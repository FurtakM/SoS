// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41683 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42134 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31775 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31775 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31775 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32238 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42053 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43001 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41962 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41962 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32238 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32238 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32238 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 70252 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31291 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31291 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31291 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31291 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32284 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41962 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31132 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41962 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31132 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41962 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31132 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41962 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31132 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41962 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42053 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41962 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41962 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41962 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41962 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41962 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41962 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41962 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41962 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41962 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41962 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41962 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41962 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31132 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31132 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31132 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31132 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31132 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31132 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31132 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31132 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31132 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31132 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31132 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31132 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32063 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31291 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31775 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31775 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32165 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42053 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41962 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41962 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41962 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41962 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42053 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28640: LD_EXP 39
28644: PUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL_OW 255
28654: ARRAY
28655: IFFALSE 29382
// begin side := GetSide ( veh ) ;
28657: LD_ADDR_VAR 0 4
28661: PUSH
28662: LD_VAR 0 1
28666: PPUSH
28667: CALL_OW 255
28671: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28672: LD_ADDR_VAR 0 6
28676: PUSH
28677: LD_VAR 0 1
28681: PPUSH
28682: CALL_OW 265
28686: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28687: LD_ADDR_VAR 0 7
28691: PUSH
28692: LD_VAR 0 1
28696: PPUSH
28697: CALL_OW 262
28701: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28702: LD_ADDR_VAR 0 8
28706: PUSH
28707: LD_VAR 0 1
28711: PPUSH
28712: CALL_OW 263
28716: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28717: LD_ADDR_VAR 0 9
28721: PUSH
28722: LD_VAR 0 1
28726: PPUSH
28727: CALL_OW 264
28731: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28732: LD_STRING VehicleConstructed [side: 
28734: PUSH
28735: LD_VAR 0 4
28739: STR
28740: PUSH
28741: LD_STRING ; id:
28743: STR
28744: PUSH
28745: LD_VAR 0 1
28749: STR
28750: PUSH
28751: LD_STRING ; components: [
28753: STR
28754: PUSH
28755: LD_VAR 0 6
28759: STR
28760: PUSH
28761: LD_STRING , 
28763: STR
28764: PUSH
28765: LD_VAR 0 7
28769: STR
28770: PUSH
28771: LD_STRING , 
28773: STR
28774: PUSH
28775: LD_VAR 0 8
28779: STR
28780: PUSH
28781: LD_STRING , 
28783: STR
28784: PUSH
28785: LD_VAR 0 9
28789: STR
28790: PUSH
28791: LD_STRING ]]
28793: STR
28794: PPUSH
28795: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28799: LD_VAR 0 1
28803: PPUSH
28804: CALL_OW 264
28808: PUSH
28809: LD_INT 13
28811: PUSH
28812: LD_INT 12
28814: PUSH
28815: LD_INT 14
28817: PUSH
28818: LD_INT 51
28820: PUSH
28821: LD_INT 53
28823: PUSH
28824: LD_INT 52
28826: PUSH
28827: LD_INT 32
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: IN
28839: NOT
28840: IFFALSE 28882
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28842: LD_ADDR_EXP 59
28846: PUSH
28847: LD_EXP 59
28851: PPUSH
28852: LD_VAR 0 4
28856: PPUSH
28857: LD_EXP 59
28861: PUSH
28862: LD_VAR 0 4
28866: ARRAY
28867: PUSH
28868: LD_INT 1
28870: PLUS
28871: PPUSH
28872: LD_VAR 0 1
28876: PPUSH
28877: CALL 31132 0 4
28881: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28882: LD_VAR 0 1
28886: PPUSH
28887: CALL_OW 264
28891: PUSH
28892: LD_INT 31
28894: EQUAL
28895: IFFALSE 28914
// SetTag ( GetDriver ( veh ) , 9 ) ;
28897: LD_VAR 0 1
28901: PPUSH
28902: CALL 31775 0 1
28906: PPUSH
28907: LD_INT 9
28909: PPUSH
28910: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28914: LD_VAR 0 1
28918: PPUSH
28919: CALL_OW 264
28923: PUSH
28924: LD_INT 14
28926: PUSH
28927: LD_INT 53
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: IN
28934: IFFALSE 28971
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28936: LD_ADDR_EXP 42
28940: PUSH
28941: LD_EXP 42
28945: PPUSH
28946: LD_VAR 0 1
28950: PPUSH
28951: CALL_OW 255
28955: PPUSH
28956: LD_INT 2
28958: PPUSH
28959: LD_VAR 0 1
28963: PPUSH
28964: CALL 31132 0 4
28968: ST_TO_ADDR
// exit ;
28969: GO 29382
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 265
28980: PUSH
28981: LD_EXP 66
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: PUSH
28997: LD_VAR 0 1
29001: PPUSH
29002: CALL_OW 262
29006: PUSH
29007: LD_EXP 66
29011: PUSH
29012: LD_VAR 0 4
29016: ARRAY
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: IN
29022: AND
29023: PUSH
29024: LD_VAR 0 1
29028: PPUSH
29029: CALL_OW 263
29033: PUSH
29034: LD_EXP 66
29038: PUSH
29039: LD_VAR 0 4
29043: ARRAY
29044: PUSH
29045: LD_INT 1
29047: ARRAY
29048: IN
29049: AND
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 264
29060: PUSH
29061: LD_EXP 66
29065: PUSH
29066: LD_VAR 0 4
29070: ARRAY
29071: PUSH
29072: LD_INT 1
29074: ARRAY
29075: IN
29076: AND
29077: IFFALSE 29121
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29079: LD_ADDR_EXP 67
29083: PUSH
29084: LD_EXP 67
29088: PPUSH
29089: LD_VAR 0 4
29093: PPUSH
29094: LD_EXP 67
29098: PUSH
29099: LD_VAR 0 4
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: PLUS
29108: PPUSH
29109: LD_VAR 0 1
29113: PPUSH
29114: CALL 31132 0 4
29118: ST_TO_ADDR
// exit ;
29119: GO 29382
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29121: LD_VAR 0 6
29125: PUSH
29126: LD_EXP 69
29130: PUSH
29131: LD_VAR 0 4
29135: ARRAY
29136: PUSH
29137: LD_INT 1
29139: ARRAY
29140: EQUAL
29141: PUSH
29142: LD_VAR 0 7
29146: PUSH
29147: LD_EXP 69
29151: PUSH
29152: LD_VAR 0 4
29156: ARRAY
29157: PUSH
29158: LD_INT 2
29160: ARRAY
29161: EQUAL
29162: AND
29163: PUSH
29164: LD_VAR 0 8
29168: PUSH
29169: LD_EXP 69
29173: PUSH
29174: LD_VAR 0 4
29178: ARRAY
29179: PUSH
29180: LD_INT 3
29182: ARRAY
29183: EQUAL
29184: AND
29185: PUSH
29186: LD_VAR 0 9
29190: PUSH
29191: LD_EXP 69
29195: PUSH
29196: LD_VAR 0 4
29200: ARRAY
29201: PUSH
29202: LD_INT 4
29204: ARRAY
29205: EQUAL
29206: AND
29207: IFFALSE 29363
// begin tmp := MREG_ToAttack [ side ] ;
29209: LD_ADDR_VAR 0 5
29213: PUSH
29214: LD_EXP 69
29218: PUSH
29219: LD_VAR 0 4
29223: ARRAY
29224: ST_TO_ADDR
// for i = 1 to 4 do
29225: LD_ADDR_VAR 0 3
29229: PUSH
29230: DOUBLE
29231: LD_INT 1
29233: DEC
29234: ST_TO_ADDR
29235: LD_INT 4
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29261
// tmp := Delete ( tmp , 1 ) ;
29241: LD_ADDR_VAR 0 5
29245: PUSH
29246: LD_VAR 0 5
29250: PPUSH
29251: LD_INT 1
29253: PPUSH
29254: CALL_OW 3
29258: ST_TO_ADDR
29259: GO 29238
29261: POP
29262: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29263: LD_ADDR_EXP 69
29267: PUSH
29268: LD_EXP 69
29272: PPUSH
29273: LD_VAR 0 4
29277: PPUSH
29278: LD_VAR 0 5
29282: PPUSH
29283: CALL_OW 1
29287: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29288: LD_ADDR_EXP 71
29292: PUSH
29293: LD_EXP 71
29297: PPUSH
29298: LD_VAR 0 4
29302: PPUSH
29303: LD_EXP 71
29307: PUSH
29308: LD_VAR 0 4
29312: ARRAY
29313: PUSH
29314: LD_INT 1
29316: PLUS
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL 31132 0 4
29327: ST_TO_ADDR
// if tmp = 0 then
29328: LD_VAR 0 5
29332: PUSH
29333: LD_INT 0
29335: EQUAL
29336: IFFALSE 29361
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29338: LD_ADDR_EXP 69
29342: PUSH
29343: LD_EXP 69
29347: PPUSH
29348: LD_VAR 0 4
29352: PPUSH
29353: LD_INT 0
29355: PPUSH
29356: CALL_OW 1
29360: ST_TO_ADDR
// exit ;
29361: GO 29382
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29363: LD_VAR 0 1
29367: PPUSH
29368: CALL_OW 255
29372: PPUSH
29373: LD_VAR 0 1
29377: PPUSH
29378: CALL 25757 0 2
// end ;
29382: PPOPN 9
29384: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29385: LD_EXP 39
29389: PUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: ARRAY
29400: IFFALSE 29632
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29402: LD_STRING ApemanTamed [side: 
29404: PUSH
29405: LD_VAR 0 2
29409: PPUSH
29410: CALL_OW 255
29414: STR
29415: PUSH
29416: LD_STRING ; sci: 
29418: STR
29419: PUSH
29420: LD_VAR 0 2
29424: STR
29425: PUSH
29426: LD_STRING ; ape: 
29428: STR
29429: PUSH
29430: LD_VAR 0 1
29434: STR
29435: PUSH
29436: LD_STRING ]
29438: STR
29439: PPUSH
29440: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29444: LD_INT 11
29446: PPUSH
29447: LD_VAR 0 2
29451: PPUSH
29452: CALL_OW 255
29456: PPUSH
29457: CALL_OW 321
29461: PUSH
29462: LD_INT 2
29464: EQUAL
29465: NOT
29466: PUSH
29467: LD_INT 2
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: CALL_OW 255
29479: PPUSH
29480: CALL_OW 321
29484: PUSH
29485: LD_INT 2
29487: EQUAL
29488: NOT
29489: OR
29490: PUSH
29491: LD_VAR 0 2
29495: PPUSH
29496: CALL_OW 255
29500: PPUSH
29501: LD_INT 171
29503: PPUSH
29504: EMPTY
29505: PPUSH
29506: CALL 12370 0 3
29510: PUSH
29511: LD_INT 0
29513: EQUAL
29514: AND
29515: IFFALSE 29529
// begin SetTag ( ape , 171 ) ;
29517: LD_VAR 0 1
29521: PPUSH
29522: LD_INT 171
29524: PPUSH
29525: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29529: LD_VAR 0 2
29533: PPUSH
29534: CALL_OW 255
29538: PPUSH
29539: LD_INT 30
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PPUSH
29549: CALL 11667 0 2
29553: IFFALSE 29632
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29555: LD_VAR 0 1
29559: PPUSH
29560: LD_VAR 0 2
29564: PPUSH
29565: CALL_OW 255
29569: PPUSH
29570: LD_INT 30
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL 11667 0 2
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: CALL_OW 250
29593: PPUSH
29594: LD_VAR 0 2
29598: PPUSH
29599: CALL_OW 255
29603: PPUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL 11667 0 2
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PPUSH
29623: CALL_OW 251
29627: PPUSH
29628: CALL_OW 111
// end ;
29632: PPOPN 2
29634: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29635: LD_EXP 39
29639: PUSH
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 255
29649: ARRAY
29650: IFFALSE 29928
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29652: LD_VAR 0 2
29656: PUSH
29657: LD_VAR 0 2
29661: PPUSH
29662: CALL_OW 255
29666: PPUSH
29667: CALL 12080 0 1
29671: IN
29672: IFFALSE 29813
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 266
29683: PUSH
29684: LD_INT 0
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: IFFALSE 29724
// begin Wait ( 0 0$0.3 ) ;
29696: LD_INT 10
29698: PPUSH
29699: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29703: LD_VAR 0 2
29707: PPUSH
29708: LD_INT 16
29710: PPUSH
29711: CALL_OW 336
// ComExitBuilding ( un ) ;
29715: LD_VAR 0 2
29719: PPUSH
29720: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29724: LD_VAR 0 1
29728: PPUSH
29729: CALL_OW 266
29733: PUSH
29734: LD_INT 4
29736: PUSH
29737: LD_INT 5
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: IN
29744: IFFALSE 29813
// begin Wait ( 0 0$0.3 ) ;
29746: LD_INT 10
29748: PPUSH
29749: CALL_OW 67
// if GetTag ( un ) = 0 then
29753: LD_VAR 0 2
29757: PPUSH
29758: CALL_OW 110
29762: PUSH
29763: LD_INT 0
29765: EQUAL
29766: IFFALSE 29782
// SetClass ( un , class_apeman_soldier ) else
29768: LD_VAR 0 2
29772: PPUSH
29773: LD_INT 15
29775: PPUSH
29776: CALL_OW 336
29780: GO 29813
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29782: LD_INT 3
29784: PPUSH
29785: LD_VAR 0 2
29789: PPUSH
29790: CALL_OW 255
29794: PPUSH
29795: CALL_OW 321
29799: IFFALSE 29813
// SetClass ( un , class_apeman_kamikaze ) ;
29801: LD_VAR 0 2
29805: PPUSH
29806: LD_INT 17
29808: PPUSH
29809: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29813: LD_VAR 0 1
29817: PPUSH
29818: CALL_OW 266
29822: PUSH
29823: LD_INT 32
29825: EQUAL
29826: IFFALSE 29928
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29828: LD_ADDR_EXP 68
29832: PUSH
29833: LD_EXP 68
29837: PPUSH
29838: LD_VAR 0 1
29842: PPUSH
29843: CALL_OW 255
29847: PPUSH
29848: LD_EXP 68
29852: PUSH
29853: LD_VAR 0 1
29857: PPUSH
29858: CALL_OW 255
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: PLUS
29867: PPUSH
29868: LD_VAR 0 1
29872: PPUSH
29873: CALL 31132 0 4
29877: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29878: LD_ADDR_EXP 68
29882: PUSH
29883: LD_EXP 68
29887: PPUSH
29888: LD_VAR 0 1
29892: PPUSH
29893: CALL_OW 255
29897: PPUSH
29898: LD_EXP 68
29902: PUSH
29903: LD_VAR 0 1
29907: PPUSH
29908: CALL_OW 255
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: PLUS
29917: PPUSH
29918: LD_VAR 0 2
29922: PPUSH
29923: CALL 31132 0 4
29927: ST_TO_ADDR
// end ; end ;
29928: PPOPN 2
29930: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29931: LD_VAR 0 1
29935: PPUSH
29936: CALL 57763 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29940: LD_VAR 0 1
29944: PUSH
29945: LD_INT 22
29947: PUSH
29948: LD_INT 3
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 23
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 21
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: LIST
29979: PPUSH
29980: CALL_OW 69
29984: IN
29985: IFFALSE 30001
// player_loss := player_loss + 1 ;
29987: LD_ADDR_EXP 10
29991: PUSH
29992: LD_EXP 10
29996: PUSH
29997: LD_INT 1
29999: PLUS
30000: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30001: LD_VAR 0 1
30005: PUSH
30006: LD_INT 22
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 21
30018: PUSH
30019: LD_INT 3
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PPUSH
30030: CALL_OW 69
30034: IN
30035: PUSH
30036: LD_EXP 14
30040: NOT
30041: AND
30042: IFFALSE 30105
// begin alfa_north_triggered := true ;
30044: LD_ADDR_EXP 14
30048: PUSH
30049: LD_INT 1
30051: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30052: LD_EXP 5
30056: PPUSH
30057: LD_STRING DS4
30059: PPUSH
30060: CALL_OW 94
// Wait ( 1 1$25 ) ;
30064: LD_INT 2975
30066: PPUSH
30067: CALL_OW 67
// if not isTest then
30071: LD_EXP 1
30075: NOT
30076: IFFALSE 30105
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30078: LD_INT 20
30080: PPUSH
30081: LD_INT 5
30083: PUSH
30084: LD_INT 6
30086: PUSH
30087: LD_INT 7
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: PUSH
30095: LD_OWVAR 67
30099: ARRAY
30100: PPUSH
30101: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30105: LD_VAR 0 1
30109: PUSH
30110: LD_INT 22
30112: PUSH
30113: LD_INT 4
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 21
30122: PUSH
30123: LD_INT 3
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PPUSH
30134: CALL_OW 69
30138: IN
30139: PUSH
30140: LD_EXP 15
30144: NOT
30145: AND
30146: IFFALSE 30209
// begin alfa_south_triggered := true ;
30148: LD_ADDR_EXP 15
30152: PUSH
30153: LD_INT 1
30155: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30156: LD_EXP 4
30160: PPUSH
30161: LD_STRING DJ3
30163: PPUSH
30164: CALL_OW 94
// Wait ( 0 0$45 ) ;
30168: LD_INT 1575
30170: PPUSH
30171: CALL_OW 67
// if not isTest then
30175: LD_EXP 1
30179: NOT
30180: IFFALSE 30209
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30182: LD_INT 20
30184: PPUSH
30185: LD_INT 5
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: LD_INT 7
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: LIST
30198: PUSH
30199: LD_OWVAR 67
30203: ARRAY
30204: PPUSH
30205: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30209: LD_VAR 0 1
30213: PPUSH
30214: CALL_OW 266
30218: PUSH
30219: LD_INT 1
30221: EQUAL
30222: PUSH
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 255
30232: PUSH
30233: LD_INT 1
30235: PUSH
30236: LD_INT 4
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: IN
30243: AND
30244: IFFALSE 30253
// RaiseSailEvent ( 104 ) ;
30246: LD_INT 104
30248: PPUSH
30249: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30253: LD_EXP 39
30257: PUSH
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: ARRAY
30268: IFFALSE 30655
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30270: LD_STRING UnitDestroyed [side 
30272: PUSH
30273: LD_VAR 0 1
30277: PPUSH
30278: CALL_OW 255
30282: STR
30283: PUSH
30284: LD_STRING ; id: 
30286: STR
30287: PUSH
30288: LD_VAR 0 1
30292: STR
30293: PUSH
30294: LD_STRING ; type: 
30296: STR
30297: PUSH
30298: LD_VAR 0 1
30302: PPUSH
30303: CALL_OW 247
30307: STR
30308: PUSH
30309: LD_STRING ]
30311: STR
30312: PPUSH
30313: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30317: LD_VAR 0 1
30321: PUSH
30322: LD_VAR 0 1
30326: PPUSH
30327: CALL_OW 255
30331: PPUSH
30332: LD_INT 21
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PPUSH
30342: CALL 11667 0 2
30346: IN
30347: IFFALSE 30503
// begin if MCF_HasClass ( un ) then
30349: LD_VAR 0 1
30353: PPUSH
30354: CALL 14373 0 1
30358: IFFALSE 30503
// case MCF_HasClass ( un ) of 1 :
30360: LD_VAR 0 1
30364: PPUSH
30365: CALL 14373 0 1
30369: PUSH
30370: LD_INT 1
30372: DOUBLE
30373: EQUAL
30374: IFTRUE 30378
30376: GO 30403
30378: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30379: LD_VAR 0 1
30383: PPUSH
30384: CALL_OW 255
30388: PPUSH
30389: LD_STRING ToArm
30391: PPUSH
30392: LD_VAR 0 1
30396: PPUSH
30397: CALL 14546 0 3
30401: GO 30503
30403: LD_INT 2
30405: DOUBLE
30406: EQUAL
30407: IFTRUE 30411
30409: GO 30436
30411: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30412: LD_VAR 0 1
30416: PPUSH
30417: CALL_OW 255
30421: PPUSH
30422: LD_STRING ToDep
30424: PPUSH
30425: LD_VAR 0 1
30429: PPUSH
30430: CALL 14546 0 3
30434: GO 30503
30436: LD_INT 3
30438: DOUBLE
30439: EQUAL
30440: IFTRUE 30444
30442: GO 30469
30444: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30445: LD_VAR 0 1
30449: PPUSH
30450: CALL_OW 255
30454: PPUSH
30455: LD_STRING ToFac
30457: PPUSH
30458: LD_VAR 0 1
30462: PPUSH
30463: CALL 14546 0 3
30467: GO 30503
30469: LD_INT 4
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30502
30477: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30478: LD_VAR 0 1
30482: PPUSH
30483: CALL_OW 255
30487: PPUSH
30488: LD_STRING ToLab
30490: PPUSH
30491: LD_VAR 0 1
30495: PPUSH
30496: CALL 14546 0 3
30500: GO 30503
30502: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30503: LD_VAR 0 1
30507: PUSH
30508: LD_EXP 67
30512: PUSH
30513: LD_VAR 0 1
30517: PPUSH
30518: CALL_OW 255
30522: ARRAY
30523: IN
30524: IFFALSE 30609
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30526: LD_ADDR_EXP 67
30530: PUSH
30531: LD_EXP 67
30535: PPUSH
30536: LD_VAR 0 1
30540: PPUSH
30541: LD_INT 0
30543: PPUSH
30544: CALL 31291 0 3
30548: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30549: LD_VAR 0 1
30553: PPUSH
30554: CALL_OW 255
30558: PPUSH
30559: LD_VAR 0 1
30563: PPUSH
30564: CALL_OW 265
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 262
30578: PUSH
30579: LD_VAR 0 1
30583: PPUSH
30584: CALL_OW 263
30588: PUSH
30589: LD_VAR 0 1
30593: PPUSH
30594: CALL_OW 264
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: PPUSH
30605: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30609: LD_VAR 0 1
30613: PUSH
30614: LD_EXP 71
30618: PUSH
30619: LD_VAR 0 1
30623: PPUSH
30624: CALL_OW 255
30628: ARRAY
30629: IN
30630: IFFALSE 30655
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30632: LD_ADDR_EXP 71
30636: PUSH
30637: LD_EXP 71
30641: PPUSH
30642: LD_VAR 0 1
30646: PPUSH
30647: LD_INT 0
30649: PPUSH
30650: CALL 31291 0 3
30654: ST_TO_ADDR
// end ; end ;
30655: PPOPN 1
30657: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30658: LD_EXP 39
30662: PUSH
30663: LD_VAR 0 2
30667: PPUSH
30668: CALL_OW 255
30672: ARRAY
30673: IFFALSE 30845
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30675: LD_VAR 0 2
30679: PUSH
30680: LD_EXP 68
30684: PUSH
30685: LD_VAR 0 2
30689: PPUSH
30690: CALL_OW 255
30694: ARRAY
30695: IN
30696: PUSH
30697: LD_VAR 0 1
30701: PPUSH
30702: CALL_OW 266
30706: PUSH
30707: LD_INT 32
30709: PUSH
30710: LD_INT 31
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: IN
30717: AND
30718: IFFALSE 30818
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30720: LD_ADDR_EXP 68
30724: PUSH
30725: LD_EXP 68
30729: PPUSH
30730: LD_VAR 0 1
30734: PPUSH
30735: LD_INT 0
30737: PPUSH
30738: CALL 31291 0 3
30742: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30743: LD_ADDR_EXP 68
30747: PUSH
30748: LD_EXP 68
30752: PPUSH
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL 31291 0 3
30765: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30766: LD_EXP 68
30770: PUSH
30771: LD_VAR 0 2
30775: PPUSH
30776: CALL_OW 255
30780: ARRAY
30781: PUSH
30782: LD_STRING 
30784: EQUAL
30785: IFFALSE 30818
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30787: LD_ADDR_EXP 68
30791: PUSH
30792: LD_EXP 68
30796: PPUSH
30797: LD_VAR 0 2
30801: PPUSH
30802: CALL_OW 255
30806: PPUSH
30807: LD_INT 1
30809: PPUSH
30810: LD_INT 0
30812: PPUSH
30813: CALL 31132 0 4
30817: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30818: LD_VAR 0 1
30822: PPUSH
30823: CALL_OW 266
30827: PUSH
30828: LD_INT 36
30830: IN
30831: IFFALSE 30845
// SetTag ( un , 0 ) ;
30833: LD_VAR 0 2
30837: PPUSH
30838: LD_INT 0
30840: PPUSH
30841: CALL_OW 109
// end ;
30845: PPOPN 2
30847: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30848: LD_EXP 39
30852: PUSH
30853: LD_VAR 0 1
30857: PPUSH
30858: CALL_OW 255
30862: ARRAY
30863: IFFALSE 30889
// begin if GetControl ( un ) = control_remote then
30865: LD_VAR 0 1
30869: PPUSH
30870: CALL_OW 263
30874: PUSH
30875: LD_INT 2
30877: EQUAL
30878: IFFALSE 30889
// ComUnlink ( un ) ;
30880: LD_VAR 0 1
30884: PPUSH
30885: CALL_OW 136
// end ;
30889: PPOPN 1
30891: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30892: LD_EXP 39
30896: PUSH
30897: LD_VAR 0 1
30901: PPUSH
30902: CALL_OW 255
30906: ARRAY
30907: IFFALSE 30936
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30909: LD_VAR 0 2
30913: PPUSH
30914: CALL_OW 264
30918: PUSH
30919: LD_INT 31
30921: IN
30922: IFFALSE 30936
// SetTag ( driver , 0 ) ;
30924: LD_VAR 0 1
30928: PPUSH
30929: LD_INT 0
30931: PPUSH
30932: CALL_OW 109
// end ;
30936: PPOPN 4
30938: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30939: LD_INT 0
30941: PPUSH
30942: PPUSH
30943: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30944: LD_ADDR_VAR 0 3
30948: PUSH
30949: LD_VAR 0 1
30953: PPUSH
30954: CALL_OW 269
30958: ST_TO_ADDR
// x := GetX ( building ) ;
30959: LD_ADDR_VAR 0 4
30963: PUSH
30964: LD_VAR 0 1
30968: PPUSH
30969: CALL_OW 250
30973: ST_TO_ADDR
// y := GetY ( building ) ;
30974: LD_ADDR_VAR 0 5
30978: PUSH
30979: LD_VAR 0 1
30983: PPUSH
30984: CALL_OW 251
30988: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30989: LD_ADDR_EXP 43
30993: PUSH
30994: LD_EXP 43
30998: PPUSH
30999: LD_VAR 0 1
31003: PPUSH
31004: CALL_OW 255
31008: PPUSH
31009: LD_VAR 0 3
31013: PPUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_VAR 0 5
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PPUSH
31028: CALL 42053 0 4
31032: ST_TO_ADDR
// end ;
31033: PPOPN 5
31035: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31036: LD_VAR 0 1
31040: PUSH
31041: LD_EXP 30
31045: IN
31046: NOT
31047: IFFALSE 31095
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31049: LD_ADDR_EXP 30
31053: PUSH
31054: LD_EXP 30
31058: PPUSH
31059: LD_EXP 30
31063: PUSH
31064: LD_INT 1
31066: PLUS
31067: PPUSH
31068: LD_VAR 0 1
31072: PPUSH
31073: CALL_OW 2
31077: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31078: LD_STRING DestinationUnrechable. [unit: 
31080: PUSH
31081: LD_VAR 0 1
31085: STR
31086: PUSH
31087: LD_STRING ]
31089: STR
31090: PPUSH
31091: CALL 8055 0 1
// end ; end ;
31095: PPOPN 1
31097: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31098: LD_VAR 0 1
31102: PPUSH
31103: LD_VAR 0 2
31107: PPUSH
31108: LD_VAR 0 3
31112: PPUSH
31113: CALL 57861 0 3
// end ;
31117: PPOPN 3
31119: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL 57869 0 1
// end ; end_of_file
31129: PPOPN 1
31131: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31132: LD_INT 0
31134: PPUSH
31135: PPUSH
31136: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31137: LD_ADDR_VAR 0 7
31141: PUSH
31142: LD_VAR 0 1
31146: PUSH
31147: LD_VAR 0 2
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: LD_VAR 0 4
31162: PPUSH
31163: CALL_OW 1
31167: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31168: LD_ADDR_VAR 0 1
31172: PUSH
31173: LD_VAR 0 1
31177: PPUSH
31178: LD_VAR 0 2
31182: PPUSH
31183: LD_VAR 0 7
31187: PPUSH
31188: CALL_OW 1
31192: ST_TO_ADDR
// result := tab ;
31193: LD_ADDR_VAR 0 5
31197: PUSH
31198: LD_VAR 0 1
31202: ST_TO_ADDR
// end ;
31203: LD_VAR 0 5
31207: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31208: LD_INT 0
31210: PPUSH
31211: PPUSH
31212: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31213: LD_ADDR_VAR 0 5
31217: PUSH
31218: LD_VAR 0 1
31222: PUSH
31223: LD_VAR 0 2
31227: PUSH
31228: LD_INT 1
31230: ARRAY
31231: ARRAY
31232: PPUSH
31233: LD_VAR 0 2
31237: PUSH
31238: LD_INT 2
31240: ARRAY
31241: PPUSH
31242: CALL_OW 3
31246: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31247: LD_ADDR_VAR 0 1
31251: PUSH
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_VAR 0 2
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PPUSH
31266: LD_VAR 0 5
31270: PPUSH
31271: CALL_OW 1
31275: ST_TO_ADDR
// result := tab ;
31276: LD_ADDR_VAR 0 3
31280: PUSH
31281: LD_VAR 0 1
31285: ST_TO_ADDR
// end ;
31286: LD_VAR 0 3
31290: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31291: LD_INT 0
31293: PPUSH
31294: PPUSH
31295: PPUSH
31296: PPUSH
// i := 1 ;
31297: LD_ADDR_VAR 0 5
31301: PUSH
31302: LD_INT 1
31304: ST_TO_ADDR
// while ( i <= tab ) do
31305: LD_VAR 0 5
31309: PUSH
31310: LD_VAR 0 1
31314: LESSEQUAL
31315: IFFALSE 31690
// begin if not tab [ i ] then
31317: LD_VAR 0 1
31321: PUSH
31322: LD_VAR 0 5
31326: ARRAY
31327: NOT
31328: IFFALSE 31332
// break ;
31330: GO 31690
// if value in tab then
31332: LD_VAR 0 2
31336: PUSH
31337: LD_VAR 0 1
31341: IN
31342: IFFALSE 31455
// begin if not mode then
31344: LD_VAR 0 3
31348: NOT
31349: IFFALSE 31369
// tab := tab diff value else
31351: LD_ADDR_VAR 0 1
31355: PUSH
31356: LD_VAR 0 1
31360: PUSH
31361: LD_VAR 0 2
31365: DIFF
31366: ST_TO_ADDR
31367: GO 31431
// for j = 1 to tab do
31369: LD_ADDR_VAR 0 6
31373: PUSH
31374: DOUBLE
31375: LD_INT 1
31377: DEC
31378: ST_TO_ADDR
31379: LD_VAR 0 1
31383: PUSH
31384: FOR_TO
31385: IFFALSE 31429
// if tab [ j ] = value then
31387: LD_VAR 0 1
31391: PUSH
31392: LD_VAR 0 6
31396: ARRAY
31397: PUSH
31398: LD_VAR 0 2
31402: EQUAL
31403: IFFALSE 31427
// begin tab := Delete ( tab , j ) ;
31405: LD_ADDR_VAR 0 1
31409: PUSH
31410: LD_VAR 0 1
31414: PPUSH
31415: LD_VAR 0 6
31419: PPUSH
31420: CALL_OW 3
31424: ST_TO_ADDR
// break ;
31425: GO 31429
// end ;
31427: GO 31384
31429: POP
31430: POP
// i := i - 1 ;
31431: LD_ADDR_VAR 0 5
31435: PUSH
31436: LD_VAR 0 5
31440: PUSH
31441: LD_INT 1
31443: MINUS
31444: ST_TO_ADDR
// if mode then
31445: LD_VAR 0 3
31449: IFFALSE 31453
// break ;
31451: GO 31690
// end else
31453: GO 31674
// if tab [ i ] and value in tab [ i ] then
31455: LD_VAR 0 1
31459: PUSH
31460: LD_VAR 0 5
31464: ARRAY
31465: PUSH
31466: LD_VAR 0 2
31470: PUSH
31471: LD_VAR 0 1
31475: PUSH
31476: LD_VAR 0 5
31480: ARRAY
31481: IN
31482: AND
31483: IFFALSE 31674
// begin if not mode then
31485: LD_VAR 0 3
31489: NOT
31490: IFFALSE 31516
// tmp := tab [ i ] diff value else
31492: LD_ADDR_VAR 0 7
31496: PUSH
31497: LD_VAR 0 1
31501: PUSH
31502: LD_VAR 0 5
31506: ARRAY
31507: PUSH
31508: LD_VAR 0 2
31512: DIFF
31513: ST_TO_ADDR
31514: GO 31596
// for j = 1 to tab [ i ] do
31516: LD_ADDR_VAR 0 6
31520: PUSH
31521: DOUBLE
31522: LD_INT 1
31524: DEC
31525: ST_TO_ADDR
31526: LD_VAR 0 1
31530: PUSH
31531: LD_VAR 0 5
31535: ARRAY
31536: PUSH
31537: FOR_TO
31538: IFFALSE 31594
// if value = tab [ i ] [ j ] then
31540: LD_VAR 0 2
31544: PUSH
31545: LD_VAR 0 1
31549: PUSH
31550: LD_VAR 0 5
31554: ARRAY
31555: PUSH
31556: LD_VAR 0 6
31560: ARRAY
31561: EQUAL
31562: IFFALSE 31592
// begin tmp := Delete ( tab [ i ] , j ) ;
31564: LD_ADDR_VAR 0 7
31568: PUSH
31569: LD_VAR 0 1
31573: PUSH
31574: LD_VAR 0 5
31578: ARRAY
31579: PPUSH
31580: LD_VAR 0 6
31584: PPUSH
31585: CALL_OW 3
31589: ST_TO_ADDR
// break ;
31590: GO 31594
// end ;
31592: GO 31537
31594: POP
31595: POP
// if tmp = [ ] then
31596: LD_VAR 0 7
31600: PUSH
31601: EMPTY
31602: EQUAL
31603: IFFALSE 31627
// begin tab := Delete ( tab , i ) ;
31605: LD_ADDR_VAR 0 1
31609: PUSH
31610: LD_VAR 0 1
31614: PPUSH
31615: LD_VAR 0 5
31619: PPUSH
31620: CALL_OW 3
31624: ST_TO_ADDR
// end else
31625: GO 31652
// tab := Replace ( tab , i , tmp ) ;
31627: LD_ADDR_VAR 0 1
31631: PUSH
31632: LD_VAR 0 1
31636: PPUSH
31637: LD_VAR 0 5
31641: PPUSH
31642: LD_VAR 0 7
31646: PPUSH
31647: CALL_OW 1
31651: ST_TO_ADDR
// i := i - 1 ;
31652: LD_ADDR_VAR 0 5
31656: PUSH
31657: LD_VAR 0 5
31661: PUSH
31662: LD_INT 1
31664: MINUS
31665: ST_TO_ADDR
// if mode then
31666: LD_VAR 0 3
31670: IFFALSE 31674
// break ;
31672: GO 31690
// end ; i := i + 1 ;
31674: LD_ADDR_VAR 0 5
31678: PUSH
31679: LD_VAR 0 5
31683: PUSH
31684: LD_INT 1
31686: PLUS
31687: ST_TO_ADDR
// end ;
31688: GO 31305
// result := tab ;
31690: LD_ADDR_VAR 0 4
31694: PUSH
31695: LD_VAR 0 1
31699: ST_TO_ADDR
// end ;
31700: LD_VAR 0 4
31704: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31705: LD_INT 0
31707: PPUSH
31708: PPUSH
// for i = 1 to values do
31709: LD_ADDR_VAR 0 4
31713: PUSH
31714: DOUBLE
31715: LD_INT 1
31717: DEC
31718: ST_TO_ADDR
31719: LD_VAR 0 2
31723: PUSH
31724: FOR_TO
31725: IFFALSE 31758
// tab := Remove ( tab , values [ i ] , false ) ;
31727: LD_ADDR_VAR 0 1
31731: PUSH
31732: LD_VAR 0 1
31736: PPUSH
31737: LD_VAR 0 2
31741: PUSH
31742: LD_VAR 0 4
31746: ARRAY
31747: PPUSH
31748: LD_INT 0
31750: PPUSH
31751: CALL 31291 0 3
31755: ST_TO_ADDR
31756: GO 31724
31758: POP
31759: POP
// result := tab ;
31760: LD_ADDR_VAR 0 3
31764: PUSH
31765: LD_VAR 0 1
31769: ST_TO_ADDR
// end ;
31770: LD_VAR 0 3
31774: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31775: LD_INT 0
31777: PPUSH
31778: PPUSH
31779: PPUSH
// if not GetControl ( veh ) = control_manual then
31780: LD_VAR 0 1
31784: PPUSH
31785: CALL_OW 263
31789: PUSH
31790: LD_INT 1
31792: EQUAL
31793: NOT
31794: IFFALSE 31806
// result := false else
31796: LD_ADDR_VAR 0 2
31800: PUSH
31801: LD_INT 0
31803: ST_TO_ADDR
31804: GO 31951
// if veh in FilterAllUnits ( [ f_empty ] ) then
31806: LD_VAR 0 1
31810: PUSH
31811: LD_INT 58
31813: PUSH
31814: EMPTY
31815: LIST
31816: PPUSH
31817: CALL_OW 69
31821: IN
31822: IFFALSE 31834
// result := false else
31824: LD_ADDR_VAR 0 2
31828: PUSH
31829: LD_INT 0
31831: ST_TO_ADDR
31832: GO 31951
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31834: LD_ADDR_VAR 0 4
31838: PUSH
31839: LD_INT 22
31841: PUSH
31842: LD_VAR 0 1
31846: PPUSH
31847: CALL_OW 255
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 55
31858: PUSH
31859: EMPTY
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PPUSH
31866: CALL_OW 69
31870: ST_TO_ADDR
// if not filter then
31871: LD_VAR 0 4
31875: NOT
31876: IFFALSE 31888
// result := false else
31878: LD_ADDR_VAR 0 2
31882: PUSH
31883: LD_INT 0
31885: ST_TO_ADDR
31886: GO 31951
// for i = 1 to filter do
31888: LD_ADDR_VAR 0 3
31892: PUSH
31893: DOUBLE
31894: LD_INT 1
31896: DEC
31897: ST_TO_ADDR
31898: LD_VAR 0 4
31902: PUSH
31903: FOR_TO
31904: IFFALSE 31949
// if IsDriver ( filter [ i ] ) = veh then
31906: LD_VAR 0 4
31910: PUSH
31911: LD_VAR 0 3
31915: ARRAY
31916: PPUSH
31917: CALL 96746 0 1
31921: PUSH
31922: LD_VAR 0 1
31926: EQUAL
31927: IFFALSE 31947
// begin result := filter [ i ] ;
31929: LD_ADDR_VAR 0 2
31933: PUSH
31934: LD_VAR 0 4
31938: PUSH
31939: LD_VAR 0 3
31943: ARRAY
31944: ST_TO_ADDR
// break ;
31945: GO 31949
// end ;
31947: GO 31903
31949: POP
31950: POP
// end ; end ;
31951: LD_VAR 0 2
31955: RET
// export function Compare ( val1 , val2 ) ; begin
31956: LD_INT 0
31958: PPUSH
// if val1 = val2 then
31959: LD_VAR 0 1
31963: PUSH
31964: LD_VAR 0 2
31968: EQUAL
31969: IFFALSE 31981
// result := true else
31971: LD_ADDR_VAR 0 3
31975: PUSH
31976: LD_INT 1
31978: ST_TO_ADDR
31979: GO 31989
// result := false ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_INT 0
31988: ST_TO_ADDR
// end ;
31989: LD_VAR 0 3
31993: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31994: LD_INT 0
31996: PPUSH
31997: PPUSH
// result := false ;
31998: LD_ADDR_VAR 0 3
32002: PUSH
32003: LD_INT 0
32005: ST_TO_ADDR
// for j = 1 to e2 do
32006: LD_ADDR_VAR 0 4
32010: PUSH
32011: DOUBLE
32012: LD_INT 1
32014: DEC
32015: ST_TO_ADDR
32016: LD_VAR 0 2
32020: PUSH
32021: FOR_TO
32022: IFFALSE 32056
// if Compare ( e1 , e2 [ j ] ) then
32024: LD_VAR 0 1
32028: PPUSH
32029: LD_VAR 0 2
32033: PUSH
32034: LD_VAR 0 4
32038: ARRAY
32039: PPUSH
32040: CALL 31956 0 2
32044: IFFALSE 32054
// result := true ;
32046: LD_ADDR_VAR 0 3
32050: PUSH
32051: LD_INT 1
32053: ST_TO_ADDR
32054: GO 32021
32056: POP
32057: POP
// end ;
32058: LD_VAR 0 3
32062: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32063: LD_INT 0
32065: PPUSH
32066: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32067: LD_VAR 0 1
32071: PPUSH
32072: LD_STRING C
32074: PUSH
32075: LD_VAR 0 2
32079: PUSH
32080: LD_VAR 0 3
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: LD_INT 0
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: PUSH
32106: LD_STRING v
32108: PUSH
32109: LD_VAR 0 4
32113: PPUSH
32114: CALL_OW 250
32118: PUSH
32119: LD_VAR 0 4
32123: PPUSH
32124: CALL_OW 251
32128: PUSH
32129: LD_VAR 0 4
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 446
// end ;
32160: LD_VAR 0 5
32164: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32165: LD_INT 0
32167: PPUSH
32168: PPUSH
32169: PPUSH
// linked := UnitsLinked ( unit ) ;
32170: LD_ADDR_VAR 0 4
32174: PUSH
32175: LD_VAR 0 1
32179: PPUSH
32180: CALL_OW 432
32184: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_VAR 0 1
32194: PPUSH
32195: LD_INT 3
32197: PPUSH
32198: CALL_OW 259
32202: ST_TO_ADDR
// if sk > linked then
32203: LD_VAR 0 3
32207: PUSH
32208: LD_VAR 0 4
32212: GREATER
32213: IFFALSE 32225
// result := true else
32215: LD_ADDR_VAR 0 2
32219: PUSH
32220: LD_INT 1
32222: ST_TO_ADDR
32223: GO 32233
// result := false ;
32225: LD_ADDR_VAR 0 2
32229: PUSH
32230: LD_INT 0
32232: ST_TO_ADDR
// end ;
32233: LD_VAR 0 2
32237: RET
// export function NotTask ( unit ) ; begin
32238: LD_INT 0
32240: PPUSH
// result := true ;
32241: LD_ADDR_VAR 0 2
32245: PUSH
32246: LD_INT 1
32248: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 437
32258: PUSH
32259: LD_VAR 0 1
32263: PPUSH
32264: CALL_OW 314
32268: OR
32269: IFFALSE 32279
// result := false ;
32271: LD_ADDR_VAR 0 2
32275: PUSH
32276: LD_INT 0
32278: ST_TO_ADDR
// end ;
32279: LD_VAR 0 2
32283: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32284: LD_INT 0
32286: PPUSH
32287: PPUSH
32288: PPUSH
32289: PPUSH
32290: PPUSH
// dist := 99999 ;
32291: LD_ADDR_VAR 0 7
32295: PUSH
32296: LD_INT 99999
32298: ST_TO_ADDR
// un := - 1 ;
32299: LD_ADDR_VAR 0 6
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: ST_TO_ADDR
// if units1 and units2 then
32308: LD_VAR 0 1
32312: PUSH
32313: LD_VAR 0 2
32317: AND
32318: IFFALSE 32406
// for i in units1 do
32320: LD_ADDR_VAR 0 4
32324: PUSH
32325: LD_VAR 0 1
32329: PUSH
32330: FOR_IN
32331: IFFALSE 32404
// for j in units2 do
32333: LD_ADDR_VAR 0 5
32337: PUSH
32338: LD_VAR 0 2
32342: PUSH
32343: FOR_IN
32344: IFFALSE 32400
// if GetDistUnits ( i , j ) < dist then
32346: LD_VAR 0 4
32350: PPUSH
32351: LD_VAR 0 5
32355: PPUSH
32356: CALL_OW 296
32360: PUSH
32361: LD_VAR 0 7
32365: LESS
32366: IFFALSE 32398
// begin un := i ;
32368: LD_ADDR_VAR 0 6
32372: PUSH
32373: LD_VAR 0 4
32377: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32378: LD_ADDR_VAR 0 7
32382: PUSH
32383: LD_VAR 0 4
32387: PPUSH
32388: LD_VAR 0 5
32392: PPUSH
32393: CALL_OW 296
32397: ST_TO_ADDR
// end ;
32398: GO 32343
32400: POP
32401: POP
32402: GO 32330
32404: POP
32405: POP
// result := [ un , dist ] ;
32406: LD_ADDR_VAR 0 3
32410: PUSH
32411: LD_VAR 0 6
32415: PUSH
32416: LD_VAR 0 7
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: ST_TO_ADDR
// end ;
32425: LD_VAR 0 3
32429: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32430: LD_INT 0
32432: PPUSH
32433: PPUSH
32434: PPUSH
32435: PPUSH
32436: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32437: LD_VAR 0 1
32441: NOT
32442: PUSH
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 256
32452: PUSH
32453: LD_INT 250
32455: LESS
32456: OR
32457: PUSH
32458: LD_VAR 0 1
32462: PPUSH
32463: CALL_OW 314
32467: PUSH
32468: LD_VAR 0 1
32472: PPUSH
32473: CALL_OW 261
32477: PUSH
32478: LD_INT 20
32480: GREATER
32481: AND
32482: OR
32483: IFFALSE 32487
// exit ;
32485: GO 32861
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32487: LD_VAR 0 1
32491: PPUSH
32492: CALL_OW 261
32496: PUSH
32497: LD_INT 20
32499: LESS
32500: PUSH
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 110
32510: PUSH
32511: LD_INT 21
32513: EQUAL
32514: NOT
32515: AND
32516: IFFALSE 32552
// begin ComStop ( bulldozer ) ;
32518: LD_VAR 0 1
32522: PPUSH
32523: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32527: LD_VAR 0 1
32531: PPUSH
32532: LD_INT 21
32534: PPUSH
32535: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32539: LD_VAR 0 1
32543: PPUSH
32544: CALL 26294 0 1
// exit ;
32548: GO 32861
// end else
32550: GO 32579
// if GetFuel ( bulldozer ) > 20 then
32552: LD_VAR 0 1
32556: PPUSH
32557: CALL_OW 261
32561: PUSH
32562: LD_INT 20
32564: GREATER
32565: IFFALSE 32579
// SetTag ( bulldozer , 0 ) ;
32567: LD_VAR 0 1
32571: PPUSH
32572: LD_INT 0
32574: PPUSH
32575: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32579: LD_ADDR_VAR 0 5
32583: PUSH
32584: LD_VAR 0 2
32588: PPUSH
32589: CALL_OW 353
32593: ST_TO_ADDR
// tmp := [ ] ;
32594: LD_ADDR_VAR 0 6
32598: PUSH
32599: EMPTY
32600: ST_TO_ADDR
// for i = 1 to list do
32601: LD_ADDR_VAR 0 4
32605: PUSH
32606: DOUBLE
32607: LD_INT 1
32609: DEC
32610: ST_TO_ADDR
32611: LD_VAR 0 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32715
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32619: LD_VAR 0 5
32623: PUSH
32624: LD_VAR 0 4
32628: ARRAY
32629: PUSH
32630: LD_INT 1
32632: ARRAY
32633: PPUSH
32634: LD_VAR 0 5
32638: PUSH
32639: LD_VAR 0 4
32643: ARRAY
32644: PUSH
32645: LD_INT 2
32647: ARRAY
32648: PPUSH
32649: CALL_OW 554
32653: IFFALSE 32713
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32655: LD_ADDR_VAR 0 6
32659: PUSH
32660: LD_VAR 0 6
32664: PPUSH
32665: LD_VAR 0 6
32669: PUSH
32670: LD_INT 1
32672: PLUS
32673: PPUSH
32674: LD_VAR 0 5
32678: PUSH
32679: LD_VAR 0 4
32683: ARRAY
32684: PUSH
32685: LD_INT 1
32687: ARRAY
32688: PUSH
32689: LD_VAR 0 5
32693: PUSH
32694: LD_VAR 0 4
32698: ARRAY
32699: PUSH
32700: LD_INT 2
32702: ARRAY
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PPUSH
32708: CALL_OW 1
32712: ST_TO_ADDR
// end ;
32713: GO 32616
32715: POP
32716: POP
// ComStop ( bulldozer ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32726: LD_ADDR_VAR 0 7
32730: PUSH
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 250
32740: PUSH
32741: LD_VAR 0 1
32745: PPUSH
32746: CALL_OW 251
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: ST_TO_ADDR
// for i = tmp downto 1 do
32755: LD_ADDR_VAR 0 4
32759: PUSH
32760: DOUBLE
32761: LD_VAR 0 6
32765: INC
32766: ST_TO_ADDR
32767: LD_INT 1
32769: PUSH
32770: FOR_DOWNTO
32771: IFFALSE 32859
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32773: LD_ADDR_VAR 0 7
32777: PUSH
32778: LD_VAR 0 7
32782: PUSH
32783: LD_INT 1
32785: ARRAY
32786: PPUSH
32787: LD_VAR 0 7
32791: PUSH
32792: LD_INT 2
32794: ARRAY
32795: PPUSH
32796: LD_VAR 0 6
32800: PPUSH
32801: CALL 32962 0 3
32805: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: LD_VAR 0 7
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: PPUSH
32820: LD_VAR 0 7
32824: PUSH
32825: LD_INT 2
32827: ARRAY
32828: PPUSH
32829: CALL 32866 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32833: LD_ADDR_VAR 0 6
32837: PUSH
32838: LD_VAR 0 6
32842: PPUSH
32843: LD_VAR 0 7
32847: PUSH
32848: LD_INT 3
32850: ARRAY
32851: PPUSH
32852: CALL_OW 3
32856: ST_TO_ADDR
// end ;
32857: GO 32770
32859: POP
32860: POP
// end ;
32861: LD_VAR 0 3
32865: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32866: LD_INT 0
32868: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32869: LD_VAR 0 2
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL_OW 351
32883: PUSH
32884: LD_VAR 0 2
32888: PPUSH
32889: LD_VAR 0 3
32893: PPUSH
32894: CALL_OW 554
32898: AND
32899: PUSH
32900: LD_VAR 0 2
32904: PPUSH
32905: LD_VAR 0 3
32909: PPUSH
32910: CALL_OW 488
32914: AND
32915: PUSH
32916: LD_VAR 0 2
32920: PPUSH
32921: LD_VAR 0 3
32925: PPUSH
32926: CALL_OW 428
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: EQUAL
32935: AND
32936: IFFALSE 32957
// AddComMoveXY ( bulldozer , x , y ) ;
32938: LD_VAR 0 1
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL_OW 171
// end ;
32957: LD_VAR 0 4
32961: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32962: LD_INT 0
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
32969: PPUSH
32970: PPUSH
// dist := 99999 ;
32971: LD_ADDR_VAR 0 6
32975: PUSH
32976: LD_INT 99999
32978: ST_TO_ADDR
// for i = 1 to list do
32979: LD_ADDR_VAR 0 5
32983: PUSH
32984: DOUBLE
32985: LD_INT 1
32987: DEC
32988: ST_TO_ADDR
32989: LD_VAR 0 3
32993: PUSH
32994: FOR_TO
32995: IFFALSE 33133
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32997: LD_ADDR_VAR 0 7
33001: PUSH
33002: LD_VAR 0 1
33006: PPUSH
33007: LD_VAR 0 2
33011: PPUSH
33012: LD_VAR 0 3
33016: PUSH
33017: LD_VAR 0 5
33021: ARRAY
33022: PUSH
33023: LD_INT 1
33025: ARRAY
33026: PPUSH
33027: LD_VAR 0 3
33031: PUSH
33032: LD_VAR 0 5
33036: ARRAY
33037: PUSH
33038: LD_INT 2
33040: ARRAY
33041: PPUSH
33042: CALL_OW 298
33046: ST_TO_ADDR
// if d = 0 then
33047: LD_VAR 0 7
33051: PUSH
33052: LD_INT 0
33054: EQUAL
33055: IFFALSE 33059
// continue ;
33057: GO 32994
// if d < dist then
33059: LD_VAR 0 7
33063: PUSH
33064: LD_VAR 0 6
33068: LESS
33069: IFFALSE 33131
// begin _x := list [ i ] [ 1 ] ;
33071: LD_ADDR_VAR 0 8
33075: PUSH
33076: LD_VAR 0 3
33080: PUSH
33081: LD_VAR 0 5
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: ARRAY
33090: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33091: LD_ADDR_VAR 0 9
33095: PUSH
33096: LD_VAR 0 3
33100: PUSH
33101: LD_VAR 0 5
33105: ARRAY
33106: PUSH
33107: LD_INT 2
33109: ARRAY
33110: ST_TO_ADDR
// _i := i ;
33111: LD_ADDR_VAR 0 10
33115: PUSH
33116: LD_VAR 0 5
33120: ST_TO_ADDR
// dist := d ;
33121: LD_ADDR_VAR 0 6
33125: PUSH
33126: LD_VAR 0 7
33130: ST_TO_ADDR
// end ; end ;
33131: GO 32994
33133: POP
33134: POP
// result := [ _x , _y , _i , dist ] ;
33135: LD_ADDR_VAR 0 4
33139: PUSH
33140: LD_VAR 0 8
33144: PUSH
33145: LD_VAR 0 9
33149: PUSH
33150: LD_VAR 0 10
33154: PUSH
33155: LD_VAR 0 6
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// end ;
33166: LD_VAR 0 4
33170: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33171: LD_INT 0
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
// for i = 1 to list do
33178: LD_ADDR_VAR 0 5
33182: PUSH
33183: DOUBLE
33184: LD_INT 1
33186: DEC
33187: ST_TO_ADDR
33188: LD_VAR 0 1
33192: PUSH
33193: FOR_TO
33194: IFFALSE 33508
// begin for j = list downto 2 do
33196: LD_ADDR_VAR 0 6
33200: PUSH
33201: DOUBLE
33202: LD_VAR 0 1
33206: INC
33207: ST_TO_ADDR
33208: LD_INT 2
33210: PUSH
33211: FOR_DOWNTO
33212: IFFALSE 33504
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33214: LD_VAR 0 2
33218: PPUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: LD_VAR 0 1
33228: PUSH
33229: LD_VAR 0 6
33233: ARRAY
33234: PUSH
33235: LD_INT 1
33237: ARRAY
33238: PPUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 2
33252: ARRAY
33253: PPUSH
33254: CALL_OW 298
33258: PUSH
33259: LD_VAR 0 2
33263: PPUSH
33264: LD_VAR 0 3
33268: PPUSH
33269: LD_VAR 0 1
33273: PUSH
33274: LD_VAR 0 6
33278: PUSH
33279: LD_INT 1
33281: MINUS
33282: ARRAY
33283: PUSH
33284: LD_INT 1
33286: ARRAY
33287: PPUSH
33288: LD_VAR 0 1
33292: PUSH
33293: LD_VAR 0 6
33297: PUSH
33298: LD_INT 1
33300: MINUS
33301: ARRAY
33302: PUSH
33303: LD_INT 2
33305: ARRAY
33306: PPUSH
33307: CALL_OW 298
33311: LESS
33312: IFFALSE 33502
// begin _x := list [ j ] [ 1 ] ;
33314: LD_ADDR_VAR 0 7
33318: PUSH
33319: LD_VAR 0 1
33323: PUSH
33324: LD_VAR 0 6
33328: ARRAY
33329: PUSH
33330: LD_INT 1
33332: ARRAY
33333: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33334: LD_ADDR_VAR 0 8
33338: PUSH
33339: LD_VAR 0 1
33343: PUSH
33344: LD_VAR 0 6
33348: ARRAY
33349: PUSH
33350: LD_INT 2
33352: ARRAY
33353: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33354: LD_ADDR_VAR 0 1
33358: PUSH
33359: LD_VAR 0 1
33363: PPUSH
33364: LD_VAR 0 6
33368: PPUSH
33369: LD_INT 1
33371: PPUSH
33372: LD_VAR 0 1
33376: PUSH
33377: LD_VAR 0 6
33381: PUSH
33382: LD_INT 1
33384: MINUS
33385: ARRAY
33386: PUSH
33387: LD_INT 1
33389: ARRAY
33390: PPUSH
33391: CALL 31132 0 4
33395: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33396: LD_ADDR_VAR 0 1
33400: PUSH
33401: LD_VAR 0 1
33405: PPUSH
33406: LD_VAR 0 6
33410: PPUSH
33411: LD_INT 2
33413: PPUSH
33414: LD_VAR 0 1
33418: PUSH
33419: LD_VAR 0 6
33423: PUSH
33424: LD_INT 1
33426: MINUS
33427: ARRAY
33428: PUSH
33429: LD_INT 2
33431: ARRAY
33432: PPUSH
33433: CALL 31132 0 4
33437: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33438: LD_ADDR_VAR 0 1
33442: PUSH
33443: LD_VAR 0 1
33447: PPUSH
33448: LD_VAR 0 6
33452: PUSH
33453: LD_INT 1
33455: MINUS
33456: PPUSH
33457: LD_INT 1
33459: PPUSH
33460: LD_VAR 0 7
33464: PPUSH
33465: CALL 31132 0 4
33469: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33470: LD_ADDR_VAR 0 1
33474: PUSH
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 6
33484: PUSH
33485: LD_INT 1
33487: MINUS
33488: PPUSH
33489: LD_INT 2
33491: PPUSH
33492: LD_VAR 0 8
33496: PPUSH
33497: CALL 31132 0 4
33501: ST_TO_ADDR
// end ; end ;
33502: GO 33211
33504: POP
33505: POP
// end ;
33506: GO 33193
33508: POP
33509: POP
// result := list ;
33510: LD_ADDR_VAR 0 4
33514: PUSH
33515: LD_VAR 0 1
33519: ST_TO_ADDR
// end ;
33520: LD_VAR 0 4
33524: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33525: LD_INT 0
33527: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33528: LD_ADDR_VAR 0 5
33532: PUSH
33533: LD_VAR 0 1
33537: PPUSH
33538: LD_VAR 0 2
33542: PPUSH
33543: CALL_OW 546
33547: PUSH
33548: LD_INT 2
33550: ARRAY
33551: PUSH
33552: LD_VAR 0 3
33556: PPUSH
33557: LD_VAR 0 4
33561: PPUSH
33562: CALL_OW 546
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: MINUS
33571: ST_TO_ADDR
// if result < 0 then
33572: LD_VAR 0 5
33576: PUSH
33577: LD_INT 0
33579: LESS
33580: IFFALSE 33597
// result := result * - 1 ;
33582: LD_ADDR_VAR 0 5
33586: PUSH
33587: LD_VAR 0 5
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: MUL
33596: ST_TO_ADDR
// end ;
33597: LD_VAR 0 5
33601: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33602: LD_INT 0
33604: PPUSH
33605: PPUSH
// area = ListEnvironmentArea ( area ) ;
33606: LD_ADDR_VAR 0 2
33610: PUSH
33611: LD_VAR 0 2
33615: PPUSH
33616: CALL_OW 353
33620: ST_TO_ADDR
// if bulldozer > 0 then
33621: LD_VAR 0 1
33625: PUSH
33626: LD_INT 0
33628: GREATER
33629: IFFALSE 33740
// for i = area downto 1 do
33631: LD_ADDR_VAR 0 4
33635: PUSH
33636: DOUBLE
33637: LD_VAR 0 2
33641: INC
33642: ST_TO_ADDR
33643: LD_INT 1
33645: PUSH
33646: FOR_DOWNTO
33647: IFFALSE 33738
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33649: LD_VAR 0 2
33653: PUSH
33654: LD_VAR 0 4
33658: ARRAY
33659: PUSH
33660: LD_INT 1
33662: ARRAY
33663: PPUSH
33664: LD_VAR 0 2
33668: PUSH
33669: LD_VAR 0 4
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: PPUSH
33679: CALL_OW 351
33683: IFFALSE 33736
// if not HasTask ( bulldozer ) then
33685: LD_VAR 0 1
33689: PPUSH
33690: CALL_OW 314
33694: NOT
33695: IFFALSE 33736
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33697: LD_VAR 0 1
33701: PPUSH
33702: LD_VAR 0 2
33706: PUSH
33707: LD_VAR 0 4
33711: ARRAY
33712: PUSH
33713: LD_INT 1
33715: ARRAY
33716: PPUSH
33717: LD_VAR 0 2
33721: PUSH
33722: LD_VAR 0 4
33726: ARRAY
33727: PUSH
33728: LD_INT 2
33730: ARRAY
33731: PPUSH
33732: CALL_OW 171
33736: GO 33646
33738: POP
33739: POP
// end ;
33740: LD_VAR 0 3
33744: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33745: LD_INT 0
33747: PPUSH
33748: PPUSH
33749: PPUSH
33750: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: LD_INT 22
33758: PUSH
33759: LD_VAR 0 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 21
33770: PUSH
33771: LD_VAR 0 2
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PPUSH
33784: CALL_OW 69
33788: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33789: LD_ADDR_VAR 0 7
33793: PUSH
33794: LD_VAR 0 3
33798: PPUSH
33799: LD_INT 22
33801: PUSH
33802: LD_VAR 0 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 21
33813: PUSH
33814: LD_VAR 0 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PPUSH
33827: CALL_OW 70
33831: ST_TO_ADDR
// if tmp and pom then
33832: LD_VAR 0 6
33836: PUSH
33837: LD_VAR 0 7
33841: AND
33842: IFFALSE 33862
// result := tmp diff pom else
33844: LD_ADDR_VAR 0 4
33848: PUSH
33849: LD_VAR 0 6
33853: PUSH
33854: LD_VAR 0 7
33858: DIFF
33859: ST_TO_ADDR
33860: GO 33870
// result := false ;
33862: LD_ADDR_VAR 0 4
33866: PUSH
33867: LD_INT 0
33869: ST_TO_ADDR
// end ;
33870: LD_VAR 0 4
33874: RET
// export function SavePosition ( unit ) ; begin
33875: LD_INT 0
33877: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 1
33887: PPUSH
33888: CALL_OW 250
33892: PPUSH
33893: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33897: LD_VAR 0 1
33901: PPUSH
33902: LD_VAR 0 1
33906: PPUSH
33907: CALL_OW 251
33911: PPUSH
33912: CALL_OW 232
// end ;
33916: LD_VAR 0 2
33920: RET
// export function GetPosition ( unit ) ; begin
33921: LD_INT 0
33923: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33924: LD_ADDR_VAR 0 2
33928: PUSH
33929: LD_VAR 0 1
33933: PPUSH
33934: CALL_OW 252
33938: PUSH
33939: LD_VAR 0 1
33943: PPUSH
33944: CALL_OW 253
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: ST_TO_ADDR
// end ;
33953: LD_VAR 0 2
33957: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33958: LD_INT 0
33960: PPUSH
// if unit in unreachableList then
33961: LD_VAR 0 1
33965: PUSH
33966: LD_EXP 30
33970: IN
33971: IFFALSE 33989
// unreachableList := unreachableList diff unit ;
33973: LD_ADDR_EXP 30
33977: PUSH
33978: LD_EXP 30
33982: PUSH
33983: LD_VAR 0 1
33987: DIFF
33988: ST_TO_ADDR
// if ValidHex ( x , y ) then
33989: LD_VAR 0 2
33993: PPUSH
33994: LD_VAR 0 3
33998: PPUSH
33999: CALL_OW 488
34003: IFFALSE 34029
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: LD_VAR 0 2
34014: PPUSH
34015: LD_VAR 0 3
34019: PPUSH
34020: CALL_OW 428
34024: PPUSH
34025: CALL_OW 115
// Wait ( 3 ) ;
34029: LD_INT 3
34031: PPUSH
34032: CALL_OW 67
// if unit in unreachableList then
34036: LD_VAR 0 1
34040: PUSH
34041: LD_EXP 30
34045: IN
34046: IFFALSE 34058
// result := false else
34048: LD_ADDR_VAR 0 4
34052: PUSH
34053: LD_INT 0
34055: ST_TO_ADDR
34056: GO 34066
// result := true ;
34058: LD_ADDR_VAR 0 4
34062: PUSH
34063: LD_INT 1
34065: ST_TO_ADDR
// end ; end_of_file
34066: LD_VAR 0 4
34070: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34071: LD_EXP 31
34075: IFFALSE 34137
34077: GO 34079
34079: DISABLE
34080: LD_INT 0
34082: PPUSH
// begin enable ;
34083: ENABLE
// for i = 1 to mc_crates_list do
34084: LD_ADDR_VAR 0 1
34088: PUSH
34089: DOUBLE
34090: LD_INT 1
34092: DEC
34093: ST_TO_ADDR
34094: LD_EXP 32
34098: PUSH
34099: FOR_TO
34100: IFFALSE 34131
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34102: LD_EXP 32
34106: PUSH
34107: LD_VAR 0 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 5
34115: PPUSH
34116: LD_INT 50
34118: PPUSH
34119: LD_INT 700
34121: PPUSH
34122: LD_INT 20
34124: PPUSH
34125: CALL 24501 0 5
34129: GO 34099
34131: POP
34132: POP
// MC_Game ( ) ;
34133: CALL 34140 0 0
// end ;
34137: PPOPN 1
34139: END
// export function MC_Game ( ) ; var i , side , un ; begin
34140: LD_INT 0
34142: PPUSH
34143: PPUSH
34144: PPUSH
34145: PPUSH
// if not isTest then
34146: LD_EXP 1
34150: NOT
34151: IFFALSE 34171
// MC_Show ( [ #tick , tick ] ) else
34153: LD_STRING #tick
34155: PUSH
34156: LD_OWVAR 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PPUSH
34165: CALL 8585 0 1
34169: GO 34180
// MC_Show ( debug_string ) ;
34171: LD_EXP 2
34175: PPUSH
34176: CALL 8585 0 1
// for side = 1 to 8 do
34180: LD_ADDR_VAR 0 3
34184: PUSH
34185: DOUBLE
34186: LD_INT 1
34188: DEC
34189: ST_TO_ADDR
34190: LD_INT 8
34192: PUSH
34193: FOR_TO
34194: IFFALSE 36194
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34196: LD_EXP 39
34200: PUSH
34201: LD_VAR 0 3
34205: ARRAY
34206: PUSH
34207: LD_INT 0
34209: EQUAL
34210: PUSH
34211: LD_VAR 0 3
34215: PPUSH
34216: EMPTY
34217: PPUSH
34218: CALL 11802 0 2
34222: PUSH
34223: LD_INT 0
34225: EQUAL
34226: OR
34227: IFFALSE 34231
// continue ;
34229: GO 34193
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34231: LD_VAR 0 3
34235: PPUSH
34236: LD_VAR 0 3
34240: PPUSH
34241: CALL 25022 0 1
34245: PPUSH
34246: CALL 36201 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34250: LD_EXP 71
34254: PUSH
34255: LD_VAR 0 3
34259: ARRAY
34260: PUSH
34261: LD_INT 1
34263: ARRAY
34264: PUSH
34265: LD_INT 0
34267: GREATER
34268: PUSH
34269: LD_EXP 69
34273: PUSH
34274: LD_VAR 0 3
34278: ARRAY
34279: PUSH
34280: LD_INT 1
34282: ARRAY
34283: PUSH
34284: LD_INT 0
34286: EQUAL
34287: AND
34288: PUSH
34289: LD_VAR 0 3
34293: PPUSH
34294: LD_INT 7
34296: PPUSH
34297: EMPTY
34298: PPUSH
34299: CALL 12370 0 3
34303: NOT
34304: AND
34305: IFFALSE 34342
// begin for i in MREG_Attackers [ side ] do
34307: LD_ADDR_VAR 0 2
34311: PUSH
34312: LD_EXP 71
34316: PUSH
34317: LD_VAR 0 3
34321: ARRAY
34322: PUSH
34323: FOR_IN
34324: IFFALSE 34340
// SetTag ( i , 7 ) ;
34326: LD_VAR 0 2
34330: PPUSH
34331: LD_INT 7
34333: PPUSH
34334: CALL_OW 109
34338: GO 34323
34340: POP
34341: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34342: LD_VAR 0 3
34346: PPUSH
34347: LD_INT 7
34349: PPUSH
34350: EMPTY
34351: PPUSH
34352: CALL 12370 0 3
34356: IFFALSE 34416
// begin if side = 1 then
34358: LD_VAR 0 3
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: IFFALSE 34375
// RaiseSailEvent ( 101 ) ;
34368: LD_INT 101
34370: PPUSH
34371: CALL_OW 427
// if side = 4 then
34375: LD_VAR 0 3
34379: PUSH
34380: LD_INT 4
34382: EQUAL
34383: IFFALSE 34392
// RaiseSailEvent ( 102 ) ;
34385: LD_INT 102
34387: PPUSH
34388: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34392: LD_VAR 0 3
34396: PPUSH
34397: LD_VAR 0 3
34401: PPUSH
34402: LD_INT 7
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL 12370 0 3
34411: PPUSH
34412: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34416: LD_VAR 0 3
34420: PPUSH
34421: CALL 18050 0 1
34425: PUSH
34426: LD_VAR 0 3
34430: PPUSH
34431: CALL 11706 0 1
34435: AND
34436: IFFALSE 34447
// MCL_Start ( side ) ;
34438: LD_VAR 0 3
34442: PPUSH
34443: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34447: LD_ADDR_EXP 35
34451: PUSH
34452: LD_EXP 35
34456: PPUSH
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_VAR 0 3
34466: PPUSH
34467: CALL 19307 0 1
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34477: LD_ADDR_EXP 47
34481: PUSH
34482: LD_EXP 47
34486: PPUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: LD_VAR 0 3
34496: PPUSH
34497: CALL 11120 0 1
34501: PPUSH
34502: CALL_OW 1
34506: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34507: LD_VAR 0 3
34511: PPUSH
34512: LD_INT 21
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PPUSH
34522: CALL 11667 0 2
34526: IFFALSE 34537
// MCV_CheckStatus ( side ) ;
34528: LD_VAR 0 3
34532: PPUSH
34533: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34537: LD_VAR 0 3
34541: PPUSH
34542: LD_EXP 53
34546: PPUSH
34547: CALL 43001 0 2
34551: IFFALSE 34636
// begin for i = MREG_ToChangeClass downto 1 do
34553: LD_ADDR_VAR 0 2
34557: PUSH
34558: DOUBLE
34559: LD_EXP 53
34563: INC
34564: ST_TO_ADDR
34565: LD_INT 1
34567: PUSH
34568: FOR_DOWNTO
34569: IFFALSE 34634
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34571: LD_EXP 53
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_INT 1
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: EQUAL
34591: IFFALSE 34632
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34593: LD_VAR 0 3
34597: PPUSH
34598: LD_EXP 53
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 2
34611: ARRAY
34612: PPUSH
34613: LD_EXP 53
34617: PUSH
34618: LD_VAR 0 2
34622: ARRAY
34623: PUSH
34624: LD_INT 3
34626: ARRAY
34627: PPUSH
34628: CALL 16574 0 3
// end ; end ;
34632: GO 34568
34634: POP
34635: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34636: LD_INT 1
34638: PUSH
34639: LD_EXP 38
34643: PUSH
34644: LD_VAR 0 3
34648: ARRAY
34649: IN
34650: IFFALSE 34661
// begin MCN_TrainApe ( side ) ;
34652: LD_VAR 0 3
34656: PPUSH
34657: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34661: LD_VAR 0 3
34665: PPUSH
34666: LD_INT 30
34668: PUSH
34669: LD_INT 3
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PPUSH
34676: CALL 11667 0 2
34680: IFFALSE 34854
// begin if MCF_Tag ( side , 10 , [ ] ) then
34682: LD_VAR 0 3
34686: PPUSH
34687: LD_INT 10
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL 12370 0 3
34696: IFFALSE 34743
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34698: LD_VAR 0 3
34702: PPUSH
34703: LD_INT 10
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL 12370 0 3
34712: PPUSH
34713: LD_VAR 0 3
34717: PPUSH
34718: LD_INT 30
34720: PUSH
34721: LD_INT 3
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PPUSH
34728: CALL 11667 0 2
34732: PUSH
34733: LD_INT 1
34735: ARRAY
34736: PPUSH
34737: CALL_OW 168
// end else
34741: GO 34854
// if MREG_ToConstruct [ side ] then
34743: LD_EXP 51
34747: PUSH
34748: LD_VAR 0 3
34752: ARRAY
34753: IFFALSE 34854
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_VAR 0 3
34764: PPUSH
34765: LD_INT 30
34767: PUSH
34768: LD_INT 3
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: CALL 11667 0 2
34779: PUSH
34780: LD_INT 1
34782: ARRAY
34783: PPUSH
34784: LD_EXP 51
34788: PUSH
34789: LD_VAR 0 3
34793: ARRAY
34794: PUSH
34795: LD_INT 1
34797: ARRAY
34798: PUSH
34799: LD_EXP 51
34803: PUSH
34804: LD_VAR 0 3
34808: ARRAY
34809: PUSH
34810: LD_INT 2
34812: ARRAY
34813: PUSH
34814: LD_EXP 51
34818: PUSH
34819: LD_VAR 0 3
34823: ARRAY
34824: PUSH
34825: LD_INT 3
34827: ARRAY
34828: PUSH
34829: LD_EXP 51
34833: PUSH
34834: LD_VAR 0 3
34838: ARRAY
34839: PUSH
34840: LD_INT 4
34842: ARRAY
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: PPUSH
34850: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 3
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PPUSH
34869: CALL 11667 0 2
34873: PUSH
34874: LD_VAR 0 3
34878: PPUSH
34879: LD_EXP 43
34883: PPUSH
34884: CALL 43001 0 2
34888: AND
34889: PUSH
34890: LD_INT 22
34892: PUSH
34893: LD_VAR 0 3
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 30
34907: PUSH
34908: LD_INT 33
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 30
34917: PUSH
34918: LD_INT 32
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 35
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: PPUSH
34945: CALL_OW 69
34949: AND
34950: IFFALSE 34961
// MCV_Turret ( side ) ;
34952: LD_VAR 0 3
34956: PPUSH
34957: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34961: LD_EXP 42
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PUSH
34972: LD_INT 1
34974: GREATER
34975: PUSH
34976: LD_VAR 0 3
34980: PPUSH
34981: CALL 25022 0 1
34985: PUSH
34986: LD_INT 0
34988: EQUAL
34989: AND
34990: IFFALSE 35152
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34992: LD_EXP 42
34996: PUSH
34997: LD_VAR 0 3
35001: ARRAY
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: PPUSH
35007: CALL_OW 353
35011: IFFALSE 35049
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35013: LD_EXP 42
35017: PUSH
35018: LD_VAR 0 3
35022: ARRAY
35023: PUSH
35024: LD_INT 2
35026: ARRAY
35027: PPUSH
35028: LD_EXP 42
35032: PUSH
35033: LD_VAR 0 3
35037: ARRAY
35038: PUSH
35039: LD_INT 1
35041: ARRAY
35042: PPUSH
35043: CALL 32430 0 2
35047: GO 35152
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35049: LD_VAR 0 3
35053: PPUSH
35054: LD_INT 30
35056: PUSH
35057: LD_INT 3
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PPUSH
35064: CALL 11667 0 2
35068: IFFALSE 35152
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35070: LD_VAR 0 3
35074: PPUSH
35075: LD_INT 30
35077: PUSH
35078: LD_INT 3
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PPUSH
35085: CALL 11667 0 2
35089: PUSH
35090: LD_INT 1
35092: ARRAY
35093: PPUSH
35094: CALL_OW 461
35098: PUSH
35099: LD_INT 2
35101: EQUAL
35102: IFFALSE 35152
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35104: LD_EXP 42
35108: PUSH
35109: LD_VAR 0 3
35113: ARRAY
35114: PUSH
35115: LD_INT 2
35117: ARRAY
35118: PPUSH
35119: LD_INT 10
35121: PPUSH
35122: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35126: LD_ADDR_EXP 42
35130: PUSH
35131: LD_EXP 42
35135: PPUSH
35136: LD_VAR 0 3
35140: PPUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 33
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11667 0 2
35171: IFFALSE 35211
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35173: LD_VAR 0 3
35177: PPUSH
35178: LD_VAR 0 3
35182: PPUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PPUSH
35193: CALL 11667 0 2
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL_OW 248
35206: PPUSH
35207: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35211: LD_EXP 47
35215: PUSH
35216: LD_VAR 0 3
35220: ARRAY
35221: IFFALSE 35234
// begin MCB_Repair ( side ) ;
35223: LD_VAR 0 3
35227: PPUSH
35228: CALL 11407 0 1
// end else
35232: GO 36147
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_EXP 49
35243: PPUSH
35244: CALL 43001 0 2
35248: PUSH
35249: LD_VAR 0 3
35253: PPUSH
35254: LD_EXP 40
35258: PPUSH
35259: CALL 43001 0 2
35263: AND
35264: IFFALSE 35472
// begin for i = 1 to MREG_ToUpLab do
35266: LD_ADDR_VAR 0 2
35270: PUSH
35271: DOUBLE
35272: LD_INT 1
35274: DEC
35275: ST_TO_ADDR
35276: LD_EXP 49
35280: PUSH
35281: FOR_TO
35282: IFFALSE 35468
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35284: LD_EXP 49
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: PUSH
35295: LD_INT 1
35297: ARRAY
35298: PUSH
35299: LD_VAR 0 3
35303: EQUAL
35304: IFFALSE 35466
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35306: LD_EXP 49
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_INT 2
35319: ARRAY
35320: PUSH
35321: LD_EXP 49
35325: PUSH
35326: LD_VAR 0 2
35330: ARRAY
35331: PUSH
35332: LD_INT 3
35334: ARRAY
35335: AND
35336: IFFALSE 35464
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35338: LD_VAR 0 3
35342: PPUSH
35343: LD_EXP 49
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_INT 2
35356: ARRAY
35357: PPUSH
35358: LD_EXP 49
35362: PUSH
35363: LD_VAR 0 2
35367: ARRAY
35368: PUSH
35369: LD_INT 3
35371: ARRAY
35372: PPUSH
35373: CALL 8931 0 3
35377: IFFALSE 35464
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35379: LD_ADDR_EXP 49
35383: PUSH
35384: LD_EXP 49
35388: PPUSH
35389: LD_VAR 0 3
35393: PPUSH
35394: LD_EXP 49
35398: PUSH
35399: LD_VAR 0 2
35403: ARRAY
35404: PUSH
35405: LD_INT 2
35407: ARRAY
35408: PPUSH
35409: LD_EXP 49
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_INT 3
35422: ARRAY
35423: PPUSH
35424: CALL 42053 0 4
35428: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35429: LD_ADDR_EXP 40
35433: PUSH
35434: LD_EXP 40
35438: PPUSH
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_EXP 40
35448: PUSH
35449: LD_INT 1
35451: ARRAY
35452: PUSH
35453: LD_INT 2
35455: ARRAY
35456: PPUSH
35457: EMPTY
35458: PPUSH
35459: CALL 42053 0 4
35463: ST_TO_ADDR
// end ; break ;
35464: GO 35468
// end ;
35466: GO 35281
35468: POP
35469: POP
// end else
35470: GO 36147
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35472: LD_VAR 0 3
35476: PPUSH
35477: LD_EXP 48
35481: PPUSH
35482: CALL 43001 0 2
35486: IFFALSE 35560
// begin for i = 1 to MREG_ToUpdate do
35488: LD_ADDR_VAR 0 2
35492: PUSH
35493: DOUBLE
35494: LD_INT 1
35496: DEC
35497: ST_TO_ADDR
35498: LD_EXP 48
35502: PUSH
35503: FOR_TO
35504: IFFALSE 35556
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35506: LD_EXP 48
35510: PUSH
35511: LD_VAR 0 2
35515: ARRAY
35516: PUSH
35517: LD_INT 1
35519: ARRAY
35520: PUSH
35521: LD_VAR 0 3
35525: EQUAL
35526: IFFALSE 35554
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PUSH
35538: LD_VAR 0 2
35542: ARRAY
35543: PUSH
35544: LD_INT 2
35546: ARRAY
35547: PPUSH
35548: CALL 8767 0 2
// break ;
35552: GO 35556
// end ;
35554: GO 35503
35556: POP
35557: POP
// end else
35558: GO 36147
// if MCF_Get ( side , [ f_constructed ] ) then
35560: LD_VAR 0 3
35564: PPUSH
35565: LD_INT 57
35567: PUSH
35568: EMPTY
35569: LIST
35570: PPUSH
35571: CALL 11667 0 2
35575: IFFALSE 35608
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35577: LD_VAR 0 3
35581: PPUSH
35582: LD_VAR 0 3
35586: PPUSH
35587: LD_INT 57
35589: PUSH
35590: EMPTY
35591: LIST
35592: PPUSH
35593: CALL 11667 0 2
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: CALL 11011 0 2
35606: GO 36147
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35608: LD_VAR 0 3
35612: PPUSH
35613: LD_EXP 46
35617: PPUSH
35618: CALL 43001 0 2
35622: PUSH
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL_OW 345
35632: NOT
35633: AND
35634: PUSH
35635: LD_VAR 0 3
35639: PPUSH
35640: CALL 25022 0 1
35644: PUSH
35645: LD_INT 0
35647: EQUAL
35648: AND
35649: IFFALSE 36048
// begin for i = 1 to MREG_ToBuild do
35651: LD_ADDR_VAR 0 2
35655: PUSH
35656: DOUBLE
35657: LD_INT 1
35659: DEC
35660: ST_TO_ADDR
35661: LD_EXP 46
35665: PUSH
35666: FOR_TO
35667: IFFALSE 36044
// if MREG_ToBuild [ i ] [ 1 ] = side then
35669: LD_EXP 46
35673: PUSH
35674: LD_VAR 0 2
35678: ARRAY
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 3
35688: EQUAL
35689: IFFALSE 36042
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35691: LD_OWVAR 84
35695: PUSH
35696: LD_EXP 46
35700: PUSH
35701: LD_VAR 0 2
35705: ARRAY
35706: PUSH
35707: LD_INT 3
35709: ARRAY
35710: PUSH
35711: LD_INT 1
35713: ARRAY
35714: PPUSH
35715: LD_EXP 46
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PUSH
35730: LD_INT 2
35732: ARRAY
35733: PPUSH
35734: CALL_OW 351
35738: AND
35739: IFFALSE 35783
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35741: LD_EXP 46
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 3
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PPUSH
35760: LD_EXP 46
35764: PUSH
35765: LD_VAR 0 2
35769: ARRAY
35770: PUSH
35771: LD_INT 3
35773: ARRAY
35774: PUSH
35775: LD_INT 2
35777: ARRAY
35778: PPUSH
35779: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35783: LD_EXP 46
35787: PUSH
35788: LD_VAR 0 2
35792: ARRAY
35793: PUSH
35794: LD_INT 2
35796: ARRAY
35797: PUSH
35798: LD_INT 0
35800: EQUAL
35801: IFFALSE 35871
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35803: LD_VAR 0 3
35807: PPUSH
35808: LD_EXP 46
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PUSH
35819: LD_INT 3
35821: ARRAY
35822: PUSH
35823: LD_INT 1
35825: ARRAY
35826: PPUSH
35827: LD_EXP 46
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: PUSH
35838: LD_INT 3
35840: ARRAY
35841: PUSH
35842: LD_INT 2
35844: ARRAY
35845: PPUSH
35846: LD_EXP 46
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_INT 3
35859: ARRAY
35860: PUSH
35861: LD_INT 3
35863: ARRAY
35864: PPUSH
35865: CALL 8603 0 4
35869: GO 36040
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35871: LD_EXP 46
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: PUSH
35882: LD_INT 2
35884: ARRAY
35885: PUSH
35886: LD_INT 6
35888: EQUAL
35889: IFFALSE 35959
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35891: LD_VAR 0 3
35895: PPUSH
35896: LD_EXP 46
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PUSH
35911: LD_INT 1
35913: ARRAY
35914: PPUSH
35915: LD_EXP 46
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: PUSH
35926: LD_INT 3
35928: ARRAY
35929: PUSH
35930: LD_INT 2
35932: ARRAY
35933: PPUSH
35934: LD_EXP 46
35938: PUSH
35939: LD_VAR 0 2
35943: ARRAY
35944: PUSH
35945: LD_INT 3
35947: ARRAY
35948: PUSH
35949: LD_INT 3
35951: ARRAY
35952: PPUSH
35953: CALL 8732 0 4
35957: GO 36040
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35959: LD_VAR 0 3
35963: PPUSH
35964: LD_EXP 46
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 2
35977: ARRAY
35978: PPUSH
35979: LD_EXP 46
35983: PUSH
35984: LD_VAR 0 2
35988: ARRAY
35989: PUSH
35990: LD_INT 3
35992: ARRAY
35993: PUSH
35994: LD_INT 1
35996: ARRAY
35997: PPUSH
35998: LD_EXP 46
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: PUSH
36009: LD_INT 3
36011: ARRAY
36012: PUSH
36013: LD_INT 2
36015: ARRAY
36016: PPUSH
36017: LD_EXP 46
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 3
36030: ARRAY
36031: PUSH
36032: LD_INT 3
36034: ARRAY
36035: PPUSH
36036: CALL 10236 0 5
// break ;
36040: GO 36044
// end ;
36042: GO 35666
36044: POP
36045: POP
// end else
36046: GO 36147
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36048: LD_VAR 0 3
36052: PPUSH
36053: LD_EXP 52
36057: PPUSH
36058: CALL 43001 0 2
36062: PUSH
36063: LD_VAR 0 3
36067: PPUSH
36068: CALL 25022 0 1
36072: PUSH
36073: LD_INT 0
36075: EQUAL
36076: AND
36077: IFFALSE 36147
// begin for i = 1 to MREG_ToDismantle do
36079: LD_ADDR_VAR 0 2
36083: PUSH
36084: DOUBLE
36085: LD_INT 1
36087: DEC
36088: ST_TO_ADDR
36089: LD_EXP 52
36093: PUSH
36094: FOR_TO
36095: IFFALSE 36145
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36097: LD_EXP 52
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PUSH
36108: LD_INT 1
36110: ARRAY
36111: PUSH
36112: LD_VAR 0 3
36116: EQUAL
36117: IFFALSE 36143
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36119: LD_VAR 0 3
36123: PPUSH
36124: LD_EXP 52
36128: PUSH
36129: LD_VAR 0 2
36133: ARRAY
36134: PUSH
36135: LD_INT 2
36137: ARRAY
36138: PPUSH
36139: CALL 10902 0 2
// end ;
36143: GO 36094
36145: POP
36146: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36147: LD_VAR 0 3
36151: PPUSH
36152: LD_INT 30
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL 11667 0 2
36166: PUSH
36167: LD_VAR 0 3
36171: PPUSH
36172: CALL 25022 0 1
36176: PUSH
36177: LD_INT 0
36179: EQUAL
36180: AND
36181: IFFALSE 36192
// MCT_CollectCrates ( side ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: CALL 23961 0 1
// end ;
36192: GO 34193
36194: POP
36195: POP
// end ;
36196: LD_VAR 0 1
36200: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36201: LD_INT 0
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
36216: PPUSH
36217: PPUSH
// all := MCF_All ( side , [ ] ) ;
36218: LD_ADDR_VAR 0 17
36222: PUSH
36223: LD_VAR 0 1
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11802 0 2
36234: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36235: LD_ADDR_VAR 0 13
36239: PUSH
36240: LD_VAR 0 1
36244: PPUSH
36245: LD_INT 1
36247: PPUSH
36248: EMPTY
36249: PPUSH
36250: CALL 11750 0 3
36254: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36255: LD_ADDR_VAR 0 14
36259: PUSH
36260: LD_VAR 0 1
36264: PPUSH
36265: LD_INT 2
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL 11750 0 3
36274: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36275: LD_ADDR_VAR 0 15
36279: PUSH
36280: LD_VAR 0 1
36284: PPUSH
36285: LD_INT 3
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL 11750 0 3
36294: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36295: LD_ADDR_VAR 0 16
36299: PUSH
36300: LD_VAR 0 1
36304: PPUSH
36305: LD_INT 4
36307: PPUSH
36308: EMPTY
36309: PPUSH
36310: CALL 11750 0 3
36314: ST_TO_ADDR
// if mech then
36315: LD_VAR 0 15
36319: IFFALSE 36336
// mech := MCF_SortListDesc ( mech ) ;
36321: LD_ADDR_VAR 0 15
36325: PUSH
36326: LD_VAR 0 15
36330: PPUSH
36331: CALL 12916 0 1
36335: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36336: LD_EXP 56
36340: PUSH
36341: LD_VAR 0 1
36345: ARRAY
36346: PUSH
36347: LD_STRING 
36349: EQUAL
36350: NOT
36351: IFFALSE 36407
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36353: LD_EXP 56
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: PPUSH
36368: CALL_OW 257
36372: PUSH
36373: LD_INT 1
36375: EQUAL
36376: IFFALSE 36405
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36378: LD_VAR 0 1
36382: PPUSH
36383: LD_STRING ToArm
36385: PPUSH
36386: LD_EXP 56
36390: PUSH
36391: LD_VAR 0 1
36395: ARRAY
36396: PUSH
36397: LD_INT 1
36399: ARRAY
36400: PPUSH
36401: CALL 14546 0 3
// end else
36405: GO 36433
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36407: LD_ADDR_EXP 56
36411: PUSH
36412: LD_EXP 56
36416: PPUSH
36417: LD_VAR 0 1
36421: PPUSH
36422: LD_INT 1
36424: PPUSH
36425: LD_INT 0
36427: PPUSH
36428: CALL 31132 0 4
36432: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36433: LD_EXP 57
36437: PUSH
36438: LD_VAR 0 1
36442: ARRAY
36443: PUSH
36444: LD_STRING 
36446: EQUAL
36447: NOT
36448: IFFALSE 36504
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_INT 1
36463: ARRAY
36464: PPUSH
36465: CALL_OW 257
36469: PUSH
36470: LD_INT 2
36472: EQUAL
36473: IFFALSE 36502
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36475: LD_VAR 0 1
36479: PPUSH
36480: LD_STRING ToDep
36482: PPUSH
36483: LD_EXP 57
36487: PUSH
36488: LD_VAR 0 1
36492: ARRAY
36493: PUSH
36494: LD_INT 1
36496: ARRAY
36497: PPUSH
36498: CALL 14546 0 3
// end else
36502: GO 36530
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36504: LD_ADDR_EXP 57
36508: PUSH
36509: LD_EXP 57
36513: PPUSH
36514: LD_VAR 0 1
36518: PPUSH
36519: LD_INT 1
36521: PPUSH
36522: LD_INT 0
36524: PPUSH
36525: CALL 31132 0 4
36529: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36530: LD_EXP 55
36534: PUSH
36535: LD_VAR 0 1
36539: ARRAY
36540: PUSH
36541: LD_STRING 
36543: EQUAL
36544: NOT
36545: IFFALSE 36601
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36547: LD_EXP 55
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_INT 1
36560: ARRAY
36561: PPUSH
36562: CALL_OW 257
36566: PUSH
36567: LD_INT 3
36569: EQUAL
36570: IFFALSE 36599
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36572: LD_VAR 0 1
36576: PPUSH
36577: LD_STRING ToFac
36579: PPUSH
36580: LD_EXP 55
36584: PUSH
36585: LD_VAR 0 1
36589: ARRAY
36590: PUSH
36591: LD_INT 1
36593: ARRAY
36594: PPUSH
36595: CALL 14546 0 3
// end else
36599: GO 36627
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36601: LD_ADDR_EXP 55
36605: PUSH
36606: LD_EXP 55
36610: PPUSH
36611: LD_VAR 0 1
36615: PPUSH
36616: LD_INT 1
36618: PPUSH
36619: LD_INT 0
36621: PPUSH
36622: CALL 31132 0 4
36626: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36627: LD_EXP 54
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_STRING 
36640: EQUAL
36641: NOT
36642: IFFALSE 36698
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36644: LD_EXP 54
36648: PUSH
36649: LD_VAR 0 1
36653: ARRAY
36654: PUSH
36655: LD_INT 1
36657: ARRAY
36658: PPUSH
36659: CALL_OW 257
36663: PUSH
36664: LD_INT 4
36666: EQUAL
36667: IFFALSE 36696
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36669: LD_VAR 0 1
36673: PPUSH
36674: LD_STRING ToLab
36676: PPUSH
36677: LD_EXP 54
36681: PUSH
36682: LD_VAR 0 1
36686: ARRAY
36687: PUSH
36688: LD_INT 1
36690: ARRAY
36691: PPUSH
36692: CALL 14546 0 3
// end else
36696: GO 36724
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36698: LD_ADDR_EXP 54
36702: PUSH
36703: LD_EXP 54
36707: PPUSH
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 1
36715: PPUSH
36716: LD_INT 0
36718: PPUSH
36719: CALL 31132 0 4
36723: ST_TO_ADDR
// if mode = 0 then
36724: LD_VAR 0 2
36728: PUSH
36729: LD_INT 0
36731: EQUAL
36732: IFFALSE 38570
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36734: LD_VAR 0 1
36738: PPUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PPUSH
36749: CALL 11667 0 2
36753: PUSH
36754: LD_VAR 0 1
36758: PPUSH
36759: LD_INT 21
36761: PUSH
36762: LD_INT 3
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PPUSH
36769: CALL 11667 0 2
36773: PUSH
36774: LD_INT 1
36776: EQUAL
36777: AND
36778: IFFALSE 36843
// begin if all then
36780: LD_VAR 0 17
36784: IFFALSE 36841
// for i in ( all diff eng ) do
36786: LD_ADDR_VAR 0 4
36790: PUSH
36791: LD_VAR 0 17
36795: PUSH
36796: LD_VAR 0 14
36800: DIFF
36801: PUSH
36802: FOR_IN
36803: IFFALSE 36839
// if GetTag ( i ) = 0 then
36805: LD_VAR 0 4
36809: PPUSH
36810: CALL_OW 110
36814: PUSH
36815: LD_INT 0
36817: EQUAL
36818: IFFALSE 36837
// MCH_ChangeClass ( side , i , 2 ) ;
36820: LD_VAR 0 1
36824: PPUSH
36825: LD_VAR 0 4
36829: PPUSH
36830: LD_INT 2
36832: PPUSH
36833: CALL 16574 0 3
36837: GO 36802
36839: POP
36840: POP
// end else
36841: GO 37162
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36843: LD_VAR 0 13
36847: PUSH
36848: LD_EXP 56
36852: PUSH
36853: LD_VAR 0 1
36857: ARRAY
36858: PLUS
36859: PUSH
36860: LD_INT 22
36862: PUSH
36863: LD_VAR 0 1
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 30
36874: PUSH
36875: LD_INT 32
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PPUSH
36886: CALL_OW 69
36890: LESS
36891: IFFALSE 36916
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_VAR 0 14
36902: PUSH
36903: LD_INT 1
36905: ARRAY
36906: PPUSH
36907: LD_INT 1
36909: PPUSH
36910: CALL 16574 0 3
// end else
36914: GO 37162
// if sci < 6 and MCF_Lab ( side ) then
36916: LD_VAR 0 16
36920: PUSH
36921: LD_INT 6
36923: LESS
36924: PUSH
36925: LD_VAR 0 1
36929: PPUSH
36930: CALL 11706 0 1
36934: AND
36935: IFFALSE 37040
// begin if MREG_ToBunker [ side ] then
36937: LD_EXP 68
36941: PUSH
36942: LD_VAR 0 1
36946: ARRAY
36947: IFFALSE 36973
// tmp := sol diff MREG_ToBunker [ side ] else
36949: LD_ADDR_VAR 0 12
36953: PUSH
36954: LD_VAR 0 13
36958: PUSH
36959: LD_EXP 68
36963: PUSH
36964: LD_VAR 0 1
36968: ARRAY
36969: DIFF
36970: ST_TO_ADDR
36971: GO 36983
// tmp := sol ;
36973: LD_ADDR_VAR 0 12
36977: PUSH
36978: LD_VAR 0 13
36982: ST_TO_ADDR
// if tmp then
36983: LD_VAR 0 12
36987: IFFALSE 37038
// for i in tmp do
36989: LD_ADDR_VAR 0 4
36993: PUSH
36994: LD_VAR 0 12
36998: PUSH
36999: FOR_IN
37000: IFFALSE 37036
// if GetTag ( i ) = 0 then
37002: LD_VAR 0 4
37006: PPUSH
37007: CALL_OW 110
37011: PUSH
37012: LD_INT 0
37014: EQUAL
37015: IFFALSE 37034
// MCH_ChangeClass ( side , i , 4 ) ;
37017: LD_VAR 0 1
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: LD_INT 4
37029: PPUSH
37030: CALL 16574 0 3
37034: GO 36999
37036: POP
37037: POP
// end else
37038: GO 37162
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37040: LD_VAR 0 1
37044: PPUSH
37045: LD_INT 30
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL 11667 0 2
37059: IFFALSE 37162
// begin if MREG_ToBunker [ side ] then
37061: LD_EXP 68
37065: PUSH
37066: LD_VAR 0 1
37070: ARRAY
37071: IFFALSE 37097
// tmp := sol diff MREG_ToBunker [ side ] else
37073: LD_ADDR_VAR 0 12
37077: PUSH
37078: LD_VAR 0 13
37082: PUSH
37083: LD_EXP 68
37087: PUSH
37088: LD_VAR 0 1
37092: ARRAY
37093: DIFF
37094: ST_TO_ADDR
37095: GO 37107
// tmp := sol ;
37097: LD_ADDR_VAR 0 12
37101: PUSH
37102: LD_VAR 0 13
37106: ST_TO_ADDR
// if tmp then
37107: LD_VAR 0 12
37111: IFFALSE 37162
// for i in tmp do
37113: LD_ADDR_VAR 0 4
37117: PUSH
37118: LD_VAR 0 12
37122: PUSH
37123: FOR_IN
37124: IFFALSE 37160
// if GetTag ( i ) = 0 then
37126: LD_VAR 0 4
37130: PPUSH
37131: CALL_OW 110
37135: PUSH
37136: LD_INT 0
37138: EQUAL
37139: IFFALSE 37158
// MCH_ChangeClass ( side , i , 2 ) ;
37141: LD_VAR 0 1
37145: PPUSH
37146: LD_VAR 0 4
37150: PPUSH
37151: LD_INT 2
37153: PPUSH
37154: CALL 16574 0 3
37158: GO 37123
37160: POP
37161: POP
// end ; if MCF_Lab ( side ) then
37162: LD_VAR 0 1
37166: PPUSH
37167: CALL 11706 0 1
37171: IFFALSE 37711
// begin if MCL_GetTechList ( side ) then
37173: LD_VAR 0 1
37177: PPUSH
37178: CALL 18050 0 1
37182: IFFALSE 37308
// begin if MREG_ToLab [ side ] then
37184: LD_EXP 54
37188: PUSH
37189: LD_VAR 0 1
37193: ARRAY
37194: IFFALSE 37214
// k := MREG_ToLab [ side ] else
37196: LD_ADDR_VAR 0 8
37200: PUSH
37201: LD_EXP 54
37205: PUSH
37206: LD_VAR 0 1
37210: ARRAY
37211: ST_TO_ADDR
37212: GO 37222
// k := 0 ;
37214: LD_ADDR_VAR 0 8
37218: PUSH
37219: LD_INT 0
37221: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37222: LD_VAR 0 16
37226: PUSH
37227: LD_VAR 0 8
37231: PLUS
37232: PUSH
37233: LD_INT 6
37235: LESSEQUAL
37236: PUSH
37237: LD_VAR 0 17
37241: PUSH
37242: LD_INT 6
37244: GREATER
37245: AND
37246: IFFALSE 37262
// MCH_TrainScientist ( side , 1 ) else
37248: LD_VAR 0 1
37252: PPUSH
37253: LD_INT 1
37255: PPUSH
37256: CALL 16126 0 2
37260: GO 37306
// if all < 6 then
37262: LD_VAR 0 17
37266: PUSH
37267: LD_INT 6
37269: LESS
37270: IFFALSE 37306
// if sci + k < all / 2 then
37272: LD_VAR 0 16
37276: PUSH
37277: LD_VAR 0 8
37281: PLUS
37282: PUSH
37283: LD_VAR 0 17
37287: PUSH
37288: LD_INT 2
37290: DIVREAL
37291: LESS
37292: IFFALSE 37306
// MCH_TrainScientist ( side , 1 ) ;
37294: LD_VAR 0 1
37298: PPUSH
37299: LD_INT 1
37301: PPUSH
37302: CALL 16126 0 2
// end else
37306: GO 37384
// begin if sci > 2 then
37308: LD_VAR 0 16
37312: PUSH
37313: LD_INT 2
37315: GREATER
37316: IFFALSE 37384
// for i = sci downto 2 do
37318: LD_ADDR_VAR 0 4
37322: PUSH
37323: DOUBLE
37324: LD_VAR 0 16
37328: INC
37329: ST_TO_ADDR
37330: LD_INT 2
37332: PUSH
37333: FOR_DOWNTO
37334: IFFALSE 37382
// if GetTag ( sci [ i ] ) = 0 then
37336: LD_VAR 0 16
37340: PUSH
37341: LD_VAR 0 4
37345: ARRAY
37346: PPUSH
37347: CALL_OW 110
37351: PUSH
37352: LD_INT 0
37354: EQUAL
37355: IFFALSE 37380
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37357: LD_VAR 0 1
37361: PPUSH
37362: LD_VAR 0 16
37366: PUSH
37367: LD_VAR 0 4
37371: ARRAY
37372: PPUSH
37373: LD_INT 2
37375: PPUSH
37376: CALL 16574 0 3
37380: GO 37333
37382: POP
37383: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37384: LD_VAR 0 1
37388: PPUSH
37389: CALL 18050 0 1
37393: PUSH
37394: LD_VAR 0 1
37398: PPUSH
37399: CALL 11706 0 1
37403: AND
37404: PUSH
37405: LD_EXP 35
37409: PUSH
37410: LD_VAR 0 1
37414: ARRAY
37415: NOT
37416: AND
37417: IFFALSE 37711
// begin for j = 1 to MCF_Lab ( side ) do
37419: LD_ADDR_VAR 0 5
37423: PUSH
37424: DOUBLE
37425: LD_INT 1
37427: DEC
37428: ST_TO_ADDR
37429: LD_VAR 0 1
37433: PPUSH
37434: CALL 11706 0 1
37438: PUSH
37439: FOR_TO
37440: IFFALSE 37500
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37442: LD_VAR 0 1
37446: PPUSH
37447: CALL 11706 0 1
37451: PUSH
37452: LD_VAR 0 5
37456: ARRAY
37457: PPUSH
37458: CALL_OW 461
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: LD_INT 6
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: IN
37473: IFFALSE 37498
// begin b := MCF_Lab ( side ) [ j ] ;
37475: LD_ADDR_VAR 0 11
37479: PUSH
37480: LD_VAR 0 1
37484: PPUSH
37485: CALL 11706 0 1
37489: PUSH
37490: LD_VAR 0 5
37494: ARRAY
37495: ST_TO_ADDR
// break ;
37496: GO 37500
// end ;
37498: GO 37439
37500: POP
37501: POP
// if MCF_Class ( side , 4 , [ ] ) then
37502: LD_VAR 0 1
37506: PPUSH
37507: LD_INT 4
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL 11750 0 3
37516: IFFALSE 37711
// for j in MCF_Class ( side , 4 , [ ] ) do
37518: LD_ADDR_VAR 0 5
37522: PUSH
37523: LD_VAR 0 1
37527: PPUSH
37528: LD_INT 4
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL 11750 0 3
37537: PUSH
37538: FOR_IN
37539: IFFALSE 37709
// begin if GetTag ( j ) = 0 then
37541: LD_VAR 0 5
37545: PPUSH
37546: CALL_OW 110
37550: PUSH
37551: LD_INT 0
37553: EQUAL
37554: IFFALSE 37645
// begin if IsInUnit ( j ) and b then
37556: LD_VAR 0 5
37560: PPUSH
37561: CALL_OW 310
37565: PUSH
37566: LD_VAR 0 11
37570: AND
37571: IFFALSE 37619
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37573: LD_VAR 0 5
37577: PPUSH
37578: CALL_OW 310
37582: PPUSH
37583: CALL_OW 461
37587: PUSH
37588: LD_INT 2
37590: EQUAL
37591: PUSH
37592: LD_VAR 0 5
37596: PPUSH
37597: CALL_OW 310
37601: PUSH
37602: LD_VAR 0 11
37606: NONEQUAL
37607: AND
37608: IFFALSE 37619
// ComExitBuilding ( j ) ;
37610: LD_VAR 0 5
37614: PPUSH
37615: CALL_OW 122
// if not IsInUnit ( j ) then
37619: LD_VAR 0 5
37623: PPUSH
37624: CALL_OW 310
37628: NOT
37629: IFFALSE 37645
// ComEnterUnit ( j , b ) ;
37631: LD_VAR 0 5
37635: PPUSH
37636: LD_VAR 0 11
37640: PPUSH
37641: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37645: LD_INT 1
37647: PPUSH
37648: LD_VAR 0 5
37652: PPUSH
37653: CALL_OW 255
37657: PPUSH
37658: CALL_OW 321
37662: PUSH
37663: LD_INT 2
37665: EQUAL
37666: PUSH
37667: LD_VAR 0 5
37671: PPUSH
37672: CALL_OW 255
37676: PPUSH
37677: CALL 25022 0 1
37681: PUSH
37682: LD_INT 0
37684: EQUAL
37685: AND
37686: IFFALSE 37707
// MCN_Tame ( GetSide ( j ) , j ) ;
37688: LD_VAR 0 5
37692: PPUSH
37693: CALL_OW 255
37697: PPUSH
37698: LD_VAR 0 5
37702: PPUSH
37703: CALL 18569 0 2
// end ;
37707: GO 37538
37709: POP
37710: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37711: LD_VAR 0 1
37715: PPUSH
37716: LD_INT 30
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PPUSH
37726: CALL 11667 0 2
37730: IFFALSE 37989
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37732: LD_ADDR_VAR 0 11
37736: PUSH
37737: LD_VAR 0 1
37741: PPUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PPUSH
37752: CALL 11667 0 2
37756: PUSH
37757: LD_INT 1
37759: ARRAY
37760: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37761: LD_ADDR_VAR 0 12
37765: PUSH
37766: LD_VAR 0 1
37770: PPUSH
37771: LD_INT 0
37773: PPUSH
37774: LD_INT 25
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PPUSH
37784: CALL 12370 0 3
37788: ST_TO_ADDR
// for i = 1 to tmp do
37789: LD_ADDR_VAR 0 4
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_VAR 0 12
37803: PUSH
37804: FOR_TO
37805: IFFALSE 37865
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37807: LD_VAR 0 12
37811: PUSH
37812: LD_VAR 0 4
37816: ARRAY
37817: PPUSH
37818: CALL_OW 310
37822: NOT
37823: PUSH
37824: LD_VAR 0 12
37828: PUSH
37829: LD_VAR 0 4
37833: ARRAY
37834: PPUSH
37835: CALL_OW 314
37839: NOT
37840: AND
37841: IFFALSE 37863
// ComEnterUnit ( tmp [ i ] , b ) ;
37843: LD_VAR 0 12
37847: PUSH
37848: LD_VAR 0 4
37852: ARRAY
37853: PPUSH
37854: LD_VAR 0 11
37858: PPUSH
37859: CALL_OW 120
37863: GO 37804
37865: POP
37866: POP
// if MREG_ToFac [ side ] then
37867: LD_EXP 55
37871: PUSH
37872: LD_VAR 0 1
37876: ARRAY
37877: IFFALSE 37897
// k := MREG_ToFac [ side ] else
37879: LD_ADDR_VAR 0 8
37883: PUSH
37884: LD_EXP 55
37888: PUSH
37889: LD_VAR 0 1
37893: ARRAY
37894: ST_TO_ADDR
37895: GO 37905
// k := 0 ;
37897: LD_ADDR_VAR 0 8
37901: PUSH
37902: LD_INT 0
37904: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37905: LD_VAR 0 15
37909: PUSH
37910: LD_VAR 0 8
37914: PLUS
37915: PUSH
37916: LD_INT 6
37918: LESSEQUAL
37919: PUSH
37920: LD_VAR 0 17
37924: PUSH
37925: LD_INT 6
37927: GREATER
37928: AND
37929: IFFALSE 37945
// MCH_TrainMechanic ( side , 1 ) else
37931: LD_VAR 0 1
37935: PPUSH
37936: LD_INT 1
37938: PPUSH
37939: CALL 15868 0 2
37943: GO 37989
// if all < 6 then
37945: LD_VAR 0 17
37949: PUSH
37950: LD_INT 6
37952: LESS
37953: IFFALSE 37989
// if mech + k < all / 2 then
37955: LD_VAR 0 15
37959: PUSH
37960: LD_VAR 0 8
37964: PLUS
37965: PUSH
37966: LD_VAR 0 17
37970: PUSH
37971: LD_INT 2
37973: DIVREAL
37974: LESS
37975: IFFALSE 37989
// MCH_TrainMechanic ( side , 1 ) ;
37977: LD_VAR 0 1
37981: PPUSH
37982: LD_INT 1
37984: PPUSH
37985: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37989: LD_ADDR_VAR 0 10
37993: PUSH
37994: LD_VAR 0 1
37998: PPUSH
37999: LD_INT 30
38001: PUSH
38002: LD_INT 36
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PPUSH
38009: CALL 11667 0 2
38013: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38014: LD_VAR 0 10
38018: PUSH
38019: LD_VAR 0 15
38023: AND
38024: PUSH
38025: LD_VAR 0 1
38029: PPUSH
38030: LD_INT 3
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL 11750 0 3
38039: AND
38040: IFFALSE 38198
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38042: LD_VAR 0 1
38046: PPUSH
38047: LD_INT 9
38049: PPUSH
38050: EMPTY
38051: PPUSH
38052: CALL 12370 0 3
38056: PUSH
38057: LD_INT 3
38059: LESS
38060: IFFALSE 38198
// begin if mech < 3 then
38062: LD_VAR 0 15
38066: PUSH
38067: LD_INT 3
38069: LESS
38070: IFFALSE 38084
// k := mech else
38072: LD_ADDR_VAR 0 8
38076: PUSH
38077: LD_VAR 0 15
38081: ST_TO_ADDR
38082: GO 38092
// k := 3 ;
38084: LD_ADDR_VAR 0 8
38088: PUSH
38089: LD_INT 3
38091: ST_TO_ADDR
// for j = 1 to k do
38092: LD_ADDR_VAR 0 5
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_VAR 0 8
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38166
// if GetClass ( mech [ j ] ) = 3 then
38110: LD_VAR 0 15
38114: PUSH
38115: LD_VAR 0 5
38119: ARRAY
38120: PPUSH
38121: CALL_OW 257
38125: PUSH
38126: LD_INT 3
38128: EQUAL
38129: IFFALSE 38164
// begin SetTag ( mech [ j ] , 9 ) ;
38131: LD_VAR 0 15
38135: PUSH
38136: LD_VAR 0 5
38140: ARRAY
38141: PPUSH
38142: LD_INT 9
38144: PPUSH
38145: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38149: LD_VAR 0 15
38153: PUSH
38154: LD_VAR 0 5
38158: ARRAY
38159: PPUSH
38160: CALL_OW 122
// end ;
38164: GO 38107
38166: POP
38167: POP
// if mech < 6 + k then
38168: LD_VAR 0 15
38172: PUSH
38173: LD_INT 6
38175: PUSH
38176: LD_VAR 0 8
38180: PLUS
38181: LESS
38182: IFFALSE 38198
// MCH_TrainMechanic ( side , k ) ;
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_VAR 0 8
38193: PPUSH
38194: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_INT 9
38205: PPUSH
38206: EMPTY
38207: PPUSH
38208: CALL 12370 0 3
38212: IFFALSE 38303
// for j in MCF_Tag ( side , 9 , [ ] ) do
38214: LD_ADDR_VAR 0 5
38218: PUSH
38219: LD_VAR 0 1
38223: PPUSH
38224: LD_INT 9
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL 12370 0 3
38233: PUSH
38234: FOR_IN
38235: IFFALSE 38301
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38237: LD_VAR 0 5
38241: PPUSH
38242: CALL_OW 310
38246: NOT
38247: PUSH
38248: LD_VAR 0 5
38252: PPUSH
38253: CALL 96746 0 1
38257: NOT
38258: AND
38259: IFFALSE 38299
// if ct then
38261: LD_VAR 0 10
38265: IFFALSE 38287
// ComEnterUnit ( j , ct [ 1 ] ) else
38267: LD_VAR 0 5
38271: PPUSH
38272: LD_VAR 0 10
38276: PUSH
38277: LD_INT 1
38279: ARRAY
38280: PPUSH
38281: CALL_OW 120
38285: GO 38299
// SetTag ( j , 0 ) ;
38287: LD_VAR 0 5
38291: PPUSH
38292: LD_INT 0
38294: PPUSH
38295: CALL_OW 109
38299: GO 38234
38301: POP
38302: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38303: LD_INT 1
38305: PPUSH
38306: LD_VAR 0 1
38310: PPUSH
38311: CALL_OW 321
38315: PUSH
38316: LD_INT 2
38318: EQUAL
38319: PUSH
38320: LD_EXP 35
38324: PUSH
38325: LD_VAR 0 1
38329: ARRAY
38330: NOT
38331: AND
38332: PUSH
38333: LD_VAR 0 1
38337: PPUSH
38338: LD_INT 4
38340: PPUSH
38341: EMPTY
38342: PPUSH
38343: CALL 11750 0 3
38347: AND
38348: IFFALSE 38396
// for j in MCF_Class ( side , 4 , [ ] ) do
38350: LD_ADDR_VAR 0 5
38354: PUSH
38355: LD_VAR 0 1
38359: PPUSH
38360: LD_INT 4
38362: PPUSH
38363: EMPTY
38364: PPUSH
38365: CALL 11750 0 3
38369: PUSH
38370: FOR_IN
38371: IFFALSE 38394
// MCN_Tame ( GetSide ( j ) , j ) ;
38373: LD_VAR 0 5
38377: PPUSH
38378: CALL_OW 255
38382: PPUSH
38383: LD_VAR 0 5
38387: PPUSH
38388: CALL 18569 0 2
38392: GO 38370
38394: POP
38395: POP
// if MREG_DefVeh [ side ] then
38396: LD_EXP 67
38400: PUSH
38401: LD_VAR 0 1
38405: ARRAY
38406: IFFALSE 38570
// begin for i in MREG_DefVeh [ side ] do
38408: LD_ADDR_VAR 0 4
38412: PUSH
38413: LD_EXP 67
38417: PUSH
38418: LD_VAR 0 1
38422: ARRAY
38423: PUSH
38424: FOR_IN
38425: IFFALSE 38478
// begin SetTag ( i , 0 ) ;
38427: LD_VAR 0 4
38431: PPUSH
38432: LD_INT 0
38434: PPUSH
38435: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_EXP 64
38448: PUSH
38449: LD_VAR 0 1
38453: ARRAY
38454: PPUSH
38455: CALL_OW 308
38459: NOT
38460: IFFALSE 38476
// MCV_Parking ( side , i ) ;
38462: LD_VAR 0 1
38466: PPUSH
38467: LD_VAR 0 4
38471: PPUSH
38472: CALL 25757 0 2
// end ;
38476: GO 38424
38478: POP
38479: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38480: LD_VAR 0 1
38484: PPUSH
38485: LD_INT 36
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL 12370 0 3
38494: IFFALSE 38535
// for i in MCF_Tag ( side , 36 , [ ] ) do
38496: LD_ADDR_VAR 0 4
38500: PUSH
38501: LD_VAR 0 1
38505: PPUSH
38506: LD_INT 36
38508: PPUSH
38509: EMPTY
38510: PPUSH
38511: CALL 12370 0 3
38515: PUSH
38516: FOR_IN
38517: IFFALSE 38533
// SetTag ( i , 0 ) ;
38519: LD_VAR 0 4
38523: PPUSH
38524: LD_INT 0
38526: PPUSH
38527: CALL_OW 109
38531: GO 38516
38533: POP
38534: POP
// if MREG_DefMobActive [ side ] then
38535: LD_EXP 70
38539: PUSH
38540: LD_VAR 0 1
38544: ARRAY
38545: IFFALSE 38570
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38547: LD_ADDR_EXP 70
38551: PUSH
38552: LD_EXP 70
38556: PPUSH
38557: LD_VAR 0 1
38561: PPUSH
38562: LD_INT 0
38564: PPUSH
38565: CALL_OW 1
38569: ST_TO_ADDR
// end ; end ; if mode > 0 then
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 0
38577: GREATER
38578: IFFALSE 40473
// begin if tick <= 15 15$00 then
38580: LD_OWVAR 1
38584: PUSH
38585: LD_INT 31500
38587: LESSEQUAL
38588: IFFALSE 38892
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38590: LD_VAR 0 13
38594: PUSH
38595: LD_VAR 0 1
38599: PPUSH
38600: CALL 25022 0 1
38604: PUSH
38605: LD_INT 4
38607: LESS
38608: AND
38609: IFFALSE 38720
// begin for i in sol do
38611: LD_ADDR_VAR 0 4
38615: PUSH
38616: LD_VAR 0 13
38620: PUSH
38621: FOR_IN
38622: IFFALSE 38718
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38624: LD_ADDR_VAR 0 8
38628: PUSH
38629: LD_VAR 0 1
38633: PPUSH
38634: CALL 25022 0 1
38638: PPUSH
38639: LD_VAR 0 4
38643: PPUSH
38644: CALL_OW 74
38648: ST_TO_ADDR
// if IsInUnit ( i ) then
38649: LD_VAR 0 4
38653: PPUSH
38654: CALL_OW 310
38658: IFFALSE 38669
// ComExitBuilding ( i ) ;
38660: LD_VAR 0 4
38664: PPUSH
38665: CALL_OW 122
// if not HasTask ( i ) and k then
38669: LD_VAR 0 4
38673: PPUSH
38674: CALL_OW 314
38678: NOT
38679: PUSH
38680: LD_VAR 0 8
38684: AND
38685: IFFALSE 38716
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38687: LD_VAR 0 4
38691: PPUSH
38692: LD_VAR 0 8
38696: PPUSH
38697: CALL_OW 250
38701: PPUSH
38702: LD_VAR 0 8
38706: PPUSH
38707: CALL_OW 251
38711: PPUSH
38712: CALL_OW 174
// end ;
38716: GO 38621
38718: POP
38719: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38720: LD_VAR 0 1
38724: PPUSH
38725: LD_INT 30
38727: PUSH
38728: LD_INT 5
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PPUSH
38735: CALL 11667 0 2
38739: IFFALSE 38890
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38741: LD_ADDR_VAR 0 11
38745: PUSH
38746: LD_VAR 0 1
38750: PPUSH
38751: LD_INT 30
38753: PUSH
38754: LD_INT 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PPUSH
38761: CALL 11667 0 2
38765: PUSH
38766: LD_INT 1
38768: ARRAY
38769: ST_TO_ADDR
// if mech then
38770: LD_VAR 0 15
38774: IFFALSE 38810
// for i in mech do
38776: LD_ADDR_VAR 0 4
38780: PUSH
38781: LD_VAR 0 15
38785: PUSH
38786: FOR_IN
38787: IFFALSE 38808
// MCH_ChangeClass ( side , i , 1 ) ;
38789: LD_VAR 0 1
38793: PPUSH
38794: LD_VAR 0 4
38798: PPUSH
38799: LD_INT 1
38801: PPUSH
38802: CALL 16574 0 3
38806: GO 38786
38808: POP
38809: POP
// if eng > 1 then
38810: LD_VAR 0 14
38814: PUSH
38815: LD_INT 1
38817: GREATER
38818: IFFALSE 38865
// for i = eng downto 2 do
38820: LD_ADDR_VAR 0 4
38824: PUSH
38825: DOUBLE
38826: LD_VAR 0 14
38830: INC
38831: ST_TO_ADDR
38832: LD_INT 2
38834: PUSH
38835: FOR_DOWNTO
38836: IFFALSE 38863
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38838: LD_VAR 0 1
38842: PPUSH
38843: LD_VAR 0 14
38847: PUSH
38848: LD_VAR 0 4
38852: ARRAY
38853: PPUSH
38854: LD_INT 1
38856: PPUSH
38857: CALL 16574 0 3
38861: GO 38835
38863: POP
38864: POP
// if UnitsInside ( b ) then
38865: LD_VAR 0 11
38869: PPUSH
38870: CALL_OW 313
38874: IFFALSE 38890
// ComExitBuilding ( UnitsInside ( b ) ) ;
38876: LD_VAR 0 11
38880: PPUSH
38881: CALL_OW 313
38885: PPUSH
38886: CALL_OW 122
// end ; end else
38890: GO 40473
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38892: LD_VAR 0 1
38896: PPUSH
38897: LD_INT 1
38899: PPUSH
38900: LD_EXP 65
38904: PUSH
38905: LD_VAR 0 1
38909: ARRAY
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL 33745 0 3
38919: IFFALSE 39058
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38921: LD_ADDR_VAR 0 12
38925: PUSH
38926: LD_VAR 0 1
38930: PPUSH
38931: LD_INT 21
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL 11667 0 2
38945: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38946: LD_ADDR_VAR 0 11
38950: PUSH
38951: LD_VAR 0 1
38955: PPUSH
38956: LD_INT 30
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PPUSH
38966: CALL 11667 0 2
38970: ST_TO_ADDR
// if b then
38971: LD_VAR 0 11
38975: IFFALSE 39058
// for i in tmp do
38977: LD_ADDR_VAR 0 4
38981: PUSH
38982: LD_VAR 0 12
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39056
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38990: LD_VAR 0 4
38994: PPUSH
38995: LD_EXP 65
38999: PUSH
39000: LD_VAR 0 1
39004: ARRAY
39005: PUSH
39006: LD_INT 1
39008: ARRAY
39009: PPUSH
39010: CALL_OW 308
39014: NOT
39015: IFFALSE 39054
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39017: LD_VAR 0 4
39021: PPUSH
39022: LD_VAR 0 11
39026: PUSH
39027: LD_INT 1
39029: ARRAY
39030: PPUSH
39031: CALL_OW 250
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 251
39049: PPUSH
39050: CALL_OW 111
39054: GO 38987
39056: POP
39057: POP
// end ; if MREG_DefVeh [ side ] then
39058: LD_EXP 67
39062: PUSH
39063: LD_VAR 0 1
39067: ARRAY
39068: IFFALSE 39636
// begin tmp := [ ] ;
39070: LD_ADDR_VAR 0 12
39074: PUSH
39075: EMPTY
39076: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39077: LD_EXP 70
39081: PUSH
39082: LD_VAR 0 1
39086: ARRAY
39087: PUSH
39088: LD_INT 0
39090: EQUAL
39091: IFFALSE 39231
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39093: LD_ADDR_VAR 0 8
39097: PUSH
39098: LD_VAR 0 1
39102: PPUSH
39103: LD_INT 0
39105: PPUSH
39106: LD_INT 25
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PPUSH
39116: CALL 12370 0 3
39120: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39121: LD_VAR 0 8
39125: PUSH
39126: LD_EXP 67
39130: PUSH
39131: LD_VAR 0 1
39135: ARRAY
39136: GREATER
39137: IFFALSE 39198
// begin for i = 1 to MREG_DefVeh [ side ] do
39139: LD_ADDR_VAR 0 4
39143: PUSH
39144: DOUBLE
39145: LD_INT 1
39147: DEC
39148: ST_TO_ADDR
39149: LD_EXP 67
39153: PUSH
39154: LD_VAR 0 1
39158: ARRAY
39159: PUSH
39160: FOR_TO
39161: IFFALSE 39194
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39163: LD_ADDR_VAR 0 12
39167: PUSH
39168: LD_VAR 0 12
39172: PPUSH
39173: LD_INT 1
39175: PPUSH
39176: LD_VAR 0 8
39180: PUSH
39181: LD_VAR 0 4
39185: ARRAY
39186: PPUSH
39187: CALL_OW 2
39191: ST_TO_ADDR
39192: GO 39160
39194: POP
39195: POP
// end else
39196: GO 39208
// tmp := k ;
39198: LD_ADDR_VAR 0 12
39202: PUSH
39203: LD_VAR 0 8
39207: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39208: LD_ADDR_EXP 70
39212: PUSH
39213: LD_EXP 70
39217: PPUSH
39218: LD_VAR 0 1
39222: PPUSH
39223: LD_INT 1
39225: PPUSH
39226: CALL_OW 1
39230: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39231: LD_ADDR_VAR 0 4
39235: PUSH
39236: LD_EXP 67
39240: PUSH
39241: LD_VAR 0 1
39245: ARRAY
39246: PUSH
39247: FOR_IN
39248: IFFALSE 39634
// begin if not GetDriver ( i ) then
39250: LD_VAR 0 4
39254: PPUSH
39255: CALL 31775 0 1
39259: NOT
39260: IFFALSE 39335
// begin if tmp then
39262: LD_VAR 0 12
39266: IFFALSE 39333
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39268: LD_VAR 0 12
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39281: LD_VAR 0 12
39285: PUSH
39286: LD_INT 1
39288: ARRAY
39289: PPUSH
39290: LD_VAR 0 4
39294: PPUSH
39295: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39299: LD_VAR 0 12
39303: PUSH
39304: LD_INT 1
39306: ARRAY
39307: PPUSH
39308: LD_INT 36
39310: PPUSH
39311: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39315: LD_ADDR_VAR 0 12
39319: PUSH
39320: LD_VAR 0 12
39324: PPUSH
39325: LD_INT 1
39327: PPUSH
39328: CALL_OW 3
39332: ST_TO_ADDR
// end ; end else
39333: GO 39632
// begin if GetTag ( i ) = 0 then
39335: LD_VAR 0 4
39339: PPUSH
39340: CALL_OW 110
39344: PUSH
39345: LD_INT 0
39347: EQUAL
39348: IFFALSE 39364
// SetTag ( i , 31 ) else
39350: LD_VAR 0 4
39354: PPUSH
39355: LD_INT 31
39357: PPUSH
39358: CALL_OW 109
39362: GO 39632
// if GetTag ( i ) = 31 then
39364: LD_VAR 0 4
39368: PPUSH
39369: CALL_OW 110
39373: PUSH
39374: LD_INT 31
39376: EQUAL
39377: IFFALSE 39632
// begin if GetFuel ( i ) < 20 then
39379: LD_VAR 0 4
39383: PPUSH
39384: CALL_OW 261
39388: PUSH
39389: LD_INT 20
39391: LESS
39392: IFFALSE 39417
// begin SetTag ( i , 21 ) ;
39394: LD_VAR 0 4
39398: PPUSH
39399: LD_INT 21
39401: PPUSH
39402: CALL_OW 109
// MCV_Refuel ( i ) ;
39406: LD_VAR 0 4
39410: PPUSH
39411: CALL 26294 0 1
// continue ;
39415: GO 39247
// end ; if GetLives ( i ) < 700 then
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 256
39426: PUSH
39427: LD_INT 700
39429: LESS
39430: IFFALSE 39542
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39432: LD_VAR 0 4
39436: PPUSH
39437: LD_EXP 58
39441: PUSH
39442: LD_VAR 0 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 308
39452: NOT
39453: IFFALSE 39477
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39455: LD_VAR 0 4
39459: PPUSH
39460: LD_EXP 58
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: CALL_OW 113
39475: GO 39540
// if GetDriver ( i ) then
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL 31775 0 1
39486: IFFALSE 39540
// begin k := GetDriver ( i ) ;
39488: LD_ADDR_VAR 0 8
39492: PUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: CALL 31775 0 1
39502: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39503: LD_VAR 0 8
39507: PPUSH
39508: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39512: LD_VAR 0 8
39516: PPUSH
39517: LD_VAR 0 4
39521: PPUSH
39522: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 180
// end ; end else
39540: GO 39632
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39542: LD_ADDR_VAR 0 8
39546: PUSH
39547: LD_VAR 0 1
39551: PPUSH
39552: CALL 25022 0 1
39556: PPUSH
39557: LD_VAR 0 4
39561: PPUSH
39562: CALL_OW 74
39566: ST_TO_ADDR
// if k then
39567: LD_VAR 0 8
39571: IFFALSE 39589
// ComAttackUnit ( i , k ) else
39573: LD_VAR 0 4
39577: PPUSH
39578: LD_VAR 0 8
39582: PPUSH
39583: CALL_OW 115
39587: GO 39632
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39589: LD_VAR 0 4
39593: PPUSH
39594: LD_EXP 58
39598: PUSH
39599: LD_VAR 0 1
39603: ARRAY
39604: PPUSH
39605: CALL_OW 308
39609: NOT
39610: IFFALSE 39632
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39612: LD_VAR 0 4
39616: PPUSH
39617: LD_EXP 58
39621: PUSH
39622: LD_VAR 0 1
39626: ARRAY
39627: PPUSH
39628: CALL_OW 113
// end ; end ; end ; end ;
39632: GO 39247
39634: POP
39635: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39636: LD_VAR 0 1
39640: PPUSH
39641: LD_INT 30
39643: PUSH
39644: LD_INT 5
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PPUSH
39651: CALL 11667 0 2
39655: IFFALSE 40473
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39657: LD_ADDR_VAR 0 11
39661: PUSH
39662: LD_VAR 0 1
39666: PPUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PPUSH
39677: CALL 11667 0 2
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: ST_TO_ADDR
// if eng > 1 then
39686: LD_VAR 0 14
39690: PUSH
39691: LD_INT 1
39693: GREATER
39694: IFFALSE 39741
// for i = eng downto 2 do
39696: LD_ADDR_VAR 0 4
39700: PUSH
39701: DOUBLE
39702: LD_VAR 0 14
39706: INC
39707: ST_TO_ADDR
39708: LD_INT 2
39710: PUSH
39711: FOR_DOWNTO
39712: IFFALSE 39739
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39714: LD_VAR 0 1
39718: PPUSH
39719: LD_VAR 0 14
39723: PUSH
39724: LD_VAR 0 4
39728: ARRAY
39729: PPUSH
39730: LD_INT 1
39732: PPUSH
39733: CALL 16574 0 3
39737: GO 39711
39739: POP
39740: POP
// if sci > 1 then
39741: LD_VAR 0 16
39745: PUSH
39746: LD_INT 1
39748: GREATER
39749: IFFALSE 39796
// for i = sci downto 2 do
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: DOUBLE
39757: LD_VAR 0 16
39761: INC
39762: ST_TO_ADDR
39763: LD_INT 2
39765: PUSH
39766: FOR_DOWNTO
39767: IFFALSE 39794
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39769: LD_VAR 0 1
39773: PPUSH
39774: LD_VAR 0 16
39778: PUSH
39779: LD_VAR 0 4
39783: ARRAY
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: CALL 16574 0 3
39792: GO 39766
39794: POP
39795: POP
// if sol then
39796: LD_VAR 0 13
39800: IFFALSE 40473
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39802: LD_VAR 0 13
39806: PUSH
39807: LD_EXP 68
39811: PUSH
39812: LD_VAR 0 1
39816: ARRAY
39817: DIFF
39818: PUSH
39819: LD_INT 22
39821: PUSH
39822: LD_VAR 0 1
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 58
39833: PUSH
39834: EMPTY
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: LD_INT 30
39842: PUSH
39843: LD_INT 32
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 31
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: PPUSH
39870: CALL_OW 69
39874: PUSH
39875: LD_INT 0
39877: EQUAL
39878: AND
39879: IFFALSE 40473
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39881: LD_ADDR_VAR 0 12
39885: PUSH
39886: LD_VAR 0 13
39890: PUSH
39891: LD_EXP 68
39895: PUSH
39896: LD_VAR 0 1
39900: ARRAY
39901: DIFF
39902: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39903: LD_VAR 0 1
39907: PPUSH
39908: LD_INT 30
39910: PUSH
39911: LD_INT 5
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL 11667 0 2
39922: PUSH
39923: LD_INT 1
39925: GREATER
39926: IFFALSE 39957
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39928: LD_ADDR_VAR 0 8
39932: PUSH
39933: LD_VAR 0 1
39937: PPUSH
39938: LD_INT 30
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PPUSH
39948: CALL 11667 0 2
39952: PUSH
39953: LD_INT 2
39955: ARRAY
39956: ST_TO_ADDR
// for j in tmp do
39957: LD_ADDR_VAR 0 5
39961: PUSH
39962: LD_VAR 0 12
39966: PUSH
39967: FOR_IN
39968: IFFALSE 40471
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39970: LD_VAR 0 5
39974: PUSH
39975: LD_VAR 0 11
39979: PPUSH
39980: CALL_OW 313
39984: IN
39985: PUSH
39986: LD_VAR 0 11
39990: PPUSH
39991: CALL_OW 313
39995: PUSH
39996: LD_INT 6
39998: EQUAL
39999: AND
40000: PUSH
40001: LD_VAR 0 8
40005: AND
40006: PUSH
40007: LD_VAR 0 8
40011: PPUSH
40012: CALL_OW 313
40016: PUSH
40017: LD_INT 6
40019: LESS
40020: AND
40021: IFFALSE 40048
// begin ComExitBuilding ( j ) ;
40023: LD_VAR 0 5
40027: PPUSH
40028: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40032: LD_VAR 0 5
40036: PPUSH
40037: LD_VAR 0 8
40041: PPUSH
40042: CALL_OW 180
// continue ;
40046: GO 39967
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40048: LD_VAR 0 5
40052: PPUSH
40053: CALL_OW 314
40057: NOT
40058: PUSH
40059: LD_VAR 0 5
40063: PPUSH
40064: CALL_OW 110
40068: PUSH
40069: LD_INT 0
40071: EQUAL
40072: AND
40073: PUSH
40074: LD_VAR 0 5
40078: PPUSH
40079: CALL_OW 310
40083: NOT
40084: AND
40085: IFFALSE 40191
// begin if k then
40087: LD_VAR 0 8
40091: IFFALSE 40162
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40093: LD_VAR 0 8
40097: PPUSH
40098: CALL_OW 313
40102: PUSH
40103: LD_VAR 0 11
40107: PPUSH
40108: CALL_OW 313
40112: LESS
40113: IFFALSE 40131
// ComEnterUnit ( j , k ) else
40115: LD_VAR 0 5
40119: PPUSH
40120: LD_VAR 0 8
40124: PPUSH
40125: CALL_OW 120
40129: GO 40160
// if UnitsInside ( b ) < 6 then
40131: LD_VAR 0 11
40135: PPUSH
40136: CALL_OW 313
40140: PUSH
40141: LD_INT 6
40143: LESS
40144: IFFALSE 40160
// ComEnterUnit ( j , b ) ;
40146: LD_VAR 0 5
40150: PPUSH
40151: LD_VAR 0 11
40155: PPUSH
40156: CALL_OW 120
// end else
40160: GO 40191
// if UnitsInside ( b ) < 6 then
40162: LD_VAR 0 11
40166: PPUSH
40167: CALL_OW 313
40171: PUSH
40172: LD_INT 6
40174: LESS
40175: IFFALSE 40191
// ComEnterUnit ( j , b ) ;
40177: LD_VAR 0 5
40181: PPUSH
40182: LD_VAR 0 11
40186: PPUSH
40187: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40191: LD_VAR 0 5
40195: PUSH
40196: LD_VAR 0 1
40200: PPUSH
40201: LD_INT 54
40203: PUSH
40204: EMPTY
40205: LIST
40206: PPUSH
40207: CALL 11667 0 2
40211: IN
40212: PUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 1
40225: EQUAL
40226: AND
40227: IFFALSE 40469
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40229: LD_EXP 62
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 1
40242: ARRAY
40243: PUSH
40244: LD_INT 12
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 5
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11750 0 3
40277: PUSH
40278: LD_EXP 62
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 1
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_sniper ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 5
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39967
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40309: LD_EXP 62
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 2
40322: ARRAY
40323: PUSH
40324: LD_INT 41
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 8
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11750 0 3
40357: PUSH
40358: LD_EXP 62
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 2
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_mortar ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 8
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39967
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40389: LD_EXP 62
40393: PUSH
40394: LD_VAR 0 1
40398: ARRAY
40399: PUSH
40400: LD_INT 3
40402: ARRAY
40403: PUSH
40404: LD_INT 44
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: CALL_OW 321
40416: PUSH
40417: LD_INT 2
40419: EQUAL
40420: AND
40421: IFFALSE 40469
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40423: LD_VAR 0 1
40427: PPUSH
40428: LD_INT 9
40430: PPUSH
40431: EMPTY
40432: PPUSH
40433: CALL 11750 0 3
40437: PUSH
40438: LD_EXP 62
40442: PUSH
40443: LD_VAR 0 1
40447: ARRAY
40448: PUSH
40449: LD_INT 3
40451: ARRAY
40452: LESS
40453: IFFALSE 40469
// begin SetClass ( j , class_bazooker ) ;
40455: LD_VAR 0 5
40459: PPUSH
40460: LD_INT 9
40462: PPUSH
40463: CALL_OW 336
// continue ;
40467: GO 39967
// end ; end ; end ;
40469: GO 39967
40471: POP
40472: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40473: LD_INT 22
40475: PUSH
40476: LD_VAR 0 1
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 58
40487: PUSH
40488: EMPTY
40489: LIST
40490: PUSH
40491: LD_INT 30
40493: PUSH
40494: LD_INT 32
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 69
40510: IFFALSE 40660
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40512: LD_ADDR_VAR 0 12
40516: PUSH
40517: LD_INT 22
40519: PUSH
40520: LD_VAR 0 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 58
40531: PUSH
40532: EMPTY
40533: LIST
40534: PUSH
40535: LD_INT 30
40537: PUSH
40538: LD_INT 32
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: LIST
40549: PPUSH
40550: CALL_OW 69
40554: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40555: LD_ADDR_VAR 0 8
40559: PUSH
40560: LD_VAR 0 13
40564: PUSH
40565: LD_EXP 68
40569: PUSH
40570: LD_VAR 0 1
40574: ARRAY
40575: DIFF
40576: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40577: LD_VAR 0 12
40581: PUSH
40582: LD_INT 1
40584: ARRAY
40585: PPUSH
40586: CALL_OW 461
40590: PUSH
40591: LD_INT 2
40593: EQUAL
40594: PUSH
40595: LD_VAR 0 12
40599: PUSH
40600: LD_INT 1
40602: ARRAY
40603: PUSH
40604: LD_EXP 68
40608: PUSH
40609: LD_VAR 0 1
40613: ARRAY
40614: IN
40615: NOT
40616: AND
40617: PUSH
40618: LD_VAR 0 8
40622: AND
40623: IFFALSE 40660
// begin ComExitBuilding ( k [ 1 ] ) ;
40625: LD_VAR 0 8
40629: PUSH
40630: LD_INT 1
40632: ARRAY
40633: PPUSH
40634: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: PPUSH
40647: LD_VAR 0 12
40651: PUSH
40652: LD_INT 1
40654: ARRAY
40655: PPUSH
40656: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40660: LD_EXP 35
40664: PUSH
40665: LD_VAR 0 1
40669: ARRAY
40670: IFFALSE 40818
// begin if MCF_Class ( side , 4 , [ ] ) then
40672: LD_VAR 0 1
40676: PPUSH
40677: LD_INT 4
40679: PPUSH
40680: EMPTY
40681: PPUSH
40682: CALL 11750 0 3
40686: IFFALSE 40816
// for j in MCF_Class ( side , 4 , [ ] ) do
40688: LD_ADDR_VAR 0 5
40692: PUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: LD_INT 4
40700: PPUSH
40701: EMPTY
40702: PPUSH
40703: CALL 11750 0 3
40707: PUSH
40708: FOR_IN
40709: IFFALSE 40814
// begin if not GetTag ( j ) = 4 then
40711: LD_VAR 0 5
40715: PPUSH
40716: CALL_OW 110
40720: PUSH
40721: LD_INT 4
40723: EQUAL
40724: NOT
40725: IFFALSE 40761
// begin SetTag ( j , 4 ) ;
40727: LD_VAR 0 5
40731: PPUSH
40732: LD_INT 4
40734: PPUSH
40735: CALL_OW 109
// if IsInUnit ( j ) then
40739: LD_VAR 0 5
40743: PPUSH
40744: CALL_OW 310
40748: IFFALSE 40759
// ComExitBuilding ( j ) ;
40750: LD_VAR 0 5
40754: PPUSH
40755: CALL_OW 122
// end else
40759: GO 40812
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40761: LD_VAR 0 5
40765: PPUSH
40766: LD_EXP 35
40770: PUSH
40771: LD_VAR 0 1
40775: ARRAY
40776: PUSH
40777: LD_INT 1
40779: ARRAY
40780: PPUSH
40781: CALL 96370 0 2
40785: NOT
40786: IFFALSE 40812
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40788: LD_VAR 0 5
40792: PPUSH
40793: LD_EXP 35
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: PUSH
40804: LD_INT 1
40806: ARRAY
40807: PPUSH
40808: CALL 19237 0 2
// end ;
40812: GO 40708
40814: POP
40815: POP
// end else
40816: GO 41050
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40818: LD_VAR 0 1
40822: PPUSH
40823: LD_INT 4
40825: PPUSH
40826: EMPTY
40827: PPUSH
40828: CALL 11750 0 3
40832: PUSH
40833: LD_VAR 0 1
40837: PPUSH
40838: LD_INT 4
40840: PPUSH
40841: EMPTY
40842: PPUSH
40843: CALL 12370 0 3
40847: AND
40848: IFFALSE 41050
// for j in MCF_Class ( side , 4 , [ ] ) do
40850: LD_ADDR_VAR 0 5
40854: PUSH
40855: LD_VAR 0 1
40859: PPUSH
40860: LD_INT 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL 11750 0 3
40869: PUSH
40870: FOR_IN
40871: IFFALSE 41048
// begin if GetTag ( j ) = 4 then
40873: LD_VAR 0 5
40877: PPUSH
40878: CALL_OW 110
40882: PUSH
40883: LD_INT 4
40885: EQUAL
40886: IFFALSE 41046
// begin SetTag ( j , 0 ) ;
40888: LD_VAR 0 5
40892: PPUSH
40893: LD_INT 0
40895: PPUSH
40896: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40900: LD_VAR 0 1
40904: PPUSH
40905: CALL 11706 0 1
40909: PUSH
40910: LD_VAR 0 1
40914: PPUSH
40915: CALL 18050 0 1
40919: NOT
40920: AND
40921: IFFALSE 40946
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40923: LD_VAR 0 5
40927: PPUSH
40928: LD_VAR 0 1
40932: PPUSH
40933: CALL 11706 0 1
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PPUSH
40942: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40946: LD_VAR 0 1
40950: PPUSH
40951: CALL 11706 0 1
40955: NOT
40956: PUSH
40957: LD_VAR 0 1
40961: PPUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL 11667 0 2
40976: AND
40977: IFFALSE 41046
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40979: LD_VAR 0 5
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 1
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL 11667 0 2
41003: PUSH
41004: LD_INT 1
41006: ARRAY
41007: PPUSH
41008: CALL_OW 250
41012: PPUSH
41013: LD_VAR 0 1
41017: PPUSH
41018: LD_INT 30
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PPUSH
41028: CALL 11667 0 2
41032: PUSH
41033: LD_INT 1
41035: ARRAY
41036: PPUSH
41037: CALL_OW 251
41041: PPUSH
41042: CALL_OW 111
// end ; end ;
41046: GO 40870
41048: POP
41049: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 3
41057: PPUSH
41058: EMPTY
41059: PPUSH
41060: CALL 11750 0 3
41064: PUSH
41065: LD_EXP 58
41069: PUSH
41070: LD_VAR 0 1
41074: ARRAY
41075: AND
41076: PUSH
41077: LD_VAR 0 1
41081: PPUSH
41082: LD_INT 6
41084: PPUSH
41085: EMPTY
41086: PPUSH
41087: CALL 12370 0 3
41091: AND
41092: IFFALSE 41623
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41094: LD_ADDR_VAR 0 6
41098: PUSH
41099: LD_EXP 58
41103: PUSH
41104: LD_VAR 0 1
41108: ARRAY
41109: PPUSH
41110: LD_INT 0
41112: PPUSH
41113: CALL_OW 517
41117: PUSH
41118: LD_INT 1
41120: ARRAY
41121: PUSH
41122: LD_INT 1
41124: ARRAY
41125: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41126: LD_ADDR_VAR 0 7
41130: PUSH
41131: LD_EXP 58
41135: PUSH
41136: LD_VAR 0 1
41140: ARRAY
41141: PPUSH
41142: LD_INT 0
41144: PPUSH
41145: CALL_OW 517
41149: PUSH
41150: LD_INT 2
41152: ARRAY
41153: PUSH
41154: LD_INT 1
41156: ARRAY
41157: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41158: LD_VAR 0 1
41162: PPUSH
41163: LD_INT 6
41165: PPUSH
41166: EMPTY
41167: PPUSH
41168: CALL 12370 0 3
41172: IFFALSE 41621
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41174: LD_ADDR_VAR 0 8
41178: PUSH
41179: LD_VAR 0 1
41183: PPUSH
41184: LD_INT 6
41186: PPUSH
41187: EMPTY
41188: PPUSH
41189: CALL 12370 0 3
41193: PUSH
41194: FOR_IN
41195: IFFALSE 41226
// if GetLives ( k ) = 1000 then
41197: LD_VAR 0 8
41201: PPUSH
41202: CALL_OW 256
41206: PUSH
41207: LD_INT 1000
41209: EQUAL
41210: IFFALSE 41224
// SetTag ( k , 0 ) ;
41212: LD_VAR 0 8
41216: PPUSH
41217: LD_INT 0
41219: PPUSH
41220: CALL_OW 109
41224: GO 41194
41226: POP
41227: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41228: LD_VAR 0 1
41232: PPUSH
41233: LD_INT 0
41235: PPUSH
41236: LD_INT 25
41238: PUSH
41239: LD_INT 3
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PPUSH
41246: CALL 12370 0 3
41250: IFFALSE 41314
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41252: LD_ADDR_VAR 0 8
41256: PUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: LD_INT 0
41264: PPUSH
41265: LD_INT 25
41267: PUSH
41268: LD_INT 3
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PPUSH
41275: CALL 12370 0 3
41279: PUSH
41280: FOR_IN
41281: IFFALSE 41312
// if GetTag ( k ) = 0 then
41283: LD_VAR 0 8
41287: PPUSH
41288: CALL_OW 110
41292: PUSH
41293: LD_INT 0
41295: EQUAL
41296: IFFALSE 41310
// begin SetTag ( k , 8 ) ;
41298: LD_VAR 0 8
41302: PPUSH
41303: LD_INT 8
41305: PPUSH
41306: CALL_OW 109
// end ;
41310: GO 41280
41312: POP
41313: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41314: LD_VAR 0 1
41318: PPUSH
41319: LD_INT 6
41321: PPUSH
41322: LD_INT 92
41324: PUSH
41325: LD_VAR 0 6
41329: PUSH
41330: LD_VAR 0 7
41334: PUSH
41335: LD_INT 10
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: PPUSH
41344: CALL 12370 0 3
41348: IFFALSE 41472
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41350: LD_ADDR_VAR 0 5
41354: PUSH
41355: LD_VAR 0 4
41359: PPUSH
41360: LD_INT 6
41362: PPUSH
41363: LD_INT 92
41365: PUSH
41366: LD_VAR 0 6
41370: PUSH
41371: LD_VAR 0 7
41375: PUSH
41376: LD_INT 10
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL 12370 0 3
41389: PUSH
41390: FOR_IN
41391: IFFALSE 41470
// begin if not HasTask ( j ) and GetDriver ( j ) then
41393: LD_VAR 0 5
41397: PPUSH
41398: CALL_OW 314
41402: NOT
41403: PUSH
41404: LD_VAR 0 5
41408: PPUSH
41409: CALL 31775 0 1
41413: AND
41414: IFFALSE 41468
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41416: LD_VAR 0 5
41420: PPUSH
41421: CALL 31775 0 1
41425: PPUSH
41426: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31775 0 1
41439: PPUSH
41440: LD_VAR 0 5
41444: PPUSH
41445: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41449: LD_VAR 0 5
41453: PPUSH
41454: CALL 31775 0 1
41458: PPUSH
41459: LD_VAR 0 5
41463: PPUSH
41464: CALL_OW 180
// end ; end ;
41468: GO 41390
41470: POP
41471: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41472: LD_VAR 0 1
41476: PPUSH
41477: LD_INT 6
41479: PPUSH
41480: LD_INT 92
41482: PUSH
41483: LD_VAR 0 6
41487: PUSH
41488: LD_VAR 0 7
41492: PUSH
41493: LD_INT 10
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL 12370 0 3
41506: PUSH
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 8
41514: PPUSH
41515: EMPTY
41516: PPUSH
41517: CALL 12370 0 3
41521: AND
41522: IFFALSE 41621
// for j in MCF_Tag ( side , 8 , [ ] ) do
41524: LD_ADDR_VAR 0 5
41528: PUSH
41529: LD_VAR 0 1
41533: PPUSH
41534: LD_INT 8
41536: PPUSH
41537: EMPTY
41538: PPUSH
41539: CALL 12370 0 3
41543: PUSH
41544: FOR_IN
41545: IFFALSE 41619
// begin if IsInUnit ( j ) then
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 310
41556: IFFALSE 41569
// ComExitBuilding ( j ) else
41558: LD_VAR 0 5
41562: PPUSH
41563: CALL_OW 122
41567: GO 41617
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41569: LD_VAR 0 5
41573: PPUSH
41574: LD_VAR 0 1
41578: PPUSH
41579: LD_INT 6
41581: PPUSH
41582: LD_INT 92
41584: PUSH
41585: LD_VAR 0 6
41589: PUSH
41590: LD_VAR 0 7
41594: PUSH
41595: LD_INT 10
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: PPUSH
41604: CALL 12370 0 3
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL_OW 129
// end ;
41617: GO 41544
41619: POP
41620: POP
// end ; end else
41621: GO 41678
// if MCF_Tag ( side , 8 , [ ] ) then
41623: LD_VAR 0 1
41627: PPUSH
41628: LD_INT 8
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL 12370 0 3
41637: IFFALSE 41678
// for k in MCF_Tag ( side , 8 , [ ] ) do
41639: LD_ADDR_VAR 0 8
41643: PUSH
41644: LD_VAR 0 1
41648: PPUSH
41649: LD_INT 8
41651: PPUSH
41652: EMPTY
41653: PPUSH
41654: CALL 12370 0 3
41658: PUSH
41659: FOR_IN
41660: IFFALSE 41676
// SetTag ( k , 0 ) ;
41662: LD_VAR 0 8
41666: PPUSH
41667: LD_INT 0
41669: PPUSH
41670: CALL_OW 109
41674: GO 41659
41676: POP
41677: POP
// end ; end_of_file
41678: LD_VAR 0 3
41682: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41683: LD_INT 0
41685: PPUSH
// MREG_Game := [ ] ;
41686: LD_ADDR_EXP 33
41690: PUSH
41691: EMPTY
41692: ST_TO_ADDR
// MREG_Crates := [ ] ;
41693: LD_ADDR_EXP 34
41697: PUSH
41698: EMPTY
41699: ST_TO_ADDR
// MREG_Heal := [ ] ;
41700: LD_ADDR_EXP 35
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Tame := [ ] ;
41707: LD_ADDR_EXP 37
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41714: LD_ADDR_EXP 38
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41721: LD_ADDR_EXP 39
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_LabList := [ ] ;
41728: LD_ADDR_EXP 40
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41735: LD_ADDR_EXP 41
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41742: LD_ADDR_EXP 42
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41749: LD_ADDR_EXP 43
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41756: LD_ADDR_EXP 44
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_Status := [ ] ;
41763: LD_ADDR_EXP 45
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41770: LD_ADDR_EXP 46
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41777: LD_ADDR_EXP 47
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41784: LD_ADDR_EXP 48
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41791: LD_ADDR_EXP 49
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41798: LD_ADDR_EXP 50
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41805: LD_ADDR_EXP 51
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41812: LD_ADDR_EXP 52
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41819: LD_ADDR_EXP 53
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41826: LD_ADDR_EXP 54
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41833: LD_ADDR_EXP 55
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41840: LD_ADDR_EXP 56
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41847: LD_ADDR_EXP 57
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41854: LD_ADDR_EXP 61
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41861: LD_ADDR_EXP 62
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Parking := [ ] ;
41868: LD_ADDR_EXP 58
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41875: LD_ADDR_EXP 59
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41882: LD_ADDR_EXP 63
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41889: LD_ADDR_EXP 64
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41896: LD_ADDR_EXP 65
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41903: LD_ADDR_EXP 67
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41910: LD_ADDR_EXP 68
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41917: LD_ADDR_EXP 69
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41924: LD_ADDR_EXP 71
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41931: LD_ADDR_EXP 70
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41938: LD_ADDR_EXP 72
41942: PUSH
41943: LD_INT 300
41945: PUSH
41946: LD_INT 100
41948: PUSH
41949: LD_INT 25
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// end ;
41957: LD_VAR 0 1
41961: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41962: LD_INT 0
41964: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41965: LD_VAR 0 2
41969: PUSH
41970: LD_VAR 0 3
41974: PUSH
41975: LD_VAR 0 4
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: LD_VAR 0 1
41989: IN
41990: IFFALSE 42004
// result := mreg_list else
41992: LD_ADDR_VAR 0 5
41996: PUSH
41997: LD_VAR 0 1
42001: ST_TO_ADDR
42002: GO 42038
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42004: LD_ADDR_VAR 0 1
42008: PUSH
42009: LD_VAR 0 1
42013: PUSH
42014: LD_VAR 0 2
42018: PUSH
42019: LD_VAR 0 3
42023: PUSH
42024: LD_VAR 0 4
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: ADD
42037: ST_TO_ADDR
// result := mreg_list ;
42038: LD_ADDR_VAR 0 5
42042: PUSH
42043: LD_VAR 0 1
42047: ST_TO_ADDR
// end ;
42048: LD_VAR 0 5
42052: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42053: LD_INT 0
42055: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42056: LD_VAR 0 2
42060: PUSH
42061: LD_VAR 0 3
42065: PUSH
42066: LD_VAR 0 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: PUSH
42076: LD_VAR 0 1
42080: IN
42081: IFFALSE 42119
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42083: LD_ADDR_VAR 0 5
42087: PUSH
42088: LD_VAR 0 1
42092: PUSH
42093: LD_VAR 0 2
42097: PUSH
42098: LD_VAR 0 3
42102: PUSH
42103: LD_VAR 0 4
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: PUSH
42113: EMPTY
42114: LIST
42115: DIFF
42116: ST_TO_ADDR
42117: GO 42129
// result := mreg_list ;
42119: LD_ADDR_VAR 0 5
42123: PUSH
42124: LD_VAR 0 1
42128: ST_TO_ADDR
// end ;
42129: LD_VAR 0 5
42133: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42134: LD_INT 0
42136: PPUSH
42137: PPUSH
42138: PPUSH
// for j = 1 to 8 do
42139: LD_ADDR_VAR 0 3
42143: PUSH
42144: DOUBLE
42145: LD_INT 1
42147: DEC
42148: ST_TO_ADDR
42149: LD_INT 8
42151: PUSH
42152: FOR_TO
42153: IFFALSE 42994
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42155: LD_VAR 0 3
42159: PPUSH
42160: LD_INT 51
42162: PUSH
42163: EMPTY
42164: LIST
42165: PPUSH
42166: CALL 11667 0 2
42170: PUSH
42171: LD_OWVAR 2
42175: PUSH
42176: LD_VAR 0 3
42180: EQUAL
42181: NOT
42182: AND
42183: IFFALSE 42201
// MREG_SidesList := MREG_SidesList ^ 1 else
42185: LD_ADDR_EXP 39
42189: PUSH
42190: LD_EXP 39
42194: PUSH
42195: LD_INT 1
42197: ADD
42198: ST_TO_ADDR
42199: GO 42215
// MREG_SidesList := MREG_SidesList ^ 0 ;
42201: LD_ADDR_EXP 39
42205: PUSH
42206: LD_EXP 39
42210: PUSH
42211: LD_INT 0
42213: ADD
42214: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42215: LD_VAR 0 3
42219: PPUSH
42220: LD_INT 2
42222: PUSH
42223: LD_INT 34
42225: PUSH
42226: LD_INT 12
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 34
42235: PUSH
42236: LD_INT 32
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 34
42245: PUSH
42246: LD_INT 51
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: PUSH
42259: EMPTY
42260: LIST
42261: PPUSH
42262: CALL 11968 0 2
42266: IFFALSE 42367
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42268: LD_ADDR_VAR 0 2
42272: PUSH
42273: LD_VAR 0 3
42277: PPUSH
42278: LD_INT 2
42280: PUSH
42281: LD_INT 34
42283: PUSH
42284: LD_INT 12
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 34
42293: PUSH
42294: LD_INT 32
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 34
42303: PUSH
42304: LD_INT 51
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: LIST
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: CALL 11968 0 2
42324: PUSH
42325: FOR_IN
42326: IFFALSE 42365
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42328: LD_ADDR_EXP 41
42332: PUSH
42333: LD_EXP 41
42337: PPUSH
42338: LD_VAR 0 3
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: LD_VAR 0 2
42352: PPUSH
42353: CALL_OW 264
42357: PPUSH
42358: CALL 41962 0 4
42362: ST_TO_ADDR
42363: GO 42325
42365: POP
42366: POP
// if MCF_Class ( j , 4 , [ ] ) then
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_INT 4
42374: PPUSH
42375: EMPTY
42376: PPUSH
42377: CALL 11750 0 3
42381: IFFALSE 42414
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42383: LD_ADDR_EXP 54
42387: PUSH
42388: LD_EXP 54
42392: PUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: LD_INT 4
42400: PPUSH
42401: EMPTY
42402: PPUSH
42403: CALL 11750 0 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: ADD
42411: ST_TO_ADDR
42412: GO 42431
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42414: LD_ADDR_EXP 54
42418: PUSH
42419: LD_EXP 54
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: EMPTY
42428: LIST
42429: ADD
42430: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_INT 3
42438: PPUSH
42439: EMPTY
42440: PPUSH
42441: CALL 11750 0 3
42445: IFFALSE 42478
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42447: LD_ADDR_EXP 55
42451: PUSH
42452: LD_EXP 55
42456: PUSH
42457: LD_VAR 0 3
42461: PPUSH
42462: LD_INT 3
42464: PPUSH
42465: EMPTY
42466: PPUSH
42467: CALL 11750 0 3
42471: PUSH
42472: EMPTY
42473: LIST
42474: ADD
42475: ST_TO_ADDR
42476: GO 42495
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42478: LD_ADDR_EXP 55
42482: PUSH
42483: LD_EXP 55
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: ADD
42494: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42495: LD_VAR 0 3
42499: PPUSH
42500: LD_INT 1
42502: PPUSH
42503: EMPTY
42504: PPUSH
42505: CALL 11750 0 3
42509: IFFALSE 42542
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42511: LD_ADDR_EXP 56
42515: PUSH
42516: LD_EXP 56
42520: PUSH
42521: LD_VAR 0 3
42525: PPUSH
42526: LD_INT 1
42528: PPUSH
42529: EMPTY
42530: PPUSH
42531: CALL 11750 0 3
42535: PUSH
42536: EMPTY
42537: LIST
42538: ADD
42539: ST_TO_ADDR
42540: GO 42559
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42542: LD_ADDR_EXP 56
42546: PUSH
42547: LD_EXP 56
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: ADD
42558: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42559: LD_VAR 0 3
42563: PPUSH
42564: LD_INT 2
42566: PPUSH
42567: EMPTY
42568: PPUSH
42569: CALL 11750 0 3
42573: IFFALSE 42606
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42575: LD_ADDR_EXP 57
42579: PUSH
42580: LD_EXP 57
42584: PUSH
42585: LD_VAR 0 3
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: EMPTY
42594: PPUSH
42595: CALL 11750 0 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: ADD
42603: ST_TO_ADDR
42604: GO 42623
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42606: LD_ADDR_EXP 57
42610: PUSH
42611: LD_EXP 57
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: EMPTY
42620: LIST
42621: ADD
42622: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42623: LD_ADDR_EXP 47
42627: PUSH
42628: LD_EXP 47
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: ADD
42639: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42640: LD_ADDR_EXP 35
42644: PUSH
42645: LD_EXP 35
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: EMPTY
42654: LIST
42655: ADD
42656: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42657: LD_ADDR_EXP 37
42661: PUSH
42662: LD_EXP 37
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: ADD
42673: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42674: LD_ADDR_EXP 58
42678: PUSH
42679: LD_EXP 58
42683: PUSH
42684: LD_INT 0
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42691: LD_ADDR_EXP 59
42695: PUSH
42696: LD_EXP 59
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: ADD
42707: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42708: LD_ADDR_EXP 51
42712: PUSH
42713: LD_EXP 51
42717: PUSH
42718: LD_INT 0
42720: PUSH
42721: EMPTY
42722: LIST
42723: ADD
42724: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42725: LD_ADDR_EXP 38
42729: PUSH
42730: LD_EXP 38
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: LD_INT 0
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: ADD
42756: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42757: LD_ADDR_EXP 60
42761: PUSH
42762: LD_EXP 60
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: ADD
42779: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42780: LD_ADDR_EXP 61
42784: PUSH
42785: LD_EXP 61
42789: PUSH
42790: LD_INT 0
42792: PUSH
42793: EMPTY
42794: LIST
42795: PUSH
42796: EMPTY
42797: LIST
42798: ADD
42799: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42800: LD_ADDR_EXP 42
42804: PUSH
42805: LD_EXP 42
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: ADD
42816: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42817: LD_ADDR_EXP 63
42821: PUSH
42822: LD_EXP 63
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: EMPTY
42831: LIST
42832: ADD
42833: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42834: LD_ADDR_EXP 64
42838: PUSH
42839: LD_EXP 64
42843: PUSH
42844: LD_INT 0
42846: PUSH
42847: EMPTY
42848: LIST
42849: ADD
42850: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42851: LD_ADDR_EXP 65
42855: PUSH
42856: LD_EXP 65
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: ADD
42867: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42868: LD_ADDR_EXP 66
42872: PUSH
42873: LD_EXP 66
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: EMPTY
42882: LIST
42883: ADD
42884: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42885: LD_ADDR_EXP 67
42889: PUSH
42890: LD_EXP 67
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42902: LD_ADDR_EXP 68
42906: PUSH
42907: LD_EXP 68
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42919: LD_ADDR_EXP 69
42923: PUSH
42924: LD_EXP 69
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42936: LD_ADDR_EXP 71
42940: PUSH
42941: LD_EXP 71
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42953: LD_ADDR_EXP 70
42957: PUSH
42958: LD_EXP 70
42962: PUSH
42963: LD_INT 0
42965: ADD
42966: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42967: LD_ADDR_EXP 62
42971: PUSH
42972: LD_EXP 62
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: LIST
42990: ADD
42991: ST_TO_ADDR
// end ;
42992: GO 42152
42994: POP
42995: POP
// end ;
42996: LD_VAR 0 1
43000: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43001: LD_INT 0
43003: PPUSH
43004: PPUSH
43005: PPUSH
// m := false ;
43006: LD_ADDR_VAR 0 5
43010: PUSH
43011: LD_INT 0
43013: ST_TO_ADDR
// for i = 1 to mreg do
43014: LD_ADDR_VAR 0 4
43018: PUSH
43019: DOUBLE
43020: LD_INT 1
43022: DEC
43023: ST_TO_ADDR
43024: LD_VAR 0 2
43028: PUSH
43029: FOR_TO
43030: IFFALSE 43066
// if mreg [ i ] [ 1 ] = side then
43032: LD_VAR 0 2
43036: PUSH
43037: LD_VAR 0 4
43041: ARRAY
43042: PUSH
43043: LD_INT 1
43045: ARRAY
43046: PUSH
43047: LD_VAR 0 1
43051: EQUAL
43052: IFFALSE 43064
// begin m := true ;
43054: LD_ADDR_VAR 0 5
43058: PUSH
43059: LD_INT 1
43061: ST_TO_ADDR
// break ;
43062: GO 43066
// end ;
43064: GO 43029
43066: POP
43067: POP
// result := m ;
43068: LD_ADDR_VAR 0 3
43072: PUSH
43073: LD_VAR 0 5
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43083: LD_INT 0
43085: PPUSH
43086: PPUSH
43087: PPUSH
// m := 0 ;
43088: LD_ADDR_VAR 0 5
43092: PUSH
43093: LD_INT 0
43095: ST_TO_ADDR
// for i = 1 to mreg do
43096: LD_ADDR_VAR 0 4
43100: PUSH
43101: DOUBLE
43102: LD_INT 1
43104: DEC
43105: ST_TO_ADDR
43106: LD_VAR 0 2
43110: PUSH
43111: FOR_TO
43112: IFFALSE 43152
// if mreg [ i ] [ 1 ] = side then
43114: LD_VAR 0 2
43118: PUSH
43119: LD_VAR 0 4
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: PUSH
43129: LD_VAR 0 1
43133: EQUAL
43134: IFFALSE 43150
// begin m := m + 1 ;
43136: LD_ADDR_VAR 0 5
43140: PUSH
43141: LD_VAR 0 5
43145: PUSH
43146: LD_INT 1
43148: PLUS
43149: ST_TO_ADDR
// end ;
43150: GO 43111
43152: POP
43153: POP
// result := m ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_VAR 0 5
43163: ST_TO_ADDR
// end ;
43164: LD_VAR 0 3
43168: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43169: LD_INT 0
43171: PPUSH
43172: PPUSH
// result := 0 ;
43173: LD_ADDR_VAR 0 3
43177: PUSH
43178: LD_INT 0
43180: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43181: LD_ADDR_VAR 0 4
43185: PUSH
43186: DOUBLE
43187: LD_INT 1
43189: DEC
43190: ST_TO_ADDR
43191: LD_EXP 53
43195: PUSH
43196: FOR_TO
43197: IFFALSE 43259
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43199: LD_EXP 53
43203: PUSH
43204: LD_VAR 0 4
43208: ARRAY
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_VAR 0 1
43218: EQUAL
43219: PUSH
43220: LD_EXP 53
43224: PUSH
43225: LD_VAR 0 4
43229: ARRAY
43230: PUSH
43231: LD_INT 2
43233: ARRAY
43234: PUSH
43235: LD_VAR 0 2
43239: EQUAL
43240: AND
43241: IFFALSE 43257
// begin result := result + 1 ;
43243: LD_ADDR_VAR 0 3
43247: PUSH
43248: LD_VAR 0 3
43252: PUSH
43253: LD_INT 1
43255: PLUS
43256: ST_TO_ADDR
// end ;
43257: GO 43196
43259: POP
43260: POP
// end ; end_of_file
43261: LD_VAR 0 3
43265: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43266: LD_INT 0
43268: PPUSH
// ar_miner := 81 ;
43269: LD_ADDR_EXP 80
43273: PUSH
43274: LD_INT 81
43276: ST_TO_ADDR
// ar_crane := 88 ;
43277: LD_ADDR_EXP 79
43281: PUSH
43282: LD_INT 88
43284: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43285: LD_ADDR_EXP 74
43289: PUSH
43290: LD_INT 89
43292: ST_TO_ADDR
// us_hack := 99 ;
43293: LD_ADDR_EXP 75
43297: PUSH
43298: LD_INT 99
43300: ST_TO_ADDR
// us_artillery := 97 ;
43301: LD_ADDR_EXP 76
43305: PUSH
43306: LD_INT 97
43308: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43309: LD_ADDR_EXP 77
43313: PUSH
43314: LD_INT 91
43316: ST_TO_ADDR
// ar_mortar := 92 ;
43317: LD_ADDR_EXP 78
43321: PUSH
43322: LD_INT 92
43324: ST_TO_ADDR
// ru_radar := 98 ;
43325: LD_ADDR_EXP 73
43329: PUSH
43330: LD_INT 98
43332: ST_TO_ADDR
// tech_Artillery := 80 ;
43333: LD_ADDR_EXP 81
43337: PUSH
43338: LD_INT 80
43340: ST_TO_ADDR
// tech_RadMat := 81 ;
43341: LD_ADDR_EXP 82
43345: PUSH
43346: LD_INT 81
43348: ST_TO_ADDR
// tech_BasicTools := 82 ;
43349: LD_ADDR_EXP 83
43353: PUSH
43354: LD_INT 82
43356: ST_TO_ADDR
// tech_Cargo := 83 ;
43357: LD_ADDR_EXP 84
43361: PUSH
43362: LD_INT 83
43364: ST_TO_ADDR
// tech_Track := 84 ;
43365: LD_ADDR_EXP 85
43369: PUSH
43370: LD_INT 84
43372: ST_TO_ADDR
// tech_Crane := 85 ;
43373: LD_ADDR_EXP 86
43377: PUSH
43378: LD_INT 85
43380: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43381: LD_ADDR_EXP 87
43385: PUSH
43386: LD_INT 86
43388: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43389: LD_ADDR_EXP 88
43393: PUSH
43394: LD_INT 87
43396: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43397: LD_ADDR_EXP 89
43401: PUSH
43402: LD_INT 88
43404: ST_TO_ADDR
// class_mastodont := 31 ;
43405: LD_ADDR_EXP 90
43409: PUSH
43410: LD_INT 31
43412: ST_TO_ADDR
// class_horse := 21 ;
43413: LD_ADDR_EXP 91
43417: PUSH
43418: LD_INT 21
43420: ST_TO_ADDR
// end ;
43421: LD_VAR 0 1
43425: RET
// every 1 do
43426: GO 43428
43428: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43429: CALL 43266 0 0
43433: END
// every 0 0$1 do
43434: GO 43436
43436: DISABLE
// begin enable ;
43437: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43438: LD_STRING updateTimer(
43440: PUSH
43441: LD_OWVAR 1
43445: STR
43446: PUSH
43447: LD_STRING );
43449: STR
43450: PPUSH
43451: CALL_OW 559
// end ;
43455: END
// on MapStart ( p ) do begin if streamModeActive then
43456: LD_EXP 92
43460: IFFALSE 43469
// DefineStreamItems ( true ) ;
43462: LD_INT 1
43464: PPUSH
43465: CALL 45117 0 1
// UpdateFactoryWaypoints ( ) ;
43469: CALL 58701 0 0
// end ;
43473: PPOPN 1
43475: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43476: LD_INT 0
43478: PPUSH
// if p2 = 100 then
43479: LD_VAR 0 2
43483: PUSH
43484: LD_INT 100
43486: EQUAL
43487: IFFALSE 44490
// begin if not StreamModeActive then
43489: LD_EXP 92
43493: NOT
43494: IFFALSE 43504
// StreamModeActive := true ;
43496: LD_ADDR_EXP 92
43500: PUSH
43501: LD_INT 1
43503: ST_TO_ADDR
// if p3 = 0 then
43504: LD_VAR 0 3
43508: PUSH
43509: LD_INT 0
43511: EQUAL
43512: IFFALSE 43518
// InitStreamMode ;
43514: CALL 44653 0 0
// if p3 = 1 then
43518: LD_VAR 0 3
43522: PUSH
43523: LD_INT 1
43525: EQUAL
43526: IFFALSE 43536
// sRocket := true ;
43528: LD_ADDR_EXP 97
43532: PUSH
43533: LD_INT 1
43535: ST_TO_ADDR
// if p3 = 2 then
43536: LD_VAR 0 3
43540: PUSH
43541: LD_INT 2
43543: EQUAL
43544: IFFALSE 43554
// sSpeed := true ;
43546: LD_ADDR_EXP 96
43550: PUSH
43551: LD_INT 1
43553: ST_TO_ADDR
// if p3 = 3 then
43554: LD_VAR 0 3
43558: PUSH
43559: LD_INT 3
43561: EQUAL
43562: IFFALSE 43572
// sEngine := true ;
43564: LD_ADDR_EXP 98
43568: PUSH
43569: LD_INT 1
43571: ST_TO_ADDR
// if p3 = 4 then
43572: LD_VAR 0 3
43576: PUSH
43577: LD_INT 4
43579: EQUAL
43580: IFFALSE 43590
// sSpec := true ;
43582: LD_ADDR_EXP 95
43586: PUSH
43587: LD_INT 1
43589: ST_TO_ADDR
// if p3 = 5 then
43590: LD_VAR 0 3
43594: PUSH
43595: LD_INT 5
43597: EQUAL
43598: IFFALSE 43608
// sLevel := true ;
43600: LD_ADDR_EXP 99
43604: PUSH
43605: LD_INT 1
43607: ST_TO_ADDR
// if p3 = 6 then
43608: LD_VAR 0 3
43612: PUSH
43613: LD_INT 6
43615: EQUAL
43616: IFFALSE 43626
// sArmoury := true ;
43618: LD_ADDR_EXP 100
43622: PUSH
43623: LD_INT 1
43625: ST_TO_ADDR
// if p3 = 7 then
43626: LD_VAR 0 3
43630: PUSH
43631: LD_INT 7
43633: EQUAL
43634: IFFALSE 43644
// sRadar := true ;
43636: LD_ADDR_EXP 101
43640: PUSH
43641: LD_INT 1
43643: ST_TO_ADDR
// if p3 = 8 then
43644: LD_VAR 0 3
43648: PUSH
43649: LD_INT 8
43651: EQUAL
43652: IFFALSE 43662
// sBunker := true ;
43654: LD_ADDR_EXP 102
43658: PUSH
43659: LD_INT 1
43661: ST_TO_ADDR
// if p3 = 9 then
43662: LD_VAR 0 3
43666: PUSH
43667: LD_INT 9
43669: EQUAL
43670: IFFALSE 43680
// sHack := true ;
43672: LD_ADDR_EXP 103
43676: PUSH
43677: LD_INT 1
43679: ST_TO_ADDR
// if p3 = 10 then
43680: LD_VAR 0 3
43684: PUSH
43685: LD_INT 10
43687: EQUAL
43688: IFFALSE 43698
// sFire := true ;
43690: LD_ADDR_EXP 104
43694: PUSH
43695: LD_INT 1
43697: ST_TO_ADDR
// if p3 = 11 then
43698: LD_VAR 0 3
43702: PUSH
43703: LD_INT 11
43705: EQUAL
43706: IFFALSE 43716
// sRefresh := true ;
43708: LD_ADDR_EXP 105
43712: PUSH
43713: LD_INT 1
43715: ST_TO_ADDR
// if p3 = 12 then
43716: LD_VAR 0 3
43720: PUSH
43721: LD_INT 12
43723: EQUAL
43724: IFFALSE 43734
// sExp := true ;
43726: LD_ADDR_EXP 106
43730: PUSH
43731: LD_INT 1
43733: ST_TO_ADDR
// if p3 = 13 then
43734: LD_VAR 0 3
43738: PUSH
43739: LD_INT 13
43741: EQUAL
43742: IFFALSE 43752
// sDepot := true ;
43744: LD_ADDR_EXP 107
43748: PUSH
43749: LD_INT 1
43751: ST_TO_ADDR
// if p3 = 14 then
43752: LD_VAR 0 3
43756: PUSH
43757: LD_INT 14
43759: EQUAL
43760: IFFALSE 43770
// sFlag := true ;
43762: LD_ADDR_EXP 108
43766: PUSH
43767: LD_INT 1
43769: ST_TO_ADDR
// if p3 = 15 then
43770: LD_VAR 0 3
43774: PUSH
43775: LD_INT 15
43777: EQUAL
43778: IFFALSE 43788
// sKamikadze := true ;
43780: LD_ADDR_EXP 116
43784: PUSH
43785: LD_INT 1
43787: ST_TO_ADDR
// if p3 = 16 then
43788: LD_VAR 0 3
43792: PUSH
43793: LD_INT 16
43795: EQUAL
43796: IFFALSE 43806
// sTroll := true ;
43798: LD_ADDR_EXP 117
43802: PUSH
43803: LD_INT 1
43805: ST_TO_ADDR
// if p3 = 17 then
43806: LD_VAR 0 3
43810: PUSH
43811: LD_INT 17
43813: EQUAL
43814: IFFALSE 43824
// sSlow := true ;
43816: LD_ADDR_EXP 118
43820: PUSH
43821: LD_INT 1
43823: ST_TO_ADDR
// if p3 = 18 then
43824: LD_VAR 0 3
43828: PUSH
43829: LD_INT 18
43831: EQUAL
43832: IFFALSE 43842
// sLack := true ;
43834: LD_ADDR_EXP 119
43838: PUSH
43839: LD_INT 1
43841: ST_TO_ADDR
// if p3 = 19 then
43842: LD_VAR 0 3
43846: PUSH
43847: LD_INT 19
43849: EQUAL
43850: IFFALSE 43860
// sTank := true ;
43852: LD_ADDR_EXP 121
43856: PUSH
43857: LD_INT 1
43859: ST_TO_ADDR
// if p3 = 20 then
43860: LD_VAR 0 3
43864: PUSH
43865: LD_INT 20
43867: EQUAL
43868: IFFALSE 43878
// sRemote := true ;
43870: LD_ADDR_EXP 122
43874: PUSH
43875: LD_INT 1
43877: ST_TO_ADDR
// if p3 = 21 then
43878: LD_VAR 0 3
43882: PUSH
43883: LD_INT 21
43885: EQUAL
43886: IFFALSE 43896
// sPowell := true ;
43888: LD_ADDR_EXP 123
43892: PUSH
43893: LD_INT 1
43895: ST_TO_ADDR
// if p3 = 22 then
43896: LD_VAR 0 3
43900: PUSH
43901: LD_INT 22
43903: EQUAL
43904: IFFALSE 43914
// sTeleport := true ;
43906: LD_ADDR_EXP 126
43910: PUSH
43911: LD_INT 1
43913: ST_TO_ADDR
// if p3 = 23 then
43914: LD_VAR 0 3
43918: PUSH
43919: LD_INT 23
43921: EQUAL
43922: IFFALSE 43932
// sOilTower := true ;
43924: LD_ADDR_EXP 128
43928: PUSH
43929: LD_INT 1
43931: ST_TO_ADDR
// if p3 = 24 then
43932: LD_VAR 0 3
43936: PUSH
43937: LD_INT 24
43939: EQUAL
43940: IFFALSE 43950
// sShovel := true ;
43942: LD_ADDR_EXP 129
43946: PUSH
43947: LD_INT 1
43949: ST_TO_ADDR
// if p3 = 25 then
43950: LD_VAR 0 3
43954: PUSH
43955: LD_INT 25
43957: EQUAL
43958: IFFALSE 43968
// sSheik := true ;
43960: LD_ADDR_EXP 130
43964: PUSH
43965: LD_INT 1
43967: ST_TO_ADDR
// if p3 = 26 then
43968: LD_VAR 0 3
43972: PUSH
43973: LD_INT 26
43975: EQUAL
43976: IFFALSE 43986
// sEarthquake := true ;
43978: LD_ADDR_EXP 132
43982: PUSH
43983: LD_INT 1
43985: ST_TO_ADDR
// if p3 = 27 then
43986: LD_VAR 0 3
43990: PUSH
43991: LD_INT 27
43993: EQUAL
43994: IFFALSE 44004
// sAI := true ;
43996: LD_ADDR_EXP 133
44000: PUSH
44001: LD_INT 1
44003: ST_TO_ADDR
// if p3 = 28 then
44004: LD_VAR 0 3
44008: PUSH
44009: LD_INT 28
44011: EQUAL
44012: IFFALSE 44022
// sCargo := true ;
44014: LD_ADDR_EXP 136
44018: PUSH
44019: LD_INT 1
44021: ST_TO_ADDR
// if p3 = 29 then
44022: LD_VAR 0 3
44026: PUSH
44027: LD_INT 29
44029: EQUAL
44030: IFFALSE 44040
// sDLaser := true ;
44032: LD_ADDR_EXP 137
44036: PUSH
44037: LD_INT 1
44039: ST_TO_ADDR
// if p3 = 30 then
44040: LD_VAR 0 3
44044: PUSH
44045: LD_INT 30
44047: EQUAL
44048: IFFALSE 44058
// sExchange := true ;
44050: LD_ADDR_EXP 138
44054: PUSH
44055: LD_INT 1
44057: ST_TO_ADDR
// if p3 = 31 then
44058: LD_VAR 0 3
44062: PUSH
44063: LD_INT 31
44065: EQUAL
44066: IFFALSE 44076
// sFac := true ;
44068: LD_ADDR_EXP 139
44072: PUSH
44073: LD_INT 1
44075: ST_TO_ADDR
// if p3 = 32 then
44076: LD_VAR 0 3
44080: PUSH
44081: LD_INT 32
44083: EQUAL
44084: IFFALSE 44094
// sPower := true ;
44086: LD_ADDR_EXP 140
44090: PUSH
44091: LD_INT 1
44093: ST_TO_ADDR
// if p3 = 33 then
44094: LD_VAR 0 3
44098: PUSH
44099: LD_INT 33
44101: EQUAL
44102: IFFALSE 44112
// sRandom := true ;
44104: LD_ADDR_EXP 141
44108: PUSH
44109: LD_INT 1
44111: ST_TO_ADDR
// if p3 = 34 then
44112: LD_VAR 0 3
44116: PUSH
44117: LD_INT 34
44119: EQUAL
44120: IFFALSE 44130
// sShield := true ;
44122: LD_ADDR_EXP 142
44126: PUSH
44127: LD_INT 1
44129: ST_TO_ADDR
// if p3 = 35 then
44130: LD_VAR 0 3
44134: PUSH
44135: LD_INT 35
44137: EQUAL
44138: IFFALSE 44148
// sTime := true ;
44140: LD_ADDR_EXP 143
44144: PUSH
44145: LD_INT 1
44147: ST_TO_ADDR
// if p3 = 36 then
44148: LD_VAR 0 3
44152: PUSH
44153: LD_INT 36
44155: EQUAL
44156: IFFALSE 44166
// sTools := true ;
44158: LD_ADDR_EXP 144
44162: PUSH
44163: LD_INT 1
44165: ST_TO_ADDR
// if p3 = 101 then
44166: LD_VAR 0 3
44170: PUSH
44171: LD_INT 101
44173: EQUAL
44174: IFFALSE 44184
// sSold := true ;
44176: LD_ADDR_EXP 109
44180: PUSH
44181: LD_INT 1
44183: ST_TO_ADDR
// if p3 = 102 then
44184: LD_VAR 0 3
44188: PUSH
44189: LD_INT 102
44191: EQUAL
44192: IFFALSE 44202
// sDiff := true ;
44194: LD_ADDR_EXP 110
44198: PUSH
44199: LD_INT 1
44201: ST_TO_ADDR
// if p3 = 103 then
44202: LD_VAR 0 3
44206: PUSH
44207: LD_INT 103
44209: EQUAL
44210: IFFALSE 44220
// sFog := true ;
44212: LD_ADDR_EXP 113
44216: PUSH
44217: LD_INT 1
44219: ST_TO_ADDR
// if p3 = 104 then
44220: LD_VAR 0 3
44224: PUSH
44225: LD_INT 104
44227: EQUAL
44228: IFFALSE 44238
// sReset := true ;
44230: LD_ADDR_EXP 114
44234: PUSH
44235: LD_INT 1
44237: ST_TO_ADDR
// if p3 = 105 then
44238: LD_VAR 0 3
44242: PUSH
44243: LD_INT 105
44245: EQUAL
44246: IFFALSE 44256
// sSun := true ;
44248: LD_ADDR_EXP 115
44252: PUSH
44253: LD_INT 1
44255: ST_TO_ADDR
// if p3 = 106 then
44256: LD_VAR 0 3
44260: PUSH
44261: LD_INT 106
44263: EQUAL
44264: IFFALSE 44274
// sTiger := true ;
44266: LD_ADDR_EXP 111
44270: PUSH
44271: LD_INT 1
44273: ST_TO_ADDR
// if p3 = 107 then
44274: LD_VAR 0 3
44278: PUSH
44279: LD_INT 107
44281: EQUAL
44282: IFFALSE 44292
// sBomb := true ;
44284: LD_ADDR_EXP 112
44288: PUSH
44289: LD_INT 1
44291: ST_TO_ADDR
// if p3 = 108 then
44292: LD_VAR 0 3
44296: PUSH
44297: LD_INT 108
44299: EQUAL
44300: IFFALSE 44310
// sWound := true ;
44302: LD_ADDR_EXP 120
44306: PUSH
44307: LD_INT 1
44309: ST_TO_ADDR
// if p3 = 109 then
44310: LD_VAR 0 3
44314: PUSH
44315: LD_INT 109
44317: EQUAL
44318: IFFALSE 44328
// sBetray := true ;
44320: LD_ADDR_EXP 124
44324: PUSH
44325: LD_INT 1
44327: ST_TO_ADDR
// if p3 = 110 then
44328: LD_VAR 0 3
44332: PUSH
44333: LD_INT 110
44335: EQUAL
44336: IFFALSE 44346
// sContamin := true ;
44338: LD_ADDR_EXP 125
44342: PUSH
44343: LD_INT 1
44345: ST_TO_ADDR
// if p3 = 111 then
44346: LD_VAR 0 3
44350: PUSH
44351: LD_INT 111
44353: EQUAL
44354: IFFALSE 44364
// sOil := true ;
44356: LD_ADDR_EXP 127
44360: PUSH
44361: LD_INT 1
44363: ST_TO_ADDR
// if p3 = 112 then
44364: LD_VAR 0 3
44368: PUSH
44369: LD_INT 112
44371: EQUAL
44372: IFFALSE 44382
// sStu := true ;
44374: LD_ADDR_EXP 131
44378: PUSH
44379: LD_INT 1
44381: ST_TO_ADDR
// if p3 = 113 then
44382: LD_VAR 0 3
44386: PUSH
44387: LD_INT 113
44389: EQUAL
44390: IFFALSE 44400
// sBazooka := true ;
44392: LD_ADDR_EXP 134
44396: PUSH
44397: LD_INT 1
44399: ST_TO_ADDR
// if p3 = 114 then
44400: LD_VAR 0 3
44404: PUSH
44405: LD_INT 114
44407: EQUAL
44408: IFFALSE 44418
// sMortar := true ;
44410: LD_ADDR_EXP 135
44414: PUSH
44415: LD_INT 1
44417: ST_TO_ADDR
// if p3 = 115 then
44418: LD_VAR 0 3
44422: PUSH
44423: LD_INT 115
44425: EQUAL
44426: IFFALSE 44436
// sRanger := true ;
44428: LD_ADDR_EXP 145
44432: PUSH
44433: LD_INT 1
44435: ST_TO_ADDR
// if p3 = 116 then
44436: LD_VAR 0 3
44440: PUSH
44441: LD_INT 116
44443: EQUAL
44444: IFFALSE 44454
// sComputer := true ;
44446: LD_ADDR_EXP 146
44450: PUSH
44451: LD_INT 1
44453: ST_TO_ADDR
// if p3 = 117 then
44454: LD_VAR 0 3
44458: PUSH
44459: LD_INT 117
44461: EQUAL
44462: IFFALSE 44472
// s30 := true ;
44464: LD_ADDR_EXP 147
44468: PUSH
44469: LD_INT 1
44471: ST_TO_ADDR
// if p3 = 118 then
44472: LD_VAR 0 3
44476: PUSH
44477: LD_INT 118
44479: EQUAL
44480: IFFALSE 44490
// s60 := true ;
44482: LD_ADDR_EXP 148
44486: PUSH
44487: LD_INT 1
44489: ST_TO_ADDR
// end ; if p2 = 101 then
44490: LD_VAR 0 2
44494: PUSH
44495: LD_INT 101
44497: EQUAL
44498: IFFALSE 44626
// begin case p3 of 1 :
44500: LD_VAR 0 3
44504: PUSH
44505: LD_INT 1
44507: DOUBLE
44508: EQUAL
44509: IFTRUE 44513
44511: GO 44520
44513: POP
// hHackUnlimitedResources ; 2 :
44514: CALL 56724 0 0
44518: GO 44626
44520: LD_INT 2
44522: DOUBLE
44523: EQUAL
44524: IFTRUE 44528
44526: GO 44535
44528: POP
// hHackSetLevel10 ; 3 :
44529: CALL 56857 0 0
44533: GO 44626
44535: LD_INT 3
44537: DOUBLE
44538: EQUAL
44539: IFTRUE 44543
44541: GO 44550
44543: POP
// hHackSetLevel10YourUnits ; 4 :
44544: CALL 56942 0 0
44548: GO 44626
44550: LD_INT 4
44552: DOUBLE
44553: EQUAL
44554: IFTRUE 44558
44556: GO 44565
44558: POP
// hHackInvincible ; 5 :
44559: CALL 57390 0 0
44563: GO 44626
44565: LD_INT 5
44567: DOUBLE
44568: EQUAL
44569: IFTRUE 44573
44571: GO 44580
44573: POP
// hHackInvisible ; 6 :
44574: CALL 57501 0 0
44578: GO 44626
44580: LD_INT 6
44582: DOUBLE
44583: EQUAL
44584: IFTRUE 44588
44586: GO 44595
44588: POP
// hHackChangeYourSide ; 7 :
44589: CALL 57558 0 0
44593: GO 44626
44595: LD_INT 7
44597: DOUBLE
44598: EQUAL
44599: IFTRUE 44603
44601: GO 44610
44603: POP
// hHackChangeUnitSide ; 8 :
44604: CALL 57600 0 0
44608: GO 44626
44610: LD_INT 8
44612: DOUBLE
44613: EQUAL
44614: IFTRUE 44618
44616: GO 44625
44618: POP
// hHackFog ; end ;
44619: CALL 57701 0 0
44623: GO 44626
44625: POP
// end ; end ;
44626: LD_VAR 0 7
44630: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44631: GO 44633
44633: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44634: LD_STRING initStreamRollete();
44636: PPUSH
44637: CALL_OW 559
// InitStreamMode ;
44641: CALL 44653 0 0
// DefineStreamItems ( false ) ;
44645: LD_INT 0
44647: PPUSH
44648: CALL 45117 0 1
// end ;
44652: END
// function InitStreamMode ; begin
44653: LD_INT 0
44655: PPUSH
// streamModeActive := false ;
44656: LD_ADDR_EXP 92
44660: PUSH
44661: LD_INT 0
44663: ST_TO_ADDR
// normalCounter := 36 ;
44664: LD_ADDR_EXP 93
44668: PUSH
44669: LD_INT 36
44671: ST_TO_ADDR
// hardcoreCounter := 18 ;
44672: LD_ADDR_EXP 94
44676: PUSH
44677: LD_INT 18
44679: ST_TO_ADDR
// sRocket := false ;
44680: LD_ADDR_EXP 97
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sSpeed := false ;
44688: LD_ADDR_EXP 96
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sEngine := false ;
44696: LD_ADDR_EXP 98
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sSpec := false ;
44704: LD_ADDR_EXP 95
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sLevel := false ;
44712: LD_ADDR_EXP 99
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sArmoury := false ;
44720: LD_ADDR_EXP 100
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sRadar := false ;
44728: LD_ADDR_EXP 101
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sBunker := false ;
44736: LD_ADDR_EXP 102
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sHack := false ;
44744: LD_ADDR_EXP 103
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sFire := false ;
44752: LD_ADDR_EXP 104
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sRefresh := false ;
44760: LD_ADDR_EXP 105
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sExp := false ;
44768: LD_ADDR_EXP 106
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sDepot := false ;
44776: LD_ADDR_EXP 107
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sFlag := false ;
44784: LD_ADDR_EXP 108
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sKamikadze := false ;
44792: LD_ADDR_EXP 116
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sTroll := false ;
44800: LD_ADDR_EXP 117
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sSlow := false ;
44808: LD_ADDR_EXP 118
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sLack := false ;
44816: LD_ADDR_EXP 119
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sTank := false ;
44824: LD_ADDR_EXP 121
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sRemote := false ;
44832: LD_ADDR_EXP 122
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sPowell := false ;
44840: LD_ADDR_EXP 123
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sTeleport := false ;
44848: LD_ADDR_EXP 126
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sOilTower := false ;
44856: LD_ADDR_EXP 128
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sShovel := false ;
44864: LD_ADDR_EXP 129
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sSheik := false ;
44872: LD_ADDR_EXP 130
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// sEarthquake := false ;
44880: LD_ADDR_EXP 132
44884: PUSH
44885: LD_INT 0
44887: ST_TO_ADDR
// sAI := false ;
44888: LD_ADDR_EXP 133
44892: PUSH
44893: LD_INT 0
44895: ST_TO_ADDR
// sCargo := false ;
44896: LD_ADDR_EXP 136
44900: PUSH
44901: LD_INT 0
44903: ST_TO_ADDR
// sDLaser := false ;
44904: LD_ADDR_EXP 137
44908: PUSH
44909: LD_INT 0
44911: ST_TO_ADDR
// sExchange := false ;
44912: LD_ADDR_EXP 138
44916: PUSH
44917: LD_INT 0
44919: ST_TO_ADDR
// sFac := false ;
44920: LD_ADDR_EXP 139
44924: PUSH
44925: LD_INT 0
44927: ST_TO_ADDR
// sPower := false ;
44928: LD_ADDR_EXP 140
44932: PUSH
44933: LD_INT 0
44935: ST_TO_ADDR
// sRandom := false ;
44936: LD_ADDR_EXP 141
44940: PUSH
44941: LD_INT 0
44943: ST_TO_ADDR
// sShield := false ;
44944: LD_ADDR_EXP 142
44948: PUSH
44949: LD_INT 0
44951: ST_TO_ADDR
// sTime := false ;
44952: LD_ADDR_EXP 143
44956: PUSH
44957: LD_INT 0
44959: ST_TO_ADDR
// sTools := false ;
44960: LD_ADDR_EXP 144
44964: PUSH
44965: LD_INT 0
44967: ST_TO_ADDR
// sSold := false ;
44968: LD_ADDR_EXP 109
44972: PUSH
44973: LD_INT 0
44975: ST_TO_ADDR
// sDiff := false ;
44976: LD_ADDR_EXP 110
44980: PUSH
44981: LD_INT 0
44983: ST_TO_ADDR
// sFog := false ;
44984: LD_ADDR_EXP 113
44988: PUSH
44989: LD_INT 0
44991: ST_TO_ADDR
// sReset := false ;
44992: LD_ADDR_EXP 114
44996: PUSH
44997: LD_INT 0
44999: ST_TO_ADDR
// sSun := false ;
45000: LD_ADDR_EXP 115
45004: PUSH
45005: LD_INT 0
45007: ST_TO_ADDR
// sTiger := false ;
45008: LD_ADDR_EXP 111
45012: PUSH
45013: LD_INT 0
45015: ST_TO_ADDR
// sBomb := false ;
45016: LD_ADDR_EXP 112
45020: PUSH
45021: LD_INT 0
45023: ST_TO_ADDR
// sWound := false ;
45024: LD_ADDR_EXP 120
45028: PUSH
45029: LD_INT 0
45031: ST_TO_ADDR
// sBetray := false ;
45032: LD_ADDR_EXP 124
45036: PUSH
45037: LD_INT 0
45039: ST_TO_ADDR
// sContamin := false ;
45040: LD_ADDR_EXP 125
45044: PUSH
45045: LD_INT 0
45047: ST_TO_ADDR
// sOil := false ;
45048: LD_ADDR_EXP 127
45052: PUSH
45053: LD_INT 0
45055: ST_TO_ADDR
// sStu := false ;
45056: LD_ADDR_EXP 131
45060: PUSH
45061: LD_INT 0
45063: ST_TO_ADDR
// sBazooka := false ;
45064: LD_ADDR_EXP 134
45068: PUSH
45069: LD_INT 0
45071: ST_TO_ADDR
// sMortar := false ;
45072: LD_ADDR_EXP 135
45076: PUSH
45077: LD_INT 0
45079: ST_TO_ADDR
// sRanger := false ;
45080: LD_ADDR_EXP 145
45084: PUSH
45085: LD_INT 0
45087: ST_TO_ADDR
// sComputer := false ;
45088: LD_ADDR_EXP 146
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// s30 := false ;
45096: LD_ADDR_EXP 147
45100: PUSH
45101: LD_INT 0
45103: ST_TO_ADDR
// s60 := false ;
45104: LD_ADDR_EXP 148
45108: PUSH
45109: LD_INT 0
45111: ST_TO_ADDR
// end ;
45112: LD_VAR 0 1
45116: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45117: LD_INT 0
45119: PPUSH
45120: PPUSH
45121: PPUSH
45122: PPUSH
45123: PPUSH
45124: PPUSH
45125: PPUSH
// result := [ ] ;
45126: LD_ADDR_VAR 0 2
45130: PUSH
45131: EMPTY
45132: ST_TO_ADDR
// if campaign_id = 1 then
45133: LD_OWVAR 69
45137: PUSH
45138: LD_INT 1
45140: EQUAL
45141: IFFALSE 48307
// begin case mission_number of 1 :
45143: LD_OWVAR 70
45147: PUSH
45148: LD_INT 1
45150: DOUBLE
45151: EQUAL
45152: IFTRUE 45156
45154: GO 45232
45156: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45157: LD_ADDR_VAR 0 2
45161: PUSH
45162: LD_INT 2
45164: PUSH
45165: LD_INT 4
45167: PUSH
45168: LD_INT 11
45170: PUSH
45171: LD_INT 12
45173: PUSH
45174: LD_INT 15
45176: PUSH
45177: LD_INT 16
45179: PUSH
45180: LD_INT 22
45182: PUSH
45183: LD_INT 23
45185: PUSH
45186: LD_INT 26
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 101
45202: PUSH
45203: LD_INT 102
45205: PUSH
45206: LD_INT 106
45208: PUSH
45209: LD_INT 116
45211: PUSH
45212: LD_INT 117
45214: PUSH
45215: LD_INT 118
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: ST_TO_ADDR
45230: GO 48305
45232: LD_INT 2
45234: DOUBLE
45235: EQUAL
45236: IFTRUE 45240
45238: GO 45324
45240: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45241: LD_ADDR_VAR 0 2
45245: PUSH
45246: LD_INT 2
45248: PUSH
45249: LD_INT 4
45251: PUSH
45252: LD_INT 11
45254: PUSH
45255: LD_INT 12
45257: PUSH
45258: LD_INT 15
45260: PUSH
45261: LD_INT 16
45263: PUSH
45264: LD_INT 22
45266: PUSH
45267: LD_INT 23
45269: PUSH
45270: LD_INT 26
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: PUSH
45284: LD_INT 101
45286: PUSH
45287: LD_INT 102
45289: PUSH
45290: LD_INT 105
45292: PUSH
45293: LD_INT 106
45295: PUSH
45296: LD_INT 108
45298: PUSH
45299: LD_INT 116
45301: PUSH
45302: LD_INT 117
45304: PUSH
45305: LD_INT 118
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: ST_TO_ADDR
45322: GO 48305
45324: LD_INT 3
45326: DOUBLE
45327: EQUAL
45328: IFTRUE 45332
45330: GO 45420
45332: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45333: LD_ADDR_VAR 0 2
45337: PUSH
45338: LD_INT 2
45340: PUSH
45341: LD_INT 4
45343: PUSH
45344: LD_INT 5
45346: PUSH
45347: LD_INT 11
45349: PUSH
45350: LD_INT 12
45352: PUSH
45353: LD_INT 15
45355: PUSH
45356: LD_INT 16
45358: PUSH
45359: LD_INT 22
45361: PUSH
45362: LD_INT 26
45364: PUSH
45365: LD_INT 36
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: PUSH
45380: LD_INT 101
45382: PUSH
45383: LD_INT 102
45385: PUSH
45386: LD_INT 105
45388: PUSH
45389: LD_INT 106
45391: PUSH
45392: LD_INT 108
45394: PUSH
45395: LD_INT 116
45397: PUSH
45398: LD_INT 117
45400: PUSH
45401: LD_INT 118
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: ST_TO_ADDR
45418: GO 48305
45420: LD_INT 4
45422: DOUBLE
45423: EQUAL
45424: IFTRUE 45428
45426: GO 45524
45428: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45429: LD_ADDR_VAR 0 2
45433: PUSH
45434: LD_INT 2
45436: PUSH
45437: LD_INT 4
45439: PUSH
45440: LD_INT 5
45442: PUSH
45443: LD_INT 8
45445: PUSH
45446: LD_INT 11
45448: PUSH
45449: LD_INT 12
45451: PUSH
45452: LD_INT 15
45454: PUSH
45455: LD_INT 16
45457: PUSH
45458: LD_INT 22
45460: PUSH
45461: LD_INT 23
45463: PUSH
45464: LD_INT 26
45466: PUSH
45467: LD_INT 36
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 101
45486: PUSH
45487: LD_INT 102
45489: PUSH
45490: LD_INT 105
45492: PUSH
45493: LD_INT 106
45495: PUSH
45496: LD_INT 108
45498: PUSH
45499: LD_INT 116
45501: PUSH
45502: LD_INT 117
45504: PUSH
45505: LD_INT 118
45507: PUSH
45508: EMPTY
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: LIST
45515: LIST
45516: LIST
45517: PUSH
45518: EMPTY
45519: LIST
45520: LIST
45521: ST_TO_ADDR
45522: GO 48305
45524: LD_INT 5
45526: DOUBLE
45527: EQUAL
45528: IFTRUE 45532
45530: GO 45644
45532: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45533: LD_ADDR_VAR 0 2
45537: PUSH
45538: LD_INT 2
45540: PUSH
45541: LD_INT 4
45543: PUSH
45544: LD_INT 5
45546: PUSH
45547: LD_INT 6
45549: PUSH
45550: LD_INT 8
45552: PUSH
45553: LD_INT 11
45555: PUSH
45556: LD_INT 12
45558: PUSH
45559: LD_INT 15
45561: PUSH
45562: LD_INT 16
45564: PUSH
45565: LD_INT 22
45567: PUSH
45568: LD_INT 23
45570: PUSH
45571: LD_INT 25
45573: PUSH
45574: LD_INT 26
45576: PUSH
45577: LD_INT 36
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 101
45598: PUSH
45599: LD_INT 102
45601: PUSH
45602: LD_INT 105
45604: PUSH
45605: LD_INT 106
45607: PUSH
45608: LD_INT 108
45610: PUSH
45611: LD_INT 109
45613: PUSH
45614: LD_INT 112
45616: PUSH
45617: LD_INT 116
45619: PUSH
45620: LD_INT 117
45622: PUSH
45623: LD_INT 118
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: ST_TO_ADDR
45642: GO 48305
45644: LD_INT 6
45646: DOUBLE
45647: EQUAL
45648: IFTRUE 45652
45650: GO 45784
45652: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45653: LD_ADDR_VAR 0 2
45657: PUSH
45658: LD_INT 2
45660: PUSH
45661: LD_INT 4
45663: PUSH
45664: LD_INT 5
45666: PUSH
45667: LD_INT 6
45669: PUSH
45670: LD_INT 8
45672: PUSH
45673: LD_INT 11
45675: PUSH
45676: LD_INT 12
45678: PUSH
45679: LD_INT 15
45681: PUSH
45682: LD_INT 16
45684: PUSH
45685: LD_INT 20
45687: PUSH
45688: LD_INT 21
45690: PUSH
45691: LD_INT 22
45693: PUSH
45694: LD_INT 23
45696: PUSH
45697: LD_INT 25
45699: PUSH
45700: LD_INT 26
45702: PUSH
45703: LD_INT 30
45705: PUSH
45706: LD_INT 31
45708: PUSH
45709: LD_INT 32
45711: PUSH
45712: LD_INT 36
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 101
45738: PUSH
45739: LD_INT 102
45741: PUSH
45742: LD_INT 105
45744: PUSH
45745: LD_INT 106
45747: PUSH
45748: LD_INT 108
45750: PUSH
45751: LD_INT 109
45753: PUSH
45754: LD_INT 112
45756: PUSH
45757: LD_INT 116
45759: PUSH
45760: LD_INT 117
45762: PUSH
45763: LD_INT 118
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: LIST
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: ST_TO_ADDR
45782: GO 48305
45784: LD_INT 7
45786: DOUBLE
45787: EQUAL
45788: IFTRUE 45792
45790: GO 45904
45792: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45793: LD_ADDR_VAR 0 2
45797: PUSH
45798: LD_INT 2
45800: PUSH
45801: LD_INT 4
45803: PUSH
45804: LD_INT 5
45806: PUSH
45807: LD_INT 7
45809: PUSH
45810: LD_INT 11
45812: PUSH
45813: LD_INT 12
45815: PUSH
45816: LD_INT 15
45818: PUSH
45819: LD_INT 16
45821: PUSH
45822: LD_INT 20
45824: PUSH
45825: LD_INT 21
45827: PUSH
45828: LD_INT 22
45830: PUSH
45831: LD_INT 23
45833: PUSH
45834: LD_INT 25
45836: PUSH
45837: LD_INT 26
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 101
45858: PUSH
45859: LD_INT 102
45861: PUSH
45862: LD_INT 103
45864: PUSH
45865: LD_INT 105
45867: PUSH
45868: LD_INT 106
45870: PUSH
45871: LD_INT 108
45873: PUSH
45874: LD_INT 112
45876: PUSH
45877: LD_INT 116
45879: PUSH
45880: LD_INT 117
45882: PUSH
45883: LD_INT 118
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: ST_TO_ADDR
45902: GO 48305
45904: LD_INT 8
45906: DOUBLE
45907: EQUAL
45908: IFTRUE 45912
45910: GO 46052
45912: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45913: LD_ADDR_VAR 0 2
45917: PUSH
45918: LD_INT 2
45920: PUSH
45921: LD_INT 4
45923: PUSH
45924: LD_INT 5
45926: PUSH
45927: LD_INT 6
45929: PUSH
45930: LD_INT 7
45932: PUSH
45933: LD_INT 8
45935: PUSH
45936: LD_INT 11
45938: PUSH
45939: LD_INT 12
45941: PUSH
45942: LD_INT 15
45944: PUSH
45945: LD_INT 16
45947: PUSH
45948: LD_INT 20
45950: PUSH
45951: LD_INT 21
45953: PUSH
45954: LD_INT 22
45956: PUSH
45957: LD_INT 23
45959: PUSH
45960: LD_INT 25
45962: PUSH
45963: LD_INT 26
45965: PUSH
45966: LD_INT 30
45968: PUSH
45969: LD_INT 31
45971: PUSH
45972: LD_INT 32
45974: PUSH
45975: LD_INT 36
45977: PUSH
45978: EMPTY
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 101
46002: PUSH
46003: LD_INT 102
46005: PUSH
46006: LD_INT 103
46008: PUSH
46009: LD_INT 105
46011: PUSH
46012: LD_INT 106
46014: PUSH
46015: LD_INT 108
46017: PUSH
46018: LD_INT 109
46020: PUSH
46021: LD_INT 112
46023: PUSH
46024: LD_INT 116
46026: PUSH
46027: LD_INT 117
46029: PUSH
46030: LD_INT 118
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: ST_TO_ADDR
46050: GO 48305
46052: LD_INT 9
46054: DOUBLE
46055: EQUAL
46056: IFTRUE 46060
46058: GO 46208
46060: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46061: LD_ADDR_VAR 0 2
46065: PUSH
46066: LD_INT 2
46068: PUSH
46069: LD_INT 4
46071: PUSH
46072: LD_INT 5
46074: PUSH
46075: LD_INT 6
46077: PUSH
46078: LD_INT 7
46080: PUSH
46081: LD_INT 8
46083: PUSH
46084: LD_INT 11
46086: PUSH
46087: LD_INT 12
46089: PUSH
46090: LD_INT 15
46092: PUSH
46093: LD_INT 16
46095: PUSH
46096: LD_INT 20
46098: PUSH
46099: LD_INT 21
46101: PUSH
46102: LD_INT 22
46104: PUSH
46105: LD_INT 23
46107: PUSH
46108: LD_INT 25
46110: PUSH
46111: LD_INT 26
46113: PUSH
46114: LD_INT 28
46116: PUSH
46117: LD_INT 30
46119: PUSH
46120: LD_INT 31
46122: PUSH
46123: LD_INT 32
46125: PUSH
46126: LD_INT 36
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 101
46154: PUSH
46155: LD_INT 102
46157: PUSH
46158: LD_INT 103
46160: PUSH
46161: LD_INT 105
46163: PUSH
46164: LD_INT 106
46166: PUSH
46167: LD_INT 108
46169: PUSH
46170: LD_INT 109
46172: PUSH
46173: LD_INT 112
46175: PUSH
46176: LD_INT 114
46178: PUSH
46179: LD_INT 116
46181: PUSH
46182: LD_INT 117
46184: PUSH
46185: LD_INT 118
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: ST_TO_ADDR
46206: GO 48305
46208: LD_INT 10
46210: DOUBLE
46211: EQUAL
46212: IFTRUE 46216
46214: GO 46412
46216: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46217: LD_ADDR_VAR 0 2
46221: PUSH
46222: LD_INT 2
46224: PUSH
46225: LD_INT 4
46227: PUSH
46228: LD_INT 5
46230: PUSH
46231: LD_INT 6
46233: PUSH
46234: LD_INT 7
46236: PUSH
46237: LD_INT 8
46239: PUSH
46240: LD_INT 9
46242: PUSH
46243: LD_INT 10
46245: PUSH
46246: LD_INT 11
46248: PUSH
46249: LD_INT 12
46251: PUSH
46252: LD_INT 13
46254: PUSH
46255: LD_INT 14
46257: PUSH
46258: LD_INT 15
46260: PUSH
46261: LD_INT 16
46263: PUSH
46264: LD_INT 17
46266: PUSH
46267: LD_INT 18
46269: PUSH
46270: LD_INT 19
46272: PUSH
46273: LD_INT 20
46275: PUSH
46276: LD_INT 21
46278: PUSH
46279: LD_INT 22
46281: PUSH
46282: LD_INT 23
46284: PUSH
46285: LD_INT 24
46287: PUSH
46288: LD_INT 25
46290: PUSH
46291: LD_INT 26
46293: PUSH
46294: LD_INT 28
46296: PUSH
46297: LD_INT 30
46299: PUSH
46300: LD_INT 31
46302: PUSH
46303: LD_INT 32
46305: PUSH
46306: LD_INT 36
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 101
46342: PUSH
46343: LD_INT 102
46345: PUSH
46346: LD_INT 103
46348: PUSH
46349: LD_INT 104
46351: PUSH
46352: LD_INT 105
46354: PUSH
46355: LD_INT 106
46357: PUSH
46358: LD_INT 107
46360: PUSH
46361: LD_INT 108
46363: PUSH
46364: LD_INT 109
46366: PUSH
46367: LD_INT 110
46369: PUSH
46370: LD_INT 111
46372: PUSH
46373: LD_INT 112
46375: PUSH
46376: LD_INT 114
46378: PUSH
46379: LD_INT 116
46381: PUSH
46382: LD_INT 117
46384: PUSH
46385: LD_INT 118
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: ST_TO_ADDR
46410: GO 48305
46412: LD_INT 11
46414: DOUBLE
46415: EQUAL
46416: IFTRUE 46420
46418: GO 46624
46420: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46421: LD_ADDR_VAR 0 2
46425: PUSH
46426: LD_INT 2
46428: PUSH
46429: LD_INT 3
46431: PUSH
46432: LD_INT 4
46434: PUSH
46435: LD_INT 5
46437: PUSH
46438: LD_INT 6
46440: PUSH
46441: LD_INT 7
46443: PUSH
46444: LD_INT 8
46446: PUSH
46447: LD_INT 9
46449: PUSH
46450: LD_INT 10
46452: PUSH
46453: LD_INT 11
46455: PUSH
46456: LD_INT 12
46458: PUSH
46459: LD_INT 13
46461: PUSH
46462: LD_INT 14
46464: PUSH
46465: LD_INT 15
46467: PUSH
46468: LD_INT 16
46470: PUSH
46471: LD_INT 17
46473: PUSH
46474: LD_INT 18
46476: PUSH
46477: LD_INT 19
46479: PUSH
46480: LD_INT 20
46482: PUSH
46483: LD_INT 21
46485: PUSH
46486: LD_INT 22
46488: PUSH
46489: LD_INT 23
46491: PUSH
46492: LD_INT 24
46494: PUSH
46495: LD_INT 25
46497: PUSH
46498: LD_INT 26
46500: PUSH
46501: LD_INT 28
46503: PUSH
46504: LD_INT 30
46506: PUSH
46507: LD_INT 31
46509: PUSH
46510: LD_INT 32
46512: PUSH
46513: LD_INT 34
46515: PUSH
46516: LD_INT 36
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 101
46554: PUSH
46555: LD_INT 102
46557: PUSH
46558: LD_INT 103
46560: PUSH
46561: LD_INT 104
46563: PUSH
46564: LD_INT 105
46566: PUSH
46567: LD_INT 106
46569: PUSH
46570: LD_INT 107
46572: PUSH
46573: LD_INT 108
46575: PUSH
46576: LD_INT 109
46578: PUSH
46579: LD_INT 110
46581: PUSH
46582: LD_INT 111
46584: PUSH
46585: LD_INT 112
46587: PUSH
46588: LD_INT 114
46590: PUSH
46591: LD_INT 116
46593: PUSH
46594: LD_INT 117
46596: PUSH
46597: LD_INT 118
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: ST_TO_ADDR
46622: GO 48305
46624: LD_INT 12
46626: DOUBLE
46627: EQUAL
46628: IFTRUE 46632
46630: GO 46852
46632: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46633: LD_ADDR_VAR 0 2
46637: PUSH
46638: LD_INT 1
46640: PUSH
46641: LD_INT 2
46643: PUSH
46644: LD_INT 3
46646: PUSH
46647: LD_INT 4
46649: PUSH
46650: LD_INT 5
46652: PUSH
46653: LD_INT 6
46655: PUSH
46656: LD_INT 7
46658: PUSH
46659: LD_INT 8
46661: PUSH
46662: LD_INT 9
46664: PUSH
46665: LD_INT 10
46667: PUSH
46668: LD_INT 11
46670: PUSH
46671: LD_INT 12
46673: PUSH
46674: LD_INT 13
46676: PUSH
46677: LD_INT 14
46679: PUSH
46680: LD_INT 15
46682: PUSH
46683: LD_INT 16
46685: PUSH
46686: LD_INT 17
46688: PUSH
46689: LD_INT 18
46691: PUSH
46692: LD_INT 19
46694: PUSH
46695: LD_INT 20
46697: PUSH
46698: LD_INT 21
46700: PUSH
46701: LD_INT 22
46703: PUSH
46704: LD_INT 23
46706: PUSH
46707: LD_INT 24
46709: PUSH
46710: LD_INT 25
46712: PUSH
46713: LD_INT 26
46715: PUSH
46716: LD_INT 27
46718: PUSH
46719: LD_INT 28
46721: PUSH
46722: LD_INT 30
46724: PUSH
46725: LD_INT 31
46727: PUSH
46728: LD_INT 32
46730: PUSH
46731: LD_INT 33
46733: PUSH
46734: LD_INT 34
46736: PUSH
46737: LD_INT 36
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 101
46778: PUSH
46779: LD_INT 102
46781: PUSH
46782: LD_INT 103
46784: PUSH
46785: LD_INT 104
46787: PUSH
46788: LD_INT 105
46790: PUSH
46791: LD_INT 106
46793: PUSH
46794: LD_INT 107
46796: PUSH
46797: LD_INT 108
46799: PUSH
46800: LD_INT 109
46802: PUSH
46803: LD_INT 110
46805: PUSH
46806: LD_INT 111
46808: PUSH
46809: LD_INT 112
46811: PUSH
46812: LD_INT 113
46814: PUSH
46815: LD_INT 114
46817: PUSH
46818: LD_INT 116
46820: PUSH
46821: LD_INT 117
46823: PUSH
46824: LD_INT 118
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: ST_TO_ADDR
46850: GO 48305
46852: LD_INT 13
46854: DOUBLE
46855: EQUAL
46856: IFTRUE 46860
46858: GO 47068
46860: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46861: LD_ADDR_VAR 0 2
46865: PUSH
46866: LD_INT 1
46868: PUSH
46869: LD_INT 2
46871: PUSH
46872: LD_INT 3
46874: PUSH
46875: LD_INT 4
46877: PUSH
46878: LD_INT 5
46880: PUSH
46881: LD_INT 8
46883: PUSH
46884: LD_INT 9
46886: PUSH
46887: LD_INT 10
46889: PUSH
46890: LD_INT 11
46892: PUSH
46893: LD_INT 12
46895: PUSH
46896: LD_INT 14
46898: PUSH
46899: LD_INT 15
46901: PUSH
46902: LD_INT 16
46904: PUSH
46905: LD_INT 17
46907: PUSH
46908: LD_INT 18
46910: PUSH
46911: LD_INT 19
46913: PUSH
46914: LD_INT 20
46916: PUSH
46917: LD_INT 21
46919: PUSH
46920: LD_INT 22
46922: PUSH
46923: LD_INT 23
46925: PUSH
46926: LD_INT 24
46928: PUSH
46929: LD_INT 25
46931: PUSH
46932: LD_INT 26
46934: PUSH
46935: LD_INT 27
46937: PUSH
46938: LD_INT 28
46940: PUSH
46941: LD_INT 30
46943: PUSH
46944: LD_INT 31
46946: PUSH
46947: LD_INT 32
46949: PUSH
46950: LD_INT 33
46952: PUSH
46953: LD_INT 34
46955: PUSH
46956: LD_INT 36
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 101
46994: PUSH
46995: LD_INT 102
46997: PUSH
46998: LD_INT 103
47000: PUSH
47001: LD_INT 104
47003: PUSH
47004: LD_INT 105
47006: PUSH
47007: LD_INT 106
47009: PUSH
47010: LD_INT 107
47012: PUSH
47013: LD_INT 108
47015: PUSH
47016: LD_INT 109
47018: PUSH
47019: LD_INT 110
47021: PUSH
47022: LD_INT 111
47024: PUSH
47025: LD_INT 112
47027: PUSH
47028: LD_INT 113
47030: PUSH
47031: LD_INT 114
47033: PUSH
47034: LD_INT 116
47036: PUSH
47037: LD_INT 117
47039: PUSH
47040: LD_INT 118
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: ST_TO_ADDR
47066: GO 48305
47068: LD_INT 14
47070: DOUBLE
47071: EQUAL
47072: IFTRUE 47076
47074: GO 47300
47076: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47077: LD_ADDR_VAR 0 2
47081: PUSH
47082: LD_INT 1
47084: PUSH
47085: LD_INT 2
47087: PUSH
47088: LD_INT 3
47090: PUSH
47091: LD_INT 4
47093: PUSH
47094: LD_INT 5
47096: PUSH
47097: LD_INT 6
47099: PUSH
47100: LD_INT 7
47102: PUSH
47103: LD_INT 8
47105: PUSH
47106: LD_INT 9
47108: PUSH
47109: LD_INT 10
47111: PUSH
47112: LD_INT 11
47114: PUSH
47115: LD_INT 12
47117: PUSH
47118: LD_INT 13
47120: PUSH
47121: LD_INT 14
47123: PUSH
47124: LD_INT 15
47126: PUSH
47127: LD_INT 16
47129: PUSH
47130: LD_INT 17
47132: PUSH
47133: LD_INT 18
47135: PUSH
47136: LD_INT 19
47138: PUSH
47139: LD_INT 20
47141: PUSH
47142: LD_INT 21
47144: PUSH
47145: LD_INT 22
47147: PUSH
47148: LD_INT 23
47150: PUSH
47151: LD_INT 24
47153: PUSH
47154: LD_INT 25
47156: PUSH
47157: LD_INT 26
47159: PUSH
47160: LD_INT 27
47162: PUSH
47163: LD_INT 28
47165: PUSH
47166: LD_INT 29
47168: PUSH
47169: LD_INT 30
47171: PUSH
47172: LD_INT 31
47174: PUSH
47175: LD_INT 32
47177: PUSH
47178: LD_INT 33
47180: PUSH
47181: LD_INT 34
47183: PUSH
47184: LD_INT 36
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 101
47226: PUSH
47227: LD_INT 102
47229: PUSH
47230: LD_INT 103
47232: PUSH
47233: LD_INT 104
47235: PUSH
47236: LD_INT 105
47238: PUSH
47239: LD_INT 106
47241: PUSH
47242: LD_INT 107
47244: PUSH
47245: LD_INT 108
47247: PUSH
47248: LD_INT 109
47250: PUSH
47251: LD_INT 110
47253: PUSH
47254: LD_INT 111
47256: PUSH
47257: LD_INT 112
47259: PUSH
47260: LD_INT 113
47262: PUSH
47263: LD_INT 114
47265: PUSH
47266: LD_INT 116
47268: PUSH
47269: LD_INT 117
47271: PUSH
47272: LD_INT 118
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: ST_TO_ADDR
47298: GO 48305
47300: LD_INT 15
47302: DOUBLE
47303: EQUAL
47304: IFTRUE 47308
47306: GO 47532
47308: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47309: LD_ADDR_VAR 0 2
47313: PUSH
47314: LD_INT 1
47316: PUSH
47317: LD_INT 2
47319: PUSH
47320: LD_INT 3
47322: PUSH
47323: LD_INT 4
47325: PUSH
47326: LD_INT 5
47328: PUSH
47329: LD_INT 6
47331: PUSH
47332: LD_INT 7
47334: PUSH
47335: LD_INT 8
47337: PUSH
47338: LD_INT 9
47340: PUSH
47341: LD_INT 10
47343: PUSH
47344: LD_INT 11
47346: PUSH
47347: LD_INT 12
47349: PUSH
47350: LD_INT 13
47352: PUSH
47353: LD_INT 14
47355: PUSH
47356: LD_INT 15
47358: PUSH
47359: LD_INT 16
47361: PUSH
47362: LD_INT 17
47364: PUSH
47365: LD_INT 18
47367: PUSH
47368: LD_INT 19
47370: PUSH
47371: LD_INT 20
47373: PUSH
47374: LD_INT 21
47376: PUSH
47377: LD_INT 22
47379: PUSH
47380: LD_INT 23
47382: PUSH
47383: LD_INT 24
47385: PUSH
47386: LD_INT 25
47388: PUSH
47389: LD_INT 26
47391: PUSH
47392: LD_INT 27
47394: PUSH
47395: LD_INT 28
47397: PUSH
47398: LD_INT 29
47400: PUSH
47401: LD_INT 30
47403: PUSH
47404: LD_INT 31
47406: PUSH
47407: LD_INT 32
47409: PUSH
47410: LD_INT 33
47412: PUSH
47413: LD_INT 34
47415: PUSH
47416: LD_INT 36
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 101
47458: PUSH
47459: LD_INT 102
47461: PUSH
47462: LD_INT 103
47464: PUSH
47465: LD_INT 104
47467: PUSH
47468: LD_INT 105
47470: PUSH
47471: LD_INT 106
47473: PUSH
47474: LD_INT 107
47476: PUSH
47477: LD_INT 108
47479: PUSH
47480: LD_INT 109
47482: PUSH
47483: LD_INT 110
47485: PUSH
47486: LD_INT 111
47488: PUSH
47489: LD_INT 112
47491: PUSH
47492: LD_INT 113
47494: PUSH
47495: LD_INT 114
47497: PUSH
47498: LD_INT 116
47500: PUSH
47501: LD_INT 117
47503: PUSH
47504: LD_INT 118
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: LIST
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: ST_TO_ADDR
47530: GO 48305
47532: LD_INT 16
47534: DOUBLE
47535: EQUAL
47536: IFTRUE 47540
47538: GO 47676
47540: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47541: LD_ADDR_VAR 0 2
47545: PUSH
47546: LD_INT 2
47548: PUSH
47549: LD_INT 4
47551: PUSH
47552: LD_INT 5
47554: PUSH
47555: LD_INT 7
47557: PUSH
47558: LD_INT 11
47560: PUSH
47561: LD_INT 12
47563: PUSH
47564: LD_INT 15
47566: PUSH
47567: LD_INT 16
47569: PUSH
47570: LD_INT 20
47572: PUSH
47573: LD_INT 21
47575: PUSH
47576: LD_INT 22
47578: PUSH
47579: LD_INT 23
47581: PUSH
47582: LD_INT 25
47584: PUSH
47585: LD_INT 26
47587: PUSH
47588: LD_INT 30
47590: PUSH
47591: LD_INT 31
47593: PUSH
47594: LD_INT 32
47596: PUSH
47597: LD_INT 33
47599: PUSH
47600: LD_INT 34
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 101
47626: PUSH
47627: LD_INT 102
47629: PUSH
47630: LD_INT 103
47632: PUSH
47633: LD_INT 106
47635: PUSH
47636: LD_INT 108
47638: PUSH
47639: LD_INT 112
47641: PUSH
47642: LD_INT 113
47644: PUSH
47645: LD_INT 114
47647: PUSH
47648: LD_INT 116
47650: PUSH
47651: LD_INT 117
47653: PUSH
47654: LD_INT 118
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: ST_TO_ADDR
47674: GO 48305
47676: LD_INT 17
47678: DOUBLE
47679: EQUAL
47680: IFTRUE 47684
47682: GO 47908
47684: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47685: LD_ADDR_VAR 0 2
47689: PUSH
47690: LD_INT 1
47692: PUSH
47693: LD_INT 2
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: LD_INT 4
47701: PUSH
47702: LD_INT 5
47704: PUSH
47705: LD_INT 6
47707: PUSH
47708: LD_INT 7
47710: PUSH
47711: LD_INT 8
47713: PUSH
47714: LD_INT 9
47716: PUSH
47717: LD_INT 10
47719: PUSH
47720: LD_INT 11
47722: PUSH
47723: LD_INT 12
47725: PUSH
47726: LD_INT 13
47728: PUSH
47729: LD_INT 14
47731: PUSH
47732: LD_INT 15
47734: PUSH
47735: LD_INT 16
47737: PUSH
47738: LD_INT 17
47740: PUSH
47741: LD_INT 18
47743: PUSH
47744: LD_INT 19
47746: PUSH
47747: LD_INT 20
47749: PUSH
47750: LD_INT 21
47752: PUSH
47753: LD_INT 22
47755: PUSH
47756: LD_INT 23
47758: PUSH
47759: LD_INT 24
47761: PUSH
47762: LD_INT 25
47764: PUSH
47765: LD_INT 26
47767: PUSH
47768: LD_INT 27
47770: PUSH
47771: LD_INT 28
47773: PUSH
47774: LD_INT 29
47776: PUSH
47777: LD_INT 30
47779: PUSH
47780: LD_INT 31
47782: PUSH
47783: LD_INT 32
47785: PUSH
47786: LD_INT 33
47788: PUSH
47789: LD_INT 34
47791: PUSH
47792: LD_INT 36
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: PUSH
47832: LD_INT 101
47834: PUSH
47835: LD_INT 102
47837: PUSH
47838: LD_INT 103
47840: PUSH
47841: LD_INT 104
47843: PUSH
47844: LD_INT 105
47846: PUSH
47847: LD_INT 106
47849: PUSH
47850: LD_INT 107
47852: PUSH
47853: LD_INT 108
47855: PUSH
47856: LD_INT 109
47858: PUSH
47859: LD_INT 110
47861: PUSH
47862: LD_INT 111
47864: PUSH
47865: LD_INT 112
47867: PUSH
47868: LD_INT 113
47870: PUSH
47871: LD_INT 114
47873: PUSH
47874: LD_INT 116
47876: PUSH
47877: LD_INT 117
47879: PUSH
47880: LD_INT 118
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: ST_TO_ADDR
47906: GO 48305
47908: LD_INT 18
47910: DOUBLE
47911: EQUAL
47912: IFTRUE 47916
47914: GO 48064
47916: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47917: LD_ADDR_VAR 0 2
47921: PUSH
47922: LD_INT 2
47924: PUSH
47925: LD_INT 4
47927: PUSH
47928: LD_INT 5
47930: PUSH
47931: LD_INT 7
47933: PUSH
47934: LD_INT 11
47936: PUSH
47937: LD_INT 12
47939: PUSH
47940: LD_INT 15
47942: PUSH
47943: LD_INT 16
47945: PUSH
47946: LD_INT 20
47948: PUSH
47949: LD_INT 21
47951: PUSH
47952: LD_INT 22
47954: PUSH
47955: LD_INT 23
47957: PUSH
47958: LD_INT 25
47960: PUSH
47961: LD_INT 26
47963: PUSH
47964: LD_INT 30
47966: PUSH
47967: LD_INT 31
47969: PUSH
47970: LD_INT 32
47972: PUSH
47973: LD_INT 33
47975: PUSH
47976: LD_INT 34
47978: PUSH
47979: LD_INT 35
47981: PUSH
47982: LD_INT 36
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 101
48010: PUSH
48011: LD_INT 102
48013: PUSH
48014: LD_INT 103
48016: PUSH
48017: LD_INT 106
48019: PUSH
48020: LD_INT 108
48022: PUSH
48023: LD_INT 112
48025: PUSH
48026: LD_INT 113
48028: PUSH
48029: LD_INT 114
48031: PUSH
48032: LD_INT 115
48034: PUSH
48035: LD_INT 116
48037: PUSH
48038: LD_INT 117
48040: PUSH
48041: LD_INT 118
48043: PUSH
48044: EMPTY
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: ST_TO_ADDR
48062: GO 48305
48064: LD_INT 19
48066: DOUBLE
48067: EQUAL
48068: IFTRUE 48072
48070: GO 48304
48072: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48073: LD_ADDR_VAR 0 2
48077: PUSH
48078: LD_INT 1
48080: PUSH
48081: LD_INT 2
48083: PUSH
48084: LD_INT 3
48086: PUSH
48087: LD_INT 4
48089: PUSH
48090: LD_INT 5
48092: PUSH
48093: LD_INT 6
48095: PUSH
48096: LD_INT 7
48098: PUSH
48099: LD_INT 8
48101: PUSH
48102: LD_INT 9
48104: PUSH
48105: LD_INT 10
48107: PUSH
48108: LD_INT 11
48110: PUSH
48111: LD_INT 12
48113: PUSH
48114: LD_INT 13
48116: PUSH
48117: LD_INT 14
48119: PUSH
48120: LD_INT 15
48122: PUSH
48123: LD_INT 16
48125: PUSH
48126: LD_INT 17
48128: PUSH
48129: LD_INT 18
48131: PUSH
48132: LD_INT 19
48134: PUSH
48135: LD_INT 20
48137: PUSH
48138: LD_INT 21
48140: PUSH
48141: LD_INT 22
48143: PUSH
48144: LD_INT 23
48146: PUSH
48147: LD_INT 24
48149: PUSH
48150: LD_INT 25
48152: PUSH
48153: LD_INT 26
48155: PUSH
48156: LD_INT 27
48158: PUSH
48159: LD_INT 28
48161: PUSH
48162: LD_INT 29
48164: PUSH
48165: LD_INT 30
48167: PUSH
48168: LD_INT 31
48170: PUSH
48171: LD_INT 32
48173: PUSH
48174: LD_INT 33
48176: PUSH
48177: LD_INT 34
48179: PUSH
48180: LD_INT 35
48182: PUSH
48183: LD_INT 36
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: PUSH
48224: LD_INT 101
48226: PUSH
48227: LD_INT 102
48229: PUSH
48230: LD_INT 103
48232: PUSH
48233: LD_INT 104
48235: PUSH
48236: LD_INT 105
48238: PUSH
48239: LD_INT 106
48241: PUSH
48242: LD_INT 107
48244: PUSH
48245: LD_INT 108
48247: PUSH
48248: LD_INT 109
48250: PUSH
48251: LD_INT 110
48253: PUSH
48254: LD_INT 111
48256: PUSH
48257: LD_INT 112
48259: PUSH
48260: LD_INT 113
48262: PUSH
48263: LD_INT 114
48265: PUSH
48266: LD_INT 115
48268: PUSH
48269: LD_INT 116
48271: PUSH
48272: LD_INT 117
48274: PUSH
48275: LD_INT 118
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: PUSH
48298: EMPTY
48299: LIST
48300: LIST
48301: ST_TO_ADDR
48302: GO 48305
48304: POP
// end else
48305: GO 48536
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48307: LD_ADDR_VAR 0 2
48311: PUSH
48312: LD_INT 1
48314: PUSH
48315: LD_INT 2
48317: PUSH
48318: LD_INT 3
48320: PUSH
48321: LD_INT 4
48323: PUSH
48324: LD_INT 5
48326: PUSH
48327: LD_INT 6
48329: PUSH
48330: LD_INT 7
48332: PUSH
48333: LD_INT 8
48335: PUSH
48336: LD_INT 9
48338: PUSH
48339: LD_INT 10
48341: PUSH
48342: LD_INT 11
48344: PUSH
48345: LD_INT 12
48347: PUSH
48348: LD_INT 13
48350: PUSH
48351: LD_INT 14
48353: PUSH
48354: LD_INT 15
48356: PUSH
48357: LD_INT 16
48359: PUSH
48360: LD_INT 17
48362: PUSH
48363: LD_INT 18
48365: PUSH
48366: LD_INT 19
48368: PUSH
48369: LD_INT 20
48371: PUSH
48372: LD_INT 21
48374: PUSH
48375: LD_INT 22
48377: PUSH
48378: LD_INT 23
48380: PUSH
48381: LD_INT 24
48383: PUSH
48384: LD_INT 25
48386: PUSH
48387: LD_INT 26
48389: PUSH
48390: LD_INT 27
48392: PUSH
48393: LD_INT 28
48395: PUSH
48396: LD_INT 29
48398: PUSH
48399: LD_INT 30
48401: PUSH
48402: LD_INT 31
48404: PUSH
48405: LD_INT 32
48407: PUSH
48408: LD_INT 33
48410: PUSH
48411: LD_INT 34
48413: PUSH
48414: LD_INT 35
48416: PUSH
48417: LD_INT 36
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: PUSH
48458: LD_INT 101
48460: PUSH
48461: LD_INT 102
48463: PUSH
48464: LD_INT 103
48466: PUSH
48467: LD_INT 104
48469: PUSH
48470: LD_INT 105
48472: PUSH
48473: LD_INT 106
48475: PUSH
48476: LD_INT 107
48478: PUSH
48479: LD_INT 108
48481: PUSH
48482: LD_INT 109
48484: PUSH
48485: LD_INT 110
48487: PUSH
48488: LD_INT 111
48490: PUSH
48491: LD_INT 112
48493: PUSH
48494: LD_INT 113
48496: PUSH
48497: LD_INT 114
48499: PUSH
48500: LD_INT 115
48502: PUSH
48503: LD_INT 116
48505: PUSH
48506: LD_INT 117
48508: PUSH
48509: LD_INT 118
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: LIST
48516: LIST
48517: LIST
48518: LIST
48519: LIST
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: LIST
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: ST_TO_ADDR
// if result then
48536: LD_VAR 0 2
48540: IFFALSE 49326
// begin normal :=  ;
48542: LD_ADDR_VAR 0 5
48546: PUSH
48547: LD_STRING 
48549: ST_TO_ADDR
// hardcore :=  ;
48550: LD_ADDR_VAR 0 6
48554: PUSH
48555: LD_STRING 
48557: ST_TO_ADDR
// active :=  ;
48558: LD_ADDR_VAR 0 7
48562: PUSH
48563: LD_STRING 
48565: ST_TO_ADDR
// for i = 1 to normalCounter do
48566: LD_ADDR_VAR 0 8
48570: PUSH
48571: DOUBLE
48572: LD_INT 1
48574: DEC
48575: ST_TO_ADDR
48576: LD_EXP 93
48580: PUSH
48581: FOR_TO
48582: IFFALSE 48683
// begin tmp := 0 ;
48584: LD_ADDR_VAR 0 3
48588: PUSH
48589: LD_STRING 0
48591: ST_TO_ADDR
// if result [ 1 ] then
48592: LD_VAR 0 2
48596: PUSH
48597: LD_INT 1
48599: ARRAY
48600: IFFALSE 48665
// if result [ 1 ] [ 1 ] = i then
48602: LD_VAR 0 2
48606: PUSH
48607: LD_INT 1
48609: ARRAY
48610: PUSH
48611: LD_INT 1
48613: ARRAY
48614: PUSH
48615: LD_VAR 0 8
48619: EQUAL
48620: IFFALSE 48665
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48622: LD_ADDR_VAR 0 2
48626: PUSH
48627: LD_VAR 0 2
48631: PPUSH
48632: LD_INT 1
48634: PPUSH
48635: LD_VAR 0 2
48639: PUSH
48640: LD_INT 1
48642: ARRAY
48643: PPUSH
48644: LD_INT 1
48646: PPUSH
48647: CALL_OW 3
48651: PPUSH
48652: CALL_OW 1
48656: ST_TO_ADDR
// tmp := 1 ;
48657: LD_ADDR_VAR 0 3
48661: PUSH
48662: LD_STRING 1
48664: ST_TO_ADDR
// end ; normal := normal & tmp ;
48665: LD_ADDR_VAR 0 5
48669: PUSH
48670: LD_VAR 0 5
48674: PUSH
48675: LD_VAR 0 3
48679: STR
48680: ST_TO_ADDR
// end ;
48681: GO 48581
48683: POP
48684: POP
// for i = 1 to hardcoreCounter do
48685: LD_ADDR_VAR 0 8
48689: PUSH
48690: DOUBLE
48691: LD_INT 1
48693: DEC
48694: ST_TO_ADDR
48695: LD_EXP 94
48699: PUSH
48700: FOR_TO
48701: IFFALSE 48806
// begin tmp := 0 ;
48703: LD_ADDR_VAR 0 3
48707: PUSH
48708: LD_STRING 0
48710: ST_TO_ADDR
// if result [ 2 ] then
48711: LD_VAR 0 2
48715: PUSH
48716: LD_INT 2
48718: ARRAY
48719: IFFALSE 48788
// if result [ 2 ] [ 1 ] = 100 + i then
48721: LD_VAR 0 2
48725: PUSH
48726: LD_INT 2
48728: ARRAY
48729: PUSH
48730: LD_INT 1
48732: ARRAY
48733: PUSH
48734: LD_INT 100
48736: PUSH
48737: LD_VAR 0 8
48741: PLUS
48742: EQUAL
48743: IFFALSE 48788
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48745: LD_ADDR_VAR 0 2
48749: PUSH
48750: LD_VAR 0 2
48754: PPUSH
48755: LD_INT 2
48757: PPUSH
48758: LD_VAR 0 2
48762: PUSH
48763: LD_INT 2
48765: ARRAY
48766: PPUSH
48767: LD_INT 1
48769: PPUSH
48770: CALL_OW 3
48774: PPUSH
48775: CALL_OW 1
48779: ST_TO_ADDR
// tmp := 1 ;
48780: LD_ADDR_VAR 0 3
48784: PUSH
48785: LD_STRING 1
48787: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48788: LD_ADDR_VAR 0 6
48792: PUSH
48793: LD_VAR 0 6
48797: PUSH
48798: LD_VAR 0 3
48802: STR
48803: ST_TO_ADDR
// end ;
48804: GO 48700
48806: POP
48807: POP
// if isGameLoad then
48808: LD_VAR 0 1
48812: IFFALSE 49287
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48814: LD_ADDR_VAR 0 4
48818: PUSH
48819: LD_EXP 97
48823: PUSH
48824: LD_EXP 96
48828: PUSH
48829: LD_EXP 98
48833: PUSH
48834: LD_EXP 95
48838: PUSH
48839: LD_EXP 99
48843: PUSH
48844: LD_EXP 100
48848: PUSH
48849: LD_EXP 101
48853: PUSH
48854: LD_EXP 102
48858: PUSH
48859: LD_EXP 103
48863: PUSH
48864: LD_EXP 104
48868: PUSH
48869: LD_EXP 105
48873: PUSH
48874: LD_EXP 106
48878: PUSH
48879: LD_EXP 107
48883: PUSH
48884: LD_EXP 108
48888: PUSH
48889: LD_EXP 116
48893: PUSH
48894: LD_EXP 117
48898: PUSH
48899: LD_EXP 118
48903: PUSH
48904: LD_EXP 119
48908: PUSH
48909: LD_EXP 121
48913: PUSH
48914: LD_EXP 122
48918: PUSH
48919: LD_EXP 123
48923: PUSH
48924: LD_EXP 126
48928: PUSH
48929: LD_EXP 128
48933: PUSH
48934: LD_EXP 129
48938: PUSH
48939: LD_EXP 130
48943: PUSH
48944: LD_EXP 132
48948: PUSH
48949: LD_EXP 133
48953: PUSH
48954: LD_EXP 136
48958: PUSH
48959: LD_EXP 137
48963: PUSH
48964: LD_EXP 138
48968: PUSH
48969: LD_EXP 139
48973: PUSH
48974: LD_EXP 140
48978: PUSH
48979: LD_EXP 141
48983: PUSH
48984: LD_EXP 142
48988: PUSH
48989: LD_EXP 143
48993: PUSH
48994: LD_EXP 144
48998: PUSH
48999: LD_EXP 109
49003: PUSH
49004: LD_EXP 110
49008: PUSH
49009: LD_EXP 113
49013: PUSH
49014: LD_EXP 114
49018: PUSH
49019: LD_EXP 115
49023: PUSH
49024: LD_EXP 111
49028: PUSH
49029: LD_EXP 112
49033: PUSH
49034: LD_EXP 120
49038: PUSH
49039: LD_EXP 124
49043: PUSH
49044: LD_EXP 125
49048: PUSH
49049: LD_EXP 127
49053: PUSH
49054: LD_EXP 131
49058: PUSH
49059: LD_EXP 134
49063: PUSH
49064: LD_EXP 135
49068: PUSH
49069: LD_EXP 145
49073: PUSH
49074: LD_EXP 146
49078: PUSH
49079: LD_EXP 147
49083: PUSH
49084: LD_EXP 148
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: ST_TO_ADDR
// tmp :=  ;
49145: LD_ADDR_VAR 0 3
49149: PUSH
49150: LD_STRING 
49152: ST_TO_ADDR
// for i = 1 to normalCounter do
49153: LD_ADDR_VAR 0 8
49157: PUSH
49158: DOUBLE
49159: LD_INT 1
49161: DEC
49162: ST_TO_ADDR
49163: LD_EXP 93
49167: PUSH
49168: FOR_TO
49169: IFFALSE 49205
// begin if flags [ i ] then
49171: LD_VAR 0 4
49175: PUSH
49176: LD_VAR 0 8
49180: ARRAY
49181: IFFALSE 49203
// tmp := tmp & i & ; ;
49183: LD_ADDR_VAR 0 3
49187: PUSH
49188: LD_VAR 0 3
49192: PUSH
49193: LD_VAR 0 8
49197: STR
49198: PUSH
49199: LD_STRING ;
49201: STR
49202: ST_TO_ADDR
// end ;
49203: GO 49168
49205: POP
49206: POP
// for i = 1 to hardcoreCounter do
49207: LD_ADDR_VAR 0 8
49211: PUSH
49212: DOUBLE
49213: LD_INT 1
49215: DEC
49216: ST_TO_ADDR
49217: LD_EXP 94
49221: PUSH
49222: FOR_TO
49223: IFFALSE 49269
// begin if flags [ normalCounter + i ] then
49225: LD_VAR 0 4
49229: PUSH
49230: LD_EXP 93
49234: PUSH
49235: LD_VAR 0 8
49239: PLUS
49240: ARRAY
49241: IFFALSE 49267
// tmp := tmp & ( 100 + i ) & ; ;
49243: LD_ADDR_VAR 0 3
49247: PUSH
49248: LD_VAR 0 3
49252: PUSH
49253: LD_INT 100
49255: PUSH
49256: LD_VAR 0 8
49260: PLUS
49261: STR
49262: PUSH
49263: LD_STRING ;
49265: STR
49266: ST_TO_ADDR
// end ;
49267: GO 49222
49269: POP
49270: POP
// if tmp then
49271: LD_VAR 0 3
49275: IFFALSE 49287
// active := tmp ;
49277: LD_ADDR_VAR 0 7
49281: PUSH
49282: LD_VAR 0 3
49286: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49287: LD_STRING getStreamItemsFromMission("
49289: PUSH
49290: LD_VAR 0 5
49294: STR
49295: PUSH
49296: LD_STRING ","
49298: STR
49299: PUSH
49300: LD_VAR 0 6
49304: STR
49305: PUSH
49306: LD_STRING ","
49308: STR
49309: PUSH
49310: LD_VAR 0 7
49314: STR
49315: PUSH
49316: LD_STRING ")
49318: STR
49319: PPUSH
49320: CALL_OW 559
// end else
49324: GO 49333
// ToLua ( getStreamItemsFromMission("","","") ) ;
49326: LD_STRING getStreamItemsFromMission("","","")
49328: PPUSH
49329: CALL_OW 559
// end ;
49333: LD_VAR 0 2
49337: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49338: LD_EXP 92
49342: PUSH
49343: LD_EXP 97
49347: AND
49348: IFFALSE 49472
49350: GO 49352
49352: DISABLE
49353: LD_INT 0
49355: PPUSH
49356: PPUSH
// begin enable ;
49357: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49358: LD_ADDR_VAR 0 2
49362: PUSH
49363: LD_INT 22
49365: PUSH
49366: LD_OWVAR 2
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: PUSH
49375: LD_INT 2
49377: PUSH
49378: LD_INT 34
49380: PUSH
49381: LD_INT 7
49383: PUSH
49384: EMPTY
49385: LIST
49386: LIST
49387: PUSH
49388: LD_INT 34
49390: PUSH
49391: LD_INT 45
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: PUSH
49398: LD_INT 34
49400: PUSH
49401: LD_INT 28
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: PUSH
49408: LD_INT 34
49410: PUSH
49411: LD_INT 47
49413: PUSH
49414: EMPTY
49415: LIST
49416: LIST
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: PPUSH
49429: CALL_OW 69
49433: ST_TO_ADDR
// if not tmp then
49434: LD_VAR 0 2
49438: NOT
49439: IFFALSE 49443
// exit ;
49441: GO 49472
// for i in tmp do
49443: LD_ADDR_VAR 0 1
49447: PUSH
49448: LD_VAR 0 2
49452: PUSH
49453: FOR_IN
49454: IFFALSE 49470
// begin SetLives ( i , 0 ) ;
49456: LD_VAR 0 1
49460: PPUSH
49461: LD_INT 0
49463: PPUSH
49464: CALL_OW 234
// end ;
49468: GO 49453
49470: POP
49471: POP
// end ;
49472: PPOPN 2
49474: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49475: LD_EXP 92
49479: PUSH
49480: LD_EXP 98
49484: AND
49485: IFFALSE 49569
49487: GO 49489
49489: DISABLE
49490: LD_INT 0
49492: PPUSH
49493: PPUSH
// begin enable ;
49494: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49495: LD_ADDR_VAR 0 2
49499: PUSH
49500: LD_INT 22
49502: PUSH
49503: LD_OWVAR 2
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 32
49514: PUSH
49515: LD_INT 3
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PPUSH
49526: CALL_OW 69
49530: ST_TO_ADDR
// if not tmp then
49531: LD_VAR 0 2
49535: NOT
49536: IFFALSE 49540
// exit ;
49538: GO 49569
// for i in tmp do
49540: LD_ADDR_VAR 0 1
49544: PUSH
49545: LD_VAR 0 2
49549: PUSH
49550: FOR_IN
49551: IFFALSE 49567
// begin SetLives ( i , 0 ) ;
49553: LD_VAR 0 1
49557: PPUSH
49558: LD_INT 0
49560: PPUSH
49561: CALL_OW 234
// end ;
49565: GO 49550
49567: POP
49568: POP
// end ;
49569: PPOPN 2
49571: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49572: LD_EXP 92
49576: PUSH
49577: LD_EXP 95
49581: AND
49582: IFFALSE 49675
49584: GO 49586
49586: DISABLE
49587: LD_INT 0
49589: PPUSH
// begin enable ;
49590: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49591: LD_ADDR_VAR 0 1
49595: PUSH
49596: LD_INT 22
49598: PUSH
49599: LD_OWVAR 2
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 2
49610: PUSH
49611: LD_INT 25
49613: PUSH
49614: LD_INT 5
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PUSH
49621: LD_INT 25
49623: PUSH
49624: LD_INT 9
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PUSH
49631: LD_INT 25
49633: PUSH
49634: LD_INT 8
49636: PUSH
49637: EMPTY
49638: LIST
49639: LIST
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PPUSH
49651: CALL_OW 69
49655: PUSH
49656: FOR_IN
49657: IFFALSE 49673
// begin SetClass ( i , 1 ) ;
49659: LD_VAR 0 1
49663: PPUSH
49664: LD_INT 1
49666: PPUSH
49667: CALL_OW 336
// end ;
49671: GO 49656
49673: POP
49674: POP
// end ;
49675: PPOPN 1
49677: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49678: LD_EXP 92
49682: PUSH
49683: LD_EXP 96
49687: AND
49688: PUSH
49689: LD_OWVAR 65
49693: PUSH
49694: LD_INT 7
49696: LESS
49697: AND
49698: IFFALSE 49712
49700: GO 49702
49702: DISABLE
// begin enable ;
49703: ENABLE
// game_speed := 7 ;
49704: LD_ADDR_OWVAR 65
49708: PUSH
49709: LD_INT 7
49711: ST_TO_ADDR
// end ;
49712: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49713: LD_EXP 92
49717: PUSH
49718: LD_EXP 99
49722: AND
49723: IFFALSE 49925
49725: GO 49727
49727: DISABLE
49728: LD_INT 0
49730: PPUSH
49731: PPUSH
49732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49733: LD_ADDR_VAR 0 3
49737: PUSH
49738: LD_INT 81
49740: PUSH
49741: LD_OWVAR 2
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: PUSH
49750: LD_INT 21
49752: PUSH
49753: LD_INT 1
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: PPUSH
49764: CALL_OW 69
49768: ST_TO_ADDR
// if not tmp then
49769: LD_VAR 0 3
49773: NOT
49774: IFFALSE 49778
// exit ;
49776: GO 49925
// if tmp > 5 then
49778: LD_VAR 0 3
49782: PUSH
49783: LD_INT 5
49785: GREATER
49786: IFFALSE 49798
// k := 5 else
49788: LD_ADDR_VAR 0 2
49792: PUSH
49793: LD_INT 5
49795: ST_TO_ADDR
49796: GO 49808
// k := tmp ;
49798: LD_ADDR_VAR 0 2
49802: PUSH
49803: LD_VAR 0 3
49807: ST_TO_ADDR
// for i := 1 to k do
49808: LD_ADDR_VAR 0 1
49812: PUSH
49813: DOUBLE
49814: LD_INT 1
49816: DEC
49817: ST_TO_ADDR
49818: LD_VAR 0 2
49822: PUSH
49823: FOR_TO
49824: IFFALSE 49923
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49826: LD_VAR 0 3
49830: PUSH
49831: LD_VAR 0 1
49835: ARRAY
49836: PPUSH
49837: LD_VAR 0 1
49841: PUSH
49842: LD_INT 4
49844: MOD
49845: PUSH
49846: LD_INT 1
49848: PLUS
49849: PPUSH
49850: CALL_OW 259
49854: PUSH
49855: LD_INT 10
49857: LESS
49858: IFFALSE 49921
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49860: LD_VAR 0 3
49864: PUSH
49865: LD_VAR 0 1
49869: ARRAY
49870: PPUSH
49871: LD_VAR 0 1
49875: PUSH
49876: LD_INT 4
49878: MOD
49879: PUSH
49880: LD_INT 1
49882: PLUS
49883: PPUSH
49884: LD_VAR 0 3
49888: PUSH
49889: LD_VAR 0 1
49893: ARRAY
49894: PPUSH
49895: LD_VAR 0 1
49899: PUSH
49900: LD_INT 4
49902: MOD
49903: PUSH
49904: LD_INT 1
49906: PLUS
49907: PPUSH
49908: CALL_OW 259
49912: PUSH
49913: LD_INT 1
49915: PLUS
49916: PPUSH
49917: CALL_OW 237
49921: GO 49823
49923: POP
49924: POP
// end ;
49925: PPOPN 3
49927: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49928: LD_EXP 92
49932: PUSH
49933: LD_EXP 100
49937: AND
49938: IFFALSE 49958
49940: GO 49942
49942: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49943: LD_INT 4
49945: PPUSH
49946: LD_OWVAR 2
49950: PPUSH
49951: LD_INT 0
49953: PPUSH
49954: CALL_OW 324
49958: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49959: LD_EXP 92
49963: PUSH
49964: LD_EXP 129
49968: AND
49969: IFFALSE 49989
49971: GO 49973
49973: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49974: LD_INT 19
49976: PPUSH
49977: LD_OWVAR 2
49981: PPUSH
49982: LD_INT 0
49984: PPUSH
49985: CALL_OW 324
49989: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49990: LD_EXP 92
49994: PUSH
49995: LD_EXP 101
49999: AND
50000: IFFALSE 50102
50002: GO 50004
50004: DISABLE
50005: LD_INT 0
50007: PPUSH
50008: PPUSH
// begin enable ;
50009: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
50010: LD_ADDR_VAR 0 2
50014: PUSH
50015: LD_INT 22
50017: PUSH
50018: LD_OWVAR 2
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PUSH
50027: LD_INT 2
50029: PUSH
50030: LD_INT 34
50032: PUSH
50033: LD_INT 11
50035: PUSH
50036: EMPTY
50037: LIST
50038: LIST
50039: PUSH
50040: LD_INT 34
50042: PUSH
50043: LD_INT 30
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: PUSH
50050: EMPTY
50051: LIST
50052: LIST
50053: LIST
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PPUSH
50059: CALL_OW 69
50063: ST_TO_ADDR
// if not tmp then
50064: LD_VAR 0 2
50068: NOT
50069: IFFALSE 50073
// exit ;
50071: GO 50102
// for i in tmp do
50073: LD_ADDR_VAR 0 1
50077: PUSH
50078: LD_VAR 0 2
50082: PUSH
50083: FOR_IN
50084: IFFALSE 50100
// begin SetLives ( i , 0 ) ;
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_INT 0
50093: PPUSH
50094: CALL_OW 234
// end ;
50098: GO 50083
50100: POP
50101: POP
// end ;
50102: PPOPN 2
50104: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50105: LD_EXP 92
50109: PUSH
50110: LD_EXP 102
50114: AND
50115: IFFALSE 50135
50117: GO 50119
50119: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50120: LD_INT 32
50122: PPUSH
50123: LD_OWVAR 2
50127: PPUSH
50128: LD_INT 0
50130: PPUSH
50131: CALL_OW 324
50135: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50136: LD_EXP 92
50140: PUSH
50141: LD_EXP 103
50145: AND
50146: IFFALSE 50327
50148: GO 50150
50150: DISABLE
50151: LD_INT 0
50153: PPUSH
50154: PPUSH
50155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50156: LD_ADDR_VAR 0 2
50160: PUSH
50161: LD_INT 22
50163: PUSH
50164: LD_OWVAR 2
50168: PUSH
50169: EMPTY
50170: LIST
50171: LIST
50172: PUSH
50173: LD_INT 33
50175: PUSH
50176: LD_INT 3
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: PPUSH
50187: CALL_OW 69
50191: ST_TO_ADDR
// if not tmp then
50192: LD_VAR 0 2
50196: NOT
50197: IFFALSE 50201
// exit ;
50199: GO 50327
// side := 0 ;
50201: LD_ADDR_VAR 0 3
50205: PUSH
50206: LD_INT 0
50208: ST_TO_ADDR
// for i := 1 to 8 do
50209: LD_ADDR_VAR 0 1
50213: PUSH
50214: DOUBLE
50215: LD_INT 1
50217: DEC
50218: ST_TO_ADDR
50219: LD_INT 8
50221: PUSH
50222: FOR_TO
50223: IFFALSE 50271
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50225: LD_OWVAR 2
50229: PUSH
50230: LD_VAR 0 1
50234: NONEQUAL
50235: PUSH
50236: LD_OWVAR 2
50240: PPUSH
50241: LD_VAR 0 1
50245: PPUSH
50246: CALL_OW 81
50250: PUSH
50251: LD_INT 2
50253: EQUAL
50254: AND
50255: IFFALSE 50269
// begin side := i ;
50257: LD_ADDR_VAR 0 3
50261: PUSH
50262: LD_VAR 0 1
50266: ST_TO_ADDR
// break ;
50267: GO 50271
// end ;
50269: GO 50222
50271: POP
50272: POP
// if not side then
50273: LD_VAR 0 3
50277: NOT
50278: IFFALSE 50282
// exit ;
50280: GO 50327
// for i := 1 to tmp do
50282: LD_ADDR_VAR 0 1
50286: PUSH
50287: DOUBLE
50288: LD_INT 1
50290: DEC
50291: ST_TO_ADDR
50292: LD_VAR 0 2
50296: PUSH
50297: FOR_TO
50298: IFFALSE 50325
// if Prob ( 60 ) then
50300: LD_INT 60
50302: PPUSH
50303: CALL_OW 13
50307: IFFALSE 50323
// SetSide ( i , side ) ;
50309: LD_VAR 0 1
50313: PPUSH
50314: LD_VAR 0 3
50318: PPUSH
50319: CALL_OW 235
50323: GO 50297
50325: POP
50326: POP
// end ;
50327: PPOPN 3
50329: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50330: LD_EXP 92
50334: PUSH
50335: LD_EXP 105
50339: AND
50340: IFFALSE 50459
50342: GO 50344
50344: DISABLE
50345: LD_INT 0
50347: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50348: LD_ADDR_VAR 0 1
50352: PUSH
50353: LD_INT 22
50355: PUSH
50356: LD_OWVAR 2
50360: PUSH
50361: EMPTY
50362: LIST
50363: LIST
50364: PUSH
50365: LD_INT 21
50367: PUSH
50368: LD_INT 1
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 3
50377: PUSH
50378: LD_INT 23
50380: PUSH
50381: LD_INT 0
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: PUSH
50392: EMPTY
50393: LIST
50394: LIST
50395: LIST
50396: PPUSH
50397: CALL_OW 69
50401: PUSH
50402: FOR_IN
50403: IFFALSE 50457
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50405: LD_VAR 0 1
50409: PPUSH
50410: CALL_OW 257
50414: PUSH
50415: LD_INT 1
50417: PUSH
50418: LD_INT 2
50420: PUSH
50421: LD_INT 3
50423: PUSH
50424: LD_INT 4
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: IN
50433: IFFALSE 50455
// SetClass ( un , rand ( 1 , 4 ) ) ;
50435: LD_VAR 0 1
50439: PPUSH
50440: LD_INT 1
50442: PPUSH
50443: LD_INT 4
50445: PPUSH
50446: CALL_OW 12
50450: PPUSH
50451: CALL_OW 336
50455: GO 50402
50457: POP
50458: POP
// end ;
50459: PPOPN 1
50461: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50462: LD_EXP 92
50466: PUSH
50467: LD_EXP 104
50471: AND
50472: IFFALSE 50551
50474: GO 50476
50476: DISABLE
50477: LD_INT 0
50479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50480: LD_ADDR_VAR 0 1
50484: PUSH
50485: LD_INT 22
50487: PUSH
50488: LD_OWVAR 2
50492: PUSH
50493: EMPTY
50494: LIST
50495: LIST
50496: PUSH
50497: LD_INT 21
50499: PUSH
50500: LD_INT 3
50502: PUSH
50503: EMPTY
50504: LIST
50505: LIST
50506: PUSH
50507: EMPTY
50508: LIST
50509: LIST
50510: PPUSH
50511: CALL_OW 69
50515: ST_TO_ADDR
// if not tmp then
50516: LD_VAR 0 1
50520: NOT
50521: IFFALSE 50525
// exit ;
50523: GO 50551
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50525: LD_VAR 0 1
50529: PUSH
50530: LD_INT 1
50532: PPUSH
50533: LD_VAR 0 1
50537: PPUSH
50538: CALL_OW 12
50542: ARRAY
50543: PPUSH
50544: LD_INT 100
50546: PPUSH
50547: CALL_OW 234
// end ;
50551: PPOPN 1
50553: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50554: LD_EXP 92
50558: PUSH
50559: LD_EXP 106
50563: AND
50564: IFFALSE 50662
50566: GO 50568
50568: DISABLE
50569: LD_INT 0
50571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50572: LD_ADDR_VAR 0 1
50576: PUSH
50577: LD_INT 22
50579: PUSH
50580: LD_OWVAR 2
50584: PUSH
50585: EMPTY
50586: LIST
50587: LIST
50588: PUSH
50589: LD_INT 21
50591: PUSH
50592: LD_INT 1
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: EMPTY
50600: LIST
50601: LIST
50602: PPUSH
50603: CALL_OW 69
50607: ST_TO_ADDR
// if not tmp then
50608: LD_VAR 0 1
50612: NOT
50613: IFFALSE 50617
// exit ;
50615: GO 50662
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50617: LD_VAR 0 1
50621: PUSH
50622: LD_INT 1
50624: PPUSH
50625: LD_VAR 0 1
50629: PPUSH
50630: CALL_OW 12
50634: ARRAY
50635: PPUSH
50636: LD_INT 1
50638: PPUSH
50639: LD_INT 4
50641: PPUSH
50642: CALL_OW 12
50646: PPUSH
50647: LD_INT 3000
50649: PPUSH
50650: LD_INT 9000
50652: PPUSH
50653: CALL_OW 12
50657: PPUSH
50658: CALL_OW 492
// end ;
50662: PPOPN 1
50664: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50665: LD_EXP 92
50669: PUSH
50670: LD_EXP 107
50674: AND
50675: IFFALSE 50695
50677: GO 50679
50679: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50680: LD_INT 1
50682: PPUSH
50683: LD_OWVAR 2
50687: PPUSH
50688: LD_INT 0
50690: PPUSH
50691: CALL_OW 324
50695: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50696: LD_EXP 92
50700: PUSH
50701: LD_EXP 108
50705: AND
50706: IFFALSE 50789
50708: GO 50710
50710: DISABLE
50711: LD_INT 0
50713: PPUSH
50714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50715: LD_ADDR_VAR 0 2
50719: PUSH
50720: LD_INT 22
50722: PUSH
50723: LD_OWVAR 2
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PUSH
50732: LD_INT 21
50734: PUSH
50735: LD_INT 3
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: PUSH
50742: EMPTY
50743: LIST
50744: LIST
50745: PPUSH
50746: CALL_OW 69
50750: ST_TO_ADDR
// if not tmp then
50751: LD_VAR 0 2
50755: NOT
50756: IFFALSE 50760
// exit ;
50758: GO 50789
// for i in tmp do
50760: LD_ADDR_VAR 0 1
50764: PUSH
50765: LD_VAR 0 2
50769: PUSH
50770: FOR_IN
50771: IFFALSE 50787
// SetBLevel ( i , 10 ) ;
50773: LD_VAR 0 1
50777: PPUSH
50778: LD_INT 10
50780: PPUSH
50781: CALL_OW 241
50785: GO 50770
50787: POP
50788: POP
// end ;
50789: PPOPN 2
50791: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50792: LD_EXP 92
50796: PUSH
50797: LD_EXP 109
50801: AND
50802: IFFALSE 50913
50804: GO 50806
50806: DISABLE
50807: LD_INT 0
50809: PPUSH
50810: PPUSH
50811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50812: LD_ADDR_VAR 0 3
50816: PUSH
50817: LD_INT 22
50819: PUSH
50820: LD_OWVAR 2
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: PUSH
50829: LD_INT 25
50831: PUSH
50832: LD_INT 1
50834: PUSH
50835: EMPTY
50836: LIST
50837: LIST
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PPUSH
50843: CALL_OW 69
50847: ST_TO_ADDR
// if not tmp then
50848: LD_VAR 0 3
50852: NOT
50853: IFFALSE 50857
// exit ;
50855: GO 50913
// un := tmp [ rand ( 1 , tmp ) ] ;
50857: LD_ADDR_VAR 0 2
50861: PUSH
50862: LD_VAR 0 3
50866: PUSH
50867: LD_INT 1
50869: PPUSH
50870: LD_VAR 0 3
50874: PPUSH
50875: CALL_OW 12
50879: ARRAY
50880: ST_TO_ADDR
// if Crawls ( un ) then
50881: LD_VAR 0 2
50885: PPUSH
50886: CALL_OW 318
50890: IFFALSE 50901
// ComWalk ( un ) ;
50892: LD_VAR 0 2
50896: PPUSH
50897: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50901: LD_VAR 0 2
50905: PPUSH
50906: LD_INT 5
50908: PPUSH
50909: CALL_OW 336
// end ;
50913: PPOPN 3
50915: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50916: LD_EXP 92
50920: PUSH
50921: LD_EXP 110
50925: AND
50926: PUSH
50927: LD_OWVAR 67
50931: PUSH
50932: LD_INT 4
50934: LESS
50935: AND
50936: IFFALSE 50955
50938: GO 50940
50940: DISABLE
// begin Difficulty := Difficulty + 1 ;
50941: LD_ADDR_OWVAR 67
50945: PUSH
50946: LD_OWVAR 67
50950: PUSH
50951: LD_INT 1
50953: PLUS
50954: ST_TO_ADDR
// end ;
50955: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50956: LD_EXP 92
50960: PUSH
50961: LD_EXP 111
50965: AND
50966: IFFALSE 51069
50968: GO 50970
50970: DISABLE
50971: LD_INT 0
50973: PPUSH
// begin for i := 1 to 5 do
50974: LD_ADDR_VAR 0 1
50978: PUSH
50979: DOUBLE
50980: LD_INT 1
50982: DEC
50983: ST_TO_ADDR
50984: LD_INT 5
50986: PUSH
50987: FOR_TO
50988: IFFALSE 51067
// begin uc_nation := nation_nature ;
50990: LD_ADDR_OWVAR 21
50994: PUSH
50995: LD_INT 0
50997: ST_TO_ADDR
// uc_side := 0 ;
50998: LD_ADDR_OWVAR 20
51002: PUSH
51003: LD_INT 0
51005: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51006: LD_ADDR_OWVAR 29
51010: PUSH
51011: LD_INT 12
51013: PUSH
51014: LD_INT 12
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: ST_TO_ADDR
// hc_agressivity := 20 ;
51021: LD_ADDR_OWVAR 35
51025: PUSH
51026: LD_INT 20
51028: ST_TO_ADDR
// hc_class := class_tiger ;
51029: LD_ADDR_OWVAR 28
51033: PUSH
51034: LD_INT 14
51036: ST_TO_ADDR
// hc_gallery :=  ;
51037: LD_ADDR_OWVAR 33
51041: PUSH
51042: LD_STRING 
51044: ST_TO_ADDR
// hc_name :=  ;
51045: LD_ADDR_OWVAR 26
51049: PUSH
51050: LD_STRING 
51052: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51053: CALL_OW 44
51057: PPUSH
51058: LD_INT 0
51060: PPUSH
51061: CALL_OW 51
// end ;
51065: GO 50987
51067: POP
51068: POP
// end ;
51069: PPOPN 1
51071: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51072: LD_EXP 92
51076: PUSH
51077: LD_EXP 112
51081: AND
51082: IFFALSE 51091
51084: GO 51086
51086: DISABLE
// StreamSibBomb ;
51087: CALL 51092 0 0
51091: END
// export function StreamSibBomb ; var i , x , y ; begin
51092: LD_INT 0
51094: PPUSH
51095: PPUSH
51096: PPUSH
51097: PPUSH
// result := false ;
51098: LD_ADDR_VAR 0 1
51102: PUSH
51103: LD_INT 0
51105: ST_TO_ADDR
// for i := 1 to 16 do
51106: LD_ADDR_VAR 0 2
51110: PUSH
51111: DOUBLE
51112: LD_INT 1
51114: DEC
51115: ST_TO_ADDR
51116: LD_INT 16
51118: PUSH
51119: FOR_TO
51120: IFFALSE 51319
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51122: LD_ADDR_VAR 0 3
51126: PUSH
51127: LD_INT 10
51129: PUSH
51130: LD_INT 20
51132: PUSH
51133: LD_INT 30
51135: PUSH
51136: LD_INT 40
51138: PUSH
51139: LD_INT 50
51141: PUSH
51142: LD_INT 60
51144: PUSH
51145: LD_INT 70
51147: PUSH
51148: LD_INT 80
51150: PUSH
51151: LD_INT 90
51153: PUSH
51154: LD_INT 100
51156: PUSH
51157: LD_INT 110
51159: PUSH
51160: LD_INT 120
51162: PUSH
51163: LD_INT 130
51165: PUSH
51166: LD_INT 140
51168: PUSH
51169: LD_INT 150
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: PUSH
51189: LD_INT 1
51191: PPUSH
51192: LD_INT 15
51194: PPUSH
51195: CALL_OW 12
51199: ARRAY
51200: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51201: LD_ADDR_VAR 0 4
51205: PUSH
51206: LD_INT 10
51208: PUSH
51209: LD_INT 20
51211: PUSH
51212: LD_INT 30
51214: PUSH
51215: LD_INT 40
51217: PUSH
51218: LD_INT 50
51220: PUSH
51221: LD_INT 60
51223: PUSH
51224: LD_INT 70
51226: PUSH
51227: LD_INT 80
51229: PUSH
51230: LD_INT 90
51232: PUSH
51233: LD_INT 100
51235: PUSH
51236: LD_INT 110
51238: PUSH
51239: LD_INT 120
51241: PUSH
51242: LD_INT 130
51244: PUSH
51245: LD_INT 140
51247: PUSH
51248: LD_INT 150
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 1
51270: PPUSH
51271: LD_INT 15
51273: PPUSH
51274: CALL_OW 12
51278: ARRAY
51279: ST_TO_ADDR
// if ValidHex ( x , y ) then
51280: LD_VAR 0 3
51284: PPUSH
51285: LD_VAR 0 4
51289: PPUSH
51290: CALL_OW 488
51294: IFFALSE 51317
// begin result := [ x , y ] ;
51296: LD_ADDR_VAR 0 1
51300: PUSH
51301: LD_VAR 0 3
51305: PUSH
51306: LD_VAR 0 4
51310: PUSH
51311: EMPTY
51312: LIST
51313: LIST
51314: ST_TO_ADDR
// break ;
51315: GO 51319
// end ; end ;
51317: GO 51119
51319: POP
51320: POP
// if result then
51321: LD_VAR 0 1
51325: IFFALSE 51385
// begin ToLua ( playSibBomb() ) ;
51327: LD_STRING playSibBomb()
51329: PPUSH
51330: CALL_OW 559
// wait ( 0 0$14 ) ;
51334: LD_INT 490
51336: PPUSH
51337: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51341: LD_VAR 0 1
51345: PUSH
51346: LD_INT 1
51348: ARRAY
51349: PPUSH
51350: LD_VAR 0 1
51354: PUSH
51355: LD_INT 2
51357: ARRAY
51358: PPUSH
51359: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51363: LD_VAR 0 1
51367: PUSH
51368: LD_INT 1
51370: ARRAY
51371: PPUSH
51372: LD_VAR 0 1
51376: PUSH
51377: LD_INT 2
51379: ARRAY
51380: PPUSH
51381: CALL_OW 429
// end ; end ;
51385: LD_VAR 0 1
51389: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51390: LD_EXP 92
51394: PUSH
51395: LD_EXP 114
51399: AND
51400: IFFALSE 51412
51402: GO 51404
51404: DISABLE
// YouLost (  ) ;
51405: LD_STRING 
51407: PPUSH
51408: CALL_OW 104
51412: END
// every 0 0$1 trigger StreamModeActive and sFog do
51413: LD_EXP 92
51417: PUSH
51418: LD_EXP 113
51422: AND
51423: IFFALSE 51437
51425: GO 51427
51427: DISABLE
// FogOff ( your_side ) ;
51428: LD_OWVAR 2
51432: PPUSH
51433: CALL_OW 344
51437: END
// every 0 0$1 trigger StreamModeActive and sSun do
51438: LD_EXP 92
51442: PUSH
51443: LD_EXP 115
51447: AND
51448: IFFALSE 51476
51450: GO 51452
51452: DISABLE
// begin solar_recharge_percent := 0 ;
51453: LD_ADDR_OWVAR 79
51457: PUSH
51458: LD_INT 0
51460: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51461: LD_INT 10500
51463: PPUSH
51464: CALL_OW 67
// solar_recharge_percent := 100 ;
51468: LD_ADDR_OWVAR 79
51472: PUSH
51473: LD_INT 100
51475: ST_TO_ADDR
// end ;
51476: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51477: LD_EXP 92
51481: PUSH
51482: LD_EXP 116
51486: AND
51487: IFFALSE 51726
51489: GO 51491
51491: DISABLE
51492: LD_INT 0
51494: PPUSH
51495: PPUSH
51496: PPUSH
// begin tmp := [ ] ;
51497: LD_ADDR_VAR 0 3
51501: PUSH
51502: EMPTY
51503: ST_TO_ADDR
// for i := 1 to 6 do
51504: LD_ADDR_VAR 0 1
51508: PUSH
51509: DOUBLE
51510: LD_INT 1
51512: DEC
51513: ST_TO_ADDR
51514: LD_INT 6
51516: PUSH
51517: FOR_TO
51518: IFFALSE 51623
// begin uc_nation := nation_nature ;
51520: LD_ADDR_OWVAR 21
51524: PUSH
51525: LD_INT 0
51527: ST_TO_ADDR
// uc_side := 0 ;
51528: LD_ADDR_OWVAR 20
51532: PUSH
51533: LD_INT 0
51535: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51536: LD_ADDR_OWVAR 29
51540: PUSH
51541: LD_INT 12
51543: PUSH
51544: LD_INT 12
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: ST_TO_ADDR
// hc_agressivity := 20 ;
51551: LD_ADDR_OWVAR 35
51555: PUSH
51556: LD_INT 20
51558: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51559: LD_ADDR_OWVAR 28
51563: PUSH
51564: LD_INT 17
51566: ST_TO_ADDR
// hc_gallery :=  ;
51567: LD_ADDR_OWVAR 33
51571: PUSH
51572: LD_STRING 
51574: ST_TO_ADDR
// hc_name :=  ;
51575: LD_ADDR_OWVAR 26
51579: PUSH
51580: LD_STRING 
51582: ST_TO_ADDR
// un := CreateHuman ;
51583: LD_ADDR_VAR 0 2
51587: PUSH
51588: CALL_OW 44
51592: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51593: LD_VAR 0 2
51597: PPUSH
51598: LD_INT 1
51600: PPUSH
51601: CALL_OW 51
// tmp := tmp ^ un ;
51605: LD_ADDR_VAR 0 3
51609: PUSH
51610: LD_VAR 0 3
51614: PUSH
51615: LD_VAR 0 2
51619: ADD
51620: ST_TO_ADDR
// end ;
51621: GO 51517
51623: POP
51624: POP
// repeat wait ( 0 0$1 ) ;
51625: LD_INT 35
51627: PPUSH
51628: CALL_OW 67
// for un in tmp do
51632: LD_ADDR_VAR 0 2
51636: PUSH
51637: LD_VAR 0 3
51641: PUSH
51642: FOR_IN
51643: IFFALSE 51717
// begin if IsDead ( un ) then
51645: LD_VAR 0 2
51649: PPUSH
51650: CALL_OW 301
51654: IFFALSE 51674
// begin tmp := tmp diff un ;
51656: LD_ADDR_VAR 0 3
51660: PUSH
51661: LD_VAR 0 3
51665: PUSH
51666: LD_VAR 0 2
51670: DIFF
51671: ST_TO_ADDR
// continue ;
51672: GO 51642
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51674: LD_VAR 0 2
51678: PPUSH
51679: LD_INT 3
51681: PUSH
51682: LD_INT 22
51684: PUSH
51685: LD_INT 0
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: PUSH
51692: EMPTY
51693: LIST
51694: LIST
51695: PPUSH
51696: CALL_OW 69
51700: PPUSH
51701: LD_VAR 0 2
51705: PPUSH
51706: CALL_OW 74
51710: PPUSH
51711: CALL_OW 115
// end ;
51715: GO 51642
51717: POP
51718: POP
// until not tmp ;
51719: LD_VAR 0 3
51723: NOT
51724: IFFALSE 51625
// end ;
51726: PPOPN 3
51728: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51729: LD_EXP 92
51733: PUSH
51734: LD_EXP 117
51738: AND
51739: IFFALSE 51793
51741: GO 51743
51743: DISABLE
// begin ToLua ( displayTroll(); ) ;
51744: LD_STRING displayTroll();
51746: PPUSH
51747: CALL_OW 559
// wait ( 3 3$00 ) ;
51751: LD_INT 6300
51753: PPUSH
51754: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51758: LD_STRING hideTroll();
51760: PPUSH
51761: CALL_OW 559
// wait ( 1 1$00 ) ;
51765: LD_INT 2100
51767: PPUSH
51768: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51772: LD_STRING displayTroll();
51774: PPUSH
51775: CALL_OW 559
// wait ( 1 1$00 ) ;
51779: LD_INT 2100
51781: PPUSH
51782: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51786: LD_STRING hideTroll();
51788: PPUSH
51789: CALL_OW 559
// end ;
51793: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51794: LD_EXP 92
51798: PUSH
51799: LD_EXP 118
51803: AND
51804: IFFALSE 51867
51806: GO 51808
51808: DISABLE
51809: LD_INT 0
51811: PPUSH
// begin p := 0 ;
51812: LD_ADDR_VAR 0 1
51816: PUSH
51817: LD_INT 0
51819: ST_TO_ADDR
// repeat game_speed := 1 ;
51820: LD_ADDR_OWVAR 65
51824: PUSH
51825: LD_INT 1
51827: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51828: LD_INT 35
51830: PPUSH
51831: CALL_OW 67
// p := p + 1 ;
51835: LD_ADDR_VAR 0 1
51839: PUSH
51840: LD_VAR 0 1
51844: PUSH
51845: LD_INT 1
51847: PLUS
51848: ST_TO_ADDR
// until p >= 60 ;
51849: LD_VAR 0 1
51853: PUSH
51854: LD_INT 60
51856: GREATEREQUAL
51857: IFFALSE 51820
// game_speed := 4 ;
51859: LD_ADDR_OWVAR 65
51863: PUSH
51864: LD_INT 4
51866: ST_TO_ADDR
// end ;
51867: PPOPN 1
51869: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51870: LD_EXP 92
51874: PUSH
51875: LD_EXP 119
51879: AND
51880: IFFALSE 52026
51882: GO 51884
51884: DISABLE
51885: LD_INT 0
51887: PPUSH
51888: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51889: LD_ADDR_VAR 0 1
51893: PUSH
51894: LD_INT 22
51896: PUSH
51897: LD_OWVAR 2
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: PUSH
51906: LD_INT 2
51908: PUSH
51909: LD_INT 30
51911: PUSH
51912: LD_INT 0
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PUSH
51919: LD_INT 30
51921: PUSH
51922: LD_INT 1
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: LIST
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PPUSH
51938: CALL_OW 69
51942: ST_TO_ADDR
// if not depot then
51943: LD_VAR 0 1
51947: NOT
51948: IFFALSE 51952
// exit ;
51950: GO 52026
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51952: LD_ADDR_VAR 0 2
51956: PUSH
51957: LD_VAR 0 1
51961: PUSH
51962: LD_INT 1
51964: PPUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: CALL_OW 12
51974: ARRAY
51975: PPUSH
51976: CALL_OW 274
51980: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51981: LD_VAR 0 2
51985: PPUSH
51986: LD_INT 1
51988: PPUSH
51989: LD_INT 0
51991: PPUSH
51992: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51996: LD_VAR 0 2
52000: PPUSH
52001: LD_INT 2
52003: PPUSH
52004: LD_INT 0
52006: PPUSH
52007: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
52011: LD_VAR 0 2
52015: PPUSH
52016: LD_INT 3
52018: PPUSH
52019: LD_INT 0
52021: PPUSH
52022: CALL_OW 277
// end ;
52026: PPOPN 2
52028: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52029: LD_EXP 92
52033: PUSH
52034: LD_EXP 120
52038: AND
52039: IFFALSE 52136
52041: GO 52043
52043: DISABLE
52044: LD_INT 0
52046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52047: LD_ADDR_VAR 0 1
52051: PUSH
52052: LD_INT 22
52054: PUSH
52055: LD_OWVAR 2
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: PUSH
52064: LD_INT 21
52066: PUSH
52067: LD_INT 1
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: PUSH
52074: LD_INT 3
52076: PUSH
52077: LD_INT 23
52079: PUSH
52080: LD_INT 0
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: EMPTY
52088: LIST
52089: LIST
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: LIST
52095: PPUSH
52096: CALL_OW 69
52100: ST_TO_ADDR
// if not tmp then
52101: LD_VAR 0 1
52105: NOT
52106: IFFALSE 52110
// exit ;
52108: GO 52136
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52110: LD_VAR 0 1
52114: PUSH
52115: LD_INT 1
52117: PPUSH
52118: LD_VAR 0 1
52122: PPUSH
52123: CALL_OW 12
52127: ARRAY
52128: PPUSH
52129: LD_INT 200
52131: PPUSH
52132: CALL_OW 234
// end ;
52136: PPOPN 1
52138: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52139: LD_EXP 92
52143: PUSH
52144: LD_EXP 121
52148: AND
52149: IFFALSE 52228
52151: GO 52153
52153: DISABLE
52154: LD_INT 0
52156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52157: LD_ADDR_VAR 0 1
52161: PUSH
52162: LD_INT 22
52164: PUSH
52165: LD_OWVAR 2
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: PUSH
52174: LD_INT 21
52176: PUSH
52177: LD_INT 2
52179: PUSH
52180: EMPTY
52181: LIST
52182: LIST
52183: PUSH
52184: EMPTY
52185: LIST
52186: LIST
52187: PPUSH
52188: CALL_OW 69
52192: ST_TO_ADDR
// if not tmp then
52193: LD_VAR 0 1
52197: NOT
52198: IFFALSE 52202
// exit ;
52200: GO 52228
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52202: LD_VAR 0 1
52206: PUSH
52207: LD_INT 1
52209: PPUSH
52210: LD_VAR 0 1
52214: PPUSH
52215: CALL_OW 12
52219: ARRAY
52220: PPUSH
52221: LD_INT 60
52223: PPUSH
52224: CALL_OW 234
// end ;
52228: PPOPN 1
52230: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52231: LD_EXP 92
52235: PUSH
52236: LD_EXP 122
52240: AND
52241: IFFALSE 52340
52243: GO 52245
52245: DISABLE
52246: LD_INT 0
52248: PPUSH
52249: PPUSH
// begin enable ;
52250: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52251: LD_ADDR_VAR 0 1
52255: PUSH
52256: LD_INT 22
52258: PUSH
52259: LD_OWVAR 2
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: PUSH
52268: LD_INT 61
52270: PUSH
52271: EMPTY
52272: LIST
52273: PUSH
52274: LD_INT 33
52276: PUSH
52277: LD_INT 2
52279: PUSH
52280: EMPTY
52281: LIST
52282: LIST
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: LIST
52288: PPUSH
52289: CALL_OW 69
52293: ST_TO_ADDR
// if not tmp then
52294: LD_VAR 0 1
52298: NOT
52299: IFFALSE 52303
// exit ;
52301: GO 52340
// for i in tmp do
52303: LD_ADDR_VAR 0 2
52307: PUSH
52308: LD_VAR 0 1
52312: PUSH
52313: FOR_IN
52314: IFFALSE 52338
// if IsControledBy ( i ) then
52316: LD_VAR 0 2
52320: PPUSH
52321: CALL_OW 312
52325: IFFALSE 52336
// ComUnlink ( i ) ;
52327: LD_VAR 0 2
52331: PPUSH
52332: CALL_OW 136
52336: GO 52313
52338: POP
52339: POP
// end ;
52340: PPOPN 2
52342: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52343: LD_EXP 92
52347: PUSH
52348: LD_EXP 123
52352: AND
52353: IFFALSE 52493
52355: GO 52357
52357: DISABLE
52358: LD_INT 0
52360: PPUSH
52361: PPUSH
// begin ToLua ( displayPowell(); ) ;
52362: LD_STRING displayPowell();
52364: PPUSH
52365: CALL_OW 559
// uc_side := 0 ;
52369: LD_ADDR_OWVAR 20
52373: PUSH
52374: LD_INT 0
52376: ST_TO_ADDR
// uc_nation := 2 ;
52377: LD_ADDR_OWVAR 21
52381: PUSH
52382: LD_INT 2
52384: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52385: LD_ADDR_OWVAR 37
52389: PUSH
52390: LD_INT 14
52392: ST_TO_ADDR
// vc_engine := engine_siberite ;
52393: LD_ADDR_OWVAR 39
52397: PUSH
52398: LD_INT 3
52400: ST_TO_ADDR
// vc_control := control_apeman ;
52401: LD_ADDR_OWVAR 38
52405: PUSH
52406: LD_INT 5
52408: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52409: LD_ADDR_OWVAR 40
52413: PUSH
52414: LD_INT 29
52416: ST_TO_ADDR
// un := CreateVehicle ;
52417: LD_ADDR_VAR 0 2
52421: PUSH
52422: CALL_OW 45
52426: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52427: LD_VAR 0 2
52431: PPUSH
52432: LD_INT 1
52434: PPUSH
52435: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52439: LD_INT 35
52441: PPUSH
52442: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52446: LD_VAR 0 2
52450: PPUSH
52451: LD_INT 22
52453: PUSH
52454: LD_OWVAR 2
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: PPUSH
52463: CALL_OW 69
52467: PPUSH
52468: LD_VAR 0 2
52472: PPUSH
52473: CALL_OW 74
52477: PPUSH
52478: CALL_OW 115
// until IsDead ( un ) ;
52482: LD_VAR 0 2
52486: PPUSH
52487: CALL_OW 301
52491: IFFALSE 52439
// end ;
52493: PPOPN 2
52495: END
// every 0 0$1 trigger StreamModeActive and sStu do
52496: LD_EXP 92
52500: PUSH
52501: LD_EXP 131
52505: AND
52506: IFFALSE 52522
52508: GO 52510
52510: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52511: LD_STRING displayStucuk();
52513: PPUSH
52514: CALL_OW 559
// ResetFog ;
52518: CALL_OW 335
// end ;
52522: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52523: LD_EXP 92
52527: PUSH
52528: LD_EXP 124
52532: AND
52533: IFFALSE 52674
52535: GO 52537
52537: DISABLE
52538: LD_INT 0
52540: PPUSH
52541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52542: LD_ADDR_VAR 0 2
52546: PUSH
52547: LD_INT 22
52549: PUSH
52550: LD_OWVAR 2
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: PUSH
52559: LD_INT 21
52561: PUSH
52562: LD_INT 1
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: PUSH
52569: EMPTY
52570: LIST
52571: LIST
52572: PPUSH
52573: CALL_OW 69
52577: ST_TO_ADDR
// if not tmp then
52578: LD_VAR 0 2
52582: NOT
52583: IFFALSE 52587
// exit ;
52585: GO 52674
// un := tmp [ rand ( 1 , tmp ) ] ;
52587: LD_ADDR_VAR 0 1
52591: PUSH
52592: LD_VAR 0 2
52596: PUSH
52597: LD_INT 1
52599: PPUSH
52600: LD_VAR 0 2
52604: PPUSH
52605: CALL_OW 12
52609: ARRAY
52610: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52611: LD_VAR 0 1
52615: PPUSH
52616: LD_INT 0
52618: PPUSH
52619: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52623: LD_VAR 0 1
52627: PPUSH
52628: LD_OWVAR 3
52632: PUSH
52633: LD_VAR 0 1
52637: DIFF
52638: PPUSH
52639: LD_VAR 0 1
52643: PPUSH
52644: CALL_OW 74
52648: PPUSH
52649: CALL_OW 115
// wait ( 0 0$20 ) ;
52653: LD_INT 700
52655: PPUSH
52656: CALL_OW 67
// SetSide ( un , your_side ) ;
52660: LD_VAR 0 1
52664: PPUSH
52665: LD_OWVAR 2
52669: PPUSH
52670: CALL_OW 235
// end ;
52674: PPOPN 2
52676: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52677: LD_EXP 92
52681: PUSH
52682: LD_EXP 125
52686: AND
52687: IFFALSE 52793
52689: GO 52691
52691: DISABLE
52692: LD_INT 0
52694: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52695: LD_ADDR_VAR 0 1
52699: PUSH
52700: LD_INT 22
52702: PUSH
52703: LD_OWVAR 2
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PUSH
52712: LD_INT 2
52714: PUSH
52715: LD_INT 30
52717: PUSH
52718: LD_INT 0
52720: PUSH
52721: EMPTY
52722: LIST
52723: LIST
52724: PUSH
52725: LD_INT 30
52727: PUSH
52728: LD_INT 1
52730: PUSH
52731: EMPTY
52732: LIST
52733: LIST
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 69
52748: ST_TO_ADDR
// if not depot then
52749: LD_VAR 0 1
52753: NOT
52754: IFFALSE 52758
// exit ;
52756: GO 52793
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52758: LD_VAR 0 1
52762: PUSH
52763: LD_INT 1
52765: ARRAY
52766: PPUSH
52767: CALL_OW 250
52771: PPUSH
52772: LD_VAR 0 1
52776: PUSH
52777: LD_INT 1
52779: ARRAY
52780: PPUSH
52781: CALL_OW 251
52785: PPUSH
52786: LD_INT 70
52788: PPUSH
52789: CALL_OW 495
// end ;
52793: PPOPN 1
52795: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52796: LD_EXP 92
52800: PUSH
52801: LD_EXP 126
52805: AND
52806: IFFALSE 53017
52808: GO 52810
52810: DISABLE
52811: LD_INT 0
52813: PPUSH
52814: PPUSH
52815: PPUSH
52816: PPUSH
52817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52818: LD_ADDR_VAR 0 5
52822: PUSH
52823: LD_INT 22
52825: PUSH
52826: LD_OWVAR 2
52830: PUSH
52831: EMPTY
52832: LIST
52833: LIST
52834: PUSH
52835: LD_INT 21
52837: PUSH
52838: LD_INT 1
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: PPUSH
52849: CALL_OW 69
52853: ST_TO_ADDR
// if not tmp then
52854: LD_VAR 0 5
52858: NOT
52859: IFFALSE 52863
// exit ;
52861: GO 53017
// for i in tmp do
52863: LD_ADDR_VAR 0 1
52867: PUSH
52868: LD_VAR 0 5
52872: PUSH
52873: FOR_IN
52874: IFFALSE 53015
// begin d := rand ( 0 , 5 ) ;
52876: LD_ADDR_VAR 0 4
52880: PUSH
52881: LD_INT 0
52883: PPUSH
52884: LD_INT 5
52886: PPUSH
52887: CALL_OW 12
52891: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52892: LD_ADDR_VAR 0 2
52896: PUSH
52897: LD_VAR 0 1
52901: PPUSH
52902: CALL_OW 250
52906: PPUSH
52907: LD_VAR 0 4
52911: PPUSH
52912: LD_INT 3
52914: PPUSH
52915: LD_INT 12
52917: PPUSH
52918: CALL_OW 12
52922: PPUSH
52923: CALL_OW 272
52927: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52928: LD_ADDR_VAR 0 3
52932: PUSH
52933: LD_VAR 0 1
52937: PPUSH
52938: CALL_OW 251
52942: PPUSH
52943: LD_VAR 0 4
52947: PPUSH
52948: LD_INT 3
52950: PPUSH
52951: LD_INT 12
52953: PPUSH
52954: CALL_OW 12
52958: PPUSH
52959: CALL_OW 273
52963: ST_TO_ADDR
// if ValidHex ( x , y ) then
52964: LD_VAR 0 2
52968: PPUSH
52969: LD_VAR 0 3
52973: PPUSH
52974: CALL_OW 488
52978: IFFALSE 53013
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52980: LD_VAR 0 1
52984: PPUSH
52985: LD_VAR 0 2
52989: PPUSH
52990: LD_VAR 0 3
52994: PPUSH
52995: LD_INT 3
52997: PPUSH
52998: LD_INT 6
53000: PPUSH
53001: CALL_OW 12
53005: PPUSH
53006: LD_INT 1
53008: PPUSH
53009: CALL_OW 483
// end ;
53013: GO 52873
53015: POP
53016: POP
// end ;
53017: PPOPN 5
53019: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53020: LD_EXP 92
53024: PUSH
53025: LD_EXP 127
53029: AND
53030: IFFALSE 53124
53032: GO 53034
53034: DISABLE
53035: LD_INT 0
53037: PPUSH
53038: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53039: LD_ADDR_VAR 0 2
53043: PUSH
53044: LD_INT 22
53046: PUSH
53047: LD_OWVAR 2
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: PUSH
53056: LD_INT 32
53058: PUSH
53059: LD_INT 1
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: LD_INT 21
53068: PUSH
53069: LD_INT 2
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: PPUSH
53081: CALL_OW 69
53085: ST_TO_ADDR
// if not tmp then
53086: LD_VAR 0 2
53090: NOT
53091: IFFALSE 53095
// exit ;
53093: GO 53124
// for i in tmp do
53095: LD_ADDR_VAR 0 1
53099: PUSH
53100: LD_VAR 0 2
53104: PUSH
53105: FOR_IN
53106: IFFALSE 53122
// SetFuel ( i , 0 ) ;
53108: LD_VAR 0 1
53112: PPUSH
53113: LD_INT 0
53115: PPUSH
53116: CALL_OW 240
53120: GO 53105
53122: POP
53123: POP
// end ;
53124: PPOPN 2
53126: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53127: LD_EXP 92
53131: PUSH
53132: LD_EXP 128
53136: AND
53137: IFFALSE 53203
53139: GO 53141
53141: DISABLE
53142: LD_INT 0
53144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53145: LD_ADDR_VAR 0 1
53149: PUSH
53150: LD_INT 22
53152: PUSH
53153: LD_OWVAR 2
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: PUSH
53162: LD_INT 30
53164: PUSH
53165: LD_INT 29
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: PUSH
53172: EMPTY
53173: LIST
53174: LIST
53175: PPUSH
53176: CALL_OW 69
53180: ST_TO_ADDR
// if not tmp then
53181: LD_VAR 0 1
53185: NOT
53186: IFFALSE 53190
// exit ;
53188: GO 53203
// DestroyUnit ( tmp [ 1 ] ) ;
53190: LD_VAR 0 1
53194: PUSH
53195: LD_INT 1
53197: ARRAY
53198: PPUSH
53199: CALL_OW 65
// end ;
53203: PPOPN 1
53205: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53206: LD_EXP 92
53210: PUSH
53211: LD_EXP 130
53215: AND
53216: IFFALSE 53345
53218: GO 53220
53220: DISABLE
53221: LD_INT 0
53223: PPUSH
// begin uc_side := 0 ;
53224: LD_ADDR_OWVAR 20
53228: PUSH
53229: LD_INT 0
53231: ST_TO_ADDR
// uc_nation := nation_arabian ;
53232: LD_ADDR_OWVAR 21
53236: PUSH
53237: LD_INT 2
53239: ST_TO_ADDR
// hc_gallery :=  ;
53240: LD_ADDR_OWVAR 33
53244: PUSH
53245: LD_STRING 
53247: ST_TO_ADDR
// hc_name :=  ;
53248: LD_ADDR_OWVAR 26
53252: PUSH
53253: LD_STRING 
53255: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53256: LD_INT 1
53258: PPUSH
53259: LD_INT 11
53261: PPUSH
53262: LD_INT 10
53264: PPUSH
53265: CALL_OW 380
// un := CreateHuman ;
53269: LD_ADDR_VAR 0 1
53273: PUSH
53274: CALL_OW 44
53278: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53279: LD_VAR 0 1
53283: PPUSH
53284: LD_INT 1
53286: PPUSH
53287: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53291: LD_INT 35
53293: PPUSH
53294: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53298: LD_VAR 0 1
53302: PPUSH
53303: LD_INT 22
53305: PUSH
53306: LD_OWVAR 2
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: PPUSH
53315: CALL_OW 69
53319: PPUSH
53320: LD_VAR 0 1
53324: PPUSH
53325: CALL_OW 74
53329: PPUSH
53330: CALL_OW 115
// until IsDead ( un ) ;
53334: LD_VAR 0 1
53338: PPUSH
53339: CALL_OW 301
53343: IFFALSE 53291
// end ;
53345: PPOPN 1
53347: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53348: LD_EXP 92
53352: PUSH
53353: LD_EXP 132
53357: AND
53358: IFFALSE 53370
53360: GO 53362
53362: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53363: LD_STRING earthquake(getX(game), 0, 32)
53365: PPUSH
53366: CALL_OW 559
53370: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53371: LD_EXP 92
53375: PUSH
53376: LD_EXP 133
53380: AND
53381: IFFALSE 53472
53383: GO 53385
53385: DISABLE
53386: LD_INT 0
53388: PPUSH
// begin enable ;
53389: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53390: LD_ADDR_VAR 0 1
53394: PUSH
53395: LD_INT 22
53397: PUSH
53398: LD_OWVAR 2
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: PUSH
53407: LD_INT 21
53409: PUSH
53410: LD_INT 2
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: PUSH
53417: LD_INT 33
53419: PUSH
53420: LD_INT 3
53422: PUSH
53423: EMPTY
53424: LIST
53425: LIST
53426: PUSH
53427: EMPTY
53428: LIST
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 69
53436: ST_TO_ADDR
// if not tmp then
53437: LD_VAR 0 1
53441: NOT
53442: IFFALSE 53446
// exit ;
53444: GO 53472
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53446: LD_VAR 0 1
53450: PUSH
53451: LD_INT 1
53453: PPUSH
53454: LD_VAR 0 1
53458: PPUSH
53459: CALL_OW 12
53463: ARRAY
53464: PPUSH
53465: LD_INT 1
53467: PPUSH
53468: CALL_OW 234
// end ;
53472: PPOPN 1
53474: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53475: LD_EXP 92
53479: PUSH
53480: LD_EXP 134
53484: AND
53485: IFFALSE 53626
53487: GO 53489
53489: DISABLE
53490: LD_INT 0
53492: PPUSH
53493: PPUSH
53494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53495: LD_ADDR_VAR 0 3
53499: PUSH
53500: LD_INT 22
53502: PUSH
53503: LD_OWVAR 2
53507: PUSH
53508: EMPTY
53509: LIST
53510: LIST
53511: PUSH
53512: LD_INT 25
53514: PUSH
53515: LD_INT 1
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: PUSH
53522: EMPTY
53523: LIST
53524: LIST
53525: PPUSH
53526: CALL_OW 69
53530: ST_TO_ADDR
// if not tmp then
53531: LD_VAR 0 3
53535: NOT
53536: IFFALSE 53540
// exit ;
53538: GO 53626
// un := tmp [ rand ( 1 , tmp ) ] ;
53540: LD_ADDR_VAR 0 2
53544: PUSH
53545: LD_VAR 0 3
53549: PUSH
53550: LD_INT 1
53552: PPUSH
53553: LD_VAR 0 3
53557: PPUSH
53558: CALL_OW 12
53562: ARRAY
53563: ST_TO_ADDR
// if Crawls ( un ) then
53564: LD_VAR 0 2
53568: PPUSH
53569: CALL_OW 318
53573: IFFALSE 53584
// ComWalk ( un ) ;
53575: LD_VAR 0 2
53579: PPUSH
53580: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53584: LD_VAR 0 2
53588: PPUSH
53589: LD_INT 9
53591: PPUSH
53592: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53596: LD_INT 28
53598: PPUSH
53599: LD_OWVAR 2
53603: PPUSH
53604: LD_INT 2
53606: PPUSH
53607: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53611: LD_INT 29
53613: PPUSH
53614: LD_OWVAR 2
53618: PPUSH
53619: LD_INT 2
53621: PPUSH
53622: CALL_OW 322
// end ;
53626: PPOPN 3
53628: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53629: LD_EXP 92
53633: PUSH
53634: LD_EXP 135
53638: AND
53639: IFFALSE 53750
53641: GO 53643
53643: DISABLE
53644: LD_INT 0
53646: PPUSH
53647: PPUSH
53648: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53649: LD_ADDR_VAR 0 3
53653: PUSH
53654: LD_INT 22
53656: PUSH
53657: LD_OWVAR 2
53661: PUSH
53662: EMPTY
53663: LIST
53664: LIST
53665: PUSH
53666: LD_INT 25
53668: PUSH
53669: LD_INT 1
53671: PUSH
53672: EMPTY
53673: LIST
53674: LIST
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: PPUSH
53680: CALL_OW 69
53684: ST_TO_ADDR
// if not tmp then
53685: LD_VAR 0 3
53689: NOT
53690: IFFALSE 53694
// exit ;
53692: GO 53750
// un := tmp [ rand ( 1 , tmp ) ] ;
53694: LD_ADDR_VAR 0 2
53698: PUSH
53699: LD_VAR 0 3
53703: PUSH
53704: LD_INT 1
53706: PPUSH
53707: LD_VAR 0 3
53711: PPUSH
53712: CALL_OW 12
53716: ARRAY
53717: ST_TO_ADDR
// if Crawls ( un ) then
53718: LD_VAR 0 2
53722: PPUSH
53723: CALL_OW 318
53727: IFFALSE 53738
// ComWalk ( un ) ;
53729: LD_VAR 0 2
53733: PPUSH
53734: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53738: LD_VAR 0 2
53742: PPUSH
53743: LD_INT 8
53745: PPUSH
53746: CALL_OW 336
// end ;
53750: PPOPN 3
53752: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53753: LD_EXP 92
53757: PUSH
53758: LD_EXP 136
53762: AND
53763: IFFALSE 53907
53765: GO 53767
53767: DISABLE
53768: LD_INT 0
53770: PPUSH
53771: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53772: LD_ADDR_VAR 0 2
53776: PUSH
53777: LD_INT 22
53779: PUSH
53780: LD_OWVAR 2
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: PUSH
53789: LD_INT 21
53791: PUSH
53792: LD_INT 2
53794: PUSH
53795: EMPTY
53796: LIST
53797: LIST
53798: PUSH
53799: LD_INT 2
53801: PUSH
53802: LD_INT 34
53804: PUSH
53805: LD_INT 12
53807: PUSH
53808: EMPTY
53809: LIST
53810: LIST
53811: PUSH
53812: LD_INT 34
53814: PUSH
53815: LD_INT 51
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: PUSH
53822: LD_INT 34
53824: PUSH
53825: LD_INT 32
53827: PUSH
53828: EMPTY
53829: LIST
53830: LIST
53831: PUSH
53832: EMPTY
53833: LIST
53834: LIST
53835: LIST
53836: LIST
53837: PUSH
53838: EMPTY
53839: LIST
53840: LIST
53841: LIST
53842: PPUSH
53843: CALL_OW 69
53847: ST_TO_ADDR
// if not tmp then
53848: LD_VAR 0 2
53852: NOT
53853: IFFALSE 53857
// exit ;
53855: GO 53907
// for i in tmp do
53857: LD_ADDR_VAR 0 1
53861: PUSH
53862: LD_VAR 0 2
53866: PUSH
53867: FOR_IN
53868: IFFALSE 53905
// if GetCargo ( i , mat_artifact ) = 0 then
53870: LD_VAR 0 1
53874: PPUSH
53875: LD_INT 4
53877: PPUSH
53878: CALL_OW 289
53882: PUSH
53883: LD_INT 0
53885: EQUAL
53886: IFFALSE 53903
// SetCargo ( i , mat_siberit , 100 ) ;
53888: LD_VAR 0 1
53892: PPUSH
53893: LD_INT 3
53895: PPUSH
53896: LD_INT 100
53898: PPUSH
53899: CALL_OW 290
53903: GO 53867
53905: POP
53906: POP
// end ;
53907: PPOPN 2
53909: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53910: LD_EXP 92
53914: PUSH
53915: LD_EXP 137
53919: AND
53920: IFFALSE 54103
53922: GO 53924
53924: DISABLE
53925: LD_INT 0
53927: PPUSH
53928: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53929: LD_ADDR_VAR 0 2
53933: PUSH
53934: LD_INT 22
53936: PUSH
53937: LD_OWVAR 2
53941: PUSH
53942: EMPTY
53943: LIST
53944: LIST
53945: PPUSH
53946: CALL_OW 69
53950: ST_TO_ADDR
// if not tmp then
53951: LD_VAR 0 2
53955: NOT
53956: IFFALSE 53960
// exit ;
53958: GO 54103
// for i := 1 to 2 do
53960: LD_ADDR_VAR 0 1
53964: PUSH
53965: DOUBLE
53966: LD_INT 1
53968: DEC
53969: ST_TO_ADDR
53970: LD_INT 2
53972: PUSH
53973: FOR_TO
53974: IFFALSE 54101
// begin uc_side := your_side ;
53976: LD_ADDR_OWVAR 20
53980: PUSH
53981: LD_OWVAR 2
53985: ST_TO_ADDR
// uc_nation := nation_american ;
53986: LD_ADDR_OWVAR 21
53990: PUSH
53991: LD_INT 1
53993: ST_TO_ADDR
// vc_chassis := us_morphling ;
53994: LD_ADDR_OWVAR 37
53998: PUSH
53999: LD_INT 5
54001: ST_TO_ADDR
// vc_engine := engine_siberite ;
54002: LD_ADDR_OWVAR 39
54006: PUSH
54007: LD_INT 3
54009: ST_TO_ADDR
// vc_control := control_computer ;
54010: LD_ADDR_OWVAR 38
54014: PUSH
54015: LD_INT 3
54017: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54018: LD_ADDR_OWVAR 40
54022: PUSH
54023: LD_INT 10
54025: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54026: LD_VAR 0 2
54030: PUSH
54031: LD_INT 1
54033: ARRAY
54034: PPUSH
54035: CALL_OW 310
54039: NOT
54040: IFFALSE 54087
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54042: CALL_OW 45
54046: PPUSH
54047: LD_VAR 0 2
54051: PUSH
54052: LD_INT 1
54054: ARRAY
54055: PPUSH
54056: CALL_OW 250
54060: PPUSH
54061: LD_VAR 0 2
54065: PUSH
54066: LD_INT 1
54068: ARRAY
54069: PPUSH
54070: CALL_OW 251
54074: PPUSH
54075: LD_INT 12
54077: PPUSH
54078: LD_INT 1
54080: PPUSH
54081: CALL_OW 50
54085: GO 54099
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54087: CALL_OW 45
54091: PPUSH
54092: LD_INT 1
54094: PPUSH
54095: CALL_OW 51
// end ;
54099: GO 53973
54101: POP
54102: POP
// end ;
54103: PPOPN 2
54105: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54106: LD_EXP 92
54110: PUSH
54111: LD_EXP 138
54115: AND
54116: IFFALSE 54338
54118: GO 54120
54120: DISABLE
54121: LD_INT 0
54123: PPUSH
54124: PPUSH
54125: PPUSH
54126: PPUSH
54127: PPUSH
54128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54129: LD_ADDR_VAR 0 6
54133: PUSH
54134: LD_INT 22
54136: PUSH
54137: LD_OWVAR 2
54141: PUSH
54142: EMPTY
54143: LIST
54144: LIST
54145: PUSH
54146: LD_INT 21
54148: PUSH
54149: LD_INT 1
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: PUSH
54156: LD_INT 3
54158: PUSH
54159: LD_INT 23
54161: PUSH
54162: LD_INT 0
54164: PUSH
54165: EMPTY
54166: LIST
54167: LIST
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: LIST
54177: PPUSH
54178: CALL_OW 69
54182: ST_TO_ADDR
// if not tmp then
54183: LD_VAR 0 6
54187: NOT
54188: IFFALSE 54192
// exit ;
54190: GO 54338
// s1 := rand ( 1 , 4 ) ;
54192: LD_ADDR_VAR 0 2
54196: PUSH
54197: LD_INT 1
54199: PPUSH
54200: LD_INT 4
54202: PPUSH
54203: CALL_OW 12
54207: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54208: LD_ADDR_VAR 0 4
54212: PUSH
54213: LD_VAR 0 6
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PPUSH
54222: LD_VAR 0 2
54226: PPUSH
54227: CALL_OW 259
54231: ST_TO_ADDR
// if s1 = 1 then
54232: LD_VAR 0 2
54236: PUSH
54237: LD_INT 1
54239: EQUAL
54240: IFFALSE 54260
// s2 := rand ( 2 , 4 ) else
54242: LD_ADDR_VAR 0 3
54246: PUSH
54247: LD_INT 2
54249: PPUSH
54250: LD_INT 4
54252: PPUSH
54253: CALL_OW 12
54257: ST_TO_ADDR
54258: GO 54268
// s2 := 1 ;
54260: LD_ADDR_VAR 0 3
54264: PUSH
54265: LD_INT 1
54267: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54268: LD_ADDR_VAR 0 5
54272: PUSH
54273: LD_VAR 0 6
54277: PUSH
54278: LD_INT 1
54280: ARRAY
54281: PPUSH
54282: LD_VAR 0 3
54286: PPUSH
54287: CALL_OW 259
54291: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54292: LD_VAR 0 6
54296: PUSH
54297: LD_INT 1
54299: ARRAY
54300: PPUSH
54301: LD_VAR 0 2
54305: PPUSH
54306: LD_VAR 0 5
54310: PPUSH
54311: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54315: LD_VAR 0 6
54319: PUSH
54320: LD_INT 1
54322: ARRAY
54323: PPUSH
54324: LD_VAR 0 3
54328: PPUSH
54329: LD_VAR 0 4
54333: PPUSH
54334: CALL_OW 237
// end ;
54338: PPOPN 6
54340: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54341: LD_EXP 92
54345: PUSH
54346: LD_EXP 139
54350: AND
54351: IFFALSE 54430
54353: GO 54355
54355: DISABLE
54356: LD_INT 0
54358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54359: LD_ADDR_VAR 0 1
54363: PUSH
54364: LD_INT 22
54366: PUSH
54367: LD_OWVAR 2
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: PUSH
54376: LD_INT 30
54378: PUSH
54379: LD_INT 3
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: PPUSH
54390: CALL_OW 69
54394: ST_TO_ADDR
// if not tmp then
54395: LD_VAR 0 1
54399: NOT
54400: IFFALSE 54404
// exit ;
54402: GO 54430
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54404: LD_VAR 0 1
54408: PUSH
54409: LD_INT 1
54411: PPUSH
54412: LD_VAR 0 1
54416: PPUSH
54417: CALL_OW 12
54421: ARRAY
54422: PPUSH
54423: LD_INT 1
54425: PPUSH
54426: CALL_OW 234
// end ;
54430: PPOPN 1
54432: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54433: LD_EXP 92
54437: PUSH
54438: LD_EXP 140
54442: AND
54443: IFFALSE 54555
54445: GO 54447
54447: DISABLE
54448: LD_INT 0
54450: PPUSH
54451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54452: LD_ADDR_VAR 0 2
54456: PUSH
54457: LD_INT 22
54459: PUSH
54460: LD_OWVAR 2
54464: PUSH
54465: EMPTY
54466: LIST
54467: LIST
54468: PUSH
54469: LD_INT 2
54471: PUSH
54472: LD_INT 30
54474: PUSH
54475: LD_INT 27
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: PUSH
54482: LD_INT 30
54484: PUSH
54485: LD_INT 26
54487: PUSH
54488: EMPTY
54489: LIST
54490: LIST
54491: PUSH
54492: LD_INT 30
54494: PUSH
54495: LD_INT 28
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: LIST
54506: LIST
54507: PUSH
54508: EMPTY
54509: LIST
54510: LIST
54511: PPUSH
54512: CALL_OW 69
54516: ST_TO_ADDR
// if not tmp then
54517: LD_VAR 0 2
54521: NOT
54522: IFFALSE 54526
// exit ;
54524: GO 54555
// for i in tmp do
54526: LD_ADDR_VAR 0 1
54530: PUSH
54531: LD_VAR 0 2
54535: PUSH
54536: FOR_IN
54537: IFFALSE 54553
// SetLives ( i , 1 ) ;
54539: LD_VAR 0 1
54543: PPUSH
54544: LD_INT 1
54546: PPUSH
54547: CALL_OW 234
54551: GO 54536
54553: POP
54554: POP
// end ;
54555: PPOPN 2
54557: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54558: LD_EXP 92
54562: PUSH
54563: LD_EXP 141
54567: AND
54568: IFFALSE 54855
54570: GO 54572
54572: DISABLE
54573: LD_INT 0
54575: PPUSH
54576: PPUSH
54577: PPUSH
// begin i := rand ( 1 , 7 ) ;
54578: LD_ADDR_VAR 0 1
54582: PUSH
54583: LD_INT 1
54585: PPUSH
54586: LD_INT 7
54588: PPUSH
54589: CALL_OW 12
54593: ST_TO_ADDR
// case i of 1 :
54594: LD_VAR 0 1
54598: PUSH
54599: LD_INT 1
54601: DOUBLE
54602: EQUAL
54603: IFTRUE 54607
54605: GO 54617
54607: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54608: LD_STRING earthquake(getX(game), 0, 32)
54610: PPUSH
54611: CALL_OW 559
54615: GO 54855
54617: LD_INT 2
54619: DOUBLE
54620: EQUAL
54621: IFTRUE 54625
54623: GO 54639
54625: POP
// begin ToLua ( displayStucuk(); ) ;
54626: LD_STRING displayStucuk();
54628: PPUSH
54629: CALL_OW 559
// ResetFog ;
54633: CALL_OW 335
// end ; 3 :
54637: GO 54855
54639: LD_INT 3
54641: DOUBLE
54642: EQUAL
54643: IFTRUE 54647
54645: GO 54751
54647: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54648: LD_ADDR_VAR 0 2
54652: PUSH
54653: LD_INT 22
54655: PUSH
54656: LD_OWVAR 2
54660: PUSH
54661: EMPTY
54662: LIST
54663: LIST
54664: PUSH
54665: LD_INT 25
54667: PUSH
54668: LD_INT 1
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: PPUSH
54679: CALL_OW 69
54683: ST_TO_ADDR
// if not tmp then
54684: LD_VAR 0 2
54688: NOT
54689: IFFALSE 54693
// exit ;
54691: GO 54855
// un := tmp [ rand ( 1 , tmp ) ] ;
54693: LD_ADDR_VAR 0 3
54697: PUSH
54698: LD_VAR 0 2
54702: PUSH
54703: LD_INT 1
54705: PPUSH
54706: LD_VAR 0 2
54710: PPUSH
54711: CALL_OW 12
54715: ARRAY
54716: ST_TO_ADDR
// if Crawls ( un ) then
54717: LD_VAR 0 3
54721: PPUSH
54722: CALL_OW 318
54726: IFFALSE 54737
// ComWalk ( un ) ;
54728: LD_VAR 0 3
54732: PPUSH
54733: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54737: LD_VAR 0 3
54741: PPUSH
54742: LD_INT 8
54744: PPUSH
54745: CALL_OW 336
// end ; 4 :
54749: GO 54855
54751: LD_INT 4
54753: DOUBLE
54754: EQUAL
54755: IFTRUE 54759
54757: GO 54833
54759: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54760: LD_ADDR_VAR 0 2
54764: PUSH
54765: LD_INT 22
54767: PUSH
54768: LD_OWVAR 2
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: LD_INT 30
54779: PUSH
54780: LD_INT 29
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: PPUSH
54791: CALL_OW 69
54795: ST_TO_ADDR
// if not tmp then
54796: LD_VAR 0 2
54800: NOT
54801: IFFALSE 54805
// exit ;
54803: GO 54855
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54805: LD_VAR 0 2
54809: PUSH
54810: LD_INT 1
54812: ARRAY
54813: PPUSH
54814: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54818: LD_VAR 0 2
54822: PUSH
54823: LD_INT 1
54825: ARRAY
54826: PPUSH
54827: CALL_OW 65
// end ; 5 .. 7 :
54831: GO 54855
54833: LD_INT 5
54835: DOUBLE
54836: GREATEREQUAL
54837: IFFALSE 54845
54839: LD_INT 7
54841: DOUBLE
54842: LESSEQUAL
54843: IFTRUE 54847
54845: GO 54854
54847: POP
// StreamSibBomb ; end ;
54848: CALL 51092 0 0
54852: GO 54855
54854: POP
// end ;
54855: PPOPN 3
54857: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54858: LD_EXP 92
54862: PUSH
54863: LD_EXP 142
54867: AND
54868: IFFALSE 55024
54870: GO 54872
54872: DISABLE
54873: LD_INT 0
54875: PPUSH
54876: PPUSH
54877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54878: LD_ADDR_VAR 0 2
54882: PUSH
54883: LD_INT 81
54885: PUSH
54886: LD_OWVAR 2
54890: PUSH
54891: EMPTY
54892: LIST
54893: LIST
54894: PUSH
54895: LD_INT 2
54897: PUSH
54898: LD_INT 21
54900: PUSH
54901: LD_INT 1
54903: PUSH
54904: EMPTY
54905: LIST
54906: LIST
54907: PUSH
54908: LD_INT 21
54910: PUSH
54911: LD_INT 2
54913: PUSH
54914: EMPTY
54915: LIST
54916: LIST
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: LIST
54922: PUSH
54923: EMPTY
54924: LIST
54925: LIST
54926: PPUSH
54927: CALL_OW 69
54931: ST_TO_ADDR
// if not tmp then
54932: LD_VAR 0 2
54936: NOT
54937: IFFALSE 54941
// exit ;
54939: GO 55024
// p := 0 ;
54941: LD_ADDR_VAR 0 3
54945: PUSH
54946: LD_INT 0
54948: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54949: LD_INT 35
54951: PPUSH
54952: CALL_OW 67
// p := p + 1 ;
54956: LD_ADDR_VAR 0 3
54960: PUSH
54961: LD_VAR 0 3
54965: PUSH
54966: LD_INT 1
54968: PLUS
54969: ST_TO_ADDR
// for i in tmp do
54970: LD_ADDR_VAR 0 1
54974: PUSH
54975: LD_VAR 0 2
54979: PUSH
54980: FOR_IN
54981: IFFALSE 55012
// if GetLives ( i ) < 1000 then
54983: LD_VAR 0 1
54987: PPUSH
54988: CALL_OW 256
54992: PUSH
54993: LD_INT 1000
54995: LESS
54996: IFFALSE 55010
// SetLives ( i , 1000 ) ;
54998: LD_VAR 0 1
55002: PPUSH
55003: LD_INT 1000
55005: PPUSH
55006: CALL_OW 234
55010: GO 54980
55012: POP
55013: POP
// until p > 20 ;
55014: LD_VAR 0 3
55018: PUSH
55019: LD_INT 20
55021: GREATER
55022: IFFALSE 54949
// end ;
55024: PPOPN 3
55026: END
// every 0 0$1 trigger StreamModeActive and sTime do
55027: LD_EXP 92
55031: PUSH
55032: LD_EXP 143
55036: AND
55037: IFFALSE 55072
55039: GO 55041
55041: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55042: LD_INT 28
55044: PPUSH
55045: LD_OWVAR 2
55049: PPUSH
55050: LD_INT 2
55052: PPUSH
55053: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55057: LD_INT 30
55059: PPUSH
55060: LD_OWVAR 2
55064: PPUSH
55065: LD_INT 2
55067: PPUSH
55068: CALL_OW 322
// end ;
55072: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55073: LD_EXP 92
55077: PUSH
55078: LD_EXP 144
55082: AND
55083: IFFALSE 55204
55085: GO 55087
55087: DISABLE
55088: LD_INT 0
55090: PPUSH
55091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55092: LD_ADDR_VAR 0 2
55096: PUSH
55097: LD_INT 22
55099: PUSH
55100: LD_OWVAR 2
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: PUSH
55109: LD_INT 21
55111: PUSH
55112: LD_INT 1
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: PUSH
55119: LD_INT 3
55121: PUSH
55122: LD_INT 23
55124: PUSH
55125: LD_INT 0
55127: PUSH
55128: EMPTY
55129: LIST
55130: LIST
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: LIST
55140: PPUSH
55141: CALL_OW 69
55145: ST_TO_ADDR
// if not tmp then
55146: LD_VAR 0 2
55150: NOT
55151: IFFALSE 55155
// exit ;
55153: GO 55204
// for i in tmp do
55155: LD_ADDR_VAR 0 1
55159: PUSH
55160: LD_VAR 0 2
55164: PUSH
55165: FOR_IN
55166: IFFALSE 55202
// begin if Crawls ( i ) then
55168: LD_VAR 0 1
55172: PPUSH
55173: CALL_OW 318
55177: IFFALSE 55188
// ComWalk ( i ) ;
55179: LD_VAR 0 1
55183: PPUSH
55184: CALL_OW 138
// SetClass ( i , 2 ) ;
55188: LD_VAR 0 1
55192: PPUSH
55193: LD_INT 2
55195: PPUSH
55196: CALL_OW 336
// end ;
55200: GO 55165
55202: POP
55203: POP
// end ;
55204: PPOPN 2
55206: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55207: LD_EXP 92
55211: PUSH
55212: LD_EXP 145
55216: AND
55217: IFFALSE 55505
55219: GO 55221
55221: DISABLE
55222: LD_INT 0
55224: PPUSH
55225: PPUSH
55226: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55227: LD_OWVAR 2
55231: PPUSH
55232: LD_INT 9
55234: PPUSH
55235: LD_INT 1
55237: PPUSH
55238: LD_INT 1
55240: PPUSH
55241: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55245: LD_INT 9
55247: PPUSH
55248: LD_OWVAR 2
55252: PPUSH
55253: CALL_OW 343
// uc_side := 9 ;
55257: LD_ADDR_OWVAR 20
55261: PUSH
55262: LD_INT 9
55264: ST_TO_ADDR
// uc_nation := 2 ;
55265: LD_ADDR_OWVAR 21
55269: PUSH
55270: LD_INT 2
55272: ST_TO_ADDR
// hc_name := Dark Warrior ;
55273: LD_ADDR_OWVAR 26
55277: PUSH
55278: LD_STRING Dark Warrior
55280: ST_TO_ADDR
// hc_gallery :=  ;
55281: LD_ADDR_OWVAR 33
55285: PUSH
55286: LD_STRING 
55288: ST_TO_ADDR
// hc_noskilllimit := true ;
55289: LD_ADDR_OWVAR 76
55293: PUSH
55294: LD_INT 1
55296: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55297: LD_ADDR_OWVAR 31
55301: PUSH
55302: LD_INT 30
55304: PUSH
55305: LD_INT 30
55307: PUSH
55308: LD_INT 30
55310: PUSH
55311: LD_INT 30
55313: PUSH
55314: EMPTY
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: ST_TO_ADDR
// un := CreateHuman ;
55320: LD_ADDR_VAR 0 3
55324: PUSH
55325: CALL_OW 44
55329: ST_TO_ADDR
// hc_noskilllimit := false ;
55330: LD_ADDR_OWVAR 76
55334: PUSH
55335: LD_INT 0
55337: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55338: LD_VAR 0 3
55342: PPUSH
55343: LD_INT 1
55345: PPUSH
55346: CALL_OW 51
// ToLua ( playRanger() ) ;
55350: LD_STRING playRanger()
55352: PPUSH
55353: CALL_OW 559
// p := 0 ;
55357: LD_ADDR_VAR 0 2
55361: PUSH
55362: LD_INT 0
55364: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55365: LD_INT 35
55367: PPUSH
55368: CALL_OW 67
// p := p + 1 ;
55372: LD_ADDR_VAR 0 2
55376: PUSH
55377: LD_VAR 0 2
55381: PUSH
55382: LD_INT 1
55384: PLUS
55385: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55386: LD_VAR 0 3
55390: PPUSH
55391: CALL_OW 256
55395: PUSH
55396: LD_INT 1000
55398: LESS
55399: IFFALSE 55413
// SetLives ( un , 1000 ) ;
55401: LD_VAR 0 3
55405: PPUSH
55406: LD_INT 1000
55408: PPUSH
55409: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55413: LD_VAR 0 3
55417: PPUSH
55418: LD_INT 81
55420: PUSH
55421: LD_OWVAR 2
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PUSH
55430: LD_INT 91
55432: PUSH
55433: LD_VAR 0 3
55437: PUSH
55438: LD_INT 30
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: LIST
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PPUSH
55450: CALL_OW 69
55454: PPUSH
55455: LD_VAR 0 3
55459: PPUSH
55460: CALL_OW 74
55464: PPUSH
55465: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55469: LD_VAR 0 2
55473: PUSH
55474: LD_INT 80
55476: GREATER
55477: PUSH
55478: LD_VAR 0 3
55482: PPUSH
55483: CALL_OW 301
55487: OR
55488: IFFALSE 55365
// if un then
55490: LD_VAR 0 3
55494: IFFALSE 55505
// RemoveUnit ( un ) ;
55496: LD_VAR 0 3
55500: PPUSH
55501: CALL_OW 64
// end ;
55505: PPOPN 3
55507: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55508: LD_EXP 146
55512: IFFALSE 55628
55514: GO 55516
55516: DISABLE
55517: LD_INT 0
55519: PPUSH
55520: PPUSH
55521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55522: LD_ADDR_VAR 0 2
55526: PUSH
55527: LD_INT 81
55529: PUSH
55530: LD_OWVAR 2
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: PUSH
55539: LD_INT 21
55541: PUSH
55542: LD_INT 1
55544: PUSH
55545: EMPTY
55546: LIST
55547: LIST
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: PPUSH
55553: CALL_OW 69
55557: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55558: LD_STRING playComputer()
55560: PPUSH
55561: CALL_OW 559
// if not tmp then
55565: LD_VAR 0 2
55569: NOT
55570: IFFALSE 55574
// exit ;
55572: GO 55628
// for i in tmp do
55574: LD_ADDR_VAR 0 1
55578: PUSH
55579: LD_VAR 0 2
55583: PUSH
55584: FOR_IN
55585: IFFALSE 55626
// for j := 1 to 4 do
55587: LD_ADDR_VAR 0 3
55591: PUSH
55592: DOUBLE
55593: LD_INT 1
55595: DEC
55596: ST_TO_ADDR
55597: LD_INT 4
55599: PUSH
55600: FOR_TO
55601: IFFALSE 55622
// SetSkill ( i , j , 10 ) ;
55603: LD_VAR 0 1
55607: PPUSH
55608: LD_VAR 0 3
55612: PPUSH
55613: LD_INT 10
55615: PPUSH
55616: CALL_OW 237
55620: GO 55600
55622: POP
55623: POP
55624: GO 55584
55626: POP
55627: POP
// end ;
55628: PPOPN 3
55630: END
// every 0 0$1 trigger s30 do var i , tmp ;
55631: LD_EXP 147
55635: IFFALSE 55704
55637: GO 55639
55639: DISABLE
55640: LD_INT 0
55642: PPUSH
55643: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55644: LD_ADDR_VAR 0 2
55648: PUSH
55649: LD_INT 22
55651: PUSH
55652: LD_OWVAR 2
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: PPUSH
55661: CALL_OW 69
55665: ST_TO_ADDR
// if not tmp then
55666: LD_VAR 0 2
55670: NOT
55671: IFFALSE 55675
// exit ;
55673: GO 55704
// for i in tmp do
55675: LD_ADDR_VAR 0 1
55679: PUSH
55680: LD_VAR 0 2
55684: PUSH
55685: FOR_IN
55686: IFFALSE 55702
// SetLives ( i , 300 ) ;
55688: LD_VAR 0 1
55692: PPUSH
55693: LD_INT 300
55695: PPUSH
55696: CALL_OW 234
55700: GO 55685
55702: POP
55703: POP
// end ;
55704: PPOPN 2
55706: END
// every 0 0$1 trigger s60 do var i , tmp ;
55707: LD_EXP 148
55711: IFFALSE 55780
55713: GO 55715
55715: DISABLE
55716: LD_INT 0
55718: PPUSH
55719: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55720: LD_ADDR_VAR 0 2
55724: PUSH
55725: LD_INT 22
55727: PUSH
55728: LD_OWVAR 2
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: PPUSH
55737: CALL_OW 69
55741: ST_TO_ADDR
// if not tmp then
55742: LD_VAR 0 2
55746: NOT
55747: IFFALSE 55751
// exit ;
55749: GO 55780
// for i in tmp do
55751: LD_ADDR_VAR 0 1
55755: PUSH
55756: LD_VAR 0 2
55760: PUSH
55761: FOR_IN
55762: IFFALSE 55778
// SetLives ( i , 600 ) ;
55764: LD_VAR 0 1
55768: PPUSH
55769: LD_INT 600
55771: PPUSH
55772: CALL_OW 234
55776: GO 55761
55778: POP
55779: POP
// end ;
55780: PPOPN 2
55782: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55783: LD_INT 0
55785: PPUSH
// case cmd of 301 :
55786: LD_VAR 0 1
55790: PUSH
55791: LD_INT 301
55793: DOUBLE
55794: EQUAL
55795: IFTRUE 55799
55797: GO 55831
55799: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55800: LD_VAR 0 6
55804: PPUSH
55805: LD_VAR 0 7
55809: PPUSH
55810: LD_VAR 0 8
55814: PPUSH
55815: LD_VAR 0 4
55819: PPUSH
55820: LD_VAR 0 5
55824: PPUSH
55825: CALL 57032 0 5
55829: GO 55952
55831: LD_INT 302
55833: DOUBLE
55834: EQUAL
55835: IFTRUE 55839
55837: GO 55876
55839: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55840: LD_VAR 0 6
55844: PPUSH
55845: LD_VAR 0 7
55849: PPUSH
55850: LD_VAR 0 8
55854: PPUSH
55855: LD_VAR 0 9
55859: PPUSH
55860: LD_VAR 0 4
55864: PPUSH
55865: LD_VAR 0 5
55869: PPUSH
55870: CALL 57123 0 6
55874: GO 55952
55876: LD_INT 303
55878: DOUBLE
55879: EQUAL
55880: IFTRUE 55884
55882: GO 55921
55884: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55885: LD_VAR 0 6
55889: PPUSH
55890: LD_VAR 0 7
55894: PPUSH
55895: LD_VAR 0 8
55899: PPUSH
55900: LD_VAR 0 9
55904: PPUSH
55905: LD_VAR 0 4
55909: PPUSH
55910: LD_VAR 0 5
55914: PPUSH
55915: CALL 55957 0 6
55919: GO 55952
55921: LD_INT 304
55923: DOUBLE
55924: EQUAL
55925: IFTRUE 55929
55927: GO 55951
55929: POP
// hHackTeleport ( unit , x , y ) ; end ;
55930: LD_VAR 0 2
55934: PPUSH
55935: LD_VAR 0 4
55939: PPUSH
55940: LD_VAR 0 5
55944: PPUSH
55945: CALL 57716 0 3
55949: GO 55952
55951: POP
// end ;
55952: LD_VAR 0 12
55956: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55957: LD_INT 0
55959: PPUSH
55960: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55961: LD_VAR 0 1
55965: PUSH
55966: LD_INT 1
55968: LESS
55969: PUSH
55970: LD_VAR 0 1
55974: PUSH
55975: LD_INT 3
55977: GREATER
55978: OR
55979: PUSH
55980: LD_VAR 0 5
55984: PPUSH
55985: LD_VAR 0 6
55989: PPUSH
55990: CALL_OW 428
55994: OR
55995: IFFALSE 55999
// exit ;
55997: GO 56719
// uc_side := your_side ;
55999: LD_ADDR_OWVAR 20
56003: PUSH
56004: LD_OWVAR 2
56008: ST_TO_ADDR
// uc_nation := nation ;
56009: LD_ADDR_OWVAR 21
56013: PUSH
56014: LD_VAR 0 1
56018: ST_TO_ADDR
// bc_level = 1 ;
56019: LD_ADDR_OWVAR 43
56023: PUSH
56024: LD_INT 1
56026: ST_TO_ADDR
// case btype of 1 :
56027: LD_VAR 0 2
56031: PUSH
56032: LD_INT 1
56034: DOUBLE
56035: EQUAL
56036: IFTRUE 56040
56038: GO 56051
56040: POP
// bc_type := b_depot ; 2 :
56041: LD_ADDR_OWVAR 42
56045: PUSH
56046: LD_INT 0
56048: ST_TO_ADDR
56049: GO 56663
56051: LD_INT 2
56053: DOUBLE
56054: EQUAL
56055: IFTRUE 56059
56057: GO 56070
56059: POP
// bc_type := b_warehouse ; 3 :
56060: LD_ADDR_OWVAR 42
56064: PUSH
56065: LD_INT 1
56067: ST_TO_ADDR
56068: GO 56663
56070: LD_INT 3
56072: DOUBLE
56073: EQUAL
56074: IFTRUE 56078
56076: GO 56089
56078: POP
// bc_type := b_lab ; 4 .. 9 :
56079: LD_ADDR_OWVAR 42
56083: PUSH
56084: LD_INT 6
56086: ST_TO_ADDR
56087: GO 56663
56089: LD_INT 4
56091: DOUBLE
56092: GREATEREQUAL
56093: IFFALSE 56101
56095: LD_INT 9
56097: DOUBLE
56098: LESSEQUAL
56099: IFTRUE 56103
56101: GO 56155
56103: POP
// begin bc_type := b_lab_half ;
56104: LD_ADDR_OWVAR 42
56108: PUSH
56109: LD_INT 7
56111: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56112: LD_ADDR_OWVAR 44
56116: PUSH
56117: LD_INT 10
56119: PUSH
56120: LD_INT 11
56122: PUSH
56123: LD_INT 12
56125: PUSH
56126: LD_INT 15
56128: PUSH
56129: LD_INT 14
56131: PUSH
56132: LD_INT 13
56134: PUSH
56135: EMPTY
56136: LIST
56137: LIST
56138: LIST
56139: LIST
56140: LIST
56141: LIST
56142: PUSH
56143: LD_VAR 0 2
56147: PUSH
56148: LD_INT 3
56150: MINUS
56151: ARRAY
56152: ST_TO_ADDR
// end ; 10 .. 13 :
56153: GO 56663
56155: LD_INT 10
56157: DOUBLE
56158: GREATEREQUAL
56159: IFFALSE 56167
56161: LD_INT 13
56163: DOUBLE
56164: LESSEQUAL
56165: IFTRUE 56169
56167: GO 56246
56169: POP
// begin bc_type := b_lab_full ;
56170: LD_ADDR_OWVAR 42
56174: PUSH
56175: LD_INT 8
56177: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56178: LD_ADDR_OWVAR 44
56182: PUSH
56183: LD_INT 10
56185: PUSH
56186: LD_INT 12
56188: PUSH
56189: LD_INT 14
56191: PUSH
56192: LD_INT 13
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: LIST
56199: LIST
56200: PUSH
56201: LD_VAR 0 2
56205: PUSH
56206: LD_INT 9
56208: MINUS
56209: ARRAY
56210: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56211: LD_ADDR_OWVAR 45
56215: PUSH
56216: LD_INT 11
56218: PUSH
56219: LD_INT 15
56221: PUSH
56222: LD_INT 12
56224: PUSH
56225: LD_INT 15
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: PUSH
56234: LD_VAR 0 2
56238: PUSH
56239: LD_INT 9
56241: MINUS
56242: ARRAY
56243: ST_TO_ADDR
// end ; 14 :
56244: GO 56663
56246: LD_INT 14
56248: DOUBLE
56249: EQUAL
56250: IFTRUE 56254
56252: GO 56265
56254: POP
// bc_type := b_workshop ; 15 :
56255: LD_ADDR_OWVAR 42
56259: PUSH
56260: LD_INT 2
56262: ST_TO_ADDR
56263: GO 56663
56265: LD_INT 15
56267: DOUBLE
56268: EQUAL
56269: IFTRUE 56273
56271: GO 56284
56273: POP
// bc_type := b_factory ; 16 :
56274: LD_ADDR_OWVAR 42
56278: PUSH
56279: LD_INT 3
56281: ST_TO_ADDR
56282: GO 56663
56284: LD_INT 16
56286: DOUBLE
56287: EQUAL
56288: IFTRUE 56292
56290: GO 56303
56292: POP
// bc_type := b_ext_gun ; 17 :
56293: LD_ADDR_OWVAR 42
56297: PUSH
56298: LD_INT 17
56300: ST_TO_ADDR
56301: GO 56663
56303: LD_INT 17
56305: DOUBLE
56306: EQUAL
56307: IFTRUE 56311
56309: GO 56339
56311: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56312: LD_ADDR_OWVAR 42
56316: PUSH
56317: LD_INT 19
56319: PUSH
56320: LD_INT 23
56322: PUSH
56323: LD_INT 19
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: LIST
56330: PUSH
56331: LD_VAR 0 1
56335: ARRAY
56336: ST_TO_ADDR
56337: GO 56663
56339: LD_INT 18
56341: DOUBLE
56342: EQUAL
56343: IFTRUE 56347
56345: GO 56358
56347: POP
// bc_type := b_ext_radar ; 19 :
56348: LD_ADDR_OWVAR 42
56352: PUSH
56353: LD_INT 20
56355: ST_TO_ADDR
56356: GO 56663
56358: LD_INT 19
56360: DOUBLE
56361: EQUAL
56362: IFTRUE 56366
56364: GO 56377
56366: POP
// bc_type := b_ext_radio ; 20 :
56367: LD_ADDR_OWVAR 42
56371: PUSH
56372: LD_INT 22
56374: ST_TO_ADDR
56375: GO 56663
56377: LD_INT 20
56379: DOUBLE
56380: EQUAL
56381: IFTRUE 56385
56383: GO 56396
56385: POP
// bc_type := b_ext_siberium ; 21 :
56386: LD_ADDR_OWVAR 42
56390: PUSH
56391: LD_INT 21
56393: ST_TO_ADDR
56394: GO 56663
56396: LD_INT 21
56398: DOUBLE
56399: EQUAL
56400: IFTRUE 56404
56402: GO 56415
56404: POP
// bc_type := b_ext_computer ; 22 :
56405: LD_ADDR_OWVAR 42
56409: PUSH
56410: LD_INT 24
56412: ST_TO_ADDR
56413: GO 56663
56415: LD_INT 22
56417: DOUBLE
56418: EQUAL
56419: IFTRUE 56423
56421: GO 56434
56423: POP
// bc_type := b_ext_track ; 23 :
56424: LD_ADDR_OWVAR 42
56428: PUSH
56429: LD_INT 16
56431: ST_TO_ADDR
56432: GO 56663
56434: LD_INT 23
56436: DOUBLE
56437: EQUAL
56438: IFTRUE 56442
56440: GO 56453
56442: POP
// bc_type := b_ext_laser ; 24 :
56443: LD_ADDR_OWVAR 42
56447: PUSH
56448: LD_INT 25
56450: ST_TO_ADDR
56451: GO 56663
56453: LD_INT 24
56455: DOUBLE
56456: EQUAL
56457: IFTRUE 56461
56459: GO 56472
56461: POP
// bc_type := b_control_tower ; 25 :
56462: LD_ADDR_OWVAR 42
56466: PUSH
56467: LD_INT 36
56469: ST_TO_ADDR
56470: GO 56663
56472: LD_INT 25
56474: DOUBLE
56475: EQUAL
56476: IFTRUE 56480
56478: GO 56491
56480: POP
// bc_type := b_breastwork ; 26 :
56481: LD_ADDR_OWVAR 42
56485: PUSH
56486: LD_INT 31
56488: ST_TO_ADDR
56489: GO 56663
56491: LD_INT 26
56493: DOUBLE
56494: EQUAL
56495: IFTRUE 56499
56497: GO 56510
56499: POP
// bc_type := b_bunker ; 27 :
56500: LD_ADDR_OWVAR 42
56504: PUSH
56505: LD_INT 32
56507: ST_TO_ADDR
56508: GO 56663
56510: LD_INT 27
56512: DOUBLE
56513: EQUAL
56514: IFTRUE 56518
56516: GO 56529
56518: POP
// bc_type := b_turret ; 28 :
56519: LD_ADDR_OWVAR 42
56523: PUSH
56524: LD_INT 33
56526: ST_TO_ADDR
56527: GO 56663
56529: LD_INT 28
56531: DOUBLE
56532: EQUAL
56533: IFTRUE 56537
56535: GO 56548
56537: POP
// bc_type := b_armoury ; 29 :
56538: LD_ADDR_OWVAR 42
56542: PUSH
56543: LD_INT 4
56545: ST_TO_ADDR
56546: GO 56663
56548: LD_INT 29
56550: DOUBLE
56551: EQUAL
56552: IFTRUE 56556
56554: GO 56567
56556: POP
// bc_type := b_barracks ; 30 :
56557: LD_ADDR_OWVAR 42
56561: PUSH
56562: LD_INT 5
56564: ST_TO_ADDR
56565: GO 56663
56567: LD_INT 30
56569: DOUBLE
56570: EQUAL
56571: IFTRUE 56575
56573: GO 56586
56575: POP
// bc_type := b_solar_power ; 31 :
56576: LD_ADDR_OWVAR 42
56580: PUSH
56581: LD_INT 27
56583: ST_TO_ADDR
56584: GO 56663
56586: LD_INT 31
56588: DOUBLE
56589: EQUAL
56590: IFTRUE 56594
56592: GO 56605
56594: POP
// bc_type := b_oil_power ; 32 :
56595: LD_ADDR_OWVAR 42
56599: PUSH
56600: LD_INT 26
56602: ST_TO_ADDR
56603: GO 56663
56605: LD_INT 32
56607: DOUBLE
56608: EQUAL
56609: IFTRUE 56613
56611: GO 56624
56613: POP
// bc_type := b_siberite_power ; 33 :
56614: LD_ADDR_OWVAR 42
56618: PUSH
56619: LD_INT 28
56621: ST_TO_ADDR
56622: GO 56663
56624: LD_INT 33
56626: DOUBLE
56627: EQUAL
56628: IFTRUE 56632
56630: GO 56643
56632: POP
// bc_type := b_oil_mine ; 34 :
56633: LD_ADDR_OWVAR 42
56637: PUSH
56638: LD_INT 29
56640: ST_TO_ADDR
56641: GO 56663
56643: LD_INT 34
56645: DOUBLE
56646: EQUAL
56647: IFTRUE 56651
56649: GO 56662
56651: POP
// bc_type := b_siberite_mine ; end ;
56652: LD_ADDR_OWVAR 42
56656: PUSH
56657: LD_INT 30
56659: ST_TO_ADDR
56660: GO 56663
56662: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56663: LD_ADDR_VAR 0 8
56667: PUSH
56668: LD_VAR 0 5
56672: PPUSH
56673: LD_VAR 0 6
56677: PPUSH
56678: LD_VAR 0 3
56682: PPUSH
56683: CALL_OW 47
56687: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56688: LD_OWVAR 42
56692: PUSH
56693: LD_INT 32
56695: PUSH
56696: LD_INT 33
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: IN
56703: IFFALSE 56719
// PlaceWeaponTurret ( b , weapon ) ;
56705: LD_VAR 0 8
56709: PPUSH
56710: LD_VAR 0 4
56714: PPUSH
56715: CALL_OW 431
// end ;
56719: LD_VAR 0 7
56723: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56724: LD_INT 0
56726: PPUSH
56727: PPUSH
56728: PPUSH
56729: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56730: LD_ADDR_VAR 0 4
56734: PUSH
56735: LD_INT 22
56737: PUSH
56738: LD_OWVAR 2
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PUSH
56747: LD_INT 2
56749: PUSH
56750: LD_INT 30
56752: PUSH
56753: LD_INT 0
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PUSH
56760: LD_INT 30
56762: PUSH
56763: LD_INT 1
56765: PUSH
56766: EMPTY
56767: LIST
56768: LIST
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: LIST
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PPUSH
56779: CALL_OW 69
56783: ST_TO_ADDR
// if not tmp then
56784: LD_VAR 0 4
56788: NOT
56789: IFFALSE 56793
// exit ;
56791: GO 56852
// for i in tmp do
56793: LD_ADDR_VAR 0 2
56797: PUSH
56798: LD_VAR 0 4
56802: PUSH
56803: FOR_IN
56804: IFFALSE 56850
// for j = 1 to 3 do
56806: LD_ADDR_VAR 0 3
56810: PUSH
56811: DOUBLE
56812: LD_INT 1
56814: DEC
56815: ST_TO_ADDR
56816: LD_INT 3
56818: PUSH
56819: FOR_TO
56820: IFFALSE 56846
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56822: LD_VAR 0 2
56826: PPUSH
56827: CALL_OW 274
56831: PPUSH
56832: LD_VAR 0 3
56836: PPUSH
56837: LD_INT 99999
56839: PPUSH
56840: CALL_OW 277
56844: GO 56819
56846: POP
56847: POP
56848: GO 56803
56850: POP
56851: POP
// end ;
56852: LD_VAR 0 1
56856: RET
// export function hHackSetLevel10 ; var i , j ; begin
56857: LD_INT 0
56859: PPUSH
56860: PPUSH
56861: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56862: LD_ADDR_VAR 0 2
56866: PUSH
56867: LD_INT 21
56869: PUSH
56870: LD_INT 1
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PPUSH
56877: CALL_OW 69
56881: PUSH
56882: FOR_IN
56883: IFFALSE 56935
// if IsSelected ( i ) then
56885: LD_VAR 0 2
56889: PPUSH
56890: CALL_OW 306
56894: IFFALSE 56933
// begin for j := 1 to 4 do
56896: LD_ADDR_VAR 0 3
56900: PUSH
56901: DOUBLE
56902: LD_INT 1
56904: DEC
56905: ST_TO_ADDR
56906: LD_INT 4
56908: PUSH
56909: FOR_TO
56910: IFFALSE 56931
// SetSkill ( i , j , 10 ) ;
56912: LD_VAR 0 2
56916: PPUSH
56917: LD_VAR 0 3
56921: PPUSH
56922: LD_INT 10
56924: PPUSH
56925: CALL_OW 237
56929: GO 56909
56931: POP
56932: POP
// end ;
56933: GO 56882
56935: POP
56936: POP
// end ;
56937: LD_VAR 0 1
56941: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56942: LD_INT 0
56944: PPUSH
56945: PPUSH
56946: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56947: LD_ADDR_VAR 0 2
56951: PUSH
56952: LD_INT 22
56954: PUSH
56955: LD_OWVAR 2
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: PUSH
56964: LD_INT 21
56966: PUSH
56967: LD_INT 1
56969: PUSH
56970: EMPTY
56971: LIST
56972: LIST
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: PPUSH
56978: CALL_OW 69
56982: PUSH
56983: FOR_IN
56984: IFFALSE 57025
// begin for j := 1 to 4 do
56986: LD_ADDR_VAR 0 3
56990: PUSH
56991: DOUBLE
56992: LD_INT 1
56994: DEC
56995: ST_TO_ADDR
56996: LD_INT 4
56998: PUSH
56999: FOR_TO
57000: IFFALSE 57021
// SetSkill ( i , j , 10 ) ;
57002: LD_VAR 0 2
57006: PPUSH
57007: LD_VAR 0 3
57011: PPUSH
57012: LD_INT 10
57014: PPUSH
57015: CALL_OW 237
57019: GO 56999
57021: POP
57022: POP
// end ;
57023: GO 56983
57025: POP
57026: POP
// end ;
57027: LD_VAR 0 1
57031: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57032: LD_INT 0
57034: PPUSH
// uc_side := your_side ;
57035: LD_ADDR_OWVAR 20
57039: PUSH
57040: LD_OWVAR 2
57044: ST_TO_ADDR
// uc_nation := nation ;
57045: LD_ADDR_OWVAR 21
57049: PUSH
57050: LD_VAR 0 1
57054: ST_TO_ADDR
// InitHc ;
57055: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57059: LD_INT 0
57061: PPUSH
57062: LD_VAR 0 2
57066: PPUSH
57067: LD_VAR 0 3
57071: PPUSH
57072: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57076: LD_VAR 0 4
57080: PPUSH
57081: LD_VAR 0 5
57085: PPUSH
57086: CALL_OW 428
57090: PUSH
57091: LD_INT 0
57093: EQUAL
57094: IFFALSE 57118
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57096: CALL_OW 44
57100: PPUSH
57101: LD_VAR 0 4
57105: PPUSH
57106: LD_VAR 0 5
57110: PPUSH
57111: LD_INT 1
57113: PPUSH
57114: CALL_OW 48
// end ;
57118: LD_VAR 0 6
57122: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57123: LD_INT 0
57125: PPUSH
57126: PPUSH
// uc_side := your_side ;
57127: LD_ADDR_OWVAR 20
57131: PUSH
57132: LD_OWVAR 2
57136: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57137: LD_VAR 0 1
57141: PUSH
57142: LD_INT 1
57144: PUSH
57145: LD_INT 2
57147: PUSH
57148: LD_INT 3
57150: PUSH
57151: LD_INT 4
57153: PUSH
57154: LD_INT 5
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: LIST
57161: LIST
57162: LIST
57163: IN
57164: IFFALSE 57176
// uc_nation := nation_american else
57166: LD_ADDR_OWVAR 21
57170: PUSH
57171: LD_INT 1
57173: ST_TO_ADDR
57174: GO 57219
// if chassis in [ 11 , 12 , 13 , 14 ] then
57176: LD_VAR 0 1
57180: PUSH
57181: LD_INT 11
57183: PUSH
57184: LD_INT 12
57186: PUSH
57187: LD_INT 13
57189: PUSH
57190: LD_INT 14
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: LIST
57197: LIST
57198: IN
57199: IFFALSE 57211
// uc_nation := nation_arabian else
57201: LD_ADDR_OWVAR 21
57205: PUSH
57206: LD_INT 2
57208: ST_TO_ADDR
57209: GO 57219
// uc_nation := nation_russian ;
57211: LD_ADDR_OWVAR 21
57215: PUSH
57216: LD_INT 3
57218: ST_TO_ADDR
// vc_chassis := chassis ;
57219: LD_ADDR_OWVAR 37
57223: PUSH
57224: LD_VAR 0 1
57228: ST_TO_ADDR
// vc_engine := engine ;
57229: LD_ADDR_OWVAR 39
57233: PUSH
57234: LD_VAR 0 2
57238: ST_TO_ADDR
// vc_control := control ;
57239: LD_ADDR_OWVAR 38
57243: PUSH
57244: LD_VAR 0 3
57248: ST_TO_ADDR
// vc_weapon := weapon ;
57249: LD_ADDR_OWVAR 40
57253: PUSH
57254: LD_VAR 0 4
57258: ST_TO_ADDR
// un := CreateVehicle ;
57259: LD_ADDR_VAR 0 8
57263: PUSH
57264: CALL_OW 45
57268: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57269: LD_VAR 0 8
57273: PPUSH
57274: LD_INT 0
57276: PPUSH
57277: LD_INT 5
57279: PPUSH
57280: CALL_OW 12
57284: PPUSH
57285: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57289: LD_VAR 0 8
57293: PPUSH
57294: LD_VAR 0 5
57298: PPUSH
57299: LD_VAR 0 6
57303: PPUSH
57304: LD_INT 1
57306: PPUSH
57307: CALL_OW 48
// end ;
57311: LD_VAR 0 7
57315: RET
// export hInvincible ; every 1 do
57316: GO 57318
57318: DISABLE
// hInvincible := [ ] ;
57319: LD_ADDR_EXP 149
57323: PUSH
57324: EMPTY
57325: ST_TO_ADDR
57326: END
// every 10 do var i ;
57327: GO 57329
57329: DISABLE
57330: LD_INT 0
57332: PPUSH
// begin enable ;
57333: ENABLE
// if not hInvincible then
57334: LD_EXP 149
57338: NOT
57339: IFFALSE 57343
// exit ;
57341: GO 57387
// for i in hInvincible do
57343: LD_ADDR_VAR 0 1
57347: PUSH
57348: LD_EXP 149
57352: PUSH
57353: FOR_IN
57354: IFFALSE 57385
// if GetLives ( i ) < 1000 then
57356: LD_VAR 0 1
57360: PPUSH
57361: CALL_OW 256
57365: PUSH
57366: LD_INT 1000
57368: LESS
57369: IFFALSE 57383
// SetLives ( i , 1000 ) ;
57371: LD_VAR 0 1
57375: PPUSH
57376: LD_INT 1000
57378: PPUSH
57379: CALL_OW 234
57383: GO 57353
57385: POP
57386: POP
// end ;
57387: PPOPN 1
57389: END
// export function hHackInvincible ; var i ; begin
57390: LD_INT 0
57392: PPUSH
57393: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57394: LD_ADDR_VAR 0 2
57398: PUSH
57399: LD_INT 2
57401: PUSH
57402: LD_INT 21
57404: PUSH
57405: LD_INT 1
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: PUSH
57412: LD_INT 21
57414: PUSH
57415: LD_INT 2
57417: PUSH
57418: EMPTY
57419: LIST
57420: LIST
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: LIST
57426: PPUSH
57427: CALL_OW 69
57431: PUSH
57432: FOR_IN
57433: IFFALSE 57494
// if IsSelected ( i ) then
57435: LD_VAR 0 2
57439: PPUSH
57440: CALL_OW 306
57444: IFFALSE 57492
// begin if i in hInvincible then
57446: LD_VAR 0 2
57450: PUSH
57451: LD_EXP 149
57455: IN
57456: IFFALSE 57476
// hInvincible := hInvincible diff i else
57458: LD_ADDR_EXP 149
57462: PUSH
57463: LD_EXP 149
57467: PUSH
57468: LD_VAR 0 2
57472: DIFF
57473: ST_TO_ADDR
57474: GO 57492
// hInvincible := hInvincible union i ;
57476: LD_ADDR_EXP 149
57480: PUSH
57481: LD_EXP 149
57485: PUSH
57486: LD_VAR 0 2
57490: UNION
57491: ST_TO_ADDR
// end ;
57492: GO 57432
57494: POP
57495: POP
// end ;
57496: LD_VAR 0 1
57500: RET
// export function hHackInvisible ; var i , j ; begin
57501: LD_INT 0
57503: PPUSH
57504: PPUSH
57505: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57506: LD_ADDR_VAR 0 2
57510: PUSH
57511: LD_INT 21
57513: PUSH
57514: LD_INT 1
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: PPUSH
57521: CALL_OW 69
57525: PUSH
57526: FOR_IN
57527: IFFALSE 57551
// if IsSelected ( i ) then
57529: LD_VAR 0 2
57533: PPUSH
57534: CALL_OW 306
57538: IFFALSE 57549
// ComForceInvisible ( i ) ;
57540: LD_VAR 0 2
57544: PPUSH
57545: CALL_OW 496
57549: GO 57526
57551: POP
57552: POP
// end ;
57553: LD_VAR 0 1
57557: RET
// export function hHackChangeYourSide ; begin
57558: LD_INT 0
57560: PPUSH
// if your_side = 8 then
57561: LD_OWVAR 2
57565: PUSH
57566: LD_INT 8
57568: EQUAL
57569: IFFALSE 57581
// your_side := 0 else
57571: LD_ADDR_OWVAR 2
57575: PUSH
57576: LD_INT 0
57578: ST_TO_ADDR
57579: GO 57595
// your_side := your_side + 1 ;
57581: LD_ADDR_OWVAR 2
57585: PUSH
57586: LD_OWVAR 2
57590: PUSH
57591: LD_INT 1
57593: PLUS
57594: ST_TO_ADDR
// end ;
57595: LD_VAR 0 1
57599: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57600: LD_INT 0
57602: PPUSH
57603: PPUSH
57604: PPUSH
// for i in all_units do
57605: LD_ADDR_VAR 0 2
57609: PUSH
57610: LD_OWVAR 3
57614: PUSH
57615: FOR_IN
57616: IFFALSE 57694
// if IsSelected ( i ) then
57618: LD_VAR 0 2
57622: PPUSH
57623: CALL_OW 306
57627: IFFALSE 57692
// begin j := GetSide ( i ) ;
57629: LD_ADDR_VAR 0 3
57633: PUSH
57634: LD_VAR 0 2
57638: PPUSH
57639: CALL_OW 255
57643: ST_TO_ADDR
// if j = 8 then
57644: LD_VAR 0 3
57648: PUSH
57649: LD_INT 8
57651: EQUAL
57652: IFFALSE 57664
// j := 0 else
57654: LD_ADDR_VAR 0 3
57658: PUSH
57659: LD_INT 0
57661: ST_TO_ADDR
57662: GO 57678
// j := j + 1 ;
57664: LD_ADDR_VAR 0 3
57668: PUSH
57669: LD_VAR 0 3
57673: PUSH
57674: LD_INT 1
57676: PLUS
57677: ST_TO_ADDR
// SetSide ( i , j ) ;
57678: LD_VAR 0 2
57682: PPUSH
57683: LD_VAR 0 3
57687: PPUSH
57688: CALL_OW 235
// end ;
57692: GO 57615
57694: POP
57695: POP
// end ;
57696: LD_VAR 0 1
57700: RET
// export function hHackFog ; begin
57701: LD_INT 0
57703: PPUSH
// FogOff ( true ) ;
57704: LD_INT 1
57706: PPUSH
57707: CALL_OW 344
// end ;
57711: LD_VAR 0 1
57715: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57716: LD_INT 0
57718: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57719: LD_VAR 0 1
57723: PPUSH
57724: LD_VAR 0 2
57728: PPUSH
57729: LD_VAR 0 3
57733: PPUSH
57734: LD_INT 1
57736: PPUSH
57737: LD_INT 1
57739: PPUSH
57740: CALL_OW 483
// CenterOnXY ( x , y ) ;
57744: LD_VAR 0 2
57748: PPUSH
57749: LD_VAR 0 3
57753: PPUSH
57754: CALL_OW 84
// end ; end_of_file
57758: LD_VAR 0 4
57762: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
57763: LD_INT 0
57765: PPUSH
57766: PPUSH
57767: PPUSH
57768: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
57769: LD_VAR 0 1
57773: PPUSH
57774: CALL_OW 264
57778: PUSH
57779: LD_EXP 77
57783: EQUAL
57784: IFFALSE 57856
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
57786: LD_INT 68
57788: PPUSH
57789: LD_VAR 0 1
57793: PPUSH
57794: CALL_OW 255
57798: PPUSH
57799: CALL_OW 321
57803: PUSH
57804: LD_INT 2
57806: EQUAL
57807: IFFALSE 57819
// eff := 70 else
57809: LD_ADDR_VAR 0 4
57813: PUSH
57814: LD_INT 70
57816: ST_TO_ADDR
57817: GO 57827
// eff := 30 ;
57819: LD_ADDR_VAR 0 4
57823: PUSH
57824: LD_INT 30
57826: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
57827: LD_VAR 0 1
57831: PPUSH
57832: CALL_OW 250
57836: PPUSH
57837: LD_VAR 0 1
57841: PPUSH
57842: CALL_OW 251
57846: PPUSH
57847: LD_VAR 0 4
57851: PPUSH
57852: CALL_OW 495
// end ; end ;
57856: LD_VAR 0 2
57860: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
57861: LD_INT 0
57863: PPUSH
// end ;
57864: LD_VAR 0 4
57868: RET
// export function SOS_Command ( cmd ) ; begin
57869: LD_INT 0
57871: PPUSH
// end ;
57872: LD_VAR 0 2
57876: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
57877: LD_INT 0
57879: PPUSH
// end ;
57880: LD_VAR 0 6
57884: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
57885: LD_INT 0
57887: PPUSH
57888: PPUSH
// if not vehicle or not factory then
57889: LD_VAR 0 1
57893: NOT
57894: PUSH
57895: LD_VAR 0 2
57899: NOT
57900: OR
57901: IFFALSE 57905
// exit ;
57903: GO 58136
// if factoryWaypoints >= factory then
57905: LD_EXP 150
57909: PUSH
57910: LD_VAR 0 2
57914: GREATEREQUAL
57915: IFFALSE 58136
// if factoryWaypoints [ factory ] then
57917: LD_EXP 150
57921: PUSH
57922: LD_VAR 0 2
57926: ARRAY
57927: IFFALSE 58136
// begin if GetControl ( vehicle ) = control_manual then
57929: LD_VAR 0 1
57933: PPUSH
57934: CALL_OW 263
57938: PUSH
57939: LD_INT 1
57941: EQUAL
57942: IFFALSE 58023
// begin driver := IsDrivenBy ( vehicle ) ;
57944: LD_ADDR_VAR 0 4
57948: PUSH
57949: LD_VAR 0 1
57953: PPUSH
57954: CALL_OW 311
57958: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
57959: LD_VAR 0 4
57963: PPUSH
57964: LD_EXP 150
57968: PUSH
57969: LD_VAR 0 2
57973: ARRAY
57974: PUSH
57975: LD_INT 1
57977: ARRAY
57978: PPUSH
57979: LD_EXP 150
57983: PUSH
57984: LD_VAR 0 2
57988: ARRAY
57989: PUSH
57990: LD_INT 2
57992: ARRAY
57993: PPUSH
57994: CALL_OW 171
// AddComExitVehicle ( driver ) ;
57998: LD_VAR 0 4
58002: PPUSH
58003: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
58007: LD_VAR 0 4
58011: PPUSH
58012: LD_VAR 0 2
58016: PPUSH
58017: CALL_OW 180
// end else
58021: GO 58136
// if GetControl ( vehicle ) = control_remote then
58023: LD_VAR 0 1
58027: PPUSH
58028: CALL_OW 263
58032: PUSH
58033: LD_INT 2
58035: EQUAL
58036: IFFALSE 58097
// begin wait ( 0 0$2 ) ;
58038: LD_INT 70
58040: PPUSH
58041: CALL_OW 67
// if Connect ( vehicle ) then
58045: LD_VAR 0 1
58049: PPUSH
58050: CALL 70360 0 1
58054: IFFALSE 58095
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
58056: LD_VAR 0 1
58060: PPUSH
58061: LD_EXP 150
58065: PUSH
58066: LD_VAR 0 2
58070: ARRAY
58071: PUSH
58072: LD_INT 1
58074: ARRAY
58075: PPUSH
58076: LD_EXP 150
58080: PUSH
58081: LD_VAR 0 2
58085: ARRAY
58086: PUSH
58087: LD_INT 2
58089: ARRAY
58090: PPUSH
58091: CALL_OW 171
// end else
58095: GO 58136
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
58097: LD_VAR 0 1
58101: PPUSH
58102: LD_EXP 150
58106: PUSH
58107: LD_VAR 0 2
58111: ARRAY
58112: PUSH
58113: LD_INT 1
58115: ARRAY
58116: PPUSH
58117: LD_EXP 150
58121: PUSH
58122: LD_VAR 0 2
58126: ARRAY
58127: PUSH
58128: LD_INT 2
58130: ARRAY
58131: PPUSH
58132: CALL_OW 171
// end ; end ;
58136: LD_VAR 0 3
58140: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
58141: LD_INT 0
58143: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
58144: LD_VAR 0 1
58148: PUSH
58149: LD_INT 250
58151: EQUAL
58152: PUSH
58153: LD_VAR 0 2
58157: PPUSH
58158: CALL_OW 264
58162: PUSH
58163: LD_EXP 80
58167: EQUAL
58168: AND
58169: IFFALSE 58190
// MinerPlaceMine ( unit , x , y ) ;
58171: LD_VAR 0 2
58175: PPUSH
58176: LD_VAR 0 4
58180: PPUSH
58181: LD_VAR 0 5
58185: PPUSH
58186: CALL 60918 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
58190: LD_VAR 0 1
58194: PUSH
58195: LD_INT 251
58197: EQUAL
58198: PUSH
58199: LD_VAR 0 2
58203: PPUSH
58204: CALL_OW 264
58208: PUSH
58209: LD_EXP 80
58213: EQUAL
58214: AND
58215: IFFALSE 58236
// MinerDetonateMine ( unit , x , y ) ;
58217: LD_VAR 0 2
58221: PPUSH
58222: LD_VAR 0 4
58226: PPUSH
58227: LD_VAR 0 5
58231: PPUSH
58232: CALL 61195 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
58236: LD_VAR 0 1
58240: PUSH
58241: LD_INT 252
58243: EQUAL
58244: PUSH
58245: LD_VAR 0 2
58249: PPUSH
58250: CALL_OW 264
58254: PUSH
58255: LD_EXP 80
58259: EQUAL
58260: AND
58261: IFFALSE 58282
// MinerCreateMinefield ( unit , x , y ) ;
58263: LD_VAR 0 2
58267: PPUSH
58268: LD_VAR 0 4
58272: PPUSH
58273: LD_VAR 0 5
58277: PPUSH
58278: CALL 61612 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
58282: LD_VAR 0 1
58286: PUSH
58287: LD_INT 253
58289: EQUAL
58290: PUSH
58291: LD_VAR 0 2
58295: PPUSH
58296: CALL_OW 257
58300: PUSH
58301: LD_INT 5
58303: EQUAL
58304: AND
58305: IFFALSE 58326
// ComBinocular ( unit , x , y ) ;
58307: LD_VAR 0 2
58311: PPUSH
58312: LD_VAR 0 4
58316: PPUSH
58317: LD_VAR 0 5
58321: PPUSH
58322: CALL 61983 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
58326: LD_VAR 0 1
58330: PUSH
58331: LD_INT 254
58333: EQUAL
58334: PUSH
58335: LD_VAR 0 2
58339: PPUSH
58340: CALL_OW 264
58344: PUSH
58345: LD_EXP 75
58349: EQUAL
58350: AND
58351: PUSH
58352: LD_VAR 0 3
58356: PPUSH
58357: CALL_OW 263
58361: PUSH
58362: LD_INT 3
58364: EQUAL
58365: AND
58366: IFFALSE 58382
// HackDestroyVehicle ( unit , selectedUnit ) ;
58368: LD_VAR 0 2
58372: PPUSH
58373: LD_VAR 0 3
58377: PPUSH
58378: CALL 60278 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
58382: LD_VAR 0 1
58386: PUSH
58387: LD_INT 255
58389: EQUAL
58390: PUSH
58391: LD_VAR 0 2
58395: PPUSH
58396: CALL_OW 264
58400: PUSH
58401: LD_INT 14
58403: PUSH
58404: LD_INT 53
58406: PUSH
58407: EMPTY
58408: LIST
58409: LIST
58410: IN
58411: AND
58412: PUSH
58413: LD_VAR 0 4
58417: PPUSH
58418: LD_VAR 0 5
58422: PPUSH
58423: CALL_OW 488
58427: AND
58428: IFFALSE 58452
// CutTreeXYR ( unit , x , y , 12 ) ;
58430: LD_VAR 0 2
58434: PPUSH
58435: LD_VAR 0 4
58439: PPUSH
58440: LD_VAR 0 5
58444: PPUSH
58445: LD_INT 12
58447: PPUSH
58448: CALL 58844 0 4
// if cmd = 256 then
58452: LD_VAR 0 1
58456: PUSH
58457: LD_INT 256
58459: EQUAL
58460: IFFALSE 58481
// SetFactoryWaypoint ( unit , x , y ) ;
58462: LD_VAR 0 2
58466: PPUSH
58467: LD_VAR 0 4
58471: PPUSH
58472: LD_VAR 0 5
58476: PPUSH
58477: CALL 58486 0 3
// end ;
58481: LD_VAR 0 6
58485: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
58486: LD_INT 0
58488: PPUSH
58489: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
58490: LD_VAR 0 1
58494: NOT
58495: PUSH
58496: LD_VAR 0 2
58500: PPUSH
58501: LD_VAR 0 3
58505: PPUSH
58506: CALL_OW 488
58510: NOT
58511: OR
58512: PUSH
58513: LD_VAR 0 1
58517: PPUSH
58518: CALL_OW 266
58522: PUSH
58523: LD_INT 3
58525: NONEQUAL
58526: PUSH
58527: LD_VAR 0 1
58531: PPUSH
58532: CALL_OW 247
58536: PUSH
58537: LD_INT 1
58539: EQUAL
58540: NOT
58541: AND
58542: OR
58543: IFFALSE 58547
// exit ;
58545: GO 58696
// if GetType ( factory ) = unit_human then
58547: LD_VAR 0 1
58551: PPUSH
58552: CALL_OW 247
58556: PUSH
58557: LD_INT 1
58559: EQUAL
58560: IFFALSE 58577
// factory := IsInUnit ( factory ) ;
58562: LD_ADDR_VAR 0 1
58566: PUSH
58567: LD_VAR 0 1
58571: PPUSH
58572: CALL_OW 310
58576: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
58577: LD_VAR 0 1
58581: PPUSH
58582: CALL_OW 266
58586: PUSH
58587: LD_INT 3
58589: NONEQUAL
58590: IFFALSE 58594
// exit ;
58592: GO 58696
// if HexInfo ( x , y ) = factory then
58594: LD_VAR 0 2
58598: PPUSH
58599: LD_VAR 0 3
58603: PPUSH
58604: CALL_OW 428
58608: PUSH
58609: LD_VAR 0 1
58613: EQUAL
58614: IFFALSE 58641
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
58616: LD_ADDR_EXP 150
58620: PUSH
58621: LD_EXP 150
58625: PPUSH
58626: LD_VAR 0 1
58630: PPUSH
58631: LD_INT 0
58633: PPUSH
58634: CALL_OW 1
58638: ST_TO_ADDR
58639: GO 58692
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
58641: LD_ADDR_EXP 150
58645: PUSH
58646: LD_EXP 150
58650: PPUSH
58651: LD_VAR 0 1
58655: PPUSH
58656: LD_VAR 0 1
58660: PPUSH
58661: CALL_OW 255
58665: PUSH
58666: LD_VAR 0 1
58670: PUSH
58671: LD_VAR 0 2
58675: PUSH
58676: LD_VAR 0 3
58680: PUSH
58681: EMPTY
58682: LIST
58683: LIST
58684: LIST
58685: LIST
58686: PPUSH
58687: CALL_OW 1
58691: ST_TO_ADDR
// UpdateFactoryWaypoints ;
58692: CALL 58701 0 0
// end ;
58696: LD_VAR 0 4
58700: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
58701: LD_INT 0
58703: PPUSH
58704: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
58705: LD_STRING resetFactoryWaypoint();
58707: PPUSH
58708: CALL_OW 559
// if factoryWaypoints then
58712: LD_EXP 150
58716: IFFALSE 58839
// begin for i := 1 to factoryWaypoints do
58718: LD_ADDR_VAR 0 2
58722: PUSH
58723: DOUBLE
58724: LD_INT 1
58726: DEC
58727: ST_TO_ADDR
58728: LD_EXP 150
58732: PUSH
58733: FOR_TO
58734: IFFALSE 58837
// if factoryWaypoints [ i ] then
58736: LD_EXP 150
58740: PUSH
58741: LD_VAR 0 2
58745: ARRAY
58746: IFFALSE 58835
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
58748: LD_STRING setFactoryWaypointXY(
58750: PUSH
58751: LD_EXP 150
58755: PUSH
58756: LD_VAR 0 2
58760: ARRAY
58761: PUSH
58762: LD_INT 1
58764: ARRAY
58765: STR
58766: PUSH
58767: LD_STRING ,
58769: STR
58770: PUSH
58771: LD_EXP 150
58775: PUSH
58776: LD_VAR 0 2
58780: ARRAY
58781: PUSH
58782: LD_INT 2
58784: ARRAY
58785: STR
58786: PUSH
58787: LD_STRING ,
58789: STR
58790: PUSH
58791: LD_EXP 150
58795: PUSH
58796: LD_VAR 0 2
58800: ARRAY
58801: PUSH
58802: LD_INT 3
58804: ARRAY
58805: STR
58806: PUSH
58807: LD_STRING ,
58809: STR
58810: PUSH
58811: LD_EXP 150
58815: PUSH
58816: LD_VAR 0 2
58820: ARRAY
58821: PUSH
58822: LD_INT 4
58824: ARRAY
58825: STR
58826: PUSH
58827: LD_STRING )
58829: STR
58830: PPUSH
58831: CALL_OW 559
58835: GO 58733
58837: POP
58838: POP
// end ; end ;
58839: LD_VAR 0 1
58843: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
58844: LD_INT 0
58846: PPUSH
58847: PPUSH
58848: PPUSH
58849: PPUSH
58850: PPUSH
58851: PPUSH
58852: PPUSH
58853: PPUSH
58854: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
58855: LD_VAR 0 1
58859: NOT
58860: PUSH
58861: LD_VAR 0 2
58865: PPUSH
58866: LD_VAR 0 3
58870: PPUSH
58871: CALL_OW 488
58875: NOT
58876: OR
58877: PUSH
58878: LD_VAR 0 4
58882: NOT
58883: OR
58884: IFFALSE 58888
// exit ;
58886: GO 59228
// list := [ ] ;
58888: LD_ADDR_VAR 0 13
58892: PUSH
58893: EMPTY
58894: ST_TO_ADDR
// if x - r < 0 then
58895: LD_VAR 0 2
58899: PUSH
58900: LD_VAR 0 4
58904: MINUS
58905: PUSH
58906: LD_INT 0
58908: LESS
58909: IFFALSE 58921
// min_x := 0 else
58911: LD_ADDR_VAR 0 7
58915: PUSH
58916: LD_INT 0
58918: ST_TO_ADDR
58919: GO 58937
// min_x := x - r ;
58921: LD_ADDR_VAR 0 7
58925: PUSH
58926: LD_VAR 0 2
58930: PUSH
58931: LD_VAR 0 4
58935: MINUS
58936: ST_TO_ADDR
// if y - r < 0 then
58937: LD_VAR 0 3
58941: PUSH
58942: LD_VAR 0 4
58946: MINUS
58947: PUSH
58948: LD_INT 0
58950: LESS
58951: IFFALSE 58963
// min_y := 0 else
58953: LD_ADDR_VAR 0 8
58957: PUSH
58958: LD_INT 0
58960: ST_TO_ADDR
58961: GO 58979
// min_y := y - r ;
58963: LD_ADDR_VAR 0 8
58967: PUSH
58968: LD_VAR 0 3
58972: PUSH
58973: LD_VAR 0 4
58977: MINUS
58978: ST_TO_ADDR
// max_x := x + r ;
58979: LD_ADDR_VAR 0 9
58983: PUSH
58984: LD_VAR 0 2
58988: PUSH
58989: LD_VAR 0 4
58993: PLUS
58994: ST_TO_ADDR
// max_y := y + r ;
58995: LD_ADDR_VAR 0 10
58999: PUSH
59000: LD_VAR 0 3
59004: PUSH
59005: LD_VAR 0 4
59009: PLUS
59010: ST_TO_ADDR
// for _x = min_x to max_x do
59011: LD_ADDR_VAR 0 11
59015: PUSH
59016: DOUBLE
59017: LD_VAR 0 7
59021: DEC
59022: ST_TO_ADDR
59023: LD_VAR 0 9
59027: PUSH
59028: FOR_TO
59029: IFFALSE 59146
// for _y = min_y to max_y do
59031: LD_ADDR_VAR 0 12
59035: PUSH
59036: DOUBLE
59037: LD_VAR 0 8
59041: DEC
59042: ST_TO_ADDR
59043: LD_VAR 0 10
59047: PUSH
59048: FOR_TO
59049: IFFALSE 59142
// begin if not ValidHex ( _x , _y ) then
59051: LD_VAR 0 11
59055: PPUSH
59056: LD_VAR 0 12
59060: PPUSH
59061: CALL_OW 488
59065: NOT
59066: IFFALSE 59070
// continue ;
59068: GO 59048
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59070: LD_VAR 0 11
59074: PPUSH
59075: LD_VAR 0 12
59079: PPUSH
59080: CALL_OW 351
59084: PUSH
59085: LD_VAR 0 11
59089: PPUSH
59090: LD_VAR 0 12
59094: PPUSH
59095: CALL_OW 554
59099: AND
59100: IFFALSE 59140
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59102: LD_ADDR_VAR 0 13
59106: PUSH
59107: LD_VAR 0 13
59111: PPUSH
59112: LD_VAR 0 13
59116: PUSH
59117: LD_INT 1
59119: PLUS
59120: PPUSH
59121: LD_VAR 0 11
59125: PUSH
59126: LD_VAR 0 12
59130: PUSH
59131: EMPTY
59132: LIST
59133: LIST
59134: PPUSH
59135: CALL_OW 2
59139: ST_TO_ADDR
// end ;
59140: GO 59048
59142: POP
59143: POP
59144: GO 59028
59146: POP
59147: POP
// if not list then
59148: LD_VAR 0 13
59152: NOT
59153: IFFALSE 59157
// exit ;
59155: GO 59228
// for i in list do
59157: LD_ADDR_VAR 0 6
59161: PUSH
59162: LD_VAR 0 13
59166: PUSH
59167: FOR_IN
59168: IFFALSE 59226
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59170: LD_VAR 0 1
59174: PPUSH
59175: LD_STRING M
59177: PUSH
59178: LD_VAR 0 6
59182: PUSH
59183: LD_INT 1
59185: ARRAY
59186: PUSH
59187: LD_VAR 0 6
59191: PUSH
59192: LD_INT 2
59194: ARRAY
59195: PUSH
59196: LD_INT 0
59198: PUSH
59199: LD_INT 0
59201: PUSH
59202: LD_INT 0
59204: PUSH
59205: LD_INT 0
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: LIST
59212: LIST
59213: LIST
59214: LIST
59215: LIST
59216: PUSH
59217: EMPTY
59218: LIST
59219: PPUSH
59220: CALL_OW 447
59224: GO 59167
59226: POP
59227: POP
// end ;
59228: LD_VAR 0 5
59232: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
59233: LD_EXP 151
59237: NOT
59238: IFFALSE 59288
59240: GO 59242
59242: DISABLE
// begin initHack := true ;
59243: LD_ADDR_EXP 151
59247: PUSH
59248: LD_INT 1
59250: ST_TO_ADDR
// hackTanks := [ ] ;
59251: LD_ADDR_EXP 152
59255: PUSH
59256: EMPTY
59257: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
59258: LD_ADDR_EXP 153
59262: PUSH
59263: EMPTY
59264: ST_TO_ADDR
// hackLimit := 3 ;
59265: LD_ADDR_EXP 154
59269: PUSH
59270: LD_INT 3
59272: ST_TO_ADDR
// hackDist := 12 ;
59273: LD_ADDR_EXP 155
59277: PUSH
59278: LD_INT 12
59280: ST_TO_ADDR
// hackCounter := [ ] ;
59281: LD_ADDR_EXP 156
59285: PUSH
59286: EMPTY
59287: ST_TO_ADDR
// end ;
59288: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
59289: LD_EXP 151
59293: PUSH
59294: LD_INT 34
59296: PUSH
59297: LD_EXP 75
59301: PUSH
59302: EMPTY
59303: LIST
59304: LIST
59305: PPUSH
59306: CALL_OW 69
59310: AND
59311: IFFALSE 59566
59313: GO 59315
59315: DISABLE
59316: LD_INT 0
59318: PPUSH
59319: PPUSH
// begin enable ;
59320: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
59321: LD_ADDR_VAR 0 1
59325: PUSH
59326: LD_INT 34
59328: PUSH
59329: LD_EXP 75
59333: PUSH
59334: EMPTY
59335: LIST
59336: LIST
59337: PPUSH
59338: CALL_OW 69
59342: PUSH
59343: FOR_IN
59344: IFFALSE 59564
// begin if not i in hackTanks then
59346: LD_VAR 0 1
59350: PUSH
59351: LD_EXP 152
59355: IN
59356: NOT
59357: IFFALSE 59440
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
59359: LD_ADDR_EXP 152
59363: PUSH
59364: LD_EXP 152
59368: PPUSH
59369: LD_EXP 152
59373: PUSH
59374: LD_INT 1
59376: PLUS
59377: PPUSH
59378: LD_VAR 0 1
59382: PPUSH
59383: CALL_OW 1
59387: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
59388: LD_ADDR_EXP 153
59392: PUSH
59393: LD_EXP 153
59397: PPUSH
59398: LD_EXP 153
59402: PUSH
59403: LD_INT 1
59405: PLUS
59406: PPUSH
59407: EMPTY
59408: PPUSH
59409: CALL_OW 1
59413: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
59414: LD_ADDR_EXP 156
59418: PUSH
59419: LD_EXP 156
59423: PPUSH
59424: LD_EXP 156
59428: PUSH
59429: LD_INT 1
59431: PLUS
59432: PPUSH
59433: EMPTY
59434: PPUSH
59435: CALL_OW 1
59439: ST_TO_ADDR
// end ; if not IsOk ( i ) then
59440: LD_VAR 0 1
59444: PPUSH
59445: CALL_OW 302
59449: NOT
59450: IFFALSE 59463
// begin HackUnlinkAll ( i ) ;
59452: LD_VAR 0 1
59456: PPUSH
59457: CALL 59569 0 1
// continue ;
59461: GO 59343
// end ; HackCheckCapturedStatus ( i ) ;
59463: LD_VAR 0 1
59467: PPUSH
59468: CALL 60012 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
59472: LD_ADDR_VAR 0 2
59476: PUSH
59477: LD_INT 81
59479: PUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: CALL_OW 255
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: LD_INT 33
59496: PUSH
59497: LD_INT 3
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: PUSH
59504: LD_INT 91
59506: PUSH
59507: LD_VAR 0 1
59511: PUSH
59512: LD_EXP 155
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: LIST
59521: PUSH
59522: LD_INT 50
59524: PUSH
59525: EMPTY
59526: LIST
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: LIST
59532: LIST
59533: PPUSH
59534: CALL_OW 69
59538: ST_TO_ADDR
// if not tmp then
59539: LD_VAR 0 2
59543: NOT
59544: IFFALSE 59548
// continue ;
59546: GO 59343
// HackLink ( i , tmp ) ;
59548: LD_VAR 0 1
59552: PPUSH
59553: LD_VAR 0 2
59557: PPUSH
59558: CALL 59705 0 2
// end ;
59562: GO 59343
59564: POP
59565: POP
// end ;
59566: PPOPN 2
59568: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
59569: LD_INT 0
59571: PPUSH
59572: PPUSH
59573: PPUSH
// if not hack in hackTanks then
59574: LD_VAR 0 1
59578: PUSH
59579: LD_EXP 152
59583: IN
59584: NOT
59585: IFFALSE 59589
// exit ;
59587: GO 59700
// index := GetElementIndex ( hackTanks , hack ) ;
59589: LD_ADDR_VAR 0 4
59593: PUSH
59594: LD_EXP 152
59598: PPUSH
59599: LD_VAR 0 1
59603: PPUSH
59604: CALL 67174 0 2
59608: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
59609: LD_EXP 153
59613: PUSH
59614: LD_VAR 0 4
59618: ARRAY
59619: IFFALSE 59700
// begin for i in hackTanksCaptured [ index ] do
59621: LD_ADDR_VAR 0 3
59625: PUSH
59626: LD_EXP 153
59630: PUSH
59631: LD_VAR 0 4
59635: ARRAY
59636: PUSH
59637: FOR_IN
59638: IFFALSE 59664
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
59640: LD_VAR 0 3
59644: PUSH
59645: LD_INT 1
59647: ARRAY
59648: PPUSH
59649: LD_VAR 0 3
59653: PUSH
59654: LD_INT 2
59656: ARRAY
59657: PPUSH
59658: CALL_OW 235
59662: GO 59637
59664: POP
59665: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
59666: LD_ADDR_EXP 153
59670: PUSH
59671: LD_EXP 153
59675: PPUSH
59676: LD_VAR 0 4
59680: PPUSH
59681: EMPTY
59682: PPUSH
59683: CALL_OW 1
59687: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
59688: LD_VAR 0 1
59692: PPUSH
59693: LD_INT 0
59695: PPUSH
59696: CALL_OW 505
// end ; end ;
59700: LD_VAR 0 2
59704: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
59705: LD_INT 0
59707: PPUSH
59708: PPUSH
59709: PPUSH
// if not hack in hackTanks or not vehicles then
59710: LD_VAR 0 1
59714: PUSH
59715: LD_EXP 152
59719: IN
59720: NOT
59721: PUSH
59722: LD_VAR 0 2
59726: NOT
59727: OR
59728: IFFALSE 59732
// exit ;
59730: GO 60007
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
59732: LD_ADDR_VAR 0 2
59736: PUSH
59737: LD_VAR 0 1
59741: PPUSH
59742: LD_VAR 0 2
59746: PPUSH
59747: LD_INT 1
59749: PPUSH
59750: LD_INT 1
59752: PPUSH
59753: CALL 67824 0 4
59757: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
59758: LD_ADDR_VAR 0 5
59762: PUSH
59763: LD_EXP 152
59767: PPUSH
59768: LD_VAR 0 1
59772: PPUSH
59773: CALL 67174 0 2
59777: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
59778: LD_EXP 153
59782: PUSH
59783: LD_VAR 0 5
59787: ARRAY
59788: PUSH
59789: LD_EXP 154
59793: LESS
59794: IFFALSE 59983
// begin for i := 1 to vehicles do
59796: LD_ADDR_VAR 0 4
59800: PUSH
59801: DOUBLE
59802: LD_INT 1
59804: DEC
59805: ST_TO_ADDR
59806: LD_VAR 0 2
59810: PUSH
59811: FOR_TO
59812: IFFALSE 59981
// begin if hackTanksCaptured [ index ] = hackLimit then
59814: LD_EXP 153
59818: PUSH
59819: LD_VAR 0 5
59823: ARRAY
59824: PUSH
59825: LD_EXP 154
59829: EQUAL
59830: IFFALSE 59834
// break ;
59832: GO 59981
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
59834: LD_ADDR_EXP 156
59838: PUSH
59839: LD_EXP 156
59843: PPUSH
59844: LD_VAR 0 5
59848: PPUSH
59849: LD_EXP 156
59853: PUSH
59854: LD_VAR 0 5
59858: ARRAY
59859: PUSH
59860: LD_INT 1
59862: PLUS
59863: PPUSH
59864: CALL_OW 1
59868: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
59869: LD_ADDR_EXP 153
59873: PUSH
59874: LD_EXP 153
59878: PPUSH
59879: LD_VAR 0 5
59883: PUSH
59884: LD_EXP 153
59888: PUSH
59889: LD_VAR 0 5
59893: ARRAY
59894: PUSH
59895: LD_INT 1
59897: PLUS
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PPUSH
59903: LD_VAR 0 2
59907: PUSH
59908: LD_VAR 0 4
59912: ARRAY
59913: PUSH
59914: LD_VAR 0 2
59918: PUSH
59919: LD_VAR 0 4
59923: ARRAY
59924: PPUSH
59925: CALL_OW 255
59929: PUSH
59930: EMPTY
59931: LIST
59932: LIST
59933: PPUSH
59934: CALL 67389 0 3
59938: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
59939: LD_VAR 0 2
59943: PUSH
59944: LD_VAR 0 4
59948: ARRAY
59949: PPUSH
59950: LD_VAR 0 1
59954: PPUSH
59955: CALL_OW 255
59959: PPUSH
59960: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
59964: LD_VAR 0 2
59968: PUSH
59969: LD_VAR 0 4
59973: ARRAY
59974: PPUSH
59975: CALL_OW 141
// end ;
59979: GO 59811
59981: POP
59982: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
59983: LD_VAR 0 1
59987: PPUSH
59988: LD_EXP 153
59992: PUSH
59993: LD_VAR 0 5
59997: ARRAY
59998: PUSH
59999: LD_INT 0
60001: PLUS
60002: PPUSH
60003: CALL_OW 505
// end ;
60007: LD_VAR 0 3
60011: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60012: LD_INT 0
60014: PPUSH
60015: PPUSH
60016: PPUSH
60017: PPUSH
// if not hack in hackTanks then
60018: LD_VAR 0 1
60022: PUSH
60023: LD_EXP 152
60027: IN
60028: NOT
60029: IFFALSE 60033
// exit ;
60031: GO 60273
// index := GetElementIndex ( hackTanks , hack ) ;
60033: LD_ADDR_VAR 0 4
60037: PUSH
60038: LD_EXP 152
60042: PPUSH
60043: LD_VAR 0 1
60047: PPUSH
60048: CALL 67174 0 2
60052: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60053: LD_ADDR_VAR 0 3
60057: PUSH
60058: DOUBLE
60059: LD_EXP 153
60063: PUSH
60064: LD_VAR 0 4
60068: ARRAY
60069: INC
60070: ST_TO_ADDR
60071: LD_INT 1
60073: PUSH
60074: FOR_DOWNTO
60075: IFFALSE 60247
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60077: LD_ADDR_VAR 0 5
60081: PUSH
60082: LD_EXP 153
60086: PUSH
60087: LD_VAR 0 4
60091: ARRAY
60092: PUSH
60093: LD_VAR 0 3
60097: ARRAY
60098: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60099: LD_VAR 0 5
60103: PUSH
60104: LD_INT 1
60106: ARRAY
60107: PPUSH
60108: CALL_OW 302
60112: NOT
60113: PUSH
60114: LD_VAR 0 5
60118: PUSH
60119: LD_INT 1
60121: ARRAY
60122: PPUSH
60123: CALL_OW 255
60127: PUSH
60128: LD_VAR 0 1
60132: PPUSH
60133: CALL_OW 255
60137: NONEQUAL
60138: OR
60139: IFFALSE 60245
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60141: LD_VAR 0 5
60145: PUSH
60146: LD_INT 1
60148: ARRAY
60149: PPUSH
60150: CALL_OW 305
60154: PUSH
60155: LD_VAR 0 5
60159: PUSH
60160: LD_INT 1
60162: ARRAY
60163: PPUSH
60164: CALL_OW 255
60168: PUSH
60169: LD_VAR 0 1
60173: PPUSH
60174: CALL_OW 255
60178: EQUAL
60179: AND
60180: IFFALSE 60204
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
60182: LD_VAR 0 5
60186: PUSH
60187: LD_INT 1
60189: ARRAY
60190: PPUSH
60191: LD_VAR 0 5
60195: PUSH
60196: LD_INT 2
60198: ARRAY
60199: PPUSH
60200: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
60204: LD_ADDR_EXP 153
60208: PUSH
60209: LD_EXP 153
60213: PPUSH
60214: LD_VAR 0 4
60218: PPUSH
60219: LD_EXP 153
60223: PUSH
60224: LD_VAR 0 4
60228: ARRAY
60229: PPUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: CALL_OW 3
60239: PPUSH
60240: CALL_OW 1
60244: ST_TO_ADDR
// end ; end ;
60245: GO 60074
60247: POP
60248: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60249: LD_VAR 0 1
60253: PPUSH
60254: LD_EXP 153
60258: PUSH
60259: LD_VAR 0 4
60263: ARRAY
60264: PUSH
60265: LD_INT 0
60267: PLUS
60268: PPUSH
60269: CALL_OW 505
// end ;
60273: LD_VAR 0 2
60277: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
60278: LD_INT 0
60280: PPUSH
60281: PPUSH
60282: PPUSH
60283: PPUSH
// if not hack in hackTanks then
60284: LD_VAR 0 1
60288: PUSH
60289: LD_EXP 152
60293: IN
60294: NOT
60295: IFFALSE 60299
// exit ;
60297: GO 60384
// index := GetElementIndex ( hackTanks , hack ) ;
60299: LD_ADDR_VAR 0 5
60303: PUSH
60304: LD_EXP 152
60308: PPUSH
60309: LD_VAR 0 1
60313: PPUSH
60314: CALL 67174 0 2
60318: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
60319: LD_ADDR_VAR 0 4
60323: PUSH
60324: DOUBLE
60325: LD_INT 1
60327: DEC
60328: ST_TO_ADDR
60329: LD_EXP 153
60333: PUSH
60334: LD_VAR 0 5
60338: ARRAY
60339: PUSH
60340: FOR_TO
60341: IFFALSE 60382
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
60343: LD_EXP 153
60347: PUSH
60348: LD_VAR 0 5
60352: ARRAY
60353: PUSH
60354: LD_VAR 0 4
60358: ARRAY
60359: PUSH
60360: LD_INT 1
60362: ARRAY
60363: PUSH
60364: LD_VAR 0 2
60368: EQUAL
60369: IFFALSE 60380
// KillUnit ( vehicle ) ;
60371: LD_VAR 0 2
60375: PPUSH
60376: CALL_OW 66
60380: GO 60340
60382: POP
60383: POP
// end ;
60384: LD_VAR 0 3
60388: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
60389: LD_EXP 157
60393: NOT
60394: IFFALSE 60429
60396: GO 60398
60398: DISABLE
// begin initMiner := true ;
60399: LD_ADDR_EXP 157
60403: PUSH
60404: LD_INT 1
60406: ST_TO_ADDR
// minersList := [ ] ;
60407: LD_ADDR_EXP 158
60411: PUSH
60412: EMPTY
60413: ST_TO_ADDR
// minerMinesList := [ ] ;
60414: LD_ADDR_EXP 159
60418: PUSH
60419: EMPTY
60420: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
60421: LD_ADDR_EXP 160
60425: PUSH
60426: LD_INT 5
60428: ST_TO_ADDR
// end ;
60429: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
60430: LD_EXP 157
60434: PUSH
60435: LD_INT 34
60437: PUSH
60438: LD_EXP 80
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: PPUSH
60447: CALL_OW 69
60451: AND
60452: IFFALSE 60915
60454: GO 60456
60456: DISABLE
60457: LD_INT 0
60459: PPUSH
60460: PPUSH
60461: PPUSH
60462: PPUSH
// begin enable ;
60463: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
60464: LD_ADDR_VAR 0 1
60468: PUSH
60469: LD_INT 34
60471: PUSH
60472: LD_EXP 80
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: PPUSH
60481: CALL_OW 69
60485: PUSH
60486: FOR_IN
60487: IFFALSE 60559
// begin if not i in minersList then
60489: LD_VAR 0 1
60493: PUSH
60494: LD_EXP 158
60498: IN
60499: NOT
60500: IFFALSE 60557
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
60502: LD_ADDR_EXP 158
60506: PUSH
60507: LD_EXP 158
60511: PPUSH
60512: LD_EXP 158
60516: PUSH
60517: LD_INT 1
60519: PLUS
60520: PPUSH
60521: LD_VAR 0 1
60525: PPUSH
60526: CALL_OW 1
60530: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
60531: LD_ADDR_EXP 159
60535: PUSH
60536: LD_EXP 159
60540: PPUSH
60541: LD_EXP 159
60545: PUSH
60546: LD_INT 1
60548: PLUS
60549: PPUSH
60550: EMPTY
60551: PPUSH
60552: CALL_OW 1
60556: ST_TO_ADDR
// end end ;
60557: GO 60486
60559: POP
60560: POP
// for i := minerMinesList downto 1 do
60561: LD_ADDR_VAR 0 1
60565: PUSH
60566: DOUBLE
60567: LD_EXP 159
60571: INC
60572: ST_TO_ADDR
60573: LD_INT 1
60575: PUSH
60576: FOR_DOWNTO
60577: IFFALSE 60913
// begin if IsLive ( minersList [ i ] ) then
60579: LD_EXP 158
60583: PUSH
60584: LD_VAR 0 1
60588: ARRAY
60589: PPUSH
60590: CALL_OW 300
60594: IFFALSE 60622
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
60596: LD_EXP 158
60600: PUSH
60601: LD_VAR 0 1
60605: ARRAY
60606: PPUSH
60607: LD_EXP 159
60611: PUSH
60612: LD_VAR 0 1
60616: ARRAY
60617: PPUSH
60618: CALL_OW 505
// if not minerMinesList [ i ] then
60622: LD_EXP 159
60626: PUSH
60627: LD_VAR 0 1
60631: ARRAY
60632: NOT
60633: IFFALSE 60637
// continue ;
60635: GO 60576
// for j := minerMinesList [ i ] downto 1 do
60637: LD_ADDR_VAR 0 2
60641: PUSH
60642: DOUBLE
60643: LD_EXP 159
60647: PUSH
60648: LD_VAR 0 1
60652: ARRAY
60653: INC
60654: ST_TO_ADDR
60655: LD_INT 1
60657: PUSH
60658: FOR_DOWNTO
60659: IFFALSE 60909
// begin side := GetSide ( minersList [ i ] ) ;
60661: LD_ADDR_VAR 0 3
60665: PUSH
60666: LD_EXP 158
60670: PUSH
60671: LD_VAR 0 1
60675: ARRAY
60676: PPUSH
60677: CALL_OW 255
60681: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
60682: LD_ADDR_VAR 0 4
60686: PUSH
60687: LD_EXP 159
60691: PUSH
60692: LD_VAR 0 1
60696: ARRAY
60697: PUSH
60698: LD_VAR 0 2
60702: ARRAY
60703: PUSH
60704: LD_INT 1
60706: ARRAY
60707: PPUSH
60708: LD_EXP 159
60712: PUSH
60713: LD_VAR 0 1
60717: ARRAY
60718: PUSH
60719: LD_VAR 0 2
60723: ARRAY
60724: PUSH
60725: LD_INT 2
60727: ARRAY
60728: PPUSH
60729: CALL_OW 428
60733: ST_TO_ADDR
// if not tmp then
60734: LD_VAR 0 4
60738: NOT
60739: IFFALSE 60743
// continue ;
60741: GO 60658
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
60743: LD_VAR 0 4
60747: PUSH
60748: LD_INT 81
60750: PUSH
60751: LD_VAR 0 3
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PPUSH
60760: CALL_OW 69
60764: IN
60765: PUSH
60766: LD_EXP 159
60770: PUSH
60771: LD_VAR 0 1
60775: ARRAY
60776: PUSH
60777: LD_VAR 0 2
60781: ARRAY
60782: PUSH
60783: LD_INT 1
60785: ARRAY
60786: PPUSH
60787: LD_EXP 159
60791: PUSH
60792: LD_VAR 0 1
60796: ARRAY
60797: PUSH
60798: LD_VAR 0 2
60802: ARRAY
60803: PUSH
60804: LD_INT 2
60806: ARRAY
60807: PPUSH
60808: CALL_OW 458
60812: AND
60813: IFFALSE 60907
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
60815: LD_EXP 159
60819: PUSH
60820: LD_VAR 0 1
60824: ARRAY
60825: PUSH
60826: LD_VAR 0 2
60830: ARRAY
60831: PUSH
60832: LD_INT 1
60834: ARRAY
60835: PPUSH
60836: LD_EXP 159
60840: PUSH
60841: LD_VAR 0 1
60845: ARRAY
60846: PUSH
60847: LD_VAR 0 2
60851: ARRAY
60852: PUSH
60853: LD_INT 2
60855: ARRAY
60856: PPUSH
60857: LD_VAR 0 3
60861: PPUSH
60862: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
60866: LD_ADDR_EXP 159
60870: PUSH
60871: LD_EXP 159
60875: PPUSH
60876: LD_VAR 0 1
60880: PPUSH
60881: LD_EXP 159
60885: PUSH
60886: LD_VAR 0 1
60890: ARRAY
60891: PPUSH
60892: LD_VAR 0 2
60896: PPUSH
60897: CALL_OW 3
60901: PPUSH
60902: CALL_OW 1
60906: ST_TO_ADDR
// end ; end ;
60907: GO 60658
60909: POP
60910: POP
// end ;
60911: GO 60576
60913: POP
60914: POP
// end ;
60915: PPOPN 4
60917: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
60918: LD_INT 0
60920: PPUSH
60921: PPUSH
// result := false ;
60922: LD_ADDR_VAR 0 4
60926: PUSH
60927: LD_INT 0
60929: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
60930: LD_VAR 0 1
60934: PPUSH
60935: CALL_OW 264
60939: PUSH
60940: LD_EXP 80
60944: EQUAL
60945: NOT
60946: IFFALSE 60950
// exit ;
60948: GO 61190
// index := GetElementIndex ( minersList , unit ) ;
60950: LD_ADDR_VAR 0 5
60954: PUSH
60955: LD_EXP 158
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: CALL 67174 0 2
60969: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
60970: LD_EXP 159
60974: PUSH
60975: LD_VAR 0 5
60979: ARRAY
60980: PUSH
60981: LD_EXP 160
60985: GREATEREQUAL
60986: IFFALSE 60990
// exit ;
60988: GO 61190
// ComMoveXY ( unit , x , y ) ;
60990: LD_VAR 0 1
60994: PPUSH
60995: LD_VAR 0 2
60999: PPUSH
61000: LD_VAR 0 3
61004: PPUSH
61005: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61009: LD_INT 35
61011: PPUSH
61012: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61016: LD_VAR 0 1
61020: PPUSH
61021: LD_VAR 0 2
61025: PPUSH
61026: LD_VAR 0 3
61030: PPUSH
61031: CALL 97946 0 3
61035: NOT
61036: PUSH
61037: LD_VAR 0 1
61041: PPUSH
61042: CALL_OW 314
61046: AND
61047: IFFALSE 61051
// exit ;
61049: GO 61190
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61051: LD_VAR 0 2
61055: PPUSH
61056: LD_VAR 0 3
61060: PPUSH
61061: CALL_OW 428
61065: PUSH
61066: LD_VAR 0 1
61070: EQUAL
61071: PUSH
61072: LD_VAR 0 1
61076: PPUSH
61077: CALL_OW 314
61081: NOT
61082: AND
61083: IFFALSE 61009
// PlaySoundXY ( x , y , PlantMine ) ;
61085: LD_VAR 0 2
61089: PPUSH
61090: LD_VAR 0 3
61094: PPUSH
61095: LD_STRING PlantMine
61097: PPUSH
61098: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61102: LD_VAR 0 2
61106: PPUSH
61107: LD_VAR 0 3
61111: PPUSH
61112: LD_VAR 0 1
61116: PPUSH
61117: CALL_OW 255
61121: PPUSH
61122: LD_INT 0
61124: PPUSH
61125: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61129: LD_ADDR_EXP 159
61133: PUSH
61134: LD_EXP 159
61138: PPUSH
61139: LD_VAR 0 5
61143: PUSH
61144: LD_EXP 159
61148: PUSH
61149: LD_VAR 0 5
61153: ARRAY
61154: PUSH
61155: LD_INT 1
61157: PLUS
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: PPUSH
61163: LD_VAR 0 2
61167: PUSH
61168: LD_VAR 0 3
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PPUSH
61177: CALL 67389 0 3
61181: ST_TO_ADDR
// result := true ;
61182: LD_ADDR_VAR 0 4
61186: PUSH
61187: LD_INT 1
61189: ST_TO_ADDR
// end ;
61190: LD_VAR 0 4
61194: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
61195: LD_INT 0
61197: PPUSH
61198: PPUSH
61199: PPUSH
// if not unit in minersList then
61200: LD_VAR 0 1
61204: PUSH
61205: LD_EXP 158
61209: IN
61210: NOT
61211: IFFALSE 61215
// exit ;
61213: GO 61607
// index := GetElementIndex ( minersList , unit ) ;
61215: LD_ADDR_VAR 0 6
61219: PUSH
61220: LD_EXP 158
61224: PPUSH
61225: LD_VAR 0 1
61229: PPUSH
61230: CALL 67174 0 2
61234: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
61235: LD_ADDR_VAR 0 5
61239: PUSH
61240: DOUBLE
61241: LD_EXP 159
61245: PUSH
61246: LD_VAR 0 6
61250: ARRAY
61251: INC
61252: ST_TO_ADDR
61253: LD_INT 1
61255: PUSH
61256: FOR_DOWNTO
61257: IFFALSE 61418
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
61259: LD_EXP 159
61263: PUSH
61264: LD_VAR 0 6
61268: ARRAY
61269: PUSH
61270: LD_VAR 0 5
61274: ARRAY
61275: PUSH
61276: LD_INT 1
61278: ARRAY
61279: PUSH
61280: LD_VAR 0 2
61284: EQUAL
61285: PUSH
61286: LD_EXP 159
61290: PUSH
61291: LD_VAR 0 6
61295: ARRAY
61296: PUSH
61297: LD_VAR 0 5
61301: ARRAY
61302: PUSH
61303: LD_INT 2
61305: ARRAY
61306: PUSH
61307: LD_VAR 0 3
61311: EQUAL
61312: AND
61313: IFFALSE 61416
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61315: LD_EXP 159
61319: PUSH
61320: LD_VAR 0 6
61324: ARRAY
61325: PUSH
61326: LD_VAR 0 5
61330: ARRAY
61331: PUSH
61332: LD_INT 1
61334: ARRAY
61335: PPUSH
61336: LD_EXP 159
61340: PUSH
61341: LD_VAR 0 6
61345: ARRAY
61346: PUSH
61347: LD_VAR 0 5
61351: ARRAY
61352: PUSH
61353: LD_INT 2
61355: ARRAY
61356: PPUSH
61357: LD_VAR 0 1
61361: PPUSH
61362: CALL_OW 255
61366: PPUSH
61367: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61371: LD_ADDR_EXP 159
61375: PUSH
61376: LD_EXP 159
61380: PPUSH
61381: LD_VAR 0 6
61385: PPUSH
61386: LD_EXP 159
61390: PUSH
61391: LD_VAR 0 6
61395: ARRAY
61396: PPUSH
61397: LD_VAR 0 5
61401: PPUSH
61402: CALL_OW 3
61406: PPUSH
61407: CALL_OW 1
61411: ST_TO_ADDR
// exit ;
61412: POP
61413: POP
61414: GO 61607
// end ; end ;
61416: GO 61256
61418: POP
61419: POP
// for i := minerMinesList [ index ] downto 1 do
61420: LD_ADDR_VAR 0 5
61424: PUSH
61425: DOUBLE
61426: LD_EXP 159
61430: PUSH
61431: LD_VAR 0 6
61435: ARRAY
61436: INC
61437: ST_TO_ADDR
61438: LD_INT 1
61440: PUSH
61441: FOR_DOWNTO
61442: IFFALSE 61605
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
61444: LD_EXP 159
61448: PUSH
61449: LD_VAR 0 6
61453: ARRAY
61454: PUSH
61455: LD_VAR 0 5
61459: ARRAY
61460: PUSH
61461: LD_INT 1
61463: ARRAY
61464: PPUSH
61465: LD_EXP 159
61469: PUSH
61470: LD_VAR 0 6
61474: ARRAY
61475: PUSH
61476: LD_VAR 0 5
61480: ARRAY
61481: PUSH
61482: LD_INT 2
61484: ARRAY
61485: PPUSH
61486: LD_VAR 0 2
61490: PPUSH
61491: LD_VAR 0 3
61495: PPUSH
61496: CALL_OW 298
61500: PUSH
61501: LD_INT 6
61503: LESS
61504: IFFALSE 61603
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61506: LD_EXP 159
61510: PUSH
61511: LD_VAR 0 6
61515: ARRAY
61516: PUSH
61517: LD_VAR 0 5
61521: ARRAY
61522: PUSH
61523: LD_INT 1
61525: ARRAY
61526: PPUSH
61527: LD_EXP 159
61531: PUSH
61532: LD_VAR 0 6
61536: ARRAY
61537: PUSH
61538: LD_VAR 0 5
61542: ARRAY
61543: PUSH
61544: LD_INT 2
61546: ARRAY
61547: PPUSH
61548: LD_VAR 0 1
61552: PPUSH
61553: CALL_OW 255
61557: PPUSH
61558: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61562: LD_ADDR_EXP 159
61566: PUSH
61567: LD_EXP 159
61571: PPUSH
61572: LD_VAR 0 6
61576: PPUSH
61577: LD_EXP 159
61581: PUSH
61582: LD_VAR 0 6
61586: ARRAY
61587: PPUSH
61588: LD_VAR 0 5
61592: PPUSH
61593: CALL_OW 3
61597: PPUSH
61598: CALL_OW 1
61602: ST_TO_ADDR
// end ; end ;
61603: GO 61441
61605: POP
61606: POP
// end ;
61607: LD_VAR 0 4
61611: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
61612: LD_INT 0
61614: PPUSH
61615: PPUSH
61616: PPUSH
61617: PPUSH
61618: PPUSH
61619: PPUSH
61620: PPUSH
61621: PPUSH
61622: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
61623: LD_VAR 0 1
61627: PPUSH
61628: CALL_OW 264
61632: PUSH
61633: LD_EXP 80
61637: EQUAL
61638: NOT
61639: PUSH
61640: LD_VAR 0 1
61644: PUSH
61645: LD_EXP 158
61649: IN
61650: NOT
61651: OR
61652: IFFALSE 61656
// exit ;
61654: GO 61978
// index := GetElementIndex ( minersList , unit ) ;
61656: LD_ADDR_VAR 0 6
61660: PUSH
61661: LD_EXP 158
61665: PPUSH
61666: LD_VAR 0 1
61670: PPUSH
61671: CALL 67174 0 2
61675: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
61676: LD_ADDR_VAR 0 8
61680: PUSH
61681: LD_EXP 160
61685: PUSH
61686: LD_EXP 159
61690: PUSH
61691: LD_VAR 0 6
61695: ARRAY
61696: MINUS
61697: ST_TO_ADDR
// if not minesFreeAmount then
61698: LD_VAR 0 8
61702: NOT
61703: IFFALSE 61707
// exit ;
61705: GO 61978
// tmp := [ ] ;
61707: LD_ADDR_VAR 0 7
61711: PUSH
61712: EMPTY
61713: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
61714: LD_ADDR_VAR 0 5
61718: PUSH
61719: DOUBLE
61720: LD_INT 1
61722: DEC
61723: ST_TO_ADDR
61724: LD_VAR 0 8
61728: PUSH
61729: FOR_TO
61730: IFFALSE 61925
// begin _d := rand ( 0 , 5 ) ;
61732: LD_ADDR_VAR 0 11
61736: PUSH
61737: LD_INT 0
61739: PPUSH
61740: LD_INT 5
61742: PPUSH
61743: CALL_OW 12
61747: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
61748: LD_ADDR_VAR 0 12
61752: PUSH
61753: LD_INT 2
61755: PPUSH
61756: LD_INT 6
61758: PPUSH
61759: CALL_OW 12
61763: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
61764: LD_ADDR_VAR 0 9
61768: PUSH
61769: LD_VAR 0 2
61773: PPUSH
61774: LD_VAR 0 11
61778: PPUSH
61779: LD_VAR 0 12
61783: PPUSH
61784: CALL_OW 272
61788: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
61789: LD_ADDR_VAR 0 10
61793: PUSH
61794: LD_VAR 0 3
61798: PPUSH
61799: LD_VAR 0 11
61803: PPUSH
61804: LD_VAR 0 12
61808: PPUSH
61809: CALL_OW 273
61813: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
61814: LD_VAR 0 9
61818: PPUSH
61819: LD_VAR 0 10
61823: PPUSH
61824: CALL_OW 488
61828: PUSH
61829: LD_VAR 0 9
61833: PUSH
61834: LD_VAR 0 10
61838: PUSH
61839: EMPTY
61840: LIST
61841: LIST
61842: PUSH
61843: LD_VAR 0 7
61847: IN
61848: NOT
61849: AND
61850: PUSH
61851: LD_VAR 0 9
61855: PPUSH
61856: LD_VAR 0 10
61860: PPUSH
61861: CALL_OW 458
61865: NOT
61866: AND
61867: IFFALSE 61909
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
61869: LD_ADDR_VAR 0 7
61873: PUSH
61874: LD_VAR 0 7
61878: PPUSH
61879: LD_VAR 0 7
61883: PUSH
61884: LD_INT 1
61886: PLUS
61887: PPUSH
61888: LD_VAR 0 9
61892: PUSH
61893: LD_VAR 0 10
61897: PUSH
61898: EMPTY
61899: LIST
61900: LIST
61901: PPUSH
61902: CALL_OW 1
61906: ST_TO_ADDR
61907: GO 61923
// i := i - 1 ;
61909: LD_ADDR_VAR 0 5
61913: PUSH
61914: LD_VAR 0 5
61918: PUSH
61919: LD_INT 1
61921: MINUS
61922: ST_TO_ADDR
// end ;
61923: GO 61729
61925: POP
61926: POP
// for i in tmp do
61927: LD_ADDR_VAR 0 5
61931: PUSH
61932: LD_VAR 0 7
61936: PUSH
61937: FOR_IN
61938: IFFALSE 61976
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
61940: LD_VAR 0 1
61944: PPUSH
61945: LD_VAR 0 5
61949: PUSH
61950: LD_INT 1
61952: ARRAY
61953: PPUSH
61954: LD_VAR 0 5
61958: PUSH
61959: LD_INT 2
61961: ARRAY
61962: PPUSH
61963: CALL 60918 0 3
61967: NOT
61968: IFFALSE 61974
// exit ;
61970: POP
61971: POP
61972: GO 61978
61974: GO 61937
61976: POP
61977: POP
// end ;
61978: LD_VAR 0 4
61982: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
61983: LD_INT 0
61985: PPUSH
61986: PPUSH
61987: PPUSH
61988: PPUSH
61989: PPUSH
61990: PPUSH
61991: PPUSH
// if not GetClass ( unit ) = class_sniper then
61992: LD_VAR 0 1
61996: PPUSH
61997: CALL_OW 257
62001: PUSH
62002: LD_INT 5
62004: EQUAL
62005: NOT
62006: IFFALSE 62010
// exit ;
62008: GO 62398
// dist := 8 ;
62010: LD_ADDR_VAR 0 5
62014: PUSH
62015: LD_INT 8
62017: ST_TO_ADDR
// viewRange := 12 ;
62018: LD_ADDR_VAR 0 7
62022: PUSH
62023: LD_INT 12
62025: ST_TO_ADDR
// side := GetSide ( unit ) ;
62026: LD_ADDR_VAR 0 6
62030: PUSH
62031: LD_VAR 0 1
62035: PPUSH
62036: CALL_OW 255
62040: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62041: LD_INT 61
62043: PPUSH
62044: LD_VAR 0 6
62048: PPUSH
62049: CALL_OW 321
62053: PUSH
62054: LD_INT 2
62056: EQUAL
62057: IFFALSE 62067
// viewRange := 16 ;
62059: LD_ADDR_VAR 0 7
62063: PUSH
62064: LD_INT 16
62066: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62067: LD_VAR 0 1
62071: PPUSH
62072: LD_VAR 0 2
62076: PPUSH
62077: LD_VAR 0 3
62081: PPUSH
62082: CALL_OW 297
62086: PUSH
62087: LD_VAR 0 5
62091: GREATER
62092: IFFALSE 62171
// begin ComMoveXY ( unit , x , y ) ;
62094: LD_VAR 0 1
62098: PPUSH
62099: LD_VAR 0 2
62103: PPUSH
62104: LD_VAR 0 3
62108: PPUSH
62109: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62113: LD_INT 35
62115: PPUSH
62116: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62120: LD_VAR 0 1
62124: PPUSH
62125: LD_VAR 0 2
62129: PPUSH
62130: LD_VAR 0 3
62134: PPUSH
62135: CALL 97946 0 3
62139: NOT
62140: IFFALSE 62144
// exit ;
62142: GO 62398
// until GetDistUnitXY ( unit , x , y ) < dist ;
62144: LD_VAR 0 1
62148: PPUSH
62149: LD_VAR 0 2
62153: PPUSH
62154: LD_VAR 0 3
62158: PPUSH
62159: CALL_OW 297
62163: PUSH
62164: LD_VAR 0 5
62168: LESS
62169: IFFALSE 62113
// end ; ComTurnXY ( unit , x , y ) ;
62171: LD_VAR 0 1
62175: PPUSH
62176: LD_VAR 0 2
62180: PPUSH
62181: LD_VAR 0 3
62185: PPUSH
62186: CALL_OW 118
// wait ( 5 ) ;
62190: LD_INT 5
62192: PPUSH
62193: CALL_OW 67
// _d := GetDir ( unit ) ;
62197: LD_ADDR_VAR 0 10
62201: PUSH
62202: LD_VAR 0 1
62206: PPUSH
62207: CALL_OW 254
62211: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
62212: LD_ADDR_VAR 0 8
62216: PUSH
62217: LD_VAR 0 1
62221: PPUSH
62222: CALL_OW 250
62226: PPUSH
62227: LD_VAR 0 10
62231: PPUSH
62232: LD_VAR 0 5
62236: PPUSH
62237: CALL_OW 272
62241: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
62242: LD_ADDR_VAR 0 9
62246: PUSH
62247: LD_VAR 0 1
62251: PPUSH
62252: CALL_OW 251
62256: PPUSH
62257: LD_VAR 0 10
62261: PPUSH
62262: LD_VAR 0 5
62266: PPUSH
62267: CALL_OW 273
62271: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62272: LD_VAR 0 8
62276: PPUSH
62277: LD_VAR 0 9
62281: PPUSH
62282: CALL_OW 488
62286: NOT
62287: IFFALSE 62291
// exit ;
62289: GO 62398
// ComAnimCustom ( unit , 1 ) ;
62291: LD_VAR 0 1
62295: PPUSH
62296: LD_INT 1
62298: PPUSH
62299: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
62303: LD_VAR 0 8
62307: PPUSH
62308: LD_VAR 0 9
62312: PPUSH
62313: LD_VAR 0 6
62317: PPUSH
62318: LD_VAR 0 7
62322: PPUSH
62323: CALL_OW 330
// repeat wait ( 1 ) ;
62327: LD_INT 1
62329: PPUSH
62330: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
62334: LD_VAR 0 1
62338: PPUSH
62339: CALL_OW 316
62343: PUSH
62344: LD_VAR 0 1
62348: PPUSH
62349: CALL_OW 314
62353: OR
62354: PUSH
62355: LD_VAR 0 1
62359: PPUSH
62360: CALL_OW 302
62364: NOT
62365: OR
62366: PUSH
62367: LD_VAR 0 1
62371: PPUSH
62372: CALL_OW 301
62376: OR
62377: IFFALSE 62327
// RemoveSeeing ( _x , _y , side ) ;
62379: LD_VAR 0 8
62383: PPUSH
62384: LD_VAR 0 9
62388: PPUSH
62389: LD_VAR 0 6
62393: PPUSH
62394: CALL_OW 331
// end ; end_of_file
62398: LD_VAR 0 4
62402: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62403: LD_INT 0
62405: PPUSH
62406: PPUSH
// if exist_mode then
62407: LD_VAR 0 2
62411: IFFALSE 62436
// unit := CreateCharacter ( prefix & ident ) else
62413: LD_ADDR_VAR 0 5
62417: PUSH
62418: LD_VAR 0 3
62422: PUSH
62423: LD_VAR 0 1
62427: STR
62428: PPUSH
62429: CALL_OW 34
62433: ST_TO_ADDR
62434: GO 62451
// unit := NewCharacter ( ident ) ;
62436: LD_ADDR_VAR 0 5
62440: PUSH
62441: LD_VAR 0 1
62445: PPUSH
62446: CALL_OW 25
62450: ST_TO_ADDR
// result := unit ;
62451: LD_ADDR_VAR 0 4
62455: PUSH
62456: LD_VAR 0 5
62460: ST_TO_ADDR
// end ;
62461: LD_VAR 0 4
62465: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
62466: LD_INT 0
62468: PPUSH
62469: PPUSH
// if not side or not nation then
62470: LD_VAR 0 1
62474: NOT
62475: PUSH
62476: LD_VAR 0 2
62480: NOT
62481: OR
62482: IFFALSE 62486
// exit ;
62484: GO 63254
// case nation of nation_american :
62486: LD_VAR 0 2
62490: PUSH
62491: LD_INT 1
62493: DOUBLE
62494: EQUAL
62495: IFTRUE 62499
62497: GO 62713
62499: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
62500: LD_ADDR_VAR 0 4
62504: PUSH
62505: LD_INT 35
62507: PUSH
62508: LD_INT 45
62510: PUSH
62511: LD_INT 46
62513: PUSH
62514: LD_INT 47
62516: PUSH
62517: LD_INT 82
62519: PUSH
62520: LD_INT 83
62522: PUSH
62523: LD_INT 84
62525: PUSH
62526: LD_INT 85
62528: PUSH
62529: LD_INT 86
62531: PUSH
62532: LD_INT 1
62534: PUSH
62535: LD_INT 2
62537: PUSH
62538: LD_INT 6
62540: PUSH
62541: LD_INT 15
62543: PUSH
62544: LD_INT 16
62546: PUSH
62547: LD_INT 7
62549: PUSH
62550: LD_INT 12
62552: PUSH
62553: LD_INT 13
62555: PUSH
62556: LD_INT 10
62558: PUSH
62559: LD_INT 14
62561: PUSH
62562: LD_INT 20
62564: PUSH
62565: LD_INT 21
62567: PUSH
62568: LD_INT 22
62570: PUSH
62571: LD_INT 25
62573: PUSH
62574: LD_INT 32
62576: PUSH
62577: LD_INT 27
62579: PUSH
62580: LD_INT 36
62582: PUSH
62583: LD_INT 69
62585: PUSH
62586: LD_INT 39
62588: PUSH
62589: LD_INT 34
62591: PUSH
62592: LD_INT 40
62594: PUSH
62595: LD_INT 48
62597: PUSH
62598: LD_INT 49
62600: PUSH
62601: LD_INT 50
62603: PUSH
62604: LD_INT 51
62606: PUSH
62607: LD_INT 52
62609: PUSH
62610: LD_INT 53
62612: PUSH
62613: LD_INT 54
62615: PUSH
62616: LD_INT 55
62618: PUSH
62619: LD_INT 56
62621: PUSH
62622: LD_INT 57
62624: PUSH
62625: LD_INT 58
62627: PUSH
62628: LD_INT 59
62630: PUSH
62631: LD_INT 60
62633: PUSH
62634: LD_INT 61
62636: PUSH
62637: LD_INT 62
62639: PUSH
62640: LD_INT 80
62642: PUSH
62643: LD_INT 82
62645: PUSH
62646: LD_INT 83
62648: PUSH
62649: LD_INT 84
62651: PUSH
62652: LD_INT 85
62654: PUSH
62655: LD_INT 86
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: LIST
62662: LIST
62663: LIST
62664: LIST
62665: LIST
62666: LIST
62667: LIST
62668: LIST
62669: LIST
62670: LIST
62671: LIST
62672: LIST
62673: LIST
62674: LIST
62675: LIST
62676: LIST
62677: LIST
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: LIST
62691: LIST
62692: LIST
62693: LIST
62694: LIST
62695: LIST
62696: LIST
62697: LIST
62698: LIST
62699: LIST
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: ST_TO_ADDR
62711: GO 63178
62713: LD_INT 2
62715: DOUBLE
62716: EQUAL
62717: IFTRUE 62721
62719: GO 62947
62721: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
62722: LD_ADDR_VAR 0 4
62726: PUSH
62727: LD_INT 35
62729: PUSH
62730: LD_INT 45
62732: PUSH
62733: LD_INT 46
62735: PUSH
62736: LD_INT 47
62738: PUSH
62739: LD_INT 82
62741: PUSH
62742: LD_INT 83
62744: PUSH
62745: LD_INT 84
62747: PUSH
62748: LD_INT 85
62750: PUSH
62751: LD_INT 87
62753: PUSH
62754: LD_INT 70
62756: PUSH
62757: LD_INT 1
62759: PUSH
62760: LD_INT 11
62762: PUSH
62763: LD_INT 3
62765: PUSH
62766: LD_INT 4
62768: PUSH
62769: LD_INT 5
62771: PUSH
62772: LD_INT 6
62774: PUSH
62775: LD_INT 15
62777: PUSH
62778: LD_INT 18
62780: PUSH
62781: LD_INT 7
62783: PUSH
62784: LD_INT 17
62786: PUSH
62787: LD_INT 8
62789: PUSH
62790: LD_INT 20
62792: PUSH
62793: LD_INT 21
62795: PUSH
62796: LD_INT 22
62798: PUSH
62799: LD_INT 72
62801: PUSH
62802: LD_INT 26
62804: PUSH
62805: LD_INT 69
62807: PUSH
62808: LD_INT 39
62810: PUSH
62811: LD_INT 40
62813: PUSH
62814: LD_INT 41
62816: PUSH
62817: LD_INT 42
62819: PUSH
62820: LD_INT 43
62822: PUSH
62823: LD_INT 48
62825: PUSH
62826: LD_INT 49
62828: PUSH
62829: LD_INT 50
62831: PUSH
62832: LD_INT 51
62834: PUSH
62835: LD_INT 52
62837: PUSH
62838: LD_INT 53
62840: PUSH
62841: LD_INT 54
62843: PUSH
62844: LD_INT 55
62846: PUSH
62847: LD_INT 56
62849: PUSH
62850: LD_INT 60
62852: PUSH
62853: LD_INT 61
62855: PUSH
62856: LD_INT 62
62858: PUSH
62859: LD_INT 66
62861: PUSH
62862: LD_INT 67
62864: PUSH
62865: LD_INT 68
62867: PUSH
62868: LD_INT 81
62870: PUSH
62871: LD_INT 82
62873: PUSH
62874: LD_INT 83
62876: PUSH
62877: LD_INT 84
62879: PUSH
62880: LD_INT 85
62882: PUSH
62883: LD_INT 87
62885: PUSH
62886: LD_INT 88
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: LIST
62900: LIST
62901: LIST
62902: LIST
62903: LIST
62904: LIST
62905: LIST
62906: LIST
62907: LIST
62908: LIST
62909: LIST
62910: LIST
62911: LIST
62912: LIST
62913: LIST
62914: LIST
62915: LIST
62916: LIST
62917: LIST
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: LIST
62942: LIST
62943: LIST
62944: ST_TO_ADDR
62945: GO 63178
62947: LD_INT 3
62949: DOUBLE
62950: EQUAL
62951: IFTRUE 62955
62953: GO 63177
62955: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
62956: LD_ADDR_VAR 0 4
62960: PUSH
62961: LD_INT 46
62963: PUSH
62964: LD_INT 47
62966: PUSH
62967: LD_INT 1
62969: PUSH
62970: LD_INT 2
62972: PUSH
62973: LD_INT 82
62975: PUSH
62976: LD_INT 83
62978: PUSH
62979: LD_INT 84
62981: PUSH
62982: LD_INT 85
62984: PUSH
62985: LD_INT 86
62987: PUSH
62988: LD_INT 11
62990: PUSH
62991: LD_INT 9
62993: PUSH
62994: LD_INT 20
62996: PUSH
62997: LD_INT 19
62999: PUSH
63000: LD_INT 21
63002: PUSH
63003: LD_INT 24
63005: PUSH
63006: LD_INT 22
63008: PUSH
63009: LD_INT 25
63011: PUSH
63012: LD_INT 28
63014: PUSH
63015: LD_INT 29
63017: PUSH
63018: LD_INT 30
63020: PUSH
63021: LD_INT 31
63023: PUSH
63024: LD_INT 37
63026: PUSH
63027: LD_INT 38
63029: PUSH
63030: LD_INT 32
63032: PUSH
63033: LD_INT 27
63035: PUSH
63036: LD_INT 33
63038: PUSH
63039: LD_INT 69
63041: PUSH
63042: LD_INT 39
63044: PUSH
63045: LD_INT 34
63047: PUSH
63048: LD_INT 40
63050: PUSH
63051: LD_INT 71
63053: PUSH
63054: LD_INT 23
63056: PUSH
63057: LD_INT 44
63059: PUSH
63060: LD_INT 48
63062: PUSH
63063: LD_INT 49
63065: PUSH
63066: LD_INT 50
63068: PUSH
63069: LD_INT 51
63071: PUSH
63072: LD_INT 52
63074: PUSH
63075: LD_INT 53
63077: PUSH
63078: LD_INT 54
63080: PUSH
63081: LD_INT 55
63083: PUSH
63084: LD_INT 56
63086: PUSH
63087: LD_INT 57
63089: PUSH
63090: LD_INT 58
63092: PUSH
63093: LD_INT 59
63095: PUSH
63096: LD_INT 63
63098: PUSH
63099: LD_INT 64
63101: PUSH
63102: LD_INT 65
63104: PUSH
63105: LD_INT 82
63107: PUSH
63108: LD_INT 83
63110: PUSH
63111: LD_INT 84
63113: PUSH
63114: LD_INT 85
63116: PUSH
63117: LD_INT 86
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: LIST
63124: LIST
63125: LIST
63126: LIST
63127: LIST
63128: LIST
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: LIST
63134: LIST
63135: LIST
63136: LIST
63137: LIST
63138: LIST
63139: LIST
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: LIST
63173: LIST
63174: ST_TO_ADDR
63175: GO 63178
63177: POP
// if state > - 1 and state < 3 then
63178: LD_VAR 0 3
63182: PUSH
63183: LD_INT 1
63185: NEG
63186: GREATER
63187: PUSH
63188: LD_VAR 0 3
63192: PUSH
63193: LD_INT 3
63195: LESS
63196: AND
63197: IFFALSE 63254
// for i in result do
63199: LD_ADDR_VAR 0 5
63203: PUSH
63204: LD_VAR 0 4
63208: PUSH
63209: FOR_IN
63210: IFFALSE 63252
// if GetTech ( i , side ) <> state then
63212: LD_VAR 0 5
63216: PPUSH
63217: LD_VAR 0 1
63221: PPUSH
63222: CALL_OW 321
63226: PUSH
63227: LD_VAR 0 3
63231: NONEQUAL
63232: IFFALSE 63250
// result := result diff i ;
63234: LD_ADDR_VAR 0 4
63238: PUSH
63239: LD_VAR 0 4
63243: PUSH
63244: LD_VAR 0 5
63248: DIFF
63249: ST_TO_ADDR
63250: GO 63209
63252: POP
63253: POP
// end ;
63254: LD_VAR 0 4
63258: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63259: LD_INT 0
63261: PPUSH
63262: PPUSH
63263: PPUSH
// result := true ;
63264: LD_ADDR_VAR 0 3
63268: PUSH
63269: LD_INT 1
63271: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63272: LD_ADDR_VAR 0 5
63276: PUSH
63277: LD_VAR 0 2
63281: PPUSH
63282: CALL_OW 480
63286: ST_TO_ADDR
// if not tmp then
63287: LD_VAR 0 5
63291: NOT
63292: IFFALSE 63296
// exit ;
63294: GO 63345
// for i in tmp do
63296: LD_ADDR_VAR 0 4
63300: PUSH
63301: LD_VAR 0 5
63305: PUSH
63306: FOR_IN
63307: IFFALSE 63343
// if GetTech ( i , side ) <> state_researched then
63309: LD_VAR 0 4
63313: PPUSH
63314: LD_VAR 0 1
63318: PPUSH
63319: CALL_OW 321
63323: PUSH
63324: LD_INT 2
63326: NONEQUAL
63327: IFFALSE 63341
// begin result := false ;
63329: LD_ADDR_VAR 0 3
63333: PUSH
63334: LD_INT 0
63336: ST_TO_ADDR
// exit ;
63337: POP
63338: POP
63339: GO 63345
// end ;
63341: GO 63306
63343: POP
63344: POP
// end ;
63345: LD_VAR 0 3
63349: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63350: LD_INT 0
63352: PPUSH
63353: PPUSH
63354: PPUSH
63355: PPUSH
63356: PPUSH
63357: PPUSH
63358: PPUSH
63359: PPUSH
63360: PPUSH
63361: PPUSH
63362: PPUSH
63363: PPUSH
63364: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63365: LD_VAR 0 1
63369: NOT
63370: PUSH
63371: LD_VAR 0 1
63375: PPUSH
63376: CALL_OW 257
63380: PUSH
63381: LD_INT 9
63383: NONEQUAL
63384: OR
63385: IFFALSE 63389
// exit ;
63387: GO 63962
// side := GetSide ( unit ) ;
63389: LD_ADDR_VAR 0 9
63393: PUSH
63394: LD_VAR 0 1
63398: PPUSH
63399: CALL_OW 255
63403: ST_TO_ADDR
// tech_space := tech_spacanom ;
63404: LD_ADDR_VAR 0 12
63408: PUSH
63409: LD_INT 29
63411: ST_TO_ADDR
// tech_time := tech_taurad ;
63412: LD_ADDR_VAR 0 13
63416: PUSH
63417: LD_INT 28
63419: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63420: LD_ADDR_VAR 0 11
63424: PUSH
63425: LD_VAR 0 1
63429: PPUSH
63430: CALL_OW 310
63434: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63435: LD_VAR 0 11
63439: PPUSH
63440: CALL_OW 247
63444: PUSH
63445: LD_INT 2
63447: EQUAL
63448: IFFALSE 63452
// exit ;
63450: GO 63962
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63452: LD_ADDR_VAR 0 8
63456: PUSH
63457: LD_INT 81
63459: PUSH
63460: LD_VAR 0 9
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: PUSH
63469: LD_INT 3
63471: PUSH
63472: LD_INT 21
63474: PUSH
63475: LD_INT 3
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: PUSH
63482: EMPTY
63483: LIST
63484: LIST
63485: PUSH
63486: EMPTY
63487: LIST
63488: LIST
63489: PPUSH
63490: CALL_OW 69
63494: ST_TO_ADDR
// if not tmp then
63495: LD_VAR 0 8
63499: NOT
63500: IFFALSE 63504
// exit ;
63502: GO 63962
// if in_unit then
63504: LD_VAR 0 11
63508: IFFALSE 63532
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63510: LD_ADDR_VAR 0 10
63514: PUSH
63515: LD_VAR 0 8
63519: PPUSH
63520: LD_VAR 0 11
63524: PPUSH
63525: CALL_OW 74
63529: ST_TO_ADDR
63530: GO 63552
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63532: LD_ADDR_VAR 0 10
63536: PUSH
63537: LD_VAR 0 8
63541: PPUSH
63542: LD_VAR 0 1
63546: PPUSH
63547: CALL_OW 74
63551: ST_TO_ADDR
// if not enemy then
63552: LD_VAR 0 10
63556: NOT
63557: IFFALSE 63561
// exit ;
63559: GO 63962
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
63561: LD_VAR 0 11
63565: PUSH
63566: LD_VAR 0 11
63570: PPUSH
63571: LD_VAR 0 10
63575: PPUSH
63576: CALL_OW 296
63580: PUSH
63581: LD_INT 13
63583: GREATER
63584: AND
63585: PUSH
63586: LD_VAR 0 1
63590: PPUSH
63591: LD_VAR 0 10
63595: PPUSH
63596: CALL_OW 296
63600: PUSH
63601: LD_INT 12
63603: GREATER
63604: OR
63605: IFFALSE 63609
// exit ;
63607: GO 63962
// missile := [ 1 ] ;
63609: LD_ADDR_VAR 0 14
63613: PUSH
63614: LD_INT 1
63616: PUSH
63617: EMPTY
63618: LIST
63619: ST_TO_ADDR
// if Researched ( side , tech_space ) then
63620: LD_VAR 0 9
63624: PPUSH
63625: LD_VAR 0 12
63629: PPUSH
63630: CALL_OW 325
63634: IFFALSE 63663
// missile := Insert ( missile , missile + 1 , 2 ) ;
63636: LD_ADDR_VAR 0 14
63640: PUSH
63641: LD_VAR 0 14
63645: PPUSH
63646: LD_VAR 0 14
63650: PUSH
63651: LD_INT 1
63653: PLUS
63654: PPUSH
63655: LD_INT 2
63657: PPUSH
63658: CALL_OW 2
63662: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
63663: LD_VAR 0 9
63667: PPUSH
63668: LD_VAR 0 13
63672: PPUSH
63673: CALL_OW 325
63677: PUSH
63678: LD_VAR 0 10
63682: PPUSH
63683: CALL_OW 255
63687: PPUSH
63688: LD_VAR 0 13
63692: PPUSH
63693: CALL_OW 325
63697: NOT
63698: AND
63699: IFFALSE 63728
// missile := Insert ( missile , missile + 1 , 3 ) ;
63701: LD_ADDR_VAR 0 14
63705: PUSH
63706: LD_VAR 0 14
63710: PPUSH
63711: LD_VAR 0 14
63715: PUSH
63716: LD_INT 1
63718: PLUS
63719: PPUSH
63720: LD_INT 3
63722: PPUSH
63723: CALL_OW 2
63727: ST_TO_ADDR
// if missile < 2 then
63728: LD_VAR 0 14
63732: PUSH
63733: LD_INT 2
63735: LESS
63736: IFFALSE 63740
// exit ;
63738: GO 63962
// x := GetX ( enemy ) ;
63740: LD_ADDR_VAR 0 4
63744: PUSH
63745: LD_VAR 0 10
63749: PPUSH
63750: CALL_OW 250
63754: ST_TO_ADDR
// y := GetY ( enemy ) ;
63755: LD_ADDR_VAR 0 5
63759: PUSH
63760: LD_VAR 0 10
63764: PPUSH
63765: CALL_OW 251
63769: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
63770: LD_ADDR_VAR 0 6
63774: PUSH
63775: LD_VAR 0 4
63779: PUSH
63780: LD_INT 1
63782: NEG
63783: PPUSH
63784: LD_INT 1
63786: PPUSH
63787: CALL_OW 12
63791: PLUS
63792: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
63793: LD_ADDR_VAR 0 7
63797: PUSH
63798: LD_VAR 0 5
63802: PUSH
63803: LD_INT 1
63805: NEG
63806: PPUSH
63807: LD_INT 1
63809: PPUSH
63810: CALL_OW 12
63814: PLUS
63815: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63816: LD_VAR 0 6
63820: PPUSH
63821: LD_VAR 0 7
63825: PPUSH
63826: CALL_OW 488
63830: NOT
63831: IFFALSE 63853
// begin _x := x ;
63833: LD_ADDR_VAR 0 6
63837: PUSH
63838: LD_VAR 0 4
63842: ST_TO_ADDR
// _y := y ;
63843: LD_ADDR_VAR 0 7
63847: PUSH
63848: LD_VAR 0 5
63852: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
63853: LD_ADDR_VAR 0 3
63857: PUSH
63858: LD_INT 1
63860: PPUSH
63861: LD_VAR 0 14
63865: PPUSH
63866: CALL_OW 12
63870: ST_TO_ADDR
// case i of 1 :
63871: LD_VAR 0 3
63875: PUSH
63876: LD_INT 1
63878: DOUBLE
63879: EQUAL
63880: IFTRUE 63884
63882: GO 63901
63884: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
63885: LD_VAR 0 1
63889: PPUSH
63890: LD_VAR 0 10
63894: PPUSH
63895: CALL_OW 115
63899: GO 63962
63901: LD_INT 2
63903: DOUBLE
63904: EQUAL
63905: IFTRUE 63909
63907: GO 63931
63909: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
63910: LD_VAR 0 1
63914: PPUSH
63915: LD_VAR 0 6
63919: PPUSH
63920: LD_VAR 0 7
63924: PPUSH
63925: CALL_OW 153
63929: GO 63962
63931: LD_INT 3
63933: DOUBLE
63934: EQUAL
63935: IFTRUE 63939
63937: GO 63961
63939: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
63940: LD_VAR 0 1
63944: PPUSH
63945: LD_VAR 0 6
63949: PPUSH
63950: LD_VAR 0 7
63954: PPUSH
63955: CALL_OW 154
63959: GO 63962
63961: POP
// end ;
63962: LD_VAR 0 2
63966: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
63967: LD_INT 0
63969: PPUSH
63970: PPUSH
63971: PPUSH
63972: PPUSH
63973: PPUSH
63974: PPUSH
// if not unit or not building then
63975: LD_VAR 0 1
63979: NOT
63980: PUSH
63981: LD_VAR 0 2
63985: NOT
63986: OR
63987: IFFALSE 63991
// exit ;
63989: GO 64149
// x := GetX ( building ) ;
63991: LD_ADDR_VAR 0 5
63995: PUSH
63996: LD_VAR 0 2
64000: PPUSH
64001: CALL_OW 250
64005: ST_TO_ADDR
// y := GetY ( building ) ;
64006: LD_ADDR_VAR 0 6
64010: PUSH
64011: LD_VAR 0 2
64015: PPUSH
64016: CALL_OW 251
64020: ST_TO_ADDR
// for i = 0 to 5 do
64021: LD_ADDR_VAR 0 4
64025: PUSH
64026: DOUBLE
64027: LD_INT 0
64029: DEC
64030: ST_TO_ADDR
64031: LD_INT 5
64033: PUSH
64034: FOR_TO
64035: IFFALSE 64147
// begin _x := ShiftX ( x , i , 3 ) ;
64037: LD_ADDR_VAR 0 7
64041: PUSH
64042: LD_VAR 0 5
64046: PPUSH
64047: LD_VAR 0 4
64051: PPUSH
64052: LD_INT 3
64054: PPUSH
64055: CALL_OW 272
64059: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64060: LD_ADDR_VAR 0 8
64064: PUSH
64065: LD_VAR 0 6
64069: PPUSH
64070: LD_VAR 0 4
64074: PPUSH
64075: LD_INT 3
64077: PPUSH
64078: CALL_OW 273
64082: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64083: LD_VAR 0 7
64087: PPUSH
64088: LD_VAR 0 8
64092: PPUSH
64093: CALL_OW 488
64097: NOT
64098: IFFALSE 64102
// continue ;
64100: GO 64034
// if HexInfo ( _x , _y ) = 0 then
64102: LD_VAR 0 7
64106: PPUSH
64107: LD_VAR 0 8
64111: PPUSH
64112: CALL_OW 428
64116: PUSH
64117: LD_INT 0
64119: EQUAL
64120: IFFALSE 64145
// begin ComMoveXY ( unit , _x , _y ) ;
64122: LD_VAR 0 1
64126: PPUSH
64127: LD_VAR 0 7
64131: PPUSH
64132: LD_VAR 0 8
64136: PPUSH
64137: CALL_OW 111
// exit ;
64141: POP
64142: POP
64143: GO 64149
// end ; end ;
64145: GO 64034
64147: POP
64148: POP
// end ;
64149: LD_VAR 0 3
64153: RET
// export function ScanBase ( side , base_area ) ; begin
64154: LD_INT 0
64156: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64157: LD_ADDR_VAR 0 3
64161: PUSH
64162: LD_VAR 0 2
64166: PPUSH
64167: LD_INT 81
64169: PUSH
64170: LD_VAR 0 1
64174: PUSH
64175: EMPTY
64176: LIST
64177: LIST
64178: PPUSH
64179: CALL_OW 70
64183: ST_TO_ADDR
// end ;
64184: LD_VAR 0 3
64188: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
64189: LD_INT 0
64191: PPUSH
64192: PPUSH
64193: PPUSH
64194: PPUSH
// result := false ;
64195: LD_ADDR_VAR 0 2
64199: PUSH
64200: LD_INT 0
64202: ST_TO_ADDR
// side := GetSide ( unit ) ;
64203: LD_ADDR_VAR 0 3
64207: PUSH
64208: LD_VAR 0 1
64212: PPUSH
64213: CALL_OW 255
64217: ST_TO_ADDR
// nat := GetNation ( unit ) ;
64218: LD_ADDR_VAR 0 4
64222: PUSH
64223: LD_VAR 0 1
64227: PPUSH
64228: CALL_OW 248
64232: ST_TO_ADDR
// case nat of 1 :
64233: LD_VAR 0 4
64237: PUSH
64238: LD_INT 1
64240: DOUBLE
64241: EQUAL
64242: IFTRUE 64246
64244: GO 64257
64246: POP
// tech := tech_lassight ; 2 :
64247: LD_ADDR_VAR 0 5
64251: PUSH
64252: LD_INT 12
64254: ST_TO_ADDR
64255: GO 64296
64257: LD_INT 2
64259: DOUBLE
64260: EQUAL
64261: IFTRUE 64265
64263: GO 64276
64265: POP
// tech := tech_mortar ; 3 :
64266: LD_ADDR_VAR 0 5
64270: PUSH
64271: LD_INT 41
64273: ST_TO_ADDR
64274: GO 64296
64276: LD_INT 3
64278: DOUBLE
64279: EQUAL
64280: IFTRUE 64284
64282: GO 64295
64284: POP
// tech := tech_bazooka ; end ;
64285: LD_ADDR_VAR 0 5
64289: PUSH
64290: LD_INT 44
64292: ST_TO_ADDR
64293: GO 64296
64295: POP
// if Researched ( side , tech ) then
64296: LD_VAR 0 3
64300: PPUSH
64301: LD_VAR 0 5
64305: PPUSH
64306: CALL_OW 325
64310: IFFALSE 64337
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
64312: LD_ADDR_VAR 0 2
64316: PUSH
64317: LD_INT 5
64319: PUSH
64320: LD_INT 8
64322: PUSH
64323: LD_INT 9
64325: PUSH
64326: EMPTY
64327: LIST
64328: LIST
64329: LIST
64330: PUSH
64331: LD_VAR 0 4
64335: ARRAY
64336: ST_TO_ADDR
// end ;
64337: LD_VAR 0 2
64341: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
64342: LD_INT 0
64344: PPUSH
64345: PPUSH
64346: PPUSH
// if not mines then
64347: LD_VAR 0 2
64351: NOT
64352: IFFALSE 64356
// exit ;
64354: GO 64500
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64356: LD_ADDR_VAR 0 5
64360: PUSH
64361: LD_INT 81
64363: PUSH
64364: LD_VAR 0 1
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 3
64375: PUSH
64376: LD_INT 21
64378: PUSH
64379: LD_INT 3
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: EMPTY
64391: LIST
64392: LIST
64393: PPUSH
64394: CALL_OW 69
64398: ST_TO_ADDR
// for i in mines do
64399: LD_ADDR_VAR 0 4
64403: PUSH
64404: LD_VAR 0 2
64408: PUSH
64409: FOR_IN
64410: IFFALSE 64498
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
64412: LD_VAR 0 4
64416: PUSH
64417: LD_INT 1
64419: ARRAY
64420: PPUSH
64421: LD_VAR 0 4
64425: PUSH
64426: LD_INT 2
64428: ARRAY
64429: PPUSH
64430: CALL_OW 458
64434: NOT
64435: IFFALSE 64439
// continue ;
64437: GO 64409
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
64439: LD_VAR 0 4
64443: PUSH
64444: LD_INT 1
64446: ARRAY
64447: PPUSH
64448: LD_VAR 0 4
64452: PUSH
64453: LD_INT 2
64455: ARRAY
64456: PPUSH
64457: CALL_OW 428
64461: PUSH
64462: LD_VAR 0 5
64466: IN
64467: IFFALSE 64496
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
64469: LD_VAR 0 4
64473: PUSH
64474: LD_INT 1
64476: ARRAY
64477: PPUSH
64478: LD_VAR 0 4
64482: PUSH
64483: LD_INT 2
64485: ARRAY
64486: PPUSH
64487: LD_VAR 0 1
64491: PPUSH
64492: CALL_OW 456
// end ;
64496: GO 64409
64498: POP
64499: POP
// end ;
64500: LD_VAR 0 3
64504: RET
// export function Count ( array ) ; var i ; begin
64505: LD_INT 0
64507: PPUSH
64508: PPUSH
// result := 0 ;
64509: LD_ADDR_VAR 0 2
64513: PUSH
64514: LD_INT 0
64516: ST_TO_ADDR
// for i in array do
64517: LD_ADDR_VAR 0 3
64521: PUSH
64522: LD_VAR 0 1
64526: PUSH
64527: FOR_IN
64528: IFFALSE 64552
// if i then
64530: LD_VAR 0 3
64534: IFFALSE 64550
// result := result + 1 ;
64536: LD_ADDR_VAR 0 2
64540: PUSH
64541: LD_VAR 0 2
64545: PUSH
64546: LD_INT 1
64548: PLUS
64549: ST_TO_ADDR
64550: GO 64527
64552: POP
64553: POP
// end ;
64554: LD_VAR 0 2
64558: RET
// export function IsEmpty ( building ) ; begin
64559: LD_INT 0
64561: PPUSH
// if not building then
64562: LD_VAR 0 1
64566: NOT
64567: IFFALSE 64571
// exit ;
64569: GO 64614
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
64571: LD_ADDR_VAR 0 2
64575: PUSH
64576: LD_VAR 0 1
64580: PUSH
64581: LD_INT 22
64583: PUSH
64584: LD_VAR 0 1
64588: PPUSH
64589: CALL_OW 255
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: PUSH
64598: LD_INT 58
64600: PUSH
64601: EMPTY
64602: LIST
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: PPUSH
64608: CALL_OW 69
64612: IN
64613: ST_TO_ADDR
// end ;
64614: LD_VAR 0 2
64618: RET
// export function IsNotFull ( building ) ; begin
64619: LD_INT 0
64621: PPUSH
// if not building then
64622: LD_VAR 0 1
64626: NOT
64627: IFFALSE 64631
// exit ;
64629: GO 64650
// result := UnitsInside ( building ) < 6 ;
64631: LD_ADDR_VAR 0 2
64635: PUSH
64636: LD_VAR 0 1
64640: PPUSH
64641: CALL_OW 313
64645: PUSH
64646: LD_INT 6
64648: LESS
64649: ST_TO_ADDR
// end ;
64650: LD_VAR 0 2
64654: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
64655: LD_INT 0
64657: PPUSH
64658: PPUSH
64659: PPUSH
64660: PPUSH
// tmp := [ ] ;
64661: LD_ADDR_VAR 0 3
64665: PUSH
64666: EMPTY
64667: ST_TO_ADDR
// list := [ ] ;
64668: LD_ADDR_VAR 0 5
64672: PUSH
64673: EMPTY
64674: ST_TO_ADDR
// for i = 16 to 25 do
64675: LD_ADDR_VAR 0 4
64679: PUSH
64680: DOUBLE
64681: LD_INT 16
64683: DEC
64684: ST_TO_ADDR
64685: LD_INT 25
64687: PUSH
64688: FOR_TO
64689: IFFALSE 64762
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
64691: LD_ADDR_VAR 0 3
64695: PUSH
64696: LD_VAR 0 3
64700: PUSH
64701: LD_INT 22
64703: PUSH
64704: LD_VAR 0 1
64708: PPUSH
64709: CALL_OW 255
64713: PUSH
64714: EMPTY
64715: LIST
64716: LIST
64717: PUSH
64718: LD_INT 91
64720: PUSH
64721: LD_VAR 0 1
64725: PUSH
64726: LD_INT 6
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: LIST
64733: PUSH
64734: LD_INT 30
64736: PUSH
64737: LD_VAR 0 4
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: LIST
64750: PUSH
64751: EMPTY
64752: LIST
64753: PPUSH
64754: CALL_OW 69
64758: ADD
64759: ST_TO_ADDR
64760: GO 64688
64762: POP
64763: POP
// for i = 1 to tmp do
64764: LD_ADDR_VAR 0 4
64768: PUSH
64769: DOUBLE
64770: LD_INT 1
64772: DEC
64773: ST_TO_ADDR
64774: LD_VAR 0 3
64778: PUSH
64779: FOR_TO
64780: IFFALSE 64868
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
64782: LD_ADDR_VAR 0 5
64786: PUSH
64787: LD_VAR 0 5
64791: PUSH
64792: LD_VAR 0 3
64796: PUSH
64797: LD_VAR 0 4
64801: ARRAY
64802: PPUSH
64803: CALL_OW 266
64807: PUSH
64808: LD_VAR 0 3
64812: PUSH
64813: LD_VAR 0 4
64817: ARRAY
64818: PPUSH
64819: CALL_OW 250
64823: PUSH
64824: LD_VAR 0 3
64828: PUSH
64829: LD_VAR 0 4
64833: ARRAY
64834: PPUSH
64835: CALL_OW 251
64839: PUSH
64840: LD_VAR 0 3
64844: PUSH
64845: LD_VAR 0 4
64849: ARRAY
64850: PPUSH
64851: CALL_OW 254
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: PUSH
64862: EMPTY
64863: LIST
64864: ADD
64865: ST_TO_ADDR
64866: GO 64779
64868: POP
64869: POP
// result := list ;
64870: LD_ADDR_VAR 0 2
64874: PUSH
64875: LD_VAR 0 5
64879: ST_TO_ADDR
// end ;
64880: LD_VAR 0 2
64884: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
64885: LD_INT 0
64887: PPUSH
64888: PPUSH
64889: PPUSH
64890: PPUSH
64891: PPUSH
64892: PPUSH
64893: PPUSH
// if not factory then
64894: LD_VAR 0 1
64898: NOT
64899: IFFALSE 64903
// exit ;
64901: GO 65496
// if control = control_apeman then
64903: LD_VAR 0 4
64907: PUSH
64908: LD_INT 5
64910: EQUAL
64911: IFFALSE 65020
// begin tmp := UnitsInside ( factory ) ;
64913: LD_ADDR_VAR 0 8
64917: PUSH
64918: LD_VAR 0 1
64922: PPUSH
64923: CALL_OW 313
64927: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
64928: LD_VAR 0 8
64932: PPUSH
64933: LD_INT 25
64935: PUSH
64936: LD_INT 12
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: PPUSH
64943: CALL_OW 72
64947: NOT
64948: IFFALSE 64958
// control := control_manual ;
64950: LD_ADDR_VAR 0 4
64954: PUSH
64955: LD_INT 1
64957: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
64958: LD_ADDR_VAR 0 8
64962: PUSH
64963: LD_VAR 0 1
64967: PPUSH
64968: CALL 64655 0 1
64972: ST_TO_ADDR
// if tmp then
64973: LD_VAR 0 8
64977: IFFALSE 65020
// begin for i in tmp do
64979: LD_ADDR_VAR 0 7
64983: PUSH
64984: LD_VAR 0 8
64988: PUSH
64989: FOR_IN
64990: IFFALSE 65018
// if i [ 1 ] = b_ext_radio then
64992: LD_VAR 0 7
64996: PUSH
64997: LD_INT 1
64999: ARRAY
65000: PUSH
65001: LD_INT 22
65003: EQUAL
65004: IFFALSE 65016
// begin control := control_remote ;
65006: LD_ADDR_VAR 0 4
65010: PUSH
65011: LD_INT 2
65013: ST_TO_ADDR
// break ;
65014: GO 65018
// end ;
65016: GO 64989
65018: POP
65019: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65020: LD_VAR 0 1
65024: PPUSH
65025: LD_VAR 0 2
65029: PPUSH
65030: LD_VAR 0 3
65034: PPUSH
65035: LD_VAR 0 4
65039: PPUSH
65040: LD_VAR 0 5
65044: PPUSH
65045: CALL_OW 448
65049: IFFALSE 65084
// begin result := [ chassis , engine , control , weapon ] ;
65051: LD_ADDR_VAR 0 6
65055: PUSH
65056: LD_VAR 0 2
65060: PUSH
65061: LD_VAR 0 3
65065: PUSH
65066: LD_VAR 0 4
65070: PUSH
65071: LD_VAR 0 5
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: LIST
65080: LIST
65081: ST_TO_ADDR
// exit ;
65082: GO 65496
// end ; _chassis := AvailableChassisList ( factory ) ;
65084: LD_ADDR_VAR 0 9
65088: PUSH
65089: LD_VAR 0 1
65093: PPUSH
65094: CALL_OW 475
65098: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
65099: LD_ADDR_VAR 0 11
65103: PUSH
65104: LD_VAR 0 1
65108: PPUSH
65109: CALL_OW 476
65113: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
65114: LD_ADDR_VAR 0 12
65118: PUSH
65119: LD_VAR 0 1
65123: PPUSH
65124: CALL_OW 477
65128: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
65129: LD_ADDR_VAR 0 10
65133: PUSH
65134: LD_VAR 0 1
65138: PPUSH
65139: CALL_OW 478
65143: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
65144: LD_VAR 0 9
65148: NOT
65149: PUSH
65150: LD_VAR 0 11
65154: NOT
65155: OR
65156: PUSH
65157: LD_VAR 0 12
65161: NOT
65162: OR
65163: PUSH
65164: LD_VAR 0 10
65168: NOT
65169: OR
65170: IFFALSE 65205
// begin result := [ chassis , engine , control , weapon ] ;
65172: LD_ADDR_VAR 0 6
65176: PUSH
65177: LD_VAR 0 2
65181: PUSH
65182: LD_VAR 0 3
65186: PUSH
65187: LD_VAR 0 4
65191: PUSH
65192: LD_VAR 0 5
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: ST_TO_ADDR
// exit ;
65203: GO 65496
// end ; if not chassis in _chassis then
65205: LD_VAR 0 2
65209: PUSH
65210: LD_VAR 0 9
65214: IN
65215: NOT
65216: IFFALSE 65242
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
65218: LD_ADDR_VAR 0 2
65222: PUSH
65223: LD_VAR 0 9
65227: PUSH
65228: LD_INT 1
65230: PPUSH
65231: LD_VAR 0 9
65235: PPUSH
65236: CALL_OW 12
65240: ARRAY
65241: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
65242: LD_VAR 0 2
65246: PPUSH
65247: LD_VAR 0 3
65251: PPUSH
65252: CALL 65501 0 2
65256: NOT
65257: IFFALSE 65316
// repeat engine := _engine [ 1 ] ;
65259: LD_ADDR_VAR 0 3
65263: PUSH
65264: LD_VAR 0 11
65268: PUSH
65269: LD_INT 1
65271: ARRAY
65272: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
65273: LD_ADDR_VAR 0 11
65277: PUSH
65278: LD_VAR 0 11
65282: PPUSH
65283: LD_INT 1
65285: PPUSH
65286: CALL_OW 3
65290: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
65291: LD_VAR 0 2
65295: PPUSH
65296: LD_VAR 0 3
65300: PPUSH
65301: CALL 65501 0 2
65305: PUSH
65306: LD_VAR 0 11
65310: PUSH
65311: EMPTY
65312: EQUAL
65313: OR
65314: IFFALSE 65259
// if not control in _control then
65316: LD_VAR 0 4
65320: PUSH
65321: LD_VAR 0 12
65325: IN
65326: NOT
65327: IFFALSE 65353
// control := _control [ rand ( 1 , _control ) ] ;
65329: LD_ADDR_VAR 0 4
65333: PUSH
65334: LD_VAR 0 12
65338: PUSH
65339: LD_INT 1
65341: PPUSH
65342: LD_VAR 0 12
65346: PPUSH
65347: CALL_OW 12
65351: ARRAY
65352: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
65353: LD_VAR 0 2
65357: PPUSH
65358: LD_VAR 0 5
65362: PPUSH
65363: CALL 65721 0 2
65367: NOT
65368: IFFALSE 65427
// repeat weapon := _weapon [ 1 ] ;
65370: LD_ADDR_VAR 0 5
65374: PUSH
65375: LD_VAR 0 10
65379: PUSH
65380: LD_INT 1
65382: ARRAY
65383: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
65384: LD_ADDR_VAR 0 10
65388: PUSH
65389: LD_VAR 0 10
65393: PPUSH
65394: LD_INT 1
65396: PPUSH
65397: CALL_OW 3
65401: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
65402: LD_VAR 0 2
65406: PPUSH
65407: LD_VAR 0 5
65411: PPUSH
65412: CALL 65721 0 2
65416: PUSH
65417: LD_VAR 0 10
65421: PUSH
65422: EMPTY
65423: EQUAL
65424: OR
65425: IFFALSE 65370
// result := [ ] ;
65427: LD_ADDR_VAR 0 6
65431: PUSH
65432: EMPTY
65433: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65434: LD_VAR 0 1
65438: PPUSH
65439: LD_VAR 0 2
65443: PPUSH
65444: LD_VAR 0 3
65448: PPUSH
65449: LD_VAR 0 4
65453: PPUSH
65454: LD_VAR 0 5
65458: PPUSH
65459: CALL_OW 448
65463: IFFALSE 65496
// result := [ chassis , engine , control , weapon ] ;
65465: LD_ADDR_VAR 0 6
65469: PUSH
65470: LD_VAR 0 2
65474: PUSH
65475: LD_VAR 0 3
65479: PUSH
65480: LD_VAR 0 4
65484: PUSH
65485: LD_VAR 0 5
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: ST_TO_ADDR
// end ;
65496: LD_VAR 0 6
65500: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
65501: LD_INT 0
65503: PPUSH
// if not chassis or not engine then
65504: LD_VAR 0 1
65508: NOT
65509: PUSH
65510: LD_VAR 0 2
65514: NOT
65515: OR
65516: IFFALSE 65520
// exit ;
65518: GO 65716
// case engine of engine_solar :
65520: LD_VAR 0 2
65524: PUSH
65525: LD_INT 2
65527: DOUBLE
65528: EQUAL
65529: IFTRUE 65533
65531: GO 65571
65533: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
65534: LD_ADDR_VAR 0 3
65538: PUSH
65539: LD_INT 11
65541: PUSH
65542: LD_INT 12
65544: PUSH
65545: LD_INT 13
65547: PUSH
65548: LD_INT 14
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: LD_INT 2
65556: PUSH
65557: LD_INT 3
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: ST_TO_ADDR
65569: GO 65700
65571: LD_INT 1
65573: DOUBLE
65574: EQUAL
65575: IFTRUE 65579
65577: GO 65641
65579: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
65580: LD_ADDR_VAR 0 3
65584: PUSH
65585: LD_INT 11
65587: PUSH
65588: LD_INT 12
65590: PUSH
65591: LD_INT 13
65593: PUSH
65594: LD_INT 14
65596: PUSH
65597: LD_INT 1
65599: PUSH
65600: LD_INT 2
65602: PUSH
65603: LD_INT 3
65605: PUSH
65606: LD_INT 4
65608: PUSH
65609: LD_INT 5
65611: PUSH
65612: LD_INT 21
65614: PUSH
65615: LD_INT 23
65617: PUSH
65618: LD_INT 22
65620: PUSH
65621: LD_INT 24
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: ST_TO_ADDR
65639: GO 65700
65641: LD_INT 3
65643: DOUBLE
65644: EQUAL
65645: IFTRUE 65649
65647: GO 65699
65649: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
65650: LD_ADDR_VAR 0 3
65654: PUSH
65655: LD_INT 13
65657: PUSH
65658: LD_INT 14
65660: PUSH
65661: LD_INT 2
65663: PUSH
65664: LD_INT 3
65666: PUSH
65667: LD_INT 4
65669: PUSH
65670: LD_INT 5
65672: PUSH
65673: LD_INT 21
65675: PUSH
65676: LD_INT 22
65678: PUSH
65679: LD_INT 23
65681: PUSH
65682: LD_INT 24
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: ST_TO_ADDR
65697: GO 65700
65699: POP
// result := ( chassis in result ) ;
65700: LD_ADDR_VAR 0 3
65704: PUSH
65705: LD_VAR 0 1
65709: PUSH
65710: LD_VAR 0 3
65714: IN
65715: ST_TO_ADDR
// end ;
65716: LD_VAR 0 3
65720: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
65721: LD_INT 0
65723: PPUSH
// if not chassis or not weapon then
65724: LD_VAR 0 1
65728: NOT
65729: PUSH
65730: LD_VAR 0 2
65734: NOT
65735: OR
65736: IFFALSE 65740
// exit ;
65738: GO 66802
// case weapon of us_machine_gun :
65740: LD_VAR 0 2
65744: PUSH
65745: LD_INT 2
65747: DOUBLE
65748: EQUAL
65749: IFTRUE 65753
65751: GO 65783
65753: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
65754: LD_ADDR_VAR 0 3
65758: PUSH
65759: LD_INT 1
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: LD_INT 3
65767: PUSH
65768: LD_INT 4
65770: PUSH
65771: LD_INT 5
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: ST_TO_ADDR
65781: GO 66786
65783: LD_INT 3
65785: DOUBLE
65786: EQUAL
65787: IFTRUE 65791
65789: GO 65821
65791: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
65792: LD_ADDR_VAR 0 3
65796: PUSH
65797: LD_INT 1
65799: PUSH
65800: LD_INT 2
65802: PUSH
65803: LD_INT 3
65805: PUSH
65806: LD_INT 4
65808: PUSH
65809: LD_INT 5
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: ST_TO_ADDR
65819: GO 66786
65821: LD_INT 11
65823: DOUBLE
65824: EQUAL
65825: IFTRUE 65829
65827: GO 65859
65829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
65830: LD_ADDR_VAR 0 3
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: LD_INT 2
65840: PUSH
65841: LD_INT 3
65843: PUSH
65844: LD_INT 4
65846: PUSH
65847: LD_INT 5
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: ST_TO_ADDR
65857: GO 66786
65859: LD_INT 4
65861: DOUBLE
65862: EQUAL
65863: IFTRUE 65867
65865: GO 65893
65867: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
65868: LD_ADDR_VAR 0 3
65872: PUSH
65873: LD_INT 2
65875: PUSH
65876: LD_INT 3
65878: PUSH
65879: LD_INT 4
65881: PUSH
65882: LD_INT 5
65884: PUSH
65885: EMPTY
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: ST_TO_ADDR
65891: GO 66786
65893: LD_INT 5
65895: DOUBLE
65896: EQUAL
65897: IFTRUE 65901
65899: GO 65927
65901: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
65902: LD_ADDR_VAR 0 3
65906: PUSH
65907: LD_INT 2
65909: PUSH
65910: LD_INT 3
65912: PUSH
65913: LD_INT 4
65915: PUSH
65916: LD_INT 5
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: ST_TO_ADDR
65925: GO 66786
65927: LD_INT 9
65929: DOUBLE
65930: EQUAL
65931: IFTRUE 65935
65933: GO 65961
65935: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
65936: LD_ADDR_VAR 0 3
65940: PUSH
65941: LD_INT 2
65943: PUSH
65944: LD_INT 3
65946: PUSH
65947: LD_INT 4
65949: PUSH
65950: LD_INT 5
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: ST_TO_ADDR
65959: GO 66786
65961: LD_INT 7
65963: DOUBLE
65964: EQUAL
65965: IFTRUE 65969
65967: GO 65995
65969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
65970: LD_ADDR_VAR 0 3
65974: PUSH
65975: LD_INT 2
65977: PUSH
65978: LD_INT 3
65980: PUSH
65981: LD_INT 4
65983: PUSH
65984: LD_INT 5
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: ST_TO_ADDR
65993: GO 66786
65995: LD_INT 12
65997: DOUBLE
65998: EQUAL
65999: IFTRUE 66003
66001: GO 66029
66003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66004: LD_ADDR_VAR 0 3
66008: PUSH
66009: LD_INT 2
66011: PUSH
66012: LD_INT 3
66014: PUSH
66015: LD_INT 4
66017: PUSH
66018: LD_INT 5
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: LIST
66025: LIST
66026: ST_TO_ADDR
66027: GO 66786
66029: LD_INT 13
66031: DOUBLE
66032: EQUAL
66033: IFTRUE 66037
66035: GO 66063
66037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
66038: LD_ADDR_VAR 0 3
66042: PUSH
66043: LD_INT 2
66045: PUSH
66046: LD_INT 3
66048: PUSH
66049: LD_INT 4
66051: PUSH
66052: LD_INT 5
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: ST_TO_ADDR
66061: GO 66786
66063: LD_INT 14
66065: DOUBLE
66066: EQUAL
66067: IFTRUE 66071
66069: GO 66089
66071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
66072: LD_ADDR_VAR 0 3
66076: PUSH
66077: LD_INT 4
66079: PUSH
66080: LD_INT 5
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: ST_TO_ADDR
66087: GO 66786
66089: LD_INT 6
66091: DOUBLE
66092: EQUAL
66093: IFTRUE 66097
66095: GO 66115
66097: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
66098: LD_ADDR_VAR 0 3
66102: PUSH
66103: LD_INT 4
66105: PUSH
66106: LD_INT 5
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: ST_TO_ADDR
66113: GO 66786
66115: LD_INT 10
66117: DOUBLE
66118: EQUAL
66119: IFTRUE 66123
66121: GO 66141
66123: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
66124: LD_ADDR_VAR 0 3
66128: PUSH
66129: LD_INT 4
66131: PUSH
66132: LD_INT 5
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: ST_TO_ADDR
66139: GO 66786
66141: LD_INT 22
66143: DOUBLE
66144: EQUAL
66145: IFTRUE 66149
66147: GO 66175
66149: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
66150: LD_ADDR_VAR 0 3
66154: PUSH
66155: LD_INT 11
66157: PUSH
66158: LD_INT 12
66160: PUSH
66161: LD_INT 13
66163: PUSH
66164: LD_INT 14
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: ST_TO_ADDR
66173: GO 66786
66175: LD_INT 23
66177: DOUBLE
66178: EQUAL
66179: IFTRUE 66183
66181: GO 66209
66183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
66184: LD_ADDR_VAR 0 3
66188: PUSH
66189: LD_INT 11
66191: PUSH
66192: LD_INT 12
66194: PUSH
66195: LD_INT 13
66197: PUSH
66198: LD_INT 14
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: ST_TO_ADDR
66207: GO 66786
66209: LD_INT 24
66211: DOUBLE
66212: EQUAL
66213: IFTRUE 66217
66215: GO 66243
66217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
66218: LD_ADDR_VAR 0 3
66222: PUSH
66223: LD_INT 11
66225: PUSH
66226: LD_INT 12
66228: PUSH
66229: LD_INT 13
66231: PUSH
66232: LD_INT 14
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: ST_TO_ADDR
66241: GO 66786
66243: LD_INT 30
66245: DOUBLE
66246: EQUAL
66247: IFTRUE 66251
66249: GO 66277
66251: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
66252: LD_ADDR_VAR 0 3
66256: PUSH
66257: LD_INT 11
66259: PUSH
66260: LD_INT 12
66262: PUSH
66263: LD_INT 13
66265: PUSH
66266: LD_INT 14
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: ST_TO_ADDR
66275: GO 66786
66277: LD_INT 25
66279: DOUBLE
66280: EQUAL
66281: IFTRUE 66285
66283: GO 66303
66285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
66286: LD_ADDR_VAR 0 3
66290: PUSH
66291: LD_INT 13
66293: PUSH
66294: LD_INT 14
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: ST_TO_ADDR
66301: GO 66786
66303: LD_INT 27
66305: DOUBLE
66306: EQUAL
66307: IFTRUE 66311
66309: GO 66329
66311: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
66312: LD_ADDR_VAR 0 3
66316: PUSH
66317: LD_INT 13
66319: PUSH
66320: LD_INT 14
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: ST_TO_ADDR
66327: GO 66786
66329: LD_EXP 78
66333: DOUBLE
66334: EQUAL
66335: IFTRUE 66339
66337: GO 66365
66339: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
66340: LD_ADDR_VAR 0 3
66344: PUSH
66345: LD_INT 11
66347: PUSH
66348: LD_INT 12
66350: PUSH
66351: LD_INT 13
66353: PUSH
66354: LD_INT 14
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: ST_TO_ADDR
66363: GO 66786
66365: LD_INT 28
66367: DOUBLE
66368: EQUAL
66369: IFTRUE 66373
66371: GO 66391
66373: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
66374: LD_ADDR_VAR 0 3
66378: PUSH
66379: LD_INT 13
66381: PUSH
66382: LD_INT 14
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: ST_TO_ADDR
66389: GO 66786
66391: LD_INT 29
66393: DOUBLE
66394: EQUAL
66395: IFTRUE 66399
66397: GO 66417
66399: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
66400: LD_ADDR_VAR 0 3
66404: PUSH
66405: LD_INT 13
66407: PUSH
66408: LD_INT 14
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: ST_TO_ADDR
66415: GO 66786
66417: LD_INT 31
66419: DOUBLE
66420: EQUAL
66421: IFTRUE 66425
66423: GO 66443
66425: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
66426: LD_ADDR_VAR 0 3
66430: PUSH
66431: LD_INT 13
66433: PUSH
66434: LD_INT 14
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: ST_TO_ADDR
66441: GO 66786
66443: LD_INT 26
66445: DOUBLE
66446: EQUAL
66447: IFTRUE 66451
66449: GO 66469
66451: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
66452: LD_ADDR_VAR 0 3
66456: PUSH
66457: LD_INT 13
66459: PUSH
66460: LD_INT 14
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: ST_TO_ADDR
66467: GO 66786
66469: LD_INT 42
66471: DOUBLE
66472: EQUAL
66473: IFTRUE 66477
66475: GO 66503
66477: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
66478: LD_ADDR_VAR 0 3
66482: PUSH
66483: LD_INT 21
66485: PUSH
66486: LD_INT 22
66488: PUSH
66489: LD_INT 23
66491: PUSH
66492: LD_INT 24
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: ST_TO_ADDR
66501: GO 66786
66503: LD_INT 43
66505: DOUBLE
66506: EQUAL
66507: IFTRUE 66511
66509: GO 66537
66511: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
66512: LD_ADDR_VAR 0 3
66516: PUSH
66517: LD_INT 21
66519: PUSH
66520: LD_INT 22
66522: PUSH
66523: LD_INT 23
66525: PUSH
66526: LD_INT 24
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: ST_TO_ADDR
66535: GO 66786
66537: LD_INT 44
66539: DOUBLE
66540: EQUAL
66541: IFTRUE 66545
66543: GO 66571
66545: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
66546: LD_ADDR_VAR 0 3
66550: PUSH
66551: LD_INT 21
66553: PUSH
66554: LD_INT 22
66556: PUSH
66557: LD_INT 23
66559: PUSH
66560: LD_INT 24
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: ST_TO_ADDR
66569: GO 66786
66571: LD_INT 45
66573: DOUBLE
66574: EQUAL
66575: IFTRUE 66579
66577: GO 66605
66579: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
66580: LD_ADDR_VAR 0 3
66584: PUSH
66585: LD_INT 21
66587: PUSH
66588: LD_INT 22
66590: PUSH
66591: LD_INT 23
66593: PUSH
66594: LD_INT 24
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: ST_TO_ADDR
66603: GO 66786
66605: LD_INT 49
66607: DOUBLE
66608: EQUAL
66609: IFTRUE 66613
66611: GO 66639
66613: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
66614: LD_ADDR_VAR 0 3
66618: PUSH
66619: LD_INT 21
66621: PUSH
66622: LD_INT 22
66624: PUSH
66625: LD_INT 23
66627: PUSH
66628: LD_INT 24
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: ST_TO_ADDR
66637: GO 66786
66639: LD_INT 51
66641: DOUBLE
66642: EQUAL
66643: IFTRUE 66647
66645: GO 66673
66647: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
66648: LD_ADDR_VAR 0 3
66652: PUSH
66653: LD_INT 21
66655: PUSH
66656: LD_INT 22
66658: PUSH
66659: LD_INT 23
66661: PUSH
66662: LD_INT 24
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: ST_TO_ADDR
66671: GO 66786
66673: LD_INT 52
66675: DOUBLE
66676: EQUAL
66677: IFTRUE 66681
66679: GO 66707
66681: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
66682: LD_ADDR_VAR 0 3
66686: PUSH
66687: LD_INT 21
66689: PUSH
66690: LD_INT 22
66692: PUSH
66693: LD_INT 23
66695: PUSH
66696: LD_INT 24
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: ST_TO_ADDR
66705: GO 66786
66707: LD_INT 53
66709: DOUBLE
66710: EQUAL
66711: IFTRUE 66715
66713: GO 66733
66715: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
66716: LD_ADDR_VAR 0 3
66720: PUSH
66721: LD_INT 23
66723: PUSH
66724: LD_INT 24
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: ST_TO_ADDR
66731: GO 66786
66733: LD_INT 46
66735: DOUBLE
66736: EQUAL
66737: IFTRUE 66741
66739: GO 66759
66741: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
66742: LD_ADDR_VAR 0 3
66746: PUSH
66747: LD_INT 23
66749: PUSH
66750: LD_INT 24
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: ST_TO_ADDR
66757: GO 66786
66759: LD_INT 47
66761: DOUBLE
66762: EQUAL
66763: IFTRUE 66767
66765: GO 66785
66767: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66768: LD_ADDR_VAR 0 3
66772: PUSH
66773: LD_INT 23
66775: PUSH
66776: LD_INT 24
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: ST_TO_ADDR
66783: GO 66786
66785: POP
// result := ( chassis in result ) ;
66786: LD_ADDR_VAR 0 3
66790: PUSH
66791: LD_VAR 0 1
66795: PUSH
66796: LD_VAR 0 3
66800: IN
66801: ST_TO_ADDR
// end ;
66802: LD_VAR 0 3
66806: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
66807: LD_INT 0
66809: PPUSH
66810: PPUSH
66811: PPUSH
66812: PPUSH
66813: PPUSH
66814: PPUSH
66815: PPUSH
// result := array ;
66816: LD_ADDR_VAR 0 5
66820: PUSH
66821: LD_VAR 0 1
66825: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
66826: LD_VAR 0 1
66830: NOT
66831: PUSH
66832: LD_VAR 0 2
66836: NOT
66837: OR
66838: PUSH
66839: LD_VAR 0 3
66843: NOT
66844: OR
66845: PUSH
66846: LD_VAR 0 2
66850: PUSH
66851: LD_VAR 0 1
66855: GREATER
66856: OR
66857: PUSH
66858: LD_VAR 0 3
66862: PUSH
66863: LD_VAR 0 1
66867: GREATER
66868: OR
66869: IFFALSE 66873
// exit ;
66871: GO 67169
// if direction then
66873: LD_VAR 0 4
66877: IFFALSE 66941
// begin d := 1 ;
66879: LD_ADDR_VAR 0 9
66883: PUSH
66884: LD_INT 1
66886: ST_TO_ADDR
// if i_from > i_to then
66887: LD_VAR 0 2
66891: PUSH
66892: LD_VAR 0 3
66896: GREATER
66897: IFFALSE 66923
// length := ( array - i_from ) + i_to else
66899: LD_ADDR_VAR 0 11
66903: PUSH
66904: LD_VAR 0 1
66908: PUSH
66909: LD_VAR 0 2
66913: MINUS
66914: PUSH
66915: LD_VAR 0 3
66919: PLUS
66920: ST_TO_ADDR
66921: GO 66939
// length := i_to - i_from ;
66923: LD_ADDR_VAR 0 11
66927: PUSH
66928: LD_VAR 0 3
66932: PUSH
66933: LD_VAR 0 2
66937: MINUS
66938: ST_TO_ADDR
// end else
66939: GO 67002
// begin d := - 1 ;
66941: LD_ADDR_VAR 0 9
66945: PUSH
66946: LD_INT 1
66948: NEG
66949: ST_TO_ADDR
// if i_from > i_to then
66950: LD_VAR 0 2
66954: PUSH
66955: LD_VAR 0 3
66959: GREATER
66960: IFFALSE 66980
// length := i_from - i_to else
66962: LD_ADDR_VAR 0 11
66966: PUSH
66967: LD_VAR 0 2
66971: PUSH
66972: LD_VAR 0 3
66976: MINUS
66977: ST_TO_ADDR
66978: GO 67002
// length := ( array - i_to ) + i_from ;
66980: LD_ADDR_VAR 0 11
66984: PUSH
66985: LD_VAR 0 1
66989: PUSH
66990: LD_VAR 0 3
66994: MINUS
66995: PUSH
66996: LD_VAR 0 2
67000: PLUS
67001: ST_TO_ADDR
// end ; if not length then
67002: LD_VAR 0 11
67006: NOT
67007: IFFALSE 67011
// exit ;
67009: GO 67169
// tmp := array ;
67011: LD_ADDR_VAR 0 10
67015: PUSH
67016: LD_VAR 0 1
67020: ST_TO_ADDR
// for i = 1 to length do
67021: LD_ADDR_VAR 0 6
67025: PUSH
67026: DOUBLE
67027: LD_INT 1
67029: DEC
67030: ST_TO_ADDR
67031: LD_VAR 0 11
67035: PUSH
67036: FOR_TO
67037: IFFALSE 67157
// begin for j = 1 to array do
67039: LD_ADDR_VAR 0 7
67043: PUSH
67044: DOUBLE
67045: LD_INT 1
67047: DEC
67048: ST_TO_ADDR
67049: LD_VAR 0 1
67053: PUSH
67054: FOR_TO
67055: IFFALSE 67143
// begin k := j + d ;
67057: LD_ADDR_VAR 0 8
67061: PUSH
67062: LD_VAR 0 7
67066: PUSH
67067: LD_VAR 0 9
67071: PLUS
67072: ST_TO_ADDR
// if k > array then
67073: LD_VAR 0 8
67077: PUSH
67078: LD_VAR 0 1
67082: GREATER
67083: IFFALSE 67093
// k := 1 ;
67085: LD_ADDR_VAR 0 8
67089: PUSH
67090: LD_INT 1
67092: ST_TO_ADDR
// if not k then
67093: LD_VAR 0 8
67097: NOT
67098: IFFALSE 67110
// k := array ;
67100: LD_ADDR_VAR 0 8
67104: PUSH
67105: LD_VAR 0 1
67109: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
67110: LD_ADDR_VAR 0 10
67114: PUSH
67115: LD_VAR 0 10
67119: PPUSH
67120: LD_VAR 0 8
67124: PPUSH
67125: LD_VAR 0 1
67129: PUSH
67130: LD_VAR 0 7
67134: ARRAY
67135: PPUSH
67136: CALL_OW 1
67140: ST_TO_ADDR
// end ;
67141: GO 67054
67143: POP
67144: POP
// array := tmp ;
67145: LD_ADDR_VAR 0 1
67149: PUSH
67150: LD_VAR 0 10
67154: ST_TO_ADDR
// end ;
67155: GO 67036
67157: POP
67158: POP
// result := array ;
67159: LD_ADDR_VAR 0 5
67163: PUSH
67164: LD_VAR 0 1
67168: ST_TO_ADDR
// end ;
67169: LD_VAR 0 5
67173: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
67174: LD_INT 0
67176: PPUSH
67177: PPUSH
// result := 0 ;
67178: LD_ADDR_VAR 0 3
67182: PUSH
67183: LD_INT 0
67185: ST_TO_ADDR
// if not array or not value in array then
67186: LD_VAR 0 1
67190: NOT
67191: PUSH
67192: LD_VAR 0 2
67196: PUSH
67197: LD_VAR 0 1
67201: IN
67202: NOT
67203: OR
67204: IFFALSE 67208
// exit ;
67206: GO 67262
// for i = 1 to array do
67208: LD_ADDR_VAR 0 4
67212: PUSH
67213: DOUBLE
67214: LD_INT 1
67216: DEC
67217: ST_TO_ADDR
67218: LD_VAR 0 1
67222: PUSH
67223: FOR_TO
67224: IFFALSE 67260
// if value = array [ i ] then
67226: LD_VAR 0 2
67230: PUSH
67231: LD_VAR 0 1
67235: PUSH
67236: LD_VAR 0 4
67240: ARRAY
67241: EQUAL
67242: IFFALSE 67258
// begin result := i ;
67244: LD_ADDR_VAR 0 3
67248: PUSH
67249: LD_VAR 0 4
67253: ST_TO_ADDR
// exit ;
67254: POP
67255: POP
67256: GO 67262
// end ;
67258: GO 67223
67260: POP
67261: POP
// end ;
67262: LD_VAR 0 3
67266: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
67267: LD_INT 0
67269: PPUSH
// vc_chassis := chassis ;
67270: LD_ADDR_OWVAR 37
67274: PUSH
67275: LD_VAR 0 1
67279: ST_TO_ADDR
// vc_engine := engine ;
67280: LD_ADDR_OWVAR 39
67284: PUSH
67285: LD_VAR 0 2
67289: ST_TO_ADDR
// vc_control := control ;
67290: LD_ADDR_OWVAR 38
67294: PUSH
67295: LD_VAR 0 3
67299: ST_TO_ADDR
// vc_weapon := weapon ;
67300: LD_ADDR_OWVAR 40
67304: PUSH
67305: LD_VAR 0 4
67309: ST_TO_ADDR
// vc_fuel_battery := fuel ;
67310: LD_ADDR_OWVAR 41
67314: PUSH
67315: LD_VAR 0 5
67319: ST_TO_ADDR
// end ;
67320: LD_VAR 0 6
67324: RET
// export function WantPlant ( unit ) ; var task ; begin
67325: LD_INT 0
67327: PPUSH
67328: PPUSH
// result := false ;
67329: LD_ADDR_VAR 0 2
67333: PUSH
67334: LD_INT 0
67336: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
67337: LD_ADDR_VAR 0 3
67341: PUSH
67342: LD_VAR 0 1
67346: PPUSH
67347: CALL_OW 437
67351: ST_TO_ADDR
// if task then
67352: LD_VAR 0 3
67356: IFFALSE 67384
// if task [ 1 ] [ 1 ] = p then
67358: LD_VAR 0 3
67362: PUSH
67363: LD_INT 1
67365: ARRAY
67366: PUSH
67367: LD_INT 1
67369: ARRAY
67370: PUSH
67371: LD_STRING p
67373: EQUAL
67374: IFFALSE 67384
// result := true ;
67376: LD_ADDR_VAR 0 2
67380: PUSH
67381: LD_INT 1
67383: ST_TO_ADDR
// end ;
67384: LD_VAR 0 2
67388: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
67389: LD_INT 0
67391: PPUSH
67392: PPUSH
67393: PPUSH
67394: PPUSH
// if pos < 1 then
67395: LD_VAR 0 2
67399: PUSH
67400: LD_INT 1
67402: LESS
67403: IFFALSE 67407
// exit ;
67405: GO 67710
// if pos = 1 then
67407: LD_VAR 0 2
67411: PUSH
67412: LD_INT 1
67414: EQUAL
67415: IFFALSE 67448
// result := Replace ( arr , pos [ 1 ] , value ) else
67417: LD_ADDR_VAR 0 4
67421: PUSH
67422: LD_VAR 0 1
67426: PPUSH
67427: LD_VAR 0 2
67431: PUSH
67432: LD_INT 1
67434: ARRAY
67435: PPUSH
67436: LD_VAR 0 3
67440: PPUSH
67441: CALL_OW 1
67445: ST_TO_ADDR
67446: GO 67710
// begin tmp := arr ;
67448: LD_ADDR_VAR 0 6
67452: PUSH
67453: LD_VAR 0 1
67457: ST_TO_ADDR
// s_arr := [ tmp ] ;
67458: LD_ADDR_VAR 0 7
67462: PUSH
67463: LD_VAR 0 6
67467: PUSH
67468: EMPTY
67469: LIST
67470: ST_TO_ADDR
// for i = 1 to pos - 1 do
67471: LD_ADDR_VAR 0 5
67475: PUSH
67476: DOUBLE
67477: LD_INT 1
67479: DEC
67480: ST_TO_ADDR
67481: LD_VAR 0 2
67485: PUSH
67486: LD_INT 1
67488: MINUS
67489: PUSH
67490: FOR_TO
67491: IFFALSE 67536
// begin tmp := tmp [ pos [ i ] ] ;
67493: LD_ADDR_VAR 0 6
67497: PUSH
67498: LD_VAR 0 6
67502: PUSH
67503: LD_VAR 0 2
67507: PUSH
67508: LD_VAR 0 5
67512: ARRAY
67513: ARRAY
67514: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
67515: LD_ADDR_VAR 0 7
67519: PUSH
67520: LD_VAR 0 7
67524: PUSH
67525: LD_VAR 0 6
67529: PUSH
67530: EMPTY
67531: LIST
67532: ADD
67533: ST_TO_ADDR
// end ;
67534: GO 67490
67536: POP
67537: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
67538: LD_ADDR_VAR 0 6
67542: PUSH
67543: LD_VAR 0 6
67547: PPUSH
67548: LD_VAR 0 2
67552: PUSH
67553: LD_VAR 0 2
67557: ARRAY
67558: PPUSH
67559: LD_VAR 0 3
67563: PPUSH
67564: CALL_OW 1
67568: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
67569: LD_ADDR_VAR 0 7
67573: PUSH
67574: LD_VAR 0 7
67578: PPUSH
67579: LD_VAR 0 7
67583: PPUSH
67584: LD_VAR 0 6
67588: PPUSH
67589: CALL_OW 1
67593: ST_TO_ADDR
// for i = s_arr downto 2 do
67594: LD_ADDR_VAR 0 5
67598: PUSH
67599: DOUBLE
67600: LD_VAR 0 7
67604: INC
67605: ST_TO_ADDR
67606: LD_INT 2
67608: PUSH
67609: FOR_DOWNTO
67610: IFFALSE 67694
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
67612: LD_ADDR_VAR 0 6
67616: PUSH
67617: LD_VAR 0 7
67621: PUSH
67622: LD_VAR 0 5
67626: PUSH
67627: LD_INT 1
67629: MINUS
67630: ARRAY
67631: PPUSH
67632: LD_VAR 0 2
67636: PUSH
67637: LD_VAR 0 5
67641: PUSH
67642: LD_INT 1
67644: MINUS
67645: ARRAY
67646: PPUSH
67647: LD_VAR 0 7
67651: PUSH
67652: LD_VAR 0 5
67656: ARRAY
67657: PPUSH
67658: CALL_OW 1
67662: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
67663: LD_ADDR_VAR 0 7
67667: PUSH
67668: LD_VAR 0 7
67672: PPUSH
67673: LD_VAR 0 5
67677: PUSH
67678: LD_INT 1
67680: MINUS
67681: PPUSH
67682: LD_VAR 0 6
67686: PPUSH
67687: CALL_OW 1
67691: ST_TO_ADDR
// end ;
67692: GO 67609
67694: POP
67695: POP
// result := s_arr [ 1 ] ;
67696: LD_ADDR_VAR 0 4
67700: PUSH
67701: LD_VAR 0 7
67705: PUSH
67706: LD_INT 1
67708: ARRAY
67709: ST_TO_ADDR
// end ; end ;
67710: LD_VAR 0 4
67714: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
67715: LD_INT 0
67717: PPUSH
67718: PPUSH
// if not list then
67719: LD_VAR 0 1
67723: NOT
67724: IFFALSE 67728
// exit ;
67726: GO 67819
// i := list [ pos1 ] ;
67728: LD_ADDR_VAR 0 5
67732: PUSH
67733: LD_VAR 0 1
67737: PUSH
67738: LD_VAR 0 2
67742: ARRAY
67743: ST_TO_ADDR
// if not i then
67744: LD_VAR 0 5
67748: NOT
67749: IFFALSE 67753
// exit ;
67751: GO 67819
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
67753: LD_ADDR_VAR 0 1
67757: PUSH
67758: LD_VAR 0 1
67762: PPUSH
67763: LD_VAR 0 2
67767: PPUSH
67768: LD_VAR 0 1
67772: PUSH
67773: LD_VAR 0 3
67777: ARRAY
67778: PPUSH
67779: CALL_OW 1
67783: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
67784: LD_ADDR_VAR 0 1
67788: PUSH
67789: LD_VAR 0 1
67793: PPUSH
67794: LD_VAR 0 3
67798: PPUSH
67799: LD_VAR 0 5
67803: PPUSH
67804: CALL_OW 1
67808: ST_TO_ADDR
// result := list ;
67809: LD_ADDR_VAR 0 4
67813: PUSH
67814: LD_VAR 0 1
67818: ST_TO_ADDR
// end ;
67819: LD_VAR 0 4
67823: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
67824: LD_INT 0
67826: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
67827: LD_ADDR_VAR 0 5
67831: PUSH
67832: LD_VAR 0 1
67836: PPUSH
67837: CALL_OW 250
67841: PPUSH
67842: LD_VAR 0 1
67846: PPUSH
67847: CALL_OW 251
67851: PPUSH
67852: LD_VAR 0 2
67856: PPUSH
67857: LD_VAR 0 3
67861: PPUSH
67862: LD_VAR 0 4
67866: PPUSH
67867: CALL 67877 0 5
67871: ST_TO_ADDR
// end ;
67872: LD_VAR 0 5
67876: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
67877: LD_INT 0
67879: PPUSH
67880: PPUSH
67881: PPUSH
67882: PPUSH
// if not list then
67883: LD_VAR 0 3
67887: NOT
67888: IFFALSE 67892
// exit ;
67890: GO 68280
// result := [ ] ;
67892: LD_ADDR_VAR 0 6
67896: PUSH
67897: EMPTY
67898: ST_TO_ADDR
// for i in list do
67899: LD_ADDR_VAR 0 7
67903: PUSH
67904: LD_VAR 0 3
67908: PUSH
67909: FOR_IN
67910: IFFALSE 68112
// begin tmp := GetDistUnitXY ( i , x , y ) ;
67912: LD_ADDR_VAR 0 9
67916: PUSH
67917: LD_VAR 0 7
67921: PPUSH
67922: LD_VAR 0 1
67926: PPUSH
67927: LD_VAR 0 2
67931: PPUSH
67932: CALL_OW 297
67936: ST_TO_ADDR
// if not result then
67937: LD_VAR 0 6
67941: NOT
67942: IFFALSE 67968
// result := [ [ i , tmp ] ] else
67944: LD_ADDR_VAR 0 6
67948: PUSH
67949: LD_VAR 0 7
67953: PUSH
67954: LD_VAR 0 9
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: EMPTY
67964: LIST
67965: ST_TO_ADDR
67966: GO 68110
// begin if result [ result ] [ 2 ] < tmp then
67968: LD_VAR 0 6
67972: PUSH
67973: LD_VAR 0 6
67977: ARRAY
67978: PUSH
67979: LD_INT 2
67981: ARRAY
67982: PUSH
67983: LD_VAR 0 9
67987: LESS
67988: IFFALSE 68030
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
67990: LD_ADDR_VAR 0 6
67994: PUSH
67995: LD_VAR 0 6
67999: PPUSH
68000: LD_VAR 0 6
68004: PUSH
68005: LD_INT 1
68007: PLUS
68008: PPUSH
68009: LD_VAR 0 7
68013: PUSH
68014: LD_VAR 0 9
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PPUSH
68023: CALL_OW 2
68027: ST_TO_ADDR
68028: GO 68110
// for j = 1 to result do
68030: LD_ADDR_VAR 0 8
68034: PUSH
68035: DOUBLE
68036: LD_INT 1
68038: DEC
68039: ST_TO_ADDR
68040: LD_VAR 0 6
68044: PUSH
68045: FOR_TO
68046: IFFALSE 68108
// begin if tmp < result [ j ] [ 2 ] then
68048: LD_VAR 0 9
68052: PUSH
68053: LD_VAR 0 6
68057: PUSH
68058: LD_VAR 0 8
68062: ARRAY
68063: PUSH
68064: LD_INT 2
68066: ARRAY
68067: LESS
68068: IFFALSE 68106
// begin result := Insert ( result , j , [ i , tmp ] ) ;
68070: LD_ADDR_VAR 0 6
68074: PUSH
68075: LD_VAR 0 6
68079: PPUSH
68080: LD_VAR 0 8
68084: PPUSH
68085: LD_VAR 0 7
68089: PUSH
68090: LD_VAR 0 9
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PPUSH
68099: CALL_OW 2
68103: ST_TO_ADDR
// break ;
68104: GO 68108
// end ; end ;
68106: GO 68045
68108: POP
68109: POP
// end ; end ;
68110: GO 67909
68112: POP
68113: POP
// if result and not asc then
68114: LD_VAR 0 6
68118: PUSH
68119: LD_VAR 0 4
68123: NOT
68124: AND
68125: IFFALSE 68200
// begin tmp := result ;
68127: LD_ADDR_VAR 0 9
68131: PUSH
68132: LD_VAR 0 6
68136: ST_TO_ADDR
// for i = tmp downto 1 do
68137: LD_ADDR_VAR 0 7
68141: PUSH
68142: DOUBLE
68143: LD_VAR 0 9
68147: INC
68148: ST_TO_ADDR
68149: LD_INT 1
68151: PUSH
68152: FOR_DOWNTO
68153: IFFALSE 68198
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
68155: LD_ADDR_VAR 0 6
68159: PUSH
68160: LD_VAR 0 6
68164: PPUSH
68165: LD_VAR 0 9
68169: PUSH
68170: LD_VAR 0 7
68174: MINUS
68175: PUSH
68176: LD_INT 1
68178: PLUS
68179: PPUSH
68180: LD_VAR 0 9
68184: PUSH
68185: LD_VAR 0 7
68189: ARRAY
68190: PPUSH
68191: CALL_OW 1
68195: ST_TO_ADDR
68196: GO 68152
68198: POP
68199: POP
// end ; tmp := [ ] ;
68200: LD_ADDR_VAR 0 9
68204: PUSH
68205: EMPTY
68206: ST_TO_ADDR
// if mode then
68207: LD_VAR 0 5
68211: IFFALSE 68280
// begin for i = 1 to result do
68213: LD_ADDR_VAR 0 7
68217: PUSH
68218: DOUBLE
68219: LD_INT 1
68221: DEC
68222: ST_TO_ADDR
68223: LD_VAR 0 6
68227: PUSH
68228: FOR_TO
68229: IFFALSE 68268
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
68231: LD_ADDR_VAR 0 9
68235: PUSH
68236: LD_VAR 0 9
68240: PPUSH
68241: LD_VAR 0 7
68245: PPUSH
68246: LD_VAR 0 6
68250: PUSH
68251: LD_VAR 0 7
68255: ARRAY
68256: PUSH
68257: LD_INT 1
68259: ARRAY
68260: PPUSH
68261: CALL_OW 1
68265: ST_TO_ADDR
68266: GO 68228
68268: POP
68269: POP
// result := tmp ;
68270: LD_ADDR_VAR 0 6
68274: PUSH
68275: LD_VAR 0 9
68279: ST_TO_ADDR
// end ; end ;
68280: LD_VAR 0 6
68284: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
68285: LD_INT 0
68287: PPUSH
68288: PPUSH
68289: PPUSH
68290: PPUSH
68291: PPUSH
68292: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
68293: LD_ADDR_VAR 0 5
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: LD_INT 0
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: ST_TO_ADDR
// if not x or not y then
68315: LD_VAR 0 2
68319: NOT
68320: PUSH
68321: LD_VAR 0 3
68325: NOT
68326: OR
68327: IFFALSE 68331
// exit ;
68329: GO 69983
// if not range then
68331: LD_VAR 0 4
68335: NOT
68336: IFFALSE 68346
// range := 10 ;
68338: LD_ADDR_VAR 0 4
68342: PUSH
68343: LD_INT 10
68345: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68346: LD_ADDR_VAR 0 8
68350: PUSH
68351: LD_INT 81
68353: PUSH
68354: LD_VAR 0 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 92
68365: PUSH
68366: LD_VAR 0 2
68370: PUSH
68371: LD_VAR 0 3
68375: PUSH
68376: LD_VAR 0 4
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: PUSH
68387: LD_INT 3
68389: PUSH
68390: LD_INT 21
68392: PUSH
68393: LD_INT 3
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: LIST
68408: PPUSH
68409: CALL_OW 69
68413: ST_TO_ADDR
// if not tmp then
68414: LD_VAR 0 8
68418: NOT
68419: IFFALSE 68423
// exit ;
68421: GO 69983
// for i in tmp do
68423: LD_ADDR_VAR 0 6
68427: PUSH
68428: LD_VAR 0 8
68432: PUSH
68433: FOR_IN
68434: IFFALSE 69958
// begin points := [ 0 , 0 , 0 ] ;
68436: LD_ADDR_VAR 0 9
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 0
68446: PUSH
68447: LD_INT 0
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: LIST
68454: ST_TO_ADDR
// bpoints := 1 ;
68455: LD_ADDR_VAR 0 10
68459: PUSH
68460: LD_INT 1
68462: ST_TO_ADDR
// case GetType ( i ) of unit_human :
68463: LD_VAR 0 6
68467: PPUSH
68468: CALL_OW 247
68472: PUSH
68473: LD_INT 1
68475: DOUBLE
68476: EQUAL
68477: IFTRUE 68481
68479: GO 69059
68481: POP
// begin if GetClass ( i ) = 1 then
68482: LD_VAR 0 6
68486: PPUSH
68487: CALL_OW 257
68491: PUSH
68492: LD_INT 1
68494: EQUAL
68495: IFFALSE 68516
// points := [ 10 , 5 , 3 ] ;
68497: LD_ADDR_VAR 0 9
68501: PUSH
68502: LD_INT 10
68504: PUSH
68505: LD_INT 5
68507: PUSH
68508: LD_INT 3
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: LIST
68515: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
68516: LD_VAR 0 6
68520: PPUSH
68521: CALL_OW 257
68525: PUSH
68526: LD_INT 2
68528: PUSH
68529: LD_INT 3
68531: PUSH
68532: LD_INT 4
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: LIST
68539: IN
68540: IFFALSE 68561
// points := [ 3 , 2 , 1 ] ;
68542: LD_ADDR_VAR 0 9
68546: PUSH
68547: LD_INT 3
68549: PUSH
68550: LD_INT 2
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: LIST
68560: ST_TO_ADDR
// if GetClass ( i ) = 5 then
68561: LD_VAR 0 6
68565: PPUSH
68566: CALL_OW 257
68570: PUSH
68571: LD_INT 5
68573: EQUAL
68574: IFFALSE 68595
// points := [ 130 , 5 , 2 ] ;
68576: LD_ADDR_VAR 0 9
68580: PUSH
68581: LD_INT 130
68583: PUSH
68584: LD_INT 5
68586: PUSH
68587: LD_INT 2
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: LIST
68594: ST_TO_ADDR
// if GetClass ( i ) = 8 then
68595: LD_VAR 0 6
68599: PPUSH
68600: CALL_OW 257
68604: PUSH
68605: LD_INT 8
68607: EQUAL
68608: IFFALSE 68629
// points := [ 35 , 35 , 30 ] ;
68610: LD_ADDR_VAR 0 9
68614: PUSH
68615: LD_INT 35
68617: PUSH
68618: LD_INT 35
68620: PUSH
68621: LD_INT 30
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: LIST
68628: ST_TO_ADDR
// if GetClass ( i ) = 9 then
68629: LD_VAR 0 6
68633: PPUSH
68634: CALL_OW 257
68638: PUSH
68639: LD_INT 9
68641: EQUAL
68642: IFFALSE 68663
// points := [ 20 , 55 , 40 ] ;
68644: LD_ADDR_VAR 0 9
68648: PUSH
68649: LD_INT 20
68651: PUSH
68652: LD_INT 55
68654: PUSH
68655: LD_INT 40
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: LIST
68662: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
68663: LD_VAR 0 6
68667: PPUSH
68668: CALL_OW 257
68672: PUSH
68673: LD_INT 12
68675: PUSH
68676: LD_INT 16
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: IN
68683: IFFALSE 68704
// points := [ 5 , 3 , 2 ] ;
68685: LD_ADDR_VAR 0 9
68689: PUSH
68690: LD_INT 5
68692: PUSH
68693: LD_INT 3
68695: PUSH
68696: LD_INT 2
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: LIST
68703: ST_TO_ADDR
// if GetClass ( i ) = 17 then
68704: LD_VAR 0 6
68708: PPUSH
68709: CALL_OW 257
68713: PUSH
68714: LD_INT 17
68716: EQUAL
68717: IFFALSE 68738
// points := [ 100 , 50 , 75 ] ;
68719: LD_ADDR_VAR 0 9
68723: PUSH
68724: LD_INT 100
68726: PUSH
68727: LD_INT 50
68729: PUSH
68730: LD_INT 75
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: LIST
68737: ST_TO_ADDR
// if GetClass ( i ) = 15 then
68738: LD_VAR 0 6
68742: PPUSH
68743: CALL_OW 257
68747: PUSH
68748: LD_INT 15
68750: EQUAL
68751: IFFALSE 68772
// points := [ 10 , 5 , 3 ] ;
68753: LD_ADDR_VAR 0 9
68757: PUSH
68758: LD_INT 10
68760: PUSH
68761: LD_INT 5
68763: PUSH
68764: LD_INT 3
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: LIST
68771: ST_TO_ADDR
// if GetClass ( i ) = 14 then
68772: LD_VAR 0 6
68776: PPUSH
68777: CALL_OW 257
68781: PUSH
68782: LD_INT 14
68784: EQUAL
68785: IFFALSE 68806
// points := [ 10 , 0 , 0 ] ;
68787: LD_ADDR_VAR 0 9
68791: PUSH
68792: LD_INT 10
68794: PUSH
68795: LD_INT 0
68797: PUSH
68798: LD_INT 0
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: LIST
68805: ST_TO_ADDR
// if GetClass ( i ) = 11 then
68806: LD_VAR 0 6
68810: PPUSH
68811: CALL_OW 257
68815: PUSH
68816: LD_INT 11
68818: EQUAL
68819: IFFALSE 68840
// points := [ 30 , 10 , 5 ] ;
68821: LD_ADDR_VAR 0 9
68825: PUSH
68826: LD_INT 30
68828: PUSH
68829: LD_INT 10
68831: PUSH
68832: LD_INT 5
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: LIST
68839: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
68840: LD_VAR 0 1
68844: PPUSH
68845: LD_INT 5
68847: PPUSH
68848: CALL_OW 321
68852: PUSH
68853: LD_INT 2
68855: EQUAL
68856: IFFALSE 68873
// bpoints := bpoints * 1.8 ;
68858: LD_ADDR_VAR 0 10
68862: PUSH
68863: LD_VAR 0 10
68867: PUSH
68868: LD_REAL  1.80000000000000E+0000
68871: MUL
68872: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
68873: LD_VAR 0 6
68877: PPUSH
68878: CALL_OW 257
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 2
68888: PUSH
68889: LD_INT 3
68891: PUSH
68892: LD_INT 4
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: IN
68901: PUSH
68902: LD_VAR 0 1
68906: PPUSH
68907: LD_INT 51
68909: PPUSH
68910: CALL_OW 321
68914: PUSH
68915: LD_INT 2
68917: EQUAL
68918: AND
68919: IFFALSE 68936
// bpoints := bpoints * 1.2 ;
68921: LD_ADDR_VAR 0 10
68925: PUSH
68926: LD_VAR 0 10
68930: PUSH
68931: LD_REAL  1.20000000000000E+0000
68934: MUL
68935: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
68936: LD_VAR 0 6
68940: PPUSH
68941: CALL_OW 257
68945: PUSH
68946: LD_INT 5
68948: PUSH
68949: LD_INT 7
68951: PUSH
68952: LD_INT 9
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: LIST
68959: IN
68960: PUSH
68961: LD_VAR 0 1
68965: PPUSH
68966: LD_INT 52
68968: PPUSH
68969: CALL_OW 321
68973: PUSH
68974: LD_INT 2
68976: EQUAL
68977: AND
68978: IFFALSE 68995
// bpoints := bpoints * 1.5 ;
68980: LD_ADDR_VAR 0 10
68984: PUSH
68985: LD_VAR 0 10
68989: PUSH
68990: LD_REAL  1.50000000000000E+0000
68993: MUL
68994: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
68995: LD_VAR 0 1
68999: PPUSH
69000: LD_INT 66
69002: PPUSH
69003: CALL_OW 321
69007: PUSH
69008: LD_INT 2
69010: EQUAL
69011: IFFALSE 69028
// bpoints := bpoints * 1.1 ;
69013: LD_ADDR_VAR 0 10
69017: PUSH
69018: LD_VAR 0 10
69022: PUSH
69023: LD_REAL  1.10000000000000E+0000
69026: MUL
69027: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69028: LD_ADDR_VAR 0 10
69032: PUSH
69033: LD_VAR 0 10
69037: PUSH
69038: LD_VAR 0 6
69042: PPUSH
69043: LD_INT 1
69045: PPUSH
69046: CALL_OW 259
69050: PUSH
69051: LD_REAL  1.15000000000000E+0000
69054: MUL
69055: MUL
69056: ST_TO_ADDR
// end ; unit_vehicle :
69057: GO 69887
69059: LD_INT 2
69061: DOUBLE
69062: EQUAL
69063: IFTRUE 69067
69065: GO 69875
69067: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
69068: LD_VAR 0 6
69072: PPUSH
69073: CALL_OW 264
69077: PUSH
69078: LD_INT 2
69080: PUSH
69081: LD_INT 42
69083: PUSH
69084: LD_INT 24
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: LIST
69091: IN
69092: IFFALSE 69113
// points := [ 25 , 5 , 3 ] ;
69094: LD_ADDR_VAR 0 9
69098: PUSH
69099: LD_INT 25
69101: PUSH
69102: LD_INT 5
69104: PUSH
69105: LD_INT 3
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: LIST
69112: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
69113: LD_VAR 0 6
69117: PPUSH
69118: CALL_OW 264
69122: PUSH
69123: LD_INT 4
69125: PUSH
69126: LD_INT 43
69128: PUSH
69129: LD_INT 25
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: LIST
69136: IN
69137: IFFALSE 69158
// points := [ 40 , 15 , 5 ] ;
69139: LD_ADDR_VAR 0 9
69143: PUSH
69144: LD_INT 40
69146: PUSH
69147: LD_INT 15
69149: PUSH
69150: LD_INT 5
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: LIST
69157: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
69158: LD_VAR 0 6
69162: PPUSH
69163: CALL_OW 264
69167: PUSH
69168: LD_INT 3
69170: PUSH
69171: LD_INT 23
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: IN
69178: IFFALSE 69199
// points := [ 7 , 25 , 8 ] ;
69180: LD_ADDR_VAR 0 9
69184: PUSH
69185: LD_INT 7
69187: PUSH
69188: LD_INT 25
69190: PUSH
69191: LD_INT 8
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: LIST
69198: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
69199: LD_VAR 0 6
69203: PPUSH
69204: CALL_OW 264
69208: PUSH
69209: LD_INT 5
69211: PUSH
69212: LD_INT 27
69214: PUSH
69215: LD_INT 44
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: LIST
69222: IN
69223: IFFALSE 69244
// points := [ 14 , 50 , 16 ] ;
69225: LD_ADDR_VAR 0 9
69229: PUSH
69230: LD_INT 14
69232: PUSH
69233: LD_INT 50
69235: PUSH
69236: LD_INT 16
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: LIST
69243: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
69244: LD_VAR 0 6
69248: PPUSH
69249: CALL_OW 264
69253: PUSH
69254: LD_INT 6
69256: PUSH
69257: LD_INT 46
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: IN
69264: IFFALSE 69285
// points := [ 32 , 120 , 70 ] ;
69266: LD_ADDR_VAR 0 9
69270: PUSH
69271: LD_INT 32
69273: PUSH
69274: LD_INT 120
69276: PUSH
69277: LD_INT 70
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: LIST
69284: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
69285: LD_VAR 0 6
69289: PPUSH
69290: CALL_OW 264
69294: PUSH
69295: LD_INT 7
69297: PUSH
69298: LD_INT 28
69300: PUSH
69301: LD_INT 45
69303: PUSH
69304: LD_EXP 78
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: IN
69315: IFFALSE 69336
// points := [ 35 , 20 , 45 ] ;
69317: LD_ADDR_VAR 0 9
69321: PUSH
69322: LD_INT 35
69324: PUSH
69325: LD_INT 20
69327: PUSH
69328: LD_INT 45
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: LIST
69335: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
69336: LD_VAR 0 6
69340: PPUSH
69341: CALL_OW 264
69345: PUSH
69346: LD_INT 47
69348: PUSH
69349: EMPTY
69350: LIST
69351: IN
69352: IFFALSE 69373
// points := [ 67 , 45 , 75 ] ;
69354: LD_ADDR_VAR 0 9
69358: PUSH
69359: LD_INT 67
69361: PUSH
69362: LD_INT 45
69364: PUSH
69365: LD_INT 75
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
69373: LD_VAR 0 6
69377: PPUSH
69378: CALL_OW 264
69382: PUSH
69383: LD_INT 26
69385: PUSH
69386: EMPTY
69387: LIST
69388: IN
69389: IFFALSE 69410
// points := [ 120 , 30 , 80 ] ;
69391: LD_ADDR_VAR 0 9
69395: PUSH
69396: LD_INT 120
69398: PUSH
69399: LD_INT 30
69401: PUSH
69402: LD_INT 80
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: LIST
69409: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
69410: LD_VAR 0 6
69414: PPUSH
69415: CALL_OW 264
69419: PUSH
69420: LD_INT 22
69422: PUSH
69423: EMPTY
69424: LIST
69425: IN
69426: IFFALSE 69447
// points := [ 40 , 1 , 1 ] ;
69428: LD_ADDR_VAR 0 9
69432: PUSH
69433: LD_INT 40
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: LD_INT 1
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: LIST
69446: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
69447: LD_VAR 0 6
69451: PPUSH
69452: CALL_OW 264
69456: PUSH
69457: LD_INT 29
69459: PUSH
69460: EMPTY
69461: LIST
69462: IN
69463: IFFALSE 69484
// points := [ 70 , 200 , 400 ] ;
69465: LD_ADDR_VAR 0 9
69469: PUSH
69470: LD_INT 70
69472: PUSH
69473: LD_INT 200
69475: PUSH
69476: LD_INT 400
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: LIST
69483: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
69484: LD_VAR 0 6
69488: PPUSH
69489: CALL_OW 264
69493: PUSH
69494: LD_INT 14
69496: PUSH
69497: LD_INT 53
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: IN
69504: IFFALSE 69525
// points := [ 40 , 10 , 20 ] ;
69506: LD_ADDR_VAR 0 9
69510: PUSH
69511: LD_INT 40
69513: PUSH
69514: LD_INT 10
69516: PUSH
69517: LD_INT 20
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: LIST
69524: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
69525: LD_VAR 0 6
69529: PPUSH
69530: CALL_OW 264
69534: PUSH
69535: LD_INT 9
69537: PUSH
69538: EMPTY
69539: LIST
69540: IN
69541: IFFALSE 69562
// points := [ 5 , 70 , 20 ] ;
69543: LD_ADDR_VAR 0 9
69547: PUSH
69548: LD_INT 5
69550: PUSH
69551: LD_INT 70
69553: PUSH
69554: LD_INT 20
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: LIST
69561: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
69562: LD_VAR 0 6
69566: PPUSH
69567: CALL_OW 264
69571: PUSH
69572: LD_INT 10
69574: PUSH
69575: EMPTY
69576: LIST
69577: IN
69578: IFFALSE 69599
// points := [ 35 , 110 , 70 ] ;
69580: LD_ADDR_VAR 0 9
69584: PUSH
69585: LD_INT 35
69587: PUSH
69588: LD_INT 110
69590: PUSH
69591: LD_INT 70
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: LIST
69598: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
69599: LD_VAR 0 6
69603: PPUSH
69604: CALL_OW 265
69608: PUSH
69609: LD_INT 25
69611: EQUAL
69612: IFFALSE 69633
// points := [ 80 , 65 , 100 ] ;
69614: LD_ADDR_VAR 0 9
69618: PUSH
69619: LD_INT 80
69621: PUSH
69622: LD_INT 65
69624: PUSH
69625: LD_INT 100
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: LIST
69632: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
69633: LD_VAR 0 6
69637: PPUSH
69638: CALL_OW 263
69642: PUSH
69643: LD_INT 1
69645: EQUAL
69646: IFFALSE 69681
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
69648: LD_ADDR_VAR 0 10
69652: PUSH
69653: LD_VAR 0 10
69657: PUSH
69658: LD_VAR 0 6
69662: PPUSH
69663: CALL_OW 311
69667: PPUSH
69668: LD_INT 3
69670: PPUSH
69671: CALL_OW 259
69675: PUSH
69676: LD_INT 4
69678: MUL
69679: MUL
69680: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
69681: LD_VAR 0 6
69685: PPUSH
69686: CALL_OW 263
69690: PUSH
69691: LD_INT 2
69693: EQUAL
69694: IFFALSE 69745
// begin j := IsControledBy ( i ) ;
69696: LD_ADDR_VAR 0 7
69700: PUSH
69701: LD_VAR 0 6
69705: PPUSH
69706: CALL_OW 312
69710: ST_TO_ADDR
// if j then
69711: LD_VAR 0 7
69715: IFFALSE 69745
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
69717: LD_ADDR_VAR 0 10
69721: PUSH
69722: LD_VAR 0 10
69726: PUSH
69727: LD_VAR 0 7
69731: PPUSH
69732: LD_INT 3
69734: PPUSH
69735: CALL_OW 259
69739: PUSH
69740: LD_INT 3
69742: MUL
69743: MUL
69744: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
69745: LD_VAR 0 6
69749: PPUSH
69750: CALL_OW 264
69754: PUSH
69755: LD_INT 5
69757: PUSH
69758: LD_INT 6
69760: PUSH
69761: LD_INT 46
69763: PUSH
69764: LD_INT 44
69766: PUSH
69767: LD_INT 47
69769: PUSH
69770: LD_INT 45
69772: PUSH
69773: LD_INT 28
69775: PUSH
69776: LD_INT 7
69778: PUSH
69779: LD_INT 27
69781: PUSH
69782: LD_INT 29
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: IN
69797: PUSH
69798: LD_VAR 0 1
69802: PPUSH
69803: LD_INT 52
69805: PPUSH
69806: CALL_OW 321
69810: PUSH
69811: LD_INT 2
69813: EQUAL
69814: AND
69815: IFFALSE 69832
// bpoints := bpoints * 1.2 ;
69817: LD_ADDR_VAR 0 10
69821: PUSH
69822: LD_VAR 0 10
69826: PUSH
69827: LD_REAL  1.20000000000000E+0000
69830: MUL
69831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
69832: LD_VAR 0 6
69836: PPUSH
69837: CALL_OW 264
69841: PUSH
69842: LD_INT 6
69844: PUSH
69845: LD_INT 46
69847: PUSH
69848: LD_INT 47
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: LIST
69855: IN
69856: IFFALSE 69873
// bpoints := bpoints * 1.2 ;
69858: LD_ADDR_VAR 0 10
69862: PUSH
69863: LD_VAR 0 10
69867: PUSH
69868: LD_REAL  1.20000000000000E+0000
69871: MUL
69872: ST_TO_ADDR
// end ; unit_building :
69873: GO 69887
69875: LD_INT 3
69877: DOUBLE
69878: EQUAL
69879: IFTRUE 69883
69881: GO 69886
69883: POP
// ; end ;
69884: GO 69887
69886: POP
// for j = 1 to 3 do
69887: LD_ADDR_VAR 0 7
69891: PUSH
69892: DOUBLE
69893: LD_INT 1
69895: DEC
69896: ST_TO_ADDR
69897: LD_INT 3
69899: PUSH
69900: FOR_TO
69901: IFFALSE 69954
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
69903: LD_ADDR_VAR 0 5
69907: PUSH
69908: LD_VAR 0 5
69912: PPUSH
69913: LD_VAR 0 7
69917: PPUSH
69918: LD_VAR 0 5
69922: PUSH
69923: LD_VAR 0 7
69927: ARRAY
69928: PUSH
69929: LD_VAR 0 9
69933: PUSH
69934: LD_VAR 0 7
69938: ARRAY
69939: PUSH
69940: LD_VAR 0 10
69944: MUL
69945: PLUS
69946: PPUSH
69947: CALL_OW 1
69951: ST_TO_ADDR
69952: GO 69900
69954: POP
69955: POP
// end ;
69956: GO 68433
69958: POP
69959: POP
// result := Replace ( result , 4 , tmp ) ;
69960: LD_ADDR_VAR 0 5
69964: PUSH
69965: LD_VAR 0 5
69969: PPUSH
69970: LD_INT 4
69972: PPUSH
69973: LD_VAR 0 8
69977: PPUSH
69978: CALL_OW 1
69982: ST_TO_ADDR
// end ;
69983: LD_VAR 0 5
69987: RET
// export function DangerAtRange ( unit , range ) ; begin
69988: LD_INT 0
69990: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
69991: LD_ADDR_VAR 0 3
69995: PUSH
69996: LD_VAR 0 1
70000: PPUSH
70001: CALL_OW 255
70005: PPUSH
70006: LD_VAR 0 1
70010: PPUSH
70011: CALL_OW 250
70015: PPUSH
70016: LD_VAR 0 1
70020: PPUSH
70021: CALL_OW 251
70025: PPUSH
70026: LD_VAR 0 2
70030: PPUSH
70031: CALL 68285 0 4
70035: ST_TO_ADDR
// end ;
70036: LD_VAR 0 3
70040: RET
// export function DangerInArea ( side , area ) ; begin
70041: LD_INT 0
70043: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70044: LD_ADDR_VAR 0 3
70048: PUSH
70049: LD_VAR 0 2
70053: PPUSH
70054: LD_INT 81
70056: PUSH
70057: LD_VAR 0 1
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PPUSH
70066: CALL_OW 70
70070: ST_TO_ADDR
// end ;
70071: LD_VAR 0 3
70075: RET
// export function IsExtension ( b ) ; begin
70076: LD_INT 0
70078: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
70079: LD_ADDR_VAR 0 2
70083: PUSH
70084: LD_VAR 0 1
70088: PUSH
70089: LD_INT 23
70091: PUSH
70092: LD_INT 20
70094: PUSH
70095: LD_INT 22
70097: PUSH
70098: LD_INT 17
70100: PUSH
70101: LD_INT 24
70103: PUSH
70104: LD_INT 21
70106: PUSH
70107: LD_INT 19
70109: PUSH
70110: LD_INT 16
70112: PUSH
70113: LD_INT 25
70115: PUSH
70116: LD_INT 18
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: IN
70131: ST_TO_ADDR
// end ;
70132: LD_VAR 0 2
70136: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
70137: LD_INT 0
70139: PPUSH
70140: PPUSH
70141: PPUSH
// result := [ ] ;
70142: LD_ADDR_VAR 0 4
70146: PUSH
70147: EMPTY
70148: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
70149: LD_ADDR_VAR 0 5
70153: PUSH
70154: LD_VAR 0 2
70158: PPUSH
70159: LD_INT 21
70161: PUSH
70162: LD_INT 3
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PPUSH
70169: CALL_OW 70
70173: ST_TO_ADDR
// if not tmp then
70174: LD_VAR 0 5
70178: NOT
70179: IFFALSE 70183
// exit ;
70181: GO 70247
// if checkLink then
70183: LD_VAR 0 3
70187: IFFALSE 70237
// begin for i in tmp do
70189: LD_ADDR_VAR 0 6
70193: PUSH
70194: LD_VAR 0 5
70198: PUSH
70199: FOR_IN
70200: IFFALSE 70235
// if GetBase ( i ) <> base then
70202: LD_VAR 0 6
70206: PPUSH
70207: CALL_OW 274
70211: PUSH
70212: LD_VAR 0 1
70216: NONEQUAL
70217: IFFALSE 70233
// ComLinkToBase ( base , i ) ;
70219: LD_VAR 0 1
70223: PPUSH
70224: LD_VAR 0 6
70228: PPUSH
70229: CALL_OW 169
70233: GO 70199
70235: POP
70236: POP
// end ; result := tmp ;
70237: LD_ADDR_VAR 0 4
70241: PUSH
70242: LD_VAR 0 5
70246: ST_TO_ADDR
// end ;
70247: LD_VAR 0 4
70251: RET
// export function ComComplete ( units , b ) ; var i ; begin
70252: LD_INT 0
70254: PPUSH
70255: PPUSH
// if not units then
70256: LD_VAR 0 1
70260: NOT
70261: IFFALSE 70265
// exit ;
70263: GO 70355
// for i in units do
70265: LD_ADDR_VAR 0 4
70269: PUSH
70270: LD_VAR 0 1
70274: PUSH
70275: FOR_IN
70276: IFFALSE 70353
// if BuildingStatus ( b ) = bs_build then
70278: LD_VAR 0 2
70282: PPUSH
70283: CALL_OW 461
70287: PUSH
70288: LD_INT 1
70290: EQUAL
70291: IFFALSE 70351
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
70293: LD_VAR 0 4
70297: PPUSH
70298: LD_STRING h
70300: PUSH
70301: LD_VAR 0 2
70305: PPUSH
70306: CALL_OW 250
70310: PUSH
70311: LD_VAR 0 2
70315: PPUSH
70316: CALL_OW 251
70320: PUSH
70321: LD_VAR 0 2
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: PUSH
70344: EMPTY
70345: LIST
70346: PPUSH
70347: CALL_OW 446
70351: GO 70275
70353: POP
70354: POP
// end ;
70355: LD_VAR 0 3
70359: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
70360: LD_INT 0
70362: PPUSH
70363: PPUSH
70364: PPUSH
70365: PPUSH
70366: PPUSH
70367: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
70368: LD_VAR 0 1
70372: NOT
70373: PUSH
70374: LD_VAR 0 1
70378: PPUSH
70379: CALL_OW 263
70383: PUSH
70384: LD_INT 2
70386: NONEQUAL
70387: OR
70388: IFFALSE 70392
// exit ;
70390: GO 70708
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
70392: LD_ADDR_VAR 0 6
70396: PUSH
70397: LD_INT 22
70399: PUSH
70400: LD_VAR 0 1
70404: PPUSH
70405: CALL_OW 255
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 2
70416: PUSH
70417: LD_INT 30
70419: PUSH
70420: LD_INT 36
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 34
70429: PUSH
70430: LD_INT 31
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: LIST
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PPUSH
70446: CALL_OW 69
70450: ST_TO_ADDR
// if not tmp then
70451: LD_VAR 0 6
70455: NOT
70456: IFFALSE 70460
// exit ;
70458: GO 70708
// result := [ ] ;
70460: LD_ADDR_VAR 0 2
70464: PUSH
70465: EMPTY
70466: ST_TO_ADDR
// for i in tmp do
70467: LD_ADDR_VAR 0 3
70471: PUSH
70472: LD_VAR 0 6
70476: PUSH
70477: FOR_IN
70478: IFFALSE 70549
// begin t := UnitsInside ( i ) ;
70480: LD_ADDR_VAR 0 4
70484: PUSH
70485: LD_VAR 0 3
70489: PPUSH
70490: CALL_OW 313
70494: ST_TO_ADDR
// if t then
70495: LD_VAR 0 4
70499: IFFALSE 70547
// for j in t do
70501: LD_ADDR_VAR 0 7
70505: PUSH
70506: LD_VAR 0 4
70510: PUSH
70511: FOR_IN
70512: IFFALSE 70545
// result := Replace ( result , result + 1 , j ) ;
70514: LD_ADDR_VAR 0 2
70518: PUSH
70519: LD_VAR 0 2
70523: PPUSH
70524: LD_VAR 0 2
70528: PUSH
70529: LD_INT 1
70531: PLUS
70532: PPUSH
70533: LD_VAR 0 7
70537: PPUSH
70538: CALL_OW 1
70542: ST_TO_ADDR
70543: GO 70511
70545: POP
70546: POP
// end ;
70547: GO 70477
70549: POP
70550: POP
// if not result then
70551: LD_VAR 0 2
70555: NOT
70556: IFFALSE 70560
// exit ;
70558: GO 70708
// mech := result [ 1 ] ;
70560: LD_ADDR_VAR 0 5
70564: PUSH
70565: LD_VAR 0 2
70569: PUSH
70570: LD_INT 1
70572: ARRAY
70573: ST_TO_ADDR
// if result > 1 then
70574: LD_VAR 0 2
70578: PUSH
70579: LD_INT 1
70581: GREATER
70582: IFFALSE 70694
// begin for i = 2 to result do
70584: LD_ADDR_VAR 0 3
70588: PUSH
70589: DOUBLE
70590: LD_INT 2
70592: DEC
70593: ST_TO_ADDR
70594: LD_VAR 0 2
70598: PUSH
70599: FOR_TO
70600: IFFALSE 70692
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
70602: LD_ADDR_VAR 0 4
70606: PUSH
70607: LD_VAR 0 2
70611: PUSH
70612: LD_VAR 0 3
70616: ARRAY
70617: PPUSH
70618: LD_INT 3
70620: PPUSH
70621: CALL_OW 259
70625: PUSH
70626: LD_VAR 0 2
70630: PUSH
70631: LD_VAR 0 3
70635: ARRAY
70636: PPUSH
70637: CALL_OW 432
70641: MINUS
70642: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
70643: LD_VAR 0 4
70647: PUSH
70648: LD_VAR 0 5
70652: PPUSH
70653: LD_INT 3
70655: PPUSH
70656: CALL_OW 259
70660: PUSH
70661: LD_VAR 0 5
70665: PPUSH
70666: CALL_OW 432
70670: MINUS
70671: GREATEREQUAL
70672: IFFALSE 70690
// mech := result [ i ] ;
70674: LD_ADDR_VAR 0 5
70678: PUSH
70679: LD_VAR 0 2
70683: PUSH
70684: LD_VAR 0 3
70688: ARRAY
70689: ST_TO_ADDR
// end ;
70690: GO 70599
70692: POP
70693: POP
// end ; ComLinkTo ( vehicle , mech ) ;
70694: LD_VAR 0 1
70698: PPUSH
70699: LD_VAR 0 5
70703: PPUSH
70704: CALL_OW 135
// end ;
70708: LD_VAR 0 2
70712: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
70713: LD_INT 0
70715: PPUSH
70716: PPUSH
70717: PPUSH
70718: PPUSH
70719: PPUSH
70720: PPUSH
70721: PPUSH
70722: PPUSH
70723: PPUSH
70724: PPUSH
70725: PPUSH
70726: PPUSH
70727: PPUSH
// result := [ ] ;
70728: LD_ADDR_VAR 0 7
70732: PUSH
70733: EMPTY
70734: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
70735: LD_VAR 0 1
70739: PPUSH
70740: CALL_OW 266
70744: PUSH
70745: LD_INT 0
70747: PUSH
70748: LD_INT 1
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: IN
70755: NOT
70756: IFFALSE 70760
// exit ;
70758: GO 72394
// if name then
70760: LD_VAR 0 3
70764: IFFALSE 70780
// SetBName ( base_dep , name ) ;
70766: LD_VAR 0 1
70770: PPUSH
70771: LD_VAR 0 3
70775: PPUSH
70776: CALL_OW 500
// base := GetBase ( base_dep ) ;
70780: LD_ADDR_VAR 0 15
70784: PUSH
70785: LD_VAR 0 1
70789: PPUSH
70790: CALL_OW 274
70794: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
70795: LD_ADDR_VAR 0 16
70799: PUSH
70800: LD_VAR 0 1
70804: PPUSH
70805: CALL_OW 255
70809: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
70810: LD_ADDR_VAR 0 17
70814: PUSH
70815: LD_VAR 0 1
70819: PPUSH
70820: CALL_OW 248
70824: ST_TO_ADDR
// if sources then
70825: LD_VAR 0 5
70829: IFFALSE 70876
// for i = 1 to 3 do
70831: LD_ADDR_VAR 0 8
70835: PUSH
70836: DOUBLE
70837: LD_INT 1
70839: DEC
70840: ST_TO_ADDR
70841: LD_INT 3
70843: PUSH
70844: FOR_TO
70845: IFFALSE 70874
// AddResourceType ( base , i , sources [ i ] ) ;
70847: LD_VAR 0 15
70851: PPUSH
70852: LD_VAR 0 8
70856: PPUSH
70857: LD_VAR 0 5
70861: PUSH
70862: LD_VAR 0 8
70866: ARRAY
70867: PPUSH
70868: CALL_OW 276
70872: GO 70844
70874: POP
70875: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
70876: LD_ADDR_VAR 0 18
70880: PUSH
70881: LD_VAR 0 15
70885: PPUSH
70886: LD_VAR 0 2
70890: PPUSH
70891: LD_INT 1
70893: PPUSH
70894: CALL 70137 0 3
70898: ST_TO_ADDR
// InitHc ;
70899: CALL_OW 19
// InitUc ;
70903: CALL_OW 18
// uc_side := side ;
70907: LD_ADDR_OWVAR 20
70911: PUSH
70912: LD_VAR 0 16
70916: ST_TO_ADDR
// uc_nation := nation ;
70917: LD_ADDR_OWVAR 21
70921: PUSH
70922: LD_VAR 0 17
70926: ST_TO_ADDR
// if buildings then
70927: LD_VAR 0 18
70931: IFFALSE 72253
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
70933: LD_ADDR_VAR 0 19
70937: PUSH
70938: LD_VAR 0 18
70942: PPUSH
70943: LD_INT 2
70945: PUSH
70946: LD_INT 30
70948: PUSH
70949: LD_INT 29
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 30
70958: PUSH
70959: LD_INT 30
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: LIST
70970: PPUSH
70971: CALL_OW 72
70975: ST_TO_ADDR
// if tmp then
70976: LD_VAR 0 19
70980: IFFALSE 71028
// for i in tmp do
70982: LD_ADDR_VAR 0 8
70986: PUSH
70987: LD_VAR 0 19
70991: PUSH
70992: FOR_IN
70993: IFFALSE 71026
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
70995: LD_VAR 0 8
70999: PPUSH
71000: CALL_OW 250
71004: PPUSH
71005: LD_VAR 0 8
71009: PPUSH
71010: CALL_OW 251
71014: PPUSH
71015: LD_VAR 0 16
71019: PPUSH
71020: CALL_OW 441
71024: GO 70992
71026: POP
71027: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71028: LD_VAR 0 18
71032: PPUSH
71033: LD_INT 2
71035: PUSH
71036: LD_INT 30
71038: PUSH
71039: LD_INT 32
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 30
71048: PUSH
71049: LD_INT 33
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: LIST
71060: PPUSH
71061: CALL_OW 72
71065: IFFALSE 71153
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
71067: LD_ADDR_VAR 0 8
71071: PUSH
71072: LD_VAR 0 18
71076: PPUSH
71077: LD_INT 2
71079: PUSH
71080: LD_INT 30
71082: PUSH
71083: LD_INT 32
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 30
71092: PUSH
71093: LD_INT 33
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: LIST
71104: PPUSH
71105: CALL_OW 72
71109: PUSH
71110: FOR_IN
71111: IFFALSE 71151
// begin if not GetBWeapon ( i ) then
71113: LD_VAR 0 8
71117: PPUSH
71118: CALL_OW 269
71122: NOT
71123: IFFALSE 71149
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
71125: LD_VAR 0 8
71129: PPUSH
71130: LD_VAR 0 8
71134: PPUSH
71135: LD_VAR 0 2
71139: PPUSH
71140: CALL 72399 0 2
71144: PPUSH
71145: CALL_OW 431
// end ;
71149: GO 71110
71151: POP
71152: POP
// end ; for i = 1 to personel do
71153: LD_ADDR_VAR 0 8
71157: PUSH
71158: DOUBLE
71159: LD_INT 1
71161: DEC
71162: ST_TO_ADDR
71163: LD_VAR 0 6
71167: PUSH
71168: FOR_TO
71169: IFFALSE 72233
// begin if i > 4 then
71171: LD_VAR 0 8
71175: PUSH
71176: LD_INT 4
71178: GREATER
71179: IFFALSE 71183
// break ;
71181: GO 72233
// case i of 1 :
71183: LD_VAR 0 8
71187: PUSH
71188: LD_INT 1
71190: DOUBLE
71191: EQUAL
71192: IFTRUE 71196
71194: GO 71276
71196: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
71197: LD_ADDR_VAR 0 12
71201: PUSH
71202: LD_VAR 0 18
71206: PPUSH
71207: LD_INT 22
71209: PUSH
71210: LD_VAR 0 16
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 58
71221: PUSH
71222: EMPTY
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: LD_INT 30
71230: PUSH
71231: LD_INT 32
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 30
71240: PUSH
71241: LD_INT 4
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 30
71250: PUSH
71251: LD_INT 5
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: LIST
71268: PPUSH
71269: CALL_OW 72
71273: ST_TO_ADDR
71274: GO 71498
71276: LD_INT 2
71278: DOUBLE
71279: EQUAL
71280: IFTRUE 71284
71282: GO 71346
71284: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
71285: LD_ADDR_VAR 0 12
71289: PUSH
71290: LD_VAR 0 18
71294: PPUSH
71295: LD_INT 22
71297: PUSH
71298: LD_VAR 0 16
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 2
71309: PUSH
71310: LD_INT 30
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 30
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: LIST
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PPUSH
71339: CALL_OW 72
71343: ST_TO_ADDR
71344: GO 71498
71346: LD_INT 3
71348: DOUBLE
71349: EQUAL
71350: IFTRUE 71354
71352: GO 71416
71354: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
71355: LD_ADDR_VAR 0 12
71359: PUSH
71360: LD_VAR 0 18
71364: PPUSH
71365: LD_INT 22
71367: PUSH
71368: LD_VAR 0 16
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 2
71379: PUSH
71380: LD_INT 30
71382: PUSH
71383: LD_INT 2
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 30
71392: PUSH
71393: LD_INT 3
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: LIST
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PPUSH
71409: CALL_OW 72
71413: ST_TO_ADDR
71414: GO 71498
71416: LD_INT 4
71418: DOUBLE
71419: EQUAL
71420: IFTRUE 71424
71422: GO 71497
71424: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
71425: LD_ADDR_VAR 0 12
71429: PUSH
71430: LD_VAR 0 18
71434: PPUSH
71435: LD_INT 22
71437: PUSH
71438: LD_VAR 0 16
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 2
71449: PUSH
71450: LD_INT 30
71452: PUSH
71453: LD_INT 6
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 30
71462: PUSH
71463: LD_INT 7
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PUSH
71470: LD_INT 30
71472: PUSH
71473: LD_INT 8
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: LIST
71484: LIST
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PPUSH
71490: CALL_OW 72
71494: ST_TO_ADDR
71495: GO 71498
71497: POP
// if i = 1 then
71498: LD_VAR 0 8
71502: PUSH
71503: LD_INT 1
71505: EQUAL
71506: IFFALSE 71617
// begin tmp := [ ] ;
71508: LD_ADDR_VAR 0 19
71512: PUSH
71513: EMPTY
71514: ST_TO_ADDR
// for j in f do
71515: LD_ADDR_VAR 0 9
71519: PUSH
71520: LD_VAR 0 12
71524: PUSH
71525: FOR_IN
71526: IFFALSE 71599
// if GetBType ( j ) = b_bunker then
71528: LD_VAR 0 9
71532: PPUSH
71533: CALL_OW 266
71537: PUSH
71538: LD_INT 32
71540: EQUAL
71541: IFFALSE 71568
// tmp := Insert ( tmp , 1 , j ) else
71543: LD_ADDR_VAR 0 19
71547: PUSH
71548: LD_VAR 0 19
71552: PPUSH
71553: LD_INT 1
71555: PPUSH
71556: LD_VAR 0 9
71560: PPUSH
71561: CALL_OW 2
71565: ST_TO_ADDR
71566: GO 71597
// tmp := Insert ( tmp , tmp + 1 , j ) ;
71568: LD_ADDR_VAR 0 19
71572: PUSH
71573: LD_VAR 0 19
71577: PPUSH
71578: LD_VAR 0 19
71582: PUSH
71583: LD_INT 1
71585: PLUS
71586: PPUSH
71587: LD_VAR 0 9
71591: PPUSH
71592: CALL_OW 2
71596: ST_TO_ADDR
71597: GO 71525
71599: POP
71600: POP
// if tmp then
71601: LD_VAR 0 19
71605: IFFALSE 71617
// f := tmp ;
71607: LD_ADDR_VAR 0 12
71611: PUSH
71612: LD_VAR 0 19
71616: ST_TO_ADDR
// end ; x := personel [ i ] ;
71617: LD_ADDR_VAR 0 13
71621: PUSH
71622: LD_VAR 0 6
71626: PUSH
71627: LD_VAR 0 8
71631: ARRAY
71632: ST_TO_ADDR
// if x = - 1 then
71633: LD_VAR 0 13
71637: PUSH
71638: LD_INT 1
71640: NEG
71641: EQUAL
71642: IFFALSE 71851
// begin for j in f do
71644: LD_ADDR_VAR 0 9
71648: PUSH
71649: LD_VAR 0 12
71653: PUSH
71654: FOR_IN
71655: IFFALSE 71847
// repeat InitHc ;
71657: CALL_OW 19
// if GetBType ( j ) = b_barracks then
71661: LD_VAR 0 9
71665: PPUSH
71666: CALL_OW 266
71670: PUSH
71671: LD_INT 5
71673: EQUAL
71674: IFFALSE 71744
// begin if UnitsInside ( j ) < 3 then
71676: LD_VAR 0 9
71680: PPUSH
71681: CALL_OW 313
71685: PUSH
71686: LD_INT 3
71688: LESS
71689: IFFALSE 71725
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
71691: LD_INT 0
71693: PPUSH
71694: LD_INT 5
71696: PUSH
71697: LD_INT 8
71699: PUSH
71700: LD_INT 9
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: LIST
71707: PUSH
71708: LD_VAR 0 17
71712: ARRAY
71713: PPUSH
71714: LD_VAR 0 4
71718: PPUSH
71719: CALL_OW 380
71723: GO 71742
// PrepareHuman ( false , i , skill ) ;
71725: LD_INT 0
71727: PPUSH
71728: LD_VAR 0 8
71732: PPUSH
71733: LD_VAR 0 4
71737: PPUSH
71738: CALL_OW 380
// end else
71742: GO 71761
// PrepareHuman ( false , i , skill ) ;
71744: LD_INT 0
71746: PPUSH
71747: LD_VAR 0 8
71751: PPUSH
71752: LD_VAR 0 4
71756: PPUSH
71757: CALL_OW 380
// un := CreateHuman ;
71761: LD_ADDR_VAR 0 14
71765: PUSH
71766: CALL_OW 44
71770: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71771: LD_ADDR_VAR 0 7
71775: PUSH
71776: LD_VAR 0 7
71780: PPUSH
71781: LD_INT 1
71783: PPUSH
71784: LD_VAR 0 14
71788: PPUSH
71789: CALL_OW 2
71793: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
71794: LD_VAR 0 14
71798: PPUSH
71799: LD_VAR 0 9
71803: PPUSH
71804: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
71808: LD_VAR 0 9
71812: PPUSH
71813: CALL_OW 313
71817: PUSH
71818: LD_INT 6
71820: EQUAL
71821: PUSH
71822: LD_VAR 0 9
71826: PPUSH
71827: CALL_OW 266
71831: PUSH
71832: LD_INT 32
71834: PUSH
71835: LD_INT 31
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: IN
71842: OR
71843: IFFALSE 71657
71845: GO 71654
71847: POP
71848: POP
// end else
71849: GO 72231
// for j = 1 to x do
71851: LD_ADDR_VAR 0 9
71855: PUSH
71856: DOUBLE
71857: LD_INT 1
71859: DEC
71860: ST_TO_ADDR
71861: LD_VAR 0 13
71865: PUSH
71866: FOR_TO
71867: IFFALSE 72229
// begin InitHc ;
71869: CALL_OW 19
// if not f then
71873: LD_VAR 0 12
71877: NOT
71878: IFFALSE 71967
// begin PrepareHuman ( false , i , skill ) ;
71880: LD_INT 0
71882: PPUSH
71883: LD_VAR 0 8
71887: PPUSH
71888: LD_VAR 0 4
71892: PPUSH
71893: CALL_OW 380
// un := CreateHuman ;
71897: LD_ADDR_VAR 0 14
71901: PUSH
71902: CALL_OW 44
71906: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71907: LD_ADDR_VAR 0 7
71911: PUSH
71912: LD_VAR 0 7
71916: PPUSH
71917: LD_INT 1
71919: PPUSH
71920: LD_VAR 0 14
71924: PPUSH
71925: CALL_OW 2
71929: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
71930: LD_VAR 0 14
71934: PPUSH
71935: LD_VAR 0 1
71939: PPUSH
71940: CALL_OW 250
71944: PPUSH
71945: LD_VAR 0 1
71949: PPUSH
71950: CALL_OW 251
71954: PPUSH
71955: LD_INT 10
71957: PPUSH
71958: LD_INT 0
71960: PPUSH
71961: CALL_OW 50
// continue ;
71965: GO 71866
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
71967: LD_VAR 0 12
71971: PUSH
71972: LD_INT 1
71974: ARRAY
71975: PPUSH
71976: CALL_OW 313
71980: PUSH
71981: LD_VAR 0 12
71985: PUSH
71986: LD_INT 1
71988: ARRAY
71989: PPUSH
71990: CALL_OW 266
71994: PUSH
71995: LD_INT 32
71997: PUSH
71998: LD_INT 31
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: IN
72005: AND
72006: PUSH
72007: LD_VAR 0 12
72011: PUSH
72012: LD_INT 1
72014: ARRAY
72015: PPUSH
72016: CALL_OW 313
72020: PUSH
72021: LD_INT 6
72023: EQUAL
72024: OR
72025: IFFALSE 72045
// f := Delete ( f , 1 ) ;
72027: LD_ADDR_VAR 0 12
72031: PUSH
72032: LD_VAR 0 12
72036: PPUSH
72037: LD_INT 1
72039: PPUSH
72040: CALL_OW 3
72044: ST_TO_ADDR
// if not f then
72045: LD_VAR 0 12
72049: NOT
72050: IFFALSE 72068
// begin x := x + 2 ;
72052: LD_ADDR_VAR 0 13
72056: PUSH
72057: LD_VAR 0 13
72061: PUSH
72062: LD_INT 2
72064: PLUS
72065: ST_TO_ADDR
// continue ;
72066: GO 71866
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
72068: LD_VAR 0 12
72072: PUSH
72073: LD_INT 1
72075: ARRAY
72076: PPUSH
72077: CALL_OW 266
72081: PUSH
72082: LD_INT 5
72084: EQUAL
72085: IFFALSE 72159
// begin if UnitsInside ( f [ 1 ] ) < 3 then
72087: LD_VAR 0 12
72091: PUSH
72092: LD_INT 1
72094: ARRAY
72095: PPUSH
72096: CALL_OW 313
72100: PUSH
72101: LD_INT 3
72103: LESS
72104: IFFALSE 72140
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72106: LD_INT 0
72108: PPUSH
72109: LD_INT 5
72111: PUSH
72112: LD_INT 8
72114: PUSH
72115: LD_INT 9
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: LIST
72122: PUSH
72123: LD_VAR 0 17
72127: ARRAY
72128: PPUSH
72129: LD_VAR 0 4
72133: PPUSH
72134: CALL_OW 380
72138: GO 72157
// PrepareHuman ( false , i , skill ) ;
72140: LD_INT 0
72142: PPUSH
72143: LD_VAR 0 8
72147: PPUSH
72148: LD_VAR 0 4
72152: PPUSH
72153: CALL_OW 380
// end else
72157: GO 72176
// PrepareHuman ( false , i , skill ) ;
72159: LD_INT 0
72161: PPUSH
72162: LD_VAR 0 8
72166: PPUSH
72167: LD_VAR 0 4
72171: PPUSH
72172: CALL_OW 380
// un := CreateHuman ;
72176: LD_ADDR_VAR 0 14
72180: PUSH
72181: CALL_OW 44
72185: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72186: LD_ADDR_VAR 0 7
72190: PUSH
72191: LD_VAR 0 7
72195: PPUSH
72196: LD_INT 1
72198: PPUSH
72199: LD_VAR 0 14
72203: PPUSH
72204: CALL_OW 2
72208: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
72209: LD_VAR 0 14
72213: PPUSH
72214: LD_VAR 0 12
72218: PUSH
72219: LD_INT 1
72221: ARRAY
72222: PPUSH
72223: CALL_OW 52
// end ;
72227: GO 71866
72229: POP
72230: POP
// end ;
72231: GO 71168
72233: POP
72234: POP
// result := result ^ buildings ;
72235: LD_ADDR_VAR 0 7
72239: PUSH
72240: LD_VAR 0 7
72244: PUSH
72245: LD_VAR 0 18
72249: ADD
72250: ST_TO_ADDR
// end else
72251: GO 72394
// begin for i = 1 to personel do
72253: LD_ADDR_VAR 0 8
72257: PUSH
72258: DOUBLE
72259: LD_INT 1
72261: DEC
72262: ST_TO_ADDR
72263: LD_VAR 0 6
72267: PUSH
72268: FOR_TO
72269: IFFALSE 72392
// begin if i > 4 then
72271: LD_VAR 0 8
72275: PUSH
72276: LD_INT 4
72278: GREATER
72279: IFFALSE 72283
// break ;
72281: GO 72392
// x := personel [ i ] ;
72283: LD_ADDR_VAR 0 13
72287: PUSH
72288: LD_VAR 0 6
72292: PUSH
72293: LD_VAR 0 8
72297: ARRAY
72298: ST_TO_ADDR
// if x = - 1 then
72299: LD_VAR 0 13
72303: PUSH
72304: LD_INT 1
72306: NEG
72307: EQUAL
72308: IFFALSE 72312
// continue ;
72310: GO 72268
// PrepareHuman ( false , i , skill ) ;
72312: LD_INT 0
72314: PPUSH
72315: LD_VAR 0 8
72319: PPUSH
72320: LD_VAR 0 4
72324: PPUSH
72325: CALL_OW 380
// un := CreateHuman ;
72329: LD_ADDR_VAR 0 14
72333: PUSH
72334: CALL_OW 44
72338: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72339: LD_VAR 0 14
72343: PPUSH
72344: LD_VAR 0 1
72348: PPUSH
72349: CALL_OW 250
72353: PPUSH
72354: LD_VAR 0 1
72358: PPUSH
72359: CALL_OW 251
72363: PPUSH
72364: LD_INT 10
72366: PPUSH
72367: LD_INT 0
72369: PPUSH
72370: CALL_OW 50
// result := result ^ un ;
72374: LD_ADDR_VAR 0 7
72378: PUSH
72379: LD_VAR 0 7
72383: PUSH
72384: LD_VAR 0 14
72388: ADD
72389: ST_TO_ADDR
// end ;
72390: GO 72268
72392: POP
72393: POP
// end ; end ;
72394: LD_VAR 0 7
72398: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
72399: LD_INT 0
72401: PPUSH
72402: PPUSH
72403: PPUSH
72404: PPUSH
72405: PPUSH
72406: PPUSH
72407: PPUSH
72408: PPUSH
72409: PPUSH
72410: PPUSH
72411: PPUSH
72412: PPUSH
72413: PPUSH
72414: PPUSH
72415: PPUSH
72416: PPUSH
// result := false ;
72417: LD_ADDR_VAR 0 3
72421: PUSH
72422: LD_INT 0
72424: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
72425: LD_VAR 0 1
72429: NOT
72430: PUSH
72431: LD_VAR 0 1
72435: PPUSH
72436: CALL_OW 266
72440: PUSH
72441: LD_INT 32
72443: PUSH
72444: LD_INT 33
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: IN
72451: NOT
72452: OR
72453: IFFALSE 72457
// exit ;
72455: GO 73566
// nat := GetNation ( tower ) ;
72457: LD_ADDR_VAR 0 12
72461: PUSH
72462: LD_VAR 0 1
72466: PPUSH
72467: CALL_OW 248
72471: ST_TO_ADDR
// side := GetSide ( tower ) ;
72472: LD_ADDR_VAR 0 16
72476: PUSH
72477: LD_VAR 0 1
72481: PPUSH
72482: CALL_OW 255
72486: ST_TO_ADDR
// x := GetX ( tower ) ;
72487: LD_ADDR_VAR 0 10
72491: PUSH
72492: LD_VAR 0 1
72496: PPUSH
72497: CALL_OW 250
72501: ST_TO_ADDR
// y := GetY ( tower ) ;
72502: LD_ADDR_VAR 0 11
72506: PUSH
72507: LD_VAR 0 1
72511: PPUSH
72512: CALL_OW 251
72516: ST_TO_ADDR
// if not x or not y then
72517: LD_VAR 0 10
72521: NOT
72522: PUSH
72523: LD_VAR 0 11
72527: NOT
72528: OR
72529: IFFALSE 72533
// exit ;
72531: GO 73566
// weapon := 0 ;
72533: LD_ADDR_VAR 0 18
72537: PUSH
72538: LD_INT 0
72540: ST_TO_ADDR
// fac_list := [ ] ;
72541: LD_ADDR_VAR 0 17
72545: PUSH
72546: EMPTY
72547: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
72548: LD_ADDR_VAR 0 6
72552: PUSH
72553: LD_VAR 0 1
72557: PPUSH
72558: CALL_OW 274
72562: PPUSH
72563: LD_VAR 0 2
72567: PPUSH
72568: LD_INT 0
72570: PPUSH
72571: CALL 70137 0 3
72575: PPUSH
72576: LD_INT 30
72578: PUSH
72579: LD_INT 3
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PPUSH
72586: CALL_OW 72
72590: ST_TO_ADDR
// if not factories then
72591: LD_VAR 0 6
72595: NOT
72596: IFFALSE 72600
// exit ;
72598: GO 73566
// for i in factories do
72600: LD_ADDR_VAR 0 8
72604: PUSH
72605: LD_VAR 0 6
72609: PUSH
72610: FOR_IN
72611: IFFALSE 72636
// fac_list := fac_list union AvailableWeaponList ( i ) ;
72613: LD_ADDR_VAR 0 17
72617: PUSH
72618: LD_VAR 0 17
72622: PUSH
72623: LD_VAR 0 8
72627: PPUSH
72628: CALL_OW 478
72632: UNION
72633: ST_TO_ADDR
72634: GO 72610
72636: POP
72637: POP
// if not fac_list then
72638: LD_VAR 0 17
72642: NOT
72643: IFFALSE 72647
// exit ;
72645: GO 73566
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
72647: LD_ADDR_VAR 0 5
72651: PUSH
72652: LD_INT 4
72654: PUSH
72655: LD_INT 5
72657: PUSH
72658: LD_INT 9
72660: PUSH
72661: LD_INT 10
72663: PUSH
72664: LD_INT 6
72666: PUSH
72667: LD_INT 7
72669: PUSH
72670: LD_INT 11
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: PUSH
72682: LD_INT 27
72684: PUSH
72685: LD_INT 28
72687: PUSH
72688: LD_INT 26
72690: PUSH
72691: LD_INT 30
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 43
72702: PUSH
72703: LD_INT 44
72705: PUSH
72706: LD_INT 46
72708: PUSH
72709: LD_INT 45
72711: PUSH
72712: LD_INT 47
72714: PUSH
72715: LD_INT 49
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: LIST
72722: LIST
72723: LIST
72724: LIST
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: LIST
72730: PUSH
72731: LD_VAR 0 12
72735: ARRAY
72736: ST_TO_ADDR
// list := list isect fac_list ;
72737: LD_ADDR_VAR 0 5
72741: PUSH
72742: LD_VAR 0 5
72746: PUSH
72747: LD_VAR 0 17
72751: ISECT
72752: ST_TO_ADDR
// if not list then
72753: LD_VAR 0 5
72757: NOT
72758: IFFALSE 72762
// exit ;
72760: GO 73566
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
72762: LD_VAR 0 12
72766: PUSH
72767: LD_INT 3
72769: EQUAL
72770: PUSH
72771: LD_INT 49
72773: PUSH
72774: LD_VAR 0 5
72778: IN
72779: AND
72780: PUSH
72781: LD_INT 31
72783: PPUSH
72784: LD_VAR 0 16
72788: PPUSH
72789: CALL_OW 321
72793: PUSH
72794: LD_INT 2
72796: EQUAL
72797: AND
72798: IFFALSE 72858
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
72800: LD_INT 22
72802: PUSH
72803: LD_VAR 0 16
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 35
72814: PUSH
72815: LD_INT 49
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 91
72824: PUSH
72825: LD_VAR 0 1
72829: PUSH
72830: LD_INT 10
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: LIST
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: LIST
72842: PPUSH
72843: CALL_OW 69
72847: NOT
72848: IFFALSE 72858
// weapon := ru_time_lapser ;
72850: LD_ADDR_VAR 0 18
72854: PUSH
72855: LD_INT 49
72857: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
72858: LD_VAR 0 12
72862: PUSH
72863: LD_INT 1
72865: PUSH
72866: LD_INT 2
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: IN
72873: PUSH
72874: LD_INT 11
72876: PUSH
72877: LD_VAR 0 5
72881: IN
72882: PUSH
72883: LD_INT 30
72885: PUSH
72886: LD_VAR 0 5
72890: IN
72891: OR
72892: AND
72893: PUSH
72894: LD_INT 6
72896: PPUSH
72897: LD_VAR 0 16
72901: PPUSH
72902: CALL_OW 321
72906: PUSH
72907: LD_INT 2
72909: EQUAL
72910: AND
72911: IFFALSE 73076
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
72913: LD_INT 22
72915: PUSH
72916: LD_VAR 0 16
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 2
72927: PUSH
72928: LD_INT 35
72930: PUSH
72931: LD_INT 11
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 35
72940: PUSH
72941: LD_INT 30
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 91
72955: PUSH
72956: LD_VAR 0 1
72960: PUSH
72961: LD_INT 18
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: LIST
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: LIST
72973: PPUSH
72974: CALL_OW 69
72978: NOT
72979: PUSH
72980: LD_INT 22
72982: PUSH
72983: LD_VAR 0 16
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: LD_INT 30
72997: PUSH
72998: LD_INT 32
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 30
73007: PUSH
73008: LD_INT 33
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 91
73022: PUSH
73023: LD_VAR 0 1
73027: PUSH
73028: LD_INT 12
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: LIST
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: LIST
73040: PUSH
73041: EMPTY
73042: LIST
73043: PPUSH
73044: CALL_OW 69
73048: PUSH
73049: LD_INT 2
73051: GREATER
73052: AND
73053: IFFALSE 73076
// weapon := [ us_radar , ar_radar ] [ nat ] ;
73055: LD_ADDR_VAR 0 18
73059: PUSH
73060: LD_INT 11
73062: PUSH
73063: LD_INT 30
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_VAR 0 12
73074: ARRAY
73075: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
73076: LD_VAR 0 18
73080: NOT
73081: PUSH
73082: LD_INT 40
73084: PPUSH
73085: LD_VAR 0 16
73089: PPUSH
73090: CALL_OW 321
73094: PUSH
73095: LD_INT 2
73097: EQUAL
73098: AND
73099: PUSH
73100: LD_INT 7
73102: PUSH
73103: LD_VAR 0 5
73107: IN
73108: PUSH
73109: LD_INT 28
73111: PUSH
73112: LD_VAR 0 5
73116: IN
73117: OR
73118: PUSH
73119: LD_INT 45
73121: PUSH
73122: LD_VAR 0 5
73126: IN
73127: OR
73128: AND
73129: IFFALSE 73383
// begin hex := GetHexInfo ( x , y ) ;
73131: LD_ADDR_VAR 0 4
73135: PUSH
73136: LD_VAR 0 10
73140: PPUSH
73141: LD_VAR 0 11
73145: PPUSH
73146: CALL_OW 546
73150: ST_TO_ADDR
// if hex [ 1 ] then
73151: LD_VAR 0 4
73155: PUSH
73156: LD_INT 1
73158: ARRAY
73159: IFFALSE 73163
// exit ;
73161: GO 73566
// height := hex [ 2 ] ;
73163: LD_ADDR_VAR 0 15
73167: PUSH
73168: LD_VAR 0 4
73172: PUSH
73173: LD_INT 2
73175: ARRAY
73176: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
73177: LD_ADDR_VAR 0 14
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: LD_INT 2
73187: PUSH
73188: LD_INT 3
73190: PUSH
73191: LD_INT 5
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: ST_TO_ADDR
// for i in tmp do
73200: LD_ADDR_VAR 0 8
73204: PUSH
73205: LD_VAR 0 14
73209: PUSH
73210: FOR_IN
73211: IFFALSE 73381
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
73213: LD_ADDR_VAR 0 9
73217: PUSH
73218: LD_VAR 0 10
73222: PPUSH
73223: LD_VAR 0 8
73227: PPUSH
73228: LD_INT 5
73230: PPUSH
73231: CALL_OW 272
73235: PUSH
73236: LD_VAR 0 11
73240: PPUSH
73241: LD_VAR 0 8
73245: PPUSH
73246: LD_INT 5
73248: PPUSH
73249: CALL_OW 273
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
73258: LD_VAR 0 9
73262: PUSH
73263: LD_INT 1
73265: ARRAY
73266: PPUSH
73267: LD_VAR 0 9
73271: PUSH
73272: LD_INT 2
73274: ARRAY
73275: PPUSH
73276: CALL_OW 488
73280: IFFALSE 73379
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
73282: LD_ADDR_VAR 0 4
73286: PUSH
73287: LD_VAR 0 9
73291: PUSH
73292: LD_INT 1
73294: ARRAY
73295: PPUSH
73296: LD_VAR 0 9
73300: PUSH
73301: LD_INT 2
73303: ARRAY
73304: PPUSH
73305: CALL_OW 546
73309: ST_TO_ADDR
// if hex [ 1 ] then
73310: LD_VAR 0 4
73314: PUSH
73315: LD_INT 1
73317: ARRAY
73318: IFFALSE 73322
// continue ;
73320: GO 73210
// h := hex [ 2 ] ;
73322: LD_ADDR_VAR 0 13
73326: PUSH
73327: LD_VAR 0 4
73331: PUSH
73332: LD_INT 2
73334: ARRAY
73335: ST_TO_ADDR
// if h + 7 < height then
73336: LD_VAR 0 13
73340: PUSH
73341: LD_INT 7
73343: PLUS
73344: PUSH
73345: LD_VAR 0 15
73349: LESS
73350: IFFALSE 73379
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
73352: LD_ADDR_VAR 0 18
73356: PUSH
73357: LD_INT 7
73359: PUSH
73360: LD_INT 28
73362: PUSH
73363: LD_INT 45
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: LIST
73370: PUSH
73371: LD_VAR 0 12
73375: ARRAY
73376: ST_TO_ADDR
// break ;
73377: GO 73381
// end ; end ; end ;
73379: GO 73210
73381: POP
73382: POP
// end ; if not weapon then
73383: LD_VAR 0 18
73387: NOT
73388: IFFALSE 73448
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
73390: LD_ADDR_VAR 0 5
73394: PUSH
73395: LD_VAR 0 5
73399: PUSH
73400: LD_INT 11
73402: PUSH
73403: LD_INT 30
73405: PUSH
73406: LD_INT 49
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: LIST
73413: DIFF
73414: ST_TO_ADDR
// if not list then
73415: LD_VAR 0 5
73419: NOT
73420: IFFALSE 73424
// exit ;
73422: GO 73566
// weapon := list [ rand ( 1 , list ) ] ;
73424: LD_ADDR_VAR 0 18
73428: PUSH
73429: LD_VAR 0 5
73433: PUSH
73434: LD_INT 1
73436: PPUSH
73437: LD_VAR 0 5
73441: PPUSH
73442: CALL_OW 12
73446: ARRAY
73447: ST_TO_ADDR
// end ; if weapon then
73448: LD_VAR 0 18
73452: IFFALSE 73566
// begin tmp := CostOfWeapon ( weapon ) ;
73454: LD_ADDR_VAR 0 14
73458: PUSH
73459: LD_VAR 0 18
73463: PPUSH
73464: CALL_OW 451
73468: ST_TO_ADDR
// j := GetBase ( tower ) ;
73469: LD_ADDR_VAR 0 9
73473: PUSH
73474: LD_VAR 0 1
73478: PPUSH
73479: CALL_OW 274
73483: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
73484: LD_VAR 0 9
73488: PPUSH
73489: LD_INT 1
73491: PPUSH
73492: CALL_OW 275
73496: PUSH
73497: LD_VAR 0 14
73501: PUSH
73502: LD_INT 1
73504: ARRAY
73505: GREATEREQUAL
73506: PUSH
73507: LD_VAR 0 9
73511: PPUSH
73512: LD_INT 2
73514: PPUSH
73515: CALL_OW 275
73519: PUSH
73520: LD_VAR 0 14
73524: PUSH
73525: LD_INT 2
73527: ARRAY
73528: GREATEREQUAL
73529: AND
73530: PUSH
73531: LD_VAR 0 9
73535: PPUSH
73536: LD_INT 3
73538: PPUSH
73539: CALL_OW 275
73543: PUSH
73544: LD_VAR 0 14
73548: PUSH
73549: LD_INT 3
73551: ARRAY
73552: GREATEREQUAL
73553: AND
73554: IFFALSE 73566
// result := weapon ;
73556: LD_ADDR_VAR 0 3
73560: PUSH
73561: LD_VAR 0 18
73565: ST_TO_ADDR
// end ; end ;
73566: LD_VAR 0 3
73570: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
73571: LD_INT 0
73573: PPUSH
73574: PPUSH
// result := true ;
73575: LD_ADDR_VAR 0 3
73579: PUSH
73580: LD_INT 1
73582: ST_TO_ADDR
// if array1 = array2 then
73583: LD_VAR 0 1
73587: PUSH
73588: LD_VAR 0 2
73592: EQUAL
73593: IFFALSE 73653
// begin for i = 1 to array1 do
73595: LD_ADDR_VAR 0 4
73599: PUSH
73600: DOUBLE
73601: LD_INT 1
73603: DEC
73604: ST_TO_ADDR
73605: LD_VAR 0 1
73609: PUSH
73610: FOR_TO
73611: IFFALSE 73649
// if array1 [ i ] <> array2 [ i ] then
73613: LD_VAR 0 1
73617: PUSH
73618: LD_VAR 0 4
73622: ARRAY
73623: PUSH
73624: LD_VAR 0 2
73628: PUSH
73629: LD_VAR 0 4
73633: ARRAY
73634: NONEQUAL
73635: IFFALSE 73647
// begin result := false ;
73637: LD_ADDR_VAR 0 3
73641: PUSH
73642: LD_INT 0
73644: ST_TO_ADDR
// break ;
73645: GO 73649
// end ;
73647: GO 73610
73649: POP
73650: POP
// end else
73651: GO 73661
// result := false ;
73653: LD_ADDR_VAR 0 3
73657: PUSH
73658: LD_INT 0
73660: ST_TO_ADDR
// end ;
73661: LD_VAR 0 3
73665: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
73666: LD_INT 0
73668: PPUSH
73669: PPUSH
// if not array1 or not array2 then
73670: LD_VAR 0 1
73674: NOT
73675: PUSH
73676: LD_VAR 0 2
73680: NOT
73681: OR
73682: IFFALSE 73686
// exit ;
73684: GO 73750
// result := true ;
73686: LD_ADDR_VAR 0 3
73690: PUSH
73691: LD_INT 1
73693: ST_TO_ADDR
// for i = 1 to array1 do
73694: LD_ADDR_VAR 0 4
73698: PUSH
73699: DOUBLE
73700: LD_INT 1
73702: DEC
73703: ST_TO_ADDR
73704: LD_VAR 0 1
73708: PUSH
73709: FOR_TO
73710: IFFALSE 73748
// if array1 [ i ] <> array2 [ i ] then
73712: LD_VAR 0 1
73716: PUSH
73717: LD_VAR 0 4
73721: ARRAY
73722: PUSH
73723: LD_VAR 0 2
73727: PUSH
73728: LD_VAR 0 4
73732: ARRAY
73733: NONEQUAL
73734: IFFALSE 73746
// begin result := false ;
73736: LD_ADDR_VAR 0 3
73740: PUSH
73741: LD_INT 0
73743: ST_TO_ADDR
// break ;
73744: GO 73748
// end ;
73746: GO 73709
73748: POP
73749: POP
// end ;
73750: LD_VAR 0 3
73754: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
73755: LD_INT 0
73757: PPUSH
73758: PPUSH
73759: PPUSH
// pom := GetBase ( fac ) ;
73760: LD_ADDR_VAR 0 5
73764: PUSH
73765: LD_VAR 0 1
73769: PPUSH
73770: CALL_OW 274
73774: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
73775: LD_ADDR_VAR 0 4
73779: PUSH
73780: LD_VAR 0 2
73784: PUSH
73785: LD_INT 1
73787: ARRAY
73788: PPUSH
73789: LD_VAR 0 2
73793: PUSH
73794: LD_INT 2
73796: ARRAY
73797: PPUSH
73798: LD_VAR 0 2
73802: PUSH
73803: LD_INT 3
73805: ARRAY
73806: PPUSH
73807: LD_VAR 0 2
73811: PUSH
73812: LD_INT 4
73814: ARRAY
73815: PPUSH
73816: CALL_OW 449
73820: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
73821: LD_ADDR_VAR 0 3
73825: PUSH
73826: LD_VAR 0 5
73830: PPUSH
73831: LD_INT 1
73833: PPUSH
73834: CALL_OW 275
73838: PUSH
73839: LD_VAR 0 4
73843: PUSH
73844: LD_INT 1
73846: ARRAY
73847: GREATEREQUAL
73848: PUSH
73849: LD_VAR 0 5
73853: PPUSH
73854: LD_INT 2
73856: PPUSH
73857: CALL_OW 275
73861: PUSH
73862: LD_VAR 0 4
73866: PUSH
73867: LD_INT 2
73869: ARRAY
73870: GREATEREQUAL
73871: AND
73872: PUSH
73873: LD_VAR 0 5
73877: PPUSH
73878: LD_INT 3
73880: PPUSH
73881: CALL_OW 275
73885: PUSH
73886: LD_VAR 0 4
73890: PUSH
73891: LD_INT 3
73893: ARRAY
73894: GREATEREQUAL
73895: AND
73896: ST_TO_ADDR
// end ;
73897: LD_VAR 0 3
73901: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
73902: LD_INT 0
73904: PPUSH
73905: PPUSH
73906: PPUSH
73907: PPUSH
// pom := GetBase ( building ) ;
73908: LD_ADDR_VAR 0 3
73912: PUSH
73913: LD_VAR 0 1
73917: PPUSH
73918: CALL_OW 274
73922: ST_TO_ADDR
// if not pom then
73923: LD_VAR 0 3
73927: NOT
73928: IFFALSE 73932
// exit ;
73930: GO 74102
// btype := GetBType ( building ) ;
73932: LD_ADDR_VAR 0 5
73936: PUSH
73937: LD_VAR 0 1
73941: PPUSH
73942: CALL_OW 266
73946: ST_TO_ADDR
// if btype = b_armoury then
73947: LD_VAR 0 5
73951: PUSH
73952: LD_INT 4
73954: EQUAL
73955: IFFALSE 73965
// btype := b_barracks ;
73957: LD_ADDR_VAR 0 5
73961: PUSH
73962: LD_INT 5
73964: ST_TO_ADDR
// if btype = b_depot then
73965: LD_VAR 0 5
73969: PUSH
73970: LD_INT 0
73972: EQUAL
73973: IFFALSE 73983
// btype := b_warehouse ;
73975: LD_ADDR_VAR 0 5
73979: PUSH
73980: LD_INT 1
73982: ST_TO_ADDR
// if btype = b_workshop then
73983: LD_VAR 0 5
73987: PUSH
73988: LD_INT 2
73990: EQUAL
73991: IFFALSE 74001
// btype := b_factory ;
73993: LD_ADDR_VAR 0 5
73997: PUSH
73998: LD_INT 3
74000: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74001: LD_ADDR_VAR 0 4
74005: PUSH
74006: LD_VAR 0 5
74010: PPUSH
74011: LD_VAR 0 1
74015: PPUSH
74016: CALL_OW 248
74020: PPUSH
74021: CALL_OW 450
74025: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74026: LD_ADDR_VAR 0 2
74030: PUSH
74031: LD_VAR 0 3
74035: PPUSH
74036: LD_INT 1
74038: PPUSH
74039: CALL_OW 275
74043: PUSH
74044: LD_VAR 0 4
74048: PUSH
74049: LD_INT 1
74051: ARRAY
74052: GREATEREQUAL
74053: PUSH
74054: LD_VAR 0 3
74058: PPUSH
74059: LD_INT 2
74061: PPUSH
74062: CALL_OW 275
74066: PUSH
74067: LD_VAR 0 4
74071: PUSH
74072: LD_INT 2
74074: ARRAY
74075: GREATEREQUAL
74076: AND
74077: PUSH
74078: LD_VAR 0 3
74082: PPUSH
74083: LD_INT 3
74085: PPUSH
74086: CALL_OW 275
74090: PUSH
74091: LD_VAR 0 4
74095: PUSH
74096: LD_INT 3
74098: ARRAY
74099: GREATEREQUAL
74100: AND
74101: ST_TO_ADDR
// end ;
74102: LD_VAR 0 2
74106: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
74107: LD_INT 0
74109: PPUSH
74110: PPUSH
74111: PPUSH
// pom := GetBase ( building ) ;
74112: LD_ADDR_VAR 0 4
74116: PUSH
74117: LD_VAR 0 1
74121: PPUSH
74122: CALL_OW 274
74126: ST_TO_ADDR
// if not pom then
74127: LD_VAR 0 4
74131: NOT
74132: IFFALSE 74136
// exit ;
74134: GO 74237
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74136: LD_ADDR_VAR 0 5
74140: PUSH
74141: LD_VAR 0 2
74145: PPUSH
74146: LD_VAR 0 1
74150: PPUSH
74151: CALL_OW 248
74155: PPUSH
74156: CALL_OW 450
74160: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74161: LD_ADDR_VAR 0 3
74165: PUSH
74166: LD_VAR 0 4
74170: PPUSH
74171: LD_INT 1
74173: PPUSH
74174: CALL_OW 275
74178: PUSH
74179: LD_VAR 0 5
74183: PUSH
74184: LD_INT 1
74186: ARRAY
74187: GREATEREQUAL
74188: PUSH
74189: LD_VAR 0 4
74193: PPUSH
74194: LD_INT 2
74196: PPUSH
74197: CALL_OW 275
74201: PUSH
74202: LD_VAR 0 5
74206: PUSH
74207: LD_INT 2
74209: ARRAY
74210: GREATEREQUAL
74211: AND
74212: PUSH
74213: LD_VAR 0 4
74217: PPUSH
74218: LD_INT 3
74220: PPUSH
74221: CALL_OW 275
74225: PUSH
74226: LD_VAR 0 5
74230: PUSH
74231: LD_INT 3
74233: ARRAY
74234: GREATEREQUAL
74235: AND
74236: ST_TO_ADDR
// end ;
74237: LD_VAR 0 3
74241: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
74242: LD_INT 0
74244: PPUSH
74245: PPUSH
74246: PPUSH
74247: PPUSH
74248: PPUSH
74249: PPUSH
74250: PPUSH
74251: PPUSH
74252: PPUSH
74253: PPUSH
74254: PPUSH
// result := false ;
74255: LD_ADDR_VAR 0 8
74259: PUSH
74260: LD_INT 0
74262: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
74263: LD_VAR 0 5
74267: NOT
74268: PUSH
74269: LD_VAR 0 1
74273: NOT
74274: OR
74275: PUSH
74276: LD_VAR 0 2
74280: NOT
74281: OR
74282: PUSH
74283: LD_VAR 0 3
74287: NOT
74288: OR
74289: IFFALSE 74293
// exit ;
74291: GO 75107
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
74293: LD_ADDR_VAR 0 14
74297: PUSH
74298: LD_VAR 0 1
74302: PPUSH
74303: LD_VAR 0 2
74307: PPUSH
74308: LD_VAR 0 3
74312: PPUSH
74313: LD_VAR 0 4
74317: PPUSH
74318: LD_VAR 0 5
74322: PUSH
74323: LD_INT 1
74325: ARRAY
74326: PPUSH
74327: CALL_OW 248
74331: PPUSH
74332: LD_INT 0
74334: PPUSH
74335: CALL 76344 0 6
74339: ST_TO_ADDR
// if not hexes then
74340: LD_VAR 0 14
74344: NOT
74345: IFFALSE 74349
// exit ;
74347: GO 75107
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74349: LD_ADDR_VAR 0 17
74353: PUSH
74354: LD_VAR 0 5
74358: PPUSH
74359: LD_INT 22
74361: PUSH
74362: LD_VAR 0 13
74366: PPUSH
74367: CALL_OW 255
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 2
74378: PUSH
74379: LD_INT 30
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 30
74391: PUSH
74392: LD_INT 1
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: LIST
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PPUSH
74408: CALL_OW 72
74412: ST_TO_ADDR
// for i = 1 to hexes do
74413: LD_ADDR_VAR 0 9
74417: PUSH
74418: DOUBLE
74419: LD_INT 1
74421: DEC
74422: ST_TO_ADDR
74423: LD_VAR 0 14
74427: PUSH
74428: FOR_TO
74429: IFFALSE 75105
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74431: LD_ADDR_VAR 0 13
74435: PUSH
74436: LD_VAR 0 14
74440: PUSH
74441: LD_VAR 0 9
74445: ARRAY
74446: PUSH
74447: LD_INT 1
74449: ARRAY
74450: PPUSH
74451: LD_VAR 0 14
74455: PUSH
74456: LD_VAR 0 9
74460: ARRAY
74461: PUSH
74462: LD_INT 2
74464: ARRAY
74465: PPUSH
74466: CALL_OW 428
74470: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
74471: LD_VAR 0 14
74475: PUSH
74476: LD_VAR 0 9
74480: ARRAY
74481: PUSH
74482: LD_INT 1
74484: ARRAY
74485: PPUSH
74486: LD_VAR 0 14
74490: PUSH
74491: LD_VAR 0 9
74495: ARRAY
74496: PUSH
74497: LD_INT 2
74499: ARRAY
74500: PPUSH
74501: CALL_OW 351
74505: PUSH
74506: LD_VAR 0 14
74510: PUSH
74511: LD_VAR 0 9
74515: ARRAY
74516: PUSH
74517: LD_INT 1
74519: ARRAY
74520: PPUSH
74521: LD_VAR 0 14
74525: PUSH
74526: LD_VAR 0 9
74530: ARRAY
74531: PUSH
74532: LD_INT 2
74534: ARRAY
74535: PPUSH
74536: CALL_OW 488
74540: NOT
74541: OR
74542: PUSH
74543: LD_VAR 0 13
74547: PPUSH
74548: CALL_OW 247
74552: PUSH
74553: LD_INT 3
74555: EQUAL
74556: OR
74557: IFFALSE 74563
// exit ;
74559: POP
74560: POP
74561: GO 75107
// if not tmp then
74563: LD_VAR 0 13
74567: NOT
74568: IFFALSE 74572
// continue ;
74570: GO 74428
// result := true ;
74572: LD_ADDR_VAR 0 8
74576: PUSH
74577: LD_INT 1
74579: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
74580: LD_VAR 0 6
74584: PUSH
74585: LD_VAR 0 13
74589: PPUSH
74590: CALL_OW 247
74594: PUSH
74595: LD_INT 2
74597: EQUAL
74598: AND
74599: PUSH
74600: LD_VAR 0 13
74604: PPUSH
74605: CALL_OW 263
74609: PUSH
74610: LD_INT 1
74612: EQUAL
74613: AND
74614: IFFALSE 74778
// begin if IsDrivenBy ( tmp ) then
74616: LD_VAR 0 13
74620: PPUSH
74621: CALL_OW 311
74625: IFFALSE 74629
// continue ;
74627: GO 74428
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
74629: LD_VAR 0 6
74633: PPUSH
74634: LD_INT 3
74636: PUSH
74637: LD_INT 60
74639: PUSH
74640: EMPTY
74641: LIST
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: LD_INT 3
74649: PUSH
74650: LD_INT 55
74652: PUSH
74653: EMPTY
74654: LIST
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PPUSH
74664: CALL_OW 72
74668: IFFALSE 74776
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
74670: LD_ADDR_VAR 0 18
74674: PUSH
74675: LD_VAR 0 6
74679: PPUSH
74680: LD_INT 3
74682: PUSH
74683: LD_INT 60
74685: PUSH
74686: EMPTY
74687: LIST
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 3
74695: PUSH
74696: LD_INT 55
74698: PUSH
74699: EMPTY
74700: LIST
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PPUSH
74710: CALL_OW 72
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: ST_TO_ADDR
// if IsInUnit ( driver ) then
74719: LD_VAR 0 18
74723: PPUSH
74724: CALL_OW 310
74728: IFFALSE 74739
// ComExit ( driver ) ;
74730: LD_VAR 0 18
74734: PPUSH
74735: CALL 99528 0 1
// AddComEnterUnit ( driver , tmp ) ;
74739: LD_VAR 0 18
74743: PPUSH
74744: LD_VAR 0 13
74748: PPUSH
74749: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
74753: LD_VAR 0 18
74757: PPUSH
74758: LD_VAR 0 7
74762: PPUSH
74763: CALL_OW 173
// AddComExitVehicle ( driver ) ;
74767: LD_VAR 0 18
74771: PPUSH
74772: CALL_OW 181
// end ; continue ;
74776: GO 74428
// end ; if not cleaners or not tmp in cleaners then
74778: LD_VAR 0 6
74782: NOT
74783: PUSH
74784: LD_VAR 0 13
74788: PUSH
74789: LD_VAR 0 6
74793: IN
74794: NOT
74795: OR
74796: IFFALSE 75103
// begin if dep then
74798: LD_VAR 0 17
74802: IFFALSE 74938
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
74804: LD_ADDR_VAR 0 16
74808: PUSH
74809: LD_VAR 0 17
74813: PUSH
74814: LD_INT 1
74816: ARRAY
74817: PPUSH
74818: CALL_OW 250
74822: PPUSH
74823: LD_VAR 0 17
74827: PUSH
74828: LD_INT 1
74830: ARRAY
74831: PPUSH
74832: CALL_OW 254
74836: PPUSH
74837: LD_INT 5
74839: PPUSH
74840: CALL_OW 272
74844: PUSH
74845: LD_VAR 0 17
74849: PUSH
74850: LD_INT 1
74852: ARRAY
74853: PPUSH
74854: CALL_OW 251
74858: PPUSH
74859: LD_VAR 0 17
74863: PUSH
74864: LD_INT 1
74866: ARRAY
74867: PPUSH
74868: CALL_OW 254
74872: PPUSH
74873: LD_INT 5
74875: PPUSH
74876: CALL_OW 273
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
74885: LD_VAR 0 16
74889: PUSH
74890: LD_INT 1
74892: ARRAY
74893: PPUSH
74894: LD_VAR 0 16
74898: PUSH
74899: LD_INT 2
74901: ARRAY
74902: PPUSH
74903: CALL_OW 488
74907: IFFALSE 74938
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
74909: LD_VAR 0 13
74913: PPUSH
74914: LD_VAR 0 16
74918: PUSH
74919: LD_INT 1
74921: ARRAY
74922: PPUSH
74923: LD_VAR 0 16
74927: PUSH
74928: LD_INT 2
74930: ARRAY
74931: PPUSH
74932: CALL_OW 111
// continue ;
74936: GO 74428
// end ; end ; r := GetDir ( tmp ) ;
74938: LD_ADDR_VAR 0 15
74942: PUSH
74943: LD_VAR 0 13
74947: PPUSH
74948: CALL_OW 254
74952: ST_TO_ADDR
// if r = 5 then
74953: LD_VAR 0 15
74957: PUSH
74958: LD_INT 5
74960: EQUAL
74961: IFFALSE 74971
// r := 0 ;
74963: LD_ADDR_VAR 0 15
74967: PUSH
74968: LD_INT 0
74970: ST_TO_ADDR
// for j = r to 5 do
74971: LD_ADDR_VAR 0 10
74975: PUSH
74976: DOUBLE
74977: LD_VAR 0 15
74981: DEC
74982: ST_TO_ADDR
74983: LD_INT 5
74985: PUSH
74986: FOR_TO
74987: IFFALSE 75101
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
74989: LD_ADDR_VAR 0 11
74993: PUSH
74994: LD_VAR 0 13
74998: PPUSH
74999: CALL_OW 250
75003: PPUSH
75004: LD_VAR 0 10
75008: PPUSH
75009: LD_INT 2
75011: PPUSH
75012: CALL_OW 272
75016: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75017: LD_ADDR_VAR 0 12
75021: PUSH
75022: LD_VAR 0 13
75026: PPUSH
75027: CALL_OW 251
75031: PPUSH
75032: LD_VAR 0 10
75036: PPUSH
75037: LD_INT 2
75039: PPUSH
75040: CALL_OW 273
75044: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75045: LD_VAR 0 11
75049: PPUSH
75050: LD_VAR 0 12
75054: PPUSH
75055: CALL_OW 488
75059: PUSH
75060: LD_VAR 0 11
75064: PPUSH
75065: LD_VAR 0 12
75069: PPUSH
75070: CALL_OW 428
75074: NOT
75075: AND
75076: IFFALSE 75099
// begin ComMoveXY ( tmp , _x , _y ) ;
75078: LD_VAR 0 13
75082: PPUSH
75083: LD_VAR 0 11
75087: PPUSH
75088: LD_VAR 0 12
75092: PPUSH
75093: CALL_OW 111
// break ;
75097: GO 75101
// end ; end ;
75099: GO 74986
75101: POP
75102: POP
// end ; end ;
75103: GO 74428
75105: POP
75106: POP
// end ;
75107: LD_VAR 0 8
75111: RET
// export function BuildingTechInvented ( side , btype ) ; begin
75112: LD_INT 0
75114: PPUSH
// result := true ;
75115: LD_ADDR_VAR 0 3
75119: PUSH
75120: LD_INT 1
75122: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
75123: LD_VAR 0 2
75127: PUSH
75128: LD_INT 24
75130: DOUBLE
75131: EQUAL
75132: IFTRUE 75142
75134: LD_INT 33
75136: DOUBLE
75137: EQUAL
75138: IFTRUE 75142
75140: GO 75167
75142: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
75143: LD_ADDR_VAR 0 3
75147: PUSH
75148: LD_INT 32
75150: PPUSH
75151: LD_VAR 0 1
75155: PPUSH
75156: CALL_OW 321
75160: PUSH
75161: LD_INT 2
75163: EQUAL
75164: ST_TO_ADDR
75165: GO 75487
75167: LD_INT 20
75169: DOUBLE
75170: EQUAL
75171: IFTRUE 75175
75173: GO 75200
75175: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
75176: LD_ADDR_VAR 0 3
75180: PUSH
75181: LD_INT 6
75183: PPUSH
75184: LD_VAR 0 1
75188: PPUSH
75189: CALL_OW 321
75193: PUSH
75194: LD_INT 2
75196: EQUAL
75197: ST_TO_ADDR
75198: GO 75487
75200: LD_INT 22
75202: DOUBLE
75203: EQUAL
75204: IFTRUE 75214
75206: LD_INT 36
75208: DOUBLE
75209: EQUAL
75210: IFTRUE 75214
75212: GO 75239
75214: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
75215: LD_ADDR_VAR 0 3
75219: PUSH
75220: LD_INT 15
75222: PPUSH
75223: LD_VAR 0 1
75227: PPUSH
75228: CALL_OW 321
75232: PUSH
75233: LD_INT 2
75235: EQUAL
75236: ST_TO_ADDR
75237: GO 75487
75239: LD_INT 30
75241: DOUBLE
75242: EQUAL
75243: IFTRUE 75247
75245: GO 75272
75247: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
75248: LD_ADDR_VAR 0 3
75252: PUSH
75253: LD_INT 20
75255: PPUSH
75256: LD_VAR 0 1
75260: PPUSH
75261: CALL_OW 321
75265: PUSH
75266: LD_INT 2
75268: EQUAL
75269: ST_TO_ADDR
75270: GO 75487
75272: LD_INT 28
75274: DOUBLE
75275: EQUAL
75276: IFTRUE 75286
75278: LD_INT 21
75280: DOUBLE
75281: EQUAL
75282: IFTRUE 75286
75284: GO 75311
75286: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
75287: LD_ADDR_VAR 0 3
75291: PUSH
75292: LD_INT 21
75294: PPUSH
75295: LD_VAR 0 1
75299: PPUSH
75300: CALL_OW 321
75304: PUSH
75305: LD_INT 2
75307: EQUAL
75308: ST_TO_ADDR
75309: GO 75487
75311: LD_INT 16
75313: DOUBLE
75314: EQUAL
75315: IFTRUE 75319
75317: GO 75346
75319: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
75320: LD_ADDR_VAR 0 3
75324: PUSH
75325: LD_EXP 85
75329: PPUSH
75330: LD_VAR 0 1
75334: PPUSH
75335: CALL_OW 321
75339: PUSH
75340: LD_INT 2
75342: EQUAL
75343: ST_TO_ADDR
75344: GO 75487
75346: LD_INT 19
75348: DOUBLE
75349: EQUAL
75350: IFTRUE 75360
75352: LD_INT 23
75354: DOUBLE
75355: EQUAL
75356: IFTRUE 75360
75358: GO 75387
75360: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
75361: LD_ADDR_VAR 0 3
75365: PUSH
75366: LD_EXP 84
75370: PPUSH
75371: LD_VAR 0 1
75375: PPUSH
75376: CALL_OW 321
75380: PUSH
75381: LD_INT 2
75383: EQUAL
75384: ST_TO_ADDR
75385: GO 75487
75387: LD_INT 17
75389: DOUBLE
75390: EQUAL
75391: IFTRUE 75395
75393: GO 75420
75395: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
75396: LD_ADDR_VAR 0 3
75400: PUSH
75401: LD_INT 39
75403: PPUSH
75404: LD_VAR 0 1
75408: PPUSH
75409: CALL_OW 321
75413: PUSH
75414: LD_INT 2
75416: EQUAL
75417: ST_TO_ADDR
75418: GO 75487
75420: LD_INT 18
75422: DOUBLE
75423: EQUAL
75424: IFTRUE 75428
75426: GO 75453
75428: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
75429: LD_ADDR_VAR 0 3
75433: PUSH
75434: LD_INT 40
75436: PPUSH
75437: LD_VAR 0 1
75441: PPUSH
75442: CALL_OW 321
75446: PUSH
75447: LD_INT 2
75449: EQUAL
75450: ST_TO_ADDR
75451: GO 75487
75453: LD_INT 27
75455: DOUBLE
75456: EQUAL
75457: IFTRUE 75461
75459: GO 75486
75461: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
75462: LD_ADDR_VAR 0 3
75466: PUSH
75467: LD_INT 35
75469: PPUSH
75470: LD_VAR 0 1
75474: PPUSH
75475: CALL_OW 321
75479: PUSH
75480: LD_INT 2
75482: EQUAL
75483: ST_TO_ADDR
75484: GO 75487
75486: POP
// end ;
75487: LD_VAR 0 3
75491: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
75492: LD_INT 0
75494: PPUSH
75495: PPUSH
75496: PPUSH
75497: PPUSH
75498: PPUSH
75499: PPUSH
75500: PPUSH
75501: PPUSH
75502: PPUSH
75503: PPUSH
75504: PPUSH
// result := false ;
75505: LD_ADDR_VAR 0 6
75509: PUSH
75510: LD_INT 0
75512: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
75513: LD_VAR 0 1
75517: NOT
75518: PUSH
75519: LD_VAR 0 1
75523: PPUSH
75524: CALL_OW 266
75528: PUSH
75529: LD_INT 0
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: IN
75539: NOT
75540: OR
75541: PUSH
75542: LD_VAR 0 2
75546: NOT
75547: OR
75548: PUSH
75549: LD_VAR 0 5
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 1
75559: PUSH
75560: LD_INT 2
75562: PUSH
75563: LD_INT 3
75565: PUSH
75566: LD_INT 4
75568: PUSH
75569: LD_INT 5
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: IN
75580: NOT
75581: OR
75582: PUSH
75583: LD_VAR 0 3
75587: PPUSH
75588: LD_VAR 0 4
75592: PPUSH
75593: CALL_OW 488
75597: NOT
75598: OR
75599: IFFALSE 75603
// exit ;
75601: GO 76339
// side := GetSide ( depot ) ;
75603: LD_ADDR_VAR 0 9
75607: PUSH
75608: LD_VAR 0 1
75612: PPUSH
75613: CALL_OW 255
75617: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
75618: LD_VAR 0 9
75622: PPUSH
75623: LD_VAR 0 2
75627: PPUSH
75628: CALL 75112 0 2
75632: NOT
75633: IFFALSE 75637
// exit ;
75635: GO 76339
// pom := GetBase ( depot ) ;
75637: LD_ADDR_VAR 0 10
75641: PUSH
75642: LD_VAR 0 1
75646: PPUSH
75647: CALL_OW 274
75651: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
75652: LD_ADDR_VAR 0 11
75656: PUSH
75657: LD_VAR 0 2
75661: PPUSH
75662: LD_VAR 0 1
75666: PPUSH
75667: CALL_OW 248
75671: PPUSH
75672: CALL_OW 450
75676: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
75677: LD_VAR 0 10
75681: PPUSH
75682: LD_INT 1
75684: PPUSH
75685: CALL_OW 275
75689: PUSH
75690: LD_VAR 0 11
75694: PUSH
75695: LD_INT 1
75697: ARRAY
75698: GREATEREQUAL
75699: PUSH
75700: LD_VAR 0 10
75704: PPUSH
75705: LD_INT 2
75707: PPUSH
75708: CALL_OW 275
75712: PUSH
75713: LD_VAR 0 11
75717: PUSH
75718: LD_INT 2
75720: ARRAY
75721: GREATEREQUAL
75722: AND
75723: PUSH
75724: LD_VAR 0 10
75728: PPUSH
75729: LD_INT 3
75731: PPUSH
75732: CALL_OW 275
75736: PUSH
75737: LD_VAR 0 11
75741: PUSH
75742: LD_INT 3
75744: ARRAY
75745: GREATEREQUAL
75746: AND
75747: NOT
75748: IFFALSE 75752
// exit ;
75750: GO 76339
// if GetBType ( depot ) = b_depot then
75752: LD_VAR 0 1
75756: PPUSH
75757: CALL_OW 266
75761: PUSH
75762: LD_INT 0
75764: EQUAL
75765: IFFALSE 75777
// dist := 28 else
75767: LD_ADDR_VAR 0 14
75771: PUSH
75772: LD_INT 28
75774: ST_TO_ADDR
75775: GO 75785
// dist := 36 ;
75777: LD_ADDR_VAR 0 14
75781: PUSH
75782: LD_INT 36
75784: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
75785: LD_VAR 0 1
75789: PPUSH
75790: LD_VAR 0 3
75794: PPUSH
75795: LD_VAR 0 4
75799: PPUSH
75800: CALL_OW 297
75804: PUSH
75805: LD_VAR 0 14
75809: GREATER
75810: IFFALSE 75814
// exit ;
75812: GO 76339
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
75814: LD_ADDR_VAR 0 12
75818: PUSH
75819: LD_VAR 0 2
75823: PPUSH
75824: LD_VAR 0 3
75828: PPUSH
75829: LD_VAR 0 4
75833: PPUSH
75834: LD_VAR 0 5
75838: PPUSH
75839: LD_VAR 0 1
75843: PPUSH
75844: CALL_OW 248
75848: PPUSH
75849: LD_INT 0
75851: PPUSH
75852: CALL 76344 0 6
75856: ST_TO_ADDR
// if not hexes then
75857: LD_VAR 0 12
75861: NOT
75862: IFFALSE 75866
// exit ;
75864: GO 76339
// hex := GetHexInfo ( x , y ) ;
75866: LD_ADDR_VAR 0 15
75870: PUSH
75871: LD_VAR 0 3
75875: PPUSH
75876: LD_VAR 0 4
75880: PPUSH
75881: CALL_OW 546
75885: ST_TO_ADDR
// if hex [ 1 ] then
75886: LD_VAR 0 15
75890: PUSH
75891: LD_INT 1
75893: ARRAY
75894: IFFALSE 75898
// exit ;
75896: GO 76339
// height := hex [ 2 ] ;
75898: LD_ADDR_VAR 0 13
75902: PUSH
75903: LD_VAR 0 15
75907: PUSH
75908: LD_INT 2
75910: ARRAY
75911: ST_TO_ADDR
// for i = 1 to hexes do
75912: LD_ADDR_VAR 0 7
75916: PUSH
75917: DOUBLE
75918: LD_INT 1
75920: DEC
75921: ST_TO_ADDR
75922: LD_VAR 0 12
75926: PUSH
75927: FOR_TO
75928: IFFALSE 76258
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
75930: LD_VAR 0 12
75934: PUSH
75935: LD_VAR 0 7
75939: ARRAY
75940: PUSH
75941: LD_INT 1
75943: ARRAY
75944: PPUSH
75945: LD_VAR 0 12
75949: PUSH
75950: LD_VAR 0 7
75954: ARRAY
75955: PUSH
75956: LD_INT 2
75958: ARRAY
75959: PPUSH
75960: CALL_OW 488
75964: NOT
75965: PUSH
75966: LD_VAR 0 12
75970: PUSH
75971: LD_VAR 0 7
75975: ARRAY
75976: PUSH
75977: LD_INT 1
75979: ARRAY
75980: PPUSH
75981: LD_VAR 0 12
75985: PUSH
75986: LD_VAR 0 7
75990: ARRAY
75991: PUSH
75992: LD_INT 2
75994: ARRAY
75995: PPUSH
75996: CALL_OW 428
76000: PUSH
76001: LD_INT 0
76003: GREATER
76004: OR
76005: PUSH
76006: LD_VAR 0 12
76010: PUSH
76011: LD_VAR 0 7
76015: ARRAY
76016: PUSH
76017: LD_INT 1
76019: ARRAY
76020: PPUSH
76021: LD_VAR 0 12
76025: PUSH
76026: LD_VAR 0 7
76030: ARRAY
76031: PUSH
76032: LD_INT 2
76034: ARRAY
76035: PPUSH
76036: CALL_OW 351
76040: OR
76041: IFFALSE 76047
// exit ;
76043: POP
76044: POP
76045: GO 76339
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76047: LD_ADDR_VAR 0 8
76051: PUSH
76052: LD_VAR 0 12
76056: PUSH
76057: LD_VAR 0 7
76061: ARRAY
76062: PUSH
76063: LD_INT 1
76065: ARRAY
76066: PPUSH
76067: LD_VAR 0 12
76071: PUSH
76072: LD_VAR 0 7
76076: ARRAY
76077: PUSH
76078: LD_INT 2
76080: ARRAY
76081: PPUSH
76082: CALL_OW 546
76086: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
76087: LD_VAR 0 8
76091: PUSH
76092: LD_INT 1
76094: ARRAY
76095: PUSH
76096: LD_VAR 0 8
76100: PUSH
76101: LD_INT 2
76103: ARRAY
76104: PUSH
76105: LD_VAR 0 13
76109: PUSH
76110: LD_INT 2
76112: PLUS
76113: GREATER
76114: OR
76115: PUSH
76116: LD_VAR 0 8
76120: PUSH
76121: LD_INT 2
76123: ARRAY
76124: PUSH
76125: LD_VAR 0 13
76129: PUSH
76130: LD_INT 2
76132: MINUS
76133: LESS
76134: OR
76135: PUSH
76136: LD_VAR 0 8
76140: PUSH
76141: LD_INT 3
76143: ARRAY
76144: PUSH
76145: LD_INT 0
76147: PUSH
76148: LD_INT 8
76150: PUSH
76151: LD_INT 9
76153: PUSH
76154: LD_INT 10
76156: PUSH
76157: LD_INT 11
76159: PUSH
76160: LD_INT 12
76162: PUSH
76163: LD_INT 13
76165: PUSH
76166: LD_INT 16
76168: PUSH
76169: LD_INT 17
76171: PUSH
76172: LD_INT 18
76174: PUSH
76175: LD_INT 19
76177: PUSH
76178: LD_INT 20
76180: PUSH
76181: LD_INT 21
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: IN
76199: NOT
76200: OR
76201: PUSH
76202: LD_VAR 0 8
76206: PUSH
76207: LD_INT 5
76209: ARRAY
76210: NOT
76211: OR
76212: PUSH
76213: LD_VAR 0 8
76217: PUSH
76218: LD_INT 6
76220: ARRAY
76221: PUSH
76222: LD_INT 1
76224: PUSH
76225: LD_INT 2
76227: PUSH
76228: LD_INT 7
76230: PUSH
76231: LD_INT 9
76233: PUSH
76234: LD_INT 10
76236: PUSH
76237: LD_INT 11
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: IN
76248: NOT
76249: OR
76250: IFFALSE 76256
// exit ;
76252: POP
76253: POP
76254: GO 76339
// end ;
76256: GO 75927
76258: POP
76259: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76260: LD_VAR 0 9
76264: PPUSH
76265: LD_VAR 0 3
76269: PPUSH
76270: LD_VAR 0 4
76274: PPUSH
76275: LD_INT 20
76277: PPUSH
76278: CALL 68285 0 4
76282: PUSH
76283: LD_INT 4
76285: ARRAY
76286: IFFALSE 76290
// exit ;
76288: GO 76339
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
76290: LD_VAR 0 2
76294: PUSH
76295: LD_INT 29
76297: PUSH
76298: LD_INT 30
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: IN
76305: PUSH
76306: LD_VAR 0 3
76310: PPUSH
76311: LD_VAR 0 4
76315: PPUSH
76316: LD_VAR 0 9
76320: PPUSH
76321: CALL_OW 440
76325: NOT
76326: AND
76327: IFFALSE 76331
// exit ;
76329: GO 76339
// result := true ;
76331: LD_ADDR_VAR 0 6
76335: PUSH
76336: LD_INT 1
76338: ST_TO_ADDR
// end ;
76339: LD_VAR 0 6
76343: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
76344: LD_INT 0
76346: PPUSH
76347: PPUSH
76348: PPUSH
76349: PPUSH
76350: PPUSH
76351: PPUSH
76352: PPUSH
76353: PPUSH
76354: PPUSH
76355: PPUSH
76356: PPUSH
76357: PPUSH
76358: PPUSH
76359: PPUSH
76360: PPUSH
76361: PPUSH
76362: PPUSH
76363: PPUSH
76364: PPUSH
76365: PPUSH
76366: PPUSH
76367: PPUSH
76368: PPUSH
76369: PPUSH
76370: PPUSH
76371: PPUSH
76372: PPUSH
76373: PPUSH
76374: PPUSH
76375: PPUSH
76376: PPUSH
76377: PPUSH
76378: PPUSH
76379: PPUSH
76380: PPUSH
76381: PPUSH
76382: PPUSH
76383: PPUSH
76384: PPUSH
76385: PPUSH
76386: PPUSH
76387: PPUSH
76388: PPUSH
76389: PPUSH
76390: PPUSH
76391: PPUSH
76392: PPUSH
76393: PPUSH
76394: PPUSH
76395: PPUSH
76396: PPUSH
76397: PPUSH
76398: PPUSH
76399: PPUSH
76400: PPUSH
76401: PPUSH
76402: PPUSH
76403: PPUSH
// result = [ ] ;
76404: LD_ADDR_VAR 0 7
76408: PUSH
76409: EMPTY
76410: ST_TO_ADDR
// temp_list = [ ] ;
76411: LD_ADDR_VAR 0 9
76415: PUSH
76416: EMPTY
76417: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76418: LD_VAR 0 4
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: LD_INT 2
76431: PUSH
76432: LD_INT 3
76434: PUSH
76435: LD_INT 4
76437: PUSH
76438: LD_INT 5
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: IN
76449: NOT
76450: PUSH
76451: LD_VAR 0 1
76455: PUSH
76456: LD_INT 0
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: IN
76466: PUSH
76467: LD_VAR 0 5
76471: PUSH
76472: LD_INT 1
76474: PUSH
76475: LD_INT 2
76477: PUSH
76478: LD_INT 3
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: LIST
76485: IN
76486: NOT
76487: AND
76488: OR
76489: IFFALSE 76493
// exit ;
76491: GO 94884
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
76493: LD_VAR 0 1
76497: PUSH
76498: LD_INT 6
76500: PUSH
76501: LD_INT 7
76503: PUSH
76504: LD_INT 8
76506: PUSH
76507: LD_INT 13
76509: PUSH
76510: LD_INT 12
76512: PUSH
76513: LD_INT 15
76515: PUSH
76516: LD_INT 11
76518: PUSH
76519: LD_INT 14
76521: PUSH
76522: LD_INT 10
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: IN
76536: IFFALSE 76546
// btype = b_lab ;
76538: LD_ADDR_VAR 0 1
76542: PUSH
76543: LD_INT 6
76545: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
76546: LD_VAR 0 6
76550: PUSH
76551: LD_INT 0
76553: PUSH
76554: LD_INT 1
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: LIST
76564: IN
76565: NOT
76566: PUSH
76567: LD_VAR 0 1
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: LD_INT 1
76577: PUSH
76578: LD_INT 2
76580: PUSH
76581: LD_INT 3
76583: PUSH
76584: LD_INT 6
76586: PUSH
76587: LD_INT 36
76589: PUSH
76590: LD_INT 4
76592: PUSH
76593: LD_INT 5
76595: PUSH
76596: LD_INT 31
76598: PUSH
76599: LD_INT 32
76601: PUSH
76602: LD_INT 33
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: LIST
76614: LIST
76615: LIST
76616: LIST
76617: IN
76618: NOT
76619: PUSH
76620: LD_VAR 0 6
76624: PUSH
76625: LD_INT 1
76627: EQUAL
76628: AND
76629: OR
76630: PUSH
76631: LD_VAR 0 1
76635: PUSH
76636: LD_INT 2
76638: PUSH
76639: LD_INT 3
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: IN
76646: NOT
76647: PUSH
76648: LD_VAR 0 6
76652: PUSH
76653: LD_INT 2
76655: EQUAL
76656: AND
76657: OR
76658: IFFALSE 76668
// mode = 0 ;
76660: LD_ADDR_VAR 0 6
76664: PUSH
76665: LD_INT 0
76667: ST_TO_ADDR
// case mode of 0 :
76668: LD_VAR 0 6
76672: PUSH
76673: LD_INT 0
76675: DOUBLE
76676: EQUAL
76677: IFTRUE 76681
76679: GO 88134
76681: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76682: LD_ADDR_VAR 0 11
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 1
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 1
76740: NEG
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: LD_INT 1
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 1
76763: NEG
76764: PUSH
76765: LD_INT 2
76767: NEG
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 0
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 1
76786: PUSH
76787: LD_INT 1
76789: NEG
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 1
76797: PUSH
76798: LD_INT 2
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 0
76807: PUSH
76808: LD_INT 2
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 1
76817: NEG
76818: PUSH
76819: LD_INT 1
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: LD_INT 3
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 0
76838: PUSH
76839: LD_INT 3
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 2
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76875: LD_ADDR_VAR 0 12
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 0
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: LD_INT 0
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 1
76913: PUSH
76914: LD_INT 1
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 0
76923: PUSH
76924: LD_INT 1
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: LD_INT 1
76933: NEG
76934: PUSH
76935: LD_INT 0
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 1
76944: NEG
76945: PUSH
76946: LD_INT 1
76948: NEG
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: PUSH
76954: LD_INT 1
76956: PUSH
76957: LD_INT 1
76959: NEG
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: LD_INT 2
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 2
76977: PUSH
76978: LD_INT 1
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 1
76987: NEG
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 2
76998: NEG
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 2
77009: NEG
77010: PUSH
77011: LD_INT 1
77013: NEG
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 2
77021: NEG
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 3
77032: NEG
77033: PUSH
77034: LD_INT 0
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 3
77043: NEG
77044: PUSH
77045: LD_INT 1
77047: NEG
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: LIST
77070: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77071: LD_ADDR_VAR 0 13
77075: PUSH
77076: LD_INT 0
77078: PUSH
77079: LD_INT 0
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 0
77088: PUSH
77089: LD_INT 1
77091: NEG
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 1
77099: PUSH
77100: LD_INT 0
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 1
77109: PUSH
77110: LD_INT 1
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 0
77119: PUSH
77120: LD_INT 1
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 1
77129: NEG
77130: PUSH
77131: LD_INT 0
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 1
77140: NEG
77141: PUSH
77142: LD_INT 1
77144: NEG
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 1
77152: NEG
77153: PUSH
77154: LD_INT 2
77156: NEG
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 2
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 2
77174: PUSH
77175: LD_INT 2
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: LD_INT 2
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 2
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 2
77206: NEG
77207: PUSH
77208: LD_INT 2
77210: NEG
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 2
77218: NEG
77219: PUSH
77220: LD_INT 3
77222: NEG
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PUSH
77228: LD_INT 3
77230: NEG
77231: PUSH
77232: LD_INT 2
77234: NEG
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: PUSH
77240: LD_INT 3
77242: NEG
77243: PUSH
77244: LD_INT 3
77246: NEG
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77270: LD_ADDR_VAR 0 14
77274: PUSH
77275: LD_INT 0
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: LD_INT 1
77290: NEG
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: LD_INT 0
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: LD_INT 1
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 0
77318: PUSH
77319: LD_INT 1
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 1
77328: NEG
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 1
77339: NEG
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: LD_INT 2
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 0
77363: PUSH
77364: LD_INT 2
77366: NEG
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: LD_INT 1
77377: NEG
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 1
77385: PUSH
77386: LD_INT 2
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 0
77395: PUSH
77396: LD_INT 2
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 1
77405: NEG
77406: PUSH
77407: LD_INT 1
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: NEG
77417: PUSH
77418: LD_INT 3
77420: NEG
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 0
77428: PUSH
77429: LD_INT 3
77431: NEG
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 1
77439: PUSH
77440: LD_INT 2
77442: NEG
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77466: LD_ADDR_VAR 0 15
77470: PUSH
77471: LD_INT 0
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: LD_INT 1
77486: NEG
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 1
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 1
77504: PUSH
77505: LD_INT 1
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: NEG
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 1
77535: NEG
77536: PUSH
77537: LD_INT 1
77539: NEG
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 1
77547: PUSH
77548: LD_INT 1
77550: NEG
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 2
77558: PUSH
77559: LD_INT 0
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 2
77568: PUSH
77569: LD_INT 1
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 1
77578: NEG
77579: PUSH
77580: LD_INT 1
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 2
77589: NEG
77590: PUSH
77591: LD_INT 0
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 2
77600: NEG
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 2
77612: PUSH
77613: LD_INT 1
77615: NEG
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 3
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 3
77633: PUSH
77634: LD_INT 1
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77659: LD_ADDR_VAR 0 16
77663: PUSH
77664: LD_INT 0
77666: PUSH
77667: LD_INT 0
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PUSH
77674: LD_INT 0
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: LD_INT 0
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 1
77697: PUSH
77698: LD_INT 1
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 0
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 1
77717: NEG
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: NEG
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 1
77740: NEG
77741: PUSH
77742: LD_INT 2
77744: NEG
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 2
77752: PUSH
77753: LD_INT 1
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 2
77762: PUSH
77763: LD_INT 2
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: LD_INT 2
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 2
77782: NEG
77783: PUSH
77784: LD_INT 1
77786: NEG
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 2
77794: NEG
77795: PUSH
77796: LD_INT 2
77798: NEG
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 3
77806: PUSH
77807: LD_INT 2
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 3
77816: PUSH
77817: LD_INT 3
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 2
77826: PUSH
77827: LD_INT 3
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77852: LD_ADDR_VAR 0 17
77856: PUSH
77857: LD_INT 0
77859: PUSH
77860: LD_INT 0
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 0
77869: PUSH
77870: LD_INT 1
77872: NEG
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 1
77880: PUSH
77881: LD_INT 0
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 1
77890: PUSH
77891: LD_INT 1
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 0
77900: PUSH
77901: LD_INT 1
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 1
77910: NEG
77911: PUSH
77912: LD_INT 0
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: LD_INT 1
77925: NEG
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 1
77933: NEG
77934: PUSH
77935: LD_INT 2
77937: NEG
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: LD_INT 0
77945: PUSH
77946: LD_INT 2
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 1
77956: PUSH
77957: LD_INT 1
77959: NEG
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 0
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 2
77977: PUSH
77978: LD_INT 1
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 2
77987: PUSH
77988: LD_INT 2
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 1
77997: PUSH
77998: LD_INT 2
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 0
78007: PUSH
78008: LD_INT 2
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 1
78017: NEG
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 2
78028: NEG
78029: PUSH
78030: LD_INT 0
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 2
78039: NEG
78040: PUSH
78041: LD_INT 1
78043: NEG
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 2
78051: NEG
78052: PUSH
78053: LD_INT 2
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: LIST
78079: LIST
78080: LIST
78081: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78082: LD_ADDR_VAR 0 18
78086: PUSH
78087: LD_INT 0
78089: PUSH
78090: LD_INT 0
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 0
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 1
78110: PUSH
78111: LD_INT 0
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: LD_INT 1
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: NEG
78141: PUSH
78142: LD_INT 0
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 1
78151: NEG
78152: PUSH
78153: LD_INT 1
78155: NEG
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 1
78163: NEG
78164: PUSH
78165: LD_INT 2
78167: NEG
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 0
78175: PUSH
78176: LD_INT 2
78178: NEG
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: LD_INT 1
78189: NEG
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 2
78197: PUSH
78198: LD_INT 0
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 2
78207: PUSH
78208: LD_INT 1
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 2
78217: PUSH
78218: LD_INT 2
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 1
78227: PUSH
78228: LD_INT 2
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 2
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: LD_INT 1
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 2
78258: NEG
78259: PUSH
78260: LD_INT 0
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 2
78269: NEG
78270: PUSH
78271: LD_INT 1
78273: NEG
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 2
78281: NEG
78282: PUSH
78283: LD_INT 2
78285: NEG
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78312: LD_ADDR_VAR 0 19
78316: PUSH
78317: LD_INT 0
78319: PUSH
78320: LD_INT 0
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 0
78329: PUSH
78330: LD_INT 1
78332: NEG
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 1
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 1
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 0
78360: PUSH
78361: LD_INT 1
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 1
78370: NEG
78371: PUSH
78372: LD_INT 0
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 1
78381: NEG
78382: PUSH
78383: LD_INT 1
78385: NEG
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: LD_INT 2
78397: NEG
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 0
78405: PUSH
78406: LD_INT 2
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: LD_INT 1
78419: NEG
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: LD_INT 2
78427: PUSH
78428: LD_INT 0
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 2
78437: PUSH
78438: LD_INT 1
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 2
78447: PUSH
78448: LD_INT 2
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 1
78457: PUSH
78458: LD_INT 2
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: LD_INT 2
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 2
78488: NEG
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 2
78499: NEG
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 2
78511: NEG
78512: PUSH
78513: LD_INT 2
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78542: LD_ADDR_VAR 0 20
78546: PUSH
78547: LD_INT 0
78549: PUSH
78550: LD_INT 0
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 0
78559: PUSH
78560: LD_INT 1
78562: NEG
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 1
78570: PUSH
78571: LD_INT 0
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: LD_INT 1
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 0
78590: PUSH
78591: LD_INT 1
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 1
78600: NEG
78601: PUSH
78602: LD_INT 0
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: LD_INT 1
78615: NEG
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: LD_INT 2
78627: NEG
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 0
78635: PUSH
78636: LD_INT 2
78638: NEG
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 1
78646: PUSH
78647: LD_INT 1
78649: NEG
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 2
78657: PUSH
78658: LD_INT 0
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 2
78667: PUSH
78668: LD_INT 1
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 2
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 1
78687: PUSH
78688: LD_INT 2
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: LD_INT 2
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 1
78707: NEG
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 2
78718: NEG
78719: PUSH
78720: LD_INT 0
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 2
78729: NEG
78730: PUSH
78731: LD_INT 1
78733: NEG
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 2
78741: NEG
78742: PUSH
78743: LD_INT 2
78745: NEG
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78772: LD_ADDR_VAR 0 21
78776: PUSH
78777: LD_INT 0
78779: PUSH
78780: LD_INT 0
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 1
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: LD_INT 1
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 1
78830: NEG
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 1
78841: NEG
78842: PUSH
78843: LD_INT 1
78845: NEG
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 1
78853: NEG
78854: PUSH
78855: LD_INT 2
78857: NEG
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 0
78865: PUSH
78866: LD_INT 2
78868: NEG
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 1
78876: PUSH
78877: LD_INT 1
78879: NEG
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 2
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 2
78897: PUSH
78898: LD_INT 1
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: LD_INT 2
78907: PUSH
78908: LD_INT 2
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: LD_INT 1
78917: PUSH
78918: LD_INT 2
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 0
78927: PUSH
78928: LD_INT 2
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 1
78937: NEG
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 2
78948: NEG
78949: PUSH
78950: LD_INT 0
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 2
78959: NEG
78960: PUSH
78961: LD_INT 1
78963: NEG
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 2
78971: NEG
78972: PUSH
78973: LD_INT 2
78975: NEG
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79002: LD_ADDR_VAR 0 22
79006: PUSH
79007: LD_INT 0
79009: PUSH
79010: LD_INT 0
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 1
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: NEG
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: LD_INT 2
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 0
79095: PUSH
79096: LD_INT 2
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: LD_INT 1
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 2
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 2
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 2
79137: PUSH
79138: LD_INT 2
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 1
79147: PUSH
79148: LD_INT 2
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 0
79157: PUSH
79158: LD_INT 2
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 1
79167: NEG
79168: PUSH
79169: LD_INT 1
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 2
79178: NEG
79179: PUSH
79180: LD_INT 0
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 2
79189: NEG
79190: PUSH
79191: LD_INT 1
79193: NEG
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 2
79201: NEG
79202: PUSH
79203: LD_INT 2
79205: NEG
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79232: LD_ADDR_VAR 0 23
79236: PUSH
79237: LD_INT 0
79239: PUSH
79240: LD_INT 0
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: LD_INT 1
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 0
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 1
79270: PUSH
79271: LD_INT 1
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 0
79280: PUSH
79281: LD_INT 1
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 1
79290: NEG
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 1
79301: NEG
79302: PUSH
79303: LD_INT 1
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 1
79313: NEG
79314: PUSH
79315: LD_INT 2
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 1
79336: PUSH
79337: LD_INT 1
79339: NEG
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 2
79347: PUSH
79348: LD_INT 0
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 2
79357: PUSH
79358: LD_INT 1
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 2
79367: PUSH
79368: LD_INT 2
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 1
79377: PUSH
79378: LD_INT 2
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 0
79387: PUSH
79388: LD_INT 2
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 1
79397: NEG
79398: PUSH
79399: LD_INT 1
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: LD_INT 0
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 2
79419: NEG
79420: PUSH
79421: LD_INT 1
79423: NEG
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: PUSH
79429: LD_INT 2
79431: NEG
79432: PUSH
79433: LD_INT 2
79435: NEG
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: LD_INT 3
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: LD_INT 3
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: LD_INT 2
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 2
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
79512: LD_ADDR_VAR 0 24
79516: PUSH
79517: LD_INT 0
79519: PUSH
79520: LD_INT 0
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 1
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 0
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 1
79550: PUSH
79551: LD_INT 1
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 0
79560: PUSH
79561: LD_INT 1
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: LD_INT 0
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 1
79581: NEG
79582: PUSH
79583: LD_INT 1
79585: NEG
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: LD_INT 2
79597: NEG
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 0
79605: PUSH
79606: LD_INT 2
79608: NEG
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 1
79616: PUSH
79617: LD_INT 1
79619: NEG
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 2
79627: PUSH
79628: LD_INT 0
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 2
79637: PUSH
79638: LD_INT 1
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 2
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 1
79657: PUSH
79658: LD_INT 2
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: LD_INT 2
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 1
79677: NEG
79678: PUSH
79679: LD_INT 1
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 2
79688: NEG
79689: PUSH
79690: LD_INT 0
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 2
79699: NEG
79700: PUSH
79701: LD_INT 1
79703: NEG
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 2
79711: NEG
79712: PUSH
79713: LD_INT 2
79715: NEG
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 1
79723: PUSH
79724: LD_INT 2
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 2
79734: PUSH
79735: LD_INT 1
79737: NEG
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 3
79745: PUSH
79746: LD_INT 1
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 3
79755: PUSH
79756: LD_INT 2
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
79788: LD_ADDR_VAR 0 25
79792: PUSH
79793: LD_INT 0
79795: PUSH
79796: LD_INT 0
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 0
79805: PUSH
79806: LD_INT 1
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 1
79816: PUSH
79817: LD_INT 0
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 1
79826: PUSH
79827: LD_INT 1
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 0
79836: PUSH
79837: LD_INT 1
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 1
79857: NEG
79858: PUSH
79859: LD_INT 1
79861: NEG
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 1
79869: NEG
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 0
79881: PUSH
79882: LD_INT 2
79884: NEG
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 1
79892: PUSH
79893: LD_INT 1
79895: NEG
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 2
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 2
79913: PUSH
79914: LD_INT 1
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: LD_INT 2
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 0
79943: PUSH
79944: LD_INT 2
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 1
79953: NEG
79954: PUSH
79955: LD_INT 1
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 2
79964: NEG
79965: PUSH
79966: LD_INT 0
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 2
79975: NEG
79976: PUSH
79977: LD_INT 1
79979: NEG
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 2
79987: NEG
79988: PUSH
79989: LD_INT 2
79991: NEG
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: LD_INT 1
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 2
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: LD_INT 3
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 1
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: LIST
80049: LIST
80050: LIST
80051: LIST
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80062: LD_ADDR_VAR 0 26
80066: PUSH
80067: LD_INT 0
80069: PUSH
80070: LD_INT 0
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 1
80082: NEG
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 1
80090: PUSH
80091: LD_INT 0
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 1
80100: PUSH
80101: LD_INT 1
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 0
80110: PUSH
80111: LD_INT 1
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 1
80120: NEG
80121: PUSH
80122: LD_INT 0
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: NEG
80132: PUSH
80133: LD_INT 1
80135: NEG
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: LD_INT 2
80147: NEG
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 0
80155: PUSH
80156: LD_INT 2
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 1
80166: PUSH
80167: LD_INT 1
80169: NEG
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 2
80177: PUSH
80178: LD_INT 0
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 2
80187: PUSH
80188: LD_INT 1
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: LD_INT 2
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: PUSH
80208: LD_INT 2
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 0
80217: PUSH
80218: LD_INT 2
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: NEG
80228: PUSH
80229: LD_INT 1
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: LD_INT 0
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 2
80261: NEG
80262: PUSH
80263: LD_INT 2
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 2
80273: PUSH
80274: LD_INT 3
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 1
80283: PUSH
80284: LD_INT 3
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 1
80293: NEG
80294: PUSH
80295: LD_INT 2
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 2
80304: NEG
80305: PUSH
80306: LD_INT 1
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: LIST
80322: LIST
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80338: LD_ADDR_VAR 0 27
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: LD_INT 0
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 0
80355: PUSH
80356: LD_INT 1
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 1
80366: PUSH
80367: LD_INT 0
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 1
80376: PUSH
80377: LD_INT 1
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: LD_INT 1
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: PUSH
80394: LD_INT 1
80396: NEG
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: LD_INT 1
80411: NEG
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: LD_INT 2
80423: NEG
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 0
80431: PUSH
80432: LD_INT 2
80434: NEG
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 1
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 2
80453: PUSH
80454: LD_INT 0
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 2
80463: PUSH
80464: LD_INT 1
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 2
80473: PUSH
80474: LD_INT 2
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 1
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 0
80493: PUSH
80494: LD_INT 2
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 1
80503: NEG
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 2
80514: NEG
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 2
80525: NEG
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 2
80537: NEG
80538: PUSH
80539: LD_INT 2
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: NEG
80550: PUSH
80551: LD_INT 2
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 2
80560: NEG
80561: PUSH
80562: LD_INT 1
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 3
80571: NEG
80572: PUSH
80573: LD_INT 1
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 3
80583: NEG
80584: PUSH
80585: LD_INT 2
80587: NEG
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80618: LD_ADDR_VAR 0 28
80622: PUSH
80623: LD_INT 0
80625: PUSH
80626: LD_INT 0
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 1
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 1
80656: PUSH
80657: LD_INT 1
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 0
80666: PUSH
80667: LD_INT 1
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 1
80676: NEG
80677: PUSH
80678: LD_INT 0
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: NEG
80688: PUSH
80689: LD_INT 1
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: NEG
80700: PUSH
80701: LD_INT 2
80703: NEG
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 0
80711: PUSH
80712: LD_INT 2
80714: NEG
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 1
80722: PUSH
80723: LD_INT 1
80725: NEG
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: LD_INT 0
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 2
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 2
80753: PUSH
80754: LD_INT 2
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 1
80763: PUSH
80764: LD_INT 2
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: LD_INT 2
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 1
80783: NEG
80784: PUSH
80785: LD_INT 1
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: NEG
80795: PUSH
80796: LD_INT 0
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 2
80805: NEG
80806: PUSH
80807: LD_INT 1
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 2
80817: NEG
80818: PUSH
80819: LD_INT 2
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 2
80829: NEG
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 3
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 3
80853: NEG
80854: PUSH
80855: LD_INT 1
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 3
80865: NEG
80866: PUSH
80867: LD_INT 2
80869: NEG
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80900: LD_ADDR_VAR 0 29
80904: PUSH
80905: LD_INT 0
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 0
80917: PUSH
80918: LD_INT 1
80920: NEG
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 1
80928: PUSH
80929: LD_INT 0
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 1
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 0
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 1
80958: NEG
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 1
80969: NEG
80970: PUSH
80971: LD_INT 1
80973: NEG
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: NEG
80982: PUSH
80983: LD_INT 2
80985: NEG
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 0
80993: PUSH
80994: LD_INT 2
80996: NEG
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 1
81004: PUSH
81005: LD_INT 1
81007: NEG
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 2
81015: PUSH
81016: LD_INT 0
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 2
81025: PUSH
81026: LD_INT 1
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 1
81035: PUSH
81036: LD_INT 2
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: LD_INT 2
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 2
81066: NEG
81067: PUSH
81068: LD_INT 1
81070: NEG
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: NEG
81079: PUSH
81080: LD_INT 2
81082: NEG
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 2
81090: NEG
81091: PUSH
81092: LD_INT 3
81094: NEG
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 2
81102: PUSH
81103: LD_INT 1
81105: NEG
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 3
81113: PUSH
81114: LD_INT 1
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 1
81123: PUSH
81124: LD_INT 3
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: LD_INT 2
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: LD_INT 3
81144: NEG
81145: PUSH
81146: LD_INT 2
81148: NEG
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81179: LD_ADDR_VAR 0 30
81183: PUSH
81184: LD_INT 0
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 0
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 1
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 0
81227: PUSH
81228: LD_INT 1
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 1
81248: NEG
81249: PUSH
81250: LD_INT 1
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 1
81260: NEG
81261: PUSH
81262: LD_INT 2
81264: NEG
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 0
81272: PUSH
81273: LD_INT 2
81275: NEG
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 1
81283: PUSH
81284: LD_INT 1
81286: NEG
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 2
81294: PUSH
81295: LD_INT 0
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: LD_INT 2
81304: PUSH
81305: LD_INT 1
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 2
81314: PUSH
81315: LD_INT 2
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 1
81324: PUSH
81325: LD_INT 2
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 1
81334: NEG
81335: PUSH
81336: LD_INT 1
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 2
81345: NEG
81346: PUSH
81347: LD_INT 0
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 2
81356: NEG
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: NEG
81369: PUSH
81370: LD_INT 3
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 3
81391: PUSH
81392: LD_INT 2
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: LD_INT 3
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 2
81411: NEG
81412: PUSH
81413: LD_INT 1
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 3
81422: NEG
81423: PUSH
81424: LD_INT 1
81426: NEG
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81457: LD_ADDR_VAR 0 31
81461: PUSH
81462: LD_INT 0
81464: PUSH
81465: LD_INT 0
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 0
81474: PUSH
81475: LD_INT 1
81477: NEG
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 1
81485: PUSH
81486: LD_INT 0
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 1
81495: PUSH
81496: LD_INT 1
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 0
81505: PUSH
81506: LD_INT 1
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 1
81515: NEG
81516: PUSH
81517: LD_INT 0
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 1
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: NEG
81539: PUSH
81540: LD_INT 2
81542: NEG
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 1
81550: PUSH
81551: LD_INT 1
81553: NEG
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 0
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 2
81571: PUSH
81572: LD_INT 1
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 2
81581: PUSH
81582: LD_INT 2
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 1
81591: PUSH
81592: LD_INT 2
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: LD_INT 2
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 1
81611: NEG
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 2
81622: NEG
81623: PUSH
81624: LD_INT 1
81626: NEG
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: NEG
81635: PUSH
81636: LD_INT 2
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 2
81646: NEG
81647: PUSH
81648: LD_INT 3
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 2
81658: PUSH
81659: LD_INT 1
81661: NEG
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 3
81669: PUSH
81670: LD_INT 1
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 1
81679: PUSH
81680: LD_INT 3
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 1
81689: NEG
81690: PUSH
81691: LD_INT 2
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 3
81700: NEG
81701: PUSH
81702: LD_INT 2
81704: NEG
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81735: LD_ADDR_VAR 0 32
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 0
81752: PUSH
81753: LD_INT 1
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 1
81763: PUSH
81764: LD_INT 0
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 1
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: LD_INT 1
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 1
81804: NEG
81805: PUSH
81806: LD_INT 1
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 1
81816: NEG
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 0
81828: PUSH
81829: LD_INT 2
81831: NEG
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 1
81839: PUSH
81840: LD_INT 1
81842: NEG
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 2
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: LD_INT 2
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 0
81880: PUSH
81881: LD_INT 2
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 1
81890: NEG
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: NEG
81902: PUSH
81903: LD_INT 0
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: LD_INT 3
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: PUSH
81937: LD_INT 2
81939: NEG
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 3
81947: PUSH
81948: LD_INT 2
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 2
81957: PUSH
81958: LD_INT 3
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 2
81967: NEG
81968: PUSH
81969: LD_INT 1
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 3
81978: NEG
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82013: LD_ADDR_VAR 0 33
82017: PUSH
82018: LD_INT 0
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: LD_INT 1
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: LD_INT 0
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 1
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 1
82071: NEG
82072: PUSH
82073: LD_INT 0
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: LD_INT 1
82086: NEG
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: LD_INT 2
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: LD_INT 1
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 2
82117: PUSH
82118: LD_INT 0
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 2
82127: PUSH
82128: LD_INT 1
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 0
82147: PUSH
82148: LD_INT 2
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: LD_INT 1
82157: NEG
82158: PUSH
82159: LD_INT 1
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 2
82168: NEG
82169: PUSH
82170: LD_INT 0
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: NEG
82180: PUSH
82181: LD_INT 1
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: NEG
82192: PUSH
82193: LD_INT 2
82195: NEG
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: LD_INT 3
82207: NEG
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 2
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 3
82226: PUSH
82227: LD_INT 1
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 3
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 1
82246: NEG
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 3
82257: NEG
82258: PUSH
82259: LD_INT 2
82261: NEG
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82292: LD_ADDR_VAR 0 34
82296: PUSH
82297: LD_INT 0
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 0
82309: PUSH
82310: LD_INT 1
82312: NEG
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 1
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 1
82330: PUSH
82331: LD_INT 1
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 0
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: NEG
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: LD_INT 1
82365: NEG
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 1
82373: NEG
82374: PUSH
82375: LD_INT 2
82377: NEG
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 0
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 1
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 2
82407: PUSH
82408: LD_INT 1
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 2
82417: PUSH
82418: LD_INT 2
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 1
82427: PUSH
82428: LD_INT 2
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: LD_INT 1
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 2
82448: NEG
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 2
82459: NEG
82460: PUSH
82461: LD_INT 1
82463: NEG
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 2
82471: NEG
82472: PUSH
82473: LD_INT 2
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 1
82483: NEG
82484: PUSH
82485: LD_INT 3
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: LD_INT 2
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 3
82506: PUSH
82507: LD_INT 2
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 2
82516: PUSH
82517: LD_INT 3
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 2
82526: NEG
82527: PUSH
82528: LD_INT 1
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 3
82537: NEG
82538: PUSH
82539: LD_INT 1
82541: NEG
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82572: LD_ADDR_VAR 0 35
82576: PUSH
82577: LD_INT 0
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 0
82589: PUSH
82590: LD_INT 1
82592: NEG
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 1
82600: PUSH
82601: LD_INT 0
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 1
82610: PUSH
82611: LD_INT 1
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 0
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 1
82630: NEG
82631: PUSH
82632: LD_INT 0
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 1
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: LD_INT 1
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82684: LD_ADDR_VAR 0 36
82688: PUSH
82689: LD_INT 0
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 0
82701: PUSH
82702: LD_INT 1
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: LD_INT 0
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: LD_INT 1
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: LD_INT 1
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: NEG
82743: PUSH
82744: LD_INT 0
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: NEG
82754: PUSH
82755: LD_INT 1
82757: NEG
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: LD_INT 2
82769: NEG
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 1
82777: PUSH
82778: LD_INT 2
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
82796: LD_ADDR_VAR 0 37
82800: PUSH
82801: LD_INT 0
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 1
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: LD_INT 0
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: LD_INT 1
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 0
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 1
82854: NEG
82855: PUSH
82856: LD_INT 0
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 1
82865: NEG
82866: PUSH
82867: LD_INT 1
82869: NEG
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 1
82877: PUSH
82878: LD_INT 1
82880: NEG
82881: PUSH
82882: EMPTY
82883: LIST
82884: LIST
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: LD_INT 1
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82908: LD_ADDR_VAR 0 38
82912: PUSH
82913: LD_INT 0
82915: PUSH
82916: LD_INT 0
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 0
82925: PUSH
82926: LD_INT 1
82928: NEG
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 1
82936: PUSH
82937: LD_INT 0
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 0
82956: PUSH
82957: LD_INT 1
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 1
82966: NEG
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 1
82977: NEG
82978: PUSH
82979: LD_INT 1
82981: NEG
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 2
82999: NEG
83000: PUSH
83001: LD_INT 1
83003: NEG
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83020: LD_ADDR_VAR 0 39
83024: PUSH
83025: LD_INT 0
83027: PUSH
83028: LD_INT 0
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 0
83037: PUSH
83038: LD_INT 1
83040: NEG
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: LD_INT 1
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: LD_INT 1
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 0
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 1
83089: NEG
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: LD_INT 2
83105: NEG
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 1
83113: PUSH
83114: LD_INT 2
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83132: LD_ADDR_VAR 0 40
83136: PUSH
83137: LD_INT 0
83139: PUSH
83140: LD_INT 0
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 1
83152: NEG
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 1
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: LD_INT 1
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: LD_INT 0
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 1
83213: PUSH
83214: LD_INT 1
83216: NEG
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 1
83224: NEG
83225: PUSH
83226: LD_INT 1
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83244: LD_ADDR_VAR 0 41
83248: PUSH
83249: LD_INT 0
83251: PUSH
83252: LD_INT 0
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 0
83261: PUSH
83262: LD_INT 1
83264: NEG
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 1
83272: PUSH
83273: LD_INT 0
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: PUSH
83283: LD_INT 1
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: LD_INT 1
83295: PUSH
83296: EMPTY
83297: LIST
83298: LIST
83299: PUSH
83300: LD_INT 1
83302: NEG
83303: PUSH
83304: LD_INT 0
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: LD_INT 1
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 1
83325: NEG
83326: PUSH
83327: LD_INT 2
83329: NEG
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 1
83337: PUSH
83338: LD_INT 1
83340: NEG
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: LD_INT 0
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 2
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 2
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 1
83378: PUSH
83379: LD_INT 2
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 1
83388: NEG
83389: PUSH
83390: LD_INT 1
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 2
83399: NEG
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 2
83410: NEG
83411: PUSH
83412: LD_INT 1
83414: NEG
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 2
83422: NEG
83423: PUSH
83424: LD_INT 2
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 2
83434: NEG
83435: PUSH
83436: LD_INT 3
83438: NEG
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 2
83446: PUSH
83447: LD_INT 1
83449: NEG
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 3
83467: PUSH
83468: LD_INT 1
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 3
83477: PUSH
83478: LD_INT 2
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 3
83487: PUSH
83488: LD_INT 3
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 2
83497: PUSH
83498: LD_INT 3
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 2
83507: NEG
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 3
83518: NEG
83519: PUSH
83520: LD_INT 0
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 3
83529: NEG
83530: PUSH
83531: LD_INT 1
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 3
83541: NEG
83542: PUSH
83543: LD_INT 2
83545: NEG
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 3
83553: NEG
83554: PUSH
83555: LD_INT 3
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83594: LD_ADDR_VAR 0 42
83598: PUSH
83599: LD_INT 0
83601: PUSH
83602: LD_INT 0
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: LD_INT 1
83614: NEG
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: LD_INT 0
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: LD_INT 1
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: LD_INT 1
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 1
83652: NEG
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: LD_INT 1
83667: NEG
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 1
83675: NEG
83676: PUSH
83677: LD_INT 2
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: LD_INT 2
83690: NEG
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 1
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 2
83709: PUSH
83710: LD_INT 1
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 2
83719: PUSH
83720: LD_INT 2
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 1
83729: PUSH
83730: LD_INT 2
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 0
83739: PUSH
83740: LD_INT 2
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: LD_INT 1
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 2
83760: NEG
83761: PUSH
83762: LD_INT 1
83764: NEG
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 2
83772: NEG
83773: PUSH
83774: LD_INT 2
83776: NEG
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 2
83784: NEG
83785: PUSH
83786: LD_INT 3
83788: NEG
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 1
83796: NEG
83797: PUSH
83798: LD_INT 3
83800: NEG
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: PUSH
83806: LD_INT 0
83808: PUSH
83809: LD_INT 3
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: LD_INT 2
83822: NEG
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 3
83830: PUSH
83831: LD_INT 2
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 3
83840: PUSH
83841: LD_INT 3
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 2
83850: PUSH
83851: LD_INT 3
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: PUSH
83861: LD_INT 3
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 0
83870: PUSH
83871: LD_INT 3
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 1
83880: NEG
83881: PUSH
83882: LD_INT 2
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 3
83891: NEG
83892: PUSH
83893: LD_INT 2
83895: NEG
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 3
83903: NEG
83904: PUSH
83905: LD_INT 3
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83944: LD_ADDR_VAR 0 43
83948: PUSH
83949: LD_INT 0
83951: PUSH
83952: LD_INT 0
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: LD_INT 1
83964: NEG
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 1
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 1
83982: PUSH
83983: LD_INT 1
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: LD_INT 1
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 1
84002: NEG
84003: PUSH
84004: LD_INT 0
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PUSH
84011: LD_INT 1
84013: NEG
84014: PUSH
84015: LD_INT 1
84017: NEG
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 1
84025: NEG
84026: PUSH
84027: LD_INT 2
84029: NEG
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 0
84037: PUSH
84038: LD_INT 2
84040: NEG
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 1
84048: PUSH
84049: LD_INT 1
84051: NEG
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 2
84059: PUSH
84060: LD_INT 0
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 2
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: LD_INT 2
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 0
84089: PUSH
84090: LD_INT 2
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 1
84099: NEG
84100: PUSH
84101: LD_INT 1
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 2
84110: NEG
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 2
84121: NEG
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: LD_INT 1
84133: NEG
84134: PUSH
84135: LD_INT 3
84137: NEG
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 0
84145: PUSH
84146: LD_INT 3
84148: NEG
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 1
84156: PUSH
84157: LD_INT 2
84159: NEG
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 2
84167: PUSH
84168: LD_INT 1
84170: NEG
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 3
84178: PUSH
84179: LD_INT 0
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 3
84188: PUSH
84189: LD_INT 1
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 1
84198: PUSH
84199: LD_INT 3
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 0
84208: PUSH
84209: LD_INT 3
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 1
84218: NEG
84219: PUSH
84220: LD_INT 2
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 2
84229: NEG
84230: PUSH
84231: LD_INT 1
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: PUSH
84238: LD_INT 3
84240: NEG
84241: PUSH
84242: LD_INT 0
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: PUSH
84249: LD_INT 3
84251: NEG
84252: PUSH
84253: LD_INT 1
84255: NEG
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84292: LD_ADDR_VAR 0 44
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 0
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 1
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 1
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: NEG
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 1
84385: PUSH
84386: LD_INT 1
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 2
84396: PUSH
84397: LD_INT 0
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 1
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 2
84416: PUSH
84417: LD_INT 2
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: PUSH
84427: LD_INT 2
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: NEG
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: NEG
84448: PUSH
84449: LD_INT 0
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 2
84458: NEG
84459: PUSH
84460: LD_INT 1
84462: NEG
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 2
84470: NEG
84471: PUSH
84472: LD_INT 2
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 2
84482: NEG
84483: PUSH
84484: LD_INT 3
84486: NEG
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 2
84494: PUSH
84495: LD_INT 1
84497: NEG
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 3
84505: PUSH
84506: LD_INT 0
84508: PUSH
84509: EMPTY
84510: LIST
84511: LIST
84512: PUSH
84513: LD_INT 3
84515: PUSH
84516: LD_INT 1
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 3
84525: PUSH
84526: LD_INT 2
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 3
84535: PUSH
84536: LD_INT 3
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: LD_INT 2
84545: PUSH
84546: LD_INT 3
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 2
84555: NEG
84556: PUSH
84557: LD_INT 1
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_INT 3
84566: NEG
84567: PUSH
84568: LD_INT 0
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 3
84577: NEG
84578: PUSH
84579: LD_INT 1
84581: NEG
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 3
84589: NEG
84590: PUSH
84591: LD_INT 2
84593: NEG
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 3
84601: NEG
84602: PUSH
84603: LD_INT 3
84605: NEG
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: LIST
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84642: LD_ADDR_VAR 0 45
84646: PUSH
84647: LD_INT 0
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: LD_INT 1
84662: NEG
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 1
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: LD_INT 1
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: NEG
84701: PUSH
84702: LD_INT 0
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: NEG
84712: PUSH
84713: LD_INT 1
84715: NEG
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 1
84723: NEG
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 0
84735: PUSH
84736: LD_INT 2
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 1
84746: PUSH
84747: LD_INT 1
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 2
84757: PUSH
84758: LD_INT 1
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 2
84767: PUSH
84768: LD_INT 2
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: LD_INT 2
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 0
84787: PUSH
84788: LD_INT 2
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 1
84797: NEG
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 2
84808: NEG
84809: PUSH
84810: LD_INT 1
84812: NEG
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 2
84820: NEG
84821: PUSH
84822: LD_INT 2
84824: NEG
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: LD_INT 2
84832: NEG
84833: PUSH
84834: LD_INT 3
84836: NEG
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 1
84844: NEG
84845: PUSH
84846: LD_INT 3
84848: NEG
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 3
84859: NEG
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 1
84867: PUSH
84868: LD_INT 2
84870: NEG
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: PUSH
84876: LD_INT 3
84878: PUSH
84879: LD_INT 2
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 3
84888: PUSH
84889: LD_INT 3
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 2
84898: PUSH
84899: LD_INT 3
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 1
84908: PUSH
84909: LD_INT 3
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: LD_INT 3
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 2
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 3
84939: NEG
84940: PUSH
84941: LD_INT 2
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 3
84951: NEG
84952: PUSH
84953: LD_INT 3
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84992: LD_ADDR_VAR 0 46
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: LD_INT 0
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: PUSH
85031: LD_INT 1
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 0
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: LD_INT 0
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 1
85061: NEG
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 1
85073: NEG
85074: PUSH
85075: LD_INT 2
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 0
85085: PUSH
85086: LD_INT 2
85088: NEG
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: LD_INT 1
85099: NEG
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 2
85107: PUSH
85108: LD_INT 0
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: LD_INT 2
85117: PUSH
85118: LD_INT 1
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: LD_INT 2
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 0
85137: PUSH
85138: LD_INT 2
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: LD_INT 1
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: LD_INT 0
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 2
85169: NEG
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 1
85181: NEG
85182: PUSH
85183: LD_INT 3
85185: NEG
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 0
85193: PUSH
85194: LD_INT 3
85196: NEG
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 1
85204: PUSH
85205: LD_INT 2
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 2
85215: PUSH
85216: LD_INT 1
85218: NEG
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 3
85226: PUSH
85227: LD_INT 0
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: PUSH
85234: LD_INT 3
85236: PUSH
85237: LD_INT 1
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 1
85246: PUSH
85247: LD_INT 3
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 0
85256: PUSH
85257: LD_INT 3
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: NEG
85267: PUSH
85268: LD_INT 2
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 2
85277: NEG
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 3
85288: NEG
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 3
85299: NEG
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85340: LD_ADDR_VAR 0 47
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 0
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 1
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 0
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: NEG
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 2
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: LD_INT 1
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 2
85455: NEG
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 2
85467: NEG
85468: PUSH
85469: LD_INT 2
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85491: LD_ADDR_VAR 0 48
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 0
85508: PUSH
85509: LD_INT 1
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 1
85519: PUSH
85520: LD_INT 0
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: LD_INT 1
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: LD_INT 1
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 1
85549: NEG
85550: PUSH
85551: LD_INT 0
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 1
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 1
85572: NEG
85573: PUSH
85574: LD_INT 2
85576: NEG
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 0
85584: PUSH
85585: LD_INT 2
85587: NEG
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 1
85595: PUSH
85596: LD_INT 1
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 2
85606: PUSH
85607: LD_INT 0
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: LD_INT 2
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85638: LD_ADDR_VAR 0 49
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 0
85655: PUSH
85656: LD_INT 1
85658: NEG
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 1
85666: PUSH
85667: LD_INT 0
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: PUSH
85674: LD_INT 1
85676: PUSH
85677: LD_INT 1
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 0
85686: PUSH
85687: LD_INT 1
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 1
85696: NEG
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 1
85707: NEG
85708: PUSH
85709: LD_INT 1
85711: NEG
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 1
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 2
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 2
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 2
85750: PUSH
85751: LD_INT 2
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: PUSH
85761: LD_INT 2
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85782: LD_ADDR_VAR 0 50
85786: PUSH
85787: LD_INT 0
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 0
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: PUSH
85808: LD_INT 1
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 1
85820: PUSH
85821: LD_INT 1
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PUSH
85828: LD_INT 0
85830: PUSH
85831: LD_INT 1
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 1
85840: NEG
85841: PUSH
85842: LD_INT 0
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 1
85851: NEG
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 2
85863: PUSH
85864: LD_INT 1
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 2
85873: PUSH
85874: LD_INT 2
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 1
85883: PUSH
85884: LD_INT 2
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 0
85893: PUSH
85894: LD_INT 2
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 1
85903: NEG
85904: PUSH
85905: LD_INT 1
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
85926: LD_ADDR_VAR 0 51
85930: PUSH
85931: LD_INT 0
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: LD_INT 1
85946: NEG
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: LD_INT 1
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: LD_INT 0
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: LD_INT 1
85999: NEG
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 1
86007: PUSH
86008: LD_INT 2
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 0
86017: PUSH
86018: LD_INT 2
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 1
86027: NEG
86028: PUSH
86029: LD_INT 1
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: PUSH
86036: LD_INT 2
86038: NEG
86039: PUSH
86040: LD_INT 0
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: PUSH
86047: LD_INT 2
86049: NEG
86050: PUSH
86051: LD_INT 1
86053: NEG
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86073: LD_ADDR_VAR 0 52
86077: PUSH
86078: LD_INT 0
86080: PUSH
86081: LD_INT 0
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: LD_INT 1
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 1
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: LD_INT 1
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PUSH
86119: LD_INT 0
86121: PUSH
86122: LD_INT 1
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 1
86131: NEG
86132: PUSH
86133: LD_INT 0
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 1
86142: NEG
86143: PUSH
86144: LD_INT 1
86146: NEG
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: NEG
86155: PUSH
86156: LD_INT 2
86158: NEG
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 1
86166: NEG
86167: PUSH
86168: LD_INT 1
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 2
86177: NEG
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 2
86188: NEG
86189: PUSH
86190: LD_INT 1
86192: NEG
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 2
86200: NEG
86201: PUSH
86202: LD_INT 2
86204: NEG
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86224: LD_ADDR_VAR 0 53
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: PUSH
86253: LD_INT 0
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: PUSH
86263: LD_INT 1
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 0
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: NEG
86283: PUSH
86284: LD_INT 0
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 1
86305: NEG
86306: PUSH
86307: LD_INT 2
86309: NEG
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 0
86317: PUSH
86318: LD_INT 2
86320: NEG
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: LD_INT 1
86331: NEG
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 0
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 2
86359: PUSH
86360: LD_INT 2
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: PUSH
86370: LD_INT 2
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 0
86379: PUSH
86380: LD_INT 2
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: NEG
86390: PUSH
86391: LD_INT 1
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 2
86400: NEG
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 1
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: LD_INT 2
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86454: LD_ADDR_VAR 0 54
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 0
86471: PUSH
86472: LD_INT 1
86474: NEG
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: LD_INT 0
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: LD_INT 1
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: LD_INT 1
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: LD_INT 0
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 1
86523: NEG
86524: PUSH
86525: LD_INT 1
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: LD_INT 2
86539: NEG
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 0
86547: PUSH
86548: LD_INT 2
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 1
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 2
86569: PUSH
86570: LD_INT 0
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 2
86579: PUSH
86580: LD_INT 1
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 2
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: LD_INT 2
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: LD_INT 2
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 1
86619: NEG
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 2
86630: NEG
86631: PUSH
86632: LD_INT 0
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: LD_INT 1
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: LD_INT 2
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86684: LD_ADDR_VAR 0 55
86688: PUSH
86689: LD_INT 0
86691: PUSH
86692: LD_INT 0
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: LD_INT 1
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 1
86712: PUSH
86713: LD_INT 0
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: PUSH
86723: LD_INT 1
86725: PUSH
86726: EMPTY
86727: LIST
86728: LIST
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: LD_INT 1
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: NEG
86743: PUSH
86744: LD_INT 0
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: LD_INT 1
86757: NEG
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 0
86777: PUSH
86778: LD_INT 2
86780: NEG
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 1
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 2
86799: PUSH
86800: LD_INT 0
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 2
86809: PUSH
86810: LD_INT 1
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: LD_INT 2
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 0
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: NEG
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: NEG
86861: PUSH
86862: LD_INT 0
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 2
86871: NEG
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 2
86883: NEG
86884: PUSH
86885: LD_INT 2
86887: NEG
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86914: LD_ADDR_VAR 0 56
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: LD_INT 0
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 0
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 1
86942: PUSH
86943: LD_INT 0
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 0
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: NEG
86973: PUSH
86974: LD_INT 0
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: LD_INT 2
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 0
87007: PUSH
87008: LD_INT 2
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 1
87018: PUSH
87019: LD_INT 1
87021: NEG
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 2
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 2
87039: PUSH
87040: LD_INT 1
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 2
87049: PUSH
87050: LD_INT 2
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: LD_INT 2
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: LD_INT 2
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: LD_INT 1
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 2
87090: NEG
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 2
87101: NEG
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 2
87113: NEG
87114: PUSH
87115: LD_INT 2
87117: NEG
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87144: LD_ADDR_VAR 0 57
87148: PUSH
87149: LD_INT 0
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: LD_INT 0
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 1
87182: PUSH
87183: LD_INT 1
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: LD_INT 1
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: LD_INT 0
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 1
87213: NEG
87214: PUSH
87215: LD_INT 1
87217: NEG
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 1
87225: NEG
87226: PUSH
87227: LD_INT 2
87229: NEG
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 0
87237: PUSH
87238: LD_INT 2
87240: NEG
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 1
87248: PUSH
87249: LD_INT 1
87251: NEG
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 2
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 2
87269: PUSH
87270: LD_INT 1
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 2
87279: PUSH
87280: LD_INT 2
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 1
87289: PUSH
87290: LD_INT 2
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: PUSH
87297: LD_INT 0
87299: PUSH
87300: LD_INT 2
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 1
87309: NEG
87310: PUSH
87311: LD_INT 1
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 2
87320: NEG
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 2
87331: NEG
87332: PUSH
87333: LD_INT 1
87335: NEG
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: PUSH
87341: LD_INT 2
87343: NEG
87344: PUSH
87345: LD_INT 2
87347: NEG
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87374: LD_ADDR_VAR 0 58
87378: PUSH
87379: LD_INT 0
87381: PUSH
87382: LD_INT 0
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 0
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 1
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 1
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: LD_INT 1
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: NEG
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: LD_INT 1
87447: NEG
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: LD_INT 2
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: LD_INT 2
87470: NEG
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 1
87478: PUSH
87479: LD_INT 1
87481: NEG
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 2
87489: PUSH
87490: LD_INT 0
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 2
87499: PUSH
87500: LD_INT 1
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 2
87509: PUSH
87510: LD_INT 2
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 1
87519: PUSH
87520: LD_INT 2
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: LD_INT 0
87529: PUSH
87530: LD_INT 2
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: LD_INT 1
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 2
87550: NEG
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 2
87561: NEG
87562: PUSH
87563: LD_INT 1
87565: NEG
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 2
87573: NEG
87574: PUSH
87575: LD_INT 2
87577: NEG
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87604: LD_ADDR_VAR 0 59
87608: PUSH
87609: LD_INT 0
87611: PUSH
87612: LD_INT 0
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 0
87652: PUSH
87653: LD_INT 1
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 1
87662: NEG
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 1
87673: NEG
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87692: LD_ADDR_VAR 0 60
87696: PUSH
87697: LD_INT 0
87699: PUSH
87700: LD_INT 0
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 0
87709: PUSH
87710: LD_INT 1
87712: NEG
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: LD_INT 1
87720: PUSH
87721: LD_INT 0
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 1
87730: PUSH
87731: LD_INT 1
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 0
87740: PUSH
87741: LD_INT 1
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 1
87750: NEG
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87780: LD_ADDR_VAR 0 61
87784: PUSH
87785: LD_INT 0
87787: PUSH
87788: LD_INT 0
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: LD_INT 1
87800: NEG
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: PUSH
87806: LD_INT 1
87808: PUSH
87809: LD_INT 0
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: PUSH
87816: LD_INT 1
87818: PUSH
87819: LD_INT 1
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: LD_INT 1
87831: PUSH
87832: EMPTY
87833: LIST
87834: LIST
87835: PUSH
87836: LD_INT 1
87838: NEG
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: EMPTY
87844: LIST
87845: LIST
87846: PUSH
87847: LD_INT 1
87849: NEG
87850: PUSH
87851: LD_INT 1
87853: NEG
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87868: LD_ADDR_VAR 0 62
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 0
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PUSH
87904: LD_INT 1
87906: PUSH
87907: LD_INT 1
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 0
87916: PUSH
87917: LD_INT 1
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 1
87926: NEG
87927: PUSH
87928: LD_INT 0
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: NEG
87938: PUSH
87939: LD_INT 1
87941: NEG
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87956: LD_ADDR_VAR 0 63
87960: PUSH
87961: LD_INT 0
87963: PUSH
87964: LD_INT 0
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 0
87973: PUSH
87974: LD_INT 1
87976: NEG
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: LD_INT 0
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_INT 1
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 1
88025: NEG
88026: PUSH
88027: LD_INT 1
88029: NEG
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88044: LD_ADDR_VAR 0 64
88048: PUSH
88049: LD_INT 0
88051: PUSH
88052: LD_INT 0
88054: PUSH
88055: EMPTY
88056: LIST
88057: LIST
88058: PUSH
88059: LD_INT 0
88061: PUSH
88062: LD_INT 1
88064: NEG
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 1
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 1
88082: PUSH
88083: LD_INT 1
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 0
88092: PUSH
88093: LD_INT 1
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 1
88102: NEG
88103: PUSH
88104: LD_INT 0
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 1
88113: NEG
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: ST_TO_ADDR
// end ; 1 :
88132: GO 94029
88134: LD_INT 1
88136: DOUBLE
88137: EQUAL
88138: IFTRUE 88142
88140: GO 90765
88142: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88143: LD_ADDR_VAR 0 11
88147: PUSH
88148: LD_INT 1
88150: NEG
88151: PUSH
88152: LD_INT 3
88154: NEG
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 0
88162: PUSH
88163: LD_INT 3
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: LD_INT 2
88176: NEG
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: LIST
88186: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88187: LD_ADDR_VAR 0 12
88191: PUSH
88192: LD_INT 2
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 3
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 3
88215: PUSH
88216: LD_INT 1
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: LIST
88227: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88228: LD_ADDR_VAR 0 13
88232: PUSH
88233: LD_INT 3
88235: PUSH
88236: LD_INT 2
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 3
88245: PUSH
88246: LD_INT 3
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 2
88255: PUSH
88256: LD_INT 3
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: LIST
88267: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88268: LD_ADDR_VAR 0 14
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: LD_INT 3
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: LD_INT 0
88285: PUSH
88286: LD_INT 3
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PUSH
88293: LD_INT 1
88295: NEG
88296: PUSH
88297: LD_INT 2
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88309: LD_ADDR_VAR 0 15
88313: PUSH
88314: LD_INT 2
88316: NEG
88317: PUSH
88318: LD_INT 1
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: LD_INT 3
88327: NEG
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 3
88338: NEG
88339: PUSH
88340: LD_INT 1
88342: NEG
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: LIST
88352: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88353: LD_ADDR_VAR 0 16
88357: PUSH
88358: LD_INT 2
88360: NEG
88361: PUSH
88362: LD_INT 3
88364: NEG
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 3
88372: NEG
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 3
88384: NEG
88385: PUSH
88386: LD_INT 3
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88399: LD_ADDR_VAR 0 17
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: LD_INT 3
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: LD_INT 3
88421: NEG
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 1
88429: PUSH
88430: LD_INT 2
88432: NEG
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: LIST
88442: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88443: LD_ADDR_VAR 0 18
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: LD_INT 1
88453: NEG
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 3
88461: PUSH
88462: LD_INT 0
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 3
88471: PUSH
88472: LD_INT 1
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: LIST
88483: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88484: LD_ADDR_VAR 0 19
88488: PUSH
88489: LD_INT 3
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 3
88501: PUSH
88502: LD_INT 3
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 2
88511: PUSH
88512: LD_INT 3
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: LIST
88523: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88524: LD_ADDR_VAR 0 20
88528: PUSH
88529: LD_INT 1
88531: PUSH
88532: LD_INT 3
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: LD_INT 3
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 1
88551: NEG
88552: PUSH
88553: LD_INT 2
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: LIST
88564: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88565: LD_ADDR_VAR 0 21
88569: PUSH
88570: LD_INT 2
88572: NEG
88573: PUSH
88574: LD_INT 1
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 3
88583: NEG
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 3
88594: NEG
88595: PUSH
88596: LD_INT 1
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: LIST
88608: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88609: LD_ADDR_VAR 0 22
88613: PUSH
88614: LD_INT 2
88616: NEG
88617: PUSH
88618: LD_INT 3
88620: NEG
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 3
88628: NEG
88629: PUSH
88630: LD_INT 2
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 3
88640: NEG
88641: PUSH
88642: LD_INT 3
88644: NEG
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: LIST
88654: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
88655: LD_ADDR_VAR 0 23
88659: PUSH
88660: LD_INT 0
88662: PUSH
88663: LD_INT 3
88665: NEG
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 1
88673: NEG
88674: PUSH
88675: LD_INT 4
88677: NEG
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PUSH
88683: LD_INT 1
88685: PUSH
88686: LD_INT 3
88688: NEG
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: LIST
88698: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
88699: LD_ADDR_VAR 0 24
88703: PUSH
88704: LD_INT 3
88706: PUSH
88707: LD_INT 0
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 3
88716: PUSH
88717: LD_INT 1
88719: NEG
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 4
88727: PUSH
88728: LD_INT 1
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: LIST
88739: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
88740: LD_ADDR_VAR 0 25
88744: PUSH
88745: LD_INT 3
88747: PUSH
88748: LD_INT 3
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 4
88757: PUSH
88758: LD_INT 3
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 3
88767: PUSH
88768: LD_INT 4
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: LIST
88779: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
88780: LD_ADDR_VAR 0 26
88784: PUSH
88785: LD_INT 0
88787: PUSH
88788: LD_INT 3
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 1
88797: PUSH
88798: LD_INT 4
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 1
88807: NEG
88808: PUSH
88809: LD_INT 3
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: LIST
88820: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
88821: LD_ADDR_VAR 0 27
88825: PUSH
88826: LD_INT 3
88828: NEG
88829: PUSH
88830: LD_INT 0
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 3
88839: NEG
88840: PUSH
88841: LD_INT 1
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 4
88850: NEG
88851: PUSH
88852: LD_INT 1
88854: NEG
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: LIST
88864: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
88865: LD_ADDR_VAR 0 28
88869: PUSH
88870: LD_INT 3
88872: NEG
88873: PUSH
88874: LD_INT 3
88876: NEG
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 3
88884: NEG
88885: PUSH
88886: LD_INT 4
88888: NEG
88889: PUSH
88890: EMPTY
88891: LIST
88892: LIST
88893: PUSH
88894: LD_INT 4
88896: NEG
88897: PUSH
88898: LD_INT 3
88900: NEG
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: LIST
88910: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
88911: LD_ADDR_VAR 0 29
88915: PUSH
88916: LD_INT 1
88918: NEG
88919: PUSH
88920: LD_INT 3
88922: NEG
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 0
88930: PUSH
88931: LD_INT 3
88933: NEG
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 1
88941: PUSH
88942: LD_INT 2
88944: NEG
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 1
88952: NEG
88953: PUSH
88954: LD_INT 4
88956: NEG
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: LD_INT 4
88967: NEG
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 1
88975: PUSH
88976: LD_INT 3
88978: NEG
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 1
88986: NEG
88987: PUSH
88988: LD_INT 5
88990: NEG
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: LD_INT 5
89001: NEG
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: LD_INT 4
89012: NEG
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: NEG
89021: PUSH
89022: LD_INT 6
89024: NEG
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: LD_INT 6
89035: NEG
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 1
89043: PUSH
89044: LD_INT 5
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
89066: LD_ADDR_VAR 0 30
89070: PUSH
89071: LD_INT 2
89073: PUSH
89074: LD_INT 1
89076: NEG
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 3
89084: PUSH
89085: LD_INT 0
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 3
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 3
89104: PUSH
89105: LD_INT 1
89107: NEG
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 4
89115: PUSH
89116: LD_INT 0
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 4
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 4
89135: PUSH
89136: LD_INT 1
89138: NEG
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 5
89146: PUSH
89147: LD_INT 0
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 5
89156: PUSH
89157: LD_INT 1
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 5
89166: PUSH
89167: LD_INT 1
89169: NEG
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 6
89177: PUSH
89178: LD_INT 0
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: PUSH
89185: LD_INT 6
89187: PUSH
89188: LD_INT 1
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
89209: LD_ADDR_VAR 0 31
89213: PUSH
89214: LD_INT 3
89216: PUSH
89217: LD_INT 2
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 3
89226: PUSH
89227: LD_INT 3
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 2
89236: PUSH
89237: LD_INT 3
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 4
89246: PUSH
89247: LD_INT 3
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 4
89256: PUSH
89257: LD_INT 4
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 3
89266: PUSH
89267: LD_INT 4
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 5
89276: PUSH
89277: LD_INT 4
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 5
89286: PUSH
89287: LD_INT 5
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 4
89296: PUSH
89297: LD_INT 5
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 6
89306: PUSH
89307: LD_INT 5
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 6
89316: PUSH
89317: LD_INT 6
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 5
89326: PUSH
89327: LD_INT 6
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
89348: LD_ADDR_VAR 0 32
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: LD_INT 3
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 0
89365: PUSH
89366: LD_INT 3
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 1
89375: NEG
89376: PUSH
89377: LD_INT 2
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 1
89386: PUSH
89387: LD_INT 4
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 0
89396: PUSH
89397: LD_INT 4
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PUSH
89404: LD_INT 1
89406: NEG
89407: PUSH
89408: LD_INT 3
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 1
89417: PUSH
89418: LD_INT 5
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: LD_INT 5
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 1
89437: NEG
89438: PUSH
89439: LD_INT 4
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 1
89448: PUSH
89449: LD_INT 6
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 0
89458: PUSH
89459: LD_INT 6
89461: PUSH
89462: EMPTY
89463: LIST
89464: LIST
89465: PUSH
89466: LD_INT 1
89468: NEG
89469: PUSH
89470: LD_INT 5
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
89491: LD_ADDR_VAR 0 33
89495: PUSH
89496: LD_INT 2
89498: NEG
89499: PUSH
89500: LD_INT 1
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 3
89509: NEG
89510: PUSH
89511: LD_INT 0
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 3
89520: NEG
89521: PUSH
89522: LD_INT 1
89524: NEG
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 3
89532: NEG
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 4
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 4
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 4
89566: NEG
89567: PUSH
89568: LD_INT 1
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 5
89577: NEG
89578: PUSH
89579: LD_INT 0
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 5
89588: NEG
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 5
89600: NEG
89601: PUSH
89602: LD_INT 1
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 6
89611: NEG
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 6
89622: NEG
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
89646: LD_ADDR_VAR 0 34
89650: PUSH
89651: LD_INT 2
89653: NEG
89654: PUSH
89655: LD_INT 3
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 3
89665: NEG
89666: PUSH
89667: LD_INT 2
89669: NEG
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 3
89677: NEG
89678: PUSH
89679: LD_INT 3
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 3
89689: NEG
89690: PUSH
89691: LD_INT 4
89693: NEG
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 4
89701: NEG
89702: PUSH
89703: LD_INT 3
89705: NEG
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 4
89713: NEG
89714: PUSH
89715: LD_INT 4
89717: NEG
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 4
89725: NEG
89726: PUSH
89727: LD_INT 5
89729: NEG
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 5
89737: NEG
89738: PUSH
89739: LD_INT 4
89741: NEG
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 5
89749: NEG
89750: PUSH
89751: LD_INT 5
89753: NEG
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 5
89761: NEG
89762: PUSH
89763: LD_INT 6
89765: NEG
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 6
89773: NEG
89774: PUSH
89775: LD_INT 5
89777: NEG
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 6
89785: NEG
89786: PUSH
89787: LD_INT 6
89789: NEG
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
89809: LD_ADDR_VAR 0 41
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: LD_INT 2
89819: NEG
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 1
89827: NEG
89828: PUSH
89829: LD_INT 3
89831: NEG
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: PUSH
89840: LD_INT 2
89842: NEG
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: LIST
89852: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
89853: LD_ADDR_VAR 0 42
89857: PUSH
89858: LD_INT 2
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 2
89870: PUSH
89871: LD_INT 1
89873: NEG
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 3
89881: PUSH
89882: LD_INT 1
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: LIST
89893: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
89894: LD_ADDR_VAR 0 43
89898: PUSH
89899: LD_INT 2
89901: PUSH
89902: LD_INT 2
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 3
89911: PUSH
89912: LD_INT 2
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 2
89921: PUSH
89922: LD_INT 3
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: LIST
89933: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
89934: LD_ADDR_VAR 0 44
89938: PUSH
89939: LD_INT 0
89941: PUSH
89942: LD_INT 2
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 1
89951: PUSH
89952: LD_INT 3
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 1
89961: NEG
89962: PUSH
89963: LD_INT 2
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: LIST
89974: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89975: LD_ADDR_VAR 0 45
89979: PUSH
89980: LD_INT 2
89982: NEG
89983: PUSH
89984: LD_INT 0
89986: PUSH
89987: EMPTY
89988: LIST
89989: LIST
89990: PUSH
89991: LD_INT 2
89993: NEG
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 3
90004: NEG
90005: PUSH
90006: LD_INT 1
90008: NEG
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: LIST
90018: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90019: LD_ADDR_VAR 0 46
90023: PUSH
90024: LD_INT 2
90026: NEG
90027: PUSH
90028: LD_INT 2
90030: NEG
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 2
90038: NEG
90039: PUSH
90040: LD_INT 3
90042: NEG
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 3
90050: NEG
90051: PUSH
90052: LD_INT 2
90054: NEG
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: LIST
90064: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
90065: LD_ADDR_VAR 0 47
90069: PUSH
90070: LD_INT 2
90072: NEG
90073: PUSH
90074: LD_INT 3
90076: NEG
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 1
90084: NEG
90085: PUSH
90086: LD_INT 3
90088: NEG
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
90098: LD_ADDR_VAR 0 48
90102: PUSH
90103: LD_INT 1
90105: PUSH
90106: LD_INT 2
90108: NEG
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 2
90116: PUSH
90117: LD_INT 1
90119: NEG
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
90129: LD_ADDR_VAR 0 49
90133: PUSH
90134: LD_INT 3
90136: PUSH
90137: LD_INT 1
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 3
90146: PUSH
90147: LD_INT 2
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
90158: LD_ADDR_VAR 0 50
90162: PUSH
90163: LD_INT 2
90165: PUSH
90166: LD_INT 3
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 1
90175: PUSH
90176: LD_INT 3
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
90187: LD_ADDR_VAR 0 51
90191: PUSH
90192: LD_INT 1
90194: NEG
90195: PUSH
90196: LD_INT 2
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: LD_INT 2
90205: NEG
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
90218: LD_ADDR_VAR 0 52
90222: PUSH
90223: LD_INT 3
90225: NEG
90226: PUSH
90227: LD_INT 1
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 3
90237: NEG
90238: PUSH
90239: LD_INT 2
90241: NEG
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90251: LD_ADDR_VAR 0 53
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: LD_INT 3
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 0
90270: PUSH
90271: LD_INT 3
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 1
90281: PUSH
90282: LD_INT 2
90284: NEG
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: LIST
90294: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90295: LD_ADDR_VAR 0 54
90299: PUSH
90300: LD_INT 2
90302: PUSH
90303: LD_INT 1
90305: NEG
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 3
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 3
90323: PUSH
90324: LD_INT 1
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: LIST
90335: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90336: LD_ADDR_VAR 0 55
90340: PUSH
90341: LD_INT 3
90343: PUSH
90344: LD_INT 2
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 3
90353: PUSH
90354: LD_INT 3
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 2
90363: PUSH
90364: LD_INT 3
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: LIST
90375: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90376: LD_ADDR_VAR 0 56
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: LD_INT 3
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: LD_INT 3
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: LD_INT 1
90403: NEG
90404: PUSH
90405: LD_INT 2
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90417: LD_ADDR_VAR 0 57
90421: PUSH
90422: LD_INT 2
90424: NEG
90425: PUSH
90426: LD_INT 1
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 3
90435: NEG
90436: PUSH
90437: LD_INT 0
90439: PUSH
90440: EMPTY
90441: LIST
90442: LIST
90443: PUSH
90444: LD_INT 3
90446: NEG
90447: PUSH
90448: LD_INT 1
90450: NEG
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: LIST
90460: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90461: LD_ADDR_VAR 0 58
90465: PUSH
90466: LD_INT 2
90468: NEG
90469: PUSH
90470: LD_INT 3
90472: NEG
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 3
90480: NEG
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 3
90492: NEG
90493: PUSH
90494: LD_INT 3
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: LIST
90506: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
90507: LD_ADDR_VAR 0 59
90511: PUSH
90512: LD_INT 1
90514: NEG
90515: PUSH
90516: LD_INT 2
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 0
90526: PUSH
90527: LD_INT 2
90529: NEG
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: LD_INT 1
90540: NEG
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: LIST
90550: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90551: LD_ADDR_VAR 0 60
90555: PUSH
90556: LD_INT 1
90558: PUSH
90559: LD_INT 1
90561: NEG
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 2
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 2
90579: PUSH
90580: LD_INT 1
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: LIST
90591: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90592: LD_ADDR_VAR 0 61
90596: PUSH
90597: LD_INT 2
90599: PUSH
90600: LD_INT 1
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 2
90609: PUSH
90610: LD_INT 2
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 1
90619: PUSH
90620: LD_INT 2
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: LIST
90631: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90632: LD_ADDR_VAR 0 62
90636: PUSH
90637: LD_INT 1
90639: PUSH
90640: LD_INT 2
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 0
90649: PUSH
90650: LD_INT 2
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 1
90659: NEG
90660: PUSH
90661: LD_INT 1
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: LIST
90672: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90673: LD_ADDR_VAR 0 63
90677: PUSH
90678: LD_INT 1
90680: NEG
90681: PUSH
90682: LD_INT 1
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 2
90691: NEG
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 2
90702: NEG
90703: PUSH
90704: LD_INT 1
90706: NEG
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: LIST
90716: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90717: LD_ADDR_VAR 0 64
90721: PUSH
90722: LD_INT 1
90724: NEG
90725: PUSH
90726: LD_INT 2
90728: NEG
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 2
90736: NEG
90737: PUSH
90738: LD_INT 1
90740: NEG
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 2
90748: NEG
90749: PUSH
90750: LD_INT 2
90752: NEG
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: LIST
90762: ST_TO_ADDR
// end ; 2 :
90763: GO 94029
90765: LD_INT 2
90767: DOUBLE
90768: EQUAL
90769: IFTRUE 90773
90771: GO 94028
90773: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
90774: LD_ADDR_VAR 0 29
90778: PUSH
90779: LD_INT 4
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 4
90791: PUSH
90792: LD_INT 1
90794: NEG
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 5
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: LD_INT 5
90812: PUSH
90813: LD_INT 1
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 4
90822: PUSH
90823: LD_INT 1
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 3
90832: PUSH
90833: LD_INT 0
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 3
90842: PUSH
90843: LD_INT 1
90845: NEG
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 3
90853: PUSH
90854: LD_INT 2
90856: NEG
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: PUSH
90862: LD_INT 5
90864: PUSH
90865: LD_INT 2
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 3
90874: PUSH
90875: LD_INT 3
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 3
90884: PUSH
90885: LD_INT 2
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 4
90894: PUSH
90895: LD_INT 3
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 4
90904: PUSH
90905: LD_INT 4
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 3
90914: PUSH
90915: LD_INT 4
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 2
90924: PUSH
90925: LD_INT 3
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 2
90934: PUSH
90935: LD_INT 2
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 4
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 2
90954: PUSH
90955: LD_INT 4
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 4
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: LD_INT 3
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: PUSH
90982: LD_INT 1
90984: PUSH
90985: LD_INT 4
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 1
90994: PUSH
90995: LD_INT 5
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 0
91004: PUSH
91005: LD_INT 5
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 1
91014: NEG
91015: PUSH
91016: LD_INT 4
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 1
91025: NEG
91026: PUSH
91027: LD_INT 3
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 2
91036: PUSH
91037: LD_INT 5
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: LD_INT 2
91046: NEG
91047: PUSH
91048: LD_INT 3
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 3
91057: NEG
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 3
91068: NEG
91069: PUSH
91070: LD_INT 1
91072: NEG
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 2
91080: NEG
91081: PUSH
91082: LD_INT 0
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 2
91091: NEG
91092: PUSH
91093: LD_INT 1
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 3
91102: NEG
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 4
91113: NEG
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 4
91124: NEG
91125: PUSH
91126: LD_INT 1
91128: NEG
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 4
91136: NEG
91137: PUSH
91138: LD_INT 2
91140: NEG
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PUSH
91146: LD_INT 2
91148: NEG
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 4
91159: NEG
91160: PUSH
91161: LD_INT 4
91163: NEG
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 4
91171: NEG
91172: PUSH
91173: LD_INT 5
91175: NEG
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 3
91183: NEG
91184: PUSH
91185: LD_INT 4
91187: NEG
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 3
91195: NEG
91196: PUSH
91197: LD_INT 3
91199: NEG
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 4
91207: NEG
91208: PUSH
91209: LD_INT 3
91211: NEG
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 5
91219: NEG
91220: PUSH
91221: LD_INT 4
91223: NEG
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 5
91231: NEG
91232: PUSH
91233: LD_INT 5
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 3
91243: NEG
91244: PUSH
91245: LD_INT 5
91247: NEG
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: LD_INT 5
91255: NEG
91256: PUSH
91257: LD_INT 3
91259: NEG
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
91312: LD_ADDR_VAR 0 30
91316: PUSH
91317: LD_INT 4
91319: PUSH
91320: LD_INT 4
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 4
91329: PUSH
91330: LD_INT 3
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 5
91339: PUSH
91340: LD_INT 4
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 5
91349: PUSH
91350: LD_INT 5
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 4
91359: PUSH
91360: LD_INT 5
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 3
91369: PUSH
91370: LD_INT 4
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 3
91379: PUSH
91380: LD_INT 3
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 5
91389: PUSH
91390: LD_INT 3
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: LD_INT 5
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 0
91409: PUSH
91410: LD_INT 3
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 0
91419: PUSH
91420: LD_INT 2
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: LD_INT 3
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 1
91439: PUSH
91440: LD_INT 4
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 0
91449: PUSH
91450: LD_INT 4
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 1
91459: NEG
91460: PUSH
91461: LD_INT 3
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: LD_INT 2
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 2
91481: PUSH
91482: LD_INT 4
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 2
91491: NEG
91492: PUSH
91493: LD_INT 2
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 4
91502: NEG
91503: PUSH
91504: LD_INT 0
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 4
91513: NEG
91514: PUSH
91515: LD_INT 1
91517: NEG
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 3
91525: NEG
91526: PUSH
91527: LD_INT 0
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 3
91536: NEG
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: LD_INT 4
91547: NEG
91548: PUSH
91549: LD_INT 1
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: PUSH
91556: LD_INT 5
91558: NEG
91559: PUSH
91560: LD_INT 0
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 5
91569: NEG
91570: PUSH
91571: LD_INT 1
91573: NEG
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 5
91581: NEG
91582: PUSH
91583: LD_INT 2
91585: NEG
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 3
91593: NEG
91594: PUSH
91595: LD_INT 2
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 3
91604: NEG
91605: PUSH
91606: LD_INT 3
91608: NEG
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 3
91616: NEG
91617: PUSH
91618: LD_INT 4
91620: NEG
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 2
91628: NEG
91629: PUSH
91630: LD_INT 3
91632: NEG
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: PUSH
91638: LD_INT 2
91640: NEG
91641: PUSH
91642: LD_INT 2
91644: NEG
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 3
91652: NEG
91653: PUSH
91654: LD_INT 2
91656: NEG
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 4
91664: NEG
91665: PUSH
91666: LD_INT 3
91668: NEG
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 4
91676: NEG
91677: PUSH
91678: LD_INT 4
91680: NEG
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 2
91688: NEG
91689: PUSH
91690: LD_INT 4
91692: NEG
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: LD_INT 4
91700: NEG
91701: PUSH
91702: LD_INT 2
91704: NEG
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 0
91712: PUSH
91713: LD_INT 4
91715: NEG
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: LD_INT 0
91723: PUSH
91724: LD_INT 5
91726: NEG
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 1
91734: PUSH
91735: LD_INT 4
91737: NEG
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 1
91745: PUSH
91746: LD_INT 3
91748: NEG
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 0
91756: PUSH
91757: LD_INT 3
91759: NEG
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: LD_INT 4
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: LD_INT 5
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 2
91791: PUSH
91792: LD_INT 3
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 2
91802: NEG
91803: PUSH
91804: LD_INT 5
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
91859: LD_ADDR_VAR 0 31
91863: PUSH
91864: LD_INT 0
91866: PUSH
91867: LD_INT 4
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: PUSH
91874: LD_INT 0
91876: PUSH
91877: LD_INT 3
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 1
91886: PUSH
91887: LD_INT 4
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: LD_INT 1
91896: PUSH
91897: LD_INT 5
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 0
91906: PUSH
91907: LD_INT 5
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 1
91916: NEG
91917: PUSH
91918: LD_INT 4
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 1
91927: NEG
91928: PUSH
91929: LD_INT 3
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 2
91938: PUSH
91939: LD_INT 5
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 2
91948: NEG
91949: PUSH
91950: LD_INT 3
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: PUSH
91957: LD_INT 3
91959: NEG
91960: PUSH
91961: LD_INT 0
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: PUSH
91968: LD_INT 3
91970: NEG
91971: PUSH
91972: LD_INT 1
91974: NEG
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 2
91982: NEG
91983: PUSH
91984: LD_INT 0
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 2
91993: NEG
91994: PUSH
91995: LD_INT 1
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 3
92004: NEG
92005: PUSH
92006: LD_INT 1
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 4
92015: NEG
92016: PUSH
92017: LD_INT 0
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 4
92026: NEG
92027: PUSH
92028: LD_INT 1
92030: NEG
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 4
92038: NEG
92039: PUSH
92040: LD_INT 2
92042: NEG
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 2
92050: NEG
92051: PUSH
92052: LD_INT 2
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 4
92061: NEG
92062: PUSH
92063: LD_INT 4
92065: NEG
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: PUSH
92071: LD_INT 4
92073: NEG
92074: PUSH
92075: LD_INT 5
92077: NEG
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: PUSH
92083: LD_INT 3
92085: NEG
92086: PUSH
92087: LD_INT 4
92089: NEG
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 3
92097: NEG
92098: PUSH
92099: LD_INT 3
92101: NEG
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 4
92109: NEG
92110: PUSH
92111: LD_INT 3
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 5
92121: NEG
92122: PUSH
92123: LD_INT 4
92125: NEG
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: LD_INT 5
92133: NEG
92134: PUSH
92135: LD_INT 5
92137: NEG
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: PUSH
92143: LD_INT 3
92145: NEG
92146: PUSH
92147: LD_INT 5
92149: NEG
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: PUSH
92155: LD_INT 5
92157: NEG
92158: PUSH
92159: LD_INT 3
92161: NEG
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 0
92169: PUSH
92170: LD_INT 3
92172: NEG
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: LD_INT 0
92180: PUSH
92181: LD_INT 4
92183: NEG
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: LD_INT 1
92191: PUSH
92192: LD_INT 3
92194: NEG
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: LD_INT 1
92202: PUSH
92203: LD_INT 2
92205: NEG
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: LD_INT 2
92216: NEG
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: LD_INT 3
92228: NEG
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 1
92236: NEG
92237: PUSH
92238: LD_INT 4
92240: NEG
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 2
92248: PUSH
92249: LD_INT 2
92251: NEG
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 2
92259: NEG
92260: PUSH
92261: LD_INT 4
92263: NEG
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 4
92271: PUSH
92272: LD_INT 0
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 4
92281: PUSH
92282: LD_INT 1
92284: NEG
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: LD_INT 5
92292: PUSH
92293: LD_INT 0
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 5
92302: PUSH
92303: LD_INT 1
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 4
92312: PUSH
92313: LD_INT 1
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 3
92322: PUSH
92323: LD_INT 0
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 3
92332: PUSH
92333: LD_INT 1
92335: NEG
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 3
92343: PUSH
92344: LD_INT 2
92346: NEG
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 5
92354: PUSH
92355: LD_INT 2
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92409: LD_ADDR_VAR 0 32
92413: PUSH
92414: LD_INT 4
92416: NEG
92417: PUSH
92418: LD_INT 0
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 4
92427: NEG
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 3
92439: NEG
92440: PUSH
92441: LD_INT 0
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 3
92450: NEG
92451: PUSH
92452: LD_INT 1
92454: PUSH
92455: EMPTY
92456: LIST
92457: LIST
92458: PUSH
92459: LD_INT 4
92461: NEG
92462: PUSH
92463: LD_INT 1
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 5
92472: NEG
92473: PUSH
92474: LD_INT 0
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 5
92483: NEG
92484: PUSH
92485: LD_INT 1
92487: NEG
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 5
92495: NEG
92496: PUSH
92497: LD_INT 2
92499: NEG
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 3
92507: NEG
92508: PUSH
92509: LD_INT 2
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 3
92518: NEG
92519: PUSH
92520: LD_INT 3
92522: NEG
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 3
92530: NEG
92531: PUSH
92532: LD_INT 4
92534: NEG
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 2
92542: NEG
92543: PUSH
92544: LD_INT 3
92546: NEG
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 2
92554: NEG
92555: PUSH
92556: LD_INT 2
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 3
92566: NEG
92567: PUSH
92568: LD_INT 2
92570: NEG
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 4
92578: NEG
92579: PUSH
92580: LD_INT 3
92582: NEG
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 4
92590: NEG
92591: PUSH
92592: LD_INT 4
92594: NEG
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 2
92602: NEG
92603: PUSH
92604: LD_INT 4
92606: NEG
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 4
92614: NEG
92615: PUSH
92616: LD_INT 2
92618: NEG
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: LD_INT 0
92626: PUSH
92627: LD_INT 4
92629: NEG
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 0
92637: PUSH
92638: LD_INT 5
92640: NEG
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 1
92648: PUSH
92649: LD_INT 4
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 1
92659: PUSH
92660: LD_INT 3
92662: NEG
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 0
92670: PUSH
92671: LD_INT 3
92673: NEG
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: PUSH
92679: LD_INT 1
92681: NEG
92682: PUSH
92683: LD_INT 4
92685: NEG
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: LD_INT 5
92697: NEG
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: LD_INT 3
92708: NEG
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 2
92716: NEG
92717: PUSH
92718: LD_INT 5
92720: NEG
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 3
92728: PUSH
92729: LD_INT 0
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 3
92738: PUSH
92739: LD_INT 1
92741: NEG
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: LD_INT 4
92749: PUSH
92750: LD_INT 0
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 4
92759: PUSH
92760: LD_INT 1
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: PUSH
92767: LD_INT 3
92769: PUSH
92770: LD_INT 1
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 2
92779: PUSH
92780: LD_INT 0
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 2
92789: PUSH
92790: LD_INT 1
92792: NEG
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: LD_INT 2
92803: NEG
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 4
92811: PUSH
92812: LD_INT 2
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 4
92821: PUSH
92822: LD_INT 4
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 4
92831: PUSH
92832: LD_INT 3
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 5
92841: PUSH
92842: LD_INT 4
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 5
92851: PUSH
92852: LD_INT 5
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 4
92861: PUSH
92862: LD_INT 5
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 3
92871: PUSH
92872: LD_INT 4
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: PUSH
92879: LD_INT 3
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 5
92891: PUSH
92892: LD_INT 3
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 3
92901: PUSH
92902: LD_INT 5
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
92956: LD_ADDR_VAR 0 33
92960: PUSH
92961: LD_INT 4
92963: NEG
92964: PUSH
92965: LD_INT 4
92967: NEG
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 4
92975: NEG
92976: PUSH
92977: LD_INT 5
92979: NEG
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 3
92987: NEG
92988: PUSH
92989: LD_INT 4
92991: NEG
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: LD_INT 3
92999: NEG
93000: PUSH
93001: LD_INT 3
93003: NEG
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PUSH
93009: LD_INT 4
93011: NEG
93012: PUSH
93013: LD_INT 3
93015: NEG
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 5
93023: NEG
93024: PUSH
93025: LD_INT 4
93027: NEG
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 5
93035: NEG
93036: PUSH
93037: LD_INT 5
93039: NEG
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 3
93047: NEG
93048: PUSH
93049: LD_INT 5
93051: NEG
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 5
93059: NEG
93060: PUSH
93061: LD_INT 3
93063: NEG
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 0
93071: PUSH
93072: LD_INT 3
93074: NEG
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 0
93082: PUSH
93083: LD_INT 4
93085: NEG
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 1
93093: PUSH
93094: LD_INT 3
93096: NEG
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 1
93104: PUSH
93105: LD_INT 2
93107: NEG
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 0
93115: PUSH
93116: LD_INT 2
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 1
93126: NEG
93127: PUSH
93128: LD_INT 3
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 1
93138: NEG
93139: PUSH
93140: LD_INT 4
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 2
93150: PUSH
93151: LD_INT 2
93153: NEG
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: LD_INT 2
93161: NEG
93162: PUSH
93163: LD_INT 4
93165: NEG
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 4
93173: PUSH
93174: LD_INT 0
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 4
93183: PUSH
93184: LD_INT 1
93186: NEG
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 5
93194: PUSH
93195: LD_INT 0
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 5
93204: PUSH
93205: LD_INT 1
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 4
93214: PUSH
93215: LD_INT 1
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 3
93224: PUSH
93225: LD_INT 0
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: LD_INT 3
93234: PUSH
93235: LD_INT 1
93237: NEG
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 3
93245: PUSH
93246: LD_INT 2
93248: NEG
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 5
93256: PUSH
93257: LD_INT 2
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 3
93266: PUSH
93267: LD_INT 3
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 3
93276: PUSH
93277: LD_INT 2
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 4
93286: PUSH
93287: LD_INT 3
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 4
93296: PUSH
93297: LD_INT 4
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: PUSH
93304: LD_INT 3
93306: PUSH
93307: LD_INT 4
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 2
93316: PUSH
93317: LD_INT 3
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 2
93326: PUSH
93327: LD_INT 2
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: LD_INT 4
93336: PUSH
93337: LD_INT 2
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: PUSH
93344: LD_INT 2
93346: PUSH
93347: LD_INT 4
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: PUSH
93354: LD_INT 0
93356: PUSH
93357: LD_INT 4
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 0
93366: PUSH
93367: LD_INT 3
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 1
93376: PUSH
93377: LD_INT 4
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 1
93386: PUSH
93387: LD_INT 5
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: LD_INT 0
93396: PUSH
93397: LD_INT 5
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 1
93406: NEG
93407: PUSH
93408: LD_INT 4
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 1
93417: NEG
93418: PUSH
93419: LD_INT 3
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 2
93428: PUSH
93429: LD_INT 5
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 2
93438: NEG
93439: PUSH
93440: LD_INT 3
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
93494: LD_ADDR_VAR 0 34
93498: PUSH
93499: LD_INT 0
93501: PUSH
93502: LD_INT 4
93504: NEG
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 0
93512: PUSH
93513: LD_INT 5
93515: NEG
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 1
93523: PUSH
93524: LD_INT 4
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 1
93534: PUSH
93535: LD_INT 3
93537: NEG
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 0
93545: PUSH
93546: LD_INT 3
93548: NEG
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 1
93556: NEG
93557: PUSH
93558: LD_INT 4
93560: NEG
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: PUSH
93566: LD_INT 1
93568: NEG
93569: PUSH
93570: LD_INT 5
93572: NEG
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 2
93580: PUSH
93581: LD_INT 3
93583: NEG
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 2
93591: NEG
93592: PUSH
93593: LD_INT 5
93595: NEG
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 3
93603: PUSH
93604: LD_INT 0
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 3
93613: PUSH
93614: LD_INT 1
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 4
93624: PUSH
93625: LD_INT 0
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 4
93634: PUSH
93635: LD_INT 1
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: LD_INT 3
93644: PUSH
93645: LD_INT 1
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 2
93654: PUSH
93655: LD_INT 0
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 2
93664: PUSH
93665: LD_INT 1
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 2
93675: PUSH
93676: LD_INT 2
93678: NEG
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 4
93686: PUSH
93687: LD_INT 2
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 4
93696: PUSH
93697: LD_INT 4
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 4
93706: PUSH
93707: LD_INT 3
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 5
93716: PUSH
93717: LD_INT 4
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 5
93726: PUSH
93727: LD_INT 5
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 4
93736: PUSH
93737: LD_INT 5
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: LD_INT 3
93746: PUSH
93747: LD_INT 4
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 3
93756: PUSH
93757: LD_INT 3
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 5
93766: PUSH
93767: LD_INT 3
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 3
93776: PUSH
93777: LD_INT 5
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 0
93786: PUSH
93787: LD_INT 3
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 0
93796: PUSH
93797: LD_INT 2
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 1
93806: PUSH
93807: LD_INT 3
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 1
93816: PUSH
93817: LD_INT 4
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: LD_INT 4
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: LD_INT 3
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 1
93847: NEG
93848: PUSH
93849: LD_INT 2
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 2
93858: PUSH
93859: LD_INT 4
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: NEG
93869: PUSH
93870: LD_INT 2
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 4
93879: NEG
93880: PUSH
93881: LD_INT 0
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 4
93890: NEG
93891: PUSH
93892: LD_INT 1
93894: NEG
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: PUSH
93900: LD_INT 3
93902: NEG
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: LD_INT 3
93913: NEG
93914: PUSH
93915: LD_INT 1
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 4
93924: NEG
93925: PUSH
93926: LD_INT 1
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 5
93935: NEG
93936: PUSH
93937: LD_INT 0
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 5
93946: NEG
93947: PUSH
93948: LD_INT 1
93950: NEG
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 5
93958: NEG
93959: PUSH
93960: LD_INT 2
93962: NEG
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 3
93970: NEG
93971: PUSH
93972: LD_INT 2
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: ST_TO_ADDR
// end ; end ;
94026: GO 94029
94028: POP
// case btype of b_depot , b_warehouse :
94029: LD_VAR 0 1
94033: PUSH
94034: LD_INT 0
94036: DOUBLE
94037: EQUAL
94038: IFTRUE 94048
94040: LD_INT 1
94042: DOUBLE
94043: EQUAL
94044: IFTRUE 94048
94046: GO 94249
94048: POP
// case nation of nation_american :
94049: LD_VAR 0 5
94053: PUSH
94054: LD_INT 1
94056: DOUBLE
94057: EQUAL
94058: IFTRUE 94062
94060: GO 94118
94062: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
94063: LD_ADDR_VAR 0 9
94067: PUSH
94068: LD_VAR 0 11
94072: PUSH
94073: LD_VAR 0 12
94077: PUSH
94078: LD_VAR 0 13
94082: PUSH
94083: LD_VAR 0 14
94087: PUSH
94088: LD_VAR 0 15
94092: PUSH
94093: LD_VAR 0 16
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: PUSH
94106: LD_VAR 0 4
94110: PUSH
94111: LD_INT 1
94113: PLUS
94114: ARRAY
94115: ST_TO_ADDR
94116: GO 94247
94118: LD_INT 2
94120: DOUBLE
94121: EQUAL
94122: IFTRUE 94126
94124: GO 94182
94126: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
94127: LD_ADDR_VAR 0 9
94131: PUSH
94132: LD_VAR 0 17
94136: PUSH
94137: LD_VAR 0 18
94141: PUSH
94142: LD_VAR 0 19
94146: PUSH
94147: LD_VAR 0 20
94151: PUSH
94152: LD_VAR 0 21
94156: PUSH
94157: LD_VAR 0 22
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: PUSH
94170: LD_VAR 0 4
94174: PUSH
94175: LD_INT 1
94177: PLUS
94178: ARRAY
94179: ST_TO_ADDR
94180: GO 94247
94182: LD_INT 3
94184: DOUBLE
94185: EQUAL
94186: IFTRUE 94190
94188: GO 94246
94190: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
94191: LD_ADDR_VAR 0 9
94195: PUSH
94196: LD_VAR 0 23
94200: PUSH
94201: LD_VAR 0 24
94205: PUSH
94206: LD_VAR 0 25
94210: PUSH
94211: LD_VAR 0 26
94215: PUSH
94216: LD_VAR 0 27
94220: PUSH
94221: LD_VAR 0 28
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: PUSH
94234: LD_VAR 0 4
94238: PUSH
94239: LD_INT 1
94241: PLUS
94242: ARRAY
94243: ST_TO_ADDR
94244: GO 94247
94246: POP
94247: GO 94802
94249: LD_INT 2
94251: DOUBLE
94252: EQUAL
94253: IFTRUE 94263
94255: LD_INT 3
94257: DOUBLE
94258: EQUAL
94259: IFTRUE 94263
94261: GO 94319
94263: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
94264: LD_ADDR_VAR 0 9
94268: PUSH
94269: LD_VAR 0 29
94273: PUSH
94274: LD_VAR 0 30
94278: PUSH
94279: LD_VAR 0 31
94283: PUSH
94284: LD_VAR 0 32
94288: PUSH
94289: LD_VAR 0 33
94293: PUSH
94294: LD_VAR 0 34
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: PUSH
94307: LD_VAR 0 4
94311: PUSH
94312: LD_INT 1
94314: PLUS
94315: ARRAY
94316: ST_TO_ADDR
94317: GO 94802
94319: LD_INT 16
94321: DOUBLE
94322: EQUAL
94323: IFTRUE 94381
94325: LD_INT 17
94327: DOUBLE
94328: EQUAL
94329: IFTRUE 94381
94331: LD_INT 18
94333: DOUBLE
94334: EQUAL
94335: IFTRUE 94381
94337: LD_INT 19
94339: DOUBLE
94340: EQUAL
94341: IFTRUE 94381
94343: LD_INT 22
94345: DOUBLE
94346: EQUAL
94347: IFTRUE 94381
94349: LD_INT 20
94351: DOUBLE
94352: EQUAL
94353: IFTRUE 94381
94355: LD_INT 21
94357: DOUBLE
94358: EQUAL
94359: IFTRUE 94381
94361: LD_INT 23
94363: DOUBLE
94364: EQUAL
94365: IFTRUE 94381
94367: LD_INT 24
94369: DOUBLE
94370: EQUAL
94371: IFTRUE 94381
94373: LD_INT 25
94375: DOUBLE
94376: EQUAL
94377: IFTRUE 94381
94379: GO 94437
94381: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
94382: LD_ADDR_VAR 0 9
94386: PUSH
94387: LD_VAR 0 35
94391: PUSH
94392: LD_VAR 0 36
94396: PUSH
94397: LD_VAR 0 37
94401: PUSH
94402: LD_VAR 0 38
94406: PUSH
94407: LD_VAR 0 39
94411: PUSH
94412: LD_VAR 0 40
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: PUSH
94425: LD_VAR 0 4
94429: PUSH
94430: LD_INT 1
94432: PLUS
94433: ARRAY
94434: ST_TO_ADDR
94435: GO 94802
94437: LD_INT 6
94439: DOUBLE
94440: EQUAL
94441: IFTRUE 94493
94443: LD_INT 7
94445: DOUBLE
94446: EQUAL
94447: IFTRUE 94493
94449: LD_INT 8
94451: DOUBLE
94452: EQUAL
94453: IFTRUE 94493
94455: LD_INT 13
94457: DOUBLE
94458: EQUAL
94459: IFTRUE 94493
94461: LD_INT 12
94463: DOUBLE
94464: EQUAL
94465: IFTRUE 94493
94467: LD_INT 15
94469: DOUBLE
94470: EQUAL
94471: IFTRUE 94493
94473: LD_INT 11
94475: DOUBLE
94476: EQUAL
94477: IFTRUE 94493
94479: LD_INT 14
94481: DOUBLE
94482: EQUAL
94483: IFTRUE 94493
94485: LD_INT 10
94487: DOUBLE
94488: EQUAL
94489: IFTRUE 94493
94491: GO 94549
94493: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
94494: LD_ADDR_VAR 0 9
94498: PUSH
94499: LD_VAR 0 41
94503: PUSH
94504: LD_VAR 0 42
94508: PUSH
94509: LD_VAR 0 43
94513: PUSH
94514: LD_VAR 0 44
94518: PUSH
94519: LD_VAR 0 45
94523: PUSH
94524: LD_VAR 0 46
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: PUSH
94537: LD_VAR 0 4
94541: PUSH
94542: LD_INT 1
94544: PLUS
94545: ARRAY
94546: ST_TO_ADDR
94547: GO 94802
94549: LD_INT 36
94551: DOUBLE
94552: EQUAL
94553: IFTRUE 94557
94555: GO 94613
94557: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
94558: LD_ADDR_VAR 0 9
94562: PUSH
94563: LD_VAR 0 47
94567: PUSH
94568: LD_VAR 0 48
94572: PUSH
94573: LD_VAR 0 49
94577: PUSH
94578: LD_VAR 0 50
94582: PUSH
94583: LD_VAR 0 51
94587: PUSH
94588: LD_VAR 0 52
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: PUSH
94601: LD_VAR 0 4
94605: PUSH
94606: LD_INT 1
94608: PLUS
94609: ARRAY
94610: ST_TO_ADDR
94611: GO 94802
94613: LD_INT 4
94615: DOUBLE
94616: EQUAL
94617: IFTRUE 94639
94619: LD_INT 5
94621: DOUBLE
94622: EQUAL
94623: IFTRUE 94639
94625: LD_INT 34
94627: DOUBLE
94628: EQUAL
94629: IFTRUE 94639
94631: LD_INT 37
94633: DOUBLE
94634: EQUAL
94635: IFTRUE 94639
94637: GO 94695
94639: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
94640: LD_ADDR_VAR 0 9
94644: PUSH
94645: LD_VAR 0 53
94649: PUSH
94650: LD_VAR 0 54
94654: PUSH
94655: LD_VAR 0 55
94659: PUSH
94660: LD_VAR 0 56
94664: PUSH
94665: LD_VAR 0 57
94669: PUSH
94670: LD_VAR 0 58
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: PUSH
94683: LD_VAR 0 4
94687: PUSH
94688: LD_INT 1
94690: PLUS
94691: ARRAY
94692: ST_TO_ADDR
94693: GO 94802
94695: LD_INT 31
94697: DOUBLE
94698: EQUAL
94699: IFTRUE 94745
94701: LD_INT 32
94703: DOUBLE
94704: EQUAL
94705: IFTRUE 94745
94707: LD_INT 33
94709: DOUBLE
94710: EQUAL
94711: IFTRUE 94745
94713: LD_INT 27
94715: DOUBLE
94716: EQUAL
94717: IFTRUE 94745
94719: LD_INT 26
94721: DOUBLE
94722: EQUAL
94723: IFTRUE 94745
94725: LD_INT 28
94727: DOUBLE
94728: EQUAL
94729: IFTRUE 94745
94731: LD_INT 29
94733: DOUBLE
94734: EQUAL
94735: IFTRUE 94745
94737: LD_INT 30
94739: DOUBLE
94740: EQUAL
94741: IFTRUE 94745
94743: GO 94801
94745: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
94746: LD_ADDR_VAR 0 9
94750: PUSH
94751: LD_VAR 0 59
94755: PUSH
94756: LD_VAR 0 60
94760: PUSH
94761: LD_VAR 0 61
94765: PUSH
94766: LD_VAR 0 62
94770: PUSH
94771: LD_VAR 0 63
94775: PUSH
94776: LD_VAR 0 64
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: PUSH
94789: LD_VAR 0 4
94793: PUSH
94794: LD_INT 1
94796: PLUS
94797: ARRAY
94798: ST_TO_ADDR
94799: GO 94802
94801: POP
// temp_list2 = [ ] ;
94802: LD_ADDR_VAR 0 10
94806: PUSH
94807: EMPTY
94808: ST_TO_ADDR
// for i in temp_list do
94809: LD_ADDR_VAR 0 8
94813: PUSH
94814: LD_VAR 0 9
94818: PUSH
94819: FOR_IN
94820: IFFALSE 94872
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
94822: LD_ADDR_VAR 0 10
94826: PUSH
94827: LD_VAR 0 10
94831: PUSH
94832: LD_VAR 0 8
94836: PUSH
94837: LD_INT 1
94839: ARRAY
94840: PUSH
94841: LD_VAR 0 2
94845: PLUS
94846: PUSH
94847: LD_VAR 0 8
94851: PUSH
94852: LD_INT 2
94854: ARRAY
94855: PUSH
94856: LD_VAR 0 3
94860: PLUS
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: EMPTY
94867: LIST
94868: ADD
94869: ST_TO_ADDR
94870: GO 94819
94872: POP
94873: POP
// result = temp_list2 ;
94874: LD_ADDR_VAR 0 7
94878: PUSH
94879: LD_VAR 0 10
94883: ST_TO_ADDR
// end ;
94884: LD_VAR 0 7
94888: RET
// export function EnemyInRange ( unit , dist ) ; begin
94889: LD_INT 0
94891: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
94892: LD_ADDR_VAR 0 3
94896: PUSH
94897: LD_VAR 0 1
94901: PPUSH
94902: CALL_OW 255
94906: PPUSH
94907: LD_VAR 0 1
94911: PPUSH
94912: CALL_OW 250
94916: PPUSH
94917: LD_VAR 0 1
94921: PPUSH
94922: CALL_OW 251
94926: PPUSH
94927: LD_VAR 0 2
94931: PPUSH
94932: CALL 68285 0 4
94936: PUSH
94937: LD_INT 4
94939: ARRAY
94940: ST_TO_ADDR
// end ;
94941: LD_VAR 0 3
94945: RET
// export function PlayerSeeMe ( unit ) ; begin
94946: LD_INT 0
94948: PPUSH
// result := See ( your_side , unit ) ;
94949: LD_ADDR_VAR 0 2
94953: PUSH
94954: LD_OWVAR 2
94958: PPUSH
94959: LD_VAR 0 1
94963: PPUSH
94964: CALL_OW 292
94968: ST_TO_ADDR
// end ;
94969: LD_VAR 0 2
94973: RET
// export function ReverseDir ( unit ) ; begin
94974: LD_INT 0
94976: PPUSH
// if not unit then
94977: LD_VAR 0 1
94981: NOT
94982: IFFALSE 94986
// exit ;
94984: GO 95009
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
94986: LD_ADDR_VAR 0 2
94990: PUSH
94991: LD_VAR 0 1
94995: PPUSH
94996: CALL_OW 254
95000: PUSH
95001: LD_INT 3
95003: PLUS
95004: PUSH
95005: LD_INT 6
95007: MOD
95008: ST_TO_ADDR
// end ;
95009: LD_VAR 0 2
95013: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
95014: LD_INT 0
95016: PPUSH
95017: PPUSH
95018: PPUSH
95019: PPUSH
95020: PPUSH
// if not hexes then
95021: LD_VAR 0 2
95025: NOT
95026: IFFALSE 95030
// exit ;
95028: GO 95178
// dist := 9999 ;
95030: LD_ADDR_VAR 0 5
95034: PUSH
95035: LD_INT 9999
95037: ST_TO_ADDR
// for i = 1 to hexes do
95038: LD_ADDR_VAR 0 4
95042: PUSH
95043: DOUBLE
95044: LD_INT 1
95046: DEC
95047: ST_TO_ADDR
95048: LD_VAR 0 2
95052: PUSH
95053: FOR_TO
95054: IFFALSE 95166
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
95056: LD_VAR 0 1
95060: PPUSH
95061: LD_VAR 0 2
95065: PUSH
95066: LD_VAR 0 4
95070: ARRAY
95071: PUSH
95072: LD_INT 1
95074: ARRAY
95075: PPUSH
95076: LD_VAR 0 2
95080: PUSH
95081: LD_VAR 0 4
95085: ARRAY
95086: PUSH
95087: LD_INT 2
95089: ARRAY
95090: PPUSH
95091: CALL_OW 297
95095: PUSH
95096: LD_VAR 0 5
95100: LESS
95101: IFFALSE 95164
// begin hex := hexes [ i ] ;
95103: LD_ADDR_VAR 0 7
95107: PUSH
95108: LD_VAR 0 2
95112: PUSH
95113: LD_VAR 0 4
95117: ARRAY
95118: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
95119: LD_ADDR_VAR 0 5
95123: PUSH
95124: LD_VAR 0 1
95128: PPUSH
95129: LD_VAR 0 2
95133: PUSH
95134: LD_VAR 0 4
95138: ARRAY
95139: PUSH
95140: LD_INT 1
95142: ARRAY
95143: PPUSH
95144: LD_VAR 0 2
95148: PUSH
95149: LD_VAR 0 4
95153: ARRAY
95154: PUSH
95155: LD_INT 2
95157: ARRAY
95158: PPUSH
95159: CALL_OW 297
95163: ST_TO_ADDR
// end ; end ;
95164: GO 95053
95166: POP
95167: POP
// result := hex ;
95168: LD_ADDR_VAR 0 3
95172: PUSH
95173: LD_VAR 0 7
95177: ST_TO_ADDR
// end ;
95178: LD_VAR 0 3
95182: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
95183: LD_INT 0
95185: PPUSH
95186: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
95187: LD_VAR 0 1
95191: NOT
95192: PUSH
95193: LD_VAR 0 1
95197: PUSH
95198: LD_INT 21
95200: PUSH
95201: LD_INT 2
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 23
95210: PUSH
95211: LD_INT 2
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PPUSH
95222: CALL_OW 69
95226: IN
95227: NOT
95228: OR
95229: IFFALSE 95233
// exit ;
95231: GO 95280
// for i = 1 to 3 do
95233: LD_ADDR_VAR 0 3
95237: PUSH
95238: DOUBLE
95239: LD_INT 1
95241: DEC
95242: ST_TO_ADDR
95243: LD_INT 3
95245: PUSH
95246: FOR_TO
95247: IFFALSE 95278
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
95249: LD_VAR 0 1
95253: PPUSH
95254: CALL_OW 250
95258: PPUSH
95259: LD_VAR 0 1
95263: PPUSH
95264: CALL_OW 251
95268: PPUSH
95269: LD_INT 1
95271: PPUSH
95272: CALL_OW 453
95276: GO 95246
95278: POP
95279: POP
// end ;
95280: LD_VAR 0 2
95284: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
95285: LD_INT 0
95287: PPUSH
95288: PPUSH
95289: PPUSH
95290: PPUSH
95291: PPUSH
95292: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
95293: LD_VAR 0 1
95297: NOT
95298: PUSH
95299: LD_VAR 0 2
95303: NOT
95304: OR
95305: PUSH
95306: LD_VAR 0 1
95310: PPUSH
95311: CALL_OW 314
95315: OR
95316: IFFALSE 95320
// exit ;
95318: GO 95761
// x := GetX ( enemy_unit ) ;
95320: LD_ADDR_VAR 0 7
95324: PUSH
95325: LD_VAR 0 2
95329: PPUSH
95330: CALL_OW 250
95334: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
95335: LD_ADDR_VAR 0 8
95339: PUSH
95340: LD_VAR 0 2
95344: PPUSH
95345: CALL_OW 251
95349: ST_TO_ADDR
// if not x or not y then
95350: LD_VAR 0 7
95354: NOT
95355: PUSH
95356: LD_VAR 0 8
95360: NOT
95361: OR
95362: IFFALSE 95366
// exit ;
95364: GO 95761
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
95366: LD_ADDR_VAR 0 6
95370: PUSH
95371: LD_VAR 0 7
95375: PPUSH
95376: LD_INT 0
95378: PPUSH
95379: LD_INT 4
95381: PPUSH
95382: CALL_OW 272
95386: PUSH
95387: LD_VAR 0 8
95391: PPUSH
95392: LD_INT 0
95394: PPUSH
95395: LD_INT 4
95397: PPUSH
95398: CALL_OW 273
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_VAR 0 7
95411: PPUSH
95412: LD_INT 1
95414: PPUSH
95415: LD_INT 4
95417: PPUSH
95418: CALL_OW 272
95422: PUSH
95423: LD_VAR 0 8
95427: PPUSH
95428: LD_INT 1
95430: PPUSH
95431: LD_INT 4
95433: PPUSH
95434: CALL_OW 273
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_VAR 0 7
95447: PPUSH
95448: LD_INT 2
95450: PPUSH
95451: LD_INT 4
95453: PPUSH
95454: CALL_OW 272
95458: PUSH
95459: LD_VAR 0 8
95463: PPUSH
95464: LD_INT 2
95466: PPUSH
95467: LD_INT 4
95469: PPUSH
95470: CALL_OW 273
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_VAR 0 7
95483: PPUSH
95484: LD_INT 3
95486: PPUSH
95487: LD_INT 4
95489: PPUSH
95490: CALL_OW 272
95494: PUSH
95495: LD_VAR 0 8
95499: PPUSH
95500: LD_INT 3
95502: PPUSH
95503: LD_INT 4
95505: PPUSH
95506: CALL_OW 273
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_VAR 0 7
95519: PPUSH
95520: LD_INT 4
95522: PPUSH
95523: LD_INT 4
95525: PPUSH
95526: CALL_OW 272
95530: PUSH
95531: LD_VAR 0 8
95535: PPUSH
95536: LD_INT 4
95538: PPUSH
95539: LD_INT 4
95541: PPUSH
95542: CALL_OW 273
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PUSH
95551: LD_VAR 0 7
95555: PPUSH
95556: LD_INT 5
95558: PPUSH
95559: LD_INT 4
95561: PPUSH
95562: CALL_OW 272
95566: PUSH
95567: LD_VAR 0 8
95571: PPUSH
95572: LD_INT 5
95574: PPUSH
95575: LD_INT 4
95577: PPUSH
95578: CALL_OW 273
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: ST_TO_ADDR
// for i = tmp downto 1 do
95595: LD_ADDR_VAR 0 4
95599: PUSH
95600: DOUBLE
95601: LD_VAR 0 6
95605: INC
95606: ST_TO_ADDR
95607: LD_INT 1
95609: PUSH
95610: FOR_DOWNTO
95611: IFFALSE 95712
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
95613: LD_VAR 0 6
95617: PUSH
95618: LD_VAR 0 4
95622: ARRAY
95623: PUSH
95624: LD_INT 1
95626: ARRAY
95627: PPUSH
95628: LD_VAR 0 6
95632: PUSH
95633: LD_VAR 0 4
95637: ARRAY
95638: PUSH
95639: LD_INT 2
95641: ARRAY
95642: PPUSH
95643: CALL_OW 488
95647: NOT
95648: PUSH
95649: LD_VAR 0 6
95653: PUSH
95654: LD_VAR 0 4
95658: ARRAY
95659: PUSH
95660: LD_INT 1
95662: ARRAY
95663: PPUSH
95664: LD_VAR 0 6
95668: PUSH
95669: LD_VAR 0 4
95673: ARRAY
95674: PUSH
95675: LD_INT 2
95677: ARRAY
95678: PPUSH
95679: CALL_OW 428
95683: PUSH
95684: LD_INT 0
95686: NONEQUAL
95687: OR
95688: IFFALSE 95710
// tmp := Delete ( tmp , i ) ;
95690: LD_ADDR_VAR 0 6
95694: PUSH
95695: LD_VAR 0 6
95699: PPUSH
95700: LD_VAR 0 4
95704: PPUSH
95705: CALL_OW 3
95709: ST_TO_ADDR
95710: GO 95610
95712: POP
95713: POP
// j := GetClosestHex ( unit , tmp ) ;
95714: LD_ADDR_VAR 0 5
95718: PUSH
95719: LD_VAR 0 1
95723: PPUSH
95724: LD_VAR 0 6
95728: PPUSH
95729: CALL 95014 0 2
95733: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
95734: LD_VAR 0 1
95738: PPUSH
95739: LD_VAR 0 5
95743: PUSH
95744: LD_INT 1
95746: ARRAY
95747: PPUSH
95748: LD_VAR 0 5
95752: PUSH
95753: LD_INT 2
95755: ARRAY
95756: PPUSH
95757: CALL_OW 111
// end ;
95761: LD_VAR 0 3
95765: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
95766: LD_INT 0
95768: PPUSH
95769: PPUSH
95770: PPUSH
// uc_side = 0 ;
95771: LD_ADDR_OWVAR 20
95775: PUSH
95776: LD_INT 0
95778: ST_TO_ADDR
// uc_nation = 0 ;
95779: LD_ADDR_OWVAR 21
95783: PUSH
95784: LD_INT 0
95786: ST_TO_ADDR
// InitHc_All ( ) ;
95787: CALL_OW 584
// InitVc ;
95791: CALL_OW 20
// if mastodonts then
95795: LD_VAR 0 6
95799: IFFALSE 95866
// for i = 1 to mastodonts do
95801: LD_ADDR_VAR 0 11
95805: PUSH
95806: DOUBLE
95807: LD_INT 1
95809: DEC
95810: ST_TO_ADDR
95811: LD_VAR 0 6
95815: PUSH
95816: FOR_TO
95817: IFFALSE 95864
// begin vc_chassis := 31 ;
95819: LD_ADDR_OWVAR 37
95823: PUSH
95824: LD_INT 31
95826: ST_TO_ADDR
// vc_control := control_rider ;
95827: LD_ADDR_OWVAR 38
95831: PUSH
95832: LD_INT 4
95834: ST_TO_ADDR
// animal := CreateVehicle ;
95835: LD_ADDR_VAR 0 12
95839: PUSH
95840: CALL_OW 45
95844: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95845: LD_VAR 0 12
95849: PPUSH
95850: LD_VAR 0 8
95854: PPUSH
95855: LD_INT 0
95857: PPUSH
95858: CALL 98054 0 3
// end ;
95862: GO 95816
95864: POP
95865: POP
// if horses then
95866: LD_VAR 0 5
95870: IFFALSE 95937
// for i = 1 to horses do
95872: LD_ADDR_VAR 0 11
95876: PUSH
95877: DOUBLE
95878: LD_INT 1
95880: DEC
95881: ST_TO_ADDR
95882: LD_VAR 0 5
95886: PUSH
95887: FOR_TO
95888: IFFALSE 95935
// begin hc_class := 21 ;
95890: LD_ADDR_OWVAR 28
95894: PUSH
95895: LD_INT 21
95897: ST_TO_ADDR
// hc_gallery :=  ;
95898: LD_ADDR_OWVAR 33
95902: PUSH
95903: LD_STRING 
95905: ST_TO_ADDR
// animal := CreateHuman ;
95906: LD_ADDR_VAR 0 12
95910: PUSH
95911: CALL_OW 44
95915: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95916: LD_VAR 0 12
95920: PPUSH
95921: LD_VAR 0 8
95925: PPUSH
95926: LD_INT 0
95928: PPUSH
95929: CALL 98054 0 3
// end ;
95933: GO 95887
95935: POP
95936: POP
// if birds then
95937: LD_VAR 0 1
95941: IFFALSE 96008
// for i = 1 to birds do
95943: LD_ADDR_VAR 0 11
95947: PUSH
95948: DOUBLE
95949: LD_INT 1
95951: DEC
95952: ST_TO_ADDR
95953: LD_VAR 0 1
95957: PUSH
95958: FOR_TO
95959: IFFALSE 96006
// begin hc_class = 18 ;
95961: LD_ADDR_OWVAR 28
95965: PUSH
95966: LD_INT 18
95968: ST_TO_ADDR
// hc_gallery =  ;
95969: LD_ADDR_OWVAR 33
95973: PUSH
95974: LD_STRING 
95976: ST_TO_ADDR
// animal := CreateHuman ;
95977: LD_ADDR_VAR 0 12
95981: PUSH
95982: CALL_OW 44
95986: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95987: LD_VAR 0 12
95991: PPUSH
95992: LD_VAR 0 8
95996: PPUSH
95997: LD_INT 0
95999: PPUSH
96000: CALL 98054 0 3
// end ;
96004: GO 95958
96006: POP
96007: POP
// if tigers then
96008: LD_VAR 0 2
96012: IFFALSE 96096
// for i = 1 to tigers do
96014: LD_ADDR_VAR 0 11
96018: PUSH
96019: DOUBLE
96020: LD_INT 1
96022: DEC
96023: ST_TO_ADDR
96024: LD_VAR 0 2
96028: PUSH
96029: FOR_TO
96030: IFFALSE 96094
// begin hc_class = class_tiger ;
96032: LD_ADDR_OWVAR 28
96036: PUSH
96037: LD_INT 14
96039: ST_TO_ADDR
// hc_gallery =  ;
96040: LD_ADDR_OWVAR 33
96044: PUSH
96045: LD_STRING 
96047: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
96048: LD_ADDR_OWVAR 35
96052: PUSH
96053: LD_INT 7
96055: NEG
96056: PPUSH
96057: LD_INT 7
96059: PPUSH
96060: CALL_OW 12
96064: ST_TO_ADDR
// animal := CreateHuman ;
96065: LD_ADDR_VAR 0 12
96069: PUSH
96070: CALL_OW 44
96074: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96075: LD_VAR 0 12
96079: PPUSH
96080: LD_VAR 0 8
96084: PPUSH
96085: LD_INT 0
96087: PPUSH
96088: CALL 98054 0 3
// end ;
96092: GO 96029
96094: POP
96095: POP
// if apemans then
96096: LD_VAR 0 3
96100: IFFALSE 96223
// for i = 1 to apemans do
96102: LD_ADDR_VAR 0 11
96106: PUSH
96107: DOUBLE
96108: LD_INT 1
96110: DEC
96111: ST_TO_ADDR
96112: LD_VAR 0 3
96116: PUSH
96117: FOR_TO
96118: IFFALSE 96221
// begin hc_class = class_apeman ;
96120: LD_ADDR_OWVAR 28
96124: PUSH
96125: LD_INT 12
96127: ST_TO_ADDR
// hc_gallery =  ;
96128: LD_ADDR_OWVAR 33
96132: PUSH
96133: LD_STRING 
96135: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
96136: LD_ADDR_OWVAR 35
96140: PUSH
96141: LD_INT 2
96143: NEG
96144: PPUSH
96145: LD_INT 2
96147: PPUSH
96148: CALL_OW 12
96152: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
96153: LD_ADDR_OWVAR 31
96157: PUSH
96158: LD_INT 1
96160: PPUSH
96161: LD_INT 3
96163: PPUSH
96164: CALL_OW 12
96168: PUSH
96169: LD_INT 1
96171: PPUSH
96172: LD_INT 3
96174: PPUSH
96175: CALL_OW 12
96179: PUSH
96180: LD_INT 0
96182: PUSH
96183: LD_INT 0
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: ST_TO_ADDR
// animal := CreateHuman ;
96192: LD_ADDR_VAR 0 12
96196: PUSH
96197: CALL_OW 44
96201: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96202: LD_VAR 0 12
96206: PPUSH
96207: LD_VAR 0 8
96211: PPUSH
96212: LD_INT 0
96214: PPUSH
96215: CALL 98054 0 3
// end ;
96219: GO 96117
96221: POP
96222: POP
// if enchidnas then
96223: LD_VAR 0 4
96227: IFFALSE 96294
// for i = 1 to enchidnas do
96229: LD_ADDR_VAR 0 11
96233: PUSH
96234: DOUBLE
96235: LD_INT 1
96237: DEC
96238: ST_TO_ADDR
96239: LD_VAR 0 4
96243: PUSH
96244: FOR_TO
96245: IFFALSE 96292
// begin hc_class = 13 ;
96247: LD_ADDR_OWVAR 28
96251: PUSH
96252: LD_INT 13
96254: ST_TO_ADDR
// hc_gallery =  ;
96255: LD_ADDR_OWVAR 33
96259: PUSH
96260: LD_STRING 
96262: ST_TO_ADDR
// animal := CreateHuman ;
96263: LD_ADDR_VAR 0 12
96267: PUSH
96268: CALL_OW 44
96272: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96273: LD_VAR 0 12
96277: PPUSH
96278: LD_VAR 0 8
96282: PPUSH
96283: LD_INT 0
96285: PPUSH
96286: CALL 98054 0 3
// end ;
96290: GO 96244
96292: POP
96293: POP
// if fishes then
96294: LD_VAR 0 7
96298: IFFALSE 96365
// for i = 1 to fishes do
96300: LD_ADDR_VAR 0 11
96304: PUSH
96305: DOUBLE
96306: LD_INT 1
96308: DEC
96309: ST_TO_ADDR
96310: LD_VAR 0 7
96314: PUSH
96315: FOR_TO
96316: IFFALSE 96363
// begin hc_class = 20 ;
96318: LD_ADDR_OWVAR 28
96322: PUSH
96323: LD_INT 20
96325: ST_TO_ADDR
// hc_gallery =  ;
96326: LD_ADDR_OWVAR 33
96330: PUSH
96331: LD_STRING 
96333: ST_TO_ADDR
// animal := CreateHuman ;
96334: LD_ADDR_VAR 0 12
96338: PUSH
96339: CALL_OW 44
96343: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
96344: LD_VAR 0 12
96348: PPUSH
96349: LD_VAR 0 9
96353: PPUSH
96354: LD_INT 0
96356: PPUSH
96357: CALL 98054 0 3
// end ;
96361: GO 96315
96363: POP
96364: POP
// end ;
96365: LD_VAR 0 10
96369: RET
// export function WantHeal ( sci , unit ) ; begin
96370: LD_INT 0
96372: PPUSH
// if GetTaskList ( sci ) > 0 then
96373: LD_VAR 0 1
96377: PPUSH
96378: CALL_OW 437
96382: PUSH
96383: LD_INT 0
96385: GREATER
96386: IFFALSE 96456
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96388: LD_VAR 0 1
96392: PPUSH
96393: CALL_OW 437
96397: PUSH
96398: LD_INT 1
96400: ARRAY
96401: PUSH
96402: LD_INT 1
96404: ARRAY
96405: PUSH
96406: LD_STRING l
96408: EQUAL
96409: PUSH
96410: LD_VAR 0 1
96414: PPUSH
96415: CALL_OW 437
96419: PUSH
96420: LD_INT 1
96422: ARRAY
96423: PUSH
96424: LD_INT 4
96426: ARRAY
96427: PUSH
96428: LD_VAR 0 2
96432: EQUAL
96433: AND
96434: IFFALSE 96446
// result := true else
96436: LD_ADDR_VAR 0 3
96440: PUSH
96441: LD_INT 1
96443: ST_TO_ADDR
96444: GO 96454
// result := false ;
96446: LD_ADDR_VAR 0 3
96450: PUSH
96451: LD_INT 0
96453: ST_TO_ADDR
// end else
96454: GO 96464
// result := false ;
96456: LD_ADDR_VAR 0 3
96460: PUSH
96461: LD_INT 0
96463: ST_TO_ADDR
// end ;
96464: LD_VAR 0 3
96468: RET
// export function HealTarget ( sci ) ; begin
96469: LD_INT 0
96471: PPUSH
// if not sci then
96472: LD_VAR 0 1
96476: NOT
96477: IFFALSE 96481
// exit ;
96479: GO 96546
// result := 0 ;
96481: LD_ADDR_VAR 0 2
96485: PUSH
96486: LD_INT 0
96488: ST_TO_ADDR
// if GetTaskList ( sci ) then
96489: LD_VAR 0 1
96493: PPUSH
96494: CALL_OW 437
96498: IFFALSE 96546
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
96500: LD_VAR 0 1
96504: PPUSH
96505: CALL_OW 437
96509: PUSH
96510: LD_INT 1
96512: ARRAY
96513: PUSH
96514: LD_INT 1
96516: ARRAY
96517: PUSH
96518: LD_STRING l
96520: EQUAL
96521: IFFALSE 96546
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
96523: LD_ADDR_VAR 0 2
96527: PUSH
96528: LD_VAR 0 1
96532: PPUSH
96533: CALL_OW 437
96537: PUSH
96538: LD_INT 1
96540: ARRAY
96541: PUSH
96542: LD_INT 4
96544: ARRAY
96545: ST_TO_ADDR
// end ;
96546: LD_VAR 0 2
96550: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
96551: LD_INT 0
96553: PPUSH
96554: PPUSH
96555: PPUSH
96556: PPUSH
// if not base_units then
96557: LD_VAR 0 1
96561: NOT
96562: IFFALSE 96566
// exit ;
96564: GO 96653
// result := false ;
96566: LD_ADDR_VAR 0 2
96570: PUSH
96571: LD_INT 0
96573: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
96574: LD_ADDR_VAR 0 5
96578: PUSH
96579: LD_VAR 0 1
96583: PPUSH
96584: LD_INT 21
96586: PUSH
96587: LD_INT 3
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PPUSH
96594: CALL_OW 72
96598: ST_TO_ADDR
// if not tmp then
96599: LD_VAR 0 5
96603: NOT
96604: IFFALSE 96608
// exit ;
96606: GO 96653
// for i in tmp do
96608: LD_ADDR_VAR 0 3
96612: PUSH
96613: LD_VAR 0 5
96617: PUSH
96618: FOR_IN
96619: IFFALSE 96651
// begin result := EnemyInRange ( i , 22 ) ;
96621: LD_ADDR_VAR 0 2
96625: PUSH
96626: LD_VAR 0 3
96630: PPUSH
96631: LD_INT 22
96633: PPUSH
96634: CALL 94889 0 2
96638: ST_TO_ADDR
// if result then
96639: LD_VAR 0 2
96643: IFFALSE 96649
// exit ;
96645: POP
96646: POP
96647: GO 96653
// end ;
96649: GO 96618
96651: POP
96652: POP
// end ;
96653: LD_VAR 0 2
96657: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
96658: LD_INT 0
96660: PPUSH
96661: PPUSH
// if not units then
96662: LD_VAR 0 1
96666: NOT
96667: IFFALSE 96671
// exit ;
96669: GO 96741
// result := [ ] ;
96671: LD_ADDR_VAR 0 3
96675: PUSH
96676: EMPTY
96677: ST_TO_ADDR
// for i in units do
96678: LD_ADDR_VAR 0 4
96682: PUSH
96683: LD_VAR 0 1
96687: PUSH
96688: FOR_IN
96689: IFFALSE 96739
// if GetTag ( i ) = tag then
96691: LD_VAR 0 4
96695: PPUSH
96696: CALL_OW 110
96700: PUSH
96701: LD_VAR 0 2
96705: EQUAL
96706: IFFALSE 96737
// result := Replace ( result , result + 1 , i ) ;
96708: LD_ADDR_VAR 0 3
96712: PUSH
96713: LD_VAR 0 3
96717: PPUSH
96718: LD_VAR 0 3
96722: PUSH
96723: LD_INT 1
96725: PLUS
96726: PPUSH
96727: LD_VAR 0 4
96731: PPUSH
96732: CALL_OW 1
96736: ST_TO_ADDR
96737: GO 96688
96739: POP
96740: POP
// end ;
96741: LD_VAR 0 3
96745: RET
// export function IsDriver ( un ) ; begin
96746: LD_INT 0
96748: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
96749: LD_ADDR_VAR 0 2
96753: PUSH
96754: LD_VAR 0 1
96758: PUSH
96759: LD_INT 55
96761: PUSH
96762: EMPTY
96763: LIST
96764: PPUSH
96765: CALL_OW 69
96769: IN
96770: ST_TO_ADDR
// end ;
96771: LD_VAR 0 2
96775: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
96776: LD_INT 0
96778: PPUSH
96779: PPUSH
// list := [ ] ;
96780: LD_ADDR_VAR 0 5
96784: PUSH
96785: EMPTY
96786: ST_TO_ADDR
// case d of 0 :
96787: LD_VAR 0 3
96791: PUSH
96792: LD_INT 0
96794: DOUBLE
96795: EQUAL
96796: IFTRUE 96800
96798: GO 96933
96800: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
96801: LD_ADDR_VAR 0 5
96805: PUSH
96806: LD_VAR 0 1
96810: PUSH
96811: LD_INT 4
96813: MINUS
96814: PUSH
96815: LD_VAR 0 2
96819: PUSH
96820: LD_INT 4
96822: MINUS
96823: PUSH
96824: LD_INT 2
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: LIST
96831: PUSH
96832: LD_VAR 0 1
96836: PUSH
96837: LD_INT 3
96839: MINUS
96840: PUSH
96841: LD_VAR 0 2
96845: PUSH
96846: LD_INT 1
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: LIST
96853: PUSH
96854: LD_VAR 0 1
96858: PUSH
96859: LD_INT 4
96861: PLUS
96862: PUSH
96863: LD_VAR 0 2
96867: PUSH
96868: LD_INT 4
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: LIST
96875: PUSH
96876: LD_VAR 0 1
96880: PUSH
96881: LD_INT 3
96883: PLUS
96884: PUSH
96885: LD_VAR 0 2
96889: PUSH
96890: LD_INT 3
96892: PLUS
96893: PUSH
96894: LD_INT 5
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: LIST
96901: PUSH
96902: LD_VAR 0 1
96906: PUSH
96907: LD_VAR 0 2
96911: PUSH
96912: LD_INT 4
96914: PLUS
96915: PUSH
96916: LD_INT 0
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: LIST
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: ST_TO_ADDR
// end ; 1 :
96931: GO 97631
96933: LD_INT 1
96935: DOUBLE
96936: EQUAL
96937: IFTRUE 96941
96939: GO 97074
96941: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
96942: LD_ADDR_VAR 0 5
96946: PUSH
96947: LD_VAR 0 1
96951: PUSH
96952: LD_VAR 0 2
96956: PUSH
96957: LD_INT 4
96959: MINUS
96960: PUSH
96961: LD_INT 3
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: LIST
96968: PUSH
96969: LD_VAR 0 1
96973: PUSH
96974: LD_INT 3
96976: MINUS
96977: PUSH
96978: LD_VAR 0 2
96982: PUSH
96983: LD_INT 3
96985: MINUS
96986: PUSH
96987: LD_INT 2
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: LIST
96994: PUSH
96995: LD_VAR 0 1
96999: PUSH
97000: LD_INT 4
97002: MINUS
97003: PUSH
97004: LD_VAR 0 2
97008: PUSH
97009: LD_INT 1
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: LIST
97016: PUSH
97017: LD_VAR 0 1
97021: PUSH
97022: LD_VAR 0 2
97026: PUSH
97027: LD_INT 3
97029: PLUS
97030: PUSH
97031: LD_INT 0
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: LIST
97038: PUSH
97039: LD_VAR 0 1
97043: PUSH
97044: LD_INT 4
97046: PLUS
97047: PUSH
97048: LD_VAR 0 2
97052: PUSH
97053: LD_INT 4
97055: PLUS
97056: PUSH
97057: LD_INT 5
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: LIST
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: ST_TO_ADDR
// end ; 2 :
97072: GO 97631
97074: LD_INT 2
97076: DOUBLE
97077: EQUAL
97078: IFTRUE 97082
97080: GO 97211
97082: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
97083: LD_ADDR_VAR 0 5
97087: PUSH
97088: LD_VAR 0 1
97092: PUSH
97093: LD_VAR 0 2
97097: PUSH
97098: LD_INT 3
97100: MINUS
97101: PUSH
97102: LD_INT 3
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: LIST
97109: PUSH
97110: LD_VAR 0 1
97114: PUSH
97115: LD_INT 4
97117: PLUS
97118: PUSH
97119: LD_VAR 0 2
97123: PUSH
97124: LD_INT 4
97126: PUSH
97127: EMPTY
97128: LIST
97129: LIST
97130: LIST
97131: PUSH
97132: LD_VAR 0 1
97136: PUSH
97137: LD_VAR 0 2
97141: PUSH
97142: LD_INT 4
97144: PLUS
97145: PUSH
97146: LD_INT 0
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: LIST
97153: PUSH
97154: LD_VAR 0 1
97158: PUSH
97159: LD_INT 3
97161: MINUS
97162: PUSH
97163: LD_VAR 0 2
97167: PUSH
97168: LD_INT 1
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: LIST
97175: PUSH
97176: LD_VAR 0 1
97180: PUSH
97181: LD_INT 4
97183: MINUS
97184: PUSH
97185: LD_VAR 0 2
97189: PUSH
97190: LD_INT 4
97192: MINUS
97193: PUSH
97194: LD_INT 2
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: LIST
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: ST_TO_ADDR
// end ; 3 :
97209: GO 97631
97211: LD_INT 3
97213: DOUBLE
97214: EQUAL
97215: IFTRUE 97219
97217: GO 97352
97219: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
97220: LD_ADDR_VAR 0 5
97224: PUSH
97225: LD_VAR 0 1
97229: PUSH
97230: LD_INT 3
97232: PLUS
97233: PUSH
97234: LD_VAR 0 2
97238: PUSH
97239: LD_INT 4
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: LIST
97246: PUSH
97247: LD_VAR 0 1
97251: PUSH
97252: LD_INT 4
97254: PLUS
97255: PUSH
97256: LD_VAR 0 2
97260: PUSH
97261: LD_INT 4
97263: PLUS
97264: PUSH
97265: LD_INT 5
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: LIST
97272: PUSH
97273: LD_VAR 0 1
97277: PUSH
97278: LD_INT 4
97280: MINUS
97281: PUSH
97282: LD_VAR 0 2
97286: PUSH
97287: LD_INT 1
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: LIST
97294: PUSH
97295: LD_VAR 0 1
97299: PUSH
97300: LD_VAR 0 2
97304: PUSH
97305: LD_INT 4
97307: MINUS
97308: PUSH
97309: LD_INT 3
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: LIST
97316: PUSH
97317: LD_VAR 0 1
97321: PUSH
97322: LD_INT 3
97324: MINUS
97325: PUSH
97326: LD_VAR 0 2
97330: PUSH
97331: LD_INT 3
97333: MINUS
97334: PUSH
97335: LD_INT 2
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: LIST
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: ST_TO_ADDR
// end ; 4 :
97350: GO 97631
97352: LD_INT 4
97354: DOUBLE
97355: EQUAL
97356: IFTRUE 97360
97358: GO 97493
97360: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
97361: LD_ADDR_VAR 0 5
97365: PUSH
97366: LD_VAR 0 1
97370: PUSH
97371: LD_VAR 0 2
97375: PUSH
97376: LD_INT 4
97378: PLUS
97379: PUSH
97380: LD_INT 0
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: LIST
97387: PUSH
97388: LD_VAR 0 1
97392: PUSH
97393: LD_INT 3
97395: PLUS
97396: PUSH
97397: LD_VAR 0 2
97401: PUSH
97402: LD_INT 3
97404: PLUS
97405: PUSH
97406: LD_INT 5
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: LIST
97413: PUSH
97414: LD_VAR 0 1
97418: PUSH
97419: LD_INT 4
97421: PLUS
97422: PUSH
97423: LD_VAR 0 2
97427: PUSH
97428: LD_INT 4
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: LIST
97435: PUSH
97436: LD_VAR 0 1
97440: PUSH
97441: LD_VAR 0 2
97445: PUSH
97446: LD_INT 3
97448: MINUS
97449: PUSH
97450: LD_INT 3
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: LIST
97457: PUSH
97458: LD_VAR 0 1
97462: PUSH
97463: LD_INT 4
97465: MINUS
97466: PUSH
97467: LD_VAR 0 2
97471: PUSH
97472: LD_INT 4
97474: MINUS
97475: PUSH
97476: LD_INT 2
97478: PUSH
97479: EMPTY
97480: LIST
97481: LIST
97482: LIST
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: ST_TO_ADDR
// end ; 5 :
97491: GO 97631
97493: LD_INT 5
97495: DOUBLE
97496: EQUAL
97497: IFTRUE 97501
97499: GO 97630
97501: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
97502: LD_ADDR_VAR 0 5
97506: PUSH
97507: LD_VAR 0 1
97511: PUSH
97512: LD_INT 4
97514: MINUS
97515: PUSH
97516: LD_VAR 0 2
97520: PUSH
97521: LD_INT 1
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: LIST
97528: PUSH
97529: LD_VAR 0 1
97533: PUSH
97534: LD_VAR 0 2
97538: PUSH
97539: LD_INT 4
97541: MINUS
97542: PUSH
97543: LD_INT 3
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: LIST
97550: PUSH
97551: LD_VAR 0 1
97555: PUSH
97556: LD_INT 4
97558: PLUS
97559: PUSH
97560: LD_VAR 0 2
97564: PUSH
97565: LD_INT 4
97567: PLUS
97568: PUSH
97569: LD_INT 5
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: LIST
97576: PUSH
97577: LD_VAR 0 1
97581: PUSH
97582: LD_INT 3
97584: PLUS
97585: PUSH
97586: LD_VAR 0 2
97590: PUSH
97591: LD_INT 4
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: LIST
97598: PUSH
97599: LD_VAR 0 1
97603: PUSH
97604: LD_VAR 0 2
97608: PUSH
97609: LD_INT 3
97611: PLUS
97612: PUSH
97613: LD_INT 0
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: LIST
97620: PUSH
97621: EMPTY
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: ST_TO_ADDR
// end ; end ;
97628: GO 97631
97630: POP
// result := list ;
97631: LD_ADDR_VAR 0 4
97635: PUSH
97636: LD_VAR 0 5
97640: ST_TO_ADDR
// end ;
97641: LD_VAR 0 4
97645: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
97646: LD_INT 0
97648: PPUSH
97649: PPUSH
97650: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
97651: LD_VAR 0 1
97655: NOT
97656: PUSH
97657: LD_VAR 0 2
97661: PUSH
97662: LD_INT 1
97664: PUSH
97665: LD_INT 2
97667: PUSH
97668: LD_INT 3
97670: PUSH
97671: LD_INT 4
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: IN
97680: NOT
97681: OR
97682: IFFALSE 97686
// exit ;
97684: GO 97778
// tmp := [ ] ;
97686: LD_ADDR_VAR 0 5
97690: PUSH
97691: EMPTY
97692: ST_TO_ADDR
// for i in units do
97693: LD_ADDR_VAR 0 4
97697: PUSH
97698: LD_VAR 0 1
97702: PUSH
97703: FOR_IN
97704: IFFALSE 97747
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
97706: LD_ADDR_VAR 0 5
97710: PUSH
97711: LD_VAR 0 5
97715: PPUSH
97716: LD_VAR 0 5
97720: PUSH
97721: LD_INT 1
97723: PLUS
97724: PPUSH
97725: LD_VAR 0 4
97729: PPUSH
97730: LD_VAR 0 2
97734: PPUSH
97735: CALL_OW 259
97739: PPUSH
97740: CALL_OW 2
97744: ST_TO_ADDR
97745: GO 97703
97747: POP
97748: POP
// if not tmp then
97749: LD_VAR 0 5
97753: NOT
97754: IFFALSE 97758
// exit ;
97756: GO 97778
// result := SortListByListDesc ( units , tmp ) ;
97758: LD_ADDR_VAR 0 3
97762: PUSH
97763: LD_VAR 0 1
97767: PPUSH
97768: LD_VAR 0 5
97772: PPUSH
97773: CALL_OW 77
97777: ST_TO_ADDR
// end ;
97778: LD_VAR 0 3
97782: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
97783: LD_INT 0
97785: PPUSH
97786: PPUSH
97787: PPUSH
// result := false ;
97788: LD_ADDR_VAR 0 3
97792: PUSH
97793: LD_INT 0
97795: ST_TO_ADDR
// x := GetX ( building ) ;
97796: LD_ADDR_VAR 0 4
97800: PUSH
97801: LD_VAR 0 2
97805: PPUSH
97806: CALL_OW 250
97810: ST_TO_ADDR
// y := GetY ( building ) ;
97811: LD_ADDR_VAR 0 5
97815: PUSH
97816: LD_VAR 0 2
97820: PPUSH
97821: CALL_OW 251
97825: ST_TO_ADDR
// if not building or not x or not y then
97826: LD_VAR 0 2
97830: NOT
97831: PUSH
97832: LD_VAR 0 4
97836: NOT
97837: OR
97838: PUSH
97839: LD_VAR 0 5
97843: NOT
97844: OR
97845: IFFALSE 97849
// exit ;
97847: GO 97941
// if GetTaskList ( unit ) then
97849: LD_VAR 0 1
97853: PPUSH
97854: CALL_OW 437
97858: IFFALSE 97941
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
97860: LD_STRING e
97862: PUSH
97863: LD_VAR 0 1
97867: PPUSH
97868: CALL_OW 437
97872: PUSH
97873: LD_INT 1
97875: ARRAY
97876: PUSH
97877: LD_INT 1
97879: ARRAY
97880: EQUAL
97881: PUSH
97882: LD_VAR 0 4
97886: PUSH
97887: LD_VAR 0 1
97891: PPUSH
97892: CALL_OW 437
97896: PUSH
97897: LD_INT 1
97899: ARRAY
97900: PUSH
97901: LD_INT 2
97903: ARRAY
97904: EQUAL
97905: AND
97906: PUSH
97907: LD_VAR 0 5
97911: PUSH
97912: LD_VAR 0 1
97916: PPUSH
97917: CALL_OW 437
97921: PUSH
97922: LD_INT 1
97924: ARRAY
97925: PUSH
97926: LD_INT 3
97928: ARRAY
97929: EQUAL
97930: AND
97931: IFFALSE 97941
// result := true end ;
97933: LD_ADDR_VAR 0 3
97937: PUSH
97938: LD_INT 1
97940: ST_TO_ADDR
// end ;
97941: LD_VAR 0 3
97945: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
97946: LD_INT 0
97948: PPUSH
// result := false ;
97949: LD_ADDR_VAR 0 4
97953: PUSH
97954: LD_INT 0
97956: ST_TO_ADDR
// if GetTaskList ( unit ) then
97957: LD_VAR 0 1
97961: PPUSH
97962: CALL_OW 437
97966: IFFALSE 98049
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
97968: LD_STRING M
97970: PUSH
97971: LD_VAR 0 1
97975: PPUSH
97976: CALL_OW 437
97980: PUSH
97981: LD_INT 1
97983: ARRAY
97984: PUSH
97985: LD_INT 1
97987: ARRAY
97988: EQUAL
97989: PUSH
97990: LD_VAR 0 2
97994: PUSH
97995: LD_VAR 0 1
97999: PPUSH
98000: CALL_OW 437
98004: PUSH
98005: LD_INT 1
98007: ARRAY
98008: PUSH
98009: LD_INT 2
98011: ARRAY
98012: EQUAL
98013: AND
98014: PUSH
98015: LD_VAR 0 3
98019: PUSH
98020: LD_VAR 0 1
98024: PPUSH
98025: CALL_OW 437
98029: PUSH
98030: LD_INT 1
98032: ARRAY
98033: PUSH
98034: LD_INT 3
98036: ARRAY
98037: EQUAL
98038: AND
98039: IFFALSE 98049
// result := true ;
98041: LD_ADDR_VAR 0 4
98045: PUSH
98046: LD_INT 1
98048: ST_TO_ADDR
// end ; end ;
98049: LD_VAR 0 4
98053: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
98054: LD_INT 0
98056: PPUSH
98057: PPUSH
98058: PPUSH
98059: PPUSH
// if not unit or not area then
98060: LD_VAR 0 1
98064: NOT
98065: PUSH
98066: LD_VAR 0 2
98070: NOT
98071: OR
98072: IFFALSE 98076
// exit ;
98074: GO 98240
// tmp := AreaToList ( area , i ) ;
98076: LD_ADDR_VAR 0 6
98080: PUSH
98081: LD_VAR 0 2
98085: PPUSH
98086: LD_VAR 0 5
98090: PPUSH
98091: CALL_OW 517
98095: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
98096: LD_ADDR_VAR 0 5
98100: PUSH
98101: DOUBLE
98102: LD_INT 1
98104: DEC
98105: ST_TO_ADDR
98106: LD_VAR 0 6
98110: PUSH
98111: LD_INT 1
98113: ARRAY
98114: PUSH
98115: FOR_TO
98116: IFFALSE 98238
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
98118: LD_ADDR_VAR 0 7
98122: PUSH
98123: LD_VAR 0 6
98127: PUSH
98128: LD_INT 1
98130: ARRAY
98131: PUSH
98132: LD_VAR 0 5
98136: ARRAY
98137: PUSH
98138: LD_VAR 0 6
98142: PUSH
98143: LD_INT 2
98145: ARRAY
98146: PUSH
98147: LD_VAR 0 5
98151: ARRAY
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
98157: LD_VAR 0 7
98161: PUSH
98162: LD_INT 1
98164: ARRAY
98165: PPUSH
98166: LD_VAR 0 7
98170: PUSH
98171: LD_INT 2
98173: ARRAY
98174: PPUSH
98175: CALL_OW 428
98179: PUSH
98180: LD_INT 0
98182: EQUAL
98183: IFFALSE 98236
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
98185: LD_VAR 0 1
98189: PPUSH
98190: LD_VAR 0 7
98194: PUSH
98195: LD_INT 1
98197: ARRAY
98198: PPUSH
98199: LD_VAR 0 7
98203: PUSH
98204: LD_INT 2
98206: ARRAY
98207: PPUSH
98208: LD_VAR 0 3
98212: PPUSH
98213: CALL_OW 48
// result := IsPlaced ( unit ) ;
98217: LD_ADDR_VAR 0 4
98221: PUSH
98222: LD_VAR 0 1
98226: PPUSH
98227: CALL_OW 305
98231: ST_TO_ADDR
// exit ;
98232: POP
98233: POP
98234: GO 98240
// end ; end ;
98236: GO 98115
98238: POP
98239: POP
// end ;
98240: LD_VAR 0 4
98244: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
98245: LD_INT 0
98247: PPUSH
98248: PPUSH
98249: PPUSH
// if not side or side > 8 then
98250: LD_VAR 0 1
98254: NOT
98255: PUSH
98256: LD_VAR 0 1
98260: PUSH
98261: LD_INT 8
98263: GREATER
98264: OR
98265: IFFALSE 98269
// exit ;
98267: GO 98456
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
98269: LD_ADDR_VAR 0 4
98273: PUSH
98274: LD_INT 22
98276: PUSH
98277: LD_VAR 0 1
98281: PUSH
98282: EMPTY
98283: LIST
98284: LIST
98285: PUSH
98286: LD_INT 21
98288: PUSH
98289: LD_INT 3
98291: PUSH
98292: EMPTY
98293: LIST
98294: LIST
98295: PUSH
98296: EMPTY
98297: LIST
98298: LIST
98299: PPUSH
98300: CALL_OW 69
98304: ST_TO_ADDR
// if not tmp then
98305: LD_VAR 0 4
98309: NOT
98310: IFFALSE 98314
// exit ;
98312: GO 98456
// enable_addtolog := true ;
98314: LD_ADDR_OWVAR 81
98318: PUSH
98319: LD_INT 1
98321: ST_TO_ADDR
// AddToLog ( [ ) ;
98322: LD_STRING [
98324: PPUSH
98325: CALL_OW 561
// for i in tmp do
98329: LD_ADDR_VAR 0 3
98333: PUSH
98334: LD_VAR 0 4
98338: PUSH
98339: FOR_IN
98340: IFFALSE 98447
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
98342: LD_STRING [
98344: PUSH
98345: LD_VAR 0 3
98349: PPUSH
98350: CALL_OW 266
98354: STR
98355: PUSH
98356: LD_STRING , 
98358: STR
98359: PUSH
98360: LD_VAR 0 3
98364: PPUSH
98365: CALL_OW 250
98369: STR
98370: PUSH
98371: LD_STRING , 
98373: STR
98374: PUSH
98375: LD_VAR 0 3
98379: PPUSH
98380: CALL_OW 251
98384: STR
98385: PUSH
98386: LD_STRING , 
98388: STR
98389: PUSH
98390: LD_VAR 0 3
98394: PPUSH
98395: CALL_OW 254
98399: STR
98400: PUSH
98401: LD_STRING , 
98403: STR
98404: PUSH
98405: LD_VAR 0 3
98409: PPUSH
98410: LD_INT 1
98412: PPUSH
98413: CALL_OW 268
98417: STR
98418: PUSH
98419: LD_STRING , 
98421: STR
98422: PUSH
98423: LD_VAR 0 3
98427: PPUSH
98428: LD_INT 2
98430: PPUSH
98431: CALL_OW 268
98435: STR
98436: PUSH
98437: LD_STRING ],
98439: STR
98440: PPUSH
98441: CALL_OW 561
// end ;
98445: GO 98339
98447: POP
98448: POP
// AddToLog ( ]; ) ;
98449: LD_STRING ];
98451: PPUSH
98452: CALL_OW 561
// end ;
98456: LD_VAR 0 2
98460: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
98461: LD_INT 0
98463: PPUSH
98464: PPUSH
98465: PPUSH
98466: PPUSH
98467: PPUSH
// if not area or not rate or not max then
98468: LD_VAR 0 1
98472: NOT
98473: PUSH
98474: LD_VAR 0 2
98478: NOT
98479: OR
98480: PUSH
98481: LD_VAR 0 4
98485: NOT
98486: OR
98487: IFFALSE 98491
// exit ;
98489: GO 98683
// while 1 do
98491: LD_INT 1
98493: IFFALSE 98683
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
98495: LD_ADDR_VAR 0 9
98499: PUSH
98500: LD_VAR 0 1
98504: PPUSH
98505: LD_INT 1
98507: PPUSH
98508: CALL_OW 287
98512: PUSH
98513: LD_INT 10
98515: MUL
98516: ST_TO_ADDR
// r := rate / 10 ;
98517: LD_ADDR_VAR 0 7
98521: PUSH
98522: LD_VAR 0 2
98526: PUSH
98527: LD_INT 10
98529: DIVREAL
98530: ST_TO_ADDR
// time := 1 1$00 ;
98531: LD_ADDR_VAR 0 8
98535: PUSH
98536: LD_INT 2100
98538: ST_TO_ADDR
// if amount < min then
98539: LD_VAR 0 9
98543: PUSH
98544: LD_VAR 0 3
98548: LESS
98549: IFFALSE 98567
// r := r * 2 else
98551: LD_ADDR_VAR 0 7
98555: PUSH
98556: LD_VAR 0 7
98560: PUSH
98561: LD_INT 2
98563: MUL
98564: ST_TO_ADDR
98565: GO 98593
// if amount > max then
98567: LD_VAR 0 9
98571: PUSH
98572: LD_VAR 0 4
98576: GREATER
98577: IFFALSE 98593
// r := r / 2 ;
98579: LD_ADDR_VAR 0 7
98583: PUSH
98584: LD_VAR 0 7
98588: PUSH
98589: LD_INT 2
98591: DIVREAL
98592: ST_TO_ADDR
// time := time / r ;
98593: LD_ADDR_VAR 0 8
98597: PUSH
98598: LD_VAR 0 8
98602: PUSH
98603: LD_VAR 0 7
98607: DIVREAL
98608: ST_TO_ADDR
// if time < 0 then
98609: LD_VAR 0 8
98613: PUSH
98614: LD_INT 0
98616: LESS
98617: IFFALSE 98634
// time := time * - 1 ;
98619: LD_ADDR_VAR 0 8
98623: PUSH
98624: LD_VAR 0 8
98628: PUSH
98629: LD_INT 1
98631: NEG
98632: MUL
98633: ST_TO_ADDR
// wait ( time ) ;
98634: LD_VAR 0 8
98638: PPUSH
98639: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
98643: LD_INT 35
98645: PPUSH
98646: LD_INT 875
98648: PPUSH
98649: CALL_OW 12
98653: PPUSH
98654: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
98658: LD_INT 1
98660: PPUSH
98661: LD_INT 5
98663: PPUSH
98664: CALL_OW 12
98668: PPUSH
98669: LD_VAR 0 1
98673: PPUSH
98674: LD_INT 1
98676: PPUSH
98677: CALL_OW 55
// end ;
98681: GO 98491
// end ;
98683: LD_VAR 0 5
98687: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
98688: LD_INT 0
98690: PPUSH
98691: PPUSH
98692: PPUSH
98693: PPUSH
98694: PPUSH
98695: PPUSH
98696: PPUSH
98697: PPUSH
// if not turrets or not factories then
98698: LD_VAR 0 1
98702: NOT
98703: PUSH
98704: LD_VAR 0 2
98708: NOT
98709: OR
98710: IFFALSE 98714
// exit ;
98712: GO 99021
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
98714: LD_ADDR_VAR 0 10
98718: PUSH
98719: LD_INT 5
98721: PUSH
98722: LD_INT 6
98724: PUSH
98725: EMPTY
98726: LIST
98727: LIST
98728: PUSH
98729: LD_INT 2
98731: PUSH
98732: LD_INT 4
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: PUSH
98739: LD_INT 3
98741: PUSH
98742: LD_INT 5
98744: PUSH
98745: EMPTY
98746: LIST
98747: LIST
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 24
98756: PUSH
98757: LD_INT 25
98759: PUSH
98760: EMPTY
98761: LIST
98762: LIST
98763: PUSH
98764: LD_INT 23
98766: PUSH
98767: LD_INT 27
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PUSH
98774: EMPTY
98775: LIST
98776: LIST
98777: PUSH
98778: LD_INT 42
98780: PUSH
98781: LD_INT 43
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: LD_INT 44
98790: PUSH
98791: LD_INT 46
98793: PUSH
98794: EMPTY
98795: LIST
98796: LIST
98797: PUSH
98798: LD_INT 45
98800: PUSH
98801: LD_INT 47
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: PUSH
98808: EMPTY
98809: LIST
98810: LIST
98811: LIST
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: LIST
98817: ST_TO_ADDR
// result := [ ] ;
98818: LD_ADDR_VAR 0 3
98822: PUSH
98823: EMPTY
98824: ST_TO_ADDR
// for i in turrets do
98825: LD_ADDR_VAR 0 4
98829: PUSH
98830: LD_VAR 0 1
98834: PUSH
98835: FOR_IN
98836: IFFALSE 99019
// begin nat := GetNation ( i ) ;
98838: LD_ADDR_VAR 0 7
98842: PUSH
98843: LD_VAR 0 4
98847: PPUSH
98848: CALL_OW 248
98852: ST_TO_ADDR
// weapon := 0 ;
98853: LD_ADDR_VAR 0 8
98857: PUSH
98858: LD_INT 0
98860: ST_TO_ADDR
// if not nat then
98861: LD_VAR 0 7
98865: NOT
98866: IFFALSE 98870
// continue ;
98868: GO 98835
// for j in list [ nat ] do
98870: LD_ADDR_VAR 0 5
98874: PUSH
98875: LD_VAR 0 10
98879: PUSH
98880: LD_VAR 0 7
98884: ARRAY
98885: PUSH
98886: FOR_IN
98887: IFFALSE 98928
// if GetBWeapon ( i ) = j [ 1 ] then
98889: LD_VAR 0 4
98893: PPUSH
98894: CALL_OW 269
98898: PUSH
98899: LD_VAR 0 5
98903: PUSH
98904: LD_INT 1
98906: ARRAY
98907: EQUAL
98908: IFFALSE 98926
// begin weapon := j [ 2 ] ;
98910: LD_ADDR_VAR 0 8
98914: PUSH
98915: LD_VAR 0 5
98919: PUSH
98920: LD_INT 2
98922: ARRAY
98923: ST_TO_ADDR
// break ;
98924: GO 98928
// end ;
98926: GO 98886
98928: POP
98929: POP
// if not weapon then
98930: LD_VAR 0 8
98934: NOT
98935: IFFALSE 98939
// continue ;
98937: GO 98835
// for k in factories do
98939: LD_ADDR_VAR 0 6
98943: PUSH
98944: LD_VAR 0 2
98948: PUSH
98949: FOR_IN
98950: IFFALSE 99015
// begin weapons := AvailableWeaponList ( k ) ;
98952: LD_ADDR_VAR 0 9
98956: PUSH
98957: LD_VAR 0 6
98961: PPUSH
98962: CALL_OW 478
98966: ST_TO_ADDR
// if not weapons then
98967: LD_VAR 0 9
98971: NOT
98972: IFFALSE 98976
// continue ;
98974: GO 98949
// if weapon in weapons then
98976: LD_VAR 0 8
98980: PUSH
98981: LD_VAR 0 9
98985: IN
98986: IFFALSE 99013
// begin result := [ i , weapon ] ;
98988: LD_ADDR_VAR 0 3
98992: PUSH
98993: LD_VAR 0 4
98997: PUSH
98998: LD_VAR 0 8
99002: PUSH
99003: EMPTY
99004: LIST
99005: LIST
99006: ST_TO_ADDR
// exit ;
99007: POP
99008: POP
99009: POP
99010: POP
99011: GO 99021
// end ; end ;
99013: GO 98949
99015: POP
99016: POP
// end ;
99017: GO 98835
99019: POP
99020: POP
// end ;
99021: LD_VAR 0 3
99025: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
99026: LD_INT 0
99028: PPUSH
// if not side or side > 8 then
99029: LD_VAR 0 3
99033: NOT
99034: PUSH
99035: LD_VAR 0 3
99039: PUSH
99040: LD_INT 8
99042: GREATER
99043: OR
99044: IFFALSE 99048
// exit ;
99046: GO 99107
// if not range then
99048: LD_VAR 0 4
99052: NOT
99053: IFFALSE 99064
// range := - 12 ;
99055: LD_ADDR_VAR 0 4
99059: PUSH
99060: LD_INT 12
99062: NEG
99063: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
99064: LD_VAR 0 1
99068: PPUSH
99069: LD_VAR 0 2
99073: PPUSH
99074: LD_VAR 0 3
99078: PPUSH
99079: LD_VAR 0 4
99083: PPUSH
99084: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
99088: LD_VAR 0 1
99092: PPUSH
99093: LD_VAR 0 2
99097: PPUSH
99098: LD_VAR 0 3
99102: PPUSH
99103: CALL_OW 331
// end ;
99107: LD_VAR 0 5
99111: RET
// export function Video ( mode ) ; begin
99112: LD_INT 0
99114: PPUSH
// ingame_video = mode ;
99115: LD_ADDR_OWVAR 52
99119: PUSH
99120: LD_VAR 0 1
99124: ST_TO_ADDR
// interface_hidden = mode ;
99125: LD_ADDR_OWVAR 54
99129: PUSH
99130: LD_VAR 0 1
99134: ST_TO_ADDR
// end ;
99135: LD_VAR 0 2
99139: RET
// export function Join ( array , element ) ; begin
99140: LD_INT 0
99142: PPUSH
// result := Replace ( array , array + 1 , element ) ;
99143: LD_ADDR_VAR 0 3
99147: PUSH
99148: LD_VAR 0 1
99152: PPUSH
99153: LD_VAR 0 1
99157: PUSH
99158: LD_INT 1
99160: PLUS
99161: PPUSH
99162: LD_VAR 0 2
99166: PPUSH
99167: CALL_OW 1
99171: ST_TO_ADDR
// end ;
99172: LD_VAR 0 3
99176: RET
// export function JoinUnion ( array , element ) ; begin
99177: LD_INT 0
99179: PPUSH
// result := array union element ;
99180: LD_ADDR_VAR 0 3
99184: PUSH
99185: LD_VAR 0 1
99189: PUSH
99190: LD_VAR 0 2
99194: UNION
99195: ST_TO_ADDR
// end ;
99196: LD_VAR 0 3
99200: RET
// export function GetBehemoths ( side ) ; begin
99201: LD_INT 0
99203: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
99204: LD_ADDR_VAR 0 2
99208: PUSH
99209: LD_INT 22
99211: PUSH
99212: LD_VAR 0 1
99216: PUSH
99217: EMPTY
99218: LIST
99219: LIST
99220: PUSH
99221: LD_INT 31
99223: PUSH
99224: LD_INT 25
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: PPUSH
99235: CALL_OW 69
99239: ST_TO_ADDR
// end ;
99240: LD_VAR 0 2
99244: RET
// export function Shuffle ( array ) ; var i , index ; begin
99245: LD_INT 0
99247: PPUSH
99248: PPUSH
99249: PPUSH
// result := [ ] ;
99250: LD_ADDR_VAR 0 2
99254: PUSH
99255: EMPTY
99256: ST_TO_ADDR
// if not array then
99257: LD_VAR 0 1
99261: NOT
99262: IFFALSE 99266
// exit ;
99264: GO 99365
// Randomize ;
99266: CALL_OW 10
// for i = array downto 1 do
99270: LD_ADDR_VAR 0 3
99274: PUSH
99275: DOUBLE
99276: LD_VAR 0 1
99280: INC
99281: ST_TO_ADDR
99282: LD_INT 1
99284: PUSH
99285: FOR_DOWNTO
99286: IFFALSE 99363
// begin index := rand ( 1 , array ) ;
99288: LD_ADDR_VAR 0 4
99292: PUSH
99293: LD_INT 1
99295: PPUSH
99296: LD_VAR 0 1
99300: PPUSH
99301: CALL_OW 12
99305: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
99306: LD_ADDR_VAR 0 2
99310: PUSH
99311: LD_VAR 0 2
99315: PPUSH
99316: LD_VAR 0 2
99320: PUSH
99321: LD_INT 1
99323: PLUS
99324: PPUSH
99325: LD_VAR 0 1
99329: PUSH
99330: LD_VAR 0 4
99334: ARRAY
99335: PPUSH
99336: CALL_OW 2
99340: ST_TO_ADDR
// array := Delete ( array , index ) ;
99341: LD_ADDR_VAR 0 1
99345: PUSH
99346: LD_VAR 0 1
99350: PPUSH
99351: LD_VAR 0 4
99355: PPUSH
99356: CALL_OW 3
99360: ST_TO_ADDR
// end ;
99361: GO 99285
99363: POP
99364: POP
// end ;
99365: LD_VAR 0 2
99369: RET
// export function GetBaseMaterials ( base ) ; begin
99370: LD_INT 0
99372: PPUSH
// result := [ 0 , 0 , 0 ] ;
99373: LD_ADDR_VAR 0 2
99377: PUSH
99378: LD_INT 0
99380: PUSH
99381: LD_INT 0
99383: PUSH
99384: LD_INT 0
99386: PUSH
99387: EMPTY
99388: LIST
99389: LIST
99390: LIST
99391: ST_TO_ADDR
// if not base then
99392: LD_VAR 0 1
99396: NOT
99397: IFFALSE 99401
// exit ;
99399: GO 99450
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
99401: LD_ADDR_VAR 0 2
99405: PUSH
99406: LD_VAR 0 1
99410: PPUSH
99411: LD_INT 1
99413: PPUSH
99414: CALL_OW 275
99418: PUSH
99419: LD_VAR 0 1
99423: PPUSH
99424: LD_INT 2
99426: PPUSH
99427: CALL_OW 275
99431: PUSH
99432: LD_VAR 0 1
99436: PPUSH
99437: LD_INT 3
99439: PPUSH
99440: CALL_OW 275
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: LIST
99449: ST_TO_ADDR
// end ;
99450: LD_VAR 0 2
99454: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
99455: LD_INT 0
99457: PPUSH
99458: PPUSH
// result := array ;
99459: LD_ADDR_VAR 0 3
99463: PUSH
99464: LD_VAR 0 1
99468: ST_TO_ADDR
// if size > 0 then
99469: LD_VAR 0 2
99473: PUSH
99474: LD_INT 0
99476: GREATER
99477: IFFALSE 99523
// for i := array downto size do
99479: LD_ADDR_VAR 0 4
99483: PUSH
99484: DOUBLE
99485: LD_VAR 0 1
99489: INC
99490: ST_TO_ADDR
99491: LD_VAR 0 2
99495: PUSH
99496: FOR_DOWNTO
99497: IFFALSE 99521
// result := Delete ( result , result ) ;
99499: LD_ADDR_VAR 0 3
99503: PUSH
99504: LD_VAR 0 3
99508: PPUSH
99509: LD_VAR 0 3
99513: PPUSH
99514: CALL_OW 3
99518: ST_TO_ADDR
99519: GO 99496
99521: POP
99522: POP
// end ;
99523: LD_VAR 0 3
99527: RET
// export function ComExit ( unit ) ; var tmp ; begin
99528: LD_INT 0
99530: PPUSH
99531: PPUSH
// if not IsInUnit ( unit ) then
99532: LD_VAR 0 1
99536: PPUSH
99537: CALL_OW 310
99541: NOT
99542: IFFALSE 99546
// exit ;
99544: GO 99606
// tmp := IsInUnit ( unit ) ;
99546: LD_ADDR_VAR 0 3
99550: PUSH
99551: LD_VAR 0 1
99555: PPUSH
99556: CALL_OW 310
99560: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
99561: LD_VAR 0 3
99565: PPUSH
99566: CALL_OW 247
99570: PUSH
99571: LD_INT 2
99573: EQUAL
99574: IFFALSE 99587
// ComExitVehicle ( unit ) else
99576: LD_VAR 0 1
99580: PPUSH
99581: CALL_OW 121
99585: GO 99596
// ComExitBuilding ( unit ) ;
99587: LD_VAR 0 1
99591: PPUSH
99592: CALL_OW 122
// result := tmp ;
99596: LD_ADDR_VAR 0 2
99600: PUSH
99601: LD_VAR 0 3
99605: ST_TO_ADDR
// end ;
99606: LD_VAR 0 2
99610: RET
// export function ComExitAll ( units ) ; var i ; begin
99611: LD_INT 0
99613: PPUSH
99614: PPUSH
// if not units then
99615: LD_VAR 0 1
99619: NOT
99620: IFFALSE 99624
// exit ;
99622: GO 99650
// for i in units do
99624: LD_ADDR_VAR 0 3
99628: PUSH
99629: LD_VAR 0 1
99633: PUSH
99634: FOR_IN
99635: IFFALSE 99648
// ComExit ( i ) ;
99637: LD_VAR 0 3
99641: PPUSH
99642: CALL 99528 0 1
99646: GO 99634
99648: POP
99649: POP
// end ;
99650: LD_VAR 0 2
99654: RET
// export function ResetHc ; begin
99655: LD_INT 0
99657: PPUSH
// InitHc ;
99658: CALL_OW 19
// hc_importance := 0 ;
99662: LD_ADDR_OWVAR 32
99666: PUSH
99667: LD_INT 0
99669: ST_TO_ADDR
// end ;
99670: LD_VAR 0 1
99674: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
99675: LD_INT 0
99677: PPUSH
99678: PPUSH
99679: PPUSH
// _x := ( x1 + x2 ) div 2 ;
99680: LD_ADDR_VAR 0 6
99684: PUSH
99685: LD_VAR 0 1
99689: PUSH
99690: LD_VAR 0 3
99694: PLUS
99695: PUSH
99696: LD_INT 2
99698: DIV
99699: ST_TO_ADDR
// if _x < 0 then
99700: LD_VAR 0 6
99704: PUSH
99705: LD_INT 0
99707: LESS
99708: IFFALSE 99725
// _x := _x * - 1 ;
99710: LD_ADDR_VAR 0 6
99714: PUSH
99715: LD_VAR 0 6
99719: PUSH
99720: LD_INT 1
99722: NEG
99723: MUL
99724: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
99725: LD_ADDR_VAR 0 7
99729: PUSH
99730: LD_VAR 0 2
99734: PUSH
99735: LD_VAR 0 4
99739: PLUS
99740: PUSH
99741: LD_INT 2
99743: DIV
99744: ST_TO_ADDR
// if _y < 0 then
99745: LD_VAR 0 7
99749: PUSH
99750: LD_INT 0
99752: LESS
99753: IFFALSE 99770
// _y := _y * - 1 ;
99755: LD_ADDR_VAR 0 7
99759: PUSH
99760: LD_VAR 0 7
99764: PUSH
99765: LD_INT 1
99767: NEG
99768: MUL
99769: ST_TO_ADDR
// result := [ _x , _y ] ;
99770: LD_ADDR_VAR 0 5
99774: PUSH
99775: LD_VAR 0 6
99779: PUSH
99780: LD_VAR 0 7
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: ST_TO_ADDR
// end ;
99789: LD_VAR 0 5
99793: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
99794: LD_INT 0
99796: PPUSH
99797: PPUSH
99798: PPUSH
99799: PPUSH
// task := GetTaskList ( unit ) ;
99800: LD_ADDR_VAR 0 7
99804: PUSH
99805: LD_VAR 0 1
99809: PPUSH
99810: CALL_OW 437
99814: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
99815: LD_VAR 0 7
99819: NOT
99820: PUSH
99821: LD_VAR 0 1
99825: PPUSH
99826: LD_VAR 0 2
99830: PPUSH
99831: CALL_OW 308
99835: NOT
99836: AND
99837: IFFALSE 99841
// exit ;
99839: GO 99959
// if IsInArea ( unit , area ) then
99841: LD_VAR 0 1
99845: PPUSH
99846: LD_VAR 0 2
99850: PPUSH
99851: CALL_OW 308
99855: IFFALSE 99873
// begin ComMoveToArea ( unit , goAway ) ;
99857: LD_VAR 0 1
99861: PPUSH
99862: LD_VAR 0 3
99866: PPUSH
99867: CALL_OW 113
// exit ;
99871: GO 99959
// end ; if task [ 1 ] [ 1 ] <> M then
99873: LD_VAR 0 7
99877: PUSH
99878: LD_INT 1
99880: ARRAY
99881: PUSH
99882: LD_INT 1
99884: ARRAY
99885: PUSH
99886: LD_STRING M
99888: NONEQUAL
99889: IFFALSE 99893
// exit ;
99891: GO 99959
// x := task [ 1 ] [ 2 ] ;
99893: LD_ADDR_VAR 0 5
99897: PUSH
99898: LD_VAR 0 7
99902: PUSH
99903: LD_INT 1
99905: ARRAY
99906: PUSH
99907: LD_INT 2
99909: ARRAY
99910: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
99911: LD_ADDR_VAR 0 6
99915: PUSH
99916: LD_VAR 0 7
99920: PUSH
99921: LD_INT 1
99923: ARRAY
99924: PUSH
99925: LD_INT 3
99927: ARRAY
99928: ST_TO_ADDR
// if InArea ( x , y , area ) then
99929: LD_VAR 0 5
99933: PPUSH
99934: LD_VAR 0 6
99938: PPUSH
99939: LD_VAR 0 2
99943: PPUSH
99944: CALL_OW 309
99948: IFFALSE 99959
// ComStop ( unit ) ;
99950: LD_VAR 0 1
99954: PPUSH
99955: CALL_OW 141
// end ;
99959: LD_VAR 0 4
99963: RET
// export function Abs ( value ) ; begin
99964: LD_INT 0
99966: PPUSH
// result := value ;
99967: LD_ADDR_VAR 0 2
99971: PUSH
99972: LD_VAR 0 1
99976: ST_TO_ADDR
// if value < 0 then
99977: LD_VAR 0 1
99981: PUSH
99982: LD_INT 0
99984: LESS
99985: IFFALSE 100002
// result := value * - 1 ;
99987: LD_ADDR_VAR 0 2
99991: PUSH
99992: LD_VAR 0 1
99996: PUSH
99997: LD_INT 1
99999: NEG
100000: MUL
100001: ST_TO_ADDR
// end ;
100002: LD_VAR 0 2
100006: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
100007: LD_INT 0
100009: PPUSH
100010: PPUSH
100011: PPUSH
100012: PPUSH
100013: PPUSH
100014: PPUSH
100015: PPUSH
100016: PPUSH
// if not unit or not building then
100017: LD_VAR 0 1
100021: NOT
100022: PUSH
100023: LD_VAR 0 2
100027: NOT
100028: OR
100029: IFFALSE 100033
// exit ;
100031: GO 100259
// x := GetX ( building ) ;
100033: LD_ADDR_VAR 0 4
100037: PUSH
100038: LD_VAR 0 2
100042: PPUSH
100043: CALL_OW 250
100047: ST_TO_ADDR
// y := GetY ( building ) ;
100048: LD_ADDR_VAR 0 6
100052: PUSH
100053: LD_VAR 0 2
100057: PPUSH
100058: CALL_OW 251
100062: ST_TO_ADDR
// d := GetDir ( building ) ;
100063: LD_ADDR_VAR 0 8
100067: PUSH
100068: LD_VAR 0 2
100072: PPUSH
100073: CALL_OW 254
100077: ST_TO_ADDR
// r := 4 ;
100078: LD_ADDR_VAR 0 9
100082: PUSH
100083: LD_INT 4
100085: ST_TO_ADDR
// for i := 1 to 5 do
100086: LD_ADDR_VAR 0 10
100090: PUSH
100091: DOUBLE
100092: LD_INT 1
100094: DEC
100095: ST_TO_ADDR
100096: LD_INT 5
100098: PUSH
100099: FOR_TO
100100: IFFALSE 100257
// begin _x := ShiftX ( x , d , r + i ) ;
100102: LD_ADDR_VAR 0 5
100106: PUSH
100107: LD_VAR 0 4
100111: PPUSH
100112: LD_VAR 0 8
100116: PPUSH
100117: LD_VAR 0 9
100121: PUSH
100122: LD_VAR 0 10
100126: PLUS
100127: PPUSH
100128: CALL_OW 272
100132: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
100133: LD_ADDR_VAR 0 7
100137: PUSH
100138: LD_VAR 0 6
100142: PPUSH
100143: LD_VAR 0 8
100147: PPUSH
100148: LD_VAR 0 9
100152: PUSH
100153: LD_VAR 0 10
100157: PLUS
100158: PPUSH
100159: CALL_OW 273
100163: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
100164: LD_VAR 0 5
100168: PPUSH
100169: LD_VAR 0 7
100173: PPUSH
100174: CALL_OW 488
100178: PUSH
100179: LD_VAR 0 5
100183: PPUSH
100184: LD_VAR 0 7
100188: PPUSH
100189: CALL_OW 428
100193: PPUSH
100194: CALL_OW 247
100198: PUSH
100199: LD_INT 3
100201: PUSH
100202: LD_INT 2
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: IN
100209: NOT
100210: AND
100211: IFFALSE 100255
// begin ComMoveXY ( unit , _x , _y ) ;
100213: LD_VAR 0 1
100217: PPUSH
100218: LD_VAR 0 5
100222: PPUSH
100223: LD_VAR 0 7
100227: PPUSH
100228: CALL_OW 111
// result := [ _x , _y ] ;
100232: LD_ADDR_VAR 0 3
100236: PUSH
100237: LD_VAR 0 5
100241: PUSH
100242: LD_VAR 0 7
100246: PUSH
100247: EMPTY
100248: LIST
100249: LIST
100250: ST_TO_ADDR
// exit ;
100251: POP
100252: POP
100253: GO 100259
// end ; end ;
100255: GO 100099
100257: POP
100258: POP
// end ;
100259: LD_VAR 0 3
100263: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
100264: LD_INT 0
100266: PPUSH
100267: PPUSH
100268: PPUSH
// result := 0 ;
100269: LD_ADDR_VAR 0 3
100273: PUSH
100274: LD_INT 0
100276: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
100277: LD_VAR 0 1
100281: PUSH
100282: LD_INT 0
100284: LESS
100285: PUSH
100286: LD_VAR 0 1
100290: PUSH
100291: LD_INT 8
100293: GREATER
100294: OR
100295: PUSH
100296: LD_VAR 0 2
100300: PUSH
100301: LD_INT 0
100303: LESS
100304: OR
100305: PUSH
100306: LD_VAR 0 2
100310: PUSH
100311: LD_INT 8
100313: GREATER
100314: OR
100315: IFFALSE 100319
// exit ;
100317: GO 100394
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
100319: LD_ADDR_VAR 0 4
100323: PUSH
100324: LD_INT 22
100326: PUSH
100327: LD_VAR 0 2
100331: PUSH
100332: EMPTY
100333: LIST
100334: LIST
100335: PPUSH
100336: CALL_OW 69
100340: PUSH
100341: FOR_IN
100342: IFFALSE 100392
// begin un := UnitShoot ( i ) ;
100344: LD_ADDR_VAR 0 5
100348: PUSH
100349: LD_VAR 0 4
100353: PPUSH
100354: CALL_OW 504
100358: ST_TO_ADDR
// if GetSide ( un ) = side1 then
100359: LD_VAR 0 5
100363: PPUSH
100364: CALL_OW 255
100368: PUSH
100369: LD_VAR 0 1
100373: EQUAL
100374: IFFALSE 100390
// begin result := un ;
100376: LD_ADDR_VAR 0 3
100380: PUSH
100381: LD_VAR 0 5
100385: ST_TO_ADDR
// exit ;
100386: POP
100387: POP
100388: GO 100394
// end ; end ;
100390: GO 100341
100392: POP
100393: POP
// end ;
100394: LD_VAR 0 3
100398: RET
// export function GetCargoBay ( units ) ; begin
100399: LD_INT 0
100401: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
100402: LD_ADDR_VAR 0 2
100406: PUSH
100407: LD_VAR 0 1
100411: PPUSH
100412: LD_INT 2
100414: PUSH
100415: LD_INT 34
100417: PUSH
100418: LD_INT 12
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: PUSH
100425: LD_INT 34
100427: PUSH
100428: LD_INT 51
100430: PUSH
100431: EMPTY
100432: LIST
100433: LIST
100434: PUSH
100435: LD_INT 34
100437: PUSH
100438: LD_INT 32
100440: PUSH
100441: EMPTY
100442: LIST
100443: LIST
100444: PUSH
100445: LD_INT 34
100447: PUSH
100448: LD_EXP 74
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: PPUSH
100464: CALL_OW 72
100468: ST_TO_ADDR
// end ;
100469: LD_VAR 0 2
100473: RET
// export function Negate ( value ) ; begin
100474: LD_INT 0
100476: PPUSH
// result := not value ;
100477: LD_ADDR_VAR 0 2
100481: PUSH
100482: LD_VAR 0 1
100486: NOT
100487: ST_TO_ADDR
// end ;
100488: LD_VAR 0 2
100492: RET
// export function Inc ( value ) ; begin
100493: LD_INT 0
100495: PPUSH
// result := value + 1 ;
100496: LD_ADDR_VAR 0 2
100500: PUSH
100501: LD_VAR 0 1
100505: PUSH
100506: LD_INT 1
100508: PLUS
100509: ST_TO_ADDR
// end ;
100510: LD_VAR 0 2
100514: RET
// export function Dec ( value ) ; begin
100515: LD_INT 0
100517: PPUSH
// result := value - 1 ;
100518: LD_ADDR_VAR 0 2
100522: PUSH
100523: LD_VAR 0 1
100527: PUSH
100528: LD_INT 1
100530: MINUS
100531: ST_TO_ADDR
// end ;
100532: LD_VAR 0 2
100536: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
100537: LD_INT 0
100539: PPUSH
100540: PPUSH
100541: PPUSH
100542: PPUSH
100543: PPUSH
100544: PPUSH
100545: PPUSH
100546: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
100547: LD_VAR 0 1
100551: PPUSH
100552: LD_VAR 0 2
100556: PPUSH
100557: CALL_OW 488
100561: NOT
100562: PUSH
100563: LD_VAR 0 3
100567: PPUSH
100568: LD_VAR 0 4
100572: PPUSH
100573: CALL_OW 488
100577: NOT
100578: OR
100579: IFFALSE 100592
// begin result := - 1 ;
100581: LD_ADDR_VAR 0 5
100585: PUSH
100586: LD_INT 1
100588: NEG
100589: ST_TO_ADDR
// exit ;
100590: GO 100827
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
100592: LD_ADDR_VAR 0 12
100596: PUSH
100597: LD_VAR 0 1
100601: PPUSH
100602: LD_VAR 0 2
100606: PPUSH
100607: LD_VAR 0 3
100611: PPUSH
100612: LD_VAR 0 4
100616: PPUSH
100617: CALL 99675 0 4
100621: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
100622: LD_ADDR_VAR 0 11
100626: PUSH
100627: LD_VAR 0 1
100631: PPUSH
100632: LD_VAR 0 2
100636: PPUSH
100637: LD_VAR 0 12
100641: PUSH
100642: LD_INT 1
100644: ARRAY
100645: PPUSH
100646: LD_VAR 0 12
100650: PUSH
100651: LD_INT 2
100653: ARRAY
100654: PPUSH
100655: CALL_OW 298
100659: ST_TO_ADDR
// distance := 9999 ;
100660: LD_ADDR_VAR 0 10
100664: PUSH
100665: LD_INT 9999
100667: ST_TO_ADDR
// for i := 0 to 5 do
100668: LD_ADDR_VAR 0 6
100672: PUSH
100673: DOUBLE
100674: LD_INT 0
100676: DEC
100677: ST_TO_ADDR
100678: LD_INT 5
100680: PUSH
100681: FOR_TO
100682: IFFALSE 100825
// begin _x := ShiftX ( x1 , i , centerDist ) ;
100684: LD_ADDR_VAR 0 7
100688: PUSH
100689: LD_VAR 0 1
100693: PPUSH
100694: LD_VAR 0 6
100698: PPUSH
100699: LD_VAR 0 11
100703: PPUSH
100704: CALL_OW 272
100708: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
100709: LD_ADDR_VAR 0 8
100713: PUSH
100714: LD_VAR 0 2
100718: PPUSH
100719: LD_VAR 0 6
100723: PPUSH
100724: LD_VAR 0 11
100728: PPUSH
100729: CALL_OW 273
100733: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
100734: LD_VAR 0 7
100738: PPUSH
100739: LD_VAR 0 8
100743: PPUSH
100744: CALL_OW 488
100748: NOT
100749: IFFALSE 100753
// continue ;
100751: GO 100681
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
100753: LD_ADDR_VAR 0 9
100757: PUSH
100758: LD_VAR 0 12
100762: PUSH
100763: LD_INT 1
100765: ARRAY
100766: PPUSH
100767: LD_VAR 0 12
100771: PUSH
100772: LD_INT 2
100774: ARRAY
100775: PPUSH
100776: LD_VAR 0 7
100780: PPUSH
100781: LD_VAR 0 8
100785: PPUSH
100786: CALL_OW 298
100790: ST_TO_ADDR
// if tmp < distance then
100791: LD_VAR 0 9
100795: PUSH
100796: LD_VAR 0 10
100800: LESS
100801: IFFALSE 100823
// begin result := i ;
100803: LD_ADDR_VAR 0 5
100807: PUSH
100808: LD_VAR 0 6
100812: ST_TO_ADDR
// distance := tmp ;
100813: LD_ADDR_VAR 0 10
100817: PUSH
100818: LD_VAR 0 9
100822: ST_TO_ADDR
// end ; end ;
100823: GO 100681
100825: POP
100826: POP
// end ;
100827: LD_VAR 0 5
100831: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
100832: LD_INT 0
100834: PPUSH
100835: PPUSH
// if not driver or not IsInUnit ( driver ) then
100836: LD_VAR 0 1
100840: NOT
100841: PUSH
100842: LD_VAR 0 1
100846: PPUSH
100847: CALL_OW 310
100851: NOT
100852: OR
100853: IFFALSE 100857
// exit ;
100855: GO 100947
// vehicle := IsInUnit ( driver ) ;
100857: LD_ADDR_VAR 0 3
100861: PUSH
100862: LD_VAR 0 1
100866: PPUSH
100867: CALL_OW 310
100871: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
100872: LD_VAR 0 1
100876: PPUSH
100877: LD_STRING \
100879: PUSH
100880: LD_INT 0
100882: PUSH
100883: LD_INT 0
100885: PUSH
100886: LD_INT 0
100888: PUSH
100889: LD_INT 0
100891: PUSH
100892: LD_INT 0
100894: PUSH
100895: LD_INT 0
100897: PUSH
100898: EMPTY
100899: LIST
100900: LIST
100901: LIST
100902: LIST
100903: LIST
100904: LIST
100905: LIST
100906: PUSH
100907: LD_STRING E
100909: PUSH
100910: LD_INT 0
100912: PUSH
100913: LD_INT 0
100915: PUSH
100916: LD_VAR 0 3
100920: PUSH
100921: LD_INT 0
100923: PUSH
100924: LD_INT 0
100926: PUSH
100927: LD_INT 0
100929: PUSH
100930: EMPTY
100931: LIST
100932: LIST
100933: LIST
100934: LIST
100935: LIST
100936: LIST
100937: LIST
100938: PUSH
100939: EMPTY
100940: LIST
100941: LIST
100942: PPUSH
100943: CALL_OW 446
// end ;
100947: LD_VAR 0 2
100951: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
100952: LD_INT 0
100954: PPUSH
100955: PPUSH
// if not driver or not IsInUnit ( driver ) then
100956: LD_VAR 0 1
100960: NOT
100961: PUSH
100962: LD_VAR 0 1
100966: PPUSH
100967: CALL_OW 310
100971: NOT
100972: OR
100973: IFFALSE 100977
// exit ;
100975: GO 101067
// vehicle := IsInUnit ( driver ) ;
100977: LD_ADDR_VAR 0 3
100981: PUSH
100982: LD_VAR 0 1
100986: PPUSH
100987: CALL_OW 310
100991: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
100992: LD_VAR 0 1
100996: PPUSH
100997: LD_STRING \
100999: PUSH
101000: LD_INT 0
101002: PUSH
101003: LD_INT 0
101005: PUSH
101006: LD_INT 0
101008: PUSH
101009: LD_INT 0
101011: PUSH
101012: LD_INT 0
101014: PUSH
101015: LD_INT 0
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: PUSH
101027: LD_STRING E
101029: PUSH
101030: LD_INT 0
101032: PUSH
101033: LD_INT 0
101035: PUSH
101036: LD_VAR 0 3
101040: PUSH
101041: LD_INT 0
101043: PUSH
101044: LD_INT 0
101046: PUSH
101047: LD_INT 0
101049: PUSH
101050: EMPTY
101051: LIST
101052: LIST
101053: LIST
101054: LIST
101055: LIST
101056: LIST
101057: LIST
101058: PUSH
101059: EMPTY
101060: LIST
101061: LIST
101062: PPUSH
101063: CALL_OW 447
// end ;
101067: LD_VAR 0 2
101071: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
101072: LD_INT 0
101074: PPUSH
101075: PPUSH
101076: PPUSH
// tmp := [ ] ;
101077: LD_ADDR_VAR 0 5
101081: PUSH
101082: EMPTY
101083: ST_TO_ADDR
// for i in units do
101084: LD_ADDR_VAR 0 4
101088: PUSH
101089: LD_VAR 0 1
101093: PUSH
101094: FOR_IN
101095: IFFALSE 101133
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
101097: LD_ADDR_VAR 0 5
101101: PUSH
101102: LD_VAR 0 5
101106: PPUSH
101107: LD_VAR 0 5
101111: PUSH
101112: LD_INT 1
101114: PLUS
101115: PPUSH
101116: LD_VAR 0 4
101120: PPUSH
101121: CALL_OW 256
101125: PPUSH
101126: CALL_OW 2
101130: ST_TO_ADDR
101131: GO 101094
101133: POP
101134: POP
// if not tmp then
101135: LD_VAR 0 5
101139: NOT
101140: IFFALSE 101144
// exit ;
101142: GO 101192
// if asc then
101144: LD_VAR 0 2
101148: IFFALSE 101172
// result := SortListByListAsc ( units , tmp ) else
101150: LD_ADDR_VAR 0 3
101154: PUSH
101155: LD_VAR 0 1
101159: PPUSH
101160: LD_VAR 0 5
101164: PPUSH
101165: CALL_OW 76
101169: ST_TO_ADDR
101170: GO 101192
// result := SortListByListDesc ( units , tmp ) ;
101172: LD_ADDR_VAR 0 3
101176: PUSH
101177: LD_VAR 0 1
101181: PPUSH
101182: LD_VAR 0 5
101186: PPUSH
101187: CALL_OW 77
101191: ST_TO_ADDR
// end ;
101192: LD_VAR 0 3
101196: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
101197: LD_INT 0
101199: PPUSH
101200: PPUSH
// task := GetTaskList ( mech ) ;
101201: LD_ADDR_VAR 0 4
101205: PUSH
101206: LD_VAR 0 1
101210: PPUSH
101211: CALL_OW 437
101215: ST_TO_ADDR
// if not task then
101216: LD_VAR 0 4
101220: NOT
101221: IFFALSE 101225
// exit ;
101223: GO 101267
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
101225: LD_ADDR_VAR 0 3
101229: PUSH
101230: LD_VAR 0 4
101234: PUSH
101235: LD_INT 1
101237: ARRAY
101238: PUSH
101239: LD_INT 1
101241: ARRAY
101242: PUSH
101243: LD_STRING r
101245: EQUAL
101246: PUSH
101247: LD_VAR 0 4
101251: PUSH
101252: LD_INT 1
101254: ARRAY
101255: PUSH
101256: LD_INT 4
101258: ARRAY
101259: PUSH
101260: LD_VAR 0 2
101264: EQUAL
101265: AND
101266: ST_TO_ADDR
// end ;
101267: LD_VAR 0 3
101271: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
101272: LD_INT 0
101274: PPUSH
// SetDir ( unit , d ) ;
101275: LD_VAR 0 1
101279: PPUSH
101280: LD_VAR 0 4
101284: PPUSH
101285: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
101289: LD_VAR 0 1
101293: PPUSH
101294: LD_VAR 0 2
101298: PPUSH
101299: LD_VAR 0 3
101303: PPUSH
101304: LD_VAR 0 5
101308: PPUSH
101309: CALL_OW 48
// end ;
101313: LD_VAR 0 6
101317: RET
// export function ToNaturalNumber ( number ) ; begin
101318: LD_INT 0
101320: PPUSH
// result := number div 1 ;
101321: LD_ADDR_VAR 0 2
101325: PUSH
101326: LD_VAR 0 1
101330: PUSH
101331: LD_INT 1
101333: DIV
101334: ST_TO_ADDR
// if number < 0 then
101335: LD_VAR 0 1
101339: PUSH
101340: LD_INT 0
101342: LESS
101343: IFFALSE 101353
// result := 0 ;
101345: LD_ADDR_VAR 0 2
101349: PUSH
101350: LD_INT 0
101352: ST_TO_ADDR
// end ;
101353: LD_VAR 0 2
101357: RET
// export function SortByClass ( units , class ) ; var un ; begin
101358: LD_INT 0
101360: PPUSH
101361: PPUSH
// if not units or not class then
101362: LD_VAR 0 1
101366: NOT
101367: PUSH
101368: LD_VAR 0 2
101372: NOT
101373: OR
101374: IFFALSE 101378
// exit ;
101376: GO 101473
// result := [ ] ;
101378: LD_ADDR_VAR 0 3
101382: PUSH
101383: EMPTY
101384: ST_TO_ADDR
// for un in units do
101385: LD_ADDR_VAR 0 4
101389: PUSH
101390: LD_VAR 0 1
101394: PUSH
101395: FOR_IN
101396: IFFALSE 101471
// if GetClass ( un ) = class then
101398: LD_VAR 0 4
101402: PPUSH
101403: CALL_OW 257
101407: PUSH
101408: LD_VAR 0 2
101412: EQUAL
101413: IFFALSE 101440
// result := Insert ( result , 1 , un ) else
101415: LD_ADDR_VAR 0 3
101419: PUSH
101420: LD_VAR 0 3
101424: PPUSH
101425: LD_INT 1
101427: PPUSH
101428: LD_VAR 0 4
101432: PPUSH
101433: CALL_OW 2
101437: ST_TO_ADDR
101438: GO 101469
// result := Replace ( result , result + 1 , un ) ;
101440: LD_ADDR_VAR 0 3
101444: PUSH
101445: LD_VAR 0 3
101449: PPUSH
101450: LD_VAR 0 3
101454: PUSH
101455: LD_INT 1
101457: PLUS
101458: PPUSH
101459: LD_VAR 0 4
101463: PPUSH
101464: CALL_OW 1
101468: ST_TO_ADDR
101469: GO 101395
101471: POP
101472: POP
// end ;
101473: LD_VAR 0 3
101477: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
101478: LD_INT 0
101480: PPUSH
101481: PPUSH
101482: PPUSH
101483: PPUSH
101484: PPUSH
101485: PPUSH
101486: PPUSH
// result := [ ] ;
101487: LD_ADDR_VAR 0 4
101491: PUSH
101492: EMPTY
101493: ST_TO_ADDR
// if x - r < 0 then
101494: LD_VAR 0 1
101498: PUSH
101499: LD_VAR 0 3
101503: MINUS
101504: PUSH
101505: LD_INT 0
101507: LESS
101508: IFFALSE 101520
// min_x := 0 else
101510: LD_ADDR_VAR 0 8
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
101518: GO 101536
// min_x := x - r ;
101520: LD_ADDR_VAR 0 8
101524: PUSH
101525: LD_VAR 0 1
101529: PUSH
101530: LD_VAR 0 3
101534: MINUS
101535: ST_TO_ADDR
// if y - r < 0 then
101536: LD_VAR 0 2
101540: PUSH
101541: LD_VAR 0 3
101545: MINUS
101546: PUSH
101547: LD_INT 0
101549: LESS
101550: IFFALSE 101562
// min_y := 0 else
101552: LD_ADDR_VAR 0 7
101556: PUSH
101557: LD_INT 0
101559: ST_TO_ADDR
101560: GO 101578
// min_y := y - r ;
101562: LD_ADDR_VAR 0 7
101566: PUSH
101567: LD_VAR 0 2
101571: PUSH
101572: LD_VAR 0 3
101576: MINUS
101577: ST_TO_ADDR
// max_x := x + r ;
101578: LD_ADDR_VAR 0 9
101582: PUSH
101583: LD_VAR 0 1
101587: PUSH
101588: LD_VAR 0 3
101592: PLUS
101593: ST_TO_ADDR
// max_y := y + r ;
101594: LD_ADDR_VAR 0 10
101598: PUSH
101599: LD_VAR 0 2
101603: PUSH
101604: LD_VAR 0 3
101608: PLUS
101609: ST_TO_ADDR
// for _x = min_x to max_x do
101610: LD_ADDR_VAR 0 5
101614: PUSH
101615: DOUBLE
101616: LD_VAR 0 8
101620: DEC
101621: ST_TO_ADDR
101622: LD_VAR 0 9
101626: PUSH
101627: FOR_TO
101628: IFFALSE 101729
// for _y = min_y to max_y do
101630: LD_ADDR_VAR 0 6
101634: PUSH
101635: DOUBLE
101636: LD_VAR 0 7
101640: DEC
101641: ST_TO_ADDR
101642: LD_VAR 0 10
101646: PUSH
101647: FOR_TO
101648: IFFALSE 101725
// begin if not ValidHex ( _x , _y ) then
101650: LD_VAR 0 5
101654: PPUSH
101655: LD_VAR 0 6
101659: PPUSH
101660: CALL_OW 488
101664: NOT
101665: IFFALSE 101669
// continue ;
101667: GO 101647
// if GetResourceTypeXY ( _x , _y ) then
101669: LD_VAR 0 5
101673: PPUSH
101674: LD_VAR 0 6
101678: PPUSH
101679: CALL_OW 283
101683: IFFALSE 101723
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
101685: LD_ADDR_VAR 0 4
101689: PUSH
101690: LD_VAR 0 4
101694: PPUSH
101695: LD_VAR 0 4
101699: PUSH
101700: LD_INT 1
101702: PLUS
101703: PPUSH
101704: LD_VAR 0 5
101708: PUSH
101709: LD_VAR 0 6
101713: PUSH
101714: EMPTY
101715: LIST
101716: LIST
101717: PPUSH
101718: CALL_OW 1
101722: ST_TO_ADDR
// end ;
101723: GO 101647
101725: POP
101726: POP
101727: GO 101627
101729: POP
101730: POP
// end ;
101731: LD_VAR 0 4
101735: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
101736: LD_INT 0
101738: PPUSH
101739: PPUSH
101740: PPUSH
101741: PPUSH
101742: PPUSH
101743: PPUSH
101744: PPUSH
101745: PPUSH
// if not units then
101746: LD_VAR 0 1
101750: NOT
101751: IFFALSE 101755
// exit ;
101753: GO 102180
// result := UnitFilter ( units , [ f_ok ] ) ;
101755: LD_ADDR_VAR 0 3
101759: PUSH
101760: LD_VAR 0 1
101764: PPUSH
101765: LD_INT 50
101767: PUSH
101768: EMPTY
101769: LIST
101770: PPUSH
101771: CALL_OW 72
101775: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
101776: LD_ADDR_VAR 0 8
101780: PUSH
101781: LD_VAR 0 1
101785: PUSH
101786: LD_INT 1
101788: ARRAY
101789: PPUSH
101790: CALL_OW 255
101794: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
101795: LD_ADDR_VAR 0 10
101799: PUSH
101800: LD_INT 29
101802: PUSH
101803: LD_EXP 77
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: ST_TO_ADDR
// if not result then
101812: LD_VAR 0 3
101816: NOT
101817: IFFALSE 101821
// exit ;
101819: GO 102180
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
101821: LD_ADDR_VAR 0 5
101825: PUSH
101826: LD_INT 81
101828: PUSH
101829: LD_VAR 0 8
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PPUSH
101838: CALL_OW 69
101842: ST_TO_ADDR
// for i in result do
101843: LD_ADDR_VAR 0 4
101847: PUSH
101848: LD_VAR 0 3
101852: PUSH
101853: FOR_IN
101854: IFFALSE 102178
// begin tag := GetTag ( i ) + 1 ;
101856: LD_ADDR_VAR 0 9
101860: PUSH
101861: LD_VAR 0 4
101865: PPUSH
101866: CALL_OW 110
101870: PUSH
101871: LD_INT 1
101873: PLUS
101874: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
101875: LD_ADDR_VAR 0 7
101879: PUSH
101880: LD_VAR 0 4
101884: PPUSH
101885: CALL_OW 250
101889: PPUSH
101890: LD_VAR 0 4
101894: PPUSH
101895: CALL_OW 251
101899: PPUSH
101900: LD_INT 6
101902: PPUSH
101903: CALL 101478 0 3
101907: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
101908: LD_VAR 0 7
101912: PUSH
101913: LD_VAR 0 4
101917: PPUSH
101918: CALL_OW 264
101922: PUSH
101923: LD_VAR 0 10
101927: IN
101928: NOT
101929: AND
101930: IFFALSE 101969
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
101932: LD_VAR 0 4
101936: PPUSH
101937: LD_VAR 0 7
101941: PUSH
101942: LD_INT 1
101944: ARRAY
101945: PUSH
101946: LD_INT 1
101948: ARRAY
101949: PPUSH
101950: LD_VAR 0 7
101954: PUSH
101955: LD_INT 1
101957: ARRAY
101958: PUSH
101959: LD_INT 2
101961: ARRAY
101962: PPUSH
101963: CALL_OW 116
101967: GO 102176
// if path > tag then
101969: LD_VAR 0 2
101973: PUSH
101974: LD_VAR 0 9
101978: GREATER
101979: IFFALSE 102146
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
101981: LD_ADDR_VAR 0 6
101985: PUSH
101986: LD_VAR 0 5
101990: PPUSH
101991: LD_INT 91
101993: PUSH
101994: LD_VAR 0 4
101998: PUSH
101999: LD_INT 12
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: LIST
102006: PPUSH
102007: CALL_OW 72
102011: ST_TO_ADDR
// if nearEnemy then
102012: LD_VAR 0 6
102016: IFFALSE 102044
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
102018: LD_VAR 0 4
102022: PPUSH
102023: LD_VAR 0 6
102027: PPUSH
102028: LD_VAR 0 4
102032: PPUSH
102033: CALL_OW 74
102037: PPUSH
102038: CALL_OW 115
102042: GO 102144
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
102044: LD_VAR 0 4
102048: PPUSH
102049: LD_VAR 0 2
102053: PUSH
102054: LD_VAR 0 9
102058: ARRAY
102059: PUSH
102060: LD_INT 1
102062: ARRAY
102063: PPUSH
102064: LD_VAR 0 2
102068: PUSH
102069: LD_VAR 0 9
102073: ARRAY
102074: PUSH
102075: LD_INT 2
102077: ARRAY
102078: PPUSH
102079: CALL_OW 297
102083: PUSH
102084: LD_INT 6
102086: GREATER
102087: IFFALSE 102130
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
102089: LD_VAR 0 4
102093: PPUSH
102094: LD_VAR 0 2
102098: PUSH
102099: LD_VAR 0 9
102103: ARRAY
102104: PUSH
102105: LD_INT 1
102107: ARRAY
102108: PPUSH
102109: LD_VAR 0 2
102113: PUSH
102114: LD_VAR 0 9
102118: ARRAY
102119: PUSH
102120: LD_INT 2
102122: ARRAY
102123: PPUSH
102124: CALL_OW 114
102128: GO 102144
// SetTag ( i , tag ) ;
102130: LD_VAR 0 4
102134: PPUSH
102135: LD_VAR 0 9
102139: PPUSH
102140: CALL_OW 109
// end else
102144: GO 102176
// if enemy then
102146: LD_VAR 0 5
102150: IFFALSE 102176
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
102152: LD_VAR 0 4
102156: PPUSH
102157: LD_VAR 0 5
102161: PPUSH
102162: LD_VAR 0 4
102166: PPUSH
102167: CALL_OW 74
102171: PPUSH
102172: CALL_OW 115
// end ;
102176: GO 101853
102178: POP
102179: POP
// end ;
102180: LD_VAR 0 3
102184: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
102185: LD_INT 0
102187: PPUSH
102188: PPUSH
102189: PPUSH
// if not unit or IsInUnit ( unit ) then
102190: LD_VAR 0 1
102194: NOT
102195: PUSH
102196: LD_VAR 0 1
102200: PPUSH
102201: CALL_OW 310
102205: OR
102206: IFFALSE 102210
// exit ;
102208: GO 102301
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
102210: LD_ADDR_VAR 0 4
102214: PUSH
102215: LD_VAR 0 1
102219: PPUSH
102220: CALL_OW 250
102224: PPUSH
102225: LD_VAR 0 2
102229: PPUSH
102230: LD_INT 1
102232: PPUSH
102233: CALL_OW 272
102237: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
102238: LD_ADDR_VAR 0 5
102242: PUSH
102243: LD_VAR 0 1
102247: PPUSH
102248: CALL_OW 251
102252: PPUSH
102253: LD_VAR 0 2
102257: PPUSH
102258: LD_INT 1
102260: PPUSH
102261: CALL_OW 273
102265: ST_TO_ADDR
// if ValidHex ( x , y ) then
102266: LD_VAR 0 4
102270: PPUSH
102271: LD_VAR 0 5
102275: PPUSH
102276: CALL_OW 488
102280: IFFALSE 102301
// ComTurnXY ( unit , x , y ) ;
102282: LD_VAR 0 1
102286: PPUSH
102287: LD_VAR 0 4
102291: PPUSH
102292: LD_VAR 0 5
102296: PPUSH
102297: CALL_OW 118
// end ;
102301: LD_VAR 0 3
102305: RET
// export function SeeUnits ( side , units ) ; var i ; begin
102306: LD_INT 0
102308: PPUSH
102309: PPUSH
// result := false ;
102310: LD_ADDR_VAR 0 3
102314: PUSH
102315: LD_INT 0
102317: ST_TO_ADDR
// if not units then
102318: LD_VAR 0 2
102322: NOT
102323: IFFALSE 102327
// exit ;
102325: GO 102372
// for i in units do
102327: LD_ADDR_VAR 0 4
102331: PUSH
102332: LD_VAR 0 2
102336: PUSH
102337: FOR_IN
102338: IFFALSE 102370
// if See ( side , i ) then
102340: LD_VAR 0 1
102344: PPUSH
102345: LD_VAR 0 4
102349: PPUSH
102350: CALL_OW 292
102354: IFFALSE 102368
// begin result := true ;
102356: LD_ADDR_VAR 0 3
102360: PUSH
102361: LD_INT 1
102363: ST_TO_ADDR
// exit ;
102364: POP
102365: POP
102366: GO 102372
// end ;
102368: GO 102337
102370: POP
102371: POP
// end ;
102372: LD_VAR 0 3
102376: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
102377: LD_INT 0
102379: PPUSH
102380: PPUSH
102381: PPUSH
102382: PPUSH
// if not unit or not points then
102383: LD_VAR 0 1
102387: NOT
102388: PUSH
102389: LD_VAR 0 2
102393: NOT
102394: OR
102395: IFFALSE 102399
// exit ;
102397: GO 102489
// dist := 99999 ;
102399: LD_ADDR_VAR 0 5
102403: PUSH
102404: LD_INT 99999
102406: ST_TO_ADDR
// for i in points do
102407: LD_ADDR_VAR 0 4
102411: PUSH
102412: LD_VAR 0 2
102416: PUSH
102417: FOR_IN
102418: IFFALSE 102487
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
102420: LD_ADDR_VAR 0 6
102424: PUSH
102425: LD_VAR 0 1
102429: PPUSH
102430: LD_VAR 0 4
102434: PUSH
102435: LD_INT 1
102437: ARRAY
102438: PPUSH
102439: LD_VAR 0 4
102443: PUSH
102444: LD_INT 2
102446: ARRAY
102447: PPUSH
102448: CALL_OW 297
102452: ST_TO_ADDR
// if tmpDist < dist then
102453: LD_VAR 0 6
102457: PUSH
102458: LD_VAR 0 5
102462: LESS
102463: IFFALSE 102485
// begin result := i ;
102465: LD_ADDR_VAR 0 3
102469: PUSH
102470: LD_VAR 0 4
102474: ST_TO_ADDR
// dist := tmpDist ;
102475: LD_ADDR_VAR 0 5
102479: PUSH
102480: LD_VAR 0 6
102484: ST_TO_ADDR
// end ; end ;
102485: GO 102417
102487: POP
102488: POP
// end ; end_of_file
102489: LD_VAR 0 3
102493: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
102494: LD_VAR 0 1
102498: PUSH
102499: LD_INT 200
102501: DOUBLE
102502: GREATEREQUAL
102503: IFFALSE 102511
102505: LD_INT 299
102507: DOUBLE
102508: LESSEQUAL
102509: IFTRUE 102513
102511: GO 102545
102513: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
102514: LD_VAR 0 1
102518: PPUSH
102519: LD_VAR 0 2
102523: PPUSH
102524: LD_VAR 0 3
102528: PPUSH
102529: LD_VAR 0 4
102533: PPUSH
102534: LD_VAR 0 5
102538: PPUSH
102539: CALL 58141 0 5
102543: GO 102622
102545: LD_INT 300
102547: DOUBLE
102548: GREATEREQUAL
102549: IFFALSE 102557
102551: LD_INT 399
102553: DOUBLE
102554: LESSEQUAL
102555: IFTRUE 102559
102557: GO 102621
102559: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
102560: LD_VAR 0 1
102564: PPUSH
102565: LD_VAR 0 2
102569: PPUSH
102570: LD_VAR 0 3
102574: PPUSH
102575: LD_VAR 0 4
102579: PPUSH
102580: LD_VAR 0 5
102584: PPUSH
102585: LD_VAR 0 6
102589: PPUSH
102590: LD_VAR 0 7
102594: PPUSH
102595: LD_VAR 0 8
102599: PPUSH
102600: LD_VAR 0 9
102604: PPUSH
102605: LD_VAR 0 10
102609: PPUSH
102610: LD_VAR 0 11
102614: PPUSH
102615: CALL 55783 0 11
102619: GO 102622
102621: POP
// end ;
102622: PPOPN 11
102624: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
102625: LD_VAR 0 1
102629: PPUSH
102630: LD_VAR 0 2
102634: PPUSH
102635: LD_VAR 0 3
102639: PPUSH
102640: LD_VAR 0 4
102644: PPUSH
102645: LD_VAR 0 5
102649: PPUSH
102650: CALL 57877 0 5
// end ; end_of_file
102654: PPOPN 5
102656: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
102657: LD_VAR 0 1
102661: PPUSH
102662: LD_VAR 0 2
102666: PPUSH
102667: LD_VAR 0 3
102671: PPUSH
102672: LD_VAR 0 4
102676: PPUSH
102677: LD_VAR 0 5
102681: PPUSH
102682: LD_VAR 0 6
102686: PPUSH
102687: CALL 43476 0 6
// end ;
102691: PPOPN 6
102693: END
