// starting begin InitSettings ;
   0: CALL 2932 0 0
// InitGame ;
   4: CALL 2970 0 0
// InitDisplay ;
   8: CALL 9509 0 0
// end ; end_of_file
  12: END
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
  18: PPUSH
// if pos < 1 then
  19: LD_VAR 0 2
  23: PUSH
  24: LD_INT 1
  26: LESS
  27: IFFALSE 31
// exit ;
  29: GO 334
// if pos = 1 then
  31: LD_VAR 0 2
  35: PUSH
  36: LD_INT 1
  38: EQUAL
  39: IFFALSE 72
// result := Replace ( arr , pos [ 1 ] , value ) else
  41: LD_ADDR_VAR 0 4
  45: PUSH
  46: LD_VAR 0 1
  50: PPUSH
  51: LD_VAR 0 2
  55: PUSH
  56: LD_INT 1
  58: ARRAY
  59: PPUSH
  60: LD_VAR 0 3
  64: PPUSH
  65: CALL_OW 1
  69: ST_TO_ADDR
  70: GO 334
// begin tmp := arr ;
  72: LD_ADDR_VAR 0 6
  76: PUSH
  77: LD_VAR 0 1
  81: ST_TO_ADDR
// s_arr := [ tmp ] ;
  82: LD_ADDR_VAR 0 7
  86: PUSH
  87: LD_VAR 0 6
  91: PUSH
  92: EMPTY
  93: LIST
  94: ST_TO_ADDR
// for i = 1 to pos - 1 do
  95: LD_ADDR_VAR 0 5
  99: PUSH
 100: DOUBLE
 101: LD_INT 1
 103: DEC
 104: ST_TO_ADDR
 105: LD_VAR 0 2
 109: PUSH
 110: LD_INT 1
 112: MINUS
 113: PUSH
 114: FOR_TO
 115: IFFALSE 160
// begin tmp := tmp [ pos [ i ] ] ;
 117: LD_ADDR_VAR 0 6
 121: PUSH
 122: LD_VAR 0 6
 126: PUSH
 127: LD_VAR 0 2
 131: PUSH
 132: LD_VAR 0 5
 136: ARRAY
 137: ARRAY
 138: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
 139: LD_ADDR_VAR 0 7
 143: PUSH
 144: LD_VAR 0 7
 148: PUSH
 149: LD_VAR 0 6
 153: PUSH
 154: EMPTY
 155: LIST
 156: ADD
 157: ST_TO_ADDR
// end ;
 158: GO 114
 160: POP
 161: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
 162: LD_ADDR_VAR 0 6
 166: PUSH
 167: LD_VAR 0 6
 171: PPUSH
 172: LD_VAR 0 2
 176: PUSH
 177: LD_VAR 0 2
 181: ARRAY
 182: PPUSH
 183: LD_VAR 0 3
 187: PPUSH
 188: CALL_OW 1
 192: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
 193: LD_ADDR_VAR 0 7
 197: PUSH
 198: LD_VAR 0 7
 202: PPUSH
 203: LD_VAR 0 7
 207: PPUSH
 208: LD_VAR 0 6
 212: PPUSH
 213: CALL_OW 1
 217: ST_TO_ADDR
// for i = s_arr downto 2 do
 218: LD_ADDR_VAR 0 5
 222: PUSH
 223: DOUBLE
 224: LD_VAR 0 7
 228: INC
 229: ST_TO_ADDR
 230: LD_INT 2
 232: PUSH
 233: FOR_DOWNTO
 234: IFFALSE 318
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: LD_VAR 0 7
 245: PUSH
 246: LD_VAR 0 5
 250: PUSH
 251: LD_INT 1
 253: MINUS
 254: ARRAY
 255: PPUSH
 256: LD_VAR 0 2
 260: PUSH
 261: LD_VAR 0 5
 265: PUSH
 266: LD_INT 1
 268: MINUS
 269: ARRAY
 270: PPUSH
 271: LD_VAR 0 7
 275: PUSH
 276: LD_VAR 0 5
 280: ARRAY
 281: PPUSH
 282: CALL_OW 1
 286: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
 287: LD_ADDR_VAR 0 7
 291: PUSH
 292: LD_VAR 0 7
 296: PPUSH
 297: LD_VAR 0 5
 301: PUSH
 302: LD_INT 1
 304: MINUS
 305: PPUSH
 306: LD_VAR 0 6
 310: PPUSH
 311: CALL_OW 1
 315: ST_TO_ADDR
// end ;
 316: GO 233
 318: POP
 319: POP
// result := s_arr [ 1 ] ;
 320: LD_ADDR_VAR 0 4
 324: PUSH
 325: LD_VAR 0 7
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: ST_TO_ADDR
// end ; end ;
 334: LD_VAR 0 4
 338: RET
// export function PrepareSquad ( nation , skill , num , x , y ) ; var i , team , c ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// team := [ ] ;
 345: LD_ADDR_VAR 0 8
 349: PUSH
 350: EMPTY
 351: ST_TO_ADDR
// playerSquad := [ ] ;
 352: LD_ADDR_EXP 12
 356: PUSH
 357: EMPTY
 358: ST_TO_ADDR
// uc_side := nation ;
 359: LD_ADDR_OWVAR 20
 363: PUSH
 364: LD_VAR 0 1
 368: ST_TO_ADDR
// uc_nation := nation ;
 369: LD_ADDR_OWVAR 21
 373: PUSH
 374: LD_VAR 0 1
 378: ST_TO_ADDR
// hc_importance := 100 ;
 379: LD_ADDR_OWVAR 32
 383: PUSH
 384: LD_INT 100
 386: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 387: LD_INT 0
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: LD_VAR 0 2
 397: PPUSH
 398: CALL_OW 380
// team := Insert ( team , 1 , CreateHuman ) ;
 402: LD_ADDR_VAR 0 8
 406: PUSH
 407: LD_VAR 0 8
 411: PPUSH
 412: LD_INT 1
 414: PPUSH
 415: CALL_OW 44
 419: PPUSH
 420: CALL_OW 2
 424: ST_TO_ADDR
// hc_importance := 0 ;
 425: LD_ADDR_OWVAR 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// for i = 1 to num - 1 do
 433: LD_ADDR_VAR 0 7
 437: PUSH
 438: DOUBLE
 439: LD_INT 1
 441: DEC
 442: ST_TO_ADDR
 443: LD_VAR 0 3
 447: PUSH
 448: LD_INT 1
 450: MINUS
 451: PUSH
 452: FOR_TO
 453: IFFALSE 511
// begin PrepareHuman ( false , i div ( num / 4 ) + 1 , skill ) ;
 455: LD_INT 0
 457: PPUSH
 458: LD_VAR 0 7
 462: PUSH
 463: LD_VAR 0 3
 467: PUSH
 468: LD_INT 4
 470: DIVREAL
 471: DIV
 472: PUSH
 473: LD_INT 1
 475: PLUS
 476: PPUSH
 477: LD_VAR 0 2
 481: PPUSH
 482: CALL_OW 380
// team := Insert ( team , 2 , CreateHuman ) ;
 486: LD_ADDR_VAR 0 8
 490: PUSH
 491: LD_VAR 0 8
 495: PPUSH
 496: LD_INT 2
 498: PPUSH
 499: CALL_OW 44
 503: PPUSH
 504: CALL_OW 2
 508: ST_TO_ADDR
// end ;
 509: GO 452
 511: POP
 512: POP
// for i in team do
 513: LD_ADDR_VAR 0 7
 517: PUSH
 518: LD_VAR 0 8
 522: PUSH
 523: FOR_IN
 524: IFFALSE 623
// begin PlaceUnitXYR ( i , x , y , 8 , false ) ;
 526: LD_VAR 0 7
 530: PPUSH
 531: LD_VAR 0 4
 535: PPUSH
 536: LD_VAR 0 5
 540: PPUSH
 541: LD_INT 8
 543: PPUSH
 544: LD_INT 0
 546: PPUSH
 547: CALL_OW 50
// c := c + 1 ;
 551: LD_ADDR_VAR 0 9
 555: PUSH
 556: LD_VAR 0 9
 560: PUSH
 561: LD_INT 1
 563: PLUS
 564: ST_TO_ADDR
// SaveCharacters ( i , grave & c ) ;
 565: LD_VAR 0 7
 569: PPUSH
 570: LD_STRING grave
 572: PUSH
 573: LD_VAR 0 9
 577: STR
 578: PPUSH
 579: CALL_OW 38
// playerSquad := Insert ( playerSquad , c , [ i , grave & c ] ) ;
 583: LD_ADDR_EXP 12
 587: PUSH
 588: LD_EXP 12
 592: PPUSH
 593: LD_VAR 0 9
 597: PPUSH
 598: LD_VAR 0 7
 602: PUSH
 603: LD_STRING grave
 605: PUSH
 606: LD_VAR 0 9
 610: STR
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PPUSH
 616: CALL_OW 2
 620: ST_TO_ADDR
// end ;
 621: GO 523
 623: POP
 624: POP
// end ;
 625: LD_VAR 0 6
 629: RET
// export function PrepareResources ( num , type_allowed , x , y , r ) ; var i , n ; begin
 630: LD_INT 0
 632: PPUSH
 633: PPUSH
 634: PPUSH
// for i = 1 to type_allowed do
 635: LD_ADDR_VAR 0 7
 639: PUSH
 640: DOUBLE
 641: LD_INT 1
 643: DEC
 644: ST_TO_ADDR
 645: LD_VAR 0 2
 649: PUSH
 650: FOR_TO
 651: IFFALSE 790
// while ( num [ i ] > 0 ) do
 653: LD_VAR 0 1
 657: PUSH
 658: LD_VAR 0 7
 662: ARRAY
 663: PUSH
 664: LD_INT 0
 666: GREATER
 667: IFFALSE 788
// begin if num [ i ] > 5 then
 669: LD_VAR 0 1
 673: PUSH
 674: LD_VAR 0 7
 678: ARRAY
 679: PUSH
 680: LD_INT 5
 682: GREATER
 683: IFFALSE 695
// n := 5 else
 685: LD_ADDR_VAR 0 8
 689: PUSH
 690: LD_INT 5
 692: ST_TO_ADDR
 693: GO 711
// n := num [ i ] ;
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: LD_VAR 0 1
 704: PUSH
 705: LD_VAR 0 7
 709: ARRAY
 710: ST_TO_ADDR
// CreateResourcesXYR ( type_allowed [ i ] , n , x , y , r , false ) ;
 711: LD_VAR 0 2
 715: PUSH
 716: LD_VAR 0 7
 720: ARRAY
 721: PPUSH
 722: LD_VAR 0 8
 726: PPUSH
 727: LD_VAR 0 3
 731: PPUSH
 732: LD_VAR 0 4
 736: PPUSH
 737: LD_VAR 0 5
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 60
// num := Replace ( num , i , num [ i ] - n ) ;
 749: LD_ADDR_VAR 0 1
 753: PUSH
 754: LD_VAR 0 1
 758: PPUSH
 759: LD_VAR 0 7
 763: PPUSH
 764: LD_VAR 0 1
 768: PUSH
 769: LD_VAR 0 7
 773: ARRAY
 774: PUSH
 775: LD_VAR 0 8
 779: MINUS
 780: PPUSH
 781: CALL_OW 1
 785: ST_TO_ADDR
// end ;
 786: GO 653
 788: GO 650
 790: POP
 791: POP
// end ;
 792: LD_VAR 0 6
 796: RET
// export function AddPoints ( p ) ; begin
 797: LD_INT 0
 799: PPUSH
// points := points + p ;
 800: LD_ADDR_EXP 2
 804: PUSH
 805: LD_EXP 2
 809: PUSH
 810: LD_VAR 0 1
 814: PLUS
 815: ST_TO_ADDR
// end ;
 816: LD_VAR 0 2
 820: RET
// export function LoadColors ; var file ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
// case GetMonth of 1 .. 3 , 12 :
 825: CALL_OW 545
 829: PUSH
 830: LD_INT 1
 832: DOUBLE
 833: GREATEREQUAL
 834: IFFALSE 842
 836: LD_INT 3
 838: DOUBLE
 839: LESSEQUAL
 840: IFTRUE 850
 842: LD_INT 12
 844: DOUBLE
 845: EQUAL
 846: IFTRUE 850
 848: GO 861
 850: POP
// file = colors.txt ; 4 .. 5 :
 851: LD_ADDR_VAR 0 2
 855: PUSH
 856: LD_STRING colors.txt
 858: ST_TO_ADDR
 859: GO 937
 861: LD_INT 4
 863: DOUBLE
 864: GREATEREQUAL
 865: IFFALSE 873
 867: LD_INT 5
 869: DOUBLE
 870: LESSEQUAL
 871: IFTRUE 875
 873: GO 886
 875: POP
// file = colors-spring.txt ; 6 .. 8 :
 876: LD_ADDR_VAR 0 2
 880: PUSH
 881: LD_STRING colors-spring.txt
 883: ST_TO_ADDR
 884: GO 937
 886: LD_INT 6
 888: DOUBLE
 889: GREATEREQUAL
 890: IFFALSE 898
 892: LD_INT 8
 894: DOUBLE
 895: LESSEQUAL
 896: IFTRUE 900
 898: GO 911
 900: POP
// file = colors-summer.txt ; 9 .. 11 :
 901: LD_ADDR_VAR 0 2
 905: PUSH
 906: LD_STRING colors-summer.txt
 908: ST_TO_ADDR
 909: GO 937
 911: LD_INT 9
 913: DOUBLE
 914: GREATEREQUAL
 915: IFFALSE 923
 917: LD_INT 11
 919: DOUBLE
 920: LESSEQUAL
 921: IFTRUE 925
 923: GO 936
 925: POP
// file = colors-autumn.txt ; end ;
 926: LD_ADDR_VAR 0 2
 930: PUSH
 931: LD_STRING colors-autumn.txt
 933: ST_TO_ADDR
 934: GO 937
 936: POP
// LoadColorsTxt ( file ) ;
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 544
// end ;
 946: LD_VAR 0 1
 950: RET
// export function TestColor ; var i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
// i = 1 ;
 955: LD_ADDR_VAR 0 2
 959: PUSH
 960: LD_INT 1
 962: ST_TO_ADDR
// repeat begin wait ( 0 0$01 ) ;
 963: LD_INT 35
 965: PPUSH
 966: CALL_OW 67
// LoadColorsTxt ( [ colors-spring.txt , colors-summer.txt , colors-autumn.txt , colors.txt ] [ i mod 4 + 1 ] ) ;
 970: LD_STRING colors-spring.txt
 972: PUSH
 973: LD_STRING colors-summer.txt
 975: PUSH
 976: LD_STRING colors-autumn.txt
 978: PUSH
 979: LD_STRING colors.txt
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_VAR 0 2
 992: PUSH
 993: LD_INT 4
 995: MOD
 996: PUSH
 997: LD_INT 1
 999: PLUS
1000: ARRAY
1001: PPUSH
1002: CALL_OW 544
// display_strings := [ Wiosna , Lato , Jesien , Zima ] [ i mod 4 + 1 ] ;
1006: LD_ADDR_OWVAR 47
1010: PUSH
1011: LD_STRING Wiosna
1013: PUSH
1014: LD_STRING Lato
1016: PUSH
1017: LD_STRING Jesien
1019: PUSH
1020: LD_STRING Zima
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_INT 4
1036: MOD
1037: PUSH
1038: LD_INT 1
1040: PLUS
1041: ARRAY
1042: ST_TO_ADDR
// i := i + 1 ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_VAR 0 2
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ST_TO_ADDR
// end until false ;
1057: LD_INT 0
1059: IFFALSE 963
// end ;
1061: LD_VAR 0 1
1065: RET
// function FindDir ( x1 , y1 , x2 , y2 ) ; begin
1066: LD_INT 0
1068: PPUSH
// if x1 = x2 and y1 > y2 then
1069: LD_VAR 0 1
1073: PUSH
1074: LD_VAR 0 3
1078: EQUAL
1079: PUSH
1080: LD_VAR 0 2
1084: PUSH
1085: LD_VAR 0 4
1089: GREATER
1090: AND
1091: IFFALSE 1101
// result := 0 ;
1093: LD_ADDR_VAR 0 5
1097: PUSH
1098: LD_INT 0
1100: ST_TO_ADDR
// if x1 < x2 and y1 = y2 then
1101: LD_VAR 0 1
1105: PUSH
1106: LD_VAR 0 3
1110: LESS
1111: PUSH
1112: LD_VAR 0 2
1116: PUSH
1117: LD_VAR 0 4
1121: EQUAL
1122: AND
1123: IFFALSE 1133
// result := 1 ;
1125: LD_ADDR_VAR 0 5
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// if x1 < x2 and y1 < y2 then
1133: LD_VAR 0 1
1137: PUSH
1138: LD_VAR 0 3
1142: LESS
1143: PUSH
1144: LD_VAR 0 2
1148: PUSH
1149: LD_VAR 0 4
1153: LESS
1154: AND
1155: IFFALSE 1165
// result := 2 ;
1157: LD_ADDR_VAR 0 5
1161: PUSH
1162: LD_INT 2
1164: ST_TO_ADDR
// if x1 = x2 and y1 < y2 then
1165: LD_VAR 0 1
1169: PUSH
1170: LD_VAR 0 3
1174: EQUAL
1175: PUSH
1176: LD_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: LESS
1186: AND
1187: IFFALSE 1197
// result := 3 ;
1189: LD_ADDR_VAR 0 5
1193: PUSH
1194: LD_INT 3
1196: ST_TO_ADDR
// if x1 > x2 and y1 = y2 then
1197: LD_VAR 0 1
1201: PUSH
1202: LD_VAR 0 3
1206: GREATER
1207: PUSH
1208: LD_VAR 0 2
1212: PUSH
1213: LD_VAR 0 4
1217: EQUAL
1218: AND
1219: IFFALSE 1229
// result := 4 ;
1221: LD_ADDR_VAR 0 5
1225: PUSH
1226: LD_INT 4
1228: ST_TO_ADDR
// if x1 > x2 and y1 > y2 then
1229: LD_VAR 0 1
1233: PUSH
1234: LD_VAR 0 3
1238: GREATER
1239: PUSH
1240: LD_VAR 0 2
1244: PUSH
1245: LD_VAR 0 4
1249: GREATER
1250: AND
1251: IFFALSE 1261
// result := 5 ;
1253: LD_ADDR_VAR 0 5
1257: PUSH
1258: LD_INT 5
1260: ST_TO_ADDR
// end ;
1261: LD_VAR 0 5
1265: RET
// export function SetTeamExp ( amount ) ; var i , team , pep ; begin
1266: LD_INT 0
1268: PPUSH
1269: PPUSH
1270: PPUSH
1271: PPUSH
// team := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_OWVAR 2
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: EMPTY
1296: LIST
1297: LIST
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: ST_TO_ADDR
// for i = 1 to amount do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_VAR 0 1
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1405
// begin pep := rand ( 1 , team ) ;
1326: LD_ADDR_VAR 0 5
1330: PUSH
1331: LD_INT 1
1333: PPUSH
1334: LD_VAR 0 4
1338: PPUSH
1339: CALL_OW 12
1343: ST_TO_ADDR
// AddExperience ( team [ pep ] , rand ( 1 , 4 ) , rand ( 1000 , 10000 ) ) ;
1344: LD_VAR 0 4
1348: PUSH
1349: LD_VAR 0 5
1353: ARRAY
1354: PPUSH
1355: LD_INT 1
1357: PPUSH
1358: LD_INT 4
1360: PPUSH
1361: CALL_OW 12
1365: PPUSH
1366: LD_INT 1000
1368: PPUSH
1369: LD_INT 10000
1371: PPUSH
1372: CALL_OW 12
1376: PPUSH
1377: CALL_OW 492
// team := team diff team [ pep ] ;
1381: LD_ADDR_VAR 0 4
1385: PUSH
1386: LD_VAR 0 4
1390: PUSH
1391: LD_VAR 0 4
1395: PUSH
1396: LD_VAR 0 5
1400: ARRAY
1401: DIFF
1402: ST_TO_ADDR
// end ;
1403: GO 1323
1405: POP
1406: POP
// end ;
1407: LD_VAR 0 2
1411: RET
// export function PrepareGuards ( strenght ) ; var i , un , area , base_area , points , p , x , y , c , tmp ; begin
1412: LD_INT 0
1414: PPUSH
1415: PPUSH
1416: PPUSH
1417: PPUSH
1418: PPUSH
1419: PPUSH
1420: PPUSH
1421: PPUSH
1422: PPUSH
1423: PPUSH
1424: PPUSH
// area := AreaToList ( guardDir , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_INT 7
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 517
1440: ST_TO_ADDR
// base_area := AreaToList ( guardArea , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_INT 6
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 517
1456: ST_TO_ADDR
// for i = 1 to area [ 1 ] do
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: DOUBLE
1463: LD_INT 1
1465: DEC
1466: ST_TO_ADDR
1467: LD_VAR 0 5
1471: PUSH
1472: LD_INT 1
1474: ARRAY
1475: PUSH
1476: FOR_TO
1477: IFFALSE 1559
// begin points := Replace ( points , points + 1 , area [ 1 ] [ i ] ) ;
1479: LD_ADDR_VAR 0 7
1483: PUSH
1484: LD_VAR 0 7
1488: PPUSH
1489: LD_VAR 0 7
1493: PUSH
1494: LD_INT 1
1496: PLUS
1497: PPUSH
1498: LD_VAR 0 5
1502: PUSH
1503: LD_INT 1
1505: ARRAY
1506: PUSH
1507: LD_VAR 0 3
1511: ARRAY
1512: PPUSH
1513: CALL_OW 1
1517: ST_TO_ADDR
// points := Replace ( points , points + 1 , area [ 2 ] [ i ] ) ;
1518: LD_ADDR_VAR 0 7
1522: PUSH
1523: LD_VAR 0 7
1527: PPUSH
1528: LD_VAR 0 7
1532: PUSH
1533: LD_INT 1
1535: PLUS
1536: PPUSH
1537: LD_VAR 0 5
1541: PUSH
1542: LD_INT 2
1544: ARRAY
1545: PUSH
1546: LD_VAR 0 3
1550: ARRAY
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1476
1559: POP
1560: POP
// uc_side := 4 ;
1561: LD_ADDR_OWVAR 20
1565: PUSH
1566: LD_INT 4
1568: ST_TO_ADDR
// case strenght of 1 .. 10 :
1569: LD_VAR 0 1
1573: PUSH
1574: LD_INT 1
1576: DOUBLE
1577: GREATEREQUAL
1578: IFFALSE 1586
1580: LD_INT 10
1582: DOUBLE
1583: LESSEQUAL
1584: IFTRUE 1588
1586: GO 1650
1588: POP
// begin uc_nation := 0 ;
1589: LD_ADDR_OWVAR 21
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// for i = 1 to 20 do
1597: LD_ADDR_VAR 0 3
1601: PUSH
1602: DOUBLE
1603: LD_INT 1
1605: DEC
1606: ST_TO_ADDR
1607: LD_INT 20
1609: PUSH
1610: FOR_TO
1611: IFFALSE 1646
// begin PrepareHuman ( false , class_apeman_soldier , strenght ) ;
1613: LD_INT 0
1615: PPUSH
1616: LD_INT 15
1618: PPUSH
1619: LD_VAR 0 1
1623: PPUSH
1624: CALL_OW 380
// result := result ^ CreateHuman ;
1628: LD_ADDR_VAR 0 2
1632: PUSH
1633: LD_VAR 0 2
1637: PUSH
1638: CALL_OW 44
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1610
1646: POP
1647: POP
// end ; 11 .. 40 :
1648: GO 1837
1650: LD_INT 11
1652: DOUBLE
1653: GREATEREQUAL
1654: IFFALSE 1662
1656: LD_INT 40
1658: DOUBLE
1659: LESSEQUAL
1660: IFTRUE 1664
1662: GO 1743
1664: POP
// begin uc_nation := 1 ;
1665: LD_ADDR_OWVAR 21
1669: PUSH
1670: LD_INT 1
1672: ST_TO_ADDR
// for i = 1 to 20 do
1673: LD_ADDR_VAR 0 3
1677: PUSH
1678: DOUBLE
1679: LD_INT 1
1681: DEC
1682: ST_TO_ADDR
1683: LD_INT 20
1685: PUSH
1686: FOR_TO
1687: IFFALSE 1739
// begin vc_chassis := us_medium_tracked ;
1689: LD_ADDR_OWVAR 37
1693: PUSH
1694: LD_INT 3
1696: ST_TO_ADDR
// vc_engine := engine_siberite ;
1697: LD_ADDR_OWVAR 39
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// vc_control := control_computer ;
1705: LD_ADDR_OWVAR 38
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// vc_weapon := us_laser ;
1713: LD_ADDR_OWVAR 40
1717: PUSH
1718: LD_INT 9
1720: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1721: LD_ADDR_VAR 0 2
1725: PUSH
1726: LD_VAR 0 2
1730: PUSH
1731: CALL_OW 45
1735: ADD
1736: ST_TO_ADDR
// end ;
1737: GO 1686
1739: POP
1740: POP
// end ; 41 .. 100 :
1741: GO 1837
1743: LD_INT 41
1745: DOUBLE
1746: GREATEREQUAL
1747: IFFALSE 1755
1749: LD_INT 100
1751: DOUBLE
1752: LESSEQUAL
1753: IFTRUE 1757
1755: GO 1836
1757: POP
// begin uc_nation := 1 ;
1758: LD_ADDR_OWVAR 21
1762: PUSH
1763: LD_INT 1
1765: ST_TO_ADDR
// for i = 1 to 20 do
1766: LD_ADDR_VAR 0 3
1770: PUSH
1771: DOUBLE
1772: LD_INT 1
1774: DEC
1775: ST_TO_ADDR
1776: LD_INT 20
1778: PUSH
1779: FOR_TO
1780: IFFALSE 1832
// begin vc_chassis := us_morphling ;
1782: LD_ADDR_OWVAR 37
1786: PUSH
1787: LD_INT 5
1789: ST_TO_ADDR
// vc_engine := engine_siberite ;
1790: LD_ADDR_OWVAR 39
1794: PUSH
1795: LD_INT 3
1797: ST_TO_ADDR
// vc_control := control_computer ;
1798: LD_ADDR_OWVAR 38
1802: PUSH
1803: LD_INT 3
1805: ST_TO_ADDR
// vc_weapon := us_double_laser ;
1806: LD_ADDR_OWVAR 40
1810: PUSH
1811: LD_INT 10
1813: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 2
1823: PUSH
1824: CALL_OW 45
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1779
1832: POP
1833: POP
// end ; end ;
1834: GO 1837
1836: POP
// for i in result do
1837: LD_ADDR_VAR 0 3
1841: PUSH
1842: LD_VAR 0 2
1846: PUSH
1847: FOR_IN
1848: IFFALSE 2065
// begin x := base_area [ 1 ] [ 1 ] ;
1850: LD_ADDR_VAR 0 9
1854: PUSH
1855: LD_VAR 0 6
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PUSH
1864: LD_INT 1
1866: ARRAY
1867: ST_TO_ADDR
// y := base_area [ 2 ] [ 1 ] ;
1868: LD_ADDR_VAR 0 10
1872: PUSH
1873: LD_VAR 0 6
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PUSH
1882: LD_INT 1
1884: ARRAY
1885: ST_TO_ADDR
// p := FindNearestPoint ( points , x , y ) ;
1886: LD_ADDR_VAR 0 8
1890: PUSH
1891: LD_VAR 0 7
1895: PPUSH
1896: LD_VAR 0 9
1900: PPUSH
1901: LD_VAR 0 10
1905: PPUSH
1906: CALL_OW 439
1910: ST_TO_ADDR
// SetDir ( i , FindDir ( x , y , p [ 1 ] , p [ 2 ] ) ) ;
1911: LD_VAR 0 3
1915: PPUSH
1916: LD_VAR 0 9
1920: PPUSH
1921: LD_VAR 0 10
1925: PPUSH
1926: LD_VAR 0 8
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PPUSH
1935: LD_VAR 0 8
1939: PUSH
1940: LD_INT 2
1942: ARRAY
1943: PPUSH
1944: CALL 1066 0 4
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( i , x , y , true ) ;
1953: LD_VAR 0 3
1957: PPUSH
1958: LD_VAR 0 9
1962: PPUSH
1963: LD_VAR 0 10
1967: PPUSH
1968: LD_INT 1
1970: PPUSH
1971: CALL_OW 48
// ComHold ( i ) ;
1975: LD_VAR 0 3
1979: PPUSH
1980: CALL_OW 140
// for c = 1 to 2 do
1984: LD_ADDR_VAR 0 11
1988: PUSH
1989: DOUBLE
1990: LD_INT 1
1992: DEC
1993: ST_TO_ADDR
1994: LD_INT 2
1996: PUSH
1997: FOR_TO
1998: IFFALSE 2061
// begin tmp := base_area [ c ] ;
2000: LD_ADDR_VAR 0 12
2004: PUSH
2005: LD_VAR 0 6
2009: PUSH
2010: LD_VAR 0 11
2014: ARRAY
2015: ST_TO_ADDR
// tmp := Delete ( tmp , 1 ) ;
2016: LD_ADDR_VAR 0 12
2020: PUSH
2021: LD_VAR 0 12
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: CALL_OW 3
2033: ST_TO_ADDR
// base_area := Replace ( base_area , c , tmp ) ;
2034: LD_ADDR_VAR 0 6
2038: PUSH
2039: LD_VAR 0 6
2043: PPUSH
2044: LD_VAR 0 11
2048: PPUSH
2049: LD_VAR 0 12
2053: PPUSH
2054: CALL_OW 1
2058: ST_TO_ADDR
// end ;
2059: GO 1997
2061: POP
2062: POP
// end ;
2063: GO 1847
2065: POP
2066: POP
// end ;
2067: LD_VAR 0 2
2071: RET
// export function GetBack ( ) ; var i , c , un , new ; begin
2072: LD_INT 0
2074: PPUSH
2075: PPUSH
2076: PPUSH
2077: PPUSH
2078: PPUSH
// if graveyard = 0 then
2079: LD_EXP 8
2083: PUSH
2084: LD_INT 0
2086: EQUAL
2087: IFFALSE 2091
// exit ;
2089: GO 2254
// i := rand ( 1 , graveyard ) ;
2091: LD_ADDR_VAR 0 2
2095: PUSH
2096: LD_INT 1
2098: PPUSH
2099: LD_EXP 8
2103: PPUSH
2104: CALL_OW 12
2108: ST_TO_ADDR
// un := graveyard [ i ] ;
2109: LD_ADDR_VAR 0 4
2113: PUSH
2114: LD_EXP 8
2118: PUSH
2119: LD_VAR 0 2
2123: ARRAY
2124: ST_TO_ADDR
// for c in playerSquad do
2125: LD_ADDR_VAR 0 3
2129: PUSH
2130: LD_EXP 12
2134: PUSH
2135: FOR_IN
2136: IFFALSE 2172
// if un = c [ 1 ] then
2138: LD_VAR 0 4
2142: PUSH
2143: LD_VAR 0 3
2147: PUSH
2148: LD_INT 1
2150: ARRAY
2151: EQUAL
2152: IFFALSE 2170
// begin new := c [ 2 ] ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 3
2163: PUSH
2164: LD_INT 2
2166: ARRAY
2167: ST_TO_ADDR
// break ;
2168: GO 2172
// end ;
2170: GO 2135
2172: POP
2173: POP
// uc_side := your_side ;
2174: LD_ADDR_OWVAR 20
2178: PUSH
2179: LD_OWVAR 2
2183: ST_TO_ADDR
// uc_nation := playerNation ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_EXP 6
2193: ST_TO_ADDR
// un := CreateCharacter ( new ) ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_VAR 0 5
2203: PPUSH
2204: CALL_OW 34
2208: ST_TO_ADDR
// PlaceUnitXYR ( un , base_x , base_y , 10 , true ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_EXP 9
2218: PPUSH
2219: LD_EXP 10
2223: PPUSH
2224: LD_INT 10
2226: PPUSH
2227: LD_INT 1
2229: PPUSH
2230: CALL_OW 50
// graveyard := Delete ( graveyard , i ) ;
2234: LD_ADDR_EXP 8
2238: PUSH
2239: LD_EXP 8
2243: PPUSH
2244: LD_VAR 0 2
2248: PPUSH
2249: CALL_OW 3
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 1
2258: RET
// export function ComEspace ( un ) ; begin
2259: LD_INT 0
2261: PPUSH
// if not IsInArea ( un , zoneOut ) then
2262: LD_VAR 0 1
2266: PPUSH
2267: LD_INT 4
2269: PPUSH
2270: CALL_OW 308
2274: NOT
2275: IFFALSE 2291
// ComMoveToArea ( un , zoneOut ) else
2277: LD_VAR 0 1
2281: PPUSH
2282: LD_INT 4
2284: PPUSH
2285: CALL_OW 113
2289: GO 2300
// RemoveUnit ( un ) ;
2291: LD_VAR 0 1
2295: PPUSH
2296: CALL_OW 64
// end ;
2300: LD_VAR 0 2
2304: RET
// export function ComSpecMove ( un , area ) ; var list , new_list , i , x ; begin
2305: LD_INT 0
2307: PPUSH
2308: PPUSH
2309: PPUSH
2310: PPUSH
2311: PPUSH
// list := AreaToList ( area , 0 ) ;
2312: LD_ADDR_VAR 0 4
2316: PUSH
2317: LD_VAR 0 2
2321: PPUSH
2322: LD_INT 0
2324: PPUSH
2325: CALL_OW 517
2329: ST_TO_ADDR
// if not list then
2330: LD_VAR 0 4
2334: NOT
2335: IFFALSE 2339
// exit ;
2337: GO 2501
// for i = 1 to list do
2339: LD_ADDR_VAR 0 6
2343: PUSH
2344: DOUBLE
2345: LD_INT 1
2347: DEC
2348: ST_TO_ADDR
2349: LD_VAR 0 4
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2437
// begin new_list := Replace ( new_list , new_list + 1 , list [ 1 ] [ i ] ) ;
2357: LD_ADDR_VAR 0 5
2361: PUSH
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_VAR 0 5
2371: PUSH
2372: LD_INT 1
2374: PLUS
2375: PPUSH
2376: LD_VAR 0 4
2380: PUSH
2381: LD_INT 1
2383: ARRAY
2384: PUSH
2385: LD_VAR 0 6
2389: ARRAY
2390: PPUSH
2391: CALL_OW 1
2395: ST_TO_ADDR
// new_list := Replace ( new_list , new_list + 1 , list [ 2 ] [ i ] ) ;
2396: LD_ADDR_VAR 0 5
2400: PUSH
2401: LD_VAR 0 5
2405: PPUSH
2406: LD_VAR 0 5
2410: PUSH
2411: LD_INT 1
2413: PLUS
2414: PPUSH
2415: LD_VAR 0 4
2419: PUSH
2420: LD_INT 2
2422: ARRAY
2423: PUSH
2424: LD_VAR 0 6
2428: ARRAY
2429: PPUSH
2430: CALL_OW 1
2434: ST_TO_ADDR
// end ;
2435: GO 2354
2437: POP
2438: POP
// x := FindNearestPoint ( new_list , GetX ( un ) , GetY ( un ) ) ;
2439: LD_ADDR_VAR 0 7
2443: PUSH
2444: LD_VAR 0 5
2448: PPUSH
2449: LD_VAR 0 1
2453: PPUSH
2454: CALL_OW 250
2458: PPUSH
2459: LD_VAR 0 1
2463: PPUSH
2464: CALL_OW 251
2468: PPUSH
2469: CALL_OW 439
2473: ST_TO_ADDR
// ComMoveXY ( un , x [ 1 ] , x [ 2 ] ) ;
2474: LD_VAR 0 1
2478: PPUSH
2479: LD_VAR 0 7
2483: PUSH
2484: LD_INT 1
2486: ARRAY
2487: PPUSH
2488: LD_VAR 0 7
2492: PUSH
2493: LD_INT 2
2495: ARRAY
2496: PPUSH
2497: CALL_OW 111
// end ;
2501: LD_VAR 0 3
2505: RET
// export function ExplodeVehicle ( un ) ; var i , timer ; begin
2506: LD_INT 0
2508: PPUSH
2509: PPUSH
2510: PPUSH
// timer := rand ( 2 , 5 ) ;
2511: LD_ADDR_VAR 0 4
2515: PUSH
2516: LD_INT 2
2518: PPUSH
2519: LD_INT 5
2521: PPUSH
2522: CALL_OW 12
2526: ST_TO_ADDR
// while ( timer > 0 ) do
2527: LD_VAR 0 4
2531: PUSH
2532: LD_INT 0
2534: GREATER
2535: IFFALSE 2574
// begin SetUnitDisplayNumber ( un , timer ) ;
2537: LD_VAR 0 1
2541: PPUSH
2542: LD_VAR 0 4
2546: PPUSH
2547: CALL_OW 505
// timer := timer - 1 ;
2551: LD_ADDR_VAR 0 4
2555: PUSH
2556: LD_VAR 0 4
2560: PUSH
2561: LD_INT 1
2563: MINUS
2564: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
2565: LD_INT 35
2567: PPUSH
2568: CALL_OW 67
// end ;
2572: GO 2527
// if timer = 0 then
2574: LD_VAR 0 4
2578: PUSH
2579: LD_INT 0
2581: EQUAL
2582: IFFALSE 2631
// for i = 1 to 3 do
2584: LD_ADDR_VAR 0 3
2588: PUSH
2589: DOUBLE
2590: LD_INT 1
2592: DEC
2593: ST_TO_ADDR
2594: LD_INT 3
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2629
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
2600: LD_VAR 0 1
2604: PPUSH
2605: CALL_OW 250
2609: PPUSH
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 251
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 453
2627: GO 2597
2629: POP
2630: POP
// end ;
2631: LD_VAR 0 2
2635: RET
// export function DestinationReachable ( unit , x , y ) ; begin
2636: LD_INT 0
2638: PPUSH
// if unit in unreachableList then
2639: LD_VAR 0 1
2643: PUSH
2644: LD_EXP 13
2648: IN
2649: IFFALSE 2667
// unreachableList := unreachableList diff unit ;
2651: LD_ADDR_EXP 13
2655: PUSH
2656: LD_EXP 13
2660: PUSH
2661: LD_VAR 0 1
2665: DIFF
2666: ST_TO_ADDR
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
2667: LD_VAR 0 1
2671: PPUSH
2672: LD_VAR 0 2
2676: PPUSH
2677: LD_VAR 0 3
2681: PPUSH
2682: CALL_OW 428
2686: PPUSH
2687: CALL_OW 115
// Wait ( 1 ) ;
2691: LD_INT 1
2693: PPUSH
2694: CALL_OW 67
// if unit in unreachableList then
2698: LD_VAR 0 1
2702: PUSH
2703: LD_EXP 13
2707: IN
2708: IFFALSE 2720
// result := false else
2710: LD_ADDR_VAR 0 4
2714: PUSH
2715: LD_INT 0
2717: ST_TO_ADDR
2718: GO 2728
// result := true ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_INT 1
2727: ST_TO_ADDR
// end ;
2728: LD_VAR 0 4
2732: RET
// export function ComSpecAttack ( unit ) ; var i , enemy , t , x , y ; begin
2733: LD_INT 0
2735: PPUSH
2736: PPUSH
2737: PPUSH
2738: PPUSH
2739: PPUSH
2740: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
2741: LD_ADDR_VAR 0 4
2745: PUSH
2746: LD_INT 81
2748: PUSH
2749: LD_VAR 0 1
2753: PPUSH
2754: CALL_OW 255
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PPUSH
2763: CALL_OW 69
2767: ST_TO_ADDR
// if not enemy then
2768: LD_VAR 0 4
2772: NOT
2773: IFFALSE 2777
// exit ;
2775: GO 2927
// if UnitFilter ( enemy , [ f_occupied ] ) then
2777: LD_VAR 0 4
2781: PPUSH
2782: LD_INT 59
2784: PUSH
2785: EMPTY
2786: LIST
2787: PPUSH
2788: CALL_OW 72
2792: IFFALSE 2903
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
2794: LD_ADDR_VAR 0 5
2798: PUSH
2799: LD_VAR 0 4
2803: PPUSH
2804: LD_INT 59
2806: PUSH
2807: EMPTY
2808: LIST
2809: PPUSH
2810: CALL_OW 72
2814: PPUSH
2815: LD_VAR 0 1
2819: PPUSH
2820: CALL_OW 74
2824: ST_TO_ADDR
// x := GetX ( t ) ;
2825: LD_ADDR_VAR 0 6
2829: PUSH
2830: LD_VAR 0 5
2834: PPUSH
2835: CALL_OW 250
2839: ST_TO_ADDR
// y := GetY ( t ) ;
2840: LD_ADDR_VAR 0 7
2844: PUSH
2845: LD_VAR 0 5
2849: PPUSH
2850: CALL_OW 251
2854: ST_TO_ADDR
// if not DestinationReachable ( unit , x , y ) then
2855: LD_VAR 0 1
2859: PPUSH
2860: LD_VAR 0 6
2864: PPUSH
2865: LD_VAR 0 7
2869: PPUSH
2870: CALL 2636 0 3
2874: NOT
2875: IFFALSE 2901
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2877: LD_VAR 0 1
2881: PPUSH
2882: LD_VAR 0 4
2886: PPUSH
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 74
2896: PPUSH
2897: CALL_OW 115
// end else
2901: GO 2927
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2903: LD_VAR 0 1
2907: PPUSH
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_VAR 0 1
2917: PPUSH
2918: CALL_OW 74
2922: PPUSH
2923: CALL_OW 115
// end ; end_of_file
2927: LD_VAR 0 2
2931: RET
// export debug , points , difficultyLevel , timeToNextAttack , waveNumber , playerNation , game_started , graveyard , base_x , base_y , base , playerSquad ; end_of_file export function InitSettings ; begin
2932: LD_INT 0
2934: PPUSH
// difficultyLevel := GetMultiplayerSetting ( 0 ) ;
2935: LD_ADDR_EXP 3
2939: PUSH
2940: LD_INT 0
2942: PPUSH
2943: CALL_OW 426
2947: ST_TO_ADDR
// playerNation := GetMultiplayerSetting ( 1 ) - 1 ;
2948: LD_ADDR_EXP 6
2952: PUSH
2953: LD_INT 1
2955: PPUSH
2956: CALL_OW 426
2960: PUSH
2961: LD_INT 1
2963: MINUS
2964: ST_TO_ADDR
// end ; end_of_file
2965: LD_VAR 0 1
2969: RET
// export function InitGame ; begin
2970: LD_INT 0
2972: PPUSH
// ResetFog ;
2973: CALL_OW 335
// RandomizeAll ;
2977: CALL_OW 11
// LoadColors ;
2981: CALL 821 0 0
// debug := false ;
2985: LD_ADDR_EXP 1
2989: PUSH
2990: LD_INT 0
2992: ST_TO_ADDR
// ar_bio_bomb := 91 ;
2993: LD_ADDR_EXP 18
2997: PUSH
2998: LD_INT 91
3000: ST_TO_ADDR
// us_artillery := 97 ;
3001: LD_ADDR_EXP 17
3005: PUSH
3006: LD_INT 97
3008: ST_TO_ADDR
// ru_radar := 98 ;
3009: LD_ADDR_EXP 14
3013: PUSH
3014: LD_INT 98
3016: ST_TO_ADDR
// game_started := false ;
3017: LD_ADDR_EXP 7
3021: PUSH
3022: LD_INT 0
3024: ST_TO_ADDR
// points := 0 ;
3025: LD_ADDR_EXP 2
3029: PUSH
3030: LD_INT 0
3032: ST_TO_ADDR
// waveNumber := 0 ;
3033: LD_ADDR_EXP 5
3037: PUSH
3038: LD_INT 0
3040: ST_TO_ADDR
// timeToNextAttack := 0 ;
3041: LD_ADDR_EXP 4
3045: PUSH
3046: LD_INT 0
3048: ST_TO_ADDR
// graveyard := [ ] ;
3049: LD_ADDR_EXP 8
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// base_x := 1 ;
3056: LD_ADDR_EXP 9
3060: PUSH
3061: LD_INT 1
3063: ST_TO_ADDR
// base_y := 1 ;
3064: LD_ADDR_EXP 10
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// if difficultyLevel > 2 then
3072: LD_EXP 3
3076: PUSH
3077: LD_INT 2
3079: GREATER
3080: IFFALSE 3095
// SetTech ( 5 , 7 , state_researched ) ;
3082: LD_INT 5
3084: PPUSH
3085: LD_INT 7
3087: PPUSH
3088: LD_INT 2
3090: PPUSH
3091: CALL_OW 322
// if not playerNation then
3095: LD_EXP 6
3099: NOT
3100: IFFALSE 3126
// begin points := 100 ;
3102: LD_ADDR_EXP 2
3106: PUSH
3107: LD_INT 100
3109: ST_TO_ADDR
// playerNation := rand ( 1 , 3 ) ;
3110: LD_ADDR_EXP 6
3114: PUSH
3115: LD_INT 1
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 12
3125: ST_TO_ADDR
// end ; your_side := playerNation ;
3126: LD_ADDR_OWVAR 2
3130: PUSH
3131: LD_EXP 6
3135: ST_TO_ADDR
// ChangeSideFog ( your_side , 4 ) ;
3136: LD_OWVAR 2
3140: PPUSH
3141: LD_INT 4
3143: PPUSH
3144: CALL_OW 343
// PrepareResources ( [ [ 25 , 20 , 15 , 10 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] ] , [ 1 , 2 , 3 ] , 88 , 76 , 6 ) ;
3148: LD_INT 25
3150: PUSH
3151: LD_INT 20
3153: PUSH
3154: LD_INT 15
3156: PUSH
3157: LD_INT 10
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: LIST
3165: PUSH
3166: LD_EXP 3
3170: ARRAY
3171: PUSH
3172: LD_INT 5
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: LD_INT 2
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_EXP 3
3194: ARRAY
3195: PUSH
3196: LD_INT 5
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: LD_INT 2
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: PUSH
3214: LD_EXP 3
3218: ARRAY
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: PPUSH
3225: LD_INT 1
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 3
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: LIST
3238: PPUSH
3239: LD_INT 88
3241: PPUSH
3242: LD_INT 76
3244: PPUSH
3245: LD_INT 6
3247: PPUSH
3248: CALL 630 0 5
// PrepareSquad ( playerNation , [ 9 , 7 , 5 , 3 ] [ difficultyLevel ] , [ 24 , 16 , 12 , 8 ] [ difficultyLevel ] , 88 , 76 ) ;
3252: LD_EXP 6
3256: PPUSH
3257: LD_INT 9
3259: PUSH
3260: LD_INT 7
3262: PUSH
3263: LD_INT 5
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_EXP 3
3279: ARRAY
3280: PPUSH
3281: LD_INT 24
3283: PUSH
3284: LD_INT 16
3286: PUSH
3287: LD_INT 12
3289: PUSH
3290: LD_INT 8
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: PUSH
3299: LD_EXP 3
3303: ARRAY
3304: PPUSH
3305: LD_INT 88
3307: PPUSH
3308: LD_INT 76
3310: PPUSH
3311: CALL 339 0 5
// CenterNowOnXY ( 88 , 76 ) ;
3315: LD_INT 88
3317: PPUSH
3318: LD_INT 76
3320: PPUSH
3321: CALL_OW 86
// PlaceSeeing ( 90 , 79 , your_side , - 50 ) ;
3325: LD_INT 90
3327: PPUSH
3328: LD_INT 79
3330: PPUSH
3331: LD_OWVAR 2
3335: PPUSH
3336: LD_INT 50
3338: NEG
3339: PPUSH
3340: CALL_OW 330
// if debug then
3344: LD_EXP 1
3348: IFFALSE 3359
// FogOff ( your_side ) ;
3350: LD_OWVAR 2
3354: PPUSH
3355: CALL_OW 344
// end ;
3359: LD_VAR 0 1
3363: RET
// every 0 0$01 trigger game_started do var i ;
3364: LD_EXP 7
3368: IFFALSE 3602
3370: GO 3372
3372: DISABLE
3373: LD_INT 0
3375: PPUSH
// begin while ( game_started ) do
3376: LD_EXP 7
3380: IFFALSE 3602
// begin if FilterAllUnits ( [ f_side , 7 ] ) < 5 and timeToNextAttack <= 0 0$00 then
3382: LD_INT 22
3384: PUSH
3385: LD_INT 7
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PPUSH
3392: CALL_OW 69
3396: PUSH
3397: LD_INT 5
3399: LESS
3400: PUSH
3401: LD_EXP 4
3405: PUSH
3406: LD_INT 0
3408: LESSEQUAL
3409: AND
3410: IFFALSE 3593
// begin if FilterAllUnits ( [ f_side , 4 ] ) then
3412: LD_INT 22
3414: PUSH
3415: LD_INT 4
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PPUSH
3422: CALL_OW 69
3426: IFFALSE 3464
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3428: LD_ADDR_VAR 0 1
3432: PUSH
3433: LD_INT 22
3435: PUSH
3436: LD_INT 4
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PPUSH
3443: CALL_OW 69
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3462
// RemoveUnit ( i ) ;
3451: LD_VAR 0 1
3455: PPUSH
3456: CALL_OW 64
3460: GO 3448
3462: POP
3463: POP
// if ( waveNumber mod 3 = 0 or waveNumber mod 10 = 0 ) and waveNumber > 0 then
3464: LD_EXP 5
3468: PUSH
3469: LD_INT 3
3471: MOD
3472: PUSH
3473: LD_INT 0
3475: EQUAL
3476: PUSH
3477: LD_EXP 5
3481: PUSH
3482: LD_INT 10
3484: MOD
3485: PUSH
3486: LD_INT 0
3488: EQUAL
3489: OR
3490: PUSH
3491: LD_EXP 5
3495: PUSH
3496: LD_INT 0
3498: GREATER
3499: AND
3500: IFFALSE 3506
// InitBonus ;
3502: CALL 9606 0 0
// if waveNumber mod 10 = 0 then
3506: LD_EXP 5
3510: PUSH
3511: LD_INT 10
3513: MOD
3514: PUSH
3515: LD_INT 0
3517: EQUAL
3518: IFFALSE 3524
// SaveForQuickRestart ;
3520: CALL_OW 22
// if waveNumber = 100 then
3524: LD_EXP 5
3528: PUSH
3529: LD_INT 100
3531: EQUAL
3532: IFFALSE 3545
// begin FogOff ( your_side ) ;
3534: LD_OWVAR 2
3538: PPUSH
3539: CALL_OW 344
// break ;
3543: GO 3602
// end ; timeToNextAttack := rand ( 1 1$30 , 2 2$30 ) ;
3545: LD_ADDR_EXP 4
3549: PUSH
3550: LD_INT 3150
3552: PPUSH
3553: LD_INT 5250
3555: PPUSH
3556: CALL_OW 12
3560: ST_TO_ADDR
// Wait ( timeToNextAttack ) ;
3561: LD_EXP 4
3565: PPUSH
3566: CALL_OW 67
// waveNumber := waveNumber + 1 ;
3570: LD_ADDR_EXP 5
3574: PUSH
3575: LD_EXP 5
3579: PUSH
3580: LD_INT 1
3582: PLUS
3583: ST_TO_ADDR
// PrepareWave ( waveNumber ) ;
3584: LD_EXP 5
3588: PPUSH
3589: CALL 4597 0 1
// end ; Wait ( 0 0$01 ) ;
3593: LD_INT 35
3595: PPUSH
3596: CALL_OW 67
// end ;
3600: GO 3376
// end ;
3602: PPOPN 1
3604: END
// every 0 0$01 trigger timeToNextAttack > 0 0$00 do
3605: LD_EXP 4
3609: PUSH
3610: LD_INT 0
3612: GREATER
3613: IFFALSE 3633
3615: GO 3617
3617: DISABLE
// begin enable ;
3618: ENABLE
// timeToNextAttack := timeToNextAttack - 0 0$01 ;
3619: LD_ADDR_EXP 4
3623: PUSH
3624: LD_EXP 4
3628: PUSH
3629: LD_INT 35
3631: MINUS
3632: ST_TO_ADDR
// end ; end_of_file
3633: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
3634: LD_VAR 0 1
3638: PUSH
3639: LD_EXP 13
3643: IN
3644: NOT
3645: IFFALSE 3676
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
3647: LD_ADDR_EXP 13
3651: PUSH
3652: LD_EXP 13
3656: PPUSH
3657: LD_EXP 13
3661: PUSH
3662: LD_INT 1
3664: PLUS
3665: PPUSH
3666: LD_VAR 0 1
3670: PPUSH
3671: CALL_OW 2
3675: ST_TO_ADDR
// end ;
3676: PPOPN 1
3678: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side and GetType ( un ) = unit_human then
3679: LD_VAR 0 1
3683: PPUSH
3684: CALL_OW 255
3688: PUSH
3689: LD_OWVAR 2
3693: EQUAL
3694: PUSH
3695: LD_VAR 0 1
3699: PPUSH
3700: CALL_OW 247
3704: PUSH
3705: LD_INT 1
3707: EQUAL
3708: AND
3709: IFFALSE 3740
// begin graveyard := Insert ( graveyard , graveyard + 1 , un ) ;
3711: LD_ADDR_EXP 8
3715: PUSH
3716: LD_EXP 8
3720: PPUSH
3721: LD_EXP 8
3725: PUSH
3726: LD_INT 1
3728: PLUS
3729: PPUSH
3730: LD_VAR 0 1
3734: PPUSH
3735: CALL_OW 2
3739: ST_TO_ADDR
// end ; if GetSide ( un ) = 7 then
3740: LD_VAR 0 1
3744: PPUSH
3745: CALL_OW 255
3749: PUSH
3750: LD_INT 7
3752: EQUAL
3753: IFFALSE 4127
// begin if un in FilterAllUnits ( [ f_weapon , 91 ] ) then
3755: LD_VAR 0 1
3759: PUSH
3760: LD_INT 34
3762: PUSH
3763: LD_INT 91
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PPUSH
3770: CALL_OW 69
3774: IN
3775: IFFALSE 3820
// begin if Rand ( 1 , 100 ) <= 70 then
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 100
3782: PPUSH
3783: CALL_OW 12
3787: PUSH
3788: LD_INT 70
3790: LESSEQUAL
3791: IFFALSE 3820
// ArtContamination ( GetX ( un ) , GetY ( un ) , 10 ) ;
3793: LD_VAR 0 1
3797: PPUSH
3798: CALL_OW 250
3802: PPUSH
3803: LD_VAR 0 1
3807: PPUSH
3808: CALL_OW 251
3812: PPUSH
3813: LD_INT 10
3815: PPUSH
3816: CALL_OW 495
// end ; case GetType ( un ) of unit_human :
3820: LD_VAR 0 1
3824: PPUSH
3825: CALL_OW 247
3829: PUSH
3830: LD_INT 1
3832: DOUBLE
3833: EQUAL
3834: IFTRUE 3838
3836: GO 3972
3838: POP
// begin case GetClass ( un ) of class_apeman :
3839: LD_VAR 0 1
3843: PPUSH
3844: CALL_OW 257
3848: PUSH
3849: LD_INT 12
3851: DOUBLE
3852: EQUAL
3853: IFTRUE 3857
3855: GO 3867
3857: POP
// AddPoints ( 2 ) ; class_apeman_soldier :
3858: LD_INT 2
3860: PPUSH
3861: CALL 797 0 1
3865: GO 3970
3867: LD_INT 15
3869: DOUBLE
3870: EQUAL
3871: IFTRUE 3875
3873: GO 3885
3875: POP
// AddPoints ( 5 ) ; class_apeman_kamikaze :
3876: LD_INT 5
3878: PPUSH
3879: CALL 797 0 1
3883: GO 3970
3885: LD_INT 17
3887: DOUBLE
3888: EQUAL
3889: IFTRUE 3893
3891: GO 3903
3893: POP
// AddPoints ( 30 ) ; class_soldier :
3894: LD_INT 30
3896: PPUSH
3897: CALL 797 0 1
3901: GO 3970
3903: LD_INT 1
3905: DOUBLE
3906: EQUAL
3907: IFTRUE 3911
3909: GO 3921
3911: POP
// AddPoints ( 50 ) ; class_bazooker , class_sniper , class_mortar :
3912: LD_INT 50
3914: PPUSH
3915: CALL 797 0 1
3919: GO 3970
3921: LD_INT 9
3923: DOUBLE
3924: EQUAL
3925: IFTRUE 3941
3927: LD_INT 5
3929: DOUBLE
3930: EQUAL
3931: IFTRUE 3941
3933: LD_INT 8
3935: DOUBLE
3936: EQUAL
3937: IFTRUE 3941
3939: GO 3951
3941: POP
// AddPoints ( 75 ) ; class_mechanic :
3942: LD_INT 75
3944: PPUSH
3945: CALL 797 0 1
3949: GO 3970
3951: LD_INT 3
3953: DOUBLE
3954: EQUAL
3955: IFTRUE 3959
3957: GO 3969
3959: POP
// AddPoints ( 60 ) ; end ;
3960: LD_INT 60
3962: PPUSH
3963: CALL 797 0 1
3967: GO 3970
3969: POP
// end ; unit_vehicle :
3970: GO 4127
3972: LD_INT 2
3974: DOUBLE
3975: EQUAL
3976: IFTRUE 3980
3978: GO 4126
3980: POP
// begin case GetChassis ( un ) of ar_light_trike , us_light_wheeled , ar_hovercraft :
3981: LD_VAR 0 1
3985: PPUSH
3986: CALL_OW 265
3990: PUSH
3991: LD_INT 12
3993: DOUBLE
3994: EQUAL
3995: IFTRUE 4011
3997: LD_INT 1
3999: DOUBLE
4000: EQUAL
4001: IFTRUE 4011
4003: LD_INT 11
4005: DOUBLE
4006: EQUAL
4007: IFTRUE 4011
4009: GO 4021
4011: POP
// AddPoints ( 100 ) ; ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , ru_medium_wheeled , ru_medium_tracked :
4012: LD_INT 100
4014: PPUSH
4015: CALL 797 0 1
4019: GO 4124
4021: LD_INT 13
4023: DOUBLE
4024: EQUAL
4025: IFTRUE 4059
4027: LD_INT 14
4029: DOUBLE
4030: EQUAL
4031: IFTRUE 4059
4033: LD_INT 2
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4059
4039: LD_INT 3
4041: DOUBLE
4042: EQUAL
4043: IFTRUE 4059
4045: LD_INT 21
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4059
4051: LD_INT 22
4053: DOUBLE
4054: EQUAL
4055: IFTRUE 4059
4057: GO 4069
4059: POP
// AddPoints ( 250 ) ; us_heavy_tracked , us_morphling , ru_heavy_wheeled , ru_heavy_tracked :
4060: LD_INT 250
4062: PPUSH
4063: CALL 797 0 1
4067: GO 4124
4069: LD_INT 4
4071: DOUBLE
4072: EQUAL
4073: IFTRUE 4095
4075: LD_INT 5
4077: DOUBLE
4078: EQUAL
4079: IFTRUE 4095
4081: LD_INT 23
4083: DOUBLE
4084: EQUAL
4085: IFTRUE 4095
4087: LD_INT 24
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4095
4093: GO 4105
4095: POP
// AddPoints ( 500 ) ; 25 :
4096: LD_INT 500
4098: PPUSH
4099: CALL 797 0 1
4103: GO 4124
4105: LD_INT 25
4107: DOUBLE
4108: EQUAL
4109: IFTRUE 4113
4111: GO 4123
4113: POP
// AddPoints ( 1250 ) ; end ;
4114: LD_INT 1250
4116: PPUSH
4117: CALL 797 0 1
4121: GO 4124
4123: POP
// end ; end ;
4124: GO 4127
4126: POP
// end ; end ;
4127: PPOPN 1
4129: END
// on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot then
4130: LD_VAR 0 1
4134: PPUSH
4135: CALL_OW 266
4139: PUSH
4140: LD_INT 0
4142: EQUAL
4143: IFFALSE 4193
// begin base_x := GetX ( b ) ;
4145: LD_ADDR_EXP 9
4149: PUSH
4150: LD_VAR 0 1
4154: PPUSH
4155: CALL_OW 250
4159: ST_TO_ADDR
// base_y := GetY ( b ) ;
4160: LD_ADDR_EXP 10
4164: PUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 251
4174: ST_TO_ADDR
// base := b ;
4175: LD_ADDR_EXP 11
4179: PUSH
4180: LD_VAR 0 1
4184: ST_TO_ADDR
// game_started := true ;
4185: LD_ADDR_EXP 7
4189: PUSH
4190: LD_INT 1
4192: ST_TO_ADDR
// end ; end ;
4193: PPOPN 1
4195: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = your_side then
4196: LD_VAR 0 1
4200: PPUSH
4201: CALL_OW 255
4205: PUSH
4206: LD_OWVAR 2
4210: EQUAL
4211: IFFALSE 4215
// exit ;
4213: GO 4362
// if GetType ( un ) = unit_vehicle then
4215: LD_VAR 0 1
4219: PPUSH
4220: CALL_OW 247
4224: PUSH
4225: LD_INT 2
4227: EQUAL
4228: IFFALSE 4281
// begin KillUnit ( un ) ;
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 66
// if GetNation ( un ) = nation_arabian or GetWeapon ( un ) in [ ru_time_lapser ] then
4239: LD_VAR 0 1
4243: PPUSH
4244: CALL_OW 248
4248: PUSH
4249: LD_INT 2
4251: EQUAL
4252: PUSH
4253: LD_VAR 0 1
4257: PPUSH
4258: CALL_OW 264
4262: PUSH
4263: LD_INT 49
4265: PUSH
4266: EMPTY
4267: LIST
4268: IN
4269: OR
4270: IFFALSE 4281
// ExplodeVehicle ( un ) ;
4272: LD_VAR 0 1
4276: PPUSH
4277: CALL 2506 0 1
// end ; if GetType ( un ) = unit_human then
4281: LD_VAR 0 1
4285: PPUSH
4286: CALL_OW 247
4290: PUSH
4291: LD_INT 1
4293: EQUAL
4294: IFFALSE 4362
// begin if ( GetNation ( un ) = 2 and GetTech ( 5 , 7 ) <> state_researched ) or GetNation ( un ) in [ 0 , 1 , 3 ] then
4296: LD_VAR 0 1
4300: PPUSH
4301: CALL_OW 248
4305: PUSH
4306: LD_INT 2
4308: EQUAL
4309: PUSH
4310: LD_INT 5
4312: PPUSH
4313: LD_INT 7
4315: PPUSH
4316: CALL_OW 321
4320: PUSH
4321: LD_INT 2
4323: NONEQUAL
4324: AND
4325: PUSH
4326: LD_VAR 0 1
4330: PPUSH
4331: CALL_OW 248
4335: PUSH
4336: LD_INT 0
4338: PUSH
4339: LD_INT 1
4341: PUSH
4342: LD_INT 3
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: LIST
4349: IN
4350: OR
4351: IFFALSE 4362
// KillUnit ( un ) ;
4353: LD_VAR 0 1
4357: PPUSH
4358: CALL_OW 66
// end ; end ;
4362: PPOPN 1
4364: END
// every 0 0$1 do
4365: GO 4367
4367: DISABLE
// begin enable ;
4368: ENABLE
// CheckBuildUpArea ( zoneOut , zoneIn , [ f_side , your_side ] ) ;
4369: LD_INT 4
4371: PPUSH
4372: LD_INT 5
4374: PPUSH
4375: LD_INT 22
4377: PUSH
4378: LD_OWVAR 2
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PPUSH
4387: CALL_OW 513
// end ;
4391: END
// every 0 0$01 trigger game_started and FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) = 0 do
4392: LD_EXP 7
4396: PUSH
4397: LD_INT 22
4399: PUSH
4400: LD_OWVAR 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 21
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PPUSH
4423: CALL_OW 69
4427: PUSH
4428: LD_INT 0
4430: EQUAL
4431: AND
4432: IFFALSE 4444
4434: GO 4436
4436: DISABLE
// YouLost ( die ) ;
4437: LD_STRING die
4439: PPUSH
4440: CALL_OW 104
4444: END
// every 0 0$21 trigger tick <= 15 15$00 do
4445: LD_OWVAR 1
4449: PUSH
4450: LD_INT 31500
4452: LESSEQUAL
4453: IFFALSE 4480
4455: GO 4457
4457: DISABLE
// begin enable ;
4458: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4459: LD_INT 1
4461: PPUSH
4462: LD_INT 5
4464: PPUSH
4465: CALL_OW 12
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 1
4475: PPUSH
4476: CALL_OW 55
// end ;
4480: END
// every 0 0$51 trigger tick > 15 15$00 do
4481: LD_OWVAR 1
4485: PUSH
4486: LD_INT 31500
4488: GREATER
4489: IFFALSE 4536
4491: GO 4493
4493: DISABLE
// begin enable ;
4494: ENABLE
// if FilterAllUnits ( [ f_side , 7 ] ) = 0 then
4495: LD_INT 22
4497: PUSH
4498: LD_INT 7
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PPUSH
4505: CALL_OW 69
4509: PUSH
4510: LD_INT 0
4512: EQUAL
4513: IFFALSE 4536
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4515: LD_INT 1
4517: PPUSH
4518: LD_INT 5
4520: PPUSH
4521: CALL_OW 12
4525: PPUSH
4526: LD_INT 3
4528: PPUSH
4529: LD_INT 1
4531: PPUSH
4532: CALL_OW 55
// end ;
4536: END
// on BuildingStarted ( building , builder ) do begin if IsInArea ( building , cratesSpawn ) then
4537: LD_VAR 0 1
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: CALL_OW 308
4549: IFFALSE 4560
// KillUnit ( building ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: CALL_OW 66
// end ;
4560: PPOPN 2
4562: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4563: LD_VAR 0 1
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_VAR 0 3
4577: PPUSH
4578: CALL 13595 0 3
// end ;
4582: PPOPN 3
4584: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4585: LD_VAR 0 1
4589: PPUSH
4590: CALL 13693 0 1
// end ; end_of_file
4594: PPOPN 1
4596: END
// export function PrepareWave ( num ) ; var i , un , skill , veh , area , a , l , c ; begin
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
4605: PPUSH
4606: PPUSH
4607: PPUSH
// area := [ Enemy1 , Enemy2 ] ;
4608: LD_ADDR_VAR 0 7
4612: PUSH
4613: LD_INT 1
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: ST_TO_ADDR
// uc_side := 7 ;
4623: LD_ADDR_OWVAR 20
4627: PUSH
4628: LD_INT 7
4630: ST_TO_ADDR
// l := 0 ;
4631: LD_ADDR_VAR 0 9
4635: PUSH
4636: LD_INT 0
4638: ST_TO_ADDR
// case num of 1 :
4639: LD_VAR 0 1
4643: PUSH
4644: LD_INT 1
4646: DOUBLE
4647: EQUAL
4648: IFTRUE 4652
4650: GO 4671
4652: POP
// result := Wave1 ( 12 , 1 ) ; 2 :
4653: LD_ADDR_VAR 0 2
4657: PUSH
4658: LD_INT 12
4660: PPUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL 7000 0 2
4668: ST_TO_ADDR
4669: GO 6809
4671: LD_INT 2
4673: DOUBLE
4674: EQUAL
4675: IFTRUE 4679
4677: GO 4698
4679: POP
// result := Wave2 ( 12 , 1 ) ; 3 :
4680: LD_ADDR_VAR 0 2
4684: PUSH
4685: LD_INT 12
4687: PPUSH
4688: LD_INT 1
4690: PPUSH
4691: CALL 7071 0 2
4695: ST_TO_ADDR
4696: GO 6809
4698: LD_INT 3
4700: DOUBLE
4701: EQUAL
4702: IFTRUE 4706
4704: GO 4725
4706: POP
// result := Wave3 ( 12 , 1 ) ; 4 :
4707: LD_ADDR_VAR 0 2
4711: PUSH
4712: LD_INT 12
4714: PPUSH
4715: LD_INT 1
4717: PPUSH
4718: CALL 7142 0 2
4722: ST_TO_ADDR
4723: GO 6809
4725: LD_INT 4
4727: DOUBLE
4728: EQUAL
4729: IFTRUE 4733
4731: GO 4752
4733: POP
// result := Wave4 ( 7 , 1 ) ; 5 :
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 7
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL 7221 0 2
4749: ST_TO_ADDR
4750: GO 6809
4752: LD_INT 5
4754: DOUBLE
4755: EQUAL
4756: IFTRUE 4760
4758: GO 4779
4760: POP
// result := Wave5 ( 7 , 1 ) ; 6 :
4761: LD_ADDR_VAR 0 2
4765: PUSH
4766: LD_INT 7
4768: PPUSH
4769: LD_INT 1
4771: PPUSH
4772: CALL 7617 0 2
4776: ST_TO_ADDR
4777: GO 6809
4779: LD_INT 6
4781: DOUBLE
4782: EQUAL
4783: IFTRUE 4787
4785: GO 4806
4787: POP
// result := Wave6 ( 6 , 1 ) ; 7 :
4788: LD_ADDR_VAR 0 2
4792: PUSH
4793: LD_INT 6
4795: PPUSH
4796: LD_INT 1
4798: PPUSH
4799: CALL 8037 0 2
4803: ST_TO_ADDR
4804: GO 6809
4806: LD_INT 7
4808: DOUBLE
4809: EQUAL
4810: IFTRUE 4814
4812: GO 4833
4814: POP
// result := Wave7 ( 15 , 1 ) ; 8 :
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: LD_INT 15
4822: PPUSH
4823: LD_INT 1
4825: PPUSH
4826: CALL 8457 0 2
4830: ST_TO_ADDR
4831: GO 6809
4833: LD_INT 8
4835: DOUBLE
4836: EQUAL
4837: IFTRUE 4841
4839: GO 4860
4841: POP
// result := Wave8 ( 7 , 1 ) ; 9 :
4842: LD_ADDR_VAR 0 2
4846: PUSH
4847: LD_INT 7
4849: PPUSH
4850: LD_INT 1
4852: PPUSH
4853: CALL 8558 0 2
4857: ST_TO_ADDR
4858: GO 6809
4860: LD_INT 9
4862: DOUBLE
4863: EQUAL
4864: IFTRUE 4868
4866: GO 4899
4868: POP
// result := Wave8 ( 4 , 1 ) ^ Wave5 ( 7 , 1 ) ; 10 :
4869: LD_ADDR_VAR 0 2
4873: PUSH
4874: LD_INT 4
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: CALL 8558 0 2
4884: PUSH
4885: LD_INT 7
4887: PPUSH
4888: LD_INT 1
4890: PPUSH
4891: CALL 7617 0 2
4895: ADD
4896: ST_TO_ADDR
4897: GO 6809
4899: LD_INT 10
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4938
4907: POP
// result := Wave7 ( 9 , 1 ) ^ Wave3 ( 14 , 1 ) ; 11 , 21 , 31 , 41 , 51 , 61 , 71 , 81 , 91 :
4908: LD_ADDR_VAR 0 2
4912: PUSH
4913: LD_INT 9
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: CALL 8457 0 2
4923: PUSH
4924: LD_INT 14
4926: PPUSH
4927: LD_INT 1
4929: PPUSH
4930: CALL 7142 0 2
4934: ADD
4935: ST_TO_ADDR
4936: GO 6809
4938: LD_INT 11
4940: DOUBLE
4941: EQUAL
4942: IFTRUE 4994
4944: LD_INT 21
4946: DOUBLE
4947: EQUAL
4948: IFTRUE 4994
4950: LD_INT 31
4952: DOUBLE
4953: EQUAL
4954: IFTRUE 4994
4956: LD_INT 41
4958: DOUBLE
4959: EQUAL
4960: IFTRUE 4994
4962: LD_INT 51
4964: DOUBLE
4965: EQUAL
4966: IFTRUE 4994
4968: LD_INT 61
4970: DOUBLE
4971: EQUAL
4972: IFTRUE 4994
4974: LD_INT 71
4976: DOUBLE
4977: EQUAL
4978: IFTRUE 4994
4980: LD_INT 81
4982: DOUBLE
4983: EQUAL
4984: IFTRUE 4994
4986: LD_INT 91
4988: DOUBLE
4989: EQUAL
4990: IFTRUE 4994
4992: GO 5103
4994: POP
// result := Wave1 ( [ 20 , 30 , 40 , 45 , 50 , 60 , 70 , 80 , 100 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 12 , 22 , 32 , 42 , 52 , 62 , 72 , 82 , 92 :
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: LD_INT 20
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 40
5008: PUSH
5009: LD_INT 45
5011: PUSH
5012: LD_INT 50
5014: PUSH
5015: LD_INT 60
5017: PUSH
5018: LD_INT 70
5020: PUSH
5021: LD_INT 80
5023: PUSH
5024: LD_INT 100
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: LD_VAR 0 1
5042: PUSH
5043: LD_INT 10
5045: DIV
5046: ARRAY
5047: PPUSH
5048: LD_INT 2
5050: PUSH
5051: LD_INT 3
5053: PUSH
5054: LD_INT 4
5056: PUSH
5057: LD_INT 5
5059: PUSH
5060: LD_INT 6
5062: PUSH
5063: LD_INT 7
5065: PUSH
5066: LD_INT 8
5068: PUSH
5069: LD_INT 9
5071: PUSH
5072: LD_INT 10
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: PUSH
5086: LD_VAR 0 1
5090: PUSH
5091: LD_INT 10
5093: DIV
5094: ARRAY
5095: PPUSH
5096: CALL 7000 0 2
5100: ST_TO_ADDR
5101: GO 6809
5103: LD_INT 12
5105: DOUBLE
5106: EQUAL
5107: IFTRUE 5159
5109: LD_INT 22
5111: DOUBLE
5112: EQUAL
5113: IFTRUE 5159
5115: LD_INT 32
5117: DOUBLE
5118: EQUAL
5119: IFTRUE 5159
5121: LD_INT 42
5123: DOUBLE
5124: EQUAL
5125: IFTRUE 5159
5127: LD_INT 52
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5159
5133: LD_INT 62
5135: DOUBLE
5136: EQUAL
5137: IFTRUE 5159
5139: LD_INT 72
5141: DOUBLE
5142: EQUAL
5143: IFTRUE 5159
5145: LD_INT 82
5147: DOUBLE
5148: EQUAL
5149: IFTRUE 5159
5151: LD_INT 92
5153: DOUBLE
5154: EQUAL
5155: IFTRUE 5159
5157: GO 5268
5159: POP
// result := Wave2 ( [ 16 , 21 , 28 , 33 , 39 , 46 , 56 , 66 , 80 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 13 , 23 , 33 , 43 , 53 , 63 , 73 , 83 , 93 :
5160: LD_ADDR_VAR 0 2
5164: PUSH
5165: LD_INT 16
5167: PUSH
5168: LD_INT 21
5170: PUSH
5171: LD_INT 28
5173: PUSH
5174: LD_INT 33
5176: PUSH
5177: LD_INT 39
5179: PUSH
5180: LD_INT 46
5182: PUSH
5183: LD_INT 56
5185: PUSH
5186: LD_INT 66
5188: PUSH
5189: LD_INT 80
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_VAR 0 1
5207: PUSH
5208: LD_INT 10
5210: DIV
5211: ARRAY
5212: PPUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: LD_INT 4
5221: PUSH
5222: LD_INT 5
5224: PUSH
5225: LD_INT 6
5227: PUSH
5228: LD_INT 7
5230: PUSH
5231: LD_INT 8
5233: PUSH
5234: LD_INT 9
5236: PUSH
5237: LD_INT 10
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PUSH
5251: LD_VAR 0 1
5255: PUSH
5256: LD_INT 10
5258: DIV
5259: ARRAY
5260: PPUSH
5261: CALL 7071 0 2
5265: ST_TO_ADDR
5266: GO 6809
5268: LD_INT 13
5270: DOUBLE
5271: EQUAL
5272: IFTRUE 5324
5274: LD_INT 23
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5324
5280: LD_INT 33
5282: DOUBLE
5283: EQUAL
5284: IFTRUE 5324
5286: LD_INT 43
5288: DOUBLE
5289: EQUAL
5290: IFTRUE 5324
5292: LD_INT 53
5294: DOUBLE
5295: EQUAL
5296: IFTRUE 5324
5298: LD_INT 63
5300: DOUBLE
5301: EQUAL
5302: IFTRUE 5324
5304: LD_INT 73
5306: DOUBLE
5307: EQUAL
5308: IFTRUE 5324
5310: LD_INT 83
5312: DOUBLE
5313: EQUAL
5314: IFTRUE 5324
5316: LD_INT 93
5318: DOUBLE
5319: EQUAL
5320: IFTRUE 5324
5322: GO 5433
5324: POP
// result := Wave3 ( [ 14 , 18 , 22 , 27 , 33 , 39 , 44 , 57 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 14 , 24 , 34 , 44 , 54 , 64 , 74 , 84 , 94 :
5325: LD_ADDR_VAR 0 2
5329: PUSH
5330: LD_INT 14
5332: PUSH
5333: LD_INT 18
5335: PUSH
5336: LD_INT 22
5338: PUSH
5339: LD_INT 27
5341: PUSH
5342: LD_INT 33
5344: PUSH
5345: LD_INT 39
5347: PUSH
5348: LD_INT 44
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: LD_INT 65
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PUSH
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 10
5375: DIV
5376: ARRAY
5377: PPUSH
5378: LD_INT 2
5380: PUSH
5381: LD_INT 3
5383: PUSH
5384: LD_INT 4
5386: PUSH
5387: LD_INT 5
5389: PUSH
5390: LD_INT 6
5392: PUSH
5393: LD_INT 7
5395: PUSH
5396: LD_INT 8
5398: PUSH
5399: LD_INT 9
5401: PUSH
5402: LD_INT 10
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: LIST
5415: PUSH
5416: LD_VAR 0 1
5420: PUSH
5421: LD_INT 10
5423: DIV
5424: ARRAY
5425: PPUSH
5426: CALL 7142 0 2
5430: ST_TO_ADDR
5431: GO 6809
5433: LD_INT 14
5435: DOUBLE
5436: EQUAL
5437: IFTRUE 5489
5439: LD_INT 24
5441: DOUBLE
5442: EQUAL
5443: IFTRUE 5489
5445: LD_INT 34
5447: DOUBLE
5448: EQUAL
5449: IFTRUE 5489
5451: LD_INT 44
5453: DOUBLE
5454: EQUAL
5455: IFTRUE 5489
5457: LD_INT 54
5459: DOUBLE
5460: EQUAL
5461: IFTRUE 5489
5463: LD_INT 64
5465: DOUBLE
5466: EQUAL
5467: IFTRUE 5489
5469: LD_INT 74
5471: DOUBLE
5472: EQUAL
5473: IFTRUE 5489
5475: LD_INT 84
5477: DOUBLE
5478: EQUAL
5479: IFTRUE 5489
5481: LD_INT 94
5483: DOUBLE
5484: EQUAL
5485: IFTRUE 5489
5487: GO 5598
5489: POP
// result := Wave4 ( [ 9 , 15 , 22 , 30 , 39 , 45 , 56 , 60 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 15 , 25 , 35 , 45 , 55 , 65 , 75 , 85 , 95 :
5490: LD_ADDR_VAR 0 2
5494: PUSH
5495: LD_INT 9
5497: PUSH
5498: LD_INT 15
5500: PUSH
5501: LD_INT 22
5503: PUSH
5504: LD_INT 30
5506: PUSH
5507: LD_INT 39
5509: PUSH
5510: LD_INT 45
5512: PUSH
5513: LD_INT 56
5515: PUSH
5516: LD_INT 60
5518: PUSH
5519: LD_INT 65
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_VAR 0 1
5537: PUSH
5538: LD_INT 10
5540: DIV
5541: ARRAY
5542: PPUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: LD_INT 4
5551: PUSH
5552: LD_INT 5
5554: PUSH
5555: LD_INT 6
5557: PUSH
5558: LD_INT 7
5560: PUSH
5561: LD_INT 8
5563: PUSH
5564: LD_INT 9
5566: PUSH
5567: LD_INT 10
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: LIST
5580: PUSH
5581: LD_VAR 0 1
5585: PUSH
5586: LD_INT 10
5588: DIV
5589: ARRAY
5590: PPUSH
5591: CALL 7221 0 2
5595: ST_TO_ADDR
5596: GO 6809
5598: LD_INT 15
5600: DOUBLE
5601: EQUAL
5602: IFTRUE 5654
5604: LD_INT 25
5606: DOUBLE
5607: EQUAL
5608: IFTRUE 5654
5610: LD_INT 35
5612: DOUBLE
5613: EQUAL
5614: IFTRUE 5654
5616: LD_INT 45
5618: DOUBLE
5619: EQUAL
5620: IFTRUE 5654
5622: LD_INT 55
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5654
5628: LD_INT 65
5630: DOUBLE
5631: EQUAL
5632: IFTRUE 5654
5634: LD_INT 75
5636: DOUBLE
5637: EQUAL
5638: IFTRUE 5654
5640: LD_INT 85
5642: DOUBLE
5643: EQUAL
5644: IFTRUE 5654
5646: LD_INT 95
5648: DOUBLE
5649: EQUAL
5650: IFTRUE 5654
5652: GO 5763
5654: POP
// result := Wave5 ( [ 6 , 11 , 15 , 20 , 25 , 30 , 35 , 40 , 45 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 16 , 26 , 36 , 46 , 56 , 66 , 76 , 86 , 96 :
5655: LD_ADDR_VAR 0 2
5659: PUSH
5660: LD_INT 6
5662: PUSH
5663: LD_INT 11
5665: PUSH
5666: LD_INT 15
5668: PUSH
5669: LD_INT 20
5671: PUSH
5672: LD_INT 25
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 35
5680: PUSH
5681: LD_INT 40
5683: PUSH
5684: LD_INT 45
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_VAR 0 1
5702: PUSH
5703: LD_INT 10
5705: DIV
5706: ARRAY
5707: PPUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: LD_INT 4
5716: PUSH
5717: LD_INT 5
5719: PUSH
5720: LD_INT 6
5722: PUSH
5723: LD_INT 7
5725: PUSH
5726: LD_INT 8
5728: PUSH
5729: LD_INT 9
5731: PUSH
5732: LD_INT 10
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: LD_VAR 0 1
5750: PUSH
5751: LD_INT 10
5753: DIV
5754: ARRAY
5755: PPUSH
5756: CALL 7617 0 2
5760: ST_TO_ADDR
5761: GO 6809
5763: LD_INT 16
5765: DOUBLE
5766: EQUAL
5767: IFTRUE 5819
5769: LD_INT 26
5771: DOUBLE
5772: EQUAL
5773: IFTRUE 5819
5775: LD_INT 36
5777: DOUBLE
5778: EQUAL
5779: IFTRUE 5819
5781: LD_INT 46
5783: DOUBLE
5784: EQUAL
5785: IFTRUE 5819
5787: LD_INT 56
5789: DOUBLE
5790: EQUAL
5791: IFTRUE 5819
5793: LD_INT 66
5795: DOUBLE
5796: EQUAL
5797: IFTRUE 5819
5799: LD_INT 76
5801: DOUBLE
5802: EQUAL
5803: IFTRUE 5819
5805: LD_INT 86
5807: DOUBLE
5808: EQUAL
5809: IFTRUE 5819
5811: LD_INT 96
5813: DOUBLE
5814: EQUAL
5815: IFTRUE 5819
5817: GO 5928
5819: POP
// result := Wave6 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 17 , 27 , 37 , 47 , 57 , 67 , 77 , 87 , 97 :
5820: LD_ADDR_VAR 0 2
5824: PUSH
5825: LD_INT 9
5827: PUSH
5828: LD_INT 12
5830: PUSH
5831: LD_INT 15
5833: PUSH
5834: LD_INT 18
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 24
5842: PUSH
5843: LD_INT 27
5845: PUSH
5846: LD_INT 30
5848: PUSH
5849: LD_INT 33
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_VAR 0 1
5867: PUSH
5868: LD_INT 10
5870: DIV
5871: ARRAY
5872: PPUSH
5873: LD_INT 2
5875: PUSH
5876: LD_INT 3
5878: PUSH
5879: LD_INT 4
5881: PUSH
5882: LD_INT 5
5884: PUSH
5885: LD_INT 6
5887: PUSH
5888: LD_INT 7
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: LD_INT 9
5896: PUSH
5897: LD_INT 10
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: PUSH
5911: LD_VAR 0 1
5915: PUSH
5916: LD_INT 10
5918: DIV
5919: ARRAY
5920: PPUSH
5921: CALL 8037 0 2
5925: ST_TO_ADDR
5926: GO 6809
5928: LD_INT 17
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5984
5934: LD_INT 27
5936: DOUBLE
5937: EQUAL
5938: IFTRUE 5984
5940: LD_INT 37
5942: DOUBLE
5943: EQUAL
5944: IFTRUE 5984
5946: LD_INT 47
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5984
5952: LD_INT 57
5954: DOUBLE
5955: EQUAL
5956: IFTRUE 5984
5958: LD_INT 67
5960: DOUBLE
5961: EQUAL
5962: IFTRUE 5984
5964: LD_INT 77
5966: DOUBLE
5967: EQUAL
5968: IFTRUE 5984
5970: LD_INT 87
5972: DOUBLE
5973: EQUAL
5974: IFTRUE 5984
5976: LD_INT 97
5978: DOUBLE
5979: EQUAL
5980: IFTRUE 5984
5982: GO 6093
5984: POP
// result := Wave7 ( [ 14 , 16 , 18 , 22 , 24 , 26 , 28 , 32 , 35 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 18 , 28 , 38 , 48 , 58 , 68 , 78 , 88 , 98 :
5985: LD_ADDR_VAR 0 2
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 16
5995: PUSH
5996: LD_INT 18
5998: PUSH
5999: LD_INT 22
6001: PUSH
6002: LD_INT 24
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 28
6010: PUSH
6011: LD_INT 32
6013: PUSH
6014: LD_INT 35
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: PUSH
6028: LD_VAR 0 1
6032: PUSH
6033: LD_INT 10
6035: DIV
6036: ARRAY
6037: PPUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 3
6043: PUSH
6044: LD_INT 4
6046: PUSH
6047: LD_INT 5
6049: PUSH
6050: LD_INT 6
6052: PUSH
6053: LD_INT 7
6055: PUSH
6056: LD_INT 8
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: LD_INT 10
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: LD_VAR 0 1
6080: PUSH
6081: LD_INT 10
6083: DIV
6084: ARRAY
6085: PPUSH
6086: CALL 8457 0 2
6090: ST_TO_ADDR
6091: GO 6809
6093: LD_INT 18
6095: DOUBLE
6096: EQUAL
6097: IFTRUE 6149
6099: LD_INT 28
6101: DOUBLE
6102: EQUAL
6103: IFTRUE 6149
6105: LD_INT 38
6107: DOUBLE
6108: EQUAL
6109: IFTRUE 6149
6111: LD_INT 48
6113: DOUBLE
6114: EQUAL
6115: IFTRUE 6149
6117: LD_INT 58
6119: DOUBLE
6120: EQUAL
6121: IFTRUE 6149
6123: LD_INT 68
6125: DOUBLE
6126: EQUAL
6127: IFTRUE 6149
6129: LD_INT 78
6131: DOUBLE
6132: EQUAL
6133: IFTRUE 6149
6135: LD_INT 88
6137: DOUBLE
6138: EQUAL
6139: IFTRUE 6149
6141: LD_INT 98
6143: DOUBLE
6144: EQUAL
6145: IFTRUE 6149
6147: GO 6258
6149: POP
// result := Wave8 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 19 , 29 , 39 , 49 , 59 , 69 , 79 , 89 , 99 :
6150: LD_ADDR_VAR 0 2
6154: PUSH
6155: LD_INT 9
6157: PUSH
6158: LD_INT 12
6160: PUSH
6161: LD_INT 15
6163: PUSH
6164: LD_INT 18
6166: PUSH
6167: LD_INT 21
6169: PUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 27
6175: PUSH
6176: LD_INT 30
6178: PUSH
6179: LD_INT 33
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: LD_VAR 0 1
6197: PUSH
6198: LD_INT 10
6200: DIV
6201: ARRAY
6202: PPUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 3
6208: PUSH
6209: LD_INT 4
6211: PUSH
6212: LD_INT 5
6214: PUSH
6215: LD_INT 6
6217: PUSH
6218: LD_INT 7
6220: PUSH
6221: LD_INT 8
6223: PUSH
6224: LD_INT 9
6226: PUSH
6227: LD_INT 10
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_VAR 0 1
6245: PUSH
6246: LD_INT 10
6248: DIV
6249: ARRAY
6250: PPUSH
6251: CALL 8558 0 2
6255: ST_TO_ADDR
6256: GO 6809
6258: LD_INT 19
6260: DOUBLE
6261: EQUAL
6262: IFTRUE 6314
6264: LD_INT 29
6266: DOUBLE
6267: EQUAL
6268: IFTRUE 6314
6270: LD_INT 39
6272: DOUBLE
6273: EQUAL
6274: IFTRUE 6314
6276: LD_INT 49
6278: DOUBLE
6279: EQUAL
6280: IFTRUE 6314
6282: LD_INT 59
6284: DOUBLE
6285: EQUAL
6286: IFTRUE 6314
6288: LD_INT 69
6290: DOUBLE
6291: EQUAL
6292: IFTRUE 6314
6294: LD_INT 79
6296: DOUBLE
6297: EQUAL
6298: IFTRUE 6314
6300: LD_INT 89
6302: DOUBLE
6303: EQUAL
6304: IFTRUE 6314
6306: LD_INT 99
6308: DOUBLE
6309: EQUAL
6310: IFTRUE 6314
6312: GO 6525
6314: POP
// result := Wave8 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ^ Wave5 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 :
6315: LD_ADDR_VAR 0 2
6319: PUSH
6320: LD_INT 4
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: LD_INT 10
6328: PUSH
6329: LD_INT 13
6331: PUSH
6332: LD_INT 14
6334: PUSH
6335: LD_INT 17
6337: PUSH
6338: LD_INT 19
6340: PUSH
6341: LD_INT 21
6343: PUSH
6344: LD_INT 23
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_VAR 0 1
6362: PUSH
6363: LD_INT 10
6365: DIV
6366: ARRAY
6367: PPUSH
6368: LD_INT 2
6370: PUSH
6371: LD_INT 3
6373: PUSH
6374: LD_INT 4
6376: PUSH
6377: LD_INT 5
6379: PUSH
6380: LD_INT 6
6382: PUSH
6383: LD_INT 7
6385: PUSH
6386: LD_INT 8
6388: PUSH
6389: LD_INT 9
6391: PUSH
6392: LD_INT 10
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_VAR 0 1
6410: PUSH
6411: LD_INT 10
6413: DIV
6414: ARRAY
6415: PPUSH
6416: CALL 8558 0 2
6420: PUSH
6421: LD_INT 4
6423: PUSH
6424: LD_INT 7
6426: PUSH
6427: LD_INT 10
6429: PUSH
6430: LD_INT 13
6432: PUSH
6433: LD_INT 14
6435: PUSH
6436: LD_INT 17
6438: PUSH
6439: LD_INT 19
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_INT 25
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: PUSH
6459: LD_VAR 0 1
6463: PUSH
6464: LD_INT 10
6466: DIV
6467: ARRAY
6468: PPUSH
6469: LD_INT 2
6471: PUSH
6472: LD_INT 3
6474: PUSH
6475: LD_INT 4
6477: PUSH
6478: LD_INT 5
6480: PUSH
6481: LD_INT 6
6483: PUSH
6484: LD_INT 7
6486: PUSH
6487: LD_INT 8
6489: PUSH
6490: LD_INT 9
6492: PUSH
6493: LD_INT 10
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_VAR 0 1
6511: PUSH
6512: LD_INT 10
6514: DIV
6515: ARRAY
6516: PPUSH
6517: CALL 7617 0 2
6521: ADD
6522: ST_TO_ADDR
6523: GO 6809
6525: LD_INT 20
6527: DOUBLE
6528: EQUAL
6529: IFTRUE 6581
6531: LD_INT 30
6533: DOUBLE
6534: EQUAL
6535: IFTRUE 6581
6537: LD_INT 40
6539: DOUBLE
6540: EQUAL
6541: IFTRUE 6581
6543: LD_INT 50
6545: DOUBLE
6546: EQUAL
6547: IFTRUE 6581
6549: LD_INT 60
6551: DOUBLE
6552: EQUAL
6553: IFTRUE 6581
6555: LD_INT 70
6557: DOUBLE
6558: EQUAL
6559: IFTRUE 6581
6561: LD_INT 80
6563: DOUBLE
6564: EQUAL
6565: IFTRUE 6581
6567: LD_INT 90
6569: DOUBLE
6570: EQUAL
6571: IFTRUE 6581
6573: LD_INT 100
6575: DOUBLE
6576: EQUAL
6577: IFTRUE 6581
6579: GO 6808
6581: POP
// result := Wave7 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ^ Wave6 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ; end ;
6582: LD_ADDR_VAR 0 2
6586: PUSH
6587: LD_INT 4
6589: PUSH
6590: LD_INT 7
6592: PUSH
6593: LD_INT 10
6595: PUSH
6596: LD_INT 13
6598: PUSH
6599: LD_INT 14
6601: PUSH
6602: LD_INT 17
6604: PUSH
6605: LD_INT 19
6607: PUSH
6608: LD_INT 21
6610: PUSH
6611: LD_INT 23
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: PUSH
6625: LD_VAR 0 1
6629: PUSH
6630: LD_INT 10
6632: DIVREAL
6633: PUSH
6634: LD_INT 1
6636: MINUS
6637: ARRAY
6638: PPUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 3
6644: PUSH
6645: LD_INT 4
6647: PUSH
6648: LD_INT 5
6650: PUSH
6651: LD_INT 6
6653: PUSH
6654: LD_INT 7
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: LD_INT 9
6662: PUSH
6663: LD_INT 10
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: LD_VAR 0 1
6681: PUSH
6682: LD_INT 10
6684: DIVREAL
6685: PUSH
6686: LD_INT 1
6688: MINUS
6689: ARRAY
6690: PPUSH
6691: CALL 8457 0 2
6695: PUSH
6696: LD_INT 4
6698: PUSH
6699: LD_INT 7
6701: PUSH
6702: LD_INT 10
6704: PUSH
6705: LD_INT 13
6707: PUSH
6708: LD_INT 14
6710: PUSH
6711: LD_INT 17
6713: PUSH
6714: LD_INT 19
6716: PUSH
6717: LD_INT 22
6719: PUSH
6720: LD_INT 25
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_VAR 0 1
6738: PUSH
6739: LD_INT 10
6741: DIVREAL
6742: PUSH
6743: LD_INT 1
6745: MINUS
6746: ARRAY
6747: PPUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 3
6753: PUSH
6754: LD_INT 4
6756: PUSH
6757: LD_INT 5
6759: PUSH
6760: LD_INT 6
6762: PUSH
6763: LD_INT 7
6765: PUSH
6766: LD_INT 8
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: LD_INT 10
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_VAR 0 1
6790: PUSH
6791: LD_INT 10
6793: DIVREAL
6794: PUSH
6795: LD_INT 1
6797: MINUS
6798: ARRAY
6799: PPUSH
6800: CALL 8037 0 2
6804: ADD
6805: ST_TO_ADDR
6806: GO 6809
6808: POP
// for i in result do
6809: LD_ADDR_VAR 0 3
6813: PUSH
6814: LD_VAR 0 2
6818: PUSH
6819: FOR_IN
6820: IFFALSE 6993
// begin a := rand ( 1 , 2 ) ;
6822: LD_ADDR_VAR 0 8
6826: PUSH
6827: LD_INT 1
6829: PPUSH
6830: LD_INT 2
6832: PPUSH
6833: CALL_OW 12
6837: ST_TO_ADDR
// if a = 1 then
6838: LD_VAR 0 8
6842: PUSH
6843: LD_INT 1
6845: EQUAL
6846: IFFALSE 6862
// SetDir ( i , 3 ) else
6848: LD_VAR 0 3
6852: PPUSH
6853: LD_INT 3
6855: PPUSH
6856: CALL_OW 233
6860: GO 6874
// SetDir ( i , 5 ) ;
6862: LD_VAR 0 3
6866: PPUSH
6867: LD_INT 5
6869: PPUSH
6870: CALL_OW 233
// PlaceUnitArea ( i , area [ a ] , false ) ;
6874: LD_VAR 0 3
6878: PPUSH
6879: LD_VAR 0 7
6883: PUSH
6884: LD_VAR 0 8
6888: ARRAY
6889: PPUSH
6890: LD_INT 0
6892: PPUSH
6893: CALL_OW 49
// if GetControl ( i ) = control_manual then
6897: LD_VAR 0 3
6901: PPUSH
6902: CALL_OW 263
6906: PUSH
6907: LD_INT 1
6909: EQUAL
6910: IFFALSE 6956
// begin uc_nation := GetNation ( i ) ;
6912: LD_ADDR_OWVAR 21
6916: PUSH
6917: LD_VAR 0 3
6921: PPUSH
6922: CALL_OW 248
6926: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
6927: LD_INT 0
6929: PPUSH
6930: LD_INT 3
6932: PPUSH
6933: LD_VAR 0 5
6937: PPUSH
6938: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
6942: CALL_OW 44
6946: PPUSH
6947: LD_VAR 0 3
6951: PPUSH
6952: CALL_OW 52
// end ; l := l + 1 ;
6956: LD_ADDR_VAR 0 9
6960: PUSH
6961: LD_VAR 0 9
6965: PUSH
6966: LD_INT 1
6968: PLUS
6969: ST_TO_ADDR
// if l mod 10 = 0 then
6970: LD_VAR 0 9
6974: PUSH
6975: LD_INT 10
6977: MOD
6978: PUSH
6979: LD_INT 0
6981: EQUAL
6982: IFFALSE 6991
// Wait ( 0 0$02 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6819
6993: POP
6994: POP
// end ;
6995: LD_VAR 0 2
6999: RET
// export function Wave1 ( n , skill ) ; var i , un ; begin
7000: LD_INT 0
7002: PPUSH
7003: PPUSH
7004: PPUSH
// uc_nation := nation_nature ;
7005: LD_ADDR_OWVAR 21
7009: PUSH
7010: LD_INT 0
7012: ST_TO_ADDR
// for i = 1 to n do
7013: LD_ADDR_VAR 0 4
7017: PUSH
7018: DOUBLE
7019: LD_INT 1
7021: DEC
7022: ST_TO_ADDR
7023: LD_VAR 0 1
7027: PUSH
7028: FOR_TO
7029: IFFALSE 7064
// begin PrepareHuman ( false , class_apeman , skill ) ;
7031: LD_INT 0
7033: PPUSH
7034: LD_INT 12
7036: PPUSH
7037: LD_VAR 0 2
7041: PPUSH
7042: CALL_OW 380
// result := result ^ CreateHuman ;
7046: LD_ADDR_VAR 0 3
7050: PUSH
7051: LD_VAR 0 3
7055: PUSH
7056: CALL_OW 44
7060: ADD
7061: ST_TO_ADDR
// end ;
7062: GO 7028
7064: POP
7065: POP
// end ;
7066: LD_VAR 0 3
7070: RET
// export function Wave2 ( n , skill ) ; var i , un ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
// uc_nation := nation_nature ;
7076: LD_ADDR_OWVAR 21
7080: PUSH
7081: LD_INT 0
7083: ST_TO_ADDR
// for i = 1 to n do
7084: LD_ADDR_VAR 0 4
7088: PUSH
7089: DOUBLE
7090: LD_INT 1
7092: DEC
7093: ST_TO_ADDR
7094: LD_VAR 0 1
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7135
// begin PrepareHuman ( false , class_apeman_soldier , skill ) ;
7102: LD_INT 0
7104: PPUSH
7105: LD_INT 15
7107: PPUSH
7108: LD_VAR 0 2
7112: PPUSH
7113: CALL_OW 380
// result := result ^ CreateHuman ;
7117: LD_ADDR_VAR 0 3
7121: PUSH
7122: LD_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ADD
7132: ST_TO_ADDR
// end ;
7133: GO 7099
7135: POP
7136: POP
// end ;
7137: LD_VAR 0 3
7141: RET
// export function Wave3 ( n , skill ) ; var i , un ; begin
7142: LD_INT 0
7144: PPUSH
7145: PPUSH
7146: PPUSH
// for i = 1 to n do
7147: LD_ADDR_VAR 0 4
7151: PUSH
7152: DOUBLE
7153: LD_INT 1
7155: DEC
7156: ST_TO_ADDR
7157: LD_VAR 0 1
7161: PUSH
7162: FOR_TO
7163: IFFALSE 7214
// begin uc_nation := rand ( 1 , 3 ) ;
7165: LD_ADDR_OWVAR 21
7169: PUSH
7170: LD_INT 1
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: CALL_OW 12
7180: ST_TO_ADDR
// PrepareHuman ( false , class_soldier , skill ) ;
7181: LD_INT 0
7183: PPUSH
7184: LD_INT 1
7186: PPUSH
7187: LD_VAR 0 2
7191: PPUSH
7192: CALL_OW 380
// result := result ^ CreateHuman ;
7196: LD_ADDR_VAR 0 3
7200: PUSH
7201: LD_VAR 0 3
7205: PUSH
7206: CALL_OW 44
7210: ADD
7211: ST_TO_ADDR
// end ;
7212: GO 7162
7214: POP
7215: POP
// end ;
7216: LD_VAR 0 3
7220: RET
// export function Wave4 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7221: LD_INT 0
7223: PPUSH
7224: PPUSH
7225: PPUSH
7226: PPUSH
7227: PPUSH
7228: PPUSH
7229: PPUSH
// for i = 1 to n do
7230: LD_ADDR_VAR 0 4
7234: PUSH
7235: DOUBLE
7236: LD_INT 1
7238: DEC
7239: ST_TO_ADDR
7240: LD_VAR 0 1
7244: PUSH
7245: FOR_TO
7246: IFFALSE 7610
// begin uc_nation := rand ( 1 , 3 ) ;
7248: LD_ADDR_OWVAR 21
7252: PUSH
7253: LD_INT 1
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 12
7263: ST_TO_ADDR
// case uc_nation of 1 :
7264: LD_OWVAR 21
7268: PUSH
7269: LD_INT 1
7271: DOUBLE
7272: EQUAL
7273: IFTRUE 7277
7275: GO 7340
7277: POP
// begin chassis := [ us_light_wheeled , us_medium_wheeled ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: LD_INT 2
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: ST_TO_ADDR
// weapons := [ us_machine_gun , us_light_gun ] ;
7293: LD_ADDR_VAR 0 7
7297: PUSH
7298: LD_INT 2
7300: PUSH
7301: LD_INT 3
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7308: LD_ADDR_VAR 0 8
7312: PUSH
7313: LD_INT 1
7315: PUSH
7316: LD_INT 3
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7323: LD_ADDR_VAR 0 9
7327: PUSH
7328: LD_INT 1
7330: PUSH
7331: LD_INT 2
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: ST_TO_ADDR
// end ; 2 :
7338: GO 7475
7340: LD_INT 2
7342: DOUBLE
7343: EQUAL
7344: IFTRUE 7348
7346: GO 7411
7348: POP
// begin chassis := [ ar_light_trike , ar_hovercraft ] ;
7349: LD_ADDR_VAR 0 6
7353: PUSH
7354: LD_INT 12
7356: PUSH
7357: LD_INT 11
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: ST_TO_ADDR
// weapons := [ ar_light_gun , ar_double_machine_gun ] ;
7364: LD_ADDR_VAR 0 7
7368: PUSH
7369: LD_INT 23
7371: PUSH
7372: LD_INT 24
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7379: LD_ADDR_VAR 0 8
7383: PUSH
7384: LD_INT 1
7386: PUSH
7387: LD_INT 5
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7394: LD_ADDR_VAR 0 9
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: ST_TO_ADDR
// end ; 3 :
7409: GO 7475
7411: LD_INT 3
7413: DOUBLE
7414: EQUAL
7415: IFTRUE 7419
7417: GO 7474
7419: POP
// begin chassis := [ ru_medium_wheeled ] ;
7420: LD_ADDR_VAR 0 6
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: EMPTY
7429: LIST
7430: ST_TO_ADDR
// weapons := [ ru_heavy_machine_gun , ru_gun ] ;
7431: LD_ADDR_VAR 0 7
7435: PUSH
7436: LD_INT 42
7438: PUSH
7439: LD_INT 44
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7446: LD_ADDR_VAR 0 8
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 3
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: ST_TO_ADDR
// engine := [ engine_combustion ] ;
7461: LD_ADDR_VAR 0 9
7465: PUSH
7466: LD_INT 1
7468: PUSH
7469: EMPTY
7470: LIST
7471: ST_TO_ADDR
// end ; end ;
7472: GO 7475
7474: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7475: LD_ADDR_OWVAR 37
7479: PUSH
7480: LD_VAR 0 6
7484: PUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_VAR 0 6
7492: PPUSH
7493: CALL_OW 12
7497: ARRAY
7498: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7499: LD_ADDR_OWVAR 39
7503: PUSH
7504: LD_VAR 0 9
7508: PUSH
7509: LD_INT 1
7511: PPUSH
7512: LD_VAR 0 9
7516: PPUSH
7517: CALL_OW 12
7521: ARRAY
7522: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7523: LD_ADDR_OWVAR 38
7527: PUSH
7528: LD_VAR 0 8
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 12
7545: ARRAY
7546: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7547: LD_ADDR_OWVAR 40
7551: PUSH
7552: LD_VAR 0 7
7556: PUSH
7557: LD_INT 1
7559: PPUSH
7560: LD_VAR 0 7
7564: PPUSH
7565: CALL_OW 12
7569: ARRAY
7570: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7571: LD_ADDR_OWVAR 41
7575: PUSH
7576: LD_INT 100
7578: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7579: LD_ADDR_VAR 0 3
7583: PUSH
7584: LD_VAR 0 3
7588: PPUSH
7589: LD_VAR 0 3
7593: PUSH
7594: LD_INT 1
7596: PLUS
7597: PPUSH
7598: CALL_OW 45
7602: PPUSH
7603: CALL_OW 2
7607: ST_TO_ADDR
// end ;
7608: GO 7245
7610: POP
7611: POP
// end ;
7612: LD_VAR 0 3
7616: RET
// export function Wave5 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
// for i = 1 to n do
7626: LD_ADDR_VAR 0 4
7630: PUSH
7631: DOUBLE
7632: LD_INT 1
7634: DEC
7635: ST_TO_ADDR
7636: LD_VAR 0 1
7640: PUSH
7641: FOR_TO
7642: IFFALSE 8030
// begin uc_nation := rand ( 1 , 3 ) ;
7644: LD_ADDR_OWVAR 21
7648: PUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 3
7654: PPUSH
7655: CALL_OW 12
7659: ST_TO_ADDR
// case uc_nation of 1 :
7660: LD_OWVAR 21
7664: PUSH
7665: LD_INT 1
7667: DOUBLE
7668: EQUAL
7669: IFTRUE 7673
7671: GO 7744
7673: POP
// begin chassis := [ us_medium_wheeled , us_medium_tracked ] ;
7674: LD_ADDR_VAR 0 6
7678: PUSH
7679: LD_INT 2
7681: PUSH
7682: LD_INT 3
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_double_gun , us_laser ] ;
7689: LD_ADDR_VAR 0 7
7693: PUSH
7694: LD_INT 4
7696: PUSH
7697: LD_INT 5
7699: PUSH
7700: LD_INT 9
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7708: LD_ADDR_VAR 0 8
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7723: LD_ADDR_VAR 0 9
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 3
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: ST_TO_ADDR
// end ; 2 :
7742: GO 7895
7744: LD_INT 2
7746: DOUBLE
7747: EQUAL
7748: IFTRUE 7752
7750: GO 7823
7752: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
7753: LD_ADDR_VAR 0 6
7757: PUSH
7758: LD_INT 13
7760: PUSH
7761: LD_INT 14
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_gatling_gun ] ;
7768: LD_ADDR_VAR 0 7
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 26
7778: PUSH
7779: LD_INT 25
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7787: LD_ADDR_VAR 0 8
7791: PUSH
7792: LD_INT 1
7794: PUSH
7795: LD_INT 5
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7802: LD_ADDR_VAR 0 9
7806: PUSH
7807: LD_INT 1
7809: PUSH
7810: LD_INT 2
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: ST_TO_ADDR
// end ; 3 :
7821: GO 7895
7823: LD_INT 3
7825: DOUBLE
7826: EQUAL
7827: IFTRUE 7831
7829: GO 7894
7831: POP
// begin chassis := [ ru_medium_tracked , ru_medium_wheeled ] ;
7832: LD_ADDR_VAR 0 6
7836: PUSH
7837: LD_INT 22
7839: PUSH
7840: LD_INT 21
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: ST_TO_ADDR
// weapons := [ ru_gun , ru_gatling_gun ] ;
7847: LD_ADDR_VAR 0 7
7851: PUSH
7852: LD_INT 44
7854: PUSH
7855: LD_INT 43
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7862: LD_ADDR_VAR 0 8
7866: PUSH
7867: LD_INT 1
7869: PUSH
7870: LD_INT 3
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
7877: LD_ADDR_VAR 0 9
7881: PUSH
7882: LD_INT 1
7884: PUSH
7885: LD_INT 3
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: ST_TO_ADDR
// end ; end ;
7892: GO 7895
7894: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7895: LD_ADDR_OWVAR 37
7899: PUSH
7900: LD_VAR 0 6
7904: PUSH
7905: LD_INT 1
7907: PPUSH
7908: LD_VAR 0 6
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7919: LD_ADDR_OWVAR 39
7923: PUSH
7924: LD_VAR 0 9
7928: PUSH
7929: LD_INT 1
7931: PPUSH
7932: LD_VAR 0 9
7936: PPUSH
7937: CALL_OW 12
7941: ARRAY
7942: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7943: LD_ADDR_OWVAR 38
7947: PUSH
7948: LD_VAR 0 8
7952: PUSH
7953: LD_INT 1
7955: PPUSH
7956: LD_VAR 0 8
7960: PPUSH
7961: CALL_OW 12
7965: ARRAY
7966: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7967: LD_ADDR_OWVAR 40
7971: PUSH
7972: LD_VAR 0 7
7976: PUSH
7977: LD_INT 1
7979: PPUSH
7980: LD_VAR 0 7
7984: PPUSH
7985: CALL_OW 12
7989: ARRAY
7990: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7991: LD_ADDR_OWVAR 41
7995: PUSH
7996: LD_INT 100
7998: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7999: LD_ADDR_VAR 0 3
8003: PUSH
8004: LD_VAR 0 3
8008: PPUSH
8009: LD_VAR 0 3
8013: PUSH
8014: LD_INT 1
8016: PLUS
8017: PPUSH
8018: CALL_OW 45
8022: PPUSH
8023: CALL_OW 2
8027: ST_TO_ADDR
// end ;
8028: GO 7641
8030: POP
8031: POP
// end ;
8032: LD_VAR 0 3
8036: RET
// export function Wave6 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8037: LD_INT 0
8039: PPUSH
8040: PPUSH
8041: PPUSH
8042: PPUSH
8043: PPUSH
8044: PPUSH
8045: PPUSH
// for i = 1 to n do
8046: LD_ADDR_VAR 0 4
8050: PUSH
8051: DOUBLE
8052: LD_INT 1
8054: DEC
8055: ST_TO_ADDR
8056: LD_VAR 0 1
8060: PUSH
8061: FOR_TO
8062: IFFALSE 8450
// begin uc_nation := rand ( 1 , 3 ) ;
8064: LD_ADDR_OWVAR 21
8068: PUSH
8069: LD_INT 1
8071: PPUSH
8072: LD_INT 3
8074: PPUSH
8075: CALL_OW 12
8079: ST_TO_ADDR
// case uc_nation of 1 :
8080: LD_OWVAR 21
8084: PUSH
8085: LD_INT 1
8087: DOUBLE
8088: EQUAL
8089: IFTRUE 8093
8091: GO 8160
8093: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8094: LD_ADDR_VAR 0 6
8098: PUSH
8099: LD_INT 4
8101: PUSH
8102: LD_INT 5
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_laser ] ;
8109: LD_ADDR_VAR 0 7
8113: PUSH
8114: LD_INT 6
8116: PUSH
8117: LD_INT 7
8119: PUSH
8120: LD_INT 9
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8128: LD_ADDR_VAR 0 8
8132: PUSH
8133: LD_INT 1
8135: PUSH
8136: LD_INT 3
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8143: LD_ADDR_VAR 0 9
8147: PUSH
8148: LD_INT 1
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: ST_TO_ADDR
// end ; 2 :
8158: GO 8315
8160: LD_INT 2
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8243
8168: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: LD_INT 13
8176: PUSH
8177: LD_INT 14
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8184: LD_ADDR_VAR 0 7
8188: PUSH
8189: LD_INT 27
8191: PUSH
8192: LD_INT 26
8194: PUSH
8195: LD_INT 28
8197: PUSH
8198: LD_INT 29
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8207: LD_ADDR_VAR 0 8
8211: PUSH
8212: LD_INT 1
8214: PUSH
8215: LD_INT 5
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8222: LD_ADDR_VAR 0 9
8226: PUSH
8227: LD_INT 1
8229: PUSH
8230: LD_INT 2
8232: PUSH
8233: LD_INT 3
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: LIST
8240: ST_TO_ADDR
// end ; 3 :
8241: GO 8315
8243: LD_INT 3
8245: DOUBLE
8246: EQUAL
8247: IFTRUE 8251
8249: GO 8314
8251: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8252: LD_ADDR_VAR 0 6
8256: PUSH
8257: LD_INT 23
8259: PUSH
8260: LD_INT 24
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher ] ;
8267: LD_ADDR_VAR 0 7
8271: PUSH
8272: LD_INT 46
8274: PUSH
8275: LD_INT 45
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8282: LD_ADDR_VAR 0 8
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: LD_INT 3
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8297: LD_ADDR_VAR 0 9
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 3
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: ST_TO_ADDR
// end ; end ;
8312: GO 8315
8314: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8315: LD_ADDR_OWVAR 37
8319: PUSH
8320: LD_VAR 0 6
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_VAR 0 6
8332: PPUSH
8333: CALL_OW 12
8337: ARRAY
8338: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8339: LD_ADDR_OWVAR 39
8343: PUSH
8344: LD_VAR 0 9
8348: PUSH
8349: LD_INT 1
8351: PPUSH
8352: LD_VAR 0 9
8356: PPUSH
8357: CALL_OW 12
8361: ARRAY
8362: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8363: LD_ADDR_OWVAR 38
8367: PUSH
8368: LD_VAR 0 8
8372: PUSH
8373: LD_INT 1
8375: PPUSH
8376: LD_VAR 0 8
8380: PPUSH
8381: CALL_OW 12
8385: ARRAY
8386: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8387: LD_ADDR_OWVAR 40
8391: PUSH
8392: LD_VAR 0 7
8396: PUSH
8397: LD_INT 1
8399: PPUSH
8400: LD_VAR 0 7
8404: PPUSH
8405: CALL_OW 12
8409: ARRAY
8410: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8411: LD_ADDR_OWVAR 41
8415: PUSH
8416: LD_INT 100
8418: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8419: LD_ADDR_VAR 0 3
8423: PUSH
8424: LD_VAR 0 3
8428: PPUSH
8429: LD_VAR 0 3
8433: PUSH
8434: LD_INT 1
8436: PLUS
8437: PPUSH
8438: CALL_OW 45
8442: PPUSH
8443: CALL_OW 2
8447: ST_TO_ADDR
// end ;
8448: GO 8061
8450: POP
8451: POP
// end ;
8452: LD_VAR 0 3
8456: RET
// export function Wave7 ( n , skill ) ; var i ; begin
8457: LD_INT 0
8459: PPUSH
8460: PPUSH
// for i = 1 to n do
8461: LD_ADDR_VAR 0 4
8465: PUSH
8466: DOUBLE
8467: LD_INT 1
8469: DEC
8470: ST_TO_ADDR
8471: LD_VAR 0 1
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8551
// begin uc_nation := rand ( 1 , 3 ) ;
8479: LD_ADDR_OWVAR 21
8483: PUSH
8484: LD_INT 1
8486: PPUSH
8487: LD_INT 3
8489: PPUSH
8490: CALL_OW 12
8494: ST_TO_ADDR
// PrepareHuman ( false , [ class_mortar , class_bazooker , class_soldier ] [ rand ( 1 , 3 ) ] , skill ) ;
8495: LD_INT 0
8497: PPUSH
8498: LD_INT 8
8500: PUSH
8501: LD_INT 9
8503: PUSH
8504: LD_INT 1
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 1
8514: PPUSH
8515: LD_INT 3
8517: PPUSH
8518: CALL_OW 12
8522: ARRAY
8523: PPUSH
8524: LD_VAR 0 2
8528: PPUSH
8529: CALL_OW 380
// result := result ^ CreateHuman ;
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_VAR 0 3
8542: PUSH
8543: CALL_OW 44
8547: ADD
8548: ST_TO_ADDR
// end ;
8549: GO 8476
8551: POP
8552: POP
// end ;
8553: LD_VAR 0 3
8557: RET
// export function Wave8 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8558: LD_INT 0
8560: PPUSH
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// for i = 1 to n do
8567: LD_ADDR_VAR 0 4
8571: PUSH
8572: DOUBLE
8573: LD_INT 1
8575: DEC
8576: ST_TO_ADDR
8577: LD_VAR 0 1
8581: PUSH
8582: FOR_TO
8583: IFFALSE 8979
// begin uc_nation := rand ( 1 , 3 ) ;
8585: LD_ADDR_OWVAR 21
8589: PUSH
8590: LD_INT 1
8592: PPUSH
8593: LD_INT 3
8595: PPUSH
8596: CALL_OW 12
8600: ST_TO_ADDR
// case uc_nation of 1 :
8601: LD_OWVAR 21
8605: PUSH
8606: LD_INT 1
8608: DOUBLE
8609: EQUAL
8610: IFTRUE 8614
8612: GO 8687
8614: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8615: LD_ADDR_VAR 0 6
8619: PUSH
8620: LD_INT 4
8622: PUSH
8623: LD_INT 5
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_double_laser , us_artillery ] ;
8630: LD_ADDR_VAR 0 7
8634: PUSH
8635: LD_INT 6
8637: PUSH
8638: LD_INT 7
8640: PUSH
8641: LD_INT 10
8643: PUSH
8644: LD_EXP 17
8648: PUSH
8649: EMPTY
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8655: LD_ADDR_VAR 0 8
8659: PUSH
8660: LD_INT 1
8662: PUSH
8663: LD_INT 3
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8670: LD_ADDR_VAR 0 9
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: ST_TO_ADDR
// end ; 2 :
8685: GO 8844
8687: LD_INT 2
8689: DOUBLE
8690: EQUAL
8691: IFTRUE 8695
8693: GO 8768
8695: POP
// begin chassis := [ ar_half_tracked ] ;
8696: LD_ADDR_VAR 0 6
8700: PUSH
8701: LD_INT 14
8703: PUSH
8704: EMPTY
8705: LIST
8706: ST_TO_ADDR
// weapons := [ ar_bio_bomb , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8707: LD_ADDR_VAR 0 7
8711: PUSH
8712: LD_EXP 18
8716: PUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 28
8722: PUSH
8723: LD_INT 29
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: LIST
8730: LIST
8731: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8732: LD_ADDR_VAR 0 8
8736: PUSH
8737: LD_INT 1
8739: PUSH
8740: LD_INT 5
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8747: LD_ADDR_VAR 0 9
8751: PUSH
8752: LD_INT 1
8754: PUSH
8755: LD_INT 2
8757: PUSH
8758: LD_INT 3
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: ST_TO_ADDR
// end ; 3 :
8766: GO 8844
8768: LD_INT 3
8770: DOUBLE
8771: EQUAL
8772: IFTRUE 8776
8774: GO 8843
8776: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8777: LD_ADDR_VAR 0 6
8781: PUSH
8782: LD_INT 23
8784: PUSH
8785: LD_INT 24
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher , ru_time_lapser ] ;
8792: LD_ADDR_VAR 0 7
8796: PUSH
8797: LD_INT 46
8799: PUSH
8800: LD_INT 45
8802: PUSH
8803: LD_INT 49
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8811: LD_ADDR_VAR 0 8
8815: PUSH
8816: LD_INT 1
8818: PUSH
8819: LD_INT 3
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8826: LD_ADDR_VAR 0 9
8830: PUSH
8831: LD_INT 1
8833: PUSH
8834: LD_INT 3
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: ST_TO_ADDR
// end ; end ;
8841: GO 8844
8843: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8844: LD_ADDR_OWVAR 37
8848: PUSH
8849: LD_VAR 0 6
8853: PUSH
8854: LD_INT 1
8856: PPUSH
8857: LD_VAR 0 6
8861: PPUSH
8862: CALL_OW 12
8866: ARRAY
8867: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8868: LD_ADDR_OWVAR 39
8872: PUSH
8873: LD_VAR 0 9
8877: PUSH
8878: LD_INT 1
8880: PPUSH
8881: LD_VAR 0 9
8885: PPUSH
8886: CALL_OW 12
8890: ARRAY
8891: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8892: LD_ADDR_OWVAR 38
8896: PUSH
8897: LD_VAR 0 8
8901: PUSH
8902: LD_INT 1
8904: PPUSH
8905: LD_VAR 0 8
8909: PPUSH
8910: CALL_OW 12
8914: ARRAY
8915: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8916: LD_ADDR_OWVAR 40
8920: PUSH
8921: LD_VAR 0 7
8925: PUSH
8926: LD_INT 1
8928: PPUSH
8929: LD_VAR 0 7
8933: PPUSH
8934: CALL_OW 12
8938: ARRAY
8939: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8940: LD_ADDR_OWVAR 41
8944: PUSH
8945: LD_INT 100
8947: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8948: LD_ADDR_VAR 0 3
8952: PUSH
8953: LD_VAR 0 3
8957: PPUSH
8958: LD_VAR 0 3
8962: PUSH
8963: LD_INT 1
8965: PLUS
8966: PPUSH
8967: CALL_OW 45
8971: PPUSH
8972: CALL_OW 2
8976: ST_TO_ADDR
// end ;
8977: GO 8582
8979: POP
8980: POP
// end ; end_of_file
8981: LD_VAR 0 3
8985: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 7 ] ) do var i , un , tmp ;
8986: LD_INT 22
8988: PUSH
8989: LD_INT 7
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PPUSH
8996: CALL_OW 69
9000: IFFALSE 9506
9002: GO 9004
9004: DISABLE
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
// begin enable ;
9010: ENABLE
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9011: LD_ADDR_VAR 0 3
9015: PUSH
9016: LD_INT 22
9018: PUSH
9019: LD_INT 7
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: ST_TO_ADDR
// for i in tmp do
9031: LD_ADDR_VAR 0 1
9035: PUSH
9036: LD_VAR 0 3
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9504
// begin case GetType ( i ) of unit_human :
9044: LD_VAR 0 1
9048: PPUSH
9049: CALL_OW 247
9053: PUSH
9054: LD_INT 1
9056: DOUBLE
9057: EQUAL
9058: IFTRUE 9062
9060: GO 9261
9062: POP
// begin if GetLives ( i ) < 250 and GetTech ( 5 , 7 ) <> state_researched then
9063: LD_VAR 0 1
9067: PPUSH
9068: CALL_OW 256
9072: PUSH
9073: LD_INT 250
9075: LESS
9076: PUSH
9077: LD_INT 5
9079: PPUSH
9080: LD_INT 7
9082: PPUSH
9083: CALL_OW 321
9087: PUSH
9088: LD_INT 2
9090: NONEQUAL
9091: AND
9092: IFFALSE 9096
// continue ;
9094: GO 9041
// if GetClass ( i ) in [ 12 , 15 , 16 , 17 , 1 , 5 , 6 , 7 , 8 , 9 ] then
9096: LD_VAR 0 1
9100: PPUSH
9101: CALL_OW 257
9105: PUSH
9106: LD_INT 12
9108: PUSH
9109: LD_INT 15
9111: PUSH
9112: LD_INT 16
9114: PUSH
9115: LD_INT 17
9117: PUSH
9118: LD_INT 1
9120: PUSH
9121: LD_INT 5
9123: PUSH
9124: LD_INT 6
9126: PUSH
9127: LD_INT 7
9129: PUSH
9130: LD_INT 8
9132: PUSH
9133: LD_INT 9
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: IN
9148: IFFALSE 9186
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9150: LD_VAR 0 1
9154: PPUSH
9155: LD_INT 22
9157: PUSH
9158: LD_OWVAR 2
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 69
9171: PPUSH
9172: LD_VAR 0 1
9176: PPUSH
9177: CALL_OW 74
9181: PPUSH
9182: CALL_OW 115
// if GetClass ( i ) = 3 then
9186: LD_VAR 0 1
9190: PPUSH
9191: CALL_OW 257
9195: PUSH
9196: LD_INT 3
9198: EQUAL
9199: IFFALSE 9259
// if IsInUnit ( i ) then
9201: LD_VAR 0 1
9205: PPUSH
9206: CALL_OW 310
9210: IFFALSE 9250
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) else
9212: LD_VAR 0 1
9216: PPUSH
9217: LD_INT 22
9219: PUSH
9220: LD_OWVAR 2
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: PPUSH
9229: CALL_OW 69
9233: PPUSH
9234: LD_VAR 0 1
9238: PPUSH
9239: CALL_OW 74
9243: PPUSH
9244: CALL_OW 115
9248: GO 9259
// ComEspace ( i ) ;
9250: LD_VAR 0 1
9254: PPUSH
9255: CALL 2259 0 1
// end ; unit_vehicle :
9259: GO 9502
9261: LD_INT 2
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9501
9269: POP
// begin if GetLives ( i ) > 250 then
9270: LD_VAR 0 1
9274: PPUSH
9275: CALL_OW 256
9279: PUSH
9280: LD_INT 250
9282: GREATER
9283: IFFALSE 9499
// begin if GetWeapon ( i ) = us_artillery then
9285: LD_VAR 0 1
9289: PPUSH
9290: CALL_OW 264
9294: PUSH
9295: LD_EXP 17
9299: EQUAL
9300: IFFALSE 9368
// begin if IsInArea ( i , zoneOut ) then
9302: LD_VAR 0 1
9306: PPUSH
9307: LD_INT 4
9309: PPUSH
9310: CALL_OW 308
9314: IFFALSE 9330
// ComMoveToArea ( i , zoneBorder ) else
9316: LD_VAR 0 1
9320: PPUSH
9321: LD_INT 9
9323: PPUSH
9324: CALL_OW 113
9328: GO 9366
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 22
9337: PUSH
9338: LD_OWVAR 2
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: PPUSH
9347: CALL_OW 69
9351: PPUSH
9352: LD_VAR 0 1
9356: PPUSH
9357: CALL_OW 74
9361: PPUSH
9362: CALL_OW 115
// end else
9366: GO 9499
// if GetWeapon ( i ) in [ us_radar , ar_radar , ru_radar , ru_time_lapser ] then
9368: LD_VAR 0 1
9372: PPUSH
9373: CALL_OW 264
9377: PUSH
9378: LD_INT 11
9380: PUSH
9381: LD_INT 30
9383: PUSH
9384: LD_EXP 14
9388: PUSH
9389: LD_INT 49
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: IN
9398: IFFALSE 9428
// begin if IsInArea ( i , zoneOut ) then
9400: LD_VAR 0 1
9404: PPUSH
9405: LD_INT 4
9407: PPUSH
9408: CALL_OW 308
9412: IFFALSE 9426
// ComSpecMove ( i , specPos ) ;
9414: LD_VAR 0 1
9418: PPUSH
9419: LD_INT 8
9421: PPUSH
9422: CALL 2305 0 2
// end else
9426: GO 9499
// if GetWeapon ( i ) in [ ar_bio_bomb , ar_selfpropelled_bomb ] then
9428: LD_VAR 0 1
9432: PPUSH
9433: CALL_OW 264
9437: PUSH
9438: LD_EXP 18
9442: PUSH
9443: LD_INT 29
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: IN
9450: IFFALSE 9463
// ComSpecAttack ( i ) else
9452: LD_VAR 0 1
9456: PPUSH
9457: CALL 2733 0 1
9461: GO 9499
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9463: LD_VAR 0 1
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_OWVAR 2
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PPUSH
9480: CALL_OW 69
9484: PPUSH
9485: LD_VAR 0 1
9489: PPUSH
9490: CALL_OW 74
9494: PPUSH
9495: CALL_OW 115
// end ; end ; end ;
9499: GO 9502
9501: POP
// end ;
9502: GO 9041
9504: POP
9505: POP
// end ; end_of_file
9506: PPOPN 3
9508: END
// export function InitDisplay ; begin
9509: LD_INT 0
9511: PPUSH
// while true do
9512: LD_INT 1
9514: IFFALSE 9601
// begin if waveNumber < 100 then
9516: LD_EXP 5
9520: PUSH
9521: LD_INT 100
9523: LESS
9524: IFFALSE 9575
// Display_Strings := [ #Tick , tick , #Points , points , #Attack , timeToNextAttack , #Wave , waveNumber ] else
9526: LD_ADDR_OWVAR 47
9530: PUSH
9531: LD_STRING #Tick
9533: PUSH
9534: LD_OWVAR 1
9538: PUSH
9539: LD_STRING #Points
9541: PUSH
9542: LD_EXP 2
9546: PUSH
9547: LD_STRING #Attack
9549: PUSH
9550: LD_EXP 4
9554: PUSH
9555: LD_STRING #Wave
9557: PUSH
9558: LD_EXP 5
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: ST_TO_ADDR
9573: GO 9592
// Display_Strings := [ #Win , points ] ;
9575: LD_ADDR_OWVAR 47
9579: PUSH
9580: LD_STRING #Win
9582: PUSH
9583: LD_EXP 2
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
9592: LD_INT 35
9594: PPUSH
9595: CALL_OW 67
// end ;
9599: GO 9512
// end ; end_of_file
9601: LD_VAR 0 1
9605: RET
// export function InitBonus ; var i , chance ; begin
9606: LD_INT 0
9608: PPUSH
9609: PPUSH
9610: PPUSH
// chance := rand ( 1 , 99 ) ;
9611: LD_ADDR_VAR 0 3
9615: PUSH
9616: LD_INT 1
9618: PPUSH
9619: LD_INT 99
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// case chance of 1 .. 10 :
9627: LD_VAR 0 3
9631: PUSH
9632: LD_INT 1
9634: DOUBLE
9635: GREATEREQUAL
9636: IFFALSE 9644
9638: LD_INT 10
9640: DOUBLE
9641: LESSEQUAL
9642: IFTRUE 9646
9644: GO 9657
9646: POP
// i := 5 ; 11 .. 25 :
9647: LD_ADDR_VAR 0 2
9651: PUSH
9652: LD_INT 5
9654: ST_TO_ADDR
9655: GO 9758
9657: LD_INT 11
9659: DOUBLE
9660: GREATEREQUAL
9661: IFFALSE 9669
9663: LD_INT 25
9665: DOUBLE
9666: LESSEQUAL
9667: IFTRUE 9671
9669: GO 9682
9671: POP
// i := 3 ; 26 .. 40 :
9672: LD_ADDR_VAR 0 2
9676: PUSH
9677: LD_INT 3
9679: ST_TO_ADDR
9680: GO 9758
9682: LD_INT 26
9684: DOUBLE
9685: GREATEREQUAL
9686: IFFALSE 9694
9688: LD_INT 40
9690: DOUBLE
9691: LESSEQUAL
9692: IFTRUE 9696
9694: GO 9707
9696: POP
// i := 2 ; 41 .. 60 :
9697: LD_ADDR_VAR 0 2
9701: PUSH
9702: LD_INT 2
9704: ST_TO_ADDR
9705: GO 9758
9707: LD_INT 41
9709: DOUBLE
9710: GREATEREQUAL
9711: IFFALSE 9719
9713: LD_INT 60
9715: DOUBLE
9716: LESSEQUAL
9717: IFTRUE 9721
9719: GO 9732
9721: POP
// i := 4 ; 61 .. 99 :
9722: LD_ADDR_VAR 0 2
9726: PUSH
9727: LD_INT 4
9729: ST_TO_ADDR
9730: GO 9758
9732: LD_INT 61
9734: DOUBLE
9735: GREATEREQUAL
9736: IFFALSE 9744
9738: LD_INT 99
9740: DOUBLE
9741: LESSEQUAL
9742: IFTRUE 9746
9744: GO 9757
9746: POP
// i := 1 ; end ;
9747: LD_ADDR_VAR 0 2
9751: PUSH
9752: LD_INT 1
9754: ST_TO_ADDR
9755: GO 9758
9757: POP
// case i of 1 :
9758: LD_VAR 0 2
9762: PUSH
9763: LD_INT 1
9765: DOUBLE
9766: EQUAL
9767: IFTRUE 9771
9769: GO 9860
9771: POP
// begin if FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) >= 10 then
9772: LD_INT 22
9774: PUSH
9775: LD_OWVAR 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: LD_INT 25
9789: PUSH
9790: LD_INT 12
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 25
9799: PUSH
9800: LD_INT 16
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PUSH
9807: LD_INT 25
9809: PUSH
9810: LD_INT 15
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PUSH
9817: LD_INT 25
9819: PUSH
9820: LD_INT 17
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 69
9842: PUSH
9843: LD_INT 10
9845: GREATEREQUAL
9846: IFFALSE 9854
// BonusIV else
9848: CALL 10433 0 0
9852: GO 9858
// BonusI ;
9854: CALL 9938 0 0
// end ; 2 :
9858: GO 9933
9860: LD_INT 2
9862: DOUBLE
9863: EQUAL
9864: IFTRUE 9868
9866: GO 9875
9868: POP
// begin BonusII ;
9869: CALL 10111 0 0
// end ; 3 :
9873: GO 9933
9875: LD_INT 3
9877: DOUBLE
9878: EQUAL
9879: IFTRUE 9883
9881: GO 9890
9883: POP
// begin BonusIII ;
9884: CALL 10259 0 0
// end ; 4 :
9888: GO 9933
9890: LD_INT 4
9892: DOUBLE
9893: EQUAL
9894: IFTRUE 9898
9896: GO 9905
9898: POP
// begin BonusIV ;
9899: CALL 10433 0 0
// end ; 5 :
9903: GO 9933
9905: LD_INT 5
9907: DOUBLE
9908: EQUAL
9909: IFTRUE 9913
9911: GO 9932
9913: POP
// begin if graveyard then
9914: LD_EXP 8
9918: IFFALSE 9926
// BonusV else
9920: CALL 10851 0 0
9924: GO 9930
// BonusIII ;
9926: CALL 10259 0 0
// end ; end ;
9930: GO 9933
9932: POP
// end ;
9933: LD_VAR 0 1
9937: RET
// export function BonusI ; var i ; begin
9938: LD_INT 0
9940: PPUSH
9941: PPUSH
// case Query ( AddGift1 ) of 1 :
9942: LD_STRING AddGift1
9944: PPUSH
9945: CALL_OW 97
9949: PUSH
9950: LD_INT 1
9952: DOUBLE
9953: EQUAL
9954: IFTRUE 9958
9956: GO 10037
9958: POP
// begin for i = 1 to 3 do
9959: LD_ADDR_VAR 0 2
9963: PUSH
9964: DOUBLE
9965: LD_INT 1
9967: DEC
9968: ST_TO_ADDR
9969: LD_INT 3
9971: PUSH
9972: FOR_TO
9973: IFFALSE 10033
// begin uc_side := your_side ;
9975: LD_ADDR_OWVAR 20
9979: PUSH
9980: LD_OWVAR 2
9984: ST_TO_ADDR
// uc_nation := 0 ;
9985: LD_ADDR_OWVAR 21
9989: PUSH
9990: LD_INT 0
9992: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
9993: LD_INT 0
9995: PPUSH
9996: LD_INT 12
9998: PPUSH
9999: LD_INT 1
10001: PPUSH
10002: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , base_x , base_y , 15 , true ) ;
10006: CALL_OW 44
10010: PPUSH
10011: LD_EXP 9
10015: PPUSH
10016: LD_EXP 10
10020: PPUSH
10021: LD_INT 15
10023: PPUSH
10024: LD_INT 1
10026: PPUSH
10027: CALL_OW 50
// end ;
10031: GO 9972
10033: POP
10034: POP
// end ; 2 :
10035: GO 10106
10037: LD_INT 2
10039: DOUBLE
10040: EQUAL
10041: IFTRUE 10045
10043: GO 10087
10045: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10046: LD_EXP 11
10050: PPUSH
10051: CALL_OW 274
10055: PPUSH
10056: LD_INT 1
10058: PPUSH
10059: LD_EXP 11
10063: PPUSH
10064: CALL_OW 274
10068: PPUSH
10069: LD_INT 1
10071: PPUSH
10072: CALL_OW 275
10076: PUSH
10077: LD_INT 100
10079: PLUS
10080: PPUSH
10081: CALL_OW 277
// end ; 3 :
10085: GO 10106
10087: LD_INT 3
10089: DOUBLE
10090: EQUAL
10091: IFTRUE 10095
10093: GO 10105
10095: POP
// begin SetTeamExp ( 2 ) ;
10096: LD_INT 2
10098: PPUSH
10099: CALL 1266 0 1
// end ; end ;
10103: GO 10106
10105: POP
// end ;
10106: LD_VAR 0 1
10110: RET
// export function BonusII ; var i ; begin
10111: LD_INT 0
10113: PPUSH
10114: PPUSH
// case Query ( AddGift2 ) of 1 :
10115: LD_STRING AddGift2
10117: PPUSH
10118: CALL_OW 97
10122: PUSH
10123: LD_INT 1
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10173
10131: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
10132: LD_EXP 11
10136: PPUSH
10137: CALL_OW 274
10141: PPUSH
10142: LD_INT 1
10144: PPUSH
10145: LD_EXP 11
10149: PPUSH
10150: CALL_OW 274
10154: PPUSH
10155: LD_INT 1
10157: PPUSH
10158: CALL_OW 275
10162: PUSH
10163: LD_INT 500
10165: PLUS
10166: PPUSH
10167: CALL_OW 277
// end ; 2 :
10171: GO 10254
10173: LD_INT 2
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10191
10181: POP
// begin SetTeamExp ( 3 ) ;
10182: LD_INT 3
10184: PPUSH
10185: CALL 1266 0 1
// end ; 3 :
10189: GO 10254
10191: LD_INT 3
10193: DOUBLE
10194: EQUAL
10195: IFTRUE 10199
10197: GO 10253
10199: POP
// begin uc_side = your_side ;
10200: LD_ADDR_OWVAR 20
10204: PUSH
10205: LD_OWVAR 2
10209: ST_TO_ADDR
// uc_nation = nation_russian ;
10210: LD_ADDR_OWVAR 21
10214: PUSH
10215: LD_INT 3
10217: ST_TO_ADDR
// vc_chassis = 25 ;
10218: LD_ADDR_OWVAR 37
10222: PUSH
10223: LD_INT 25
10225: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10226: CALL_OW 45
10230: PPUSH
10231: LD_EXP 9
10235: PPUSH
10236: LD_EXP 10
10240: PPUSH
10241: LD_INT 15
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL_OW 50
// end ; end ;
10251: GO 10254
10253: POP
// end ;
10254: LD_VAR 0 1
10258: RET
// export function BonusIII ; var i ; begin
10259: LD_INT 0
10261: PPUSH
10262: PPUSH
// case Query ( AddGift3 ) of 1 :
10263: LD_STRING AddGift3
10265: PPUSH
10266: CALL_OW 97
10270: PUSH
10271: LD_INT 1
10273: DOUBLE
10274: EQUAL
10275: IFTRUE 10279
10277: GO 10321
10279: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 1000 ) ;
10280: LD_EXP 11
10284: PPUSH
10285: CALL_OW 274
10289: PPUSH
10290: LD_INT 1
10292: PPUSH
10293: LD_EXP 11
10297: PPUSH
10298: CALL_OW 274
10302: PPUSH
10303: LD_INT 1
10305: PPUSH
10306: CALL_OW 275
10310: PUSH
10311: LD_INT 1000
10313: PLUS
10314: PPUSH
10315: CALL_OW 277
// end ; 2 :
10319: GO 10428
10321: LD_INT 2
10323: DOUBLE
10324: EQUAL
10325: IFTRUE 10329
10327: GO 10341
10329: POP
// begin PrepareGuards ( waveNumber ) ;
10330: LD_EXP 5
10334: PPUSH
10335: CALL 1412 0 1
// end ; 3 :
10339: GO 10428
10341: LD_INT 3
10343: DOUBLE
10344: EQUAL
10345: IFTRUE 10349
10347: GO 10427
10349: POP
// begin uc_side = your_side ;
10350: LD_ADDR_OWVAR 20
10354: PUSH
10355: LD_OWVAR 2
10359: ST_TO_ADDR
// uc_nation = nation_american ;
10360: LD_ADDR_OWVAR 21
10364: PUSH
10365: LD_INT 1
10367: ST_TO_ADDR
// vc_chassis = us_morphling ;
10368: LD_ADDR_OWVAR 37
10372: PUSH
10373: LD_INT 5
10375: ST_TO_ADDR
// vc_engine := engine_siberite ;
10376: LD_ADDR_OWVAR 39
10380: PUSH
10381: LD_INT 3
10383: ST_TO_ADDR
// vc_control := control_computer ;
10384: LD_ADDR_OWVAR 38
10388: PUSH
10389: LD_INT 3
10391: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
10392: LD_ADDR_OWVAR 40
10396: PUSH
10397: LD_INT 8
10399: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10400: CALL_OW 45
10404: PPUSH
10405: LD_EXP 9
10409: PPUSH
10410: LD_EXP 10
10414: PPUSH
10415: LD_INT 15
10417: PPUSH
10418: LD_INT 1
10420: PPUSH
10421: CALL_OW 50
// end ; end ;
10425: GO 10428
10427: POP
// end ;
10428: LD_VAR 0 1
10432: RET
// export function BonusIV ; var i ; begin
10433: LD_INT 0
10435: PPUSH
10436: PPUSH
// case Query ( AddGift4 ) of 1 :
10437: LD_STRING AddGift4
10439: PPUSH
10440: CALL_OW 97
10444: PUSH
10445: LD_INT 1
10447: DOUBLE
10448: EQUAL
10449: IFTRUE 10453
10451: GO 10777
10453: POP
// begin i := rand ( 1 , 3 ) ;
10454: LD_ADDR_VAR 0 2
10458: PUSH
10459: LD_INT 1
10461: PPUSH
10462: LD_INT 3
10464: PPUSH
10465: CALL_OW 12
10469: ST_TO_ADDR
// uc_side := your_side ;
10470: LD_ADDR_OWVAR 20
10474: PUSH
10475: LD_OWVAR 2
10479: ST_TO_ADDR
// case i of 1 :
10480: LD_VAR 0 2
10484: PUSH
10485: LD_INT 1
10487: DOUBLE
10488: EQUAL
10489: IFTRUE 10493
10491: GO 10580
10493: POP
// begin uc_nation := nation_arabian ;
10494: LD_ADDR_OWVAR 21
10498: PUSH
10499: LD_INT 2
10501: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10502: LD_ADDR_OWVAR 37
10506: PUSH
10507: LD_INT 14
10509: ST_TO_ADDR
// vc_engine := engine_combustion ;
10510: LD_ADDR_OWVAR 39
10514: PUSH
10515: LD_INT 1
10517: ST_TO_ADDR
// vc_control := control_manual ;
10518: LD_ADDR_OWVAR 38
10522: PUSH
10523: LD_INT 1
10525: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10526: LD_ADDR_OWVAR 40
10530: PUSH
10531: LD_INT 27
10533: PUSH
10534: LD_INT 28
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: LD_INT 1
10543: PPUSH
10544: LD_INT 2
10546: PPUSH
10547: CALL_OW 12
10551: ARRAY
10552: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10553: CALL_OW 45
10557: PPUSH
10558: LD_EXP 9
10562: PPUSH
10563: LD_EXP 10
10567: PPUSH
10568: LD_INT 15
10570: PPUSH
10571: LD_INT 1
10573: PPUSH
10574: CALL_OW 50
// end ; 2 :
10578: GO 10775
10580: LD_INT 2
10582: DOUBLE
10583: EQUAL
10584: IFTRUE 10588
10586: GO 10679
10588: POP
// begin uc_nation := nation_american ;
10589: LD_ADDR_OWVAR 21
10593: PUSH
10594: LD_INT 1
10596: ST_TO_ADDR
// vc_chassis := us_morphling ;
10597: LD_ADDR_OWVAR 37
10601: PUSH
10602: LD_INT 5
10604: ST_TO_ADDR
// vc_engine := engine_siberite ;
10605: LD_ADDR_OWVAR 39
10609: PUSH
10610: LD_INT 3
10612: ST_TO_ADDR
// vc_control := control_computer ;
10613: LD_ADDR_OWVAR 38
10617: PUSH
10618: LD_INT 3
10620: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_double_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
10621: LD_ADDR_OWVAR 40
10625: PUSH
10626: LD_INT 12
10628: PUSH
10629: LD_INT 10
10631: PUSH
10632: LD_INT 7
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 1
10642: PPUSH
10643: LD_INT 3
10645: PPUSH
10646: CALL_OW 12
10650: ARRAY
10651: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10652: CALL_OW 45
10656: PPUSH
10657: LD_EXP 9
10661: PPUSH
10662: LD_EXP 10
10666: PPUSH
10667: LD_INT 15
10669: PPUSH
10670: LD_INT 1
10672: PPUSH
10673: CALL_OW 50
// end ; 3 :
10677: GO 10775
10679: LD_INT 3
10681: DOUBLE
10682: EQUAL
10683: IFTRUE 10687
10685: GO 10774
10687: POP
// begin uc_nation := nation_russian ;
10688: LD_ADDR_OWVAR 21
10692: PUSH
10693: LD_INT 3
10695: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10696: LD_ADDR_OWVAR 37
10700: PUSH
10701: LD_INT 22
10703: ST_TO_ADDR
// vc_engine := engine_combustion ;
10704: LD_ADDR_OWVAR 39
10708: PUSH
10709: LD_INT 1
10711: ST_TO_ADDR
// vc_control := control_manual ;
10712: LD_ADDR_OWVAR 38
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
10720: LD_ADDR_OWVAR 40
10724: PUSH
10725: LD_INT 45
10727: PUSH
10728: LD_INT 44
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 1
10737: PPUSH
10738: LD_INT 2
10740: PPUSH
10741: CALL_OW 12
10745: ARRAY
10746: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10747: CALL_OW 45
10751: PPUSH
10752: LD_EXP 9
10756: PPUSH
10757: LD_EXP 10
10761: PPUSH
10762: LD_INT 15
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 50
// end ; end ;
10772: GO 10775
10774: POP
// end ; 2 :
10775: GO 10846
10777: LD_INT 2
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10827
10785: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10786: LD_EXP 11
10790: PPUSH
10791: CALL_OW 274
10795: PPUSH
10796: LD_INT 1
10798: PPUSH
10799: LD_EXP 11
10803: PPUSH
10804: CALL_OW 274
10808: PPUSH
10809: LD_INT 1
10811: PPUSH
10812: CALL_OW 275
10816: PUSH
10817: LD_INT 100
10819: PLUS
10820: PPUSH
10821: CALL_OW 277
// end ; 3 :
10825: GO 10846
10827: LD_INT 3
10829: DOUBLE
10830: EQUAL
10831: IFTRUE 10835
10833: GO 10845
10835: POP
// begin SetTeamExp ( 2 ) ;
10836: LD_INT 2
10838: PPUSH
10839: CALL 1266 0 1
// end ; end ;
10843: GO 10846
10845: POP
// end ;
10846: LD_VAR 0 1
10850: RET
// export function BonusV ; var i , j ; begin
10851: LD_INT 0
10853: PPUSH
10854: PPUSH
10855: PPUSH
// case Query ( AddGift5 ) of 1 :
10856: LD_STRING AddGift5
10858: PPUSH
10859: CALL_OW 97
10863: PUSH
10864: LD_INT 1
10866: DOUBLE
10867: EQUAL
10868: IFTRUE 10872
10870: GO 11216
10872: POP
// begin for j = 1 to 3 do
10873: LD_ADDR_VAR 0 3
10877: PUSH
10878: DOUBLE
10879: LD_INT 1
10881: DEC
10882: ST_TO_ADDR
10883: LD_INT 3
10885: PUSH
10886: FOR_TO
10887: IFFALSE 11212
// begin i := rand ( 1 , 3 ) ;
10889: LD_ADDR_VAR 0 2
10893: PUSH
10894: LD_INT 1
10896: PPUSH
10897: LD_INT 3
10899: PPUSH
10900: CALL_OW 12
10904: ST_TO_ADDR
// uc_side := your_side ;
10905: LD_ADDR_OWVAR 20
10909: PUSH
10910: LD_OWVAR 2
10914: ST_TO_ADDR
// case i of 1 :
10915: LD_VAR 0 2
10919: PUSH
10920: LD_INT 1
10922: DOUBLE
10923: EQUAL
10924: IFTRUE 10928
10926: GO 11015
10928: POP
// begin uc_nation := nation_arabian ;
10929: LD_ADDR_OWVAR 21
10933: PUSH
10934: LD_INT 2
10936: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10937: LD_ADDR_OWVAR 37
10941: PUSH
10942: LD_INT 14
10944: ST_TO_ADDR
// vc_engine := engine_combustion ;
10945: LD_ADDR_OWVAR 39
10949: PUSH
10950: LD_INT 1
10952: ST_TO_ADDR
// vc_control := control_manual ;
10953: LD_ADDR_OWVAR 38
10957: PUSH
10958: LD_INT 1
10960: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10961: LD_ADDR_OWVAR 40
10965: PUSH
10966: LD_INT 27
10968: PUSH
10969: LD_INT 28
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: LD_INT 1
10978: PPUSH
10979: LD_INT 2
10981: PPUSH
10982: CALL_OW 12
10986: ARRAY
10987: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10988: CALL_OW 45
10992: PPUSH
10993: LD_EXP 9
10997: PPUSH
10998: LD_EXP 10
11002: PPUSH
11003: LD_INT 15
11005: PPUSH
11006: LD_INT 1
11008: PPUSH
11009: CALL_OW 50
// end ; 2 :
11013: GO 11210
11015: LD_INT 2
11017: DOUBLE
11018: EQUAL
11019: IFTRUE 11023
11021: GO 11114
11023: POP
// begin uc_nation := nation_american ;
11024: LD_ADDR_OWVAR 21
11028: PUSH
11029: LD_INT 1
11031: ST_TO_ADDR
// vc_chassis := us_morphling ;
11032: LD_ADDR_OWVAR 37
11036: PUSH
11037: LD_INT 5
11039: ST_TO_ADDR
// vc_engine := engine_siberite ;
11040: LD_ADDR_OWVAR 39
11044: PUSH
11045: LD_INT 3
11047: ST_TO_ADDR
// vc_control := control_computer ;
11048: LD_ADDR_OWVAR 38
11052: PUSH
11053: LD_INT 3
11055: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_radar , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
11056: LD_ADDR_OWVAR 40
11060: PUSH
11061: LD_INT 12
11063: PUSH
11064: LD_INT 11
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 1
11077: PPUSH
11078: LD_INT 3
11080: PPUSH
11081: CALL_OW 12
11085: ARRAY
11086: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11087: CALL_OW 45
11091: PPUSH
11092: LD_EXP 9
11096: PPUSH
11097: LD_EXP 10
11101: PPUSH
11102: LD_INT 15
11104: PPUSH
11105: LD_INT 1
11107: PPUSH
11108: CALL_OW 50
// end ; 3 :
11112: GO 11210
11114: LD_INT 3
11116: DOUBLE
11117: EQUAL
11118: IFTRUE 11122
11120: GO 11209
11122: POP
// begin uc_nation := nation_russian ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 3
11130: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
11131: LD_ADDR_OWVAR 37
11135: PUSH
11136: LD_INT 22
11138: ST_TO_ADDR
// vc_engine := engine_combustion ;
11139: LD_ADDR_OWVAR 39
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// vc_control := control_manual ;
11147: LD_ADDR_OWVAR 38
11151: PUSH
11152: LD_INT 1
11154: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
11155: LD_ADDR_OWVAR 40
11159: PUSH
11160: LD_INT 45
11162: PUSH
11163: LD_INT 44
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: PUSH
11170: LD_INT 1
11172: PPUSH
11173: LD_INT 2
11175: PPUSH
11176: CALL_OW 12
11180: ARRAY
11181: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11182: CALL_OW 45
11186: PPUSH
11187: LD_EXP 9
11191: PPUSH
11192: LD_EXP 10
11196: PPUSH
11197: LD_INT 15
11199: PPUSH
11200: LD_INT 1
11202: PPUSH
11203: CALL_OW 50
// end ; end ;
11207: GO 11210
11209: POP
// end ;
11210: GO 10886
11212: POP
11213: POP
// end ; 2 :
11214: GO 11282
11216: LD_INT 2
11218: DOUBLE
11219: EQUAL
11220: IFTRUE 11224
11222: GO 11266
11224: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
11225: LD_EXP 11
11229: PPUSH
11230: CALL_OW 274
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: LD_EXP 11
11242: PPUSH
11243: CALL_OW 274
11247: PPUSH
11248: LD_INT 1
11250: PPUSH
11251: CALL_OW 275
11255: PUSH
11256: LD_INT 500
11258: PLUS
11259: PPUSH
11260: CALL_OW 277
// end ; 3 :
11264: GO 11282
11266: LD_INT 3
11268: DOUBLE
11269: EQUAL
11270: IFTRUE 11274
11272: GO 11281
11274: POP
// begin GetBack ( ) ;
11275: CALL 2072 0 0
// end ; end ;
11279: GO 11282
11281: POP
// end ; end_of_file
11282: LD_VAR 0 1
11286: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11287: GO 11289
11289: DISABLE
// begin ru_radar := 98 ;
11290: LD_ADDR_EXP 14
11294: PUSH
11295: LD_INT 98
11297: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11298: LD_ADDR_EXP 15
11302: PUSH
11303: LD_INT 89
11305: ST_TO_ADDR
// us_hack := 99 ;
11306: LD_ADDR_EXP 16
11310: PUSH
11311: LD_INT 99
11313: ST_TO_ADDR
// us_artillery := 97 ;
11314: LD_ADDR_EXP 17
11318: PUSH
11319: LD_INT 97
11321: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11322: LD_ADDR_EXP 18
11326: PUSH
11327: LD_INT 91
11329: ST_TO_ADDR
// end ; end_of_file end_of_file
11330: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
11331: GO 11333
11333: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11334: LD_STRING initStreamRollete();
11336: PPUSH
11337: CALL_OW 559
// InitStreamMode ;
11341: CALL 11346 0 0
// end ;
11345: END
// function InitStreamMode ; begin
11346: LD_INT 0
11348: PPUSH
// streamModeActive := false ;
11349: LD_ADDR_EXP 19
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// sRocket := false ;
11357: LD_ADDR_EXP 22
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// sSpeed := false ;
11365: LD_ADDR_EXP 21
11369: PUSH
11370: LD_INT 0
11372: ST_TO_ADDR
// sEngine := false ;
11373: LD_ADDR_EXP 23
11377: PUSH
11378: LD_INT 0
11380: ST_TO_ADDR
// sSpec := false ;
11381: LD_ADDR_EXP 20
11385: PUSH
11386: LD_INT 0
11388: ST_TO_ADDR
// sLevel := false ;
11389: LD_ADDR_EXP 24
11393: PUSH
11394: LD_INT 0
11396: ST_TO_ADDR
// sArmoury := false ;
11397: LD_ADDR_EXP 25
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// sRadar := false ;
11405: LD_ADDR_EXP 26
11409: PUSH
11410: LD_INT 0
11412: ST_TO_ADDR
// sBunker := false ;
11413: LD_ADDR_EXP 27
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// sHack := false ;
11421: LD_ADDR_EXP 28
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// sFire := false ;
11429: LD_ADDR_EXP 29
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// sRefresh := false ;
11437: LD_ADDR_EXP 30
11441: PUSH
11442: LD_INT 0
11444: ST_TO_ADDR
// sExp := false ;
11445: LD_ADDR_EXP 31
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// sDepot := false ;
11453: LD_ADDR_EXP 32
11457: PUSH
11458: LD_INT 0
11460: ST_TO_ADDR
// sFlag := false ;
11461: LD_ADDR_EXP 33
11465: PUSH
11466: LD_INT 0
11468: ST_TO_ADDR
// sSold := false ;
11469: LD_ADDR_EXP 34
11473: PUSH
11474: LD_INT 0
11476: ST_TO_ADDR
// sDiff := false ;
11477: LD_ADDR_EXP 35
11481: PUSH
11482: LD_INT 0
11484: ST_TO_ADDR
// sTiger := false ;
11485: LD_ADDR_EXP 36
11489: PUSH
11490: LD_INT 0
11492: ST_TO_ADDR
// sBomb := false ;
11493: LD_ADDR_EXP 37
11497: PUSH
11498: LD_INT 0
11500: ST_TO_ADDR
// sFog := false ;
11501: LD_ADDR_EXP 38
11505: PUSH
11506: LD_INT 0
11508: ST_TO_ADDR
// sReset := false ;
11509: LD_ADDR_EXP 39
11513: PUSH
11514: LD_INT 0
11516: ST_TO_ADDR
// sSun := false ;
11517: LD_ADDR_EXP 40
11521: PUSH
11522: LD_INT 0
11524: ST_TO_ADDR
// end ;
11525: LD_VAR 0 1
11529: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11530: LD_VAR 0 2
11534: PUSH
11535: LD_INT 100
11537: EQUAL
11538: IFFALSE 11947
// begin if not StreamModeActive then
11540: LD_EXP 19
11544: NOT
11545: IFFALSE 11555
// StreamModeActive := true ;
11547: LD_ADDR_EXP 19
11551: PUSH
11552: LD_INT 1
11554: ST_TO_ADDR
// if p3 = 0 then
11555: LD_VAR 0 3
11559: PUSH
11560: LD_INT 0
11562: EQUAL
11563: IFFALSE 11569
// InitStreamMode ;
11565: CALL 11346 0 0
// if p3 = 1 then
11569: LD_VAR 0 3
11573: PUSH
11574: LD_INT 1
11576: EQUAL
11577: IFFALSE 11587
// sRocket := true ;
11579: LD_ADDR_EXP 22
11583: PUSH
11584: LD_INT 1
11586: ST_TO_ADDR
// if p3 = 2 then
11587: LD_VAR 0 3
11591: PUSH
11592: LD_INT 2
11594: EQUAL
11595: IFFALSE 11605
// sSpeed := true ;
11597: LD_ADDR_EXP 21
11601: PUSH
11602: LD_INT 1
11604: ST_TO_ADDR
// if p3 = 3 then
11605: LD_VAR 0 3
11609: PUSH
11610: LD_INT 3
11612: EQUAL
11613: IFFALSE 11623
// sEngine := true ;
11615: LD_ADDR_EXP 23
11619: PUSH
11620: LD_INT 1
11622: ST_TO_ADDR
// if p3 = 4 then
11623: LD_VAR 0 3
11627: PUSH
11628: LD_INT 4
11630: EQUAL
11631: IFFALSE 11641
// sSpec := true ;
11633: LD_ADDR_EXP 20
11637: PUSH
11638: LD_INT 1
11640: ST_TO_ADDR
// if p3 = 5 then
11641: LD_VAR 0 3
11645: PUSH
11646: LD_INT 5
11648: EQUAL
11649: IFFALSE 11659
// sLevel := true ;
11651: LD_ADDR_EXP 24
11655: PUSH
11656: LD_INT 1
11658: ST_TO_ADDR
// if p3 = 6 then
11659: LD_VAR 0 3
11663: PUSH
11664: LD_INT 6
11666: EQUAL
11667: IFFALSE 11677
// sArmoury := true ;
11669: LD_ADDR_EXP 25
11673: PUSH
11674: LD_INT 1
11676: ST_TO_ADDR
// if p3 = 7 then
11677: LD_VAR 0 3
11681: PUSH
11682: LD_INT 7
11684: EQUAL
11685: IFFALSE 11695
// sRadar := true ;
11687: LD_ADDR_EXP 26
11691: PUSH
11692: LD_INT 1
11694: ST_TO_ADDR
// if p3 = 8 then
11695: LD_VAR 0 3
11699: PUSH
11700: LD_INT 8
11702: EQUAL
11703: IFFALSE 11713
// sBunker := true ;
11705: LD_ADDR_EXP 27
11709: PUSH
11710: LD_INT 1
11712: ST_TO_ADDR
// if p3 = 9 then
11713: LD_VAR 0 3
11717: PUSH
11718: LD_INT 9
11720: EQUAL
11721: IFFALSE 11731
// sHack := true ;
11723: LD_ADDR_EXP 28
11727: PUSH
11728: LD_INT 1
11730: ST_TO_ADDR
// if p3 = 10 then
11731: LD_VAR 0 3
11735: PUSH
11736: LD_INT 10
11738: EQUAL
11739: IFFALSE 11749
// sFire := true ;
11741: LD_ADDR_EXP 29
11745: PUSH
11746: LD_INT 1
11748: ST_TO_ADDR
// if p3 = 11 then
11749: LD_VAR 0 3
11753: PUSH
11754: LD_INT 11
11756: EQUAL
11757: IFFALSE 11767
// sRefresh := true ;
11759: LD_ADDR_EXP 30
11763: PUSH
11764: LD_INT 1
11766: ST_TO_ADDR
// if p3 = 12 then
11767: LD_VAR 0 3
11771: PUSH
11772: LD_INT 12
11774: EQUAL
11775: IFFALSE 11785
// sExp := true ;
11777: LD_ADDR_EXP 31
11781: PUSH
11782: LD_INT 1
11784: ST_TO_ADDR
// if p3 = 13 then
11785: LD_VAR 0 3
11789: PUSH
11790: LD_INT 13
11792: EQUAL
11793: IFFALSE 11803
// sDepot := true ;
11795: LD_ADDR_EXP 32
11799: PUSH
11800: LD_INT 1
11802: ST_TO_ADDR
// if p3 = 14 then
11803: LD_VAR 0 3
11807: PUSH
11808: LD_INT 14
11810: EQUAL
11811: IFFALSE 11821
// sFlag := true ;
11813: LD_ADDR_EXP 33
11817: PUSH
11818: LD_INT 1
11820: ST_TO_ADDR
// if p3 = 101 then
11821: LD_VAR 0 3
11825: PUSH
11826: LD_INT 101
11828: EQUAL
11829: IFFALSE 11839
// sSold := true ;
11831: LD_ADDR_EXP 34
11835: PUSH
11836: LD_INT 1
11838: ST_TO_ADDR
// if p3 = 102 then
11839: LD_VAR 0 3
11843: PUSH
11844: LD_INT 102
11846: EQUAL
11847: IFFALSE 11857
// sDiff := true ;
11849: LD_ADDR_EXP 35
11853: PUSH
11854: LD_INT 1
11856: ST_TO_ADDR
// if p3 = 103 then
11857: LD_VAR 0 3
11861: PUSH
11862: LD_INT 103
11864: EQUAL
11865: IFFALSE 11875
// sFog := true ;
11867: LD_ADDR_EXP 38
11871: PUSH
11872: LD_INT 1
11874: ST_TO_ADDR
// if p3 = 104 then
11875: LD_VAR 0 3
11879: PUSH
11880: LD_INT 104
11882: EQUAL
11883: IFFALSE 11893
// sReset := true ;
11885: LD_ADDR_EXP 39
11889: PUSH
11890: LD_INT 1
11892: ST_TO_ADDR
// if p3 = 105 then
11893: LD_VAR 0 3
11897: PUSH
11898: LD_INT 105
11900: EQUAL
11901: IFFALSE 11911
// sSun := true ;
11903: LD_ADDR_EXP 40
11907: PUSH
11908: LD_INT 1
11910: ST_TO_ADDR
// if p3 = 106 then
11911: LD_VAR 0 3
11915: PUSH
11916: LD_INT 106
11918: EQUAL
11919: IFFALSE 11929
// sTiger := true ;
11921: LD_ADDR_EXP 36
11925: PUSH
11926: LD_INT 1
11928: ST_TO_ADDR
// if p3 = 107 then
11929: LD_VAR 0 3
11933: PUSH
11934: LD_INT 107
11936: EQUAL
11937: IFFALSE 11947
// sBomb := true ;
11939: LD_ADDR_EXP 37
11943: PUSH
11944: LD_INT 1
11946: ST_TO_ADDR
// end ; end ;
11947: PPOPN 6
11949: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11950: LD_EXP 19
11954: PUSH
11955: LD_EXP 22
11959: AND
11960: IFFALSE 12081
11962: GO 11964
11964: DISABLE
11965: LD_INT 0
11967: PPUSH
11968: PPUSH
// begin enable ;
11969: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11970: LD_ADDR_VAR 0 2
11974: PUSH
11975: LD_INT 22
11977: PUSH
11978: LD_OWVAR 2
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 2
11989: PUSH
11990: LD_INT 34
11992: PUSH
11993: LD_INT 7
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: LD_INT 34
12002: PUSH
12003: LD_INT 45
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 34
12012: PUSH
12013: LD_INT 28
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 34
12022: PUSH
12023: LD_INT 47
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: PPUSH
12041: CALL_OW 69
12045: ST_TO_ADDR
// if not tmp then
12046: LD_VAR 0 2
12050: NOT
12051: IFFALSE 12055
// exit ;
12053: GO 12081
// for i in tmp do
12055: LD_ADDR_VAR 0 1
12059: PUSH
12060: LD_VAR 0 2
12064: PUSH
12065: FOR_IN
12066: IFFALSE 12079
// begin DestroyUnit ( i ) ;
12068: LD_VAR 0 1
12072: PPUSH
12073: CALL_OW 65
// end ;
12077: GO 12065
12079: POP
12080: POP
// end ;
12081: PPOPN 2
12083: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12084: LD_EXP 19
12088: PUSH
12089: LD_EXP 23
12093: AND
12094: IFFALSE 12175
12096: GO 12098
12098: DISABLE
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
// begin enable ;
12103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12104: LD_ADDR_VAR 0 2
12108: PUSH
12109: LD_INT 22
12111: PUSH
12112: LD_OWVAR 2
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PUSH
12121: LD_INT 32
12123: PUSH
12124: LD_INT 3
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PPUSH
12135: CALL_OW 69
12139: ST_TO_ADDR
// if not tmp then
12140: LD_VAR 0 2
12144: NOT
12145: IFFALSE 12149
// exit ;
12147: GO 12175
// for i in tmp do
12149: LD_ADDR_VAR 0 1
12153: PUSH
12154: LD_VAR 0 2
12158: PUSH
12159: FOR_IN
12160: IFFALSE 12173
// begin DestroyUnit ( i ) ;
12162: LD_VAR 0 1
12166: PPUSH
12167: CALL_OW 65
// end ;
12171: GO 12159
12173: POP
12174: POP
// end ;
12175: PPOPN 2
12177: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12178: LD_EXP 19
12182: PUSH
12183: LD_EXP 20
12187: AND
12188: IFFALSE 12281
12190: GO 12192
12192: DISABLE
12193: LD_INT 0
12195: PPUSH
// begin enable ;
12196: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_OWVAR 2
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PUSH
12214: LD_INT 2
12216: PUSH
12217: LD_INT 25
12219: PUSH
12220: LD_INT 5
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 25
12229: PUSH
12230: LD_INT 9
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: LD_INT 25
12239: PUSH
12240: LD_INT 8
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: PPUSH
12257: CALL_OW 69
12261: PUSH
12262: FOR_IN
12263: IFFALSE 12279
// begin SetClass ( i , 1 ) ;
12265: LD_VAR 0 1
12269: PPUSH
12270: LD_INT 1
12272: PPUSH
12273: CALL_OW 336
// end ;
12277: GO 12262
12279: POP
12280: POP
// end ;
12281: PPOPN 1
12283: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12284: LD_EXP 19
12288: PUSH
12289: LD_EXP 21
12293: AND
12294: PUSH
12295: LD_OWVAR 65
12299: PUSH
12300: LD_INT 7
12302: LESS
12303: AND
12304: IFFALSE 12318
12306: GO 12308
12308: DISABLE
// begin enable ;
12309: ENABLE
// game_speed := 7 ;
12310: LD_ADDR_OWVAR 65
12314: PUSH
12315: LD_INT 7
12317: ST_TO_ADDR
// end ;
12318: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12319: LD_EXP 19
12323: PUSH
12324: LD_EXP 24
12328: AND
12329: IFFALSE 12531
12331: GO 12333
12333: DISABLE
12334: LD_INT 0
12336: PPUSH
12337: PPUSH
12338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_INT 81
12346: PUSH
12347: LD_OWVAR 2
12351: PUSH
12352: EMPTY
12353: LIST
12354: LIST
12355: PUSH
12356: LD_INT 21
12358: PUSH
12359: LD_INT 1
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PPUSH
12370: CALL_OW 69
12374: ST_TO_ADDR
// if not tmp then
12375: LD_VAR 0 3
12379: NOT
12380: IFFALSE 12384
// exit ;
12382: GO 12531
// if tmp > 5 then
12384: LD_VAR 0 3
12388: PUSH
12389: LD_INT 5
12391: GREATER
12392: IFFALSE 12404
// k := 5 else
12394: LD_ADDR_VAR 0 2
12398: PUSH
12399: LD_INT 5
12401: ST_TO_ADDR
12402: GO 12414
// k := tmp ;
12404: LD_ADDR_VAR 0 2
12408: PUSH
12409: LD_VAR 0 3
12413: ST_TO_ADDR
// for i := 1 to k do
12414: LD_ADDR_VAR 0 1
12418: PUSH
12419: DOUBLE
12420: LD_INT 1
12422: DEC
12423: ST_TO_ADDR
12424: LD_VAR 0 2
12428: PUSH
12429: FOR_TO
12430: IFFALSE 12529
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12432: LD_VAR 0 3
12436: PUSH
12437: LD_VAR 0 1
12441: ARRAY
12442: PPUSH
12443: LD_VAR 0 1
12447: PUSH
12448: LD_INT 4
12450: MOD
12451: PUSH
12452: LD_INT 1
12454: PLUS
12455: PPUSH
12456: CALL_OW 259
12460: PUSH
12461: LD_INT 10
12463: LESS
12464: IFFALSE 12527
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12466: LD_VAR 0 3
12470: PUSH
12471: LD_VAR 0 1
12475: ARRAY
12476: PPUSH
12477: LD_VAR 0 1
12481: PUSH
12482: LD_INT 4
12484: MOD
12485: PUSH
12486: LD_INT 1
12488: PLUS
12489: PPUSH
12490: LD_VAR 0 3
12494: PUSH
12495: LD_VAR 0 1
12499: ARRAY
12500: PPUSH
12501: LD_VAR 0 1
12505: PUSH
12506: LD_INT 4
12508: MOD
12509: PUSH
12510: LD_INT 1
12512: PLUS
12513: PPUSH
12514: CALL_OW 259
12518: PUSH
12519: LD_INT 1
12521: PLUS
12522: PPUSH
12523: CALL_OW 237
12527: GO 12429
12529: POP
12530: POP
// end ;
12531: PPOPN 3
12533: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12534: LD_EXP 19
12538: PUSH
12539: LD_EXP 25
12543: AND
12544: IFFALSE 12564
12546: GO 12548
12548: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12549: LD_INT 4
12551: PPUSH
12552: LD_OWVAR 2
12556: PPUSH
12557: LD_INT 0
12559: PPUSH
12560: CALL_OW 324
12564: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12565: LD_EXP 19
12569: PUSH
12570: LD_EXP 26
12574: AND
12575: IFFALSE 12674
12577: GO 12579
12579: DISABLE
12580: LD_INT 0
12582: PPUSH
12583: PPUSH
// begin enable ;
12584: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_INT 22
12592: PUSH
12593: LD_OWVAR 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 2
12604: PUSH
12605: LD_INT 34
12607: PUSH
12608: LD_INT 11
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 34
12617: PUSH
12618: LD_INT 30
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PPUSH
12634: CALL_OW 69
12638: ST_TO_ADDR
// if not tmp then
12639: LD_VAR 0 2
12643: NOT
12644: IFFALSE 12648
// exit ;
12646: GO 12674
// for i in tmp do
12648: LD_ADDR_VAR 0 1
12652: PUSH
12653: LD_VAR 0 2
12657: PUSH
12658: FOR_IN
12659: IFFALSE 12672
// begin DestroyUnit ( i ) ;
12661: LD_VAR 0 1
12665: PPUSH
12666: CALL_OW 65
// end ;
12670: GO 12658
12672: POP
12673: POP
// end ;
12674: PPOPN 2
12676: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12677: LD_EXP 19
12681: PUSH
12682: LD_EXP 27
12686: AND
12687: IFFALSE 12707
12689: GO 12691
12691: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12692: LD_INT 32
12694: PPUSH
12695: LD_OWVAR 2
12699: PPUSH
12700: LD_INT 0
12702: PPUSH
12703: CALL_OW 324
12707: END
// every 0 0$1 trigger StreamModeActive and sHack do
12708: LD_EXP 19
12712: PUSH
12713: LD_EXP 28
12717: AND
12718: IFFALSE 12738
12720: GO 12722
12722: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
12723: LD_INT 33
12725: PPUSH
12726: LD_OWVAR 2
12730: PPUSH
12731: LD_INT 0
12733: PPUSH
12734: CALL_OW 322
12738: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12739: LD_EXP 19
12743: PUSH
12744: LD_EXP 29
12748: AND
12749: IFFALSE 12828
12751: GO 12753
12753: DISABLE
12754: LD_INT 0
12756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12757: LD_ADDR_VAR 0 1
12761: PUSH
12762: LD_INT 22
12764: PUSH
12765: LD_OWVAR 2
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 21
12776: PUSH
12777: LD_INT 3
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: PPUSH
12788: CALL_OW 69
12792: ST_TO_ADDR
// if not tmp then
12793: LD_VAR 0 1
12797: NOT
12798: IFFALSE 12802
// exit ;
12800: GO 12828
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12802: LD_VAR 0 1
12806: PUSH
12807: LD_INT 1
12809: PPUSH
12810: LD_VAR 0 1
12814: PPUSH
12815: CALL_OW 12
12819: ARRAY
12820: PPUSH
12821: LD_INT 100
12823: PPUSH
12824: CALL_OW 234
// end ;
12828: PPOPN 1
12830: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12831: LD_EXP 19
12835: PUSH
12836: LD_EXP 31
12840: AND
12841: IFFALSE 12939
12843: GO 12845
12845: DISABLE
12846: LD_INT 0
12848: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12849: LD_ADDR_VAR 0 1
12853: PUSH
12854: LD_INT 22
12856: PUSH
12857: LD_OWVAR 2
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: LD_INT 21
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 69
12884: ST_TO_ADDR
// if not tmp then
12885: LD_VAR 0 1
12889: NOT
12890: IFFALSE 12894
// exit ;
12892: GO 12939
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12894: LD_VAR 0 1
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 1
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PPUSH
12913: LD_INT 1
12915: PPUSH
12916: LD_INT 4
12918: PPUSH
12919: CALL_OW 12
12923: PPUSH
12924: LD_INT 3000
12926: PPUSH
12927: LD_INT 9000
12929: PPUSH
12930: CALL_OW 12
12934: PPUSH
12935: CALL_OW 492
// end ;
12939: PPOPN 1
12941: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12942: LD_EXP 19
12946: PUSH
12947: LD_EXP 32
12951: AND
12952: IFFALSE 12972
12954: GO 12956
12956: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12957: LD_INT 1
12959: PPUSH
12960: LD_OWVAR 2
12964: PPUSH
12965: LD_INT 0
12967: PPUSH
12968: CALL_OW 324
12972: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12973: LD_EXP 19
12977: PUSH
12978: LD_EXP 33
12982: AND
12983: IFFALSE 13066
12985: GO 12987
12987: DISABLE
12988: LD_INT 0
12990: PPUSH
12991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12992: LD_ADDR_VAR 0 2
12996: PUSH
12997: LD_INT 22
12999: PUSH
13000: LD_OWVAR 2
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 21
13011: PUSH
13012: LD_INT 3
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PPUSH
13023: CALL_OW 69
13027: ST_TO_ADDR
// if not tmp then
13028: LD_VAR 0 2
13032: NOT
13033: IFFALSE 13037
// exit ;
13035: GO 13066
// for i in tmp do
13037: LD_ADDR_VAR 0 1
13041: PUSH
13042: LD_VAR 0 2
13046: PUSH
13047: FOR_IN
13048: IFFALSE 13064
// SetBLevel ( i , 10 ) ;
13050: LD_VAR 0 1
13054: PPUSH
13055: LD_INT 10
13057: PPUSH
13058: CALL_OW 241
13062: GO 13047
13064: POP
13065: POP
// end ;
13066: PPOPN 2
13068: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
13069: LD_EXP 19
13073: PUSH
13074: LD_EXP 34
13078: AND
13079: IFFALSE 13162
13081: GO 13083
13083: DISABLE
13084: LD_INT 0
13086: PPUSH
13087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_INT 22
13095: PUSH
13096: LD_OWVAR 2
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: LD_INT 25
13107: PUSH
13108: LD_INT 1
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PPUSH
13119: CALL_OW 69
13123: ST_TO_ADDR
// if not tmp then
13124: LD_VAR 0 2
13128: NOT
13129: IFFALSE 13133
// exit ;
13131: GO 13162
// for i in tmp do
13133: LD_ADDR_VAR 0 1
13137: PUSH
13138: LD_VAR 0 2
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13160
// SetClass ( i , 4 ) ;
13146: LD_VAR 0 1
13150: PPUSH
13151: LD_INT 4
13153: PPUSH
13154: CALL_OW 336
13158: GO 13143
13160: POP
13161: POP
// end ;
13162: PPOPN 2
13164: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13165: LD_EXP 19
13169: PUSH
13170: LD_EXP 35
13174: AND
13175: PUSH
13176: LD_OWVAR 67
13180: PUSH
13181: LD_INT 3
13183: LESS
13184: AND
13185: IFFALSE 13204
13187: GO 13189
13189: DISABLE
// Difficulty := Difficulty + 1 ;
13190: LD_ADDR_OWVAR 67
13194: PUSH
13195: LD_OWVAR 67
13199: PUSH
13200: LD_INT 1
13202: PLUS
13203: ST_TO_ADDR
13204: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13205: LD_EXP 19
13209: PUSH
13210: LD_EXP 36
13214: AND
13215: IFFALSE 13318
13217: GO 13219
13219: DISABLE
13220: LD_INT 0
13222: PPUSH
// begin for i := 1 to 5 do
13223: LD_ADDR_VAR 0 1
13227: PUSH
13228: DOUBLE
13229: LD_INT 1
13231: DEC
13232: ST_TO_ADDR
13233: LD_INT 5
13235: PUSH
13236: FOR_TO
13237: IFFALSE 13316
// begin uc_nation := nation_nature ;
13239: LD_ADDR_OWVAR 21
13243: PUSH
13244: LD_INT 0
13246: ST_TO_ADDR
// uc_side := 0 ;
13247: LD_ADDR_OWVAR 20
13251: PUSH
13252: LD_INT 0
13254: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13255: LD_ADDR_OWVAR 29
13259: PUSH
13260: LD_INT 12
13262: PUSH
13263: LD_INT 12
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: ST_TO_ADDR
// hc_agressivity := 20 ;
13270: LD_ADDR_OWVAR 35
13274: PUSH
13275: LD_INT 20
13277: ST_TO_ADDR
// hc_class := class_tiger ;
13278: LD_ADDR_OWVAR 28
13282: PUSH
13283: LD_INT 14
13285: ST_TO_ADDR
// hc_gallery :=  ;
13286: LD_ADDR_OWVAR 33
13290: PUSH
13291: LD_STRING 
13293: ST_TO_ADDR
// hc_name :=  ;
13294: LD_ADDR_OWVAR 26
13298: PUSH
13299: LD_STRING 
13301: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13302: CALL_OW 44
13306: PPUSH
13307: LD_INT 0
13309: PPUSH
13310: CALL_OW 51
// end ;
13314: GO 13236
13316: POP
13317: POP
// end ;
13318: PPOPN 1
13320: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
13321: LD_EXP 19
13325: PUSH
13326: LD_EXP 37
13330: AND
13331: IFFALSE 13505
13333: GO 13335
13335: DISABLE
13336: LD_INT 0
13338: PPUSH
13339: PPUSH
13340: PPUSH
13341: PPUSH
// begin result := false ;
13342: LD_ADDR_VAR 0 4
13346: PUSH
13347: LD_INT 0
13349: ST_TO_ADDR
// for i := 1 to 8 do
13350: LD_ADDR_VAR 0 1
13354: PUSH
13355: DOUBLE
13356: LD_INT 1
13358: DEC
13359: ST_TO_ADDR
13360: LD_INT 8
13362: PUSH
13363: FOR_TO
13364: IFFALSE 13475
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13366: LD_ADDR_VAR 0 2
13370: PUSH
13371: LD_INT 10
13373: PUSH
13374: LD_INT 50
13376: PUSH
13377: LD_INT 90
13379: PUSH
13380: LD_INT 140
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 1
13391: PPUSH
13392: LD_INT 4
13394: PPUSH
13395: CALL_OW 12
13399: ARRAY
13400: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13401: LD_ADDR_VAR 0 3
13405: PUSH
13406: LD_INT 10
13408: PUSH
13409: LD_INT 50
13411: PUSH
13412: LD_INT 90
13414: PUSH
13415: LD_INT 140
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: PUSH
13424: LD_INT 1
13426: PPUSH
13427: LD_INT 4
13429: PPUSH
13430: CALL_OW 12
13434: ARRAY
13435: ST_TO_ADDR
// if ValidHex ( x , y ) then
13436: LD_VAR 0 2
13440: PPUSH
13441: LD_VAR 0 3
13445: PPUSH
13446: CALL_OW 488
13450: IFFALSE 13473
// begin result := [ x , y ] ;
13452: LD_ADDR_VAR 0 4
13456: PUSH
13457: LD_VAR 0 2
13461: PUSH
13462: LD_VAR 0 3
13466: PUSH
13467: EMPTY
13468: LIST
13469: LIST
13470: ST_TO_ADDR
// break ;
13471: GO 13475
// end ; end ;
13473: GO 13363
13475: POP
13476: POP
// if result then
13477: LD_VAR 0 4
13481: IFFALSE 13505
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13483: LD_VAR 0 4
13487: PUSH
13488: LD_INT 1
13490: ARRAY
13491: PPUSH
13492: LD_VAR 0 4
13496: PUSH
13497: LD_INT 2
13499: ARRAY
13500: PPUSH
13501: CALL_OW 429
// end ;
13505: PPOPN 4
13507: END
// every 0 0$1 trigger StreamModeActive and sReset do
13508: LD_EXP 19
13512: PUSH
13513: LD_EXP 39
13517: AND
13518: IFFALSE 13530
13520: GO 13522
13522: DISABLE
// YouLost (  ) ;
13523: LD_STRING 
13525: PPUSH
13526: CALL_OW 104
13530: END
// every 0 0$1 trigger StreamModeActive and sFog do
13531: LD_EXP 19
13535: PUSH
13536: LD_EXP 38
13540: AND
13541: IFFALSE 13555
13543: GO 13545
13545: DISABLE
// FogOff ( your_side ) ;
13546: LD_OWVAR 2
13550: PPUSH
13551: CALL_OW 344
13555: END
// every 0 0$1 trigger StreamModeActive and sSun do
13556: LD_EXP 19
13560: PUSH
13561: LD_EXP 40
13565: AND
13566: IFFALSE 13594
13568: GO 13570
13570: DISABLE
// begin solar_recharge_percent := 0 ;
13571: LD_ADDR_OWVAR 79
13575: PUSH
13576: LD_INT 0
13578: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13579: LD_INT 10500
13581: PPUSH
13582: CALL_OW 67
// solar_recharge_percent := 100 ;
13586: LD_ADDR_OWVAR 79
13590: PUSH
13591: LD_INT 100
13593: ST_TO_ADDR
// end ; end_of_file
13594: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
13595: LD_INT 0
13597: PPUSH
13598: PPUSH
13599: PPUSH
13600: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
13601: LD_VAR 0 1
13605: PPUSH
13606: CALL_OW 264
13610: PUSH
13611: LD_EXP 18
13615: EQUAL
13616: IFFALSE 13688
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13618: LD_INT 68
13620: PPUSH
13621: LD_VAR 0 1
13625: PPUSH
13626: CALL_OW 255
13630: PPUSH
13631: CALL_OW 321
13635: PUSH
13636: LD_INT 2
13638: EQUAL
13639: IFFALSE 13651
// eff := 70 else
13641: LD_ADDR_VAR 0 6
13645: PUSH
13646: LD_INT 70
13648: ST_TO_ADDR
13649: GO 13659
// eff := 30 ;
13651: LD_ADDR_VAR 0 6
13655: PUSH
13656: LD_INT 30
13658: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13659: LD_VAR 0 1
13663: PPUSH
13664: CALL_OW 250
13668: PPUSH
13669: LD_VAR 0 1
13673: PPUSH
13674: CALL_OW 251
13678: PPUSH
13679: LD_VAR 0 6
13683: PPUSH
13684: CALL_OW 495
// end ; end ;
13688: LD_VAR 0 4
13692: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
13693: LD_INT 0
13695: PPUSH
13696: PPUSH
13697: PPUSH
13698: PPUSH
13699: PPUSH
13700: PPUSH
// if cmd = 124 then
13701: LD_VAR 0 1
13705: PUSH
13706: LD_INT 124
13708: EQUAL
13709: IFFALSE 13915
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
13711: LD_ADDR_VAR 0 5
13715: PUSH
13716: LD_INT 2
13718: PUSH
13719: LD_INT 34
13721: PUSH
13722: LD_INT 53
13724: PUSH
13725: EMPTY
13726: LIST
13727: LIST
13728: PUSH
13729: LD_INT 34
13731: PUSH
13732: LD_INT 14
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: LIST
13743: PPUSH
13744: CALL_OW 69
13748: ST_TO_ADDR
// if not tmp then
13749: LD_VAR 0 5
13753: NOT
13754: IFFALSE 13758
// exit ;
13756: GO 13915
// for i in tmp do
13758: LD_ADDR_VAR 0 3
13762: PUSH
13763: LD_VAR 0 5
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13913
// begin taskList := GetTaskList ( i ) ;
13771: LD_ADDR_VAR 0 6
13775: PUSH
13776: LD_VAR 0 3
13780: PPUSH
13781: CALL_OW 437
13785: ST_TO_ADDR
// if not taskList then
13786: LD_VAR 0 6
13790: NOT
13791: IFFALSE 13795
// continue ;
13793: GO 13768
// for j = 1 to taskList do
13795: LD_ADDR_VAR 0 4
13799: PUSH
13800: DOUBLE
13801: LD_INT 1
13803: DEC
13804: ST_TO_ADDR
13805: LD_VAR 0 6
13809: PUSH
13810: FOR_TO
13811: IFFALSE 13909
// if taskList [ j ] [ 1 ] = | then
13813: LD_VAR 0 6
13817: PUSH
13818: LD_VAR 0 4
13822: ARRAY
13823: PUSH
13824: LD_INT 1
13826: ARRAY
13827: PUSH
13828: LD_STRING |
13830: EQUAL
13831: IFFALSE 13907
// begin _taskList := Delete ( taskList , 1 ) ;
13833: LD_ADDR_VAR 0 7
13837: PUSH
13838: LD_VAR 0 6
13842: PPUSH
13843: LD_INT 1
13845: PPUSH
13846: CALL_OW 3
13850: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
13851: LD_VAR 0 3
13855: PPUSH
13856: LD_VAR 0 7
13860: PPUSH
13861: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
13865: LD_VAR 0 3
13869: PPUSH
13870: LD_VAR 0 6
13874: PUSH
13875: LD_VAR 0 4
13879: ARRAY
13880: PUSH
13881: LD_INT 2
13883: ARRAY
13884: PPUSH
13885: LD_VAR 0 6
13889: PUSH
13890: LD_VAR 0 4
13894: ARRAY
13895: PUSH
13896: LD_INT 3
13898: ARRAY
13899: PPUSH
13900: LD_INT 8
13902: PPUSH
13903: CALL 13920 0 4
// end ;
13907: GO 13810
13909: POP
13910: POP
// end ;
13911: GO 13768
13913: POP
13914: POP
// end ; end ;
13915: LD_VAR 0 2
13919: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13920: LD_INT 0
13922: PPUSH
13923: PPUSH
13924: PPUSH
13925: PPUSH
13926: PPUSH
13927: PPUSH
13928: PPUSH
13929: PPUSH
13930: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13931: LD_VAR 0 1
13935: NOT
13936: PUSH
13937: LD_VAR 0 2
13941: PPUSH
13942: LD_VAR 0 3
13946: PPUSH
13947: CALL_OW 488
13951: NOT
13952: OR
13953: PUSH
13954: LD_VAR 0 4
13958: NOT
13959: OR
13960: IFFALSE 13964
// exit ;
13962: GO 14304
// list := [ ] ;
13964: LD_ADDR_VAR 0 13
13968: PUSH
13969: EMPTY
13970: ST_TO_ADDR
// if x - r < 0 then
13971: LD_VAR 0 2
13975: PUSH
13976: LD_VAR 0 4
13980: MINUS
13981: PUSH
13982: LD_INT 0
13984: LESS
13985: IFFALSE 13997
// min_x := 0 else
13987: LD_ADDR_VAR 0 7
13991: PUSH
13992: LD_INT 0
13994: ST_TO_ADDR
13995: GO 14013
// min_x := x - r ;
13997: LD_ADDR_VAR 0 7
14001: PUSH
14002: LD_VAR 0 2
14006: PUSH
14007: LD_VAR 0 4
14011: MINUS
14012: ST_TO_ADDR
// if y - r < 0 then
14013: LD_VAR 0 3
14017: PUSH
14018: LD_VAR 0 4
14022: MINUS
14023: PUSH
14024: LD_INT 0
14026: LESS
14027: IFFALSE 14039
// min_y := 0 else
14029: LD_ADDR_VAR 0 8
14033: PUSH
14034: LD_INT 0
14036: ST_TO_ADDR
14037: GO 14055
// min_y := y - r ;
14039: LD_ADDR_VAR 0 8
14043: PUSH
14044: LD_VAR 0 3
14048: PUSH
14049: LD_VAR 0 4
14053: MINUS
14054: ST_TO_ADDR
// max_x := x + r ;
14055: LD_ADDR_VAR 0 9
14059: PUSH
14060: LD_VAR 0 2
14064: PUSH
14065: LD_VAR 0 4
14069: PLUS
14070: ST_TO_ADDR
// max_y := y + r ;
14071: LD_ADDR_VAR 0 10
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: PLUS
14086: ST_TO_ADDR
// for _x = min_x to max_x do
14087: LD_ADDR_VAR 0 11
14091: PUSH
14092: DOUBLE
14093: LD_VAR 0 7
14097: DEC
14098: ST_TO_ADDR
14099: LD_VAR 0 9
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14222
// for _y = min_y to max_y do
14107: LD_ADDR_VAR 0 12
14111: PUSH
14112: DOUBLE
14113: LD_VAR 0 8
14117: DEC
14118: ST_TO_ADDR
14119: LD_VAR 0 10
14123: PUSH
14124: FOR_TO
14125: IFFALSE 14218
// begin if not ValidHex ( _x , _y ) then
14127: LD_VAR 0 11
14131: PPUSH
14132: LD_VAR 0 12
14136: PPUSH
14137: CALL_OW 488
14141: NOT
14142: IFFALSE 14146
// continue ;
14144: GO 14124
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
14146: LD_VAR 0 11
14150: PPUSH
14151: LD_VAR 0 12
14155: PPUSH
14156: CALL_OW 351
14160: PUSH
14161: LD_VAR 0 11
14165: PPUSH
14166: LD_VAR 0 12
14170: PPUSH
14171: CALL_OW 554
14175: AND
14176: IFFALSE 14216
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
14178: LD_ADDR_VAR 0 13
14182: PUSH
14183: LD_VAR 0 13
14187: PPUSH
14188: LD_VAR 0 13
14192: PUSH
14193: LD_INT 1
14195: PLUS
14196: PPUSH
14197: LD_VAR 0 11
14201: PUSH
14202: LD_VAR 0 12
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PPUSH
14211: CALL_OW 2
14215: ST_TO_ADDR
// end ;
14216: GO 14124
14218: POP
14219: POP
14220: GO 14104
14222: POP
14223: POP
// if not list then
14224: LD_VAR 0 13
14228: NOT
14229: IFFALSE 14233
// exit ;
14231: GO 14304
// for i in list do
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 13
14242: PUSH
14243: FOR_IN
14244: IFFALSE 14302
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
14246: LD_VAR 0 1
14250: PPUSH
14251: LD_STRING M
14253: PUSH
14254: LD_VAR 0 6
14258: PUSH
14259: LD_INT 1
14261: ARRAY
14262: PUSH
14263: LD_VAR 0 6
14267: PUSH
14268: LD_INT 2
14270: ARRAY
14271: PUSH
14272: LD_INT 0
14274: PUSH
14275: LD_INT 0
14277: PUSH
14278: LD_INT 0
14280: PUSH
14281: LD_INT 0
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: PUSH
14293: EMPTY
14294: LIST
14295: PPUSH
14296: CALL_OW 447
14300: GO 14243
14302: POP
14303: POP
// end ;
14304: LD_VAR 0 5
14308: RET
