// starting begin InitSettings ;
   0: CALL 2932 0 0
// InitGame ;
   4: CALL 2970 0 0
// InitDisplay ;
   8: CALL 9509 0 0
// end ; end_of_file
  12: END
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
  18: PPUSH
// if pos < 1 then
  19: LD_VAR 0 2
  23: PUSH
  24: LD_INT 1
  26: LESS
  27: IFFALSE 31
// exit ;
  29: GO 334
// if pos = 1 then
  31: LD_VAR 0 2
  35: PUSH
  36: LD_INT 1
  38: EQUAL
  39: IFFALSE 72
// result := Replace ( arr , pos [ 1 ] , value ) else
  41: LD_ADDR_VAR 0 4
  45: PUSH
  46: LD_VAR 0 1
  50: PPUSH
  51: LD_VAR 0 2
  55: PUSH
  56: LD_INT 1
  58: ARRAY
  59: PPUSH
  60: LD_VAR 0 3
  64: PPUSH
  65: CALL_OW 1
  69: ST_TO_ADDR
  70: GO 334
// begin tmp := arr ;
  72: LD_ADDR_VAR 0 6
  76: PUSH
  77: LD_VAR 0 1
  81: ST_TO_ADDR
// s_arr := [ tmp ] ;
  82: LD_ADDR_VAR 0 7
  86: PUSH
  87: LD_VAR 0 6
  91: PUSH
  92: EMPTY
  93: LIST
  94: ST_TO_ADDR
// for i = 1 to pos - 1 do
  95: LD_ADDR_VAR 0 5
  99: PUSH
 100: DOUBLE
 101: LD_INT 1
 103: DEC
 104: ST_TO_ADDR
 105: LD_VAR 0 2
 109: PUSH
 110: LD_INT 1
 112: MINUS
 113: PUSH
 114: FOR_TO
 115: IFFALSE 160
// begin tmp := tmp [ pos [ i ] ] ;
 117: LD_ADDR_VAR 0 6
 121: PUSH
 122: LD_VAR 0 6
 126: PUSH
 127: LD_VAR 0 2
 131: PUSH
 132: LD_VAR 0 5
 136: ARRAY
 137: ARRAY
 138: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
 139: LD_ADDR_VAR 0 7
 143: PUSH
 144: LD_VAR 0 7
 148: PUSH
 149: LD_VAR 0 6
 153: PUSH
 154: EMPTY
 155: LIST
 156: ADD
 157: ST_TO_ADDR
// end ;
 158: GO 114
 160: POP
 161: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
 162: LD_ADDR_VAR 0 6
 166: PUSH
 167: LD_VAR 0 6
 171: PPUSH
 172: LD_VAR 0 2
 176: PUSH
 177: LD_VAR 0 2
 181: ARRAY
 182: PPUSH
 183: LD_VAR 0 3
 187: PPUSH
 188: CALL_OW 1
 192: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
 193: LD_ADDR_VAR 0 7
 197: PUSH
 198: LD_VAR 0 7
 202: PPUSH
 203: LD_VAR 0 7
 207: PPUSH
 208: LD_VAR 0 6
 212: PPUSH
 213: CALL_OW 1
 217: ST_TO_ADDR
// for i = s_arr downto 2 do
 218: LD_ADDR_VAR 0 5
 222: PUSH
 223: DOUBLE
 224: LD_VAR 0 7
 228: INC
 229: ST_TO_ADDR
 230: LD_INT 2
 232: PUSH
 233: FOR_DOWNTO
 234: IFFALSE 318
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: LD_VAR 0 7
 245: PUSH
 246: LD_VAR 0 5
 250: PUSH
 251: LD_INT 1
 253: MINUS
 254: ARRAY
 255: PPUSH
 256: LD_VAR 0 2
 260: PUSH
 261: LD_VAR 0 5
 265: PUSH
 266: LD_INT 1
 268: MINUS
 269: ARRAY
 270: PPUSH
 271: LD_VAR 0 7
 275: PUSH
 276: LD_VAR 0 5
 280: ARRAY
 281: PPUSH
 282: CALL_OW 1
 286: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
 287: LD_ADDR_VAR 0 7
 291: PUSH
 292: LD_VAR 0 7
 296: PPUSH
 297: LD_VAR 0 5
 301: PUSH
 302: LD_INT 1
 304: MINUS
 305: PPUSH
 306: LD_VAR 0 6
 310: PPUSH
 311: CALL_OW 1
 315: ST_TO_ADDR
// end ;
 316: GO 233
 318: POP
 319: POP
// result := s_arr [ 1 ] ;
 320: LD_ADDR_VAR 0 4
 324: PUSH
 325: LD_VAR 0 7
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: ST_TO_ADDR
// end ; end ;
 334: LD_VAR 0 4
 338: RET
// export function PrepareSquad ( nation , skill , num , x , y ) ; var i , team , c ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// team := [ ] ;
 345: LD_ADDR_VAR 0 8
 349: PUSH
 350: EMPTY
 351: ST_TO_ADDR
// playerSquad := [ ] ;
 352: LD_ADDR_EXP 12
 356: PUSH
 357: EMPTY
 358: ST_TO_ADDR
// uc_side := nation ;
 359: LD_ADDR_OWVAR 20
 363: PUSH
 364: LD_VAR 0 1
 368: ST_TO_ADDR
// uc_nation := nation ;
 369: LD_ADDR_OWVAR 21
 373: PUSH
 374: LD_VAR 0 1
 378: ST_TO_ADDR
// hc_importance := 100 ;
 379: LD_ADDR_OWVAR 32
 383: PUSH
 384: LD_INT 100
 386: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 387: LD_INT 0
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: LD_VAR 0 2
 397: PPUSH
 398: CALL_OW 380
// team := Insert ( team , 1 , CreateHuman ) ;
 402: LD_ADDR_VAR 0 8
 406: PUSH
 407: LD_VAR 0 8
 411: PPUSH
 412: LD_INT 1
 414: PPUSH
 415: CALL_OW 44
 419: PPUSH
 420: CALL_OW 2
 424: ST_TO_ADDR
// hc_importance := 0 ;
 425: LD_ADDR_OWVAR 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// for i = 1 to num - 1 do
 433: LD_ADDR_VAR 0 7
 437: PUSH
 438: DOUBLE
 439: LD_INT 1
 441: DEC
 442: ST_TO_ADDR
 443: LD_VAR 0 3
 447: PUSH
 448: LD_INT 1
 450: MINUS
 451: PUSH
 452: FOR_TO
 453: IFFALSE 511
// begin PrepareHuman ( false , i div ( num / 4 ) + 1 , skill ) ;
 455: LD_INT 0
 457: PPUSH
 458: LD_VAR 0 7
 462: PUSH
 463: LD_VAR 0 3
 467: PUSH
 468: LD_INT 4
 470: DIVREAL
 471: DIV
 472: PUSH
 473: LD_INT 1
 475: PLUS
 476: PPUSH
 477: LD_VAR 0 2
 481: PPUSH
 482: CALL_OW 380
// team := Insert ( team , 2 , CreateHuman ) ;
 486: LD_ADDR_VAR 0 8
 490: PUSH
 491: LD_VAR 0 8
 495: PPUSH
 496: LD_INT 2
 498: PPUSH
 499: CALL_OW 44
 503: PPUSH
 504: CALL_OW 2
 508: ST_TO_ADDR
// end ;
 509: GO 452
 511: POP
 512: POP
// for i in team do
 513: LD_ADDR_VAR 0 7
 517: PUSH
 518: LD_VAR 0 8
 522: PUSH
 523: FOR_IN
 524: IFFALSE 623
// begin PlaceUnitXYR ( i , x , y , 8 , false ) ;
 526: LD_VAR 0 7
 530: PPUSH
 531: LD_VAR 0 4
 535: PPUSH
 536: LD_VAR 0 5
 540: PPUSH
 541: LD_INT 8
 543: PPUSH
 544: LD_INT 0
 546: PPUSH
 547: CALL_OW 50
// c := c + 1 ;
 551: LD_ADDR_VAR 0 9
 555: PUSH
 556: LD_VAR 0 9
 560: PUSH
 561: LD_INT 1
 563: PLUS
 564: ST_TO_ADDR
// SaveCharacters ( i , grave & c ) ;
 565: LD_VAR 0 7
 569: PPUSH
 570: LD_STRING grave
 572: PUSH
 573: LD_VAR 0 9
 577: STR
 578: PPUSH
 579: CALL_OW 38
// playerSquad := Insert ( playerSquad , c , [ i , grave & c ] ) ;
 583: LD_ADDR_EXP 12
 587: PUSH
 588: LD_EXP 12
 592: PPUSH
 593: LD_VAR 0 9
 597: PPUSH
 598: LD_VAR 0 7
 602: PUSH
 603: LD_STRING grave
 605: PUSH
 606: LD_VAR 0 9
 610: STR
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PPUSH
 616: CALL_OW 2
 620: ST_TO_ADDR
// end ;
 621: GO 523
 623: POP
 624: POP
// end ;
 625: LD_VAR 0 6
 629: RET
// export function PrepareResources ( num , type_allowed , x , y , r ) ; var i , n ; begin
 630: LD_INT 0
 632: PPUSH
 633: PPUSH
 634: PPUSH
// for i = 1 to type_allowed do
 635: LD_ADDR_VAR 0 7
 639: PUSH
 640: DOUBLE
 641: LD_INT 1
 643: DEC
 644: ST_TO_ADDR
 645: LD_VAR 0 2
 649: PUSH
 650: FOR_TO
 651: IFFALSE 790
// while ( num [ i ] > 0 ) do
 653: LD_VAR 0 1
 657: PUSH
 658: LD_VAR 0 7
 662: ARRAY
 663: PUSH
 664: LD_INT 0
 666: GREATER
 667: IFFALSE 788
// begin if num [ i ] > 5 then
 669: LD_VAR 0 1
 673: PUSH
 674: LD_VAR 0 7
 678: ARRAY
 679: PUSH
 680: LD_INT 5
 682: GREATER
 683: IFFALSE 695
// n := 5 else
 685: LD_ADDR_VAR 0 8
 689: PUSH
 690: LD_INT 5
 692: ST_TO_ADDR
 693: GO 711
// n := num [ i ] ;
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: LD_VAR 0 1
 704: PUSH
 705: LD_VAR 0 7
 709: ARRAY
 710: ST_TO_ADDR
// CreateResourcesXYR ( type_allowed [ i ] , n , x , y , r , false ) ;
 711: LD_VAR 0 2
 715: PUSH
 716: LD_VAR 0 7
 720: ARRAY
 721: PPUSH
 722: LD_VAR 0 8
 726: PPUSH
 727: LD_VAR 0 3
 731: PPUSH
 732: LD_VAR 0 4
 736: PPUSH
 737: LD_VAR 0 5
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 60
// num := Replace ( num , i , num [ i ] - n ) ;
 749: LD_ADDR_VAR 0 1
 753: PUSH
 754: LD_VAR 0 1
 758: PPUSH
 759: LD_VAR 0 7
 763: PPUSH
 764: LD_VAR 0 1
 768: PUSH
 769: LD_VAR 0 7
 773: ARRAY
 774: PUSH
 775: LD_VAR 0 8
 779: MINUS
 780: PPUSH
 781: CALL_OW 1
 785: ST_TO_ADDR
// end ;
 786: GO 653
 788: GO 650
 790: POP
 791: POP
// end ;
 792: LD_VAR 0 6
 796: RET
// export function AddPoints ( p ) ; begin
 797: LD_INT 0
 799: PPUSH
// points := points + p ;
 800: LD_ADDR_EXP 2
 804: PUSH
 805: LD_EXP 2
 809: PUSH
 810: LD_VAR 0 1
 814: PLUS
 815: ST_TO_ADDR
// end ;
 816: LD_VAR 0 2
 820: RET
// export function LoadColors ; var file ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
// case GetMonth of 1 .. 3 , 12 :
 825: CALL_OW 545
 829: PUSH
 830: LD_INT 1
 832: DOUBLE
 833: GREATEREQUAL
 834: IFFALSE 842
 836: LD_INT 3
 838: DOUBLE
 839: LESSEQUAL
 840: IFTRUE 850
 842: LD_INT 12
 844: DOUBLE
 845: EQUAL
 846: IFTRUE 850
 848: GO 861
 850: POP
// file = colors.txt ; 4 .. 5 :
 851: LD_ADDR_VAR 0 2
 855: PUSH
 856: LD_STRING colors.txt
 858: ST_TO_ADDR
 859: GO 937
 861: LD_INT 4
 863: DOUBLE
 864: GREATEREQUAL
 865: IFFALSE 873
 867: LD_INT 5
 869: DOUBLE
 870: LESSEQUAL
 871: IFTRUE 875
 873: GO 886
 875: POP
// file = colors-spring.txt ; 6 .. 8 :
 876: LD_ADDR_VAR 0 2
 880: PUSH
 881: LD_STRING colors-spring.txt
 883: ST_TO_ADDR
 884: GO 937
 886: LD_INT 6
 888: DOUBLE
 889: GREATEREQUAL
 890: IFFALSE 898
 892: LD_INT 8
 894: DOUBLE
 895: LESSEQUAL
 896: IFTRUE 900
 898: GO 911
 900: POP
// file = colors-summer.txt ; 9 .. 11 :
 901: LD_ADDR_VAR 0 2
 905: PUSH
 906: LD_STRING colors-summer.txt
 908: ST_TO_ADDR
 909: GO 937
 911: LD_INT 9
 913: DOUBLE
 914: GREATEREQUAL
 915: IFFALSE 923
 917: LD_INT 11
 919: DOUBLE
 920: LESSEQUAL
 921: IFTRUE 925
 923: GO 936
 925: POP
// file = colors-autumn.txt ; end ;
 926: LD_ADDR_VAR 0 2
 930: PUSH
 931: LD_STRING colors-autumn.txt
 933: ST_TO_ADDR
 934: GO 937
 936: POP
// LoadColorsTxt ( file ) ;
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 544
// end ;
 946: LD_VAR 0 1
 950: RET
// export function TestColor ; var i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
// i = 1 ;
 955: LD_ADDR_VAR 0 2
 959: PUSH
 960: LD_INT 1
 962: ST_TO_ADDR
// repeat begin wait ( 0 0$01 ) ;
 963: LD_INT 35
 965: PPUSH
 966: CALL_OW 67
// LoadColorsTxt ( [ colors-spring.txt , colors-summer.txt , colors-autumn.txt , colors.txt ] [ i mod 4 + 1 ] ) ;
 970: LD_STRING colors-spring.txt
 972: PUSH
 973: LD_STRING colors-summer.txt
 975: PUSH
 976: LD_STRING colors-autumn.txt
 978: PUSH
 979: LD_STRING colors.txt
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_VAR 0 2
 992: PUSH
 993: LD_INT 4
 995: MOD
 996: PUSH
 997: LD_INT 1
 999: PLUS
1000: ARRAY
1001: PPUSH
1002: CALL_OW 544
// display_strings := [ Wiosna , Lato , Jesien , Zima ] [ i mod 4 + 1 ] ;
1006: LD_ADDR_OWVAR 47
1010: PUSH
1011: LD_STRING Wiosna
1013: PUSH
1014: LD_STRING Lato
1016: PUSH
1017: LD_STRING Jesien
1019: PUSH
1020: LD_STRING Zima
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_INT 4
1036: MOD
1037: PUSH
1038: LD_INT 1
1040: PLUS
1041: ARRAY
1042: ST_TO_ADDR
// i := i + 1 ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_VAR 0 2
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ST_TO_ADDR
// end until false ;
1057: LD_INT 0
1059: IFFALSE 963
// end ;
1061: LD_VAR 0 1
1065: RET
// function FindDir ( x1 , y1 , x2 , y2 ) ; begin
1066: LD_INT 0
1068: PPUSH
// if x1 = x2 and y1 > y2 then
1069: LD_VAR 0 1
1073: PUSH
1074: LD_VAR 0 3
1078: EQUAL
1079: PUSH
1080: LD_VAR 0 2
1084: PUSH
1085: LD_VAR 0 4
1089: GREATER
1090: AND
1091: IFFALSE 1101
// result := 0 ;
1093: LD_ADDR_VAR 0 5
1097: PUSH
1098: LD_INT 0
1100: ST_TO_ADDR
// if x1 < x2 and y1 = y2 then
1101: LD_VAR 0 1
1105: PUSH
1106: LD_VAR 0 3
1110: LESS
1111: PUSH
1112: LD_VAR 0 2
1116: PUSH
1117: LD_VAR 0 4
1121: EQUAL
1122: AND
1123: IFFALSE 1133
// result := 1 ;
1125: LD_ADDR_VAR 0 5
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// if x1 < x2 and y1 < y2 then
1133: LD_VAR 0 1
1137: PUSH
1138: LD_VAR 0 3
1142: LESS
1143: PUSH
1144: LD_VAR 0 2
1148: PUSH
1149: LD_VAR 0 4
1153: LESS
1154: AND
1155: IFFALSE 1165
// result := 2 ;
1157: LD_ADDR_VAR 0 5
1161: PUSH
1162: LD_INT 2
1164: ST_TO_ADDR
// if x1 = x2 and y1 < y2 then
1165: LD_VAR 0 1
1169: PUSH
1170: LD_VAR 0 3
1174: EQUAL
1175: PUSH
1176: LD_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: LESS
1186: AND
1187: IFFALSE 1197
// result := 3 ;
1189: LD_ADDR_VAR 0 5
1193: PUSH
1194: LD_INT 3
1196: ST_TO_ADDR
// if x1 > x2 and y1 = y2 then
1197: LD_VAR 0 1
1201: PUSH
1202: LD_VAR 0 3
1206: GREATER
1207: PUSH
1208: LD_VAR 0 2
1212: PUSH
1213: LD_VAR 0 4
1217: EQUAL
1218: AND
1219: IFFALSE 1229
// result := 4 ;
1221: LD_ADDR_VAR 0 5
1225: PUSH
1226: LD_INT 4
1228: ST_TO_ADDR
// if x1 > x2 and y1 > y2 then
1229: LD_VAR 0 1
1233: PUSH
1234: LD_VAR 0 3
1238: GREATER
1239: PUSH
1240: LD_VAR 0 2
1244: PUSH
1245: LD_VAR 0 4
1249: GREATER
1250: AND
1251: IFFALSE 1261
// result := 5 ;
1253: LD_ADDR_VAR 0 5
1257: PUSH
1258: LD_INT 5
1260: ST_TO_ADDR
// end ;
1261: LD_VAR 0 5
1265: RET
// export function SetTeamExp ( amount ) ; var i , team , pep ; begin
1266: LD_INT 0
1268: PPUSH
1269: PPUSH
1270: PPUSH
1271: PPUSH
// team := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_OWVAR 2
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: EMPTY
1296: LIST
1297: LIST
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: ST_TO_ADDR
// for i = 1 to amount do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_VAR 0 1
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1405
// begin pep := rand ( 1 , team ) ;
1326: LD_ADDR_VAR 0 5
1330: PUSH
1331: LD_INT 1
1333: PPUSH
1334: LD_VAR 0 4
1338: PPUSH
1339: CALL_OW 12
1343: ST_TO_ADDR
// AddExperience ( team [ pep ] , rand ( 1 , 4 ) , rand ( 1000 , 10000 ) ) ;
1344: LD_VAR 0 4
1348: PUSH
1349: LD_VAR 0 5
1353: ARRAY
1354: PPUSH
1355: LD_INT 1
1357: PPUSH
1358: LD_INT 4
1360: PPUSH
1361: CALL_OW 12
1365: PPUSH
1366: LD_INT 1000
1368: PPUSH
1369: LD_INT 10000
1371: PPUSH
1372: CALL_OW 12
1376: PPUSH
1377: CALL_OW 492
// team := team diff team [ pep ] ;
1381: LD_ADDR_VAR 0 4
1385: PUSH
1386: LD_VAR 0 4
1390: PUSH
1391: LD_VAR 0 4
1395: PUSH
1396: LD_VAR 0 5
1400: ARRAY
1401: DIFF
1402: ST_TO_ADDR
// end ;
1403: GO 1323
1405: POP
1406: POP
// end ;
1407: LD_VAR 0 2
1411: RET
// export function PrepareGuards ( strenght ) ; var i , un , area , base_area , points , p , x , y , c , tmp ; begin
1412: LD_INT 0
1414: PPUSH
1415: PPUSH
1416: PPUSH
1417: PPUSH
1418: PPUSH
1419: PPUSH
1420: PPUSH
1421: PPUSH
1422: PPUSH
1423: PPUSH
1424: PPUSH
// area := AreaToList ( guardDir , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_INT 7
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 517
1440: ST_TO_ADDR
// base_area := AreaToList ( guardArea , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_INT 6
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 517
1456: ST_TO_ADDR
// for i = 1 to area [ 1 ] do
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: DOUBLE
1463: LD_INT 1
1465: DEC
1466: ST_TO_ADDR
1467: LD_VAR 0 5
1471: PUSH
1472: LD_INT 1
1474: ARRAY
1475: PUSH
1476: FOR_TO
1477: IFFALSE 1559
// begin points := Replace ( points , points + 1 , area [ 1 ] [ i ] ) ;
1479: LD_ADDR_VAR 0 7
1483: PUSH
1484: LD_VAR 0 7
1488: PPUSH
1489: LD_VAR 0 7
1493: PUSH
1494: LD_INT 1
1496: PLUS
1497: PPUSH
1498: LD_VAR 0 5
1502: PUSH
1503: LD_INT 1
1505: ARRAY
1506: PUSH
1507: LD_VAR 0 3
1511: ARRAY
1512: PPUSH
1513: CALL_OW 1
1517: ST_TO_ADDR
// points := Replace ( points , points + 1 , area [ 2 ] [ i ] ) ;
1518: LD_ADDR_VAR 0 7
1522: PUSH
1523: LD_VAR 0 7
1527: PPUSH
1528: LD_VAR 0 7
1532: PUSH
1533: LD_INT 1
1535: PLUS
1536: PPUSH
1537: LD_VAR 0 5
1541: PUSH
1542: LD_INT 2
1544: ARRAY
1545: PUSH
1546: LD_VAR 0 3
1550: ARRAY
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1476
1559: POP
1560: POP
// uc_side := 4 ;
1561: LD_ADDR_OWVAR 20
1565: PUSH
1566: LD_INT 4
1568: ST_TO_ADDR
// case strenght of 1 .. 10 :
1569: LD_VAR 0 1
1573: PUSH
1574: LD_INT 1
1576: DOUBLE
1577: GREATEREQUAL
1578: IFFALSE 1586
1580: LD_INT 10
1582: DOUBLE
1583: LESSEQUAL
1584: IFTRUE 1588
1586: GO 1650
1588: POP
// begin uc_nation := 0 ;
1589: LD_ADDR_OWVAR 21
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// for i = 1 to 20 do
1597: LD_ADDR_VAR 0 3
1601: PUSH
1602: DOUBLE
1603: LD_INT 1
1605: DEC
1606: ST_TO_ADDR
1607: LD_INT 20
1609: PUSH
1610: FOR_TO
1611: IFFALSE 1646
// begin PrepareHuman ( false , class_apeman_soldier , strenght ) ;
1613: LD_INT 0
1615: PPUSH
1616: LD_INT 15
1618: PPUSH
1619: LD_VAR 0 1
1623: PPUSH
1624: CALL_OW 380
// result := result ^ CreateHuman ;
1628: LD_ADDR_VAR 0 2
1632: PUSH
1633: LD_VAR 0 2
1637: PUSH
1638: CALL_OW 44
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1610
1646: POP
1647: POP
// end ; 11 .. 40 :
1648: GO 1837
1650: LD_INT 11
1652: DOUBLE
1653: GREATEREQUAL
1654: IFFALSE 1662
1656: LD_INT 40
1658: DOUBLE
1659: LESSEQUAL
1660: IFTRUE 1664
1662: GO 1743
1664: POP
// begin uc_nation := 1 ;
1665: LD_ADDR_OWVAR 21
1669: PUSH
1670: LD_INT 1
1672: ST_TO_ADDR
// for i = 1 to 20 do
1673: LD_ADDR_VAR 0 3
1677: PUSH
1678: DOUBLE
1679: LD_INT 1
1681: DEC
1682: ST_TO_ADDR
1683: LD_INT 20
1685: PUSH
1686: FOR_TO
1687: IFFALSE 1739
// begin vc_chassis := us_medium_tracked ;
1689: LD_ADDR_OWVAR 37
1693: PUSH
1694: LD_INT 3
1696: ST_TO_ADDR
// vc_engine := engine_siberite ;
1697: LD_ADDR_OWVAR 39
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// vc_control := control_computer ;
1705: LD_ADDR_OWVAR 38
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// vc_weapon := us_laser ;
1713: LD_ADDR_OWVAR 40
1717: PUSH
1718: LD_INT 9
1720: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1721: LD_ADDR_VAR 0 2
1725: PUSH
1726: LD_VAR 0 2
1730: PUSH
1731: CALL_OW 45
1735: ADD
1736: ST_TO_ADDR
// end ;
1737: GO 1686
1739: POP
1740: POP
// end ; 41 .. 100 :
1741: GO 1837
1743: LD_INT 41
1745: DOUBLE
1746: GREATEREQUAL
1747: IFFALSE 1755
1749: LD_INT 100
1751: DOUBLE
1752: LESSEQUAL
1753: IFTRUE 1757
1755: GO 1836
1757: POP
// begin uc_nation := 1 ;
1758: LD_ADDR_OWVAR 21
1762: PUSH
1763: LD_INT 1
1765: ST_TO_ADDR
// for i = 1 to 20 do
1766: LD_ADDR_VAR 0 3
1770: PUSH
1771: DOUBLE
1772: LD_INT 1
1774: DEC
1775: ST_TO_ADDR
1776: LD_INT 20
1778: PUSH
1779: FOR_TO
1780: IFFALSE 1832
// begin vc_chassis := us_morphling ;
1782: LD_ADDR_OWVAR 37
1786: PUSH
1787: LD_INT 5
1789: ST_TO_ADDR
// vc_engine := engine_siberite ;
1790: LD_ADDR_OWVAR 39
1794: PUSH
1795: LD_INT 3
1797: ST_TO_ADDR
// vc_control := control_computer ;
1798: LD_ADDR_OWVAR 38
1802: PUSH
1803: LD_INT 3
1805: ST_TO_ADDR
// vc_weapon := us_double_laser ;
1806: LD_ADDR_OWVAR 40
1810: PUSH
1811: LD_INT 10
1813: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 2
1823: PUSH
1824: CALL_OW 45
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1779
1832: POP
1833: POP
// end ; end ;
1834: GO 1837
1836: POP
// for i in result do
1837: LD_ADDR_VAR 0 3
1841: PUSH
1842: LD_VAR 0 2
1846: PUSH
1847: FOR_IN
1848: IFFALSE 2065
// begin x := base_area [ 1 ] [ 1 ] ;
1850: LD_ADDR_VAR 0 9
1854: PUSH
1855: LD_VAR 0 6
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PUSH
1864: LD_INT 1
1866: ARRAY
1867: ST_TO_ADDR
// y := base_area [ 2 ] [ 1 ] ;
1868: LD_ADDR_VAR 0 10
1872: PUSH
1873: LD_VAR 0 6
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PUSH
1882: LD_INT 1
1884: ARRAY
1885: ST_TO_ADDR
// p := FindNearestPoint ( points , x , y ) ;
1886: LD_ADDR_VAR 0 8
1890: PUSH
1891: LD_VAR 0 7
1895: PPUSH
1896: LD_VAR 0 9
1900: PPUSH
1901: LD_VAR 0 10
1905: PPUSH
1906: CALL_OW 439
1910: ST_TO_ADDR
// SetDir ( i , FindDir ( x , y , p [ 1 ] , p [ 2 ] ) ) ;
1911: LD_VAR 0 3
1915: PPUSH
1916: LD_VAR 0 9
1920: PPUSH
1921: LD_VAR 0 10
1925: PPUSH
1926: LD_VAR 0 8
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PPUSH
1935: LD_VAR 0 8
1939: PUSH
1940: LD_INT 2
1942: ARRAY
1943: PPUSH
1944: CALL 1066 0 4
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( i , x , y , true ) ;
1953: LD_VAR 0 3
1957: PPUSH
1958: LD_VAR 0 9
1962: PPUSH
1963: LD_VAR 0 10
1967: PPUSH
1968: LD_INT 1
1970: PPUSH
1971: CALL_OW 48
// ComHold ( i ) ;
1975: LD_VAR 0 3
1979: PPUSH
1980: CALL_OW 140
// for c = 1 to 2 do
1984: LD_ADDR_VAR 0 11
1988: PUSH
1989: DOUBLE
1990: LD_INT 1
1992: DEC
1993: ST_TO_ADDR
1994: LD_INT 2
1996: PUSH
1997: FOR_TO
1998: IFFALSE 2061
// begin tmp := base_area [ c ] ;
2000: LD_ADDR_VAR 0 12
2004: PUSH
2005: LD_VAR 0 6
2009: PUSH
2010: LD_VAR 0 11
2014: ARRAY
2015: ST_TO_ADDR
// tmp := Delete ( tmp , 1 ) ;
2016: LD_ADDR_VAR 0 12
2020: PUSH
2021: LD_VAR 0 12
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: CALL_OW 3
2033: ST_TO_ADDR
// base_area := Replace ( base_area , c , tmp ) ;
2034: LD_ADDR_VAR 0 6
2038: PUSH
2039: LD_VAR 0 6
2043: PPUSH
2044: LD_VAR 0 11
2048: PPUSH
2049: LD_VAR 0 12
2053: PPUSH
2054: CALL_OW 1
2058: ST_TO_ADDR
// end ;
2059: GO 1997
2061: POP
2062: POP
// end ;
2063: GO 1847
2065: POP
2066: POP
// end ;
2067: LD_VAR 0 2
2071: RET
// export function GetBack ( ) ; var i , c , un , new ; begin
2072: LD_INT 0
2074: PPUSH
2075: PPUSH
2076: PPUSH
2077: PPUSH
2078: PPUSH
// if graveyard = 0 then
2079: LD_EXP 8
2083: PUSH
2084: LD_INT 0
2086: EQUAL
2087: IFFALSE 2091
// exit ;
2089: GO 2254
// i := rand ( 1 , graveyard ) ;
2091: LD_ADDR_VAR 0 2
2095: PUSH
2096: LD_INT 1
2098: PPUSH
2099: LD_EXP 8
2103: PPUSH
2104: CALL_OW 12
2108: ST_TO_ADDR
// un := graveyard [ i ] ;
2109: LD_ADDR_VAR 0 4
2113: PUSH
2114: LD_EXP 8
2118: PUSH
2119: LD_VAR 0 2
2123: ARRAY
2124: ST_TO_ADDR
// for c in playerSquad do
2125: LD_ADDR_VAR 0 3
2129: PUSH
2130: LD_EXP 12
2134: PUSH
2135: FOR_IN
2136: IFFALSE 2172
// if un = c [ 1 ] then
2138: LD_VAR 0 4
2142: PUSH
2143: LD_VAR 0 3
2147: PUSH
2148: LD_INT 1
2150: ARRAY
2151: EQUAL
2152: IFFALSE 2170
// begin new := c [ 2 ] ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 3
2163: PUSH
2164: LD_INT 2
2166: ARRAY
2167: ST_TO_ADDR
// break ;
2168: GO 2172
// end ;
2170: GO 2135
2172: POP
2173: POP
// uc_side := your_side ;
2174: LD_ADDR_OWVAR 20
2178: PUSH
2179: LD_OWVAR 2
2183: ST_TO_ADDR
// uc_nation := playerNation ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_EXP 6
2193: ST_TO_ADDR
// un := CreateCharacter ( new ) ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_VAR 0 5
2203: PPUSH
2204: CALL_OW 34
2208: ST_TO_ADDR
// PlaceUnitXYR ( un , base_x , base_y , 10 , true ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_EXP 9
2218: PPUSH
2219: LD_EXP 10
2223: PPUSH
2224: LD_INT 10
2226: PPUSH
2227: LD_INT 1
2229: PPUSH
2230: CALL_OW 50
// graveyard := Delete ( graveyard , i ) ;
2234: LD_ADDR_EXP 8
2238: PUSH
2239: LD_EXP 8
2243: PPUSH
2244: LD_VAR 0 2
2248: PPUSH
2249: CALL_OW 3
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 1
2258: RET
// export function ComEspace ( un ) ; begin
2259: LD_INT 0
2261: PPUSH
// if not IsInArea ( un , zoneOut ) then
2262: LD_VAR 0 1
2266: PPUSH
2267: LD_INT 4
2269: PPUSH
2270: CALL_OW 308
2274: NOT
2275: IFFALSE 2291
// ComMoveToArea ( un , zoneOut ) else
2277: LD_VAR 0 1
2281: PPUSH
2282: LD_INT 4
2284: PPUSH
2285: CALL_OW 113
2289: GO 2300
// RemoveUnit ( un ) ;
2291: LD_VAR 0 1
2295: PPUSH
2296: CALL_OW 64
// end ;
2300: LD_VAR 0 2
2304: RET
// export function ComSpecMove ( un , area ) ; var list , new_list , i , x ; begin
2305: LD_INT 0
2307: PPUSH
2308: PPUSH
2309: PPUSH
2310: PPUSH
2311: PPUSH
// list := AreaToList ( area , 0 ) ;
2312: LD_ADDR_VAR 0 4
2316: PUSH
2317: LD_VAR 0 2
2321: PPUSH
2322: LD_INT 0
2324: PPUSH
2325: CALL_OW 517
2329: ST_TO_ADDR
// if not list then
2330: LD_VAR 0 4
2334: NOT
2335: IFFALSE 2339
// exit ;
2337: GO 2501
// for i = 1 to list do
2339: LD_ADDR_VAR 0 6
2343: PUSH
2344: DOUBLE
2345: LD_INT 1
2347: DEC
2348: ST_TO_ADDR
2349: LD_VAR 0 4
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2437
// begin new_list := Replace ( new_list , new_list + 1 , list [ 1 ] [ i ] ) ;
2357: LD_ADDR_VAR 0 5
2361: PUSH
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_VAR 0 5
2371: PUSH
2372: LD_INT 1
2374: PLUS
2375: PPUSH
2376: LD_VAR 0 4
2380: PUSH
2381: LD_INT 1
2383: ARRAY
2384: PUSH
2385: LD_VAR 0 6
2389: ARRAY
2390: PPUSH
2391: CALL_OW 1
2395: ST_TO_ADDR
// new_list := Replace ( new_list , new_list + 1 , list [ 2 ] [ i ] ) ;
2396: LD_ADDR_VAR 0 5
2400: PUSH
2401: LD_VAR 0 5
2405: PPUSH
2406: LD_VAR 0 5
2410: PUSH
2411: LD_INT 1
2413: PLUS
2414: PPUSH
2415: LD_VAR 0 4
2419: PUSH
2420: LD_INT 2
2422: ARRAY
2423: PUSH
2424: LD_VAR 0 6
2428: ARRAY
2429: PPUSH
2430: CALL_OW 1
2434: ST_TO_ADDR
// end ;
2435: GO 2354
2437: POP
2438: POP
// x := FindNearestPoint ( new_list , GetX ( un ) , GetY ( un ) ) ;
2439: LD_ADDR_VAR 0 7
2443: PUSH
2444: LD_VAR 0 5
2448: PPUSH
2449: LD_VAR 0 1
2453: PPUSH
2454: CALL_OW 250
2458: PPUSH
2459: LD_VAR 0 1
2463: PPUSH
2464: CALL_OW 251
2468: PPUSH
2469: CALL_OW 439
2473: ST_TO_ADDR
// ComMoveXY ( un , x [ 1 ] , x [ 2 ] ) ;
2474: LD_VAR 0 1
2478: PPUSH
2479: LD_VAR 0 7
2483: PUSH
2484: LD_INT 1
2486: ARRAY
2487: PPUSH
2488: LD_VAR 0 7
2492: PUSH
2493: LD_INT 2
2495: ARRAY
2496: PPUSH
2497: CALL_OW 111
// end ;
2501: LD_VAR 0 3
2505: RET
// export function ExplodeVehicle ( un ) ; var i , timer ; begin
2506: LD_INT 0
2508: PPUSH
2509: PPUSH
2510: PPUSH
// timer := rand ( 2 , 5 ) ;
2511: LD_ADDR_VAR 0 4
2515: PUSH
2516: LD_INT 2
2518: PPUSH
2519: LD_INT 5
2521: PPUSH
2522: CALL_OW 12
2526: ST_TO_ADDR
// while ( timer > 0 ) do
2527: LD_VAR 0 4
2531: PUSH
2532: LD_INT 0
2534: GREATER
2535: IFFALSE 2574
// begin SetUnitDisplayNumber ( un , timer ) ;
2537: LD_VAR 0 1
2541: PPUSH
2542: LD_VAR 0 4
2546: PPUSH
2547: CALL_OW 505
// timer := timer - 1 ;
2551: LD_ADDR_VAR 0 4
2555: PUSH
2556: LD_VAR 0 4
2560: PUSH
2561: LD_INT 1
2563: MINUS
2564: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
2565: LD_INT 35
2567: PPUSH
2568: CALL_OW 67
// end ;
2572: GO 2527
// if timer = 0 then
2574: LD_VAR 0 4
2578: PUSH
2579: LD_INT 0
2581: EQUAL
2582: IFFALSE 2631
// for i = 1 to 3 do
2584: LD_ADDR_VAR 0 3
2588: PUSH
2589: DOUBLE
2590: LD_INT 1
2592: DEC
2593: ST_TO_ADDR
2594: LD_INT 3
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2629
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
2600: LD_VAR 0 1
2604: PPUSH
2605: CALL_OW 250
2609: PPUSH
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 251
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 453
2627: GO 2597
2629: POP
2630: POP
// end ;
2631: LD_VAR 0 2
2635: RET
// export function DestinationReachable ( unit , x , y ) ; begin
2636: LD_INT 0
2638: PPUSH
// if unit in unreachableList then
2639: LD_VAR 0 1
2643: PUSH
2644: LD_EXP 13
2648: IN
2649: IFFALSE 2667
// unreachableList := unreachableList diff unit ;
2651: LD_ADDR_EXP 13
2655: PUSH
2656: LD_EXP 13
2660: PUSH
2661: LD_VAR 0 1
2665: DIFF
2666: ST_TO_ADDR
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
2667: LD_VAR 0 1
2671: PPUSH
2672: LD_VAR 0 2
2676: PPUSH
2677: LD_VAR 0 3
2681: PPUSH
2682: CALL_OW 428
2686: PPUSH
2687: CALL_OW 115
// Wait ( 1 ) ;
2691: LD_INT 1
2693: PPUSH
2694: CALL_OW 67
// if unit in unreachableList then
2698: LD_VAR 0 1
2702: PUSH
2703: LD_EXP 13
2707: IN
2708: IFFALSE 2720
// result := false else
2710: LD_ADDR_VAR 0 4
2714: PUSH
2715: LD_INT 0
2717: ST_TO_ADDR
2718: GO 2728
// result := true ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_INT 1
2727: ST_TO_ADDR
// end ;
2728: LD_VAR 0 4
2732: RET
// export function ComSpecAttack ( unit ) ; var i , enemy , t , x , y ; begin
2733: LD_INT 0
2735: PPUSH
2736: PPUSH
2737: PPUSH
2738: PPUSH
2739: PPUSH
2740: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
2741: LD_ADDR_VAR 0 4
2745: PUSH
2746: LD_INT 81
2748: PUSH
2749: LD_VAR 0 1
2753: PPUSH
2754: CALL_OW 255
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PPUSH
2763: CALL_OW 69
2767: ST_TO_ADDR
// if not enemy then
2768: LD_VAR 0 4
2772: NOT
2773: IFFALSE 2777
// exit ;
2775: GO 2927
// if UnitFilter ( enemy , [ f_occupied ] ) then
2777: LD_VAR 0 4
2781: PPUSH
2782: LD_INT 59
2784: PUSH
2785: EMPTY
2786: LIST
2787: PPUSH
2788: CALL_OW 72
2792: IFFALSE 2903
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
2794: LD_ADDR_VAR 0 5
2798: PUSH
2799: LD_VAR 0 4
2803: PPUSH
2804: LD_INT 59
2806: PUSH
2807: EMPTY
2808: LIST
2809: PPUSH
2810: CALL_OW 72
2814: PPUSH
2815: LD_VAR 0 1
2819: PPUSH
2820: CALL_OW 74
2824: ST_TO_ADDR
// x := GetX ( t ) ;
2825: LD_ADDR_VAR 0 6
2829: PUSH
2830: LD_VAR 0 5
2834: PPUSH
2835: CALL_OW 250
2839: ST_TO_ADDR
// y := GetY ( t ) ;
2840: LD_ADDR_VAR 0 7
2844: PUSH
2845: LD_VAR 0 5
2849: PPUSH
2850: CALL_OW 251
2854: ST_TO_ADDR
// if not DestinationReachable ( unit , x , y ) then
2855: LD_VAR 0 1
2859: PPUSH
2860: LD_VAR 0 6
2864: PPUSH
2865: LD_VAR 0 7
2869: PPUSH
2870: CALL 2636 0 3
2874: NOT
2875: IFFALSE 2901
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2877: LD_VAR 0 1
2881: PPUSH
2882: LD_VAR 0 4
2886: PPUSH
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 74
2896: PPUSH
2897: CALL_OW 115
// end else
2901: GO 2927
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2903: LD_VAR 0 1
2907: PPUSH
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_VAR 0 1
2917: PPUSH
2918: CALL_OW 74
2922: PPUSH
2923: CALL_OW 115
// end ; end_of_file
2927: LD_VAR 0 2
2931: RET
// export debug , points , difficultyLevel , timeToNextAttack , waveNumber , playerNation , game_started , graveyard , base_x , base_y , base , playerSquad ; end_of_file export function InitSettings ; begin
2932: LD_INT 0
2934: PPUSH
// difficultyLevel := GetMultiplayerSetting ( 0 ) ;
2935: LD_ADDR_EXP 3
2939: PUSH
2940: LD_INT 0
2942: PPUSH
2943: CALL_OW 426
2947: ST_TO_ADDR
// playerNation := GetMultiplayerSetting ( 1 ) - 1 ;
2948: LD_ADDR_EXP 6
2952: PUSH
2953: LD_INT 1
2955: PPUSH
2956: CALL_OW 426
2960: PUSH
2961: LD_INT 1
2963: MINUS
2964: ST_TO_ADDR
// end ; end_of_file
2965: LD_VAR 0 1
2969: RET
// export function InitGame ; begin
2970: LD_INT 0
2972: PPUSH
// ResetFog ;
2973: CALL_OW 335
// RandomizeAll ;
2977: CALL_OW 11
// LoadColors ;
2981: CALL 821 0 0
// debug := false ;
2985: LD_ADDR_EXP 1
2989: PUSH
2990: LD_INT 0
2992: ST_TO_ADDR
// ar_bio_bomb := 91 ;
2993: LD_ADDR_EXP 18
2997: PUSH
2998: LD_INT 91
3000: ST_TO_ADDR
// us_artillery := 97 ;
3001: LD_ADDR_EXP 17
3005: PUSH
3006: LD_INT 97
3008: ST_TO_ADDR
// ru_radar := 98 ;
3009: LD_ADDR_EXP 14
3013: PUSH
3014: LD_INT 98
3016: ST_TO_ADDR
// game_started := false ;
3017: LD_ADDR_EXP 7
3021: PUSH
3022: LD_INT 0
3024: ST_TO_ADDR
// points := 0 ;
3025: LD_ADDR_EXP 2
3029: PUSH
3030: LD_INT 0
3032: ST_TO_ADDR
// waveNumber := 0 ;
3033: LD_ADDR_EXP 5
3037: PUSH
3038: LD_INT 0
3040: ST_TO_ADDR
// timeToNextAttack := 0 ;
3041: LD_ADDR_EXP 4
3045: PUSH
3046: LD_INT 0
3048: ST_TO_ADDR
// graveyard := [ ] ;
3049: LD_ADDR_EXP 8
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// base_x := 1 ;
3056: LD_ADDR_EXP 9
3060: PUSH
3061: LD_INT 1
3063: ST_TO_ADDR
// base_y := 1 ;
3064: LD_ADDR_EXP 10
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// if difficultyLevel > 2 then
3072: LD_EXP 3
3076: PUSH
3077: LD_INT 2
3079: GREATER
3080: IFFALSE 3095
// SetTech ( 5 , 7 , state_researched ) ;
3082: LD_INT 5
3084: PPUSH
3085: LD_INT 7
3087: PPUSH
3088: LD_INT 2
3090: PPUSH
3091: CALL_OW 322
// if not playerNation then
3095: LD_EXP 6
3099: NOT
3100: IFFALSE 3126
// begin points := 100 ;
3102: LD_ADDR_EXP 2
3106: PUSH
3107: LD_INT 100
3109: ST_TO_ADDR
// playerNation := rand ( 1 , 3 ) ;
3110: LD_ADDR_EXP 6
3114: PUSH
3115: LD_INT 1
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 12
3125: ST_TO_ADDR
// end ; your_side := playerNation ;
3126: LD_ADDR_OWVAR 2
3130: PUSH
3131: LD_EXP 6
3135: ST_TO_ADDR
// ChangeSideFog ( your_side , 4 ) ;
3136: LD_OWVAR 2
3140: PPUSH
3141: LD_INT 4
3143: PPUSH
3144: CALL_OW 343
// PrepareResources ( [ [ 25 , 20 , 15 , 10 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] ] , [ 1 , 2 , 3 ] , 88 , 76 , 6 ) ;
3148: LD_INT 25
3150: PUSH
3151: LD_INT 20
3153: PUSH
3154: LD_INT 15
3156: PUSH
3157: LD_INT 10
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: LIST
3165: PUSH
3166: LD_EXP 3
3170: ARRAY
3171: PUSH
3172: LD_INT 5
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: LD_INT 2
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_EXP 3
3194: ARRAY
3195: PUSH
3196: LD_INT 5
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: LD_INT 2
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: PUSH
3214: LD_EXP 3
3218: ARRAY
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: PPUSH
3225: LD_INT 1
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 3
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: LIST
3238: PPUSH
3239: LD_INT 88
3241: PPUSH
3242: LD_INT 76
3244: PPUSH
3245: LD_INT 6
3247: PPUSH
3248: CALL 630 0 5
// PrepareSquad ( playerNation , [ 9 , 7 , 5 , 3 ] [ difficultyLevel ] , [ 24 , 16 , 12 , 8 ] [ difficultyLevel ] , 88 , 76 ) ;
3252: LD_EXP 6
3256: PPUSH
3257: LD_INT 9
3259: PUSH
3260: LD_INT 7
3262: PUSH
3263: LD_INT 5
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_EXP 3
3279: ARRAY
3280: PPUSH
3281: LD_INT 24
3283: PUSH
3284: LD_INT 16
3286: PUSH
3287: LD_INT 12
3289: PUSH
3290: LD_INT 8
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: PUSH
3299: LD_EXP 3
3303: ARRAY
3304: PPUSH
3305: LD_INT 88
3307: PPUSH
3308: LD_INT 76
3310: PPUSH
3311: CALL 339 0 5
// CenterNowOnXY ( 88 , 76 ) ;
3315: LD_INT 88
3317: PPUSH
3318: LD_INT 76
3320: PPUSH
3321: CALL_OW 86
// PlaceSeeing ( 90 , 79 , your_side , - 50 ) ;
3325: LD_INT 90
3327: PPUSH
3328: LD_INT 79
3330: PPUSH
3331: LD_OWVAR 2
3335: PPUSH
3336: LD_INT 50
3338: NEG
3339: PPUSH
3340: CALL_OW 330
// if debug then
3344: LD_EXP 1
3348: IFFALSE 3359
// FogOff ( your_side ) ;
3350: LD_OWVAR 2
3354: PPUSH
3355: CALL_OW 344
// end ;
3359: LD_VAR 0 1
3363: RET
// every 0 0$01 trigger game_started do var i ;
3364: LD_EXP 7
3368: IFFALSE 3602
3370: GO 3372
3372: DISABLE
3373: LD_INT 0
3375: PPUSH
// begin while ( game_started ) do
3376: LD_EXP 7
3380: IFFALSE 3602
// begin if FilterAllUnits ( [ f_side , 7 ] ) < 5 and timeToNextAttack <= 0 0$00 then
3382: LD_INT 22
3384: PUSH
3385: LD_INT 7
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PPUSH
3392: CALL_OW 69
3396: PUSH
3397: LD_INT 5
3399: LESS
3400: PUSH
3401: LD_EXP 4
3405: PUSH
3406: LD_INT 0
3408: LESSEQUAL
3409: AND
3410: IFFALSE 3593
// begin if FilterAllUnits ( [ f_side , 4 ] ) then
3412: LD_INT 22
3414: PUSH
3415: LD_INT 4
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PPUSH
3422: CALL_OW 69
3426: IFFALSE 3464
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3428: LD_ADDR_VAR 0 1
3432: PUSH
3433: LD_INT 22
3435: PUSH
3436: LD_INT 4
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PPUSH
3443: CALL_OW 69
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3462
// RemoveUnit ( i ) ;
3451: LD_VAR 0 1
3455: PPUSH
3456: CALL_OW 64
3460: GO 3448
3462: POP
3463: POP
// if ( waveNumber mod 3 = 0 or waveNumber mod 10 = 0 ) and waveNumber > 0 then
3464: LD_EXP 5
3468: PUSH
3469: LD_INT 3
3471: MOD
3472: PUSH
3473: LD_INT 0
3475: EQUAL
3476: PUSH
3477: LD_EXP 5
3481: PUSH
3482: LD_INT 10
3484: MOD
3485: PUSH
3486: LD_INT 0
3488: EQUAL
3489: OR
3490: PUSH
3491: LD_EXP 5
3495: PUSH
3496: LD_INT 0
3498: GREATER
3499: AND
3500: IFFALSE 3506
// InitBonus ;
3502: CALL 9606 0 0
// if waveNumber mod 10 = 0 then
3506: LD_EXP 5
3510: PUSH
3511: LD_INT 10
3513: MOD
3514: PUSH
3515: LD_INT 0
3517: EQUAL
3518: IFFALSE 3524
// SaveForQuickRestart ;
3520: CALL_OW 22
// if waveNumber = 100 then
3524: LD_EXP 5
3528: PUSH
3529: LD_INT 100
3531: EQUAL
3532: IFFALSE 3545
// begin FogOff ( your_side ) ;
3534: LD_OWVAR 2
3538: PPUSH
3539: CALL_OW 344
// break ;
3543: GO 3602
// end ; timeToNextAttack := rand ( 1 1$30 , 2 2$30 ) ;
3545: LD_ADDR_EXP 4
3549: PUSH
3550: LD_INT 3150
3552: PPUSH
3553: LD_INT 5250
3555: PPUSH
3556: CALL_OW 12
3560: ST_TO_ADDR
// Wait ( timeToNextAttack ) ;
3561: LD_EXP 4
3565: PPUSH
3566: CALL_OW 67
// waveNumber := waveNumber + 1 ;
3570: LD_ADDR_EXP 5
3574: PUSH
3575: LD_EXP 5
3579: PUSH
3580: LD_INT 1
3582: PLUS
3583: ST_TO_ADDR
// PrepareWave ( waveNumber ) ;
3584: LD_EXP 5
3588: PPUSH
3589: CALL 4597 0 1
// end ; Wait ( 0 0$01 ) ;
3593: LD_INT 35
3595: PPUSH
3596: CALL_OW 67
// end ;
3600: GO 3376
// end ;
3602: PPOPN 1
3604: END
// every 0 0$01 trigger timeToNextAttack > 0 0$00 do
3605: LD_EXP 4
3609: PUSH
3610: LD_INT 0
3612: GREATER
3613: IFFALSE 3633
3615: GO 3617
3617: DISABLE
// begin enable ;
3618: ENABLE
// timeToNextAttack := timeToNextAttack - 0 0$01 ;
3619: LD_ADDR_EXP 4
3623: PUSH
3624: LD_EXP 4
3628: PUSH
3629: LD_INT 35
3631: MINUS
3632: ST_TO_ADDR
// end ; end_of_file
3633: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
3634: LD_VAR 0 1
3638: PUSH
3639: LD_EXP 13
3643: IN
3644: NOT
3645: IFFALSE 3676
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
3647: LD_ADDR_EXP 13
3651: PUSH
3652: LD_EXP 13
3656: PPUSH
3657: LD_EXP 13
3661: PUSH
3662: LD_INT 1
3664: PLUS
3665: PPUSH
3666: LD_VAR 0 1
3670: PPUSH
3671: CALL_OW 2
3675: ST_TO_ADDR
// end ;
3676: PPOPN 1
3678: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side and GetType ( un ) = unit_human then
3679: LD_VAR 0 1
3683: PPUSH
3684: CALL_OW 255
3688: PUSH
3689: LD_OWVAR 2
3693: EQUAL
3694: PUSH
3695: LD_VAR 0 1
3699: PPUSH
3700: CALL_OW 247
3704: PUSH
3705: LD_INT 1
3707: EQUAL
3708: AND
3709: IFFALSE 3740
// begin graveyard := Insert ( graveyard , graveyard + 1 , un ) ;
3711: LD_ADDR_EXP 8
3715: PUSH
3716: LD_EXP 8
3720: PPUSH
3721: LD_EXP 8
3725: PUSH
3726: LD_INT 1
3728: PLUS
3729: PPUSH
3730: LD_VAR 0 1
3734: PPUSH
3735: CALL_OW 2
3739: ST_TO_ADDR
// end ; if GetSide ( un ) = 7 then
3740: LD_VAR 0 1
3744: PPUSH
3745: CALL_OW 255
3749: PUSH
3750: LD_INT 7
3752: EQUAL
3753: IFFALSE 4127
// begin if un in FilterAllUnits ( [ f_weapon , 91 ] ) then
3755: LD_VAR 0 1
3759: PUSH
3760: LD_INT 34
3762: PUSH
3763: LD_INT 91
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PPUSH
3770: CALL_OW 69
3774: IN
3775: IFFALSE 3820
// begin if Rand ( 1 , 100 ) <= 70 then
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 100
3782: PPUSH
3783: CALL_OW 12
3787: PUSH
3788: LD_INT 70
3790: LESSEQUAL
3791: IFFALSE 3820
// ArtContamination ( GetX ( un ) , GetY ( un ) , 10 ) ;
3793: LD_VAR 0 1
3797: PPUSH
3798: CALL_OW 250
3802: PPUSH
3803: LD_VAR 0 1
3807: PPUSH
3808: CALL_OW 251
3812: PPUSH
3813: LD_INT 10
3815: PPUSH
3816: CALL_OW 495
// end ; case GetType ( un ) of unit_human :
3820: LD_VAR 0 1
3824: PPUSH
3825: CALL_OW 247
3829: PUSH
3830: LD_INT 1
3832: DOUBLE
3833: EQUAL
3834: IFTRUE 3838
3836: GO 3972
3838: POP
// begin case GetClass ( un ) of class_apeman :
3839: LD_VAR 0 1
3843: PPUSH
3844: CALL_OW 257
3848: PUSH
3849: LD_INT 12
3851: DOUBLE
3852: EQUAL
3853: IFTRUE 3857
3855: GO 3867
3857: POP
// AddPoints ( 2 ) ; class_apeman_soldier :
3858: LD_INT 2
3860: PPUSH
3861: CALL 797 0 1
3865: GO 3970
3867: LD_INT 15
3869: DOUBLE
3870: EQUAL
3871: IFTRUE 3875
3873: GO 3885
3875: POP
// AddPoints ( 5 ) ; class_apeman_kamikaze :
3876: LD_INT 5
3878: PPUSH
3879: CALL 797 0 1
3883: GO 3970
3885: LD_INT 17
3887: DOUBLE
3888: EQUAL
3889: IFTRUE 3893
3891: GO 3903
3893: POP
// AddPoints ( 30 ) ; class_soldier :
3894: LD_INT 30
3896: PPUSH
3897: CALL 797 0 1
3901: GO 3970
3903: LD_INT 1
3905: DOUBLE
3906: EQUAL
3907: IFTRUE 3911
3909: GO 3921
3911: POP
// AddPoints ( 50 ) ; class_bazooker , class_sniper , class_mortar :
3912: LD_INT 50
3914: PPUSH
3915: CALL 797 0 1
3919: GO 3970
3921: LD_INT 9
3923: DOUBLE
3924: EQUAL
3925: IFTRUE 3941
3927: LD_INT 5
3929: DOUBLE
3930: EQUAL
3931: IFTRUE 3941
3933: LD_INT 8
3935: DOUBLE
3936: EQUAL
3937: IFTRUE 3941
3939: GO 3951
3941: POP
// AddPoints ( 75 ) ; class_mechanic :
3942: LD_INT 75
3944: PPUSH
3945: CALL 797 0 1
3949: GO 3970
3951: LD_INT 3
3953: DOUBLE
3954: EQUAL
3955: IFTRUE 3959
3957: GO 3969
3959: POP
// AddPoints ( 60 ) ; end ;
3960: LD_INT 60
3962: PPUSH
3963: CALL 797 0 1
3967: GO 3970
3969: POP
// end ; unit_vehicle :
3970: GO 4127
3972: LD_INT 2
3974: DOUBLE
3975: EQUAL
3976: IFTRUE 3980
3978: GO 4126
3980: POP
// begin case GetChassis ( un ) of ar_light_trike , us_light_wheeled , ar_hovercraft :
3981: LD_VAR 0 1
3985: PPUSH
3986: CALL_OW 265
3990: PUSH
3991: LD_INT 12
3993: DOUBLE
3994: EQUAL
3995: IFTRUE 4011
3997: LD_INT 1
3999: DOUBLE
4000: EQUAL
4001: IFTRUE 4011
4003: LD_INT 11
4005: DOUBLE
4006: EQUAL
4007: IFTRUE 4011
4009: GO 4021
4011: POP
// AddPoints ( 100 ) ; ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , ru_medium_wheeled , ru_medium_tracked :
4012: LD_INT 100
4014: PPUSH
4015: CALL 797 0 1
4019: GO 4124
4021: LD_INT 13
4023: DOUBLE
4024: EQUAL
4025: IFTRUE 4059
4027: LD_INT 14
4029: DOUBLE
4030: EQUAL
4031: IFTRUE 4059
4033: LD_INT 2
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4059
4039: LD_INT 3
4041: DOUBLE
4042: EQUAL
4043: IFTRUE 4059
4045: LD_INT 21
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4059
4051: LD_INT 22
4053: DOUBLE
4054: EQUAL
4055: IFTRUE 4059
4057: GO 4069
4059: POP
// AddPoints ( 250 ) ; us_heavy_tracked , us_morphling , ru_heavy_wheeled , ru_heavy_tracked :
4060: LD_INT 250
4062: PPUSH
4063: CALL 797 0 1
4067: GO 4124
4069: LD_INT 4
4071: DOUBLE
4072: EQUAL
4073: IFTRUE 4095
4075: LD_INT 5
4077: DOUBLE
4078: EQUAL
4079: IFTRUE 4095
4081: LD_INT 23
4083: DOUBLE
4084: EQUAL
4085: IFTRUE 4095
4087: LD_INT 24
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4095
4093: GO 4105
4095: POP
// AddPoints ( 500 ) ; 25 :
4096: LD_INT 500
4098: PPUSH
4099: CALL 797 0 1
4103: GO 4124
4105: LD_INT 25
4107: DOUBLE
4108: EQUAL
4109: IFTRUE 4113
4111: GO 4123
4113: POP
// AddPoints ( 1250 ) ; end ;
4114: LD_INT 1250
4116: PPUSH
4117: CALL 797 0 1
4121: GO 4124
4123: POP
// end ; end ;
4124: GO 4127
4126: POP
// end ; end ;
4127: PPOPN 1
4129: END
// on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot then
4130: LD_VAR 0 1
4134: PPUSH
4135: CALL_OW 266
4139: PUSH
4140: LD_INT 0
4142: EQUAL
4143: IFFALSE 4193
// begin base_x := GetX ( b ) ;
4145: LD_ADDR_EXP 9
4149: PUSH
4150: LD_VAR 0 1
4154: PPUSH
4155: CALL_OW 250
4159: ST_TO_ADDR
// base_y := GetY ( b ) ;
4160: LD_ADDR_EXP 10
4164: PUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 251
4174: ST_TO_ADDR
// base := b ;
4175: LD_ADDR_EXP 11
4179: PUSH
4180: LD_VAR 0 1
4184: ST_TO_ADDR
// game_started := true ;
4185: LD_ADDR_EXP 7
4189: PUSH
4190: LD_INT 1
4192: ST_TO_ADDR
// end ; end ;
4193: PPOPN 1
4195: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = your_side then
4196: LD_VAR 0 1
4200: PPUSH
4201: CALL_OW 255
4205: PUSH
4206: LD_OWVAR 2
4210: EQUAL
4211: IFFALSE 4215
// exit ;
4213: GO 4362
// if GetType ( un ) = unit_vehicle then
4215: LD_VAR 0 1
4219: PPUSH
4220: CALL_OW 247
4224: PUSH
4225: LD_INT 2
4227: EQUAL
4228: IFFALSE 4281
// begin KillUnit ( un ) ;
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 66
// if GetNation ( un ) = nation_arabian or GetWeapon ( un ) in [ ru_time_lapser ] then
4239: LD_VAR 0 1
4243: PPUSH
4244: CALL_OW 248
4248: PUSH
4249: LD_INT 2
4251: EQUAL
4252: PUSH
4253: LD_VAR 0 1
4257: PPUSH
4258: CALL_OW 264
4262: PUSH
4263: LD_INT 49
4265: PUSH
4266: EMPTY
4267: LIST
4268: IN
4269: OR
4270: IFFALSE 4281
// ExplodeVehicle ( un ) ;
4272: LD_VAR 0 1
4276: PPUSH
4277: CALL 2506 0 1
// end ; if GetType ( un ) = unit_human then
4281: LD_VAR 0 1
4285: PPUSH
4286: CALL_OW 247
4290: PUSH
4291: LD_INT 1
4293: EQUAL
4294: IFFALSE 4362
// begin if ( GetNation ( un ) = 2 and GetTech ( 5 , 7 ) <> state_researched ) or GetNation ( un ) in [ 0 , 1 , 3 ] then
4296: LD_VAR 0 1
4300: PPUSH
4301: CALL_OW 248
4305: PUSH
4306: LD_INT 2
4308: EQUAL
4309: PUSH
4310: LD_INT 5
4312: PPUSH
4313: LD_INT 7
4315: PPUSH
4316: CALL_OW 321
4320: PUSH
4321: LD_INT 2
4323: NONEQUAL
4324: AND
4325: PUSH
4326: LD_VAR 0 1
4330: PPUSH
4331: CALL_OW 248
4335: PUSH
4336: LD_INT 0
4338: PUSH
4339: LD_INT 1
4341: PUSH
4342: LD_INT 3
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: LIST
4349: IN
4350: OR
4351: IFFALSE 4362
// KillUnit ( un ) ;
4353: LD_VAR 0 1
4357: PPUSH
4358: CALL_OW 66
// end ; end ;
4362: PPOPN 1
4364: END
// every 0 0$1 do
4365: GO 4367
4367: DISABLE
// begin enable ;
4368: ENABLE
// CheckBuildUpArea ( zoneOut , zoneIn , [ f_side , your_side ] ) ;
4369: LD_INT 4
4371: PPUSH
4372: LD_INT 5
4374: PPUSH
4375: LD_INT 22
4377: PUSH
4378: LD_OWVAR 2
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PPUSH
4387: CALL_OW 513
// end ;
4391: END
// every 0 0$01 trigger game_started and FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) = 0 do
4392: LD_EXP 7
4396: PUSH
4397: LD_INT 22
4399: PUSH
4400: LD_OWVAR 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 21
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PPUSH
4423: CALL_OW 69
4427: PUSH
4428: LD_INT 0
4430: EQUAL
4431: AND
4432: IFFALSE 4444
4434: GO 4436
4436: DISABLE
// YouLost ( die ) ;
4437: LD_STRING die
4439: PPUSH
4440: CALL_OW 104
4444: END
// every 0 0$21 trigger tick <= 15 15$00 do
4445: LD_OWVAR 1
4449: PUSH
4450: LD_INT 31500
4452: LESSEQUAL
4453: IFFALSE 4480
4455: GO 4457
4457: DISABLE
// begin enable ;
4458: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4459: LD_INT 1
4461: PPUSH
4462: LD_INT 5
4464: PPUSH
4465: CALL_OW 12
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 1
4475: PPUSH
4476: CALL_OW 55
// end ;
4480: END
// every 0 0$51 trigger tick > 15 15$00 do
4481: LD_OWVAR 1
4485: PUSH
4486: LD_INT 31500
4488: GREATER
4489: IFFALSE 4536
4491: GO 4493
4493: DISABLE
// begin enable ;
4494: ENABLE
// if FilterAllUnits ( [ f_side , 7 ] ) = 0 then
4495: LD_INT 22
4497: PUSH
4498: LD_INT 7
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PPUSH
4505: CALL_OW 69
4509: PUSH
4510: LD_INT 0
4512: EQUAL
4513: IFFALSE 4536
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4515: LD_INT 1
4517: PPUSH
4518: LD_INT 5
4520: PPUSH
4521: CALL_OW 12
4525: PPUSH
4526: LD_INT 3
4528: PPUSH
4529: LD_INT 1
4531: PPUSH
4532: CALL_OW 55
// end ;
4536: END
// on BuildingStarted ( building , builder ) do begin if IsInArea ( building , cratesSpawn ) then
4537: LD_VAR 0 1
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: CALL_OW 308
4549: IFFALSE 4560
// KillUnit ( building ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: CALL_OW 66
// end ;
4560: PPOPN 2
4562: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4563: LD_VAR 0 1
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_VAR 0 3
4577: PPUSH
4578: CALL 14846 0 3
// end ;
4582: PPOPN 3
4584: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4585: LD_VAR 0 1
4589: PPUSH
4590: CALL 14944 0 1
// end ; end_of_file
4594: PPOPN 1
4596: END
// export function PrepareWave ( num ) ; var i , un , skill , veh , area , a , l , c ; begin
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
4605: PPUSH
4606: PPUSH
4607: PPUSH
// area := [ Enemy1 , Enemy2 ] ;
4608: LD_ADDR_VAR 0 7
4612: PUSH
4613: LD_INT 1
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: ST_TO_ADDR
// uc_side := 7 ;
4623: LD_ADDR_OWVAR 20
4627: PUSH
4628: LD_INT 7
4630: ST_TO_ADDR
// l := 0 ;
4631: LD_ADDR_VAR 0 9
4635: PUSH
4636: LD_INT 0
4638: ST_TO_ADDR
// case num of 1 :
4639: LD_VAR 0 1
4643: PUSH
4644: LD_INT 1
4646: DOUBLE
4647: EQUAL
4648: IFTRUE 4652
4650: GO 4671
4652: POP
// result := Wave1 ( 12 , 1 ) ; 2 :
4653: LD_ADDR_VAR 0 2
4657: PUSH
4658: LD_INT 12
4660: PPUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL 7000 0 2
4668: ST_TO_ADDR
4669: GO 6809
4671: LD_INT 2
4673: DOUBLE
4674: EQUAL
4675: IFTRUE 4679
4677: GO 4698
4679: POP
// result := Wave2 ( 12 , 1 ) ; 3 :
4680: LD_ADDR_VAR 0 2
4684: PUSH
4685: LD_INT 12
4687: PPUSH
4688: LD_INT 1
4690: PPUSH
4691: CALL 7071 0 2
4695: ST_TO_ADDR
4696: GO 6809
4698: LD_INT 3
4700: DOUBLE
4701: EQUAL
4702: IFTRUE 4706
4704: GO 4725
4706: POP
// result := Wave3 ( 12 , 1 ) ; 4 :
4707: LD_ADDR_VAR 0 2
4711: PUSH
4712: LD_INT 12
4714: PPUSH
4715: LD_INT 1
4717: PPUSH
4718: CALL 7142 0 2
4722: ST_TO_ADDR
4723: GO 6809
4725: LD_INT 4
4727: DOUBLE
4728: EQUAL
4729: IFTRUE 4733
4731: GO 4752
4733: POP
// result := Wave4 ( 7 , 1 ) ; 5 :
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 7
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL 7221 0 2
4749: ST_TO_ADDR
4750: GO 6809
4752: LD_INT 5
4754: DOUBLE
4755: EQUAL
4756: IFTRUE 4760
4758: GO 4779
4760: POP
// result := Wave5 ( 7 , 1 ) ; 6 :
4761: LD_ADDR_VAR 0 2
4765: PUSH
4766: LD_INT 7
4768: PPUSH
4769: LD_INT 1
4771: PPUSH
4772: CALL 7617 0 2
4776: ST_TO_ADDR
4777: GO 6809
4779: LD_INT 6
4781: DOUBLE
4782: EQUAL
4783: IFTRUE 4787
4785: GO 4806
4787: POP
// result := Wave6 ( 6 , 1 ) ; 7 :
4788: LD_ADDR_VAR 0 2
4792: PUSH
4793: LD_INT 6
4795: PPUSH
4796: LD_INT 1
4798: PPUSH
4799: CALL 8037 0 2
4803: ST_TO_ADDR
4804: GO 6809
4806: LD_INT 7
4808: DOUBLE
4809: EQUAL
4810: IFTRUE 4814
4812: GO 4833
4814: POP
// result := Wave7 ( 15 , 1 ) ; 8 :
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: LD_INT 15
4822: PPUSH
4823: LD_INT 1
4825: PPUSH
4826: CALL 8457 0 2
4830: ST_TO_ADDR
4831: GO 6809
4833: LD_INT 8
4835: DOUBLE
4836: EQUAL
4837: IFTRUE 4841
4839: GO 4860
4841: POP
// result := Wave8 ( 7 , 1 ) ; 9 :
4842: LD_ADDR_VAR 0 2
4846: PUSH
4847: LD_INT 7
4849: PPUSH
4850: LD_INT 1
4852: PPUSH
4853: CALL 8558 0 2
4857: ST_TO_ADDR
4858: GO 6809
4860: LD_INT 9
4862: DOUBLE
4863: EQUAL
4864: IFTRUE 4868
4866: GO 4899
4868: POP
// result := Wave8 ( 4 , 1 ) ^ Wave5 ( 7 , 1 ) ; 10 :
4869: LD_ADDR_VAR 0 2
4873: PUSH
4874: LD_INT 4
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: CALL 8558 0 2
4884: PUSH
4885: LD_INT 7
4887: PPUSH
4888: LD_INT 1
4890: PPUSH
4891: CALL 7617 0 2
4895: ADD
4896: ST_TO_ADDR
4897: GO 6809
4899: LD_INT 10
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4938
4907: POP
// result := Wave7 ( 9 , 1 ) ^ Wave3 ( 14 , 1 ) ; 11 , 21 , 31 , 41 , 51 , 61 , 71 , 81 , 91 :
4908: LD_ADDR_VAR 0 2
4912: PUSH
4913: LD_INT 9
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: CALL 8457 0 2
4923: PUSH
4924: LD_INT 14
4926: PPUSH
4927: LD_INT 1
4929: PPUSH
4930: CALL 7142 0 2
4934: ADD
4935: ST_TO_ADDR
4936: GO 6809
4938: LD_INT 11
4940: DOUBLE
4941: EQUAL
4942: IFTRUE 4994
4944: LD_INT 21
4946: DOUBLE
4947: EQUAL
4948: IFTRUE 4994
4950: LD_INT 31
4952: DOUBLE
4953: EQUAL
4954: IFTRUE 4994
4956: LD_INT 41
4958: DOUBLE
4959: EQUAL
4960: IFTRUE 4994
4962: LD_INT 51
4964: DOUBLE
4965: EQUAL
4966: IFTRUE 4994
4968: LD_INT 61
4970: DOUBLE
4971: EQUAL
4972: IFTRUE 4994
4974: LD_INT 71
4976: DOUBLE
4977: EQUAL
4978: IFTRUE 4994
4980: LD_INT 81
4982: DOUBLE
4983: EQUAL
4984: IFTRUE 4994
4986: LD_INT 91
4988: DOUBLE
4989: EQUAL
4990: IFTRUE 4994
4992: GO 5103
4994: POP
// result := Wave1 ( [ 20 , 30 , 40 , 45 , 50 , 60 , 70 , 80 , 100 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 12 , 22 , 32 , 42 , 52 , 62 , 72 , 82 , 92 :
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: LD_INT 20
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 40
5008: PUSH
5009: LD_INT 45
5011: PUSH
5012: LD_INT 50
5014: PUSH
5015: LD_INT 60
5017: PUSH
5018: LD_INT 70
5020: PUSH
5021: LD_INT 80
5023: PUSH
5024: LD_INT 100
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: LD_VAR 0 1
5042: PUSH
5043: LD_INT 10
5045: DIV
5046: ARRAY
5047: PPUSH
5048: LD_INT 2
5050: PUSH
5051: LD_INT 3
5053: PUSH
5054: LD_INT 4
5056: PUSH
5057: LD_INT 5
5059: PUSH
5060: LD_INT 6
5062: PUSH
5063: LD_INT 7
5065: PUSH
5066: LD_INT 8
5068: PUSH
5069: LD_INT 9
5071: PUSH
5072: LD_INT 10
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: PUSH
5086: LD_VAR 0 1
5090: PUSH
5091: LD_INT 10
5093: DIV
5094: ARRAY
5095: PPUSH
5096: CALL 7000 0 2
5100: ST_TO_ADDR
5101: GO 6809
5103: LD_INT 12
5105: DOUBLE
5106: EQUAL
5107: IFTRUE 5159
5109: LD_INT 22
5111: DOUBLE
5112: EQUAL
5113: IFTRUE 5159
5115: LD_INT 32
5117: DOUBLE
5118: EQUAL
5119: IFTRUE 5159
5121: LD_INT 42
5123: DOUBLE
5124: EQUAL
5125: IFTRUE 5159
5127: LD_INT 52
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5159
5133: LD_INT 62
5135: DOUBLE
5136: EQUAL
5137: IFTRUE 5159
5139: LD_INT 72
5141: DOUBLE
5142: EQUAL
5143: IFTRUE 5159
5145: LD_INT 82
5147: DOUBLE
5148: EQUAL
5149: IFTRUE 5159
5151: LD_INT 92
5153: DOUBLE
5154: EQUAL
5155: IFTRUE 5159
5157: GO 5268
5159: POP
// result := Wave2 ( [ 16 , 21 , 28 , 33 , 39 , 46 , 56 , 66 , 80 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 13 , 23 , 33 , 43 , 53 , 63 , 73 , 83 , 93 :
5160: LD_ADDR_VAR 0 2
5164: PUSH
5165: LD_INT 16
5167: PUSH
5168: LD_INT 21
5170: PUSH
5171: LD_INT 28
5173: PUSH
5174: LD_INT 33
5176: PUSH
5177: LD_INT 39
5179: PUSH
5180: LD_INT 46
5182: PUSH
5183: LD_INT 56
5185: PUSH
5186: LD_INT 66
5188: PUSH
5189: LD_INT 80
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_VAR 0 1
5207: PUSH
5208: LD_INT 10
5210: DIV
5211: ARRAY
5212: PPUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: LD_INT 4
5221: PUSH
5222: LD_INT 5
5224: PUSH
5225: LD_INT 6
5227: PUSH
5228: LD_INT 7
5230: PUSH
5231: LD_INT 8
5233: PUSH
5234: LD_INT 9
5236: PUSH
5237: LD_INT 10
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PUSH
5251: LD_VAR 0 1
5255: PUSH
5256: LD_INT 10
5258: DIV
5259: ARRAY
5260: PPUSH
5261: CALL 7071 0 2
5265: ST_TO_ADDR
5266: GO 6809
5268: LD_INT 13
5270: DOUBLE
5271: EQUAL
5272: IFTRUE 5324
5274: LD_INT 23
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5324
5280: LD_INT 33
5282: DOUBLE
5283: EQUAL
5284: IFTRUE 5324
5286: LD_INT 43
5288: DOUBLE
5289: EQUAL
5290: IFTRUE 5324
5292: LD_INT 53
5294: DOUBLE
5295: EQUAL
5296: IFTRUE 5324
5298: LD_INT 63
5300: DOUBLE
5301: EQUAL
5302: IFTRUE 5324
5304: LD_INT 73
5306: DOUBLE
5307: EQUAL
5308: IFTRUE 5324
5310: LD_INT 83
5312: DOUBLE
5313: EQUAL
5314: IFTRUE 5324
5316: LD_INT 93
5318: DOUBLE
5319: EQUAL
5320: IFTRUE 5324
5322: GO 5433
5324: POP
// result := Wave3 ( [ 14 , 18 , 22 , 27 , 33 , 39 , 44 , 57 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 14 , 24 , 34 , 44 , 54 , 64 , 74 , 84 , 94 :
5325: LD_ADDR_VAR 0 2
5329: PUSH
5330: LD_INT 14
5332: PUSH
5333: LD_INT 18
5335: PUSH
5336: LD_INT 22
5338: PUSH
5339: LD_INT 27
5341: PUSH
5342: LD_INT 33
5344: PUSH
5345: LD_INT 39
5347: PUSH
5348: LD_INT 44
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: LD_INT 65
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PUSH
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 10
5375: DIV
5376: ARRAY
5377: PPUSH
5378: LD_INT 2
5380: PUSH
5381: LD_INT 3
5383: PUSH
5384: LD_INT 4
5386: PUSH
5387: LD_INT 5
5389: PUSH
5390: LD_INT 6
5392: PUSH
5393: LD_INT 7
5395: PUSH
5396: LD_INT 8
5398: PUSH
5399: LD_INT 9
5401: PUSH
5402: LD_INT 10
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: LIST
5415: PUSH
5416: LD_VAR 0 1
5420: PUSH
5421: LD_INT 10
5423: DIV
5424: ARRAY
5425: PPUSH
5426: CALL 7142 0 2
5430: ST_TO_ADDR
5431: GO 6809
5433: LD_INT 14
5435: DOUBLE
5436: EQUAL
5437: IFTRUE 5489
5439: LD_INT 24
5441: DOUBLE
5442: EQUAL
5443: IFTRUE 5489
5445: LD_INT 34
5447: DOUBLE
5448: EQUAL
5449: IFTRUE 5489
5451: LD_INT 44
5453: DOUBLE
5454: EQUAL
5455: IFTRUE 5489
5457: LD_INT 54
5459: DOUBLE
5460: EQUAL
5461: IFTRUE 5489
5463: LD_INT 64
5465: DOUBLE
5466: EQUAL
5467: IFTRUE 5489
5469: LD_INT 74
5471: DOUBLE
5472: EQUAL
5473: IFTRUE 5489
5475: LD_INT 84
5477: DOUBLE
5478: EQUAL
5479: IFTRUE 5489
5481: LD_INT 94
5483: DOUBLE
5484: EQUAL
5485: IFTRUE 5489
5487: GO 5598
5489: POP
// result := Wave4 ( [ 9 , 15 , 22 , 30 , 39 , 45 , 56 , 60 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 15 , 25 , 35 , 45 , 55 , 65 , 75 , 85 , 95 :
5490: LD_ADDR_VAR 0 2
5494: PUSH
5495: LD_INT 9
5497: PUSH
5498: LD_INT 15
5500: PUSH
5501: LD_INT 22
5503: PUSH
5504: LD_INT 30
5506: PUSH
5507: LD_INT 39
5509: PUSH
5510: LD_INT 45
5512: PUSH
5513: LD_INT 56
5515: PUSH
5516: LD_INT 60
5518: PUSH
5519: LD_INT 65
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_VAR 0 1
5537: PUSH
5538: LD_INT 10
5540: DIV
5541: ARRAY
5542: PPUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: LD_INT 4
5551: PUSH
5552: LD_INT 5
5554: PUSH
5555: LD_INT 6
5557: PUSH
5558: LD_INT 7
5560: PUSH
5561: LD_INT 8
5563: PUSH
5564: LD_INT 9
5566: PUSH
5567: LD_INT 10
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: LIST
5580: PUSH
5581: LD_VAR 0 1
5585: PUSH
5586: LD_INT 10
5588: DIV
5589: ARRAY
5590: PPUSH
5591: CALL 7221 0 2
5595: ST_TO_ADDR
5596: GO 6809
5598: LD_INT 15
5600: DOUBLE
5601: EQUAL
5602: IFTRUE 5654
5604: LD_INT 25
5606: DOUBLE
5607: EQUAL
5608: IFTRUE 5654
5610: LD_INT 35
5612: DOUBLE
5613: EQUAL
5614: IFTRUE 5654
5616: LD_INT 45
5618: DOUBLE
5619: EQUAL
5620: IFTRUE 5654
5622: LD_INT 55
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5654
5628: LD_INT 65
5630: DOUBLE
5631: EQUAL
5632: IFTRUE 5654
5634: LD_INT 75
5636: DOUBLE
5637: EQUAL
5638: IFTRUE 5654
5640: LD_INT 85
5642: DOUBLE
5643: EQUAL
5644: IFTRUE 5654
5646: LD_INT 95
5648: DOUBLE
5649: EQUAL
5650: IFTRUE 5654
5652: GO 5763
5654: POP
// result := Wave5 ( [ 6 , 11 , 15 , 20 , 25 , 30 , 35 , 40 , 45 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 16 , 26 , 36 , 46 , 56 , 66 , 76 , 86 , 96 :
5655: LD_ADDR_VAR 0 2
5659: PUSH
5660: LD_INT 6
5662: PUSH
5663: LD_INT 11
5665: PUSH
5666: LD_INT 15
5668: PUSH
5669: LD_INT 20
5671: PUSH
5672: LD_INT 25
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 35
5680: PUSH
5681: LD_INT 40
5683: PUSH
5684: LD_INT 45
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_VAR 0 1
5702: PUSH
5703: LD_INT 10
5705: DIV
5706: ARRAY
5707: PPUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: LD_INT 4
5716: PUSH
5717: LD_INT 5
5719: PUSH
5720: LD_INT 6
5722: PUSH
5723: LD_INT 7
5725: PUSH
5726: LD_INT 8
5728: PUSH
5729: LD_INT 9
5731: PUSH
5732: LD_INT 10
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: LD_VAR 0 1
5750: PUSH
5751: LD_INT 10
5753: DIV
5754: ARRAY
5755: PPUSH
5756: CALL 7617 0 2
5760: ST_TO_ADDR
5761: GO 6809
5763: LD_INT 16
5765: DOUBLE
5766: EQUAL
5767: IFTRUE 5819
5769: LD_INT 26
5771: DOUBLE
5772: EQUAL
5773: IFTRUE 5819
5775: LD_INT 36
5777: DOUBLE
5778: EQUAL
5779: IFTRUE 5819
5781: LD_INT 46
5783: DOUBLE
5784: EQUAL
5785: IFTRUE 5819
5787: LD_INT 56
5789: DOUBLE
5790: EQUAL
5791: IFTRUE 5819
5793: LD_INT 66
5795: DOUBLE
5796: EQUAL
5797: IFTRUE 5819
5799: LD_INT 76
5801: DOUBLE
5802: EQUAL
5803: IFTRUE 5819
5805: LD_INT 86
5807: DOUBLE
5808: EQUAL
5809: IFTRUE 5819
5811: LD_INT 96
5813: DOUBLE
5814: EQUAL
5815: IFTRUE 5819
5817: GO 5928
5819: POP
// result := Wave6 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 17 , 27 , 37 , 47 , 57 , 67 , 77 , 87 , 97 :
5820: LD_ADDR_VAR 0 2
5824: PUSH
5825: LD_INT 9
5827: PUSH
5828: LD_INT 12
5830: PUSH
5831: LD_INT 15
5833: PUSH
5834: LD_INT 18
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 24
5842: PUSH
5843: LD_INT 27
5845: PUSH
5846: LD_INT 30
5848: PUSH
5849: LD_INT 33
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_VAR 0 1
5867: PUSH
5868: LD_INT 10
5870: DIV
5871: ARRAY
5872: PPUSH
5873: LD_INT 2
5875: PUSH
5876: LD_INT 3
5878: PUSH
5879: LD_INT 4
5881: PUSH
5882: LD_INT 5
5884: PUSH
5885: LD_INT 6
5887: PUSH
5888: LD_INT 7
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: LD_INT 9
5896: PUSH
5897: LD_INT 10
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: PUSH
5911: LD_VAR 0 1
5915: PUSH
5916: LD_INT 10
5918: DIV
5919: ARRAY
5920: PPUSH
5921: CALL 8037 0 2
5925: ST_TO_ADDR
5926: GO 6809
5928: LD_INT 17
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5984
5934: LD_INT 27
5936: DOUBLE
5937: EQUAL
5938: IFTRUE 5984
5940: LD_INT 37
5942: DOUBLE
5943: EQUAL
5944: IFTRUE 5984
5946: LD_INT 47
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5984
5952: LD_INT 57
5954: DOUBLE
5955: EQUAL
5956: IFTRUE 5984
5958: LD_INT 67
5960: DOUBLE
5961: EQUAL
5962: IFTRUE 5984
5964: LD_INT 77
5966: DOUBLE
5967: EQUAL
5968: IFTRUE 5984
5970: LD_INT 87
5972: DOUBLE
5973: EQUAL
5974: IFTRUE 5984
5976: LD_INT 97
5978: DOUBLE
5979: EQUAL
5980: IFTRUE 5984
5982: GO 6093
5984: POP
// result := Wave7 ( [ 14 , 16 , 18 , 22 , 24 , 26 , 28 , 32 , 35 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 18 , 28 , 38 , 48 , 58 , 68 , 78 , 88 , 98 :
5985: LD_ADDR_VAR 0 2
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 16
5995: PUSH
5996: LD_INT 18
5998: PUSH
5999: LD_INT 22
6001: PUSH
6002: LD_INT 24
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 28
6010: PUSH
6011: LD_INT 32
6013: PUSH
6014: LD_INT 35
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: PUSH
6028: LD_VAR 0 1
6032: PUSH
6033: LD_INT 10
6035: DIV
6036: ARRAY
6037: PPUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 3
6043: PUSH
6044: LD_INT 4
6046: PUSH
6047: LD_INT 5
6049: PUSH
6050: LD_INT 6
6052: PUSH
6053: LD_INT 7
6055: PUSH
6056: LD_INT 8
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: LD_INT 10
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: LD_VAR 0 1
6080: PUSH
6081: LD_INT 10
6083: DIV
6084: ARRAY
6085: PPUSH
6086: CALL 8457 0 2
6090: ST_TO_ADDR
6091: GO 6809
6093: LD_INT 18
6095: DOUBLE
6096: EQUAL
6097: IFTRUE 6149
6099: LD_INT 28
6101: DOUBLE
6102: EQUAL
6103: IFTRUE 6149
6105: LD_INT 38
6107: DOUBLE
6108: EQUAL
6109: IFTRUE 6149
6111: LD_INT 48
6113: DOUBLE
6114: EQUAL
6115: IFTRUE 6149
6117: LD_INT 58
6119: DOUBLE
6120: EQUAL
6121: IFTRUE 6149
6123: LD_INT 68
6125: DOUBLE
6126: EQUAL
6127: IFTRUE 6149
6129: LD_INT 78
6131: DOUBLE
6132: EQUAL
6133: IFTRUE 6149
6135: LD_INT 88
6137: DOUBLE
6138: EQUAL
6139: IFTRUE 6149
6141: LD_INT 98
6143: DOUBLE
6144: EQUAL
6145: IFTRUE 6149
6147: GO 6258
6149: POP
// result := Wave8 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 19 , 29 , 39 , 49 , 59 , 69 , 79 , 89 , 99 :
6150: LD_ADDR_VAR 0 2
6154: PUSH
6155: LD_INT 9
6157: PUSH
6158: LD_INT 12
6160: PUSH
6161: LD_INT 15
6163: PUSH
6164: LD_INT 18
6166: PUSH
6167: LD_INT 21
6169: PUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 27
6175: PUSH
6176: LD_INT 30
6178: PUSH
6179: LD_INT 33
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: LD_VAR 0 1
6197: PUSH
6198: LD_INT 10
6200: DIV
6201: ARRAY
6202: PPUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 3
6208: PUSH
6209: LD_INT 4
6211: PUSH
6212: LD_INT 5
6214: PUSH
6215: LD_INT 6
6217: PUSH
6218: LD_INT 7
6220: PUSH
6221: LD_INT 8
6223: PUSH
6224: LD_INT 9
6226: PUSH
6227: LD_INT 10
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_VAR 0 1
6245: PUSH
6246: LD_INT 10
6248: DIV
6249: ARRAY
6250: PPUSH
6251: CALL 8558 0 2
6255: ST_TO_ADDR
6256: GO 6809
6258: LD_INT 19
6260: DOUBLE
6261: EQUAL
6262: IFTRUE 6314
6264: LD_INT 29
6266: DOUBLE
6267: EQUAL
6268: IFTRUE 6314
6270: LD_INT 39
6272: DOUBLE
6273: EQUAL
6274: IFTRUE 6314
6276: LD_INT 49
6278: DOUBLE
6279: EQUAL
6280: IFTRUE 6314
6282: LD_INT 59
6284: DOUBLE
6285: EQUAL
6286: IFTRUE 6314
6288: LD_INT 69
6290: DOUBLE
6291: EQUAL
6292: IFTRUE 6314
6294: LD_INT 79
6296: DOUBLE
6297: EQUAL
6298: IFTRUE 6314
6300: LD_INT 89
6302: DOUBLE
6303: EQUAL
6304: IFTRUE 6314
6306: LD_INT 99
6308: DOUBLE
6309: EQUAL
6310: IFTRUE 6314
6312: GO 6525
6314: POP
// result := Wave8 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ^ Wave5 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 :
6315: LD_ADDR_VAR 0 2
6319: PUSH
6320: LD_INT 4
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: LD_INT 10
6328: PUSH
6329: LD_INT 13
6331: PUSH
6332: LD_INT 14
6334: PUSH
6335: LD_INT 17
6337: PUSH
6338: LD_INT 19
6340: PUSH
6341: LD_INT 21
6343: PUSH
6344: LD_INT 23
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_VAR 0 1
6362: PUSH
6363: LD_INT 10
6365: DIV
6366: ARRAY
6367: PPUSH
6368: LD_INT 2
6370: PUSH
6371: LD_INT 3
6373: PUSH
6374: LD_INT 4
6376: PUSH
6377: LD_INT 5
6379: PUSH
6380: LD_INT 6
6382: PUSH
6383: LD_INT 7
6385: PUSH
6386: LD_INT 8
6388: PUSH
6389: LD_INT 9
6391: PUSH
6392: LD_INT 10
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_VAR 0 1
6410: PUSH
6411: LD_INT 10
6413: DIV
6414: ARRAY
6415: PPUSH
6416: CALL 8558 0 2
6420: PUSH
6421: LD_INT 4
6423: PUSH
6424: LD_INT 7
6426: PUSH
6427: LD_INT 10
6429: PUSH
6430: LD_INT 13
6432: PUSH
6433: LD_INT 14
6435: PUSH
6436: LD_INT 17
6438: PUSH
6439: LD_INT 19
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_INT 25
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: PUSH
6459: LD_VAR 0 1
6463: PUSH
6464: LD_INT 10
6466: DIV
6467: ARRAY
6468: PPUSH
6469: LD_INT 2
6471: PUSH
6472: LD_INT 3
6474: PUSH
6475: LD_INT 4
6477: PUSH
6478: LD_INT 5
6480: PUSH
6481: LD_INT 6
6483: PUSH
6484: LD_INT 7
6486: PUSH
6487: LD_INT 8
6489: PUSH
6490: LD_INT 9
6492: PUSH
6493: LD_INT 10
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_VAR 0 1
6511: PUSH
6512: LD_INT 10
6514: DIV
6515: ARRAY
6516: PPUSH
6517: CALL 7617 0 2
6521: ADD
6522: ST_TO_ADDR
6523: GO 6809
6525: LD_INT 20
6527: DOUBLE
6528: EQUAL
6529: IFTRUE 6581
6531: LD_INT 30
6533: DOUBLE
6534: EQUAL
6535: IFTRUE 6581
6537: LD_INT 40
6539: DOUBLE
6540: EQUAL
6541: IFTRUE 6581
6543: LD_INT 50
6545: DOUBLE
6546: EQUAL
6547: IFTRUE 6581
6549: LD_INT 60
6551: DOUBLE
6552: EQUAL
6553: IFTRUE 6581
6555: LD_INT 70
6557: DOUBLE
6558: EQUAL
6559: IFTRUE 6581
6561: LD_INT 80
6563: DOUBLE
6564: EQUAL
6565: IFTRUE 6581
6567: LD_INT 90
6569: DOUBLE
6570: EQUAL
6571: IFTRUE 6581
6573: LD_INT 100
6575: DOUBLE
6576: EQUAL
6577: IFTRUE 6581
6579: GO 6808
6581: POP
// result := Wave7 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ^ Wave6 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ; end ;
6582: LD_ADDR_VAR 0 2
6586: PUSH
6587: LD_INT 4
6589: PUSH
6590: LD_INT 7
6592: PUSH
6593: LD_INT 10
6595: PUSH
6596: LD_INT 13
6598: PUSH
6599: LD_INT 14
6601: PUSH
6602: LD_INT 17
6604: PUSH
6605: LD_INT 19
6607: PUSH
6608: LD_INT 21
6610: PUSH
6611: LD_INT 23
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: PUSH
6625: LD_VAR 0 1
6629: PUSH
6630: LD_INT 10
6632: DIVREAL
6633: PUSH
6634: LD_INT 1
6636: MINUS
6637: ARRAY
6638: PPUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 3
6644: PUSH
6645: LD_INT 4
6647: PUSH
6648: LD_INT 5
6650: PUSH
6651: LD_INT 6
6653: PUSH
6654: LD_INT 7
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: LD_INT 9
6662: PUSH
6663: LD_INT 10
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: LD_VAR 0 1
6681: PUSH
6682: LD_INT 10
6684: DIVREAL
6685: PUSH
6686: LD_INT 1
6688: MINUS
6689: ARRAY
6690: PPUSH
6691: CALL 8457 0 2
6695: PUSH
6696: LD_INT 4
6698: PUSH
6699: LD_INT 7
6701: PUSH
6702: LD_INT 10
6704: PUSH
6705: LD_INT 13
6707: PUSH
6708: LD_INT 14
6710: PUSH
6711: LD_INT 17
6713: PUSH
6714: LD_INT 19
6716: PUSH
6717: LD_INT 22
6719: PUSH
6720: LD_INT 25
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_VAR 0 1
6738: PUSH
6739: LD_INT 10
6741: DIVREAL
6742: PUSH
6743: LD_INT 1
6745: MINUS
6746: ARRAY
6747: PPUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 3
6753: PUSH
6754: LD_INT 4
6756: PUSH
6757: LD_INT 5
6759: PUSH
6760: LD_INT 6
6762: PUSH
6763: LD_INT 7
6765: PUSH
6766: LD_INT 8
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: LD_INT 10
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_VAR 0 1
6790: PUSH
6791: LD_INT 10
6793: DIVREAL
6794: PUSH
6795: LD_INT 1
6797: MINUS
6798: ARRAY
6799: PPUSH
6800: CALL 8037 0 2
6804: ADD
6805: ST_TO_ADDR
6806: GO 6809
6808: POP
// for i in result do
6809: LD_ADDR_VAR 0 3
6813: PUSH
6814: LD_VAR 0 2
6818: PUSH
6819: FOR_IN
6820: IFFALSE 6993
// begin a := rand ( 1 , 2 ) ;
6822: LD_ADDR_VAR 0 8
6826: PUSH
6827: LD_INT 1
6829: PPUSH
6830: LD_INT 2
6832: PPUSH
6833: CALL_OW 12
6837: ST_TO_ADDR
// if a = 1 then
6838: LD_VAR 0 8
6842: PUSH
6843: LD_INT 1
6845: EQUAL
6846: IFFALSE 6862
// SetDir ( i , 3 ) else
6848: LD_VAR 0 3
6852: PPUSH
6853: LD_INT 3
6855: PPUSH
6856: CALL_OW 233
6860: GO 6874
// SetDir ( i , 5 ) ;
6862: LD_VAR 0 3
6866: PPUSH
6867: LD_INT 5
6869: PPUSH
6870: CALL_OW 233
// PlaceUnitArea ( i , area [ a ] , false ) ;
6874: LD_VAR 0 3
6878: PPUSH
6879: LD_VAR 0 7
6883: PUSH
6884: LD_VAR 0 8
6888: ARRAY
6889: PPUSH
6890: LD_INT 0
6892: PPUSH
6893: CALL_OW 49
// if GetControl ( i ) = control_manual then
6897: LD_VAR 0 3
6901: PPUSH
6902: CALL_OW 263
6906: PUSH
6907: LD_INT 1
6909: EQUAL
6910: IFFALSE 6956
// begin uc_nation := GetNation ( i ) ;
6912: LD_ADDR_OWVAR 21
6916: PUSH
6917: LD_VAR 0 3
6921: PPUSH
6922: CALL_OW 248
6926: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
6927: LD_INT 0
6929: PPUSH
6930: LD_INT 3
6932: PPUSH
6933: LD_VAR 0 5
6937: PPUSH
6938: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
6942: CALL_OW 44
6946: PPUSH
6947: LD_VAR 0 3
6951: PPUSH
6952: CALL_OW 52
// end ; l := l + 1 ;
6956: LD_ADDR_VAR 0 9
6960: PUSH
6961: LD_VAR 0 9
6965: PUSH
6966: LD_INT 1
6968: PLUS
6969: ST_TO_ADDR
// if l mod 10 = 0 then
6970: LD_VAR 0 9
6974: PUSH
6975: LD_INT 10
6977: MOD
6978: PUSH
6979: LD_INT 0
6981: EQUAL
6982: IFFALSE 6991
// Wait ( 0 0$02 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6819
6993: POP
6994: POP
// end ;
6995: LD_VAR 0 2
6999: RET
// export function Wave1 ( n , skill ) ; var i , un ; begin
7000: LD_INT 0
7002: PPUSH
7003: PPUSH
7004: PPUSH
// uc_nation := nation_nature ;
7005: LD_ADDR_OWVAR 21
7009: PUSH
7010: LD_INT 0
7012: ST_TO_ADDR
// for i = 1 to n do
7013: LD_ADDR_VAR 0 4
7017: PUSH
7018: DOUBLE
7019: LD_INT 1
7021: DEC
7022: ST_TO_ADDR
7023: LD_VAR 0 1
7027: PUSH
7028: FOR_TO
7029: IFFALSE 7064
// begin PrepareHuman ( false , class_apeman , skill ) ;
7031: LD_INT 0
7033: PPUSH
7034: LD_INT 12
7036: PPUSH
7037: LD_VAR 0 2
7041: PPUSH
7042: CALL_OW 380
// result := result ^ CreateHuman ;
7046: LD_ADDR_VAR 0 3
7050: PUSH
7051: LD_VAR 0 3
7055: PUSH
7056: CALL_OW 44
7060: ADD
7061: ST_TO_ADDR
// end ;
7062: GO 7028
7064: POP
7065: POP
// end ;
7066: LD_VAR 0 3
7070: RET
// export function Wave2 ( n , skill ) ; var i , un ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
// uc_nation := nation_nature ;
7076: LD_ADDR_OWVAR 21
7080: PUSH
7081: LD_INT 0
7083: ST_TO_ADDR
// for i = 1 to n do
7084: LD_ADDR_VAR 0 4
7088: PUSH
7089: DOUBLE
7090: LD_INT 1
7092: DEC
7093: ST_TO_ADDR
7094: LD_VAR 0 1
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7135
// begin PrepareHuman ( false , class_apeman_soldier , skill ) ;
7102: LD_INT 0
7104: PPUSH
7105: LD_INT 15
7107: PPUSH
7108: LD_VAR 0 2
7112: PPUSH
7113: CALL_OW 380
// result := result ^ CreateHuman ;
7117: LD_ADDR_VAR 0 3
7121: PUSH
7122: LD_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ADD
7132: ST_TO_ADDR
// end ;
7133: GO 7099
7135: POP
7136: POP
// end ;
7137: LD_VAR 0 3
7141: RET
// export function Wave3 ( n , skill ) ; var i , un ; begin
7142: LD_INT 0
7144: PPUSH
7145: PPUSH
7146: PPUSH
// for i = 1 to n do
7147: LD_ADDR_VAR 0 4
7151: PUSH
7152: DOUBLE
7153: LD_INT 1
7155: DEC
7156: ST_TO_ADDR
7157: LD_VAR 0 1
7161: PUSH
7162: FOR_TO
7163: IFFALSE 7214
// begin uc_nation := rand ( 1 , 3 ) ;
7165: LD_ADDR_OWVAR 21
7169: PUSH
7170: LD_INT 1
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: CALL_OW 12
7180: ST_TO_ADDR
// PrepareHuman ( false , class_soldier , skill ) ;
7181: LD_INT 0
7183: PPUSH
7184: LD_INT 1
7186: PPUSH
7187: LD_VAR 0 2
7191: PPUSH
7192: CALL_OW 380
// result := result ^ CreateHuman ;
7196: LD_ADDR_VAR 0 3
7200: PUSH
7201: LD_VAR 0 3
7205: PUSH
7206: CALL_OW 44
7210: ADD
7211: ST_TO_ADDR
// end ;
7212: GO 7162
7214: POP
7215: POP
// end ;
7216: LD_VAR 0 3
7220: RET
// export function Wave4 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7221: LD_INT 0
7223: PPUSH
7224: PPUSH
7225: PPUSH
7226: PPUSH
7227: PPUSH
7228: PPUSH
7229: PPUSH
// for i = 1 to n do
7230: LD_ADDR_VAR 0 4
7234: PUSH
7235: DOUBLE
7236: LD_INT 1
7238: DEC
7239: ST_TO_ADDR
7240: LD_VAR 0 1
7244: PUSH
7245: FOR_TO
7246: IFFALSE 7610
// begin uc_nation := rand ( 1 , 3 ) ;
7248: LD_ADDR_OWVAR 21
7252: PUSH
7253: LD_INT 1
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 12
7263: ST_TO_ADDR
// case uc_nation of 1 :
7264: LD_OWVAR 21
7268: PUSH
7269: LD_INT 1
7271: DOUBLE
7272: EQUAL
7273: IFTRUE 7277
7275: GO 7340
7277: POP
// begin chassis := [ us_light_wheeled , us_medium_wheeled ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: LD_INT 2
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: ST_TO_ADDR
// weapons := [ us_machine_gun , us_light_gun ] ;
7293: LD_ADDR_VAR 0 7
7297: PUSH
7298: LD_INT 2
7300: PUSH
7301: LD_INT 3
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7308: LD_ADDR_VAR 0 8
7312: PUSH
7313: LD_INT 1
7315: PUSH
7316: LD_INT 3
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7323: LD_ADDR_VAR 0 9
7327: PUSH
7328: LD_INT 1
7330: PUSH
7331: LD_INT 2
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: ST_TO_ADDR
// end ; 2 :
7338: GO 7475
7340: LD_INT 2
7342: DOUBLE
7343: EQUAL
7344: IFTRUE 7348
7346: GO 7411
7348: POP
// begin chassis := [ ar_light_trike , ar_hovercraft ] ;
7349: LD_ADDR_VAR 0 6
7353: PUSH
7354: LD_INT 12
7356: PUSH
7357: LD_INT 11
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: ST_TO_ADDR
// weapons := [ ar_light_gun , ar_double_machine_gun ] ;
7364: LD_ADDR_VAR 0 7
7368: PUSH
7369: LD_INT 23
7371: PUSH
7372: LD_INT 24
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7379: LD_ADDR_VAR 0 8
7383: PUSH
7384: LD_INT 1
7386: PUSH
7387: LD_INT 5
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7394: LD_ADDR_VAR 0 9
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: ST_TO_ADDR
// end ; 3 :
7409: GO 7475
7411: LD_INT 3
7413: DOUBLE
7414: EQUAL
7415: IFTRUE 7419
7417: GO 7474
7419: POP
// begin chassis := [ ru_medium_wheeled ] ;
7420: LD_ADDR_VAR 0 6
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: EMPTY
7429: LIST
7430: ST_TO_ADDR
// weapons := [ ru_heavy_machine_gun , ru_gun ] ;
7431: LD_ADDR_VAR 0 7
7435: PUSH
7436: LD_INT 42
7438: PUSH
7439: LD_INT 44
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7446: LD_ADDR_VAR 0 8
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 3
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: ST_TO_ADDR
// engine := [ engine_combustion ] ;
7461: LD_ADDR_VAR 0 9
7465: PUSH
7466: LD_INT 1
7468: PUSH
7469: EMPTY
7470: LIST
7471: ST_TO_ADDR
// end ; end ;
7472: GO 7475
7474: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7475: LD_ADDR_OWVAR 37
7479: PUSH
7480: LD_VAR 0 6
7484: PUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_VAR 0 6
7492: PPUSH
7493: CALL_OW 12
7497: ARRAY
7498: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7499: LD_ADDR_OWVAR 39
7503: PUSH
7504: LD_VAR 0 9
7508: PUSH
7509: LD_INT 1
7511: PPUSH
7512: LD_VAR 0 9
7516: PPUSH
7517: CALL_OW 12
7521: ARRAY
7522: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7523: LD_ADDR_OWVAR 38
7527: PUSH
7528: LD_VAR 0 8
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 12
7545: ARRAY
7546: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7547: LD_ADDR_OWVAR 40
7551: PUSH
7552: LD_VAR 0 7
7556: PUSH
7557: LD_INT 1
7559: PPUSH
7560: LD_VAR 0 7
7564: PPUSH
7565: CALL_OW 12
7569: ARRAY
7570: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7571: LD_ADDR_OWVAR 41
7575: PUSH
7576: LD_INT 100
7578: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7579: LD_ADDR_VAR 0 3
7583: PUSH
7584: LD_VAR 0 3
7588: PPUSH
7589: LD_VAR 0 3
7593: PUSH
7594: LD_INT 1
7596: PLUS
7597: PPUSH
7598: CALL_OW 45
7602: PPUSH
7603: CALL_OW 2
7607: ST_TO_ADDR
// end ;
7608: GO 7245
7610: POP
7611: POP
// end ;
7612: LD_VAR 0 3
7616: RET
// export function Wave5 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
// for i = 1 to n do
7626: LD_ADDR_VAR 0 4
7630: PUSH
7631: DOUBLE
7632: LD_INT 1
7634: DEC
7635: ST_TO_ADDR
7636: LD_VAR 0 1
7640: PUSH
7641: FOR_TO
7642: IFFALSE 8030
// begin uc_nation := rand ( 1 , 3 ) ;
7644: LD_ADDR_OWVAR 21
7648: PUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 3
7654: PPUSH
7655: CALL_OW 12
7659: ST_TO_ADDR
// case uc_nation of 1 :
7660: LD_OWVAR 21
7664: PUSH
7665: LD_INT 1
7667: DOUBLE
7668: EQUAL
7669: IFTRUE 7673
7671: GO 7744
7673: POP
// begin chassis := [ us_medium_wheeled , us_medium_tracked ] ;
7674: LD_ADDR_VAR 0 6
7678: PUSH
7679: LD_INT 2
7681: PUSH
7682: LD_INT 3
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_double_gun , us_laser ] ;
7689: LD_ADDR_VAR 0 7
7693: PUSH
7694: LD_INT 4
7696: PUSH
7697: LD_INT 5
7699: PUSH
7700: LD_INT 9
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7708: LD_ADDR_VAR 0 8
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7723: LD_ADDR_VAR 0 9
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 3
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: ST_TO_ADDR
// end ; 2 :
7742: GO 7895
7744: LD_INT 2
7746: DOUBLE
7747: EQUAL
7748: IFTRUE 7752
7750: GO 7823
7752: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
7753: LD_ADDR_VAR 0 6
7757: PUSH
7758: LD_INT 13
7760: PUSH
7761: LD_INT 14
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_gatling_gun ] ;
7768: LD_ADDR_VAR 0 7
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 26
7778: PUSH
7779: LD_INT 25
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7787: LD_ADDR_VAR 0 8
7791: PUSH
7792: LD_INT 1
7794: PUSH
7795: LD_INT 5
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7802: LD_ADDR_VAR 0 9
7806: PUSH
7807: LD_INT 1
7809: PUSH
7810: LD_INT 2
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: ST_TO_ADDR
// end ; 3 :
7821: GO 7895
7823: LD_INT 3
7825: DOUBLE
7826: EQUAL
7827: IFTRUE 7831
7829: GO 7894
7831: POP
// begin chassis := [ ru_medium_tracked , ru_medium_wheeled ] ;
7832: LD_ADDR_VAR 0 6
7836: PUSH
7837: LD_INT 22
7839: PUSH
7840: LD_INT 21
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: ST_TO_ADDR
// weapons := [ ru_gun , ru_gatling_gun ] ;
7847: LD_ADDR_VAR 0 7
7851: PUSH
7852: LD_INT 44
7854: PUSH
7855: LD_INT 43
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7862: LD_ADDR_VAR 0 8
7866: PUSH
7867: LD_INT 1
7869: PUSH
7870: LD_INT 3
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
7877: LD_ADDR_VAR 0 9
7881: PUSH
7882: LD_INT 1
7884: PUSH
7885: LD_INT 3
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: ST_TO_ADDR
// end ; end ;
7892: GO 7895
7894: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7895: LD_ADDR_OWVAR 37
7899: PUSH
7900: LD_VAR 0 6
7904: PUSH
7905: LD_INT 1
7907: PPUSH
7908: LD_VAR 0 6
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7919: LD_ADDR_OWVAR 39
7923: PUSH
7924: LD_VAR 0 9
7928: PUSH
7929: LD_INT 1
7931: PPUSH
7932: LD_VAR 0 9
7936: PPUSH
7937: CALL_OW 12
7941: ARRAY
7942: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7943: LD_ADDR_OWVAR 38
7947: PUSH
7948: LD_VAR 0 8
7952: PUSH
7953: LD_INT 1
7955: PPUSH
7956: LD_VAR 0 8
7960: PPUSH
7961: CALL_OW 12
7965: ARRAY
7966: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7967: LD_ADDR_OWVAR 40
7971: PUSH
7972: LD_VAR 0 7
7976: PUSH
7977: LD_INT 1
7979: PPUSH
7980: LD_VAR 0 7
7984: PPUSH
7985: CALL_OW 12
7989: ARRAY
7990: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7991: LD_ADDR_OWVAR 41
7995: PUSH
7996: LD_INT 100
7998: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7999: LD_ADDR_VAR 0 3
8003: PUSH
8004: LD_VAR 0 3
8008: PPUSH
8009: LD_VAR 0 3
8013: PUSH
8014: LD_INT 1
8016: PLUS
8017: PPUSH
8018: CALL_OW 45
8022: PPUSH
8023: CALL_OW 2
8027: ST_TO_ADDR
// end ;
8028: GO 7641
8030: POP
8031: POP
// end ;
8032: LD_VAR 0 3
8036: RET
// export function Wave6 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8037: LD_INT 0
8039: PPUSH
8040: PPUSH
8041: PPUSH
8042: PPUSH
8043: PPUSH
8044: PPUSH
8045: PPUSH
// for i = 1 to n do
8046: LD_ADDR_VAR 0 4
8050: PUSH
8051: DOUBLE
8052: LD_INT 1
8054: DEC
8055: ST_TO_ADDR
8056: LD_VAR 0 1
8060: PUSH
8061: FOR_TO
8062: IFFALSE 8450
// begin uc_nation := rand ( 1 , 3 ) ;
8064: LD_ADDR_OWVAR 21
8068: PUSH
8069: LD_INT 1
8071: PPUSH
8072: LD_INT 3
8074: PPUSH
8075: CALL_OW 12
8079: ST_TO_ADDR
// case uc_nation of 1 :
8080: LD_OWVAR 21
8084: PUSH
8085: LD_INT 1
8087: DOUBLE
8088: EQUAL
8089: IFTRUE 8093
8091: GO 8160
8093: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8094: LD_ADDR_VAR 0 6
8098: PUSH
8099: LD_INT 4
8101: PUSH
8102: LD_INT 5
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_laser ] ;
8109: LD_ADDR_VAR 0 7
8113: PUSH
8114: LD_INT 6
8116: PUSH
8117: LD_INT 7
8119: PUSH
8120: LD_INT 9
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8128: LD_ADDR_VAR 0 8
8132: PUSH
8133: LD_INT 1
8135: PUSH
8136: LD_INT 3
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8143: LD_ADDR_VAR 0 9
8147: PUSH
8148: LD_INT 1
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: ST_TO_ADDR
// end ; 2 :
8158: GO 8315
8160: LD_INT 2
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8243
8168: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: LD_INT 13
8176: PUSH
8177: LD_INT 14
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8184: LD_ADDR_VAR 0 7
8188: PUSH
8189: LD_INT 27
8191: PUSH
8192: LD_INT 26
8194: PUSH
8195: LD_INT 28
8197: PUSH
8198: LD_INT 29
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8207: LD_ADDR_VAR 0 8
8211: PUSH
8212: LD_INT 1
8214: PUSH
8215: LD_INT 5
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8222: LD_ADDR_VAR 0 9
8226: PUSH
8227: LD_INT 1
8229: PUSH
8230: LD_INT 2
8232: PUSH
8233: LD_INT 3
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: LIST
8240: ST_TO_ADDR
// end ; 3 :
8241: GO 8315
8243: LD_INT 3
8245: DOUBLE
8246: EQUAL
8247: IFTRUE 8251
8249: GO 8314
8251: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8252: LD_ADDR_VAR 0 6
8256: PUSH
8257: LD_INT 23
8259: PUSH
8260: LD_INT 24
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher ] ;
8267: LD_ADDR_VAR 0 7
8271: PUSH
8272: LD_INT 46
8274: PUSH
8275: LD_INT 45
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8282: LD_ADDR_VAR 0 8
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: LD_INT 3
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8297: LD_ADDR_VAR 0 9
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 3
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: ST_TO_ADDR
// end ; end ;
8312: GO 8315
8314: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8315: LD_ADDR_OWVAR 37
8319: PUSH
8320: LD_VAR 0 6
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_VAR 0 6
8332: PPUSH
8333: CALL_OW 12
8337: ARRAY
8338: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8339: LD_ADDR_OWVAR 39
8343: PUSH
8344: LD_VAR 0 9
8348: PUSH
8349: LD_INT 1
8351: PPUSH
8352: LD_VAR 0 9
8356: PPUSH
8357: CALL_OW 12
8361: ARRAY
8362: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8363: LD_ADDR_OWVAR 38
8367: PUSH
8368: LD_VAR 0 8
8372: PUSH
8373: LD_INT 1
8375: PPUSH
8376: LD_VAR 0 8
8380: PPUSH
8381: CALL_OW 12
8385: ARRAY
8386: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8387: LD_ADDR_OWVAR 40
8391: PUSH
8392: LD_VAR 0 7
8396: PUSH
8397: LD_INT 1
8399: PPUSH
8400: LD_VAR 0 7
8404: PPUSH
8405: CALL_OW 12
8409: ARRAY
8410: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8411: LD_ADDR_OWVAR 41
8415: PUSH
8416: LD_INT 100
8418: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8419: LD_ADDR_VAR 0 3
8423: PUSH
8424: LD_VAR 0 3
8428: PPUSH
8429: LD_VAR 0 3
8433: PUSH
8434: LD_INT 1
8436: PLUS
8437: PPUSH
8438: CALL_OW 45
8442: PPUSH
8443: CALL_OW 2
8447: ST_TO_ADDR
// end ;
8448: GO 8061
8450: POP
8451: POP
// end ;
8452: LD_VAR 0 3
8456: RET
// export function Wave7 ( n , skill ) ; var i ; begin
8457: LD_INT 0
8459: PPUSH
8460: PPUSH
// for i = 1 to n do
8461: LD_ADDR_VAR 0 4
8465: PUSH
8466: DOUBLE
8467: LD_INT 1
8469: DEC
8470: ST_TO_ADDR
8471: LD_VAR 0 1
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8551
// begin uc_nation := rand ( 1 , 3 ) ;
8479: LD_ADDR_OWVAR 21
8483: PUSH
8484: LD_INT 1
8486: PPUSH
8487: LD_INT 3
8489: PPUSH
8490: CALL_OW 12
8494: ST_TO_ADDR
// PrepareHuman ( false , [ class_mortar , class_bazooker , class_soldier ] [ rand ( 1 , 3 ) ] , skill ) ;
8495: LD_INT 0
8497: PPUSH
8498: LD_INT 8
8500: PUSH
8501: LD_INT 9
8503: PUSH
8504: LD_INT 1
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 1
8514: PPUSH
8515: LD_INT 3
8517: PPUSH
8518: CALL_OW 12
8522: ARRAY
8523: PPUSH
8524: LD_VAR 0 2
8528: PPUSH
8529: CALL_OW 380
// result := result ^ CreateHuman ;
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_VAR 0 3
8542: PUSH
8543: CALL_OW 44
8547: ADD
8548: ST_TO_ADDR
// end ;
8549: GO 8476
8551: POP
8552: POP
// end ;
8553: LD_VAR 0 3
8557: RET
// export function Wave8 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8558: LD_INT 0
8560: PPUSH
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// for i = 1 to n do
8567: LD_ADDR_VAR 0 4
8571: PUSH
8572: DOUBLE
8573: LD_INT 1
8575: DEC
8576: ST_TO_ADDR
8577: LD_VAR 0 1
8581: PUSH
8582: FOR_TO
8583: IFFALSE 8979
// begin uc_nation := rand ( 1 , 3 ) ;
8585: LD_ADDR_OWVAR 21
8589: PUSH
8590: LD_INT 1
8592: PPUSH
8593: LD_INT 3
8595: PPUSH
8596: CALL_OW 12
8600: ST_TO_ADDR
// case uc_nation of 1 :
8601: LD_OWVAR 21
8605: PUSH
8606: LD_INT 1
8608: DOUBLE
8609: EQUAL
8610: IFTRUE 8614
8612: GO 8687
8614: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8615: LD_ADDR_VAR 0 6
8619: PUSH
8620: LD_INT 4
8622: PUSH
8623: LD_INT 5
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_double_laser , us_artillery ] ;
8630: LD_ADDR_VAR 0 7
8634: PUSH
8635: LD_INT 6
8637: PUSH
8638: LD_INT 7
8640: PUSH
8641: LD_INT 10
8643: PUSH
8644: LD_EXP 17
8648: PUSH
8649: EMPTY
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8655: LD_ADDR_VAR 0 8
8659: PUSH
8660: LD_INT 1
8662: PUSH
8663: LD_INT 3
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8670: LD_ADDR_VAR 0 9
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: ST_TO_ADDR
// end ; 2 :
8685: GO 8844
8687: LD_INT 2
8689: DOUBLE
8690: EQUAL
8691: IFTRUE 8695
8693: GO 8768
8695: POP
// begin chassis := [ ar_half_tracked ] ;
8696: LD_ADDR_VAR 0 6
8700: PUSH
8701: LD_INT 14
8703: PUSH
8704: EMPTY
8705: LIST
8706: ST_TO_ADDR
// weapons := [ ar_bio_bomb , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8707: LD_ADDR_VAR 0 7
8711: PUSH
8712: LD_EXP 18
8716: PUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 28
8722: PUSH
8723: LD_INT 29
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: LIST
8730: LIST
8731: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8732: LD_ADDR_VAR 0 8
8736: PUSH
8737: LD_INT 1
8739: PUSH
8740: LD_INT 5
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8747: LD_ADDR_VAR 0 9
8751: PUSH
8752: LD_INT 1
8754: PUSH
8755: LD_INT 2
8757: PUSH
8758: LD_INT 3
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: ST_TO_ADDR
// end ; 3 :
8766: GO 8844
8768: LD_INT 3
8770: DOUBLE
8771: EQUAL
8772: IFTRUE 8776
8774: GO 8843
8776: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8777: LD_ADDR_VAR 0 6
8781: PUSH
8782: LD_INT 23
8784: PUSH
8785: LD_INT 24
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher , ru_time_lapser ] ;
8792: LD_ADDR_VAR 0 7
8796: PUSH
8797: LD_INT 46
8799: PUSH
8800: LD_INT 45
8802: PUSH
8803: LD_INT 49
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8811: LD_ADDR_VAR 0 8
8815: PUSH
8816: LD_INT 1
8818: PUSH
8819: LD_INT 3
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8826: LD_ADDR_VAR 0 9
8830: PUSH
8831: LD_INT 1
8833: PUSH
8834: LD_INT 3
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: ST_TO_ADDR
// end ; end ;
8841: GO 8844
8843: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8844: LD_ADDR_OWVAR 37
8848: PUSH
8849: LD_VAR 0 6
8853: PUSH
8854: LD_INT 1
8856: PPUSH
8857: LD_VAR 0 6
8861: PPUSH
8862: CALL_OW 12
8866: ARRAY
8867: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8868: LD_ADDR_OWVAR 39
8872: PUSH
8873: LD_VAR 0 9
8877: PUSH
8878: LD_INT 1
8880: PPUSH
8881: LD_VAR 0 9
8885: PPUSH
8886: CALL_OW 12
8890: ARRAY
8891: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8892: LD_ADDR_OWVAR 38
8896: PUSH
8897: LD_VAR 0 8
8901: PUSH
8902: LD_INT 1
8904: PPUSH
8905: LD_VAR 0 8
8909: PPUSH
8910: CALL_OW 12
8914: ARRAY
8915: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8916: LD_ADDR_OWVAR 40
8920: PUSH
8921: LD_VAR 0 7
8925: PUSH
8926: LD_INT 1
8928: PPUSH
8929: LD_VAR 0 7
8933: PPUSH
8934: CALL_OW 12
8938: ARRAY
8939: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8940: LD_ADDR_OWVAR 41
8944: PUSH
8945: LD_INT 100
8947: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8948: LD_ADDR_VAR 0 3
8952: PUSH
8953: LD_VAR 0 3
8957: PPUSH
8958: LD_VAR 0 3
8962: PUSH
8963: LD_INT 1
8965: PLUS
8966: PPUSH
8967: CALL_OW 45
8971: PPUSH
8972: CALL_OW 2
8976: ST_TO_ADDR
// end ;
8977: GO 8582
8979: POP
8980: POP
// end ; end_of_file
8981: LD_VAR 0 3
8985: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 7 ] ) do var i , un , tmp ;
8986: LD_INT 22
8988: PUSH
8989: LD_INT 7
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PPUSH
8996: CALL_OW 69
9000: IFFALSE 9506
9002: GO 9004
9004: DISABLE
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
// begin enable ;
9010: ENABLE
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9011: LD_ADDR_VAR 0 3
9015: PUSH
9016: LD_INT 22
9018: PUSH
9019: LD_INT 7
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: ST_TO_ADDR
// for i in tmp do
9031: LD_ADDR_VAR 0 1
9035: PUSH
9036: LD_VAR 0 3
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9504
// begin case GetType ( i ) of unit_human :
9044: LD_VAR 0 1
9048: PPUSH
9049: CALL_OW 247
9053: PUSH
9054: LD_INT 1
9056: DOUBLE
9057: EQUAL
9058: IFTRUE 9062
9060: GO 9261
9062: POP
// begin if GetLives ( i ) < 250 and GetTech ( 5 , 7 ) <> state_researched then
9063: LD_VAR 0 1
9067: PPUSH
9068: CALL_OW 256
9072: PUSH
9073: LD_INT 250
9075: LESS
9076: PUSH
9077: LD_INT 5
9079: PPUSH
9080: LD_INT 7
9082: PPUSH
9083: CALL_OW 321
9087: PUSH
9088: LD_INT 2
9090: NONEQUAL
9091: AND
9092: IFFALSE 9096
// continue ;
9094: GO 9041
// if GetClass ( i ) in [ 12 , 15 , 16 , 17 , 1 , 5 , 6 , 7 , 8 , 9 ] then
9096: LD_VAR 0 1
9100: PPUSH
9101: CALL_OW 257
9105: PUSH
9106: LD_INT 12
9108: PUSH
9109: LD_INT 15
9111: PUSH
9112: LD_INT 16
9114: PUSH
9115: LD_INT 17
9117: PUSH
9118: LD_INT 1
9120: PUSH
9121: LD_INT 5
9123: PUSH
9124: LD_INT 6
9126: PUSH
9127: LD_INT 7
9129: PUSH
9130: LD_INT 8
9132: PUSH
9133: LD_INT 9
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: IN
9148: IFFALSE 9186
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9150: LD_VAR 0 1
9154: PPUSH
9155: LD_INT 22
9157: PUSH
9158: LD_OWVAR 2
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 69
9171: PPUSH
9172: LD_VAR 0 1
9176: PPUSH
9177: CALL_OW 74
9181: PPUSH
9182: CALL_OW 115
// if GetClass ( i ) = 3 then
9186: LD_VAR 0 1
9190: PPUSH
9191: CALL_OW 257
9195: PUSH
9196: LD_INT 3
9198: EQUAL
9199: IFFALSE 9259
// if IsInUnit ( i ) then
9201: LD_VAR 0 1
9205: PPUSH
9206: CALL_OW 310
9210: IFFALSE 9250
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) else
9212: LD_VAR 0 1
9216: PPUSH
9217: LD_INT 22
9219: PUSH
9220: LD_OWVAR 2
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: PPUSH
9229: CALL_OW 69
9233: PPUSH
9234: LD_VAR 0 1
9238: PPUSH
9239: CALL_OW 74
9243: PPUSH
9244: CALL_OW 115
9248: GO 9259
// ComEspace ( i ) ;
9250: LD_VAR 0 1
9254: PPUSH
9255: CALL 2259 0 1
// end ; unit_vehicle :
9259: GO 9502
9261: LD_INT 2
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9501
9269: POP
// begin if GetLives ( i ) > 250 then
9270: LD_VAR 0 1
9274: PPUSH
9275: CALL_OW 256
9279: PUSH
9280: LD_INT 250
9282: GREATER
9283: IFFALSE 9499
// begin if GetWeapon ( i ) = us_artillery then
9285: LD_VAR 0 1
9289: PPUSH
9290: CALL_OW 264
9294: PUSH
9295: LD_EXP 17
9299: EQUAL
9300: IFFALSE 9368
// begin if IsInArea ( i , zoneOut ) then
9302: LD_VAR 0 1
9306: PPUSH
9307: LD_INT 4
9309: PPUSH
9310: CALL_OW 308
9314: IFFALSE 9330
// ComMoveToArea ( i , zoneBorder ) else
9316: LD_VAR 0 1
9320: PPUSH
9321: LD_INT 9
9323: PPUSH
9324: CALL_OW 113
9328: GO 9366
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 22
9337: PUSH
9338: LD_OWVAR 2
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: PPUSH
9347: CALL_OW 69
9351: PPUSH
9352: LD_VAR 0 1
9356: PPUSH
9357: CALL_OW 74
9361: PPUSH
9362: CALL_OW 115
// end else
9366: GO 9499
// if GetWeapon ( i ) in [ us_radar , ar_radar , ru_radar , ru_time_lapser ] then
9368: LD_VAR 0 1
9372: PPUSH
9373: CALL_OW 264
9377: PUSH
9378: LD_INT 11
9380: PUSH
9381: LD_INT 30
9383: PUSH
9384: LD_EXP 14
9388: PUSH
9389: LD_INT 49
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: IN
9398: IFFALSE 9428
// begin if IsInArea ( i , zoneOut ) then
9400: LD_VAR 0 1
9404: PPUSH
9405: LD_INT 4
9407: PPUSH
9408: CALL_OW 308
9412: IFFALSE 9426
// ComSpecMove ( i , specPos ) ;
9414: LD_VAR 0 1
9418: PPUSH
9419: LD_INT 8
9421: PPUSH
9422: CALL 2305 0 2
// end else
9426: GO 9499
// if GetWeapon ( i ) in [ ar_bio_bomb , ar_selfpropelled_bomb ] then
9428: LD_VAR 0 1
9432: PPUSH
9433: CALL_OW 264
9437: PUSH
9438: LD_EXP 18
9442: PUSH
9443: LD_INT 29
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: IN
9450: IFFALSE 9463
// ComSpecAttack ( i ) else
9452: LD_VAR 0 1
9456: PPUSH
9457: CALL 2733 0 1
9461: GO 9499
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9463: LD_VAR 0 1
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_OWVAR 2
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PPUSH
9480: CALL_OW 69
9484: PPUSH
9485: LD_VAR 0 1
9489: PPUSH
9490: CALL_OW 74
9494: PPUSH
9495: CALL_OW 115
// end ; end ; end ;
9499: GO 9502
9501: POP
// end ;
9502: GO 9041
9504: POP
9505: POP
// end ; end_of_file
9506: PPOPN 3
9508: END
// export function InitDisplay ; begin
9509: LD_INT 0
9511: PPUSH
// while true do
9512: LD_INT 1
9514: IFFALSE 9601
// begin if waveNumber < 100 then
9516: LD_EXP 5
9520: PUSH
9521: LD_INT 100
9523: LESS
9524: IFFALSE 9575
// Display_Strings := [ #Tick , tick , #Points , points , #Attack , timeToNextAttack , #Wave , waveNumber ] else
9526: LD_ADDR_OWVAR 47
9530: PUSH
9531: LD_STRING #Tick
9533: PUSH
9534: LD_OWVAR 1
9538: PUSH
9539: LD_STRING #Points
9541: PUSH
9542: LD_EXP 2
9546: PUSH
9547: LD_STRING #Attack
9549: PUSH
9550: LD_EXP 4
9554: PUSH
9555: LD_STRING #Wave
9557: PUSH
9558: LD_EXP 5
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: ST_TO_ADDR
9573: GO 9592
// Display_Strings := [ #Win , points ] ;
9575: LD_ADDR_OWVAR 47
9579: PUSH
9580: LD_STRING #Win
9582: PUSH
9583: LD_EXP 2
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
9592: LD_INT 35
9594: PPUSH
9595: CALL_OW 67
// end ;
9599: GO 9512
// end ; end_of_file
9601: LD_VAR 0 1
9605: RET
// export function InitBonus ; var i , chance ; begin
9606: LD_INT 0
9608: PPUSH
9609: PPUSH
9610: PPUSH
// chance := rand ( 1 , 99 ) ;
9611: LD_ADDR_VAR 0 3
9615: PUSH
9616: LD_INT 1
9618: PPUSH
9619: LD_INT 99
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// case chance of 1 .. 10 :
9627: LD_VAR 0 3
9631: PUSH
9632: LD_INT 1
9634: DOUBLE
9635: GREATEREQUAL
9636: IFFALSE 9644
9638: LD_INT 10
9640: DOUBLE
9641: LESSEQUAL
9642: IFTRUE 9646
9644: GO 9657
9646: POP
// i := 5 ; 11 .. 25 :
9647: LD_ADDR_VAR 0 2
9651: PUSH
9652: LD_INT 5
9654: ST_TO_ADDR
9655: GO 9758
9657: LD_INT 11
9659: DOUBLE
9660: GREATEREQUAL
9661: IFFALSE 9669
9663: LD_INT 25
9665: DOUBLE
9666: LESSEQUAL
9667: IFTRUE 9671
9669: GO 9682
9671: POP
// i := 3 ; 26 .. 40 :
9672: LD_ADDR_VAR 0 2
9676: PUSH
9677: LD_INT 3
9679: ST_TO_ADDR
9680: GO 9758
9682: LD_INT 26
9684: DOUBLE
9685: GREATEREQUAL
9686: IFFALSE 9694
9688: LD_INT 40
9690: DOUBLE
9691: LESSEQUAL
9692: IFTRUE 9696
9694: GO 9707
9696: POP
// i := 2 ; 41 .. 60 :
9697: LD_ADDR_VAR 0 2
9701: PUSH
9702: LD_INT 2
9704: ST_TO_ADDR
9705: GO 9758
9707: LD_INT 41
9709: DOUBLE
9710: GREATEREQUAL
9711: IFFALSE 9719
9713: LD_INT 60
9715: DOUBLE
9716: LESSEQUAL
9717: IFTRUE 9721
9719: GO 9732
9721: POP
// i := 4 ; 61 .. 99 :
9722: LD_ADDR_VAR 0 2
9726: PUSH
9727: LD_INT 4
9729: ST_TO_ADDR
9730: GO 9758
9732: LD_INT 61
9734: DOUBLE
9735: GREATEREQUAL
9736: IFFALSE 9744
9738: LD_INT 99
9740: DOUBLE
9741: LESSEQUAL
9742: IFTRUE 9746
9744: GO 9757
9746: POP
// i := 1 ; end ;
9747: LD_ADDR_VAR 0 2
9751: PUSH
9752: LD_INT 1
9754: ST_TO_ADDR
9755: GO 9758
9757: POP
// case i of 1 :
9758: LD_VAR 0 2
9762: PUSH
9763: LD_INT 1
9765: DOUBLE
9766: EQUAL
9767: IFTRUE 9771
9769: GO 9860
9771: POP
// begin if FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) >= 10 then
9772: LD_INT 22
9774: PUSH
9775: LD_OWVAR 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: LD_INT 25
9789: PUSH
9790: LD_INT 12
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 25
9799: PUSH
9800: LD_INT 16
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PUSH
9807: LD_INT 25
9809: PUSH
9810: LD_INT 15
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PUSH
9817: LD_INT 25
9819: PUSH
9820: LD_INT 17
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 69
9842: PUSH
9843: LD_INT 10
9845: GREATEREQUAL
9846: IFFALSE 9854
// BonusIV else
9848: CALL 10433 0 0
9852: GO 9858
// BonusI ;
9854: CALL 9938 0 0
// end ; 2 :
9858: GO 9933
9860: LD_INT 2
9862: DOUBLE
9863: EQUAL
9864: IFTRUE 9868
9866: GO 9875
9868: POP
// begin BonusII ;
9869: CALL 10111 0 0
// end ; 3 :
9873: GO 9933
9875: LD_INT 3
9877: DOUBLE
9878: EQUAL
9879: IFTRUE 9883
9881: GO 9890
9883: POP
// begin BonusIII ;
9884: CALL 10259 0 0
// end ; 4 :
9888: GO 9933
9890: LD_INT 4
9892: DOUBLE
9893: EQUAL
9894: IFTRUE 9898
9896: GO 9905
9898: POP
// begin BonusIV ;
9899: CALL 10433 0 0
// end ; 5 :
9903: GO 9933
9905: LD_INT 5
9907: DOUBLE
9908: EQUAL
9909: IFTRUE 9913
9911: GO 9932
9913: POP
// begin if graveyard then
9914: LD_EXP 8
9918: IFFALSE 9926
// BonusV else
9920: CALL 10851 0 0
9924: GO 9930
// BonusIII ;
9926: CALL 10259 0 0
// end ; end ;
9930: GO 9933
9932: POP
// end ;
9933: LD_VAR 0 1
9937: RET
// export function BonusI ; var i ; begin
9938: LD_INT 0
9940: PPUSH
9941: PPUSH
// case Query ( AddGift1 ) of 1 :
9942: LD_STRING AddGift1
9944: PPUSH
9945: CALL_OW 97
9949: PUSH
9950: LD_INT 1
9952: DOUBLE
9953: EQUAL
9954: IFTRUE 9958
9956: GO 10037
9958: POP
// begin for i = 1 to 3 do
9959: LD_ADDR_VAR 0 2
9963: PUSH
9964: DOUBLE
9965: LD_INT 1
9967: DEC
9968: ST_TO_ADDR
9969: LD_INT 3
9971: PUSH
9972: FOR_TO
9973: IFFALSE 10033
// begin uc_side := your_side ;
9975: LD_ADDR_OWVAR 20
9979: PUSH
9980: LD_OWVAR 2
9984: ST_TO_ADDR
// uc_nation := 0 ;
9985: LD_ADDR_OWVAR 21
9989: PUSH
9990: LD_INT 0
9992: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
9993: LD_INT 0
9995: PPUSH
9996: LD_INT 12
9998: PPUSH
9999: LD_INT 1
10001: PPUSH
10002: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , base_x , base_y , 15 , true ) ;
10006: CALL_OW 44
10010: PPUSH
10011: LD_EXP 9
10015: PPUSH
10016: LD_EXP 10
10020: PPUSH
10021: LD_INT 15
10023: PPUSH
10024: LD_INT 1
10026: PPUSH
10027: CALL_OW 50
// end ;
10031: GO 9972
10033: POP
10034: POP
// end ; 2 :
10035: GO 10106
10037: LD_INT 2
10039: DOUBLE
10040: EQUAL
10041: IFTRUE 10045
10043: GO 10087
10045: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10046: LD_EXP 11
10050: PPUSH
10051: CALL_OW 274
10055: PPUSH
10056: LD_INT 1
10058: PPUSH
10059: LD_EXP 11
10063: PPUSH
10064: CALL_OW 274
10068: PPUSH
10069: LD_INT 1
10071: PPUSH
10072: CALL_OW 275
10076: PUSH
10077: LD_INT 100
10079: PLUS
10080: PPUSH
10081: CALL_OW 277
// end ; 3 :
10085: GO 10106
10087: LD_INT 3
10089: DOUBLE
10090: EQUAL
10091: IFTRUE 10095
10093: GO 10105
10095: POP
// begin SetTeamExp ( 2 ) ;
10096: LD_INT 2
10098: PPUSH
10099: CALL 1266 0 1
// end ; end ;
10103: GO 10106
10105: POP
// end ;
10106: LD_VAR 0 1
10110: RET
// export function BonusII ; var i ; begin
10111: LD_INT 0
10113: PPUSH
10114: PPUSH
// case Query ( AddGift2 ) of 1 :
10115: LD_STRING AddGift2
10117: PPUSH
10118: CALL_OW 97
10122: PUSH
10123: LD_INT 1
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10173
10131: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
10132: LD_EXP 11
10136: PPUSH
10137: CALL_OW 274
10141: PPUSH
10142: LD_INT 1
10144: PPUSH
10145: LD_EXP 11
10149: PPUSH
10150: CALL_OW 274
10154: PPUSH
10155: LD_INT 1
10157: PPUSH
10158: CALL_OW 275
10162: PUSH
10163: LD_INT 500
10165: PLUS
10166: PPUSH
10167: CALL_OW 277
// end ; 2 :
10171: GO 10254
10173: LD_INT 2
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10191
10181: POP
// begin SetTeamExp ( 3 ) ;
10182: LD_INT 3
10184: PPUSH
10185: CALL 1266 0 1
// end ; 3 :
10189: GO 10254
10191: LD_INT 3
10193: DOUBLE
10194: EQUAL
10195: IFTRUE 10199
10197: GO 10253
10199: POP
// begin uc_side = your_side ;
10200: LD_ADDR_OWVAR 20
10204: PUSH
10205: LD_OWVAR 2
10209: ST_TO_ADDR
// uc_nation = nation_russian ;
10210: LD_ADDR_OWVAR 21
10214: PUSH
10215: LD_INT 3
10217: ST_TO_ADDR
// vc_chassis = 25 ;
10218: LD_ADDR_OWVAR 37
10222: PUSH
10223: LD_INT 25
10225: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10226: CALL_OW 45
10230: PPUSH
10231: LD_EXP 9
10235: PPUSH
10236: LD_EXP 10
10240: PPUSH
10241: LD_INT 15
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL_OW 50
// end ; end ;
10251: GO 10254
10253: POP
// end ;
10254: LD_VAR 0 1
10258: RET
// export function BonusIII ; var i ; begin
10259: LD_INT 0
10261: PPUSH
10262: PPUSH
// case Query ( AddGift3 ) of 1 :
10263: LD_STRING AddGift3
10265: PPUSH
10266: CALL_OW 97
10270: PUSH
10271: LD_INT 1
10273: DOUBLE
10274: EQUAL
10275: IFTRUE 10279
10277: GO 10321
10279: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 1000 ) ;
10280: LD_EXP 11
10284: PPUSH
10285: CALL_OW 274
10289: PPUSH
10290: LD_INT 1
10292: PPUSH
10293: LD_EXP 11
10297: PPUSH
10298: CALL_OW 274
10302: PPUSH
10303: LD_INT 1
10305: PPUSH
10306: CALL_OW 275
10310: PUSH
10311: LD_INT 1000
10313: PLUS
10314: PPUSH
10315: CALL_OW 277
// end ; 2 :
10319: GO 10428
10321: LD_INT 2
10323: DOUBLE
10324: EQUAL
10325: IFTRUE 10329
10327: GO 10341
10329: POP
// begin PrepareGuards ( waveNumber ) ;
10330: LD_EXP 5
10334: PPUSH
10335: CALL 1412 0 1
// end ; 3 :
10339: GO 10428
10341: LD_INT 3
10343: DOUBLE
10344: EQUAL
10345: IFTRUE 10349
10347: GO 10427
10349: POP
// begin uc_side = your_side ;
10350: LD_ADDR_OWVAR 20
10354: PUSH
10355: LD_OWVAR 2
10359: ST_TO_ADDR
// uc_nation = nation_american ;
10360: LD_ADDR_OWVAR 21
10364: PUSH
10365: LD_INT 1
10367: ST_TO_ADDR
// vc_chassis = us_morphling ;
10368: LD_ADDR_OWVAR 37
10372: PUSH
10373: LD_INT 5
10375: ST_TO_ADDR
// vc_engine := engine_siberite ;
10376: LD_ADDR_OWVAR 39
10380: PUSH
10381: LD_INT 3
10383: ST_TO_ADDR
// vc_control := control_computer ;
10384: LD_ADDR_OWVAR 38
10388: PUSH
10389: LD_INT 3
10391: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
10392: LD_ADDR_OWVAR 40
10396: PUSH
10397: LD_INT 8
10399: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10400: CALL_OW 45
10404: PPUSH
10405: LD_EXP 9
10409: PPUSH
10410: LD_EXP 10
10414: PPUSH
10415: LD_INT 15
10417: PPUSH
10418: LD_INT 1
10420: PPUSH
10421: CALL_OW 50
// end ; end ;
10425: GO 10428
10427: POP
// end ;
10428: LD_VAR 0 1
10432: RET
// export function BonusIV ; var i ; begin
10433: LD_INT 0
10435: PPUSH
10436: PPUSH
// case Query ( AddGift4 ) of 1 :
10437: LD_STRING AddGift4
10439: PPUSH
10440: CALL_OW 97
10444: PUSH
10445: LD_INT 1
10447: DOUBLE
10448: EQUAL
10449: IFTRUE 10453
10451: GO 10777
10453: POP
// begin i := rand ( 1 , 3 ) ;
10454: LD_ADDR_VAR 0 2
10458: PUSH
10459: LD_INT 1
10461: PPUSH
10462: LD_INT 3
10464: PPUSH
10465: CALL_OW 12
10469: ST_TO_ADDR
// uc_side := your_side ;
10470: LD_ADDR_OWVAR 20
10474: PUSH
10475: LD_OWVAR 2
10479: ST_TO_ADDR
// case i of 1 :
10480: LD_VAR 0 2
10484: PUSH
10485: LD_INT 1
10487: DOUBLE
10488: EQUAL
10489: IFTRUE 10493
10491: GO 10580
10493: POP
// begin uc_nation := nation_arabian ;
10494: LD_ADDR_OWVAR 21
10498: PUSH
10499: LD_INT 2
10501: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10502: LD_ADDR_OWVAR 37
10506: PUSH
10507: LD_INT 14
10509: ST_TO_ADDR
// vc_engine := engine_combustion ;
10510: LD_ADDR_OWVAR 39
10514: PUSH
10515: LD_INT 1
10517: ST_TO_ADDR
// vc_control := control_manual ;
10518: LD_ADDR_OWVAR 38
10522: PUSH
10523: LD_INT 1
10525: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10526: LD_ADDR_OWVAR 40
10530: PUSH
10531: LD_INT 27
10533: PUSH
10534: LD_INT 28
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: LD_INT 1
10543: PPUSH
10544: LD_INT 2
10546: PPUSH
10547: CALL_OW 12
10551: ARRAY
10552: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10553: CALL_OW 45
10557: PPUSH
10558: LD_EXP 9
10562: PPUSH
10563: LD_EXP 10
10567: PPUSH
10568: LD_INT 15
10570: PPUSH
10571: LD_INT 1
10573: PPUSH
10574: CALL_OW 50
// end ; 2 :
10578: GO 10775
10580: LD_INT 2
10582: DOUBLE
10583: EQUAL
10584: IFTRUE 10588
10586: GO 10679
10588: POP
// begin uc_nation := nation_american ;
10589: LD_ADDR_OWVAR 21
10593: PUSH
10594: LD_INT 1
10596: ST_TO_ADDR
// vc_chassis := us_morphling ;
10597: LD_ADDR_OWVAR 37
10601: PUSH
10602: LD_INT 5
10604: ST_TO_ADDR
// vc_engine := engine_siberite ;
10605: LD_ADDR_OWVAR 39
10609: PUSH
10610: LD_INT 3
10612: ST_TO_ADDR
// vc_control := control_computer ;
10613: LD_ADDR_OWVAR 38
10617: PUSH
10618: LD_INT 3
10620: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_double_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
10621: LD_ADDR_OWVAR 40
10625: PUSH
10626: LD_INT 12
10628: PUSH
10629: LD_INT 10
10631: PUSH
10632: LD_INT 7
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 1
10642: PPUSH
10643: LD_INT 3
10645: PPUSH
10646: CALL_OW 12
10650: ARRAY
10651: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10652: CALL_OW 45
10656: PPUSH
10657: LD_EXP 9
10661: PPUSH
10662: LD_EXP 10
10666: PPUSH
10667: LD_INT 15
10669: PPUSH
10670: LD_INT 1
10672: PPUSH
10673: CALL_OW 50
// end ; 3 :
10677: GO 10775
10679: LD_INT 3
10681: DOUBLE
10682: EQUAL
10683: IFTRUE 10687
10685: GO 10774
10687: POP
// begin uc_nation := nation_russian ;
10688: LD_ADDR_OWVAR 21
10692: PUSH
10693: LD_INT 3
10695: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10696: LD_ADDR_OWVAR 37
10700: PUSH
10701: LD_INT 22
10703: ST_TO_ADDR
// vc_engine := engine_combustion ;
10704: LD_ADDR_OWVAR 39
10708: PUSH
10709: LD_INT 1
10711: ST_TO_ADDR
// vc_control := control_manual ;
10712: LD_ADDR_OWVAR 38
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
10720: LD_ADDR_OWVAR 40
10724: PUSH
10725: LD_INT 45
10727: PUSH
10728: LD_INT 44
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 1
10737: PPUSH
10738: LD_INT 2
10740: PPUSH
10741: CALL_OW 12
10745: ARRAY
10746: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10747: CALL_OW 45
10751: PPUSH
10752: LD_EXP 9
10756: PPUSH
10757: LD_EXP 10
10761: PPUSH
10762: LD_INT 15
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 50
// end ; end ;
10772: GO 10775
10774: POP
// end ; 2 :
10775: GO 10846
10777: LD_INT 2
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10827
10785: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10786: LD_EXP 11
10790: PPUSH
10791: CALL_OW 274
10795: PPUSH
10796: LD_INT 1
10798: PPUSH
10799: LD_EXP 11
10803: PPUSH
10804: CALL_OW 274
10808: PPUSH
10809: LD_INT 1
10811: PPUSH
10812: CALL_OW 275
10816: PUSH
10817: LD_INT 100
10819: PLUS
10820: PPUSH
10821: CALL_OW 277
// end ; 3 :
10825: GO 10846
10827: LD_INT 3
10829: DOUBLE
10830: EQUAL
10831: IFTRUE 10835
10833: GO 10845
10835: POP
// begin SetTeamExp ( 2 ) ;
10836: LD_INT 2
10838: PPUSH
10839: CALL 1266 0 1
// end ; end ;
10843: GO 10846
10845: POP
// end ;
10846: LD_VAR 0 1
10850: RET
// export function BonusV ; var i , j ; begin
10851: LD_INT 0
10853: PPUSH
10854: PPUSH
10855: PPUSH
// case Query ( AddGift5 ) of 1 :
10856: LD_STRING AddGift5
10858: PPUSH
10859: CALL_OW 97
10863: PUSH
10864: LD_INT 1
10866: DOUBLE
10867: EQUAL
10868: IFTRUE 10872
10870: GO 11216
10872: POP
// begin for j = 1 to 3 do
10873: LD_ADDR_VAR 0 3
10877: PUSH
10878: DOUBLE
10879: LD_INT 1
10881: DEC
10882: ST_TO_ADDR
10883: LD_INT 3
10885: PUSH
10886: FOR_TO
10887: IFFALSE 11212
// begin i := rand ( 1 , 3 ) ;
10889: LD_ADDR_VAR 0 2
10893: PUSH
10894: LD_INT 1
10896: PPUSH
10897: LD_INT 3
10899: PPUSH
10900: CALL_OW 12
10904: ST_TO_ADDR
// uc_side := your_side ;
10905: LD_ADDR_OWVAR 20
10909: PUSH
10910: LD_OWVAR 2
10914: ST_TO_ADDR
// case i of 1 :
10915: LD_VAR 0 2
10919: PUSH
10920: LD_INT 1
10922: DOUBLE
10923: EQUAL
10924: IFTRUE 10928
10926: GO 11015
10928: POP
// begin uc_nation := nation_arabian ;
10929: LD_ADDR_OWVAR 21
10933: PUSH
10934: LD_INT 2
10936: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10937: LD_ADDR_OWVAR 37
10941: PUSH
10942: LD_INT 14
10944: ST_TO_ADDR
// vc_engine := engine_combustion ;
10945: LD_ADDR_OWVAR 39
10949: PUSH
10950: LD_INT 1
10952: ST_TO_ADDR
// vc_control := control_manual ;
10953: LD_ADDR_OWVAR 38
10957: PUSH
10958: LD_INT 1
10960: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10961: LD_ADDR_OWVAR 40
10965: PUSH
10966: LD_INT 27
10968: PUSH
10969: LD_INT 28
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: LD_INT 1
10978: PPUSH
10979: LD_INT 2
10981: PPUSH
10982: CALL_OW 12
10986: ARRAY
10987: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10988: CALL_OW 45
10992: PPUSH
10993: LD_EXP 9
10997: PPUSH
10998: LD_EXP 10
11002: PPUSH
11003: LD_INT 15
11005: PPUSH
11006: LD_INT 1
11008: PPUSH
11009: CALL_OW 50
// end ; 2 :
11013: GO 11210
11015: LD_INT 2
11017: DOUBLE
11018: EQUAL
11019: IFTRUE 11023
11021: GO 11114
11023: POP
// begin uc_nation := nation_american ;
11024: LD_ADDR_OWVAR 21
11028: PUSH
11029: LD_INT 1
11031: ST_TO_ADDR
// vc_chassis := us_morphling ;
11032: LD_ADDR_OWVAR 37
11036: PUSH
11037: LD_INT 5
11039: ST_TO_ADDR
// vc_engine := engine_siberite ;
11040: LD_ADDR_OWVAR 39
11044: PUSH
11045: LD_INT 3
11047: ST_TO_ADDR
// vc_control := control_computer ;
11048: LD_ADDR_OWVAR 38
11052: PUSH
11053: LD_INT 3
11055: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_radar , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
11056: LD_ADDR_OWVAR 40
11060: PUSH
11061: LD_INT 12
11063: PUSH
11064: LD_INT 11
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 1
11077: PPUSH
11078: LD_INT 3
11080: PPUSH
11081: CALL_OW 12
11085: ARRAY
11086: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11087: CALL_OW 45
11091: PPUSH
11092: LD_EXP 9
11096: PPUSH
11097: LD_EXP 10
11101: PPUSH
11102: LD_INT 15
11104: PPUSH
11105: LD_INT 1
11107: PPUSH
11108: CALL_OW 50
// end ; 3 :
11112: GO 11210
11114: LD_INT 3
11116: DOUBLE
11117: EQUAL
11118: IFTRUE 11122
11120: GO 11209
11122: POP
// begin uc_nation := nation_russian ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 3
11130: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
11131: LD_ADDR_OWVAR 37
11135: PUSH
11136: LD_INT 22
11138: ST_TO_ADDR
// vc_engine := engine_combustion ;
11139: LD_ADDR_OWVAR 39
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// vc_control := control_manual ;
11147: LD_ADDR_OWVAR 38
11151: PUSH
11152: LD_INT 1
11154: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
11155: LD_ADDR_OWVAR 40
11159: PUSH
11160: LD_INT 45
11162: PUSH
11163: LD_INT 44
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: PUSH
11170: LD_INT 1
11172: PPUSH
11173: LD_INT 2
11175: PPUSH
11176: CALL_OW 12
11180: ARRAY
11181: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11182: CALL_OW 45
11186: PPUSH
11187: LD_EXP 9
11191: PPUSH
11192: LD_EXP 10
11196: PPUSH
11197: LD_INT 15
11199: PPUSH
11200: LD_INT 1
11202: PPUSH
11203: CALL_OW 50
// end ; end ;
11207: GO 11210
11209: POP
// end ;
11210: GO 10886
11212: POP
11213: POP
// end ; 2 :
11214: GO 11282
11216: LD_INT 2
11218: DOUBLE
11219: EQUAL
11220: IFTRUE 11224
11222: GO 11266
11224: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
11225: LD_EXP 11
11229: PPUSH
11230: CALL_OW 274
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: LD_EXP 11
11242: PPUSH
11243: CALL_OW 274
11247: PPUSH
11248: LD_INT 1
11250: PPUSH
11251: CALL_OW 275
11255: PUSH
11256: LD_INT 500
11258: PLUS
11259: PPUSH
11260: CALL_OW 277
// end ; 3 :
11264: GO 11282
11266: LD_INT 3
11268: DOUBLE
11269: EQUAL
11270: IFTRUE 11274
11272: GO 11281
11274: POP
// begin GetBack ( ) ;
11275: CALL 2072 0 0
// end ; end ;
11279: GO 11282
11281: POP
// end ; end_of_file
11282: LD_VAR 0 1
11286: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11287: GO 11289
11289: DISABLE
// begin ru_radar := 98 ;
11290: LD_ADDR_EXP 14
11294: PUSH
11295: LD_INT 98
11297: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11298: LD_ADDR_EXP 15
11302: PUSH
11303: LD_INT 89
11305: ST_TO_ADDR
// us_hack := 99 ;
11306: LD_ADDR_EXP 16
11310: PUSH
11311: LD_INT 99
11313: ST_TO_ADDR
// us_artillery := 97 ;
11314: LD_ADDR_EXP 17
11318: PUSH
11319: LD_INT 97
11321: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11322: LD_ADDR_EXP 18
11326: PUSH
11327: LD_INT 91
11329: ST_TO_ADDR
// end ; end_of_file end_of_file
11330: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
11331: GO 11333
11333: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11334: LD_STRING initStreamRollete();
11336: PPUSH
11337: CALL_OW 559
// InitStreamMode ;
11341: CALL 11346 0 0
// end ;
11345: END
// function InitStreamMode ; begin
11346: LD_INT 0
11348: PPUSH
// streamModeActive := false ;
11349: LD_ADDR_EXP 19
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// sRocket := false ;
11357: LD_ADDR_EXP 22
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// sSpeed := false ;
11365: LD_ADDR_EXP 21
11369: PUSH
11370: LD_INT 0
11372: ST_TO_ADDR
// sEngine := false ;
11373: LD_ADDR_EXP 23
11377: PUSH
11378: LD_INT 0
11380: ST_TO_ADDR
// sSpec := false ;
11381: LD_ADDR_EXP 20
11385: PUSH
11386: LD_INT 0
11388: ST_TO_ADDR
// sLevel := false ;
11389: LD_ADDR_EXP 24
11393: PUSH
11394: LD_INT 0
11396: ST_TO_ADDR
// sArmoury := false ;
11397: LD_ADDR_EXP 25
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// sRadar := false ;
11405: LD_ADDR_EXP 26
11409: PUSH
11410: LD_INT 0
11412: ST_TO_ADDR
// sBunker := false ;
11413: LD_ADDR_EXP 27
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// sHack := false ;
11421: LD_ADDR_EXP 28
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// sFire := false ;
11429: LD_ADDR_EXP 29
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// sRefresh := false ;
11437: LD_ADDR_EXP 30
11441: PUSH
11442: LD_INT 0
11444: ST_TO_ADDR
// sExp := false ;
11445: LD_ADDR_EXP 31
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// sDepot := false ;
11453: LD_ADDR_EXP 32
11457: PUSH
11458: LD_INT 0
11460: ST_TO_ADDR
// sFlag := false ;
11461: LD_ADDR_EXP 33
11465: PUSH
11466: LD_INT 0
11468: ST_TO_ADDR
// sKamikadze := false ;
11469: LD_ADDR_EXP 41
11473: PUSH
11474: LD_INT 0
11476: ST_TO_ADDR
// sTroll := false ;
11477: LD_ADDR_EXP 42
11481: PUSH
11482: LD_INT 0
11484: ST_TO_ADDR
// sSlow := false ;
11485: LD_ADDR_EXP 43
11489: PUSH
11490: LD_INT 0
11492: ST_TO_ADDR
// sLack := false ;
11493: LD_ADDR_EXP 44
11497: PUSH
11498: LD_INT 0
11500: ST_TO_ADDR
// sTank := false ;
11501: LD_ADDR_EXP 46
11505: PUSH
11506: LD_INT 0
11508: ST_TO_ADDR
// sRemote := false ;
11509: LD_ADDR_EXP 47
11513: PUSH
11514: LD_INT 0
11516: ST_TO_ADDR
// sSold := false ;
11517: LD_ADDR_EXP 34
11521: PUSH
11522: LD_INT 0
11524: ST_TO_ADDR
// sDiff := false ;
11525: LD_ADDR_EXP 35
11529: PUSH
11530: LD_INT 0
11532: ST_TO_ADDR
// sFog := false ;
11533: LD_ADDR_EXP 38
11537: PUSH
11538: LD_INT 0
11540: ST_TO_ADDR
// sReset := false ;
11541: LD_ADDR_EXP 39
11545: PUSH
11546: LD_INT 0
11548: ST_TO_ADDR
// sSun := false ;
11549: LD_ADDR_EXP 40
11553: PUSH
11554: LD_INT 0
11556: ST_TO_ADDR
// sTiger := false ;
11557: LD_ADDR_EXP 36
11561: PUSH
11562: LD_INT 0
11564: ST_TO_ADDR
// sBomb := false ;
11565: LD_ADDR_EXP 37
11569: PUSH
11570: LD_INT 0
11572: ST_TO_ADDR
// sWound := false ;
11573: LD_ADDR_EXP 45
11577: PUSH
11578: LD_INT 0
11580: ST_TO_ADDR
// end ;
11581: LD_VAR 0 1
11585: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11586: LD_VAR 0 2
11590: PUSH
11591: LD_INT 100
11593: EQUAL
11594: IFFALSE 12129
// begin if not StreamModeActive then
11596: LD_EXP 19
11600: NOT
11601: IFFALSE 11611
// StreamModeActive := true ;
11603: LD_ADDR_EXP 19
11607: PUSH
11608: LD_INT 1
11610: ST_TO_ADDR
// if p3 = 0 then
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 0
11618: EQUAL
11619: IFFALSE 11625
// InitStreamMode ;
11621: CALL 11346 0 0
// if p3 = 1 then
11625: LD_VAR 0 3
11629: PUSH
11630: LD_INT 1
11632: EQUAL
11633: IFFALSE 11643
// sRocket := true ;
11635: LD_ADDR_EXP 22
11639: PUSH
11640: LD_INT 1
11642: ST_TO_ADDR
// if p3 = 2 then
11643: LD_VAR 0 3
11647: PUSH
11648: LD_INT 2
11650: EQUAL
11651: IFFALSE 11661
// sSpeed := true ;
11653: LD_ADDR_EXP 21
11657: PUSH
11658: LD_INT 1
11660: ST_TO_ADDR
// if p3 = 3 then
11661: LD_VAR 0 3
11665: PUSH
11666: LD_INT 3
11668: EQUAL
11669: IFFALSE 11679
// sEngine := true ;
11671: LD_ADDR_EXP 23
11675: PUSH
11676: LD_INT 1
11678: ST_TO_ADDR
// if p3 = 4 then
11679: LD_VAR 0 3
11683: PUSH
11684: LD_INT 4
11686: EQUAL
11687: IFFALSE 11697
// sSpec := true ;
11689: LD_ADDR_EXP 20
11693: PUSH
11694: LD_INT 1
11696: ST_TO_ADDR
// if p3 = 5 then
11697: LD_VAR 0 3
11701: PUSH
11702: LD_INT 5
11704: EQUAL
11705: IFFALSE 11715
// sLevel := true ;
11707: LD_ADDR_EXP 24
11711: PUSH
11712: LD_INT 1
11714: ST_TO_ADDR
// if p3 = 6 then
11715: LD_VAR 0 3
11719: PUSH
11720: LD_INT 6
11722: EQUAL
11723: IFFALSE 11733
// sArmoury := true ;
11725: LD_ADDR_EXP 25
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
// if p3 = 7 then
11733: LD_VAR 0 3
11737: PUSH
11738: LD_INT 7
11740: EQUAL
11741: IFFALSE 11751
// sRadar := true ;
11743: LD_ADDR_EXP 26
11747: PUSH
11748: LD_INT 1
11750: ST_TO_ADDR
// if p3 = 8 then
11751: LD_VAR 0 3
11755: PUSH
11756: LD_INT 8
11758: EQUAL
11759: IFFALSE 11769
// sBunker := true ;
11761: LD_ADDR_EXP 27
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// if p3 = 9 then
11769: LD_VAR 0 3
11773: PUSH
11774: LD_INT 9
11776: EQUAL
11777: IFFALSE 11787
// sHack := true ;
11779: LD_ADDR_EXP 28
11783: PUSH
11784: LD_INT 1
11786: ST_TO_ADDR
// if p3 = 10 then
11787: LD_VAR 0 3
11791: PUSH
11792: LD_INT 10
11794: EQUAL
11795: IFFALSE 11805
// sFire := true ;
11797: LD_ADDR_EXP 29
11801: PUSH
11802: LD_INT 1
11804: ST_TO_ADDR
// if p3 = 11 then
11805: LD_VAR 0 3
11809: PUSH
11810: LD_INT 11
11812: EQUAL
11813: IFFALSE 11823
// sRefresh := true ;
11815: LD_ADDR_EXP 30
11819: PUSH
11820: LD_INT 1
11822: ST_TO_ADDR
// if p3 = 12 then
11823: LD_VAR 0 3
11827: PUSH
11828: LD_INT 12
11830: EQUAL
11831: IFFALSE 11841
// sExp := true ;
11833: LD_ADDR_EXP 31
11837: PUSH
11838: LD_INT 1
11840: ST_TO_ADDR
// if p3 = 13 then
11841: LD_VAR 0 3
11845: PUSH
11846: LD_INT 13
11848: EQUAL
11849: IFFALSE 11859
// sDepot := true ;
11851: LD_ADDR_EXP 32
11855: PUSH
11856: LD_INT 1
11858: ST_TO_ADDR
// if p3 = 14 then
11859: LD_VAR 0 3
11863: PUSH
11864: LD_INT 14
11866: EQUAL
11867: IFFALSE 11877
// sFlag := true ;
11869: LD_ADDR_EXP 33
11873: PUSH
11874: LD_INT 1
11876: ST_TO_ADDR
// if p3 = 15 then
11877: LD_VAR 0 3
11881: PUSH
11882: LD_INT 15
11884: EQUAL
11885: IFFALSE 11895
// sKamikadze := true ;
11887: LD_ADDR_EXP 41
11891: PUSH
11892: LD_INT 1
11894: ST_TO_ADDR
// if p3 = 16 then
11895: LD_VAR 0 3
11899: PUSH
11900: LD_INT 16
11902: EQUAL
11903: IFFALSE 11913
// sTroll := true ;
11905: LD_ADDR_EXP 42
11909: PUSH
11910: LD_INT 1
11912: ST_TO_ADDR
// if p3 = 17 then
11913: LD_VAR 0 3
11917: PUSH
11918: LD_INT 17
11920: EQUAL
11921: IFFALSE 11931
// sSlow := true ;
11923: LD_ADDR_EXP 43
11927: PUSH
11928: LD_INT 1
11930: ST_TO_ADDR
// if p3 = 18 then
11931: LD_VAR 0 3
11935: PUSH
11936: LD_INT 18
11938: EQUAL
11939: IFFALSE 11949
// sLack := true ;
11941: LD_ADDR_EXP 44
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// if p3 = 19 then
11949: LD_VAR 0 3
11953: PUSH
11954: LD_INT 19
11956: EQUAL
11957: IFFALSE 11967
// sTank := true ;
11959: LD_ADDR_EXP 46
11963: PUSH
11964: LD_INT 1
11966: ST_TO_ADDR
// if p3 = 20 then
11967: LD_VAR 0 3
11971: PUSH
11972: LD_INT 20
11974: EQUAL
11975: IFFALSE 11985
// sRemote := true ;
11977: LD_ADDR_EXP 47
11981: PUSH
11982: LD_INT 1
11984: ST_TO_ADDR
// if p3 = 101 then
11985: LD_VAR 0 3
11989: PUSH
11990: LD_INT 101
11992: EQUAL
11993: IFFALSE 12003
// sSold := true ;
11995: LD_ADDR_EXP 34
11999: PUSH
12000: LD_INT 1
12002: ST_TO_ADDR
// if p3 = 102 then
12003: LD_VAR 0 3
12007: PUSH
12008: LD_INT 102
12010: EQUAL
12011: IFFALSE 12021
// sDiff := true ;
12013: LD_ADDR_EXP 35
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// if p3 = 103 then
12021: LD_VAR 0 3
12025: PUSH
12026: LD_INT 103
12028: EQUAL
12029: IFFALSE 12039
// sFog := true ;
12031: LD_ADDR_EXP 38
12035: PUSH
12036: LD_INT 1
12038: ST_TO_ADDR
// if p3 = 104 then
12039: LD_VAR 0 3
12043: PUSH
12044: LD_INT 104
12046: EQUAL
12047: IFFALSE 12057
// sReset := true ;
12049: LD_ADDR_EXP 39
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// if p3 = 105 then
12057: LD_VAR 0 3
12061: PUSH
12062: LD_INT 105
12064: EQUAL
12065: IFFALSE 12075
// sSun := true ;
12067: LD_ADDR_EXP 40
12071: PUSH
12072: LD_INT 1
12074: ST_TO_ADDR
// if p3 = 106 then
12075: LD_VAR 0 3
12079: PUSH
12080: LD_INT 106
12082: EQUAL
12083: IFFALSE 12093
// sTiger := true ;
12085: LD_ADDR_EXP 36
12089: PUSH
12090: LD_INT 1
12092: ST_TO_ADDR
// if p3 = 107 then
12093: LD_VAR 0 3
12097: PUSH
12098: LD_INT 107
12100: EQUAL
12101: IFFALSE 12111
// sBomb := true ;
12103: LD_ADDR_EXP 37
12107: PUSH
12108: LD_INT 1
12110: ST_TO_ADDR
// if p3 = 108 then
12111: LD_VAR 0 3
12115: PUSH
12116: LD_INT 108
12118: EQUAL
12119: IFFALSE 12129
// sWound := true ;
12121: LD_ADDR_EXP 45
12125: PUSH
12126: LD_INT 1
12128: ST_TO_ADDR
// end ; end ;
12129: PPOPN 6
12131: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12132: LD_EXP 19
12136: PUSH
12137: LD_EXP 22
12141: AND
12142: IFFALSE 12263
12144: GO 12146
12146: DISABLE
12147: LD_INT 0
12149: PPUSH
12150: PPUSH
// begin enable ;
12151: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12152: LD_ADDR_VAR 0 2
12156: PUSH
12157: LD_INT 22
12159: PUSH
12160: LD_OWVAR 2
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 2
12171: PUSH
12172: LD_INT 34
12174: PUSH
12175: LD_INT 7
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 34
12184: PUSH
12185: LD_INT 45
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 34
12194: PUSH
12195: LD_INT 28
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: LD_INT 34
12204: PUSH
12205: LD_INT 47
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: LIST
12216: LIST
12217: LIST
12218: PUSH
12219: EMPTY
12220: LIST
12221: LIST
12222: PPUSH
12223: CALL_OW 69
12227: ST_TO_ADDR
// if not tmp then
12228: LD_VAR 0 2
12232: NOT
12233: IFFALSE 12237
// exit ;
12235: GO 12263
// for i in tmp do
12237: LD_ADDR_VAR 0 1
12241: PUSH
12242: LD_VAR 0 2
12246: PUSH
12247: FOR_IN
12248: IFFALSE 12261
// begin DestroyUnit ( i ) ;
12250: LD_VAR 0 1
12254: PPUSH
12255: CALL_OW 65
// end ;
12259: GO 12247
12261: POP
12262: POP
// end ;
12263: PPOPN 2
12265: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12266: LD_EXP 19
12270: PUSH
12271: LD_EXP 23
12275: AND
12276: IFFALSE 12357
12278: GO 12280
12280: DISABLE
12281: LD_INT 0
12283: PPUSH
12284: PPUSH
// begin enable ;
12285: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12286: LD_ADDR_VAR 0 2
12290: PUSH
12291: LD_INT 22
12293: PUSH
12294: LD_OWVAR 2
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: PUSH
12303: LD_INT 32
12305: PUSH
12306: LD_INT 3
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: EMPTY
12314: LIST
12315: LIST
12316: PPUSH
12317: CALL_OW 69
12321: ST_TO_ADDR
// if not tmp then
12322: LD_VAR 0 2
12326: NOT
12327: IFFALSE 12331
// exit ;
12329: GO 12357
// for i in tmp do
12331: LD_ADDR_VAR 0 1
12335: PUSH
12336: LD_VAR 0 2
12340: PUSH
12341: FOR_IN
12342: IFFALSE 12355
// begin DestroyUnit ( i ) ;
12344: LD_VAR 0 1
12348: PPUSH
12349: CALL_OW 65
// end ;
12353: GO 12341
12355: POP
12356: POP
// end ;
12357: PPOPN 2
12359: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12360: LD_EXP 19
12364: PUSH
12365: LD_EXP 20
12369: AND
12370: IFFALSE 12463
12372: GO 12374
12374: DISABLE
12375: LD_INT 0
12377: PPUSH
// begin enable ;
12378: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12379: LD_ADDR_VAR 0 1
12383: PUSH
12384: LD_INT 22
12386: PUSH
12387: LD_OWVAR 2
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PUSH
12396: LD_INT 2
12398: PUSH
12399: LD_INT 25
12401: PUSH
12402: LD_INT 5
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: PUSH
12409: LD_INT 25
12411: PUSH
12412: LD_INT 9
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PUSH
12419: LD_INT 25
12421: PUSH
12422: LD_INT 8
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: LIST
12433: LIST
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: PPUSH
12439: CALL_OW 69
12443: PUSH
12444: FOR_IN
12445: IFFALSE 12461
// begin SetClass ( i , 1 ) ;
12447: LD_VAR 0 1
12451: PPUSH
12452: LD_INT 1
12454: PPUSH
12455: CALL_OW 336
// end ;
12459: GO 12444
12461: POP
12462: POP
// end ;
12463: PPOPN 1
12465: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12466: LD_EXP 19
12470: PUSH
12471: LD_EXP 21
12475: AND
12476: PUSH
12477: LD_OWVAR 65
12481: PUSH
12482: LD_INT 7
12484: LESS
12485: AND
12486: IFFALSE 12500
12488: GO 12490
12490: DISABLE
// begin enable ;
12491: ENABLE
// game_speed := 7 ;
12492: LD_ADDR_OWVAR 65
12496: PUSH
12497: LD_INT 7
12499: ST_TO_ADDR
// end ;
12500: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12501: LD_EXP 19
12505: PUSH
12506: LD_EXP 24
12510: AND
12511: IFFALSE 12713
12513: GO 12515
12515: DISABLE
12516: LD_INT 0
12518: PPUSH
12519: PPUSH
12520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12521: LD_ADDR_VAR 0 3
12525: PUSH
12526: LD_INT 81
12528: PUSH
12529: LD_OWVAR 2
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PUSH
12538: LD_INT 21
12540: PUSH
12541: LD_INT 1
12543: PUSH
12544: EMPTY
12545: LIST
12546: LIST
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 69
12556: ST_TO_ADDR
// if not tmp then
12557: LD_VAR 0 3
12561: NOT
12562: IFFALSE 12566
// exit ;
12564: GO 12713
// if tmp > 5 then
12566: LD_VAR 0 3
12570: PUSH
12571: LD_INT 5
12573: GREATER
12574: IFFALSE 12586
// k := 5 else
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_INT 5
12583: ST_TO_ADDR
12584: GO 12596
// k := tmp ;
12586: LD_ADDR_VAR 0 2
12590: PUSH
12591: LD_VAR 0 3
12595: ST_TO_ADDR
// for i := 1 to k do
12596: LD_ADDR_VAR 0 1
12600: PUSH
12601: DOUBLE
12602: LD_INT 1
12604: DEC
12605: ST_TO_ADDR
12606: LD_VAR 0 2
12610: PUSH
12611: FOR_TO
12612: IFFALSE 12711
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12614: LD_VAR 0 3
12618: PUSH
12619: LD_VAR 0 1
12623: ARRAY
12624: PPUSH
12625: LD_VAR 0 1
12629: PUSH
12630: LD_INT 4
12632: MOD
12633: PUSH
12634: LD_INT 1
12636: PLUS
12637: PPUSH
12638: CALL_OW 259
12642: PUSH
12643: LD_INT 10
12645: LESS
12646: IFFALSE 12709
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12648: LD_VAR 0 3
12652: PUSH
12653: LD_VAR 0 1
12657: ARRAY
12658: PPUSH
12659: LD_VAR 0 1
12663: PUSH
12664: LD_INT 4
12666: MOD
12667: PUSH
12668: LD_INT 1
12670: PLUS
12671: PPUSH
12672: LD_VAR 0 3
12676: PUSH
12677: LD_VAR 0 1
12681: ARRAY
12682: PPUSH
12683: LD_VAR 0 1
12687: PUSH
12688: LD_INT 4
12690: MOD
12691: PUSH
12692: LD_INT 1
12694: PLUS
12695: PPUSH
12696: CALL_OW 259
12700: PUSH
12701: LD_INT 1
12703: PLUS
12704: PPUSH
12705: CALL_OW 237
12709: GO 12611
12711: POP
12712: POP
// end ;
12713: PPOPN 3
12715: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12716: LD_EXP 19
12720: PUSH
12721: LD_EXP 25
12725: AND
12726: IFFALSE 12746
12728: GO 12730
12730: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12731: LD_INT 4
12733: PPUSH
12734: LD_OWVAR 2
12738: PPUSH
12739: LD_INT 0
12741: PPUSH
12742: CALL_OW 324
12746: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12747: LD_EXP 19
12751: PUSH
12752: LD_EXP 26
12756: AND
12757: IFFALSE 12856
12759: GO 12761
12761: DISABLE
12762: LD_INT 0
12764: PPUSH
12765: PPUSH
// begin enable ;
12766: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12767: LD_ADDR_VAR 0 2
12771: PUSH
12772: LD_INT 22
12774: PUSH
12775: LD_OWVAR 2
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 2
12786: PUSH
12787: LD_INT 34
12789: PUSH
12790: LD_INT 11
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: PUSH
12797: LD_INT 34
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: LIST
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PPUSH
12816: CALL_OW 69
12820: ST_TO_ADDR
// if not tmp then
12821: LD_VAR 0 2
12825: NOT
12826: IFFALSE 12830
// exit ;
12828: GO 12856
// for i in tmp do
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_VAR 0 2
12839: PUSH
12840: FOR_IN
12841: IFFALSE 12854
// begin DestroyUnit ( i ) ;
12843: LD_VAR 0 1
12847: PPUSH
12848: CALL_OW 65
// end ;
12852: GO 12840
12854: POP
12855: POP
// end ;
12856: PPOPN 2
12858: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12859: LD_EXP 19
12863: PUSH
12864: LD_EXP 27
12868: AND
12869: IFFALSE 12889
12871: GO 12873
12873: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12874: LD_INT 32
12876: PPUSH
12877: LD_OWVAR 2
12881: PPUSH
12882: LD_INT 0
12884: PPUSH
12885: CALL_OW 324
12889: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12890: LD_EXP 19
12894: PUSH
12895: LD_EXP 28
12899: AND
12900: IFFALSE 13081
12902: GO 12904
12904: DISABLE
12905: LD_INT 0
12907: PPUSH
12908: PPUSH
12909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12910: LD_ADDR_VAR 0 2
12914: PUSH
12915: LD_INT 22
12917: PUSH
12918: LD_OWVAR 2
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 33
12929: PUSH
12930: LD_INT 3
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PPUSH
12941: CALL_OW 69
12945: ST_TO_ADDR
// if not tmp then
12946: LD_VAR 0 2
12950: NOT
12951: IFFALSE 12955
// exit ;
12953: GO 13081
// side := 0 ;
12955: LD_ADDR_VAR 0 3
12959: PUSH
12960: LD_INT 0
12962: ST_TO_ADDR
// for i := 1 to 8 do
12963: LD_ADDR_VAR 0 1
12967: PUSH
12968: DOUBLE
12969: LD_INT 1
12971: DEC
12972: ST_TO_ADDR
12973: LD_INT 8
12975: PUSH
12976: FOR_TO
12977: IFFALSE 13025
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12979: LD_OWVAR 2
12983: PUSH
12984: LD_VAR 0 1
12988: NONEQUAL
12989: PUSH
12990: LD_OWVAR 2
12994: PPUSH
12995: LD_VAR 0 1
12999: PPUSH
13000: CALL_OW 81
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: AND
13009: IFFALSE 13023
// begin side := i ;
13011: LD_ADDR_VAR 0 3
13015: PUSH
13016: LD_VAR 0 1
13020: ST_TO_ADDR
// break ;
13021: GO 13025
// end ;
13023: GO 12976
13025: POP
13026: POP
// if not side then
13027: LD_VAR 0 3
13031: NOT
13032: IFFALSE 13036
// exit ;
13034: GO 13081
// for i := 1 to tmp do
13036: LD_ADDR_VAR 0 1
13040: PUSH
13041: DOUBLE
13042: LD_INT 1
13044: DEC
13045: ST_TO_ADDR
13046: LD_VAR 0 2
13050: PUSH
13051: FOR_TO
13052: IFFALSE 13079
// if Prob ( 30 ) then
13054: LD_INT 30
13056: PPUSH
13057: CALL_OW 13
13061: IFFALSE 13077
// SetSide ( i , side ) ;
13063: LD_VAR 0 1
13067: PPUSH
13068: LD_VAR 0 3
13072: PPUSH
13073: CALL_OW 235
13077: GO 13051
13079: POP
13080: POP
// end ;
13081: PPOPN 3
13083: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13084: LD_EXP 19
13088: PUSH
13089: LD_EXP 30
13093: AND
13094: IFFALSE 13213
13096: GO 13098
13098: DISABLE
13099: LD_INT 0
13101: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13102: LD_ADDR_VAR 0 1
13106: PUSH
13107: LD_INT 22
13109: PUSH
13110: LD_OWVAR 2
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PUSH
13119: LD_INT 21
13121: PUSH
13122: LD_INT 1
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: PUSH
13129: LD_INT 3
13131: PUSH
13132: LD_INT 23
13134: PUSH
13135: LD_INT 0
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PUSH
13142: EMPTY
13143: LIST
13144: LIST
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: LIST
13150: PPUSH
13151: CALL_OW 69
13155: PUSH
13156: FOR_IN
13157: IFFALSE 13211
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13159: LD_VAR 0 1
13163: PPUSH
13164: CALL_OW 257
13168: PUSH
13169: LD_INT 1
13171: PUSH
13172: LD_INT 2
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: LD_INT 4
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: IN
13187: IFFALSE 13209
// SetClass ( un , rand ( 1 , 4 ) ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: LD_INT 1
13196: PPUSH
13197: LD_INT 4
13199: PPUSH
13200: CALL_OW 12
13204: PPUSH
13205: CALL_OW 336
13209: GO 13156
13211: POP
13212: POP
// end ;
13213: PPOPN 1
13215: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13216: LD_EXP 19
13220: PUSH
13221: LD_EXP 29
13225: AND
13226: IFFALSE 13305
13228: GO 13230
13230: DISABLE
13231: LD_INT 0
13233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13234: LD_ADDR_VAR 0 1
13238: PUSH
13239: LD_INT 22
13241: PUSH
13242: LD_OWVAR 2
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: PUSH
13251: LD_INT 21
13253: PUSH
13254: LD_INT 3
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL_OW 69
13269: ST_TO_ADDR
// if not tmp then
13270: LD_VAR 0 1
13274: NOT
13275: IFFALSE 13279
// exit ;
13277: GO 13305
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13279: LD_VAR 0 1
13283: PUSH
13284: LD_INT 1
13286: PPUSH
13287: LD_VAR 0 1
13291: PPUSH
13292: CALL_OW 12
13296: ARRAY
13297: PPUSH
13298: LD_INT 100
13300: PPUSH
13301: CALL_OW 234
// end ;
13305: PPOPN 1
13307: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13308: LD_EXP 19
13312: PUSH
13313: LD_EXP 31
13317: AND
13318: IFFALSE 13416
13320: GO 13322
13322: DISABLE
13323: LD_INT 0
13325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13326: LD_ADDR_VAR 0 1
13330: PUSH
13331: LD_INT 22
13333: PUSH
13334: LD_OWVAR 2
13338: PUSH
13339: EMPTY
13340: LIST
13341: LIST
13342: PUSH
13343: LD_INT 21
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PPUSH
13357: CALL_OW 69
13361: ST_TO_ADDR
// if not tmp then
13362: LD_VAR 0 1
13366: NOT
13367: IFFALSE 13371
// exit ;
13369: GO 13416
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13371: LD_VAR 0 1
13375: PUSH
13376: LD_INT 1
13378: PPUSH
13379: LD_VAR 0 1
13383: PPUSH
13384: CALL_OW 12
13388: ARRAY
13389: PPUSH
13390: LD_INT 1
13392: PPUSH
13393: LD_INT 4
13395: PPUSH
13396: CALL_OW 12
13400: PPUSH
13401: LD_INT 3000
13403: PPUSH
13404: LD_INT 9000
13406: PPUSH
13407: CALL_OW 12
13411: PPUSH
13412: CALL_OW 492
// end ;
13416: PPOPN 1
13418: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13419: LD_EXP 19
13423: PUSH
13424: LD_EXP 32
13428: AND
13429: IFFALSE 13449
13431: GO 13433
13433: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13434: LD_INT 1
13436: PPUSH
13437: LD_OWVAR 2
13441: PPUSH
13442: LD_INT 0
13444: PPUSH
13445: CALL_OW 324
13449: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13450: LD_EXP 19
13454: PUSH
13455: LD_EXP 33
13459: AND
13460: IFFALSE 13543
13462: GO 13464
13464: DISABLE
13465: LD_INT 0
13467: PPUSH
13468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13469: LD_ADDR_VAR 0 2
13473: PUSH
13474: LD_INT 22
13476: PUSH
13477: LD_OWVAR 2
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PUSH
13486: LD_INT 21
13488: PUSH
13489: LD_INT 3
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PPUSH
13500: CALL_OW 69
13504: ST_TO_ADDR
// if not tmp then
13505: LD_VAR 0 2
13509: NOT
13510: IFFALSE 13514
// exit ;
13512: GO 13543
// for i in tmp do
13514: LD_ADDR_VAR 0 1
13518: PUSH
13519: LD_VAR 0 2
13523: PUSH
13524: FOR_IN
13525: IFFALSE 13541
// SetBLevel ( i , 10 ) ;
13527: LD_VAR 0 1
13531: PPUSH
13532: LD_INT 10
13534: PPUSH
13535: CALL_OW 241
13539: GO 13524
13541: POP
13542: POP
// end ;
13543: PPOPN 2
13545: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
13546: LD_EXP 19
13550: PUSH
13551: LD_EXP 34
13555: AND
13556: IFFALSE 13659
13558: GO 13560
13560: DISABLE
13561: LD_INT 0
13563: PPUSH
13564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13565: LD_ADDR_VAR 0 2
13569: PUSH
13570: LD_INT 22
13572: PUSH
13573: LD_OWVAR 2
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 25
13584: PUSH
13585: LD_INT 1
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PPUSH
13596: CALL_OW 69
13600: ST_TO_ADDR
// if not tmp then
13601: LD_VAR 0 2
13605: NOT
13606: IFFALSE 13610
// exit ;
13608: GO 13659
// for i in tmp do
13610: LD_ADDR_VAR 0 1
13614: PUSH
13615: LD_VAR 0 2
13619: PUSH
13620: FOR_IN
13621: IFFALSE 13657
// begin if Crawls ( i ) then
13623: LD_VAR 0 1
13627: PPUSH
13628: CALL_OW 318
13632: IFFALSE 13643
// ComWalk ( i ) ;
13634: LD_VAR 0 1
13638: PPUSH
13639: CALL_OW 138
// SetClass ( i , 4 ) ;
13643: LD_VAR 0 1
13647: PPUSH
13648: LD_INT 4
13650: PPUSH
13651: CALL_OW 336
// end ;
13655: GO 13620
13657: POP
13658: POP
// end ;
13659: PPOPN 2
13661: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13662: LD_EXP 19
13666: PUSH
13667: LD_EXP 35
13671: AND
13672: PUSH
13673: LD_OWVAR 67
13677: PUSH
13678: LD_INT 3
13680: LESS
13681: AND
13682: IFFALSE 13701
13684: GO 13686
13686: DISABLE
// Difficulty := Difficulty + 1 ;
13687: LD_ADDR_OWVAR 67
13691: PUSH
13692: LD_OWVAR 67
13696: PUSH
13697: LD_INT 1
13699: PLUS
13700: ST_TO_ADDR
13701: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13702: LD_EXP 19
13706: PUSH
13707: LD_EXP 36
13711: AND
13712: IFFALSE 13815
13714: GO 13716
13716: DISABLE
13717: LD_INT 0
13719: PPUSH
// begin for i := 1 to 5 do
13720: LD_ADDR_VAR 0 1
13724: PUSH
13725: DOUBLE
13726: LD_INT 1
13728: DEC
13729: ST_TO_ADDR
13730: LD_INT 5
13732: PUSH
13733: FOR_TO
13734: IFFALSE 13813
// begin uc_nation := nation_nature ;
13736: LD_ADDR_OWVAR 21
13740: PUSH
13741: LD_INT 0
13743: ST_TO_ADDR
// uc_side := 0 ;
13744: LD_ADDR_OWVAR 20
13748: PUSH
13749: LD_INT 0
13751: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13752: LD_ADDR_OWVAR 29
13756: PUSH
13757: LD_INT 12
13759: PUSH
13760: LD_INT 12
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: ST_TO_ADDR
// hc_agressivity := 20 ;
13767: LD_ADDR_OWVAR 35
13771: PUSH
13772: LD_INT 20
13774: ST_TO_ADDR
// hc_class := class_tiger ;
13775: LD_ADDR_OWVAR 28
13779: PUSH
13780: LD_INT 14
13782: ST_TO_ADDR
// hc_gallery :=  ;
13783: LD_ADDR_OWVAR 33
13787: PUSH
13788: LD_STRING 
13790: ST_TO_ADDR
// hc_name :=  ;
13791: LD_ADDR_OWVAR 26
13795: PUSH
13796: LD_STRING 
13798: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13799: CALL_OW 44
13803: PPUSH
13804: LD_INT 0
13806: PPUSH
13807: CALL_OW 51
// end ;
13811: GO 13733
13813: POP
13814: POP
// end ;
13815: PPOPN 1
13817: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
13818: LD_EXP 19
13822: PUSH
13823: LD_EXP 37
13827: AND
13828: IFFALSE 14002
13830: GO 13832
13832: DISABLE
13833: LD_INT 0
13835: PPUSH
13836: PPUSH
13837: PPUSH
13838: PPUSH
// begin result := false ;
13839: LD_ADDR_VAR 0 4
13843: PUSH
13844: LD_INT 0
13846: ST_TO_ADDR
// for i := 1 to 8 do
13847: LD_ADDR_VAR 0 1
13851: PUSH
13852: DOUBLE
13853: LD_INT 1
13855: DEC
13856: ST_TO_ADDR
13857: LD_INT 8
13859: PUSH
13860: FOR_TO
13861: IFFALSE 13972
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13863: LD_ADDR_VAR 0 2
13867: PUSH
13868: LD_INT 10
13870: PUSH
13871: LD_INT 50
13873: PUSH
13874: LD_INT 90
13876: PUSH
13877: LD_INT 140
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: PUSH
13886: LD_INT 1
13888: PPUSH
13889: LD_INT 4
13891: PPUSH
13892: CALL_OW 12
13896: ARRAY
13897: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13898: LD_ADDR_VAR 0 3
13902: PUSH
13903: LD_INT 10
13905: PUSH
13906: LD_INT 50
13908: PUSH
13909: LD_INT 90
13911: PUSH
13912: LD_INT 140
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: PUSH
13921: LD_INT 1
13923: PPUSH
13924: LD_INT 4
13926: PPUSH
13927: CALL_OW 12
13931: ARRAY
13932: ST_TO_ADDR
// if ValidHex ( x , y ) then
13933: LD_VAR 0 2
13937: PPUSH
13938: LD_VAR 0 3
13942: PPUSH
13943: CALL_OW 488
13947: IFFALSE 13970
// begin result := [ x , y ] ;
13949: LD_ADDR_VAR 0 4
13953: PUSH
13954: LD_VAR 0 2
13958: PUSH
13959: LD_VAR 0 3
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: ST_TO_ADDR
// break ;
13968: GO 13972
// end ; end ;
13970: GO 13860
13972: POP
13973: POP
// if result then
13974: LD_VAR 0 4
13978: IFFALSE 14002
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13980: LD_VAR 0 4
13984: PUSH
13985: LD_INT 1
13987: ARRAY
13988: PPUSH
13989: LD_VAR 0 4
13993: PUSH
13994: LD_INT 2
13996: ARRAY
13997: PPUSH
13998: CALL_OW 429
// end ;
14002: PPOPN 4
14004: END
// every 0 0$1 trigger StreamModeActive and sReset do
14005: LD_EXP 19
14009: PUSH
14010: LD_EXP 39
14014: AND
14015: IFFALSE 14027
14017: GO 14019
14019: DISABLE
// YouLost (  ) ;
14020: LD_STRING 
14022: PPUSH
14023: CALL_OW 104
14027: END
// every 0 0$1 trigger StreamModeActive and sFog do
14028: LD_EXP 19
14032: PUSH
14033: LD_EXP 38
14037: AND
14038: IFFALSE 14052
14040: GO 14042
14042: DISABLE
// FogOff ( your_side ) ;
14043: LD_OWVAR 2
14047: PPUSH
14048: CALL_OW 344
14052: END
// every 0 0$1 trigger StreamModeActive and sSun do
14053: LD_EXP 19
14057: PUSH
14058: LD_EXP 40
14062: AND
14063: IFFALSE 14091
14065: GO 14067
14067: DISABLE
// begin solar_recharge_percent := 0 ;
14068: LD_ADDR_OWVAR 79
14072: PUSH
14073: LD_INT 0
14075: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14076: LD_INT 10500
14078: PPUSH
14079: CALL_OW 67
// solar_recharge_percent := 100 ;
14083: LD_ADDR_OWVAR 79
14087: PUSH
14088: LD_INT 100
14090: ST_TO_ADDR
// end ;
14091: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
14092: LD_EXP 19
14096: PUSH
14097: LD_EXP 41
14101: AND
14102: IFFALSE 14257
14104: GO 14106
14106: DISABLE
14107: LD_INT 0
14109: PPUSH
14110: PPUSH
// begin for i := 1 to 6 do
14111: LD_ADDR_VAR 0 1
14115: PUSH
14116: DOUBLE
14117: LD_INT 1
14119: DEC
14120: ST_TO_ADDR
14121: LD_INT 6
14123: PUSH
14124: FOR_TO
14125: IFFALSE 14255
// begin uc_nation := nation_nature ;
14127: LD_ADDR_OWVAR 21
14131: PUSH
14132: LD_INT 0
14134: ST_TO_ADDR
// uc_side := 0 ;
14135: LD_ADDR_OWVAR 20
14139: PUSH
14140: LD_INT 0
14142: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14143: LD_ADDR_OWVAR 29
14147: PUSH
14148: LD_INT 12
14150: PUSH
14151: LD_INT 12
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: ST_TO_ADDR
// hc_agressivity := 20 ;
14158: LD_ADDR_OWVAR 35
14162: PUSH
14163: LD_INT 20
14165: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14166: LD_ADDR_OWVAR 28
14170: PUSH
14171: LD_INT 17
14173: ST_TO_ADDR
// hc_gallery :=  ;
14174: LD_ADDR_OWVAR 33
14178: PUSH
14179: LD_STRING 
14181: ST_TO_ADDR
// hc_name :=  ;
14182: LD_ADDR_OWVAR 26
14186: PUSH
14187: LD_STRING 
14189: ST_TO_ADDR
// un := CreateHuman ;
14190: LD_ADDR_VAR 0 2
14194: PUSH
14195: CALL_OW 44
14199: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14200: LD_VAR 0 2
14204: PPUSH
14205: LD_INT 1
14207: PPUSH
14208: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14212: LD_VAR 0 2
14216: PPUSH
14217: LD_INT 3
14219: PUSH
14220: LD_INT 22
14222: PUSH
14223: LD_INT 0
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PPUSH
14234: CALL_OW 69
14238: PPUSH
14239: LD_VAR 0 2
14243: PPUSH
14244: CALL_OW 74
14248: PPUSH
14249: CALL_OW 115
// end ;
14253: GO 14124
14255: POP
14256: POP
// end ;
14257: PPOPN 2
14259: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14260: LD_EXP 19
14264: PUSH
14265: LD_EXP 42
14269: AND
14270: IFFALSE 14296
14272: GO 14274
14274: DISABLE
// begin ToLua ( displayTroll(); ) ;
14275: LD_STRING displayTroll();
14277: PPUSH
14278: CALL_OW 559
// wait ( 3 3$00 ) ;
14282: LD_INT 6300
14284: PPUSH
14285: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14289: LD_STRING hideTroll();
14291: PPUSH
14292: CALL_OW 559
// end ;
14296: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14297: LD_EXP 19
14301: PUSH
14302: LD_EXP 43
14306: AND
14307: IFFALSE 14370
14309: GO 14311
14311: DISABLE
14312: LD_INT 0
14314: PPUSH
// begin p := 0 ;
14315: LD_ADDR_VAR 0 1
14319: PUSH
14320: LD_INT 0
14322: ST_TO_ADDR
// repeat game_speed := 1 ;
14323: LD_ADDR_OWVAR 65
14327: PUSH
14328: LD_INT 1
14330: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14331: LD_INT 35
14333: PPUSH
14334: CALL_OW 67
// p := p + 1 ;
14338: LD_ADDR_VAR 0 1
14342: PUSH
14343: LD_VAR 0 1
14347: PUSH
14348: LD_INT 1
14350: PLUS
14351: ST_TO_ADDR
// until p >= 60 ;
14352: LD_VAR 0 1
14356: PUSH
14357: LD_INT 60
14359: GREATEREQUAL
14360: IFFALSE 14323
// game_speed := 4 ;
14362: LD_ADDR_OWVAR 65
14366: PUSH
14367: LD_INT 4
14369: ST_TO_ADDR
// end ;
14370: PPOPN 1
14372: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14373: LD_EXP 19
14377: PUSH
14378: LD_EXP 44
14382: AND
14383: IFFALSE 14529
14385: GO 14387
14387: DISABLE
14388: LD_INT 0
14390: PPUSH
14391: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14392: LD_ADDR_VAR 0 1
14396: PUSH
14397: LD_INT 22
14399: PUSH
14400: LD_OWVAR 2
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PUSH
14409: LD_INT 2
14411: PUSH
14412: LD_INT 30
14414: PUSH
14415: LD_INT 0
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: LD_INT 30
14424: PUSH
14425: LD_INT 1
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: LIST
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PPUSH
14441: CALL_OW 69
14445: ST_TO_ADDR
// if not depot then
14446: LD_VAR 0 1
14450: NOT
14451: IFFALSE 14455
// exit ;
14453: GO 14529
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14455: LD_ADDR_VAR 0 2
14459: PUSH
14460: LD_VAR 0 1
14464: PUSH
14465: LD_INT 1
14467: PPUSH
14468: LD_VAR 0 1
14472: PPUSH
14473: CALL_OW 12
14477: ARRAY
14478: PPUSH
14479: CALL_OW 274
14483: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14484: LD_VAR 0 2
14488: PPUSH
14489: LD_INT 1
14491: PPUSH
14492: LD_INT 0
14494: PPUSH
14495: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14499: LD_VAR 0 2
14503: PPUSH
14504: LD_INT 2
14506: PPUSH
14507: LD_INT 0
14509: PPUSH
14510: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14514: LD_VAR 0 2
14518: PPUSH
14519: LD_INT 3
14521: PPUSH
14522: LD_INT 0
14524: PPUSH
14525: CALL_OW 277
// end ;
14529: PPOPN 2
14531: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14532: LD_EXP 19
14536: PUSH
14537: LD_EXP 45
14541: AND
14542: IFFALSE 14639
14544: GO 14546
14546: DISABLE
14547: LD_INT 0
14549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14550: LD_ADDR_VAR 0 1
14554: PUSH
14555: LD_INT 22
14557: PUSH
14558: LD_OWVAR 2
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 21
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: LD_INT 3
14579: PUSH
14580: LD_INT 23
14582: PUSH
14583: LD_INT 0
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: LIST
14598: PPUSH
14599: CALL_OW 69
14603: ST_TO_ADDR
// if not tmp then
14604: LD_VAR 0 1
14608: NOT
14609: IFFALSE 14613
// exit ;
14611: GO 14639
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14613: LD_VAR 0 1
14617: PUSH
14618: LD_INT 1
14620: PPUSH
14621: LD_VAR 0 1
14625: PPUSH
14626: CALL_OW 12
14630: ARRAY
14631: PPUSH
14632: LD_INT 200
14634: PPUSH
14635: CALL_OW 234
// end ;
14639: PPOPN 1
14641: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14642: LD_EXP 19
14646: PUSH
14647: LD_EXP 46
14651: AND
14652: IFFALSE 14731
14654: GO 14656
14656: DISABLE
14657: LD_INT 0
14659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14660: LD_ADDR_VAR 0 1
14664: PUSH
14665: LD_INT 22
14667: PUSH
14668: LD_OWVAR 2
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 21
14679: PUSH
14680: LD_INT 2
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PPUSH
14691: CALL_OW 69
14695: ST_TO_ADDR
// if not tmp then
14696: LD_VAR 0 1
14700: NOT
14701: IFFALSE 14705
// exit ;
14703: GO 14731
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
14705: LD_VAR 0 1
14709: PUSH
14710: LD_INT 1
14712: PPUSH
14713: LD_VAR 0 1
14717: PPUSH
14718: CALL_OW 12
14722: ARRAY
14723: PPUSH
14724: LD_INT 10
14726: PPUSH
14727: CALL_OW 234
// end ;
14731: PPOPN 1
14733: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14734: LD_EXP 19
14738: PUSH
14739: LD_EXP 47
14743: AND
14744: IFFALSE 14843
14746: GO 14748
14748: DISABLE
14749: LD_INT 0
14751: PPUSH
14752: PPUSH
// begin enable ;
14753: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14754: LD_ADDR_VAR 0 1
14758: PUSH
14759: LD_INT 22
14761: PUSH
14762: LD_OWVAR 2
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PUSH
14771: LD_INT 61
14773: PUSH
14774: EMPTY
14775: LIST
14776: PUSH
14777: LD_INT 33
14779: PUSH
14780: LD_INT 2
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: ST_TO_ADDR
// if not tmp then
14797: LD_VAR 0 1
14801: NOT
14802: IFFALSE 14806
// exit ;
14804: GO 14843
// for i in tmp do
14806: LD_ADDR_VAR 0 2
14810: PUSH
14811: LD_VAR 0 1
14815: PUSH
14816: FOR_IN
14817: IFFALSE 14841
// if IsControledBy ( i ) then
14819: LD_VAR 0 2
14823: PPUSH
14824: CALL_OW 312
14828: IFFALSE 14839
// ComUnlink ( i ) ;
14830: LD_VAR 0 2
14834: PPUSH
14835: CALL_OW 136
14839: GO 14816
14841: POP
14842: POP
// end ; end_of_file
14843: PPOPN 2
14845: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
14846: LD_INT 0
14848: PPUSH
14849: PPUSH
14850: PPUSH
14851: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
14852: LD_VAR 0 1
14856: PPUSH
14857: CALL_OW 264
14861: PUSH
14862: LD_EXP 18
14866: EQUAL
14867: IFFALSE 14939
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
14869: LD_INT 68
14871: PPUSH
14872: LD_VAR 0 1
14876: PPUSH
14877: CALL_OW 255
14881: PPUSH
14882: CALL_OW 321
14886: PUSH
14887: LD_INT 2
14889: EQUAL
14890: IFFALSE 14902
// eff := 70 else
14892: LD_ADDR_VAR 0 6
14896: PUSH
14897: LD_INT 70
14899: ST_TO_ADDR
14900: GO 14910
// eff := 30 ;
14902: LD_ADDR_VAR 0 6
14906: PUSH
14907: LD_INT 30
14909: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
14910: LD_VAR 0 1
14914: PPUSH
14915: CALL_OW 250
14919: PPUSH
14920: LD_VAR 0 1
14924: PPUSH
14925: CALL_OW 251
14929: PPUSH
14930: LD_VAR 0 6
14934: PPUSH
14935: CALL_OW 495
// end ; end ;
14939: LD_VAR 0 4
14943: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
14944: LD_INT 0
14946: PPUSH
14947: PPUSH
14948: PPUSH
14949: PPUSH
14950: PPUSH
14951: PPUSH
// if cmd = 124 then
14952: LD_VAR 0 1
14956: PUSH
14957: LD_INT 124
14959: EQUAL
14960: IFFALSE 15166
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
14962: LD_ADDR_VAR 0 5
14966: PUSH
14967: LD_INT 2
14969: PUSH
14970: LD_INT 34
14972: PUSH
14973: LD_INT 53
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PUSH
14980: LD_INT 34
14982: PUSH
14983: LD_INT 14
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: PUSH
14990: EMPTY
14991: LIST
14992: LIST
14993: LIST
14994: PPUSH
14995: CALL_OW 69
14999: ST_TO_ADDR
// if not tmp then
15000: LD_VAR 0 5
15004: NOT
15005: IFFALSE 15009
// exit ;
15007: GO 15166
// for i in tmp do
15009: LD_ADDR_VAR 0 3
15013: PUSH
15014: LD_VAR 0 5
15018: PUSH
15019: FOR_IN
15020: IFFALSE 15164
// begin taskList := GetTaskList ( i ) ;
15022: LD_ADDR_VAR 0 6
15026: PUSH
15027: LD_VAR 0 3
15031: PPUSH
15032: CALL_OW 437
15036: ST_TO_ADDR
// if not taskList then
15037: LD_VAR 0 6
15041: NOT
15042: IFFALSE 15046
// continue ;
15044: GO 15019
// for j = 1 to taskList do
15046: LD_ADDR_VAR 0 4
15050: PUSH
15051: DOUBLE
15052: LD_INT 1
15054: DEC
15055: ST_TO_ADDR
15056: LD_VAR 0 6
15060: PUSH
15061: FOR_TO
15062: IFFALSE 15160
// if taskList [ j ] [ 1 ] = | then
15064: LD_VAR 0 6
15068: PUSH
15069: LD_VAR 0 4
15073: ARRAY
15074: PUSH
15075: LD_INT 1
15077: ARRAY
15078: PUSH
15079: LD_STRING |
15081: EQUAL
15082: IFFALSE 15158
// begin _taskList := Delete ( taskList , 1 ) ;
15084: LD_ADDR_VAR 0 7
15088: PUSH
15089: LD_VAR 0 6
15093: PPUSH
15094: LD_INT 1
15096: PPUSH
15097: CALL_OW 3
15101: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
15102: LD_VAR 0 3
15106: PPUSH
15107: LD_VAR 0 7
15111: PPUSH
15112: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
15116: LD_VAR 0 3
15120: PPUSH
15121: LD_VAR 0 6
15125: PUSH
15126: LD_VAR 0 4
15130: ARRAY
15131: PUSH
15132: LD_INT 2
15134: ARRAY
15135: PPUSH
15136: LD_VAR 0 6
15140: PUSH
15141: LD_VAR 0 4
15145: ARRAY
15146: PUSH
15147: LD_INT 3
15149: ARRAY
15150: PPUSH
15151: LD_INT 8
15153: PPUSH
15154: CALL 15171 0 4
// end ;
15158: GO 15061
15160: POP
15161: POP
// end ;
15162: GO 15019
15164: POP
15165: POP
// end ; end ;
15166: LD_VAR 0 2
15170: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
15171: LD_INT 0
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
15182: LD_VAR 0 1
15186: NOT
15187: PUSH
15188: LD_VAR 0 2
15192: PPUSH
15193: LD_VAR 0 3
15197: PPUSH
15198: CALL_OW 488
15202: NOT
15203: OR
15204: PUSH
15205: LD_VAR 0 4
15209: NOT
15210: OR
15211: IFFALSE 15215
// exit ;
15213: GO 15555
// list := [ ] ;
15215: LD_ADDR_VAR 0 13
15219: PUSH
15220: EMPTY
15221: ST_TO_ADDR
// if x - r < 0 then
15222: LD_VAR 0 2
15226: PUSH
15227: LD_VAR 0 4
15231: MINUS
15232: PUSH
15233: LD_INT 0
15235: LESS
15236: IFFALSE 15248
// min_x := 0 else
15238: LD_ADDR_VAR 0 7
15242: PUSH
15243: LD_INT 0
15245: ST_TO_ADDR
15246: GO 15264
// min_x := x - r ;
15248: LD_ADDR_VAR 0 7
15252: PUSH
15253: LD_VAR 0 2
15257: PUSH
15258: LD_VAR 0 4
15262: MINUS
15263: ST_TO_ADDR
// if y - r < 0 then
15264: LD_VAR 0 3
15268: PUSH
15269: LD_VAR 0 4
15273: MINUS
15274: PUSH
15275: LD_INT 0
15277: LESS
15278: IFFALSE 15290
// min_y := 0 else
15280: LD_ADDR_VAR 0 8
15284: PUSH
15285: LD_INT 0
15287: ST_TO_ADDR
15288: GO 15306
// min_y := y - r ;
15290: LD_ADDR_VAR 0 8
15294: PUSH
15295: LD_VAR 0 3
15299: PUSH
15300: LD_VAR 0 4
15304: MINUS
15305: ST_TO_ADDR
// max_x := x + r ;
15306: LD_ADDR_VAR 0 9
15310: PUSH
15311: LD_VAR 0 2
15315: PUSH
15316: LD_VAR 0 4
15320: PLUS
15321: ST_TO_ADDR
// max_y := y + r ;
15322: LD_ADDR_VAR 0 10
15326: PUSH
15327: LD_VAR 0 3
15331: PUSH
15332: LD_VAR 0 4
15336: PLUS
15337: ST_TO_ADDR
// for _x = min_x to max_x do
15338: LD_ADDR_VAR 0 11
15342: PUSH
15343: DOUBLE
15344: LD_VAR 0 7
15348: DEC
15349: ST_TO_ADDR
15350: LD_VAR 0 9
15354: PUSH
15355: FOR_TO
15356: IFFALSE 15473
// for _y = min_y to max_y do
15358: LD_ADDR_VAR 0 12
15362: PUSH
15363: DOUBLE
15364: LD_VAR 0 8
15368: DEC
15369: ST_TO_ADDR
15370: LD_VAR 0 10
15374: PUSH
15375: FOR_TO
15376: IFFALSE 15469
// begin if not ValidHex ( _x , _y ) then
15378: LD_VAR 0 11
15382: PPUSH
15383: LD_VAR 0 12
15387: PPUSH
15388: CALL_OW 488
15392: NOT
15393: IFFALSE 15397
// continue ;
15395: GO 15375
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
15397: LD_VAR 0 11
15401: PPUSH
15402: LD_VAR 0 12
15406: PPUSH
15407: CALL_OW 351
15411: PUSH
15412: LD_VAR 0 11
15416: PPUSH
15417: LD_VAR 0 12
15421: PPUSH
15422: CALL_OW 554
15426: AND
15427: IFFALSE 15467
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
15429: LD_ADDR_VAR 0 13
15433: PUSH
15434: LD_VAR 0 13
15438: PPUSH
15439: LD_VAR 0 13
15443: PUSH
15444: LD_INT 1
15446: PLUS
15447: PPUSH
15448: LD_VAR 0 11
15452: PUSH
15453: LD_VAR 0 12
15457: PUSH
15458: EMPTY
15459: LIST
15460: LIST
15461: PPUSH
15462: CALL_OW 2
15466: ST_TO_ADDR
// end ;
15467: GO 15375
15469: POP
15470: POP
15471: GO 15355
15473: POP
15474: POP
// if not list then
15475: LD_VAR 0 13
15479: NOT
15480: IFFALSE 15484
// exit ;
15482: GO 15555
// for i in list do
15484: LD_ADDR_VAR 0 6
15488: PUSH
15489: LD_VAR 0 13
15493: PUSH
15494: FOR_IN
15495: IFFALSE 15553
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
15497: LD_VAR 0 1
15501: PPUSH
15502: LD_STRING M
15504: PUSH
15505: LD_VAR 0 6
15509: PUSH
15510: LD_INT 1
15512: ARRAY
15513: PUSH
15514: LD_VAR 0 6
15518: PUSH
15519: LD_INT 2
15521: ARRAY
15522: PUSH
15523: LD_INT 0
15525: PUSH
15526: LD_INT 0
15528: PUSH
15529: LD_INT 0
15531: PUSH
15532: LD_INT 0
15534: PUSH
15535: EMPTY
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: PUSH
15544: EMPTY
15545: LIST
15546: PPUSH
15547: CALL_OW 447
15551: GO 15494
15553: POP
15554: POP
// end ;
15555: LD_VAR 0 5
15559: RET
