// starting begin InitSettings ;
   0: CALL 2932 0 0
// InitGame ;
   4: CALL 2970 0 0
// InitDisplay ;
   8: CALL 9509 0 0
// end ; end_of_file
  12: END
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
  18: PPUSH
// if pos < 1 then
  19: LD_VAR 0 2
  23: PUSH
  24: LD_INT 1
  26: LESS
  27: IFFALSE 31
// exit ;
  29: GO 334
// if pos = 1 then
  31: LD_VAR 0 2
  35: PUSH
  36: LD_INT 1
  38: EQUAL
  39: IFFALSE 72
// result := Replace ( arr , pos [ 1 ] , value ) else
  41: LD_ADDR_VAR 0 4
  45: PUSH
  46: LD_VAR 0 1
  50: PPUSH
  51: LD_VAR 0 2
  55: PUSH
  56: LD_INT 1
  58: ARRAY
  59: PPUSH
  60: LD_VAR 0 3
  64: PPUSH
  65: CALL_OW 1
  69: ST_TO_ADDR
  70: GO 334
// begin tmp := arr ;
  72: LD_ADDR_VAR 0 6
  76: PUSH
  77: LD_VAR 0 1
  81: ST_TO_ADDR
// s_arr := [ tmp ] ;
  82: LD_ADDR_VAR 0 7
  86: PUSH
  87: LD_VAR 0 6
  91: PUSH
  92: EMPTY
  93: LIST
  94: ST_TO_ADDR
// for i = 1 to pos - 1 do
  95: LD_ADDR_VAR 0 5
  99: PUSH
 100: DOUBLE
 101: LD_INT 1
 103: DEC
 104: ST_TO_ADDR
 105: LD_VAR 0 2
 109: PUSH
 110: LD_INT 1
 112: MINUS
 113: PUSH
 114: FOR_TO
 115: IFFALSE 160
// begin tmp := tmp [ pos [ i ] ] ;
 117: LD_ADDR_VAR 0 6
 121: PUSH
 122: LD_VAR 0 6
 126: PUSH
 127: LD_VAR 0 2
 131: PUSH
 132: LD_VAR 0 5
 136: ARRAY
 137: ARRAY
 138: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
 139: LD_ADDR_VAR 0 7
 143: PUSH
 144: LD_VAR 0 7
 148: PUSH
 149: LD_VAR 0 6
 153: PUSH
 154: EMPTY
 155: LIST
 156: ADD
 157: ST_TO_ADDR
// end ;
 158: GO 114
 160: POP
 161: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
 162: LD_ADDR_VAR 0 6
 166: PUSH
 167: LD_VAR 0 6
 171: PPUSH
 172: LD_VAR 0 2
 176: PUSH
 177: LD_VAR 0 2
 181: ARRAY
 182: PPUSH
 183: LD_VAR 0 3
 187: PPUSH
 188: CALL_OW 1
 192: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
 193: LD_ADDR_VAR 0 7
 197: PUSH
 198: LD_VAR 0 7
 202: PPUSH
 203: LD_VAR 0 7
 207: PPUSH
 208: LD_VAR 0 6
 212: PPUSH
 213: CALL_OW 1
 217: ST_TO_ADDR
// for i = s_arr downto 2 do
 218: LD_ADDR_VAR 0 5
 222: PUSH
 223: DOUBLE
 224: LD_VAR 0 7
 228: INC
 229: ST_TO_ADDR
 230: LD_INT 2
 232: PUSH
 233: FOR_DOWNTO
 234: IFFALSE 318
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: LD_VAR 0 7
 245: PUSH
 246: LD_VAR 0 5
 250: PUSH
 251: LD_INT 1
 253: MINUS
 254: ARRAY
 255: PPUSH
 256: LD_VAR 0 2
 260: PUSH
 261: LD_VAR 0 5
 265: PUSH
 266: LD_INT 1
 268: MINUS
 269: ARRAY
 270: PPUSH
 271: LD_VAR 0 7
 275: PUSH
 276: LD_VAR 0 5
 280: ARRAY
 281: PPUSH
 282: CALL_OW 1
 286: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
 287: LD_ADDR_VAR 0 7
 291: PUSH
 292: LD_VAR 0 7
 296: PPUSH
 297: LD_VAR 0 5
 301: PUSH
 302: LD_INT 1
 304: MINUS
 305: PPUSH
 306: LD_VAR 0 6
 310: PPUSH
 311: CALL_OW 1
 315: ST_TO_ADDR
// end ;
 316: GO 233
 318: POP
 319: POP
// result := s_arr [ 1 ] ;
 320: LD_ADDR_VAR 0 4
 324: PUSH
 325: LD_VAR 0 7
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: ST_TO_ADDR
// end ; end ;
 334: LD_VAR 0 4
 338: RET
// export function PrepareSquad ( nation , skill , num , x , y ) ; var i , team , c ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// team := [ ] ;
 345: LD_ADDR_VAR 0 8
 349: PUSH
 350: EMPTY
 351: ST_TO_ADDR
// playerSquad := [ ] ;
 352: LD_ADDR_EXP 12
 356: PUSH
 357: EMPTY
 358: ST_TO_ADDR
// uc_side := nation ;
 359: LD_ADDR_OWVAR 20
 363: PUSH
 364: LD_VAR 0 1
 368: ST_TO_ADDR
// uc_nation := nation ;
 369: LD_ADDR_OWVAR 21
 373: PUSH
 374: LD_VAR 0 1
 378: ST_TO_ADDR
// hc_importance := 100 ;
 379: LD_ADDR_OWVAR 32
 383: PUSH
 384: LD_INT 100
 386: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 387: LD_INT 0
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: LD_VAR 0 2
 397: PPUSH
 398: CALL_OW 380
// team := Insert ( team , 1 , CreateHuman ) ;
 402: LD_ADDR_VAR 0 8
 406: PUSH
 407: LD_VAR 0 8
 411: PPUSH
 412: LD_INT 1
 414: PPUSH
 415: CALL_OW 44
 419: PPUSH
 420: CALL_OW 2
 424: ST_TO_ADDR
// hc_importance := 0 ;
 425: LD_ADDR_OWVAR 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// for i = 1 to num - 1 do
 433: LD_ADDR_VAR 0 7
 437: PUSH
 438: DOUBLE
 439: LD_INT 1
 441: DEC
 442: ST_TO_ADDR
 443: LD_VAR 0 3
 447: PUSH
 448: LD_INT 1
 450: MINUS
 451: PUSH
 452: FOR_TO
 453: IFFALSE 511
// begin PrepareHuman ( false , i div ( num / 4 ) + 1 , skill ) ;
 455: LD_INT 0
 457: PPUSH
 458: LD_VAR 0 7
 462: PUSH
 463: LD_VAR 0 3
 467: PUSH
 468: LD_INT 4
 470: DIVREAL
 471: DIV
 472: PUSH
 473: LD_INT 1
 475: PLUS
 476: PPUSH
 477: LD_VAR 0 2
 481: PPUSH
 482: CALL_OW 380
// team := Insert ( team , 2 , CreateHuman ) ;
 486: LD_ADDR_VAR 0 8
 490: PUSH
 491: LD_VAR 0 8
 495: PPUSH
 496: LD_INT 2
 498: PPUSH
 499: CALL_OW 44
 503: PPUSH
 504: CALL_OW 2
 508: ST_TO_ADDR
// end ;
 509: GO 452
 511: POP
 512: POP
// for i in team do
 513: LD_ADDR_VAR 0 7
 517: PUSH
 518: LD_VAR 0 8
 522: PUSH
 523: FOR_IN
 524: IFFALSE 623
// begin PlaceUnitXYR ( i , x , y , 8 , false ) ;
 526: LD_VAR 0 7
 530: PPUSH
 531: LD_VAR 0 4
 535: PPUSH
 536: LD_VAR 0 5
 540: PPUSH
 541: LD_INT 8
 543: PPUSH
 544: LD_INT 0
 546: PPUSH
 547: CALL_OW 50
// c := c + 1 ;
 551: LD_ADDR_VAR 0 9
 555: PUSH
 556: LD_VAR 0 9
 560: PUSH
 561: LD_INT 1
 563: PLUS
 564: ST_TO_ADDR
// SaveCharacters ( i , grave & c ) ;
 565: LD_VAR 0 7
 569: PPUSH
 570: LD_STRING grave
 572: PUSH
 573: LD_VAR 0 9
 577: STR
 578: PPUSH
 579: CALL_OW 38
// playerSquad := Insert ( playerSquad , c , [ i , grave & c ] ) ;
 583: LD_ADDR_EXP 12
 587: PUSH
 588: LD_EXP 12
 592: PPUSH
 593: LD_VAR 0 9
 597: PPUSH
 598: LD_VAR 0 7
 602: PUSH
 603: LD_STRING grave
 605: PUSH
 606: LD_VAR 0 9
 610: STR
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PPUSH
 616: CALL_OW 2
 620: ST_TO_ADDR
// end ;
 621: GO 523
 623: POP
 624: POP
// end ;
 625: LD_VAR 0 6
 629: RET
// export function PrepareResources ( num , type_allowed , x , y , r ) ; var i , n ; begin
 630: LD_INT 0
 632: PPUSH
 633: PPUSH
 634: PPUSH
// for i = 1 to type_allowed do
 635: LD_ADDR_VAR 0 7
 639: PUSH
 640: DOUBLE
 641: LD_INT 1
 643: DEC
 644: ST_TO_ADDR
 645: LD_VAR 0 2
 649: PUSH
 650: FOR_TO
 651: IFFALSE 790
// while ( num [ i ] > 0 ) do
 653: LD_VAR 0 1
 657: PUSH
 658: LD_VAR 0 7
 662: ARRAY
 663: PUSH
 664: LD_INT 0
 666: GREATER
 667: IFFALSE 788
// begin if num [ i ] > 5 then
 669: LD_VAR 0 1
 673: PUSH
 674: LD_VAR 0 7
 678: ARRAY
 679: PUSH
 680: LD_INT 5
 682: GREATER
 683: IFFALSE 695
// n := 5 else
 685: LD_ADDR_VAR 0 8
 689: PUSH
 690: LD_INT 5
 692: ST_TO_ADDR
 693: GO 711
// n := num [ i ] ;
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: LD_VAR 0 1
 704: PUSH
 705: LD_VAR 0 7
 709: ARRAY
 710: ST_TO_ADDR
// CreateResourcesXYR ( type_allowed [ i ] , n , x , y , r , false ) ;
 711: LD_VAR 0 2
 715: PUSH
 716: LD_VAR 0 7
 720: ARRAY
 721: PPUSH
 722: LD_VAR 0 8
 726: PPUSH
 727: LD_VAR 0 3
 731: PPUSH
 732: LD_VAR 0 4
 736: PPUSH
 737: LD_VAR 0 5
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 60
// num := Replace ( num , i , num [ i ] - n ) ;
 749: LD_ADDR_VAR 0 1
 753: PUSH
 754: LD_VAR 0 1
 758: PPUSH
 759: LD_VAR 0 7
 763: PPUSH
 764: LD_VAR 0 1
 768: PUSH
 769: LD_VAR 0 7
 773: ARRAY
 774: PUSH
 775: LD_VAR 0 8
 779: MINUS
 780: PPUSH
 781: CALL_OW 1
 785: ST_TO_ADDR
// end ;
 786: GO 653
 788: GO 650
 790: POP
 791: POP
// end ;
 792: LD_VAR 0 6
 796: RET
// export function AddPoints ( p ) ; begin
 797: LD_INT 0
 799: PPUSH
// points := points + p ;
 800: LD_ADDR_EXP 2
 804: PUSH
 805: LD_EXP 2
 809: PUSH
 810: LD_VAR 0 1
 814: PLUS
 815: ST_TO_ADDR
// end ;
 816: LD_VAR 0 2
 820: RET
// export function LoadColors ; var file ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
// case GetMonth of 1 .. 3 , 12 :
 825: CALL_OW 545
 829: PUSH
 830: LD_INT 1
 832: DOUBLE
 833: GREATEREQUAL
 834: IFFALSE 842
 836: LD_INT 3
 838: DOUBLE
 839: LESSEQUAL
 840: IFTRUE 850
 842: LD_INT 12
 844: DOUBLE
 845: EQUAL
 846: IFTRUE 850
 848: GO 861
 850: POP
// file = colors.txt ; 4 .. 5 :
 851: LD_ADDR_VAR 0 2
 855: PUSH
 856: LD_STRING colors.txt
 858: ST_TO_ADDR
 859: GO 937
 861: LD_INT 4
 863: DOUBLE
 864: GREATEREQUAL
 865: IFFALSE 873
 867: LD_INT 5
 869: DOUBLE
 870: LESSEQUAL
 871: IFTRUE 875
 873: GO 886
 875: POP
// file = colors-spring.txt ; 6 .. 8 :
 876: LD_ADDR_VAR 0 2
 880: PUSH
 881: LD_STRING colors-spring.txt
 883: ST_TO_ADDR
 884: GO 937
 886: LD_INT 6
 888: DOUBLE
 889: GREATEREQUAL
 890: IFFALSE 898
 892: LD_INT 8
 894: DOUBLE
 895: LESSEQUAL
 896: IFTRUE 900
 898: GO 911
 900: POP
// file = colors-summer.txt ; 9 .. 11 :
 901: LD_ADDR_VAR 0 2
 905: PUSH
 906: LD_STRING colors-summer.txt
 908: ST_TO_ADDR
 909: GO 937
 911: LD_INT 9
 913: DOUBLE
 914: GREATEREQUAL
 915: IFFALSE 923
 917: LD_INT 11
 919: DOUBLE
 920: LESSEQUAL
 921: IFTRUE 925
 923: GO 936
 925: POP
// file = colors-autumn.txt ; end ;
 926: LD_ADDR_VAR 0 2
 930: PUSH
 931: LD_STRING colors-autumn.txt
 933: ST_TO_ADDR
 934: GO 937
 936: POP
// LoadColorsTxt ( file ) ;
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 544
// end ;
 946: LD_VAR 0 1
 950: RET
// export function TestColor ; var i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
// i = 1 ;
 955: LD_ADDR_VAR 0 2
 959: PUSH
 960: LD_INT 1
 962: ST_TO_ADDR
// repeat begin wait ( 0 0$01 ) ;
 963: LD_INT 35
 965: PPUSH
 966: CALL_OW 67
// LoadColorsTxt ( [ colors-spring.txt , colors-summer.txt , colors-autumn.txt , colors.txt ] [ i mod 4 + 1 ] ) ;
 970: LD_STRING colors-spring.txt
 972: PUSH
 973: LD_STRING colors-summer.txt
 975: PUSH
 976: LD_STRING colors-autumn.txt
 978: PUSH
 979: LD_STRING colors.txt
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_VAR 0 2
 992: PUSH
 993: LD_INT 4
 995: MOD
 996: PUSH
 997: LD_INT 1
 999: PLUS
1000: ARRAY
1001: PPUSH
1002: CALL_OW 544
// display_strings := [ Wiosna , Lato , Jesien , Zima ] [ i mod 4 + 1 ] ;
1006: LD_ADDR_OWVAR 47
1010: PUSH
1011: LD_STRING Wiosna
1013: PUSH
1014: LD_STRING Lato
1016: PUSH
1017: LD_STRING Jesien
1019: PUSH
1020: LD_STRING Zima
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_INT 4
1036: MOD
1037: PUSH
1038: LD_INT 1
1040: PLUS
1041: ARRAY
1042: ST_TO_ADDR
// i := i + 1 ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_VAR 0 2
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ST_TO_ADDR
// end until false ;
1057: LD_INT 0
1059: IFFALSE 963
// end ;
1061: LD_VAR 0 1
1065: RET
// function FindDir ( x1 , y1 , x2 , y2 ) ; begin
1066: LD_INT 0
1068: PPUSH
// if x1 = x2 and y1 > y2 then
1069: LD_VAR 0 1
1073: PUSH
1074: LD_VAR 0 3
1078: EQUAL
1079: PUSH
1080: LD_VAR 0 2
1084: PUSH
1085: LD_VAR 0 4
1089: GREATER
1090: AND
1091: IFFALSE 1101
// result := 0 ;
1093: LD_ADDR_VAR 0 5
1097: PUSH
1098: LD_INT 0
1100: ST_TO_ADDR
// if x1 < x2 and y1 = y2 then
1101: LD_VAR 0 1
1105: PUSH
1106: LD_VAR 0 3
1110: LESS
1111: PUSH
1112: LD_VAR 0 2
1116: PUSH
1117: LD_VAR 0 4
1121: EQUAL
1122: AND
1123: IFFALSE 1133
// result := 1 ;
1125: LD_ADDR_VAR 0 5
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// if x1 < x2 and y1 < y2 then
1133: LD_VAR 0 1
1137: PUSH
1138: LD_VAR 0 3
1142: LESS
1143: PUSH
1144: LD_VAR 0 2
1148: PUSH
1149: LD_VAR 0 4
1153: LESS
1154: AND
1155: IFFALSE 1165
// result := 2 ;
1157: LD_ADDR_VAR 0 5
1161: PUSH
1162: LD_INT 2
1164: ST_TO_ADDR
// if x1 = x2 and y1 < y2 then
1165: LD_VAR 0 1
1169: PUSH
1170: LD_VAR 0 3
1174: EQUAL
1175: PUSH
1176: LD_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: LESS
1186: AND
1187: IFFALSE 1197
// result := 3 ;
1189: LD_ADDR_VAR 0 5
1193: PUSH
1194: LD_INT 3
1196: ST_TO_ADDR
// if x1 > x2 and y1 = y2 then
1197: LD_VAR 0 1
1201: PUSH
1202: LD_VAR 0 3
1206: GREATER
1207: PUSH
1208: LD_VAR 0 2
1212: PUSH
1213: LD_VAR 0 4
1217: EQUAL
1218: AND
1219: IFFALSE 1229
// result := 4 ;
1221: LD_ADDR_VAR 0 5
1225: PUSH
1226: LD_INT 4
1228: ST_TO_ADDR
// if x1 > x2 and y1 > y2 then
1229: LD_VAR 0 1
1233: PUSH
1234: LD_VAR 0 3
1238: GREATER
1239: PUSH
1240: LD_VAR 0 2
1244: PUSH
1245: LD_VAR 0 4
1249: GREATER
1250: AND
1251: IFFALSE 1261
// result := 5 ;
1253: LD_ADDR_VAR 0 5
1257: PUSH
1258: LD_INT 5
1260: ST_TO_ADDR
// end ;
1261: LD_VAR 0 5
1265: RET
// export function SetTeamExp ( amount ) ; var i , team , pep ; begin
1266: LD_INT 0
1268: PPUSH
1269: PPUSH
1270: PPUSH
1271: PPUSH
// team := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_OWVAR 2
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: EMPTY
1296: LIST
1297: LIST
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: ST_TO_ADDR
// for i = 1 to amount do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_VAR 0 1
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1405
// begin pep := rand ( 1 , team ) ;
1326: LD_ADDR_VAR 0 5
1330: PUSH
1331: LD_INT 1
1333: PPUSH
1334: LD_VAR 0 4
1338: PPUSH
1339: CALL_OW 12
1343: ST_TO_ADDR
// AddExperience ( team [ pep ] , rand ( 1 , 4 ) , rand ( 1000 , 10000 ) ) ;
1344: LD_VAR 0 4
1348: PUSH
1349: LD_VAR 0 5
1353: ARRAY
1354: PPUSH
1355: LD_INT 1
1357: PPUSH
1358: LD_INT 4
1360: PPUSH
1361: CALL_OW 12
1365: PPUSH
1366: LD_INT 1000
1368: PPUSH
1369: LD_INT 10000
1371: PPUSH
1372: CALL_OW 12
1376: PPUSH
1377: CALL_OW 492
// team := team diff team [ pep ] ;
1381: LD_ADDR_VAR 0 4
1385: PUSH
1386: LD_VAR 0 4
1390: PUSH
1391: LD_VAR 0 4
1395: PUSH
1396: LD_VAR 0 5
1400: ARRAY
1401: DIFF
1402: ST_TO_ADDR
// end ;
1403: GO 1323
1405: POP
1406: POP
// end ;
1407: LD_VAR 0 2
1411: RET
// export function PrepareGuards ( strenght ) ; var i , un , area , base_area , points , p , x , y , c , tmp ; begin
1412: LD_INT 0
1414: PPUSH
1415: PPUSH
1416: PPUSH
1417: PPUSH
1418: PPUSH
1419: PPUSH
1420: PPUSH
1421: PPUSH
1422: PPUSH
1423: PPUSH
1424: PPUSH
// area := AreaToList ( guardDir , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_INT 7
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 517
1440: ST_TO_ADDR
// base_area := AreaToList ( guardArea , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_INT 6
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 517
1456: ST_TO_ADDR
// for i = 1 to area [ 1 ] do
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: DOUBLE
1463: LD_INT 1
1465: DEC
1466: ST_TO_ADDR
1467: LD_VAR 0 5
1471: PUSH
1472: LD_INT 1
1474: ARRAY
1475: PUSH
1476: FOR_TO
1477: IFFALSE 1559
// begin points := Replace ( points , points + 1 , area [ 1 ] [ i ] ) ;
1479: LD_ADDR_VAR 0 7
1483: PUSH
1484: LD_VAR 0 7
1488: PPUSH
1489: LD_VAR 0 7
1493: PUSH
1494: LD_INT 1
1496: PLUS
1497: PPUSH
1498: LD_VAR 0 5
1502: PUSH
1503: LD_INT 1
1505: ARRAY
1506: PUSH
1507: LD_VAR 0 3
1511: ARRAY
1512: PPUSH
1513: CALL_OW 1
1517: ST_TO_ADDR
// points := Replace ( points , points + 1 , area [ 2 ] [ i ] ) ;
1518: LD_ADDR_VAR 0 7
1522: PUSH
1523: LD_VAR 0 7
1527: PPUSH
1528: LD_VAR 0 7
1532: PUSH
1533: LD_INT 1
1535: PLUS
1536: PPUSH
1537: LD_VAR 0 5
1541: PUSH
1542: LD_INT 2
1544: ARRAY
1545: PUSH
1546: LD_VAR 0 3
1550: ARRAY
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1476
1559: POP
1560: POP
// uc_side := 4 ;
1561: LD_ADDR_OWVAR 20
1565: PUSH
1566: LD_INT 4
1568: ST_TO_ADDR
// case strenght of 1 .. 10 :
1569: LD_VAR 0 1
1573: PUSH
1574: LD_INT 1
1576: DOUBLE
1577: GREATEREQUAL
1578: IFFALSE 1586
1580: LD_INT 10
1582: DOUBLE
1583: LESSEQUAL
1584: IFTRUE 1588
1586: GO 1650
1588: POP
// begin uc_nation := 0 ;
1589: LD_ADDR_OWVAR 21
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// for i = 1 to 20 do
1597: LD_ADDR_VAR 0 3
1601: PUSH
1602: DOUBLE
1603: LD_INT 1
1605: DEC
1606: ST_TO_ADDR
1607: LD_INT 20
1609: PUSH
1610: FOR_TO
1611: IFFALSE 1646
// begin PrepareHuman ( false , class_apeman_soldier , strenght ) ;
1613: LD_INT 0
1615: PPUSH
1616: LD_INT 15
1618: PPUSH
1619: LD_VAR 0 1
1623: PPUSH
1624: CALL_OW 380
// result := result ^ CreateHuman ;
1628: LD_ADDR_VAR 0 2
1632: PUSH
1633: LD_VAR 0 2
1637: PUSH
1638: CALL_OW 44
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1610
1646: POP
1647: POP
// end ; 11 .. 40 :
1648: GO 1837
1650: LD_INT 11
1652: DOUBLE
1653: GREATEREQUAL
1654: IFFALSE 1662
1656: LD_INT 40
1658: DOUBLE
1659: LESSEQUAL
1660: IFTRUE 1664
1662: GO 1743
1664: POP
// begin uc_nation := 1 ;
1665: LD_ADDR_OWVAR 21
1669: PUSH
1670: LD_INT 1
1672: ST_TO_ADDR
// for i = 1 to 20 do
1673: LD_ADDR_VAR 0 3
1677: PUSH
1678: DOUBLE
1679: LD_INT 1
1681: DEC
1682: ST_TO_ADDR
1683: LD_INT 20
1685: PUSH
1686: FOR_TO
1687: IFFALSE 1739
// begin vc_chassis := us_medium_tracked ;
1689: LD_ADDR_OWVAR 37
1693: PUSH
1694: LD_INT 3
1696: ST_TO_ADDR
// vc_engine := engine_siberite ;
1697: LD_ADDR_OWVAR 39
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// vc_control := control_computer ;
1705: LD_ADDR_OWVAR 38
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// vc_weapon := us_laser ;
1713: LD_ADDR_OWVAR 40
1717: PUSH
1718: LD_INT 9
1720: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1721: LD_ADDR_VAR 0 2
1725: PUSH
1726: LD_VAR 0 2
1730: PUSH
1731: CALL_OW 45
1735: ADD
1736: ST_TO_ADDR
// end ;
1737: GO 1686
1739: POP
1740: POP
// end ; 41 .. 100 :
1741: GO 1837
1743: LD_INT 41
1745: DOUBLE
1746: GREATEREQUAL
1747: IFFALSE 1755
1749: LD_INT 100
1751: DOUBLE
1752: LESSEQUAL
1753: IFTRUE 1757
1755: GO 1836
1757: POP
// begin uc_nation := 1 ;
1758: LD_ADDR_OWVAR 21
1762: PUSH
1763: LD_INT 1
1765: ST_TO_ADDR
// for i = 1 to 20 do
1766: LD_ADDR_VAR 0 3
1770: PUSH
1771: DOUBLE
1772: LD_INT 1
1774: DEC
1775: ST_TO_ADDR
1776: LD_INT 20
1778: PUSH
1779: FOR_TO
1780: IFFALSE 1832
// begin vc_chassis := us_morphling ;
1782: LD_ADDR_OWVAR 37
1786: PUSH
1787: LD_INT 5
1789: ST_TO_ADDR
// vc_engine := engine_siberite ;
1790: LD_ADDR_OWVAR 39
1794: PUSH
1795: LD_INT 3
1797: ST_TO_ADDR
// vc_control := control_computer ;
1798: LD_ADDR_OWVAR 38
1802: PUSH
1803: LD_INT 3
1805: ST_TO_ADDR
// vc_weapon := us_double_laser ;
1806: LD_ADDR_OWVAR 40
1810: PUSH
1811: LD_INT 10
1813: ST_TO_ADDR
// result := result ^ CreateVehicle ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 2
1823: PUSH
1824: CALL_OW 45
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1779
1832: POP
1833: POP
// end ; end ;
1834: GO 1837
1836: POP
// for i in result do
1837: LD_ADDR_VAR 0 3
1841: PUSH
1842: LD_VAR 0 2
1846: PUSH
1847: FOR_IN
1848: IFFALSE 2065
// begin x := base_area [ 1 ] [ 1 ] ;
1850: LD_ADDR_VAR 0 9
1854: PUSH
1855: LD_VAR 0 6
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PUSH
1864: LD_INT 1
1866: ARRAY
1867: ST_TO_ADDR
// y := base_area [ 2 ] [ 1 ] ;
1868: LD_ADDR_VAR 0 10
1872: PUSH
1873: LD_VAR 0 6
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PUSH
1882: LD_INT 1
1884: ARRAY
1885: ST_TO_ADDR
// p := FindNearestPoint ( points , x , y ) ;
1886: LD_ADDR_VAR 0 8
1890: PUSH
1891: LD_VAR 0 7
1895: PPUSH
1896: LD_VAR 0 9
1900: PPUSH
1901: LD_VAR 0 10
1905: PPUSH
1906: CALL_OW 439
1910: ST_TO_ADDR
// SetDir ( i , FindDir ( x , y , p [ 1 ] , p [ 2 ] ) ) ;
1911: LD_VAR 0 3
1915: PPUSH
1916: LD_VAR 0 9
1920: PPUSH
1921: LD_VAR 0 10
1925: PPUSH
1926: LD_VAR 0 8
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PPUSH
1935: LD_VAR 0 8
1939: PUSH
1940: LD_INT 2
1942: ARRAY
1943: PPUSH
1944: CALL 1066 0 4
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( i , x , y , true ) ;
1953: LD_VAR 0 3
1957: PPUSH
1958: LD_VAR 0 9
1962: PPUSH
1963: LD_VAR 0 10
1967: PPUSH
1968: LD_INT 1
1970: PPUSH
1971: CALL_OW 48
// ComHold ( i ) ;
1975: LD_VAR 0 3
1979: PPUSH
1980: CALL_OW 140
// for c = 1 to 2 do
1984: LD_ADDR_VAR 0 11
1988: PUSH
1989: DOUBLE
1990: LD_INT 1
1992: DEC
1993: ST_TO_ADDR
1994: LD_INT 2
1996: PUSH
1997: FOR_TO
1998: IFFALSE 2061
// begin tmp := base_area [ c ] ;
2000: LD_ADDR_VAR 0 12
2004: PUSH
2005: LD_VAR 0 6
2009: PUSH
2010: LD_VAR 0 11
2014: ARRAY
2015: ST_TO_ADDR
// tmp := Delete ( tmp , 1 ) ;
2016: LD_ADDR_VAR 0 12
2020: PUSH
2021: LD_VAR 0 12
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: CALL_OW 3
2033: ST_TO_ADDR
// base_area := Replace ( base_area , c , tmp ) ;
2034: LD_ADDR_VAR 0 6
2038: PUSH
2039: LD_VAR 0 6
2043: PPUSH
2044: LD_VAR 0 11
2048: PPUSH
2049: LD_VAR 0 12
2053: PPUSH
2054: CALL_OW 1
2058: ST_TO_ADDR
// end ;
2059: GO 1997
2061: POP
2062: POP
// end ;
2063: GO 1847
2065: POP
2066: POP
// end ;
2067: LD_VAR 0 2
2071: RET
// export function GetBack ( ) ; var i , c , un , new ; begin
2072: LD_INT 0
2074: PPUSH
2075: PPUSH
2076: PPUSH
2077: PPUSH
2078: PPUSH
// if graveyard = 0 then
2079: LD_EXP 8
2083: PUSH
2084: LD_INT 0
2086: EQUAL
2087: IFFALSE 2091
// exit ;
2089: GO 2254
// i := rand ( 1 , graveyard ) ;
2091: LD_ADDR_VAR 0 2
2095: PUSH
2096: LD_INT 1
2098: PPUSH
2099: LD_EXP 8
2103: PPUSH
2104: CALL_OW 12
2108: ST_TO_ADDR
// un := graveyard [ i ] ;
2109: LD_ADDR_VAR 0 4
2113: PUSH
2114: LD_EXP 8
2118: PUSH
2119: LD_VAR 0 2
2123: ARRAY
2124: ST_TO_ADDR
// for c in playerSquad do
2125: LD_ADDR_VAR 0 3
2129: PUSH
2130: LD_EXP 12
2134: PUSH
2135: FOR_IN
2136: IFFALSE 2172
// if un = c [ 1 ] then
2138: LD_VAR 0 4
2142: PUSH
2143: LD_VAR 0 3
2147: PUSH
2148: LD_INT 1
2150: ARRAY
2151: EQUAL
2152: IFFALSE 2170
// begin new := c [ 2 ] ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 3
2163: PUSH
2164: LD_INT 2
2166: ARRAY
2167: ST_TO_ADDR
// break ;
2168: GO 2172
// end ;
2170: GO 2135
2172: POP
2173: POP
// uc_side := your_side ;
2174: LD_ADDR_OWVAR 20
2178: PUSH
2179: LD_OWVAR 2
2183: ST_TO_ADDR
// uc_nation := playerNation ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_EXP 6
2193: ST_TO_ADDR
// un := CreateCharacter ( new ) ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_VAR 0 5
2203: PPUSH
2204: CALL_OW 34
2208: ST_TO_ADDR
// PlaceUnitXYR ( un , base_x , base_y , 10 , true ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_EXP 9
2218: PPUSH
2219: LD_EXP 10
2223: PPUSH
2224: LD_INT 10
2226: PPUSH
2227: LD_INT 1
2229: PPUSH
2230: CALL_OW 50
// graveyard := Delete ( graveyard , i ) ;
2234: LD_ADDR_EXP 8
2238: PUSH
2239: LD_EXP 8
2243: PPUSH
2244: LD_VAR 0 2
2248: PPUSH
2249: CALL_OW 3
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 1
2258: RET
// export function ComEspace ( un ) ; begin
2259: LD_INT 0
2261: PPUSH
// if not IsInArea ( un , zoneOut ) then
2262: LD_VAR 0 1
2266: PPUSH
2267: LD_INT 4
2269: PPUSH
2270: CALL_OW 308
2274: NOT
2275: IFFALSE 2291
// ComMoveToArea ( un , zoneOut ) else
2277: LD_VAR 0 1
2281: PPUSH
2282: LD_INT 4
2284: PPUSH
2285: CALL_OW 113
2289: GO 2300
// RemoveUnit ( un ) ;
2291: LD_VAR 0 1
2295: PPUSH
2296: CALL_OW 64
// end ;
2300: LD_VAR 0 2
2304: RET
// export function ComSpecMove ( un , area ) ; var list , new_list , i , x ; begin
2305: LD_INT 0
2307: PPUSH
2308: PPUSH
2309: PPUSH
2310: PPUSH
2311: PPUSH
// list := AreaToList ( area , 0 ) ;
2312: LD_ADDR_VAR 0 4
2316: PUSH
2317: LD_VAR 0 2
2321: PPUSH
2322: LD_INT 0
2324: PPUSH
2325: CALL_OW 517
2329: ST_TO_ADDR
// if not list then
2330: LD_VAR 0 4
2334: NOT
2335: IFFALSE 2339
// exit ;
2337: GO 2501
// for i = 1 to list do
2339: LD_ADDR_VAR 0 6
2343: PUSH
2344: DOUBLE
2345: LD_INT 1
2347: DEC
2348: ST_TO_ADDR
2349: LD_VAR 0 4
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2437
// begin new_list := Replace ( new_list , new_list + 1 , list [ 1 ] [ i ] ) ;
2357: LD_ADDR_VAR 0 5
2361: PUSH
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_VAR 0 5
2371: PUSH
2372: LD_INT 1
2374: PLUS
2375: PPUSH
2376: LD_VAR 0 4
2380: PUSH
2381: LD_INT 1
2383: ARRAY
2384: PUSH
2385: LD_VAR 0 6
2389: ARRAY
2390: PPUSH
2391: CALL_OW 1
2395: ST_TO_ADDR
// new_list := Replace ( new_list , new_list + 1 , list [ 2 ] [ i ] ) ;
2396: LD_ADDR_VAR 0 5
2400: PUSH
2401: LD_VAR 0 5
2405: PPUSH
2406: LD_VAR 0 5
2410: PUSH
2411: LD_INT 1
2413: PLUS
2414: PPUSH
2415: LD_VAR 0 4
2419: PUSH
2420: LD_INT 2
2422: ARRAY
2423: PUSH
2424: LD_VAR 0 6
2428: ARRAY
2429: PPUSH
2430: CALL_OW 1
2434: ST_TO_ADDR
// end ;
2435: GO 2354
2437: POP
2438: POP
// x := FindNearestPoint ( new_list , GetX ( un ) , GetY ( un ) ) ;
2439: LD_ADDR_VAR 0 7
2443: PUSH
2444: LD_VAR 0 5
2448: PPUSH
2449: LD_VAR 0 1
2453: PPUSH
2454: CALL_OW 250
2458: PPUSH
2459: LD_VAR 0 1
2463: PPUSH
2464: CALL_OW 251
2468: PPUSH
2469: CALL_OW 439
2473: ST_TO_ADDR
// ComMoveXY ( un , x [ 1 ] , x [ 2 ] ) ;
2474: LD_VAR 0 1
2478: PPUSH
2479: LD_VAR 0 7
2483: PUSH
2484: LD_INT 1
2486: ARRAY
2487: PPUSH
2488: LD_VAR 0 7
2492: PUSH
2493: LD_INT 2
2495: ARRAY
2496: PPUSH
2497: CALL_OW 111
// end ;
2501: LD_VAR 0 3
2505: RET
// export function ExplodeVehicle ( un ) ; var i , timer ; begin
2506: LD_INT 0
2508: PPUSH
2509: PPUSH
2510: PPUSH
// timer := rand ( 2 , 5 ) ;
2511: LD_ADDR_VAR 0 4
2515: PUSH
2516: LD_INT 2
2518: PPUSH
2519: LD_INT 5
2521: PPUSH
2522: CALL_OW 12
2526: ST_TO_ADDR
// while ( timer > 0 ) do
2527: LD_VAR 0 4
2531: PUSH
2532: LD_INT 0
2534: GREATER
2535: IFFALSE 2574
// begin SetUnitDisplayNumber ( un , timer ) ;
2537: LD_VAR 0 1
2541: PPUSH
2542: LD_VAR 0 4
2546: PPUSH
2547: CALL_OW 505
// timer := timer - 1 ;
2551: LD_ADDR_VAR 0 4
2555: PUSH
2556: LD_VAR 0 4
2560: PUSH
2561: LD_INT 1
2563: MINUS
2564: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
2565: LD_INT 35
2567: PPUSH
2568: CALL_OW 67
// end ;
2572: GO 2527
// if timer = 0 then
2574: LD_VAR 0 4
2578: PUSH
2579: LD_INT 0
2581: EQUAL
2582: IFFALSE 2631
// for i = 1 to 3 do
2584: LD_ADDR_VAR 0 3
2588: PUSH
2589: DOUBLE
2590: LD_INT 1
2592: DEC
2593: ST_TO_ADDR
2594: LD_INT 3
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2629
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
2600: LD_VAR 0 1
2604: PPUSH
2605: CALL_OW 250
2609: PPUSH
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 251
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 453
2627: GO 2597
2629: POP
2630: POP
// end ;
2631: LD_VAR 0 2
2635: RET
// export function DestinationReachable ( unit , x , y ) ; begin
2636: LD_INT 0
2638: PPUSH
// if unit in unreachableList then
2639: LD_VAR 0 1
2643: PUSH
2644: LD_EXP 13
2648: IN
2649: IFFALSE 2667
// unreachableList := unreachableList diff unit ;
2651: LD_ADDR_EXP 13
2655: PUSH
2656: LD_EXP 13
2660: PUSH
2661: LD_VAR 0 1
2665: DIFF
2666: ST_TO_ADDR
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
2667: LD_VAR 0 1
2671: PPUSH
2672: LD_VAR 0 2
2676: PPUSH
2677: LD_VAR 0 3
2681: PPUSH
2682: CALL_OW 428
2686: PPUSH
2687: CALL_OW 115
// Wait ( 1 ) ;
2691: LD_INT 1
2693: PPUSH
2694: CALL_OW 67
// if unit in unreachableList then
2698: LD_VAR 0 1
2702: PUSH
2703: LD_EXP 13
2707: IN
2708: IFFALSE 2720
// result := false else
2710: LD_ADDR_VAR 0 4
2714: PUSH
2715: LD_INT 0
2717: ST_TO_ADDR
2718: GO 2728
// result := true ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_INT 1
2727: ST_TO_ADDR
// end ;
2728: LD_VAR 0 4
2732: RET
// export function ComSpecAttack ( unit ) ; var i , enemy , t , x , y ; begin
2733: LD_INT 0
2735: PPUSH
2736: PPUSH
2737: PPUSH
2738: PPUSH
2739: PPUSH
2740: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
2741: LD_ADDR_VAR 0 4
2745: PUSH
2746: LD_INT 81
2748: PUSH
2749: LD_VAR 0 1
2753: PPUSH
2754: CALL_OW 255
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PPUSH
2763: CALL_OW 69
2767: ST_TO_ADDR
// if not enemy then
2768: LD_VAR 0 4
2772: NOT
2773: IFFALSE 2777
// exit ;
2775: GO 2927
// if UnitFilter ( enemy , [ f_occupied ] ) then
2777: LD_VAR 0 4
2781: PPUSH
2782: LD_INT 59
2784: PUSH
2785: EMPTY
2786: LIST
2787: PPUSH
2788: CALL_OW 72
2792: IFFALSE 2903
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
2794: LD_ADDR_VAR 0 5
2798: PUSH
2799: LD_VAR 0 4
2803: PPUSH
2804: LD_INT 59
2806: PUSH
2807: EMPTY
2808: LIST
2809: PPUSH
2810: CALL_OW 72
2814: PPUSH
2815: LD_VAR 0 1
2819: PPUSH
2820: CALL_OW 74
2824: ST_TO_ADDR
// x := GetX ( t ) ;
2825: LD_ADDR_VAR 0 6
2829: PUSH
2830: LD_VAR 0 5
2834: PPUSH
2835: CALL_OW 250
2839: ST_TO_ADDR
// y := GetY ( t ) ;
2840: LD_ADDR_VAR 0 7
2844: PUSH
2845: LD_VAR 0 5
2849: PPUSH
2850: CALL_OW 251
2854: ST_TO_ADDR
// if not DestinationReachable ( unit , x , y ) then
2855: LD_VAR 0 1
2859: PPUSH
2860: LD_VAR 0 6
2864: PPUSH
2865: LD_VAR 0 7
2869: PPUSH
2870: CALL 2636 0 3
2874: NOT
2875: IFFALSE 2901
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2877: LD_VAR 0 1
2881: PPUSH
2882: LD_VAR 0 4
2886: PPUSH
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 74
2896: PPUSH
2897: CALL_OW 115
// end else
2901: GO 2927
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
2903: LD_VAR 0 1
2907: PPUSH
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_VAR 0 1
2917: PPUSH
2918: CALL_OW 74
2922: PPUSH
2923: CALL_OW 115
// end ; end_of_file
2927: LD_VAR 0 2
2931: RET
// export debug , points , difficultyLevel , timeToNextAttack , waveNumber , playerNation , game_started , graveyard , base_x , base_y , base , playerSquad ; end_of_file export function InitSettings ; begin
2932: LD_INT 0
2934: PPUSH
// difficultyLevel := GetMultiplayerSetting ( 0 ) ;
2935: LD_ADDR_EXP 3
2939: PUSH
2940: LD_INT 0
2942: PPUSH
2943: CALL_OW 426
2947: ST_TO_ADDR
// playerNation := GetMultiplayerSetting ( 1 ) - 1 ;
2948: LD_ADDR_EXP 6
2952: PUSH
2953: LD_INT 1
2955: PPUSH
2956: CALL_OW 426
2960: PUSH
2961: LD_INT 1
2963: MINUS
2964: ST_TO_ADDR
// end ; end_of_file
2965: LD_VAR 0 1
2969: RET
// export function InitGame ; begin
2970: LD_INT 0
2972: PPUSH
// ResetFog ;
2973: CALL_OW 335
// RandomizeAll ;
2977: CALL_OW 11
// LoadColors ;
2981: CALL 821 0 0
// debug := false ;
2985: LD_ADDR_EXP 1
2989: PUSH
2990: LD_INT 0
2992: ST_TO_ADDR
// ar_bio_bomb := 91 ;
2993: LD_ADDR_EXP 18
2997: PUSH
2998: LD_INT 91
3000: ST_TO_ADDR
// us_artillery := 97 ;
3001: LD_ADDR_EXP 17
3005: PUSH
3006: LD_INT 97
3008: ST_TO_ADDR
// ru_radar := 98 ;
3009: LD_ADDR_EXP 14
3013: PUSH
3014: LD_INT 98
3016: ST_TO_ADDR
// game_started := false ;
3017: LD_ADDR_EXP 7
3021: PUSH
3022: LD_INT 0
3024: ST_TO_ADDR
// points := 0 ;
3025: LD_ADDR_EXP 2
3029: PUSH
3030: LD_INT 0
3032: ST_TO_ADDR
// waveNumber := 0 ;
3033: LD_ADDR_EXP 5
3037: PUSH
3038: LD_INT 0
3040: ST_TO_ADDR
// timeToNextAttack := 0 ;
3041: LD_ADDR_EXP 4
3045: PUSH
3046: LD_INT 0
3048: ST_TO_ADDR
// graveyard := [ ] ;
3049: LD_ADDR_EXP 8
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// base_x := 1 ;
3056: LD_ADDR_EXP 9
3060: PUSH
3061: LD_INT 1
3063: ST_TO_ADDR
// base_y := 1 ;
3064: LD_ADDR_EXP 10
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// if difficultyLevel > 2 then
3072: LD_EXP 3
3076: PUSH
3077: LD_INT 2
3079: GREATER
3080: IFFALSE 3095
// SetTech ( 5 , 7 , state_researched ) ;
3082: LD_INT 5
3084: PPUSH
3085: LD_INT 7
3087: PPUSH
3088: LD_INT 2
3090: PPUSH
3091: CALL_OW 322
// if not playerNation then
3095: LD_EXP 6
3099: NOT
3100: IFFALSE 3126
// begin points := 100 ;
3102: LD_ADDR_EXP 2
3106: PUSH
3107: LD_INT 100
3109: ST_TO_ADDR
// playerNation := rand ( 1 , 3 ) ;
3110: LD_ADDR_EXP 6
3114: PUSH
3115: LD_INT 1
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 12
3125: ST_TO_ADDR
// end ; your_side := playerNation ;
3126: LD_ADDR_OWVAR 2
3130: PUSH
3131: LD_EXP 6
3135: ST_TO_ADDR
// ChangeSideFog ( your_side , 4 ) ;
3136: LD_OWVAR 2
3140: PPUSH
3141: LD_INT 4
3143: PPUSH
3144: CALL_OW 343
// PrepareResources ( [ [ 25 , 20 , 15 , 10 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] , [ 5 , 3 , 2 , 1 ] [ difficultyLevel ] ] , [ 1 , 2 , 3 ] , 88 , 76 , 6 ) ;
3148: LD_INT 25
3150: PUSH
3151: LD_INT 20
3153: PUSH
3154: LD_INT 15
3156: PUSH
3157: LD_INT 10
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: LIST
3165: PUSH
3166: LD_EXP 3
3170: ARRAY
3171: PUSH
3172: LD_INT 5
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: LD_INT 2
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_EXP 3
3194: ARRAY
3195: PUSH
3196: LD_INT 5
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: LD_INT 2
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: PUSH
3214: LD_EXP 3
3218: ARRAY
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: PPUSH
3225: LD_INT 1
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 3
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: LIST
3238: PPUSH
3239: LD_INT 88
3241: PPUSH
3242: LD_INT 76
3244: PPUSH
3245: LD_INT 6
3247: PPUSH
3248: CALL 630 0 5
// PrepareSquad ( playerNation , [ 9 , 7 , 5 , 3 ] [ difficultyLevel ] , [ 24 , 16 , 12 , 8 ] [ difficultyLevel ] , 88 , 76 ) ;
3252: LD_EXP 6
3256: PPUSH
3257: LD_INT 9
3259: PUSH
3260: LD_INT 7
3262: PUSH
3263: LD_INT 5
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_EXP 3
3279: ARRAY
3280: PPUSH
3281: LD_INT 24
3283: PUSH
3284: LD_INT 16
3286: PUSH
3287: LD_INT 12
3289: PUSH
3290: LD_INT 8
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: PUSH
3299: LD_EXP 3
3303: ARRAY
3304: PPUSH
3305: LD_INT 88
3307: PPUSH
3308: LD_INT 76
3310: PPUSH
3311: CALL 339 0 5
// CenterNowOnXY ( 88 , 76 ) ;
3315: LD_INT 88
3317: PPUSH
3318: LD_INT 76
3320: PPUSH
3321: CALL_OW 86
// PlaceSeeing ( 90 , 79 , your_side , - 50 ) ;
3325: LD_INT 90
3327: PPUSH
3328: LD_INT 79
3330: PPUSH
3331: LD_OWVAR 2
3335: PPUSH
3336: LD_INT 50
3338: NEG
3339: PPUSH
3340: CALL_OW 330
// if debug then
3344: LD_EXP 1
3348: IFFALSE 3359
// FogOff ( your_side ) ;
3350: LD_OWVAR 2
3354: PPUSH
3355: CALL_OW 344
// end ;
3359: LD_VAR 0 1
3363: RET
// every 0 0$01 trigger game_started do var i ;
3364: LD_EXP 7
3368: IFFALSE 3602
3370: GO 3372
3372: DISABLE
3373: LD_INT 0
3375: PPUSH
// begin while ( game_started ) do
3376: LD_EXP 7
3380: IFFALSE 3602
// begin if FilterAllUnits ( [ f_side , 7 ] ) < 5 and timeToNextAttack <= 0 0$00 then
3382: LD_INT 22
3384: PUSH
3385: LD_INT 7
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PPUSH
3392: CALL_OW 69
3396: PUSH
3397: LD_INT 5
3399: LESS
3400: PUSH
3401: LD_EXP 4
3405: PUSH
3406: LD_INT 0
3408: LESSEQUAL
3409: AND
3410: IFFALSE 3593
// begin if FilterAllUnits ( [ f_side , 4 ] ) then
3412: LD_INT 22
3414: PUSH
3415: LD_INT 4
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PPUSH
3422: CALL_OW 69
3426: IFFALSE 3464
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3428: LD_ADDR_VAR 0 1
3432: PUSH
3433: LD_INT 22
3435: PUSH
3436: LD_INT 4
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PPUSH
3443: CALL_OW 69
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3462
// RemoveUnit ( i ) ;
3451: LD_VAR 0 1
3455: PPUSH
3456: CALL_OW 64
3460: GO 3448
3462: POP
3463: POP
// if ( waveNumber mod 3 = 0 or waveNumber mod 10 = 0 ) and waveNumber > 0 then
3464: LD_EXP 5
3468: PUSH
3469: LD_INT 3
3471: MOD
3472: PUSH
3473: LD_INT 0
3475: EQUAL
3476: PUSH
3477: LD_EXP 5
3481: PUSH
3482: LD_INT 10
3484: MOD
3485: PUSH
3486: LD_INT 0
3488: EQUAL
3489: OR
3490: PUSH
3491: LD_EXP 5
3495: PUSH
3496: LD_INT 0
3498: GREATER
3499: AND
3500: IFFALSE 3506
// InitBonus ;
3502: CALL 9606 0 0
// if waveNumber mod 10 = 0 then
3506: LD_EXP 5
3510: PUSH
3511: LD_INT 10
3513: MOD
3514: PUSH
3515: LD_INT 0
3517: EQUAL
3518: IFFALSE 3524
// SaveForQuickRestart ;
3520: CALL_OW 22
// if waveNumber = 100 then
3524: LD_EXP 5
3528: PUSH
3529: LD_INT 100
3531: EQUAL
3532: IFFALSE 3545
// begin FogOff ( your_side ) ;
3534: LD_OWVAR 2
3538: PPUSH
3539: CALL_OW 344
// break ;
3543: GO 3602
// end ; timeToNextAttack := rand ( 1 1$30 , 2 2$30 ) ;
3545: LD_ADDR_EXP 4
3549: PUSH
3550: LD_INT 3150
3552: PPUSH
3553: LD_INT 5250
3555: PPUSH
3556: CALL_OW 12
3560: ST_TO_ADDR
// Wait ( timeToNextAttack ) ;
3561: LD_EXP 4
3565: PPUSH
3566: CALL_OW 67
// waveNumber := waveNumber + 1 ;
3570: LD_ADDR_EXP 5
3574: PUSH
3575: LD_EXP 5
3579: PUSH
3580: LD_INT 1
3582: PLUS
3583: ST_TO_ADDR
// PrepareWave ( waveNumber ) ;
3584: LD_EXP 5
3588: PPUSH
3589: CALL 4597 0 1
// end ; Wait ( 0 0$01 ) ;
3593: LD_INT 35
3595: PPUSH
3596: CALL_OW 67
// end ;
3600: GO 3376
// end ;
3602: PPOPN 1
3604: END
// every 0 0$01 trigger timeToNextAttack > 0 0$00 do
3605: LD_EXP 4
3609: PUSH
3610: LD_INT 0
3612: GREATER
3613: IFFALSE 3633
3615: GO 3617
3617: DISABLE
// begin enable ;
3618: ENABLE
// timeToNextAttack := timeToNextAttack - 0 0$01 ;
3619: LD_ADDR_EXP 4
3623: PUSH
3624: LD_EXP 4
3628: PUSH
3629: LD_INT 35
3631: MINUS
3632: ST_TO_ADDR
// end ; end_of_file
3633: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
3634: LD_VAR 0 1
3638: PUSH
3639: LD_EXP 13
3643: IN
3644: NOT
3645: IFFALSE 3676
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
3647: LD_ADDR_EXP 13
3651: PUSH
3652: LD_EXP 13
3656: PPUSH
3657: LD_EXP 13
3661: PUSH
3662: LD_INT 1
3664: PLUS
3665: PPUSH
3666: LD_VAR 0 1
3670: PPUSH
3671: CALL_OW 2
3675: ST_TO_ADDR
// end ;
3676: PPOPN 1
3678: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side and GetType ( un ) = unit_human then
3679: LD_VAR 0 1
3683: PPUSH
3684: CALL_OW 255
3688: PUSH
3689: LD_OWVAR 2
3693: EQUAL
3694: PUSH
3695: LD_VAR 0 1
3699: PPUSH
3700: CALL_OW 247
3704: PUSH
3705: LD_INT 1
3707: EQUAL
3708: AND
3709: IFFALSE 3740
// begin graveyard := Insert ( graveyard , graveyard + 1 , un ) ;
3711: LD_ADDR_EXP 8
3715: PUSH
3716: LD_EXP 8
3720: PPUSH
3721: LD_EXP 8
3725: PUSH
3726: LD_INT 1
3728: PLUS
3729: PPUSH
3730: LD_VAR 0 1
3734: PPUSH
3735: CALL_OW 2
3739: ST_TO_ADDR
// end ; if GetSide ( un ) = 7 then
3740: LD_VAR 0 1
3744: PPUSH
3745: CALL_OW 255
3749: PUSH
3750: LD_INT 7
3752: EQUAL
3753: IFFALSE 4127
// begin if un in FilterAllUnits ( [ f_weapon , 91 ] ) then
3755: LD_VAR 0 1
3759: PUSH
3760: LD_INT 34
3762: PUSH
3763: LD_INT 91
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PPUSH
3770: CALL_OW 69
3774: IN
3775: IFFALSE 3820
// begin if Rand ( 1 , 100 ) <= 70 then
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 100
3782: PPUSH
3783: CALL_OW 12
3787: PUSH
3788: LD_INT 70
3790: LESSEQUAL
3791: IFFALSE 3820
// ArtContamination ( GetX ( un ) , GetY ( un ) , 10 ) ;
3793: LD_VAR 0 1
3797: PPUSH
3798: CALL_OW 250
3802: PPUSH
3803: LD_VAR 0 1
3807: PPUSH
3808: CALL_OW 251
3812: PPUSH
3813: LD_INT 10
3815: PPUSH
3816: CALL_OW 495
// end ; case GetType ( un ) of unit_human :
3820: LD_VAR 0 1
3824: PPUSH
3825: CALL_OW 247
3829: PUSH
3830: LD_INT 1
3832: DOUBLE
3833: EQUAL
3834: IFTRUE 3838
3836: GO 3972
3838: POP
// begin case GetClass ( un ) of class_apeman :
3839: LD_VAR 0 1
3843: PPUSH
3844: CALL_OW 257
3848: PUSH
3849: LD_INT 12
3851: DOUBLE
3852: EQUAL
3853: IFTRUE 3857
3855: GO 3867
3857: POP
// AddPoints ( 2 ) ; class_apeman_soldier :
3858: LD_INT 2
3860: PPUSH
3861: CALL 797 0 1
3865: GO 3970
3867: LD_INT 15
3869: DOUBLE
3870: EQUAL
3871: IFTRUE 3875
3873: GO 3885
3875: POP
// AddPoints ( 5 ) ; class_apeman_kamikaze :
3876: LD_INT 5
3878: PPUSH
3879: CALL 797 0 1
3883: GO 3970
3885: LD_INT 17
3887: DOUBLE
3888: EQUAL
3889: IFTRUE 3893
3891: GO 3903
3893: POP
// AddPoints ( 30 ) ; class_soldier :
3894: LD_INT 30
3896: PPUSH
3897: CALL 797 0 1
3901: GO 3970
3903: LD_INT 1
3905: DOUBLE
3906: EQUAL
3907: IFTRUE 3911
3909: GO 3921
3911: POP
// AddPoints ( 50 ) ; class_bazooker , class_sniper , class_mortar :
3912: LD_INT 50
3914: PPUSH
3915: CALL 797 0 1
3919: GO 3970
3921: LD_INT 9
3923: DOUBLE
3924: EQUAL
3925: IFTRUE 3941
3927: LD_INT 5
3929: DOUBLE
3930: EQUAL
3931: IFTRUE 3941
3933: LD_INT 8
3935: DOUBLE
3936: EQUAL
3937: IFTRUE 3941
3939: GO 3951
3941: POP
// AddPoints ( 75 ) ; class_mechanic :
3942: LD_INT 75
3944: PPUSH
3945: CALL 797 0 1
3949: GO 3970
3951: LD_INT 3
3953: DOUBLE
3954: EQUAL
3955: IFTRUE 3959
3957: GO 3969
3959: POP
// AddPoints ( 60 ) ; end ;
3960: LD_INT 60
3962: PPUSH
3963: CALL 797 0 1
3967: GO 3970
3969: POP
// end ; unit_vehicle :
3970: GO 4127
3972: LD_INT 2
3974: DOUBLE
3975: EQUAL
3976: IFTRUE 3980
3978: GO 4126
3980: POP
// begin case GetChassis ( un ) of ar_light_trike , us_light_wheeled , ar_hovercraft :
3981: LD_VAR 0 1
3985: PPUSH
3986: CALL_OW 265
3990: PUSH
3991: LD_INT 12
3993: DOUBLE
3994: EQUAL
3995: IFTRUE 4011
3997: LD_INT 1
3999: DOUBLE
4000: EQUAL
4001: IFTRUE 4011
4003: LD_INT 11
4005: DOUBLE
4006: EQUAL
4007: IFTRUE 4011
4009: GO 4021
4011: POP
// AddPoints ( 100 ) ; ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , ru_medium_wheeled , ru_medium_tracked :
4012: LD_INT 100
4014: PPUSH
4015: CALL 797 0 1
4019: GO 4124
4021: LD_INT 13
4023: DOUBLE
4024: EQUAL
4025: IFTRUE 4059
4027: LD_INT 14
4029: DOUBLE
4030: EQUAL
4031: IFTRUE 4059
4033: LD_INT 2
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4059
4039: LD_INT 3
4041: DOUBLE
4042: EQUAL
4043: IFTRUE 4059
4045: LD_INT 21
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4059
4051: LD_INT 22
4053: DOUBLE
4054: EQUAL
4055: IFTRUE 4059
4057: GO 4069
4059: POP
// AddPoints ( 250 ) ; us_heavy_tracked , us_morphling , ru_heavy_wheeled , ru_heavy_tracked :
4060: LD_INT 250
4062: PPUSH
4063: CALL 797 0 1
4067: GO 4124
4069: LD_INT 4
4071: DOUBLE
4072: EQUAL
4073: IFTRUE 4095
4075: LD_INT 5
4077: DOUBLE
4078: EQUAL
4079: IFTRUE 4095
4081: LD_INT 23
4083: DOUBLE
4084: EQUAL
4085: IFTRUE 4095
4087: LD_INT 24
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4095
4093: GO 4105
4095: POP
// AddPoints ( 500 ) ; 25 :
4096: LD_INT 500
4098: PPUSH
4099: CALL 797 0 1
4103: GO 4124
4105: LD_INT 25
4107: DOUBLE
4108: EQUAL
4109: IFTRUE 4113
4111: GO 4123
4113: POP
// AddPoints ( 1250 ) ; end ;
4114: LD_INT 1250
4116: PPUSH
4117: CALL 797 0 1
4121: GO 4124
4123: POP
// end ; end ;
4124: GO 4127
4126: POP
// end ; end ;
4127: PPOPN 1
4129: END
// on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot then
4130: LD_VAR 0 1
4134: PPUSH
4135: CALL_OW 266
4139: PUSH
4140: LD_INT 0
4142: EQUAL
4143: IFFALSE 4193
// begin base_x := GetX ( b ) ;
4145: LD_ADDR_EXP 9
4149: PUSH
4150: LD_VAR 0 1
4154: PPUSH
4155: CALL_OW 250
4159: ST_TO_ADDR
// base_y := GetY ( b ) ;
4160: LD_ADDR_EXP 10
4164: PUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 251
4174: ST_TO_ADDR
// base := b ;
4175: LD_ADDR_EXP 11
4179: PUSH
4180: LD_VAR 0 1
4184: ST_TO_ADDR
// game_started := true ;
4185: LD_ADDR_EXP 7
4189: PUSH
4190: LD_INT 1
4192: ST_TO_ADDR
// end ; end ;
4193: PPOPN 1
4195: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = your_side then
4196: LD_VAR 0 1
4200: PPUSH
4201: CALL_OW 255
4205: PUSH
4206: LD_OWVAR 2
4210: EQUAL
4211: IFFALSE 4215
// exit ;
4213: GO 4362
// if GetType ( un ) = unit_vehicle then
4215: LD_VAR 0 1
4219: PPUSH
4220: CALL_OW 247
4224: PUSH
4225: LD_INT 2
4227: EQUAL
4228: IFFALSE 4281
// begin KillUnit ( un ) ;
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 66
// if GetNation ( un ) = nation_arabian or GetWeapon ( un ) in [ ru_time_lapser ] then
4239: LD_VAR 0 1
4243: PPUSH
4244: CALL_OW 248
4248: PUSH
4249: LD_INT 2
4251: EQUAL
4252: PUSH
4253: LD_VAR 0 1
4257: PPUSH
4258: CALL_OW 264
4262: PUSH
4263: LD_INT 49
4265: PUSH
4266: EMPTY
4267: LIST
4268: IN
4269: OR
4270: IFFALSE 4281
// ExplodeVehicle ( un ) ;
4272: LD_VAR 0 1
4276: PPUSH
4277: CALL 2506 0 1
// end ; if GetType ( un ) = unit_human then
4281: LD_VAR 0 1
4285: PPUSH
4286: CALL_OW 247
4290: PUSH
4291: LD_INT 1
4293: EQUAL
4294: IFFALSE 4362
// begin if ( GetNation ( un ) = 2 and GetTech ( 5 , 7 ) <> state_researched ) or GetNation ( un ) in [ 0 , 1 , 3 ] then
4296: LD_VAR 0 1
4300: PPUSH
4301: CALL_OW 248
4305: PUSH
4306: LD_INT 2
4308: EQUAL
4309: PUSH
4310: LD_INT 5
4312: PPUSH
4313: LD_INT 7
4315: PPUSH
4316: CALL_OW 321
4320: PUSH
4321: LD_INT 2
4323: NONEQUAL
4324: AND
4325: PUSH
4326: LD_VAR 0 1
4330: PPUSH
4331: CALL_OW 248
4335: PUSH
4336: LD_INT 0
4338: PUSH
4339: LD_INT 1
4341: PUSH
4342: LD_INT 3
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: LIST
4349: IN
4350: OR
4351: IFFALSE 4362
// KillUnit ( un ) ;
4353: LD_VAR 0 1
4357: PPUSH
4358: CALL_OW 66
// end ; end ;
4362: PPOPN 1
4364: END
// every 0 0$1 do
4365: GO 4367
4367: DISABLE
// begin enable ;
4368: ENABLE
// CheckBuildUpArea ( zoneOut , zoneIn , [ f_side , your_side ] ) ;
4369: LD_INT 4
4371: PPUSH
4372: LD_INT 5
4374: PPUSH
4375: LD_INT 22
4377: PUSH
4378: LD_OWVAR 2
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PPUSH
4387: CALL_OW 513
// end ;
4391: END
// every 0 0$01 trigger game_started and FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) = 0 do
4392: LD_EXP 7
4396: PUSH
4397: LD_INT 22
4399: PUSH
4400: LD_OWVAR 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 21
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PPUSH
4423: CALL_OW 69
4427: PUSH
4428: LD_INT 0
4430: EQUAL
4431: AND
4432: IFFALSE 4444
4434: GO 4436
4436: DISABLE
// YouLost ( die ) ;
4437: LD_STRING die
4439: PPUSH
4440: CALL_OW 104
4444: END
// every 0 0$21 trigger tick <= 15 15$00 do
4445: LD_OWVAR 1
4449: PUSH
4450: LD_INT 31500
4452: LESSEQUAL
4453: IFFALSE 4480
4455: GO 4457
4457: DISABLE
// begin enable ;
4458: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4459: LD_INT 1
4461: PPUSH
4462: LD_INT 5
4464: PPUSH
4465: CALL_OW 12
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 1
4475: PPUSH
4476: CALL_OW 55
// end ;
4480: END
// every 0 0$51 trigger tick > 15 15$00 do
4481: LD_OWVAR 1
4485: PUSH
4486: LD_INT 31500
4488: GREATER
4489: IFFALSE 4536
4491: GO 4493
4493: DISABLE
// begin enable ;
4494: ENABLE
// if FilterAllUnits ( [ f_side , 7 ] ) = 0 then
4495: LD_INT 22
4497: PUSH
4498: LD_INT 7
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PPUSH
4505: CALL_OW 69
4509: PUSH
4510: LD_INT 0
4512: EQUAL
4513: IFFALSE 4536
// CreateCratesArea ( Rand ( 1 , 5 ) , cratesSpawn , true ) ;
4515: LD_INT 1
4517: PPUSH
4518: LD_INT 5
4520: PPUSH
4521: CALL_OW 12
4525: PPUSH
4526: LD_INT 3
4528: PPUSH
4529: LD_INT 1
4531: PPUSH
4532: CALL_OW 55
// end ;
4536: END
// on BuildingStarted ( building , builder ) do begin if IsInArea ( building , cratesSpawn ) then
4537: LD_VAR 0 1
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: CALL_OW 308
4549: IFFALSE 4560
// KillUnit ( building ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: CALL_OW 66
// end ;
4560: PPOPN 2
4562: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4563: LD_VAR 0 1
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_VAR 0 3
4577: PPUSH
4578: CALL 16089 0 3
// end ;
4582: PPOPN 3
4584: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4585: LD_VAR 0 1
4589: PPUSH
4590: CALL 16187 0 1
// end ; end_of_file
4594: PPOPN 1
4596: END
// export function PrepareWave ( num ) ; var i , un , skill , veh , area , a , l , c ; begin
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
4605: PPUSH
4606: PPUSH
4607: PPUSH
// area := [ Enemy1 , Enemy2 ] ;
4608: LD_ADDR_VAR 0 7
4612: PUSH
4613: LD_INT 1
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: ST_TO_ADDR
// uc_side := 7 ;
4623: LD_ADDR_OWVAR 20
4627: PUSH
4628: LD_INT 7
4630: ST_TO_ADDR
// l := 0 ;
4631: LD_ADDR_VAR 0 9
4635: PUSH
4636: LD_INT 0
4638: ST_TO_ADDR
// case num of 1 :
4639: LD_VAR 0 1
4643: PUSH
4644: LD_INT 1
4646: DOUBLE
4647: EQUAL
4648: IFTRUE 4652
4650: GO 4671
4652: POP
// result := Wave1 ( 12 , 1 ) ; 2 :
4653: LD_ADDR_VAR 0 2
4657: PUSH
4658: LD_INT 12
4660: PPUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL 7000 0 2
4668: ST_TO_ADDR
4669: GO 6809
4671: LD_INT 2
4673: DOUBLE
4674: EQUAL
4675: IFTRUE 4679
4677: GO 4698
4679: POP
// result := Wave2 ( 12 , 1 ) ; 3 :
4680: LD_ADDR_VAR 0 2
4684: PUSH
4685: LD_INT 12
4687: PPUSH
4688: LD_INT 1
4690: PPUSH
4691: CALL 7071 0 2
4695: ST_TO_ADDR
4696: GO 6809
4698: LD_INT 3
4700: DOUBLE
4701: EQUAL
4702: IFTRUE 4706
4704: GO 4725
4706: POP
// result := Wave3 ( 12 , 1 ) ; 4 :
4707: LD_ADDR_VAR 0 2
4711: PUSH
4712: LD_INT 12
4714: PPUSH
4715: LD_INT 1
4717: PPUSH
4718: CALL 7142 0 2
4722: ST_TO_ADDR
4723: GO 6809
4725: LD_INT 4
4727: DOUBLE
4728: EQUAL
4729: IFTRUE 4733
4731: GO 4752
4733: POP
// result := Wave4 ( 7 , 1 ) ; 5 :
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 7
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL 7221 0 2
4749: ST_TO_ADDR
4750: GO 6809
4752: LD_INT 5
4754: DOUBLE
4755: EQUAL
4756: IFTRUE 4760
4758: GO 4779
4760: POP
// result := Wave5 ( 7 , 1 ) ; 6 :
4761: LD_ADDR_VAR 0 2
4765: PUSH
4766: LD_INT 7
4768: PPUSH
4769: LD_INT 1
4771: PPUSH
4772: CALL 7617 0 2
4776: ST_TO_ADDR
4777: GO 6809
4779: LD_INT 6
4781: DOUBLE
4782: EQUAL
4783: IFTRUE 4787
4785: GO 4806
4787: POP
// result := Wave6 ( 6 , 1 ) ; 7 :
4788: LD_ADDR_VAR 0 2
4792: PUSH
4793: LD_INT 6
4795: PPUSH
4796: LD_INT 1
4798: PPUSH
4799: CALL 8037 0 2
4803: ST_TO_ADDR
4804: GO 6809
4806: LD_INT 7
4808: DOUBLE
4809: EQUAL
4810: IFTRUE 4814
4812: GO 4833
4814: POP
// result := Wave7 ( 15 , 1 ) ; 8 :
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: LD_INT 15
4822: PPUSH
4823: LD_INT 1
4825: PPUSH
4826: CALL 8457 0 2
4830: ST_TO_ADDR
4831: GO 6809
4833: LD_INT 8
4835: DOUBLE
4836: EQUAL
4837: IFTRUE 4841
4839: GO 4860
4841: POP
// result := Wave8 ( 7 , 1 ) ; 9 :
4842: LD_ADDR_VAR 0 2
4846: PUSH
4847: LD_INT 7
4849: PPUSH
4850: LD_INT 1
4852: PPUSH
4853: CALL 8558 0 2
4857: ST_TO_ADDR
4858: GO 6809
4860: LD_INT 9
4862: DOUBLE
4863: EQUAL
4864: IFTRUE 4868
4866: GO 4899
4868: POP
// result := Wave8 ( 4 , 1 ) ^ Wave5 ( 7 , 1 ) ; 10 :
4869: LD_ADDR_VAR 0 2
4873: PUSH
4874: LD_INT 4
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: CALL 8558 0 2
4884: PUSH
4885: LD_INT 7
4887: PPUSH
4888: LD_INT 1
4890: PPUSH
4891: CALL 7617 0 2
4895: ADD
4896: ST_TO_ADDR
4897: GO 6809
4899: LD_INT 10
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4938
4907: POP
// result := Wave7 ( 9 , 1 ) ^ Wave3 ( 14 , 1 ) ; 11 , 21 , 31 , 41 , 51 , 61 , 71 , 81 , 91 :
4908: LD_ADDR_VAR 0 2
4912: PUSH
4913: LD_INT 9
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: CALL 8457 0 2
4923: PUSH
4924: LD_INT 14
4926: PPUSH
4927: LD_INT 1
4929: PPUSH
4930: CALL 7142 0 2
4934: ADD
4935: ST_TO_ADDR
4936: GO 6809
4938: LD_INT 11
4940: DOUBLE
4941: EQUAL
4942: IFTRUE 4994
4944: LD_INT 21
4946: DOUBLE
4947: EQUAL
4948: IFTRUE 4994
4950: LD_INT 31
4952: DOUBLE
4953: EQUAL
4954: IFTRUE 4994
4956: LD_INT 41
4958: DOUBLE
4959: EQUAL
4960: IFTRUE 4994
4962: LD_INT 51
4964: DOUBLE
4965: EQUAL
4966: IFTRUE 4994
4968: LD_INT 61
4970: DOUBLE
4971: EQUAL
4972: IFTRUE 4994
4974: LD_INT 71
4976: DOUBLE
4977: EQUAL
4978: IFTRUE 4994
4980: LD_INT 81
4982: DOUBLE
4983: EQUAL
4984: IFTRUE 4994
4986: LD_INT 91
4988: DOUBLE
4989: EQUAL
4990: IFTRUE 4994
4992: GO 5103
4994: POP
// result := Wave1 ( [ 20 , 30 , 40 , 45 , 50 , 60 , 70 , 80 , 100 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 12 , 22 , 32 , 42 , 52 , 62 , 72 , 82 , 92 :
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: LD_INT 20
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 40
5008: PUSH
5009: LD_INT 45
5011: PUSH
5012: LD_INT 50
5014: PUSH
5015: LD_INT 60
5017: PUSH
5018: LD_INT 70
5020: PUSH
5021: LD_INT 80
5023: PUSH
5024: LD_INT 100
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: LD_VAR 0 1
5042: PUSH
5043: LD_INT 10
5045: DIV
5046: ARRAY
5047: PPUSH
5048: LD_INT 2
5050: PUSH
5051: LD_INT 3
5053: PUSH
5054: LD_INT 4
5056: PUSH
5057: LD_INT 5
5059: PUSH
5060: LD_INT 6
5062: PUSH
5063: LD_INT 7
5065: PUSH
5066: LD_INT 8
5068: PUSH
5069: LD_INT 9
5071: PUSH
5072: LD_INT 10
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: PUSH
5086: LD_VAR 0 1
5090: PUSH
5091: LD_INT 10
5093: DIV
5094: ARRAY
5095: PPUSH
5096: CALL 7000 0 2
5100: ST_TO_ADDR
5101: GO 6809
5103: LD_INT 12
5105: DOUBLE
5106: EQUAL
5107: IFTRUE 5159
5109: LD_INT 22
5111: DOUBLE
5112: EQUAL
5113: IFTRUE 5159
5115: LD_INT 32
5117: DOUBLE
5118: EQUAL
5119: IFTRUE 5159
5121: LD_INT 42
5123: DOUBLE
5124: EQUAL
5125: IFTRUE 5159
5127: LD_INT 52
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5159
5133: LD_INT 62
5135: DOUBLE
5136: EQUAL
5137: IFTRUE 5159
5139: LD_INT 72
5141: DOUBLE
5142: EQUAL
5143: IFTRUE 5159
5145: LD_INT 82
5147: DOUBLE
5148: EQUAL
5149: IFTRUE 5159
5151: LD_INT 92
5153: DOUBLE
5154: EQUAL
5155: IFTRUE 5159
5157: GO 5268
5159: POP
// result := Wave2 ( [ 16 , 21 , 28 , 33 , 39 , 46 , 56 , 66 , 80 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 13 , 23 , 33 , 43 , 53 , 63 , 73 , 83 , 93 :
5160: LD_ADDR_VAR 0 2
5164: PUSH
5165: LD_INT 16
5167: PUSH
5168: LD_INT 21
5170: PUSH
5171: LD_INT 28
5173: PUSH
5174: LD_INT 33
5176: PUSH
5177: LD_INT 39
5179: PUSH
5180: LD_INT 46
5182: PUSH
5183: LD_INT 56
5185: PUSH
5186: LD_INT 66
5188: PUSH
5189: LD_INT 80
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_VAR 0 1
5207: PUSH
5208: LD_INT 10
5210: DIV
5211: ARRAY
5212: PPUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: LD_INT 4
5221: PUSH
5222: LD_INT 5
5224: PUSH
5225: LD_INT 6
5227: PUSH
5228: LD_INT 7
5230: PUSH
5231: LD_INT 8
5233: PUSH
5234: LD_INT 9
5236: PUSH
5237: LD_INT 10
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PUSH
5251: LD_VAR 0 1
5255: PUSH
5256: LD_INT 10
5258: DIV
5259: ARRAY
5260: PPUSH
5261: CALL 7071 0 2
5265: ST_TO_ADDR
5266: GO 6809
5268: LD_INT 13
5270: DOUBLE
5271: EQUAL
5272: IFTRUE 5324
5274: LD_INT 23
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5324
5280: LD_INT 33
5282: DOUBLE
5283: EQUAL
5284: IFTRUE 5324
5286: LD_INT 43
5288: DOUBLE
5289: EQUAL
5290: IFTRUE 5324
5292: LD_INT 53
5294: DOUBLE
5295: EQUAL
5296: IFTRUE 5324
5298: LD_INT 63
5300: DOUBLE
5301: EQUAL
5302: IFTRUE 5324
5304: LD_INT 73
5306: DOUBLE
5307: EQUAL
5308: IFTRUE 5324
5310: LD_INT 83
5312: DOUBLE
5313: EQUAL
5314: IFTRUE 5324
5316: LD_INT 93
5318: DOUBLE
5319: EQUAL
5320: IFTRUE 5324
5322: GO 5433
5324: POP
// result := Wave3 ( [ 14 , 18 , 22 , 27 , 33 , 39 , 44 , 57 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 14 , 24 , 34 , 44 , 54 , 64 , 74 , 84 , 94 :
5325: LD_ADDR_VAR 0 2
5329: PUSH
5330: LD_INT 14
5332: PUSH
5333: LD_INT 18
5335: PUSH
5336: LD_INT 22
5338: PUSH
5339: LD_INT 27
5341: PUSH
5342: LD_INT 33
5344: PUSH
5345: LD_INT 39
5347: PUSH
5348: LD_INT 44
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: LD_INT 65
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PUSH
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 10
5375: DIV
5376: ARRAY
5377: PPUSH
5378: LD_INT 2
5380: PUSH
5381: LD_INT 3
5383: PUSH
5384: LD_INT 4
5386: PUSH
5387: LD_INT 5
5389: PUSH
5390: LD_INT 6
5392: PUSH
5393: LD_INT 7
5395: PUSH
5396: LD_INT 8
5398: PUSH
5399: LD_INT 9
5401: PUSH
5402: LD_INT 10
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: LIST
5415: PUSH
5416: LD_VAR 0 1
5420: PUSH
5421: LD_INT 10
5423: DIV
5424: ARRAY
5425: PPUSH
5426: CALL 7142 0 2
5430: ST_TO_ADDR
5431: GO 6809
5433: LD_INT 14
5435: DOUBLE
5436: EQUAL
5437: IFTRUE 5489
5439: LD_INT 24
5441: DOUBLE
5442: EQUAL
5443: IFTRUE 5489
5445: LD_INT 34
5447: DOUBLE
5448: EQUAL
5449: IFTRUE 5489
5451: LD_INT 44
5453: DOUBLE
5454: EQUAL
5455: IFTRUE 5489
5457: LD_INT 54
5459: DOUBLE
5460: EQUAL
5461: IFTRUE 5489
5463: LD_INT 64
5465: DOUBLE
5466: EQUAL
5467: IFTRUE 5489
5469: LD_INT 74
5471: DOUBLE
5472: EQUAL
5473: IFTRUE 5489
5475: LD_INT 84
5477: DOUBLE
5478: EQUAL
5479: IFTRUE 5489
5481: LD_INT 94
5483: DOUBLE
5484: EQUAL
5485: IFTRUE 5489
5487: GO 5598
5489: POP
// result := Wave4 ( [ 9 , 15 , 22 , 30 , 39 , 45 , 56 , 60 , 65 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 15 , 25 , 35 , 45 , 55 , 65 , 75 , 85 , 95 :
5490: LD_ADDR_VAR 0 2
5494: PUSH
5495: LD_INT 9
5497: PUSH
5498: LD_INT 15
5500: PUSH
5501: LD_INT 22
5503: PUSH
5504: LD_INT 30
5506: PUSH
5507: LD_INT 39
5509: PUSH
5510: LD_INT 45
5512: PUSH
5513: LD_INT 56
5515: PUSH
5516: LD_INT 60
5518: PUSH
5519: LD_INT 65
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_VAR 0 1
5537: PUSH
5538: LD_INT 10
5540: DIV
5541: ARRAY
5542: PPUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: LD_INT 4
5551: PUSH
5552: LD_INT 5
5554: PUSH
5555: LD_INT 6
5557: PUSH
5558: LD_INT 7
5560: PUSH
5561: LD_INT 8
5563: PUSH
5564: LD_INT 9
5566: PUSH
5567: LD_INT 10
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: LIST
5580: PUSH
5581: LD_VAR 0 1
5585: PUSH
5586: LD_INT 10
5588: DIV
5589: ARRAY
5590: PPUSH
5591: CALL 7221 0 2
5595: ST_TO_ADDR
5596: GO 6809
5598: LD_INT 15
5600: DOUBLE
5601: EQUAL
5602: IFTRUE 5654
5604: LD_INT 25
5606: DOUBLE
5607: EQUAL
5608: IFTRUE 5654
5610: LD_INT 35
5612: DOUBLE
5613: EQUAL
5614: IFTRUE 5654
5616: LD_INT 45
5618: DOUBLE
5619: EQUAL
5620: IFTRUE 5654
5622: LD_INT 55
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5654
5628: LD_INT 65
5630: DOUBLE
5631: EQUAL
5632: IFTRUE 5654
5634: LD_INT 75
5636: DOUBLE
5637: EQUAL
5638: IFTRUE 5654
5640: LD_INT 85
5642: DOUBLE
5643: EQUAL
5644: IFTRUE 5654
5646: LD_INT 95
5648: DOUBLE
5649: EQUAL
5650: IFTRUE 5654
5652: GO 5763
5654: POP
// result := Wave5 ( [ 6 , 11 , 15 , 20 , 25 , 30 , 35 , 40 , 45 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 16 , 26 , 36 , 46 , 56 , 66 , 76 , 86 , 96 :
5655: LD_ADDR_VAR 0 2
5659: PUSH
5660: LD_INT 6
5662: PUSH
5663: LD_INT 11
5665: PUSH
5666: LD_INT 15
5668: PUSH
5669: LD_INT 20
5671: PUSH
5672: LD_INT 25
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 35
5680: PUSH
5681: LD_INT 40
5683: PUSH
5684: LD_INT 45
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_VAR 0 1
5702: PUSH
5703: LD_INT 10
5705: DIV
5706: ARRAY
5707: PPUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: LD_INT 4
5716: PUSH
5717: LD_INT 5
5719: PUSH
5720: LD_INT 6
5722: PUSH
5723: LD_INT 7
5725: PUSH
5726: LD_INT 8
5728: PUSH
5729: LD_INT 9
5731: PUSH
5732: LD_INT 10
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: LD_VAR 0 1
5750: PUSH
5751: LD_INT 10
5753: DIV
5754: ARRAY
5755: PPUSH
5756: CALL 7617 0 2
5760: ST_TO_ADDR
5761: GO 6809
5763: LD_INT 16
5765: DOUBLE
5766: EQUAL
5767: IFTRUE 5819
5769: LD_INT 26
5771: DOUBLE
5772: EQUAL
5773: IFTRUE 5819
5775: LD_INT 36
5777: DOUBLE
5778: EQUAL
5779: IFTRUE 5819
5781: LD_INT 46
5783: DOUBLE
5784: EQUAL
5785: IFTRUE 5819
5787: LD_INT 56
5789: DOUBLE
5790: EQUAL
5791: IFTRUE 5819
5793: LD_INT 66
5795: DOUBLE
5796: EQUAL
5797: IFTRUE 5819
5799: LD_INT 76
5801: DOUBLE
5802: EQUAL
5803: IFTRUE 5819
5805: LD_INT 86
5807: DOUBLE
5808: EQUAL
5809: IFTRUE 5819
5811: LD_INT 96
5813: DOUBLE
5814: EQUAL
5815: IFTRUE 5819
5817: GO 5928
5819: POP
// result := Wave6 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 17 , 27 , 37 , 47 , 57 , 67 , 77 , 87 , 97 :
5820: LD_ADDR_VAR 0 2
5824: PUSH
5825: LD_INT 9
5827: PUSH
5828: LD_INT 12
5830: PUSH
5831: LD_INT 15
5833: PUSH
5834: LD_INT 18
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 24
5842: PUSH
5843: LD_INT 27
5845: PUSH
5846: LD_INT 30
5848: PUSH
5849: LD_INT 33
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_VAR 0 1
5867: PUSH
5868: LD_INT 10
5870: DIV
5871: ARRAY
5872: PPUSH
5873: LD_INT 2
5875: PUSH
5876: LD_INT 3
5878: PUSH
5879: LD_INT 4
5881: PUSH
5882: LD_INT 5
5884: PUSH
5885: LD_INT 6
5887: PUSH
5888: LD_INT 7
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: LD_INT 9
5896: PUSH
5897: LD_INT 10
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: PUSH
5911: LD_VAR 0 1
5915: PUSH
5916: LD_INT 10
5918: DIV
5919: ARRAY
5920: PPUSH
5921: CALL 8037 0 2
5925: ST_TO_ADDR
5926: GO 6809
5928: LD_INT 17
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5984
5934: LD_INT 27
5936: DOUBLE
5937: EQUAL
5938: IFTRUE 5984
5940: LD_INT 37
5942: DOUBLE
5943: EQUAL
5944: IFTRUE 5984
5946: LD_INT 47
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5984
5952: LD_INT 57
5954: DOUBLE
5955: EQUAL
5956: IFTRUE 5984
5958: LD_INT 67
5960: DOUBLE
5961: EQUAL
5962: IFTRUE 5984
5964: LD_INT 77
5966: DOUBLE
5967: EQUAL
5968: IFTRUE 5984
5970: LD_INT 87
5972: DOUBLE
5973: EQUAL
5974: IFTRUE 5984
5976: LD_INT 97
5978: DOUBLE
5979: EQUAL
5980: IFTRUE 5984
5982: GO 6093
5984: POP
// result := Wave7 ( [ 14 , 16 , 18 , 22 , 24 , 26 , 28 , 32 , 35 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 18 , 28 , 38 , 48 , 58 , 68 , 78 , 88 , 98 :
5985: LD_ADDR_VAR 0 2
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 16
5995: PUSH
5996: LD_INT 18
5998: PUSH
5999: LD_INT 22
6001: PUSH
6002: LD_INT 24
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 28
6010: PUSH
6011: LD_INT 32
6013: PUSH
6014: LD_INT 35
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: PUSH
6028: LD_VAR 0 1
6032: PUSH
6033: LD_INT 10
6035: DIV
6036: ARRAY
6037: PPUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 3
6043: PUSH
6044: LD_INT 4
6046: PUSH
6047: LD_INT 5
6049: PUSH
6050: LD_INT 6
6052: PUSH
6053: LD_INT 7
6055: PUSH
6056: LD_INT 8
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: LD_INT 10
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: LD_VAR 0 1
6080: PUSH
6081: LD_INT 10
6083: DIV
6084: ARRAY
6085: PPUSH
6086: CALL 8457 0 2
6090: ST_TO_ADDR
6091: GO 6809
6093: LD_INT 18
6095: DOUBLE
6096: EQUAL
6097: IFTRUE 6149
6099: LD_INT 28
6101: DOUBLE
6102: EQUAL
6103: IFTRUE 6149
6105: LD_INT 38
6107: DOUBLE
6108: EQUAL
6109: IFTRUE 6149
6111: LD_INT 48
6113: DOUBLE
6114: EQUAL
6115: IFTRUE 6149
6117: LD_INT 58
6119: DOUBLE
6120: EQUAL
6121: IFTRUE 6149
6123: LD_INT 68
6125: DOUBLE
6126: EQUAL
6127: IFTRUE 6149
6129: LD_INT 78
6131: DOUBLE
6132: EQUAL
6133: IFTRUE 6149
6135: LD_INT 88
6137: DOUBLE
6138: EQUAL
6139: IFTRUE 6149
6141: LD_INT 98
6143: DOUBLE
6144: EQUAL
6145: IFTRUE 6149
6147: GO 6258
6149: POP
// result := Wave8 ( [ 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 19 , 29 , 39 , 49 , 59 , 69 , 79 , 89 , 99 :
6150: LD_ADDR_VAR 0 2
6154: PUSH
6155: LD_INT 9
6157: PUSH
6158: LD_INT 12
6160: PUSH
6161: LD_INT 15
6163: PUSH
6164: LD_INT 18
6166: PUSH
6167: LD_INT 21
6169: PUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 27
6175: PUSH
6176: LD_INT 30
6178: PUSH
6179: LD_INT 33
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: LD_VAR 0 1
6197: PUSH
6198: LD_INT 10
6200: DIV
6201: ARRAY
6202: PPUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 3
6208: PUSH
6209: LD_INT 4
6211: PUSH
6212: LD_INT 5
6214: PUSH
6215: LD_INT 6
6217: PUSH
6218: LD_INT 7
6220: PUSH
6221: LD_INT 8
6223: PUSH
6224: LD_INT 9
6226: PUSH
6227: LD_INT 10
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_VAR 0 1
6245: PUSH
6246: LD_INT 10
6248: DIV
6249: ARRAY
6250: PPUSH
6251: CALL 8558 0 2
6255: ST_TO_ADDR
6256: GO 6809
6258: LD_INT 19
6260: DOUBLE
6261: EQUAL
6262: IFTRUE 6314
6264: LD_INT 29
6266: DOUBLE
6267: EQUAL
6268: IFTRUE 6314
6270: LD_INT 39
6272: DOUBLE
6273: EQUAL
6274: IFTRUE 6314
6276: LD_INT 49
6278: DOUBLE
6279: EQUAL
6280: IFTRUE 6314
6282: LD_INT 59
6284: DOUBLE
6285: EQUAL
6286: IFTRUE 6314
6288: LD_INT 69
6290: DOUBLE
6291: EQUAL
6292: IFTRUE 6314
6294: LD_INT 79
6296: DOUBLE
6297: EQUAL
6298: IFTRUE 6314
6300: LD_INT 89
6302: DOUBLE
6303: EQUAL
6304: IFTRUE 6314
6306: LD_INT 99
6308: DOUBLE
6309: EQUAL
6310: IFTRUE 6314
6312: GO 6525
6314: POP
// result := Wave8 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ^ Wave5 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num div 10 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num div 10 ] ) ; 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 :
6315: LD_ADDR_VAR 0 2
6319: PUSH
6320: LD_INT 4
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: LD_INT 10
6328: PUSH
6329: LD_INT 13
6331: PUSH
6332: LD_INT 14
6334: PUSH
6335: LD_INT 17
6337: PUSH
6338: LD_INT 19
6340: PUSH
6341: LD_INT 21
6343: PUSH
6344: LD_INT 23
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_VAR 0 1
6362: PUSH
6363: LD_INT 10
6365: DIV
6366: ARRAY
6367: PPUSH
6368: LD_INT 2
6370: PUSH
6371: LD_INT 3
6373: PUSH
6374: LD_INT 4
6376: PUSH
6377: LD_INT 5
6379: PUSH
6380: LD_INT 6
6382: PUSH
6383: LD_INT 7
6385: PUSH
6386: LD_INT 8
6388: PUSH
6389: LD_INT 9
6391: PUSH
6392: LD_INT 10
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_VAR 0 1
6410: PUSH
6411: LD_INT 10
6413: DIV
6414: ARRAY
6415: PPUSH
6416: CALL 8558 0 2
6420: PUSH
6421: LD_INT 4
6423: PUSH
6424: LD_INT 7
6426: PUSH
6427: LD_INT 10
6429: PUSH
6430: LD_INT 13
6432: PUSH
6433: LD_INT 14
6435: PUSH
6436: LD_INT 17
6438: PUSH
6439: LD_INT 19
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_INT 25
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: PUSH
6459: LD_VAR 0 1
6463: PUSH
6464: LD_INT 10
6466: DIV
6467: ARRAY
6468: PPUSH
6469: LD_INT 2
6471: PUSH
6472: LD_INT 3
6474: PUSH
6475: LD_INT 4
6477: PUSH
6478: LD_INT 5
6480: PUSH
6481: LD_INT 6
6483: PUSH
6484: LD_INT 7
6486: PUSH
6487: LD_INT 8
6489: PUSH
6490: LD_INT 9
6492: PUSH
6493: LD_INT 10
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_VAR 0 1
6511: PUSH
6512: LD_INT 10
6514: DIV
6515: ARRAY
6516: PPUSH
6517: CALL 7617 0 2
6521: ADD
6522: ST_TO_ADDR
6523: GO 6809
6525: LD_INT 20
6527: DOUBLE
6528: EQUAL
6529: IFTRUE 6581
6531: LD_INT 30
6533: DOUBLE
6534: EQUAL
6535: IFTRUE 6581
6537: LD_INT 40
6539: DOUBLE
6540: EQUAL
6541: IFTRUE 6581
6543: LD_INT 50
6545: DOUBLE
6546: EQUAL
6547: IFTRUE 6581
6549: LD_INT 60
6551: DOUBLE
6552: EQUAL
6553: IFTRUE 6581
6555: LD_INT 70
6557: DOUBLE
6558: EQUAL
6559: IFTRUE 6581
6561: LD_INT 80
6563: DOUBLE
6564: EQUAL
6565: IFTRUE 6581
6567: LD_INT 90
6569: DOUBLE
6570: EQUAL
6571: IFTRUE 6581
6573: LD_INT 100
6575: DOUBLE
6576: EQUAL
6577: IFTRUE 6581
6579: GO 6808
6581: POP
// result := Wave7 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 21 , 23 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ^ Wave6 ( [ 4 , 7 , 10 , 13 , 14 , 17 , 19 , 22 , 25 ] [ num / 10 - 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] [ num / 10 - 1 ] ) ; end ;
6582: LD_ADDR_VAR 0 2
6586: PUSH
6587: LD_INT 4
6589: PUSH
6590: LD_INT 7
6592: PUSH
6593: LD_INT 10
6595: PUSH
6596: LD_INT 13
6598: PUSH
6599: LD_INT 14
6601: PUSH
6602: LD_INT 17
6604: PUSH
6605: LD_INT 19
6607: PUSH
6608: LD_INT 21
6610: PUSH
6611: LD_INT 23
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: PUSH
6625: LD_VAR 0 1
6629: PUSH
6630: LD_INT 10
6632: DIVREAL
6633: PUSH
6634: LD_INT 1
6636: MINUS
6637: ARRAY
6638: PPUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 3
6644: PUSH
6645: LD_INT 4
6647: PUSH
6648: LD_INT 5
6650: PUSH
6651: LD_INT 6
6653: PUSH
6654: LD_INT 7
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: LD_INT 9
6662: PUSH
6663: LD_INT 10
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: LD_VAR 0 1
6681: PUSH
6682: LD_INT 10
6684: DIVREAL
6685: PUSH
6686: LD_INT 1
6688: MINUS
6689: ARRAY
6690: PPUSH
6691: CALL 8457 0 2
6695: PUSH
6696: LD_INT 4
6698: PUSH
6699: LD_INT 7
6701: PUSH
6702: LD_INT 10
6704: PUSH
6705: LD_INT 13
6707: PUSH
6708: LD_INT 14
6710: PUSH
6711: LD_INT 17
6713: PUSH
6714: LD_INT 19
6716: PUSH
6717: LD_INT 22
6719: PUSH
6720: LD_INT 25
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_VAR 0 1
6738: PUSH
6739: LD_INT 10
6741: DIVREAL
6742: PUSH
6743: LD_INT 1
6745: MINUS
6746: ARRAY
6747: PPUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 3
6753: PUSH
6754: LD_INT 4
6756: PUSH
6757: LD_INT 5
6759: PUSH
6760: LD_INT 6
6762: PUSH
6763: LD_INT 7
6765: PUSH
6766: LD_INT 8
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: LD_INT 10
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_VAR 0 1
6790: PUSH
6791: LD_INT 10
6793: DIVREAL
6794: PUSH
6795: LD_INT 1
6797: MINUS
6798: ARRAY
6799: PPUSH
6800: CALL 8037 0 2
6804: ADD
6805: ST_TO_ADDR
6806: GO 6809
6808: POP
// for i in result do
6809: LD_ADDR_VAR 0 3
6813: PUSH
6814: LD_VAR 0 2
6818: PUSH
6819: FOR_IN
6820: IFFALSE 6993
// begin a := rand ( 1 , 2 ) ;
6822: LD_ADDR_VAR 0 8
6826: PUSH
6827: LD_INT 1
6829: PPUSH
6830: LD_INT 2
6832: PPUSH
6833: CALL_OW 12
6837: ST_TO_ADDR
// if a = 1 then
6838: LD_VAR 0 8
6842: PUSH
6843: LD_INT 1
6845: EQUAL
6846: IFFALSE 6862
// SetDir ( i , 3 ) else
6848: LD_VAR 0 3
6852: PPUSH
6853: LD_INT 3
6855: PPUSH
6856: CALL_OW 233
6860: GO 6874
// SetDir ( i , 5 ) ;
6862: LD_VAR 0 3
6866: PPUSH
6867: LD_INT 5
6869: PPUSH
6870: CALL_OW 233
// PlaceUnitArea ( i , area [ a ] , false ) ;
6874: LD_VAR 0 3
6878: PPUSH
6879: LD_VAR 0 7
6883: PUSH
6884: LD_VAR 0 8
6888: ARRAY
6889: PPUSH
6890: LD_INT 0
6892: PPUSH
6893: CALL_OW 49
// if GetControl ( i ) = control_manual then
6897: LD_VAR 0 3
6901: PPUSH
6902: CALL_OW 263
6906: PUSH
6907: LD_INT 1
6909: EQUAL
6910: IFFALSE 6956
// begin uc_nation := GetNation ( i ) ;
6912: LD_ADDR_OWVAR 21
6916: PUSH
6917: LD_VAR 0 3
6921: PPUSH
6922: CALL_OW 248
6926: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
6927: LD_INT 0
6929: PPUSH
6930: LD_INT 3
6932: PPUSH
6933: LD_VAR 0 5
6937: PPUSH
6938: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
6942: CALL_OW 44
6946: PPUSH
6947: LD_VAR 0 3
6951: PPUSH
6952: CALL_OW 52
// end ; l := l + 1 ;
6956: LD_ADDR_VAR 0 9
6960: PUSH
6961: LD_VAR 0 9
6965: PUSH
6966: LD_INT 1
6968: PLUS
6969: ST_TO_ADDR
// if l mod 10 = 0 then
6970: LD_VAR 0 9
6974: PUSH
6975: LD_INT 10
6977: MOD
6978: PUSH
6979: LD_INT 0
6981: EQUAL
6982: IFFALSE 6991
// Wait ( 0 0$02 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6819
6993: POP
6994: POP
// end ;
6995: LD_VAR 0 2
6999: RET
// export function Wave1 ( n , skill ) ; var i , un ; begin
7000: LD_INT 0
7002: PPUSH
7003: PPUSH
7004: PPUSH
// uc_nation := nation_nature ;
7005: LD_ADDR_OWVAR 21
7009: PUSH
7010: LD_INT 0
7012: ST_TO_ADDR
// for i = 1 to n do
7013: LD_ADDR_VAR 0 4
7017: PUSH
7018: DOUBLE
7019: LD_INT 1
7021: DEC
7022: ST_TO_ADDR
7023: LD_VAR 0 1
7027: PUSH
7028: FOR_TO
7029: IFFALSE 7064
// begin PrepareHuman ( false , class_apeman , skill ) ;
7031: LD_INT 0
7033: PPUSH
7034: LD_INT 12
7036: PPUSH
7037: LD_VAR 0 2
7041: PPUSH
7042: CALL_OW 380
// result := result ^ CreateHuman ;
7046: LD_ADDR_VAR 0 3
7050: PUSH
7051: LD_VAR 0 3
7055: PUSH
7056: CALL_OW 44
7060: ADD
7061: ST_TO_ADDR
// end ;
7062: GO 7028
7064: POP
7065: POP
// end ;
7066: LD_VAR 0 3
7070: RET
// export function Wave2 ( n , skill ) ; var i , un ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
// uc_nation := nation_nature ;
7076: LD_ADDR_OWVAR 21
7080: PUSH
7081: LD_INT 0
7083: ST_TO_ADDR
// for i = 1 to n do
7084: LD_ADDR_VAR 0 4
7088: PUSH
7089: DOUBLE
7090: LD_INT 1
7092: DEC
7093: ST_TO_ADDR
7094: LD_VAR 0 1
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7135
// begin PrepareHuman ( false , class_apeman_soldier , skill ) ;
7102: LD_INT 0
7104: PPUSH
7105: LD_INT 15
7107: PPUSH
7108: LD_VAR 0 2
7112: PPUSH
7113: CALL_OW 380
// result := result ^ CreateHuman ;
7117: LD_ADDR_VAR 0 3
7121: PUSH
7122: LD_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ADD
7132: ST_TO_ADDR
// end ;
7133: GO 7099
7135: POP
7136: POP
// end ;
7137: LD_VAR 0 3
7141: RET
// export function Wave3 ( n , skill ) ; var i , un ; begin
7142: LD_INT 0
7144: PPUSH
7145: PPUSH
7146: PPUSH
// for i = 1 to n do
7147: LD_ADDR_VAR 0 4
7151: PUSH
7152: DOUBLE
7153: LD_INT 1
7155: DEC
7156: ST_TO_ADDR
7157: LD_VAR 0 1
7161: PUSH
7162: FOR_TO
7163: IFFALSE 7214
// begin uc_nation := rand ( 1 , 3 ) ;
7165: LD_ADDR_OWVAR 21
7169: PUSH
7170: LD_INT 1
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: CALL_OW 12
7180: ST_TO_ADDR
// PrepareHuman ( false , class_soldier , skill ) ;
7181: LD_INT 0
7183: PPUSH
7184: LD_INT 1
7186: PPUSH
7187: LD_VAR 0 2
7191: PPUSH
7192: CALL_OW 380
// result := result ^ CreateHuman ;
7196: LD_ADDR_VAR 0 3
7200: PUSH
7201: LD_VAR 0 3
7205: PUSH
7206: CALL_OW 44
7210: ADD
7211: ST_TO_ADDR
// end ;
7212: GO 7162
7214: POP
7215: POP
// end ;
7216: LD_VAR 0 3
7220: RET
// export function Wave4 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7221: LD_INT 0
7223: PPUSH
7224: PPUSH
7225: PPUSH
7226: PPUSH
7227: PPUSH
7228: PPUSH
7229: PPUSH
// for i = 1 to n do
7230: LD_ADDR_VAR 0 4
7234: PUSH
7235: DOUBLE
7236: LD_INT 1
7238: DEC
7239: ST_TO_ADDR
7240: LD_VAR 0 1
7244: PUSH
7245: FOR_TO
7246: IFFALSE 7610
// begin uc_nation := rand ( 1 , 3 ) ;
7248: LD_ADDR_OWVAR 21
7252: PUSH
7253: LD_INT 1
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 12
7263: ST_TO_ADDR
// case uc_nation of 1 :
7264: LD_OWVAR 21
7268: PUSH
7269: LD_INT 1
7271: DOUBLE
7272: EQUAL
7273: IFTRUE 7277
7275: GO 7340
7277: POP
// begin chassis := [ us_light_wheeled , us_medium_wheeled ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: LD_INT 2
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: ST_TO_ADDR
// weapons := [ us_machine_gun , us_light_gun ] ;
7293: LD_ADDR_VAR 0 7
7297: PUSH
7298: LD_INT 2
7300: PUSH
7301: LD_INT 3
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7308: LD_ADDR_VAR 0 8
7312: PUSH
7313: LD_INT 1
7315: PUSH
7316: LD_INT 3
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7323: LD_ADDR_VAR 0 9
7327: PUSH
7328: LD_INT 1
7330: PUSH
7331: LD_INT 2
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: ST_TO_ADDR
// end ; 2 :
7338: GO 7475
7340: LD_INT 2
7342: DOUBLE
7343: EQUAL
7344: IFTRUE 7348
7346: GO 7411
7348: POP
// begin chassis := [ ar_light_trike , ar_hovercraft ] ;
7349: LD_ADDR_VAR 0 6
7353: PUSH
7354: LD_INT 12
7356: PUSH
7357: LD_INT 11
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: ST_TO_ADDR
// weapons := [ ar_light_gun , ar_double_machine_gun ] ;
7364: LD_ADDR_VAR 0 7
7368: PUSH
7369: LD_INT 23
7371: PUSH
7372: LD_INT 24
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7379: LD_ADDR_VAR 0 8
7383: PUSH
7384: LD_INT 1
7386: PUSH
7387: LD_INT 5
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar ] ;
7394: LD_ADDR_VAR 0 9
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: ST_TO_ADDR
// end ; 3 :
7409: GO 7475
7411: LD_INT 3
7413: DOUBLE
7414: EQUAL
7415: IFTRUE 7419
7417: GO 7474
7419: POP
// begin chassis := [ ru_medium_wheeled ] ;
7420: LD_ADDR_VAR 0 6
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: EMPTY
7429: LIST
7430: ST_TO_ADDR
// weapons := [ ru_heavy_machine_gun , ru_gun ] ;
7431: LD_ADDR_VAR 0 7
7435: PUSH
7436: LD_INT 42
7438: PUSH
7439: LD_INT 44
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7446: LD_ADDR_VAR 0 8
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 3
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: ST_TO_ADDR
// engine := [ engine_combustion ] ;
7461: LD_ADDR_VAR 0 9
7465: PUSH
7466: LD_INT 1
7468: PUSH
7469: EMPTY
7470: LIST
7471: ST_TO_ADDR
// end ; end ;
7472: GO 7475
7474: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7475: LD_ADDR_OWVAR 37
7479: PUSH
7480: LD_VAR 0 6
7484: PUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_VAR 0 6
7492: PPUSH
7493: CALL_OW 12
7497: ARRAY
7498: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7499: LD_ADDR_OWVAR 39
7503: PUSH
7504: LD_VAR 0 9
7508: PUSH
7509: LD_INT 1
7511: PPUSH
7512: LD_VAR 0 9
7516: PPUSH
7517: CALL_OW 12
7521: ARRAY
7522: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7523: LD_ADDR_OWVAR 38
7527: PUSH
7528: LD_VAR 0 8
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 12
7545: ARRAY
7546: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7547: LD_ADDR_OWVAR 40
7551: PUSH
7552: LD_VAR 0 7
7556: PUSH
7557: LD_INT 1
7559: PPUSH
7560: LD_VAR 0 7
7564: PPUSH
7565: CALL_OW 12
7569: ARRAY
7570: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7571: LD_ADDR_OWVAR 41
7575: PUSH
7576: LD_INT 100
7578: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7579: LD_ADDR_VAR 0 3
7583: PUSH
7584: LD_VAR 0 3
7588: PPUSH
7589: LD_VAR 0 3
7593: PUSH
7594: LD_INT 1
7596: PLUS
7597: PPUSH
7598: CALL_OW 45
7602: PPUSH
7603: CALL_OW 2
7607: ST_TO_ADDR
// end ;
7608: GO 7245
7610: POP
7611: POP
// end ;
7612: LD_VAR 0 3
7616: RET
// export function Wave5 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
// for i = 1 to n do
7626: LD_ADDR_VAR 0 4
7630: PUSH
7631: DOUBLE
7632: LD_INT 1
7634: DEC
7635: ST_TO_ADDR
7636: LD_VAR 0 1
7640: PUSH
7641: FOR_TO
7642: IFFALSE 8030
// begin uc_nation := rand ( 1 , 3 ) ;
7644: LD_ADDR_OWVAR 21
7648: PUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 3
7654: PPUSH
7655: CALL_OW 12
7659: ST_TO_ADDR
// case uc_nation of 1 :
7660: LD_OWVAR 21
7664: PUSH
7665: LD_INT 1
7667: DOUBLE
7668: EQUAL
7669: IFTRUE 7673
7671: GO 7744
7673: POP
// begin chassis := [ us_medium_wheeled , us_medium_tracked ] ;
7674: LD_ADDR_VAR 0 6
7678: PUSH
7679: LD_INT 2
7681: PUSH
7682: LD_INT 3
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_double_gun , us_laser ] ;
7689: LD_ADDR_VAR 0 7
7693: PUSH
7694: LD_INT 4
7696: PUSH
7697: LD_INT 5
7699: PUSH
7700: LD_INT 9
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7708: LD_ADDR_VAR 0 8
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7723: LD_ADDR_VAR 0 9
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 3
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: ST_TO_ADDR
// end ; 2 :
7742: GO 7895
7744: LD_INT 2
7746: DOUBLE
7747: EQUAL
7748: IFTRUE 7752
7750: GO 7823
7752: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
7753: LD_ADDR_VAR 0 6
7757: PUSH
7758: LD_INT 13
7760: PUSH
7761: LD_INT 14
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_gatling_gun ] ;
7768: LD_ADDR_VAR 0 7
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 26
7778: PUSH
7779: LD_INT 25
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
7787: LD_ADDR_VAR 0 8
7791: PUSH
7792: LD_INT 1
7794: PUSH
7795: LD_INT 5
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
7802: LD_ADDR_VAR 0 9
7806: PUSH
7807: LD_INT 1
7809: PUSH
7810: LD_INT 2
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: ST_TO_ADDR
// end ; 3 :
7821: GO 7895
7823: LD_INT 3
7825: DOUBLE
7826: EQUAL
7827: IFTRUE 7831
7829: GO 7894
7831: POP
// begin chassis := [ ru_medium_tracked , ru_medium_wheeled ] ;
7832: LD_ADDR_VAR 0 6
7836: PUSH
7837: LD_INT 22
7839: PUSH
7840: LD_INT 21
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: ST_TO_ADDR
// weapons := [ ru_gun , ru_gatling_gun ] ;
7847: LD_ADDR_VAR 0 7
7851: PUSH
7852: LD_INT 44
7854: PUSH
7855: LD_INT 43
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
7862: LD_ADDR_VAR 0 8
7866: PUSH
7867: LD_INT 1
7869: PUSH
7870: LD_INT 3
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
7877: LD_ADDR_VAR 0 9
7881: PUSH
7882: LD_INT 1
7884: PUSH
7885: LD_INT 3
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: ST_TO_ADDR
// end ; end ;
7892: GO 7895
7894: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
7895: LD_ADDR_OWVAR 37
7899: PUSH
7900: LD_VAR 0 6
7904: PUSH
7905: LD_INT 1
7907: PPUSH
7908: LD_VAR 0 6
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
7919: LD_ADDR_OWVAR 39
7923: PUSH
7924: LD_VAR 0 9
7928: PUSH
7929: LD_INT 1
7931: PPUSH
7932: LD_VAR 0 9
7936: PPUSH
7937: CALL_OW 12
7941: ARRAY
7942: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
7943: LD_ADDR_OWVAR 38
7947: PUSH
7948: LD_VAR 0 8
7952: PUSH
7953: LD_INT 1
7955: PPUSH
7956: LD_VAR 0 8
7960: PPUSH
7961: CALL_OW 12
7965: ARRAY
7966: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
7967: LD_ADDR_OWVAR 40
7971: PUSH
7972: LD_VAR 0 7
7976: PUSH
7977: LD_INT 1
7979: PPUSH
7980: LD_VAR 0 7
7984: PPUSH
7985: CALL_OW 12
7989: ARRAY
7990: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7991: LD_ADDR_OWVAR 41
7995: PUSH
7996: LD_INT 100
7998: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
7999: LD_ADDR_VAR 0 3
8003: PUSH
8004: LD_VAR 0 3
8008: PPUSH
8009: LD_VAR 0 3
8013: PUSH
8014: LD_INT 1
8016: PLUS
8017: PPUSH
8018: CALL_OW 45
8022: PPUSH
8023: CALL_OW 2
8027: ST_TO_ADDR
// end ;
8028: GO 7641
8030: POP
8031: POP
// end ;
8032: LD_VAR 0 3
8036: RET
// export function Wave6 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8037: LD_INT 0
8039: PPUSH
8040: PPUSH
8041: PPUSH
8042: PPUSH
8043: PPUSH
8044: PPUSH
8045: PPUSH
// for i = 1 to n do
8046: LD_ADDR_VAR 0 4
8050: PUSH
8051: DOUBLE
8052: LD_INT 1
8054: DEC
8055: ST_TO_ADDR
8056: LD_VAR 0 1
8060: PUSH
8061: FOR_TO
8062: IFFALSE 8450
// begin uc_nation := rand ( 1 , 3 ) ;
8064: LD_ADDR_OWVAR 21
8068: PUSH
8069: LD_INT 1
8071: PPUSH
8072: LD_INT 3
8074: PPUSH
8075: CALL_OW 12
8079: ST_TO_ADDR
// case uc_nation of 1 :
8080: LD_OWVAR 21
8084: PUSH
8085: LD_INT 1
8087: DOUBLE
8088: EQUAL
8089: IFTRUE 8093
8091: GO 8160
8093: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8094: LD_ADDR_VAR 0 6
8098: PUSH
8099: LD_INT 4
8101: PUSH
8102: LD_INT 5
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_laser ] ;
8109: LD_ADDR_VAR 0 7
8113: PUSH
8114: LD_INT 6
8116: PUSH
8117: LD_INT 7
8119: PUSH
8120: LD_INT 9
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8128: LD_ADDR_VAR 0 8
8132: PUSH
8133: LD_INT 1
8135: PUSH
8136: LD_INT 3
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8143: LD_ADDR_VAR 0 9
8147: PUSH
8148: LD_INT 1
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: ST_TO_ADDR
// end ; 2 :
8158: GO 8315
8160: LD_INT 2
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8243
8168: POP
// begin chassis := [ ar_medium_trike , ar_half_tracked ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: LD_INT 13
8176: PUSH
8177: LD_INT 14
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: ST_TO_ADDR
// weapons := [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8184: LD_ADDR_VAR 0 7
8188: PUSH
8189: LD_INT 27
8191: PUSH
8192: LD_INT 26
8194: PUSH
8195: LD_INT 28
8197: PUSH
8198: LD_INT 29
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8207: LD_ADDR_VAR 0 8
8211: PUSH
8212: LD_INT 1
8214: PUSH
8215: LD_INT 5
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8222: LD_ADDR_VAR 0 9
8226: PUSH
8227: LD_INT 1
8229: PUSH
8230: LD_INT 2
8232: PUSH
8233: LD_INT 3
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: LIST
8240: ST_TO_ADDR
// end ; 3 :
8241: GO 8315
8243: LD_INT 3
8245: DOUBLE
8246: EQUAL
8247: IFTRUE 8251
8249: GO 8314
8251: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8252: LD_ADDR_VAR 0 6
8256: PUSH
8257: LD_INT 23
8259: PUSH
8260: LD_INT 24
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher ] ;
8267: LD_ADDR_VAR 0 7
8271: PUSH
8272: LD_INT 46
8274: PUSH
8275: LD_INT 45
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8282: LD_ADDR_VAR 0 8
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: LD_INT 3
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8297: LD_ADDR_VAR 0 9
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 3
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: ST_TO_ADDR
// end ; end ;
8312: GO 8315
8314: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8315: LD_ADDR_OWVAR 37
8319: PUSH
8320: LD_VAR 0 6
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_VAR 0 6
8332: PPUSH
8333: CALL_OW 12
8337: ARRAY
8338: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8339: LD_ADDR_OWVAR 39
8343: PUSH
8344: LD_VAR 0 9
8348: PUSH
8349: LD_INT 1
8351: PPUSH
8352: LD_VAR 0 9
8356: PPUSH
8357: CALL_OW 12
8361: ARRAY
8362: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8363: LD_ADDR_OWVAR 38
8367: PUSH
8368: LD_VAR 0 8
8372: PUSH
8373: LD_INT 1
8375: PPUSH
8376: LD_VAR 0 8
8380: PPUSH
8381: CALL_OW 12
8385: ARRAY
8386: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8387: LD_ADDR_OWVAR 40
8391: PUSH
8392: LD_VAR 0 7
8396: PUSH
8397: LD_INT 1
8399: PPUSH
8400: LD_VAR 0 7
8404: PPUSH
8405: CALL_OW 12
8409: ARRAY
8410: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8411: LD_ADDR_OWVAR 41
8415: PUSH
8416: LD_INT 100
8418: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8419: LD_ADDR_VAR 0 3
8423: PUSH
8424: LD_VAR 0 3
8428: PPUSH
8429: LD_VAR 0 3
8433: PUSH
8434: LD_INT 1
8436: PLUS
8437: PPUSH
8438: CALL_OW 45
8442: PPUSH
8443: CALL_OW 2
8447: ST_TO_ADDR
// end ;
8448: GO 8061
8450: POP
8451: POP
// end ;
8452: LD_VAR 0 3
8456: RET
// export function Wave7 ( n , skill ) ; var i ; begin
8457: LD_INT 0
8459: PPUSH
8460: PPUSH
// for i = 1 to n do
8461: LD_ADDR_VAR 0 4
8465: PUSH
8466: DOUBLE
8467: LD_INT 1
8469: DEC
8470: ST_TO_ADDR
8471: LD_VAR 0 1
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8551
// begin uc_nation := rand ( 1 , 3 ) ;
8479: LD_ADDR_OWVAR 21
8483: PUSH
8484: LD_INT 1
8486: PPUSH
8487: LD_INT 3
8489: PPUSH
8490: CALL_OW 12
8494: ST_TO_ADDR
// PrepareHuman ( false , [ class_mortar , class_bazooker , class_soldier ] [ rand ( 1 , 3 ) ] , skill ) ;
8495: LD_INT 0
8497: PPUSH
8498: LD_INT 8
8500: PUSH
8501: LD_INT 9
8503: PUSH
8504: LD_INT 1
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 1
8514: PPUSH
8515: LD_INT 3
8517: PPUSH
8518: CALL_OW 12
8522: ARRAY
8523: PPUSH
8524: LD_VAR 0 2
8528: PPUSH
8529: CALL_OW 380
// result := result ^ CreateHuman ;
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_VAR 0 3
8542: PUSH
8543: CALL_OW 44
8547: ADD
8548: ST_TO_ADDR
// end ;
8549: GO 8476
8551: POP
8552: POP
// end ;
8553: LD_VAR 0 3
8557: RET
// export function Wave8 ( n , skill ) ; var i , un , chassis , weapons , control , engine ; begin
8558: LD_INT 0
8560: PPUSH
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// for i = 1 to n do
8567: LD_ADDR_VAR 0 4
8571: PUSH
8572: DOUBLE
8573: LD_INT 1
8575: DEC
8576: ST_TO_ADDR
8577: LD_VAR 0 1
8581: PUSH
8582: FOR_TO
8583: IFFALSE 8979
// begin uc_nation := rand ( 1 , 3 ) ;
8585: LD_ADDR_OWVAR 21
8589: PUSH
8590: LD_INT 1
8592: PPUSH
8593: LD_INT 3
8595: PPUSH
8596: CALL_OW 12
8600: ST_TO_ADDR
// case uc_nation of 1 :
8601: LD_OWVAR 21
8605: PUSH
8606: LD_INT 1
8608: DOUBLE
8609: EQUAL
8610: IFTRUE 8614
8612: GO 8687
8614: POP
// begin chassis := [ us_heavy_tracked , us_morphling ] ;
8615: LD_ADDR_VAR 0 6
8619: PUSH
8620: LD_INT 4
8622: PUSH
8623: LD_INT 5
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: ST_TO_ADDR
// weapons := [ us_heavy_gun , us_rocket_launcher , us_double_laser , us_artillery ] ;
8630: LD_ADDR_VAR 0 7
8634: PUSH
8635: LD_INT 6
8637: PUSH
8638: LD_INT 7
8640: PUSH
8641: LD_INT 10
8643: PUSH
8644: LD_EXP 17
8648: PUSH
8649: EMPTY
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8655: LD_ADDR_VAR 0 8
8659: PUSH
8660: LD_INT 1
8662: PUSH
8663: LD_INT 3
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8670: LD_ADDR_VAR 0 9
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: ST_TO_ADDR
// end ; 2 :
8685: GO 8844
8687: LD_INT 2
8689: DOUBLE
8690: EQUAL
8691: IFTRUE 8695
8693: GO 8768
8695: POP
// begin chassis := [ ar_half_tracked ] ;
8696: LD_ADDR_VAR 0 6
8700: PUSH
8701: LD_INT 14
8703: PUSH
8704: EMPTY
8705: LIST
8706: ST_TO_ADDR
// weapons := [ ar_bio_bomb , ar_flame_thrower , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
8707: LD_ADDR_VAR 0 7
8711: PUSH
8712: LD_EXP 18
8716: PUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 28
8722: PUSH
8723: LD_INT 29
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: LIST
8730: LIST
8731: ST_TO_ADDR
// control := [ control_manual , control_apeman ] ;
8732: LD_ADDR_VAR 0 8
8736: PUSH
8737: LD_INT 1
8739: PUSH
8740: LD_INT 5
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: ST_TO_ADDR
// engine := [ engine_combustion , engine_solar , engine_siberite ] ;
8747: LD_ADDR_VAR 0 9
8751: PUSH
8752: LD_INT 1
8754: PUSH
8755: LD_INT 2
8757: PUSH
8758: LD_INT 3
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: ST_TO_ADDR
// end ; 3 :
8766: GO 8844
8768: LD_INT 3
8770: DOUBLE
8771: EQUAL
8772: IFTRUE 8776
8774: GO 8843
8776: POP
// begin chassis := [ ru_heavy_wheeled , ru_heavy_tracked ] ;
8777: LD_ADDR_VAR 0 6
8781: PUSH
8782: LD_INT 23
8784: PUSH
8785: LD_INT 24
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: ST_TO_ADDR
// weapons := [ ru_heavy_gun , ru_rocket_launcher , ru_time_lapser ] ;
8792: LD_ADDR_VAR 0 7
8796: PUSH
8797: LD_INT 46
8799: PUSH
8800: LD_INT 45
8802: PUSH
8803: LD_INT 49
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// control := [ control_manual , control_computer ] ;
8811: LD_ADDR_VAR 0 8
8815: PUSH
8816: LD_INT 1
8818: PUSH
8819: LD_INT 3
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: ST_TO_ADDR
// engine := [ engine_combustion , engine_siberite ] ;
8826: LD_ADDR_VAR 0 9
8830: PUSH
8831: LD_INT 1
8833: PUSH
8834: LD_INT 3
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: ST_TO_ADDR
// end ; end ;
8841: GO 8844
8843: POP
// vc_chassis := chassis [ rand ( 1 , chassis ) ] ;
8844: LD_ADDR_OWVAR 37
8848: PUSH
8849: LD_VAR 0 6
8853: PUSH
8854: LD_INT 1
8856: PPUSH
8857: LD_VAR 0 6
8861: PPUSH
8862: CALL_OW 12
8866: ARRAY
8867: ST_TO_ADDR
// vc_engine := engine [ rand ( 1 , engine ) ] ;
8868: LD_ADDR_OWVAR 39
8872: PUSH
8873: LD_VAR 0 9
8877: PUSH
8878: LD_INT 1
8880: PPUSH
8881: LD_VAR 0 9
8885: PPUSH
8886: CALL_OW 12
8890: ARRAY
8891: ST_TO_ADDR
// vc_control := control [ rand ( 1 , control ) ] ;
8892: LD_ADDR_OWVAR 38
8896: PUSH
8897: LD_VAR 0 8
8901: PUSH
8902: LD_INT 1
8904: PPUSH
8905: LD_VAR 0 8
8909: PPUSH
8910: CALL_OW 12
8914: ARRAY
8915: ST_TO_ADDR
// vc_weapon := weapons [ rand ( 1 , weapons ) ] ;
8916: LD_ADDR_OWVAR 40
8920: PUSH
8921: LD_VAR 0 7
8925: PUSH
8926: LD_INT 1
8928: PPUSH
8929: LD_VAR 0 7
8933: PPUSH
8934: CALL_OW 12
8938: ARRAY
8939: ST_TO_ADDR
// vc_fuel_battery := 100 ;
8940: LD_ADDR_OWVAR 41
8944: PUSH
8945: LD_INT 100
8947: ST_TO_ADDR
// result := Insert ( result , result + 1 , CreateVehicle ) ;
8948: LD_ADDR_VAR 0 3
8952: PUSH
8953: LD_VAR 0 3
8957: PPUSH
8958: LD_VAR 0 3
8962: PUSH
8963: LD_INT 1
8965: PLUS
8966: PPUSH
8967: CALL_OW 45
8971: PPUSH
8972: CALL_OW 2
8976: ST_TO_ADDR
// end ;
8977: GO 8582
8979: POP
8980: POP
// end ; end_of_file
8981: LD_VAR 0 3
8985: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 7 ] ) do var i , un , tmp ;
8986: LD_INT 22
8988: PUSH
8989: LD_INT 7
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PPUSH
8996: CALL_OW 69
9000: IFFALSE 9506
9002: GO 9004
9004: DISABLE
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
// begin enable ;
9010: ENABLE
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9011: LD_ADDR_VAR 0 3
9015: PUSH
9016: LD_INT 22
9018: PUSH
9019: LD_INT 7
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: ST_TO_ADDR
// for i in tmp do
9031: LD_ADDR_VAR 0 1
9035: PUSH
9036: LD_VAR 0 3
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9504
// begin case GetType ( i ) of unit_human :
9044: LD_VAR 0 1
9048: PPUSH
9049: CALL_OW 247
9053: PUSH
9054: LD_INT 1
9056: DOUBLE
9057: EQUAL
9058: IFTRUE 9062
9060: GO 9261
9062: POP
// begin if GetLives ( i ) < 250 and GetTech ( 5 , 7 ) <> state_researched then
9063: LD_VAR 0 1
9067: PPUSH
9068: CALL_OW 256
9072: PUSH
9073: LD_INT 250
9075: LESS
9076: PUSH
9077: LD_INT 5
9079: PPUSH
9080: LD_INT 7
9082: PPUSH
9083: CALL_OW 321
9087: PUSH
9088: LD_INT 2
9090: NONEQUAL
9091: AND
9092: IFFALSE 9096
// continue ;
9094: GO 9041
// if GetClass ( i ) in [ 12 , 15 , 16 , 17 , 1 , 5 , 6 , 7 , 8 , 9 ] then
9096: LD_VAR 0 1
9100: PPUSH
9101: CALL_OW 257
9105: PUSH
9106: LD_INT 12
9108: PUSH
9109: LD_INT 15
9111: PUSH
9112: LD_INT 16
9114: PUSH
9115: LD_INT 17
9117: PUSH
9118: LD_INT 1
9120: PUSH
9121: LD_INT 5
9123: PUSH
9124: LD_INT 6
9126: PUSH
9127: LD_INT 7
9129: PUSH
9130: LD_INT 8
9132: PUSH
9133: LD_INT 9
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: IN
9148: IFFALSE 9186
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9150: LD_VAR 0 1
9154: PPUSH
9155: LD_INT 22
9157: PUSH
9158: LD_OWVAR 2
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 69
9171: PPUSH
9172: LD_VAR 0 1
9176: PPUSH
9177: CALL_OW 74
9181: PPUSH
9182: CALL_OW 115
// if GetClass ( i ) = 3 then
9186: LD_VAR 0 1
9190: PPUSH
9191: CALL_OW 257
9195: PUSH
9196: LD_INT 3
9198: EQUAL
9199: IFFALSE 9259
// if IsInUnit ( i ) then
9201: LD_VAR 0 1
9205: PPUSH
9206: CALL_OW 310
9210: IFFALSE 9250
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) else
9212: LD_VAR 0 1
9216: PPUSH
9217: LD_INT 22
9219: PUSH
9220: LD_OWVAR 2
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: PPUSH
9229: CALL_OW 69
9233: PPUSH
9234: LD_VAR 0 1
9238: PPUSH
9239: CALL_OW 74
9243: PPUSH
9244: CALL_OW 115
9248: GO 9259
// ComEspace ( i ) ;
9250: LD_VAR 0 1
9254: PPUSH
9255: CALL 2259 0 1
// end ; unit_vehicle :
9259: GO 9502
9261: LD_INT 2
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9501
9269: POP
// begin if GetLives ( i ) > 250 then
9270: LD_VAR 0 1
9274: PPUSH
9275: CALL_OW 256
9279: PUSH
9280: LD_INT 250
9282: GREATER
9283: IFFALSE 9499
// begin if GetWeapon ( i ) = us_artillery then
9285: LD_VAR 0 1
9289: PPUSH
9290: CALL_OW 264
9294: PUSH
9295: LD_EXP 17
9299: EQUAL
9300: IFFALSE 9368
// begin if IsInArea ( i , zoneOut ) then
9302: LD_VAR 0 1
9306: PPUSH
9307: LD_INT 4
9309: PPUSH
9310: CALL_OW 308
9314: IFFALSE 9330
// ComMoveToArea ( i , zoneBorder ) else
9316: LD_VAR 0 1
9320: PPUSH
9321: LD_INT 9
9323: PPUSH
9324: CALL_OW 113
9328: GO 9366
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 22
9337: PUSH
9338: LD_OWVAR 2
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: PPUSH
9347: CALL_OW 69
9351: PPUSH
9352: LD_VAR 0 1
9356: PPUSH
9357: CALL_OW 74
9361: PPUSH
9362: CALL_OW 115
// end else
9366: GO 9499
// if GetWeapon ( i ) in [ us_radar , ar_radar , ru_radar , ru_time_lapser ] then
9368: LD_VAR 0 1
9372: PPUSH
9373: CALL_OW 264
9377: PUSH
9378: LD_INT 11
9380: PUSH
9381: LD_INT 30
9383: PUSH
9384: LD_EXP 14
9388: PUSH
9389: LD_INT 49
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: IN
9398: IFFALSE 9428
// begin if IsInArea ( i , zoneOut ) then
9400: LD_VAR 0 1
9404: PPUSH
9405: LD_INT 4
9407: PPUSH
9408: CALL_OW 308
9412: IFFALSE 9426
// ComSpecMove ( i , specPos ) ;
9414: LD_VAR 0 1
9418: PPUSH
9419: LD_INT 8
9421: PPUSH
9422: CALL 2305 0 2
// end else
9426: GO 9499
// if GetWeapon ( i ) in [ ar_bio_bomb , ar_selfpropelled_bomb ] then
9428: LD_VAR 0 1
9432: PPUSH
9433: CALL_OW 264
9437: PUSH
9438: LD_EXP 18
9442: PUSH
9443: LD_INT 29
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: IN
9450: IFFALSE 9463
// ComSpecAttack ( i ) else
9452: LD_VAR 0 1
9456: PPUSH
9457: CALL 2733 0 1
9461: GO 9499
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , i ) ) ;
9463: LD_VAR 0 1
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_OWVAR 2
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PPUSH
9480: CALL_OW 69
9484: PPUSH
9485: LD_VAR 0 1
9489: PPUSH
9490: CALL_OW 74
9494: PPUSH
9495: CALL_OW 115
// end ; end ; end ;
9499: GO 9502
9501: POP
// end ;
9502: GO 9041
9504: POP
9505: POP
// end ; end_of_file
9506: PPOPN 3
9508: END
// export function InitDisplay ; begin
9509: LD_INT 0
9511: PPUSH
// while true do
9512: LD_INT 1
9514: IFFALSE 9601
// begin if waveNumber < 100 then
9516: LD_EXP 5
9520: PUSH
9521: LD_INT 100
9523: LESS
9524: IFFALSE 9575
// Display_Strings := [ #Tick , tick , #Points , points , #Attack , timeToNextAttack , #Wave , waveNumber ] else
9526: LD_ADDR_OWVAR 47
9530: PUSH
9531: LD_STRING #Tick
9533: PUSH
9534: LD_OWVAR 1
9538: PUSH
9539: LD_STRING #Points
9541: PUSH
9542: LD_EXP 2
9546: PUSH
9547: LD_STRING #Attack
9549: PUSH
9550: LD_EXP 4
9554: PUSH
9555: LD_STRING #Wave
9557: PUSH
9558: LD_EXP 5
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: ST_TO_ADDR
9573: GO 9592
// Display_Strings := [ #Win , points ] ;
9575: LD_ADDR_OWVAR 47
9579: PUSH
9580: LD_STRING #Win
9582: PUSH
9583: LD_EXP 2
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
9592: LD_INT 35
9594: PPUSH
9595: CALL_OW 67
// end ;
9599: GO 9512
// end ; end_of_file
9601: LD_VAR 0 1
9605: RET
// export function InitBonus ; var i , chance ; begin
9606: LD_INT 0
9608: PPUSH
9609: PPUSH
9610: PPUSH
// chance := rand ( 1 , 99 ) ;
9611: LD_ADDR_VAR 0 3
9615: PUSH
9616: LD_INT 1
9618: PPUSH
9619: LD_INT 99
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// case chance of 1 .. 10 :
9627: LD_VAR 0 3
9631: PUSH
9632: LD_INT 1
9634: DOUBLE
9635: GREATEREQUAL
9636: IFFALSE 9644
9638: LD_INT 10
9640: DOUBLE
9641: LESSEQUAL
9642: IFTRUE 9646
9644: GO 9657
9646: POP
// i := 5 ; 11 .. 25 :
9647: LD_ADDR_VAR 0 2
9651: PUSH
9652: LD_INT 5
9654: ST_TO_ADDR
9655: GO 9758
9657: LD_INT 11
9659: DOUBLE
9660: GREATEREQUAL
9661: IFFALSE 9669
9663: LD_INT 25
9665: DOUBLE
9666: LESSEQUAL
9667: IFTRUE 9671
9669: GO 9682
9671: POP
// i := 3 ; 26 .. 40 :
9672: LD_ADDR_VAR 0 2
9676: PUSH
9677: LD_INT 3
9679: ST_TO_ADDR
9680: GO 9758
9682: LD_INT 26
9684: DOUBLE
9685: GREATEREQUAL
9686: IFFALSE 9694
9688: LD_INT 40
9690: DOUBLE
9691: LESSEQUAL
9692: IFTRUE 9696
9694: GO 9707
9696: POP
// i := 2 ; 41 .. 60 :
9697: LD_ADDR_VAR 0 2
9701: PUSH
9702: LD_INT 2
9704: ST_TO_ADDR
9705: GO 9758
9707: LD_INT 41
9709: DOUBLE
9710: GREATEREQUAL
9711: IFFALSE 9719
9713: LD_INT 60
9715: DOUBLE
9716: LESSEQUAL
9717: IFTRUE 9721
9719: GO 9732
9721: POP
// i := 4 ; 61 .. 99 :
9722: LD_ADDR_VAR 0 2
9726: PUSH
9727: LD_INT 4
9729: ST_TO_ADDR
9730: GO 9758
9732: LD_INT 61
9734: DOUBLE
9735: GREATEREQUAL
9736: IFFALSE 9744
9738: LD_INT 99
9740: DOUBLE
9741: LESSEQUAL
9742: IFTRUE 9746
9744: GO 9757
9746: POP
// i := 1 ; end ;
9747: LD_ADDR_VAR 0 2
9751: PUSH
9752: LD_INT 1
9754: ST_TO_ADDR
9755: GO 9758
9757: POP
// case i of 1 :
9758: LD_VAR 0 2
9762: PUSH
9763: LD_INT 1
9765: DOUBLE
9766: EQUAL
9767: IFTRUE 9771
9769: GO 9860
9771: POP
// begin if FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) >= 10 then
9772: LD_INT 22
9774: PUSH
9775: LD_OWVAR 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: LD_INT 25
9789: PUSH
9790: LD_INT 12
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 25
9799: PUSH
9800: LD_INT 16
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PUSH
9807: LD_INT 25
9809: PUSH
9810: LD_INT 15
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PUSH
9817: LD_INT 25
9819: PUSH
9820: LD_INT 17
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 69
9842: PUSH
9843: LD_INT 10
9845: GREATEREQUAL
9846: IFFALSE 9854
// BonusIV else
9848: CALL 10433 0 0
9852: GO 9858
// BonusI ;
9854: CALL 9938 0 0
// end ; 2 :
9858: GO 9933
9860: LD_INT 2
9862: DOUBLE
9863: EQUAL
9864: IFTRUE 9868
9866: GO 9875
9868: POP
// begin BonusII ;
9869: CALL 10111 0 0
// end ; 3 :
9873: GO 9933
9875: LD_INT 3
9877: DOUBLE
9878: EQUAL
9879: IFTRUE 9883
9881: GO 9890
9883: POP
// begin BonusIII ;
9884: CALL 10259 0 0
// end ; 4 :
9888: GO 9933
9890: LD_INT 4
9892: DOUBLE
9893: EQUAL
9894: IFTRUE 9898
9896: GO 9905
9898: POP
// begin BonusIV ;
9899: CALL 10433 0 0
// end ; 5 :
9903: GO 9933
9905: LD_INT 5
9907: DOUBLE
9908: EQUAL
9909: IFTRUE 9913
9911: GO 9932
9913: POP
// begin if graveyard then
9914: LD_EXP 8
9918: IFFALSE 9926
// BonusV else
9920: CALL 10851 0 0
9924: GO 9930
// BonusIII ;
9926: CALL 10259 0 0
// end ; end ;
9930: GO 9933
9932: POP
// end ;
9933: LD_VAR 0 1
9937: RET
// export function BonusI ; var i ; begin
9938: LD_INT 0
9940: PPUSH
9941: PPUSH
// case Query ( AddGift1 ) of 1 :
9942: LD_STRING AddGift1
9944: PPUSH
9945: CALL_OW 97
9949: PUSH
9950: LD_INT 1
9952: DOUBLE
9953: EQUAL
9954: IFTRUE 9958
9956: GO 10037
9958: POP
// begin for i = 1 to 3 do
9959: LD_ADDR_VAR 0 2
9963: PUSH
9964: DOUBLE
9965: LD_INT 1
9967: DEC
9968: ST_TO_ADDR
9969: LD_INT 3
9971: PUSH
9972: FOR_TO
9973: IFFALSE 10033
// begin uc_side := your_side ;
9975: LD_ADDR_OWVAR 20
9979: PUSH
9980: LD_OWVAR 2
9984: ST_TO_ADDR
// uc_nation := 0 ;
9985: LD_ADDR_OWVAR 21
9989: PUSH
9990: LD_INT 0
9992: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
9993: LD_INT 0
9995: PPUSH
9996: LD_INT 12
9998: PPUSH
9999: LD_INT 1
10001: PPUSH
10002: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , base_x , base_y , 15 , true ) ;
10006: CALL_OW 44
10010: PPUSH
10011: LD_EXP 9
10015: PPUSH
10016: LD_EXP 10
10020: PPUSH
10021: LD_INT 15
10023: PPUSH
10024: LD_INT 1
10026: PPUSH
10027: CALL_OW 50
// end ;
10031: GO 9972
10033: POP
10034: POP
// end ; 2 :
10035: GO 10106
10037: LD_INT 2
10039: DOUBLE
10040: EQUAL
10041: IFTRUE 10045
10043: GO 10087
10045: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10046: LD_EXP 11
10050: PPUSH
10051: CALL_OW 274
10055: PPUSH
10056: LD_INT 1
10058: PPUSH
10059: LD_EXP 11
10063: PPUSH
10064: CALL_OW 274
10068: PPUSH
10069: LD_INT 1
10071: PPUSH
10072: CALL_OW 275
10076: PUSH
10077: LD_INT 100
10079: PLUS
10080: PPUSH
10081: CALL_OW 277
// end ; 3 :
10085: GO 10106
10087: LD_INT 3
10089: DOUBLE
10090: EQUAL
10091: IFTRUE 10095
10093: GO 10105
10095: POP
// begin SetTeamExp ( 2 ) ;
10096: LD_INT 2
10098: PPUSH
10099: CALL 1266 0 1
// end ; end ;
10103: GO 10106
10105: POP
// end ;
10106: LD_VAR 0 1
10110: RET
// export function BonusII ; var i ; begin
10111: LD_INT 0
10113: PPUSH
10114: PPUSH
// case Query ( AddGift2 ) of 1 :
10115: LD_STRING AddGift2
10117: PPUSH
10118: CALL_OW 97
10122: PUSH
10123: LD_INT 1
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10173
10131: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
10132: LD_EXP 11
10136: PPUSH
10137: CALL_OW 274
10141: PPUSH
10142: LD_INT 1
10144: PPUSH
10145: LD_EXP 11
10149: PPUSH
10150: CALL_OW 274
10154: PPUSH
10155: LD_INT 1
10157: PPUSH
10158: CALL_OW 275
10162: PUSH
10163: LD_INT 500
10165: PLUS
10166: PPUSH
10167: CALL_OW 277
// end ; 2 :
10171: GO 10254
10173: LD_INT 2
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10191
10181: POP
// begin SetTeamExp ( 3 ) ;
10182: LD_INT 3
10184: PPUSH
10185: CALL 1266 0 1
// end ; 3 :
10189: GO 10254
10191: LD_INT 3
10193: DOUBLE
10194: EQUAL
10195: IFTRUE 10199
10197: GO 10253
10199: POP
// begin uc_side = your_side ;
10200: LD_ADDR_OWVAR 20
10204: PUSH
10205: LD_OWVAR 2
10209: ST_TO_ADDR
// uc_nation = nation_russian ;
10210: LD_ADDR_OWVAR 21
10214: PUSH
10215: LD_INT 3
10217: ST_TO_ADDR
// vc_chassis = 25 ;
10218: LD_ADDR_OWVAR 37
10222: PUSH
10223: LD_INT 25
10225: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10226: CALL_OW 45
10230: PPUSH
10231: LD_EXP 9
10235: PPUSH
10236: LD_EXP 10
10240: PPUSH
10241: LD_INT 15
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL_OW 50
// end ; end ;
10251: GO 10254
10253: POP
// end ;
10254: LD_VAR 0 1
10258: RET
// export function BonusIII ; var i ; begin
10259: LD_INT 0
10261: PPUSH
10262: PPUSH
// case Query ( AddGift3 ) of 1 :
10263: LD_STRING AddGift3
10265: PPUSH
10266: CALL_OW 97
10270: PUSH
10271: LD_INT 1
10273: DOUBLE
10274: EQUAL
10275: IFTRUE 10279
10277: GO 10321
10279: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 1000 ) ;
10280: LD_EXP 11
10284: PPUSH
10285: CALL_OW 274
10289: PPUSH
10290: LD_INT 1
10292: PPUSH
10293: LD_EXP 11
10297: PPUSH
10298: CALL_OW 274
10302: PPUSH
10303: LD_INT 1
10305: PPUSH
10306: CALL_OW 275
10310: PUSH
10311: LD_INT 1000
10313: PLUS
10314: PPUSH
10315: CALL_OW 277
// end ; 2 :
10319: GO 10428
10321: LD_INT 2
10323: DOUBLE
10324: EQUAL
10325: IFTRUE 10329
10327: GO 10341
10329: POP
// begin PrepareGuards ( waveNumber ) ;
10330: LD_EXP 5
10334: PPUSH
10335: CALL 1412 0 1
// end ; 3 :
10339: GO 10428
10341: LD_INT 3
10343: DOUBLE
10344: EQUAL
10345: IFTRUE 10349
10347: GO 10427
10349: POP
// begin uc_side = your_side ;
10350: LD_ADDR_OWVAR 20
10354: PUSH
10355: LD_OWVAR 2
10359: ST_TO_ADDR
// uc_nation = nation_american ;
10360: LD_ADDR_OWVAR 21
10364: PUSH
10365: LD_INT 1
10367: ST_TO_ADDR
// vc_chassis = us_morphling ;
10368: LD_ADDR_OWVAR 37
10372: PUSH
10373: LD_INT 5
10375: ST_TO_ADDR
// vc_engine := engine_siberite ;
10376: LD_ADDR_OWVAR 39
10380: PUSH
10381: LD_INT 3
10383: ST_TO_ADDR
// vc_control := control_computer ;
10384: LD_ADDR_OWVAR 38
10388: PUSH
10389: LD_INT 3
10391: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
10392: LD_ADDR_OWVAR 40
10396: PUSH
10397: LD_INT 8
10399: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10400: CALL_OW 45
10404: PPUSH
10405: LD_EXP 9
10409: PPUSH
10410: LD_EXP 10
10414: PPUSH
10415: LD_INT 15
10417: PPUSH
10418: LD_INT 1
10420: PPUSH
10421: CALL_OW 50
// end ; end ;
10425: GO 10428
10427: POP
// end ;
10428: LD_VAR 0 1
10432: RET
// export function BonusIV ; var i ; begin
10433: LD_INT 0
10435: PPUSH
10436: PPUSH
// case Query ( AddGift4 ) of 1 :
10437: LD_STRING AddGift4
10439: PPUSH
10440: CALL_OW 97
10444: PUSH
10445: LD_INT 1
10447: DOUBLE
10448: EQUAL
10449: IFTRUE 10453
10451: GO 10777
10453: POP
// begin i := rand ( 1 , 3 ) ;
10454: LD_ADDR_VAR 0 2
10458: PUSH
10459: LD_INT 1
10461: PPUSH
10462: LD_INT 3
10464: PPUSH
10465: CALL_OW 12
10469: ST_TO_ADDR
// uc_side := your_side ;
10470: LD_ADDR_OWVAR 20
10474: PUSH
10475: LD_OWVAR 2
10479: ST_TO_ADDR
// case i of 1 :
10480: LD_VAR 0 2
10484: PUSH
10485: LD_INT 1
10487: DOUBLE
10488: EQUAL
10489: IFTRUE 10493
10491: GO 10580
10493: POP
// begin uc_nation := nation_arabian ;
10494: LD_ADDR_OWVAR 21
10498: PUSH
10499: LD_INT 2
10501: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10502: LD_ADDR_OWVAR 37
10506: PUSH
10507: LD_INT 14
10509: ST_TO_ADDR
// vc_engine := engine_combustion ;
10510: LD_ADDR_OWVAR 39
10514: PUSH
10515: LD_INT 1
10517: ST_TO_ADDR
// vc_control := control_manual ;
10518: LD_ADDR_OWVAR 38
10522: PUSH
10523: LD_INT 1
10525: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10526: LD_ADDR_OWVAR 40
10530: PUSH
10531: LD_INT 27
10533: PUSH
10534: LD_INT 28
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: LD_INT 1
10543: PPUSH
10544: LD_INT 2
10546: PPUSH
10547: CALL_OW 12
10551: ARRAY
10552: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10553: CALL_OW 45
10557: PPUSH
10558: LD_EXP 9
10562: PPUSH
10563: LD_EXP 10
10567: PPUSH
10568: LD_INT 15
10570: PPUSH
10571: LD_INT 1
10573: PPUSH
10574: CALL_OW 50
// end ; 2 :
10578: GO 10775
10580: LD_INT 2
10582: DOUBLE
10583: EQUAL
10584: IFTRUE 10588
10586: GO 10679
10588: POP
// begin uc_nation := nation_american ;
10589: LD_ADDR_OWVAR 21
10593: PUSH
10594: LD_INT 1
10596: ST_TO_ADDR
// vc_chassis := us_morphling ;
10597: LD_ADDR_OWVAR 37
10601: PUSH
10602: LD_INT 5
10604: ST_TO_ADDR
// vc_engine := engine_siberite ;
10605: LD_ADDR_OWVAR 39
10609: PUSH
10610: LD_INT 3
10612: ST_TO_ADDR
// vc_control := control_computer ;
10613: LD_ADDR_OWVAR 38
10617: PUSH
10618: LD_INT 3
10620: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_double_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
10621: LD_ADDR_OWVAR 40
10625: PUSH
10626: LD_INT 12
10628: PUSH
10629: LD_INT 10
10631: PUSH
10632: LD_INT 7
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 1
10642: PPUSH
10643: LD_INT 3
10645: PPUSH
10646: CALL_OW 12
10650: ARRAY
10651: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10652: CALL_OW 45
10656: PPUSH
10657: LD_EXP 9
10661: PPUSH
10662: LD_EXP 10
10666: PPUSH
10667: LD_INT 15
10669: PPUSH
10670: LD_INT 1
10672: PPUSH
10673: CALL_OW 50
// end ; 3 :
10677: GO 10775
10679: LD_INT 3
10681: DOUBLE
10682: EQUAL
10683: IFTRUE 10687
10685: GO 10774
10687: POP
// begin uc_nation := nation_russian ;
10688: LD_ADDR_OWVAR 21
10692: PUSH
10693: LD_INT 3
10695: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10696: LD_ADDR_OWVAR 37
10700: PUSH
10701: LD_INT 22
10703: ST_TO_ADDR
// vc_engine := engine_combustion ;
10704: LD_ADDR_OWVAR 39
10708: PUSH
10709: LD_INT 1
10711: ST_TO_ADDR
// vc_control := control_manual ;
10712: LD_ADDR_OWVAR 38
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
10720: LD_ADDR_OWVAR 40
10724: PUSH
10725: LD_INT 45
10727: PUSH
10728: LD_INT 44
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 1
10737: PPUSH
10738: LD_INT 2
10740: PPUSH
10741: CALL_OW 12
10745: ARRAY
10746: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10747: CALL_OW 45
10751: PPUSH
10752: LD_EXP 9
10756: PPUSH
10757: LD_EXP 10
10761: PPUSH
10762: LD_INT 15
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 50
// end ; end ;
10772: GO 10775
10774: POP
// end ; 2 :
10775: GO 10846
10777: LD_INT 2
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10827
10785: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 100 ) ;
10786: LD_EXP 11
10790: PPUSH
10791: CALL_OW 274
10795: PPUSH
10796: LD_INT 1
10798: PPUSH
10799: LD_EXP 11
10803: PPUSH
10804: CALL_OW 274
10808: PPUSH
10809: LD_INT 1
10811: PPUSH
10812: CALL_OW 275
10816: PUSH
10817: LD_INT 100
10819: PLUS
10820: PPUSH
10821: CALL_OW 277
// end ; 3 :
10825: GO 10846
10827: LD_INT 3
10829: DOUBLE
10830: EQUAL
10831: IFTRUE 10835
10833: GO 10845
10835: POP
// begin SetTeamExp ( 2 ) ;
10836: LD_INT 2
10838: PPUSH
10839: CALL 1266 0 1
// end ; end ;
10843: GO 10846
10845: POP
// end ;
10846: LD_VAR 0 1
10850: RET
// export function BonusV ; var i , j ; begin
10851: LD_INT 0
10853: PPUSH
10854: PPUSH
10855: PPUSH
// case Query ( AddGift5 ) of 1 :
10856: LD_STRING AddGift5
10858: PPUSH
10859: CALL_OW 97
10863: PUSH
10864: LD_INT 1
10866: DOUBLE
10867: EQUAL
10868: IFTRUE 10872
10870: GO 11216
10872: POP
// begin for j = 1 to 3 do
10873: LD_ADDR_VAR 0 3
10877: PUSH
10878: DOUBLE
10879: LD_INT 1
10881: DEC
10882: ST_TO_ADDR
10883: LD_INT 3
10885: PUSH
10886: FOR_TO
10887: IFFALSE 11212
// begin i := rand ( 1 , 3 ) ;
10889: LD_ADDR_VAR 0 2
10893: PUSH
10894: LD_INT 1
10896: PPUSH
10897: LD_INT 3
10899: PPUSH
10900: CALL_OW 12
10904: ST_TO_ADDR
// uc_side := your_side ;
10905: LD_ADDR_OWVAR 20
10909: PUSH
10910: LD_OWVAR 2
10914: ST_TO_ADDR
// case i of 1 :
10915: LD_VAR 0 2
10919: PUSH
10920: LD_INT 1
10922: DOUBLE
10923: EQUAL
10924: IFTRUE 10928
10926: GO 11015
10928: POP
// begin uc_nation := nation_arabian ;
10929: LD_ADDR_OWVAR 21
10933: PUSH
10934: LD_INT 2
10936: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10937: LD_ADDR_OWVAR 37
10941: PUSH
10942: LD_INT 14
10944: ST_TO_ADDR
// vc_engine := engine_combustion ;
10945: LD_ADDR_OWVAR 39
10949: PUSH
10950: LD_INT 1
10952: ST_TO_ADDR
// vc_control := control_manual ;
10953: LD_ADDR_OWVAR 38
10957: PUSH
10958: LD_INT 1
10960: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ;
10961: LD_ADDR_OWVAR 40
10965: PUSH
10966: LD_INT 27
10968: PUSH
10969: LD_INT 28
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: LD_INT 1
10978: PPUSH
10979: LD_INT 2
10981: PPUSH
10982: CALL_OW 12
10986: ARRAY
10987: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
10988: CALL_OW 45
10992: PPUSH
10993: LD_EXP 9
10997: PPUSH
10998: LD_EXP 10
11002: PPUSH
11003: LD_INT 15
11005: PPUSH
11006: LD_INT 1
11008: PPUSH
11009: CALL_OW 50
// end ; 2 :
11013: GO 11210
11015: LD_INT 2
11017: DOUBLE
11018: EQUAL
11019: IFTRUE 11023
11021: GO 11114
11023: POP
// begin uc_nation := nation_american ;
11024: LD_ADDR_OWVAR 21
11028: PUSH
11029: LD_INT 1
11031: ST_TO_ADDR
// vc_chassis := us_morphling ;
11032: LD_ADDR_OWVAR 37
11036: PUSH
11037: LD_INT 5
11039: ST_TO_ADDR
// vc_engine := engine_siberite ;
11040: LD_ADDR_OWVAR 39
11044: PUSH
11045: LD_INT 3
11047: ST_TO_ADDR
// vc_control := control_computer ;
11048: LD_ADDR_OWVAR 38
11052: PUSH
11053: LD_INT 3
11055: ST_TO_ADDR
// vc_weapon := [ us_cargo_bay , us_radar , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
11056: LD_ADDR_OWVAR 40
11060: PUSH
11061: LD_INT 12
11063: PUSH
11064: LD_INT 11
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 1
11077: PPUSH
11078: LD_INT 3
11080: PPUSH
11081: CALL_OW 12
11085: ARRAY
11086: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11087: CALL_OW 45
11091: PPUSH
11092: LD_EXP 9
11096: PPUSH
11097: LD_EXP 10
11101: PPUSH
11102: LD_INT 15
11104: PPUSH
11105: LD_INT 1
11107: PPUSH
11108: CALL_OW 50
// end ; 3 :
11112: GO 11210
11114: LD_INT 3
11116: DOUBLE
11117: EQUAL
11118: IFTRUE 11122
11120: GO 11209
11122: POP
// begin uc_nation := nation_russian ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 3
11130: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
11131: LD_ADDR_OWVAR 37
11135: PUSH
11136: LD_INT 22
11138: ST_TO_ADDR
// vc_engine := engine_combustion ;
11139: LD_ADDR_OWVAR 39
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// vc_control := control_manual ;
11147: LD_ADDR_OWVAR 38
11151: PUSH
11152: LD_INT 1
11154: ST_TO_ADDR
// vc_weapon := [ ru_rocket_launcher , ru_gun ] [ rand ( 1 , 2 ) ] ;
11155: LD_ADDR_OWVAR 40
11159: PUSH
11160: LD_INT 45
11162: PUSH
11163: LD_INT 44
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: PUSH
11170: LD_INT 1
11172: PPUSH
11173: LD_INT 2
11175: PPUSH
11176: CALL_OW 12
11180: ARRAY
11181: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , base_x , base_y , 15 , true ) ;
11182: CALL_OW 45
11186: PPUSH
11187: LD_EXP 9
11191: PPUSH
11192: LD_EXP 10
11196: PPUSH
11197: LD_INT 15
11199: PPUSH
11200: LD_INT 1
11202: PPUSH
11203: CALL_OW 50
// end ; end ;
11207: GO 11210
11209: POP
// end ;
11210: GO 10886
11212: POP
11213: POP
// end ; 2 :
11214: GO 11282
11216: LD_INT 2
11218: DOUBLE
11219: EQUAL
11220: IFTRUE 11224
11222: GO 11266
11224: POP
// begin SetResourceType ( GetBase ( base ) , mat_cans , GetResourceType ( GetBase ( base ) , mat_cans ) + 500 ) ;
11225: LD_EXP 11
11229: PPUSH
11230: CALL_OW 274
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: LD_EXP 11
11242: PPUSH
11243: CALL_OW 274
11247: PPUSH
11248: LD_INT 1
11250: PPUSH
11251: CALL_OW 275
11255: PUSH
11256: LD_INT 500
11258: PLUS
11259: PPUSH
11260: CALL_OW 277
// end ; 3 :
11264: GO 11282
11266: LD_INT 3
11268: DOUBLE
11269: EQUAL
11270: IFTRUE 11274
11272: GO 11281
11274: POP
// begin GetBack ( ) ;
11275: CALL 2072 0 0
// end ; end ;
11279: GO 11282
11281: POP
// end ; end_of_file
11282: LD_VAR 0 1
11286: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11287: GO 11289
11289: DISABLE
// begin ru_radar := 98 ;
11290: LD_ADDR_EXP 14
11294: PUSH
11295: LD_INT 98
11297: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11298: LD_ADDR_EXP 15
11302: PUSH
11303: LD_INT 89
11305: ST_TO_ADDR
// us_hack := 99 ;
11306: LD_ADDR_EXP 16
11310: PUSH
11311: LD_INT 99
11313: ST_TO_ADDR
// us_artillery := 97 ;
11314: LD_ADDR_EXP 17
11318: PUSH
11319: LD_INT 97
11321: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11322: LD_ADDR_EXP 18
11326: PUSH
11327: LD_INT 91
11329: ST_TO_ADDR
// end ; end_of_file end_of_file
11330: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
11331: GO 11333
11333: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11334: LD_STRING initStreamRollete();
11336: PPUSH
11337: CALL_OW 559
// InitStreamMode ;
11341: CALL 11346 0 0
// end ;
11345: END
// function InitStreamMode ; begin
11346: LD_INT 0
11348: PPUSH
// streamModeActive := false ;
11349: LD_ADDR_EXP 19
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// sRocket := false ;
11357: LD_ADDR_EXP 22
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// sSpeed := false ;
11365: LD_ADDR_EXP 21
11369: PUSH
11370: LD_INT 0
11372: ST_TO_ADDR
// sEngine := false ;
11373: LD_ADDR_EXP 23
11377: PUSH
11378: LD_INT 0
11380: ST_TO_ADDR
// sSpec := false ;
11381: LD_ADDR_EXP 20
11385: PUSH
11386: LD_INT 0
11388: ST_TO_ADDR
// sLevel := false ;
11389: LD_ADDR_EXP 24
11393: PUSH
11394: LD_INT 0
11396: ST_TO_ADDR
// sArmoury := false ;
11397: LD_ADDR_EXP 25
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// sRadar := false ;
11405: LD_ADDR_EXP 26
11409: PUSH
11410: LD_INT 0
11412: ST_TO_ADDR
// sBunker := false ;
11413: LD_ADDR_EXP 27
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// sHack := false ;
11421: LD_ADDR_EXP 28
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// sFire := false ;
11429: LD_ADDR_EXP 29
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// sRefresh := false ;
11437: LD_ADDR_EXP 30
11441: PUSH
11442: LD_INT 0
11444: ST_TO_ADDR
// sExp := false ;
11445: LD_ADDR_EXP 31
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// sDepot := false ;
11453: LD_ADDR_EXP 32
11457: PUSH
11458: LD_INT 0
11460: ST_TO_ADDR
// sFlag := false ;
11461: LD_ADDR_EXP 33
11465: PUSH
11466: LD_INT 0
11468: ST_TO_ADDR
// sKamikadze := false ;
11469: LD_ADDR_EXP 41
11473: PUSH
11474: LD_INT 0
11476: ST_TO_ADDR
// sTroll := false ;
11477: LD_ADDR_EXP 42
11481: PUSH
11482: LD_INT 0
11484: ST_TO_ADDR
// sSlow := false ;
11485: LD_ADDR_EXP 43
11489: PUSH
11490: LD_INT 0
11492: ST_TO_ADDR
// sLack := false ;
11493: LD_ADDR_EXP 44
11497: PUSH
11498: LD_INT 0
11500: ST_TO_ADDR
// sTank := false ;
11501: LD_ADDR_EXP 46
11505: PUSH
11506: LD_INT 0
11508: ST_TO_ADDR
// sRemote := false ;
11509: LD_ADDR_EXP 47
11513: PUSH
11514: LD_INT 0
11516: ST_TO_ADDR
// sPowell := false ;
11517: LD_ADDR_EXP 48
11521: PUSH
11522: LD_INT 0
11524: ST_TO_ADDR
// sTeleport := false ;
11525: LD_ADDR_EXP 51
11529: PUSH
11530: LD_INT 0
11532: ST_TO_ADDR
// sOilTower := false ;
11533: LD_ADDR_EXP 53
11537: PUSH
11538: LD_INT 0
11540: ST_TO_ADDR
// sShovel := false ;
11541: LD_ADDR_EXP 54
11545: PUSH
11546: LD_INT 0
11548: ST_TO_ADDR
// sSheik := false ;
11549: LD_ADDR_EXP 55
11553: PUSH
11554: LD_INT 0
11556: ST_TO_ADDR
// sSold := false ;
11557: LD_ADDR_EXP 34
11561: PUSH
11562: LD_INT 0
11564: ST_TO_ADDR
// sDiff := false ;
11565: LD_ADDR_EXP 35
11569: PUSH
11570: LD_INT 0
11572: ST_TO_ADDR
// sFog := false ;
11573: LD_ADDR_EXP 38
11577: PUSH
11578: LD_INT 0
11580: ST_TO_ADDR
// sReset := false ;
11581: LD_ADDR_EXP 39
11585: PUSH
11586: LD_INT 0
11588: ST_TO_ADDR
// sSun := false ;
11589: LD_ADDR_EXP 40
11593: PUSH
11594: LD_INT 0
11596: ST_TO_ADDR
// sTiger := false ;
11597: LD_ADDR_EXP 36
11601: PUSH
11602: LD_INT 0
11604: ST_TO_ADDR
// sBomb := false ;
11605: LD_ADDR_EXP 37
11609: PUSH
11610: LD_INT 0
11612: ST_TO_ADDR
// sWound := false ;
11613: LD_ADDR_EXP 45
11617: PUSH
11618: LD_INT 0
11620: ST_TO_ADDR
// sBetray := false ;
11621: LD_ADDR_EXP 49
11625: PUSH
11626: LD_INT 0
11628: ST_TO_ADDR
// sContamin := false ;
11629: LD_ADDR_EXP 50
11633: PUSH
11634: LD_INT 0
11636: ST_TO_ADDR
// sOil := false ;
11637: LD_ADDR_EXP 52
11641: PUSH
11642: LD_INT 0
11644: ST_TO_ADDR
// sStu := false ;
11645: LD_ADDR_EXP 56
11649: PUSH
11650: LD_INT 0
11652: ST_TO_ADDR
// end ;
11653: LD_VAR 0 1
11657: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11658: LD_VAR 0 2
11662: PUSH
11663: LD_INT 100
11665: EQUAL
11666: IFFALSE 12363
// begin if not StreamModeActive then
11668: LD_EXP 19
11672: NOT
11673: IFFALSE 11683
// StreamModeActive := true ;
11675: LD_ADDR_EXP 19
11679: PUSH
11680: LD_INT 1
11682: ST_TO_ADDR
// if p3 = 0 then
11683: LD_VAR 0 3
11687: PUSH
11688: LD_INT 0
11690: EQUAL
11691: IFFALSE 11697
// InitStreamMode ;
11693: CALL 11346 0 0
// if p3 = 1 then
11697: LD_VAR 0 3
11701: PUSH
11702: LD_INT 1
11704: EQUAL
11705: IFFALSE 11715
// sRocket := true ;
11707: LD_ADDR_EXP 22
11711: PUSH
11712: LD_INT 1
11714: ST_TO_ADDR
// if p3 = 2 then
11715: LD_VAR 0 3
11719: PUSH
11720: LD_INT 2
11722: EQUAL
11723: IFFALSE 11733
// sSpeed := true ;
11725: LD_ADDR_EXP 21
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
// if p3 = 3 then
11733: LD_VAR 0 3
11737: PUSH
11738: LD_INT 3
11740: EQUAL
11741: IFFALSE 11751
// sEngine := true ;
11743: LD_ADDR_EXP 23
11747: PUSH
11748: LD_INT 1
11750: ST_TO_ADDR
// if p3 = 4 then
11751: LD_VAR 0 3
11755: PUSH
11756: LD_INT 4
11758: EQUAL
11759: IFFALSE 11769
// sSpec := true ;
11761: LD_ADDR_EXP 20
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// if p3 = 5 then
11769: LD_VAR 0 3
11773: PUSH
11774: LD_INT 5
11776: EQUAL
11777: IFFALSE 11787
// sLevel := true ;
11779: LD_ADDR_EXP 24
11783: PUSH
11784: LD_INT 1
11786: ST_TO_ADDR
// if p3 = 6 then
11787: LD_VAR 0 3
11791: PUSH
11792: LD_INT 6
11794: EQUAL
11795: IFFALSE 11805
// sArmoury := true ;
11797: LD_ADDR_EXP 25
11801: PUSH
11802: LD_INT 1
11804: ST_TO_ADDR
// if p3 = 7 then
11805: LD_VAR 0 3
11809: PUSH
11810: LD_INT 7
11812: EQUAL
11813: IFFALSE 11823
// sRadar := true ;
11815: LD_ADDR_EXP 26
11819: PUSH
11820: LD_INT 1
11822: ST_TO_ADDR
// if p3 = 8 then
11823: LD_VAR 0 3
11827: PUSH
11828: LD_INT 8
11830: EQUAL
11831: IFFALSE 11841
// sBunker := true ;
11833: LD_ADDR_EXP 27
11837: PUSH
11838: LD_INT 1
11840: ST_TO_ADDR
// if p3 = 9 then
11841: LD_VAR 0 3
11845: PUSH
11846: LD_INT 9
11848: EQUAL
11849: IFFALSE 11859
// sHack := true ;
11851: LD_ADDR_EXP 28
11855: PUSH
11856: LD_INT 1
11858: ST_TO_ADDR
// if p3 = 10 then
11859: LD_VAR 0 3
11863: PUSH
11864: LD_INT 10
11866: EQUAL
11867: IFFALSE 11877
// sFire := true ;
11869: LD_ADDR_EXP 29
11873: PUSH
11874: LD_INT 1
11876: ST_TO_ADDR
// if p3 = 11 then
11877: LD_VAR 0 3
11881: PUSH
11882: LD_INT 11
11884: EQUAL
11885: IFFALSE 11895
// sRefresh := true ;
11887: LD_ADDR_EXP 30
11891: PUSH
11892: LD_INT 1
11894: ST_TO_ADDR
// if p3 = 12 then
11895: LD_VAR 0 3
11899: PUSH
11900: LD_INT 12
11902: EQUAL
11903: IFFALSE 11913
// sExp := true ;
11905: LD_ADDR_EXP 31
11909: PUSH
11910: LD_INT 1
11912: ST_TO_ADDR
// if p3 = 13 then
11913: LD_VAR 0 3
11917: PUSH
11918: LD_INT 13
11920: EQUAL
11921: IFFALSE 11931
// sDepot := true ;
11923: LD_ADDR_EXP 32
11927: PUSH
11928: LD_INT 1
11930: ST_TO_ADDR
// if p3 = 14 then
11931: LD_VAR 0 3
11935: PUSH
11936: LD_INT 14
11938: EQUAL
11939: IFFALSE 11949
// sFlag := true ;
11941: LD_ADDR_EXP 33
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// if p3 = 15 then
11949: LD_VAR 0 3
11953: PUSH
11954: LD_INT 15
11956: EQUAL
11957: IFFALSE 11967
// sKamikadze := true ;
11959: LD_ADDR_EXP 41
11963: PUSH
11964: LD_INT 1
11966: ST_TO_ADDR
// if p3 = 16 then
11967: LD_VAR 0 3
11971: PUSH
11972: LD_INT 16
11974: EQUAL
11975: IFFALSE 11985
// sTroll := true ;
11977: LD_ADDR_EXP 42
11981: PUSH
11982: LD_INT 1
11984: ST_TO_ADDR
// if p3 = 17 then
11985: LD_VAR 0 3
11989: PUSH
11990: LD_INT 17
11992: EQUAL
11993: IFFALSE 12003
// sSlow := true ;
11995: LD_ADDR_EXP 43
11999: PUSH
12000: LD_INT 1
12002: ST_TO_ADDR
// if p3 = 18 then
12003: LD_VAR 0 3
12007: PUSH
12008: LD_INT 18
12010: EQUAL
12011: IFFALSE 12021
// sLack := true ;
12013: LD_ADDR_EXP 44
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// if p3 = 19 then
12021: LD_VAR 0 3
12025: PUSH
12026: LD_INT 19
12028: EQUAL
12029: IFFALSE 12039
// sTank := true ;
12031: LD_ADDR_EXP 46
12035: PUSH
12036: LD_INT 1
12038: ST_TO_ADDR
// if p3 = 20 then
12039: LD_VAR 0 3
12043: PUSH
12044: LD_INT 20
12046: EQUAL
12047: IFFALSE 12057
// sRemote := true ;
12049: LD_ADDR_EXP 47
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// if p3 = 21 then
12057: LD_VAR 0 3
12061: PUSH
12062: LD_INT 21
12064: EQUAL
12065: IFFALSE 12075
// sPowell := true ;
12067: LD_ADDR_EXP 48
12071: PUSH
12072: LD_INT 1
12074: ST_TO_ADDR
// if p3 = 22 then
12075: LD_VAR 0 3
12079: PUSH
12080: LD_INT 22
12082: EQUAL
12083: IFFALSE 12093
// sTeleport := true ;
12085: LD_ADDR_EXP 51
12089: PUSH
12090: LD_INT 1
12092: ST_TO_ADDR
// if p3 = 23 then
12093: LD_VAR 0 3
12097: PUSH
12098: LD_INT 23
12100: EQUAL
12101: IFFALSE 12111
// sOilTower := true ;
12103: LD_ADDR_EXP 53
12107: PUSH
12108: LD_INT 1
12110: ST_TO_ADDR
// if p3 = 24 then
12111: LD_VAR 0 3
12115: PUSH
12116: LD_INT 24
12118: EQUAL
12119: IFFALSE 12129
// sShovel := true ;
12121: LD_ADDR_EXP 54
12125: PUSH
12126: LD_INT 1
12128: ST_TO_ADDR
// if p3 = 25 then
12129: LD_VAR 0 3
12133: PUSH
12134: LD_INT 25
12136: EQUAL
12137: IFFALSE 12147
// sSheik := true ;
12139: LD_ADDR_EXP 55
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// if p3 = 101 then
12147: LD_VAR 0 3
12151: PUSH
12152: LD_INT 101
12154: EQUAL
12155: IFFALSE 12165
// sSold := true ;
12157: LD_ADDR_EXP 34
12161: PUSH
12162: LD_INT 1
12164: ST_TO_ADDR
// if p3 = 102 then
12165: LD_VAR 0 3
12169: PUSH
12170: LD_INT 102
12172: EQUAL
12173: IFFALSE 12183
// sDiff := true ;
12175: LD_ADDR_EXP 35
12179: PUSH
12180: LD_INT 1
12182: ST_TO_ADDR
// if p3 = 103 then
12183: LD_VAR 0 3
12187: PUSH
12188: LD_INT 103
12190: EQUAL
12191: IFFALSE 12201
// sFog := true ;
12193: LD_ADDR_EXP 38
12197: PUSH
12198: LD_INT 1
12200: ST_TO_ADDR
// if p3 = 104 then
12201: LD_VAR 0 3
12205: PUSH
12206: LD_INT 104
12208: EQUAL
12209: IFFALSE 12219
// sReset := true ;
12211: LD_ADDR_EXP 39
12215: PUSH
12216: LD_INT 1
12218: ST_TO_ADDR
// if p3 = 105 then
12219: LD_VAR 0 3
12223: PUSH
12224: LD_INT 105
12226: EQUAL
12227: IFFALSE 12237
// sSun := true ;
12229: LD_ADDR_EXP 40
12233: PUSH
12234: LD_INT 1
12236: ST_TO_ADDR
// if p3 = 106 then
12237: LD_VAR 0 3
12241: PUSH
12242: LD_INT 106
12244: EQUAL
12245: IFFALSE 12255
// sTiger := true ;
12247: LD_ADDR_EXP 36
12251: PUSH
12252: LD_INT 1
12254: ST_TO_ADDR
// if p3 = 107 then
12255: LD_VAR 0 3
12259: PUSH
12260: LD_INT 107
12262: EQUAL
12263: IFFALSE 12273
// sBomb := true ;
12265: LD_ADDR_EXP 37
12269: PUSH
12270: LD_INT 1
12272: ST_TO_ADDR
// if p3 = 108 then
12273: LD_VAR 0 3
12277: PUSH
12278: LD_INT 108
12280: EQUAL
12281: IFFALSE 12291
// sWound := true ;
12283: LD_ADDR_EXP 45
12287: PUSH
12288: LD_INT 1
12290: ST_TO_ADDR
// if p3 = 109 then
12291: LD_VAR 0 3
12295: PUSH
12296: LD_INT 109
12298: EQUAL
12299: IFFALSE 12309
// sBetray := true ;
12301: LD_ADDR_EXP 49
12305: PUSH
12306: LD_INT 1
12308: ST_TO_ADDR
// if p3 = 110 then
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 110
12316: EQUAL
12317: IFFALSE 12327
// sContamin := true ;
12319: LD_ADDR_EXP 50
12323: PUSH
12324: LD_INT 1
12326: ST_TO_ADDR
// if p3 = 111 then
12327: LD_VAR 0 3
12331: PUSH
12332: LD_INT 111
12334: EQUAL
12335: IFFALSE 12345
// sOil := true ;
12337: LD_ADDR_EXP 52
12341: PUSH
12342: LD_INT 1
12344: ST_TO_ADDR
// if p3 = 112 then
12345: LD_VAR 0 3
12349: PUSH
12350: LD_INT 112
12352: EQUAL
12353: IFFALSE 12363
// sStu := true ;
12355: LD_ADDR_EXP 56
12359: PUSH
12360: LD_INT 1
12362: ST_TO_ADDR
// end ; end ;
12363: PPOPN 6
12365: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12366: LD_EXP 19
12370: PUSH
12371: LD_EXP 22
12375: AND
12376: IFFALSE 12500
12378: GO 12380
12380: DISABLE
12381: LD_INT 0
12383: PPUSH
12384: PPUSH
// begin enable ;
12385: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12386: LD_ADDR_VAR 0 2
12390: PUSH
12391: LD_INT 22
12393: PUSH
12394: LD_OWVAR 2
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: PUSH
12403: LD_INT 2
12405: PUSH
12406: LD_INT 34
12408: PUSH
12409: LD_INT 7
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: PUSH
12416: LD_INT 34
12418: PUSH
12419: LD_INT 45
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: PUSH
12426: LD_INT 34
12428: PUSH
12429: LD_INT 28
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: PUSH
12436: LD_INT 34
12438: PUSH
12439: LD_INT 47
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PPUSH
12457: CALL_OW 69
12461: ST_TO_ADDR
// if not tmp then
12462: LD_VAR 0 2
12466: NOT
12467: IFFALSE 12471
// exit ;
12469: GO 12500
// for i in tmp do
12471: LD_ADDR_VAR 0 1
12475: PUSH
12476: LD_VAR 0 2
12480: PUSH
12481: FOR_IN
12482: IFFALSE 12498
// begin SetLives ( i , 0 ) ;
12484: LD_VAR 0 1
12488: PPUSH
12489: LD_INT 0
12491: PPUSH
12492: CALL_OW 234
// end ;
12496: GO 12481
12498: POP
12499: POP
// end ;
12500: PPOPN 2
12502: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12503: LD_EXP 19
12507: PUSH
12508: LD_EXP 23
12512: AND
12513: IFFALSE 12594
12515: GO 12517
12517: DISABLE
12518: LD_INT 0
12520: PPUSH
12521: PPUSH
// begin enable ;
12522: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12523: LD_ADDR_VAR 0 2
12527: PUSH
12528: LD_INT 22
12530: PUSH
12531: LD_OWVAR 2
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PUSH
12540: LD_INT 32
12542: PUSH
12543: LD_INT 3
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PPUSH
12554: CALL_OW 69
12558: ST_TO_ADDR
// if not tmp then
12559: LD_VAR 0 2
12563: NOT
12564: IFFALSE 12568
// exit ;
12566: GO 12594
// for i in tmp do
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_VAR 0 2
12577: PUSH
12578: FOR_IN
12579: IFFALSE 12592
// begin DestroyUnit ( i ) ;
12581: LD_VAR 0 1
12585: PPUSH
12586: CALL_OW 65
// end ;
12590: GO 12578
12592: POP
12593: POP
// end ;
12594: PPOPN 2
12596: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12597: LD_EXP 19
12601: PUSH
12602: LD_EXP 20
12606: AND
12607: IFFALSE 12700
12609: GO 12611
12611: DISABLE
12612: LD_INT 0
12614: PPUSH
// begin enable ;
12615: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12616: LD_ADDR_VAR 0 1
12620: PUSH
12621: LD_INT 22
12623: PUSH
12624: LD_OWVAR 2
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: PUSH
12633: LD_INT 2
12635: PUSH
12636: LD_INT 25
12638: PUSH
12639: LD_INT 5
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: LD_INT 25
12648: PUSH
12649: LD_INT 9
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: PUSH
12656: LD_INT 25
12658: PUSH
12659: LD_INT 8
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: PPUSH
12676: CALL_OW 69
12680: PUSH
12681: FOR_IN
12682: IFFALSE 12698
// begin SetClass ( i , 1 ) ;
12684: LD_VAR 0 1
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL_OW 336
// end ;
12696: GO 12681
12698: POP
12699: POP
// end ;
12700: PPOPN 1
12702: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12703: LD_EXP 19
12707: PUSH
12708: LD_EXP 21
12712: AND
12713: PUSH
12714: LD_OWVAR 65
12718: PUSH
12719: LD_INT 7
12721: LESS
12722: AND
12723: IFFALSE 12737
12725: GO 12727
12727: DISABLE
// begin enable ;
12728: ENABLE
// game_speed := 7 ;
12729: LD_ADDR_OWVAR 65
12733: PUSH
12734: LD_INT 7
12736: ST_TO_ADDR
// end ;
12737: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12738: LD_EXP 19
12742: PUSH
12743: LD_EXP 24
12747: AND
12748: IFFALSE 12950
12750: GO 12752
12752: DISABLE
12753: LD_INT 0
12755: PPUSH
12756: PPUSH
12757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_INT 81
12765: PUSH
12766: LD_OWVAR 2
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 21
12777: PUSH
12778: LD_INT 1
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PPUSH
12789: CALL_OW 69
12793: ST_TO_ADDR
// if not tmp then
12794: LD_VAR 0 3
12798: NOT
12799: IFFALSE 12803
// exit ;
12801: GO 12950
// if tmp > 5 then
12803: LD_VAR 0 3
12807: PUSH
12808: LD_INT 5
12810: GREATER
12811: IFFALSE 12823
// k := 5 else
12813: LD_ADDR_VAR 0 2
12817: PUSH
12818: LD_INT 5
12820: ST_TO_ADDR
12821: GO 12833
// k := tmp ;
12823: LD_ADDR_VAR 0 2
12827: PUSH
12828: LD_VAR 0 3
12832: ST_TO_ADDR
// for i := 1 to k do
12833: LD_ADDR_VAR 0 1
12837: PUSH
12838: DOUBLE
12839: LD_INT 1
12841: DEC
12842: ST_TO_ADDR
12843: LD_VAR 0 2
12847: PUSH
12848: FOR_TO
12849: IFFALSE 12948
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12851: LD_VAR 0 3
12855: PUSH
12856: LD_VAR 0 1
12860: ARRAY
12861: PPUSH
12862: LD_VAR 0 1
12866: PUSH
12867: LD_INT 4
12869: MOD
12870: PUSH
12871: LD_INT 1
12873: PLUS
12874: PPUSH
12875: CALL_OW 259
12879: PUSH
12880: LD_INT 10
12882: LESS
12883: IFFALSE 12946
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12885: LD_VAR 0 3
12889: PUSH
12890: LD_VAR 0 1
12894: ARRAY
12895: PPUSH
12896: LD_VAR 0 1
12900: PUSH
12901: LD_INT 4
12903: MOD
12904: PUSH
12905: LD_INT 1
12907: PLUS
12908: PPUSH
12909: LD_VAR 0 3
12913: PUSH
12914: LD_VAR 0 1
12918: ARRAY
12919: PPUSH
12920: LD_VAR 0 1
12924: PUSH
12925: LD_INT 4
12927: MOD
12928: PUSH
12929: LD_INT 1
12931: PLUS
12932: PPUSH
12933: CALL_OW 259
12937: PUSH
12938: LD_INT 1
12940: PLUS
12941: PPUSH
12942: CALL_OW 237
12946: GO 12848
12948: POP
12949: POP
// end ;
12950: PPOPN 3
12952: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12953: LD_EXP 19
12957: PUSH
12958: LD_EXP 25
12962: AND
12963: IFFALSE 12983
12965: GO 12967
12967: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12968: LD_INT 4
12970: PPUSH
12971: LD_OWVAR 2
12975: PPUSH
12976: LD_INT 0
12978: PPUSH
12979: CALL_OW 324
12983: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12984: LD_EXP 19
12988: PUSH
12989: LD_EXP 54
12993: AND
12994: IFFALSE 13014
12996: GO 12998
12998: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12999: LD_INT 19
13001: PPUSH
13002: LD_OWVAR 2
13006: PPUSH
13007: LD_INT 0
13009: PPUSH
13010: CALL_OW 324
13014: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13015: LD_EXP 19
13019: PUSH
13020: LD_EXP 26
13024: AND
13025: IFFALSE 13124
13027: GO 13029
13029: DISABLE
13030: LD_INT 0
13032: PPUSH
13033: PPUSH
// begin enable ;
13034: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13035: LD_ADDR_VAR 0 2
13039: PUSH
13040: LD_INT 22
13042: PUSH
13043: LD_OWVAR 2
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PUSH
13052: LD_INT 2
13054: PUSH
13055: LD_INT 34
13057: PUSH
13058: LD_INT 11
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 34
13067: PUSH
13068: LD_INT 30
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: LIST
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PPUSH
13084: CALL_OW 69
13088: ST_TO_ADDR
// if not tmp then
13089: LD_VAR 0 2
13093: NOT
13094: IFFALSE 13098
// exit ;
13096: GO 13124
// for i in tmp do
13098: LD_ADDR_VAR 0 1
13102: PUSH
13103: LD_VAR 0 2
13107: PUSH
13108: FOR_IN
13109: IFFALSE 13122
// begin DestroyUnit ( i ) ;
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 65
// end ;
13120: GO 13108
13122: POP
13123: POP
// end ;
13124: PPOPN 2
13126: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13127: LD_EXP 19
13131: PUSH
13132: LD_EXP 27
13136: AND
13137: IFFALSE 13157
13139: GO 13141
13141: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13142: LD_INT 32
13144: PPUSH
13145: LD_OWVAR 2
13149: PPUSH
13150: LD_INT 0
13152: PPUSH
13153: CALL_OW 324
13157: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13158: LD_EXP 19
13162: PUSH
13163: LD_EXP 28
13167: AND
13168: IFFALSE 13349
13170: GO 13172
13172: DISABLE
13173: LD_INT 0
13175: PPUSH
13176: PPUSH
13177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13178: LD_ADDR_VAR 0 2
13182: PUSH
13183: LD_INT 22
13185: PUSH
13186: LD_OWVAR 2
13190: PUSH
13191: EMPTY
13192: LIST
13193: LIST
13194: PUSH
13195: LD_INT 33
13197: PUSH
13198: LD_INT 3
13200: PUSH
13201: EMPTY
13202: LIST
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: ST_TO_ADDR
// if not tmp then
13214: LD_VAR 0 2
13218: NOT
13219: IFFALSE 13223
// exit ;
13221: GO 13349
// side := 0 ;
13223: LD_ADDR_VAR 0 3
13227: PUSH
13228: LD_INT 0
13230: ST_TO_ADDR
// for i := 1 to 8 do
13231: LD_ADDR_VAR 0 1
13235: PUSH
13236: DOUBLE
13237: LD_INT 1
13239: DEC
13240: ST_TO_ADDR
13241: LD_INT 8
13243: PUSH
13244: FOR_TO
13245: IFFALSE 13293
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13247: LD_OWVAR 2
13251: PUSH
13252: LD_VAR 0 1
13256: NONEQUAL
13257: PUSH
13258: LD_OWVAR 2
13262: PPUSH
13263: LD_VAR 0 1
13267: PPUSH
13268: CALL_OW 81
13272: PUSH
13273: LD_INT 2
13275: EQUAL
13276: AND
13277: IFFALSE 13291
// begin side := i ;
13279: LD_ADDR_VAR 0 3
13283: PUSH
13284: LD_VAR 0 1
13288: ST_TO_ADDR
// break ;
13289: GO 13293
// end ;
13291: GO 13244
13293: POP
13294: POP
// if not side then
13295: LD_VAR 0 3
13299: NOT
13300: IFFALSE 13304
// exit ;
13302: GO 13349
// for i := 1 to tmp do
13304: LD_ADDR_VAR 0 1
13308: PUSH
13309: DOUBLE
13310: LD_INT 1
13312: DEC
13313: ST_TO_ADDR
13314: LD_VAR 0 2
13318: PUSH
13319: FOR_TO
13320: IFFALSE 13347
// if Prob ( 30 ) then
13322: LD_INT 30
13324: PPUSH
13325: CALL_OW 13
13329: IFFALSE 13345
// SetSide ( i , side ) ;
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_VAR 0 3
13340: PPUSH
13341: CALL_OW 235
13345: GO 13319
13347: POP
13348: POP
// end ;
13349: PPOPN 3
13351: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13352: LD_EXP 19
13356: PUSH
13357: LD_EXP 30
13361: AND
13362: IFFALSE 13481
13364: GO 13366
13366: DISABLE
13367: LD_INT 0
13369: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13370: LD_ADDR_VAR 0 1
13374: PUSH
13375: LD_INT 22
13377: PUSH
13378: LD_OWVAR 2
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PUSH
13387: LD_INT 21
13389: PUSH
13390: LD_INT 1
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 3
13399: PUSH
13400: LD_INT 23
13402: PUSH
13403: LD_INT 0
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: PPUSH
13419: CALL_OW 69
13423: PUSH
13424: FOR_IN
13425: IFFALSE 13479
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13427: LD_VAR 0 1
13431: PPUSH
13432: CALL_OW 257
13436: PUSH
13437: LD_INT 1
13439: PUSH
13440: LD_INT 2
13442: PUSH
13443: LD_INT 3
13445: PUSH
13446: LD_INT 4
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: IN
13455: IFFALSE 13477
// SetClass ( un , rand ( 1 , 4 ) ) ;
13457: LD_VAR 0 1
13461: PPUSH
13462: LD_INT 1
13464: PPUSH
13465: LD_INT 4
13467: PPUSH
13468: CALL_OW 12
13472: PPUSH
13473: CALL_OW 336
13477: GO 13424
13479: POP
13480: POP
// end ;
13481: PPOPN 1
13483: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13484: LD_EXP 19
13488: PUSH
13489: LD_EXP 29
13493: AND
13494: IFFALSE 13573
13496: GO 13498
13498: DISABLE
13499: LD_INT 0
13501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13502: LD_ADDR_VAR 0 1
13506: PUSH
13507: LD_INT 22
13509: PUSH
13510: LD_OWVAR 2
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: LD_INT 21
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PPUSH
13533: CALL_OW 69
13537: ST_TO_ADDR
// if not tmp then
13538: LD_VAR 0 1
13542: NOT
13543: IFFALSE 13547
// exit ;
13545: GO 13573
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13547: LD_VAR 0 1
13551: PUSH
13552: LD_INT 1
13554: PPUSH
13555: LD_VAR 0 1
13559: PPUSH
13560: CALL_OW 12
13564: ARRAY
13565: PPUSH
13566: LD_INT 100
13568: PPUSH
13569: CALL_OW 234
// end ;
13573: PPOPN 1
13575: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13576: LD_EXP 19
13580: PUSH
13581: LD_EXP 31
13585: AND
13586: IFFALSE 13684
13588: GO 13590
13590: DISABLE
13591: LD_INT 0
13593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13594: LD_ADDR_VAR 0 1
13598: PUSH
13599: LD_INT 22
13601: PUSH
13602: LD_OWVAR 2
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 21
13613: PUSH
13614: LD_INT 1
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PPUSH
13625: CALL_OW 69
13629: ST_TO_ADDR
// if not tmp then
13630: LD_VAR 0 1
13634: NOT
13635: IFFALSE 13639
// exit ;
13637: GO 13684
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13639: LD_VAR 0 1
13643: PUSH
13644: LD_INT 1
13646: PPUSH
13647: LD_VAR 0 1
13651: PPUSH
13652: CALL_OW 12
13656: ARRAY
13657: PPUSH
13658: LD_INT 1
13660: PPUSH
13661: LD_INT 4
13663: PPUSH
13664: CALL_OW 12
13668: PPUSH
13669: LD_INT 3000
13671: PPUSH
13672: LD_INT 9000
13674: PPUSH
13675: CALL_OW 12
13679: PPUSH
13680: CALL_OW 492
// end ;
13684: PPOPN 1
13686: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13687: LD_EXP 19
13691: PUSH
13692: LD_EXP 32
13696: AND
13697: IFFALSE 13717
13699: GO 13701
13701: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13702: LD_INT 1
13704: PPUSH
13705: LD_OWVAR 2
13709: PPUSH
13710: LD_INT 0
13712: PPUSH
13713: CALL_OW 324
13717: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13718: LD_EXP 19
13722: PUSH
13723: LD_EXP 33
13727: AND
13728: IFFALSE 13811
13730: GO 13732
13732: DISABLE
13733: LD_INT 0
13735: PPUSH
13736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13737: LD_ADDR_VAR 0 2
13741: PUSH
13742: LD_INT 22
13744: PUSH
13745: LD_OWVAR 2
13749: PUSH
13750: EMPTY
13751: LIST
13752: LIST
13753: PUSH
13754: LD_INT 21
13756: PUSH
13757: LD_INT 3
13759: PUSH
13760: EMPTY
13761: LIST
13762: LIST
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PPUSH
13768: CALL_OW 69
13772: ST_TO_ADDR
// if not tmp then
13773: LD_VAR 0 2
13777: NOT
13778: IFFALSE 13782
// exit ;
13780: GO 13811
// for i in tmp do
13782: LD_ADDR_VAR 0 1
13786: PUSH
13787: LD_VAR 0 2
13791: PUSH
13792: FOR_IN
13793: IFFALSE 13809
// SetBLevel ( i , 10 ) ;
13795: LD_VAR 0 1
13799: PPUSH
13800: LD_INT 10
13802: PPUSH
13803: CALL_OW 241
13807: GO 13792
13809: POP
13810: POP
// end ;
13811: PPOPN 2
13813: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
13814: LD_EXP 19
13818: PUSH
13819: LD_EXP 34
13823: AND
13824: IFFALSE 13935
13826: GO 13828
13828: DISABLE
13829: LD_INT 0
13831: PPUSH
13832: PPUSH
13833: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 22
13841: PUSH
13842: LD_OWVAR 2
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: LD_INT 25
13853: PUSH
13854: LD_INT 1
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PPUSH
13865: CALL_OW 69
13869: ST_TO_ADDR
// if not tmp then
13870: LD_VAR 0 3
13874: NOT
13875: IFFALSE 13879
// exit ;
13877: GO 13935
// un := tmp [ rand ( 1 , tmp ) ] ;
13879: LD_ADDR_VAR 0 2
13883: PUSH
13884: LD_VAR 0 3
13888: PUSH
13889: LD_INT 1
13891: PPUSH
13892: LD_VAR 0 3
13896: PPUSH
13897: CALL_OW 12
13901: ARRAY
13902: ST_TO_ADDR
// if Crawls ( un ) then
13903: LD_VAR 0 2
13907: PPUSH
13908: CALL_OW 318
13912: IFFALSE 13923
// ComWalk ( un ) ;
13914: LD_VAR 0 2
13918: PPUSH
13919: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13923: LD_VAR 0 2
13927: PPUSH
13928: LD_INT 5
13930: PPUSH
13931: CALL_OW 336
// end ;
13935: PPOPN 3
13937: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13938: LD_EXP 19
13942: PUSH
13943: LD_EXP 35
13947: AND
13948: PUSH
13949: LD_OWVAR 67
13953: PUSH
13954: LD_INT 3
13956: LESS
13957: AND
13958: IFFALSE 13977
13960: GO 13962
13962: DISABLE
// Difficulty := Difficulty + 1 ;
13963: LD_ADDR_OWVAR 67
13967: PUSH
13968: LD_OWVAR 67
13972: PUSH
13973: LD_INT 1
13975: PLUS
13976: ST_TO_ADDR
13977: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13978: LD_EXP 19
13982: PUSH
13983: LD_EXP 36
13987: AND
13988: IFFALSE 14091
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
// begin for i := 1 to 5 do
13996: LD_ADDR_VAR 0 1
14000: PUSH
14001: DOUBLE
14002: LD_INT 1
14004: DEC
14005: ST_TO_ADDR
14006: LD_INT 5
14008: PUSH
14009: FOR_TO
14010: IFFALSE 14089
// begin uc_nation := nation_nature ;
14012: LD_ADDR_OWVAR 21
14016: PUSH
14017: LD_INT 0
14019: ST_TO_ADDR
// uc_side := 0 ;
14020: LD_ADDR_OWVAR 20
14024: PUSH
14025: LD_INT 0
14027: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14028: LD_ADDR_OWVAR 29
14032: PUSH
14033: LD_INT 12
14035: PUSH
14036: LD_INT 12
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: ST_TO_ADDR
// hc_agressivity := 20 ;
14043: LD_ADDR_OWVAR 35
14047: PUSH
14048: LD_INT 20
14050: ST_TO_ADDR
// hc_class := class_tiger ;
14051: LD_ADDR_OWVAR 28
14055: PUSH
14056: LD_INT 14
14058: ST_TO_ADDR
// hc_gallery :=  ;
14059: LD_ADDR_OWVAR 33
14063: PUSH
14064: LD_STRING 
14066: ST_TO_ADDR
// hc_name :=  ;
14067: LD_ADDR_OWVAR 26
14071: PUSH
14072: LD_STRING 
14074: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14075: CALL_OW 44
14079: PPUSH
14080: LD_INT 0
14082: PPUSH
14083: CALL_OW 51
// end ;
14087: GO 14009
14089: POP
14090: POP
// end ;
14091: PPOPN 1
14093: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
14094: LD_EXP 19
14098: PUSH
14099: LD_EXP 37
14103: AND
14104: IFFALSE 14278
14106: GO 14108
14108: DISABLE
14109: LD_INT 0
14111: PPUSH
14112: PPUSH
14113: PPUSH
14114: PPUSH
// begin result := false ;
14115: LD_ADDR_VAR 0 4
14119: PUSH
14120: LD_INT 0
14122: ST_TO_ADDR
// for i := 1 to 8 do
14123: LD_ADDR_VAR 0 1
14127: PUSH
14128: DOUBLE
14129: LD_INT 1
14131: DEC
14132: ST_TO_ADDR
14133: LD_INT 8
14135: PUSH
14136: FOR_TO
14137: IFFALSE 14248
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
14139: LD_ADDR_VAR 0 2
14143: PUSH
14144: LD_INT 10
14146: PUSH
14147: LD_INT 50
14149: PUSH
14150: LD_INT 90
14152: PUSH
14153: LD_INT 140
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 1
14164: PPUSH
14165: LD_INT 4
14167: PPUSH
14168: CALL_OW 12
14172: ARRAY
14173: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
14174: LD_ADDR_VAR 0 3
14178: PUSH
14179: LD_INT 10
14181: PUSH
14182: LD_INT 50
14184: PUSH
14185: LD_INT 90
14187: PUSH
14188: LD_INT 140
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: PUSH
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 4
14202: PPUSH
14203: CALL_OW 12
14207: ARRAY
14208: ST_TO_ADDR
// if ValidHex ( x , y ) then
14209: LD_VAR 0 2
14213: PPUSH
14214: LD_VAR 0 3
14218: PPUSH
14219: CALL_OW 488
14223: IFFALSE 14246
// begin result := [ x , y ] ;
14225: LD_ADDR_VAR 0 4
14229: PUSH
14230: LD_VAR 0 2
14234: PUSH
14235: LD_VAR 0 3
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: ST_TO_ADDR
// break ;
14244: GO 14248
// end ; end ;
14246: GO 14136
14248: POP
14249: POP
// if result then
14250: LD_VAR 0 4
14254: IFFALSE 14278
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14256: LD_VAR 0 4
14260: PUSH
14261: LD_INT 1
14263: ARRAY
14264: PPUSH
14265: LD_VAR 0 4
14269: PUSH
14270: LD_INT 2
14272: ARRAY
14273: PPUSH
14274: CALL_OW 429
// end ;
14278: PPOPN 4
14280: END
// every 0 0$1 trigger StreamModeActive and sReset do
14281: LD_EXP 19
14285: PUSH
14286: LD_EXP 39
14290: AND
14291: IFFALSE 14303
14293: GO 14295
14295: DISABLE
// YouLost (  ) ;
14296: LD_STRING 
14298: PPUSH
14299: CALL_OW 104
14303: END
// every 0 0$1 trigger StreamModeActive and sFog do
14304: LD_EXP 19
14308: PUSH
14309: LD_EXP 38
14313: AND
14314: IFFALSE 14328
14316: GO 14318
14318: DISABLE
// FogOff ( your_side ) ;
14319: LD_OWVAR 2
14323: PPUSH
14324: CALL_OW 344
14328: END
// every 0 0$1 trigger StreamModeActive and sSun do
14329: LD_EXP 19
14333: PUSH
14334: LD_EXP 40
14338: AND
14339: IFFALSE 14367
14341: GO 14343
14343: DISABLE
// begin solar_recharge_percent := 0 ;
14344: LD_ADDR_OWVAR 79
14348: PUSH
14349: LD_INT 0
14351: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14352: LD_INT 10500
14354: PPUSH
14355: CALL_OW 67
// solar_recharge_percent := 100 ;
14359: LD_ADDR_OWVAR 79
14363: PUSH
14364: LD_INT 100
14366: ST_TO_ADDR
// end ;
14367: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14368: LD_EXP 19
14372: PUSH
14373: LD_EXP 41
14377: AND
14378: IFFALSE 14617
14380: GO 14382
14382: DISABLE
14383: LD_INT 0
14385: PPUSH
14386: PPUSH
14387: PPUSH
// begin tmp := [ ] ;
14388: LD_ADDR_VAR 0 3
14392: PUSH
14393: EMPTY
14394: ST_TO_ADDR
// for i := 1 to 6 do
14395: LD_ADDR_VAR 0 1
14399: PUSH
14400: DOUBLE
14401: LD_INT 1
14403: DEC
14404: ST_TO_ADDR
14405: LD_INT 6
14407: PUSH
14408: FOR_TO
14409: IFFALSE 14514
// begin uc_nation := nation_nature ;
14411: LD_ADDR_OWVAR 21
14415: PUSH
14416: LD_INT 0
14418: ST_TO_ADDR
// uc_side := 0 ;
14419: LD_ADDR_OWVAR 20
14423: PUSH
14424: LD_INT 0
14426: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14427: LD_ADDR_OWVAR 29
14431: PUSH
14432: LD_INT 12
14434: PUSH
14435: LD_INT 12
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: ST_TO_ADDR
// hc_agressivity := 20 ;
14442: LD_ADDR_OWVAR 35
14446: PUSH
14447: LD_INT 20
14449: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14450: LD_ADDR_OWVAR 28
14454: PUSH
14455: LD_INT 17
14457: ST_TO_ADDR
// hc_gallery :=  ;
14458: LD_ADDR_OWVAR 33
14462: PUSH
14463: LD_STRING 
14465: ST_TO_ADDR
// hc_name :=  ;
14466: LD_ADDR_OWVAR 26
14470: PUSH
14471: LD_STRING 
14473: ST_TO_ADDR
// un := CreateHuman ;
14474: LD_ADDR_VAR 0 2
14478: PUSH
14479: CALL_OW 44
14483: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14484: LD_VAR 0 2
14488: PPUSH
14489: LD_INT 1
14491: PPUSH
14492: CALL_OW 51
// tmp := tmp * un ;
14496: LD_ADDR_VAR 0 3
14500: PUSH
14501: LD_VAR 0 3
14505: PUSH
14506: LD_VAR 0 2
14510: MUL
14511: ST_TO_ADDR
// end ;
14512: GO 14408
14514: POP
14515: POP
// repeat wait ( 0 0$1 ) ;
14516: LD_INT 35
14518: PPUSH
14519: CALL_OW 67
// for un in tmp do
14523: LD_ADDR_VAR 0 2
14527: PUSH
14528: LD_VAR 0 3
14532: PUSH
14533: FOR_IN
14534: IFFALSE 14608
// begin if IsDead ( un ) then
14536: LD_VAR 0 2
14540: PPUSH
14541: CALL_OW 301
14545: IFFALSE 14565
// begin tmp := tmp diff un ;
14547: LD_ADDR_VAR 0 3
14551: PUSH
14552: LD_VAR 0 3
14556: PUSH
14557: LD_VAR 0 2
14561: DIFF
14562: ST_TO_ADDR
// continue ;
14563: GO 14533
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14565: LD_VAR 0 2
14569: PPUSH
14570: LD_INT 3
14572: PUSH
14573: LD_INT 22
14575: PUSH
14576: LD_INT 0
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PPUSH
14587: CALL_OW 69
14591: PPUSH
14592: LD_VAR 0 2
14596: PPUSH
14597: CALL_OW 74
14601: PPUSH
14602: CALL_OW 115
// end ;
14606: GO 14533
14608: POP
14609: POP
// until not tmp ;
14610: LD_VAR 0 3
14614: NOT
14615: IFFALSE 14516
// end ;
14617: PPOPN 3
14619: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14620: LD_EXP 19
14624: PUSH
14625: LD_EXP 42
14629: AND
14630: IFFALSE 14656
14632: GO 14634
14634: DISABLE
// begin ToLua ( displayTroll(); ) ;
14635: LD_STRING displayTroll();
14637: PPUSH
14638: CALL_OW 559
// wait ( 3 3$00 ) ;
14642: LD_INT 6300
14644: PPUSH
14645: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14649: LD_STRING hideTroll();
14651: PPUSH
14652: CALL_OW 559
// end ;
14656: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14657: LD_EXP 19
14661: PUSH
14662: LD_EXP 43
14666: AND
14667: IFFALSE 14730
14669: GO 14671
14671: DISABLE
14672: LD_INT 0
14674: PPUSH
// begin p := 0 ;
14675: LD_ADDR_VAR 0 1
14679: PUSH
14680: LD_INT 0
14682: ST_TO_ADDR
// repeat game_speed := 1 ;
14683: LD_ADDR_OWVAR 65
14687: PUSH
14688: LD_INT 1
14690: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14691: LD_INT 35
14693: PPUSH
14694: CALL_OW 67
// p := p + 1 ;
14698: LD_ADDR_VAR 0 1
14702: PUSH
14703: LD_VAR 0 1
14707: PUSH
14708: LD_INT 1
14710: PLUS
14711: ST_TO_ADDR
// until p >= 60 ;
14712: LD_VAR 0 1
14716: PUSH
14717: LD_INT 60
14719: GREATEREQUAL
14720: IFFALSE 14683
// game_speed := 4 ;
14722: LD_ADDR_OWVAR 65
14726: PUSH
14727: LD_INT 4
14729: ST_TO_ADDR
// end ;
14730: PPOPN 1
14732: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14733: LD_EXP 19
14737: PUSH
14738: LD_EXP 44
14742: AND
14743: IFFALSE 14889
14745: GO 14747
14747: DISABLE
14748: LD_INT 0
14750: PPUSH
14751: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14752: LD_ADDR_VAR 0 1
14756: PUSH
14757: LD_INT 22
14759: PUSH
14760: LD_OWVAR 2
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: PUSH
14769: LD_INT 2
14771: PUSH
14772: LD_INT 30
14774: PUSH
14775: LD_INT 0
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: PUSH
14782: LD_INT 30
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: LIST
14796: PUSH
14797: EMPTY
14798: LIST
14799: LIST
14800: PPUSH
14801: CALL_OW 69
14805: ST_TO_ADDR
// if not depot then
14806: LD_VAR 0 1
14810: NOT
14811: IFFALSE 14815
// exit ;
14813: GO 14889
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14815: LD_ADDR_VAR 0 2
14819: PUSH
14820: LD_VAR 0 1
14824: PUSH
14825: LD_INT 1
14827: PPUSH
14828: LD_VAR 0 1
14832: PPUSH
14833: CALL_OW 12
14837: ARRAY
14838: PPUSH
14839: CALL_OW 274
14843: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14844: LD_VAR 0 2
14848: PPUSH
14849: LD_INT 1
14851: PPUSH
14852: LD_INT 0
14854: PPUSH
14855: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14859: LD_VAR 0 2
14863: PPUSH
14864: LD_INT 2
14866: PPUSH
14867: LD_INT 0
14869: PPUSH
14870: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14874: LD_VAR 0 2
14878: PPUSH
14879: LD_INT 3
14881: PPUSH
14882: LD_INT 0
14884: PPUSH
14885: CALL_OW 277
// end ;
14889: PPOPN 2
14891: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14892: LD_EXP 19
14896: PUSH
14897: LD_EXP 45
14901: AND
14902: IFFALSE 14999
14904: GO 14906
14906: DISABLE
14907: LD_INT 0
14909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14910: LD_ADDR_VAR 0 1
14914: PUSH
14915: LD_INT 22
14917: PUSH
14918: LD_OWVAR 2
14922: PUSH
14923: EMPTY
14924: LIST
14925: LIST
14926: PUSH
14927: LD_INT 21
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 3
14939: PUSH
14940: LD_INT 23
14942: PUSH
14943: LD_INT 0
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PUSH
14954: EMPTY
14955: LIST
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 69
14963: ST_TO_ADDR
// if not tmp then
14964: LD_VAR 0 1
14968: NOT
14969: IFFALSE 14973
// exit ;
14971: GO 14999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14973: LD_VAR 0 1
14977: PUSH
14978: LD_INT 1
14980: PPUSH
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 12
14990: ARRAY
14991: PPUSH
14992: LD_INT 200
14994: PPUSH
14995: CALL_OW 234
// end ;
14999: PPOPN 1
15001: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15002: LD_EXP 19
15006: PUSH
15007: LD_EXP 46
15011: AND
15012: IFFALSE 15091
15014: GO 15016
15016: DISABLE
15017: LD_INT 0
15019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15020: LD_ADDR_VAR 0 1
15024: PUSH
15025: LD_INT 22
15027: PUSH
15028: LD_OWVAR 2
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: PUSH
15037: LD_INT 21
15039: PUSH
15040: LD_INT 2
15042: PUSH
15043: EMPTY
15044: LIST
15045: LIST
15046: PUSH
15047: EMPTY
15048: LIST
15049: LIST
15050: PPUSH
15051: CALL_OW 69
15055: ST_TO_ADDR
// if not tmp then
15056: LD_VAR 0 1
15060: NOT
15061: IFFALSE 15065
// exit ;
15063: GO 15091
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15065: LD_VAR 0 1
15069: PUSH
15070: LD_INT 1
15072: PPUSH
15073: LD_VAR 0 1
15077: PPUSH
15078: CALL_OW 12
15082: ARRAY
15083: PPUSH
15084: LD_INT 60
15086: PPUSH
15087: CALL_OW 234
// end ;
15091: PPOPN 1
15093: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15094: LD_EXP 19
15098: PUSH
15099: LD_EXP 47
15103: AND
15104: IFFALSE 15203
15106: GO 15108
15108: DISABLE
15109: LD_INT 0
15111: PPUSH
15112: PPUSH
// begin enable ;
15113: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15114: LD_ADDR_VAR 0 1
15118: PUSH
15119: LD_INT 22
15121: PUSH
15122: LD_OWVAR 2
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 61
15133: PUSH
15134: EMPTY
15135: LIST
15136: PUSH
15137: LD_INT 33
15139: PUSH
15140: LD_INT 2
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: LIST
15151: PPUSH
15152: CALL_OW 69
15156: ST_TO_ADDR
// if not tmp then
15157: LD_VAR 0 1
15161: NOT
15162: IFFALSE 15166
// exit ;
15164: GO 15203
// for i in tmp do
15166: LD_ADDR_VAR 0 2
15170: PUSH
15171: LD_VAR 0 1
15175: PUSH
15176: FOR_IN
15177: IFFALSE 15201
// if IsControledBy ( i ) then
15179: LD_VAR 0 2
15183: PPUSH
15184: CALL_OW 312
15188: IFFALSE 15199
// ComUnlink ( i ) ;
15190: LD_VAR 0 2
15194: PPUSH
15195: CALL_OW 136
15199: GO 15176
15201: POP
15202: POP
// end ;
15203: PPOPN 2
15205: END
// every 0 0$1 trigger StreamModeActive and sPowell do
15206: LD_EXP 19
15210: PUSH
15211: LD_EXP 48
15215: AND
15216: IFFALSE 15256
15218: GO 15220
15220: DISABLE
// begin ToLua ( displayPowell(); ) ;
15221: LD_STRING displayPowell();
15223: PPUSH
15224: CALL_OW 559
// wait ( 0 0$20 ) ;
15228: LD_INT 700
15230: PPUSH
15231: CALL_OW 67
// ToLua ( displayPowell(); ) ;
15235: LD_STRING displayPowell();
15237: PPUSH
15238: CALL_OW 559
// wait ( 0 0$40 ) ;
15242: LD_INT 1400
15244: PPUSH
15245: CALL_OW 67
// ToLua ( displayPowell(); ) ;
15249: LD_STRING displayPowell();
15251: PPUSH
15252: CALL_OW 559
// end ;
15256: END
// every 0 0$1 trigger StreamModeActive and sStu do
15257: LD_EXP 19
15261: PUSH
15262: LD_EXP 56
15266: AND
15267: IFFALSE 15279
15269: GO 15271
15271: DISABLE
// begin ToLua ( displayStucuk(); ) ;
15272: LD_STRING displayStucuk();
15274: PPUSH
15275: CALL_OW 559
// end ;
15279: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
15280: LD_EXP 19
15284: PUSH
15285: LD_EXP 49
15289: AND
15290: IFFALSE 15431
15292: GO 15294
15294: DISABLE
15295: LD_INT 0
15297: PPUSH
15298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15299: LD_ADDR_VAR 0 2
15303: PUSH
15304: LD_INT 22
15306: PUSH
15307: LD_OWVAR 2
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 21
15318: PUSH
15319: LD_INT 1
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: PPUSH
15330: CALL_OW 69
15334: ST_TO_ADDR
// if not tmp then
15335: LD_VAR 0 2
15339: NOT
15340: IFFALSE 15344
// exit ;
15342: GO 15431
// un := tmp [ rand ( 1 , tmp ) ] ;
15344: LD_ADDR_VAR 0 1
15348: PUSH
15349: LD_VAR 0 2
15353: PUSH
15354: LD_INT 1
15356: PPUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: CALL_OW 12
15366: ARRAY
15367: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15368: LD_VAR 0 1
15372: PPUSH
15373: LD_INT 0
15375: PPUSH
15376: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15380: LD_VAR 0 1
15384: PPUSH
15385: LD_OWVAR 3
15389: PUSH
15390: LD_VAR 0 1
15394: DIFF
15395: PPUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 74
15405: PPUSH
15406: CALL_OW 115
// wait ( 0 0$20 ) ;
15410: LD_INT 700
15412: PPUSH
15413: CALL_OW 67
// SetSide ( un , your_side ) ;
15417: LD_VAR 0 1
15421: PPUSH
15422: LD_OWVAR 2
15426: PPUSH
15427: CALL_OW 235
// end ;
15431: PPOPN 2
15433: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15434: LD_EXP 19
15438: PUSH
15439: LD_EXP 50
15443: AND
15444: IFFALSE 15550
15446: GO 15448
15448: DISABLE
15449: LD_INT 0
15451: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15452: LD_ADDR_VAR 0 1
15456: PUSH
15457: LD_INT 22
15459: PUSH
15460: LD_OWVAR 2
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: PUSH
15469: LD_INT 2
15471: PUSH
15472: LD_INT 30
15474: PUSH
15475: LD_INT 0
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 30
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: LIST
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PPUSH
15501: CALL_OW 69
15505: ST_TO_ADDR
// if not depot then
15506: LD_VAR 0 1
15510: NOT
15511: IFFALSE 15515
// exit ;
15513: GO 15550
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15515: LD_VAR 0 1
15519: PUSH
15520: LD_INT 1
15522: ARRAY
15523: PPUSH
15524: CALL_OW 250
15528: PPUSH
15529: LD_VAR 0 1
15533: PUSH
15534: LD_INT 1
15536: ARRAY
15537: PPUSH
15538: CALL_OW 251
15542: PPUSH
15543: LD_INT 70
15545: PPUSH
15546: CALL_OW 495
// end ;
15550: PPOPN 1
15552: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
15553: LD_EXP 19
15557: PUSH
15558: LD_EXP 51
15562: AND
15563: IFFALSE 15774
15565: GO 15567
15567: DISABLE
15568: LD_INT 0
15570: PPUSH
15571: PPUSH
15572: PPUSH
15573: PPUSH
15574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15575: LD_ADDR_VAR 0 5
15579: PUSH
15580: LD_INT 22
15582: PUSH
15583: LD_OWVAR 2
15587: PUSH
15588: EMPTY
15589: LIST
15590: LIST
15591: PUSH
15592: LD_INT 21
15594: PUSH
15595: LD_INT 1
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PPUSH
15606: CALL_OW 69
15610: ST_TO_ADDR
// if not tmp then
15611: LD_VAR 0 5
15615: NOT
15616: IFFALSE 15620
// exit ;
15618: GO 15774
// for i in tmp do
15620: LD_ADDR_VAR 0 1
15624: PUSH
15625: LD_VAR 0 5
15629: PUSH
15630: FOR_IN
15631: IFFALSE 15772
// begin d := rand ( 0 , 5 ) ;
15633: LD_ADDR_VAR 0 4
15637: PUSH
15638: LD_INT 0
15640: PPUSH
15641: LD_INT 5
15643: PPUSH
15644: CALL_OW 12
15648: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15649: LD_ADDR_VAR 0 2
15653: PUSH
15654: LD_VAR 0 1
15658: PPUSH
15659: CALL_OW 250
15663: PPUSH
15664: LD_VAR 0 4
15668: PPUSH
15669: LD_INT 3
15671: PPUSH
15672: LD_INT 12
15674: PPUSH
15675: CALL_OW 12
15679: PPUSH
15680: CALL_OW 272
15684: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15685: LD_ADDR_VAR 0 3
15689: PUSH
15690: LD_VAR 0 1
15694: PPUSH
15695: CALL_OW 251
15699: PPUSH
15700: LD_VAR 0 4
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: LD_INT 12
15710: PPUSH
15711: CALL_OW 12
15715: PPUSH
15716: CALL_OW 273
15720: ST_TO_ADDR
// if ValidHex ( x , y ) then
15721: LD_VAR 0 2
15725: PPUSH
15726: LD_VAR 0 3
15730: PPUSH
15731: CALL_OW 488
15735: IFFALSE 15770
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15737: LD_VAR 0 1
15741: PPUSH
15742: LD_VAR 0 2
15746: PPUSH
15747: LD_VAR 0 3
15751: PPUSH
15752: LD_INT 3
15754: PPUSH
15755: LD_INT 6
15757: PPUSH
15758: CALL_OW 12
15762: PPUSH
15763: LD_INT 1
15765: PPUSH
15766: CALL_OW 483
// end ;
15770: GO 15630
15772: POP
15773: POP
// end ;
15774: PPOPN 5
15776: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15777: LD_EXP 19
15781: PUSH
15782: LD_EXP 52
15786: AND
15787: IFFALSE 15881
15789: GO 15791
15791: DISABLE
15792: LD_INT 0
15794: PPUSH
15795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15796: LD_ADDR_VAR 0 2
15800: PUSH
15801: LD_INT 22
15803: PUSH
15804: LD_OWVAR 2
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: LD_INT 32
15815: PUSH
15816: LD_INT 1
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: LD_INT 21
15825: PUSH
15826: LD_INT 2
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: LIST
15837: PPUSH
15838: CALL_OW 69
15842: ST_TO_ADDR
// if not tmp then
15843: LD_VAR 0 2
15847: NOT
15848: IFFALSE 15852
// exit ;
15850: GO 15881
// for i in tmp do
15852: LD_ADDR_VAR 0 1
15856: PUSH
15857: LD_VAR 0 2
15861: PUSH
15862: FOR_IN
15863: IFFALSE 15879
// SetFuel ( i , 0 ) ;
15865: LD_VAR 0 1
15869: PPUSH
15870: LD_INT 0
15872: PPUSH
15873: CALL_OW 240
15877: GO 15862
15879: POP
15880: POP
// end ;
15881: PPOPN 2
15883: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15884: LD_EXP 19
15888: PUSH
15889: LD_EXP 53
15893: AND
15894: IFFALSE 15960
15896: GO 15898
15898: DISABLE
15899: LD_INT 0
15901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15902: LD_ADDR_VAR 0 1
15906: PUSH
15907: LD_INT 22
15909: PUSH
15910: LD_OWVAR 2
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: PUSH
15919: LD_INT 30
15921: PUSH
15922: LD_INT 29
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PPUSH
15933: CALL_OW 69
15937: ST_TO_ADDR
// if not tmp then
15938: LD_VAR 0 1
15942: NOT
15943: IFFALSE 15947
// exit ;
15945: GO 15960
// DestroyUnit ( tmp [ 1 ] ) ;
15947: LD_VAR 0 1
15951: PUSH
15952: LD_INT 1
15954: ARRAY
15955: PPUSH
15956: CALL_OW 65
// end ;
15960: PPOPN 1
15962: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15963: LD_EXP 19
15967: PUSH
15968: LD_EXP 55
15972: AND
15973: IFFALSE 16086
15975: GO 15977
15977: DISABLE
15978: LD_INT 0
15980: PPUSH
// begin uc_side := 0 ;
15981: LD_ADDR_OWVAR 20
15985: PUSH
15986: LD_INT 0
15988: ST_TO_ADDR
// uc_nation := nation_arabian ;
15989: LD_ADDR_OWVAR 21
15993: PUSH
15994: LD_INT 2
15996: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
15997: LD_INT 1
15999: PPUSH
16000: LD_INT 10
16002: PPUSH
16003: LD_INT 11
16005: PPUSH
16006: CALL_OW 380
// un := CreateHuman ;
16010: LD_ADDR_VAR 0 1
16014: PUSH
16015: CALL_OW 44
16019: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16020: LD_VAR 0 1
16024: PPUSH
16025: LD_INT 1
16027: PPUSH
16028: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16032: LD_INT 35
16034: PPUSH
16035: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_INT 22
16046: PUSH
16047: LD_OWVAR 2
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PPUSH
16056: CALL_OW 69
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: CALL_OW 74
16070: PPUSH
16071: CALL_OW 115
// until IsDead ( un ) ;
16075: LD_VAR 0 1
16079: PPUSH
16080: CALL_OW 301
16084: IFFALSE 16032
// end ; end_of_file
16086: PPOPN 1
16088: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
16089: LD_INT 0
16091: PPUSH
16092: PPUSH
16093: PPUSH
16094: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
16095: LD_VAR 0 1
16099: PPUSH
16100: CALL_OW 264
16104: PUSH
16105: LD_EXP 18
16109: EQUAL
16110: IFFALSE 16182
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
16112: LD_INT 68
16114: PPUSH
16115: LD_VAR 0 1
16119: PPUSH
16120: CALL_OW 255
16124: PPUSH
16125: CALL_OW 321
16129: PUSH
16130: LD_INT 2
16132: EQUAL
16133: IFFALSE 16145
// eff := 70 else
16135: LD_ADDR_VAR 0 6
16139: PUSH
16140: LD_INT 70
16142: ST_TO_ADDR
16143: GO 16153
// eff := 30 ;
16145: LD_ADDR_VAR 0 6
16149: PUSH
16150: LD_INT 30
16152: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
16153: LD_VAR 0 1
16157: PPUSH
16158: CALL_OW 250
16162: PPUSH
16163: LD_VAR 0 1
16167: PPUSH
16168: CALL_OW 251
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 495
// end ; end ;
16182: LD_VAR 0 4
16186: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
16187: LD_INT 0
16189: PPUSH
16190: PPUSH
16191: PPUSH
16192: PPUSH
16193: PPUSH
16194: PPUSH
// if cmd = 124 then
16195: LD_VAR 0 1
16199: PUSH
16200: LD_INT 124
16202: EQUAL
16203: IFFALSE 16409
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
16205: LD_ADDR_VAR 0 5
16209: PUSH
16210: LD_INT 2
16212: PUSH
16213: LD_INT 34
16215: PUSH
16216: LD_INT 53
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: LD_INT 34
16225: PUSH
16226: LD_INT 14
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: LIST
16237: PPUSH
16238: CALL_OW 69
16242: ST_TO_ADDR
// if not tmp then
16243: LD_VAR 0 5
16247: NOT
16248: IFFALSE 16252
// exit ;
16250: GO 16409
// for i in tmp do
16252: LD_ADDR_VAR 0 3
16256: PUSH
16257: LD_VAR 0 5
16261: PUSH
16262: FOR_IN
16263: IFFALSE 16407
// begin taskList := GetTaskList ( i ) ;
16265: LD_ADDR_VAR 0 6
16269: PUSH
16270: LD_VAR 0 3
16274: PPUSH
16275: CALL_OW 437
16279: ST_TO_ADDR
// if not taskList then
16280: LD_VAR 0 6
16284: NOT
16285: IFFALSE 16289
// continue ;
16287: GO 16262
// for j = 1 to taskList do
16289: LD_ADDR_VAR 0 4
16293: PUSH
16294: DOUBLE
16295: LD_INT 1
16297: DEC
16298: ST_TO_ADDR
16299: LD_VAR 0 6
16303: PUSH
16304: FOR_TO
16305: IFFALSE 16403
// if taskList [ j ] [ 1 ] = | then
16307: LD_VAR 0 6
16311: PUSH
16312: LD_VAR 0 4
16316: ARRAY
16317: PUSH
16318: LD_INT 1
16320: ARRAY
16321: PUSH
16322: LD_STRING |
16324: EQUAL
16325: IFFALSE 16401
// begin _taskList := Delete ( taskList , 1 ) ;
16327: LD_ADDR_VAR 0 7
16331: PUSH
16332: LD_VAR 0 6
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 3
16344: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
16345: LD_VAR 0 3
16349: PPUSH
16350: LD_VAR 0 7
16354: PPUSH
16355: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
16359: LD_VAR 0 3
16363: PPUSH
16364: LD_VAR 0 6
16368: PUSH
16369: LD_VAR 0 4
16373: ARRAY
16374: PUSH
16375: LD_INT 2
16377: ARRAY
16378: PPUSH
16379: LD_VAR 0 6
16383: PUSH
16384: LD_VAR 0 4
16388: ARRAY
16389: PUSH
16390: LD_INT 3
16392: ARRAY
16393: PPUSH
16394: LD_INT 8
16396: PPUSH
16397: CALL 16414 0 4
// end ;
16401: GO 16304
16403: POP
16404: POP
// end ;
16405: GO 16262
16407: POP
16408: POP
// end ; end ;
16409: LD_VAR 0 2
16413: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
16414: LD_INT 0
16416: PPUSH
16417: PPUSH
16418: PPUSH
16419: PPUSH
16420: PPUSH
16421: PPUSH
16422: PPUSH
16423: PPUSH
16424: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
16425: LD_VAR 0 1
16429: NOT
16430: PUSH
16431: LD_VAR 0 2
16435: PPUSH
16436: LD_VAR 0 3
16440: PPUSH
16441: CALL_OW 488
16445: NOT
16446: OR
16447: PUSH
16448: LD_VAR 0 4
16452: NOT
16453: OR
16454: IFFALSE 16458
// exit ;
16456: GO 16798
// list := [ ] ;
16458: LD_ADDR_VAR 0 13
16462: PUSH
16463: EMPTY
16464: ST_TO_ADDR
// if x - r < 0 then
16465: LD_VAR 0 2
16469: PUSH
16470: LD_VAR 0 4
16474: MINUS
16475: PUSH
16476: LD_INT 0
16478: LESS
16479: IFFALSE 16491
// min_x := 0 else
16481: LD_ADDR_VAR 0 7
16485: PUSH
16486: LD_INT 0
16488: ST_TO_ADDR
16489: GO 16507
// min_x := x - r ;
16491: LD_ADDR_VAR 0 7
16495: PUSH
16496: LD_VAR 0 2
16500: PUSH
16501: LD_VAR 0 4
16505: MINUS
16506: ST_TO_ADDR
// if y - r < 0 then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_VAR 0 4
16516: MINUS
16517: PUSH
16518: LD_INT 0
16520: LESS
16521: IFFALSE 16533
// min_y := 0 else
16523: LD_ADDR_VAR 0 8
16527: PUSH
16528: LD_INT 0
16530: ST_TO_ADDR
16531: GO 16549
// min_y := y - r ;
16533: LD_ADDR_VAR 0 8
16537: PUSH
16538: LD_VAR 0 3
16542: PUSH
16543: LD_VAR 0 4
16547: MINUS
16548: ST_TO_ADDR
// max_x := x + r ;
16549: LD_ADDR_VAR 0 9
16553: PUSH
16554: LD_VAR 0 2
16558: PUSH
16559: LD_VAR 0 4
16563: PLUS
16564: ST_TO_ADDR
// max_y := y + r ;
16565: LD_ADDR_VAR 0 10
16569: PUSH
16570: LD_VAR 0 3
16574: PUSH
16575: LD_VAR 0 4
16579: PLUS
16580: ST_TO_ADDR
// for _x = min_x to max_x do
16581: LD_ADDR_VAR 0 11
16585: PUSH
16586: DOUBLE
16587: LD_VAR 0 7
16591: DEC
16592: ST_TO_ADDR
16593: LD_VAR 0 9
16597: PUSH
16598: FOR_TO
16599: IFFALSE 16716
// for _y = min_y to max_y do
16601: LD_ADDR_VAR 0 12
16605: PUSH
16606: DOUBLE
16607: LD_VAR 0 8
16611: DEC
16612: ST_TO_ADDR
16613: LD_VAR 0 10
16617: PUSH
16618: FOR_TO
16619: IFFALSE 16712
// begin if not ValidHex ( _x , _y ) then
16621: LD_VAR 0 11
16625: PPUSH
16626: LD_VAR 0 12
16630: PPUSH
16631: CALL_OW 488
16635: NOT
16636: IFFALSE 16640
// continue ;
16638: GO 16618
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
16640: LD_VAR 0 11
16644: PPUSH
16645: LD_VAR 0 12
16649: PPUSH
16650: CALL_OW 351
16654: PUSH
16655: LD_VAR 0 11
16659: PPUSH
16660: LD_VAR 0 12
16664: PPUSH
16665: CALL_OW 554
16669: AND
16670: IFFALSE 16710
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
16672: LD_ADDR_VAR 0 13
16676: PUSH
16677: LD_VAR 0 13
16681: PPUSH
16682: LD_VAR 0 13
16686: PUSH
16687: LD_INT 1
16689: PLUS
16690: PPUSH
16691: LD_VAR 0 11
16695: PUSH
16696: LD_VAR 0 12
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL_OW 2
16709: ST_TO_ADDR
// end ;
16710: GO 16618
16712: POP
16713: POP
16714: GO 16598
16716: POP
16717: POP
// if not list then
16718: LD_VAR 0 13
16722: NOT
16723: IFFALSE 16727
// exit ;
16725: GO 16798
// for i in list do
16727: LD_ADDR_VAR 0 6
16731: PUSH
16732: LD_VAR 0 13
16736: PUSH
16737: FOR_IN
16738: IFFALSE 16796
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
16740: LD_VAR 0 1
16744: PPUSH
16745: LD_STRING M
16747: PUSH
16748: LD_VAR 0 6
16752: PUSH
16753: LD_INT 1
16755: ARRAY
16756: PUSH
16757: LD_VAR 0 6
16761: PUSH
16762: LD_INT 2
16764: ARRAY
16765: PUSH
16766: LD_INT 0
16768: PUSH
16769: LD_INT 0
16771: PUSH
16772: LD_INT 0
16774: PUSH
16775: LD_INT 0
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: PUSH
16787: EMPTY
16788: LIST
16789: PPUSH
16790: CALL_OW 447
16794: GO 16737
16796: POP
16797: POP
// end ;
16798: LD_VAR 0 5
16802: RET
