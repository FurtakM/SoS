// starting begin InitMap ;
   0: CALL 1433 0 0
// InitTriggers ;
   4: CALL 1818 0 0
// Start_Game ;
   8: CALL 13155 0 0
// InitPlayer ;
  12: CALL 2055 0 0
// InitRussian ;
  16: CALL 2945 0 0
// end ; end_of_file
  20: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
  21: LD_INT 0
  23: PPUSH
  24: PPUSH
  25: PPUSH
  26: PPUSH
  27: PPUSH
// uc_nation = nation_nature ;
  28: LD_ADDR_OWVAR 21
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// uc_side = 0 ;
  36: LD_ADDR_OWVAR 20
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// l = 0 ;
  44: LD_ADDR_VAR 0 6
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
  52: LD_ADDR_OWVAR 24
  56: PUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: CALL_OW 12
  67: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
  68: LD_ADDR_OWVAR 35
  72: PUSH
  73: LD_INT 5
  75: NEG
  76: PPUSH
  77: LD_INT 5
  79: PPUSH
  80: CALL_OW 12
  84: ST_TO_ADDR
// hc_gallery =  ;
  85: LD_ADDR_OWVAR 33
  89: PUSH
  90: LD_STRING 
  92: ST_TO_ADDR
// hc_class = class_apeman ;
  93: LD_ADDR_OWVAR 28
  97: PUSH
  98: LD_INT 12
 100: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 101: LD_ADDR_OWVAR 29
 105: PUSH
 106: LD_INT 11
 108: PPUSH
 109: LD_INT 13
 111: PPUSH
 112: CALL_OW 12
 116: PUSH
 117: LD_INT 10
 119: PPUSH
 120: LD_INT 11
 122: PPUSH
 123: CALL_OW 12
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: ST_TO_ADDR
// hc_sex = sex_male ;
 132: LD_ADDR_OWVAR 27
 136: PUSH
 137: LD_INT 1
 139: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 140: LD_ADDR_OWVAR 31
 144: PUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 2
 150: PPUSH
 151: CALL_OW 12
 155: PUSH
 156: LD_INT 0
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: LIST
 169: LIST
 170: ST_TO_ADDR
// apeman = CreateHuman ;
 171: LD_ADDR_VAR 0 7
 175: PUSH
 176: CALL_OW 44
 180: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 181: LD_VAR 0 7
 185: PPUSH
 186: LD_VAR 0 4
 190: PPUSH
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 49
// l = l + 1 ;
 198: LD_ADDR_VAR 0 6
 202: PUSH
 203: LD_VAR 0 6
 207: PUSH
 208: LD_INT 1
 210: PLUS
 211: ST_TO_ADDR
// end until l = num1 ;
 212: LD_VAR 0 6
 216: PUSH
 217: LD_VAR 0 1
 221: EQUAL
 222: IFFALSE 52
// l = 0 ;
 224: LD_ADDR_VAR 0 6
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 232: LD_ADDR_OWVAR 35
 236: PUSH
 237: LD_INT 0
 239: PPUSH
 240: LD_INT 25
 242: PPUSH
 243: CALL_OW 12
 247: ST_TO_ADDR
// hc_class = class_tiger ;
 248: LD_ADDR_OWVAR 28
 252: PUSH
 253: LD_INT 14
 255: ST_TO_ADDR
// hc_sex = sex_male ;
 256: LD_ADDR_OWVAR 27
 260: PUSH
 261: LD_INT 1
 263: ST_TO_ADDR
// hc_gallery = sandnature ;
 264: LD_ADDR_OWVAR 33
 268: PUSH
 269: LD_STRING sandnature
 271: ST_TO_ADDR
// hc_face_number = 3 ;
 272: LD_ADDR_OWVAR 34
 276: PUSH
 277: LD_INT 3
 279: ST_TO_ADDR
// tiger = CreateHuman ;
 280: LD_ADDR_VAR 0 8
 284: PUSH
 285: CALL_OW 44
 289: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 290: LD_VAR 0 8
 294: PPUSH
 295: LD_VAR 0 4
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL_OW 49
// l = l + 1 ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_INT 1
 319: PLUS
 320: ST_TO_ADDR
// end until l = num2 ;
 321: LD_VAR 0 6
 325: PUSH
 326: LD_VAR 0 2
 330: EQUAL
 331: IFFALSE 232
// l = 0 ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 341: LD_ADDR_OWVAR 28
 345: PUSH
 346: LD_INT 18
 348: ST_TO_ADDR
// hc_gallery = sandnature ;
 349: LD_ADDR_OWVAR 33
 353: PUSH
 354: LD_STRING sandnature
 356: ST_TO_ADDR
// hc_face_number = 1 ;
 357: LD_ADDR_OWVAR 34
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// bird = CreateHuman ;
 365: LD_ADDR_VAR 0 9
 369: PUSH
 370: CALL_OW 44
 374: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 375: LD_VAR 0 9
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: CALL_OW 51
// l = l + 1 ;
 387: LD_ADDR_VAR 0 6
 391: PUSH
 392: LD_VAR 0 6
 396: PUSH
 397: LD_INT 1
 399: PLUS
 400: ST_TO_ADDR
// end until l = num3 ;
 401: LD_VAR 0 6
 405: PUSH
 406: LD_VAR 0 3
 410: EQUAL
 411: IFFALSE 341
// end ;
 413: LD_VAR 0 5
 417: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
 423: PPUSH
 424: PPUSH
 425: PPUSH
// hc_class := clas ;
 426: LD_ADDR_OWVAR 28
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 2
 445: PUSH
 446: LD_INT 1
 448: NEG
 449: PPUSH
 450: LD_INT 1
 452: PPUSH
 453: CALL_OW 12
 457: PLUS
 458: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 459: LD_ADDR_VAR 0 5
 463: PUSH
 464: LD_VAR 0 2
 468: PUSH
 469: LD_INT 1
 471: NEG
 472: PPUSH
 473: LD_INT 1
 475: PPUSH
 476: CALL_OW 12
 480: PLUS
 481: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 482: LD_ADDR_VAR 0 6
 486: PUSH
 487: LD_VAR 0 2
 491: PUSH
 492: LD_INT 1
 494: NEG
 495: PPUSH
 496: LD_INT 1
 498: PPUSH
 499: CALL_OW 12
 503: PLUS
 504: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 505: LD_ADDR_VAR 0 7
 509: PUSH
 510: LD_VAR 0 2
 514: PUSH
 515: LD_INT 1
 517: NEG
 518: PPUSH
 519: LD_INT 1
 521: PPUSH
 522: CALL_OW 12
 526: PLUS
 527: ST_TO_ADDR
// if clas = 1 or clas = 9 then
 528: LD_VAR 0 1
 532: PUSH
 533: LD_INT 1
 535: EQUAL
 536: PUSH
 537: LD_VAR 0 1
 541: PUSH
 542: LD_INT 9
 544: EQUAL
 545: OR
 546: IFFALSE 571
// bonus := [ 2 , 0 , 0 , 0 ] ;
 548: LD_ADDR_VAR 0 8
 552: PUSH
 553: LD_INT 2
 555: PUSH
 556: LD_INT 0
 558: PUSH
 559: LD_INT 0
 561: PUSH
 562: LD_INT 0
 564: PUSH
 565: EMPTY
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: ST_TO_ADDR
// if clas = 2 then
 571: LD_VAR 0 1
 575: PUSH
 576: LD_INT 2
 578: EQUAL
 579: IFFALSE 604
// bonus := [ 0 , 2 , 0 , 0 ] ;
 581: LD_ADDR_VAR 0 8
 585: PUSH
 586: LD_INT 0
 588: PUSH
 589: LD_INT 2
 591: PUSH
 592: LD_INT 0
 594: PUSH
 595: LD_INT 0
 597: PUSH
 598: EMPTY
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: ST_TO_ADDR
// if clas = 3 then
 604: LD_VAR 0 1
 608: PUSH
 609: LD_INT 3
 611: EQUAL
 612: IFFALSE 637
// bonus := [ 0 , 0 , 2 , 0 ] ;
 614: LD_ADDR_VAR 0 8
 618: PUSH
 619: LD_INT 0
 621: PUSH
 622: LD_INT 0
 624: PUSH
 625: LD_INT 2
 627: PUSH
 628: LD_INT 0
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: ST_TO_ADDR
// if clas = 4 then
 637: LD_VAR 0 1
 641: PUSH
 642: LD_INT 4
 644: EQUAL
 645: IFFALSE 670
// bonus := [ 0 , 0 , 0 , 2 ] ;
 647: LD_ADDR_VAR 0 8
 651: PUSH
 652: LD_INT 0
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: LD_INT 0
 660: PUSH
 661: LD_INT 2
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: ST_TO_ADDR
// if clas > 4 and not clas = 9 then
 670: LD_VAR 0 1
 674: PUSH
 675: LD_INT 4
 677: GREATER
 678: PUSH
 679: LD_VAR 0 1
 683: PUSH
 684: LD_INT 9
 686: EQUAL
 687: NOT
 688: AND
 689: IFFALSE 714
// bonus := [ 0 , 0 , 0 , 0 ] ;
 691: LD_ADDR_VAR 0 8
 695: PUSH
 696: LD_INT 0
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 0
 704: PUSH
 705: LD_INT 0
 707: PUSH
 708: EMPTY
 709: LIST
 710: LIST
 711: LIST
 712: LIST
 713: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 714: LD_ADDR_OWVAR 31
 718: PUSH
 719: LD_VAR 0 4
 723: PUSH
 724: LD_VAR 0 8
 728: PUSH
 729: LD_INT 1
 731: ARRAY
 732: PLUS
 733: PUSH
 734: LD_VAR 0 5
 738: PUSH
 739: LD_VAR 0 8
 743: PUSH
 744: LD_INT 2
 746: ARRAY
 747: PLUS
 748: PUSH
 749: LD_VAR 0 6
 753: PUSH
 754: LD_VAR 0 8
 758: PUSH
 759: LD_INT 3
 761: ARRAY
 762: PLUS
 763: PUSH
 764: LD_VAR 0 7
 768: PUSH
 769: LD_VAR 0 8
 773: PUSH
 774: LD_INT 4
 776: ARRAY
 777: PLUS
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: LIST
 783: LIST
 784: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 785: LD_ADDR_OWVAR 27
 789: PUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_INT 2
 795: PPUSH
 796: CALL_OW 12
 800: ST_TO_ADDR
// hc_gallery :=  ;
 801: LD_ADDR_OWVAR 33
 805: PUSH
 806: LD_STRING 
 808: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 809: LD_ADDR_OWVAR 29
 813: PUSH
 814: LD_INT 8
 816: PPUSH
 817: LD_INT 12
 819: PPUSH
 820: CALL_OW 12
 824: PUSH
 825: LD_INT 9
 827: PPUSH
 828: LD_INT 11
 830: PPUSH
 831: CALL_OW 12
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: ST_TO_ADDR
// hc_name :=  ;
 840: LD_ADDR_OWVAR 26
 844: PUSH
 845: LD_STRING 
 847: ST_TO_ADDR
// result := CreateHuman ;
 848: LD_ADDR_VAR 0 3
 852: PUSH
 853: CALL_OW 44
 857: ST_TO_ADDR
// end ;
 858: LD_VAR 0 3
 862: RET
// export function SeeSide ( unit , side ) ; var i ; begin
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
// result := false ;
 867: LD_ADDR_VAR 0 3
 871: PUSH
 872: LD_INT 0
 874: ST_TO_ADDR
// i := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
 875: LD_ADDR_VAR 0 4
 879: PUSH
 880: LD_INT 22
 882: PUSH
 883: LD_VAR 0 2
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: PPUSH
 892: CALL_OW 69
 896: PPUSH
 897: LD_VAR 0 1
 901: PPUSH
 902: CALL_OW 74
 906: ST_TO_ADDR
// if GetDistUnits ( unit , i ) < 9 then
 907: LD_VAR 0 1
 911: PPUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: CALL_OW 296
 921: PUSH
 922: LD_INT 9
 924: LESS
 925: IFFALSE 935
// result := true ;
 927: LD_ADDR_VAR 0 3
 931: PUSH
 932: LD_INT 1
 934: ST_TO_ADDR
// end ;
 935: LD_VAR 0 3
 939: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
 940: LD_VAR 0 1
 944: PUSH
 945: LD_EXP 1
 949: IN
 950: NOT
 951: IFFALSE 982
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
 953: LD_ADDR_EXP 1
 957: PUSH
 958: LD_EXP 1
 962: PPUSH
 963: LD_EXP 1
 967: PUSH
 968: LD_INT 1
 970: PLUS
 971: PPUSH
 972: LD_VAR 0 1
 976: PPUSH
 977: CALL_OW 2
 981: ST_TO_ADDR
// end ;
 982: PPOPN 1
 984: END
// export function ComAttack ( unit , ignore_list ) ; var i , j , target , enemy_list , _list , types_list ; begin
 985: LD_INT 0
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
// if not IsPlaced ( unit ) then
 994: LD_VAR 0 1
 998: PPUSH
 999: CALL_OW 305
1003: NOT
1004: IFFALSE 1008
// exit ;
1006: GO 1315
// enemy_list := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
1008: LD_ADDR_VAR 0 7
1012: PUSH
1013: LD_INT 81
1015: PUSH
1016: LD_VAR 0 1
1020: PPUSH
1021: CALL_OW 255
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: PPUSH
1030: CALL_OW 69
1034: ST_TO_ADDR
// if not enemy_list then
1035: LD_VAR 0 7
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1315
// if ignore_list then
1044: LD_VAR 0 2
1048: IFFALSE 1190
// begin _list := [ ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: EMPTY
1056: ST_TO_ADDR
// types_list := [ f_btype , f_weapon , f_class ] ;
1057: LD_ADDR_VAR 0 9
1061: PUSH
1062: LD_INT 30
1064: PUSH
1065: LD_INT 34
1067: PUSH
1068: LD_INT 25
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// for i = 1 to 3 do
1076: LD_ADDR_VAR 0 4
1080: PUSH
1081: DOUBLE
1082: LD_INT 1
1084: DEC
1085: ST_TO_ADDR
1086: LD_INT 3
1088: PUSH
1089: FOR_TO
1090: IFFALSE 1188
// begin if not ignore_list [ i ] then
1092: LD_VAR 0 2
1096: PUSH
1097: LD_VAR 0 4
1101: ARRAY
1102: NOT
1103: IFFALSE 1109
// continue else
1105: GO 1089
1107: GO 1186
// for j in ignore_list [ i ] do
1109: LD_ADDR_VAR 0 5
1113: PUSH
1114: LD_VAR 0 2
1118: PUSH
1119: LD_VAR 0 4
1123: ARRAY
1124: PUSH
1125: FOR_IN
1126: IFFALSE 1184
// begin _list := Insert ( _list , _list + 1 , UnitFilter ( enemy_list , [ types_list [ i ] , j ] ) ) ;
1128: LD_ADDR_VAR 0 8
1132: PUSH
1133: LD_VAR 0 8
1137: PPUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: PLUS
1146: PPUSH
1147: LD_VAR 0 7
1151: PPUSH
1152: LD_VAR 0 9
1156: PUSH
1157: LD_VAR 0 4
1161: ARRAY
1162: PUSH
1163: LD_VAR 0 5
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PPUSH
1172: CALL_OW 72
1176: PPUSH
1177: CALL_OW 2
1181: ST_TO_ADDR
// end ;
1182: GO 1125
1184: POP
1185: POP
// end ;
1186: GO 1089
1188: POP
1189: POP
// end ; if enemy_list diff _list > 0 then
1190: LD_VAR 0 7
1194: PUSH
1195: LD_VAR 0 8
1199: PUSH
1200: LD_INT 0
1202: GREATER
1203: DIFF
1204: IFFALSE 1222
// enemy_list := enemy_list diff _list ;
1206: LD_ADDR_VAR 0 7
1210: PUSH
1211: LD_VAR 0 7
1215: PUSH
1216: LD_VAR 0 8
1220: DIFF
1221: ST_TO_ADDR
// target := NearestUnitToUnit ( enemy_list , unit ) ;
1222: LD_ADDR_VAR 0 6
1226: PUSH
1227: LD_VAR 0 7
1231: PPUSH
1232: LD_VAR 0 1
1236: PPUSH
1237: CALL_OW 74
1241: ST_TO_ADDR
// if not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
1242: LD_VAR 0 1
1246: PPUSH
1247: LD_VAR 0 6
1251: PPUSH
1252: CALL_OW 250
1256: PPUSH
1257: LD_VAR 0 6
1261: PPUSH
1262: CALL_OW 251
1266: PPUSH
1267: CALL 1320 0 3
1271: NOT
1272: IFFALSE 1315
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
1274: LD_VAR 0 1
1278: PPUSH
1279: LD_INT 81
1281: PUSH
1282: LD_VAR 0 1
1286: PPUSH
1287: CALL_OW 255
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL_OW 69
1300: PPUSH
1301: LD_VAR 0 1
1305: PPUSH
1306: CALL_OW 74
1310: PPUSH
1311: CALL_OW 115
// end ;
1315: LD_VAR 0 3
1319: RET
// export function DestinationReachable ( unit , x , y ) ; begin
1320: LD_INT 0
1322: PPUSH
// if unit in unreachableList then
1323: LD_VAR 0 1
1327: PUSH
1328: LD_EXP 1
1332: IN
1333: IFFALSE 1351
// unreachableList := unreachableList diff unit ;
1335: LD_ADDR_EXP 1
1339: PUSH
1340: LD_EXP 1
1344: PUSH
1345: LD_VAR 0 1
1349: DIFF
1350: ST_TO_ADDR
// if ValidHex ( x , y ) then
1351: LD_VAR 0 2
1355: PPUSH
1356: LD_VAR 0 3
1360: PPUSH
1361: CALL_OW 488
1365: IFFALSE 1391
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_VAR 0 2
1376: PPUSH
1377: LD_VAR 0 3
1381: PPUSH
1382: CALL_OW 428
1386: PPUSH
1387: CALL_OW 115
// Wait ( 1 ) ;
1391: LD_INT 1
1393: PPUSH
1394: CALL_OW 67
// if unit in unreachableList then
1398: LD_VAR 0 1
1402: PUSH
1403: LD_EXP 1
1407: IN
1408: IFFALSE 1420
// result := false else
1410: LD_ADDR_VAR 0 4
1414: PUSH
1415: LD_INT 0
1417: ST_TO_ADDR
1418: GO 1428
// result := true ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// end ; end_of_file
1428: LD_VAR 0 4
1432: RET
// export function InitMap ; begin
1433: LD_INT 0
1435: PPUSH
// ResetFog ;
1436: CALL_OW 335
// PrepareAnimals ( 2 , 3 , 3 , nature_area ) ;
1440: LD_INT 2
1442: PPUSH
1443: LD_INT 3
1445: PPUSH
1446: LD_INT 3
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: CALL 21 0 4
// end ;
1456: LD_VAR 0 1
1460: RET
// export function SpawnCrates ; var i ; begin
1461: LD_INT 0
1463: PPUSH
1464: PPUSH
// while ( crates_allow ) do
1465: LD_EXP 13
1469: IFFALSE 1622
// begin Wait ( crates_time + Rand ( - 0 0$10 , 0 0$20 ) ) ;
1471: LD_EXP 11
1475: PUSH
1476: LD_INT 350
1478: NEG
1479: PPUSH
1480: LD_INT 700
1482: PPUSH
1483: CALL_OW 12
1487: PLUS
1488: PPUSH
1489: CALL_OW 67
// for i = 1 to crates_num do
1493: LD_ADDR_VAR 0 2
1497: PUSH
1498: DOUBLE
1499: LD_INT 1
1501: DEC
1502: ST_TO_ADDR
1503: LD_EXP 12
1507: PUSH
1508: FOR_TO
1509: IFFALSE 1618
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1511: LD_INT 1
1513: PPUSH
1514: LD_INT 5
1516: PPUSH
1517: CALL_OW 12
1521: PPUSH
1522: LD_INT 2
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: CALL_OW 55
// Wait ( Rand ( 0 0$03 , 0 0$12 ) ) ;
1532: LD_INT 105
1534: PPUSH
1535: LD_INT 420
1537: PPUSH
1538: CALL_OW 12
1542: PPUSH
1543: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1547: LD_INT 1
1549: PPUSH
1550: LD_INT 5
1552: PPUSH
1553: CALL_OW 12
1557: PPUSH
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 1
1563: PPUSH
1564: CALL_OW 55
// Wait ( Rand ( 0 0$04 , 0 0$15 ) ) ;
1568: LD_INT 140
1570: PPUSH
1571: LD_INT 525
1573: PPUSH
1574: CALL_OW 12
1578: PPUSH
1579: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
1583: LD_INT 1
1585: PPUSH
1586: LD_INT 5
1588: PPUSH
1589: CALL_OW 12
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 57
// Wait ( Rand ( 0 0$05 , 0 0$10 ) ) ;
1601: LD_INT 175
1603: PPUSH
1604: LD_INT 350
1606: PPUSH
1607: CALL_OW 12
1611: PPUSH
1612: CALL_OW 67
// end ;
1616: GO 1508
1618: POP
1619: POP
// end ;
1620: GO 1465
// end ;
1622: LD_VAR 0 1
1626: RET
// every 1 1$25 trigger game_started do
1627: LD_EXP 10
1631: IFFALSE 1685
1633: GO 1635
1635: DISABLE
// begin enable ;
1636: ENABLE
// if timer <= [ 23 23$00 , 21 21$00 , 19 19$00 ] [ global_diff ] then
1637: LD_EXP 2
1641: PUSH
1642: LD_INT 48300
1644: PUSH
1645: LD_INT 44100
1647: PUSH
1648: LD_INT 39900
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: PUSH
1656: LD_EXP 3
1660: ARRAY
1661: LESSEQUAL
1662: IFFALSE 1685
// CreateCratesArea ( Rand ( 2 , 5 ) , us_crates , true ) ;
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 5
1669: PPUSH
1670: CALL_OW 12
1674: PPUSH
1675: LD_INT 12
1677: PPUSH
1678: LD_INT 1
1680: PPUSH
1681: CALL_OW 55
// end ;
1685: END
// every 0 0$01 trigger game_started do
1686: LD_EXP 10
1690: IFFALSE 1699
1692: GO 1694
1694: DISABLE
// SpawnCrates ;
1695: CALL 1461 0 0
1699: END
// export timer ; every 1 do
1700: GO 1702
1702: DISABLE
// timer := 0 0$00 ;
1703: LD_ADDR_EXP 2
1707: PUSH
1708: LD_INT 0
1710: ST_TO_ADDR
1711: END
// every 0 0$01 trigger game_started do
1712: LD_EXP 10
1716: IFFALSE 1753
1718: GO 1720
1720: DISABLE
// begin enable ;
1721: ENABLE
// timer := timer + 0 0$01 ;
1722: LD_ADDR_EXP 2
1726: PUSH
1727: LD_EXP 2
1731: PUSH
1732: LD_INT 35
1734: PLUS
1735: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
1736: LD_ADDR_OWVAR 47
1740: PUSH
1741: LD_STRING #tick
1743: PUSH
1744: LD_EXP 2
1748: PUSH
1749: EMPTY
1750: LIST
1751: LIST
1752: ST_TO_ADDR
// end ;
1753: END
// every 0 0$01 trigger timer <= 13 13$00 do
1754: LD_EXP 2
1758: PUSH
1759: LD_INT 27300
1761: LESSEQUAL
1762: IFFALSE 1775
1764: GO 1766
1766: DISABLE
// music_nat := 1 ;
1767: LD_ADDR_OWVAR 71
1771: PUSH
1772: LD_INT 1
1774: ST_TO_ADDR
1775: END
// every 5 5$00 trigger timer > 13 13$00 do
1776: LD_EXP 2
1780: PUSH
1781: LD_INT 27300
1783: GREATER
1784: IFFALSE 1817
1786: GO 1788
1788: DISABLE
// begin enable ;
1789: ENABLE
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1790: LD_ADDR_OWVAR 71
1794: PUSH
1795: LD_INT 1
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 1
1807: PPUSH
1808: LD_INT 2
1810: PPUSH
1811: CALL_OW 12
1815: ARRAY
1816: ST_TO_ADDR
// end ; end_of_file
1817: END
// export global_diff , ru_force , ru_def , am_def , am_force , ar_def , ar_force ; export game_started ; export crates_time , crates_num , crates_allow ; export sikorski , kurin , heike , ron , jack ; export sikorski_come , russian_produce , beria_action , sikorski_veh ; export function InitTriggers ; begin
1818: LD_INT 0
1820: PPUSH
// game_started := false ;
1821: LD_ADDR_EXP 10
1825: PUSH
1826: LD_INT 0
1828: ST_TO_ADDR
// global_diff := [ 1 , 2 , 3 ] ;
1829: LD_ADDR_EXP 3
1833: PUSH
1834: LD_INT 1
1836: PUSH
1837: LD_INT 2
1839: PUSH
1840: LD_INT 3
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: ST_TO_ADDR
// crates_time := [ 0 0$55 , 1 1$15 , 1 1$35 ] [ global_diff ] ;
1848: LD_ADDR_EXP 11
1852: PUSH
1853: LD_INT 1925
1855: PUSH
1856: LD_INT 2625
1858: PUSH
1859: LD_INT 3325
1861: PUSH
1862: EMPTY
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_EXP 3
1871: ARRAY
1872: ST_TO_ADDR
// crates_num := [ 3 , 2 , 1 ] [ global_diff ] ;
1873: LD_ADDR_EXP 12
1877: PUSH
1878: LD_INT 3
1880: PUSH
1881: LD_INT 2
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_EXP 3
1896: ARRAY
1897: ST_TO_ADDR
// crates_allow := false ;
1898: LD_ADDR_EXP 13
1902: PUSH
1903: LD_INT 0
1905: ST_TO_ADDR
// am_def := [ 4 , 3 , 2 ] [ global_diff ] ;
1906: LD_ADDR_EXP 6
1910: PUSH
1911: LD_INT 4
1913: PUSH
1914: LD_INT 3
1916: PUSH
1917: LD_INT 2
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: LIST
1924: PUSH
1925: LD_EXP 3
1929: ARRAY
1930: ST_TO_ADDR
// ru_def := [ 2 , 3 , 4 ] [ global_diff ] ;
1931: LD_ADDR_EXP 5
1935: PUSH
1936: LD_INT 2
1938: PUSH
1939: LD_INT 3
1941: PUSH
1942: LD_INT 4
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: LIST
1949: PUSH
1950: LD_EXP 3
1954: ARRAY
1955: ST_TO_ADDR
// ru_force := [ 12 , 14 , 16 ] [ global_diff ] ;
1956: LD_ADDR_EXP 4
1960: PUSH
1961: LD_INT 12
1963: PUSH
1964: LD_INT 14
1966: PUSH
1967: LD_INT 16
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: LIST
1974: PUSH
1975: LD_EXP 3
1979: ARRAY
1980: ST_TO_ADDR
// ar_def := [ 3 , 4 , 5 ] [ global_diff ] ;
1981: LD_ADDR_EXP 8
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: LD_INT 4
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_EXP 3
2004: ARRAY
2005: ST_TO_ADDR
// ar_force := [ 4 , 5 , 6 ] [ global_diff ] ;
2006: LD_ADDR_EXP 9
2010: PUSH
2011: LD_INT 4
2013: PUSH
2014: LD_INT 5
2016: PUSH
2017: LD_INT 6
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: PUSH
2025: LD_EXP 3
2029: ARRAY
2030: ST_TO_ADDR
// sikorski_come := false ;
2031: LD_ADDR_EXP 19
2035: PUSH
2036: LD_INT 0
2038: ST_TO_ADDR
// russian_produce := false ;
2039: LD_ADDR_EXP 20
2043: PUSH
2044: LD_INT 0
2046: ST_TO_ADDR
// disable ( 99 ) ;
2047: LD_INT 99
2049: DISABLE_MARKED
// end ; end_of_file
2050: LD_VAR 0 1
2054: RET
// export function InitPlayer ; var i , p , un , am , am2 , filter ; begin
2055: LD_INT 0
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
// uc_nation := nation_american ;
2064: LD_ADDR_OWVAR 21
2068: PUSH
2069: LD_INT 1
2071: ST_TO_ADDR
// am := 1 ;
2072: LD_ADDR_VAR 0 5
2076: PUSH
2077: LD_INT 1
2079: ST_TO_ADDR
// am2 := 4 ;
2080: LD_ADDR_VAR 0 6
2084: PUSH
2085: LD_INT 4
2087: ST_TO_ADDR
// filter := [ ] ;
2088: LD_ADDR_VAR 0 7
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// SetSide ( omikron , am2 ) ;
2095: LD_INT 64
2097: PPUSH
2098: LD_VAR 0 6
2102: PPUSH
2103: CALL_OW 235
// SetBName ( omikron , omikron ) ;
2107: LD_INT 64
2109: PPUSH
2110: LD_STRING omikron
2112: PPUSH
2113: CALL_OW 500
// ResetFog ;
2117: CALL_OW 335
// uc_side := am2 ;
2121: LD_ADDR_OWVAR 20
2125: PUSH
2126: LD_VAR 0 6
2130: ST_TO_ADDR
// for i = 1 to 4 do
2131: LD_ADDR_VAR 0 2
2135: PUSH
2136: DOUBLE
2137: LD_INT 1
2139: DEC
2140: ST_TO_ADDR
2141: LD_INT 4
2143: PUSH
2144: FOR_TO
2145: IFFALSE 2267
// for p = 1 to 2 do
2147: LD_ADDR_VAR 0 3
2151: PUSH
2152: DOUBLE
2153: LD_INT 1
2155: DEC
2156: ST_TO_ADDR
2157: LD_INT 2
2159: PUSH
2160: FOR_TO
2161: IFFALSE 2263
// begin un := CreateHumanWithClass ( i , am_def ) ;
2163: LD_ADDR_VAR 0 4
2167: PUSH
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_EXP 6
2177: PPUSH
2178: CALL 418 0 2
2182: ST_TO_ADDR
// PlaceUnitArea ( un , am_area , false ) ;
2183: LD_VAR 0 4
2187: PPUSH
2188: LD_INT 3
2190: PPUSH
2191: LD_INT 0
2193: PPUSH
2194: CALL_OW 49
// if GetClass ( un ) = 1 then
2198: LD_VAR 0 4
2202: PPUSH
2203: CALL_OW 257
2207: PUSH
2208: LD_INT 1
2210: EQUAL
2211: IFFALSE 2261
// ComEnterUnit ( un , ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) diff us_spec_b ) [ p ] ) ;
2213: LD_VAR 0 4
2217: PPUSH
2218: LD_INT 22
2220: PUSH
2221: LD_INT 4
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: PUSH
2228: LD_INT 30
2230: PUSH
2231: LD_INT 31
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: PPUSH
2242: CALL_OW 69
2246: PUSH
2247: LD_INT 140
2249: DIFF
2250: PUSH
2251: LD_VAR 0 3
2255: ARRAY
2256: PPUSH
2257: CALL_OW 120
// end ;
2261: GO 2160
2263: POP
2264: POP
2265: GO 2144
2267: POP
2268: POP
// if IsPlaced ( us_spec_b ) then
2269: LD_INT 140
2271: PPUSH
2272: CALL_OW 305
2276: IFFALSE 2340
// begin un := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) [ 1 ] ;
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: LD_INT 22
2285: PUSH
2286: LD_INT 4
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 25
2295: PUSH
2296: LD_INT 3
2298: PUSH
2299: EMPTY
2300: LIST
2301: LIST
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: LD_INT 1
2314: ARRAY
2315: ST_TO_ADDR
// SetClass ( un , 1 ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 1
2323: PPUSH
2324: CALL_OW 336
// ComEnterUnit ( un , us_spec_b ) ;
2328: LD_VAR 0 4
2332: PPUSH
2333: LD_INT 140
2335: PPUSH
2336: CALL_OW 120
// end ; vc_chassis := us_medium_wheeled ;
2340: LD_ADDR_OWVAR 37
2344: PUSH
2345: LD_INT 2
2347: ST_TO_ADDR
// vc_engine := engine_solar ;
2348: LD_ADDR_OWVAR 39
2352: PUSH
2353: LD_INT 2
2355: ST_TO_ADDR
// vc_control := control_manual ;
2356: LD_ADDR_OWVAR 38
2360: PUSH
2361: LD_INT 1
2363: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_double_gun , us_gatling_gun ] [ global_diff ] ;
2364: LD_ADDR_OWVAR 40
2368: PUSH
2369: LD_INT 5
2371: PUSH
2372: LD_INT 5
2374: PUSH
2375: LD_INT 4
2377: PUSH
2378: EMPTY
2379: LIST
2380: LIST
2381: LIST
2382: PUSH
2383: LD_EXP 3
2387: ARRAY
2388: ST_TO_ADDR
// un := CreateVehicle ;
2389: LD_ADDR_VAR 0 4
2393: PUSH
2394: CALL_OW 45
2398: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2399: LD_VAR 0 4
2403: PPUSH
2404: LD_INT 4
2406: PPUSH
2407: CALL_OW 233
// PlaceUnitXY ( un , 12 , 17 , false ) ;
2411: LD_VAR 0 4
2415: PPUSH
2416: LD_INT 12
2418: PPUSH
2419: LD_INT 17
2421: PPUSH
2422: LD_INT 0
2424: PPUSH
2425: CALL_OW 48
// vc_chassis := us_light_wheeled ;
2429: LD_ADDR_OWVAR 37
2433: PUSH
2434: LD_INT 1
2436: ST_TO_ADDR
// vc_engine := engine_combustion ;
2437: LD_ADDR_OWVAR 39
2441: PUSH
2442: LD_INT 1
2444: ST_TO_ADDR
// vc_control := control_manual ;
2445: LD_ADDR_OWVAR 38
2449: PUSH
2450: LD_INT 1
2452: ST_TO_ADDR
// vc_weapon := us_light_gun ;
2453: LD_ADDR_OWVAR 40
2457: PUSH
2458: LD_INT 3
2460: ST_TO_ADDR
// un := CreateVehicle ;
2461: LD_ADDR_VAR 0 4
2465: PUSH
2466: CALL_OW 45
2470: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2471: LD_VAR 0 4
2475: PPUSH
2476: LD_INT 4
2478: PPUSH
2479: CALL_OW 233
// PlaceUnitXY ( un , 19 , 19 , false ) ;
2483: LD_VAR 0 4
2487: PPUSH
2488: LD_INT 19
2490: PPUSH
2491: LD_INT 19
2493: PPUSH
2494: LD_INT 0
2496: PPUSH
2497: CALL_OW 48
// uc_side := am ;
2501: LD_ADDR_OWVAR 20
2505: PUSH
2506: LD_VAR 0 5
2510: ST_TO_ADDR
// hc_importance := 100 ;
2511: LD_ADDR_OWVAR 32
2515: PUSH
2516: LD_INT 100
2518: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
2519: LD_ADDR_OWVAR 26
2523: PUSH
2524: LD_STRING Jeremy Sikorski
2526: ST_TO_ADDR
// hc_gallery := us ;
2527: LD_ADDR_OWVAR 33
2531: PUSH
2532: LD_STRING us
2534: ST_TO_ADDR
// hc_face_number := 19 ;
2535: LD_ADDR_OWVAR 34
2539: PUSH
2540: LD_INT 19
2542: ST_TO_ADDR
// hc_skills := [ Rand ( am_def + 2 , am_def + 4 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) ] ;
2543: LD_ADDR_OWVAR 31
2547: PUSH
2548: LD_EXP 6
2552: PUSH
2553: LD_INT 2
2555: PLUS
2556: PPUSH
2557: LD_EXP 6
2561: PUSH
2562: LD_INT 4
2564: PLUS
2565: PPUSH
2566: CALL_OW 12
2570: PUSH
2571: LD_EXP 6
2575: PUSH
2576: LD_INT 1
2578: MINUS
2579: PPUSH
2580: LD_EXP 6
2584: PUSH
2585: LD_INT 1
2587: PLUS
2588: PPUSH
2589: CALL_OW 12
2593: PUSH
2594: LD_EXP 6
2598: PUSH
2599: LD_INT 1
2601: MINUS
2602: PPUSH
2603: LD_EXP 6
2607: PUSH
2608: LD_INT 1
2610: PLUS
2611: PPUSH
2612: CALL_OW 12
2616: PUSH
2617: LD_EXP 6
2621: PUSH
2622: LD_INT 1
2624: MINUS
2625: PPUSH
2626: LD_EXP 6
2630: PUSH
2631: LD_INT 1
2633: PLUS
2634: PPUSH
2635: CALL_OW 12
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: ST_TO_ADDR
// hc_sex := sex_male ;
2646: LD_ADDR_OWVAR 27
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// hc_class := 1 ;
2654: LD_ADDR_OWVAR 28
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2662: LD_ADDR_OWVAR 29
2666: PUSH
2667: LD_INT 10
2669: PUSH
2670: LD_INT 12
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: ST_TO_ADDR
// sikorski := CreateHuman ;
2677: LD_ADDR_EXP 14
2681: PUSH
2682: CALL_OW 44
2686: ST_TO_ADDR
// if global_diff > 1 then
2687: LD_EXP 3
2691: PUSH
2692: LD_INT 1
2694: GREATER
2695: IFFALSE 2714
// PlaceUnitArea ( sikorski , sikorski_area , false ) else
2697: LD_EXP 14
2701: PPUSH
2702: LD_INT 8
2704: PPUSH
2705: LD_INT 0
2707: PPUSH
2708: CALL_OW 49
2712: GO 2805
// begin vc_chassis := us_light_wheeled ;
2714: LD_ADDR_OWVAR 37
2718: PUSH
2719: LD_INT 1
2721: ST_TO_ADDR
// vc_engine := engine_combustion ;
2722: LD_ADDR_OWVAR 39
2726: PUSH
2727: LD_INT 1
2729: ST_TO_ADDR
// vc_control := control_manual ;
2730: LD_ADDR_OWVAR 38
2734: PUSH
2735: LD_INT 1
2737: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
2738: LD_ADDR_OWVAR 40
2742: PUSH
2743: LD_INT 2
2745: ST_TO_ADDR
// vc_fuel_battery := 21 ;
2746: LD_ADDR_OWVAR 41
2750: PUSH
2751: LD_INT 21
2753: ST_TO_ADDR
// sikorski_veh := CreateVehicle ;
2754: LD_ADDR_EXP 22
2758: PUSH
2759: CALL_OW 45
2763: ST_TO_ADDR
// SetDir ( sikorski_veh , 0 ) ;
2764: LD_EXP 22
2768: PPUSH
2769: LD_INT 0
2771: PPUSH
2772: CALL_OW 233
// PlaceUnitArea ( sikorski_veh , sikorski_area , false ) ;
2776: LD_EXP 22
2780: PPUSH
2781: LD_INT 8
2783: PPUSH
2784: LD_INT 0
2786: PPUSH
2787: CALL_OW 49
// PlaceHumanInUnit ( sikorski , sikorski_veh ) ;
2791: LD_EXP 14
2795: PPUSH
2796: LD_EXP 22
2800: PPUSH
2801: CALL_OW 52
// end ; hc_importance := 0 ;
2805: LD_ADDR_OWVAR 32
2809: PUSH
2810: LD_INT 0
2812: ST_TO_ADDR
// hc_name := Ronn Harisson ;
2813: LD_ADDR_OWVAR 26
2817: PUSH
2818: LD_STRING Ronn Harisson
2820: ST_TO_ADDR
// hc_gallery := us ;
2821: LD_ADDR_OWVAR 33
2825: PUSH
2826: LD_STRING us
2828: ST_TO_ADDR
// hc_face_number := 6 ;
2829: LD_ADDR_OWVAR 34
2833: PUSH
2834: LD_INT 6
2836: ST_TO_ADDR
// ron := CreateHuman ;
2837: LD_ADDR_EXP 17
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// hc_name := Jack Dickens ;
2847: LD_ADDR_OWVAR 26
2851: PUSH
2852: LD_STRING Jack Dickens
2854: ST_TO_ADDR
// hc_gallery :=  ;
2855: LD_ADDR_OWVAR 33
2859: PUSH
2860: LD_STRING 
2862: ST_TO_ADDR
// jack := CreateHuman ;
2863: LD_ADDR_EXP 18
2867: PUSH
2868: CALL_OW 44
2872: ST_TO_ADDR
// end ;
2873: LD_VAR 0 1
2877: RET
// every 0 0$01 trigger GetDistUnits ( sikorski , omikron ) <= 45 do
2878: LD_EXP 14
2882: PPUSH
2883: LD_INT 64
2885: PPUSH
2886: CALL_OW 296
2890: PUSH
2891: LD_INT 45
2893: LESSEQUAL
2894: IFFALSE 2944
2896: GO 2898
2898: DISABLE
// ComBuild ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) , b_workshop , 16 , 5 , 3 ) ; end_of_file
2899: LD_INT 22
2901: PUSH
2902: LD_INT 4
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: LD_INT 25
2911: PUSH
2912: LD_INT 2
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PPUSH
2923: CALL_OW 69
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_INT 16
2933: PPUSH
2934: LD_INT 5
2936: PPUSH
2937: LD_INT 3
2939: PPUSH
2940: CALL_OW 145
2944: END
// export ru_sold , ru_stw , ru_tw , ru_tech , ru_veh , ru_eng , ru_mech , ru_sci , ru_bul , ru_b ; export ru2_sold , ru2_stw , ru2_tw , ru2_tech , ru2_veh , ru2_eng , ru2_mech , ru2_sci , ru2_bul , ru2_b ; export ru_list_attackers ; export ru_radar ; export function InitRussian ; var ru , ru2 , i , un , filter ; begin
2945: LD_INT 0
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
// ru := 6 ;
2953: LD_ADDR_VAR 0 2
2957: PUSH
2958: LD_INT 6
2960: ST_TO_ADDR
// ru2 := 3 ;
2961: LD_ADDR_VAR 0 3
2965: PUSH
2966: LD_INT 3
2968: ST_TO_ADDR
// uc_nation := nation_russian ;
2969: LD_ADDR_OWVAR 21
2973: PUSH
2974: LD_INT 3
2976: ST_TO_ADDR
// ru_radar := 98 ;
2977: LD_ADDR_EXP 44
2981: PUSH
2982: LD_INT 98
2984: ST_TO_ADDR
// ru_list_attackers := [ ] ;
2985: LD_ADDR_EXP 43
2989: PUSH
2990: EMPTY
2991: ST_TO_ADDR
// uc_side := ru ;
2992: LD_ADDR_OWVAR 20
2996: PUSH
2997: LD_VAR 0 2
3001: ST_TO_ADDR
// ru_sold := [ ] ;
3002: LD_ADDR_EXP 23
3006: PUSH
3007: EMPTY
3008: ST_TO_ADDR
// ru_stw := [ ] ;
3009: LD_ADDR_EXP 24
3013: PUSH
3014: EMPTY
3015: ST_TO_ADDR
// ru_tw := [ ] ;
3016: LD_ADDR_EXP 25
3020: PUSH
3021: EMPTY
3022: ST_TO_ADDR
// ru_b := [ ] ;
3023: LD_ADDR_EXP 32
3027: PUSH
3028: EMPTY
3029: ST_TO_ADDR
// ru_eng := [ ] ;
3030: LD_ADDR_EXP 28
3034: PUSH
3035: EMPTY
3036: ST_TO_ADDR
// ru_mech := [ ] ;
3037: LD_ADDR_EXP 29
3041: PUSH
3042: EMPTY
3043: ST_TO_ADDR
// ru_sci := [ ] ;
3044: LD_ADDR_EXP 30
3048: PUSH
3049: EMPTY
3050: ST_TO_ADDR
// ru_bul := [ b_bunker , 162 , 101 , 0 , b_ext_rocket , 149 , 86 , 4 ] ;
3051: LD_ADDR_EXP 31
3055: PUSH
3056: LD_INT 32
3058: PUSH
3059: LD_INT 162
3061: PUSH
3062: LD_INT 101
3064: PUSH
3065: LD_INT 0
3067: PUSH
3068: LD_INT 18
3070: PUSH
3071: LD_INT 149
3073: PUSH
3074: LD_INT 86
3076: PUSH
3077: LD_INT 4
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: ST_TO_ADDR
// ru_tech := [ tech_tech1 , tech_tech2 , tech_tech3 , tech_oilpow , tech_oileng , tech_weap1 , tech_weap2 , tech_gatling , tech_advmet , tech_weap3 ] ;
3090: LD_ADDR_EXP 26
3094: PUSH
3095: LD_INT 48
3097: PUSH
3098: LD_INT 49
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: LD_INT 46
3106: PUSH
3107: LD_INT 47
3109: PUSH
3110: LD_INT 51
3112: PUSH
3113: LD_INT 52
3115: PUSH
3116: LD_INT 69
3118: PUSH
3119: LD_INT 34
3121: PUSH
3122: LD_INT 53
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: LIST
3136: ST_TO_ADDR
// ru_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3137: LD_ADDR_EXP 27
3141: PUSH
3142: LD_INT 21
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 1
3150: PUSH
3151: LD_INT 51
3153: PUSH
3154: LD_INT 22
3156: PUSH
3157: LD_INT 1
3159: PUSH
3160: LD_INT 1
3162: PUSH
3163: LD_INT 52
3165: PUSH
3166: LD_INT 22
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: LD_INT 1
3174: PUSH
3175: LD_INT 52
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: LIST
3190: LIST
3191: ST_TO_ADDR
// SetBName ( kirov , kirov ) ;
3192: LD_INT 71
3194: PPUSH
3195: LD_STRING kirov
3197: PPUSH
3198: CALL_OW 500
// hc_gallery := ru ;
3202: LD_ADDR_OWVAR 33
3206: PUSH
3207: LD_STRING ru
3209: ST_TO_ADDR
// hc_face_number := 8 ;
3210: LD_ADDR_OWVAR 34
3214: PUSH
3215: LD_INT 8
3217: ST_TO_ADDR
// hc_skills := [ 7 , 4 , 3 , 2 ] ;
3218: LD_ADDR_OWVAR 31
3222: PUSH
3223: LD_INT 7
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 2
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: ST_TO_ADDR
// hc_sex := sex_male ;
3241: LD_ADDR_OWVAR 27
3245: PUSH
3246: LD_INT 1
3248: ST_TO_ADDR
// hc_name := Ivan Kurin ;
3249: LD_ADDR_OWVAR 26
3253: PUSH
3254: LD_STRING Ivan Kurin
3256: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3257: LD_ADDR_OWVAR 29
3261: PUSH
3262: LD_INT 10
3264: PUSH
3265: LD_INT 10
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: ST_TO_ADDR
// kurin := CreateHuman ;
3272: LD_ADDR_EXP 15
3276: PUSH
3277: CALL_OW 44
3281: ST_TO_ADDR
// PlaceHumanInUnit ( kurin , kirov ) ;
3282: LD_EXP 15
3286: PPUSH
3287: LD_INT 71
3289: PPUSH
3290: CALL_OW 52
// filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_bunker ] ] ) ;
3294: LD_ADDR_VAR 0 6
3298: PUSH
3299: LD_INT 22
3301: PUSH
3302: LD_INT 6
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: LD_INT 30
3311: PUSH
3312: LD_INT 32
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 69
3327: ST_TO_ADDR
// for i = 1 to ru_force do
3328: LD_ADDR_VAR 0 4
3332: PUSH
3333: DOUBLE
3334: LD_INT 1
3336: DEC
3337: ST_TO_ADDR
3338: LD_EXP 4
3342: PUSH
3343: FOR_TO
3344: IFFALSE 3415
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3346: LD_ADDR_VAR 0 5
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_EXP 5
3358: PPUSH
3359: CALL 418 0 2
3363: ST_TO_ADDR
// if i <= filter then
3364: LD_VAR 0 4
3368: PUSH
3369: LD_VAR 0 6
3373: LESSEQUAL
3374: IFFALSE 3398
// PlaceHumanInUnit ( un , filter [ i ] ) else
3376: LD_VAR 0 5
3380: PPUSH
3381: LD_VAR 0 6
3385: PUSH
3386: LD_VAR 0 4
3390: ARRAY
3391: PPUSH
3392: CALL_OW 52
3396: GO 3413
// PlaceUnitArea ( un , ru_area , false ) ;
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_INT 4
3405: PPUSH
3406: LD_INT 0
3408: PPUSH
3409: CALL_OW 49
// end ;
3413: GO 3343
3415: POP
3416: POP
// for i = 1 to 6 do
3417: LD_ADDR_VAR 0 4
3421: PUSH
3422: DOUBLE
3423: LD_INT 1
3425: DEC
3426: ST_TO_ADDR
3427: LD_INT 6
3429: PUSH
3430: FOR_TO
3431: IFFALSE 3468
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
3433: LD_ADDR_VAR 0 5
3437: PUSH
3438: LD_INT 3
3440: PPUSH
3441: LD_EXP 5
3445: PPUSH
3446: CALL 418 0 2
3450: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3451: LD_VAR 0 5
3455: PPUSH
3456: LD_INT 4
3458: PPUSH
3459: LD_INT 0
3461: PPUSH
3462: CALL_OW 49
// end ;
3466: GO 3430
3468: POP
3469: POP
// for i = 1 to 3 do
3470: LD_ADDR_VAR 0 4
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 3
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3521
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
3486: LD_ADDR_VAR 0 5
3490: PUSH
3491: LD_INT 4
3493: PPUSH
3494: LD_EXP 5
3498: PPUSH
3499: CALL 418 0 2
3503: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3504: LD_VAR 0 5
3508: PPUSH
3509: LD_INT 4
3511: PPUSH
3512: LD_INT 0
3514: PPUSH
3515: CALL_OW 49
// end ;
3519: GO 3483
3521: POP
3522: POP
// for i = 1 to 4 do
3523: LD_ADDR_VAR 0 4
3527: PUSH
3528: DOUBLE
3529: LD_INT 1
3531: DEC
3532: ST_TO_ADDR
3533: LD_INT 4
3535: PUSH
3536: FOR_TO
3537: IFFALSE 3574
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
3539: LD_ADDR_VAR 0 5
3543: PUSH
3544: LD_INT 2
3546: PPUSH
3547: LD_EXP 5
3551: PPUSH
3552: CALL 418 0 2
3556: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3557: LD_VAR 0 5
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_INT 0
3567: PPUSH
3568: CALL_OW 49
// end ;
3572: GO 3536
3574: POP
3575: POP
// uc_side := ru2 ;
3576: LD_ADDR_OWVAR 20
3580: PUSH
3581: LD_VAR 0 3
3585: ST_TO_ADDR
// ru2_sold := [ ] ;
3586: LD_ADDR_EXP 33
3590: PUSH
3591: EMPTY
3592: ST_TO_ADDR
// ru2_stw := [ ] ;
3593: LD_ADDR_EXP 34
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// ru2_tw := [ ] ;
3600: LD_ADDR_EXP 35
3604: PUSH
3605: EMPTY
3606: ST_TO_ADDR
// ru2_b := [ ] ;
3607: LD_ADDR_EXP 42
3611: PUSH
3612: EMPTY
3613: ST_TO_ADDR
// ru2_eng := [ ] ;
3614: LD_ADDR_EXP 38
3618: PUSH
3619: EMPTY
3620: ST_TO_ADDR
// ru2_mech := [ ] ;
3621: LD_ADDR_EXP 39
3625: PUSH
3626: EMPTY
3627: ST_TO_ADDR
// ru2_sci := [ ] ;
3628: LD_ADDR_EXP 40
3632: PUSH
3633: EMPTY
3634: ST_TO_ADDR
// ru2_bul := [ b_lab , 90 , 71 , 1 , b_armoury , 88 , 58 , 2 , b_workshop , 103 , 66 , 4 , b_oil_power , 106 , 77 , 3 , b_oil_power , 110 , 77 , 3 , b_bunker , 109 , 65 , 4 , b_bunker , 92 , 85 , 0 , b_bunker , 74 , 72 , 0 , b_bunker , 71 , 66 , 2 , b_bunker , 115 , 79 , 4 , b_bunker , 112 , 69 , 4 , b_bunker , 111 , 84 , 5 ] ;
3635: LD_ADDR_EXP 41
3639: PUSH
3640: LD_INT 6
3642: PUSH
3643: LD_INT 90
3645: PUSH
3646: LD_INT 71
3648: PUSH
3649: LD_INT 1
3651: PUSH
3652: LD_INT 4
3654: PUSH
3655: LD_INT 88
3657: PUSH
3658: LD_INT 58
3660: PUSH
3661: LD_INT 2
3663: PUSH
3664: LD_INT 2
3666: PUSH
3667: LD_INT 103
3669: PUSH
3670: LD_INT 66
3672: PUSH
3673: LD_INT 4
3675: PUSH
3676: LD_INT 26
3678: PUSH
3679: LD_INT 106
3681: PUSH
3682: LD_INT 77
3684: PUSH
3685: LD_INT 3
3687: PUSH
3688: LD_INT 26
3690: PUSH
3691: LD_INT 110
3693: PUSH
3694: LD_INT 77
3696: PUSH
3697: LD_INT 3
3699: PUSH
3700: LD_INT 32
3702: PUSH
3703: LD_INT 109
3705: PUSH
3706: LD_INT 65
3708: PUSH
3709: LD_INT 4
3711: PUSH
3712: LD_INT 32
3714: PUSH
3715: LD_INT 92
3717: PUSH
3718: LD_INT 85
3720: PUSH
3721: LD_INT 0
3723: PUSH
3724: LD_INT 32
3726: PUSH
3727: LD_INT 74
3729: PUSH
3730: LD_INT 72
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 32
3738: PUSH
3739: LD_INT 71
3741: PUSH
3742: LD_INT 66
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: LD_INT 32
3750: PUSH
3751: LD_INT 115
3753: PUSH
3754: LD_INT 79
3756: PUSH
3757: LD_INT 4
3759: PUSH
3760: LD_INT 32
3762: PUSH
3763: LD_INT 112
3765: PUSH
3766: LD_INT 69
3768: PUSH
3769: LD_INT 4
3771: PUSH
3772: LD_INT 32
3774: PUSH
3775: LD_INT 111
3777: PUSH
3778: LD_INT 84
3780: PUSH
3781: LD_INT 5
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: ST_TO_ADDR
// ru2_tech := [ tech_tech1 , tech_tech2 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_advmet , tech_weap3 , tech_tech3 ] ;
3834: LD_ADDR_EXP 36
3838: PUSH
3839: LD_INT 48
3841: PUSH
3842: LD_INT 49
3844: PUSH
3845: LD_INT 51
3847: PUSH
3848: LD_INT 52
3850: PUSH
3851: LD_INT 69
3853: PUSH
3854: LD_INT 39
3856: PUSH
3857: LD_INT 34
3859: PUSH
3860: LD_INT 53
3862: PUSH
3863: LD_INT 50
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: ST_TO_ADDR
// ru2_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3877: LD_ADDR_EXP 37
3881: PUSH
3882: LD_INT 21
3884: PUSH
3885: LD_INT 1
3887: PUSH
3888: LD_INT 1
3890: PUSH
3891: LD_INT 51
3893: PUSH
3894: LD_INT 22
3896: PUSH
3897: LD_INT 1
3899: PUSH
3900: LD_INT 1
3902: PUSH
3903: LD_INT 52
3905: PUSH
3906: LD_INT 22
3908: PUSH
3909: LD_INT 1
3911: PUSH
3912: LD_INT 1
3914: PUSH
3915: LD_INT 52
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: ST_TO_ADDR
// SetBName ( beria , beria ) ;
3932: LD_INT 106
3934: PPUSH
3935: LD_STRING beria
3937: PPUSH
3938: CALL_OW 500
// SetBName ( kagan , kagan ) ;
3942: LD_INT 112
3944: PPUSH
3945: LD_STRING kagan
3947: PPUSH
3948: CALL_OW 500
// for i = 1 to 12 do
3952: LD_ADDR_VAR 0 4
3956: PUSH
3957: DOUBLE
3958: LD_INT 1
3960: DEC
3961: ST_TO_ADDR
3962: LD_INT 12
3964: PUSH
3965: FOR_TO
3966: IFFALSE 4003
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_INT 1
3975: PPUSH
3976: LD_EXP 5
3980: PPUSH
3981: CALL 418 0 2
3985: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3986: LD_VAR 0 5
3990: PPUSH
3991: LD_INT 9
3993: PPUSH
3994: LD_INT 0
3996: PPUSH
3997: CALL_OW 49
// end ;
4001: GO 3965
4003: POP
4004: POP
// for i = 1 to 6 do
4005: LD_ADDR_VAR 0 4
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 6
4017: PUSH
4018: FOR_TO
4019: IFFALSE 4056
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
4021: LD_ADDR_VAR 0 5
4025: PUSH
4026: LD_INT 3
4028: PPUSH
4029: LD_EXP 5
4033: PPUSH
4034: CALL 418 0 2
4038: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4039: LD_VAR 0 5
4043: PPUSH
4044: LD_INT 9
4046: PPUSH
4047: LD_INT 0
4049: PPUSH
4050: CALL_OW 49
// end ;
4054: GO 4018
4056: POP
4057: POP
// for i = 1 to 4 do
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: DOUBLE
4064: LD_INT 1
4066: DEC
4067: ST_TO_ADDR
4068: LD_INT 4
4070: PUSH
4071: FOR_TO
4072: IFFALSE 4109
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
4074: LD_ADDR_VAR 0 5
4078: PUSH
4079: LD_INT 4
4081: PPUSH
4082: LD_EXP 5
4086: PPUSH
4087: CALL 418 0 2
4091: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4092: LD_VAR 0 5
4096: PPUSH
4097: LD_INT 9
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 49
// end ;
4107: GO 4071
4109: POP
4110: POP
// for i = 1 to 4 do
4111: LD_ADDR_VAR 0 4
4115: PUSH
4116: DOUBLE
4117: LD_INT 1
4119: DEC
4120: ST_TO_ADDR
4121: LD_INT 4
4123: PUSH
4124: FOR_TO
4125: IFFALSE 4162
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
4127: LD_ADDR_VAR 0 5
4131: PUSH
4132: LD_INT 2
4134: PPUSH
4135: LD_EXP 5
4139: PPUSH
4140: CALL 418 0 2
4144: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4145: LD_VAR 0 5
4149: PPUSH
4150: LD_INT 9
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 49
// end ;
4160: GO 4124
4162: POP
4163: POP
// end ;
4164: LD_VAR 0 1
4168: RET
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , enemy_detected ;
4169: GO 4171
4171: DISABLE
4172: LD_INT 0
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
// begin enable ;
4184: ENABLE
// ru_sold := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) diff Kurin ;
4185: LD_ADDR_EXP 23
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 6
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 25
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 24
4212: PUSH
4213: LD_INT 600
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: PPUSH
4228: CALL_OW 69
4232: PUSH
4233: LD_EXP 15
4237: DIFF
4238: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
4239: LD_ADDR_EXP 28
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_INT 6
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: LD_INT 25
4256: PUSH
4257: LD_INT 2
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 24
4266: PUSH
4267: LD_INT 600
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: PPUSH
4282: CALL_OW 69
4286: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
4287: LD_ADDR_EXP 29
4291: PUSH
4292: LD_INT 22
4294: PUSH
4295: LD_INT 6
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 25
4304: PUSH
4305: LD_INT 3
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 24
4314: PUSH
4315: LD_INT 600
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: PUSH
4327: EMPTY
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
4335: LD_ADDR_EXP 30
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 6
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 4
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 24
4362: PUSH
4363: LD_INT 600
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: EMPTY
4376: LIST
4377: PPUSH
4378: CALL_OW 69
4382: ST_TO_ADDR
// ru_tw := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
4383: LD_ADDR_EXP 25
4387: PUSH
4388: LD_INT 22
4390: PUSH
4391: LD_INT 6
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: LD_INT 30
4403: PUSH
4404: LD_INT 31
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PUSH
4411: LD_INT 30
4413: PUSH
4414: LD_INT 32
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 24
4428: PUSH
4429: LD_INT 250
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: PPUSH
4444: CALL_OW 69
4448: ST_TO_ADDR
// ru_b := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) ;
4449: LD_ADDR_EXP 32
4453: PUSH
4454: LD_INT 22
4456: PUSH
4457: LD_INT 6
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 21
4466: PUSH
4467: LD_INT 3
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PPUSH
4478: CALL_OW 69
4482: ST_TO_ADDR
// b_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4483: LD_ADDR_VAR 0 6
4487: PUSH
4488: LD_INT 22
4490: PUSH
4491: LD_INT 6
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 21
4500: PUSH
4501: LD_INT 3
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: LD_INT 24
4513: PUSH
4514: LD_INT 1000
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: LIST
4529: PUSH
4530: EMPTY
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
4538: LD_ADDR_VAR 0 5
4542: PUSH
4543: LD_INT 22
4545: PUSH
4546: LD_INT 6
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 21
4555: PUSH
4556: LD_INT 1
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 3
4565: PUSH
4566: LD_INT 24
4568: PUSH
4569: LD_INT 600
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: PUSH
4585: EMPTY
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// b_weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
4593: LD_ADDR_VAR 0 8
4597: PUSH
4598: LD_INT 92
4600: PPUSH
4601: CALL_OW 478
4605: PUSH
4606: LD_INT 52
4608: PUSH
4609: LD_INT 51
4611: PUSH
4612: LD_INT 53
4614: PUSH
4615: LD_EXP 44
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: DIFF
4626: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_breastwork , b_workshop ] ;
4627: LD_ADDR_VAR 0 9
4631: PUSH
4632: LD_INT 0
4634: PUSH
4635: LD_INT 4
4637: PUSH
4638: LD_INT 31
4640: PUSH
4641: LD_INT 2
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: ST_TO_ADDR
// if FilterUnitsInArea ( kirov_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) > 0 then
4650: LD_INT 10
4652: PPUSH
4653: LD_INT 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 1
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 22
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: LIST
4680: PPUSH
4681: CALL_OW 70
4685: PUSH
4686: LD_INT 0
4688: GREATER
4689: IFFALSE 4701
// enemy_detected := true else
4691: LD_ADDR_VAR 0 10
4695: PUSH
4696: LD_INT 1
4698: ST_TO_ADDR
4699: GO 4709
// enemy_detected := false ;
4701: LD_ADDR_VAR 0 10
4705: PUSH
4706: LD_INT 0
4708: ST_TO_ADDR
// if enemy_detected = false then
4709: LD_VAR 0 10
4713: PUSH
4714: LD_INT 0
4716: EQUAL
4717: IFFALSE 4779
// for i = 1 to ru_b do
4719: LD_ADDR_VAR 0 1
4723: PUSH
4724: DOUBLE
4725: LD_INT 1
4727: DEC
4728: ST_TO_ADDR
4729: LD_EXP 32
4733: PUSH
4734: FOR_TO
4735: IFFALSE 4777
// if GetBType ( ru_b [ i ] ) in b_upgrade then
4737: LD_EXP 32
4741: PUSH
4742: LD_VAR 0 1
4746: ARRAY
4747: PPUSH
4748: CALL_OW 266
4752: PUSH
4753: LD_VAR 0 9
4757: IN
4758: IFFALSE 4775
// ComUpgrade ( ru_b [ i ] ) ;
4760: LD_EXP 32
4764: PUSH
4765: LD_VAR 0 1
4769: ARRAY
4770: PPUSH
4771: CALL_OW 146
4775: GO 4734
4777: POP
4778: POP
// if ru_sold > 0 then
4779: LD_EXP 23
4783: PUSH
4784: LD_INT 0
4786: GREATER
4787: IFFALSE 5235
// begin filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4789: LD_ADDR_VAR 0 4
4793: PUSH
4794: LD_EXP 23
4798: PPUSH
4799: LD_INT 3
4801: PUSH
4802: LD_INT 54
4804: PUSH
4805: EMPTY
4806: LIST
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PPUSH
4812: CALL_OW 72
4816: ST_TO_ADDR
// if UnitFilter ( ru_tw , [ f_empty ] ) > 0 then
4817: LD_EXP 25
4821: PPUSH
4822: LD_INT 58
4824: PUSH
4825: EMPTY
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: PUSH
4833: LD_INT 0
4835: GREATER
4836: IFFALSE 4938
// begin if filter = 0 then
4838: LD_VAR 0 4
4842: PUSH
4843: LD_INT 0
4845: EQUAL
4846: IFFALSE 4871
// ComExitBuilding ( ru_sold [ Rand ( 1 , ru_sold ) ] ) ;
4848: LD_EXP 23
4852: PUSH
4853: LD_INT 1
4855: PPUSH
4856: LD_EXP 23
4860: PPUSH
4861: CALL_OW 12
4865: ARRAY
4866: PPUSH
4867: CALL_OW 122
// filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4871: LD_ADDR_VAR 0 4
4875: PUSH
4876: LD_EXP 23
4880: PPUSH
4881: LD_INT 3
4883: PUSH
4884: LD_INT 54
4886: PUSH
4887: EMPTY
4888: LIST
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PPUSH
4894: CALL_OW 72
4898: ST_TO_ADDR
// if filter then
4899: LD_VAR 0 4
4903: IFFALSE 4938
// ComEnterUnit ( filter [ 1 ] , UnitFilter ( ru_tw , [ f_empty ] ) [ 1 ] ) ;
4905: LD_VAR 0 4
4909: PUSH
4910: LD_INT 1
4912: ARRAY
4913: PPUSH
4914: LD_EXP 25
4918: PPUSH
4919: LD_INT 58
4921: PUSH
4922: EMPTY
4923: LIST
4924: PPUSH
4925: CALL_OW 72
4929: PUSH
4930: LD_INT 1
4932: ARRAY
4933: PPUSH
4934: CALL_OW 120
// end ; if UnitFilter ( ru_tw , [ f_empty ] ) = 0 then
4938: LD_EXP 25
4942: PPUSH
4943: LD_INT 58
4945: PUSH
4946: EMPTY
4947: LIST
4948: PPUSH
4949: CALL_OW 72
4953: PUSH
4954: LD_INT 0
4956: EQUAL
4957: IFFALSE 5112
// begin b_unit := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4959: LD_ADDR_VAR 0 7
4963: PUSH
4964: LD_INT 22
4966: PUSH
4967: LD_INT 6
4969: PUSH
4970: EMPTY
4971: LIST
4972: LIST
4973: PUSH
4974: LD_INT 2
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 4
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 5
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: PPUSH
5006: CALL_OW 69
5010: ST_TO_ADDR
// if b_unit > 0 then
5011: LD_VAR 0 7
5015: PUSH
5016: LD_INT 0
5018: GREATER
5019: IFFALSE 5112
// for p = 1 to b_unit do
5021: LD_ADDR_VAR 0 2
5025: PUSH
5026: DOUBLE
5027: LD_INT 1
5029: DEC
5030: ST_TO_ADDR
5031: LD_VAR 0 7
5035: PUSH
5036: FOR_TO
5037: IFFALSE 5110
// if UnitsInSide ( b_unit [ p ] ) < 6 then
5039: LD_VAR 0 7
5043: PUSH
5044: LD_VAR 0 2
5048: ARRAY
5049: PPUSH
5050: CALL_OW 313
5054: PUSH
5055: LD_INT 6
5057: LESS
5058: IFFALSE 5108
// for i = 1 to filter do
5060: LD_ADDR_VAR 0 1
5064: PUSH
5065: DOUBLE
5066: LD_INT 1
5068: DEC
5069: ST_TO_ADDR
5070: LD_VAR 0 4
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5106
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
5078: LD_VAR 0 4
5082: PUSH
5083: LD_VAR 0 1
5087: ARRAY
5088: PPUSH
5089: LD_VAR 0 7
5093: PUSH
5094: LD_VAR 0 2
5098: ARRAY
5099: PPUSH
5100: CALL_OW 120
5104: GO 5075
5106: POP
5107: POP
5108: GO 5036
5110: POP
5111: POP
// end ; if UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
5112: LD_EXP 25
5116: PPUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 32
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: LD_INT 35
5129: PUSH
5130: LD_INT 0
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 72
5145: PUSH
5146: LD_INT 0
5148: GREATER
5149: IFFALSE 5235
// begin filter := UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
5151: LD_ADDR_VAR 0 4
5155: PUSH
5156: LD_EXP 25
5160: PPUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 32
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: LD_INT 35
5173: PUSH
5174: LD_INT 0
5176: PUSH
5177: EMPTY
5178: LIST
5179: LIST
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PPUSH
5185: CALL_OW 72
5189: ST_TO_ADDR
// if BuildingStatus ( ru_fac ) = bs_idle then
5190: LD_INT 92
5192: PPUSH
5193: CALL_OW 461
5197: PUSH
5198: LD_INT 2
5200: EQUAL
5201: IFFALSE 5235
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
5203: LD_VAR 0 4
5207: PUSH
5208: LD_INT 1
5210: ARRAY
5211: PPUSH
5212: LD_VAR 0 8
5216: PUSH
5217: LD_INT 1
5219: PPUSH
5220: LD_VAR 0 8
5224: PPUSH
5225: CALL_OW 12
5229: ARRAY
5230: PPUSH
5231: CALL_OW 148
// end ; end ; if ru_mech > 0 then
5235: LD_EXP 29
5239: PUSH
5240: LD_INT 0
5242: GREATER
5243: IFFALSE 5303
// for i = 1 to ru_mech do
5245: LD_ADDR_VAR 0 1
5249: PUSH
5250: DOUBLE
5251: LD_INT 1
5253: DEC
5254: ST_TO_ADDR
5255: LD_EXP 29
5259: PUSH
5260: FOR_TO
5261: IFFALSE 5301
// if not IsInUnit ( ru_mech [ i ] ) then
5263: LD_EXP 29
5267: PUSH
5268: LD_VAR 0 1
5272: ARRAY
5273: PPUSH
5274: CALL_OW 310
5278: NOT
5279: IFFALSE 5299
// ComEnterUnit ( ru_mech [ i ] , ru_fac ) ;
5281: LD_EXP 29
5285: PUSH
5286: LD_VAR 0 1
5290: ARRAY
5291: PPUSH
5292: LD_INT 92
5294: PPUSH
5295: CALL_OW 120
5299: GO 5260
5301: POP
5302: POP
// if ru_fac then
5303: LD_INT 92
5305: IFFALSE 5411
// if ru_veh > 0 then
5307: LD_EXP 27
5311: PUSH
5312: LD_INT 0
5314: GREATER
5315: IFFALSE 5411
// if BuildingStatus ( ru_fac ) = bs_idle then
5317: LD_INT 92
5319: PPUSH
5320: CALL_OW 461
5324: PUSH
5325: LD_INT 2
5327: EQUAL
5328: IFFALSE 5411
// begin ComConstruct ( ru_fac , ru_veh [ 1 ] , ru_veh [ 2 ] , ru_veh [ 3 ] , ru_veh [ 4 ] ) ;
5330: LD_INT 92
5332: PPUSH
5333: LD_EXP 27
5337: PUSH
5338: LD_INT 1
5340: ARRAY
5341: PPUSH
5342: LD_EXP 27
5346: PUSH
5347: LD_INT 2
5349: ARRAY
5350: PPUSH
5351: LD_EXP 27
5355: PUSH
5356: LD_INT 3
5358: ARRAY
5359: PPUSH
5360: LD_EXP 27
5364: PUSH
5365: LD_INT 4
5367: ARRAY
5368: PPUSH
5369: CALL_OW 125
// for i = 1 to 4 do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: DOUBLE
5379: LD_INT 1
5381: DEC
5382: ST_TO_ADDR
5383: LD_INT 4
5385: PUSH
5386: FOR_TO
5387: IFFALSE 5409
// ru_veh := Delete ( ru_veh , 1 ) ;
5389: LD_ADDR_EXP 27
5393: PUSH
5394: LD_EXP 27
5398: PPUSH
5399: LD_INT 1
5401: PPUSH
5402: CALL_OW 3
5406: ST_TO_ADDR
5407: GO 5386
5409: POP
5410: POP
// end ; if ru_bul > 0 and enemy_detected = false then
5411: LD_EXP 31
5415: PUSH
5416: LD_INT 0
5418: GREATER
5419: PUSH
5420: LD_VAR 0 10
5424: PUSH
5425: LD_INT 0
5427: EQUAL
5428: AND
5429: IFFALSE 5532
// if ru_eng > 0 then
5431: LD_EXP 28
5435: PUSH
5436: LD_INT 0
5438: GREATER
5439: IFFALSE 5532
// for i = 1 to ru_eng do
5441: LD_ADDR_VAR 0 1
5445: PUSH
5446: DOUBLE
5447: LD_INT 1
5449: DEC
5450: ST_TO_ADDR
5451: LD_EXP 28
5455: PUSH
5456: FOR_TO
5457: IFFALSE 5530
// if not HasTask ( ru_eng [ i ] ) then
5459: LD_EXP 28
5463: PUSH
5464: LD_VAR 0 1
5468: ARRAY
5469: PPUSH
5470: CALL_OW 314
5474: NOT
5475: IFFALSE 5528
// begin ComBuild ( ru_eng [ i ] , ru_bul [ 1 ] , ru_bul [ 2 ] , ru_bul [ 3 ] , ru_bul [ 4 ] ) ;
5477: LD_EXP 28
5481: PUSH
5482: LD_VAR 0 1
5486: ARRAY
5487: PPUSH
5488: LD_EXP 31
5492: PUSH
5493: LD_INT 1
5495: ARRAY
5496: PPUSH
5497: LD_EXP 31
5501: PUSH
5502: LD_INT 2
5504: ARRAY
5505: PPUSH
5506: LD_EXP 31
5510: PUSH
5511: LD_INT 3
5513: ARRAY
5514: PPUSH
5515: LD_EXP 31
5519: PUSH
5520: LD_INT 4
5522: ARRAY
5523: PPUSH
5524: CALL_OW 145
// end ;
5528: GO 5456
5530: POP
5531: POP
// if b_dmgunit > 0 then
5532: LD_VAR 0 6
5536: PUSH
5537: LD_INT 0
5539: GREATER
5540: IFFALSE 5725
// begin if ru_eng > 0 then
5542: LD_EXP 28
5546: PUSH
5547: LD_INT 0
5549: GREATER
5550: IFFALSE 5630
// for i = 1 to ru_eng do
5552: LD_ADDR_VAR 0 1
5556: PUSH
5557: DOUBLE
5558: LD_INT 1
5560: DEC
5561: ST_TO_ADDR
5562: LD_EXP 28
5566: PUSH
5567: FOR_TO
5568: IFFALSE 5628
// begin if IsInUnit ( ru_eng [ i ] ) then
5570: LD_EXP 28
5574: PUSH
5575: LD_VAR 0 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 310
5585: IFFALSE 5602
// ComExitBuilding ( ru_eng [ i ] ) ;
5587: LD_EXP 28
5591: PUSH
5592: LD_VAR 0 1
5596: ARRAY
5597: PPUSH
5598: CALL_OW 122
// ComRepairBuilding ( ru_eng [ i ] , b_dmgunit [ 1 ] ) ;
5602: LD_EXP 28
5606: PUSH
5607: LD_VAR 0 1
5611: ARRAY
5612: PPUSH
5613: LD_VAR 0 6
5617: PUSH
5618: LD_INT 1
5620: ARRAY
5621: PPUSH
5622: CALL_OW 130
// end ;
5626: GO 5567
5628: POP
5629: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) > 0 then
5630: LD_INT 22
5632: PUSH
5633: LD_INT 6
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 34
5642: PUSH
5643: LD_INT 52
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: PUSH
5659: LD_INT 0
5661: GREATER
5662: IFFALSE 5723
// for p in FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) do
5664: LD_ADDR_VAR 0 2
5668: PUSH
5669: LD_INT 22
5671: PUSH
5672: LD_INT 6
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 34
5681: PUSH
5682: LD_INT 52
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PPUSH
5693: CALL_OW 69
5697: PUSH
5698: FOR_IN
5699: IFFALSE 5721
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
5701: LD_VAR 0 2
5705: PPUSH
5706: LD_VAR 0 6
5710: PUSH
5711: LD_INT 1
5713: ARRAY
5714: PPUSH
5715: CALL_OW 130
5719: GO 5698
5721: POP
5722: POP
// end else
5723: GO 5853
// if ru_bul = 0 then
5725: LD_EXP 31
5729: PUSH
5730: LD_INT 0
5732: EQUAL
5733: IFFALSE 5853
// for i = 1 to ru_eng do
5735: LD_ADDR_VAR 0 1
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_EXP 28
5749: PUSH
5750: FOR_TO
5751: IFFALSE 5851
// if not HasTask ( ru_eng [ i ] ) then
5753: LD_EXP 28
5757: PUSH
5758: LD_VAR 0 1
5762: ARRAY
5763: PPUSH
5764: CALL_OW 314
5768: NOT
5769: IFFALSE 5849
// ComEnterUnit ( ru_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru_eng [ i ] ) ) ;
5771: LD_EXP 28
5775: PUSH
5776: LD_VAR 0 1
5780: ARRAY
5781: PPUSH
5782: LD_INT 22
5784: PUSH
5785: LD_INT 6
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PUSH
5792: LD_INT 2
5794: PUSH
5795: LD_INT 30
5797: PUSH
5798: LD_INT 0
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: PUSH
5805: LD_INT 30
5807: PUSH
5808: LD_INT 1
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: PPUSH
5824: CALL_OW 69
5828: PPUSH
5829: LD_EXP 28
5833: PUSH
5834: LD_VAR 0 1
5838: ARRAY
5839: PPUSH
5840: CALL_OW 74
5844: PPUSH
5845: CALL_OW 120
5849: GO 5750
5851: POP
5852: POP
// if h_dmgunit > 0 then
5853: LD_VAR 0 5
5857: PUSH
5858: LD_INT 0
5860: GREATER
5861: IFFALSE 6068
// begin for p = 1 to h_dmgunit do
5863: LD_ADDR_VAR 0 2
5867: PUSH
5868: DOUBLE
5869: LD_INT 1
5871: DEC
5872: ST_TO_ADDR
5873: LD_VAR 0 5
5877: PUSH
5878: FOR_TO
5879: IFFALSE 5928
// if GetDistUnits ( h_dmgunit [ p ] , ru_lab ) > 6 then
5881: LD_VAR 0 5
5885: PUSH
5886: LD_VAR 0 2
5890: ARRAY
5891: PPUSH
5892: LD_INT 83
5894: PPUSH
5895: CALL_OW 296
5899: PUSH
5900: LD_INT 6
5902: GREATER
5903: IFFALSE 5926
// ComMoveXY ( h_dmgunit [ p ] , 140 , 76 ) ;
5905: LD_VAR 0 5
5909: PUSH
5910: LD_VAR 0 2
5914: ARRAY
5915: PPUSH
5916: LD_INT 140
5918: PPUSH
5919: LD_INT 76
5921: PPUSH
5922: CALL_OW 111
5926: GO 5878
5928: POP
5929: POP
// if ru_sci > 0 then
5930: LD_EXP 30
5934: PUSH
5935: LD_INT 0
5937: GREATER
5938: IFFALSE 6068
// for i = 1 to ru_sci do
5940: LD_ADDR_VAR 0 1
5944: PUSH
5945: DOUBLE
5946: LD_INT 1
5948: DEC
5949: ST_TO_ADDR
5950: LD_EXP 30
5954: PUSH
5955: FOR_TO
5956: IFFALSE 6066
// if IsInUnit ( ru_sci [ i ] ) then
5958: LD_EXP 30
5962: PUSH
5963: LD_VAR 0 1
5967: ARRAY
5968: PPUSH
5969: CALL_OW 310
5973: IFFALSE 5992
// ComExitBuilding ( ru_sci [ i ] ) else
5975: LD_EXP 30
5979: PUSH
5980: LD_VAR 0 1
5984: ARRAY
5985: PPUSH
5986: CALL_OW 122
5990: GO 6064
// if not HasTask ( ru_sci [ i ] ) then
5992: LD_EXP 30
5996: PUSH
5997: LD_VAR 0 1
6001: ARRAY
6002: PPUSH
6003: CALL_OW 314
6007: NOT
6008: IFFALSE 6064
// if GetDistUnits ( ru_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
6010: LD_EXP 30
6014: PUSH
6015: LD_VAR 0 1
6019: ARRAY
6020: PPUSH
6021: LD_VAR 0 5
6025: PUSH
6026: LD_INT 1
6028: ARRAY
6029: PPUSH
6030: CALL_OW 296
6034: PUSH
6035: LD_INT 15
6037: LESSEQUAL
6038: IFFALSE 6064
// ComHeal ( ru_sci [ i ] , h_dmgunit [ 1 ] ) ;
6040: LD_EXP 30
6044: PUSH
6045: LD_VAR 0 1
6049: ARRAY
6050: PPUSH
6051: LD_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: ARRAY
6059: PPUSH
6060: CALL_OW 128
6064: GO 5955
6066: POP
6067: POP
// end ; if h_dmgunit = 0 then
6068: LD_VAR 0 5
6072: PUSH
6073: LD_INT 0
6075: EQUAL
6076: IFFALSE 6193
// begin for i = 1 to ru_sci do
6078: LD_ADDR_VAR 0 1
6082: PUSH
6083: DOUBLE
6084: LD_INT 1
6086: DEC
6087: ST_TO_ADDR
6088: LD_EXP 30
6092: PUSH
6093: FOR_TO
6094: IFFALSE 6134
// if not IsInUnit ( ru_sci [ i ] ) then
6096: LD_EXP 30
6100: PUSH
6101: LD_VAR 0 1
6105: ARRAY
6106: PPUSH
6107: CALL_OW 310
6111: NOT
6112: IFFALSE 6132
// ComEnterUnit ( ru_sci [ i ] , ru_lab ) ;
6114: LD_EXP 30
6118: PUSH
6119: LD_VAR 0 1
6123: ARRAY
6124: PPUSH
6125: LD_INT 83
6127: PPUSH
6128: CALL_OW 120
6132: GO 6093
6134: POP
6135: POP
// if ru_tech > 0 then
6136: LD_EXP 26
6140: PUSH
6141: LD_INT 0
6143: GREATER
6144: IFFALSE 6193
// if BuildingStatus ( ru_lab ) = bs_idle then
6146: LD_INT 83
6148: PPUSH
6149: CALL_OW 461
6153: PUSH
6154: LD_INT 2
6156: EQUAL
6157: IFFALSE 6193
// begin ComResearch ( ru_lab , ru_tech [ 1 ] ) ;
6159: LD_INT 83
6161: PPUSH
6162: LD_EXP 26
6166: PUSH
6167: LD_INT 1
6169: ARRAY
6170: PPUSH
6171: CALL_OW 124
// ru_tech := Delete ( ru_tech , 1 ) ;
6175: LD_ADDR_EXP 26
6179: PUSH
6180: LD_EXP 26
6184: PPUSH
6185: LD_INT 1
6187: PPUSH
6188: CALL_OW 3
6192: ST_TO_ADDR
// end ; end ; end ;
6193: PPOPN 10
6195: END
// every 20 20$00 trigger ru_fac do var weap ;
6196: LD_INT 92
6198: IFFALSE 6425
6200: GO 6202
6202: DISABLE
6203: LD_INT 0
6205: PPUSH
// begin enable ;
6206: ENABLE
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6207: LD_ADDR_VAR 0 1
6211: PUSH
6212: LD_INT 22
6214: PUSH
6215: LD_INT 6
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 30
6224: PUSH
6225: LD_INT 3
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PPUSH
6236: CALL_OW 69
6240: PUSH
6241: LD_INT 1
6243: ARRAY
6244: PPUSH
6245: CALL_OW 478
6249: PUSH
6250: LD_INT 52
6252: PUSH
6253: LD_INT 51
6255: PUSH
6256: LD_INT 53
6258: PUSH
6259: LD_EXP 44
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: DIFF
6270: ST_TO_ADDR
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6271: LD_ADDR_EXP 27
6275: PUSH
6276: LD_EXP 27
6280: PUSH
6281: LD_INT 23
6283: PUSH
6284: LD_INT 1
6286: PUSH
6287: LD_INT 1
6289: PUSH
6290: LD_VAR 0 1
6294: PUSH
6295: LD_INT 1
6297: PPUSH
6298: LD_VAR 0 1
6302: PPUSH
6303: CALL_OW 12
6307: ARRAY
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: ADD
6315: ST_TO_ADDR
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6316: LD_ADDR_VAR 0 1
6320: PUSH
6321: LD_INT 22
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 30
6333: PUSH
6334: LD_INT 3
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PPUSH
6345: CALL_OW 69
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: CALL_OW 478
6358: PUSH
6359: LD_INT 52
6361: PUSH
6362: LD_INT 51
6364: PUSH
6365: LD_INT 53
6367: PUSH
6368: LD_EXP 44
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: DIFF
6379: ST_TO_ADDR
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6380: LD_ADDR_EXP 37
6384: PUSH
6385: LD_EXP 37
6389: PUSH
6390: LD_INT 23
6392: PUSH
6393: LD_INT 1
6395: PUSH
6396: LD_INT 1
6398: PUSH
6399: LD_VAR 0 1
6403: PUSH
6404: LD_INT 1
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 12
6416: ARRAY
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: ADD
6424: ST_TO_ADDR
// end ;
6425: PPOPN 1
6427: END
// every 0 0$03 do var i , c , p , skr , filter , cargo , dep ;
6428: GO 6430
6430: DISABLE
6431: LD_INT 0
6433: PPUSH
6434: PPUSH
6435: PPUSH
6436: PPUSH
6437: PPUSH
6438: PPUSH
6439: PPUSH
// begin enable ;
6440: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
6441: LD_ADDR_VAR 0 5
6445: PUSH
6446: LD_INT 50
6448: PUSH
6449: EMPTY
6450: LIST
6451: PUSH
6452: LD_INT 22
6454: PUSH
6455: LD_INT 6
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PUSH
6462: LD_INT 2
6464: PUSH
6465: LD_INT 25
6467: PUSH
6468: LD_INT 2
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: LD_INT 25
6477: PUSH
6478: LD_INT 16
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_weapon , ru_cargo_bay ] , [ f_lives , 600 ] ] ) ;
6500: LD_ADDR_VAR 0 6
6504: PUSH
6505: LD_INT 2
6507: PUSH
6508: LD_INT 22
6510: PUSH
6511: LD_INT 6
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 22
6520: PUSH
6521: LD_INT 3
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: PUSH
6533: LD_INT 34
6535: PUSH
6536: LD_INT 51
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: PUSH
6543: LD_INT 24
6545: PUSH
6546: LD_INT 600
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: LIST
6557: PPUSH
6558: CALL_OW 69
6562: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6563: LD_ADDR_VAR 0 7
6567: PUSH
6568: LD_INT 2
6570: PUSH
6571: LD_INT 22
6573: PUSH
6574: LD_INT 6
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 22
6583: PUSH
6584: LD_INT 3
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 2
6598: PUSH
6599: LD_INT 30
6601: PUSH
6602: LD_INT 0
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: LD_INT 30
6611: PUSH
6612: LD_INT 1
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: PPUSH
6628: CALL_OW 69
6632: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_main_area ) ;
6633: LD_ADDR_VAR 0 4
6637: PUSH
6638: LD_INT 2
6640: PPUSH
6641: CALL_OW 435
6645: ST_TO_ADDR
// c = 1 ;
6646: LD_ADDR_VAR 0 2
6650: PUSH
6651: LD_INT 1
6653: ST_TO_ADDR
// if cargo > 0 then
6654: LD_VAR 0 6
6658: PUSH
6659: LD_INT 0
6661: GREATER
6662: IFFALSE 6954
// while c < skr do
6664: LD_VAR 0 2
6668: PUSH
6669: LD_VAR 0 4
6673: LESS
6674: IFFALSE 6954
// begin if cargo then
6676: LD_VAR 0 6
6680: IFFALSE 6952
// for i in cargo do
6682: LD_ADDR_VAR 0 1
6686: PUSH
6687: LD_VAR 0 6
6691: PUSH
6692: FOR_IN
6693: IFFALSE 6950
// begin if not IsOk ( i ) or not skr then
6695: LD_VAR 0 1
6699: PPUSH
6700: CALL_OW 302
6704: NOT
6705: PUSH
6706: LD_VAR 0 4
6710: NOT
6711: OR
6712: IFFALSE 6716
// continue ;
6714: GO 6692
// if c > skr then
6716: LD_VAR 0 2
6720: PUSH
6721: LD_VAR 0 4
6725: GREATER
6726: IFFALSE 6730
// continue ;
6728: GO 6692
// if GetFuel ( i ) > 40 and GetDistUnitXY ( i , skr [ c ] , skr [ c + 1 ] ) < 51 then
6730: LD_VAR 0 1
6734: PPUSH
6735: CALL_OW 261
6739: PUSH
6740: LD_INT 40
6742: GREATER
6743: PUSH
6744: LD_VAR 0 1
6748: PPUSH
6749: LD_VAR 0 4
6753: PUSH
6754: LD_VAR 0 2
6758: ARRAY
6759: PPUSH
6760: LD_VAR 0 4
6764: PUSH
6765: LD_VAR 0 2
6769: PUSH
6770: LD_INT 1
6772: PLUS
6773: ARRAY
6774: PPUSH
6775: CALL_OW 297
6779: PUSH
6780: LD_INT 51
6782: LESS
6783: AND
6784: IFFALSE 6821
// ComCollect ( i , skr [ c ] , skr [ c + 1 ] ) ;
6786: LD_VAR 0 1
6790: PPUSH
6791: LD_VAR 0 4
6795: PUSH
6796: LD_VAR 0 2
6800: ARRAY
6801: PPUSH
6802: LD_VAR 0 4
6806: PUSH
6807: LD_VAR 0 2
6811: PUSH
6812: LD_INT 1
6814: PLUS
6815: ARRAY
6816: PPUSH
6817: CALL_OW 117
// if GetFuel ( i ) <= 40 then
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 261
6830: PUSH
6831: LD_INT 40
6833: LESSEQUAL
6834: IFFALSE 6934
// begin repeat begin ComMoveXY ( i , GetX ( NearestUnitToUnit ( dep , i ) ) , GetY ( NearestUnitToUnit ( dep , i ) ) ) ;
6836: LD_VAR 0 1
6840: PPUSH
6841: LD_VAR 0 7
6845: PPUSH
6846: LD_VAR 0 1
6850: PPUSH
6851: CALL_OW 74
6855: PPUSH
6856: CALL_OW 250
6860: PPUSH
6861: LD_VAR 0 7
6865: PPUSH
6866: LD_VAR 0 1
6870: PPUSH
6871: CALL_OW 74
6875: PPUSH
6876: CALL_OW 251
6880: PPUSH
6881: CALL_OW 111
// Wait ( 0 0$01 ) ;
6885: LD_INT 35
6887: PPUSH
6888: CALL_OW 67
// end until GetDistUnits ( i , NearestUnitToUnit ( dep , i ) ) < 5 ;
6892: LD_VAR 0 1
6896: PPUSH
6897: LD_VAR 0 7
6901: PPUSH
6902: LD_VAR 0 1
6906: PPUSH
6907: CALL_OW 74
6911: PPUSH
6912: CALL_OW 296
6916: PUSH
6917: LD_INT 5
6919: LESS
6920: IFFALSE 6836
// SetFuel ( i , 100 ) ;
6922: LD_VAR 0 1
6926: PPUSH
6927: LD_INT 100
6929: PPUSH
6930: CALL_OW 240
// end ; c = c + 2 ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 2
6946: PLUS
6947: ST_TO_ADDR
// end ;
6948: GO 6692
6950: POP
6951: POP
// end ;
6952: GO 6664
// end ;
6954: PPOPN 7
6956: END
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , b_fac , b_labb , b_ext , enemy_detected ;
6957: GO 6959
6959: DISABLE
6960: LD_INT 0
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
// begin enable ;
6975: ENABLE
// ru2_sold := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) ;
6976: LD_ADDR_EXP 33
6980: PUSH
6981: LD_INT 22
6983: PUSH
6984: LD_INT 3
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 25
6993: PUSH
6994: LD_INT 1
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: PUSH
7001: LD_INT 24
7003: PUSH
7004: LD_INT 600
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: PUSH
7016: EMPTY
7017: LIST
7018: PPUSH
7019: CALL_OW 69
7023: ST_TO_ADDR
// ru2_eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
7024: LD_ADDR_EXP 38
7028: PUSH
7029: LD_INT 22
7031: PUSH
7032: LD_INT 3
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 25
7041: PUSH
7042: LD_INT 2
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PUSH
7049: LD_INT 24
7051: PUSH
7052: LD_INT 600
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: EMPTY
7060: LIST
7061: LIST
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: PPUSH
7067: CALL_OW 69
7071: ST_TO_ADDR
// ru2_mech := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
7072: LD_ADDR_EXP 39
7076: PUSH
7077: LD_INT 22
7079: PUSH
7080: LD_INT 3
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 25
7089: PUSH
7090: LD_INT 3
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: PUSH
7097: LD_INT 24
7099: PUSH
7100: LD_INT 600
7102: PUSH
7103: EMPTY
7104: LIST
7105: LIST
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: PPUSH
7115: CALL_OW 69
7119: ST_TO_ADDR
// ru2_sci := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
7120: LD_ADDR_EXP 40
7124: PUSH
7125: LD_INT 22
7127: PUSH
7128: LD_INT 3
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 25
7137: PUSH
7138: LD_INT 4
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 24
7147: PUSH
7148: LD_INT 600
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: LIST
7159: PUSH
7160: EMPTY
7161: LIST
7162: PPUSH
7163: CALL_OW 69
7167: ST_TO_ADDR
// ru2_tw := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
7168: LD_ADDR_EXP 35
7172: PUSH
7173: LD_INT 22
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: LD_INT 2
7185: PUSH
7186: LD_INT 30
7188: PUSH
7189: LD_INT 31
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 30
7198: PUSH
7199: LD_INT 32
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: PUSH
7211: LD_INT 24
7213: PUSH
7214: LD_INT 250
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: EMPTY
7227: LIST
7228: PPUSH
7229: CALL_OW 69
7233: ST_TO_ADDR
// ru2_b := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
7234: LD_ADDR_EXP 42
7238: PUSH
7239: LD_INT 22
7241: PUSH
7242: LD_INT 3
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: LD_INT 21
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PPUSH
7263: CALL_OW 69
7267: ST_TO_ADDR
// b_dmgunit := FilterUnitsInArea ( beria_defa , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
7268: LD_ADDR_VAR 0 6
7272: PUSH
7273: LD_INT 17
7275: PPUSH
7276: LD_INT 22
7278: PUSH
7279: LD_INT 3
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: PUSH
7286: LD_INT 21
7288: PUSH
7289: LD_INT 3
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 24
7301: PUSH
7302: LD_INT 1000
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: LIST
7317: PUSH
7318: EMPTY
7319: LIST
7320: PPUSH
7321: CALL_OW 70
7325: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
7326: LD_ADDR_VAR 0 5
7330: PUSH
7331: LD_INT 22
7333: PUSH
7334: LD_INT 3
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: LD_INT 21
7343: PUSH
7344: LD_INT 1
7346: PUSH
7347: EMPTY
7348: LIST
7349: LIST
7350: PUSH
7351: LD_INT 3
7353: PUSH
7354: LD_INT 24
7356: PUSH
7357: LD_INT 600
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PUSH
7373: EMPTY
7374: LIST
7375: PPUSH
7376: CALL_OW 69
7380: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7381: LD_INT 22
7383: PUSH
7384: LD_INT 3
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: PUSH
7391: LD_INT 30
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: EMPTY
7398: LIST
7399: LIST
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PPUSH
7405: CALL_OW 69
7409: IFFALSE 7449
// b_fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7411: LD_ADDR_VAR 0 10
7415: PUSH
7416: LD_INT 22
7418: PUSH
7419: LD_INT 3
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 30
7428: PUSH
7429: LD_INT 3
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PPUSH
7440: CALL_OW 69
7444: PUSH
7445: LD_INT 1
7447: ARRAY
7448: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
7449: LD_INT 22
7451: PUSH
7452: LD_INT 3
7454: PUSH
7455: EMPTY
7456: LIST
7457: LIST
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 30
7464: PUSH
7465: LD_INT 6
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 30
7474: PUSH
7475: LD_INT 7
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 30
7484: PUSH
7485: LD_INT 8
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: LIST
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PPUSH
7502: CALL_OW 69
7506: IFFALSE 7575
// b_labb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7508: LD_ADDR_VAR 0 11
7512: PUSH
7513: LD_INT 22
7515: PUSH
7516: LD_INT 3
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 30
7528: PUSH
7529: LD_INT 6
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 30
7538: PUSH
7539: LD_INT 7
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 30
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: LIST
7560: LIST
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PPUSH
7566: CALL_OW 69
7570: PUSH
7571: LD_INT 1
7573: ARRAY
7574: ST_TO_ADDR
// b_weap := AvailableWeaponList ( b_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
7575: LD_ADDR_VAR 0 8
7579: PUSH
7580: LD_VAR 0 10
7584: PPUSH
7585: CALL_OW 478
7589: PUSH
7590: LD_INT 52
7592: PUSH
7593: LD_INT 51
7595: PUSH
7596: LD_INT 53
7598: PUSH
7599: LD_EXP 44
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: LIST
7608: LIST
7609: DIFF
7610: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_workshop ] ;
7611: LD_ADDR_VAR 0 9
7615: PUSH
7616: LD_INT 0
7618: PUSH
7619: LD_INT 4
7621: PUSH
7622: LD_INT 2
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: LIST
7629: ST_TO_ADDR
// b_ext := [ ] ;
7630: LD_ADDR_VAR 0 12
7634: PUSH
7635: EMPTY
7636: ST_TO_ADDR
// if FilterUnitsInArea ( beria_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) diff FilterAllUnits ( [ f_weapon , us_radar ] ) > 0 then
7637: LD_INT 11
7639: PPUSH
7640: LD_INT 2
7642: PUSH
7643: LD_INT 22
7645: PUSH
7646: LD_INT 1
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: LIST
7667: PPUSH
7668: CALL_OW 70
7672: PUSH
7673: LD_INT 34
7675: PUSH
7676: LD_INT 11
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 69
7687: PUSH
7688: LD_INT 0
7690: GREATER
7691: DIFF
7692: IFFALSE 7704
// enemy_detected := true else
7694: LD_ADDR_VAR 0 13
7698: PUSH
7699: LD_INT 1
7701: ST_TO_ADDR
7702: GO 7712
// enemy_detected := false ;
7704: LD_ADDR_VAR 0 13
7708: PUSH
7709: LD_INT 0
7711: ST_TO_ADDR
// if enemy_detected = false then
7712: LD_VAR 0 13
7716: PUSH
7717: LD_INT 0
7719: EQUAL
7720: IFFALSE 7821
// for i = 1 to ru2_b do
7722: LD_ADDR_VAR 0 1
7726: PUSH
7727: DOUBLE
7728: LD_INT 1
7730: DEC
7731: ST_TO_ADDR
7732: LD_EXP 42
7736: PUSH
7737: FOR_TO
7738: IFFALSE 7819
// begin if GetBType ( ru2_b [ i ] ) in b_upgrade then
7740: LD_EXP 42
7744: PUSH
7745: LD_VAR 0 1
7749: ARRAY
7750: PPUSH
7751: CALL_OW 266
7755: PUSH
7756: LD_VAR 0 9
7760: IN
7761: IFFALSE 7778
// ComUpgrade ( ru2_b [ i ] ) ;
7763: LD_EXP 42
7767: PUSH
7768: LD_VAR 0 1
7772: ARRAY
7773: PPUSH
7774: CALL_OW 146
// if GetBType ( ru2_b [ i ] ) in b_lab then
7778: LD_EXP 42
7782: PUSH
7783: LD_VAR 0 1
7787: ARRAY
7788: PPUSH
7789: CALL_OW 266
7793: PUSH
7794: LD_INT 6
7796: IN
7797: IFFALSE 7817
// ComUpgradeLab ( ru2_b [ i ] , b_lab_weapon ) ;
7799: LD_EXP 42
7803: PUSH
7804: LD_VAR 0 1
7808: ARRAY
7809: PPUSH
7810: LD_INT 10
7812: PPUSH
7813: CALL_OW 147
// end ;
7817: GO 7737
7819: POP
7820: POP
// if ru2_sold > 0 then
7821: LD_EXP 33
7825: PUSH
7826: LD_INT 0
7828: GREATER
7829: IFFALSE 8327
// begin filter := UnitFilter ( ru2_sold , [ f_not , [ f_inside ] ] ) ;
7831: LD_ADDR_VAR 0 4
7835: PUSH
7836: LD_EXP 33
7840: PPUSH
7841: LD_INT 3
7843: PUSH
7844: LD_INT 54
7846: PUSH
7847: EMPTY
7848: LIST
7849: PUSH
7850: EMPTY
7851: LIST
7852: LIST
7853: PPUSH
7854: CALL_OW 72
7858: ST_TO_ADDR
// if UnitFilter ( ru2_tw , [ f_empty ] ) > 0 then
7859: LD_EXP 35
7863: PPUSH
7864: LD_INT 58
7866: PUSH
7867: EMPTY
7868: LIST
7869: PPUSH
7870: CALL_OW 72
7874: PUSH
7875: LD_INT 0
7877: GREATER
7878: IFFALSE 8028
// begin if filter = 0 then
7880: LD_VAR 0 4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7913
// ComExitBuilding ( ru2_sold [ Rand ( 1 , ru2_sold ) ] ) ;
7890: LD_EXP 33
7894: PUSH
7895: LD_INT 1
7897: PPUSH
7898: LD_EXP 33
7902: PPUSH
7903: CALL_OW 12
7907: ARRAY
7908: PPUSH
7909: CALL_OW 122
// if UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
7913: LD_VAR 0 4
7917: PPUSH
7918: LD_INT 3
7920: PUSH
7921: LD_INT 60
7923: PUSH
7924: EMPTY
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PPUSH
7931: CALL_OW 72
7935: IFFALSE 8028
// for i in UnitFilter ( ru2_tw , [ f_empty ] ) do
7937: LD_ADDR_VAR 0 1
7941: PUSH
7942: LD_EXP 35
7946: PPUSH
7947: LD_INT 58
7949: PUSH
7950: EMPTY
7951: LIST
7952: PPUSH
7953: CALL_OW 72
7957: PUSH
7958: FOR_IN
7959: IFFALSE 8026
// begin ComEnterUnit ( UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) [ 1 ] , i ) ;
7961: LD_VAR 0 4
7965: PPUSH
7966: LD_INT 3
7968: PUSH
7969: LD_INT 60
7971: PUSH
7972: EMPTY
7973: LIST
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 72
7983: PUSH
7984: LD_INT 1
7986: ARRAY
7987: PPUSH
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 120
// if not UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
7997: LD_VAR 0 4
8001: PPUSH
8002: LD_INT 3
8004: PUSH
8005: LD_INT 60
8007: PUSH
8008: EMPTY
8009: LIST
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: PPUSH
8015: CALL_OW 72
8019: NOT
8020: IFFALSE 8024
// break ;
8022: GO 8026
// end ;
8024: GO 7958
8026: POP
8027: POP
// end ; if UnitFilter ( ru2_tw , [ f_empty ] ) = 0 then
8028: LD_EXP 35
8032: PPUSH
8033: LD_INT 58
8035: PUSH
8036: EMPTY
8037: LIST
8038: PPUSH
8039: CALL_OW 72
8043: PUSH
8044: LD_INT 0
8046: EQUAL
8047: IFFALSE 8202
// begin b_unit := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
8049: LD_ADDR_VAR 0 7
8053: PUSH
8054: LD_INT 22
8056: PUSH
8057: LD_INT 3
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: LD_INT 2
8066: PUSH
8067: LD_INT 30
8069: PUSH
8070: LD_INT 4
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: PUSH
8077: LD_INT 30
8079: PUSH
8080: LD_INT 5
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: ST_TO_ADDR
// if b_unit > 0 then
8101: LD_VAR 0 7
8105: PUSH
8106: LD_INT 0
8108: GREATER
8109: IFFALSE 8202
// for p = 1 to b_unit do
8111: LD_ADDR_VAR 0 2
8115: PUSH
8116: DOUBLE
8117: LD_INT 1
8119: DEC
8120: ST_TO_ADDR
8121: LD_VAR 0 7
8125: PUSH
8126: FOR_TO
8127: IFFALSE 8200
// if UnitsInSide ( b_unit [ p ] ) < 6 then
8129: LD_VAR 0 7
8133: PUSH
8134: LD_VAR 0 2
8138: ARRAY
8139: PPUSH
8140: CALL_OW 313
8144: PUSH
8145: LD_INT 6
8147: LESS
8148: IFFALSE 8198
// for i = 1 to filter do
8150: LD_ADDR_VAR 0 1
8154: PUSH
8155: DOUBLE
8156: LD_INT 1
8158: DEC
8159: ST_TO_ADDR
8160: LD_VAR 0 4
8164: PUSH
8165: FOR_TO
8166: IFFALSE 8196
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
8168: LD_VAR 0 4
8172: PUSH
8173: LD_VAR 0 1
8177: ARRAY
8178: PPUSH
8179: LD_VAR 0 7
8183: PUSH
8184: LD_VAR 0 2
8188: ARRAY
8189: PPUSH
8190: CALL_OW 120
8194: GO 8165
8196: POP
8197: POP
8198: GO 8126
8200: POP
8201: POP
// end ; if UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
8202: LD_EXP 35
8206: PPUSH
8207: LD_INT 30
8209: PUSH
8210: LD_INT 32
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: LD_INT 35
8219: PUSH
8220: LD_INT 0
8222: PUSH
8223: EMPTY
8224: LIST
8225: LIST
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 72
8235: PUSH
8236: LD_INT 0
8238: GREATER
8239: IFFALSE 8327
// begin filter := UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
8241: LD_ADDR_VAR 0 4
8245: PUSH
8246: LD_EXP 35
8250: PPUSH
8251: LD_INT 30
8253: PUSH
8254: LD_INT 32
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: LD_INT 35
8263: PUSH
8264: LD_INT 0
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PPUSH
8275: CALL_OW 72
8279: ST_TO_ADDR
// if BuildingStatus ( b_fac ) = bs_idle then
8280: LD_VAR 0 10
8284: PPUSH
8285: CALL_OW 461
8289: PUSH
8290: LD_INT 2
8292: EQUAL
8293: IFFALSE 8327
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
8295: LD_VAR 0 4
8299: PUSH
8300: LD_INT 1
8302: ARRAY
8303: PPUSH
8304: LD_VAR 0 8
8308: PUSH
8309: LD_INT 1
8311: PPUSH
8312: LD_VAR 0 8
8316: PPUSH
8317: CALL_OW 12
8321: ARRAY
8322: PPUSH
8323: CALL_OW 148
// end ; end ; if b_fac > 0 and ru2_mech > 0 then
8327: LD_VAR 0 10
8331: PUSH
8332: LD_INT 0
8334: GREATER
8335: PUSH
8336: LD_EXP 39
8340: PUSH
8341: LD_INT 0
8343: GREATER
8344: AND
8345: IFFALSE 8407
// for i = 1 to ru2_mech do
8347: LD_ADDR_VAR 0 1
8351: PUSH
8352: DOUBLE
8353: LD_INT 1
8355: DEC
8356: ST_TO_ADDR
8357: LD_EXP 39
8361: PUSH
8362: FOR_TO
8363: IFFALSE 8405
// if not IsInUnit ( ru2_mech [ i ] ) then
8365: LD_EXP 39
8369: PUSH
8370: LD_VAR 0 1
8374: ARRAY
8375: PPUSH
8376: CALL_OW 310
8380: NOT
8381: IFFALSE 8403
// ComEnterUnit ( ru2_mech [ i ] , b_fac ) ;
8383: LD_EXP 39
8387: PUSH
8388: LD_VAR 0 1
8392: ARRAY
8393: PPUSH
8394: LD_VAR 0 10
8398: PPUSH
8399: CALL_OW 120
8403: GO 8362
8405: POP
8406: POP
// if b_fac > 0 and ru2_veh > 0 then
8407: LD_VAR 0 10
8411: PUSH
8412: LD_INT 0
8414: GREATER
8415: PUSH
8416: LD_EXP 37
8420: PUSH
8421: LD_INT 0
8423: GREATER
8424: AND
8425: IFFALSE 8525
// if BuildingStatus ( b_fac ) = bs_idle then
8427: LD_VAR 0 10
8431: PPUSH
8432: CALL_OW 461
8436: PUSH
8437: LD_INT 2
8439: EQUAL
8440: IFFALSE 8525
// begin ComConstruct ( b_fac , ru2_veh [ 1 ] , ru2_veh [ 2 ] , ru2_veh [ 3 ] , ru2_veh [ 4 ] ) ;
8442: LD_VAR 0 10
8446: PPUSH
8447: LD_EXP 37
8451: PUSH
8452: LD_INT 1
8454: ARRAY
8455: PPUSH
8456: LD_EXP 37
8460: PUSH
8461: LD_INT 2
8463: ARRAY
8464: PPUSH
8465: LD_EXP 37
8469: PUSH
8470: LD_INT 3
8472: ARRAY
8473: PPUSH
8474: LD_EXP 37
8478: PUSH
8479: LD_INT 4
8481: ARRAY
8482: PPUSH
8483: CALL_OW 125
// for i = 1 to 4 do
8487: LD_ADDR_VAR 0 1
8491: PUSH
8492: DOUBLE
8493: LD_INT 1
8495: DEC
8496: ST_TO_ADDR
8497: LD_INT 4
8499: PUSH
8500: FOR_TO
8501: IFFALSE 8523
// ru2_veh := Delete ( ru2_veh , 1 ) ;
8503: LD_ADDR_EXP 37
8507: PUSH
8508: LD_EXP 37
8512: PPUSH
8513: LD_INT 1
8515: PPUSH
8516: CALL_OW 3
8520: ST_TO_ADDR
8521: GO 8500
8523: POP
8524: POP
// end ; if ru2_bul > 0 and enemy_detected = false then
8525: LD_EXP 41
8529: PUSH
8530: LD_INT 0
8532: GREATER
8533: PUSH
8534: LD_VAR 0 13
8538: PUSH
8539: LD_INT 0
8541: EQUAL
8542: AND
8543: IFFALSE 8646
// if ru2_eng > 0 then
8545: LD_EXP 38
8549: PUSH
8550: LD_INT 0
8552: GREATER
8553: IFFALSE 8646
// for i = 1 to ru2_eng do
8555: LD_ADDR_VAR 0 1
8559: PUSH
8560: DOUBLE
8561: LD_INT 1
8563: DEC
8564: ST_TO_ADDR
8565: LD_EXP 38
8569: PUSH
8570: FOR_TO
8571: IFFALSE 8644
// if not HasTask ( ru2_eng [ i ] ) then
8573: LD_EXP 38
8577: PUSH
8578: LD_VAR 0 1
8582: ARRAY
8583: PPUSH
8584: CALL_OW 314
8588: NOT
8589: IFFALSE 8642
// begin ComBuild ( ru2_eng [ i ] , ru2_bul [ 1 ] , ru2_bul [ 2 ] , ru2_bul [ 3 ] , ru2_bul [ 4 ] ) ;
8591: LD_EXP 38
8595: PUSH
8596: LD_VAR 0 1
8600: ARRAY
8601: PPUSH
8602: LD_EXP 41
8606: PUSH
8607: LD_INT 1
8609: ARRAY
8610: PPUSH
8611: LD_EXP 41
8615: PUSH
8616: LD_INT 2
8618: ARRAY
8619: PPUSH
8620: LD_EXP 41
8624: PUSH
8625: LD_INT 3
8627: ARRAY
8628: PPUSH
8629: LD_EXP 41
8633: PUSH
8634: LD_INT 4
8636: ARRAY
8637: PPUSH
8638: CALL_OW 145
// end ;
8642: GO 8570
8644: POP
8645: POP
// for i = 1 to ru2_b do
8646: LD_ADDR_VAR 0 1
8650: PUSH
8651: DOUBLE
8652: LD_INT 1
8654: DEC
8655: ST_TO_ADDR
8656: LD_EXP 42
8660: PUSH
8661: FOR_TO
8662: IFFALSE 8850
// if BuildingStatus ( ru2_b [ i ] ) = bs_need_extension then
8664: LD_EXP 42
8668: PUSH
8669: LD_VAR 0 1
8673: ARRAY
8674: PPUSH
8675: CALL_OW 461
8679: PUSH
8680: LD_INT 8
8682: EQUAL
8683: IFFALSE 8848
// begin b_ext := GetExtPositions ( ru2_b [ i ] ) ;
8685: LD_ADDR_VAR 0 12
8689: PUSH
8690: LD_EXP 42
8694: PUSH
8695: LD_VAR 0 1
8699: ARRAY
8700: PPUSH
8701: CALL_OW 270
8705: ST_TO_ADDR
// if b_ext > 0 and not b_ext_gun in ru2_bul then
8706: LD_VAR 0 12
8710: PUSH
8711: LD_INT 0
8713: GREATER
8714: PUSH
8715: LD_INT 17
8717: PUSH
8718: LD_EXP 41
8722: IN
8723: NOT
8724: AND
8725: IFFALSE 8848
// ru2_bul := ru2_bul ^ [ b_ext_noncombat , b_ext [ 1 ] [ 1 ] , b_ext [ 1 ] [ 2 ] , 3 , b_ext_track , b_ext [ 2 ] [ 1 ] , b_ext [ 2 ] [ 2 ] , 5 , b_ext_gun , b_ext [ 3 ] [ 1 ] , b_ext [ 3 ] [ 2 ] , 2 ] ;
8727: LD_ADDR_EXP 41
8731: PUSH
8732: LD_EXP 41
8736: PUSH
8737: LD_INT 19
8739: PUSH
8740: LD_VAR 0 12
8744: PUSH
8745: LD_INT 1
8747: ARRAY
8748: PUSH
8749: LD_INT 1
8751: ARRAY
8752: PUSH
8753: LD_VAR 0 12
8757: PUSH
8758: LD_INT 1
8760: ARRAY
8761: PUSH
8762: LD_INT 2
8764: ARRAY
8765: PUSH
8766: LD_INT 3
8768: PUSH
8769: LD_INT 16
8771: PUSH
8772: LD_VAR 0 12
8776: PUSH
8777: LD_INT 2
8779: ARRAY
8780: PUSH
8781: LD_INT 1
8783: ARRAY
8784: PUSH
8785: LD_VAR 0 12
8789: PUSH
8790: LD_INT 2
8792: ARRAY
8793: PUSH
8794: LD_INT 2
8796: ARRAY
8797: PUSH
8798: LD_INT 5
8800: PUSH
8801: LD_INT 17
8803: PUSH
8804: LD_VAR 0 12
8808: PUSH
8809: LD_INT 3
8811: ARRAY
8812: PUSH
8813: LD_INT 1
8815: ARRAY
8816: PUSH
8817: LD_VAR 0 12
8821: PUSH
8822: LD_INT 3
8824: ARRAY
8825: PUSH
8826: LD_INT 2
8828: ARRAY
8829: PUSH
8830: LD_INT 2
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: ADD
8847: ST_TO_ADDR
// end ;
8848: GO 8661
8850: POP
8851: POP
// if b_dmgunit > 0 then
8852: LD_VAR 0 6
8856: PUSH
8857: LD_INT 0
8859: GREATER
8860: IFFALSE 9045
// begin if ru2_eng > 0 then
8862: LD_EXP 38
8866: PUSH
8867: LD_INT 0
8869: GREATER
8870: IFFALSE 8950
// for i = 1 to ru2_eng do
8872: LD_ADDR_VAR 0 1
8876: PUSH
8877: DOUBLE
8878: LD_INT 1
8880: DEC
8881: ST_TO_ADDR
8882: LD_EXP 38
8886: PUSH
8887: FOR_TO
8888: IFFALSE 8948
// begin if IsInUnit ( ru2_eng [ i ] ) then
8890: LD_EXP 38
8894: PUSH
8895: LD_VAR 0 1
8899: ARRAY
8900: PPUSH
8901: CALL_OW 310
8905: IFFALSE 8922
// ComExitBuilding ( ru2_eng [ i ] ) ;
8907: LD_EXP 38
8911: PUSH
8912: LD_VAR 0 1
8916: ARRAY
8917: PPUSH
8918: CALL_OW 122
// ComRepairBuilding ( ru2_eng [ i ] , b_dmgunit [ 1 ] ) ;
8922: LD_EXP 38
8926: PUSH
8927: LD_VAR 0 1
8931: ARRAY
8932: PPUSH
8933: LD_VAR 0 6
8937: PUSH
8938: LD_INT 1
8940: ARRAY
8941: PPUSH
8942: CALL_OW 130
// end ;
8946: GO 8887
8948: POP
8949: POP
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) > 0 then
8950: LD_INT 22
8952: PUSH
8953: LD_INT 3
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 34
8962: PUSH
8963: LD_INT 52
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: PPUSH
8974: CALL_OW 69
8978: PUSH
8979: LD_INT 0
8981: GREATER
8982: IFFALSE 9043
// for p in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) do
8984: LD_ADDR_VAR 0 2
8988: PUSH
8989: LD_INT 22
8991: PUSH
8992: LD_INT 3
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PUSH
8999: LD_INT 34
9001: PUSH
9002: LD_INT 52
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PPUSH
9013: CALL_OW 69
9017: PUSH
9018: FOR_IN
9019: IFFALSE 9041
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
9021: LD_VAR 0 2
9025: PPUSH
9026: LD_VAR 0 6
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: PPUSH
9035: CALL_OW 130
9039: GO 9018
9041: POP
9042: POP
// end else
9043: GO 9173
// if ru2_bul = 0 then
9045: LD_EXP 41
9049: PUSH
9050: LD_INT 0
9052: EQUAL
9053: IFFALSE 9173
// for i = 1 to ru2_eng do
9055: LD_ADDR_VAR 0 1
9059: PUSH
9060: DOUBLE
9061: LD_INT 1
9063: DEC
9064: ST_TO_ADDR
9065: LD_EXP 38
9069: PUSH
9070: FOR_TO
9071: IFFALSE 9171
// if not HasTask ( ru2_eng [ i ] ) then
9073: LD_EXP 38
9077: PUSH
9078: LD_VAR 0 1
9082: ARRAY
9083: PPUSH
9084: CALL_OW 314
9088: NOT
9089: IFFALSE 9169
// ComEnterUnit ( ru2_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru2_eng [ i ] ) ) ;
9091: LD_EXP 38
9095: PUSH
9096: LD_VAR 0 1
9100: ARRAY
9101: PPUSH
9102: LD_INT 22
9104: PUSH
9105: LD_INT 3
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: LD_INT 2
9114: PUSH
9115: LD_INT 30
9117: PUSH
9118: LD_INT 0
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: LD_INT 30
9127: PUSH
9128: LD_INT 1
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PPUSH
9144: CALL_OW 69
9148: PPUSH
9149: LD_EXP 38
9153: PUSH
9154: LD_VAR 0 1
9158: ARRAY
9159: PPUSH
9160: CALL_OW 74
9164: PPUSH
9165: CALL_OW 120
9169: GO 9070
9171: POP
9172: POP
// if b_labb > 0 then
9173: LD_VAR 0 11
9177: PUSH
9178: LD_INT 0
9180: GREATER
9181: IFFALSE 9531
// begin if h_dmgunit > 0 then
9183: LD_VAR 0 5
9187: PUSH
9188: LD_INT 0
9190: GREATER
9191: IFFALSE 9400
// begin for p = 1 to h_dmgunit do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9260
// if GetDistUnits ( h_dmgunit [ p ] , b_labb ) > 6 then
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 2
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 11
9226: PPUSH
9227: CALL_OW 296
9231: PUSH
9232: LD_INT 6
9234: GREATER
9235: IFFALSE 9258
// ComMoveXY ( h_dmgunit [ p ] , 95 , 72 ) ;
9237: LD_VAR 0 5
9241: PUSH
9242: LD_VAR 0 2
9246: ARRAY
9247: PPUSH
9248: LD_INT 95
9250: PPUSH
9251: LD_INT 72
9253: PPUSH
9254: CALL_OW 111
9258: GO 9208
9260: POP
9261: POP
// if ru2_sci > 0 then
9262: LD_EXP 40
9266: PUSH
9267: LD_INT 0
9269: GREATER
9270: IFFALSE 9400
// for i = 1 to ru2_sci do
9272: LD_ADDR_VAR 0 1
9276: PUSH
9277: DOUBLE
9278: LD_INT 1
9280: DEC
9281: ST_TO_ADDR
9282: LD_EXP 40
9286: PUSH
9287: FOR_TO
9288: IFFALSE 9398
// if IsInUnit ( ru2_sci [ i ] ) then
9290: LD_EXP 40
9294: PUSH
9295: LD_VAR 0 1
9299: ARRAY
9300: PPUSH
9301: CALL_OW 310
9305: IFFALSE 9324
// ComExitBuilding ( ru2_sci [ i ] ) else
9307: LD_EXP 40
9311: PUSH
9312: LD_VAR 0 1
9316: ARRAY
9317: PPUSH
9318: CALL_OW 122
9322: GO 9396
// if not HasTask ( ru2_sci [ i ] ) then
9324: LD_EXP 40
9328: PUSH
9329: LD_VAR 0 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 314
9339: NOT
9340: IFFALSE 9396
// if GetDistUnits ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
9342: LD_EXP 40
9346: PUSH
9347: LD_VAR 0 1
9351: ARRAY
9352: PPUSH
9353: LD_VAR 0 5
9357: PUSH
9358: LD_INT 1
9360: ARRAY
9361: PPUSH
9362: CALL_OW 296
9366: PUSH
9367: LD_INT 15
9369: LESSEQUAL
9370: IFFALSE 9396
// ComHeal ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) ;
9372: LD_EXP 40
9376: PUSH
9377: LD_VAR 0 1
9381: ARRAY
9382: PPUSH
9383: LD_VAR 0 5
9387: PUSH
9388: LD_INT 1
9390: ARRAY
9391: PPUSH
9392: CALL_OW 128
9396: GO 9287
9398: POP
9399: POP
// end ; if h_dmgunit = 0 then
9400: LD_VAR 0 5
9404: PUSH
9405: LD_INT 0
9407: EQUAL
9408: IFFALSE 9531
// begin for i = 1 to ru2_sci do
9410: LD_ADDR_VAR 0 1
9414: PUSH
9415: DOUBLE
9416: LD_INT 1
9418: DEC
9419: ST_TO_ADDR
9420: LD_EXP 40
9424: PUSH
9425: FOR_TO
9426: IFFALSE 9468
// if not IsInUnit ( ru2_sci [ i ] ) then
9428: LD_EXP 40
9432: PUSH
9433: LD_VAR 0 1
9437: ARRAY
9438: PPUSH
9439: CALL_OW 310
9443: NOT
9444: IFFALSE 9466
// ComEnterUnit ( ru2_sci [ i ] , b_labb ) ;
9446: LD_EXP 40
9450: PUSH
9451: LD_VAR 0 1
9455: ARRAY
9456: PPUSH
9457: LD_VAR 0 11
9461: PPUSH
9462: CALL_OW 120
9466: GO 9425
9468: POP
9469: POP
// if ru2_tech > 0 then
9470: LD_EXP 36
9474: PUSH
9475: LD_INT 0
9477: GREATER
9478: IFFALSE 9531
// if BuildingStatus ( b_labb ) = bs_idle then
9480: LD_VAR 0 11
9484: PPUSH
9485: CALL_OW 461
9489: PUSH
9490: LD_INT 2
9492: EQUAL
9493: IFFALSE 9531
// begin ComResearch ( b_labb , ru2_tech [ 1 ] ) ;
9495: LD_VAR 0 11
9499: PPUSH
9500: LD_EXP 36
9504: PUSH
9505: LD_INT 1
9507: ARRAY
9508: PPUSH
9509: CALL_OW 124
// ru2_tech := Delete ( ru2_tech , 1 ) ;
9513: LD_ADDR_EXP 36
9517: PUSH
9518: LD_EXP 36
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: CALL_OW 3
9530: ST_TO_ADDR
// end ; end ; end ; end ;
9531: PPOPN 13
9533: END
// every 0 0$01 trigger russian_produce do
9534: LD_EXP 20
9538: IFFALSE 9987
9540: GO 9542
9542: DISABLE
// begin case global_diff of 1 :
9543: LD_EXP 3
9547: PUSH
9548: LD_INT 1
9550: DOUBLE
9551: EQUAL
9552: IFTRUE 9556
9554: GO 9620
9556: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9557: LD_ADDR_EXP 27
9561: PUSH
9562: LD_EXP 27
9566: PUSH
9567: LD_INT 21
9569: PUSH
9570: LD_INT 1
9572: PUSH
9573: LD_INT 1
9575: PUSH
9576: LD_INT 42
9578: PUSH
9579: LD_INT 21
9581: PUSH
9582: LD_INT 1
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: LD_INT 42
9590: PUSH
9591: LD_INT 21
9593: PUSH
9594: LD_INT 1
9596: PUSH
9597: LD_INT 1
9599: PUSH
9600: LD_INT 43
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: ADD
9617: ST_TO_ADDR
9618: GO 9765
9620: LD_INT 2
9622: DOUBLE
9623: EQUAL
9624: IFTRUE 9628
9626: GO 9692
9628: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9629: LD_ADDR_EXP 27
9633: PUSH
9634: LD_EXP 27
9638: PUSH
9639: LD_INT 21
9641: PUSH
9642: LD_INT 1
9644: PUSH
9645: LD_INT 1
9647: PUSH
9648: LD_INT 44
9650: PUSH
9651: LD_INT 22
9653: PUSH
9654: LD_INT 1
9656: PUSH
9657: LD_INT 1
9659: PUSH
9660: LD_INT 42
9662: PUSH
9663: LD_INT 22
9665: PUSH
9666: LD_INT 1
9668: PUSH
9669: LD_INT 1
9671: PUSH
9672: LD_INT 43
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: ADD
9689: ST_TO_ADDR
9690: GO 9765
9692: LD_INT 3
9694: DOUBLE
9695: EQUAL
9696: IFTRUE 9700
9698: GO 9764
9700: POP
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_rocket_launcher ] ; end ;
9701: LD_ADDR_EXP 27
9705: PUSH
9706: LD_EXP 27
9710: PUSH
9711: LD_INT 23
9713: PUSH
9714: LD_INT 1
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: LD_INT 43
9722: PUSH
9723: LD_INT 22
9725: PUSH
9726: LD_INT 1
9728: PUSH
9729: LD_INT 1
9731: PUSH
9732: LD_INT 44
9734: PUSH
9735: LD_INT 22
9737: PUSH
9738: LD_INT 1
9740: PUSH
9741: LD_INT 1
9743: PUSH
9744: LD_INT 45
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: ADD
9761: ST_TO_ADDR
9762: GO 9765
9764: POP
// case global_diff of 1 :
9765: LD_EXP 3
9769: PUSH
9770: LD_INT 1
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9842
9778: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9779: LD_ADDR_EXP 37
9783: PUSH
9784: LD_EXP 37
9788: PUSH
9789: LD_INT 21
9791: PUSH
9792: LD_INT 1
9794: PUSH
9795: LD_INT 1
9797: PUSH
9798: LD_INT 42
9800: PUSH
9801: LD_INT 21
9803: PUSH
9804: LD_INT 1
9806: PUSH
9807: LD_INT 1
9809: PUSH
9810: LD_INT 42
9812: PUSH
9813: LD_INT 21
9815: PUSH
9816: LD_INT 1
9818: PUSH
9819: LD_INT 1
9821: PUSH
9822: LD_INT 43
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: ADD
9839: ST_TO_ADDR
9840: GO 9987
9842: LD_INT 2
9844: DOUBLE
9845: EQUAL
9846: IFTRUE 9850
9848: GO 9914
9850: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9851: LD_ADDR_EXP 37
9855: PUSH
9856: LD_EXP 37
9860: PUSH
9861: LD_INT 21
9863: PUSH
9864: LD_INT 1
9866: PUSH
9867: LD_INT 1
9869: PUSH
9870: LD_INT 44
9872: PUSH
9873: LD_INT 22
9875: PUSH
9876: LD_INT 1
9878: PUSH
9879: LD_INT 1
9881: PUSH
9882: LD_INT 44
9884: PUSH
9885: LD_INT 22
9887: PUSH
9888: LD_INT 1
9890: PUSH
9891: LD_INT 1
9893: PUSH
9894: LD_INT 43
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: ADD
9911: ST_TO_ADDR
9912: GO 9987
9914: LD_INT 3
9916: DOUBLE
9917: EQUAL
9918: IFTRUE 9922
9920: GO 9986
9922: POP
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
9923: LD_ADDR_EXP 37
9927: PUSH
9928: LD_EXP 37
9932: PUSH
9933: LD_INT 23
9935: PUSH
9936: LD_INT 1
9938: PUSH
9939: LD_INT 1
9941: PUSH
9942: LD_INT 42
9944: PUSH
9945: LD_INT 22
9947: PUSH
9948: LD_INT 1
9950: PUSH
9951: LD_INT 1
9953: PUSH
9954: LD_INT 44
9956: PUSH
9957: LD_INT 22
9959: PUSH
9960: LD_INT 1
9962: PUSH
9963: LD_INT 1
9965: PUSH
9966: LD_INT 44
9968: PUSH
9969: EMPTY
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: LIST
9978: LIST
9979: LIST
9980: LIST
9981: LIST
9982: ADD
9983: ST_TO_ADDR
9984: GO 9987
9986: POP
// end ;
9987: END
// every 12 12$00 trigger timer >= [ 26 26$00 , 21 21$00 , 16 16$00 ] [ global_diff ] and FilterAllUnits ( [ f_side , 3 ] ) > 0 do var veh , i , p , area ;
9988: LD_EXP 2
9992: PUSH
9993: LD_INT 54600
9995: PUSH
9996: LD_INT 44100
9998: PUSH
9999: LD_INT 33600
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: LIST
10006: PUSH
10007: LD_EXP 3
10011: ARRAY
10012: GREATEREQUAL
10013: PUSH
10014: LD_INT 22
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: EMPTY
10021: LIST
10022: LIST
10023: PPUSH
10024: CALL_OW 69
10028: PUSH
10029: LD_INT 0
10031: GREATER
10032: AND
10033: IFFALSE 10249
10035: GO 10037
10037: DISABLE
10038: LD_INT 0
10040: PPUSH
10041: PPUSH
10042: PPUSH
10043: PPUSH
// begin enable ;
10044: ENABLE
// uc_side := [ 3 , 6 ] [ Rand ( 1 , 2 ) ] ;
10045: LD_ADDR_OWVAR 20
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 6
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 1
10062: PPUSH
10063: LD_INT 2
10065: PPUSH
10066: CALL_OW 12
10070: ARRAY
10071: ST_TO_ADDR
// uc_nation := 3 ;
10072: LD_ADDR_OWVAR 21
10076: PUSH
10077: LD_INT 3
10079: ST_TO_ADDR
// area := [ ru_west , south_spawn ] ;
10080: LD_ADDR_VAR 0 4
10084: PUSH
10085: LD_INT 18
10087: PUSH
10088: LD_INT 7
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
10095: LD_ADDR_VAR 0 3
10099: PUSH
10100: LD_INT 1
10102: PPUSH
10103: LD_INT 2
10105: PPUSH
10106: CALL_OW 12
10110: ST_TO_ADDR
// for i = 1 to Rand ( 1 , 2 ) do
10111: LD_ADDR_VAR 0 2
10115: PUSH
10116: DOUBLE
10117: LD_INT 1
10119: DEC
10120: ST_TO_ADDR
10121: LD_INT 1
10123: PPUSH
10124: LD_INT 2
10126: PPUSH
10127: CALL_OW 12
10131: PUSH
10132: FOR_TO
10133: IFFALSE 10247
// begin vc_chassis := ru_medium_tracked ;
10135: LD_ADDR_OWVAR 37
10139: PUSH
10140: LD_INT 22
10142: ST_TO_ADDR
// vc_engine := engine_combustion ;
10143: LD_ADDR_OWVAR 39
10147: PUSH
10148: LD_INT 1
10150: ST_TO_ADDR
// vc_control := control_manual ;
10151: LD_ADDR_OWVAR 38
10155: PUSH
10156: LD_INT 1
10158: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
10159: LD_ADDR_OWVAR 40
10163: PUSH
10164: LD_INT 43
10166: PUSH
10167: LD_INT 44
10169: PUSH
10170: LD_INT 45
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: LIST
10177: PUSH
10178: LD_INT 1
10180: PPUSH
10181: LD_INT 3
10183: PPUSH
10184: CALL_OW 12
10188: ARRAY
10189: ST_TO_ADDR
// veh := CreateVehicle ;
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: CALL_OW 45
10199: ST_TO_ADDR
// PlaceUnitArea ( veh , area [ p ] , false ) ;
10200: LD_VAR 0 1
10204: PPUSH
10205: LD_VAR 0 4
10209: PUSH
10210: LD_VAR 0 3
10214: ARRAY
10215: PPUSH
10216: LD_INT 0
10218: PPUSH
10219: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_def ) , veh ) ;
10223: LD_INT 3
10225: PPUSH
10226: LD_EXP 5
10230: PPUSH
10231: CALL 418 0 2
10235: PPUSH
10236: LD_VAR 0 1
10240: PPUSH
10241: CALL_OW 52
// end ;
10245: GO 10132
10247: POP
10248: POP
// end ;
10249: PPOPN 4
10251: END
// every 4 4$35 trigger FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) >= 6 do var filter , enemy , i , _list ;
10252: LD_INT 2
10254: PUSH
10255: LD_INT 22
10257: PUSH
10258: LD_INT 3
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 6
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 21
10282: PUSH
10283: LD_INT 2
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: LD_INT 3
10292: PUSH
10293: LD_INT 2
10295: PUSH
10296: LD_INT 34
10298: PUSH
10299: LD_INT 52
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: LD_INT 34
10308: PUSH
10309: LD_INT 51
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: LD_INT 53
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: PPUSH
10341: CALL_OW 69
10345: PUSH
10346: LD_INT 6
10348: GREATEREQUAL
10349: IFFALSE 10589
10351: GO 10353
10353: DISABLE
10354: LD_INT 0
10356: PPUSH
10357: PPUSH
10358: PPUSH
10359: PPUSH
// begin enable ;
10360: ENABLE
// _list := [ [ b_oil_mine , b_solar_power , b_oil_power ] , [ us_cargo_bay ] , [ ] ] ;
10361: LD_ADDR_VAR 0 4
10365: PUSH
10366: LD_INT 29
10368: PUSH
10369: LD_INT 27
10371: PUSH
10372: LD_INT 26
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 12
10382: PUSH
10383: EMPTY
10384: LIST
10385: PUSH
10386: EMPTY
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
// filter := ru_list_attackers ;
10393: LD_ADDR_VAR 0 1
10397: PUSH
10398: LD_EXP 43
10402: ST_TO_ADDR
// while ( filter ) do
10403: LD_VAR 0 1
10407: IFFALSE 10589
// begin Wait ( 0 0$01 ) ;
10409: LD_INT 35
10411: PPUSH
10412: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10416: LD_INT 22
10418: PUSH
10419: LD_INT 2
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PPUSH
10426: CALL_OW 69
10430: PUSH
10431: LD_INT 0
10433: EQUAL
10434: IFFALSE 10476
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10436: LD_ADDR_VAR 0 2
10440: PUSH
10441: LD_INT 2
10443: PUSH
10444: LD_INT 22
10446: PUSH
10447: LD_INT 1
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 4
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: PPUSH
10469: CALL_OW 69
10473: ST_TO_ADDR
10474: GO 10496
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10476: LD_ADDR_VAR 0 2
10480: PUSH
10481: LD_INT 22
10483: PUSH
10484: LD_INT 2
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: PPUSH
10491: CALL_OW 69
10495: ST_TO_ADDR
// for i = filter downto 1 do
10496: LD_ADDR_VAR 0 3
10500: PUSH
10501: DOUBLE
10502: LD_VAR 0 1
10506: INC
10507: ST_TO_ADDR
10508: LD_INT 1
10510: PUSH
10511: FOR_DOWNTO
10512: IFFALSE 10576
// if not IsPlaced ( filter [ i ] ) then
10514: LD_VAR 0 1
10518: PUSH
10519: LD_VAR 0 3
10523: ARRAY
10524: PPUSH
10525: CALL_OW 305
10529: NOT
10530: IFFALSE 10554
// filter := Delete ( filter , i ) else
10532: LD_ADDR_VAR 0 1
10536: PUSH
10537: LD_VAR 0 1
10541: PPUSH
10542: LD_VAR 0 3
10546: PPUSH
10547: CALL_OW 3
10551: ST_TO_ADDR
10552: GO 10574
// ComAttack ( filter [ i ] , _list ) ;
10554: LD_VAR 0 1
10558: PUSH
10559: LD_VAR 0 3
10563: ARRAY
10564: PPUSH
10565: LD_VAR 0 4
10569: PPUSH
10570: CALL 985 0 2
10574: GO 10511
10576: POP
10577: POP
// if not filter then
10578: LD_VAR 0 1
10582: NOT
10583: IFFALSE 10587
// break ;
10585: GO 10589
// end ;
10587: GO 10403
// end ;
10589: PPOPN 4
10591: END
// export ru_spec_group ; every 0 0$10 trigger FilterUnitsInArea ( buffor , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 do var i , un , veh ;
10592: LD_INT 22
10594: PPUSH
10595: LD_INT 22
10597: PUSH
10598: LD_INT 1
10600: PUSH
10601: EMPTY
10602: LIST
10603: LIST
10604: PUSH
10605: LD_INT 21
10607: PUSH
10608: LD_INT 3
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: PUSH
10615: EMPTY
10616: LIST
10617: LIST
10618: PPUSH
10619: CALL_OW 70
10623: PUSH
10624: LD_INT 0
10626: GREATER
10627: IFFALSE 10772
10629: GO 10631
10631: DISABLE
10632: LD_INT 0
10634: PPUSH
10635: PPUSH
10636: PPUSH
// begin uc_side := 6 ;
10637: LD_ADDR_OWVAR 20
10641: PUSH
10642: LD_INT 6
10644: ST_TO_ADDR
// uc_nation := 3 ;
10645: LD_ADDR_OWVAR 21
10649: PUSH
10650: LD_INT 3
10652: ST_TO_ADDR
// for i = 1 to Difficulty + 1 do
10653: LD_ADDR_VAR 0 1
10657: PUSH
10658: DOUBLE
10659: LD_INT 1
10661: DEC
10662: ST_TO_ADDR
10663: LD_OWVAR 67
10667: PUSH
10668: LD_INT 1
10670: PLUS
10671: PUSH
10672: FOR_TO
10673: IFFALSE 10767
// begin vc_chassis := ru_medium_tracked ;
10675: LD_ADDR_OWVAR 37
10679: PUSH
10680: LD_INT 22
10682: ST_TO_ADDR
// vc_engine := engine_combustion ;
10683: LD_ADDR_OWVAR 39
10687: PUSH
10688: LD_INT 1
10690: ST_TO_ADDR
// vc_control := control_manual ;
10691: LD_ADDR_OWVAR 38
10695: PUSH
10696: LD_INT 1
10698: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10699: LD_ADDR_OWVAR 40
10703: PUSH
10704: LD_INT 45
10706: ST_TO_ADDR
// veh := CreateVehicle ;
10707: LD_ADDR_VAR 0 3
10711: PUSH
10712: CALL_OW 45
10716: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
10717: LD_ADDR_VAR 0 2
10721: PUSH
10722: LD_INT 3
10724: PPUSH
10725: LD_EXP 5
10729: PPUSH
10730: CALL 418 0 2
10734: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10735: LD_VAR 0 2
10739: PPUSH
10740: LD_VAR 0 3
10744: PPUSH
10745: CALL_OW 52
// ru_spec_group := ru_spec_group ^ veh ;
10749: LD_ADDR_EXP 45
10753: PUSH
10754: LD_EXP 45
10758: PUSH
10759: LD_VAR 0 3
10763: ADD
10764: ST_TO_ADDR
// end ;
10765: GO 10672
10767: POP
10768: POP
// enable ( 99 ) ;
10769: LD_INT 99
10771: ENABLE_MARKED
// end ;
10772: PPOPN 3
10774: END
// every 0 0$01 trigger ru_spec_group marked 99 do var i , enemy , filter ;
10775: LD_EXP 45
10779: IFFALSE 10948
10781: GO 10783
10783: DISABLE
10784: LD_INT 0
10786: PPUSH
10787: PPUSH
10788: PPUSH
// begin enable ;
10789: ENABLE
// filter := ru_spec_group ;
10790: LD_ADDR_VAR 0 3
10794: PUSH
10795: LD_EXP 45
10799: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10800: LD_INT 22
10802: PUSH
10803: LD_INT 2
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PPUSH
10810: CALL_OW 69
10814: PUSH
10815: LD_INT 0
10817: EQUAL
10818: IFFALSE 10860
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10820: LD_ADDR_VAR 0 2
10824: PUSH
10825: LD_INT 2
10827: PUSH
10828: LD_INT 22
10830: PUSH
10831: LD_INT 1
10833: PUSH
10834: EMPTY
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 22
10840: PUSH
10841: LD_INT 4
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: LIST
10852: PPUSH
10853: CALL_OW 69
10857: ST_TO_ADDR
10858: GO 10880
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10860: LD_ADDR_VAR 0 2
10864: PUSH
10865: LD_INT 22
10867: PUSH
10868: LD_INT 2
10870: PUSH
10871: EMPTY
10872: LIST
10873: LIST
10874: PPUSH
10875: CALL_OW 69
10879: ST_TO_ADDR
// if filter > 0 then
10880: LD_VAR 0 3
10884: PUSH
10885: LD_INT 0
10887: GREATER
10888: IFFALSE 10948
// for i = 1 to filter do
10890: LD_ADDR_VAR 0 1
10894: PUSH
10895: DOUBLE
10896: LD_INT 1
10898: DEC
10899: ST_TO_ADDR
10900: LD_VAR 0 3
10904: PUSH
10905: FOR_TO
10906: IFFALSE 10946
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
10908: LD_VAR 0 3
10912: PUSH
10913: LD_VAR 0 1
10917: ARRAY
10918: PPUSH
10919: LD_VAR 0 2
10923: PPUSH
10924: LD_VAR 0 3
10928: PUSH
10929: LD_VAR 0 1
10933: ARRAY
10934: PPUSH
10935: CALL_OW 74
10939: PPUSH
10940: CALL_OW 115
10944: GO 10905
10946: POP
10947: POP
// end ; end_of_file
10948: PPOPN 3
10950: END
// export function ArabianAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
10951: LD_INT 0
10953: PPUSH
10954: PPUSH
10955: PPUSH
10956: PPUSH
10957: PPUSH
10958: PPUSH
10959: PPUSH
// uc_side := side ;
10960: LD_ADDR_OWVAR 20
10964: PUSH
10965: LD_VAR 0 1
10969: ST_TO_ADDR
// uc_nation := nation_arabian ;
10970: LD_ADDR_OWVAR 21
10974: PUSH
10975: LD_INT 2
10977: ST_TO_ADDR
// chassis := [ ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
10978: LD_ADDR_VAR 0 10
10982: PUSH
10983: LD_INT 12
10985: PUSH
10986: LD_INT 13
10988: PUSH
10989: LD_INT 14
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: LIST
10996: ST_TO_ADDR
// weapon := [ ar_multimissile_ballista , ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher ] ;
10997: LD_ADDR_VAR 0 11
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 24
11007: PUSH
11008: LD_INT 25
11010: PUSH
11011: LD_INT 27
11013: PUSH
11014: LD_INT 28
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: ST_TO_ADDR
// case typ of 1 :
11024: LD_VAR 0 3
11028: PUSH
11029: LD_INT 1
11031: DOUBLE
11032: EQUAL
11033: IFTRUE 11037
11035: GO 11262
11037: POP
// begin for i = 1 to num do
11038: LD_ADDR_VAR 0 6
11042: PUSH
11043: DOUBLE
11044: LD_INT 1
11046: DEC
11047: ST_TO_ADDR
11048: LD_VAR 0 2
11052: PUSH
11053: FOR_TO
11054: IFFALSE 11213
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
11056: LD_ADDR_OWVAR 37
11060: PUSH
11061: LD_VAR 0 10
11065: PUSH
11066: LD_INT 1
11068: PPUSH
11069: LD_INT 2
11071: PPUSH
11072: CALL_OW 12
11076: ARRAY
11077: ST_TO_ADDR
// vc_engine := engine_combustion ;
11078: LD_ADDR_OWVAR 39
11082: PUSH
11083: LD_INT 1
11085: ST_TO_ADDR
// vc_control := control_manual ;
11086: LD_ADDR_OWVAR 38
11090: PUSH
11091: LD_INT 1
11093: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 2 ) ] ;
11094: LD_ADDR_OWVAR 40
11098: PUSH
11099: LD_VAR 0 11
11103: PUSH
11104: LD_INT 1
11106: PPUSH
11107: LD_INT 2
11109: PPUSH
11110: CALL_OW 12
11114: ARRAY
11115: ST_TO_ADDR
// veh := CreateVehicle ;
11116: LD_ADDR_VAR 0 9
11120: PUSH
11121: CALL_OW 45
11125: ST_TO_ADDR
// if area = ar_area1 then
11126: LD_VAR 0 4
11130: PUSH
11131: LD_INT 6
11133: EQUAL
11134: IFFALSE 11150
// SetDir ( veh , 3 ) else
11136: LD_VAR 0 9
11140: PPUSH
11141: LD_INT 3
11143: PPUSH
11144: CALL_OW 233
11148: GO 11162
// SetDir ( veh , 0 ) ;
11150: LD_VAR 0 9
11154: PPUSH
11155: LD_INT 0
11157: PPUSH
11158: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11162: LD_VAR 0 9
11166: PPUSH
11167: LD_VAR 0 4
11171: PPUSH
11172: LD_INT 0
11174: PPUSH
11175: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11179: LD_ADDR_VAR 0 7
11183: PUSH
11184: LD_INT 1
11186: PPUSH
11187: LD_EXP 8
11191: PPUSH
11192: CALL 418 0 2
11196: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11197: LD_VAR 0 7
11201: PPUSH
11202: LD_VAR 0 9
11206: PPUSH
11207: CALL_OW 52
// end ;
11211: GO 11053
11213: POP
11214: POP
// for i = 1 to 3 do
11215: LD_ADDR_VAR 0 6
11219: PUSH
11220: DOUBLE
11221: LD_INT 1
11223: DEC
11224: ST_TO_ADDR
11225: LD_INT 3
11227: PUSH
11228: FOR_TO
11229: IFFALSE 11258
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , ar_def ) , area , false ) ;
11231: LD_INT 8
11233: PPUSH
11234: LD_EXP 8
11238: PPUSH
11239: CALL 418 0 2
11243: PPUSH
11244: LD_VAR 0 4
11248: PPUSH
11249: LD_INT 0
11251: PPUSH
11252: CALL_OW 49
11256: GO 11228
11258: POP
11259: POP
// end ; 2 :
11260: GO 11529
11262: LD_INT 2
11264: DOUBLE
11265: EQUAL
11266: IFTRUE 11270
11268: GO 11528
11270: POP
// begin for i = 1 to num do
11271: LD_ADDR_VAR 0 6
11275: PUSH
11276: DOUBLE
11277: LD_INT 1
11279: DEC
11280: ST_TO_ADDR
11281: LD_VAR 0 2
11285: PUSH
11286: FOR_TO
11287: IFFALSE 11446
// begin vc_chassis := chassis [ Rand ( 2 , 3 ) ] ;
11289: LD_ADDR_OWVAR 37
11293: PUSH
11294: LD_VAR 0 10
11298: PUSH
11299: LD_INT 2
11301: PPUSH
11302: LD_INT 3
11304: PPUSH
11305: CALL_OW 12
11309: ARRAY
11310: ST_TO_ADDR
// vc_engine := engine_combustion ;
11311: LD_ADDR_OWVAR 39
11315: PUSH
11316: LD_INT 1
11318: ST_TO_ADDR
// vc_control := control_manual ;
11319: LD_ADDR_OWVAR 38
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
11327: LD_ADDR_OWVAR 40
11331: PUSH
11332: LD_VAR 0 11
11336: PUSH
11337: LD_INT 3
11339: PPUSH
11340: LD_INT 5
11342: PPUSH
11343: CALL_OW 12
11347: ARRAY
11348: ST_TO_ADDR
// veh := CreateVehicle ;
11349: LD_ADDR_VAR 0 9
11353: PUSH
11354: CALL_OW 45
11358: ST_TO_ADDR
// if area = ar_area1 then
11359: LD_VAR 0 4
11363: PUSH
11364: LD_INT 6
11366: EQUAL
11367: IFFALSE 11383
// SetDir ( veh , 3 ) else
11369: LD_VAR 0 9
11373: PPUSH
11374: LD_INT 3
11376: PPUSH
11377: CALL_OW 233
11381: GO 11395
// SetDir ( veh , 0 ) ;
11383: LD_VAR 0 9
11387: PPUSH
11388: LD_INT 0
11390: PPUSH
11391: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11395: LD_VAR 0 9
11399: PPUSH
11400: LD_VAR 0 4
11404: PPUSH
11405: LD_INT 0
11407: PPUSH
11408: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11412: LD_ADDR_VAR 0 7
11416: PUSH
11417: LD_INT 1
11419: PPUSH
11420: LD_EXP 8
11424: PPUSH
11425: CALL 418 0 2
11429: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11430: LD_VAR 0 7
11434: PPUSH
11435: LD_VAR 0 9
11439: PPUSH
11440: CALL_OW 52
// end ;
11444: GO 11286
11446: POP
11447: POP
// for i = 1 to 2 do
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: DOUBLE
11454: LD_INT 1
11456: DEC
11457: ST_TO_ADDR
11458: LD_INT 2
11460: PUSH
11461: FOR_TO
11462: IFFALSE 11524
// begin uc_nation := 0 ;
11464: LD_ADDR_OWVAR 21
11468: PUSH
11469: LD_INT 0
11471: ST_TO_ADDR
// hc_class := 17 ;
11472: LD_ADDR_OWVAR 28
11476: PUSH
11477: LD_INT 17
11479: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
11480: LD_ADDR_OWVAR 29
11484: PUSH
11485: LD_INT 11
11487: PUSH
11488: LD_INT 13
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: ST_TO_ADDR
// un := CreateHuman ;
11495: LD_ADDR_VAR 0 7
11499: PUSH
11500: CALL_OW 44
11504: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
11505: LD_VAR 0 7
11509: PPUSH
11510: LD_VAR 0 4
11514: PPUSH
11515: LD_INT 0
11517: PPUSH
11518: CALL_OW 49
// end ;
11522: GO 11461
11524: POP
11525: POP
// end ; end ;
11526: GO 11529
11528: POP
// end ;
11529: LD_VAR 0 5
11533: RET
// export function FHeike ; begin
11534: LD_INT 0
11536: PPUSH
// uc_side := 2 ;
11537: LD_ADDR_OWVAR 20
11541: PUSH
11542: LD_INT 2
11544: ST_TO_ADDR
// uc_nation := 2 ;
11545: LD_ADDR_OWVAR 21
11549: PUSH
11550: LD_INT 2
11552: ST_TO_ADDR
// hc_gallery := sandar ;
11553: LD_ADDR_OWVAR 33
11557: PUSH
11558: LD_STRING sandar
11560: ST_TO_ADDR
// hc_face_number := 2 ;
11561: LD_ADDR_OWVAR 34
11565: PUSH
11566: LD_INT 2
11568: ST_TO_ADDR
// hc_name := Heike Steyer ;
11569: LD_ADDR_OWVAR 26
11573: PUSH
11574: LD_STRING Heike Steyer
11576: ST_TO_ADDR
// hc_sex := sex_female ;
11577: LD_ADDR_OWVAR 27
11581: PUSH
11582: LD_INT 2
11584: ST_TO_ADDR
// hc_class := 1 ;
11585: LD_ADDR_OWVAR 28
11589: PUSH
11590: LD_INT 1
11592: ST_TO_ADDR
// heike := CreateHuman ;
11593: LD_ADDR_EXP 16
11597: PUSH
11598: CALL_OW 44
11602: ST_TO_ADDR
// end ;
11603: LD_VAR 0 1
11607: RET
// every 0 0$01 do var filter , enemy , i ;
11608: GO 11610
11610: DISABLE
11611: LD_INT 0
11613: PPUSH
11614: PPUSH
11615: PPUSH
// begin enable ;
11616: ENABLE
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
11617: LD_ADDR_VAR 0 1
11621: PUSH
11622: LD_INT 22
11624: PUSH
11625: LD_INT 2
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PPUSH
11632: CALL_OW 69
11636: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_INT 2
11644: PUSH
11645: LD_INT 22
11647: PUSH
11648: LD_INT 1
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 22
11657: PUSH
11658: LD_INT 3
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: LD_INT 22
11667: PUSH
11668: LD_INT 6
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: PPUSH
11681: CALL_OW 69
11685: ST_TO_ADDR
// if filter > 0 then
11686: LD_VAR 0 1
11690: PUSH
11691: LD_INT 0
11693: GREATER
11694: IFFALSE 11754
// for i = 1 to filter do
11696: LD_ADDR_VAR 0 3
11700: PUSH
11701: DOUBLE
11702: LD_INT 1
11704: DEC
11705: ST_TO_ADDR
11706: LD_VAR 0 1
11710: PUSH
11711: FOR_TO
11712: IFFALSE 11752
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
11714: LD_VAR 0 1
11718: PUSH
11719: LD_VAR 0 3
11723: ARRAY
11724: PPUSH
11725: LD_VAR 0 2
11729: PPUSH
11730: LD_VAR 0 1
11734: PUSH
11735: LD_VAR 0 3
11739: ARRAY
11740: PPUSH
11741: CALL_OW 74
11745: PPUSH
11746: CALL_OW 115
11750: GO 11711
11752: POP
11753: POP
// end ; end_of_file
11754: PPOPN 3
11756: END
// on UnitDestroyed ( un ) do begin if un = sikorski then
11757: LD_VAR 0 1
11761: PUSH
11762: LD_EXP 14
11766: EQUAL
11767: IFFALSE 11776
// YouLost ( sik ) ;
11769: LD_STRING sik
11771: PPUSH
11772: CALL_OW 104
// if un = omikron then
11776: LD_VAR 0 1
11780: PUSH
11781: LD_INT 64
11783: EQUAL
11784: IFFALSE 11793
// YouLost ( omi ) ;
11786: LD_STRING omi
11788: PPUSH
11789: CALL_OW 104
// if un in ru_list_attackers then
11793: LD_VAR 0 1
11797: PUSH
11798: LD_EXP 43
11802: IN
11803: IFFALSE 11821
// ru_list_attackers := ru_list_attackers diff un ;
11805: LD_ADDR_EXP 43
11809: PUSH
11810: LD_EXP 43
11814: PUSH
11815: LD_VAR 0 1
11819: DIFF
11820: ST_TO_ADDR
// if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
11821: LD_VAR 0 1
11825: PPUSH
11826: CALL_OW 255
11830: PUSH
11831: LD_INT 6
11833: EQUAL
11834: PUSH
11835: LD_VAR 0 1
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 3
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PPUSH
11850: CALL_OW 69
11854: IN
11855: AND
11856: IFFALSE 12075
// begin if GetBType ( un ) = b_factory then
11858: LD_VAR 0 1
11862: PPUSH
11863: CALL_OW 266
11867: PUSH
11868: LD_INT 3
11870: EQUAL
11871: IFFALSE 11887
// ru_bul := ru_bul ^ b_workshop ;
11873: LD_ADDR_EXP 31
11877: PUSH
11878: LD_EXP 31
11882: PUSH
11883: LD_INT 2
11885: ADD
11886: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
11887: LD_VAR 0 1
11891: PPUSH
11892: CALL_OW 266
11896: PUSH
11897: LD_INT 8
11899: EQUAL
11900: PUSH
11901: LD_VAR 0 1
11905: PPUSH
11906: CALL_OW 266
11910: PUSH
11911: LD_INT 7
11913: EQUAL
11914: OR
11915: IFFALSE 11931
// ru_bul := ru_bul ^ b_lab ;
11917: LD_ADDR_EXP 31
11921: PUSH
11922: LD_EXP 31
11926: PUSH
11927: LD_INT 6
11929: ADD
11930: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11931: LD_VAR 0 1
11935: PPUSH
11936: CALL_OW 266
11940: PUSH
11941: LD_INT 5
11943: EQUAL
11944: IFFALSE 11960
// ru_bul := ru_bul ^ b_armoury ;
11946: LD_ADDR_EXP 31
11950: PUSH
11951: LD_EXP 31
11955: PUSH
11956: LD_INT 4
11958: ADD
11959: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks ] then
11960: LD_VAR 0 1
11964: PPUSH
11965: CALL_OW 266
11969: PUSH
11970: LD_INT 3
11972: PUSH
11973: LD_INT 8
11975: PUSH
11976: LD_INT 7
11978: PUSH
11979: LD_INT 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: IN
11988: NOT
11989: IFFALSE 12012
// ru_bul := ru_bul ^ GetBType ( un ) ;
11991: LD_ADDR_EXP 31
11995: PUSH
11996: LD_EXP 31
12000: PUSH
12001: LD_VAR 0 1
12005: PPUSH
12006: CALL_OW 266
12010: ADD
12011: ST_TO_ADDR
// ru_bul := ru_bul ^ GetX ( un ) ;
12012: LD_ADDR_EXP 31
12016: PUSH
12017: LD_EXP 31
12021: PUSH
12022: LD_VAR 0 1
12026: PPUSH
12027: CALL_OW 250
12031: ADD
12032: ST_TO_ADDR
// ru_bul := ru_bul ^ GetY ( un ) ;
12033: LD_ADDR_EXP 31
12037: PUSH
12038: LD_EXP 31
12042: PUSH
12043: LD_VAR 0 1
12047: PPUSH
12048: CALL_OW 251
12052: ADD
12053: ST_TO_ADDR
// ru_bul := ru_bul ^ GetDir ( un ) ;
12054: LD_ADDR_EXP 31
12058: PUSH
12059: LD_EXP 31
12063: PUSH
12064: LD_VAR 0 1
12068: PPUSH
12069: CALL_OW 254
12073: ADD
12074: ST_TO_ADDR
// end ; if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12075: LD_VAR 0 1
12079: PPUSH
12080: CALL_OW 255
12084: PUSH
12085: LD_INT 6
12087: EQUAL
12088: PUSH
12089: LD_VAR 0 1
12093: PUSH
12094: LD_INT 21
12096: PUSH
12097: LD_INT 2
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PPUSH
12104: CALL_OW 69
12108: PUSH
12109: LD_INT 34
12111: PUSH
12112: LD_INT 45
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: DIFF
12124: IN
12125: AND
12126: IFFALSE 12212
// begin ru_veh := ru_veh ^ GetChassis ( un ) ;
12128: LD_ADDR_EXP 27
12132: PUSH
12133: LD_EXP 27
12137: PUSH
12138: LD_VAR 0 1
12142: PPUSH
12143: CALL_OW 265
12147: ADD
12148: ST_TO_ADDR
// ru_veh := ru_veh ^ GetEngine ( un ) ;
12149: LD_ADDR_EXP 27
12153: PUSH
12154: LD_EXP 27
12158: PUSH
12159: LD_VAR 0 1
12163: PPUSH
12164: CALL_OW 262
12168: ADD
12169: ST_TO_ADDR
// ru_veh := ru_veh ^ GetControl ( un ) ;
12170: LD_ADDR_EXP 27
12174: PUSH
12175: LD_EXP 27
12179: PUSH
12180: LD_VAR 0 1
12184: PPUSH
12185: CALL_OW 263
12189: ADD
12190: ST_TO_ADDR
// ru_veh := ru_veh ^ GetWeapon ( un ) ;
12191: LD_ADDR_EXP 27
12195: PUSH
12196: LD_EXP 27
12200: PUSH
12201: LD_VAR 0 1
12205: PPUSH
12206: CALL_OW 264
12210: ADD
12211: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12212: LD_VAR 0 1
12216: PUSH
12217: LD_INT 22
12219: PUSH
12220: LD_INT 6
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 25
12229: PUSH
12230: LD_INT 3
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PPUSH
12241: CALL_OW 69
12245: IN
12246: PUSH
12247: LD_INT 22
12249: PUSH
12250: LD_INT 6
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: PUSH
12257: LD_INT 30
12259: PUSH
12260: LD_INT 3
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: PUSH
12267: LD_INT 24
12269: PUSH
12270: LD_INT 251
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: EMPTY
12278: LIST
12279: LIST
12280: LIST
12281: PPUSH
12282: CALL_OW 69
12286: PUSH
12287: LD_INT 0
12289: GREATER
12290: AND
12291: IFFALSE 12339
// begin uc_side := 6 ;
12293: LD_ADDR_OWVAR 20
12297: PUSH
12298: LD_INT 6
12300: ST_TO_ADDR
// uc_nation := 3 ;
12301: LD_ADDR_OWVAR 21
12305: PUSH
12306: LD_INT 3
12308: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12309: LD_ADDR_VAR 0 1
12313: PUSH
12314: LD_INT 3
12316: PPUSH
12317: LD_EXP 5
12321: PPUSH
12322: CALL 418 0 2
12326: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
12327: LD_VAR 0 1
12331: PPUSH
12332: LD_INT 92
12334: PPUSH
12335: CALL_OW 52
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
12339: LD_VAR 0 1
12343: PPUSH
12344: CALL_OW 255
12348: PUSH
12349: LD_INT 3
12351: EQUAL
12352: PUSH
12353: LD_VAR 0 1
12357: PUSH
12358: LD_INT 21
12360: PUSH
12361: LD_INT 3
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PPUSH
12368: CALL_OW 69
12372: IN
12373: AND
12374: IFFALSE 12605
// begin if GetBType ( un ) = b_factory then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 266
12385: PUSH
12386: LD_INT 3
12388: EQUAL
12389: IFFALSE 12405
// ru2_bul := ru2_bul ^ b_workshop ;
12391: LD_ADDR_EXP 41
12395: PUSH
12396: LD_EXP 41
12400: PUSH
12401: LD_INT 2
12403: ADD
12404: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
12405: LD_VAR 0 1
12409: PPUSH
12410: CALL_OW 266
12414: PUSH
12415: LD_INT 8
12417: EQUAL
12418: PUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 266
12428: PUSH
12429: LD_INT 7
12431: EQUAL
12432: OR
12433: IFFALSE 12449
// ru2_bul := ru2_bul ^ b_lab ;
12435: LD_ADDR_EXP 41
12439: PUSH
12440: LD_EXP 41
12444: PUSH
12445: LD_INT 6
12447: ADD
12448: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12449: LD_VAR 0 1
12453: PPUSH
12454: CALL_OW 266
12458: PUSH
12459: LD_INT 5
12461: EQUAL
12462: IFFALSE 12478
// ru2_bul := ru2_bul ^ b_armoury ;
12464: LD_ADDR_EXP 41
12468: PUSH
12469: LD_EXP 41
12473: PUSH
12474: LD_INT 4
12476: ADD
12477: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks , b_ext_gun , b_ext_noncombat , b_ext_track ] then
12478: LD_VAR 0 1
12482: PPUSH
12483: CALL_OW 266
12487: PUSH
12488: LD_INT 3
12490: PUSH
12491: LD_INT 8
12493: PUSH
12494: LD_INT 7
12496: PUSH
12497: LD_INT 5
12499: PUSH
12500: LD_INT 17
12502: PUSH
12503: LD_INT 19
12505: PUSH
12506: LD_INT 16
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: IN
12518: NOT
12519: IFFALSE 12542
// ru2_bul := ru2_bul ^ GetBType ( un ) ;
12521: LD_ADDR_EXP 41
12525: PUSH
12526: LD_EXP 41
12530: PUSH
12531: LD_VAR 0 1
12535: PPUSH
12536: CALL_OW 266
12540: ADD
12541: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetX ( un ) ;
12542: LD_ADDR_EXP 41
12546: PUSH
12547: LD_EXP 41
12551: PUSH
12552: LD_VAR 0 1
12556: PPUSH
12557: CALL_OW 250
12561: ADD
12562: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetY ( un ) ;
12563: LD_ADDR_EXP 41
12567: PUSH
12568: LD_EXP 41
12572: PUSH
12573: LD_VAR 0 1
12577: PPUSH
12578: CALL_OW 251
12582: ADD
12583: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetDir ( un ) ;
12584: LD_ADDR_EXP 41
12588: PUSH
12589: LD_EXP 41
12593: PUSH
12594: LD_VAR 0 1
12598: PPUSH
12599: CALL_OW 254
12603: ADD
12604: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12605: LD_VAR 0 1
12609: PPUSH
12610: CALL_OW 255
12614: PUSH
12615: LD_INT 3
12617: EQUAL
12618: PUSH
12619: LD_VAR 0 1
12623: PUSH
12624: LD_INT 21
12626: PUSH
12627: LD_INT 2
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PPUSH
12634: CALL_OW 69
12638: PUSH
12639: LD_INT 34
12641: PUSH
12642: LD_INT 45
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL_OW 69
12653: DIFF
12654: IN
12655: AND
12656: IFFALSE 12742
// begin ru2_veh := ru2_veh ^ GetChassis ( un ) ;
12658: LD_ADDR_EXP 37
12662: PUSH
12663: LD_EXP 37
12667: PUSH
12668: LD_VAR 0 1
12672: PPUSH
12673: CALL_OW 265
12677: ADD
12678: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetEngine ( un ) ;
12679: LD_ADDR_EXP 37
12683: PUSH
12684: LD_EXP 37
12688: PUSH
12689: LD_VAR 0 1
12693: PPUSH
12694: CALL_OW 262
12698: ADD
12699: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetControl ( un ) ;
12700: LD_ADDR_EXP 37
12704: PUSH
12705: LD_EXP 37
12709: PUSH
12710: LD_VAR 0 1
12714: PPUSH
12715: CALL_OW 263
12719: ADD
12720: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetWeapon ( un ) ;
12721: LD_ADDR_EXP 37
12725: PUSH
12726: LD_EXP 37
12730: PUSH
12731: LD_VAR 0 1
12735: PPUSH
12736: CALL_OW 264
12740: ADD
12741: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12742: LD_VAR 0 1
12746: PUSH
12747: LD_INT 22
12749: PUSH
12750: LD_INT 3
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: LD_INT 25
12759: PUSH
12760: LD_INT 3
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PPUSH
12771: CALL_OW 69
12775: IN
12776: PUSH
12777: LD_INT 22
12779: PUSH
12780: LD_INT 3
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: LD_INT 30
12789: PUSH
12790: LD_INT 3
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: PUSH
12797: LD_INT 24
12799: PUSH
12800: LD_INT 251
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: LIST
12811: PPUSH
12812: CALL_OW 69
12816: PUSH
12817: LD_INT 0
12819: GREATER
12820: AND
12821: IFFALSE 12899
// begin uc_side := 3 ;
12823: LD_ADDR_OWVAR 20
12827: PUSH
12828: LD_INT 3
12830: ST_TO_ADDR
// uc_nation := 3 ;
12831: LD_ADDR_OWVAR 21
12835: PUSH
12836: LD_INT 3
12838: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12839: LD_ADDR_VAR 0 1
12843: PUSH
12844: LD_INT 3
12846: PPUSH
12847: LD_EXP 5
12851: PPUSH
12852: CALL 418 0 2
12856: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12857: LD_VAR 0 1
12861: PPUSH
12862: LD_INT 22
12864: PUSH
12865: LD_INT 3
12867: PUSH
12868: EMPTY
12869: LIST
12870: LIST
12871: PUSH
12872: LD_INT 30
12874: PUSH
12875: LD_INT 3
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PPUSH
12886: CALL_OW 69
12890: PUSH
12891: LD_INT 1
12893: ARRAY
12894: PPUSH
12895: CALL_OW 52
// end ; end ;
12899: PPOPN 1
12901: END
// on VehicleConstructed ( veh , fac ) do begin if veh in FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) then
12902: LD_VAR 0 1
12906: PUSH
12907: LD_INT 2
12909: PUSH
12910: LD_INT 22
12912: PUSH
12913: LD_INT 6
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: PUSH
12920: LD_INT 22
12922: PUSH
12923: LD_INT 3
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 21
12937: PUSH
12938: LD_INT 2
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PUSH
12945: LD_INT 3
12947: PUSH
12948: LD_INT 2
12950: PUSH
12951: LD_INT 34
12953: PUSH
12954: LD_INT 52
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 34
12963: PUSH
12964: LD_INT 51
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: LD_INT 53
12976: PUSH
12977: EMPTY
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: LIST
12995: PPUSH
12996: CALL_OW 69
13000: IN
13001: IFFALSE 13026
// ru_list_attackers := Insert ( ru_list_attackers , 1 , veh ) ;
13003: LD_ADDR_EXP 43
13007: PUSH
13008: LD_EXP 43
13012: PPUSH
13013: LD_INT 1
13015: PPUSH
13016: LD_VAR 0 1
13020: PPUSH
13021: CALL_OW 2
13025: ST_TO_ADDR
// end ;
13026: PPOPN 2
13028: END
// on BuildingComplete ( b ) do var i ;
13029: LD_INT 0
13031: PPUSH
// begin if b in FilterAllUnits ( [ f_side , 6 ] ) then
13032: LD_VAR 0 1
13036: PUSH
13037: LD_INT 22
13039: PUSH
13040: LD_INT 6
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: IN
13052: IFFALSE 13092
// for i = 1 to 4 do
13054: LD_ADDR_VAR 0 2
13058: PUSH
13059: DOUBLE
13060: LD_INT 1
13062: DEC
13063: ST_TO_ADDR
13064: LD_INT 4
13066: PUSH
13067: FOR_TO
13068: IFFALSE 13090
// ru_bul := Delete ( ru_bul , 1 ) ;
13070: LD_ADDR_EXP 31
13074: PUSH
13075: LD_EXP 31
13079: PPUSH
13080: LD_INT 1
13082: PPUSH
13083: CALL_OW 3
13087: ST_TO_ADDR
13088: GO 13067
13090: POP
13091: POP
// if b in FilterAllUnits ( [ f_side , 3 ] ) then
13092: LD_VAR 0 1
13096: PUSH
13097: LD_INT 22
13099: PUSH
13100: LD_INT 3
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: PPUSH
13107: CALL_OW 69
13111: IN
13112: IFFALSE 13152
// for i = 1 to 4 do
13114: LD_ADDR_VAR 0 2
13118: PUSH
13119: DOUBLE
13120: LD_INT 1
13122: DEC
13123: ST_TO_ADDR
13124: LD_INT 4
13126: PUSH
13127: FOR_TO
13128: IFFALSE 13150
// ru2_bul := Delete ( ru2_bul , 1 ) ;
13130: LD_ADDR_EXP 41
13134: PUSH
13135: LD_EXP 41
13139: PPUSH
13140: LD_INT 1
13142: PPUSH
13143: CALL_OW 3
13147: ST_TO_ADDR
13148: GO 13127
13150: POP
13151: POP
// end ; end_of_file
13152: PPOPN 2
13154: END
// export function Start_Game ; begin
13155: LD_INT 0
13157: PPUSH
// case Query ( textdiff ) of 1 :
13158: LD_STRING textdiff
13160: PPUSH
13161: CALL_OW 97
13165: PUSH
13166: LD_INT 1
13168: DOUBLE
13169: EQUAL
13170: IFTRUE 13174
13172: GO 13185
13174: POP
// global_diff := 1 ; 2 :
13175: LD_ADDR_EXP 3
13179: PUSH
13180: LD_INT 1
13182: ST_TO_ADDR
13183: GO 13224
13185: LD_INT 2
13187: DOUBLE
13188: EQUAL
13189: IFTRUE 13193
13191: GO 13204
13193: POP
// global_diff := 2 ; 3 :
13194: LD_ADDR_EXP 3
13198: PUSH
13199: LD_INT 2
13201: ST_TO_ADDR
13202: GO 13224
13204: LD_INT 3
13206: DOUBLE
13207: EQUAL
13208: IFTRUE 13212
13210: GO 13223
13212: POP
// global_diff := 3 ; end ;
13213: LD_ADDR_EXP 3
13217: PUSH
13218: LD_INT 3
13220: ST_TO_ADDR
13221: GO 13224
13223: POP
// CenterOnXY ( 70 , 130 ) ;
13224: LD_INT 70
13226: PPUSH
13227: LD_INT 130
13229: PPUSH
13230: CALL_OW 84
// case Query ( text1 ) of 1 :
13234: LD_STRING text1
13236: PPUSH
13237: CALL_OW 97
13241: PUSH
13242: LD_INT 1
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13253
13250: POP
// ; end ;
13251: GO 13254
13253: POP
// ChangeMissionObjectives ( target1 ) ;
13254: LD_STRING target1
13256: PPUSH
13257: CALL_OW 337
// game_started := true ;
13261: LD_ADDR_EXP 10
13265: PUSH
13266: LD_INT 1
13268: ST_TO_ADDR
// crates_allow := true ;
13269: LD_ADDR_EXP 13
13273: PUSH
13274: LD_INT 1
13276: ST_TO_ADDR
// if global_diff > 2 then
13277: LD_EXP 3
13281: PUSH
13282: LD_INT 2
13284: GREATER
13285: IFFALSE 13294
// RemoveUnit ( us_spec_b ) ;
13287: LD_INT 140
13289: PPUSH
13290: CALL_OW 64
// end ;
13294: LD_VAR 0 1
13298: RET
// every 0 0$0.3 trigger SeeSide ( sikorski_veh , 6 ) or SeeSide ( sikorski_veh , 3 ) or SeeSide ( sikorski , 3 ) or SeeSide ( sikorski , 6 ) do
13299: LD_EXP 22
13303: PPUSH
13304: LD_INT 6
13306: PPUSH
13307: CALL 863 0 2
13311: PUSH
13312: LD_EXP 22
13316: PPUSH
13317: LD_INT 3
13319: PPUSH
13320: CALL 863 0 2
13324: OR
13325: PUSH
13326: LD_EXP 14
13330: PPUSH
13331: LD_INT 3
13333: PPUSH
13334: CALL 863 0 2
13338: OR
13339: PUSH
13340: LD_EXP 14
13344: PPUSH
13345: LD_INT 6
13347: PPUSH
13348: CALL 863 0 2
13352: OR
13353: IFFALSE 13370
13355: GO 13357
13357: DISABLE
// Say ( sikorski , DRus ) ;
13358: LD_EXP 14
13362: PPUSH
13363: LD_STRING DRus
13365: PPUSH
13366: CALL_OW 88
13370: END
// every 0 0$01 trigger See ( 4 , sikorski ) or See ( 4 , sikorski_veh ) do var i , per ;
13371: LD_INT 4
13373: PPUSH
13374: LD_EXP 14
13378: PPUSH
13379: CALL_OW 292
13383: PUSH
13384: LD_INT 4
13386: PPUSH
13387: LD_EXP 22
13391: PPUSH
13392: CALL_OW 292
13396: OR
13397: IFFALSE 13819
13399: GO 13401
13401: DISABLE
13402: LD_INT 0
13404: PPUSH
13405: PPUSH
// begin Wait ( 0 0$05 ) ;
13406: LD_INT 175
13408: PPUSH
13409: CALL_OW 67
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
13413: LD_ADDR_VAR 0 1
13417: PUSH
13418: LD_INT 22
13420: PUSH
13421: LD_INT 4
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: PUSH
13433: FOR_IN
13434: IFFALSE 13450
// SetSide ( i , 1 ) ;
13436: LD_VAR 0 1
13440: PPUSH
13441: LD_INT 1
13443: PPUSH
13444: CALL_OW 235
13448: GO 13433
13450: POP
13451: POP
// per := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff sikorski ;
13452: LD_ADDR_VAR 0 2
13456: PUSH
13457: LD_INT 22
13459: PUSH
13460: LD_INT 1
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: PUSH
13467: LD_INT 21
13469: PUSH
13470: LD_INT 1
13472: PUSH
13473: EMPTY
13474: LIST
13475: LIST
13476: PUSH
13477: LD_INT 26
13479: PUSH
13480: LD_INT 1
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: LIST
13491: PPUSH
13492: CALL_OW 69
13496: PUSH
13497: LD_EXP 14
13501: DIFF
13502: ST_TO_ADDR
// InGameOn ;
13503: CALL_OW 8
// CenterNowOnXY ( 19 , 13 ) ;
13507: LD_INT 19
13509: PPUSH
13510: LD_INT 13
13512: PPUSH
13513: CALL_OW 86
// if IsInUnit ( sikorski ) then
13517: LD_EXP 14
13521: PPUSH
13522: CALL_OW 310
13526: IFFALSE 13544
// begin ComExitVehicle ( sikorski ) ;
13528: LD_EXP 14
13532: PPUSH
13533: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
13537: LD_INT 10
13539: PPUSH
13540: CALL_OW 67
// end ; ComTurnUnit ( sikorski , per [ 1 ] ) ;
13544: LD_EXP 14
13548: PPUSH
13549: LD_VAR 0 2
13553: PUSH
13554: LD_INT 1
13556: ARRAY
13557: PPUSH
13558: CALL_OW 119
// ComTurnUnit ( per [ 1 ] , sikorski ) ;
13562: LD_VAR 0 2
13566: PUSH
13567: LD_INT 1
13569: ARRAY
13570: PPUSH
13571: LD_EXP 14
13575: PPUSH
13576: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
13580: LD_INT 10
13582: PPUSH
13583: CALL_OW 67
// Say ( sikorski , DS-1 ) ;
13587: LD_EXP 14
13591: PPUSH
13592: LD_STRING DS-1
13594: PPUSH
13595: CALL_OW 88
// Say ( per [ 1 ] , DP-1 ) ;
13599: LD_VAR 0 2
13603: PUSH
13604: LD_INT 1
13606: ARRAY
13607: PPUSH
13608: LD_STRING DP-1
13610: PPUSH
13611: CALL_OW 88
// Say ( sikorski , DS-2 ) ;
13615: LD_EXP 14
13619: PPUSH
13620: LD_STRING DS-2
13622: PPUSH
13623: CALL_OW 88
// Say ( per [ 1 ] , DP-2 ) ;
13627: LD_VAR 0 2
13631: PUSH
13632: LD_INT 1
13634: ARRAY
13635: PPUSH
13636: LD_STRING DP-2
13638: PPUSH
13639: CALL_OW 88
// Say ( sikorski , DS-3 ) ;
13643: LD_EXP 14
13647: PPUSH
13648: LD_STRING DS-3
13650: PPUSH
13651: CALL_OW 88
// Say ( per [ 1 ] , DP-3 ) ;
13655: LD_VAR 0 2
13659: PUSH
13660: LD_INT 1
13662: ARRAY
13663: PPUSH
13664: LD_STRING DP-3
13666: PPUSH
13667: CALL_OW 88
// Say ( sikorski , DS-4 ) ;
13671: LD_EXP 14
13675: PPUSH
13676: LD_STRING DS-4
13678: PPUSH
13679: CALL_OW 88
// Wait ( 0 0$0.6 ) ;
13683: LD_INT 21
13685: PPUSH
13686: CALL_OW 67
// SayRadio ( ron , DR-1 ) ;
13690: LD_EXP 17
13694: PPUSH
13695: LD_STRING DR-1
13697: PPUSH
13698: CALL_OW 94
// Say ( sikorski , DS-5 ) ;
13702: LD_EXP 14
13706: PPUSH
13707: LD_STRING DS-5
13709: PPUSH
13710: CALL_OW 88
// SayRadio ( ron , DR-2 ) ;
13714: LD_EXP 17
13718: PPUSH
13719: LD_STRING DR-2
13721: PPUSH
13722: CALL_OW 94
// Say ( sikorski , DS-6 ) ;
13726: LD_EXP 14
13730: PPUSH
13731: LD_STRING DS-6
13733: PPUSH
13734: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
13738: LD_INT 10
13740: PPUSH
13741: CALL_OW 67
// SayRadio ( ron , DR-3 ) ;
13745: LD_EXP 17
13749: PPUSH
13750: LD_STRING DR-3
13752: PPUSH
13753: CALL_OW 94
// InGameOff ;
13757: CALL_OW 9
// ChangeMissionObjectives ( target2 ) ;
13761: LD_STRING target2
13763: PPUSH
13764: CALL_OW 337
// Wait ( 0 0$03 ) ;
13768: LD_INT 105
13770: PPUSH
13771: CALL_OW 67
// Say ( sikorski , DS-7 ) ;
13775: LD_EXP 14
13779: PPUSH
13780: LD_STRING DS-7
13782: PPUSH
13783: CALL_OW 88
// Wait ( [ 6 6$00 , 5 5$00 , 4 4$00 ] [ global_diff ] ) ;
13787: LD_INT 12600
13789: PUSH
13790: LD_INT 10500
13792: PUSH
13793: LD_INT 8400
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: LIST
13800: PUSH
13801: LD_EXP 3
13805: ARRAY
13806: PPUSH
13807: CALL_OW 67
// russian_produce := true ;
13811: LD_ADDR_EXP 20
13815: PUSH
13816: LD_INT 1
13818: ST_TO_ADDR
// end ;
13819: PPOPN 2
13821: END
// export us_unit ; every 0 0$11 trigger timer >= [ 25 25$00 , 27 27$30 , 29 29$20 ] [ global_diff ] do
13822: LD_EXP 2
13826: PUSH
13827: LD_INT 52500
13829: PUSH
13830: LD_INT 57750
13832: PUSH
13833: LD_INT 61600
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: LIST
13840: PUSH
13841: LD_EXP 3
13845: ARRAY
13846: GREATEREQUAL
13847: IFFALSE 14015
13849: GO 13851
13851: DISABLE
// begin uc_side := 8 ;
13852: LD_ADDR_OWVAR 20
13856: PUSH
13857: LD_INT 8
13859: ST_TO_ADDR
// uc_nation := 1 ;
13860: LD_ADDR_OWVAR 21
13864: PUSH
13865: LD_INT 1
13867: ST_TO_ADDR
// hc_sex := sex_male ;
13868: LD_ADDR_OWVAR 27
13872: PUSH
13873: LD_INT 1
13875: ST_TO_ADDR
// hc_gallery :=  ;
13876: LD_ADDR_OWVAR 33
13880: PUSH
13881: LD_STRING 
13883: ST_TO_ADDR
// hc_name :=  ;
13884: LD_ADDR_OWVAR 26
13888: PUSH
13889: LD_STRING 
13891: ST_TO_ADDR
// hc_class := Rand ( 1 , 4 ) ;
13892: LD_ADDR_OWVAR 28
13896: PUSH
13897: LD_INT 1
13899: PPUSH
13900: LD_INT 4
13902: PPUSH
13903: CALL_OW 12
13907: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
13908: LD_ADDR_OWVAR 31
13912: PUSH
13913: LD_INT 2
13915: PPUSH
13916: LD_EXP 6
13920: PPUSH
13921: CALL_OW 12
13925: PUSH
13926: LD_INT 2
13928: PPUSH
13929: LD_EXP 6
13933: PPUSH
13934: CALL_OW 12
13938: PUSH
13939: LD_INT 2
13941: PPUSH
13942: LD_EXP 6
13946: PPUSH
13947: CALL_OW 12
13951: PUSH
13952: LD_INT 2
13954: PPUSH
13955: LD_EXP 6
13959: PPUSH
13960: CALL_OW 12
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: ST_TO_ADDR
// us_unit := CreateHuman ;
13971: LD_ADDR_EXP 46
13975: PUSH
13976: CALL_OW 44
13980: ST_TO_ADDR
// PlaceUnitArea ( us_unit , swamp_spawn , true ) ;
13981: LD_EXP 46
13985: PPUSH
13986: LD_INT 13
13988: PPUSH
13989: LD_INT 1
13991: PPUSH
13992: CALL_OW 49
// Wait ( 0 0$0.3 ) ;
13996: LD_INT 10
13998: PPUSH
13999: CALL_OW 67
// SayRadio ( us_unit , Dun1 ) ;
14003: LD_EXP 46
14007: PPUSH
14008: LD_STRING Dun1
14010: PPUSH
14011: CALL_OW 94
// end ;
14015: END
// every 0 0$01 trigger See ( 1 , us_unit ) do
14016: LD_INT 1
14018: PPUSH
14019: LD_EXP 46
14023: PPUSH
14024: CALL_OW 292
14028: IFFALSE 14045
14030: GO 14032
14032: DISABLE
// SetSide ( us_unit , 1 ) ;
14033: LD_EXP 46
14037: PPUSH
14038: LD_INT 1
14040: PPUSH
14041: CALL_OW 235
14045: END
// every 1 1$35 trigger timer >= [ 8 8$00 , 9 9$00 , 10 10$00 ] [ global_diff ] do var un , veh , i ;
14046: LD_EXP 2
14050: PUSH
14051: LD_INT 16800
14053: PUSH
14054: LD_INT 18900
14056: PUSH
14057: LD_INT 21000
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: LIST
14064: PUSH
14065: LD_EXP 3
14069: ARRAY
14070: GREATEREQUAL
14071: IFFALSE 14450
14073: GO 14075
14075: DISABLE
14076: LD_INT 0
14078: PPUSH
14079: PPUSH
14080: PPUSH
// begin uc_side := 4 ;
14081: LD_ADDR_OWVAR 20
14085: PUSH
14086: LD_INT 4
14088: ST_TO_ADDR
// uc_nation := 1 ;
14089: LD_ADDR_OWVAR 21
14093: PUSH
14094: LD_INT 1
14096: ST_TO_ADDR
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_medium_wheeled ] [ global_diff ] ;
14097: LD_ADDR_OWVAR 37
14101: PUSH
14102: LD_INT 3
14104: PUSH
14105: LD_INT 2
14107: PUSH
14108: LD_INT 2
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: LIST
14115: PUSH
14116: LD_EXP 3
14120: ARRAY
14121: ST_TO_ADDR
// vc_engine := engine_solar ;
14122: LD_ADDR_OWVAR 39
14126: PUSH
14127: LD_INT 2
14129: ST_TO_ADDR
// vc_control := control_manual ;
14130: LD_ADDR_OWVAR 38
14134: PUSH
14135: LD_INT 1
14137: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
14138: LD_ADDR_OWVAR 40
14142: PUSH
14143: LD_INT 12
14145: ST_TO_ADDR
// veh := CreateVehicle ;
14146: LD_ADDR_VAR 0 2
14150: PUSH
14151: CALL_OW 45
14155: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , false ) ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_INT 20
14163: PPUSH
14164: LD_INT 0
14166: PPUSH
14167: CALL_OW 49
// hc_sex := sex_male ;
14171: LD_ADDR_OWVAR 27
14175: PUSH
14176: LD_INT 1
14178: ST_TO_ADDR
// hc_gallery :=  ;
14179: LD_ADDR_OWVAR 33
14183: PUSH
14184: LD_STRING 
14186: ST_TO_ADDR
// hc_name :=  ;
14187: LD_ADDR_OWVAR 26
14191: PUSH
14192: LD_STRING 
14194: ST_TO_ADDR
// hc_class := 3 ;
14195: LD_ADDR_OWVAR 28
14199: PUSH
14200: LD_INT 3
14202: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
14203: LD_ADDR_OWVAR 31
14207: PUSH
14208: LD_INT 2
14210: PPUSH
14211: LD_EXP 6
14215: PPUSH
14216: CALL_OW 12
14220: PUSH
14221: LD_INT 2
14223: PPUSH
14224: LD_EXP 6
14228: PPUSH
14229: CALL_OW 12
14233: PUSH
14234: LD_INT 2
14236: PPUSH
14237: LD_EXP 6
14241: PPUSH
14242: CALL_OW 12
14246: PUSH
14247: LD_INT 2
14249: PPUSH
14250: LD_EXP 6
14254: PPUSH
14255: CALL_OW 12
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: ST_TO_ADDR
// un := CreateHuman ;
14266: LD_ADDR_VAR 0 1
14270: PUSH
14271: CALL_OW 44
14275: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , true ) ;
14276: LD_VAR 0 2
14280: PPUSH
14281: LD_INT 20
14283: PPUSH
14284: LD_INT 1
14286: PPUSH
14287: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
14291: LD_VAR 0 1
14295: PPUSH
14296: LD_VAR 0 2
14300: PPUSH
14301: CALL_OW 52
// SetCargo ( veh , mat_cans , 60 ) ;
14305: LD_VAR 0 2
14309: PPUSH
14310: LD_INT 1
14312: PPUSH
14313: LD_INT 60
14315: PPUSH
14316: CALL_OW 290
// SetFuel ( veh , 98 ) ;
14320: LD_VAR 0 2
14324: PPUSH
14325: LD_INT 98
14327: PPUSH
14328: CALL_OW 240
// SetLives ( un , 500 ) ;
14332: LD_VAR 0 1
14336: PPUSH
14337: LD_INT 500
14339: PPUSH
14340: CALL_OW 234
// SetLives ( veh , Rand ( 900 , 999 ) ) ;
14344: LD_VAR 0 2
14348: PPUSH
14349: LD_INT 900
14351: PPUSH
14352: LD_INT 999
14354: PPUSH
14355: CALL_OW 12
14359: PPUSH
14360: CALL_OW 234
// ComMoveXY ( un , 14 , 9 ) ;
14364: LD_VAR 0 1
14368: PPUSH
14369: LD_INT 14
14371: PPUSH
14372: LD_INT 9
14374: PPUSH
14375: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
14379: LD_INT 35
14381: PPUSH
14382: CALL_OW 67
// until See ( 1 , veh ) or See ( 1 , un ) ;
14386: LD_INT 1
14388: PPUSH
14389: LD_VAR 0 2
14393: PPUSH
14394: CALL_OW 292
14398: PUSH
14399: LD_INT 1
14401: PPUSH
14402: LD_VAR 0 1
14406: PPUSH
14407: CALL_OW 292
14411: OR
14412: IFFALSE 14379
// Say ( un , Dcargo ) ;
14414: LD_VAR 0 1
14418: PPUSH
14419: LD_STRING Dcargo
14421: PPUSH
14422: CALL_OW 88
// SetSide ( un , 1 ) ;
14426: LD_VAR 0 1
14430: PPUSH
14431: LD_INT 1
14433: PPUSH
14434: CALL_OW 235
// SetSide ( veh , 1 ) ;
14438: LD_VAR 0 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 235
// end ;
14450: PPOPN 3
14452: END
// every 0 0$01 trigger timer >= [ 18 18$00 , 19 19$00 , 21 21$00 ] [ global_diff ] and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) < 5 do var un , speaker , veh , i , area ;
14453: LD_EXP 2
14457: PUSH
14458: LD_INT 37800
14460: PUSH
14461: LD_INT 39900
14463: PUSH
14464: LD_INT 44100
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: LIST
14471: PUSH
14472: LD_EXP 3
14476: ARRAY
14477: GREATEREQUAL
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 6
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: PPUSH
14503: CALL_OW 69
14507: PUSH
14508: LD_INT 5
14510: LESS
14511: AND
14512: IFFALSE 14847
14514: GO 14516
14516: DISABLE
14517: LD_INT 0
14519: PPUSH
14520: PPUSH
14521: PPUSH
14522: PPUSH
14523: PPUSH
// begin area := [ us_north , us_south , us_north ] [ global_diff ] ;
14524: LD_ADDR_VAR 0 5
14528: PUSH
14529: LD_INT 21
14531: PUSH
14532: LD_INT 14
14534: PUSH
14535: LD_INT 21
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: LIST
14542: PUSH
14543: LD_EXP 3
14547: ARRAY
14548: ST_TO_ADDR
// speaker := [ ] ;
14549: LD_ADDR_VAR 0 2
14553: PUSH
14554: EMPTY
14555: ST_TO_ADDR
// uc_side := 1 ;
14556: LD_ADDR_OWVAR 20
14560: PUSH
14561: LD_INT 1
14563: ST_TO_ADDR
// uc_nation := 1 ;
14564: LD_ADDR_OWVAR 21
14568: PUSH
14569: LD_INT 1
14571: ST_TO_ADDR
// for i = 1 to 7 - [ global_diff ] do
14572: LD_ADDR_VAR 0 4
14576: PUSH
14577: DOUBLE
14578: LD_INT 1
14580: DEC
14581: ST_TO_ADDR
14582: LD_INT 7
14584: PUSH
14585: LD_EXP 3
14589: PUSH
14590: EMPTY
14591: LIST
14592: MINUS
14593: PUSH
14594: FOR_TO
14595: IFFALSE 14658
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , am_def ) ;
14597: LD_ADDR_VAR 0 1
14601: PUSH
14602: LD_INT 1
14604: PPUSH
14605: LD_INT 4
14607: PPUSH
14608: CALL_OW 12
14612: PPUSH
14613: LD_EXP 6
14617: PPUSH
14618: CALL 418 0 2
14622: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
14623: LD_VAR 0 1
14627: PPUSH
14628: LD_VAR 0 5
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// speaker := speaker ^ un ;
14640: LD_ADDR_VAR 0 2
14644: PUSH
14645: LD_VAR 0 2
14649: PUSH
14650: LD_VAR 0 1
14654: ADD
14655: ST_TO_ADDR
// end ;
14656: GO 14594
14658: POP
14659: POP
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ global_diff ] ;
14660: LD_ADDR_OWVAR 37
14664: PUSH
14665: LD_INT 3
14667: PUSH
14668: LD_INT 2
14670: PUSH
14671: LD_INT 1
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: LIST
14678: PUSH
14679: LD_EXP 3
14683: ARRAY
14684: ST_TO_ADDR
// vc_engine := engine_solar ;
14685: LD_ADDR_OWVAR 39
14689: PUSH
14690: LD_INT 2
14692: ST_TO_ADDR
// vc_control := control_manual ;
14693: LD_ADDR_OWVAR 38
14697: PUSH
14698: LD_INT 1
14700: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_gatling_gun , us_machine_gun ] [ global_diff ] ;
14701: LD_ADDR_OWVAR 40
14705: PUSH
14706: LD_INT 5
14708: PUSH
14709: LD_INT 4
14711: PUSH
14712: LD_INT 2
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: LIST
14719: PUSH
14720: LD_EXP 3
14724: ARRAY
14725: ST_TO_ADDR
// veh := CreateVehicle ;
14726: LD_ADDR_VAR 0 3
14730: PUSH
14731: CALL_OW 45
14735: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
14736: LD_VAR 0 3
14740: PPUSH
14741: LD_VAR 0 5
14745: PPUSH
14746: LD_INT 0
14748: PPUSH
14749: CALL_OW 49
// un := CreateHumanWithClass ( 3 , am_def ) ;
14753: LD_ADDR_VAR 0 1
14757: PUSH
14758: LD_INT 3
14760: PPUSH
14761: LD_EXP 6
14765: PPUSH
14766: CALL 418 0 2
14770: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
14771: LD_VAR 0 1
14775: PPUSH
14776: LD_VAR 0 3
14780: PPUSH
14781: CALL_OW 52
// Wait ( 0 0$0.3 ) ;
14785: LD_INT 10
14787: PPUSH
14788: CALL_OW 67
// SayRadio ( UnitFilter ( speaker , [ f_sex , sex_male ] ) [ 1 ] , Dhelp ) ;
14792: LD_VAR 0 2
14796: PPUSH
14797: LD_INT 26
14799: PUSH
14800: LD_INT 1
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 72
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING Dhelp
14818: PPUSH
14819: CALL_OW 94
// CenterNowOnXY ( GetX ( un ) , GetY ( un ) ) ;
14823: LD_VAR 0 1
14827: PPUSH
14828: CALL_OW 250
14832: PPUSH
14833: LD_VAR 0 1
14837: PPUSH
14838: CALL_OW 251
14842: PPUSH
14843: CALL_OW 86
// end ;
14847: PPOPN 5
14849: END
// every 0 0$01 trigger FilterUnitsInArea ( kurin_a , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) > 0 do
14850: LD_INT 19
14852: PPUSH
14853: LD_INT 2
14855: PUSH
14856: LD_INT 22
14858: PUSH
14859: LD_INT 3
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PUSH
14866: LD_INT 22
14868: PUSH
14869: LD_INT 6
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: LIST
14880: PPUSH
14881: CALL_OW 70
14885: PUSH
14886: LD_INT 0
14888: GREATER
14889: IFFALSE 14917
14891: GO 14893
14893: DISABLE
// begin if IsLive ( kurin ) then
14894: LD_EXP 15
14898: PPUSH
14899: CALL_OW 300
14903: IFFALSE 14917
// SayRadio ( kurin , Dkurin ) ;
14905: LD_EXP 15
14909: PPUSH
14910: LD_STRING Dkurin
14912: PPUSH
14913: CALL_OW 94
// end ;
14917: END
// every 0 0$01 trigger timer > 27 27$00 do
14918: LD_EXP 2
14922: PUSH
14923: LD_INT 56700
14925: GREATER
14926: IFFALSE 14943
14928: GO 14930
14930: DISABLE
// SayRadio ( jack , ar_come ) ;
14931: LD_EXP 18
14935: PPUSH
14936: LD_STRING ar_come
14938: PPUSH
14939: CALL_OW 94
14943: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) > 0 do
14944: LD_INT 22
14946: PUSH
14947: LD_INT 2
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PPUSH
14954: CALL_OW 69
14958: PUSH
14959: LD_INT 0
14961: GREATER
14962: IFFALSE 14990
14964: GO 14966
14966: DISABLE
// begin FHeike ;
14967: CALL 11534 0 0
// Wait ( 0 0$01 ) ;
14971: LD_INT 35
14973: PPUSH
14974: CALL_OW 67
// SayRadio ( heike , heike1 ) ;
14978: LD_EXP 16
14982: PPUSH
14983: LD_STRING heike1
14985: PPUSH
14986: CALL_OW 94
// end ;
14990: END
// every 15 15$00 trigger timer > 22 22$00 do
14991: LD_EXP 2
14995: PUSH
14996: LD_INT 46200
14998: GREATER
14999: IFFALSE 15050
15001: GO 15003
15003: DISABLE
// begin enable ;
15004: ENABLE
// ArabianAttack ( 2 , ar_force , Rand ( 1 , 2 ) , [ ar_area1 , ar_area2 ] [ Rand ( 1 , 2 ) ] ) ;
15005: LD_INT 2
15007: PPUSH
15008: LD_EXP 9
15012: PPUSH
15013: LD_INT 1
15015: PPUSH
15016: LD_INT 2
15018: PPUSH
15019: CALL_OW 12
15023: PPUSH
15024: LD_INT 6
15026: PUSH
15027: LD_INT 16
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 1
15036: PPUSH
15037: LD_INT 2
15039: PPUSH
15040: CALL_OW 12
15044: ARRAY
15045: PPUSH
15046: CALL 10951 0 4
// end ;
15050: END
// every 0 0$01 trigger timer >= Rand ( 65 65$00 , 67 67$30 ) or ( FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 ) do var i ;
15051: LD_EXP 2
15055: PUSH
15056: LD_INT 136500
15058: PPUSH
15059: LD_INT 141750
15061: PPUSH
15062: CALL_OW 12
15066: GREATEREQUAL
15067: PUSH
15068: LD_INT 22
15070: PUSH
15071: LD_INT 3
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: PPUSH
15078: CALL_OW 69
15082: PUSH
15083: LD_INT 22
15085: PUSH
15086: LD_INT 6
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PPUSH
15093: CALL_OW 69
15097: PLUS
15098: PUSH
15099: LD_INT 3
15101: LESS
15102: OR
15103: IFFALSE 15177
15105: GO 15107
15107: DISABLE
15108: LD_INT 0
15110: PPUSH
// begin InGameOn ;
15111: CALL_OW 8
// DialogueOn ;
15115: CALL_OW 6
// SayRadio ( ron , you_win ) ;
15119: LD_EXP 17
15123: PPUSH
15124: LD_STRING you_win
15126: PPUSH
15127: CALL_OW 94
// DialogueOff ;
15131: CALL_OW 7
// InGameOff ;
15135: CALL_OW 9
// AddMedal ( med , 1 ) ;
15139: LD_STRING med
15141: PPUSH
15142: LD_INT 1
15144: PPUSH
15145: CALL_OW 101
// End_The_Mission_Allowed := true ;
15149: LD_ADDR_OWVAR 57
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// case Query ( MEnd ) of 1 :
15157: LD_STRING MEnd
15159: PPUSH
15160: CALL_OW 97
15164: PUSH
15165: LD_INT 1
15167: DOUBLE
15168: EQUAL
15169: IFTRUE 15173
15171: GO 15176
15173: POP
// ; end ;
15174: GO 15177
15176: POP
// end ;
15177: PPOPN 1
15179: END
// on EndTheMissionRaised ( exitt ) do begin End_The_Mission_Allowed := false ;
15180: LD_ADDR_OWVAR 57
15184: PUSH
15185: LD_INT 0
15187: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 then
15188: LD_INT 22
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PPUSH
15198: CALL_OW 69
15202: PUSH
15203: LD_INT 22
15205: PUSH
15206: LD_INT 6
15208: PUSH
15209: EMPTY
15210: LIST
15211: LIST
15212: PPUSH
15213: CALL_OW 69
15217: PLUS
15218: PUSH
15219: LD_INT 3
15221: LESS
15222: IFFALSE 15236
// AddMedal ( ru , 1 ) else
15224: LD_STRING ru
15226: PPUSH
15227: LD_INT 1
15229: PPUSH
15230: CALL_OW 101
15234: GO 15247
// AddMedal ( ru , - 1 ) ;
15236: LD_STRING ru
15238: PPUSH
15239: LD_INT 1
15241: NEG
15242: PPUSH
15243: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 6 then
15247: LD_INT 22
15249: PUSH
15250: LD_INT 1
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 6
15278: GREATER
15279: IFFALSE 15293
// AddMedal ( pep , 1 ) else
15281: LD_STRING pep
15283: PPUSH
15284: LD_INT 1
15286: PPUSH
15287: CALL_OW 101
15291: GO 15304
// AddMedal ( pep , - 1 ) ;
15293: LD_STRING pep
15295: PPUSH
15296: LD_INT 1
15298: NEG
15299: PPUSH
15300: CALL_OW 101
// GiveMedals ( MAIN ) ;
15304: LD_STRING MAIN
15306: PPUSH
15307: CALL_OW 102
// YouWin ;
15311: CALL_OW 103
// end ;
15315: PPOPN 1
15317: END
