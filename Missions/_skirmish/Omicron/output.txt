// starting begin InitMap ;
   0: CALL 1433 0 0
// InitTriggers ;
   4: CALL 1818 0 0
// Start_Game ;
   8: CALL 13088 0 0
// InitPlayer ;
  12: CALL 2055 0 0
// InitRussian ;
  16: CALL 2945 0 0
// end ; end_of_file
  20: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
  21: LD_INT 0
  23: PPUSH
  24: PPUSH
  25: PPUSH
  26: PPUSH
  27: PPUSH
// uc_nation = nation_nature ;
  28: LD_ADDR_OWVAR 21
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// uc_side = 0 ;
  36: LD_ADDR_OWVAR 20
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// l = 0 ;
  44: LD_ADDR_VAR 0 6
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
  52: LD_ADDR_OWVAR 24
  56: PUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: CALL_OW 12
  67: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
  68: LD_ADDR_OWVAR 35
  72: PUSH
  73: LD_INT 5
  75: NEG
  76: PPUSH
  77: LD_INT 5
  79: PPUSH
  80: CALL_OW 12
  84: ST_TO_ADDR
// hc_gallery =  ;
  85: LD_ADDR_OWVAR 33
  89: PUSH
  90: LD_STRING 
  92: ST_TO_ADDR
// hc_class = class_apeman ;
  93: LD_ADDR_OWVAR 28
  97: PUSH
  98: LD_INT 12
 100: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 101: LD_ADDR_OWVAR 29
 105: PUSH
 106: LD_INT 11
 108: PPUSH
 109: LD_INT 13
 111: PPUSH
 112: CALL_OW 12
 116: PUSH
 117: LD_INT 10
 119: PPUSH
 120: LD_INT 11
 122: PPUSH
 123: CALL_OW 12
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: ST_TO_ADDR
// hc_sex = sex_male ;
 132: LD_ADDR_OWVAR 27
 136: PUSH
 137: LD_INT 1
 139: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 140: LD_ADDR_OWVAR 31
 144: PUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 2
 150: PPUSH
 151: CALL_OW 12
 155: PUSH
 156: LD_INT 0
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: LIST
 169: LIST
 170: ST_TO_ADDR
// apeman = CreateHuman ;
 171: LD_ADDR_VAR 0 7
 175: PUSH
 176: CALL_OW 44
 180: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 181: LD_VAR 0 7
 185: PPUSH
 186: LD_VAR 0 4
 190: PPUSH
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 49
// l = l + 1 ;
 198: LD_ADDR_VAR 0 6
 202: PUSH
 203: LD_VAR 0 6
 207: PUSH
 208: LD_INT 1
 210: PLUS
 211: ST_TO_ADDR
// end until l = num1 ;
 212: LD_VAR 0 6
 216: PUSH
 217: LD_VAR 0 1
 221: EQUAL
 222: IFFALSE 52
// l = 0 ;
 224: LD_ADDR_VAR 0 6
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 232: LD_ADDR_OWVAR 35
 236: PUSH
 237: LD_INT 0
 239: PPUSH
 240: LD_INT 25
 242: PPUSH
 243: CALL_OW 12
 247: ST_TO_ADDR
// hc_class = class_tiger ;
 248: LD_ADDR_OWVAR 28
 252: PUSH
 253: LD_INT 14
 255: ST_TO_ADDR
// hc_sex = sex_male ;
 256: LD_ADDR_OWVAR 27
 260: PUSH
 261: LD_INT 1
 263: ST_TO_ADDR
// hc_gallery = sandnature ;
 264: LD_ADDR_OWVAR 33
 268: PUSH
 269: LD_STRING sandnature
 271: ST_TO_ADDR
// hc_face_number = 3 ;
 272: LD_ADDR_OWVAR 34
 276: PUSH
 277: LD_INT 3
 279: ST_TO_ADDR
// tiger = CreateHuman ;
 280: LD_ADDR_VAR 0 8
 284: PUSH
 285: CALL_OW 44
 289: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 290: LD_VAR 0 8
 294: PPUSH
 295: LD_VAR 0 4
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL_OW 49
// l = l + 1 ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_INT 1
 319: PLUS
 320: ST_TO_ADDR
// end until l = num2 ;
 321: LD_VAR 0 6
 325: PUSH
 326: LD_VAR 0 2
 330: EQUAL
 331: IFFALSE 232
// l = 0 ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 341: LD_ADDR_OWVAR 28
 345: PUSH
 346: LD_INT 18
 348: ST_TO_ADDR
// hc_gallery = sandnature ;
 349: LD_ADDR_OWVAR 33
 353: PUSH
 354: LD_STRING sandnature
 356: ST_TO_ADDR
// hc_face_number = 1 ;
 357: LD_ADDR_OWVAR 34
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// bird = CreateHuman ;
 365: LD_ADDR_VAR 0 9
 369: PUSH
 370: CALL_OW 44
 374: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 375: LD_VAR 0 9
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: CALL_OW 51
// l = l + 1 ;
 387: LD_ADDR_VAR 0 6
 391: PUSH
 392: LD_VAR 0 6
 396: PUSH
 397: LD_INT 1
 399: PLUS
 400: ST_TO_ADDR
// end until l = num3 ;
 401: LD_VAR 0 6
 405: PUSH
 406: LD_VAR 0 3
 410: EQUAL
 411: IFFALSE 341
// end ;
 413: LD_VAR 0 5
 417: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
 423: PPUSH
 424: PPUSH
 425: PPUSH
// hc_class := clas ;
 426: LD_ADDR_OWVAR 28
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 2
 445: PUSH
 446: LD_INT 1
 448: NEG
 449: PPUSH
 450: LD_INT 1
 452: PPUSH
 453: CALL_OW 12
 457: PLUS
 458: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 459: LD_ADDR_VAR 0 5
 463: PUSH
 464: LD_VAR 0 2
 468: PUSH
 469: LD_INT 1
 471: NEG
 472: PPUSH
 473: LD_INT 1
 475: PPUSH
 476: CALL_OW 12
 480: PLUS
 481: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 482: LD_ADDR_VAR 0 6
 486: PUSH
 487: LD_VAR 0 2
 491: PUSH
 492: LD_INT 1
 494: NEG
 495: PPUSH
 496: LD_INT 1
 498: PPUSH
 499: CALL_OW 12
 503: PLUS
 504: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 505: LD_ADDR_VAR 0 7
 509: PUSH
 510: LD_VAR 0 2
 514: PUSH
 515: LD_INT 1
 517: NEG
 518: PPUSH
 519: LD_INT 1
 521: PPUSH
 522: CALL_OW 12
 526: PLUS
 527: ST_TO_ADDR
// if clas = 1 or clas = 9 then
 528: LD_VAR 0 1
 532: PUSH
 533: LD_INT 1
 535: EQUAL
 536: PUSH
 537: LD_VAR 0 1
 541: PUSH
 542: LD_INT 9
 544: EQUAL
 545: OR
 546: IFFALSE 571
// bonus := [ 2 , 0 , 0 , 0 ] ;
 548: LD_ADDR_VAR 0 8
 552: PUSH
 553: LD_INT 2
 555: PUSH
 556: LD_INT 0
 558: PUSH
 559: LD_INT 0
 561: PUSH
 562: LD_INT 0
 564: PUSH
 565: EMPTY
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: ST_TO_ADDR
// if clas = 2 then
 571: LD_VAR 0 1
 575: PUSH
 576: LD_INT 2
 578: EQUAL
 579: IFFALSE 604
// bonus := [ 0 , 2 , 0 , 0 ] ;
 581: LD_ADDR_VAR 0 8
 585: PUSH
 586: LD_INT 0
 588: PUSH
 589: LD_INT 2
 591: PUSH
 592: LD_INT 0
 594: PUSH
 595: LD_INT 0
 597: PUSH
 598: EMPTY
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: ST_TO_ADDR
// if clas = 3 then
 604: LD_VAR 0 1
 608: PUSH
 609: LD_INT 3
 611: EQUAL
 612: IFFALSE 637
// bonus := [ 0 , 0 , 2 , 0 ] ;
 614: LD_ADDR_VAR 0 8
 618: PUSH
 619: LD_INT 0
 621: PUSH
 622: LD_INT 0
 624: PUSH
 625: LD_INT 2
 627: PUSH
 628: LD_INT 0
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: ST_TO_ADDR
// if clas = 4 then
 637: LD_VAR 0 1
 641: PUSH
 642: LD_INT 4
 644: EQUAL
 645: IFFALSE 670
// bonus := [ 0 , 0 , 0 , 2 ] ;
 647: LD_ADDR_VAR 0 8
 651: PUSH
 652: LD_INT 0
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: LD_INT 0
 660: PUSH
 661: LD_INT 2
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: ST_TO_ADDR
// if clas > 4 and not clas = 9 then
 670: LD_VAR 0 1
 674: PUSH
 675: LD_INT 4
 677: GREATER
 678: PUSH
 679: LD_VAR 0 1
 683: PUSH
 684: LD_INT 9
 686: EQUAL
 687: NOT
 688: AND
 689: IFFALSE 714
// bonus := [ 0 , 0 , 0 , 0 ] ;
 691: LD_ADDR_VAR 0 8
 695: PUSH
 696: LD_INT 0
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 0
 704: PUSH
 705: LD_INT 0
 707: PUSH
 708: EMPTY
 709: LIST
 710: LIST
 711: LIST
 712: LIST
 713: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 714: LD_ADDR_OWVAR 31
 718: PUSH
 719: LD_VAR 0 4
 723: PUSH
 724: LD_VAR 0 8
 728: PUSH
 729: LD_INT 1
 731: ARRAY
 732: PLUS
 733: PUSH
 734: LD_VAR 0 5
 738: PUSH
 739: LD_VAR 0 8
 743: PUSH
 744: LD_INT 2
 746: ARRAY
 747: PLUS
 748: PUSH
 749: LD_VAR 0 6
 753: PUSH
 754: LD_VAR 0 8
 758: PUSH
 759: LD_INT 3
 761: ARRAY
 762: PLUS
 763: PUSH
 764: LD_VAR 0 7
 768: PUSH
 769: LD_VAR 0 8
 773: PUSH
 774: LD_INT 4
 776: ARRAY
 777: PLUS
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: LIST
 783: LIST
 784: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 785: LD_ADDR_OWVAR 27
 789: PUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_INT 2
 795: PPUSH
 796: CALL_OW 12
 800: ST_TO_ADDR
// hc_gallery :=  ;
 801: LD_ADDR_OWVAR 33
 805: PUSH
 806: LD_STRING 
 808: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 809: LD_ADDR_OWVAR 29
 813: PUSH
 814: LD_INT 8
 816: PPUSH
 817: LD_INT 12
 819: PPUSH
 820: CALL_OW 12
 824: PUSH
 825: LD_INT 9
 827: PPUSH
 828: LD_INT 11
 830: PPUSH
 831: CALL_OW 12
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: ST_TO_ADDR
// hc_name :=  ;
 840: LD_ADDR_OWVAR 26
 844: PUSH
 845: LD_STRING 
 847: ST_TO_ADDR
// result := CreateHuman ;
 848: LD_ADDR_VAR 0 3
 852: PUSH
 853: CALL_OW 44
 857: ST_TO_ADDR
// end ;
 858: LD_VAR 0 3
 862: RET
// export function SeeSide ( unit , side ) ; var i ; begin
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
// result := false ;
 867: LD_ADDR_VAR 0 3
 871: PUSH
 872: LD_INT 0
 874: ST_TO_ADDR
// i := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
 875: LD_ADDR_VAR 0 4
 879: PUSH
 880: LD_INT 22
 882: PUSH
 883: LD_VAR 0 2
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: PPUSH
 892: CALL_OW 69
 896: PPUSH
 897: LD_VAR 0 1
 901: PPUSH
 902: CALL_OW 74
 906: ST_TO_ADDR
// if GetDistUnits ( unit , i ) < 9 then
 907: LD_VAR 0 1
 911: PPUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: CALL_OW 296
 921: PUSH
 922: LD_INT 9
 924: LESS
 925: IFFALSE 935
// result := true ;
 927: LD_ADDR_VAR 0 3
 931: PUSH
 932: LD_INT 1
 934: ST_TO_ADDR
// end ;
 935: LD_VAR 0 3
 939: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
 940: LD_VAR 0 1
 944: PUSH
 945: LD_EXP 1
 949: IN
 950: NOT
 951: IFFALSE 982
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
 953: LD_ADDR_EXP 1
 957: PUSH
 958: LD_EXP 1
 962: PPUSH
 963: LD_EXP 1
 967: PUSH
 968: LD_INT 1
 970: PLUS
 971: PPUSH
 972: LD_VAR 0 1
 976: PPUSH
 977: CALL_OW 2
 981: ST_TO_ADDR
// end ;
 982: PPOPN 1
 984: END
// export function ComAttack ( unit , ignore_list ) ; var i , j , target , enemy_list , _list , types_list ; begin
 985: LD_INT 0
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
// if not IsPlaced ( unit ) then
 994: LD_VAR 0 1
 998: PPUSH
 999: CALL_OW 305
1003: NOT
1004: IFFALSE 1008
// exit ;
1006: GO 1315
// enemy_list := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
1008: LD_ADDR_VAR 0 7
1012: PUSH
1013: LD_INT 81
1015: PUSH
1016: LD_VAR 0 1
1020: PPUSH
1021: CALL_OW 255
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: PPUSH
1030: CALL_OW 69
1034: ST_TO_ADDR
// if not enemy_list then
1035: LD_VAR 0 7
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1315
// if ignore_list then
1044: LD_VAR 0 2
1048: IFFALSE 1190
// begin _list := [ ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: EMPTY
1056: ST_TO_ADDR
// types_list := [ f_btype , f_weapon , f_class ] ;
1057: LD_ADDR_VAR 0 9
1061: PUSH
1062: LD_INT 30
1064: PUSH
1065: LD_INT 34
1067: PUSH
1068: LD_INT 25
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// for i = 1 to 3 do
1076: LD_ADDR_VAR 0 4
1080: PUSH
1081: DOUBLE
1082: LD_INT 1
1084: DEC
1085: ST_TO_ADDR
1086: LD_INT 3
1088: PUSH
1089: FOR_TO
1090: IFFALSE 1188
// begin if not ignore_list [ i ] then
1092: LD_VAR 0 2
1096: PUSH
1097: LD_VAR 0 4
1101: ARRAY
1102: NOT
1103: IFFALSE 1109
// continue else
1105: GO 1089
1107: GO 1186
// for j in ignore_list [ i ] do
1109: LD_ADDR_VAR 0 5
1113: PUSH
1114: LD_VAR 0 2
1118: PUSH
1119: LD_VAR 0 4
1123: ARRAY
1124: PUSH
1125: FOR_IN
1126: IFFALSE 1184
// begin _list := Insert ( _list , _list + 1 , UnitFilter ( enemy_list , [ types_list [ i ] , j ] ) ) ;
1128: LD_ADDR_VAR 0 8
1132: PUSH
1133: LD_VAR 0 8
1137: PPUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: PLUS
1146: PPUSH
1147: LD_VAR 0 7
1151: PPUSH
1152: LD_VAR 0 9
1156: PUSH
1157: LD_VAR 0 4
1161: ARRAY
1162: PUSH
1163: LD_VAR 0 5
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PPUSH
1172: CALL_OW 72
1176: PPUSH
1177: CALL_OW 2
1181: ST_TO_ADDR
// end ;
1182: GO 1125
1184: POP
1185: POP
// end ;
1186: GO 1089
1188: POP
1189: POP
// end ; if enemy_list diff _list > 0 then
1190: LD_VAR 0 7
1194: PUSH
1195: LD_VAR 0 8
1199: PUSH
1200: LD_INT 0
1202: GREATER
1203: DIFF
1204: IFFALSE 1222
// enemy_list := enemy_list diff _list ;
1206: LD_ADDR_VAR 0 7
1210: PUSH
1211: LD_VAR 0 7
1215: PUSH
1216: LD_VAR 0 8
1220: DIFF
1221: ST_TO_ADDR
// target := NearestUnitToUnit ( enemy_list , unit ) ;
1222: LD_ADDR_VAR 0 6
1226: PUSH
1227: LD_VAR 0 7
1231: PPUSH
1232: LD_VAR 0 1
1236: PPUSH
1237: CALL_OW 74
1241: ST_TO_ADDR
// if not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
1242: LD_VAR 0 1
1246: PPUSH
1247: LD_VAR 0 6
1251: PPUSH
1252: CALL_OW 250
1256: PPUSH
1257: LD_VAR 0 6
1261: PPUSH
1262: CALL_OW 251
1266: PPUSH
1267: CALL 1320 0 3
1271: NOT
1272: IFFALSE 1315
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
1274: LD_VAR 0 1
1278: PPUSH
1279: LD_INT 81
1281: PUSH
1282: LD_VAR 0 1
1286: PPUSH
1287: CALL_OW 255
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL_OW 69
1300: PPUSH
1301: LD_VAR 0 1
1305: PPUSH
1306: CALL_OW 74
1310: PPUSH
1311: CALL_OW 115
// end ;
1315: LD_VAR 0 3
1319: RET
// export function DestinationReachable ( unit , x , y ) ; begin
1320: LD_INT 0
1322: PPUSH
// if unit in unreachableList then
1323: LD_VAR 0 1
1327: PUSH
1328: LD_EXP 1
1332: IN
1333: IFFALSE 1351
// unreachableList := unreachableList diff unit ;
1335: LD_ADDR_EXP 1
1339: PUSH
1340: LD_EXP 1
1344: PUSH
1345: LD_VAR 0 1
1349: DIFF
1350: ST_TO_ADDR
// if ValidHex ( x , y ) then
1351: LD_VAR 0 2
1355: PPUSH
1356: LD_VAR 0 3
1360: PPUSH
1361: CALL_OW 488
1365: IFFALSE 1391
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_VAR 0 2
1376: PPUSH
1377: LD_VAR 0 3
1381: PPUSH
1382: CALL_OW 428
1386: PPUSH
1387: CALL_OW 115
// Wait ( 1 ) ;
1391: LD_INT 1
1393: PPUSH
1394: CALL_OW 67
// if unit in unreachableList then
1398: LD_VAR 0 1
1402: PUSH
1403: LD_EXP 1
1407: IN
1408: IFFALSE 1420
// result := false else
1410: LD_ADDR_VAR 0 4
1414: PUSH
1415: LD_INT 0
1417: ST_TO_ADDR
1418: GO 1428
// result := true ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// end ; end_of_file
1428: LD_VAR 0 4
1432: RET
// export function InitMap ; begin
1433: LD_INT 0
1435: PPUSH
// ResetFog ;
1436: CALL_OW 335
// PrepareAnimals ( 2 , 3 , 3 , nature_area ) ;
1440: LD_INT 2
1442: PPUSH
1443: LD_INT 3
1445: PPUSH
1446: LD_INT 3
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: CALL 21 0 4
// end ;
1456: LD_VAR 0 1
1460: RET
// export function SpawnCrates ; var i ; begin
1461: LD_INT 0
1463: PPUSH
1464: PPUSH
// while ( crates_allow ) do
1465: LD_EXP 13
1469: IFFALSE 1622
// begin Wait ( crates_time + Rand ( - 0 0$10 , 0 0$20 ) ) ;
1471: LD_EXP 11
1475: PUSH
1476: LD_INT 350
1478: NEG
1479: PPUSH
1480: LD_INT 700
1482: PPUSH
1483: CALL_OW 12
1487: PLUS
1488: PPUSH
1489: CALL_OW 67
// for i = 1 to crates_num do
1493: LD_ADDR_VAR 0 2
1497: PUSH
1498: DOUBLE
1499: LD_INT 1
1501: DEC
1502: ST_TO_ADDR
1503: LD_EXP 12
1507: PUSH
1508: FOR_TO
1509: IFFALSE 1618
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1511: LD_INT 1
1513: PPUSH
1514: LD_INT 5
1516: PPUSH
1517: CALL_OW 12
1521: PPUSH
1522: LD_INT 2
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: CALL_OW 55
// Wait ( Rand ( 0 0$03 , 0 0$12 ) ) ;
1532: LD_INT 105
1534: PPUSH
1535: LD_INT 420
1537: PPUSH
1538: CALL_OW 12
1542: PPUSH
1543: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1547: LD_INT 1
1549: PPUSH
1550: LD_INT 5
1552: PPUSH
1553: CALL_OW 12
1557: PPUSH
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 1
1563: PPUSH
1564: CALL_OW 55
// Wait ( Rand ( 0 0$04 , 0 0$15 ) ) ;
1568: LD_INT 140
1570: PPUSH
1571: LD_INT 525
1573: PPUSH
1574: CALL_OW 12
1578: PPUSH
1579: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
1583: LD_INT 1
1585: PPUSH
1586: LD_INT 5
1588: PPUSH
1589: CALL_OW 12
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 57
// Wait ( Rand ( 0 0$05 , 0 0$10 ) ) ;
1601: LD_INT 175
1603: PPUSH
1604: LD_INT 350
1606: PPUSH
1607: CALL_OW 12
1611: PPUSH
1612: CALL_OW 67
// end ;
1616: GO 1508
1618: POP
1619: POP
// end ;
1620: GO 1465
// end ;
1622: LD_VAR 0 1
1626: RET
// every 1 1$25 trigger game_started do
1627: LD_EXP 10
1631: IFFALSE 1685
1633: GO 1635
1635: DISABLE
// begin enable ;
1636: ENABLE
// if timer <= [ 23 23$00 , 21 21$00 , 19 19$00 ] [ global_diff ] then
1637: LD_EXP 2
1641: PUSH
1642: LD_INT 48300
1644: PUSH
1645: LD_INT 44100
1647: PUSH
1648: LD_INT 39900
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: PUSH
1656: LD_EXP 3
1660: ARRAY
1661: LESSEQUAL
1662: IFFALSE 1685
// CreateCratesArea ( Rand ( 2 , 5 ) , us_crates , true ) ;
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 5
1669: PPUSH
1670: CALL_OW 12
1674: PPUSH
1675: LD_INT 12
1677: PPUSH
1678: LD_INT 1
1680: PPUSH
1681: CALL_OW 55
// end ;
1685: END
// every 0 0$01 trigger game_started do
1686: LD_EXP 10
1690: IFFALSE 1699
1692: GO 1694
1694: DISABLE
// SpawnCrates ;
1695: CALL 1461 0 0
1699: END
// export timer ; every 1 do
1700: GO 1702
1702: DISABLE
// timer := 0 0$00 ;
1703: LD_ADDR_EXP 2
1707: PUSH
1708: LD_INT 0
1710: ST_TO_ADDR
1711: END
// every 0 0$01 trigger game_started do
1712: LD_EXP 10
1716: IFFALSE 1753
1718: GO 1720
1720: DISABLE
// begin enable ;
1721: ENABLE
// timer := timer + 0 0$01 ;
1722: LD_ADDR_EXP 2
1726: PUSH
1727: LD_EXP 2
1731: PUSH
1732: LD_INT 35
1734: PLUS
1735: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
1736: LD_ADDR_OWVAR 47
1740: PUSH
1741: LD_STRING #tick
1743: PUSH
1744: LD_EXP 2
1748: PUSH
1749: EMPTY
1750: LIST
1751: LIST
1752: ST_TO_ADDR
// end ;
1753: END
// every 0 0$01 trigger timer <= 13 13$00 do
1754: LD_EXP 2
1758: PUSH
1759: LD_INT 27300
1761: LESSEQUAL
1762: IFFALSE 1775
1764: GO 1766
1766: DISABLE
// music_nat := 1 ;
1767: LD_ADDR_OWVAR 71
1771: PUSH
1772: LD_INT 1
1774: ST_TO_ADDR
1775: END
// every 5 5$00 trigger timer > 13 13$00 do
1776: LD_EXP 2
1780: PUSH
1781: LD_INT 27300
1783: GREATER
1784: IFFALSE 1817
1786: GO 1788
1788: DISABLE
// begin enable ;
1789: ENABLE
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1790: LD_ADDR_OWVAR 71
1794: PUSH
1795: LD_INT 1
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 1
1807: PPUSH
1808: LD_INT 2
1810: PPUSH
1811: CALL_OW 12
1815: ARRAY
1816: ST_TO_ADDR
// end ; end_of_file
1817: END
// export global_diff , ru_force , ru_def , am_def , am_force , ar_def , ar_force ; export game_started ; export crates_time , crates_num , crates_allow ; export sikorski , kurin , heike , ron , jack ; export sikorski_come , russian_produce , beria_action , sikorski_veh ; export function InitTriggers ; begin
1818: LD_INT 0
1820: PPUSH
// game_started := false ;
1821: LD_ADDR_EXP 10
1825: PUSH
1826: LD_INT 0
1828: ST_TO_ADDR
// global_diff := [ 1 , 2 , 3 ] ;
1829: LD_ADDR_EXP 3
1833: PUSH
1834: LD_INT 1
1836: PUSH
1837: LD_INT 2
1839: PUSH
1840: LD_INT 3
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: ST_TO_ADDR
// crates_time := [ 0 0$55 , 1 1$15 , 1 1$35 ] [ global_diff ] ;
1848: LD_ADDR_EXP 11
1852: PUSH
1853: LD_INT 1925
1855: PUSH
1856: LD_INT 2625
1858: PUSH
1859: LD_INT 3325
1861: PUSH
1862: EMPTY
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_EXP 3
1871: ARRAY
1872: ST_TO_ADDR
// crates_num := [ 3 , 2 , 1 ] [ global_diff ] ;
1873: LD_ADDR_EXP 12
1877: PUSH
1878: LD_INT 3
1880: PUSH
1881: LD_INT 2
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_EXP 3
1896: ARRAY
1897: ST_TO_ADDR
// crates_allow := false ;
1898: LD_ADDR_EXP 13
1902: PUSH
1903: LD_INT 0
1905: ST_TO_ADDR
// am_def := [ 4 , 3 , 2 ] [ global_diff ] ;
1906: LD_ADDR_EXP 6
1910: PUSH
1911: LD_INT 4
1913: PUSH
1914: LD_INT 3
1916: PUSH
1917: LD_INT 2
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: LIST
1924: PUSH
1925: LD_EXP 3
1929: ARRAY
1930: ST_TO_ADDR
// ru_def := [ 2 , 3 , 4 ] [ global_diff ] ;
1931: LD_ADDR_EXP 5
1935: PUSH
1936: LD_INT 2
1938: PUSH
1939: LD_INT 3
1941: PUSH
1942: LD_INT 4
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: LIST
1949: PUSH
1950: LD_EXP 3
1954: ARRAY
1955: ST_TO_ADDR
// ru_force := [ 12 , 14 , 16 ] [ global_diff ] ;
1956: LD_ADDR_EXP 4
1960: PUSH
1961: LD_INT 12
1963: PUSH
1964: LD_INT 14
1966: PUSH
1967: LD_INT 16
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: LIST
1974: PUSH
1975: LD_EXP 3
1979: ARRAY
1980: ST_TO_ADDR
// ar_def := [ 3 , 4 , 5 ] [ global_diff ] ;
1981: LD_ADDR_EXP 8
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: LD_INT 4
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_EXP 3
2004: ARRAY
2005: ST_TO_ADDR
// ar_force := [ 4 , 5 , 6 ] [ global_diff ] ;
2006: LD_ADDR_EXP 9
2010: PUSH
2011: LD_INT 4
2013: PUSH
2014: LD_INT 5
2016: PUSH
2017: LD_INT 6
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: PUSH
2025: LD_EXP 3
2029: ARRAY
2030: ST_TO_ADDR
// sikorski_come := false ;
2031: LD_ADDR_EXP 19
2035: PUSH
2036: LD_INT 0
2038: ST_TO_ADDR
// russian_produce := false ;
2039: LD_ADDR_EXP 20
2043: PUSH
2044: LD_INT 0
2046: ST_TO_ADDR
// disable ( 99 ) ;
2047: LD_INT 99
2049: DISABLE_MARKED
// end ; end_of_file
2050: LD_VAR 0 1
2054: RET
// export function InitPlayer ; var i , p , un , am , am2 , filter ; begin
2055: LD_INT 0
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
// uc_nation := nation_american ;
2064: LD_ADDR_OWVAR 21
2068: PUSH
2069: LD_INT 1
2071: ST_TO_ADDR
// am := 1 ;
2072: LD_ADDR_VAR 0 5
2076: PUSH
2077: LD_INT 1
2079: ST_TO_ADDR
// am2 := 4 ;
2080: LD_ADDR_VAR 0 6
2084: PUSH
2085: LD_INT 4
2087: ST_TO_ADDR
// filter := [ ] ;
2088: LD_ADDR_VAR 0 7
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// SetSide ( omikron , am2 ) ;
2095: LD_INT 64
2097: PPUSH
2098: LD_VAR 0 6
2102: PPUSH
2103: CALL_OW 235
// SetBName ( omikron , omikron ) ;
2107: LD_INT 64
2109: PPUSH
2110: LD_STRING omikron
2112: PPUSH
2113: CALL_OW 500
// ResetFog ;
2117: CALL_OW 335
// uc_side := am2 ;
2121: LD_ADDR_OWVAR 20
2125: PUSH
2126: LD_VAR 0 6
2130: ST_TO_ADDR
// for i = 1 to 4 do
2131: LD_ADDR_VAR 0 2
2135: PUSH
2136: DOUBLE
2137: LD_INT 1
2139: DEC
2140: ST_TO_ADDR
2141: LD_INT 4
2143: PUSH
2144: FOR_TO
2145: IFFALSE 2267
// for p = 1 to 2 do
2147: LD_ADDR_VAR 0 3
2151: PUSH
2152: DOUBLE
2153: LD_INT 1
2155: DEC
2156: ST_TO_ADDR
2157: LD_INT 2
2159: PUSH
2160: FOR_TO
2161: IFFALSE 2263
// begin un := CreateHumanWithClass ( i , am_def ) ;
2163: LD_ADDR_VAR 0 4
2167: PUSH
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_EXP 6
2177: PPUSH
2178: CALL 418 0 2
2182: ST_TO_ADDR
// PlaceUnitArea ( un , am_area , false ) ;
2183: LD_VAR 0 4
2187: PPUSH
2188: LD_INT 3
2190: PPUSH
2191: LD_INT 0
2193: PPUSH
2194: CALL_OW 49
// if GetClass ( un ) = 1 then
2198: LD_VAR 0 4
2202: PPUSH
2203: CALL_OW 257
2207: PUSH
2208: LD_INT 1
2210: EQUAL
2211: IFFALSE 2261
// ComEnterUnit ( un , ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) diff us_spec_b ) [ p ] ) ;
2213: LD_VAR 0 4
2217: PPUSH
2218: LD_INT 22
2220: PUSH
2221: LD_INT 4
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: PUSH
2228: LD_INT 30
2230: PUSH
2231: LD_INT 31
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: PPUSH
2242: CALL_OW 69
2246: PUSH
2247: LD_INT 140
2249: DIFF
2250: PUSH
2251: LD_VAR 0 3
2255: ARRAY
2256: PPUSH
2257: CALL_OW 120
// end ;
2261: GO 2160
2263: POP
2264: POP
2265: GO 2144
2267: POP
2268: POP
// if IsPlaced ( us_spec_b ) then
2269: LD_INT 140
2271: PPUSH
2272: CALL_OW 305
2276: IFFALSE 2340
// begin un := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) [ 1 ] ;
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: LD_INT 22
2285: PUSH
2286: LD_INT 4
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 25
2295: PUSH
2296: LD_INT 3
2298: PUSH
2299: EMPTY
2300: LIST
2301: LIST
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: LD_INT 1
2314: ARRAY
2315: ST_TO_ADDR
// SetClass ( un , 1 ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 1
2323: PPUSH
2324: CALL_OW 336
// ComEnterUnit ( un , us_spec_b ) ;
2328: LD_VAR 0 4
2332: PPUSH
2333: LD_INT 140
2335: PPUSH
2336: CALL_OW 120
// end ; vc_chassis := us_medium_wheeled ;
2340: LD_ADDR_OWVAR 37
2344: PUSH
2345: LD_INT 2
2347: ST_TO_ADDR
// vc_engine := engine_solar ;
2348: LD_ADDR_OWVAR 39
2352: PUSH
2353: LD_INT 2
2355: ST_TO_ADDR
// vc_control := control_manual ;
2356: LD_ADDR_OWVAR 38
2360: PUSH
2361: LD_INT 1
2363: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_double_gun , us_gatling_gun ] [ global_diff ] ;
2364: LD_ADDR_OWVAR 40
2368: PUSH
2369: LD_INT 5
2371: PUSH
2372: LD_INT 5
2374: PUSH
2375: LD_INT 4
2377: PUSH
2378: EMPTY
2379: LIST
2380: LIST
2381: LIST
2382: PUSH
2383: LD_EXP 3
2387: ARRAY
2388: ST_TO_ADDR
// un := CreateVehicle ;
2389: LD_ADDR_VAR 0 4
2393: PUSH
2394: CALL_OW 45
2398: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2399: LD_VAR 0 4
2403: PPUSH
2404: LD_INT 4
2406: PPUSH
2407: CALL_OW 233
// PlaceUnitXY ( un , 12 , 17 , false ) ;
2411: LD_VAR 0 4
2415: PPUSH
2416: LD_INT 12
2418: PPUSH
2419: LD_INT 17
2421: PPUSH
2422: LD_INT 0
2424: PPUSH
2425: CALL_OW 48
// vc_chassis := us_light_wheeled ;
2429: LD_ADDR_OWVAR 37
2433: PUSH
2434: LD_INT 1
2436: ST_TO_ADDR
// vc_engine := engine_combustion ;
2437: LD_ADDR_OWVAR 39
2441: PUSH
2442: LD_INT 1
2444: ST_TO_ADDR
// vc_control := control_manual ;
2445: LD_ADDR_OWVAR 38
2449: PUSH
2450: LD_INT 1
2452: ST_TO_ADDR
// vc_weapon := us_light_gun ;
2453: LD_ADDR_OWVAR 40
2457: PUSH
2458: LD_INT 3
2460: ST_TO_ADDR
// un := CreateVehicle ;
2461: LD_ADDR_VAR 0 4
2465: PUSH
2466: CALL_OW 45
2470: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2471: LD_VAR 0 4
2475: PPUSH
2476: LD_INT 4
2478: PPUSH
2479: CALL_OW 233
// PlaceUnitXY ( un , 19 , 19 , false ) ;
2483: LD_VAR 0 4
2487: PPUSH
2488: LD_INT 19
2490: PPUSH
2491: LD_INT 19
2493: PPUSH
2494: LD_INT 0
2496: PPUSH
2497: CALL_OW 48
// uc_side := am ;
2501: LD_ADDR_OWVAR 20
2505: PUSH
2506: LD_VAR 0 5
2510: ST_TO_ADDR
// hc_importance := 100 ;
2511: LD_ADDR_OWVAR 32
2515: PUSH
2516: LD_INT 100
2518: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
2519: LD_ADDR_OWVAR 26
2523: PUSH
2524: LD_STRING Jeremy Sikorski
2526: ST_TO_ADDR
// hc_gallery := us ;
2527: LD_ADDR_OWVAR 33
2531: PUSH
2532: LD_STRING us
2534: ST_TO_ADDR
// hc_face_number := 19 ;
2535: LD_ADDR_OWVAR 34
2539: PUSH
2540: LD_INT 19
2542: ST_TO_ADDR
// hc_skills := [ Rand ( am_def + 2 , am_def + 4 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) ] ;
2543: LD_ADDR_OWVAR 31
2547: PUSH
2548: LD_EXP 6
2552: PUSH
2553: LD_INT 2
2555: PLUS
2556: PPUSH
2557: LD_EXP 6
2561: PUSH
2562: LD_INT 4
2564: PLUS
2565: PPUSH
2566: CALL_OW 12
2570: PUSH
2571: LD_EXP 6
2575: PUSH
2576: LD_INT 1
2578: MINUS
2579: PPUSH
2580: LD_EXP 6
2584: PUSH
2585: LD_INT 1
2587: PLUS
2588: PPUSH
2589: CALL_OW 12
2593: PUSH
2594: LD_EXP 6
2598: PUSH
2599: LD_INT 1
2601: MINUS
2602: PPUSH
2603: LD_EXP 6
2607: PUSH
2608: LD_INT 1
2610: PLUS
2611: PPUSH
2612: CALL_OW 12
2616: PUSH
2617: LD_EXP 6
2621: PUSH
2622: LD_INT 1
2624: MINUS
2625: PPUSH
2626: LD_EXP 6
2630: PUSH
2631: LD_INT 1
2633: PLUS
2634: PPUSH
2635: CALL_OW 12
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: ST_TO_ADDR
// hc_sex := sex_male ;
2646: LD_ADDR_OWVAR 27
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// hc_class := 1 ;
2654: LD_ADDR_OWVAR 28
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2662: LD_ADDR_OWVAR 29
2666: PUSH
2667: LD_INT 10
2669: PUSH
2670: LD_INT 12
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: ST_TO_ADDR
// sikorski := CreateHuman ;
2677: LD_ADDR_EXP 14
2681: PUSH
2682: CALL_OW 44
2686: ST_TO_ADDR
// if global_diff > 1 then
2687: LD_EXP 3
2691: PUSH
2692: LD_INT 1
2694: GREATER
2695: IFFALSE 2714
// PlaceUnitArea ( sikorski , sikorski_area , false ) else
2697: LD_EXP 14
2701: PPUSH
2702: LD_INT 8
2704: PPUSH
2705: LD_INT 0
2707: PPUSH
2708: CALL_OW 49
2712: GO 2805
// begin vc_chassis := us_light_wheeled ;
2714: LD_ADDR_OWVAR 37
2718: PUSH
2719: LD_INT 1
2721: ST_TO_ADDR
// vc_engine := engine_combustion ;
2722: LD_ADDR_OWVAR 39
2726: PUSH
2727: LD_INT 1
2729: ST_TO_ADDR
// vc_control := control_manual ;
2730: LD_ADDR_OWVAR 38
2734: PUSH
2735: LD_INT 1
2737: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
2738: LD_ADDR_OWVAR 40
2742: PUSH
2743: LD_INT 2
2745: ST_TO_ADDR
// vc_fuel_battery := 21 ;
2746: LD_ADDR_OWVAR 41
2750: PUSH
2751: LD_INT 21
2753: ST_TO_ADDR
// sikorski_veh := CreateVehicle ;
2754: LD_ADDR_EXP 22
2758: PUSH
2759: CALL_OW 45
2763: ST_TO_ADDR
// SetDir ( sikorski_veh , 0 ) ;
2764: LD_EXP 22
2768: PPUSH
2769: LD_INT 0
2771: PPUSH
2772: CALL_OW 233
// PlaceUnitArea ( sikorski_veh , sikorski_area , false ) ;
2776: LD_EXP 22
2780: PPUSH
2781: LD_INT 8
2783: PPUSH
2784: LD_INT 0
2786: PPUSH
2787: CALL_OW 49
// PlaceHumanInUnit ( sikorski , sikorski_veh ) ;
2791: LD_EXP 14
2795: PPUSH
2796: LD_EXP 22
2800: PPUSH
2801: CALL_OW 52
// end ; hc_importance := 0 ;
2805: LD_ADDR_OWVAR 32
2809: PUSH
2810: LD_INT 0
2812: ST_TO_ADDR
// hc_name := Ronn Harisson ;
2813: LD_ADDR_OWVAR 26
2817: PUSH
2818: LD_STRING Ronn Harisson
2820: ST_TO_ADDR
// hc_gallery := us ;
2821: LD_ADDR_OWVAR 33
2825: PUSH
2826: LD_STRING us
2828: ST_TO_ADDR
// hc_face_number := 6 ;
2829: LD_ADDR_OWVAR 34
2833: PUSH
2834: LD_INT 6
2836: ST_TO_ADDR
// ron := CreateHuman ;
2837: LD_ADDR_EXP 17
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// hc_name := Jack Dickens ;
2847: LD_ADDR_OWVAR 26
2851: PUSH
2852: LD_STRING Jack Dickens
2854: ST_TO_ADDR
// hc_gallery :=  ;
2855: LD_ADDR_OWVAR 33
2859: PUSH
2860: LD_STRING 
2862: ST_TO_ADDR
// jack := CreateHuman ;
2863: LD_ADDR_EXP 18
2867: PUSH
2868: CALL_OW 44
2872: ST_TO_ADDR
// end ;
2873: LD_VAR 0 1
2877: RET
// every 0 0$01 trigger GetDistUnits ( sikorski , omikron ) <= 45 do
2878: LD_EXP 14
2882: PPUSH
2883: LD_INT 64
2885: PPUSH
2886: CALL_OW 296
2890: PUSH
2891: LD_INT 45
2893: LESSEQUAL
2894: IFFALSE 2944
2896: GO 2898
2898: DISABLE
// ComBuild ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) , b_workshop , 16 , 5 , 3 ) ; end_of_file
2899: LD_INT 22
2901: PUSH
2902: LD_INT 4
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: LD_INT 25
2911: PUSH
2912: LD_INT 2
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PPUSH
2923: CALL_OW 69
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_INT 16
2933: PPUSH
2934: LD_INT 5
2936: PPUSH
2937: LD_INT 3
2939: PPUSH
2940: CALL_OW 145
2944: END
// export ru_sold , ru_stw , ru_tw , ru_tech , ru_veh , ru_eng , ru_mech , ru_sci , ru_bul , ru_b ; export ru2_sold , ru2_stw , ru2_tw , ru2_tech , ru2_veh , ru2_eng , ru2_mech , ru2_sci , ru2_bul , ru2_b ; export ru_list_attackers ; export ru_radar ; export function InitRussian ; var ru , ru2 , i , un , filter ; begin
2945: LD_INT 0
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
// ru := 6 ;
2953: LD_ADDR_VAR 0 2
2957: PUSH
2958: LD_INT 6
2960: ST_TO_ADDR
// ru2 := 3 ;
2961: LD_ADDR_VAR 0 3
2965: PUSH
2966: LD_INT 3
2968: ST_TO_ADDR
// uc_nation := nation_russian ;
2969: LD_ADDR_OWVAR 21
2973: PUSH
2974: LD_INT 3
2976: ST_TO_ADDR
// ru_radar := 98 ;
2977: LD_ADDR_EXP 44
2981: PUSH
2982: LD_INT 98
2984: ST_TO_ADDR
// ru_list_attackers := [ ] ;
2985: LD_ADDR_EXP 43
2989: PUSH
2990: EMPTY
2991: ST_TO_ADDR
// uc_side := ru ;
2992: LD_ADDR_OWVAR 20
2996: PUSH
2997: LD_VAR 0 2
3001: ST_TO_ADDR
// ru_sold := [ ] ;
3002: LD_ADDR_EXP 23
3006: PUSH
3007: EMPTY
3008: ST_TO_ADDR
// ru_stw := [ ] ;
3009: LD_ADDR_EXP 24
3013: PUSH
3014: EMPTY
3015: ST_TO_ADDR
// ru_tw := [ ] ;
3016: LD_ADDR_EXP 25
3020: PUSH
3021: EMPTY
3022: ST_TO_ADDR
// ru_b := [ ] ;
3023: LD_ADDR_EXP 32
3027: PUSH
3028: EMPTY
3029: ST_TO_ADDR
// ru_eng := [ ] ;
3030: LD_ADDR_EXP 28
3034: PUSH
3035: EMPTY
3036: ST_TO_ADDR
// ru_mech := [ ] ;
3037: LD_ADDR_EXP 29
3041: PUSH
3042: EMPTY
3043: ST_TO_ADDR
// ru_sci := [ ] ;
3044: LD_ADDR_EXP 30
3048: PUSH
3049: EMPTY
3050: ST_TO_ADDR
// ru_bul := [ b_bunker , 162 , 101 , 0 , b_ext_rocket , 149 , 86 , 4 ] ;
3051: LD_ADDR_EXP 31
3055: PUSH
3056: LD_INT 32
3058: PUSH
3059: LD_INT 162
3061: PUSH
3062: LD_INT 101
3064: PUSH
3065: LD_INT 0
3067: PUSH
3068: LD_INT 18
3070: PUSH
3071: LD_INT 149
3073: PUSH
3074: LD_INT 86
3076: PUSH
3077: LD_INT 4
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: ST_TO_ADDR
// ru_tech := [ tech_tech1 , tech_tech2 , tech_tech3 , tech_oilpow , tech_oileng , tech_weap1 , tech_weap2 , tech_gatling , tech_advmet , tech_weap3 ] ;
3090: LD_ADDR_EXP 26
3094: PUSH
3095: LD_INT 48
3097: PUSH
3098: LD_INT 49
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: LD_INT 46
3106: PUSH
3107: LD_INT 47
3109: PUSH
3110: LD_INT 51
3112: PUSH
3113: LD_INT 52
3115: PUSH
3116: LD_INT 69
3118: PUSH
3119: LD_INT 34
3121: PUSH
3122: LD_INT 53
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: LIST
3136: ST_TO_ADDR
// ru_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3137: LD_ADDR_EXP 27
3141: PUSH
3142: LD_INT 21
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 1
3150: PUSH
3151: LD_INT 51
3153: PUSH
3154: LD_INT 22
3156: PUSH
3157: LD_INT 1
3159: PUSH
3160: LD_INT 1
3162: PUSH
3163: LD_INT 52
3165: PUSH
3166: LD_INT 22
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: LD_INT 1
3174: PUSH
3175: LD_INT 52
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: LIST
3190: LIST
3191: ST_TO_ADDR
// SetBName ( kirov , kirov ) ;
3192: LD_INT 71
3194: PPUSH
3195: LD_STRING kirov
3197: PPUSH
3198: CALL_OW 500
// hc_gallery := ru ;
3202: LD_ADDR_OWVAR 33
3206: PUSH
3207: LD_STRING ru
3209: ST_TO_ADDR
// hc_face_number := 8 ;
3210: LD_ADDR_OWVAR 34
3214: PUSH
3215: LD_INT 8
3217: ST_TO_ADDR
// hc_skills := [ 7 , 4 , 3 , 2 ] ;
3218: LD_ADDR_OWVAR 31
3222: PUSH
3223: LD_INT 7
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 2
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: ST_TO_ADDR
// hc_sex := sex_male ;
3241: LD_ADDR_OWVAR 27
3245: PUSH
3246: LD_INT 1
3248: ST_TO_ADDR
// hc_name := Ivan Kurin ;
3249: LD_ADDR_OWVAR 26
3253: PUSH
3254: LD_STRING Ivan Kurin
3256: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3257: LD_ADDR_OWVAR 29
3261: PUSH
3262: LD_INT 10
3264: PUSH
3265: LD_INT 10
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: ST_TO_ADDR
// kurin := CreateHuman ;
3272: LD_ADDR_EXP 15
3276: PUSH
3277: CALL_OW 44
3281: ST_TO_ADDR
// PlaceHumanInUnit ( kurin , kirov ) ;
3282: LD_EXP 15
3286: PPUSH
3287: LD_INT 71
3289: PPUSH
3290: CALL_OW 52
// filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_bunker ] ] ) ;
3294: LD_ADDR_VAR 0 6
3298: PUSH
3299: LD_INT 22
3301: PUSH
3302: LD_INT 6
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: LD_INT 30
3311: PUSH
3312: LD_INT 32
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 69
3327: ST_TO_ADDR
// for i = 1 to ru_force do
3328: LD_ADDR_VAR 0 4
3332: PUSH
3333: DOUBLE
3334: LD_INT 1
3336: DEC
3337: ST_TO_ADDR
3338: LD_EXP 4
3342: PUSH
3343: FOR_TO
3344: IFFALSE 3415
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3346: LD_ADDR_VAR 0 5
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_EXP 5
3358: PPUSH
3359: CALL 418 0 2
3363: ST_TO_ADDR
// if i <= filter then
3364: LD_VAR 0 4
3368: PUSH
3369: LD_VAR 0 6
3373: LESSEQUAL
3374: IFFALSE 3398
// PlaceHumanInUnit ( un , filter [ i ] ) else
3376: LD_VAR 0 5
3380: PPUSH
3381: LD_VAR 0 6
3385: PUSH
3386: LD_VAR 0 4
3390: ARRAY
3391: PPUSH
3392: CALL_OW 52
3396: GO 3413
// PlaceUnitArea ( un , ru_area , false ) ;
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_INT 4
3405: PPUSH
3406: LD_INT 0
3408: PPUSH
3409: CALL_OW 49
// end ;
3413: GO 3343
3415: POP
3416: POP
// for i = 1 to 6 do
3417: LD_ADDR_VAR 0 4
3421: PUSH
3422: DOUBLE
3423: LD_INT 1
3425: DEC
3426: ST_TO_ADDR
3427: LD_INT 6
3429: PUSH
3430: FOR_TO
3431: IFFALSE 3468
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
3433: LD_ADDR_VAR 0 5
3437: PUSH
3438: LD_INT 3
3440: PPUSH
3441: LD_EXP 5
3445: PPUSH
3446: CALL 418 0 2
3450: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3451: LD_VAR 0 5
3455: PPUSH
3456: LD_INT 4
3458: PPUSH
3459: LD_INT 0
3461: PPUSH
3462: CALL_OW 49
// end ;
3466: GO 3430
3468: POP
3469: POP
// for i = 1 to 3 do
3470: LD_ADDR_VAR 0 4
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 3
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3521
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
3486: LD_ADDR_VAR 0 5
3490: PUSH
3491: LD_INT 4
3493: PPUSH
3494: LD_EXP 5
3498: PPUSH
3499: CALL 418 0 2
3503: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3504: LD_VAR 0 5
3508: PPUSH
3509: LD_INT 4
3511: PPUSH
3512: LD_INT 0
3514: PPUSH
3515: CALL_OW 49
// end ;
3519: GO 3483
3521: POP
3522: POP
// for i = 1 to 4 do
3523: LD_ADDR_VAR 0 4
3527: PUSH
3528: DOUBLE
3529: LD_INT 1
3531: DEC
3532: ST_TO_ADDR
3533: LD_INT 4
3535: PUSH
3536: FOR_TO
3537: IFFALSE 3574
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
3539: LD_ADDR_VAR 0 5
3543: PUSH
3544: LD_INT 2
3546: PPUSH
3547: LD_EXP 5
3551: PPUSH
3552: CALL 418 0 2
3556: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3557: LD_VAR 0 5
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_INT 0
3567: PPUSH
3568: CALL_OW 49
// end ;
3572: GO 3536
3574: POP
3575: POP
// uc_side := ru2 ;
3576: LD_ADDR_OWVAR 20
3580: PUSH
3581: LD_VAR 0 3
3585: ST_TO_ADDR
// ru2_sold := [ ] ;
3586: LD_ADDR_EXP 33
3590: PUSH
3591: EMPTY
3592: ST_TO_ADDR
// ru2_stw := [ ] ;
3593: LD_ADDR_EXP 34
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// ru2_tw := [ ] ;
3600: LD_ADDR_EXP 35
3604: PUSH
3605: EMPTY
3606: ST_TO_ADDR
// ru2_b := [ ] ;
3607: LD_ADDR_EXP 42
3611: PUSH
3612: EMPTY
3613: ST_TO_ADDR
// ru2_eng := [ ] ;
3614: LD_ADDR_EXP 38
3618: PUSH
3619: EMPTY
3620: ST_TO_ADDR
// ru2_mech := [ ] ;
3621: LD_ADDR_EXP 39
3625: PUSH
3626: EMPTY
3627: ST_TO_ADDR
// ru2_sci := [ ] ;
3628: LD_ADDR_EXP 40
3632: PUSH
3633: EMPTY
3634: ST_TO_ADDR
// ru2_bul := [ b_lab , 90 , 71 , 1 , b_armoury , 88 , 58 , 2 , b_workshop , 103 , 66 , 4 , b_oil_power , 106 , 77 , 3 , b_oil_power , 110 , 77 , 3 , b_bunker , 109 , 65 , 4 , b_bunker , 92 , 85 , 0 , b_bunker , 74 , 72 , 0 , b_bunker , 71 , 66 , 2 , b_bunker , 115 , 79 , 4 , b_bunker , 112 , 69 , 4 , b_bunker , 111 , 84 , 5 ] ;
3635: LD_ADDR_EXP 41
3639: PUSH
3640: LD_INT 6
3642: PUSH
3643: LD_INT 90
3645: PUSH
3646: LD_INT 71
3648: PUSH
3649: LD_INT 1
3651: PUSH
3652: LD_INT 4
3654: PUSH
3655: LD_INT 88
3657: PUSH
3658: LD_INT 58
3660: PUSH
3661: LD_INT 2
3663: PUSH
3664: LD_INT 2
3666: PUSH
3667: LD_INT 103
3669: PUSH
3670: LD_INT 66
3672: PUSH
3673: LD_INT 4
3675: PUSH
3676: LD_INT 26
3678: PUSH
3679: LD_INT 106
3681: PUSH
3682: LD_INT 77
3684: PUSH
3685: LD_INT 3
3687: PUSH
3688: LD_INT 26
3690: PUSH
3691: LD_INT 110
3693: PUSH
3694: LD_INT 77
3696: PUSH
3697: LD_INT 3
3699: PUSH
3700: LD_INT 32
3702: PUSH
3703: LD_INT 109
3705: PUSH
3706: LD_INT 65
3708: PUSH
3709: LD_INT 4
3711: PUSH
3712: LD_INT 32
3714: PUSH
3715: LD_INT 92
3717: PUSH
3718: LD_INT 85
3720: PUSH
3721: LD_INT 0
3723: PUSH
3724: LD_INT 32
3726: PUSH
3727: LD_INT 74
3729: PUSH
3730: LD_INT 72
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 32
3738: PUSH
3739: LD_INT 71
3741: PUSH
3742: LD_INT 66
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: LD_INT 32
3750: PUSH
3751: LD_INT 115
3753: PUSH
3754: LD_INT 79
3756: PUSH
3757: LD_INT 4
3759: PUSH
3760: LD_INT 32
3762: PUSH
3763: LD_INT 112
3765: PUSH
3766: LD_INT 69
3768: PUSH
3769: LD_INT 4
3771: PUSH
3772: LD_INT 32
3774: PUSH
3775: LD_INT 111
3777: PUSH
3778: LD_INT 84
3780: PUSH
3781: LD_INT 5
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: ST_TO_ADDR
// ru2_tech := [ tech_tech1 , tech_tech2 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_advmet , tech_weap3 , tech_tech3 ] ;
3834: LD_ADDR_EXP 36
3838: PUSH
3839: LD_INT 48
3841: PUSH
3842: LD_INT 49
3844: PUSH
3845: LD_INT 51
3847: PUSH
3848: LD_INT 52
3850: PUSH
3851: LD_INT 69
3853: PUSH
3854: LD_INT 39
3856: PUSH
3857: LD_INT 34
3859: PUSH
3860: LD_INT 53
3862: PUSH
3863: LD_INT 50
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: ST_TO_ADDR
// ru2_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3877: LD_ADDR_EXP 37
3881: PUSH
3882: LD_INT 21
3884: PUSH
3885: LD_INT 1
3887: PUSH
3888: LD_INT 1
3890: PUSH
3891: LD_INT 51
3893: PUSH
3894: LD_INT 22
3896: PUSH
3897: LD_INT 1
3899: PUSH
3900: LD_INT 1
3902: PUSH
3903: LD_INT 52
3905: PUSH
3906: LD_INT 22
3908: PUSH
3909: LD_INT 1
3911: PUSH
3912: LD_INT 1
3914: PUSH
3915: LD_INT 52
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: ST_TO_ADDR
// SetBName ( beria , beria ) ;
3932: LD_INT 106
3934: PPUSH
3935: LD_STRING beria
3937: PPUSH
3938: CALL_OW 500
// SetBName ( kagan , kagan ) ;
3942: LD_INT 112
3944: PPUSH
3945: LD_STRING kagan
3947: PPUSH
3948: CALL_OW 500
// for i = 1 to 12 do
3952: LD_ADDR_VAR 0 4
3956: PUSH
3957: DOUBLE
3958: LD_INT 1
3960: DEC
3961: ST_TO_ADDR
3962: LD_INT 12
3964: PUSH
3965: FOR_TO
3966: IFFALSE 4003
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_INT 1
3975: PPUSH
3976: LD_EXP 5
3980: PPUSH
3981: CALL 418 0 2
3985: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3986: LD_VAR 0 5
3990: PPUSH
3991: LD_INT 9
3993: PPUSH
3994: LD_INT 0
3996: PPUSH
3997: CALL_OW 49
// end ;
4001: GO 3965
4003: POP
4004: POP
// for i = 1 to 6 do
4005: LD_ADDR_VAR 0 4
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 6
4017: PUSH
4018: FOR_TO
4019: IFFALSE 4056
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
4021: LD_ADDR_VAR 0 5
4025: PUSH
4026: LD_INT 3
4028: PPUSH
4029: LD_EXP 5
4033: PPUSH
4034: CALL 418 0 2
4038: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4039: LD_VAR 0 5
4043: PPUSH
4044: LD_INT 9
4046: PPUSH
4047: LD_INT 0
4049: PPUSH
4050: CALL_OW 49
// end ;
4054: GO 4018
4056: POP
4057: POP
// for i = 1 to 4 do
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: DOUBLE
4064: LD_INT 1
4066: DEC
4067: ST_TO_ADDR
4068: LD_INT 4
4070: PUSH
4071: FOR_TO
4072: IFFALSE 4109
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
4074: LD_ADDR_VAR 0 5
4078: PUSH
4079: LD_INT 4
4081: PPUSH
4082: LD_EXP 5
4086: PPUSH
4087: CALL 418 0 2
4091: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4092: LD_VAR 0 5
4096: PPUSH
4097: LD_INT 9
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 49
// end ;
4107: GO 4071
4109: POP
4110: POP
// for i = 1 to 4 do
4111: LD_ADDR_VAR 0 4
4115: PUSH
4116: DOUBLE
4117: LD_INT 1
4119: DEC
4120: ST_TO_ADDR
4121: LD_INT 4
4123: PUSH
4124: FOR_TO
4125: IFFALSE 4162
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
4127: LD_ADDR_VAR 0 5
4131: PUSH
4132: LD_INT 2
4134: PPUSH
4135: LD_EXP 5
4139: PPUSH
4140: CALL 418 0 2
4144: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4145: LD_VAR 0 5
4149: PPUSH
4150: LD_INT 9
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 49
// end ;
4160: GO 4124
4162: POP
4163: POP
// end ;
4164: LD_VAR 0 1
4168: RET
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , enemy_detected ;
4169: GO 4171
4171: DISABLE
4172: LD_INT 0
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
// begin enable ;
4184: ENABLE
// ru_sold := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) diff Kurin ;
4185: LD_ADDR_EXP 23
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 6
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 25
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 24
4212: PUSH
4213: LD_INT 600
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: PPUSH
4228: CALL_OW 69
4232: PUSH
4233: LD_EXP 15
4237: DIFF
4238: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
4239: LD_ADDR_EXP 28
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_INT 6
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: LD_INT 25
4256: PUSH
4257: LD_INT 2
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 24
4266: PUSH
4267: LD_INT 600
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: PPUSH
4282: CALL_OW 69
4286: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
4287: LD_ADDR_EXP 29
4291: PUSH
4292: LD_INT 22
4294: PUSH
4295: LD_INT 6
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 25
4304: PUSH
4305: LD_INT 3
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 24
4314: PUSH
4315: LD_INT 600
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: PUSH
4327: EMPTY
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
4335: LD_ADDR_EXP 30
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 6
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 4
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 24
4362: PUSH
4363: LD_INT 600
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: EMPTY
4376: LIST
4377: PPUSH
4378: CALL_OW 69
4382: ST_TO_ADDR
// ru_tw := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
4383: LD_ADDR_EXP 25
4387: PUSH
4388: LD_INT 22
4390: PUSH
4391: LD_INT 6
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: LD_INT 30
4403: PUSH
4404: LD_INT 31
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PUSH
4411: LD_INT 30
4413: PUSH
4414: LD_INT 32
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 24
4428: PUSH
4429: LD_INT 250
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: PPUSH
4444: CALL_OW 69
4448: ST_TO_ADDR
// ru_b := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) ;
4449: LD_ADDR_EXP 32
4453: PUSH
4454: LD_INT 22
4456: PUSH
4457: LD_INT 6
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 21
4466: PUSH
4467: LD_INT 3
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PPUSH
4478: CALL_OW 69
4482: ST_TO_ADDR
// b_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4483: LD_ADDR_VAR 0 6
4487: PUSH
4488: LD_INT 22
4490: PUSH
4491: LD_INT 6
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 21
4500: PUSH
4501: LD_INT 3
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: LD_INT 24
4513: PUSH
4514: LD_INT 1000
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: LIST
4529: PUSH
4530: EMPTY
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
4538: LD_ADDR_VAR 0 5
4542: PUSH
4543: LD_INT 22
4545: PUSH
4546: LD_INT 6
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 21
4555: PUSH
4556: LD_INT 1
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 3
4565: PUSH
4566: LD_INT 24
4568: PUSH
4569: LD_INT 600
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: PUSH
4585: EMPTY
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// b_weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
4593: LD_ADDR_VAR 0 8
4597: PUSH
4598: LD_INT 92
4600: PPUSH
4601: CALL_OW 478
4605: PUSH
4606: LD_INT 52
4608: PUSH
4609: LD_INT 51
4611: PUSH
4612: LD_INT 53
4614: PUSH
4615: LD_EXP 44
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: DIFF
4626: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_breastwork , b_workshop ] ;
4627: LD_ADDR_VAR 0 9
4631: PUSH
4632: LD_INT 0
4634: PUSH
4635: LD_INT 4
4637: PUSH
4638: LD_INT 31
4640: PUSH
4641: LD_INT 2
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: ST_TO_ADDR
// if FilterUnitsInArea ( kirov_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) > 0 then
4650: LD_INT 10
4652: PPUSH
4653: LD_INT 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 1
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 22
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: LIST
4680: PPUSH
4681: CALL_OW 70
4685: PUSH
4686: LD_INT 0
4688: GREATER
4689: IFFALSE 4701
// enemy_detected := true else
4691: LD_ADDR_VAR 0 10
4695: PUSH
4696: LD_INT 1
4698: ST_TO_ADDR
4699: GO 4709
// enemy_detected := false ;
4701: LD_ADDR_VAR 0 10
4705: PUSH
4706: LD_INT 0
4708: ST_TO_ADDR
// if enemy_detected = false then
4709: LD_VAR 0 10
4713: PUSH
4714: LD_INT 0
4716: EQUAL
4717: IFFALSE 4779
// for i = 1 to ru_b do
4719: LD_ADDR_VAR 0 1
4723: PUSH
4724: DOUBLE
4725: LD_INT 1
4727: DEC
4728: ST_TO_ADDR
4729: LD_EXP 32
4733: PUSH
4734: FOR_TO
4735: IFFALSE 4777
// if GetBType ( ru_b [ i ] ) in b_upgrade then
4737: LD_EXP 32
4741: PUSH
4742: LD_VAR 0 1
4746: ARRAY
4747: PPUSH
4748: CALL_OW 266
4752: PUSH
4753: LD_VAR 0 9
4757: IN
4758: IFFALSE 4775
// ComUpgrade ( ru_b [ i ] ) ;
4760: LD_EXP 32
4764: PUSH
4765: LD_VAR 0 1
4769: ARRAY
4770: PPUSH
4771: CALL_OW 146
4775: GO 4734
4777: POP
4778: POP
// if ru_sold > 0 then
4779: LD_EXP 23
4783: PUSH
4784: LD_INT 0
4786: GREATER
4787: IFFALSE 5201
// begin filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4789: LD_ADDR_VAR 0 4
4793: PUSH
4794: LD_EXP 23
4798: PPUSH
4799: LD_INT 3
4801: PUSH
4802: LD_INT 54
4804: PUSH
4805: EMPTY
4806: LIST
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PPUSH
4812: CALL_OW 72
4816: ST_TO_ADDR
// if UnitFilter ( ru_tw , [ f_empty ] ) > 0 then
4817: LD_EXP 25
4821: PPUSH
4822: LD_INT 58
4824: PUSH
4825: EMPTY
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: PUSH
4833: LD_INT 0
4835: GREATER
4836: IFFALSE 4904
// begin if filter = 0 then
4838: LD_VAR 0 4
4842: PUSH
4843: LD_INT 0
4845: EQUAL
4846: IFFALSE 4871
// ComExitBuilding ( ru_sold [ Rand ( 1 , ru_sold ) ] ) ;
4848: LD_EXP 23
4852: PUSH
4853: LD_INT 1
4855: PPUSH
4856: LD_EXP 23
4860: PPUSH
4861: CALL_OW 12
4865: ARRAY
4866: PPUSH
4867: CALL_OW 122
// ComEnterUnit ( filter [ 1 ] , UnitFilter ( ru_tw , [ f_empty ] ) [ 1 ] ) ;
4871: LD_VAR 0 4
4875: PUSH
4876: LD_INT 1
4878: ARRAY
4879: PPUSH
4880: LD_EXP 25
4884: PPUSH
4885: LD_INT 58
4887: PUSH
4888: EMPTY
4889: LIST
4890: PPUSH
4891: CALL_OW 72
4895: PUSH
4896: LD_INT 1
4898: ARRAY
4899: PPUSH
4900: CALL_OW 120
// end ; if UnitFilter ( ru_tw , [ f_empty ] ) = 0 then
4904: LD_EXP 25
4908: PPUSH
4909: LD_INT 58
4911: PUSH
4912: EMPTY
4913: LIST
4914: PPUSH
4915: CALL_OW 72
4919: PUSH
4920: LD_INT 0
4922: EQUAL
4923: IFFALSE 5078
// begin b_unit := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4925: LD_ADDR_VAR 0 7
4929: PUSH
4930: LD_INT 22
4932: PUSH
4933: LD_INT 6
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: LD_INT 2
4942: PUSH
4943: LD_INT 30
4945: PUSH
4946: LD_INT 4
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PUSH
4953: LD_INT 30
4955: PUSH
4956: LD_INT 5
4958: PUSH
4959: EMPTY
4960: LIST
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PPUSH
4972: CALL_OW 69
4976: ST_TO_ADDR
// if b_unit > 0 then
4977: LD_VAR 0 7
4981: PUSH
4982: LD_INT 0
4984: GREATER
4985: IFFALSE 5078
// for p = 1 to b_unit do
4987: LD_ADDR_VAR 0 2
4991: PUSH
4992: DOUBLE
4993: LD_INT 1
4995: DEC
4996: ST_TO_ADDR
4997: LD_VAR 0 7
5001: PUSH
5002: FOR_TO
5003: IFFALSE 5076
// if UnitsInSide ( b_unit [ p ] ) < 6 then
5005: LD_VAR 0 7
5009: PUSH
5010: LD_VAR 0 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 313
5020: PUSH
5021: LD_INT 6
5023: LESS
5024: IFFALSE 5074
// for i = 1 to filter do
5026: LD_ADDR_VAR 0 1
5030: PUSH
5031: DOUBLE
5032: LD_INT 1
5034: DEC
5035: ST_TO_ADDR
5036: LD_VAR 0 4
5040: PUSH
5041: FOR_TO
5042: IFFALSE 5072
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
5044: LD_VAR 0 4
5048: PUSH
5049: LD_VAR 0 1
5053: ARRAY
5054: PPUSH
5055: LD_VAR 0 7
5059: PUSH
5060: LD_VAR 0 2
5064: ARRAY
5065: PPUSH
5066: CALL_OW 120
5070: GO 5041
5072: POP
5073: POP
5074: GO 5002
5076: POP
5077: POP
// end ; if UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
5078: LD_EXP 25
5082: PPUSH
5083: LD_INT 30
5085: PUSH
5086: LD_INT 32
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: PUSH
5093: LD_INT 35
5095: PUSH
5096: LD_INT 0
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: PUSH
5112: LD_INT 0
5114: GREATER
5115: IFFALSE 5201
// begin filter := UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
5117: LD_ADDR_VAR 0 4
5121: PUSH
5122: LD_EXP 25
5126: PPUSH
5127: LD_INT 30
5129: PUSH
5130: LD_INT 32
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PUSH
5137: LD_INT 35
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: PPUSH
5151: CALL_OW 72
5155: ST_TO_ADDR
// if BuildingStatus ( ru_fac ) = bs_idle then
5156: LD_INT 92
5158: PPUSH
5159: CALL_OW 461
5163: PUSH
5164: LD_INT 2
5166: EQUAL
5167: IFFALSE 5201
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
5169: LD_VAR 0 4
5173: PUSH
5174: LD_INT 1
5176: ARRAY
5177: PPUSH
5178: LD_VAR 0 8
5182: PUSH
5183: LD_INT 1
5185: PPUSH
5186: LD_VAR 0 8
5190: PPUSH
5191: CALL_OW 12
5195: ARRAY
5196: PPUSH
5197: CALL_OW 148
// end ; end ; if ru_mech > 0 then
5201: LD_EXP 29
5205: PUSH
5206: LD_INT 0
5208: GREATER
5209: IFFALSE 5269
// for i = 1 to ru_mech do
5211: LD_ADDR_VAR 0 1
5215: PUSH
5216: DOUBLE
5217: LD_INT 1
5219: DEC
5220: ST_TO_ADDR
5221: LD_EXP 29
5225: PUSH
5226: FOR_TO
5227: IFFALSE 5267
// if not IsInUnit ( ru_mech [ i ] ) then
5229: LD_EXP 29
5233: PUSH
5234: LD_VAR 0 1
5238: ARRAY
5239: PPUSH
5240: CALL_OW 310
5244: NOT
5245: IFFALSE 5265
// ComEnterUnit ( ru_mech [ i ] , ru_fac ) ;
5247: LD_EXP 29
5251: PUSH
5252: LD_VAR 0 1
5256: ARRAY
5257: PPUSH
5258: LD_INT 92
5260: PPUSH
5261: CALL_OW 120
5265: GO 5226
5267: POP
5268: POP
// if ru_fac then
5269: LD_INT 92
5271: IFFALSE 5377
// if ru_veh > 0 then
5273: LD_EXP 27
5277: PUSH
5278: LD_INT 0
5280: GREATER
5281: IFFALSE 5377
// if BuildingStatus ( ru_fac ) = bs_idle then
5283: LD_INT 92
5285: PPUSH
5286: CALL_OW 461
5290: PUSH
5291: LD_INT 2
5293: EQUAL
5294: IFFALSE 5377
// begin ComConstruct ( ru_fac , ru_veh [ 1 ] , ru_veh [ 2 ] , ru_veh [ 3 ] , ru_veh [ 4 ] ) ;
5296: LD_INT 92
5298: PPUSH
5299: LD_EXP 27
5303: PUSH
5304: LD_INT 1
5306: ARRAY
5307: PPUSH
5308: LD_EXP 27
5312: PUSH
5313: LD_INT 2
5315: ARRAY
5316: PPUSH
5317: LD_EXP 27
5321: PUSH
5322: LD_INT 3
5324: ARRAY
5325: PPUSH
5326: LD_EXP 27
5330: PUSH
5331: LD_INT 4
5333: ARRAY
5334: PPUSH
5335: CALL_OW 125
// for i = 1 to 4 do
5339: LD_ADDR_VAR 0 1
5343: PUSH
5344: DOUBLE
5345: LD_INT 1
5347: DEC
5348: ST_TO_ADDR
5349: LD_INT 4
5351: PUSH
5352: FOR_TO
5353: IFFALSE 5375
// ru_veh := Delete ( ru_veh , 1 ) ;
5355: LD_ADDR_EXP 27
5359: PUSH
5360: LD_EXP 27
5364: PPUSH
5365: LD_INT 1
5367: PPUSH
5368: CALL_OW 3
5372: ST_TO_ADDR
5373: GO 5352
5375: POP
5376: POP
// end ; if ru_bul > 0 and enemy_detected = false then
5377: LD_EXP 31
5381: PUSH
5382: LD_INT 0
5384: GREATER
5385: PUSH
5386: LD_VAR 0 10
5390: PUSH
5391: LD_INT 0
5393: EQUAL
5394: AND
5395: IFFALSE 5498
// if ru_eng > 0 then
5397: LD_EXP 28
5401: PUSH
5402: LD_INT 0
5404: GREATER
5405: IFFALSE 5498
// for i = 1 to ru_eng do
5407: LD_ADDR_VAR 0 1
5411: PUSH
5412: DOUBLE
5413: LD_INT 1
5415: DEC
5416: ST_TO_ADDR
5417: LD_EXP 28
5421: PUSH
5422: FOR_TO
5423: IFFALSE 5496
// if not HasTask ( ru_eng [ i ] ) then
5425: LD_EXP 28
5429: PUSH
5430: LD_VAR 0 1
5434: ARRAY
5435: PPUSH
5436: CALL_OW 314
5440: NOT
5441: IFFALSE 5494
// begin ComBuild ( ru_eng [ i ] , ru_bul [ 1 ] , ru_bul [ 2 ] , ru_bul [ 3 ] , ru_bul [ 4 ] ) ;
5443: LD_EXP 28
5447: PUSH
5448: LD_VAR 0 1
5452: ARRAY
5453: PPUSH
5454: LD_EXP 31
5458: PUSH
5459: LD_INT 1
5461: ARRAY
5462: PPUSH
5463: LD_EXP 31
5467: PUSH
5468: LD_INT 2
5470: ARRAY
5471: PPUSH
5472: LD_EXP 31
5476: PUSH
5477: LD_INT 3
5479: ARRAY
5480: PPUSH
5481: LD_EXP 31
5485: PUSH
5486: LD_INT 4
5488: ARRAY
5489: PPUSH
5490: CALL_OW 145
// end ;
5494: GO 5422
5496: POP
5497: POP
// if b_dmgunit > 0 then
5498: LD_VAR 0 6
5502: PUSH
5503: LD_INT 0
5505: GREATER
5506: IFFALSE 5691
// begin if ru_eng > 0 then
5508: LD_EXP 28
5512: PUSH
5513: LD_INT 0
5515: GREATER
5516: IFFALSE 5596
// for i = 1 to ru_eng do
5518: LD_ADDR_VAR 0 1
5522: PUSH
5523: DOUBLE
5524: LD_INT 1
5526: DEC
5527: ST_TO_ADDR
5528: LD_EXP 28
5532: PUSH
5533: FOR_TO
5534: IFFALSE 5594
// begin if IsInUnit ( ru_eng [ i ] ) then
5536: LD_EXP 28
5540: PUSH
5541: LD_VAR 0 1
5545: ARRAY
5546: PPUSH
5547: CALL_OW 310
5551: IFFALSE 5568
// ComExitBuilding ( ru_eng [ i ] ) ;
5553: LD_EXP 28
5557: PUSH
5558: LD_VAR 0 1
5562: ARRAY
5563: PPUSH
5564: CALL_OW 122
// ComRepairBuilding ( ru_eng [ i ] , b_dmgunit [ 1 ] ) ;
5568: LD_EXP 28
5572: PUSH
5573: LD_VAR 0 1
5577: ARRAY
5578: PPUSH
5579: LD_VAR 0 6
5583: PUSH
5584: LD_INT 1
5586: ARRAY
5587: PPUSH
5588: CALL_OW 130
// end ;
5592: GO 5533
5594: POP
5595: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) > 0 then
5596: LD_INT 22
5598: PUSH
5599: LD_INT 6
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 34
5608: PUSH
5609: LD_INT 52
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: PUSH
5625: LD_INT 0
5627: GREATER
5628: IFFALSE 5689
// for p in FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) do
5630: LD_ADDR_VAR 0 2
5634: PUSH
5635: LD_INT 22
5637: PUSH
5638: LD_INT 6
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PUSH
5645: LD_INT 34
5647: PUSH
5648: LD_INT 52
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PPUSH
5659: CALL_OW 69
5663: PUSH
5664: FOR_IN
5665: IFFALSE 5687
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_VAR 0 6
5676: PUSH
5677: LD_INT 1
5679: ARRAY
5680: PPUSH
5681: CALL_OW 130
5685: GO 5664
5687: POP
5688: POP
// end else
5689: GO 5819
// if ru_bul = 0 then
5691: LD_EXP 31
5695: PUSH
5696: LD_INT 0
5698: EQUAL
5699: IFFALSE 5819
// for i = 1 to ru_eng do
5701: LD_ADDR_VAR 0 1
5705: PUSH
5706: DOUBLE
5707: LD_INT 1
5709: DEC
5710: ST_TO_ADDR
5711: LD_EXP 28
5715: PUSH
5716: FOR_TO
5717: IFFALSE 5817
// if not HasTask ( ru_eng [ i ] ) then
5719: LD_EXP 28
5723: PUSH
5724: LD_VAR 0 1
5728: ARRAY
5729: PPUSH
5730: CALL_OW 314
5734: NOT
5735: IFFALSE 5815
// ComEnterUnit ( ru_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru_eng [ i ] ) ) ;
5737: LD_EXP 28
5741: PUSH
5742: LD_VAR 0 1
5746: ARRAY
5747: PPUSH
5748: LD_INT 22
5750: PUSH
5751: LD_INT 6
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 2
5760: PUSH
5761: LD_INT 30
5763: PUSH
5764: LD_INT 0
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: LD_INT 30
5773: PUSH
5774: LD_INT 1
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: LIST
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PPUSH
5790: CALL_OW 69
5794: PPUSH
5795: LD_EXP 28
5799: PUSH
5800: LD_VAR 0 1
5804: ARRAY
5805: PPUSH
5806: CALL_OW 74
5810: PPUSH
5811: CALL_OW 120
5815: GO 5716
5817: POP
5818: POP
// if h_dmgunit > 0 then
5819: LD_VAR 0 5
5823: PUSH
5824: LD_INT 0
5826: GREATER
5827: IFFALSE 6034
// begin for p = 1 to h_dmgunit do
5829: LD_ADDR_VAR 0 2
5833: PUSH
5834: DOUBLE
5835: LD_INT 1
5837: DEC
5838: ST_TO_ADDR
5839: LD_VAR 0 5
5843: PUSH
5844: FOR_TO
5845: IFFALSE 5894
// if GetDistUnits ( h_dmgunit [ p ] , ru_lab ) > 6 then
5847: LD_VAR 0 5
5851: PUSH
5852: LD_VAR 0 2
5856: ARRAY
5857: PPUSH
5858: LD_INT 83
5860: PPUSH
5861: CALL_OW 296
5865: PUSH
5866: LD_INT 6
5868: GREATER
5869: IFFALSE 5892
// ComMoveXY ( h_dmgunit [ p ] , 140 , 76 ) ;
5871: LD_VAR 0 5
5875: PUSH
5876: LD_VAR 0 2
5880: ARRAY
5881: PPUSH
5882: LD_INT 140
5884: PPUSH
5885: LD_INT 76
5887: PPUSH
5888: CALL_OW 111
5892: GO 5844
5894: POP
5895: POP
// if ru_sci > 0 then
5896: LD_EXP 30
5900: PUSH
5901: LD_INT 0
5903: GREATER
5904: IFFALSE 6034
// for i = 1 to ru_sci do
5906: LD_ADDR_VAR 0 1
5910: PUSH
5911: DOUBLE
5912: LD_INT 1
5914: DEC
5915: ST_TO_ADDR
5916: LD_EXP 30
5920: PUSH
5921: FOR_TO
5922: IFFALSE 6032
// if IsInUnit ( ru_sci [ i ] ) then
5924: LD_EXP 30
5928: PUSH
5929: LD_VAR 0 1
5933: ARRAY
5934: PPUSH
5935: CALL_OW 310
5939: IFFALSE 5958
// ComExitBuilding ( ru_sci [ i ] ) else
5941: LD_EXP 30
5945: PUSH
5946: LD_VAR 0 1
5950: ARRAY
5951: PPUSH
5952: CALL_OW 122
5956: GO 6030
// if not HasTask ( ru_sci [ i ] ) then
5958: LD_EXP 30
5962: PUSH
5963: LD_VAR 0 1
5967: ARRAY
5968: PPUSH
5969: CALL_OW 314
5973: NOT
5974: IFFALSE 6030
// if GetDistUnits ( ru_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
5976: LD_EXP 30
5980: PUSH
5981: LD_VAR 0 1
5985: ARRAY
5986: PPUSH
5987: LD_VAR 0 5
5991: PUSH
5992: LD_INT 1
5994: ARRAY
5995: PPUSH
5996: CALL_OW 296
6000: PUSH
6001: LD_INT 15
6003: LESSEQUAL
6004: IFFALSE 6030
// ComHeal ( ru_sci [ i ] , h_dmgunit [ 1 ] ) ;
6006: LD_EXP 30
6010: PUSH
6011: LD_VAR 0 1
6015: ARRAY
6016: PPUSH
6017: LD_VAR 0 5
6021: PUSH
6022: LD_INT 1
6024: ARRAY
6025: PPUSH
6026: CALL_OW 128
6030: GO 5921
6032: POP
6033: POP
// end ; if h_dmgunit = 0 then
6034: LD_VAR 0 5
6038: PUSH
6039: LD_INT 0
6041: EQUAL
6042: IFFALSE 6159
// begin for i = 1 to ru_sci do
6044: LD_ADDR_VAR 0 1
6048: PUSH
6049: DOUBLE
6050: LD_INT 1
6052: DEC
6053: ST_TO_ADDR
6054: LD_EXP 30
6058: PUSH
6059: FOR_TO
6060: IFFALSE 6100
// if not IsInUnit ( ru_sci [ i ] ) then
6062: LD_EXP 30
6066: PUSH
6067: LD_VAR 0 1
6071: ARRAY
6072: PPUSH
6073: CALL_OW 310
6077: NOT
6078: IFFALSE 6098
// ComEnterUnit ( ru_sci [ i ] , ru_lab ) ;
6080: LD_EXP 30
6084: PUSH
6085: LD_VAR 0 1
6089: ARRAY
6090: PPUSH
6091: LD_INT 83
6093: PPUSH
6094: CALL_OW 120
6098: GO 6059
6100: POP
6101: POP
// if ru_tech > 0 then
6102: LD_EXP 26
6106: PUSH
6107: LD_INT 0
6109: GREATER
6110: IFFALSE 6159
// if BuildingStatus ( ru_lab ) = bs_idle then
6112: LD_INT 83
6114: PPUSH
6115: CALL_OW 461
6119: PUSH
6120: LD_INT 2
6122: EQUAL
6123: IFFALSE 6159
// begin ComResearch ( ru_lab , ru_tech [ 1 ] ) ;
6125: LD_INT 83
6127: PPUSH
6128: LD_EXP 26
6132: PUSH
6133: LD_INT 1
6135: ARRAY
6136: PPUSH
6137: CALL_OW 124
// ru_tech := Delete ( ru_tech , 1 ) ;
6141: LD_ADDR_EXP 26
6145: PUSH
6146: LD_EXP 26
6150: PPUSH
6151: LD_INT 1
6153: PPUSH
6154: CALL_OW 3
6158: ST_TO_ADDR
// end ; end ; end ;
6159: PPOPN 10
6161: END
// every 20 20$00 trigger ru_fac do var weap ;
6162: LD_INT 92
6164: IFFALSE 6391
6166: GO 6168
6168: DISABLE
6169: LD_INT 0
6171: PPUSH
// begin enable ;
6172: ENABLE
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6173: LD_ADDR_VAR 0 1
6177: PUSH
6178: LD_INT 22
6180: PUSH
6181: LD_INT 6
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PUSH
6188: LD_INT 30
6190: PUSH
6191: LD_INT 3
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PPUSH
6202: CALL_OW 69
6206: PUSH
6207: LD_INT 1
6209: ARRAY
6210: PPUSH
6211: CALL_OW 478
6215: PUSH
6216: LD_INT 52
6218: PUSH
6219: LD_INT 51
6221: PUSH
6222: LD_INT 53
6224: PUSH
6225: LD_EXP 44
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: DIFF
6236: ST_TO_ADDR
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6237: LD_ADDR_EXP 27
6241: PUSH
6242: LD_EXP 27
6246: PUSH
6247: LD_INT 23
6249: PUSH
6250: LD_INT 1
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: LD_VAR 0 1
6260: PUSH
6261: LD_INT 1
6263: PPUSH
6264: LD_VAR 0 1
6268: PPUSH
6269: CALL_OW 12
6273: ARRAY
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: ADD
6281: ST_TO_ADDR
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6282: LD_ADDR_VAR 0 1
6286: PUSH
6287: LD_INT 22
6289: PUSH
6290: LD_INT 3
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 30
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PPUSH
6311: CALL_OW 69
6315: PUSH
6316: LD_INT 1
6318: ARRAY
6319: PPUSH
6320: CALL_OW 478
6324: PUSH
6325: LD_INT 52
6327: PUSH
6328: LD_INT 51
6330: PUSH
6331: LD_INT 53
6333: PUSH
6334: LD_EXP 44
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: DIFF
6345: ST_TO_ADDR
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6346: LD_ADDR_EXP 37
6350: PUSH
6351: LD_EXP 37
6355: PUSH
6356: LD_INT 23
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: LD_INT 1
6364: PUSH
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: PPUSH
6373: LD_VAR 0 1
6377: PPUSH
6378: CALL_OW 12
6382: ARRAY
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: ADD
6390: ST_TO_ADDR
// end ;
6391: PPOPN 1
6393: END
// every 0 0$03 do var i , c , p , skr , filter , cargo , dep ;
6394: GO 6396
6396: DISABLE
6397: LD_INT 0
6399: PPUSH
6400: PPUSH
6401: PPUSH
6402: PPUSH
6403: PPUSH
6404: PPUSH
6405: PPUSH
// begin enable ;
6406: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
6407: LD_ADDR_VAR 0 5
6411: PUSH
6412: LD_INT 50
6414: PUSH
6415: EMPTY
6416: LIST
6417: PUSH
6418: LD_INT 22
6420: PUSH
6421: LD_INT 6
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 2
6430: PUSH
6431: LD_INT 25
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: PUSH
6441: LD_INT 25
6443: PUSH
6444: LD_INT 16
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: LIST
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: LIST
6460: PPUSH
6461: CALL_OW 69
6465: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_weapon , ru_cargo_bay ] , [ f_lives , 600 ] ] ) ;
6466: LD_ADDR_VAR 0 6
6470: PUSH
6471: LD_INT 2
6473: PUSH
6474: LD_INT 22
6476: PUSH
6477: LD_INT 6
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 22
6486: PUSH
6487: LD_INT 3
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: PUSH
6499: LD_INT 34
6501: PUSH
6502: LD_INT 51
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 24
6511: PUSH
6512: LD_INT 600
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: PPUSH
6524: CALL_OW 69
6528: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6529: LD_ADDR_VAR 0 7
6533: PUSH
6534: LD_INT 2
6536: PUSH
6537: LD_INT 22
6539: PUSH
6540: LD_INT 6
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 22
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 2
6564: PUSH
6565: LD_INT 30
6567: PUSH
6568: LD_INT 0
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PUSH
6575: LD_INT 30
6577: PUSH
6578: LD_INT 1
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: LIST
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PPUSH
6594: CALL_OW 69
6598: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_main_area ) ;
6599: LD_ADDR_VAR 0 4
6603: PUSH
6604: LD_INT 2
6606: PPUSH
6607: CALL_OW 435
6611: ST_TO_ADDR
// c = 1 ;
6612: LD_ADDR_VAR 0 2
6616: PUSH
6617: LD_INT 1
6619: ST_TO_ADDR
// if cargo > 0 then
6620: LD_VAR 0 6
6624: PUSH
6625: LD_INT 0
6627: GREATER
6628: IFFALSE 6922
// while c < skr do
6630: LD_VAR 0 2
6634: PUSH
6635: LD_VAR 0 4
6639: LESS
6640: IFFALSE 6922
// begin if cargo > 0 then
6642: LD_VAR 0 6
6646: PUSH
6647: LD_INT 0
6649: GREATER
6650: IFFALSE 6920
// for i = 1 to cargo do
6652: LD_ADDR_VAR 0 1
6656: PUSH
6657: DOUBLE
6658: LD_INT 1
6660: DEC
6661: ST_TO_ADDR
6662: LD_VAR 0 6
6666: PUSH
6667: FOR_TO
6668: IFFALSE 6918
// begin if GetFuel ( cargo [ i ] ) > 40 and GetDistUnitXY ( cargo [ i ] , skr [ c ] , skr [ c + 1 ] ) < 51 then
6670: LD_VAR 0 6
6674: PUSH
6675: LD_VAR 0 1
6679: ARRAY
6680: PPUSH
6681: CALL_OW 261
6685: PUSH
6686: LD_INT 40
6688: GREATER
6689: PUSH
6690: LD_VAR 0 6
6694: PUSH
6695: LD_VAR 0 1
6699: ARRAY
6700: PPUSH
6701: LD_VAR 0 4
6705: PUSH
6706: LD_VAR 0 2
6710: ARRAY
6711: PPUSH
6712: LD_VAR 0 4
6716: PUSH
6717: LD_VAR 0 2
6721: PUSH
6722: LD_INT 1
6724: PLUS
6725: ARRAY
6726: PPUSH
6727: CALL_OW 297
6731: PUSH
6732: LD_INT 51
6734: LESS
6735: AND
6736: IFFALSE 6779
// ComCollect ( cargo [ i ] , skr [ c ] , skr [ c + 1 ] ) ;
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 1
6747: ARRAY
6748: PPUSH
6749: LD_VAR 0 4
6753: PUSH
6754: LD_VAR 0 2
6758: ARRAY
6759: PPUSH
6760: LD_VAR 0 4
6764: PUSH
6765: LD_VAR 0 2
6769: PUSH
6770: LD_INT 1
6772: PLUS
6773: ARRAY
6774: PPUSH
6775: CALL_OW 117
// if GetFuel ( cargo [ i ] ) <= 40 then
6779: LD_VAR 0 6
6783: PUSH
6784: LD_VAR 0 1
6788: ARRAY
6789: PPUSH
6790: CALL_OW 261
6794: PUSH
6795: LD_INT 40
6797: LESSEQUAL
6798: IFFALSE 6902
// begin repeat begin ComMoveXY ( cargo [ i ] , GetX ( dep [ i ] ) , GetY ( dep [ 1 ] ) ) ;
6800: LD_VAR 0 6
6804: PUSH
6805: LD_VAR 0 1
6809: ARRAY
6810: PPUSH
6811: LD_VAR 0 7
6815: PUSH
6816: LD_VAR 0 1
6820: ARRAY
6821: PPUSH
6822: CALL_OW 250
6826: PPUSH
6827: LD_VAR 0 7
6831: PUSH
6832: LD_INT 1
6834: ARRAY
6835: PPUSH
6836: CALL_OW 251
6840: PPUSH
6841: CALL_OW 111
// Wait ( 0 0$01 ) ;
6845: LD_INT 35
6847: PPUSH
6848: CALL_OW 67
// end until GetDistUnits ( cargo [ i ] , dep [ i ] ) < 7 ;
6852: LD_VAR 0 6
6856: PUSH
6857: LD_VAR 0 1
6861: ARRAY
6862: PPUSH
6863: LD_VAR 0 7
6867: PUSH
6868: LD_VAR 0 1
6872: ARRAY
6873: PPUSH
6874: CALL_OW 296
6878: PUSH
6879: LD_INT 7
6881: LESS
6882: IFFALSE 6800
// SetFuel ( cargo [ i ] , 100 ) ;
6884: LD_VAR 0 6
6888: PUSH
6889: LD_VAR 0 1
6893: ARRAY
6894: PPUSH
6895: LD_INT 100
6897: PPUSH
6898: CALL_OW 240
// end ; c = c + 2 ;
6902: LD_ADDR_VAR 0 2
6906: PUSH
6907: LD_VAR 0 2
6911: PUSH
6912: LD_INT 2
6914: PLUS
6915: ST_TO_ADDR
// end ;
6916: GO 6667
6918: POP
6919: POP
// end ;
6920: GO 6630
// end ;
6922: PPOPN 7
6924: END
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , b_fac , b_labb , b_ext , enemy_detected ;
6925: GO 6927
6927: DISABLE
6928: LD_INT 0
6930: PPUSH
6931: PPUSH
6932: PPUSH
6933: PPUSH
6934: PPUSH
6935: PPUSH
6936: PPUSH
6937: PPUSH
6938: PPUSH
6939: PPUSH
6940: PPUSH
6941: PPUSH
6942: PPUSH
// begin enable ;
6943: ENABLE
// ru2_sold := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) ;
6944: LD_ADDR_EXP 33
6948: PUSH
6949: LD_INT 22
6951: PUSH
6952: LD_INT 3
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PUSH
6959: LD_INT 25
6961: PUSH
6962: LD_INT 1
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: PUSH
6969: LD_INT 24
6971: PUSH
6972: LD_INT 600
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: PPUSH
6987: CALL_OW 69
6991: ST_TO_ADDR
// ru2_eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
6992: LD_ADDR_EXP 38
6996: PUSH
6997: LD_INT 22
6999: PUSH
7000: LD_INT 3
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PUSH
7007: LD_INT 25
7009: PUSH
7010: LD_INT 2
7012: PUSH
7013: EMPTY
7014: LIST
7015: LIST
7016: PUSH
7017: LD_INT 24
7019: PUSH
7020: LD_INT 600
7022: PUSH
7023: EMPTY
7024: LIST
7025: LIST
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: LIST
7031: PUSH
7032: EMPTY
7033: LIST
7034: PPUSH
7035: CALL_OW 69
7039: ST_TO_ADDR
// ru2_mech := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
7040: LD_ADDR_EXP 39
7044: PUSH
7045: LD_INT 22
7047: PUSH
7048: LD_INT 3
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: PUSH
7055: LD_INT 25
7057: PUSH
7058: LD_INT 3
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 24
7067: PUSH
7068: LD_INT 600
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: LIST
7079: PUSH
7080: EMPTY
7081: LIST
7082: PPUSH
7083: CALL_OW 69
7087: ST_TO_ADDR
// ru2_sci := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
7088: LD_ADDR_EXP 40
7092: PUSH
7093: LD_INT 22
7095: PUSH
7096: LD_INT 3
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: PUSH
7103: LD_INT 25
7105: PUSH
7106: LD_INT 4
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: LD_INT 24
7115: PUSH
7116: LD_INT 600
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: PUSH
7128: EMPTY
7129: LIST
7130: PPUSH
7131: CALL_OW 69
7135: ST_TO_ADDR
// ru2_tw := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
7136: LD_ADDR_EXP 35
7140: PUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 3
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 2
7153: PUSH
7154: LD_INT 30
7156: PUSH
7157: LD_INT 31
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 30
7166: PUSH
7167: LD_INT 32
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 250
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: PPUSH
7197: CALL_OW 69
7201: ST_TO_ADDR
// ru2_b := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
7202: LD_ADDR_EXP 42
7206: PUSH
7207: LD_INT 22
7209: PUSH
7210: LD_INT 3
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: LD_INT 21
7219: PUSH
7220: LD_INT 3
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PPUSH
7231: CALL_OW 69
7235: ST_TO_ADDR
// b_dmgunit := FilterUnitsInArea ( beria_defa , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
7236: LD_ADDR_VAR 0 6
7240: PUSH
7241: LD_INT 17
7243: PPUSH
7244: LD_INT 22
7246: PUSH
7247: LD_INT 3
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PUSH
7254: LD_INT 21
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: EMPTY
7261: LIST
7262: LIST
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: LD_INT 24
7269: PUSH
7270: LD_INT 1000
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: LIST
7285: PUSH
7286: EMPTY
7287: LIST
7288: PPUSH
7289: CALL_OW 70
7293: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
7294: LD_ADDR_VAR 0 5
7298: PUSH
7299: LD_INT 22
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PUSH
7309: LD_INT 21
7311: PUSH
7312: LD_INT 1
7314: PUSH
7315: EMPTY
7316: LIST
7317: LIST
7318: PUSH
7319: LD_INT 3
7321: PUSH
7322: LD_INT 24
7324: PUSH
7325: LD_INT 600
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: PPUSH
7344: CALL_OW 69
7348: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7349: LD_INT 22
7351: PUSH
7352: LD_INT 3
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PUSH
7359: LD_INT 30
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PPUSH
7373: CALL_OW 69
7377: IFFALSE 7417
// b_fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7379: LD_ADDR_VAR 0 10
7383: PUSH
7384: LD_INT 22
7386: PUSH
7387: LD_INT 3
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 30
7396: PUSH
7397: LD_INT 3
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: PUSH
7413: LD_INT 1
7415: ARRAY
7416: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
7417: LD_INT 22
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: LD_INT 2
7429: PUSH
7430: LD_INT 30
7432: PUSH
7433: LD_INT 6
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 30
7442: PUSH
7443: LD_INT 7
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 30
7452: PUSH
7453: LD_INT 8
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: IFFALSE 7543
// b_labb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7476: LD_ADDR_VAR 0 11
7480: PUSH
7481: LD_INT 22
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 2
7493: PUSH
7494: LD_INT 30
7496: PUSH
7497: LD_INT 6
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: LD_INT 30
7506: PUSH
7507: LD_INT 7
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: PUSH
7514: LD_INT 30
7516: PUSH
7517: LD_INT 8
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: LIST
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PPUSH
7534: CALL_OW 69
7538: PUSH
7539: LD_INT 1
7541: ARRAY
7542: ST_TO_ADDR
// b_weap := AvailableWeaponList ( b_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
7543: LD_ADDR_VAR 0 8
7547: PUSH
7548: LD_VAR 0 10
7552: PPUSH
7553: CALL_OW 478
7557: PUSH
7558: LD_INT 52
7560: PUSH
7561: LD_INT 51
7563: PUSH
7564: LD_INT 53
7566: PUSH
7567: LD_EXP 44
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: DIFF
7578: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_workshop ] ;
7579: LD_ADDR_VAR 0 9
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: LD_INT 4
7589: PUSH
7590: LD_INT 2
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: ST_TO_ADDR
// b_ext := [ ] ;
7598: LD_ADDR_VAR 0 12
7602: PUSH
7603: EMPTY
7604: ST_TO_ADDR
// if FilterUnitsInArea ( beria_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) diff FilterAllUnits ( [ f_weapon , us_radar ] ) > 0 then
7605: LD_INT 11
7607: PPUSH
7608: LD_INT 2
7610: PUSH
7611: LD_INT 22
7613: PUSH
7614: LD_INT 1
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 22
7623: PUSH
7624: LD_INT 2
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PPUSH
7636: CALL_OW 70
7640: PUSH
7641: LD_INT 34
7643: PUSH
7644: LD_INT 11
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: PPUSH
7651: CALL_OW 69
7655: PUSH
7656: LD_INT 0
7658: GREATER
7659: DIFF
7660: IFFALSE 7672
// enemy_detected := true else
7662: LD_ADDR_VAR 0 13
7666: PUSH
7667: LD_INT 1
7669: ST_TO_ADDR
7670: GO 7680
// enemy_detected := false ;
7672: LD_ADDR_VAR 0 13
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// if enemy_detected = false then
7680: LD_VAR 0 13
7684: PUSH
7685: LD_INT 0
7687: EQUAL
7688: IFFALSE 7789
// for i = 1 to ru2_b do
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: DOUBLE
7696: LD_INT 1
7698: DEC
7699: ST_TO_ADDR
7700: LD_EXP 42
7704: PUSH
7705: FOR_TO
7706: IFFALSE 7787
// begin if GetBType ( ru2_b [ i ] ) in b_upgrade then
7708: LD_EXP 42
7712: PUSH
7713: LD_VAR 0 1
7717: ARRAY
7718: PPUSH
7719: CALL_OW 266
7723: PUSH
7724: LD_VAR 0 9
7728: IN
7729: IFFALSE 7746
// ComUpgrade ( ru2_b [ i ] ) ;
7731: LD_EXP 42
7735: PUSH
7736: LD_VAR 0 1
7740: ARRAY
7741: PPUSH
7742: CALL_OW 146
// if GetBType ( ru2_b [ i ] ) in b_lab then
7746: LD_EXP 42
7750: PUSH
7751: LD_VAR 0 1
7755: ARRAY
7756: PPUSH
7757: CALL_OW 266
7761: PUSH
7762: LD_INT 6
7764: IN
7765: IFFALSE 7785
// ComUpgradeLab ( ru2_b [ i ] , b_lab_weapon ) ;
7767: LD_EXP 42
7771: PUSH
7772: LD_VAR 0 1
7776: ARRAY
7777: PPUSH
7778: LD_INT 10
7780: PPUSH
7781: CALL_OW 147
// end ;
7785: GO 7705
7787: POP
7788: POP
// if ru2_sold > 0 then
7789: LD_EXP 33
7793: PUSH
7794: LD_INT 0
7796: GREATER
7797: IFFALSE 8260
// begin filter := UnitFilter ( ru2_sold , [ f_not , [ f_inside ] ] ) ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_EXP 33
7808: PPUSH
7809: LD_INT 3
7811: PUSH
7812: LD_INT 54
7814: PUSH
7815: EMPTY
7816: LIST
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL_OW 72
7826: ST_TO_ADDR
// if UnitFilter ( ru2_tw , [ f_empty ] ) > 0 then
7827: LD_EXP 35
7831: PPUSH
7832: LD_INT 58
7834: PUSH
7835: EMPTY
7836: LIST
7837: PPUSH
7838: CALL_OW 72
7842: PUSH
7843: LD_INT 0
7845: GREATER
7846: IFFALSE 7961
// begin if filter = 0 then
7848: LD_VAR 0 4
7852: PUSH
7853: LD_INT 0
7855: EQUAL
7856: IFFALSE 7881
// ComExitBuilding ( ru2_sold [ Rand ( 1 , ru2_sold ) ] ) ;
7858: LD_EXP 33
7862: PUSH
7863: LD_INT 1
7865: PPUSH
7866: LD_EXP 33
7870: PPUSH
7871: CALL_OW 12
7875: ARRAY
7876: PPUSH
7877: CALL_OW 122
// if filter > 0 then
7881: LD_VAR 0 4
7885: PUSH
7886: LD_INT 0
7888: GREATER
7889: IFFALSE 7961
// for i = 1 to UnitFilter ( ru2_tw , [ f_empty ] ) do
7891: LD_ADDR_VAR 0 1
7895: PUSH
7896: DOUBLE
7897: LD_INT 1
7899: DEC
7900: ST_TO_ADDR
7901: LD_EXP 35
7905: PPUSH
7906: LD_INT 58
7908: PUSH
7909: EMPTY
7910: LIST
7911: PPUSH
7912: CALL_OW 72
7916: PUSH
7917: FOR_TO
7918: IFFALSE 7959
// ComEnterUnit ( filter [ i ] , UnitFilter ( ru2_tw , [ f_empty ] ) [ i ] ) ;
7920: LD_VAR 0 4
7924: PUSH
7925: LD_VAR 0 1
7929: ARRAY
7930: PPUSH
7931: LD_EXP 35
7935: PPUSH
7936: LD_INT 58
7938: PUSH
7939: EMPTY
7940: LIST
7941: PPUSH
7942: CALL_OW 72
7946: PUSH
7947: LD_VAR 0 1
7951: ARRAY
7952: PPUSH
7953: CALL_OW 120
7957: GO 7917
7959: POP
7960: POP
// end ; if UnitFilter ( ru2_tw , [ f_empty ] ) = 0 then
7961: LD_EXP 35
7965: PPUSH
7966: LD_INT 58
7968: PUSH
7969: EMPTY
7970: LIST
7971: PPUSH
7972: CALL_OW 72
7976: PUSH
7977: LD_INT 0
7979: EQUAL
7980: IFFALSE 8135
// begin b_unit := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
7982: LD_ADDR_VAR 0 7
7986: PUSH
7987: LD_INT 22
7989: PUSH
7990: LD_INT 3
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: PUSH
7997: LD_INT 2
7999: PUSH
8000: LD_INT 30
8002: PUSH
8003: LD_INT 4
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: LD_INT 30
8012: PUSH
8013: LD_INT 5
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PPUSH
8029: CALL_OW 69
8033: ST_TO_ADDR
// if b_unit > 0 then
8034: LD_VAR 0 7
8038: PUSH
8039: LD_INT 0
8041: GREATER
8042: IFFALSE 8135
// for p = 1 to b_unit do
8044: LD_ADDR_VAR 0 2
8048: PUSH
8049: DOUBLE
8050: LD_INT 1
8052: DEC
8053: ST_TO_ADDR
8054: LD_VAR 0 7
8058: PUSH
8059: FOR_TO
8060: IFFALSE 8133
// if UnitsInSide ( b_unit [ p ] ) < 6 then
8062: LD_VAR 0 7
8066: PUSH
8067: LD_VAR 0 2
8071: ARRAY
8072: PPUSH
8073: CALL_OW 313
8077: PUSH
8078: LD_INT 6
8080: LESS
8081: IFFALSE 8131
// for i = 1 to filter do
8083: LD_ADDR_VAR 0 1
8087: PUSH
8088: DOUBLE
8089: LD_INT 1
8091: DEC
8092: ST_TO_ADDR
8093: LD_VAR 0 4
8097: PUSH
8098: FOR_TO
8099: IFFALSE 8129
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
8101: LD_VAR 0 4
8105: PUSH
8106: LD_VAR 0 1
8110: ARRAY
8111: PPUSH
8112: LD_VAR 0 7
8116: PUSH
8117: LD_VAR 0 2
8121: ARRAY
8122: PPUSH
8123: CALL_OW 120
8127: GO 8098
8129: POP
8130: POP
8131: GO 8059
8133: POP
8134: POP
// end ; if UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
8135: LD_EXP 35
8139: PPUSH
8140: LD_INT 30
8142: PUSH
8143: LD_INT 32
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: PUSH
8150: LD_INT 35
8152: PUSH
8153: LD_INT 0
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PPUSH
8164: CALL_OW 72
8168: PUSH
8169: LD_INT 0
8171: GREATER
8172: IFFALSE 8260
// begin filter := UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
8174: LD_ADDR_VAR 0 4
8178: PUSH
8179: LD_EXP 35
8183: PPUSH
8184: LD_INT 30
8186: PUSH
8187: LD_INT 32
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PUSH
8194: LD_INT 35
8196: PUSH
8197: LD_INT 0
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PPUSH
8208: CALL_OW 72
8212: ST_TO_ADDR
// if BuildingStatus ( b_fac ) = bs_idle then
8213: LD_VAR 0 10
8217: PPUSH
8218: CALL_OW 461
8222: PUSH
8223: LD_INT 2
8225: EQUAL
8226: IFFALSE 8260
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
8228: LD_VAR 0 4
8232: PUSH
8233: LD_INT 1
8235: ARRAY
8236: PPUSH
8237: LD_VAR 0 8
8241: PUSH
8242: LD_INT 1
8244: PPUSH
8245: LD_VAR 0 8
8249: PPUSH
8250: CALL_OW 12
8254: ARRAY
8255: PPUSH
8256: CALL_OW 148
// end ; end ; if b_fac > 0 and ru2_mech > 0 then
8260: LD_VAR 0 10
8264: PUSH
8265: LD_INT 0
8267: GREATER
8268: PUSH
8269: LD_EXP 39
8273: PUSH
8274: LD_INT 0
8276: GREATER
8277: AND
8278: IFFALSE 8340
// for i = 1 to ru2_mech do
8280: LD_ADDR_VAR 0 1
8284: PUSH
8285: DOUBLE
8286: LD_INT 1
8288: DEC
8289: ST_TO_ADDR
8290: LD_EXP 39
8294: PUSH
8295: FOR_TO
8296: IFFALSE 8338
// if not IsInUnit ( ru2_mech [ i ] ) then
8298: LD_EXP 39
8302: PUSH
8303: LD_VAR 0 1
8307: ARRAY
8308: PPUSH
8309: CALL_OW 310
8313: NOT
8314: IFFALSE 8336
// ComEnterUnit ( ru2_mech [ i ] , b_fac ) ;
8316: LD_EXP 39
8320: PUSH
8321: LD_VAR 0 1
8325: ARRAY
8326: PPUSH
8327: LD_VAR 0 10
8331: PPUSH
8332: CALL_OW 120
8336: GO 8295
8338: POP
8339: POP
// if b_fac > 0 and ru2_veh > 0 then
8340: LD_VAR 0 10
8344: PUSH
8345: LD_INT 0
8347: GREATER
8348: PUSH
8349: LD_EXP 37
8353: PUSH
8354: LD_INT 0
8356: GREATER
8357: AND
8358: IFFALSE 8458
// if BuildingStatus ( b_fac ) = bs_idle then
8360: LD_VAR 0 10
8364: PPUSH
8365: CALL_OW 461
8369: PUSH
8370: LD_INT 2
8372: EQUAL
8373: IFFALSE 8458
// begin ComConstruct ( b_fac , ru2_veh [ 1 ] , ru2_veh [ 2 ] , ru2_veh [ 3 ] , ru2_veh [ 4 ] ) ;
8375: LD_VAR 0 10
8379: PPUSH
8380: LD_EXP 37
8384: PUSH
8385: LD_INT 1
8387: ARRAY
8388: PPUSH
8389: LD_EXP 37
8393: PUSH
8394: LD_INT 2
8396: ARRAY
8397: PPUSH
8398: LD_EXP 37
8402: PUSH
8403: LD_INT 3
8405: ARRAY
8406: PPUSH
8407: LD_EXP 37
8411: PUSH
8412: LD_INT 4
8414: ARRAY
8415: PPUSH
8416: CALL_OW 125
// for i = 1 to 4 do
8420: LD_ADDR_VAR 0 1
8424: PUSH
8425: DOUBLE
8426: LD_INT 1
8428: DEC
8429: ST_TO_ADDR
8430: LD_INT 4
8432: PUSH
8433: FOR_TO
8434: IFFALSE 8456
// ru2_veh := Delete ( ru2_veh , 1 ) ;
8436: LD_ADDR_EXP 37
8440: PUSH
8441: LD_EXP 37
8445: PPUSH
8446: LD_INT 1
8448: PPUSH
8449: CALL_OW 3
8453: ST_TO_ADDR
8454: GO 8433
8456: POP
8457: POP
// end ; if ru2_bul > 0 and enemy_detected = false then
8458: LD_EXP 41
8462: PUSH
8463: LD_INT 0
8465: GREATER
8466: PUSH
8467: LD_VAR 0 13
8471: PUSH
8472: LD_INT 0
8474: EQUAL
8475: AND
8476: IFFALSE 8579
// if ru2_eng > 0 then
8478: LD_EXP 38
8482: PUSH
8483: LD_INT 0
8485: GREATER
8486: IFFALSE 8579
// for i = 1 to ru2_eng do
8488: LD_ADDR_VAR 0 1
8492: PUSH
8493: DOUBLE
8494: LD_INT 1
8496: DEC
8497: ST_TO_ADDR
8498: LD_EXP 38
8502: PUSH
8503: FOR_TO
8504: IFFALSE 8577
// if not HasTask ( ru2_eng [ i ] ) then
8506: LD_EXP 38
8510: PUSH
8511: LD_VAR 0 1
8515: ARRAY
8516: PPUSH
8517: CALL_OW 314
8521: NOT
8522: IFFALSE 8575
// begin ComBuild ( ru2_eng [ i ] , ru2_bul [ 1 ] , ru2_bul [ 2 ] , ru2_bul [ 3 ] , ru2_bul [ 4 ] ) ;
8524: LD_EXP 38
8528: PUSH
8529: LD_VAR 0 1
8533: ARRAY
8534: PPUSH
8535: LD_EXP 41
8539: PUSH
8540: LD_INT 1
8542: ARRAY
8543: PPUSH
8544: LD_EXP 41
8548: PUSH
8549: LD_INT 2
8551: ARRAY
8552: PPUSH
8553: LD_EXP 41
8557: PUSH
8558: LD_INT 3
8560: ARRAY
8561: PPUSH
8562: LD_EXP 41
8566: PUSH
8567: LD_INT 4
8569: ARRAY
8570: PPUSH
8571: CALL_OW 145
// end ;
8575: GO 8503
8577: POP
8578: POP
// for i = 1 to ru2_b do
8579: LD_ADDR_VAR 0 1
8583: PUSH
8584: DOUBLE
8585: LD_INT 1
8587: DEC
8588: ST_TO_ADDR
8589: LD_EXP 42
8593: PUSH
8594: FOR_TO
8595: IFFALSE 8783
// if BuildingStatus ( ru2_b [ i ] ) = bs_need_extension then
8597: LD_EXP 42
8601: PUSH
8602: LD_VAR 0 1
8606: ARRAY
8607: PPUSH
8608: CALL_OW 461
8612: PUSH
8613: LD_INT 8
8615: EQUAL
8616: IFFALSE 8781
// begin b_ext := GetExtPositions ( ru2_b [ i ] ) ;
8618: LD_ADDR_VAR 0 12
8622: PUSH
8623: LD_EXP 42
8627: PUSH
8628: LD_VAR 0 1
8632: ARRAY
8633: PPUSH
8634: CALL_OW 270
8638: ST_TO_ADDR
// if b_ext > 0 and not b_ext_gun in ru2_bul then
8639: LD_VAR 0 12
8643: PUSH
8644: LD_INT 0
8646: GREATER
8647: PUSH
8648: LD_INT 17
8650: PUSH
8651: LD_EXP 41
8655: IN
8656: NOT
8657: AND
8658: IFFALSE 8781
// ru2_bul := ru2_bul ^ [ b_ext_noncombat , b_ext [ 1 ] [ 1 ] , b_ext [ 1 ] [ 2 ] , 3 , b_ext_track , b_ext [ 2 ] [ 1 ] , b_ext [ 2 ] [ 2 ] , 5 , b_ext_gun , b_ext [ 3 ] [ 1 ] , b_ext [ 3 ] [ 2 ] , 2 ] ;
8660: LD_ADDR_EXP 41
8664: PUSH
8665: LD_EXP 41
8669: PUSH
8670: LD_INT 19
8672: PUSH
8673: LD_VAR 0 12
8677: PUSH
8678: LD_INT 1
8680: ARRAY
8681: PUSH
8682: LD_INT 1
8684: ARRAY
8685: PUSH
8686: LD_VAR 0 12
8690: PUSH
8691: LD_INT 1
8693: ARRAY
8694: PUSH
8695: LD_INT 2
8697: ARRAY
8698: PUSH
8699: LD_INT 3
8701: PUSH
8702: LD_INT 16
8704: PUSH
8705: LD_VAR 0 12
8709: PUSH
8710: LD_INT 2
8712: ARRAY
8713: PUSH
8714: LD_INT 1
8716: ARRAY
8717: PUSH
8718: LD_VAR 0 12
8722: PUSH
8723: LD_INT 2
8725: ARRAY
8726: PUSH
8727: LD_INT 2
8729: ARRAY
8730: PUSH
8731: LD_INT 5
8733: PUSH
8734: LD_INT 17
8736: PUSH
8737: LD_VAR 0 12
8741: PUSH
8742: LD_INT 3
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PUSH
8750: LD_VAR 0 12
8754: PUSH
8755: LD_INT 3
8757: ARRAY
8758: PUSH
8759: LD_INT 2
8761: ARRAY
8762: PUSH
8763: LD_INT 2
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: LIST
8777: LIST
8778: LIST
8779: ADD
8780: ST_TO_ADDR
// end ;
8781: GO 8594
8783: POP
8784: POP
// if b_dmgunit > 0 then
8785: LD_VAR 0 6
8789: PUSH
8790: LD_INT 0
8792: GREATER
8793: IFFALSE 8978
// begin if ru2_eng > 0 then
8795: LD_EXP 38
8799: PUSH
8800: LD_INT 0
8802: GREATER
8803: IFFALSE 8883
// for i = 1 to ru2_eng do
8805: LD_ADDR_VAR 0 1
8809: PUSH
8810: DOUBLE
8811: LD_INT 1
8813: DEC
8814: ST_TO_ADDR
8815: LD_EXP 38
8819: PUSH
8820: FOR_TO
8821: IFFALSE 8881
// begin if IsInUnit ( ru2_eng [ i ] ) then
8823: LD_EXP 38
8827: PUSH
8828: LD_VAR 0 1
8832: ARRAY
8833: PPUSH
8834: CALL_OW 310
8838: IFFALSE 8855
// ComExitBuilding ( ru2_eng [ i ] ) ;
8840: LD_EXP 38
8844: PUSH
8845: LD_VAR 0 1
8849: ARRAY
8850: PPUSH
8851: CALL_OW 122
// ComRepairBuilding ( ru2_eng [ i ] , b_dmgunit [ 1 ] ) ;
8855: LD_EXP 38
8859: PUSH
8860: LD_VAR 0 1
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 6
8870: PUSH
8871: LD_INT 1
8873: ARRAY
8874: PPUSH
8875: CALL_OW 130
// end ;
8879: GO 8820
8881: POP
8882: POP
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) > 0 then
8883: LD_INT 22
8885: PUSH
8886: LD_INT 3
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: LD_INT 34
8895: PUSH
8896: LD_INT 52
8898: PUSH
8899: EMPTY
8900: LIST
8901: LIST
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PPUSH
8907: CALL_OW 69
8911: PUSH
8912: LD_INT 0
8914: GREATER
8915: IFFALSE 8976
// for p in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) do
8917: LD_ADDR_VAR 0 2
8921: PUSH
8922: LD_INT 22
8924: PUSH
8925: LD_INT 3
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: LD_INT 34
8934: PUSH
8935: LD_INT 52
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PPUSH
8946: CALL_OW 69
8950: PUSH
8951: FOR_IN
8952: IFFALSE 8974
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
8954: LD_VAR 0 2
8958: PPUSH
8959: LD_VAR 0 6
8963: PUSH
8964: LD_INT 1
8966: ARRAY
8967: PPUSH
8968: CALL_OW 130
8972: GO 8951
8974: POP
8975: POP
// end else
8976: GO 9106
// if ru2_bul = 0 then
8978: LD_EXP 41
8982: PUSH
8983: LD_INT 0
8985: EQUAL
8986: IFFALSE 9106
// for i = 1 to ru2_eng do
8988: LD_ADDR_VAR 0 1
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_EXP 38
9002: PUSH
9003: FOR_TO
9004: IFFALSE 9104
// if not HasTask ( ru2_eng [ i ] ) then
9006: LD_EXP 38
9010: PUSH
9011: LD_VAR 0 1
9015: ARRAY
9016: PPUSH
9017: CALL_OW 314
9021: NOT
9022: IFFALSE 9102
// ComEnterUnit ( ru2_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru2_eng [ i ] ) ) ;
9024: LD_EXP 38
9028: PUSH
9029: LD_VAR 0 1
9033: ARRAY
9034: PPUSH
9035: LD_INT 22
9037: PUSH
9038: LD_INT 3
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: LD_INT 2
9047: PUSH
9048: LD_INT 30
9050: PUSH
9051: LD_INT 0
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PUSH
9058: LD_INT 30
9060: PUSH
9061: LD_INT 1
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PPUSH
9077: CALL_OW 69
9081: PPUSH
9082: LD_EXP 38
9086: PUSH
9087: LD_VAR 0 1
9091: ARRAY
9092: PPUSH
9093: CALL_OW 74
9097: PPUSH
9098: CALL_OW 120
9102: GO 9003
9104: POP
9105: POP
// if b_labb > 0 then
9106: LD_VAR 0 11
9110: PUSH
9111: LD_INT 0
9113: GREATER
9114: IFFALSE 9464
// begin if h_dmgunit > 0 then
9116: LD_VAR 0 5
9120: PUSH
9121: LD_INT 0
9123: GREATER
9124: IFFALSE 9333
// begin for p = 1 to h_dmgunit do
9126: LD_ADDR_VAR 0 2
9130: PUSH
9131: DOUBLE
9132: LD_INT 1
9134: DEC
9135: ST_TO_ADDR
9136: LD_VAR 0 5
9140: PUSH
9141: FOR_TO
9142: IFFALSE 9193
// if GetDistUnits ( h_dmgunit [ p ] , b_labb ) > 6 then
9144: LD_VAR 0 5
9148: PUSH
9149: LD_VAR 0 2
9153: ARRAY
9154: PPUSH
9155: LD_VAR 0 11
9159: PPUSH
9160: CALL_OW 296
9164: PUSH
9165: LD_INT 6
9167: GREATER
9168: IFFALSE 9191
// ComMoveXY ( h_dmgunit [ p ] , 95 , 72 ) ;
9170: LD_VAR 0 5
9174: PUSH
9175: LD_VAR 0 2
9179: ARRAY
9180: PPUSH
9181: LD_INT 95
9183: PPUSH
9184: LD_INT 72
9186: PPUSH
9187: CALL_OW 111
9191: GO 9141
9193: POP
9194: POP
// if ru2_sci > 0 then
9195: LD_EXP 40
9199: PUSH
9200: LD_INT 0
9202: GREATER
9203: IFFALSE 9333
// for i = 1 to ru2_sci do
9205: LD_ADDR_VAR 0 1
9209: PUSH
9210: DOUBLE
9211: LD_INT 1
9213: DEC
9214: ST_TO_ADDR
9215: LD_EXP 40
9219: PUSH
9220: FOR_TO
9221: IFFALSE 9331
// if IsInUnit ( ru2_sci [ i ] ) then
9223: LD_EXP 40
9227: PUSH
9228: LD_VAR 0 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 310
9238: IFFALSE 9257
// ComExitBuilding ( ru2_sci [ i ] ) else
9240: LD_EXP 40
9244: PUSH
9245: LD_VAR 0 1
9249: ARRAY
9250: PPUSH
9251: CALL_OW 122
9255: GO 9329
// if not HasTask ( ru2_sci [ i ] ) then
9257: LD_EXP 40
9261: PUSH
9262: LD_VAR 0 1
9266: ARRAY
9267: PPUSH
9268: CALL_OW 314
9272: NOT
9273: IFFALSE 9329
// if GetDistUnits ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
9275: LD_EXP 40
9279: PUSH
9280: LD_VAR 0 1
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 5
9290: PUSH
9291: LD_INT 1
9293: ARRAY
9294: PPUSH
9295: CALL_OW 296
9299: PUSH
9300: LD_INT 15
9302: LESSEQUAL
9303: IFFALSE 9329
// ComHeal ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) ;
9305: LD_EXP 40
9309: PUSH
9310: LD_VAR 0 1
9314: ARRAY
9315: PPUSH
9316: LD_VAR 0 5
9320: PUSH
9321: LD_INT 1
9323: ARRAY
9324: PPUSH
9325: CALL_OW 128
9329: GO 9220
9331: POP
9332: POP
// end ; if h_dmgunit = 0 then
9333: LD_VAR 0 5
9337: PUSH
9338: LD_INT 0
9340: EQUAL
9341: IFFALSE 9464
// begin for i = 1 to ru2_sci do
9343: LD_ADDR_VAR 0 1
9347: PUSH
9348: DOUBLE
9349: LD_INT 1
9351: DEC
9352: ST_TO_ADDR
9353: LD_EXP 40
9357: PUSH
9358: FOR_TO
9359: IFFALSE 9401
// if not IsInUnit ( ru2_sci [ i ] ) then
9361: LD_EXP 40
9365: PUSH
9366: LD_VAR 0 1
9370: ARRAY
9371: PPUSH
9372: CALL_OW 310
9376: NOT
9377: IFFALSE 9399
// ComEnterUnit ( ru2_sci [ i ] , b_labb ) ;
9379: LD_EXP 40
9383: PUSH
9384: LD_VAR 0 1
9388: ARRAY
9389: PPUSH
9390: LD_VAR 0 11
9394: PPUSH
9395: CALL_OW 120
9399: GO 9358
9401: POP
9402: POP
// if ru2_tech > 0 then
9403: LD_EXP 36
9407: PUSH
9408: LD_INT 0
9410: GREATER
9411: IFFALSE 9464
// if BuildingStatus ( b_labb ) = bs_idle then
9413: LD_VAR 0 11
9417: PPUSH
9418: CALL_OW 461
9422: PUSH
9423: LD_INT 2
9425: EQUAL
9426: IFFALSE 9464
// begin ComResearch ( b_labb , ru2_tech [ 1 ] ) ;
9428: LD_VAR 0 11
9432: PPUSH
9433: LD_EXP 36
9437: PUSH
9438: LD_INT 1
9440: ARRAY
9441: PPUSH
9442: CALL_OW 124
// ru2_tech := Delete ( ru2_tech , 1 ) ;
9446: LD_ADDR_EXP 36
9450: PUSH
9451: LD_EXP 36
9455: PPUSH
9456: LD_INT 1
9458: PPUSH
9459: CALL_OW 3
9463: ST_TO_ADDR
// end ; end ; end ; end ;
9464: PPOPN 13
9466: END
// every 0 0$01 trigger russian_produce do
9467: LD_EXP 20
9471: IFFALSE 9920
9473: GO 9475
9475: DISABLE
// begin case global_diff of 1 :
9476: LD_EXP 3
9480: PUSH
9481: LD_INT 1
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9553
9489: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9490: LD_ADDR_EXP 27
9494: PUSH
9495: LD_EXP 27
9499: PUSH
9500: LD_INT 21
9502: PUSH
9503: LD_INT 1
9505: PUSH
9506: LD_INT 1
9508: PUSH
9509: LD_INT 42
9511: PUSH
9512: LD_INT 21
9514: PUSH
9515: LD_INT 1
9517: PUSH
9518: LD_INT 1
9520: PUSH
9521: LD_INT 42
9523: PUSH
9524: LD_INT 21
9526: PUSH
9527: LD_INT 1
9529: PUSH
9530: LD_INT 1
9532: PUSH
9533: LD_INT 43
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: LIST
9540: LIST
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: ADD
9550: ST_TO_ADDR
9551: GO 9698
9553: LD_INT 2
9555: DOUBLE
9556: EQUAL
9557: IFTRUE 9561
9559: GO 9625
9561: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9562: LD_ADDR_EXP 27
9566: PUSH
9567: LD_EXP 27
9571: PUSH
9572: LD_INT 21
9574: PUSH
9575: LD_INT 1
9577: PUSH
9578: LD_INT 1
9580: PUSH
9581: LD_INT 44
9583: PUSH
9584: LD_INT 22
9586: PUSH
9587: LD_INT 1
9589: PUSH
9590: LD_INT 1
9592: PUSH
9593: LD_INT 42
9595: PUSH
9596: LD_INT 22
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: LD_INT 1
9604: PUSH
9605: LD_INT 43
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: ADD
9622: ST_TO_ADDR
9623: GO 9698
9625: LD_INT 3
9627: DOUBLE
9628: EQUAL
9629: IFTRUE 9633
9631: GO 9697
9633: POP
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_rocket_launcher ] ; end ;
9634: LD_ADDR_EXP 27
9638: PUSH
9639: LD_EXP 27
9643: PUSH
9644: LD_INT 23
9646: PUSH
9647: LD_INT 1
9649: PUSH
9650: LD_INT 1
9652: PUSH
9653: LD_INT 43
9655: PUSH
9656: LD_INT 22
9658: PUSH
9659: LD_INT 1
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 44
9667: PUSH
9668: LD_INT 22
9670: PUSH
9671: LD_INT 1
9673: PUSH
9674: LD_INT 1
9676: PUSH
9677: LD_INT 45
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: ADD
9694: ST_TO_ADDR
9695: GO 9698
9697: POP
// case global_diff of 1 :
9698: LD_EXP 3
9702: PUSH
9703: LD_INT 1
9705: DOUBLE
9706: EQUAL
9707: IFTRUE 9711
9709: GO 9775
9711: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9712: LD_ADDR_EXP 37
9716: PUSH
9717: LD_EXP 37
9721: PUSH
9722: LD_INT 21
9724: PUSH
9725: LD_INT 1
9727: PUSH
9728: LD_INT 1
9730: PUSH
9731: LD_INT 42
9733: PUSH
9734: LD_INT 21
9736: PUSH
9737: LD_INT 1
9739: PUSH
9740: LD_INT 1
9742: PUSH
9743: LD_INT 42
9745: PUSH
9746: LD_INT 21
9748: PUSH
9749: LD_INT 1
9751: PUSH
9752: LD_INT 1
9754: PUSH
9755: LD_INT 43
9757: PUSH
9758: EMPTY
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: LIST
9764: LIST
9765: LIST
9766: LIST
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: ADD
9772: ST_TO_ADDR
9773: GO 9920
9775: LD_INT 2
9777: DOUBLE
9778: EQUAL
9779: IFTRUE 9783
9781: GO 9847
9783: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9784: LD_ADDR_EXP 37
9788: PUSH
9789: LD_EXP 37
9793: PUSH
9794: LD_INT 21
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: LD_INT 1
9802: PUSH
9803: LD_INT 44
9805: PUSH
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: LD_INT 1
9814: PUSH
9815: LD_INT 44
9817: PUSH
9818: LD_INT 22
9820: PUSH
9821: LD_INT 1
9823: PUSH
9824: LD_INT 1
9826: PUSH
9827: LD_INT 43
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: ADD
9844: ST_TO_ADDR
9845: GO 9920
9847: LD_INT 3
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9919
9855: POP
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
9856: LD_ADDR_EXP 37
9860: PUSH
9861: LD_EXP 37
9865: PUSH
9866: LD_INT 23
9868: PUSH
9869: LD_INT 1
9871: PUSH
9872: LD_INT 1
9874: PUSH
9875: LD_INT 42
9877: PUSH
9878: LD_INT 22
9880: PUSH
9881: LD_INT 1
9883: PUSH
9884: LD_INT 1
9886: PUSH
9887: LD_INT 44
9889: PUSH
9890: LD_INT 22
9892: PUSH
9893: LD_INT 1
9895: PUSH
9896: LD_INT 1
9898: PUSH
9899: LD_INT 44
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: ADD
9916: ST_TO_ADDR
9917: GO 9920
9919: POP
// end ;
9920: END
// every 12 12$00 trigger timer >= [ 26 26$00 , 21 21$00 , 16 16$00 ] [ global_diff ] and FilterAllUnits ( [ f_side , 3 ] ) > 0 do var veh , i , p , area ;
9921: LD_EXP 2
9925: PUSH
9926: LD_INT 54600
9928: PUSH
9929: LD_INT 44100
9931: PUSH
9932: LD_INT 33600
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: LIST
9939: PUSH
9940: LD_EXP 3
9944: ARRAY
9945: GREATEREQUAL
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PPUSH
9957: CALL_OW 69
9961: PUSH
9962: LD_INT 0
9964: GREATER
9965: AND
9966: IFFALSE 10182
9968: GO 9970
9970: DISABLE
9971: LD_INT 0
9973: PPUSH
9974: PPUSH
9975: PPUSH
9976: PPUSH
// begin enable ;
9977: ENABLE
// uc_side := [ 3 , 6 ] [ Rand ( 1 , 2 ) ] ;
9978: LD_ADDR_OWVAR 20
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 1
9995: PPUSH
9996: LD_INT 2
9998: PPUSH
9999: CALL_OW 12
10003: ARRAY
10004: ST_TO_ADDR
// uc_nation := 3 ;
10005: LD_ADDR_OWVAR 21
10009: PUSH
10010: LD_INT 3
10012: ST_TO_ADDR
// area := [ ru_west , south_spawn ] ;
10013: LD_ADDR_VAR 0 4
10017: PUSH
10018: LD_INT 18
10020: PUSH
10021: LD_INT 7
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
10028: LD_ADDR_VAR 0 3
10032: PUSH
10033: LD_INT 1
10035: PPUSH
10036: LD_INT 2
10038: PPUSH
10039: CALL_OW 12
10043: ST_TO_ADDR
// for i = 1 to Rand ( 1 , 2 ) do
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: DOUBLE
10050: LD_INT 1
10052: DEC
10053: ST_TO_ADDR
10054: LD_INT 1
10056: PPUSH
10057: LD_INT 2
10059: PPUSH
10060: CALL_OW 12
10064: PUSH
10065: FOR_TO
10066: IFFALSE 10180
// begin vc_chassis := ru_medium_tracked ;
10068: LD_ADDR_OWVAR 37
10072: PUSH
10073: LD_INT 22
10075: ST_TO_ADDR
// vc_engine := engine_combustion ;
10076: LD_ADDR_OWVAR 39
10080: PUSH
10081: LD_INT 1
10083: ST_TO_ADDR
// vc_control := control_manual ;
10084: LD_ADDR_OWVAR 38
10088: PUSH
10089: LD_INT 1
10091: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
10092: LD_ADDR_OWVAR 40
10096: PUSH
10097: LD_INT 43
10099: PUSH
10100: LD_INT 44
10102: PUSH
10103: LD_INT 45
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: PUSH
10111: LD_INT 1
10113: PPUSH
10114: LD_INT 3
10116: PPUSH
10117: CALL_OW 12
10121: ARRAY
10122: ST_TO_ADDR
// veh := CreateVehicle ;
10123: LD_ADDR_VAR 0 1
10127: PUSH
10128: CALL_OW 45
10132: ST_TO_ADDR
// PlaceUnitArea ( veh , area [ p ] , false ) ;
10133: LD_VAR 0 1
10137: PPUSH
10138: LD_VAR 0 4
10142: PUSH
10143: LD_VAR 0 3
10147: ARRAY
10148: PPUSH
10149: LD_INT 0
10151: PPUSH
10152: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_def ) , veh ) ;
10156: LD_INT 3
10158: PPUSH
10159: LD_EXP 5
10163: PPUSH
10164: CALL 418 0 2
10168: PPUSH
10169: LD_VAR 0 1
10173: PPUSH
10174: CALL_OW 52
// end ;
10178: GO 10065
10180: POP
10181: POP
// end ;
10182: PPOPN 4
10184: END
// every 4 4$35 trigger FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) >= 6 do var filter , enemy , i , _list ;
10185: LD_INT 2
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_INT 6
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 21
10215: PUSH
10216: LD_INT 2
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 2
10228: PUSH
10229: LD_INT 34
10231: PUSH
10232: LD_INT 52
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: PUSH
10239: LD_INT 34
10241: PUSH
10242: LD_INT 51
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: PUSH
10249: LD_INT 34
10251: PUSH
10252: LD_INT 53
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: LIST
10273: PPUSH
10274: CALL_OW 69
10278: PUSH
10279: LD_INT 6
10281: GREATEREQUAL
10282: IFFALSE 10522
10284: GO 10286
10286: DISABLE
10287: LD_INT 0
10289: PPUSH
10290: PPUSH
10291: PPUSH
10292: PPUSH
// begin enable ;
10293: ENABLE
// _list := [ [ b_oil_mine , b_solar_power , b_oil_power ] , [ us_cargo_bay ] , [ ] ] ;
10294: LD_ADDR_VAR 0 4
10298: PUSH
10299: LD_INT 29
10301: PUSH
10302: LD_INT 27
10304: PUSH
10305: LD_INT 26
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 12
10315: PUSH
10316: EMPTY
10317: LIST
10318: PUSH
10319: EMPTY
10320: PUSH
10321: EMPTY
10322: LIST
10323: LIST
10324: LIST
10325: ST_TO_ADDR
// filter := ru_list_attackers ;
10326: LD_ADDR_VAR 0 1
10330: PUSH
10331: LD_EXP 43
10335: ST_TO_ADDR
// while ( filter ) do
10336: LD_VAR 0 1
10340: IFFALSE 10522
// begin Wait ( 0 0$01 ) ;
10342: LD_INT 35
10344: PPUSH
10345: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10349: LD_INT 22
10351: PUSH
10352: LD_INT 2
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PPUSH
10359: CALL_OW 69
10363: PUSH
10364: LD_INT 0
10366: EQUAL
10367: IFFALSE 10409
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10369: LD_ADDR_VAR 0 2
10373: PUSH
10374: LD_INT 2
10376: PUSH
10377: LD_INT 22
10379: PUSH
10380: LD_INT 1
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 22
10389: PUSH
10390: LD_INT 4
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: PPUSH
10402: CALL_OW 69
10406: ST_TO_ADDR
10407: GO 10429
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10409: LD_ADDR_VAR 0 2
10413: PUSH
10414: LD_INT 22
10416: PUSH
10417: LD_INT 2
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PPUSH
10424: CALL_OW 69
10428: ST_TO_ADDR
// for i = filter downto 1 do
10429: LD_ADDR_VAR 0 3
10433: PUSH
10434: DOUBLE
10435: LD_VAR 0 1
10439: INC
10440: ST_TO_ADDR
10441: LD_INT 1
10443: PUSH
10444: FOR_DOWNTO
10445: IFFALSE 10509
// if not IsPlaced ( filter [ i ] ) then
10447: LD_VAR 0 1
10451: PUSH
10452: LD_VAR 0 3
10456: ARRAY
10457: PPUSH
10458: CALL_OW 305
10462: NOT
10463: IFFALSE 10487
// filter := Delete ( filter , i ) else
10465: LD_ADDR_VAR 0 1
10469: PUSH
10470: LD_VAR 0 1
10474: PPUSH
10475: LD_VAR 0 3
10479: PPUSH
10480: CALL_OW 3
10484: ST_TO_ADDR
10485: GO 10507
// ComAttack ( filter [ i ] , _list ) ;
10487: LD_VAR 0 1
10491: PUSH
10492: LD_VAR 0 3
10496: ARRAY
10497: PPUSH
10498: LD_VAR 0 4
10502: PPUSH
10503: CALL 985 0 2
10507: GO 10444
10509: POP
10510: POP
// if not filter then
10511: LD_VAR 0 1
10515: NOT
10516: IFFALSE 10520
// break ;
10518: GO 10522
// end ;
10520: GO 10336
// end ;
10522: PPOPN 4
10524: END
// export ru_spec_group ; every 0 0$10 trigger FilterUnitsInArea ( buffor , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 do var i , un , veh ;
10525: LD_INT 22
10527: PPUSH
10528: LD_INT 22
10530: PUSH
10531: LD_INT 1
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 21
10540: PUSH
10541: LD_INT 3
10543: PUSH
10544: EMPTY
10545: LIST
10546: LIST
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: PPUSH
10552: CALL_OW 70
10556: PUSH
10557: LD_INT 0
10559: GREATER
10560: IFFALSE 10705
10562: GO 10564
10564: DISABLE
10565: LD_INT 0
10567: PPUSH
10568: PPUSH
10569: PPUSH
// begin uc_side := 6 ;
10570: LD_ADDR_OWVAR 20
10574: PUSH
10575: LD_INT 6
10577: ST_TO_ADDR
// uc_nation := 3 ;
10578: LD_ADDR_OWVAR 21
10582: PUSH
10583: LD_INT 3
10585: ST_TO_ADDR
// for i = 1 to Difficulty + 1 do
10586: LD_ADDR_VAR 0 1
10590: PUSH
10591: DOUBLE
10592: LD_INT 1
10594: DEC
10595: ST_TO_ADDR
10596: LD_OWVAR 67
10600: PUSH
10601: LD_INT 1
10603: PLUS
10604: PUSH
10605: FOR_TO
10606: IFFALSE 10700
// begin vc_chassis := ru_medium_tracked ;
10608: LD_ADDR_OWVAR 37
10612: PUSH
10613: LD_INT 22
10615: ST_TO_ADDR
// vc_engine := engine_combustion ;
10616: LD_ADDR_OWVAR 39
10620: PUSH
10621: LD_INT 1
10623: ST_TO_ADDR
// vc_control := control_manual ;
10624: LD_ADDR_OWVAR 38
10628: PUSH
10629: LD_INT 1
10631: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10632: LD_ADDR_OWVAR 40
10636: PUSH
10637: LD_INT 45
10639: ST_TO_ADDR
// veh := CreateVehicle ;
10640: LD_ADDR_VAR 0 3
10644: PUSH
10645: CALL_OW 45
10649: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
10650: LD_ADDR_VAR 0 2
10654: PUSH
10655: LD_INT 3
10657: PPUSH
10658: LD_EXP 5
10662: PPUSH
10663: CALL 418 0 2
10667: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10668: LD_VAR 0 2
10672: PPUSH
10673: LD_VAR 0 3
10677: PPUSH
10678: CALL_OW 52
// ru_spec_group := ru_spec_group ^ veh ;
10682: LD_ADDR_EXP 45
10686: PUSH
10687: LD_EXP 45
10691: PUSH
10692: LD_VAR 0 3
10696: ADD
10697: ST_TO_ADDR
// end ;
10698: GO 10605
10700: POP
10701: POP
// enable ( 99 ) ;
10702: LD_INT 99
10704: ENABLE_MARKED
// end ;
10705: PPOPN 3
10707: END
// every 0 0$01 trigger ru_spec_group marked 99 do var i , enemy , filter ;
10708: LD_EXP 45
10712: IFFALSE 10881
10714: GO 10716
10716: DISABLE
10717: LD_INT 0
10719: PPUSH
10720: PPUSH
10721: PPUSH
// begin enable ;
10722: ENABLE
// filter := ru_spec_group ;
10723: LD_ADDR_VAR 0 3
10727: PUSH
10728: LD_EXP 45
10732: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10733: LD_INT 22
10735: PUSH
10736: LD_INT 2
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 69
10747: PUSH
10748: LD_INT 0
10750: EQUAL
10751: IFFALSE 10793
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10753: LD_ADDR_VAR 0 2
10757: PUSH
10758: LD_INT 2
10760: PUSH
10761: LD_INT 22
10763: PUSH
10764: LD_INT 1
10766: PUSH
10767: EMPTY
10768: LIST
10769: LIST
10770: PUSH
10771: LD_INT 22
10773: PUSH
10774: LD_INT 4
10776: PUSH
10777: EMPTY
10778: LIST
10779: LIST
10780: PUSH
10781: EMPTY
10782: LIST
10783: LIST
10784: LIST
10785: PPUSH
10786: CALL_OW 69
10790: ST_TO_ADDR
10791: GO 10813
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10793: LD_ADDR_VAR 0 2
10797: PUSH
10798: LD_INT 22
10800: PUSH
10801: LD_INT 2
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: PPUSH
10808: CALL_OW 69
10812: ST_TO_ADDR
// if filter > 0 then
10813: LD_VAR 0 3
10817: PUSH
10818: LD_INT 0
10820: GREATER
10821: IFFALSE 10881
// for i = 1 to filter do
10823: LD_ADDR_VAR 0 1
10827: PUSH
10828: DOUBLE
10829: LD_INT 1
10831: DEC
10832: ST_TO_ADDR
10833: LD_VAR 0 3
10837: PUSH
10838: FOR_TO
10839: IFFALSE 10879
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
10841: LD_VAR 0 3
10845: PUSH
10846: LD_VAR 0 1
10850: ARRAY
10851: PPUSH
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_VAR 0 3
10861: PUSH
10862: LD_VAR 0 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 74
10872: PPUSH
10873: CALL_OW 115
10877: GO 10838
10879: POP
10880: POP
// end ; end_of_file
10881: PPOPN 3
10883: END
// export function ArabianAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
10884: LD_INT 0
10886: PPUSH
10887: PPUSH
10888: PPUSH
10889: PPUSH
10890: PPUSH
10891: PPUSH
10892: PPUSH
// uc_side := side ;
10893: LD_ADDR_OWVAR 20
10897: PUSH
10898: LD_VAR 0 1
10902: ST_TO_ADDR
// uc_nation := nation_arabian ;
10903: LD_ADDR_OWVAR 21
10907: PUSH
10908: LD_INT 2
10910: ST_TO_ADDR
// chassis := [ ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
10911: LD_ADDR_VAR 0 10
10915: PUSH
10916: LD_INT 12
10918: PUSH
10919: LD_INT 13
10921: PUSH
10922: LD_INT 14
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: ST_TO_ADDR
// weapon := [ ar_multimissile_ballista , ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher ] ;
10930: LD_ADDR_VAR 0 11
10934: PUSH
10935: LD_INT 22
10937: PUSH
10938: LD_INT 24
10940: PUSH
10941: LD_INT 25
10943: PUSH
10944: LD_INT 27
10946: PUSH
10947: LD_INT 28
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: ST_TO_ADDR
// case typ of 1 :
10957: LD_VAR 0 3
10961: PUSH
10962: LD_INT 1
10964: DOUBLE
10965: EQUAL
10966: IFTRUE 10970
10968: GO 11195
10970: POP
// begin for i = 1 to num do
10971: LD_ADDR_VAR 0 6
10975: PUSH
10976: DOUBLE
10977: LD_INT 1
10979: DEC
10980: ST_TO_ADDR
10981: LD_VAR 0 2
10985: PUSH
10986: FOR_TO
10987: IFFALSE 11146
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
10989: LD_ADDR_OWVAR 37
10993: PUSH
10994: LD_VAR 0 10
10998: PUSH
10999: LD_INT 1
11001: PPUSH
11002: LD_INT 2
11004: PPUSH
11005: CALL_OW 12
11009: ARRAY
11010: ST_TO_ADDR
// vc_engine := engine_combustion ;
11011: LD_ADDR_OWVAR 39
11015: PUSH
11016: LD_INT 1
11018: ST_TO_ADDR
// vc_control := control_manual ;
11019: LD_ADDR_OWVAR 38
11023: PUSH
11024: LD_INT 1
11026: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 2 ) ] ;
11027: LD_ADDR_OWVAR 40
11031: PUSH
11032: LD_VAR 0 11
11036: PUSH
11037: LD_INT 1
11039: PPUSH
11040: LD_INT 2
11042: PPUSH
11043: CALL_OW 12
11047: ARRAY
11048: ST_TO_ADDR
// veh := CreateVehicle ;
11049: LD_ADDR_VAR 0 9
11053: PUSH
11054: CALL_OW 45
11058: ST_TO_ADDR
// if area = ar_area1 then
11059: LD_VAR 0 4
11063: PUSH
11064: LD_INT 6
11066: EQUAL
11067: IFFALSE 11083
// SetDir ( veh , 3 ) else
11069: LD_VAR 0 9
11073: PPUSH
11074: LD_INT 3
11076: PPUSH
11077: CALL_OW 233
11081: GO 11095
// SetDir ( veh , 0 ) ;
11083: LD_VAR 0 9
11087: PPUSH
11088: LD_INT 0
11090: PPUSH
11091: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11095: LD_VAR 0 9
11099: PPUSH
11100: LD_VAR 0 4
11104: PPUSH
11105: LD_INT 0
11107: PPUSH
11108: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11112: LD_ADDR_VAR 0 7
11116: PUSH
11117: LD_INT 1
11119: PPUSH
11120: LD_EXP 8
11124: PPUSH
11125: CALL 418 0 2
11129: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11130: LD_VAR 0 7
11134: PPUSH
11135: LD_VAR 0 9
11139: PPUSH
11140: CALL_OW 52
// end ;
11144: GO 10986
11146: POP
11147: POP
// for i = 1 to 3 do
11148: LD_ADDR_VAR 0 6
11152: PUSH
11153: DOUBLE
11154: LD_INT 1
11156: DEC
11157: ST_TO_ADDR
11158: LD_INT 3
11160: PUSH
11161: FOR_TO
11162: IFFALSE 11191
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , ar_def ) , area , false ) ;
11164: LD_INT 8
11166: PPUSH
11167: LD_EXP 8
11171: PPUSH
11172: CALL 418 0 2
11176: PPUSH
11177: LD_VAR 0 4
11181: PPUSH
11182: LD_INT 0
11184: PPUSH
11185: CALL_OW 49
11189: GO 11161
11191: POP
11192: POP
// end ; 2 :
11193: GO 11462
11195: LD_INT 2
11197: DOUBLE
11198: EQUAL
11199: IFTRUE 11203
11201: GO 11461
11203: POP
// begin for i = 1 to num do
11204: LD_ADDR_VAR 0 6
11208: PUSH
11209: DOUBLE
11210: LD_INT 1
11212: DEC
11213: ST_TO_ADDR
11214: LD_VAR 0 2
11218: PUSH
11219: FOR_TO
11220: IFFALSE 11379
// begin vc_chassis := chassis [ Rand ( 2 , 3 ) ] ;
11222: LD_ADDR_OWVAR 37
11226: PUSH
11227: LD_VAR 0 10
11231: PUSH
11232: LD_INT 2
11234: PPUSH
11235: LD_INT 3
11237: PPUSH
11238: CALL_OW 12
11242: ARRAY
11243: ST_TO_ADDR
// vc_engine := engine_combustion ;
11244: LD_ADDR_OWVAR 39
11248: PUSH
11249: LD_INT 1
11251: ST_TO_ADDR
// vc_control := control_manual ;
11252: LD_ADDR_OWVAR 38
11256: PUSH
11257: LD_INT 1
11259: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
11260: LD_ADDR_OWVAR 40
11264: PUSH
11265: LD_VAR 0 11
11269: PUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 5
11275: PPUSH
11276: CALL_OW 12
11280: ARRAY
11281: ST_TO_ADDR
// veh := CreateVehicle ;
11282: LD_ADDR_VAR 0 9
11286: PUSH
11287: CALL_OW 45
11291: ST_TO_ADDR
// if area = ar_area1 then
11292: LD_VAR 0 4
11296: PUSH
11297: LD_INT 6
11299: EQUAL
11300: IFFALSE 11316
// SetDir ( veh , 3 ) else
11302: LD_VAR 0 9
11306: PPUSH
11307: LD_INT 3
11309: PPUSH
11310: CALL_OW 233
11314: GO 11328
// SetDir ( veh , 0 ) ;
11316: LD_VAR 0 9
11320: PPUSH
11321: LD_INT 0
11323: PPUSH
11324: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11328: LD_VAR 0 9
11332: PPUSH
11333: LD_VAR 0 4
11337: PPUSH
11338: LD_INT 0
11340: PPUSH
11341: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11345: LD_ADDR_VAR 0 7
11349: PUSH
11350: LD_INT 1
11352: PPUSH
11353: LD_EXP 8
11357: PPUSH
11358: CALL 418 0 2
11362: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11363: LD_VAR 0 7
11367: PPUSH
11368: LD_VAR 0 9
11372: PPUSH
11373: CALL_OW 52
// end ;
11377: GO 11219
11379: POP
11380: POP
// for i = 1 to 2 do
11381: LD_ADDR_VAR 0 6
11385: PUSH
11386: DOUBLE
11387: LD_INT 1
11389: DEC
11390: ST_TO_ADDR
11391: LD_INT 2
11393: PUSH
11394: FOR_TO
11395: IFFALSE 11457
// begin uc_nation := 0 ;
11397: LD_ADDR_OWVAR 21
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// hc_class := 17 ;
11405: LD_ADDR_OWVAR 28
11409: PUSH
11410: LD_INT 17
11412: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
11413: LD_ADDR_OWVAR 29
11417: PUSH
11418: LD_INT 11
11420: PUSH
11421: LD_INT 13
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: ST_TO_ADDR
// un := CreateHuman ;
11428: LD_ADDR_VAR 0 7
11432: PUSH
11433: CALL_OW 44
11437: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
11438: LD_VAR 0 7
11442: PPUSH
11443: LD_VAR 0 4
11447: PPUSH
11448: LD_INT 0
11450: PPUSH
11451: CALL_OW 49
// end ;
11455: GO 11394
11457: POP
11458: POP
// end ; end ;
11459: GO 11462
11461: POP
// end ;
11462: LD_VAR 0 5
11466: RET
// export function FHeike ; begin
11467: LD_INT 0
11469: PPUSH
// uc_side := 2 ;
11470: LD_ADDR_OWVAR 20
11474: PUSH
11475: LD_INT 2
11477: ST_TO_ADDR
// uc_nation := 2 ;
11478: LD_ADDR_OWVAR 21
11482: PUSH
11483: LD_INT 2
11485: ST_TO_ADDR
// hc_gallery := sandar ;
11486: LD_ADDR_OWVAR 33
11490: PUSH
11491: LD_STRING sandar
11493: ST_TO_ADDR
// hc_face_number := 2 ;
11494: LD_ADDR_OWVAR 34
11498: PUSH
11499: LD_INT 2
11501: ST_TO_ADDR
// hc_name := Heike Steyer ;
11502: LD_ADDR_OWVAR 26
11506: PUSH
11507: LD_STRING Heike Steyer
11509: ST_TO_ADDR
// hc_sex := sex_female ;
11510: LD_ADDR_OWVAR 27
11514: PUSH
11515: LD_INT 2
11517: ST_TO_ADDR
// hc_class := 1 ;
11518: LD_ADDR_OWVAR 28
11522: PUSH
11523: LD_INT 1
11525: ST_TO_ADDR
// heike := CreateHuman ;
11526: LD_ADDR_EXP 16
11530: PUSH
11531: CALL_OW 44
11535: ST_TO_ADDR
// end ;
11536: LD_VAR 0 1
11540: RET
// every 0 0$01 do var filter , enemy , i ;
11541: GO 11543
11543: DISABLE
11544: LD_INT 0
11546: PPUSH
11547: PPUSH
11548: PPUSH
// begin enable ;
11549: ENABLE
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
11550: LD_ADDR_VAR 0 1
11554: PUSH
11555: LD_INT 22
11557: PUSH
11558: LD_INT 2
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
11570: LD_ADDR_VAR 0 2
11574: PUSH
11575: LD_INT 2
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_INT 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 22
11590: PUSH
11591: LD_INT 3
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: LD_INT 22
11600: PUSH
11601: LD_INT 6
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: PPUSH
11614: CALL_OW 69
11618: ST_TO_ADDR
// if filter > 0 then
11619: LD_VAR 0 1
11623: PUSH
11624: LD_INT 0
11626: GREATER
11627: IFFALSE 11687
// for i = 1 to filter do
11629: LD_ADDR_VAR 0 3
11633: PUSH
11634: DOUBLE
11635: LD_INT 1
11637: DEC
11638: ST_TO_ADDR
11639: LD_VAR 0 1
11643: PUSH
11644: FOR_TO
11645: IFFALSE 11685
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
11647: LD_VAR 0 1
11651: PUSH
11652: LD_VAR 0 3
11656: ARRAY
11657: PPUSH
11658: LD_VAR 0 2
11662: PPUSH
11663: LD_VAR 0 1
11667: PUSH
11668: LD_VAR 0 3
11672: ARRAY
11673: PPUSH
11674: CALL_OW 74
11678: PPUSH
11679: CALL_OW 115
11683: GO 11644
11685: POP
11686: POP
// end ; end_of_file
11687: PPOPN 3
11689: END
// on UnitDestroyed ( un ) do begin if un = sikorski then
11690: LD_VAR 0 1
11694: PUSH
11695: LD_EXP 14
11699: EQUAL
11700: IFFALSE 11709
// YouLost ( sik ) ;
11702: LD_STRING sik
11704: PPUSH
11705: CALL_OW 104
// if un = omikron then
11709: LD_VAR 0 1
11713: PUSH
11714: LD_INT 64
11716: EQUAL
11717: IFFALSE 11726
// YouLost ( omi ) ;
11719: LD_STRING omi
11721: PPUSH
11722: CALL_OW 104
// if un in ru_list_attackers then
11726: LD_VAR 0 1
11730: PUSH
11731: LD_EXP 43
11735: IN
11736: IFFALSE 11754
// ru_list_attackers := ru_list_attackers diff un ;
11738: LD_ADDR_EXP 43
11742: PUSH
11743: LD_EXP 43
11747: PUSH
11748: LD_VAR 0 1
11752: DIFF
11753: ST_TO_ADDR
// if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
11754: LD_VAR 0 1
11758: PPUSH
11759: CALL_OW 255
11763: PUSH
11764: LD_INT 6
11766: EQUAL
11767: PUSH
11768: LD_VAR 0 1
11772: PUSH
11773: LD_INT 21
11775: PUSH
11776: LD_INT 3
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PPUSH
11783: CALL_OW 69
11787: IN
11788: AND
11789: IFFALSE 12008
// begin if GetBType ( un ) = b_factory then
11791: LD_VAR 0 1
11795: PPUSH
11796: CALL_OW 266
11800: PUSH
11801: LD_INT 3
11803: EQUAL
11804: IFFALSE 11820
// ru_bul := ru_bul ^ b_workshop ;
11806: LD_ADDR_EXP 31
11810: PUSH
11811: LD_EXP 31
11815: PUSH
11816: LD_INT 2
11818: ADD
11819: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
11820: LD_VAR 0 1
11824: PPUSH
11825: CALL_OW 266
11829: PUSH
11830: LD_INT 8
11832: EQUAL
11833: PUSH
11834: LD_VAR 0 1
11838: PPUSH
11839: CALL_OW 266
11843: PUSH
11844: LD_INT 7
11846: EQUAL
11847: OR
11848: IFFALSE 11864
// ru_bul := ru_bul ^ b_lab ;
11850: LD_ADDR_EXP 31
11854: PUSH
11855: LD_EXP 31
11859: PUSH
11860: LD_INT 6
11862: ADD
11863: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11864: LD_VAR 0 1
11868: PPUSH
11869: CALL_OW 266
11873: PUSH
11874: LD_INT 5
11876: EQUAL
11877: IFFALSE 11893
// ru_bul := ru_bul ^ b_armoury ;
11879: LD_ADDR_EXP 31
11883: PUSH
11884: LD_EXP 31
11888: PUSH
11889: LD_INT 4
11891: ADD
11892: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks ] then
11893: LD_VAR 0 1
11897: PPUSH
11898: CALL_OW 266
11902: PUSH
11903: LD_INT 3
11905: PUSH
11906: LD_INT 8
11908: PUSH
11909: LD_INT 7
11911: PUSH
11912: LD_INT 5
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: LIST
11919: LIST
11920: IN
11921: NOT
11922: IFFALSE 11945
// ru_bul := ru_bul ^ GetBType ( un ) ;
11924: LD_ADDR_EXP 31
11928: PUSH
11929: LD_EXP 31
11933: PUSH
11934: LD_VAR 0 1
11938: PPUSH
11939: CALL_OW 266
11943: ADD
11944: ST_TO_ADDR
// ru_bul := ru_bul ^ GetX ( un ) ;
11945: LD_ADDR_EXP 31
11949: PUSH
11950: LD_EXP 31
11954: PUSH
11955: LD_VAR 0 1
11959: PPUSH
11960: CALL_OW 250
11964: ADD
11965: ST_TO_ADDR
// ru_bul := ru_bul ^ GetY ( un ) ;
11966: LD_ADDR_EXP 31
11970: PUSH
11971: LD_EXP 31
11975: PUSH
11976: LD_VAR 0 1
11980: PPUSH
11981: CALL_OW 251
11985: ADD
11986: ST_TO_ADDR
// ru_bul := ru_bul ^ GetDir ( un ) ;
11987: LD_ADDR_EXP 31
11991: PUSH
11992: LD_EXP 31
11996: PUSH
11997: LD_VAR 0 1
12001: PPUSH
12002: CALL_OW 254
12006: ADD
12007: ST_TO_ADDR
// end ; if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12008: LD_VAR 0 1
12012: PPUSH
12013: CALL_OW 255
12017: PUSH
12018: LD_INT 6
12020: EQUAL
12021: PUSH
12022: LD_VAR 0 1
12026: PUSH
12027: LD_INT 21
12029: PUSH
12030: LD_INT 2
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: PPUSH
12037: CALL_OW 69
12041: PUSH
12042: LD_INT 34
12044: PUSH
12045: LD_INT 45
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PPUSH
12052: CALL_OW 69
12056: DIFF
12057: IN
12058: AND
12059: IFFALSE 12145
// begin ru_veh := ru_veh ^ GetChassis ( un ) ;
12061: LD_ADDR_EXP 27
12065: PUSH
12066: LD_EXP 27
12070: PUSH
12071: LD_VAR 0 1
12075: PPUSH
12076: CALL_OW 265
12080: ADD
12081: ST_TO_ADDR
// ru_veh := ru_veh ^ GetEngine ( un ) ;
12082: LD_ADDR_EXP 27
12086: PUSH
12087: LD_EXP 27
12091: PUSH
12092: LD_VAR 0 1
12096: PPUSH
12097: CALL_OW 262
12101: ADD
12102: ST_TO_ADDR
// ru_veh := ru_veh ^ GetControl ( un ) ;
12103: LD_ADDR_EXP 27
12107: PUSH
12108: LD_EXP 27
12112: PUSH
12113: LD_VAR 0 1
12117: PPUSH
12118: CALL_OW 263
12122: ADD
12123: ST_TO_ADDR
// ru_veh := ru_veh ^ GetWeapon ( un ) ;
12124: LD_ADDR_EXP 27
12128: PUSH
12129: LD_EXP 27
12133: PUSH
12134: LD_VAR 0 1
12138: PPUSH
12139: CALL_OW 264
12143: ADD
12144: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12145: LD_VAR 0 1
12149: PUSH
12150: LD_INT 22
12152: PUSH
12153: LD_INT 6
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 3
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PPUSH
12174: CALL_OW 69
12178: IN
12179: PUSH
12180: LD_INT 22
12182: PUSH
12183: LD_INT 6
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 30
12192: PUSH
12193: LD_INT 3
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: LD_INT 24
12202: PUSH
12203: LD_INT 251
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: PPUSH
12215: CALL_OW 69
12219: PUSH
12220: LD_INT 0
12222: GREATER
12223: AND
12224: IFFALSE 12272
// begin uc_side := 6 ;
12226: LD_ADDR_OWVAR 20
12230: PUSH
12231: LD_INT 6
12233: ST_TO_ADDR
// uc_nation := 3 ;
12234: LD_ADDR_OWVAR 21
12238: PUSH
12239: LD_INT 3
12241: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12242: LD_ADDR_VAR 0 1
12246: PUSH
12247: LD_INT 3
12249: PPUSH
12250: LD_EXP 5
12254: PPUSH
12255: CALL 418 0 2
12259: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
12260: LD_VAR 0 1
12264: PPUSH
12265: LD_INT 92
12267: PPUSH
12268: CALL_OW 52
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
12272: LD_VAR 0 1
12276: PPUSH
12277: CALL_OW 255
12281: PUSH
12282: LD_INT 3
12284: EQUAL
12285: PUSH
12286: LD_VAR 0 1
12290: PUSH
12291: LD_INT 21
12293: PUSH
12294: LD_INT 3
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PPUSH
12301: CALL_OW 69
12305: IN
12306: AND
12307: IFFALSE 12538
// begin if GetBType ( un ) = b_factory then
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 266
12318: PUSH
12319: LD_INT 3
12321: EQUAL
12322: IFFALSE 12338
// ru2_bul := ru2_bul ^ b_workshop ;
12324: LD_ADDR_EXP 41
12328: PUSH
12329: LD_EXP 41
12333: PUSH
12334: LD_INT 2
12336: ADD
12337: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
12338: LD_VAR 0 1
12342: PPUSH
12343: CALL_OW 266
12347: PUSH
12348: LD_INT 8
12350: EQUAL
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_INT 7
12364: EQUAL
12365: OR
12366: IFFALSE 12382
// ru2_bul := ru2_bul ^ b_lab ;
12368: LD_ADDR_EXP 41
12372: PUSH
12373: LD_EXP 41
12377: PUSH
12378: LD_INT 6
12380: ADD
12381: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 266
12391: PUSH
12392: LD_INT 5
12394: EQUAL
12395: IFFALSE 12411
// ru2_bul := ru2_bul ^ b_armoury ;
12397: LD_ADDR_EXP 41
12401: PUSH
12402: LD_EXP 41
12406: PUSH
12407: LD_INT 4
12409: ADD
12410: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks , b_ext_gun , b_ext_noncombat , b_ext_track ] then
12411: LD_VAR 0 1
12415: PPUSH
12416: CALL_OW 266
12420: PUSH
12421: LD_INT 3
12423: PUSH
12424: LD_INT 8
12426: PUSH
12427: LD_INT 7
12429: PUSH
12430: LD_INT 5
12432: PUSH
12433: LD_INT 17
12435: PUSH
12436: LD_INT 19
12438: PUSH
12439: LD_INT 16
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: IN
12451: NOT
12452: IFFALSE 12475
// ru2_bul := ru2_bul ^ GetBType ( un ) ;
12454: LD_ADDR_EXP 41
12458: PUSH
12459: LD_EXP 41
12463: PUSH
12464: LD_VAR 0 1
12468: PPUSH
12469: CALL_OW 266
12473: ADD
12474: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetX ( un ) ;
12475: LD_ADDR_EXP 41
12479: PUSH
12480: LD_EXP 41
12484: PUSH
12485: LD_VAR 0 1
12489: PPUSH
12490: CALL_OW 250
12494: ADD
12495: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetY ( un ) ;
12496: LD_ADDR_EXP 41
12500: PUSH
12501: LD_EXP 41
12505: PUSH
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 251
12515: ADD
12516: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetDir ( un ) ;
12517: LD_ADDR_EXP 41
12521: PUSH
12522: LD_EXP 41
12526: PUSH
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 254
12536: ADD
12537: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12538: LD_VAR 0 1
12542: PPUSH
12543: CALL_OW 255
12547: PUSH
12548: LD_INT 3
12550: EQUAL
12551: PUSH
12552: LD_VAR 0 1
12556: PUSH
12557: LD_INT 21
12559: PUSH
12560: LD_INT 2
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: PUSH
12572: LD_INT 34
12574: PUSH
12575: LD_INT 45
12577: PUSH
12578: EMPTY
12579: LIST
12580: LIST
12581: PPUSH
12582: CALL_OW 69
12586: DIFF
12587: IN
12588: AND
12589: IFFALSE 12675
// begin ru2_veh := ru2_veh ^ GetChassis ( un ) ;
12591: LD_ADDR_EXP 37
12595: PUSH
12596: LD_EXP 37
12600: PUSH
12601: LD_VAR 0 1
12605: PPUSH
12606: CALL_OW 265
12610: ADD
12611: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetEngine ( un ) ;
12612: LD_ADDR_EXP 37
12616: PUSH
12617: LD_EXP 37
12621: PUSH
12622: LD_VAR 0 1
12626: PPUSH
12627: CALL_OW 262
12631: ADD
12632: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetControl ( un ) ;
12633: LD_ADDR_EXP 37
12637: PUSH
12638: LD_EXP 37
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: CALL_OW 263
12652: ADD
12653: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetWeapon ( un ) ;
12654: LD_ADDR_EXP 37
12658: PUSH
12659: LD_EXP 37
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 264
12673: ADD
12674: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12675: LD_VAR 0 1
12679: PUSH
12680: LD_INT 22
12682: PUSH
12683: LD_INT 3
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: PUSH
12690: LD_INT 25
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: EMPTY
12701: LIST
12702: LIST
12703: PPUSH
12704: CALL_OW 69
12708: IN
12709: PUSH
12710: LD_INT 22
12712: PUSH
12713: LD_INT 3
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 3
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 24
12732: PUSH
12733: LD_INT 251
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: LIST
12744: PPUSH
12745: CALL_OW 69
12749: PUSH
12750: LD_INT 0
12752: GREATER
12753: AND
12754: IFFALSE 12832
// begin uc_side := 3 ;
12756: LD_ADDR_OWVAR 20
12760: PUSH
12761: LD_INT 3
12763: ST_TO_ADDR
// uc_nation := 3 ;
12764: LD_ADDR_OWVAR 21
12768: PUSH
12769: LD_INT 3
12771: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12772: LD_ADDR_VAR 0 1
12776: PUSH
12777: LD_INT 3
12779: PPUSH
12780: LD_EXP 5
12784: PPUSH
12785: CALL 418 0 2
12789: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12790: LD_VAR 0 1
12794: PPUSH
12795: LD_INT 22
12797: PUSH
12798: LD_INT 3
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 30
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: PPUSH
12828: CALL_OW 52
// end ; end ;
12832: PPOPN 1
12834: END
// on VehicleConstructed ( veh , fac ) do begin if veh in FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) then
12835: LD_VAR 0 1
12839: PUSH
12840: LD_INT 2
12842: PUSH
12843: LD_INT 22
12845: PUSH
12846: LD_INT 6
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 22
12855: PUSH
12856: LD_INT 3
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 21
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 2
12883: PUSH
12884: LD_INT 34
12886: PUSH
12887: LD_INT 52
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 34
12896: PUSH
12897: LD_INT 51
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: PUSH
12904: LD_INT 34
12906: PUSH
12907: LD_INT 53
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: IN
12934: IFFALSE 12959
// ru_list_attackers := Insert ( ru_list_attackers , 1 , veh ) ;
12936: LD_ADDR_EXP 43
12940: PUSH
12941: LD_EXP 43
12945: PPUSH
12946: LD_INT 1
12948: PPUSH
12949: LD_VAR 0 1
12953: PPUSH
12954: CALL_OW 2
12958: ST_TO_ADDR
// end ;
12959: PPOPN 2
12961: END
// on BuildingComplete ( b ) do var i ;
12962: LD_INT 0
12964: PPUSH
// begin if b in FilterAllUnits ( [ f_side , 6 ] ) then
12965: LD_VAR 0 1
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_INT 6
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PPUSH
12980: CALL_OW 69
12984: IN
12985: IFFALSE 13025
// for i = 1 to 4 do
12987: LD_ADDR_VAR 0 2
12991: PUSH
12992: DOUBLE
12993: LD_INT 1
12995: DEC
12996: ST_TO_ADDR
12997: LD_INT 4
12999: PUSH
13000: FOR_TO
13001: IFFALSE 13023
// ru_bul := Delete ( ru_bul , 1 ) ;
13003: LD_ADDR_EXP 31
13007: PUSH
13008: LD_EXP 31
13012: PPUSH
13013: LD_INT 1
13015: PPUSH
13016: CALL_OW 3
13020: ST_TO_ADDR
13021: GO 13000
13023: POP
13024: POP
// if b in FilterAllUnits ( [ f_side , 3 ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 3
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 69
13044: IN
13045: IFFALSE 13085
// for i = 1 to 4 do
13047: LD_ADDR_VAR 0 2
13051: PUSH
13052: DOUBLE
13053: LD_INT 1
13055: DEC
13056: ST_TO_ADDR
13057: LD_INT 4
13059: PUSH
13060: FOR_TO
13061: IFFALSE 13083
// ru2_bul := Delete ( ru2_bul , 1 ) ;
13063: LD_ADDR_EXP 41
13067: PUSH
13068: LD_EXP 41
13072: PPUSH
13073: LD_INT 1
13075: PPUSH
13076: CALL_OW 3
13080: ST_TO_ADDR
13081: GO 13060
13083: POP
13084: POP
// end ; end_of_file
13085: PPOPN 2
13087: END
// export function Start_Game ; begin
13088: LD_INT 0
13090: PPUSH
// case Query ( textdiff ) of 1 :
13091: LD_STRING textdiff
13093: PPUSH
13094: CALL_OW 97
13098: PUSH
13099: LD_INT 1
13101: DOUBLE
13102: EQUAL
13103: IFTRUE 13107
13105: GO 13118
13107: POP
// global_diff := 1 ; 2 :
13108: LD_ADDR_EXP 3
13112: PUSH
13113: LD_INT 1
13115: ST_TO_ADDR
13116: GO 13157
13118: LD_INT 2
13120: DOUBLE
13121: EQUAL
13122: IFTRUE 13126
13124: GO 13137
13126: POP
// global_diff := 2 ; 3 :
13127: LD_ADDR_EXP 3
13131: PUSH
13132: LD_INT 2
13134: ST_TO_ADDR
13135: GO 13157
13137: LD_INT 3
13139: DOUBLE
13140: EQUAL
13141: IFTRUE 13145
13143: GO 13156
13145: POP
// global_diff := 3 ; end ;
13146: LD_ADDR_EXP 3
13150: PUSH
13151: LD_INT 3
13153: ST_TO_ADDR
13154: GO 13157
13156: POP
// CenterOnXY ( 70 , 130 ) ;
13157: LD_INT 70
13159: PPUSH
13160: LD_INT 130
13162: PPUSH
13163: CALL_OW 84
// case Query ( text1 ) of 1 :
13167: LD_STRING text1
13169: PPUSH
13170: CALL_OW 97
13174: PUSH
13175: LD_INT 1
13177: DOUBLE
13178: EQUAL
13179: IFTRUE 13183
13181: GO 13186
13183: POP
// ; end ;
13184: GO 13187
13186: POP
// ChangeMissionObjectives ( target1 ) ;
13187: LD_STRING target1
13189: PPUSH
13190: CALL_OW 337
// game_started := true ;
13194: LD_ADDR_EXP 10
13198: PUSH
13199: LD_INT 1
13201: ST_TO_ADDR
// crates_allow := true ;
13202: LD_ADDR_EXP 13
13206: PUSH
13207: LD_INT 1
13209: ST_TO_ADDR
// if global_diff > 2 then
13210: LD_EXP 3
13214: PUSH
13215: LD_INT 2
13217: GREATER
13218: IFFALSE 13227
// RemoveUnit ( us_spec_b ) ;
13220: LD_INT 140
13222: PPUSH
13223: CALL_OW 64
// end ;
13227: LD_VAR 0 1
13231: RET
// every 0 0$0.3 trigger SeeSide ( sikorski_veh , 6 ) or SeeSide ( sikorski_veh , 3 ) or SeeSide ( sikorski , 3 ) or SeeSide ( sikorski , 6 ) do
13232: LD_EXP 22
13236: PPUSH
13237: LD_INT 6
13239: PPUSH
13240: CALL 863 0 2
13244: PUSH
13245: LD_EXP 22
13249: PPUSH
13250: LD_INT 3
13252: PPUSH
13253: CALL 863 0 2
13257: OR
13258: PUSH
13259: LD_EXP 14
13263: PPUSH
13264: LD_INT 3
13266: PPUSH
13267: CALL 863 0 2
13271: OR
13272: PUSH
13273: LD_EXP 14
13277: PPUSH
13278: LD_INT 6
13280: PPUSH
13281: CALL 863 0 2
13285: OR
13286: IFFALSE 13303
13288: GO 13290
13290: DISABLE
// Say ( sikorski , DRus ) ;
13291: LD_EXP 14
13295: PPUSH
13296: LD_STRING DRus
13298: PPUSH
13299: CALL_OW 88
13303: END
// every 0 0$01 trigger See ( 4 , sikorski ) or See ( 4 , sikorski_veh ) do var i , per ;
13304: LD_INT 4
13306: PPUSH
13307: LD_EXP 14
13311: PPUSH
13312: CALL_OW 292
13316: PUSH
13317: LD_INT 4
13319: PPUSH
13320: LD_EXP 22
13324: PPUSH
13325: CALL_OW 292
13329: OR
13330: IFFALSE 13752
13332: GO 13334
13334: DISABLE
13335: LD_INT 0
13337: PPUSH
13338: PPUSH
// begin Wait ( 0 0$05 ) ;
13339: LD_INT 175
13341: PPUSH
13342: CALL_OW 67
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
13346: LD_ADDR_VAR 0 1
13350: PUSH
13351: LD_INT 22
13353: PUSH
13354: LD_INT 4
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: PUSH
13366: FOR_IN
13367: IFFALSE 13383
// SetSide ( i , 1 ) ;
13369: LD_VAR 0 1
13373: PPUSH
13374: LD_INT 1
13376: PPUSH
13377: CALL_OW 235
13381: GO 13366
13383: POP
13384: POP
// per := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff sikorski ;
13385: LD_ADDR_VAR 0 2
13389: PUSH
13390: LD_INT 22
13392: PUSH
13393: LD_INT 1
13395: PUSH
13396: EMPTY
13397: LIST
13398: LIST
13399: PUSH
13400: LD_INT 21
13402: PUSH
13403: LD_INT 1
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: LD_INT 26
13412: PUSH
13413: LD_INT 1
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: EMPTY
13421: LIST
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 69
13429: PUSH
13430: LD_EXP 14
13434: DIFF
13435: ST_TO_ADDR
// InGameOn ;
13436: CALL_OW 8
// CenterNowOnXY ( 19 , 13 ) ;
13440: LD_INT 19
13442: PPUSH
13443: LD_INT 13
13445: PPUSH
13446: CALL_OW 86
// if IsInUnit ( sikorski ) then
13450: LD_EXP 14
13454: PPUSH
13455: CALL_OW 310
13459: IFFALSE 13477
// begin ComExitVehicle ( sikorski ) ;
13461: LD_EXP 14
13465: PPUSH
13466: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
13470: LD_INT 10
13472: PPUSH
13473: CALL_OW 67
// end ; ComTurnUnit ( sikorski , per [ 1 ] ) ;
13477: LD_EXP 14
13481: PPUSH
13482: LD_VAR 0 2
13486: PUSH
13487: LD_INT 1
13489: ARRAY
13490: PPUSH
13491: CALL_OW 119
// ComTurnUnit ( per [ 1 ] , sikorski ) ;
13495: LD_VAR 0 2
13499: PUSH
13500: LD_INT 1
13502: ARRAY
13503: PPUSH
13504: LD_EXP 14
13508: PPUSH
13509: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
13513: LD_INT 10
13515: PPUSH
13516: CALL_OW 67
// Say ( sikorski , DS-1 ) ;
13520: LD_EXP 14
13524: PPUSH
13525: LD_STRING DS-1
13527: PPUSH
13528: CALL_OW 88
// Say ( per [ 1 ] , DP-1 ) ;
13532: LD_VAR 0 2
13536: PUSH
13537: LD_INT 1
13539: ARRAY
13540: PPUSH
13541: LD_STRING DP-1
13543: PPUSH
13544: CALL_OW 88
// Say ( sikorski , DS-2 ) ;
13548: LD_EXP 14
13552: PPUSH
13553: LD_STRING DS-2
13555: PPUSH
13556: CALL_OW 88
// Say ( per [ 1 ] , DP-2 ) ;
13560: LD_VAR 0 2
13564: PUSH
13565: LD_INT 1
13567: ARRAY
13568: PPUSH
13569: LD_STRING DP-2
13571: PPUSH
13572: CALL_OW 88
// Say ( sikorski , DS-3 ) ;
13576: LD_EXP 14
13580: PPUSH
13581: LD_STRING DS-3
13583: PPUSH
13584: CALL_OW 88
// Say ( per [ 1 ] , DP-3 ) ;
13588: LD_VAR 0 2
13592: PUSH
13593: LD_INT 1
13595: ARRAY
13596: PPUSH
13597: LD_STRING DP-3
13599: PPUSH
13600: CALL_OW 88
// Say ( sikorski , DS-4 ) ;
13604: LD_EXP 14
13608: PPUSH
13609: LD_STRING DS-4
13611: PPUSH
13612: CALL_OW 88
// Wait ( 0 0$0.6 ) ;
13616: LD_INT 21
13618: PPUSH
13619: CALL_OW 67
// SayRadio ( ron , DR-1 ) ;
13623: LD_EXP 17
13627: PPUSH
13628: LD_STRING DR-1
13630: PPUSH
13631: CALL_OW 94
// Say ( sikorski , DS-5 ) ;
13635: LD_EXP 14
13639: PPUSH
13640: LD_STRING DS-5
13642: PPUSH
13643: CALL_OW 88
// SayRadio ( ron , DR-2 ) ;
13647: LD_EXP 17
13651: PPUSH
13652: LD_STRING DR-2
13654: PPUSH
13655: CALL_OW 94
// Say ( sikorski , DS-6 ) ;
13659: LD_EXP 14
13663: PPUSH
13664: LD_STRING DS-6
13666: PPUSH
13667: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
13671: LD_INT 10
13673: PPUSH
13674: CALL_OW 67
// SayRadio ( ron , DR-3 ) ;
13678: LD_EXP 17
13682: PPUSH
13683: LD_STRING DR-3
13685: PPUSH
13686: CALL_OW 94
// InGameOff ;
13690: CALL_OW 9
// ChangeMissionObjectives ( target2 ) ;
13694: LD_STRING target2
13696: PPUSH
13697: CALL_OW 337
// Wait ( 0 0$03 ) ;
13701: LD_INT 105
13703: PPUSH
13704: CALL_OW 67
// Say ( sikorski , DS-7 ) ;
13708: LD_EXP 14
13712: PPUSH
13713: LD_STRING DS-7
13715: PPUSH
13716: CALL_OW 88
// Wait ( [ 6 6$00 , 5 5$00 , 4 4$00 ] [ global_diff ] ) ;
13720: LD_INT 12600
13722: PUSH
13723: LD_INT 10500
13725: PUSH
13726: LD_INT 8400
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: PUSH
13734: LD_EXP 3
13738: ARRAY
13739: PPUSH
13740: CALL_OW 67
// russian_produce := true ;
13744: LD_ADDR_EXP 20
13748: PUSH
13749: LD_INT 1
13751: ST_TO_ADDR
// end ;
13752: PPOPN 2
13754: END
// export us_unit ; every 0 0$11 trigger timer >= [ 25 25$00 , 27 27$30 , 29 29$20 ] [ global_diff ] do
13755: LD_EXP 2
13759: PUSH
13760: LD_INT 52500
13762: PUSH
13763: LD_INT 57750
13765: PUSH
13766: LD_INT 61600
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: LIST
13773: PUSH
13774: LD_EXP 3
13778: ARRAY
13779: GREATEREQUAL
13780: IFFALSE 13948
13782: GO 13784
13784: DISABLE
// begin uc_side := 8 ;
13785: LD_ADDR_OWVAR 20
13789: PUSH
13790: LD_INT 8
13792: ST_TO_ADDR
// uc_nation := 1 ;
13793: LD_ADDR_OWVAR 21
13797: PUSH
13798: LD_INT 1
13800: ST_TO_ADDR
// hc_sex := sex_male ;
13801: LD_ADDR_OWVAR 27
13805: PUSH
13806: LD_INT 1
13808: ST_TO_ADDR
// hc_gallery :=  ;
13809: LD_ADDR_OWVAR 33
13813: PUSH
13814: LD_STRING 
13816: ST_TO_ADDR
// hc_name :=  ;
13817: LD_ADDR_OWVAR 26
13821: PUSH
13822: LD_STRING 
13824: ST_TO_ADDR
// hc_class := Rand ( 1 , 4 ) ;
13825: LD_ADDR_OWVAR 28
13829: PUSH
13830: LD_INT 1
13832: PPUSH
13833: LD_INT 4
13835: PPUSH
13836: CALL_OW 12
13840: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
13841: LD_ADDR_OWVAR 31
13845: PUSH
13846: LD_INT 2
13848: PPUSH
13849: LD_EXP 6
13853: PPUSH
13854: CALL_OW 12
13858: PUSH
13859: LD_INT 2
13861: PPUSH
13862: LD_EXP 6
13866: PPUSH
13867: CALL_OW 12
13871: PUSH
13872: LD_INT 2
13874: PPUSH
13875: LD_EXP 6
13879: PPUSH
13880: CALL_OW 12
13884: PUSH
13885: LD_INT 2
13887: PPUSH
13888: LD_EXP 6
13892: PPUSH
13893: CALL_OW 12
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: ST_TO_ADDR
// us_unit := CreateHuman ;
13904: LD_ADDR_EXP 46
13908: PUSH
13909: CALL_OW 44
13913: ST_TO_ADDR
// PlaceUnitArea ( us_unit , swamp_spawn , true ) ;
13914: LD_EXP 46
13918: PPUSH
13919: LD_INT 13
13921: PPUSH
13922: LD_INT 1
13924: PPUSH
13925: CALL_OW 49
// Wait ( 0 0$0.3 ) ;
13929: LD_INT 10
13931: PPUSH
13932: CALL_OW 67
// SayRadio ( us_unit , Dun1 ) ;
13936: LD_EXP 46
13940: PPUSH
13941: LD_STRING Dun1
13943: PPUSH
13944: CALL_OW 94
// end ;
13948: END
// every 0 0$01 trigger See ( 1 , us_unit ) do
13949: LD_INT 1
13951: PPUSH
13952: LD_EXP 46
13956: PPUSH
13957: CALL_OW 292
13961: IFFALSE 13978
13963: GO 13965
13965: DISABLE
// SetSide ( us_unit , 1 ) ;
13966: LD_EXP 46
13970: PPUSH
13971: LD_INT 1
13973: PPUSH
13974: CALL_OW 235
13978: END
// every 1 1$35 trigger timer >= [ 8 8$00 , 9 9$00 , 10 10$00 ] [ global_diff ] do var un , veh , i ;
13979: LD_EXP 2
13983: PUSH
13984: LD_INT 16800
13986: PUSH
13987: LD_INT 18900
13989: PUSH
13990: LD_INT 21000
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: LIST
13997: PUSH
13998: LD_EXP 3
14002: ARRAY
14003: GREATEREQUAL
14004: IFFALSE 14383
14006: GO 14008
14008: DISABLE
14009: LD_INT 0
14011: PPUSH
14012: PPUSH
14013: PPUSH
// begin uc_side := 4 ;
14014: LD_ADDR_OWVAR 20
14018: PUSH
14019: LD_INT 4
14021: ST_TO_ADDR
// uc_nation := 1 ;
14022: LD_ADDR_OWVAR 21
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_medium_wheeled ] [ global_diff ] ;
14030: LD_ADDR_OWVAR 37
14034: PUSH
14035: LD_INT 3
14037: PUSH
14038: LD_INT 2
14040: PUSH
14041: LD_INT 2
14043: PUSH
14044: EMPTY
14045: LIST
14046: LIST
14047: LIST
14048: PUSH
14049: LD_EXP 3
14053: ARRAY
14054: ST_TO_ADDR
// vc_engine := engine_solar ;
14055: LD_ADDR_OWVAR 39
14059: PUSH
14060: LD_INT 2
14062: ST_TO_ADDR
// vc_control := control_manual ;
14063: LD_ADDR_OWVAR 38
14067: PUSH
14068: LD_INT 1
14070: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
14071: LD_ADDR_OWVAR 40
14075: PUSH
14076: LD_INT 12
14078: ST_TO_ADDR
// veh := CreateVehicle ;
14079: LD_ADDR_VAR 0 2
14083: PUSH
14084: CALL_OW 45
14088: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , false ) ;
14089: LD_VAR 0 2
14093: PPUSH
14094: LD_INT 20
14096: PPUSH
14097: LD_INT 0
14099: PPUSH
14100: CALL_OW 49
// hc_sex := sex_male ;
14104: LD_ADDR_OWVAR 27
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// hc_gallery :=  ;
14112: LD_ADDR_OWVAR 33
14116: PUSH
14117: LD_STRING 
14119: ST_TO_ADDR
// hc_name :=  ;
14120: LD_ADDR_OWVAR 26
14124: PUSH
14125: LD_STRING 
14127: ST_TO_ADDR
// hc_class := 3 ;
14128: LD_ADDR_OWVAR 28
14132: PUSH
14133: LD_INT 3
14135: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
14136: LD_ADDR_OWVAR 31
14140: PUSH
14141: LD_INT 2
14143: PPUSH
14144: LD_EXP 6
14148: PPUSH
14149: CALL_OW 12
14153: PUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_EXP 6
14161: PPUSH
14162: CALL_OW 12
14166: PUSH
14167: LD_INT 2
14169: PPUSH
14170: LD_EXP 6
14174: PPUSH
14175: CALL_OW 12
14179: PUSH
14180: LD_INT 2
14182: PPUSH
14183: LD_EXP 6
14187: PPUSH
14188: CALL_OW 12
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: ST_TO_ADDR
// un := CreateHuman ;
14199: LD_ADDR_VAR 0 1
14203: PUSH
14204: CALL_OW 44
14208: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , true ) ;
14209: LD_VAR 0 2
14213: PPUSH
14214: LD_INT 20
14216: PPUSH
14217: LD_INT 1
14219: PPUSH
14220: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
14224: LD_VAR 0 1
14228: PPUSH
14229: LD_VAR 0 2
14233: PPUSH
14234: CALL_OW 52
// SetCargo ( veh , mat_cans , 60 ) ;
14238: LD_VAR 0 2
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: LD_INT 60
14248: PPUSH
14249: CALL_OW 290
// SetFuel ( veh , 98 ) ;
14253: LD_VAR 0 2
14257: PPUSH
14258: LD_INT 98
14260: PPUSH
14261: CALL_OW 240
// SetLives ( un , 500 ) ;
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_INT 500
14272: PPUSH
14273: CALL_OW 234
// SetLives ( veh , Rand ( 900 , 999 ) ) ;
14277: LD_VAR 0 2
14281: PPUSH
14282: LD_INT 900
14284: PPUSH
14285: LD_INT 999
14287: PPUSH
14288: CALL_OW 12
14292: PPUSH
14293: CALL_OW 234
// ComMoveXY ( un , 14 , 9 ) ;
14297: LD_VAR 0 1
14301: PPUSH
14302: LD_INT 14
14304: PPUSH
14305: LD_INT 9
14307: PPUSH
14308: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
14312: LD_INT 35
14314: PPUSH
14315: CALL_OW 67
// until See ( 1 , veh ) or See ( 1 , un ) ;
14319: LD_INT 1
14321: PPUSH
14322: LD_VAR 0 2
14326: PPUSH
14327: CALL_OW 292
14331: PUSH
14332: LD_INT 1
14334: PPUSH
14335: LD_VAR 0 1
14339: PPUSH
14340: CALL_OW 292
14344: OR
14345: IFFALSE 14312
// Say ( un , Dcargo ) ;
14347: LD_VAR 0 1
14351: PPUSH
14352: LD_STRING Dcargo
14354: PPUSH
14355: CALL_OW 88
// SetSide ( un , 1 ) ;
14359: LD_VAR 0 1
14363: PPUSH
14364: LD_INT 1
14366: PPUSH
14367: CALL_OW 235
// SetSide ( veh , 1 ) ;
14371: LD_VAR 0 2
14375: PPUSH
14376: LD_INT 1
14378: PPUSH
14379: CALL_OW 235
// end ;
14383: PPOPN 3
14385: END
// every 0 0$01 trigger timer >= [ 18 18$00 , 19 19$00 , 21 21$00 ] [ global_diff ] and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) < 5 do var un , speaker , veh , i , area ;
14386: LD_EXP 2
14390: PUSH
14391: LD_INT 37800
14393: PUSH
14394: LD_INT 39900
14396: PUSH
14397: LD_INT 44100
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: LIST
14404: PUSH
14405: LD_EXP 3
14409: ARRAY
14410: GREATEREQUAL
14411: PUSH
14412: LD_INT 22
14414: PUSH
14415: LD_INT 6
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: LD_INT 21
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PPUSH
14436: CALL_OW 69
14440: PUSH
14441: LD_INT 5
14443: LESS
14444: AND
14445: IFFALSE 14780
14447: GO 14449
14449: DISABLE
14450: LD_INT 0
14452: PPUSH
14453: PPUSH
14454: PPUSH
14455: PPUSH
14456: PPUSH
// begin area := [ us_north , us_south , us_north ] [ global_diff ] ;
14457: LD_ADDR_VAR 0 5
14461: PUSH
14462: LD_INT 21
14464: PUSH
14465: LD_INT 14
14467: PUSH
14468: LD_INT 21
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_EXP 3
14480: ARRAY
14481: ST_TO_ADDR
// speaker := [ ] ;
14482: LD_ADDR_VAR 0 2
14486: PUSH
14487: EMPTY
14488: ST_TO_ADDR
// uc_side := 1 ;
14489: LD_ADDR_OWVAR 20
14493: PUSH
14494: LD_INT 1
14496: ST_TO_ADDR
// uc_nation := 1 ;
14497: LD_ADDR_OWVAR 21
14501: PUSH
14502: LD_INT 1
14504: ST_TO_ADDR
// for i = 1 to 7 - [ global_diff ] do
14505: LD_ADDR_VAR 0 4
14509: PUSH
14510: DOUBLE
14511: LD_INT 1
14513: DEC
14514: ST_TO_ADDR
14515: LD_INT 7
14517: PUSH
14518: LD_EXP 3
14522: PUSH
14523: EMPTY
14524: LIST
14525: MINUS
14526: PUSH
14527: FOR_TO
14528: IFFALSE 14591
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , am_def ) ;
14530: LD_ADDR_VAR 0 1
14534: PUSH
14535: LD_INT 1
14537: PPUSH
14538: LD_INT 4
14540: PPUSH
14541: CALL_OW 12
14545: PPUSH
14546: LD_EXP 6
14550: PPUSH
14551: CALL 418 0 2
14555: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
14556: LD_VAR 0 1
14560: PPUSH
14561: LD_VAR 0 5
14565: PPUSH
14566: LD_INT 0
14568: PPUSH
14569: CALL_OW 49
// speaker := speaker ^ un ;
14573: LD_ADDR_VAR 0 2
14577: PUSH
14578: LD_VAR 0 2
14582: PUSH
14583: LD_VAR 0 1
14587: ADD
14588: ST_TO_ADDR
// end ;
14589: GO 14527
14591: POP
14592: POP
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ global_diff ] ;
14593: LD_ADDR_OWVAR 37
14597: PUSH
14598: LD_INT 3
14600: PUSH
14601: LD_INT 2
14603: PUSH
14604: LD_INT 1
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: LIST
14611: PUSH
14612: LD_EXP 3
14616: ARRAY
14617: ST_TO_ADDR
// vc_engine := engine_solar ;
14618: LD_ADDR_OWVAR 39
14622: PUSH
14623: LD_INT 2
14625: ST_TO_ADDR
// vc_control := control_manual ;
14626: LD_ADDR_OWVAR 38
14630: PUSH
14631: LD_INT 1
14633: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_gatling_gun , us_machine_gun ] [ global_diff ] ;
14634: LD_ADDR_OWVAR 40
14638: PUSH
14639: LD_INT 5
14641: PUSH
14642: LD_INT 4
14644: PUSH
14645: LD_INT 2
14647: PUSH
14648: EMPTY
14649: LIST
14650: LIST
14651: LIST
14652: PUSH
14653: LD_EXP 3
14657: ARRAY
14658: ST_TO_ADDR
// veh := CreateVehicle ;
14659: LD_ADDR_VAR 0 3
14663: PUSH
14664: CALL_OW 45
14668: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
14669: LD_VAR 0 3
14673: PPUSH
14674: LD_VAR 0 5
14678: PPUSH
14679: LD_INT 0
14681: PPUSH
14682: CALL_OW 49
// un := CreateHumanWithClass ( 3 , am_def ) ;
14686: LD_ADDR_VAR 0 1
14690: PUSH
14691: LD_INT 3
14693: PPUSH
14694: LD_EXP 6
14698: PPUSH
14699: CALL 418 0 2
14703: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
14704: LD_VAR 0 1
14708: PPUSH
14709: LD_VAR 0 3
14713: PPUSH
14714: CALL_OW 52
// Wait ( 0 0$0.3 ) ;
14718: LD_INT 10
14720: PPUSH
14721: CALL_OW 67
// SayRadio ( UnitFilter ( speaker , [ f_sex , sex_male ] ) [ 1 ] , Dhelp ) ;
14725: LD_VAR 0 2
14729: PPUSH
14730: LD_INT 26
14732: PUSH
14733: LD_INT 1
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: PPUSH
14740: CALL_OW 72
14744: PUSH
14745: LD_INT 1
14747: ARRAY
14748: PPUSH
14749: LD_STRING Dhelp
14751: PPUSH
14752: CALL_OW 94
// CenterNowOnXY ( GetX ( un ) , GetY ( un ) ) ;
14756: LD_VAR 0 1
14760: PPUSH
14761: CALL_OW 250
14765: PPUSH
14766: LD_VAR 0 1
14770: PPUSH
14771: CALL_OW 251
14775: PPUSH
14776: CALL_OW 86
// end ;
14780: PPOPN 5
14782: END
// every 0 0$01 trigger FilterUnitsInArea ( kurin_a , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) > 0 do
14783: LD_INT 19
14785: PPUSH
14786: LD_INT 2
14788: PUSH
14789: LD_INT 22
14791: PUSH
14792: LD_INT 3
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: PUSH
14799: LD_INT 22
14801: PUSH
14802: LD_INT 6
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 70
14818: PUSH
14819: LD_INT 0
14821: GREATER
14822: IFFALSE 14850
14824: GO 14826
14826: DISABLE
// begin if IsLive ( kurin ) then
14827: LD_EXP 15
14831: PPUSH
14832: CALL_OW 300
14836: IFFALSE 14850
// SayRadio ( kurin , Dkurin ) ;
14838: LD_EXP 15
14842: PPUSH
14843: LD_STRING Dkurin
14845: PPUSH
14846: CALL_OW 94
// end ;
14850: END
// every 0 0$01 trigger timer > 27 27$00 do
14851: LD_EXP 2
14855: PUSH
14856: LD_INT 56700
14858: GREATER
14859: IFFALSE 14876
14861: GO 14863
14863: DISABLE
// SayRadio ( jack , ar_come ) ;
14864: LD_EXP 18
14868: PPUSH
14869: LD_STRING ar_come
14871: PPUSH
14872: CALL_OW 94
14876: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) > 0 do
14877: LD_INT 22
14879: PUSH
14880: LD_INT 2
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PPUSH
14887: CALL_OW 69
14891: PUSH
14892: LD_INT 0
14894: GREATER
14895: IFFALSE 14923
14897: GO 14899
14899: DISABLE
// begin FHeike ;
14900: CALL 11467 0 0
// Wait ( 0 0$01 ) ;
14904: LD_INT 35
14906: PPUSH
14907: CALL_OW 67
// SayRadio ( heike , heike1 ) ;
14911: LD_EXP 16
14915: PPUSH
14916: LD_STRING heike1
14918: PPUSH
14919: CALL_OW 94
// end ;
14923: END
// every 15 15$00 trigger timer > 22 22$00 do
14924: LD_EXP 2
14928: PUSH
14929: LD_INT 46200
14931: GREATER
14932: IFFALSE 14983
14934: GO 14936
14936: DISABLE
// begin enable ;
14937: ENABLE
// ArabianAttack ( 2 , ar_force , Rand ( 1 , 2 ) , [ ar_area1 , ar_area2 ] [ Rand ( 1 , 2 ) ] ) ;
14938: LD_INT 2
14940: PPUSH
14941: LD_EXP 9
14945: PPUSH
14946: LD_INT 1
14948: PPUSH
14949: LD_INT 2
14951: PPUSH
14952: CALL_OW 12
14956: PPUSH
14957: LD_INT 6
14959: PUSH
14960: LD_INT 16
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 1
14969: PPUSH
14970: LD_INT 2
14972: PPUSH
14973: CALL_OW 12
14977: ARRAY
14978: PPUSH
14979: CALL 10884 0 4
// end ;
14983: END
// every 0 0$01 trigger timer >= Rand ( 65 65$00 , 67 67$30 ) or ( FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 ) do var i ;
14984: LD_EXP 2
14988: PUSH
14989: LD_INT 136500
14991: PPUSH
14992: LD_INT 141750
14994: PPUSH
14995: CALL_OW 12
14999: GREATEREQUAL
15000: PUSH
15001: LD_INT 22
15003: PUSH
15004: LD_INT 3
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PPUSH
15011: CALL_OW 69
15015: PUSH
15016: LD_INT 22
15018: PUSH
15019: LD_INT 6
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PPUSH
15026: CALL_OW 69
15030: PLUS
15031: PUSH
15032: LD_INT 3
15034: LESS
15035: OR
15036: IFFALSE 15110
15038: GO 15040
15040: DISABLE
15041: LD_INT 0
15043: PPUSH
// begin InGameOn ;
15044: CALL_OW 8
// DialogueOn ;
15048: CALL_OW 6
// SayRadio ( ron , you_win ) ;
15052: LD_EXP 17
15056: PPUSH
15057: LD_STRING you_win
15059: PPUSH
15060: CALL_OW 94
// DialogueOff ;
15064: CALL_OW 7
// InGameOff ;
15068: CALL_OW 9
// AddMedal ( med , 1 ) ;
15072: LD_STRING med
15074: PPUSH
15075: LD_INT 1
15077: PPUSH
15078: CALL_OW 101
// End_The_Mission_Allowed := true ;
15082: LD_ADDR_OWVAR 57
15086: PUSH
15087: LD_INT 1
15089: ST_TO_ADDR
// case Query ( MEnd ) of 1 :
15090: LD_STRING MEnd
15092: PPUSH
15093: CALL_OW 97
15097: PUSH
15098: LD_INT 1
15100: DOUBLE
15101: EQUAL
15102: IFTRUE 15106
15104: GO 15109
15106: POP
// ; end ;
15107: GO 15110
15109: POP
// end ;
15110: PPOPN 1
15112: END
// on EndTheMissionRaised ( exitt ) do begin End_The_Mission_Allowed := false ;
15113: LD_ADDR_OWVAR 57
15117: PUSH
15118: LD_INT 0
15120: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 then
15121: LD_INT 22
15123: PUSH
15124: LD_INT 3
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PPUSH
15131: CALL_OW 69
15135: PUSH
15136: LD_INT 22
15138: PUSH
15139: LD_INT 6
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PPUSH
15146: CALL_OW 69
15150: PLUS
15151: PUSH
15152: LD_INT 3
15154: LESS
15155: IFFALSE 15169
// AddMedal ( ru , 1 ) else
15157: LD_STRING ru
15159: PPUSH
15160: LD_INT 1
15162: PPUSH
15163: CALL_OW 101
15167: GO 15180
// AddMedal ( ru , - 1 ) ;
15169: LD_STRING ru
15171: PPUSH
15172: LD_INT 1
15174: NEG
15175: PPUSH
15176: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 6 then
15180: LD_INT 22
15182: PUSH
15183: LD_INT 1
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: LD_INT 21
15192: PUSH
15193: LD_INT 1
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL_OW 69
15208: PUSH
15209: LD_INT 6
15211: GREATER
15212: IFFALSE 15226
// AddMedal ( pep , 1 ) else
15214: LD_STRING pep
15216: PPUSH
15217: LD_INT 1
15219: PPUSH
15220: CALL_OW 101
15224: GO 15237
// AddMedal ( pep , - 1 ) ;
15226: LD_STRING pep
15228: PPUSH
15229: LD_INT 1
15231: NEG
15232: PPUSH
15233: CALL_OW 101
// GiveMedals ( MAIN ) ;
15237: LD_STRING MAIN
15239: PPUSH
15240: CALL_OW 102
// YouWin ;
15244: CALL_OW 103
// end ;
15248: PPOPN 1
15250: END
