// starting begin InitMap ;
   0: CALL 1440 0 0
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitTriggers ;
  11: CALL 1825 0 0
// Start_Game ;
  15: CALL 13204 0 0
// InitPlayer ;
  19: CALL 2062 0 0
// InitRussian ;
  23: CALL 2952 0 0
// end ; end_of_file
  27: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
  28: LD_INT 0
  30: PPUSH
  31: PPUSH
  32: PPUSH
  33: PPUSH
  34: PPUSH
// uc_nation = nation_nature ;
  35: LD_ADDR_OWVAR 21
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// uc_side = 0 ;
  43: LD_ADDR_OWVAR 20
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// l = 0 ;
  51: LD_ADDR_VAR 0 6
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
  59: LD_ADDR_OWVAR 24
  63: PUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: CALL_OW 12
  74: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
  75: LD_ADDR_OWVAR 35
  79: PUSH
  80: LD_INT 5
  82: NEG
  83: PPUSH
  84: LD_INT 5
  86: PPUSH
  87: CALL_OW 12
  91: ST_TO_ADDR
// hc_gallery =  ;
  92: LD_ADDR_OWVAR 33
  96: PUSH
  97: LD_STRING 
  99: ST_TO_ADDR
// hc_class = class_apeman ;
 100: LD_ADDR_OWVAR 28
 104: PUSH
 105: LD_INT 12
 107: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 108: LD_ADDR_OWVAR 29
 112: PUSH
 113: LD_INT 11
 115: PPUSH
 116: LD_INT 13
 118: PPUSH
 119: CALL_OW 12
 123: PUSH
 124: LD_INT 10
 126: PPUSH
 127: LD_INT 11
 129: PPUSH
 130: CALL_OW 12
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: ST_TO_ADDR
// hc_sex = sex_male ;
 139: LD_ADDR_OWVAR 27
 143: PUSH
 144: LD_INT 1
 146: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 147: LD_ADDR_OWVAR 31
 151: PUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 2
 157: PPUSH
 158: CALL_OW 12
 162: PUSH
 163: LD_INT 0
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: EMPTY
 173: LIST
 174: LIST
 175: LIST
 176: LIST
 177: ST_TO_ADDR
// apeman = CreateHuman ;
 178: LD_ADDR_VAR 0 7
 182: PUSH
 183: CALL_OW 44
 187: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 188: LD_VAR 0 7
 192: PPUSH
 193: LD_VAR 0 4
 197: PPUSH
 198: LD_INT 0
 200: PPUSH
 201: CALL_OW 49
// l = l + 1 ;
 205: LD_ADDR_VAR 0 6
 209: PUSH
 210: LD_VAR 0 6
 214: PUSH
 215: LD_INT 1
 217: PLUS
 218: ST_TO_ADDR
// end until l = num1 ;
 219: LD_VAR 0 6
 223: PUSH
 224: LD_VAR 0 1
 228: EQUAL
 229: IFFALSE 59
// l = 0 ;
 231: LD_ADDR_VAR 0 6
 235: PUSH
 236: LD_INT 0
 238: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 239: LD_ADDR_OWVAR 35
 243: PUSH
 244: LD_INT 0
 246: PPUSH
 247: LD_INT 25
 249: PPUSH
 250: CALL_OW 12
 254: ST_TO_ADDR
// hc_class = class_tiger ;
 255: LD_ADDR_OWVAR 28
 259: PUSH
 260: LD_INT 14
 262: ST_TO_ADDR
// hc_sex = sex_male ;
 263: LD_ADDR_OWVAR 27
 267: PUSH
 268: LD_INT 1
 270: ST_TO_ADDR
// hc_gallery = sandnature ;
 271: LD_ADDR_OWVAR 33
 275: PUSH
 276: LD_STRING sandnature
 278: ST_TO_ADDR
// hc_face_number = 3 ;
 279: LD_ADDR_OWVAR 34
 283: PUSH
 284: LD_INT 3
 286: ST_TO_ADDR
// tiger = CreateHuman ;
 287: LD_ADDR_VAR 0 8
 291: PUSH
 292: CALL_OW 44
 296: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 297: LD_VAR 0 8
 301: PPUSH
 302: LD_VAR 0 4
 306: PPUSH
 307: LD_INT 0
 309: PPUSH
 310: CALL_OW 49
// l = l + 1 ;
 314: LD_ADDR_VAR 0 6
 318: PUSH
 319: LD_VAR 0 6
 323: PUSH
 324: LD_INT 1
 326: PLUS
 327: ST_TO_ADDR
// end until l = num2 ;
 328: LD_VAR 0 6
 332: PUSH
 333: LD_VAR 0 2
 337: EQUAL
 338: IFFALSE 239
// l = 0 ;
 340: LD_ADDR_VAR 0 6
 344: PUSH
 345: LD_INT 0
 347: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 348: LD_ADDR_OWVAR 28
 352: PUSH
 353: LD_INT 18
 355: ST_TO_ADDR
// hc_gallery = sandnature ;
 356: LD_ADDR_OWVAR 33
 360: PUSH
 361: LD_STRING sandnature
 363: ST_TO_ADDR
// hc_face_number = 1 ;
 364: LD_ADDR_OWVAR 34
 368: PUSH
 369: LD_INT 1
 371: ST_TO_ADDR
// bird = CreateHuman ;
 372: LD_ADDR_VAR 0 9
 376: PUSH
 377: CALL_OW 44
 381: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 382: LD_VAR 0 9
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 51
// l = l + 1 ;
 394: LD_ADDR_VAR 0 6
 398: PUSH
 399: LD_VAR 0 6
 403: PUSH
 404: LD_INT 1
 406: PLUS
 407: ST_TO_ADDR
// end until l = num3 ;
 408: LD_VAR 0 6
 412: PUSH
 413: LD_VAR 0 3
 417: EQUAL
 418: IFFALSE 348
// end ;
 420: LD_VAR 0 5
 424: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
 429: PPUSH
 430: PPUSH
 431: PPUSH
 432: PPUSH
// hc_class := clas ;
 433: LD_ADDR_OWVAR 28
 437: PUSH
 438: LD_VAR 0 1
 442: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 443: LD_ADDR_VAR 0 4
 447: PUSH
 448: LD_VAR 0 2
 452: PUSH
 453: LD_INT 1
 455: NEG
 456: PPUSH
 457: LD_INT 1
 459: PPUSH
 460: CALL_OW 12
 464: PLUS
 465: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 466: LD_ADDR_VAR 0 5
 470: PUSH
 471: LD_VAR 0 2
 475: PUSH
 476: LD_INT 1
 478: NEG
 479: PPUSH
 480: LD_INT 1
 482: PPUSH
 483: CALL_OW 12
 487: PLUS
 488: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 489: LD_ADDR_VAR 0 6
 493: PUSH
 494: LD_VAR 0 2
 498: PUSH
 499: LD_INT 1
 501: NEG
 502: PPUSH
 503: LD_INT 1
 505: PPUSH
 506: CALL_OW 12
 510: PLUS
 511: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 512: LD_ADDR_VAR 0 7
 516: PUSH
 517: LD_VAR 0 2
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PPUSH
 526: LD_INT 1
 528: PPUSH
 529: CALL_OW 12
 533: PLUS
 534: ST_TO_ADDR
// if clas = 1 or clas = 9 then
 535: LD_VAR 0 1
 539: PUSH
 540: LD_INT 1
 542: EQUAL
 543: PUSH
 544: LD_VAR 0 1
 548: PUSH
 549: LD_INT 9
 551: EQUAL
 552: OR
 553: IFFALSE 578
// bonus := [ 2 , 0 , 0 , 0 ] ;
 555: LD_ADDR_VAR 0 8
 559: PUSH
 560: LD_INT 2
 562: PUSH
 563: LD_INT 0
 565: PUSH
 566: LD_INT 0
 568: PUSH
 569: LD_INT 0
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: LIST
 576: LIST
 577: ST_TO_ADDR
// if clas = 2 then
 578: LD_VAR 0 1
 582: PUSH
 583: LD_INT 2
 585: EQUAL
 586: IFFALSE 611
// bonus := [ 0 , 2 , 0 , 0 ] ;
 588: LD_ADDR_VAR 0 8
 592: PUSH
 593: LD_INT 0
 595: PUSH
 596: LD_INT 2
 598: PUSH
 599: LD_INT 0
 601: PUSH
 602: LD_INT 0
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: ST_TO_ADDR
// if clas = 3 then
 611: LD_VAR 0 1
 615: PUSH
 616: LD_INT 3
 618: EQUAL
 619: IFFALSE 644
// bonus := [ 0 , 0 , 2 , 0 ] ;
 621: LD_ADDR_VAR 0 8
 625: PUSH
 626: LD_INT 0
 628: PUSH
 629: LD_INT 0
 631: PUSH
 632: LD_INT 2
 634: PUSH
 635: LD_INT 0
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// if clas = 4 then
 644: LD_VAR 0 1
 648: PUSH
 649: LD_INT 4
 651: EQUAL
 652: IFFALSE 677
// bonus := [ 0 , 0 , 0 , 2 ] ;
 654: LD_ADDR_VAR 0 8
 658: PUSH
 659: LD_INT 0
 661: PUSH
 662: LD_INT 0
 664: PUSH
 665: LD_INT 0
 667: PUSH
 668: LD_INT 2
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: ST_TO_ADDR
// if clas > 4 and not clas = 9 then
 677: LD_VAR 0 1
 681: PUSH
 682: LD_INT 4
 684: GREATER
 685: PUSH
 686: LD_VAR 0 1
 690: PUSH
 691: LD_INT 9
 693: EQUAL
 694: NOT
 695: AND
 696: IFFALSE 721
// bonus := [ 0 , 0 , 0 , 0 ] ;
 698: LD_ADDR_VAR 0 8
 702: PUSH
 703: LD_INT 0
 705: PUSH
 706: LD_INT 0
 708: PUSH
 709: LD_INT 0
 711: PUSH
 712: LD_INT 0
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 721: LD_ADDR_OWVAR 31
 725: PUSH
 726: LD_VAR 0 4
 730: PUSH
 731: LD_VAR 0 8
 735: PUSH
 736: LD_INT 1
 738: ARRAY
 739: PLUS
 740: PUSH
 741: LD_VAR 0 5
 745: PUSH
 746: LD_VAR 0 8
 750: PUSH
 751: LD_INT 2
 753: ARRAY
 754: PLUS
 755: PUSH
 756: LD_VAR 0 6
 760: PUSH
 761: LD_VAR 0 8
 765: PUSH
 766: LD_INT 3
 768: ARRAY
 769: PLUS
 770: PUSH
 771: LD_VAR 0 7
 775: PUSH
 776: LD_VAR 0 8
 780: PUSH
 781: LD_INT 4
 783: ARRAY
 784: PLUS
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 792: LD_ADDR_OWVAR 27
 796: PUSH
 797: LD_INT 1
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: CALL_OW 12
 807: ST_TO_ADDR
// hc_gallery :=  ;
 808: LD_ADDR_OWVAR 33
 812: PUSH
 813: LD_STRING 
 815: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 816: LD_ADDR_OWVAR 29
 820: PUSH
 821: LD_INT 8
 823: PPUSH
 824: LD_INT 12
 826: PPUSH
 827: CALL_OW 12
 831: PUSH
 832: LD_INT 9
 834: PPUSH
 835: LD_INT 11
 837: PPUSH
 838: CALL_OW 12
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: ST_TO_ADDR
// hc_name :=  ;
 847: LD_ADDR_OWVAR 26
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// result := CreateHuman ;
 855: LD_ADDR_VAR 0 3
 859: PUSH
 860: CALL_OW 44
 864: ST_TO_ADDR
// end ;
 865: LD_VAR 0 3
 869: RET
// export function SeeSide ( unit , side ) ; var i ; begin
 870: LD_INT 0
 872: PPUSH
 873: PPUSH
// result := false ;
 874: LD_ADDR_VAR 0 3
 878: PUSH
 879: LD_INT 0
 881: ST_TO_ADDR
// i := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
 882: LD_ADDR_VAR 0 4
 886: PUSH
 887: LD_INT 22
 889: PUSH
 890: LD_VAR 0 2
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PPUSH
 899: CALL_OW 69
 903: PPUSH
 904: LD_VAR 0 1
 908: PPUSH
 909: CALL_OW 74
 913: ST_TO_ADDR
// if GetDistUnits ( unit , i ) < 9 then
 914: LD_VAR 0 1
 918: PPUSH
 919: LD_VAR 0 4
 923: PPUSH
 924: CALL_OW 296
 928: PUSH
 929: LD_INT 9
 931: LESS
 932: IFFALSE 942
// result := true ;
 934: LD_ADDR_VAR 0 3
 938: PUSH
 939: LD_INT 1
 941: ST_TO_ADDR
// end ;
 942: LD_VAR 0 3
 946: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
 947: LD_VAR 0 1
 951: PUSH
 952: LD_EXP 1
 956: IN
 957: NOT
 958: IFFALSE 989
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
 960: LD_ADDR_EXP 1
 964: PUSH
 965: LD_EXP 1
 969: PPUSH
 970: LD_EXP 1
 974: PUSH
 975: LD_INT 1
 977: PLUS
 978: PPUSH
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 2
 988: ST_TO_ADDR
// end ;
 989: PPOPN 1
 991: END
// export function ComAttack ( unit , ignore_list ) ; var i , j , target , enemy_list , _list , types_list ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
 997: PPUSH
 998: PPUSH
 999: PPUSH
1000: PPUSH
// if not IsPlaced ( unit ) then
1001: LD_VAR 0 1
1005: PPUSH
1006: CALL_OW 305
1010: NOT
1011: IFFALSE 1015
// exit ;
1013: GO 1322
// enemy_list := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
1015: LD_ADDR_VAR 0 7
1019: PUSH
1020: LD_INT 81
1022: PUSH
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 255
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL_OW 69
1041: ST_TO_ADDR
// if not enemy_list then
1042: LD_VAR 0 7
1046: NOT
1047: IFFALSE 1051
// exit ;
1049: GO 1322
// if ignore_list then
1051: LD_VAR 0 2
1055: IFFALSE 1197
// begin _list := [ ] ;
1057: LD_ADDR_VAR 0 8
1061: PUSH
1062: EMPTY
1063: ST_TO_ADDR
// types_list := [ f_btype , f_weapon , f_class ] ;
1064: LD_ADDR_VAR 0 9
1068: PUSH
1069: LD_INT 30
1071: PUSH
1072: LD_INT 34
1074: PUSH
1075: LD_INT 25
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: ST_TO_ADDR
// for i = 1 to 3 do
1083: LD_ADDR_VAR 0 4
1087: PUSH
1088: DOUBLE
1089: LD_INT 1
1091: DEC
1092: ST_TO_ADDR
1093: LD_INT 3
1095: PUSH
1096: FOR_TO
1097: IFFALSE 1195
// begin if not ignore_list [ i ] then
1099: LD_VAR 0 2
1103: PUSH
1104: LD_VAR 0 4
1108: ARRAY
1109: NOT
1110: IFFALSE 1116
// continue else
1112: GO 1096
1114: GO 1193
// for j in ignore_list [ i ] do
1116: LD_ADDR_VAR 0 5
1120: PUSH
1121: LD_VAR 0 2
1125: PUSH
1126: LD_VAR 0 4
1130: ARRAY
1131: PUSH
1132: FOR_IN
1133: IFFALSE 1191
// begin _list := Insert ( _list , _list + 1 , UnitFilter ( enemy_list , [ types_list [ i ] , j ] ) ) ;
1135: LD_ADDR_VAR 0 8
1139: PUSH
1140: LD_VAR 0 8
1144: PPUSH
1145: LD_VAR 0 8
1149: PUSH
1150: LD_INT 1
1152: PLUS
1153: PPUSH
1154: LD_VAR 0 7
1158: PPUSH
1159: LD_VAR 0 9
1163: PUSH
1164: LD_VAR 0 4
1168: ARRAY
1169: PUSH
1170: LD_VAR 0 5
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: PPUSH
1179: CALL_OW 72
1183: PPUSH
1184: CALL_OW 2
1188: ST_TO_ADDR
// end ;
1189: GO 1132
1191: POP
1192: POP
// end ;
1193: GO 1096
1195: POP
1196: POP
// end ; if enemy_list diff _list > 0 then
1197: LD_VAR 0 7
1201: PUSH
1202: LD_VAR 0 8
1206: PUSH
1207: LD_INT 0
1209: GREATER
1210: DIFF
1211: IFFALSE 1229
// enemy_list := enemy_list diff _list ;
1213: LD_ADDR_VAR 0 7
1217: PUSH
1218: LD_VAR 0 7
1222: PUSH
1223: LD_VAR 0 8
1227: DIFF
1228: ST_TO_ADDR
// target := NearestUnitToUnit ( enemy_list , unit ) ;
1229: LD_ADDR_VAR 0 6
1233: PUSH
1234: LD_VAR 0 7
1238: PPUSH
1239: LD_VAR 0 1
1243: PPUSH
1244: CALL_OW 74
1248: ST_TO_ADDR
// if not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
1249: LD_VAR 0 1
1253: PPUSH
1254: LD_VAR 0 6
1258: PPUSH
1259: CALL_OW 250
1263: PPUSH
1264: LD_VAR 0 6
1268: PPUSH
1269: CALL_OW 251
1273: PPUSH
1274: CALL 1327 0 3
1278: NOT
1279: IFFALSE 1322
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
1281: LD_VAR 0 1
1285: PPUSH
1286: LD_INT 81
1288: PUSH
1289: LD_VAR 0 1
1293: PPUSH
1294: CALL_OW 255
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PPUSH
1308: LD_VAR 0 1
1312: PPUSH
1313: CALL_OW 74
1317: PPUSH
1318: CALL_OW 115
// end ;
1322: LD_VAR 0 3
1326: RET
// export function DestinationReachable ( unit , x , y ) ; begin
1327: LD_INT 0
1329: PPUSH
// if unit in unreachableList then
1330: LD_VAR 0 1
1334: PUSH
1335: LD_EXP 1
1339: IN
1340: IFFALSE 1358
// unreachableList := unreachableList diff unit ;
1342: LD_ADDR_EXP 1
1346: PUSH
1347: LD_EXP 1
1351: PUSH
1352: LD_VAR 0 1
1356: DIFF
1357: ST_TO_ADDR
// if ValidHex ( x , y ) then
1358: LD_VAR 0 2
1362: PPUSH
1363: LD_VAR 0 3
1367: PPUSH
1368: CALL_OW 488
1372: IFFALSE 1398
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
1374: LD_VAR 0 1
1378: PPUSH
1379: LD_VAR 0 2
1383: PPUSH
1384: LD_VAR 0 3
1388: PPUSH
1389: CALL_OW 428
1393: PPUSH
1394: CALL_OW 115
// Wait ( 1 ) ;
1398: LD_INT 1
1400: PPUSH
1401: CALL_OW 67
// if unit in unreachableList then
1405: LD_VAR 0 1
1409: PUSH
1410: LD_EXP 1
1414: IN
1415: IFFALSE 1427
// result := false else
1417: LD_ADDR_VAR 0 4
1421: PUSH
1422: LD_INT 0
1424: ST_TO_ADDR
1425: GO 1435
// result := true ;
1427: LD_ADDR_VAR 0 4
1431: PUSH
1432: LD_INT 1
1434: ST_TO_ADDR
// end ; end_of_file
1435: LD_VAR 0 4
1439: RET
// export function InitMap ; begin
1440: LD_INT 0
1442: PPUSH
// ResetFog ;
1443: CALL_OW 335
// PrepareAnimals ( 2 , 3 , 3 , nature_area ) ;
1447: LD_INT 2
1449: PPUSH
1450: LD_INT 3
1452: PPUSH
1453: LD_INT 3
1455: PPUSH
1456: LD_INT 1
1458: PPUSH
1459: CALL 28 0 4
// end ;
1463: LD_VAR 0 1
1467: RET
// export function SpawnCrates ; var i ; begin
1468: LD_INT 0
1470: PPUSH
1471: PPUSH
// while ( crates_allow ) do
1472: LD_EXP 13
1476: IFFALSE 1629
// begin Wait ( crates_time + Rand ( - 0 0$10 , 0 0$20 ) ) ;
1478: LD_EXP 11
1482: PUSH
1483: LD_INT 350
1485: NEG
1486: PPUSH
1487: LD_INT 700
1489: PPUSH
1490: CALL_OW 12
1494: PLUS
1495: PPUSH
1496: CALL_OW 67
// for i = 1 to crates_num do
1500: LD_ADDR_VAR 0 2
1504: PUSH
1505: DOUBLE
1506: LD_INT 1
1508: DEC
1509: ST_TO_ADDR
1510: LD_EXP 12
1514: PUSH
1515: FOR_TO
1516: IFFALSE 1625
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 5
1523: PPUSH
1524: CALL_OW 12
1528: PPUSH
1529: LD_INT 2
1531: PPUSH
1532: LD_INT 1
1534: PPUSH
1535: CALL_OW 55
// Wait ( Rand ( 0 0$03 , 0 0$12 ) ) ;
1539: LD_INT 105
1541: PPUSH
1542: LD_INT 420
1544: PPUSH
1545: CALL_OW 12
1549: PPUSH
1550: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1554: LD_INT 1
1556: PPUSH
1557: LD_INT 5
1559: PPUSH
1560: CALL_OW 12
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 1
1570: PPUSH
1571: CALL_OW 55
// Wait ( Rand ( 0 0$04 , 0 0$15 ) ) ;
1575: LD_INT 140
1577: PPUSH
1578: LD_INT 525
1580: PPUSH
1581: CALL_OW 12
1585: PPUSH
1586: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
1590: LD_INT 1
1592: PPUSH
1593: LD_INT 5
1595: PPUSH
1596: CALL_OW 12
1600: PPUSH
1601: LD_INT 1
1603: PPUSH
1604: CALL_OW 57
// Wait ( Rand ( 0 0$05 , 0 0$10 ) ) ;
1608: LD_INT 175
1610: PPUSH
1611: LD_INT 350
1613: PPUSH
1614: CALL_OW 12
1618: PPUSH
1619: CALL_OW 67
// end ;
1623: GO 1515
1625: POP
1626: POP
// end ;
1627: GO 1472
// end ;
1629: LD_VAR 0 1
1633: RET
// every 1 1$25 trigger game_started do
1634: LD_EXP 10
1638: IFFALSE 1692
1640: GO 1642
1642: DISABLE
// begin enable ;
1643: ENABLE
// if timer <= [ 23 23$00 , 21 21$00 , 19 19$00 ] [ global_diff ] then
1644: LD_EXP 2
1648: PUSH
1649: LD_INT 48300
1651: PUSH
1652: LD_INT 44100
1654: PUSH
1655: LD_INT 39900
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: PUSH
1663: LD_EXP 3
1667: ARRAY
1668: LESSEQUAL
1669: IFFALSE 1692
// CreateCratesArea ( Rand ( 2 , 5 ) , us_crates , true ) ;
1671: LD_INT 2
1673: PPUSH
1674: LD_INT 5
1676: PPUSH
1677: CALL_OW 12
1681: PPUSH
1682: LD_INT 12
1684: PPUSH
1685: LD_INT 1
1687: PPUSH
1688: CALL_OW 55
// end ;
1692: END
// every 0 0$01 trigger game_started do
1693: LD_EXP 10
1697: IFFALSE 1706
1699: GO 1701
1701: DISABLE
// SpawnCrates ;
1702: CALL 1468 0 0
1706: END
// export timer ; every 1 do
1707: GO 1709
1709: DISABLE
// timer := 0 0$00 ;
1710: LD_ADDR_EXP 2
1714: PUSH
1715: LD_INT 0
1717: ST_TO_ADDR
1718: END
// every 0 0$01 trigger game_started do
1719: LD_EXP 10
1723: IFFALSE 1760
1725: GO 1727
1727: DISABLE
// begin enable ;
1728: ENABLE
// timer := timer + 0 0$01 ;
1729: LD_ADDR_EXP 2
1733: PUSH
1734: LD_EXP 2
1738: PUSH
1739: LD_INT 35
1741: PLUS
1742: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
1743: LD_ADDR_OWVAR 47
1747: PUSH
1748: LD_STRING #tick
1750: PUSH
1751: LD_EXP 2
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: ST_TO_ADDR
// end ;
1760: END
// every 0 0$01 trigger timer <= 13 13$00 do
1761: LD_EXP 2
1765: PUSH
1766: LD_INT 27300
1768: LESSEQUAL
1769: IFFALSE 1782
1771: GO 1773
1773: DISABLE
// music_nat := 1 ;
1774: LD_ADDR_OWVAR 71
1778: PUSH
1779: LD_INT 1
1781: ST_TO_ADDR
1782: END
// every 5 5$00 trigger timer > 13 13$00 do
1783: LD_EXP 2
1787: PUSH
1788: LD_INT 27300
1790: GREATER
1791: IFFALSE 1824
1793: GO 1795
1795: DISABLE
// begin enable ;
1796: ENABLE
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1797: LD_ADDR_OWVAR 71
1801: PUSH
1802: LD_INT 1
1804: PUSH
1805: LD_INT 3
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: PUSH
1812: LD_INT 1
1814: PPUSH
1815: LD_INT 2
1817: PPUSH
1818: CALL_OW 12
1822: ARRAY
1823: ST_TO_ADDR
// end ; end_of_file
1824: END
// export global_diff , ru_force , ru_def , am_def , am_force , ar_def , ar_force ; export game_started ; export crates_time , crates_num , crates_allow ; export sikorski , kurin , heike , ron , jack ; export sikorski_come , russian_produce , beria_action , sikorski_veh ; export function InitTriggers ; begin
1825: LD_INT 0
1827: PPUSH
// game_started := false ;
1828: LD_ADDR_EXP 10
1832: PUSH
1833: LD_INT 0
1835: ST_TO_ADDR
// global_diff := [ 1 , 2 , 3 ] ;
1836: LD_ADDR_EXP 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: LIST
1854: ST_TO_ADDR
// crates_time := [ 0 0$55 , 1 1$15 , 1 1$35 ] [ global_diff ] ;
1855: LD_ADDR_EXP 11
1859: PUSH
1860: LD_INT 1925
1862: PUSH
1863: LD_INT 2625
1865: PUSH
1866: LD_INT 3325
1868: PUSH
1869: EMPTY
1870: LIST
1871: LIST
1872: LIST
1873: PUSH
1874: LD_EXP 3
1878: ARRAY
1879: ST_TO_ADDR
// crates_num := [ 3 , 2 , 1 ] [ global_diff ] ;
1880: LD_ADDR_EXP 12
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 2
1890: PUSH
1891: LD_INT 1
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: PUSH
1899: LD_EXP 3
1903: ARRAY
1904: ST_TO_ADDR
// crates_allow := false ;
1905: LD_ADDR_EXP 13
1909: PUSH
1910: LD_INT 0
1912: ST_TO_ADDR
// am_def := [ 4 , 3 , 2 ] [ global_diff ] ;
1913: LD_ADDR_EXP 6
1917: PUSH
1918: LD_INT 4
1920: PUSH
1921: LD_INT 3
1923: PUSH
1924: LD_INT 2
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: PUSH
1932: LD_EXP 3
1936: ARRAY
1937: ST_TO_ADDR
// ru_def := [ 2 , 3 , 4 ] [ global_diff ] ;
1938: LD_ADDR_EXP 5
1942: PUSH
1943: LD_INT 2
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 4
1951: PUSH
1952: EMPTY
1953: LIST
1954: LIST
1955: LIST
1956: PUSH
1957: LD_EXP 3
1961: ARRAY
1962: ST_TO_ADDR
// ru_force := [ 16 , 18 , 20 ] [ global_diff ] ;
1963: LD_ADDR_EXP 4
1967: PUSH
1968: LD_INT 16
1970: PUSH
1971: LD_INT 18
1973: PUSH
1974: LD_INT 20
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_EXP 3
1986: ARRAY
1987: ST_TO_ADDR
// ar_def := [ 3 , 4 , 5 ] [ global_diff ] ;
1988: LD_ADDR_EXP 8
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 4
1998: PUSH
1999: LD_INT 5
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: PUSH
2007: LD_EXP 3
2011: ARRAY
2012: ST_TO_ADDR
// ar_force := [ 4 , 5 , 6 ] [ global_diff ] ;
2013: LD_ADDR_EXP 9
2017: PUSH
2018: LD_INT 4
2020: PUSH
2021: LD_INT 5
2023: PUSH
2024: LD_INT 6
2026: PUSH
2027: EMPTY
2028: LIST
2029: LIST
2030: LIST
2031: PUSH
2032: LD_EXP 3
2036: ARRAY
2037: ST_TO_ADDR
// sikorski_come := false ;
2038: LD_ADDR_EXP 19
2042: PUSH
2043: LD_INT 0
2045: ST_TO_ADDR
// russian_produce := false ;
2046: LD_ADDR_EXP 20
2050: PUSH
2051: LD_INT 0
2053: ST_TO_ADDR
// disable ( 99 ) ;
2054: LD_INT 99
2056: DISABLE_MARKED
// end ; end_of_file
2057: LD_VAR 0 1
2061: RET
// export function InitPlayer ; var i , p , un , am , am2 , filter ; begin
2062: LD_INT 0
2064: PPUSH
2065: PPUSH
2066: PPUSH
2067: PPUSH
2068: PPUSH
2069: PPUSH
2070: PPUSH
// uc_nation := nation_american ;
2071: LD_ADDR_OWVAR 21
2075: PUSH
2076: LD_INT 1
2078: ST_TO_ADDR
// am := 1 ;
2079: LD_ADDR_VAR 0 5
2083: PUSH
2084: LD_INT 1
2086: ST_TO_ADDR
// am2 := 4 ;
2087: LD_ADDR_VAR 0 6
2091: PUSH
2092: LD_INT 4
2094: ST_TO_ADDR
// filter := [ ] ;
2095: LD_ADDR_VAR 0 7
2099: PUSH
2100: EMPTY
2101: ST_TO_ADDR
// SetSide ( omikron , am2 ) ;
2102: LD_INT 64
2104: PPUSH
2105: LD_VAR 0 6
2109: PPUSH
2110: CALL_OW 235
// SetBName ( omikron , omikron ) ;
2114: LD_INT 64
2116: PPUSH
2117: LD_STRING omikron
2119: PPUSH
2120: CALL_OW 500
// ResetFog ;
2124: CALL_OW 335
// uc_side := am2 ;
2128: LD_ADDR_OWVAR 20
2132: PUSH
2133: LD_VAR 0 6
2137: ST_TO_ADDR
// for i = 1 to 4 do
2138: LD_ADDR_VAR 0 2
2142: PUSH
2143: DOUBLE
2144: LD_INT 1
2146: DEC
2147: ST_TO_ADDR
2148: LD_INT 4
2150: PUSH
2151: FOR_TO
2152: IFFALSE 2274
// for p = 1 to 2 do
2154: LD_ADDR_VAR 0 3
2158: PUSH
2159: DOUBLE
2160: LD_INT 1
2162: DEC
2163: ST_TO_ADDR
2164: LD_INT 2
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2270
// begin un := CreateHumanWithClass ( i , am_def ) ;
2170: LD_ADDR_VAR 0 4
2174: PUSH
2175: LD_VAR 0 2
2179: PPUSH
2180: LD_EXP 6
2184: PPUSH
2185: CALL 425 0 2
2189: ST_TO_ADDR
// PlaceUnitArea ( un , am_area , false ) ;
2190: LD_VAR 0 4
2194: PPUSH
2195: LD_INT 3
2197: PPUSH
2198: LD_INT 0
2200: PPUSH
2201: CALL_OW 49
// if GetClass ( un ) = 1 then
2205: LD_VAR 0 4
2209: PPUSH
2210: CALL_OW 257
2214: PUSH
2215: LD_INT 1
2217: EQUAL
2218: IFFALSE 2268
// ComEnterUnit ( un , ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) diff us_spec_b ) [ p ] ) ;
2220: LD_VAR 0 4
2224: PPUSH
2225: LD_INT 22
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PUSH
2235: LD_INT 30
2237: PUSH
2238: LD_INT 31
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 69
2253: PUSH
2254: LD_INT 140
2256: DIFF
2257: PUSH
2258: LD_VAR 0 3
2262: ARRAY
2263: PPUSH
2264: CALL_OW 120
// end ;
2268: GO 2167
2270: POP
2271: POP
2272: GO 2151
2274: POP
2275: POP
// if IsPlaced ( us_spec_b ) then
2276: LD_INT 140
2278: PPUSH
2279: CALL_OW 305
2283: IFFALSE 2347
// begin un := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) [ 1 ] ;
2285: LD_ADDR_VAR 0 4
2289: PUSH
2290: LD_INT 22
2292: PUSH
2293: LD_INT 4
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: PUSH
2300: LD_INT 25
2302: PUSH
2303: LD_INT 3
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: PPUSH
2314: CALL_OW 69
2318: PUSH
2319: LD_INT 1
2321: ARRAY
2322: ST_TO_ADDR
// SetClass ( un , 1 ) ;
2323: LD_VAR 0 4
2327: PPUSH
2328: LD_INT 1
2330: PPUSH
2331: CALL_OW 336
// ComEnterUnit ( un , us_spec_b ) ;
2335: LD_VAR 0 4
2339: PPUSH
2340: LD_INT 140
2342: PPUSH
2343: CALL_OW 120
// end ; vc_chassis := us_medium_wheeled ;
2347: LD_ADDR_OWVAR 37
2351: PUSH
2352: LD_INT 2
2354: ST_TO_ADDR
// vc_engine := engine_solar ;
2355: LD_ADDR_OWVAR 39
2359: PUSH
2360: LD_INT 2
2362: ST_TO_ADDR
// vc_control := control_manual ;
2363: LD_ADDR_OWVAR 38
2367: PUSH
2368: LD_INT 1
2370: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_double_gun , us_gatling_gun ] [ global_diff ] ;
2371: LD_ADDR_OWVAR 40
2375: PUSH
2376: LD_INT 5
2378: PUSH
2379: LD_INT 5
2381: PUSH
2382: LD_INT 4
2384: PUSH
2385: EMPTY
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_EXP 3
2394: ARRAY
2395: ST_TO_ADDR
// un := CreateVehicle ;
2396: LD_ADDR_VAR 0 4
2400: PUSH
2401: CALL_OW 45
2405: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2406: LD_VAR 0 4
2410: PPUSH
2411: LD_INT 4
2413: PPUSH
2414: CALL_OW 233
// PlaceUnitXY ( un , 12 , 17 , false ) ;
2418: LD_VAR 0 4
2422: PPUSH
2423: LD_INT 12
2425: PPUSH
2426: LD_INT 17
2428: PPUSH
2429: LD_INT 0
2431: PPUSH
2432: CALL_OW 48
// vc_chassis := us_light_wheeled ;
2436: LD_ADDR_OWVAR 37
2440: PUSH
2441: LD_INT 1
2443: ST_TO_ADDR
// vc_engine := engine_combustion ;
2444: LD_ADDR_OWVAR 39
2448: PUSH
2449: LD_INT 1
2451: ST_TO_ADDR
// vc_control := control_manual ;
2452: LD_ADDR_OWVAR 38
2456: PUSH
2457: LD_INT 1
2459: ST_TO_ADDR
// vc_weapon := us_light_gun ;
2460: LD_ADDR_OWVAR 40
2464: PUSH
2465: LD_INT 3
2467: ST_TO_ADDR
// un := CreateVehicle ;
2468: LD_ADDR_VAR 0 4
2472: PUSH
2473: CALL_OW 45
2477: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2478: LD_VAR 0 4
2482: PPUSH
2483: LD_INT 4
2485: PPUSH
2486: CALL_OW 233
// PlaceUnitXY ( un , 19 , 19 , false ) ;
2490: LD_VAR 0 4
2494: PPUSH
2495: LD_INT 19
2497: PPUSH
2498: LD_INT 19
2500: PPUSH
2501: LD_INT 0
2503: PPUSH
2504: CALL_OW 48
// uc_side := am ;
2508: LD_ADDR_OWVAR 20
2512: PUSH
2513: LD_VAR 0 5
2517: ST_TO_ADDR
// hc_importance := 100 ;
2518: LD_ADDR_OWVAR 32
2522: PUSH
2523: LD_INT 100
2525: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
2526: LD_ADDR_OWVAR 26
2530: PUSH
2531: LD_STRING Jeremy Sikorski
2533: ST_TO_ADDR
// hc_gallery := us ;
2534: LD_ADDR_OWVAR 33
2538: PUSH
2539: LD_STRING us
2541: ST_TO_ADDR
// hc_face_number := 19 ;
2542: LD_ADDR_OWVAR 34
2546: PUSH
2547: LD_INT 19
2549: ST_TO_ADDR
// hc_skills := [ Rand ( am_def + 2 , am_def + 4 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) ] ;
2550: LD_ADDR_OWVAR 31
2554: PUSH
2555: LD_EXP 6
2559: PUSH
2560: LD_INT 2
2562: PLUS
2563: PPUSH
2564: LD_EXP 6
2568: PUSH
2569: LD_INT 4
2571: PLUS
2572: PPUSH
2573: CALL_OW 12
2577: PUSH
2578: LD_EXP 6
2582: PUSH
2583: LD_INT 1
2585: MINUS
2586: PPUSH
2587: LD_EXP 6
2591: PUSH
2592: LD_INT 1
2594: PLUS
2595: PPUSH
2596: CALL_OW 12
2600: PUSH
2601: LD_EXP 6
2605: PUSH
2606: LD_INT 1
2608: MINUS
2609: PPUSH
2610: LD_EXP 6
2614: PUSH
2615: LD_INT 1
2617: PLUS
2618: PPUSH
2619: CALL_OW 12
2623: PUSH
2624: LD_EXP 6
2628: PUSH
2629: LD_INT 1
2631: MINUS
2632: PPUSH
2633: LD_EXP 6
2637: PUSH
2638: LD_INT 1
2640: PLUS
2641: PPUSH
2642: CALL_OW 12
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: ST_TO_ADDR
// hc_sex := sex_male ;
2653: LD_ADDR_OWVAR 27
2657: PUSH
2658: LD_INT 1
2660: ST_TO_ADDR
// hc_class := 1 ;
2661: LD_ADDR_OWVAR 28
2665: PUSH
2666: LD_INT 1
2668: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2669: LD_ADDR_OWVAR 29
2673: PUSH
2674: LD_INT 10
2676: PUSH
2677: LD_INT 12
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: ST_TO_ADDR
// sikorski := CreateHuman ;
2684: LD_ADDR_EXP 14
2688: PUSH
2689: CALL_OW 44
2693: ST_TO_ADDR
// if global_diff > 1 then
2694: LD_EXP 3
2698: PUSH
2699: LD_INT 1
2701: GREATER
2702: IFFALSE 2721
// PlaceUnitArea ( sikorski , sikorski_area , false ) else
2704: LD_EXP 14
2708: PPUSH
2709: LD_INT 8
2711: PPUSH
2712: LD_INT 0
2714: PPUSH
2715: CALL_OW 49
2719: GO 2812
// begin vc_chassis := us_light_wheeled ;
2721: LD_ADDR_OWVAR 37
2725: PUSH
2726: LD_INT 1
2728: ST_TO_ADDR
// vc_engine := engine_combustion ;
2729: LD_ADDR_OWVAR 39
2733: PUSH
2734: LD_INT 1
2736: ST_TO_ADDR
// vc_control := control_manual ;
2737: LD_ADDR_OWVAR 38
2741: PUSH
2742: LD_INT 1
2744: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
2745: LD_ADDR_OWVAR 40
2749: PUSH
2750: LD_INT 2
2752: ST_TO_ADDR
// vc_fuel_battery := 21 ;
2753: LD_ADDR_OWVAR 41
2757: PUSH
2758: LD_INT 21
2760: ST_TO_ADDR
// sikorski_veh := CreateVehicle ;
2761: LD_ADDR_EXP 22
2765: PUSH
2766: CALL_OW 45
2770: ST_TO_ADDR
// SetDir ( sikorski_veh , 0 ) ;
2771: LD_EXP 22
2775: PPUSH
2776: LD_INT 0
2778: PPUSH
2779: CALL_OW 233
// PlaceUnitArea ( sikorski_veh , sikorski_area , false ) ;
2783: LD_EXP 22
2787: PPUSH
2788: LD_INT 8
2790: PPUSH
2791: LD_INT 0
2793: PPUSH
2794: CALL_OW 49
// PlaceHumanInUnit ( sikorski , sikorski_veh ) ;
2798: LD_EXP 14
2802: PPUSH
2803: LD_EXP 22
2807: PPUSH
2808: CALL_OW 52
// end ; hc_importance := 0 ;
2812: LD_ADDR_OWVAR 32
2816: PUSH
2817: LD_INT 0
2819: ST_TO_ADDR
// hc_name := Ronn Harisson ;
2820: LD_ADDR_OWVAR 26
2824: PUSH
2825: LD_STRING Ronn Harisson
2827: ST_TO_ADDR
// hc_gallery := us ;
2828: LD_ADDR_OWVAR 33
2832: PUSH
2833: LD_STRING us
2835: ST_TO_ADDR
// hc_face_number := 6 ;
2836: LD_ADDR_OWVAR 34
2840: PUSH
2841: LD_INT 6
2843: ST_TO_ADDR
// ron := CreateHuman ;
2844: LD_ADDR_EXP 17
2848: PUSH
2849: CALL_OW 44
2853: ST_TO_ADDR
// hc_name := Jack Dickens ;
2854: LD_ADDR_OWVAR 26
2858: PUSH
2859: LD_STRING Jack Dickens
2861: ST_TO_ADDR
// hc_gallery :=  ;
2862: LD_ADDR_OWVAR 33
2866: PUSH
2867: LD_STRING 
2869: ST_TO_ADDR
// jack := CreateHuman ;
2870: LD_ADDR_EXP 18
2874: PUSH
2875: CALL_OW 44
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 1
2884: RET
// every 0 0$01 trigger GetDistUnits ( sikorski , omikron ) <= 45 do
2885: LD_EXP 14
2889: PPUSH
2890: LD_INT 64
2892: PPUSH
2893: CALL_OW 296
2897: PUSH
2898: LD_INT 45
2900: LESSEQUAL
2901: IFFALSE 2951
2903: GO 2905
2905: DISABLE
// ComBuild ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) , b_workshop , 16 , 5 , 3 ) ; end_of_file
2906: LD_INT 22
2908: PUSH
2909: LD_INT 4
2911: PUSH
2912: EMPTY
2913: LIST
2914: LIST
2915: PUSH
2916: LD_INT 25
2918: PUSH
2919: LD_INT 2
2921: PUSH
2922: EMPTY
2923: LIST
2924: LIST
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PPUSH
2930: CALL_OW 69
2934: PPUSH
2935: LD_INT 2
2937: PPUSH
2938: LD_INT 16
2940: PPUSH
2941: LD_INT 5
2943: PPUSH
2944: LD_INT 3
2946: PPUSH
2947: CALL_OW 145
2951: END
// export ru_sold , ru_stw , ru_tw , ru_tech , ru_veh , ru_eng , ru_mech , ru_sci , ru_bul , ru_b ; export ru2_sold , ru2_stw , ru2_tw , ru2_tech , ru2_veh , ru2_eng , ru2_mech , ru2_sci , ru2_bul , ru2_b ; export ru_list_attackers ; export function InitRussian ; var ru , ru2 , i , un , filter ; begin
2952: LD_INT 0
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
2959: PPUSH
// ru := 6 ;
2960: LD_ADDR_VAR 0 2
2964: PUSH
2965: LD_INT 6
2967: ST_TO_ADDR
// ru2 := 3 ;
2968: LD_ADDR_VAR 0 3
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// uc_nation := nation_russian ;
2976: LD_ADDR_OWVAR 21
2980: PUSH
2981: LD_INT 3
2983: ST_TO_ADDR
// ru_radar := 98 ;
2984: LD_ADDR_EXP 46
2988: PUSH
2989: LD_INT 98
2991: ST_TO_ADDR
// ru_list_attackers := [ ] ;
2992: LD_ADDR_EXP 43
2996: PUSH
2997: EMPTY
2998: ST_TO_ADDR
// uc_side := ru ;
2999: LD_ADDR_OWVAR 20
3003: PUSH
3004: LD_VAR 0 2
3008: ST_TO_ADDR
// ru_sold := [ ] ;
3009: LD_ADDR_EXP 23
3013: PUSH
3014: EMPTY
3015: ST_TO_ADDR
// ru_stw := [ ] ;
3016: LD_ADDR_EXP 24
3020: PUSH
3021: EMPTY
3022: ST_TO_ADDR
// ru_tw := [ ] ;
3023: LD_ADDR_EXP 25
3027: PUSH
3028: EMPTY
3029: ST_TO_ADDR
// ru_b := [ ] ;
3030: LD_ADDR_EXP 32
3034: PUSH
3035: EMPTY
3036: ST_TO_ADDR
// ru_eng := [ ] ;
3037: LD_ADDR_EXP 28
3041: PUSH
3042: EMPTY
3043: ST_TO_ADDR
// ru_mech := [ ] ;
3044: LD_ADDR_EXP 29
3048: PUSH
3049: EMPTY
3050: ST_TO_ADDR
// ru_sci := [ ] ;
3051: LD_ADDR_EXP 30
3055: PUSH
3056: EMPTY
3057: ST_TO_ADDR
// ru_bul := [ b_bunker , 162 , 101 , 0 , b_ext_rocket , 149 , 86 , 4 ] ;
3058: LD_ADDR_EXP 31
3062: PUSH
3063: LD_INT 32
3065: PUSH
3066: LD_INT 162
3068: PUSH
3069: LD_INT 101
3071: PUSH
3072: LD_INT 0
3074: PUSH
3075: LD_INT 18
3077: PUSH
3078: LD_INT 149
3080: PUSH
3081: LD_INT 86
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: ST_TO_ADDR
// ru_tech := [ tech_tech1 , tech_tech2 , tech_tech3 , tech_oilpow , tech_oileng , tech_weap1 , tech_weap2 , tech_gatling , tech_advmet , tech_weap3 ] ;
3097: LD_ADDR_EXP 26
3101: PUSH
3102: LD_INT 48
3104: PUSH
3105: LD_INT 49
3107: PUSH
3108: LD_INT 50
3110: PUSH
3111: LD_INT 46
3113: PUSH
3114: LD_INT 47
3116: PUSH
3117: LD_INT 51
3119: PUSH
3120: LD_INT 52
3122: PUSH
3123: LD_INT 69
3125: PUSH
3126: LD_INT 34
3128: PUSH
3129: LD_INT 53
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: ST_TO_ADDR
// ru_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3144: LD_ADDR_EXP 27
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 1
3154: PUSH
3155: LD_INT 1
3157: PUSH
3158: LD_INT 51
3160: PUSH
3161: LD_INT 22
3163: PUSH
3164: LD_INT 1
3166: PUSH
3167: LD_INT 1
3169: PUSH
3170: LD_INT 52
3172: PUSH
3173: LD_INT 22
3175: PUSH
3176: LD_INT 1
3178: PUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 52
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: LIST
3189: LIST
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: ST_TO_ADDR
// SetBName ( kirov , kirov ) ;
3199: LD_INT 71
3201: PPUSH
3202: LD_STRING kirov
3204: PPUSH
3205: CALL_OW 500
// hc_gallery := ru ;
3209: LD_ADDR_OWVAR 33
3213: PUSH
3214: LD_STRING ru
3216: ST_TO_ADDR
// hc_face_number := 8 ;
3217: LD_ADDR_OWVAR 34
3221: PUSH
3222: LD_INT 8
3224: ST_TO_ADDR
// hc_skills := [ 7 , 4 , 3 , 2 ] ;
3225: LD_ADDR_OWVAR 31
3229: PUSH
3230: LD_INT 7
3232: PUSH
3233: LD_INT 4
3235: PUSH
3236: LD_INT 3
3238: PUSH
3239: LD_INT 2
3241: PUSH
3242: EMPTY
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: ST_TO_ADDR
// hc_sex := sex_male ;
3248: LD_ADDR_OWVAR 27
3252: PUSH
3253: LD_INT 1
3255: ST_TO_ADDR
// hc_name := Ivan Kurin ;
3256: LD_ADDR_OWVAR 26
3260: PUSH
3261: LD_STRING Ivan Kurin
3263: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3264: LD_ADDR_OWVAR 29
3268: PUSH
3269: LD_INT 10
3271: PUSH
3272: LD_INT 10
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: ST_TO_ADDR
// kurin := CreateHuman ;
3279: LD_ADDR_EXP 15
3283: PUSH
3284: CALL_OW 44
3288: ST_TO_ADDR
// PlaceHumanInUnit ( kurin , kirov ) ;
3289: LD_EXP 15
3293: PPUSH
3294: LD_INT 71
3296: PPUSH
3297: CALL_OW 52
// filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_bunker ] ] ) ;
3301: LD_ADDR_VAR 0 6
3305: PUSH
3306: LD_INT 22
3308: PUSH
3309: LD_INT 6
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: LD_INT 30
3318: PUSH
3319: LD_INT 32
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PPUSH
3330: CALL_OW 69
3334: ST_TO_ADDR
// for i = 1 to ru_force do
3335: LD_ADDR_VAR 0 4
3339: PUSH
3340: DOUBLE
3341: LD_INT 1
3343: DEC
3344: ST_TO_ADDR
3345: LD_EXP 4
3349: PUSH
3350: FOR_TO
3351: IFFALSE 3422
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3353: LD_ADDR_VAR 0 5
3357: PUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_EXP 5
3365: PPUSH
3366: CALL 425 0 2
3370: ST_TO_ADDR
// if i <= filter then
3371: LD_VAR 0 4
3375: PUSH
3376: LD_VAR 0 6
3380: LESSEQUAL
3381: IFFALSE 3405
// PlaceHumanInUnit ( un , filter [ i ] ) else
3383: LD_VAR 0 5
3387: PPUSH
3388: LD_VAR 0 6
3392: PUSH
3393: LD_VAR 0 4
3397: ARRAY
3398: PPUSH
3399: CALL_OW 52
3403: GO 3420
// PlaceUnitArea ( un , ru_area , false ) ;
3405: LD_VAR 0 5
3409: PPUSH
3410: LD_INT 4
3412: PPUSH
3413: LD_INT 0
3415: PPUSH
3416: CALL_OW 49
// end ;
3420: GO 3350
3422: POP
3423: POP
// for i = 1 to 6 do
3424: LD_ADDR_VAR 0 4
3428: PUSH
3429: DOUBLE
3430: LD_INT 1
3432: DEC
3433: ST_TO_ADDR
3434: LD_INT 6
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3475
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
3440: LD_ADDR_VAR 0 5
3444: PUSH
3445: LD_INT 3
3447: PPUSH
3448: LD_EXP 5
3452: PPUSH
3453: CALL 425 0 2
3457: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3458: LD_VAR 0 5
3462: PPUSH
3463: LD_INT 4
3465: PPUSH
3466: LD_INT 0
3468: PPUSH
3469: CALL_OW 49
// end ;
3473: GO 3437
3475: POP
3476: POP
// for i = 1 to 3 do
3477: LD_ADDR_VAR 0 4
3481: PUSH
3482: DOUBLE
3483: LD_INT 1
3485: DEC
3486: ST_TO_ADDR
3487: LD_INT 3
3489: PUSH
3490: FOR_TO
3491: IFFALSE 3528
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
3493: LD_ADDR_VAR 0 5
3497: PUSH
3498: LD_INT 4
3500: PPUSH
3501: LD_EXP 5
3505: PPUSH
3506: CALL 425 0 2
3510: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3511: LD_VAR 0 5
3515: PPUSH
3516: LD_INT 4
3518: PPUSH
3519: LD_INT 0
3521: PPUSH
3522: CALL_OW 49
// end ;
3526: GO 3490
3528: POP
3529: POP
// for i = 1 to 4 do
3530: LD_ADDR_VAR 0 4
3534: PUSH
3535: DOUBLE
3536: LD_INT 1
3538: DEC
3539: ST_TO_ADDR
3540: LD_INT 4
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3581
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
3546: LD_ADDR_VAR 0 5
3550: PUSH
3551: LD_INT 2
3553: PPUSH
3554: LD_EXP 5
3558: PPUSH
3559: CALL 425 0 2
3563: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3564: LD_VAR 0 5
3568: PPUSH
3569: LD_INT 4
3571: PPUSH
3572: LD_INT 0
3574: PPUSH
3575: CALL_OW 49
// end ;
3579: GO 3543
3581: POP
3582: POP
// uc_side := ru2 ;
3583: LD_ADDR_OWVAR 20
3587: PUSH
3588: LD_VAR 0 3
3592: ST_TO_ADDR
// ru2_sold := [ ] ;
3593: LD_ADDR_EXP 33
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// ru2_stw := [ ] ;
3600: LD_ADDR_EXP 34
3604: PUSH
3605: EMPTY
3606: ST_TO_ADDR
// ru2_tw := [ ] ;
3607: LD_ADDR_EXP 35
3611: PUSH
3612: EMPTY
3613: ST_TO_ADDR
// ru2_b := [ ] ;
3614: LD_ADDR_EXP 42
3618: PUSH
3619: EMPTY
3620: ST_TO_ADDR
// ru2_eng := [ ] ;
3621: LD_ADDR_EXP 38
3625: PUSH
3626: EMPTY
3627: ST_TO_ADDR
// ru2_mech := [ ] ;
3628: LD_ADDR_EXP 39
3632: PUSH
3633: EMPTY
3634: ST_TO_ADDR
// ru2_sci := [ ] ;
3635: LD_ADDR_EXP 40
3639: PUSH
3640: EMPTY
3641: ST_TO_ADDR
// ru2_bul := [ b_lab , 90 , 71 , 1 , b_armoury , 88 , 58 , 2 , b_workshop , 103 , 66 , 4 , b_oil_power , 106 , 77 , 3 , b_oil_power , 110 , 77 , 3 , b_bunker , 109 , 65 , 4 , b_bunker , 92 , 85 , 0 , b_bunker , 74 , 72 , 0 , b_bunker , 71 , 66 , 2 , b_bunker , 115 , 79 , 4 , b_bunker , 112 , 69 , 4 , b_bunker , 111 , 84 , 5 ] ;
3642: LD_ADDR_EXP 41
3646: PUSH
3647: LD_INT 6
3649: PUSH
3650: LD_INT 90
3652: PUSH
3653: LD_INT 71
3655: PUSH
3656: LD_INT 1
3658: PUSH
3659: LD_INT 4
3661: PUSH
3662: LD_INT 88
3664: PUSH
3665: LD_INT 58
3667: PUSH
3668: LD_INT 2
3670: PUSH
3671: LD_INT 2
3673: PUSH
3674: LD_INT 103
3676: PUSH
3677: LD_INT 66
3679: PUSH
3680: LD_INT 4
3682: PUSH
3683: LD_INT 26
3685: PUSH
3686: LD_INT 106
3688: PUSH
3689: LD_INT 77
3691: PUSH
3692: LD_INT 3
3694: PUSH
3695: LD_INT 26
3697: PUSH
3698: LD_INT 110
3700: PUSH
3701: LD_INT 77
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 32
3709: PUSH
3710: LD_INT 109
3712: PUSH
3713: LD_INT 65
3715: PUSH
3716: LD_INT 4
3718: PUSH
3719: LD_INT 32
3721: PUSH
3722: LD_INT 92
3724: PUSH
3725: LD_INT 85
3727: PUSH
3728: LD_INT 0
3730: PUSH
3731: LD_INT 32
3733: PUSH
3734: LD_INT 74
3736: PUSH
3737: LD_INT 72
3739: PUSH
3740: LD_INT 0
3742: PUSH
3743: LD_INT 32
3745: PUSH
3746: LD_INT 71
3748: PUSH
3749: LD_INT 66
3751: PUSH
3752: LD_INT 2
3754: PUSH
3755: LD_INT 32
3757: PUSH
3758: LD_INT 115
3760: PUSH
3761: LD_INT 79
3763: PUSH
3764: LD_INT 4
3766: PUSH
3767: LD_INT 32
3769: PUSH
3770: LD_INT 112
3772: PUSH
3773: LD_INT 69
3775: PUSH
3776: LD_INT 4
3778: PUSH
3779: LD_INT 32
3781: PUSH
3782: LD_INT 111
3784: PUSH
3785: LD_INT 84
3787: PUSH
3788: LD_INT 5
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: LIST
3839: LIST
3840: ST_TO_ADDR
// ru2_tech := [ tech_tech1 , tech_tech2 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_advmet , tech_weap3 , tech_tech3 ] ;
3841: LD_ADDR_EXP 36
3845: PUSH
3846: LD_INT 48
3848: PUSH
3849: LD_INT 49
3851: PUSH
3852: LD_INT 51
3854: PUSH
3855: LD_INT 52
3857: PUSH
3858: LD_INT 69
3860: PUSH
3861: LD_INT 39
3863: PUSH
3864: LD_INT 34
3866: PUSH
3867: LD_INT 53
3869: PUSH
3870: LD_INT 50
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: ST_TO_ADDR
// ru2_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3884: LD_ADDR_EXP 37
3888: PUSH
3889: LD_INT 21
3891: PUSH
3892: LD_INT 1
3894: PUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 51
3900: PUSH
3901: LD_INT 22
3903: PUSH
3904: LD_INT 1
3906: PUSH
3907: LD_INT 1
3909: PUSH
3910: LD_INT 52
3912: PUSH
3913: LD_INT 22
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: LD_INT 1
3921: PUSH
3922: LD_INT 52
3924: PUSH
3925: EMPTY
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: ST_TO_ADDR
// SetBName ( beria , beria ) ;
3939: LD_INT 106
3941: PPUSH
3942: LD_STRING beria
3944: PPUSH
3945: CALL_OW 500
// SetBName ( kagan , kagan ) ;
3949: LD_INT 112
3951: PPUSH
3952: LD_STRING kagan
3954: PPUSH
3955: CALL_OW 500
// for i = 1 to 12 do
3959: LD_ADDR_VAR 0 4
3963: PUSH
3964: DOUBLE
3965: LD_INT 1
3967: DEC
3968: ST_TO_ADDR
3969: LD_INT 12
3971: PUSH
3972: FOR_TO
3973: IFFALSE 4010
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3975: LD_ADDR_VAR 0 5
3979: PUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_EXP 5
3987: PPUSH
3988: CALL 425 0 2
3992: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3993: LD_VAR 0 5
3997: PPUSH
3998: LD_INT 9
4000: PPUSH
4001: LD_INT 0
4003: PPUSH
4004: CALL_OW 49
// end ;
4008: GO 3972
4010: POP
4011: POP
// for i = 1 to 6 do
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: DOUBLE
4018: LD_INT 1
4020: DEC
4021: ST_TO_ADDR
4022: LD_INT 6
4024: PUSH
4025: FOR_TO
4026: IFFALSE 4063
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
4028: LD_ADDR_VAR 0 5
4032: PUSH
4033: LD_INT 3
4035: PPUSH
4036: LD_EXP 5
4040: PPUSH
4041: CALL 425 0 2
4045: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4046: LD_VAR 0 5
4050: PPUSH
4051: LD_INT 9
4053: PPUSH
4054: LD_INT 0
4056: PPUSH
4057: CALL_OW 49
// end ;
4061: GO 4025
4063: POP
4064: POP
// for i = 1 to 4 do
4065: LD_ADDR_VAR 0 4
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 4
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4116
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: LD_INT 4
4088: PPUSH
4089: LD_EXP 5
4093: PPUSH
4094: CALL 425 0 2
4098: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4099: LD_VAR 0 5
4103: PPUSH
4104: LD_INT 9
4106: PPUSH
4107: LD_INT 0
4109: PPUSH
4110: CALL_OW 49
// end ;
4114: GO 4078
4116: POP
4117: POP
// for i = 1 to 4 do
4118: LD_ADDR_VAR 0 4
4122: PUSH
4123: DOUBLE
4124: LD_INT 1
4126: DEC
4127: ST_TO_ADDR
4128: LD_INT 4
4130: PUSH
4131: FOR_TO
4132: IFFALSE 4169
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
4134: LD_ADDR_VAR 0 5
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: LD_EXP 5
4146: PPUSH
4147: CALL 425 0 2
4151: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4152: LD_VAR 0 5
4156: PPUSH
4157: LD_INT 9
4159: PPUSH
4160: LD_INT 0
4162: PPUSH
4163: CALL_OW 49
// end ;
4167: GO 4131
4169: POP
4170: POP
// end ;
4171: LD_VAR 0 1
4175: RET
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , enemy_detected ;
4176: GO 4178
4178: DISABLE
4179: LD_INT 0
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
4189: PPUSH
4190: PPUSH
// begin enable ;
4191: ENABLE
// ru_sold := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) diff Kurin ;
4192: LD_ADDR_EXP 23
4196: PUSH
4197: LD_INT 22
4199: PUSH
4200: LD_INT 6
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 25
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 24
4219: PUSH
4220: LD_INT 600
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: EMPTY
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_EXP 15
4244: DIFF
4245: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
4246: LD_ADDR_EXP 28
4250: PUSH
4251: LD_INT 22
4253: PUSH
4254: LD_INT 6
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 25
4263: PUSH
4264: LD_INT 2
4266: PUSH
4267: EMPTY
4268: LIST
4269: LIST
4270: PUSH
4271: LD_INT 24
4273: PUSH
4274: LD_INT 600
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: LIST
4285: PUSH
4286: EMPTY
4287: LIST
4288: PPUSH
4289: CALL_OW 69
4293: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
4294: LD_ADDR_EXP 29
4298: PUSH
4299: LD_INT 22
4301: PUSH
4302: LD_INT 6
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 25
4311: PUSH
4312: LD_INT 3
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 24
4321: PUSH
4322: LD_INT 600
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
4342: LD_ADDR_EXP 30
4346: PUSH
4347: LD_INT 22
4349: PUSH
4350: LD_INT 6
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 25
4359: PUSH
4360: LD_INT 4
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 24
4369: PUSH
4370: LD_INT 600
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: EMPTY
4383: LIST
4384: PPUSH
4385: CALL_OW 69
4389: ST_TO_ADDR
// ru_tw := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
4390: LD_ADDR_EXP 25
4394: PUSH
4395: LD_INT 22
4397: PUSH
4398: LD_INT 6
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 2
4407: PUSH
4408: LD_INT 30
4410: PUSH
4411: LD_INT 31
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 30
4420: PUSH
4421: LD_INT 32
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: LIST
4432: PUSH
4433: LD_INT 24
4435: PUSH
4436: LD_INT 250
4438: PUSH
4439: EMPTY
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: PPUSH
4451: CALL_OW 69
4455: ST_TO_ADDR
// ru_b := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) ;
4456: LD_ADDR_EXP 32
4460: PUSH
4461: LD_INT 22
4463: PUSH
4464: LD_INT 6
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PUSH
4471: LD_INT 21
4473: PUSH
4474: LD_INT 3
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PPUSH
4485: CALL_OW 69
4489: ST_TO_ADDR
// b_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4490: LD_ADDR_VAR 0 6
4494: PUSH
4495: LD_INT 22
4497: PUSH
4498: LD_INT 6
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 21
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 3
4517: PUSH
4518: LD_INT 24
4520: PUSH
4521: LD_INT 1000
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: EMPTY
4529: LIST
4530: LIST
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: PPUSH
4540: CALL_OW 69
4544: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
4545: LD_ADDR_VAR 0 5
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: LD_INT 6
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 21
4562: PUSH
4563: LD_INT 1
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: LD_INT 3
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 600
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: LIST
4591: PUSH
4592: EMPTY
4593: LIST
4594: PPUSH
4595: CALL_OW 69
4599: ST_TO_ADDR
// b_weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar , 89 ] ;
4600: LD_ADDR_VAR 0 8
4604: PUSH
4605: LD_INT 92
4607: PPUSH
4608: CALL_OW 478
4612: PUSH
4613: LD_INT 52
4615: PUSH
4616: LD_INT 51
4618: PUSH
4619: LD_INT 53
4621: PUSH
4622: LD_EXP 46
4626: PUSH
4627: LD_INT 89
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: LIST
4636: DIFF
4637: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_breastwork , b_workshop ] ;
4638: LD_ADDR_VAR 0 9
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 4
4648: PUSH
4649: LD_INT 31
4651: PUSH
4652: LD_INT 2
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: ST_TO_ADDR
// if FilterUnitsInArea ( kirov_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) > 0 then
4661: LD_INT 10
4663: PPUSH
4664: LD_INT 2
4666: PUSH
4667: LD_INT 22
4669: PUSH
4670: LD_INT 1
4672: PUSH
4673: EMPTY
4674: LIST
4675: LIST
4676: PUSH
4677: LD_INT 22
4679: PUSH
4680: LD_INT 2
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: PPUSH
4692: CALL_OW 70
4696: PUSH
4697: LD_INT 0
4699: GREATER
4700: IFFALSE 4712
// enemy_detected := true else
4702: LD_ADDR_VAR 0 10
4706: PUSH
4707: LD_INT 1
4709: ST_TO_ADDR
4710: GO 4720
// enemy_detected := false ;
4712: LD_ADDR_VAR 0 10
4716: PUSH
4717: LD_INT 0
4719: ST_TO_ADDR
// if enemy_detected = false then
4720: LD_VAR 0 10
4724: PUSH
4725: LD_INT 0
4727: EQUAL
4728: IFFALSE 4790
// for i = 1 to ru_b do
4730: LD_ADDR_VAR 0 1
4734: PUSH
4735: DOUBLE
4736: LD_INT 1
4738: DEC
4739: ST_TO_ADDR
4740: LD_EXP 32
4744: PUSH
4745: FOR_TO
4746: IFFALSE 4788
// if GetBType ( ru_b [ i ] ) in b_upgrade then
4748: LD_EXP 32
4752: PUSH
4753: LD_VAR 0 1
4757: ARRAY
4758: PPUSH
4759: CALL_OW 266
4763: PUSH
4764: LD_VAR 0 9
4768: IN
4769: IFFALSE 4786
// ComUpgrade ( ru_b [ i ] ) ;
4771: LD_EXP 32
4775: PUSH
4776: LD_VAR 0 1
4780: ARRAY
4781: PPUSH
4782: CALL_OW 146
4786: GO 4745
4788: POP
4789: POP
// if ru_sold > 0 then
4790: LD_EXP 23
4794: PUSH
4795: LD_INT 0
4797: GREATER
4798: IFFALSE 5246
// begin filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4800: LD_ADDR_VAR 0 4
4804: PUSH
4805: LD_EXP 23
4809: PPUSH
4810: LD_INT 3
4812: PUSH
4813: LD_INT 54
4815: PUSH
4816: EMPTY
4817: LIST
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PPUSH
4823: CALL_OW 72
4827: ST_TO_ADDR
// if UnitFilter ( ru_tw , [ f_empty ] ) > 0 then
4828: LD_EXP 25
4832: PPUSH
4833: LD_INT 58
4835: PUSH
4836: EMPTY
4837: LIST
4838: PPUSH
4839: CALL_OW 72
4843: PUSH
4844: LD_INT 0
4846: GREATER
4847: IFFALSE 4949
// begin if filter = 0 then
4849: LD_VAR 0 4
4853: PUSH
4854: LD_INT 0
4856: EQUAL
4857: IFFALSE 4882
// ComExitBuilding ( ru_sold [ Rand ( 1 , ru_sold ) ] ) ;
4859: LD_EXP 23
4863: PUSH
4864: LD_INT 1
4866: PPUSH
4867: LD_EXP 23
4871: PPUSH
4872: CALL_OW 12
4876: ARRAY
4877: PPUSH
4878: CALL_OW 122
// filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4882: LD_ADDR_VAR 0 4
4886: PUSH
4887: LD_EXP 23
4891: PPUSH
4892: LD_INT 3
4894: PUSH
4895: LD_INT 54
4897: PUSH
4898: EMPTY
4899: LIST
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PPUSH
4905: CALL_OW 72
4909: ST_TO_ADDR
// if filter then
4910: LD_VAR 0 4
4914: IFFALSE 4949
// ComEnterUnit ( filter [ 1 ] , UnitFilter ( ru_tw , [ f_empty ] ) [ 1 ] ) ;
4916: LD_VAR 0 4
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_EXP 25
4929: PPUSH
4930: LD_INT 58
4932: PUSH
4933: EMPTY
4934: LIST
4935: PPUSH
4936: CALL_OW 72
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: PPUSH
4945: CALL_OW 120
// end ; if UnitFilter ( ru_tw , [ f_empty ] ) = 0 then
4949: LD_EXP 25
4953: PPUSH
4954: LD_INT 58
4956: PUSH
4957: EMPTY
4958: LIST
4959: PPUSH
4960: CALL_OW 72
4964: PUSH
4965: LD_INT 0
4967: EQUAL
4968: IFFALSE 5123
// begin b_unit := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4970: LD_ADDR_VAR 0 7
4974: PUSH
4975: LD_INT 22
4977: PUSH
4978: LD_INT 6
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 2
4987: PUSH
4988: LD_INT 30
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 5
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PPUSH
5017: CALL_OW 69
5021: ST_TO_ADDR
// if b_unit > 0 then
5022: LD_VAR 0 7
5026: PUSH
5027: LD_INT 0
5029: GREATER
5030: IFFALSE 5123
// for p = 1 to b_unit do
5032: LD_ADDR_VAR 0 2
5036: PUSH
5037: DOUBLE
5038: LD_INT 1
5040: DEC
5041: ST_TO_ADDR
5042: LD_VAR 0 7
5046: PUSH
5047: FOR_TO
5048: IFFALSE 5121
// if UnitsInSide ( b_unit [ p ] ) < 6 then
5050: LD_VAR 0 7
5054: PUSH
5055: LD_VAR 0 2
5059: ARRAY
5060: PPUSH
5061: CALL_OW 313
5065: PUSH
5066: LD_INT 6
5068: LESS
5069: IFFALSE 5119
// for i = 1 to filter do
5071: LD_ADDR_VAR 0 1
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_VAR 0 4
5085: PUSH
5086: FOR_TO
5087: IFFALSE 5117
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
5089: LD_VAR 0 4
5093: PUSH
5094: LD_VAR 0 1
5098: ARRAY
5099: PPUSH
5100: LD_VAR 0 7
5104: PUSH
5105: LD_VAR 0 2
5109: ARRAY
5110: PPUSH
5111: CALL_OW 120
5115: GO 5086
5117: POP
5118: POP
5119: GO 5047
5121: POP
5122: POP
// end ; if UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
5123: LD_EXP 25
5127: PPUSH
5128: LD_INT 30
5130: PUSH
5131: LD_INT 32
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_INT 35
5140: PUSH
5141: LD_INT 0
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PPUSH
5152: CALL_OW 72
5156: PUSH
5157: LD_INT 0
5159: GREATER
5160: IFFALSE 5246
// begin filter := UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
5162: LD_ADDR_VAR 0 4
5166: PUSH
5167: LD_EXP 25
5171: PPUSH
5172: LD_INT 30
5174: PUSH
5175: LD_INT 32
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: LD_INT 35
5184: PUSH
5185: LD_INT 0
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PPUSH
5196: CALL_OW 72
5200: ST_TO_ADDR
// if BuildingStatus ( ru_fac ) = bs_idle then
5201: LD_INT 92
5203: PPUSH
5204: CALL_OW 461
5208: PUSH
5209: LD_INT 2
5211: EQUAL
5212: IFFALSE 5246
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
5214: LD_VAR 0 4
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PPUSH
5223: LD_VAR 0 8
5227: PUSH
5228: LD_INT 1
5230: PPUSH
5231: LD_VAR 0 8
5235: PPUSH
5236: CALL_OW 12
5240: ARRAY
5241: PPUSH
5242: CALL_OW 148
// end ; end ; if ru_mech > 0 then
5246: LD_EXP 29
5250: PUSH
5251: LD_INT 0
5253: GREATER
5254: IFFALSE 5314
// for i = 1 to ru_mech do
5256: LD_ADDR_VAR 0 1
5260: PUSH
5261: DOUBLE
5262: LD_INT 1
5264: DEC
5265: ST_TO_ADDR
5266: LD_EXP 29
5270: PUSH
5271: FOR_TO
5272: IFFALSE 5312
// if not IsInUnit ( ru_mech [ i ] ) then
5274: LD_EXP 29
5278: PUSH
5279: LD_VAR 0 1
5283: ARRAY
5284: PPUSH
5285: CALL_OW 310
5289: NOT
5290: IFFALSE 5310
// ComEnterUnit ( ru_mech [ i ] , ru_fac ) ;
5292: LD_EXP 29
5296: PUSH
5297: LD_VAR 0 1
5301: ARRAY
5302: PPUSH
5303: LD_INT 92
5305: PPUSH
5306: CALL_OW 120
5310: GO 5271
5312: POP
5313: POP
// if ru_fac then
5314: LD_INT 92
5316: IFFALSE 5422
// if ru_veh > 0 then
5318: LD_EXP 27
5322: PUSH
5323: LD_INT 0
5325: GREATER
5326: IFFALSE 5422
// if BuildingStatus ( ru_fac ) = bs_idle then
5328: LD_INT 92
5330: PPUSH
5331: CALL_OW 461
5335: PUSH
5336: LD_INT 2
5338: EQUAL
5339: IFFALSE 5422
// begin ComConstruct ( ru_fac , ru_veh [ 1 ] , ru_veh [ 2 ] , ru_veh [ 3 ] , ru_veh [ 4 ] ) ;
5341: LD_INT 92
5343: PPUSH
5344: LD_EXP 27
5348: PUSH
5349: LD_INT 1
5351: ARRAY
5352: PPUSH
5353: LD_EXP 27
5357: PUSH
5358: LD_INT 2
5360: ARRAY
5361: PPUSH
5362: LD_EXP 27
5366: PUSH
5367: LD_INT 3
5369: ARRAY
5370: PPUSH
5371: LD_EXP 27
5375: PUSH
5376: LD_INT 4
5378: ARRAY
5379: PPUSH
5380: CALL_OW 125
// for i = 1 to 4 do
5384: LD_ADDR_VAR 0 1
5388: PUSH
5389: DOUBLE
5390: LD_INT 1
5392: DEC
5393: ST_TO_ADDR
5394: LD_INT 4
5396: PUSH
5397: FOR_TO
5398: IFFALSE 5420
// ru_veh := Delete ( ru_veh , 1 ) ;
5400: LD_ADDR_EXP 27
5404: PUSH
5405: LD_EXP 27
5409: PPUSH
5410: LD_INT 1
5412: PPUSH
5413: CALL_OW 3
5417: ST_TO_ADDR
5418: GO 5397
5420: POP
5421: POP
// end ; if ru_bul > 0 and enemy_detected = false then
5422: LD_EXP 31
5426: PUSH
5427: LD_INT 0
5429: GREATER
5430: PUSH
5431: LD_VAR 0 10
5435: PUSH
5436: LD_INT 0
5438: EQUAL
5439: AND
5440: IFFALSE 5543
// if ru_eng > 0 then
5442: LD_EXP 28
5446: PUSH
5447: LD_INT 0
5449: GREATER
5450: IFFALSE 5543
// for i = 1 to ru_eng do
5452: LD_ADDR_VAR 0 1
5456: PUSH
5457: DOUBLE
5458: LD_INT 1
5460: DEC
5461: ST_TO_ADDR
5462: LD_EXP 28
5466: PUSH
5467: FOR_TO
5468: IFFALSE 5541
// if not HasTask ( ru_eng [ i ] ) then
5470: LD_EXP 28
5474: PUSH
5475: LD_VAR 0 1
5479: ARRAY
5480: PPUSH
5481: CALL_OW 314
5485: NOT
5486: IFFALSE 5539
// begin ComBuild ( ru_eng [ i ] , ru_bul [ 1 ] , ru_bul [ 2 ] , ru_bul [ 3 ] , ru_bul [ 4 ] ) ;
5488: LD_EXP 28
5492: PUSH
5493: LD_VAR 0 1
5497: ARRAY
5498: PPUSH
5499: LD_EXP 31
5503: PUSH
5504: LD_INT 1
5506: ARRAY
5507: PPUSH
5508: LD_EXP 31
5512: PUSH
5513: LD_INT 2
5515: ARRAY
5516: PPUSH
5517: LD_EXP 31
5521: PUSH
5522: LD_INT 3
5524: ARRAY
5525: PPUSH
5526: LD_EXP 31
5530: PUSH
5531: LD_INT 4
5533: ARRAY
5534: PPUSH
5535: CALL_OW 145
// end ;
5539: GO 5467
5541: POP
5542: POP
// if b_dmgunit > 0 then
5543: LD_VAR 0 6
5547: PUSH
5548: LD_INT 0
5550: GREATER
5551: IFFALSE 5736
// begin if ru_eng > 0 then
5553: LD_EXP 28
5557: PUSH
5558: LD_INT 0
5560: GREATER
5561: IFFALSE 5641
// for i = 1 to ru_eng do
5563: LD_ADDR_VAR 0 1
5567: PUSH
5568: DOUBLE
5569: LD_INT 1
5571: DEC
5572: ST_TO_ADDR
5573: LD_EXP 28
5577: PUSH
5578: FOR_TO
5579: IFFALSE 5639
// begin if IsInUnit ( ru_eng [ i ] ) then
5581: LD_EXP 28
5585: PUSH
5586: LD_VAR 0 1
5590: ARRAY
5591: PPUSH
5592: CALL_OW 310
5596: IFFALSE 5613
// ComExitBuilding ( ru_eng [ i ] ) ;
5598: LD_EXP 28
5602: PUSH
5603: LD_VAR 0 1
5607: ARRAY
5608: PPUSH
5609: CALL_OW 122
// ComRepairBuilding ( ru_eng [ i ] , b_dmgunit [ 1 ] ) ;
5613: LD_EXP 28
5617: PUSH
5618: LD_VAR 0 1
5622: ARRAY
5623: PPUSH
5624: LD_VAR 0 6
5628: PUSH
5629: LD_INT 1
5631: ARRAY
5632: PPUSH
5633: CALL_OW 130
// end ;
5637: GO 5578
5639: POP
5640: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) > 0 then
5641: LD_INT 22
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: LD_INT 34
5653: PUSH
5654: LD_INT 52
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PPUSH
5665: CALL_OW 69
5669: PUSH
5670: LD_INT 0
5672: GREATER
5673: IFFALSE 5734
// for p in FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) do
5675: LD_ADDR_VAR 0 2
5679: PUSH
5680: LD_INT 22
5682: PUSH
5683: LD_INT 6
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 34
5692: PUSH
5693: LD_INT 52
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: PPUSH
5704: CALL_OW 69
5708: PUSH
5709: FOR_IN
5710: IFFALSE 5732
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
5712: LD_VAR 0 2
5716: PPUSH
5717: LD_VAR 0 6
5721: PUSH
5722: LD_INT 1
5724: ARRAY
5725: PPUSH
5726: CALL_OW 130
5730: GO 5709
5732: POP
5733: POP
// end else
5734: GO 5864
// if ru_bul = 0 then
5736: LD_EXP 31
5740: PUSH
5741: LD_INT 0
5743: EQUAL
5744: IFFALSE 5864
// for i = 1 to ru_eng do
5746: LD_ADDR_VAR 0 1
5750: PUSH
5751: DOUBLE
5752: LD_INT 1
5754: DEC
5755: ST_TO_ADDR
5756: LD_EXP 28
5760: PUSH
5761: FOR_TO
5762: IFFALSE 5862
// if not HasTask ( ru_eng [ i ] ) then
5764: LD_EXP 28
5768: PUSH
5769: LD_VAR 0 1
5773: ARRAY
5774: PPUSH
5775: CALL_OW 314
5779: NOT
5780: IFFALSE 5860
// ComEnterUnit ( ru_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru_eng [ i ] ) ) ;
5782: LD_EXP 28
5786: PUSH
5787: LD_VAR 0 1
5791: ARRAY
5792: PPUSH
5793: LD_INT 22
5795: PUSH
5796: LD_INT 6
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 30
5808: PUSH
5809: LD_INT 0
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: PUSH
5816: LD_INT 30
5818: PUSH
5819: LD_INT 1
5821: PUSH
5822: EMPTY
5823: LIST
5824: LIST
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: LIST
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PPUSH
5835: CALL_OW 69
5839: PPUSH
5840: LD_EXP 28
5844: PUSH
5845: LD_VAR 0 1
5849: ARRAY
5850: PPUSH
5851: CALL_OW 74
5855: PPUSH
5856: CALL_OW 120
5860: GO 5761
5862: POP
5863: POP
// if h_dmgunit > 0 then
5864: LD_VAR 0 5
5868: PUSH
5869: LD_INT 0
5871: GREATER
5872: IFFALSE 6079
// begin for p = 1 to h_dmgunit do
5874: LD_ADDR_VAR 0 2
5878: PUSH
5879: DOUBLE
5880: LD_INT 1
5882: DEC
5883: ST_TO_ADDR
5884: LD_VAR 0 5
5888: PUSH
5889: FOR_TO
5890: IFFALSE 5939
// if GetDistUnits ( h_dmgunit [ p ] , ru_lab ) > 6 then
5892: LD_VAR 0 5
5896: PUSH
5897: LD_VAR 0 2
5901: ARRAY
5902: PPUSH
5903: LD_INT 83
5905: PPUSH
5906: CALL_OW 296
5910: PUSH
5911: LD_INT 6
5913: GREATER
5914: IFFALSE 5937
// ComMoveXY ( h_dmgunit [ p ] , 140 , 76 ) ;
5916: LD_VAR 0 5
5920: PUSH
5921: LD_VAR 0 2
5925: ARRAY
5926: PPUSH
5927: LD_INT 140
5929: PPUSH
5930: LD_INT 76
5932: PPUSH
5933: CALL_OW 111
5937: GO 5889
5939: POP
5940: POP
// if ru_sci > 0 then
5941: LD_EXP 30
5945: PUSH
5946: LD_INT 0
5948: GREATER
5949: IFFALSE 6079
// for i = 1 to ru_sci do
5951: LD_ADDR_VAR 0 1
5955: PUSH
5956: DOUBLE
5957: LD_INT 1
5959: DEC
5960: ST_TO_ADDR
5961: LD_EXP 30
5965: PUSH
5966: FOR_TO
5967: IFFALSE 6077
// if IsInUnit ( ru_sci [ i ] ) then
5969: LD_EXP 30
5973: PUSH
5974: LD_VAR 0 1
5978: ARRAY
5979: PPUSH
5980: CALL_OW 310
5984: IFFALSE 6003
// ComExitBuilding ( ru_sci [ i ] ) else
5986: LD_EXP 30
5990: PUSH
5991: LD_VAR 0 1
5995: ARRAY
5996: PPUSH
5997: CALL_OW 122
6001: GO 6075
// if not HasTask ( ru_sci [ i ] ) then
6003: LD_EXP 30
6007: PUSH
6008: LD_VAR 0 1
6012: ARRAY
6013: PPUSH
6014: CALL_OW 314
6018: NOT
6019: IFFALSE 6075
// if GetDistUnits ( ru_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
6021: LD_EXP 30
6025: PUSH
6026: LD_VAR 0 1
6030: ARRAY
6031: PPUSH
6032: LD_VAR 0 5
6036: PUSH
6037: LD_INT 1
6039: ARRAY
6040: PPUSH
6041: CALL_OW 296
6045: PUSH
6046: LD_INT 15
6048: LESSEQUAL
6049: IFFALSE 6075
// ComHeal ( ru_sci [ i ] , h_dmgunit [ 1 ] ) ;
6051: LD_EXP 30
6055: PUSH
6056: LD_VAR 0 1
6060: ARRAY
6061: PPUSH
6062: LD_VAR 0 5
6066: PUSH
6067: LD_INT 1
6069: ARRAY
6070: PPUSH
6071: CALL_OW 128
6075: GO 5966
6077: POP
6078: POP
// end ; if h_dmgunit = 0 then
6079: LD_VAR 0 5
6083: PUSH
6084: LD_INT 0
6086: EQUAL
6087: IFFALSE 6204
// begin for i = 1 to ru_sci do
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: DOUBLE
6095: LD_INT 1
6097: DEC
6098: ST_TO_ADDR
6099: LD_EXP 30
6103: PUSH
6104: FOR_TO
6105: IFFALSE 6145
// if not IsInUnit ( ru_sci [ i ] ) then
6107: LD_EXP 30
6111: PUSH
6112: LD_VAR 0 1
6116: ARRAY
6117: PPUSH
6118: CALL_OW 310
6122: NOT
6123: IFFALSE 6143
// ComEnterUnit ( ru_sci [ i ] , ru_lab ) ;
6125: LD_EXP 30
6129: PUSH
6130: LD_VAR 0 1
6134: ARRAY
6135: PPUSH
6136: LD_INT 83
6138: PPUSH
6139: CALL_OW 120
6143: GO 6104
6145: POP
6146: POP
// if ru_tech > 0 then
6147: LD_EXP 26
6151: PUSH
6152: LD_INT 0
6154: GREATER
6155: IFFALSE 6204
// if BuildingStatus ( ru_lab ) = bs_idle then
6157: LD_INT 83
6159: PPUSH
6160: CALL_OW 461
6164: PUSH
6165: LD_INT 2
6167: EQUAL
6168: IFFALSE 6204
// begin ComResearch ( ru_lab , ru_tech [ 1 ] ) ;
6170: LD_INT 83
6172: PPUSH
6173: LD_EXP 26
6177: PUSH
6178: LD_INT 1
6180: ARRAY
6181: PPUSH
6182: CALL_OW 124
// ru_tech := Delete ( ru_tech , 1 ) ;
6186: LD_ADDR_EXP 26
6190: PUSH
6191: LD_EXP 26
6195: PPUSH
6196: LD_INT 1
6198: PPUSH
6199: CALL_OW 3
6203: ST_TO_ADDR
// end ; end ; end ;
6204: PPOPN 10
6206: END
// every 20 20$00 trigger ru_fac do var weap ;
6207: LD_INT 92
6209: IFFALSE 6436
6211: GO 6213
6213: DISABLE
6214: LD_INT 0
6216: PPUSH
// begin enable ;
6217: ENABLE
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6218: LD_ADDR_VAR 0 1
6222: PUSH
6223: LD_INT 22
6225: PUSH
6226: LD_INT 6
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 30
6235: PUSH
6236: LD_INT 3
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 69
6251: PUSH
6252: LD_INT 1
6254: ARRAY
6255: PPUSH
6256: CALL_OW 478
6260: PUSH
6261: LD_INT 52
6263: PUSH
6264: LD_INT 51
6266: PUSH
6267: LD_INT 53
6269: PUSH
6270: LD_EXP 46
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: DIFF
6281: ST_TO_ADDR
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6282: LD_ADDR_EXP 27
6286: PUSH
6287: LD_EXP 27
6291: PUSH
6292: LD_INT 23
6294: PUSH
6295: LD_INT 1
6297: PUSH
6298: LD_INT 1
6300: PUSH
6301: LD_VAR 0 1
6305: PUSH
6306: LD_INT 1
6308: PPUSH
6309: LD_VAR 0 1
6313: PPUSH
6314: CALL_OW 12
6318: ARRAY
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: ADD
6326: ST_TO_ADDR
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6327: LD_ADDR_VAR 0 1
6331: PUSH
6332: LD_INT 22
6334: PUSH
6335: LD_INT 3
6337: PUSH
6338: EMPTY
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 30
6344: PUSH
6345: LD_INT 3
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PPUSH
6356: CALL_OW 69
6360: PUSH
6361: LD_INT 1
6363: ARRAY
6364: PPUSH
6365: CALL_OW 478
6369: PUSH
6370: LD_INT 52
6372: PUSH
6373: LD_INT 51
6375: PUSH
6376: LD_INT 53
6378: PUSH
6379: LD_EXP 46
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: DIFF
6390: ST_TO_ADDR
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6391: LD_ADDR_EXP 37
6395: PUSH
6396: LD_EXP 37
6400: PUSH
6401: LD_INT 23
6403: PUSH
6404: LD_INT 1
6406: PUSH
6407: LD_INT 1
6409: PUSH
6410: LD_VAR 0 1
6414: PUSH
6415: LD_INT 1
6417: PPUSH
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 12
6427: ARRAY
6428: PUSH
6429: EMPTY
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: ADD
6435: ST_TO_ADDR
// end ;
6436: PPOPN 1
6438: END
// every 0 0$03 do var i , c , p , skr , filter , cargo , dep ;
6439: GO 6441
6441: DISABLE
6442: LD_INT 0
6444: PPUSH
6445: PPUSH
6446: PPUSH
6447: PPUSH
6448: PPUSH
6449: PPUSH
6450: PPUSH
// begin enable ;
6451: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
6452: LD_ADDR_VAR 0 5
6456: PUSH
6457: LD_INT 50
6459: PUSH
6460: EMPTY
6461: LIST
6462: PUSH
6463: LD_INT 22
6465: PUSH
6466: LD_INT 6
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: LD_INT 25
6478: PUSH
6479: LD_INT 2
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PUSH
6486: LD_INT 25
6488: PUSH
6489: LD_INT 16
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: LIST
6505: PPUSH
6506: CALL_OW 69
6510: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_weapon , ru_cargo_bay ] , [ f_lives , 600 ] ] ) ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_INT 2
6518: PUSH
6519: LD_INT 22
6521: PUSH
6522: LD_INT 6
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PUSH
6529: LD_INT 22
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 34
6546: PUSH
6547: LD_INT 51
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: PUSH
6554: LD_INT 24
6556: PUSH
6557: LD_INT 600
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: LIST
6568: PPUSH
6569: CALL_OW 69
6573: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6574: LD_ADDR_VAR 0 7
6578: PUSH
6579: LD_INT 2
6581: PUSH
6582: LD_INT 22
6584: PUSH
6585: LD_INT 6
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: LD_INT 22
6594: PUSH
6595: LD_INT 3
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 2
6609: PUSH
6610: LD_INT 30
6612: PUSH
6613: LD_INT 0
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PUSH
6620: LD_INT 30
6622: PUSH
6623: LD_INT 1
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_main_area ) ;
6644: LD_ADDR_VAR 0 4
6648: PUSH
6649: LD_INT 2
6651: PPUSH
6652: CALL_OW 435
6656: ST_TO_ADDR
// c = 1 ;
6657: LD_ADDR_VAR 0 2
6661: PUSH
6662: LD_INT 1
6664: ST_TO_ADDR
// if cargo > 0 then
6665: LD_VAR 0 6
6669: PUSH
6670: LD_INT 0
6672: GREATER
6673: IFFALSE 6965
// while c < skr do
6675: LD_VAR 0 2
6679: PUSH
6680: LD_VAR 0 4
6684: LESS
6685: IFFALSE 6965
// begin if cargo then
6687: LD_VAR 0 6
6691: IFFALSE 6963
// for i in cargo do
6693: LD_ADDR_VAR 0 1
6697: PUSH
6698: LD_VAR 0 6
6702: PUSH
6703: FOR_IN
6704: IFFALSE 6961
// begin if not IsOk ( i ) or not skr then
6706: LD_VAR 0 1
6710: PPUSH
6711: CALL_OW 302
6715: NOT
6716: PUSH
6717: LD_VAR 0 4
6721: NOT
6722: OR
6723: IFFALSE 6727
// continue ;
6725: GO 6703
// if c > skr then
6727: LD_VAR 0 2
6731: PUSH
6732: LD_VAR 0 4
6736: GREATER
6737: IFFALSE 6741
// continue ;
6739: GO 6703
// if GetFuel ( i ) > 40 and GetDistUnitXY ( i , skr [ c ] , skr [ c + 1 ] ) < 51 then
6741: LD_VAR 0 1
6745: PPUSH
6746: CALL_OW 261
6750: PUSH
6751: LD_INT 40
6753: GREATER
6754: PUSH
6755: LD_VAR 0 1
6759: PPUSH
6760: LD_VAR 0 4
6764: PUSH
6765: LD_VAR 0 2
6769: ARRAY
6770: PPUSH
6771: LD_VAR 0 4
6775: PUSH
6776: LD_VAR 0 2
6780: PUSH
6781: LD_INT 1
6783: PLUS
6784: ARRAY
6785: PPUSH
6786: CALL_OW 297
6790: PUSH
6791: LD_INT 51
6793: LESS
6794: AND
6795: IFFALSE 6832
// ComCollect ( i , skr [ c ] , skr [ c + 1 ] ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_VAR 0 4
6806: PUSH
6807: LD_VAR 0 2
6811: ARRAY
6812: PPUSH
6813: LD_VAR 0 4
6817: PUSH
6818: LD_VAR 0 2
6822: PUSH
6823: LD_INT 1
6825: PLUS
6826: ARRAY
6827: PPUSH
6828: CALL_OW 117
// if GetFuel ( i ) <= 40 then
6832: LD_VAR 0 1
6836: PPUSH
6837: CALL_OW 261
6841: PUSH
6842: LD_INT 40
6844: LESSEQUAL
6845: IFFALSE 6945
// begin repeat begin ComMoveXY ( i , GetX ( NearestUnitToUnit ( dep , i ) ) , GetY ( NearestUnitToUnit ( dep , i ) ) ) ;
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_VAR 0 7
6856: PPUSH
6857: LD_VAR 0 1
6861: PPUSH
6862: CALL_OW 74
6866: PPUSH
6867: CALL_OW 250
6871: PPUSH
6872: LD_VAR 0 7
6876: PPUSH
6877: LD_VAR 0 1
6881: PPUSH
6882: CALL_OW 74
6886: PPUSH
6887: CALL_OW 251
6891: PPUSH
6892: CALL_OW 111
// Wait ( 0 0$01 ) ;
6896: LD_INT 35
6898: PPUSH
6899: CALL_OW 67
// end until GetDistUnits ( i , NearestUnitToUnit ( dep , i ) ) < 5 ;
6903: LD_VAR 0 1
6907: PPUSH
6908: LD_VAR 0 7
6912: PPUSH
6913: LD_VAR 0 1
6917: PPUSH
6918: CALL_OW 74
6922: PPUSH
6923: CALL_OW 296
6927: PUSH
6928: LD_INT 5
6930: LESS
6931: IFFALSE 6847
// SetFuel ( i , 100 ) ;
6933: LD_VAR 0 1
6937: PPUSH
6938: LD_INT 100
6940: PPUSH
6941: CALL_OW 240
// end ; c = c + 2 ;
6945: LD_ADDR_VAR 0 2
6949: PUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 2
6957: PLUS
6958: ST_TO_ADDR
// end ;
6959: GO 6703
6961: POP
6962: POP
// end ;
6963: GO 6675
// end ;
6965: PPOPN 7
6967: END
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , b_fac , b_labb , b_ext , enemy_detected ;
6968: GO 6970
6970: DISABLE
6971: LD_INT 0
6973: PPUSH
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
6978: PPUSH
6979: PPUSH
6980: PPUSH
6981: PPUSH
6982: PPUSH
6983: PPUSH
6984: PPUSH
6985: PPUSH
// begin enable ;
6986: ENABLE
// ru2_sold := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) ;
6987: LD_ADDR_EXP 33
6991: PUSH
6992: LD_INT 22
6994: PUSH
6995: LD_INT 3
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PUSH
7002: LD_INT 25
7004: PUSH
7005: LD_INT 1
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 24
7014: PUSH
7015: LD_INT 600
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: PUSH
7027: EMPTY
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: ST_TO_ADDR
// ru2_eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
7035: LD_ADDR_EXP 38
7039: PUSH
7040: LD_INT 22
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 25
7052: PUSH
7053: LD_INT 2
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: LD_INT 24
7062: PUSH
7063: LD_INT 600
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: PPUSH
7078: CALL_OW 69
7082: ST_TO_ADDR
// ru2_mech := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
7083: LD_ADDR_EXP 39
7087: PUSH
7088: LD_INT 22
7090: PUSH
7091: LD_INT 3
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 3
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PUSH
7108: LD_INT 24
7110: PUSH
7111: LD_INT 600
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: EMPTY
7124: LIST
7125: PPUSH
7126: CALL_OW 69
7130: ST_TO_ADDR
// ru2_sci := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
7131: LD_ADDR_EXP 40
7135: PUSH
7136: LD_INT 22
7138: PUSH
7139: LD_INT 3
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PUSH
7146: LD_INT 25
7148: PUSH
7149: LD_INT 4
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: LD_INT 600
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: PPUSH
7174: CALL_OW 69
7178: ST_TO_ADDR
// ru2_tw := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
7179: LD_ADDR_EXP 35
7183: PUSH
7184: LD_INT 22
7186: PUSH
7187: LD_INT 3
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 2
7196: PUSH
7197: LD_INT 30
7199: PUSH
7200: LD_INT 31
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 30
7209: PUSH
7210: LD_INT 32
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 24
7224: PUSH
7225: LD_INT 250
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: PUSH
7237: EMPTY
7238: LIST
7239: PPUSH
7240: CALL_OW 69
7244: ST_TO_ADDR
// ru2_b := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
7245: LD_ADDR_EXP 42
7249: PUSH
7250: LD_INT 22
7252: PUSH
7253: LD_INT 3
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 21
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PPUSH
7274: CALL_OW 69
7278: ST_TO_ADDR
// b_dmgunit := FilterUnitsInArea ( beria_defa , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
7279: LD_ADDR_VAR 0 6
7283: PUSH
7284: LD_INT 17
7286: PPUSH
7287: LD_INT 22
7289: PUSH
7290: LD_INT 3
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 21
7299: PUSH
7300: LD_INT 3
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 3
7309: PUSH
7310: LD_INT 24
7312: PUSH
7313: LD_INT 1000
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: PUSH
7329: EMPTY
7330: LIST
7331: PPUSH
7332: CALL_OW 70
7336: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
7337: LD_ADDR_VAR 0 5
7341: PUSH
7342: LD_INT 22
7344: PUSH
7345: LD_INT 3
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 21
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: LD_INT 24
7367: PUSH
7368: LD_INT 600
7370: PUSH
7371: EMPTY
7372: LIST
7373: LIST
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: PUSH
7384: EMPTY
7385: LIST
7386: PPUSH
7387: CALL_OW 69
7391: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7392: LD_INT 22
7394: PUSH
7395: LD_INT 3
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 30
7404: PUSH
7405: LD_INT 3
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL_OW 69
7420: IFFALSE 7460
// b_fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7422: LD_ADDR_VAR 0 10
7426: PUSH
7427: LD_INT 22
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 30
7439: PUSH
7440: LD_INT 3
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PPUSH
7451: CALL_OW 69
7455: PUSH
7456: LD_INT 1
7458: ARRAY
7459: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
7460: LD_INT 22
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: LD_INT 2
7472: PUSH
7473: LD_INT 30
7475: PUSH
7476: LD_INT 6
7478: PUSH
7479: EMPTY
7480: LIST
7481: LIST
7482: PUSH
7483: LD_INT 30
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 30
7495: PUSH
7496: LD_INT 8
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PPUSH
7513: CALL_OW 69
7517: IFFALSE 7586
// b_labb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7519: LD_ADDR_VAR 0 11
7523: PUSH
7524: LD_INT 22
7526: PUSH
7527: LD_INT 3
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_INT 2
7536: PUSH
7537: LD_INT 30
7539: PUSH
7540: LD_INT 6
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: LD_INT 30
7549: PUSH
7550: LD_INT 7
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 30
7559: PUSH
7560: LD_INT 8
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PPUSH
7577: CALL_OW 69
7581: PUSH
7582: LD_INT 1
7584: ARRAY
7585: ST_TO_ADDR
// b_weap := AvailableWeaponList ( b_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar , 89 ] ;
7586: LD_ADDR_VAR 0 8
7590: PUSH
7591: LD_VAR 0 10
7595: PPUSH
7596: CALL_OW 478
7600: PUSH
7601: LD_INT 52
7603: PUSH
7604: LD_INT 51
7606: PUSH
7607: LD_INT 53
7609: PUSH
7610: LD_EXP 46
7614: PUSH
7615: LD_INT 89
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: DIFF
7625: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_workshop ] ;
7626: LD_ADDR_VAR 0 9
7630: PUSH
7631: LD_INT 0
7633: PUSH
7634: LD_INT 4
7636: PUSH
7637: LD_INT 2
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: LIST
7644: ST_TO_ADDR
// b_ext := [ ] ;
7645: LD_ADDR_VAR 0 12
7649: PUSH
7650: EMPTY
7651: ST_TO_ADDR
// if FilterUnitsInArea ( beria_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) diff FilterAllUnits ( [ f_weapon , us_radar ] ) > 0 then
7652: LD_INT 11
7654: PPUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 22
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 22
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 70
7687: PUSH
7688: LD_INT 34
7690: PUSH
7691: LD_INT 11
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PPUSH
7698: CALL_OW 69
7702: PUSH
7703: LD_INT 0
7705: GREATER
7706: DIFF
7707: IFFALSE 7719
// enemy_detected := true else
7709: LD_ADDR_VAR 0 13
7713: PUSH
7714: LD_INT 1
7716: ST_TO_ADDR
7717: GO 7727
// enemy_detected := false ;
7719: LD_ADDR_VAR 0 13
7723: PUSH
7724: LD_INT 0
7726: ST_TO_ADDR
// if enemy_detected = false then
7727: LD_VAR 0 13
7731: PUSH
7732: LD_INT 0
7734: EQUAL
7735: IFFALSE 7836
// for i = 1 to ru2_b do
7737: LD_ADDR_VAR 0 1
7741: PUSH
7742: DOUBLE
7743: LD_INT 1
7745: DEC
7746: ST_TO_ADDR
7747: LD_EXP 42
7751: PUSH
7752: FOR_TO
7753: IFFALSE 7834
// begin if GetBType ( ru2_b [ i ] ) in b_upgrade then
7755: LD_EXP 42
7759: PUSH
7760: LD_VAR 0 1
7764: ARRAY
7765: PPUSH
7766: CALL_OW 266
7770: PUSH
7771: LD_VAR 0 9
7775: IN
7776: IFFALSE 7793
// ComUpgrade ( ru2_b [ i ] ) ;
7778: LD_EXP 42
7782: PUSH
7783: LD_VAR 0 1
7787: ARRAY
7788: PPUSH
7789: CALL_OW 146
// if GetBType ( ru2_b [ i ] ) in b_lab then
7793: LD_EXP 42
7797: PUSH
7798: LD_VAR 0 1
7802: ARRAY
7803: PPUSH
7804: CALL_OW 266
7808: PUSH
7809: LD_INT 6
7811: IN
7812: IFFALSE 7832
// ComUpgradeLab ( ru2_b [ i ] , b_lab_weapon ) ;
7814: LD_EXP 42
7818: PUSH
7819: LD_VAR 0 1
7823: ARRAY
7824: PPUSH
7825: LD_INT 10
7827: PPUSH
7828: CALL_OW 147
// end ;
7832: GO 7752
7834: POP
7835: POP
// if ru2_sold > 0 then
7836: LD_EXP 33
7840: PUSH
7841: LD_INT 0
7843: GREATER
7844: IFFALSE 8342
// begin filter := UnitFilter ( ru2_sold , [ f_not , [ f_inside ] ] ) ;
7846: LD_ADDR_VAR 0 4
7850: PUSH
7851: LD_EXP 33
7855: PPUSH
7856: LD_INT 3
7858: PUSH
7859: LD_INT 54
7861: PUSH
7862: EMPTY
7863: LIST
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 72
7873: ST_TO_ADDR
// if UnitFilter ( ru2_tw , [ f_empty ] ) > 0 then
7874: LD_EXP 35
7878: PPUSH
7879: LD_INT 58
7881: PUSH
7882: EMPTY
7883: LIST
7884: PPUSH
7885: CALL_OW 72
7889: PUSH
7890: LD_INT 0
7892: GREATER
7893: IFFALSE 8043
// begin if filter = 0 then
7895: LD_VAR 0 4
7899: PUSH
7900: LD_INT 0
7902: EQUAL
7903: IFFALSE 7928
// ComExitBuilding ( ru2_sold [ Rand ( 1 , ru2_sold ) ] ) ;
7905: LD_EXP 33
7909: PUSH
7910: LD_INT 1
7912: PPUSH
7913: LD_EXP 33
7917: PPUSH
7918: CALL_OW 12
7922: ARRAY
7923: PPUSH
7924: CALL_OW 122
// if UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
7928: LD_VAR 0 4
7932: PPUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 60
7938: PUSH
7939: EMPTY
7940: LIST
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PPUSH
7946: CALL_OW 72
7950: IFFALSE 8043
// for i in UnitFilter ( ru2_tw , [ f_empty ] ) do
7952: LD_ADDR_VAR 0 1
7956: PUSH
7957: LD_EXP 35
7961: PPUSH
7962: LD_INT 58
7964: PUSH
7965: EMPTY
7966: LIST
7967: PPUSH
7968: CALL_OW 72
7972: PUSH
7973: FOR_IN
7974: IFFALSE 8041
// begin ComEnterUnit ( UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) [ 1 ] , i ) ;
7976: LD_VAR 0 4
7980: PPUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 60
7986: PUSH
7987: EMPTY
7988: LIST
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PPUSH
7994: CALL_OW 72
7998: PUSH
7999: LD_INT 1
8001: ARRAY
8002: PPUSH
8003: LD_VAR 0 1
8007: PPUSH
8008: CALL_OW 120
// if not UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
8012: LD_VAR 0 4
8016: PPUSH
8017: LD_INT 3
8019: PUSH
8020: LD_INT 60
8022: PUSH
8023: EMPTY
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 72
8034: NOT
8035: IFFALSE 8039
// break ;
8037: GO 8041
// end ;
8039: GO 7973
8041: POP
8042: POP
// end ; if UnitFilter ( ru2_tw , [ f_empty ] ) = 0 then
8043: LD_EXP 35
8047: PPUSH
8048: LD_INT 58
8050: PUSH
8051: EMPTY
8052: LIST
8053: PPUSH
8054: CALL_OW 72
8058: PUSH
8059: LD_INT 0
8061: EQUAL
8062: IFFALSE 8217
// begin b_unit := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
8064: LD_ADDR_VAR 0 7
8068: PUSH
8069: LD_INT 22
8071: PUSH
8072: LD_INT 3
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 2
8081: PUSH
8082: LD_INT 30
8084: PUSH
8085: LD_INT 4
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: LD_INT 30
8094: PUSH
8095: LD_INT 5
8097: PUSH
8098: EMPTY
8099: LIST
8100: LIST
8101: PUSH
8102: EMPTY
8103: LIST
8104: LIST
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 69
8115: ST_TO_ADDR
// if b_unit > 0 then
8116: LD_VAR 0 7
8120: PUSH
8121: LD_INT 0
8123: GREATER
8124: IFFALSE 8217
// for p = 1 to b_unit do
8126: LD_ADDR_VAR 0 2
8130: PUSH
8131: DOUBLE
8132: LD_INT 1
8134: DEC
8135: ST_TO_ADDR
8136: LD_VAR 0 7
8140: PUSH
8141: FOR_TO
8142: IFFALSE 8215
// if UnitsInSide ( b_unit [ p ] ) < 6 then
8144: LD_VAR 0 7
8148: PUSH
8149: LD_VAR 0 2
8153: ARRAY
8154: PPUSH
8155: CALL_OW 313
8159: PUSH
8160: LD_INT 6
8162: LESS
8163: IFFALSE 8213
// for i = 1 to filter do
8165: LD_ADDR_VAR 0 1
8169: PUSH
8170: DOUBLE
8171: LD_INT 1
8173: DEC
8174: ST_TO_ADDR
8175: LD_VAR 0 4
8179: PUSH
8180: FOR_TO
8181: IFFALSE 8211
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
8183: LD_VAR 0 4
8187: PUSH
8188: LD_VAR 0 1
8192: ARRAY
8193: PPUSH
8194: LD_VAR 0 7
8198: PUSH
8199: LD_VAR 0 2
8203: ARRAY
8204: PPUSH
8205: CALL_OW 120
8209: GO 8180
8211: POP
8212: POP
8213: GO 8141
8215: POP
8216: POP
// end ; if UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
8217: LD_EXP 35
8221: PPUSH
8222: LD_INT 30
8224: PUSH
8225: LD_INT 32
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 35
8234: PUSH
8235: LD_INT 0
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: EMPTY
8243: LIST
8244: LIST
8245: PPUSH
8246: CALL_OW 72
8250: PUSH
8251: LD_INT 0
8253: GREATER
8254: IFFALSE 8342
// begin filter := UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
8256: LD_ADDR_VAR 0 4
8260: PUSH
8261: LD_EXP 35
8265: PPUSH
8266: LD_INT 30
8268: PUSH
8269: LD_INT 32
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: PUSH
8276: LD_INT 35
8278: PUSH
8279: LD_INT 0
8281: PUSH
8282: EMPTY
8283: LIST
8284: LIST
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 72
8294: ST_TO_ADDR
// if BuildingStatus ( b_fac ) = bs_idle then
8295: LD_VAR 0 10
8299: PPUSH
8300: CALL_OW 461
8304: PUSH
8305: LD_INT 2
8307: EQUAL
8308: IFFALSE 8342
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
8310: LD_VAR 0 4
8314: PUSH
8315: LD_INT 1
8317: ARRAY
8318: PPUSH
8319: LD_VAR 0 8
8323: PUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_VAR 0 8
8331: PPUSH
8332: CALL_OW 12
8336: ARRAY
8337: PPUSH
8338: CALL_OW 148
// end ; end ; if b_fac > 0 and ru2_mech > 0 then
8342: LD_VAR 0 10
8346: PUSH
8347: LD_INT 0
8349: GREATER
8350: PUSH
8351: LD_EXP 39
8355: PUSH
8356: LD_INT 0
8358: GREATER
8359: AND
8360: IFFALSE 8422
// for i = 1 to ru2_mech do
8362: LD_ADDR_VAR 0 1
8366: PUSH
8367: DOUBLE
8368: LD_INT 1
8370: DEC
8371: ST_TO_ADDR
8372: LD_EXP 39
8376: PUSH
8377: FOR_TO
8378: IFFALSE 8420
// if not IsInUnit ( ru2_mech [ i ] ) then
8380: LD_EXP 39
8384: PUSH
8385: LD_VAR 0 1
8389: ARRAY
8390: PPUSH
8391: CALL_OW 310
8395: NOT
8396: IFFALSE 8418
// ComEnterUnit ( ru2_mech [ i ] , b_fac ) ;
8398: LD_EXP 39
8402: PUSH
8403: LD_VAR 0 1
8407: ARRAY
8408: PPUSH
8409: LD_VAR 0 10
8413: PPUSH
8414: CALL_OW 120
8418: GO 8377
8420: POP
8421: POP
// if b_fac > 0 and ru2_veh > 0 then
8422: LD_VAR 0 10
8426: PUSH
8427: LD_INT 0
8429: GREATER
8430: PUSH
8431: LD_EXP 37
8435: PUSH
8436: LD_INT 0
8438: GREATER
8439: AND
8440: IFFALSE 8540
// if BuildingStatus ( b_fac ) = bs_idle then
8442: LD_VAR 0 10
8446: PPUSH
8447: CALL_OW 461
8451: PUSH
8452: LD_INT 2
8454: EQUAL
8455: IFFALSE 8540
// begin ComConstruct ( b_fac , ru2_veh [ 1 ] , ru2_veh [ 2 ] , ru2_veh [ 3 ] , ru2_veh [ 4 ] ) ;
8457: LD_VAR 0 10
8461: PPUSH
8462: LD_EXP 37
8466: PUSH
8467: LD_INT 1
8469: ARRAY
8470: PPUSH
8471: LD_EXP 37
8475: PUSH
8476: LD_INT 2
8478: ARRAY
8479: PPUSH
8480: LD_EXP 37
8484: PUSH
8485: LD_INT 3
8487: ARRAY
8488: PPUSH
8489: LD_EXP 37
8493: PUSH
8494: LD_INT 4
8496: ARRAY
8497: PPUSH
8498: CALL_OW 125
// for i = 1 to 4 do
8502: LD_ADDR_VAR 0 1
8506: PUSH
8507: DOUBLE
8508: LD_INT 1
8510: DEC
8511: ST_TO_ADDR
8512: LD_INT 4
8514: PUSH
8515: FOR_TO
8516: IFFALSE 8538
// ru2_veh := Delete ( ru2_veh , 1 ) ;
8518: LD_ADDR_EXP 37
8522: PUSH
8523: LD_EXP 37
8527: PPUSH
8528: LD_INT 1
8530: PPUSH
8531: CALL_OW 3
8535: ST_TO_ADDR
8536: GO 8515
8538: POP
8539: POP
// end ; if ru2_bul > 0 and enemy_detected = false then
8540: LD_EXP 41
8544: PUSH
8545: LD_INT 0
8547: GREATER
8548: PUSH
8549: LD_VAR 0 13
8553: PUSH
8554: LD_INT 0
8556: EQUAL
8557: AND
8558: IFFALSE 8661
// if ru2_eng > 0 then
8560: LD_EXP 38
8564: PUSH
8565: LD_INT 0
8567: GREATER
8568: IFFALSE 8661
// for i = 1 to ru2_eng do
8570: LD_ADDR_VAR 0 1
8574: PUSH
8575: DOUBLE
8576: LD_INT 1
8578: DEC
8579: ST_TO_ADDR
8580: LD_EXP 38
8584: PUSH
8585: FOR_TO
8586: IFFALSE 8659
// if not HasTask ( ru2_eng [ i ] ) then
8588: LD_EXP 38
8592: PUSH
8593: LD_VAR 0 1
8597: ARRAY
8598: PPUSH
8599: CALL_OW 314
8603: NOT
8604: IFFALSE 8657
// begin ComBuild ( ru2_eng [ i ] , ru2_bul [ 1 ] , ru2_bul [ 2 ] , ru2_bul [ 3 ] , ru2_bul [ 4 ] ) ;
8606: LD_EXP 38
8610: PUSH
8611: LD_VAR 0 1
8615: ARRAY
8616: PPUSH
8617: LD_EXP 41
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: LD_EXP 41
8630: PUSH
8631: LD_INT 2
8633: ARRAY
8634: PPUSH
8635: LD_EXP 41
8639: PUSH
8640: LD_INT 3
8642: ARRAY
8643: PPUSH
8644: LD_EXP 41
8648: PUSH
8649: LD_INT 4
8651: ARRAY
8652: PPUSH
8653: CALL_OW 145
// end ;
8657: GO 8585
8659: POP
8660: POP
// for i = 1 to ru2_b do
8661: LD_ADDR_VAR 0 1
8665: PUSH
8666: DOUBLE
8667: LD_INT 1
8669: DEC
8670: ST_TO_ADDR
8671: LD_EXP 42
8675: PUSH
8676: FOR_TO
8677: IFFALSE 8865
// if BuildingStatus ( ru2_b [ i ] ) = bs_need_extension then
8679: LD_EXP 42
8683: PUSH
8684: LD_VAR 0 1
8688: ARRAY
8689: PPUSH
8690: CALL_OW 461
8694: PUSH
8695: LD_INT 8
8697: EQUAL
8698: IFFALSE 8863
// begin b_ext := GetExtPositions ( ru2_b [ i ] ) ;
8700: LD_ADDR_VAR 0 12
8704: PUSH
8705: LD_EXP 42
8709: PUSH
8710: LD_VAR 0 1
8714: ARRAY
8715: PPUSH
8716: CALL_OW 270
8720: ST_TO_ADDR
// if b_ext > 0 and not b_ext_gun in ru2_bul then
8721: LD_VAR 0 12
8725: PUSH
8726: LD_INT 0
8728: GREATER
8729: PUSH
8730: LD_INT 17
8732: PUSH
8733: LD_EXP 41
8737: IN
8738: NOT
8739: AND
8740: IFFALSE 8863
// ru2_bul := ru2_bul ^ [ b_ext_noncombat , b_ext [ 1 ] [ 1 ] , b_ext [ 1 ] [ 2 ] , 3 , b_ext_track , b_ext [ 2 ] [ 1 ] , b_ext [ 2 ] [ 2 ] , 5 , b_ext_gun , b_ext [ 3 ] [ 1 ] , b_ext [ 3 ] [ 2 ] , 2 ] ;
8742: LD_ADDR_EXP 41
8746: PUSH
8747: LD_EXP 41
8751: PUSH
8752: LD_INT 19
8754: PUSH
8755: LD_VAR 0 12
8759: PUSH
8760: LD_INT 1
8762: ARRAY
8763: PUSH
8764: LD_INT 1
8766: ARRAY
8767: PUSH
8768: LD_VAR 0 12
8772: PUSH
8773: LD_INT 1
8775: ARRAY
8776: PUSH
8777: LD_INT 2
8779: ARRAY
8780: PUSH
8781: LD_INT 3
8783: PUSH
8784: LD_INT 16
8786: PUSH
8787: LD_VAR 0 12
8791: PUSH
8792: LD_INT 2
8794: ARRAY
8795: PUSH
8796: LD_INT 1
8798: ARRAY
8799: PUSH
8800: LD_VAR 0 12
8804: PUSH
8805: LD_INT 2
8807: ARRAY
8808: PUSH
8809: LD_INT 2
8811: ARRAY
8812: PUSH
8813: LD_INT 5
8815: PUSH
8816: LD_INT 17
8818: PUSH
8819: LD_VAR 0 12
8823: PUSH
8824: LD_INT 3
8826: ARRAY
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PUSH
8832: LD_VAR 0 12
8836: PUSH
8837: LD_INT 3
8839: ARRAY
8840: PUSH
8841: LD_INT 2
8843: ARRAY
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: LIST
8860: LIST
8861: ADD
8862: ST_TO_ADDR
// end ;
8863: GO 8676
8865: POP
8866: POP
// if b_dmgunit > 0 then
8867: LD_VAR 0 6
8871: PUSH
8872: LD_INT 0
8874: GREATER
8875: IFFALSE 9060
// begin if ru2_eng > 0 then
8877: LD_EXP 38
8881: PUSH
8882: LD_INT 0
8884: GREATER
8885: IFFALSE 8965
// for i = 1 to ru2_eng do
8887: LD_ADDR_VAR 0 1
8891: PUSH
8892: DOUBLE
8893: LD_INT 1
8895: DEC
8896: ST_TO_ADDR
8897: LD_EXP 38
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8963
// begin if IsInUnit ( ru2_eng [ i ] ) then
8905: LD_EXP 38
8909: PUSH
8910: LD_VAR 0 1
8914: ARRAY
8915: PPUSH
8916: CALL_OW 310
8920: IFFALSE 8937
// ComExitBuilding ( ru2_eng [ i ] ) ;
8922: LD_EXP 38
8926: PUSH
8927: LD_VAR 0 1
8931: ARRAY
8932: PPUSH
8933: CALL_OW 122
// ComRepairBuilding ( ru2_eng [ i ] , b_dmgunit [ 1 ] ) ;
8937: LD_EXP 38
8941: PUSH
8942: LD_VAR 0 1
8946: ARRAY
8947: PPUSH
8948: LD_VAR 0 6
8952: PUSH
8953: LD_INT 1
8955: ARRAY
8956: PPUSH
8957: CALL_OW 130
// end ;
8961: GO 8902
8963: POP
8964: POP
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) > 0 then
8965: LD_INT 22
8967: PUSH
8968: LD_INT 3
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 34
8977: PUSH
8978: LD_INT 52
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: PUSH
8994: LD_INT 0
8996: GREATER
8997: IFFALSE 9058
// for p in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) do
8999: LD_ADDR_VAR 0 2
9003: PUSH
9004: LD_INT 22
9006: PUSH
9007: LD_INT 3
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PUSH
9014: LD_INT 34
9016: PUSH
9017: LD_INT 52
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: EMPTY
9025: LIST
9026: LIST
9027: PPUSH
9028: CALL_OW 69
9032: PUSH
9033: FOR_IN
9034: IFFALSE 9056
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 6
9045: PUSH
9046: LD_INT 1
9048: ARRAY
9049: PPUSH
9050: CALL_OW 130
9054: GO 9033
9056: POP
9057: POP
// end else
9058: GO 9188
// if ru2_bul = 0 then
9060: LD_EXP 41
9064: PUSH
9065: LD_INT 0
9067: EQUAL
9068: IFFALSE 9188
// for i = 1 to ru2_eng do
9070: LD_ADDR_VAR 0 1
9074: PUSH
9075: DOUBLE
9076: LD_INT 1
9078: DEC
9079: ST_TO_ADDR
9080: LD_EXP 38
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9186
// if not HasTask ( ru2_eng [ i ] ) then
9088: LD_EXP 38
9092: PUSH
9093: LD_VAR 0 1
9097: ARRAY
9098: PPUSH
9099: CALL_OW 314
9103: NOT
9104: IFFALSE 9184
// ComEnterUnit ( ru2_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru2_eng [ i ] ) ) ;
9106: LD_EXP 38
9110: PUSH
9111: LD_VAR 0 1
9115: ARRAY
9116: PPUSH
9117: LD_INT 22
9119: PUSH
9120: LD_INT 3
9122: PUSH
9123: EMPTY
9124: LIST
9125: LIST
9126: PUSH
9127: LD_INT 2
9129: PUSH
9130: LD_INT 30
9132: PUSH
9133: LD_INT 0
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: PUSH
9140: LD_INT 30
9142: PUSH
9143: LD_INT 1
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: PPUSH
9159: CALL_OW 69
9163: PPUSH
9164: LD_EXP 38
9168: PUSH
9169: LD_VAR 0 1
9173: ARRAY
9174: PPUSH
9175: CALL_OW 74
9179: PPUSH
9180: CALL_OW 120
9184: GO 9085
9186: POP
9187: POP
// if b_labb > 0 then
9188: LD_VAR 0 11
9192: PUSH
9193: LD_INT 0
9195: GREATER
9196: IFFALSE 9546
// begin if h_dmgunit > 0 then
9198: LD_VAR 0 5
9202: PUSH
9203: LD_INT 0
9205: GREATER
9206: IFFALSE 9415
// begin for p = 1 to h_dmgunit do
9208: LD_ADDR_VAR 0 2
9212: PUSH
9213: DOUBLE
9214: LD_INT 1
9216: DEC
9217: ST_TO_ADDR
9218: LD_VAR 0 5
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9275
// if GetDistUnits ( h_dmgunit [ p ] , b_labb ) > 6 then
9226: LD_VAR 0 5
9230: PUSH
9231: LD_VAR 0 2
9235: ARRAY
9236: PPUSH
9237: LD_VAR 0 11
9241: PPUSH
9242: CALL_OW 296
9246: PUSH
9247: LD_INT 6
9249: GREATER
9250: IFFALSE 9273
// ComMoveXY ( h_dmgunit [ p ] , 95 , 72 ) ;
9252: LD_VAR 0 5
9256: PUSH
9257: LD_VAR 0 2
9261: ARRAY
9262: PPUSH
9263: LD_INT 95
9265: PPUSH
9266: LD_INT 72
9268: PPUSH
9269: CALL_OW 111
9273: GO 9223
9275: POP
9276: POP
// if ru2_sci > 0 then
9277: LD_EXP 40
9281: PUSH
9282: LD_INT 0
9284: GREATER
9285: IFFALSE 9415
// for i = 1 to ru2_sci do
9287: LD_ADDR_VAR 0 1
9291: PUSH
9292: DOUBLE
9293: LD_INT 1
9295: DEC
9296: ST_TO_ADDR
9297: LD_EXP 40
9301: PUSH
9302: FOR_TO
9303: IFFALSE 9413
// if IsInUnit ( ru2_sci [ i ] ) then
9305: LD_EXP 40
9309: PUSH
9310: LD_VAR 0 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 310
9320: IFFALSE 9339
// ComExitBuilding ( ru2_sci [ i ] ) else
9322: LD_EXP 40
9326: PUSH
9327: LD_VAR 0 1
9331: ARRAY
9332: PPUSH
9333: CALL_OW 122
9337: GO 9411
// if not HasTask ( ru2_sci [ i ] ) then
9339: LD_EXP 40
9343: PUSH
9344: LD_VAR 0 1
9348: ARRAY
9349: PPUSH
9350: CALL_OW 314
9354: NOT
9355: IFFALSE 9411
// if GetDistUnits ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
9357: LD_EXP 40
9361: PUSH
9362: LD_VAR 0 1
9366: ARRAY
9367: PPUSH
9368: LD_VAR 0 5
9372: PUSH
9373: LD_INT 1
9375: ARRAY
9376: PPUSH
9377: CALL_OW 296
9381: PUSH
9382: LD_INT 15
9384: LESSEQUAL
9385: IFFALSE 9411
// ComHeal ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) ;
9387: LD_EXP 40
9391: PUSH
9392: LD_VAR 0 1
9396: ARRAY
9397: PPUSH
9398: LD_VAR 0 5
9402: PUSH
9403: LD_INT 1
9405: ARRAY
9406: PPUSH
9407: CALL_OW 128
9411: GO 9302
9413: POP
9414: POP
// end ; if h_dmgunit = 0 then
9415: LD_VAR 0 5
9419: PUSH
9420: LD_INT 0
9422: EQUAL
9423: IFFALSE 9546
// begin for i = 1 to ru2_sci do
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: DOUBLE
9431: LD_INT 1
9433: DEC
9434: ST_TO_ADDR
9435: LD_EXP 40
9439: PUSH
9440: FOR_TO
9441: IFFALSE 9483
// if not IsInUnit ( ru2_sci [ i ] ) then
9443: LD_EXP 40
9447: PUSH
9448: LD_VAR 0 1
9452: ARRAY
9453: PPUSH
9454: CALL_OW 310
9458: NOT
9459: IFFALSE 9481
// ComEnterUnit ( ru2_sci [ i ] , b_labb ) ;
9461: LD_EXP 40
9465: PUSH
9466: LD_VAR 0 1
9470: ARRAY
9471: PPUSH
9472: LD_VAR 0 11
9476: PPUSH
9477: CALL_OW 120
9481: GO 9440
9483: POP
9484: POP
// if ru2_tech > 0 then
9485: LD_EXP 36
9489: PUSH
9490: LD_INT 0
9492: GREATER
9493: IFFALSE 9546
// if BuildingStatus ( b_labb ) = bs_idle then
9495: LD_VAR 0 11
9499: PPUSH
9500: CALL_OW 461
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9546
// begin ComResearch ( b_labb , ru2_tech [ 1 ] ) ;
9510: LD_VAR 0 11
9514: PPUSH
9515: LD_EXP 36
9519: PUSH
9520: LD_INT 1
9522: ARRAY
9523: PPUSH
9524: CALL_OW 124
// ru2_tech := Delete ( ru2_tech , 1 ) ;
9528: LD_ADDR_EXP 36
9532: PUSH
9533: LD_EXP 36
9537: PPUSH
9538: LD_INT 1
9540: PPUSH
9541: CALL_OW 3
9545: ST_TO_ADDR
// end ; end ; end ; end ;
9546: PPOPN 13
9548: END
// every 0 0$01 trigger russian_produce do
9549: LD_EXP 20
9553: IFFALSE 10002
9555: GO 9557
9557: DISABLE
// begin case global_diff of 1 :
9558: LD_EXP 3
9562: PUSH
9563: LD_INT 1
9565: DOUBLE
9566: EQUAL
9567: IFTRUE 9571
9569: GO 9635
9571: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9572: LD_ADDR_EXP 27
9576: PUSH
9577: LD_EXP 27
9581: PUSH
9582: LD_INT 21
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: LD_INT 1
9590: PUSH
9591: LD_INT 42
9593: PUSH
9594: LD_INT 21
9596: PUSH
9597: LD_INT 1
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: LD_INT 42
9605: PUSH
9606: LD_INT 21
9608: PUSH
9609: LD_INT 1
9611: PUSH
9612: LD_INT 1
9614: PUSH
9615: LD_INT 43
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: LIST
9630: LIST
9631: ADD
9632: ST_TO_ADDR
9633: GO 9780
9635: LD_INT 2
9637: DOUBLE
9638: EQUAL
9639: IFTRUE 9643
9641: GO 9707
9643: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9644: LD_ADDR_EXP 27
9648: PUSH
9649: LD_EXP 27
9653: PUSH
9654: LD_INT 21
9656: PUSH
9657: LD_INT 1
9659: PUSH
9660: LD_INT 1
9662: PUSH
9663: LD_INT 44
9665: PUSH
9666: LD_INT 22
9668: PUSH
9669: LD_INT 1
9671: PUSH
9672: LD_INT 1
9674: PUSH
9675: LD_INT 42
9677: PUSH
9678: LD_INT 22
9680: PUSH
9681: LD_INT 1
9683: PUSH
9684: LD_INT 1
9686: PUSH
9687: LD_INT 43
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: LIST
9701: LIST
9702: LIST
9703: ADD
9704: ST_TO_ADDR
9705: GO 9780
9707: LD_INT 3
9709: DOUBLE
9710: EQUAL
9711: IFTRUE 9715
9713: GO 9779
9715: POP
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_rocket_launcher ] ; end ;
9716: LD_ADDR_EXP 27
9720: PUSH
9721: LD_EXP 27
9725: PUSH
9726: LD_INT 23
9728: PUSH
9729: LD_INT 1
9731: PUSH
9732: LD_INT 1
9734: PUSH
9735: LD_INT 43
9737: PUSH
9738: LD_INT 22
9740: PUSH
9741: LD_INT 1
9743: PUSH
9744: LD_INT 1
9746: PUSH
9747: LD_INT 44
9749: PUSH
9750: LD_INT 22
9752: PUSH
9753: LD_INT 1
9755: PUSH
9756: LD_INT 1
9758: PUSH
9759: LD_INT 45
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: LIST
9766: LIST
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: LIST
9773: LIST
9774: LIST
9775: ADD
9776: ST_TO_ADDR
9777: GO 9780
9779: POP
// case global_diff of 1 :
9780: LD_EXP 3
9784: PUSH
9785: LD_INT 1
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9857
9793: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9794: LD_ADDR_EXP 37
9798: PUSH
9799: LD_EXP 37
9803: PUSH
9804: LD_INT 21
9806: PUSH
9807: LD_INT 1
9809: PUSH
9810: LD_INT 1
9812: PUSH
9813: LD_INT 42
9815: PUSH
9816: LD_INT 21
9818: PUSH
9819: LD_INT 1
9821: PUSH
9822: LD_INT 1
9824: PUSH
9825: LD_INT 42
9827: PUSH
9828: LD_INT 21
9830: PUSH
9831: LD_INT 1
9833: PUSH
9834: LD_INT 1
9836: PUSH
9837: LD_INT 43
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: ADD
9854: ST_TO_ADDR
9855: GO 10002
9857: LD_INT 2
9859: DOUBLE
9860: EQUAL
9861: IFTRUE 9865
9863: GO 9929
9865: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9866: LD_ADDR_EXP 37
9870: PUSH
9871: LD_EXP 37
9875: PUSH
9876: LD_INT 21
9878: PUSH
9879: LD_INT 1
9881: PUSH
9882: LD_INT 1
9884: PUSH
9885: LD_INT 44
9887: PUSH
9888: LD_INT 22
9890: PUSH
9891: LD_INT 1
9893: PUSH
9894: LD_INT 1
9896: PUSH
9897: LD_INT 44
9899: PUSH
9900: LD_INT 22
9902: PUSH
9903: LD_INT 1
9905: PUSH
9906: LD_INT 1
9908: PUSH
9909: LD_INT 43
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: ADD
9926: ST_TO_ADDR
9927: GO 10002
9929: LD_INT 3
9931: DOUBLE
9932: EQUAL
9933: IFTRUE 9937
9935: GO 10001
9937: POP
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
9938: LD_ADDR_EXP 37
9942: PUSH
9943: LD_EXP 37
9947: PUSH
9948: LD_INT 23
9950: PUSH
9951: LD_INT 1
9953: PUSH
9954: LD_INT 1
9956: PUSH
9957: LD_INT 42
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_INT 1
9965: PUSH
9966: LD_INT 1
9968: PUSH
9969: LD_INT 44
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 1
9977: PUSH
9978: LD_INT 1
9980: PUSH
9981: LD_INT 44
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: ADD
9998: ST_TO_ADDR
9999: GO 10002
10001: POP
// end ;
10002: END
// every 12 12$00 trigger timer >= [ 26 26$00 , 21 21$00 , 16 16$00 ] [ global_diff ] and FilterAllUnits ( [ f_side , 3 ] ) > 0 do var veh , i , p , area ;
10003: LD_EXP 2
10007: PUSH
10008: LD_INT 54600
10010: PUSH
10011: LD_INT 44100
10013: PUSH
10014: LD_INT 33600
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: PUSH
10022: LD_EXP 3
10026: ARRAY
10027: GREATEREQUAL
10028: PUSH
10029: LD_INT 22
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: PPUSH
10039: CALL_OW 69
10043: PUSH
10044: LD_INT 0
10046: GREATER
10047: AND
10048: IFFALSE 10264
10050: GO 10052
10052: DISABLE
10053: LD_INT 0
10055: PPUSH
10056: PPUSH
10057: PPUSH
10058: PPUSH
// begin enable ;
10059: ENABLE
// uc_side := [ 3 , 6 ] [ Rand ( 1 , 2 ) ] ;
10060: LD_ADDR_OWVAR 20
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 6
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: PUSH
10075: LD_INT 1
10077: PPUSH
10078: LD_INT 2
10080: PPUSH
10081: CALL_OW 12
10085: ARRAY
10086: ST_TO_ADDR
// uc_nation := 3 ;
10087: LD_ADDR_OWVAR 21
10091: PUSH
10092: LD_INT 3
10094: ST_TO_ADDR
// area := [ ru_west , south_spawn ] ;
10095: LD_ADDR_VAR 0 4
10099: PUSH
10100: LD_INT 18
10102: PUSH
10103: LD_INT 7
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
10110: LD_ADDR_VAR 0 3
10114: PUSH
10115: LD_INT 1
10117: PPUSH
10118: LD_INT 2
10120: PPUSH
10121: CALL_OW 12
10125: ST_TO_ADDR
// for i = 1 to Rand ( 1 , 2 ) do
10126: LD_ADDR_VAR 0 2
10130: PUSH
10131: DOUBLE
10132: LD_INT 1
10134: DEC
10135: ST_TO_ADDR
10136: LD_INT 1
10138: PPUSH
10139: LD_INT 2
10141: PPUSH
10142: CALL_OW 12
10146: PUSH
10147: FOR_TO
10148: IFFALSE 10262
// begin vc_chassis := ru_medium_tracked ;
10150: LD_ADDR_OWVAR 37
10154: PUSH
10155: LD_INT 22
10157: ST_TO_ADDR
// vc_engine := engine_combustion ;
10158: LD_ADDR_OWVAR 39
10162: PUSH
10163: LD_INT 1
10165: ST_TO_ADDR
// vc_control := control_manual ;
10166: LD_ADDR_OWVAR 38
10170: PUSH
10171: LD_INT 1
10173: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
10174: LD_ADDR_OWVAR 40
10178: PUSH
10179: LD_INT 43
10181: PUSH
10182: LD_INT 44
10184: PUSH
10185: LD_INT 45
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: LIST
10192: PUSH
10193: LD_INT 1
10195: PPUSH
10196: LD_INT 3
10198: PPUSH
10199: CALL_OW 12
10203: ARRAY
10204: ST_TO_ADDR
// veh := CreateVehicle ;
10205: LD_ADDR_VAR 0 1
10209: PUSH
10210: CALL_OW 45
10214: ST_TO_ADDR
// PlaceUnitArea ( veh , area [ p ] , false ) ;
10215: LD_VAR 0 1
10219: PPUSH
10220: LD_VAR 0 4
10224: PUSH
10225: LD_VAR 0 3
10229: ARRAY
10230: PPUSH
10231: LD_INT 0
10233: PPUSH
10234: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_def ) , veh ) ;
10238: LD_INT 3
10240: PPUSH
10241: LD_EXP 5
10245: PPUSH
10246: CALL 425 0 2
10250: PPUSH
10251: LD_VAR 0 1
10255: PPUSH
10256: CALL_OW 52
// end ;
10260: GO 10147
10262: POP
10263: POP
// end ;
10264: PPOPN 4
10266: END
// every 4 4$35 trigger FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) >= 6 do var filter , enemy , i , _list ;
10267: LD_INT 2
10269: PUSH
10270: LD_INT 22
10272: PUSH
10273: LD_INT 3
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 22
10282: PUSH
10283: LD_INT 6
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: LIST
10294: PUSH
10295: LD_INT 21
10297: PUSH
10298: LD_INT 2
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: PUSH
10305: LD_INT 3
10307: PUSH
10308: LD_INT 2
10310: PUSH
10311: LD_INT 34
10313: PUSH
10314: LD_INT 52
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: LD_INT 34
10323: PUSH
10324: LD_INT 51
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PUSH
10331: LD_INT 34
10333: PUSH
10334: LD_INT 53
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: LIST
10355: PPUSH
10356: CALL_OW 69
10360: PUSH
10361: LD_INT 6
10363: GREATEREQUAL
10364: IFFALSE 10604
10366: GO 10368
10368: DISABLE
10369: LD_INT 0
10371: PPUSH
10372: PPUSH
10373: PPUSH
10374: PPUSH
// begin enable ;
10375: ENABLE
// _list := [ [ b_oil_mine , b_solar_power , b_oil_power ] , [ us_cargo_bay ] , [ ] ] ;
10376: LD_ADDR_VAR 0 4
10380: PUSH
10381: LD_INT 29
10383: PUSH
10384: LD_INT 27
10386: PUSH
10387: LD_INT 26
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 12
10397: PUSH
10398: EMPTY
10399: LIST
10400: PUSH
10401: EMPTY
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: ST_TO_ADDR
// filter := ru_list_attackers ;
10408: LD_ADDR_VAR 0 1
10412: PUSH
10413: LD_EXP 43
10417: ST_TO_ADDR
// while ( filter ) do
10418: LD_VAR 0 1
10422: IFFALSE 10604
// begin Wait ( 0 0$01 ) ;
10424: LD_INT 35
10426: PPUSH
10427: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10431: LD_INT 22
10433: PUSH
10434: LD_INT 2
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: PPUSH
10441: CALL_OW 69
10445: PUSH
10446: LD_INT 0
10448: EQUAL
10449: IFFALSE 10491
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10451: LD_ADDR_VAR 0 2
10455: PUSH
10456: LD_INT 2
10458: PUSH
10459: LD_INT 22
10461: PUSH
10462: LD_INT 1
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: LD_INT 22
10471: PUSH
10472: LD_INT 4
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: EMPTY
10480: LIST
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: ST_TO_ADDR
10489: GO 10511
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10491: LD_ADDR_VAR 0 2
10495: PUSH
10496: LD_INT 22
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: PPUSH
10506: CALL_OW 69
10510: ST_TO_ADDR
// for i = filter downto 1 do
10511: LD_ADDR_VAR 0 3
10515: PUSH
10516: DOUBLE
10517: LD_VAR 0 1
10521: INC
10522: ST_TO_ADDR
10523: LD_INT 1
10525: PUSH
10526: FOR_DOWNTO
10527: IFFALSE 10591
// if not IsPlaced ( filter [ i ] ) then
10529: LD_VAR 0 1
10533: PUSH
10534: LD_VAR 0 3
10538: ARRAY
10539: PPUSH
10540: CALL_OW 305
10544: NOT
10545: IFFALSE 10569
// filter := Delete ( filter , i ) else
10547: LD_ADDR_VAR 0 1
10551: PUSH
10552: LD_VAR 0 1
10556: PPUSH
10557: LD_VAR 0 3
10561: PPUSH
10562: CALL_OW 3
10566: ST_TO_ADDR
10567: GO 10589
// ComAttack ( filter [ i ] , _list ) ;
10569: LD_VAR 0 1
10573: PUSH
10574: LD_VAR 0 3
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 4
10584: PPUSH
10585: CALL 992 0 2
10589: GO 10526
10591: POP
10592: POP
// if not filter then
10593: LD_VAR 0 1
10597: NOT
10598: IFFALSE 10602
// break ;
10600: GO 10604
// end ;
10602: GO 10418
// end ;
10604: PPOPN 4
10606: END
// export ru_spec_group ; every 0 0$10 trigger FilterUnitsInArea ( buffor , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 do var i , un , veh ;
10607: LD_INT 22
10609: PPUSH
10610: LD_INT 22
10612: PUSH
10613: LD_INT 1
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: PUSH
10620: LD_INT 21
10622: PUSH
10623: LD_INT 3
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PPUSH
10634: CALL_OW 70
10638: PUSH
10639: LD_INT 0
10641: GREATER
10642: IFFALSE 10787
10644: GO 10646
10646: DISABLE
10647: LD_INT 0
10649: PPUSH
10650: PPUSH
10651: PPUSH
// begin uc_side := 6 ;
10652: LD_ADDR_OWVAR 20
10656: PUSH
10657: LD_INT 6
10659: ST_TO_ADDR
// uc_nation := 3 ;
10660: LD_ADDR_OWVAR 21
10664: PUSH
10665: LD_INT 3
10667: ST_TO_ADDR
// for i = 1 to Difficulty + 1 do
10668: LD_ADDR_VAR 0 1
10672: PUSH
10673: DOUBLE
10674: LD_INT 1
10676: DEC
10677: ST_TO_ADDR
10678: LD_OWVAR 67
10682: PUSH
10683: LD_INT 1
10685: PLUS
10686: PUSH
10687: FOR_TO
10688: IFFALSE 10782
// begin vc_chassis := ru_medium_tracked ;
10690: LD_ADDR_OWVAR 37
10694: PUSH
10695: LD_INT 22
10697: ST_TO_ADDR
// vc_engine := engine_combustion ;
10698: LD_ADDR_OWVAR 39
10702: PUSH
10703: LD_INT 1
10705: ST_TO_ADDR
// vc_control := control_manual ;
10706: LD_ADDR_OWVAR 38
10710: PUSH
10711: LD_INT 1
10713: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10714: LD_ADDR_OWVAR 40
10718: PUSH
10719: LD_INT 45
10721: ST_TO_ADDR
// veh := CreateVehicle ;
10722: LD_ADDR_VAR 0 3
10726: PUSH
10727: CALL_OW 45
10731: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
10732: LD_ADDR_VAR 0 2
10736: PUSH
10737: LD_INT 3
10739: PPUSH
10740: LD_EXP 5
10744: PPUSH
10745: CALL 425 0 2
10749: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10750: LD_VAR 0 2
10754: PPUSH
10755: LD_VAR 0 3
10759: PPUSH
10760: CALL_OW 52
// ru_spec_group := ru_spec_group ^ veh ;
10764: LD_ADDR_EXP 44
10768: PUSH
10769: LD_EXP 44
10773: PUSH
10774: LD_VAR 0 3
10778: ADD
10779: ST_TO_ADDR
// end ;
10780: GO 10687
10782: POP
10783: POP
// enable ( 99 ) ;
10784: LD_INT 99
10786: ENABLE_MARKED
// end ;
10787: PPOPN 3
10789: END
// every 0 0$01 trigger ru_spec_group marked 99 do var i , enemy , filter ;
10790: LD_EXP 44
10794: IFFALSE 10963
10796: GO 10798
10798: DISABLE
10799: LD_INT 0
10801: PPUSH
10802: PPUSH
10803: PPUSH
// begin enable ;
10804: ENABLE
// filter := ru_spec_group ;
10805: LD_ADDR_VAR 0 3
10809: PUSH
10810: LD_EXP 44
10814: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10815: LD_INT 22
10817: PUSH
10818: LD_INT 2
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PPUSH
10825: CALL_OW 69
10829: PUSH
10830: LD_INT 0
10832: EQUAL
10833: IFFALSE 10875
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10835: LD_ADDR_VAR 0 2
10839: PUSH
10840: LD_INT 2
10842: PUSH
10843: LD_INT 22
10845: PUSH
10846: LD_INT 1
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 22
10855: PUSH
10856: LD_INT 4
10858: PUSH
10859: EMPTY
10860: LIST
10861: LIST
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: LIST
10867: PPUSH
10868: CALL_OW 69
10872: ST_TO_ADDR
10873: GO 10895
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10875: LD_ADDR_VAR 0 2
10879: PUSH
10880: LD_INT 22
10882: PUSH
10883: LD_INT 2
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PPUSH
10890: CALL_OW 69
10894: ST_TO_ADDR
// if filter > 0 then
10895: LD_VAR 0 3
10899: PUSH
10900: LD_INT 0
10902: GREATER
10903: IFFALSE 10963
// for i = 1 to filter do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: DOUBLE
10911: LD_INT 1
10913: DEC
10914: ST_TO_ADDR
10915: LD_VAR 0 3
10919: PUSH
10920: FOR_TO
10921: IFFALSE 10961
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
10923: LD_VAR 0 3
10927: PUSH
10928: LD_VAR 0 1
10932: ARRAY
10933: PPUSH
10934: LD_VAR 0 2
10938: PPUSH
10939: LD_VAR 0 3
10943: PUSH
10944: LD_VAR 0 1
10948: ARRAY
10949: PPUSH
10950: CALL_OW 74
10954: PPUSH
10955: CALL_OW 115
10959: GO 10920
10961: POP
10962: POP
// end ; end_of_file
10963: PPOPN 3
10965: END
// export function ArabianAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
10966: LD_INT 0
10968: PPUSH
10969: PPUSH
10970: PPUSH
10971: PPUSH
10972: PPUSH
10973: PPUSH
10974: PPUSH
// uc_side := side ;
10975: LD_ADDR_OWVAR 20
10979: PUSH
10980: LD_VAR 0 1
10984: ST_TO_ADDR
// uc_nation := nation_arabian ;
10985: LD_ADDR_OWVAR 21
10989: PUSH
10990: LD_INT 2
10992: ST_TO_ADDR
// chassis := [ ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
10993: LD_ADDR_VAR 0 10
10997: PUSH
10998: LD_INT 12
11000: PUSH
11001: LD_INT 13
11003: PUSH
11004: LD_INT 14
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: ST_TO_ADDR
// weapon := [ ar_multimissile_ballista , ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher ] ;
11012: LD_ADDR_VAR 0 11
11016: PUSH
11017: LD_INT 22
11019: PUSH
11020: LD_INT 24
11022: PUSH
11023: LD_INT 25
11025: PUSH
11026: LD_INT 27
11028: PUSH
11029: LD_INT 28
11031: PUSH
11032: EMPTY
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: ST_TO_ADDR
// case typ of 1 :
11039: LD_VAR 0 3
11043: PUSH
11044: LD_INT 1
11046: DOUBLE
11047: EQUAL
11048: IFTRUE 11052
11050: GO 11277
11052: POP
// begin for i = 1 to num do
11053: LD_ADDR_VAR 0 6
11057: PUSH
11058: DOUBLE
11059: LD_INT 1
11061: DEC
11062: ST_TO_ADDR
11063: LD_VAR 0 2
11067: PUSH
11068: FOR_TO
11069: IFFALSE 11228
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
11071: LD_ADDR_OWVAR 37
11075: PUSH
11076: LD_VAR 0 10
11080: PUSH
11081: LD_INT 1
11083: PPUSH
11084: LD_INT 2
11086: PPUSH
11087: CALL_OW 12
11091: ARRAY
11092: ST_TO_ADDR
// vc_engine := engine_combustion ;
11093: LD_ADDR_OWVAR 39
11097: PUSH
11098: LD_INT 1
11100: ST_TO_ADDR
// vc_control := control_manual ;
11101: LD_ADDR_OWVAR 38
11105: PUSH
11106: LD_INT 1
11108: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 2 ) ] ;
11109: LD_ADDR_OWVAR 40
11113: PUSH
11114: LD_VAR 0 11
11118: PUSH
11119: LD_INT 1
11121: PPUSH
11122: LD_INT 2
11124: PPUSH
11125: CALL_OW 12
11129: ARRAY
11130: ST_TO_ADDR
// veh := CreateVehicle ;
11131: LD_ADDR_VAR 0 9
11135: PUSH
11136: CALL_OW 45
11140: ST_TO_ADDR
// if area = ar_area1 then
11141: LD_VAR 0 4
11145: PUSH
11146: LD_INT 6
11148: EQUAL
11149: IFFALSE 11165
// SetDir ( veh , 3 ) else
11151: LD_VAR 0 9
11155: PPUSH
11156: LD_INT 3
11158: PPUSH
11159: CALL_OW 233
11163: GO 11177
// SetDir ( veh , 0 ) ;
11165: LD_VAR 0 9
11169: PPUSH
11170: LD_INT 0
11172: PPUSH
11173: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11177: LD_VAR 0 9
11181: PPUSH
11182: LD_VAR 0 4
11186: PPUSH
11187: LD_INT 0
11189: PPUSH
11190: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11194: LD_ADDR_VAR 0 7
11198: PUSH
11199: LD_INT 1
11201: PPUSH
11202: LD_EXP 8
11206: PPUSH
11207: CALL 425 0 2
11211: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11212: LD_VAR 0 7
11216: PPUSH
11217: LD_VAR 0 9
11221: PPUSH
11222: CALL_OW 52
// end ;
11226: GO 11068
11228: POP
11229: POP
// for i = 1 to 3 do
11230: LD_ADDR_VAR 0 6
11234: PUSH
11235: DOUBLE
11236: LD_INT 1
11238: DEC
11239: ST_TO_ADDR
11240: LD_INT 3
11242: PUSH
11243: FOR_TO
11244: IFFALSE 11273
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , ar_def ) , area , false ) ;
11246: LD_INT 8
11248: PPUSH
11249: LD_EXP 8
11253: PPUSH
11254: CALL 425 0 2
11258: PPUSH
11259: LD_VAR 0 4
11263: PPUSH
11264: LD_INT 0
11266: PPUSH
11267: CALL_OW 49
11271: GO 11243
11273: POP
11274: POP
// end ; 2 :
11275: GO 11544
11277: LD_INT 2
11279: DOUBLE
11280: EQUAL
11281: IFTRUE 11285
11283: GO 11543
11285: POP
// begin for i = 1 to num do
11286: LD_ADDR_VAR 0 6
11290: PUSH
11291: DOUBLE
11292: LD_INT 1
11294: DEC
11295: ST_TO_ADDR
11296: LD_VAR 0 2
11300: PUSH
11301: FOR_TO
11302: IFFALSE 11461
// begin vc_chassis := chassis [ Rand ( 2 , 3 ) ] ;
11304: LD_ADDR_OWVAR 37
11308: PUSH
11309: LD_VAR 0 10
11313: PUSH
11314: LD_INT 2
11316: PPUSH
11317: LD_INT 3
11319: PPUSH
11320: CALL_OW 12
11324: ARRAY
11325: ST_TO_ADDR
// vc_engine := engine_combustion ;
11326: LD_ADDR_OWVAR 39
11330: PUSH
11331: LD_INT 1
11333: ST_TO_ADDR
// vc_control := control_manual ;
11334: LD_ADDR_OWVAR 38
11338: PUSH
11339: LD_INT 1
11341: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
11342: LD_ADDR_OWVAR 40
11346: PUSH
11347: LD_VAR 0 11
11351: PUSH
11352: LD_INT 3
11354: PPUSH
11355: LD_INT 5
11357: PPUSH
11358: CALL_OW 12
11362: ARRAY
11363: ST_TO_ADDR
// veh := CreateVehicle ;
11364: LD_ADDR_VAR 0 9
11368: PUSH
11369: CALL_OW 45
11373: ST_TO_ADDR
// if area = ar_area1 then
11374: LD_VAR 0 4
11378: PUSH
11379: LD_INT 6
11381: EQUAL
11382: IFFALSE 11398
// SetDir ( veh , 3 ) else
11384: LD_VAR 0 9
11388: PPUSH
11389: LD_INT 3
11391: PPUSH
11392: CALL_OW 233
11396: GO 11410
// SetDir ( veh , 0 ) ;
11398: LD_VAR 0 9
11402: PPUSH
11403: LD_INT 0
11405: PPUSH
11406: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11410: LD_VAR 0 9
11414: PPUSH
11415: LD_VAR 0 4
11419: PPUSH
11420: LD_INT 0
11422: PPUSH
11423: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11427: LD_ADDR_VAR 0 7
11431: PUSH
11432: LD_INT 1
11434: PPUSH
11435: LD_EXP 8
11439: PPUSH
11440: CALL 425 0 2
11444: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11445: LD_VAR 0 7
11449: PPUSH
11450: LD_VAR 0 9
11454: PPUSH
11455: CALL_OW 52
// end ;
11459: GO 11301
11461: POP
11462: POP
// for i = 1 to 2 do
11463: LD_ADDR_VAR 0 6
11467: PUSH
11468: DOUBLE
11469: LD_INT 1
11471: DEC
11472: ST_TO_ADDR
11473: LD_INT 2
11475: PUSH
11476: FOR_TO
11477: IFFALSE 11539
// begin uc_nation := 0 ;
11479: LD_ADDR_OWVAR 21
11483: PUSH
11484: LD_INT 0
11486: ST_TO_ADDR
// hc_class := 17 ;
11487: LD_ADDR_OWVAR 28
11491: PUSH
11492: LD_INT 17
11494: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
11495: LD_ADDR_OWVAR 29
11499: PUSH
11500: LD_INT 11
11502: PUSH
11503: LD_INT 13
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: ST_TO_ADDR
// un := CreateHuman ;
11510: LD_ADDR_VAR 0 7
11514: PUSH
11515: CALL_OW 44
11519: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
11520: LD_VAR 0 7
11524: PPUSH
11525: LD_VAR 0 4
11529: PPUSH
11530: LD_INT 0
11532: PPUSH
11533: CALL_OW 49
// end ;
11537: GO 11476
11539: POP
11540: POP
// end ; end ;
11541: GO 11544
11543: POP
// end ;
11544: LD_VAR 0 5
11548: RET
// export function FHeike ; begin
11549: LD_INT 0
11551: PPUSH
// uc_side := 2 ;
11552: LD_ADDR_OWVAR 20
11556: PUSH
11557: LD_INT 2
11559: ST_TO_ADDR
// uc_nation := 2 ;
11560: LD_ADDR_OWVAR 21
11564: PUSH
11565: LD_INT 2
11567: ST_TO_ADDR
// hc_gallery := sandar ;
11568: LD_ADDR_OWVAR 33
11572: PUSH
11573: LD_STRING sandar
11575: ST_TO_ADDR
// hc_face_number := 14 ;
11576: LD_ADDR_OWVAR 34
11580: PUSH
11581: LD_INT 14
11583: ST_TO_ADDR
// hc_name := Heike Steyer ;
11584: LD_ADDR_OWVAR 26
11588: PUSH
11589: LD_STRING Heike Steyer
11591: ST_TO_ADDR
// hc_sex := sex_female ;
11592: LD_ADDR_OWVAR 27
11596: PUSH
11597: LD_INT 2
11599: ST_TO_ADDR
// hc_class := 1 ;
11600: LD_ADDR_OWVAR 28
11604: PUSH
11605: LD_INT 1
11607: ST_TO_ADDR
// heike := CreateHuman ;
11608: LD_ADDR_EXP 16
11612: PUSH
11613: CALL_OW 44
11617: ST_TO_ADDR
// end ;
11618: LD_VAR 0 1
11622: RET
// every 0 0$01 do var filter , enemy , i ;
11623: GO 11625
11625: DISABLE
11626: LD_INT 0
11628: PPUSH
11629: PPUSH
11630: PPUSH
// begin enable ;
11631: ENABLE
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
11632: LD_ADDR_VAR 0 1
11636: PUSH
11637: LD_INT 22
11639: PUSH
11640: LD_INT 2
11642: PUSH
11643: EMPTY
11644: LIST
11645: LIST
11646: PPUSH
11647: CALL_OW 69
11651: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
11652: LD_ADDR_VAR 0 2
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: LD_INT 22
11662: PUSH
11663: LD_INT 1
11665: PUSH
11666: EMPTY
11667: LIST
11668: LIST
11669: PUSH
11670: LD_INT 22
11672: PUSH
11673: LD_INT 3
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: LD_INT 22
11682: PUSH
11683: LD_INT 6
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// if filter > 0 then
11701: LD_VAR 0 1
11705: PUSH
11706: LD_INT 0
11708: GREATER
11709: IFFALSE 11769
// for i = 1 to filter do
11711: LD_ADDR_VAR 0 3
11715: PUSH
11716: DOUBLE
11717: LD_INT 1
11719: DEC
11720: ST_TO_ADDR
11721: LD_VAR 0 1
11725: PUSH
11726: FOR_TO
11727: IFFALSE 11767
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
11729: LD_VAR 0 1
11733: PUSH
11734: LD_VAR 0 3
11738: ARRAY
11739: PPUSH
11740: LD_VAR 0 2
11744: PPUSH
11745: LD_VAR 0 1
11749: PUSH
11750: LD_VAR 0 3
11754: ARRAY
11755: PPUSH
11756: CALL_OW 74
11760: PPUSH
11761: CALL_OW 115
11765: GO 11726
11767: POP
11768: POP
// end ; end_of_file
11769: PPOPN 3
11771: END
// on UnitDestroyed ( un ) do begin if un = sikorski then
11772: LD_VAR 0 1
11776: PUSH
11777: LD_EXP 14
11781: EQUAL
11782: IFFALSE 11791
// YouLost ( sik ) ;
11784: LD_STRING sik
11786: PPUSH
11787: CALL_OW 104
// if un = omikron then
11791: LD_VAR 0 1
11795: PUSH
11796: LD_INT 64
11798: EQUAL
11799: IFFALSE 11808
// YouLost ( omi ) ;
11801: LD_STRING omi
11803: PPUSH
11804: CALL_OW 104
// if un in ru_list_attackers then
11808: LD_VAR 0 1
11812: PUSH
11813: LD_EXP 43
11817: IN
11818: IFFALSE 11836
// ru_list_attackers := ru_list_attackers diff un ;
11820: LD_ADDR_EXP 43
11824: PUSH
11825: LD_EXP 43
11829: PUSH
11830: LD_VAR 0 1
11834: DIFF
11835: ST_TO_ADDR
// if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
11836: LD_VAR 0 1
11840: PPUSH
11841: CALL_OW 255
11845: PUSH
11846: LD_INT 6
11848: EQUAL
11849: PUSH
11850: LD_VAR 0 1
11854: PUSH
11855: LD_INT 21
11857: PUSH
11858: LD_INT 3
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PPUSH
11865: CALL_OW 69
11869: IN
11870: AND
11871: IFFALSE 12090
// begin if GetBType ( un ) = b_factory then
11873: LD_VAR 0 1
11877: PPUSH
11878: CALL_OW 266
11882: PUSH
11883: LD_INT 3
11885: EQUAL
11886: IFFALSE 11902
// ru_bul := ru_bul ^ b_workshop ;
11888: LD_ADDR_EXP 31
11892: PUSH
11893: LD_EXP 31
11897: PUSH
11898: LD_INT 2
11900: ADD
11901: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
11902: LD_VAR 0 1
11906: PPUSH
11907: CALL_OW 266
11911: PUSH
11912: LD_INT 8
11914: EQUAL
11915: PUSH
11916: LD_VAR 0 1
11920: PPUSH
11921: CALL_OW 266
11925: PUSH
11926: LD_INT 7
11928: EQUAL
11929: OR
11930: IFFALSE 11946
// ru_bul := ru_bul ^ b_lab ;
11932: LD_ADDR_EXP 31
11936: PUSH
11937: LD_EXP 31
11941: PUSH
11942: LD_INT 6
11944: ADD
11945: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11946: LD_VAR 0 1
11950: PPUSH
11951: CALL_OW 266
11955: PUSH
11956: LD_INT 5
11958: EQUAL
11959: IFFALSE 11975
// ru_bul := ru_bul ^ b_armoury ;
11961: LD_ADDR_EXP 31
11965: PUSH
11966: LD_EXP 31
11970: PUSH
11971: LD_INT 4
11973: ADD
11974: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks ] then
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 266
11984: PUSH
11985: LD_INT 3
11987: PUSH
11988: LD_INT 8
11990: PUSH
11991: LD_INT 7
11993: PUSH
11994: LD_INT 5
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: IN
12003: NOT
12004: IFFALSE 12027
// ru_bul := ru_bul ^ GetBType ( un ) ;
12006: LD_ADDR_EXP 31
12010: PUSH
12011: LD_EXP 31
12015: PUSH
12016: LD_VAR 0 1
12020: PPUSH
12021: CALL_OW 266
12025: ADD
12026: ST_TO_ADDR
// ru_bul := ru_bul ^ GetX ( un ) ;
12027: LD_ADDR_EXP 31
12031: PUSH
12032: LD_EXP 31
12036: PUSH
12037: LD_VAR 0 1
12041: PPUSH
12042: CALL_OW 250
12046: ADD
12047: ST_TO_ADDR
// ru_bul := ru_bul ^ GetY ( un ) ;
12048: LD_ADDR_EXP 31
12052: PUSH
12053: LD_EXP 31
12057: PUSH
12058: LD_VAR 0 1
12062: PPUSH
12063: CALL_OW 251
12067: ADD
12068: ST_TO_ADDR
// ru_bul := ru_bul ^ GetDir ( un ) ;
12069: LD_ADDR_EXP 31
12073: PUSH
12074: LD_EXP 31
12078: PUSH
12079: LD_VAR 0 1
12083: PPUSH
12084: CALL_OW 254
12088: ADD
12089: ST_TO_ADDR
// end ; if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12090: LD_VAR 0 1
12094: PPUSH
12095: CALL_OW 255
12099: PUSH
12100: LD_INT 6
12102: EQUAL
12103: PUSH
12104: LD_VAR 0 1
12108: PUSH
12109: LD_INT 21
12111: PUSH
12112: LD_INT 2
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: PUSH
12124: LD_INT 34
12126: PUSH
12127: LD_INT 45
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PPUSH
12134: CALL_OW 69
12138: DIFF
12139: IN
12140: AND
12141: IFFALSE 12227
// begin ru_veh := ru_veh ^ GetChassis ( un ) ;
12143: LD_ADDR_EXP 27
12147: PUSH
12148: LD_EXP 27
12152: PUSH
12153: LD_VAR 0 1
12157: PPUSH
12158: CALL_OW 265
12162: ADD
12163: ST_TO_ADDR
// ru_veh := ru_veh ^ GetEngine ( un ) ;
12164: LD_ADDR_EXP 27
12168: PUSH
12169: LD_EXP 27
12173: PUSH
12174: LD_VAR 0 1
12178: PPUSH
12179: CALL_OW 262
12183: ADD
12184: ST_TO_ADDR
// ru_veh := ru_veh ^ GetControl ( un ) ;
12185: LD_ADDR_EXP 27
12189: PUSH
12190: LD_EXP 27
12194: PUSH
12195: LD_VAR 0 1
12199: PPUSH
12200: CALL_OW 263
12204: ADD
12205: ST_TO_ADDR
// ru_veh := ru_veh ^ GetWeapon ( un ) ;
12206: LD_ADDR_EXP 27
12210: PUSH
12211: LD_EXP 27
12215: PUSH
12216: LD_VAR 0 1
12220: PPUSH
12221: CALL_OW 264
12225: ADD
12226: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12227: LD_VAR 0 1
12231: PUSH
12232: LD_INT 22
12234: PUSH
12235: LD_INT 6
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 25
12244: PUSH
12245: LD_INT 3
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PPUSH
12256: CALL_OW 69
12260: IN
12261: PUSH
12262: LD_INT 22
12264: PUSH
12265: LD_INT 6
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: LD_INT 30
12274: PUSH
12275: LD_INT 3
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PUSH
12282: LD_INT 24
12284: PUSH
12285: LD_INT 251
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: LIST
12296: PPUSH
12297: CALL_OW 69
12301: PUSH
12302: LD_INT 0
12304: GREATER
12305: AND
12306: IFFALSE 12354
// begin uc_side := 6 ;
12308: LD_ADDR_OWVAR 20
12312: PUSH
12313: LD_INT 6
12315: ST_TO_ADDR
// uc_nation := 3 ;
12316: LD_ADDR_OWVAR 21
12320: PUSH
12321: LD_INT 3
12323: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_INT 3
12331: PPUSH
12332: LD_EXP 5
12336: PPUSH
12337: CALL 425 0 2
12341: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
12342: LD_VAR 0 1
12346: PPUSH
12347: LD_INT 92
12349: PPUSH
12350: CALL_OW 52
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
12354: LD_VAR 0 1
12358: PPUSH
12359: CALL_OW 255
12363: PUSH
12364: LD_INT 3
12366: EQUAL
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 21
12375: PUSH
12376: LD_INT 3
12378: PUSH
12379: EMPTY
12380: LIST
12381: LIST
12382: PPUSH
12383: CALL_OW 69
12387: IN
12388: AND
12389: IFFALSE 12620
// begin if GetBType ( un ) = b_factory then
12391: LD_VAR 0 1
12395: PPUSH
12396: CALL_OW 266
12400: PUSH
12401: LD_INT 3
12403: EQUAL
12404: IFFALSE 12420
// ru2_bul := ru2_bul ^ b_workshop ;
12406: LD_ADDR_EXP 41
12410: PUSH
12411: LD_EXP 41
12415: PUSH
12416: LD_INT 2
12418: ADD
12419: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
12420: LD_VAR 0 1
12424: PPUSH
12425: CALL_OW 266
12429: PUSH
12430: LD_INT 8
12432: EQUAL
12433: PUSH
12434: LD_VAR 0 1
12438: PPUSH
12439: CALL_OW 266
12443: PUSH
12444: LD_INT 7
12446: EQUAL
12447: OR
12448: IFFALSE 12464
// ru2_bul := ru2_bul ^ b_lab ;
12450: LD_ADDR_EXP 41
12454: PUSH
12455: LD_EXP 41
12459: PUSH
12460: LD_INT 6
12462: ADD
12463: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12464: LD_VAR 0 1
12468: PPUSH
12469: CALL_OW 266
12473: PUSH
12474: LD_INT 5
12476: EQUAL
12477: IFFALSE 12493
// ru2_bul := ru2_bul ^ b_armoury ;
12479: LD_ADDR_EXP 41
12483: PUSH
12484: LD_EXP 41
12488: PUSH
12489: LD_INT 4
12491: ADD
12492: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks , b_ext_gun , b_ext_noncombat , b_ext_track ] then
12493: LD_VAR 0 1
12497: PPUSH
12498: CALL_OW 266
12502: PUSH
12503: LD_INT 3
12505: PUSH
12506: LD_INT 8
12508: PUSH
12509: LD_INT 7
12511: PUSH
12512: LD_INT 5
12514: PUSH
12515: LD_INT 17
12517: PUSH
12518: LD_INT 19
12520: PUSH
12521: LD_INT 16
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: IN
12533: NOT
12534: IFFALSE 12557
// ru2_bul := ru2_bul ^ GetBType ( un ) ;
12536: LD_ADDR_EXP 41
12540: PUSH
12541: LD_EXP 41
12545: PUSH
12546: LD_VAR 0 1
12550: PPUSH
12551: CALL_OW 266
12555: ADD
12556: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetX ( un ) ;
12557: LD_ADDR_EXP 41
12561: PUSH
12562: LD_EXP 41
12566: PUSH
12567: LD_VAR 0 1
12571: PPUSH
12572: CALL_OW 250
12576: ADD
12577: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetY ( un ) ;
12578: LD_ADDR_EXP 41
12582: PUSH
12583: LD_EXP 41
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 251
12597: ADD
12598: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetDir ( un ) ;
12599: LD_ADDR_EXP 41
12603: PUSH
12604: LD_EXP 41
12608: PUSH
12609: LD_VAR 0 1
12613: PPUSH
12614: CALL_OW 254
12618: ADD
12619: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12620: LD_VAR 0 1
12624: PPUSH
12625: CALL_OW 255
12629: PUSH
12630: LD_INT 3
12632: EQUAL
12633: PUSH
12634: LD_VAR 0 1
12638: PUSH
12639: LD_INT 21
12641: PUSH
12642: LD_INT 2
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL_OW 69
12653: PUSH
12654: LD_INT 34
12656: PUSH
12657: LD_INT 45
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PPUSH
12664: CALL_OW 69
12668: DIFF
12669: IN
12670: AND
12671: IFFALSE 12757
// begin ru2_veh := ru2_veh ^ GetChassis ( un ) ;
12673: LD_ADDR_EXP 37
12677: PUSH
12678: LD_EXP 37
12682: PUSH
12683: LD_VAR 0 1
12687: PPUSH
12688: CALL_OW 265
12692: ADD
12693: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetEngine ( un ) ;
12694: LD_ADDR_EXP 37
12698: PUSH
12699: LD_EXP 37
12703: PUSH
12704: LD_VAR 0 1
12708: PPUSH
12709: CALL_OW 262
12713: ADD
12714: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetControl ( un ) ;
12715: LD_ADDR_EXP 37
12719: PUSH
12720: LD_EXP 37
12724: PUSH
12725: LD_VAR 0 1
12729: PPUSH
12730: CALL_OW 263
12734: ADD
12735: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetWeapon ( un ) ;
12736: LD_ADDR_EXP 37
12740: PUSH
12741: LD_EXP 37
12745: PUSH
12746: LD_VAR 0 1
12750: PPUSH
12751: CALL_OW 264
12755: ADD
12756: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12757: LD_VAR 0 1
12761: PUSH
12762: LD_INT 22
12764: PUSH
12765: LD_INT 3
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: LD_INT 25
12774: PUSH
12775: LD_INT 3
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PPUSH
12786: CALL_OW 69
12790: IN
12791: PUSH
12792: LD_INT 22
12794: PUSH
12795: LD_INT 3
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PUSH
12802: LD_INT 30
12804: PUSH
12805: LD_INT 3
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PUSH
12812: LD_INT 24
12814: PUSH
12815: LD_INT 251
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: PUSH
12832: LD_INT 0
12834: GREATER
12835: AND
12836: IFFALSE 12914
// begin uc_side := 3 ;
12838: LD_ADDR_OWVAR 20
12842: PUSH
12843: LD_INT 3
12845: ST_TO_ADDR
// uc_nation := 3 ;
12846: LD_ADDR_OWVAR 21
12850: PUSH
12851: LD_INT 3
12853: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12854: LD_ADDR_VAR 0 1
12858: PUSH
12859: LD_INT 3
12861: PPUSH
12862: LD_EXP 5
12866: PPUSH
12867: CALL 425 0 2
12871: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12872: LD_VAR 0 1
12876: PPUSH
12877: LD_INT 22
12879: PUSH
12880: LD_INT 3
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PUSH
12887: LD_INT 30
12889: PUSH
12890: LD_INT 3
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PPUSH
12901: CALL_OW 69
12905: PUSH
12906: LD_INT 1
12908: ARRAY
12909: PPUSH
12910: CALL_OW 52
// end ; end ;
12914: PPOPN 1
12916: END
// on VehicleConstructed ( veh , fac ) do begin if veh in FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) then
12917: LD_VAR 0 1
12921: PUSH
12922: LD_INT 2
12924: PUSH
12925: LD_INT 22
12927: PUSH
12928: LD_INT 6
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 22
12937: PUSH
12938: LD_INT 3
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: LIST
12949: PUSH
12950: LD_INT 21
12952: PUSH
12953: LD_INT 2
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: LD_INT 3
12962: PUSH
12963: LD_INT 2
12965: PUSH
12966: LD_INT 34
12968: PUSH
12969: LD_INT 52
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 34
12978: PUSH
12979: LD_INT 51
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: LD_INT 34
12988: PUSH
12989: LD_INT 53
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: LIST
13010: PPUSH
13011: CALL_OW 69
13015: IN
13016: IFFALSE 13041
// ru_list_attackers := Insert ( ru_list_attackers , 1 , veh ) ;
13018: LD_ADDR_EXP 43
13022: PUSH
13023: LD_EXP 43
13027: PPUSH
13028: LD_INT 1
13030: PPUSH
13031: LD_VAR 0 1
13035: PPUSH
13036: CALL_OW 2
13040: ST_TO_ADDR
// end ;
13041: PPOPN 2
13043: END
// on BuildingComplete ( b ) do var i ;
13044: LD_INT 0
13046: PPUSH
// begin if b in FilterAllUnits ( [ f_side , 6 ] ) then
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 22
13054: PUSH
13055: LD_INT 6
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL_OW 69
13066: IN
13067: IFFALSE 13107
// for i = 1 to 4 do
13069: LD_ADDR_VAR 0 2
13073: PUSH
13074: DOUBLE
13075: LD_INT 1
13077: DEC
13078: ST_TO_ADDR
13079: LD_INT 4
13081: PUSH
13082: FOR_TO
13083: IFFALSE 13105
// ru_bul := Delete ( ru_bul , 1 ) ;
13085: LD_ADDR_EXP 31
13089: PUSH
13090: LD_EXP 31
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: CALL_OW 3
13102: ST_TO_ADDR
13103: GO 13082
13105: POP
13106: POP
// if b in FilterAllUnits ( [ f_side , 3 ] ) then
13107: LD_VAR 0 1
13111: PUSH
13112: LD_INT 22
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: PPUSH
13122: CALL_OW 69
13126: IN
13127: IFFALSE 13167
// for i = 1 to 4 do
13129: LD_ADDR_VAR 0 2
13133: PUSH
13134: DOUBLE
13135: LD_INT 1
13137: DEC
13138: ST_TO_ADDR
13139: LD_INT 4
13141: PUSH
13142: FOR_TO
13143: IFFALSE 13165
// ru2_bul := Delete ( ru2_bul , 1 ) ;
13145: LD_ADDR_EXP 41
13149: PUSH
13150: LD_EXP 41
13154: PPUSH
13155: LD_INT 1
13157: PPUSH
13158: CALL_OW 3
13162: ST_TO_ADDR
13163: GO 13142
13165: POP
13166: POP
// end ;
13167: PPOPN 2
13169: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
13170: LD_VAR 0 1
13174: PPUSH
13175: LD_VAR 0 2
13179: PPUSH
13180: LD_VAR 0 3
13184: PPUSH
13185: CALL 26111 0 3
// end ;
13189: PPOPN 3
13191: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13192: LD_VAR 0 1
13196: PPUSH
13197: CALL 26209 0 1
// end ; end_of_file
13201: PPOPN 1
13203: END
// export function Start_Game ; begin
13204: LD_INT 0
13206: PPUSH
// global_diff := GetMultiplayerSetting ( 0 ) ;
13207: LD_ADDR_EXP 3
13211: PUSH
13212: LD_INT 0
13214: PPUSH
13215: CALL_OW 426
13219: ST_TO_ADDR
// if not global_diff then
13220: LD_EXP 3
13224: NOT
13225: IFFALSE 13235
// global_diff := 1 ;
13227: LD_ADDR_EXP 3
13231: PUSH
13232: LD_INT 1
13234: ST_TO_ADDR
// CenterOnXY ( 70 , 130 ) ;
13235: LD_INT 70
13237: PPUSH
13238: LD_INT 130
13240: PPUSH
13241: CALL_OW 84
// case Query ( text1 ) of 1 :
13245: LD_STRING text1
13247: PPUSH
13248: CALL_OW 97
13252: PUSH
13253: LD_INT 1
13255: DOUBLE
13256: EQUAL
13257: IFTRUE 13261
13259: GO 13264
13261: POP
// ; end ;
13262: GO 13265
13264: POP
// ChangeMissionObjectives ( target1 ) ;
13265: LD_STRING target1
13267: PPUSH
13268: CALL_OW 337
// game_started := true ;
13272: LD_ADDR_EXP 10
13276: PUSH
13277: LD_INT 1
13279: ST_TO_ADDR
// crates_allow := true ;
13280: LD_ADDR_EXP 13
13284: PUSH
13285: LD_INT 1
13287: ST_TO_ADDR
// if global_diff > 2 then
13288: LD_EXP 3
13292: PUSH
13293: LD_INT 2
13295: GREATER
13296: IFFALSE 13305
// RemoveUnit ( us_spec_b ) ;
13298: LD_INT 140
13300: PPUSH
13301: CALL_OW 64
// end ;
13305: LD_VAR 0 1
13309: RET
// every 0 0$0.3 trigger SeeSide ( sikorski_veh , 6 ) or SeeSide ( sikorski_veh , 3 ) or SeeSide ( sikorski , 3 ) or SeeSide ( sikorski , 6 ) do
13310: LD_EXP 22
13314: PPUSH
13315: LD_INT 6
13317: PPUSH
13318: CALL 870 0 2
13322: PUSH
13323: LD_EXP 22
13327: PPUSH
13328: LD_INT 3
13330: PPUSH
13331: CALL 870 0 2
13335: OR
13336: PUSH
13337: LD_EXP 14
13341: PPUSH
13342: LD_INT 3
13344: PPUSH
13345: CALL 870 0 2
13349: OR
13350: PUSH
13351: LD_EXP 14
13355: PPUSH
13356: LD_INT 6
13358: PPUSH
13359: CALL 870 0 2
13363: OR
13364: IFFALSE 13381
13366: GO 13368
13368: DISABLE
// Say ( sikorski , DRus ) ;
13369: LD_EXP 14
13373: PPUSH
13374: LD_STRING DRus
13376: PPUSH
13377: CALL_OW 88
13381: END
// every 0 0$03 trigger See ( 4 , sikorski ) or See ( 4 , sikorski_veh ) do var i , per ;
13382: LD_INT 4
13384: PPUSH
13385: LD_EXP 14
13389: PPUSH
13390: CALL_OW 292
13394: PUSH
13395: LD_INT 4
13397: PPUSH
13398: LD_EXP 22
13402: PPUSH
13403: CALL_OW 292
13407: OR
13408: IFFALSE 13830
13410: GO 13412
13412: DISABLE
13413: LD_INT 0
13415: PPUSH
13416: PPUSH
// begin Wait ( 0 0$05 ) ;
13417: LD_INT 175
13419: PPUSH
13420: CALL_OW 67
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_INT 22
13431: PUSH
13432: LD_INT 4
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: FOR_IN
13445: IFFALSE 13461
// SetSide ( i , 1 ) ;
13447: LD_VAR 0 1
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 235
13459: GO 13444
13461: POP
13462: POP
// per := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff sikorski ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_INT 22
13470: PUSH
13471: LD_INT 1
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: LD_INT 21
13480: PUSH
13481: LD_INT 1
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 26
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: LIST
13502: PPUSH
13503: CALL_OW 69
13507: PUSH
13508: LD_EXP 14
13512: DIFF
13513: ST_TO_ADDR
// InGameOn ;
13514: CALL_OW 8
// CenterNowOnXY ( 19 , 13 ) ;
13518: LD_INT 19
13520: PPUSH
13521: LD_INT 13
13523: PPUSH
13524: CALL_OW 86
// if IsInUnit ( sikorski ) then
13528: LD_EXP 14
13532: PPUSH
13533: CALL_OW 310
13537: IFFALSE 13555
// begin ComExitVehicle ( sikorski ) ;
13539: LD_EXP 14
13543: PPUSH
13544: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
13548: LD_INT 10
13550: PPUSH
13551: CALL_OW 67
// end ; ComTurnUnit ( sikorski , per [ 1 ] ) ;
13555: LD_EXP 14
13559: PPUSH
13560: LD_VAR 0 2
13564: PUSH
13565: LD_INT 1
13567: ARRAY
13568: PPUSH
13569: CALL_OW 119
// ComTurnUnit ( per [ 1 ] , sikorski ) ;
13573: LD_VAR 0 2
13577: PUSH
13578: LD_INT 1
13580: ARRAY
13581: PPUSH
13582: LD_EXP 14
13586: PPUSH
13587: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
13591: LD_INT 10
13593: PPUSH
13594: CALL_OW 67
// Say ( sikorski , DS-1 ) ;
13598: LD_EXP 14
13602: PPUSH
13603: LD_STRING DS-1
13605: PPUSH
13606: CALL_OW 88
// Say ( per [ 1 ] , DP-1 ) ;
13610: LD_VAR 0 2
13614: PUSH
13615: LD_INT 1
13617: ARRAY
13618: PPUSH
13619: LD_STRING DP-1
13621: PPUSH
13622: CALL_OW 88
// Say ( sikorski , DS-2 ) ;
13626: LD_EXP 14
13630: PPUSH
13631: LD_STRING DS-2
13633: PPUSH
13634: CALL_OW 88
// Say ( per [ 1 ] , DP-2 ) ;
13638: LD_VAR 0 2
13642: PUSH
13643: LD_INT 1
13645: ARRAY
13646: PPUSH
13647: LD_STRING DP-2
13649: PPUSH
13650: CALL_OW 88
// Say ( sikorski , DS-3 ) ;
13654: LD_EXP 14
13658: PPUSH
13659: LD_STRING DS-3
13661: PPUSH
13662: CALL_OW 88
// Say ( per [ 1 ] , DP-3 ) ;
13666: LD_VAR 0 2
13670: PUSH
13671: LD_INT 1
13673: ARRAY
13674: PPUSH
13675: LD_STRING DP-3
13677: PPUSH
13678: CALL_OW 88
// Say ( sikorski , DS-4 ) ;
13682: LD_EXP 14
13686: PPUSH
13687: LD_STRING DS-4
13689: PPUSH
13690: CALL_OW 88
// Wait ( 0 0$0.6 ) ;
13694: LD_INT 21
13696: PPUSH
13697: CALL_OW 67
// SayRadio ( ron , DR-1 ) ;
13701: LD_EXP 17
13705: PPUSH
13706: LD_STRING DR-1
13708: PPUSH
13709: CALL_OW 94
// Say ( sikorski , DS-5 ) ;
13713: LD_EXP 14
13717: PPUSH
13718: LD_STRING DS-5
13720: PPUSH
13721: CALL_OW 88
// SayRadio ( ron , DR-2 ) ;
13725: LD_EXP 17
13729: PPUSH
13730: LD_STRING DR-2
13732: PPUSH
13733: CALL_OW 94
// Say ( sikorski , DS-6 ) ;
13737: LD_EXP 14
13741: PPUSH
13742: LD_STRING DS-6
13744: PPUSH
13745: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
13749: LD_INT 10
13751: PPUSH
13752: CALL_OW 67
// SayRadio ( ron , DR-3 ) ;
13756: LD_EXP 17
13760: PPUSH
13761: LD_STRING DR-3
13763: PPUSH
13764: CALL_OW 94
// InGameOff ;
13768: CALL_OW 9
// ChangeMissionObjectives ( target2 ) ;
13772: LD_STRING target2
13774: PPUSH
13775: CALL_OW 337
// Wait ( 0 0$03 ) ;
13779: LD_INT 105
13781: PPUSH
13782: CALL_OW 67
// Say ( sikorski , DS-7 ) ;
13786: LD_EXP 14
13790: PPUSH
13791: LD_STRING DS-7
13793: PPUSH
13794: CALL_OW 88
// Wait ( [ 6 6$00 , 5 5$00 , 4 4$00 ] [ global_diff ] ) ;
13798: LD_INT 12600
13800: PUSH
13801: LD_INT 10500
13803: PUSH
13804: LD_INT 8400
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: LIST
13811: PUSH
13812: LD_EXP 3
13816: ARRAY
13817: PPUSH
13818: CALL_OW 67
// russian_produce := true ;
13822: LD_ADDR_EXP 20
13826: PUSH
13827: LD_INT 1
13829: ST_TO_ADDR
// end ;
13830: PPOPN 2
13832: END
// export us_unit ; every 0 0$11 trigger timer >= [ 25 25$00 , 27 27$30 , 29 29$20 ] [ global_diff ] do
13833: LD_EXP 2
13837: PUSH
13838: LD_INT 52500
13840: PUSH
13841: LD_INT 57750
13843: PUSH
13844: LD_INT 61600
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: LIST
13851: PUSH
13852: LD_EXP 3
13856: ARRAY
13857: GREATEREQUAL
13858: IFFALSE 14026
13860: GO 13862
13862: DISABLE
// begin uc_side := 8 ;
13863: LD_ADDR_OWVAR 20
13867: PUSH
13868: LD_INT 8
13870: ST_TO_ADDR
// uc_nation := 1 ;
13871: LD_ADDR_OWVAR 21
13875: PUSH
13876: LD_INT 1
13878: ST_TO_ADDR
// hc_sex := sex_male ;
13879: LD_ADDR_OWVAR 27
13883: PUSH
13884: LD_INT 1
13886: ST_TO_ADDR
// hc_gallery :=  ;
13887: LD_ADDR_OWVAR 33
13891: PUSH
13892: LD_STRING 
13894: ST_TO_ADDR
// hc_name :=  ;
13895: LD_ADDR_OWVAR 26
13899: PUSH
13900: LD_STRING 
13902: ST_TO_ADDR
// hc_class := Rand ( 1 , 4 ) ;
13903: LD_ADDR_OWVAR 28
13907: PUSH
13908: LD_INT 1
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 12
13918: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
13919: LD_ADDR_OWVAR 31
13923: PUSH
13924: LD_INT 2
13926: PPUSH
13927: LD_EXP 6
13931: PPUSH
13932: CALL_OW 12
13936: PUSH
13937: LD_INT 2
13939: PPUSH
13940: LD_EXP 6
13944: PPUSH
13945: CALL_OW 12
13949: PUSH
13950: LD_INT 2
13952: PPUSH
13953: LD_EXP 6
13957: PPUSH
13958: CALL_OW 12
13962: PUSH
13963: LD_INT 2
13965: PPUSH
13966: LD_EXP 6
13970: PPUSH
13971: CALL_OW 12
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: ST_TO_ADDR
// us_unit := CreateHuman ;
13982: LD_ADDR_EXP 45
13986: PUSH
13987: CALL_OW 44
13991: ST_TO_ADDR
// PlaceUnitArea ( us_unit , swamp_spawn , true ) ;
13992: LD_EXP 45
13996: PPUSH
13997: LD_INT 13
13999: PPUSH
14000: LD_INT 1
14002: PPUSH
14003: CALL_OW 49
// Wait ( 0 0$0.3 ) ;
14007: LD_INT 10
14009: PPUSH
14010: CALL_OW 67
// SayRadio ( us_unit , Dun1 ) ;
14014: LD_EXP 45
14018: PPUSH
14019: LD_STRING Dun1
14021: PPUSH
14022: CALL_OW 94
// end ;
14026: END
// every 0 0$01 trigger See ( 1 , us_unit ) do
14027: LD_INT 1
14029: PPUSH
14030: LD_EXP 45
14034: PPUSH
14035: CALL_OW 292
14039: IFFALSE 14056
14041: GO 14043
14043: DISABLE
// SetSide ( us_unit , 1 ) ;
14044: LD_EXP 45
14048: PPUSH
14049: LD_INT 1
14051: PPUSH
14052: CALL_OW 235
14056: END
// every 1 1$35 trigger timer >= [ 8 8$00 , 9 9$00 , 10 10$00 ] [ global_diff ] do var un , veh , i ;
14057: LD_EXP 2
14061: PUSH
14062: LD_INT 16800
14064: PUSH
14065: LD_INT 18900
14067: PUSH
14068: LD_INT 21000
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: LIST
14075: PUSH
14076: LD_EXP 3
14080: ARRAY
14081: GREATEREQUAL
14082: IFFALSE 14461
14084: GO 14086
14086: DISABLE
14087: LD_INT 0
14089: PPUSH
14090: PPUSH
14091: PPUSH
// begin uc_side := 4 ;
14092: LD_ADDR_OWVAR 20
14096: PUSH
14097: LD_INT 4
14099: ST_TO_ADDR
// uc_nation := 1 ;
14100: LD_ADDR_OWVAR 21
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_medium_wheeled ] [ global_diff ] ;
14108: LD_ADDR_OWVAR 37
14112: PUSH
14113: LD_INT 3
14115: PUSH
14116: LD_INT 2
14118: PUSH
14119: LD_INT 2
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: LIST
14126: PUSH
14127: LD_EXP 3
14131: ARRAY
14132: ST_TO_ADDR
// vc_engine := engine_solar ;
14133: LD_ADDR_OWVAR 39
14137: PUSH
14138: LD_INT 2
14140: ST_TO_ADDR
// vc_control := control_manual ;
14141: LD_ADDR_OWVAR 38
14145: PUSH
14146: LD_INT 1
14148: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
14149: LD_ADDR_OWVAR 40
14153: PUSH
14154: LD_INT 12
14156: ST_TO_ADDR
// veh := CreateVehicle ;
14157: LD_ADDR_VAR 0 2
14161: PUSH
14162: CALL_OW 45
14166: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , false ) ;
14167: LD_VAR 0 2
14171: PPUSH
14172: LD_INT 20
14174: PPUSH
14175: LD_INT 0
14177: PPUSH
14178: CALL_OW 49
// hc_sex := sex_male ;
14182: LD_ADDR_OWVAR 27
14186: PUSH
14187: LD_INT 1
14189: ST_TO_ADDR
// hc_gallery :=  ;
14190: LD_ADDR_OWVAR 33
14194: PUSH
14195: LD_STRING 
14197: ST_TO_ADDR
// hc_name :=  ;
14198: LD_ADDR_OWVAR 26
14202: PUSH
14203: LD_STRING 
14205: ST_TO_ADDR
// hc_class := 3 ;
14206: LD_ADDR_OWVAR 28
14210: PUSH
14211: LD_INT 3
14213: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
14214: LD_ADDR_OWVAR 31
14218: PUSH
14219: LD_INT 2
14221: PPUSH
14222: LD_EXP 6
14226: PPUSH
14227: CALL_OW 12
14231: PUSH
14232: LD_INT 2
14234: PPUSH
14235: LD_EXP 6
14239: PPUSH
14240: CALL_OW 12
14244: PUSH
14245: LD_INT 2
14247: PPUSH
14248: LD_EXP 6
14252: PPUSH
14253: CALL_OW 12
14257: PUSH
14258: LD_INT 2
14260: PPUSH
14261: LD_EXP 6
14265: PPUSH
14266: CALL_OW 12
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: ST_TO_ADDR
// un := CreateHuman ;
14277: LD_ADDR_VAR 0 1
14281: PUSH
14282: CALL_OW 44
14286: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , true ) ;
14287: LD_VAR 0 2
14291: PPUSH
14292: LD_INT 20
14294: PPUSH
14295: LD_INT 1
14297: PPUSH
14298: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
14302: LD_VAR 0 1
14306: PPUSH
14307: LD_VAR 0 2
14311: PPUSH
14312: CALL_OW 52
// SetCargo ( veh , mat_cans , 60 ) ;
14316: LD_VAR 0 2
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: LD_INT 60
14326: PPUSH
14327: CALL_OW 290
// SetFuel ( veh , 98 ) ;
14331: LD_VAR 0 2
14335: PPUSH
14336: LD_INT 98
14338: PPUSH
14339: CALL_OW 240
// SetLives ( un , 500 ) ;
14343: LD_VAR 0 1
14347: PPUSH
14348: LD_INT 500
14350: PPUSH
14351: CALL_OW 234
// SetLives ( veh , Rand ( 900 , 999 ) ) ;
14355: LD_VAR 0 2
14359: PPUSH
14360: LD_INT 900
14362: PPUSH
14363: LD_INT 999
14365: PPUSH
14366: CALL_OW 12
14370: PPUSH
14371: CALL_OW 234
// ComMoveXY ( un , 14 , 9 ) ;
14375: LD_VAR 0 1
14379: PPUSH
14380: LD_INT 14
14382: PPUSH
14383: LD_INT 9
14385: PPUSH
14386: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
14390: LD_INT 35
14392: PPUSH
14393: CALL_OW 67
// until See ( 1 , veh ) or See ( 1 , un ) ;
14397: LD_INT 1
14399: PPUSH
14400: LD_VAR 0 2
14404: PPUSH
14405: CALL_OW 292
14409: PUSH
14410: LD_INT 1
14412: PPUSH
14413: LD_VAR 0 1
14417: PPUSH
14418: CALL_OW 292
14422: OR
14423: IFFALSE 14390
// Say ( un , Dcargo ) ;
14425: LD_VAR 0 1
14429: PPUSH
14430: LD_STRING Dcargo
14432: PPUSH
14433: CALL_OW 88
// SetSide ( un , 1 ) ;
14437: LD_VAR 0 1
14441: PPUSH
14442: LD_INT 1
14444: PPUSH
14445: CALL_OW 235
// SetSide ( veh , 1 ) ;
14449: LD_VAR 0 2
14453: PPUSH
14454: LD_INT 1
14456: PPUSH
14457: CALL_OW 235
// end ;
14461: PPOPN 3
14463: END
// every 0 0$01 trigger timer >= [ 18 18$00 , 19 19$00 , 21 21$00 ] [ global_diff ] and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) < 5 do var un , speaker , veh , i , area ;
14464: LD_EXP 2
14468: PUSH
14469: LD_INT 37800
14471: PUSH
14472: LD_INT 39900
14474: PUSH
14475: LD_INT 44100
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: LIST
14482: PUSH
14483: LD_EXP 3
14487: ARRAY
14488: GREATEREQUAL
14489: PUSH
14490: LD_INT 22
14492: PUSH
14493: LD_INT 6
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PUSH
14500: LD_INT 21
14502: PUSH
14503: LD_INT 2
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: PPUSH
14514: CALL_OW 69
14518: PUSH
14519: LD_INT 5
14521: LESS
14522: AND
14523: IFFALSE 14858
14525: GO 14527
14527: DISABLE
14528: LD_INT 0
14530: PPUSH
14531: PPUSH
14532: PPUSH
14533: PPUSH
14534: PPUSH
// begin area := [ us_north , us_south , us_north ] [ global_diff ] ;
14535: LD_ADDR_VAR 0 5
14539: PUSH
14540: LD_INT 21
14542: PUSH
14543: LD_INT 14
14545: PUSH
14546: LD_INT 21
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: LIST
14553: PUSH
14554: LD_EXP 3
14558: ARRAY
14559: ST_TO_ADDR
// speaker := [ ] ;
14560: LD_ADDR_VAR 0 2
14564: PUSH
14565: EMPTY
14566: ST_TO_ADDR
// uc_side := 1 ;
14567: LD_ADDR_OWVAR 20
14571: PUSH
14572: LD_INT 1
14574: ST_TO_ADDR
// uc_nation := 1 ;
14575: LD_ADDR_OWVAR 21
14579: PUSH
14580: LD_INT 1
14582: ST_TO_ADDR
// for i = 1 to 7 - [ global_diff ] do
14583: LD_ADDR_VAR 0 4
14587: PUSH
14588: DOUBLE
14589: LD_INT 1
14591: DEC
14592: ST_TO_ADDR
14593: LD_INT 7
14595: PUSH
14596: LD_EXP 3
14600: PUSH
14601: EMPTY
14602: LIST
14603: MINUS
14604: PUSH
14605: FOR_TO
14606: IFFALSE 14669
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , am_def ) ;
14608: LD_ADDR_VAR 0 1
14612: PUSH
14613: LD_INT 1
14615: PPUSH
14616: LD_INT 4
14618: PPUSH
14619: CALL_OW 12
14623: PPUSH
14624: LD_EXP 6
14628: PPUSH
14629: CALL 425 0 2
14633: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
14634: LD_VAR 0 1
14638: PPUSH
14639: LD_VAR 0 5
14643: PPUSH
14644: LD_INT 0
14646: PPUSH
14647: CALL_OW 49
// speaker := speaker ^ un ;
14651: LD_ADDR_VAR 0 2
14655: PUSH
14656: LD_VAR 0 2
14660: PUSH
14661: LD_VAR 0 1
14665: ADD
14666: ST_TO_ADDR
// end ;
14667: GO 14605
14669: POP
14670: POP
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ global_diff ] ;
14671: LD_ADDR_OWVAR 37
14675: PUSH
14676: LD_INT 3
14678: PUSH
14679: LD_INT 2
14681: PUSH
14682: LD_INT 1
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PUSH
14690: LD_EXP 3
14694: ARRAY
14695: ST_TO_ADDR
// vc_engine := engine_solar ;
14696: LD_ADDR_OWVAR 39
14700: PUSH
14701: LD_INT 2
14703: ST_TO_ADDR
// vc_control := control_manual ;
14704: LD_ADDR_OWVAR 38
14708: PUSH
14709: LD_INT 1
14711: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_gatling_gun , us_machine_gun ] [ global_diff ] ;
14712: LD_ADDR_OWVAR 40
14716: PUSH
14717: LD_INT 5
14719: PUSH
14720: LD_INT 4
14722: PUSH
14723: LD_INT 2
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: LIST
14730: PUSH
14731: LD_EXP 3
14735: ARRAY
14736: ST_TO_ADDR
// veh := CreateVehicle ;
14737: LD_ADDR_VAR 0 3
14741: PUSH
14742: CALL_OW 45
14746: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
14747: LD_VAR 0 3
14751: PPUSH
14752: LD_VAR 0 5
14756: PPUSH
14757: LD_INT 0
14759: PPUSH
14760: CALL_OW 49
// un := CreateHumanWithClass ( 3 , am_def ) ;
14764: LD_ADDR_VAR 0 1
14768: PUSH
14769: LD_INT 3
14771: PPUSH
14772: LD_EXP 6
14776: PPUSH
14777: CALL 425 0 2
14781: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_VAR 0 3
14791: PPUSH
14792: CALL_OW 52
// Wait ( 0 0$0.3 ) ;
14796: LD_INT 10
14798: PPUSH
14799: CALL_OW 67
// SayRadio ( UnitFilter ( speaker , [ f_sex , sex_male ] ) [ 1 ] , Dhelp ) ;
14803: LD_VAR 0 2
14807: PPUSH
14808: LD_INT 26
14810: PUSH
14811: LD_INT 1
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: PPUSH
14818: CALL_OW 72
14822: PUSH
14823: LD_INT 1
14825: ARRAY
14826: PPUSH
14827: LD_STRING Dhelp
14829: PPUSH
14830: CALL_OW 94
// CenterNowOnXY ( GetX ( un ) , GetY ( un ) ) ;
14834: LD_VAR 0 1
14838: PPUSH
14839: CALL_OW 250
14843: PPUSH
14844: LD_VAR 0 1
14848: PPUSH
14849: CALL_OW 251
14853: PPUSH
14854: CALL_OW 86
// end ;
14858: PPOPN 5
14860: END
// every 0 0$01 trigger FilterUnitsInArea ( kurin_a , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) and IsOk ( Kurin ) do
14861: LD_INT 19
14863: PPUSH
14864: LD_INT 2
14866: PUSH
14867: LD_INT 22
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 22
14879: PUSH
14880: LD_INT 6
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: LIST
14891: PPUSH
14892: CALL_OW 70
14896: PUSH
14897: LD_EXP 15
14901: PPUSH
14902: CALL_OW 302
14906: AND
14907: IFFALSE 14924
14909: GO 14911
14911: DISABLE
// SayRadio ( Kurin , Dkurin ) ;
14912: LD_EXP 15
14916: PPUSH
14917: LD_STRING Dkurin
14919: PPUSH
14920: CALL_OW 94
14924: END
// every 0 0$01 trigger timer > 27 27$00 do
14925: LD_EXP 2
14929: PUSH
14930: LD_INT 56700
14932: GREATER
14933: IFFALSE 14950
14935: GO 14937
14937: DISABLE
// SayRadio ( jack , ar_come ) ;
14938: LD_EXP 18
14942: PPUSH
14943: LD_STRING ar_come
14945: PPUSH
14946: CALL_OW 94
14950: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) > 0 do
14951: LD_INT 22
14953: PUSH
14954: LD_INT 2
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PPUSH
14961: CALL_OW 69
14965: PUSH
14966: LD_INT 0
14968: GREATER
14969: IFFALSE 14997
14971: GO 14973
14973: DISABLE
// begin FHeike ;
14974: CALL 11549 0 0
// Wait ( 0 0$01 ) ;
14978: LD_INT 35
14980: PPUSH
14981: CALL_OW 67
// SayRadio ( heike , heike1 ) ;
14985: LD_EXP 16
14989: PPUSH
14990: LD_STRING heike1
14992: PPUSH
14993: CALL_OW 94
// end ;
14997: END
// every 15 15$00 trigger timer > 22 22$00 do
14998: LD_EXP 2
15002: PUSH
15003: LD_INT 46200
15005: GREATER
15006: IFFALSE 15057
15008: GO 15010
15010: DISABLE
// begin enable ;
15011: ENABLE
// ArabianAttack ( 2 , ar_force , Rand ( 1 , 2 ) , [ ar_area1 , ar_area2 ] [ Rand ( 1 , 2 ) ] ) ;
15012: LD_INT 2
15014: PPUSH
15015: LD_EXP 9
15019: PPUSH
15020: LD_INT 1
15022: PPUSH
15023: LD_INT 2
15025: PPUSH
15026: CALL_OW 12
15030: PPUSH
15031: LD_INT 6
15033: PUSH
15034: LD_INT 16
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: LD_INT 1
15043: PPUSH
15044: LD_INT 2
15046: PPUSH
15047: CALL_OW 12
15051: ARRAY
15052: PPUSH
15053: CALL 10966 0 4
// end ;
15057: END
// every 0 0$01 trigger timer >= Rand ( 65 65$00 , 67 67$30 ) or ( FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 ) do var i ;
15058: LD_EXP 2
15062: PUSH
15063: LD_INT 136500
15065: PPUSH
15066: LD_INT 141750
15068: PPUSH
15069: CALL_OW 12
15073: GREATEREQUAL
15074: PUSH
15075: LD_INT 22
15077: PUSH
15078: LD_INT 3
15080: PUSH
15081: EMPTY
15082: LIST
15083: LIST
15084: PPUSH
15085: CALL_OW 69
15089: PUSH
15090: LD_INT 22
15092: PUSH
15093: LD_INT 6
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: PPUSH
15100: CALL_OW 69
15104: PLUS
15105: PUSH
15106: LD_INT 3
15108: LESS
15109: OR
15110: IFFALSE 15184
15112: GO 15114
15114: DISABLE
15115: LD_INT 0
15117: PPUSH
// begin InGameOn ;
15118: CALL_OW 8
// DialogueOn ;
15122: CALL_OW 6
// SayRadio ( ron , you_win ) ;
15126: LD_EXP 17
15130: PPUSH
15131: LD_STRING you_win
15133: PPUSH
15134: CALL_OW 94
// DialogueOff ;
15138: CALL_OW 7
// InGameOff ;
15142: CALL_OW 9
// AddMedal ( med , 1 ) ;
15146: LD_STRING med
15148: PPUSH
15149: LD_INT 1
15151: PPUSH
15152: CALL_OW 101
// End_The_Mission_Allowed := true ;
15156: LD_ADDR_OWVAR 57
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
// case Query ( MEnd ) of 1 :
15164: LD_STRING MEnd
15166: PPUSH
15167: CALL_OW 97
15171: PUSH
15172: LD_INT 1
15174: DOUBLE
15175: EQUAL
15176: IFTRUE 15180
15178: GO 15183
15180: POP
// ; end ;
15181: GO 15184
15183: POP
// end ;
15184: PPOPN 1
15186: END
// on EndTheMissionRaised ( exitt ) do begin End_The_Mission_Allowed := false ;
15187: LD_ADDR_OWVAR 57
15191: PUSH
15192: LD_INT 0
15194: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 then
15195: LD_INT 22
15197: PUSH
15198: LD_INT 3
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PPUSH
15205: CALL_OW 69
15209: PUSH
15210: LD_INT 22
15212: PUSH
15213: LD_INT 6
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL_OW 69
15224: PLUS
15225: PUSH
15226: LD_INT 3
15228: LESS
15229: IFFALSE 15243
// AddMedal ( ru , 1 ) else
15231: LD_STRING ru
15233: PPUSH
15234: LD_INT 1
15236: PPUSH
15237: CALL_OW 101
15241: GO 15254
// AddMedal ( ru , - 1 ) ;
15243: LD_STRING ru
15245: PPUSH
15246: LD_INT 1
15248: NEG
15249: PPUSH
15250: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 6 then
15254: LD_INT 22
15256: PUSH
15257: LD_INT 1
15259: PUSH
15260: EMPTY
15261: LIST
15262: LIST
15263: PUSH
15264: LD_INT 21
15266: PUSH
15267: LD_INT 1
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PPUSH
15278: CALL_OW 69
15282: PUSH
15283: LD_INT 6
15285: GREATER
15286: IFFALSE 15300
// AddMedal ( pep , 1 ) else
15288: LD_STRING pep
15290: PPUSH
15291: LD_INT 1
15293: PPUSH
15294: CALL_OW 101
15298: GO 15311
// AddMedal ( pep , - 1 ) ;
15300: LD_STRING pep
15302: PPUSH
15303: LD_INT 1
15305: NEG
15306: PPUSH
15307: CALL_OW 101
// GiveMedals ( MAIN ) ;
15311: LD_STRING MAIN
15313: PPUSH
15314: CALL_OW 102
// YouWin ;
15318: CALL_OW 103
// end ; end_of_file
15322: PPOPN 1
15324: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
15325: GO 15327
15327: DISABLE
// begin ru_radar := 98 ;
15328: LD_ADDR_EXP 46
15332: PUSH
15333: LD_INT 98
15335: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
15336: LD_ADDR_EXP 47
15340: PUSH
15341: LD_INT 89
15343: ST_TO_ADDR
// us_hack := 99 ;
15344: LD_ADDR_EXP 48
15348: PUSH
15349: LD_INT 99
15351: ST_TO_ADDR
// us_artillery := 97 ;
15352: LD_ADDR_EXP 49
15356: PUSH
15357: LD_INT 97
15359: ST_TO_ADDR
// ar_bio_bomb := 91 ;
15360: LD_ADDR_EXP 50
15364: PUSH
15365: LD_INT 91
15367: ST_TO_ADDR
// end ; end_of_file end_of_file
15368: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
15369: GO 15371
15371: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
15372: LD_STRING initStreamRollete();
15374: PPUSH
15375: CALL_OW 559
// InitStreamMode ;
15379: CALL 15388 0 0
// DefineStreamItems ( ) ;
15383: CALL 15828 0 0
// end ;
15387: END
// function InitStreamMode ; begin
15388: LD_INT 0
15390: PPUSH
// streamModeActive := false ;
15391: LD_ADDR_EXP 51
15395: PUSH
15396: LD_INT 0
15398: ST_TO_ADDR
// normalCounter := 26 ;
15399: LD_ADDR_EXP 52
15403: PUSH
15404: LD_INT 26
15406: ST_TO_ADDR
// hardcoreCounter := 12 ;
15407: LD_ADDR_EXP 53
15411: PUSH
15412: LD_INT 12
15414: ST_TO_ADDR
// sRocket := false ;
15415: LD_ADDR_EXP 56
15419: PUSH
15420: LD_INT 0
15422: ST_TO_ADDR
// sSpeed := false ;
15423: LD_ADDR_EXP 55
15427: PUSH
15428: LD_INT 0
15430: ST_TO_ADDR
// sEngine := false ;
15431: LD_ADDR_EXP 57
15435: PUSH
15436: LD_INT 0
15438: ST_TO_ADDR
// sSpec := false ;
15439: LD_ADDR_EXP 54
15443: PUSH
15444: LD_INT 0
15446: ST_TO_ADDR
// sLevel := false ;
15447: LD_ADDR_EXP 58
15451: PUSH
15452: LD_INT 0
15454: ST_TO_ADDR
// sArmoury := false ;
15455: LD_ADDR_EXP 59
15459: PUSH
15460: LD_INT 0
15462: ST_TO_ADDR
// sRadar := false ;
15463: LD_ADDR_EXP 60
15467: PUSH
15468: LD_INT 0
15470: ST_TO_ADDR
// sBunker := false ;
15471: LD_ADDR_EXP 61
15475: PUSH
15476: LD_INT 0
15478: ST_TO_ADDR
// sHack := false ;
15479: LD_ADDR_EXP 62
15483: PUSH
15484: LD_INT 0
15486: ST_TO_ADDR
// sFire := false ;
15487: LD_ADDR_EXP 63
15491: PUSH
15492: LD_INT 0
15494: ST_TO_ADDR
// sRefresh := false ;
15495: LD_ADDR_EXP 64
15499: PUSH
15500: LD_INT 0
15502: ST_TO_ADDR
// sExp := false ;
15503: LD_ADDR_EXP 65
15507: PUSH
15508: LD_INT 0
15510: ST_TO_ADDR
// sDepot := false ;
15511: LD_ADDR_EXP 66
15515: PUSH
15516: LD_INT 0
15518: ST_TO_ADDR
// sFlag := false ;
15519: LD_ADDR_EXP 67
15523: PUSH
15524: LD_INT 0
15526: ST_TO_ADDR
// sKamikadze := false ;
15527: LD_ADDR_EXP 75
15531: PUSH
15532: LD_INT 0
15534: ST_TO_ADDR
// sTroll := false ;
15535: LD_ADDR_EXP 76
15539: PUSH
15540: LD_INT 0
15542: ST_TO_ADDR
// sSlow := false ;
15543: LD_ADDR_EXP 77
15547: PUSH
15548: LD_INT 0
15550: ST_TO_ADDR
// sLack := false ;
15551: LD_ADDR_EXP 78
15555: PUSH
15556: LD_INT 0
15558: ST_TO_ADDR
// sTank := false ;
15559: LD_ADDR_EXP 80
15563: PUSH
15564: LD_INT 0
15566: ST_TO_ADDR
// sRemote := false ;
15567: LD_ADDR_EXP 81
15571: PUSH
15572: LD_INT 0
15574: ST_TO_ADDR
// sPowell := false ;
15575: LD_ADDR_EXP 82
15579: PUSH
15580: LD_INT 0
15582: ST_TO_ADDR
// sTeleport := false ;
15583: LD_ADDR_EXP 85
15587: PUSH
15588: LD_INT 0
15590: ST_TO_ADDR
// sOilTower := false ;
15591: LD_ADDR_EXP 87
15595: PUSH
15596: LD_INT 0
15598: ST_TO_ADDR
// sShovel := false ;
15599: LD_ADDR_EXP 88
15603: PUSH
15604: LD_INT 0
15606: ST_TO_ADDR
// sSheik := false ;
15607: LD_ADDR_EXP 89
15611: PUSH
15612: LD_INT 0
15614: ST_TO_ADDR
// sEarthquake := false ;
15615: LD_ADDR_EXP 91
15619: PUSH
15620: LD_INT 0
15622: ST_TO_ADDR
// sAI := false ;
15623: LD_ADDR_EXP 92
15627: PUSH
15628: LD_INT 0
15630: ST_TO_ADDR
// sCargo := false ;
15631: LD_ADDR_EXP 95
15635: PUSH
15636: LD_INT 0
15638: ST_TO_ADDR
// sDLaser := false ;
15639: LD_ADDR_EXP 96
15643: PUSH
15644: LD_INT 0
15646: ST_TO_ADDR
// sExchange := false ;
15647: LD_ADDR_EXP 97
15651: PUSH
15652: LD_INT 0
15654: ST_TO_ADDR
// sFac := false ;
15655: LD_ADDR_EXP 98
15659: PUSH
15660: LD_INT 0
15662: ST_TO_ADDR
// sPower := false ;
15663: LD_ADDR_EXP 99
15667: PUSH
15668: LD_INT 0
15670: ST_TO_ADDR
// sRandom := false ;
15671: LD_ADDR_EXP 100
15675: PUSH
15676: LD_INT 0
15678: ST_TO_ADDR
// sShield := false ;
15679: LD_ADDR_EXP 101
15683: PUSH
15684: LD_INT 0
15686: ST_TO_ADDR
// sTime := false ;
15687: LD_ADDR_EXP 102
15691: PUSH
15692: LD_INT 0
15694: ST_TO_ADDR
// sTools := false ;
15695: LD_ADDR_EXP 103
15699: PUSH
15700: LD_INT 0
15702: ST_TO_ADDR
// sSold := false ;
15703: LD_ADDR_EXP 68
15707: PUSH
15708: LD_INT 0
15710: ST_TO_ADDR
// sDiff := false ;
15711: LD_ADDR_EXP 69
15715: PUSH
15716: LD_INT 0
15718: ST_TO_ADDR
// sFog := false ;
15719: LD_ADDR_EXP 72
15723: PUSH
15724: LD_INT 0
15726: ST_TO_ADDR
// sReset := false ;
15727: LD_ADDR_EXP 73
15731: PUSH
15732: LD_INT 0
15734: ST_TO_ADDR
// sSun := false ;
15735: LD_ADDR_EXP 74
15739: PUSH
15740: LD_INT 0
15742: ST_TO_ADDR
// sTiger := false ;
15743: LD_ADDR_EXP 70
15747: PUSH
15748: LD_INT 0
15750: ST_TO_ADDR
// sBomb := false ;
15751: LD_ADDR_EXP 71
15755: PUSH
15756: LD_INT 0
15758: ST_TO_ADDR
// sWound := false ;
15759: LD_ADDR_EXP 79
15763: PUSH
15764: LD_INT 0
15766: ST_TO_ADDR
// sBetray := false ;
15767: LD_ADDR_EXP 83
15771: PUSH
15772: LD_INT 0
15774: ST_TO_ADDR
// sContamin := false ;
15775: LD_ADDR_EXP 84
15779: PUSH
15780: LD_INT 0
15782: ST_TO_ADDR
// sOil := false ;
15783: LD_ADDR_EXP 86
15787: PUSH
15788: LD_INT 0
15790: ST_TO_ADDR
// sStu := false ;
15791: LD_ADDR_EXP 90
15795: PUSH
15796: LD_INT 0
15798: ST_TO_ADDR
// sBazooka := false ;
15799: LD_ADDR_EXP 93
15803: PUSH
15804: LD_INT 0
15806: ST_TO_ADDR
// sMortar := false ;
15807: LD_ADDR_EXP 94
15811: PUSH
15812: LD_INT 0
15814: ST_TO_ADDR
// sRanger := false ;
15815: LD_ADDR_EXP 104
15819: PUSH
15820: LD_INT 0
15822: ST_TO_ADDR
// end ;
15823: LD_VAR 0 1
15827: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
15828: LD_INT 0
15830: PPUSH
15831: PPUSH
15832: PPUSH
15833: PPUSH
15834: PPUSH
// result := [ ] ;
15835: LD_ADDR_VAR 0 1
15839: PUSH
15840: EMPTY
15841: ST_TO_ADDR
// if campaign_id = 1 then
15842: LD_OWVAR 69
15846: PUSH
15847: LD_INT 1
15849: EQUAL
15850: IFFALSE 18786
// begin case mission_number of 1 :
15852: LD_OWVAR 70
15856: PUSH
15857: LD_INT 1
15859: DOUBLE
15860: EQUAL
15861: IFTRUE 15865
15863: GO 15929
15865: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_INT 2
15873: PUSH
15874: LD_INT 4
15876: PUSH
15877: LD_INT 11
15879: PUSH
15880: LD_INT 12
15882: PUSH
15883: LD_INT 15
15885: PUSH
15886: LD_INT 16
15888: PUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 23
15894: PUSH
15895: LD_INT 26
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 101
15911: PUSH
15912: LD_INT 102
15914: PUSH
15915: LD_INT 106
15917: PUSH
15918: EMPTY
15919: LIST
15920: LIST
15921: LIST
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: ST_TO_ADDR
15927: GO 18786
15929: LD_INT 2
15931: DOUBLE
15932: EQUAL
15933: IFTRUE 15937
15935: GO 16009
15937: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
15938: LD_ADDR_VAR 0 1
15942: PUSH
15943: LD_INT 2
15945: PUSH
15946: LD_INT 4
15948: PUSH
15949: LD_INT 11
15951: PUSH
15952: LD_INT 12
15954: PUSH
15955: LD_INT 15
15957: PUSH
15958: LD_INT 16
15960: PUSH
15961: LD_INT 22
15963: PUSH
15964: LD_INT 23
15966: PUSH
15967: LD_INT 26
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: PUSH
15981: LD_INT 101
15983: PUSH
15984: LD_INT 102
15986: PUSH
15987: LD_INT 105
15989: PUSH
15990: LD_INT 106
15992: PUSH
15993: LD_INT 108
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: PUSH
16003: EMPTY
16004: LIST
16005: LIST
16006: ST_TO_ADDR
16007: GO 18786
16009: LD_INT 3
16011: DOUBLE
16012: EQUAL
16013: IFTRUE 16017
16015: GO 16093
16017: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
16018: LD_ADDR_VAR 0 1
16022: PUSH
16023: LD_INT 2
16025: PUSH
16026: LD_INT 4
16028: PUSH
16029: LD_INT 5
16031: PUSH
16032: LD_INT 11
16034: PUSH
16035: LD_INT 12
16037: PUSH
16038: LD_INT 15
16040: PUSH
16041: LD_INT 16
16043: PUSH
16044: LD_INT 22
16046: PUSH
16047: LD_INT 26
16049: PUSH
16050: LD_INT 36
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: LIST
16057: LIST
16058: LIST
16059: LIST
16060: LIST
16061: LIST
16062: LIST
16063: LIST
16064: PUSH
16065: LD_INT 101
16067: PUSH
16068: LD_INT 102
16070: PUSH
16071: LD_INT 105
16073: PUSH
16074: LD_INT 106
16076: PUSH
16077: LD_INT 108
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: ST_TO_ADDR
16091: GO 18786
16093: LD_INT 4
16095: DOUBLE
16096: EQUAL
16097: IFTRUE 16101
16099: GO 16185
16101: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
16102: LD_ADDR_VAR 0 1
16106: PUSH
16107: LD_INT 2
16109: PUSH
16110: LD_INT 4
16112: PUSH
16113: LD_INT 5
16115: PUSH
16116: LD_INT 8
16118: PUSH
16119: LD_INT 11
16121: PUSH
16122: LD_INT 12
16124: PUSH
16125: LD_INT 15
16127: PUSH
16128: LD_INT 16
16130: PUSH
16131: LD_INT 22
16133: PUSH
16134: LD_INT 23
16136: PUSH
16137: LD_INT 26
16139: PUSH
16140: LD_INT 36
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: LIST
16150: LIST
16151: LIST
16152: LIST
16153: LIST
16154: LIST
16155: LIST
16156: PUSH
16157: LD_INT 101
16159: PUSH
16160: LD_INT 102
16162: PUSH
16163: LD_INT 105
16165: PUSH
16166: LD_INT 106
16168: PUSH
16169: LD_INT 108
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: PUSH
16179: EMPTY
16180: LIST
16181: LIST
16182: ST_TO_ADDR
16183: GO 18786
16185: LD_INT 5
16187: DOUBLE
16188: EQUAL
16189: IFTRUE 16193
16191: GO 16293
16193: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
16194: LD_ADDR_VAR 0 1
16198: PUSH
16199: LD_INT 2
16201: PUSH
16202: LD_INT 4
16204: PUSH
16205: LD_INT 5
16207: PUSH
16208: LD_INT 6
16210: PUSH
16211: LD_INT 8
16213: PUSH
16214: LD_INT 11
16216: PUSH
16217: LD_INT 12
16219: PUSH
16220: LD_INT 15
16222: PUSH
16223: LD_INT 16
16225: PUSH
16226: LD_INT 22
16228: PUSH
16229: LD_INT 23
16231: PUSH
16232: LD_INT 25
16234: PUSH
16235: LD_INT 26
16237: PUSH
16238: LD_INT 36
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: PUSH
16257: LD_INT 101
16259: PUSH
16260: LD_INT 102
16262: PUSH
16263: LD_INT 105
16265: PUSH
16266: LD_INT 106
16268: PUSH
16269: LD_INT 108
16271: PUSH
16272: LD_INT 109
16274: PUSH
16275: LD_INT 112
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: ST_TO_ADDR
16291: GO 18786
16293: LD_INT 6
16295: DOUBLE
16296: EQUAL
16297: IFTRUE 16301
16299: GO 16421
16301: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
16302: LD_ADDR_VAR 0 1
16306: PUSH
16307: LD_INT 2
16309: PUSH
16310: LD_INT 4
16312: PUSH
16313: LD_INT 5
16315: PUSH
16316: LD_INT 6
16318: PUSH
16319: LD_INT 8
16321: PUSH
16322: LD_INT 11
16324: PUSH
16325: LD_INT 12
16327: PUSH
16328: LD_INT 15
16330: PUSH
16331: LD_INT 16
16333: PUSH
16334: LD_INT 20
16336: PUSH
16337: LD_INT 21
16339: PUSH
16340: LD_INT 22
16342: PUSH
16343: LD_INT 23
16345: PUSH
16346: LD_INT 25
16348: PUSH
16349: LD_INT 26
16351: PUSH
16352: LD_INT 30
16354: PUSH
16355: LD_INT 31
16357: PUSH
16358: LD_INT 32
16360: PUSH
16361: LD_INT 36
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: LIST
16377: LIST
16378: LIST
16379: LIST
16380: LIST
16381: LIST
16382: LIST
16383: LIST
16384: PUSH
16385: LD_INT 101
16387: PUSH
16388: LD_INT 102
16390: PUSH
16391: LD_INT 105
16393: PUSH
16394: LD_INT 106
16396: PUSH
16397: LD_INT 108
16399: PUSH
16400: LD_INT 109
16402: PUSH
16403: LD_INT 112
16405: PUSH
16406: EMPTY
16407: LIST
16408: LIST
16409: LIST
16410: LIST
16411: LIST
16412: LIST
16413: LIST
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: ST_TO_ADDR
16419: GO 18786
16421: LD_INT 7
16423: DOUBLE
16424: EQUAL
16425: IFTRUE 16429
16427: GO 16529
16429: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
16430: LD_ADDR_VAR 0 1
16434: PUSH
16435: LD_INT 2
16437: PUSH
16438: LD_INT 4
16440: PUSH
16441: LD_INT 5
16443: PUSH
16444: LD_INT 7
16446: PUSH
16447: LD_INT 11
16449: PUSH
16450: LD_INT 12
16452: PUSH
16453: LD_INT 15
16455: PUSH
16456: LD_INT 16
16458: PUSH
16459: LD_INT 20
16461: PUSH
16462: LD_INT 21
16464: PUSH
16465: LD_INT 22
16467: PUSH
16468: LD_INT 23
16470: PUSH
16471: LD_INT 25
16473: PUSH
16474: LD_INT 26
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: LIST
16481: LIST
16482: LIST
16483: LIST
16484: LIST
16485: LIST
16486: LIST
16487: LIST
16488: LIST
16489: LIST
16490: LIST
16491: LIST
16492: PUSH
16493: LD_INT 101
16495: PUSH
16496: LD_INT 102
16498: PUSH
16499: LD_INT 103
16501: PUSH
16502: LD_INT 105
16504: PUSH
16505: LD_INT 106
16507: PUSH
16508: LD_INT 108
16510: PUSH
16511: LD_INT 112
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: LIST
16521: LIST
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: ST_TO_ADDR
16527: GO 18786
16529: LD_INT 8
16531: DOUBLE
16532: EQUAL
16533: IFTRUE 16537
16535: GO 16665
16537: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
16538: LD_ADDR_VAR 0 1
16542: PUSH
16543: LD_INT 2
16545: PUSH
16546: LD_INT 4
16548: PUSH
16549: LD_INT 5
16551: PUSH
16552: LD_INT 6
16554: PUSH
16555: LD_INT 7
16557: PUSH
16558: LD_INT 8
16560: PUSH
16561: LD_INT 11
16563: PUSH
16564: LD_INT 12
16566: PUSH
16567: LD_INT 15
16569: PUSH
16570: LD_INT 16
16572: PUSH
16573: LD_INT 20
16575: PUSH
16576: LD_INT 21
16578: PUSH
16579: LD_INT 22
16581: PUSH
16582: LD_INT 23
16584: PUSH
16585: LD_INT 25
16587: PUSH
16588: LD_INT 26
16590: PUSH
16591: LD_INT 30
16593: PUSH
16594: LD_INT 31
16596: PUSH
16597: LD_INT 32
16599: PUSH
16600: LD_INT 36
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: LIST
16610: LIST
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: LIST
16621: LIST
16622: LIST
16623: LIST
16624: PUSH
16625: LD_INT 101
16627: PUSH
16628: LD_INT 102
16630: PUSH
16631: LD_INT 103
16633: PUSH
16634: LD_INT 105
16636: PUSH
16637: LD_INT 106
16639: PUSH
16640: LD_INT 108
16642: PUSH
16643: LD_INT 109
16645: PUSH
16646: LD_INT 112
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: LIST
16653: LIST
16654: LIST
16655: LIST
16656: LIST
16657: LIST
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: ST_TO_ADDR
16663: GO 18786
16665: LD_INT 9
16667: DOUBLE
16668: EQUAL
16669: IFTRUE 16673
16671: GO 16809
16673: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
16674: LD_ADDR_VAR 0 1
16678: PUSH
16679: LD_INT 2
16681: PUSH
16682: LD_INT 4
16684: PUSH
16685: LD_INT 5
16687: PUSH
16688: LD_INT 6
16690: PUSH
16691: LD_INT 7
16693: PUSH
16694: LD_INT 8
16696: PUSH
16697: LD_INT 11
16699: PUSH
16700: LD_INT 12
16702: PUSH
16703: LD_INT 15
16705: PUSH
16706: LD_INT 16
16708: PUSH
16709: LD_INT 20
16711: PUSH
16712: LD_INT 21
16714: PUSH
16715: LD_INT 22
16717: PUSH
16718: LD_INT 23
16720: PUSH
16721: LD_INT 25
16723: PUSH
16724: LD_INT 26
16726: PUSH
16727: LD_INT 28
16729: PUSH
16730: LD_INT 30
16732: PUSH
16733: LD_INT 31
16735: PUSH
16736: LD_INT 32
16738: PUSH
16739: LD_INT 36
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: LIST
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: PUSH
16765: LD_INT 101
16767: PUSH
16768: LD_INT 102
16770: PUSH
16771: LD_INT 103
16773: PUSH
16774: LD_INT 105
16776: PUSH
16777: LD_INT 106
16779: PUSH
16780: LD_INT 108
16782: PUSH
16783: LD_INT 109
16785: PUSH
16786: LD_INT 112
16788: PUSH
16789: LD_INT 114
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: LIST
16796: LIST
16797: LIST
16798: LIST
16799: LIST
16800: LIST
16801: LIST
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: ST_TO_ADDR
16807: GO 18786
16809: LD_INT 10
16811: DOUBLE
16812: EQUAL
16813: IFTRUE 16817
16815: GO 17001
16817: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
16818: LD_ADDR_VAR 0 1
16822: PUSH
16823: LD_INT 2
16825: PUSH
16826: LD_INT 4
16828: PUSH
16829: LD_INT 5
16831: PUSH
16832: LD_INT 6
16834: PUSH
16835: LD_INT 7
16837: PUSH
16838: LD_INT 8
16840: PUSH
16841: LD_INT 9
16843: PUSH
16844: LD_INT 10
16846: PUSH
16847: LD_INT 11
16849: PUSH
16850: LD_INT 12
16852: PUSH
16853: LD_INT 13
16855: PUSH
16856: LD_INT 14
16858: PUSH
16859: LD_INT 15
16861: PUSH
16862: LD_INT 16
16864: PUSH
16865: LD_INT 17
16867: PUSH
16868: LD_INT 18
16870: PUSH
16871: LD_INT 19
16873: PUSH
16874: LD_INT 20
16876: PUSH
16877: LD_INT 21
16879: PUSH
16880: LD_INT 22
16882: PUSH
16883: LD_INT 23
16885: PUSH
16886: LD_INT 24
16888: PUSH
16889: LD_INT 25
16891: PUSH
16892: LD_INT 26
16894: PUSH
16895: LD_INT 28
16897: PUSH
16898: LD_INT 30
16900: PUSH
16901: LD_INT 31
16903: PUSH
16904: LD_INT 32
16906: PUSH
16907: LD_INT 36
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 101
16943: PUSH
16944: LD_INT 102
16946: PUSH
16947: LD_INT 103
16949: PUSH
16950: LD_INT 104
16952: PUSH
16953: LD_INT 105
16955: PUSH
16956: LD_INT 106
16958: PUSH
16959: LD_INT 107
16961: PUSH
16962: LD_INT 108
16964: PUSH
16965: LD_INT 109
16967: PUSH
16968: LD_INT 110
16970: PUSH
16971: LD_INT 111
16973: PUSH
16974: LD_INT 112
16976: PUSH
16977: LD_INT 114
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: ST_TO_ADDR
16999: GO 18786
17001: LD_INT 11
17003: DOUBLE
17004: EQUAL
17005: IFTRUE 17009
17007: GO 17201
17009: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
17010: LD_ADDR_VAR 0 1
17014: PUSH
17015: LD_INT 2
17017: PUSH
17018: LD_INT 3
17020: PUSH
17021: LD_INT 4
17023: PUSH
17024: LD_INT 5
17026: PUSH
17027: LD_INT 6
17029: PUSH
17030: LD_INT 7
17032: PUSH
17033: LD_INT 8
17035: PUSH
17036: LD_INT 9
17038: PUSH
17039: LD_INT 10
17041: PUSH
17042: LD_INT 11
17044: PUSH
17045: LD_INT 12
17047: PUSH
17048: LD_INT 13
17050: PUSH
17051: LD_INT 14
17053: PUSH
17054: LD_INT 15
17056: PUSH
17057: LD_INT 16
17059: PUSH
17060: LD_INT 17
17062: PUSH
17063: LD_INT 18
17065: PUSH
17066: LD_INT 19
17068: PUSH
17069: LD_INT 20
17071: PUSH
17072: LD_INT 21
17074: PUSH
17075: LD_INT 22
17077: PUSH
17078: LD_INT 23
17080: PUSH
17081: LD_INT 24
17083: PUSH
17084: LD_INT 25
17086: PUSH
17087: LD_INT 26
17089: PUSH
17090: LD_INT 28
17092: PUSH
17093: LD_INT 30
17095: PUSH
17096: LD_INT 31
17098: PUSH
17099: LD_INT 32
17101: PUSH
17102: LD_INT 34
17104: PUSH
17105: LD_INT 36
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: LIST
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: PUSH
17141: LD_INT 101
17143: PUSH
17144: LD_INT 102
17146: PUSH
17147: LD_INT 103
17149: PUSH
17150: LD_INT 104
17152: PUSH
17153: LD_INT 105
17155: PUSH
17156: LD_INT 106
17158: PUSH
17159: LD_INT 107
17161: PUSH
17162: LD_INT 108
17164: PUSH
17165: LD_INT 109
17167: PUSH
17168: LD_INT 110
17170: PUSH
17171: LD_INT 111
17173: PUSH
17174: LD_INT 112
17176: PUSH
17177: LD_INT 114
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: ST_TO_ADDR
17199: GO 18786
17201: LD_INT 12
17203: DOUBLE
17204: EQUAL
17205: IFTRUE 17209
17207: GO 17417
17209: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_INT 1
17217: PUSH
17218: LD_INT 2
17220: PUSH
17221: LD_INT 3
17223: PUSH
17224: LD_INT 4
17226: PUSH
17227: LD_INT 5
17229: PUSH
17230: LD_INT 6
17232: PUSH
17233: LD_INT 7
17235: PUSH
17236: LD_INT 8
17238: PUSH
17239: LD_INT 9
17241: PUSH
17242: LD_INT 10
17244: PUSH
17245: LD_INT 11
17247: PUSH
17248: LD_INT 12
17250: PUSH
17251: LD_INT 13
17253: PUSH
17254: LD_INT 14
17256: PUSH
17257: LD_INT 15
17259: PUSH
17260: LD_INT 16
17262: PUSH
17263: LD_INT 17
17265: PUSH
17266: LD_INT 18
17268: PUSH
17269: LD_INT 19
17271: PUSH
17272: LD_INT 20
17274: PUSH
17275: LD_INT 21
17277: PUSH
17278: LD_INT 22
17280: PUSH
17281: LD_INT 23
17283: PUSH
17284: LD_INT 24
17286: PUSH
17287: LD_INT 25
17289: PUSH
17290: LD_INT 26
17292: PUSH
17293: LD_INT 27
17295: PUSH
17296: LD_INT 28
17298: PUSH
17299: LD_INT 30
17301: PUSH
17302: LD_INT 31
17304: PUSH
17305: LD_INT 32
17307: PUSH
17308: LD_INT 33
17310: PUSH
17311: LD_INT 34
17313: PUSH
17314: LD_INT 36
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: LIST
17326: LIST
17327: LIST
17328: LIST
17329: LIST
17330: LIST
17331: LIST
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: LIST
17350: LIST
17351: LIST
17352: PUSH
17353: LD_INT 101
17355: PUSH
17356: LD_INT 102
17358: PUSH
17359: LD_INT 103
17361: PUSH
17362: LD_INT 104
17364: PUSH
17365: LD_INT 105
17367: PUSH
17368: LD_INT 106
17370: PUSH
17371: LD_INT 107
17373: PUSH
17374: LD_INT 108
17376: PUSH
17377: LD_INT 109
17379: PUSH
17380: LD_INT 110
17382: PUSH
17383: LD_INT 111
17385: PUSH
17386: LD_INT 112
17388: PUSH
17389: LD_INT 113
17391: PUSH
17392: LD_INT 114
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: LIST
17406: LIST
17407: LIST
17408: LIST
17409: LIST
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: ST_TO_ADDR
17415: GO 18786
17417: LD_INT 13
17419: DOUBLE
17420: EQUAL
17421: IFTRUE 17425
17423: GO 17621
17425: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
17426: LD_ADDR_VAR 0 1
17430: PUSH
17431: LD_INT 1
17433: PUSH
17434: LD_INT 2
17436: PUSH
17437: LD_INT 3
17439: PUSH
17440: LD_INT 4
17442: PUSH
17443: LD_INT 5
17445: PUSH
17446: LD_INT 8
17448: PUSH
17449: LD_INT 9
17451: PUSH
17452: LD_INT 10
17454: PUSH
17455: LD_INT 11
17457: PUSH
17458: LD_INT 12
17460: PUSH
17461: LD_INT 14
17463: PUSH
17464: LD_INT 15
17466: PUSH
17467: LD_INT 16
17469: PUSH
17470: LD_INT 17
17472: PUSH
17473: LD_INT 18
17475: PUSH
17476: LD_INT 19
17478: PUSH
17479: LD_INT 20
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 22
17487: PUSH
17488: LD_INT 23
17490: PUSH
17491: LD_INT 24
17493: PUSH
17494: LD_INT 25
17496: PUSH
17497: LD_INT 26
17499: PUSH
17500: LD_INT 27
17502: PUSH
17503: LD_INT 28
17505: PUSH
17506: LD_INT 30
17508: PUSH
17509: LD_INT 31
17511: PUSH
17512: LD_INT 32
17514: PUSH
17515: LD_INT 33
17517: PUSH
17518: LD_INT 34
17520: PUSH
17521: LD_INT 36
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: LIST
17534: LIST
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: LIST
17547: LIST
17548: LIST
17549: LIST
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: LIST
17555: LIST
17556: PUSH
17557: LD_INT 101
17559: PUSH
17560: LD_INT 102
17562: PUSH
17563: LD_INT 103
17565: PUSH
17566: LD_INT 104
17568: PUSH
17569: LD_INT 105
17571: PUSH
17572: LD_INT 106
17574: PUSH
17575: LD_INT 107
17577: PUSH
17578: LD_INT 108
17580: PUSH
17581: LD_INT 109
17583: PUSH
17584: LD_INT 110
17586: PUSH
17587: LD_INT 111
17589: PUSH
17590: LD_INT 112
17592: PUSH
17593: LD_INT 113
17595: PUSH
17596: LD_INT 114
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: LIST
17613: LIST
17614: PUSH
17615: EMPTY
17616: LIST
17617: LIST
17618: ST_TO_ADDR
17619: GO 18786
17621: LD_INT 14
17623: DOUBLE
17624: EQUAL
17625: IFTRUE 17629
17627: GO 17841
17629: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
17630: LD_ADDR_VAR 0 1
17634: PUSH
17635: LD_INT 1
17637: PUSH
17638: LD_INT 2
17640: PUSH
17641: LD_INT 3
17643: PUSH
17644: LD_INT 4
17646: PUSH
17647: LD_INT 5
17649: PUSH
17650: LD_INT 6
17652: PUSH
17653: LD_INT 7
17655: PUSH
17656: LD_INT 8
17658: PUSH
17659: LD_INT 9
17661: PUSH
17662: LD_INT 10
17664: PUSH
17665: LD_INT 11
17667: PUSH
17668: LD_INT 12
17670: PUSH
17671: LD_INT 13
17673: PUSH
17674: LD_INT 14
17676: PUSH
17677: LD_INT 15
17679: PUSH
17680: LD_INT 16
17682: PUSH
17683: LD_INT 17
17685: PUSH
17686: LD_INT 18
17688: PUSH
17689: LD_INT 19
17691: PUSH
17692: LD_INT 20
17694: PUSH
17695: LD_INT 21
17697: PUSH
17698: LD_INT 22
17700: PUSH
17701: LD_INT 23
17703: PUSH
17704: LD_INT 24
17706: PUSH
17707: LD_INT 25
17709: PUSH
17710: LD_INT 26
17712: PUSH
17713: LD_INT 27
17715: PUSH
17716: LD_INT 28
17718: PUSH
17719: LD_INT 29
17721: PUSH
17722: LD_INT 30
17724: PUSH
17725: LD_INT 31
17727: PUSH
17728: LD_INT 32
17730: PUSH
17731: LD_INT 33
17733: PUSH
17734: LD_INT 34
17736: PUSH
17737: LD_INT 36
17739: PUSH
17740: EMPTY
17741: LIST
17742: LIST
17743: LIST
17744: LIST
17745: LIST
17746: LIST
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: LIST
17752: LIST
17753: LIST
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: PUSH
17777: LD_INT 101
17779: PUSH
17780: LD_INT 102
17782: PUSH
17783: LD_INT 103
17785: PUSH
17786: LD_INT 104
17788: PUSH
17789: LD_INT 105
17791: PUSH
17792: LD_INT 106
17794: PUSH
17795: LD_INT 107
17797: PUSH
17798: LD_INT 108
17800: PUSH
17801: LD_INT 109
17803: PUSH
17804: LD_INT 110
17806: PUSH
17807: LD_INT 111
17809: PUSH
17810: LD_INT 112
17812: PUSH
17813: LD_INT 113
17815: PUSH
17816: LD_INT 114
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: ST_TO_ADDR
17839: GO 18786
17841: LD_INT 15
17843: DOUBLE
17844: EQUAL
17845: IFTRUE 17849
17847: GO 18061
17849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
17850: LD_ADDR_VAR 0 1
17854: PUSH
17855: LD_INT 1
17857: PUSH
17858: LD_INT 2
17860: PUSH
17861: LD_INT 3
17863: PUSH
17864: LD_INT 4
17866: PUSH
17867: LD_INT 5
17869: PUSH
17870: LD_INT 6
17872: PUSH
17873: LD_INT 7
17875: PUSH
17876: LD_INT 8
17878: PUSH
17879: LD_INT 9
17881: PUSH
17882: LD_INT 10
17884: PUSH
17885: LD_INT 11
17887: PUSH
17888: LD_INT 12
17890: PUSH
17891: LD_INT 13
17893: PUSH
17894: LD_INT 14
17896: PUSH
17897: LD_INT 15
17899: PUSH
17900: LD_INT 16
17902: PUSH
17903: LD_INT 17
17905: PUSH
17906: LD_INT 18
17908: PUSH
17909: LD_INT 19
17911: PUSH
17912: LD_INT 20
17914: PUSH
17915: LD_INT 21
17917: PUSH
17918: LD_INT 22
17920: PUSH
17921: LD_INT 23
17923: PUSH
17924: LD_INT 24
17926: PUSH
17927: LD_INT 25
17929: PUSH
17930: LD_INT 26
17932: PUSH
17933: LD_INT 27
17935: PUSH
17936: LD_INT 28
17938: PUSH
17939: LD_INT 29
17941: PUSH
17942: LD_INT 30
17944: PUSH
17945: LD_INT 31
17947: PUSH
17948: LD_INT 32
17950: PUSH
17951: LD_INT 33
17953: PUSH
17954: LD_INT 34
17956: PUSH
17957: LD_INT 36
17959: PUSH
17960: EMPTY
17961: LIST
17962: LIST
17963: LIST
17964: LIST
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: LIST
17981: LIST
17982: LIST
17983: LIST
17984: LIST
17985: LIST
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: PUSH
17997: LD_INT 101
17999: PUSH
18000: LD_INT 102
18002: PUSH
18003: LD_INT 103
18005: PUSH
18006: LD_INT 104
18008: PUSH
18009: LD_INT 105
18011: PUSH
18012: LD_INT 106
18014: PUSH
18015: LD_INT 107
18017: PUSH
18018: LD_INT 108
18020: PUSH
18021: LD_INT 109
18023: PUSH
18024: LD_INT 110
18026: PUSH
18027: LD_INT 111
18029: PUSH
18030: LD_INT 112
18032: PUSH
18033: LD_INT 113
18035: PUSH
18036: LD_INT 114
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: ST_TO_ADDR
18059: GO 18786
18061: LD_INT 16
18063: DOUBLE
18064: EQUAL
18065: IFTRUE 18069
18067: GO 18193
18069: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
18070: LD_ADDR_VAR 0 1
18074: PUSH
18075: LD_INT 2
18077: PUSH
18078: LD_INT 4
18080: PUSH
18081: LD_INT 5
18083: PUSH
18084: LD_INT 7
18086: PUSH
18087: LD_INT 11
18089: PUSH
18090: LD_INT 12
18092: PUSH
18093: LD_INT 15
18095: PUSH
18096: LD_INT 16
18098: PUSH
18099: LD_INT 20
18101: PUSH
18102: LD_INT 21
18104: PUSH
18105: LD_INT 22
18107: PUSH
18108: LD_INT 23
18110: PUSH
18111: LD_INT 25
18113: PUSH
18114: LD_INT 26
18116: PUSH
18117: LD_INT 30
18119: PUSH
18120: LD_INT 31
18122: PUSH
18123: LD_INT 32
18125: PUSH
18126: LD_INT 33
18128: PUSH
18129: LD_INT 34
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: LIST
18138: LIST
18139: LIST
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: LIST
18145: LIST
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: LIST
18151: LIST
18152: PUSH
18153: LD_INT 101
18155: PUSH
18156: LD_INT 102
18158: PUSH
18159: LD_INT 103
18161: PUSH
18162: LD_INT 106
18164: PUSH
18165: LD_INT 108
18167: PUSH
18168: LD_INT 112
18170: PUSH
18171: LD_INT 113
18173: PUSH
18174: LD_INT 114
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: LIST
18183: LIST
18184: LIST
18185: LIST
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: ST_TO_ADDR
18191: GO 18786
18193: LD_INT 17
18195: DOUBLE
18196: EQUAL
18197: IFTRUE 18201
18199: GO 18413
18201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
18202: LD_ADDR_VAR 0 1
18206: PUSH
18207: LD_INT 1
18209: PUSH
18210: LD_INT 2
18212: PUSH
18213: LD_INT 3
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: LD_INT 5
18221: PUSH
18222: LD_INT 6
18224: PUSH
18225: LD_INT 7
18227: PUSH
18228: LD_INT 8
18230: PUSH
18231: LD_INT 9
18233: PUSH
18234: LD_INT 10
18236: PUSH
18237: LD_INT 11
18239: PUSH
18240: LD_INT 12
18242: PUSH
18243: LD_INT 13
18245: PUSH
18246: LD_INT 14
18248: PUSH
18249: LD_INT 15
18251: PUSH
18252: LD_INT 16
18254: PUSH
18255: LD_INT 17
18257: PUSH
18258: LD_INT 18
18260: PUSH
18261: LD_INT 19
18263: PUSH
18264: LD_INT 20
18266: PUSH
18267: LD_INT 21
18269: PUSH
18270: LD_INT 22
18272: PUSH
18273: LD_INT 23
18275: PUSH
18276: LD_INT 24
18278: PUSH
18279: LD_INT 25
18281: PUSH
18282: LD_INT 26
18284: PUSH
18285: LD_INT 27
18287: PUSH
18288: LD_INT 28
18290: PUSH
18291: LD_INT 29
18293: PUSH
18294: LD_INT 30
18296: PUSH
18297: LD_INT 31
18299: PUSH
18300: LD_INT 32
18302: PUSH
18303: LD_INT 33
18305: PUSH
18306: LD_INT 34
18308: PUSH
18309: LD_INT 36
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: LIST
18330: LIST
18331: LIST
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 101
18351: PUSH
18352: LD_INT 102
18354: PUSH
18355: LD_INT 103
18357: PUSH
18358: LD_INT 104
18360: PUSH
18361: LD_INT 105
18363: PUSH
18364: LD_INT 106
18366: PUSH
18367: LD_INT 107
18369: PUSH
18370: LD_INT 108
18372: PUSH
18373: LD_INT 109
18375: PUSH
18376: LD_INT 110
18378: PUSH
18379: LD_INT 111
18381: PUSH
18382: LD_INT 112
18384: PUSH
18385: LD_INT 113
18387: PUSH
18388: LD_INT 114
18390: PUSH
18391: EMPTY
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: LIST
18405: LIST
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: ST_TO_ADDR
18411: GO 18786
18413: LD_INT 18
18415: DOUBLE
18416: EQUAL
18417: IFTRUE 18421
18419: GO 18557
18421: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
18422: LD_ADDR_VAR 0 1
18426: PUSH
18427: LD_INT 2
18429: PUSH
18430: LD_INT 4
18432: PUSH
18433: LD_INT 5
18435: PUSH
18436: LD_INT 7
18438: PUSH
18439: LD_INT 11
18441: PUSH
18442: LD_INT 12
18444: PUSH
18445: LD_INT 15
18447: PUSH
18448: LD_INT 16
18450: PUSH
18451: LD_INT 20
18453: PUSH
18454: LD_INT 21
18456: PUSH
18457: LD_INT 22
18459: PUSH
18460: LD_INT 23
18462: PUSH
18463: LD_INT 25
18465: PUSH
18466: LD_INT 26
18468: PUSH
18469: LD_INT 30
18471: PUSH
18472: LD_INT 31
18474: PUSH
18475: LD_INT 32
18477: PUSH
18478: LD_INT 33
18480: PUSH
18481: LD_INT 34
18483: PUSH
18484: LD_INT 35
18486: PUSH
18487: LD_INT 36
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: LIST
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: PUSH
18513: LD_INT 101
18515: PUSH
18516: LD_INT 102
18518: PUSH
18519: LD_INT 103
18521: PUSH
18522: LD_INT 106
18524: PUSH
18525: LD_INT 108
18527: PUSH
18528: LD_INT 112
18530: PUSH
18531: LD_INT 113
18533: PUSH
18534: LD_INT 114
18536: PUSH
18537: LD_INT 115
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: LIST
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: ST_TO_ADDR
18555: GO 18786
18557: LD_INT 19
18559: DOUBLE
18560: EQUAL
18561: IFTRUE 18565
18563: GO 18785
18565: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_INT 1
18573: PUSH
18574: LD_INT 2
18576: PUSH
18577: LD_INT 3
18579: PUSH
18580: LD_INT 4
18582: PUSH
18583: LD_INT 5
18585: PUSH
18586: LD_INT 6
18588: PUSH
18589: LD_INT 7
18591: PUSH
18592: LD_INT 8
18594: PUSH
18595: LD_INT 9
18597: PUSH
18598: LD_INT 10
18600: PUSH
18601: LD_INT 11
18603: PUSH
18604: LD_INT 12
18606: PUSH
18607: LD_INT 13
18609: PUSH
18610: LD_INT 14
18612: PUSH
18613: LD_INT 15
18615: PUSH
18616: LD_INT 16
18618: PUSH
18619: LD_INT 17
18621: PUSH
18622: LD_INT 18
18624: PUSH
18625: LD_INT 19
18627: PUSH
18628: LD_INT 20
18630: PUSH
18631: LD_INT 21
18633: PUSH
18634: LD_INT 22
18636: PUSH
18637: LD_INT 23
18639: PUSH
18640: LD_INT 24
18642: PUSH
18643: LD_INT 25
18645: PUSH
18646: LD_INT 26
18648: PUSH
18649: LD_INT 27
18651: PUSH
18652: LD_INT 28
18654: PUSH
18655: LD_INT 29
18657: PUSH
18658: LD_INT 30
18660: PUSH
18661: LD_INT 31
18663: PUSH
18664: LD_INT 32
18666: PUSH
18667: LD_INT 33
18669: PUSH
18670: LD_INT 34
18672: PUSH
18673: LD_INT 35
18675: PUSH
18676: LD_INT 36
18678: PUSH
18679: EMPTY
18680: LIST
18681: LIST
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: LIST
18701: LIST
18702: LIST
18703: LIST
18704: LIST
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: LIST
18715: LIST
18716: PUSH
18717: LD_INT 101
18719: PUSH
18720: LD_INT 102
18722: PUSH
18723: LD_INT 103
18725: PUSH
18726: LD_INT 104
18728: PUSH
18729: LD_INT 105
18731: PUSH
18732: LD_INT 106
18734: PUSH
18735: LD_INT 107
18737: PUSH
18738: LD_INT 108
18740: PUSH
18741: LD_INT 109
18743: PUSH
18744: LD_INT 110
18746: PUSH
18747: LD_INT 111
18749: PUSH
18750: LD_INT 112
18752: PUSH
18753: LD_INT 113
18755: PUSH
18756: LD_INT 114
18758: PUSH
18759: LD_INT 115
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: LIST
18775: LIST
18776: LIST
18777: LIST
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: ST_TO_ADDR
18783: GO 18786
18785: POP
// end ; if result then
18786: LD_VAR 0 1
18790: IFFALSE 19079
// begin normal :=  ;
18792: LD_ADDR_VAR 0 3
18796: PUSH
18797: LD_STRING 
18799: ST_TO_ADDR
// hardcore :=  ;
18800: LD_ADDR_VAR 0 4
18804: PUSH
18805: LD_STRING 
18807: ST_TO_ADDR
// for i = 1 to normalCounter do
18808: LD_ADDR_VAR 0 5
18812: PUSH
18813: DOUBLE
18814: LD_INT 1
18816: DEC
18817: ST_TO_ADDR
18818: LD_EXP 52
18822: PUSH
18823: FOR_TO
18824: IFFALSE 18925
// begin tmp := 0 ;
18826: LD_ADDR_VAR 0 2
18830: PUSH
18831: LD_STRING 0
18833: ST_TO_ADDR
// if result [ 1 ] then
18834: LD_VAR 0 1
18838: PUSH
18839: LD_INT 1
18841: ARRAY
18842: IFFALSE 18907
// if result [ 1 ] [ 1 ] = i then
18844: LD_VAR 0 1
18848: PUSH
18849: LD_INT 1
18851: ARRAY
18852: PUSH
18853: LD_INT 1
18855: ARRAY
18856: PUSH
18857: LD_VAR 0 5
18861: EQUAL
18862: IFFALSE 18907
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
18864: LD_ADDR_VAR 0 1
18868: PUSH
18869: LD_VAR 0 1
18873: PPUSH
18874: LD_INT 1
18876: PPUSH
18877: LD_VAR 0 1
18881: PUSH
18882: LD_INT 1
18884: ARRAY
18885: PPUSH
18886: LD_INT 1
18888: PPUSH
18889: CALL_OW 3
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// tmp := 1 ;
18899: LD_ADDR_VAR 0 2
18903: PUSH
18904: LD_STRING 1
18906: ST_TO_ADDR
// end ; normal := normal & tmp ;
18907: LD_ADDR_VAR 0 3
18911: PUSH
18912: LD_VAR 0 3
18916: PUSH
18917: LD_VAR 0 2
18921: STR
18922: ST_TO_ADDR
// end ;
18923: GO 18823
18925: POP
18926: POP
// for i = 1 to hardcoreCounter do
18927: LD_ADDR_VAR 0 5
18931: PUSH
18932: DOUBLE
18933: LD_INT 1
18935: DEC
18936: ST_TO_ADDR
18937: LD_EXP 53
18941: PUSH
18942: FOR_TO
18943: IFFALSE 19048
// begin tmp := 0 ;
18945: LD_ADDR_VAR 0 2
18949: PUSH
18950: LD_STRING 0
18952: ST_TO_ADDR
// if result [ 2 ] then
18953: LD_VAR 0 1
18957: PUSH
18958: LD_INT 2
18960: ARRAY
18961: IFFALSE 19030
// if result [ 2 ] [ 1 ] = 100 + i then
18963: LD_VAR 0 1
18967: PUSH
18968: LD_INT 2
18970: ARRAY
18971: PUSH
18972: LD_INT 1
18974: ARRAY
18975: PUSH
18976: LD_INT 100
18978: PUSH
18979: LD_VAR 0 5
18983: PLUS
18984: EQUAL
18985: IFFALSE 19030
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
18987: LD_ADDR_VAR 0 1
18991: PUSH
18992: LD_VAR 0 1
18996: PPUSH
18997: LD_INT 2
18999: PPUSH
19000: LD_VAR 0 1
19004: PUSH
19005: LD_INT 2
19007: ARRAY
19008: PPUSH
19009: LD_INT 1
19011: PPUSH
19012: CALL_OW 3
19016: PPUSH
19017: CALL_OW 1
19021: ST_TO_ADDR
// tmp := 1 ;
19022: LD_ADDR_VAR 0 2
19026: PUSH
19027: LD_STRING 1
19029: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_VAR 0 4
19039: PUSH
19040: LD_VAR 0 2
19044: STR
19045: ST_TO_ADDR
// end ;
19046: GO 18942
19048: POP
19049: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
19050: LD_STRING getStreamItemsFromMission("
19052: PUSH
19053: LD_VAR 0 3
19057: STR
19058: PUSH
19059: LD_STRING ","
19061: STR
19062: PUSH
19063: LD_VAR 0 4
19067: STR
19068: PUSH
19069: LD_STRING ")
19071: STR
19072: PPUSH
19073: CALL_OW 559
// end else
19077: GO 19086
// ToLua ( getStreamItemsFromMission("","") ) ;
19079: LD_STRING getStreamItemsFromMission("","")
19081: PPUSH
19082: CALL_OW 559
// end ;
19086: LD_VAR 0 1
19090: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19091: LD_VAR 0 2
19095: PUSH
19096: LD_INT 100
19098: EQUAL
19099: IFFALSE 20048
// begin if not StreamModeActive then
19101: LD_EXP 51
19105: NOT
19106: IFFALSE 19116
// StreamModeActive := true ;
19108: LD_ADDR_EXP 51
19112: PUSH
19113: LD_INT 1
19115: ST_TO_ADDR
// if p3 = 0 then
19116: LD_VAR 0 3
19120: PUSH
19121: LD_INT 0
19123: EQUAL
19124: IFFALSE 19130
// InitStreamMode ;
19126: CALL 15388 0 0
// if p3 = 1 then
19130: LD_VAR 0 3
19134: PUSH
19135: LD_INT 1
19137: EQUAL
19138: IFFALSE 19148
// sRocket := true ;
19140: LD_ADDR_EXP 56
19144: PUSH
19145: LD_INT 1
19147: ST_TO_ADDR
// if p3 = 2 then
19148: LD_VAR 0 3
19152: PUSH
19153: LD_INT 2
19155: EQUAL
19156: IFFALSE 19166
// sSpeed := true ;
19158: LD_ADDR_EXP 55
19162: PUSH
19163: LD_INT 1
19165: ST_TO_ADDR
// if p3 = 3 then
19166: LD_VAR 0 3
19170: PUSH
19171: LD_INT 3
19173: EQUAL
19174: IFFALSE 19184
// sEngine := true ;
19176: LD_ADDR_EXP 57
19180: PUSH
19181: LD_INT 1
19183: ST_TO_ADDR
// if p3 = 4 then
19184: LD_VAR 0 3
19188: PUSH
19189: LD_INT 4
19191: EQUAL
19192: IFFALSE 19202
// sSpec := true ;
19194: LD_ADDR_EXP 54
19198: PUSH
19199: LD_INT 1
19201: ST_TO_ADDR
// if p3 = 5 then
19202: LD_VAR 0 3
19206: PUSH
19207: LD_INT 5
19209: EQUAL
19210: IFFALSE 19220
// sLevel := true ;
19212: LD_ADDR_EXP 58
19216: PUSH
19217: LD_INT 1
19219: ST_TO_ADDR
// if p3 = 6 then
19220: LD_VAR 0 3
19224: PUSH
19225: LD_INT 6
19227: EQUAL
19228: IFFALSE 19238
// sArmoury := true ;
19230: LD_ADDR_EXP 59
19234: PUSH
19235: LD_INT 1
19237: ST_TO_ADDR
// if p3 = 7 then
19238: LD_VAR 0 3
19242: PUSH
19243: LD_INT 7
19245: EQUAL
19246: IFFALSE 19256
// sRadar := true ;
19248: LD_ADDR_EXP 60
19252: PUSH
19253: LD_INT 1
19255: ST_TO_ADDR
// if p3 = 8 then
19256: LD_VAR 0 3
19260: PUSH
19261: LD_INT 8
19263: EQUAL
19264: IFFALSE 19274
// sBunker := true ;
19266: LD_ADDR_EXP 61
19270: PUSH
19271: LD_INT 1
19273: ST_TO_ADDR
// if p3 = 9 then
19274: LD_VAR 0 3
19278: PUSH
19279: LD_INT 9
19281: EQUAL
19282: IFFALSE 19292
// sHack := true ;
19284: LD_ADDR_EXP 62
19288: PUSH
19289: LD_INT 1
19291: ST_TO_ADDR
// if p3 = 10 then
19292: LD_VAR 0 3
19296: PUSH
19297: LD_INT 10
19299: EQUAL
19300: IFFALSE 19310
// sFire := true ;
19302: LD_ADDR_EXP 63
19306: PUSH
19307: LD_INT 1
19309: ST_TO_ADDR
// if p3 = 11 then
19310: LD_VAR 0 3
19314: PUSH
19315: LD_INT 11
19317: EQUAL
19318: IFFALSE 19328
// sRefresh := true ;
19320: LD_ADDR_EXP 64
19324: PUSH
19325: LD_INT 1
19327: ST_TO_ADDR
// if p3 = 12 then
19328: LD_VAR 0 3
19332: PUSH
19333: LD_INT 12
19335: EQUAL
19336: IFFALSE 19346
// sExp := true ;
19338: LD_ADDR_EXP 65
19342: PUSH
19343: LD_INT 1
19345: ST_TO_ADDR
// if p3 = 13 then
19346: LD_VAR 0 3
19350: PUSH
19351: LD_INT 13
19353: EQUAL
19354: IFFALSE 19364
// sDepot := true ;
19356: LD_ADDR_EXP 66
19360: PUSH
19361: LD_INT 1
19363: ST_TO_ADDR
// if p3 = 14 then
19364: LD_VAR 0 3
19368: PUSH
19369: LD_INT 14
19371: EQUAL
19372: IFFALSE 19382
// sFlag := true ;
19374: LD_ADDR_EXP 67
19378: PUSH
19379: LD_INT 1
19381: ST_TO_ADDR
// if p3 = 15 then
19382: LD_VAR 0 3
19386: PUSH
19387: LD_INT 15
19389: EQUAL
19390: IFFALSE 19400
// sKamikadze := true ;
19392: LD_ADDR_EXP 75
19396: PUSH
19397: LD_INT 1
19399: ST_TO_ADDR
// if p3 = 16 then
19400: LD_VAR 0 3
19404: PUSH
19405: LD_INT 16
19407: EQUAL
19408: IFFALSE 19418
// sTroll := true ;
19410: LD_ADDR_EXP 76
19414: PUSH
19415: LD_INT 1
19417: ST_TO_ADDR
// if p3 = 17 then
19418: LD_VAR 0 3
19422: PUSH
19423: LD_INT 17
19425: EQUAL
19426: IFFALSE 19436
// sSlow := true ;
19428: LD_ADDR_EXP 77
19432: PUSH
19433: LD_INT 1
19435: ST_TO_ADDR
// if p3 = 18 then
19436: LD_VAR 0 3
19440: PUSH
19441: LD_INT 18
19443: EQUAL
19444: IFFALSE 19454
// sLack := true ;
19446: LD_ADDR_EXP 78
19450: PUSH
19451: LD_INT 1
19453: ST_TO_ADDR
// if p3 = 19 then
19454: LD_VAR 0 3
19458: PUSH
19459: LD_INT 19
19461: EQUAL
19462: IFFALSE 19472
// sTank := true ;
19464: LD_ADDR_EXP 80
19468: PUSH
19469: LD_INT 1
19471: ST_TO_ADDR
// if p3 = 20 then
19472: LD_VAR 0 3
19476: PUSH
19477: LD_INT 20
19479: EQUAL
19480: IFFALSE 19490
// sRemote := true ;
19482: LD_ADDR_EXP 81
19486: PUSH
19487: LD_INT 1
19489: ST_TO_ADDR
// if p3 = 21 then
19490: LD_VAR 0 3
19494: PUSH
19495: LD_INT 21
19497: EQUAL
19498: IFFALSE 19508
// sPowell := true ;
19500: LD_ADDR_EXP 82
19504: PUSH
19505: LD_INT 1
19507: ST_TO_ADDR
// if p3 = 22 then
19508: LD_VAR 0 3
19512: PUSH
19513: LD_INT 22
19515: EQUAL
19516: IFFALSE 19526
// sTeleport := true ;
19518: LD_ADDR_EXP 85
19522: PUSH
19523: LD_INT 1
19525: ST_TO_ADDR
// if p3 = 23 then
19526: LD_VAR 0 3
19530: PUSH
19531: LD_INT 23
19533: EQUAL
19534: IFFALSE 19544
// sOilTower := true ;
19536: LD_ADDR_EXP 87
19540: PUSH
19541: LD_INT 1
19543: ST_TO_ADDR
// if p3 = 24 then
19544: LD_VAR 0 3
19548: PUSH
19549: LD_INT 24
19551: EQUAL
19552: IFFALSE 19562
// sShovel := true ;
19554: LD_ADDR_EXP 88
19558: PUSH
19559: LD_INT 1
19561: ST_TO_ADDR
// if p3 = 25 then
19562: LD_VAR 0 3
19566: PUSH
19567: LD_INT 25
19569: EQUAL
19570: IFFALSE 19580
// sSheik := true ;
19572: LD_ADDR_EXP 89
19576: PUSH
19577: LD_INT 1
19579: ST_TO_ADDR
// if p3 = 26 then
19580: LD_VAR 0 3
19584: PUSH
19585: LD_INT 26
19587: EQUAL
19588: IFFALSE 19598
// sEarthquake := true ;
19590: LD_ADDR_EXP 91
19594: PUSH
19595: LD_INT 1
19597: ST_TO_ADDR
// if p3 = 27 then
19598: LD_VAR 0 3
19602: PUSH
19603: LD_INT 27
19605: EQUAL
19606: IFFALSE 19616
// sAI := true ;
19608: LD_ADDR_EXP 92
19612: PUSH
19613: LD_INT 1
19615: ST_TO_ADDR
// if p3 = 28 then
19616: LD_VAR 0 3
19620: PUSH
19621: LD_INT 28
19623: EQUAL
19624: IFFALSE 19634
// sCargo := true ;
19626: LD_ADDR_EXP 95
19630: PUSH
19631: LD_INT 1
19633: ST_TO_ADDR
// if p3 = 29 then
19634: LD_VAR 0 3
19638: PUSH
19639: LD_INT 29
19641: EQUAL
19642: IFFALSE 19652
// sDLaser := true ;
19644: LD_ADDR_EXP 96
19648: PUSH
19649: LD_INT 1
19651: ST_TO_ADDR
// if p3 = 30 then
19652: LD_VAR 0 3
19656: PUSH
19657: LD_INT 30
19659: EQUAL
19660: IFFALSE 19670
// sExchange := true ;
19662: LD_ADDR_EXP 97
19666: PUSH
19667: LD_INT 1
19669: ST_TO_ADDR
// if p3 = 31 then
19670: LD_VAR 0 3
19674: PUSH
19675: LD_INT 31
19677: EQUAL
19678: IFFALSE 19688
// sFac := true ;
19680: LD_ADDR_EXP 98
19684: PUSH
19685: LD_INT 1
19687: ST_TO_ADDR
// if p3 = 32 then
19688: LD_VAR 0 3
19692: PUSH
19693: LD_INT 32
19695: EQUAL
19696: IFFALSE 19706
// sPower := true ;
19698: LD_ADDR_EXP 99
19702: PUSH
19703: LD_INT 1
19705: ST_TO_ADDR
// if p3 = 33 then
19706: LD_VAR 0 3
19710: PUSH
19711: LD_INT 33
19713: EQUAL
19714: IFFALSE 19724
// sRandom := true ;
19716: LD_ADDR_EXP 100
19720: PUSH
19721: LD_INT 1
19723: ST_TO_ADDR
// if p3 = 34 then
19724: LD_VAR 0 3
19728: PUSH
19729: LD_INT 34
19731: EQUAL
19732: IFFALSE 19742
// sShield := true ;
19734: LD_ADDR_EXP 101
19738: PUSH
19739: LD_INT 1
19741: ST_TO_ADDR
// if p3 = 35 then
19742: LD_VAR 0 3
19746: PUSH
19747: LD_INT 35
19749: EQUAL
19750: IFFALSE 19760
// sTime := true ;
19752: LD_ADDR_EXP 102
19756: PUSH
19757: LD_INT 1
19759: ST_TO_ADDR
// if p3 = 36 then
19760: LD_VAR 0 3
19764: PUSH
19765: LD_INT 36
19767: EQUAL
19768: IFFALSE 19778
// sTools := true ;
19770: LD_ADDR_EXP 103
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// if p3 = 101 then
19778: LD_VAR 0 3
19782: PUSH
19783: LD_INT 101
19785: EQUAL
19786: IFFALSE 19796
// sSold := true ;
19788: LD_ADDR_EXP 68
19792: PUSH
19793: LD_INT 1
19795: ST_TO_ADDR
// if p3 = 102 then
19796: LD_VAR 0 3
19800: PUSH
19801: LD_INT 102
19803: EQUAL
19804: IFFALSE 19814
// sDiff := true ;
19806: LD_ADDR_EXP 69
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// if p3 = 103 then
19814: LD_VAR 0 3
19818: PUSH
19819: LD_INT 103
19821: EQUAL
19822: IFFALSE 19832
// sFog := true ;
19824: LD_ADDR_EXP 72
19828: PUSH
19829: LD_INT 1
19831: ST_TO_ADDR
// if p3 = 104 then
19832: LD_VAR 0 3
19836: PUSH
19837: LD_INT 104
19839: EQUAL
19840: IFFALSE 19850
// sReset := true ;
19842: LD_ADDR_EXP 73
19846: PUSH
19847: LD_INT 1
19849: ST_TO_ADDR
// if p3 = 105 then
19850: LD_VAR 0 3
19854: PUSH
19855: LD_INT 105
19857: EQUAL
19858: IFFALSE 19868
// sSun := true ;
19860: LD_ADDR_EXP 74
19864: PUSH
19865: LD_INT 1
19867: ST_TO_ADDR
// if p3 = 106 then
19868: LD_VAR 0 3
19872: PUSH
19873: LD_INT 106
19875: EQUAL
19876: IFFALSE 19886
// sTiger := true ;
19878: LD_ADDR_EXP 70
19882: PUSH
19883: LD_INT 1
19885: ST_TO_ADDR
// if p3 = 107 then
19886: LD_VAR 0 3
19890: PUSH
19891: LD_INT 107
19893: EQUAL
19894: IFFALSE 19904
// sBomb := true ;
19896: LD_ADDR_EXP 71
19900: PUSH
19901: LD_INT 1
19903: ST_TO_ADDR
// if p3 = 108 then
19904: LD_VAR 0 3
19908: PUSH
19909: LD_INT 108
19911: EQUAL
19912: IFFALSE 19922
// sWound := true ;
19914: LD_ADDR_EXP 79
19918: PUSH
19919: LD_INT 1
19921: ST_TO_ADDR
// if p3 = 109 then
19922: LD_VAR 0 3
19926: PUSH
19927: LD_INT 109
19929: EQUAL
19930: IFFALSE 19940
// sBetray := true ;
19932: LD_ADDR_EXP 83
19936: PUSH
19937: LD_INT 1
19939: ST_TO_ADDR
// if p3 = 110 then
19940: LD_VAR 0 3
19944: PUSH
19945: LD_INT 110
19947: EQUAL
19948: IFFALSE 19958
// sContamin := true ;
19950: LD_ADDR_EXP 84
19954: PUSH
19955: LD_INT 1
19957: ST_TO_ADDR
// if p3 = 111 then
19958: LD_VAR 0 3
19962: PUSH
19963: LD_INT 111
19965: EQUAL
19966: IFFALSE 19976
// sOil := true ;
19968: LD_ADDR_EXP 86
19972: PUSH
19973: LD_INT 1
19975: ST_TO_ADDR
// if p3 = 112 then
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 112
19983: EQUAL
19984: IFFALSE 19994
// sStu := true ;
19986: LD_ADDR_EXP 90
19990: PUSH
19991: LD_INT 1
19993: ST_TO_ADDR
// if p3 = 113 then
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 113
20001: EQUAL
20002: IFFALSE 20012
// sBazooka := true ;
20004: LD_ADDR_EXP 93
20008: PUSH
20009: LD_INT 1
20011: ST_TO_ADDR
// if p3 = 114 then
20012: LD_VAR 0 3
20016: PUSH
20017: LD_INT 114
20019: EQUAL
20020: IFFALSE 20030
// sMortar := true ;
20022: LD_ADDR_EXP 94
20026: PUSH
20027: LD_INT 1
20029: ST_TO_ADDR
// if p3 = 115 then
20030: LD_VAR 0 3
20034: PUSH
20035: LD_INT 115
20037: EQUAL
20038: IFFALSE 20048
// sRanger := true ;
20040: LD_ADDR_EXP 104
20044: PUSH
20045: LD_INT 1
20047: ST_TO_ADDR
// end ; end ;
20048: PPOPN 6
20050: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
20051: LD_EXP 51
20055: PUSH
20056: LD_EXP 56
20060: AND
20061: IFFALSE 20185
20063: GO 20065
20065: DISABLE
20066: LD_INT 0
20068: PPUSH
20069: PPUSH
// begin enable ;
20070: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
20071: LD_ADDR_VAR 0 2
20075: PUSH
20076: LD_INT 22
20078: PUSH
20079: LD_OWVAR 2
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 34
20093: PUSH
20094: LD_INT 7
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PUSH
20101: LD_INT 34
20103: PUSH
20104: LD_INT 45
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: LD_INT 34
20113: PUSH
20114: LD_INT 28
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: LD_INT 34
20123: PUSH
20124: LD_INT 47
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL_OW 69
20146: ST_TO_ADDR
// if not tmp then
20147: LD_VAR 0 2
20151: NOT
20152: IFFALSE 20156
// exit ;
20154: GO 20185
// for i in tmp do
20156: LD_ADDR_VAR 0 1
20160: PUSH
20161: LD_VAR 0 2
20165: PUSH
20166: FOR_IN
20167: IFFALSE 20183
// begin SetLives ( i , 0 ) ;
20169: LD_VAR 0 1
20173: PPUSH
20174: LD_INT 0
20176: PPUSH
20177: CALL_OW 234
// end ;
20181: GO 20166
20183: POP
20184: POP
// end ;
20185: PPOPN 2
20187: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
20188: LD_EXP 51
20192: PUSH
20193: LD_EXP 57
20197: AND
20198: IFFALSE 20282
20200: GO 20202
20202: DISABLE
20203: LD_INT 0
20205: PPUSH
20206: PPUSH
// begin enable ;
20207: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
20208: LD_ADDR_VAR 0 2
20212: PUSH
20213: LD_INT 22
20215: PUSH
20216: LD_OWVAR 2
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 32
20227: PUSH
20228: LD_INT 3
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: PPUSH
20239: CALL_OW 69
20243: ST_TO_ADDR
// if not tmp then
20244: LD_VAR 0 2
20248: NOT
20249: IFFALSE 20253
// exit ;
20251: GO 20282
// for i in tmp do
20253: LD_ADDR_VAR 0 1
20257: PUSH
20258: LD_VAR 0 2
20262: PUSH
20263: FOR_IN
20264: IFFALSE 20280
// begin SetLives ( i , 0 ) ;
20266: LD_VAR 0 1
20270: PPUSH
20271: LD_INT 0
20273: PPUSH
20274: CALL_OW 234
// end ;
20278: GO 20263
20280: POP
20281: POP
// end ;
20282: PPOPN 2
20284: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
20285: LD_EXP 51
20289: PUSH
20290: LD_EXP 54
20294: AND
20295: IFFALSE 20388
20297: GO 20299
20299: DISABLE
20300: LD_INT 0
20302: PPUSH
// begin enable ;
20303: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
20304: LD_ADDR_VAR 0 1
20308: PUSH
20309: LD_INT 22
20311: PUSH
20312: LD_OWVAR 2
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: PUSH
20321: LD_INT 2
20323: PUSH
20324: LD_INT 25
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PUSH
20334: LD_INT 25
20336: PUSH
20337: LD_INT 9
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: PUSH
20344: LD_INT 25
20346: PUSH
20347: LD_INT 8
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: LIST
20358: LIST
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PPUSH
20364: CALL_OW 69
20368: PUSH
20369: FOR_IN
20370: IFFALSE 20386
// begin SetClass ( i , 1 ) ;
20372: LD_VAR 0 1
20376: PPUSH
20377: LD_INT 1
20379: PPUSH
20380: CALL_OW 336
// end ;
20384: GO 20369
20386: POP
20387: POP
// end ;
20388: PPOPN 1
20390: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
20391: LD_EXP 51
20395: PUSH
20396: LD_EXP 55
20400: AND
20401: PUSH
20402: LD_OWVAR 65
20406: PUSH
20407: LD_INT 7
20409: LESS
20410: AND
20411: IFFALSE 20425
20413: GO 20415
20415: DISABLE
// begin enable ;
20416: ENABLE
// game_speed := 7 ;
20417: LD_ADDR_OWVAR 65
20421: PUSH
20422: LD_INT 7
20424: ST_TO_ADDR
// end ;
20425: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
20426: LD_EXP 51
20430: PUSH
20431: LD_EXP 58
20435: AND
20436: IFFALSE 20638
20438: GO 20440
20440: DISABLE
20441: LD_INT 0
20443: PPUSH
20444: PPUSH
20445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
20446: LD_ADDR_VAR 0 3
20450: PUSH
20451: LD_INT 81
20453: PUSH
20454: LD_OWVAR 2
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: LD_INT 21
20465: PUSH
20466: LD_INT 1
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: PPUSH
20477: CALL_OW 69
20481: ST_TO_ADDR
// if not tmp then
20482: LD_VAR 0 3
20486: NOT
20487: IFFALSE 20491
// exit ;
20489: GO 20638
// if tmp > 5 then
20491: LD_VAR 0 3
20495: PUSH
20496: LD_INT 5
20498: GREATER
20499: IFFALSE 20511
// k := 5 else
20501: LD_ADDR_VAR 0 2
20505: PUSH
20506: LD_INT 5
20508: ST_TO_ADDR
20509: GO 20521
// k := tmp ;
20511: LD_ADDR_VAR 0 2
20515: PUSH
20516: LD_VAR 0 3
20520: ST_TO_ADDR
// for i := 1 to k do
20521: LD_ADDR_VAR 0 1
20525: PUSH
20526: DOUBLE
20527: LD_INT 1
20529: DEC
20530: ST_TO_ADDR
20531: LD_VAR 0 2
20535: PUSH
20536: FOR_TO
20537: IFFALSE 20636
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
20539: LD_VAR 0 3
20543: PUSH
20544: LD_VAR 0 1
20548: ARRAY
20549: PPUSH
20550: LD_VAR 0 1
20554: PUSH
20555: LD_INT 4
20557: MOD
20558: PUSH
20559: LD_INT 1
20561: PLUS
20562: PPUSH
20563: CALL_OW 259
20567: PUSH
20568: LD_INT 10
20570: LESS
20571: IFFALSE 20634
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
20573: LD_VAR 0 3
20577: PUSH
20578: LD_VAR 0 1
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 1
20588: PUSH
20589: LD_INT 4
20591: MOD
20592: PUSH
20593: LD_INT 1
20595: PLUS
20596: PPUSH
20597: LD_VAR 0 3
20601: PUSH
20602: LD_VAR 0 1
20606: ARRAY
20607: PPUSH
20608: LD_VAR 0 1
20612: PUSH
20613: LD_INT 4
20615: MOD
20616: PUSH
20617: LD_INT 1
20619: PLUS
20620: PPUSH
20621: CALL_OW 259
20625: PUSH
20626: LD_INT 1
20628: PLUS
20629: PPUSH
20630: CALL_OW 237
20634: GO 20536
20636: POP
20637: POP
// end ;
20638: PPOPN 3
20640: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
20641: LD_EXP 51
20645: PUSH
20646: LD_EXP 59
20650: AND
20651: IFFALSE 20671
20653: GO 20655
20655: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
20656: LD_INT 4
20658: PPUSH
20659: LD_OWVAR 2
20663: PPUSH
20664: LD_INT 0
20666: PPUSH
20667: CALL_OW 324
20671: END
// every 0 0$1 trigger StreamModeActive and sShovel do
20672: LD_EXP 51
20676: PUSH
20677: LD_EXP 88
20681: AND
20682: IFFALSE 20702
20684: GO 20686
20686: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
20687: LD_INT 19
20689: PPUSH
20690: LD_OWVAR 2
20694: PPUSH
20695: LD_INT 0
20697: PPUSH
20698: CALL_OW 324
20702: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
20703: LD_EXP 51
20707: PUSH
20708: LD_EXP 60
20712: AND
20713: IFFALSE 20815
20715: GO 20717
20717: DISABLE
20718: LD_INT 0
20720: PPUSH
20721: PPUSH
// begin enable ;
20722: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
20723: LD_ADDR_VAR 0 2
20727: PUSH
20728: LD_INT 22
20730: PUSH
20731: LD_OWVAR 2
20735: PUSH
20736: EMPTY
20737: LIST
20738: LIST
20739: PUSH
20740: LD_INT 2
20742: PUSH
20743: LD_INT 34
20745: PUSH
20746: LD_INT 11
20748: PUSH
20749: EMPTY
20750: LIST
20751: LIST
20752: PUSH
20753: LD_INT 34
20755: PUSH
20756: LD_INT 30
20758: PUSH
20759: EMPTY
20760: LIST
20761: LIST
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: LIST
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: PPUSH
20772: CALL_OW 69
20776: ST_TO_ADDR
// if not tmp then
20777: LD_VAR 0 2
20781: NOT
20782: IFFALSE 20786
// exit ;
20784: GO 20815
// for i in tmp do
20786: LD_ADDR_VAR 0 1
20790: PUSH
20791: LD_VAR 0 2
20795: PUSH
20796: FOR_IN
20797: IFFALSE 20813
// begin SetLives ( i , 0 ) ;
20799: LD_VAR 0 1
20803: PPUSH
20804: LD_INT 0
20806: PPUSH
20807: CALL_OW 234
// end ;
20811: GO 20796
20813: POP
20814: POP
// end ;
20815: PPOPN 2
20817: END
// every 0 0$1 trigger StreamModeActive and sBunker do
20818: LD_EXP 51
20822: PUSH
20823: LD_EXP 61
20827: AND
20828: IFFALSE 20848
20830: GO 20832
20832: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
20833: LD_INT 32
20835: PPUSH
20836: LD_OWVAR 2
20840: PPUSH
20841: LD_INT 0
20843: PPUSH
20844: CALL_OW 324
20848: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
20849: LD_EXP 51
20853: PUSH
20854: LD_EXP 62
20858: AND
20859: IFFALSE 21040
20861: GO 20863
20863: DISABLE
20864: LD_INT 0
20866: PPUSH
20867: PPUSH
20868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
20869: LD_ADDR_VAR 0 2
20873: PUSH
20874: LD_INT 22
20876: PUSH
20877: LD_OWVAR 2
20881: PUSH
20882: EMPTY
20883: LIST
20884: LIST
20885: PUSH
20886: LD_INT 33
20888: PUSH
20889: LD_INT 3
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: PUSH
20896: EMPTY
20897: LIST
20898: LIST
20899: PPUSH
20900: CALL_OW 69
20904: ST_TO_ADDR
// if not tmp then
20905: LD_VAR 0 2
20909: NOT
20910: IFFALSE 20914
// exit ;
20912: GO 21040
// side := 0 ;
20914: LD_ADDR_VAR 0 3
20918: PUSH
20919: LD_INT 0
20921: ST_TO_ADDR
// for i := 1 to 8 do
20922: LD_ADDR_VAR 0 1
20926: PUSH
20927: DOUBLE
20928: LD_INT 1
20930: DEC
20931: ST_TO_ADDR
20932: LD_INT 8
20934: PUSH
20935: FOR_TO
20936: IFFALSE 20984
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
20938: LD_OWVAR 2
20942: PUSH
20943: LD_VAR 0 1
20947: NONEQUAL
20948: PUSH
20949: LD_OWVAR 2
20953: PPUSH
20954: LD_VAR 0 1
20958: PPUSH
20959: CALL_OW 81
20963: PUSH
20964: LD_INT 2
20966: EQUAL
20967: AND
20968: IFFALSE 20982
// begin side := i ;
20970: LD_ADDR_VAR 0 3
20974: PUSH
20975: LD_VAR 0 1
20979: ST_TO_ADDR
// break ;
20980: GO 20984
// end ;
20982: GO 20935
20984: POP
20985: POP
// if not side then
20986: LD_VAR 0 3
20990: NOT
20991: IFFALSE 20995
// exit ;
20993: GO 21040
// for i := 1 to tmp do
20995: LD_ADDR_VAR 0 1
20999: PUSH
21000: DOUBLE
21001: LD_INT 1
21003: DEC
21004: ST_TO_ADDR
21005: LD_VAR 0 2
21009: PUSH
21010: FOR_TO
21011: IFFALSE 21038
// if Prob ( 60 ) then
21013: LD_INT 60
21015: PPUSH
21016: CALL_OW 13
21020: IFFALSE 21036
// SetSide ( i , side ) ;
21022: LD_VAR 0 1
21026: PPUSH
21027: LD_VAR 0 3
21031: PPUSH
21032: CALL_OW 235
21036: GO 21010
21038: POP
21039: POP
// end ;
21040: PPOPN 3
21042: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
21043: LD_EXP 51
21047: PUSH
21048: LD_EXP 64
21052: AND
21053: IFFALSE 21172
21055: GO 21057
21057: DISABLE
21058: LD_INT 0
21060: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
21061: LD_ADDR_VAR 0 1
21065: PUSH
21066: LD_INT 22
21068: PUSH
21069: LD_OWVAR 2
21073: PUSH
21074: EMPTY
21075: LIST
21076: LIST
21077: PUSH
21078: LD_INT 21
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: EMPTY
21085: LIST
21086: LIST
21087: PUSH
21088: LD_INT 3
21090: PUSH
21091: LD_INT 23
21093: PUSH
21094: LD_INT 0
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: EMPTY
21106: LIST
21107: LIST
21108: LIST
21109: PPUSH
21110: CALL_OW 69
21114: PUSH
21115: FOR_IN
21116: IFFALSE 21170
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
21118: LD_VAR 0 1
21122: PPUSH
21123: CALL_OW 257
21127: PUSH
21128: LD_INT 1
21130: PUSH
21131: LD_INT 2
21133: PUSH
21134: LD_INT 3
21136: PUSH
21137: LD_INT 4
21139: PUSH
21140: EMPTY
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: IN
21146: IFFALSE 21168
// SetClass ( un , rand ( 1 , 4 ) ) ;
21148: LD_VAR 0 1
21152: PPUSH
21153: LD_INT 1
21155: PPUSH
21156: LD_INT 4
21158: PPUSH
21159: CALL_OW 12
21163: PPUSH
21164: CALL_OW 336
21168: GO 21115
21170: POP
21171: POP
// end ;
21172: PPOPN 1
21174: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
21175: LD_EXP 51
21179: PUSH
21180: LD_EXP 63
21184: AND
21185: IFFALSE 21264
21187: GO 21189
21189: DISABLE
21190: LD_INT 0
21192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21193: LD_ADDR_VAR 0 1
21197: PUSH
21198: LD_INT 22
21200: PUSH
21201: LD_OWVAR 2
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PUSH
21210: LD_INT 21
21212: PUSH
21213: LD_INT 3
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: PPUSH
21224: CALL_OW 69
21228: ST_TO_ADDR
// if not tmp then
21229: LD_VAR 0 1
21233: NOT
21234: IFFALSE 21238
// exit ;
21236: GO 21264
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
21238: LD_VAR 0 1
21242: PUSH
21243: LD_INT 1
21245: PPUSH
21246: LD_VAR 0 1
21250: PPUSH
21251: CALL_OW 12
21255: ARRAY
21256: PPUSH
21257: LD_INT 100
21259: PPUSH
21260: CALL_OW 234
// end ;
21264: PPOPN 1
21266: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
21267: LD_EXP 51
21271: PUSH
21272: LD_EXP 65
21276: AND
21277: IFFALSE 21375
21279: GO 21281
21281: DISABLE
21282: LD_INT 0
21284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
21285: LD_ADDR_VAR 0 1
21289: PUSH
21290: LD_INT 22
21292: PUSH
21293: LD_OWVAR 2
21297: PUSH
21298: EMPTY
21299: LIST
21300: LIST
21301: PUSH
21302: LD_INT 21
21304: PUSH
21305: LD_INT 1
21307: PUSH
21308: EMPTY
21309: LIST
21310: LIST
21311: PUSH
21312: EMPTY
21313: LIST
21314: LIST
21315: PPUSH
21316: CALL_OW 69
21320: ST_TO_ADDR
// if not tmp then
21321: LD_VAR 0 1
21325: NOT
21326: IFFALSE 21330
// exit ;
21328: GO 21375
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
21330: LD_VAR 0 1
21334: PUSH
21335: LD_INT 1
21337: PPUSH
21338: LD_VAR 0 1
21342: PPUSH
21343: CALL_OW 12
21347: ARRAY
21348: PPUSH
21349: LD_INT 1
21351: PPUSH
21352: LD_INT 4
21354: PPUSH
21355: CALL_OW 12
21359: PPUSH
21360: LD_INT 3000
21362: PPUSH
21363: LD_INT 9000
21365: PPUSH
21366: CALL_OW 12
21370: PPUSH
21371: CALL_OW 492
// end ;
21375: PPOPN 1
21377: END
// every 0 0$1 trigger StreamModeActive and sDepot do
21378: LD_EXP 51
21382: PUSH
21383: LD_EXP 66
21387: AND
21388: IFFALSE 21408
21390: GO 21392
21392: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
21393: LD_INT 1
21395: PPUSH
21396: LD_OWVAR 2
21400: PPUSH
21401: LD_INT 0
21403: PPUSH
21404: CALL_OW 324
21408: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
21409: LD_EXP 51
21413: PUSH
21414: LD_EXP 67
21418: AND
21419: IFFALSE 21502
21421: GO 21423
21423: DISABLE
21424: LD_INT 0
21426: PPUSH
21427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21428: LD_ADDR_VAR 0 2
21432: PUSH
21433: LD_INT 22
21435: PUSH
21436: LD_OWVAR 2
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: PUSH
21445: LD_INT 21
21447: PUSH
21448: LD_INT 3
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: PPUSH
21459: CALL_OW 69
21463: ST_TO_ADDR
// if not tmp then
21464: LD_VAR 0 2
21468: NOT
21469: IFFALSE 21473
// exit ;
21471: GO 21502
// for i in tmp do
21473: LD_ADDR_VAR 0 1
21477: PUSH
21478: LD_VAR 0 2
21482: PUSH
21483: FOR_IN
21484: IFFALSE 21500
// SetBLevel ( i , 10 ) ;
21486: LD_VAR 0 1
21490: PPUSH
21491: LD_INT 10
21493: PPUSH
21494: CALL_OW 241
21498: GO 21483
21500: POP
21501: POP
// end ;
21502: PPOPN 2
21504: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
21505: LD_EXP 51
21509: PUSH
21510: LD_EXP 68
21514: AND
21515: IFFALSE 21626
21517: GO 21519
21519: DISABLE
21520: LD_INT 0
21522: PPUSH
21523: PPUSH
21524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21525: LD_ADDR_VAR 0 3
21529: PUSH
21530: LD_INT 22
21532: PUSH
21533: LD_OWVAR 2
21537: PUSH
21538: EMPTY
21539: LIST
21540: LIST
21541: PUSH
21542: LD_INT 25
21544: PUSH
21545: LD_INT 1
21547: PUSH
21548: EMPTY
21549: LIST
21550: LIST
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: PPUSH
21556: CALL_OW 69
21560: ST_TO_ADDR
// if not tmp then
21561: LD_VAR 0 3
21565: NOT
21566: IFFALSE 21570
// exit ;
21568: GO 21626
// un := tmp [ rand ( 1 , tmp ) ] ;
21570: LD_ADDR_VAR 0 2
21574: PUSH
21575: LD_VAR 0 3
21579: PUSH
21580: LD_INT 1
21582: PPUSH
21583: LD_VAR 0 3
21587: PPUSH
21588: CALL_OW 12
21592: ARRAY
21593: ST_TO_ADDR
// if Crawls ( un ) then
21594: LD_VAR 0 2
21598: PPUSH
21599: CALL_OW 318
21603: IFFALSE 21614
// ComWalk ( un ) ;
21605: LD_VAR 0 2
21609: PPUSH
21610: CALL_OW 138
// SetClass ( un , class_sniper ) ;
21614: LD_VAR 0 2
21618: PPUSH
21619: LD_INT 5
21621: PPUSH
21622: CALL_OW 336
// end ;
21626: PPOPN 3
21628: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
21629: LD_EXP 51
21633: PUSH
21634: LD_EXP 69
21638: AND
21639: PUSH
21640: LD_OWVAR 67
21644: PUSH
21645: LD_INT 3
21647: LESS
21648: AND
21649: IFFALSE 21668
21651: GO 21653
21653: DISABLE
// Difficulty := Difficulty + 1 ;
21654: LD_ADDR_OWVAR 67
21658: PUSH
21659: LD_OWVAR 67
21663: PUSH
21664: LD_INT 1
21666: PLUS
21667: ST_TO_ADDR
21668: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
21669: LD_EXP 51
21673: PUSH
21674: LD_EXP 70
21678: AND
21679: IFFALSE 21782
21681: GO 21683
21683: DISABLE
21684: LD_INT 0
21686: PPUSH
// begin for i := 1 to 5 do
21687: LD_ADDR_VAR 0 1
21691: PUSH
21692: DOUBLE
21693: LD_INT 1
21695: DEC
21696: ST_TO_ADDR
21697: LD_INT 5
21699: PUSH
21700: FOR_TO
21701: IFFALSE 21780
// begin uc_nation := nation_nature ;
21703: LD_ADDR_OWVAR 21
21707: PUSH
21708: LD_INT 0
21710: ST_TO_ADDR
// uc_side := 0 ;
21711: LD_ADDR_OWVAR 20
21715: PUSH
21716: LD_INT 0
21718: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21719: LD_ADDR_OWVAR 29
21723: PUSH
21724: LD_INT 12
21726: PUSH
21727: LD_INT 12
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: ST_TO_ADDR
// hc_agressivity := 20 ;
21734: LD_ADDR_OWVAR 35
21738: PUSH
21739: LD_INT 20
21741: ST_TO_ADDR
// hc_class := class_tiger ;
21742: LD_ADDR_OWVAR 28
21746: PUSH
21747: LD_INT 14
21749: ST_TO_ADDR
// hc_gallery :=  ;
21750: LD_ADDR_OWVAR 33
21754: PUSH
21755: LD_STRING 
21757: ST_TO_ADDR
// hc_name :=  ;
21758: LD_ADDR_OWVAR 26
21762: PUSH
21763: LD_STRING 
21765: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
21766: CALL_OW 44
21770: PPUSH
21771: LD_INT 0
21773: PPUSH
21774: CALL_OW 51
// end ;
21778: GO 21700
21780: POP
21781: POP
// end ;
21782: PPOPN 1
21784: END
// every 0 0$1 trigger StreamModeActive and sBomb do
21785: LD_EXP 51
21789: PUSH
21790: LD_EXP 71
21794: AND
21795: IFFALSE 21804
21797: GO 21799
21799: DISABLE
// StreamSibBomb ;
21800: CALL 21805 0 0
21804: END
// export function StreamSibBomb ; var i , x , y ; begin
21805: LD_INT 0
21807: PPUSH
21808: PPUSH
21809: PPUSH
21810: PPUSH
// result := false ;
21811: LD_ADDR_VAR 0 1
21815: PUSH
21816: LD_INT 0
21818: ST_TO_ADDR
// for i := 1 to 16 do
21819: LD_ADDR_VAR 0 2
21823: PUSH
21824: DOUBLE
21825: LD_INT 1
21827: DEC
21828: ST_TO_ADDR
21829: LD_INT 16
21831: PUSH
21832: FOR_TO
21833: IFFALSE 22032
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
21835: LD_ADDR_VAR 0 3
21839: PUSH
21840: LD_INT 10
21842: PUSH
21843: LD_INT 20
21845: PUSH
21846: LD_INT 30
21848: PUSH
21849: LD_INT 40
21851: PUSH
21852: LD_INT 50
21854: PUSH
21855: LD_INT 60
21857: PUSH
21858: LD_INT 70
21860: PUSH
21861: LD_INT 80
21863: PUSH
21864: LD_INT 90
21866: PUSH
21867: LD_INT 100
21869: PUSH
21870: LD_INT 110
21872: PUSH
21873: LD_INT 120
21875: PUSH
21876: LD_INT 130
21878: PUSH
21879: LD_INT 140
21881: PUSH
21882: LD_INT 150
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: LIST
21889: LIST
21890: LIST
21891: LIST
21892: LIST
21893: LIST
21894: LIST
21895: LIST
21896: LIST
21897: LIST
21898: LIST
21899: LIST
21900: LIST
21901: PUSH
21902: LD_INT 1
21904: PPUSH
21905: LD_INT 15
21907: PPUSH
21908: CALL_OW 12
21912: ARRAY
21913: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
21914: LD_ADDR_VAR 0 4
21918: PUSH
21919: LD_INT 10
21921: PUSH
21922: LD_INT 20
21924: PUSH
21925: LD_INT 30
21927: PUSH
21928: LD_INT 40
21930: PUSH
21931: LD_INT 50
21933: PUSH
21934: LD_INT 60
21936: PUSH
21937: LD_INT 70
21939: PUSH
21940: LD_INT 80
21942: PUSH
21943: LD_INT 90
21945: PUSH
21946: LD_INT 100
21948: PUSH
21949: LD_INT 110
21951: PUSH
21952: LD_INT 120
21954: PUSH
21955: LD_INT 130
21957: PUSH
21958: LD_INT 140
21960: PUSH
21961: LD_INT 150
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: PUSH
21981: LD_INT 1
21983: PPUSH
21984: LD_INT 15
21986: PPUSH
21987: CALL_OW 12
21991: ARRAY
21992: ST_TO_ADDR
// if ValidHex ( x , y ) then
21993: LD_VAR 0 3
21997: PPUSH
21998: LD_VAR 0 4
22002: PPUSH
22003: CALL_OW 488
22007: IFFALSE 22030
// begin result := [ x , y ] ;
22009: LD_ADDR_VAR 0 1
22013: PUSH
22014: LD_VAR 0 3
22018: PUSH
22019: LD_VAR 0 4
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: ST_TO_ADDR
// break ;
22028: GO 22032
// end ; end ;
22030: GO 21832
22032: POP
22033: POP
// if result then
22034: LD_VAR 0 1
22038: IFFALSE 22098
// begin ToLua ( playSibBomb() ) ;
22040: LD_STRING playSibBomb()
22042: PPUSH
22043: CALL_OW 559
// wait ( 0 0$14 ) ;
22047: LD_INT 490
22049: PPUSH
22050: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
22054: LD_VAR 0 1
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PPUSH
22063: LD_VAR 0 1
22067: PUSH
22068: LD_INT 2
22070: ARRAY
22071: PPUSH
22072: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
22076: LD_VAR 0 1
22080: PUSH
22081: LD_INT 1
22083: ARRAY
22084: PPUSH
22085: LD_VAR 0 1
22089: PUSH
22090: LD_INT 2
22092: ARRAY
22093: PPUSH
22094: CALL_OW 429
// end ; end ;
22098: LD_VAR 0 1
22102: RET
// every 0 0$1 trigger StreamModeActive and sReset do
22103: LD_EXP 51
22107: PUSH
22108: LD_EXP 73
22112: AND
22113: IFFALSE 22125
22115: GO 22117
22117: DISABLE
// YouLost (  ) ;
22118: LD_STRING 
22120: PPUSH
22121: CALL_OW 104
22125: END
// every 0 0$1 trigger StreamModeActive and sFog do
22126: LD_EXP 51
22130: PUSH
22131: LD_EXP 72
22135: AND
22136: IFFALSE 22150
22138: GO 22140
22140: DISABLE
// FogOff ( your_side ) ;
22141: LD_OWVAR 2
22145: PPUSH
22146: CALL_OW 344
22150: END
// every 0 0$1 trigger StreamModeActive and sSun do
22151: LD_EXP 51
22155: PUSH
22156: LD_EXP 74
22160: AND
22161: IFFALSE 22189
22163: GO 22165
22165: DISABLE
// begin solar_recharge_percent := 0 ;
22166: LD_ADDR_OWVAR 79
22170: PUSH
22171: LD_INT 0
22173: ST_TO_ADDR
// wait ( 5 5$00 ) ;
22174: LD_INT 10500
22176: PPUSH
22177: CALL_OW 67
// solar_recharge_percent := 100 ;
22181: LD_ADDR_OWVAR 79
22185: PUSH
22186: LD_INT 100
22188: ST_TO_ADDR
// end ;
22189: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
22190: LD_EXP 51
22194: PUSH
22195: LD_EXP 75
22199: AND
22200: IFFALSE 22439
22202: GO 22204
22204: DISABLE
22205: LD_INT 0
22207: PPUSH
22208: PPUSH
22209: PPUSH
// begin tmp := [ ] ;
22210: LD_ADDR_VAR 0 3
22214: PUSH
22215: EMPTY
22216: ST_TO_ADDR
// for i := 1 to 6 do
22217: LD_ADDR_VAR 0 1
22221: PUSH
22222: DOUBLE
22223: LD_INT 1
22225: DEC
22226: ST_TO_ADDR
22227: LD_INT 6
22229: PUSH
22230: FOR_TO
22231: IFFALSE 22336
// begin uc_nation := nation_nature ;
22233: LD_ADDR_OWVAR 21
22237: PUSH
22238: LD_INT 0
22240: ST_TO_ADDR
// uc_side := 0 ;
22241: LD_ADDR_OWVAR 20
22245: PUSH
22246: LD_INT 0
22248: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22249: LD_ADDR_OWVAR 29
22253: PUSH
22254: LD_INT 12
22256: PUSH
22257: LD_INT 12
22259: PUSH
22260: EMPTY
22261: LIST
22262: LIST
22263: ST_TO_ADDR
// hc_agressivity := 20 ;
22264: LD_ADDR_OWVAR 35
22268: PUSH
22269: LD_INT 20
22271: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
22272: LD_ADDR_OWVAR 28
22276: PUSH
22277: LD_INT 17
22279: ST_TO_ADDR
// hc_gallery :=  ;
22280: LD_ADDR_OWVAR 33
22284: PUSH
22285: LD_STRING 
22287: ST_TO_ADDR
// hc_name :=  ;
22288: LD_ADDR_OWVAR 26
22292: PUSH
22293: LD_STRING 
22295: ST_TO_ADDR
// un := CreateHuman ;
22296: LD_ADDR_VAR 0 2
22300: PUSH
22301: CALL_OW 44
22305: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
22306: LD_VAR 0 2
22310: PPUSH
22311: LD_INT 1
22313: PPUSH
22314: CALL_OW 51
// tmp := tmp ^ un ;
22318: LD_ADDR_VAR 0 3
22322: PUSH
22323: LD_VAR 0 3
22327: PUSH
22328: LD_VAR 0 2
22332: ADD
22333: ST_TO_ADDR
// end ;
22334: GO 22230
22336: POP
22337: POP
// repeat wait ( 0 0$1 ) ;
22338: LD_INT 35
22340: PPUSH
22341: CALL_OW 67
// for un in tmp do
22345: LD_ADDR_VAR 0 2
22349: PUSH
22350: LD_VAR 0 3
22354: PUSH
22355: FOR_IN
22356: IFFALSE 22430
// begin if IsDead ( un ) then
22358: LD_VAR 0 2
22362: PPUSH
22363: CALL_OW 301
22367: IFFALSE 22387
// begin tmp := tmp diff un ;
22369: LD_ADDR_VAR 0 3
22373: PUSH
22374: LD_VAR 0 3
22378: PUSH
22379: LD_VAR 0 2
22383: DIFF
22384: ST_TO_ADDR
// continue ;
22385: GO 22355
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
22387: LD_VAR 0 2
22391: PPUSH
22392: LD_INT 3
22394: PUSH
22395: LD_INT 22
22397: PUSH
22398: LD_INT 0
22400: PUSH
22401: EMPTY
22402: LIST
22403: LIST
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PPUSH
22409: CALL_OW 69
22413: PPUSH
22414: LD_VAR 0 2
22418: PPUSH
22419: CALL_OW 74
22423: PPUSH
22424: CALL_OW 115
// end ;
22428: GO 22355
22430: POP
22431: POP
// until not tmp ;
22432: LD_VAR 0 3
22436: NOT
22437: IFFALSE 22338
// end ;
22439: PPOPN 3
22441: END
// every 0 0$1 trigger StreamModeActive and sTroll do
22442: LD_EXP 51
22446: PUSH
22447: LD_EXP 76
22451: AND
22452: IFFALSE 22506
22454: GO 22456
22456: DISABLE
// begin ToLua ( displayTroll(); ) ;
22457: LD_STRING displayTroll();
22459: PPUSH
22460: CALL_OW 559
// wait ( 3 3$00 ) ;
22464: LD_INT 6300
22466: PPUSH
22467: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22471: LD_STRING hideTroll();
22473: PPUSH
22474: CALL_OW 559
// wait ( 1 1$00 ) ;
22478: LD_INT 2100
22480: PPUSH
22481: CALL_OW 67
// ToLua ( displayTroll(); ) ;
22485: LD_STRING displayTroll();
22487: PPUSH
22488: CALL_OW 559
// wait ( 1 1$00 ) ;
22492: LD_INT 2100
22494: PPUSH
22495: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22499: LD_STRING hideTroll();
22501: PPUSH
22502: CALL_OW 559
// end ;
22506: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
22507: LD_EXP 51
22511: PUSH
22512: LD_EXP 77
22516: AND
22517: IFFALSE 22580
22519: GO 22521
22521: DISABLE
22522: LD_INT 0
22524: PPUSH
// begin p := 0 ;
22525: LD_ADDR_VAR 0 1
22529: PUSH
22530: LD_INT 0
22532: ST_TO_ADDR
// repeat game_speed := 1 ;
22533: LD_ADDR_OWVAR 65
22537: PUSH
22538: LD_INT 1
22540: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22541: LD_INT 35
22543: PPUSH
22544: CALL_OW 67
// p := p + 1 ;
22548: LD_ADDR_VAR 0 1
22552: PUSH
22553: LD_VAR 0 1
22557: PUSH
22558: LD_INT 1
22560: PLUS
22561: ST_TO_ADDR
// until p >= 60 ;
22562: LD_VAR 0 1
22566: PUSH
22567: LD_INT 60
22569: GREATEREQUAL
22570: IFFALSE 22533
// game_speed := 4 ;
22572: LD_ADDR_OWVAR 65
22576: PUSH
22577: LD_INT 4
22579: ST_TO_ADDR
// end ;
22580: PPOPN 1
22582: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
22583: LD_EXP 51
22587: PUSH
22588: LD_EXP 78
22592: AND
22593: IFFALSE 22739
22595: GO 22597
22597: DISABLE
22598: LD_INT 0
22600: PPUSH
22601: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22602: LD_ADDR_VAR 0 1
22606: PUSH
22607: LD_INT 22
22609: PUSH
22610: LD_OWVAR 2
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: LD_INT 2
22621: PUSH
22622: LD_INT 30
22624: PUSH
22625: LD_INT 0
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: PUSH
22632: LD_INT 30
22634: PUSH
22635: LD_INT 1
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: LIST
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PPUSH
22651: CALL_OW 69
22655: ST_TO_ADDR
// if not depot then
22656: LD_VAR 0 1
22660: NOT
22661: IFFALSE 22665
// exit ;
22663: GO 22739
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
22665: LD_ADDR_VAR 0 2
22669: PUSH
22670: LD_VAR 0 1
22674: PUSH
22675: LD_INT 1
22677: PPUSH
22678: LD_VAR 0 1
22682: PPUSH
22683: CALL_OW 12
22687: ARRAY
22688: PPUSH
22689: CALL_OW 274
22693: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
22694: LD_VAR 0 2
22698: PPUSH
22699: LD_INT 1
22701: PPUSH
22702: LD_INT 0
22704: PPUSH
22705: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
22709: LD_VAR 0 2
22713: PPUSH
22714: LD_INT 2
22716: PPUSH
22717: LD_INT 0
22719: PPUSH
22720: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
22724: LD_VAR 0 2
22728: PPUSH
22729: LD_INT 3
22731: PPUSH
22732: LD_INT 0
22734: PPUSH
22735: CALL_OW 277
// end ;
22739: PPOPN 2
22741: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
22742: LD_EXP 51
22746: PUSH
22747: LD_EXP 79
22751: AND
22752: IFFALSE 22849
22754: GO 22756
22756: DISABLE
22757: LD_INT 0
22759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22760: LD_ADDR_VAR 0 1
22764: PUSH
22765: LD_INT 22
22767: PUSH
22768: LD_OWVAR 2
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 21
22779: PUSH
22780: LD_INT 1
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: PUSH
22787: LD_INT 3
22789: PUSH
22790: LD_INT 23
22792: PUSH
22793: LD_INT 0
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: LIST
22808: PPUSH
22809: CALL_OW 69
22813: ST_TO_ADDR
// if not tmp then
22814: LD_VAR 0 1
22818: NOT
22819: IFFALSE 22823
// exit ;
22821: GO 22849
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
22823: LD_VAR 0 1
22827: PUSH
22828: LD_INT 1
22830: PPUSH
22831: LD_VAR 0 1
22835: PPUSH
22836: CALL_OW 12
22840: ARRAY
22841: PPUSH
22842: LD_INT 200
22844: PPUSH
22845: CALL_OW 234
// end ;
22849: PPOPN 1
22851: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
22852: LD_EXP 51
22856: PUSH
22857: LD_EXP 80
22861: AND
22862: IFFALSE 22941
22864: GO 22866
22866: DISABLE
22867: LD_INT 0
22869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
22870: LD_ADDR_VAR 0 1
22874: PUSH
22875: LD_INT 22
22877: PUSH
22878: LD_OWVAR 2
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PUSH
22887: LD_INT 21
22889: PUSH
22890: LD_INT 2
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PPUSH
22901: CALL_OW 69
22905: ST_TO_ADDR
// if not tmp then
22906: LD_VAR 0 1
22910: NOT
22911: IFFALSE 22915
// exit ;
22913: GO 22941
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
22915: LD_VAR 0 1
22919: PUSH
22920: LD_INT 1
22922: PPUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: CALL_OW 12
22932: ARRAY
22933: PPUSH
22934: LD_INT 60
22936: PPUSH
22937: CALL_OW 234
// end ;
22941: PPOPN 1
22943: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
22944: LD_EXP 51
22948: PUSH
22949: LD_EXP 81
22953: AND
22954: IFFALSE 23053
22956: GO 22958
22958: DISABLE
22959: LD_INT 0
22961: PPUSH
22962: PPUSH
// begin enable ;
22963: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
22964: LD_ADDR_VAR 0 1
22968: PUSH
22969: LD_INT 22
22971: PUSH
22972: LD_OWVAR 2
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: LD_INT 61
22983: PUSH
22984: EMPTY
22985: LIST
22986: PUSH
22987: LD_INT 33
22989: PUSH
22990: LD_INT 2
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: PUSH
22997: EMPTY
22998: LIST
22999: LIST
23000: LIST
23001: PPUSH
23002: CALL_OW 69
23006: ST_TO_ADDR
// if not tmp then
23007: LD_VAR 0 1
23011: NOT
23012: IFFALSE 23016
// exit ;
23014: GO 23053
// for i in tmp do
23016: LD_ADDR_VAR 0 2
23020: PUSH
23021: LD_VAR 0 1
23025: PUSH
23026: FOR_IN
23027: IFFALSE 23051
// if IsControledBy ( i ) then
23029: LD_VAR 0 2
23033: PPUSH
23034: CALL_OW 312
23038: IFFALSE 23049
// ComUnlink ( i ) ;
23040: LD_VAR 0 2
23044: PPUSH
23045: CALL_OW 136
23049: GO 23026
23051: POP
23052: POP
// end ;
23053: PPOPN 2
23055: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
23056: LD_EXP 51
23060: PUSH
23061: LD_EXP 82
23065: AND
23066: IFFALSE 23206
23068: GO 23070
23070: DISABLE
23071: LD_INT 0
23073: PPUSH
23074: PPUSH
// begin ToLua ( displayPowell(); ) ;
23075: LD_STRING displayPowell();
23077: PPUSH
23078: CALL_OW 559
// uc_side := 0 ;
23082: LD_ADDR_OWVAR 20
23086: PUSH
23087: LD_INT 0
23089: ST_TO_ADDR
// uc_nation := 2 ;
23090: LD_ADDR_OWVAR 21
23094: PUSH
23095: LD_INT 2
23097: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
23098: LD_ADDR_OWVAR 37
23102: PUSH
23103: LD_INT 14
23105: ST_TO_ADDR
// vc_engine := engine_siberite ;
23106: LD_ADDR_OWVAR 39
23110: PUSH
23111: LD_INT 3
23113: ST_TO_ADDR
// vc_control := control_apeman ;
23114: LD_ADDR_OWVAR 38
23118: PUSH
23119: LD_INT 5
23121: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
23122: LD_ADDR_OWVAR 40
23126: PUSH
23127: LD_INT 29
23129: ST_TO_ADDR
// un := CreateVehicle ;
23130: LD_ADDR_VAR 0 2
23134: PUSH
23135: CALL_OW 45
23139: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23140: LD_VAR 0 2
23144: PPUSH
23145: LD_INT 1
23147: PPUSH
23148: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23152: LD_INT 35
23154: PPUSH
23155: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
23159: LD_VAR 0 2
23163: PPUSH
23164: LD_INT 22
23166: PUSH
23167: LD_OWVAR 2
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PPUSH
23176: CALL_OW 69
23180: PPUSH
23181: LD_VAR 0 2
23185: PPUSH
23186: CALL_OW 74
23190: PPUSH
23191: CALL_OW 115
// until IsDead ( un ) ;
23195: LD_VAR 0 2
23199: PPUSH
23200: CALL_OW 301
23204: IFFALSE 23152
// end ;
23206: PPOPN 2
23208: END
// every 0 0$1 trigger StreamModeActive and sStu do
23209: LD_EXP 51
23213: PUSH
23214: LD_EXP 90
23218: AND
23219: IFFALSE 23235
23221: GO 23223
23223: DISABLE
// begin ToLua ( displayStucuk(); ) ;
23224: LD_STRING displayStucuk();
23226: PPUSH
23227: CALL_OW 559
// ResetFog ;
23231: CALL_OW 335
// end ;
23235: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
23236: LD_EXP 51
23240: PUSH
23241: LD_EXP 83
23245: AND
23246: IFFALSE 23387
23248: GO 23250
23250: DISABLE
23251: LD_INT 0
23253: PPUSH
23254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23255: LD_ADDR_VAR 0 2
23259: PUSH
23260: LD_INT 22
23262: PUSH
23263: LD_OWVAR 2
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: LD_INT 21
23274: PUSH
23275: LD_INT 1
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: PUSH
23282: EMPTY
23283: LIST
23284: LIST
23285: PPUSH
23286: CALL_OW 69
23290: ST_TO_ADDR
// if not tmp then
23291: LD_VAR 0 2
23295: NOT
23296: IFFALSE 23300
// exit ;
23298: GO 23387
// un := tmp [ rand ( 1 , tmp ) ] ;
23300: LD_ADDR_VAR 0 1
23304: PUSH
23305: LD_VAR 0 2
23309: PUSH
23310: LD_INT 1
23312: PPUSH
23313: LD_VAR 0 2
23317: PPUSH
23318: CALL_OW 12
23322: ARRAY
23323: ST_TO_ADDR
// SetSide ( un , 0 ) ;
23324: LD_VAR 0 1
23328: PPUSH
23329: LD_INT 0
23331: PPUSH
23332: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
23336: LD_VAR 0 1
23340: PPUSH
23341: LD_OWVAR 3
23345: PUSH
23346: LD_VAR 0 1
23350: DIFF
23351: PPUSH
23352: LD_VAR 0 1
23356: PPUSH
23357: CALL_OW 74
23361: PPUSH
23362: CALL_OW 115
// wait ( 0 0$20 ) ;
23366: LD_INT 700
23368: PPUSH
23369: CALL_OW 67
// SetSide ( un , your_side ) ;
23373: LD_VAR 0 1
23377: PPUSH
23378: LD_OWVAR 2
23382: PPUSH
23383: CALL_OW 235
// end ;
23387: PPOPN 2
23389: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
23390: LD_EXP 51
23394: PUSH
23395: LD_EXP 84
23399: AND
23400: IFFALSE 23506
23402: GO 23404
23404: DISABLE
23405: LD_INT 0
23407: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23408: LD_ADDR_VAR 0 1
23412: PUSH
23413: LD_INT 22
23415: PUSH
23416: LD_OWVAR 2
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: LD_INT 2
23427: PUSH
23428: LD_INT 30
23430: PUSH
23431: LD_INT 0
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: PUSH
23438: LD_INT 30
23440: PUSH
23441: LD_INT 1
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: LIST
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: ST_TO_ADDR
// if not depot then
23462: LD_VAR 0 1
23466: NOT
23467: IFFALSE 23471
// exit ;
23469: GO 23506
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
23471: LD_VAR 0 1
23475: PUSH
23476: LD_INT 1
23478: ARRAY
23479: PPUSH
23480: CALL_OW 250
23484: PPUSH
23485: LD_VAR 0 1
23489: PUSH
23490: LD_INT 1
23492: ARRAY
23493: PPUSH
23494: CALL_OW 251
23498: PPUSH
23499: LD_INT 70
23501: PPUSH
23502: CALL_OW 495
// end ;
23506: PPOPN 1
23508: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
23509: LD_EXP 51
23513: PUSH
23514: LD_EXP 85
23518: AND
23519: IFFALSE 23730
23521: GO 23523
23523: DISABLE
23524: LD_INT 0
23526: PPUSH
23527: PPUSH
23528: PPUSH
23529: PPUSH
23530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23531: LD_ADDR_VAR 0 5
23535: PUSH
23536: LD_INT 22
23538: PUSH
23539: LD_OWVAR 2
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: PUSH
23548: LD_INT 21
23550: PUSH
23551: LD_INT 1
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PPUSH
23562: CALL_OW 69
23566: ST_TO_ADDR
// if not tmp then
23567: LD_VAR 0 5
23571: NOT
23572: IFFALSE 23576
// exit ;
23574: GO 23730
// for i in tmp do
23576: LD_ADDR_VAR 0 1
23580: PUSH
23581: LD_VAR 0 5
23585: PUSH
23586: FOR_IN
23587: IFFALSE 23728
// begin d := rand ( 0 , 5 ) ;
23589: LD_ADDR_VAR 0 4
23593: PUSH
23594: LD_INT 0
23596: PPUSH
23597: LD_INT 5
23599: PPUSH
23600: CALL_OW 12
23604: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
23605: LD_ADDR_VAR 0 2
23609: PUSH
23610: LD_VAR 0 1
23614: PPUSH
23615: CALL_OW 250
23619: PPUSH
23620: LD_VAR 0 4
23624: PPUSH
23625: LD_INT 3
23627: PPUSH
23628: LD_INT 12
23630: PPUSH
23631: CALL_OW 12
23635: PPUSH
23636: CALL_OW 272
23640: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
23641: LD_ADDR_VAR 0 3
23645: PUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: CALL_OW 251
23655: PPUSH
23656: LD_VAR 0 4
23660: PPUSH
23661: LD_INT 3
23663: PPUSH
23664: LD_INT 12
23666: PPUSH
23667: CALL_OW 12
23671: PPUSH
23672: CALL_OW 273
23676: ST_TO_ADDR
// if ValidHex ( x , y ) then
23677: LD_VAR 0 2
23681: PPUSH
23682: LD_VAR 0 3
23686: PPUSH
23687: CALL_OW 488
23691: IFFALSE 23726
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
23693: LD_VAR 0 1
23697: PPUSH
23698: LD_VAR 0 2
23702: PPUSH
23703: LD_VAR 0 3
23707: PPUSH
23708: LD_INT 3
23710: PPUSH
23711: LD_INT 6
23713: PPUSH
23714: CALL_OW 12
23718: PPUSH
23719: LD_INT 1
23721: PPUSH
23722: CALL_OW 483
// end ;
23726: GO 23586
23728: POP
23729: POP
// end ;
23730: PPOPN 5
23732: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
23733: LD_EXP 51
23737: PUSH
23738: LD_EXP 86
23742: AND
23743: IFFALSE 23837
23745: GO 23747
23747: DISABLE
23748: LD_INT 0
23750: PPUSH
23751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
23752: LD_ADDR_VAR 0 2
23756: PUSH
23757: LD_INT 22
23759: PUSH
23760: LD_OWVAR 2
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 32
23771: PUSH
23772: LD_INT 1
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: LD_INT 21
23781: PUSH
23782: LD_INT 2
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: LIST
23793: PPUSH
23794: CALL_OW 69
23798: ST_TO_ADDR
// if not tmp then
23799: LD_VAR 0 2
23803: NOT
23804: IFFALSE 23808
// exit ;
23806: GO 23837
// for i in tmp do
23808: LD_ADDR_VAR 0 1
23812: PUSH
23813: LD_VAR 0 2
23817: PUSH
23818: FOR_IN
23819: IFFALSE 23835
// SetFuel ( i , 0 ) ;
23821: LD_VAR 0 1
23825: PPUSH
23826: LD_INT 0
23828: PPUSH
23829: CALL_OW 240
23833: GO 23818
23835: POP
23836: POP
// end ;
23837: PPOPN 2
23839: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
23840: LD_EXP 51
23844: PUSH
23845: LD_EXP 87
23849: AND
23850: IFFALSE 23916
23852: GO 23854
23854: DISABLE
23855: LD_INT 0
23857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
23858: LD_ADDR_VAR 0 1
23862: PUSH
23863: LD_INT 22
23865: PUSH
23866: LD_OWVAR 2
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: PUSH
23875: LD_INT 30
23877: PUSH
23878: LD_INT 29
23880: PUSH
23881: EMPTY
23882: LIST
23883: LIST
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PPUSH
23889: CALL_OW 69
23893: ST_TO_ADDR
// if not tmp then
23894: LD_VAR 0 1
23898: NOT
23899: IFFALSE 23903
// exit ;
23901: GO 23916
// DestroyUnit ( tmp [ 1 ] ) ;
23903: LD_VAR 0 1
23907: PUSH
23908: LD_INT 1
23910: ARRAY
23911: PPUSH
23912: CALL_OW 65
// end ;
23916: PPOPN 1
23918: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
23919: LD_EXP 51
23923: PUSH
23924: LD_EXP 89
23928: AND
23929: IFFALSE 24058
23931: GO 23933
23933: DISABLE
23934: LD_INT 0
23936: PPUSH
// begin uc_side := 0 ;
23937: LD_ADDR_OWVAR 20
23941: PUSH
23942: LD_INT 0
23944: ST_TO_ADDR
// uc_nation := nation_arabian ;
23945: LD_ADDR_OWVAR 21
23949: PUSH
23950: LD_INT 2
23952: ST_TO_ADDR
// hc_gallery :=  ;
23953: LD_ADDR_OWVAR 33
23957: PUSH
23958: LD_STRING 
23960: ST_TO_ADDR
// hc_name :=  ;
23961: LD_ADDR_OWVAR 26
23965: PUSH
23966: LD_STRING 
23968: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
23969: LD_INT 1
23971: PPUSH
23972: LD_INT 11
23974: PPUSH
23975: LD_INT 10
23977: PPUSH
23978: CALL_OW 380
// un := CreateHuman ;
23982: LD_ADDR_VAR 0 1
23986: PUSH
23987: CALL_OW 44
23991: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23992: LD_VAR 0 1
23996: PPUSH
23997: LD_INT 1
23999: PPUSH
24000: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
24004: LD_INT 35
24006: PPUSH
24007: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
24011: LD_VAR 0 1
24015: PPUSH
24016: LD_INT 22
24018: PUSH
24019: LD_OWVAR 2
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: PPUSH
24028: CALL_OW 69
24032: PPUSH
24033: LD_VAR 0 1
24037: PPUSH
24038: CALL_OW 74
24042: PPUSH
24043: CALL_OW 115
// until IsDead ( un ) ;
24047: LD_VAR 0 1
24051: PPUSH
24052: CALL_OW 301
24056: IFFALSE 24004
// end ;
24058: PPOPN 1
24060: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
24061: LD_EXP 51
24065: PUSH
24066: LD_EXP 91
24070: AND
24071: IFFALSE 24083
24073: GO 24075
24075: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
24076: LD_STRING earthquake(getX(game), 0, 32)
24078: PPUSH
24079: CALL_OW 559
24083: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
24084: LD_EXP 51
24088: PUSH
24089: LD_EXP 92
24093: AND
24094: IFFALSE 24185
24096: GO 24098
24098: DISABLE
24099: LD_INT 0
24101: PPUSH
// begin enable ;
24102: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
24103: LD_ADDR_VAR 0 1
24107: PUSH
24108: LD_INT 22
24110: PUSH
24111: LD_OWVAR 2
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: LD_INT 21
24122: PUSH
24123: LD_INT 2
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 33
24132: PUSH
24133: LD_INT 3
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: LIST
24144: PPUSH
24145: CALL_OW 69
24149: ST_TO_ADDR
// if not tmp then
24150: LD_VAR 0 1
24154: NOT
24155: IFFALSE 24159
// exit ;
24157: GO 24185
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
24159: LD_VAR 0 1
24163: PUSH
24164: LD_INT 1
24166: PPUSH
24167: LD_VAR 0 1
24171: PPUSH
24172: CALL_OW 12
24176: ARRAY
24177: PPUSH
24178: LD_INT 1
24180: PPUSH
24181: CALL_OW 234
// end ;
24185: PPOPN 1
24187: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
24188: LD_EXP 51
24192: PUSH
24193: LD_EXP 93
24197: AND
24198: IFFALSE 24339
24200: GO 24202
24202: DISABLE
24203: LD_INT 0
24205: PPUSH
24206: PPUSH
24207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24208: LD_ADDR_VAR 0 3
24212: PUSH
24213: LD_INT 22
24215: PUSH
24216: LD_OWVAR 2
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 25
24227: PUSH
24228: LD_INT 1
24230: PUSH
24231: EMPTY
24232: LIST
24233: LIST
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: PPUSH
24239: CALL_OW 69
24243: ST_TO_ADDR
// if not tmp then
24244: LD_VAR 0 3
24248: NOT
24249: IFFALSE 24253
// exit ;
24251: GO 24339
// un := tmp [ rand ( 1 , tmp ) ] ;
24253: LD_ADDR_VAR 0 2
24257: PUSH
24258: LD_VAR 0 3
24262: PUSH
24263: LD_INT 1
24265: PPUSH
24266: LD_VAR 0 3
24270: PPUSH
24271: CALL_OW 12
24275: ARRAY
24276: ST_TO_ADDR
// if Crawls ( un ) then
24277: LD_VAR 0 2
24281: PPUSH
24282: CALL_OW 318
24286: IFFALSE 24297
// ComWalk ( un ) ;
24288: LD_VAR 0 2
24292: PPUSH
24293: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
24297: LD_VAR 0 2
24301: PPUSH
24302: LD_INT 9
24304: PPUSH
24305: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
24309: LD_INT 28
24311: PPUSH
24312: LD_OWVAR 2
24316: PPUSH
24317: LD_INT 2
24319: PPUSH
24320: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
24324: LD_INT 29
24326: PPUSH
24327: LD_OWVAR 2
24331: PPUSH
24332: LD_INT 2
24334: PPUSH
24335: CALL_OW 322
// end ;
24339: PPOPN 3
24341: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
24342: LD_EXP 51
24346: PUSH
24347: LD_EXP 94
24351: AND
24352: IFFALSE 24463
24354: GO 24356
24356: DISABLE
24357: LD_INT 0
24359: PPUSH
24360: PPUSH
24361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24362: LD_ADDR_VAR 0 3
24366: PUSH
24367: LD_INT 22
24369: PUSH
24370: LD_OWVAR 2
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 25
24381: PUSH
24382: LD_INT 1
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: PPUSH
24393: CALL_OW 69
24397: ST_TO_ADDR
// if not tmp then
24398: LD_VAR 0 3
24402: NOT
24403: IFFALSE 24407
// exit ;
24405: GO 24463
// un := tmp [ rand ( 1 , tmp ) ] ;
24407: LD_ADDR_VAR 0 2
24411: PUSH
24412: LD_VAR 0 3
24416: PUSH
24417: LD_INT 1
24419: PPUSH
24420: LD_VAR 0 3
24424: PPUSH
24425: CALL_OW 12
24429: ARRAY
24430: ST_TO_ADDR
// if Crawls ( un ) then
24431: LD_VAR 0 2
24435: PPUSH
24436: CALL_OW 318
24440: IFFALSE 24451
// ComWalk ( un ) ;
24442: LD_VAR 0 2
24446: PPUSH
24447: CALL_OW 138
// SetClass ( un , class_mortar ) ;
24451: LD_VAR 0 2
24455: PPUSH
24456: LD_INT 8
24458: PPUSH
24459: CALL_OW 336
// end ;
24463: PPOPN 3
24465: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
24466: LD_EXP 51
24470: PUSH
24471: LD_EXP 95
24475: AND
24476: IFFALSE 24620
24478: GO 24480
24480: DISABLE
24481: LD_INT 0
24483: PPUSH
24484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
24485: LD_ADDR_VAR 0 2
24489: PUSH
24490: LD_INT 22
24492: PUSH
24493: LD_OWVAR 2
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 21
24504: PUSH
24505: LD_INT 2
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: PUSH
24512: LD_INT 2
24514: PUSH
24515: LD_INT 34
24517: PUSH
24518: LD_INT 12
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 34
24527: PUSH
24528: LD_INT 51
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 34
24537: PUSH
24538: LD_INT 32
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: LIST
24555: PPUSH
24556: CALL_OW 69
24560: ST_TO_ADDR
// if not tmp then
24561: LD_VAR 0 2
24565: NOT
24566: IFFALSE 24570
// exit ;
24568: GO 24620
// for i in tmp do
24570: LD_ADDR_VAR 0 1
24574: PUSH
24575: LD_VAR 0 2
24579: PUSH
24580: FOR_IN
24581: IFFALSE 24618
// if GetCargo ( i , mat_artifact ) = 0 then
24583: LD_VAR 0 1
24587: PPUSH
24588: LD_INT 4
24590: PPUSH
24591: CALL_OW 289
24595: PUSH
24596: LD_INT 0
24598: EQUAL
24599: IFFALSE 24616
// SetCargo ( i , mat_siberit , 100 ) ;
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 3
24608: PPUSH
24609: LD_INT 100
24611: PPUSH
24612: CALL_OW 290
24616: GO 24580
24618: POP
24619: POP
// end ;
24620: PPOPN 2
24622: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
24623: LD_EXP 51
24627: PUSH
24628: LD_EXP 96
24632: AND
24633: IFFALSE 24786
24635: GO 24637
24637: DISABLE
24638: LD_INT 0
24640: PPUSH
24641: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
24642: LD_ADDR_VAR 0 2
24646: PUSH
24647: LD_INT 22
24649: PUSH
24650: LD_OWVAR 2
24654: PUSH
24655: EMPTY
24656: LIST
24657: LIST
24658: PPUSH
24659: CALL_OW 69
24663: ST_TO_ADDR
// if not tmp then
24664: LD_VAR 0 2
24668: NOT
24669: IFFALSE 24673
// exit ;
24671: GO 24786
// for i := 1 to 2 do
24673: LD_ADDR_VAR 0 1
24677: PUSH
24678: DOUBLE
24679: LD_INT 1
24681: DEC
24682: ST_TO_ADDR
24683: LD_INT 2
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24784
// begin uc_side := your_side ;
24689: LD_ADDR_OWVAR 20
24693: PUSH
24694: LD_OWVAR 2
24698: ST_TO_ADDR
// uc_nation := nation_american ;
24699: LD_ADDR_OWVAR 21
24703: PUSH
24704: LD_INT 1
24706: ST_TO_ADDR
// vc_chassis := us_morphling ;
24707: LD_ADDR_OWVAR 37
24711: PUSH
24712: LD_INT 5
24714: ST_TO_ADDR
// vc_engine := engine_siberite ;
24715: LD_ADDR_OWVAR 39
24719: PUSH
24720: LD_INT 3
24722: ST_TO_ADDR
// vc_control := control_computer ;
24723: LD_ADDR_OWVAR 38
24727: PUSH
24728: LD_INT 3
24730: ST_TO_ADDR
// vc_weapon := us_double_laser ;
24731: LD_ADDR_OWVAR 40
24735: PUSH
24736: LD_INT 10
24738: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
24739: CALL_OW 45
24743: PPUSH
24744: LD_VAR 0 2
24748: PUSH
24749: LD_INT 1
24751: ARRAY
24752: PPUSH
24753: CALL_OW 250
24757: PPUSH
24758: LD_VAR 0 2
24762: PUSH
24763: LD_INT 1
24765: ARRAY
24766: PPUSH
24767: CALL_OW 251
24771: PPUSH
24772: LD_INT 12
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 50
// end ;
24782: GO 24686
24784: POP
24785: POP
// end ;
24786: PPOPN 2
24788: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
24789: LD_EXP 51
24793: PUSH
24794: LD_EXP 97
24798: AND
24799: IFFALSE 25021
24801: GO 24803
24803: DISABLE
24804: LD_INT 0
24806: PPUSH
24807: PPUSH
24808: PPUSH
24809: PPUSH
24810: PPUSH
24811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
24812: LD_ADDR_VAR 0 6
24816: PUSH
24817: LD_INT 22
24819: PUSH
24820: LD_OWVAR 2
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: LD_INT 21
24831: PUSH
24832: LD_INT 1
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PUSH
24839: LD_INT 3
24841: PUSH
24842: LD_INT 23
24844: PUSH
24845: LD_INT 0
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: LIST
24860: PPUSH
24861: CALL_OW 69
24865: ST_TO_ADDR
// if not tmp then
24866: LD_VAR 0 6
24870: NOT
24871: IFFALSE 24875
// exit ;
24873: GO 25021
// s1 := rand ( 1 , 4 ) ;
24875: LD_ADDR_VAR 0 2
24879: PUSH
24880: LD_INT 1
24882: PPUSH
24883: LD_INT 4
24885: PPUSH
24886: CALL_OW 12
24890: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
24891: LD_ADDR_VAR 0 4
24895: PUSH
24896: LD_VAR 0 6
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: PPUSH
24905: LD_VAR 0 2
24909: PPUSH
24910: CALL_OW 259
24914: ST_TO_ADDR
// if s1 = 1 then
24915: LD_VAR 0 2
24919: PUSH
24920: LD_INT 1
24922: EQUAL
24923: IFFALSE 24943
// s2 := rand ( 2 , 4 ) else
24925: LD_ADDR_VAR 0 3
24929: PUSH
24930: LD_INT 2
24932: PPUSH
24933: LD_INT 4
24935: PPUSH
24936: CALL_OW 12
24940: ST_TO_ADDR
24941: GO 24951
// s2 := 1 ;
24943: LD_ADDR_VAR 0 3
24947: PUSH
24948: LD_INT 1
24950: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
24951: LD_ADDR_VAR 0 5
24955: PUSH
24956: LD_VAR 0 6
24960: PUSH
24961: LD_INT 1
24963: ARRAY
24964: PPUSH
24965: LD_VAR 0 3
24969: PPUSH
24970: CALL_OW 259
24974: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
24975: LD_VAR 0 6
24979: PUSH
24980: LD_INT 1
24982: ARRAY
24983: PPUSH
24984: LD_VAR 0 2
24988: PPUSH
24989: LD_VAR 0 5
24993: PPUSH
24994: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
24998: LD_VAR 0 6
25002: PUSH
25003: LD_INT 1
25005: ARRAY
25006: PPUSH
25007: LD_VAR 0 3
25011: PPUSH
25012: LD_VAR 0 4
25016: PPUSH
25017: CALL_OW 237
// end ;
25021: PPOPN 6
25023: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
25024: LD_EXP 51
25028: PUSH
25029: LD_EXP 98
25033: AND
25034: IFFALSE 25113
25036: GO 25038
25038: DISABLE
25039: LD_INT 0
25041: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
25042: LD_ADDR_VAR 0 1
25046: PUSH
25047: LD_INT 22
25049: PUSH
25050: LD_OWVAR 2
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 30
25061: PUSH
25062: LD_INT 3
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: PPUSH
25073: CALL_OW 69
25077: ST_TO_ADDR
// if not tmp then
25078: LD_VAR 0 1
25082: NOT
25083: IFFALSE 25087
// exit ;
25085: GO 25113
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
25087: LD_VAR 0 1
25091: PUSH
25092: LD_INT 1
25094: PPUSH
25095: LD_VAR 0 1
25099: PPUSH
25100: CALL_OW 12
25104: ARRAY
25105: PPUSH
25106: LD_INT 1
25108: PPUSH
25109: CALL_OW 234
// end ;
25113: PPOPN 1
25115: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
25116: LD_EXP 51
25120: PUSH
25121: LD_EXP 99
25125: AND
25126: IFFALSE 25238
25128: GO 25130
25130: DISABLE
25131: LD_INT 0
25133: PPUSH
25134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
25135: LD_ADDR_VAR 0 2
25139: PUSH
25140: LD_INT 22
25142: PUSH
25143: LD_OWVAR 2
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: PUSH
25152: LD_INT 2
25154: PUSH
25155: LD_INT 30
25157: PUSH
25158: LD_INT 27
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: PUSH
25165: LD_INT 30
25167: PUSH
25168: LD_INT 26
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PUSH
25175: LD_INT 30
25177: PUSH
25178: LD_INT 28
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: EMPTY
25186: LIST
25187: LIST
25188: LIST
25189: LIST
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PPUSH
25195: CALL_OW 69
25199: ST_TO_ADDR
// if not tmp then
25200: LD_VAR 0 2
25204: NOT
25205: IFFALSE 25209
// exit ;
25207: GO 25238
// for i in tmp do
25209: LD_ADDR_VAR 0 1
25213: PUSH
25214: LD_VAR 0 2
25218: PUSH
25219: FOR_IN
25220: IFFALSE 25236
// SetLives ( i , 1 ) ;
25222: LD_VAR 0 1
25226: PPUSH
25227: LD_INT 1
25229: PPUSH
25230: CALL_OW 234
25234: GO 25219
25236: POP
25237: POP
// end ;
25238: PPOPN 2
25240: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
25241: LD_EXP 51
25245: PUSH
25246: LD_EXP 100
25250: AND
25251: IFFALSE 25525
25253: GO 25255
25255: DISABLE
25256: LD_INT 0
25258: PPUSH
25259: PPUSH
25260: PPUSH
// begin i := rand ( 1 , 7 ) ;
25261: LD_ADDR_VAR 0 1
25265: PUSH
25266: LD_INT 1
25268: PPUSH
25269: LD_INT 7
25271: PPUSH
25272: CALL_OW 12
25276: ST_TO_ADDR
// case i of 1 :
25277: LD_VAR 0 1
25281: PUSH
25282: LD_INT 1
25284: DOUBLE
25285: EQUAL
25286: IFTRUE 25290
25288: GO 25300
25290: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
25291: LD_STRING earthquake(getX(game), 0, 32)
25293: PPUSH
25294: CALL_OW 559
25298: GO 25525
25300: LD_INT 2
25302: DOUBLE
25303: EQUAL
25304: IFTRUE 25308
25306: GO 25322
25308: POP
// begin ToLua ( displayStucuk(); ) ;
25309: LD_STRING displayStucuk();
25311: PPUSH
25312: CALL_OW 559
// ResetFog ;
25316: CALL_OW 335
// end ; 3 :
25320: GO 25525
25322: LD_INT 3
25324: DOUBLE
25325: EQUAL
25326: IFTRUE 25330
25328: GO 25434
25330: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25331: LD_ADDR_VAR 0 2
25335: PUSH
25336: LD_INT 22
25338: PUSH
25339: LD_OWVAR 2
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 25
25350: PUSH
25351: LD_INT 1
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PPUSH
25362: CALL_OW 69
25366: ST_TO_ADDR
// if not tmp then
25367: LD_VAR 0 2
25371: NOT
25372: IFFALSE 25376
// exit ;
25374: GO 25525
// un := tmp [ rand ( 1 , tmp ) ] ;
25376: LD_ADDR_VAR 0 3
25380: PUSH
25381: LD_VAR 0 2
25385: PUSH
25386: LD_INT 1
25388: PPUSH
25389: LD_VAR 0 2
25393: PPUSH
25394: CALL_OW 12
25398: ARRAY
25399: ST_TO_ADDR
// if Crawls ( un ) then
25400: LD_VAR 0 3
25404: PPUSH
25405: CALL_OW 318
25409: IFFALSE 25420
// ComWalk ( un ) ;
25411: LD_VAR 0 3
25415: PPUSH
25416: CALL_OW 138
// SetClass ( un , class_mortar ) ;
25420: LD_VAR 0 3
25424: PPUSH
25425: LD_INT 8
25427: PPUSH
25428: CALL_OW 336
// end ; 4 :
25432: GO 25525
25434: LD_INT 4
25436: DOUBLE
25437: EQUAL
25438: IFTRUE 25442
25440: GO 25503
25442: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
25443: LD_ADDR_VAR 0 2
25447: PUSH
25448: LD_INT 22
25450: PUSH
25451: LD_OWVAR 2
25455: PUSH
25456: EMPTY
25457: LIST
25458: LIST
25459: PUSH
25460: LD_INT 30
25462: PUSH
25463: LD_INT 29
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PPUSH
25474: CALL_OW 69
25478: ST_TO_ADDR
// if not tmp then
25479: LD_VAR 0 2
25483: NOT
25484: IFFALSE 25488
// exit ;
25486: GO 25525
// DestroyUnit ( tmp [ 1 ] ) ;
25488: LD_VAR 0 2
25492: PUSH
25493: LD_INT 1
25495: ARRAY
25496: PPUSH
25497: CALL_OW 65
// end ; 5 .. 7 :
25501: GO 25525
25503: LD_INT 5
25505: DOUBLE
25506: GREATEREQUAL
25507: IFFALSE 25515
25509: LD_INT 7
25511: DOUBLE
25512: LESSEQUAL
25513: IFTRUE 25517
25515: GO 25524
25517: POP
// StreamSibBomb ; end ;
25518: CALL 21805 0 0
25522: GO 25525
25524: POP
// end ;
25525: PPOPN 3
25527: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
25528: LD_EXP 51
25532: PUSH
25533: LD_EXP 101
25537: AND
25538: IFFALSE 25694
25540: GO 25542
25542: DISABLE
25543: LD_INT 0
25545: PPUSH
25546: PPUSH
25547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
25548: LD_ADDR_VAR 0 2
25552: PUSH
25553: LD_INT 81
25555: PUSH
25556: LD_OWVAR 2
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PUSH
25565: LD_INT 2
25567: PUSH
25568: LD_INT 21
25570: PUSH
25571: LD_INT 1
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: LD_INT 21
25580: PUSH
25581: LD_INT 2
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PPUSH
25597: CALL_OW 69
25601: ST_TO_ADDR
// if not tmp then
25602: LD_VAR 0 2
25606: NOT
25607: IFFALSE 25611
// exit ;
25609: GO 25694
// p := 0 ;
25611: LD_ADDR_VAR 0 3
25615: PUSH
25616: LD_INT 0
25618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
25619: LD_INT 35
25621: PPUSH
25622: CALL_OW 67
// p := p + 1 ;
25626: LD_ADDR_VAR 0 3
25630: PUSH
25631: LD_VAR 0 3
25635: PUSH
25636: LD_INT 1
25638: PLUS
25639: ST_TO_ADDR
// for i in tmp do
25640: LD_ADDR_VAR 0 1
25644: PUSH
25645: LD_VAR 0 2
25649: PUSH
25650: FOR_IN
25651: IFFALSE 25682
// if GetLives ( i ) < 1000 then
25653: LD_VAR 0 1
25657: PPUSH
25658: CALL_OW 256
25662: PUSH
25663: LD_INT 1000
25665: LESS
25666: IFFALSE 25680
// SetLives ( i , 1000 ) ;
25668: LD_VAR 0 1
25672: PPUSH
25673: LD_INT 1000
25675: PPUSH
25676: CALL_OW 234
25680: GO 25650
25682: POP
25683: POP
// until p > 20 ;
25684: LD_VAR 0 3
25688: PUSH
25689: LD_INT 20
25691: GREATER
25692: IFFALSE 25619
// end ;
25694: PPOPN 3
25696: END
// every 0 0$1 trigger StreamModeActive and sTime do
25697: LD_EXP 51
25701: PUSH
25702: LD_EXP 102
25706: AND
25707: IFFALSE 25742
25709: GO 25711
25711: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
25712: LD_INT 28
25714: PPUSH
25715: LD_OWVAR 2
25719: PPUSH
25720: LD_INT 2
25722: PPUSH
25723: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
25727: LD_INT 30
25729: PPUSH
25730: LD_OWVAR 2
25734: PPUSH
25735: LD_INT 2
25737: PPUSH
25738: CALL_OW 322
// end ;
25742: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
25743: LD_EXP 51
25747: PUSH
25748: LD_EXP 103
25752: AND
25753: IFFALSE 25874
25755: GO 25757
25757: DISABLE
25758: LD_INT 0
25760: PPUSH
25761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25762: LD_ADDR_VAR 0 2
25766: PUSH
25767: LD_INT 22
25769: PUSH
25770: LD_OWVAR 2
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: LD_INT 21
25781: PUSH
25782: LD_INT 1
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: PUSH
25789: LD_INT 3
25791: PUSH
25792: LD_INT 23
25794: PUSH
25795: LD_INT 0
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: LIST
25810: PPUSH
25811: CALL_OW 69
25815: ST_TO_ADDR
// if not tmp then
25816: LD_VAR 0 2
25820: NOT
25821: IFFALSE 25825
// exit ;
25823: GO 25874
// for i in tmp do
25825: LD_ADDR_VAR 0 1
25829: PUSH
25830: LD_VAR 0 2
25834: PUSH
25835: FOR_IN
25836: IFFALSE 25872
// begin if Crawls ( i ) then
25838: LD_VAR 0 1
25842: PPUSH
25843: CALL_OW 318
25847: IFFALSE 25858
// ComWalk ( i ) ;
25849: LD_VAR 0 1
25853: PPUSH
25854: CALL_OW 138
// SetClass ( i , 2 ) ;
25858: LD_VAR 0 1
25862: PPUSH
25863: LD_INT 2
25865: PPUSH
25866: CALL_OW 336
// end ;
25870: GO 25835
25872: POP
25873: POP
// end ;
25874: PPOPN 2
25876: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
25877: LD_EXP 51
25881: PUSH
25882: LD_EXP 104
25886: AND
25887: IFFALSE 26108
25889: GO 25891
25891: DISABLE
25892: LD_INT 0
25894: PPUSH
25895: PPUSH
25896: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
25897: LD_OWVAR 2
25901: PPUSH
25902: LD_INT 9
25904: PPUSH
25905: LD_INT 1
25907: PPUSH
25908: LD_INT 1
25910: PPUSH
25911: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
25915: LD_INT 9
25917: PPUSH
25918: LD_OWVAR 2
25922: PPUSH
25923: CALL_OW 343
// uc_side := 9 ;
25927: LD_ADDR_OWVAR 20
25931: PUSH
25932: LD_INT 9
25934: ST_TO_ADDR
// uc_nation := 2 ;
25935: LD_ADDR_OWVAR 21
25939: PUSH
25940: LD_INT 2
25942: ST_TO_ADDR
// hc_name := Dark Warrior ;
25943: LD_ADDR_OWVAR 26
25947: PUSH
25948: LD_STRING Dark Warrior
25950: ST_TO_ADDR
// hc_gallery :=  ;
25951: LD_ADDR_OWVAR 33
25955: PUSH
25956: LD_STRING 
25958: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
25959: LD_INT 1
25961: PPUSH
25962: LD_INT 1
25964: PPUSH
25965: LD_INT 10
25967: PPUSH
25968: CALL_OW 380
// un := CreateHuman ;
25972: LD_ADDR_VAR 0 3
25976: PUSH
25977: CALL_OW 44
25981: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
25982: LD_VAR 0 3
25986: PPUSH
25987: LD_INT 1
25989: PPUSH
25990: CALL_OW 51
// p := 0 ;
25994: LD_ADDR_VAR 0 2
25998: PUSH
25999: LD_INT 0
26001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26002: LD_INT 35
26004: PPUSH
26005: CALL_OW 67
// if GetLives ( un ) < 1000 then
26009: LD_VAR 0 3
26013: PPUSH
26014: CALL_OW 256
26018: PUSH
26019: LD_INT 1000
26021: LESS
26022: IFFALSE 26036
// SetLives ( un , 1000 ) ;
26024: LD_VAR 0 3
26028: PPUSH
26029: LD_INT 1000
26031: PPUSH
26032: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
26036: LD_VAR 0 3
26040: PPUSH
26041: LD_INT 81
26043: PUSH
26044: LD_OWVAR 2
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PPUSH
26053: CALL_OW 69
26057: PPUSH
26058: LD_VAR 0 3
26062: PPUSH
26063: CALL_OW 74
26067: PPUSH
26068: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
26072: LD_VAR 0 2
26076: PUSH
26077: LD_INT 60
26079: GREATER
26080: PUSH
26081: LD_VAR 0 3
26085: PPUSH
26086: CALL_OW 301
26090: OR
26091: IFFALSE 26002
// if un then
26093: LD_VAR 0 3
26097: IFFALSE 26108
// RemoveUnit ( un ) ;
26099: LD_VAR 0 3
26103: PPUSH
26104: CALL_OW 64
// end ; end_of_file
26108: PPOPN 3
26110: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
26111: LD_INT 0
26113: PPUSH
26114: PPUSH
26115: PPUSH
26116: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
26117: LD_VAR 0 1
26121: PPUSH
26122: CALL_OW 264
26126: PUSH
26127: LD_EXP 50
26131: EQUAL
26132: IFFALSE 26204
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
26134: LD_INT 68
26136: PPUSH
26137: LD_VAR 0 1
26141: PPUSH
26142: CALL_OW 255
26146: PPUSH
26147: CALL_OW 321
26151: PUSH
26152: LD_INT 2
26154: EQUAL
26155: IFFALSE 26167
// eff := 70 else
26157: LD_ADDR_VAR 0 6
26161: PUSH
26162: LD_INT 70
26164: ST_TO_ADDR
26165: GO 26175
// eff := 30 ;
26167: LD_ADDR_VAR 0 6
26171: PUSH
26172: LD_INT 30
26174: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
26175: LD_VAR 0 1
26179: PPUSH
26180: CALL_OW 250
26184: PPUSH
26185: LD_VAR 0 1
26189: PPUSH
26190: CALL_OW 251
26194: PPUSH
26195: LD_VAR 0 6
26199: PPUSH
26200: CALL_OW 495
// end ; end ;
26204: LD_VAR 0 4
26208: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
26209: LD_INT 0
26211: PPUSH
26212: PPUSH
26213: PPUSH
26214: PPUSH
26215: PPUSH
26216: PPUSH
// if cmd = 124 then
26217: LD_VAR 0 1
26221: PUSH
26222: LD_INT 124
26224: EQUAL
26225: IFFALSE 26431
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
26227: LD_ADDR_VAR 0 5
26231: PUSH
26232: LD_INT 2
26234: PUSH
26235: LD_INT 34
26237: PUSH
26238: LD_INT 53
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 34
26247: PUSH
26248: LD_INT 14
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: LIST
26259: PPUSH
26260: CALL_OW 69
26264: ST_TO_ADDR
// if not tmp then
26265: LD_VAR 0 5
26269: NOT
26270: IFFALSE 26274
// exit ;
26272: GO 26431
// for i in tmp do
26274: LD_ADDR_VAR 0 3
26278: PUSH
26279: LD_VAR 0 5
26283: PUSH
26284: FOR_IN
26285: IFFALSE 26429
// begin taskList := GetTaskList ( i ) ;
26287: LD_ADDR_VAR 0 6
26291: PUSH
26292: LD_VAR 0 3
26296: PPUSH
26297: CALL_OW 437
26301: ST_TO_ADDR
// if not taskList then
26302: LD_VAR 0 6
26306: NOT
26307: IFFALSE 26311
// continue ;
26309: GO 26284
// for j = 1 to taskList do
26311: LD_ADDR_VAR 0 4
26315: PUSH
26316: DOUBLE
26317: LD_INT 1
26319: DEC
26320: ST_TO_ADDR
26321: LD_VAR 0 6
26325: PUSH
26326: FOR_TO
26327: IFFALSE 26425
// if taskList [ j ] [ 1 ] = | then
26329: LD_VAR 0 6
26333: PUSH
26334: LD_VAR 0 4
26338: ARRAY
26339: PUSH
26340: LD_INT 1
26342: ARRAY
26343: PUSH
26344: LD_STRING |
26346: EQUAL
26347: IFFALSE 26423
// begin _taskList := Delete ( taskList , 1 ) ;
26349: LD_ADDR_VAR 0 7
26353: PUSH
26354: LD_VAR 0 6
26358: PPUSH
26359: LD_INT 1
26361: PPUSH
26362: CALL_OW 3
26366: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
26367: LD_VAR 0 3
26371: PPUSH
26372: LD_VAR 0 7
26376: PPUSH
26377: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
26381: LD_VAR 0 3
26385: PPUSH
26386: LD_VAR 0 6
26390: PUSH
26391: LD_VAR 0 4
26395: ARRAY
26396: PUSH
26397: LD_INT 2
26399: ARRAY
26400: PPUSH
26401: LD_VAR 0 6
26405: PUSH
26406: LD_VAR 0 4
26410: ARRAY
26411: PUSH
26412: LD_INT 3
26414: ARRAY
26415: PPUSH
26416: LD_INT 8
26418: PPUSH
26419: CALL 26436 0 4
// end ;
26423: GO 26326
26425: POP
26426: POP
// end ;
26427: GO 26284
26429: POP
26430: POP
// end ; end ;
26431: LD_VAR 0 2
26435: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
26436: LD_INT 0
26438: PPUSH
26439: PPUSH
26440: PPUSH
26441: PPUSH
26442: PPUSH
26443: PPUSH
26444: PPUSH
26445: PPUSH
26446: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
26447: LD_VAR 0 1
26451: NOT
26452: PUSH
26453: LD_VAR 0 2
26457: PPUSH
26458: LD_VAR 0 3
26462: PPUSH
26463: CALL_OW 488
26467: NOT
26468: OR
26469: PUSH
26470: LD_VAR 0 4
26474: NOT
26475: OR
26476: IFFALSE 26480
// exit ;
26478: GO 26820
// list := [ ] ;
26480: LD_ADDR_VAR 0 13
26484: PUSH
26485: EMPTY
26486: ST_TO_ADDR
// if x - r < 0 then
26487: LD_VAR 0 2
26491: PUSH
26492: LD_VAR 0 4
26496: MINUS
26497: PUSH
26498: LD_INT 0
26500: LESS
26501: IFFALSE 26513
// min_x := 0 else
26503: LD_ADDR_VAR 0 7
26507: PUSH
26508: LD_INT 0
26510: ST_TO_ADDR
26511: GO 26529
// min_x := x - r ;
26513: LD_ADDR_VAR 0 7
26517: PUSH
26518: LD_VAR 0 2
26522: PUSH
26523: LD_VAR 0 4
26527: MINUS
26528: ST_TO_ADDR
// if y - r < 0 then
26529: LD_VAR 0 3
26533: PUSH
26534: LD_VAR 0 4
26538: MINUS
26539: PUSH
26540: LD_INT 0
26542: LESS
26543: IFFALSE 26555
// min_y := 0 else
26545: LD_ADDR_VAR 0 8
26549: PUSH
26550: LD_INT 0
26552: ST_TO_ADDR
26553: GO 26571
// min_y := y - r ;
26555: LD_ADDR_VAR 0 8
26559: PUSH
26560: LD_VAR 0 3
26564: PUSH
26565: LD_VAR 0 4
26569: MINUS
26570: ST_TO_ADDR
// max_x := x + r ;
26571: LD_ADDR_VAR 0 9
26575: PUSH
26576: LD_VAR 0 2
26580: PUSH
26581: LD_VAR 0 4
26585: PLUS
26586: ST_TO_ADDR
// max_y := y + r ;
26587: LD_ADDR_VAR 0 10
26591: PUSH
26592: LD_VAR 0 3
26596: PUSH
26597: LD_VAR 0 4
26601: PLUS
26602: ST_TO_ADDR
// for _x = min_x to max_x do
26603: LD_ADDR_VAR 0 11
26607: PUSH
26608: DOUBLE
26609: LD_VAR 0 7
26613: DEC
26614: ST_TO_ADDR
26615: LD_VAR 0 9
26619: PUSH
26620: FOR_TO
26621: IFFALSE 26738
// for _y = min_y to max_y do
26623: LD_ADDR_VAR 0 12
26627: PUSH
26628: DOUBLE
26629: LD_VAR 0 8
26633: DEC
26634: ST_TO_ADDR
26635: LD_VAR 0 10
26639: PUSH
26640: FOR_TO
26641: IFFALSE 26734
// begin if not ValidHex ( _x , _y ) then
26643: LD_VAR 0 11
26647: PPUSH
26648: LD_VAR 0 12
26652: PPUSH
26653: CALL_OW 488
26657: NOT
26658: IFFALSE 26662
// continue ;
26660: GO 26640
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
26662: LD_VAR 0 11
26666: PPUSH
26667: LD_VAR 0 12
26671: PPUSH
26672: CALL_OW 351
26676: PUSH
26677: LD_VAR 0 11
26681: PPUSH
26682: LD_VAR 0 12
26686: PPUSH
26687: CALL_OW 554
26691: AND
26692: IFFALSE 26732
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
26694: LD_ADDR_VAR 0 13
26698: PUSH
26699: LD_VAR 0 13
26703: PPUSH
26704: LD_VAR 0 13
26708: PUSH
26709: LD_INT 1
26711: PLUS
26712: PPUSH
26713: LD_VAR 0 11
26717: PUSH
26718: LD_VAR 0 12
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PPUSH
26727: CALL_OW 2
26731: ST_TO_ADDR
// end ;
26732: GO 26640
26734: POP
26735: POP
26736: GO 26620
26738: POP
26739: POP
// if not list then
26740: LD_VAR 0 13
26744: NOT
26745: IFFALSE 26749
// exit ;
26747: GO 26820
// for i in list do
26749: LD_ADDR_VAR 0 6
26753: PUSH
26754: LD_VAR 0 13
26758: PUSH
26759: FOR_IN
26760: IFFALSE 26818
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
26762: LD_VAR 0 1
26766: PPUSH
26767: LD_STRING M
26769: PUSH
26770: LD_VAR 0 6
26774: PUSH
26775: LD_INT 1
26777: ARRAY
26778: PUSH
26779: LD_VAR 0 6
26783: PUSH
26784: LD_INT 2
26786: ARRAY
26787: PUSH
26788: LD_INT 0
26790: PUSH
26791: LD_INT 0
26793: PUSH
26794: LD_INT 0
26796: PUSH
26797: LD_INT 0
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: LIST
26808: PUSH
26809: EMPTY
26810: LIST
26811: PPUSH
26812: CALL_OW 447
26816: GO 26759
26818: POP
26819: POP
// end ;
26820: LD_VAR 0 5
26824: RET
