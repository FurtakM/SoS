// starting begin InitMap ;
   0: CALL 1433 0 0
// InitTriggers ;
   4: CALL 1818 0 0
// Start_Game ;
   8: CALL 13163 0 0
// InitPlayer ;
  12: CALL 2055 0 0
// InitRussian ;
  16: CALL 2945 0 0
// end ; end_of_file
  20: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
  21: LD_INT 0
  23: PPUSH
  24: PPUSH
  25: PPUSH
  26: PPUSH
  27: PPUSH
// uc_nation = nation_nature ;
  28: LD_ADDR_OWVAR 21
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// uc_side = 0 ;
  36: LD_ADDR_OWVAR 20
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// l = 0 ;
  44: LD_ADDR_VAR 0 6
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
  52: LD_ADDR_OWVAR 24
  56: PUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: CALL_OW 12
  67: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
  68: LD_ADDR_OWVAR 35
  72: PUSH
  73: LD_INT 5
  75: NEG
  76: PPUSH
  77: LD_INT 5
  79: PPUSH
  80: CALL_OW 12
  84: ST_TO_ADDR
// hc_gallery =  ;
  85: LD_ADDR_OWVAR 33
  89: PUSH
  90: LD_STRING 
  92: ST_TO_ADDR
// hc_class = class_apeman ;
  93: LD_ADDR_OWVAR 28
  97: PUSH
  98: LD_INT 12
 100: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 101: LD_ADDR_OWVAR 29
 105: PUSH
 106: LD_INT 11
 108: PPUSH
 109: LD_INT 13
 111: PPUSH
 112: CALL_OW 12
 116: PUSH
 117: LD_INT 10
 119: PPUSH
 120: LD_INT 11
 122: PPUSH
 123: CALL_OW 12
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: ST_TO_ADDR
// hc_sex = sex_male ;
 132: LD_ADDR_OWVAR 27
 136: PUSH
 137: LD_INT 1
 139: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 140: LD_ADDR_OWVAR 31
 144: PUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 2
 150: PPUSH
 151: CALL_OW 12
 155: PUSH
 156: LD_INT 0
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: LIST
 169: LIST
 170: ST_TO_ADDR
// apeman = CreateHuman ;
 171: LD_ADDR_VAR 0 7
 175: PUSH
 176: CALL_OW 44
 180: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 181: LD_VAR 0 7
 185: PPUSH
 186: LD_VAR 0 4
 190: PPUSH
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 49
// l = l + 1 ;
 198: LD_ADDR_VAR 0 6
 202: PUSH
 203: LD_VAR 0 6
 207: PUSH
 208: LD_INT 1
 210: PLUS
 211: ST_TO_ADDR
// end until l = num1 ;
 212: LD_VAR 0 6
 216: PUSH
 217: LD_VAR 0 1
 221: EQUAL
 222: IFFALSE 52
// l = 0 ;
 224: LD_ADDR_VAR 0 6
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 232: LD_ADDR_OWVAR 35
 236: PUSH
 237: LD_INT 0
 239: PPUSH
 240: LD_INT 25
 242: PPUSH
 243: CALL_OW 12
 247: ST_TO_ADDR
// hc_class = class_tiger ;
 248: LD_ADDR_OWVAR 28
 252: PUSH
 253: LD_INT 14
 255: ST_TO_ADDR
// hc_sex = sex_male ;
 256: LD_ADDR_OWVAR 27
 260: PUSH
 261: LD_INT 1
 263: ST_TO_ADDR
// hc_gallery = sandnature ;
 264: LD_ADDR_OWVAR 33
 268: PUSH
 269: LD_STRING sandnature
 271: ST_TO_ADDR
// hc_face_number = 3 ;
 272: LD_ADDR_OWVAR 34
 276: PUSH
 277: LD_INT 3
 279: ST_TO_ADDR
// tiger = CreateHuman ;
 280: LD_ADDR_VAR 0 8
 284: PUSH
 285: CALL_OW 44
 289: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 290: LD_VAR 0 8
 294: PPUSH
 295: LD_VAR 0 4
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL_OW 49
// l = l + 1 ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_INT 1
 319: PLUS
 320: ST_TO_ADDR
// end until l = num2 ;
 321: LD_VAR 0 6
 325: PUSH
 326: LD_VAR 0 2
 330: EQUAL
 331: IFFALSE 232
// l = 0 ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 341: LD_ADDR_OWVAR 28
 345: PUSH
 346: LD_INT 18
 348: ST_TO_ADDR
// hc_gallery = sandnature ;
 349: LD_ADDR_OWVAR 33
 353: PUSH
 354: LD_STRING sandnature
 356: ST_TO_ADDR
// hc_face_number = 1 ;
 357: LD_ADDR_OWVAR 34
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// bird = CreateHuman ;
 365: LD_ADDR_VAR 0 9
 369: PUSH
 370: CALL_OW 44
 374: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 375: LD_VAR 0 9
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: CALL_OW 51
// l = l + 1 ;
 387: LD_ADDR_VAR 0 6
 391: PUSH
 392: LD_VAR 0 6
 396: PUSH
 397: LD_INT 1
 399: PLUS
 400: ST_TO_ADDR
// end until l = num3 ;
 401: LD_VAR 0 6
 405: PUSH
 406: LD_VAR 0 3
 410: EQUAL
 411: IFFALSE 341
// end ;
 413: LD_VAR 0 5
 417: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
 423: PPUSH
 424: PPUSH
 425: PPUSH
// hc_class := clas ;
 426: LD_ADDR_OWVAR 28
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 2
 445: PUSH
 446: LD_INT 1
 448: NEG
 449: PPUSH
 450: LD_INT 1
 452: PPUSH
 453: CALL_OW 12
 457: PLUS
 458: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 459: LD_ADDR_VAR 0 5
 463: PUSH
 464: LD_VAR 0 2
 468: PUSH
 469: LD_INT 1
 471: NEG
 472: PPUSH
 473: LD_INT 1
 475: PPUSH
 476: CALL_OW 12
 480: PLUS
 481: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 482: LD_ADDR_VAR 0 6
 486: PUSH
 487: LD_VAR 0 2
 491: PUSH
 492: LD_INT 1
 494: NEG
 495: PPUSH
 496: LD_INT 1
 498: PPUSH
 499: CALL_OW 12
 503: PLUS
 504: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 505: LD_ADDR_VAR 0 7
 509: PUSH
 510: LD_VAR 0 2
 514: PUSH
 515: LD_INT 1
 517: NEG
 518: PPUSH
 519: LD_INT 1
 521: PPUSH
 522: CALL_OW 12
 526: PLUS
 527: ST_TO_ADDR
// if clas = 1 or clas = 9 then
 528: LD_VAR 0 1
 532: PUSH
 533: LD_INT 1
 535: EQUAL
 536: PUSH
 537: LD_VAR 0 1
 541: PUSH
 542: LD_INT 9
 544: EQUAL
 545: OR
 546: IFFALSE 571
// bonus := [ 2 , 0 , 0 , 0 ] ;
 548: LD_ADDR_VAR 0 8
 552: PUSH
 553: LD_INT 2
 555: PUSH
 556: LD_INT 0
 558: PUSH
 559: LD_INT 0
 561: PUSH
 562: LD_INT 0
 564: PUSH
 565: EMPTY
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: ST_TO_ADDR
// if clas = 2 then
 571: LD_VAR 0 1
 575: PUSH
 576: LD_INT 2
 578: EQUAL
 579: IFFALSE 604
// bonus := [ 0 , 2 , 0 , 0 ] ;
 581: LD_ADDR_VAR 0 8
 585: PUSH
 586: LD_INT 0
 588: PUSH
 589: LD_INT 2
 591: PUSH
 592: LD_INT 0
 594: PUSH
 595: LD_INT 0
 597: PUSH
 598: EMPTY
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: ST_TO_ADDR
// if clas = 3 then
 604: LD_VAR 0 1
 608: PUSH
 609: LD_INT 3
 611: EQUAL
 612: IFFALSE 637
// bonus := [ 0 , 0 , 2 , 0 ] ;
 614: LD_ADDR_VAR 0 8
 618: PUSH
 619: LD_INT 0
 621: PUSH
 622: LD_INT 0
 624: PUSH
 625: LD_INT 2
 627: PUSH
 628: LD_INT 0
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: ST_TO_ADDR
// if clas = 4 then
 637: LD_VAR 0 1
 641: PUSH
 642: LD_INT 4
 644: EQUAL
 645: IFFALSE 670
// bonus := [ 0 , 0 , 0 , 2 ] ;
 647: LD_ADDR_VAR 0 8
 651: PUSH
 652: LD_INT 0
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: LD_INT 0
 660: PUSH
 661: LD_INT 2
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: ST_TO_ADDR
// if clas > 4 and not clas = 9 then
 670: LD_VAR 0 1
 674: PUSH
 675: LD_INT 4
 677: GREATER
 678: PUSH
 679: LD_VAR 0 1
 683: PUSH
 684: LD_INT 9
 686: EQUAL
 687: NOT
 688: AND
 689: IFFALSE 714
// bonus := [ 0 , 0 , 0 , 0 ] ;
 691: LD_ADDR_VAR 0 8
 695: PUSH
 696: LD_INT 0
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 0
 704: PUSH
 705: LD_INT 0
 707: PUSH
 708: EMPTY
 709: LIST
 710: LIST
 711: LIST
 712: LIST
 713: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 714: LD_ADDR_OWVAR 31
 718: PUSH
 719: LD_VAR 0 4
 723: PUSH
 724: LD_VAR 0 8
 728: PUSH
 729: LD_INT 1
 731: ARRAY
 732: PLUS
 733: PUSH
 734: LD_VAR 0 5
 738: PUSH
 739: LD_VAR 0 8
 743: PUSH
 744: LD_INT 2
 746: ARRAY
 747: PLUS
 748: PUSH
 749: LD_VAR 0 6
 753: PUSH
 754: LD_VAR 0 8
 758: PUSH
 759: LD_INT 3
 761: ARRAY
 762: PLUS
 763: PUSH
 764: LD_VAR 0 7
 768: PUSH
 769: LD_VAR 0 8
 773: PUSH
 774: LD_INT 4
 776: ARRAY
 777: PLUS
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: LIST
 783: LIST
 784: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 785: LD_ADDR_OWVAR 27
 789: PUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_INT 2
 795: PPUSH
 796: CALL_OW 12
 800: ST_TO_ADDR
// hc_gallery :=  ;
 801: LD_ADDR_OWVAR 33
 805: PUSH
 806: LD_STRING 
 808: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 809: LD_ADDR_OWVAR 29
 813: PUSH
 814: LD_INT 8
 816: PPUSH
 817: LD_INT 12
 819: PPUSH
 820: CALL_OW 12
 824: PUSH
 825: LD_INT 9
 827: PPUSH
 828: LD_INT 11
 830: PPUSH
 831: CALL_OW 12
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: ST_TO_ADDR
// hc_name :=  ;
 840: LD_ADDR_OWVAR 26
 844: PUSH
 845: LD_STRING 
 847: ST_TO_ADDR
// result := CreateHuman ;
 848: LD_ADDR_VAR 0 3
 852: PUSH
 853: CALL_OW 44
 857: ST_TO_ADDR
// end ;
 858: LD_VAR 0 3
 862: RET
// export function SeeSide ( unit , side ) ; var i ; begin
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
// result := false ;
 867: LD_ADDR_VAR 0 3
 871: PUSH
 872: LD_INT 0
 874: ST_TO_ADDR
// i := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
 875: LD_ADDR_VAR 0 4
 879: PUSH
 880: LD_INT 22
 882: PUSH
 883: LD_VAR 0 2
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: PPUSH
 892: CALL_OW 69
 896: PPUSH
 897: LD_VAR 0 1
 901: PPUSH
 902: CALL_OW 74
 906: ST_TO_ADDR
// if GetDistUnits ( unit , i ) < 9 then
 907: LD_VAR 0 1
 911: PPUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: CALL_OW 296
 921: PUSH
 922: LD_INT 9
 924: LESS
 925: IFFALSE 935
// result := true ;
 927: LD_ADDR_VAR 0 3
 931: PUSH
 932: LD_INT 1
 934: ST_TO_ADDR
// end ;
 935: LD_VAR 0 3
 939: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
 940: LD_VAR 0 1
 944: PUSH
 945: LD_EXP 1
 949: IN
 950: NOT
 951: IFFALSE 982
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
 953: LD_ADDR_EXP 1
 957: PUSH
 958: LD_EXP 1
 962: PPUSH
 963: LD_EXP 1
 967: PUSH
 968: LD_INT 1
 970: PLUS
 971: PPUSH
 972: LD_VAR 0 1
 976: PPUSH
 977: CALL_OW 2
 981: ST_TO_ADDR
// end ;
 982: PPOPN 1
 984: END
// export function ComAttack ( unit , ignore_list ) ; var i , j , target , enemy_list , _list , types_list ; begin
 985: LD_INT 0
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
// if not IsPlaced ( unit ) then
 994: LD_VAR 0 1
 998: PPUSH
 999: CALL_OW 305
1003: NOT
1004: IFFALSE 1008
// exit ;
1006: GO 1315
// enemy_list := FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) ;
1008: LD_ADDR_VAR 0 7
1012: PUSH
1013: LD_INT 81
1015: PUSH
1016: LD_VAR 0 1
1020: PPUSH
1021: CALL_OW 255
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: PPUSH
1030: CALL_OW 69
1034: ST_TO_ADDR
// if not enemy_list then
1035: LD_VAR 0 7
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1315
// if ignore_list then
1044: LD_VAR 0 2
1048: IFFALSE 1190
// begin _list := [ ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: EMPTY
1056: ST_TO_ADDR
// types_list := [ f_btype , f_weapon , f_class ] ;
1057: LD_ADDR_VAR 0 9
1061: PUSH
1062: LD_INT 30
1064: PUSH
1065: LD_INT 34
1067: PUSH
1068: LD_INT 25
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// for i = 1 to 3 do
1076: LD_ADDR_VAR 0 4
1080: PUSH
1081: DOUBLE
1082: LD_INT 1
1084: DEC
1085: ST_TO_ADDR
1086: LD_INT 3
1088: PUSH
1089: FOR_TO
1090: IFFALSE 1188
// begin if not ignore_list [ i ] then
1092: LD_VAR 0 2
1096: PUSH
1097: LD_VAR 0 4
1101: ARRAY
1102: NOT
1103: IFFALSE 1109
// continue else
1105: GO 1089
1107: GO 1186
// for j in ignore_list [ i ] do
1109: LD_ADDR_VAR 0 5
1113: PUSH
1114: LD_VAR 0 2
1118: PUSH
1119: LD_VAR 0 4
1123: ARRAY
1124: PUSH
1125: FOR_IN
1126: IFFALSE 1184
// begin _list := Insert ( _list , _list + 1 , UnitFilter ( enemy_list , [ types_list [ i ] , j ] ) ) ;
1128: LD_ADDR_VAR 0 8
1132: PUSH
1133: LD_VAR 0 8
1137: PPUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: PLUS
1146: PPUSH
1147: LD_VAR 0 7
1151: PPUSH
1152: LD_VAR 0 9
1156: PUSH
1157: LD_VAR 0 4
1161: ARRAY
1162: PUSH
1163: LD_VAR 0 5
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PPUSH
1172: CALL_OW 72
1176: PPUSH
1177: CALL_OW 2
1181: ST_TO_ADDR
// end ;
1182: GO 1125
1184: POP
1185: POP
// end ;
1186: GO 1089
1188: POP
1189: POP
// end ; if enemy_list diff _list > 0 then
1190: LD_VAR 0 7
1194: PUSH
1195: LD_VAR 0 8
1199: PUSH
1200: LD_INT 0
1202: GREATER
1203: DIFF
1204: IFFALSE 1222
// enemy_list := enemy_list diff _list ;
1206: LD_ADDR_VAR 0 7
1210: PUSH
1211: LD_VAR 0 7
1215: PUSH
1216: LD_VAR 0 8
1220: DIFF
1221: ST_TO_ADDR
// target := NearestUnitToUnit ( enemy_list , unit ) ;
1222: LD_ADDR_VAR 0 6
1226: PUSH
1227: LD_VAR 0 7
1231: PPUSH
1232: LD_VAR 0 1
1236: PPUSH
1237: CALL_OW 74
1241: ST_TO_ADDR
// if not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
1242: LD_VAR 0 1
1246: PPUSH
1247: LD_VAR 0 6
1251: PPUSH
1252: CALL_OW 250
1256: PPUSH
1257: LD_VAR 0 6
1261: PPUSH
1262: CALL_OW 251
1266: PPUSH
1267: CALL 1320 0 3
1271: NOT
1272: IFFALSE 1315
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
1274: LD_VAR 0 1
1278: PPUSH
1279: LD_INT 81
1281: PUSH
1282: LD_VAR 0 1
1286: PPUSH
1287: CALL_OW 255
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL_OW 69
1300: PPUSH
1301: LD_VAR 0 1
1305: PPUSH
1306: CALL_OW 74
1310: PPUSH
1311: CALL_OW 115
// end ;
1315: LD_VAR 0 3
1319: RET
// export function DestinationReachable ( unit , x , y ) ; begin
1320: LD_INT 0
1322: PPUSH
// if unit in unreachableList then
1323: LD_VAR 0 1
1327: PUSH
1328: LD_EXP 1
1332: IN
1333: IFFALSE 1351
// unreachableList := unreachableList diff unit ;
1335: LD_ADDR_EXP 1
1339: PUSH
1340: LD_EXP 1
1344: PUSH
1345: LD_VAR 0 1
1349: DIFF
1350: ST_TO_ADDR
// if ValidHex ( x , y ) then
1351: LD_VAR 0 2
1355: PPUSH
1356: LD_VAR 0 3
1360: PPUSH
1361: CALL_OW 488
1365: IFFALSE 1391
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_VAR 0 2
1376: PPUSH
1377: LD_VAR 0 3
1381: PPUSH
1382: CALL_OW 428
1386: PPUSH
1387: CALL_OW 115
// Wait ( 1 ) ;
1391: LD_INT 1
1393: PPUSH
1394: CALL_OW 67
// if unit in unreachableList then
1398: LD_VAR 0 1
1402: PUSH
1403: LD_EXP 1
1407: IN
1408: IFFALSE 1420
// result := false else
1410: LD_ADDR_VAR 0 4
1414: PUSH
1415: LD_INT 0
1417: ST_TO_ADDR
1418: GO 1428
// result := true ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// end ; end_of_file
1428: LD_VAR 0 4
1432: RET
// export function InitMap ; begin
1433: LD_INT 0
1435: PPUSH
// ResetFog ;
1436: CALL_OW 335
// PrepareAnimals ( 2 , 3 , 3 , nature_area ) ;
1440: LD_INT 2
1442: PPUSH
1443: LD_INT 3
1445: PPUSH
1446: LD_INT 3
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: CALL 21 0 4
// end ;
1456: LD_VAR 0 1
1460: RET
// export function SpawnCrates ; var i ; begin
1461: LD_INT 0
1463: PPUSH
1464: PPUSH
// while ( crates_allow ) do
1465: LD_EXP 13
1469: IFFALSE 1622
// begin Wait ( crates_time + Rand ( - 0 0$10 , 0 0$20 ) ) ;
1471: LD_EXP 11
1475: PUSH
1476: LD_INT 350
1478: NEG
1479: PPUSH
1480: LD_INT 700
1482: PPUSH
1483: CALL_OW 12
1487: PLUS
1488: PPUSH
1489: CALL_OW 67
// for i = 1 to crates_num do
1493: LD_ADDR_VAR 0 2
1497: PUSH
1498: DOUBLE
1499: LD_INT 1
1501: DEC
1502: ST_TO_ADDR
1503: LD_EXP 12
1507: PUSH
1508: FOR_TO
1509: IFFALSE 1618
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1511: LD_INT 1
1513: PPUSH
1514: LD_INT 5
1516: PPUSH
1517: CALL_OW 12
1521: PPUSH
1522: LD_INT 2
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: CALL_OW 55
// Wait ( Rand ( 0 0$03 , 0 0$12 ) ) ;
1532: LD_INT 105
1534: PPUSH
1535: LD_INT 420
1537: PPUSH
1538: CALL_OW 12
1542: PPUSH
1543: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1547: LD_INT 1
1549: PPUSH
1550: LD_INT 5
1552: PPUSH
1553: CALL_OW 12
1557: PPUSH
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 1
1563: PPUSH
1564: CALL_OW 55
// Wait ( Rand ( 0 0$04 , 0 0$15 ) ) ;
1568: LD_INT 140
1570: PPUSH
1571: LD_INT 525
1573: PPUSH
1574: CALL_OW 12
1578: PPUSH
1579: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
1583: LD_INT 1
1585: PPUSH
1586: LD_INT 5
1588: PPUSH
1589: CALL_OW 12
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 57
// Wait ( Rand ( 0 0$05 , 0 0$10 ) ) ;
1601: LD_INT 175
1603: PPUSH
1604: LD_INT 350
1606: PPUSH
1607: CALL_OW 12
1611: PPUSH
1612: CALL_OW 67
// end ;
1616: GO 1508
1618: POP
1619: POP
// end ;
1620: GO 1465
// end ;
1622: LD_VAR 0 1
1626: RET
// every 1 1$25 trigger game_started do
1627: LD_EXP 10
1631: IFFALSE 1685
1633: GO 1635
1635: DISABLE
// begin enable ;
1636: ENABLE
// if timer <= [ 23 23$00 , 21 21$00 , 19 19$00 ] [ global_diff ] then
1637: LD_EXP 2
1641: PUSH
1642: LD_INT 48300
1644: PUSH
1645: LD_INT 44100
1647: PUSH
1648: LD_INT 39900
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: PUSH
1656: LD_EXP 3
1660: ARRAY
1661: LESSEQUAL
1662: IFFALSE 1685
// CreateCratesArea ( Rand ( 2 , 5 ) , us_crates , true ) ;
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 5
1669: PPUSH
1670: CALL_OW 12
1674: PPUSH
1675: LD_INT 12
1677: PPUSH
1678: LD_INT 1
1680: PPUSH
1681: CALL_OW 55
// end ;
1685: END
// every 0 0$01 trigger game_started do
1686: LD_EXP 10
1690: IFFALSE 1699
1692: GO 1694
1694: DISABLE
// SpawnCrates ;
1695: CALL 1461 0 0
1699: END
// export timer ; every 1 do
1700: GO 1702
1702: DISABLE
// timer := 0 0$00 ;
1703: LD_ADDR_EXP 2
1707: PUSH
1708: LD_INT 0
1710: ST_TO_ADDR
1711: END
// every 0 0$01 trigger game_started do
1712: LD_EXP 10
1716: IFFALSE 1753
1718: GO 1720
1720: DISABLE
// begin enable ;
1721: ENABLE
// timer := timer + 0 0$01 ;
1722: LD_ADDR_EXP 2
1726: PUSH
1727: LD_EXP 2
1731: PUSH
1732: LD_INT 35
1734: PLUS
1735: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
1736: LD_ADDR_OWVAR 47
1740: PUSH
1741: LD_STRING #tick
1743: PUSH
1744: LD_EXP 2
1748: PUSH
1749: EMPTY
1750: LIST
1751: LIST
1752: ST_TO_ADDR
// end ;
1753: END
// every 0 0$01 trigger timer <= 13 13$00 do
1754: LD_EXP 2
1758: PUSH
1759: LD_INT 27300
1761: LESSEQUAL
1762: IFFALSE 1775
1764: GO 1766
1766: DISABLE
// music_nat := 1 ;
1767: LD_ADDR_OWVAR 71
1771: PUSH
1772: LD_INT 1
1774: ST_TO_ADDR
1775: END
// every 5 5$00 trigger timer > 13 13$00 do
1776: LD_EXP 2
1780: PUSH
1781: LD_INT 27300
1783: GREATER
1784: IFFALSE 1817
1786: GO 1788
1788: DISABLE
// begin enable ;
1789: ENABLE
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1790: LD_ADDR_OWVAR 71
1794: PUSH
1795: LD_INT 1
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 1
1807: PPUSH
1808: LD_INT 2
1810: PPUSH
1811: CALL_OW 12
1815: ARRAY
1816: ST_TO_ADDR
// end ; end_of_file
1817: END
// export global_diff , ru_force , ru_def , am_def , am_force , ar_def , ar_force ; export game_started ; export crates_time , crates_num , crates_allow ; export sikorski , kurin , heike , ron , jack ; export sikorski_come , russian_produce , beria_action , sikorski_veh ; export function InitTriggers ; begin
1818: LD_INT 0
1820: PPUSH
// game_started := false ;
1821: LD_ADDR_EXP 10
1825: PUSH
1826: LD_INT 0
1828: ST_TO_ADDR
// global_diff := [ 1 , 2 , 3 ] ;
1829: LD_ADDR_EXP 3
1833: PUSH
1834: LD_INT 1
1836: PUSH
1837: LD_INT 2
1839: PUSH
1840: LD_INT 3
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: ST_TO_ADDR
// crates_time := [ 0 0$55 , 1 1$15 , 1 1$35 ] [ global_diff ] ;
1848: LD_ADDR_EXP 11
1852: PUSH
1853: LD_INT 1925
1855: PUSH
1856: LD_INT 2625
1858: PUSH
1859: LD_INT 3325
1861: PUSH
1862: EMPTY
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_EXP 3
1871: ARRAY
1872: ST_TO_ADDR
// crates_num := [ 3 , 2 , 1 ] [ global_diff ] ;
1873: LD_ADDR_EXP 12
1877: PUSH
1878: LD_INT 3
1880: PUSH
1881: LD_INT 2
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_EXP 3
1896: ARRAY
1897: ST_TO_ADDR
// crates_allow := false ;
1898: LD_ADDR_EXP 13
1902: PUSH
1903: LD_INT 0
1905: ST_TO_ADDR
// am_def := [ 4 , 3 , 2 ] [ global_diff ] ;
1906: LD_ADDR_EXP 6
1910: PUSH
1911: LD_INT 4
1913: PUSH
1914: LD_INT 3
1916: PUSH
1917: LD_INT 2
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: LIST
1924: PUSH
1925: LD_EXP 3
1929: ARRAY
1930: ST_TO_ADDR
// ru_def := [ 2 , 3 , 4 ] [ global_diff ] ;
1931: LD_ADDR_EXP 5
1935: PUSH
1936: LD_INT 2
1938: PUSH
1939: LD_INT 3
1941: PUSH
1942: LD_INT 4
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: LIST
1949: PUSH
1950: LD_EXP 3
1954: ARRAY
1955: ST_TO_ADDR
// ru_force := [ 16 , 18 , 20 ] [ global_diff ] ;
1956: LD_ADDR_EXP 4
1960: PUSH
1961: LD_INT 16
1963: PUSH
1964: LD_INT 18
1966: PUSH
1967: LD_INT 20
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: LIST
1974: PUSH
1975: LD_EXP 3
1979: ARRAY
1980: ST_TO_ADDR
// ar_def := [ 3 , 4 , 5 ] [ global_diff ] ;
1981: LD_ADDR_EXP 8
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: LD_INT 4
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_EXP 3
2004: ARRAY
2005: ST_TO_ADDR
// ar_force := [ 4 , 5 , 6 ] [ global_diff ] ;
2006: LD_ADDR_EXP 9
2010: PUSH
2011: LD_INT 4
2013: PUSH
2014: LD_INT 5
2016: PUSH
2017: LD_INT 6
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: PUSH
2025: LD_EXP 3
2029: ARRAY
2030: ST_TO_ADDR
// sikorski_come := false ;
2031: LD_ADDR_EXP 19
2035: PUSH
2036: LD_INT 0
2038: ST_TO_ADDR
// russian_produce := false ;
2039: LD_ADDR_EXP 20
2043: PUSH
2044: LD_INT 0
2046: ST_TO_ADDR
// disable ( 99 ) ;
2047: LD_INT 99
2049: DISABLE_MARKED
// end ; end_of_file
2050: LD_VAR 0 1
2054: RET
// export function InitPlayer ; var i , p , un , am , am2 , filter ; begin
2055: LD_INT 0
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
// uc_nation := nation_american ;
2064: LD_ADDR_OWVAR 21
2068: PUSH
2069: LD_INT 1
2071: ST_TO_ADDR
// am := 1 ;
2072: LD_ADDR_VAR 0 5
2076: PUSH
2077: LD_INT 1
2079: ST_TO_ADDR
// am2 := 4 ;
2080: LD_ADDR_VAR 0 6
2084: PUSH
2085: LD_INT 4
2087: ST_TO_ADDR
// filter := [ ] ;
2088: LD_ADDR_VAR 0 7
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// SetSide ( omikron , am2 ) ;
2095: LD_INT 64
2097: PPUSH
2098: LD_VAR 0 6
2102: PPUSH
2103: CALL_OW 235
// SetBName ( omikron , omikron ) ;
2107: LD_INT 64
2109: PPUSH
2110: LD_STRING omikron
2112: PPUSH
2113: CALL_OW 500
// ResetFog ;
2117: CALL_OW 335
// uc_side := am2 ;
2121: LD_ADDR_OWVAR 20
2125: PUSH
2126: LD_VAR 0 6
2130: ST_TO_ADDR
// for i = 1 to 4 do
2131: LD_ADDR_VAR 0 2
2135: PUSH
2136: DOUBLE
2137: LD_INT 1
2139: DEC
2140: ST_TO_ADDR
2141: LD_INT 4
2143: PUSH
2144: FOR_TO
2145: IFFALSE 2267
// for p = 1 to 2 do
2147: LD_ADDR_VAR 0 3
2151: PUSH
2152: DOUBLE
2153: LD_INT 1
2155: DEC
2156: ST_TO_ADDR
2157: LD_INT 2
2159: PUSH
2160: FOR_TO
2161: IFFALSE 2263
// begin un := CreateHumanWithClass ( i , am_def ) ;
2163: LD_ADDR_VAR 0 4
2167: PUSH
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_EXP 6
2177: PPUSH
2178: CALL 418 0 2
2182: ST_TO_ADDR
// PlaceUnitArea ( un , am_area , false ) ;
2183: LD_VAR 0 4
2187: PPUSH
2188: LD_INT 3
2190: PPUSH
2191: LD_INT 0
2193: PPUSH
2194: CALL_OW 49
// if GetClass ( un ) = 1 then
2198: LD_VAR 0 4
2202: PPUSH
2203: CALL_OW 257
2207: PUSH
2208: LD_INT 1
2210: EQUAL
2211: IFFALSE 2261
// ComEnterUnit ( un , ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) diff us_spec_b ) [ p ] ) ;
2213: LD_VAR 0 4
2217: PPUSH
2218: LD_INT 22
2220: PUSH
2221: LD_INT 4
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: PUSH
2228: LD_INT 30
2230: PUSH
2231: LD_INT 31
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: PPUSH
2242: CALL_OW 69
2246: PUSH
2247: LD_INT 140
2249: DIFF
2250: PUSH
2251: LD_VAR 0 3
2255: ARRAY
2256: PPUSH
2257: CALL_OW 120
// end ;
2261: GO 2160
2263: POP
2264: POP
2265: GO 2144
2267: POP
2268: POP
// if IsPlaced ( us_spec_b ) then
2269: LD_INT 140
2271: PPUSH
2272: CALL_OW 305
2276: IFFALSE 2340
// begin un := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) [ 1 ] ;
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: LD_INT 22
2285: PUSH
2286: LD_INT 4
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 25
2295: PUSH
2296: LD_INT 3
2298: PUSH
2299: EMPTY
2300: LIST
2301: LIST
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: LD_INT 1
2314: ARRAY
2315: ST_TO_ADDR
// SetClass ( un , 1 ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 1
2323: PPUSH
2324: CALL_OW 336
// ComEnterUnit ( un , us_spec_b ) ;
2328: LD_VAR 0 4
2332: PPUSH
2333: LD_INT 140
2335: PPUSH
2336: CALL_OW 120
// end ; vc_chassis := us_medium_wheeled ;
2340: LD_ADDR_OWVAR 37
2344: PUSH
2345: LD_INT 2
2347: ST_TO_ADDR
// vc_engine := engine_solar ;
2348: LD_ADDR_OWVAR 39
2352: PUSH
2353: LD_INT 2
2355: ST_TO_ADDR
// vc_control := control_manual ;
2356: LD_ADDR_OWVAR 38
2360: PUSH
2361: LD_INT 1
2363: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_double_gun , us_gatling_gun ] [ global_diff ] ;
2364: LD_ADDR_OWVAR 40
2368: PUSH
2369: LD_INT 5
2371: PUSH
2372: LD_INT 5
2374: PUSH
2375: LD_INT 4
2377: PUSH
2378: EMPTY
2379: LIST
2380: LIST
2381: LIST
2382: PUSH
2383: LD_EXP 3
2387: ARRAY
2388: ST_TO_ADDR
// un := CreateVehicle ;
2389: LD_ADDR_VAR 0 4
2393: PUSH
2394: CALL_OW 45
2398: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2399: LD_VAR 0 4
2403: PPUSH
2404: LD_INT 4
2406: PPUSH
2407: CALL_OW 233
// PlaceUnitXY ( un , 12 , 17 , false ) ;
2411: LD_VAR 0 4
2415: PPUSH
2416: LD_INT 12
2418: PPUSH
2419: LD_INT 17
2421: PPUSH
2422: LD_INT 0
2424: PPUSH
2425: CALL_OW 48
// vc_chassis := us_light_wheeled ;
2429: LD_ADDR_OWVAR 37
2433: PUSH
2434: LD_INT 1
2436: ST_TO_ADDR
// vc_engine := engine_combustion ;
2437: LD_ADDR_OWVAR 39
2441: PUSH
2442: LD_INT 1
2444: ST_TO_ADDR
// vc_control := control_manual ;
2445: LD_ADDR_OWVAR 38
2449: PUSH
2450: LD_INT 1
2452: ST_TO_ADDR
// vc_weapon := us_light_gun ;
2453: LD_ADDR_OWVAR 40
2457: PUSH
2458: LD_INT 3
2460: ST_TO_ADDR
// un := CreateVehicle ;
2461: LD_ADDR_VAR 0 4
2465: PUSH
2466: CALL_OW 45
2470: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2471: LD_VAR 0 4
2475: PPUSH
2476: LD_INT 4
2478: PPUSH
2479: CALL_OW 233
// PlaceUnitXY ( un , 19 , 19 , false ) ;
2483: LD_VAR 0 4
2487: PPUSH
2488: LD_INT 19
2490: PPUSH
2491: LD_INT 19
2493: PPUSH
2494: LD_INT 0
2496: PPUSH
2497: CALL_OW 48
// uc_side := am ;
2501: LD_ADDR_OWVAR 20
2505: PUSH
2506: LD_VAR 0 5
2510: ST_TO_ADDR
// hc_importance := 100 ;
2511: LD_ADDR_OWVAR 32
2515: PUSH
2516: LD_INT 100
2518: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
2519: LD_ADDR_OWVAR 26
2523: PUSH
2524: LD_STRING Jeremy Sikorski
2526: ST_TO_ADDR
// hc_gallery := us ;
2527: LD_ADDR_OWVAR 33
2531: PUSH
2532: LD_STRING us
2534: ST_TO_ADDR
// hc_face_number := 19 ;
2535: LD_ADDR_OWVAR 34
2539: PUSH
2540: LD_INT 19
2542: ST_TO_ADDR
// hc_skills := [ Rand ( am_def + 2 , am_def + 4 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) , Rand ( am_def - 1 , am_def + 1 ) ] ;
2543: LD_ADDR_OWVAR 31
2547: PUSH
2548: LD_EXP 6
2552: PUSH
2553: LD_INT 2
2555: PLUS
2556: PPUSH
2557: LD_EXP 6
2561: PUSH
2562: LD_INT 4
2564: PLUS
2565: PPUSH
2566: CALL_OW 12
2570: PUSH
2571: LD_EXP 6
2575: PUSH
2576: LD_INT 1
2578: MINUS
2579: PPUSH
2580: LD_EXP 6
2584: PUSH
2585: LD_INT 1
2587: PLUS
2588: PPUSH
2589: CALL_OW 12
2593: PUSH
2594: LD_EXP 6
2598: PUSH
2599: LD_INT 1
2601: MINUS
2602: PPUSH
2603: LD_EXP 6
2607: PUSH
2608: LD_INT 1
2610: PLUS
2611: PPUSH
2612: CALL_OW 12
2616: PUSH
2617: LD_EXP 6
2621: PUSH
2622: LD_INT 1
2624: MINUS
2625: PPUSH
2626: LD_EXP 6
2630: PUSH
2631: LD_INT 1
2633: PLUS
2634: PPUSH
2635: CALL_OW 12
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: ST_TO_ADDR
// hc_sex := sex_male ;
2646: LD_ADDR_OWVAR 27
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// hc_class := 1 ;
2654: LD_ADDR_OWVAR 28
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2662: LD_ADDR_OWVAR 29
2666: PUSH
2667: LD_INT 10
2669: PUSH
2670: LD_INT 12
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: ST_TO_ADDR
// sikorski := CreateHuman ;
2677: LD_ADDR_EXP 14
2681: PUSH
2682: CALL_OW 44
2686: ST_TO_ADDR
// if global_diff > 1 then
2687: LD_EXP 3
2691: PUSH
2692: LD_INT 1
2694: GREATER
2695: IFFALSE 2714
// PlaceUnitArea ( sikorski , sikorski_area , false ) else
2697: LD_EXP 14
2701: PPUSH
2702: LD_INT 8
2704: PPUSH
2705: LD_INT 0
2707: PPUSH
2708: CALL_OW 49
2712: GO 2805
// begin vc_chassis := us_light_wheeled ;
2714: LD_ADDR_OWVAR 37
2718: PUSH
2719: LD_INT 1
2721: ST_TO_ADDR
// vc_engine := engine_combustion ;
2722: LD_ADDR_OWVAR 39
2726: PUSH
2727: LD_INT 1
2729: ST_TO_ADDR
// vc_control := control_manual ;
2730: LD_ADDR_OWVAR 38
2734: PUSH
2735: LD_INT 1
2737: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
2738: LD_ADDR_OWVAR 40
2742: PUSH
2743: LD_INT 2
2745: ST_TO_ADDR
// vc_fuel_battery := 21 ;
2746: LD_ADDR_OWVAR 41
2750: PUSH
2751: LD_INT 21
2753: ST_TO_ADDR
// sikorski_veh := CreateVehicle ;
2754: LD_ADDR_EXP 22
2758: PUSH
2759: CALL_OW 45
2763: ST_TO_ADDR
// SetDir ( sikorski_veh , 0 ) ;
2764: LD_EXP 22
2768: PPUSH
2769: LD_INT 0
2771: PPUSH
2772: CALL_OW 233
// PlaceUnitArea ( sikorski_veh , sikorski_area , false ) ;
2776: LD_EXP 22
2780: PPUSH
2781: LD_INT 8
2783: PPUSH
2784: LD_INT 0
2786: PPUSH
2787: CALL_OW 49
// PlaceHumanInUnit ( sikorski , sikorski_veh ) ;
2791: LD_EXP 14
2795: PPUSH
2796: LD_EXP 22
2800: PPUSH
2801: CALL_OW 52
// end ; hc_importance := 0 ;
2805: LD_ADDR_OWVAR 32
2809: PUSH
2810: LD_INT 0
2812: ST_TO_ADDR
// hc_name := Ronn Harisson ;
2813: LD_ADDR_OWVAR 26
2817: PUSH
2818: LD_STRING Ronn Harisson
2820: ST_TO_ADDR
// hc_gallery := us ;
2821: LD_ADDR_OWVAR 33
2825: PUSH
2826: LD_STRING us
2828: ST_TO_ADDR
// hc_face_number := 6 ;
2829: LD_ADDR_OWVAR 34
2833: PUSH
2834: LD_INT 6
2836: ST_TO_ADDR
// ron := CreateHuman ;
2837: LD_ADDR_EXP 17
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// hc_name := Jack Dickens ;
2847: LD_ADDR_OWVAR 26
2851: PUSH
2852: LD_STRING Jack Dickens
2854: ST_TO_ADDR
// hc_gallery :=  ;
2855: LD_ADDR_OWVAR 33
2859: PUSH
2860: LD_STRING 
2862: ST_TO_ADDR
// jack := CreateHuman ;
2863: LD_ADDR_EXP 18
2867: PUSH
2868: CALL_OW 44
2872: ST_TO_ADDR
// end ;
2873: LD_VAR 0 1
2877: RET
// every 0 0$01 trigger GetDistUnits ( sikorski , omikron ) <= 45 do
2878: LD_EXP 14
2882: PPUSH
2883: LD_INT 64
2885: PPUSH
2886: CALL_OW 296
2890: PUSH
2891: LD_INT 45
2893: LESSEQUAL
2894: IFFALSE 2944
2896: GO 2898
2898: DISABLE
// ComBuild ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) , b_workshop , 16 , 5 , 3 ) ; end_of_file
2899: LD_INT 22
2901: PUSH
2902: LD_INT 4
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: LD_INT 25
2911: PUSH
2912: LD_INT 2
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PPUSH
2923: CALL_OW 69
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_INT 16
2933: PPUSH
2934: LD_INT 5
2936: PPUSH
2937: LD_INT 3
2939: PPUSH
2940: CALL_OW 145
2944: END
// export ru_sold , ru_stw , ru_tw , ru_tech , ru_veh , ru_eng , ru_mech , ru_sci , ru_bul , ru_b ; export ru2_sold , ru2_stw , ru2_tw , ru2_tech , ru2_veh , ru2_eng , ru2_mech , ru2_sci , ru2_bul , ru2_b ; export ru_list_attackers ; export ru_radar ; export function InitRussian ; var ru , ru2 , i , un , filter ; begin
2945: LD_INT 0
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
// ru := 6 ;
2953: LD_ADDR_VAR 0 2
2957: PUSH
2958: LD_INT 6
2960: ST_TO_ADDR
// ru2 := 3 ;
2961: LD_ADDR_VAR 0 3
2965: PUSH
2966: LD_INT 3
2968: ST_TO_ADDR
// uc_nation := nation_russian ;
2969: LD_ADDR_OWVAR 21
2973: PUSH
2974: LD_INT 3
2976: ST_TO_ADDR
// ru_radar := 98 ;
2977: LD_ADDR_EXP 44
2981: PUSH
2982: LD_INT 98
2984: ST_TO_ADDR
// ru_list_attackers := [ ] ;
2985: LD_ADDR_EXP 43
2989: PUSH
2990: EMPTY
2991: ST_TO_ADDR
// uc_side := ru ;
2992: LD_ADDR_OWVAR 20
2996: PUSH
2997: LD_VAR 0 2
3001: ST_TO_ADDR
// ru_sold := [ ] ;
3002: LD_ADDR_EXP 23
3006: PUSH
3007: EMPTY
3008: ST_TO_ADDR
// ru_stw := [ ] ;
3009: LD_ADDR_EXP 24
3013: PUSH
3014: EMPTY
3015: ST_TO_ADDR
// ru_tw := [ ] ;
3016: LD_ADDR_EXP 25
3020: PUSH
3021: EMPTY
3022: ST_TO_ADDR
// ru_b := [ ] ;
3023: LD_ADDR_EXP 32
3027: PUSH
3028: EMPTY
3029: ST_TO_ADDR
// ru_eng := [ ] ;
3030: LD_ADDR_EXP 28
3034: PUSH
3035: EMPTY
3036: ST_TO_ADDR
// ru_mech := [ ] ;
3037: LD_ADDR_EXP 29
3041: PUSH
3042: EMPTY
3043: ST_TO_ADDR
// ru_sci := [ ] ;
3044: LD_ADDR_EXP 30
3048: PUSH
3049: EMPTY
3050: ST_TO_ADDR
// ru_bul := [ b_bunker , 162 , 101 , 0 , b_ext_rocket , 149 , 86 , 4 ] ;
3051: LD_ADDR_EXP 31
3055: PUSH
3056: LD_INT 32
3058: PUSH
3059: LD_INT 162
3061: PUSH
3062: LD_INT 101
3064: PUSH
3065: LD_INT 0
3067: PUSH
3068: LD_INT 18
3070: PUSH
3071: LD_INT 149
3073: PUSH
3074: LD_INT 86
3076: PUSH
3077: LD_INT 4
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: ST_TO_ADDR
// ru_tech := [ tech_tech1 , tech_tech2 , tech_tech3 , tech_oilpow , tech_oileng , tech_weap1 , tech_weap2 , tech_gatling , tech_advmet , tech_weap3 ] ;
3090: LD_ADDR_EXP 26
3094: PUSH
3095: LD_INT 48
3097: PUSH
3098: LD_INT 49
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: LD_INT 46
3106: PUSH
3107: LD_INT 47
3109: PUSH
3110: LD_INT 51
3112: PUSH
3113: LD_INT 52
3115: PUSH
3116: LD_INT 69
3118: PUSH
3119: LD_INT 34
3121: PUSH
3122: LD_INT 53
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: LIST
3136: ST_TO_ADDR
// ru_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3137: LD_ADDR_EXP 27
3141: PUSH
3142: LD_INT 21
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 1
3150: PUSH
3151: LD_INT 51
3153: PUSH
3154: LD_INT 22
3156: PUSH
3157: LD_INT 1
3159: PUSH
3160: LD_INT 1
3162: PUSH
3163: LD_INT 52
3165: PUSH
3166: LD_INT 22
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: LD_INT 1
3174: PUSH
3175: LD_INT 52
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: LIST
3190: LIST
3191: ST_TO_ADDR
// SetBName ( kirov , kirov ) ;
3192: LD_INT 71
3194: PPUSH
3195: LD_STRING kirov
3197: PPUSH
3198: CALL_OW 500
// hc_gallery := ru ;
3202: LD_ADDR_OWVAR 33
3206: PUSH
3207: LD_STRING ru
3209: ST_TO_ADDR
// hc_face_number := 8 ;
3210: LD_ADDR_OWVAR 34
3214: PUSH
3215: LD_INT 8
3217: ST_TO_ADDR
// hc_skills := [ 7 , 4 , 3 , 2 ] ;
3218: LD_ADDR_OWVAR 31
3222: PUSH
3223: LD_INT 7
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 2
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: ST_TO_ADDR
// hc_sex := sex_male ;
3241: LD_ADDR_OWVAR 27
3245: PUSH
3246: LD_INT 1
3248: ST_TO_ADDR
// hc_name := Ivan Kurin ;
3249: LD_ADDR_OWVAR 26
3253: PUSH
3254: LD_STRING Ivan Kurin
3256: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3257: LD_ADDR_OWVAR 29
3261: PUSH
3262: LD_INT 10
3264: PUSH
3265: LD_INT 10
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: ST_TO_ADDR
// kurin := CreateHuman ;
3272: LD_ADDR_EXP 15
3276: PUSH
3277: CALL_OW 44
3281: ST_TO_ADDR
// PlaceHumanInUnit ( kurin , kirov ) ;
3282: LD_EXP 15
3286: PPUSH
3287: LD_INT 71
3289: PPUSH
3290: CALL_OW 52
// filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_bunker ] ] ) ;
3294: LD_ADDR_VAR 0 6
3298: PUSH
3299: LD_INT 22
3301: PUSH
3302: LD_INT 6
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: LD_INT 30
3311: PUSH
3312: LD_INT 32
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 69
3327: ST_TO_ADDR
// for i = 1 to ru_force do
3328: LD_ADDR_VAR 0 4
3332: PUSH
3333: DOUBLE
3334: LD_INT 1
3336: DEC
3337: ST_TO_ADDR
3338: LD_EXP 4
3342: PUSH
3343: FOR_TO
3344: IFFALSE 3415
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3346: LD_ADDR_VAR 0 5
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_EXP 5
3358: PPUSH
3359: CALL 418 0 2
3363: ST_TO_ADDR
// if i <= filter then
3364: LD_VAR 0 4
3368: PUSH
3369: LD_VAR 0 6
3373: LESSEQUAL
3374: IFFALSE 3398
// PlaceHumanInUnit ( un , filter [ i ] ) else
3376: LD_VAR 0 5
3380: PPUSH
3381: LD_VAR 0 6
3385: PUSH
3386: LD_VAR 0 4
3390: ARRAY
3391: PPUSH
3392: CALL_OW 52
3396: GO 3413
// PlaceUnitArea ( un , ru_area , false ) ;
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_INT 4
3405: PPUSH
3406: LD_INT 0
3408: PPUSH
3409: CALL_OW 49
// end ;
3413: GO 3343
3415: POP
3416: POP
// for i = 1 to 6 do
3417: LD_ADDR_VAR 0 4
3421: PUSH
3422: DOUBLE
3423: LD_INT 1
3425: DEC
3426: ST_TO_ADDR
3427: LD_INT 6
3429: PUSH
3430: FOR_TO
3431: IFFALSE 3468
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
3433: LD_ADDR_VAR 0 5
3437: PUSH
3438: LD_INT 3
3440: PPUSH
3441: LD_EXP 5
3445: PPUSH
3446: CALL 418 0 2
3450: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3451: LD_VAR 0 5
3455: PPUSH
3456: LD_INT 4
3458: PPUSH
3459: LD_INT 0
3461: PPUSH
3462: CALL_OW 49
// end ;
3466: GO 3430
3468: POP
3469: POP
// for i = 1 to 3 do
3470: LD_ADDR_VAR 0 4
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 3
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3521
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
3486: LD_ADDR_VAR 0 5
3490: PUSH
3491: LD_INT 4
3493: PPUSH
3494: LD_EXP 5
3498: PPUSH
3499: CALL 418 0 2
3503: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3504: LD_VAR 0 5
3508: PPUSH
3509: LD_INT 4
3511: PPUSH
3512: LD_INT 0
3514: PPUSH
3515: CALL_OW 49
// end ;
3519: GO 3483
3521: POP
3522: POP
// for i = 1 to 4 do
3523: LD_ADDR_VAR 0 4
3527: PUSH
3528: DOUBLE
3529: LD_INT 1
3531: DEC
3532: ST_TO_ADDR
3533: LD_INT 4
3535: PUSH
3536: FOR_TO
3537: IFFALSE 3574
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
3539: LD_ADDR_VAR 0 5
3543: PUSH
3544: LD_INT 2
3546: PPUSH
3547: LD_EXP 5
3551: PPUSH
3552: CALL 418 0 2
3556: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
3557: LD_VAR 0 5
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_INT 0
3567: PPUSH
3568: CALL_OW 49
// end ;
3572: GO 3536
3574: POP
3575: POP
// uc_side := ru2 ;
3576: LD_ADDR_OWVAR 20
3580: PUSH
3581: LD_VAR 0 3
3585: ST_TO_ADDR
// ru2_sold := [ ] ;
3586: LD_ADDR_EXP 33
3590: PUSH
3591: EMPTY
3592: ST_TO_ADDR
// ru2_stw := [ ] ;
3593: LD_ADDR_EXP 34
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// ru2_tw := [ ] ;
3600: LD_ADDR_EXP 35
3604: PUSH
3605: EMPTY
3606: ST_TO_ADDR
// ru2_b := [ ] ;
3607: LD_ADDR_EXP 42
3611: PUSH
3612: EMPTY
3613: ST_TO_ADDR
// ru2_eng := [ ] ;
3614: LD_ADDR_EXP 38
3618: PUSH
3619: EMPTY
3620: ST_TO_ADDR
// ru2_mech := [ ] ;
3621: LD_ADDR_EXP 39
3625: PUSH
3626: EMPTY
3627: ST_TO_ADDR
// ru2_sci := [ ] ;
3628: LD_ADDR_EXP 40
3632: PUSH
3633: EMPTY
3634: ST_TO_ADDR
// ru2_bul := [ b_lab , 90 , 71 , 1 , b_armoury , 88 , 58 , 2 , b_workshop , 103 , 66 , 4 , b_oil_power , 106 , 77 , 3 , b_oil_power , 110 , 77 , 3 , b_bunker , 109 , 65 , 4 , b_bunker , 92 , 85 , 0 , b_bunker , 74 , 72 , 0 , b_bunker , 71 , 66 , 2 , b_bunker , 115 , 79 , 4 , b_bunker , 112 , 69 , 4 , b_bunker , 111 , 84 , 5 ] ;
3635: LD_ADDR_EXP 41
3639: PUSH
3640: LD_INT 6
3642: PUSH
3643: LD_INT 90
3645: PUSH
3646: LD_INT 71
3648: PUSH
3649: LD_INT 1
3651: PUSH
3652: LD_INT 4
3654: PUSH
3655: LD_INT 88
3657: PUSH
3658: LD_INT 58
3660: PUSH
3661: LD_INT 2
3663: PUSH
3664: LD_INT 2
3666: PUSH
3667: LD_INT 103
3669: PUSH
3670: LD_INT 66
3672: PUSH
3673: LD_INT 4
3675: PUSH
3676: LD_INT 26
3678: PUSH
3679: LD_INT 106
3681: PUSH
3682: LD_INT 77
3684: PUSH
3685: LD_INT 3
3687: PUSH
3688: LD_INT 26
3690: PUSH
3691: LD_INT 110
3693: PUSH
3694: LD_INT 77
3696: PUSH
3697: LD_INT 3
3699: PUSH
3700: LD_INT 32
3702: PUSH
3703: LD_INT 109
3705: PUSH
3706: LD_INT 65
3708: PUSH
3709: LD_INT 4
3711: PUSH
3712: LD_INT 32
3714: PUSH
3715: LD_INT 92
3717: PUSH
3718: LD_INT 85
3720: PUSH
3721: LD_INT 0
3723: PUSH
3724: LD_INT 32
3726: PUSH
3727: LD_INT 74
3729: PUSH
3730: LD_INT 72
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 32
3738: PUSH
3739: LD_INT 71
3741: PUSH
3742: LD_INT 66
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: LD_INT 32
3750: PUSH
3751: LD_INT 115
3753: PUSH
3754: LD_INT 79
3756: PUSH
3757: LD_INT 4
3759: PUSH
3760: LD_INT 32
3762: PUSH
3763: LD_INT 112
3765: PUSH
3766: LD_INT 69
3768: PUSH
3769: LD_INT 4
3771: PUSH
3772: LD_INT 32
3774: PUSH
3775: LD_INT 111
3777: PUSH
3778: LD_INT 84
3780: PUSH
3781: LD_INT 5
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: ST_TO_ADDR
// ru2_tech := [ tech_tech1 , tech_tech2 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_advmet , tech_weap3 , tech_tech3 ] ;
3834: LD_ADDR_EXP 36
3838: PUSH
3839: LD_INT 48
3841: PUSH
3842: LD_INT 49
3844: PUSH
3845: LD_INT 51
3847: PUSH
3848: LD_INT 52
3850: PUSH
3851: LD_INT 69
3853: PUSH
3854: LD_INT 39
3856: PUSH
3857: LD_INT 34
3859: PUSH
3860: LD_INT 53
3862: PUSH
3863: LD_INT 50
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: ST_TO_ADDR
// ru2_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
3877: LD_ADDR_EXP 37
3881: PUSH
3882: LD_INT 21
3884: PUSH
3885: LD_INT 1
3887: PUSH
3888: LD_INT 1
3890: PUSH
3891: LD_INT 51
3893: PUSH
3894: LD_INT 22
3896: PUSH
3897: LD_INT 1
3899: PUSH
3900: LD_INT 1
3902: PUSH
3903: LD_INT 52
3905: PUSH
3906: LD_INT 22
3908: PUSH
3909: LD_INT 1
3911: PUSH
3912: LD_INT 1
3914: PUSH
3915: LD_INT 52
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: ST_TO_ADDR
// SetBName ( beria , beria ) ;
3932: LD_INT 106
3934: PPUSH
3935: LD_STRING beria
3937: PPUSH
3938: CALL_OW 500
// SetBName ( kagan , kagan ) ;
3942: LD_INT 112
3944: PPUSH
3945: LD_STRING kagan
3947: PPUSH
3948: CALL_OW 500
// for i = 1 to 12 do
3952: LD_ADDR_VAR 0 4
3956: PUSH
3957: DOUBLE
3958: LD_INT 1
3960: DEC
3961: ST_TO_ADDR
3962: LD_INT 12
3964: PUSH
3965: FOR_TO
3966: IFFALSE 4003
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_INT 1
3975: PPUSH
3976: LD_EXP 5
3980: PPUSH
3981: CALL 418 0 2
3985: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3986: LD_VAR 0 5
3990: PPUSH
3991: LD_INT 9
3993: PPUSH
3994: LD_INT 0
3996: PPUSH
3997: CALL_OW 49
// end ;
4001: GO 3965
4003: POP
4004: POP
// for i = 1 to 6 do
4005: LD_ADDR_VAR 0 4
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 6
4017: PUSH
4018: FOR_TO
4019: IFFALSE 4056
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
4021: LD_ADDR_VAR 0 5
4025: PUSH
4026: LD_INT 3
4028: PPUSH
4029: LD_EXP 5
4033: PPUSH
4034: CALL 418 0 2
4038: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4039: LD_VAR 0 5
4043: PPUSH
4044: LD_INT 9
4046: PPUSH
4047: LD_INT 0
4049: PPUSH
4050: CALL_OW 49
// end ;
4054: GO 4018
4056: POP
4057: POP
// for i = 1 to 4 do
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: DOUBLE
4064: LD_INT 1
4066: DEC
4067: ST_TO_ADDR
4068: LD_INT 4
4070: PUSH
4071: FOR_TO
4072: IFFALSE 4109
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
4074: LD_ADDR_VAR 0 5
4078: PUSH
4079: LD_INT 4
4081: PPUSH
4082: LD_EXP 5
4086: PPUSH
4087: CALL 418 0 2
4091: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4092: LD_VAR 0 5
4096: PPUSH
4097: LD_INT 9
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 49
// end ;
4107: GO 4071
4109: POP
4110: POP
// for i = 1 to 4 do
4111: LD_ADDR_VAR 0 4
4115: PUSH
4116: DOUBLE
4117: LD_INT 1
4119: DEC
4120: ST_TO_ADDR
4121: LD_INT 4
4123: PUSH
4124: FOR_TO
4125: IFFALSE 4162
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
4127: LD_ADDR_VAR 0 5
4131: PUSH
4132: LD_INT 2
4134: PPUSH
4135: LD_EXP 5
4139: PPUSH
4140: CALL 418 0 2
4144: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
4145: LD_VAR 0 5
4149: PPUSH
4150: LD_INT 9
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 49
// end ;
4160: GO 4124
4162: POP
4163: POP
// end ;
4164: LD_VAR 0 1
4168: RET
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , enemy_detected ;
4169: GO 4171
4171: DISABLE
4172: LD_INT 0
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
// begin enable ;
4184: ENABLE
// ru_sold := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) diff Kurin ;
4185: LD_ADDR_EXP 23
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 6
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 25
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 24
4212: PUSH
4213: LD_INT 600
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: PPUSH
4228: CALL_OW 69
4232: PUSH
4233: LD_EXP 15
4237: DIFF
4238: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
4239: LD_ADDR_EXP 28
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_INT 6
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: LD_INT 25
4256: PUSH
4257: LD_INT 2
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 24
4266: PUSH
4267: LD_INT 600
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: PPUSH
4282: CALL_OW 69
4286: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
4287: LD_ADDR_EXP 29
4291: PUSH
4292: LD_INT 22
4294: PUSH
4295: LD_INT 6
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 25
4304: PUSH
4305: LD_INT 3
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 24
4314: PUSH
4315: LD_INT 600
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: PUSH
4327: EMPTY
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
4335: LD_ADDR_EXP 30
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 6
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 4
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 24
4362: PUSH
4363: LD_INT 600
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: EMPTY
4376: LIST
4377: PPUSH
4378: CALL_OW 69
4382: ST_TO_ADDR
// ru_tw := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
4383: LD_ADDR_EXP 25
4387: PUSH
4388: LD_INT 22
4390: PUSH
4391: LD_INT 6
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: LD_INT 30
4403: PUSH
4404: LD_INT 31
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PUSH
4411: LD_INT 30
4413: PUSH
4414: LD_INT 32
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 24
4428: PUSH
4429: LD_INT 250
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: PPUSH
4444: CALL_OW 69
4448: ST_TO_ADDR
// ru_b := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) ;
4449: LD_ADDR_EXP 32
4453: PUSH
4454: LD_INT 22
4456: PUSH
4457: LD_INT 6
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 21
4466: PUSH
4467: LD_INT 3
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PPUSH
4478: CALL_OW 69
4482: ST_TO_ADDR
// b_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4483: LD_ADDR_VAR 0 6
4487: PUSH
4488: LD_INT 22
4490: PUSH
4491: LD_INT 6
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 21
4500: PUSH
4501: LD_INT 3
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: LD_INT 24
4513: PUSH
4514: LD_INT 1000
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: LIST
4529: PUSH
4530: EMPTY
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
4538: LD_ADDR_VAR 0 5
4542: PUSH
4543: LD_INT 22
4545: PUSH
4546: LD_INT 6
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 21
4555: PUSH
4556: LD_INT 1
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 3
4565: PUSH
4566: LD_INT 24
4568: PUSH
4569: LD_INT 600
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: PUSH
4585: EMPTY
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// b_weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar , 89 ] ;
4593: LD_ADDR_VAR 0 8
4597: PUSH
4598: LD_INT 92
4600: PPUSH
4601: CALL_OW 478
4605: PUSH
4606: LD_INT 52
4608: PUSH
4609: LD_INT 51
4611: PUSH
4612: LD_INT 53
4614: PUSH
4615: LD_EXP 44
4619: PUSH
4620: LD_INT 89
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: DIFF
4630: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_breastwork , b_workshop ] ;
4631: LD_ADDR_VAR 0 9
4635: PUSH
4636: LD_INT 0
4638: PUSH
4639: LD_INT 4
4641: PUSH
4642: LD_INT 31
4644: PUSH
4645: LD_INT 2
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: LIST
4653: ST_TO_ADDR
// if FilterUnitsInArea ( kirov_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) > 0 then
4654: LD_INT 10
4656: PPUSH
4657: LD_INT 2
4659: PUSH
4660: LD_INT 22
4662: PUSH
4663: LD_INT 1
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PUSH
4670: LD_INT 22
4672: PUSH
4673: LD_INT 2
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 70
4689: PUSH
4690: LD_INT 0
4692: GREATER
4693: IFFALSE 4705
// enemy_detected := true else
4695: LD_ADDR_VAR 0 10
4699: PUSH
4700: LD_INT 1
4702: ST_TO_ADDR
4703: GO 4713
// enemy_detected := false ;
4705: LD_ADDR_VAR 0 10
4709: PUSH
4710: LD_INT 0
4712: ST_TO_ADDR
// if enemy_detected = false then
4713: LD_VAR 0 10
4717: PUSH
4718: LD_INT 0
4720: EQUAL
4721: IFFALSE 4783
// for i = 1 to ru_b do
4723: LD_ADDR_VAR 0 1
4727: PUSH
4728: DOUBLE
4729: LD_INT 1
4731: DEC
4732: ST_TO_ADDR
4733: LD_EXP 32
4737: PUSH
4738: FOR_TO
4739: IFFALSE 4781
// if GetBType ( ru_b [ i ] ) in b_upgrade then
4741: LD_EXP 32
4745: PUSH
4746: LD_VAR 0 1
4750: ARRAY
4751: PPUSH
4752: CALL_OW 266
4756: PUSH
4757: LD_VAR 0 9
4761: IN
4762: IFFALSE 4779
// ComUpgrade ( ru_b [ i ] ) ;
4764: LD_EXP 32
4768: PUSH
4769: LD_VAR 0 1
4773: ARRAY
4774: PPUSH
4775: CALL_OW 146
4779: GO 4738
4781: POP
4782: POP
// if ru_sold > 0 then
4783: LD_EXP 23
4787: PUSH
4788: LD_INT 0
4790: GREATER
4791: IFFALSE 5239
// begin filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4793: LD_ADDR_VAR 0 4
4797: PUSH
4798: LD_EXP 23
4802: PPUSH
4803: LD_INT 3
4805: PUSH
4806: LD_INT 54
4808: PUSH
4809: EMPTY
4810: LIST
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PPUSH
4816: CALL_OW 72
4820: ST_TO_ADDR
// if UnitFilter ( ru_tw , [ f_empty ] ) > 0 then
4821: LD_EXP 25
4825: PPUSH
4826: LD_INT 58
4828: PUSH
4829: EMPTY
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: PUSH
4837: LD_INT 0
4839: GREATER
4840: IFFALSE 4942
// begin if filter = 0 then
4842: LD_VAR 0 4
4846: PUSH
4847: LD_INT 0
4849: EQUAL
4850: IFFALSE 4875
// ComExitBuilding ( ru_sold [ Rand ( 1 , ru_sold ) ] ) ;
4852: LD_EXP 23
4856: PUSH
4857: LD_INT 1
4859: PPUSH
4860: LD_EXP 23
4864: PPUSH
4865: CALL_OW 12
4869: ARRAY
4870: PPUSH
4871: CALL_OW 122
// filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
4875: LD_ADDR_VAR 0 4
4879: PUSH
4880: LD_EXP 23
4884: PPUSH
4885: LD_INT 3
4887: PUSH
4888: LD_INT 54
4890: PUSH
4891: EMPTY
4892: LIST
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PPUSH
4898: CALL_OW 72
4902: ST_TO_ADDR
// if filter then
4903: LD_VAR 0 4
4907: IFFALSE 4942
// ComEnterUnit ( filter [ 1 ] , UnitFilter ( ru_tw , [ f_empty ] ) [ 1 ] ) ;
4909: LD_VAR 0 4
4913: PUSH
4914: LD_INT 1
4916: ARRAY
4917: PPUSH
4918: LD_EXP 25
4922: PPUSH
4923: LD_INT 58
4925: PUSH
4926: EMPTY
4927: LIST
4928: PPUSH
4929: CALL_OW 72
4933: PUSH
4934: LD_INT 1
4936: ARRAY
4937: PPUSH
4938: CALL_OW 120
// end ; if UnitFilter ( ru_tw , [ f_empty ] ) = 0 then
4942: LD_EXP 25
4946: PPUSH
4947: LD_INT 58
4949: PUSH
4950: EMPTY
4951: LIST
4952: PPUSH
4953: CALL_OW 72
4957: PUSH
4958: LD_INT 0
4960: EQUAL
4961: IFFALSE 5116
// begin b_unit := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4963: LD_ADDR_VAR 0 7
4967: PUSH
4968: LD_INT 22
4970: PUSH
4971: LD_INT 6
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 2
4980: PUSH
4981: LD_INT 30
4983: PUSH
4984: LD_INT 4
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 5
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PPUSH
5010: CALL_OW 69
5014: ST_TO_ADDR
// if b_unit > 0 then
5015: LD_VAR 0 7
5019: PUSH
5020: LD_INT 0
5022: GREATER
5023: IFFALSE 5116
// for p = 1 to b_unit do
5025: LD_ADDR_VAR 0 2
5029: PUSH
5030: DOUBLE
5031: LD_INT 1
5033: DEC
5034: ST_TO_ADDR
5035: LD_VAR 0 7
5039: PUSH
5040: FOR_TO
5041: IFFALSE 5114
// if UnitsInSide ( b_unit [ p ] ) < 6 then
5043: LD_VAR 0 7
5047: PUSH
5048: LD_VAR 0 2
5052: ARRAY
5053: PPUSH
5054: CALL_OW 313
5058: PUSH
5059: LD_INT 6
5061: LESS
5062: IFFALSE 5112
// for i = 1 to filter do
5064: LD_ADDR_VAR 0 1
5068: PUSH
5069: DOUBLE
5070: LD_INT 1
5072: DEC
5073: ST_TO_ADDR
5074: LD_VAR 0 4
5078: PUSH
5079: FOR_TO
5080: IFFALSE 5110
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
5082: LD_VAR 0 4
5086: PUSH
5087: LD_VAR 0 1
5091: ARRAY
5092: PPUSH
5093: LD_VAR 0 7
5097: PUSH
5098: LD_VAR 0 2
5102: ARRAY
5103: PPUSH
5104: CALL_OW 120
5108: GO 5079
5110: POP
5111: POP
5112: GO 5040
5114: POP
5115: POP
// end ; if UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
5116: LD_EXP 25
5120: PPUSH
5121: LD_INT 30
5123: PUSH
5124: LD_INT 32
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: PUSH
5131: LD_INT 35
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PPUSH
5145: CALL_OW 72
5149: PUSH
5150: LD_INT 0
5152: GREATER
5153: IFFALSE 5239
// begin filter := UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
5155: LD_ADDR_VAR 0 4
5159: PUSH
5160: LD_EXP 25
5164: PPUSH
5165: LD_INT 30
5167: PUSH
5168: LD_INT 32
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 35
5177: PUSH
5178: LD_INT 0
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PPUSH
5189: CALL_OW 72
5193: ST_TO_ADDR
// if BuildingStatus ( ru_fac ) = bs_idle then
5194: LD_INT 92
5196: PPUSH
5197: CALL_OW 461
5201: PUSH
5202: LD_INT 2
5204: EQUAL
5205: IFFALSE 5239
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
5207: LD_VAR 0 4
5211: PUSH
5212: LD_INT 1
5214: ARRAY
5215: PPUSH
5216: LD_VAR 0 8
5220: PUSH
5221: LD_INT 1
5223: PPUSH
5224: LD_VAR 0 8
5228: PPUSH
5229: CALL_OW 12
5233: ARRAY
5234: PPUSH
5235: CALL_OW 148
// end ; end ; if ru_mech > 0 then
5239: LD_EXP 29
5243: PUSH
5244: LD_INT 0
5246: GREATER
5247: IFFALSE 5307
// for i = 1 to ru_mech do
5249: LD_ADDR_VAR 0 1
5253: PUSH
5254: DOUBLE
5255: LD_INT 1
5257: DEC
5258: ST_TO_ADDR
5259: LD_EXP 29
5263: PUSH
5264: FOR_TO
5265: IFFALSE 5305
// if not IsInUnit ( ru_mech [ i ] ) then
5267: LD_EXP 29
5271: PUSH
5272: LD_VAR 0 1
5276: ARRAY
5277: PPUSH
5278: CALL_OW 310
5282: NOT
5283: IFFALSE 5303
// ComEnterUnit ( ru_mech [ i ] , ru_fac ) ;
5285: LD_EXP 29
5289: PUSH
5290: LD_VAR 0 1
5294: ARRAY
5295: PPUSH
5296: LD_INT 92
5298: PPUSH
5299: CALL_OW 120
5303: GO 5264
5305: POP
5306: POP
// if ru_fac then
5307: LD_INT 92
5309: IFFALSE 5415
// if ru_veh > 0 then
5311: LD_EXP 27
5315: PUSH
5316: LD_INT 0
5318: GREATER
5319: IFFALSE 5415
// if BuildingStatus ( ru_fac ) = bs_idle then
5321: LD_INT 92
5323: PPUSH
5324: CALL_OW 461
5328: PUSH
5329: LD_INT 2
5331: EQUAL
5332: IFFALSE 5415
// begin ComConstruct ( ru_fac , ru_veh [ 1 ] , ru_veh [ 2 ] , ru_veh [ 3 ] , ru_veh [ 4 ] ) ;
5334: LD_INT 92
5336: PPUSH
5337: LD_EXP 27
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PPUSH
5346: LD_EXP 27
5350: PUSH
5351: LD_INT 2
5353: ARRAY
5354: PPUSH
5355: LD_EXP 27
5359: PUSH
5360: LD_INT 3
5362: ARRAY
5363: PPUSH
5364: LD_EXP 27
5368: PUSH
5369: LD_INT 4
5371: ARRAY
5372: PPUSH
5373: CALL_OW 125
// for i = 1 to 4 do
5377: LD_ADDR_VAR 0 1
5381: PUSH
5382: DOUBLE
5383: LD_INT 1
5385: DEC
5386: ST_TO_ADDR
5387: LD_INT 4
5389: PUSH
5390: FOR_TO
5391: IFFALSE 5413
// ru_veh := Delete ( ru_veh , 1 ) ;
5393: LD_ADDR_EXP 27
5397: PUSH
5398: LD_EXP 27
5402: PPUSH
5403: LD_INT 1
5405: PPUSH
5406: CALL_OW 3
5410: ST_TO_ADDR
5411: GO 5390
5413: POP
5414: POP
// end ; if ru_bul > 0 and enemy_detected = false then
5415: LD_EXP 31
5419: PUSH
5420: LD_INT 0
5422: GREATER
5423: PUSH
5424: LD_VAR 0 10
5428: PUSH
5429: LD_INT 0
5431: EQUAL
5432: AND
5433: IFFALSE 5536
// if ru_eng > 0 then
5435: LD_EXP 28
5439: PUSH
5440: LD_INT 0
5442: GREATER
5443: IFFALSE 5536
// for i = 1 to ru_eng do
5445: LD_ADDR_VAR 0 1
5449: PUSH
5450: DOUBLE
5451: LD_INT 1
5453: DEC
5454: ST_TO_ADDR
5455: LD_EXP 28
5459: PUSH
5460: FOR_TO
5461: IFFALSE 5534
// if not HasTask ( ru_eng [ i ] ) then
5463: LD_EXP 28
5467: PUSH
5468: LD_VAR 0 1
5472: ARRAY
5473: PPUSH
5474: CALL_OW 314
5478: NOT
5479: IFFALSE 5532
// begin ComBuild ( ru_eng [ i ] , ru_bul [ 1 ] , ru_bul [ 2 ] , ru_bul [ 3 ] , ru_bul [ 4 ] ) ;
5481: LD_EXP 28
5485: PUSH
5486: LD_VAR 0 1
5490: ARRAY
5491: PPUSH
5492: LD_EXP 31
5496: PUSH
5497: LD_INT 1
5499: ARRAY
5500: PPUSH
5501: LD_EXP 31
5505: PUSH
5506: LD_INT 2
5508: ARRAY
5509: PPUSH
5510: LD_EXP 31
5514: PUSH
5515: LD_INT 3
5517: ARRAY
5518: PPUSH
5519: LD_EXP 31
5523: PUSH
5524: LD_INT 4
5526: ARRAY
5527: PPUSH
5528: CALL_OW 145
// end ;
5532: GO 5460
5534: POP
5535: POP
// if b_dmgunit > 0 then
5536: LD_VAR 0 6
5540: PUSH
5541: LD_INT 0
5543: GREATER
5544: IFFALSE 5729
// begin if ru_eng > 0 then
5546: LD_EXP 28
5550: PUSH
5551: LD_INT 0
5553: GREATER
5554: IFFALSE 5634
// for i = 1 to ru_eng do
5556: LD_ADDR_VAR 0 1
5560: PUSH
5561: DOUBLE
5562: LD_INT 1
5564: DEC
5565: ST_TO_ADDR
5566: LD_EXP 28
5570: PUSH
5571: FOR_TO
5572: IFFALSE 5632
// begin if IsInUnit ( ru_eng [ i ] ) then
5574: LD_EXP 28
5578: PUSH
5579: LD_VAR 0 1
5583: ARRAY
5584: PPUSH
5585: CALL_OW 310
5589: IFFALSE 5606
// ComExitBuilding ( ru_eng [ i ] ) ;
5591: LD_EXP 28
5595: PUSH
5596: LD_VAR 0 1
5600: ARRAY
5601: PPUSH
5602: CALL_OW 122
// ComRepairBuilding ( ru_eng [ i ] , b_dmgunit [ 1 ] ) ;
5606: LD_EXP 28
5610: PUSH
5611: LD_VAR 0 1
5615: ARRAY
5616: PPUSH
5617: LD_VAR 0 6
5621: PUSH
5622: LD_INT 1
5624: ARRAY
5625: PPUSH
5626: CALL_OW 130
// end ;
5630: GO 5571
5632: POP
5633: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) > 0 then
5634: LD_INT 22
5636: PUSH
5637: LD_INT 6
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PUSH
5644: LD_INT 34
5646: PUSH
5647: LD_INT 52
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PPUSH
5658: CALL_OW 69
5662: PUSH
5663: LD_INT 0
5665: GREATER
5666: IFFALSE 5727
// for p in FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) do
5668: LD_ADDR_VAR 0 2
5672: PUSH
5673: LD_INT 22
5675: PUSH
5676: LD_INT 6
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: PUSH
5683: LD_INT 34
5685: PUSH
5686: LD_INT 52
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: PUSH
5702: FOR_IN
5703: IFFALSE 5725
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
5705: LD_VAR 0 2
5709: PPUSH
5710: LD_VAR 0 6
5714: PUSH
5715: LD_INT 1
5717: ARRAY
5718: PPUSH
5719: CALL_OW 130
5723: GO 5702
5725: POP
5726: POP
// end else
5727: GO 5857
// if ru_bul = 0 then
5729: LD_EXP 31
5733: PUSH
5734: LD_INT 0
5736: EQUAL
5737: IFFALSE 5857
// for i = 1 to ru_eng do
5739: LD_ADDR_VAR 0 1
5743: PUSH
5744: DOUBLE
5745: LD_INT 1
5747: DEC
5748: ST_TO_ADDR
5749: LD_EXP 28
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5855
// if not HasTask ( ru_eng [ i ] ) then
5757: LD_EXP 28
5761: PUSH
5762: LD_VAR 0 1
5766: ARRAY
5767: PPUSH
5768: CALL_OW 314
5772: NOT
5773: IFFALSE 5853
// ComEnterUnit ( ru_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru_eng [ i ] ) ) ;
5775: LD_EXP 28
5779: PUSH
5780: LD_VAR 0 1
5784: ARRAY
5785: PPUSH
5786: LD_INT 22
5788: PUSH
5789: LD_INT 6
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: LD_INT 2
5798: PUSH
5799: LD_INT 30
5801: PUSH
5802: LD_INT 0
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 30
5811: PUSH
5812: LD_INT 1
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PPUSH
5828: CALL_OW 69
5832: PPUSH
5833: LD_EXP 28
5837: PUSH
5838: LD_VAR 0 1
5842: ARRAY
5843: PPUSH
5844: CALL_OW 74
5848: PPUSH
5849: CALL_OW 120
5853: GO 5754
5855: POP
5856: POP
// if h_dmgunit > 0 then
5857: LD_VAR 0 5
5861: PUSH
5862: LD_INT 0
5864: GREATER
5865: IFFALSE 6072
// begin for p = 1 to h_dmgunit do
5867: LD_ADDR_VAR 0 2
5871: PUSH
5872: DOUBLE
5873: LD_INT 1
5875: DEC
5876: ST_TO_ADDR
5877: LD_VAR 0 5
5881: PUSH
5882: FOR_TO
5883: IFFALSE 5932
// if GetDistUnits ( h_dmgunit [ p ] , ru_lab ) > 6 then
5885: LD_VAR 0 5
5889: PUSH
5890: LD_VAR 0 2
5894: ARRAY
5895: PPUSH
5896: LD_INT 83
5898: PPUSH
5899: CALL_OW 296
5903: PUSH
5904: LD_INT 6
5906: GREATER
5907: IFFALSE 5930
// ComMoveXY ( h_dmgunit [ p ] , 140 , 76 ) ;
5909: LD_VAR 0 5
5913: PUSH
5914: LD_VAR 0 2
5918: ARRAY
5919: PPUSH
5920: LD_INT 140
5922: PPUSH
5923: LD_INT 76
5925: PPUSH
5926: CALL_OW 111
5930: GO 5882
5932: POP
5933: POP
// if ru_sci > 0 then
5934: LD_EXP 30
5938: PUSH
5939: LD_INT 0
5941: GREATER
5942: IFFALSE 6072
// for i = 1 to ru_sci do
5944: LD_ADDR_VAR 0 1
5948: PUSH
5949: DOUBLE
5950: LD_INT 1
5952: DEC
5953: ST_TO_ADDR
5954: LD_EXP 30
5958: PUSH
5959: FOR_TO
5960: IFFALSE 6070
// if IsInUnit ( ru_sci [ i ] ) then
5962: LD_EXP 30
5966: PUSH
5967: LD_VAR 0 1
5971: ARRAY
5972: PPUSH
5973: CALL_OW 310
5977: IFFALSE 5996
// ComExitBuilding ( ru_sci [ i ] ) else
5979: LD_EXP 30
5983: PUSH
5984: LD_VAR 0 1
5988: ARRAY
5989: PPUSH
5990: CALL_OW 122
5994: GO 6068
// if not HasTask ( ru_sci [ i ] ) then
5996: LD_EXP 30
6000: PUSH
6001: LD_VAR 0 1
6005: ARRAY
6006: PPUSH
6007: CALL_OW 314
6011: NOT
6012: IFFALSE 6068
// if GetDistUnits ( ru_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
6014: LD_EXP 30
6018: PUSH
6019: LD_VAR 0 1
6023: ARRAY
6024: PPUSH
6025: LD_VAR 0 5
6029: PUSH
6030: LD_INT 1
6032: ARRAY
6033: PPUSH
6034: CALL_OW 296
6038: PUSH
6039: LD_INT 15
6041: LESSEQUAL
6042: IFFALSE 6068
// ComHeal ( ru_sci [ i ] , h_dmgunit [ 1 ] ) ;
6044: LD_EXP 30
6048: PUSH
6049: LD_VAR 0 1
6053: ARRAY
6054: PPUSH
6055: LD_VAR 0 5
6059: PUSH
6060: LD_INT 1
6062: ARRAY
6063: PPUSH
6064: CALL_OW 128
6068: GO 5959
6070: POP
6071: POP
// end ; if h_dmgunit = 0 then
6072: LD_VAR 0 5
6076: PUSH
6077: LD_INT 0
6079: EQUAL
6080: IFFALSE 6197
// begin for i = 1 to ru_sci do
6082: LD_ADDR_VAR 0 1
6086: PUSH
6087: DOUBLE
6088: LD_INT 1
6090: DEC
6091: ST_TO_ADDR
6092: LD_EXP 30
6096: PUSH
6097: FOR_TO
6098: IFFALSE 6138
// if not IsInUnit ( ru_sci [ i ] ) then
6100: LD_EXP 30
6104: PUSH
6105: LD_VAR 0 1
6109: ARRAY
6110: PPUSH
6111: CALL_OW 310
6115: NOT
6116: IFFALSE 6136
// ComEnterUnit ( ru_sci [ i ] , ru_lab ) ;
6118: LD_EXP 30
6122: PUSH
6123: LD_VAR 0 1
6127: ARRAY
6128: PPUSH
6129: LD_INT 83
6131: PPUSH
6132: CALL_OW 120
6136: GO 6097
6138: POP
6139: POP
// if ru_tech > 0 then
6140: LD_EXP 26
6144: PUSH
6145: LD_INT 0
6147: GREATER
6148: IFFALSE 6197
// if BuildingStatus ( ru_lab ) = bs_idle then
6150: LD_INT 83
6152: PPUSH
6153: CALL_OW 461
6157: PUSH
6158: LD_INT 2
6160: EQUAL
6161: IFFALSE 6197
// begin ComResearch ( ru_lab , ru_tech [ 1 ] ) ;
6163: LD_INT 83
6165: PPUSH
6166: LD_EXP 26
6170: PUSH
6171: LD_INT 1
6173: ARRAY
6174: PPUSH
6175: CALL_OW 124
// ru_tech := Delete ( ru_tech , 1 ) ;
6179: LD_ADDR_EXP 26
6183: PUSH
6184: LD_EXP 26
6188: PPUSH
6189: LD_INT 1
6191: PPUSH
6192: CALL_OW 3
6196: ST_TO_ADDR
// end ; end ; end ;
6197: PPOPN 10
6199: END
// every 20 20$00 trigger ru_fac do var weap ;
6200: LD_INT 92
6202: IFFALSE 6429
6204: GO 6206
6206: DISABLE
6207: LD_INT 0
6209: PPUSH
// begin enable ;
6210: ENABLE
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6211: LD_ADDR_VAR 0 1
6215: PUSH
6216: LD_INT 22
6218: PUSH
6219: LD_INT 6
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 30
6228: PUSH
6229: LD_INT 3
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PPUSH
6240: CALL_OW 69
6244: PUSH
6245: LD_INT 1
6247: ARRAY
6248: PPUSH
6249: CALL_OW 478
6253: PUSH
6254: LD_INT 52
6256: PUSH
6257: LD_INT 51
6259: PUSH
6260: LD_INT 53
6262: PUSH
6263: LD_EXP 44
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: ST_TO_ADDR
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6275: LD_ADDR_EXP 27
6279: PUSH
6280: LD_EXP 27
6284: PUSH
6285: LD_INT 23
6287: PUSH
6288: LD_INT 1
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: LD_VAR 0 1
6298: PUSH
6299: LD_INT 1
6301: PPUSH
6302: LD_VAR 0 1
6306: PPUSH
6307: CALL_OW 12
6311: ARRAY
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: ADD
6319: ST_TO_ADDR
// weap := AvailableWeaponList ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
6320: LD_ADDR_VAR 0 1
6324: PUSH
6325: LD_INT 22
6327: PUSH
6328: LD_INT 3
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 30
6337: PUSH
6338: LD_INT 3
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PUSH
6354: LD_INT 1
6356: ARRAY
6357: PPUSH
6358: CALL_OW 478
6362: PUSH
6363: LD_INT 52
6365: PUSH
6366: LD_INT 51
6368: PUSH
6369: LD_INT 53
6371: PUSH
6372: LD_EXP 44
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: DIFF
6383: ST_TO_ADDR
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
6384: LD_ADDR_EXP 37
6388: PUSH
6389: LD_EXP 37
6393: PUSH
6394: LD_INT 23
6396: PUSH
6397: LD_INT 1
6399: PUSH
6400: LD_INT 1
6402: PUSH
6403: LD_VAR 0 1
6407: PUSH
6408: LD_INT 1
6410: PPUSH
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL_OW 12
6420: ARRAY
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: ADD
6428: ST_TO_ADDR
// end ;
6429: PPOPN 1
6431: END
// every 0 0$03 do var i , c , p , skr , filter , cargo , dep ;
6432: GO 6434
6434: DISABLE
6435: LD_INT 0
6437: PPUSH
6438: PPUSH
6439: PPUSH
6440: PPUSH
6441: PPUSH
6442: PPUSH
6443: PPUSH
// begin enable ;
6444: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
6445: LD_ADDR_VAR 0 5
6449: PUSH
6450: LD_INT 50
6452: PUSH
6453: EMPTY
6454: LIST
6455: PUSH
6456: LD_INT 22
6458: PUSH
6459: LD_INT 6
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 25
6471: PUSH
6472: LD_INT 2
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PUSH
6479: LD_INT 25
6481: PUSH
6482: LD_INT 16
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: LIST
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: PPUSH
6499: CALL_OW 69
6503: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_weapon , ru_cargo_bay ] , [ f_lives , 600 ] ] ) ;
6504: LD_ADDR_VAR 0 6
6508: PUSH
6509: LD_INT 2
6511: PUSH
6512: LD_INT 22
6514: PUSH
6515: LD_INT 6
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 22
6524: PUSH
6525: LD_INT 3
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PUSH
6532: EMPTY
6533: LIST
6534: LIST
6535: LIST
6536: PUSH
6537: LD_INT 34
6539: PUSH
6540: LD_INT 51
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 24
6549: PUSH
6550: LD_INT 600
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: PPUSH
6562: CALL_OW 69
6566: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6567: LD_ADDR_VAR 0 7
6571: PUSH
6572: LD_INT 2
6574: PUSH
6575: LD_INT 22
6577: PUSH
6578: LD_INT 6
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: LD_INT 22
6587: PUSH
6588: LD_INT 3
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 2
6602: PUSH
6603: LD_INT 30
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: LD_INT 30
6615: PUSH
6616: LD_INT 1
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PPUSH
6632: CALL_OW 69
6636: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_main_area ) ;
6637: LD_ADDR_VAR 0 4
6641: PUSH
6642: LD_INT 2
6644: PPUSH
6645: CALL_OW 435
6649: ST_TO_ADDR
// c = 1 ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_INT 1
6657: ST_TO_ADDR
// if cargo > 0 then
6658: LD_VAR 0 6
6662: PUSH
6663: LD_INT 0
6665: GREATER
6666: IFFALSE 6958
// while c < skr do
6668: LD_VAR 0 2
6672: PUSH
6673: LD_VAR 0 4
6677: LESS
6678: IFFALSE 6958
// begin if cargo then
6680: LD_VAR 0 6
6684: IFFALSE 6956
// for i in cargo do
6686: LD_ADDR_VAR 0 1
6690: PUSH
6691: LD_VAR 0 6
6695: PUSH
6696: FOR_IN
6697: IFFALSE 6954
// begin if not IsOk ( i ) or not skr then
6699: LD_VAR 0 1
6703: PPUSH
6704: CALL_OW 302
6708: NOT
6709: PUSH
6710: LD_VAR 0 4
6714: NOT
6715: OR
6716: IFFALSE 6720
// continue ;
6718: GO 6696
// if c > skr then
6720: LD_VAR 0 2
6724: PUSH
6725: LD_VAR 0 4
6729: GREATER
6730: IFFALSE 6734
// continue ;
6732: GO 6696
// if GetFuel ( i ) > 40 and GetDistUnitXY ( i , skr [ c ] , skr [ c + 1 ] ) < 51 then
6734: LD_VAR 0 1
6738: PPUSH
6739: CALL_OW 261
6743: PUSH
6744: LD_INT 40
6746: GREATER
6747: PUSH
6748: LD_VAR 0 1
6752: PPUSH
6753: LD_VAR 0 4
6757: PUSH
6758: LD_VAR 0 2
6762: ARRAY
6763: PPUSH
6764: LD_VAR 0 4
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: PLUS
6777: ARRAY
6778: PPUSH
6779: CALL_OW 297
6783: PUSH
6784: LD_INT 51
6786: LESS
6787: AND
6788: IFFALSE 6825
// ComCollect ( i , skr [ c ] , skr [ c + 1 ] ) ;
6790: LD_VAR 0 1
6794: PPUSH
6795: LD_VAR 0 4
6799: PUSH
6800: LD_VAR 0 2
6804: ARRAY
6805: PPUSH
6806: LD_VAR 0 4
6810: PUSH
6811: LD_VAR 0 2
6815: PUSH
6816: LD_INT 1
6818: PLUS
6819: ARRAY
6820: PPUSH
6821: CALL_OW 117
// if GetFuel ( i ) <= 40 then
6825: LD_VAR 0 1
6829: PPUSH
6830: CALL_OW 261
6834: PUSH
6835: LD_INT 40
6837: LESSEQUAL
6838: IFFALSE 6938
// begin repeat begin ComMoveXY ( i , GetX ( NearestUnitToUnit ( dep , i ) ) , GetY ( NearestUnitToUnit ( dep , i ) ) ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: LD_VAR 0 7
6849: PPUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 74
6859: PPUSH
6860: CALL_OW 250
6864: PPUSH
6865: LD_VAR 0 7
6869: PPUSH
6870: LD_VAR 0 1
6874: PPUSH
6875: CALL_OW 74
6879: PPUSH
6880: CALL_OW 251
6884: PPUSH
6885: CALL_OW 111
// Wait ( 0 0$01 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// end until GetDistUnits ( i , NearestUnitToUnit ( dep , i ) ) < 5 ;
6896: LD_VAR 0 1
6900: PPUSH
6901: LD_VAR 0 7
6905: PPUSH
6906: LD_VAR 0 1
6910: PPUSH
6911: CALL_OW 74
6915: PPUSH
6916: CALL_OW 296
6920: PUSH
6921: LD_INT 5
6923: LESS
6924: IFFALSE 6840
// SetFuel ( i , 100 ) ;
6926: LD_VAR 0 1
6930: PPUSH
6931: LD_INT 100
6933: PPUSH
6934: CALL_OW 240
// end ; c = c + 2 ;
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_VAR 0 2
6947: PUSH
6948: LD_INT 2
6950: PLUS
6951: ST_TO_ADDR
// end ;
6952: GO 6696
6954: POP
6955: POP
// end ;
6956: GO 6668
// end ;
6958: PPOPN 7
6960: END
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , b_fac , b_labb , b_ext , enemy_detected ;
6961: GO 6963
6963: DISABLE
6964: LD_INT 0
6966: PPUSH
6967: PPUSH
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
6978: PPUSH
// begin enable ;
6979: ENABLE
// ru2_sold := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) ;
6980: LD_ADDR_EXP 33
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 3
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 25
6997: PUSH
6998: LD_INT 1
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: LD_INT 24
7007: PUSH
7008: LD_INT 600
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: PPUSH
7023: CALL_OW 69
7027: ST_TO_ADDR
// ru2_eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
7028: LD_ADDR_EXP 38
7032: PUSH
7033: LD_INT 22
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 25
7045: PUSH
7046: LD_INT 2
7048: PUSH
7049: EMPTY
7050: LIST
7051: LIST
7052: PUSH
7053: LD_INT 24
7055: PUSH
7056: LD_INT 600
7058: PUSH
7059: EMPTY
7060: LIST
7061: LIST
7062: PUSH
7063: EMPTY
7064: LIST
7065: LIST
7066: LIST
7067: PUSH
7068: EMPTY
7069: LIST
7070: PPUSH
7071: CALL_OW 69
7075: ST_TO_ADDR
// ru2_mech := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
7076: LD_ADDR_EXP 39
7080: PUSH
7081: LD_INT 22
7083: PUSH
7084: LD_INT 3
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: LD_INT 25
7093: PUSH
7094: LD_INT 3
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PUSH
7101: LD_INT 24
7103: PUSH
7104: LD_INT 600
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: EMPTY
7117: LIST
7118: PPUSH
7119: CALL_OW 69
7123: ST_TO_ADDR
// ru2_sci := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
7124: LD_ADDR_EXP 40
7128: PUSH
7129: LD_INT 22
7131: PUSH
7132: LD_INT 3
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PUSH
7139: LD_INT 25
7141: PUSH
7142: LD_INT 4
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: PUSH
7149: LD_INT 24
7151: PUSH
7152: LD_INT 600
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: PUSH
7164: EMPTY
7165: LIST
7166: PPUSH
7167: CALL_OW 69
7171: ST_TO_ADDR
// ru2_tw := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
7172: LD_ADDR_EXP 35
7176: PUSH
7177: LD_INT 22
7179: PUSH
7180: LD_INT 3
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: LD_INT 2
7189: PUSH
7190: LD_INT 30
7192: PUSH
7193: LD_INT 31
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 30
7202: PUSH
7203: LD_INT 32
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: LIST
7214: PUSH
7215: LD_INT 24
7217: PUSH
7218: LD_INT 250
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: LIST
7229: PUSH
7230: EMPTY
7231: LIST
7232: PPUSH
7233: CALL_OW 69
7237: ST_TO_ADDR
// ru2_b := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
7238: LD_ADDR_EXP 42
7242: PUSH
7243: LD_INT 22
7245: PUSH
7246: LD_INT 3
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: LD_INT 21
7255: PUSH
7256: LD_INT 3
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: PPUSH
7267: CALL_OW 69
7271: ST_TO_ADDR
// b_dmgunit := FilterUnitsInArea ( beria_defa , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
7272: LD_ADDR_VAR 0 6
7276: PUSH
7277: LD_INT 17
7279: PPUSH
7280: LD_INT 22
7282: PUSH
7283: LD_INT 3
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 21
7292: PUSH
7293: LD_INT 3
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PUSH
7300: LD_INT 3
7302: PUSH
7303: LD_INT 24
7305: PUSH
7306: LD_INT 1000
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: LIST
7321: PUSH
7322: EMPTY
7323: LIST
7324: PPUSH
7325: CALL_OW 70
7329: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
7330: LD_ADDR_VAR 0 5
7334: PUSH
7335: LD_INT 22
7337: PUSH
7338: LD_INT 3
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PUSH
7345: LD_INT 21
7347: PUSH
7348: LD_INT 1
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 24
7360: PUSH
7361: LD_INT 600
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: LIST
7376: PUSH
7377: EMPTY
7378: LIST
7379: PPUSH
7380: CALL_OW 69
7384: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7385: LD_INT 22
7387: PUSH
7388: LD_INT 3
7390: PUSH
7391: EMPTY
7392: LIST
7393: LIST
7394: PUSH
7395: LD_INT 30
7397: PUSH
7398: LD_INT 3
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: PPUSH
7409: CALL_OW 69
7413: IFFALSE 7453
// b_fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7415: LD_ADDR_VAR 0 10
7419: PUSH
7420: LD_INT 22
7422: PUSH
7423: LD_INT 3
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 30
7432: PUSH
7433: LD_INT 3
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: EMPTY
7441: LIST
7442: LIST
7443: PPUSH
7444: CALL_OW 69
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
7453: LD_INT 22
7455: PUSH
7456: LD_INT 3
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 2
7465: PUSH
7466: LD_INT 30
7468: PUSH
7469: LD_INT 6
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 30
7478: PUSH
7479: LD_INT 7
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: LD_INT 30
7488: PUSH
7489: LD_INT 8
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: IFFALSE 7579
// b_labb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7512: LD_ADDR_VAR 0 11
7516: PUSH
7517: LD_INT 22
7519: PUSH
7520: LD_INT 3
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 2
7529: PUSH
7530: LD_INT 30
7532: PUSH
7533: LD_INT 6
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: LD_INT 30
7542: PUSH
7543: LD_INT 7
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: PUSH
7550: LD_INT 30
7552: PUSH
7553: LD_INT 8
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 69
7574: PUSH
7575: LD_INT 1
7577: ARRAY
7578: ST_TO_ADDR
// b_weap := AvailableWeaponList ( b_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar , 89 ] ;
7579: LD_ADDR_VAR 0 8
7583: PUSH
7584: LD_VAR 0 10
7588: PPUSH
7589: CALL_OW 478
7593: PUSH
7594: LD_INT 52
7596: PUSH
7597: LD_INT 51
7599: PUSH
7600: LD_INT 53
7602: PUSH
7603: LD_EXP 44
7607: PUSH
7608: LD_INT 89
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: LIST
7616: LIST
7617: DIFF
7618: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_workshop ] ;
7619: LD_ADDR_VAR 0 9
7623: PUSH
7624: LD_INT 0
7626: PUSH
7627: LD_INT 4
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: LIST
7637: ST_TO_ADDR
// b_ext := [ ] ;
7638: LD_ADDR_VAR 0 12
7642: PUSH
7643: EMPTY
7644: ST_TO_ADDR
// if FilterUnitsInArea ( beria_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) diff FilterAllUnits ( [ f_weapon , us_radar ] ) > 0 then
7645: LD_INT 11
7647: PPUSH
7648: LD_INT 2
7650: PUSH
7651: LD_INT 22
7653: PUSH
7654: LD_INT 1
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: LD_INT 22
7663: PUSH
7664: LD_INT 2
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 70
7680: PUSH
7681: LD_INT 34
7683: PUSH
7684: LD_INT 11
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: CALL_OW 69
7695: PUSH
7696: LD_INT 0
7698: GREATER
7699: DIFF
7700: IFFALSE 7712
// enemy_detected := true else
7702: LD_ADDR_VAR 0 13
7706: PUSH
7707: LD_INT 1
7709: ST_TO_ADDR
7710: GO 7720
// enemy_detected := false ;
7712: LD_ADDR_VAR 0 13
7716: PUSH
7717: LD_INT 0
7719: ST_TO_ADDR
// if enemy_detected = false then
7720: LD_VAR 0 13
7724: PUSH
7725: LD_INT 0
7727: EQUAL
7728: IFFALSE 7829
// for i = 1 to ru2_b do
7730: LD_ADDR_VAR 0 1
7734: PUSH
7735: DOUBLE
7736: LD_INT 1
7738: DEC
7739: ST_TO_ADDR
7740: LD_EXP 42
7744: PUSH
7745: FOR_TO
7746: IFFALSE 7827
// begin if GetBType ( ru2_b [ i ] ) in b_upgrade then
7748: LD_EXP 42
7752: PUSH
7753: LD_VAR 0 1
7757: ARRAY
7758: PPUSH
7759: CALL_OW 266
7763: PUSH
7764: LD_VAR 0 9
7768: IN
7769: IFFALSE 7786
// ComUpgrade ( ru2_b [ i ] ) ;
7771: LD_EXP 42
7775: PUSH
7776: LD_VAR 0 1
7780: ARRAY
7781: PPUSH
7782: CALL_OW 146
// if GetBType ( ru2_b [ i ] ) in b_lab then
7786: LD_EXP 42
7790: PUSH
7791: LD_VAR 0 1
7795: ARRAY
7796: PPUSH
7797: CALL_OW 266
7801: PUSH
7802: LD_INT 6
7804: IN
7805: IFFALSE 7825
// ComUpgradeLab ( ru2_b [ i ] , b_lab_weapon ) ;
7807: LD_EXP 42
7811: PUSH
7812: LD_VAR 0 1
7816: ARRAY
7817: PPUSH
7818: LD_INT 10
7820: PPUSH
7821: CALL_OW 147
// end ;
7825: GO 7745
7827: POP
7828: POP
// if ru2_sold > 0 then
7829: LD_EXP 33
7833: PUSH
7834: LD_INT 0
7836: GREATER
7837: IFFALSE 8335
// begin filter := UnitFilter ( ru2_sold , [ f_not , [ f_inside ] ] ) ;
7839: LD_ADDR_VAR 0 4
7843: PUSH
7844: LD_EXP 33
7848: PPUSH
7849: LD_INT 3
7851: PUSH
7852: LD_INT 54
7854: PUSH
7855: EMPTY
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 72
7866: ST_TO_ADDR
// if UnitFilter ( ru2_tw , [ f_empty ] ) > 0 then
7867: LD_EXP 35
7871: PPUSH
7872: LD_INT 58
7874: PUSH
7875: EMPTY
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: PUSH
7883: LD_INT 0
7885: GREATER
7886: IFFALSE 8036
// begin if filter = 0 then
7888: LD_VAR 0 4
7892: PUSH
7893: LD_INT 0
7895: EQUAL
7896: IFFALSE 7921
// ComExitBuilding ( ru2_sold [ Rand ( 1 , ru2_sold ) ] ) ;
7898: LD_EXP 33
7902: PUSH
7903: LD_INT 1
7905: PPUSH
7906: LD_EXP 33
7910: PPUSH
7911: CALL_OW 12
7915: ARRAY
7916: PPUSH
7917: CALL_OW 122
// if UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
7921: LD_VAR 0 4
7925: PPUSH
7926: LD_INT 3
7928: PUSH
7929: LD_INT 60
7931: PUSH
7932: EMPTY
7933: LIST
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PPUSH
7939: CALL_OW 72
7943: IFFALSE 8036
// for i in UnitFilter ( ru2_tw , [ f_empty ] ) do
7945: LD_ADDR_VAR 0 1
7949: PUSH
7950: LD_EXP 35
7954: PPUSH
7955: LD_INT 58
7957: PUSH
7958: EMPTY
7959: LIST
7960: PPUSH
7961: CALL_OW 72
7965: PUSH
7966: FOR_IN
7967: IFFALSE 8034
// begin ComEnterUnit ( UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) [ 1 ] , i ) ;
7969: LD_VAR 0 4
7973: PPUSH
7974: LD_INT 3
7976: PUSH
7977: LD_INT 60
7979: PUSH
7980: EMPTY
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PPUSH
7987: CALL_OW 72
7991: PUSH
7992: LD_INT 1
7994: ARRAY
7995: PPUSH
7996: LD_VAR 0 1
8000: PPUSH
8001: CALL_OW 120
// if not UnitFilter ( filter , [ f_not , [ f_hastask ] ] ) then
8005: LD_VAR 0 4
8009: PPUSH
8010: LD_INT 3
8012: PUSH
8013: LD_INT 60
8015: PUSH
8016: EMPTY
8017: LIST
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PPUSH
8023: CALL_OW 72
8027: NOT
8028: IFFALSE 8032
// break ;
8030: GO 8034
// end ;
8032: GO 7966
8034: POP
8035: POP
// end ; if UnitFilter ( ru2_tw , [ f_empty ] ) = 0 then
8036: LD_EXP 35
8040: PPUSH
8041: LD_INT 58
8043: PUSH
8044: EMPTY
8045: LIST
8046: PPUSH
8047: CALL_OW 72
8051: PUSH
8052: LD_INT 0
8054: EQUAL
8055: IFFALSE 8210
// begin b_unit := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
8057: LD_ADDR_VAR 0 7
8061: PUSH
8062: LD_INT 22
8064: PUSH
8065: LD_INT 3
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 2
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 4
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: LD_INT 30
8087: PUSH
8088: LD_INT 5
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: EMPTY
8101: LIST
8102: LIST
8103: PPUSH
8104: CALL_OW 69
8108: ST_TO_ADDR
// if b_unit > 0 then
8109: LD_VAR 0 7
8113: PUSH
8114: LD_INT 0
8116: GREATER
8117: IFFALSE 8210
// for p = 1 to b_unit do
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: DOUBLE
8125: LD_INT 1
8127: DEC
8128: ST_TO_ADDR
8129: LD_VAR 0 7
8133: PUSH
8134: FOR_TO
8135: IFFALSE 8208
// if UnitsInSide ( b_unit [ p ] ) < 6 then
8137: LD_VAR 0 7
8141: PUSH
8142: LD_VAR 0 2
8146: ARRAY
8147: PPUSH
8148: CALL_OW 313
8152: PUSH
8153: LD_INT 6
8155: LESS
8156: IFFALSE 8206
// for i = 1 to filter do
8158: LD_ADDR_VAR 0 1
8162: PUSH
8163: DOUBLE
8164: LD_INT 1
8166: DEC
8167: ST_TO_ADDR
8168: LD_VAR 0 4
8172: PUSH
8173: FOR_TO
8174: IFFALSE 8204
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
8176: LD_VAR 0 4
8180: PUSH
8181: LD_VAR 0 1
8185: ARRAY
8186: PPUSH
8187: LD_VAR 0 7
8191: PUSH
8192: LD_VAR 0 2
8196: ARRAY
8197: PPUSH
8198: CALL_OW 120
8202: GO 8173
8204: POP
8205: POP
8206: GO 8134
8208: POP
8209: POP
// end ; if UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
8210: LD_EXP 35
8214: PPUSH
8215: LD_INT 30
8217: PUSH
8218: LD_INT 32
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 35
8227: PUSH
8228: LD_INT 0
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: PPUSH
8239: CALL_OW 72
8243: PUSH
8244: LD_INT 0
8246: GREATER
8247: IFFALSE 8335
// begin filter := UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
8249: LD_ADDR_VAR 0 4
8253: PUSH
8254: LD_EXP 35
8258: PPUSH
8259: LD_INT 30
8261: PUSH
8262: LD_INT 32
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 35
8271: PUSH
8272: LD_INT 0
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 72
8287: ST_TO_ADDR
// if BuildingStatus ( b_fac ) = bs_idle then
8288: LD_VAR 0 10
8292: PPUSH
8293: CALL_OW 461
8297: PUSH
8298: LD_INT 2
8300: EQUAL
8301: IFFALSE 8335
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
8303: LD_VAR 0 4
8307: PUSH
8308: LD_INT 1
8310: ARRAY
8311: PPUSH
8312: LD_VAR 0 8
8316: PUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_VAR 0 8
8324: PPUSH
8325: CALL_OW 12
8329: ARRAY
8330: PPUSH
8331: CALL_OW 148
// end ; end ; if b_fac > 0 and ru2_mech > 0 then
8335: LD_VAR 0 10
8339: PUSH
8340: LD_INT 0
8342: GREATER
8343: PUSH
8344: LD_EXP 39
8348: PUSH
8349: LD_INT 0
8351: GREATER
8352: AND
8353: IFFALSE 8415
// for i = 1 to ru2_mech do
8355: LD_ADDR_VAR 0 1
8359: PUSH
8360: DOUBLE
8361: LD_INT 1
8363: DEC
8364: ST_TO_ADDR
8365: LD_EXP 39
8369: PUSH
8370: FOR_TO
8371: IFFALSE 8413
// if not IsInUnit ( ru2_mech [ i ] ) then
8373: LD_EXP 39
8377: PUSH
8378: LD_VAR 0 1
8382: ARRAY
8383: PPUSH
8384: CALL_OW 310
8388: NOT
8389: IFFALSE 8411
// ComEnterUnit ( ru2_mech [ i ] , b_fac ) ;
8391: LD_EXP 39
8395: PUSH
8396: LD_VAR 0 1
8400: ARRAY
8401: PPUSH
8402: LD_VAR 0 10
8406: PPUSH
8407: CALL_OW 120
8411: GO 8370
8413: POP
8414: POP
// if b_fac > 0 and ru2_veh > 0 then
8415: LD_VAR 0 10
8419: PUSH
8420: LD_INT 0
8422: GREATER
8423: PUSH
8424: LD_EXP 37
8428: PUSH
8429: LD_INT 0
8431: GREATER
8432: AND
8433: IFFALSE 8533
// if BuildingStatus ( b_fac ) = bs_idle then
8435: LD_VAR 0 10
8439: PPUSH
8440: CALL_OW 461
8444: PUSH
8445: LD_INT 2
8447: EQUAL
8448: IFFALSE 8533
// begin ComConstruct ( b_fac , ru2_veh [ 1 ] , ru2_veh [ 2 ] , ru2_veh [ 3 ] , ru2_veh [ 4 ] ) ;
8450: LD_VAR 0 10
8454: PPUSH
8455: LD_EXP 37
8459: PUSH
8460: LD_INT 1
8462: ARRAY
8463: PPUSH
8464: LD_EXP 37
8468: PUSH
8469: LD_INT 2
8471: ARRAY
8472: PPUSH
8473: LD_EXP 37
8477: PUSH
8478: LD_INT 3
8480: ARRAY
8481: PPUSH
8482: LD_EXP 37
8486: PUSH
8487: LD_INT 4
8489: ARRAY
8490: PPUSH
8491: CALL_OW 125
// for i = 1 to 4 do
8495: LD_ADDR_VAR 0 1
8499: PUSH
8500: DOUBLE
8501: LD_INT 1
8503: DEC
8504: ST_TO_ADDR
8505: LD_INT 4
8507: PUSH
8508: FOR_TO
8509: IFFALSE 8531
// ru2_veh := Delete ( ru2_veh , 1 ) ;
8511: LD_ADDR_EXP 37
8515: PUSH
8516: LD_EXP 37
8520: PPUSH
8521: LD_INT 1
8523: PPUSH
8524: CALL_OW 3
8528: ST_TO_ADDR
8529: GO 8508
8531: POP
8532: POP
// end ; if ru2_bul > 0 and enemy_detected = false then
8533: LD_EXP 41
8537: PUSH
8538: LD_INT 0
8540: GREATER
8541: PUSH
8542: LD_VAR 0 13
8546: PUSH
8547: LD_INT 0
8549: EQUAL
8550: AND
8551: IFFALSE 8654
// if ru2_eng > 0 then
8553: LD_EXP 38
8557: PUSH
8558: LD_INT 0
8560: GREATER
8561: IFFALSE 8654
// for i = 1 to ru2_eng do
8563: LD_ADDR_VAR 0 1
8567: PUSH
8568: DOUBLE
8569: LD_INT 1
8571: DEC
8572: ST_TO_ADDR
8573: LD_EXP 38
8577: PUSH
8578: FOR_TO
8579: IFFALSE 8652
// if not HasTask ( ru2_eng [ i ] ) then
8581: LD_EXP 38
8585: PUSH
8586: LD_VAR 0 1
8590: ARRAY
8591: PPUSH
8592: CALL_OW 314
8596: NOT
8597: IFFALSE 8650
// begin ComBuild ( ru2_eng [ i ] , ru2_bul [ 1 ] , ru2_bul [ 2 ] , ru2_bul [ 3 ] , ru2_bul [ 4 ] ) ;
8599: LD_EXP 38
8603: PUSH
8604: LD_VAR 0 1
8608: ARRAY
8609: PPUSH
8610: LD_EXP 41
8614: PUSH
8615: LD_INT 1
8617: ARRAY
8618: PPUSH
8619: LD_EXP 41
8623: PUSH
8624: LD_INT 2
8626: ARRAY
8627: PPUSH
8628: LD_EXP 41
8632: PUSH
8633: LD_INT 3
8635: ARRAY
8636: PPUSH
8637: LD_EXP 41
8641: PUSH
8642: LD_INT 4
8644: ARRAY
8645: PPUSH
8646: CALL_OW 145
// end ;
8650: GO 8578
8652: POP
8653: POP
// for i = 1 to ru2_b do
8654: LD_ADDR_VAR 0 1
8658: PUSH
8659: DOUBLE
8660: LD_INT 1
8662: DEC
8663: ST_TO_ADDR
8664: LD_EXP 42
8668: PUSH
8669: FOR_TO
8670: IFFALSE 8858
// if BuildingStatus ( ru2_b [ i ] ) = bs_need_extension then
8672: LD_EXP 42
8676: PUSH
8677: LD_VAR 0 1
8681: ARRAY
8682: PPUSH
8683: CALL_OW 461
8687: PUSH
8688: LD_INT 8
8690: EQUAL
8691: IFFALSE 8856
// begin b_ext := GetExtPositions ( ru2_b [ i ] ) ;
8693: LD_ADDR_VAR 0 12
8697: PUSH
8698: LD_EXP 42
8702: PUSH
8703: LD_VAR 0 1
8707: ARRAY
8708: PPUSH
8709: CALL_OW 270
8713: ST_TO_ADDR
// if b_ext > 0 and not b_ext_gun in ru2_bul then
8714: LD_VAR 0 12
8718: PUSH
8719: LD_INT 0
8721: GREATER
8722: PUSH
8723: LD_INT 17
8725: PUSH
8726: LD_EXP 41
8730: IN
8731: NOT
8732: AND
8733: IFFALSE 8856
// ru2_bul := ru2_bul ^ [ b_ext_noncombat , b_ext [ 1 ] [ 1 ] , b_ext [ 1 ] [ 2 ] , 3 , b_ext_track , b_ext [ 2 ] [ 1 ] , b_ext [ 2 ] [ 2 ] , 5 , b_ext_gun , b_ext [ 3 ] [ 1 ] , b_ext [ 3 ] [ 2 ] , 2 ] ;
8735: LD_ADDR_EXP 41
8739: PUSH
8740: LD_EXP 41
8744: PUSH
8745: LD_INT 19
8747: PUSH
8748: LD_VAR 0 12
8752: PUSH
8753: LD_INT 1
8755: ARRAY
8756: PUSH
8757: LD_INT 1
8759: ARRAY
8760: PUSH
8761: LD_VAR 0 12
8765: PUSH
8766: LD_INT 1
8768: ARRAY
8769: PUSH
8770: LD_INT 2
8772: ARRAY
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: LD_INT 16
8779: PUSH
8780: LD_VAR 0 12
8784: PUSH
8785: LD_INT 2
8787: ARRAY
8788: PUSH
8789: LD_INT 1
8791: ARRAY
8792: PUSH
8793: LD_VAR 0 12
8797: PUSH
8798: LD_INT 2
8800: ARRAY
8801: PUSH
8802: LD_INT 2
8804: ARRAY
8805: PUSH
8806: LD_INT 5
8808: PUSH
8809: LD_INT 17
8811: PUSH
8812: LD_VAR 0 12
8816: PUSH
8817: LD_INT 3
8819: ARRAY
8820: PUSH
8821: LD_INT 1
8823: ARRAY
8824: PUSH
8825: LD_VAR 0 12
8829: PUSH
8830: LD_INT 3
8832: ARRAY
8833: PUSH
8834: LD_INT 2
8836: ARRAY
8837: PUSH
8838: LD_INT 2
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: ADD
8855: ST_TO_ADDR
// end ;
8856: GO 8669
8858: POP
8859: POP
// if b_dmgunit > 0 then
8860: LD_VAR 0 6
8864: PUSH
8865: LD_INT 0
8867: GREATER
8868: IFFALSE 9053
// begin if ru2_eng > 0 then
8870: LD_EXP 38
8874: PUSH
8875: LD_INT 0
8877: GREATER
8878: IFFALSE 8958
// for i = 1 to ru2_eng do
8880: LD_ADDR_VAR 0 1
8884: PUSH
8885: DOUBLE
8886: LD_INT 1
8888: DEC
8889: ST_TO_ADDR
8890: LD_EXP 38
8894: PUSH
8895: FOR_TO
8896: IFFALSE 8956
// begin if IsInUnit ( ru2_eng [ i ] ) then
8898: LD_EXP 38
8902: PUSH
8903: LD_VAR 0 1
8907: ARRAY
8908: PPUSH
8909: CALL_OW 310
8913: IFFALSE 8930
// ComExitBuilding ( ru2_eng [ i ] ) ;
8915: LD_EXP 38
8919: PUSH
8920: LD_VAR 0 1
8924: ARRAY
8925: PPUSH
8926: CALL_OW 122
// ComRepairBuilding ( ru2_eng [ i ] , b_dmgunit [ 1 ] ) ;
8930: LD_EXP 38
8934: PUSH
8935: LD_VAR 0 1
8939: ARRAY
8940: PPUSH
8941: LD_VAR 0 6
8945: PUSH
8946: LD_INT 1
8948: ARRAY
8949: PPUSH
8950: CALL_OW 130
// end ;
8954: GO 8895
8956: POP
8957: POP
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) > 0 then
8958: LD_INT 22
8960: PUSH
8961: LD_INT 3
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: LD_INT 34
8970: PUSH
8971: LD_INT 52
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: EMPTY
8979: LIST
8980: LIST
8981: PPUSH
8982: CALL_OW 69
8986: PUSH
8987: LD_INT 0
8989: GREATER
8990: IFFALSE 9051
// for p in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) do
8992: LD_ADDR_VAR 0 2
8996: PUSH
8997: LD_INT 22
8999: PUSH
9000: LD_INT 3
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: PUSH
9007: LD_INT 34
9009: PUSH
9010: LD_INT 52
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PPUSH
9021: CALL_OW 69
9025: PUSH
9026: FOR_IN
9027: IFFALSE 9049
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
9029: LD_VAR 0 2
9033: PPUSH
9034: LD_VAR 0 6
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: CALL_OW 130
9047: GO 9026
9049: POP
9050: POP
// end else
9051: GO 9181
// if ru2_bul = 0 then
9053: LD_EXP 41
9057: PUSH
9058: LD_INT 0
9060: EQUAL
9061: IFFALSE 9181
// for i = 1 to ru2_eng do
9063: LD_ADDR_VAR 0 1
9067: PUSH
9068: DOUBLE
9069: LD_INT 1
9071: DEC
9072: ST_TO_ADDR
9073: LD_EXP 38
9077: PUSH
9078: FOR_TO
9079: IFFALSE 9179
// if not HasTask ( ru2_eng [ i ] ) then
9081: LD_EXP 38
9085: PUSH
9086: LD_VAR 0 1
9090: ARRAY
9091: PPUSH
9092: CALL_OW 314
9096: NOT
9097: IFFALSE 9177
// ComEnterUnit ( ru2_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru2_eng [ i ] ) ) ;
9099: LD_EXP 38
9103: PUSH
9104: LD_VAR 0 1
9108: ARRAY
9109: PPUSH
9110: LD_INT 22
9112: PUSH
9113: LD_INT 3
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 2
9122: PUSH
9123: LD_INT 30
9125: PUSH
9126: LD_INT 0
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 30
9135: PUSH
9136: LD_INT 1
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: LIST
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: PPUSH
9152: CALL_OW 69
9156: PPUSH
9157: LD_EXP 38
9161: PUSH
9162: LD_VAR 0 1
9166: ARRAY
9167: PPUSH
9168: CALL_OW 74
9172: PPUSH
9173: CALL_OW 120
9177: GO 9078
9179: POP
9180: POP
// if b_labb > 0 then
9181: LD_VAR 0 11
9185: PUSH
9186: LD_INT 0
9188: GREATER
9189: IFFALSE 9539
// begin if h_dmgunit > 0 then
9191: LD_VAR 0 5
9195: PUSH
9196: LD_INT 0
9198: GREATER
9199: IFFALSE 9408
// begin for p = 1 to h_dmgunit do
9201: LD_ADDR_VAR 0 2
9205: PUSH
9206: DOUBLE
9207: LD_INT 1
9209: DEC
9210: ST_TO_ADDR
9211: LD_VAR 0 5
9215: PUSH
9216: FOR_TO
9217: IFFALSE 9268
// if GetDistUnits ( h_dmgunit [ p ] , b_labb ) > 6 then
9219: LD_VAR 0 5
9223: PUSH
9224: LD_VAR 0 2
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 11
9234: PPUSH
9235: CALL_OW 296
9239: PUSH
9240: LD_INT 6
9242: GREATER
9243: IFFALSE 9266
// ComMoveXY ( h_dmgunit [ p ] , 95 , 72 ) ;
9245: LD_VAR 0 5
9249: PUSH
9250: LD_VAR 0 2
9254: ARRAY
9255: PPUSH
9256: LD_INT 95
9258: PPUSH
9259: LD_INT 72
9261: PPUSH
9262: CALL_OW 111
9266: GO 9216
9268: POP
9269: POP
// if ru2_sci > 0 then
9270: LD_EXP 40
9274: PUSH
9275: LD_INT 0
9277: GREATER
9278: IFFALSE 9408
// for i = 1 to ru2_sci do
9280: LD_ADDR_VAR 0 1
9284: PUSH
9285: DOUBLE
9286: LD_INT 1
9288: DEC
9289: ST_TO_ADDR
9290: LD_EXP 40
9294: PUSH
9295: FOR_TO
9296: IFFALSE 9406
// if IsInUnit ( ru2_sci [ i ] ) then
9298: LD_EXP 40
9302: PUSH
9303: LD_VAR 0 1
9307: ARRAY
9308: PPUSH
9309: CALL_OW 310
9313: IFFALSE 9332
// ComExitBuilding ( ru2_sci [ i ] ) else
9315: LD_EXP 40
9319: PUSH
9320: LD_VAR 0 1
9324: ARRAY
9325: PPUSH
9326: CALL_OW 122
9330: GO 9404
// if not HasTask ( ru2_sci [ i ] ) then
9332: LD_EXP 40
9336: PUSH
9337: LD_VAR 0 1
9341: ARRAY
9342: PPUSH
9343: CALL_OW 314
9347: NOT
9348: IFFALSE 9404
// if GetDistUnits ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
9350: LD_EXP 40
9354: PUSH
9355: LD_VAR 0 1
9359: ARRAY
9360: PPUSH
9361: LD_VAR 0 5
9365: PUSH
9366: LD_INT 1
9368: ARRAY
9369: PPUSH
9370: CALL_OW 296
9374: PUSH
9375: LD_INT 15
9377: LESSEQUAL
9378: IFFALSE 9404
// ComHeal ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) ;
9380: LD_EXP 40
9384: PUSH
9385: LD_VAR 0 1
9389: ARRAY
9390: PPUSH
9391: LD_VAR 0 5
9395: PUSH
9396: LD_INT 1
9398: ARRAY
9399: PPUSH
9400: CALL_OW 128
9404: GO 9295
9406: POP
9407: POP
// end ; if h_dmgunit = 0 then
9408: LD_VAR 0 5
9412: PUSH
9413: LD_INT 0
9415: EQUAL
9416: IFFALSE 9539
// begin for i = 1 to ru2_sci do
9418: LD_ADDR_VAR 0 1
9422: PUSH
9423: DOUBLE
9424: LD_INT 1
9426: DEC
9427: ST_TO_ADDR
9428: LD_EXP 40
9432: PUSH
9433: FOR_TO
9434: IFFALSE 9476
// if not IsInUnit ( ru2_sci [ i ] ) then
9436: LD_EXP 40
9440: PUSH
9441: LD_VAR 0 1
9445: ARRAY
9446: PPUSH
9447: CALL_OW 310
9451: NOT
9452: IFFALSE 9474
// ComEnterUnit ( ru2_sci [ i ] , b_labb ) ;
9454: LD_EXP 40
9458: PUSH
9459: LD_VAR 0 1
9463: ARRAY
9464: PPUSH
9465: LD_VAR 0 11
9469: PPUSH
9470: CALL_OW 120
9474: GO 9433
9476: POP
9477: POP
// if ru2_tech > 0 then
9478: LD_EXP 36
9482: PUSH
9483: LD_INT 0
9485: GREATER
9486: IFFALSE 9539
// if BuildingStatus ( b_labb ) = bs_idle then
9488: LD_VAR 0 11
9492: PPUSH
9493: CALL_OW 461
9497: PUSH
9498: LD_INT 2
9500: EQUAL
9501: IFFALSE 9539
// begin ComResearch ( b_labb , ru2_tech [ 1 ] ) ;
9503: LD_VAR 0 11
9507: PPUSH
9508: LD_EXP 36
9512: PUSH
9513: LD_INT 1
9515: ARRAY
9516: PPUSH
9517: CALL_OW 124
// ru2_tech := Delete ( ru2_tech , 1 ) ;
9521: LD_ADDR_EXP 36
9525: PUSH
9526: LD_EXP 36
9530: PPUSH
9531: LD_INT 1
9533: PPUSH
9534: CALL_OW 3
9538: ST_TO_ADDR
// end ; end ; end ; end ;
9539: PPOPN 13
9541: END
// every 0 0$01 trigger russian_produce do
9542: LD_EXP 20
9546: IFFALSE 9995
9548: GO 9550
9550: DISABLE
// begin case global_diff of 1 :
9551: LD_EXP 3
9555: PUSH
9556: LD_INT 1
9558: DOUBLE
9559: EQUAL
9560: IFTRUE 9564
9562: GO 9628
9564: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9565: LD_ADDR_EXP 27
9569: PUSH
9570: LD_EXP 27
9574: PUSH
9575: LD_INT 21
9577: PUSH
9578: LD_INT 1
9580: PUSH
9581: LD_INT 1
9583: PUSH
9584: LD_INT 42
9586: PUSH
9587: LD_INT 21
9589: PUSH
9590: LD_INT 1
9592: PUSH
9593: LD_INT 1
9595: PUSH
9596: LD_INT 42
9598: PUSH
9599: LD_INT 21
9601: PUSH
9602: LD_INT 1
9604: PUSH
9605: LD_INT 1
9607: PUSH
9608: LD_INT 43
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: ADD
9625: ST_TO_ADDR
9626: GO 9773
9628: LD_INT 2
9630: DOUBLE
9631: EQUAL
9632: IFTRUE 9636
9634: GO 9700
9636: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9637: LD_ADDR_EXP 27
9641: PUSH
9642: LD_EXP 27
9646: PUSH
9647: LD_INT 21
9649: PUSH
9650: LD_INT 1
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: LD_INT 44
9658: PUSH
9659: LD_INT 22
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 1
9667: PUSH
9668: LD_INT 42
9670: PUSH
9671: LD_INT 22
9673: PUSH
9674: LD_INT 1
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: LD_INT 43
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: ADD
9697: ST_TO_ADDR
9698: GO 9773
9700: LD_INT 3
9702: DOUBLE
9703: EQUAL
9704: IFTRUE 9708
9706: GO 9772
9708: POP
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_rocket_launcher ] ; end ;
9709: LD_ADDR_EXP 27
9713: PUSH
9714: LD_EXP 27
9718: PUSH
9719: LD_INT 23
9721: PUSH
9722: LD_INT 1
9724: PUSH
9725: LD_INT 1
9727: PUSH
9728: LD_INT 43
9730: PUSH
9731: LD_INT 22
9733: PUSH
9734: LD_INT 1
9736: PUSH
9737: LD_INT 1
9739: PUSH
9740: LD_INT 44
9742: PUSH
9743: LD_INT 22
9745: PUSH
9746: LD_INT 1
9748: PUSH
9749: LD_INT 1
9751: PUSH
9752: LD_INT 45
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: LIST
9764: LIST
9765: LIST
9766: LIST
9767: LIST
9768: ADD
9769: ST_TO_ADDR
9770: GO 9773
9772: POP
// case global_diff of 1 :
9773: LD_EXP 3
9777: PUSH
9778: LD_INT 1
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9850
9786: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
9787: LD_ADDR_EXP 37
9791: PUSH
9792: LD_EXP 37
9796: PUSH
9797: LD_INT 21
9799: PUSH
9800: LD_INT 1
9802: PUSH
9803: LD_INT 1
9805: PUSH
9806: LD_INT 42
9808: PUSH
9809: LD_INT 21
9811: PUSH
9812: LD_INT 1
9814: PUSH
9815: LD_INT 1
9817: PUSH
9818: LD_INT 42
9820: PUSH
9821: LD_INT 21
9823: PUSH
9824: LD_INT 1
9826: PUSH
9827: LD_INT 1
9829: PUSH
9830: LD_INT 43
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: ADD
9847: ST_TO_ADDR
9848: GO 9995
9850: LD_INT 2
9852: DOUBLE
9853: EQUAL
9854: IFTRUE 9858
9856: GO 9922
9858: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
9859: LD_ADDR_EXP 37
9863: PUSH
9864: LD_EXP 37
9868: PUSH
9869: LD_INT 21
9871: PUSH
9872: LD_INT 1
9874: PUSH
9875: LD_INT 1
9877: PUSH
9878: LD_INT 44
9880: PUSH
9881: LD_INT 22
9883: PUSH
9884: LD_INT 1
9886: PUSH
9887: LD_INT 1
9889: PUSH
9890: LD_INT 44
9892: PUSH
9893: LD_INT 22
9895: PUSH
9896: LD_INT 1
9898: PUSH
9899: LD_INT 1
9901: PUSH
9902: LD_INT 43
9904: PUSH
9905: EMPTY
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: ADD
9919: ST_TO_ADDR
9920: GO 9995
9922: LD_INT 3
9924: DOUBLE
9925: EQUAL
9926: IFTRUE 9930
9928: GO 9994
9930: POP
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
9931: LD_ADDR_EXP 37
9935: PUSH
9936: LD_EXP 37
9940: PUSH
9941: LD_INT 23
9943: PUSH
9944: LD_INT 1
9946: PUSH
9947: LD_INT 1
9949: PUSH
9950: LD_INT 42
9952: PUSH
9953: LD_INT 22
9955: PUSH
9956: LD_INT 1
9958: PUSH
9959: LD_INT 1
9961: PUSH
9962: LD_INT 44
9964: PUSH
9965: LD_INT 22
9967: PUSH
9968: LD_INT 1
9970: PUSH
9971: LD_INT 1
9973: PUSH
9974: LD_INT 44
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: LIST
9981: LIST
9982: LIST
9983: LIST
9984: LIST
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: ADD
9991: ST_TO_ADDR
9992: GO 9995
9994: POP
// end ;
9995: END
// every 12 12$00 trigger timer >= [ 26 26$00 , 21 21$00 , 16 16$00 ] [ global_diff ] and FilterAllUnits ( [ f_side , 3 ] ) > 0 do var veh , i , p , area ;
9996: LD_EXP 2
10000: PUSH
10001: LD_INT 54600
10003: PUSH
10004: LD_INT 44100
10006: PUSH
10007: LD_INT 33600
10009: PUSH
10010: EMPTY
10011: LIST
10012: LIST
10013: LIST
10014: PUSH
10015: LD_EXP 3
10019: ARRAY
10020: GREATEREQUAL
10021: PUSH
10022: LD_INT 22
10024: PUSH
10025: LD_INT 3
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PPUSH
10032: CALL_OW 69
10036: PUSH
10037: LD_INT 0
10039: GREATER
10040: AND
10041: IFFALSE 10257
10043: GO 10045
10045: DISABLE
10046: LD_INT 0
10048: PPUSH
10049: PPUSH
10050: PPUSH
10051: PPUSH
// begin enable ;
10052: ENABLE
// uc_side := [ 3 , 6 ] [ Rand ( 1 , 2 ) ] ;
10053: LD_ADDR_OWVAR 20
10057: PUSH
10058: LD_INT 3
10060: PUSH
10061: LD_INT 6
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: LD_INT 1
10070: PPUSH
10071: LD_INT 2
10073: PPUSH
10074: CALL_OW 12
10078: ARRAY
10079: ST_TO_ADDR
// uc_nation := 3 ;
10080: LD_ADDR_OWVAR 21
10084: PUSH
10085: LD_INT 3
10087: ST_TO_ADDR
// area := [ ru_west , south_spawn ] ;
10088: LD_ADDR_VAR 0 4
10092: PUSH
10093: LD_INT 18
10095: PUSH
10096: LD_INT 7
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
10103: LD_ADDR_VAR 0 3
10107: PUSH
10108: LD_INT 1
10110: PPUSH
10111: LD_INT 2
10113: PPUSH
10114: CALL_OW 12
10118: ST_TO_ADDR
// for i = 1 to Rand ( 1 , 2 ) do
10119: LD_ADDR_VAR 0 2
10123: PUSH
10124: DOUBLE
10125: LD_INT 1
10127: DEC
10128: ST_TO_ADDR
10129: LD_INT 1
10131: PPUSH
10132: LD_INT 2
10134: PPUSH
10135: CALL_OW 12
10139: PUSH
10140: FOR_TO
10141: IFFALSE 10255
// begin vc_chassis := ru_medium_tracked ;
10143: LD_ADDR_OWVAR 37
10147: PUSH
10148: LD_INT 22
10150: ST_TO_ADDR
// vc_engine := engine_combustion ;
10151: LD_ADDR_OWVAR 39
10155: PUSH
10156: LD_INT 1
10158: ST_TO_ADDR
// vc_control := control_manual ;
10159: LD_ADDR_OWVAR 38
10163: PUSH
10164: LD_INT 1
10166: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
10167: LD_ADDR_OWVAR 40
10171: PUSH
10172: LD_INT 43
10174: PUSH
10175: LD_INT 44
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_INT 1
10188: PPUSH
10189: LD_INT 3
10191: PPUSH
10192: CALL_OW 12
10196: ARRAY
10197: ST_TO_ADDR
// veh := CreateVehicle ;
10198: LD_ADDR_VAR 0 1
10202: PUSH
10203: CALL_OW 45
10207: ST_TO_ADDR
// PlaceUnitArea ( veh , area [ p ] , false ) ;
10208: LD_VAR 0 1
10212: PPUSH
10213: LD_VAR 0 4
10217: PUSH
10218: LD_VAR 0 3
10222: ARRAY
10223: PPUSH
10224: LD_INT 0
10226: PPUSH
10227: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_def ) , veh ) ;
10231: LD_INT 3
10233: PPUSH
10234: LD_EXP 5
10238: PPUSH
10239: CALL 418 0 2
10243: PPUSH
10244: LD_VAR 0 1
10248: PPUSH
10249: CALL_OW 52
// end ;
10253: GO 10140
10255: POP
10256: POP
// end ;
10257: PPOPN 4
10259: END
// every 4 4$35 trigger FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) >= 6 do var filter , enemy , i , _list ;
10260: LD_INT 2
10262: PUSH
10263: LD_INT 22
10265: PUSH
10266: LD_INT 3
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: PUSH
10273: LD_INT 22
10275: PUSH
10276: LD_INT 6
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 21
10290: PUSH
10291: LD_INT 2
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: PUSH
10298: LD_INT 3
10300: PUSH
10301: LD_INT 2
10303: PUSH
10304: LD_INT 34
10306: PUSH
10307: LD_INT 52
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: LD_INT 34
10316: PUSH
10317: LD_INT 51
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 34
10326: PUSH
10327: LD_INT 53
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: PPUSH
10349: CALL_OW 69
10353: PUSH
10354: LD_INT 6
10356: GREATEREQUAL
10357: IFFALSE 10597
10359: GO 10361
10361: DISABLE
10362: LD_INT 0
10364: PPUSH
10365: PPUSH
10366: PPUSH
10367: PPUSH
// begin enable ;
10368: ENABLE
// _list := [ [ b_oil_mine , b_solar_power , b_oil_power ] , [ us_cargo_bay ] , [ ] ] ;
10369: LD_ADDR_VAR 0 4
10373: PUSH
10374: LD_INT 29
10376: PUSH
10377: LD_INT 27
10379: PUSH
10380: LD_INT 26
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: LIST
10387: PUSH
10388: LD_INT 12
10390: PUSH
10391: EMPTY
10392: LIST
10393: PUSH
10394: EMPTY
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: LIST
10400: ST_TO_ADDR
// filter := ru_list_attackers ;
10401: LD_ADDR_VAR 0 1
10405: PUSH
10406: LD_EXP 43
10410: ST_TO_ADDR
// while ( filter ) do
10411: LD_VAR 0 1
10415: IFFALSE 10597
// begin Wait ( 0 0$01 ) ;
10417: LD_INT 35
10419: PPUSH
10420: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10424: LD_INT 22
10426: PUSH
10427: LD_INT 2
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 69
10438: PUSH
10439: LD_INT 0
10441: EQUAL
10442: IFFALSE 10484
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10444: LD_ADDR_VAR 0 2
10448: PUSH
10449: LD_INT 2
10451: PUSH
10452: LD_INT 22
10454: PUSH
10455: LD_INT 1
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 22
10464: PUSH
10465: LD_INT 4
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: LIST
10476: PPUSH
10477: CALL_OW 69
10481: ST_TO_ADDR
10482: GO 10504
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10484: LD_ADDR_VAR 0 2
10488: PUSH
10489: LD_INT 22
10491: PUSH
10492: LD_INT 2
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PPUSH
10499: CALL_OW 69
10503: ST_TO_ADDR
// for i = filter downto 1 do
10504: LD_ADDR_VAR 0 3
10508: PUSH
10509: DOUBLE
10510: LD_VAR 0 1
10514: INC
10515: ST_TO_ADDR
10516: LD_INT 1
10518: PUSH
10519: FOR_DOWNTO
10520: IFFALSE 10584
// if not IsPlaced ( filter [ i ] ) then
10522: LD_VAR 0 1
10526: PUSH
10527: LD_VAR 0 3
10531: ARRAY
10532: PPUSH
10533: CALL_OW 305
10537: NOT
10538: IFFALSE 10562
// filter := Delete ( filter , i ) else
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_VAR 0 1
10549: PPUSH
10550: LD_VAR 0 3
10554: PPUSH
10555: CALL_OW 3
10559: ST_TO_ADDR
10560: GO 10582
// ComAttack ( filter [ i ] , _list ) ;
10562: LD_VAR 0 1
10566: PUSH
10567: LD_VAR 0 3
10571: ARRAY
10572: PPUSH
10573: LD_VAR 0 4
10577: PPUSH
10578: CALL 985 0 2
10582: GO 10519
10584: POP
10585: POP
// if not filter then
10586: LD_VAR 0 1
10590: NOT
10591: IFFALSE 10595
// break ;
10593: GO 10597
// end ;
10595: GO 10411
// end ;
10597: PPOPN 4
10599: END
// export ru_spec_group ; every 0 0$10 trigger FilterUnitsInArea ( buffor , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 do var i , un , veh ;
10600: LD_INT 22
10602: PPUSH
10603: LD_INT 22
10605: PUSH
10606: LD_INT 1
10608: PUSH
10609: EMPTY
10610: LIST
10611: LIST
10612: PUSH
10613: LD_INT 21
10615: PUSH
10616: LD_INT 3
10618: PUSH
10619: EMPTY
10620: LIST
10621: LIST
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PPUSH
10627: CALL_OW 70
10631: PUSH
10632: LD_INT 0
10634: GREATER
10635: IFFALSE 10780
10637: GO 10639
10639: DISABLE
10640: LD_INT 0
10642: PPUSH
10643: PPUSH
10644: PPUSH
// begin uc_side := 6 ;
10645: LD_ADDR_OWVAR 20
10649: PUSH
10650: LD_INT 6
10652: ST_TO_ADDR
// uc_nation := 3 ;
10653: LD_ADDR_OWVAR 21
10657: PUSH
10658: LD_INT 3
10660: ST_TO_ADDR
// for i = 1 to Difficulty + 1 do
10661: LD_ADDR_VAR 0 1
10665: PUSH
10666: DOUBLE
10667: LD_INT 1
10669: DEC
10670: ST_TO_ADDR
10671: LD_OWVAR 67
10675: PUSH
10676: LD_INT 1
10678: PLUS
10679: PUSH
10680: FOR_TO
10681: IFFALSE 10775
// begin vc_chassis := ru_medium_tracked ;
10683: LD_ADDR_OWVAR 37
10687: PUSH
10688: LD_INT 22
10690: ST_TO_ADDR
// vc_engine := engine_combustion ;
10691: LD_ADDR_OWVAR 39
10695: PUSH
10696: LD_INT 1
10698: ST_TO_ADDR
// vc_control := control_manual ;
10699: LD_ADDR_OWVAR 38
10703: PUSH
10704: LD_INT 1
10706: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10707: LD_ADDR_OWVAR 40
10711: PUSH
10712: LD_INT 45
10714: ST_TO_ADDR
// veh := CreateVehicle ;
10715: LD_ADDR_VAR 0 3
10719: PUSH
10720: CALL_OW 45
10724: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
10725: LD_ADDR_VAR 0 2
10729: PUSH
10730: LD_INT 3
10732: PPUSH
10733: LD_EXP 5
10737: PPUSH
10738: CALL 418 0 2
10742: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10743: LD_VAR 0 2
10747: PPUSH
10748: LD_VAR 0 3
10752: PPUSH
10753: CALL_OW 52
// ru_spec_group := ru_spec_group ^ veh ;
10757: LD_ADDR_EXP 45
10761: PUSH
10762: LD_EXP 45
10766: PUSH
10767: LD_VAR 0 3
10771: ADD
10772: ST_TO_ADDR
// end ;
10773: GO 10680
10775: POP
10776: POP
// enable ( 99 ) ;
10777: LD_INT 99
10779: ENABLE_MARKED
// end ;
10780: PPOPN 3
10782: END
// every 0 0$01 trigger ru_spec_group marked 99 do var i , enemy , filter ;
10783: LD_EXP 45
10787: IFFALSE 10956
10789: GO 10791
10791: DISABLE
10792: LD_INT 0
10794: PPUSH
10795: PPUSH
10796: PPUSH
// begin enable ;
10797: ENABLE
// filter := ru_spec_group ;
10798: LD_ADDR_VAR 0 3
10802: PUSH
10803: LD_EXP 45
10807: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
10808: LD_INT 22
10810: PUSH
10811: LD_INT 2
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PUSH
10823: LD_INT 0
10825: EQUAL
10826: IFFALSE 10868
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] ) else
10828: LD_ADDR_VAR 0 2
10832: PUSH
10833: LD_INT 2
10835: PUSH
10836: LD_INT 22
10838: PUSH
10839: LD_INT 1
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 22
10848: PUSH
10849: LD_INT 4
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: PPUSH
10861: CALL_OW 69
10865: ST_TO_ADDR
10866: GO 10888
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
10868: LD_ADDR_VAR 0 2
10872: PUSH
10873: LD_INT 22
10875: PUSH
10876: LD_INT 2
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PPUSH
10883: CALL_OW 69
10887: ST_TO_ADDR
// if filter > 0 then
10888: LD_VAR 0 3
10892: PUSH
10893: LD_INT 0
10895: GREATER
10896: IFFALSE 10956
// for i = 1 to filter do
10898: LD_ADDR_VAR 0 1
10902: PUSH
10903: DOUBLE
10904: LD_INT 1
10906: DEC
10907: ST_TO_ADDR
10908: LD_VAR 0 3
10912: PUSH
10913: FOR_TO
10914: IFFALSE 10954
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
10916: LD_VAR 0 3
10920: PUSH
10921: LD_VAR 0 1
10925: ARRAY
10926: PPUSH
10927: LD_VAR 0 2
10931: PPUSH
10932: LD_VAR 0 3
10936: PUSH
10937: LD_VAR 0 1
10941: ARRAY
10942: PPUSH
10943: CALL_OW 74
10947: PPUSH
10948: CALL_OW 115
10952: GO 10913
10954: POP
10955: POP
// end ; end_of_file
10956: PPOPN 3
10958: END
// export function ArabianAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
10959: LD_INT 0
10961: PPUSH
10962: PPUSH
10963: PPUSH
10964: PPUSH
10965: PPUSH
10966: PPUSH
10967: PPUSH
// uc_side := side ;
10968: LD_ADDR_OWVAR 20
10972: PUSH
10973: LD_VAR 0 1
10977: ST_TO_ADDR
// uc_nation := nation_arabian ;
10978: LD_ADDR_OWVAR 21
10982: PUSH
10983: LD_INT 2
10985: ST_TO_ADDR
// chassis := [ ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
10986: LD_ADDR_VAR 0 10
10990: PUSH
10991: LD_INT 12
10993: PUSH
10994: LD_INT 13
10996: PUSH
10997: LD_INT 14
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: ST_TO_ADDR
// weapon := [ ar_multimissile_ballista , ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher ] ;
11005: LD_ADDR_VAR 0 11
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 24
11015: PUSH
11016: LD_INT 25
11018: PUSH
11019: LD_INT 27
11021: PUSH
11022: LD_INT 28
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: ST_TO_ADDR
// case typ of 1 :
11032: LD_VAR 0 3
11036: PUSH
11037: LD_INT 1
11039: DOUBLE
11040: EQUAL
11041: IFTRUE 11045
11043: GO 11270
11045: POP
// begin for i = 1 to num do
11046: LD_ADDR_VAR 0 6
11050: PUSH
11051: DOUBLE
11052: LD_INT 1
11054: DEC
11055: ST_TO_ADDR
11056: LD_VAR 0 2
11060: PUSH
11061: FOR_TO
11062: IFFALSE 11221
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
11064: LD_ADDR_OWVAR 37
11068: PUSH
11069: LD_VAR 0 10
11073: PUSH
11074: LD_INT 1
11076: PPUSH
11077: LD_INT 2
11079: PPUSH
11080: CALL_OW 12
11084: ARRAY
11085: ST_TO_ADDR
// vc_engine := engine_combustion ;
11086: LD_ADDR_OWVAR 39
11090: PUSH
11091: LD_INT 1
11093: ST_TO_ADDR
// vc_control := control_manual ;
11094: LD_ADDR_OWVAR 38
11098: PUSH
11099: LD_INT 1
11101: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 2 ) ] ;
11102: LD_ADDR_OWVAR 40
11106: PUSH
11107: LD_VAR 0 11
11111: PUSH
11112: LD_INT 1
11114: PPUSH
11115: LD_INT 2
11117: PPUSH
11118: CALL_OW 12
11122: ARRAY
11123: ST_TO_ADDR
// veh := CreateVehicle ;
11124: LD_ADDR_VAR 0 9
11128: PUSH
11129: CALL_OW 45
11133: ST_TO_ADDR
// if area = ar_area1 then
11134: LD_VAR 0 4
11138: PUSH
11139: LD_INT 6
11141: EQUAL
11142: IFFALSE 11158
// SetDir ( veh , 3 ) else
11144: LD_VAR 0 9
11148: PPUSH
11149: LD_INT 3
11151: PPUSH
11152: CALL_OW 233
11156: GO 11170
// SetDir ( veh , 0 ) ;
11158: LD_VAR 0 9
11162: PPUSH
11163: LD_INT 0
11165: PPUSH
11166: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11170: LD_VAR 0 9
11174: PPUSH
11175: LD_VAR 0 4
11179: PPUSH
11180: LD_INT 0
11182: PPUSH
11183: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11187: LD_ADDR_VAR 0 7
11191: PUSH
11192: LD_INT 1
11194: PPUSH
11195: LD_EXP 8
11199: PPUSH
11200: CALL 418 0 2
11204: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11205: LD_VAR 0 7
11209: PPUSH
11210: LD_VAR 0 9
11214: PPUSH
11215: CALL_OW 52
// end ;
11219: GO 11061
11221: POP
11222: POP
// for i = 1 to 3 do
11223: LD_ADDR_VAR 0 6
11227: PUSH
11228: DOUBLE
11229: LD_INT 1
11231: DEC
11232: ST_TO_ADDR
11233: LD_INT 3
11235: PUSH
11236: FOR_TO
11237: IFFALSE 11266
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , ar_def ) , area , false ) ;
11239: LD_INT 8
11241: PPUSH
11242: LD_EXP 8
11246: PPUSH
11247: CALL 418 0 2
11251: PPUSH
11252: LD_VAR 0 4
11256: PPUSH
11257: LD_INT 0
11259: PPUSH
11260: CALL_OW 49
11264: GO 11236
11266: POP
11267: POP
// end ; 2 :
11268: GO 11537
11270: LD_INT 2
11272: DOUBLE
11273: EQUAL
11274: IFTRUE 11278
11276: GO 11536
11278: POP
// begin for i = 1 to num do
11279: LD_ADDR_VAR 0 6
11283: PUSH
11284: DOUBLE
11285: LD_INT 1
11287: DEC
11288: ST_TO_ADDR
11289: LD_VAR 0 2
11293: PUSH
11294: FOR_TO
11295: IFFALSE 11454
// begin vc_chassis := chassis [ Rand ( 2 , 3 ) ] ;
11297: LD_ADDR_OWVAR 37
11301: PUSH
11302: LD_VAR 0 10
11306: PUSH
11307: LD_INT 2
11309: PPUSH
11310: LD_INT 3
11312: PPUSH
11313: CALL_OW 12
11317: ARRAY
11318: ST_TO_ADDR
// vc_engine := engine_combustion ;
11319: LD_ADDR_OWVAR 39
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// vc_control := control_manual ;
11327: LD_ADDR_OWVAR 38
11331: PUSH
11332: LD_INT 1
11334: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
11335: LD_ADDR_OWVAR 40
11339: PUSH
11340: LD_VAR 0 11
11344: PUSH
11345: LD_INT 3
11347: PPUSH
11348: LD_INT 5
11350: PPUSH
11351: CALL_OW 12
11355: ARRAY
11356: ST_TO_ADDR
// veh := CreateVehicle ;
11357: LD_ADDR_VAR 0 9
11361: PUSH
11362: CALL_OW 45
11366: ST_TO_ADDR
// if area = ar_area1 then
11367: LD_VAR 0 4
11371: PUSH
11372: LD_INT 6
11374: EQUAL
11375: IFFALSE 11391
// SetDir ( veh , 3 ) else
11377: LD_VAR 0 9
11381: PPUSH
11382: LD_INT 3
11384: PPUSH
11385: CALL_OW 233
11389: GO 11403
// SetDir ( veh , 0 ) ;
11391: LD_VAR 0 9
11395: PPUSH
11396: LD_INT 0
11398: PPUSH
11399: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
11403: LD_VAR 0 9
11407: PPUSH
11408: LD_VAR 0 4
11412: PPUSH
11413: LD_INT 0
11415: PPUSH
11416: CALL_OW 49
// un := CreateHumanWithClass ( 1 , ar_def ) ;
11420: LD_ADDR_VAR 0 7
11424: PUSH
11425: LD_INT 1
11427: PPUSH
11428: LD_EXP 8
11432: PPUSH
11433: CALL 418 0 2
11437: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11438: LD_VAR 0 7
11442: PPUSH
11443: LD_VAR 0 9
11447: PPUSH
11448: CALL_OW 52
// end ;
11452: GO 11294
11454: POP
11455: POP
// for i = 1 to 2 do
11456: LD_ADDR_VAR 0 6
11460: PUSH
11461: DOUBLE
11462: LD_INT 1
11464: DEC
11465: ST_TO_ADDR
11466: LD_INT 2
11468: PUSH
11469: FOR_TO
11470: IFFALSE 11532
// begin uc_nation := 0 ;
11472: LD_ADDR_OWVAR 21
11476: PUSH
11477: LD_INT 0
11479: ST_TO_ADDR
// hc_class := 17 ;
11480: LD_ADDR_OWVAR 28
11484: PUSH
11485: LD_INT 17
11487: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
11488: LD_ADDR_OWVAR 29
11492: PUSH
11493: LD_INT 11
11495: PUSH
11496: LD_INT 13
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: ST_TO_ADDR
// un := CreateHuman ;
11503: LD_ADDR_VAR 0 7
11507: PUSH
11508: CALL_OW 44
11512: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
11513: LD_VAR 0 7
11517: PPUSH
11518: LD_VAR 0 4
11522: PPUSH
11523: LD_INT 0
11525: PPUSH
11526: CALL_OW 49
// end ;
11530: GO 11469
11532: POP
11533: POP
// end ; end ;
11534: GO 11537
11536: POP
// end ;
11537: LD_VAR 0 5
11541: RET
// export function FHeike ; begin
11542: LD_INT 0
11544: PPUSH
// uc_side := 2 ;
11545: LD_ADDR_OWVAR 20
11549: PUSH
11550: LD_INT 2
11552: ST_TO_ADDR
// uc_nation := 2 ;
11553: LD_ADDR_OWVAR 21
11557: PUSH
11558: LD_INT 2
11560: ST_TO_ADDR
// hc_gallery := sandar ;
11561: LD_ADDR_OWVAR 33
11565: PUSH
11566: LD_STRING sandar
11568: ST_TO_ADDR
// hc_face_number := 14 ;
11569: LD_ADDR_OWVAR 34
11573: PUSH
11574: LD_INT 14
11576: ST_TO_ADDR
// hc_name := Heike Steyer ;
11577: LD_ADDR_OWVAR 26
11581: PUSH
11582: LD_STRING Heike Steyer
11584: ST_TO_ADDR
// hc_sex := sex_female ;
11585: LD_ADDR_OWVAR 27
11589: PUSH
11590: LD_INT 2
11592: ST_TO_ADDR
// hc_class := 1 ;
11593: LD_ADDR_OWVAR 28
11597: PUSH
11598: LD_INT 1
11600: ST_TO_ADDR
// heike := CreateHuman ;
11601: LD_ADDR_EXP 16
11605: PUSH
11606: CALL_OW 44
11610: ST_TO_ADDR
// end ;
11611: LD_VAR 0 1
11615: RET
// every 0 0$01 do var filter , enemy , i ;
11616: GO 11618
11618: DISABLE
11619: LD_INT 0
11621: PPUSH
11622: PPUSH
11623: PPUSH
// begin enable ;
11624: ENABLE
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
11625: LD_ADDR_VAR 0 1
11629: PUSH
11630: LD_INT 22
11632: PUSH
11633: LD_INT 2
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PPUSH
11640: CALL_OW 69
11644: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
11645: LD_ADDR_VAR 0 2
11649: PUSH
11650: LD_INT 2
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 1
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 22
11665: PUSH
11666: LD_INT 3
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: LD_INT 22
11675: PUSH
11676: LD_INT 6
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: ST_TO_ADDR
// if filter > 0 then
11694: LD_VAR 0 1
11698: PUSH
11699: LD_INT 0
11701: GREATER
11702: IFFALSE 11762
// for i = 1 to filter do
11704: LD_ADDR_VAR 0 3
11708: PUSH
11709: DOUBLE
11710: LD_INT 1
11712: DEC
11713: ST_TO_ADDR
11714: LD_VAR 0 1
11718: PUSH
11719: FOR_TO
11720: IFFALSE 11760
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
11722: LD_VAR 0 1
11726: PUSH
11727: LD_VAR 0 3
11731: ARRAY
11732: PPUSH
11733: LD_VAR 0 2
11737: PPUSH
11738: LD_VAR 0 1
11742: PUSH
11743: LD_VAR 0 3
11747: ARRAY
11748: PPUSH
11749: CALL_OW 74
11753: PPUSH
11754: CALL_OW 115
11758: GO 11719
11760: POP
11761: POP
// end ; end_of_file
11762: PPOPN 3
11764: END
// on UnitDestroyed ( un ) do begin if un = sikorski then
11765: LD_VAR 0 1
11769: PUSH
11770: LD_EXP 14
11774: EQUAL
11775: IFFALSE 11784
// YouLost ( sik ) ;
11777: LD_STRING sik
11779: PPUSH
11780: CALL_OW 104
// if un = omikron then
11784: LD_VAR 0 1
11788: PUSH
11789: LD_INT 64
11791: EQUAL
11792: IFFALSE 11801
// YouLost ( omi ) ;
11794: LD_STRING omi
11796: PPUSH
11797: CALL_OW 104
// if un in ru_list_attackers then
11801: LD_VAR 0 1
11805: PUSH
11806: LD_EXP 43
11810: IN
11811: IFFALSE 11829
// ru_list_attackers := ru_list_attackers diff un ;
11813: LD_ADDR_EXP 43
11817: PUSH
11818: LD_EXP 43
11822: PUSH
11823: LD_VAR 0 1
11827: DIFF
11828: ST_TO_ADDR
// if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
11829: LD_VAR 0 1
11833: PPUSH
11834: CALL_OW 255
11838: PUSH
11839: LD_INT 6
11841: EQUAL
11842: PUSH
11843: LD_VAR 0 1
11847: PUSH
11848: LD_INT 21
11850: PUSH
11851: LD_INT 3
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: PPUSH
11858: CALL_OW 69
11862: IN
11863: AND
11864: IFFALSE 12083
// begin if GetBType ( un ) = b_factory then
11866: LD_VAR 0 1
11870: PPUSH
11871: CALL_OW 266
11875: PUSH
11876: LD_INT 3
11878: EQUAL
11879: IFFALSE 11895
// ru_bul := ru_bul ^ b_workshop ;
11881: LD_ADDR_EXP 31
11885: PUSH
11886: LD_EXP 31
11890: PUSH
11891: LD_INT 2
11893: ADD
11894: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
11895: LD_VAR 0 1
11899: PPUSH
11900: CALL_OW 266
11904: PUSH
11905: LD_INT 8
11907: EQUAL
11908: PUSH
11909: LD_VAR 0 1
11913: PPUSH
11914: CALL_OW 266
11918: PUSH
11919: LD_INT 7
11921: EQUAL
11922: OR
11923: IFFALSE 11939
// ru_bul := ru_bul ^ b_lab ;
11925: LD_ADDR_EXP 31
11929: PUSH
11930: LD_EXP 31
11934: PUSH
11935: LD_INT 6
11937: ADD
11938: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11939: LD_VAR 0 1
11943: PPUSH
11944: CALL_OW 266
11948: PUSH
11949: LD_INT 5
11951: EQUAL
11952: IFFALSE 11968
// ru_bul := ru_bul ^ b_armoury ;
11954: LD_ADDR_EXP 31
11958: PUSH
11959: LD_EXP 31
11963: PUSH
11964: LD_INT 4
11966: ADD
11967: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks ] then
11968: LD_VAR 0 1
11972: PPUSH
11973: CALL_OW 266
11977: PUSH
11978: LD_INT 3
11980: PUSH
11981: LD_INT 8
11983: PUSH
11984: LD_INT 7
11986: PUSH
11987: LD_INT 5
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: LIST
11994: LIST
11995: IN
11996: NOT
11997: IFFALSE 12020
// ru_bul := ru_bul ^ GetBType ( un ) ;
11999: LD_ADDR_EXP 31
12003: PUSH
12004: LD_EXP 31
12008: PUSH
12009: LD_VAR 0 1
12013: PPUSH
12014: CALL_OW 266
12018: ADD
12019: ST_TO_ADDR
// ru_bul := ru_bul ^ GetX ( un ) ;
12020: LD_ADDR_EXP 31
12024: PUSH
12025: LD_EXP 31
12029: PUSH
12030: LD_VAR 0 1
12034: PPUSH
12035: CALL_OW 250
12039: ADD
12040: ST_TO_ADDR
// ru_bul := ru_bul ^ GetY ( un ) ;
12041: LD_ADDR_EXP 31
12045: PUSH
12046: LD_EXP 31
12050: PUSH
12051: LD_VAR 0 1
12055: PPUSH
12056: CALL_OW 251
12060: ADD
12061: ST_TO_ADDR
// ru_bul := ru_bul ^ GetDir ( un ) ;
12062: LD_ADDR_EXP 31
12066: PUSH
12067: LD_EXP 31
12071: PUSH
12072: LD_VAR 0 1
12076: PPUSH
12077: CALL_OW 254
12081: ADD
12082: ST_TO_ADDR
// end ; if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 255
12092: PUSH
12093: LD_INT 6
12095: EQUAL
12096: PUSH
12097: LD_VAR 0 1
12101: PUSH
12102: LD_INT 21
12104: PUSH
12105: LD_INT 2
12107: PUSH
12108: EMPTY
12109: LIST
12110: LIST
12111: PPUSH
12112: CALL_OW 69
12116: PUSH
12117: LD_INT 34
12119: PUSH
12120: LD_INT 45
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PPUSH
12127: CALL_OW 69
12131: DIFF
12132: IN
12133: AND
12134: IFFALSE 12220
// begin ru_veh := ru_veh ^ GetChassis ( un ) ;
12136: LD_ADDR_EXP 27
12140: PUSH
12141: LD_EXP 27
12145: PUSH
12146: LD_VAR 0 1
12150: PPUSH
12151: CALL_OW 265
12155: ADD
12156: ST_TO_ADDR
// ru_veh := ru_veh ^ GetEngine ( un ) ;
12157: LD_ADDR_EXP 27
12161: PUSH
12162: LD_EXP 27
12166: PUSH
12167: LD_VAR 0 1
12171: PPUSH
12172: CALL_OW 262
12176: ADD
12177: ST_TO_ADDR
// ru_veh := ru_veh ^ GetControl ( un ) ;
12178: LD_ADDR_EXP 27
12182: PUSH
12183: LD_EXP 27
12187: PUSH
12188: LD_VAR 0 1
12192: PPUSH
12193: CALL_OW 263
12197: ADD
12198: ST_TO_ADDR
// ru_veh := ru_veh ^ GetWeapon ( un ) ;
12199: LD_ADDR_EXP 27
12203: PUSH
12204: LD_EXP 27
12208: PUSH
12209: LD_VAR 0 1
12213: PPUSH
12214: CALL_OW 264
12218: ADD
12219: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12220: LD_VAR 0 1
12224: PUSH
12225: LD_INT 22
12227: PUSH
12228: LD_INT 6
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 25
12237: PUSH
12238: LD_INT 3
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: PPUSH
12249: CALL_OW 69
12253: IN
12254: PUSH
12255: LD_INT 22
12257: PUSH
12258: LD_INT 6
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 30
12267: PUSH
12268: LD_INT 3
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 24
12277: PUSH
12278: LD_INT 251
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: EMPTY
12286: LIST
12287: LIST
12288: LIST
12289: PPUSH
12290: CALL_OW 69
12294: PUSH
12295: LD_INT 0
12297: GREATER
12298: AND
12299: IFFALSE 12347
// begin uc_side := 6 ;
12301: LD_ADDR_OWVAR 20
12305: PUSH
12306: LD_INT 6
12308: ST_TO_ADDR
// uc_nation := 3 ;
12309: LD_ADDR_OWVAR 21
12313: PUSH
12314: LD_INT 3
12316: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12317: LD_ADDR_VAR 0 1
12321: PUSH
12322: LD_INT 3
12324: PPUSH
12325: LD_EXP 5
12329: PPUSH
12330: CALL 418 0 2
12334: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
12335: LD_VAR 0 1
12339: PPUSH
12340: LD_INT 92
12342: PPUSH
12343: CALL_OW 52
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
12347: LD_VAR 0 1
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 3
12359: EQUAL
12360: PUSH
12361: LD_VAR 0 1
12365: PUSH
12366: LD_INT 21
12368: PUSH
12369: LD_INT 3
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PPUSH
12376: CALL_OW 69
12380: IN
12381: AND
12382: IFFALSE 12613
// begin if GetBType ( un ) = b_factory then
12384: LD_VAR 0 1
12388: PPUSH
12389: CALL_OW 266
12393: PUSH
12394: LD_INT 3
12396: EQUAL
12397: IFFALSE 12413
// ru2_bul := ru2_bul ^ b_workshop ;
12399: LD_ADDR_EXP 41
12403: PUSH
12404: LD_EXP 41
12408: PUSH
12409: LD_INT 2
12411: ADD
12412: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
12413: LD_VAR 0 1
12417: PPUSH
12418: CALL_OW 266
12422: PUSH
12423: LD_INT 8
12425: EQUAL
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 266
12436: PUSH
12437: LD_INT 7
12439: EQUAL
12440: OR
12441: IFFALSE 12457
// ru2_bul := ru2_bul ^ b_lab ;
12443: LD_ADDR_EXP 41
12447: PUSH
12448: LD_EXP 41
12452: PUSH
12453: LD_INT 6
12455: ADD
12456: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12457: LD_VAR 0 1
12461: PPUSH
12462: CALL_OW 266
12466: PUSH
12467: LD_INT 5
12469: EQUAL
12470: IFFALSE 12486
// ru2_bul := ru2_bul ^ b_armoury ;
12472: LD_ADDR_EXP 41
12476: PUSH
12477: LD_EXP 41
12481: PUSH
12482: LD_INT 4
12484: ADD
12485: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks , b_ext_gun , b_ext_noncombat , b_ext_track ] then
12486: LD_VAR 0 1
12490: PPUSH
12491: CALL_OW 266
12495: PUSH
12496: LD_INT 3
12498: PUSH
12499: LD_INT 8
12501: PUSH
12502: LD_INT 7
12504: PUSH
12505: LD_INT 5
12507: PUSH
12508: LD_INT 17
12510: PUSH
12511: LD_INT 19
12513: PUSH
12514: LD_INT 16
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: IN
12526: NOT
12527: IFFALSE 12550
// ru2_bul := ru2_bul ^ GetBType ( un ) ;
12529: LD_ADDR_EXP 41
12533: PUSH
12534: LD_EXP 41
12538: PUSH
12539: LD_VAR 0 1
12543: PPUSH
12544: CALL_OW 266
12548: ADD
12549: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetX ( un ) ;
12550: LD_ADDR_EXP 41
12554: PUSH
12555: LD_EXP 41
12559: PUSH
12560: LD_VAR 0 1
12564: PPUSH
12565: CALL_OW 250
12569: ADD
12570: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetY ( un ) ;
12571: LD_ADDR_EXP 41
12575: PUSH
12576: LD_EXP 41
12580: PUSH
12581: LD_VAR 0 1
12585: PPUSH
12586: CALL_OW 251
12590: ADD
12591: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetDir ( un ) ;
12592: LD_ADDR_EXP 41
12596: PUSH
12597: LD_EXP 41
12601: PUSH
12602: LD_VAR 0 1
12606: PPUSH
12607: CALL_OW 254
12611: ADD
12612: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
12613: LD_VAR 0 1
12617: PPUSH
12618: CALL_OW 255
12622: PUSH
12623: LD_INT 3
12625: EQUAL
12626: PUSH
12627: LD_VAR 0 1
12631: PUSH
12632: LD_INT 21
12634: PUSH
12635: LD_INT 2
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PPUSH
12642: CALL_OW 69
12646: PUSH
12647: LD_INT 34
12649: PUSH
12650: LD_INT 45
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PPUSH
12657: CALL_OW 69
12661: DIFF
12662: IN
12663: AND
12664: IFFALSE 12750
// begin ru2_veh := ru2_veh ^ GetChassis ( un ) ;
12666: LD_ADDR_EXP 37
12670: PUSH
12671: LD_EXP 37
12675: PUSH
12676: LD_VAR 0 1
12680: PPUSH
12681: CALL_OW 265
12685: ADD
12686: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetEngine ( un ) ;
12687: LD_ADDR_EXP 37
12691: PUSH
12692: LD_EXP 37
12696: PUSH
12697: LD_VAR 0 1
12701: PPUSH
12702: CALL_OW 262
12706: ADD
12707: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetControl ( un ) ;
12708: LD_ADDR_EXP 37
12712: PUSH
12713: LD_EXP 37
12717: PUSH
12718: LD_VAR 0 1
12722: PPUSH
12723: CALL_OW 263
12727: ADD
12728: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetWeapon ( un ) ;
12729: LD_ADDR_EXP 37
12733: PUSH
12734: LD_EXP 37
12738: PUSH
12739: LD_VAR 0 1
12743: PPUSH
12744: CALL_OW 264
12748: ADD
12749: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] , [ f_lives , 251 ] ] ) > 0 then
12750: LD_VAR 0 1
12754: PUSH
12755: LD_INT 22
12757: PUSH
12758: LD_INT 3
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PPUSH
12779: CALL_OW 69
12783: IN
12784: PUSH
12785: LD_INT 22
12787: PUSH
12788: LD_INT 3
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 30
12797: PUSH
12798: LD_INT 3
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 24
12807: PUSH
12808: LD_INT 251
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 69
12824: PUSH
12825: LD_INT 0
12827: GREATER
12828: AND
12829: IFFALSE 12907
// begin uc_side := 3 ;
12831: LD_ADDR_OWVAR 20
12835: PUSH
12836: LD_INT 3
12838: ST_TO_ADDR
// uc_nation := 3 ;
12839: LD_ADDR_OWVAR 21
12843: PUSH
12844: LD_INT 3
12846: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , ru_def ) ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_INT 3
12854: PPUSH
12855: LD_EXP 5
12859: PPUSH
12860: CALL 418 0 2
12864: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12865: LD_VAR 0 1
12869: PPUSH
12870: LD_INT 22
12872: PUSH
12873: LD_INT 3
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PUSH
12880: LD_INT 30
12882: PUSH
12883: LD_INT 3
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PPUSH
12894: CALL_OW 69
12898: PUSH
12899: LD_INT 1
12901: ARRAY
12902: PPUSH
12903: CALL_OW 52
// end ; end ;
12907: PPOPN 1
12909: END
// on VehicleConstructed ( veh , fac ) do begin if veh in FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) then
12910: LD_VAR 0 1
12914: PUSH
12915: LD_INT 2
12917: PUSH
12918: LD_INT 22
12920: PUSH
12921: LD_INT 6
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 3
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 21
12945: PUSH
12946: LD_INT 2
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: LD_INT 2
12958: PUSH
12959: LD_INT 34
12961: PUSH
12962: LD_INT 52
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PUSH
12969: LD_INT 34
12971: PUSH
12972: LD_INT 51
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: LD_INT 34
12981: PUSH
12982: LD_INT 53
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: LIST
13003: PPUSH
13004: CALL_OW 69
13008: IN
13009: IFFALSE 13034
// ru_list_attackers := Insert ( ru_list_attackers , 1 , veh ) ;
13011: LD_ADDR_EXP 43
13015: PUSH
13016: LD_EXP 43
13020: PPUSH
13021: LD_INT 1
13023: PPUSH
13024: LD_VAR 0 1
13028: PPUSH
13029: CALL_OW 2
13033: ST_TO_ADDR
// end ;
13034: PPOPN 2
13036: END
// on BuildingComplete ( b ) do var i ;
13037: LD_INT 0
13039: PPUSH
// begin if b in FilterAllUnits ( [ f_side , 6 ] ) then
13040: LD_VAR 0 1
13044: PUSH
13045: LD_INT 22
13047: PUSH
13048: LD_INT 6
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PPUSH
13055: CALL_OW 69
13059: IN
13060: IFFALSE 13100
// for i = 1 to 4 do
13062: LD_ADDR_VAR 0 2
13066: PUSH
13067: DOUBLE
13068: LD_INT 1
13070: DEC
13071: ST_TO_ADDR
13072: LD_INT 4
13074: PUSH
13075: FOR_TO
13076: IFFALSE 13098
// ru_bul := Delete ( ru_bul , 1 ) ;
13078: LD_ADDR_EXP 31
13082: PUSH
13083: LD_EXP 31
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: CALL_OW 3
13095: ST_TO_ADDR
13096: GO 13075
13098: POP
13099: POP
// if b in FilterAllUnits ( [ f_side , 3 ] ) then
13100: LD_VAR 0 1
13104: PUSH
13105: LD_INT 22
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL_OW 69
13119: IN
13120: IFFALSE 13160
// for i = 1 to 4 do
13122: LD_ADDR_VAR 0 2
13126: PUSH
13127: DOUBLE
13128: LD_INT 1
13130: DEC
13131: ST_TO_ADDR
13132: LD_INT 4
13134: PUSH
13135: FOR_TO
13136: IFFALSE 13158
// ru2_bul := Delete ( ru2_bul , 1 ) ;
13138: LD_ADDR_EXP 41
13142: PUSH
13143: LD_EXP 41
13147: PPUSH
13148: LD_INT 1
13150: PPUSH
13151: CALL_OW 3
13155: ST_TO_ADDR
13156: GO 13135
13158: POP
13159: POP
// end ; end_of_file
13160: PPOPN 2
13162: END
// export function Start_Game ; begin
13163: LD_INT 0
13165: PPUSH
// global_diff := GetMultiplayerSetting ( 0 ) ;
13166: LD_ADDR_EXP 3
13170: PUSH
13171: LD_INT 0
13173: PPUSH
13174: CALL_OW 426
13178: ST_TO_ADDR
// CenterOnXY ( 70 , 130 ) ;
13179: LD_INT 70
13181: PPUSH
13182: LD_INT 130
13184: PPUSH
13185: CALL_OW 84
// case Query ( text1 ) of 1 :
13189: LD_STRING text1
13191: PPUSH
13192: CALL_OW 97
13196: PUSH
13197: LD_INT 1
13199: DOUBLE
13200: EQUAL
13201: IFTRUE 13205
13203: GO 13208
13205: POP
// ; end ;
13206: GO 13209
13208: POP
// ChangeMissionObjectives ( target1 ) ;
13209: LD_STRING target1
13211: PPUSH
13212: CALL_OW 337
// game_started := true ;
13216: LD_ADDR_EXP 10
13220: PUSH
13221: LD_INT 1
13223: ST_TO_ADDR
// crates_allow := true ;
13224: LD_ADDR_EXP 13
13228: PUSH
13229: LD_INT 1
13231: ST_TO_ADDR
// if global_diff > 2 then
13232: LD_EXP 3
13236: PUSH
13237: LD_INT 2
13239: GREATER
13240: IFFALSE 13249
// RemoveUnit ( us_spec_b ) ;
13242: LD_INT 140
13244: PPUSH
13245: CALL_OW 64
// end ;
13249: LD_VAR 0 1
13253: RET
// every 0 0$0.3 trigger SeeSide ( sikorski_veh , 6 ) or SeeSide ( sikorski_veh , 3 ) or SeeSide ( sikorski , 3 ) or SeeSide ( sikorski , 6 ) do
13254: LD_EXP 22
13258: PPUSH
13259: LD_INT 6
13261: PPUSH
13262: CALL 863 0 2
13266: PUSH
13267: LD_EXP 22
13271: PPUSH
13272: LD_INT 3
13274: PPUSH
13275: CALL 863 0 2
13279: OR
13280: PUSH
13281: LD_EXP 14
13285: PPUSH
13286: LD_INT 3
13288: PPUSH
13289: CALL 863 0 2
13293: OR
13294: PUSH
13295: LD_EXP 14
13299: PPUSH
13300: LD_INT 6
13302: PPUSH
13303: CALL 863 0 2
13307: OR
13308: IFFALSE 13325
13310: GO 13312
13312: DISABLE
// Say ( sikorski , DRus ) ;
13313: LD_EXP 14
13317: PPUSH
13318: LD_STRING DRus
13320: PPUSH
13321: CALL_OW 88
13325: END
// every 0 0$03 trigger See ( 4 , sikorski ) or See ( 4 , sikorski_veh ) do var i , per ;
13326: LD_INT 4
13328: PPUSH
13329: LD_EXP 14
13333: PPUSH
13334: CALL_OW 292
13338: PUSH
13339: LD_INT 4
13341: PPUSH
13342: LD_EXP 22
13346: PPUSH
13347: CALL_OW 292
13351: OR
13352: IFFALSE 13774
13354: GO 13356
13356: DISABLE
13357: LD_INT 0
13359: PPUSH
13360: PPUSH
// begin Wait ( 0 0$05 ) ;
13361: LD_INT 175
13363: PPUSH
13364: CALL_OW 67
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
13368: LD_ADDR_VAR 0 1
13372: PUSH
13373: LD_INT 22
13375: PUSH
13376: LD_INT 4
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PPUSH
13383: CALL_OW 69
13387: PUSH
13388: FOR_IN
13389: IFFALSE 13405
// SetSide ( i , 1 ) ;
13391: LD_VAR 0 1
13395: PPUSH
13396: LD_INT 1
13398: PPUSH
13399: CALL_OW 235
13403: GO 13388
13405: POP
13406: POP
// per := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff sikorski ;
13407: LD_ADDR_VAR 0 2
13411: PUSH
13412: LD_INT 22
13414: PUSH
13415: LD_INT 1
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: LD_INT 21
13424: PUSH
13425: LD_INT 1
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 26
13434: PUSH
13435: LD_INT 1
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: PPUSH
13447: CALL_OW 69
13451: PUSH
13452: LD_EXP 14
13456: DIFF
13457: ST_TO_ADDR
// InGameOn ;
13458: CALL_OW 8
// CenterNowOnXY ( 19 , 13 ) ;
13462: LD_INT 19
13464: PPUSH
13465: LD_INT 13
13467: PPUSH
13468: CALL_OW 86
// if IsInUnit ( sikorski ) then
13472: LD_EXP 14
13476: PPUSH
13477: CALL_OW 310
13481: IFFALSE 13499
// begin ComExitVehicle ( sikorski ) ;
13483: LD_EXP 14
13487: PPUSH
13488: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 67
// end ; ComTurnUnit ( sikorski , per [ 1 ] ) ;
13499: LD_EXP 14
13503: PPUSH
13504: LD_VAR 0 2
13508: PUSH
13509: LD_INT 1
13511: ARRAY
13512: PPUSH
13513: CALL_OW 119
// ComTurnUnit ( per [ 1 ] , sikorski ) ;
13517: LD_VAR 0 2
13521: PUSH
13522: LD_INT 1
13524: ARRAY
13525: PPUSH
13526: LD_EXP 14
13530: PPUSH
13531: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
13535: LD_INT 10
13537: PPUSH
13538: CALL_OW 67
// Say ( sikorski , DS-1 ) ;
13542: LD_EXP 14
13546: PPUSH
13547: LD_STRING DS-1
13549: PPUSH
13550: CALL_OW 88
// Say ( per [ 1 ] , DP-1 ) ;
13554: LD_VAR 0 2
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PPUSH
13563: LD_STRING DP-1
13565: PPUSH
13566: CALL_OW 88
// Say ( sikorski , DS-2 ) ;
13570: LD_EXP 14
13574: PPUSH
13575: LD_STRING DS-2
13577: PPUSH
13578: CALL_OW 88
// Say ( per [ 1 ] , DP-2 ) ;
13582: LD_VAR 0 2
13586: PUSH
13587: LD_INT 1
13589: ARRAY
13590: PPUSH
13591: LD_STRING DP-2
13593: PPUSH
13594: CALL_OW 88
// Say ( sikorski , DS-3 ) ;
13598: LD_EXP 14
13602: PPUSH
13603: LD_STRING DS-3
13605: PPUSH
13606: CALL_OW 88
// Say ( per [ 1 ] , DP-3 ) ;
13610: LD_VAR 0 2
13614: PUSH
13615: LD_INT 1
13617: ARRAY
13618: PPUSH
13619: LD_STRING DP-3
13621: PPUSH
13622: CALL_OW 88
// Say ( sikorski , DS-4 ) ;
13626: LD_EXP 14
13630: PPUSH
13631: LD_STRING DS-4
13633: PPUSH
13634: CALL_OW 88
// Wait ( 0 0$0.6 ) ;
13638: LD_INT 21
13640: PPUSH
13641: CALL_OW 67
// SayRadio ( ron , DR-1 ) ;
13645: LD_EXP 17
13649: PPUSH
13650: LD_STRING DR-1
13652: PPUSH
13653: CALL_OW 94
// Say ( sikorski , DS-5 ) ;
13657: LD_EXP 14
13661: PPUSH
13662: LD_STRING DS-5
13664: PPUSH
13665: CALL_OW 88
// SayRadio ( ron , DR-2 ) ;
13669: LD_EXP 17
13673: PPUSH
13674: LD_STRING DR-2
13676: PPUSH
13677: CALL_OW 94
// Say ( sikorski , DS-6 ) ;
13681: LD_EXP 14
13685: PPUSH
13686: LD_STRING DS-6
13688: PPUSH
13689: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
13693: LD_INT 10
13695: PPUSH
13696: CALL_OW 67
// SayRadio ( ron , DR-3 ) ;
13700: LD_EXP 17
13704: PPUSH
13705: LD_STRING DR-3
13707: PPUSH
13708: CALL_OW 94
// InGameOff ;
13712: CALL_OW 9
// ChangeMissionObjectives ( target2 ) ;
13716: LD_STRING target2
13718: PPUSH
13719: CALL_OW 337
// Wait ( 0 0$03 ) ;
13723: LD_INT 105
13725: PPUSH
13726: CALL_OW 67
// Say ( sikorski , DS-7 ) ;
13730: LD_EXP 14
13734: PPUSH
13735: LD_STRING DS-7
13737: PPUSH
13738: CALL_OW 88
// Wait ( [ 6 6$00 , 5 5$00 , 4 4$00 ] [ global_diff ] ) ;
13742: LD_INT 12600
13744: PUSH
13745: LD_INT 10500
13747: PUSH
13748: LD_INT 8400
13750: PUSH
13751: EMPTY
13752: LIST
13753: LIST
13754: LIST
13755: PUSH
13756: LD_EXP 3
13760: ARRAY
13761: PPUSH
13762: CALL_OW 67
// russian_produce := true ;
13766: LD_ADDR_EXP 20
13770: PUSH
13771: LD_INT 1
13773: ST_TO_ADDR
// end ;
13774: PPOPN 2
13776: END
// export us_unit ; every 0 0$11 trigger timer >= [ 25 25$00 , 27 27$30 , 29 29$20 ] [ global_diff ] do
13777: LD_EXP 2
13781: PUSH
13782: LD_INT 52500
13784: PUSH
13785: LD_INT 57750
13787: PUSH
13788: LD_INT 61600
13790: PUSH
13791: EMPTY
13792: LIST
13793: LIST
13794: LIST
13795: PUSH
13796: LD_EXP 3
13800: ARRAY
13801: GREATEREQUAL
13802: IFFALSE 13970
13804: GO 13806
13806: DISABLE
// begin uc_side := 8 ;
13807: LD_ADDR_OWVAR 20
13811: PUSH
13812: LD_INT 8
13814: ST_TO_ADDR
// uc_nation := 1 ;
13815: LD_ADDR_OWVAR 21
13819: PUSH
13820: LD_INT 1
13822: ST_TO_ADDR
// hc_sex := sex_male ;
13823: LD_ADDR_OWVAR 27
13827: PUSH
13828: LD_INT 1
13830: ST_TO_ADDR
// hc_gallery :=  ;
13831: LD_ADDR_OWVAR 33
13835: PUSH
13836: LD_STRING 
13838: ST_TO_ADDR
// hc_name :=  ;
13839: LD_ADDR_OWVAR 26
13843: PUSH
13844: LD_STRING 
13846: ST_TO_ADDR
// hc_class := Rand ( 1 , 4 ) ;
13847: LD_ADDR_OWVAR 28
13851: PUSH
13852: LD_INT 1
13854: PPUSH
13855: LD_INT 4
13857: PPUSH
13858: CALL_OW 12
13862: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
13863: LD_ADDR_OWVAR 31
13867: PUSH
13868: LD_INT 2
13870: PPUSH
13871: LD_EXP 6
13875: PPUSH
13876: CALL_OW 12
13880: PUSH
13881: LD_INT 2
13883: PPUSH
13884: LD_EXP 6
13888: PPUSH
13889: CALL_OW 12
13893: PUSH
13894: LD_INT 2
13896: PPUSH
13897: LD_EXP 6
13901: PPUSH
13902: CALL_OW 12
13906: PUSH
13907: LD_INT 2
13909: PPUSH
13910: LD_EXP 6
13914: PPUSH
13915: CALL_OW 12
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: ST_TO_ADDR
// us_unit := CreateHuman ;
13926: LD_ADDR_EXP 46
13930: PUSH
13931: CALL_OW 44
13935: ST_TO_ADDR
// PlaceUnitArea ( us_unit , swamp_spawn , true ) ;
13936: LD_EXP 46
13940: PPUSH
13941: LD_INT 13
13943: PPUSH
13944: LD_INT 1
13946: PPUSH
13947: CALL_OW 49
// Wait ( 0 0$0.3 ) ;
13951: LD_INT 10
13953: PPUSH
13954: CALL_OW 67
// SayRadio ( us_unit , Dun1 ) ;
13958: LD_EXP 46
13962: PPUSH
13963: LD_STRING Dun1
13965: PPUSH
13966: CALL_OW 94
// end ;
13970: END
// every 0 0$01 trigger See ( 1 , us_unit ) do
13971: LD_INT 1
13973: PPUSH
13974: LD_EXP 46
13978: PPUSH
13979: CALL_OW 292
13983: IFFALSE 14000
13985: GO 13987
13987: DISABLE
// SetSide ( us_unit , 1 ) ;
13988: LD_EXP 46
13992: PPUSH
13993: LD_INT 1
13995: PPUSH
13996: CALL_OW 235
14000: END
// every 1 1$35 trigger timer >= [ 8 8$00 , 9 9$00 , 10 10$00 ] [ global_diff ] do var un , veh , i ;
14001: LD_EXP 2
14005: PUSH
14006: LD_INT 16800
14008: PUSH
14009: LD_INT 18900
14011: PUSH
14012: LD_INT 21000
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: LIST
14019: PUSH
14020: LD_EXP 3
14024: ARRAY
14025: GREATEREQUAL
14026: IFFALSE 14405
14028: GO 14030
14030: DISABLE
14031: LD_INT 0
14033: PPUSH
14034: PPUSH
14035: PPUSH
// begin uc_side := 4 ;
14036: LD_ADDR_OWVAR 20
14040: PUSH
14041: LD_INT 4
14043: ST_TO_ADDR
// uc_nation := 1 ;
14044: LD_ADDR_OWVAR 21
14048: PUSH
14049: LD_INT 1
14051: ST_TO_ADDR
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_medium_wheeled ] [ global_diff ] ;
14052: LD_ADDR_OWVAR 37
14056: PUSH
14057: LD_INT 3
14059: PUSH
14060: LD_INT 2
14062: PUSH
14063: LD_INT 2
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: LIST
14070: PUSH
14071: LD_EXP 3
14075: ARRAY
14076: ST_TO_ADDR
// vc_engine := engine_solar ;
14077: LD_ADDR_OWVAR 39
14081: PUSH
14082: LD_INT 2
14084: ST_TO_ADDR
// vc_control := control_manual ;
14085: LD_ADDR_OWVAR 38
14089: PUSH
14090: LD_INT 1
14092: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
14093: LD_ADDR_OWVAR 40
14097: PUSH
14098: LD_INT 12
14100: ST_TO_ADDR
// veh := CreateVehicle ;
14101: LD_ADDR_VAR 0 2
14105: PUSH
14106: CALL_OW 45
14110: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , false ) ;
14111: LD_VAR 0 2
14115: PPUSH
14116: LD_INT 20
14118: PPUSH
14119: LD_INT 0
14121: PPUSH
14122: CALL_OW 49
// hc_sex := sex_male ;
14126: LD_ADDR_OWVAR 27
14130: PUSH
14131: LD_INT 1
14133: ST_TO_ADDR
// hc_gallery :=  ;
14134: LD_ADDR_OWVAR 33
14138: PUSH
14139: LD_STRING 
14141: ST_TO_ADDR
// hc_name :=  ;
14142: LD_ADDR_OWVAR 26
14146: PUSH
14147: LD_STRING 
14149: ST_TO_ADDR
// hc_class := 3 ;
14150: LD_ADDR_OWVAR 28
14154: PUSH
14155: LD_INT 3
14157: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) , Rand ( 2 , am_def ) ] ;
14158: LD_ADDR_OWVAR 31
14162: PUSH
14163: LD_INT 2
14165: PPUSH
14166: LD_EXP 6
14170: PPUSH
14171: CALL_OW 12
14175: PUSH
14176: LD_INT 2
14178: PPUSH
14179: LD_EXP 6
14183: PPUSH
14184: CALL_OW 12
14188: PUSH
14189: LD_INT 2
14191: PPUSH
14192: LD_EXP 6
14196: PPUSH
14197: CALL_OW 12
14201: PUSH
14202: LD_INT 2
14204: PPUSH
14205: LD_EXP 6
14209: PPUSH
14210: CALL_OW 12
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: ST_TO_ADDR
// un := CreateHuman ;
14221: LD_ADDR_VAR 0 1
14225: PUSH
14226: CALL_OW 44
14230: ST_TO_ADDR
// PlaceUnitArea ( veh , am_car , true ) ;
14231: LD_VAR 0 2
14235: PPUSH
14236: LD_INT 20
14238: PPUSH
14239: LD_INT 1
14241: PPUSH
14242: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
14246: LD_VAR 0 1
14250: PPUSH
14251: LD_VAR 0 2
14255: PPUSH
14256: CALL_OW 52
// SetCargo ( veh , mat_cans , 60 ) ;
14260: LD_VAR 0 2
14264: PPUSH
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 60
14270: PPUSH
14271: CALL_OW 290
// SetFuel ( veh , 98 ) ;
14275: LD_VAR 0 2
14279: PPUSH
14280: LD_INT 98
14282: PPUSH
14283: CALL_OW 240
// SetLives ( un , 500 ) ;
14287: LD_VAR 0 1
14291: PPUSH
14292: LD_INT 500
14294: PPUSH
14295: CALL_OW 234
// SetLives ( veh , Rand ( 900 , 999 ) ) ;
14299: LD_VAR 0 2
14303: PPUSH
14304: LD_INT 900
14306: PPUSH
14307: LD_INT 999
14309: PPUSH
14310: CALL_OW 12
14314: PPUSH
14315: CALL_OW 234
// ComMoveXY ( un , 14 , 9 ) ;
14319: LD_VAR 0 1
14323: PPUSH
14324: LD_INT 14
14326: PPUSH
14327: LD_INT 9
14329: PPUSH
14330: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
14334: LD_INT 35
14336: PPUSH
14337: CALL_OW 67
// until See ( 1 , veh ) or See ( 1 , un ) ;
14341: LD_INT 1
14343: PPUSH
14344: LD_VAR 0 2
14348: PPUSH
14349: CALL_OW 292
14353: PUSH
14354: LD_INT 1
14356: PPUSH
14357: LD_VAR 0 1
14361: PPUSH
14362: CALL_OW 292
14366: OR
14367: IFFALSE 14334
// Say ( un , Dcargo ) ;
14369: LD_VAR 0 1
14373: PPUSH
14374: LD_STRING Dcargo
14376: PPUSH
14377: CALL_OW 88
// SetSide ( un , 1 ) ;
14381: LD_VAR 0 1
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 235
// SetSide ( veh , 1 ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_INT 1
14400: PPUSH
14401: CALL_OW 235
// end ;
14405: PPOPN 3
14407: END
// every 0 0$01 trigger timer >= [ 18 18$00 , 19 19$00 , 21 21$00 ] [ global_diff ] and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) < 5 do var un , speaker , veh , i , area ;
14408: LD_EXP 2
14412: PUSH
14413: LD_INT 37800
14415: PUSH
14416: LD_INT 39900
14418: PUSH
14419: LD_INT 44100
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: LIST
14426: PUSH
14427: LD_EXP 3
14431: ARRAY
14432: GREATEREQUAL
14433: PUSH
14434: LD_INT 22
14436: PUSH
14437: LD_INT 6
14439: PUSH
14440: EMPTY
14441: LIST
14442: LIST
14443: PUSH
14444: LD_INT 21
14446: PUSH
14447: LD_INT 2
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PPUSH
14458: CALL_OW 69
14462: PUSH
14463: LD_INT 5
14465: LESS
14466: AND
14467: IFFALSE 14802
14469: GO 14471
14471: DISABLE
14472: LD_INT 0
14474: PPUSH
14475: PPUSH
14476: PPUSH
14477: PPUSH
14478: PPUSH
// begin area := [ us_north , us_south , us_north ] [ global_diff ] ;
14479: LD_ADDR_VAR 0 5
14483: PUSH
14484: LD_INT 21
14486: PUSH
14487: LD_INT 14
14489: PUSH
14490: LD_INT 21
14492: PUSH
14493: EMPTY
14494: LIST
14495: LIST
14496: LIST
14497: PUSH
14498: LD_EXP 3
14502: ARRAY
14503: ST_TO_ADDR
// speaker := [ ] ;
14504: LD_ADDR_VAR 0 2
14508: PUSH
14509: EMPTY
14510: ST_TO_ADDR
// uc_side := 1 ;
14511: LD_ADDR_OWVAR 20
14515: PUSH
14516: LD_INT 1
14518: ST_TO_ADDR
// uc_nation := 1 ;
14519: LD_ADDR_OWVAR 21
14523: PUSH
14524: LD_INT 1
14526: ST_TO_ADDR
// for i = 1 to 7 - [ global_diff ] do
14527: LD_ADDR_VAR 0 4
14531: PUSH
14532: DOUBLE
14533: LD_INT 1
14535: DEC
14536: ST_TO_ADDR
14537: LD_INT 7
14539: PUSH
14540: LD_EXP 3
14544: PUSH
14545: EMPTY
14546: LIST
14547: MINUS
14548: PUSH
14549: FOR_TO
14550: IFFALSE 14613
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , am_def ) ;
14552: LD_ADDR_VAR 0 1
14556: PUSH
14557: LD_INT 1
14559: PPUSH
14560: LD_INT 4
14562: PPUSH
14563: CALL_OW 12
14567: PPUSH
14568: LD_EXP 6
14572: PPUSH
14573: CALL 418 0 2
14577: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
14578: LD_VAR 0 1
14582: PPUSH
14583: LD_VAR 0 5
14587: PPUSH
14588: LD_INT 0
14590: PPUSH
14591: CALL_OW 49
// speaker := speaker ^ un ;
14595: LD_ADDR_VAR 0 2
14599: PUSH
14600: LD_VAR 0 2
14604: PUSH
14605: LD_VAR 0 1
14609: ADD
14610: ST_TO_ADDR
// end ;
14611: GO 14549
14613: POP
14614: POP
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ global_diff ] ;
14615: LD_ADDR_OWVAR 37
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: LD_INT 2
14625: PUSH
14626: LD_INT 1
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: LIST
14633: PUSH
14634: LD_EXP 3
14638: ARRAY
14639: ST_TO_ADDR
// vc_engine := engine_solar ;
14640: LD_ADDR_OWVAR 39
14644: PUSH
14645: LD_INT 2
14647: ST_TO_ADDR
// vc_control := control_manual ;
14648: LD_ADDR_OWVAR 38
14652: PUSH
14653: LD_INT 1
14655: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_gatling_gun , us_machine_gun ] [ global_diff ] ;
14656: LD_ADDR_OWVAR 40
14660: PUSH
14661: LD_INT 5
14663: PUSH
14664: LD_INT 4
14666: PUSH
14667: LD_INT 2
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: LIST
14674: PUSH
14675: LD_EXP 3
14679: ARRAY
14680: ST_TO_ADDR
// veh := CreateVehicle ;
14681: LD_ADDR_VAR 0 3
14685: PUSH
14686: CALL_OW 45
14690: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
14691: LD_VAR 0 3
14695: PPUSH
14696: LD_VAR 0 5
14700: PPUSH
14701: LD_INT 0
14703: PPUSH
14704: CALL_OW 49
// un := CreateHumanWithClass ( 3 , am_def ) ;
14708: LD_ADDR_VAR 0 1
14712: PUSH
14713: LD_INT 3
14715: PPUSH
14716: LD_EXP 6
14720: PPUSH
14721: CALL 418 0 2
14725: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
14726: LD_VAR 0 1
14730: PPUSH
14731: LD_VAR 0 3
14735: PPUSH
14736: CALL_OW 52
// Wait ( 0 0$0.3 ) ;
14740: LD_INT 10
14742: PPUSH
14743: CALL_OW 67
// SayRadio ( UnitFilter ( speaker , [ f_sex , sex_male ] ) [ 1 ] , Dhelp ) ;
14747: LD_VAR 0 2
14751: PPUSH
14752: LD_INT 26
14754: PUSH
14755: LD_INT 1
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PPUSH
14762: CALL_OW 72
14766: PUSH
14767: LD_INT 1
14769: ARRAY
14770: PPUSH
14771: LD_STRING Dhelp
14773: PPUSH
14774: CALL_OW 94
// CenterNowOnXY ( GetX ( un ) , GetY ( un ) ) ;
14778: LD_VAR 0 1
14782: PPUSH
14783: CALL_OW 250
14787: PPUSH
14788: LD_VAR 0 1
14792: PPUSH
14793: CALL_OW 251
14797: PPUSH
14798: CALL_OW 86
// end ;
14802: PPOPN 5
14804: END
// every 0 0$01 trigger FilterUnitsInArea ( kurin_a , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) and IsOk ( Kurin ) do
14805: LD_INT 19
14807: PPUSH
14808: LD_INT 2
14810: PUSH
14811: LD_INT 22
14813: PUSH
14814: LD_INT 3
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: PUSH
14821: LD_INT 22
14823: PUSH
14824: LD_INT 6
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: LIST
14835: PPUSH
14836: CALL_OW 70
14840: PUSH
14841: LD_EXP 15
14845: PPUSH
14846: CALL_OW 302
14850: AND
14851: IFFALSE 14868
14853: GO 14855
14855: DISABLE
// SayRadio ( Kurin , Dkurin ) ;
14856: LD_EXP 15
14860: PPUSH
14861: LD_STRING Dkurin
14863: PPUSH
14864: CALL_OW 94
14868: END
// every 0 0$01 trigger timer > 27 27$00 do
14869: LD_EXP 2
14873: PUSH
14874: LD_INT 56700
14876: GREATER
14877: IFFALSE 14894
14879: GO 14881
14881: DISABLE
// SayRadio ( jack , ar_come ) ;
14882: LD_EXP 18
14886: PPUSH
14887: LD_STRING ar_come
14889: PPUSH
14890: CALL_OW 94
14894: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) > 0 do
14895: LD_INT 22
14897: PUSH
14898: LD_INT 2
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: PPUSH
14905: CALL_OW 69
14909: PUSH
14910: LD_INT 0
14912: GREATER
14913: IFFALSE 14941
14915: GO 14917
14917: DISABLE
// begin FHeike ;
14918: CALL 11542 0 0
// Wait ( 0 0$01 ) ;
14922: LD_INT 35
14924: PPUSH
14925: CALL_OW 67
// SayRadio ( heike , heike1 ) ;
14929: LD_EXP 16
14933: PPUSH
14934: LD_STRING heike1
14936: PPUSH
14937: CALL_OW 94
// end ;
14941: END
// every 15 15$00 trigger timer > 22 22$00 do
14942: LD_EXP 2
14946: PUSH
14947: LD_INT 46200
14949: GREATER
14950: IFFALSE 15001
14952: GO 14954
14954: DISABLE
// begin enable ;
14955: ENABLE
// ArabianAttack ( 2 , ar_force , Rand ( 1 , 2 ) , [ ar_area1 , ar_area2 ] [ Rand ( 1 , 2 ) ] ) ;
14956: LD_INT 2
14958: PPUSH
14959: LD_EXP 9
14963: PPUSH
14964: LD_INT 1
14966: PPUSH
14967: LD_INT 2
14969: PPUSH
14970: CALL_OW 12
14974: PPUSH
14975: LD_INT 6
14977: PUSH
14978: LD_INT 16
14980: PUSH
14981: EMPTY
14982: LIST
14983: LIST
14984: PUSH
14985: LD_INT 1
14987: PPUSH
14988: LD_INT 2
14990: PPUSH
14991: CALL_OW 12
14995: ARRAY
14996: PPUSH
14997: CALL 10959 0 4
// end ;
15001: END
// every 0 0$01 trigger timer >= Rand ( 65 65$00 , 67 67$30 ) or ( FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 ) do var i ;
15002: LD_EXP 2
15006: PUSH
15007: LD_INT 136500
15009: PPUSH
15010: LD_INT 141750
15012: PPUSH
15013: CALL_OW 12
15017: GREATEREQUAL
15018: PUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 3
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PPUSH
15029: CALL_OW 69
15033: PUSH
15034: LD_INT 22
15036: PUSH
15037: LD_INT 6
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: PLUS
15049: PUSH
15050: LD_INT 3
15052: LESS
15053: OR
15054: IFFALSE 15128
15056: GO 15058
15058: DISABLE
15059: LD_INT 0
15061: PPUSH
// begin InGameOn ;
15062: CALL_OW 8
// DialogueOn ;
15066: CALL_OW 6
// SayRadio ( ron , you_win ) ;
15070: LD_EXP 17
15074: PPUSH
15075: LD_STRING you_win
15077: PPUSH
15078: CALL_OW 94
// DialogueOff ;
15082: CALL_OW 7
// InGameOff ;
15086: CALL_OW 9
// AddMedal ( med , 1 ) ;
15090: LD_STRING med
15092: PPUSH
15093: LD_INT 1
15095: PPUSH
15096: CALL_OW 101
// End_The_Mission_Allowed := true ;
15100: LD_ADDR_OWVAR 57
15104: PUSH
15105: LD_INT 1
15107: ST_TO_ADDR
// case Query ( MEnd ) of 1 :
15108: LD_STRING MEnd
15110: PPUSH
15111: CALL_OW 97
15115: PUSH
15116: LD_INT 1
15118: DOUBLE
15119: EQUAL
15120: IFTRUE 15124
15122: GO 15127
15124: POP
// ; end ;
15125: GO 15128
15127: POP
// end ;
15128: PPOPN 1
15130: END
// on EndTheMissionRaised ( exitt ) do begin End_The_Mission_Allowed := false ;
15131: LD_ADDR_OWVAR 57
15135: PUSH
15136: LD_INT 0
15138: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 3 ] ) + FilterAllUnits ( [ f_side , 6 ] ) < 3 then
15139: LD_INT 22
15141: PUSH
15142: LD_INT 3
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PUSH
15154: LD_INT 22
15156: PUSH
15157: LD_INT 6
15159: PUSH
15160: EMPTY
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PLUS
15169: PUSH
15170: LD_INT 3
15172: LESS
15173: IFFALSE 15187
// AddMedal ( ru , 1 ) else
15175: LD_STRING ru
15177: PPUSH
15178: LD_INT 1
15180: PPUSH
15181: CALL_OW 101
15185: GO 15198
// AddMedal ( ru , - 1 ) ;
15187: LD_STRING ru
15189: PPUSH
15190: LD_INT 1
15192: NEG
15193: PPUSH
15194: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 6 then
15198: LD_INT 22
15200: PUSH
15201: LD_INT 1
15203: PUSH
15204: EMPTY
15205: LIST
15206: LIST
15207: PUSH
15208: LD_INT 21
15210: PUSH
15211: LD_INT 1
15213: PUSH
15214: EMPTY
15215: LIST
15216: LIST
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: PPUSH
15222: CALL_OW 69
15226: PUSH
15227: LD_INT 6
15229: GREATER
15230: IFFALSE 15244
// AddMedal ( pep , 1 ) else
15232: LD_STRING pep
15234: PPUSH
15235: LD_INT 1
15237: PPUSH
15238: CALL_OW 101
15242: GO 15255
// AddMedal ( pep , - 1 ) ;
15244: LD_STRING pep
15246: PPUSH
15247: LD_INT 1
15249: NEG
15250: PPUSH
15251: CALL_OW 101
// GiveMedals ( MAIN ) ;
15255: LD_STRING MAIN
15257: PPUSH
15258: CALL_OW 102
// YouWin ;
15262: CALL_OW 103
// end ;
15266: PPOPN 1
15268: END
