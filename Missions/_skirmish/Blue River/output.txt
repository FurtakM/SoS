// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// PlaceSeeing ( 0 , 0 , 7 , - 37963 ) ;
  11: LD_INT 0
  13: PPUSH
  14: LD_INT 0
  16: PPUSH
  17: LD_INT 7
  19: PPUSH
  20: LD_INT 37963
  22: NEG
  23: PPUSH
  24: CALL_OW 330
// RemoveSeeing ( 0 , 0 , 7 ) ;
  28: LD_INT 0
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 7
  36: PPUSH
  37: CALL_OW 331
// PrepareBase ;
  41: CALL 514 0 0
// Action ;
  45: CALL 54 0 0
// SaveForQuickRestart ;
  49: CALL_OW 22
// end ;
  53: END
// function Action ; var un , f , i ; begin
  54: LD_INT 0
  56: PPUSH
  57: PPUSH
  58: PPUSH
  59: PPUSH
// SetBName ( brave , brave ) ;
  60: LD_INT 1
  62: PPUSH
  63: LD_STRING brave
  65: PPUSH
  66: CALL_OW 500
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// SetResourceType ( GetBase ( brave ) , mat_cans , [ 6000 , 4500 , 3000 ] [ Difficulty ] ) ;
  83: LD_INT 1
  85: PPUSH
  86: CALL_OW 274
  90: PPUSH
  91: LD_INT 1
  93: PPUSH
  94: LD_INT 6000
  96: PUSH
  97: LD_INT 4500
  99: PUSH
 100: LD_INT 3000
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: LIST
 107: PUSH
 108: LD_OWVAR 67
 112: ARRAY
 113: PPUSH
 114: CALL_OW 277
// InGameOn ;
 118: CALL_OW 8
// CenterNowOnUnits ( brave ) ;
 122: LD_INT 1
 124: PPUSH
 125: CALL_OW 87
// Say ( com , DJack1 ) ;
 129: LD_EXP 1
 133: PPUSH
 134: LD_STRING DJack1
 136: PPUSH
 137: CALL_OW 88
// Say ( k1 , DUn1 ) ;
 141: LD_EXP 3
 145: PPUSH
 146: LD_STRING DUn1
 148: PPUSH
 149: CALL_OW 88
// Say ( com , DJack2 ) ;
 153: LD_EXP 1
 157: PPUSH
 158: LD_STRING DJack2
 160: PPUSH
 161: CALL_OW 88
// Say ( k1 , DUn2 ) ;
 165: LD_EXP 3
 169: PPUSH
 170: LD_STRING DUn2
 172: PPUSH
 173: CALL_OW 88
// Say ( com , DJack3 ) ;
 177: LD_EXP 1
 181: PPUSH
 182: LD_STRING DJack3
 184: PPUSH
 185: CALL_OW 88
// uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := 1 ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_INT 1
 204: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 0 ) ;
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 0
 213: PPUSH
 214: CALL_OW 380
// hc_name :=  ;
 218: LD_ADDR_OWVAR 26
 222: PUSH
 223: LD_STRING 
 225: ST_TO_ADDR
// un := CreateHuman ;
 226: LD_ADDR_VAR 0 2
 230: PUSH
 231: CALL_OW 44
 235: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
 236: LD_INT 105
 238: PPUSH
 239: CALL_OW 67
// SayRadio ( un , DRadio1 ) ;
 243: LD_VAR 0 2
 247: PPUSH
 248: LD_STRING DRadio1
 250: PPUSH
 251: CALL_OW 94
// Say ( com , DJack4 ) ;
 255: LD_EXP 1
 259: PPUSH
 260: LD_STRING DJack4
 262: PPUSH
 263: CALL_OW 88
// SayRadio ( un , DRadio2 ) ;
 267: LD_VAR 0 2
 271: PPUSH
 272: LD_STRING DRadio2
 274: PPUSH
 275: CALL_OW 94
// Wait ( 0 0$01 ) ;
 279: LD_INT 35
 281: PPUSH
 282: CALL_OW 67
// SayRadio ( doc , DDoc1 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_STRING DDoc1
 293: PPUSH
 294: CALL_OW 94
// Say ( com , DJack5 ) ;
 298: LD_EXP 1
 302: PPUSH
 303: LD_STRING DJack5
 305: PPUSH
 306: CALL_OW 88
// SayRadio ( doc , DDoc2 ) ;
 310: LD_EXP 2
 314: PPUSH
 315: LD_STRING DDoc2
 317: PPUSH
 318: CALL_OW 94
// SayRadio ( un , DRadio3 ) ;
 322: LD_VAR 0 2
 326: PPUSH
 327: LD_STRING DRadio3
 329: PPUSH
 330: CALL_OW 94
// Say ( com , DJack6 ) ;
 334: LD_EXP 1
 338: PPUSH
 339: LD_STRING DJack6
 341: PPUSH
 342: CALL_OW 88
// f := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
 346: LD_ADDR_VAR 0 3
 350: PUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 7
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 21
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: ST_TO_ADDR
// for i = 2 to f do
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: DOUBLE
 386: LD_INT 2
 388: DEC
 389: ST_TO_ADDR
 390: LD_VAR 0 3
 394: PUSH
 395: FOR_TO
 396: IFFALSE 453
// begin ComExitBuilding ( f [ i ] ) ;
 398: LD_VAR 0 3
 402: PUSH
 403: LD_VAR 0 4
 407: ARRAY
 408: PPUSH
 409: CALL_OW 122
// AddComMoveToArea ( f [ i ] , act_area ) ;
 413: LD_VAR 0 3
 417: PUSH
 418: LD_VAR 0 4
 422: ARRAY
 423: PPUSH
 424: LD_INT 7
 426: PPUSH
 427: CALL_OW 173
// AddComTurnUnit ( f [ i ] , com ) ;
 431: LD_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ARRAY
 441: PPUSH
 442: LD_EXP 1
 446: PPUSH
 447: CALL_OW 179
// end ;
 451: GO 395
 453: POP
 454: POP
// ComExitBuilding ( com ) ;
 455: LD_EXP 1
 459: PPUSH
 460: CALL_OW 122
// AddComTurnXY ( com , 45 , 32 ) ;
 464: LD_EXP 1
 468: PPUSH
 469: LD_INT 45
 471: PPUSH
 472: LD_INT 32
 474: PPUSH
 475: CALL_OW 178
// Wait ( 0 0$03 ) ;
 479: LD_INT 105
 481: PPUSH
 482: CALL_OW 67
// Say ( com , DJack7 ) ;
 486: LD_EXP 1
 490: PPUSH
 491: LD_STRING DJack7
 493: PPUSH
 494: CALL_OW 88
// InGameOff ;
 498: CALL_OW 9
// ChangeMissionObjectives ( TDef ) ;
 502: LD_STRING TDef
 504: PPUSH
 505: CALL_OW 337
// end ; end_of_file
 509: LD_VAR 0 1
 513: RET
// export com , doc , k1 ; export function PrepareBase ; var i , un , skill ; begin
 514: LD_INT 0
 516: PPUSH
 517: PPUSH
 518: PPUSH
 519: PPUSH
// PlaceSeeing ( 30 , 14 , 7 , 20 ) ;
 520: LD_INT 30
 522: PPUSH
 523: LD_INT 14
 525: PPUSH
 526: LD_INT 7
 528: PPUSH
 529: LD_INT 20
 531: PPUSH
 532: CALL_OW 330
// PlaceSeeing ( 49 , 17 , 7 , 20 ) ;
 536: LD_INT 49
 538: PPUSH
 539: LD_INT 17
 541: PPUSH
 542: LD_INT 7
 544: PPUSH
 545: LD_INT 20
 547: PPUSH
 548: CALL_OW 330
// PlaceSeeing ( 35 , 46 , 7 , 20 ) ;
 552: LD_INT 35
 554: PPUSH
 555: LD_INT 46
 557: PPUSH
 558: LD_INT 7
 560: PPUSH
 561: LD_INT 20
 563: PPUSH
 564: CALL_OW 330
// PlaceSeeing ( 70 , 39 , 7 , 20 ) ;
 568: LD_INT 70
 570: PPUSH
 571: LD_INT 39
 573: PPUSH
 574: LD_INT 7
 576: PPUSH
 577: LD_INT 20
 579: PPUSH
 580: CALL_OW 330
// RemoveSeeing ( 30 , 14 , 7 ) ;
 584: LD_INT 30
 586: PPUSH
 587: LD_INT 14
 589: PPUSH
 590: LD_INT 7
 592: PPUSH
 593: CALL_OW 331
// RemoveSeeing ( 49 , 17 , 7 ) ;
 597: LD_INT 49
 599: PPUSH
 600: LD_INT 17
 602: PPUSH
 603: LD_INT 7
 605: PPUSH
 606: CALL_OW 331
// RemoveSeeing ( 35 , 46 , 7 ) ;
 610: LD_INT 35
 612: PPUSH
 613: LD_INT 46
 615: PPUSH
 616: LD_INT 7
 618: PPUSH
 619: CALL_OW 331
// RemoveSeeing ( 70 , 39 , 7 ) ;
 623: LD_INT 70
 625: PPUSH
 626: LD_INT 39
 628: PPUSH
 629: LD_INT 7
 631: PPUSH
 632: CALL_OW 331
// uc_side := 7 ;
 636: LD_ADDR_OWVAR 20
 640: PUSH
 641: LD_INT 7
 643: ST_TO_ADDR
// uc_nation := 1 ;
 644: LD_ADDR_OWVAR 21
 648: PUSH
 649: LD_INT 1
 651: ST_TO_ADDR
// if Difficulty < 3 then
 652: LD_OWVAR 67
 656: PUSH
 657: LD_INT 3
 659: LESS
 660: IFFALSE 761
// begin for i = 1 to 2 do
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: DOUBLE
 668: LD_INT 1
 670: DEC
 671: ST_TO_ADDR
 672: LD_INT 2
 674: PUSH
 675: FOR_TO
 676: IFFALSE 757
// begin vc_chassis := us_heavy_tracked ;
 678: LD_ADDR_OWVAR 37
 682: PUSH
 683: LD_INT 4
 685: ST_TO_ADDR
// vc_engine := 3 ;
 686: LD_ADDR_OWVAR 39
 690: PUSH
 691: LD_INT 3
 693: ST_TO_ADDR
// vc_control := control_computer ;
 694: LD_ADDR_OWVAR 38
 698: PUSH
 699: LD_INT 3
 701: ST_TO_ADDR
// vc_weapon := us_double_laser ;
 702: LD_ADDR_OWVAR 40
 706: PUSH
 707: LD_INT 10
 709: ST_TO_ADDR
// un := CreateVehicle ;
 710: LD_ADDR_VAR 0 3
 714: PUSH
 715: CALL_OW 45
 719: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 720: LD_VAR 0 3
 724: PPUSH
 725: LD_INT 0
 727: PPUSH
 728: LD_INT 5
 730: PPUSH
 731: CALL_OW 12
 735: PPUSH
 736: CALL_OW 233
// PlaceUnitArea ( un , base_spawn , false ) ;
 740: LD_VAR 0 3
 744: PPUSH
 745: LD_INT 6
 747: PPUSH
 748: LD_INT 0
 750: PPUSH
 751: CALL_OW 49
// end ;
 755: GO 675
 757: POP
 758: POP
// end else
 759: GO 850
// begin vc_chassis := us_medium_tracked ;
 761: LD_ADDR_OWVAR 37
 765: PUSH
 766: LD_INT 3
 768: ST_TO_ADDR
// vc_engine := engine_combustion ;
 769: LD_ADDR_OWVAR 39
 773: PUSH
 774: LD_INT 1
 776: ST_TO_ADDR
// vc_control := control_manual ;
 777: LD_ADDR_OWVAR 38
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
 785: LD_ADDR_OWVAR 40
 789: PUSH
 790: LD_INT 4
 792: ST_TO_ADDR
// un := CreateVehicle ;
 793: LD_ADDR_VAR 0 3
 797: PUSH
 798: CALL_OW 45
 802: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 803: LD_VAR 0 3
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: LD_INT 5
 813: PPUSH
 814: CALL_OW 12
 818: PPUSH
 819: CALL_OW 233
// SetFuel ( un , 75 ) ;
 823: LD_VAR 0 3
 827: PPUSH
 828: LD_INT 75
 830: PPUSH
 831: CALL_OW 240
// PlaceUnitArea ( un , base_spawn , false ) ;
 835: LD_VAR 0 3
 839: PPUSH
 840: LD_INT 6
 842: PPUSH
 843: LD_INT 0
 845: PPUSH
 846: CALL_OW 49
// end ; skill := [ 8 , 7 , 6 ] [ Difficulty ] ;
 850: LD_ADDR_VAR 0 4
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: LD_INT 7
 860: PUSH
 861: LD_INT 6
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_OWVAR 67
 873: ARRAY
 874: ST_TO_ADDR
// hc_importance := 100 ;
 875: LD_ADDR_OWVAR 32
 879: PUSH
 880: LD_INT 100
 882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 883: LD_INT 1
 885: PPUSH
 886: LD_INT 1
 888: PPUSH
 889: LD_VAR 0 4
 893: PPUSH
 894: CALL_OW 380
// hc_name := Jack Collins ;
 898: LD_ADDR_OWVAR 26
 902: PUSH
 903: LD_STRING Jack Collins
 905: ST_TO_ADDR
// com := CreateHuman ;
 906: LD_ADDR_EXP 1
 910: PUSH
 911: CALL_OW 44
 915: ST_TO_ADDR
// PlaceHumanInUnit ( com , brave ) ;
 916: LD_EXP 1
 920: PPUSH
 921: LD_INT 1
 923: PPUSH
 924: CALL_OW 52
// hc_importance := 0 ;
 928: LD_ADDR_OWVAR 32
 932: PUSH
 933: LD_INT 0
 935: ST_TO_ADDR
// hc_gallery :=  ;
 936: LD_ADDR_OWVAR 33
 940: PUSH
 941: LD_STRING 
 943: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 4
 954: PPUSH
 955: CALL_OW 380
// hc_name := Thomas Jackson ;
 959: LD_ADDR_OWVAR 26
 963: PUSH
 964: LD_STRING Thomas Jackson
 966: ST_TO_ADDR
// k1 := CreateHuman ;
 967: LD_ADDR_EXP 3
 971: PUSH
 972: CALL_OW 44
 976: ST_TO_ADDR
// PlaceHumanInUnit ( k1 , brave ) ;
 977: LD_EXP 3
 981: PPUSH
 982: LD_INT 1
 984: PPUSH
 985: CALL_OW 52
// hc_name :=  ;
 989: LD_ADDR_OWVAR 26
 993: PUSH
 994: LD_STRING 
 996: ST_TO_ADDR
// for i = 1 to [ 9 , 8 , 7 ] [ Difficulty ] do
 997: LD_ADDR_VAR 0 2
1001: PUSH
1002: DOUBLE
1003: LD_INT 1
1005: DEC
1006: ST_TO_ADDR
1007: LD_INT 9
1009: PUSH
1010: LD_INT 8
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_OWVAR 67
1025: ARRAY
1026: PUSH
1027: FOR_TO
1028: IFFALSE 1199
// begin Randomize ;
1030: CALL_OW 10
// uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1034: LD_ADDR_OWVAR 21
1038: PUSH
1039: LD_INT 1
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 2
1054: PPUSH
1055: CALL_OW 12
1059: ARRAY
1060: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , skill ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 1
1066: PPUSH
1067: LD_INT 4
1069: PPUSH
1070: CALL_OW 12
1074: PPUSH
1075: LD_VAR 0 4
1079: PPUSH
1080: CALL_OW 380
// un := CreateHuman ;
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: CALL_OW 44
1093: ST_TO_ADDR
// case GetClass ( un ) of 1 :
1094: LD_VAR 0 3
1098: PPUSH
1099: CALL_OW 257
1103: PUSH
1104: LD_INT 1
1106: DOUBLE
1107: EQUAL
1108: IFTRUE 1112
1110: GO 1127
1112: POP
// PlaceHumanInUnit ( un , br ) ; 2 :
1113: LD_VAR 0 3
1117: PPUSH
1118: LD_INT 21
1120: PPUSH
1121: CALL_OW 52
1125: GO 1197
1127: LD_INT 2
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1150
1135: POP
// PlaceHumanInUnit ( un , brave ) ; 3 :
1136: LD_VAR 0 3
1140: PPUSH
1141: LD_INT 1
1143: PPUSH
1144: CALL_OW 52
1148: GO 1197
1150: LD_INT 3
1152: DOUBLE
1153: EQUAL
1154: IFTRUE 1158
1156: GO 1173
1158: POP
// PlaceHumanInUnit ( un , fac ) ; 4 :
1159: LD_VAR 0 3
1163: PPUSH
1164: LD_INT 38
1166: PPUSH
1167: CALL_OW 52
1171: GO 1197
1173: LD_INT 4
1175: DOUBLE
1176: EQUAL
1177: IFTRUE 1181
1179: GO 1196
1181: POP
// PlaceHumanInUnit ( un , lab ) ; end ;
1182: LD_VAR 0 3
1186: PPUSH
1187: LD_INT 36
1189: PPUSH
1190: CALL_OW 52
1194: GO 1197
1196: POP
// end ;
1197: GO 1027
1199: POP
1200: POP
// uc_side := 2 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 2
1208: ST_TO_ADDR
// uc_nation := 2 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 2
1216: ST_TO_ADDR
// hc_name := _ ;
1217: LD_ADDR_OWVAR 26
1221: PUSH
1222: LD_STRING _
1224: ST_TO_ADDR
// hc_gallery :=  ;
1225: LD_ADDR_OWVAR 33
1229: PUSH
1230: LD_STRING 
1232: ST_TO_ADDR
// hc_class := 4 ;
1233: LD_ADDR_OWVAR 28
1237: PUSH
1238: LD_INT 4
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// doc := CreateHuman ;
1249: LD_ADDR_EXP 2
1253: PUSH
1254: CALL_OW 44
1258: ST_TO_ADDR
// end ; end_of_file
1259: LD_VAR 0 1
1263: RET
// export function Attack ( num ) ; var i , un , tmp ; begin
1264: LD_INT 0
1266: PPUSH
1267: PPUSH
1268: PPUSH
1269: PPUSH
// uc_side := 2 ;
1270: LD_ADDR_OWVAR 20
1274: PUSH
1275: LD_INT 2
1277: ST_TO_ADDR
// uc_nation := 2 ;
1278: LD_ADDR_OWVAR 21
1282: PUSH
1283: LD_INT 2
1285: ST_TO_ADDR
// tmp := [ ] ;
1286: LD_ADDR_VAR 0 5
1290: PUSH
1291: EMPTY
1292: ST_TO_ADDR
// hc_skills := [ [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] ] ;
1293: LD_ADDR_OWVAR 31
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: LD_INT 6
1303: PUSH
1304: LD_INT 10
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_OWVAR 67
1316: ARRAY
1317: PUSH
1318: LD_INT 3
1320: PUSH
1321: LD_INT 6
1323: PUSH
1324: LD_INT 10
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: LIST
1331: PUSH
1332: LD_OWVAR 67
1336: ARRAY
1337: PUSH
1338: LD_INT 3
1340: PUSH
1341: LD_INT 6
1343: PUSH
1344: LD_INT 10
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_OWVAR 67
1356: ARRAY
1357: PUSH
1358: LD_INT 3
1360: PUSH
1361: LD_INT 6
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: LD_OWVAR 67
1376: ARRAY
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: ST_TO_ADDR
// if FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) then
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 22
1389: PUSH
1390: LD_INT 7
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: PPUSH
1397: CALL_OW 70
1401: IFFALSE 1442
// for i in FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) do
1403: LD_ADDR_VAR 0 3
1407: PUSH
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 22
1413: PUSH
1414: LD_INT 7
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PPUSH
1421: CALL_OW 70
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1440
// RemoveUnit ( i ) ;
1429: LD_VAR 0 3
1433: PPUSH
1434: CALL_OW 64
1438: GO 1426
1440: POP
1441: POP
// if FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) then
1442: LD_INT 5
1444: PPUSH
1445: LD_INT 22
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 70
1459: IFFALSE 1500
// for i in FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) do
1461: LD_ADDR_VAR 0 3
1465: PUSH
1466: LD_INT 5
1468: PPUSH
1469: LD_INT 22
1471: PUSH
1472: LD_INT 7
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PPUSH
1479: CALL_OW 70
1483: PUSH
1484: FOR_IN
1485: IFFALSE 1498
// RemoveUnit ( i ) ;
1487: LD_VAR 0 3
1491: PPUSH
1492: CALL_OW 64
1496: GO 1484
1498: POP
1499: POP
// if FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) then
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 22
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 70
1517: IFFALSE 1558
// for i in FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) do
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_INT 1
1526: PPUSH
1527: LD_INT 22
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PPUSH
1537: CALL_OW 70
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1556
// RemoveUnit ( i ) ;
1545: LD_VAR 0 3
1549: PPUSH
1550: CALL_OW 64
1554: GO 1542
1556: POP
1557: POP
// if FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) then
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 7
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL_OW 70
1575: IFFALSE 1616
// for i in FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) do
1577: LD_ADDR_VAR 0 3
1581: PUSH
1582: LD_INT 2
1584: PPUSH
1585: LD_INT 22
1587: PUSH
1588: LD_INT 7
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 70
1599: PUSH
1600: FOR_IN
1601: IFFALSE 1614
// RemoveUnit ( i ) ;
1603: LD_VAR 0 3
1607: PPUSH
1608: CALL_OW 64
1612: GO 1600
1614: POP
1615: POP
// case num of 1 :
1616: LD_VAR 0 1
1620: PUSH
1621: LD_INT 1
1623: DOUBLE
1624: EQUAL
1625: IFTRUE 1629
1627: GO 1882
1629: POP
// begin for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: DOUBLE
1636: LD_INT 1
1638: DEC
1639: ST_TO_ADDR
1640: LD_INT 5
1642: PUSH
1643: LD_INT 6
1645: PUSH
1646: LD_INT 6
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_OWVAR 67
1658: ARRAY
1659: PUSH
1660: FOR_TO
1661: IFFALSE 1753
// begin uc_nation := 0 ;
1663: LD_ADDR_OWVAR 21
1667: PUSH
1668: LD_INT 0
1670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1671: LD_ADDR_OWVAR 28
1675: PUSH
1676: LD_INT 15
1678: ST_TO_ADDR
// hc_gallery :=  ;
1679: LD_ADDR_OWVAR 33
1683: PUSH
1684: LD_STRING 
1686: ST_TO_ADDR
// hc_name :=  ;
1687: LD_ADDR_OWVAR 26
1691: PUSH
1692: LD_STRING 
1694: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1695: LD_ADDR_OWVAR 29
1699: PUSH
1700: LD_INT 16
1702: PUSH
1703: LD_INT 12
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// un := CreateHuman ;
1710: LD_ADDR_VAR 0 4
1714: PUSH
1715: CALL_OW 44
1719: ST_TO_ADDR
// PlaceUnitArea ( un , north_spawn , false ) ;
1720: LD_VAR 0 4
1724: PPUSH
1725: LD_INT 1
1727: PPUSH
1728: LD_INT 0
1730: PPUSH
1731: CALL_OW 49
// tmp := tmp ^ un ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_VAR 0 4
1749: ADD
1750: ST_TO_ADDR
// end ;
1751: GO 1660
1753: POP
1754: POP
// for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
1755: LD_ADDR_VAR 0 3
1759: PUSH
1760: DOUBLE
1761: LD_INT 1
1763: DEC
1764: ST_TO_ADDR
1765: LD_INT 4
1767: PUSH
1768: LD_INT 5
1770: PUSH
1771: LD_INT 5
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: PUSH
1779: LD_OWVAR 67
1783: ARRAY
1784: PUSH
1785: FOR_TO
1786: IFFALSE 1878
// begin uc_nation := 0 ;
1788: LD_ADDR_OWVAR 21
1792: PUSH
1793: LD_INT 0
1795: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1796: LD_ADDR_OWVAR 28
1800: PUSH
1801: LD_INT 15
1803: ST_TO_ADDR
// hc_gallery :=  ;
1804: LD_ADDR_OWVAR 33
1808: PUSH
1809: LD_STRING 
1811: ST_TO_ADDR
// hc_name :=  ;
1812: LD_ADDR_OWVAR 26
1816: PUSH
1817: LD_STRING 
1819: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1820: LD_ADDR_OWVAR 29
1824: PUSH
1825: LD_INT 16
1827: PUSH
1828: LD_INT 12
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: ST_TO_ADDR
// un := CreateHuman ;
1835: LD_ADDR_VAR 0 4
1839: PUSH
1840: CALL_OW 44
1844: ST_TO_ADDR
// PlaceUnitArea ( un , east2_spawn , false ) ;
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 49
// tmp := tmp ^ un ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_VAR 0 4
1874: ADD
1875: ST_TO_ADDR
// end ;
1876: GO 1785
1878: POP
1879: POP
// end ; 2 :
1880: GO 2660
1882: LD_INT 2
1884: DOUBLE
1885: EQUAL
1886: IFTRUE 1890
1888: GO 2018
1890: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
1891: LD_ADDR_VAR 0 3
1895: PUSH
1896: DOUBLE
1897: LD_INT 1
1899: DEC
1900: ST_TO_ADDR
1901: LD_INT 3
1903: PUSH
1904: LD_INT 4
1906: PUSH
1907: LD_INT 5
1909: PUSH
1910: EMPTY
1911: LIST
1912: LIST
1913: LIST
1914: PUSH
1915: LD_OWVAR 67
1919: ARRAY
1920: PUSH
1921: FOR_TO
1922: IFFALSE 2014
// begin uc_nation := 0 ;
1924: LD_ADDR_OWVAR 21
1928: PUSH
1929: LD_INT 0
1931: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
1932: LD_ADDR_OWVAR 28
1936: PUSH
1937: LD_INT 17
1939: ST_TO_ADDR
// hc_gallery :=  ;
1940: LD_ADDR_OWVAR 33
1944: PUSH
1945: LD_STRING 
1947: ST_TO_ADDR
// hc_name :=  ;
1948: LD_ADDR_OWVAR 26
1952: PUSH
1953: LD_STRING 
1955: ST_TO_ADDR
// hc_attr := [ 22 , 12 ] ;
1956: LD_ADDR_OWVAR 29
1960: PUSH
1961: LD_INT 22
1963: PUSH
1964: LD_INT 12
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: ST_TO_ADDR
// un := CreateHuman ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: CALL_OW 44
1980: ST_TO_ADDR
// PlaceUnitArea ( un , west_spawn , false ) ;
1981: LD_VAR 0 4
1985: PPUSH
1986: LD_INT 3
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 49
// tmp := tmp ^ un ;
1996: LD_ADDR_VAR 0 5
2000: PUSH
2001: LD_VAR 0 5
2005: PUSH
2006: LD_VAR 0 4
2010: ADD
2011: ST_TO_ADDR
// end ;
2012: GO 1921
2014: POP
2015: POP
// end ; 3 :
2016: GO 2660
2018: LD_INT 3
2020: DOUBLE
2021: EQUAL
2022: IFTRUE 2026
2024: GO 2186
2026: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_INT 4
2039: PUSH
2040: LD_INT 5
2042: PUSH
2043: LD_INT 6
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PUSH
2051: LD_OWVAR 67
2055: ARRAY
2056: PUSH
2057: FOR_TO
2058: IFFALSE 2182
// begin uc_nation := 2 ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 2
2067: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2068: LD_ADDR_OWVAR 37
2072: PUSH
2073: LD_INT 14
2075: ST_TO_ADDR
// vc_engine := 3 ;
2076: LD_ADDR_OWVAR 39
2080: PUSH
2081: LD_INT 3
2083: ST_TO_ADDR
// vc_control := control_apeman ;
2084: LD_ADDR_OWVAR 38
2088: PUSH
2089: LD_INT 5
2091: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 27
2099: PUSH
2100: LD_INT 28
2102: PUSH
2103: LD_INT 29
2105: PUSH
2106: LD_INT 91
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PPUSH
2121: CALL_OW 12
2125: ARRAY
2126: ST_TO_ADDR
// un := CreateVehicle ;
2127: LD_ADDR_VAR 0 4
2131: PUSH
2132: CALL_OW 45
2136: ST_TO_ADDR
// tmp := tmp ^ un ;
2137: LD_ADDR_VAR 0 5
2141: PUSH
2142: LD_VAR 0 5
2146: PUSH
2147: LD_VAR 0 4
2151: ADD
2152: ST_TO_ADDR
// SetDir ( un , 0 ) ;
2153: LD_VAR 0 4
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 233
// PlaceUnitArea ( un , south_spawn , false ) ;
2165: LD_VAR 0 4
2169: PPUSH
2170: LD_INT 2
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: GO 2057
2182: POP
2183: POP
// end ; 4 :
2184: GO 2660
2186: LD_INT 4
2188: DOUBLE
2189: EQUAL
2190: IFTRUE 2194
2192: GO 2362
2194: POP
// begin for i = 1 to Rand ( 3 , [ 4 , 5 , 6 ] [ Difficulty ] ) do
2195: LD_ADDR_VAR 0 3
2199: PUSH
2200: DOUBLE
2201: LD_INT 1
2203: DEC
2204: ST_TO_ADDR
2205: LD_INT 3
2207: PPUSH
2208: LD_INT 4
2210: PUSH
2211: LD_INT 5
2213: PUSH
2214: LD_INT 6
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: CALL_OW 12
2232: PUSH
2233: FOR_TO
2234: IFFALSE 2358
// begin uc_nation := 2 ;
2236: LD_ADDR_OWVAR 21
2240: PUSH
2241: LD_INT 2
2243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 14
2251: ST_TO_ADDR
// vc_engine := 3 ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 3
2259: ST_TO_ADDR
// vc_control := control_apeman ;
2260: LD_ADDR_OWVAR 38
2264: PUSH
2265: LD_INT 5
2267: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2268: LD_ADDR_OWVAR 40
2272: PUSH
2273: LD_INT 27
2275: PUSH
2276: LD_INT 28
2278: PUSH
2279: LD_INT 29
2281: PUSH
2282: LD_INT 91
2284: PUSH
2285: EMPTY
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: PUSH
2291: LD_INT 1
2293: PPUSH
2294: LD_INT 4
2296: PPUSH
2297: CALL_OW 12
2301: ARRAY
2302: ST_TO_ADDR
// un := CreateVehicle ;
2303: LD_ADDR_VAR 0 4
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// tmp := tmp ^ un ;
2313: LD_ADDR_VAR 0 5
2317: PUSH
2318: LD_VAR 0 5
2322: PUSH
2323: LD_VAR 0 4
2327: ADD
2328: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2329: LD_VAR 0 4
2333: PPUSH
2334: LD_INT 3
2336: PPUSH
2337: CALL_OW 233
// PlaceUnitArea ( un , north_spawn , false ) ;
2341: LD_VAR 0 4
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_INT 0
2351: PPUSH
2352: CALL_OW 49
// end ;
2356: GO 2233
2358: POP
2359: POP
// end ; 5 :
2360: GO 2660
2362: LD_INT 5
2364: DOUBLE
2365: EQUAL
2366: IFTRUE 2370
2368: GO 2530
2370: POP
// begin for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: DOUBLE
2377: LD_INT 1
2379: DEC
2380: ST_TO_ADDR
2381: LD_INT 3
2383: PUSH
2384: LD_INT 4
2386: PUSH
2387: LD_INT 4
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: LD_OWVAR 67
2399: ARRAY
2400: PUSH
2401: FOR_TO
2402: IFFALSE 2526
// begin uc_nation := 2 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 2
2411: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2412: LD_ADDR_OWVAR 37
2416: PUSH
2417: LD_INT 14
2419: ST_TO_ADDR
// vc_engine := 3 ;
2420: LD_ADDR_OWVAR 39
2424: PUSH
2425: LD_INT 3
2427: ST_TO_ADDR
// vc_control := control_apeman ;
2428: LD_ADDR_OWVAR 38
2432: PUSH
2433: LD_INT 5
2435: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2436: LD_ADDR_OWVAR 40
2440: PUSH
2441: LD_INT 27
2443: PUSH
2444: LD_INT 28
2446: PUSH
2447: LD_INT 29
2449: PUSH
2450: LD_INT 91
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 1
2461: PPUSH
2462: LD_INT 4
2464: PPUSH
2465: CALL_OW 12
2469: ARRAY
2470: ST_TO_ADDR
// un := CreateVehicle ;
2471: LD_ADDR_VAR 0 4
2475: PUSH
2476: CALL_OW 45
2480: ST_TO_ADDR
// tmp := tmp ^ un ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_VAR 0 4
2495: ADD
2496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 4
2504: PPUSH
2505: CALL_OW 233
// PlaceUnitArea ( un , east2_spawn , false ) ;
2509: LD_VAR 0 4
2513: PPUSH
2514: LD_INT 5
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: CALL_OW 49
// end ;
2524: GO 2401
2526: POP
2527: POP
// end ; 6 :
2528: GO 2660
2530: LD_INT 6
2532: DOUBLE
2533: EQUAL
2534: IFTRUE 2538
2536: GO 2659
2538: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: DOUBLE
2545: LD_INT 1
2547: DEC
2548: ST_TO_ADDR
2549: LD_INT 2
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 4
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_OWVAR 67
2567: ARRAY
2568: PUSH
2569: FOR_TO
2570: IFFALSE 2655
// begin uc_nation := 2 ;
2572: LD_ADDR_OWVAR 21
2576: PUSH
2577: LD_INT 2
2579: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
2580: LD_ADDR_OWVAR 37
2584: PUSH
2585: LD_INT 11
2587: ST_TO_ADDR
// vc_engine := engine_combustion ;
2588: LD_ADDR_OWVAR 39
2592: PUSH
2593: LD_INT 1
2595: ST_TO_ADDR
// vc_control := control_apeman ;
2596: LD_ADDR_OWVAR 38
2600: PUSH
2601: LD_INT 5
2603: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
2604: LD_ADDR_OWVAR 40
2608: PUSH
2609: LD_INT 24
2611: ST_TO_ADDR
// un := CreateVehicle ;
2612: LD_ADDR_VAR 0 4
2616: PUSH
2617: CALL_OW 45
2621: ST_TO_ADDR
// tmp := tmp ^ un ;
2622: LD_ADDR_VAR 0 5
2626: PUSH
2627: LD_VAR 0 5
2631: PUSH
2632: LD_VAR 0 4
2636: ADD
2637: ST_TO_ADDR
// PlaceUnitArea ( un , river , false ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_INT 8
2645: PPUSH
2646: LD_INT 0
2648: PPUSH
2649: CALL_OW 49
// end ;
2653: GO 2569
2655: POP
2656: POP
// end ; end ;
2657: GO 2660
2659: POP
// result := tmp ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 5
2669: ST_TO_ADDR
// end ;
2670: LD_VAR 0 2
2674: RET
// export function ComitSib ; var un ; begin
2675: LD_INT 0
2677: PPUSH
2678: PPUSH
// uc_side := 2 ;
2679: LD_ADDR_OWVAR 20
2683: PUSH
2684: LD_INT 2
2686: ST_TO_ADDR
// uc_nation := 2 ;
2687: LD_ADDR_OWVAR 21
2691: PUSH
2692: LD_INT 2
2694: ST_TO_ADDR
// PrepareHuman ( false , 4 , 7 ) ;
2695: LD_INT 0
2697: PPUSH
2698: LD_INT 4
2700: PPUSH
2701: LD_INT 7
2703: PPUSH
2704: CALL_OW 380
// un := CreateHuman ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: CALL_OW 44
2717: ST_TO_ADDR
// PlaceUnitArea ( un , east1_spawn , false ) ;
2718: LD_VAR 0 2
2722: PPUSH
2723: LD_INT 4
2725: PPUSH
2726: LD_INT 0
2728: PPUSH
2729: CALL_OW 49
// ComContaminate ( un , 63 , 37 ) ;
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 63
2740: PPUSH
2741: LD_INT 37
2743: PPUSH
2744: CALL_OW 158
// end ;
2748: LD_VAR 0 1
2752: RET
// export function DSay ; var i ; begin
2753: LD_INT 0
2755: PPUSH
2756: PPUSH
// Randomize ;
2757: CALL_OW 10
// i := Rand ( 1 , 8 ) ;
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: LD_INT 1
2768: PPUSH
2769: LD_INT 8
2771: PPUSH
2772: CALL_OW 12
2776: ST_TO_ADDR
// case i of 1 :
2777: LD_VAR 0 2
2781: PUSH
2782: LD_INT 1
2784: DOUBLE
2785: EQUAL
2786: IFTRUE 2790
2788: GO 2805
2790: POP
// SayRadio ( doc , DDocA1 ) ; 2 :
2791: LD_EXP 2
2795: PPUSH
2796: LD_STRING DDocA1
2798: PPUSH
2799: CALL_OW 94
2803: GO 2967
2805: LD_INT 2
2807: DOUBLE
2808: EQUAL
2809: IFTRUE 2813
2811: GO 2828
2813: POP
// SayRadio ( doc , DDocA2 ) ; 3 :
2814: LD_EXP 2
2818: PPUSH
2819: LD_STRING DDocA2
2821: PPUSH
2822: CALL_OW 94
2826: GO 2967
2828: LD_INT 3
2830: DOUBLE
2831: EQUAL
2832: IFTRUE 2836
2834: GO 2851
2836: POP
// SayRadio ( doc , DDocA3 ) ; 4 :
2837: LD_EXP 2
2841: PPUSH
2842: LD_STRING DDocA3
2844: PPUSH
2845: CALL_OW 94
2849: GO 2967
2851: LD_INT 4
2853: DOUBLE
2854: EQUAL
2855: IFTRUE 2859
2857: GO 2874
2859: POP
// SayRadio ( doc , DDocA4 ) ; 5 :
2860: LD_EXP 2
2864: PPUSH
2865: LD_STRING DDocA4
2867: PPUSH
2868: CALL_OW 94
2872: GO 2967
2874: LD_INT 5
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2897
2882: POP
// SayRadio ( doc , DDocA5 ) ; 6 :
2883: LD_EXP 2
2887: PPUSH
2888: LD_STRING DDocA5
2890: PPUSH
2891: CALL_OW 94
2895: GO 2967
2897: LD_INT 6
2899: DOUBLE
2900: EQUAL
2901: IFTRUE 2905
2903: GO 2920
2905: POP
// SayRadio ( doc , DDocA6 ) ; 7 :
2906: LD_EXP 2
2910: PPUSH
2911: LD_STRING DDocA6
2913: PPUSH
2914: CALL_OW 94
2918: GO 2967
2920: LD_INT 7
2922: DOUBLE
2923: EQUAL
2924: IFTRUE 2928
2926: GO 2943
2928: POP
// SayRadio ( doc , DDocA7 ) ; 8 :
2929: LD_EXP 2
2933: PPUSH
2934: LD_STRING DDocA7
2936: PPUSH
2937: CALL_OW 94
2941: GO 2967
2943: LD_INT 8
2945: DOUBLE
2946: EQUAL
2947: IFTRUE 2951
2949: GO 2966
2951: POP
// SayRadio ( doc , DDocA8 ) ; end ;
2952: LD_EXP 2
2956: PPUSH
2957: LD_STRING DDocA8
2959: PPUSH
2960: CALL_OW 94
2964: GO 2967
2966: POP
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// every 0 0$01 do
2972: GO 2974
2974: DISABLE
// begin display_strings := [ #tick , tick ] ;
2975: LD_ADDR_OWVAR 47
2979: PUSH
2980: LD_STRING #tick
2982: PUSH
2983: LD_OWVAR 1
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: ST_TO_ADDR
// enable ;
2992: ENABLE
// end ;
2993: END
// export pom , hover , attackN ; every 1 do
2994: GO 2996
2996: DISABLE
// begin pom := [ ] ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: EMPTY
3003: ST_TO_ADDR
// hover := [ ] ;
3004: LD_ADDR_EXP 5
3008: PUSH
3009: EMPTY
3010: ST_TO_ADDR
// attackN := 0 ;
3011: LD_ADDR_EXP 6
3015: PUSH
3016: LD_INT 0
3018: ST_TO_ADDR
// end ;
3019: END
// every 0 0$01 trigger pom do var i , f , z , target ;
3020: LD_EXP 4
3024: IFFALSE 3446
3026: GO 3028
3028: DISABLE
3029: LD_INT 0
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
// begin enable ;
3035: ENABLE
// f := FilterAllUnits ( [ f_side , 7 ] ) ;
3036: LD_ADDR_VAR 0 2
3040: PUSH
3041: LD_INT 22
3043: PUSH
3044: LD_INT 7
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: PPUSH
3051: CALL_OW 69
3055: ST_TO_ADDR
// for i = 1 to pom do
3056: LD_ADDR_VAR 0 1
3060: PUSH
3061: DOUBLE
3062: LD_INT 1
3064: DEC
3065: ST_TO_ADDR
3066: LD_EXP 4
3070: PUSH
3071: FOR_TO
3072: IFFALSE 3130
// if not HasTask ( pom [ i ] ) then
3074: LD_EXP 4
3078: PUSH
3079: LD_VAR 0 1
3083: ARRAY
3084: PPUSH
3085: CALL_OW 314
3089: NOT
3090: IFFALSE 3128
// ComAttackUnit ( pom [ i ] , NearestUnitToUnit ( f , pom [ i ] ) ) ;
3092: LD_EXP 4
3096: PUSH
3097: LD_VAR 0 1
3101: ARRAY
3102: PPUSH
3103: LD_VAR 0 2
3107: PPUSH
3108: LD_EXP 4
3112: PUSH
3113: LD_VAR 0 1
3117: ARRAY
3118: PPUSH
3119: CALL_OW 74
3123: PPUSH
3124: CALL_OW 115
3128: GO 3071
3130: POP
3131: POP
// if hover then
3132: LD_EXP 5
3136: IFFALSE 3446
// begin for i = 1 to hover do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 5
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3444
// begin if GetLives ( hover [ i ] ) < 250 then
3156: LD_EXP 5
3160: PUSH
3161: LD_VAR 0 1
3165: ARRAY
3166: PPUSH
3167: CALL_OW 256
3171: PUSH
3172: LD_INT 250
3174: LESS
3175: IFFALSE 3242
// begin for z = 1 to 1 + Difficulty do
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: DOUBLE
3183: LD_INT 1
3185: DEC
3186: ST_TO_ADDR
3187: LD_INT 1
3189: PUSH
3190: LD_OWVAR 67
3194: PLUS
3195: PUSH
3196: FOR_TO
3197: IFFALSE 3240
// MineExplosion ( GetX ( hover [ i ] ) , GetY ( hover [ i ] ) , 10 ) ;
3199: LD_EXP 5
3203: PUSH
3204: LD_VAR 0 1
3208: ARRAY
3209: PPUSH
3210: CALL_OW 250
3214: PPUSH
3215: LD_EXP 5
3219: PUSH
3220: LD_VAR 0 1
3224: ARRAY
3225: PPUSH
3226: CALL_OW 251
3230: PPUSH
3231: LD_INT 10
3233: PPUSH
3234: CALL_OW 453
3238: GO 3196
3240: POP
3241: POP
// end ; if UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) > 0 then
3242: LD_VAR 0 2
3246: PPUSH
3247: LD_INT 25
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: LD_INT 54
3262: PUSH
3263: EMPTY
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PPUSH
3274: CALL_OW 72
3278: PUSH
3279: LD_INT 0
3281: GREATER
3282: IFFALSE 3364
// begin target := UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) ;
3284: LD_ADDR_VAR 0 4
3288: PUSH
3289: LD_VAR 0 2
3293: PPUSH
3294: LD_INT 25
3296: PUSH
3297: LD_INT 2
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PUSH
3304: LD_INT 3
3306: PUSH
3307: LD_INT 54
3309: PUSH
3310: EMPTY
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 72
3325: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3326: LD_EXP 5
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PPUSH
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_EXP 5
3346: PUSH
3347: LD_VAR 0 1
3351: ARRAY
3352: PPUSH
3353: CALL_OW 74
3357: PPUSH
3358: CALL_OW 115
// end else
3362: GO 3442
// begin target := UnitFilter ( f , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) ;
3364: LD_ADDR_VAR 0 4
3368: PUSH
3369: LD_VAR 0 2
3373: PPUSH
3374: LD_INT 21
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 3
3386: PUSH
3387: LD_INT 54
3389: PUSH
3390: EMPTY
3391: LIST
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PPUSH
3401: CALL_OW 72
3405: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3406: LD_EXP 5
3410: PUSH
3411: LD_VAR 0 1
3415: ARRAY
3416: PPUSH
3417: LD_VAR 0 4
3421: PPUSH
3422: LD_EXP 5
3426: PUSH
3427: LD_VAR 0 1
3431: ARRAY
3432: PPUSH
3433: CALL_OW 74
3437: PPUSH
3438: CALL_OW 115
// end ; end ;
3442: GO 3153
3444: POP
3445: POP
// end ; end ;
3446: PPOPN 4
3448: END
// every 3 3$10 do var i , un ;
3449: GO 3451
3451: DISABLE
3452: LD_INT 0
3454: PPUSH
3455: PPUSH
// begin uc_side := 7 ;
3456: LD_ADDR_OWVAR 20
3460: PUSH
3461: LD_INT 7
3463: ST_TO_ADDR
// uc_nation := 1 ;
3464: LD_ADDR_OWVAR 21
3468: PUSH
3469: LD_INT 1
3471: ST_TO_ADDR
// for i = 1 to 2 do
3472: LD_ADDR_VAR 0 1
3476: PUSH
3477: DOUBLE
3478: LD_INT 1
3480: DEC
3481: ST_TO_ADDR
3482: LD_INT 2
3484: PUSH
3485: FOR_TO
3486: IFFALSE 3651
// begin PrepareHuman ( sex_male , class_sniper , [ 7 , 6 , 6 ] [ Difficulty ] ) ;
3488: LD_INT 1
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: LD_INT 7
3496: PUSH
3497: LD_INT 6
3499: PUSH
3500: LD_INT 6
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_OWVAR 67
3512: ARRAY
3513: PPUSH
3514: CALL_OW 380
// vc_chassis := us_light_wheeled ;
3518: LD_ADDR_OWVAR 37
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// vc_engine := engine_combustion ;
3526: LD_ADDR_OWVAR 39
3530: PUSH
3531: LD_INT 1
3533: ST_TO_ADDR
// vc_control := control_manual ;
3534: LD_ADDR_OWVAR 38
3538: PUSH
3539: LD_INT 1
3541: ST_TO_ADDR
// vc_fuel_battery := 66 ;
3542: LD_ADDR_OWVAR 41
3546: PUSH
3547: LD_INT 66
3549: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
3550: LD_ADDR_OWVAR 40
3554: PUSH
3555: LD_INT 2
3557: ST_TO_ADDR
// un := CreateVehicle ;
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: CALL_OW 45
3567: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3568: LD_VAR 0 2
3572: PPUSH
3573: LD_INT 3
3575: PPUSH
3576: CALL_OW 233
// PlaceUnitXY ( un , 48 , 3 , false ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_INT 48
3587: PPUSH
3588: LD_INT 3
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , un ) ;
3598: CALL_OW 44
3602: PPUSH
3603: LD_VAR 0 2
3607: PPUSH
3608: CALL_OW 52
// ComMoveXY ( un , 49 , 17 ) ;
3612: LD_VAR 0 2
3616: PPUSH
3617: LD_INT 49
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: CALL_OW 111
// AddComMoveXY ( un , 48 , 36 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_INT 48
3634: PPUSH
3635: LD_INT 36
3637: PPUSH
3638: CALL_OW 171
// Wait ( 0 0$02 ) ;
3642: LD_INT 70
3644: PPUSH
3645: CALL_OW 67
// end ;
3649: GO 3485
3651: POP
3652: POP
// end ;
3653: PPOPN 2
3655: END
// every 5 5$00 + 3 3$00 trigger attackN < [ 10 , 12 , 14 ] [ Difficulty ] do var c , l ;
3656: LD_EXP 6
3660: PUSH
3661: LD_INT 10
3663: PUSH
3664: LD_INT 12
3666: PUSH
3667: LD_INT 14
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_OWVAR 67
3679: ARRAY
3680: LESS
3681: IFFALSE 4383
3683: GO 3685
3685: DISABLE
3686: LD_INT 0
3688: PPUSH
3689: PPUSH
// begin enable ;
3690: ENABLE
// Randomize ;
3691: CALL_OW 10
// Wait ( Rand ( 0 0$01 , 2 2$59 ) ) ;
3695: LD_INT 35
3697: PPUSH
3698: LD_INT 6265
3700: PPUSH
3701: CALL_OW 12
3705: PPUSH
3706: CALL_OW 67
// if attackN < [ 4 , 4 , 5 ] [ Difficulty ] then
3710: LD_EXP 6
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 4
3720: PUSH
3721: LD_INT 5
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PUSH
3729: LD_OWVAR 67
3733: ARRAY
3734: LESS
3735: IFFALSE 3755
// c := Rand ( 1 , 2 ) else
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PPUSH
3745: LD_INT 2
3747: PPUSH
3748: CALL_OW 12
3752: ST_TO_ADDR
3753: GO 3771
// c := Rand ( 1 , 3 ) ;
3755: LD_ADDR_VAR 0 1
3759: PUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 3
3765: PPUSH
3766: CALL_OW 12
3770: ST_TO_ADDR
// if attackN = 0 then
3771: LD_EXP 6
3775: PUSH
3776: LD_INT 0
3778: EQUAL
3779: IFFALSE 3795
// Say ( com , DJackAttack ) else
3781: LD_EXP 1
3785: PPUSH
3786: LD_STRING DJackAttack
3788: PPUSH
3789: CALL_OW 88
3793: GO 3799
// DSay ;
3795: CALL 2753 0 0
// case c of 1 :
3799: LD_VAR 0 1
3803: PUSH
3804: LD_INT 1
3806: DOUBLE
3807: EQUAL
3808: IFTRUE 3812
3810: GO 3994
3812: POP
// begin pom := pom ^ Attack ( 1 ) ;
3813: LD_ADDR_EXP 4
3817: PUSH
3818: LD_EXP 4
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: CALL 1264 0 1
3830: ADD
3831: ST_TO_ADDR
// Wait ( 0 0$12 ) ;
3832: LD_INT 420
3834: PPUSH
3835: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3839: LD_ADDR_EXP 4
3843: PUSH
3844: LD_EXP 4
3848: PUSH
3849: LD_INT 3
3851: PPUSH
3852: CALL 1264 0 1
3856: ADD
3857: ST_TO_ADDR
// if Difficulty > 2 then
3858: LD_OWVAR 67
3862: PUSH
3863: LD_INT 2
3865: GREATER
3866: IFFALSE 3894
// begin Wait ( 0 0$46 ) ;
3868: LD_INT 1610
3870: PPUSH
3871: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
3875: LD_ADDR_EXP 4
3879: PUSH
3880: LD_EXP 4
3884: PUSH
3885: LD_INT 4
3887: PPUSH
3888: CALL 1264 0 1
3892: ADD
3893: ST_TO_ADDR
// end ; if attackN > 4 then
3894: LD_EXP 6
3898: PUSH
3899: LD_INT 4
3901: GREATER
3902: IFFALSE 3930
// begin Wait ( 0 0$12 ) ;
3904: LD_INT 420
3906: PPUSH
3907: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3911: LD_ADDR_EXP 4
3915: PUSH
3916: LD_EXP 4
3920: PUSH
3921: LD_INT 3
3923: PPUSH
3924: CALL 1264 0 1
3928: ADD
3929: ST_TO_ADDR
// end ; if attackN > 8 then
3930: LD_EXP 6
3934: PUSH
3935: LD_INT 8
3937: GREATER
3938: IFFALSE 3992
// begin Wait ( 0 0$12 ) ;
3940: LD_INT 420
3942: PPUSH
3943: CALL_OW 67
// l := Rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// if l < 45 then
3963: LD_VAR 0 2
3967: PUSH
3968: LD_INT 45
3970: LESS
3971: IFFALSE 3992
// pom := pom ^ Attack ( 2 ) ;
3973: LD_ADDR_EXP 4
3977: PUSH
3978: LD_EXP 4
3982: PUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL 1264 0 1
3990: ADD
3991: ST_TO_ADDR
// end ; end ; 2 :
3992: GO 4281
3994: LD_INT 2
3996: DOUBLE
3997: EQUAL
3998: IFTRUE 4002
4000: GO 4150
4002: POP
// begin pom := pom ^ Attack ( 2 ) ;
4003: LD_ADDR_EXP 4
4007: PUSH
4008: LD_EXP 4
4012: PUSH
4013: LD_INT 2
4015: PPUSH
4016: CALL 1264 0 1
4020: ADD
4021: ST_TO_ADDR
// pom := pom ^ Attack ( 3 ) ;
4022: LD_ADDR_EXP 4
4026: PUSH
4027: LD_EXP 4
4031: PUSH
4032: LD_INT 3
4034: PPUSH
4035: CALL 1264 0 1
4039: ADD
4040: ST_TO_ADDR
// if Difficulty > 1 and GetBType ( HexInfo ( 63 , 37 ) ) = b_siberite_mine then
4041: LD_OWVAR 67
4045: PUSH
4046: LD_INT 1
4048: GREATER
4049: PUSH
4050: LD_INT 63
4052: PPUSH
4053: LD_INT 37
4055: PPUSH
4056: CALL_OW 428
4060: PPUSH
4061: CALL_OW 266
4065: PUSH
4066: LD_INT 30
4068: EQUAL
4069: AND
4070: IFFALSE 4076
// ComitSib ;
4072: CALL 2675 0 0
// if Difficulty > 2 then
4076: LD_OWVAR 67
4080: PUSH
4081: LD_INT 2
4083: GREATER
4084: IFFALSE 4112
// begin Wait ( 0 0$25 ) ;
4086: LD_INT 875
4088: PPUSH
4089: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
4093: LD_ADDR_EXP 4
4097: PUSH
4098: LD_EXP 4
4102: PUSH
4103: LD_INT 4
4105: PPUSH
4106: CALL 1264 0 1
4110: ADD
4111: ST_TO_ADDR
// end ; if attackN > 7 then
4112: LD_EXP 6
4116: PUSH
4117: LD_INT 7
4119: GREATER
4120: IFFALSE 4148
// begin Wait ( 0 0$15 ) ;
4122: LD_INT 525
4124: PPUSH
4125: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4129: LD_ADDR_EXP 4
4133: PUSH
4134: LD_EXP 4
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: CALL 1264 0 1
4146: ADD
4147: ST_TO_ADDR
// end ; end ; 3 :
4148: GO 4281
4150: LD_INT 3
4152: DOUBLE
4153: EQUAL
4154: IFTRUE 4158
4156: GO 4280
4158: POP
// begin pom := pom ^ Attack ( 1 ) ;
4159: LD_ADDR_EXP 4
4163: PUSH
4164: LD_EXP 4
4168: PUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL 1264 0 1
4176: ADD
4177: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
4178: LD_INT 70
4180: PPUSH
4181: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4185: LD_ADDR_EXP 4
4189: PUSH
4190: LD_EXP 4
4194: PUSH
4195: LD_INT 2
4197: PPUSH
4198: CALL 1264 0 1
4202: ADD
4203: ST_TO_ADDR
// Wait ( 1 1$00 ) ;
4204: LD_INT 2100
4206: PPUSH
4207: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4211: LD_ADDR_EXP 4
4215: PUSH
4216: LD_EXP 4
4220: PUSH
4221: LD_INT 3
4223: PPUSH
4224: CALL 1264 0 1
4228: ADD
4229: ST_TO_ADDR
// pom := pom ^ Attack ( 5 ) ;
4230: LD_ADDR_EXP 4
4234: PUSH
4235: LD_EXP 4
4239: PUSH
4240: LD_INT 5
4242: PPUSH
4243: CALL 1264 0 1
4247: ADD
4248: ST_TO_ADDR
// if attackN > 10 then
4249: LD_EXP 6
4253: PUSH
4254: LD_INT 10
4256: GREATER
4257: IFFALSE 4278
// pom := pom ^ Attack ( 2 ) ;
4259: LD_ADDR_EXP 4
4263: PUSH
4264: LD_EXP 4
4268: PUSH
4269: LD_INT 2
4271: PPUSH
4272: CALL 1264 0 1
4276: ADD
4277: ST_TO_ADDR
// end ; end ;
4278: GO 4281
4280: POP
// if Difficulty > 1 and attackN mod 4 = 0 then
4281: LD_OWVAR 67
4285: PUSH
4286: LD_INT 1
4288: GREATER
4289: PUSH
4290: LD_EXP 6
4294: PUSH
4295: LD_INT 4
4297: MOD
4298: PUSH
4299: LD_INT 0
4301: EQUAL
4302: AND
4303: IFFALSE 4369
// begin Wait ( 1 1$45 ) ;
4305: LD_INT 3675
4307: PPUSH
4308: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4312: LD_ADDR_EXP 4
4316: PUSH
4317: LD_EXP 4
4321: PUSH
4322: LD_INT 3
4324: PPUSH
4325: CALL 1264 0 1
4329: ADD
4330: ST_TO_ADDR
// pom := pom ^ Attack ( 4 ) ;
4331: LD_ADDR_EXP 4
4335: PUSH
4336: LD_EXP 4
4340: PUSH
4341: LD_INT 4
4343: PPUSH
4344: CALL 1264 0 1
4348: ADD
4349: ST_TO_ADDR
// hover := hover ^ Attack ( 6 ) ;
4350: LD_ADDR_EXP 5
4354: PUSH
4355: LD_EXP 5
4359: PUSH
4360: LD_INT 6
4362: PPUSH
4363: CALL 1264 0 1
4367: ADD
4368: ST_TO_ADDR
// end ; attackN := attackN + 1 ;
4369: LD_ADDR_EXP 6
4373: PUSH
4374: LD_EXP 6
4378: PUSH
4379: LD_INT 1
4381: PLUS
4382: ST_TO_ADDR
// end ;
4383: PPOPN 2
4385: END
// every 0 0$10 trigger attackN >= [ 10 , 12 , 14 ] [ Difficulty ] and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
4386: LD_EXP 6
4390: PUSH
4391: LD_INT 10
4393: PUSH
4394: LD_INT 12
4396: PUSH
4397: LD_INT 14
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PUSH
4405: LD_OWVAR 67
4409: ARRAY
4410: GREATEREQUAL
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PPUSH
4422: CALL_OW 69
4426: PUSH
4427: LD_INT 0
4429: EQUAL
4430: AND
4431: IFFALSE 4487
4433: GO 4435
4435: DISABLE
// begin SayRadio ( doc , DDocEnd ) ;
4436: LD_EXP 2
4440: PPUSH
4441: LD_STRING DDocEnd
4443: PPUSH
4444: CALL_OW 94
// Wait ( 0 0$03 ) ;
4448: LD_INT 105
4450: PPUSH
4451: CALL_OW 67
// case Query ( QWin ) of 1 :
4455: LD_STRING QWin
4457: PPUSH
4458: CALL_OW 97
4462: PUSH
4463: LD_INT 1
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4474
4471: POP
// ; end ;
4472: GO 4475
4474: POP
// music_nat := 5 ;
4475: LD_ADDR_OWVAR 71
4479: PUSH
4480: LD_INT 5
4482: ST_TO_ADDR
// YouWin ;
4483: CALL_OW 103
// end ; end_of_file
4487: END
// on UnitDestroyed ( un ) do begin if un = brave or un = com then
4488: LD_VAR 0 1
4492: PUSH
4493: LD_INT 1
4495: EQUAL
4496: PUSH
4497: LD_VAR 0 1
4501: PUSH
4502: LD_EXP 1
4506: EQUAL
4507: OR
4508: IFFALSE 4529
// begin SayRadio ( doc , DDocWin ) ;
4510: LD_EXP 2
4514: PPUSH
4515: LD_STRING DDocWin
4517: PPUSH
4518: CALL_OW 94
// YouLost (  ) ;
4522: LD_STRING 
4524: PPUSH
4525: CALL_OW 104
// end ; end ;
4529: PPOPN 1
4531: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4532: LD_VAR 0 1
4536: PPUSH
4537: LD_VAR 0 2
4541: PPUSH
4542: LD_VAR 0 3
4546: PPUSH
4547: CALL 8125 0 3
// end ;
4551: PPOPN 3
4553: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4554: LD_VAR 0 1
4558: PPUSH
4559: CALL 8223 0 1
// end ; end_of_file
4563: PPOPN 1
4565: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4566: GO 4568
4568: DISABLE
// begin ru_radar := 98 ;
4569: LD_ADDR_EXP 7
4573: PUSH
4574: LD_INT 98
4576: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4577: LD_ADDR_EXP 8
4581: PUSH
4582: LD_INT 89
4584: ST_TO_ADDR
// us_hack := 99 ;
4585: LD_ADDR_EXP 9
4589: PUSH
4590: LD_INT 99
4592: ST_TO_ADDR
// us_artillery := 97 ;
4593: LD_ADDR_EXP 10
4597: PUSH
4598: LD_INT 97
4600: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4601: LD_ADDR_EXP 11
4605: PUSH
4606: LD_INT 91
4608: ST_TO_ADDR
// end ; end_of_file end_of_file
4609: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
4610: GO 4612
4612: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4613: LD_STRING initStreamRollete();
4615: PPUSH
4616: CALL_OW 559
// InitStreamMode ;
4620: CALL 4625 0 0
// end ;
4624: END
// function InitStreamMode ; begin
4625: LD_INT 0
4627: PPUSH
// streamModeActive := false ;
4628: LD_ADDR_EXP 12
4632: PUSH
4633: LD_INT 0
4635: ST_TO_ADDR
// sRocket := false ;
4636: LD_ADDR_EXP 15
4640: PUSH
4641: LD_INT 0
4643: ST_TO_ADDR
// sSpeed := false ;
4644: LD_ADDR_EXP 14
4648: PUSH
4649: LD_INT 0
4651: ST_TO_ADDR
// sEngine := false ;
4652: LD_ADDR_EXP 16
4656: PUSH
4657: LD_INT 0
4659: ST_TO_ADDR
// sSpec := false ;
4660: LD_ADDR_EXP 13
4664: PUSH
4665: LD_INT 0
4667: ST_TO_ADDR
// sLevel := false ;
4668: LD_ADDR_EXP 17
4672: PUSH
4673: LD_INT 0
4675: ST_TO_ADDR
// sArmoury := false ;
4676: LD_ADDR_EXP 18
4680: PUSH
4681: LD_INT 0
4683: ST_TO_ADDR
// sRadar := false ;
4684: LD_ADDR_EXP 19
4688: PUSH
4689: LD_INT 0
4691: ST_TO_ADDR
// sBunker := false ;
4692: LD_ADDR_EXP 20
4696: PUSH
4697: LD_INT 0
4699: ST_TO_ADDR
// sHack := false ;
4700: LD_ADDR_EXP 21
4704: PUSH
4705: LD_INT 0
4707: ST_TO_ADDR
// sFire := false ;
4708: LD_ADDR_EXP 22
4712: PUSH
4713: LD_INT 0
4715: ST_TO_ADDR
// sRefresh := false ;
4716: LD_ADDR_EXP 23
4720: PUSH
4721: LD_INT 0
4723: ST_TO_ADDR
// sExp := false ;
4724: LD_ADDR_EXP 24
4728: PUSH
4729: LD_INT 0
4731: ST_TO_ADDR
// sDepot := false ;
4732: LD_ADDR_EXP 25
4736: PUSH
4737: LD_INT 0
4739: ST_TO_ADDR
// sFlag := false ;
4740: LD_ADDR_EXP 26
4744: PUSH
4745: LD_INT 0
4747: ST_TO_ADDR
// sKamikadze := false ;
4748: LD_ADDR_EXP 34
4752: PUSH
4753: LD_INT 0
4755: ST_TO_ADDR
// sTroll := false ;
4756: LD_ADDR_EXP 35
4760: PUSH
4761: LD_INT 0
4763: ST_TO_ADDR
// sSlow := false ;
4764: LD_ADDR_EXP 36
4768: PUSH
4769: LD_INT 0
4771: ST_TO_ADDR
// sLack := false ;
4772: LD_ADDR_EXP 37
4776: PUSH
4777: LD_INT 0
4779: ST_TO_ADDR
// sTank := false ;
4780: LD_ADDR_EXP 39
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// sRemote := false ;
4788: LD_ADDR_EXP 40
4792: PUSH
4793: LD_INT 0
4795: ST_TO_ADDR
// sSold := false ;
4796: LD_ADDR_EXP 27
4800: PUSH
4801: LD_INT 0
4803: ST_TO_ADDR
// sDiff := false ;
4804: LD_ADDR_EXP 28
4808: PUSH
4809: LD_INT 0
4811: ST_TO_ADDR
// sFog := false ;
4812: LD_ADDR_EXP 31
4816: PUSH
4817: LD_INT 0
4819: ST_TO_ADDR
// sReset := false ;
4820: LD_ADDR_EXP 32
4824: PUSH
4825: LD_INT 0
4827: ST_TO_ADDR
// sSun := false ;
4828: LD_ADDR_EXP 33
4832: PUSH
4833: LD_INT 0
4835: ST_TO_ADDR
// sTiger := false ;
4836: LD_ADDR_EXP 29
4840: PUSH
4841: LD_INT 0
4843: ST_TO_ADDR
// sBomb := false ;
4844: LD_ADDR_EXP 30
4848: PUSH
4849: LD_INT 0
4851: ST_TO_ADDR
// sWound := false ;
4852: LD_ADDR_EXP 38
4856: PUSH
4857: LD_INT 0
4859: ST_TO_ADDR
// end ;
4860: LD_VAR 0 1
4864: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
4865: LD_VAR 0 2
4869: PUSH
4870: LD_INT 100
4872: EQUAL
4873: IFFALSE 5408
// begin if not StreamModeActive then
4875: LD_EXP 12
4879: NOT
4880: IFFALSE 4890
// StreamModeActive := true ;
4882: LD_ADDR_EXP 12
4886: PUSH
4887: LD_INT 1
4889: ST_TO_ADDR
// if p3 = 0 then
4890: LD_VAR 0 3
4894: PUSH
4895: LD_INT 0
4897: EQUAL
4898: IFFALSE 4904
// InitStreamMode ;
4900: CALL 4625 0 0
// if p3 = 1 then
4904: LD_VAR 0 3
4908: PUSH
4909: LD_INT 1
4911: EQUAL
4912: IFFALSE 4922
// sRocket := true ;
4914: LD_ADDR_EXP 15
4918: PUSH
4919: LD_INT 1
4921: ST_TO_ADDR
// if p3 = 2 then
4922: LD_VAR 0 3
4926: PUSH
4927: LD_INT 2
4929: EQUAL
4930: IFFALSE 4940
// sSpeed := true ;
4932: LD_ADDR_EXP 14
4936: PUSH
4937: LD_INT 1
4939: ST_TO_ADDR
// if p3 = 3 then
4940: LD_VAR 0 3
4944: PUSH
4945: LD_INT 3
4947: EQUAL
4948: IFFALSE 4958
// sEngine := true ;
4950: LD_ADDR_EXP 16
4954: PUSH
4955: LD_INT 1
4957: ST_TO_ADDR
// if p3 = 4 then
4958: LD_VAR 0 3
4962: PUSH
4963: LD_INT 4
4965: EQUAL
4966: IFFALSE 4976
// sSpec := true ;
4968: LD_ADDR_EXP 13
4972: PUSH
4973: LD_INT 1
4975: ST_TO_ADDR
// if p3 = 5 then
4976: LD_VAR 0 3
4980: PUSH
4981: LD_INT 5
4983: EQUAL
4984: IFFALSE 4994
// sLevel := true ;
4986: LD_ADDR_EXP 17
4990: PUSH
4991: LD_INT 1
4993: ST_TO_ADDR
// if p3 = 6 then
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 6
5001: EQUAL
5002: IFFALSE 5012
// sArmoury := true ;
5004: LD_ADDR_EXP 18
5008: PUSH
5009: LD_INT 1
5011: ST_TO_ADDR
// if p3 = 7 then
5012: LD_VAR 0 3
5016: PUSH
5017: LD_INT 7
5019: EQUAL
5020: IFFALSE 5030
// sRadar := true ;
5022: LD_ADDR_EXP 19
5026: PUSH
5027: LD_INT 1
5029: ST_TO_ADDR
// if p3 = 8 then
5030: LD_VAR 0 3
5034: PUSH
5035: LD_INT 8
5037: EQUAL
5038: IFFALSE 5048
// sBunker := true ;
5040: LD_ADDR_EXP 20
5044: PUSH
5045: LD_INT 1
5047: ST_TO_ADDR
// if p3 = 9 then
5048: LD_VAR 0 3
5052: PUSH
5053: LD_INT 9
5055: EQUAL
5056: IFFALSE 5066
// sHack := true ;
5058: LD_ADDR_EXP 21
5062: PUSH
5063: LD_INT 1
5065: ST_TO_ADDR
// if p3 = 10 then
5066: LD_VAR 0 3
5070: PUSH
5071: LD_INT 10
5073: EQUAL
5074: IFFALSE 5084
// sFire := true ;
5076: LD_ADDR_EXP 22
5080: PUSH
5081: LD_INT 1
5083: ST_TO_ADDR
// if p3 = 11 then
5084: LD_VAR 0 3
5088: PUSH
5089: LD_INT 11
5091: EQUAL
5092: IFFALSE 5102
// sRefresh := true ;
5094: LD_ADDR_EXP 23
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// if p3 = 12 then
5102: LD_VAR 0 3
5106: PUSH
5107: LD_INT 12
5109: EQUAL
5110: IFFALSE 5120
// sExp := true ;
5112: LD_ADDR_EXP 24
5116: PUSH
5117: LD_INT 1
5119: ST_TO_ADDR
// if p3 = 13 then
5120: LD_VAR 0 3
5124: PUSH
5125: LD_INT 13
5127: EQUAL
5128: IFFALSE 5138
// sDepot := true ;
5130: LD_ADDR_EXP 25
5134: PUSH
5135: LD_INT 1
5137: ST_TO_ADDR
// if p3 = 14 then
5138: LD_VAR 0 3
5142: PUSH
5143: LD_INT 14
5145: EQUAL
5146: IFFALSE 5156
// sFlag := true ;
5148: LD_ADDR_EXP 26
5152: PUSH
5153: LD_INT 1
5155: ST_TO_ADDR
// if p3 = 15 then
5156: LD_VAR 0 3
5160: PUSH
5161: LD_INT 15
5163: EQUAL
5164: IFFALSE 5174
// sKamikadze := true ;
5166: LD_ADDR_EXP 34
5170: PUSH
5171: LD_INT 1
5173: ST_TO_ADDR
// if p3 = 16 then
5174: LD_VAR 0 3
5178: PUSH
5179: LD_INT 16
5181: EQUAL
5182: IFFALSE 5192
// sTroll := true ;
5184: LD_ADDR_EXP 35
5188: PUSH
5189: LD_INT 1
5191: ST_TO_ADDR
// if p3 = 17 then
5192: LD_VAR 0 3
5196: PUSH
5197: LD_INT 17
5199: EQUAL
5200: IFFALSE 5210
// sSlow := true ;
5202: LD_ADDR_EXP 36
5206: PUSH
5207: LD_INT 1
5209: ST_TO_ADDR
// if p3 = 18 then
5210: LD_VAR 0 3
5214: PUSH
5215: LD_INT 18
5217: EQUAL
5218: IFFALSE 5228
// sLack := true ;
5220: LD_ADDR_EXP 37
5224: PUSH
5225: LD_INT 1
5227: ST_TO_ADDR
// if p3 = 19 then
5228: LD_VAR 0 3
5232: PUSH
5233: LD_INT 19
5235: EQUAL
5236: IFFALSE 5246
// sTank := true ;
5238: LD_ADDR_EXP 39
5242: PUSH
5243: LD_INT 1
5245: ST_TO_ADDR
// if p3 = 20 then
5246: LD_VAR 0 3
5250: PUSH
5251: LD_INT 20
5253: EQUAL
5254: IFFALSE 5264
// sRemote := true ;
5256: LD_ADDR_EXP 40
5260: PUSH
5261: LD_INT 1
5263: ST_TO_ADDR
// if p3 = 101 then
5264: LD_VAR 0 3
5268: PUSH
5269: LD_INT 101
5271: EQUAL
5272: IFFALSE 5282
// sSold := true ;
5274: LD_ADDR_EXP 27
5278: PUSH
5279: LD_INT 1
5281: ST_TO_ADDR
// if p3 = 102 then
5282: LD_VAR 0 3
5286: PUSH
5287: LD_INT 102
5289: EQUAL
5290: IFFALSE 5300
// sDiff := true ;
5292: LD_ADDR_EXP 28
5296: PUSH
5297: LD_INT 1
5299: ST_TO_ADDR
// if p3 = 103 then
5300: LD_VAR 0 3
5304: PUSH
5305: LD_INT 103
5307: EQUAL
5308: IFFALSE 5318
// sFog := true ;
5310: LD_ADDR_EXP 31
5314: PUSH
5315: LD_INT 1
5317: ST_TO_ADDR
// if p3 = 104 then
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 104
5325: EQUAL
5326: IFFALSE 5336
// sReset := true ;
5328: LD_ADDR_EXP 32
5332: PUSH
5333: LD_INT 1
5335: ST_TO_ADDR
// if p3 = 105 then
5336: LD_VAR 0 3
5340: PUSH
5341: LD_INT 105
5343: EQUAL
5344: IFFALSE 5354
// sSun := true ;
5346: LD_ADDR_EXP 33
5350: PUSH
5351: LD_INT 1
5353: ST_TO_ADDR
// if p3 = 106 then
5354: LD_VAR 0 3
5358: PUSH
5359: LD_INT 106
5361: EQUAL
5362: IFFALSE 5372
// sTiger := true ;
5364: LD_ADDR_EXP 29
5368: PUSH
5369: LD_INT 1
5371: ST_TO_ADDR
// if p3 = 107 then
5372: LD_VAR 0 3
5376: PUSH
5377: LD_INT 107
5379: EQUAL
5380: IFFALSE 5390
// sBomb := true ;
5382: LD_ADDR_EXP 30
5386: PUSH
5387: LD_INT 1
5389: ST_TO_ADDR
// if p3 = 108 then
5390: LD_VAR 0 3
5394: PUSH
5395: LD_INT 108
5397: EQUAL
5398: IFFALSE 5408
// sWound := true ;
5400: LD_ADDR_EXP 38
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// end ; end ;
5408: PPOPN 6
5410: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5411: LD_EXP 12
5415: PUSH
5416: LD_EXP 15
5420: AND
5421: IFFALSE 5542
5423: GO 5425
5425: DISABLE
5426: LD_INT 0
5428: PPUSH
5429: PPUSH
// begin enable ;
5430: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: LD_INT 22
5438: PUSH
5439: LD_OWVAR 2
5443: PUSH
5444: EMPTY
5445: LIST
5446: LIST
5447: PUSH
5448: LD_INT 2
5450: PUSH
5451: LD_INT 34
5453: PUSH
5454: LD_INT 7
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PUSH
5461: LD_INT 34
5463: PUSH
5464: LD_INT 45
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: PUSH
5471: LD_INT 34
5473: PUSH
5474: LD_INT 28
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: PUSH
5481: LD_INT 34
5483: PUSH
5484: LD_INT 47
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 69
5506: ST_TO_ADDR
// if not tmp then
5507: LD_VAR 0 2
5511: NOT
5512: IFFALSE 5516
// exit ;
5514: GO 5542
// for i in tmp do
5516: LD_ADDR_VAR 0 1
5520: PUSH
5521: LD_VAR 0 2
5525: PUSH
5526: FOR_IN
5527: IFFALSE 5540
// begin DestroyUnit ( i ) ;
5529: LD_VAR 0 1
5533: PPUSH
5534: CALL_OW 65
// end ;
5538: GO 5526
5540: POP
5541: POP
// end ;
5542: PPOPN 2
5544: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5545: LD_EXP 12
5549: PUSH
5550: LD_EXP 16
5554: AND
5555: IFFALSE 5636
5557: GO 5559
5559: DISABLE
5560: LD_INT 0
5562: PPUSH
5563: PPUSH
// begin enable ;
5564: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5565: LD_ADDR_VAR 0 2
5569: PUSH
5570: LD_INT 22
5572: PUSH
5573: LD_OWVAR 2
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 32
5584: PUSH
5585: LD_INT 3
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PPUSH
5596: CALL_OW 69
5600: ST_TO_ADDR
// if not tmp then
5601: LD_VAR 0 2
5605: NOT
5606: IFFALSE 5610
// exit ;
5608: GO 5636
// for i in tmp do
5610: LD_ADDR_VAR 0 1
5614: PUSH
5615: LD_VAR 0 2
5619: PUSH
5620: FOR_IN
5621: IFFALSE 5634
// begin DestroyUnit ( i ) ;
5623: LD_VAR 0 1
5627: PPUSH
5628: CALL_OW 65
// end ;
5632: GO 5620
5634: POP
5635: POP
// end ;
5636: PPOPN 2
5638: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5639: LD_EXP 12
5643: PUSH
5644: LD_EXP 13
5648: AND
5649: IFFALSE 5742
5651: GO 5653
5653: DISABLE
5654: LD_INT 0
5656: PPUSH
// begin enable ;
5657: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5658: LD_ADDR_VAR 0 1
5662: PUSH
5663: LD_INT 22
5665: PUSH
5666: LD_OWVAR 2
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 25
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 25
5690: PUSH
5691: LD_INT 9
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 25
5700: PUSH
5701: LD_INT 8
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PPUSH
5718: CALL_OW 69
5722: PUSH
5723: FOR_IN
5724: IFFALSE 5740
// begin SetClass ( i , 1 ) ;
5726: LD_VAR 0 1
5730: PPUSH
5731: LD_INT 1
5733: PPUSH
5734: CALL_OW 336
// end ;
5738: GO 5723
5740: POP
5741: POP
// end ;
5742: PPOPN 1
5744: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5745: LD_EXP 12
5749: PUSH
5750: LD_EXP 14
5754: AND
5755: PUSH
5756: LD_OWVAR 65
5760: PUSH
5761: LD_INT 7
5763: LESS
5764: AND
5765: IFFALSE 5779
5767: GO 5769
5769: DISABLE
// begin enable ;
5770: ENABLE
// game_speed := 7 ;
5771: LD_ADDR_OWVAR 65
5775: PUSH
5776: LD_INT 7
5778: ST_TO_ADDR
// end ;
5779: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5780: LD_EXP 12
5784: PUSH
5785: LD_EXP 17
5789: AND
5790: IFFALSE 5992
5792: GO 5794
5794: DISABLE
5795: LD_INT 0
5797: PPUSH
5798: PPUSH
5799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5800: LD_ADDR_VAR 0 3
5804: PUSH
5805: LD_INT 81
5807: PUSH
5808: LD_OWVAR 2
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: PUSH
5817: LD_INT 21
5819: PUSH
5820: LD_INT 1
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: PPUSH
5831: CALL_OW 69
5835: ST_TO_ADDR
// if not tmp then
5836: LD_VAR 0 3
5840: NOT
5841: IFFALSE 5845
// exit ;
5843: GO 5992
// if tmp > 5 then
5845: LD_VAR 0 3
5849: PUSH
5850: LD_INT 5
5852: GREATER
5853: IFFALSE 5865
// k := 5 else
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_INT 5
5862: ST_TO_ADDR
5863: GO 5875
// k := tmp ;
5865: LD_ADDR_VAR 0 2
5869: PUSH
5870: LD_VAR 0 3
5874: ST_TO_ADDR
// for i := 1 to k do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_VAR 0 2
5889: PUSH
5890: FOR_TO
5891: IFFALSE 5990
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5893: LD_VAR 0 3
5897: PUSH
5898: LD_VAR 0 1
5902: ARRAY
5903: PPUSH
5904: LD_VAR 0 1
5908: PUSH
5909: LD_INT 4
5911: MOD
5912: PUSH
5913: LD_INT 1
5915: PLUS
5916: PPUSH
5917: CALL_OW 259
5921: PUSH
5922: LD_INT 10
5924: LESS
5925: IFFALSE 5988
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5927: LD_VAR 0 3
5931: PUSH
5932: LD_VAR 0 1
5936: ARRAY
5937: PPUSH
5938: LD_VAR 0 1
5942: PUSH
5943: LD_INT 4
5945: MOD
5946: PUSH
5947: LD_INT 1
5949: PLUS
5950: PPUSH
5951: LD_VAR 0 3
5955: PUSH
5956: LD_VAR 0 1
5960: ARRAY
5961: PPUSH
5962: LD_VAR 0 1
5966: PUSH
5967: LD_INT 4
5969: MOD
5970: PUSH
5971: LD_INT 1
5973: PLUS
5974: PPUSH
5975: CALL_OW 259
5979: PUSH
5980: LD_INT 1
5982: PLUS
5983: PPUSH
5984: CALL_OW 237
5988: GO 5890
5990: POP
5991: POP
// end ;
5992: PPOPN 3
5994: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5995: LD_EXP 12
5999: PUSH
6000: LD_EXP 18
6004: AND
6005: IFFALSE 6025
6007: GO 6009
6009: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
6010: LD_INT 4
6012: PPUSH
6013: LD_OWVAR 2
6017: PPUSH
6018: LD_INT 0
6020: PPUSH
6021: CALL_OW 324
6025: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
6026: LD_EXP 12
6030: PUSH
6031: LD_EXP 19
6035: AND
6036: IFFALSE 6135
6038: GO 6040
6040: DISABLE
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
// begin enable ;
6045: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
6046: LD_ADDR_VAR 0 2
6050: PUSH
6051: LD_INT 22
6053: PUSH
6054: LD_OWVAR 2
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: PUSH
6063: LD_INT 2
6065: PUSH
6066: LD_INT 34
6068: PUSH
6069: LD_INT 11
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: LD_INT 34
6078: PUSH
6079: LD_INT 30
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PPUSH
6095: CALL_OW 69
6099: ST_TO_ADDR
// if not tmp then
6100: LD_VAR 0 2
6104: NOT
6105: IFFALSE 6109
// exit ;
6107: GO 6135
// for i in tmp do
6109: LD_ADDR_VAR 0 1
6113: PUSH
6114: LD_VAR 0 2
6118: PUSH
6119: FOR_IN
6120: IFFALSE 6133
// begin DestroyUnit ( i ) ;
6122: LD_VAR 0 1
6126: PPUSH
6127: CALL_OW 65
// end ;
6131: GO 6119
6133: POP
6134: POP
// end ;
6135: PPOPN 2
6137: END
// every 0 0$1 trigger StreamModeActive and sBunker do
6138: LD_EXP 12
6142: PUSH
6143: LD_EXP 20
6147: AND
6148: IFFALSE 6168
6150: GO 6152
6152: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
6153: LD_INT 32
6155: PPUSH
6156: LD_OWVAR 2
6160: PPUSH
6161: LD_INT 0
6163: PPUSH
6164: CALL_OW 324
6168: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
6169: LD_EXP 12
6173: PUSH
6174: LD_EXP 21
6178: AND
6179: IFFALSE 6360
6181: GO 6183
6183: DISABLE
6184: LD_INT 0
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6189: LD_ADDR_VAR 0 2
6193: PUSH
6194: LD_INT 22
6196: PUSH
6197: LD_OWVAR 2
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: PUSH
6206: LD_INT 33
6208: PUSH
6209: LD_INT 3
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 69
6224: ST_TO_ADDR
// if not tmp then
6225: LD_VAR 0 2
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 6360
// side := 0 ;
6234: LD_ADDR_VAR 0 3
6238: PUSH
6239: LD_INT 0
6241: ST_TO_ADDR
// for i := 1 to 8 do
6242: LD_ADDR_VAR 0 1
6246: PUSH
6247: DOUBLE
6248: LD_INT 1
6250: DEC
6251: ST_TO_ADDR
6252: LD_INT 8
6254: PUSH
6255: FOR_TO
6256: IFFALSE 6304
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6258: LD_OWVAR 2
6262: PUSH
6263: LD_VAR 0 1
6267: NONEQUAL
6268: PUSH
6269: LD_OWVAR 2
6273: PPUSH
6274: LD_VAR 0 1
6278: PPUSH
6279: CALL_OW 81
6283: PUSH
6284: LD_INT 2
6286: EQUAL
6287: AND
6288: IFFALSE 6302
// begin side := i ;
6290: LD_ADDR_VAR 0 3
6294: PUSH
6295: LD_VAR 0 1
6299: ST_TO_ADDR
// break ;
6300: GO 6304
// end ;
6302: GO 6255
6304: POP
6305: POP
// if not side then
6306: LD_VAR 0 3
6310: NOT
6311: IFFALSE 6315
// exit ;
6313: GO 6360
// for i := 1 to tmp do
6315: LD_ADDR_VAR 0 1
6319: PUSH
6320: DOUBLE
6321: LD_INT 1
6323: DEC
6324: ST_TO_ADDR
6325: LD_VAR 0 2
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6358
// if Prob ( 30 ) then
6333: LD_INT 30
6335: PPUSH
6336: CALL_OW 13
6340: IFFALSE 6356
// SetSide ( i , side ) ;
6342: LD_VAR 0 1
6346: PPUSH
6347: LD_VAR 0 3
6351: PPUSH
6352: CALL_OW 235
6356: GO 6330
6358: POP
6359: POP
// end ;
6360: PPOPN 3
6362: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6363: LD_EXP 12
6367: PUSH
6368: LD_EXP 23
6372: AND
6373: IFFALSE 6492
6375: GO 6377
6377: DISABLE
6378: LD_INT 0
6380: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6381: LD_ADDR_VAR 0 1
6385: PUSH
6386: LD_INT 22
6388: PUSH
6389: LD_OWVAR 2
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: PUSH
6398: LD_INT 21
6400: PUSH
6401: LD_INT 1
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: PUSH
6408: LD_INT 3
6410: PUSH
6411: LD_INT 23
6413: PUSH
6414: LD_INT 0
6416: PUSH
6417: EMPTY
6418: LIST
6419: LIST
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: PPUSH
6430: CALL_OW 69
6434: PUSH
6435: FOR_IN
6436: IFFALSE 6490
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6438: LD_VAR 0 1
6442: PPUSH
6443: CALL_OW 257
6447: PUSH
6448: LD_INT 1
6450: PUSH
6451: LD_INT 2
6453: PUSH
6454: LD_INT 3
6456: PUSH
6457: LD_INT 4
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: IN
6466: IFFALSE 6488
// SetClass ( un , rand ( 1 , 4 ) ) ;
6468: LD_VAR 0 1
6472: PPUSH
6473: LD_INT 1
6475: PPUSH
6476: LD_INT 4
6478: PPUSH
6479: CALL_OW 12
6483: PPUSH
6484: CALL_OW 336
6488: GO 6435
6490: POP
6491: POP
// end ;
6492: PPOPN 1
6494: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6495: LD_EXP 12
6499: PUSH
6500: LD_EXP 22
6504: AND
6505: IFFALSE 6584
6507: GO 6509
6509: DISABLE
6510: LD_INT 0
6512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6513: LD_ADDR_VAR 0 1
6517: PUSH
6518: LD_INT 22
6520: PUSH
6521: LD_OWVAR 2
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 21
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: PPUSH
6544: CALL_OW 69
6548: ST_TO_ADDR
// if not tmp then
6549: LD_VAR 0 1
6553: NOT
6554: IFFALSE 6558
// exit ;
6556: GO 6584
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6558: LD_VAR 0 1
6562: PUSH
6563: LD_INT 1
6565: PPUSH
6566: LD_VAR 0 1
6570: PPUSH
6571: CALL_OW 12
6575: ARRAY
6576: PPUSH
6577: LD_INT 100
6579: PPUSH
6580: CALL_OW 234
// end ;
6584: PPOPN 1
6586: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6587: LD_EXP 12
6591: PUSH
6592: LD_EXP 24
6596: AND
6597: IFFALSE 6695
6599: GO 6601
6601: DISABLE
6602: LD_INT 0
6604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6605: LD_ADDR_VAR 0 1
6609: PUSH
6610: LD_INT 22
6612: PUSH
6613: LD_OWVAR 2
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 21
6624: PUSH
6625: LD_INT 1
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 69
6640: ST_TO_ADDR
// if not tmp then
6641: LD_VAR 0 1
6645: NOT
6646: IFFALSE 6650
// exit ;
6648: GO 6695
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 1
6657: PPUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 12
6667: ARRAY
6668: PPUSH
6669: LD_INT 1
6671: PPUSH
6672: LD_INT 4
6674: PPUSH
6675: CALL_OW 12
6679: PPUSH
6680: LD_INT 3000
6682: PPUSH
6683: LD_INT 9000
6685: PPUSH
6686: CALL_OW 12
6690: PPUSH
6691: CALL_OW 492
// end ;
6695: PPOPN 1
6697: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6698: LD_EXP 12
6702: PUSH
6703: LD_EXP 25
6707: AND
6708: IFFALSE 6728
6710: GO 6712
6712: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6713: LD_INT 1
6715: PPUSH
6716: LD_OWVAR 2
6720: PPUSH
6721: LD_INT 0
6723: PPUSH
6724: CALL_OW 324
6728: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6729: LD_EXP 12
6733: PUSH
6734: LD_EXP 26
6738: AND
6739: IFFALSE 6822
6741: GO 6743
6743: DISABLE
6744: LD_INT 0
6746: PPUSH
6747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6748: LD_ADDR_VAR 0 2
6752: PUSH
6753: LD_INT 22
6755: PUSH
6756: LD_OWVAR 2
6760: PUSH
6761: EMPTY
6762: LIST
6763: LIST
6764: PUSH
6765: LD_INT 21
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PPUSH
6779: CALL_OW 69
6783: ST_TO_ADDR
// if not tmp then
6784: LD_VAR 0 2
6788: NOT
6789: IFFALSE 6793
// exit ;
6791: GO 6822
// for i in tmp do
6793: LD_ADDR_VAR 0 1
6797: PUSH
6798: LD_VAR 0 2
6802: PUSH
6803: FOR_IN
6804: IFFALSE 6820
// SetBLevel ( i , 10 ) ;
6806: LD_VAR 0 1
6810: PPUSH
6811: LD_INT 10
6813: PPUSH
6814: CALL_OW 241
6818: GO 6803
6820: POP
6821: POP
// end ;
6822: PPOPN 2
6824: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
6825: LD_EXP 12
6829: PUSH
6830: LD_EXP 27
6834: AND
6835: IFFALSE 6938
6837: GO 6839
6839: DISABLE
6840: LD_INT 0
6842: PPUSH
6843: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6844: LD_ADDR_VAR 0 2
6848: PUSH
6849: LD_INT 22
6851: PUSH
6852: LD_OWVAR 2
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PUSH
6861: LD_INT 25
6863: PUSH
6864: LD_INT 1
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PPUSH
6875: CALL_OW 69
6879: ST_TO_ADDR
// if not tmp then
6880: LD_VAR 0 2
6884: NOT
6885: IFFALSE 6889
// exit ;
6887: GO 6938
// for i in tmp do
6889: LD_ADDR_VAR 0 1
6893: PUSH
6894: LD_VAR 0 2
6898: PUSH
6899: FOR_IN
6900: IFFALSE 6936
// begin if Crawls ( i ) then
6902: LD_VAR 0 1
6906: PPUSH
6907: CALL_OW 318
6911: IFFALSE 6922
// ComWalk ( i ) ;
6913: LD_VAR 0 1
6917: PPUSH
6918: CALL_OW 138
// SetClass ( i , 4 ) ;
6922: LD_VAR 0 1
6926: PPUSH
6927: LD_INT 4
6929: PPUSH
6930: CALL_OW 336
// end ;
6934: GO 6899
6936: POP
6937: POP
// end ;
6938: PPOPN 2
6940: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6941: LD_EXP 12
6945: PUSH
6946: LD_EXP 28
6950: AND
6951: PUSH
6952: LD_OWVAR 67
6956: PUSH
6957: LD_INT 3
6959: LESS
6960: AND
6961: IFFALSE 6980
6963: GO 6965
6965: DISABLE
// Difficulty := Difficulty + 1 ;
6966: LD_ADDR_OWVAR 67
6970: PUSH
6971: LD_OWVAR 67
6975: PUSH
6976: LD_INT 1
6978: PLUS
6979: ST_TO_ADDR
6980: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6981: LD_EXP 12
6985: PUSH
6986: LD_EXP 29
6990: AND
6991: IFFALSE 7094
6993: GO 6995
6995: DISABLE
6996: LD_INT 0
6998: PPUSH
// begin for i := 1 to 5 do
6999: LD_ADDR_VAR 0 1
7003: PUSH
7004: DOUBLE
7005: LD_INT 1
7007: DEC
7008: ST_TO_ADDR
7009: LD_INT 5
7011: PUSH
7012: FOR_TO
7013: IFFALSE 7092
// begin uc_nation := nation_nature ;
7015: LD_ADDR_OWVAR 21
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// uc_side := 0 ;
7023: LD_ADDR_OWVAR 20
7027: PUSH
7028: LD_INT 0
7030: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7031: LD_ADDR_OWVAR 29
7035: PUSH
7036: LD_INT 12
7038: PUSH
7039: LD_INT 12
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: ST_TO_ADDR
// hc_agressivity := 20 ;
7046: LD_ADDR_OWVAR 35
7050: PUSH
7051: LD_INT 20
7053: ST_TO_ADDR
// hc_class := class_tiger ;
7054: LD_ADDR_OWVAR 28
7058: PUSH
7059: LD_INT 14
7061: ST_TO_ADDR
// hc_gallery :=  ;
7062: LD_ADDR_OWVAR 33
7066: PUSH
7067: LD_STRING 
7069: ST_TO_ADDR
// hc_name :=  ;
7070: LD_ADDR_OWVAR 26
7074: PUSH
7075: LD_STRING 
7077: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
7078: CALL_OW 44
7082: PPUSH
7083: LD_INT 0
7085: PPUSH
7086: CALL_OW 51
// end ;
7090: GO 7012
7092: POP
7093: POP
// end ;
7094: PPOPN 1
7096: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
7097: LD_EXP 12
7101: PUSH
7102: LD_EXP 30
7106: AND
7107: IFFALSE 7281
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
7117: PPUSH
// begin result := false ;
7118: LD_ADDR_VAR 0 4
7122: PUSH
7123: LD_INT 0
7125: ST_TO_ADDR
// for i := 1 to 8 do
7126: LD_ADDR_VAR 0 1
7130: PUSH
7131: DOUBLE
7132: LD_INT 1
7134: DEC
7135: ST_TO_ADDR
7136: LD_INT 8
7138: PUSH
7139: FOR_TO
7140: IFFALSE 7251
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
7142: LD_ADDR_VAR 0 2
7146: PUSH
7147: LD_INT 10
7149: PUSH
7150: LD_INT 50
7152: PUSH
7153: LD_INT 90
7155: PUSH
7156: LD_INT 140
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: LD_INT 1
7167: PPUSH
7168: LD_INT 4
7170: PPUSH
7171: CALL_OW 12
7175: ARRAY
7176: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
7177: LD_ADDR_VAR 0 3
7181: PUSH
7182: LD_INT 10
7184: PUSH
7185: LD_INT 50
7187: PUSH
7188: LD_INT 90
7190: PUSH
7191: LD_INT 140
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 1
7202: PPUSH
7203: LD_INT 4
7205: PPUSH
7206: CALL_OW 12
7210: ARRAY
7211: ST_TO_ADDR
// if ValidHex ( x , y ) then
7212: LD_VAR 0 2
7216: PPUSH
7217: LD_VAR 0 3
7221: PPUSH
7222: CALL_OW 488
7226: IFFALSE 7249
// begin result := [ x , y ] ;
7228: LD_ADDR_VAR 0 4
7232: PUSH
7233: LD_VAR 0 2
7237: PUSH
7238: LD_VAR 0 3
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: ST_TO_ADDR
// break ;
7247: GO 7251
// end ; end ;
7249: GO 7139
7251: POP
7252: POP
// if result then
7253: LD_VAR 0 4
7257: IFFALSE 7281
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7259: LD_VAR 0 4
7263: PUSH
7264: LD_INT 1
7266: ARRAY
7267: PPUSH
7268: LD_VAR 0 4
7272: PUSH
7273: LD_INT 2
7275: ARRAY
7276: PPUSH
7277: CALL_OW 429
// end ;
7281: PPOPN 4
7283: END
// every 0 0$1 trigger StreamModeActive and sReset do
7284: LD_EXP 12
7288: PUSH
7289: LD_EXP 32
7293: AND
7294: IFFALSE 7306
7296: GO 7298
7298: DISABLE
// YouLost (  ) ;
7299: LD_STRING 
7301: PPUSH
7302: CALL_OW 104
7306: END
// every 0 0$1 trigger StreamModeActive and sFog do
7307: LD_EXP 12
7311: PUSH
7312: LD_EXP 31
7316: AND
7317: IFFALSE 7331
7319: GO 7321
7321: DISABLE
// FogOff ( your_side ) ;
7322: LD_OWVAR 2
7326: PPUSH
7327: CALL_OW 344
7331: END
// every 0 0$1 trigger StreamModeActive and sSun do
7332: LD_EXP 12
7336: PUSH
7337: LD_EXP 33
7341: AND
7342: IFFALSE 7370
7344: GO 7346
7346: DISABLE
// begin solar_recharge_percent := 0 ;
7347: LD_ADDR_OWVAR 79
7351: PUSH
7352: LD_INT 0
7354: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7355: LD_INT 10500
7357: PPUSH
7358: CALL_OW 67
// solar_recharge_percent := 100 ;
7362: LD_ADDR_OWVAR 79
7366: PUSH
7367: LD_INT 100
7369: ST_TO_ADDR
// end ;
7370: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
7371: LD_EXP 12
7375: PUSH
7376: LD_EXP 34
7380: AND
7381: IFFALSE 7536
7383: GO 7385
7385: DISABLE
7386: LD_INT 0
7388: PPUSH
7389: PPUSH
// begin for i := 1 to 6 do
7390: LD_ADDR_VAR 0 1
7394: PUSH
7395: DOUBLE
7396: LD_INT 1
7398: DEC
7399: ST_TO_ADDR
7400: LD_INT 6
7402: PUSH
7403: FOR_TO
7404: IFFALSE 7534
// begin uc_nation := nation_nature ;
7406: LD_ADDR_OWVAR 21
7410: PUSH
7411: LD_INT 0
7413: ST_TO_ADDR
// uc_side := 0 ;
7414: LD_ADDR_OWVAR 20
7418: PUSH
7419: LD_INT 0
7421: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7422: LD_ADDR_OWVAR 29
7426: PUSH
7427: LD_INT 12
7429: PUSH
7430: LD_INT 12
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: ST_TO_ADDR
// hc_agressivity := 20 ;
7437: LD_ADDR_OWVAR 35
7441: PUSH
7442: LD_INT 20
7444: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7445: LD_ADDR_OWVAR 28
7449: PUSH
7450: LD_INT 17
7452: ST_TO_ADDR
// hc_gallery :=  ;
7453: LD_ADDR_OWVAR 33
7457: PUSH
7458: LD_STRING 
7460: ST_TO_ADDR
// hc_name :=  ;
7461: LD_ADDR_OWVAR 26
7465: PUSH
7466: LD_STRING 
7468: ST_TO_ADDR
// un := CreateHuman ;
7469: LD_ADDR_VAR 0 2
7473: PUSH
7474: CALL_OW 44
7478: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7479: LD_VAR 0 2
7483: PPUSH
7484: LD_INT 1
7486: PPUSH
7487: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7491: LD_VAR 0 2
7495: PPUSH
7496: LD_INT 3
7498: PUSH
7499: LD_INT 22
7501: PUSH
7502: LD_INT 0
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PPUSH
7513: CALL_OW 69
7517: PPUSH
7518: LD_VAR 0 2
7522: PPUSH
7523: CALL_OW 74
7527: PPUSH
7528: CALL_OW 115
// end ;
7532: GO 7403
7534: POP
7535: POP
// end ;
7536: PPOPN 2
7538: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7539: LD_EXP 12
7543: PUSH
7544: LD_EXP 35
7548: AND
7549: IFFALSE 7575
7551: GO 7553
7553: DISABLE
// begin ToLua ( displayTroll(); ) ;
7554: LD_STRING displayTroll();
7556: PPUSH
7557: CALL_OW 559
// wait ( 3 3$00 ) ;
7561: LD_INT 6300
7563: PPUSH
7564: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7568: LD_STRING hideTroll();
7570: PPUSH
7571: CALL_OW 559
// end ;
7575: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7576: LD_EXP 12
7580: PUSH
7581: LD_EXP 36
7585: AND
7586: IFFALSE 7649
7588: GO 7590
7590: DISABLE
7591: LD_INT 0
7593: PPUSH
// begin p := 0 ;
7594: LD_ADDR_VAR 0 1
7598: PUSH
7599: LD_INT 0
7601: ST_TO_ADDR
// repeat game_speed := 1 ;
7602: LD_ADDR_OWVAR 65
7606: PUSH
7607: LD_INT 1
7609: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7610: LD_INT 35
7612: PPUSH
7613: CALL_OW 67
// p := p + 1 ;
7617: LD_ADDR_VAR 0 1
7621: PUSH
7622: LD_VAR 0 1
7626: PUSH
7627: LD_INT 1
7629: PLUS
7630: ST_TO_ADDR
// until p >= 60 ;
7631: LD_VAR 0 1
7635: PUSH
7636: LD_INT 60
7638: GREATEREQUAL
7639: IFFALSE 7602
// game_speed := 4 ;
7641: LD_ADDR_OWVAR 65
7645: PUSH
7646: LD_INT 4
7648: ST_TO_ADDR
// end ;
7649: PPOPN 1
7651: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
7652: LD_EXP 12
7656: PUSH
7657: LD_EXP 37
7661: AND
7662: IFFALSE 7808
7664: GO 7666
7666: DISABLE
7667: LD_INT 0
7669: PPUSH
7670: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7671: LD_ADDR_VAR 0 1
7675: PUSH
7676: LD_INT 22
7678: PUSH
7679: LD_OWVAR 2
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 2
7690: PUSH
7691: LD_INT 30
7693: PUSH
7694: LD_INT 0
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: PUSH
7701: LD_INT 30
7703: PUSH
7704: LD_INT 1
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: ST_TO_ADDR
// if not depot then
7725: LD_VAR 0 1
7729: NOT
7730: IFFALSE 7734
// exit ;
7732: GO 7808
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7734: LD_ADDR_VAR 0 2
7738: PUSH
7739: LD_VAR 0 1
7743: PUSH
7744: LD_INT 1
7746: PPUSH
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 12
7756: ARRAY
7757: PPUSH
7758: CALL_OW 274
7762: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7763: LD_VAR 0 2
7767: PPUSH
7768: LD_INT 1
7770: PPUSH
7771: LD_INT 0
7773: PPUSH
7774: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
7778: LD_VAR 0 2
7782: PPUSH
7783: LD_INT 2
7785: PPUSH
7786: LD_INT 0
7788: PPUSH
7789: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
7793: LD_VAR 0 2
7797: PPUSH
7798: LD_INT 3
7800: PPUSH
7801: LD_INT 0
7803: PPUSH
7804: CALL_OW 277
// end ;
7808: PPOPN 2
7810: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
7811: LD_EXP 12
7815: PUSH
7816: LD_EXP 38
7820: AND
7821: IFFALSE 7918
7823: GO 7825
7825: DISABLE
7826: LD_INT 0
7828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
7829: LD_ADDR_VAR 0 1
7833: PUSH
7834: LD_INT 22
7836: PUSH
7837: LD_OWVAR 2
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 21
7848: PUSH
7849: LD_INT 1
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: LD_INT 3
7858: PUSH
7859: LD_INT 23
7861: PUSH
7862: LD_INT 0
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 69
7882: ST_TO_ADDR
// if not tmp then
7883: LD_VAR 0 1
7887: NOT
7888: IFFALSE 7892
// exit ;
7890: GO 7918
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
7892: LD_VAR 0 1
7896: PUSH
7897: LD_INT 1
7899: PPUSH
7900: LD_VAR 0 1
7904: PPUSH
7905: CALL_OW 12
7909: ARRAY
7910: PPUSH
7911: LD_INT 200
7913: PPUSH
7914: CALL_OW 234
// end ;
7918: PPOPN 1
7920: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
7921: LD_EXP 12
7925: PUSH
7926: LD_EXP 39
7930: AND
7931: IFFALSE 8010
7933: GO 7935
7935: DISABLE
7936: LD_INT 0
7938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
7939: LD_ADDR_VAR 0 1
7943: PUSH
7944: LD_INT 22
7946: PUSH
7947: LD_OWVAR 2
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: PUSH
7956: LD_INT 21
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: PPUSH
7970: CALL_OW 69
7974: ST_TO_ADDR
// if not tmp then
7975: LD_VAR 0 1
7979: NOT
7980: IFFALSE 7984
// exit ;
7982: GO 8010
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
7984: LD_VAR 0 1
7988: PUSH
7989: LD_INT 1
7991: PPUSH
7992: LD_VAR 0 1
7996: PPUSH
7997: CALL_OW 12
8001: ARRAY
8002: PPUSH
8003: LD_INT 10
8005: PPUSH
8006: CALL_OW 234
// end ;
8010: PPOPN 1
8012: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8013: LD_EXP 12
8017: PUSH
8018: LD_EXP 40
8022: AND
8023: IFFALSE 8122
8025: GO 8027
8027: DISABLE
8028: LD_INT 0
8030: PPUSH
8031: PPUSH
// begin enable ;
8032: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8033: LD_ADDR_VAR 0 1
8037: PUSH
8038: LD_INT 22
8040: PUSH
8041: LD_OWVAR 2
8045: PUSH
8046: EMPTY
8047: LIST
8048: LIST
8049: PUSH
8050: LD_INT 61
8052: PUSH
8053: EMPTY
8054: LIST
8055: PUSH
8056: LD_INT 33
8058: PUSH
8059: LD_INT 2
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: PPUSH
8071: CALL_OW 69
8075: ST_TO_ADDR
// if not tmp then
8076: LD_VAR 0 1
8080: NOT
8081: IFFALSE 8085
// exit ;
8083: GO 8122
// for i in tmp do
8085: LD_ADDR_VAR 0 2
8089: PUSH
8090: LD_VAR 0 1
8094: PUSH
8095: FOR_IN
8096: IFFALSE 8120
// if IsControledBy ( i ) then
8098: LD_VAR 0 2
8102: PPUSH
8103: CALL_OW 312
8107: IFFALSE 8118
// ComUnlink ( i ) ;
8109: LD_VAR 0 2
8113: PPUSH
8114: CALL_OW 136
8118: GO 8095
8120: POP
8121: POP
// end ; end_of_file
8122: PPOPN 2
8124: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8125: LD_INT 0
8127: PPUSH
8128: PPUSH
8129: PPUSH
8130: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8131: LD_VAR 0 1
8135: PPUSH
8136: CALL_OW 264
8140: PUSH
8141: LD_EXP 11
8145: EQUAL
8146: IFFALSE 8218
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8148: LD_INT 68
8150: PPUSH
8151: LD_VAR 0 1
8155: PPUSH
8156: CALL_OW 255
8160: PPUSH
8161: CALL_OW 321
8165: PUSH
8166: LD_INT 2
8168: EQUAL
8169: IFFALSE 8181
// eff := 70 else
8171: LD_ADDR_VAR 0 6
8175: PUSH
8176: LD_INT 70
8178: ST_TO_ADDR
8179: GO 8189
// eff := 30 ;
8181: LD_ADDR_VAR 0 6
8185: PUSH
8186: LD_INT 30
8188: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8189: LD_VAR 0 1
8193: PPUSH
8194: CALL_OW 250
8198: PPUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: CALL_OW 251
8208: PPUSH
8209: LD_VAR 0 6
8213: PPUSH
8214: CALL_OW 495
// end ; end ;
8218: LD_VAR 0 4
8222: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8223: LD_INT 0
8225: PPUSH
8226: PPUSH
8227: PPUSH
8228: PPUSH
8229: PPUSH
8230: PPUSH
// if cmd = 124 then
8231: LD_VAR 0 1
8235: PUSH
8236: LD_INT 124
8238: EQUAL
8239: IFFALSE 8445
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8241: LD_ADDR_VAR 0 5
8245: PUSH
8246: LD_INT 2
8248: PUSH
8249: LD_INT 34
8251: PUSH
8252: LD_INT 53
8254: PUSH
8255: EMPTY
8256: LIST
8257: LIST
8258: PUSH
8259: LD_INT 34
8261: PUSH
8262: LD_INT 14
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: LIST
8273: PPUSH
8274: CALL_OW 69
8278: ST_TO_ADDR
// if not tmp then
8279: LD_VAR 0 5
8283: NOT
8284: IFFALSE 8288
// exit ;
8286: GO 8445
// for i in tmp do
8288: LD_ADDR_VAR 0 3
8292: PUSH
8293: LD_VAR 0 5
8297: PUSH
8298: FOR_IN
8299: IFFALSE 8443
// begin taskList := GetTaskList ( i ) ;
8301: LD_ADDR_VAR 0 6
8305: PUSH
8306: LD_VAR 0 3
8310: PPUSH
8311: CALL_OW 437
8315: ST_TO_ADDR
// if not taskList then
8316: LD_VAR 0 6
8320: NOT
8321: IFFALSE 8325
// continue ;
8323: GO 8298
// for j = 1 to taskList do
8325: LD_ADDR_VAR 0 4
8329: PUSH
8330: DOUBLE
8331: LD_INT 1
8333: DEC
8334: ST_TO_ADDR
8335: LD_VAR 0 6
8339: PUSH
8340: FOR_TO
8341: IFFALSE 8439
// if taskList [ j ] [ 1 ] = | then
8343: LD_VAR 0 6
8347: PUSH
8348: LD_VAR 0 4
8352: ARRAY
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: PUSH
8358: LD_STRING |
8360: EQUAL
8361: IFFALSE 8437
// begin _taskList := Delete ( taskList , 1 ) ;
8363: LD_ADDR_VAR 0 7
8367: PUSH
8368: LD_VAR 0 6
8372: PPUSH
8373: LD_INT 1
8375: PPUSH
8376: CALL_OW 3
8380: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8381: LD_VAR 0 3
8385: PPUSH
8386: LD_VAR 0 7
8390: PPUSH
8391: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8395: LD_VAR 0 3
8399: PPUSH
8400: LD_VAR 0 6
8404: PUSH
8405: LD_VAR 0 4
8409: ARRAY
8410: PUSH
8411: LD_INT 2
8413: ARRAY
8414: PPUSH
8415: LD_VAR 0 6
8419: PUSH
8420: LD_VAR 0 4
8424: ARRAY
8425: PUSH
8426: LD_INT 3
8428: ARRAY
8429: PPUSH
8430: LD_INT 8
8432: PPUSH
8433: CALL 8450 0 4
// end ;
8437: GO 8340
8439: POP
8440: POP
// end ;
8441: GO 8298
8443: POP
8444: POP
// end ; end ;
8445: LD_VAR 0 2
8449: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8450: LD_INT 0
8452: PPUSH
8453: PPUSH
8454: PPUSH
8455: PPUSH
8456: PPUSH
8457: PPUSH
8458: PPUSH
8459: PPUSH
8460: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8461: LD_VAR 0 1
8465: NOT
8466: PUSH
8467: LD_VAR 0 2
8471: PPUSH
8472: LD_VAR 0 3
8476: PPUSH
8477: CALL_OW 488
8481: NOT
8482: OR
8483: PUSH
8484: LD_VAR 0 4
8488: NOT
8489: OR
8490: IFFALSE 8494
// exit ;
8492: GO 8834
// list := [ ] ;
8494: LD_ADDR_VAR 0 13
8498: PUSH
8499: EMPTY
8500: ST_TO_ADDR
// if x - r < 0 then
8501: LD_VAR 0 2
8505: PUSH
8506: LD_VAR 0 4
8510: MINUS
8511: PUSH
8512: LD_INT 0
8514: LESS
8515: IFFALSE 8527
// min_x := 0 else
8517: LD_ADDR_VAR 0 7
8521: PUSH
8522: LD_INT 0
8524: ST_TO_ADDR
8525: GO 8543
// min_x := x - r ;
8527: LD_ADDR_VAR 0 7
8531: PUSH
8532: LD_VAR 0 2
8536: PUSH
8537: LD_VAR 0 4
8541: MINUS
8542: ST_TO_ADDR
// if y - r < 0 then
8543: LD_VAR 0 3
8547: PUSH
8548: LD_VAR 0 4
8552: MINUS
8553: PUSH
8554: LD_INT 0
8556: LESS
8557: IFFALSE 8569
// min_y := 0 else
8559: LD_ADDR_VAR 0 8
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
8567: GO 8585
// min_y := y - r ;
8569: LD_ADDR_VAR 0 8
8573: PUSH
8574: LD_VAR 0 3
8578: PUSH
8579: LD_VAR 0 4
8583: MINUS
8584: ST_TO_ADDR
// max_x := x + r ;
8585: LD_ADDR_VAR 0 9
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: LD_VAR 0 4
8599: PLUS
8600: ST_TO_ADDR
// max_y := y + r ;
8601: LD_ADDR_VAR 0 10
8605: PUSH
8606: LD_VAR 0 3
8610: PUSH
8611: LD_VAR 0 4
8615: PLUS
8616: ST_TO_ADDR
// for _x = min_x to max_x do
8617: LD_ADDR_VAR 0 11
8621: PUSH
8622: DOUBLE
8623: LD_VAR 0 7
8627: DEC
8628: ST_TO_ADDR
8629: LD_VAR 0 9
8633: PUSH
8634: FOR_TO
8635: IFFALSE 8752
// for _y = min_y to max_y do
8637: LD_ADDR_VAR 0 12
8641: PUSH
8642: DOUBLE
8643: LD_VAR 0 8
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 10
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8748
// begin if not ValidHex ( _x , _y ) then
8657: LD_VAR 0 11
8661: PPUSH
8662: LD_VAR 0 12
8666: PPUSH
8667: CALL_OW 488
8671: NOT
8672: IFFALSE 8676
// continue ;
8674: GO 8654
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
8676: LD_VAR 0 11
8680: PPUSH
8681: LD_VAR 0 12
8685: PPUSH
8686: CALL_OW 351
8690: PUSH
8691: LD_VAR 0 11
8695: PPUSH
8696: LD_VAR 0 12
8700: PPUSH
8701: CALL_OW 554
8705: AND
8706: IFFALSE 8746
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
8708: LD_ADDR_VAR 0 13
8712: PUSH
8713: LD_VAR 0 13
8717: PPUSH
8718: LD_VAR 0 13
8722: PUSH
8723: LD_INT 1
8725: PLUS
8726: PPUSH
8727: LD_VAR 0 11
8731: PUSH
8732: LD_VAR 0 12
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: PPUSH
8741: CALL_OW 2
8745: ST_TO_ADDR
// end ;
8746: GO 8654
8748: POP
8749: POP
8750: GO 8634
8752: POP
8753: POP
// if not list then
8754: LD_VAR 0 13
8758: NOT
8759: IFFALSE 8763
// exit ;
8761: GO 8834
// for i in list do
8763: LD_ADDR_VAR 0 6
8767: PUSH
8768: LD_VAR 0 13
8772: PUSH
8773: FOR_IN
8774: IFFALSE 8832
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
8776: LD_VAR 0 1
8780: PPUSH
8781: LD_STRING M
8783: PUSH
8784: LD_VAR 0 6
8788: PUSH
8789: LD_INT 1
8791: ARRAY
8792: PUSH
8793: LD_VAR 0 6
8797: PUSH
8798: LD_INT 2
8800: ARRAY
8801: PUSH
8802: LD_INT 0
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 0
8810: PUSH
8811: LD_INT 0
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: LIST
8822: PUSH
8823: EMPTY
8824: LIST
8825: PPUSH
8826: CALL_OW 447
8830: GO 8773
8832: POP
8833: POP
// end ;
8834: LD_VAR 0 5
8838: RET
