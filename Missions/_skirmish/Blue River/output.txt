// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// PlaceSeeing ( 0 , 0 , 7 , - 37963 ) ;
  11: LD_INT 0
  13: PPUSH
  14: LD_INT 0
  16: PPUSH
  17: LD_INT 7
  19: PPUSH
  20: LD_INT 37963
  22: NEG
  23: PPUSH
  24: CALL_OW 330
// RemoveSeeing ( 0 , 0 , 7 ) ;
  28: LD_INT 0
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 7
  36: PPUSH
  37: CALL_OW 331
// PrepareBase ;
  41: CALL 514 0 0
// Action ;
  45: CALL 54 0 0
// SaveForQuickRestart ;
  49: CALL_OW 22
// end ;
  53: END
// function Action ; var un , f , i ; begin
  54: LD_INT 0
  56: PPUSH
  57: PPUSH
  58: PPUSH
  59: PPUSH
// SetBName ( brave , brave ) ;
  60: LD_INT 1
  62: PPUSH
  63: LD_STRING brave
  65: PPUSH
  66: CALL_OW 500
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// SetResourceType ( GetBase ( brave ) , mat_cans , [ 6000 , 4500 , 3000 ] [ Difficulty ] ) ;
  83: LD_INT 1
  85: PPUSH
  86: CALL_OW 274
  90: PPUSH
  91: LD_INT 1
  93: PPUSH
  94: LD_INT 6000
  96: PUSH
  97: LD_INT 4500
  99: PUSH
 100: LD_INT 3000
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: LIST
 107: PUSH
 108: LD_OWVAR 67
 112: ARRAY
 113: PPUSH
 114: CALL_OW 277
// InGameOn ;
 118: CALL_OW 8
// CenterNowOnUnits ( brave ) ;
 122: LD_INT 1
 124: PPUSH
 125: CALL_OW 87
// Say ( com , DJack1 ) ;
 129: LD_EXP 1
 133: PPUSH
 134: LD_STRING DJack1
 136: PPUSH
 137: CALL_OW 88
// Say ( k1 , DUn1 ) ;
 141: LD_EXP 3
 145: PPUSH
 146: LD_STRING DUn1
 148: PPUSH
 149: CALL_OW 88
// Say ( com , DJack2 ) ;
 153: LD_EXP 1
 157: PPUSH
 158: LD_STRING DJack2
 160: PPUSH
 161: CALL_OW 88
// Say ( k1 , DUn2 ) ;
 165: LD_EXP 3
 169: PPUSH
 170: LD_STRING DUn2
 172: PPUSH
 173: CALL_OW 88
// Say ( com , DJack3 ) ;
 177: LD_EXP 1
 181: PPUSH
 182: LD_STRING DJack3
 184: PPUSH
 185: CALL_OW 88
// uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := 1 ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_INT 1
 204: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 0 ) ;
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 0
 213: PPUSH
 214: CALL_OW 380
// hc_name :=  ;
 218: LD_ADDR_OWVAR 26
 222: PUSH
 223: LD_STRING 
 225: ST_TO_ADDR
// un := CreateHuman ;
 226: LD_ADDR_VAR 0 2
 230: PUSH
 231: CALL_OW 44
 235: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
 236: LD_INT 105
 238: PPUSH
 239: CALL_OW 67
// SayRadio ( un , DRadio1 ) ;
 243: LD_VAR 0 2
 247: PPUSH
 248: LD_STRING DRadio1
 250: PPUSH
 251: CALL_OW 94
// Say ( com , DJack4 ) ;
 255: LD_EXP 1
 259: PPUSH
 260: LD_STRING DJack4
 262: PPUSH
 263: CALL_OW 88
// SayRadio ( un , DRadio2 ) ;
 267: LD_VAR 0 2
 271: PPUSH
 272: LD_STRING DRadio2
 274: PPUSH
 275: CALL_OW 94
// Wait ( 0 0$01 ) ;
 279: LD_INT 35
 281: PPUSH
 282: CALL_OW 67
// SayRadio ( doc , DDoc1 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_STRING DDoc1
 293: PPUSH
 294: CALL_OW 94
// Say ( com , DJack5 ) ;
 298: LD_EXP 1
 302: PPUSH
 303: LD_STRING DJack5
 305: PPUSH
 306: CALL_OW 88
// SayRadio ( doc , DDoc2 ) ;
 310: LD_EXP 2
 314: PPUSH
 315: LD_STRING DDoc2
 317: PPUSH
 318: CALL_OW 94
// SayRadio ( un , DRadio3 ) ;
 322: LD_VAR 0 2
 326: PPUSH
 327: LD_STRING DRadio3
 329: PPUSH
 330: CALL_OW 94
// Say ( com , DJack6 ) ;
 334: LD_EXP 1
 338: PPUSH
 339: LD_STRING DJack6
 341: PPUSH
 342: CALL_OW 88
// f := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
 346: LD_ADDR_VAR 0 3
 350: PUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 7
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 21
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: ST_TO_ADDR
// for i = 2 to f do
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: DOUBLE
 386: LD_INT 2
 388: DEC
 389: ST_TO_ADDR
 390: LD_VAR 0 3
 394: PUSH
 395: FOR_TO
 396: IFFALSE 453
// begin ComExitBuilding ( f [ i ] ) ;
 398: LD_VAR 0 3
 402: PUSH
 403: LD_VAR 0 4
 407: ARRAY
 408: PPUSH
 409: CALL_OW 122
// AddComMoveToArea ( f [ i ] , act_area ) ;
 413: LD_VAR 0 3
 417: PUSH
 418: LD_VAR 0 4
 422: ARRAY
 423: PPUSH
 424: LD_INT 7
 426: PPUSH
 427: CALL_OW 173
// AddComTurnUnit ( f [ i ] , com ) ;
 431: LD_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ARRAY
 441: PPUSH
 442: LD_EXP 1
 446: PPUSH
 447: CALL_OW 179
// end ;
 451: GO 395
 453: POP
 454: POP
// ComExitBuilding ( com ) ;
 455: LD_EXP 1
 459: PPUSH
 460: CALL_OW 122
// AddComTurnXY ( com , 45 , 32 ) ;
 464: LD_EXP 1
 468: PPUSH
 469: LD_INT 45
 471: PPUSH
 472: LD_INT 32
 474: PPUSH
 475: CALL_OW 178
// Wait ( 0 0$03 ) ;
 479: LD_INT 105
 481: PPUSH
 482: CALL_OW 67
// Say ( com , DJack7 ) ;
 486: LD_EXP 1
 490: PPUSH
 491: LD_STRING DJack7
 493: PPUSH
 494: CALL_OW 88
// InGameOff ;
 498: CALL_OW 9
// ChangeMissionObjectives ( TDef ) ;
 502: LD_STRING TDef
 504: PPUSH
 505: CALL_OW 337
// end ; end_of_file
 509: LD_VAR 0 1
 513: RET
// export com , doc , k1 ; export function PrepareBase ; var i , un , skill ; begin
 514: LD_INT 0
 516: PPUSH
 517: PPUSH
 518: PPUSH
 519: PPUSH
// PlaceSeeing ( 30 , 14 , 7 , 20 ) ;
 520: LD_INT 30
 522: PPUSH
 523: LD_INT 14
 525: PPUSH
 526: LD_INT 7
 528: PPUSH
 529: LD_INT 20
 531: PPUSH
 532: CALL_OW 330
// PlaceSeeing ( 49 , 17 , 7 , 20 ) ;
 536: LD_INT 49
 538: PPUSH
 539: LD_INT 17
 541: PPUSH
 542: LD_INT 7
 544: PPUSH
 545: LD_INT 20
 547: PPUSH
 548: CALL_OW 330
// PlaceSeeing ( 35 , 46 , 7 , 20 ) ;
 552: LD_INT 35
 554: PPUSH
 555: LD_INT 46
 557: PPUSH
 558: LD_INT 7
 560: PPUSH
 561: LD_INT 20
 563: PPUSH
 564: CALL_OW 330
// PlaceSeeing ( 70 , 39 , 7 , 20 ) ;
 568: LD_INT 70
 570: PPUSH
 571: LD_INT 39
 573: PPUSH
 574: LD_INT 7
 576: PPUSH
 577: LD_INT 20
 579: PPUSH
 580: CALL_OW 330
// RemoveSeeing ( 30 , 14 , 7 ) ;
 584: LD_INT 30
 586: PPUSH
 587: LD_INT 14
 589: PPUSH
 590: LD_INT 7
 592: PPUSH
 593: CALL_OW 331
// RemoveSeeing ( 49 , 17 , 7 ) ;
 597: LD_INT 49
 599: PPUSH
 600: LD_INT 17
 602: PPUSH
 603: LD_INT 7
 605: PPUSH
 606: CALL_OW 331
// RemoveSeeing ( 35 , 46 , 7 ) ;
 610: LD_INT 35
 612: PPUSH
 613: LD_INT 46
 615: PPUSH
 616: LD_INT 7
 618: PPUSH
 619: CALL_OW 331
// RemoveSeeing ( 70 , 39 , 7 ) ;
 623: LD_INT 70
 625: PPUSH
 626: LD_INT 39
 628: PPUSH
 629: LD_INT 7
 631: PPUSH
 632: CALL_OW 331
// uc_side := 7 ;
 636: LD_ADDR_OWVAR 20
 640: PUSH
 641: LD_INT 7
 643: ST_TO_ADDR
// uc_nation := 1 ;
 644: LD_ADDR_OWVAR 21
 648: PUSH
 649: LD_INT 1
 651: ST_TO_ADDR
// if Difficulty < 3 then
 652: LD_OWVAR 67
 656: PUSH
 657: LD_INT 3
 659: LESS
 660: IFFALSE 761
// begin for i = 1 to 2 do
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: DOUBLE
 668: LD_INT 1
 670: DEC
 671: ST_TO_ADDR
 672: LD_INT 2
 674: PUSH
 675: FOR_TO
 676: IFFALSE 757
// begin vc_chassis := us_heavy_tracked ;
 678: LD_ADDR_OWVAR 37
 682: PUSH
 683: LD_INT 4
 685: ST_TO_ADDR
// vc_engine := 3 ;
 686: LD_ADDR_OWVAR 39
 690: PUSH
 691: LD_INT 3
 693: ST_TO_ADDR
// vc_control := control_computer ;
 694: LD_ADDR_OWVAR 38
 698: PUSH
 699: LD_INT 3
 701: ST_TO_ADDR
// vc_weapon := us_double_laser ;
 702: LD_ADDR_OWVAR 40
 706: PUSH
 707: LD_INT 10
 709: ST_TO_ADDR
// un := CreateVehicle ;
 710: LD_ADDR_VAR 0 3
 714: PUSH
 715: CALL_OW 45
 719: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 720: LD_VAR 0 3
 724: PPUSH
 725: LD_INT 0
 727: PPUSH
 728: LD_INT 5
 730: PPUSH
 731: CALL_OW 12
 735: PPUSH
 736: CALL_OW 233
// PlaceUnitArea ( un , base_spawn , false ) ;
 740: LD_VAR 0 3
 744: PPUSH
 745: LD_INT 6
 747: PPUSH
 748: LD_INT 0
 750: PPUSH
 751: CALL_OW 49
// end ;
 755: GO 675
 757: POP
 758: POP
// end else
 759: GO 850
// begin vc_chassis := us_medium_tracked ;
 761: LD_ADDR_OWVAR 37
 765: PUSH
 766: LD_INT 3
 768: ST_TO_ADDR
// vc_engine := engine_combustion ;
 769: LD_ADDR_OWVAR 39
 773: PUSH
 774: LD_INT 1
 776: ST_TO_ADDR
// vc_control := control_manual ;
 777: LD_ADDR_OWVAR 38
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
 785: LD_ADDR_OWVAR 40
 789: PUSH
 790: LD_INT 4
 792: ST_TO_ADDR
// un := CreateVehicle ;
 793: LD_ADDR_VAR 0 3
 797: PUSH
 798: CALL_OW 45
 802: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 803: LD_VAR 0 3
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: LD_INT 5
 813: PPUSH
 814: CALL_OW 12
 818: PPUSH
 819: CALL_OW 233
// SetFuel ( un , 75 ) ;
 823: LD_VAR 0 3
 827: PPUSH
 828: LD_INT 75
 830: PPUSH
 831: CALL_OW 240
// PlaceUnitArea ( un , base_spawn , false ) ;
 835: LD_VAR 0 3
 839: PPUSH
 840: LD_INT 6
 842: PPUSH
 843: LD_INT 0
 845: PPUSH
 846: CALL_OW 49
// end ; skill := [ 8 , 7 , 6 ] [ Difficulty ] ;
 850: LD_ADDR_VAR 0 4
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: LD_INT 7
 860: PUSH
 861: LD_INT 6
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_OWVAR 67
 873: ARRAY
 874: ST_TO_ADDR
// hc_importance := 100 ;
 875: LD_ADDR_OWVAR 32
 879: PUSH
 880: LD_INT 100
 882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 883: LD_INT 1
 885: PPUSH
 886: LD_INT 1
 888: PPUSH
 889: LD_VAR 0 4
 893: PPUSH
 894: CALL_OW 380
// hc_name := Jack Collins ;
 898: LD_ADDR_OWVAR 26
 902: PUSH
 903: LD_STRING Jack Collins
 905: ST_TO_ADDR
// com := CreateHuman ;
 906: LD_ADDR_EXP 1
 910: PUSH
 911: CALL_OW 44
 915: ST_TO_ADDR
// PlaceHumanInUnit ( com , brave ) ;
 916: LD_EXP 1
 920: PPUSH
 921: LD_INT 1
 923: PPUSH
 924: CALL_OW 52
// hc_importance := 0 ;
 928: LD_ADDR_OWVAR 32
 932: PUSH
 933: LD_INT 0
 935: ST_TO_ADDR
// hc_gallery :=  ;
 936: LD_ADDR_OWVAR 33
 940: PUSH
 941: LD_STRING 
 943: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 4
 954: PPUSH
 955: CALL_OW 380
// hc_name := Thomas Jackson ;
 959: LD_ADDR_OWVAR 26
 963: PUSH
 964: LD_STRING Thomas Jackson
 966: ST_TO_ADDR
// k1 := CreateHuman ;
 967: LD_ADDR_EXP 3
 971: PUSH
 972: CALL_OW 44
 976: ST_TO_ADDR
// PlaceHumanInUnit ( k1 , brave ) ;
 977: LD_EXP 3
 981: PPUSH
 982: LD_INT 1
 984: PPUSH
 985: CALL_OW 52
// hc_name :=  ;
 989: LD_ADDR_OWVAR 26
 993: PUSH
 994: LD_STRING 
 996: ST_TO_ADDR
// for i = 1 to [ 9 , 8 , 7 ] [ Difficulty ] do
 997: LD_ADDR_VAR 0 2
1001: PUSH
1002: DOUBLE
1003: LD_INT 1
1005: DEC
1006: ST_TO_ADDR
1007: LD_INT 9
1009: PUSH
1010: LD_INT 8
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_OWVAR 67
1025: ARRAY
1026: PUSH
1027: FOR_TO
1028: IFFALSE 1199
// begin Randomize ;
1030: CALL_OW 10
// uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1034: LD_ADDR_OWVAR 21
1038: PUSH
1039: LD_INT 1
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 2
1054: PPUSH
1055: CALL_OW 12
1059: ARRAY
1060: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , skill ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 1
1066: PPUSH
1067: LD_INT 4
1069: PPUSH
1070: CALL_OW 12
1074: PPUSH
1075: LD_VAR 0 4
1079: PPUSH
1080: CALL_OW 380
// un := CreateHuman ;
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: CALL_OW 44
1093: ST_TO_ADDR
// case GetClass ( un ) of 1 :
1094: LD_VAR 0 3
1098: PPUSH
1099: CALL_OW 257
1103: PUSH
1104: LD_INT 1
1106: DOUBLE
1107: EQUAL
1108: IFTRUE 1112
1110: GO 1127
1112: POP
// PlaceHumanInUnit ( un , br ) ; 2 :
1113: LD_VAR 0 3
1117: PPUSH
1118: LD_INT 21
1120: PPUSH
1121: CALL_OW 52
1125: GO 1197
1127: LD_INT 2
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1150
1135: POP
// PlaceHumanInUnit ( un , brave ) ; 3 :
1136: LD_VAR 0 3
1140: PPUSH
1141: LD_INT 1
1143: PPUSH
1144: CALL_OW 52
1148: GO 1197
1150: LD_INT 3
1152: DOUBLE
1153: EQUAL
1154: IFTRUE 1158
1156: GO 1173
1158: POP
// PlaceHumanInUnit ( un , fac ) ; 4 :
1159: LD_VAR 0 3
1163: PPUSH
1164: LD_INT 38
1166: PPUSH
1167: CALL_OW 52
1171: GO 1197
1173: LD_INT 4
1175: DOUBLE
1176: EQUAL
1177: IFTRUE 1181
1179: GO 1196
1181: POP
// PlaceHumanInUnit ( un , lab ) ; end ;
1182: LD_VAR 0 3
1186: PPUSH
1187: LD_INT 36
1189: PPUSH
1190: CALL_OW 52
1194: GO 1197
1196: POP
// end ;
1197: GO 1027
1199: POP
1200: POP
// uc_side := 2 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 2
1208: ST_TO_ADDR
// uc_nation := 2 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 2
1216: ST_TO_ADDR
// hc_name := _ ;
1217: LD_ADDR_OWVAR 26
1221: PUSH
1222: LD_STRING _
1224: ST_TO_ADDR
// hc_gallery :=  ;
1225: LD_ADDR_OWVAR 33
1229: PUSH
1230: LD_STRING 
1232: ST_TO_ADDR
// hc_class := 4 ;
1233: LD_ADDR_OWVAR 28
1237: PUSH
1238: LD_INT 4
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// doc := CreateHuman ;
1249: LD_ADDR_EXP 2
1253: PUSH
1254: CALL_OW 44
1258: ST_TO_ADDR
// end ; end_of_file
1259: LD_VAR 0 1
1263: RET
// export function Attack ( num ) ; var i , un , tmp ; begin
1264: LD_INT 0
1266: PPUSH
1267: PPUSH
1268: PPUSH
1269: PPUSH
// uc_side := 2 ;
1270: LD_ADDR_OWVAR 20
1274: PUSH
1275: LD_INT 2
1277: ST_TO_ADDR
// uc_nation := 2 ;
1278: LD_ADDR_OWVAR 21
1282: PUSH
1283: LD_INT 2
1285: ST_TO_ADDR
// tmp := [ ] ;
1286: LD_ADDR_VAR 0 5
1290: PUSH
1291: EMPTY
1292: ST_TO_ADDR
// hc_skills := [ [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] ] ;
1293: LD_ADDR_OWVAR 31
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: LD_INT 6
1303: PUSH
1304: LD_INT 10
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_OWVAR 67
1316: ARRAY
1317: PUSH
1318: LD_INT 3
1320: PUSH
1321: LD_INT 6
1323: PUSH
1324: LD_INT 10
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: LIST
1331: PUSH
1332: LD_OWVAR 67
1336: ARRAY
1337: PUSH
1338: LD_INT 3
1340: PUSH
1341: LD_INT 6
1343: PUSH
1344: LD_INT 10
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_OWVAR 67
1356: ARRAY
1357: PUSH
1358: LD_INT 3
1360: PUSH
1361: LD_INT 6
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: LD_OWVAR 67
1376: ARRAY
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: ST_TO_ADDR
// if FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) then
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 22
1389: PUSH
1390: LD_INT 7
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: PPUSH
1397: CALL_OW 70
1401: IFFALSE 1442
// for i in FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) do
1403: LD_ADDR_VAR 0 3
1407: PUSH
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 22
1413: PUSH
1414: LD_INT 7
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PPUSH
1421: CALL_OW 70
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1440
// RemoveUnit ( i ) ;
1429: LD_VAR 0 3
1433: PPUSH
1434: CALL_OW 64
1438: GO 1426
1440: POP
1441: POP
// if FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) then
1442: LD_INT 5
1444: PPUSH
1445: LD_INT 22
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 70
1459: IFFALSE 1500
// for i in FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) do
1461: LD_ADDR_VAR 0 3
1465: PUSH
1466: LD_INT 5
1468: PPUSH
1469: LD_INT 22
1471: PUSH
1472: LD_INT 7
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PPUSH
1479: CALL_OW 70
1483: PUSH
1484: FOR_IN
1485: IFFALSE 1498
// RemoveUnit ( i ) ;
1487: LD_VAR 0 3
1491: PPUSH
1492: CALL_OW 64
1496: GO 1484
1498: POP
1499: POP
// if FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) then
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 22
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 70
1517: IFFALSE 1558
// for i in FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) do
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_INT 1
1526: PPUSH
1527: LD_INT 22
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PPUSH
1537: CALL_OW 70
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1556
// RemoveUnit ( i ) ;
1545: LD_VAR 0 3
1549: PPUSH
1550: CALL_OW 64
1554: GO 1542
1556: POP
1557: POP
// if FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) then
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 7
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL_OW 70
1575: IFFALSE 1616
// for i in FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) do
1577: LD_ADDR_VAR 0 3
1581: PUSH
1582: LD_INT 2
1584: PPUSH
1585: LD_INT 22
1587: PUSH
1588: LD_INT 7
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 70
1599: PUSH
1600: FOR_IN
1601: IFFALSE 1614
// RemoveUnit ( i ) ;
1603: LD_VAR 0 3
1607: PPUSH
1608: CALL_OW 64
1612: GO 1600
1614: POP
1615: POP
// case num of 1 :
1616: LD_VAR 0 1
1620: PUSH
1621: LD_INT 1
1623: DOUBLE
1624: EQUAL
1625: IFTRUE 1629
1627: GO 1882
1629: POP
// begin for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: DOUBLE
1636: LD_INT 1
1638: DEC
1639: ST_TO_ADDR
1640: LD_INT 5
1642: PUSH
1643: LD_INT 6
1645: PUSH
1646: LD_INT 6
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_OWVAR 67
1658: ARRAY
1659: PUSH
1660: FOR_TO
1661: IFFALSE 1753
// begin uc_nation := 0 ;
1663: LD_ADDR_OWVAR 21
1667: PUSH
1668: LD_INT 0
1670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1671: LD_ADDR_OWVAR 28
1675: PUSH
1676: LD_INT 15
1678: ST_TO_ADDR
// hc_gallery :=  ;
1679: LD_ADDR_OWVAR 33
1683: PUSH
1684: LD_STRING 
1686: ST_TO_ADDR
// hc_name :=  ;
1687: LD_ADDR_OWVAR 26
1691: PUSH
1692: LD_STRING 
1694: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1695: LD_ADDR_OWVAR 29
1699: PUSH
1700: LD_INT 16
1702: PUSH
1703: LD_INT 12
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// un := CreateHuman ;
1710: LD_ADDR_VAR 0 4
1714: PUSH
1715: CALL_OW 44
1719: ST_TO_ADDR
// PlaceUnitArea ( un , north_spawn , false ) ;
1720: LD_VAR 0 4
1724: PPUSH
1725: LD_INT 1
1727: PPUSH
1728: LD_INT 0
1730: PPUSH
1731: CALL_OW 49
// tmp := tmp ^ un ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_VAR 0 4
1749: ADD
1750: ST_TO_ADDR
// end ;
1751: GO 1660
1753: POP
1754: POP
// for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
1755: LD_ADDR_VAR 0 3
1759: PUSH
1760: DOUBLE
1761: LD_INT 1
1763: DEC
1764: ST_TO_ADDR
1765: LD_INT 4
1767: PUSH
1768: LD_INT 5
1770: PUSH
1771: LD_INT 5
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: PUSH
1779: LD_OWVAR 67
1783: ARRAY
1784: PUSH
1785: FOR_TO
1786: IFFALSE 1878
// begin uc_nation := 0 ;
1788: LD_ADDR_OWVAR 21
1792: PUSH
1793: LD_INT 0
1795: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1796: LD_ADDR_OWVAR 28
1800: PUSH
1801: LD_INT 15
1803: ST_TO_ADDR
// hc_gallery :=  ;
1804: LD_ADDR_OWVAR 33
1808: PUSH
1809: LD_STRING 
1811: ST_TO_ADDR
// hc_name :=  ;
1812: LD_ADDR_OWVAR 26
1816: PUSH
1817: LD_STRING 
1819: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1820: LD_ADDR_OWVAR 29
1824: PUSH
1825: LD_INT 16
1827: PUSH
1828: LD_INT 12
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: ST_TO_ADDR
// un := CreateHuman ;
1835: LD_ADDR_VAR 0 4
1839: PUSH
1840: CALL_OW 44
1844: ST_TO_ADDR
// PlaceUnitArea ( un , east2_spawn , false ) ;
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 49
// tmp := tmp ^ un ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_VAR 0 4
1874: ADD
1875: ST_TO_ADDR
// end ;
1876: GO 1785
1878: POP
1879: POP
// end ; 2 :
1880: GO 2660
1882: LD_INT 2
1884: DOUBLE
1885: EQUAL
1886: IFTRUE 1890
1888: GO 2018
1890: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
1891: LD_ADDR_VAR 0 3
1895: PUSH
1896: DOUBLE
1897: LD_INT 1
1899: DEC
1900: ST_TO_ADDR
1901: LD_INT 3
1903: PUSH
1904: LD_INT 4
1906: PUSH
1907: LD_INT 5
1909: PUSH
1910: EMPTY
1911: LIST
1912: LIST
1913: LIST
1914: PUSH
1915: LD_OWVAR 67
1919: ARRAY
1920: PUSH
1921: FOR_TO
1922: IFFALSE 2014
// begin uc_nation := 0 ;
1924: LD_ADDR_OWVAR 21
1928: PUSH
1929: LD_INT 0
1931: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
1932: LD_ADDR_OWVAR 28
1936: PUSH
1937: LD_INT 17
1939: ST_TO_ADDR
// hc_gallery :=  ;
1940: LD_ADDR_OWVAR 33
1944: PUSH
1945: LD_STRING 
1947: ST_TO_ADDR
// hc_name :=  ;
1948: LD_ADDR_OWVAR 26
1952: PUSH
1953: LD_STRING 
1955: ST_TO_ADDR
// hc_attr := [ 22 , 12 ] ;
1956: LD_ADDR_OWVAR 29
1960: PUSH
1961: LD_INT 22
1963: PUSH
1964: LD_INT 12
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: ST_TO_ADDR
// un := CreateHuman ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: CALL_OW 44
1980: ST_TO_ADDR
// PlaceUnitArea ( un , west_spawn , false ) ;
1981: LD_VAR 0 4
1985: PPUSH
1986: LD_INT 3
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 49
// tmp := tmp ^ un ;
1996: LD_ADDR_VAR 0 5
2000: PUSH
2001: LD_VAR 0 5
2005: PUSH
2006: LD_VAR 0 4
2010: ADD
2011: ST_TO_ADDR
// end ;
2012: GO 1921
2014: POP
2015: POP
// end ; 3 :
2016: GO 2660
2018: LD_INT 3
2020: DOUBLE
2021: EQUAL
2022: IFTRUE 2026
2024: GO 2186
2026: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_INT 4
2039: PUSH
2040: LD_INT 5
2042: PUSH
2043: LD_INT 6
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PUSH
2051: LD_OWVAR 67
2055: ARRAY
2056: PUSH
2057: FOR_TO
2058: IFFALSE 2182
// begin uc_nation := 2 ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 2
2067: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2068: LD_ADDR_OWVAR 37
2072: PUSH
2073: LD_INT 14
2075: ST_TO_ADDR
// vc_engine := 3 ;
2076: LD_ADDR_OWVAR 39
2080: PUSH
2081: LD_INT 3
2083: ST_TO_ADDR
// vc_control := control_apeman ;
2084: LD_ADDR_OWVAR 38
2088: PUSH
2089: LD_INT 5
2091: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 27
2099: PUSH
2100: LD_INT 28
2102: PUSH
2103: LD_INT 29
2105: PUSH
2106: LD_INT 91
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PPUSH
2121: CALL_OW 12
2125: ARRAY
2126: ST_TO_ADDR
// un := CreateVehicle ;
2127: LD_ADDR_VAR 0 4
2131: PUSH
2132: CALL_OW 45
2136: ST_TO_ADDR
// tmp := tmp ^ un ;
2137: LD_ADDR_VAR 0 5
2141: PUSH
2142: LD_VAR 0 5
2146: PUSH
2147: LD_VAR 0 4
2151: ADD
2152: ST_TO_ADDR
// SetDir ( un , 0 ) ;
2153: LD_VAR 0 4
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 233
// PlaceUnitArea ( un , south_spawn , false ) ;
2165: LD_VAR 0 4
2169: PPUSH
2170: LD_INT 2
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: GO 2057
2182: POP
2183: POP
// end ; 4 :
2184: GO 2660
2186: LD_INT 4
2188: DOUBLE
2189: EQUAL
2190: IFTRUE 2194
2192: GO 2362
2194: POP
// begin for i = 1 to Rand ( 3 , [ 4 , 5 , 6 ] [ Difficulty ] ) do
2195: LD_ADDR_VAR 0 3
2199: PUSH
2200: DOUBLE
2201: LD_INT 1
2203: DEC
2204: ST_TO_ADDR
2205: LD_INT 3
2207: PPUSH
2208: LD_INT 4
2210: PUSH
2211: LD_INT 5
2213: PUSH
2214: LD_INT 6
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: CALL_OW 12
2232: PUSH
2233: FOR_TO
2234: IFFALSE 2358
// begin uc_nation := 2 ;
2236: LD_ADDR_OWVAR 21
2240: PUSH
2241: LD_INT 2
2243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 14
2251: ST_TO_ADDR
// vc_engine := 3 ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 3
2259: ST_TO_ADDR
// vc_control := control_apeman ;
2260: LD_ADDR_OWVAR 38
2264: PUSH
2265: LD_INT 5
2267: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2268: LD_ADDR_OWVAR 40
2272: PUSH
2273: LD_INT 27
2275: PUSH
2276: LD_INT 28
2278: PUSH
2279: LD_INT 29
2281: PUSH
2282: LD_INT 91
2284: PUSH
2285: EMPTY
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: PUSH
2291: LD_INT 1
2293: PPUSH
2294: LD_INT 4
2296: PPUSH
2297: CALL_OW 12
2301: ARRAY
2302: ST_TO_ADDR
// un := CreateVehicle ;
2303: LD_ADDR_VAR 0 4
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// tmp := tmp ^ un ;
2313: LD_ADDR_VAR 0 5
2317: PUSH
2318: LD_VAR 0 5
2322: PUSH
2323: LD_VAR 0 4
2327: ADD
2328: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2329: LD_VAR 0 4
2333: PPUSH
2334: LD_INT 3
2336: PPUSH
2337: CALL_OW 233
// PlaceUnitArea ( un , north_spawn , false ) ;
2341: LD_VAR 0 4
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_INT 0
2351: PPUSH
2352: CALL_OW 49
// end ;
2356: GO 2233
2358: POP
2359: POP
// end ; 5 :
2360: GO 2660
2362: LD_INT 5
2364: DOUBLE
2365: EQUAL
2366: IFTRUE 2370
2368: GO 2530
2370: POP
// begin for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: DOUBLE
2377: LD_INT 1
2379: DEC
2380: ST_TO_ADDR
2381: LD_INT 3
2383: PUSH
2384: LD_INT 4
2386: PUSH
2387: LD_INT 4
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: LD_OWVAR 67
2399: ARRAY
2400: PUSH
2401: FOR_TO
2402: IFFALSE 2526
// begin uc_nation := 2 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 2
2411: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2412: LD_ADDR_OWVAR 37
2416: PUSH
2417: LD_INT 14
2419: ST_TO_ADDR
// vc_engine := 3 ;
2420: LD_ADDR_OWVAR 39
2424: PUSH
2425: LD_INT 3
2427: ST_TO_ADDR
// vc_control := control_apeman ;
2428: LD_ADDR_OWVAR 38
2432: PUSH
2433: LD_INT 5
2435: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2436: LD_ADDR_OWVAR 40
2440: PUSH
2441: LD_INT 27
2443: PUSH
2444: LD_INT 28
2446: PUSH
2447: LD_INT 29
2449: PUSH
2450: LD_INT 91
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 1
2461: PPUSH
2462: LD_INT 4
2464: PPUSH
2465: CALL_OW 12
2469: ARRAY
2470: ST_TO_ADDR
// un := CreateVehicle ;
2471: LD_ADDR_VAR 0 4
2475: PUSH
2476: CALL_OW 45
2480: ST_TO_ADDR
// tmp := tmp ^ un ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_VAR 0 4
2495: ADD
2496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 4
2504: PPUSH
2505: CALL_OW 233
// PlaceUnitArea ( un , east2_spawn , false ) ;
2509: LD_VAR 0 4
2513: PPUSH
2514: LD_INT 5
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: CALL_OW 49
// end ;
2524: GO 2401
2526: POP
2527: POP
// end ; 6 :
2528: GO 2660
2530: LD_INT 6
2532: DOUBLE
2533: EQUAL
2534: IFTRUE 2538
2536: GO 2659
2538: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: DOUBLE
2545: LD_INT 1
2547: DEC
2548: ST_TO_ADDR
2549: LD_INT 2
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 4
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_OWVAR 67
2567: ARRAY
2568: PUSH
2569: FOR_TO
2570: IFFALSE 2655
// begin uc_nation := 2 ;
2572: LD_ADDR_OWVAR 21
2576: PUSH
2577: LD_INT 2
2579: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
2580: LD_ADDR_OWVAR 37
2584: PUSH
2585: LD_INT 11
2587: ST_TO_ADDR
// vc_engine := engine_combustion ;
2588: LD_ADDR_OWVAR 39
2592: PUSH
2593: LD_INT 1
2595: ST_TO_ADDR
// vc_control := control_apeman ;
2596: LD_ADDR_OWVAR 38
2600: PUSH
2601: LD_INT 5
2603: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
2604: LD_ADDR_OWVAR 40
2608: PUSH
2609: LD_INT 24
2611: ST_TO_ADDR
// un := CreateVehicle ;
2612: LD_ADDR_VAR 0 4
2616: PUSH
2617: CALL_OW 45
2621: ST_TO_ADDR
// tmp := tmp ^ un ;
2622: LD_ADDR_VAR 0 5
2626: PUSH
2627: LD_VAR 0 5
2631: PUSH
2632: LD_VAR 0 4
2636: ADD
2637: ST_TO_ADDR
// PlaceUnitArea ( un , river , false ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_INT 8
2645: PPUSH
2646: LD_INT 0
2648: PPUSH
2649: CALL_OW 49
// end ;
2653: GO 2569
2655: POP
2656: POP
// end ; end ;
2657: GO 2660
2659: POP
// result := tmp ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 5
2669: ST_TO_ADDR
// end ;
2670: LD_VAR 0 2
2674: RET
// export function ComitSib ; var un ; begin
2675: LD_INT 0
2677: PPUSH
2678: PPUSH
// uc_side := 2 ;
2679: LD_ADDR_OWVAR 20
2683: PUSH
2684: LD_INT 2
2686: ST_TO_ADDR
// uc_nation := 2 ;
2687: LD_ADDR_OWVAR 21
2691: PUSH
2692: LD_INT 2
2694: ST_TO_ADDR
// PrepareHuman ( false , 4 , 7 ) ;
2695: LD_INT 0
2697: PPUSH
2698: LD_INT 4
2700: PPUSH
2701: LD_INT 7
2703: PPUSH
2704: CALL_OW 380
// un := CreateHuman ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: CALL_OW 44
2717: ST_TO_ADDR
// PlaceUnitArea ( un , east1_spawn , false ) ;
2718: LD_VAR 0 2
2722: PPUSH
2723: LD_INT 4
2725: PPUSH
2726: LD_INT 0
2728: PPUSH
2729: CALL_OW 49
// ComContaminate ( un , 63 , 37 ) ;
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 63
2740: PPUSH
2741: LD_INT 37
2743: PPUSH
2744: CALL_OW 158
// end ;
2748: LD_VAR 0 1
2752: RET
// export function DSay ; var i ; begin
2753: LD_INT 0
2755: PPUSH
2756: PPUSH
// Randomize ;
2757: CALL_OW 10
// i := Rand ( 1 , 8 ) ;
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: LD_INT 1
2768: PPUSH
2769: LD_INT 8
2771: PPUSH
2772: CALL_OW 12
2776: ST_TO_ADDR
// case i of 1 :
2777: LD_VAR 0 2
2781: PUSH
2782: LD_INT 1
2784: DOUBLE
2785: EQUAL
2786: IFTRUE 2790
2788: GO 2805
2790: POP
// SayRadio ( doc , DDocA1 ) ; 2 :
2791: LD_EXP 2
2795: PPUSH
2796: LD_STRING DDocA1
2798: PPUSH
2799: CALL_OW 94
2803: GO 2967
2805: LD_INT 2
2807: DOUBLE
2808: EQUAL
2809: IFTRUE 2813
2811: GO 2828
2813: POP
// SayRadio ( doc , DDocA2 ) ; 3 :
2814: LD_EXP 2
2818: PPUSH
2819: LD_STRING DDocA2
2821: PPUSH
2822: CALL_OW 94
2826: GO 2967
2828: LD_INT 3
2830: DOUBLE
2831: EQUAL
2832: IFTRUE 2836
2834: GO 2851
2836: POP
// SayRadio ( doc , DDocA3 ) ; 4 :
2837: LD_EXP 2
2841: PPUSH
2842: LD_STRING DDocA3
2844: PPUSH
2845: CALL_OW 94
2849: GO 2967
2851: LD_INT 4
2853: DOUBLE
2854: EQUAL
2855: IFTRUE 2859
2857: GO 2874
2859: POP
// SayRadio ( doc , DDocA4 ) ; 5 :
2860: LD_EXP 2
2864: PPUSH
2865: LD_STRING DDocA4
2867: PPUSH
2868: CALL_OW 94
2872: GO 2967
2874: LD_INT 5
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2897
2882: POP
// SayRadio ( doc , DDocA5 ) ; 6 :
2883: LD_EXP 2
2887: PPUSH
2888: LD_STRING DDocA5
2890: PPUSH
2891: CALL_OW 94
2895: GO 2967
2897: LD_INT 6
2899: DOUBLE
2900: EQUAL
2901: IFTRUE 2905
2903: GO 2920
2905: POP
// SayRadio ( doc , DDocA6 ) ; 7 :
2906: LD_EXP 2
2910: PPUSH
2911: LD_STRING DDocA6
2913: PPUSH
2914: CALL_OW 94
2918: GO 2967
2920: LD_INT 7
2922: DOUBLE
2923: EQUAL
2924: IFTRUE 2928
2926: GO 2943
2928: POP
// SayRadio ( doc , DDocA7 ) ; 8 :
2929: LD_EXP 2
2933: PPUSH
2934: LD_STRING DDocA7
2936: PPUSH
2937: CALL_OW 94
2941: GO 2967
2943: LD_INT 8
2945: DOUBLE
2946: EQUAL
2947: IFTRUE 2951
2949: GO 2966
2951: POP
// SayRadio ( doc , DDocA8 ) ; end ;
2952: LD_EXP 2
2956: PPUSH
2957: LD_STRING DDocA8
2959: PPUSH
2960: CALL_OW 94
2964: GO 2967
2966: POP
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// every 0 0$01 do
2972: GO 2974
2974: DISABLE
// begin display_strings := [ #tick , tick ] ;
2975: LD_ADDR_OWVAR 47
2979: PUSH
2980: LD_STRING #tick
2982: PUSH
2983: LD_OWVAR 1
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: ST_TO_ADDR
// enable ;
2992: ENABLE
// end ;
2993: END
// export pom , hover , attackN ; every 1 do
2994: GO 2996
2996: DISABLE
// begin pom := [ ] ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: EMPTY
3003: ST_TO_ADDR
// hover := [ ] ;
3004: LD_ADDR_EXP 5
3008: PUSH
3009: EMPTY
3010: ST_TO_ADDR
// attackN := 0 ;
3011: LD_ADDR_EXP 6
3015: PUSH
3016: LD_INT 0
3018: ST_TO_ADDR
// end ;
3019: END
// every 0 0$01 trigger pom do var i , f , z , target ;
3020: LD_EXP 4
3024: IFFALSE 3446
3026: GO 3028
3028: DISABLE
3029: LD_INT 0
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
// begin enable ;
3035: ENABLE
// f := FilterAllUnits ( [ f_side , 7 ] ) ;
3036: LD_ADDR_VAR 0 2
3040: PUSH
3041: LD_INT 22
3043: PUSH
3044: LD_INT 7
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: PPUSH
3051: CALL_OW 69
3055: ST_TO_ADDR
// for i = 1 to pom do
3056: LD_ADDR_VAR 0 1
3060: PUSH
3061: DOUBLE
3062: LD_INT 1
3064: DEC
3065: ST_TO_ADDR
3066: LD_EXP 4
3070: PUSH
3071: FOR_TO
3072: IFFALSE 3130
// if not HasTask ( pom [ i ] ) then
3074: LD_EXP 4
3078: PUSH
3079: LD_VAR 0 1
3083: ARRAY
3084: PPUSH
3085: CALL_OW 314
3089: NOT
3090: IFFALSE 3128
// ComAttackUnit ( pom [ i ] , NearestUnitToUnit ( f , pom [ i ] ) ) ;
3092: LD_EXP 4
3096: PUSH
3097: LD_VAR 0 1
3101: ARRAY
3102: PPUSH
3103: LD_VAR 0 2
3107: PPUSH
3108: LD_EXP 4
3112: PUSH
3113: LD_VAR 0 1
3117: ARRAY
3118: PPUSH
3119: CALL_OW 74
3123: PPUSH
3124: CALL_OW 115
3128: GO 3071
3130: POP
3131: POP
// if hover then
3132: LD_EXP 5
3136: IFFALSE 3446
// begin for i = 1 to hover do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 5
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3444
// begin if GetLives ( hover [ i ] ) < 250 then
3156: LD_EXP 5
3160: PUSH
3161: LD_VAR 0 1
3165: ARRAY
3166: PPUSH
3167: CALL_OW 256
3171: PUSH
3172: LD_INT 250
3174: LESS
3175: IFFALSE 3242
// begin for z = 1 to 1 + Difficulty do
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: DOUBLE
3183: LD_INT 1
3185: DEC
3186: ST_TO_ADDR
3187: LD_INT 1
3189: PUSH
3190: LD_OWVAR 67
3194: PLUS
3195: PUSH
3196: FOR_TO
3197: IFFALSE 3240
// MineExplosion ( GetX ( hover [ i ] ) , GetY ( hover [ i ] ) , 10 ) ;
3199: LD_EXP 5
3203: PUSH
3204: LD_VAR 0 1
3208: ARRAY
3209: PPUSH
3210: CALL_OW 250
3214: PPUSH
3215: LD_EXP 5
3219: PUSH
3220: LD_VAR 0 1
3224: ARRAY
3225: PPUSH
3226: CALL_OW 251
3230: PPUSH
3231: LD_INT 10
3233: PPUSH
3234: CALL_OW 453
3238: GO 3196
3240: POP
3241: POP
// end ; if UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) > 0 then
3242: LD_VAR 0 2
3246: PPUSH
3247: LD_INT 25
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: LD_INT 54
3262: PUSH
3263: EMPTY
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PPUSH
3274: CALL_OW 72
3278: PUSH
3279: LD_INT 0
3281: GREATER
3282: IFFALSE 3364
// begin target := UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) ;
3284: LD_ADDR_VAR 0 4
3288: PUSH
3289: LD_VAR 0 2
3293: PPUSH
3294: LD_INT 25
3296: PUSH
3297: LD_INT 2
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PUSH
3304: LD_INT 3
3306: PUSH
3307: LD_INT 54
3309: PUSH
3310: EMPTY
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 72
3325: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3326: LD_EXP 5
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PPUSH
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_EXP 5
3346: PUSH
3347: LD_VAR 0 1
3351: ARRAY
3352: PPUSH
3353: CALL_OW 74
3357: PPUSH
3358: CALL_OW 115
// end else
3362: GO 3442
// begin target := UnitFilter ( f , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) ;
3364: LD_ADDR_VAR 0 4
3368: PUSH
3369: LD_VAR 0 2
3373: PPUSH
3374: LD_INT 21
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 3
3386: PUSH
3387: LD_INT 54
3389: PUSH
3390: EMPTY
3391: LIST
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PPUSH
3401: CALL_OW 72
3405: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3406: LD_EXP 5
3410: PUSH
3411: LD_VAR 0 1
3415: ARRAY
3416: PPUSH
3417: LD_VAR 0 4
3421: PPUSH
3422: LD_EXP 5
3426: PUSH
3427: LD_VAR 0 1
3431: ARRAY
3432: PPUSH
3433: CALL_OW 74
3437: PPUSH
3438: CALL_OW 115
// end ; end ;
3442: GO 3153
3444: POP
3445: POP
// end ; end ;
3446: PPOPN 4
3448: END
// every 3 3$10 do var i , un ;
3449: GO 3451
3451: DISABLE
3452: LD_INT 0
3454: PPUSH
3455: PPUSH
// begin uc_side := 7 ;
3456: LD_ADDR_OWVAR 20
3460: PUSH
3461: LD_INT 7
3463: ST_TO_ADDR
// uc_nation := 1 ;
3464: LD_ADDR_OWVAR 21
3468: PUSH
3469: LD_INT 1
3471: ST_TO_ADDR
// for i = 1 to 2 do
3472: LD_ADDR_VAR 0 1
3476: PUSH
3477: DOUBLE
3478: LD_INT 1
3480: DEC
3481: ST_TO_ADDR
3482: LD_INT 2
3484: PUSH
3485: FOR_TO
3486: IFFALSE 3651
// begin PrepareHuman ( sex_male , class_sniper , [ 7 , 6 , 6 ] [ Difficulty ] ) ;
3488: LD_INT 1
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: LD_INT 7
3496: PUSH
3497: LD_INT 6
3499: PUSH
3500: LD_INT 6
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_OWVAR 67
3512: ARRAY
3513: PPUSH
3514: CALL_OW 380
// vc_chassis := us_light_wheeled ;
3518: LD_ADDR_OWVAR 37
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// vc_engine := engine_combustion ;
3526: LD_ADDR_OWVAR 39
3530: PUSH
3531: LD_INT 1
3533: ST_TO_ADDR
// vc_control := control_manual ;
3534: LD_ADDR_OWVAR 38
3538: PUSH
3539: LD_INT 1
3541: ST_TO_ADDR
// vc_fuel_battery := 66 ;
3542: LD_ADDR_OWVAR 41
3546: PUSH
3547: LD_INT 66
3549: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
3550: LD_ADDR_OWVAR 40
3554: PUSH
3555: LD_INT 2
3557: ST_TO_ADDR
// un := CreateVehicle ;
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: CALL_OW 45
3567: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3568: LD_VAR 0 2
3572: PPUSH
3573: LD_INT 3
3575: PPUSH
3576: CALL_OW 233
// PlaceUnitXY ( un , 48 , 3 , false ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_INT 48
3587: PPUSH
3588: LD_INT 3
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , un ) ;
3598: CALL_OW 44
3602: PPUSH
3603: LD_VAR 0 2
3607: PPUSH
3608: CALL_OW 52
// ComMoveXY ( un , 49 , 17 ) ;
3612: LD_VAR 0 2
3616: PPUSH
3617: LD_INT 49
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: CALL_OW 111
// AddComMoveXY ( un , 48 , 36 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_INT 48
3634: PPUSH
3635: LD_INT 36
3637: PPUSH
3638: CALL_OW 171
// Wait ( 0 0$02 ) ;
3642: LD_INT 70
3644: PPUSH
3645: CALL_OW 67
// end ;
3649: GO 3485
3651: POP
3652: POP
// end ;
3653: PPOPN 2
3655: END
// every 5 5$00 + 3 3$00 trigger attackN < [ 10 , 12 , 14 ] [ Difficulty ] do var c , l ;
3656: LD_EXP 6
3660: PUSH
3661: LD_INT 10
3663: PUSH
3664: LD_INT 12
3666: PUSH
3667: LD_INT 14
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_OWVAR 67
3679: ARRAY
3680: LESS
3681: IFFALSE 4383
3683: GO 3685
3685: DISABLE
3686: LD_INT 0
3688: PPUSH
3689: PPUSH
// begin enable ;
3690: ENABLE
// Randomize ;
3691: CALL_OW 10
// Wait ( Rand ( 0 0$01 , 2 2$59 ) ) ;
3695: LD_INT 35
3697: PPUSH
3698: LD_INT 6265
3700: PPUSH
3701: CALL_OW 12
3705: PPUSH
3706: CALL_OW 67
// if attackN < [ 4 , 4 , 5 ] [ Difficulty ] then
3710: LD_EXP 6
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 4
3720: PUSH
3721: LD_INT 5
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PUSH
3729: LD_OWVAR 67
3733: ARRAY
3734: LESS
3735: IFFALSE 3755
// c := Rand ( 1 , 2 ) else
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PPUSH
3745: LD_INT 2
3747: PPUSH
3748: CALL_OW 12
3752: ST_TO_ADDR
3753: GO 3771
// c := Rand ( 1 , 3 ) ;
3755: LD_ADDR_VAR 0 1
3759: PUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 3
3765: PPUSH
3766: CALL_OW 12
3770: ST_TO_ADDR
// if attackN = 0 then
3771: LD_EXP 6
3775: PUSH
3776: LD_INT 0
3778: EQUAL
3779: IFFALSE 3795
// Say ( com , DJackAttack ) else
3781: LD_EXP 1
3785: PPUSH
3786: LD_STRING DJackAttack
3788: PPUSH
3789: CALL_OW 88
3793: GO 3799
// DSay ;
3795: CALL 2753 0 0
// case c of 1 :
3799: LD_VAR 0 1
3803: PUSH
3804: LD_INT 1
3806: DOUBLE
3807: EQUAL
3808: IFTRUE 3812
3810: GO 3994
3812: POP
// begin pom := pom ^ Attack ( 1 ) ;
3813: LD_ADDR_EXP 4
3817: PUSH
3818: LD_EXP 4
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: CALL 1264 0 1
3830: ADD
3831: ST_TO_ADDR
// Wait ( 0 0$12 ) ;
3832: LD_INT 420
3834: PPUSH
3835: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3839: LD_ADDR_EXP 4
3843: PUSH
3844: LD_EXP 4
3848: PUSH
3849: LD_INT 3
3851: PPUSH
3852: CALL 1264 0 1
3856: ADD
3857: ST_TO_ADDR
// if Difficulty > 2 then
3858: LD_OWVAR 67
3862: PUSH
3863: LD_INT 2
3865: GREATER
3866: IFFALSE 3894
// begin Wait ( 0 0$46 ) ;
3868: LD_INT 1610
3870: PPUSH
3871: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
3875: LD_ADDR_EXP 4
3879: PUSH
3880: LD_EXP 4
3884: PUSH
3885: LD_INT 4
3887: PPUSH
3888: CALL 1264 0 1
3892: ADD
3893: ST_TO_ADDR
// end ; if attackN > 4 then
3894: LD_EXP 6
3898: PUSH
3899: LD_INT 4
3901: GREATER
3902: IFFALSE 3930
// begin Wait ( 0 0$12 ) ;
3904: LD_INT 420
3906: PPUSH
3907: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3911: LD_ADDR_EXP 4
3915: PUSH
3916: LD_EXP 4
3920: PUSH
3921: LD_INT 3
3923: PPUSH
3924: CALL 1264 0 1
3928: ADD
3929: ST_TO_ADDR
// end ; if attackN > 8 then
3930: LD_EXP 6
3934: PUSH
3935: LD_INT 8
3937: GREATER
3938: IFFALSE 3992
// begin Wait ( 0 0$12 ) ;
3940: LD_INT 420
3942: PPUSH
3943: CALL_OW 67
// l := Rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// if l < 45 then
3963: LD_VAR 0 2
3967: PUSH
3968: LD_INT 45
3970: LESS
3971: IFFALSE 3992
// pom := pom ^ Attack ( 2 ) ;
3973: LD_ADDR_EXP 4
3977: PUSH
3978: LD_EXP 4
3982: PUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL 1264 0 1
3990: ADD
3991: ST_TO_ADDR
// end ; end ; 2 :
3992: GO 4281
3994: LD_INT 2
3996: DOUBLE
3997: EQUAL
3998: IFTRUE 4002
4000: GO 4150
4002: POP
// begin pom := pom ^ Attack ( 2 ) ;
4003: LD_ADDR_EXP 4
4007: PUSH
4008: LD_EXP 4
4012: PUSH
4013: LD_INT 2
4015: PPUSH
4016: CALL 1264 0 1
4020: ADD
4021: ST_TO_ADDR
// pom := pom ^ Attack ( 3 ) ;
4022: LD_ADDR_EXP 4
4026: PUSH
4027: LD_EXP 4
4031: PUSH
4032: LD_INT 3
4034: PPUSH
4035: CALL 1264 0 1
4039: ADD
4040: ST_TO_ADDR
// if Difficulty > 1 and GetBType ( HexInfo ( 63 , 37 ) ) = b_siberite_mine then
4041: LD_OWVAR 67
4045: PUSH
4046: LD_INT 1
4048: GREATER
4049: PUSH
4050: LD_INT 63
4052: PPUSH
4053: LD_INT 37
4055: PPUSH
4056: CALL_OW 428
4060: PPUSH
4061: CALL_OW 266
4065: PUSH
4066: LD_INT 30
4068: EQUAL
4069: AND
4070: IFFALSE 4076
// ComitSib ;
4072: CALL 2675 0 0
// if Difficulty > 2 then
4076: LD_OWVAR 67
4080: PUSH
4081: LD_INT 2
4083: GREATER
4084: IFFALSE 4112
// begin Wait ( 0 0$25 ) ;
4086: LD_INT 875
4088: PPUSH
4089: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
4093: LD_ADDR_EXP 4
4097: PUSH
4098: LD_EXP 4
4102: PUSH
4103: LD_INT 4
4105: PPUSH
4106: CALL 1264 0 1
4110: ADD
4111: ST_TO_ADDR
// end ; if attackN > 7 then
4112: LD_EXP 6
4116: PUSH
4117: LD_INT 7
4119: GREATER
4120: IFFALSE 4148
// begin Wait ( 0 0$15 ) ;
4122: LD_INT 525
4124: PPUSH
4125: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4129: LD_ADDR_EXP 4
4133: PUSH
4134: LD_EXP 4
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: CALL 1264 0 1
4146: ADD
4147: ST_TO_ADDR
// end ; end ; 3 :
4148: GO 4281
4150: LD_INT 3
4152: DOUBLE
4153: EQUAL
4154: IFTRUE 4158
4156: GO 4280
4158: POP
// begin pom := pom ^ Attack ( 1 ) ;
4159: LD_ADDR_EXP 4
4163: PUSH
4164: LD_EXP 4
4168: PUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL 1264 0 1
4176: ADD
4177: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
4178: LD_INT 70
4180: PPUSH
4181: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4185: LD_ADDR_EXP 4
4189: PUSH
4190: LD_EXP 4
4194: PUSH
4195: LD_INT 2
4197: PPUSH
4198: CALL 1264 0 1
4202: ADD
4203: ST_TO_ADDR
// Wait ( 1 1$00 ) ;
4204: LD_INT 2100
4206: PPUSH
4207: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4211: LD_ADDR_EXP 4
4215: PUSH
4216: LD_EXP 4
4220: PUSH
4221: LD_INT 3
4223: PPUSH
4224: CALL 1264 0 1
4228: ADD
4229: ST_TO_ADDR
// pom := pom ^ Attack ( 5 ) ;
4230: LD_ADDR_EXP 4
4234: PUSH
4235: LD_EXP 4
4239: PUSH
4240: LD_INT 5
4242: PPUSH
4243: CALL 1264 0 1
4247: ADD
4248: ST_TO_ADDR
// if attackN > 10 then
4249: LD_EXP 6
4253: PUSH
4254: LD_INT 10
4256: GREATER
4257: IFFALSE 4278
// pom := pom ^ Attack ( 2 ) ;
4259: LD_ADDR_EXP 4
4263: PUSH
4264: LD_EXP 4
4268: PUSH
4269: LD_INT 2
4271: PPUSH
4272: CALL 1264 0 1
4276: ADD
4277: ST_TO_ADDR
// end ; end ;
4278: GO 4281
4280: POP
// if Difficulty > 1 and attackN mod 4 = 0 then
4281: LD_OWVAR 67
4285: PUSH
4286: LD_INT 1
4288: GREATER
4289: PUSH
4290: LD_EXP 6
4294: PUSH
4295: LD_INT 4
4297: MOD
4298: PUSH
4299: LD_INT 0
4301: EQUAL
4302: AND
4303: IFFALSE 4369
// begin Wait ( 1 1$45 ) ;
4305: LD_INT 3675
4307: PPUSH
4308: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4312: LD_ADDR_EXP 4
4316: PUSH
4317: LD_EXP 4
4321: PUSH
4322: LD_INT 3
4324: PPUSH
4325: CALL 1264 0 1
4329: ADD
4330: ST_TO_ADDR
// pom := pom ^ Attack ( 4 ) ;
4331: LD_ADDR_EXP 4
4335: PUSH
4336: LD_EXP 4
4340: PUSH
4341: LD_INT 4
4343: PPUSH
4344: CALL 1264 0 1
4348: ADD
4349: ST_TO_ADDR
// hover := hover ^ Attack ( 6 ) ;
4350: LD_ADDR_EXP 5
4354: PUSH
4355: LD_EXP 5
4359: PUSH
4360: LD_INT 6
4362: PPUSH
4363: CALL 1264 0 1
4367: ADD
4368: ST_TO_ADDR
// end ; attackN := attackN + 1 ;
4369: LD_ADDR_EXP 6
4373: PUSH
4374: LD_EXP 6
4378: PUSH
4379: LD_INT 1
4381: PLUS
4382: ST_TO_ADDR
// end ;
4383: PPOPN 2
4385: END
// every 0 0$10 trigger attackN >= [ 10 , 12 , 14 ] [ Difficulty ] and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
4386: LD_EXP 6
4390: PUSH
4391: LD_INT 10
4393: PUSH
4394: LD_INT 12
4396: PUSH
4397: LD_INT 14
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PUSH
4405: LD_OWVAR 67
4409: ARRAY
4410: GREATEREQUAL
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PPUSH
4422: CALL_OW 69
4426: PUSH
4427: LD_INT 0
4429: EQUAL
4430: AND
4431: IFFALSE 4487
4433: GO 4435
4435: DISABLE
// begin SayRadio ( doc , DDocEnd ) ;
4436: LD_EXP 2
4440: PPUSH
4441: LD_STRING DDocEnd
4443: PPUSH
4444: CALL_OW 94
// Wait ( 0 0$03 ) ;
4448: LD_INT 105
4450: PPUSH
4451: CALL_OW 67
// case Query ( QWin ) of 1 :
4455: LD_STRING QWin
4457: PPUSH
4458: CALL_OW 97
4462: PUSH
4463: LD_INT 1
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4474
4471: POP
// ; end ;
4472: GO 4475
4474: POP
// music_nat := 5 ;
4475: LD_ADDR_OWVAR 71
4479: PUSH
4480: LD_INT 5
4482: ST_TO_ADDR
// YouWin ;
4483: CALL_OW 103
// end ; end_of_file
4487: END
// on UnitDestroyed ( un ) do begin if un = brave or un = com then
4488: LD_VAR 0 1
4492: PUSH
4493: LD_INT 1
4495: EQUAL
4496: PUSH
4497: LD_VAR 0 1
4501: PUSH
4502: LD_EXP 1
4506: EQUAL
4507: OR
4508: IFFALSE 4529
// begin SayRadio ( doc , DDocWin ) ;
4510: LD_EXP 2
4514: PPUSH
4515: LD_STRING DDocWin
4517: PPUSH
4518: CALL_OW 94
// YouLost (  ) ;
4522: LD_STRING 
4524: PPUSH
4525: CALL_OW 104
// end ; end ;
4529: PPOPN 1
4531: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4532: LD_VAR 0 1
4536: PPUSH
4537: LD_VAR 0 2
4541: PPUSH
4542: LD_VAR 0 3
4546: PPUSH
4547: CALL 6874 0 3
// end ;
4551: PPOPN 3
4553: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4554: LD_VAR 0 1
4558: PPUSH
4559: CALL 6972 0 1
// end ; end_of_file
4563: PPOPN 1
4565: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4566: GO 4568
4568: DISABLE
// begin ru_radar := 98 ;
4569: LD_ADDR_EXP 7
4573: PUSH
4574: LD_INT 98
4576: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4577: LD_ADDR_EXP 8
4581: PUSH
4582: LD_INT 89
4584: ST_TO_ADDR
// us_hack := 99 ;
4585: LD_ADDR_EXP 9
4589: PUSH
4590: LD_INT 99
4592: ST_TO_ADDR
// us_artillery := 97 ;
4593: LD_ADDR_EXP 10
4597: PUSH
4598: LD_INT 97
4600: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4601: LD_ADDR_EXP 11
4605: PUSH
4606: LD_INT 91
4608: ST_TO_ADDR
// end ; end_of_file end_of_file
4609: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
4610: GO 4612
4612: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4613: LD_STRING initStreamRollete();
4615: PPUSH
4616: CALL_OW 559
// InitStreamMode ;
4620: CALL 4625 0 0
// end ;
4624: END
// function InitStreamMode ; begin
4625: LD_INT 0
4627: PPUSH
// streamModeActive := false ;
4628: LD_ADDR_EXP 12
4632: PUSH
4633: LD_INT 0
4635: ST_TO_ADDR
// sRocket := false ;
4636: LD_ADDR_EXP 15
4640: PUSH
4641: LD_INT 0
4643: ST_TO_ADDR
// sSpeed := false ;
4644: LD_ADDR_EXP 14
4648: PUSH
4649: LD_INT 0
4651: ST_TO_ADDR
// sEngine := false ;
4652: LD_ADDR_EXP 16
4656: PUSH
4657: LD_INT 0
4659: ST_TO_ADDR
// sSpec := false ;
4660: LD_ADDR_EXP 13
4664: PUSH
4665: LD_INT 0
4667: ST_TO_ADDR
// sLevel := false ;
4668: LD_ADDR_EXP 17
4672: PUSH
4673: LD_INT 0
4675: ST_TO_ADDR
// sArmoury := false ;
4676: LD_ADDR_EXP 18
4680: PUSH
4681: LD_INT 0
4683: ST_TO_ADDR
// sRadar := false ;
4684: LD_ADDR_EXP 19
4688: PUSH
4689: LD_INT 0
4691: ST_TO_ADDR
// sBunker := false ;
4692: LD_ADDR_EXP 20
4696: PUSH
4697: LD_INT 0
4699: ST_TO_ADDR
// sHack := false ;
4700: LD_ADDR_EXP 21
4704: PUSH
4705: LD_INT 0
4707: ST_TO_ADDR
// sFire := false ;
4708: LD_ADDR_EXP 22
4712: PUSH
4713: LD_INT 0
4715: ST_TO_ADDR
// sRefresh := false ;
4716: LD_ADDR_EXP 23
4720: PUSH
4721: LD_INT 0
4723: ST_TO_ADDR
// sExp := false ;
4724: LD_ADDR_EXP 24
4728: PUSH
4729: LD_INT 0
4731: ST_TO_ADDR
// sDepot := false ;
4732: LD_ADDR_EXP 25
4736: PUSH
4737: LD_INT 0
4739: ST_TO_ADDR
// sFlag := false ;
4740: LD_ADDR_EXP 26
4744: PUSH
4745: LD_INT 0
4747: ST_TO_ADDR
// sSold := false ;
4748: LD_ADDR_EXP 27
4752: PUSH
4753: LD_INT 0
4755: ST_TO_ADDR
// sDiff := false ;
4756: LD_ADDR_EXP 28
4760: PUSH
4761: LD_INT 0
4763: ST_TO_ADDR
// sTiger := false ;
4764: LD_ADDR_EXP 29
4768: PUSH
4769: LD_INT 0
4771: ST_TO_ADDR
// sBomb := false ;
4772: LD_ADDR_EXP 30
4776: PUSH
4777: LD_INT 0
4779: ST_TO_ADDR
// sFog := false ;
4780: LD_ADDR_EXP 31
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// sReset := false ;
4788: LD_ADDR_EXP 32
4792: PUSH
4793: LD_INT 0
4795: ST_TO_ADDR
// sSun := false ;
4796: LD_ADDR_EXP 33
4800: PUSH
4801: LD_INT 0
4803: ST_TO_ADDR
// end ;
4804: LD_VAR 0 1
4808: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
4809: LD_VAR 0 2
4813: PUSH
4814: LD_INT 100
4816: EQUAL
4817: IFFALSE 5226
// begin if not StreamModeActive then
4819: LD_EXP 12
4823: NOT
4824: IFFALSE 4834
// StreamModeActive := true ;
4826: LD_ADDR_EXP 12
4830: PUSH
4831: LD_INT 1
4833: ST_TO_ADDR
// if p3 = 0 then
4834: LD_VAR 0 3
4838: PUSH
4839: LD_INT 0
4841: EQUAL
4842: IFFALSE 4848
// InitStreamMode ;
4844: CALL 4625 0 0
// if p3 = 1 then
4848: LD_VAR 0 3
4852: PUSH
4853: LD_INT 1
4855: EQUAL
4856: IFFALSE 4866
// sRocket := true ;
4858: LD_ADDR_EXP 15
4862: PUSH
4863: LD_INT 1
4865: ST_TO_ADDR
// if p3 = 2 then
4866: LD_VAR 0 3
4870: PUSH
4871: LD_INT 2
4873: EQUAL
4874: IFFALSE 4884
// sSpeed := true ;
4876: LD_ADDR_EXP 14
4880: PUSH
4881: LD_INT 1
4883: ST_TO_ADDR
// if p3 = 3 then
4884: LD_VAR 0 3
4888: PUSH
4889: LD_INT 3
4891: EQUAL
4892: IFFALSE 4902
// sEngine := true ;
4894: LD_ADDR_EXP 16
4898: PUSH
4899: LD_INT 1
4901: ST_TO_ADDR
// if p3 = 4 then
4902: LD_VAR 0 3
4906: PUSH
4907: LD_INT 4
4909: EQUAL
4910: IFFALSE 4920
// sSpec := true ;
4912: LD_ADDR_EXP 13
4916: PUSH
4917: LD_INT 1
4919: ST_TO_ADDR
// if p3 = 5 then
4920: LD_VAR 0 3
4924: PUSH
4925: LD_INT 5
4927: EQUAL
4928: IFFALSE 4938
// sLevel := true ;
4930: LD_ADDR_EXP 17
4934: PUSH
4935: LD_INT 1
4937: ST_TO_ADDR
// if p3 = 6 then
4938: LD_VAR 0 3
4942: PUSH
4943: LD_INT 6
4945: EQUAL
4946: IFFALSE 4956
// sArmoury := true ;
4948: LD_ADDR_EXP 18
4952: PUSH
4953: LD_INT 1
4955: ST_TO_ADDR
// if p3 = 7 then
4956: LD_VAR 0 3
4960: PUSH
4961: LD_INT 7
4963: EQUAL
4964: IFFALSE 4974
// sRadar := true ;
4966: LD_ADDR_EXP 19
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// if p3 = 8 then
4974: LD_VAR 0 3
4978: PUSH
4979: LD_INT 8
4981: EQUAL
4982: IFFALSE 4992
// sBunker := true ;
4984: LD_ADDR_EXP 20
4988: PUSH
4989: LD_INT 1
4991: ST_TO_ADDR
// if p3 = 9 then
4992: LD_VAR 0 3
4996: PUSH
4997: LD_INT 9
4999: EQUAL
5000: IFFALSE 5010
// sHack := true ;
5002: LD_ADDR_EXP 21
5006: PUSH
5007: LD_INT 1
5009: ST_TO_ADDR
// if p3 = 10 then
5010: LD_VAR 0 3
5014: PUSH
5015: LD_INT 10
5017: EQUAL
5018: IFFALSE 5028
// sFire := true ;
5020: LD_ADDR_EXP 22
5024: PUSH
5025: LD_INT 1
5027: ST_TO_ADDR
// if p3 = 11 then
5028: LD_VAR 0 3
5032: PUSH
5033: LD_INT 11
5035: EQUAL
5036: IFFALSE 5046
// sRefresh := true ;
5038: LD_ADDR_EXP 23
5042: PUSH
5043: LD_INT 1
5045: ST_TO_ADDR
// if p3 = 12 then
5046: LD_VAR 0 3
5050: PUSH
5051: LD_INT 12
5053: EQUAL
5054: IFFALSE 5064
// sExp := true ;
5056: LD_ADDR_EXP 24
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// if p3 = 13 then
5064: LD_VAR 0 3
5068: PUSH
5069: LD_INT 13
5071: EQUAL
5072: IFFALSE 5082
// sDepot := true ;
5074: LD_ADDR_EXP 25
5078: PUSH
5079: LD_INT 1
5081: ST_TO_ADDR
// if p3 = 14 then
5082: LD_VAR 0 3
5086: PUSH
5087: LD_INT 14
5089: EQUAL
5090: IFFALSE 5100
// sFlag := true ;
5092: LD_ADDR_EXP 26
5096: PUSH
5097: LD_INT 1
5099: ST_TO_ADDR
// if p3 = 101 then
5100: LD_VAR 0 3
5104: PUSH
5105: LD_INT 101
5107: EQUAL
5108: IFFALSE 5118
// sSold := true ;
5110: LD_ADDR_EXP 27
5114: PUSH
5115: LD_INT 1
5117: ST_TO_ADDR
// if p3 = 102 then
5118: LD_VAR 0 3
5122: PUSH
5123: LD_INT 102
5125: EQUAL
5126: IFFALSE 5136
// sDiff := true ;
5128: LD_ADDR_EXP 28
5132: PUSH
5133: LD_INT 1
5135: ST_TO_ADDR
// if p3 = 103 then
5136: LD_VAR 0 3
5140: PUSH
5141: LD_INT 103
5143: EQUAL
5144: IFFALSE 5154
// sFog := true ;
5146: LD_ADDR_EXP 31
5150: PUSH
5151: LD_INT 1
5153: ST_TO_ADDR
// if p3 = 104 then
5154: LD_VAR 0 3
5158: PUSH
5159: LD_INT 104
5161: EQUAL
5162: IFFALSE 5172
// sReset := true ;
5164: LD_ADDR_EXP 32
5168: PUSH
5169: LD_INT 1
5171: ST_TO_ADDR
// if p3 = 105 then
5172: LD_VAR 0 3
5176: PUSH
5177: LD_INT 105
5179: EQUAL
5180: IFFALSE 5190
// sSun := true ;
5182: LD_ADDR_EXP 33
5186: PUSH
5187: LD_INT 1
5189: ST_TO_ADDR
// if p3 = 106 then
5190: LD_VAR 0 3
5194: PUSH
5195: LD_INT 106
5197: EQUAL
5198: IFFALSE 5208
// sTiger := true ;
5200: LD_ADDR_EXP 29
5204: PUSH
5205: LD_INT 1
5207: ST_TO_ADDR
// if p3 = 107 then
5208: LD_VAR 0 3
5212: PUSH
5213: LD_INT 107
5215: EQUAL
5216: IFFALSE 5226
// sBomb := true ;
5218: LD_ADDR_EXP 30
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// end ; end ;
5226: PPOPN 6
5228: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5229: LD_EXP 12
5233: PUSH
5234: LD_EXP 15
5238: AND
5239: IFFALSE 5360
5241: GO 5243
5243: DISABLE
5244: LD_INT 0
5246: PPUSH
5247: PPUSH
// begin enable ;
5248: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5249: LD_ADDR_VAR 0 2
5253: PUSH
5254: LD_INT 22
5256: PUSH
5257: LD_OWVAR 2
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PUSH
5266: LD_INT 2
5268: PUSH
5269: LD_INT 34
5271: PUSH
5272: LD_INT 7
5274: PUSH
5275: EMPTY
5276: LIST
5277: LIST
5278: PUSH
5279: LD_INT 34
5281: PUSH
5282: LD_INT 45
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: PUSH
5289: LD_INT 34
5291: PUSH
5292: LD_INT 28
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PUSH
5299: LD_INT 34
5301: PUSH
5302: LD_INT 47
5304: PUSH
5305: EMPTY
5306: LIST
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PPUSH
5320: CALL_OW 69
5324: ST_TO_ADDR
// if not tmp then
5325: LD_VAR 0 2
5329: NOT
5330: IFFALSE 5334
// exit ;
5332: GO 5360
// for i in tmp do
5334: LD_ADDR_VAR 0 1
5338: PUSH
5339: LD_VAR 0 2
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5358
// begin DestroyUnit ( i ) ;
5347: LD_VAR 0 1
5351: PPUSH
5352: CALL_OW 65
// end ;
5356: GO 5344
5358: POP
5359: POP
// end ;
5360: PPOPN 2
5362: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5363: LD_EXP 12
5367: PUSH
5368: LD_EXP 16
5372: AND
5373: IFFALSE 5454
5375: GO 5377
5377: DISABLE
5378: LD_INT 0
5380: PPUSH
5381: PPUSH
// begin enable ;
5382: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5383: LD_ADDR_VAR 0 2
5387: PUSH
5388: LD_INT 22
5390: PUSH
5391: LD_OWVAR 2
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PUSH
5400: LD_INT 32
5402: PUSH
5403: LD_INT 3
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: PUSH
5410: EMPTY
5411: LIST
5412: LIST
5413: PPUSH
5414: CALL_OW 69
5418: ST_TO_ADDR
// if not tmp then
5419: LD_VAR 0 2
5423: NOT
5424: IFFALSE 5428
// exit ;
5426: GO 5454
// for i in tmp do
5428: LD_ADDR_VAR 0 1
5432: PUSH
5433: LD_VAR 0 2
5437: PUSH
5438: FOR_IN
5439: IFFALSE 5452
// begin DestroyUnit ( i ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: CALL_OW 65
// end ;
5450: GO 5438
5452: POP
5453: POP
// end ;
5454: PPOPN 2
5456: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5457: LD_EXP 12
5461: PUSH
5462: LD_EXP 13
5466: AND
5467: IFFALSE 5560
5469: GO 5471
5471: DISABLE
5472: LD_INT 0
5474: PPUSH
// begin enable ;
5475: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5476: LD_ADDR_VAR 0 1
5480: PUSH
5481: LD_INT 22
5483: PUSH
5484: LD_OWVAR 2
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 2
5495: PUSH
5496: LD_INT 25
5498: PUSH
5499: LD_INT 5
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: PUSH
5506: LD_INT 25
5508: PUSH
5509: LD_INT 9
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 25
5518: PUSH
5519: LD_INT 8
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: LIST
5530: LIST
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PPUSH
5536: CALL_OW 69
5540: PUSH
5541: FOR_IN
5542: IFFALSE 5558
// begin SetClass ( i , 1 ) ;
5544: LD_VAR 0 1
5548: PPUSH
5549: LD_INT 1
5551: PPUSH
5552: CALL_OW 336
// end ;
5556: GO 5541
5558: POP
5559: POP
// end ;
5560: PPOPN 1
5562: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5563: LD_EXP 12
5567: PUSH
5568: LD_EXP 14
5572: AND
5573: PUSH
5574: LD_OWVAR 65
5578: PUSH
5579: LD_INT 7
5581: LESS
5582: AND
5583: IFFALSE 5597
5585: GO 5587
5587: DISABLE
// begin enable ;
5588: ENABLE
// game_speed := 7 ;
5589: LD_ADDR_OWVAR 65
5593: PUSH
5594: LD_INT 7
5596: ST_TO_ADDR
// end ;
5597: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5598: LD_EXP 12
5602: PUSH
5603: LD_EXP 17
5607: AND
5608: IFFALSE 5810
5610: GO 5612
5612: DISABLE
5613: LD_INT 0
5615: PPUSH
5616: PPUSH
5617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5618: LD_ADDR_VAR 0 3
5622: PUSH
5623: LD_INT 81
5625: PUSH
5626: LD_OWVAR 2
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PUSH
5635: LD_INT 21
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PUSH
5645: EMPTY
5646: LIST
5647: LIST
5648: PPUSH
5649: CALL_OW 69
5653: ST_TO_ADDR
// if not tmp then
5654: LD_VAR 0 3
5658: NOT
5659: IFFALSE 5663
// exit ;
5661: GO 5810
// if tmp > 5 then
5663: LD_VAR 0 3
5667: PUSH
5668: LD_INT 5
5670: GREATER
5671: IFFALSE 5683
// k := 5 else
5673: LD_ADDR_VAR 0 2
5677: PUSH
5678: LD_INT 5
5680: ST_TO_ADDR
5681: GO 5693
// k := tmp ;
5683: LD_ADDR_VAR 0 2
5687: PUSH
5688: LD_VAR 0 3
5692: ST_TO_ADDR
// for i := 1 to k do
5693: LD_ADDR_VAR 0 1
5697: PUSH
5698: DOUBLE
5699: LD_INT 1
5701: DEC
5702: ST_TO_ADDR
5703: LD_VAR 0 2
5707: PUSH
5708: FOR_TO
5709: IFFALSE 5808
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5711: LD_VAR 0 3
5715: PUSH
5716: LD_VAR 0 1
5720: ARRAY
5721: PPUSH
5722: LD_VAR 0 1
5726: PUSH
5727: LD_INT 4
5729: MOD
5730: PUSH
5731: LD_INT 1
5733: PLUS
5734: PPUSH
5735: CALL_OW 259
5739: PUSH
5740: LD_INT 10
5742: LESS
5743: IFFALSE 5806
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5745: LD_VAR 0 3
5749: PUSH
5750: LD_VAR 0 1
5754: ARRAY
5755: PPUSH
5756: LD_VAR 0 1
5760: PUSH
5761: LD_INT 4
5763: MOD
5764: PUSH
5765: LD_INT 1
5767: PLUS
5768: PPUSH
5769: LD_VAR 0 3
5773: PUSH
5774: LD_VAR 0 1
5778: ARRAY
5779: PPUSH
5780: LD_VAR 0 1
5784: PUSH
5785: LD_INT 4
5787: MOD
5788: PUSH
5789: LD_INT 1
5791: PLUS
5792: PPUSH
5793: CALL_OW 259
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: PPUSH
5802: CALL_OW 237
5806: GO 5708
5808: POP
5809: POP
// end ;
5810: PPOPN 3
5812: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5813: LD_EXP 12
5817: PUSH
5818: LD_EXP 18
5822: AND
5823: IFFALSE 5843
5825: GO 5827
5827: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5828: LD_INT 4
5830: PPUSH
5831: LD_OWVAR 2
5835: PPUSH
5836: LD_INT 0
5838: PPUSH
5839: CALL_OW 324
5843: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5844: LD_EXP 12
5848: PUSH
5849: LD_EXP 19
5853: AND
5854: IFFALSE 5953
5856: GO 5858
5858: DISABLE
5859: LD_INT 0
5861: PPUSH
5862: PPUSH
// begin enable ;
5863: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
5864: LD_ADDR_VAR 0 2
5868: PUSH
5869: LD_INT 22
5871: PUSH
5872: LD_OWVAR 2
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 34
5886: PUSH
5887: LD_INT 11
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: PUSH
5894: LD_INT 34
5896: PUSH
5897: LD_INT 30
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: LIST
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PPUSH
5913: CALL_OW 69
5917: ST_TO_ADDR
// if not tmp then
5918: LD_VAR 0 2
5922: NOT
5923: IFFALSE 5927
// exit ;
5925: GO 5953
// for i in tmp do
5927: LD_ADDR_VAR 0 1
5931: PUSH
5932: LD_VAR 0 2
5936: PUSH
5937: FOR_IN
5938: IFFALSE 5951
// begin DestroyUnit ( i ) ;
5940: LD_VAR 0 1
5944: PPUSH
5945: CALL_OW 65
// end ;
5949: GO 5937
5951: POP
5952: POP
// end ;
5953: PPOPN 2
5955: END
// every 0 0$1 trigger StreamModeActive and sBunker do
5956: LD_EXP 12
5960: PUSH
5961: LD_EXP 20
5965: AND
5966: IFFALSE 5986
5968: GO 5970
5970: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
5971: LD_INT 32
5973: PPUSH
5974: LD_OWVAR 2
5978: PPUSH
5979: LD_INT 0
5981: PPUSH
5982: CALL_OW 324
5986: END
// every 0 0$1 trigger StreamModeActive and sHack do
5987: LD_EXP 12
5991: PUSH
5992: LD_EXP 21
5996: AND
5997: IFFALSE 6017
5999: GO 6001
6001: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
6002: LD_INT 33
6004: PPUSH
6005: LD_OWVAR 2
6009: PPUSH
6010: LD_INT 0
6012: PPUSH
6013: CALL_OW 322
6017: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6018: LD_EXP 12
6022: PUSH
6023: LD_EXP 22
6027: AND
6028: IFFALSE 6107
6030: GO 6032
6032: DISABLE
6033: LD_INT 0
6035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6036: LD_ADDR_VAR 0 1
6040: PUSH
6041: LD_INT 22
6043: PUSH
6044: LD_OWVAR 2
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: LD_INT 21
6055: PUSH
6056: LD_INT 3
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: PPUSH
6067: CALL_OW 69
6071: ST_TO_ADDR
// if not tmp then
6072: LD_VAR 0 1
6076: NOT
6077: IFFALSE 6081
// exit ;
6079: GO 6107
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6081: LD_VAR 0 1
6085: PUSH
6086: LD_INT 1
6088: PPUSH
6089: LD_VAR 0 1
6093: PPUSH
6094: CALL_OW 12
6098: ARRAY
6099: PPUSH
6100: LD_INT 100
6102: PPUSH
6103: CALL_OW 234
// end ;
6107: PPOPN 1
6109: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6110: LD_EXP 12
6114: PUSH
6115: LD_EXP 24
6119: AND
6120: IFFALSE 6218
6122: GO 6124
6124: DISABLE
6125: LD_INT 0
6127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: LD_INT 22
6135: PUSH
6136: LD_OWVAR 2
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 21
6147: PUSH
6148: LD_INT 1
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 69
6163: ST_TO_ADDR
// if not tmp then
6164: LD_VAR 0 1
6168: NOT
6169: IFFALSE 6173
// exit ;
6171: GO 6218
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6173: LD_VAR 0 1
6177: PUSH
6178: LD_INT 1
6180: PPUSH
6181: LD_VAR 0 1
6185: PPUSH
6186: CALL_OW 12
6190: ARRAY
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: LD_INT 4
6197: PPUSH
6198: CALL_OW 12
6202: PPUSH
6203: LD_INT 3000
6205: PPUSH
6206: LD_INT 9000
6208: PPUSH
6209: CALL_OW 12
6213: PPUSH
6214: CALL_OW 492
// end ;
6218: PPOPN 1
6220: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6221: LD_EXP 12
6225: PUSH
6226: LD_EXP 25
6230: AND
6231: IFFALSE 6251
6233: GO 6235
6235: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6236: LD_INT 1
6238: PPUSH
6239: LD_OWVAR 2
6243: PPUSH
6244: LD_INT 0
6246: PPUSH
6247: CALL_OW 324
6251: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6252: LD_EXP 12
6256: PUSH
6257: LD_EXP 26
6261: AND
6262: IFFALSE 6345
6264: GO 6266
6266: DISABLE
6267: LD_INT 0
6269: PPUSH
6270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6271: LD_ADDR_VAR 0 2
6275: PUSH
6276: LD_INT 22
6278: PUSH
6279: LD_OWVAR 2
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: PUSH
6288: LD_INT 21
6290: PUSH
6291: LD_INT 3
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PPUSH
6302: CALL_OW 69
6306: ST_TO_ADDR
// if not tmp then
6307: LD_VAR 0 2
6311: NOT
6312: IFFALSE 6316
// exit ;
6314: GO 6345
// for i in tmp do
6316: LD_ADDR_VAR 0 1
6320: PUSH
6321: LD_VAR 0 2
6325: PUSH
6326: FOR_IN
6327: IFFALSE 6343
// SetBLevel ( i , 10 ) ;
6329: LD_VAR 0 1
6333: PPUSH
6334: LD_INT 10
6336: PPUSH
6337: CALL_OW 241
6341: GO 6326
6343: POP
6344: POP
// end ;
6345: PPOPN 2
6347: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
6348: LD_EXP 12
6352: PUSH
6353: LD_EXP 27
6357: AND
6358: IFFALSE 6441
6360: GO 6362
6362: DISABLE
6363: LD_INT 0
6365: PPUSH
6366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6367: LD_ADDR_VAR 0 2
6371: PUSH
6372: LD_INT 22
6374: PUSH
6375: LD_OWVAR 2
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: LD_INT 25
6386: PUSH
6387: LD_INT 1
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: PPUSH
6398: CALL_OW 69
6402: ST_TO_ADDR
// if not tmp then
6403: LD_VAR 0 2
6407: NOT
6408: IFFALSE 6412
// exit ;
6410: GO 6441
// for i in tmp do
6412: LD_ADDR_VAR 0 1
6416: PUSH
6417: LD_VAR 0 2
6421: PUSH
6422: FOR_IN
6423: IFFALSE 6439
// SetClass ( i , 4 ) ;
6425: LD_VAR 0 1
6429: PPUSH
6430: LD_INT 4
6432: PPUSH
6433: CALL_OW 336
6437: GO 6422
6439: POP
6440: POP
// end ;
6441: PPOPN 2
6443: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6444: LD_EXP 12
6448: PUSH
6449: LD_EXP 28
6453: AND
6454: PUSH
6455: LD_OWVAR 67
6459: PUSH
6460: LD_INT 3
6462: LESS
6463: AND
6464: IFFALSE 6483
6466: GO 6468
6468: DISABLE
// Difficulty := Difficulty + 1 ;
6469: LD_ADDR_OWVAR 67
6473: PUSH
6474: LD_OWVAR 67
6478: PUSH
6479: LD_INT 1
6481: PLUS
6482: ST_TO_ADDR
6483: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6484: LD_EXP 12
6488: PUSH
6489: LD_EXP 29
6493: AND
6494: IFFALSE 6597
6496: GO 6498
6498: DISABLE
6499: LD_INT 0
6501: PPUSH
// begin for i := 1 to 5 do
6502: LD_ADDR_VAR 0 1
6506: PUSH
6507: DOUBLE
6508: LD_INT 1
6510: DEC
6511: ST_TO_ADDR
6512: LD_INT 5
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6595
// begin uc_nation := nation_nature ;
6518: LD_ADDR_OWVAR 21
6522: PUSH
6523: LD_INT 0
6525: ST_TO_ADDR
// uc_side := 0 ;
6526: LD_ADDR_OWVAR 20
6530: PUSH
6531: LD_INT 0
6533: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6534: LD_ADDR_OWVAR 29
6538: PUSH
6539: LD_INT 12
6541: PUSH
6542: LD_INT 12
6544: PUSH
6545: EMPTY
6546: LIST
6547: LIST
6548: ST_TO_ADDR
// hc_agressivity := 20 ;
6549: LD_ADDR_OWVAR 35
6553: PUSH
6554: LD_INT 20
6556: ST_TO_ADDR
// hc_class := class_tiger ;
6557: LD_ADDR_OWVAR 28
6561: PUSH
6562: LD_INT 14
6564: ST_TO_ADDR
// hc_gallery :=  ;
6565: LD_ADDR_OWVAR 33
6569: PUSH
6570: LD_STRING 
6572: ST_TO_ADDR
// hc_name :=  ;
6573: LD_ADDR_OWVAR 26
6577: PUSH
6578: LD_STRING 
6580: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
6581: CALL_OW 44
6585: PPUSH
6586: LD_INT 0
6588: PPUSH
6589: CALL_OW 51
// end ;
6593: GO 6515
6595: POP
6596: POP
// end ;
6597: PPOPN 1
6599: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
6600: LD_EXP 12
6604: PUSH
6605: LD_EXP 30
6609: AND
6610: IFFALSE 6784
6612: GO 6614
6614: DISABLE
6615: LD_INT 0
6617: PPUSH
6618: PPUSH
6619: PPUSH
6620: PPUSH
// begin result := false ;
6621: LD_ADDR_VAR 0 4
6625: PUSH
6626: LD_INT 0
6628: ST_TO_ADDR
// for i := 1 to 8 do
6629: LD_ADDR_VAR 0 1
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 8
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6754
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_INT 10
6652: PUSH
6653: LD_INT 50
6655: PUSH
6656: LD_INT 90
6658: PUSH
6659: LD_INT 140
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 1
6670: PPUSH
6671: LD_INT 4
6673: PPUSH
6674: CALL_OW 12
6678: ARRAY
6679: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
6680: LD_ADDR_VAR 0 3
6684: PUSH
6685: LD_INT 10
6687: PUSH
6688: LD_INT 50
6690: PUSH
6691: LD_INT 90
6693: PUSH
6694: LD_INT 140
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 1
6705: PPUSH
6706: LD_INT 4
6708: PPUSH
6709: CALL_OW 12
6713: ARRAY
6714: ST_TO_ADDR
// if ValidHex ( x , y ) then
6715: LD_VAR 0 2
6719: PPUSH
6720: LD_VAR 0 3
6724: PPUSH
6725: CALL_OW 488
6729: IFFALSE 6752
// begin result := [ x , y ] ;
6731: LD_ADDR_VAR 0 4
6735: PUSH
6736: LD_VAR 0 2
6740: PUSH
6741: LD_VAR 0 3
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: ST_TO_ADDR
// break ;
6750: GO 6754
// end ; end ;
6752: GO 6642
6754: POP
6755: POP
// if result then
6756: LD_VAR 0 4
6760: IFFALSE 6784
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
6762: LD_VAR 0 4
6766: PUSH
6767: LD_INT 1
6769: ARRAY
6770: PPUSH
6771: LD_VAR 0 4
6775: PUSH
6776: LD_INT 2
6778: ARRAY
6779: PPUSH
6780: CALL_OW 429
// end ;
6784: PPOPN 4
6786: END
// every 0 0$1 trigger StreamModeActive and sReset do
6787: LD_EXP 12
6791: PUSH
6792: LD_EXP 32
6796: AND
6797: IFFALSE 6809
6799: GO 6801
6801: DISABLE
// YouLost (  ) ;
6802: LD_STRING 
6804: PPUSH
6805: CALL_OW 104
6809: END
// every 0 0$1 trigger StreamModeActive and sFog do
6810: LD_EXP 12
6814: PUSH
6815: LD_EXP 31
6819: AND
6820: IFFALSE 6834
6822: GO 6824
6824: DISABLE
// FogOff ( your_side ) ;
6825: LD_OWVAR 2
6829: PPUSH
6830: CALL_OW 344
6834: END
// every 0 0$1 trigger StreamModeActive and sSun do
6835: LD_EXP 12
6839: PUSH
6840: LD_EXP 33
6844: AND
6845: IFFALSE 6873
6847: GO 6849
6849: DISABLE
// begin solar_recharge_percent := 0 ;
6850: LD_ADDR_OWVAR 79
6854: PUSH
6855: LD_INT 0
6857: ST_TO_ADDR
// wait ( 5 5$00 ) ;
6858: LD_INT 10500
6860: PPUSH
6861: CALL_OW 67
// solar_recharge_percent := 100 ;
6865: LD_ADDR_OWVAR 79
6869: PUSH
6870: LD_INT 100
6872: ST_TO_ADDR
// end ; end_of_file
6873: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
6880: LD_VAR 0 1
6884: PPUSH
6885: CALL_OW 264
6889: PUSH
6890: LD_EXP 11
6894: EQUAL
6895: IFFALSE 6967
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
6897: LD_INT 68
6899: PPUSH
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 255
6909: PPUSH
6910: CALL_OW 321
6914: PUSH
6915: LD_INT 2
6917: EQUAL
6918: IFFALSE 6930
// eff := 70 else
6920: LD_ADDR_VAR 0 6
6924: PUSH
6925: LD_INT 70
6927: ST_TO_ADDR
6928: GO 6938
// eff := 30 ;
6930: LD_ADDR_VAR 0 6
6934: PUSH
6935: LD_INT 30
6937: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
6938: LD_VAR 0 1
6942: PPUSH
6943: CALL_OW 250
6947: PPUSH
6948: LD_VAR 0 1
6952: PPUSH
6953: CALL_OW 251
6957: PPUSH
6958: LD_VAR 0 6
6962: PPUSH
6963: CALL_OW 495
// end ; end ;
6967: LD_VAR 0 4
6971: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
6972: LD_INT 0
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
6978: PPUSH
6979: PPUSH
// if cmd = 124 then
6980: LD_VAR 0 1
6984: PUSH
6985: LD_INT 124
6987: EQUAL
6988: IFFALSE 7194
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
6990: LD_ADDR_VAR 0 5
6994: PUSH
6995: LD_INT 2
6997: PUSH
6998: LD_INT 34
7000: PUSH
7001: LD_INT 53
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PUSH
7008: LD_INT 34
7010: PUSH
7011: LD_INT 14
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: PPUSH
7023: CALL_OW 69
7027: ST_TO_ADDR
// if not tmp then
7028: LD_VAR 0 5
7032: NOT
7033: IFFALSE 7037
// exit ;
7035: GO 7194
// for i in tmp do
7037: LD_ADDR_VAR 0 3
7041: PUSH
7042: LD_VAR 0 5
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7192
// begin taskList := GetTaskList ( i ) ;
7050: LD_ADDR_VAR 0 6
7054: PUSH
7055: LD_VAR 0 3
7059: PPUSH
7060: CALL_OW 437
7064: ST_TO_ADDR
// if not taskList then
7065: LD_VAR 0 6
7069: NOT
7070: IFFALSE 7074
// continue ;
7072: GO 7047
// for j = 1 to taskList do
7074: LD_ADDR_VAR 0 4
7078: PUSH
7079: DOUBLE
7080: LD_INT 1
7082: DEC
7083: ST_TO_ADDR
7084: LD_VAR 0 6
7088: PUSH
7089: FOR_TO
7090: IFFALSE 7188
// if taskList [ j ] [ 1 ] = | then
7092: LD_VAR 0 6
7096: PUSH
7097: LD_VAR 0 4
7101: ARRAY
7102: PUSH
7103: LD_INT 1
7105: ARRAY
7106: PUSH
7107: LD_STRING |
7109: EQUAL
7110: IFFALSE 7186
// begin _taskList := Delete ( taskList , 1 ) ;
7112: LD_ADDR_VAR 0 7
7116: PUSH
7117: LD_VAR 0 6
7121: PPUSH
7122: LD_INT 1
7124: PPUSH
7125: CALL_OW 3
7129: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
7130: LD_VAR 0 3
7134: PPUSH
7135: LD_VAR 0 7
7139: PPUSH
7140: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
7144: LD_VAR 0 3
7148: PPUSH
7149: LD_VAR 0 6
7153: PUSH
7154: LD_VAR 0 4
7158: ARRAY
7159: PUSH
7160: LD_INT 2
7162: ARRAY
7163: PPUSH
7164: LD_VAR 0 6
7168: PUSH
7169: LD_VAR 0 4
7173: ARRAY
7174: PUSH
7175: LD_INT 3
7177: ARRAY
7178: PPUSH
7179: LD_INT 8
7181: PPUSH
7182: CALL 7199 0 4
// end ;
7186: GO 7089
7188: POP
7189: POP
// end ;
7190: GO 7047
7192: POP
7193: POP
// end ; end ;
7194: LD_VAR 0 2
7198: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
7199: LD_INT 0
7201: PPUSH
7202: PPUSH
7203: PPUSH
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
7208: PPUSH
7209: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
7210: LD_VAR 0 1
7214: NOT
7215: PUSH
7216: LD_VAR 0 2
7220: PPUSH
7221: LD_VAR 0 3
7225: PPUSH
7226: CALL_OW 488
7230: NOT
7231: OR
7232: PUSH
7233: LD_VAR 0 4
7237: NOT
7238: OR
7239: IFFALSE 7243
// exit ;
7241: GO 7583
// list := [ ] ;
7243: LD_ADDR_VAR 0 13
7247: PUSH
7248: EMPTY
7249: ST_TO_ADDR
// if x - r < 0 then
7250: LD_VAR 0 2
7254: PUSH
7255: LD_VAR 0 4
7259: MINUS
7260: PUSH
7261: LD_INT 0
7263: LESS
7264: IFFALSE 7276
// min_x := 0 else
7266: LD_ADDR_VAR 0 7
7270: PUSH
7271: LD_INT 0
7273: ST_TO_ADDR
7274: GO 7292
// min_x := x - r ;
7276: LD_ADDR_VAR 0 7
7280: PUSH
7281: LD_VAR 0 2
7285: PUSH
7286: LD_VAR 0 4
7290: MINUS
7291: ST_TO_ADDR
// if y - r < 0 then
7292: LD_VAR 0 3
7296: PUSH
7297: LD_VAR 0 4
7301: MINUS
7302: PUSH
7303: LD_INT 0
7305: LESS
7306: IFFALSE 7318
// min_y := 0 else
7308: LD_ADDR_VAR 0 8
7312: PUSH
7313: LD_INT 0
7315: ST_TO_ADDR
7316: GO 7334
// min_y := y - r ;
7318: LD_ADDR_VAR 0 8
7322: PUSH
7323: LD_VAR 0 3
7327: PUSH
7328: LD_VAR 0 4
7332: MINUS
7333: ST_TO_ADDR
// max_x := x + r ;
7334: LD_ADDR_VAR 0 9
7338: PUSH
7339: LD_VAR 0 2
7343: PUSH
7344: LD_VAR 0 4
7348: PLUS
7349: ST_TO_ADDR
// max_y := y + r ;
7350: LD_ADDR_VAR 0 10
7354: PUSH
7355: LD_VAR 0 3
7359: PUSH
7360: LD_VAR 0 4
7364: PLUS
7365: ST_TO_ADDR
// for _x = min_x to max_x do
7366: LD_ADDR_VAR 0 11
7370: PUSH
7371: DOUBLE
7372: LD_VAR 0 7
7376: DEC
7377: ST_TO_ADDR
7378: LD_VAR 0 9
7382: PUSH
7383: FOR_TO
7384: IFFALSE 7501
// for _y = min_y to max_y do
7386: LD_ADDR_VAR 0 12
7390: PUSH
7391: DOUBLE
7392: LD_VAR 0 8
7396: DEC
7397: ST_TO_ADDR
7398: LD_VAR 0 10
7402: PUSH
7403: FOR_TO
7404: IFFALSE 7497
// begin if not ValidHex ( _x , _y ) then
7406: LD_VAR 0 11
7410: PPUSH
7411: LD_VAR 0 12
7415: PPUSH
7416: CALL_OW 488
7420: NOT
7421: IFFALSE 7425
// continue ;
7423: GO 7403
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
7425: LD_VAR 0 11
7429: PPUSH
7430: LD_VAR 0 12
7434: PPUSH
7435: CALL_OW 351
7439: PUSH
7440: LD_VAR 0 11
7444: PPUSH
7445: LD_VAR 0 12
7449: PPUSH
7450: CALL_OW 554
7454: AND
7455: IFFALSE 7495
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
7457: LD_ADDR_VAR 0 13
7461: PUSH
7462: LD_VAR 0 13
7466: PPUSH
7467: LD_VAR 0 13
7471: PUSH
7472: LD_INT 1
7474: PLUS
7475: PPUSH
7476: LD_VAR 0 11
7480: PUSH
7481: LD_VAR 0 12
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 2
7494: ST_TO_ADDR
// end ;
7495: GO 7403
7497: POP
7498: POP
7499: GO 7383
7501: POP
7502: POP
// if not list then
7503: LD_VAR 0 13
7507: NOT
7508: IFFALSE 7512
// exit ;
7510: GO 7583
// for i in list do
7512: LD_ADDR_VAR 0 6
7516: PUSH
7517: LD_VAR 0 13
7521: PUSH
7522: FOR_IN
7523: IFFALSE 7581
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
7525: LD_VAR 0 1
7529: PPUSH
7530: LD_STRING M
7532: PUSH
7533: LD_VAR 0 6
7537: PUSH
7538: LD_INT 1
7540: ARRAY
7541: PUSH
7542: LD_VAR 0 6
7546: PUSH
7547: LD_INT 2
7549: ARRAY
7550: PUSH
7551: LD_INT 0
7553: PUSH
7554: LD_INT 0
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: PUSH
7572: EMPTY
7573: LIST
7574: PPUSH
7575: CALL_OW 447
7579: GO 7522
7581: POP
7582: POP
// end ;
7583: LD_VAR 0 5
7587: RET
