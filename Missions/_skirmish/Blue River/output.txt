// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// PlaceSeeing ( 0 , 0 , 7 , - 37963 ) ;
  11: LD_INT 0
  13: PPUSH
  14: LD_INT 0
  16: PPUSH
  17: LD_INT 7
  19: PPUSH
  20: LD_INT 37963
  22: NEG
  23: PPUSH
  24: CALL_OW 330
// RemoveSeeing ( 0 , 0 , 7 ) ;
  28: LD_INT 0
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 7
  36: PPUSH
  37: CALL_OW 331
// PrepareBase ;
  41: CALL 514 0 0
// Action ;
  45: CALL 54 0 0
// SaveForQuickRestart ;
  49: CALL_OW 22
// end ;
  53: END
// function Action ; var un , f , i ; begin
  54: LD_INT 0
  56: PPUSH
  57: PPUSH
  58: PPUSH
  59: PPUSH
// SetBName ( brave , brave ) ;
  60: LD_INT 1
  62: PPUSH
  63: LD_STRING brave
  65: PPUSH
  66: CALL_OW 500
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// SetResourceType ( GetBase ( brave ) , mat_cans , [ 6000 , 4500 , 3000 ] [ Difficulty ] ) ;
  83: LD_INT 1
  85: PPUSH
  86: CALL_OW 274
  90: PPUSH
  91: LD_INT 1
  93: PPUSH
  94: LD_INT 6000
  96: PUSH
  97: LD_INT 4500
  99: PUSH
 100: LD_INT 3000
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: LIST
 107: PUSH
 108: LD_OWVAR 67
 112: ARRAY
 113: PPUSH
 114: CALL_OW 277
// InGameOn ;
 118: CALL_OW 8
// CenterNowOnUnits ( brave ) ;
 122: LD_INT 1
 124: PPUSH
 125: CALL_OW 87
// Say ( com , DJack1 ) ;
 129: LD_EXP 1
 133: PPUSH
 134: LD_STRING DJack1
 136: PPUSH
 137: CALL_OW 88
// Say ( k1 , DUn1 ) ;
 141: LD_EXP 3
 145: PPUSH
 146: LD_STRING DUn1
 148: PPUSH
 149: CALL_OW 88
// Say ( com , DJack2 ) ;
 153: LD_EXP 1
 157: PPUSH
 158: LD_STRING DJack2
 160: PPUSH
 161: CALL_OW 88
// Say ( k1 , DUn2 ) ;
 165: LD_EXP 3
 169: PPUSH
 170: LD_STRING DUn2
 172: PPUSH
 173: CALL_OW 88
// Say ( com , DJack3 ) ;
 177: LD_EXP 1
 181: PPUSH
 182: LD_STRING DJack3
 184: PPUSH
 185: CALL_OW 88
// uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := 1 ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_INT 1
 204: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 0 ) ;
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 0
 213: PPUSH
 214: CALL_OW 380
// hc_name :=  ;
 218: LD_ADDR_OWVAR 26
 222: PUSH
 223: LD_STRING 
 225: ST_TO_ADDR
// un := CreateHuman ;
 226: LD_ADDR_VAR 0 2
 230: PUSH
 231: CALL_OW 44
 235: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
 236: LD_INT 105
 238: PPUSH
 239: CALL_OW 67
// SayRadio ( un , DRadio1 ) ;
 243: LD_VAR 0 2
 247: PPUSH
 248: LD_STRING DRadio1
 250: PPUSH
 251: CALL_OW 94
// Say ( com , DJack4 ) ;
 255: LD_EXP 1
 259: PPUSH
 260: LD_STRING DJack4
 262: PPUSH
 263: CALL_OW 88
// SayRadio ( un , DRadio2 ) ;
 267: LD_VAR 0 2
 271: PPUSH
 272: LD_STRING DRadio2
 274: PPUSH
 275: CALL_OW 94
// Wait ( 0 0$01 ) ;
 279: LD_INT 35
 281: PPUSH
 282: CALL_OW 67
// SayRadio ( doc , DDoc1 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_STRING DDoc1
 293: PPUSH
 294: CALL_OW 94
// Say ( com , DJack5 ) ;
 298: LD_EXP 1
 302: PPUSH
 303: LD_STRING DJack5
 305: PPUSH
 306: CALL_OW 88
// SayRadio ( doc , DDoc2 ) ;
 310: LD_EXP 2
 314: PPUSH
 315: LD_STRING DDoc2
 317: PPUSH
 318: CALL_OW 94
// SayRadio ( un , DRadio3 ) ;
 322: LD_VAR 0 2
 326: PPUSH
 327: LD_STRING DRadio3
 329: PPUSH
 330: CALL_OW 94
// Say ( com , DJack6 ) ;
 334: LD_EXP 1
 338: PPUSH
 339: LD_STRING DJack6
 341: PPUSH
 342: CALL_OW 88
// f := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
 346: LD_ADDR_VAR 0 3
 350: PUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 7
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 21
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: ST_TO_ADDR
// for i = 2 to f do
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: DOUBLE
 386: LD_INT 2
 388: DEC
 389: ST_TO_ADDR
 390: LD_VAR 0 3
 394: PUSH
 395: FOR_TO
 396: IFFALSE 453
// begin ComExitBuilding ( f [ i ] ) ;
 398: LD_VAR 0 3
 402: PUSH
 403: LD_VAR 0 4
 407: ARRAY
 408: PPUSH
 409: CALL_OW 122
// AddComMoveToArea ( f [ i ] , act_area ) ;
 413: LD_VAR 0 3
 417: PUSH
 418: LD_VAR 0 4
 422: ARRAY
 423: PPUSH
 424: LD_INT 7
 426: PPUSH
 427: CALL_OW 173
// AddComTurnUnit ( f [ i ] , com ) ;
 431: LD_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ARRAY
 441: PPUSH
 442: LD_EXP 1
 446: PPUSH
 447: CALL_OW 179
// end ;
 451: GO 395
 453: POP
 454: POP
// ComExitBuilding ( com ) ;
 455: LD_EXP 1
 459: PPUSH
 460: CALL_OW 122
// AddComTurnXY ( com , 45 , 32 ) ;
 464: LD_EXP 1
 468: PPUSH
 469: LD_INT 45
 471: PPUSH
 472: LD_INT 32
 474: PPUSH
 475: CALL_OW 178
// Wait ( 0 0$03 ) ;
 479: LD_INT 105
 481: PPUSH
 482: CALL_OW 67
// Say ( com , DJack7 ) ;
 486: LD_EXP 1
 490: PPUSH
 491: LD_STRING DJack7
 493: PPUSH
 494: CALL_OW 88
// InGameOff ;
 498: CALL_OW 9
// ChangeMissionObjectives ( TDef ) ;
 502: LD_STRING TDef
 504: PPUSH
 505: CALL_OW 337
// end ; end_of_file
 509: LD_VAR 0 1
 513: RET
// export com , doc , k1 ; export function PrepareBase ; var i , un , skill ; begin
 514: LD_INT 0
 516: PPUSH
 517: PPUSH
 518: PPUSH
 519: PPUSH
// PlaceSeeing ( 30 , 14 , 7 , 20 ) ;
 520: LD_INT 30
 522: PPUSH
 523: LD_INT 14
 525: PPUSH
 526: LD_INT 7
 528: PPUSH
 529: LD_INT 20
 531: PPUSH
 532: CALL_OW 330
// PlaceSeeing ( 49 , 17 , 7 , 20 ) ;
 536: LD_INT 49
 538: PPUSH
 539: LD_INT 17
 541: PPUSH
 542: LD_INT 7
 544: PPUSH
 545: LD_INT 20
 547: PPUSH
 548: CALL_OW 330
// PlaceSeeing ( 35 , 46 , 7 , 20 ) ;
 552: LD_INT 35
 554: PPUSH
 555: LD_INT 46
 557: PPUSH
 558: LD_INT 7
 560: PPUSH
 561: LD_INT 20
 563: PPUSH
 564: CALL_OW 330
// PlaceSeeing ( 70 , 39 , 7 , 20 ) ;
 568: LD_INT 70
 570: PPUSH
 571: LD_INT 39
 573: PPUSH
 574: LD_INT 7
 576: PPUSH
 577: LD_INT 20
 579: PPUSH
 580: CALL_OW 330
// RemoveSeeing ( 30 , 14 , 7 ) ;
 584: LD_INT 30
 586: PPUSH
 587: LD_INT 14
 589: PPUSH
 590: LD_INT 7
 592: PPUSH
 593: CALL_OW 331
// RemoveSeeing ( 49 , 17 , 7 ) ;
 597: LD_INT 49
 599: PPUSH
 600: LD_INT 17
 602: PPUSH
 603: LD_INT 7
 605: PPUSH
 606: CALL_OW 331
// RemoveSeeing ( 35 , 46 , 7 ) ;
 610: LD_INT 35
 612: PPUSH
 613: LD_INT 46
 615: PPUSH
 616: LD_INT 7
 618: PPUSH
 619: CALL_OW 331
// RemoveSeeing ( 70 , 39 , 7 ) ;
 623: LD_INT 70
 625: PPUSH
 626: LD_INT 39
 628: PPUSH
 629: LD_INT 7
 631: PPUSH
 632: CALL_OW 331
// uc_side := 7 ;
 636: LD_ADDR_OWVAR 20
 640: PUSH
 641: LD_INT 7
 643: ST_TO_ADDR
// uc_nation := 1 ;
 644: LD_ADDR_OWVAR 21
 648: PUSH
 649: LD_INT 1
 651: ST_TO_ADDR
// if Difficulty < 3 then
 652: LD_OWVAR 67
 656: PUSH
 657: LD_INT 3
 659: LESS
 660: IFFALSE 761
// begin for i = 1 to 2 do
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: DOUBLE
 668: LD_INT 1
 670: DEC
 671: ST_TO_ADDR
 672: LD_INT 2
 674: PUSH
 675: FOR_TO
 676: IFFALSE 757
// begin vc_chassis := us_heavy_tracked ;
 678: LD_ADDR_OWVAR 37
 682: PUSH
 683: LD_INT 4
 685: ST_TO_ADDR
// vc_engine := 3 ;
 686: LD_ADDR_OWVAR 39
 690: PUSH
 691: LD_INT 3
 693: ST_TO_ADDR
// vc_control := control_computer ;
 694: LD_ADDR_OWVAR 38
 698: PUSH
 699: LD_INT 3
 701: ST_TO_ADDR
// vc_weapon := us_double_laser ;
 702: LD_ADDR_OWVAR 40
 706: PUSH
 707: LD_INT 10
 709: ST_TO_ADDR
// un := CreateVehicle ;
 710: LD_ADDR_VAR 0 3
 714: PUSH
 715: CALL_OW 45
 719: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 720: LD_VAR 0 3
 724: PPUSH
 725: LD_INT 0
 727: PPUSH
 728: LD_INT 5
 730: PPUSH
 731: CALL_OW 12
 735: PPUSH
 736: CALL_OW 233
// PlaceUnitArea ( un , base_spawn , false ) ;
 740: LD_VAR 0 3
 744: PPUSH
 745: LD_INT 6
 747: PPUSH
 748: LD_INT 0
 750: PPUSH
 751: CALL_OW 49
// end ;
 755: GO 675
 757: POP
 758: POP
// end else
 759: GO 850
// begin vc_chassis := us_medium_tracked ;
 761: LD_ADDR_OWVAR 37
 765: PUSH
 766: LD_INT 3
 768: ST_TO_ADDR
// vc_engine := engine_combustion ;
 769: LD_ADDR_OWVAR 39
 773: PUSH
 774: LD_INT 1
 776: ST_TO_ADDR
// vc_control := control_manual ;
 777: LD_ADDR_OWVAR 38
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
 785: LD_ADDR_OWVAR 40
 789: PUSH
 790: LD_INT 4
 792: ST_TO_ADDR
// un := CreateVehicle ;
 793: LD_ADDR_VAR 0 3
 797: PUSH
 798: CALL_OW 45
 802: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 803: LD_VAR 0 3
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: LD_INT 5
 813: PPUSH
 814: CALL_OW 12
 818: PPUSH
 819: CALL_OW 233
// SetFuel ( un , 75 ) ;
 823: LD_VAR 0 3
 827: PPUSH
 828: LD_INT 75
 830: PPUSH
 831: CALL_OW 240
// PlaceUnitArea ( un , base_spawn , false ) ;
 835: LD_VAR 0 3
 839: PPUSH
 840: LD_INT 6
 842: PPUSH
 843: LD_INT 0
 845: PPUSH
 846: CALL_OW 49
// end ; skill := [ 8 , 7 , 6 ] [ Difficulty ] ;
 850: LD_ADDR_VAR 0 4
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: LD_INT 7
 860: PUSH
 861: LD_INT 6
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_OWVAR 67
 873: ARRAY
 874: ST_TO_ADDR
// hc_importance := 100 ;
 875: LD_ADDR_OWVAR 32
 879: PUSH
 880: LD_INT 100
 882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 883: LD_INT 1
 885: PPUSH
 886: LD_INT 1
 888: PPUSH
 889: LD_VAR 0 4
 893: PPUSH
 894: CALL_OW 380
// hc_name := Jack Collins ;
 898: LD_ADDR_OWVAR 26
 902: PUSH
 903: LD_STRING Jack Collins
 905: ST_TO_ADDR
// com := CreateHuman ;
 906: LD_ADDR_EXP 1
 910: PUSH
 911: CALL_OW 44
 915: ST_TO_ADDR
// PlaceHumanInUnit ( com , brave ) ;
 916: LD_EXP 1
 920: PPUSH
 921: LD_INT 1
 923: PPUSH
 924: CALL_OW 52
// hc_importance := 0 ;
 928: LD_ADDR_OWVAR 32
 932: PUSH
 933: LD_INT 0
 935: ST_TO_ADDR
// hc_gallery :=  ;
 936: LD_ADDR_OWVAR 33
 940: PUSH
 941: LD_STRING 
 943: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 4
 954: PPUSH
 955: CALL_OW 380
// hc_name := Thomas Jackson ;
 959: LD_ADDR_OWVAR 26
 963: PUSH
 964: LD_STRING Thomas Jackson
 966: ST_TO_ADDR
// k1 := CreateHuman ;
 967: LD_ADDR_EXP 3
 971: PUSH
 972: CALL_OW 44
 976: ST_TO_ADDR
// PlaceHumanInUnit ( k1 , brave ) ;
 977: LD_EXP 3
 981: PPUSH
 982: LD_INT 1
 984: PPUSH
 985: CALL_OW 52
// hc_name :=  ;
 989: LD_ADDR_OWVAR 26
 993: PUSH
 994: LD_STRING 
 996: ST_TO_ADDR
// for i = 1 to [ 9 , 8 , 7 ] [ Difficulty ] do
 997: LD_ADDR_VAR 0 2
1001: PUSH
1002: DOUBLE
1003: LD_INT 1
1005: DEC
1006: ST_TO_ADDR
1007: LD_INT 9
1009: PUSH
1010: LD_INT 8
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_OWVAR 67
1025: ARRAY
1026: PUSH
1027: FOR_TO
1028: IFFALSE 1199
// begin Randomize ;
1030: CALL_OW 10
// uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1034: LD_ADDR_OWVAR 21
1038: PUSH
1039: LD_INT 1
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 2
1054: PPUSH
1055: CALL_OW 12
1059: ARRAY
1060: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , skill ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 1
1066: PPUSH
1067: LD_INT 4
1069: PPUSH
1070: CALL_OW 12
1074: PPUSH
1075: LD_VAR 0 4
1079: PPUSH
1080: CALL_OW 380
// un := CreateHuman ;
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: CALL_OW 44
1093: ST_TO_ADDR
// case GetClass ( un ) of 1 :
1094: LD_VAR 0 3
1098: PPUSH
1099: CALL_OW 257
1103: PUSH
1104: LD_INT 1
1106: DOUBLE
1107: EQUAL
1108: IFTRUE 1112
1110: GO 1127
1112: POP
// PlaceHumanInUnit ( un , br ) ; 2 :
1113: LD_VAR 0 3
1117: PPUSH
1118: LD_INT 21
1120: PPUSH
1121: CALL_OW 52
1125: GO 1197
1127: LD_INT 2
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1150
1135: POP
// PlaceHumanInUnit ( un , brave ) ; 3 :
1136: LD_VAR 0 3
1140: PPUSH
1141: LD_INT 1
1143: PPUSH
1144: CALL_OW 52
1148: GO 1197
1150: LD_INT 3
1152: DOUBLE
1153: EQUAL
1154: IFTRUE 1158
1156: GO 1173
1158: POP
// PlaceHumanInUnit ( un , fac ) ; 4 :
1159: LD_VAR 0 3
1163: PPUSH
1164: LD_INT 38
1166: PPUSH
1167: CALL_OW 52
1171: GO 1197
1173: LD_INT 4
1175: DOUBLE
1176: EQUAL
1177: IFTRUE 1181
1179: GO 1196
1181: POP
// PlaceHumanInUnit ( un , lab ) ; end ;
1182: LD_VAR 0 3
1186: PPUSH
1187: LD_INT 36
1189: PPUSH
1190: CALL_OW 52
1194: GO 1197
1196: POP
// end ;
1197: GO 1027
1199: POP
1200: POP
// uc_side := 2 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 2
1208: ST_TO_ADDR
// uc_nation := 2 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 2
1216: ST_TO_ADDR
// hc_name := _ ;
1217: LD_ADDR_OWVAR 26
1221: PUSH
1222: LD_STRING _
1224: ST_TO_ADDR
// hc_gallery :=  ;
1225: LD_ADDR_OWVAR 33
1229: PUSH
1230: LD_STRING 
1232: ST_TO_ADDR
// hc_class := 4 ;
1233: LD_ADDR_OWVAR 28
1237: PUSH
1238: LD_INT 4
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// doc := CreateHuman ;
1249: LD_ADDR_EXP 2
1253: PUSH
1254: CALL_OW 44
1258: ST_TO_ADDR
// end ; end_of_file
1259: LD_VAR 0 1
1263: RET
// export function Attack ( num ) ; var i , un , tmp ; begin
1264: LD_INT 0
1266: PPUSH
1267: PPUSH
1268: PPUSH
1269: PPUSH
// uc_side := 2 ;
1270: LD_ADDR_OWVAR 20
1274: PUSH
1275: LD_INT 2
1277: ST_TO_ADDR
// uc_nation := 2 ;
1278: LD_ADDR_OWVAR 21
1282: PUSH
1283: LD_INT 2
1285: ST_TO_ADDR
// tmp := [ ] ;
1286: LD_ADDR_VAR 0 5
1290: PUSH
1291: EMPTY
1292: ST_TO_ADDR
// hc_skills := [ [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] ] ;
1293: LD_ADDR_OWVAR 31
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: LD_INT 6
1303: PUSH
1304: LD_INT 10
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_OWVAR 67
1316: ARRAY
1317: PUSH
1318: LD_INT 3
1320: PUSH
1321: LD_INT 6
1323: PUSH
1324: LD_INT 10
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: LIST
1331: PUSH
1332: LD_OWVAR 67
1336: ARRAY
1337: PUSH
1338: LD_INT 3
1340: PUSH
1341: LD_INT 6
1343: PUSH
1344: LD_INT 10
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_OWVAR 67
1356: ARRAY
1357: PUSH
1358: LD_INT 3
1360: PUSH
1361: LD_INT 6
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: LD_OWVAR 67
1376: ARRAY
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: ST_TO_ADDR
// if FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) then
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 22
1389: PUSH
1390: LD_INT 7
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: PPUSH
1397: CALL_OW 70
1401: IFFALSE 1442
// for i in FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) do
1403: LD_ADDR_VAR 0 3
1407: PUSH
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 22
1413: PUSH
1414: LD_INT 7
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PPUSH
1421: CALL_OW 70
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1440
// RemoveUnit ( i ) ;
1429: LD_VAR 0 3
1433: PPUSH
1434: CALL_OW 64
1438: GO 1426
1440: POP
1441: POP
// if FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) then
1442: LD_INT 5
1444: PPUSH
1445: LD_INT 22
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 70
1459: IFFALSE 1500
// for i in FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) do
1461: LD_ADDR_VAR 0 3
1465: PUSH
1466: LD_INT 5
1468: PPUSH
1469: LD_INT 22
1471: PUSH
1472: LD_INT 7
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PPUSH
1479: CALL_OW 70
1483: PUSH
1484: FOR_IN
1485: IFFALSE 1498
// RemoveUnit ( i ) ;
1487: LD_VAR 0 3
1491: PPUSH
1492: CALL_OW 64
1496: GO 1484
1498: POP
1499: POP
// if FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) then
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 22
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 70
1517: IFFALSE 1558
// for i in FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) do
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_INT 1
1526: PPUSH
1527: LD_INT 22
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PPUSH
1537: CALL_OW 70
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1556
// RemoveUnit ( i ) ;
1545: LD_VAR 0 3
1549: PPUSH
1550: CALL_OW 64
1554: GO 1542
1556: POP
1557: POP
// if FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) then
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 7
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL_OW 70
1575: IFFALSE 1616
// for i in FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) do
1577: LD_ADDR_VAR 0 3
1581: PUSH
1582: LD_INT 2
1584: PPUSH
1585: LD_INT 22
1587: PUSH
1588: LD_INT 7
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 70
1599: PUSH
1600: FOR_IN
1601: IFFALSE 1614
// RemoveUnit ( i ) ;
1603: LD_VAR 0 3
1607: PPUSH
1608: CALL_OW 64
1612: GO 1600
1614: POP
1615: POP
// case num of 1 :
1616: LD_VAR 0 1
1620: PUSH
1621: LD_INT 1
1623: DOUBLE
1624: EQUAL
1625: IFTRUE 1629
1627: GO 1882
1629: POP
// begin for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: DOUBLE
1636: LD_INT 1
1638: DEC
1639: ST_TO_ADDR
1640: LD_INT 5
1642: PUSH
1643: LD_INT 6
1645: PUSH
1646: LD_INT 6
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_OWVAR 67
1658: ARRAY
1659: PUSH
1660: FOR_TO
1661: IFFALSE 1753
// begin uc_nation := 0 ;
1663: LD_ADDR_OWVAR 21
1667: PUSH
1668: LD_INT 0
1670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1671: LD_ADDR_OWVAR 28
1675: PUSH
1676: LD_INT 15
1678: ST_TO_ADDR
// hc_gallery :=  ;
1679: LD_ADDR_OWVAR 33
1683: PUSH
1684: LD_STRING 
1686: ST_TO_ADDR
// hc_name :=  ;
1687: LD_ADDR_OWVAR 26
1691: PUSH
1692: LD_STRING 
1694: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1695: LD_ADDR_OWVAR 29
1699: PUSH
1700: LD_INT 16
1702: PUSH
1703: LD_INT 12
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// un := CreateHuman ;
1710: LD_ADDR_VAR 0 4
1714: PUSH
1715: CALL_OW 44
1719: ST_TO_ADDR
// PlaceUnitArea ( un , north_spawn , false ) ;
1720: LD_VAR 0 4
1724: PPUSH
1725: LD_INT 1
1727: PPUSH
1728: LD_INT 0
1730: PPUSH
1731: CALL_OW 49
// tmp := tmp ^ un ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_VAR 0 4
1749: ADD
1750: ST_TO_ADDR
// end ;
1751: GO 1660
1753: POP
1754: POP
// for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
1755: LD_ADDR_VAR 0 3
1759: PUSH
1760: DOUBLE
1761: LD_INT 1
1763: DEC
1764: ST_TO_ADDR
1765: LD_INT 4
1767: PUSH
1768: LD_INT 5
1770: PUSH
1771: LD_INT 5
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: PUSH
1779: LD_OWVAR 67
1783: ARRAY
1784: PUSH
1785: FOR_TO
1786: IFFALSE 1878
// begin uc_nation := 0 ;
1788: LD_ADDR_OWVAR 21
1792: PUSH
1793: LD_INT 0
1795: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1796: LD_ADDR_OWVAR 28
1800: PUSH
1801: LD_INT 15
1803: ST_TO_ADDR
// hc_gallery :=  ;
1804: LD_ADDR_OWVAR 33
1808: PUSH
1809: LD_STRING 
1811: ST_TO_ADDR
// hc_name :=  ;
1812: LD_ADDR_OWVAR 26
1816: PUSH
1817: LD_STRING 
1819: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1820: LD_ADDR_OWVAR 29
1824: PUSH
1825: LD_INT 16
1827: PUSH
1828: LD_INT 12
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: ST_TO_ADDR
// un := CreateHuman ;
1835: LD_ADDR_VAR 0 4
1839: PUSH
1840: CALL_OW 44
1844: ST_TO_ADDR
// PlaceUnitArea ( un , east2_spawn , false ) ;
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 49
// tmp := tmp ^ un ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_VAR 0 4
1874: ADD
1875: ST_TO_ADDR
// end ;
1876: GO 1785
1878: POP
1879: POP
// end ; 2 :
1880: GO 2660
1882: LD_INT 2
1884: DOUBLE
1885: EQUAL
1886: IFTRUE 1890
1888: GO 2018
1890: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
1891: LD_ADDR_VAR 0 3
1895: PUSH
1896: DOUBLE
1897: LD_INT 1
1899: DEC
1900: ST_TO_ADDR
1901: LD_INT 3
1903: PUSH
1904: LD_INT 4
1906: PUSH
1907: LD_INT 5
1909: PUSH
1910: EMPTY
1911: LIST
1912: LIST
1913: LIST
1914: PUSH
1915: LD_OWVAR 67
1919: ARRAY
1920: PUSH
1921: FOR_TO
1922: IFFALSE 2014
// begin uc_nation := 0 ;
1924: LD_ADDR_OWVAR 21
1928: PUSH
1929: LD_INT 0
1931: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
1932: LD_ADDR_OWVAR 28
1936: PUSH
1937: LD_INT 17
1939: ST_TO_ADDR
// hc_gallery :=  ;
1940: LD_ADDR_OWVAR 33
1944: PUSH
1945: LD_STRING 
1947: ST_TO_ADDR
// hc_name :=  ;
1948: LD_ADDR_OWVAR 26
1952: PUSH
1953: LD_STRING 
1955: ST_TO_ADDR
// hc_attr := [ 22 , 12 ] ;
1956: LD_ADDR_OWVAR 29
1960: PUSH
1961: LD_INT 22
1963: PUSH
1964: LD_INT 12
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: ST_TO_ADDR
// un := CreateHuman ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: CALL_OW 44
1980: ST_TO_ADDR
// PlaceUnitArea ( un , west_spawn , false ) ;
1981: LD_VAR 0 4
1985: PPUSH
1986: LD_INT 3
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 49
// tmp := tmp ^ un ;
1996: LD_ADDR_VAR 0 5
2000: PUSH
2001: LD_VAR 0 5
2005: PUSH
2006: LD_VAR 0 4
2010: ADD
2011: ST_TO_ADDR
// end ;
2012: GO 1921
2014: POP
2015: POP
// end ; 3 :
2016: GO 2660
2018: LD_INT 3
2020: DOUBLE
2021: EQUAL
2022: IFTRUE 2026
2024: GO 2186
2026: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_INT 4
2039: PUSH
2040: LD_INT 5
2042: PUSH
2043: LD_INT 6
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PUSH
2051: LD_OWVAR 67
2055: ARRAY
2056: PUSH
2057: FOR_TO
2058: IFFALSE 2182
// begin uc_nation := 2 ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 2
2067: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2068: LD_ADDR_OWVAR 37
2072: PUSH
2073: LD_INT 14
2075: ST_TO_ADDR
// vc_engine := 3 ;
2076: LD_ADDR_OWVAR 39
2080: PUSH
2081: LD_INT 3
2083: ST_TO_ADDR
// vc_control := control_apeman ;
2084: LD_ADDR_OWVAR 38
2088: PUSH
2089: LD_INT 5
2091: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 27
2099: PUSH
2100: LD_INT 28
2102: PUSH
2103: LD_INT 29
2105: PUSH
2106: LD_INT 91
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PPUSH
2121: CALL_OW 12
2125: ARRAY
2126: ST_TO_ADDR
// un := CreateVehicle ;
2127: LD_ADDR_VAR 0 4
2131: PUSH
2132: CALL_OW 45
2136: ST_TO_ADDR
// tmp := tmp ^ un ;
2137: LD_ADDR_VAR 0 5
2141: PUSH
2142: LD_VAR 0 5
2146: PUSH
2147: LD_VAR 0 4
2151: ADD
2152: ST_TO_ADDR
// SetDir ( un , 0 ) ;
2153: LD_VAR 0 4
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 233
// PlaceUnitArea ( un , south_spawn , false ) ;
2165: LD_VAR 0 4
2169: PPUSH
2170: LD_INT 2
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: GO 2057
2182: POP
2183: POP
// end ; 4 :
2184: GO 2660
2186: LD_INT 4
2188: DOUBLE
2189: EQUAL
2190: IFTRUE 2194
2192: GO 2362
2194: POP
// begin for i = 1 to Rand ( 3 , [ 4 , 5 , 6 ] [ Difficulty ] ) do
2195: LD_ADDR_VAR 0 3
2199: PUSH
2200: DOUBLE
2201: LD_INT 1
2203: DEC
2204: ST_TO_ADDR
2205: LD_INT 3
2207: PPUSH
2208: LD_INT 4
2210: PUSH
2211: LD_INT 5
2213: PUSH
2214: LD_INT 6
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: CALL_OW 12
2232: PUSH
2233: FOR_TO
2234: IFFALSE 2358
// begin uc_nation := 2 ;
2236: LD_ADDR_OWVAR 21
2240: PUSH
2241: LD_INT 2
2243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 14
2251: ST_TO_ADDR
// vc_engine := 3 ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 3
2259: ST_TO_ADDR
// vc_control := control_apeman ;
2260: LD_ADDR_OWVAR 38
2264: PUSH
2265: LD_INT 5
2267: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2268: LD_ADDR_OWVAR 40
2272: PUSH
2273: LD_INT 27
2275: PUSH
2276: LD_INT 28
2278: PUSH
2279: LD_INT 29
2281: PUSH
2282: LD_INT 91
2284: PUSH
2285: EMPTY
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: PUSH
2291: LD_INT 1
2293: PPUSH
2294: LD_INT 4
2296: PPUSH
2297: CALL_OW 12
2301: ARRAY
2302: ST_TO_ADDR
// un := CreateVehicle ;
2303: LD_ADDR_VAR 0 4
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// tmp := tmp ^ un ;
2313: LD_ADDR_VAR 0 5
2317: PUSH
2318: LD_VAR 0 5
2322: PUSH
2323: LD_VAR 0 4
2327: ADD
2328: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2329: LD_VAR 0 4
2333: PPUSH
2334: LD_INT 3
2336: PPUSH
2337: CALL_OW 233
// PlaceUnitArea ( un , north_spawn , false ) ;
2341: LD_VAR 0 4
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_INT 0
2351: PPUSH
2352: CALL_OW 49
// end ;
2356: GO 2233
2358: POP
2359: POP
// end ; 5 :
2360: GO 2660
2362: LD_INT 5
2364: DOUBLE
2365: EQUAL
2366: IFTRUE 2370
2368: GO 2530
2370: POP
// begin for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: DOUBLE
2377: LD_INT 1
2379: DEC
2380: ST_TO_ADDR
2381: LD_INT 3
2383: PUSH
2384: LD_INT 4
2386: PUSH
2387: LD_INT 4
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: LD_OWVAR 67
2399: ARRAY
2400: PUSH
2401: FOR_TO
2402: IFFALSE 2526
// begin uc_nation := 2 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 2
2411: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2412: LD_ADDR_OWVAR 37
2416: PUSH
2417: LD_INT 14
2419: ST_TO_ADDR
// vc_engine := 3 ;
2420: LD_ADDR_OWVAR 39
2424: PUSH
2425: LD_INT 3
2427: ST_TO_ADDR
// vc_control := control_apeman ;
2428: LD_ADDR_OWVAR 38
2432: PUSH
2433: LD_INT 5
2435: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2436: LD_ADDR_OWVAR 40
2440: PUSH
2441: LD_INT 27
2443: PUSH
2444: LD_INT 28
2446: PUSH
2447: LD_INT 29
2449: PUSH
2450: LD_INT 91
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 1
2461: PPUSH
2462: LD_INT 4
2464: PPUSH
2465: CALL_OW 12
2469: ARRAY
2470: ST_TO_ADDR
// un := CreateVehicle ;
2471: LD_ADDR_VAR 0 4
2475: PUSH
2476: CALL_OW 45
2480: ST_TO_ADDR
// tmp := tmp ^ un ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_VAR 0 4
2495: ADD
2496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 4
2504: PPUSH
2505: CALL_OW 233
// PlaceUnitArea ( un , east2_spawn , false ) ;
2509: LD_VAR 0 4
2513: PPUSH
2514: LD_INT 5
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: CALL_OW 49
// end ;
2524: GO 2401
2526: POP
2527: POP
// end ; 6 :
2528: GO 2660
2530: LD_INT 6
2532: DOUBLE
2533: EQUAL
2534: IFTRUE 2538
2536: GO 2659
2538: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: DOUBLE
2545: LD_INT 1
2547: DEC
2548: ST_TO_ADDR
2549: LD_INT 2
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 4
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_OWVAR 67
2567: ARRAY
2568: PUSH
2569: FOR_TO
2570: IFFALSE 2655
// begin uc_nation := 2 ;
2572: LD_ADDR_OWVAR 21
2576: PUSH
2577: LD_INT 2
2579: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
2580: LD_ADDR_OWVAR 37
2584: PUSH
2585: LD_INT 11
2587: ST_TO_ADDR
// vc_engine := engine_combustion ;
2588: LD_ADDR_OWVAR 39
2592: PUSH
2593: LD_INT 1
2595: ST_TO_ADDR
// vc_control := control_apeman ;
2596: LD_ADDR_OWVAR 38
2600: PUSH
2601: LD_INT 5
2603: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
2604: LD_ADDR_OWVAR 40
2608: PUSH
2609: LD_INT 24
2611: ST_TO_ADDR
// un := CreateVehicle ;
2612: LD_ADDR_VAR 0 4
2616: PUSH
2617: CALL_OW 45
2621: ST_TO_ADDR
// tmp := tmp ^ un ;
2622: LD_ADDR_VAR 0 5
2626: PUSH
2627: LD_VAR 0 5
2631: PUSH
2632: LD_VAR 0 4
2636: ADD
2637: ST_TO_ADDR
// PlaceUnitArea ( un , river , false ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_INT 8
2645: PPUSH
2646: LD_INT 0
2648: PPUSH
2649: CALL_OW 49
// end ;
2653: GO 2569
2655: POP
2656: POP
// end ; end ;
2657: GO 2660
2659: POP
// result := tmp ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 5
2669: ST_TO_ADDR
// end ;
2670: LD_VAR 0 2
2674: RET
// export function ComitSib ; var un ; begin
2675: LD_INT 0
2677: PPUSH
2678: PPUSH
// uc_side := 2 ;
2679: LD_ADDR_OWVAR 20
2683: PUSH
2684: LD_INT 2
2686: ST_TO_ADDR
// uc_nation := 2 ;
2687: LD_ADDR_OWVAR 21
2691: PUSH
2692: LD_INT 2
2694: ST_TO_ADDR
// PrepareHuman ( false , 4 , 7 ) ;
2695: LD_INT 0
2697: PPUSH
2698: LD_INT 4
2700: PPUSH
2701: LD_INT 7
2703: PPUSH
2704: CALL_OW 380
// un := CreateHuman ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: CALL_OW 44
2717: ST_TO_ADDR
// PlaceUnitArea ( un , east1_spawn , false ) ;
2718: LD_VAR 0 2
2722: PPUSH
2723: LD_INT 4
2725: PPUSH
2726: LD_INT 0
2728: PPUSH
2729: CALL_OW 49
// ComContaminate ( un , 63 , 37 ) ;
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 63
2740: PPUSH
2741: LD_INT 37
2743: PPUSH
2744: CALL_OW 158
// end ;
2748: LD_VAR 0 1
2752: RET
// export function DSay ; var i ; begin
2753: LD_INT 0
2755: PPUSH
2756: PPUSH
// Randomize ;
2757: CALL_OW 10
// i := Rand ( 1 , 8 ) ;
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: LD_INT 1
2768: PPUSH
2769: LD_INT 8
2771: PPUSH
2772: CALL_OW 12
2776: ST_TO_ADDR
// case i of 1 :
2777: LD_VAR 0 2
2781: PUSH
2782: LD_INT 1
2784: DOUBLE
2785: EQUAL
2786: IFTRUE 2790
2788: GO 2805
2790: POP
// SayRadio ( doc , DDocA1 ) ; 2 :
2791: LD_EXP 2
2795: PPUSH
2796: LD_STRING DDocA1
2798: PPUSH
2799: CALL_OW 94
2803: GO 2967
2805: LD_INT 2
2807: DOUBLE
2808: EQUAL
2809: IFTRUE 2813
2811: GO 2828
2813: POP
// SayRadio ( doc , DDocA2 ) ; 3 :
2814: LD_EXP 2
2818: PPUSH
2819: LD_STRING DDocA2
2821: PPUSH
2822: CALL_OW 94
2826: GO 2967
2828: LD_INT 3
2830: DOUBLE
2831: EQUAL
2832: IFTRUE 2836
2834: GO 2851
2836: POP
// SayRadio ( doc , DDocA3 ) ; 4 :
2837: LD_EXP 2
2841: PPUSH
2842: LD_STRING DDocA3
2844: PPUSH
2845: CALL_OW 94
2849: GO 2967
2851: LD_INT 4
2853: DOUBLE
2854: EQUAL
2855: IFTRUE 2859
2857: GO 2874
2859: POP
// SayRadio ( doc , DDocA4 ) ; 5 :
2860: LD_EXP 2
2864: PPUSH
2865: LD_STRING DDocA4
2867: PPUSH
2868: CALL_OW 94
2872: GO 2967
2874: LD_INT 5
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2897
2882: POP
// SayRadio ( doc , DDocA5 ) ; 6 :
2883: LD_EXP 2
2887: PPUSH
2888: LD_STRING DDocA5
2890: PPUSH
2891: CALL_OW 94
2895: GO 2967
2897: LD_INT 6
2899: DOUBLE
2900: EQUAL
2901: IFTRUE 2905
2903: GO 2920
2905: POP
// SayRadio ( doc , DDocA6 ) ; 7 :
2906: LD_EXP 2
2910: PPUSH
2911: LD_STRING DDocA6
2913: PPUSH
2914: CALL_OW 94
2918: GO 2967
2920: LD_INT 7
2922: DOUBLE
2923: EQUAL
2924: IFTRUE 2928
2926: GO 2943
2928: POP
// SayRadio ( doc , DDocA7 ) ; 8 :
2929: LD_EXP 2
2933: PPUSH
2934: LD_STRING DDocA7
2936: PPUSH
2937: CALL_OW 94
2941: GO 2967
2943: LD_INT 8
2945: DOUBLE
2946: EQUAL
2947: IFTRUE 2951
2949: GO 2966
2951: POP
// SayRadio ( doc , DDocA8 ) ; end ;
2952: LD_EXP 2
2956: PPUSH
2957: LD_STRING DDocA8
2959: PPUSH
2960: CALL_OW 94
2964: GO 2967
2966: POP
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// every 0 0$01 do
2972: GO 2974
2974: DISABLE
// begin display_strings := [ #tick , tick ] ;
2975: LD_ADDR_OWVAR 47
2979: PUSH
2980: LD_STRING #tick
2982: PUSH
2983: LD_OWVAR 1
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: ST_TO_ADDR
// enable ;
2992: ENABLE
// end ;
2993: END
// export pom , hover , attackN ; every 1 do
2994: GO 2996
2996: DISABLE
// begin pom := [ ] ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: EMPTY
3003: ST_TO_ADDR
// hover := [ ] ;
3004: LD_ADDR_EXP 5
3008: PUSH
3009: EMPTY
3010: ST_TO_ADDR
// attackN := 0 ;
3011: LD_ADDR_EXP 6
3015: PUSH
3016: LD_INT 0
3018: ST_TO_ADDR
// end ;
3019: END
// every 0 0$01 trigger pom do var i , f , z , target ;
3020: LD_EXP 4
3024: IFFALSE 3446
3026: GO 3028
3028: DISABLE
3029: LD_INT 0
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
// begin enable ;
3035: ENABLE
// f := FilterAllUnits ( [ f_side , 7 ] ) ;
3036: LD_ADDR_VAR 0 2
3040: PUSH
3041: LD_INT 22
3043: PUSH
3044: LD_INT 7
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: PPUSH
3051: CALL_OW 69
3055: ST_TO_ADDR
// for i = 1 to pom do
3056: LD_ADDR_VAR 0 1
3060: PUSH
3061: DOUBLE
3062: LD_INT 1
3064: DEC
3065: ST_TO_ADDR
3066: LD_EXP 4
3070: PUSH
3071: FOR_TO
3072: IFFALSE 3130
// if not HasTask ( pom [ i ] ) then
3074: LD_EXP 4
3078: PUSH
3079: LD_VAR 0 1
3083: ARRAY
3084: PPUSH
3085: CALL_OW 314
3089: NOT
3090: IFFALSE 3128
// ComAttackUnit ( pom [ i ] , NearestUnitToUnit ( f , pom [ i ] ) ) ;
3092: LD_EXP 4
3096: PUSH
3097: LD_VAR 0 1
3101: ARRAY
3102: PPUSH
3103: LD_VAR 0 2
3107: PPUSH
3108: LD_EXP 4
3112: PUSH
3113: LD_VAR 0 1
3117: ARRAY
3118: PPUSH
3119: CALL_OW 74
3123: PPUSH
3124: CALL_OW 115
3128: GO 3071
3130: POP
3131: POP
// if hover then
3132: LD_EXP 5
3136: IFFALSE 3446
// begin for i = 1 to hover do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 5
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3444
// begin if GetLives ( hover [ i ] ) < 250 then
3156: LD_EXP 5
3160: PUSH
3161: LD_VAR 0 1
3165: ARRAY
3166: PPUSH
3167: CALL_OW 256
3171: PUSH
3172: LD_INT 250
3174: LESS
3175: IFFALSE 3242
// begin for z = 1 to 1 + Difficulty do
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: DOUBLE
3183: LD_INT 1
3185: DEC
3186: ST_TO_ADDR
3187: LD_INT 1
3189: PUSH
3190: LD_OWVAR 67
3194: PLUS
3195: PUSH
3196: FOR_TO
3197: IFFALSE 3240
// MineExplosion ( GetX ( hover [ i ] ) , GetY ( hover [ i ] ) , 10 ) ;
3199: LD_EXP 5
3203: PUSH
3204: LD_VAR 0 1
3208: ARRAY
3209: PPUSH
3210: CALL_OW 250
3214: PPUSH
3215: LD_EXP 5
3219: PUSH
3220: LD_VAR 0 1
3224: ARRAY
3225: PPUSH
3226: CALL_OW 251
3230: PPUSH
3231: LD_INT 10
3233: PPUSH
3234: CALL_OW 453
3238: GO 3196
3240: POP
3241: POP
// end ; if UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) > 0 then
3242: LD_VAR 0 2
3246: PPUSH
3247: LD_INT 25
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: LD_INT 54
3262: PUSH
3263: EMPTY
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PPUSH
3274: CALL_OW 72
3278: PUSH
3279: LD_INT 0
3281: GREATER
3282: IFFALSE 3364
// begin target := UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) ;
3284: LD_ADDR_VAR 0 4
3288: PUSH
3289: LD_VAR 0 2
3293: PPUSH
3294: LD_INT 25
3296: PUSH
3297: LD_INT 2
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PUSH
3304: LD_INT 3
3306: PUSH
3307: LD_INT 54
3309: PUSH
3310: EMPTY
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 72
3325: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3326: LD_EXP 5
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PPUSH
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_EXP 5
3346: PUSH
3347: LD_VAR 0 1
3351: ARRAY
3352: PPUSH
3353: CALL_OW 74
3357: PPUSH
3358: CALL_OW 115
// end else
3362: GO 3442
// begin target := UnitFilter ( f , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) ;
3364: LD_ADDR_VAR 0 4
3368: PUSH
3369: LD_VAR 0 2
3373: PPUSH
3374: LD_INT 21
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 3
3386: PUSH
3387: LD_INT 54
3389: PUSH
3390: EMPTY
3391: LIST
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PPUSH
3401: CALL_OW 72
3405: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3406: LD_EXP 5
3410: PUSH
3411: LD_VAR 0 1
3415: ARRAY
3416: PPUSH
3417: LD_VAR 0 4
3421: PPUSH
3422: LD_EXP 5
3426: PUSH
3427: LD_VAR 0 1
3431: ARRAY
3432: PPUSH
3433: CALL_OW 74
3437: PPUSH
3438: CALL_OW 115
// end ; end ;
3442: GO 3153
3444: POP
3445: POP
// end ; end ;
3446: PPOPN 4
3448: END
// every 3 3$10 do var i , un ;
3449: GO 3451
3451: DISABLE
3452: LD_INT 0
3454: PPUSH
3455: PPUSH
// begin uc_side := 7 ;
3456: LD_ADDR_OWVAR 20
3460: PUSH
3461: LD_INT 7
3463: ST_TO_ADDR
// uc_nation := 1 ;
3464: LD_ADDR_OWVAR 21
3468: PUSH
3469: LD_INT 1
3471: ST_TO_ADDR
// for i = 1 to 2 do
3472: LD_ADDR_VAR 0 1
3476: PUSH
3477: DOUBLE
3478: LD_INT 1
3480: DEC
3481: ST_TO_ADDR
3482: LD_INT 2
3484: PUSH
3485: FOR_TO
3486: IFFALSE 3651
// begin PrepareHuman ( sex_male , class_sniper , [ 7 , 6 , 6 ] [ Difficulty ] ) ;
3488: LD_INT 1
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: LD_INT 7
3496: PUSH
3497: LD_INT 6
3499: PUSH
3500: LD_INT 6
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_OWVAR 67
3512: ARRAY
3513: PPUSH
3514: CALL_OW 380
// vc_chassis := us_light_wheeled ;
3518: LD_ADDR_OWVAR 37
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// vc_engine := engine_combustion ;
3526: LD_ADDR_OWVAR 39
3530: PUSH
3531: LD_INT 1
3533: ST_TO_ADDR
// vc_control := control_manual ;
3534: LD_ADDR_OWVAR 38
3538: PUSH
3539: LD_INT 1
3541: ST_TO_ADDR
// vc_fuel_battery := 66 ;
3542: LD_ADDR_OWVAR 41
3546: PUSH
3547: LD_INT 66
3549: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
3550: LD_ADDR_OWVAR 40
3554: PUSH
3555: LD_INT 2
3557: ST_TO_ADDR
// un := CreateVehicle ;
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: CALL_OW 45
3567: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3568: LD_VAR 0 2
3572: PPUSH
3573: LD_INT 3
3575: PPUSH
3576: CALL_OW 233
// PlaceUnitXY ( un , 48 , 3 , false ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_INT 48
3587: PPUSH
3588: LD_INT 3
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , un ) ;
3598: CALL_OW 44
3602: PPUSH
3603: LD_VAR 0 2
3607: PPUSH
3608: CALL_OW 52
// ComMoveXY ( un , 49 , 17 ) ;
3612: LD_VAR 0 2
3616: PPUSH
3617: LD_INT 49
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: CALL_OW 111
// AddComMoveXY ( un , 48 , 36 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_INT 48
3634: PPUSH
3635: LD_INT 36
3637: PPUSH
3638: CALL_OW 171
// Wait ( 0 0$02 ) ;
3642: LD_INT 70
3644: PPUSH
3645: CALL_OW 67
// end ;
3649: GO 3485
3651: POP
3652: POP
// end ;
3653: PPOPN 2
3655: END
// every 5 5$00 + 3 3$00 trigger attackN < [ 10 , 12 , 14 ] [ Difficulty ] do var c , l ;
3656: LD_EXP 6
3660: PUSH
3661: LD_INT 10
3663: PUSH
3664: LD_INT 12
3666: PUSH
3667: LD_INT 14
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_OWVAR 67
3679: ARRAY
3680: LESS
3681: IFFALSE 4383
3683: GO 3685
3685: DISABLE
3686: LD_INT 0
3688: PPUSH
3689: PPUSH
// begin enable ;
3690: ENABLE
// Randomize ;
3691: CALL_OW 10
// Wait ( Rand ( 0 0$01 , 2 2$59 ) ) ;
3695: LD_INT 35
3697: PPUSH
3698: LD_INT 6265
3700: PPUSH
3701: CALL_OW 12
3705: PPUSH
3706: CALL_OW 67
// if attackN < [ 4 , 4 , 5 ] [ Difficulty ] then
3710: LD_EXP 6
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 4
3720: PUSH
3721: LD_INT 5
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PUSH
3729: LD_OWVAR 67
3733: ARRAY
3734: LESS
3735: IFFALSE 3755
// c := Rand ( 1 , 2 ) else
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PPUSH
3745: LD_INT 2
3747: PPUSH
3748: CALL_OW 12
3752: ST_TO_ADDR
3753: GO 3771
// c := Rand ( 1 , 3 ) ;
3755: LD_ADDR_VAR 0 1
3759: PUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 3
3765: PPUSH
3766: CALL_OW 12
3770: ST_TO_ADDR
// if attackN = 0 then
3771: LD_EXP 6
3775: PUSH
3776: LD_INT 0
3778: EQUAL
3779: IFFALSE 3795
// Say ( com , DJackAttack ) else
3781: LD_EXP 1
3785: PPUSH
3786: LD_STRING DJackAttack
3788: PPUSH
3789: CALL_OW 88
3793: GO 3799
// DSay ;
3795: CALL 2753 0 0
// case c of 1 :
3799: LD_VAR 0 1
3803: PUSH
3804: LD_INT 1
3806: DOUBLE
3807: EQUAL
3808: IFTRUE 3812
3810: GO 3994
3812: POP
// begin pom := pom ^ Attack ( 1 ) ;
3813: LD_ADDR_EXP 4
3817: PUSH
3818: LD_EXP 4
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: CALL 1264 0 1
3830: ADD
3831: ST_TO_ADDR
// Wait ( 0 0$12 ) ;
3832: LD_INT 420
3834: PPUSH
3835: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3839: LD_ADDR_EXP 4
3843: PUSH
3844: LD_EXP 4
3848: PUSH
3849: LD_INT 3
3851: PPUSH
3852: CALL 1264 0 1
3856: ADD
3857: ST_TO_ADDR
// if Difficulty > 2 then
3858: LD_OWVAR 67
3862: PUSH
3863: LD_INT 2
3865: GREATER
3866: IFFALSE 3894
// begin Wait ( 0 0$46 ) ;
3868: LD_INT 1610
3870: PPUSH
3871: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
3875: LD_ADDR_EXP 4
3879: PUSH
3880: LD_EXP 4
3884: PUSH
3885: LD_INT 4
3887: PPUSH
3888: CALL 1264 0 1
3892: ADD
3893: ST_TO_ADDR
// end ; if attackN > 4 then
3894: LD_EXP 6
3898: PUSH
3899: LD_INT 4
3901: GREATER
3902: IFFALSE 3930
// begin Wait ( 0 0$12 ) ;
3904: LD_INT 420
3906: PPUSH
3907: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3911: LD_ADDR_EXP 4
3915: PUSH
3916: LD_EXP 4
3920: PUSH
3921: LD_INT 3
3923: PPUSH
3924: CALL 1264 0 1
3928: ADD
3929: ST_TO_ADDR
// end ; if attackN > 8 then
3930: LD_EXP 6
3934: PUSH
3935: LD_INT 8
3937: GREATER
3938: IFFALSE 3992
// begin Wait ( 0 0$12 ) ;
3940: LD_INT 420
3942: PPUSH
3943: CALL_OW 67
// l := Rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// if l < 45 then
3963: LD_VAR 0 2
3967: PUSH
3968: LD_INT 45
3970: LESS
3971: IFFALSE 3992
// pom := pom ^ Attack ( 2 ) ;
3973: LD_ADDR_EXP 4
3977: PUSH
3978: LD_EXP 4
3982: PUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL 1264 0 1
3990: ADD
3991: ST_TO_ADDR
// end ; end ; 2 :
3992: GO 4281
3994: LD_INT 2
3996: DOUBLE
3997: EQUAL
3998: IFTRUE 4002
4000: GO 4150
4002: POP
// begin pom := pom ^ Attack ( 2 ) ;
4003: LD_ADDR_EXP 4
4007: PUSH
4008: LD_EXP 4
4012: PUSH
4013: LD_INT 2
4015: PPUSH
4016: CALL 1264 0 1
4020: ADD
4021: ST_TO_ADDR
// pom := pom ^ Attack ( 3 ) ;
4022: LD_ADDR_EXP 4
4026: PUSH
4027: LD_EXP 4
4031: PUSH
4032: LD_INT 3
4034: PPUSH
4035: CALL 1264 0 1
4039: ADD
4040: ST_TO_ADDR
// if Difficulty > 1 and GetBType ( HexInfo ( 63 , 37 ) ) = b_siberite_mine then
4041: LD_OWVAR 67
4045: PUSH
4046: LD_INT 1
4048: GREATER
4049: PUSH
4050: LD_INT 63
4052: PPUSH
4053: LD_INT 37
4055: PPUSH
4056: CALL_OW 428
4060: PPUSH
4061: CALL_OW 266
4065: PUSH
4066: LD_INT 30
4068: EQUAL
4069: AND
4070: IFFALSE 4076
// ComitSib ;
4072: CALL 2675 0 0
// if Difficulty > 2 then
4076: LD_OWVAR 67
4080: PUSH
4081: LD_INT 2
4083: GREATER
4084: IFFALSE 4112
// begin Wait ( 0 0$25 ) ;
4086: LD_INT 875
4088: PPUSH
4089: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
4093: LD_ADDR_EXP 4
4097: PUSH
4098: LD_EXP 4
4102: PUSH
4103: LD_INT 4
4105: PPUSH
4106: CALL 1264 0 1
4110: ADD
4111: ST_TO_ADDR
// end ; if attackN > 7 then
4112: LD_EXP 6
4116: PUSH
4117: LD_INT 7
4119: GREATER
4120: IFFALSE 4148
// begin Wait ( 0 0$15 ) ;
4122: LD_INT 525
4124: PPUSH
4125: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4129: LD_ADDR_EXP 4
4133: PUSH
4134: LD_EXP 4
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: CALL 1264 0 1
4146: ADD
4147: ST_TO_ADDR
// end ; end ; 3 :
4148: GO 4281
4150: LD_INT 3
4152: DOUBLE
4153: EQUAL
4154: IFTRUE 4158
4156: GO 4280
4158: POP
// begin pom := pom ^ Attack ( 1 ) ;
4159: LD_ADDR_EXP 4
4163: PUSH
4164: LD_EXP 4
4168: PUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL 1264 0 1
4176: ADD
4177: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
4178: LD_INT 70
4180: PPUSH
4181: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4185: LD_ADDR_EXP 4
4189: PUSH
4190: LD_EXP 4
4194: PUSH
4195: LD_INT 2
4197: PPUSH
4198: CALL 1264 0 1
4202: ADD
4203: ST_TO_ADDR
// Wait ( 1 1$00 ) ;
4204: LD_INT 2100
4206: PPUSH
4207: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4211: LD_ADDR_EXP 4
4215: PUSH
4216: LD_EXP 4
4220: PUSH
4221: LD_INT 3
4223: PPUSH
4224: CALL 1264 0 1
4228: ADD
4229: ST_TO_ADDR
// pom := pom ^ Attack ( 5 ) ;
4230: LD_ADDR_EXP 4
4234: PUSH
4235: LD_EXP 4
4239: PUSH
4240: LD_INT 5
4242: PPUSH
4243: CALL 1264 0 1
4247: ADD
4248: ST_TO_ADDR
// if attackN > 10 then
4249: LD_EXP 6
4253: PUSH
4254: LD_INT 10
4256: GREATER
4257: IFFALSE 4278
// pom := pom ^ Attack ( 2 ) ;
4259: LD_ADDR_EXP 4
4263: PUSH
4264: LD_EXP 4
4268: PUSH
4269: LD_INT 2
4271: PPUSH
4272: CALL 1264 0 1
4276: ADD
4277: ST_TO_ADDR
// end ; end ;
4278: GO 4281
4280: POP
// if Difficulty > 1 and attackN mod 4 = 0 then
4281: LD_OWVAR 67
4285: PUSH
4286: LD_INT 1
4288: GREATER
4289: PUSH
4290: LD_EXP 6
4294: PUSH
4295: LD_INT 4
4297: MOD
4298: PUSH
4299: LD_INT 0
4301: EQUAL
4302: AND
4303: IFFALSE 4369
// begin Wait ( 1 1$45 ) ;
4305: LD_INT 3675
4307: PPUSH
4308: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4312: LD_ADDR_EXP 4
4316: PUSH
4317: LD_EXP 4
4321: PUSH
4322: LD_INT 3
4324: PPUSH
4325: CALL 1264 0 1
4329: ADD
4330: ST_TO_ADDR
// pom := pom ^ Attack ( 4 ) ;
4331: LD_ADDR_EXP 4
4335: PUSH
4336: LD_EXP 4
4340: PUSH
4341: LD_INT 4
4343: PPUSH
4344: CALL 1264 0 1
4348: ADD
4349: ST_TO_ADDR
// hover := hover ^ Attack ( 6 ) ;
4350: LD_ADDR_EXP 5
4354: PUSH
4355: LD_EXP 5
4359: PUSH
4360: LD_INT 6
4362: PPUSH
4363: CALL 1264 0 1
4367: ADD
4368: ST_TO_ADDR
// end ; attackN := attackN + 1 ;
4369: LD_ADDR_EXP 6
4373: PUSH
4374: LD_EXP 6
4378: PUSH
4379: LD_INT 1
4381: PLUS
4382: ST_TO_ADDR
// end ;
4383: PPOPN 2
4385: END
// every 0 0$10 trigger attackN >= [ 10 , 12 , 14 ] [ Difficulty ] and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
4386: LD_EXP 6
4390: PUSH
4391: LD_INT 10
4393: PUSH
4394: LD_INT 12
4396: PUSH
4397: LD_INT 14
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PUSH
4405: LD_OWVAR 67
4409: ARRAY
4410: GREATEREQUAL
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PPUSH
4422: CALL_OW 69
4426: PUSH
4427: LD_INT 0
4429: EQUAL
4430: AND
4431: IFFALSE 4487
4433: GO 4435
4435: DISABLE
// begin SayRadio ( doc , DDocEnd ) ;
4436: LD_EXP 2
4440: PPUSH
4441: LD_STRING DDocEnd
4443: PPUSH
4444: CALL_OW 94
// Wait ( 0 0$03 ) ;
4448: LD_INT 105
4450: PPUSH
4451: CALL_OW 67
// case Query ( QWin ) of 1 :
4455: LD_STRING QWin
4457: PPUSH
4458: CALL_OW 97
4462: PUSH
4463: LD_INT 1
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4474
4471: POP
// ; end ;
4472: GO 4475
4474: POP
// music_nat := 5 ;
4475: LD_ADDR_OWVAR 71
4479: PUSH
4480: LD_INT 5
4482: ST_TO_ADDR
// YouWin ;
4483: CALL_OW 103
// end ; end_of_file
4487: END
// on UnitDestroyed ( un ) do begin if un = brave or un = com then
4488: LD_VAR 0 1
4492: PUSH
4493: LD_INT 1
4495: EQUAL
4496: PUSH
4497: LD_VAR 0 1
4501: PUSH
4502: LD_EXP 1
4506: EQUAL
4507: OR
4508: IFFALSE 4529
// begin SayRadio ( doc , DDocWin ) ;
4510: LD_EXP 2
4514: PPUSH
4515: LD_STRING DDocWin
4517: PPUSH
4518: CALL_OW 94
// YouLost (  ) ;
4522: LD_STRING 
4524: PPUSH
4525: CALL_OW 104
// end ; end ;
4529: PPOPN 1
4531: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4532: LD_VAR 0 1
4536: PPUSH
4537: LD_VAR 0 2
4541: PPUSH
4542: LD_VAR 0 3
4546: PPUSH
4547: CALL 9368 0 3
// end ;
4551: PPOPN 3
4553: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4554: LD_VAR 0 1
4558: PPUSH
4559: CALL 9466 0 1
// end ; end_of_file
4563: PPOPN 1
4565: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4566: GO 4568
4568: DISABLE
// begin ru_radar := 98 ;
4569: LD_ADDR_EXP 7
4573: PUSH
4574: LD_INT 98
4576: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4577: LD_ADDR_EXP 8
4581: PUSH
4582: LD_INT 89
4584: ST_TO_ADDR
// us_hack := 99 ;
4585: LD_ADDR_EXP 9
4589: PUSH
4590: LD_INT 99
4592: ST_TO_ADDR
// us_artillery := 97 ;
4593: LD_ADDR_EXP 10
4597: PUSH
4598: LD_INT 97
4600: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4601: LD_ADDR_EXP 11
4605: PUSH
4606: LD_INT 91
4608: ST_TO_ADDR
// end ; end_of_file end_of_file
4609: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
4610: GO 4612
4612: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4613: LD_STRING initStreamRollete();
4615: PPUSH
4616: CALL_OW 559
// InitStreamMode ;
4620: CALL 4625 0 0
// end ;
4624: END
// function InitStreamMode ; begin
4625: LD_INT 0
4627: PPUSH
// streamModeActive := false ;
4628: LD_ADDR_EXP 12
4632: PUSH
4633: LD_INT 0
4635: ST_TO_ADDR
// sRocket := false ;
4636: LD_ADDR_EXP 15
4640: PUSH
4641: LD_INT 0
4643: ST_TO_ADDR
// sSpeed := false ;
4644: LD_ADDR_EXP 14
4648: PUSH
4649: LD_INT 0
4651: ST_TO_ADDR
// sEngine := false ;
4652: LD_ADDR_EXP 16
4656: PUSH
4657: LD_INT 0
4659: ST_TO_ADDR
// sSpec := false ;
4660: LD_ADDR_EXP 13
4664: PUSH
4665: LD_INT 0
4667: ST_TO_ADDR
// sLevel := false ;
4668: LD_ADDR_EXP 17
4672: PUSH
4673: LD_INT 0
4675: ST_TO_ADDR
// sArmoury := false ;
4676: LD_ADDR_EXP 18
4680: PUSH
4681: LD_INT 0
4683: ST_TO_ADDR
// sRadar := false ;
4684: LD_ADDR_EXP 19
4688: PUSH
4689: LD_INT 0
4691: ST_TO_ADDR
// sBunker := false ;
4692: LD_ADDR_EXP 20
4696: PUSH
4697: LD_INT 0
4699: ST_TO_ADDR
// sHack := false ;
4700: LD_ADDR_EXP 21
4704: PUSH
4705: LD_INT 0
4707: ST_TO_ADDR
// sFire := false ;
4708: LD_ADDR_EXP 22
4712: PUSH
4713: LD_INT 0
4715: ST_TO_ADDR
// sRefresh := false ;
4716: LD_ADDR_EXP 23
4720: PUSH
4721: LD_INT 0
4723: ST_TO_ADDR
// sExp := false ;
4724: LD_ADDR_EXP 24
4728: PUSH
4729: LD_INT 0
4731: ST_TO_ADDR
// sDepot := false ;
4732: LD_ADDR_EXP 25
4736: PUSH
4737: LD_INT 0
4739: ST_TO_ADDR
// sFlag := false ;
4740: LD_ADDR_EXP 26
4744: PUSH
4745: LD_INT 0
4747: ST_TO_ADDR
// sKamikadze := false ;
4748: LD_ADDR_EXP 34
4752: PUSH
4753: LD_INT 0
4755: ST_TO_ADDR
// sTroll := false ;
4756: LD_ADDR_EXP 35
4760: PUSH
4761: LD_INT 0
4763: ST_TO_ADDR
// sSlow := false ;
4764: LD_ADDR_EXP 36
4768: PUSH
4769: LD_INT 0
4771: ST_TO_ADDR
// sLack := false ;
4772: LD_ADDR_EXP 37
4776: PUSH
4777: LD_INT 0
4779: ST_TO_ADDR
// sTank := false ;
4780: LD_ADDR_EXP 39
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// sRemote := false ;
4788: LD_ADDR_EXP 40
4792: PUSH
4793: LD_INT 0
4795: ST_TO_ADDR
// sPowell := false ;
4796: LD_ADDR_EXP 41
4800: PUSH
4801: LD_INT 0
4803: ST_TO_ADDR
// sTeleport := false ;
4804: LD_ADDR_EXP 44
4808: PUSH
4809: LD_INT 0
4811: ST_TO_ADDR
// sOilTower := false ;
4812: LD_ADDR_EXP 46
4816: PUSH
4817: LD_INT 0
4819: ST_TO_ADDR
// sShovel := false ;
4820: LD_ADDR_EXP 47
4824: PUSH
4825: LD_INT 0
4827: ST_TO_ADDR
// sSheik := false ;
4828: LD_ADDR_EXP 48
4832: PUSH
4833: LD_INT 0
4835: ST_TO_ADDR
// sSold := false ;
4836: LD_ADDR_EXP 27
4840: PUSH
4841: LD_INT 0
4843: ST_TO_ADDR
// sDiff := false ;
4844: LD_ADDR_EXP 28
4848: PUSH
4849: LD_INT 0
4851: ST_TO_ADDR
// sFog := false ;
4852: LD_ADDR_EXP 31
4856: PUSH
4857: LD_INT 0
4859: ST_TO_ADDR
// sReset := false ;
4860: LD_ADDR_EXP 32
4864: PUSH
4865: LD_INT 0
4867: ST_TO_ADDR
// sSun := false ;
4868: LD_ADDR_EXP 33
4872: PUSH
4873: LD_INT 0
4875: ST_TO_ADDR
// sTiger := false ;
4876: LD_ADDR_EXP 29
4880: PUSH
4881: LD_INT 0
4883: ST_TO_ADDR
// sBomb := false ;
4884: LD_ADDR_EXP 30
4888: PUSH
4889: LD_INT 0
4891: ST_TO_ADDR
// sWound := false ;
4892: LD_ADDR_EXP 38
4896: PUSH
4897: LD_INT 0
4899: ST_TO_ADDR
// sBetray := false ;
4900: LD_ADDR_EXP 42
4904: PUSH
4905: LD_INT 0
4907: ST_TO_ADDR
// sContamin := false ;
4908: LD_ADDR_EXP 43
4912: PUSH
4913: LD_INT 0
4915: ST_TO_ADDR
// sOil := false ;
4916: LD_ADDR_EXP 45
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// sStu := false ;
4924: LD_ADDR_EXP 49
4928: PUSH
4929: LD_INT 0
4931: ST_TO_ADDR
// end ;
4932: LD_VAR 0 1
4936: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
4937: LD_VAR 0 2
4941: PUSH
4942: LD_INT 100
4944: EQUAL
4945: IFFALSE 5642
// begin if not StreamModeActive then
4947: LD_EXP 12
4951: NOT
4952: IFFALSE 4962
// StreamModeActive := true ;
4954: LD_ADDR_EXP 12
4958: PUSH
4959: LD_INT 1
4961: ST_TO_ADDR
// if p3 = 0 then
4962: LD_VAR 0 3
4966: PUSH
4967: LD_INT 0
4969: EQUAL
4970: IFFALSE 4976
// InitStreamMode ;
4972: CALL 4625 0 0
// if p3 = 1 then
4976: LD_VAR 0 3
4980: PUSH
4981: LD_INT 1
4983: EQUAL
4984: IFFALSE 4994
// sRocket := true ;
4986: LD_ADDR_EXP 15
4990: PUSH
4991: LD_INT 1
4993: ST_TO_ADDR
// if p3 = 2 then
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 2
5001: EQUAL
5002: IFFALSE 5012
// sSpeed := true ;
5004: LD_ADDR_EXP 14
5008: PUSH
5009: LD_INT 1
5011: ST_TO_ADDR
// if p3 = 3 then
5012: LD_VAR 0 3
5016: PUSH
5017: LD_INT 3
5019: EQUAL
5020: IFFALSE 5030
// sEngine := true ;
5022: LD_ADDR_EXP 16
5026: PUSH
5027: LD_INT 1
5029: ST_TO_ADDR
// if p3 = 4 then
5030: LD_VAR 0 3
5034: PUSH
5035: LD_INT 4
5037: EQUAL
5038: IFFALSE 5048
// sSpec := true ;
5040: LD_ADDR_EXP 13
5044: PUSH
5045: LD_INT 1
5047: ST_TO_ADDR
// if p3 = 5 then
5048: LD_VAR 0 3
5052: PUSH
5053: LD_INT 5
5055: EQUAL
5056: IFFALSE 5066
// sLevel := true ;
5058: LD_ADDR_EXP 17
5062: PUSH
5063: LD_INT 1
5065: ST_TO_ADDR
// if p3 = 6 then
5066: LD_VAR 0 3
5070: PUSH
5071: LD_INT 6
5073: EQUAL
5074: IFFALSE 5084
// sArmoury := true ;
5076: LD_ADDR_EXP 18
5080: PUSH
5081: LD_INT 1
5083: ST_TO_ADDR
// if p3 = 7 then
5084: LD_VAR 0 3
5088: PUSH
5089: LD_INT 7
5091: EQUAL
5092: IFFALSE 5102
// sRadar := true ;
5094: LD_ADDR_EXP 19
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// if p3 = 8 then
5102: LD_VAR 0 3
5106: PUSH
5107: LD_INT 8
5109: EQUAL
5110: IFFALSE 5120
// sBunker := true ;
5112: LD_ADDR_EXP 20
5116: PUSH
5117: LD_INT 1
5119: ST_TO_ADDR
// if p3 = 9 then
5120: LD_VAR 0 3
5124: PUSH
5125: LD_INT 9
5127: EQUAL
5128: IFFALSE 5138
// sHack := true ;
5130: LD_ADDR_EXP 21
5134: PUSH
5135: LD_INT 1
5137: ST_TO_ADDR
// if p3 = 10 then
5138: LD_VAR 0 3
5142: PUSH
5143: LD_INT 10
5145: EQUAL
5146: IFFALSE 5156
// sFire := true ;
5148: LD_ADDR_EXP 22
5152: PUSH
5153: LD_INT 1
5155: ST_TO_ADDR
// if p3 = 11 then
5156: LD_VAR 0 3
5160: PUSH
5161: LD_INT 11
5163: EQUAL
5164: IFFALSE 5174
// sRefresh := true ;
5166: LD_ADDR_EXP 23
5170: PUSH
5171: LD_INT 1
5173: ST_TO_ADDR
// if p3 = 12 then
5174: LD_VAR 0 3
5178: PUSH
5179: LD_INT 12
5181: EQUAL
5182: IFFALSE 5192
// sExp := true ;
5184: LD_ADDR_EXP 24
5188: PUSH
5189: LD_INT 1
5191: ST_TO_ADDR
// if p3 = 13 then
5192: LD_VAR 0 3
5196: PUSH
5197: LD_INT 13
5199: EQUAL
5200: IFFALSE 5210
// sDepot := true ;
5202: LD_ADDR_EXP 25
5206: PUSH
5207: LD_INT 1
5209: ST_TO_ADDR
// if p3 = 14 then
5210: LD_VAR 0 3
5214: PUSH
5215: LD_INT 14
5217: EQUAL
5218: IFFALSE 5228
// sFlag := true ;
5220: LD_ADDR_EXP 26
5224: PUSH
5225: LD_INT 1
5227: ST_TO_ADDR
// if p3 = 15 then
5228: LD_VAR 0 3
5232: PUSH
5233: LD_INT 15
5235: EQUAL
5236: IFFALSE 5246
// sKamikadze := true ;
5238: LD_ADDR_EXP 34
5242: PUSH
5243: LD_INT 1
5245: ST_TO_ADDR
// if p3 = 16 then
5246: LD_VAR 0 3
5250: PUSH
5251: LD_INT 16
5253: EQUAL
5254: IFFALSE 5264
// sTroll := true ;
5256: LD_ADDR_EXP 35
5260: PUSH
5261: LD_INT 1
5263: ST_TO_ADDR
// if p3 = 17 then
5264: LD_VAR 0 3
5268: PUSH
5269: LD_INT 17
5271: EQUAL
5272: IFFALSE 5282
// sSlow := true ;
5274: LD_ADDR_EXP 36
5278: PUSH
5279: LD_INT 1
5281: ST_TO_ADDR
// if p3 = 18 then
5282: LD_VAR 0 3
5286: PUSH
5287: LD_INT 18
5289: EQUAL
5290: IFFALSE 5300
// sLack := true ;
5292: LD_ADDR_EXP 37
5296: PUSH
5297: LD_INT 1
5299: ST_TO_ADDR
// if p3 = 19 then
5300: LD_VAR 0 3
5304: PUSH
5305: LD_INT 19
5307: EQUAL
5308: IFFALSE 5318
// sTank := true ;
5310: LD_ADDR_EXP 39
5314: PUSH
5315: LD_INT 1
5317: ST_TO_ADDR
// if p3 = 20 then
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 20
5325: EQUAL
5326: IFFALSE 5336
// sRemote := true ;
5328: LD_ADDR_EXP 40
5332: PUSH
5333: LD_INT 1
5335: ST_TO_ADDR
// if p3 = 21 then
5336: LD_VAR 0 3
5340: PUSH
5341: LD_INT 21
5343: EQUAL
5344: IFFALSE 5354
// sPowell := true ;
5346: LD_ADDR_EXP 41
5350: PUSH
5351: LD_INT 1
5353: ST_TO_ADDR
// if p3 = 22 then
5354: LD_VAR 0 3
5358: PUSH
5359: LD_INT 22
5361: EQUAL
5362: IFFALSE 5372
// sTeleport := true ;
5364: LD_ADDR_EXP 44
5368: PUSH
5369: LD_INT 1
5371: ST_TO_ADDR
// if p3 = 23 then
5372: LD_VAR 0 3
5376: PUSH
5377: LD_INT 23
5379: EQUAL
5380: IFFALSE 5390
// sOilTower := true ;
5382: LD_ADDR_EXP 46
5386: PUSH
5387: LD_INT 1
5389: ST_TO_ADDR
// if p3 = 24 then
5390: LD_VAR 0 3
5394: PUSH
5395: LD_INT 24
5397: EQUAL
5398: IFFALSE 5408
// sShovel := true ;
5400: LD_ADDR_EXP 47
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// if p3 = 25 then
5408: LD_VAR 0 3
5412: PUSH
5413: LD_INT 25
5415: EQUAL
5416: IFFALSE 5426
// sSheik := true ;
5418: LD_ADDR_EXP 48
5422: PUSH
5423: LD_INT 1
5425: ST_TO_ADDR
// if p3 = 101 then
5426: LD_VAR 0 3
5430: PUSH
5431: LD_INT 101
5433: EQUAL
5434: IFFALSE 5444
// sSold := true ;
5436: LD_ADDR_EXP 27
5440: PUSH
5441: LD_INT 1
5443: ST_TO_ADDR
// if p3 = 102 then
5444: LD_VAR 0 3
5448: PUSH
5449: LD_INT 102
5451: EQUAL
5452: IFFALSE 5462
// sDiff := true ;
5454: LD_ADDR_EXP 28
5458: PUSH
5459: LD_INT 1
5461: ST_TO_ADDR
// if p3 = 103 then
5462: LD_VAR 0 3
5466: PUSH
5467: LD_INT 103
5469: EQUAL
5470: IFFALSE 5480
// sFog := true ;
5472: LD_ADDR_EXP 31
5476: PUSH
5477: LD_INT 1
5479: ST_TO_ADDR
// if p3 = 104 then
5480: LD_VAR 0 3
5484: PUSH
5485: LD_INT 104
5487: EQUAL
5488: IFFALSE 5498
// sReset := true ;
5490: LD_ADDR_EXP 32
5494: PUSH
5495: LD_INT 1
5497: ST_TO_ADDR
// if p3 = 105 then
5498: LD_VAR 0 3
5502: PUSH
5503: LD_INT 105
5505: EQUAL
5506: IFFALSE 5516
// sSun := true ;
5508: LD_ADDR_EXP 33
5512: PUSH
5513: LD_INT 1
5515: ST_TO_ADDR
// if p3 = 106 then
5516: LD_VAR 0 3
5520: PUSH
5521: LD_INT 106
5523: EQUAL
5524: IFFALSE 5534
// sTiger := true ;
5526: LD_ADDR_EXP 29
5530: PUSH
5531: LD_INT 1
5533: ST_TO_ADDR
// if p3 = 107 then
5534: LD_VAR 0 3
5538: PUSH
5539: LD_INT 107
5541: EQUAL
5542: IFFALSE 5552
// sBomb := true ;
5544: LD_ADDR_EXP 30
5548: PUSH
5549: LD_INT 1
5551: ST_TO_ADDR
// if p3 = 108 then
5552: LD_VAR 0 3
5556: PUSH
5557: LD_INT 108
5559: EQUAL
5560: IFFALSE 5570
// sWound := true ;
5562: LD_ADDR_EXP 38
5566: PUSH
5567: LD_INT 1
5569: ST_TO_ADDR
// if p3 = 109 then
5570: LD_VAR 0 3
5574: PUSH
5575: LD_INT 109
5577: EQUAL
5578: IFFALSE 5588
// sBetray := true ;
5580: LD_ADDR_EXP 42
5584: PUSH
5585: LD_INT 1
5587: ST_TO_ADDR
// if p3 = 110 then
5588: LD_VAR 0 3
5592: PUSH
5593: LD_INT 110
5595: EQUAL
5596: IFFALSE 5606
// sContamin := true ;
5598: LD_ADDR_EXP 43
5602: PUSH
5603: LD_INT 1
5605: ST_TO_ADDR
// if p3 = 111 then
5606: LD_VAR 0 3
5610: PUSH
5611: LD_INT 111
5613: EQUAL
5614: IFFALSE 5624
// sOil := true ;
5616: LD_ADDR_EXP 45
5620: PUSH
5621: LD_INT 1
5623: ST_TO_ADDR
// if p3 = 112 then
5624: LD_VAR 0 3
5628: PUSH
5629: LD_INT 112
5631: EQUAL
5632: IFFALSE 5642
// sStu := true ;
5634: LD_ADDR_EXP 49
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
// end ; end ;
5642: PPOPN 6
5644: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5645: LD_EXP 12
5649: PUSH
5650: LD_EXP 15
5654: AND
5655: IFFALSE 5779
5657: GO 5659
5659: DISABLE
5660: LD_INT 0
5662: PPUSH
5663: PPUSH
// begin enable ;
5664: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: LD_INT 22
5672: PUSH
5673: LD_OWVAR 2
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 2
5684: PUSH
5685: LD_INT 34
5687: PUSH
5688: LD_INT 7
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: PUSH
5695: LD_INT 34
5697: PUSH
5698: LD_INT 45
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PUSH
5705: LD_INT 34
5707: PUSH
5708: LD_INT 28
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 34
5717: PUSH
5718: LD_INT 47
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL_OW 69
5740: ST_TO_ADDR
// if not tmp then
5741: LD_VAR 0 2
5745: NOT
5746: IFFALSE 5750
// exit ;
5748: GO 5779
// for i in tmp do
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_VAR 0 2
5759: PUSH
5760: FOR_IN
5761: IFFALSE 5777
// begin SetLives ( i , 0 ) ;
5763: LD_VAR 0 1
5767: PPUSH
5768: LD_INT 0
5770: PPUSH
5771: CALL_OW 234
// end ;
5775: GO 5760
5777: POP
5778: POP
// end ;
5779: PPOPN 2
5781: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5782: LD_EXP 12
5786: PUSH
5787: LD_EXP 16
5791: AND
5792: IFFALSE 5873
5794: GO 5796
5796: DISABLE
5797: LD_INT 0
5799: PPUSH
5800: PPUSH
// begin enable ;
5801: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5802: LD_ADDR_VAR 0 2
5806: PUSH
5807: LD_INT 22
5809: PUSH
5810: LD_OWVAR 2
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PUSH
5819: LD_INT 32
5821: PUSH
5822: LD_INT 3
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PPUSH
5833: CALL_OW 69
5837: ST_TO_ADDR
// if not tmp then
5838: LD_VAR 0 2
5842: NOT
5843: IFFALSE 5847
// exit ;
5845: GO 5873
// for i in tmp do
5847: LD_ADDR_VAR 0 1
5851: PUSH
5852: LD_VAR 0 2
5856: PUSH
5857: FOR_IN
5858: IFFALSE 5871
// begin DestroyUnit ( i ) ;
5860: LD_VAR 0 1
5864: PPUSH
5865: CALL_OW 65
// end ;
5869: GO 5857
5871: POP
5872: POP
// end ;
5873: PPOPN 2
5875: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5876: LD_EXP 12
5880: PUSH
5881: LD_EXP 13
5885: AND
5886: IFFALSE 5979
5888: GO 5890
5890: DISABLE
5891: LD_INT 0
5893: PPUSH
// begin enable ;
5894: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: LD_INT 22
5902: PUSH
5903: LD_OWVAR 2
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: PUSH
5912: LD_INT 2
5914: PUSH
5915: LD_INT 25
5917: PUSH
5918: LD_INT 5
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 25
5927: PUSH
5928: LD_INT 9
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 25
5937: PUSH
5938: LD_INT 8
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PPUSH
5955: CALL_OW 69
5959: PUSH
5960: FOR_IN
5961: IFFALSE 5977
// begin SetClass ( i , 1 ) ;
5963: LD_VAR 0 1
5967: PPUSH
5968: LD_INT 1
5970: PPUSH
5971: CALL_OW 336
// end ;
5975: GO 5960
5977: POP
5978: POP
// end ;
5979: PPOPN 1
5981: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5982: LD_EXP 12
5986: PUSH
5987: LD_EXP 14
5991: AND
5992: PUSH
5993: LD_OWVAR 65
5997: PUSH
5998: LD_INT 7
6000: LESS
6001: AND
6002: IFFALSE 6016
6004: GO 6006
6006: DISABLE
// begin enable ;
6007: ENABLE
// game_speed := 7 ;
6008: LD_ADDR_OWVAR 65
6012: PUSH
6013: LD_INT 7
6015: ST_TO_ADDR
// end ;
6016: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
6017: LD_EXP 12
6021: PUSH
6022: LD_EXP 17
6026: AND
6027: IFFALSE 6229
6029: GO 6031
6031: DISABLE
6032: LD_INT 0
6034: PPUSH
6035: PPUSH
6036: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
6037: LD_ADDR_VAR 0 3
6041: PUSH
6042: LD_INT 81
6044: PUSH
6045: LD_OWVAR 2
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PUSH
6054: LD_INT 21
6056: PUSH
6057: LD_INT 1
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 69
6072: ST_TO_ADDR
// if not tmp then
6073: LD_VAR 0 3
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6229
// if tmp > 5 then
6082: LD_VAR 0 3
6086: PUSH
6087: LD_INT 5
6089: GREATER
6090: IFFALSE 6102
// k := 5 else
6092: LD_ADDR_VAR 0 2
6096: PUSH
6097: LD_INT 5
6099: ST_TO_ADDR
6100: GO 6112
// k := tmp ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 3
6111: ST_TO_ADDR
// for i := 1 to k do
6112: LD_ADDR_VAR 0 1
6116: PUSH
6117: DOUBLE
6118: LD_INT 1
6120: DEC
6121: ST_TO_ADDR
6122: LD_VAR 0 2
6126: PUSH
6127: FOR_TO
6128: IFFALSE 6227
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
6130: LD_VAR 0 3
6134: PUSH
6135: LD_VAR 0 1
6139: ARRAY
6140: PPUSH
6141: LD_VAR 0 1
6145: PUSH
6146: LD_INT 4
6148: MOD
6149: PUSH
6150: LD_INT 1
6152: PLUS
6153: PPUSH
6154: CALL_OW 259
6158: PUSH
6159: LD_INT 10
6161: LESS
6162: IFFALSE 6225
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
6164: LD_VAR 0 3
6168: PUSH
6169: LD_VAR 0 1
6173: ARRAY
6174: PPUSH
6175: LD_VAR 0 1
6179: PUSH
6180: LD_INT 4
6182: MOD
6183: PUSH
6184: LD_INT 1
6186: PLUS
6187: PPUSH
6188: LD_VAR 0 3
6192: PUSH
6193: LD_VAR 0 1
6197: ARRAY
6198: PPUSH
6199: LD_VAR 0 1
6203: PUSH
6204: LD_INT 4
6206: MOD
6207: PUSH
6208: LD_INT 1
6210: PLUS
6211: PPUSH
6212: CALL_OW 259
6216: PUSH
6217: LD_INT 1
6219: PLUS
6220: PPUSH
6221: CALL_OW 237
6225: GO 6127
6227: POP
6228: POP
// end ;
6229: PPOPN 3
6231: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
6232: LD_EXP 12
6236: PUSH
6237: LD_EXP 18
6241: AND
6242: IFFALSE 6262
6244: GO 6246
6246: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
6247: LD_INT 4
6249: PPUSH
6250: LD_OWVAR 2
6254: PPUSH
6255: LD_INT 0
6257: PPUSH
6258: CALL_OW 324
6262: END
// every 0 0$1 trigger StreamModeActive and sShovel do
6263: LD_EXP 12
6267: PUSH
6268: LD_EXP 47
6272: AND
6273: IFFALSE 6293
6275: GO 6277
6277: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
6278: LD_INT 19
6280: PPUSH
6281: LD_OWVAR 2
6285: PPUSH
6286: LD_INT 0
6288: PPUSH
6289: CALL_OW 324
6293: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
6294: LD_EXP 12
6298: PUSH
6299: LD_EXP 19
6303: AND
6304: IFFALSE 6403
6306: GO 6308
6308: DISABLE
6309: LD_INT 0
6311: PPUSH
6312: PPUSH
// begin enable ;
6313: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
6314: LD_ADDR_VAR 0 2
6318: PUSH
6319: LD_INT 22
6321: PUSH
6322: LD_OWVAR 2
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 34
6336: PUSH
6337: LD_INT 11
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 34
6346: PUSH
6347: LD_INT 30
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PPUSH
6363: CALL_OW 69
6367: ST_TO_ADDR
// if not tmp then
6368: LD_VAR 0 2
6372: NOT
6373: IFFALSE 6377
// exit ;
6375: GO 6403
// for i in tmp do
6377: LD_ADDR_VAR 0 1
6381: PUSH
6382: LD_VAR 0 2
6386: PUSH
6387: FOR_IN
6388: IFFALSE 6401
// begin DestroyUnit ( i ) ;
6390: LD_VAR 0 1
6394: PPUSH
6395: CALL_OW 65
// end ;
6399: GO 6387
6401: POP
6402: POP
// end ;
6403: PPOPN 2
6405: END
// every 0 0$1 trigger StreamModeActive and sBunker do
6406: LD_EXP 12
6410: PUSH
6411: LD_EXP 20
6415: AND
6416: IFFALSE 6436
6418: GO 6420
6420: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
6421: LD_INT 32
6423: PPUSH
6424: LD_OWVAR 2
6428: PPUSH
6429: LD_INT 0
6431: PPUSH
6432: CALL_OW 324
6436: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
6437: LD_EXP 12
6441: PUSH
6442: LD_EXP 21
6446: AND
6447: IFFALSE 6628
6449: GO 6451
6451: DISABLE
6452: LD_INT 0
6454: PPUSH
6455: PPUSH
6456: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6457: LD_ADDR_VAR 0 2
6461: PUSH
6462: LD_INT 22
6464: PUSH
6465: LD_OWVAR 2
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 33
6476: PUSH
6477: LD_INT 3
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: PPUSH
6488: CALL_OW 69
6492: ST_TO_ADDR
// if not tmp then
6493: LD_VAR 0 2
6497: NOT
6498: IFFALSE 6502
// exit ;
6500: GO 6628
// side := 0 ;
6502: LD_ADDR_VAR 0 3
6506: PUSH
6507: LD_INT 0
6509: ST_TO_ADDR
// for i := 1 to 8 do
6510: LD_ADDR_VAR 0 1
6514: PUSH
6515: DOUBLE
6516: LD_INT 1
6518: DEC
6519: ST_TO_ADDR
6520: LD_INT 8
6522: PUSH
6523: FOR_TO
6524: IFFALSE 6572
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6526: LD_OWVAR 2
6530: PUSH
6531: LD_VAR 0 1
6535: NONEQUAL
6536: PUSH
6537: LD_OWVAR 2
6541: PPUSH
6542: LD_VAR 0 1
6546: PPUSH
6547: CALL_OW 81
6551: PUSH
6552: LD_INT 2
6554: EQUAL
6555: AND
6556: IFFALSE 6570
// begin side := i ;
6558: LD_ADDR_VAR 0 3
6562: PUSH
6563: LD_VAR 0 1
6567: ST_TO_ADDR
// break ;
6568: GO 6572
// end ;
6570: GO 6523
6572: POP
6573: POP
// if not side then
6574: LD_VAR 0 3
6578: NOT
6579: IFFALSE 6583
// exit ;
6581: GO 6628
// for i := 1 to tmp do
6583: LD_ADDR_VAR 0 1
6587: PUSH
6588: DOUBLE
6589: LD_INT 1
6591: DEC
6592: ST_TO_ADDR
6593: LD_VAR 0 2
6597: PUSH
6598: FOR_TO
6599: IFFALSE 6626
// if Prob ( 30 ) then
6601: LD_INT 30
6603: PPUSH
6604: CALL_OW 13
6608: IFFALSE 6624
// SetSide ( i , side ) ;
6610: LD_VAR 0 1
6614: PPUSH
6615: LD_VAR 0 3
6619: PPUSH
6620: CALL_OW 235
6624: GO 6598
6626: POP
6627: POP
// end ;
6628: PPOPN 3
6630: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6631: LD_EXP 12
6635: PUSH
6636: LD_EXP 23
6640: AND
6641: IFFALSE 6760
6643: GO 6645
6645: DISABLE
6646: LD_INT 0
6648: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6649: LD_ADDR_VAR 0 1
6653: PUSH
6654: LD_INT 22
6656: PUSH
6657: LD_OWVAR 2
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: LD_INT 21
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: LD_INT 3
6678: PUSH
6679: LD_INT 23
6681: PUSH
6682: LD_INT 0
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: LIST
6697: PPUSH
6698: CALL_OW 69
6702: PUSH
6703: FOR_IN
6704: IFFALSE 6758
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6706: LD_VAR 0 1
6710: PPUSH
6711: CALL_OW 257
6715: PUSH
6716: LD_INT 1
6718: PUSH
6719: LD_INT 2
6721: PUSH
6722: LD_INT 3
6724: PUSH
6725: LD_INT 4
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: IN
6734: IFFALSE 6756
// SetClass ( un , rand ( 1 , 4 ) ) ;
6736: LD_VAR 0 1
6740: PPUSH
6741: LD_INT 1
6743: PPUSH
6744: LD_INT 4
6746: PPUSH
6747: CALL_OW 12
6751: PPUSH
6752: CALL_OW 336
6756: GO 6703
6758: POP
6759: POP
// end ;
6760: PPOPN 1
6762: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6763: LD_EXP 12
6767: PUSH
6768: LD_EXP 22
6772: AND
6773: IFFALSE 6852
6775: GO 6777
6777: DISABLE
6778: LD_INT 0
6780: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6781: LD_ADDR_VAR 0 1
6785: PUSH
6786: LD_INT 22
6788: PUSH
6789: LD_OWVAR 2
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: PUSH
6798: LD_INT 21
6800: PUSH
6801: LD_INT 3
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: ST_TO_ADDR
// if not tmp then
6817: LD_VAR 0 1
6821: NOT
6822: IFFALSE 6826
// exit ;
6824: GO 6852
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6826: LD_VAR 0 1
6830: PUSH
6831: LD_INT 1
6833: PPUSH
6834: LD_VAR 0 1
6838: PPUSH
6839: CALL_OW 12
6843: ARRAY
6844: PPUSH
6845: LD_INT 100
6847: PPUSH
6848: CALL_OW 234
// end ;
6852: PPOPN 1
6854: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6855: LD_EXP 12
6859: PUSH
6860: LD_EXP 24
6864: AND
6865: IFFALSE 6963
6867: GO 6869
6869: DISABLE
6870: LD_INT 0
6872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6873: LD_ADDR_VAR 0 1
6877: PUSH
6878: LD_INT 22
6880: PUSH
6881: LD_OWVAR 2
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 21
6892: PUSH
6893: LD_INT 1
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 69
6908: ST_TO_ADDR
// if not tmp then
6909: LD_VAR 0 1
6913: NOT
6914: IFFALSE 6918
// exit ;
6916: GO 6963
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6918: LD_VAR 0 1
6922: PUSH
6923: LD_INT 1
6925: PPUSH
6926: LD_VAR 0 1
6930: PPUSH
6931: CALL_OW 12
6935: ARRAY
6936: PPUSH
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 4
6942: PPUSH
6943: CALL_OW 12
6947: PPUSH
6948: LD_INT 3000
6950: PPUSH
6951: LD_INT 9000
6953: PPUSH
6954: CALL_OW 12
6958: PPUSH
6959: CALL_OW 492
// end ;
6963: PPOPN 1
6965: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6966: LD_EXP 12
6970: PUSH
6971: LD_EXP 25
6975: AND
6976: IFFALSE 6996
6978: GO 6980
6980: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6981: LD_INT 1
6983: PPUSH
6984: LD_OWVAR 2
6988: PPUSH
6989: LD_INT 0
6991: PPUSH
6992: CALL_OW 324
6996: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6997: LD_EXP 12
7001: PUSH
7002: LD_EXP 26
7006: AND
7007: IFFALSE 7090
7009: GO 7011
7011: DISABLE
7012: LD_INT 0
7014: PPUSH
7015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7016: LD_ADDR_VAR 0 2
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_OWVAR 2
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 21
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: CALL_OW 69
7051: ST_TO_ADDR
// if not tmp then
7052: LD_VAR 0 2
7056: NOT
7057: IFFALSE 7061
// exit ;
7059: GO 7090
// for i in tmp do
7061: LD_ADDR_VAR 0 1
7065: PUSH
7066: LD_VAR 0 2
7070: PUSH
7071: FOR_IN
7072: IFFALSE 7088
// SetBLevel ( i , 10 ) ;
7074: LD_VAR 0 1
7078: PPUSH
7079: LD_INT 10
7081: PPUSH
7082: CALL_OW 241
7086: GO 7071
7088: POP
7089: POP
// end ;
7090: PPOPN 2
7092: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
7093: LD_EXP 12
7097: PUSH
7098: LD_EXP 27
7102: AND
7103: IFFALSE 7214
7105: GO 7107
7107: DISABLE
7108: LD_INT 0
7110: PPUSH
7111: PPUSH
7112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
7113: LD_ADDR_VAR 0 3
7117: PUSH
7118: LD_INT 22
7120: PUSH
7121: LD_OWVAR 2
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 25
7132: PUSH
7133: LD_INT 1
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PPUSH
7144: CALL_OW 69
7148: ST_TO_ADDR
// if not tmp then
7149: LD_VAR 0 3
7153: NOT
7154: IFFALSE 7158
// exit ;
7156: GO 7214
// un := tmp [ rand ( 1 , tmp ) ] ;
7158: LD_ADDR_VAR 0 2
7162: PUSH
7163: LD_VAR 0 3
7167: PUSH
7168: LD_INT 1
7170: PPUSH
7171: LD_VAR 0 3
7175: PPUSH
7176: CALL_OW 12
7180: ARRAY
7181: ST_TO_ADDR
// if Crawls ( un ) then
7182: LD_VAR 0 2
7186: PPUSH
7187: CALL_OW 318
7191: IFFALSE 7202
// ComWalk ( un ) ;
7193: LD_VAR 0 2
7197: PPUSH
7198: CALL_OW 138
// SetClass ( un , class_sniper ) ;
7202: LD_VAR 0 2
7206: PPUSH
7207: LD_INT 5
7209: PPUSH
7210: CALL_OW 336
// end ;
7214: PPOPN 3
7216: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
7217: LD_EXP 12
7221: PUSH
7222: LD_EXP 28
7226: AND
7227: PUSH
7228: LD_OWVAR 67
7232: PUSH
7233: LD_INT 3
7235: LESS
7236: AND
7237: IFFALSE 7256
7239: GO 7241
7241: DISABLE
// Difficulty := Difficulty + 1 ;
7242: LD_ADDR_OWVAR 67
7246: PUSH
7247: LD_OWVAR 67
7251: PUSH
7252: LD_INT 1
7254: PLUS
7255: ST_TO_ADDR
7256: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
7257: LD_EXP 12
7261: PUSH
7262: LD_EXP 29
7266: AND
7267: IFFALSE 7370
7269: GO 7271
7271: DISABLE
7272: LD_INT 0
7274: PPUSH
// begin for i := 1 to 5 do
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: DOUBLE
7281: LD_INT 1
7283: DEC
7284: ST_TO_ADDR
7285: LD_INT 5
7287: PUSH
7288: FOR_TO
7289: IFFALSE 7368
// begin uc_nation := nation_nature ;
7291: LD_ADDR_OWVAR 21
7295: PUSH
7296: LD_INT 0
7298: ST_TO_ADDR
// uc_side := 0 ;
7299: LD_ADDR_OWVAR 20
7303: PUSH
7304: LD_INT 0
7306: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7307: LD_ADDR_OWVAR 29
7311: PUSH
7312: LD_INT 12
7314: PUSH
7315: LD_INT 12
7317: PUSH
7318: EMPTY
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// hc_agressivity := 20 ;
7322: LD_ADDR_OWVAR 35
7326: PUSH
7327: LD_INT 20
7329: ST_TO_ADDR
// hc_class := class_tiger ;
7330: LD_ADDR_OWVAR 28
7334: PUSH
7335: LD_INT 14
7337: ST_TO_ADDR
// hc_gallery :=  ;
7338: LD_ADDR_OWVAR 33
7342: PUSH
7343: LD_STRING 
7345: ST_TO_ADDR
// hc_name :=  ;
7346: LD_ADDR_OWVAR 26
7350: PUSH
7351: LD_STRING 
7353: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
7354: CALL_OW 44
7358: PPUSH
7359: LD_INT 0
7361: PPUSH
7362: CALL_OW 51
// end ;
7366: GO 7288
7368: POP
7369: POP
// end ;
7370: PPOPN 1
7372: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
7373: LD_EXP 12
7377: PUSH
7378: LD_EXP 30
7382: AND
7383: IFFALSE 7557
7385: GO 7387
7387: DISABLE
7388: LD_INT 0
7390: PPUSH
7391: PPUSH
7392: PPUSH
7393: PPUSH
// begin result := false ;
7394: LD_ADDR_VAR 0 4
7398: PUSH
7399: LD_INT 0
7401: ST_TO_ADDR
// for i := 1 to 8 do
7402: LD_ADDR_VAR 0 1
7406: PUSH
7407: DOUBLE
7408: LD_INT 1
7410: DEC
7411: ST_TO_ADDR
7412: LD_INT 8
7414: PUSH
7415: FOR_TO
7416: IFFALSE 7527
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_INT 10
7425: PUSH
7426: LD_INT 50
7428: PUSH
7429: LD_INT 90
7431: PUSH
7432: LD_INT 140
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: LIST
7439: LIST
7440: PUSH
7441: LD_INT 1
7443: PPUSH
7444: LD_INT 4
7446: PPUSH
7447: CALL_OW 12
7451: ARRAY
7452: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_INT 10
7460: PUSH
7461: LD_INT 50
7463: PUSH
7464: LD_INT 90
7466: PUSH
7467: LD_INT 140
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 1
7478: PPUSH
7479: LD_INT 4
7481: PPUSH
7482: CALL_OW 12
7486: ARRAY
7487: ST_TO_ADDR
// if ValidHex ( x , y ) then
7488: LD_VAR 0 2
7492: PPUSH
7493: LD_VAR 0 3
7497: PPUSH
7498: CALL_OW 488
7502: IFFALSE 7525
// begin result := [ x , y ] ;
7504: LD_ADDR_VAR 0 4
7508: PUSH
7509: LD_VAR 0 2
7513: PUSH
7514: LD_VAR 0 3
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: ST_TO_ADDR
// break ;
7523: GO 7527
// end ; end ;
7525: GO 7415
7527: POP
7528: POP
// if result then
7529: LD_VAR 0 4
7533: IFFALSE 7557
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7535: LD_VAR 0 4
7539: PUSH
7540: LD_INT 1
7542: ARRAY
7543: PPUSH
7544: LD_VAR 0 4
7548: PUSH
7549: LD_INT 2
7551: ARRAY
7552: PPUSH
7553: CALL_OW 429
// end ;
7557: PPOPN 4
7559: END
// every 0 0$1 trigger StreamModeActive and sReset do
7560: LD_EXP 12
7564: PUSH
7565: LD_EXP 32
7569: AND
7570: IFFALSE 7582
7572: GO 7574
7574: DISABLE
// YouLost (  ) ;
7575: LD_STRING 
7577: PPUSH
7578: CALL_OW 104
7582: END
// every 0 0$1 trigger StreamModeActive and sFog do
7583: LD_EXP 12
7587: PUSH
7588: LD_EXP 31
7592: AND
7593: IFFALSE 7607
7595: GO 7597
7597: DISABLE
// FogOff ( your_side ) ;
7598: LD_OWVAR 2
7602: PPUSH
7603: CALL_OW 344
7607: END
// every 0 0$1 trigger StreamModeActive and sSun do
7608: LD_EXP 12
7612: PUSH
7613: LD_EXP 33
7617: AND
7618: IFFALSE 7646
7620: GO 7622
7622: DISABLE
// begin solar_recharge_percent := 0 ;
7623: LD_ADDR_OWVAR 79
7627: PUSH
7628: LD_INT 0
7630: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7631: LD_INT 10500
7633: PPUSH
7634: CALL_OW 67
// solar_recharge_percent := 100 ;
7638: LD_ADDR_OWVAR 79
7642: PUSH
7643: LD_INT 100
7645: ST_TO_ADDR
// end ;
7646: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
7647: LD_EXP 12
7651: PUSH
7652: LD_EXP 34
7656: AND
7657: IFFALSE 7896
7659: GO 7661
7661: DISABLE
7662: LD_INT 0
7664: PPUSH
7665: PPUSH
7666: PPUSH
// begin tmp := [ ] ;
7667: LD_ADDR_VAR 0 3
7671: PUSH
7672: EMPTY
7673: ST_TO_ADDR
// for i := 1 to 6 do
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: DOUBLE
7680: LD_INT 1
7682: DEC
7683: ST_TO_ADDR
7684: LD_INT 6
7686: PUSH
7687: FOR_TO
7688: IFFALSE 7793
// begin uc_nation := nation_nature ;
7690: LD_ADDR_OWVAR 21
7694: PUSH
7695: LD_INT 0
7697: ST_TO_ADDR
// uc_side := 0 ;
7698: LD_ADDR_OWVAR 20
7702: PUSH
7703: LD_INT 0
7705: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7706: LD_ADDR_OWVAR 29
7710: PUSH
7711: LD_INT 12
7713: PUSH
7714: LD_INT 12
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: ST_TO_ADDR
// hc_agressivity := 20 ;
7721: LD_ADDR_OWVAR 35
7725: PUSH
7726: LD_INT 20
7728: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7729: LD_ADDR_OWVAR 28
7733: PUSH
7734: LD_INT 17
7736: ST_TO_ADDR
// hc_gallery :=  ;
7737: LD_ADDR_OWVAR 33
7741: PUSH
7742: LD_STRING 
7744: ST_TO_ADDR
// hc_name :=  ;
7745: LD_ADDR_OWVAR 26
7749: PUSH
7750: LD_STRING 
7752: ST_TO_ADDR
// un := CreateHuman ;
7753: LD_ADDR_VAR 0 2
7757: PUSH
7758: CALL_OW 44
7762: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7763: LD_VAR 0 2
7767: PPUSH
7768: LD_INT 1
7770: PPUSH
7771: CALL_OW 51
// tmp := tmp * un ;
7775: LD_ADDR_VAR 0 3
7779: PUSH
7780: LD_VAR 0 3
7784: PUSH
7785: LD_VAR 0 2
7789: MUL
7790: ST_TO_ADDR
// end ;
7791: GO 7687
7793: POP
7794: POP
// repeat wait ( 0 0$1 ) ;
7795: LD_INT 35
7797: PPUSH
7798: CALL_OW 67
// for un in tmp do
7802: LD_ADDR_VAR 0 2
7806: PUSH
7807: LD_VAR 0 3
7811: PUSH
7812: FOR_IN
7813: IFFALSE 7887
// begin if IsDead ( un ) then
7815: LD_VAR 0 2
7819: PPUSH
7820: CALL_OW 301
7824: IFFALSE 7844
// begin tmp := tmp diff un ;
7826: LD_ADDR_VAR 0 3
7830: PUSH
7831: LD_VAR 0 3
7835: PUSH
7836: LD_VAR 0 2
7840: DIFF
7841: ST_TO_ADDR
// continue ;
7842: GO 7812
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7844: LD_VAR 0 2
7848: PPUSH
7849: LD_INT 3
7851: PUSH
7852: LD_INT 22
7854: PUSH
7855: LD_INT 0
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: PPUSH
7871: LD_VAR 0 2
7875: PPUSH
7876: CALL_OW 74
7880: PPUSH
7881: CALL_OW 115
// end ;
7885: GO 7812
7887: POP
7888: POP
// until not tmp ;
7889: LD_VAR 0 3
7893: NOT
7894: IFFALSE 7795
// end ;
7896: PPOPN 3
7898: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7899: LD_EXP 12
7903: PUSH
7904: LD_EXP 35
7908: AND
7909: IFFALSE 7935
7911: GO 7913
7913: DISABLE
// begin ToLua ( displayTroll(); ) ;
7914: LD_STRING displayTroll();
7916: PPUSH
7917: CALL_OW 559
// wait ( 3 3$00 ) ;
7921: LD_INT 6300
7923: PPUSH
7924: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7928: LD_STRING hideTroll();
7930: PPUSH
7931: CALL_OW 559
// end ;
7935: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7936: LD_EXP 12
7940: PUSH
7941: LD_EXP 36
7945: AND
7946: IFFALSE 8009
7948: GO 7950
7950: DISABLE
7951: LD_INT 0
7953: PPUSH
// begin p := 0 ;
7954: LD_ADDR_VAR 0 1
7958: PUSH
7959: LD_INT 0
7961: ST_TO_ADDR
// repeat game_speed := 1 ;
7962: LD_ADDR_OWVAR 65
7966: PUSH
7967: LD_INT 1
7969: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7970: LD_INT 35
7972: PPUSH
7973: CALL_OW 67
// p := p + 1 ;
7977: LD_ADDR_VAR 0 1
7981: PUSH
7982: LD_VAR 0 1
7986: PUSH
7987: LD_INT 1
7989: PLUS
7990: ST_TO_ADDR
// until p >= 60 ;
7991: LD_VAR 0 1
7995: PUSH
7996: LD_INT 60
7998: GREATEREQUAL
7999: IFFALSE 7962
// game_speed := 4 ;
8001: LD_ADDR_OWVAR 65
8005: PUSH
8006: LD_INT 4
8008: ST_TO_ADDR
// end ;
8009: PPOPN 1
8011: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
8012: LD_EXP 12
8016: PUSH
8017: LD_EXP 37
8021: AND
8022: IFFALSE 8168
8024: GO 8026
8026: DISABLE
8027: LD_INT 0
8029: PPUSH
8030: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8031: LD_ADDR_VAR 0 1
8035: PUSH
8036: LD_INT 22
8038: PUSH
8039: LD_OWVAR 2
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 2
8050: PUSH
8051: LD_INT 30
8053: PUSH
8054: LD_INT 0
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: LD_INT 30
8063: PUSH
8064: LD_INT 1
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PPUSH
8080: CALL_OW 69
8084: ST_TO_ADDR
// if not depot then
8085: LD_VAR 0 1
8089: NOT
8090: IFFALSE 8094
// exit ;
8092: GO 8168
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
8094: LD_ADDR_VAR 0 2
8098: PUSH
8099: LD_VAR 0 1
8103: PUSH
8104: LD_INT 1
8106: PPUSH
8107: LD_VAR 0 1
8111: PPUSH
8112: CALL_OW 12
8116: ARRAY
8117: PPUSH
8118: CALL_OW 274
8122: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
8123: LD_VAR 0 2
8127: PPUSH
8128: LD_INT 1
8130: PPUSH
8131: LD_INT 0
8133: PPUSH
8134: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
8138: LD_VAR 0 2
8142: PPUSH
8143: LD_INT 2
8145: PPUSH
8146: LD_INT 0
8148: PPUSH
8149: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
8153: LD_VAR 0 2
8157: PPUSH
8158: LD_INT 3
8160: PPUSH
8161: LD_INT 0
8163: PPUSH
8164: CALL_OW 277
// end ;
8168: PPOPN 2
8170: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
8171: LD_EXP 12
8175: PUSH
8176: LD_EXP 38
8180: AND
8181: IFFALSE 8278
8183: GO 8185
8185: DISABLE
8186: LD_INT 0
8188: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
8189: LD_ADDR_VAR 0 1
8193: PUSH
8194: LD_INT 22
8196: PUSH
8197: LD_OWVAR 2
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PUSH
8206: LD_INT 21
8208: PUSH
8209: LD_INT 1
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: PUSH
8216: LD_INT 3
8218: PUSH
8219: LD_INT 23
8221: PUSH
8222: LD_INT 0
8224: PUSH
8225: EMPTY
8226: LIST
8227: LIST
8228: PUSH
8229: EMPTY
8230: LIST
8231: LIST
8232: PUSH
8233: EMPTY
8234: LIST
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 69
8242: ST_TO_ADDR
// if not tmp then
8243: LD_VAR 0 1
8247: NOT
8248: IFFALSE 8252
// exit ;
8250: GO 8278
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
8252: LD_VAR 0 1
8256: PUSH
8257: LD_INT 1
8259: PPUSH
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 12
8269: ARRAY
8270: PPUSH
8271: LD_INT 200
8273: PPUSH
8274: CALL_OW 234
// end ;
8278: PPOPN 1
8280: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
8281: LD_EXP 12
8285: PUSH
8286: LD_EXP 39
8290: AND
8291: IFFALSE 8370
8293: GO 8295
8295: DISABLE
8296: LD_INT 0
8298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8299: LD_ADDR_VAR 0 1
8303: PUSH
8304: LD_INT 22
8306: PUSH
8307: LD_OWVAR 2
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: PUSH
8316: LD_INT 21
8318: PUSH
8319: LD_INT 2
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PPUSH
8330: CALL_OW 69
8334: ST_TO_ADDR
// if not tmp then
8335: LD_VAR 0 1
8339: NOT
8340: IFFALSE 8344
// exit ;
8342: GO 8370
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
8344: LD_VAR 0 1
8348: PUSH
8349: LD_INT 1
8351: PPUSH
8352: LD_VAR 0 1
8356: PPUSH
8357: CALL_OW 12
8361: ARRAY
8362: PPUSH
8363: LD_INT 60
8365: PPUSH
8366: CALL_OW 234
// end ;
8370: PPOPN 1
8372: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8373: LD_EXP 12
8377: PUSH
8378: LD_EXP 40
8382: AND
8383: IFFALSE 8482
8385: GO 8387
8387: DISABLE
8388: LD_INT 0
8390: PPUSH
8391: PPUSH
// begin enable ;
8392: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8393: LD_ADDR_VAR 0 1
8397: PUSH
8398: LD_INT 22
8400: PUSH
8401: LD_OWVAR 2
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 61
8412: PUSH
8413: EMPTY
8414: LIST
8415: PUSH
8416: LD_INT 33
8418: PUSH
8419: LD_INT 2
8421: PUSH
8422: EMPTY
8423: LIST
8424: LIST
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: PPUSH
8431: CALL_OW 69
8435: ST_TO_ADDR
// if not tmp then
8436: LD_VAR 0 1
8440: NOT
8441: IFFALSE 8445
// exit ;
8443: GO 8482
// for i in tmp do
8445: LD_ADDR_VAR 0 2
8449: PUSH
8450: LD_VAR 0 1
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8480
// if IsControledBy ( i ) then
8458: LD_VAR 0 2
8462: PPUSH
8463: CALL_OW 312
8467: IFFALSE 8478
// ComUnlink ( i ) ;
8469: LD_VAR 0 2
8473: PPUSH
8474: CALL_OW 136
8478: GO 8455
8480: POP
8481: POP
// end ;
8482: PPOPN 2
8484: END
// every 0 0$1 trigger StreamModeActive and sPowell do
8485: LD_EXP 12
8489: PUSH
8490: LD_EXP 41
8494: AND
8495: IFFALSE 8535
8497: GO 8499
8499: DISABLE
// begin ToLua ( displayPowell(); ) ;
8500: LD_STRING displayPowell();
8502: PPUSH
8503: CALL_OW 559
// wait ( 0 0$20 ) ;
8507: LD_INT 700
8509: PPUSH
8510: CALL_OW 67
// ToLua ( displayPowell(); ) ;
8514: LD_STRING displayPowell();
8516: PPUSH
8517: CALL_OW 559
// wait ( 0 0$40 ) ;
8521: LD_INT 1400
8523: PPUSH
8524: CALL_OW 67
// ToLua ( displayPowell(); ) ;
8528: LD_STRING displayPowell();
8530: PPUSH
8531: CALL_OW 559
// end ;
8535: END
// every 0 0$1 trigger StreamModeActive and sStu do
8536: LD_EXP 12
8540: PUSH
8541: LD_EXP 49
8545: AND
8546: IFFALSE 8558
8548: GO 8550
8550: DISABLE
// begin ToLua ( displayStucuk(); ) ;
8551: LD_STRING displayStucuk();
8553: PPUSH
8554: CALL_OW 559
// end ;
8558: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
8559: LD_EXP 12
8563: PUSH
8564: LD_EXP 42
8568: AND
8569: IFFALSE 8710
8571: GO 8573
8573: DISABLE
8574: LD_INT 0
8576: PPUSH
8577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8578: LD_ADDR_VAR 0 2
8582: PUSH
8583: LD_INT 22
8585: PUSH
8586: LD_OWVAR 2
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PUSH
8595: LD_INT 21
8597: PUSH
8598: LD_INT 1
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: PPUSH
8609: CALL_OW 69
8613: ST_TO_ADDR
// if not tmp then
8614: LD_VAR 0 2
8618: NOT
8619: IFFALSE 8623
// exit ;
8621: GO 8710
// un := tmp [ rand ( 1 , tmp ) ] ;
8623: LD_ADDR_VAR 0 1
8627: PUSH
8628: LD_VAR 0 2
8632: PUSH
8633: LD_INT 1
8635: PPUSH
8636: LD_VAR 0 2
8640: PPUSH
8641: CALL_OW 12
8645: ARRAY
8646: ST_TO_ADDR
// SetSide ( un , 0 ) ;
8647: LD_VAR 0 1
8651: PPUSH
8652: LD_INT 0
8654: PPUSH
8655: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
8659: LD_VAR 0 1
8663: PPUSH
8664: LD_OWVAR 3
8668: PUSH
8669: LD_VAR 0 1
8673: DIFF
8674: PPUSH
8675: LD_VAR 0 1
8679: PPUSH
8680: CALL_OW 74
8684: PPUSH
8685: CALL_OW 115
// wait ( 0 0$20 ) ;
8689: LD_INT 700
8691: PPUSH
8692: CALL_OW 67
// SetSide ( un , your_side ) ;
8696: LD_VAR 0 1
8700: PPUSH
8701: LD_OWVAR 2
8705: PPUSH
8706: CALL_OW 235
// end ;
8710: PPOPN 2
8712: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
8713: LD_EXP 12
8717: PUSH
8718: LD_EXP 43
8722: AND
8723: IFFALSE 8829
8725: GO 8727
8727: DISABLE
8728: LD_INT 0
8730: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8731: LD_ADDR_VAR 0 1
8735: PUSH
8736: LD_INT 22
8738: PUSH
8739: LD_OWVAR 2
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: LD_INT 2
8750: PUSH
8751: LD_INT 30
8753: PUSH
8754: LD_INT 0
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: PUSH
8761: LD_INT 30
8763: PUSH
8764: LD_INT 1
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PUSH
8771: EMPTY
8772: LIST
8773: LIST
8774: LIST
8775: PUSH
8776: EMPTY
8777: LIST
8778: LIST
8779: PPUSH
8780: CALL_OW 69
8784: ST_TO_ADDR
// if not depot then
8785: LD_VAR 0 1
8789: NOT
8790: IFFALSE 8794
// exit ;
8792: GO 8829
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
8794: LD_VAR 0 1
8798: PUSH
8799: LD_INT 1
8801: ARRAY
8802: PPUSH
8803: CALL_OW 250
8807: PPUSH
8808: LD_VAR 0 1
8812: PUSH
8813: LD_INT 1
8815: ARRAY
8816: PPUSH
8817: CALL_OW 251
8821: PPUSH
8822: LD_INT 70
8824: PPUSH
8825: CALL_OW 495
// end ;
8829: PPOPN 1
8831: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
8832: LD_EXP 12
8836: PUSH
8837: LD_EXP 44
8841: AND
8842: IFFALSE 9053
8844: GO 8846
8846: DISABLE
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8854: LD_ADDR_VAR 0 5
8858: PUSH
8859: LD_INT 22
8861: PUSH
8862: LD_OWVAR 2
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: LD_INT 21
8873: PUSH
8874: LD_INT 1
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: PPUSH
8885: CALL_OW 69
8889: ST_TO_ADDR
// if not tmp then
8890: LD_VAR 0 5
8894: NOT
8895: IFFALSE 8899
// exit ;
8897: GO 9053
// for i in tmp do
8899: LD_ADDR_VAR 0 1
8903: PUSH
8904: LD_VAR 0 5
8908: PUSH
8909: FOR_IN
8910: IFFALSE 9051
// begin d := rand ( 0 , 5 ) ;
8912: LD_ADDR_VAR 0 4
8916: PUSH
8917: LD_INT 0
8919: PPUSH
8920: LD_INT 5
8922: PPUSH
8923: CALL_OW 12
8927: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
8928: LD_ADDR_VAR 0 2
8932: PUSH
8933: LD_VAR 0 1
8937: PPUSH
8938: CALL_OW 250
8942: PPUSH
8943: LD_VAR 0 4
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 12
8953: PPUSH
8954: CALL_OW 12
8958: PPUSH
8959: CALL_OW 272
8963: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
8964: LD_ADDR_VAR 0 3
8968: PUSH
8969: LD_VAR 0 1
8973: PPUSH
8974: CALL_OW 251
8978: PPUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: LD_INT 3
8986: PPUSH
8987: LD_INT 12
8989: PPUSH
8990: CALL_OW 12
8994: PPUSH
8995: CALL_OW 273
8999: ST_TO_ADDR
// if ValidHex ( x , y ) then
9000: LD_VAR 0 2
9004: PPUSH
9005: LD_VAR 0 3
9009: PPUSH
9010: CALL_OW 488
9014: IFFALSE 9049
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
9016: LD_VAR 0 1
9020: PPUSH
9021: LD_VAR 0 2
9025: PPUSH
9026: LD_VAR 0 3
9030: PPUSH
9031: LD_INT 3
9033: PPUSH
9034: LD_INT 6
9036: PPUSH
9037: CALL_OW 12
9041: PPUSH
9042: LD_INT 1
9044: PPUSH
9045: CALL_OW 483
// end ;
9049: GO 8909
9051: POP
9052: POP
// end ;
9053: PPOPN 5
9055: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
9056: LD_EXP 12
9060: PUSH
9061: LD_EXP 45
9065: AND
9066: IFFALSE 9160
9068: GO 9070
9070: DISABLE
9071: LD_INT 0
9073: PPUSH
9074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
9075: LD_ADDR_VAR 0 2
9079: PUSH
9080: LD_INT 22
9082: PUSH
9083: LD_OWVAR 2
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 32
9094: PUSH
9095: LD_INT 1
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 21
9104: PUSH
9105: LD_INT 2
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 69
9121: ST_TO_ADDR
// if not tmp then
9122: LD_VAR 0 2
9126: NOT
9127: IFFALSE 9131
// exit ;
9129: GO 9160
// for i in tmp do
9131: LD_ADDR_VAR 0 1
9135: PUSH
9136: LD_VAR 0 2
9140: PUSH
9141: FOR_IN
9142: IFFALSE 9158
// SetFuel ( i , 0 ) ;
9144: LD_VAR 0 1
9148: PPUSH
9149: LD_INT 0
9151: PPUSH
9152: CALL_OW 240
9156: GO 9141
9158: POP
9159: POP
// end ;
9160: PPOPN 2
9162: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
9163: LD_EXP 12
9167: PUSH
9168: LD_EXP 46
9172: AND
9173: IFFALSE 9239
9175: GO 9177
9177: DISABLE
9178: LD_INT 0
9180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9181: LD_ADDR_VAR 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_OWVAR 2
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: PUSH
9198: LD_INT 30
9200: PUSH
9201: LD_INT 29
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PPUSH
9212: CALL_OW 69
9216: ST_TO_ADDR
// if not tmp then
9217: LD_VAR 0 1
9221: NOT
9222: IFFALSE 9226
// exit ;
9224: GO 9239
// DestroyUnit ( tmp [ 1 ] ) ;
9226: LD_VAR 0 1
9230: PUSH
9231: LD_INT 1
9233: ARRAY
9234: PPUSH
9235: CALL_OW 65
// end ;
9239: PPOPN 1
9241: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
9242: LD_EXP 12
9246: PUSH
9247: LD_EXP 48
9251: AND
9252: IFFALSE 9365
9254: GO 9256
9256: DISABLE
9257: LD_INT 0
9259: PPUSH
// begin uc_side := 0 ;
9260: LD_ADDR_OWVAR 20
9264: PUSH
9265: LD_INT 0
9267: ST_TO_ADDR
// uc_nation := nation_arabian ;
9268: LD_ADDR_OWVAR 21
9272: PUSH
9273: LD_INT 2
9275: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 10
9281: PPUSH
9282: LD_INT 11
9284: PPUSH
9285: CALL_OW 380
// un := CreateHuman ;
9289: LD_ADDR_VAR 0 1
9293: PUSH
9294: CALL_OW 44
9298: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9299: LD_VAR 0 1
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9311: LD_INT 35
9313: PPUSH
9314: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 22
9325: PUSH
9326: LD_OWVAR 2
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PPUSH
9335: CALL_OW 69
9339: PPUSH
9340: LD_VAR 0 1
9344: PPUSH
9345: CALL_OW 74
9349: PPUSH
9350: CALL_OW 115
// until IsDead ( un ) ;
9354: LD_VAR 0 1
9358: PPUSH
9359: CALL_OW 301
9363: IFFALSE 9311
// end ; end_of_file
9365: PPOPN 1
9367: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
9368: LD_INT 0
9370: PPUSH
9371: PPUSH
9372: PPUSH
9373: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
9374: LD_VAR 0 1
9378: PPUSH
9379: CALL_OW 264
9383: PUSH
9384: LD_EXP 11
9388: EQUAL
9389: IFFALSE 9461
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
9391: LD_INT 68
9393: PPUSH
9394: LD_VAR 0 1
9398: PPUSH
9399: CALL_OW 255
9403: PPUSH
9404: CALL_OW 321
9408: PUSH
9409: LD_INT 2
9411: EQUAL
9412: IFFALSE 9424
// eff := 70 else
9414: LD_ADDR_VAR 0 6
9418: PUSH
9419: LD_INT 70
9421: ST_TO_ADDR
9422: GO 9432
// eff := 30 ;
9424: LD_ADDR_VAR 0 6
9428: PUSH
9429: LD_INT 30
9431: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 250
9441: PPUSH
9442: LD_VAR 0 1
9446: PPUSH
9447: CALL_OW 251
9451: PPUSH
9452: LD_VAR 0 6
9456: PPUSH
9457: CALL_OW 495
// end ; end ;
9461: LD_VAR 0 4
9465: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
9466: LD_INT 0
9468: PPUSH
9469: PPUSH
9470: PPUSH
9471: PPUSH
9472: PPUSH
9473: PPUSH
// if cmd = 124 then
9474: LD_VAR 0 1
9478: PUSH
9479: LD_INT 124
9481: EQUAL
9482: IFFALSE 9688
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
9484: LD_ADDR_VAR 0 5
9488: PUSH
9489: LD_INT 2
9491: PUSH
9492: LD_INT 34
9494: PUSH
9495: LD_INT 53
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: PUSH
9502: LD_INT 34
9504: PUSH
9505: LD_INT 14
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: LIST
9516: PPUSH
9517: CALL_OW 69
9521: ST_TO_ADDR
// if not tmp then
9522: LD_VAR 0 5
9526: NOT
9527: IFFALSE 9531
// exit ;
9529: GO 9688
// for i in tmp do
9531: LD_ADDR_VAR 0 3
9535: PUSH
9536: LD_VAR 0 5
9540: PUSH
9541: FOR_IN
9542: IFFALSE 9686
// begin taskList := GetTaskList ( i ) ;
9544: LD_ADDR_VAR 0 6
9548: PUSH
9549: LD_VAR 0 3
9553: PPUSH
9554: CALL_OW 437
9558: ST_TO_ADDR
// if not taskList then
9559: LD_VAR 0 6
9563: NOT
9564: IFFALSE 9568
// continue ;
9566: GO 9541
// for j = 1 to taskList do
9568: LD_ADDR_VAR 0 4
9572: PUSH
9573: DOUBLE
9574: LD_INT 1
9576: DEC
9577: ST_TO_ADDR
9578: LD_VAR 0 6
9582: PUSH
9583: FOR_TO
9584: IFFALSE 9682
// if taskList [ j ] [ 1 ] = | then
9586: LD_VAR 0 6
9590: PUSH
9591: LD_VAR 0 4
9595: ARRAY
9596: PUSH
9597: LD_INT 1
9599: ARRAY
9600: PUSH
9601: LD_STRING |
9603: EQUAL
9604: IFFALSE 9680
// begin _taskList := Delete ( taskList , 1 ) ;
9606: LD_ADDR_VAR 0 7
9610: PUSH
9611: LD_VAR 0 6
9615: PPUSH
9616: LD_INT 1
9618: PPUSH
9619: CALL_OW 3
9623: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
9624: LD_VAR 0 3
9628: PPUSH
9629: LD_VAR 0 7
9633: PPUSH
9634: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
9638: LD_VAR 0 3
9642: PPUSH
9643: LD_VAR 0 6
9647: PUSH
9648: LD_VAR 0 4
9652: ARRAY
9653: PUSH
9654: LD_INT 2
9656: ARRAY
9657: PPUSH
9658: LD_VAR 0 6
9662: PUSH
9663: LD_VAR 0 4
9667: ARRAY
9668: PUSH
9669: LD_INT 3
9671: ARRAY
9672: PPUSH
9673: LD_INT 8
9675: PPUSH
9676: CALL 9693 0 4
// end ;
9680: GO 9583
9682: POP
9683: POP
// end ;
9684: GO 9541
9686: POP
9687: POP
// end ; end ;
9688: LD_VAR 0 2
9692: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
9693: LD_INT 0
9695: PPUSH
9696: PPUSH
9697: PPUSH
9698: PPUSH
9699: PPUSH
9700: PPUSH
9701: PPUSH
9702: PPUSH
9703: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
9704: LD_VAR 0 1
9708: NOT
9709: PUSH
9710: LD_VAR 0 2
9714: PPUSH
9715: LD_VAR 0 3
9719: PPUSH
9720: CALL_OW 488
9724: NOT
9725: OR
9726: PUSH
9727: LD_VAR 0 4
9731: NOT
9732: OR
9733: IFFALSE 9737
// exit ;
9735: GO 10077
// list := [ ] ;
9737: LD_ADDR_VAR 0 13
9741: PUSH
9742: EMPTY
9743: ST_TO_ADDR
// if x - r < 0 then
9744: LD_VAR 0 2
9748: PUSH
9749: LD_VAR 0 4
9753: MINUS
9754: PUSH
9755: LD_INT 0
9757: LESS
9758: IFFALSE 9770
// min_x := 0 else
9760: LD_ADDR_VAR 0 7
9764: PUSH
9765: LD_INT 0
9767: ST_TO_ADDR
9768: GO 9786
// min_x := x - r ;
9770: LD_ADDR_VAR 0 7
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_VAR 0 4
9784: MINUS
9785: ST_TO_ADDR
// if y - r < 0 then
9786: LD_VAR 0 3
9790: PUSH
9791: LD_VAR 0 4
9795: MINUS
9796: PUSH
9797: LD_INT 0
9799: LESS
9800: IFFALSE 9812
// min_y := 0 else
9802: LD_ADDR_VAR 0 8
9806: PUSH
9807: LD_INT 0
9809: ST_TO_ADDR
9810: GO 9828
// min_y := y - r ;
9812: LD_ADDR_VAR 0 8
9816: PUSH
9817: LD_VAR 0 3
9821: PUSH
9822: LD_VAR 0 4
9826: MINUS
9827: ST_TO_ADDR
// max_x := x + r ;
9828: LD_ADDR_VAR 0 9
9832: PUSH
9833: LD_VAR 0 2
9837: PUSH
9838: LD_VAR 0 4
9842: PLUS
9843: ST_TO_ADDR
// max_y := y + r ;
9844: LD_ADDR_VAR 0 10
9848: PUSH
9849: LD_VAR 0 3
9853: PUSH
9854: LD_VAR 0 4
9858: PLUS
9859: ST_TO_ADDR
// for _x = min_x to max_x do
9860: LD_ADDR_VAR 0 11
9864: PUSH
9865: DOUBLE
9866: LD_VAR 0 7
9870: DEC
9871: ST_TO_ADDR
9872: LD_VAR 0 9
9876: PUSH
9877: FOR_TO
9878: IFFALSE 9995
// for _y = min_y to max_y do
9880: LD_ADDR_VAR 0 12
9884: PUSH
9885: DOUBLE
9886: LD_VAR 0 8
9890: DEC
9891: ST_TO_ADDR
9892: LD_VAR 0 10
9896: PUSH
9897: FOR_TO
9898: IFFALSE 9991
// begin if not ValidHex ( _x , _y ) then
9900: LD_VAR 0 11
9904: PPUSH
9905: LD_VAR 0 12
9909: PPUSH
9910: CALL_OW 488
9914: NOT
9915: IFFALSE 9919
// continue ;
9917: GO 9897
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9919: LD_VAR 0 11
9923: PPUSH
9924: LD_VAR 0 12
9928: PPUSH
9929: CALL_OW 351
9933: PUSH
9934: LD_VAR 0 11
9938: PPUSH
9939: LD_VAR 0 12
9943: PPUSH
9944: CALL_OW 554
9948: AND
9949: IFFALSE 9989
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9951: LD_ADDR_VAR 0 13
9955: PUSH
9956: LD_VAR 0 13
9960: PPUSH
9961: LD_VAR 0 13
9965: PUSH
9966: LD_INT 1
9968: PLUS
9969: PPUSH
9970: LD_VAR 0 11
9974: PUSH
9975: LD_VAR 0 12
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PPUSH
9984: CALL_OW 2
9988: ST_TO_ADDR
// end ;
9989: GO 9897
9991: POP
9992: POP
9993: GO 9877
9995: POP
9996: POP
// if not list then
9997: LD_VAR 0 13
10001: NOT
10002: IFFALSE 10006
// exit ;
10004: GO 10077
// for i in list do
10006: LD_ADDR_VAR 0 6
10010: PUSH
10011: LD_VAR 0 13
10015: PUSH
10016: FOR_IN
10017: IFFALSE 10075
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
10019: LD_VAR 0 1
10023: PPUSH
10024: LD_STRING M
10026: PUSH
10027: LD_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: ARRAY
10035: PUSH
10036: LD_VAR 0 6
10040: PUSH
10041: LD_INT 2
10043: ARRAY
10044: PUSH
10045: LD_INT 0
10047: PUSH
10048: LD_INT 0
10050: PUSH
10051: LD_INT 0
10053: PUSH
10054: LD_INT 0
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: PUSH
10066: EMPTY
10067: LIST
10068: PPUSH
10069: CALL_OW 447
10073: GO 10016
10075: POP
10076: POP
// end ;
10077: LD_VAR 0 5
10081: RET
