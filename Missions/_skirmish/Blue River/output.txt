// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// PlaceSeeing ( 0 , 0 , 7 , - 37963 ) ;
  11: LD_INT 0
  13: PPUSH
  14: LD_INT 0
  16: PPUSH
  17: LD_INT 7
  19: PPUSH
  20: LD_INT 37963
  22: NEG
  23: PPUSH
  24: CALL_OW 330
// RemoveSeeing ( 0 , 0 , 7 ) ;
  28: LD_INT 0
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 7
  36: PPUSH
  37: CALL_OW 331
// PrepareBase ;
  41: CALL 514 0 0
// Action ;
  45: CALL 54 0 0
// SaveForQuickRestart ;
  49: CALL_OW 22
// end ;
  53: END
// function Action ; var un , f , i ; begin
  54: LD_INT 0
  56: PPUSH
  57: PPUSH
  58: PPUSH
  59: PPUSH
// SetBName ( brave , brave ) ;
  60: LD_INT 1
  62: PPUSH
  63: LD_STRING brave
  65: PPUSH
  66: CALL_OW 500
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// SetResourceType ( GetBase ( brave ) , mat_cans , [ 6000 , 4500 , 3000 ] [ Difficulty ] ) ;
  83: LD_INT 1
  85: PPUSH
  86: CALL_OW 274
  90: PPUSH
  91: LD_INT 1
  93: PPUSH
  94: LD_INT 6000
  96: PUSH
  97: LD_INT 4500
  99: PUSH
 100: LD_INT 3000
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: LIST
 107: PUSH
 108: LD_OWVAR 67
 112: ARRAY
 113: PPUSH
 114: CALL_OW 277
// InGameOn ;
 118: CALL_OW 8
// CenterNowOnUnits ( brave ) ;
 122: LD_INT 1
 124: PPUSH
 125: CALL_OW 87
// Say ( com , DJack1 ) ;
 129: LD_EXP 1
 133: PPUSH
 134: LD_STRING DJack1
 136: PPUSH
 137: CALL_OW 88
// Say ( k1 , DUn1 ) ;
 141: LD_EXP 3
 145: PPUSH
 146: LD_STRING DUn1
 148: PPUSH
 149: CALL_OW 88
// Say ( com , DJack2 ) ;
 153: LD_EXP 1
 157: PPUSH
 158: LD_STRING DJack2
 160: PPUSH
 161: CALL_OW 88
// Say ( k1 , DUn2 ) ;
 165: LD_EXP 3
 169: PPUSH
 170: LD_STRING DUn2
 172: PPUSH
 173: CALL_OW 88
// Say ( com , DJack3 ) ;
 177: LD_EXP 1
 181: PPUSH
 182: LD_STRING DJack3
 184: PPUSH
 185: CALL_OW 88
// uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := 1 ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_INT 1
 204: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 0 ) ;
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 0
 213: PPUSH
 214: CALL_OW 380
// hc_name :=  ;
 218: LD_ADDR_OWVAR 26
 222: PUSH
 223: LD_STRING 
 225: ST_TO_ADDR
// un := CreateHuman ;
 226: LD_ADDR_VAR 0 2
 230: PUSH
 231: CALL_OW 44
 235: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
 236: LD_INT 105
 238: PPUSH
 239: CALL_OW 67
// SayRadio ( un , DRadio1 ) ;
 243: LD_VAR 0 2
 247: PPUSH
 248: LD_STRING DRadio1
 250: PPUSH
 251: CALL_OW 94
// Say ( com , DJack4 ) ;
 255: LD_EXP 1
 259: PPUSH
 260: LD_STRING DJack4
 262: PPUSH
 263: CALL_OW 88
// SayRadio ( un , DRadio2 ) ;
 267: LD_VAR 0 2
 271: PPUSH
 272: LD_STRING DRadio2
 274: PPUSH
 275: CALL_OW 94
// Wait ( 0 0$01 ) ;
 279: LD_INT 35
 281: PPUSH
 282: CALL_OW 67
// SayRadio ( doc , DDoc1 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_STRING DDoc1
 293: PPUSH
 294: CALL_OW 94
// Say ( com , DJack5 ) ;
 298: LD_EXP 1
 302: PPUSH
 303: LD_STRING DJack5
 305: PPUSH
 306: CALL_OW 88
// SayRadio ( doc , DDoc2 ) ;
 310: LD_EXP 2
 314: PPUSH
 315: LD_STRING DDoc2
 317: PPUSH
 318: CALL_OW 94
// SayRadio ( un , DRadio3 ) ;
 322: LD_VAR 0 2
 326: PPUSH
 327: LD_STRING DRadio3
 329: PPUSH
 330: CALL_OW 94
// Say ( com , DJack6 ) ;
 334: LD_EXP 1
 338: PPUSH
 339: LD_STRING DJack6
 341: PPUSH
 342: CALL_OW 88
// f := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
 346: LD_ADDR_VAR 0 3
 350: PUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 7
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 21
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: ST_TO_ADDR
// for i = 2 to f do
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: DOUBLE
 386: LD_INT 2
 388: DEC
 389: ST_TO_ADDR
 390: LD_VAR 0 3
 394: PUSH
 395: FOR_TO
 396: IFFALSE 453
// begin ComExitBuilding ( f [ i ] ) ;
 398: LD_VAR 0 3
 402: PUSH
 403: LD_VAR 0 4
 407: ARRAY
 408: PPUSH
 409: CALL_OW 122
// AddComMoveToArea ( f [ i ] , act_area ) ;
 413: LD_VAR 0 3
 417: PUSH
 418: LD_VAR 0 4
 422: ARRAY
 423: PPUSH
 424: LD_INT 7
 426: PPUSH
 427: CALL_OW 173
// AddComTurnUnit ( f [ i ] , com ) ;
 431: LD_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ARRAY
 441: PPUSH
 442: LD_EXP 1
 446: PPUSH
 447: CALL_OW 179
// end ;
 451: GO 395
 453: POP
 454: POP
// ComExitBuilding ( com ) ;
 455: LD_EXP 1
 459: PPUSH
 460: CALL_OW 122
// AddComTurnXY ( com , 45 , 32 ) ;
 464: LD_EXP 1
 468: PPUSH
 469: LD_INT 45
 471: PPUSH
 472: LD_INT 32
 474: PPUSH
 475: CALL_OW 178
// Wait ( 0 0$03 ) ;
 479: LD_INT 105
 481: PPUSH
 482: CALL_OW 67
// Say ( com , DJack7 ) ;
 486: LD_EXP 1
 490: PPUSH
 491: LD_STRING DJack7
 493: PPUSH
 494: CALL_OW 88
// InGameOff ;
 498: CALL_OW 9
// ChangeMissionObjectives ( TDef ) ;
 502: LD_STRING TDef
 504: PPUSH
 505: CALL_OW 337
// end ; end_of_file
 509: LD_VAR 0 1
 513: RET
// export com , doc , k1 ; export function PrepareBase ; var i , un , skill ; begin
 514: LD_INT 0
 516: PPUSH
 517: PPUSH
 518: PPUSH
 519: PPUSH
// PlaceSeeing ( 30 , 14 , 7 , 20 ) ;
 520: LD_INT 30
 522: PPUSH
 523: LD_INT 14
 525: PPUSH
 526: LD_INT 7
 528: PPUSH
 529: LD_INT 20
 531: PPUSH
 532: CALL_OW 330
// PlaceSeeing ( 49 , 17 , 7 , 20 ) ;
 536: LD_INT 49
 538: PPUSH
 539: LD_INT 17
 541: PPUSH
 542: LD_INT 7
 544: PPUSH
 545: LD_INT 20
 547: PPUSH
 548: CALL_OW 330
// PlaceSeeing ( 35 , 46 , 7 , 20 ) ;
 552: LD_INT 35
 554: PPUSH
 555: LD_INT 46
 557: PPUSH
 558: LD_INT 7
 560: PPUSH
 561: LD_INT 20
 563: PPUSH
 564: CALL_OW 330
// PlaceSeeing ( 70 , 39 , 7 , 20 ) ;
 568: LD_INT 70
 570: PPUSH
 571: LD_INT 39
 573: PPUSH
 574: LD_INT 7
 576: PPUSH
 577: LD_INT 20
 579: PPUSH
 580: CALL_OW 330
// RemoveSeeing ( 30 , 14 , 7 ) ;
 584: LD_INT 30
 586: PPUSH
 587: LD_INT 14
 589: PPUSH
 590: LD_INT 7
 592: PPUSH
 593: CALL_OW 331
// RemoveSeeing ( 49 , 17 , 7 ) ;
 597: LD_INT 49
 599: PPUSH
 600: LD_INT 17
 602: PPUSH
 603: LD_INT 7
 605: PPUSH
 606: CALL_OW 331
// RemoveSeeing ( 35 , 46 , 7 ) ;
 610: LD_INT 35
 612: PPUSH
 613: LD_INT 46
 615: PPUSH
 616: LD_INT 7
 618: PPUSH
 619: CALL_OW 331
// RemoveSeeing ( 70 , 39 , 7 ) ;
 623: LD_INT 70
 625: PPUSH
 626: LD_INT 39
 628: PPUSH
 629: LD_INT 7
 631: PPUSH
 632: CALL_OW 331
// uc_side := 7 ;
 636: LD_ADDR_OWVAR 20
 640: PUSH
 641: LD_INT 7
 643: ST_TO_ADDR
// uc_nation := 1 ;
 644: LD_ADDR_OWVAR 21
 648: PUSH
 649: LD_INT 1
 651: ST_TO_ADDR
// if Difficulty < 3 then
 652: LD_OWVAR 67
 656: PUSH
 657: LD_INT 3
 659: LESS
 660: IFFALSE 761
// begin for i = 1 to 2 do
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: DOUBLE
 668: LD_INT 1
 670: DEC
 671: ST_TO_ADDR
 672: LD_INT 2
 674: PUSH
 675: FOR_TO
 676: IFFALSE 757
// begin vc_chassis := us_heavy_tracked ;
 678: LD_ADDR_OWVAR 37
 682: PUSH
 683: LD_INT 4
 685: ST_TO_ADDR
// vc_engine := 3 ;
 686: LD_ADDR_OWVAR 39
 690: PUSH
 691: LD_INT 3
 693: ST_TO_ADDR
// vc_control := control_computer ;
 694: LD_ADDR_OWVAR 38
 698: PUSH
 699: LD_INT 3
 701: ST_TO_ADDR
// vc_weapon := us_double_laser ;
 702: LD_ADDR_OWVAR 40
 706: PUSH
 707: LD_INT 10
 709: ST_TO_ADDR
// un := CreateVehicle ;
 710: LD_ADDR_VAR 0 3
 714: PUSH
 715: CALL_OW 45
 719: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 720: LD_VAR 0 3
 724: PPUSH
 725: LD_INT 0
 727: PPUSH
 728: LD_INT 5
 730: PPUSH
 731: CALL_OW 12
 735: PPUSH
 736: CALL_OW 233
// PlaceUnitArea ( un , base_spawn , false ) ;
 740: LD_VAR 0 3
 744: PPUSH
 745: LD_INT 6
 747: PPUSH
 748: LD_INT 0
 750: PPUSH
 751: CALL_OW 49
// end ;
 755: GO 675
 757: POP
 758: POP
// end else
 759: GO 850
// begin vc_chassis := us_medium_tracked ;
 761: LD_ADDR_OWVAR 37
 765: PUSH
 766: LD_INT 3
 768: ST_TO_ADDR
// vc_engine := engine_combustion ;
 769: LD_ADDR_OWVAR 39
 773: PUSH
 774: LD_INT 1
 776: ST_TO_ADDR
// vc_control := control_manual ;
 777: LD_ADDR_OWVAR 38
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
 785: LD_ADDR_OWVAR 40
 789: PUSH
 790: LD_INT 4
 792: ST_TO_ADDR
// un := CreateVehicle ;
 793: LD_ADDR_VAR 0 3
 797: PUSH
 798: CALL_OW 45
 802: ST_TO_ADDR
// SetDir ( un , Rand ( 0 , 5 ) ) ;
 803: LD_VAR 0 3
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: LD_INT 5
 813: PPUSH
 814: CALL_OW 12
 818: PPUSH
 819: CALL_OW 233
// SetFuel ( un , 75 ) ;
 823: LD_VAR 0 3
 827: PPUSH
 828: LD_INT 75
 830: PPUSH
 831: CALL_OW 240
// PlaceUnitArea ( un , base_spawn , false ) ;
 835: LD_VAR 0 3
 839: PPUSH
 840: LD_INT 6
 842: PPUSH
 843: LD_INT 0
 845: PPUSH
 846: CALL_OW 49
// end ; skill := [ 8 , 7 , 6 ] [ Difficulty ] ;
 850: LD_ADDR_VAR 0 4
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: LD_INT 7
 860: PUSH
 861: LD_INT 6
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_OWVAR 67
 873: ARRAY
 874: ST_TO_ADDR
// hc_importance := 100 ;
 875: LD_ADDR_OWVAR 32
 879: PUSH
 880: LD_INT 100
 882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 883: LD_INT 1
 885: PPUSH
 886: LD_INT 1
 888: PPUSH
 889: LD_VAR 0 4
 893: PPUSH
 894: CALL_OW 380
// hc_name := Jack Collins ;
 898: LD_ADDR_OWVAR 26
 902: PUSH
 903: LD_STRING Jack Collins
 905: ST_TO_ADDR
// com := CreateHuman ;
 906: LD_ADDR_EXP 1
 910: PUSH
 911: CALL_OW 44
 915: ST_TO_ADDR
// PlaceHumanInUnit ( com , brave ) ;
 916: LD_EXP 1
 920: PPUSH
 921: LD_INT 1
 923: PPUSH
 924: CALL_OW 52
// hc_importance := 0 ;
 928: LD_ADDR_OWVAR 32
 932: PUSH
 933: LD_INT 0
 935: ST_TO_ADDR
// hc_gallery :=  ;
 936: LD_ADDR_OWVAR 33
 940: PUSH
 941: LD_STRING 
 943: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 4
 954: PPUSH
 955: CALL_OW 380
// hc_name := Thomas Jackson ;
 959: LD_ADDR_OWVAR 26
 963: PUSH
 964: LD_STRING Thomas Jackson
 966: ST_TO_ADDR
// k1 := CreateHuman ;
 967: LD_ADDR_EXP 3
 971: PUSH
 972: CALL_OW 44
 976: ST_TO_ADDR
// PlaceHumanInUnit ( k1 , brave ) ;
 977: LD_EXP 3
 981: PPUSH
 982: LD_INT 1
 984: PPUSH
 985: CALL_OW 52
// hc_name :=  ;
 989: LD_ADDR_OWVAR 26
 993: PUSH
 994: LD_STRING 
 996: ST_TO_ADDR
// for i = 1 to [ 9 , 8 , 7 ] [ Difficulty ] do
 997: LD_ADDR_VAR 0 2
1001: PUSH
1002: DOUBLE
1003: LD_INT 1
1005: DEC
1006: ST_TO_ADDR
1007: LD_INT 9
1009: PUSH
1010: LD_INT 8
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_OWVAR 67
1025: ARRAY
1026: PUSH
1027: FOR_TO
1028: IFFALSE 1199
// begin Randomize ;
1030: CALL_OW 10
// uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
1034: LD_ADDR_OWVAR 21
1038: PUSH
1039: LD_INT 1
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 2
1054: PPUSH
1055: CALL_OW 12
1059: ARRAY
1060: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , skill ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 1
1066: PPUSH
1067: LD_INT 4
1069: PPUSH
1070: CALL_OW 12
1074: PPUSH
1075: LD_VAR 0 4
1079: PPUSH
1080: CALL_OW 380
// un := CreateHuman ;
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: CALL_OW 44
1093: ST_TO_ADDR
// case GetClass ( un ) of 1 :
1094: LD_VAR 0 3
1098: PPUSH
1099: CALL_OW 257
1103: PUSH
1104: LD_INT 1
1106: DOUBLE
1107: EQUAL
1108: IFTRUE 1112
1110: GO 1127
1112: POP
// PlaceHumanInUnit ( un , br ) ; 2 :
1113: LD_VAR 0 3
1117: PPUSH
1118: LD_INT 21
1120: PPUSH
1121: CALL_OW 52
1125: GO 1197
1127: LD_INT 2
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1150
1135: POP
// PlaceHumanInUnit ( un , brave ) ; 3 :
1136: LD_VAR 0 3
1140: PPUSH
1141: LD_INT 1
1143: PPUSH
1144: CALL_OW 52
1148: GO 1197
1150: LD_INT 3
1152: DOUBLE
1153: EQUAL
1154: IFTRUE 1158
1156: GO 1173
1158: POP
// PlaceHumanInUnit ( un , fac ) ; 4 :
1159: LD_VAR 0 3
1163: PPUSH
1164: LD_INT 38
1166: PPUSH
1167: CALL_OW 52
1171: GO 1197
1173: LD_INT 4
1175: DOUBLE
1176: EQUAL
1177: IFTRUE 1181
1179: GO 1196
1181: POP
// PlaceHumanInUnit ( un , lab ) ; end ;
1182: LD_VAR 0 3
1186: PPUSH
1187: LD_INT 36
1189: PPUSH
1190: CALL_OW 52
1194: GO 1197
1196: POP
// end ;
1197: GO 1027
1199: POP
1200: POP
// uc_side := 2 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 2
1208: ST_TO_ADDR
// uc_nation := 2 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 2
1216: ST_TO_ADDR
// hc_name := _ ;
1217: LD_ADDR_OWVAR 26
1221: PUSH
1222: LD_STRING _
1224: ST_TO_ADDR
// hc_gallery :=  ;
1225: LD_ADDR_OWVAR 33
1229: PUSH
1230: LD_STRING 
1232: ST_TO_ADDR
// hc_class := 4 ;
1233: LD_ADDR_OWVAR 28
1237: PUSH
1238: LD_INT 4
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// doc := CreateHuman ;
1249: LD_ADDR_EXP 2
1253: PUSH
1254: CALL_OW 44
1258: ST_TO_ADDR
// end ; end_of_file
1259: LD_VAR 0 1
1263: RET
// export function Attack ( num ) ; var i , un , tmp ; begin
1264: LD_INT 0
1266: PPUSH
1267: PPUSH
1268: PPUSH
1269: PPUSH
// uc_side := 2 ;
1270: LD_ADDR_OWVAR 20
1274: PUSH
1275: LD_INT 2
1277: ST_TO_ADDR
// uc_nation := 2 ;
1278: LD_ADDR_OWVAR 21
1282: PUSH
1283: LD_INT 2
1285: ST_TO_ADDR
// tmp := [ ] ;
1286: LD_ADDR_VAR 0 5
1290: PUSH
1291: EMPTY
1292: ST_TO_ADDR
// hc_skills := [ [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] , [ 3 , 6 , 10 ] [ Difficulty ] ] ;
1293: LD_ADDR_OWVAR 31
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: LD_INT 6
1303: PUSH
1304: LD_INT 10
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_OWVAR 67
1316: ARRAY
1317: PUSH
1318: LD_INT 3
1320: PUSH
1321: LD_INT 6
1323: PUSH
1324: LD_INT 10
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: LIST
1331: PUSH
1332: LD_OWVAR 67
1336: ARRAY
1337: PUSH
1338: LD_INT 3
1340: PUSH
1341: LD_INT 6
1343: PUSH
1344: LD_INT 10
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_OWVAR 67
1356: ARRAY
1357: PUSH
1358: LD_INT 3
1360: PUSH
1361: LD_INT 6
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: LD_OWVAR 67
1376: ARRAY
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: ST_TO_ADDR
// if FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) then
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 22
1389: PUSH
1390: LD_INT 7
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: PPUSH
1397: CALL_OW 70
1401: IFFALSE 1442
// for i in FilterUnitsInArea ( east1_spawn , [ f_side , 7 ] ) do
1403: LD_ADDR_VAR 0 3
1407: PUSH
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 22
1413: PUSH
1414: LD_INT 7
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PPUSH
1421: CALL_OW 70
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1440
// RemoveUnit ( i ) ;
1429: LD_VAR 0 3
1433: PPUSH
1434: CALL_OW 64
1438: GO 1426
1440: POP
1441: POP
// if FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) then
1442: LD_INT 5
1444: PPUSH
1445: LD_INT 22
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 70
1459: IFFALSE 1500
// for i in FilterUnitsInArea ( east2_spawn , [ f_side , 7 ] ) do
1461: LD_ADDR_VAR 0 3
1465: PUSH
1466: LD_INT 5
1468: PPUSH
1469: LD_INT 22
1471: PUSH
1472: LD_INT 7
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PPUSH
1479: CALL_OW 70
1483: PUSH
1484: FOR_IN
1485: IFFALSE 1498
// RemoveUnit ( i ) ;
1487: LD_VAR 0 3
1491: PPUSH
1492: CALL_OW 64
1496: GO 1484
1498: POP
1499: POP
// if FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) then
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 22
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 70
1517: IFFALSE 1558
// for i in FilterUnitsInArea ( north_spawn , [ f_side , 7 ] ) do
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_INT 1
1526: PPUSH
1527: LD_INT 22
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PPUSH
1537: CALL_OW 70
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1556
// RemoveUnit ( i ) ;
1545: LD_VAR 0 3
1549: PPUSH
1550: CALL_OW 64
1554: GO 1542
1556: POP
1557: POP
// if FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) then
1558: LD_INT 2
1560: PPUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 7
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL_OW 70
1575: IFFALSE 1616
// for i in FilterUnitsInArea ( south_spawn , [ f_side , 7 ] ) do
1577: LD_ADDR_VAR 0 3
1581: PUSH
1582: LD_INT 2
1584: PPUSH
1585: LD_INT 22
1587: PUSH
1588: LD_INT 7
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 70
1599: PUSH
1600: FOR_IN
1601: IFFALSE 1614
// RemoveUnit ( i ) ;
1603: LD_VAR 0 3
1607: PPUSH
1608: CALL_OW 64
1612: GO 1600
1614: POP
1615: POP
// case num of 1 :
1616: LD_VAR 0 1
1620: PUSH
1621: LD_INT 1
1623: DOUBLE
1624: EQUAL
1625: IFTRUE 1629
1627: GO 1882
1629: POP
// begin for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: DOUBLE
1636: LD_INT 1
1638: DEC
1639: ST_TO_ADDR
1640: LD_INT 5
1642: PUSH
1643: LD_INT 6
1645: PUSH
1646: LD_INT 6
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_OWVAR 67
1658: ARRAY
1659: PUSH
1660: FOR_TO
1661: IFFALSE 1753
// begin uc_nation := 0 ;
1663: LD_ADDR_OWVAR 21
1667: PUSH
1668: LD_INT 0
1670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1671: LD_ADDR_OWVAR 28
1675: PUSH
1676: LD_INT 15
1678: ST_TO_ADDR
// hc_gallery :=  ;
1679: LD_ADDR_OWVAR 33
1683: PUSH
1684: LD_STRING 
1686: ST_TO_ADDR
// hc_name :=  ;
1687: LD_ADDR_OWVAR 26
1691: PUSH
1692: LD_STRING 
1694: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1695: LD_ADDR_OWVAR 29
1699: PUSH
1700: LD_INT 16
1702: PUSH
1703: LD_INT 12
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// un := CreateHuman ;
1710: LD_ADDR_VAR 0 4
1714: PUSH
1715: CALL_OW 44
1719: ST_TO_ADDR
// PlaceUnitArea ( un , north_spawn , false ) ;
1720: LD_VAR 0 4
1724: PPUSH
1725: LD_INT 1
1727: PPUSH
1728: LD_INT 0
1730: PPUSH
1731: CALL_OW 49
// tmp := tmp ^ un ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_VAR 0 4
1749: ADD
1750: ST_TO_ADDR
// end ;
1751: GO 1660
1753: POP
1754: POP
// for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
1755: LD_ADDR_VAR 0 3
1759: PUSH
1760: DOUBLE
1761: LD_INT 1
1763: DEC
1764: ST_TO_ADDR
1765: LD_INT 4
1767: PUSH
1768: LD_INT 5
1770: PUSH
1771: LD_INT 5
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: PUSH
1779: LD_OWVAR 67
1783: ARRAY
1784: PUSH
1785: FOR_TO
1786: IFFALSE 1878
// begin uc_nation := 0 ;
1788: LD_ADDR_OWVAR 21
1792: PUSH
1793: LD_INT 0
1795: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1796: LD_ADDR_OWVAR 28
1800: PUSH
1801: LD_INT 15
1803: ST_TO_ADDR
// hc_gallery :=  ;
1804: LD_ADDR_OWVAR 33
1808: PUSH
1809: LD_STRING 
1811: ST_TO_ADDR
// hc_name :=  ;
1812: LD_ADDR_OWVAR 26
1816: PUSH
1817: LD_STRING 
1819: ST_TO_ADDR
// hc_attr := [ 16 , 12 ] ;
1820: LD_ADDR_OWVAR 29
1824: PUSH
1825: LD_INT 16
1827: PUSH
1828: LD_INT 12
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: ST_TO_ADDR
// un := CreateHuman ;
1835: LD_ADDR_VAR 0 4
1839: PUSH
1840: CALL_OW 44
1844: ST_TO_ADDR
// PlaceUnitArea ( un , east2_spawn , false ) ;
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 49
// tmp := tmp ^ un ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_VAR 0 4
1874: ADD
1875: ST_TO_ADDR
// end ;
1876: GO 1785
1878: POP
1879: POP
// end ; 2 :
1880: GO 2660
1882: LD_INT 2
1884: DOUBLE
1885: EQUAL
1886: IFTRUE 1890
1888: GO 2018
1890: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
1891: LD_ADDR_VAR 0 3
1895: PUSH
1896: DOUBLE
1897: LD_INT 1
1899: DEC
1900: ST_TO_ADDR
1901: LD_INT 3
1903: PUSH
1904: LD_INT 4
1906: PUSH
1907: LD_INT 5
1909: PUSH
1910: EMPTY
1911: LIST
1912: LIST
1913: LIST
1914: PUSH
1915: LD_OWVAR 67
1919: ARRAY
1920: PUSH
1921: FOR_TO
1922: IFFALSE 2014
// begin uc_nation := 0 ;
1924: LD_ADDR_OWVAR 21
1928: PUSH
1929: LD_INT 0
1931: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
1932: LD_ADDR_OWVAR 28
1936: PUSH
1937: LD_INT 17
1939: ST_TO_ADDR
// hc_gallery :=  ;
1940: LD_ADDR_OWVAR 33
1944: PUSH
1945: LD_STRING 
1947: ST_TO_ADDR
// hc_name :=  ;
1948: LD_ADDR_OWVAR 26
1952: PUSH
1953: LD_STRING 
1955: ST_TO_ADDR
// hc_attr := [ 22 , 12 ] ;
1956: LD_ADDR_OWVAR 29
1960: PUSH
1961: LD_INT 22
1963: PUSH
1964: LD_INT 12
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: ST_TO_ADDR
// un := CreateHuman ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: CALL_OW 44
1980: ST_TO_ADDR
// PlaceUnitArea ( un , west_spawn , false ) ;
1981: LD_VAR 0 4
1985: PPUSH
1986: LD_INT 3
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 49
// tmp := tmp ^ un ;
1996: LD_ADDR_VAR 0 5
2000: PUSH
2001: LD_VAR 0 5
2005: PUSH
2006: LD_VAR 0 4
2010: ADD
2011: ST_TO_ADDR
// end ;
2012: GO 1921
2014: POP
2015: POP
// end ; 3 :
2016: GO 2660
2018: LD_INT 3
2020: DOUBLE
2021: EQUAL
2022: IFTRUE 2026
2024: GO 2186
2026: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_INT 4
2039: PUSH
2040: LD_INT 5
2042: PUSH
2043: LD_INT 6
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PUSH
2051: LD_OWVAR 67
2055: ARRAY
2056: PUSH
2057: FOR_TO
2058: IFFALSE 2182
// begin uc_nation := 2 ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 2
2067: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2068: LD_ADDR_OWVAR 37
2072: PUSH
2073: LD_INT 14
2075: ST_TO_ADDR
// vc_engine := 3 ;
2076: LD_ADDR_OWVAR 39
2080: PUSH
2081: LD_INT 3
2083: ST_TO_ADDR
// vc_control := control_apeman ;
2084: LD_ADDR_OWVAR 38
2088: PUSH
2089: LD_INT 5
2091: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 27
2099: PUSH
2100: LD_INT 28
2102: PUSH
2103: LD_INT 29
2105: PUSH
2106: LD_INT 91
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PPUSH
2121: CALL_OW 12
2125: ARRAY
2126: ST_TO_ADDR
// un := CreateVehicle ;
2127: LD_ADDR_VAR 0 4
2131: PUSH
2132: CALL_OW 45
2136: ST_TO_ADDR
// tmp := tmp ^ un ;
2137: LD_ADDR_VAR 0 5
2141: PUSH
2142: LD_VAR 0 5
2146: PUSH
2147: LD_VAR 0 4
2151: ADD
2152: ST_TO_ADDR
// SetDir ( un , 0 ) ;
2153: LD_VAR 0 4
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 233
// PlaceUnitArea ( un , south_spawn , false ) ;
2165: LD_VAR 0 4
2169: PPUSH
2170: LD_INT 2
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: GO 2057
2182: POP
2183: POP
// end ; 4 :
2184: GO 2660
2186: LD_INT 4
2188: DOUBLE
2189: EQUAL
2190: IFTRUE 2194
2192: GO 2362
2194: POP
// begin for i = 1 to Rand ( 3 , [ 4 , 5 , 6 ] [ Difficulty ] ) do
2195: LD_ADDR_VAR 0 3
2199: PUSH
2200: DOUBLE
2201: LD_INT 1
2203: DEC
2204: ST_TO_ADDR
2205: LD_INT 3
2207: PPUSH
2208: LD_INT 4
2210: PUSH
2211: LD_INT 5
2213: PUSH
2214: LD_INT 6
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: CALL_OW 12
2232: PUSH
2233: FOR_TO
2234: IFFALSE 2358
// begin uc_nation := 2 ;
2236: LD_ADDR_OWVAR 21
2240: PUSH
2241: LD_INT 2
2243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 14
2251: ST_TO_ADDR
// vc_engine := 3 ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 3
2259: ST_TO_ADDR
// vc_control := control_apeman ;
2260: LD_ADDR_OWVAR 38
2264: PUSH
2265: LD_INT 5
2267: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2268: LD_ADDR_OWVAR 40
2272: PUSH
2273: LD_INT 27
2275: PUSH
2276: LD_INT 28
2278: PUSH
2279: LD_INT 29
2281: PUSH
2282: LD_INT 91
2284: PUSH
2285: EMPTY
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: PUSH
2291: LD_INT 1
2293: PPUSH
2294: LD_INT 4
2296: PPUSH
2297: CALL_OW 12
2301: ARRAY
2302: ST_TO_ADDR
// un := CreateVehicle ;
2303: LD_ADDR_VAR 0 4
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// tmp := tmp ^ un ;
2313: LD_ADDR_VAR 0 5
2317: PUSH
2318: LD_VAR 0 5
2322: PUSH
2323: LD_VAR 0 4
2327: ADD
2328: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2329: LD_VAR 0 4
2333: PPUSH
2334: LD_INT 3
2336: PPUSH
2337: CALL_OW 233
// PlaceUnitArea ( un , north_spawn , false ) ;
2341: LD_VAR 0 4
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_INT 0
2351: PPUSH
2352: CALL_OW 49
// end ;
2356: GO 2233
2358: POP
2359: POP
// end ; 5 :
2360: GO 2660
2362: LD_INT 5
2364: DOUBLE
2365: EQUAL
2366: IFTRUE 2370
2368: GO 2530
2370: POP
// begin for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: DOUBLE
2377: LD_INT 1
2379: DEC
2380: ST_TO_ADDR
2381: LD_INT 3
2383: PUSH
2384: LD_INT 4
2386: PUSH
2387: LD_INT 4
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: LD_OWVAR 67
2399: ARRAY
2400: PUSH
2401: FOR_TO
2402: IFFALSE 2526
// begin uc_nation := 2 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 2
2411: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2412: LD_ADDR_OWVAR 37
2416: PUSH
2417: LD_INT 14
2419: ST_TO_ADDR
// vc_engine := 3 ;
2420: LD_ADDR_OWVAR 39
2424: PUSH
2425: LD_INT 3
2427: ST_TO_ADDR
// vc_control := control_apeman ;
2428: LD_ADDR_OWVAR 38
2432: PUSH
2433: LD_INT 5
2435: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_rocket_launcher , 29 , 91 ] [ Rand ( 1 , 4 ) ] ;
2436: LD_ADDR_OWVAR 40
2440: PUSH
2441: LD_INT 27
2443: PUSH
2444: LD_INT 28
2446: PUSH
2447: LD_INT 29
2449: PUSH
2450: LD_INT 91
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 1
2461: PPUSH
2462: LD_INT 4
2464: PPUSH
2465: CALL_OW 12
2469: ARRAY
2470: ST_TO_ADDR
// un := CreateVehicle ;
2471: LD_ADDR_VAR 0 4
2475: PUSH
2476: CALL_OW 45
2480: ST_TO_ADDR
// tmp := tmp ^ un ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_VAR 0 4
2495: ADD
2496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 4
2504: PPUSH
2505: CALL_OW 233
// PlaceUnitArea ( un , east2_spawn , false ) ;
2509: LD_VAR 0 4
2513: PPUSH
2514: LD_INT 5
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: CALL_OW 49
// end ;
2524: GO 2401
2526: POP
2527: POP
// end ; 6 :
2528: GO 2660
2530: LD_INT 6
2532: DOUBLE
2533: EQUAL
2534: IFTRUE 2538
2536: GO 2659
2538: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: DOUBLE
2545: LD_INT 1
2547: DEC
2548: ST_TO_ADDR
2549: LD_INT 2
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 4
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_OWVAR 67
2567: ARRAY
2568: PUSH
2569: FOR_TO
2570: IFFALSE 2655
// begin uc_nation := 2 ;
2572: LD_ADDR_OWVAR 21
2576: PUSH
2577: LD_INT 2
2579: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
2580: LD_ADDR_OWVAR 37
2584: PUSH
2585: LD_INT 11
2587: ST_TO_ADDR
// vc_engine := engine_combustion ;
2588: LD_ADDR_OWVAR 39
2592: PUSH
2593: LD_INT 1
2595: ST_TO_ADDR
// vc_control := control_apeman ;
2596: LD_ADDR_OWVAR 38
2600: PUSH
2601: LD_INT 5
2603: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
2604: LD_ADDR_OWVAR 40
2608: PUSH
2609: LD_INT 24
2611: ST_TO_ADDR
// un := CreateVehicle ;
2612: LD_ADDR_VAR 0 4
2616: PUSH
2617: CALL_OW 45
2621: ST_TO_ADDR
// tmp := tmp ^ un ;
2622: LD_ADDR_VAR 0 5
2626: PUSH
2627: LD_VAR 0 5
2631: PUSH
2632: LD_VAR 0 4
2636: ADD
2637: ST_TO_ADDR
// PlaceUnitArea ( un , river , false ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_INT 8
2645: PPUSH
2646: LD_INT 0
2648: PPUSH
2649: CALL_OW 49
// end ;
2653: GO 2569
2655: POP
2656: POP
// end ; end ;
2657: GO 2660
2659: POP
// result := tmp ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 5
2669: ST_TO_ADDR
// end ;
2670: LD_VAR 0 2
2674: RET
// export function ComitSib ; var un ; begin
2675: LD_INT 0
2677: PPUSH
2678: PPUSH
// uc_side := 2 ;
2679: LD_ADDR_OWVAR 20
2683: PUSH
2684: LD_INT 2
2686: ST_TO_ADDR
// uc_nation := 2 ;
2687: LD_ADDR_OWVAR 21
2691: PUSH
2692: LD_INT 2
2694: ST_TO_ADDR
// PrepareHuman ( false , 4 , 7 ) ;
2695: LD_INT 0
2697: PPUSH
2698: LD_INT 4
2700: PPUSH
2701: LD_INT 7
2703: PPUSH
2704: CALL_OW 380
// un := CreateHuman ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: CALL_OW 44
2717: ST_TO_ADDR
// PlaceUnitArea ( un , east1_spawn , false ) ;
2718: LD_VAR 0 2
2722: PPUSH
2723: LD_INT 4
2725: PPUSH
2726: LD_INT 0
2728: PPUSH
2729: CALL_OW 49
// ComContaminate ( un , 63 , 37 ) ;
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 63
2740: PPUSH
2741: LD_INT 37
2743: PPUSH
2744: CALL_OW 158
// end ;
2748: LD_VAR 0 1
2752: RET
// export function DSay ; var i ; begin
2753: LD_INT 0
2755: PPUSH
2756: PPUSH
// Randomize ;
2757: CALL_OW 10
// i := Rand ( 1 , 8 ) ;
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: LD_INT 1
2768: PPUSH
2769: LD_INT 8
2771: PPUSH
2772: CALL_OW 12
2776: ST_TO_ADDR
// case i of 1 :
2777: LD_VAR 0 2
2781: PUSH
2782: LD_INT 1
2784: DOUBLE
2785: EQUAL
2786: IFTRUE 2790
2788: GO 2805
2790: POP
// SayRadio ( doc , DDocA1 ) ; 2 :
2791: LD_EXP 2
2795: PPUSH
2796: LD_STRING DDocA1
2798: PPUSH
2799: CALL_OW 94
2803: GO 2967
2805: LD_INT 2
2807: DOUBLE
2808: EQUAL
2809: IFTRUE 2813
2811: GO 2828
2813: POP
// SayRadio ( doc , DDocA2 ) ; 3 :
2814: LD_EXP 2
2818: PPUSH
2819: LD_STRING DDocA2
2821: PPUSH
2822: CALL_OW 94
2826: GO 2967
2828: LD_INT 3
2830: DOUBLE
2831: EQUAL
2832: IFTRUE 2836
2834: GO 2851
2836: POP
// SayRadio ( doc , DDocA3 ) ; 4 :
2837: LD_EXP 2
2841: PPUSH
2842: LD_STRING DDocA3
2844: PPUSH
2845: CALL_OW 94
2849: GO 2967
2851: LD_INT 4
2853: DOUBLE
2854: EQUAL
2855: IFTRUE 2859
2857: GO 2874
2859: POP
// SayRadio ( doc , DDocA4 ) ; 5 :
2860: LD_EXP 2
2864: PPUSH
2865: LD_STRING DDocA4
2867: PPUSH
2868: CALL_OW 94
2872: GO 2967
2874: LD_INT 5
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2897
2882: POP
// SayRadio ( doc , DDocA5 ) ; 6 :
2883: LD_EXP 2
2887: PPUSH
2888: LD_STRING DDocA5
2890: PPUSH
2891: CALL_OW 94
2895: GO 2967
2897: LD_INT 6
2899: DOUBLE
2900: EQUAL
2901: IFTRUE 2905
2903: GO 2920
2905: POP
// SayRadio ( doc , DDocA6 ) ; 7 :
2906: LD_EXP 2
2910: PPUSH
2911: LD_STRING DDocA6
2913: PPUSH
2914: CALL_OW 94
2918: GO 2967
2920: LD_INT 7
2922: DOUBLE
2923: EQUAL
2924: IFTRUE 2928
2926: GO 2943
2928: POP
// SayRadio ( doc , DDocA7 ) ; 8 :
2929: LD_EXP 2
2933: PPUSH
2934: LD_STRING DDocA7
2936: PPUSH
2937: CALL_OW 94
2941: GO 2967
2943: LD_INT 8
2945: DOUBLE
2946: EQUAL
2947: IFTRUE 2951
2949: GO 2966
2951: POP
// SayRadio ( doc , DDocA8 ) ; end ;
2952: LD_EXP 2
2956: PPUSH
2957: LD_STRING DDocA8
2959: PPUSH
2960: CALL_OW 94
2964: GO 2967
2966: POP
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// every 0 0$01 do
2972: GO 2974
2974: DISABLE
// begin display_strings := [ #tick , tick ] ;
2975: LD_ADDR_OWVAR 47
2979: PUSH
2980: LD_STRING #tick
2982: PUSH
2983: LD_OWVAR 1
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: ST_TO_ADDR
// enable ;
2992: ENABLE
// end ;
2993: END
// export pom , hover , attackN ; every 1 do
2994: GO 2996
2996: DISABLE
// begin pom := [ ] ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: EMPTY
3003: ST_TO_ADDR
// hover := [ ] ;
3004: LD_ADDR_EXP 5
3008: PUSH
3009: EMPTY
3010: ST_TO_ADDR
// attackN := 0 ;
3011: LD_ADDR_EXP 6
3015: PUSH
3016: LD_INT 0
3018: ST_TO_ADDR
// end ;
3019: END
// every 0 0$01 trigger pom do var i , f , z , target ;
3020: LD_EXP 4
3024: IFFALSE 3446
3026: GO 3028
3028: DISABLE
3029: LD_INT 0
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
// begin enable ;
3035: ENABLE
// f := FilterAllUnits ( [ f_side , 7 ] ) ;
3036: LD_ADDR_VAR 0 2
3040: PUSH
3041: LD_INT 22
3043: PUSH
3044: LD_INT 7
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: PPUSH
3051: CALL_OW 69
3055: ST_TO_ADDR
// for i = 1 to pom do
3056: LD_ADDR_VAR 0 1
3060: PUSH
3061: DOUBLE
3062: LD_INT 1
3064: DEC
3065: ST_TO_ADDR
3066: LD_EXP 4
3070: PUSH
3071: FOR_TO
3072: IFFALSE 3130
// if not HasTask ( pom [ i ] ) then
3074: LD_EXP 4
3078: PUSH
3079: LD_VAR 0 1
3083: ARRAY
3084: PPUSH
3085: CALL_OW 314
3089: NOT
3090: IFFALSE 3128
// ComAttackUnit ( pom [ i ] , NearestUnitToUnit ( f , pom [ i ] ) ) ;
3092: LD_EXP 4
3096: PUSH
3097: LD_VAR 0 1
3101: ARRAY
3102: PPUSH
3103: LD_VAR 0 2
3107: PPUSH
3108: LD_EXP 4
3112: PUSH
3113: LD_VAR 0 1
3117: ARRAY
3118: PPUSH
3119: CALL_OW 74
3123: PPUSH
3124: CALL_OW 115
3128: GO 3071
3130: POP
3131: POP
// if hover then
3132: LD_EXP 5
3136: IFFALSE 3446
// begin for i = 1 to hover do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 5
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3444
// begin if GetLives ( hover [ i ] ) < 250 then
3156: LD_EXP 5
3160: PUSH
3161: LD_VAR 0 1
3165: ARRAY
3166: PPUSH
3167: CALL_OW 256
3171: PUSH
3172: LD_INT 250
3174: LESS
3175: IFFALSE 3242
// begin for z = 1 to 1 + Difficulty do
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: DOUBLE
3183: LD_INT 1
3185: DEC
3186: ST_TO_ADDR
3187: LD_INT 1
3189: PUSH
3190: LD_OWVAR 67
3194: PLUS
3195: PUSH
3196: FOR_TO
3197: IFFALSE 3240
// MineExplosion ( GetX ( hover [ i ] ) , GetY ( hover [ i ] ) , 10 ) ;
3199: LD_EXP 5
3203: PUSH
3204: LD_VAR 0 1
3208: ARRAY
3209: PPUSH
3210: CALL_OW 250
3214: PPUSH
3215: LD_EXP 5
3219: PUSH
3220: LD_VAR 0 1
3224: ARRAY
3225: PPUSH
3226: CALL_OW 251
3230: PPUSH
3231: LD_INT 10
3233: PPUSH
3234: CALL_OW 453
3238: GO 3196
3240: POP
3241: POP
// end ; if UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) > 0 then
3242: LD_VAR 0 2
3246: PPUSH
3247: LD_INT 25
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: LD_INT 54
3262: PUSH
3263: EMPTY
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PPUSH
3274: CALL_OW 72
3278: PUSH
3279: LD_INT 0
3281: GREATER
3282: IFFALSE 3364
// begin target := UnitFilter ( f , [ [ f_class , 2 ] , [ f_not , [ f_inside ] ] ] ) ;
3284: LD_ADDR_VAR 0 4
3288: PUSH
3289: LD_VAR 0 2
3293: PPUSH
3294: LD_INT 25
3296: PUSH
3297: LD_INT 2
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PUSH
3304: LD_INT 3
3306: PUSH
3307: LD_INT 54
3309: PUSH
3310: EMPTY
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 72
3325: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3326: LD_EXP 5
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PPUSH
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_EXP 5
3346: PUSH
3347: LD_VAR 0 1
3351: ARRAY
3352: PPUSH
3353: CALL_OW 74
3357: PPUSH
3358: CALL_OW 115
// end else
3362: GO 3442
// begin target := UnitFilter ( f , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) ;
3364: LD_ADDR_VAR 0 4
3368: PUSH
3369: LD_VAR 0 2
3373: PPUSH
3374: LD_INT 21
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 3
3386: PUSH
3387: LD_INT 54
3389: PUSH
3390: EMPTY
3391: LIST
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PPUSH
3401: CALL_OW 72
3405: ST_TO_ADDR
// ComAttackUnit ( hover [ i ] , NearestUnitToUnit ( target , hover [ i ] ) ) ;
3406: LD_EXP 5
3410: PUSH
3411: LD_VAR 0 1
3415: ARRAY
3416: PPUSH
3417: LD_VAR 0 4
3421: PPUSH
3422: LD_EXP 5
3426: PUSH
3427: LD_VAR 0 1
3431: ARRAY
3432: PPUSH
3433: CALL_OW 74
3437: PPUSH
3438: CALL_OW 115
// end ; end ;
3442: GO 3153
3444: POP
3445: POP
// end ; end ;
3446: PPOPN 4
3448: END
// every 3 3$10 do var i , un ;
3449: GO 3451
3451: DISABLE
3452: LD_INT 0
3454: PPUSH
3455: PPUSH
// begin uc_side := 7 ;
3456: LD_ADDR_OWVAR 20
3460: PUSH
3461: LD_INT 7
3463: ST_TO_ADDR
// uc_nation := 1 ;
3464: LD_ADDR_OWVAR 21
3468: PUSH
3469: LD_INT 1
3471: ST_TO_ADDR
// for i = 1 to 2 do
3472: LD_ADDR_VAR 0 1
3476: PUSH
3477: DOUBLE
3478: LD_INT 1
3480: DEC
3481: ST_TO_ADDR
3482: LD_INT 2
3484: PUSH
3485: FOR_TO
3486: IFFALSE 3651
// begin PrepareHuman ( sex_male , class_sniper , [ 7 , 6 , 6 ] [ Difficulty ] ) ;
3488: LD_INT 1
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: LD_INT 7
3496: PUSH
3497: LD_INT 6
3499: PUSH
3500: LD_INT 6
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_OWVAR 67
3512: ARRAY
3513: PPUSH
3514: CALL_OW 380
// vc_chassis := us_light_wheeled ;
3518: LD_ADDR_OWVAR 37
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// vc_engine := engine_combustion ;
3526: LD_ADDR_OWVAR 39
3530: PUSH
3531: LD_INT 1
3533: ST_TO_ADDR
// vc_control := control_manual ;
3534: LD_ADDR_OWVAR 38
3538: PUSH
3539: LD_INT 1
3541: ST_TO_ADDR
// vc_fuel_battery := 66 ;
3542: LD_ADDR_OWVAR 41
3546: PUSH
3547: LD_INT 66
3549: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
3550: LD_ADDR_OWVAR 40
3554: PUSH
3555: LD_INT 2
3557: ST_TO_ADDR
// un := CreateVehicle ;
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: CALL_OW 45
3567: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3568: LD_VAR 0 2
3572: PPUSH
3573: LD_INT 3
3575: PPUSH
3576: CALL_OW 233
// PlaceUnitXY ( un , 48 , 3 , false ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_INT 48
3587: PPUSH
3588: LD_INT 3
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , un ) ;
3598: CALL_OW 44
3602: PPUSH
3603: LD_VAR 0 2
3607: PPUSH
3608: CALL_OW 52
// ComMoveXY ( un , 49 , 17 ) ;
3612: LD_VAR 0 2
3616: PPUSH
3617: LD_INT 49
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: CALL_OW 111
// AddComMoveXY ( un , 48 , 36 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_INT 48
3634: PPUSH
3635: LD_INT 36
3637: PPUSH
3638: CALL_OW 171
// Wait ( 0 0$02 ) ;
3642: LD_INT 70
3644: PPUSH
3645: CALL_OW 67
// end ;
3649: GO 3485
3651: POP
3652: POP
// end ;
3653: PPOPN 2
3655: END
// every 5 5$00 + 3 3$00 trigger attackN < [ 10 , 12 , 14 ] [ Difficulty ] do var c , l ;
3656: LD_EXP 6
3660: PUSH
3661: LD_INT 10
3663: PUSH
3664: LD_INT 12
3666: PUSH
3667: LD_INT 14
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_OWVAR 67
3679: ARRAY
3680: LESS
3681: IFFALSE 4383
3683: GO 3685
3685: DISABLE
3686: LD_INT 0
3688: PPUSH
3689: PPUSH
// begin enable ;
3690: ENABLE
// Randomize ;
3691: CALL_OW 10
// Wait ( Rand ( 0 0$01 , 2 2$59 ) ) ;
3695: LD_INT 35
3697: PPUSH
3698: LD_INT 6265
3700: PPUSH
3701: CALL_OW 12
3705: PPUSH
3706: CALL_OW 67
// if attackN < [ 4 , 4 , 5 ] [ Difficulty ] then
3710: LD_EXP 6
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 4
3720: PUSH
3721: LD_INT 5
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PUSH
3729: LD_OWVAR 67
3733: ARRAY
3734: LESS
3735: IFFALSE 3755
// c := Rand ( 1 , 2 ) else
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PPUSH
3745: LD_INT 2
3747: PPUSH
3748: CALL_OW 12
3752: ST_TO_ADDR
3753: GO 3771
// c := Rand ( 1 , 3 ) ;
3755: LD_ADDR_VAR 0 1
3759: PUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 3
3765: PPUSH
3766: CALL_OW 12
3770: ST_TO_ADDR
// if attackN = 0 then
3771: LD_EXP 6
3775: PUSH
3776: LD_INT 0
3778: EQUAL
3779: IFFALSE 3795
// Say ( com , DJackAttack ) else
3781: LD_EXP 1
3785: PPUSH
3786: LD_STRING DJackAttack
3788: PPUSH
3789: CALL_OW 88
3793: GO 3799
// DSay ;
3795: CALL 2753 0 0
// case c of 1 :
3799: LD_VAR 0 1
3803: PUSH
3804: LD_INT 1
3806: DOUBLE
3807: EQUAL
3808: IFTRUE 3812
3810: GO 3994
3812: POP
// begin pom := pom ^ Attack ( 1 ) ;
3813: LD_ADDR_EXP 4
3817: PUSH
3818: LD_EXP 4
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: CALL 1264 0 1
3830: ADD
3831: ST_TO_ADDR
// Wait ( 0 0$12 ) ;
3832: LD_INT 420
3834: PPUSH
3835: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3839: LD_ADDR_EXP 4
3843: PUSH
3844: LD_EXP 4
3848: PUSH
3849: LD_INT 3
3851: PPUSH
3852: CALL 1264 0 1
3856: ADD
3857: ST_TO_ADDR
// if Difficulty > 2 then
3858: LD_OWVAR 67
3862: PUSH
3863: LD_INT 2
3865: GREATER
3866: IFFALSE 3894
// begin Wait ( 0 0$46 ) ;
3868: LD_INT 1610
3870: PPUSH
3871: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
3875: LD_ADDR_EXP 4
3879: PUSH
3880: LD_EXP 4
3884: PUSH
3885: LD_INT 4
3887: PPUSH
3888: CALL 1264 0 1
3892: ADD
3893: ST_TO_ADDR
// end ; if attackN > 4 then
3894: LD_EXP 6
3898: PUSH
3899: LD_INT 4
3901: GREATER
3902: IFFALSE 3930
// begin Wait ( 0 0$12 ) ;
3904: LD_INT 420
3906: PPUSH
3907: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
3911: LD_ADDR_EXP 4
3915: PUSH
3916: LD_EXP 4
3920: PUSH
3921: LD_INT 3
3923: PPUSH
3924: CALL 1264 0 1
3928: ADD
3929: ST_TO_ADDR
// end ; if attackN > 8 then
3930: LD_EXP 6
3934: PUSH
3935: LD_INT 8
3937: GREATER
3938: IFFALSE 3992
// begin Wait ( 0 0$12 ) ;
3940: LD_INT 420
3942: PPUSH
3943: CALL_OW 67
// l := Rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// if l < 45 then
3963: LD_VAR 0 2
3967: PUSH
3968: LD_INT 45
3970: LESS
3971: IFFALSE 3992
// pom := pom ^ Attack ( 2 ) ;
3973: LD_ADDR_EXP 4
3977: PUSH
3978: LD_EXP 4
3982: PUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL 1264 0 1
3990: ADD
3991: ST_TO_ADDR
// end ; end ; 2 :
3992: GO 4281
3994: LD_INT 2
3996: DOUBLE
3997: EQUAL
3998: IFTRUE 4002
4000: GO 4150
4002: POP
// begin pom := pom ^ Attack ( 2 ) ;
4003: LD_ADDR_EXP 4
4007: PUSH
4008: LD_EXP 4
4012: PUSH
4013: LD_INT 2
4015: PPUSH
4016: CALL 1264 0 1
4020: ADD
4021: ST_TO_ADDR
// pom := pom ^ Attack ( 3 ) ;
4022: LD_ADDR_EXP 4
4026: PUSH
4027: LD_EXP 4
4031: PUSH
4032: LD_INT 3
4034: PPUSH
4035: CALL 1264 0 1
4039: ADD
4040: ST_TO_ADDR
// if Difficulty > 1 and GetBType ( HexInfo ( 63 , 37 ) ) = b_siberite_mine then
4041: LD_OWVAR 67
4045: PUSH
4046: LD_INT 1
4048: GREATER
4049: PUSH
4050: LD_INT 63
4052: PPUSH
4053: LD_INT 37
4055: PPUSH
4056: CALL_OW 428
4060: PPUSH
4061: CALL_OW 266
4065: PUSH
4066: LD_INT 30
4068: EQUAL
4069: AND
4070: IFFALSE 4076
// ComitSib ;
4072: CALL 2675 0 0
// if Difficulty > 2 then
4076: LD_OWVAR 67
4080: PUSH
4081: LD_INT 2
4083: GREATER
4084: IFFALSE 4112
// begin Wait ( 0 0$25 ) ;
4086: LD_INT 875
4088: PPUSH
4089: CALL_OW 67
// pom := pom ^ Attack ( 4 ) ;
4093: LD_ADDR_EXP 4
4097: PUSH
4098: LD_EXP 4
4102: PUSH
4103: LD_INT 4
4105: PPUSH
4106: CALL 1264 0 1
4110: ADD
4111: ST_TO_ADDR
// end ; if attackN > 7 then
4112: LD_EXP 6
4116: PUSH
4117: LD_INT 7
4119: GREATER
4120: IFFALSE 4148
// begin Wait ( 0 0$15 ) ;
4122: LD_INT 525
4124: PPUSH
4125: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4129: LD_ADDR_EXP 4
4133: PUSH
4134: LD_EXP 4
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: CALL 1264 0 1
4146: ADD
4147: ST_TO_ADDR
// end ; end ; 3 :
4148: GO 4281
4150: LD_INT 3
4152: DOUBLE
4153: EQUAL
4154: IFTRUE 4158
4156: GO 4280
4158: POP
// begin pom := pom ^ Attack ( 1 ) ;
4159: LD_ADDR_EXP 4
4163: PUSH
4164: LD_EXP 4
4168: PUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL 1264 0 1
4176: ADD
4177: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
4178: LD_INT 70
4180: PPUSH
4181: CALL_OW 67
// pom := pom ^ Attack ( 2 ) ;
4185: LD_ADDR_EXP 4
4189: PUSH
4190: LD_EXP 4
4194: PUSH
4195: LD_INT 2
4197: PPUSH
4198: CALL 1264 0 1
4202: ADD
4203: ST_TO_ADDR
// Wait ( 1 1$00 ) ;
4204: LD_INT 2100
4206: PPUSH
4207: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4211: LD_ADDR_EXP 4
4215: PUSH
4216: LD_EXP 4
4220: PUSH
4221: LD_INT 3
4223: PPUSH
4224: CALL 1264 0 1
4228: ADD
4229: ST_TO_ADDR
// pom := pom ^ Attack ( 5 ) ;
4230: LD_ADDR_EXP 4
4234: PUSH
4235: LD_EXP 4
4239: PUSH
4240: LD_INT 5
4242: PPUSH
4243: CALL 1264 0 1
4247: ADD
4248: ST_TO_ADDR
// if attackN > 10 then
4249: LD_EXP 6
4253: PUSH
4254: LD_INT 10
4256: GREATER
4257: IFFALSE 4278
// pom := pom ^ Attack ( 2 ) ;
4259: LD_ADDR_EXP 4
4263: PUSH
4264: LD_EXP 4
4268: PUSH
4269: LD_INT 2
4271: PPUSH
4272: CALL 1264 0 1
4276: ADD
4277: ST_TO_ADDR
// end ; end ;
4278: GO 4281
4280: POP
// if Difficulty > 1 and attackN mod 4 = 0 then
4281: LD_OWVAR 67
4285: PUSH
4286: LD_INT 1
4288: GREATER
4289: PUSH
4290: LD_EXP 6
4294: PUSH
4295: LD_INT 4
4297: MOD
4298: PUSH
4299: LD_INT 0
4301: EQUAL
4302: AND
4303: IFFALSE 4369
// begin Wait ( 1 1$45 ) ;
4305: LD_INT 3675
4307: PPUSH
4308: CALL_OW 67
// pom := pom ^ Attack ( 3 ) ;
4312: LD_ADDR_EXP 4
4316: PUSH
4317: LD_EXP 4
4321: PUSH
4322: LD_INT 3
4324: PPUSH
4325: CALL 1264 0 1
4329: ADD
4330: ST_TO_ADDR
// pom := pom ^ Attack ( 4 ) ;
4331: LD_ADDR_EXP 4
4335: PUSH
4336: LD_EXP 4
4340: PUSH
4341: LD_INT 4
4343: PPUSH
4344: CALL 1264 0 1
4348: ADD
4349: ST_TO_ADDR
// hover := hover ^ Attack ( 6 ) ;
4350: LD_ADDR_EXP 5
4354: PUSH
4355: LD_EXP 5
4359: PUSH
4360: LD_INT 6
4362: PPUSH
4363: CALL 1264 0 1
4367: ADD
4368: ST_TO_ADDR
// end ; attackN := attackN + 1 ;
4369: LD_ADDR_EXP 6
4373: PUSH
4374: LD_EXP 6
4378: PUSH
4379: LD_INT 1
4381: PLUS
4382: ST_TO_ADDR
// end ;
4383: PPOPN 2
4385: END
// every 0 0$10 trigger attackN >= [ 10 , 12 , 14 ] [ Difficulty ] and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
4386: LD_EXP 6
4390: PUSH
4391: LD_INT 10
4393: PUSH
4394: LD_INT 12
4396: PUSH
4397: LD_INT 14
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PUSH
4405: LD_OWVAR 67
4409: ARRAY
4410: GREATEREQUAL
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PPUSH
4422: CALL_OW 69
4426: PUSH
4427: LD_INT 0
4429: EQUAL
4430: AND
4431: IFFALSE 4487
4433: GO 4435
4435: DISABLE
// begin SayRadio ( doc , DDocEnd ) ;
4436: LD_EXP 2
4440: PPUSH
4441: LD_STRING DDocEnd
4443: PPUSH
4444: CALL_OW 94
// Wait ( 0 0$03 ) ;
4448: LD_INT 105
4450: PPUSH
4451: CALL_OW 67
// case Query ( QWin ) of 1 :
4455: LD_STRING QWin
4457: PPUSH
4458: CALL_OW 97
4462: PUSH
4463: LD_INT 1
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4474
4471: POP
// ; end ;
4472: GO 4475
4474: POP
// music_nat := 5 ;
4475: LD_ADDR_OWVAR 71
4479: PUSH
4480: LD_INT 5
4482: ST_TO_ADDR
// YouWin ;
4483: CALL_OW 103
// end ; end_of_file
4487: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
4488: LD_VAR 0 1
4492: PPUSH
4493: CALL 15704 0 1
// if un = brave or un = com then
4497: LD_VAR 0 1
4501: PUSH
4502: LD_INT 1
4504: EQUAL
4505: PUSH
4506: LD_VAR 0 1
4510: PUSH
4511: LD_EXP 1
4515: EQUAL
4516: OR
4517: IFFALSE 4538
// begin SayRadio ( doc , DDocWin ) ;
4519: LD_EXP 2
4523: PPUSH
4524: LD_STRING DDocWin
4526: PPUSH
4527: CALL_OW 94
// YouLost (  ) ;
4531: LD_STRING 
4533: PPUSH
4534: CALL_OW 104
// end ; end ;
4538: PPOPN 1
4540: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
4541: LD_VAR 0 1
4545: PPUSH
4546: LD_VAR 0 2
4550: PPUSH
4551: LD_VAR 0 3
4555: PPUSH
4556: CALL 15802 0 3
// end ;
4560: PPOPN 3
4562: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
4563: LD_VAR 0 1
4567: PPUSH
4568: CALL 15810 0 1
// end ; end_of_file
4572: PPOPN 1
4574: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
4575: GO 4577
4577: DISABLE
// begin ru_radar := 98 ;
4578: LD_ADDR_EXP 7
4582: PUSH
4583: LD_INT 98
4585: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4586: LD_ADDR_EXP 8
4590: PUSH
4591: LD_INT 89
4593: ST_TO_ADDR
// us_hack := 99 ;
4594: LD_ADDR_EXP 9
4598: PUSH
4599: LD_INT 99
4601: ST_TO_ADDR
// us_artillery := 97 ;
4602: LD_ADDR_EXP 10
4606: PUSH
4607: LD_INT 97
4609: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4610: LD_ADDR_EXP 11
4614: PUSH
4615: LD_INT 91
4617: ST_TO_ADDR
// tech_Artillery := 80 ;
4618: LD_ADDR_EXP 12
4622: PUSH
4623: LD_INT 80
4625: ST_TO_ADDR
// tech_RadMat := 81 ;
4626: LD_ADDR_EXP 13
4630: PUSH
4631: LD_INT 81
4633: ST_TO_ADDR
// tech_BasicTools := 82 ;
4634: LD_ADDR_EXP 14
4638: PUSH
4639: LD_INT 82
4641: ST_TO_ADDR
// tech_Cargo := 83 ;
4642: LD_ADDR_EXP 15
4646: PUSH
4647: LD_INT 83
4649: ST_TO_ADDR
// tech_Track := 84 ;
4650: LD_ADDR_EXP 16
4654: PUSH
4655: LD_INT 84
4657: ST_TO_ADDR
// tech_Crane := 85 ;
4658: LD_ADDR_EXP 17
4662: PUSH
4663: LD_INT 85
4665: ST_TO_ADDR
// tech_Bulldozer := 86 ;
4666: LD_ADDR_EXP 18
4670: PUSH
4671: LD_INT 86
4673: ST_TO_ADDR
// tech_Hovercraft := 87 ;
4674: LD_ADDR_EXP 19
4678: PUSH
4679: LD_INT 87
4681: ST_TO_ADDR
// end ; end_of_file end_of_file
4682: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
4683: GO 4685
4685: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4686: LD_STRING initStreamRollete();
4688: PPUSH
4689: CALL_OW 559
// InitStreamMode ;
4693: CALL 4702 0 0
// DefineStreamItems ( ) ;
4697: CALL 5142 0 0
// end ;
4701: END
// function InitStreamMode ; begin
4702: LD_INT 0
4704: PPUSH
// streamModeActive := false ;
4705: LD_ADDR_EXP 20
4709: PUSH
4710: LD_INT 0
4712: ST_TO_ADDR
// normalCounter := 36 ;
4713: LD_ADDR_EXP 21
4717: PUSH
4718: LD_INT 36
4720: ST_TO_ADDR
// hardcoreCounter := 16 ;
4721: LD_ADDR_EXP 22
4725: PUSH
4726: LD_INT 16
4728: ST_TO_ADDR
// sRocket := false ;
4729: LD_ADDR_EXP 25
4733: PUSH
4734: LD_INT 0
4736: ST_TO_ADDR
// sSpeed := false ;
4737: LD_ADDR_EXP 24
4741: PUSH
4742: LD_INT 0
4744: ST_TO_ADDR
// sEngine := false ;
4745: LD_ADDR_EXP 26
4749: PUSH
4750: LD_INT 0
4752: ST_TO_ADDR
// sSpec := false ;
4753: LD_ADDR_EXP 23
4757: PUSH
4758: LD_INT 0
4760: ST_TO_ADDR
// sLevel := false ;
4761: LD_ADDR_EXP 27
4765: PUSH
4766: LD_INT 0
4768: ST_TO_ADDR
// sArmoury := false ;
4769: LD_ADDR_EXP 28
4773: PUSH
4774: LD_INT 0
4776: ST_TO_ADDR
// sRadar := false ;
4777: LD_ADDR_EXP 29
4781: PUSH
4782: LD_INT 0
4784: ST_TO_ADDR
// sBunker := false ;
4785: LD_ADDR_EXP 30
4789: PUSH
4790: LD_INT 0
4792: ST_TO_ADDR
// sHack := false ;
4793: LD_ADDR_EXP 31
4797: PUSH
4798: LD_INT 0
4800: ST_TO_ADDR
// sFire := false ;
4801: LD_ADDR_EXP 32
4805: PUSH
4806: LD_INT 0
4808: ST_TO_ADDR
// sRefresh := false ;
4809: LD_ADDR_EXP 33
4813: PUSH
4814: LD_INT 0
4816: ST_TO_ADDR
// sExp := false ;
4817: LD_ADDR_EXP 34
4821: PUSH
4822: LD_INT 0
4824: ST_TO_ADDR
// sDepot := false ;
4825: LD_ADDR_EXP 35
4829: PUSH
4830: LD_INT 0
4832: ST_TO_ADDR
// sFlag := false ;
4833: LD_ADDR_EXP 36
4837: PUSH
4838: LD_INT 0
4840: ST_TO_ADDR
// sKamikadze := false ;
4841: LD_ADDR_EXP 44
4845: PUSH
4846: LD_INT 0
4848: ST_TO_ADDR
// sTroll := false ;
4849: LD_ADDR_EXP 45
4853: PUSH
4854: LD_INT 0
4856: ST_TO_ADDR
// sSlow := false ;
4857: LD_ADDR_EXP 46
4861: PUSH
4862: LD_INT 0
4864: ST_TO_ADDR
// sLack := false ;
4865: LD_ADDR_EXP 47
4869: PUSH
4870: LD_INT 0
4872: ST_TO_ADDR
// sTank := false ;
4873: LD_ADDR_EXP 49
4877: PUSH
4878: LD_INT 0
4880: ST_TO_ADDR
// sRemote := false ;
4881: LD_ADDR_EXP 50
4885: PUSH
4886: LD_INT 0
4888: ST_TO_ADDR
// sPowell := false ;
4889: LD_ADDR_EXP 51
4893: PUSH
4894: LD_INT 0
4896: ST_TO_ADDR
// sTeleport := false ;
4897: LD_ADDR_EXP 54
4901: PUSH
4902: LD_INT 0
4904: ST_TO_ADDR
// sOilTower := false ;
4905: LD_ADDR_EXP 56
4909: PUSH
4910: LD_INT 0
4912: ST_TO_ADDR
// sShovel := false ;
4913: LD_ADDR_EXP 57
4917: PUSH
4918: LD_INT 0
4920: ST_TO_ADDR
// sSheik := false ;
4921: LD_ADDR_EXP 58
4925: PUSH
4926: LD_INT 0
4928: ST_TO_ADDR
// sEarthquake := false ;
4929: LD_ADDR_EXP 60
4933: PUSH
4934: LD_INT 0
4936: ST_TO_ADDR
// sAI := false ;
4937: LD_ADDR_EXP 61
4941: PUSH
4942: LD_INT 0
4944: ST_TO_ADDR
// sCargo := false ;
4945: LD_ADDR_EXP 64
4949: PUSH
4950: LD_INT 0
4952: ST_TO_ADDR
// sDLaser := false ;
4953: LD_ADDR_EXP 65
4957: PUSH
4958: LD_INT 0
4960: ST_TO_ADDR
// sExchange := false ;
4961: LD_ADDR_EXP 66
4965: PUSH
4966: LD_INT 0
4968: ST_TO_ADDR
// sFac := false ;
4969: LD_ADDR_EXP 67
4973: PUSH
4974: LD_INT 0
4976: ST_TO_ADDR
// sPower := false ;
4977: LD_ADDR_EXP 68
4981: PUSH
4982: LD_INT 0
4984: ST_TO_ADDR
// sRandom := false ;
4985: LD_ADDR_EXP 69
4989: PUSH
4990: LD_INT 0
4992: ST_TO_ADDR
// sShield := false ;
4993: LD_ADDR_EXP 70
4997: PUSH
4998: LD_INT 0
5000: ST_TO_ADDR
// sTime := false ;
5001: LD_ADDR_EXP 71
5005: PUSH
5006: LD_INT 0
5008: ST_TO_ADDR
// sTools := false ;
5009: LD_ADDR_EXP 72
5013: PUSH
5014: LD_INT 0
5016: ST_TO_ADDR
// sSold := false ;
5017: LD_ADDR_EXP 37
5021: PUSH
5022: LD_INT 0
5024: ST_TO_ADDR
// sDiff := false ;
5025: LD_ADDR_EXP 38
5029: PUSH
5030: LD_INT 0
5032: ST_TO_ADDR
// sFog := false ;
5033: LD_ADDR_EXP 41
5037: PUSH
5038: LD_INT 0
5040: ST_TO_ADDR
// sReset := false ;
5041: LD_ADDR_EXP 42
5045: PUSH
5046: LD_INT 0
5048: ST_TO_ADDR
// sSun := false ;
5049: LD_ADDR_EXP 43
5053: PUSH
5054: LD_INT 0
5056: ST_TO_ADDR
// sTiger := false ;
5057: LD_ADDR_EXP 39
5061: PUSH
5062: LD_INT 0
5064: ST_TO_ADDR
// sBomb := false ;
5065: LD_ADDR_EXP 40
5069: PUSH
5070: LD_INT 0
5072: ST_TO_ADDR
// sWound := false ;
5073: LD_ADDR_EXP 48
5077: PUSH
5078: LD_INT 0
5080: ST_TO_ADDR
// sBetray := false ;
5081: LD_ADDR_EXP 52
5085: PUSH
5086: LD_INT 0
5088: ST_TO_ADDR
// sContamin := false ;
5089: LD_ADDR_EXP 53
5093: PUSH
5094: LD_INT 0
5096: ST_TO_ADDR
// sOil := false ;
5097: LD_ADDR_EXP 55
5101: PUSH
5102: LD_INT 0
5104: ST_TO_ADDR
// sStu := false ;
5105: LD_ADDR_EXP 59
5109: PUSH
5110: LD_INT 0
5112: ST_TO_ADDR
// sBazooka := false ;
5113: LD_ADDR_EXP 62
5117: PUSH
5118: LD_INT 0
5120: ST_TO_ADDR
// sMortar := false ;
5121: LD_ADDR_EXP 63
5125: PUSH
5126: LD_INT 0
5128: ST_TO_ADDR
// sRanger := false ;
5129: LD_ADDR_EXP 73
5133: PUSH
5134: LD_INT 0
5136: ST_TO_ADDR
// end ;
5137: LD_VAR 0 1
5141: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
5142: LD_INT 0
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// result := [ ] ;
5149: LD_ADDR_VAR 0 1
5153: PUSH
5154: EMPTY
5155: ST_TO_ADDR
// if campaign_id = 1 then
5156: LD_OWVAR 69
5160: PUSH
5161: LD_INT 1
5163: EQUAL
5164: IFFALSE 8102
// begin case mission_number of 1 :
5166: LD_OWVAR 70
5170: PUSH
5171: LD_INT 1
5173: DOUBLE
5174: EQUAL
5175: IFTRUE 5179
5177: GO 5243
5179: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
5180: LD_ADDR_VAR 0 1
5184: PUSH
5185: LD_INT 2
5187: PUSH
5188: LD_INT 4
5190: PUSH
5191: LD_INT 11
5193: PUSH
5194: LD_INT 12
5196: PUSH
5197: LD_INT 15
5199: PUSH
5200: LD_INT 16
5202: PUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 23
5208: PUSH
5209: LD_INT 26
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 101
5225: PUSH
5226: LD_INT 102
5228: PUSH
5229: LD_INT 106
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: EMPTY
5238: LIST
5239: LIST
5240: ST_TO_ADDR
5241: GO 8100
5243: LD_INT 2
5245: DOUBLE
5246: EQUAL
5247: IFTRUE 5251
5249: GO 5323
5251: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
5252: LD_ADDR_VAR 0 1
5256: PUSH
5257: LD_INT 2
5259: PUSH
5260: LD_INT 4
5262: PUSH
5263: LD_INT 11
5265: PUSH
5266: LD_INT 12
5268: PUSH
5269: LD_INT 15
5271: PUSH
5272: LD_INT 16
5274: PUSH
5275: LD_INT 22
5277: PUSH
5278: LD_INT 23
5280: PUSH
5281: LD_INT 26
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: LIST
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 101
5297: PUSH
5298: LD_INT 102
5300: PUSH
5301: LD_INT 105
5303: PUSH
5304: LD_INT 106
5306: PUSH
5307: LD_INT 108
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: LIST
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: ST_TO_ADDR
5321: GO 8100
5323: LD_INT 3
5325: DOUBLE
5326: EQUAL
5327: IFTRUE 5331
5329: GO 5407
5331: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
5332: LD_ADDR_VAR 0 1
5336: PUSH
5337: LD_INT 2
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: LD_INT 5
5345: PUSH
5346: LD_INT 11
5348: PUSH
5349: LD_INT 12
5351: PUSH
5352: LD_INT 15
5354: PUSH
5355: LD_INT 16
5357: PUSH
5358: LD_INT 22
5360: PUSH
5361: LD_INT 26
5363: PUSH
5364: LD_INT 36
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 101
5381: PUSH
5382: LD_INT 102
5384: PUSH
5385: LD_INT 105
5387: PUSH
5388: LD_INT 106
5390: PUSH
5391: LD_INT 108
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: LIST
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: ST_TO_ADDR
5405: GO 8100
5407: LD_INT 4
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5499
5415: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
5416: LD_ADDR_VAR 0 1
5420: PUSH
5421: LD_INT 2
5423: PUSH
5424: LD_INT 4
5426: PUSH
5427: LD_INT 5
5429: PUSH
5430: LD_INT 8
5432: PUSH
5433: LD_INT 11
5435: PUSH
5436: LD_INT 12
5438: PUSH
5439: LD_INT 15
5441: PUSH
5442: LD_INT 16
5444: PUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 23
5450: PUSH
5451: LD_INT 26
5453: PUSH
5454: LD_INT 36
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: LIST
5461: LIST
5462: LIST
5463: LIST
5464: LIST
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PUSH
5471: LD_INT 101
5473: PUSH
5474: LD_INT 102
5476: PUSH
5477: LD_INT 105
5479: PUSH
5480: LD_INT 106
5482: PUSH
5483: LD_INT 108
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: ST_TO_ADDR
5497: GO 8100
5499: LD_INT 5
5501: DOUBLE
5502: EQUAL
5503: IFTRUE 5507
5505: GO 5607
5507: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
5508: LD_ADDR_VAR 0 1
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 4
5518: PUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 6
5524: PUSH
5525: LD_INT 8
5527: PUSH
5528: LD_INT 11
5530: PUSH
5531: LD_INT 12
5533: PUSH
5534: LD_INT 15
5536: PUSH
5537: LD_INT 16
5539: PUSH
5540: LD_INT 22
5542: PUSH
5543: LD_INT 23
5545: PUSH
5546: LD_INT 25
5548: PUSH
5549: LD_INT 26
5551: PUSH
5552: LD_INT 36
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 101
5573: PUSH
5574: LD_INT 102
5576: PUSH
5577: LD_INT 105
5579: PUSH
5580: LD_INT 106
5582: PUSH
5583: LD_INT 108
5585: PUSH
5586: LD_INT 109
5588: PUSH
5589: LD_INT 112
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: LIST
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: ST_TO_ADDR
5605: GO 8100
5607: LD_INT 6
5609: DOUBLE
5610: EQUAL
5611: IFTRUE 5615
5613: GO 5735
5615: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
5616: LD_ADDR_VAR 0 1
5620: PUSH
5621: LD_INT 2
5623: PUSH
5624: LD_INT 4
5626: PUSH
5627: LD_INT 5
5629: PUSH
5630: LD_INT 6
5632: PUSH
5633: LD_INT 8
5635: PUSH
5636: LD_INT 11
5638: PUSH
5639: LD_INT 12
5641: PUSH
5642: LD_INT 15
5644: PUSH
5645: LD_INT 16
5647: PUSH
5648: LD_INT 20
5650: PUSH
5651: LD_INT 21
5653: PUSH
5654: LD_INT 22
5656: PUSH
5657: LD_INT 23
5659: PUSH
5660: LD_INT 25
5662: PUSH
5663: LD_INT 26
5665: PUSH
5666: LD_INT 30
5668: PUSH
5669: LD_INT 31
5671: PUSH
5672: LD_INT 32
5674: PUSH
5675: LD_INT 36
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 101
5701: PUSH
5702: LD_INT 102
5704: PUSH
5705: LD_INT 105
5707: PUSH
5708: LD_INT 106
5710: PUSH
5711: LD_INT 108
5713: PUSH
5714: LD_INT 109
5716: PUSH
5717: LD_INT 112
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: ST_TO_ADDR
5733: GO 8100
5735: LD_INT 7
5737: DOUBLE
5738: EQUAL
5739: IFTRUE 5743
5741: GO 5843
5743: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
5744: LD_ADDR_VAR 0 1
5748: PUSH
5749: LD_INT 2
5751: PUSH
5752: LD_INT 4
5754: PUSH
5755: LD_INT 5
5757: PUSH
5758: LD_INT 7
5760: PUSH
5761: LD_INT 11
5763: PUSH
5764: LD_INT 12
5766: PUSH
5767: LD_INT 15
5769: PUSH
5770: LD_INT 16
5772: PUSH
5773: LD_INT 20
5775: PUSH
5776: LD_INT 21
5778: PUSH
5779: LD_INT 22
5781: PUSH
5782: LD_INT 23
5784: PUSH
5785: LD_INT 25
5787: PUSH
5788: LD_INT 26
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: LD_INT 101
5809: PUSH
5810: LD_INT 102
5812: PUSH
5813: LD_INT 103
5815: PUSH
5816: LD_INT 105
5818: PUSH
5819: LD_INT 106
5821: PUSH
5822: LD_INT 108
5824: PUSH
5825: LD_INT 112
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: LIST
5836: PUSH
5837: EMPTY
5838: LIST
5839: LIST
5840: ST_TO_ADDR
5841: GO 8100
5843: LD_INT 8
5845: DOUBLE
5846: EQUAL
5847: IFTRUE 5851
5849: GO 5979
5851: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
5852: LD_ADDR_VAR 0 1
5856: PUSH
5857: LD_INT 2
5859: PUSH
5860: LD_INT 4
5862: PUSH
5863: LD_INT 5
5865: PUSH
5866: LD_INT 6
5868: PUSH
5869: LD_INT 7
5871: PUSH
5872: LD_INT 8
5874: PUSH
5875: LD_INT 11
5877: PUSH
5878: LD_INT 12
5880: PUSH
5881: LD_INT 15
5883: PUSH
5884: LD_INT 16
5886: PUSH
5887: LD_INT 20
5889: PUSH
5890: LD_INT 21
5892: PUSH
5893: LD_INT 22
5895: PUSH
5896: LD_INT 23
5898: PUSH
5899: LD_INT 25
5901: PUSH
5902: LD_INT 26
5904: PUSH
5905: LD_INT 30
5907: PUSH
5908: LD_INT 31
5910: PUSH
5911: LD_INT 32
5913: PUSH
5914: LD_INT 36
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: PUSH
5939: LD_INT 101
5941: PUSH
5942: LD_INT 102
5944: PUSH
5945: LD_INT 103
5947: PUSH
5948: LD_INT 105
5950: PUSH
5951: LD_INT 106
5953: PUSH
5954: LD_INT 108
5956: PUSH
5957: LD_INT 109
5959: PUSH
5960: LD_INT 112
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: LIST
5971: LIST
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: ST_TO_ADDR
5977: GO 8100
5979: LD_INT 9
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 6123
5987: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
5988: LD_ADDR_VAR 0 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 4
5998: PUSH
5999: LD_INT 5
6001: PUSH
6002: LD_INT 6
6004: PUSH
6005: LD_INT 7
6007: PUSH
6008: LD_INT 8
6010: PUSH
6011: LD_INT 11
6013: PUSH
6014: LD_INT 12
6016: PUSH
6017: LD_INT 15
6019: PUSH
6020: LD_INT 16
6022: PUSH
6023: LD_INT 20
6025: PUSH
6026: LD_INT 21
6028: PUSH
6029: LD_INT 22
6031: PUSH
6032: LD_INT 23
6034: PUSH
6035: LD_INT 25
6037: PUSH
6038: LD_INT 26
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 30
6046: PUSH
6047: LD_INT 31
6049: PUSH
6050: LD_INT 32
6052: PUSH
6053: LD_INT 36
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 101
6081: PUSH
6082: LD_INT 102
6084: PUSH
6085: LD_INT 103
6087: PUSH
6088: LD_INT 105
6090: PUSH
6091: LD_INT 106
6093: PUSH
6094: LD_INT 108
6096: PUSH
6097: LD_INT 109
6099: PUSH
6100: LD_INT 112
6102: PUSH
6103: LD_INT 114
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: ST_TO_ADDR
6121: GO 8100
6123: LD_INT 10
6125: DOUBLE
6126: EQUAL
6127: IFTRUE 6131
6129: GO 6315
6131: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
6132: LD_ADDR_VAR 0 1
6136: PUSH
6137: LD_INT 2
6139: PUSH
6140: LD_INT 4
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 6
6148: PUSH
6149: LD_INT 7
6151: PUSH
6152: LD_INT 8
6154: PUSH
6155: LD_INT 9
6157: PUSH
6158: LD_INT 10
6160: PUSH
6161: LD_INT 11
6163: PUSH
6164: LD_INT 12
6166: PUSH
6167: LD_INT 13
6169: PUSH
6170: LD_INT 14
6172: PUSH
6173: LD_INT 15
6175: PUSH
6176: LD_INT 16
6178: PUSH
6179: LD_INT 17
6181: PUSH
6182: LD_INT 18
6184: PUSH
6185: LD_INT 19
6187: PUSH
6188: LD_INT 20
6190: PUSH
6191: LD_INT 21
6193: PUSH
6194: LD_INT 22
6196: PUSH
6197: LD_INT 23
6199: PUSH
6200: LD_INT 24
6202: PUSH
6203: LD_INT 25
6205: PUSH
6206: LD_INT 26
6208: PUSH
6209: LD_INT 28
6211: PUSH
6212: LD_INT 30
6214: PUSH
6215: LD_INT 31
6217: PUSH
6218: LD_INT 32
6220: PUSH
6221: LD_INT 36
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 101
6257: PUSH
6258: LD_INT 102
6260: PUSH
6261: LD_INT 103
6263: PUSH
6264: LD_INT 104
6266: PUSH
6267: LD_INT 105
6269: PUSH
6270: LD_INT 106
6272: PUSH
6273: LD_INT 107
6275: PUSH
6276: LD_INT 108
6278: PUSH
6279: LD_INT 109
6281: PUSH
6282: LD_INT 110
6284: PUSH
6285: LD_INT 111
6287: PUSH
6288: LD_INT 112
6290: PUSH
6291: LD_INT 114
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: LIST
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: ST_TO_ADDR
6313: GO 8100
6315: LD_INT 11
6317: DOUBLE
6318: EQUAL
6319: IFTRUE 6323
6321: GO 6515
6323: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
6324: LD_ADDR_VAR 0 1
6328: PUSH
6329: LD_INT 2
6331: PUSH
6332: LD_INT 3
6334: PUSH
6335: LD_INT 4
6337: PUSH
6338: LD_INT 5
6340: PUSH
6341: LD_INT 6
6343: PUSH
6344: LD_INT 7
6346: PUSH
6347: LD_INT 8
6349: PUSH
6350: LD_INT 9
6352: PUSH
6353: LD_INT 10
6355: PUSH
6356: LD_INT 11
6358: PUSH
6359: LD_INT 12
6361: PUSH
6362: LD_INT 13
6364: PUSH
6365: LD_INT 14
6367: PUSH
6368: LD_INT 15
6370: PUSH
6371: LD_INT 16
6373: PUSH
6374: LD_INT 17
6376: PUSH
6377: LD_INT 18
6379: PUSH
6380: LD_INT 19
6382: PUSH
6383: LD_INT 20
6385: PUSH
6386: LD_INT 21
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 23
6394: PUSH
6395: LD_INT 24
6397: PUSH
6398: LD_INT 25
6400: PUSH
6401: LD_INT 26
6403: PUSH
6404: LD_INT 28
6406: PUSH
6407: LD_INT 30
6409: PUSH
6410: LD_INT 31
6412: PUSH
6413: LD_INT 32
6415: PUSH
6416: LD_INT 34
6418: PUSH
6419: LD_INT 36
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: LIST
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: LIST
6448: LIST
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 101
6457: PUSH
6458: LD_INT 102
6460: PUSH
6461: LD_INT 103
6463: PUSH
6464: LD_INT 104
6466: PUSH
6467: LD_INT 105
6469: PUSH
6470: LD_INT 106
6472: PUSH
6473: LD_INT 107
6475: PUSH
6476: LD_INT 108
6478: PUSH
6479: LD_INT 109
6481: PUSH
6482: LD_INT 110
6484: PUSH
6485: LD_INT 111
6487: PUSH
6488: LD_INT 112
6490: PUSH
6491: LD_INT 114
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: ST_TO_ADDR
6513: GO 8100
6515: LD_INT 12
6517: DOUBLE
6518: EQUAL
6519: IFTRUE 6523
6521: GO 6731
6523: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
6524: LD_ADDR_VAR 0 1
6528: PUSH
6529: LD_INT 1
6531: PUSH
6532: LD_INT 2
6534: PUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 4
6540: PUSH
6541: LD_INT 5
6543: PUSH
6544: LD_INT 6
6546: PUSH
6547: LD_INT 7
6549: PUSH
6550: LD_INT 8
6552: PUSH
6553: LD_INT 9
6555: PUSH
6556: LD_INT 10
6558: PUSH
6559: LD_INT 11
6561: PUSH
6562: LD_INT 12
6564: PUSH
6565: LD_INT 13
6567: PUSH
6568: LD_INT 14
6570: PUSH
6571: LD_INT 15
6573: PUSH
6574: LD_INT 16
6576: PUSH
6577: LD_INT 17
6579: PUSH
6580: LD_INT 18
6582: PUSH
6583: LD_INT 19
6585: PUSH
6586: LD_INT 20
6588: PUSH
6589: LD_INT 21
6591: PUSH
6592: LD_INT 22
6594: PUSH
6595: LD_INT 23
6597: PUSH
6598: LD_INT 24
6600: PUSH
6601: LD_INT 25
6603: PUSH
6604: LD_INT 26
6606: PUSH
6607: LD_INT 27
6609: PUSH
6610: LD_INT 28
6612: PUSH
6613: LD_INT 30
6615: PUSH
6616: LD_INT 31
6618: PUSH
6619: LD_INT 32
6621: PUSH
6622: LD_INT 33
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 36
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: LIST
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: LIST
6664: LIST
6665: LIST
6666: PUSH
6667: LD_INT 101
6669: PUSH
6670: LD_INT 102
6672: PUSH
6673: LD_INT 103
6675: PUSH
6676: LD_INT 104
6678: PUSH
6679: LD_INT 105
6681: PUSH
6682: LD_INT 106
6684: PUSH
6685: LD_INT 107
6687: PUSH
6688: LD_INT 108
6690: PUSH
6691: LD_INT 109
6693: PUSH
6694: LD_INT 110
6696: PUSH
6697: LD_INT 111
6699: PUSH
6700: LD_INT 112
6702: PUSH
6703: LD_INT 113
6705: PUSH
6706: LD_INT 114
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: ST_TO_ADDR
6729: GO 8100
6731: LD_INT 13
6733: DOUBLE
6734: EQUAL
6735: IFTRUE 6739
6737: GO 6935
6739: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_INT 1
6747: PUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 3
6753: PUSH
6754: LD_INT 4
6756: PUSH
6757: LD_INT 5
6759: PUSH
6760: LD_INT 8
6762: PUSH
6763: LD_INT 9
6765: PUSH
6766: LD_INT 10
6768: PUSH
6769: LD_INT 11
6771: PUSH
6772: LD_INT 12
6774: PUSH
6775: LD_INT 14
6777: PUSH
6778: LD_INT 15
6780: PUSH
6781: LD_INT 16
6783: PUSH
6784: LD_INT 17
6786: PUSH
6787: LD_INT 18
6789: PUSH
6790: LD_INT 19
6792: PUSH
6793: LD_INT 20
6795: PUSH
6796: LD_INT 21
6798: PUSH
6799: LD_INT 22
6801: PUSH
6802: LD_INT 23
6804: PUSH
6805: LD_INT 24
6807: PUSH
6808: LD_INT 25
6810: PUSH
6811: LD_INT 26
6813: PUSH
6814: LD_INT 27
6816: PUSH
6817: LD_INT 28
6819: PUSH
6820: LD_INT 30
6822: PUSH
6823: LD_INT 31
6825: PUSH
6826: LD_INT 32
6828: PUSH
6829: LD_INT 33
6831: PUSH
6832: LD_INT 34
6834: PUSH
6835: LD_INT 36
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: LIST
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: LIST
6847: LIST
6848: LIST
6849: LIST
6850: LIST
6851: LIST
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: PUSH
6871: LD_INT 101
6873: PUSH
6874: LD_INT 102
6876: PUSH
6877: LD_INT 103
6879: PUSH
6880: LD_INT 104
6882: PUSH
6883: LD_INT 105
6885: PUSH
6886: LD_INT 106
6888: PUSH
6889: LD_INT 107
6891: PUSH
6892: LD_INT 108
6894: PUSH
6895: LD_INT 109
6897: PUSH
6898: LD_INT 110
6900: PUSH
6901: LD_INT 111
6903: PUSH
6904: LD_INT 112
6906: PUSH
6907: LD_INT 113
6909: PUSH
6910: LD_INT 114
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: LIST
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: ST_TO_ADDR
6933: GO 8100
6935: LD_INT 14
6937: DOUBLE
6938: EQUAL
6939: IFTRUE 6943
6941: GO 7155
6943: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
6944: LD_ADDR_VAR 0 1
6948: PUSH
6949: LD_INT 1
6951: PUSH
6952: LD_INT 2
6954: PUSH
6955: LD_INT 3
6957: PUSH
6958: LD_INT 4
6960: PUSH
6961: LD_INT 5
6963: PUSH
6964: LD_INT 6
6966: PUSH
6967: LD_INT 7
6969: PUSH
6970: LD_INT 8
6972: PUSH
6973: LD_INT 9
6975: PUSH
6976: LD_INT 10
6978: PUSH
6979: LD_INT 11
6981: PUSH
6982: LD_INT 12
6984: PUSH
6985: LD_INT 13
6987: PUSH
6988: LD_INT 14
6990: PUSH
6991: LD_INT 15
6993: PUSH
6994: LD_INT 16
6996: PUSH
6997: LD_INT 17
6999: PUSH
7000: LD_INT 18
7002: PUSH
7003: LD_INT 19
7005: PUSH
7006: LD_INT 20
7008: PUSH
7009: LD_INT 21
7011: PUSH
7012: LD_INT 22
7014: PUSH
7015: LD_INT 23
7017: PUSH
7018: LD_INT 24
7020: PUSH
7021: LD_INT 25
7023: PUSH
7024: LD_INT 26
7026: PUSH
7027: LD_INT 27
7029: PUSH
7030: LD_INT 28
7032: PUSH
7033: LD_INT 29
7035: PUSH
7036: LD_INT 30
7038: PUSH
7039: LD_INT 31
7041: PUSH
7042: LD_INT 32
7044: PUSH
7045: LD_INT 33
7047: PUSH
7048: LD_INT 34
7050: PUSH
7051: LD_INT 36
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: LIST
7058: LIST
7059: LIST
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: LIST
7079: LIST
7080: LIST
7081: LIST
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: LIST
7089: LIST
7090: PUSH
7091: LD_INT 101
7093: PUSH
7094: LD_INT 102
7096: PUSH
7097: LD_INT 103
7099: PUSH
7100: LD_INT 104
7102: PUSH
7103: LD_INT 105
7105: PUSH
7106: LD_INT 106
7108: PUSH
7109: LD_INT 107
7111: PUSH
7112: LD_INT 108
7114: PUSH
7115: LD_INT 109
7117: PUSH
7118: LD_INT 110
7120: PUSH
7121: LD_INT 111
7123: PUSH
7124: LD_INT 112
7126: PUSH
7127: LD_INT 113
7129: PUSH
7130: LD_INT 114
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: LIST
7141: LIST
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: ST_TO_ADDR
7153: GO 8100
7155: LD_INT 15
7157: DOUBLE
7158: EQUAL
7159: IFTRUE 7163
7161: GO 7375
7163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
7164: LD_ADDR_VAR 0 1
7168: PUSH
7169: LD_INT 1
7171: PUSH
7172: LD_INT 2
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 5
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 7
7189: PUSH
7190: LD_INT 8
7192: PUSH
7193: LD_INT 9
7195: PUSH
7196: LD_INT 10
7198: PUSH
7199: LD_INT 11
7201: PUSH
7202: LD_INT 12
7204: PUSH
7205: LD_INT 13
7207: PUSH
7208: LD_INT 14
7210: PUSH
7211: LD_INT 15
7213: PUSH
7214: LD_INT 16
7216: PUSH
7217: LD_INT 17
7219: PUSH
7220: LD_INT 18
7222: PUSH
7223: LD_INT 19
7225: PUSH
7226: LD_INT 20
7228: PUSH
7229: LD_INT 21
7231: PUSH
7232: LD_INT 22
7234: PUSH
7235: LD_INT 23
7237: PUSH
7238: LD_INT 24
7240: PUSH
7241: LD_INT 25
7243: PUSH
7244: LD_INT 26
7246: PUSH
7247: LD_INT 27
7249: PUSH
7250: LD_INT 28
7252: PUSH
7253: LD_INT 29
7255: PUSH
7256: LD_INT 30
7258: PUSH
7259: LD_INT 31
7261: PUSH
7262: LD_INT 32
7264: PUSH
7265: LD_INT 33
7267: PUSH
7268: LD_INT 34
7270: PUSH
7271: LD_INT 36
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: LIST
7281: LIST
7282: LIST
7283: LIST
7284: LIST
7285: LIST
7286: LIST
7287: LIST
7288: LIST
7289: LIST
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: LIST
7300: LIST
7301: LIST
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: LIST
7307: LIST
7308: LIST
7309: LIST
7310: PUSH
7311: LD_INT 101
7313: PUSH
7314: LD_INT 102
7316: PUSH
7317: LD_INT 103
7319: PUSH
7320: LD_INT 104
7322: PUSH
7323: LD_INT 105
7325: PUSH
7326: LD_INT 106
7328: PUSH
7329: LD_INT 107
7331: PUSH
7332: LD_INT 108
7334: PUSH
7335: LD_INT 109
7337: PUSH
7338: LD_INT 110
7340: PUSH
7341: LD_INT 111
7343: PUSH
7344: LD_INT 112
7346: PUSH
7347: LD_INT 113
7349: PUSH
7350: LD_INT 114
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: LIST
7360: LIST
7361: LIST
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: ST_TO_ADDR
7373: GO 8100
7375: LD_INT 16
7377: DOUBLE
7378: EQUAL
7379: IFTRUE 7383
7381: GO 7507
7383: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
7384: LD_ADDR_VAR 0 1
7388: PUSH
7389: LD_INT 2
7391: PUSH
7392: LD_INT 4
7394: PUSH
7395: LD_INT 5
7397: PUSH
7398: LD_INT 7
7400: PUSH
7401: LD_INT 11
7403: PUSH
7404: LD_INT 12
7406: PUSH
7407: LD_INT 15
7409: PUSH
7410: LD_INT 16
7412: PUSH
7413: LD_INT 20
7415: PUSH
7416: LD_INT 21
7418: PUSH
7419: LD_INT 22
7421: PUSH
7422: LD_INT 23
7424: PUSH
7425: LD_INT 25
7427: PUSH
7428: LD_INT 26
7430: PUSH
7431: LD_INT 30
7433: PUSH
7434: LD_INT 31
7436: PUSH
7437: LD_INT 32
7439: PUSH
7440: LD_INT 33
7442: PUSH
7443: LD_INT 34
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: LIST
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: LIST
7466: PUSH
7467: LD_INT 101
7469: PUSH
7470: LD_INT 102
7472: PUSH
7473: LD_INT 103
7475: PUSH
7476: LD_INT 106
7478: PUSH
7479: LD_INT 108
7481: PUSH
7482: LD_INT 112
7484: PUSH
7485: LD_INT 113
7487: PUSH
7488: LD_INT 114
7490: PUSH
7491: EMPTY
7492: LIST
7493: LIST
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: ST_TO_ADDR
7505: GO 8100
7507: LD_INT 17
7509: DOUBLE
7510: EQUAL
7511: IFTRUE 7515
7513: GO 7727
7515: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
7516: LD_ADDR_VAR 0 1
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: LD_INT 2
7526: PUSH
7527: LD_INT 3
7529: PUSH
7530: LD_INT 4
7532: PUSH
7533: LD_INT 5
7535: PUSH
7536: LD_INT 6
7538: PUSH
7539: LD_INT 7
7541: PUSH
7542: LD_INT 8
7544: PUSH
7545: LD_INT 9
7547: PUSH
7548: LD_INT 10
7550: PUSH
7551: LD_INT 11
7553: PUSH
7554: LD_INT 12
7556: PUSH
7557: LD_INT 13
7559: PUSH
7560: LD_INT 14
7562: PUSH
7563: LD_INT 15
7565: PUSH
7566: LD_INT 16
7568: PUSH
7569: LD_INT 17
7571: PUSH
7572: LD_INT 18
7574: PUSH
7575: LD_INT 19
7577: PUSH
7578: LD_INT 20
7580: PUSH
7581: LD_INT 21
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_INT 23
7589: PUSH
7590: LD_INT 24
7592: PUSH
7593: LD_INT 25
7595: PUSH
7596: LD_INT 26
7598: PUSH
7599: LD_INT 27
7601: PUSH
7602: LD_INT 28
7604: PUSH
7605: LD_INT 29
7607: PUSH
7608: LD_INT 30
7610: PUSH
7611: LD_INT 31
7613: PUSH
7614: LD_INT 32
7616: PUSH
7617: LD_INT 33
7619: PUSH
7620: LD_INT 34
7622: PUSH
7623: LD_INT 36
7625: PUSH
7626: EMPTY
7627: LIST
7628: LIST
7629: LIST
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: LIST
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: LIST
7659: LIST
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 101
7665: PUSH
7666: LD_INT 102
7668: PUSH
7669: LD_INT 103
7671: PUSH
7672: LD_INT 104
7674: PUSH
7675: LD_INT 105
7677: PUSH
7678: LD_INT 106
7680: PUSH
7681: LD_INT 107
7683: PUSH
7684: LD_INT 108
7686: PUSH
7687: LD_INT 109
7689: PUSH
7690: LD_INT 110
7692: PUSH
7693: LD_INT 111
7695: PUSH
7696: LD_INT 112
7698: PUSH
7699: LD_INT 113
7701: PUSH
7702: LD_INT 114
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: ST_TO_ADDR
7725: GO 8100
7727: LD_INT 18
7729: DOUBLE
7730: EQUAL
7731: IFTRUE 7735
7733: GO 7871
7735: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
7736: LD_ADDR_VAR 0 1
7740: PUSH
7741: LD_INT 2
7743: PUSH
7744: LD_INT 4
7746: PUSH
7747: LD_INT 5
7749: PUSH
7750: LD_INT 7
7752: PUSH
7753: LD_INT 11
7755: PUSH
7756: LD_INT 12
7758: PUSH
7759: LD_INT 15
7761: PUSH
7762: LD_INT 16
7764: PUSH
7765: LD_INT 20
7767: PUSH
7768: LD_INT 21
7770: PUSH
7771: LD_INT 22
7773: PUSH
7774: LD_INT 23
7776: PUSH
7777: LD_INT 25
7779: PUSH
7780: LD_INT 26
7782: PUSH
7783: LD_INT 30
7785: PUSH
7786: LD_INT 31
7788: PUSH
7789: LD_INT 32
7791: PUSH
7792: LD_INT 33
7794: PUSH
7795: LD_INT 34
7797: PUSH
7798: LD_INT 35
7800: PUSH
7801: LD_INT 36
7803: PUSH
7804: EMPTY
7805: LIST
7806: LIST
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: LIST
7816: LIST
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 101
7829: PUSH
7830: LD_INT 102
7832: PUSH
7833: LD_INT 103
7835: PUSH
7836: LD_INT 106
7838: PUSH
7839: LD_INT 108
7841: PUSH
7842: LD_INT 112
7844: PUSH
7845: LD_INT 113
7847: PUSH
7848: LD_INT 114
7850: PUSH
7851: LD_INT 115
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: ST_TO_ADDR
7869: GO 8100
7871: LD_INT 19
7873: DOUBLE
7874: EQUAL
7875: IFTRUE 7879
7877: GO 8099
7879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
7880: LD_ADDR_VAR 0 1
7884: PUSH
7885: LD_INT 1
7887: PUSH
7888: LD_INT 2
7890: PUSH
7891: LD_INT 3
7893: PUSH
7894: LD_INT 4
7896: PUSH
7897: LD_INT 5
7899: PUSH
7900: LD_INT 6
7902: PUSH
7903: LD_INT 7
7905: PUSH
7906: LD_INT 8
7908: PUSH
7909: LD_INT 9
7911: PUSH
7912: LD_INT 10
7914: PUSH
7915: LD_INT 11
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: LD_INT 13
7923: PUSH
7924: LD_INT 14
7926: PUSH
7927: LD_INT 15
7929: PUSH
7930: LD_INT 16
7932: PUSH
7933: LD_INT 17
7935: PUSH
7936: LD_INT 18
7938: PUSH
7939: LD_INT 19
7941: PUSH
7942: LD_INT 20
7944: PUSH
7945: LD_INT 21
7947: PUSH
7948: LD_INT 22
7950: PUSH
7951: LD_INT 23
7953: PUSH
7954: LD_INT 24
7956: PUSH
7957: LD_INT 25
7959: PUSH
7960: LD_INT 26
7962: PUSH
7963: LD_INT 27
7965: PUSH
7966: LD_INT 28
7968: PUSH
7969: LD_INT 29
7971: PUSH
7972: LD_INT 30
7974: PUSH
7975: LD_INT 31
7977: PUSH
7978: LD_INT 32
7980: PUSH
7981: LD_INT 33
7983: PUSH
7984: LD_INT 34
7986: PUSH
7987: LD_INT 35
7989: PUSH
7990: LD_INT 36
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: LIST
7999: LIST
8000: LIST
8001: LIST
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: LIST
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: LIST
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 101
8033: PUSH
8034: LD_INT 102
8036: PUSH
8037: LD_INT 103
8039: PUSH
8040: LD_INT 104
8042: PUSH
8043: LD_INT 105
8045: PUSH
8046: LD_INT 106
8048: PUSH
8049: LD_INT 107
8051: PUSH
8052: LD_INT 108
8054: PUSH
8055: LD_INT 109
8057: PUSH
8058: LD_INT 110
8060: PUSH
8061: LD_INT 111
8063: PUSH
8064: LD_INT 112
8066: PUSH
8067: LD_INT 113
8069: PUSH
8070: LD_INT 114
8072: PUSH
8073: LD_INT 115
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: LIST
8080: LIST
8081: LIST
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: LIST
8087: LIST
8088: LIST
8089: LIST
8090: LIST
8091: LIST
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: ST_TO_ADDR
8097: GO 8100
8099: POP
// end else
8100: GO 8319
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
8102: LD_ADDR_VAR 0 1
8106: PUSH
8107: LD_INT 1
8109: PUSH
8110: LD_INT 2
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: LD_INT 4
8118: PUSH
8119: LD_INT 5
8121: PUSH
8122: LD_INT 6
8124: PUSH
8125: LD_INT 7
8127: PUSH
8128: LD_INT 8
8130: PUSH
8131: LD_INT 9
8133: PUSH
8134: LD_INT 10
8136: PUSH
8137: LD_INT 11
8139: PUSH
8140: LD_INT 12
8142: PUSH
8143: LD_INT 13
8145: PUSH
8146: LD_INT 14
8148: PUSH
8149: LD_INT 15
8151: PUSH
8152: LD_INT 16
8154: PUSH
8155: LD_INT 17
8157: PUSH
8158: LD_INT 18
8160: PUSH
8161: LD_INT 19
8163: PUSH
8164: LD_INT 20
8166: PUSH
8167: LD_INT 21
8169: PUSH
8170: LD_INT 22
8172: PUSH
8173: LD_INT 23
8175: PUSH
8176: LD_INT 24
8178: PUSH
8179: LD_INT 25
8181: PUSH
8182: LD_INT 26
8184: PUSH
8185: LD_INT 27
8187: PUSH
8188: LD_INT 28
8190: PUSH
8191: LD_INT 29
8193: PUSH
8194: LD_INT 30
8196: PUSH
8197: LD_INT 31
8199: PUSH
8200: LD_INT 32
8202: PUSH
8203: LD_INT 33
8205: PUSH
8206: LD_INT 34
8208: PUSH
8209: LD_INT 35
8211: PUSH
8212: LD_INT 36
8214: PUSH
8215: EMPTY
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: LIST
8252: PUSH
8253: LD_INT 101
8255: PUSH
8256: LD_INT 102
8258: PUSH
8259: LD_INT 103
8261: PUSH
8262: LD_INT 104
8264: PUSH
8265: LD_INT 105
8267: PUSH
8268: LD_INT 106
8270: PUSH
8271: LD_INT 107
8273: PUSH
8274: LD_INT 108
8276: PUSH
8277: LD_INT 109
8279: PUSH
8280: LD_INT 110
8282: PUSH
8283: LD_INT 111
8285: PUSH
8286: LD_INT 112
8288: PUSH
8289: LD_INT 113
8291: PUSH
8292: LD_INT 114
8294: PUSH
8295: LD_INT 115
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: LIST
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: EMPTY
8316: LIST
8317: LIST
8318: ST_TO_ADDR
// if result then
8319: LD_VAR 0 1
8323: IFFALSE 8612
// begin normal :=  ;
8325: LD_ADDR_VAR 0 3
8329: PUSH
8330: LD_STRING 
8332: ST_TO_ADDR
// hardcore :=  ;
8333: LD_ADDR_VAR 0 4
8337: PUSH
8338: LD_STRING 
8340: ST_TO_ADDR
// for i = 1 to normalCounter do
8341: LD_ADDR_VAR 0 5
8345: PUSH
8346: DOUBLE
8347: LD_INT 1
8349: DEC
8350: ST_TO_ADDR
8351: LD_EXP 21
8355: PUSH
8356: FOR_TO
8357: IFFALSE 8458
// begin tmp := 0 ;
8359: LD_ADDR_VAR 0 2
8363: PUSH
8364: LD_STRING 0
8366: ST_TO_ADDR
// if result [ 1 ] then
8367: LD_VAR 0 1
8371: PUSH
8372: LD_INT 1
8374: ARRAY
8375: IFFALSE 8440
// if result [ 1 ] [ 1 ] = i then
8377: LD_VAR 0 1
8381: PUSH
8382: LD_INT 1
8384: ARRAY
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: PUSH
8390: LD_VAR 0 5
8394: EQUAL
8395: IFFALSE 8440
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
8397: LD_ADDR_VAR 0 1
8401: PUSH
8402: LD_VAR 0 1
8406: PPUSH
8407: LD_INT 1
8409: PPUSH
8410: LD_VAR 0 1
8414: PUSH
8415: LD_INT 1
8417: ARRAY
8418: PPUSH
8419: LD_INT 1
8421: PPUSH
8422: CALL_OW 3
8426: PPUSH
8427: CALL_OW 1
8431: ST_TO_ADDR
// tmp := 1 ;
8432: LD_ADDR_VAR 0 2
8436: PUSH
8437: LD_STRING 1
8439: ST_TO_ADDR
// end ; normal := normal & tmp ;
8440: LD_ADDR_VAR 0 3
8444: PUSH
8445: LD_VAR 0 3
8449: PUSH
8450: LD_VAR 0 2
8454: STR
8455: ST_TO_ADDR
// end ;
8456: GO 8356
8458: POP
8459: POP
// for i = 1 to hardcoreCounter do
8460: LD_ADDR_VAR 0 5
8464: PUSH
8465: DOUBLE
8466: LD_INT 1
8468: DEC
8469: ST_TO_ADDR
8470: LD_EXP 22
8474: PUSH
8475: FOR_TO
8476: IFFALSE 8581
// begin tmp := 0 ;
8478: LD_ADDR_VAR 0 2
8482: PUSH
8483: LD_STRING 0
8485: ST_TO_ADDR
// if result [ 2 ] then
8486: LD_VAR 0 1
8490: PUSH
8491: LD_INT 2
8493: ARRAY
8494: IFFALSE 8563
// if result [ 2 ] [ 1 ] = 100 + i then
8496: LD_VAR 0 1
8500: PUSH
8501: LD_INT 2
8503: ARRAY
8504: PUSH
8505: LD_INT 1
8507: ARRAY
8508: PUSH
8509: LD_INT 100
8511: PUSH
8512: LD_VAR 0 5
8516: PLUS
8517: EQUAL
8518: IFFALSE 8563
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: LD_VAR 0 1
8529: PPUSH
8530: LD_INT 2
8532: PPUSH
8533: LD_VAR 0 1
8537: PUSH
8538: LD_INT 2
8540: ARRAY
8541: PPUSH
8542: LD_INT 1
8544: PPUSH
8545: CALL_OW 3
8549: PPUSH
8550: CALL_OW 1
8554: ST_TO_ADDR
// tmp := 1 ;
8555: LD_ADDR_VAR 0 2
8559: PUSH
8560: LD_STRING 1
8562: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
8563: LD_ADDR_VAR 0 4
8567: PUSH
8568: LD_VAR 0 4
8572: PUSH
8573: LD_VAR 0 2
8577: STR
8578: ST_TO_ADDR
// end ;
8579: GO 8475
8581: POP
8582: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
8583: LD_STRING getStreamItemsFromMission("
8585: PUSH
8586: LD_VAR 0 3
8590: STR
8591: PUSH
8592: LD_STRING ","
8594: STR
8595: PUSH
8596: LD_VAR 0 4
8600: STR
8601: PUSH
8602: LD_STRING ")
8604: STR
8605: PPUSH
8606: CALL_OW 559
// end else
8610: GO 8619
// ToLua ( getStreamItemsFromMission("","") ) ;
8612: LD_STRING getStreamItemsFromMission("","")
8614: PPUSH
8615: CALL_OW 559
// end ;
8619: LD_VAR 0 1
8623: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8624: LD_VAR 0 2
8628: PUSH
8629: LD_INT 100
8631: EQUAL
8632: IFFALSE 9581
// begin if not StreamModeActive then
8634: LD_EXP 20
8638: NOT
8639: IFFALSE 8649
// StreamModeActive := true ;
8641: LD_ADDR_EXP 20
8645: PUSH
8646: LD_INT 1
8648: ST_TO_ADDR
// if p3 = 0 then
8649: LD_VAR 0 3
8653: PUSH
8654: LD_INT 0
8656: EQUAL
8657: IFFALSE 8663
// InitStreamMode ;
8659: CALL 4702 0 0
// if p3 = 1 then
8663: LD_VAR 0 3
8667: PUSH
8668: LD_INT 1
8670: EQUAL
8671: IFFALSE 8681
// sRocket := true ;
8673: LD_ADDR_EXP 25
8677: PUSH
8678: LD_INT 1
8680: ST_TO_ADDR
// if p3 = 2 then
8681: LD_VAR 0 3
8685: PUSH
8686: LD_INT 2
8688: EQUAL
8689: IFFALSE 8699
// sSpeed := true ;
8691: LD_ADDR_EXP 24
8695: PUSH
8696: LD_INT 1
8698: ST_TO_ADDR
// if p3 = 3 then
8699: LD_VAR 0 3
8703: PUSH
8704: LD_INT 3
8706: EQUAL
8707: IFFALSE 8717
// sEngine := true ;
8709: LD_ADDR_EXP 26
8713: PUSH
8714: LD_INT 1
8716: ST_TO_ADDR
// if p3 = 4 then
8717: LD_VAR 0 3
8721: PUSH
8722: LD_INT 4
8724: EQUAL
8725: IFFALSE 8735
// sSpec := true ;
8727: LD_ADDR_EXP 23
8731: PUSH
8732: LD_INT 1
8734: ST_TO_ADDR
// if p3 = 5 then
8735: LD_VAR 0 3
8739: PUSH
8740: LD_INT 5
8742: EQUAL
8743: IFFALSE 8753
// sLevel := true ;
8745: LD_ADDR_EXP 27
8749: PUSH
8750: LD_INT 1
8752: ST_TO_ADDR
// if p3 = 6 then
8753: LD_VAR 0 3
8757: PUSH
8758: LD_INT 6
8760: EQUAL
8761: IFFALSE 8771
// sArmoury := true ;
8763: LD_ADDR_EXP 28
8767: PUSH
8768: LD_INT 1
8770: ST_TO_ADDR
// if p3 = 7 then
8771: LD_VAR 0 3
8775: PUSH
8776: LD_INT 7
8778: EQUAL
8779: IFFALSE 8789
// sRadar := true ;
8781: LD_ADDR_EXP 29
8785: PUSH
8786: LD_INT 1
8788: ST_TO_ADDR
// if p3 = 8 then
8789: LD_VAR 0 3
8793: PUSH
8794: LD_INT 8
8796: EQUAL
8797: IFFALSE 8807
// sBunker := true ;
8799: LD_ADDR_EXP 30
8803: PUSH
8804: LD_INT 1
8806: ST_TO_ADDR
// if p3 = 9 then
8807: LD_VAR 0 3
8811: PUSH
8812: LD_INT 9
8814: EQUAL
8815: IFFALSE 8825
// sHack := true ;
8817: LD_ADDR_EXP 31
8821: PUSH
8822: LD_INT 1
8824: ST_TO_ADDR
// if p3 = 10 then
8825: LD_VAR 0 3
8829: PUSH
8830: LD_INT 10
8832: EQUAL
8833: IFFALSE 8843
// sFire := true ;
8835: LD_ADDR_EXP 32
8839: PUSH
8840: LD_INT 1
8842: ST_TO_ADDR
// if p3 = 11 then
8843: LD_VAR 0 3
8847: PUSH
8848: LD_INT 11
8850: EQUAL
8851: IFFALSE 8861
// sRefresh := true ;
8853: LD_ADDR_EXP 33
8857: PUSH
8858: LD_INT 1
8860: ST_TO_ADDR
// if p3 = 12 then
8861: LD_VAR 0 3
8865: PUSH
8866: LD_INT 12
8868: EQUAL
8869: IFFALSE 8879
// sExp := true ;
8871: LD_ADDR_EXP 34
8875: PUSH
8876: LD_INT 1
8878: ST_TO_ADDR
// if p3 = 13 then
8879: LD_VAR 0 3
8883: PUSH
8884: LD_INT 13
8886: EQUAL
8887: IFFALSE 8897
// sDepot := true ;
8889: LD_ADDR_EXP 35
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// if p3 = 14 then
8897: LD_VAR 0 3
8901: PUSH
8902: LD_INT 14
8904: EQUAL
8905: IFFALSE 8915
// sFlag := true ;
8907: LD_ADDR_EXP 36
8911: PUSH
8912: LD_INT 1
8914: ST_TO_ADDR
// if p3 = 15 then
8915: LD_VAR 0 3
8919: PUSH
8920: LD_INT 15
8922: EQUAL
8923: IFFALSE 8933
// sKamikadze := true ;
8925: LD_ADDR_EXP 44
8929: PUSH
8930: LD_INT 1
8932: ST_TO_ADDR
// if p3 = 16 then
8933: LD_VAR 0 3
8937: PUSH
8938: LD_INT 16
8940: EQUAL
8941: IFFALSE 8951
// sTroll := true ;
8943: LD_ADDR_EXP 45
8947: PUSH
8948: LD_INT 1
8950: ST_TO_ADDR
// if p3 = 17 then
8951: LD_VAR 0 3
8955: PUSH
8956: LD_INT 17
8958: EQUAL
8959: IFFALSE 8969
// sSlow := true ;
8961: LD_ADDR_EXP 46
8965: PUSH
8966: LD_INT 1
8968: ST_TO_ADDR
// if p3 = 18 then
8969: LD_VAR 0 3
8973: PUSH
8974: LD_INT 18
8976: EQUAL
8977: IFFALSE 8987
// sLack := true ;
8979: LD_ADDR_EXP 47
8983: PUSH
8984: LD_INT 1
8986: ST_TO_ADDR
// if p3 = 19 then
8987: LD_VAR 0 3
8991: PUSH
8992: LD_INT 19
8994: EQUAL
8995: IFFALSE 9005
// sTank := true ;
8997: LD_ADDR_EXP 49
9001: PUSH
9002: LD_INT 1
9004: ST_TO_ADDR
// if p3 = 20 then
9005: LD_VAR 0 3
9009: PUSH
9010: LD_INT 20
9012: EQUAL
9013: IFFALSE 9023
// sRemote := true ;
9015: LD_ADDR_EXP 50
9019: PUSH
9020: LD_INT 1
9022: ST_TO_ADDR
// if p3 = 21 then
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 21
9030: EQUAL
9031: IFFALSE 9041
// sPowell := true ;
9033: LD_ADDR_EXP 51
9037: PUSH
9038: LD_INT 1
9040: ST_TO_ADDR
// if p3 = 22 then
9041: LD_VAR 0 3
9045: PUSH
9046: LD_INT 22
9048: EQUAL
9049: IFFALSE 9059
// sTeleport := true ;
9051: LD_ADDR_EXP 54
9055: PUSH
9056: LD_INT 1
9058: ST_TO_ADDR
// if p3 = 23 then
9059: LD_VAR 0 3
9063: PUSH
9064: LD_INT 23
9066: EQUAL
9067: IFFALSE 9077
// sOilTower := true ;
9069: LD_ADDR_EXP 56
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// if p3 = 24 then
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 24
9084: EQUAL
9085: IFFALSE 9095
// sShovel := true ;
9087: LD_ADDR_EXP 57
9091: PUSH
9092: LD_INT 1
9094: ST_TO_ADDR
// if p3 = 25 then
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 25
9102: EQUAL
9103: IFFALSE 9113
// sSheik := true ;
9105: LD_ADDR_EXP 58
9109: PUSH
9110: LD_INT 1
9112: ST_TO_ADDR
// if p3 = 26 then
9113: LD_VAR 0 3
9117: PUSH
9118: LD_INT 26
9120: EQUAL
9121: IFFALSE 9131
// sEarthquake := true ;
9123: LD_ADDR_EXP 60
9127: PUSH
9128: LD_INT 1
9130: ST_TO_ADDR
// if p3 = 27 then
9131: LD_VAR 0 3
9135: PUSH
9136: LD_INT 27
9138: EQUAL
9139: IFFALSE 9149
// sAI := true ;
9141: LD_ADDR_EXP 61
9145: PUSH
9146: LD_INT 1
9148: ST_TO_ADDR
// if p3 = 28 then
9149: LD_VAR 0 3
9153: PUSH
9154: LD_INT 28
9156: EQUAL
9157: IFFALSE 9167
// sCargo := true ;
9159: LD_ADDR_EXP 64
9163: PUSH
9164: LD_INT 1
9166: ST_TO_ADDR
// if p3 = 29 then
9167: LD_VAR 0 3
9171: PUSH
9172: LD_INT 29
9174: EQUAL
9175: IFFALSE 9185
// sDLaser := true ;
9177: LD_ADDR_EXP 65
9181: PUSH
9182: LD_INT 1
9184: ST_TO_ADDR
// if p3 = 30 then
9185: LD_VAR 0 3
9189: PUSH
9190: LD_INT 30
9192: EQUAL
9193: IFFALSE 9203
// sExchange := true ;
9195: LD_ADDR_EXP 66
9199: PUSH
9200: LD_INT 1
9202: ST_TO_ADDR
// if p3 = 31 then
9203: LD_VAR 0 3
9207: PUSH
9208: LD_INT 31
9210: EQUAL
9211: IFFALSE 9221
// sFac := true ;
9213: LD_ADDR_EXP 67
9217: PUSH
9218: LD_INT 1
9220: ST_TO_ADDR
// if p3 = 32 then
9221: LD_VAR 0 3
9225: PUSH
9226: LD_INT 32
9228: EQUAL
9229: IFFALSE 9239
// sPower := true ;
9231: LD_ADDR_EXP 68
9235: PUSH
9236: LD_INT 1
9238: ST_TO_ADDR
// if p3 = 33 then
9239: LD_VAR 0 3
9243: PUSH
9244: LD_INT 33
9246: EQUAL
9247: IFFALSE 9257
// sRandom := true ;
9249: LD_ADDR_EXP 69
9253: PUSH
9254: LD_INT 1
9256: ST_TO_ADDR
// if p3 = 34 then
9257: LD_VAR 0 3
9261: PUSH
9262: LD_INT 34
9264: EQUAL
9265: IFFALSE 9275
// sShield := true ;
9267: LD_ADDR_EXP 70
9271: PUSH
9272: LD_INT 1
9274: ST_TO_ADDR
// if p3 = 35 then
9275: LD_VAR 0 3
9279: PUSH
9280: LD_INT 35
9282: EQUAL
9283: IFFALSE 9293
// sTime := true ;
9285: LD_ADDR_EXP 71
9289: PUSH
9290: LD_INT 1
9292: ST_TO_ADDR
// if p3 = 36 then
9293: LD_VAR 0 3
9297: PUSH
9298: LD_INT 36
9300: EQUAL
9301: IFFALSE 9311
// sTools := true ;
9303: LD_ADDR_EXP 72
9307: PUSH
9308: LD_INT 1
9310: ST_TO_ADDR
// if p3 = 101 then
9311: LD_VAR 0 3
9315: PUSH
9316: LD_INT 101
9318: EQUAL
9319: IFFALSE 9329
// sSold := true ;
9321: LD_ADDR_EXP 37
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// if p3 = 102 then
9329: LD_VAR 0 3
9333: PUSH
9334: LD_INT 102
9336: EQUAL
9337: IFFALSE 9347
// sDiff := true ;
9339: LD_ADDR_EXP 38
9343: PUSH
9344: LD_INT 1
9346: ST_TO_ADDR
// if p3 = 103 then
9347: LD_VAR 0 3
9351: PUSH
9352: LD_INT 103
9354: EQUAL
9355: IFFALSE 9365
// sFog := true ;
9357: LD_ADDR_EXP 41
9361: PUSH
9362: LD_INT 1
9364: ST_TO_ADDR
// if p3 = 104 then
9365: LD_VAR 0 3
9369: PUSH
9370: LD_INT 104
9372: EQUAL
9373: IFFALSE 9383
// sReset := true ;
9375: LD_ADDR_EXP 42
9379: PUSH
9380: LD_INT 1
9382: ST_TO_ADDR
// if p3 = 105 then
9383: LD_VAR 0 3
9387: PUSH
9388: LD_INT 105
9390: EQUAL
9391: IFFALSE 9401
// sSun := true ;
9393: LD_ADDR_EXP 43
9397: PUSH
9398: LD_INT 1
9400: ST_TO_ADDR
// if p3 = 106 then
9401: LD_VAR 0 3
9405: PUSH
9406: LD_INT 106
9408: EQUAL
9409: IFFALSE 9419
// sTiger := true ;
9411: LD_ADDR_EXP 39
9415: PUSH
9416: LD_INT 1
9418: ST_TO_ADDR
// if p3 = 107 then
9419: LD_VAR 0 3
9423: PUSH
9424: LD_INT 107
9426: EQUAL
9427: IFFALSE 9437
// sBomb := true ;
9429: LD_ADDR_EXP 40
9433: PUSH
9434: LD_INT 1
9436: ST_TO_ADDR
// if p3 = 108 then
9437: LD_VAR 0 3
9441: PUSH
9442: LD_INT 108
9444: EQUAL
9445: IFFALSE 9455
// sWound := true ;
9447: LD_ADDR_EXP 48
9451: PUSH
9452: LD_INT 1
9454: ST_TO_ADDR
// if p3 = 109 then
9455: LD_VAR 0 3
9459: PUSH
9460: LD_INT 109
9462: EQUAL
9463: IFFALSE 9473
// sBetray := true ;
9465: LD_ADDR_EXP 52
9469: PUSH
9470: LD_INT 1
9472: ST_TO_ADDR
// if p3 = 110 then
9473: LD_VAR 0 3
9477: PUSH
9478: LD_INT 110
9480: EQUAL
9481: IFFALSE 9491
// sContamin := true ;
9483: LD_ADDR_EXP 53
9487: PUSH
9488: LD_INT 1
9490: ST_TO_ADDR
// if p3 = 111 then
9491: LD_VAR 0 3
9495: PUSH
9496: LD_INT 111
9498: EQUAL
9499: IFFALSE 9509
// sOil := true ;
9501: LD_ADDR_EXP 55
9505: PUSH
9506: LD_INT 1
9508: ST_TO_ADDR
// if p3 = 112 then
9509: LD_VAR 0 3
9513: PUSH
9514: LD_INT 112
9516: EQUAL
9517: IFFALSE 9527
// sStu := true ;
9519: LD_ADDR_EXP 59
9523: PUSH
9524: LD_INT 1
9526: ST_TO_ADDR
// if p3 = 113 then
9527: LD_VAR 0 3
9531: PUSH
9532: LD_INT 113
9534: EQUAL
9535: IFFALSE 9545
// sBazooka := true ;
9537: LD_ADDR_EXP 62
9541: PUSH
9542: LD_INT 1
9544: ST_TO_ADDR
// if p3 = 114 then
9545: LD_VAR 0 3
9549: PUSH
9550: LD_INT 114
9552: EQUAL
9553: IFFALSE 9563
// sMortar := true ;
9555: LD_ADDR_EXP 63
9559: PUSH
9560: LD_INT 1
9562: ST_TO_ADDR
// if p3 = 115 then
9563: LD_VAR 0 3
9567: PUSH
9568: LD_INT 115
9570: EQUAL
9571: IFFALSE 9581
// sRanger := true ;
9573: LD_ADDR_EXP 73
9577: PUSH
9578: LD_INT 1
9580: ST_TO_ADDR
// end ; end ;
9581: PPOPN 6
9583: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
9584: LD_EXP 20
9588: PUSH
9589: LD_EXP 25
9593: AND
9594: IFFALSE 9718
9596: GO 9598
9598: DISABLE
9599: LD_INT 0
9601: PPUSH
9602: PPUSH
// begin enable ;
9603: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
9604: LD_ADDR_VAR 0 2
9608: PUSH
9609: LD_INT 22
9611: PUSH
9612: LD_OWVAR 2
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: LD_INT 2
9623: PUSH
9624: LD_INT 34
9626: PUSH
9627: LD_INT 7
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 34
9636: PUSH
9637: LD_INT 45
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PUSH
9644: LD_INT 34
9646: PUSH
9647: LD_INT 28
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: LD_INT 34
9656: PUSH
9657: LD_INT 47
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: LIST
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PPUSH
9675: CALL_OW 69
9679: ST_TO_ADDR
// if not tmp then
9680: LD_VAR 0 2
9684: NOT
9685: IFFALSE 9689
// exit ;
9687: GO 9718
// for i in tmp do
9689: LD_ADDR_VAR 0 1
9693: PUSH
9694: LD_VAR 0 2
9698: PUSH
9699: FOR_IN
9700: IFFALSE 9716
// begin SetLives ( i , 0 ) ;
9702: LD_VAR 0 1
9706: PPUSH
9707: LD_INT 0
9709: PPUSH
9710: CALL_OW 234
// end ;
9714: GO 9699
9716: POP
9717: POP
// end ;
9718: PPOPN 2
9720: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
9721: LD_EXP 20
9725: PUSH
9726: LD_EXP 26
9730: AND
9731: IFFALSE 9815
9733: GO 9735
9735: DISABLE
9736: LD_INT 0
9738: PPUSH
9739: PPUSH
// begin enable ;
9740: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9741: LD_ADDR_VAR 0 2
9745: PUSH
9746: LD_INT 22
9748: PUSH
9749: LD_OWVAR 2
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PUSH
9758: LD_INT 32
9760: PUSH
9761: LD_INT 3
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PPUSH
9772: CALL_OW 69
9776: ST_TO_ADDR
// if not tmp then
9777: LD_VAR 0 2
9781: NOT
9782: IFFALSE 9786
// exit ;
9784: GO 9815
// for i in tmp do
9786: LD_ADDR_VAR 0 1
9790: PUSH
9791: LD_VAR 0 2
9795: PUSH
9796: FOR_IN
9797: IFFALSE 9813
// begin SetLives ( i , 0 ) ;
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 0
9806: PPUSH
9807: CALL_OW 234
// end ;
9811: GO 9796
9813: POP
9814: POP
// end ;
9815: PPOPN 2
9817: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9818: LD_EXP 20
9822: PUSH
9823: LD_EXP 23
9827: AND
9828: IFFALSE 9921
9830: GO 9832
9832: DISABLE
9833: LD_INT 0
9835: PPUSH
// begin enable ;
9836: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9837: LD_ADDR_VAR 0 1
9841: PUSH
9842: LD_INT 22
9844: PUSH
9845: LD_OWVAR 2
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 2
9856: PUSH
9857: LD_INT 25
9859: PUSH
9860: LD_INT 5
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PUSH
9867: LD_INT 25
9869: PUSH
9870: LD_INT 9
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: LD_INT 25
9879: PUSH
9880: LD_INT 8
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: LIST
9891: LIST
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: PPUSH
9897: CALL_OW 69
9901: PUSH
9902: FOR_IN
9903: IFFALSE 9919
// begin SetClass ( i , 1 ) ;
9905: LD_VAR 0 1
9909: PPUSH
9910: LD_INT 1
9912: PPUSH
9913: CALL_OW 336
// end ;
9917: GO 9902
9919: POP
9920: POP
// end ;
9921: PPOPN 1
9923: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9924: LD_EXP 20
9928: PUSH
9929: LD_EXP 24
9933: AND
9934: PUSH
9935: LD_OWVAR 65
9939: PUSH
9940: LD_INT 7
9942: LESS
9943: AND
9944: IFFALSE 9958
9946: GO 9948
9948: DISABLE
// begin enable ;
9949: ENABLE
// game_speed := 7 ;
9950: LD_ADDR_OWVAR 65
9954: PUSH
9955: LD_INT 7
9957: ST_TO_ADDR
// end ;
9958: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9959: LD_EXP 20
9963: PUSH
9964: LD_EXP 27
9968: AND
9969: IFFALSE 10171
9971: GO 9973
9973: DISABLE
9974: LD_INT 0
9976: PPUSH
9977: PPUSH
9978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9979: LD_ADDR_VAR 0 3
9983: PUSH
9984: LD_INT 81
9986: PUSH
9987: LD_OWVAR 2
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 21
9998: PUSH
9999: LD_INT 1
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PPUSH
10010: CALL_OW 69
10014: ST_TO_ADDR
// if not tmp then
10015: LD_VAR 0 3
10019: NOT
10020: IFFALSE 10024
// exit ;
10022: GO 10171
// if tmp > 5 then
10024: LD_VAR 0 3
10028: PUSH
10029: LD_INT 5
10031: GREATER
10032: IFFALSE 10044
// k := 5 else
10034: LD_ADDR_VAR 0 2
10038: PUSH
10039: LD_INT 5
10041: ST_TO_ADDR
10042: GO 10054
// k := tmp ;
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: LD_VAR 0 3
10053: ST_TO_ADDR
// for i := 1 to k do
10054: LD_ADDR_VAR 0 1
10058: PUSH
10059: DOUBLE
10060: LD_INT 1
10062: DEC
10063: ST_TO_ADDR
10064: LD_VAR 0 2
10068: PUSH
10069: FOR_TO
10070: IFFALSE 10169
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
10072: LD_VAR 0 3
10076: PUSH
10077: LD_VAR 0 1
10081: ARRAY
10082: PPUSH
10083: LD_VAR 0 1
10087: PUSH
10088: LD_INT 4
10090: MOD
10091: PUSH
10092: LD_INT 1
10094: PLUS
10095: PPUSH
10096: CALL_OW 259
10100: PUSH
10101: LD_INT 10
10103: LESS
10104: IFFALSE 10167
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
10106: LD_VAR 0 3
10110: PUSH
10111: LD_VAR 0 1
10115: ARRAY
10116: PPUSH
10117: LD_VAR 0 1
10121: PUSH
10122: LD_INT 4
10124: MOD
10125: PUSH
10126: LD_INT 1
10128: PLUS
10129: PPUSH
10130: LD_VAR 0 3
10134: PUSH
10135: LD_VAR 0 1
10139: ARRAY
10140: PPUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: MOD
10149: PUSH
10150: LD_INT 1
10152: PLUS
10153: PPUSH
10154: CALL_OW 259
10158: PUSH
10159: LD_INT 1
10161: PLUS
10162: PPUSH
10163: CALL_OW 237
10167: GO 10069
10169: POP
10170: POP
// end ;
10171: PPOPN 3
10173: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
10174: LD_EXP 20
10178: PUSH
10179: LD_EXP 28
10183: AND
10184: IFFALSE 10204
10186: GO 10188
10188: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
10189: LD_INT 4
10191: PPUSH
10192: LD_OWVAR 2
10196: PPUSH
10197: LD_INT 0
10199: PPUSH
10200: CALL_OW 324
10204: END
// every 0 0$1 trigger StreamModeActive and sShovel do
10205: LD_EXP 20
10209: PUSH
10210: LD_EXP 57
10214: AND
10215: IFFALSE 10235
10217: GO 10219
10219: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
10220: LD_INT 19
10222: PPUSH
10223: LD_OWVAR 2
10227: PPUSH
10228: LD_INT 0
10230: PPUSH
10231: CALL_OW 324
10235: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
10236: LD_EXP 20
10240: PUSH
10241: LD_EXP 29
10245: AND
10246: IFFALSE 10348
10248: GO 10250
10250: DISABLE
10251: LD_INT 0
10253: PPUSH
10254: PPUSH
// begin enable ;
10255: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
10256: LD_ADDR_VAR 0 2
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_OWVAR 2
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: PUSH
10273: LD_INT 2
10275: PUSH
10276: LD_INT 34
10278: PUSH
10279: LD_INT 11
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PUSH
10286: LD_INT 34
10288: PUSH
10289: LD_INT 30
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL_OW 69
10309: ST_TO_ADDR
// if not tmp then
10310: LD_VAR 0 2
10314: NOT
10315: IFFALSE 10319
// exit ;
10317: GO 10348
// for i in tmp do
10319: LD_ADDR_VAR 0 1
10323: PUSH
10324: LD_VAR 0 2
10328: PUSH
10329: FOR_IN
10330: IFFALSE 10346
// begin SetLives ( i , 0 ) ;
10332: LD_VAR 0 1
10336: PPUSH
10337: LD_INT 0
10339: PPUSH
10340: CALL_OW 234
// end ;
10344: GO 10329
10346: POP
10347: POP
// end ;
10348: PPOPN 2
10350: END
// every 0 0$1 trigger StreamModeActive and sBunker do
10351: LD_EXP 20
10355: PUSH
10356: LD_EXP 30
10360: AND
10361: IFFALSE 10381
10363: GO 10365
10365: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
10366: LD_INT 32
10368: PPUSH
10369: LD_OWVAR 2
10373: PPUSH
10374: LD_INT 0
10376: PPUSH
10377: CALL_OW 324
10381: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
10382: LD_EXP 20
10386: PUSH
10387: LD_EXP 31
10391: AND
10392: IFFALSE 10573
10394: GO 10396
10396: DISABLE
10397: LD_INT 0
10399: PPUSH
10400: PPUSH
10401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
10402: LD_ADDR_VAR 0 2
10406: PUSH
10407: LD_INT 22
10409: PUSH
10410: LD_OWVAR 2
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 33
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: EMPTY
10430: LIST
10431: LIST
10432: PPUSH
10433: CALL_OW 69
10437: ST_TO_ADDR
// if not tmp then
10438: LD_VAR 0 2
10442: NOT
10443: IFFALSE 10447
// exit ;
10445: GO 10573
// side := 0 ;
10447: LD_ADDR_VAR 0 3
10451: PUSH
10452: LD_INT 0
10454: ST_TO_ADDR
// for i := 1 to 8 do
10455: LD_ADDR_VAR 0 1
10459: PUSH
10460: DOUBLE
10461: LD_INT 1
10463: DEC
10464: ST_TO_ADDR
10465: LD_INT 8
10467: PUSH
10468: FOR_TO
10469: IFFALSE 10517
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
10471: LD_OWVAR 2
10475: PUSH
10476: LD_VAR 0 1
10480: NONEQUAL
10481: PUSH
10482: LD_OWVAR 2
10486: PPUSH
10487: LD_VAR 0 1
10491: PPUSH
10492: CALL_OW 81
10496: PUSH
10497: LD_INT 2
10499: EQUAL
10500: AND
10501: IFFALSE 10515
// begin side := i ;
10503: LD_ADDR_VAR 0 3
10507: PUSH
10508: LD_VAR 0 1
10512: ST_TO_ADDR
// break ;
10513: GO 10517
// end ;
10515: GO 10468
10517: POP
10518: POP
// if not side then
10519: LD_VAR 0 3
10523: NOT
10524: IFFALSE 10528
// exit ;
10526: GO 10573
// for i := 1 to tmp do
10528: LD_ADDR_VAR 0 1
10532: PUSH
10533: DOUBLE
10534: LD_INT 1
10536: DEC
10537: ST_TO_ADDR
10538: LD_VAR 0 2
10542: PUSH
10543: FOR_TO
10544: IFFALSE 10571
// if Prob ( 60 ) then
10546: LD_INT 60
10548: PPUSH
10549: CALL_OW 13
10553: IFFALSE 10569
// SetSide ( i , side ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: LD_VAR 0 3
10564: PPUSH
10565: CALL_OW 235
10569: GO 10543
10571: POP
10572: POP
// end ;
10573: PPOPN 3
10575: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
10576: LD_EXP 20
10580: PUSH
10581: LD_EXP 33
10585: AND
10586: IFFALSE 10705
10588: GO 10590
10590: DISABLE
10591: LD_INT 0
10593: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
10594: LD_ADDR_VAR 0 1
10598: PUSH
10599: LD_INT 22
10601: PUSH
10602: LD_OWVAR 2
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 21
10613: PUSH
10614: LD_INT 1
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 3
10623: PUSH
10624: LD_INT 23
10626: PUSH
10627: LD_INT 0
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 69
10647: PUSH
10648: FOR_IN
10649: IFFALSE 10703
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
10651: LD_VAR 0 1
10655: PPUSH
10656: CALL_OW 257
10660: PUSH
10661: LD_INT 1
10663: PUSH
10664: LD_INT 2
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: LD_INT 4
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: LIST
10677: LIST
10678: IN
10679: IFFALSE 10701
// SetClass ( un , rand ( 1 , 4 ) ) ;
10681: LD_VAR 0 1
10685: PPUSH
10686: LD_INT 1
10688: PPUSH
10689: LD_INT 4
10691: PPUSH
10692: CALL_OW 12
10696: PPUSH
10697: CALL_OW 336
10701: GO 10648
10703: POP
10704: POP
// end ;
10705: PPOPN 1
10707: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
10708: LD_EXP 20
10712: PUSH
10713: LD_EXP 32
10717: AND
10718: IFFALSE 10797
10720: GO 10722
10722: DISABLE
10723: LD_INT 0
10725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_OWVAR 2
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: LD_INT 21
10745: PUSH
10746: LD_INT 3
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: ST_TO_ADDR
// if not tmp then
10762: LD_VAR 0 1
10766: NOT
10767: IFFALSE 10771
// exit ;
10769: GO 10797
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10771: LD_VAR 0 1
10775: PUSH
10776: LD_INT 1
10778: PPUSH
10779: LD_VAR 0 1
10783: PPUSH
10784: CALL_OW 12
10788: ARRAY
10789: PPUSH
10790: LD_INT 100
10792: PPUSH
10793: CALL_OW 234
// end ;
10797: PPOPN 1
10799: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10800: LD_EXP 20
10804: PUSH
10805: LD_EXP 34
10809: AND
10810: IFFALSE 10908
10812: GO 10814
10814: DISABLE
10815: LD_INT 0
10817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10818: LD_ADDR_VAR 0 1
10822: PUSH
10823: LD_INT 22
10825: PUSH
10826: LD_OWVAR 2
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: PUSH
10835: LD_INT 21
10837: PUSH
10838: LD_INT 1
10840: PUSH
10841: EMPTY
10842: LIST
10843: LIST
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: PPUSH
10849: CALL_OW 69
10853: ST_TO_ADDR
// if not tmp then
10854: LD_VAR 0 1
10858: NOT
10859: IFFALSE 10863
// exit ;
10861: GO 10908
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10863: LD_VAR 0 1
10867: PUSH
10868: LD_INT 1
10870: PPUSH
10871: LD_VAR 0 1
10875: PPUSH
10876: CALL_OW 12
10880: ARRAY
10881: PPUSH
10882: LD_INT 1
10884: PPUSH
10885: LD_INT 4
10887: PPUSH
10888: CALL_OW 12
10892: PPUSH
10893: LD_INT 3000
10895: PPUSH
10896: LD_INT 9000
10898: PPUSH
10899: CALL_OW 12
10903: PPUSH
10904: CALL_OW 492
// end ;
10908: PPOPN 1
10910: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10911: LD_EXP 20
10915: PUSH
10916: LD_EXP 35
10920: AND
10921: IFFALSE 10941
10923: GO 10925
10925: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10926: LD_INT 1
10928: PPUSH
10929: LD_OWVAR 2
10933: PPUSH
10934: LD_INT 0
10936: PPUSH
10937: CALL_OW 324
10941: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10942: LD_EXP 20
10946: PUSH
10947: LD_EXP 36
10951: AND
10952: IFFALSE 11035
10954: GO 10956
10956: DISABLE
10957: LD_INT 0
10959: PPUSH
10960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10961: LD_ADDR_VAR 0 2
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_OWVAR 2
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PUSH
10978: LD_INT 21
10980: PUSH
10981: LD_INT 3
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: PUSH
10988: EMPTY
10989: LIST
10990: LIST
10991: PPUSH
10992: CALL_OW 69
10996: ST_TO_ADDR
// if not tmp then
10997: LD_VAR 0 2
11001: NOT
11002: IFFALSE 11006
// exit ;
11004: GO 11035
// for i in tmp do
11006: LD_ADDR_VAR 0 1
11010: PUSH
11011: LD_VAR 0 2
11015: PUSH
11016: FOR_IN
11017: IFFALSE 11033
// SetBLevel ( i , 10 ) ;
11019: LD_VAR 0 1
11023: PPUSH
11024: LD_INT 10
11026: PPUSH
11027: CALL_OW 241
11031: GO 11016
11033: POP
11034: POP
// end ;
11035: PPOPN 2
11037: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
11038: LD_EXP 20
11042: PUSH
11043: LD_EXP 37
11047: AND
11048: IFFALSE 11159
11050: GO 11052
11052: DISABLE
11053: LD_INT 0
11055: PPUSH
11056: PPUSH
11057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11058: LD_ADDR_VAR 0 3
11062: PUSH
11063: LD_INT 22
11065: PUSH
11066: LD_OWVAR 2
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 25
11077: PUSH
11078: LD_INT 1
11080: PUSH
11081: EMPTY
11082: LIST
11083: LIST
11084: PUSH
11085: EMPTY
11086: LIST
11087: LIST
11088: PPUSH
11089: CALL_OW 69
11093: ST_TO_ADDR
// if not tmp then
11094: LD_VAR 0 3
11098: NOT
11099: IFFALSE 11103
// exit ;
11101: GO 11159
// un := tmp [ rand ( 1 , tmp ) ] ;
11103: LD_ADDR_VAR 0 2
11107: PUSH
11108: LD_VAR 0 3
11112: PUSH
11113: LD_INT 1
11115: PPUSH
11116: LD_VAR 0 3
11120: PPUSH
11121: CALL_OW 12
11125: ARRAY
11126: ST_TO_ADDR
// if Crawls ( un ) then
11127: LD_VAR 0 2
11131: PPUSH
11132: CALL_OW 318
11136: IFFALSE 11147
// ComWalk ( un ) ;
11138: LD_VAR 0 2
11142: PPUSH
11143: CALL_OW 138
// SetClass ( un , class_sniper ) ;
11147: LD_VAR 0 2
11151: PPUSH
11152: LD_INT 5
11154: PPUSH
11155: CALL_OW 336
// end ;
11159: PPOPN 3
11161: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
11162: LD_EXP 20
11166: PUSH
11167: LD_EXP 38
11171: AND
11172: PUSH
11173: LD_OWVAR 67
11177: PUSH
11178: LD_INT 3
11180: LESS
11181: AND
11182: IFFALSE 11201
11184: GO 11186
11186: DISABLE
// Difficulty := Difficulty + 1 ;
11187: LD_ADDR_OWVAR 67
11191: PUSH
11192: LD_OWVAR 67
11196: PUSH
11197: LD_INT 1
11199: PLUS
11200: ST_TO_ADDR
11201: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
11202: LD_EXP 20
11206: PUSH
11207: LD_EXP 39
11211: AND
11212: IFFALSE 11315
11214: GO 11216
11216: DISABLE
11217: LD_INT 0
11219: PPUSH
// begin for i := 1 to 5 do
11220: LD_ADDR_VAR 0 1
11224: PUSH
11225: DOUBLE
11226: LD_INT 1
11228: DEC
11229: ST_TO_ADDR
11230: LD_INT 5
11232: PUSH
11233: FOR_TO
11234: IFFALSE 11313
// begin uc_nation := nation_nature ;
11236: LD_ADDR_OWVAR 21
11240: PUSH
11241: LD_INT 0
11243: ST_TO_ADDR
// uc_side := 0 ;
11244: LD_ADDR_OWVAR 20
11248: PUSH
11249: LD_INT 0
11251: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11252: LD_ADDR_OWVAR 29
11256: PUSH
11257: LD_INT 12
11259: PUSH
11260: LD_INT 12
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: ST_TO_ADDR
// hc_agressivity := 20 ;
11267: LD_ADDR_OWVAR 35
11271: PUSH
11272: LD_INT 20
11274: ST_TO_ADDR
// hc_class := class_tiger ;
11275: LD_ADDR_OWVAR 28
11279: PUSH
11280: LD_INT 14
11282: ST_TO_ADDR
// hc_gallery :=  ;
11283: LD_ADDR_OWVAR 33
11287: PUSH
11288: LD_STRING 
11290: ST_TO_ADDR
// hc_name :=  ;
11291: LD_ADDR_OWVAR 26
11295: PUSH
11296: LD_STRING 
11298: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
11299: CALL_OW 44
11303: PPUSH
11304: LD_INT 0
11306: PPUSH
11307: CALL_OW 51
// end ;
11311: GO 11233
11313: POP
11314: POP
// end ;
11315: PPOPN 1
11317: END
// every 0 0$1 trigger StreamModeActive and sBomb do
11318: LD_EXP 20
11322: PUSH
11323: LD_EXP 40
11327: AND
11328: IFFALSE 11337
11330: GO 11332
11332: DISABLE
// StreamSibBomb ;
11333: CALL 11338 0 0
11337: END
// export function StreamSibBomb ; var i , x , y ; begin
11338: LD_INT 0
11340: PPUSH
11341: PPUSH
11342: PPUSH
11343: PPUSH
// result := false ;
11344: LD_ADDR_VAR 0 1
11348: PUSH
11349: LD_INT 0
11351: ST_TO_ADDR
// for i := 1 to 16 do
11352: LD_ADDR_VAR 0 2
11356: PUSH
11357: DOUBLE
11358: LD_INT 1
11360: DEC
11361: ST_TO_ADDR
11362: LD_INT 16
11364: PUSH
11365: FOR_TO
11366: IFFALSE 11565
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
11368: LD_ADDR_VAR 0 3
11372: PUSH
11373: LD_INT 10
11375: PUSH
11376: LD_INT 20
11378: PUSH
11379: LD_INT 30
11381: PUSH
11382: LD_INT 40
11384: PUSH
11385: LD_INT 50
11387: PUSH
11388: LD_INT 60
11390: PUSH
11391: LD_INT 70
11393: PUSH
11394: LD_INT 80
11396: PUSH
11397: LD_INT 90
11399: PUSH
11400: LD_INT 100
11402: PUSH
11403: LD_INT 110
11405: PUSH
11406: LD_INT 120
11408: PUSH
11409: LD_INT 130
11411: PUSH
11412: LD_INT 140
11414: PUSH
11415: LD_INT 150
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: PUSH
11435: LD_INT 1
11437: PPUSH
11438: LD_INT 15
11440: PPUSH
11441: CALL_OW 12
11445: ARRAY
11446: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
11447: LD_ADDR_VAR 0 4
11451: PUSH
11452: LD_INT 10
11454: PUSH
11455: LD_INT 20
11457: PUSH
11458: LD_INT 30
11460: PUSH
11461: LD_INT 40
11463: PUSH
11464: LD_INT 50
11466: PUSH
11467: LD_INT 60
11469: PUSH
11470: LD_INT 70
11472: PUSH
11473: LD_INT 80
11475: PUSH
11476: LD_INT 90
11478: PUSH
11479: LD_INT 100
11481: PUSH
11482: LD_INT 110
11484: PUSH
11485: LD_INT 120
11487: PUSH
11488: LD_INT 130
11490: PUSH
11491: LD_INT 140
11493: PUSH
11494: LD_INT 150
11496: PUSH
11497: EMPTY
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: PUSH
11514: LD_INT 1
11516: PPUSH
11517: LD_INT 15
11519: PPUSH
11520: CALL_OW 12
11524: ARRAY
11525: ST_TO_ADDR
// if ValidHex ( x , y ) then
11526: LD_VAR 0 3
11530: PPUSH
11531: LD_VAR 0 4
11535: PPUSH
11536: CALL_OW 488
11540: IFFALSE 11563
// begin result := [ x , y ] ;
11542: LD_ADDR_VAR 0 1
11546: PUSH
11547: LD_VAR 0 3
11551: PUSH
11552: LD_VAR 0 4
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: ST_TO_ADDR
// break ;
11561: GO 11565
// end ; end ;
11563: GO 11365
11565: POP
11566: POP
// if result then
11567: LD_VAR 0 1
11571: IFFALSE 11631
// begin ToLua ( playSibBomb() ) ;
11573: LD_STRING playSibBomb()
11575: PPUSH
11576: CALL_OW 559
// wait ( 0 0$14 ) ;
11580: LD_INT 490
11582: PPUSH
11583: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
11587: LD_VAR 0 1
11591: PUSH
11592: LD_INT 1
11594: ARRAY
11595: PPUSH
11596: LD_VAR 0 1
11600: PUSH
11601: LD_INT 2
11603: ARRAY
11604: PPUSH
11605: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
11609: LD_VAR 0 1
11613: PUSH
11614: LD_INT 1
11616: ARRAY
11617: PPUSH
11618: LD_VAR 0 1
11622: PUSH
11623: LD_INT 2
11625: ARRAY
11626: PPUSH
11627: CALL_OW 429
// end ; end ;
11631: LD_VAR 0 1
11635: RET
// every 0 0$1 trigger StreamModeActive and sReset do
11636: LD_EXP 20
11640: PUSH
11641: LD_EXP 42
11645: AND
11646: IFFALSE 11658
11648: GO 11650
11650: DISABLE
// YouLost (  ) ;
11651: LD_STRING 
11653: PPUSH
11654: CALL_OW 104
11658: END
// every 0 0$1 trigger StreamModeActive and sFog do
11659: LD_EXP 20
11663: PUSH
11664: LD_EXP 41
11668: AND
11669: IFFALSE 11683
11671: GO 11673
11673: DISABLE
// FogOff ( your_side ) ;
11674: LD_OWVAR 2
11678: PPUSH
11679: CALL_OW 344
11683: END
// every 0 0$1 trigger StreamModeActive and sSun do
11684: LD_EXP 20
11688: PUSH
11689: LD_EXP 43
11693: AND
11694: IFFALSE 11722
11696: GO 11698
11698: DISABLE
// begin solar_recharge_percent := 0 ;
11699: LD_ADDR_OWVAR 79
11703: PUSH
11704: LD_INT 0
11706: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11707: LD_INT 10500
11709: PPUSH
11710: CALL_OW 67
// solar_recharge_percent := 100 ;
11714: LD_ADDR_OWVAR 79
11718: PUSH
11719: LD_INT 100
11721: ST_TO_ADDR
// end ;
11722: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
11723: LD_EXP 20
11727: PUSH
11728: LD_EXP 44
11732: AND
11733: IFFALSE 11972
11735: GO 11737
11737: DISABLE
11738: LD_INT 0
11740: PPUSH
11741: PPUSH
11742: PPUSH
// begin tmp := [ ] ;
11743: LD_ADDR_VAR 0 3
11747: PUSH
11748: EMPTY
11749: ST_TO_ADDR
// for i := 1 to 6 do
11750: LD_ADDR_VAR 0 1
11754: PUSH
11755: DOUBLE
11756: LD_INT 1
11758: DEC
11759: ST_TO_ADDR
11760: LD_INT 6
11762: PUSH
11763: FOR_TO
11764: IFFALSE 11869
// begin uc_nation := nation_nature ;
11766: LD_ADDR_OWVAR 21
11770: PUSH
11771: LD_INT 0
11773: ST_TO_ADDR
// uc_side := 0 ;
11774: LD_ADDR_OWVAR 20
11778: PUSH
11779: LD_INT 0
11781: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11782: LD_ADDR_OWVAR 29
11786: PUSH
11787: LD_INT 12
11789: PUSH
11790: LD_INT 12
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: ST_TO_ADDR
// hc_agressivity := 20 ;
11797: LD_ADDR_OWVAR 35
11801: PUSH
11802: LD_INT 20
11804: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11805: LD_ADDR_OWVAR 28
11809: PUSH
11810: LD_INT 17
11812: ST_TO_ADDR
// hc_gallery :=  ;
11813: LD_ADDR_OWVAR 33
11817: PUSH
11818: LD_STRING 
11820: ST_TO_ADDR
// hc_name :=  ;
11821: LD_ADDR_OWVAR 26
11825: PUSH
11826: LD_STRING 
11828: ST_TO_ADDR
// un := CreateHuman ;
11829: LD_ADDR_VAR 0 2
11833: PUSH
11834: CALL_OW 44
11838: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11839: LD_VAR 0 2
11843: PPUSH
11844: LD_INT 1
11846: PPUSH
11847: CALL_OW 51
// tmp := tmp ^ un ;
11851: LD_ADDR_VAR 0 3
11855: PUSH
11856: LD_VAR 0 3
11860: PUSH
11861: LD_VAR 0 2
11865: ADD
11866: ST_TO_ADDR
// end ;
11867: GO 11763
11869: POP
11870: POP
// repeat wait ( 0 0$1 ) ;
11871: LD_INT 35
11873: PPUSH
11874: CALL_OW 67
// for un in tmp do
11878: LD_ADDR_VAR 0 2
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: FOR_IN
11889: IFFALSE 11963
// begin if IsDead ( un ) then
11891: LD_VAR 0 2
11895: PPUSH
11896: CALL_OW 301
11900: IFFALSE 11920
// begin tmp := tmp diff un ;
11902: LD_ADDR_VAR 0 3
11906: PUSH
11907: LD_VAR 0 3
11911: PUSH
11912: LD_VAR 0 2
11916: DIFF
11917: ST_TO_ADDR
// continue ;
11918: GO 11888
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11920: LD_VAR 0 2
11924: PPUSH
11925: LD_INT 3
11927: PUSH
11928: LD_INT 22
11930: PUSH
11931: LD_INT 0
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: PPUSH
11947: LD_VAR 0 2
11951: PPUSH
11952: CALL_OW 74
11956: PPUSH
11957: CALL_OW 115
// end ;
11961: GO 11888
11963: POP
11964: POP
// until not tmp ;
11965: LD_VAR 0 3
11969: NOT
11970: IFFALSE 11871
// end ;
11972: PPOPN 3
11974: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11975: LD_EXP 20
11979: PUSH
11980: LD_EXP 45
11984: AND
11985: IFFALSE 12039
11987: GO 11989
11989: DISABLE
// begin ToLua ( displayTroll(); ) ;
11990: LD_STRING displayTroll();
11992: PPUSH
11993: CALL_OW 559
// wait ( 3 3$00 ) ;
11997: LD_INT 6300
11999: PPUSH
12000: CALL_OW 67
// ToLua ( hideTroll(); ) ;
12004: LD_STRING hideTroll();
12006: PPUSH
12007: CALL_OW 559
// wait ( 1 1$00 ) ;
12011: LD_INT 2100
12013: PPUSH
12014: CALL_OW 67
// ToLua ( displayTroll(); ) ;
12018: LD_STRING displayTroll();
12020: PPUSH
12021: CALL_OW 559
// wait ( 1 1$00 ) ;
12025: LD_INT 2100
12027: PPUSH
12028: CALL_OW 67
// ToLua ( hideTroll(); ) ;
12032: LD_STRING hideTroll();
12034: PPUSH
12035: CALL_OW 559
// end ;
12039: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
12040: LD_EXP 20
12044: PUSH
12045: LD_EXP 46
12049: AND
12050: IFFALSE 12113
12052: GO 12054
12054: DISABLE
12055: LD_INT 0
12057: PPUSH
// begin p := 0 ;
12058: LD_ADDR_VAR 0 1
12062: PUSH
12063: LD_INT 0
12065: ST_TO_ADDR
// repeat game_speed := 1 ;
12066: LD_ADDR_OWVAR 65
12070: PUSH
12071: LD_INT 1
12073: ST_TO_ADDR
// wait ( 0 0$1 ) ;
12074: LD_INT 35
12076: PPUSH
12077: CALL_OW 67
// p := p + 1 ;
12081: LD_ADDR_VAR 0 1
12085: PUSH
12086: LD_VAR 0 1
12090: PUSH
12091: LD_INT 1
12093: PLUS
12094: ST_TO_ADDR
// until p >= 60 ;
12095: LD_VAR 0 1
12099: PUSH
12100: LD_INT 60
12102: GREATEREQUAL
12103: IFFALSE 12066
// game_speed := 4 ;
12105: LD_ADDR_OWVAR 65
12109: PUSH
12110: LD_INT 4
12112: ST_TO_ADDR
// end ;
12113: PPOPN 1
12115: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
12116: LD_EXP 20
12120: PUSH
12121: LD_EXP 47
12125: AND
12126: IFFALSE 12272
12128: GO 12130
12130: DISABLE
12131: LD_INT 0
12133: PPUSH
12134: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12135: LD_ADDR_VAR 0 1
12139: PUSH
12140: LD_INT 22
12142: PUSH
12143: LD_OWVAR 2
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: PUSH
12152: LD_INT 2
12154: PUSH
12155: LD_INT 30
12157: PUSH
12158: LD_INT 0
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: PUSH
12165: LD_INT 30
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: LIST
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PPUSH
12184: CALL_OW 69
12188: ST_TO_ADDR
// if not depot then
12189: LD_VAR 0 1
12193: NOT
12194: IFFALSE 12198
// exit ;
12196: GO 12272
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
12198: LD_ADDR_VAR 0 2
12202: PUSH
12203: LD_VAR 0 1
12207: PUSH
12208: LD_INT 1
12210: PPUSH
12211: LD_VAR 0 1
12215: PPUSH
12216: CALL_OW 12
12220: ARRAY
12221: PPUSH
12222: CALL_OW 274
12226: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
12227: LD_VAR 0 2
12231: PPUSH
12232: LD_INT 1
12234: PPUSH
12235: LD_INT 0
12237: PPUSH
12238: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
12242: LD_VAR 0 2
12246: PPUSH
12247: LD_INT 2
12249: PPUSH
12250: LD_INT 0
12252: PPUSH
12253: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
12257: LD_VAR 0 2
12261: PPUSH
12262: LD_INT 3
12264: PPUSH
12265: LD_INT 0
12267: PPUSH
12268: CALL_OW 277
// end ;
12272: PPOPN 2
12274: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
12275: LD_EXP 20
12279: PUSH
12280: LD_EXP 48
12284: AND
12285: IFFALSE 12382
12287: GO 12289
12289: DISABLE
12290: LD_INT 0
12292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12293: LD_ADDR_VAR 0 1
12297: PUSH
12298: LD_INT 22
12300: PUSH
12301: LD_OWVAR 2
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: PUSH
12310: LD_INT 21
12312: PUSH
12313: LD_INT 1
12315: PUSH
12316: EMPTY
12317: LIST
12318: LIST
12319: PUSH
12320: LD_INT 3
12322: PUSH
12323: LD_INT 23
12325: PUSH
12326: LD_INT 0
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: LIST
12341: PPUSH
12342: CALL_OW 69
12346: ST_TO_ADDR
// if not tmp then
12347: LD_VAR 0 1
12351: NOT
12352: IFFALSE 12356
// exit ;
12354: GO 12382
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
12356: LD_VAR 0 1
12360: PUSH
12361: LD_INT 1
12363: PPUSH
12364: LD_VAR 0 1
12368: PPUSH
12369: CALL_OW 12
12373: ARRAY
12374: PPUSH
12375: LD_INT 200
12377: PPUSH
12378: CALL_OW 234
// end ;
12382: PPOPN 1
12384: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
12385: LD_EXP 20
12389: PUSH
12390: LD_EXP 49
12394: AND
12395: IFFALSE 12474
12397: GO 12399
12399: DISABLE
12400: LD_INT 0
12402: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
12403: LD_ADDR_VAR 0 1
12407: PUSH
12408: LD_INT 22
12410: PUSH
12411: LD_OWVAR 2
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: PUSH
12420: LD_INT 21
12422: PUSH
12423: LD_INT 2
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PPUSH
12434: CALL_OW 69
12438: ST_TO_ADDR
// if not tmp then
12439: LD_VAR 0 1
12443: NOT
12444: IFFALSE 12448
// exit ;
12446: GO 12474
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
12448: LD_VAR 0 1
12452: PUSH
12453: LD_INT 1
12455: PPUSH
12456: LD_VAR 0 1
12460: PPUSH
12461: CALL_OW 12
12465: ARRAY
12466: PPUSH
12467: LD_INT 60
12469: PPUSH
12470: CALL_OW 234
// end ;
12474: PPOPN 1
12476: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
12477: LD_EXP 20
12481: PUSH
12482: LD_EXP 50
12486: AND
12487: IFFALSE 12586
12489: GO 12491
12491: DISABLE
12492: LD_INT 0
12494: PPUSH
12495: PPUSH
// begin enable ;
12496: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
12497: LD_ADDR_VAR 0 1
12501: PUSH
12502: LD_INT 22
12504: PUSH
12505: LD_OWVAR 2
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PUSH
12514: LD_INT 61
12516: PUSH
12517: EMPTY
12518: LIST
12519: PUSH
12520: LD_INT 33
12522: PUSH
12523: LD_INT 2
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 69
12539: ST_TO_ADDR
// if not tmp then
12540: LD_VAR 0 1
12544: NOT
12545: IFFALSE 12549
// exit ;
12547: GO 12586
// for i in tmp do
12549: LD_ADDR_VAR 0 2
12553: PUSH
12554: LD_VAR 0 1
12558: PUSH
12559: FOR_IN
12560: IFFALSE 12584
// if IsControledBy ( i ) then
12562: LD_VAR 0 2
12566: PPUSH
12567: CALL_OW 312
12571: IFFALSE 12582
// ComUnlink ( i ) ;
12573: LD_VAR 0 2
12577: PPUSH
12578: CALL_OW 136
12582: GO 12559
12584: POP
12585: POP
// end ;
12586: PPOPN 2
12588: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
12589: LD_EXP 20
12593: PUSH
12594: LD_EXP 51
12598: AND
12599: IFFALSE 12739
12601: GO 12603
12603: DISABLE
12604: LD_INT 0
12606: PPUSH
12607: PPUSH
// begin ToLua ( displayPowell(); ) ;
12608: LD_STRING displayPowell();
12610: PPUSH
12611: CALL_OW 559
// uc_side := 0 ;
12615: LD_ADDR_OWVAR 20
12619: PUSH
12620: LD_INT 0
12622: ST_TO_ADDR
// uc_nation := 2 ;
12623: LD_ADDR_OWVAR 21
12627: PUSH
12628: LD_INT 2
12630: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
12631: LD_ADDR_OWVAR 37
12635: PUSH
12636: LD_INT 14
12638: ST_TO_ADDR
// vc_engine := engine_siberite ;
12639: LD_ADDR_OWVAR 39
12643: PUSH
12644: LD_INT 3
12646: ST_TO_ADDR
// vc_control := control_apeman ;
12647: LD_ADDR_OWVAR 38
12651: PUSH
12652: LD_INT 5
12654: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
12655: LD_ADDR_OWVAR 40
12659: PUSH
12660: LD_INT 29
12662: ST_TO_ADDR
// un := CreateVehicle ;
12663: LD_ADDR_VAR 0 2
12667: PUSH
12668: CALL_OW 45
12672: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12673: LD_VAR 0 2
12677: PPUSH
12678: LD_INT 1
12680: PPUSH
12681: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12685: LD_INT 35
12687: PPUSH
12688: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12692: LD_VAR 0 2
12696: PPUSH
12697: LD_INT 22
12699: PUSH
12700: LD_OWVAR 2
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: PPUSH
12709: CALL_OW 69
12713: PPUSH
12714: LD_VAR 0 2
12718: PPUSH
12719: CALL_OW 74
12723: PPUSH
12724: CALL_OW 115
// until IsDead ( un ) ;
12728: LD_VAR 0 2
12732: PPUSH
12733: CALL_OW 301
12737: IFFALSE 12685
// end ;
12739: PPOPN 2
12741: END
// every 0 0$1 trigger StreamModeActive and sStu do
12742: LD_EXP 20
12746: PUSH
12747: LD_EXP 59
12751: AND
12752: IFFALSE 12768
12754: GO 12756
12756: DISABLE
// begin ToLua ( displayStucuk(); ) ;
12757: LD_STRING displayStucuk();
12759: PPUSH
12760: CALL_OW 559
// ResetFog ;
12764: CALL_OW 335
// end ;
12768: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
12769: LD_EXP 20
12773: PUSH
12774: LD_EXP 52
12778: AND
12779: IFFALSE 12920
12781: GO 12783
12783: DISABLE
12784: LD_INT 0
12786: PPUSH
12787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12788: LD_ADDR_VAR 0 2
12792: PUSH
12793: LD_INT 22
12795: PUSH
12796: LD_OWVAR 2
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 21
12807: PUSH
12808: LD_INT 1
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: ST_TO_ADDR
// if not tmp then
12824: LD_VAR 0 2
12828: NOT
12829: IFFALSE 12833
// exit ;
12831: GO 12920
// un := tmp [ rand ( 1 , tmp ) ] ;
12833: LD_ADDR_VAR 0 1
12837: PUSH
12838: LD_VAR 0 2
12842: PUSH
12843: LD_INT 1
12845: PPUSH
12846: LD_VAR 0 2
12850: PPUSH
12851: CALL_OW 12
12855: ARRAY
12856: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12857: LD_VAR 0 1
12861: PPUSH
12862: LD_INT 0
12864: PPUSH
12865: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12869: LD_VAR 0 1
12873: PPUSH
12874: LD_OWVAR 3
12878: PUSH
12879: LD_VAR 0 1
12883: DIFF
12884: PPUSH
12885: LD_VAR 0 1
12889: PPUSH
12890: CALL_OW 74
12894: PPUSH
12895: CALL_OW 115
// wait ( 0 0$20 ) ;
12899: LD_INT 700
12901: PPUSH
12902: CALL_OW 67
// SetSide ( un , your_side ) ;
12906: LD_VAR 0 1
12910: PPUSH
12911: LD_OWVAR 2
12915: PPUSH
12916: CALL_OW 235
// end ;
12920: PPOPN 2
12922: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12923: LD_EXP 20
12927: PUSH
12928: LD_EXP 53
12932: AND
12933: IFFALSE 13039
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12941: LD_ADDR_VAR 0 1
12945: PUSH
12946: LD_INT 22
12948: PUSH
12949: LD_OWVAR 2
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PUSH
12958: LD_INT 2
12960: PUSH
12961: LD_INT 30
12963: PUSH
12964: LD_INT 0
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: LD_INT 30
12973: PUSH
12974: LD_INT 1
12976: PUSH
12977: EMPTY
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PPUSH
12990: CALL_OW 69
12994: ST_TO_ADDR
// if not depot then
12995: LD_VAR 0 1
12999: NOT
13000: IFFALSE 13004
// exit ;
13002: GO 13039
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
13004: LD_VAR 0 1
13008: PUSH
13009: LD_INT 1
13011: ARRAY
13012: PPUSH
13013: CALL_OW 250
13017: PPUSH
13018: LD_VAR 0 1
13022: PUSH
13023: LD_INT 1
13025: ARRAY
13026: PPUSH
13027: CALL_OW 251
13031: PPUSH
13032: LD_INT 70
13034: PPUSH
13035: CALL_OW 495
// end ;
13039: PPOPN 1
13041: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
13042: LD_EXP 20
13046: PUSH
13047: LD_EXP 54
13051: AND
13052: IFFALSE 13263
13054: GO 13056
13056: DISABLE
13057: LD_INT 0
13059: PPUSH
13060: PPUSH
13061: PPUSH
13062: PPUSH
13063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13064: LD_ADDR_VAR 0 5
13068: PUSH
13069: LD_INT 22
13071: PUSH
13072: LD_OWVAR 2
13076: PUSH
13077: EMPTY
13078: LIST
13079: LIST
13080: PUSH
13081: LD_INT 21
13083: PUSH
13084: LD_INT 1
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PPUSH
13095: CALL_OW 69
13099: ST_TO_ADDR
// if not tmp then
13100: LD_VAR 0 5
13104: NOT
13105: IFFALSE 13109
// exit ;
13107: GO 13263
// for i in tmp do
13109: LD_ADDR_VAR 0 1
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: FOR_IN
13120: IFFALSE 13261
// begin d := rand ( 0 , 5 ) ;
13122: LD_ADDR_VAR 0 4
13126: PUSH
13127: LD_INT 0
13129: PPUSH
13130: LD_INT 5
13132: PPUSH
13133: CALL_OW 12
13137: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
13138: LD_ADDR_VAR 0 2
13142: PUSH
13143: LD_VAR 0 1
13147: PPUSH
13148: CALL_OW 250
13152: PPUSH
13153: LD_VAR 0 4
13157: PPUSH
13158: LD_INT 3
13160: PPUSH
13161: LD_INT 12
13163: PPUSH
13164: CALL_OW 12
13168: PPUSH
13169: CALL_OW 272
13173: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 251
13188: PPUSH
13189: LD_VAR 0 4
13193: PPUSH
13194: LD_INT 3
13196: PPUSH
13197: LD_INT 12
13199: PPUSH
13200: CALL_OW 12
13204: PPUSH
13205: CALL_OW 273
13209: ST_TO_ADDR
// if ValidHex ( x , y ) then
13210: LD_VAR 0 2
13214: PPUSH
13215: LD_VAR 0 3
13219: PPUSH
13220: CALL_OW 488
13224: IFFALSE 13259
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
13226: LD_VAR 0 1
13230: PPUSH
13231: LD_VAR 0 2
13235: PPUSH
13236: LD_VAR 0 3
13240: PPUSH
13241: LD_INT 3
13243: PPUSH
13244: LD_INT 6
13246: PPUSH
13247: CALL_OW 12
13251: PPUSH
13252: LD_INT 1
13254: PPUSH
13255: CALL_OW 483
// end ;
13259: GO 13119
13261: POP
13262: POP
// end ;
13263: PPOPN 5
13265: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
13266: LD_EXP 20
13270: PUSH
13271: LD_EXP 55
13275: AND
13276: IFFALSE 13370
13278: GO 13280
13280: DISABLE
13281: LD_INT 0
13283: PPUSH
13284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
13285: LD_ADDR_VAR 0 2
13289: PUSH
13290: LD_INT 22
13292: PUSH
13293: LD_OWVAR 2
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: PUSH
13302: LD_INT 32
13304: PUSH
13305: LD_INT 1
13307: PUSH
13308: EMPTY
13309: LIST
13310: LIST
13311: PUSH
13312: LD_INT 21
13314: PUSH
13315: LD_INT 2
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: EMPTY
13323: LIST
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 69
13331: ST_TO_ADDR
// if not tmp then
13332: LD_VAR 0 2
13336: NOT
13337: IFFALSE 13341
// exit ;
13339: GO 13370
// for i in tmp do
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: LD_VAR 0 2
13350: PUSH
13351: FOR_IN
13352: IFFALSE 13368
// SetFuel ( i , 0 ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: LD_INT 0
13361: PPUSH
13362: CALL_OW 240
13366: GO 13351
13368: POP
13369: POP
// end ;
13370: PPOPN 2
13372: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
13373: LD_EXP 20
13377: PUSH
13378: LD_EXP 56
13382: AND
13383: IFFALSE 13449
13385: GO 13387
13387: DISABLE
13388: LD_INT 0
13390: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
13391: LD_ADDR_VAR 0 1
13395: PUSH
13396: LD_INT 22
13398: PUSH
13399: LD_OWVAR 2
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 30
13410: PUSH
13411: LD_INT 29
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PPUSH
13422: CALL_OW 69
13426: ST_TO_ADDR
// if not tmp then
13427: LD_VAR 0 1
13431: NOT
13432: IFFALSE 13436
// exit ;
13434: GO 13449
// DestroyUnit ( tmp [ 1 ] ) ;
13436: LD_VAR 0 1
13440: PUSH
13441: LD_INT 1
13443: ARRAY
13444: PPUSH
13445: CALL_OW 65
// end ;
13449: PPOPN 1
13451: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
13452: LD_EXP 20
13456: PUSH
13457: LD_EXP 58
13461: AND
13462: IFFALSE 13591
13464: GO 13466
13466: DISABLE
13467: LD_INT 0
13469: PPUSH
// begin uc_side := 0 ;
13470: LD_ADDR_OWVAR 20
13474: PUSH
13475: LD_INT 0
13477: ST_TO_ADDR
// uc_nation := nation_arabian ;
13478: LD_ADDR_OWVAR 21
13482: PUSH
13483: LD_INT 2
13485: ST_TO_ADDR
// hc_gallery :=  ;
13486: LD_ADDR_OWVAR 33
13490: PUSH
13491: LD_STRING 
13493: ST_TO_ADDR
// hc_name :=  ;
13494: LD_ADDR_OWVAR 26
13498: PUSH
13499: LD_STRING 
13501: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
13502: LD_INT 1
13504: PPUSH
13505: LD_INT 11
13507: PPUSH
13508: LD_INT 10
13510: PPUSH
13511: CALL_OW 380
// un := CreateHuman ;
13515: LD_ADDR_VAR 0 1
13519: PUSH
13520: CALL_OW 44
13524: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_INT 1
13532: PPUSH
13533: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
13537: LD_INT 35
13539: PPUSH
13540: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
13544: LD_VAR 0 1
13548: PPUSH
13549: LD_INT 22
13551: PUSH
13552: LD_OWVAR 2
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PPUSH
13561: CALL_OW 69
13565: PPUSH
13566: LD_VAR 0 1
13570: PPUSH
13571: CALL_OW 74
13575: PPUSH
13576: CALL_OW 115
// until IsDead ( un ) ;
13580: LD_VAR 0 1
13584: PPUSH
13585: CALL_OW 301
13589: IFFALSE 13537
// end ;
13591: PPOPN 1
13593: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
13594: LD_EXP 20
13598: PUSH
13599: LD_EXP 60
13603: AND
13604: IFFALSE 13616
13606: GO 13608
13608: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
13609: LD_STRING earthquake(getX(game), 0, 32)
13611: PPUSH
13612: CALL_OW 559
13616: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
13617: LD_EXP 20
13621: PUSH
13622: LD_EXP 61
13626: AND
13627: IFFALSE 13718
13629: GO 13631
13631: DISABLE
13632: LD_INT 0
13634: PPUSH
// begin enable ;
13635: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
13636: LD_ADDR_VAR 0 1
13640: PUSH
13641: LD_INT 22
13643: PUSH
13644: LD_OWVAR 2
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PUSH
13653: LD_INT 21
13655: PUSH
13656: LD_INT 2
13658: PUSH
13659: EMPTY
13660: LIST
13661: LIST
13662: PUSH
13663: LD_INT 33
13665: PUSH
13666: LD_INT 3
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: LIST
13677: PPUSH
13678: CALL_OW 69
13682: ST_TO_ADDR
// if not tmp then
13683: LD_VAR 0 1
13687: NOT
13688: IFFALSE 13692
// exit ;
13690: GO 13718
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13692: LD_VAR 0 1
13696: PUSH
13697: LD_INT 1
13699: PPUSH
13700: LD_VAR 0 1
13704: PPUSH
13705: CALL_OW 12
13709: ARRAY
13710: PPUSH
13711: LD_INT 1
13713: PPUSH
13714: CALL_OW 234
// end ;
13718: PPOPN 1
13720: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
13721: LD_EXP 20
13725: PUSH
13726: LD_EXP 62
13730: AND
13731: IFFALSE 13872
13733: GO 13735
13735: DISABLE
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13741: LD_ADDR_VAR 0 3
13745: PUSH
13746: LD_INT 22
13748: PUSH
13749: LD_OWVAR 2
13753: PUSH
13754: EMPTY
13755: LIST
13756: LIST
13757: PUSH
13758: LD_INT 25
13760: PUSH
13761: LD_INT 1
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PPUSH
13772: CALL_OW 69
13776: ST_TO_ADDR
// if not tmp then
13777: LD_VAR 0 3
13781: NOT
13782: IFFALSE 13786
// exit ;
13784: GO 13872
// un := tmp [ rand ( 1 , tmp ) ] ;
13786: LD_ADDR_VAR 0 2
13790: PUSH
13791: LD_VAR 0 3
13795: PUSH
13796: LD_INT 1
13798: PPUSH
13799: LD_VAR 0 3
13803: PPUSH
13804: CALL_OW 12
13808: ARRAY
13809: ST_TO_ADDR
// if Crawls ( un ) then
13810: LD_VAR 0 2
13814: PPUSH
13815: CALL_OW 318
13819: IFFALSE 13830
// ComWalk ( un ) ;
13821: LD_VAR 0 2
13825: PPUSH
13826: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
13830: LD_VAR 0 2
13834: PPUSH
13835: LD_INT 9
13837: PPUSH
13838: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
13842: LD_INT 28
13844: PPUSH
13845: LD_OWVAR 2
13849: PPUSH
13850: LD_INT 2
13852: PPUSH
13853: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
13857: LD_INT 29
13859: PPUSH
13860: LD_OWVAR 2
13864: PPUSH
13865: LD_INT 2
13867: PPUSH
13868: CALL_OW 322
// end ;
13872: PPOPN 3
13874: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
13875: LD_EXP 20
13879: PUSH
13880: LD_EXP 63
13884: AND
13885: IFFALSE 13996
13887: GO 13889
13889: DISABLE
13890: LD_INT 0
13892: PPUSH
13893: PPUSH
13894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13895: LD_ADDR_VAR 0 3
13899: PUSH
13900: LD_INT 22
13902: PUSH
13903: LD_OWVAR 2
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: PUSH
13912: LD_INT 25
13914: PUSH
13915: LD_INT 1
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PPUSH
13926: CALL_OW 69
13930: ST_TO_ADDR
// if not tmp then
13931: LD_VAR 0 3
13935: NOT
13936: IFFALSE 13940
// exit ;
13938: GO 13996
// un := tmp [ rand ( 1 , tmp ) ] ;
13940: LD_ADDR_VAR 0 2
13944: PUSH
13945: LD_VAR 0 3
13949: PUSH
13950: LD_INT 1
13952: PPUSH
13953: LD_VAR 0 3
13957: PPUSH
13958: CALL_OW 12
13962: ARRAY
13963: ST_TO_ADDR
// if Crawls ( un ) then
13964: LD_VAR 0 2
13968: PPUSH
13969: CALL_OW 318
13973: IFFALSE 13984
// ComWalk ( un ) ;
13975: LD_VAR 0 2
13979: PPUSH
13980: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13984: LD_VAR 0 2
13988: PPUSH
13989: LD_INT 8
13991: PPUSH
13992: CALL_OW 336
// end ;
13996: PPOPN 3
13998: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
13999: LD_EXP 20
14003: PUSH
14004: LD_EXP 64
14008: AND
14009: IFFALSE 14153
14011: GO 14013
14013: DISABLE
14014: LD_INT 0
14016: PPUSH
14017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
14018: LD_ADDR_VAR 0 2
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_OWVAR 2
14030: PUSH
14031: EMPTY
14032: LIST
14033: LIST
14034: PUSH
14035: LD_INT 21
14037: PUSH
14038: LD_INT 2
14040: PUSH
14041: EMPTY
14042: LIST
14043: LIST
14044: PUSH
14045: LD_INT 2
14047: PUSH
14048: LD_INT 34
14050: PUSH
14051: LD_INT 12
14053: PUSH
14054: EMPTY
14055: LIST
14056: LIST
14057: PUSH
14058: LD_INT 34
14060: PUSH
14061: LD_INT 51
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: PUSH
14068: LD_INT 34
14070: PUSH
14071: LD_INT 32
14073: PUSH
14074: EMPTY
14075: LIST
14076: LIST
14077: PUSH
14078: EMPTY
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: PPUSH
14089: CALL_OW 69
14093: ST_TO_ADDR
// if not tmp then
14094: LD_VAR 0 2
14098: NOT
14099: IFFALSE 14103
// exit ;
14101: GO 14153
// for i in tmp do
14103: LD_ADDR_VAR 0 1
14107: PUSH
14108: LD_VAR 0 2
14112: PUSH
14113: FOR_IN
14114: IFFALSE 14151
// if GetCargo ( i , mat_artifact ) = 0 then
14116: LD_VAR 0 1
14120: PPUSH
14121: LD_INT 4
14123: PPUSH
14124: CALL_OW 289
14128: PUSH
14129: LD_INT 0
14131: EQUAL
14132: IFFALSE 14149
// SetCargo ( i , mat_siberit , 100 ) ;
14134: LD_VAR 0 1
14138: PPUSH
14139: LD_INT 3
14141: PPUSH
14142: LD_INT 100
14144: PPUSH
14145: CALL_OW 290
14149: GO 14113
14151: POP
14152: POP
// end ;
14153: PPOPN 2
14155: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
14156: LD_EXP 20
14160: PUSH
14161: LD_EXP 65
14165: AND
14166: IFFALSE 14319
14168: GO 14170
14170: DISABLE
14171: LD_INT 0
14173: PPUSH
14174: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
14175: LD_ADDR_VAR 0 2
14179: PUSH
14180: LD_INT 22
14182: PUSH
14183: LD_OWVAR 2
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PPUSH
14192: CALL_OW 69
14196: ST_TO_ADDR
// if not tmp then
14197: LD_VAR 0 2
14201: NOT
14202: IFFALSE 14206
// exit ;
14204: GO 14319
// for i := 1 to 2 do
14206: LD_ADDR_VAR 0 1
14210: PUSH
14211: DOUBLE
14212: LD_INT 1
14214: DEC
14215: ST_TO_ADDR
14216: LD_INT 2
14218: PUSH
14219: FOR_TO
14220: IFFALSE 14317
// begin uc_side := your_side ;
14222: LD_ADDR_OWVAR 20
14226: PUSH
14227: LD_OWVAR 2
14231: ST_TO_ADDR
// uc_nation := nation_american ;
14232: LD_ADDR_OWVAR 21
14236: PUSH
14237: LD_INT 1
14239: ST_TO_ADDR
// vc_chassis := us_morphling ;
14240: LD_ADDR_OWVAR 37
14244: PUSH
14245: LD_INT 5
14247: ST_TO_ADDR
// vc_engine := engine_siberite ;
14248: LD_ADDR_OWVAR 39
14252: PUSH
14253: LD_INT 3
14255: ST_TO_ADDR
// vc_control := control_computer ;
14256: LD_ADDR_OWVAR 38
14260: PUSH
14261: LD_INT 3
14263: ST_TO_ADDR
// vc_weapon := us_double_laser ;
14264: LD_ADDR_OWVAR 40
14268: PUSH
14269: LD_INT 10
14271: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
14272: CALL_OW 45
14276: PPUSH
14277: LD_VAR 0 2
14281: PUSH
14282: LD_INT 1
14284: ARRAY
14285: PPUSH
14286: CALL_OW 250
14290: PPUSH
14291: LD_VAR 0 2
14295: PUSH
14296: LD_INT 1
14298: ARRAY
14299: PPUSH
14300: CALL_OW 251
14304: PPUSH
14305: LD_INT 12
14307: PPUSH
14308: LD_INT 1
14310: PPUSH
14311: CALL_OW 50
// end ;
14315: GO 14219
14317: POP
14318: POP
// end ;
14319: PPOPN 2
14321: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
14322: LD_EXP 20
14326: PUSH
14327: LD_EXP 66
14331: AND
14332: IFFALSE 14554
14334: GO 14336
14336: DISABLE
14337: LD_INT 0
14339: PPUSH
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14345: LD_ADDR_VAR 0 6
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_OWVAR 2
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 21
14364: PUSH
14365: LD_INT 1
14367: PUSH
14368: EMPTY
14369: LIST
14370: LIST
14371: PUSH
14372: LD_INT 3
14374: PUSH
14375: LD_INT 23
14377: PUSH
14378: LD_INT 0
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PUSH
14385: EMPTY
14386: LIST
14387: LIST
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: LIST
14393: PPUSH
14394: CALL_OW 69
14398: ST_TO_ADDR
// if not tmp then
14399: LD_VAR 0 6
14403: NOT
14404: IFFALSE 14408
// exit ;
14406: GO 14554
// s1 := rand ( 1 , 4 ) ;
14408: LD_ADDR_VAR 0 2
14412: PUSH
14413: LD_INT 1
14415: PPUSH
14416: LD_INT 4
14418: PPUSH
14419: CALL_OW 12
14423: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
14424: LD_ADDR_VAR 0 4
14428: PUSH
14429: LD_VAR 0 6
14433: PUSH
14434: LD_INT 1
14436: ARRAY
14437: PPUSH
14438: LD_VAR 0 2
14442: PPUSH
14443: CALL_OW 259
14447: ST_TO_ADDR
// if s1 = 1 then
14448: LD_VAR 0 2
14452: PUSH
14453: LD_INT 1
14455: EQUAL
14456: IFFALSE 14476
// s2 := rand ( 2 , 4 ) else
14458: LD_ADDR_VAR 0 3
14462: PUSH
14463: LD_INT 2
14465: PPUSH
14466: LD_INT 4
14468: PPUSH
14469: CALL_OW 12
14473: ST_TO_ADDR
14474: GO 14484
// s2 := 1 ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 1
14483: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
14484: LD_ADDR_VAR 0 5
14488: PUSH
14489: LD_VAR 0 6
14493: PUSH
14494: LD_INT 1
14496: ARRAY
14497: PPUSH
14498: LD_VAR 0 3
14502: PPUSH
14503: CALL_OW 259
14507: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
14508: LD_VAR 0 6
14512: PUSH
14513: LD_INT 1
14515: ARRAY
14516: PPUSH
14517: LD_VAR 0 2
14521: PPUSH
14522: LD_VAR 0 5
14526: PPUSH
14527: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
14531: LD_VAR 0 6
14535: PUSH
14536: LD_INT 1
14538: ARRAY
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: LD_VAR 0 4
14549: PPUSH
14550: CALL_OW 237
// end ;
14554: PPOPN 6
14556: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
14557: LD_EXP 20
14561: PUSH
14562: LD_EXP 67
14566: AND
14567: IFFALSE 14646
14569: GO 14571
14571: DISABLE
14572: LD_INT 0
14574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
14575: LD_ADDR_VAR 0 1
14579: PUSH
14580: LD_INT 22
14582: PUSH
14583: LD_OWVAR 2
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: PUSH
14592: LD_INT 30
14594: PUSH
14595: LD_INT 3
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PPUSH
14606: CALL_OW 69
14610: ST_TO_ADDR
// if not tmp then
14611: LD_VAR 0 1
14615: NOT
14616: IFFALSE 14620
// exit ;
14618: GO 14646
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
14620: LD_VAR 0 1
14624: PUSH
14625: LD_INT 1
14627: PPUSH
14628: LD_VAR 0 1
14632: PPUSH
14633: CALL_OW 12
14637: ARRAY
14638: PPUSH
14639: LD_INT 1
14641: PPUSH
14642: CALL_OW 234
// end ;
14646: PPOPN 1
14648: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
14649: LD_EXP 20
14653: PUSH
14654: LD_EXP 68
14658: AND
14659: IFFALSE 14771
14661: GO 14663
14663: DISABLE
14664: LD_INT 0
14666: PPUSH
14667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
14668: LD_ADDR_VAR 0 2
14672: PUSH
14673: LD_INT 22
14675: PUSH
14676: LD_OWVAR 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: LD_INT 2
14687: PUSH
14688: LD_INT 30
14690: PUSH
14691: LD_INT 27
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: LD_INT 30
14700: PUSH
14701: LD_INT 26
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: LD_INT 30
14710: PUSH
14711: LD_INT 28
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: ST_TO_ADDR
// if not tmp then
14733: LD_VAR 0 2
14737: NOT
14738: IFFALSE 14742
// exit ;
14740: GO 14771
// for i in tmp do
14742: LD_ADDR_VAR 0 1
14746: PUSH
14747: LD_VAR 0 2
14751: PUSH
14752: FOR_IN
14753: IFFALSE 14769
// SetLives ( i , 1 ) ;
14755: LD_VAR 0 1
14759: PPUSH
14760: LD_INT 1
14762: PPUSH
14763: CALL_OW 234
14767: GO 14752
14769: POP
14770: POP
// end ;
14771: PPOPN 2
14773: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
14774: LD_EXP 20
14778: PUSH
14779: LD_EXP 69
14783: AND
14784: IFFALSE 15058
14786: GO 14788
14788: DISABLE
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
// begin i := rand ( 1 , 7 ) ;
14794: LD_ADDR_VAR 0 1
14798: PUSH
14799: LD_INT 1
14801: PPUSH
14802: LD_INT 7
14804: PPUSH
14805: CALL_OW 12
14809: ST_TO_ADDR
// case i of 1 :
14810: LD_VAR 0 1
14814: PUSH
14815: LD_INT 1
14817: DOUBLE
14818: EQUAL
14819: IFTRUE 14823
14821: GO 14833
14823: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
14824: LD_STRING earthquake(getX(game), 0, 32)
14826: PPUSH
14827: CALL_OW 559
14831: GO 15058
14833: LD_INT 2
14835: DOUBLE
14836: EQUAL
14837: IFTRUE 14841
14839: GO 14855
14841: POP
// begin ToLua ( displayStucuk(); ) ;
14842: LD_STRING displayStucuk();
14844: PPUSH
14845: CALL_OW 559
// ResetFog ;
14849: CALL_OW 335
// end ; 3 :
14853: GO 15058
14855: LD_INT 3
14857: DOUBLE
14858: EQUAL
14859: IFTRUE 14863
14861: GO 14967
14863: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14864: LD_ADDR_VAR 0 2
14868: PUSH
14869: LD_INT 22
14871: PUSH
14872: LD_OWVAR 2
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 25
14883: PUSH
14884: LD_INT 1
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PPUSH
14895: CALL_OW 69
14899: ST_TO_ADDR
// if not tmp then
14900: LD_VAR 0 2
14904: NOT
14905: IFFALSE 14909
// exit ;
14907: GO 15058
// un := tmp [ rand ( 1 , tmp ) ] ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 2
14918: PUSH
14919: LD_INT 1
14921: PPUSH
14922: LD_VAR 0 2
14926: PPUSH
14927: CALL_OW 12
14931: ARRAY
14932: ST_TO_ADDR
// if Crawls ( un ) then
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 318
14942: IFFALSE 14953
// ComWalk ( un ) ;
14944: LD_VAR 0 3
14948: PPUSH
14949: CALL_OW 138
// SetClass ( un , class_mortar ) ;
14953: LD_VAR 0 3
14957: PPUSH
14958: LD_INT 8
14960: PPUSH
14961: CALL_OW 336
// end ; 4 :
14965: GO 15058
14967: LD_INT 4
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 15036
14975: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14976: LD_ADDR_VAR 0 2
14980: PUSH
14981: LD_INT 22
14983: PUSH
14984: LD_OWVAR 2
14988: PUSH
14989: EMPTY
14990: LIST
14991: LIST
14992: PUSH
14993: LD_INT 30
14995: PUSH
14996: LD_INT 29
14998: PUSH
14999: EMPTY
15000: LIST
15001: LIST
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PPUSH
15007: CALL_OW 69
15011: ST_TO_ADDR
// if not tmp then
15012: LD_VAR 0 2
15016: NOT
15017: IFFALSE 15021
// exit ;
15019: GO 15058
// DestroyUnit ( tmp [ 1 ] ) ;
15021: LD_VAR 0 2
15025: PUSH
15026: LD_INT 1
15028: ARRAY
15029: PPUSH
15030: CALL_OW 65
// end ; 5 .. 7 :
15034: GO 15058
15036: LD_INT 5
15038: DOUBLE
15039: GREATEREQUAL
15040: IFFALSE 15048
15042: LD_INT 7
15044: DOUBLE
15045: LESSEQUAL
15046: IFTRUE 15050
15048: GO 15057
15050: POP
// StreamSibBomb ; end ;
15051: CALL 11338 0 0
15055: GO 15058
15057: POP
// end ;
15058: PPOPN 3
15060: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
15061: LD_EXP 20
15065: PUSH
15066: LD_EXP 70
15070: AND
15071: IFFALSE 15227
15073: GO 15075
15075: DISABLE
15076: LD_INT 0
15078: PPUSH
15079: PPUSH
15080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
15081: LD_ADDR_VAR 0 2
15085: PUSH
15086: LD_INT 81
15088: PUSH
15089: LD_OWVAR 2
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PUSH
15098: LD_INT 2
15100: PUSH
15101: LD_INT 21
15103: PUSH
15104: LD_INT 1
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PUSH
15111: LD_INT 21
15113: PUSH
15114: LD_INT 2
15116: PUSH
15117: EMPTY
15118: LIST
15119: LIST
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: PPUSH
15130: CALL_OW 69
15134: ST_TO_ADDR
// if not tmp then
15135: LD_VAR 0 2
15139: NOT
15140: IFFALSE 15144
// exit ;
15142: GO 15227
// p := 0 ;
15144: LD_ADDR_VAR 0 3
15148: PUSH
15149: LD_INT 0
15151: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15152: LD_INT 35
15154: PPUSH
15155: CALL_OW 67
// p := p + 1 ;
15159: LD_ADDR_VAR 0 3
15163: PUSH
15164: LD_VAR 0 3
15168: PUSH
15169: LD_INT 1
15171: PLUS
15172: ST_TO_ADDR
// for i in tmp do
15173: LD_ADDR_VAR 0 1
15177: PUSH
15178: LD_VAR 0 2
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15215
// if GetLives ( i ) < 1000 then
15186: LD_VAR 0 1
15190: PPUSH
15191: CALL_OW 256
15195: PUSH
15196: LD_INT 1000
15198: LESS
15199: IFFALSE 15213
// SetLives ( i , 1000 ) ;
15201: LD_VAR 0 1
15205: PPUSH
15206: LD_INT 1000
15208: PPUSH
15209: CALL_OW 234
15213: GO 15183
15215: POP
15216: POP
// until p > 20 ;
15217: LD_VAR 0 3
15221: PUSH
15222: LD_INT 20
15224: GREATER
15225: IFFALSE 15152
// end ;
15227: PPOPN 3
15229: END
// every 0 0$1 trigger StreamModeActive and sTime do
15230: LD_EXP 20
15234: PUSH
15235: LD_EXP 71
15239: AND
15240: IFFALSE 15275
15242: GO 15244
15244: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
15245: LD_INT 28
15247: PPUSH
15248: LD_OWVAR 2
15252: PPUSH
15253: LD_INT 2
15255: PPUSH
15256: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
15260: LD_INT 30
15262: PPUSH
15263: LD_OWVAR 2
15267: PPUSH
15268: LD_INT 2
15270: PPUSH
15271: CALL_OW 322
// end ;
15275: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
15276: LD_EXP 20
15280: PUSH
15281: LD_EXP 72
15285: AND
15286: IFFALSE 15407
15288: GO 15290
15290: DISABLE
15291: LD_INT 0
15293: PPUSH
15294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15295: LD_ADDR_VAR 0 2
15299: PUSH
15300: LD_INT 22
15302: PUSH
15303: LD_OWVAR 2
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: LD_INT 21
15314: PUSH
15315: LD_INT 1
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 3
15324: PUSH
15325: LD_INT 23
15327: PUSH
15328: LD_INT 0
15330: PUSH
15331: EMPTY
15332: LIST
15333: LIST
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: LIST
15343: PPUSH
15344: CALL_OW 69
15348: ST_TO_ADDR
// if not tmp then
15349: LD_VAR 0 2
15353: NOT
15354: IFFALSE 15358
// exit ;
15356: GO 15407
// for i in tmp do
15358: LD_ADDR_VAR 0 1
15362: PUSH
15363: LD_VAR 0 2
15367: PUSH
15368: FOR_IN
15369: IFFALSE 15405
// begin if Crawls ( i ) then
15371: LD_VAR 0 1
15375: PPUSH
15376: CALL_OW 318
15380: IFFALSE 15391
// ComWalk ( i ) ;
15382: LD_VAR 0 1
15386: PPUSH
15387: CALL_OW 138
// SetClass ( i , 2 ) ;
15391: LD_VAR 0 1
15395: PPUSH
15396: LD_INT 2
15398: PPUSH
15399: CALL_OW 336
// end ;
15403: GO 15368
15405: POP
15406: POP
// end ;
15407: PPOPN 2
15409: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
15410: LD_EXP 20
15414: PUSH
15415: LD_EXP 73
15419: AND
15420: IFFALSE 15701
15422: GO 15424
15424: DISABLE
15425: LD_INT 0
15427: PPUSH
15428: PPUSH
15429: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
15430: LD_OWVAR 2
15434: PPUSH
15435: LD_INT 9
15437: PPUSH
15438: LD_INT 1
15440: PPUSH
15441: LD_INT 1
15443: PPUSH
15444: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
15448: LD_INT 9
15450: PPUSH
15451: LD_OWVAR 2
15455: PPUSH
15456: CALL_OW 343
// uc_side := 9 ;
15460: LD_ADDR_OWVAR 20
15464: PUSH
15465: LD_INT 9
15467: ST_TO_ADDR
// uc_nation := 2 ;
15468: LD_ADDR_OWVAR 21
15472: PUSH
15473: LD_INT 2
15475: ST_TO_ADDR
// hc_name := Dark Warrior ;
15476: LD_ADDR_OWVAR 26
15480: PUSH
15481: LD_STRING Dark Warrior
15483: ST_TO_ADDR
// hc_gallery :=  ;
15484: LD_ADDR_OWVAR 33
15488: PUSH
15489: LD_STRING 
15491: ST_TO_ADDR
// hc_noskilllimit := true ;
15492: LD_ADDR_OWVAR 76
15496: PUSH
15497: LD_INT 1
15499: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
15500: LD_ADDR_OWVAR 31
15504: PUSH
15505: LD_INT 30
15507: PUSH
15508: LD_INT 30
15510: PUSH
15511: LD_INT 30
15513: PUSH
15514: LD_INT 30
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: LIST
15521: LIST
15522: ST_TO_ADDR
// un := CreateHuman ;
15523: LD_ADDR_VAR 0 3
15527: PUSH
15528: CALL_OW 44
15532: ST_TO_ADDR
// hc_noskilllimit := false ;
15533: LD_ADDR_OWVAR 76
15537: PUSH
15538: LD_INT 0
15540: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_INT 1
15548: PPUSH
15549: CALL_OW 51
// p := 0 ;
15553: LD_ADDR_VAR 0 2
15557: PUSH
15558: LD_INT 0
15560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15561: LD_INT 35
15563: PPUSH
15564: CALL_OW 67
// p := p + 1 ;
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 2
15577: PUSH
15578: LD_INT 1
15580: PLUS
15581: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
15582: LD_VAR 0 3
15586: PPUSH
15587: CALL_OW 256
15591: PUSH
15592: LD_INT 1000
15594: LESS
15595: IFFALSE 15609
// SetLives ( un , 1000 ) ;
15597: LD_VAR 0 3
15601: PPUSH
15602: LD_INT 1000
15604: PPUSH
15605: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
15609: LD_VAR 0 3
15613: PPUSH
15614: LD_INT 81
15616: PUSH
15617: LD_OWVAR 2
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: LD_INT 91
15628: PUSH
15629: LD_VAR 0 3
15633: PUSH
15634: LD_INT 30
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: LIST
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: PPUSH
15646: CALL_OW 69
15650: PPUSH
15651: LD_VAR 0 3
15655: PPUSH
15656: CALL_OW 74
15660: PPUSH
15661: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
15665: LD_VAR 0 2
15669: PUSH
15670: LD_INT 60
15672: GREATER
15673: PUSH
15674: LD_VAR 0 3
15678: PPUSH
15679: CALL_OW 301
15683: OR
15684: IFFALSE 15561
// if un then
15686: LD_VAR 0 3
15690: IFFALSE 15701
// RemoveUnit ( un ) ;
15692: LD_VAR 0 3
15696: PPUSH
15697: CALL_OW 64
// end ; end_of_file
15701: PPOPN 3
15703: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
15708: PPUSH
15709: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
15710: LD_VAR 0 1
15714: PPUSH
15715: CALL_OW 264
15719: PUSH
15720: LD_EXP 11
15724: EQUAL
15725: IFFALSE 15797
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
15727: LD_INT 68
15729: PPUSH
15730: LD_VAR 0 1
15734: PPUSH
15735: CALL_OW 255
15739: PPUSH
15740: CALL_OW 321
15744: PUSH
15745: LD_INT 2
15747: EQUAL
15748: IFFALSE 15760
// eff := 70 else
15750: LD_ADDR_VAR 0 4
15754: PUSH
15755: LD_INT 70
15757: ST_TO_ADDR
15758: GO 15768
// eff := 30 ;
15760: LD_ADDR_VAR 0 4
15764: PUSH
15765: LD_INT 30
15767: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
15768: LD_VAR 0 1
15772: PPUSH
15773: CALL_OW 250
15777: PPUSH
15778: LD_VAR 0 1
15782: PPUSH
15783: CALL_OW 251
15787: PPUSH
15788: LD_VAR 0 4
15792: PPUSH
15793: CALL_OW 495
// end ; end ;
15797: LD_VAR 0 2
15801: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
15802: LD_INT 0
15804: PPUSH
// end ;
15805: LD_VAR 0 4
15809: RET
// export function SOS_Command ( cmd ) ; begin
15810: LD_INT 0
15812: PPUSH
// end ;
15813: LD_VAR 0 2
15817: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
15818: LD_VAR 0 1
15822: PUSH
15823: LD_INT 255
15825: EQUAL
15826: PUSH
15827: LD_VAR 0 2
15831: PPUSH
15832: CALL_OW 264
15836: PUSH
15837: LD_INT 14
15839: PUSH
15840: LD_INT 53
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: IN
15847: AND
15848: PUSH
15849: LD_VAR 0 4
15853: PPUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL_OW 488
15863: AND
15864: IFFALSE 15888
// CutTreeXYR ( unit , x , y , 12 ) ;
15866: LD_VAR 0 2
15870: PPUSH
15871: LD_VAR 0 4
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 12
15883: PPUSH
15884: CALL 15891 0 4
// end ;
15888: PPOPN 5
15890: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
15891: LD_INT 0
15893: PPUSH
15894: PPUSH
15895: PPUSH
15896: PPUSH
15897: PPUSH
15898: PPUSH
15899: PPUSH
15900: PPUSH
15901: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
15902: LD_VAR 0 1
15906: NOT
15907: PUSH
15908: LD_VAR 0 2
15912: PPUSH
15913: LD_VAR 0 3
15917: PPUSH
15918: CALL_OW 488
15922: NOT
15923: OR
15924: PUSH
15925: LD_VAR 0 4
15929: NOT
15930: OR
15931: IFFALSE 15935
// exit ;
15933: GO 16275
// list := [ ] ;
15935: LD_ADDR_VAR 0 13
15939: PUSH
15940: EMPTY
15941: ST_TO_ADDR
// if x - r < 0 then
15942: LD_VAR 0 2
15946: PUSH
15947: LD_VAR 0 4
15951: MINUS
15952: PUSH
15953: LD_INT 0
15955: LESS
15956: IFFALSE 15968
// min_x := 0 else
15958: LD_ADDR_VAR 0 7
15962: PUSH
15963: LD_INT 0
15965: ST_TO_ADDR
15966: GO 15984
// min_x := x - r ;
15968: LD_ADDR_VAR 0 7
15972: PUSH
15973: LD_VAR 0 2
15977: PUSH
15978: LD_VAR 0 4
15982: MINUS
15983: ST_TO_ADDR
// if y - r < 0 then
15984: LD_VAR 0 3
15988: PUSH
15989: LD_VAR 0 4
15993: MINUS
15994: PUSH
15995: LD_INT 0
15997: LESS
15998: IFFALSE 16010
// min_y := 0 else
16000: LD_ADDR_VAR 0 8
16004: PUSH
16005: LD_INT 0
16007: ST_TO_ADDR
16008: GO 16026
// min_y := y - r ;
16010: LD_ADDR_VAR 0 8
16014: PUSH
16015: LD_VAR 0 3
16019: PUSH
16020: LD_VAR 0 4
16024: MINUS
16025: ST_TO_ADDR
// max_x := x + r ;
16026: LD_ADDR_VAR 0 9
16030: PUSH
16031: LD_VAR 0 2
16035: PUSH
16036: LD_VAR 0 4
16040: PLUS
16041: ST_TO_ADDR
// max_y := y + r ;
16042: LD_ADDR_VAR 0 10
16046: PUSH
16047: LD_VAR 0 3
16051: PUSH
16052: LD_VAR 0 4
16056: PLUS
16057: ST_TO_ADDR
// for _x = min_x to max_x do
16058: LD_ADDR_VAR 0 11
16062: PUSH
16063: DOUBLE
16064: LD_VAR 0 7
16068: DEC
16069: ST_TO_ADDR
16070: LD_VAR 0 9
16074: PUSH
16075: FOR_TO
16076: IFFALSE 16193
// for _y = min_y to max_y do
16078: LD_ADDR_VAR 0 12
16082: PUSH
16083: DOUBLE
16084: LD_VAR 0 8
16088: DEC
16089: ST_TO_ADDR
16090: LD_VAR 0 10
16094: PUSH
16095: FOR_TO
16096: IFFALSE 16189
// begin if not ValidHex ( _x , _y ) then
16098: LD_VAR 0 11
16102: PPUSH
16103: LD_VAR 0 12
16107: PPUSH
16108: CALL_OW 488
16112: NOT
16113: IFFALSE 16117
// continue ;
16115: GO 16095
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
16117: LD_VAR 0 11
16121: PPUSH
16122: LD_VAR 0 12
16126: PPUSH
16127: CALL_OW 351
16131: PUSH
16132: LD_VAR 0 11
16136: PPUSH
16137: LD_VAR 0 12
16141: PPUSH
16142: CALL_OW 554
16146: AND
16147: IFFALSE 16187
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
16149: LD_ADDR_VAR 0 13
16153: PUSH
16154: LD_VAR 0 13
16158: PPUSH
16159: LD_VAR 0 13
16163: PUSH
16164: LD_INT 1
16166: PLUS
16167: PPUSH
16168: LD_VAR 0 11
16172: PUSH
16173: LD_VAR 0 12
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PPUSH
16182: CALL_OW 2
16186: ST_TO_ADDR
// end ;
16187: GO 16095
16189: POP
16190: POP
16191: GO 16075
16193: POP
16194: POP
// if not list then
16195: LD_VAR 0 13
16199: NOT
16200: IFFALSE 16204
// exit ;
16202: GO 16275
// for i in list do
16204: LD_ADDR_VAR 0 6
16208: PUSH
16209: LD_VAR 0 13
16213: PUSH
16214: FOR_IN
16215: IFFALSE 16273
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
16217: LD_VAR 0 1
16221: PPUSH
16222: LD_STRING M
16224: PUSH
16225: LD_VAR 0 6
16229: PUSH
16230: LD_INT 1
16232: ARRAY
16233: PUSH
16234: LD_VAR 0 6
16238: PUSH
16239: LD_INT 2
16241: ARRAY
16242: PUSH
16243: LD_INT 0
16245: PUSH
16246: LD_INT 0
16248: PUSH
16249: LD_INT 0
16251: PUSH
16252: LD_INT 0
16254: PUSH
16255: EMPTY
16256: LIST
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: LIST
16262: LIST
16263: PUSH
16264: EMPTY
16265: LIST
16266: PPUSH
16267: CALL_OW 447
16271: GO 16214
16273: POP
16274: POP
// end ;
16275: LD_VAR 0 5
16279: RET
