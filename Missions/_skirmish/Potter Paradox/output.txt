// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 181 0 0
// PrepareAllies ;
  12: CALL 2172 0 0
// Action ;
  16: CALL 4314 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// if not Difficulty then
  41: LD_OWVAR 67
  45: NOT
  46: IFFALSE 56
// Difficulty := 2 ;
  48: LD_ADDR_OWVAR 67
  52: PUSH
  53: LD_INT 2
  55: ST_TO_ADDR
// InitVariables ;
  56: CALL 69 0 0
// SetDiplomacy ;
  60: CALL 133 0 0
// end ; end_of_file
  64: LD_VAR 0 1
  68: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// points := 0 ;
  72: LD_ADDR_EXP 8
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// alert := false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// game_over := false ;
  88: LD_ADDR_EXP 7
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// wave_time := 0 0$00 ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// bonus_active := false ;
 104: LD_ADDR_EXP 11
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ignore_wave := false ;
 112: LD_ADDR_EXP 13
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// bonus_num := 0 ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// end ;
 128: LD_VAR 0 1
 132: RET
// export function SetDiplomacy ; begin
 133: LD_INT 0
 135: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 136: LD_INT 92
 138: PPUSH
 139: LD_INT 48
 141: PPUSH
 142: LD_INT 8
 144: PPUSH
 145: LD_INT 32796
 147: NEG
 148: PPUSH
 149: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 153: LD_INT 92
 155: PPUSH
 156: LD_INT 48
 158: PPUSH
 159: LD_INT 8
 161: PPUSH
 162: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 166: LD_INT 5
 168: PPUSH
 169: LD_INT 8
 171: PPUSH
 172: CALL_OW 343
// end ; end_of_file
 176: LD_VAR 0 1
 180: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
 198: PPUSH
 199: PPUSH
 200: PPUSH
// uc_side := 2 ;
 201: LD_ADDR_OWVAR 20
 205: PUSH
 206: LD_INT 2
 208: ST_TO_ADDR
// uc_nation := nation_arabian ;
 209: LD_ADDR_OWVAR 21
 213: PUSH
 214: LD_INT 2
 216: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 1
 222: PPUSH
 223: LD_INT 6
 225: PPUSH
 226: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 230: LD_ADDR_OWVAR 26
 234: PUSH
 235: LD_STRING Nicolas Vervecken
 237: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 238: LD_ADDR_OWVAR 33
 242: PUSH
 243: LD_STRING SecondCharsGal
 245: ST_TO_ADDR
// hc_face_number := 3 ;
 246: LD_ADDR_OWVAR 34
 250: PUSH
 251: LD_INT 3
 253: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 254: LD_ADDR_OWVAR 29
 258: PUSH
 259: LD_INT 11
 261: PUSH
 262: LD_INT 10
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: ST_TO_ADDR
// Vervecken := CreateHuman ;
 269: LD_ADDR_EXP 10
 273: PUSH
 274: CALL_OW 44
 278: ST_TO_ADDR
// InitHc ;
 279: CALL_OW 19
// uc_side := 8 ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_INT 8
 290: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 291: LD_INT 23
 293: PPUSH
 294: CALL_OW 274
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 4000
 304: PUSH
 305: LD_INT 2500
 307: PUSH
 308: LD_INT 1250
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_OWVAR 67
 320: ARRAY
 321: PPUSH
 322: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 326: LD_INT 23
 328: PPUSH
 329: CALL_OW 274
 333: PPUSH
 334: LD_INT 2
 336: PPUSH
 337: LD_INT 300
 339: PPUSH
 340: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 344: LD_INT 23
 346: PPUSH
 347: CALL_OW 274
 351: PPUSH
 352: LD_INT 3
 354: PPUSH
 355: LD_INT 100
 357: PUSH
 358: LD_INT 50
 360: PUSH
 361: LD_INT 30
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: PUSH
 369: LD_OWVAR 67
 373: ARRAY
 374: PPUSH
 375: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 379: LD_ADDR_VAR 0 14
 383: PUSH
 384: LD_INT 23
 386: PPUSH
 387: CALL_OW 250
 391: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 392: LD_ADDR_VAR 0 15
 396: PUSH
 397: LD_INT 23
 399: PPUSH
 400: CALL_OW 251
 404: ST_TO_ADDR
// team := [ ] ;
 405: LD_ADDR_VAR 0 7
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 412: LD_ADDR_VAR 0 8
 416: PUSH
 417: LD_INT 9
 419: PUSH
 420: LD_INT 8
 422: PUSH
 423: LD_INT 7
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_OWVAR 67
 435: ARRAY
 436: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 437: LD_ADDR_VAR 0 9
 441: PUSH
 442: LD_INT 11
 444: PUSH
 445: LD_INT 9
 447: PUSH
 448: LD_INT 8
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_OWVAR 67
 460: ARRAY
 461: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 462: LD_ADDR_VAR 0 10
 466: PUSH
 467: LD_INT 3
 469: PUSH
 470: LD_INT 2
 472: PUSH
 473: LD_INT 2
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: PUSH
 481: LD_OWVAR 67
 485: ARRAY
 486: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 487: LD_ADDR_VAR 0 11
 491: PUSH
 492: LD_INT 5
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: PUSH
 506: LD_OWVAR 67
 510: ARRAY
 511: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 512: LD_ADDR_VAR 0 12
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 2
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 537: LD_ADDR_VAR 0 13
 541: PUSH
 542: LD_INT 6
 544: PUSH
 545: LD_INT 5
 547: PUSH
 548: LD_INT 4
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 562: LD_ADDR_VAR 0 18
 566: PUSH
 567: LD_INT 13
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 26
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 14
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 25
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 14
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 5
 611: PUSH
 612: LD_INT 32
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 14
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 31
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 14
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 14
 659: PUSH
 660: LD_INT 3
 662: PUSH
 663: LD_INT 2
 665: PUSH
 666: LD_INT 25
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 13
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 18
 716: PUSH
 717: LD_OWVAR 67
 721: MINUS
 722: PUSH
 723: LD_INT 1
 725: PLUS
 726: PUSH
 727: FOR_TO
 728: IFFALSE 857
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 730: LD_ADDR_OWVAR 37
 734: PUSH
 735: LD_VAR 0 18
 739: PUSH
 740: LD_VAR 0 2
 744: ARRAY
 745: PUSH
 746: LD_INT 1
 748: ARRAY
 749: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 750: LD_ADDR_OWVAR 39
 754: PUSH
 755: LD_VAR 0 18
 759: PUSH
 760: LD_VAR 0 2
 764: ARRAY
 765: PUSH
 766: LD_INT 2
 768: ARRAY
 769: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 770: LD_ADDR_OWVAR 38
 774: PUSH
 775: LD_VAR 0 18
 779: PUSH
 780: LD_VAR 0 2
 784: ARRAY
 785: PUSH
 786: LD_INT 3
 788: ARRAY
 789: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 790: LD_ADDR_OWVAR 40
 794: PUSH
 795: LD_VAR 0 18
 799: PUSH
 800: LD_VAR 0 2
 804: ARRAY
 805: PUSH
 806: LD_INT 4
 808: ARRAY
 809: ST_TO_ADDR
// un := CreateVehicle ;
 810: LD_ADDR_VAR 0 6
 814: PUSH
 815: CALL_OW 45
 819: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 820: LD_VAR 0 6
 824: PPUSH
 825: LD_INT 0
 827: PPUSH
 828: LD_INT 5
 830: PPUSH
 831: CALL_OW 12
 835: PPUSH
 836: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 840: LD_VAR 0 6
 844: PPUSH
 845: LD_INT 7
 847: PPUSH
 848: LD_INT 0
 850: PPUSH
 851: CALL_OW 49
// end ;
 855: GO 727
 857: POP
 858: POP
// for i = 1 to ape_num do
 859: LD_ADDR_VAR 0 2
 863: PUSH
 864: DOUBLE
 865: LD_INT 1
 867: DEC
 868: ST_TO_ADDR
 869: LD_VAR 0 13
 873: PUSH
 874: FOR_TO
 875: IFFALSE 942
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_INT 16
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 1
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 8
 906: PPUSH
 907: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 911: LD_ADDR_VAR 0 7
 915: PUSH
 916: LD_VAR 0 7
 920: PPUSH
 921: LD_VAR 0 7
 925: PUSH
 926: LD_INT 1
 928: PLUS
 929: PPUSH
 930: CALL_OW 44
 934: PPUSH
 935: CALL_OW 2
 939: ST_TO_ADDR
// end ;
 940: GO 874
 942: POP
 943: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 8
 954: PPUSH
 955: CALL_OW 380
// l1 := CreateHuman ;
 959: LD_ADDR_EXP 2
 963: PUSH
 964: CALL_OW 44
 968: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 969: LD_EXP 2
 973: PPUSH
 974: LD_INT 23
 976: PPUSH
 977: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 981: LD_INT 1
 983: PPUSH
 984: LD_INT 1
 986: PPUSH
 987: LD_VAR 0 8
 991: PPUSH
 992: CALL_OW 380
// l2 := CreateHuman ;
 996: LD_ADDR_EXP 3
1000: PUSH
1001: CALL_OW 44
1005: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1006: LD_EXP 3
1010: PPUSH
1011: LD_INT 23
1013: PPUSH
1014: CALL_OW 52
// for class = 1 to 4 do
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: DOUBLE
1024: LD_INT 1
1026: DEC
1027: ST_TO_ADDR
1028: LD_INT 4
1030: PUSH
1031: FOR_TO
1032: IFFALSE 1131
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: DOUBLE
1040: LD_INT 1
1042: DEC
1043: ST_TO_ADDR
1044: LD_VAR 0 9
1048: PUSH
1049: LD_VAR 0 10
1053: PUSH
1054: LD_VAR 0 11
1058: PUSH
1059: LD_VAR 0 12
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_VAR 0 4
1074: ARRAY
1075: PUSH
1076: FOR_TO
1077: IFFALSE 1127
// begin PrepareHuman ( false , class , skill ) ;
1079: LD_INT 0
1081: PPUSH
1082: LD_VAR 0 4
1086: PPUSH
1087: LD_VAR 0 8
1091: PPUSH
1092: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 7
1105: PPUSH
1106: LD_VAR 0 7
1110: PUSH
1111: LD_INT 1
1113: PLUS
1114: PPUSH
1115: CALL_OW 44
1119: PPUSH
1120: CALL_OW 2
1124: ST_TO_ADDR
// end ;
1125: GO 1076
1127: POP
1128: POP
1129: GO 1031
1131: POP
1132: POP
// for i in team do
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 7
1142: PUSH
1143: FOR_IN
1144: IFFALSE 1620
// begin b := 0 ;
1146: LD_ADDR_VAR 0 5
1150: PUSH
1151: LD_INT 0
1153: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1154: LD_VAR 0 2
1158: PPUSH
1159: CALL_OW 257
1163: PUSH
1164: LD_INT 1
1166: DOUBLE
1167: EQUAL
1168: IFTRUE 1172
1170: GO 1279
1172: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 22
1180: PUSH
1181: LD_OWVAR 20
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 2
1192: PUSH
1193: LD_INT 30
1195: PUSH
1196: LD_INT 32
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 30
1205: PUSH
1206: LD_INT 31
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 58
1220: PUSH
1221: EMPTY
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: ST_TO_ADDR
// if not b then
1234: LD_VAR 0 5
1238: NOT
1239: IFFALSE 1277
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1241: LD_ADDR_VAR 0 5
1245: PUSH
1246: LD_INT 22
1248: PUSH
1249: LD_OWVAR 20
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// end ; class_engineer :
1277: GO 1518
1279: LD_INT 2
1281: DOUBLE
1282: EQUAL
1283: IFTRUE 1287
1285: GO 1326
1287: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_OWVAR 20
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 30
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
1324: GO 1518
1326: LD_INT 3
1328: DOUBLE
1329: EQUAL
1330: IFTRUE 1334
1332: GO 1423
1334: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1335: LD_ADDR_VAR 0 5
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_OWVAR 20
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 21
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 58
1364: PUSH
1365: EMPTY
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: ST_TO_ADDR
// if not b then
1378: LD_VAR 0 5
1382: NOT
1383: IFFALSE 1421
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1385: LD_ADDR_VAR 0 5
1389: PUSH
1390: LD_INT 22
1392: PUSH
1393: LD_OWVAR 20
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 30
1404: PUSH
1405: LD_INT 3
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL_OW 69
1420: ST_TO_ADDR
// end ; class_scientistic :
1421: GO 1518
1423: LD_INT 4
1425: DOUBLE
1426: EQUAL
1427: IFTRUE 1431
1429: GO 1470
1431: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1432: LD_ADDR_VAR 0 5
1436: PUSH
1437: LD_INT 22
1439: PUSH
1440: LD_OWVAR 20
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PPUSH
1463: CALL_OW 69
1467: ST_TO_ADDR
// end ; class_apeman_soldier :
1468: GO 1518
1470: LD_INT 15
1472: DOUBLE
1473: EQUAL
1474: IFTRUE 1478
1476: GO 1517
1478: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1479: LD_ADDR_VAR 0 5
1483: PUSH
1484: LD_INT 22
1486: PUSH
1487: LD_OWVAR 20
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 30
1498: PUSH
1499: LD_INT 5
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: ST_TO_ADDR
1515: GO 1518
1517: POP
// if b then
1518: LD_VAR 0 5
1522: IFFALSE 1593
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1524: LD_VAR 0 5
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: CALL_OW 266
1537: PUSH
1538: LD_INT 31
1540: EQUAL
1541: IFFALSE 1563
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_VAR 0 5
1552: PUSH
1553: LD_INT 1
1555: ARRAY
1556: PPUSH
1557: CALL 5028 0 2
1561: GO 1591
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1563: LD_VAR 0 2
1567: PPUSH
1568: LD_VAR 0 5
1572: PUSH
1573: LD_INT 1
1575: PPUSH
1576: LD_VAR 0 5
1580: PPUSH
1581: CALL_OW 12
1585: ARRAY
1586: PPUSH
1587: CALL_OW 52
1591: GO 1618
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1593: LD_VAR 0 2
1597: PPUSH
1598: LD_VAR 0 14
1602: PPUSH
1603: LD_VAR 0 15
1607: PPUSH
1608: LD_INT 15
1610: PPUSH
1611: LD_INT 0
1613: PPUSH
1614: CALL_OW 50
// end ;
1618: GO 1143
1620: POP
1621: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1622: LD_ADDR_VAR 0 16
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 2
1635: PUSH
1636: LD_INT 1
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PUSH
1644: LD_OWVAR 67
1648: ARRAY
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: PUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 5
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_OWVAR 67
1675: ARRAY
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: LD_INT 5
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 4
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: LIST
1697: PUSH
1698: LD_OWVAR 67
1702: ARRAY
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: LD_INT 30
1710: PUSH
1711: LD_INT 2
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_OWVAR 67
1729: ARRAY
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1741: LD_ADDR_VAR 0 2
1745: PUSH
1746: LD_INT 22
1748: PUSH
1749: LD_OWVAR 20
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 30
1760: PUSH
1761: LD_INT 32
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: PUSH
1777: FOR_IN
1778: IFFALSE 1951
// begin if weapons then
1780: LD_VAR 0 16
1784: IFFALSE 1908
// begin k := rand ( 1 , weapons ) ;
1786: LD_ADDR_VAR 0 3
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_VAR 0 16
1798: PPUSH
1799: CALL_OW 12
1803: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1804: LD_ADDR_VAR 0 17
1808: PUSH
1809: LD_VAR 0 16
1813: PUSH
1814: LD_VAR 0 3
1818: ARRAY
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1824: LD_ADDR_VAR 0 16
1828: PUSH
1829: LD_VAR 0 16
1833: PPUSH
1834: LD_VAR 0 3
1838: PPUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_VAR 0 16
1846: PUSH
1847: LD_VAR 0 3
1851: ARRAY
1852: PUSH
1853: LD_INT 2
1855: ARRAY
1856: PUSH
1857: LD_INT 1
1859: MINUS
1860: PPUSH
1861: CALL 5120 0 4
1865: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1866: LD_VAR 0 16
1870: PUSH
1871: LD_VAR 0 3
1875: ARRAY
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: PUSH
1881: LD_INT 0
1883: EQUAL
1884: IFFALSE 1906
// weapons := Delete ( weapons , k ) ;
1886: LD_ADDR_VAR 0 16
1890: PUSH
1891: LD_VAR 0 16
1895: PPUSH
1896: LD_VAR 0 3
1900: PPUSH
1901: CALL_OW 3
1905: ST_TO_ADDR
// end else
1906: GO 1935
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_INT 27
1915: PUSH
1916: LD_INT 23
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: CALL_OW 12
1933: ARRAY
1934: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1935: LD_VAR 0 2
1939: PPUSH
1940: LD_VAR 0 17
1944: PPUSH
1945: CALL_OW 431
// end ;
1949: GO 1777
1951: POP
1952: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1953: LD_INT 1
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 8
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: CALL_OW 380
// hc_gallery := potter ;
1972: LD_ADDR_OWVAR 33
1976: PUSH
1977: LD_STRING potter
1979: ST_TO_ADDR
// hc_face_number := 1 ;
1980: LD_ADDR_OWVAR 34
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// hc_importance := 100 ;
1988: LD_ADDR_OWVAR 32
1992: PUSH
1993: LD_INT 100
1995: ST_TO_ADDR
// hc_name := Mike Gerste ;
1996: LD_ADDR_OWVAR 26
2000: PUSH
2001: LD_STRING Mike Gerste
2003: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2004: LD_ADDR_OWVAR 29
2008: PUSH
2009: LD_INT 10
2011: PUSH
2012: LD_INT 11
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: ST_TO_ADDR
// legion_commander := CreateHuman ;
2019: LD_ADDR_EXP 1
2023: PUSH
2024: CALL_OW 44
2028: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2029: LD_EXP 1
2033: PPUSH
2034: LD_INT 23
2036: PPUSH
2037: CALL_OW 52
// uc_side := 5 ;
2041: LD_ADDR_OWVAR 20
2045: PUSH
2046: LD_INT 5
2048: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: LD_VAR 0 8
2059: PPUSH
2060: CALL_OW 380
// hc_gallery := potter ;
2064: LD_ADDR_OWVAR 33
2068: PUSH
2069: LD_STRING potter
2071: ST_TO_ADDR
// hc_face_number := 2 ;
2072: LD_ADDR_OWVAR 34
2076: PUSH
2077: LD_INT 2
2079: ST_TO_ADDR
// hc_importance := 0 ;
2080: LD_ADDR_OWVAR 32
2084: PUSH
2085: LD_INT 0
2087: ST_TO_ADDR
// hc_name := George Potter ;
2088: LD_ADDR_OWVAR 26
2092: PUSH
2093: LD_STRING George Potter
2095: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2096: LD_ADDR_OWVAR 29
2100: PUSH
2101: LD_INT 12
2103: PUSH
2104: LD_INT 9
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: ST_TO_ADDR
// potter := CreateHuman ;
2111: LD_ADDR_EXP 4
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2121: LD_EXP 4
2125: PPUSH
2126: LD_INT 4
2128: PPUSH
2129: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2133: LD_EXP 4
2137: PPUSH
2138: LD_INT 103
2140: PPUSH
2141: LD_INT 45
2143: PPUSH
2144: LD_INT 0
2146: PPUSH
2147: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2151: LD_EXP 4
2155: PPUSH
2156: LD_INT 23
2158: PPUSH
2159: CALL_OW 119
// InitHc ( ) ;
2163: CALL_OW 19
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
2178: PPUSH
// uc_side := 5 ;
2179: LD_ADDR_OWVAR 20
2183: PUSH
2184: LD_INT 5
2186: ST_TO_ADDR
// uc_nation := nation_arabian ;
2187: LD_ADDR_OWVAR 21
2191: PUSH
2192: LD_INT 2
2194: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2195: LD_ADDR_VAR 0 4
2199: PUSH
2200: LD_INT 22
2202: PUSH
2203: LD_OWVAR 20
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 30
2214: PUSH
2215: LD_INT 5
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PPUSH
2226: CALL_OW 69
2230: ST_TO_ADDR
// for i = 1 to 3 do
2231: LD_ADDR_VAR 0 2
2235: PUSH
2236: DOUBLE
2237: LD_INT 1
2239: DEC
2240: ST_TO_ADDR
2241: LD_INT 3
2243: PUSH
2244: FOR_TO
2245: IFFALSE 2283
// begin PrepareHuman ( false , 2 , 6 ) ;
2247: LD_INT 0
2249: PPUSH
2250: LD_INT 2
2252: PPUSH
2253: LD_INT 6
2255: PPUSH
2256: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2260: CALL_OW 44
2264: PPUSH
2265: LD_INT 27
2267: PPUSH
2268: LD_INT 22
2270: PPUSH
2271: LD_INT 5
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 50
// end ;
2281: GO 2244
2283: POP
2284: POP
// for i = 1 to 3 do
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: DOUBLE
2291: LD_INT 1
2293: DEC
2294: ST_TO_ADDR
2295: LD_INT 3
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2334
// begin PrepareHuman ( false , 1 , 6 ) ;
2301: LD_INT 0
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 6
2309: PPUSH
2310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2314: CALL_OW 44
2318: PPUSH
2319: LD_VAR 0 4
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 52
// end ;
2332: GO 2298
2334: POP
2335: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_INT 22
2343: PUSH
2344: LD_OWVAR 20
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: LD_INT 30
2358: PUSH
2359: LD_INT 31
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 30
2368: PUSH
2369: LD_INT 32
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2478
// begin PrepareHuman ( false , 1 , 6 ) ;
2393: LD_INT 0
2395: PPUSH
2396: LD_INT 1
2398: PPUSH
2399: LD_INT 6
2401: PPUSH
2402: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2406: CALL_OW 44
2410: PPUSH
2411: LD_VAR 0 2
2415: PPUSH
2416: CALL 5028 0 2
// if GetBType ( i ) = b_bunker then
2420: LD_VAR 0 2
2424: PPUSH
2425: CALL_OW 266
2429: PUSH
2430: LD_INT 32
2432: EQUAL
2433: IFFALSE 2476
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_INT 27
2442: PUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 24
2448: PUSH
2449: LD_INT 28
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_INT 4
2465: MOD
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: ARRAY
2471: PPUSH
2472: CALL_OW 431
// end ;
2476: GO 2390
2478: POP
2479: POP
// for i = 1 to 3 do
2480: LD_ADDR_VAR 0 2
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_INT 3
2492: PUSH
2493: FOR_TO
2494: IFFALSE 2611
// begin vc_chassis := ar_half_tracked ;
2496: LD_ADDR_OWVAR 37
2500: PUSH
2501: LD_INT 14
2503: ST_TO_ADDR
// vc_engine := engine_solar ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_INT 2
2511: ST_TO_ADDR
// vc_control := control_manual ;
2512: LD_ADDR_OWVAR 38
2516: PUSH
2517: LD_INT 1
2519: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2520: LD_ADDR_OWVAR 40
2524: PUSH
2525: LD_INT 25
2527: PUSH
2528: LD_INT 27
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_VAR 0 2
2543: ARRAY
2544: ST_TO_ADDR
// un := CreateVehicle ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2555: LD_VAR 0 3
2559: PPUSH
2560: LD_INT 5
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2567: LD_VAR 0 3
2571: PPUSH
2572: LD_INT 8
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2582: LD_INT 0
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 7
2590: PPUSH
2591: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2595: CALL_OW 44
2599: PPUSH
2600: LD_VAR 0 3
2604: PPUSH
2605: CALL_OW 52
// end ;
2609: GO 2493
2611: POP
2612: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 1
2618: PPUSH
2619: LD_INT 6
2621: PPUSH
2622: CALL_OW 380
// al_commander := CreateHuman ;
2626: LD_ADDR_EXP 5
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2636: LD_EXP 5
2640: PPUSH
2641: LD_INT 22
2643: PUSH
2644: LD_OWVAR 20
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: LD_INT 0
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL_OW 69
2671: PUSH
2672: LD_INT 1
2674: ARRAY
2675: PPUSH
2676: CALL_OW 52
// InitHc ( ) ;
2680: CALL_OW 19
// end ;
2684: LD_VAR 0 1
2688: RET
// export function ChangeSide ( ) ; var i ; begin
2689: LD_INT 0
2691: PPUSH
2692: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_INT 22
2700: PUSH
2701: LD_INT 5
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2730
// SetSide ( i , 8 ) ;
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 8
2723: PPUSH
2724: CALL_OW 235
2728: GO 2713
2730: POP
2731: POP
// end ;
2732: LD_VAR 0 1
2736: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2737: LD_INT 22
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PPUSH
2747: CALL_OW 69
2751: IFFALSE 3265
2753: GO 2755
2755: DISABLE
2756: LD_INT 0
2758: PPUSH
2759: PPUSH
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 5
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: LD_INT 21
2785: PUSH
2786: LD_INT 1
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: LD_INT 21
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PPUSH
2812: CALL_OW 69
2816: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_INT 22
2824: PUSH
2825: LD_INT 5
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 30
2834: PUSH
2835: LD_INT 32
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 3
2844: PUSH
2845: LD_INT 24
2847: PUSH
2848: LD_INT 1000
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 69
2868: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 3
2881: PUSH
2882: LD_INT 54
2884: PUSH
2885: EMPTY
2886: LIST
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 25
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 72
2910: ST_TO_ADDR
// if not list then
2911: LD_VAR 0 2
2915: NOT
2916: IFFALSE 2920
// exit ;
2918: GO 3265
// for i in list do
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: PUSH
2930: FOR_IN
2931: IFFALSE 3263
// begin if b then
2933: LD_VAR 0 5
2937: IFFALSE 3016
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PUSH
2952: LD_INT 2
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 72
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3014
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2967: LD_VAR 0 4
2971: PPUSH
2972: CALL_OW 314
2976: NOT
2977: PUSH
2978: LD_VAR 0 1
2982: PPUSH
2983: CALL_OW 110
2987: PUSH
2988: LD_INT 7
2990: NONEQUAL
2991: AND
2992: IFFALSE 3012
// ComRepairBuilding ( j , b [ 1 ] ) ;
2994: LD_VAR 0 4
2998: PPUSH
2999: LD_VAR 0 5
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: PPUSH
3008: CALL_OW 130
3012: GO 2964
3014: POP
3015: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 256
3025: PUSH
3026: LD_INT 500
3028: LESS
3029: PUSH
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 110
3039: PUSH
3040: LD_INT 7
3042: EQUAL
3043: NOT
3044: AND
3045: IFFALSE 3095
// begin ComMoveToArea ( i , guard_hill ) ;
3047: LD_VAR 0 1
3051: PPUSH
3052: LD_INT 11
3054: PPUSH
3055: CALL_OW 113
// SetTag ( i , 7 ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: LD_INT 7
3066: PPUSH
3067: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 247
3080: PUSH
3081: LD_INT 2
3083: EQUAL
3084: IFFALSE 3095
// begin AddComExitVehicle ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3095: LD_VAR 0 1
3099: PPUSH
3100: CALL_OW 256
3104: PUSH
3105: LD_INT 1000
3107: EQUAL
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 110
3118: PUSH
3119: LD_INT 7
3121: EQUAL
3122: AND
3123: PUSH
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 310
3133: NOT
3134: AND
3135: PUSH
3136: LD_VAR 0 6
3140: AND
3141: IFFALSE 3169
// begin SetTag ( i , 0 ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3155: LD_VAR 0 6
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3169: LD_VAR 0 1
3173: PPUSH
3174: CALL_OW 247
3178: PUSH
3179: LD_INT 2
3181: EQUAL
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 110
3192: PUSH
3193: LD_INT 7
3195: NONEQUAL
3196: AND
3197: PUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 314
3207: NOT
3208: AND
3209: IFFALSE 3261
// if FilterAllUnits ( [ f_side , 7 ] ) then
3211: LD_INT 22
3213: PUSH
3214: LD_INT 7
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PPUSH
3221: CALL_OW 69
3225: IFFALSE 3261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_INT 22
3234: PUSH
3235: LD_INT 7
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 69
3246: PPUSH
3247: LD_VAR 0 1
3251: PPUSH
3252: CALL_OW 74
3256: PPUSH
3257: CALL_OW 115
// end ;
3261: GO 2930
3263: POP
3264: POP
// end ; end_of_file
3265: PPOPN 6
3267: END
// export function Game ; var i , val , areas , wave ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: LD_INT 5
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3306: LD_ADDR_VAR 0 3
3310: PUSH
3311: LD_INT 10
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 30
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_OWVAR 67
3329: ARRAY
3330: ST_TO_ADDR
// wave := 1 ;
3331: LD_ADDR_VAR 0 5
3335: PUSH
3336: LD_INT 1
3338: ST_TO_ADDR
// while ( game_over = false ) do
3339: LD_EXP 7
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3511
// begin repeat begin Wait ( 0 0$01 ) ;
3349: LD_INT 35
3351: PPUSH
3352: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3356: LD_ADDR_EXP 9
3360: PUSH
3361: LD_EXP 9
3365: PUSH
3366: LD_INT 35
3368: PLUS
3369: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3370: LD_INT 22
3372: PUSH
3373: LD_INT 7
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 10
3387: LESS
3388: PUSH
3389: LD_EXP 9
3393: PUSH
3394: LD_INT 21000
3396: GREATEREQUAL
3397: OR
3398: IFFALSE 3349
// wave_time := 0 0$00 ;
3400: LD_ADDR_EXP 9
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3408: LD_INT 5250
3410: PPUSH
3411: CALL_OW 67
// if not ignore_wave then
3415: LD_EXP 13
3419: NOT
3420: IFFALSE 3501
// begin for i = 1 to wave do
3422: LD_ADDR_VAR 0 2
3426: PUSH
3427: DOUBLE
3428: LD_INT 1
3430: DEC
3431: ST_TO_ADDR
3432: LD_VAR 0 5
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3483
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3440: LD_VAR 0 3
3444: PUSH
3445: LD_VAR 0 2
3449: MUL
3450: PPUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 6
3463: MOD
3464: PUSH
3465: LD_INT 1
3467: PLUS
3468: ARRAY
3469: PPUSH
3470: CALL 3516 0 2
// Wait ( 0 0$10 ) ;
3474: LD_INT 350
3476: PPUSH
3477: CALL_OW 67
// end ;
3481: GO 3437
3483: POP
3484: POP
// wave := wave + 1 ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_VAR 0 5
3494: PUSH
3495: LD_INT 1
3497: PLUS
3498: ST_TO_ADDR
// end else
3499: GO 3509
// ignore_wave := false ;
3501: LD_ADDR_EXP 13
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// end ;
3509: GO 3339
// end ;
3511: LD_VAR 0 1
3515: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3516: LD_INT 0
3518: PPUSH
3519: PPUSH
3520: PPUSH
3521: PPUSH
// uc_side := 7 ;
3522: LD_ADDR_OWVAR 20
3526: PUSH
3527: LD_INT 7
3529: ST_TO_ADDR
// uc_nation := 2 ;
3530: LD_ADDR_OWVAR 21
3534: PUSH
3535: LD_INT 2
3537: ST_TO_ADDR
// InitHc ( ) ;
3538: CALL_OW 19
// hc_gallery :=  ;
3542: LD_ADDR_OWVAR 33
3546: PUSH
3547: LD_STRING 
3549: ST_TO_ADDR
// hc_importance := 0 ;
3550: LD_ADDR_OWVAR 32
3554: PUSH
3555: LD_INT 0
3557: ST_TO_ADDR
// hc_name :=  ;
3558: LD_ADDR_OWVAR 26
3562: PUSH
3563: LD_STRING 
3565: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3566: LD_ADDR_OWVAR 29
3570: PUSH
3571: LD_INT 10
3573: PUSH
3574: LD_OWVAR 1
3578: PUSH
3579: LD_INT 21000
3581: DIV
3582: PLUS
3583: PUSH
3584: LD_INT 10
3586: PUSH
3587: LD_OWVAR 1
3591: PUSH
3592: LD_INT 21000
3594: DIV
3595: PLUS
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// for i = 1 to val do
3601: LD_ADDR_VAR 0 4
3605: PUSH
3606: DOUBLE
3607: LD_INT 1
3609: DEC
3610: ST_TO_ADDR
3611: LD_VAR 0 1
3615: PUSH
3616: FOR_TO
3617: IFFALSE 3824
// begin if i mod 9 = 0 then
3619: LD_VAR 0 4
3623: PUSH
3624: LD_INT 9
3626: MOD
3627: PUSH
3628: LD_INT 0
3630: EQUAL
3631: IFFALSE 3643
// class := class_apeman_kamikaze else
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_INT 17
3640: ST_TO_ADDR
3641: GO 3675
// if i mod 4 = 0 then
3643: LD_VAR 0 4
3647: PUSH
3648: LD_INT 4
3650: MOD
3651: PUSH
3652: LD_INT 0
3654: EQUAL
3655: IFFALSE 3667
// class := class_apeman_soldier else
3657: LD_ADDR_VAR 0 6
3661: PUSH
3662: LD_INT 15
3664: ST_TO_ADDR
3665: GO 3675
// class := class_apeman ;
3667: LD_ADDR_VAR 0 6
3671: PUSH
3672: LD_INT 12
3674: ST_TO_ADDR
// if i mod 33 = 0 then
3675: LD_VAR 0 4
3679: PUSH
3680: LD_INT 33
3682: MOD
3683: PUSH
3684: LD_INT 0
3686: EQUAL
3687: IFFALSE 3756
// begin vc_chassis := ar_half_tracked ;
3689: LD_ADDR_OWVAR 37
3693: PUSH
3694: LD_INT 14
3696: ST_TO_ADDR
// vc_control := control_apeman ;
3697: LD_ADDR_OWVAR 38
3701: PUSH
3702: LD_INT 5
3704: ST_TO_ADDR
// vc_engine := engine_combustion ;
3705: LD_ADDR_OWVAR 39
3709: PUSH
3710: LD_INT 1
3712: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3713: LD_ADDR_OWVAR 40
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: LD_INT 29
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 1
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: CALL_OW 12
3742: ARRAY
3743: ST_TO_ADDR
// un := CreateVehicle ;
3744: LD_ADDR_VAR 0 5
3748: PUSH
3749: CALL_OW 45
3753: ST_TO_ADDR
// end else
3754: GO 3781
// begin PrepareHuman ( sex_male , class , 10 ) ;
3756: LD_INT 1
3758: PPUSH
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_INT 10
3766: PPUSH
3767: CALL_OW 380
// un := CreateHuman ;
3771: LD_ADDR_VAR 0 5
3775: PUSH
3776: CALL_OW 44
3780: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3781: LD_VAR 0 5
3785: PPUSH
3786: LD_VAR 0 2
3790: PPUSH
3791: LD_INT 0
3793: PPUSH
3794: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3798: LD_VAR 0 5
3802: PPUSH
3803: CALL_OW 250
3807: PPUSH
3808: LD_VAR 0 5
3812: PPUSH
3813: CALL_OW 251
3817: PPUSH
3818: CALL_OW 494
// end ;
3822: GO 3616
3824: POP
3825: POP
// end ;
3826: LD_VAR 0 3
3830: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3831: LD_EXP 6
3835: PUSH
3836: LD_EXP 7
3840: NOT
3841: AND
3842: IFFALSE 4128
3844: GO 3846
3846: DISABLE
3847: LD_INT 0
3849: PPUSH
3850: PPUSH
3851: PPUSH
// begin enable ;
3852: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_INT 22
3860: PUSH
3861: LD_INT 7
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// if not list then
3873: LD_VAR 0 2
3877: NOT
3878: IFFALSE 3882
// exit ;
3880: GO 4128
// for i in list do
3882: LD_ADDR_VAR 0 1
3886: PUSH
3887: LD_VAR 0 2
3891: PUSH
3892: FOR_IN
3893: IFFALSE 4126
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3895: LD_ADDR_VAR 0 3
3899: PUSH
3900: LD_INT 81
3902: PUSH
3903: LD_INT 7
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 92
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 250
3922: PUSH
3923: LD_VAR 0 1
3927: PPUSH
3928: CALL_OW 251
3932: PUSH
3933: LD_INT 15
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 69
3950: ST_TO_ADDR
// if not enemy then
3951: LD_VAR 0 3
3955: NOT
3956: IFFALSE 4014
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3958: LD_ADDR_VAR 0 3
3962: PUSH
3963: LD_INT 81
3965: PUSH
3966: LD_INT 7
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 92
3975: PUSH
3976: LD_VAR 0 1
3980: PPUSH
3981: CALL_OW 250
3985: PUSH
3986: LD_VAR 0 1
3990: PPUSH
3991: CALL_OW 251
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 69
4013: ST_TO_ADDR
// if not enemy then
4014: LD_VAR 0 3
4018: NOT
4019: IFFALSE 4077
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4021: LD_ADDR_VAR 0 3
4025: PUSH
4026: LD_INT 81
4028: PUSH
4029: LD_INT 7
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 92
4038: PUSH
4039: LD_VAR 0 1
4043: PPUSH
4044: CALL_OW 250
4048: PUSH
4049: LD_VAR 0 1
4053: PPUSH
4054: CALL_OW 251
4058: PUSH
4059: LD_INT 50
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 3
4081: NOT
4082: IFFALSE 4104
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4084: LD_ADDR_VAR 0 3
4088: PUSH
4089: LD_INT 81
4091: PUSH
4092: LD_INT 7
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: ST_TO_ADDR
// if enemy then
4104: LD_VAR 0 3
4108: IFFALSE 4124
// Attack ( i , enemy ) ;
4110: LD_VAR 0 1
4114: PPUSH
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL 4131 0 2
// end ;
4124: GO 3892
4126: POP
4127: POP
// end ;
4128: PPOPN 3
4130: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4131: LD_INT 0
4133: PPUSH
4134: PPUSH
4135: PPUSH
// if not unit then
4136: LD_VAR 0 1
4140: NOT
4141: IFFALSE 4145
// exit ;
4143: GO 4309
// targets_list := [ ] ;
4145: LD_ADDR_VAR 0 5
4149: PUSH
4150: EMPTY
4151: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_VAR 0 2
4161: PPUSH
4162: LD_INT 21
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 3
4174: PUSH
4175: LD_INT 54
4177: PUSH
4178: EMPTY
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 72
4193: PUSH
4194: LD_VAR 0 2
4198: PPUSH
4199: LD_INT 21
4201: PUSH
4202: LD_INT 2
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL_OW 72
4213: PUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: LD_INT 21
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 3
4231: PUSH
4232: LD_INT 58
4234: PUSH
4235: EMPTY
4236: LIST
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 72
4250: PUSH
4251: LD_VAR 0 2
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// for target in targets_list do
4262: LD_ADDR_VAR 0 4
4266: PUSH
4267: LD_VAR 0 5
4271: PUSH
4272: FOR_IN
4273: IFFALSE 4307
// begin if target then
4275: LD_VAR 0 4
4279: IFFALSE 4305
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_VAR 0 4
4290: PPUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 74
4300: PPUSH
4301: CALL_OW 115
// end ;
4305: GO 4272
4307: POP
4308: POP
// end ; end_of_file
4309: LD_VAR 0 3
4313: RET
// export function Action ; begin
4314: LD_INT 0
4316: PPUSH
// InGameOn ;
4317: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4321: LD_INT 23
4323: PPUSH
4324: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4328: LD_EXP 1
4332: PPUSH
4333: LD_STRING DL-1
4335: PPUSH
4336: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4340: LD_EXP 2
4344: PPUSH
4345: LD_STRING DA-1
4347: PPUSH
4348: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4352: LD_EXP 3
4356: PPUSH
4357: LD_STRING DA-2
4359: PPUSH
4360: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4364: LD_EXP 1
4368: PPUSH
4369: LD_STRING DL-2
4371: PPUSH
4372: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4376: LD_EXP 3
4380: PPUSH
4381: LD_STRING DA-3
4383: PPUSH
4384: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4388: LD_EXP 1
4392: PPUSH
4393: LD_STRING DL-3
4395: PPUSH
4396: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_STRING DA-4
4407: PPUSH
4408: CALL_OW 88
// if not dialogue_skipped then
4412: LD_OWVAR 59
4416: NOT
4417: IFFALSE 4502
// begin Wait ( 0 0$01 ) ;
4419: LD_INT 35
4421: PPUSH
4422: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4426: LD_EXP 2
4430: PUSH
4431: LD_EXP 3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4444: LD_EXP 2
4448: PPUSH
4449: LD_INT 107
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4459: LD_EXP 3
4463: PPUSH
4464: LD_INT 108
4466: PPUSH
4467: LD_INT 53
4469: PPUSH
4470: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4474: LD_EXP 2
4478: PPUSH
4479: LD_EXP 4
4483: PPUSH
4484: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4488: LD_EXP 3
4492: PPUSH
4493: LD_EXP 4
4497: PPUSH
4498: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4502: LD_INT 35
4504: PPUSH
4505: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4509: LD_EXP 2
4513: PPUSH
4514: LD_INT 107
4516: PPUSH
4517: LD_INT 53
4519: PPUSH
4520: CALL_OW 307
4524: PUSH
4525: LD_OWVAR 59
4529: OR
4530: IFFALSE 4502
// if not dialogue_skipped then
4532: LD_OWVAR 59
4536: NOT
4537: IFFALSE 4638
// begin ComTurnUnit ( potter , l1 ) ;
4539: LD_EXP 4
4543: PPUSH
4544: LD_EXP 2
4548: PPUSH
4549: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4553: LD_INT 10
4555: PPUSH
4556: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4560: LD_EXP 4
4564: PPUSH
4565: LD_INT 108
4567: PPUSH
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 0
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 483
// Wait ( 0 0$01 ) ;
4581: LD_INT 35
4583: PPUSH
4584: CALL_OW 67
// RemoveUnit ( potter ) ;
4588: LD_EXP 4
4592: PPUSH
4593: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4597: LD_EXP 2
4601: PPUSH
4602: LD_STRING DA-5
4604: PPUSH
4605: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4609: LD_EXP 3
4613: PPUSH
4614: LD_STRING DA-6
4616: PPUSH
4617: CALL_OW 88
// Wait ( 0 0$02 ) ;
4621: LD_INT 70
4623: PPUSH
4624: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4628: LD_INT 25
4630: PPUSH
4631: LD_INT 19
4633: PPUSH
4634: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4638: LD_INT 30
4640: PPUSH
4641: LD_INT 1
4643: PPUSH
4644: CALL 3516 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4648: LD_EXP 5
4652: PPUSH
4653: LD_STRING DLa-1
4655: PPUSH
4656: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4660: LD_EXP 1
4664: PPUSH
4665: LD_STRING DL-5
4667: PPUSH
4668: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4672: LD_INT 23
4674: PPUSH
4675: CALL_OW 87
// InGameOff ;
4679: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4683: LD_STRING C1
4685: PPUSH
4686: CALL_OW 337
// alert := true ;
4690: LD_ADDR_EXP 6
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4698: LD_EXP 5
4702: PPUSH
4703: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4707: LD_EXP 5
4711: PPUSH
4712: LD_INT 11
4714: PPUSH
4715: CALL_OW 173
// Wait ( 0 0$30 ) ;
4719: LD_INT 1050
4721: PPUSH
4722: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4726: LD_INT 20
4728: PPUSH
4729: LD_INT 4
4731: PPUSH
4732: CALL 3516 0 2
// Wait ( 0 0$35 ) ;
4736: LD_INT 1225
4738: PPUSH
4739: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4743: LD_INT 20
4745: PPUSH
4746: LD_INT 5
4748: PPUSH
4749: CALL 3516 0 2
// Wait ( 0 0$03 ) ;
4753: LD_INT 105
4755: PPUSH
4756: CALL_OW 67
// Game ;
4760: CALL 3268 0 0
// end ;
4764: LD_VAR 0 1
4768: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4769: LD_INT 22
4771: PUSH
4772: LD_INT 7
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: PUSH
4788: LD_EXP 8
4792: PUSH
4793: LD_INT 500
4795: GREATEREQUAL
4796: AND
4797: IFFALSE 5025
4799: GO 4801
4801: DISABLE
4802: LD_INT 0
4804: PPUSH
4805: PPUSH
// begin DialogueOn ;
4806: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4810: LD_EXP 10
4814: PPUSH
4815: LD_STRING DVr-1
4817: PPUSH
4818: CALL_OW 94
// DialogueOff ;
4822: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4826: LD_STRING QBonusInfo
4828: PPUSH
4829: CALL_OW 97
4833: PUSH
4834: LD_INT 1
4836: DOUBLE
4837: EQUAL
4838: IFTRUE 4842
4840: GO 4853
4842: POP
// bonus_active := true ; end ;
4843: LD_ADDR_EXP 11
4847: PUSH
4848: LD_INT 1
4850: ST_TO_ADDR
4851: GO 4854
4853: POP
// bonus_num := 4 ;
4854: LD_ADDR_EXP 12
4858: PUSH
4859: LD_INT 4
4861: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4862: LD_OWVAR 2
4866: PPUSH
4867: LD_INT 2
4869: PPUSH
4870: LD_INT 2
4872: PPUSH
4873: LD_INT 23
4875: PPUSH
4876: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: LD_INT 500
4887: PUSH
4888: LD_INT 3500
4890: PUSH
4891: LD_INT 5750
4893: PUSH
4894: LD_INT 10000
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// repeat wait ( [ 5 5$00 , 6 6$00 , 7 7$00 ] [ Difficulty ] ) ;
4903: LD_INT 10500
4905: PUSH
4906: LD_INT 12600
4908: PUSH
4909: LD_INT 14700
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_OWVAR 67
4921: ARRAY
4922: PPUSH
4923: CALL_OW 67
// for i = 1 to tmp do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_VAR 0 1
4941: PUSH
4942: FOR_TO
4943: IFFALSE 4975
// if points >= tmp [ i ] then
4945: LD_EXP 8
4949: PUSH
4950: LD_VAR 0 1
4954: PUSH
4955: LD_VAR 0 2
4959: ARRAY
4960: GREATEREQUAL
4961: IFFALSE 4973
// bonus_num := i ;
4963: LD_ADDR_EXP 12
4967: PUSH
4968: LD_VAR 0 2
4972: ST_TO_ADDR
4973: GO 4942
4975: POP
4976: POP
// case Query ( QBonusInfo ) of 1 :
4977: LD_STRING QBonusInfo
4979: PPUSH
4980: CALL_OW 97
4984: PUSH
4985: LD_INT 1
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5014
4993: POP
// SetArtifactUse ( your_side , art_use_exclamation , art_instant , main_base ) ; end ;
4994: LD_OWVAR 2
4998: PPUSH
4999: LD_INT 12
5001: PPUSH
5002: LD_INT 2
5004: PPUSH
5005: LD_INT 23
5007: PPUSH
5008: CALL_OW 468
5012: GO 5015
5014: POP
// until points >= 15000 ;
5015: LD_EXP 8
5019: PUSH
5020: LD_INT 15000
5022: GREATEREQUAL
5023: IFFALSE 4903
// end ; end_of_file
5025: PPOPN 2
5027: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5028: LD_INT 0
5030: PPUSH
5031: PPUSH
// dir := GetDir ( b ) ;
5032: LD_ADDR_VAR 0 4
5036: PUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 254
5046: ST_TO_ADDR
// if dir < 3 then
5047: LD_VAR 0 4
5051: PUSH
5052: LD_INT 3
5054: LESS
5055: IFFALSE 5073
// dir := dir + 3 else
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: LD_VAR 0 4
5066: PUSH
5067: LD_INT 3
5069: PLUS
5070: ST_TO_ADDR
5071: GO 5087
// dir := dir - 3 ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 3
5085: MINUS
5086: ST_TO_ADDR
// SetDir ( un , dir ) ;
5087: LD_VAR 0 1
5091: PPUSH
5092: LD_VAR 0 4
5096: PPUSH
5097: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5101: LD_VAR 0 1
5105: PPUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: CALL_OW 52
// end ;
5115: LD_VAR 0 3
5119: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5125: LD_ADDR_VAR 0 7
5129: PUSH
5130: LD_VAR 0 1
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_VAR 0 3
5145: PPUSH
5146: LD_VAR 0 4
5150: PPUSH
5151: CALL_OW 1
5155: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_VAR 0 2
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 1
5180: ST_TO_ADDR
// result := tab ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_VAR 0 1
5190: ST_TO_ADDR
// end ;
5191: LD_VAR 0 5
5195: RET
// export function IsDriver ( unit ) ; begin
5196: LD_INT 0
5198: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5199: LD_VAR 0 1
5203: PUSH
5204: LD_INT 55
5206: PUSH
5207: EMPTY
5208: LIST
5209: PPUSH
5210: CALL_OW 69
5214: IN
5215: IFFALSE 5234
// result := IsInUnit ( unit ) else
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: CALL_OW 310
5231: ST_TO_ADDR
5232: GO 5242
// result := false ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: LD_INT 0
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 2
5246: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5247: LD_INT 0
5249: PPUSH
5250: PPUSH
5251: PPUSH
// if not GetControl ( veh ) = control_manual then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 263
5261: PUSH
5262: LD_INT 1
5264: EQUAL
5265: NOT
5266: IFFALSE 5278
// result := false else
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
5276: GO 5423
// if veh in FilterAllUnits ( [ f_empty ] ) then
5278: LD_VAR 0 1
5282: PUSH
5283: LD_INT 58
5285: PUSH
5286: EMPTY
5287: LIST
5288: PPUSH
5289: CALL_OW 69
5293: IN
5294: IFFALSE 5306
// result := false else
5296: LD_ADDR_VAR 0 2
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
5304: GO 5423
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5306: LD_ADDR_VAR 0 4
5310: PUSH
5311: LD_INT 22
5313: PUSH
5314: LD_VAR 0 1
5318: PPUSH
5319: CALL_OW 255
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 55
5330: PUSH
5331: EMPTY
5332: LIST
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if not filter then
5343: LD_VAR 0 4
5347: NOT
5348: IFFALSE 5360
// result := false else
5350: LD_ADDR_VAR 0 2
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
5358: GO 5423
// for i = 1 to filter do
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_VAR 0 4
5374: PUSH
5375: FOR_TO
5376: IFFALSE 5421
// if IsDriver ( filter [ i ] ) = veh then
5378: LD_VAR 0 4
5382: PUSH
5383: LD_VAR 0 3
5387: ARRAY
5388: PPUSH
5389: CALL 5196 0 1
5393: PUSH
5394: LD_VAR 0 1
5398: EQUAL
5399: IFFALSE 5419
// begin result := filter [ i ] ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: LD_VAR 0 3
5415: ARRAY
5416: ST_TO_ADDR
// break ;
5417: GO 5421
// end ;
5419: GO 5375
5421: POP
5422: POP
// end ; end ; end_of_file
5423: LD_VAR 0 2
5427: RET
// on UnitDestroyed ( un ) do begin if un in [ legion_commander , main_base ] then
5428: LD_VAR 0 1
5432: PUSH
5433: LD_EXP 1
5437: PUSH
5438: LD_INT 23
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: IN
5445: IFFALSE 5455
// game_over := true ;
5447: LD_ADDR_EXP 7
5451: PUSH
5452: LD_INT 1
5454: ST_TO_ADDR
// if un = al_commander then
5455: LD_VAR 0 1
5459: PUSH
5460: LD_EXP 5
5464: EQUAL
5465: IFFALSE 5471
// ChangeSide ( ) ;
5467: CALL 2689 0 0
// if GetSide ( un ) = 7 then
5471: LD_VAR 0 1
5475: PPUSH
5476: CALL_OW 255
5480: PUSH
5481: LD_INT 7
5483: EQUAL
5484: IFFALSE 5602
// begin if GetClass ( un ) = class_apeman then
5486: LD_VAR 0 1
5490: PPUSH
5491: CALL_OW 257
5495: PUSH
5496: LD_INT 12
5498: EQUAL
5499: IFFALSE 5515
// points := points + 6 ;
5501: LD_ADDR_EXP 8
5505: PUSH
5506: LD_EXP 8
5510: PUSH
5511: LD_INT 6
5513: PLUS
5514: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5515: LD_VAR 0 1
5519: PPUSH
5520: CALL_OW 257
5524: PUSH
5525: LD_INT 17
5527: EQUAL
5528: IFFALSE 5544
// points := points + 11 ;
5530: LD_ADDR_EXP 8
5534: PUSH
5535: LD_EXP 8
5539: PUSH
5540: LD_INT 11
5542: PLUS
5543: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5544: LD_VAR 0 1
5548: PPUSH
5549: CALL_OW 257
5553: PUSH
5554: LD_INT 15
5556: EQUAL
5557: IFFALSE 5573
// points := points + 14 ;
5559: LD_ADDR_EXP 8
5563: PUSH
5564: LD_EXP 8
5568: PUSH
5569: LD_INT 14
5571: PLUS
5572: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5573: LD_VAR 0 1
5577: PPUSH
5578: CALL_OW 247
5582: PUSH
5583: LD_INT 2
5585: EQUAL
5586: IFFALSE 5602
// points := points + 50 ;
5588: LD_ADDR_EXP 8
5592: PUSH
5593: LD_EXP 8
5597: PUSH
5598: LD_INT 50
5600: PLUS
5601: ST_TO_ADDR
// end ; end ;
5602: PPOPN 1
5604: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5605: LD_EXP 5
5609: PPUSH
5610: CALL_OW 256
5614: PUSH
5615: LD_INT 1000
5617: LESS
5618: IFFALSE 5650
5620: GO 5622
5622: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5623: LD_EXP 5
5627: PPUSH
5628: CALL_OW 504
5632: PPUSH
5633: CALL_OW 255
5637: PUSH
5638: LD_INT 8
5640: EQUAL
5641: IFFALSE 5650
// YouLost (  ) ;
5643: LD_STRING 
5645: PPUSH
5646: CALL_OW 104
5650: END
// on EnterBuilding ( b , un ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] and GetClass ( un ) in [ class_apeman , class_apeman_soldier , class_apeman_kamikaze ] then
5651: LD_VAR 0 1
5655: PPUSH
5656: CALL_OW 266
5660: PUSH
5661: LD_INT 0
5663: PUSH
5664: LD_INT 1
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: IN
5671: PUSH
5672: LD_VAR 0 2
5676: PPUSH
5677: CALL_OW 257
5681: PUSH
5682: LD_INT 12
5684: PUSH
5685: LD_INT 15
5687: PUSH
5688: LD_INT 17
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: IN
5696: AND
5697: IFFALSE 5718
// begin wait ( 0 0$0.3 ) ;
5699: LD_INT 10
5701: PPUSH
5702: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
5706: LD_VAR 0 2
5710: PPUSH
5711: LD_INT 16
5713: PPUSH
5714: CALL_OW 336
// end ; end ;
5718: PPOPN 2
5720: END
// on DialogueSkipped ( value ) do var i ;
5721: LD_INT 0
5723: PPUSH
// begin RemoveUnit ( potter ) ;
5724: LD_EXP 4
5728: PPUSH
5729: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5733: LD_EXP 2
5737: PUSH
5738: LD_EXP 3
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: PPUSH
5747: CALL_OW 122
// Wait ( 1 ) ;
5751: LD_INT 1
5753: PPUSH
5754: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5758: LD_EXP 2
5762: PPUSH
5763: LD_INT 107
5765: PPUSH
5766: LD_INT 53
5768: PPUSH
5769: LD_INT 0
5771: PPUSH
5772: LD_INT 0
5774: PPUSH
5775: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5779: LD_EXP 3
5783: PPUSH
5784: LD_INT 108
5786: PPUSH
5787: LD_INT 53
5789: PPUSH
5790: LD_INT 0
5792: PPUSH
5793: LD_INT 0
5795: PPUSH
5796: CALL_OW 483
// Wait ( 1 ) ;
5800: LD_INT 1
5802: PPUSH
5803: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5807: LD_EXP 2
5811: PUSH
5812: LD_EXP 3
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: PPUSH
5821: LD_INT 108
5823: PPUSH
5824: LD_INT 1
5826: PPUSH
5827: CALL_OW 118
// end ;
5831: PPOPN 2
5833: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5834: LD_INT 0
5836: PPUSH
5837: PPUSH
5838: PPUSH
5839: PPUSH
5840: PPUSH
5841: PPUSH
// begin DialogueOn ;
5842: CALL_OW 6
// uc_side := 8 ;
5846: LD_ADDR_OWVAR 20
5850: PUSH
5851: LD_INT 8
5853: ST_TO_ADDR
// uc_nation := 2 ;
5854: LD_ADDR_OWVAR 21
5858: PUSH
5859: LD_INT 2
5861: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5862: LD_ADDR_VAR 0 5
5866: PUSH
5867: LD_STRING QBonus
5869: PUSH
5870: LD_EXP 12
5874: STR
5875: ST_TO_ADDR
// off := true ;
5876: LD_ADDR_VAR 0 6
5880: PUSH
5881: LD_INT 1
5883: ST_TO_ADDR
// units := [ ] ;
5884: LD_ADDR_VAR 0 7
5888: PUSH
5889: EMPTY
5890: ST_TO_ADDR
// crates := 0 ;
5891: LD_ADDR_VAR 0 8
5895: PUSH
5896: LD_INT 0
5898: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5899: LD_EXP 10
5903: PPUSH
5904: LD_STRING DVr-2
5906: PPUSH
5907: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5911: LD_INT 10
5913: PPUSH
5914: CALL_OW 67
// case Query ( bonus ) of 1 :
5918: LD_VAR 0 5
5922: PPUSH
5923: CALL_OW 97
5927: PUSH
5928: LD_INT 1
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5936
5934: GO 6021
5936: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5937: LD_ADDR_VAR 0 9
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 2
5947: PUSH
5948: LD_INT 5
5950: PUSH
5951: LD_INT 8
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: PUSH
5960: LD_EXP 12
5964: ARRAY
5965: ST_TO_ADDR
// for i = 1 to tmp do
5966: LD_ADDR_VAR 0 10
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_VAR 0 9
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6017
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5984: LD_INT 0
5986: PPUSH
5987: LD_INT 15
5989: PPUSH
5990: LD_VAR 0 9
5994: PPUSH
5995: CALL_OW 380
// units := units ^ CreateHuman ;
5999: LD_ADDR_VAR 0 7
6003: PUSH
6004: LD_VAR 0 7
6008: PUSH
6009: CALL_OW 44
6013: ADD
6014: ST_TO_ADDR
// end ;
6015: GO 5981
6017: POP
6018: POP
// end ; 2 :
6019: GO 6429
6021: LD_INT 2
6023: DOUBLE
6024: EQUAL
6025: IFTRUE 6029
6027: GO 6061
6029: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
6030: LD_ADDR_VAR 0 8
6034: PUSH
6035: LD_INT 100
6037: PUSH
6038: LD_INT 150
6040: PUSH
6041: LD_INT 350
6043: PUSH
6044: LD_INT 500
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: PUSH
6053: LD_EXP 12
6057: ARRAY
6058: ST_TO_ADDR
// end ; 3 :
6059: GO 6429
6061: LD_INT 3
6063: DOUBLE
6064: EQUAL
6065: IFTRUE 6069
6067: GO 6409
6069: POP
// begin if bonus_num = 1 then
6070: LD_EXP 12
6074: PUSH
6075: LD_INT 1
6077: EQUAL
6078: IFFALSE 6088
// ignore_wave := true ;
6080: LD_ADDR_EXP 13
6084: PUSH
6085: LD_INT 1
6087: ST_TO_ADDR
// if bonus_num = 2 then
6088: LD_EXP 12
6092: PUSH
6093: LD_INT 2
6095: EQUAL
6096: IFFALSE 6216
// begin for i = 1 to 2 do
6098: LD_ADDR_VAR 0 10
6102: PUSH
6103: DOUBLE
6104: LD_INT 1
6106: DEC
6107: ST_TO_ADDR
6108: LD_INT 2
6110: PUSH
6111: FOR_TO
6112: IFFALSE 6214
// begin uc_nation := nation_arabian ;
6114: LD_ADDR_OWVAR 21
6118: PUSH
6119: LD_INT 2
6121: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6122: LD_ADDR_OWVAR 37
6126: PUSH
6127: LD_INT 14
6129: ST_TO_ADDR
// vc_engine := engine_siberite ;
6130: LD_ADDR_OWVAR 39
6134: PUSH
6135: LD_INT 3
6137: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6138: LD_ADDR_OWVAR 38
6142: PUSH
6143: LD_INT 2
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PUSH
6153: LD_INT 1
6155: PPUSH
6156: LD_INT 2
6158: PPUSH
6159: CALL_OW 12
6163: ARRAY
6164: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6165: LD_ADDR_OWVAR 40
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: LD_INT 27
6175: PUSH
6176: LD_INT 25
6178: PUSH
6179: EMPTY
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 1
6186: PPUSH
6187: LD_INT 3
6189: PPUSH
6190: CALL_OW 12
6194: ARRAY
6195: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6196: LD_ADDR_VAR 0 7
6200: PUSH
6201: LD_VAR 0 7
6205: PUSH
6206: CALL_OW 45
6210: ADD
6211: ST_TO_ADDR
// end ;
6212: GO 6111
6214: POP
6215: POP
// end ; if bonus_num = 3 then
6216: LD_EXP 12
6220: PUSH
6221: LD_INT 3
6223: EQUAL
6224: IFFALSE 6348
// begin for i = 1 to 4 do
6226: LD_ADDR_VAR 0 10
6230: PUSH
6231: DOUBLE
6232: LD_INT 1
6234: DEC
6235: ST_TO_ADDR
6236: LD_INT 4
6238: PUSH
6239: FOR_TO
6240: IFFALSE 6346
// begin uc_nation := nation_arabian ;
6242: LD_ADDR_OWVAR 21
6246: PUSH
6247: LD_INT 2
6249: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6250: LD_ADDR_OWVAR 37
6254: PUSH
6255: LD_INT 14
6257: ST_TO_ADDR
// vc_engine := engine_siberite ;
6258: LD_ADDR_OWVAR 39
6262: PUSH
6263: LD_INT 3
6265: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6266: LD_ADDR_OWVAR 38
6270: PUSH
6271: LD_INT 2
6273: PUSH
6274: LD_INT 5
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PUSH
6281: LD_INT 1
6283: PPUSH
6284: LD_INT 2
6286: PPUSH
6287: CALL_OW 12
6291: ARRAY
6292: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6293: LD_ADDR_OWVAR 40
6297: PUSH
6298: LD_INT 28
6300: PUSH
6301: LD_INT 27
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: LD_INT 25
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 1
6318: PPUSH
6319: LD_INT 4
6321: PPUSH
6322: CALL_OW 12
6326: ARRAY
6327: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6328: LD_ADDR_VAR 0 7
6332: PUSH
6333: LD_VAR 0 7
6337: PUSH
6338: CALL_OW 45
6342: ADD
6343: ST_TO_ADDR
// end ;
6344: GO 6239
6346: POP
6347: POP
// end ; if bonus_num = 4 then
6348: LD_EXP 12
6352: PUSH
6353: LD_INT 4
6355: EQUAL
6356: IFFALSE 6407
// for i = 1 to 3 do
6358: LD_ADDR_VAR 0 10
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_INT 3
6370: PUSH
6371: FOR_TO
6372: IFFALSE 6405
// begin PrepareHuman ( false , 3 , 8 ) ;
6374: LD_INT 0
6376: PPUSH
6377: LD_INT 3
6379: PPUSH
6380: LD_INT 8
6382: PPUSH
6383: CALL_OW 380
// units := units ^ CreateHuman ;
6387: LD_ADDR_VAR 0 7
6391: PUSH
6392: LD_VAR 0 7
6396: PUSH
6397: CALL_OW 44
6401: ADD
6402: ST_TO_ADDR
// end ;
6403: GO 6371
6405: POP
6406: POP
// end ; 4 :
6407: GO 6429
6409: LD_INT 4
6411: DOUBLE
6412: EQUAL
6413: IFTRUE 6417
6415: GO 6428
6417: POP
// off := false ; end ;
6418: LD_ADDR_VAR 0 6
6422: PUSH
6423: LD_INT 0
6425: ST_TO_ADDR
6426: GO 6429
6428: POP
// DialogueOff ;
6429: CALL_OW 7
// if not off then
6433: LD_VAR 0 6
6437: NOT
6438: IFFALSE 6444
// exit else
6440: GO 6623
6442: GO 6497
// begin SetArtifactUse ( your_side , art_use_exclamation , art_no , main_base ) ;
6444: LD_OWVAR 2
6448: PPUSH
6449: LD_INT 12
6451: PPUSH
6452: LD_INT 0
6454: PPUSH
6455: LD_INT 23
6457: PPUSH
6458: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6462: LD_EXP 10
6466: PPUSH
6467: LD_STRING DVr-3
6469: PUSH
6470: LD_STRING DVr-3a
6472: PUSH
6473: LD_STRING DVr-3b
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_INT 3
6486: PPUSH
6487: CALL_OW 12
6491: ARRAY
6492: PPUSH
6493: CALL_OW 94
// end ; if units then
6497: LD_VAR 0 7
6501: IFFALSE 6565
// for i in units do
6503: LD_ADDR_VAR 0 10
6507: PUSH
6508: LD_VAR 0 7
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6563
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6516: LD_VAR 0 10
6520: PPUSH
6521: LD_INT 92
6523: PPUSH
6524: LD_INT 49
6526: PPUSH
6527: LD_INT 20
6529: PPUSH
6530: LD_INT 0
6532: PPUSH
6533: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6537: LD_VAR 0 10
6541: PPUSH
6542: CALL_OW 250
6546: PPUSH
6547: LD_VAR 0 10
6551: PPUSH
6552: CALL_OW 251
6556: PPUSH
6557: CALL_OW 494
// end ;
6561: GO 6513
6563: POP
6564: POP
// if crates then
6565: LD_VAR 0 8
6569: IFFALSE 6623
// for i = 1 to ( crates div 50 ) do
6571: LD_ADDR_VAR 0 10
6575: PUSH
6576: DOUBLE
6577: LD_INT 1
6579: DEC
6580: ST_TO_ADDR
6581: LD_VAR 0 8
6585: PUSH
6586: LD_INT 50
6588: DIV
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6621
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6593: LD_INT 5
6595: PPUSH
6596: LD_INT 92
6598: PPUSH
6599: LD_INT 49
6601: PPUSH
6602: LD_INT 30
6604: PPUSH
6605: LD_INT 1
6607: PPUSH
6608: CALL_OW 56
// wait ( 0 0$02 ) ;
6612: LD_INT 70
6614: PPUSH
6615: CALL_OW 67
// end ;
6619: GO 6590
6621: POP
6622: POP
// end ;
6623: PPOPN 10
6625: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6626: LD_VAR 0 1
6630: PPUSH
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_VAR 0 3
6640: PPUSH
6641: CALL 11598 0 3
// end ;
6645: PPOPN 3
6647: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6648: LD_VAR 0 1
6652: PPUSH
6653: CALL 11696 0 1
// end ; end_of_file
6657: PPOPN 1
6659: END
// every 0 0$01 trigger not game_over do
6660: LD_EXP 7
6664: NOT
6665: IFFALSE 6698
6667: GO 6669
6669: DISABLE
// begin enable ;
6670: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6671: LD_ADDR_OWVAR 47
6675: PUSH
6676: LD_STRING #tick
6678: PUSH
6679: LD_OWVAR 1
6683: PUSH
6684: LD_STRING #points
6686: PUSH
6687: LD_EXP 8
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: ST_TO_ADDR
// end ;
6698: END
// every 0 0$01 trigger game_over do
6699: LD_EXP 7
6703: IFFALSE 6762
6705: GO 6707
6707: DISABLE
// begin Wait ( 0 0$02 ) ;
6708: LD_INT 70
6710: PPUSH
6711: CALL_OW 67
// DialogueOn ;
6715: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6719: LD_ADDR_OWVAR 47
6723: PUSH
6724: LD_STRING #game-points
6726: PUSH
6727: LD_OWVAR 78
6731: PUSH
6732: LD_EXP 8
6736: PUSH
6737: LD_STRING #game-time
6739: PUSH
6740: LD_OWVAR 1
6744: PUSH
6745: LD_STRING #game-difficulty
6747: PUSH
6748: LD_OWVAR 67
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: ST_TO_ADDR
// end ; end_of_file
6762: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6763: LD_OWVAR 1
6767: PUSH
6768: LD_INT 52500
6770: LESS
6771: IFFALSE 6795
6773: GO 6775
6775: DISABLE
// begin enable ;
6776: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6777: LD_INT 1
6779: PPUSH
6780: LD_INT 5
6782: PPUSH
6783: CALL_OW 12
6787: PPUSH
6788: LD_INT 1
6790: PPUSH
6791: CALL_OW 57
// end ; end_of_file
6795: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
6796: GO 6798
6798: DISABLE
// begin ru_radar := 98 ;
6799: LD_ADDR_EXP 14
6803: PUSH
6804: LD_INT 98
6806: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
6807: LD_ADDR_EXP 15
6811: PUSH
6812: LD_INT 89
6814: ST_TO_ADDR
// us_hack := 99 ;
6815: LD_ADDR_EXP 16
6819: PUSH
6820: LD_INT 99
6822: ST_TO_ADDR
// us_artillery := 97 ;
6823: LD_ADDR_EXP 17
6827: PUSH
6828: LD_INT 97
6830: ST_TO_ADDR
// ar_bio_bomb := 91 ;
6831: LD_ADDR_EXP 18
6835: PUSH
6836: LD_INT 91
6838: ST_TO_ADDR
// end ; end_of_file end_of_file
6839: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
6840: GO 6842
6842: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6843: LD_STRING initStreamRollete();
6845: PPUSH
6846: CALL_OW 559
// InitStreamMode ;
6850: CALL 6855 0 0
// end ;
6854: END
// function InitStreamMode ; begin
6855: LD_INT 0
6857: PPUSH
// streamModeActive := false ;
6858: LD_ADDR_EXP 19
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// sRocket := false ;
6866: LD_ADDR_EXP 22
6870: PUSH
6871: LD_INT 0
6873: ST_TO_ADDR
// sSpeed := false ;
6874: LD_ADDR_EXP 21
6878: PUSH
6879: LD_INT 0
6881: ST_TO_ADDR
// sEngine := false ;
6882: LD_ADDR_EXP 23
6886: PUSH
6887: LD_INT 0
6889: ST_TO_ADDR
// sSpec := false ;
6890: LD_ADDR_EXP 20
6894: PUSH
6895: LD_INT 0
6897: ST_TO_ADDR
// sLevel := false ;
6898: LD_ADDR_EXP 24
6902: PUSH
6903: LD_INT 0
6905: ST_TO_ADDR
// sArmoury := false ;
6906: LD_ADDR_EXP 25
6910: PUSH
6911: LD_INT 0
6913: ST_TO_ADDR
// sRadar := false ;
6914: LD_ADDR_EXP 26
6918: PUSH
6919: LD_INT 0
6921: ST_TO_ADDR
// sBunker := false ;
6922: LD_ADDR_EXP 27
6926: PUSH
6927: LD_INT 0
6929: ST_TO_ADDR
// sHack := false ;
6930: LD_ADDR_EXP 28
6934: PUSH
6935: LD_INT 0
6937: ST_TO_ADDR
// sFire := false ;
6938: LD_ADDR_EXP 29
6942: PUSH
6943: LD_INT 0
6945: ST_TO_ADDR
// sRefresh := false ;
6946: LD_ADDR_EXP 30
6950: PUSH
6951: LD_INT 0
6953: ST_TO_ADDR
// sExp := false ;
6954: LD_ADDR_EXP 31
6958: PUSH
6959: LD_INT 0
6961: ST_TO_ADDR
// sDepot := false ;
6962: LD_ADDR_EXP 32
6966: PUSH
6967: LD_INT 0
6969: ST_TO_ADDR
// sFlag := false ;
6970: LD_ADDR_EXP 33
6974: PUSH
6975: LD_INT 0
6977: ST_TO_ADDR
// sKamikadze := false ;
6978: LD_ADDR_EXP 41
6982: PUSH
6983: LD_INT 0
6985: ST_TO_ADDR
// sTroll := false ;
6986: LD_ADDR_EXP 42
6990: PUSH
6991: LD_INT 0
6993: ST_TO_ADDR
// sSlow := false ;
6994: LD_ADDR_EXP 43
6998: PUSH
6999: LD_INT 0
7001: ST_TO_ADDR
// sLack := false ;
7002: LD_ADDR_EXP 44
7006: PUSH
7007: LD_INT 0
7009: ST_TO_ADDR
// sTank := false ;
7010: LD_ADDR_EXP 46
7014: PUSH
7015: LD_INT 0
7017: ST_TO_ADDR
// sRemote := false ;
7018: LD_ADDR_EXP 47
7022: PUSH
7023: LD_INT 0
7025: ST_TO_ADDR
// sPowell := false ;
7026: LD_ADDR_EXP 48
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// sTeleport := false ;
7034: LD_ADDR_EXP 51
7038: PUSH
7039: LD_INT 0
7041: ST_TO_ADDR
// sOilTower := false ;
7042: LD_ADDR_EXP 53
7046: PUSH
7047: LD_INT 0
7049: ST_TO_ADDR
// sShovel := false ;
7050: LD_ADDR_EXP 54
7054: PUSH
7055: LD_INT 0
7057: ST_TO_ADDR
// sSheik := false ;
7058: LD_ADDR_EXP 55
7062: PUSH
7063: LD_INT 0
7065: ST_TO_ADDR
// sSold := false ;
7066: LD_ADDR_EXP 34
7070: PUSH
7071: LD_INT 0
7073: ST_TO_ADDR
// sDiff := false ;
7074: LD_ADDR_EXP 35
7078: PUSH
7079: LD_INT 0
7081: ST_TO_ADDR
// sFog := false ;
7082: LD_ADDR_EXP 38
7086: PUSH
7087: LD_INT 0
7089: ST_TO_ADDR
// sReset := false ;
7090: LD_ADDR_EXP 39
7094: PUSH
7095: LD_INT 0
7097: ST_TO_ADDR
// sSun := false ;
7098: LD_ADDR_EXP 40
7102: PUSH
7103: LD_INT 0
7105: ST_TO_ADDR
// sTiger := false ;
7106: LD_ADDR_EXP 36
7110: PUSH
7111: LD_INT 0
7113: ST_TO_ADDR
// sBomb := false ;
7114: LD_ADDR_EXP 37
7118: PUSH
7119: LD_INT 0
7121: ST_TO_ADDR
// sWound := false ;
7122: LD_ADDR_EXP 45
7126: PUSH
7127: LD_INT 0
7129: ST_TO_ADDR
// sBetray := false ;
7130: LD_ADDR_EXP 49
7134: PUSH
7135: LD_INT 0
7137: ST_TO_ADDR
// sContamin := false ;
7138: LD_ADDR_EXP 50
7142: PUSH
7143: LD_INT 0
7145: ST_TO_ADDR
// sOil := false ;
7146: LD_ADDR_EXP 52
7150: PUSH
7151: LD_INT 0
7153: ST_TO_ADDR
// sStu := false ;
7154: LD_ADDR_EXP 56
7158: PUSH
7159: LD_INT 0
7161: ST_TO_ADDR
// end ;
7162: LD_VAR 0 1
7166: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
7167: LD_VAR 0 2
7171: PUSH
7172: LD_INT 100
7174: EQUAL
7175: IFFALSE 7872
// begin if not StreamModeActive then
7177: LD_EXP 19
7181: NOT
7182: IFFALSE 7192
// StreamModeActive := true ;
7184: LD_ADDR_EXP 19
7188: PUSH
7189: LD_INT 1
7191: ST_TO_ADDR
// if p3 = 0 then
7192: LD_VAR 0 3
7196: PUSH
7197: LD_INT 0
7199: EQUAL
7200: IFFALSE 7206
// InitStreamMode ;
7202: CALL 6855 0 0
// if p3 = 1 then
7206: LD_VAR 0 3
7210: PUSH
7211: LD_INT 1
7213: EQUAL
7214: IFFALSE 7224
// sRocket := true ;
7216: LD_ADDR_EXP 22
7220: PUSH
7221: LD_INT 1
7223: ST_TO_ADDR
// if p3 = 2 then
7224: LD_VAR 0 3
7228: PUSH
7229: LD_INT 2
7231: EQUAL
7232: IFFALSE 7242
// sSpeed := true ;
7234: LD_ADDR_EXP 21
7238: PUSH
7239: LD_INT 1
7241: ST_TO_ADDR
// if p3 = 3 then
7242: LD_VAR 0 3
7246: PUSH
7247: LD_INT 3
7249: EQUAL
7250: IFFALSE 7260
// sEngine := true ;
7252: LD_ADDR_EXP 23
7256: PUSH
7257: LD_INT 1
7259: ST_TO_ADDR
// if p3 = 4 then
7260: LD_VAR 0 3
7264: PUSH
7265: LD_INT 4
7267: EQUAL
7268: IFFALSE 7278
// sSpec := true ;
7270: LD_ADDR_EXP 20
7274: PUSH
7275: LD_INT 1
7277: ST_TO_ADDR
// if p3 = 5 then
7278: LD_VAR 0 3
7282: PUSH
7283: LD_INT 5
7285: EQUAL
7286: IFFALSE 7296
// sLevel := true ;
7288: LD_ADDR_EXP 24
7292: PUSH
7293: LD_INT 1
7295: ST_TO_ADDR
// if p3 = 6 then
7296: LD_VAR 0 3
7300: PUSH
7301: LD_INT 6
7303: EQUAL
7304: IFFALSE 7314
// sArmoury := true ;
7306: LD_ADDR_EXP 25
7310: PUSH
7311: LD_INT 1
7313: ST_TO_ADDR
// if p3 = 7 then
7314: LD_VAR 0 3
7318: PUSH
7319: LD_INT 7
7321: EQUAL
7322: IFFALSE 7332
// sRadar := true ;
7324: LD_ADDR_EXP 26
7328: PUSH
7329: LD_INT 1
7331: ST_TO_ADDR
// if p3 = 8 then
7332: LD_VAR 0 3
7336: PUSH
7337: LD_INT 8
7339: EQUAL
7340: IFFALSE 7350
// sBunker := true ;
7342: LD_ADDR_EXP 27
7346: PUSH
7347: LD_INT 1
7349: ST_TO_ADDR
// if p3 = 9 then
7350: LD_VAR 0 3
7354: PUSH
7355: LD_INT 9
7357: EQUAL
7358: IFFALSE 7368
// sHack := true ;
7360: LD_ADDR_EXP 28
7364: PUSH
7365: LD_INT 1
7367: ST_TO_ADDR
// if p3 = 10 then
7368: LD_VAR 0 3
7372: PUSH
7373: LD_INT 10
7375: EQUAL
7376: IFFALSE 7386
// sFire := true ;
7378: LD_ADDR_EXP 29
7382: PUSH
7383: LD_INT 1
7385: ST_TO_ADDR
// if p3 = 11 then
7386: LD_VAR 0 3
7390: PUSH
7391: LD_INT 11
7393: EQUAL
7394: IFFALSE 7404
// sRefresh := true ;
7396: LD_ADDR_EXP 30
7400: PUSH
7401: LD_INT 1
7403: ST_TO_ADDR
// if p3 = 12 then
7404: LD_VAR 0 3
7408: PUSH
7409: LD_INT 12
7411: EQUAL
7412: IFFALSE 7422
// sExp := true ;
7414: LD_ADDR_EXP 31
7418: PUSH
7419: LD_INT 1
7421: ST_TO_ADDR
// if p3 = 13 then
7422: LD_VAR 0 3
7426: PUSH
7427: LD_INT 13
7429: EQUAL
7430: IFFALSE 7440
// sDepot := true ;
7432: LD_ADDR_EXP 32
7436: PUSH
7437: LD_INT 1
7439: ST_TO_ADDR
// if p3 = 14 then
7440: LD_VAR 0 3
7444: PUSH
7445: LD_INT 14
7447: EQUAL
7448: IFFALSE 7458
// sFlag := true ;
7450: LD_ADDR_EXP 33
7454: PUSH
7455: LD_INT 1
7457: ST_TO_ADDR
// if p3 = 15 then
7458: LD_VAR 0 3
7462: PUSH
7463: LD_INT 15
7465: EQUAL
7466: IFFALSE 7476
// sKamikadze := true ;
7468: LD_ADDR_EXP 41
7472: PUSH
7473: LD_INT 1
7475: ST_TO_ADDR
// if p3 = 16 then
7476: LD_VAR 0 3
7480: PUSH
7481: LD_INT 16
7483: EQUAL
7484: IFFALSE 7494
// sTroll := true ;
7486: LD_ADDR_EXP 42
7490: PUSH
7491: LD_INT 1
7493: ST_TO_ADDR
// if p3 = 17 then
7494: LD_VAR 0 3
7498: PUSH
7499: LD_INT 17
7501: EQUAL
7502: IFFALSE 7512
// sSlow := true ;
7504: LD_ADDR_EXP 43
7508: PUSH
7509: LD_INT 1
7511: ST_TO_ADDR
// if p3 = 18 then
7512: LD_VAR 0 3
7516: PUSH
7517: LD_INT 18
7519: EQUAL
7520: IFFALSE 7530
// sLack := true ;
7522: LD_ADDR_EXP 44
7526: PUSH
7527: LD_INT 1
7529: ST_TO_ADDR
// if p3 = 19 then
7530: LD_VAR 0 3
7534: PUSH
7535: LD_INT 19
7537: EQUAL
7538: IFFALSE 7548
// sTank := true ;
7540: LD_ADDR_EXP 46
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// if p3 = 20 then
7548: LD_VAR 0 3
7552: PUSH
7553: LD_INT 20
7555: EQUAL
7556: IFFALSE 7566
// sRemote := true ;
7558: LD_ADDR_EXP 47
7562: PUSH
7563: LD_INT 1
7565: ST_TO_ADDR
// if p3 = 21 then
7566: LD_VAR 0 3
7570: PUSH
7571: LD_INT 21
7573: EQUAL
7574: IFFALSE 7584
// sPowell := true ;
7576: LD_ADDR_EXP 48
7580: PUSH
7581: LD_INT 1
7583: ST_TO_ADDR
// if p3 = 22 then
7584: LD_VAR 0 3
7588: PUSH
7589: LD_INT 22
7591: EQUAL
7592: IFFALSE 7602
// sTeleport := true ;
7594: LD_ADDR_EXP 51
7598: PUSH
7599: LD_INT 1
7601: ST_TO_ADDR
// if p3 = 23 then
7602: LD_VAR 0 3
7606: PUSH
7607: LD_INT 23
7609: EQUAL
7610: IFFALSE 7620
// sOilTower := true ;
7612: LD_ADDR_EXP 53
7616: PUSH
7617: LD_INT 1
7619: ST_TO_ADDR
// if p3 = 24 then
7620: LD_VAR 0 3
7624: PUSH
7625: LD_INT 24
7627: EQUAL
7628: IFFALSE 7638
// sShovel := true ;
7630: LD_ADDR_EXP 54
7634: PUSH
7635: LD_INT 1
7637: ST_TO_ADDR
// if p3 = 25 then
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 25
7645: EQUAL
7646: IFFALSE 7656
// sSheik := true ;
7648: LD_ADDR_EXP 55
7652: PUSH
7653: LD_INT 1
7655: ST_TO_ADDR
// if p3 = 101 then
7656: LD_VAR 0 3
7660: PUSH
7661: LD_INT 101
7663: EQUAL
7664: IFFALSE 7674
// sSold := true ;
7666: LD_ADDR_EXP 34
7670: PUSH
7671: LD_INT 1
7673: ST_TO_ADDR
// if p3 = 102 then
7674: LD_VAR 0 3
7678: PUSH
7679: LD_INT 102
7681: EQUAL
7682: IFFALSE 7692
// sDiff := true ;
7684: LD_ADDR_EXP 35
7688: PUSH
7689: LD_INT 1
7691: ST_TO_ADDR
// if p3 = 103 then
7692: LD_VAR 0 3
7696: PUSH
7697: LD_INT 103
7699: EQUAL
7700: IFFALSE 7710
// sFog := true ;
7702: LD_ADDR_EXP 38
7706: PUSH
7707: LD_INT 1
7709: ST_TO_ADDR
// if p3 = 104 then
7710: LD_VAR 0 3
7714: PUSH
7715: LD_INT 104
7717: EQUAL
7718: IFFALSE 7728
// sReset := true ;
7720: LD_ADDR_EXP 39
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// if p3 = 105 then
7728: LD_VAR 0 3
7732: PUSH
7733: LD_INT 105
7735: EQUAL
7736: IFFALSE 7746
// sSun := true ;
7738: LD_ADDR_EXP 40
7742: PUSH
7743: LD_INT 1
7745: ST_TO_ADDR
// if p3 = 106 then
7746: LD_VAR 0 3
7750: PUSH
7751: LD_INT 106
7753: EQUAL
7754: IFFALSE 7764
// sTiger := true ;
7756: LD_ADDR_EXP 36
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// if p3 = 107 then
7764: LD_VAR 0 3
7768: PUSH
7769: LD_INT 107
7771: EQUAL
7772: IFFALSE 7782
// sBomb := true ;
7774: LD_ADDR_EXP 37
7778: PUSH
7779: LD_INT 1
7781: ST_TO_ADDR
// if p3 = 108 then
7782: LD_VAR 0 3
7786: PUSH
7787: LD_INT 108
7789: EQUAL
7790: IFFALSE 7800
// sWound := true ;
7792: LD_ADDR_EXP 45
7796: PUSH
7797: LD_INT 1
7799: ST_TO_ADDR
// if p3 = 109 then
7800: LD_VAR 0 3
7804: PUSH
7805: LD_INT 109
7807: EQUAL
7808: IFFALSE 7818
// sBetray := true ;
7810: LD_ADDR_EXP 49
7814: PUSH
7815: LD_INT 1
7817: ST_TO_ADDR
// if p3 = 110 then
7818: LD_VAR 0 3
7822: PUSH
7823: LD_INT 110
7825: EQUAL
7826: IFFALSE 7836
// sContamin := true ;
7828: LD_ADDR_EXP 50
7832: PUSH
7833: LD_INT 1
7835: ST_TO_ADDR
// if p3 = 111 then
7836: LD_VAR 0 3
7840: PUSH
7841: LD_INT 111
7843: EQUAL
7844: IFFALSE 7854
// sOil := true ;
7846: LD_ADDR_EXP 52
7850: PUSH
7851: LD_INT 1
7853: ST_TO_ADDR
// if p3 = 112 then
7854: LD_VAR 0 3
7858: PUSH
7859: LD_INT 112
7861: EQUAL
7862: IFFALSE 7872
// sStu := true ;
7864: LD_ADDR_EXP 56
7868: PUSH
7869: LD_INT 1
7871: ST_TO_ADDR
// end ; end ;
7872: PPOPN 6
7874: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7875: LD_EXP 19
7879: PUSH
7880: LD_EXP 22
7884: AND
7885: IFFALSE 8009
7887: GO 7889
7889: DISABLE
7890: LD_INT 0
7892: PPUSH
7893: PPUSH
// begin enable ;
7894: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7895: LD_ADDR_VAR 0 2
7899: PUSH
7900: LD_INT 22
7902: PUSH
7903: LD_OWVAR 2
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: LD_INT 2
7914: PUSH
7915: LD_INT 34
7917: PUSH
7918: LD_INT 7
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 34
7927: PUSH
7928: LD_INT 45
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 34
7937: PUSH
7938: LD_INT 28
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 34
7947: PUSH
7948: LD_INT 47
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PPUSH
7966: CALL_OW 69
7970: ST_TO_ADDR
// if not tmp then
7971: LD_VAR 0 2
7975: NOT
7976: IFFALSE 7980
// exit ;
7978: GO 8009
// for i in tmp do
7980: LD_ADDR_VAR 0 1
7984: PUSH
7985: LD_VAR 0 2
7989: PUSH
7990: FOR_IN
7991: IFFALSE 8007
// begin SetLives ( i , 0 ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 0
8000: PPUSH
8001: CALL_OW 234
// end ;
8005: GO 7990
8007: POP
8008: POP
// end ;
8009: PPOPN 2
8011: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8012: LD_EXP 19
8016: PUSH
8017: LD_EXP 23
8021: AND
8022: IFFALSE 8103
8024: GO 8026
8026: DISABLE
8027: LD_INT 0
8029: PPUSH
8030: PPUSH
// begin enable ;
8031: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8032: LD_ADDR_VAR 0 2
8036: PUSH
8037: LD_INT 22
8039: PUSH
8040: LD_OWVAR 2
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: LD_INT 32
8051: PUSH
8052: LD_INT 3
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PPUSH
8063: CALL_OW 69
8067: ST_TO_ADDR
// if not tmp then
8068: LD_VAR 0 2
8072: NOT
8073: IFFALSE 8077
// exit ;
8075: GO 8103
// for i in tmp do
8077: LD_ADDR_VAR 0 1
8081: PUSH
8082: LD_VAR 0 2
8086: PUSH
8087: FOR_IN
8088: IFFALSE 8101
// begin DestroyUnit ( i ) ;
8090: LD_VAR 0 1
8094: PPUSH
8095: CALL_OW 65
// end ;
8099: GO 8087
8101: POP
8102: POP
// end ;
8103: PPOPN 2
8105: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
8106: LD_EXP 19
8110: PUSH
8111: LD_EXP 20
8115: AND
8116: IFFALSE 8209
8118: GO 8120
8120: DISABLE
8121: LD_INT 0
8123: PPUSH
// begin enable ;
8124: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: LD_INT 22
8132: PUSH
8133: LD_OWVAR 2
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: PUSH
8142: LD_INT 2
8144: PUSH
8145: LD_INT 25
8147: PUSH
8148: LD_INT 5
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 25
8157: PUSH
8158: LD_INT 9
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: LD_INT 25
8167: PUSH
8168: LD_INT 8
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: LIST
8179: LIST
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: PPUSH
8185: CALL_OW 69
8189: PUSH
8190: FOR_IN
8191: IFFALSE 8207
// begin SetClass ( i , 1 ) ;
8193: LD_VAR 0 1
8197: PPUSH
8198: LD_INT 1
8200: PPUSH
8201: CALL_OW 336
// end ;
8205: GO 8190
8207: POP
8208: POP
// end ;
8209: PPOPN 1
8211: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
8212: LD_EXP 19
8216: PUSH
8217: LD_EXP 21
8221: AND
8222: PUSH
8223: LD_OWVAR 65
8227: PUSH
8228: LD_INT 7
8230: LESS
8231: AND
8232: IFFALSE 8246
8234: GO 8236
8236: DISABLE
// begin enable ;
8237: ENABLE
// game_speed := 7 ;
8238: LD_ADDR_OWVAR 65
8242: PUSH
8243: LD_INT 7
8245: ST_TO_ADDR
// end ;
8246: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
8247: LD_EXP 19
8251: PUSH
8252: LD_EXP 24
8256: AND
8257: IFFALSE 8459
8259: GO 8261
8261: DISABLE
8262: LD_INT 0
8264: PPUSH
8265: PPUSH
8266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
8267: LD_ADDR_VAR 0 3
8271: PUSH
8272: LD_INT 81
8274: PUSH
8275: LD_OWVAR 2
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: PUSH
8284: LD_INT 21
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: EMPTY
8291: LIST
8292: LIST
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PPUSH
8298: CALL_OW 69
8302: ST_TO_ADDR
// if not tmp then
8303: LD_VAR 0 3
8307: NOT
8308: IFFALSE 8312
// exit ;
8310: GO 8459
// if tmp > 5 then
8312: LD_VAR 0 3
8316: PUSH
8317: LD_INT 5
8319: GREATER
8320: IFFALSE 8332
// k := 5 else
8322: LD_ADDR_VAR 0 2
8326: PUSH
8327: LD_INT 5
8329: ST_TO_ADDR
8330: GO 8342
// k := tmp ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 3
8341: ST_TO_ADDR
// for i := 1 to k do
8342: LD_ADDR_VAR 0 1
8346: PUSH
8347: DOUBLE
8348: LD_INT 1
8350: DEC
8351: ST_TO_ADDR
8352: LD_VAR 0 2
8356: PUSH
8357: FOR_TO
8358: IFFALSE 8457
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
8360: LD_VAR 0 3
8364: PUSH
8365: LD_VAR 0 1
8369: ARRAY
8370: PPUSH
8371: LD_VAR 0 1
8375: PUSH
8376: LD_INT 4
8378: MOD
8379: PUSH
8380: LD_INT 1
8382: PLUS
8383: PPUSH
8384: CALL_OW 259
8388: PUSH
8389: LD_INT 10
8391: LESS
8392: IFFALSE 8455
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
8394: LD_VAR 0 3
8398: PUSH
8399: LD_VAR 0 1
8403: ARRAY
8404: PPUSH
8405: LD_VAR 0 1
8409: PUSH
8410: LD_INT 4
8412: MOD
8413: PUSH
8414: LD_INT 1
8416: PLUS
8417: PPUSH
8418: LD_VAR 0 3
8422: PUSH
8423: LD_VAR 0 1
8427: ARRAY
8428: PPUSH
8429: LD_VAR 0 1
8433: PUSH
8434: LD_INT 4
8436: MOD
8437: PUSH
8438: LD_INT 1
8440: PLUS
8441: PPUSH
8442: CALL_OW 259
8446: PUSH
8447: LD_INT 1
8449: PLUS
8450: PPUSH
8451: CALL_OW 237
8455: GO 8357
8457: POP
8458: POP
// end ;
8459: PPOPN 3
8461: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
8462: LD_EXP 19
8466: PUSH
8467: LD_EXP 25
8471: AND
8472: IFFALSE 8492
8474: GO 8476
8476: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
8477: LD_INT 4
8479: PPUSH
8480: LD_OWVAR 2
8484: PPUSH
8485: LD_INT 0
8487: PPUSH
8488: CALL_OW 324
8492: END
// every 0 0$1 trigger StreamModeActive and sShovel do
8493: LD_EXP 19
8497: PUSH
8498: LD_EXP 54
8502: AND
8503: IFFALSE 8523
8505: GO 8507
8507: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
8508: LD_INT 19
8510: PPUSH
8511: LD_OWVAR 2
8515: PPUSH
8516: LD_INT 0
8518: PPUSH
8519: CALL_OW 324
8523: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
8524: LD_EXP 19
8528: PUSH
8529: LD_EXP 26
8533: AND
8534: IFFALSE 8633
8536: GO 8538
8538: DISABLE
8539: LD_INT 0
8541: PPUSH
8542: PPUSH
// begin enable ;
8543: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
8544: LD_ADDR_VAR 0 2
8548: PUSH
8549: LD_INT 22
8551: PUSH
8552: LD_OWVAR 2
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PUSH
8561: LD_INT 2
8563: PUSH
8564: LD_INT 34
8566: PUSH
8567: LD_INT 11
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: LD_INT 34
8576: PUSH
8577: LD_INT 30
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: LIST
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PPUSH
8593: CALL_OW 69
8597: ST_TO_ADDR
// if not tmp then
8598: LD_VAR 0 2
8602: NOT
8603: IFFALSE 8607
// exit ;
8605: GO 8633
// for i in tmp do
8607: LD_ADDR_VAR 0 1
8611: PUSH
8612: LD_VAR 0 2
8616: PUSH
8617: FOR_IN
8618: IFFALSE 8631
// begin DestroyUnit ( i ) ;
8620: LD_VAR 0 1
8624: PPUSH
8625: CALL_OW 65
// end ;
8629: GO 8617
8631: POP
8632: POP
// end ;
8633: PPOPN 2
8635: END
// every 0 0$1 trigger StreamModeActive and sBunker do
8636: LD_EXP 19
8640: PUSH
8641: LD_EXP 27
8645: AND
8646: IFFALSE 8666
8648: GO 8650
8650: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
8651: LD_INT 32
8653: PPUSH
8654: LD_OWVAR 2
8658: PPUSH
8659: LD_INT 0
8661: PPUSH
8662: CALL_OW 324
8666: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
8667: LD_EXP 19
8671: PUSH
8672: LD_EXP 28
8676: AND
8677: IFFALSE 8858
8679: GO 8681
8681: DISABLE
8682: LD_INT 0
8684: PPUSH
8685: PPUSH
8686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
8687: LD_ADDR_VAR 0 2
8691: PUSH
8692: LD_INT 22
8694: PUSH
8695: LD_OWVAR 2
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: LD_INT 33
8706: PUSH
8707: LD_INT 3
8709: PUSH
8710: EMPTY
8711: LIST
8712: LIST
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PPUSH
8718: CALL_OW 69
8722: ST_TO_ADDR
// if not tmp then
8723: LD_VAR 0 2
8727: NOT
8728: IFFALSE 8732
// exit ;
8730: GO 8858
// side := 0 ;
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: LD_INT 0
8739: ST_TO_ADDR
// for i := 1 to 8 do
8740: LD_ADDR_VAR 0 1
8744: PUSH
8745: DOUBLE
8746: LD_INT 1
8748: DEC
8749: ST_TO_ADDR
8750: LD_INT 8
8752: PUSH
8753: FOR_TO
8754: IFFALSE 8802
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
8756: LD_OWVAR 2
8760: PUSH
8761: LD_VAR 0 1
8765: NONEQUAL
8766: PUSH
8767: LD_OWVAR 2
8771: PPUSH
8772: LD_VAR 0 1
8776: PPUSH
8777: CALL_OW 81
8781: PUSH
8782: LD_INT 2
8784: EQUAL
8785: AND
8786: IFFALSE 8800
// begin side := i ;
8788: LD_ADDR_VAR 0 3
8792: PUSH
8793: LD_VAR 0 1
8797: ST_TO_ADDR
// break ;
8798: GO 8802
// end ;
8800: GO 8753
8802: POP
8803: POP
// if not side then
8804: LD_VAR 0 3
8808: NOT
8809: IFFALSE 8813
// exit ;
8811: GO 8858
// for i := 1 to tmp do
8813: LD_ADDR_VAR 0 1
8817: PUSH
8818: DOUBLE
8819: LD_INT 1
8821: DEC
8822: ST_TO_ADDR
8823: LD_VAR 0 2
8827: PUSH
8828: FOR_TO
8829: IFFALSE 8856
// if Prob ( 30 ) then
8831: LD_INT 30
8833: PPUSH
8834: CALL_OW 13
8838: IFFALSE 8854
// SetSide ( i , side ) ;
8840: LD_VAR 0 1
8844: PPUSH
8845: LD_VAR 0 3
8849: PPUSH
8850: CALL_OW 235
8854: GO 8828
8856: POP
8857: POP
// end ;
8858: PPOPN 3
8860: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
8861: LD_EXP 19
8865: PUSH
8866: LD_EXP 30
8870: AND
8871: IFFALSE 8990
8873: GO 8875
8875: DISABLE
8876: LD_INT 0
8878: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8879: LD_ADDR_VAR 0 1
8883: PUSH
8884: LD_INT 22
8886: PUSH
8887: LD_OWVAR 2
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: LD_INT 21
8898: PUSH
8899: LD_INT 1
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 3
8908: PUSH
8909: LD_INT 23
8911: PUSH
8912: LD_INT 0
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PUSH
8923: EMPTY
8924: LIST
8925: LIST
8926: LIST
8927: PPUSH
8928: CALL_OW 69
8932: PUSH
8933: FOR_IN
8934: IFFALSE 8988
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 257
8945: PUSH
8946: LD_INT 1
8948: PUSH
8949: LD_INT 2
8951: PUSH
8952: LD_INT 3
8954: PUSH
8955: LD_INT 4
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: LIST
8962: LIST
8963: IN
8964: IFFALSE 8986
// SetClass ( un , rand ( 1 , 4 ) ) ;
8966: LD_VAR 0 1
8970: PPUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 4
8976: PPUSH
8977: CALL_OW 12
8981: PPUSH
8982: CALL_OW 336
8986: GO 8933
8988: POP
8989: POP
// end ;
8990: PPOPN 1
8992: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8993: LD_EXP 19
8997: PUSH
8998: LD_EXP 29
9002: AND
9003: IFFALSE 9082
9005: GO 9007
9007: DISABLE
9008: LD_INT 0
9010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9011: LD_ADDR_VAR 0 1
9015: PUSH
9016: LD_INT 22
9018: PUSH
9019: LD_OWVAR 2
9023: PUSH
9024: EMPTY
9025: LIST
9026: LIST
9027: PUSH
9028: LD_INT 21
9030: PUSH
9031: LD_INT 3
9033: PUSH
9034: EMPTY
9035: LIST
9036: LIST
9037: PUSH
9038: EMPTY
9039: LIST
9040: LIST
9041: PPUSH
9042: CALL_OW 69
9046: ST_TO_ADDR
// if not tmp then
9047: LD_VAR 0 1
9051: NOT
9052: IFFALSE 9056
// exit ;
9054: GO 9082
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9056: LD_VAR 0 1
9060: PUSH
9061: LD_INT 1
9063: PPUSH
9064: LD_VAR 0 1
9068: PPUSH
9069: CALL_OW 12
9073: ARRAY
9074: PPUSH
9075: LD_INT 100
9077: PPUSH
9078: CALL_OW 234
// end ;
9082: PPOPN 1
9084: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
9085: LD_EXP 19
9089: PUSH
9090: LD_EXP 31
9094: AND
9095: IFFALSE 9193
9097: GO 9099
9099: DISABLE
9100: LD_INT 0
9102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9103: LD_ADDR_VAR 0 1
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_OWVAR 2
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 21
9122: PUSH
9123: LD_INT 1
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: ST_TO_ADDR
// if not tmp then
9139: LD_VAR 0 1
9143: NOT
9144: IFFALSE 9148
// exit ;
9146: GO 9193
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
9148: LD_VAR 0 1
9152: PUSH
9153: LD_INT 1
9155: PPUSH
9156: LD_VAR 0 1
9160: PPUSH
9161: CALL_OW 12
9165: ARRAY
9166: PPUSH
9167: LD_INT 1
9169: PPUSH
9170: LD_INT 4
9172: PPUSH
9173: CALL_OW 12
9177: PPUSH
9178: LD_INT 3000
9180: PPUSH
9181: LD_INT 9000
9183: PPUSH
9184: CALL_OW 12
9188: PPUSH
9189: CALL_OW 492
// end ;
9193: PPOPN 1
9195: END
// every 0 0$1 trigger StreamModeActive and sDepot do
9196: LD_EXP 19
9200: PUSH
9201: LD_EXP 32
9205: AND
9206: IFFALSE 9226
9208: GO 9210
9210: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
9211: LD_INT 1
9213: PPUSH
9214: LD_OWVAR 2
9218: PPUSH
9219: LD_INT 0
9221: PPUSH
9222: CALL_OW 324
9226: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
9227: LD_EXP 19
9231: PUSH
9232: LD_EXP 33
9236: AND
9237: IFFALSE 9320
9239: GO 9241
9241: DISABLE
9242: LD_INT 0
9244: PPUSH
9245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9246: LD_ADDR_VAR 0 2
9250: PUSH
9251: LD_INT 22
9253: PUSH
9254: LD_OWVAR 2
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: PUSH
9263: LD_INT 21
9265: PUSH
9266: LD_INT 3
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: PPUSH
9277: CALL_OW 69
9281: ST_TO_ADDR
// if not tmp then
9282: LD_VAR 0 2
9286: NOT
9287: IFFALSE 9291
// exit ;
9289: GO 9320
// for i in tmp do
9291: LD_ADDR_VAR 0 1
9295: PUSH
9296: LD_VAR 0 2
9300: PUSH
9301: FOR_IN
9302: IFFALSE 9318
// SetBLevel ( i , 10 ) ;
9304: LD_VAR 0 1
9308: PPUSH
9309: LD_INT 10
9311: PPUSH
9312: CALL_OW 241
9316: GO 9301
9318: POP
9319: POP
// end ;
9320: PPOPN 2
9322: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
9323: LD_EXP 19
9327: PUSH
9328: LD_EXP 34
9332: AND
9333: IFFALSE 9444
9335: GO 9337
9337: DISABLE
9338: LD_INT 0
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9343: LD_ADDR_VAR 0 3
9347: PUSH
9348: LD_INT 22
9350: PUSH
9351: LD_OWVAR 2
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: PUSH
9360: LD_INT 25
9362: PUSH
9363: LD_INT 1
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PPUSH
9374: CALL_OW 69
9378: ST_TO_ADDR
// if not tmp then
9379: LD_VAR 0 3
9383: NOT
9384: IFFALSE 9388
// exit ;
9386: GO 9444
// un := tmp [ rand ( 1 , tmp ) ] ;
9388: LD_ADDR_VAR 0 2
9392: PUSH
9393: LD_VAR 0 3
9397: PUSH
9398: LD_INT 1
9400: PPUSH
9401: LD_VAR 0 3
9405: PPUSH
9406: CALL_OW 12
9410: ARRAY
9411: ST_TO_ADDR
// if Crawls ( un ) then
9412: LD_VAR 0 2
9416: PPUSH
9417: CALL_OW 318
9421: IFFALSE 9432
// ComWalk ( un ) ;
9423: LD_VAR 0 2
9427: PPUSH
9428: CALL_OW 138
// SetClass ( un , class_sniper ) ;
9432: LD_VAR 0 2
9436: PPUSH
9437: LD_INT 5
9439: PPUSH
9440: CALL_OW 336
// end ;
9444: PPOPN 3
9446: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
9447: LD_EXP 19
9451: PUSH
9452: LD_EXP 35
9456: AND
9457: PUSH
9458: LD_OWVAR 67
9462: PUSH
9463: LD_INT 3
9465: LESS
9466: AND
9467: IFFALSE 9486
9469: GO 9471
9471: DISABLE
// Difficulty := Difficulty + 1 ;
9472: LD_ADDR_OWVAR 67
9476: PUSH
9477: LD_OWVAR 67
9481: PUSH
9482: LD_INT 1
9484: PLUS
9485: ST_TO_ADDR
9486: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
9487: LD_EXP 19
9491: PUSH
9492: LD_EXP 36
9496: AND
9497: IFFALSE 9600
9499: GO 9501
9501: DISABLE
9502: LD_INT 0
9504: PPUSH
// begin for i := 1 to 5 do
9505: LD_ADDR_VAR 0 1
9509: PUSH
9510: DOUBLE
9511: LD_INT 1
9513: DEC
9514: ST_TO_ADDR
9515: LD_INT 5
9517: PUSH
9518: FOR_TO
9519: IFFALSE 9598
// begin uc_nation := nation_nature ;
9521: LD_ADDR_OWVAR 21
9525: PUSH
9526: LD_INT 0
9528: ST_TO_ADDR
// uc_side := 0 ;
9529: LD_ADDR_OWVAR 20
9533: PUSH
9534: LD_INT 0
9536: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9537: LD_ADDR_OWVAR 29
9541: PUSH
9542: LD_INT 12
9544: PUSH
9545: LD_INT 12
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: ST_TO_ADDR
// hc_agressivity := 20 ;
9552: LD_ADDR_OWVAR 35
9556: PUSH
9557: LD_INT 20
9559: ST_TO_ADDR
// hc_class := class_tiger ;
9560: LD_ADDR_OWVAR 28
9564: PUSH
9565: LD_INT 14
9567: ST_TO_ADDR
// hc_gallery :=  ;
9568: LD_ADDR_OWVAR 33
9572: PUSH
9573: LD_STRING 
9575: ST_TO_ADDR
// hc_name :=  ;
9576: LD_ADDR_OWVAR 26
9580: PUSH
9581: LD_STRING 
9583: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
9584: CALL_OW 44
9588: PPUSH
9589: LD_INT 0
9591: PPUSH
9592: CALL_OW 51
// end ;
9596: GO 9518
9598: POP
9599: POP
// end ;
9600: PPOPN 1
9602: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
9603: LD_EXP 19
9607: PUSH
9608: LD_EXP 37
9612: AND
9613: IFFALSE 9787
9615: GO 9617
9617: DISABLE
9618: LD_INT 0
9620: PPUSH
9621: PPUSH
9622: PPUSH
9623: PPUSH
// begin result := false ;
9624: LD_ADDR_VAR 0 4
9628: PUSH
9629: LD_INT 0
9631: ST_TO_ADDR
// for i := 1 to 8 do
9632: LD_ADDR_VAR 0 1
9636: PUSH
9637: DOUBLE
9638: LD_INT 1
9640: DEC
9641: ST_TO_ADDR
9642: LD_INT 8
9644: PUSH
9645: FOR_TO
9646: IFFALSE 9757
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
9648: LD_ADDR_VAR 0 2
9652: PUSH
9653: LD_INT 10
9655: PUSH
9656: LD_INT 50
9658: PUSH
9659: LD_INT 90
9661: PUSH
9662: LD_INT 140
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: LIST
9669: LIST
9670: PUSH
9671: LD_INT 1
9673: PPUSH
9674: LD_INT 4
9676: PPUSH
9677: CALL_OW 12
9681: ARRAY
9682: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
9683: LD_ADDR_VAR 0 3
9687: PUSH
9688: LD_INT 10
9690: PUSH
9691: LD_INT 50
9693: PUSH
9694: LD_INT 90
9696: PUSH
9697: LD_INT 140
9699: PUSH
9700: EMPTY
9701: LIST
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_INT 1
9708: PPUSH
9709: LD_INT 4
9711: PPUSH
9712: CALL_OW 12
9716: ARRAY
9717: ST_TO_ADDR
// if ValidHex ( x , y ) then
9718: LD_VAR 0 2
9722: PPUSH
9723: LD_VAR 0 3
9727: PPUSH
9728: CALL_OW 488
9732: IFFALSE 9755
// begin result := [ x , y ] ;
9734: LD_ADDR_VAR 0 4
9738: PUSH
9739: LD_VAR 0 2
9743: PUSH
9744: LD_VAR 0 3
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: ST_TO_ADDR
// break ;
9753: GO 9757
// end ; end ;
9755: GO 9645
9757: POP
9758: POP
// if result then
9759: LD_VAR 0 4
9763: IFFALSE 9787
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
9765: LD_VAR 0 4
9769: PUSH
9770: LD_INT 1
9772: ARRAY
9773: PPUSH
9774: LD_VAR 0 4
9778: PUSH
9779: LD_INT 2
9781: ARRAY
9782: PPUSH
9783: CALL_OW 429
// end ;
9787: PPOPN 4
9789: END
// every 0 0$1 trigger StreamModeActive and sReset do
9790: LD_EXP 19
9794: PUSH
9795: LD_EXP 39
9799: AND
9800: IFFALSE 9812
9802: GO 9804
9804: DISABLE
// YouLost (  ) ;
9805: LD_STRING 
9807: PPUSH
9808: CALL_OW 104
9812: END
// every 0 0$1 trigger StreamModeActive and sFog do
9813: LD_EXP 19
9817: PUSH
9818: LD_EXP 38
9822: AND
9823: IFFALSE 9837
9825: GO 9827
9827: DISABLE
// FogOff ( your_side ) ;
9828: LD_OWVAR 2
9832: PPUSH
9833: CALL_OW 344
9837: END
// every 0 0$1 trigger StreamModeActive and sSun do
9838: LD_EXP 19
9842: PUSH
9843: LD_EXP 40
9847: AND
9848: IFFALSE 9876
9850: GO 9852
9852: DISABLE
// begin solar_recharge_percent := 0 ;
9853: LD_ADDR_OWVAR 79
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9861: LD_INT 10500
9863: PPUSH
9864: CALL_OW 67
// solar_recharge_percent := 100 ;
9868: LD_ADDR_OWVAR 79
9872: PUSH
9873: LD_INT 100
9875: ST_TO_ADDR
// end ;
9876: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
9877: LD_EXP 19
9881: PUSH
9882: LD_EXP 41
9886: AND
9887: IFFALSE 10126
9889: GO 9891
9891: DISABLE
9892: LD_INT 0
9894: PPUSH
9895: PPUSH
9896: PPUSH
// begin tmp := [ ] ;
9897: LD_ADDR_VAR 0 3
9901: PUSH
9902: EMPTY
9903: ST_TO_ADDR
// for i := 1 to 6 do
9904: LD_ADDR_VAR 0 1
9908: PUSH
9909: DOUBLE
9910: LD_INT 1
9912: DEC
9913: ST_TO_ADDR
9914: LD_INT 6
9916: PUSH
9917: FOR_TO
9918: IFFALSE 10023
// begin uc_nation := nation_nature ;
9920: LD_ADDR_OWVAR 21
9924: PUSH
9925: LD_INT 0
9927: ST_TO_ADDR
// uc_side := 0 ;
9928: LD_ADDR_OWVAR 20
9932: PUSH
9933: LD_INT 0
9935: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9936: LD_ADDR_OWVAR 29
9940: PUSH
9941: LD_INT 12
9943: PUSH
9944: LD_INT 12
9946: PUSH
9947: EMPTY
9948: LIST
9949: LIST
9950: ST_TO_ADDR
// hc_agressivity := 20 ;
9951: LD_ADDR_OWVAR 35
9955: PUSH
9956: LD_INT 20
9958: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9959: LD_ADDR_OWVAR 28
9963: PUSH
9964: LD_INT 17
9966: ST_TO_ADDR
// hc_gallery :=  ;
9967: LD_ADDR_OWVAR 33
9971: PUSH
9972: LD_STRING 
9974: ST_TO_ADDR
// hc_name :=  ;
9975: LD_ADDR_OWVAR 26
9979: PUSH
9980: LD_STRING 
9982: ST_TO_ADDR
// un := CreateHuman ;
9983: LD_ADDR_VAR 0 2
9987: PUSH
9988: CALL_OW 44
9992: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9993: LD_VAR 0 2
9997: PPUSH
9998: LD_INT 1
10000: PPUSH
10001: CALL_OW 51
// tmp := tmp * un ;
10005: LD_ADDR_VAR 0 3
10009: PUSH
10010: LD_VAR 0 3
10014: PUSH
10015: LD_VAR 0 2
10019: MUL
10020: ST_TO_ADDR
// end ;
10021: GO 9917
10023: POP
10024: POP
// repeat wait ( 0 0$1 ) ;
10025: LD_INT 35
10027: PPUSH
10028: CALL_OW 67
// for un in tmp do
10032: LD_ADDR_VAR 0 2
10036: PUSH
10037: LD_VAR 0 3
10041: PUSH
10042: FOR_IN
10043: IFFALSE 10117
// begin if IsDead ( un ) then
10045: LD_VAR 0 2
10049: PPUSH
10050: CALL_OW 301
10054: IFFALSE 10074
// begin tmp := tmp diff un ;
10056: LD_ADDR_VAR 0 3
10060: PUSH
10061: LD_VAR 0 3
10065: PUSH
10066: LD_VAR 0 2
10070: DIFF
10071: ST_TO_ADDR
// continue ;
10072: GO 10042
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
10074: LD_VAR 0 2
10078: PPUSH
10079: LD_INT 3
10081: PUSH
10082: LD_INT 22
10084: PUSH
10085: LD_INT 0
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PPUSH
10096: CALL_OW 69
10100: PPUSH
10101: LD_VAR 0 2
10105: PPUSH
10106: CALL_OW 74
10110: PPUSH
10111: CALL_OW 115
// end ;
10115: GO 10042
10117: POP
10118: POP
// until not tmp ;
10119: LD_VAR 0 3
10123: NOT
10124: IFFALSE 10025
// end ;
10126: PPOPN 3
10128: END
// every 0 0$1 trigger StreamModeActive and sTroll do
10129: LD_EXP 19
10133: PUSH
10134: LD_EXP 42
10138: AND
10139: IFFALSE 10165
10141: GO 10143
10143: DISABLE
// begin ToLua ( displayTroll(); ) ;
10144: LD_STRING displayTroll();
10146: PPUSH
10147: CALL_OW 559
// wait ( 3 3$00 ) ;
10151: LD_INT 6300
10153: PPUSH
10154: CALL_OW 67
// ToLua ( hideTroll(); ) ;
10158: LD_STRING hideTroll();
10160: PPUSH
10161: CALL_OW 559
// end ;
10165: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
10166: LD_EXP 19
10170: PUSH
10171: LD_EXP 43
10175: AND
10176: IFFALSE 10239
10178: GO 10180
10180: DISABLE
10181: LD_INT 0
10183: PPUSH
// begin p := 0 ;
10184: LD_ADDR_VAR 0 1
10188: PUSH
10189: LD_INT 0
10191: ST_TO_ADDR
// repeat game_speed := 1 ;
10192: LD_ADDR_OWVAR 65
10196: PUSH
10197: LD_INT 1
10199: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10200: LD_INT 35
10202: PPUSH
10203: CALL_OW 67
// p := p + 1 ;
10207: LD_ADDR_VAR 0 1
10211: PUSH
10212: LD_VAR 0 1
10216: PUSH
10217: LD_INT 1
10219: PLUS
10220: ST_TO_ADDR
// until p >= 60 ;
10221: LD_VAR 0 1
10225: PUSH
10226: LD_INT 60
10228: GREATEREQUAL
10229: IFFALSE 10192
// game_speed := 4 ;
10231: LD_ADDR_OWVAR 65
10235: PUSH
10236: LD_INT 4
10238: ST_TO_ADDR
// end ;
10239: PPOPN 1
10241: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
10242: LD_EXP 19
10246: PUSH
10247: LD_EXP 44
10251: AND
10252: IFFALSE 10398
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10261: LD_ADDR_VAR 0 1
10265: PUSH
10266: LD_INT 22
10268: PUSH
10269: LD_OWVAR 2
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: PUSH
10278: LD_INT 2
10280: PUSH
10281: LD_INT 30
10283: PUSH
10284: LD_INT 0
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: PUSH
10291: LD_INT 30
10293: PUSH
10294: LD_INT 1
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PPUSH
10310: CALL_OW 69
10314: ST_TO_ADDR
// if not depot then
10315: LD_VAR 0 1
10319: NOT
10320: IFFALSE 10324
// exit ;
10322: GO 10398
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
10324: LD_ADDR_VAR 0 2
10328: PUSH
10329: LD_VAR 0 1
10333: PUSH
10334: LD_INT 1
10336: PPUSH
10337: LD_VAR 0 1
10341: PPUSH
10342: CALL_OW 12
10346: ARRAY
10347: PPUSH
10348: CALL_OW 274
10352: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
10353: LD_VAR 0 2
10357: PPUSH
10358: LD_INT 1
10360: PPUSH
10361: LD_INT 0
10363: PPUSH
10364: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
10368: LD_VAR 0 2
10372: PPUSH
10373: LD_INT 2
10375: PPUSH
10376: LD_INT 0
10378: PPUSH
10379: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
10383: LD_VAR 0 2
10387: PPUSH
10388: LD_INT 3
10390: PPUSH
10391: LD_INT 0
10393: PPUSH
10394: CALL_OW 277
// end ;
10398: PPOPN 2
10400: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
10401: LD_EXP 19
10405: PUSH
10406: LD_EXP 45
10410: AND
10411: IFFALSE 10508
10413: GO 10415
10415: DISABLE
10416: LD_INT 0
10418: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10419: LD_ADDR_VAR 0 1
10423: PUSH
10424: LD_INT 22
10426: PUSH
10427: LD_OWVAR 2
10431: PUSH
10432: EMPTY
10433: LIST
10434: LIST
10435: PUSH
10436: LD_INT 21
10438: PUSH
10439: LD_INT 1
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 23
10451: PUSH
10452: LD_INT 0
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: LIST
10467: PPUSH
10468: CALL_OW 69
10472: ST_TO_ADDR
// if not tmp then
10473: LD_VAR 0 1
10477: NOT
10478: IFFALSE 10482
// exit ;
10480: GO 10508
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
10482: LD_VAR 0 1
10486: PUSH
10487: LD_INT 1
10489: PPUSH
10490: LD_VAR 0 1
10494: PPUSH
10495: CALL_OW 12
10499: ARRAY
10500: PPUSH
10501: LD_INT 200
10503: PPUSH
10504: CALL_OW 234
// end ;
10508: PPOPN 1
10510: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
10511: LD_EXP 19
10515: PUSH
10516: LD_EXP 46
10520: AND
10521: IFFALSE 10600
10523: GO 10525
10525: DISABLE
10526: LD_INT 0
10528: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
10529: LD_ADDR_VAR 0 1
10533: PUSH
10534: LD_INT 22
10536: PUSH
10537: LD_OWVAR 2
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: PUSH
10546: LD_INT 21
10548: PUSH
10549: LD_INT 2
10551: PUSH
10552: EMPTY
10553: LIST
10554: LIST
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: PPUSH
10560: CALL_OW 69
10564: ST_TO_ADDR
// if not tmp then
10565: LD_VAR 0 1
10569: NOT
10570: IFFALSE 10574
// exit ;
10572: GO 10600
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
10574: LD_VAR 0 1
10578: PUSH
10579: LD_INT 1
10581: PPUSH
10582: LD_VAR 0 1
10586: PPUSH
10587: CALL_OW 12
10591: ARRAY
10592: PPUSH
10593: LD_INT 60
10595: PPUSH
10596: CALL_OW 234
// end ;
10600: PPOPN 1
10602: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
10603: LD_EXP 19
10607: PUSH
10608: LD_EXP 47
10612: AND
10613: IFFALSE 10712
10615: GO 10617
10617: DISABLE
10618: LD_INT 0
10620: PPUSH
10621: PPUSH
// begin enable ;
10622: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
10623: LD_ADDR_VAR 0 1
10627: PUSH
10628: LD_INT 22
10630: PUSH
10631: LD_OWVAR 2
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 61
10642: PUSH
10643: EMPTY
10644: LIST
10645: PUSH
10646: LD_INT 33
10648: PUSH
10649: LD_INT 2
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: LIST
10660: PPUSH
10661: CALL_OW 69
10665: ST_TO_ADDR
// if not tmp then
10666: LD_VAR 0 1
10670: NOT
10671: IFFALSE 10675
// exit ;
10673: GO 10712
// for i in tmp do
10675: LD_ADDR_VAR 0 2
10679: PUSH
10680: LD_VAR 0 1
10684: PUSH
10685: FOR_IN
10686: IFFALSE 10710
// if IsControledBy ( i ) then
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 312
10697: IFFALSE 10708
// ComUnlink ( i ) ;
10699: LD_VAR 0 2
10703: PPUSH
10704: CALL_OW 136
10708: GO 10685
10710: POP
10711: POP
// end ;
10712: PPOPN 2
10714: END
// every 0 0$1 trigger StreamModeActive and sPowell do
10715: LD_EXP 19
10719: PUSH
10720: LD_EXP 48
10724: AND
10725: IFFALSE 10765
10727: GO 10729
10729: DISABLE
// begin ToLua ( displayPowell(); ) ;
10730: LD_STRING displayPowell();
10732: PPUSH
10733: CALL_OW 559
// wait ( 0 0$20 ) ;
10737: LD_INT 700
10739: PPUSH
10740: CALL_OW 67
// ToLua ( displayPowell(); ) ;
10744: LD_STRING displayPowell();
10746: PPUSH
10747: CALL_OW 559
// wait ( 0 0$40 ) ;
10751: LD_INT 1400
10753: PPUSH
10754: CALL_OW 67
// ToLua ( displayPowell(); ) ;
10758: LD_STRING displayPowell();
10760: PPUSH
10761: CALL_OW 559
// end ;
10765: END
// every 0 0$1 trigger StreamModeActive and sStu do
10766: LD_EXP 19
10770: PUSH
10771: LD_EXP 56
10775: AND
10776: IFFALSE 10788
10778: GO 10780
10780: DISABLE
// begin ToLua ( displayStucuk(); ) ;
10781: LD_STRING displayStucuk();
10783: PPUSH
10784: CALL_OW 559
// end ;
10788: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
10789: LD_EXP 19
10793: PUSH
10794: LD_EXP 49
10798: AND
10799: IFFALSE 10940
10801: GO 10803
10803: DISABLE
10804: LD_INT 0
10806: PPUSH
10807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10808: LD_ADDR_VAR 0 2
10812: PUSH
10813: LD_INT 22
10815: PUSH
10816: LD_OWVAR 2
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: LD_INT 21
10827: PUSH
10828: LD_INT 1
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PPUSH
10839: CALL_OW 69
10843: ST_TO_ADDR
// if not tmp then
10844: LD_VAR 0 2
10848: NOT
10849: IFFALSE 10853
// exit ;
10851: GO 10940
// un := tmp [ rand ( 1 , tmp ) ] ;
10853: LD_ADDR_VAR 0 1
10857: PUSH
10858: LD_VAR 0 2
10862: PUSH
10863: LD_INT 1
10865: PPUSH
10866: LD_VAR 0 2
10870: PPUSH
10871: CALL_OW 12
10875: ARRAY
10876: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10877: LD_VAR 0 1
10881: PPUSH
10882: LD_INT 0
10884: PPUSH
10885: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10889: LD_VAR 0 1
10893: PPUSH
10894: LD_OWVAR 3
10898: PUSH
10899: LD_VAR 0 1
10903: DIFF
10904: PPUSH
10905: LD_VAR 0 1
10909: PPUSH
10910: CALL_OW 74
10914: PPUSH
10915: CALL_OW 115
// wait ( 0 0$20 ) ;
10919: LD_INT 700
10921: PPUSH
10922: CALL_OW 67
// SetSide ( un , your_side ) ;
10926: LD_VAR 0 1
10930: PPUSH
10931: LD_OWVAR 2
10935: PPUSH
10936: CALL_OW 235
// end ;
10940: PPOPN 2
10942: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10943: LD_EXP 19
10947: PUSH
10948: LD_EXP 50
10952: AND
10953: IFFALSE 11059
10955: GO 10957
10957: DISABLE
10958: LD_INT 0
10960: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10961: LD_ADDR_VAR 0 1
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_OWVAR 2
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PUSH
10978: LD_INT 2
10980: PUSH
10981: LD_INT 30
10983: PUSH
10984: LD_INT 0
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 30
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: LIST
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: ST_TO_ADDR
// if not depot then
11015: LD_VAR 0 1
11019: NOT
11020: IFFALSE 11024
// exit ;
11022: GO 11059
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
11024: LD_VAR 0 1
11028: PUSH
11029: LD_INT 1
11031: ARRAY
11032: PPUSH
11033: CALL_OW 250
11037: PPUSH
11038: LD_VAR 0 1
11042: PUSH
11043: LD_INT 1
11045: ARRAY
11046: PPUSH
11047: CALL_OW 251
11051: PPUSH
11052: LD_INT 70
11054: PPUSH
11055: CALL_OW 495
// end ;
11059: PPOPN 1
11061: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
11062: LD_EXP 19
11066: PUSH
11067: LD_EXP 51
11071: AND
11072: IFFALSE 11283
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
11082: PPUSH
11083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11084: LD_ADDR_VAR 0 5
11088: PUSH
11089: LD_INT 22
11091: PUSH
11092: LD_OWVAR 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 21
11103: PUSH
11104: LD_INT 1
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: PPUSH
11115: CALL_OW 69
11119: ST_TO_ADDR
// if not tmp then
11120: LD_VAR 0 5
11124: NOT
11125: IFFALSE 11129
// exit ;
11127: GO 11283
// for i in tmp do
11129: LD_ADDR_VAR 0 1
11133: PUSH
11134: LD_VAR 0 5
11138: PUSH
11139: FOR_IN
11140: IFFALSE 11281
// begin d := rand ( 0 , 5 ) ;
11142: LD_ADDR_VAR 0 4
11146: PUSH
11147: LD_INT 0
11149: PPUSH
11150: LD_INT 5
11152: PPUSH
11153: CALL_OW 12
11157: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_VAR 0 1
11167: PPUSH
11168: CALL_OW 250
11172: PPUSH
11173: LD_VAR 0 4
11177: PPUSH
11178: LD_INT 3
11180: PPUSH
11181: LD_INT 12
11183: PPUSH
11184: CALL_OW 12
11188: PPUSH
11189: CALL_OW 272
11193: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
11194: LD_ADDR_VAR 0 3
11198: PUSH
11199: LD_VAR 0 1
11203: PPUSH
11204: CALL_OW 251
11208: PPUSH
11209: LD_VAR 0 4
11213: PPUSH
11214: LD_INT 3
11216: PPUSH
11217: LD_INT 12
11219: PPUSH
11220: CALL_OW 12
11224: PPUSH
11225: CALL_OW 273
11229: ST_TO_ADDR
// if ValidHex ( x , y ) then
11230: LD_VAR 0 2
11234: PPUSH
11235: LD_VAR 0 3
11239: PPUSH
11240: CALL_OW 488
11244: IFFALSE 11279
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
11246: LD_VAR 0 1
11250: PPUSH
11251: LD_VAR 0 2
11255: PPUSH
11256: LD_VAR 0 3
11260: PPUSH
11261: LD_INT 3
11263: PPUSH
11264: LD_INT 6
11266: PPUSH
11267: CALL_OW 12
11271: PPUSH
11272: LD_INT 1
11274: PPUSH
11275: CALL_OW 483
// end ;
11279: GO 11139
11281: POP
11282: POP
// end ;
11283: PPOPN 5
11285: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
11286: LD_EXP 19
11290: PUSH
11291: LD_EXP 52
11295: AND
11296: IFFALSE 11390
11298: GO 11300
11300: DISABLE
11301: LD_INT 0
11303: PPUSH
11304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
11305: LD_ADDR_VAR 0 2
11309: PUSH
11310: LD_INT 22
11312: PUSH
11313: LD_OWVAR 2
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: PUSH
11322: LD_INT 32
11324: PUSH
11325: LD_INT 1
11327: PUSH
11328: EMPTY
11329: LIST
11330: LIST
11331: PUSH
11332: LD_INT 21
11334: PUSH
11335: LD_INT 2
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: PPUSH
11347: CALL_OW 69
11351: ST_TO_ADDR
// if not tmp then
11352: LD_VAR 0 2
11356: NOT
11357: IFFALSE 11361
// exit ;
11359: GO 11390
// for i in tmp do
11361: LD_ADDR_VAR 0 1
11365: PUSH
11366: LD_VAR 0 2
11370: PUSH
11371: FOR_IN
11372: IFFALSE 11388
// SetFuel ( i , 0 ) ;
11374: LD_VAR 0 1
11378: PPUSH
11379: LD_INT 0
11381: PPUSH
11382: CALL_OW 240
11386: GO 11371
11388: POP
11389: POP
// end ;
11390: PPOPN 2
11392: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
11393: LD_EXP 19
11397: PUSH
11398: LD_EXP 53
11402: AND
11403: IFFALSE 11469
11405: GO 11407
11407: DISABLE
11408: LD_INT 0
11410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
11411: LD_ADDR_VAR 0 1
11415: PUSH
11416: LD_INT 22
11418: PUSH
11419: LD_OWVAR 2
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PUSH
11428: LD_INT 30
11430: PUSH
11431: LD_INT 29
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PPUSH
11442: CALL_OW 69
11446: ST_TO_ADDR
// if not tmp then
11447: LD_VAR 0 1
11451: NOT
11452: IFFALSE 11456
// exit ;
11454: GO 11469
// DestroyUnit ( tmp [ 1 ] ) ;
11456: LD_VAR 0 1
11460: PUSH
11461: LD_INT 1
11463: ARRAY
11464: PPUSH
11465: CALL_OW 65
// end ;
11469: PPOPN 1
11471: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
11472: LD_EXP 19
11476: PUSH
11477: LD_EXP 55
11481: AND
11482: IFFALSE 11595
11484: GO 11486
11486: DISABLE
11487: LD_INT 0
11489: PPUSH
// begin uc_side := 0 ;
11490: LD_ADDR_OWVAR 20
11494: PUSH
11495: LD_INT 0
11497: ST_TO_ADDR
// uc_nation := nation_arabian ;
11498: LD_ADDR_OWVAR 21
11502: PUSH
11503: LD_INT 2
11505: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
11506: LD_INT 1
11508: PPUSH
11509: LD_INT 10
11511: PPUSH
11512: LD_INT 11
11514: PPUSH
11515: CALL_OW 380
// un := CreateHuman ;
11519: LD_ADDR_VAR 0 1
11523: PUSH
11524: CALL_OW 44
11528: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11529: LD_VAR 0 1
11533: PPUSH
11534: LD_INT 1
11536: PPUSH
11537: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11541: LD_INT 35
11543: PPUSH
11544: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11548: LD_VAR 0 1
11552: PPUSH
11553: LD_INT 22
11555: PUSH
11556: LD_OWVAR 2
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: PPUSH
11570: LD_VAR 0 1
11574: PPUSH
11575: CALL_OW 74
11579: PPUSH
11580: CALL_OW 115
// until IsDead ( un ) ;
11584: LD_VAR 0 1
11588: PPUSH
11589: CALL_OW 301
11593: IFFALSE 11541
// end ; end_of_file
11595: PPOPN 1
11597: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11604: LD_VAR 0 1
11608: PPUSH
11609: CALL_OW 264
11613: PUSH
11614: LD_EXP 18
11618: EQUAL
11619: IFFALSE 11691
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11621: LD_INT 68
11623: PPUSH
11624: LD_VAR 0 1
11628: PPUSH
11629: CALL_OW 255
11633: PPUSH
11634: CALL_OW 321
11638: PUSH
11639: LD_INT 2
11641: EQUAL
11642: IFFALSE 11654
// eff := 70 else
11644: LD_ADDR_VAR 0 6
11648: PUSH
11649: LD_INT 70
11651: ST_TO_ADDR
11652: GO 11662
// eff := 30 ;
11654: LD_ADDR_VAR 0 6
11658: PUSH
11659: LD_INT 30
11661: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11662: LD_VAR 0 1
11666: PPUSH
11667: CALL_OW 250
11671: PPUSH
11672: LD_VAR 0 1
11676: PPUSH
11677: CALL_OW 251
11681: PPUSH
11682: LD_VAR 0 6
11686: PPUSH
11687: CALL_OW 495
// end ; end ;
11691: LD_VAR 0 4
11695: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11696: LD_INT 0
11698: PPUSH
11699: PPUSH
11700: PPUSH
11701: PPUSH
11702: PPUSH
11703: PPUSH
// if cmd = 124 then
11704: LD_VAR 0 1
11708: PUSH
11709: LD_INT 124
11711: EQUAL
11712: IFFALSE 11918
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11714: LD_ADDR_VAR 0 5
11718: PUSH
11719: LD_INT 2
11721: PUSH
11722: LD_INT 34
11724: PUSH
11725: LD_INT 53
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: PUSH
11732: LD_INT 34
11734: PUSH
11735: LD_INT 14
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 69
11751: ST_TO_ADDR
// if not tmp then
11752: LD_VAR 0 5
11756: NOT
11757: IFFALSE 11761
// exit ;
11759: GO 11918
// for i in tmp do
11761: LD_ADDR_VAR 0 3
11765: PUSH
11766: LD_VAR 0 5
11770: PUSH
11771: FOR_IN
11772: IFFALSE 11916
// begin taskList := GetTaskList ( i ) ;
11774: LD_ADDR_VAR 0 6
11778: PUSH
11779: LD_VAR 0 3
11783: PPUSH
11784: CALL_OW 437
11788: ST_TO_ADDR
// if not taskList then
11789: LD_VAR 0 6
11793: NOT
11794: IFFALSE 11798
// continue ;
11796: GO 11771
// for j = 1 to taskList do
11798: LD_ADDR_VAR 0 4
11802: PUSH
11803: DOUBLE
11804: LD_INT 1
11806: DEC
11807: ST_TO_ADDR
11808: LD_VAR 0 6
11812: PUSH
11813: FOR_TO
11814: IFFALSE 11912
// if taskList [ j ] [ 1 ] = | then
11816: LD_VAR 0 6
11820: PUSH
11821: LD_VAR 0 4
11825: ARRAY
11826: PUSH
11827: LD_INT 1
11829: ARRAY
11830: PUSH
11831: LD_STRING |
11833: EQUAL
11834: IFFALSE 11910
// begin _taskList := Delete ( taskList , 1 ) ;
11836: LD_ADDR_VAR 0 7
11840: PUSH
11841: LD_VAR 0 6
11845: PPUSH
11846: LD_INT 1
11848: PPUSH
11849: CALL_OW 3
11853: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11854: LD_VAR 0 3
11858: PPUSH
11859: LD_VAR 0 7
11863: PPUSH
11864: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11868: LD_VAR 0 3
11872: PPUSH
11873: LD_VAR 0 6
11877: PUSH
11878: LD_VAR 0 4
11882: ARRAY
11883: PUSH
11884: LD_INT 2
11886: ARRAY
11887: PPUSH
11888: LD_VAR 0 6
11892: PUSH
11893: LD_VAR 0 4
11897: ARRAY
11898: PUSH
11899: LD_INT 3
11901: ARRAY
11902: PPUSH
11903: LD_INT 8
11905: PPUSH
11906: CALL 11923 0 4
// end ;
11910: GO 11813
11912: POP
11913: POP
// end ;
11914: GO 11771
11916: POP
11917: POP
// end ; end ;
11918: LD_VAR 0 2
11922: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11923: LD_INT 0
11925: PPUSH
11926: PPUSH
11927: PPUSH
11928: PPUSH
11929: PPUSH
11930: PPUSH
11931: PPUSH
11932: PPUSH
11933: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11934: LD_VAR 0 1
11938: NOT
11939: PUSH
11940: LD_VAR 0 2
11944: PPUSH
11945: LD_VAR 0 3
11949: PPUSH
11950: CALL_OW 488
11954: NOT
11955: OR
11956: PUSH
11957: LD_VAR 0 4
11961: NOT
11962: OR
11963: IFFALSE 11967
// exit ;
11965: GO 12307
// list := [ ] ;
11967: LD_ADDR_VAR 0 13
11971: PUSH
11972: EMPTY
11973: ST_TO_ADDR
// if x - r < 0 then
11974: LD_VAR 0 2
11978: PUSH
11979: LD_VAR 0 4
11983: MINUS
11984: PUSH
11985: LD_INT 0
11987: LESS
11988: IFFALSE 12000
// min_x := 0 else
11990: LD_ADDR_VAR 0 7
11994: PUSH
11995: LD_INT 0
11997: ST_TO_ADDR
11998: GO 12016
// min_x := x - r ;
12000: LD_ADDR_VAR 0 7
12004: PUSH
12005: LD_VAR 0 2
12009: PUSH
12010: LD_VAR 0 4
12014: MINUS
12015: ST_TO_ADDR
// if y - r < 0 then
12016: LD_VAR 0 3
12020: PUSH
12021: LD_VAR 0 4
12025: MINUS
12026: PUSH
12027: LD_INT 0
12029: LESS
12030: IFFALSE 12042
// min_y := 0 else
12032: LD_ADDR_VAR 0 8
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
12040: GO 12058
// min_y := y - r ;
12042: LD_ADDR_VAR 0 8
12046: PUSH
12047: LD_VAR 0 3
12051: PUSH
12052: LD_VAR 0 4
12056: MINUS
12057: ST_TO_ADDR
// max_x := x + r ;
12058: LD_ADDR_VAR 0 9
12062: PUSH
12063: LD_VAR 0 2
12067: PUSH
12068: LD_VAR 0 4
12072: PLUS
12073: ST_TO_ADDR
// max_y := y + r ;
12074: LD_ADDR_VAR 0 10
12078: PUSH
12079: LD_VAR 0 3
12083: PUSH
12084: LD_VAR 0 4
12088: PLUS
12089: ST_TO_ADDR
// for _x = min_x to max_x do
12090: LD_ADDR_VAR 0 11
12094: PUSH
12095: DOUBLE
12096: LD_VAR 0 7
12100: DEC
12101: ST_TO_ADDR
12102: LD_VAR 0 9
12106: PUSH
12107: FOR_TO
12108: IFFALSE 12225
// for _y = min_y to max_y do
12110: LD_ADDR_VAR 0 12
12114: PUSH
12115: DOUBLE
12116: LD_VAR 0 8
12120: DEC
12121: ST_TO_ADDR
12122: LD_VAR 0 10
12126: PUSH
12127: FOR_TO
12128: IFFALSE 12221
// begin if not ValidHex ( _x , _y ) then
12130: LD_VAR 0 11
12134: PPUSH
12135: LD_VAR 0 12
12139: PPUSH
12140: CALL_OW 488
12144: NOT
12145: IFFALSE 12149
// continue ;
12147: GO 12127
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12149: LD_VAR 0 11
12153: PPUSH
12154: LD_VAR 0 12
12158: PPUSH
12159: CALL_OW 351
12163: PUSH
12164: LD_VAR 0 11
12168: PPUSH
12169: LD_VAR 0 12
12173: PPUSH
12174: CALL_OW 554
12178: AND
12179: IFFALSE 12219
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12181: LD_ADDR_VAR 0 13
12185: PUSH
12186: LD_VAR 0 13
12190: PPUSH
12191: LD_VAR 0 13
12195: PUSH
12196: LD_INT 1
12198: PLUS
12199: PPUSH
12200: LD_VAR 0 11
12204: PUSH
12205: LD_VAR 0 12
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PPUSH
12214: CALL_OW 2
12218: ST_TO_ADDR
// end ;
12219: GO 12127
12221: POP
12222: POP
12223: GO 12107
12225: POP
12226: POP
// if not list then
12227: LD_VAR 0 13
12231: NOT
12232: IFFALSE 12236
// exit ;
12234: GO 12307
// for i in list do
12236: LD_ADDR_VAR 0 6
12240: PUSH
12241: LD_VAR 0 13
12245: PUSH
12246: FOR_IN
12247: IFFALSE 12305
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12249: LD_VAR 0 1
12253: PPUSH
12254: LD_STRING M
12256: PUSH
12257: LD_VAR 0 6
12261: PUSH
12262: LD_INT 1
12264: ARRAY
12265: PUSH
12266: LD_VAR 0 6
12270: PUSH
12271: LD_INT 2
12273: ARRAY
12274: PUSH
12275: LD_INT 0
12277: PUSH
12278: LD_INT 0
12280: PUSH
12281: LD_INT 0
12283: PUSH
12284: LD_INT 0
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: PPUSH
12299: CALL_OW 447
12303: GO 12246
12305: POP
12306: POP
// end ;
12307: LD_VAR 0 5
12311: RET
