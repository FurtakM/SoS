// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 181 0 0
// PrepareAllies ;
  12: CALL 2172 0 0
// Action ;
  16: CALL 4314 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// if not Difficulty then
  41: LD_OWVAR 67
  45: NOT
  46: IFFALSE 56
// Difficulty := 2 ;
  48: LD_ADDR_OWVAR 67
  52: PUSH
  53: LD_INT 2
  55: ST_TO_ADDR
// InitVariables ;
  56: CALL 69 0 0
// SetDiplomacy ;
  60: CALL 133 0 0
// end ; end_of_file
  64: LD_VAR 0 1
  68: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// points := 0 ;
  72: LD_ADDR_EXP 8
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// alert := false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// game_over := false ;
  88: LD_ADDR_EXP 7
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// wave_time := 0 0$00 ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// bonus_active := false ;
 104: LD_ADDR_EXP 11
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ignore_wave := false ;
 112: LD_ADDR_EXP 13
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// bonus_num := 0 ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// end ;
 128: LD_VAR 0 1
 132: RET
// export function SetDiplomacy ; begin
 133: LD_INT 0
 135: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 136: LD_INT 92
 138: PPUSH
 139: LD_INT 48
 141: PPUSH
 142: LD_INT 8
 144: PPUSH
 145: LD_INT 32796
 147: NEG
 148: PPUSH
 149: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 153: LD_INT 92
 155: PPUSH
 156: LD_INT 48
 158: PPUSH
 159: LD_INT 8
 161: PPUSH
 162: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 166: LD_INT 5
 168: PPUSH
 169: LD_INT 8
 171: PPUSH
 172: CALL_OW 343
// end ; end_of_file
 176: LD_VAR 0 1
 180: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
 198: PPUSH
 199: PPUSH
 200: PPUSH
// uc_side := 2 ;
 201: LD_ADDR_OWVAR 20
 205: PUSH
 206: LD_INT 2
 208: ST_TO_ADDR
// uc_nation := nation_arabian ;
 209: LD_ADDR_OWVAR 21
 213: PUSH
 214: LD_INT 2
 216: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 1
 222: PPUSH
 223: LD_INT 6
 225: PPUSH
 226: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 230: LD_ADDR_OWVAR 26
 234: PUSH
 235: LD_STRING Nicolas Vervecken
 237: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 238: LD_ADDR_OWVAR 33
 242: PUSH
 243: LD_STRING SecondCharsGal
 245: ST_TO_ADDR
// hc_face_number := 3 ;
 246: LD_ADDR_OWVAR 34
 250: PUSH
 251: LD_INT 3
 253: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 254: LD_ADDR_OWVAR 29
 258: PUSH
 259: LD_INT 11
 261: PUSH
 262: LD_INT 10
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: ST_TO_ADDR
// Vervecken := CreateHuman ;
 269: LD_ADDR_EXP 10
 273: PUSH
 274: CALL_OW 44
 278: ST_TO_ADDR
// InitHc ;
 279: CALL_OW 19
// uc_side := 8 ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_INT 8
 290: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 291: LD_INT 23
 293: PPUSH
 294: CALL_OW 274
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 4000
 304: PUSH
 305: LD_INT 2500
 307: PUSH
 308: LD_INT 1250
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_OWVAR 67
 320: ARRAY
 321: PPUSH
 322: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 326: LD_INT 23
 328: PPUSH
 329: CALL_OW 274
 333: PPUSH
 334: LD_INT 2
 336: PPUSH
 337: LD_INT 300
 339: PPUSH
 340: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 344: LD_INT 23
 346: PPUSH
 347: CALL_OW 274
 351: PPUSH
 352: LD_INT 3
 354: PPUSH
 355: LD_INT 100
 357: PUSH
 358: LD_INT 50
 360: PUSH
 361: LD_INT 30
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: PUSH
 369: LD_OWVAR 67
 373: ARRAY
 374: PPUSH
 375: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 379: LD_ADDR_VAR 0 14
 383: PUSH
 384: LD_INT 23
 386: PPUSH
 387: CALL_OW 250
 391: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 392: LD_ADDR_VAR 0 15
 396: PUSH
 397: LD_INT 23
 399: PPUSH
 400: CALL_OW 251
 404: ST_TO_ADDR
// team := [ ] ;
 405: LD_ADDR_VAR 0 7
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 412: LD_ADDR_VAR 0 8
 416: PUSH
 417: LD_INT 9
 419: PUSH
 420: LD_INT 8
 422: PUSH
 423: LD_INT 7
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_OWVAR 67
 435: ARRAY
 436: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 437: LD_ADDR_VAR 0 9
 441: PUSH
 442: LD_INT 11
 444: PUSH
 445: LD_INT 9
 447: PUSH
 448: LD_INT 8
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_OWVAR 67
 460: ARRAY
 461: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 462: LD_ADDR_VAR 0 10
 466: PUSH
 467: LD_INT 3
 469: PUSH
 470: LD_INT 2
 472: PUSH
 473: LD_INT 2
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: PUSH
 481: LD_OWVAR 67
 485: ARRAY
 486: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 487: LD_ADDR_VAR 0 11
 491: PUSH
 492: LD_INT 5
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: PUSH
 506: LD_OWVAR 67
 510: ARRAY
 511: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 512: LD_ADDR_VAR 0 12
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 2
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 537: LD_ADDR_VAR 0 13
 541: PUSH
 542: LD_INT 6
 544: PUSH
 545: LD_INT 5
 547: PUSH
 548: LD_INT 4
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 562: LD_ADDR_VAR 0 18
 566: PUSH
 567: LD_INT 13
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 26
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 14
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 25
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 14
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 5
 611: PUSH
 612: LD_INT 32
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 14
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 31
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 14
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 14
 659: PUSH
 660: LD_INT 3
 662: PUSH
 663: LD_INT 2
 665: PUSH
 666: LD_INT 25
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 13
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 18
 716: PUSH
 717: LD_OWVAR 67
 721: MINUS
 722: PUSH
 723: LD_INT 1
 725: PLUS
 726: PUSH
 727: FOR_TO
 728: IFFALSE 857
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 730: LD_ADDR_OWVAR 37
 734: PUSH
 735: LD_VAR 0 18
 739: PUSH
 740: LD_VAR 0 2
 744: ARRAY
 745: PUSH
 746: LD_INT 1
 748: ARRAY
 749: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 750: LD_ADDR_OWVAR 39
 754: PUSH
 755: LD_VAR 0 18
 759: PUSH
 760: LD_VAR 0 2
 764: ARRAY
 765: PUSH
 766: LD_INT 2
 768: ARRAY
 769: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 770: LD_ADDR_OWVAR 38
 774: PUSH
 775: LD_VAR 0 18
 779: PUSH
 780: LD_VAR 0 2
 784: ARRAY
 785: PUSH
 786: LD_INT 3
 788: ARRAY
 789: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 790: LD_ADDR_OWVAR 40
 794: PUSH
 795: LD_VAR 0 18
 799: PUSH
 800: LD_VAR 0 2
 804: ARRAY
 805: PUSH
 806: LD_INT 4
 808: ARRAY
 809: ST_TO_ADDR
// un := CreateVehicle ;
 810: LD_ADDR_VAR 0 6
 814: PUSH
 815: CALL_OW 45
 819: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 820: LD_VAR 0 6
 824: PPUSH
 825: LD_INT 0
 827: PPUSH
 828: LD_INT 5
 830: PPUSH
 831: CALL_OW 12
 835: PPUSH
 836: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 840: LD_VAR 0 6
 844: PPUSH
 845: LD_INT 7
 847: PPUSH
 848: LD_INT 0
 850: PPUSH
 851: CALL_OW 49
// end ;
 855: GO 727
 857: POP
 858: POP
// for i = 1 to ape_num do
 859: LD_ADDR_VAR 0 2
 863: PUSH
 864: DOUBLE
 865: LD_INT 1
 867: DEC
 868: ST_TO_ADDR
 869: LD_VAR 0 13
 873: PUSH
 874: FOR_TO
 875: IFFALSE 942
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_INT 16
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 1
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 8
 906: PPUSH
 907: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 911: LD_ADDR_VAR 0 7
 915: PUSH
 916: LD_VAR 0 7
 920: PPUSH
 921: LD_VAR 0 7
 925: PUSH
 926: LD_INT 1
 928: PLUS
 929: PPUSH
 930: CALL_OW 44
 934: PPUSH
 935: CALL_OW 2
 939: ST_TO_ADDR
// end ;
 940: GO 874
 942: POP
 943: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 8
 954: PPUSH
 955: CALL_OW 380
// l1 := CreateHuman ;
 959: LD_ADDR_EXP 2
 963: PUSH
 964: CALL_OW 44
 968: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 969: LD_EXP 2
 973: PPUSH
 974: LD_INT 23
 976: PPUSH
 977: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 981: LD_INT 1
 983: PPUSH
 984: LD_INT 1
 986: PPUSH
 987: LD_VAR 0 8
 991: PPUSH
 992: CALL_OW 380
// l2 := CreateHuman ;
 996: LD_ADDR_EXP 3
1000: PUSH
1001: CALL_OW 44
1005: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1006: LD_EXP 3
1010: PPUSH
1011: LD_INT 23
1013: PPUSH
1014: CALL_OW 52
// for class = 1 to 4 do
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: DOUBLE
1024: LD_INT 1
1026: DEC
1027: ST_TO_ADDR
1028: LD_INT 4
1030: PUSH
1031: FOR_TO
1032: IFFALSE 1131
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: DOUBLE
1040: LD_INT 1
1042: DEC
1043: ST_TO_ADDR
1044: LD_VAR 0 9
1048: PUSH
1049: LD_VAR 0 10
1053: PUSH
1054: LD_VAR 0 11
1058: PUSH
1059: LD_VAR 0 12
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_VAR 0 4
1074: ARRAY
1075: PUSH
1076: FOR_TO
1077: IFFALSE 1127
// begin PrepareHuman ( false , class , skill ) ;
1079: LD_INT 0
1081: PPUSH
1082: LD_VAR 0 4
1086: PPUSH
1087: LD_VAR 0 8
1091: PPUSH
1092: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 7
1105: PPUSH
1106: LD_VAR 0 7
1110: PUSH
1111: LD_INT 1
1113: PLUS
1114: PPUSH
1115: CALL_OW 44
1119: PPUSH
1120: CALL_OW 2
1124: ST_TO_ADDR
// end ;
1125: GO 1076
1127: POP
1128: POP
1129: GO 1031
1131: POP
1132: POP
// for i in team do
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 7
1142: PUSH
1143: FOR_IN
1144: IFFALSE 1620
// begin b := 0 ;
1146: LD_ADDR_VAR 0 5
1150: PUSH
1151: LD_INT 0
1153: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1154: LD_VAR 0 2
1158: PPUSH
1159: CALL_OW 257
1163: PUSH
1164: LD_INT 1
1166: DOUBLE
1167: EQUAL
1168: IFTRUE 1172
1170: GO 1279
1172: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 22
1180: PUSH
1181: LD_OWVAR 20
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 2
1192: PUSH
1193: LD_INT 30
1195: PUSH
1196: LD_INT 32
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 30
1205: PUSH
1206: LD_INT 31
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 58
1220: PUSH
1221: EMPTY
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: ST_TO_ADDR
// if not b then
1234: LD_VAR 0 5
1238: NOT
1239: IFFALSE 1277
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1241: LD_ADDR_VAR 0 5
1245: PUSH
1246: LD_INT 22
1248: PUSH
1249: LD_OWVAR 20
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// end ; class_engineer :
1277: GO 1518
1279: LD_INT 2
1281: DOUBLE
1282: EQUAL
1283: IFTRUE 1287
1285: GO 1326
1287: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_OWVAR 20
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 30
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
1324: GO 1518
1326: LD_INT 3
1328: DOUBLE
1329: EQUAL
1330: IFTRUE 1334
1332: GO 1423
1334: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1335: LD_ADDR_VAR 0 5
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_OWVAR 20
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 21
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 58
1364: PUSH
1365: EMPTY
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: ST_TO_ADDR
// if not b then
1378: LD_VAR 0 5
1382: NOT
1383: IFFALSE 1421
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1385: LD_ADDR_VAR 0 5
1389: PUSH
1390: LD_INT 22
1392: PUSH
1393: LD_OWVAR 20
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 30
1404: PUSH
1405: LD_INT 3
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL_OW 69
1420: ST_TO_ADDR
// end ; class_scientistic :
1421: GO 1518
1423: LD_INT 4
1425: DOUBLE
1426: EQUAL
1427: IFTRUE 1431
1429: GO 1470
1431: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1432: LD_ADDR_VAR 0 5
1436: PUSH
1437: LD_INT 22
1439: PUSH
1440: LD_OWVAR 20
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PPUSH
1463: CALL_OW 69
1467: ST_TO_ADDR
// end ; class_apeman_soldier :
1468: GO 1518
1470: LD_INT 15
1472: DOUBLE
1473: EQUAL
1474: IFTRUE 1478
1476: GO 1517
1478: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1479: LD_ADDR_VAR 0 5
1483: PUSH
1484: LD_INT 22
1486: PUSH
1487: LD_OWVAR 20
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 30
1498: PUSH
1499: LD_INT 5
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: ST_TO_ADDR
1515: GO 1518
1517: POP
// if b then
1518: LD_VAR 0 5
1522: IFFALSE 1593
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1524: LD_VAR 0 5
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: CALL_OW 266
1537: PUSH
1538: LD_INT 31
1540: EQUAL
1541: IFFALSE 1563
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_VAR 0 5
1552: PUSH
1553: LD_INT 1
1555: ARRAY
1556: PPUSH
1557: CALL 5028 0 2
1561: GO 1591
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1563: LD_VAR 0 2
1567: PPUSH
1568: LD_VAR 0 5
1572: PUSH
1573: LD_INT 1
1575: PPUSH
1576: LD_VAR 0 5
1580: PPUSH
1581: CALL_OW 12
1585: ARRAY
1586: PPUSH
1587: CALL_OW 52
1591: GO 1618
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1593: LD_VAR 0 2
1597: PPUSH
1598: LD_VAR 0 14
1602: PPUSH
1603: LD_VAR 0 15
1607: PPUSH
1608: LD_INT 15
1610: PPUSH
1611: LD_INT 0
1613: PPUSH
1614: CALL_OW 50
// end ;
1618: GO 1143
1620: POP
1621: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1622: LD_ADDR_VAR 0 16
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 2
1635: PUSH
1636: LD_INT 1
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PUSH
1644: LD_OWVAR 67
1648: ARRAY
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: PUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 5
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_OWVAR 67
1675: ARRAY
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: LD_INT 5
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 4
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: LIST
1697: PUSH
1698: LD_OWVAR 67
1702: ARRAY
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: LD_INT 30
1710: PUSH
1711: LD_INT 2
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_OWVAR 67
1729: ARRAY
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1741: LD_ADDR_VAR 0 2
1745: PUSH
1746: LD_INT 22
1748: PUSH
1749: LD_OWVAR 20
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 30
1760: PUSH
1761: LD_INT 32
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: PUSH
1777: FOR_IN
1778: IFFALSE 1951
// begin if weapons then
1780: LD_VAR 0 16
1784: IFFALSE 1908
// begin k := rand ( 1 , weapons ) ;
1786: LD_ADDR_VAR 0 3
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_VAR 0 16
1798: PPUSH
1799: CALL_OW 12
1803: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1804: LD_ADDR_VAR 0 17
1808: PUSH
1809: LD_VAR 0 16
1813: PUSH
1814: LD_VAR 0 3
1818: ARRAY
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1824: LD_ADDR_VAR 0 16
1828: PUSH
1829: LD_VAR 0 16
1833: PPUSH
1834: LD_VAR 0 3
1838: PPUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_VAR 0 16
1846: PUSH
1847: LD_VAR 0 3
1851: ARRAY
1852: PUSH
1853: LD_INT 2
1855: ARRAY
1856: PUSH
1857: LD_INT 1
1859: MINUS
1860: PPUSH
1861: CALL 5120 0 4
1865: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1866: LD_VAR 0 16
1870: PUSH
1871: LD_VAR 0 3
1875: ARRAY
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: PUSH
1881: LD_INT 0
1883: EQUAL
1884: IFFALSE 1906
// weapons := Delete ( weapons , k ) ;
1886: LD_ADDR_VAR 0 16
1890: PUSH
1891: LD_VAR 0 16
1895: PPUSH
1896: LD_VAR 0 3
1900: PPUSH
1901: CALL_OW 3
1905: ST_TO_ADDR
// end else
1906: GO 1935
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_INT 27
1915: PUSH
1916: LD_INT 23
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: CALL_OW 12
1933: ARRAY
1934: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1935: LD_VAR 0 2
1939: PPUSH
1940: LD_VAR 0 17
1944: PPUSH
1945: CALL_OW 431
// end ;
1949: GO 1777
1951: POP
1952: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1953: LD_INT 1
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 8
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: CALL_OW 380
// hc_gallery := potter ;
1972: LD_ADDR_OWVAR 33
1976: PUSH
1977: LD_STRING potter
1979: ST_TO_ADDR
// hc_face_number := 1 ;
1980: LD_ADDR_OWVAR 34
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// hc_importance := 100 ;
1988: LD_ADDR_OWVAR 32
1992: PUSH
1993: LD_INT 100
1995: ST_TO_ADDR
// hc_name := Mike Gerste ;
1996: LD_ADDR_OWVAR 26
2000: PUSH
2001: LD_STRING Mike Gerste
2003: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2004: LD_ADDR_OWVAR 29
2008: PUSH
2009: LD_INT 10
2011: PUSH
2012: LD_INT 11
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: ST_TO_ADDR
// legion_commander := CreateHuman ;
2019: LD_ADDR_EXP 1
2023: PUSH
2024: CALL_OW 44
2028: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2029: LD_EXP 1
2033: PPUSH
2034: LD_INT 23
2036: PPUSH
2037: CALL_OW 52
// uc_side := 5 ;
2041: LD_ADDR_OWVAR 20
2045: PUSH
2046: LD_INT 5
2048: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: LD_VAR 0 8
2059: PPUSH
2060: CALL_OW 380
// hc_gallery := potter ;
2064: LD_ADDR_OWVAR 33
2068: PUSH
2069: LD_STRING potter
2071: ST_TO_ADDR
// hc_face_number := 2 ;
2072: LD_ADDR_OWVAR 34
2076: PUSH
2077: LD_INT 2
2079: ST_TO_ADDR
// hc_importance := 0 ;
2080: LD_ADDR_OWVAR 32
2084: PUSH
2085: LD_INT 0
2087: ST_TO_ADDR
// hc_name := George Potter ;
2088: LD_ADDR_OWVAR 26
2092: PUSH
2093: LD_STRING George Potter
2095: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2096: LD_ADDR_OWVAR 29
2100: PUSH
2101: LD_INT 12
2103: PUSH
2104: LD_INT 9
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: ST_TO_ADDR
// potter := CreateHuman ;
2111: LD_ADDR_EXP 4
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2121: LD_EXP 4
2125: PPUSH
2126: LD_INT 4
2128: PPUSH
2129: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2133: LD_EXP 4
2137: PPUSH
2138: LD_INT 103
2140: PPUSH
2141: LD_INT 45
2143: PPUSH
2144: LD_INT 0
2146: PPUSH
2147: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2151: LD_EXP 4
2155: PPUSH
2156: LD_INT 23
2158: PPUSH
2159: CALL_OW 119
// InitHc ( ) ;
2163: CALL_OW 19
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
2178: PPUSH
// uc_side := 5 ;
2179: LD_ADDR_OWVAR 20
2183: PUSH
2184: LD_INT 5
2186: ST_TO_ADDR
// uc_nation := nation_arabian ;
2187: LD_ADDR_OWVAR 21
2191: PUSH
2192: LD_INT 2
2194: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2195: LD_ADDR_VAR 0 4
2199: PUSH
2200: LD_INT 22
2202: PUSH
2203: LD_OWVAR 20
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 30
2214: PUSH
2215: LD_INT 5
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PPUSH
2226: CALL_OW 69
2230: ST_TO_ADDR
// for i = 1 to 3 do
2231: LD_ADDR_VAR 0 2
2235: PUSH
2236: DOUBLE
2237: LD_INT 1
2239: DEC
2240: ST_TO_ADDR
2241: LD_INT 3
2243: PUSH
2244: FOR_TO
2245: IFFALSE 2283
// begin PrepareHuman ( false , 2 , 6 ) ;
2247: LD_INT 0
2249: PPUSH
2250: LD_INT 2
2252: PPUSH
2253: LD_INT 6
2255: PPUSH
2256: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2260: CALL_OW 44
2264: PPUSH
2265: LD_INT 27
2267: PPUSH
2268: LD_INT 22
2270: PPUSH
2271: LD_INT 5
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 50
// end ;
2281: GO 2244
2283: POP
2284: POP
// for i = 1 to 3 do
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: DOUBLE
2291: LD_INT 1
2293: DEC
2294: ST_TO_ADDR
2295: LD_INT 3
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2334
// begin PrepareHuman ( false , 1 , 6 ) ;
2301: LD_INT 0
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 6
2309: PPUSH
2310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2314: CALL_OW 44
2318: PPUSH
2319: LD_VAR 0 4
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 52
// end ;
2332: GO 2298
2334: POP
2335: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_INT 22
2343: PUSH
2344: LD_OWVAR 20
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: LD_INT 30
2358: PUSH
2359: LD_INT 31
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 30
2368: PUSH
2369: LD_INT 32
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2478
// begin PrepareHuman ( false , 1 , 6 ) ;
2393: LD_INT 0
2395: PPUSH
2396: LD_INT 1
2398: PPUSH
2399: LD_INT 6
2401: PPUSH
2402: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2406: CALL_OW 44
2410: PPUSH
2411: LD_VAR 0 2
2415: PPUSH
2416: CALL 5028 0 2
// if GetBType ( i ) = b_bunker then
2420: LD_VAR 0 2
2424: PPUSH
2425: CALL_OW 266
2429: PUSH
2430: LD_INT 32
2432: EQUAL
2433: IFFALSE 2476
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_INT 27
2442: PUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 24
2448: PUSH
2449: LD_INT 28
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_INT 4
2465: MOD
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: ARRAY
2471: PPUSH
2472: CALL_OW 431
// end ;
2476: GO 2390
2478: POP
2479: POP
// for i = 1 to 3 do
2480: LD_ADDR_VAR 0 2
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_INT 3
2492: PUSH
2493: FOR_TO
2494: IFFALSE 2611
// begin vc_chassis := ar_half_tracked ;
2496: LD_ADDR_OWVAR 37
2500: PUSH
2501: LD_INT 14
2503: ST_TO_ADDR
// vc_engine := engine_solar ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_INT 2
2511: ST_TO_ADDR
// vc_control := control_manual ;
2512: LD_ADDR_OWVAR 38
2516: PUSH
2517: LD_INT 1
2519: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2520: LD_ADDR_OWVAR 40
2524: PUSH
2525: LD_INT 25
2527: PUSH
2528: LD_INT 27
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_VAR 0 2
2543: ARRAY
2544: ST_TO_ADDR
// un := CreateVehicle ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2555: LD_VAR 0 3
2559: PPUSH
2560: LD_INT 5
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2567: LD_VAR 0 3
2571: PPUSH
2572: LD_INT 8
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2582: LD_INT 0
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 7
2590: PPUSH
2591: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2595: CALL_OW 44
2599: PPUSH
2600: LD_VAR 0 3
2604: PPUSH
2605: CALL_OW 52
// end ;
2609: GO 2493
2611: POP
2612: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 1
2618: PPUSH
2619: LD_INT 6
2621: PPUSH
2622: CALL_OW 380
// al_commander := CreateHuman ;
2626: LD_ADDR_EXP 5
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2636: LD_EXP 5
2640: PPUSH
2641: LD_INT 22
2643: PUSH
2644: LD_OWVAR 20
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: LD_INT 0
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL_OW 69
2671: PUSH
2672: LD_INT 1
2674: ARRAY
2675: PPUSH
2676: CALL_OW 52
// InitHc ( ) ;
2680: CALL_OW 19
// end ;
2684: LD_VAR 0 1
2688: RET
// export function ChangeSide ( ) ; var i ; begin
2689: LD_INT 0
2691: PPUSH
2692: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_INT 22
2700: PUSH
2701: LD_INT 5
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2730
// SetSide ( i , 8 ) ;
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 8
2723: PPUSH
2724: CALL_OW 235
2728: GO 2713
2730: POP
2731: POP
// end ;
2732: LD_VAR 0 1
2736: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2737: LD_INT 22
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PPUSH
2747: CALL_OW 69
2751: IFFALSE 3265
2753: GO 2755
2755: DISABLE
2756: LD_INT 0
2758: PPUSH
2759: PPUSH
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 5
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: LD_INT 21
2785: PUSH
2786: LD_INT 1
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: LD_INT 21
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PPUSH
2812: CALL_OW 69
2816: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_INT 22
2824: PUSH
2825: LD_INT 5
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 30
2834: PUSH
2835: LD_INT 32
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 3
2844: PUSH
2845: LD_INT 24
2847: PUSH
2848: LD_INT 1000
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 69
2868: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 3
2881: PUSH
2882: LD_INT 54
2884: PUSH
2885: EMPTY
2886: LIST
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 25
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 72
2910: ST_TO_ADDR
// if not list then
2911: LD_VAR 0 2
2915: NOT
2916: IFFALSE 2920
// exit ;
2918: GO 3265
// for i in list do
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: PUSH
2930: FOR_IN
2931: IFFALSE 3263
// begin if b then
2933: LD_VAR 0 5
2937: IFFALSE 3016
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PUSH
2952: LD_INT 2
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 72
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3014
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2967: LD_VAR 0 4
2971: PPUSH
2972: CALL_OW 314
2976: NOT
2977: PUSH
2978: LD_VAR 0 1
2982: PPUSH
2983: CALL_OW 110
2987: PUSH
2988: LD_INT 7
2990: NONEQUAL
2991: AND
2992: IFFALSE 3012
// ComRepairBuilding ( j , b [ 1 ] ) ;
2994: LD_VAR 0 4
2998: PPUSH
2999: LD_VAR 0 5
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: PPUSH
3008: CALL_OW 130
3012: GO 2964
3014: POP
3015: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 256
3025: PUSH
3026: LD_INT 500
3028: LESS
3029: PUSH
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 110
3039: PUSH
3040: LD_INT 7
3042: EQUAL
3043: NOT
3044: AND
3045: IFFALSE 3095
// begin ComMoveToArea ( i , guard_hill ) ;
3047: LD_VAR 0 1
3051: PPUSH
3052: LD_INT 11
3054: PPUSH
3055: CALL_OW 113
// SetTag ( i , 7 ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: LD_INT 7
3066: PPUSH
3067: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 247
3080: PUSH
3081: LD_INT 2
3083: EQUAL
3084: IFFALSE 3095
// begin AddComExitVehicle ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3095: LD_VAR 0 1
3099: PPUSH
3100: CALL_OW 256
3104: PUSH
3105: LD_INT 1000
3107: EQUAL
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 110
3118: PUSH
3119: LD_INT 7
3121: EQUAL
3122: AND
3123: PUSH
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 310
3133: NOT
3134: AND
3135: PUSH
3136: LD_VAR 0 6
3140: AND
3141: IFFALSE 3169
// begin SetTag ( i , 0 ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3155: LD_VAR 0 6
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3169: LD_VAR 0 1
3173: PPUSH
3174: CALL_OW 247
3178: PUSH
3179: LD_INT 2
3181: EQUAL
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 110
3192: PUSH
3193: LD_INT 7
3195: NONEQUAL
3196: AND
3197: PUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 314
3207: NOT
3208: AND
3209: IFFALSE 3261
// if FilterAllUnits ( [ f_side , 7 ] ) then
3211: LD_INT 22
3213: PUSH
3214: LD_INT 7
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PPUSH
3221: CALL_OW 69
3225: IFFALSE 3261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_INT 22
3234: PUSH
3235: LD_INT 7
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 69
3246: PPUSH
3247: LD_VAR 0 1
3251: PPUSH
3252: CALL_OW 74
3256: PPUSH
3257: CALL_OW 115
// end ;
3261: GO 2930
3263: POP
3264: POP
// end ; end_of_file
3265: PPOPN 6
3267: END
// export function Game ; var i , val , areas , wave ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: LD_INT 5
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3306: LD_ADDR_VAR 0 3
3310: PUSH
3311: LD_INT 10
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 30
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_OWVAR 67
3329: ARRAY
3330: ST_TO_ADDR
// wave := 1 ;
3331: LD_ADDR_VAR 0 5
3335: PUSH
3336: LD_INT 1
3338: ST_TO_ADDR
// while ( game_over = false ) do
3339: LD_EXP 7
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3511
// begin repeat begin Wait ( 0 0$01 ) ;
3349: LD_INT 35
3351: PPUSH
3352: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3356: LD_ADDR_EXP 9
3360: PUSH
3361: LD_EXP 9
3365: PUSH
3366: LD_INT 35
3368: PLUS
3369: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3370: LD_INT 22
3372: PUSH
3373: LD_INT 7
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 10
3387: LESS
3388: PUSH
3389: LD_EXP 9
3393: PUSH
3394: LD_INT 21000
3396: GREATEREQUAL
3397: OR
3398: IFFALSE 3349
// wave_time := 0 0$00 ;
3400: LD_ADDR_EXP 9
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3408: LD_INT 5250
3410: PPUSH
3411: CALL_OW 67
// if not ignore_wave then
3415: LD_EXP 13
3419: NOT
3420: IFFALSE 3501
// begin for i = 1 to wave do
3422: LD_ADDR_VAR 0 2
3426: PUSH
3427: DOUBLE
3428: LD_INT 1
3430: DEC
3431: ST_TO_ADDR
3432: LD_VAR 0 5
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3483
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3440: LD_VAR 0 3
3444: PUSH
3445: LD_VAR 0 2
3449: MUL
3450: PPUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 6
3463: MOD
3464: PUSH
3465: LD_INT 1
3467: PLUS
3468: ARRAY
3469: PPUSH
3470: CALL 3516 0 2
// Wait ( 0 0$10 ) ;
3474: LD_INT 350
3476: PPUSH
3477: CALL_OW 67
// end ;
3481: GO 3437
3483: POP
3484: POP
// wave := wave + 1 ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_VAR 0 5
3494: PUSH
3495: LD_INT 1
3497: PLUS
3498: ST_TO_ADDR
// end else
3499: GO 3509
// ignore_wave := false ;
3501: LD_ADDR_EXP 13
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// end ;
3509: GO 3339
// end ;
3511: LD_VAR 0 1
3515: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3516: LD_INT 0
3518: PPUSH
3519: PPUSH
3520: PPUSH
3521: PPUSH
// uc_side := 7 ;
3522: LD_ADDR_OWVAR 20
3526: PUSH
3527: LD_INT 7
3529: ST_TO_ADDR
// uc_nation := 2 ;
3530: LD_ADDR_OWVAR 21
3534: PUSH
3535: LD_INT 2
3537: ST_TO_ADDR
// InitHc ( ) ;
3538: CALL_OW 19
// hc_gallery :=  ;
3542: LD_ADDR_OWVAR 33
3546: PUSH
3547: LD_STRING 
3549: ST_TO_ADDR
// hc_importance := 0 ;
3550: LD_ADDR_OWVAR 32
3554: PUSH
3555: LD_INT 0
3557: ST_TO_ADDR
// hc_name :=  ;
3558: LD_ADDR_OWVAR 26
3562: PUSH
3563: LD_STRING 
3565: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3566: LD_ADDR_OWVAR 29
3570: PUSH
3571: LD_INT 10
3573: PUSH
3574: LD_OWVAR 1
3578: PUSH
3579: LD_INT 21000
3581: DIV
3582: PLUS
3583: PUSH
3584: LD_INT 10
3586: PUSH
3587: LD_OWVAR 1
3591: PUSH
3592: LD_INT 21000
3594: DIV
3595: PLUS
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// for i = 1 to val do
3601: LD_ADDR_VAR 0 4
3605: PUSH
3606: DOUBLE
3607: LD_INT 1
3609: DEC
3610: ST_TO_ADDR
3611: LD_VAR 0 1
3615: PUSH
3616: FOR_TO
3617: IFFALSE 3824
// begin if i mod 9 = 0 then
3619: LD_VAR 0 4
3623: PUSH
3624: LD_INT 9
3626: MOD
3627: PUSH
3628: LD_INT 0
3630: EQUAL
3631: IFFALSE 3643
// class := class_apeman_kamikaze else
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_INT 17
3640: ST_TO_ADDR
3641: GO 3675
// if i mod 4 = 0 then
3643: LD_VAR 0 4
3647: PUSH
3648: LD_INT 4
3650: MOD
3651: PUSH
3652: LD_INT 0
3654: EQUAL
3655: IFFALSE 3667
// class := class_apeman_soldier else
3657: LD_ADDR_VAR 0 6
3661: PUSH
3662: LD_INT 15
3664: ST_TO_ADDR
3665: GO 3675
// class := class_apeman ;
3667: LD_ADDR_VAR 0 6
3671: PUSH
3672: LD_INT 12
3674: ST_TO_ADDR
// if i mod 33 = 0 then
3675: LD_VAR 0 4
3679: PUSH
3680: LD_INT 33
3682: MOD
3683: PUSH
3684: LD_INT 0
3686: EQUAL
3687: IFFALSE 3756
// begin vc_chassis := ar_half_tracked ;
3689: LD_ADDR_OWVAR 37
3693: PUSH
3694: LD_INT 14
3696: ST_TO_ADDR
// vc_control := control_apeman ;
3697: LD_ADDR_OWVAR 38
3701: PUSH
3702: LD_INT 5
3704: ST_TO_ADDR
// vc_engine := engine_combustion ;
3705: LD_ADDR_OWVAR 39
3709: PUSH
3710: LD_INT 1
3712: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3713: LD_ADDR_OWVAR 40
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: LD_INT 29
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 1
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: CALL_OW 12
3742: ARRAY
3743: ST_TO_ADDR
// un := CreateVehicle ;
3744: LD_ADDR_VAR 0 5
3748: PUSH
3749: CALL_OW 45
3753: ST_TO_ADDR
// end else
3754: GO 3781
// begin PrepareHuman ( sex_male , class , 10 ) ;
3756: LD_INT 1
3758: PPUSH
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_INT 10
3766: PPUSH
3767: CALL_OW 380
// un := CreateHuman ;
3771: LD_ADDR_VAR 0 5
3775: PUSH
3776: CALL_OW 44
3780: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3781: LD_VAR 0 5
3785: PPUSH
3786: LD_VAR 0 2
3790: PPUSH
3791: LD_INT 0
3793: PPUSH
3794: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3798: LD_VAR 0 5
3802: PPUSH
3803: CALL_OW 250
3807: PPUSH
3808: LD_VAR 0 5
3812: PPUSH
3813: CALL_OW 251
3817: PPUSH
3818: CALL_OW 494
// end ;
3822: GO 3616
3824: POP
3825: POP
// end ;
3826: LD_VAR 0 3
3830: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3831: LD_EXP 6
3835: PUSH
3836: LD_EXP 7
3840: NOT
3841: AND
3842: IFFALSE 4128
3844: GO 3846
3846: DISABLE
3847: LD_INT 0
3849: PPUSH
3850: PPUSH
3851: PPUSH
// begin enable ;
3852: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_INT 22
3860: PUSH
3861: LD_INT 7
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// if not list then
3873: LD_VAR 0 2
3877: NOT
3878: IFFALSE 3882
// exit ;
3880: GO 4128
// for i in list do
3882: LD_ADDR_VAR 0 1
3886: PUSH
3887: LD_VAR 0 2
3891: PUSH
3892: FOR_IN
3893: IFFALSE 4126
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3895: LD_ADDR_VAR 0 3
3899: PUSH
3900: LD_INT 81
3902: PUSH
3903: LD_INT 7
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 92
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 250
3922: PUSH
3923: LD_VAR 0 1
3927: PPUSH
3928: CALL_OW 251
3932: PUSH
3933: LD_INT 15
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 69
3950: ST_TO_ADDR
// if not enemy then
3951: LD_VAR 0 3
3955: NOT
3956: IFFALSE 4014
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3958: LD_ADDR_VAR 0 3
3962: PUSH
3963: LD_INT 81
3965: PUSH
3966: LD_INT 7
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 92
3975: PUSH
3976: LD_VAR 0 1
3980: PPUSH
3981: CALL_OW 250
3985: PUSH
3986: LD_VAR 0 1
3990: PPUSH
3991: CALL_OW 251
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 69
4013: ST_TO_ADDR
// if not enemy then
4014: LD_VAR 0 3
4018: NOT
4019: IFFALSE 4077
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4021: LD_ADDR_VAR 0 3
4025: PUSH
4026: LD_INT 81
4028: PUSH
4029: LD_INT 7
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 92
4038: PUSH
4039: LD_VAR 0 1
4043: PPUSH
4044: CALL_OW 250
4048: PUSH
4049: LD_VAR 0 1
4053: PPUSH
4054: CALL_OW 251
4058: PUSH
4059: LD_INT 50
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 3
4081: NOT
4082: IFFALSE 4104
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4084: LD_ADDR_VAR 0 3
4088: PUSH
4089: LD_INT 81
4091: PUSH
4092: LD_INT 7
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: ST_TO_ADDR
// if enemy then
4104: LD_VAR 0 3
4108: IFFALSE 4124
// Attack ( i , enemy ) ;
4110: LD_VAR 0 1
4114: PPUSH
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL 4131 0 2
// end ;
4124: GO 3892
4126: POP
4127: POP
// end ;
4128: PPOPN 3
4130: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4131: LD_INT 0
4133: PPUSH
4134: PPUSH
4135: PPUSH
// if not unit then
4136: LD_VAR 0 1
4140: NOT
4141: IFFALSE 4145
// exit ;
4143: GO 4309
// targets_list := [ ] ;
4145: LD_ADDR_VAR 0 5
4149: PUSH
4150: EMPTY
4151: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_VAR 0 2
4161: PPUSH
4162: LD_INT 21
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 3
4174: PUSH
4175: LD_INT 54
4177: PUSH
4178: EMPTY
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 72
4193: PUSH
4194: LD_VAR 0 2
4198: PPUSH
4199: LD_INT 21
4201: PUSH
4202: LD_INT 2
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL_OW 72
4213: PUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: LD_INT 21
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 3
4231: PUSH
4232: LD_INT 58
4234: PUSH
4235: EMPTY
4236: LIST
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 72
4250: PUSH
4251: LD_VAR 0 2
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// for target in targets_list do
4262: LD_ADDR_VAR 0 4
4266: PUSH
4267: LD_VAR 0 5
4271: PUSH
4272: FOR_IN
4273: IFFALSE 4307
// begin if target then
4275: LD_VAR 0 4
4279: IFFALSE 4305
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_VAR 0 4
4290: PPUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 74
4300: PPUSH
4301: CALL_OW 115
// end ;
4305: GO 4272
4307: POP
4308: POP
// end ; end_of_file
4309: LD_VAR 0 3
4313: RET
// export function Action ; begin
4314: LD_INT 0
4316: PPUSH
// InGameOn ;
4317: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4321: LD_INT 23
4323: PPUSH
4324: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4328: LD_EXP 1
4332: PPUSH
4333: LD_STRING DL-1
4335: PPUSH
4336: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4340: LD_EXP 2
4344: PPUSH
4345: LD_STRING DA-1
4347: PPUSH
4348: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4352: LD_EXP 3
4356: PPUSH
4357: LD_STRING DA-2
4359: PPUSH
4360: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4364: LD_EXP 1
4368: PPUSH
4369: LD_STRING DL-2
4371: PPUSH
4372: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4376: LD_EXP 3
4380: PPUSH
4381: LD_STRING DA-3
4383: PPUSH
4384: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4388: LD_EXP 1
4392: PPUSH
4393: LD_STRING DL-3
4395: PPUSH
4396: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_STRING DA-4
4407: PPUSH
4408: CALL_OW 88
// if not dialogue_skipped then
4412: LD_OWVAR 59
4416: NOT
4417: IFFALSE 4502
// begin Wait ( 0 0$01 ) ;
4419: LD_INT 35
4421: PPUSH
4422: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4426: LD_EXP 2
4430: PUSH
4431: LD_EXP 3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4444: LD_EXP 2
4448: PPUSH
4449: LD_INT 107
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4459: LD_EXP 3
4463: PPUSH
4464: LD_INT 108
4466: PPUSH
4467: LD_INT 53
4469: PPUSH
4470: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4474: LD_EXP 2
4478: PPUSH
4479: LD_EXP 4
4483: PPUSH
4484: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4488: LD_EXP 3
4492: PPUSH
4493: LD_EXP 4
4497: PPUSH
4498: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4502: LD_INT 35
4504: PPUSH
4505: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4509: LD_EXP 2
4513: PPUSH
4514: LD_INT 107
4516: PPUSH
4517: LD_INT 53
4519: PPUSH
4520: CALL_OW 307
4524: PUSH
4525: LD_OWVAR 59
4529: OR
4530: IFFALSE 4502
// if not dialogue_skipped then
4532: LD_OWVAR 59
4536: NOT
4537: IFFALSE 4638
// begin ComTurnUnit ( potter , l1 ) ;
4539: LD_EXP 4
4543: PPUSH
4544: LD_EXP 2
4548: PPUSH
4549: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4553: LD_INT 10
4555: PPUSH
4556: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4560: LD_EXP 4
4564: PPUSH
4565: LD_INT 108
4567: PPUSH
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 0
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 483
// Wait ( 0 0$01 ) ;
4581: LD_INT 35
4583: PPUSH
4584: CALL_OW 67
// RemoveUnit ( potter ) ;
4588: LD_EXP 4
4592: PPUSH
4593: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4597: LD_EXP 2
4601: PPUSH
4602: LD_STRING DA-5
4604: PPUSH
4605: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4609: LD_EXP 3
4613: PPUSH
4614: LD_STRING DA-6
4616: PPUSH
4617: CALL_OW 88
// Wait ( 0 0$02 ) ;
4621: LD_INT 70
4623: PPUSH
4624: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4628: LD_INT 25
4630: PPUSH
4631: LD_INT 19
4633: PPUSH
4634: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4638: LD_INT 30
4640: PPUSH
4641: LD_INT 1
4643: PPUSH
4644: CALL 3516 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4648: LD_EXP 5
4652: PPUSH
4653: LD_STRING DLa-1
4655: PPUSH
4656: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4660: LD_EXP 1
4664: PPUSH
4665: LD_STRING DL-5
4667: PPUSH
4668: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4672: LD_INT 23
4674: PPUSH
4675: CALL_OW 87
// InGameOff ;
4679: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4683: LD_STRING C1
4685: PPUSH
4686: CALL_OW 337
// alert := true ;
4690: LD_ADDR_EXP 6
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4698: LD_EXP 5
4702: PPUSH
4703: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4707: LD_EXP 5
4711: PPUSH
4712: LD_INT 11
4714: PPUSH
4715: CALL_OW 173
// Wait ( 0 0$30 ) ;
4719: LD_INT 1050
4721: PPUSH
4722: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4726: LD_INT 20
4728: PPUSH
4729: LD_INT 4
4731: PPUSH
4732: CALL 3516 0 2
// Wait ( 0 0$35 ) ;
4736: LD_INT 1225
4738: PPUSH
4739: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4743: LD_INT 20
4745: PPUSH
4746: LD_INT 5
4748: PPUSH
4749: CALL 3516 0 2
// Wait ( 0 0$03 ) ;
4753: LD_INT 105
4755: PPUSH
4756: CALL_OW 67
// Game ;
4760: CALL 3268 0 0
// end ;
4764: LD_VAR 0 1
4768: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4769: LD_INT 22
4771: PUSH
4772: LD_INT 7
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: PUSH
4788: LD_EXP 8
4792: PUSH
4793: LD_INT 500
4795: GREATEREQUAL
4796: AND
4797: IFFALSE 5025
4799: GO 4801
4801: DISABLE
4802: LD_INT 0
4804: PPUSH
4805: PPUSH
// begin DialogueOn ;
4806: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4810: LD_EXP 10
4814: PPUSH
4815: LD_STRING DVr-1
4817: PPUSH
4818: CALL_OW 94
// DialogueOff ;
4822: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4826: LD_STRING QBonusInfo
4828: PPUSH
4829: CALL_OW 97
4833: PUSH
4834: LD_INT 1
4836: DOUBLE
4837: EQUAL
4838: IFTRUE 4842
4840: GO 4853
4842: POP
// bonus_active := true ; end ;
4843: LD_ADDR_EXP 11
4847: PUSH
4848: LD_INT 1
4850: ST_TO_ADDR
4851: GO 4854
4853: POP
// bonus_num := 4 ;
4854: LD_ADDR_EXP 12
4858: PUSH
4859: LD_INT 4
4861: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4862: LD_OWVAR 2
4866: PPUSH
4867: LD_INT 2
4869: PPUSH
4870: LD_INT 2
4872: PPUSH
4873: LD_INT 23
4875: PPUSH
4876: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: LD_INT 500
4887: PUSH
4888: LD_INT 3500
4890: PUSH
4891: LD_INT 5750
4893: PUSH
4894: LD_INT 10000
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// repeat wait ( [ 5 5$00 , 6 6$00 , 7 7$00 ] [ Difficulty ] ) ;
4903: LD_INT 10500
4905: PUSH
4906: LD_INT 12600
4908: PUSH
4909: LD_INT 14700
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_OWVAR 67
4921: ARRAY
4922: PPUSH
4923: CALL_OW 67
// for i = 1 to tmp do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_VAR 0 1
4941: PUSH
4942: FOR_TO
4943: IFFALSE 4975
// if points >= tmp [ i ] then
4945: LD_EXP 8
4949: PUSH
4950: LD_VAR 0 1
4954: PUSH
4955: LD_VAR 0 2
4959: ARRAY
4960: GREATEREQUAL
4961: IFFALSE 4973
// bonus_num := i ;
4963: LD_ADDR_EXP 12
4967: PUSH
4968: LD_VAR 0 2
4972: ST_TO_ADDR
4973: GO 4942
4975: POP
4976: POP
// case Query ( QBonusInfo ) of 1 :
4977: LD_STRING QBonusInfo
4979: PPUSH
4980: CALL_OW 97
4984: PUSH
4985: LD_INT 1
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5014
4993: POP
// SetArtifactUse ( your_side , art_use_exclamation , art_instant , main_base ) ; end ;
4994: LD_OWVAR 2
4998: PPUSH
4999: LD_INT 12
5001: PPUSH
5002: LD_INT 2
5004: PPUSH
5005: LD_INT 23
5007: PPUSH
5008: CALL_OW 468
5012: GO 5015
5014: POP
// until points >= 15000 ;
5015: LD_EXP 8
5019: PUSH
5020: LD_INT 15000
5022: GREATEREQUAL
5023: IFFALSE 4903
// end ; end_of_file
5025: PPOPN 2
5027: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5028: LD_INT 0
5030: PPUSH
5031: PPUSH
// dir := GetDir ( b ) ;
5032: LD_ADDR_VAR 0 4
5036: PUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 254
5046: ST_TO_ADDR
// if dir < 3 then
5047: LD_VAR 0 4
5051: PUSH
5052: LD_INT 3
5054: LESS
5055: IFFALSE 5073
// dir := dir + 3 else
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: LD_VAR 0 4
5066: PUSH
5067: LD_INT 3
5069: PLUS
5070: ST_TO_ADDR
5071: GO 5087
// dir := dir - 3 ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 3
5085: MINUS
5086: ST_TO_ADDR
// SetDir ( un , dir ) ;
5087: LD_VAR 0 1
5091: PPUSH
5092: LD_VAR 0 4
5096: PPUSH
5097: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5101: LD_VAR 0 1
5105: PPUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: CALL_OW 52
// end ;
5115: LD_VAR 0 3
5119: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5125: LD_ADDR_VAR 0 7
5129: PUSH
5130: LD_VAR 0 1
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_VAR 0 3
5145: PPUSH
5146: LD_VAR 0 4
5150: PPUSH
5151: CALL_OW 1
5155: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_VAR 0 2
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 1
5180: ST_TO_ADDR
// result := tab ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_VAR 0 1
5190: ST_TO_ADDR
// end ;
5191: LD_VAR 0 5
5195: RET
// export function IsDriver ( unit ) ; begin
5196: LD_INT 0
5198: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5199: LD_VAR 0 1
5203: PUSH
5204: LD_INT 55
5206: PUSH
5207: EMPTY
5208: LIST
5209: PPUSH
5210: CALL_OW 69
5214: IN
5215: IFFALSE 5234
// result := IsInUnit ( unit ) else
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: CALL_OW 310
5231: ST_TO_ADDR
5232: GO 5242
// result := false ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: LD_INT 0
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 2
5246: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5247: LD_INT 0
5249: PPUSH
5250: PPUSH
5251: PPUSH
// if not GetControl ( veh ) = control_manual then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 263
5261: PUSH
5262: LD_INT 1
5264: EQUAL
5265: NOT
5266: IFFALSE 5278
// result := false else
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
5276: GO 5423
// if veh in FilterAllUnits ( [ f_empty ] ) then
5278: LD_VAR 0 1
5282: PUSH
5283: LD_INT 58
5285: PUSH
5286: EMPTY
5287: LIST
5288: PPUSH
5289: CALL_OW 69
5293: IN
5294: IFFALSE 5306
// result := false else
5296: LD_ADDR_VAR 0 2
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
5304: GO 5423
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5306: LD_ADDR_VAR 0 4
5310: PUSH
5311: LD_INT 22
5313: PUSH
5314: LD_VAR 0 1
5318: PPUSH
5319: CALL_OW 255
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 55
5330: PUSH
5331: EMPTY
5332: LIST
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if not filter then
5343: LD_VAR 0 4
5347: NOT
5348: IFFALSE 5360
// result := false else
5350: LD_ADDR_VAR 0 2
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
5358: GO 5423
// for i = 1 to filter do
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_VAR 0 4
5374: PUSH
5375: FOR_TO
5376: IFFALSE 5421
// if IsDriver ( filter [ i ] ) = veh then
5378: LD_VAR 0 4
5382: PUSH
5383: LD_VAR 0 3
5387: ARRAY
5388: PPUSH
5389: CALL 5196 0 1
5393: PUSH
5394: LD_VAR 0 1
5398: EQUAL
5399: IFFALSE 5419
// begin result := filter [ i ] ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: LD_VAR 0 3
5415: ARRAY
5416: ST_TO_ADDR
// break ;
5417: GO 5421
// end ;
5419: GO 5375
5421: POP
5422: POP
// end ; end ; end_of_file
5423: LD_VAR 0 2
5427: RET
// on UnitDestroyed ( un ) do begin if un in [ legion_commander , main_base ] then
5428: LD_VAR 0 1
5432: PUSH
5433: LD_EXP 1
5437: PUSH
5438: LD_INT 23
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: IN
5445: IFFALSE 5455
// game_over := true ;
5447: LD_ADDR_EXP 7
5451: PUSH
5452: LD_INT 1
5454: ST_TO_ADDR
// if un = al_commander then
5455: LD_VAR 0 1
5459: PUSH
5460: LD_EXP 5
5464: EQUAL
5465: IFFALSE 5471
// ChangeSide ( ) ;
5467: CALL 2689 0 0
// if GetSide ( un ) = 7 then
5471: LD_VAR 0 1
5475: PPUSH
5476: CALL_OW 255
5480: PUSH
5481: LD_INT 7
5483: EQUAL
5484: IFFALSE 5602
// begin if GetClass ( un ) = class_apeman then
5486: LD_VAR 0 1
5490: PPUSH
5491: CALL_OW 257
5495: PUSH
5496: LD_INT 12
5498: EQUAL
5499: IFFALSE 5515
// points := points + 6 ;
5501: LD_ADDR_EXP 8
5505: PUSH
5506: LD_EXP 8
5510: PUSH
5511: LD_INT 6
5513: PLUS
5514: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5515: LD_VAR 0 1
5519: PPUSH
5520: CALL_OW 257
5524: PUSH
5525: LD_INT 17
5527: EQUAL
5528: IFFALSE 5544
// points := points + 11 ;
5530: LD_ADDR_EXP 8
5534: PUSH
5535: LD_EXP 8
5539: PUSH
5540: LD_INT 11
5542: PLUS
5543: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5544: LD_VAR 0 1
5548: PPUSH
5549: CALL_OW 257
5553: PUSH
5554: LD_INT 15
5556: EQUAL
5557: IFFALSE 5573
// points := points + 14 ;
5559: LD_ADDR_EXP 8
5563: PUSH
5564: LD_EXP 8
5568: PUSH
5569: LD_INT 14
5571: PLUS
5572: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5573: LD_VAR 0 1
5577: PPUSH
5578: CALL_OW 247
5582: PUSH
5583: LD_INT 2
5585: EQUAL
5586: IFFALSE 5602
// points := points + 50 ;
5588: LD_ADDR_EXP 8
5592: PUSH
5593: LD_EXP 8
5597: PUSH
5598: LD_INT 50
5600: PLUS
5601: ST_TO_ADDR
// end ; end ;
5602: PPOPN 1
5604: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5605: LD_EXP 5
5609: PPUSH
5610: CALL_OW 256
5614: PUSH
5615: LD_INT 1000
5617: LESS
5618: IFFALSE 5650
5620: GO 5622
5622: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5623: LD_EXP 5
5627: PPUSH
5628: CALL_OW 504
5632: PPUSH
5633: CALL_OW 255
5637: PUSH
5638: LD_INT 8
5640: EQUAL
5641: IFFALSE 5650
// YouLost (  ) ;
5643: LD_STRING 
5645: PPUSH
5646: CALL_OW 104
5650: END
// on DialogueSkipped ( value ) do var i ;
5651: LD_INT 0
5653: PPUSH
// begin RemoveUnit ( potter ) ;
5654: LD_EXP 4
5658: PPUSH
5659: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5663: LD_EXP 2
5667: PUSH
5668: LD_EXP 3
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: PPUSH
5677: CALL_OW 122
// Wait ( 1 ) ;
5681: LD_INT 1
5683: PPUSH
5684: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5688: LD_EXP 2
5692: PPUSH
5693: LD_INT 107
5695: PPUSH
5696: LD_INT 53
5698: PPUSH
5699: LD_INT 0
5701: PPUSH
5702: LD_INT 0
5704: PPUSH
5705: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5709: LD_EXP 3
5713: PPUSH
5714: LD_INT 108
5716: PPUSH
5717: LD_INT 53
5719: PPUSH
5720: LD_INT 0
5722: PPUSH
5723: LD_INT 0
5725: PPUSH
5726: CALL_OW 483
// Wait ( 1 ) ;
5730: LD_INT 1
5732: PPUSH
5733: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5737: LD_EXP 2
5741: PUSH
5742: LD_EXP 3
5746: PUSH
5747: EMPTY
5748: LIST
5749: LIST
5750: PPUSH
5751: LD_INT 108
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 118
// end ;
5761: PPOPN 2
5763: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5764: LD_INT 0
5766: PPUSH
5767: PPUSH
5768: PPUSH
5769: PPUSH
5770: PPUSH
5771: PPUSH
// begin DialogueOn ;
5772: CALL_OW 6
// uc_side := 8 ;
5776: LD_ADDR_OWVAR 20
5780: PUSH
5781: LD_INT 8
5783: ST_TO_ADDR
// uc_nation := 2 ;
5784: LD_ADDR_OWVAR 21
5788: PUSH
5789: LD_INT 2
5791: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5792: LD_ADDR_VAR 0 5
5796: PUSH
5797: LD_STRING QBonus
5799: PUSH
5800: LD_EXP 12
5804: STR
5805: ST_TO_ADDR
// off := true ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_INT 1
5813: ST_TO_ADDR
// units := [ ] ;
5814: LD_ADDR_VAR 0 7
5818: PUSH
5819: EMPTY
5820: ST_TO_ADDR
// crates := 0 ;
5821: LD_ADDR_VAR 0 8
5825: PUSH
5826: LD_INT 0
5828: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5829: LD_EXP 10
5833: PPUSH
5834: LD_STRING DVr-2
5836: PPUSH
5837: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5841: LD_INT 10
5843: PPUSH
5844: CALL_OW 67
// case Query ( bonus ) of 1 :
5848: LD_VAR 0 5
5852: PPUSH
5853: CALL_OW 97
5857: PUSH
5858: LD_INT 1
5860: DOUBLE
5861: EQUAL
5862: IFTRUE 5866
5864: GO 5951
5866: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5867: LD_ADDR_VAR 0 9
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 2
5877: PUSH
5878: LD_INT 5
5880: PUSH
5881: LD_INT 8
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_EXP 12
5894: ARRAY
5895: ST_TO_ADDR
// for i = 1 to tmp do
5896: LD_ADDR_VAR 0 10
5900: PUSH
5901: DOUBLE
5902: LD_INT 1
5904: DEC
5905: ST_TO_ADDR
5906: LD_VAR 0 9
5910: PUSH
5911: FOR_TO
5912: IFFALSE 5947
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5914: LD_INT 0
5916: PPUSH
5917: LD_INT 15
5919: PPUSH
5920: LD_VAR 0 9
5924: PPUSH
5925: CALL_OW 380
// units := units ^ CreateHuman ;
5929: LD_ADDR_VAR 0 7
5933: PUSH
5934: LD_VAR 0 7
5938: PUSH
5939: CALL_OW 44
5943: ADD
5944: ST_TO_ADDR
// end ;
5945: GO 5911
5947: POP
5948: POP
// end ; 2 :
5949: GO 6359
5951: LD_INT 2
5953: DOUBLE
5954: EQUAL
5955: IFTRUE 5959
5957: GO 5991
5959: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
5960: LD_ADDR_VAR 0 8
5964: PUSH
5965: LD_INT 100
5967: PUSH
5968: LD_INT 150
5970: PUSH
5971: LD_INT 350
5973: PUSH
5974: LD_INT 500
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: LIST
5981: LIST
5982: PUSH
5983: LD_EXP 12
5987: ARRAY
5988: ST_TO_ADDR
// end ; 3 :
5989: GO 6359
5991: LD_INT 3
5993: DOUBLE
5994: EQUAL
5995: IFTRUE 5999
5997: GO 6339
5999: POP
// begin if bonus_num = 1 then
6000: LD_EXP 12
6004: PUSH
6005: LD_INT 1
6007: EQUAL
6008: IFFALSE 6018
// ignore_wave := true ;
6010: LD_ADDR_EXP 13
6014: PUSH
6015: LD_INT 1
6017: ST_TO_ADDR
// if bonus_num = 2 then
6018: LD_EXP 12
6022: PUSH
6023: LD_INT 2
6025: EQUAL
6026: IFFALSE 6146
// begin for i = 1 to 2 do
6028: LD_ADDR_VAR 0 10
6032: PUSH
6033: DOUBLE
6034: LD_INT 1
6036: DEC
6037: ST_TO_ADDR
6038: LD_INT 2
6040: PUSH
6041: FOR_TO
6042: IFFALSE 6144
// begin uc_nation := nation_arabian ;
6044: LD_ADDR_OWVAR 21
6048: PUSH
6049: LD_INT 2
6051: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6052: LD_ADDR_OWVAR 37
6056: PUSH
6057: LD_INT 14
6059: ST_TO_ADDR
// vc_engine := engine_siberite ;
6060: LD_ADDR_OWVAR 39
6064: PUSH
6065: LD_INT 3
6067: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6068: LD_ADDR_OWVAR 38
6072: PUSH
6073: LD_INT 2
6075: PUSH
6076: LD_INT 5
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: LD_INT 1
6085: PPUSH
6086: LD_INT 2
6088: PPUSH
6089: CALL_OW 12
6093: ARRAY
6094: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6095: LD_ADDR_OWVAR 40
6099: PUSH
6100: LD_INT 28
6102: PUSH
6103: LD_INT 27
6105: PUSH
6106: LD_INT 25
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: LIST
6113: PUSH
6114: LD_INT 1
6116: PPUSH
6117: LD_INT 3
6119: PPUSH
6120: CALL_OW 12
6124: ARRAY
6125: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6126: LD_ADDR_VAR 0 7
6130: PUSH
6131: LD_VAR 0 7
6135: PUSH
6136: CALL_OW 45
6140: ADD
6141: ST_TO_ADDR
// end ;
6142: GO 6041
6144: POP
6145: POP
// end ; if bonus_num = 3 then
6146: LD_EXP 12
6150: PUSH
6151: LD_INT 3
6153: EQUAL
6154: IFFALSE 6278
// begin for i = 1 to 4 do
6156: LD_ADDR_VAR 0 10
6160: PUSH
6161: DOUBLE
6162: LD_INT 1
6164: DEC
6165: ST_TO_ADDR
6166: LD_INT 4
6168: PUSH
6169: FOR_TO
6170: IFFALSE 6276
// begin uc_nation := nation_arabian ;
6172: LD_ADDR_OWVAR 21
6176: PUSH
6177: LD_INT 2
6179: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6180: LD_ADDR_OWVAR 37
6184: PUSH
6185: LD_INT 14
6187: ST_TO_ADDR
// vc_engine := engine_siberite ;
6188: LD_ADDR_OWVAR 39
6192: PUSH
6193: LD_INT 3
6195: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6196: LD_ADDR_OWVAR 38
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: LD_INT 5
6206: PUSH
6207: EMPTY
6208: LIST
6209: LIST
6210: PUSH
6211: LD_INT 1
6213: PPUSH
6214: LD_INT 2
6216: PPUSH
6217: CALL_OW 12
6221: ARRAY
6222: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6223: LD_ADDR_OWVAR 40
6227: PUSH
6228: LD_INT 28
6230: PUSH
6231: LD_INT 27
6233: PUSH
6234: LD_INT 28
6236: PUSH
6237: LD_INT 25
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 4
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6258: LD_ADDR_VAR 0 7
6262: PUSH
6263: LD_VAR 0 7
6267: PUSH
6268: CALL_OW 45
6272: ADD
6273: ST_TO_ADDR
// end ;
6274: GO 6169
6276: POP
6277: POP
// end ; if bonus_num = 4 then
6278: LD_EXP 12
6282: PUSH
6283: LD_INT 4
6285: EQUAL
6286: IFFALSE 6337
// for i = 1 to 3 do
6288: LD_ADDR_VAR 0 10
6292: PUSH
6293: DOUBLE
6294: LD_INT 1
6296: DEC
6297: ST_TO_ADDR
6298: LD_INT 3
6300: PUSH
6301: FOR_TO
6302: IFFALSE 6335
// begin PrepareHuman ( false , 3 , 8 ) ;
6304: LD_INT 0
6306: PPUSH
6307: LD_INT 3
6309: PPUSH
6310: LD_INT 8
6312: PPUSH
6313: CALL_OW 380
// units := units ^ CreateHuman ;
6317: LD_ADDR_VAR 0 7
6321: PUSH
6322: LD_VAR 0 7
6326: PUSH
6327: CALL_OW 44
6331: ADD
6332: ST_TO_ADDR
// end ;
6333: GO 6301
6335: POP
6336: POP
// end ; 4 :
6337: GO 6359
6339: LD_INT 4
6341: DOUBLE
6342: EQUAL
6343: IFTRUE 6347
6345: GO 6358
6347: POP
// off := false ; end ;
6348: LD_ADDR_VAR 0 6
6352: PUSH
6353: LD_INT 0
6355: ST_TO_ADDR
6356: GO 6359
6358: POP
// DialogueOff ;
6359: CALL_OW 7
// if not off then
6363: LD_VAR 0 6
6367: NOT
6368: IFFALSE 6374
// exit else
6370: GO 6553
6372: GO 6427
// begin SetArtifactUse ( your_side , art_use_exclamation , art_no , main_base ) ;
6374: LD_OWVAR 2
6378: PPUSH
6379: LD_INT 12
6381: PPUSH
6382: LD_INT 0
6384: PPUSH
6385: LD_INT 23
6387: PPUSH
6388: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6392: LD_EXP 10
6396: PPUSH
6397: LD_STRING DVr-3
6399: PUSH
6400: LD_STRING DVr-3a
6402: PUSH
6403: LD_STRING DVr-3b
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: LD_INT 1
6413: PPUSH
6414: LD_INT 3
6416: PPUSH
6417: CALL_OW 12
6421: ARRAY
6422: PPUSH
6423: CALL_OW 94
// end ; if units then
6427: LD_VAR 0 7
6431: IFFALSE 6495
// for i in units do
6433: LD_ADDR_VAR 0 10
6437: PUSH
6438: LD_VAR 0 7
6442: PUSH
6443: FOR_IN
6444: IFFALSE 6493
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6446: LD_VAR 0 10
6450: PPUSH
6451: LD_INT 92
6453: PPUSH
6454: LD_INT 49
6456: PPUSH
6457: LD_INT 20
6459: PPUSH
6460: LD_INT 0
6462: PPUSH
6463: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6467: LD_VAR 0 10
6471: PPUSH
6472: CALL_OW 250
6476: PPUSH
6477: LD_VAR 0 10
6481: PPUSH
6482: CALL_OW 251
6486: PPUSH
6487: CALL_OW 494
// end ;
6491: GO 6443
6493: POP
6494: POP
// if crates then
6495: LD_VAR 0 8
6499: IFFALSE 6553
// for i = 1 to ( crates div 50 ) do
6501: LD_ADDR_VAR 0 10
6505: PUSH
6506: DOUBLE
6507: LD_INT 1
6509: DEC
6510: ST_TO_ADDR
6511: LD_VAR 0 8
6515: PUSH
6516: LD_INT 50
6518: DIV
6519: PUSH
6520: FOR_TO
6521: IFFALSE 6551
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6523: LD_INT 5
6525: PPUSH
6526: LD_INT 92
6528: PPUSH
6529: LD_INT 49
6531: PPUSH
6532: LD_INT 30
6534: PPUSH
6535: LD_INT 1
6537: PPUSH
6538: CALL_OW 56
// wait ( 0 0$02 ) ;
6542: LD_INT 70
6544: PPUSH
6545: CALL_OW 67
// end ;
6549: GO 6520
6551: POP
6552: POP
// end ;
6553: PPOPN 10
6555: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6556: LD_VAR 0 1
6560: PPUSH
6561: LD_VAR 0 2
6565: PPUSH
6566: LD_VAR 0 3
6570: PPUSH
6571: CALL 17512 0 3
// end ;
6575: PPOPN 3
6577: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6578: LD_VAR 0 1
6582: PPUSH
6583: CALL 17610 0 1
// end ; end_of_file
6587: PPOPN 1
6589: END
// every 0 0$01 trigger not game_over do
6590: LD_EXP 7
6594: NOT
6595: IFFALSE 6628
6597: GO 6599
6599: DISABLE
// begin enable ;
6600: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6601: LD_ADDR_OWVAR 47
6605: PUSH
6606: LD_STRING #tick
6608: PUSH
6609: LD_OWVAR 1
6613: PUSH
6614: LD_STRING #points
6616: PUSH
6617: LD_EXP 8
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: ST_TO_ADDR
// end ;
6628: END
// every 0 0$01 trigger game_over do
6629: LD_EXP 7
6633: IFFALSE 6692
6635: GO 6637
6637: DISABLE
// begin Wait ( 0 0$02 ) ;
6638: LD_INT 70
6640: PPUSH
6641: CALL_OW 67
// DialogueOn ;
6645: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6649: LD_ADDR_OWVAR 47
6653: PUSH
6654: LD_STRING #game-points
6656: PUSH
6657: LD_OWVAR 78
6661: PUSH
6662: LD_EXP 8
6666: PUSH
6667: LD_STRING #game-time
6669: PUSH
6670: LD_OWVAR 1
6674: PUSH
6675: LD_STRING #game-difficulty
6677: PUSH
6678: LD_OWVAR 67
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: ST_TO_ADDR
// end ; end_of_file
6692: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6693: LD_OWVAR 1
6697: PUSH
6698: LD_INT 52500
6700: LESS
6701: IFFALSE 6725
6703: GO 6705
6705: DISABLE
// begin enable ;
6706: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6707: LD_INT 1
6709: PPUSH
6710: LD_INT 5
6712: PPUSH
6713: CALL_OW 12
6717: PPUSH
6718: LD_INT 1
6720: PPUSH
6721: CALL_OW 57
// end ; end_of_file
6725: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
6726: GO 6728
6728: DISABLE
// begin ru_radar := 98 ;
6729: LD_ADDR_EXP 14
6733: PUSH
6734: LD_INT 98
6736: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
6737: LD_ADDR_EXP 15
6741: PUSH
6742: LD_INT 89
6744: ST_TO_ADDR
// us_hack := 99 ;
6745: LD_ADDR_EXP 16
6749: PUSH
6750: LD_INT 99
6752: ST_TO_ADDR
// us_artillery := 97 ;
6753: LD_ADDR_EXP 17
6757: PUSH
6758: LD_INT 97
6760: ST_TO_ADDR
// ar_bio_bomb := 91 ;
6761: LD_ADDR_EXP 18
6765: PUSH
6766: LD_INT 91
6768: ST_TO_ADDR
// end ; end_of_file end_of_file
6769: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6770: GO 6772
6772: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6773: LD_STRING initStreamRollete();
6775: PPUSH
6776: CALL_OW 559
// InitStreamMode ;
6780: CALL 6789 0 0
// DefineStreamItems ( ) ;
6784: CALL 7229 0 0
// end ;
6788: END
// function InitStreamMode ; begin
6789: LD_INT 0
6791: PPUSH
// streamModeActive := false ;
6792: LD_ADDR_EXP 19
6796: PUSH
6797: LD_INT 0
6799: ST_TO_ADDR
// normalCounter := 26 ;
6800: LD_ADDR_EXP 20
6804: PUSH
6805: LD_INT 26
6807: ST_TO_ADDR
// hardcoreCounter := 12 ;
6808: LD_ADDR_EXP 21
6812: PUSH
6813: LD_INT 12
6815: ST_TO_ADDR
// sRocket := false ;
6816: LD_ADDR_EXP 24
6820: PUSH
6821: LD_INT 0
6823: ST_TO_ADDR
// sSpeed := false ;
6824: LD_ADDR_EXP 23
6828: PUSH
6829: LD_INT 0
6831: ST_TO_ADDR
// sEngine := false ;
6832: LD_ADDR_EXP 25
6836: PUSH
6837: LD_INT 0
6839: ST_TO_ADDR
// sSpec := false ;
6840: LD_ADDR_EXP 22
6844: PUSH
6845: LD_INT 0
6847: ST_TO_ADDR
// sLevel := false ;
6848: LD_ADDR_EXP 26
6852: PUSH
6853: LD_INT 0
6855: ST_TO_ADDR
// sArmoury := false ;
6856: LD_ADDR_EXP 27
6860: PUSH
6861: LD_INT 0
6863: ST_TO_ADDR
// sRadar := false ;
6864: LD_ADDR_EXP 28
6868: PUSH
6869: LD_INT 0
6871: ST_TO_ADDR
// sBunker := false ;
6872: LD_ADDR_EXP 29
6876: PUSH
6877: LD_INT 0
6879: ST_TO_ADDR
// sHack := false ;
6880: LD_ADDR_EXP 30
6884: PUSH
6885: LD_INT 0
6887: ST_TO_ADDR
// sFire := false ;
6888: LD_ADDR_EXP 31
6892: PUSH
6893: LD_INT 0
6895: ST_TO_ADDR
// sRefresh := false ;
6896: LD_ADDR_EXP 32
6900: PUSH
6901: LD_INT 0
6903: ST_TO_ADDR
// sExp := false ;
6904: LD_ADDR_EXP 33
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// sDepot := false ;
6912: LD_ADDR_EXP 34
6916: PUSH
6917: LD_INT 0
6919: ST_TO_ADDR
// sFlag := false ;
6920: LD_ADDR_EXP 35
6924: PUSH
6925: LD_INT 0
6927: ST_TO_ADDR
// sKamikadze := false ;
6928: LD_ADDR_EXP 43
6932: PUSH
6933: LD_INT 0
6935: ST_TO_ADDR
// sTroll := false ;
6936: LD_ADDR_EXP 44
6940: PUSH
6941: LD_INT 0
6943: ST_TO_ADDR
// sSlow := false ;
6944: LD_ADDR_EXP 45
6948: PUSH
6949: LD_INT 0
6951: ST_TO_ADDR
// sLack := false ;
6952: LD_ADDR_EXP 46
6956: PUSH
6957: LD_INT 0
6959: ST_TO_ADDR
// sTank := false ;
6960: LD_ADDR_EXP 48
6964: PUSH
6965: LD_INT 0
6967: ST_TO_ADDR
// sRemote := false ;
6968: LD_ADDR_EXP 49
6972: PUSH
6973: LD_INT 0
6975: ST_TO_ADDR
// sPowell := false ;
6976: LD_ADDR_EXP 50
6980: PUSH
6981: LD_INT 0
6983: ST_TO_ADDR
// sTeleport := false ;
6984: LD_ADDR_EXP 53
6988: PUSH
6989: LD_INT 0
6991: ST_TO_ADDR
// sOilTower := false ;
6992: LD_ADDR_EXP 55
6996: PUSH
6997: LD_INT 0
6999: ST_TO_ADDR
// sShovel := false ;
7000: LD_ADDR_EXP 56
7004: PUSH
7005: LD_INT 0
7007: ST_TO_ADDR
// sSheik := false ;
7008: LD_ADDR_EXP 57
7012: PUSH
7013: LD_INT 0
7015: ST_TO_ADDR
// sEarthquake := false ;
7016: LD_ADDR_EXP 59
7020: PUSH
7021: LD_INT 0
7023: ST_TO_ADDR
// sAI := false ;
7024: LD_ADDR_EXP 60
7028: PUSH
7029: LD_INT 0
7031: ST_TO_ADDR
// sCargo := false ;
7032: LD_ADDR_EXP 63
7036: PUSH
7037: LD_INT 0
7039: ST_TO_ADDR
// sDLaser := false ;
7040: LD_ADDR_EXP 64
7044: PUSH
7045: LD_INT 0
7047: ST_TO_ADDR
// sExchange := false ;
7048: LD_ADDR_EXP 65
7052: PUSH
7053: LD_INT 0
7055: ST_TO_ADDR
// sFac := false ;
7056: LD_ADDR_EXP 66
7060: PUSH
7061: LD_INT 0
7063: ST_TO_ADDR
// sPower := false ;
7064: LD_ADDR_EXP 67
7068: PUSH
7069: LD_INT 0
7071: ST_TO_ADDR
// sRandom := false ;
7072: LD_ADDR_EXP 68
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// sShield := false ;
7080: LD_ADDR_EXP 69
7084: PUSH
7085: LD_INT 0
7087: ST_TO_ADDR
// sTime := false ;
7088: LD_ADDR_EXP 70
7092: PUSH
7093: LD_INT 0
7095: ST_TO_ADDR
// sTools := false ;
7096: LD_ADDR_EXP 71
7100: PUSH
7101: LD_INT 0
7103: ST_TO_ADDR
// sSold := false ;
7104: LD_ADDR_EXP 36
7108: PUSH
7109: LD_INT 0
7111: ST_TO_ADDR
// sDiff := false ;
7112: LD_ADDR_EXP 37
7116: PUSH
7117: LD_INT 0
7119: ST_TO_ADDR
// sFog := false ;
7120: LD_ADDR_EXP 40
7124: PUSH
7125: LD_INT 0
7127: ST_TO_ADDR
// sReset := false ;
7128: LD_ADDR_EXP 41
7132: PUSH
7133: LD_INT 0
7135: ST_TO_ADDR
// sSun := false ;
7136: LD_ADDR_EXP 42
7140: PUSH
7141: LD_INT 0
7143: ST_TO_ADDR
// sTiger := false ;
7144: LD_ADDR_EXP 38
7148: PUSH
7149: LD_INT 0
7151: ST_TO_ADDR
// sBomb := false ;
7152: LD_ADDR_EXP 39
7156: PUSH
7157: LD_INT 0
7159: ST_TO_ADDR
// sWound := false ;
7160: LD_ADDR_EXP 47
7164: PUSH
7165: LD_INT 0
7167: ST_TO_ADDR
// sBetray := false ;
7168: LD_ADDR_EXP 51
7172: PUSH
7173: LD_INT 0
7175: ST_TO_ADDR
// sContamin := false ;
7176: LD_ADDR_EXP 52
7180: PUSH
7181: LD_INT 0
7183: ST_TO_ADDR
// sOil := false ;
7184: LD_ADDR_EXP 54
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// sStu := false ;
7192: LD_ADDR_EXP 58
7196: PUSH
7197: LD_INT 0
7199: ST_TO_ADDR
// sBazooka := false ;
7200: LD_ADDR_EXP 61
7204: PUSH
7205: LD_INT 0
7207: ST_TO_ADDR
// sMortar := false ;
7208: LD_ADDR_EXP 62
7212: PUSH
7213: LD_INT 0
7215: ST_TO_ADDR
// sRanger := false ;
7216: LD_ADDR_EXP 72
7220: PUSH
7221: LD_INT 0
7223: ST_TO_ADDR
// end ;
7224: LD_VAR 0 1
7228: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
7229: LD_INT 0
7231: PPUSH
7232: PPUSH
7233: PPUSH
7234: PPUSH
7235: PPUSH
// result := [ ] ;
7236: LD_ADDR_VAR 0 1
7240: PUSH
7241: EMPTY
7242: ST_TO_ADDR
// if campaign_id = 1 then
7243: LD_OWVAR 69
7247: PUSH
7248: LD_INT 1
7250: EQUAL
7251: IFFALSE 10187
// begin case mission_number of 1 :
7253: LD_OWVAR 70
7257: PUSH
7258: LD_INT 1
7260: DOUBLE
7261: EQUAL
7262: IFTRUE 7266
7264: GO 7330
7266: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
7267: LD_ADDR_VAR 0 1
7271: PUSH
7272: LD_INT 2
7274: PUSH
7275: LD_INT 4
7277: PUSH
7278: LD_INT 11
7280: PUSH
7281: LD_INT 12
7283: PUSH
7284: LD_INT 15
7286: PUSH
7287: LD_INT 16
7289: PUSH
7290: LD_INT 22
7292: PUSH
7293: LD_INT 23
7295: PUSH
7296: LD_INT 26
7298: PUSH
7299: EMPTY
7300: LIST
7301: LIST
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: LIST
7307: LIST
7308: LIST
7309: PUSH
7310: LD_INT 101
7312: PUSH
7313: LD_INT 102
7315: PUSH
7316: LD_INT 106
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: LIST
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: ST_TO_ADDR
7328: GO 10187
7330: LD_INT 2
7332: DOUBLE
7333: EQUAL
7334: IFTRUE 7338
7336: GO 7410
7338: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7339: LD_ADDR_VAR 0 1
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: LD_INT 11
7352: PUSH
7353: LD_INT 12
7355: PUSH
7356: LD_INT 15
7358: PUSH
7359: LD_INT 16
7361: PUSH
7362: LD_INT 22
7364: PUSH
7365: LD_INT 23
7367: PUSH
7368: LD_INT 26
7370: PUSH
7371: EMPTY
7372: LIST
7373: LIST
7374: LIST
7375: LIST
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: LIST
7381: PUSH
7382: LD_INT 101
7384: PUSH
7385: LD_INT 102
7387: PUSH
7388: LD_INT 105
7390: PUSH
7391: LD_INT 106
7393: PUSH
7394: LD_INT 108
7396: PUSH
7397: EMPTY
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: ST_TO_ADDR
7408: GO 10187
7410: LD_INT 3
7412: DOUBLE
7413: EQUAL
7414: IFTRUE 7418
7416: GO 7494
7418: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7419: LD_ADDR_VAR 0 1
7423: PUSH
7424: LD_INT 2
7426: PUSH
7427: LD_INT 4
7429: PUSH
7430: LD_INT 5
7432: PUSH
7433: LD_INT 11
7435: PUSH
7436: LD_INT 12
7438: PUSH
7439: LD_INT 15
7441: PUSH
7442: LD_INT 16
7444: PUSH
7445: LD_INT 22
7447: PUSH
7448: LD_INT 26
7450: PUSH
7451: LD_INT 36
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: LD_INT 101
7468: PUSH
7469: LD_INT 102
7471: PUSH
7472: LD_INT 105
7474: PUSH
7475: LD_INT 106
7477: PUSH
7478: LD_INT 108
7480: PUSH
7481: EMPTY
7482: LIST
7483: LIST
7484: LIST
7485: LIST
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: ST_TO_ADDR
7492: GO 10187
7494: LD_INT 4
7496: DOUBLE
7497: EQUAL
7498: IFTRUE 7502
7500: GO 7586
7502: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7503: LD_ADDR_VAR 0 1
7507: PUSH
7508: LD_INT 2
7510: PUSH
7511: LD_INT 4
7513: PUSH
7514: LD_INT 5
7516: PUSH
7517: LD_INT 8
7519: PUSH
7520: LD_INT 11
7522: PUSH
7523: LD_INT 12
7525: PUSH
7526: LD_INT 15
7528: PUSH
7529: LD_INT 16
7531: PUSH
7532: LD_INT 22
7534: PUSH
7535: LD_INT 23
7537: PUSH
7538: LD_INT 26
7540: PUSH
7541: LD_INT 36
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 101
7560: PUSH
7561: LD_INT 102
7563: PUSH
7564: LD_INT 105
7566: PUSH
7567: LD_INT 106
7569: PUSH
7570: LD_INT 108
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: ST_TO_ADDR
7584: GO 10187
7586: LD_INT 5
7588: DOUBLE
7589: EQUAL
7590: IFTRUE 7594
7592: GO 7694
7594: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7595: LD_ADDR_VAR 0 1
7599: PUSH
7600: LD_INT 2
7602: PUSH
7603: LD_INT 4
7605: PUSH
7606: LD_INT 5
7608: PUSH
7609: LD_INT 6
7611: PUSH
7612: LD_INT 8
7614: PUSH
7615: LD_INT 11
7617: PUSH
7618: LD_INT 12
7620: PUSH
7621: LD_INT 15
7623: PUSH
7624: LD_INT 16
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 23
7632: PUSH
7633: LD_INT 25
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 36
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 101
7660: PUSH
7661: LD_INT 102
7663: PUSH
7664: LD_INT 105
7666: PUSH
7667: LD_INT 106
7669: PUSH
7670: LD_INT 108
7672: PUSH
7673: LD_INT 109
7675: PUSH
7676: LD_INT 112
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: ST_TO_ADDR
7692: GO 10187
7694: LD_INT 6
7696: DOUBLE
7697: EQUAL
7698: IFTRUE 7702
7700: GO 7822
7702: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7703: LD_ADDR_VAR 0 1
7707: PUSH
7708: LD_INT 2
7710: PUSH
7711: LD_INT 4
7713: PUSH
7714: LD_INT 5
7716: PUSH
7717: LD_INT 6
7719: PUSH
7720: LD_INT 8
7722: PUSH
7723: LD_INT 11
7725: PUSH
7726: LD_INT 12
7728: PUSH
7729: LD_INT 15
7731: PUSH
7732: LD_INT 16
7734: PUSH
7735: LD_INT 20
7737: PUSH
7738: LD_INT 21
7740: PUSH
7741: LD_INT 22
7743: PUSH
7744: LD_INT 23
7746: PUSH
7747: LD_INT 25
7749: PUSH
7750: LD_INT 26
7752: PUSH
7753: LD_INT 30
7755: PUSH
7756: LD_INT 31
7758: PUSH
7759: LD_INT 32
7761: PUSH
7762: LD_INT 36
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: LIST
7772: LIST
7773: LIST
7774: LIST
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: PUSH
7786: LD_INT 101
7788: PUSH
7789: LD_INT 102
7791: PUSH
7792: LD_INT 105
7794: PUSH
7795: LD_INT 106
7797: PUSH
7798: LD_INT 108
7800: PUSH
7801: LD_INT 109
7803: PUSH
7804: LD_INT 112
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: ST_TO_ADDR
7820: GO 10187
7822: LD_INT 7
7824: DOUBLE
7825: EQUAL
7826: IFTRUE 7830
7828: GO 7930
7830: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7831: LD_ADDR_VAR 0 1
7835: PUSH
7836: LD_INT 2
7838: PUSH
7839: LD_INT 4
7841: PUSH
7842: LD_INT 5
7844: PUSH
7845: LD_INT 7
7847: PUSH
7848: LD_INT 11
7850: PUSH
7851: LD_INT 12
7853: PUSH
7854: LD_INT 15
7856: PUSH
7857: LD_INT 16
7859: PUSH
7860: LD_INT 20
7862: PUSH
7863: LD_INT 21
7865: PUSH
7866: LD_INT 22
7868: PUSH
7869: LD_INT 23
7871: PUSH
7872: LD_INT 25
7874: PUSH
7875: LD_INT 26
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: LIST
7893: PUSH
7894: LD_INT 101
7896: PUSH
7897: LD_INT 102
7899: PUSH
7900: LD_INT 103
7902: PUSH
7903: LD_INT 105
7905: PUSH
7906: LD_INT 106
7908: PUSH
7909: LD_INT 108
7911: PUSH
7912: LD_INT 112
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: LIST
7919: LIST
7920: LIST
7921: LIST
7922: LIST
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: ST_TO_ADDR
7928: GO 10187
7930: LD_INT 8
7932: DOUBLE
7933: EQUAL
7934: IFTRUE 7938
7936: GO 8066
7938: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
7939: LD_ADDR_VAR 0 1
7943: PUSH
7944: LD_INT 2
7946: PUSH
7947: LD_INT 4
7949: PUSH
7950: LD_INT 5
7952: PUSH
7953: LD_INT 6
7955: PUSH
7956: LD_INT 7
7958: PUSH
7959: LD_INT 8
7961: PUSH
7962: LD_INT 11
7964: PUSH
7965: LD_INT 12
7967: PUSH
7968: LD_INT 15
7970: PUSH
7971: LD_INT 16
7973: PUSH
7974: LD_INT 20
7976: PUSH
7977: LD_INT 21
7979: PUSH
7980: LD_INT 22
7982: PUSH
7983: LD_INT 23
7985: PUSH
7986: LD_INT 25
7988: PUSH
7989: LD_INT 26
7991: PUSH
7992: LD_INT 30
7994: PUSH
7995: LD_INT 31
7997: PUSH
7998: LD_INT 32
8000: PUSH
8001: LD_INT 36
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: LIST
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 101
8028: PUSH
8029: LD_INT 102
8031: PUSH
8032: LD_INT 103
8034: PUSH
8035: LD_INT 105
8037: PUSH
8038: LD_INT 106
8040: PUSH
8041: LD_INT 108
8043: PUSH
8044: LD_INT 109
8046: PUSH
8047: LD_INT 112
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: LIST
8054: LIST
8055: LIST
8056: LIST
8057: LIST
8058: LIST
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: ST_TO_ADDR
8064: GO 10187
8066: LD_INT 9
8068: DOUBLE
8069: EQUAL
8070: IFTRUE 8074
8072: GO 8210
8074: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
8075: LD_ADDR_VAR 0 1
8079: PUSH
8080: LD_INT 2
8082: PUSH
8083: LD_INT 4
8085: PUSH
8086: LD_INT 5
8088: PUSH
8089: LD_INT 6
8091: PUSH
8092: LD_INT 7
8094: PUSH
8095: LD_INT 8
8097: PUSH
8098: LD_INT 11
8100: PUSH
8101: LD_INT 12
8103: PUSH
8104: LD_INT 15
8106: PUSH
8107: LD_INT 16
8109: PUSH
8110: LD_INT 20
8112: PUSH
8113: LD_INT 21
8115: PUSH
8116: LD_INT 22
8118: PUSH
8119: LD_INT 23
8121: PUSH
8122: LD_INT 25
8124: PUSH
8125: LD_INT 26
8127: PUSH
8128: LD_INT 28
8130: PUSH
8131: LD_INT 30
8133: PUSH
8134: LD_INT 31
8136: PUSH
8137: LD_INT 32
8139: PUSH
8140: LD_INT 36
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: LIST
8159: LIST
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: PUSH
8166: LD_INT 101
8168: PUSH
8169: LD_INT 102
8171: PUSH
8172: LD_INT 103
8174: PUSH
8175: LD_INT 105
8177: PUSH
8178: LD_INT 106
8180: PUSH
8181: LD_INT 108
8183: PUSH
8184: LD_INT 109
8186: PUSH
8187: LD_INT 112
8189: PUSH
8190: LD_INT 114
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: ST_TO_ADDR
8208: GO 10187
8210: LD_INT 10
8212: DOUBLE
8213: EQUAL
8214: IFTRUE 8218
8216: GO 8402
8218: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
8219: LD_ADDR_VAR 0 1
8223: PUSH
8224: LD_INT 2
8226: PUSH
8227: LD_INT 4
8229: PUSH
8230: LD_INT 5
8232: PUSH
8233: LD_INT 6
8235: PUSH
8236: LD_INT 7
8238: PUSH
8239: LD_INT 8
8241: PUSH
8242: LD_INT 9
8244: PUSH
8245: LD_INT 10
8247: PUSH
8248: LD_INT 11
8250: PUSH
8251: LD_INT 12
8253: PUSH
8254: LD_INT 13
8256: PUSH
8257: LD_INT 14
8259: PUSH
8260: LD_INT 15
8262: PUSH
8263: LD_INT 16
8265: PUSH
8266: LD_INT 17
8268: PUSH
8269: LD_INT 18
8271: PUSH
8272: LD_INT 19
8274: PUSH
8275: LD_INT 20
8277: PUSH
8278: LD_INT 21
8280: PUSH
8281: LD_INT 22
8283: PUSH
8284: LD_INT 23
8286: PUSH
8287: LD_INT 24
8289: PUSH
8290: LD_INT 25
8292: PUSH
8293: LD_INT 26
8295: PUSH
8296: LD_INT 28
8298: PUSH
8299: LD_INT 30
8301: PUSH
8302: LD_INT 31
8304: PUSH
8305: LD_INT 32
8307: PUSH
8308: LD_INT 36
8310: PUSH
8311: EMPTY
8312: LIST
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: LIST
8328: LIST
8329: LIST
8330: LIST
8331: LIST
8332: LIST
8333: LIST
8334: LIST
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: LIST
8340: LIST
8341: PUSH
8342: LD_INT 101
8344: PUSH
8345: LD_INT 102
8347: PUSH
8348: LD_INT 103
8350: PUSH
8351: LD_INT 104
8353: PUSH
8354: LD_INT 105
8356: PUSH
8357: LD_INT 106
8359: PUSH
8360: LD_INT 107
8362: PUSH
8363: LD_INT 108
8365: PUSH
8366: LD_INT 109
8368: PUSH
8369: LD_INT 110
8371: PUSH
8372: LD_INT 111
8374: PUSH
8375: LD_INT 112
8377: PUSH
8378: LD_INT 114
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: LIST
8387: LIST
8388: LIST
8389: LIST
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: ST_TO_ADDR
8400: GO 10187
8402: LD_INT 11
8404: DOUBLE
8405: EQUAL
8406: IFTRUE 8410
8408: GO 8602
8410: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8411: LD_ADDR_VAR 0 1
8415: PUSH
8416: LD_INT 2
8418: PUSH
8419: LD_INT 3
8421: PUSH
8422: LD_INT 4
8424: PUSH
8425: LD_INT 5
8427: PUSH
8428: LD_INT 6
8430: PUSH
8431: LD_INT 7
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: LD_INT 9
8439: PUSH
8440: LD_INT 10
8442: PUSH
8443: LD_INT 11
8445: PUSH
8446: LD_INT 12
8448: PUSH
8449: LD_INT 13
8451: PUSH
8452: LD_INT 14
8454: PUSH
8455: LD_INT 15
8457: PUSH
8458: LD_INT 16
8460: PUSH
8461: LD_INT 17
8463: PUSH
8464: LD_INT 18
8466: PUSH
8467: LD_INT 19
8469: PUSH
8470: LD_INT 20
8472: PUSH
8473: LD_INT 21
8475: PUSH
8476: LD_INT 22
8478: PUSH
8479: LD_INT 23
8481: PUSH
8482: LD_INT 24
8484: PUSH
8485: LD_INT 25
8487: PUSH
8488: LD_INT 26
8490: PUSH
8491: LD_INT 28
8493: PUSH
8494: LD_INT 30
8496: PUSH
8497: LD_INT 31
8499: PUSH
8500: LD_INT 32
8502: PUSH
8503: LD_INT 34
8505: PUSH
8506: LD_INT 36
8508: PUSH
8509: EMPTY
8510: LIST
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: LIST
8518: LIST
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: LIST
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 101
8544: PUSH
8545: LD_INT 102
8547: PUSH
8548: LD_INT 103
8550: PUSH
8551: LD_INT 104
8553: PUSH
8554: LD_INT 105
8556: PUSH
8557: LD_INT 106
8559: PUSH
8560: LD_INT 107
8562: PUSH
8563: LD_INT 108
8565: PUSH
8566: LD_INT 109
8568: PUSH
8569: LD_INT 110
8571: PUSH
8572: LD_INT 111
8574: PUSH
8575: LD_INT 112
8577: PUSH
8578: LD_INT 114
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: LIST
8593: LIST
8594: LIST
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: ST_TO_ADDR
8600: GO 10187
8602: LD_INT 12
8604: DOUBLE
8605: EQUAL
8606: IFTRUE 8610
8608: GO 8818
8610: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8611: LD_ADDR_VAR 0 1
8615: PUSH
8616: LD_INT 1
8618: PUSH
8619: LD_INT 2
8621: PUSH
8622: LD_INT 3
8624: PUSH
8625: LD_INT 4
8627: PUSH
8628: LD_INT 5
8630: PUSH
8631: LD_INT 6
8633: PUSH
8634: LD_INT 7
8636: PUSH
8637: LD_INT 8
8639: PUSH
8640: LD_INT 9
8642: PUSH
8643: LD_INT 10
8645: PUSH
8646: LD_INT 11
8648: PUSH
8649: LD_INT 12
8651: PUSH
8652: LD_INT 13
8654: PUSH
8655: LD_INT 14
8657: PUSH
8658: LD_INT 15
8660: PUSH
8661: LD_INT 16
8663: PUSH
8664: LD_INT 17
8666: PUSH
8667: LD_INT 18
8669: PUSH
8670: LD_INT 19
8672: PUSH
8673: LD_INT 20
8675: PUSH
8676: LD_INT 21
8678: PUSH
8679: LD_INT 22
8681: PUSH
8682: LD_INT 23
8684: PUSH
8685: LD_INT 24
8687: PUSH
8688: LD_INT 25
8690: PUSH
8691: LD_INT 26
8693: PUSH
8694: LD_INT 27
8696: PUSH
8697: LD_INT 28
8699: PUSH
8700: LD_INT 30
8702: PUSH
8703: LD_INT 31
8705: PUSH
8706: LD_INT 32
8708: PUSH
8709: LD_INT 33
8711: PUSH
8712: LD_INT 34
8714: PUSH
8715: LD_INT 36
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: LIST
8722: LIST
8723: LIST
8724: LIST
8725: LIST
8726: LIST
8727: LIST
8728: LIST
8729: LIST
8730: LIST
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_INT 101
8756: PUSH
8757: LD_INT 102
8759: PUSH
8760: LD_INT 103
8762: PUSH
8763: LD_INT 104
8765: PUSH
8766: LD_INT 105
8768: PUSH
8769: LD_INT 106
8771: PUSH
8772: LD_INT 107
8774: PUSH
8775: LD_INT 108
8777: PUSH
8778: LD_INT 109
8780: PUSH
8781: LD_INT 110
8783: PUSH
8784: LD_INT 111
8786: PUSH
8787: LD_INT 112
8789: PUSH
8790: LD_INT 113
8792: PUSH
8793: LD_INT 114
8795: PUSH
8796: EMPTY
8797: LIST
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: ST_TO_ADDR
8816: GO 10187
8818: LD_INT 13
8820: DOUBLE
8821: EQUAL
8822: IFTRUE 8826
8824: GO 9022
8826: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8827: LD_ADDR_VAR 0 1
8831: PUSH
8832: LD_INT 1
8834: PUSH
8835: LD_INT 2
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: LD_INT 4
8843: PUSH
8844: LD_INT 5
8846: PUSH
8847: LD_INT 8
8849: PUSH
8850: LD_INT 9
8852: PUSH
8853: LD_INT 10
8855: PUSH
8856: LD_INT 11
8858: PUSH
8859: LD_INT 12
8861: PUSH
8862: LD_INT 14
8864: PUSH
8865: LD_INT 15
8867: PUSH
8868: LD_INT 16
8870: PUSH
8871: LD_INT 17
8873: PUSH
8874: LD_INT 18
8876: PUSH
8877: LD_INT 19
8879: PUSH
8880: LD_INT 20
8882: PUSH
8883: LD_INT 21
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_INT 23
8891: PUSH
8892: LD_INT 24
8894: PUSH
8895: LD_INT 25
8897: PUSH
8898: LD_INT 26
8900: PUSH
8901: LD_INT 27
8903: PUSH
8904: LD_INT 28
8906: PUSH
8907: LD_INT 30
8909: PUSH
8910: LD_INT 31
8912: PUSH
8913: LD_INT 32
8915: PUSH
8916: LD_INT 33
8918: PUSH
8919: LD_INT 34
8921: PUSH
8922: LD_INT 36
8924: PUSH
8925: EMPTY
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: LIST
8940: LIST
8941: LIST
8942: LIST
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: PUSH
8958: LD_INT 101
8960: PUSH
8961: LD_INT 102
8963: PUSH
8964: LD_INT 103
8966: PUSH
8967: LD_INT 104
8969: PUSH
8970: LD_INT 105
8972: PUSH
8973: LD_INT 106
8975: PUSH
8976: LD_INT 107
8978: PUSH
8979: LD_INT 108
8981: PUSH
8982: LD_INT 109
8984: PUSH
8985: LD_INT 110
8987: PUSH
8988: LD_INT 111
8990: PUSH
8991: LD_INT 112
8993: PUSH
8994: LD_INT 113
8996: PUSH
8997: LD_INT 114
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: ST_TO_ADDR
9020: GO 10187
9022: LD_INT 14
9024: DOUBLE
9025: EQUAL
9026: IFTRUE 9030
9028: GO 9242
9030: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
9031: LD_ADDR_VAR 0 1
9035: PUSH
9036: LD_INT 1
9038: PUSH
9039: LD_INT 2
9041: PUSH
9042: LD_INT 3
9044: PUSH
9045: LD_INT 4
9047: PUSH
9048: LD_INT 5
9050: PUSH
9051: LD_INT 6
9053: PUSH
9054: LD_INT 7
9056: PUSH
9057: LD_INT 8
9059: PUSH
9060: LD_INT 9
9062: PUSH
9063: LD_INT 10
9065: PUSH
9066: LD_INT 11
9068: PUSH
9069: LD_INT 12
9071: PUSH
9072: LD_INT 13
9074: PUSH
9075: LD_INT 14
9077: PUSH
9078: LD_INT 15
9080: PUSH
9081: LD_INT 16
9083: PUSH
9084: LD_INT 17
9086: PUSH
9087: LD_INT 18
9089: PUSH
9090: LD_INT 19
9092: PUSH
9093: LD_INT 20
9095: PUSH
9096: LD_INT 21
9098: PUSH
9099: LD_INT 22
9101: PUSH
9102: LD_INT 23
9104: PUSH
9105: LD_INT 24
9107: PUSH
9108: LD_INT 25
9110: PUSH
9111: LD_INT 26
9113: PUSH
9114: LD_INT 27
9116: PUSH
9117: LD_INT 28
9119: PUSH
9120: LD_INT 29
9122: PUSH
9123: LD_INT 30
9125: PUSH
9126: LD_INT 31
9128: PUSH
9129: LD_INT 32
9131: PUSH
9132: LD_INT 33
9134: PUSH
9135: LD_INT 34
9137: PUSH
9138: LD_INT 36
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: PUSH
9178: LD_INT 101
9180: PUSH
9181: LD_INT 102
9183: PUSH
9184: LD_INT 103
9186: PUSH
9187: LD_INT 104
9189: PUSH
9190: LD_INT 105
9192: PUSH
9193: LD_INT 106
9195: PUSH
9196: LD_INT 107
9198: PUSH
9199: LD_INT 108
9201: PUSH
9202: LD_INT 109
9204: PUSH
9205: LD_INT 110
9207: PUSH
9208: LD_INT 111
9210: PUSH
9211: LD_INT 112
9213: PUSH
9214: LD_INT 113
9216: PUSH
9217: LD_INT 114
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: ST_TO_ADDR
9240: GO 10187
9242: LD_INT 15
9244: DOUBLE
9245: EQUAL
9246: IFTRUE 9250
9248: GO 9462
9250: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
9251: LD_ADDR_VAR 0 1
9255: PUSH
9256: LD_INT 1
9258: PUSH
9259: LD_INT 2
9261: PUSH
9262: LD_INT 3
9264: PUSH
9265: LD_INT 4
9267: PUSH
9268: LD_INT 5
9270: PUSH
9271: LD_INT 6
9273: PUSH
9274: LD_INT 7
9276: PUSH
9277: LD_INT 8
9279: PUSH
9280: LD_INT 9
9282: PUSH
9283: LD_INT 10
9285: PUSH
9286: LD_INT 11
9288: PUSH
9289: LD_INT 12
9291: PUSH
9292: LD_INT 13
9294: PUSH
9295: LD_INT 14
9297: PUSH
9298: LD_INT 15
9300: PUSH
9301: LD_INT 16
9303: PUSH
9304: LD_INT 17
9306: PUSH
9307: LD_INT 18
9309: PUSH
9310: LD_INT 19
9312: PUSH
9313: LD_INT 20
9315: PUSH
9316: LD_INT 21
9318: PUSH
9319: LD_INT 22
9321: PUSH
9322: LD_INT 23
9324: PUSH
9325: LD_INT 24
9327: PUSH
9328: LD_INT 25
9330: PUSH
9331: LD_INT 26
9333: PUSH
9334: LD_INT 27
9336: PUSH
9337: LD_INT 28
9339: PUSH
9340: LD_INT 29
9342: PUSH
9343: LD_INT 30
9345: PUSH
9346: LD_INT 31
9348: PUSH
9349: LD_INT 32
9351: PUSH
9352: LD_INT 33
9354: PUSH
9355: LD_INT 34
9357: PUSH
9358: LD_INT 36
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: LIST
9367: LIST
9368: LIST
9369: LIST
9370: LIST
9371: LIST
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: PUSH
9398: LD_INT 101
9400: PUSH
9401: LD_INT 102
9403: PUSH
9404: LD_INT 103
9406: PUSH
9407: LD_INT 104
9409: PUSH
9410: LD_INT 105
9412: PUSH
9413: LD_INT 106
9415: PUSH
9416: LD_INT 107
9418: PUSH
9419: LD_INT 108
9421: PUSH
9422: LD_INT 109
9424: PUSH
9425: LD_INT 110
9427: PUSH
9428: LD_INT 111
9430: PUSH
9431: LD_INT 112
9433: PUSH
9434: LD_INT 113
9436: PUSH
9437: LD_INT 114
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: ST_TO_ADDR
9460: GO 10187
9462: LD_INT 16
9464: DOUBLE
9465: EQUAL
9466: IFTRUE 9470
9468: GO 9594
9470: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9471: LD_ADDR_VAR 0 1
9475: PUSH
9476: LD_INT 2
9478: PUSH
9479: LD_INT 4
9481: PUSH
9482: LD_INT 5
9484: PUSH
9485: LD_INT 7
9487: PUSH
9488: LD_INT 11
9490: PUSH
9491: LD_INT 12
9493: PUSH
9494: LD_INT 15
9496: PUSH
9497: LD_INT 16
9499: PUSH
9500: LD_INT 20
9502: PUSH
9503: LD_INT 21
9505: PUSH
9506: LD_INT 22
9508: PUSH
9509: LD_INT 23
9511: PUSH
9512: LD_INT 25
9514: PUSH
9515: LD_INT 26
9517: PUSH
9518: LD_INT 30
9520: PUSH
9521: LD_INT 31
9523: PUSH
9524: LD_INT 32
9526: PUSH
9527: LD_INT 33
9529: PUSH
9530: LD_INT 34
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: LIST
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 101
9556: PUSH
9557: LD_INT 102
9559: PUSH
9560: LD_INT 103
9562: PUSH
9563: LD_INT 106
9565: PUSH
9566: LD_INT 108
9568: PUSH
9569: LD_INT 112
9571: PUSH
9572: LD_INT 113
9574: PUSH
9575: LD_INT 114
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: LIST
9586: LIST
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: ST_TO_ADDR
9592: GO 10187
9594: LD_INT 17
9596: DOUBLE
9597: EQUAL
9598: IFTRUE 9602
9600: GO 9814
9602: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9603: LD_ADDR_VAR 0 1
9607: PUSH
9608: LD_INT 1
9610: PUSH
9611: LD_INT 2
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 4
9619: PUSH
9620: LD_INT 5
9622: PUSH
9623: LD_INT 6
9625: PUSH
9626: LD_INT 7
9628: PUSH
9629: LD_INT 8
9631: PUSH
9632: LD_INT 9
9634: PUSH
9635: LD_INT 10
9637: PUSH
9638: LD_INT 11
9640: PUSH
9641: LD_INT 12
9643: PUSH
9644: LD_INT 13
9646: PUSH
9647: LD_INT 14
9649: PUSH
9650: LD_INT 15
9652: PUSH
9653: LD_INT 16
9655: PUSH
9656: LD_INT 17
9658: PUSH
9659: LD_INT 18
9661: PUSH
9662: LD_INT 19
9664: PUSH
9665: LD_INT 20
9667: PUSH
9668: LD_INT 21
9670: PUSH
9671: LD_INT 22
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 24
9679: PUSH
9680: LD_INT 25
9682: PUSH
9683: LD_INT 26
9685: PUSH
9686: LD_INT 27
9688: PUSH
9689: LD_INT 28
9691: PUSH
9692: LD_INT 29
9694: PUSH
9695: LD_INT 30
9697: PUSH
9698: LD_INT 31
9700: PUSH
9701: LD_INT 32
9703: PUSH
9704: LD_INT 33
9706: PUSH
9707: LD_INT 34
9709: PUSH
9710: LD_INT 36
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: LIST
9735: LIST
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_INT 101
9752: PUSH
9753: LD_INT 102
9755: PUSH
9756: LD_INT 103
9758: PUSH
9759: LD_INT 104
9761: PUSH
9762: LD_INT 105
9764: PUSH
9765: LD_INT 106
9767: PUSH
9768: LD_INT 107
9770: PUSH
9771: LD_INT 108
9773: PUSH
9774: LD_INT 109
9776: PUSH
9777: LD_INT 110
9779: PUSH
9780: LD_INT 111
9782: PUSH
9783: LD_INT 112
9785: PUSH
9786: LD_INT 113
9788: PUSH
9789: LD_INT 114
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: PUSH
9808: EMPTY
9809: LIST
9810: LIST
9811: ST_TO_ADDR
9812: GO 10187
9814: LD_INT 18
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9958
9822: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9823: LD_ADDR_VAR 0 1
9827: PUSH
9828: LD_INT 2
9830: PUSH
9831: LD_INT 4
9833: PUSH
9834: LD_INT 5
9836: PUSH
9837: LD_INT 7
9839: PUSH
9840: LD_INT 11
9842: PUSH
9843: LD_INT 12
9845: PUSH
9846: LD_INT 15
9848: PUSH
9849: LD_INT 16
9851: PUSH
9852: LD_INT 20
9854: PUSH
9855: LD_INT 21
9857: PUSH
9858: LD_INT 22
9860: PUSH
9861: LD_INT 23
9863: PUSH
9864: LD_INT 25
9866: PUSH
9867: LD_INT 26
9869: PUSH
9870: LD_INT 30
9872: PUSH
9873: LD_INT 31
9875: PUSH
9876: LD_INT 32
9878: PUSH
9879: LD_INT 33
9881: PUSH
9882: LD_INT 34
9884: PUSH
9885: LD_INT 35
9887: PUSH
9888: LD_INT 36
9890: PUSH
9891: EMPTY
9892: LIST
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 101
9916: PUSH
9917: LD_INT 102
9919: PUSH
9920: LD_INT 103
9922: PUSH
9923: LD_INT 106
9925: PUSH
9926: LD_INT 108
9928: PUSH
9929: LD_INT 112
9931: PUSH
9932: LD_INT 113
9934: PUSH
9935: LD_INT 114
9937: PUSH
9938: LD_INT 115
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: ST_TO_ADDR
9956: GO 10187
9958: LD_INT 19
9960: DOUBLE
9961: EQUAL
9962: IFTRUE 9966
9964: GO 10186
9966: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
9967: LD_ADDR_VAR 0 1
9971: PUSH
9972: LD_INT 1
9974: PUSH
9975: LD_INT 2
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: LD_INT 4
9983: PUSH
9984: LD_INT 5
9986: PUSH
9987: LD_INT 6
9989: PUSH
9990: LD_INT 7
9992: PUSH
9993: LD_INT 8
9995: PUSH
9996: LD_INT 9
9998: PUSH
9999: LD_INT 10
10001: PUSH
10002: LD_INT 11
10004: PUSH
10005: LD_INT 12
10007: PUSH
10008: LD_INT 13
10010: PUSH
10011: LD_INT 14
10013: PUSH
10014: LD_INT 15
10016: PUSH
10017: LD_INT 16
10019: PUSH
10020: LD_INT 17
10022: PUSH
10023: LD_INT 18
10025: PUSH
10026: LD_INT 19
10028: PUSH
10029: LD_INT 20
10031: PUSH
10032: LD_INT 21
10034: PUSH
10035: LD_INT 22
10037: PUSH
10038: LD_INT 23
10040: PUSH
10041: LD_INT 24
10043: PUSH
10044: LD_INT 25
10046: PUSH
10047: LD_INT 26
10049: PUSH
10050: LD_INT 27
10052: PUSH
10053: LD_INT 28
10055: PUSH
10056: LD_INT 29
10058: PUSH
10059: LD_INT 30
10061: PUSH
10062: LD_INT 31
10064: PUSH
10065: LD_INT 32
10067: PUSH
10068: LD_INT 33
10070: PUSH
10071: LD_INT 34
10073: PUSH
10074: LD_INT 35
10076: PUSH
10077: LD_INT 36
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 101
10120: PUSH
10121: LD_INT 102
10123: PUSH
10124: LD_INT 103
10126: PUSH
10127: LD_INT 104
10129: PUSH
10130: LD_INT 105
10132: PUSH
10133: LD_INT 106
10135: PUSH
10136: LD_INT 107
10138: PUSH
10139: LD_INT 108
10141: PUSH
10142: LD_INT 109
10144: PUSH
10145: LD_INT 110
10147: PUSH
10148: LD_INT 111
10150: PUSH
10151: LD_INT 112
10153: PUSH
10154: LD_INT 113
10156: PUSH
10157: LD_INT 114
10159: PUSH
10160: LD_INT 115
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: ST_TO_ADDR
10184: GO 10187
10186: POP
// end ; if result then
10187: LD_VAR 0 1
10191: IFFALSE 10480
// begin normal :=  ;
10193: LD_ADDR_VAR 0 3
10197: PUSH
10198: LD_STRING 
10200: ST_TO_ADDR
// hardcore :=  ;
10201: LD_ADDR_VAR 0 4
10205: PUSH
10206: LD_STRING 
10208: ST_TO_ADDR
// for i = 1 to normalCounter do
10209: LD_ADDR_VAR 0 5
10213: PUSH
10214: DOUBLE
10215: LD_INT 1
10217: DEC
10218: ST_TO_ADDR
10219: LD_EXP 20
10223: PUSH
10224: FOR_TO
10225: IFFALSE 10326
// begin tmp := 0 ;
10227: LD_ADDR_VAR 0 2
10231: PUSH
10232: LD_STRING 0
10234: ST_TO_ADDR
// if result [ 1 ] then
10235: LD_VAR 0 1
10239: PUSH
10240: LD_INT 1
10242: ARRAY
10243: IFFALSE 10308
// if result [ 1 ] [ 1 ] = i then
10245: LD_VAR 0 1
10249: PUSH
10250: LD_INT 1
10252: ARRAY
10253: PUSH
10254: LD_INT 1
10256: ARRAY
10257: PUSH
10258: LD_VAR 0 5
10262: EQUAL
10263: IFFALSE 10308
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
10265: LD_ADDR_VAR 0 1
10269: PUSH
10270: LD_VAR 0 1
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_VAR 0 1
10282: PUSH
10283: LD_INT 1
10285: ARRAY
10286: PPUSH
10287: LD_INT 1
10289: PPUSH
10290: CALL_OW 3
10294: PPUSH
10295: CALL_OW 1
10299: ST_TO_ADDR
// tmp := 1 ;
10300: LD_ADDR_VAR 0 2
10304: PUSH
10305: LD_STRING 1
10307: ST_TO_ADDR
// end ; normal := normal & tmp ;
10308: LD_ADDR_VAR 0 3
10312: PUSH
10313: LD_VAR 0 3
10317: PUSH
10318: LD_VAR 0 2
10322: STR
10323: ST_TO_ADDR
// end ;
10324: GO 10224
10326: POP
10327: POP
// for i = 1 to hardcoreCounter do
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: DOUBLE
10334: LD_INT 1
10336: DEC
10337: ST_TO_ADDR
10338: LD_EXP 21
10342: PUSH
10343: FOR_TO
10344: IFFALSE 10449
// begin tmp := 0 ;
10346: LD_ADDR_VAR 0 2
10350: PUSH
10351: LD_STRING 0
10353: ST_TO_ADDR
// if result [ 2 ] then
10354: LD_VAR 0 1
10358: PUSH
10359: LD_INT 2
10361: ARRAY
10362: IFFALSE 10431
// if result [ 2 ] [ 1 ] = 100 + i then
10364: LD_VAR 0 1
10368: PUSH
10369: LD_INT 2
10371: ARRAY
10372: PUSH
10373: LD_INT 1
10375: ARRAY
10376: PUSH
10377: LD_INT 100
10379: PUSH
10380: LD_VAR 0 5
10384: PLUS
10385: EQUAL
10386: IFFALSE 10431
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10388: LD_ADDR_VAR 0 1
10392: PUSH
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 2
10400: PPUSH
10401: LD_VAR 0 1
10405: PUSH
10406: LD_INT 2
10408: ARRAY
10409: PPUSH
10410: LD_INT 1
10412: PPUSH
10413: CALL_OW 3
10417: PPUSH
10418: CALL_OW 1
10422: ST_TO_ADDR
// tmp := 1 ;
10423: LD_ADDR_VAR 0 2
10427: PUSH
10428: LD_STRING 1
10430: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10431: LD_ADDR_VAR 0 4
10435: PUSH
10436: LD_VAR 0 4
10440: PUSH
10441: LD_VAR 0 2
10445: STR
10446: ST_TO_ADDR
// end ;
10447: GO 10343
10449: POP
10450: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10451: LD_STRING getStreamItemsFromMission("
10453: PUSH
10454: LD_VAR 0 3
10458: STR
10459: PUSH
10460: LD_STRING ","
10462: STR
10463: PUSH
10464: LD_VAR 0 4
10468: STR
10469: PUSH
10470: LD_STRING ")
10472: STR
10473: PPUSH
10474: CALL_OW 559
// end else
10478: GO 10487
// ToLua ( getStreamItemsFromMission("","") ) ;
10480: LD_STRING getStreamItemsFromMission("","")
10482: PPUSH
10483: CALL_OW 559
// end ;
10487: LD_VAR 0 1
10491: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10492: LD_VAR 0 2
10496: PUSH
10497: LD_INT 100
10499: EQUAL
10500: IFFALSE 11449
// begin if not StreamModeActive then
10502: LD_EXP 19
10506: NOT
10507: IFFALSE 10517
// StreamModeActive := true ;
10509: LD_ADDR_EXP 19
10513: PUSH
10514: LD_INT 1
10516: ST_TO_ADDR
// if p3 = 0 then
10517: LD_VAR 0 3
10521: PUSH
10522: LD_INT 0
10524: EQUAL
10525: IFFALSE 10531
// InitStreamMode ;
10527: CALL 6789 0 0
// if p3 = 1 then
10531: LD_VAR 0 3
10535: PUSH
10536: LD_INT 1
10538: EQUAL
10539: IFFALSE 10549
// sRocket := true ;
10541: LD_ADDR_EXP 24
10545: PUSH
10546: LD_INT 1
10548: ST_TO_ADDR
// if p3 = 2 then
10549: LD_VAR 0 3
10553: PUSH
10554: LD_INT 2
10556: EQUAL
10557: IFFALSE 10567
// sSpeed := true ;
10559: LD_ADDR_EXP 23
10563: PUSH
10564: LD_INT 1
10566: ST_TO_ADDR
// if p3 = 3 then
10567: LD_VAR 0 3
10571: PUSH
10572: LD_INT 3
10574: EQUAL
10575: IFFALSE 10585
// sEngine := true ;
10577: LD_ADDR_EXP 25
10581: PUSH
10582: LD_INT 1
10584: ST_TO_ADDR
// if p3 = 4 then
10585: LD_VAR 0 3
10589: PUSH
10590: LD_INT 4
10592: EQUAL
10593: IFFALSE 10603
// sSpec := true ;
10595: LD_ADDR_EXP 22
10599: PUSH
10600: LD_INT 1
10602: ST_TO_ADDR
// if p3 = 5 then
10603: LD_VAR 0 3
10607: PUSH
10608: LD_INT 5
10610: EQUAL
10611: IFFALSE 10621
// sLevel := true ;
10613: LD_ADDR_EXP 26
10617: PUSH
10618: LD_INT 1
10620: ST_TO_ADDR
// if p3 = 6 then
10621: LD_VAR 0 3
10625: PUSH
10626: LD_INT 6
10628: EQUAL
10629: IFFALSE 10639
// sArmoury := true ;
10631: LD_ADDR_EXP 27
10635: PUSH
10636: LD_INT 1
10638: ST_TO_ADDR
// if p3 = 7 then
10639: LD_VAR 0 3
10643: PUSH
10644: LD_INT 7
10646: EQUAL
10647: IFFALSE 10657
// sRadar := true ;
10649: LD_ADDR_EXP 28
10653: PUSH
10654: LD_INT 1
10656: ST_TO_ADDR
// if p3 = 8 then
10657: LD_VAR 0 3
10661: PUSH
10662: LD_INT 8
10664: EQUAL
10665: IFFALSE 10675
// sBunker := true ;
10667: LD_ADDR_EXP 29
10671: PUSH
10672: LD_INT 1
10674: ST_TO_ADDR
// if p3 = 9 then
10675: LD_VAR 0 3
10679: PUSH
10680: LD_INT 9
10682: EQUAL
10683: IFFALSE 10693
// sHack := true ;
10685: LD_ADDR_EXP 30
10689: PUSH
10690: LD_INT 1
10692: ST_TO_ADDR
// if p3 = 10 then
10693: LD_VAR 0 3
10697: PUSH
10698: LD_INT 10
10700: EQUAL
10701: IFFALSE 10711
// sFire := true ;
10703: LD_ADDR_EXP 31
10707: PUSH
10708: LD_INT 1
10710: ST_TO_ADDR
// if p3 = 11 then
10711: LD_VAR 0 3
10715: PUSH
10716: LD_INT 11
10718: EQUAL
10719: IFFALSE 10729
// sRefresh := true ;
10721: LD_ADDR_EXP 32
10725: PUSH
10726: LD_INT 1
10728: ST_TO_ADDR
// if p3 = 12 then
10729: LD_VAR 0 3
10733: PUSH
10734: LD_INT 12
10736: EQUAL
10737: IFFALSE 10747
// sExp := true ;
10739: LD_ADDR_EXP 33
10743: PUSH
10744: LD_INT 1
10746: ST_TO_ADDR
// if p3 = 13 then
10747: LD_VAR 0 3
10751: PUSH
10752: LD_INT 13
10754: EQUAL
10755: IFFALSE 10765
// sDepot := true ;
10757: LD_ADDR_EXP 34
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// if p3 = 14 then
10765: LD_VAR 0 3
10769: PUSH
10770: LD_INT 14
10772: EQUAL
10773: IFFALSE 10783
// sFlag := true ;
10775: LD_ADDR_EXP 35
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// if p3 = 15 then
10783: LD_VAR 0 3
10787: PUSH
10788: LD_INT 15
10790: EQUAL
10791: IFFALSE 10801
// sKamikadze := true ;
10793: LD_ADDR_EXP 43
10797: PUSH
10798: LD_INT 1
10800: ST_TO_ADDR
// if p3 = 16 then
10801: LD_VAR 0 3
10805: PUSH
10806: LD_INT 16
10808: EQUAL
10809: IFFALSE 10819
// sTroll := true ;
10811: LD_ADDR_EXP 44
10815: PUSH
10816: LD_INT 1
10818: ST_TO_ADDR
// if p3 = 17 then
10819: LD_VAR 0 3
10823: PUSH
10824: LD_INT 17
10826: EQUAL
10827: IFFALSE 10837
// sSlow := true ;
10829: LD_ADDR_EXP 45
10833: PUSH
10834: LD_INT 1
10836: ST_TO_ADDR
// if p3 = 18 then
10837: LD_VAR 0 3
10841: PUSH
10842: LD_INT 18
10844: EQUAL
10845: IFFALSE 10855
// sLack := true ;
10847: LD_ADDR_EXP 46
10851: PUSH
10852: LD_INT 1
10854: ST_TO_ADDR
// if p3 = 19 then
10855: LD_VAR 0 3
10859: PUSH
10860: LD_INT 19
10862: EQUAL
10863: IFFALSE 10873
// sTank := true ;
10865: LD_ADDR_EXP 48
10869: PUSH
10870: LD_INT 1
10872: ST_TO_ADDR
// if p3 = 20 then
10873: LD_VAR 0 3
10877: PUSH
10878: LD_INT 20
10880: EQUAL
10881: IFFALSE 10891
// sRemote := true ;
10883: LD_ADDR_EXP 49
10887: PUSH
10888: LD_INT 1
10890: ST_TO_ADDR
// if p3 = 21 then
10891: LD_VAR 0 3
10895: PUSH
10896: LD_INT 21
10898: EQUAL
10899: IFFALSE 10909
// sPowell := true ;
10901: LD_ADDR_EXP 50
10905: PUSH
10906: LD_INT 1
10908: ST_TO_ADDR
// if p3 = 22 then
10909: LD_VAR 0 3
10913: PUSH
10914: LD_INT 22
10916: EQUAL
10917: IFFALSE 10927
// sTeleport := true ;
10919: LD_ADDR_EXP 53
10923: PUSH
10924: LD_INT 1
10926: ST_TO_ADDR
// if p3 = 23 then
10927: LD_VAR 0 3
10931: PUSH
10932: LD_INT 23
10934: EQUAL
10935: IFFALSE 10945
// sOilTower := true ;
10937: LD_ADDR_EXP 55
10941: PUSH
10942: LD_INT 1
10944: ST_TO_ADDR
// if p3 = 24 then
10945: LD_VAR 0 3
10949: PUSH
10950: LD_INT 24
10952: EQUAL
10953: IFFALSE 10963
// sShovel := true ;
10955: LD_ADDR_EXP 56
10959: PUSH
10960: LD_INT 1
10962: ST_TO_ADDR
// if p3 = 25 then
10963: LD_VAR 0 3
10967: PUSH
10968: LD_INT 25
10970: EQUAL
10971: IFFALSE 10981
// sSheik := true ;
10973: LD_ADDR_EXP 57
10977: PUSH
10978: LD_INT 1
10980: ST_TO_ADDR
// if p3 = 26 then
10981: LD_VAR 0 3
10985: PUSH
10986: LD_INT 26
10988: EQUAL
10989: IFFALSE 10999
// sEarthquake := true ;
10991: LD_ADDR_EXP 59
10995: PUSH
10996: LD_INT 1
10998: ST_TO_ADDR
// if p3 = 27 then
10999: LD_VAR 0 3
11003: PUSH
11004: LD_INT 27
11006: EQUAL
11007: IFFALSE 11017
// sAI := true ;
11009: LD_ADDR_EXP 60
11013: PUSH
11014: LD_INT 1
11016: ST_TO_ADDR
// if p3 = 28 then
11017: LD_VAR 0 3
11021: PUSH
11022: LD_INT 28
11024: EQUAL
11025: IFFALSE 11035
// sCargo := true ;
11027: LD_ADDR_EXP 63
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// if p3 = 29 then
11035: LD_VAR 0 3
11039: PUSH
11040: LD_INT 29
11042: EQUAL
11043: IFFALSE 11053
// sDLaser := true ;
11045: LD_ADDR_EXP 64
11049: PUSH
11050: LD_INT 1
11052: ST_TO_ADDR
// if p3 = 30 then
11053: LD_VAR 0 3
11057: PUSH
11058: LD_INT 30
11060: EQUAL
11061: IFFALSE 11071
// sExchange := true ;
11063: LD_ADDR_EXP 65
11067: PUSH
11068: LD_INT 1
11070: ST_TO_ADDR
// if p3 = 31 then
11071: LD_VAR 0 3
11075: PUSH
11076: LD_INT 31
11078: EQUAL
11079: IFFALSE 11089
// sFac := true ;
11081: LD_ADDR_EXP 66
11085: PUSH
11086: LD_INT 1
11088: ST_TO_ADDR
// if p3 = 32 then
11089: LD_VAR 0 3
11093: PUSH
11094: LD_INT 32
11096: EQUAL
11097: IFFALSE 11107
// sPower := true ;
11099: LD_ADDR_EXP 67
11103: PUSH
11104: LD_INT 1
11106: ST_TO_ADDR
// if p3 = 33 then
11107: LD_VAR 0 3
11111: PUSH
11112: LD_INT 33
11114: EQUAL
11115: IFFALSE 11125
// sRandom := true ;
11117: LD_ADDR_EXP 68
11121: PUSH
11122: LD_INT 1
11124: ST_TO_ADDR
// if p3 = 34 then
11125: LD_VAR 0 3
11129: PUSH
11130: LD_INT 34
11132: EQUAL
11133: IFFALSE 11143
// sShield := true ;
11135: LD_ADDR_EXP 69
11139: PUSH
11140: LD_INT 1
11142: ST_TO_ADDR
// if p3 = 35 then
11143: LD_VAR 0 3
11147: PUSH
11148: LD_INT 35
11150: EQUAL
11151: IFFALSE 11161
// sTime := true ;
11153: LD_ADDR_EXP 70
11157: PUSH
11158: LD_INT 1
11160: ST_TO_ADDR
// if p3 = 36 then
11161: LD_VAR 0 3
11165: PUSH
11166: LD_INT 36
11168: EQUAL
11169: IFFALSE 11179
// sTools := true ;
11171: LD_ADDR_EXP 71
11175: PUSH
11176: LD_INT 1
11178: ST_TO_ADDR
// if p3 = 101 then
11179: LD_VAR 0 3
11183: PUSH
11184: LD_INT 101
11186: EQUAL
11187: IFFALSE 11197
// sSold := true ;
11189: LD_ADDR_EXP 36
11193: PUSH
11194: LD_INT 1
11196: ST_TO_ADDR
// if p3 = 102 then
11197: LD_VAR 0 3
11201: PUSH
11202: LD_INT 102
11204: EQUAL
11205: IFFALSE 11215
// sDiff := true ;
11207: LD_ADDR_EXP 37
11211: PUSH
11212: LD_INT 1
11214: ST_TO_ADDR
// if p3 = 103 then
11215: LD_VAR 0 3
11219: PUSH
11220: LD_INT 103
11222: EQUAL
11223: IFFALSE 11233
// sFog := true ;
11225: LD_ADDR_EXP 40
11229: PUSH
11230: LD_INT 1
11232: ST_TO_ADDR
// if p3 = 104 then
11233: LD_VAR 0 3
11237: PUSH
11238: LD_INT 104
11240: EQUAL
11241: IFFALSE 11251
// sReset := true ;
11243: LD_ADDR_EXP 41
11247: PUSH
11248: LD_INT 1
11250: ST_TO_ADDR
// if p3 = 105 then
11251: LD_VAR 0 3
11255: PUSH
11256: LD_INT 105
11258: EQUAL
11259: IFFALSE 11269
// sSun := true ;
11261: LD_ADDR_EXP 42
11265: PUSH
11266: LD_INT 1
11268: ST_TO_ADDR
// if p3 = 106 then
11269: LD_VAR 0 3
11273: PUSH
11274: LD_INT 106
11276: EQUAL
11277: IFFALSE 11287
// sTiger := true ;
11279: LD_ADDR_EXP 38
11283: PUSH
11284: LD_INT 1
11286: ST_TO_ADDR
// if p3 = 107 then
11287: LD_VAR 0 3
11291: PUSH
11292: LD_INT 107
11294: EQUAL
11295: IFFALSE 11305
// sBomb := true ;
11297: LD_ADDR_EXP 39
11301: PUSH
11302: LD_INT 1
11304: ST_TO_ADDR
// if p3 = 108 then
11305: LD_VAR 0 3
11309: PUSH
11310: LD_INT 108
11312: EQUAL
11313: IFFALSE 11323
// sWound := true ;
11315: LD_ADDR_EXP 47
11319: PUSH
11320: LD_INT 1
11322: ST_TO_ADDR
// if p3 = 109 then
11323: LD_VAR 0 3
11327: PUSH
11328: LD_INT 109
11330: EQUAL
11331: IFFALSE 11341
// sBetray := true ;
11333: LD_ADDR_EXP 51
11337: PUSH
11338: LD_INT 1
11340: ST_TO_ADDR
// if p3 = 110 then
11341: LD_VAR 0 3
11345: PUSH
11346: LD_INT 110
11348: EQUAL
11349: IFFALSE 11359
// sContamin := true ;
11351: LD_ADDR_EXP 52
11355: PUSH
11356: LD_INT 1
11358: ST_TO_ADDR
// if p3 = 111 then
11359: LD_VAR 0 3
11363: PUSH
11364: LD_INT 111
11366: EQUAL
11367: IFFALSE 11377
// sOil := true ;
11369: LD_ADDR_EXP 54
11373: PUSH
11374: LD_INT 1
11376: ST_TO_ADDR
// if p3 = 112 then
11377: LD_VAR 0 3
11381: PUSH
11382: LD_INT 112
11384: EQUAL
11385: IFFALSE 11395
// sStu := true ;
11387: LD_ADDR_EXP 58
11391: PUSH
11392: LD_INT 1
11394: ST_TO_ADDR
// if p3 = 113 then
11395: LD_VAR 0 3
11399: PUSH
11400: LD_INT 113
11402: EQUAL
11403: IFFALSE 11413
// sBazooka := true ;
11405: LD_ADDR_EXP 61
11409: PUSH
11410: LD_INT 1
11412: ST_TO_ADDR
// if p3 = 114 then
11413: LD_VAR 0 3
11417: PUSH
11418: LD_INT 114
11420: EQUAL
11421: IFFALSE 11431
// sMortar := true ;
11423: LD_ADDR_EXP 62
11427: PUSH
11428: LD_INT 1
11430: ST_TO_ADDR
// if p3 = 115 then
11431: LD_VAR 0 3
11435: PUSH
11436: LD_INT 115
11438: EQUAL
11439: IFFALSE 11449
// sRanger := true ;
11441: LD_ADDR_EXP 72
11445: PUSH
11446: LD_INT 1
11448: ST_TO_ADDR
// end ; end ;
11449: PPOPN 6
11451: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11452: LD_EXP 19
11456: PUSH
11457: LD_EXP 24
11461: AND
11462: IFFALSE 11586
11464: GO 11466
11466: DISABLE
11467: LD_INT 0
11469: PPUSH
11470: PPUSH
// begin enable ;
11471: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11472: LD_ADDR_VAR 0 2
11476: PUSH
11477: LD_INT 22
11479: PUSH
11480: LD_OWVAR 2
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: LD_INT 2
11491: PUSH
11492: LD_INT 34
11494: PUSH
11495: LD_INT 7
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PUSH
11502: LD_INT 34
11504: PUSH
11505: LD_INT 45
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 34
11514: PUSH
11515: LD_INT 28
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: LD_INT 34
11524: PUSH
11525: LD_INT 47
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: PUSH
11539: EMPTY
11540: LIST
11541: LIST
11542: PPUSH
11543: CALL_OW 69
11547: ST_TO_ADDR
// if not tmp then
11548: LD_VAR 0 2
11552: NOT
11553: IFFALSE 11557
// exit ;
11555: GO 11586
// for i in tmp do
11557: LD_ADDR_VAR 0 1
11561: PUSH
11562: LD_VAR 0 2
11566: PUSH
11567: FOR_IN
11568: IFFALSE 11584
// begin SetLives ( i , 0 ) ;
11570: LD_VAR 0 1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 234
// end ;
11582: GO 11567
11584: POP
11585: POP
// end ;
11586: PPOPN 2
11588: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11589: LD_EXP 19
11593: PUSH
11594: LD_EXP 25
11598: AND
11599: IFFALSE 11683
11601: GO 11603
11603: DISABLE
11604: LD_INT 0
11606: PPUSH
11607: PPUSH
// begin enable ;
11608: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11609: LD_ADDR_VAR 0 2
11613: PUSH
11614: LD_INT 22
11616: PUSH
11617: LD_OWVAR 2
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 32
11628: PUSH
11629: LD_INT 3
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PPUSH
11640: CALL_OW 69
11644: ST_TO_ADDR
// if not tmp then
11645: LD_VAR 0 2
11649: NOT
11650: IFFALSE 11654
// exit ;
11652: GO 11683
// for i in tmp do
11654: LD_ADDR_VAR 0 1
11658: PUSH
11659: LD_VAR 0 2
11663: PUSH
11664: FOR_IN
11665: IFFALSE 11681
// begin SetLives ( i , 0 ) ;
11667: LD_VAR 0 1
11671: PPUSH
11672: LD_INT 0
11674: PPUSH
11675: CALL_OW 234
// end ;
11679: GO 11664
11681: POP
11682: POP
// end ;
11683: PPOPN 2
11685: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11686: LD_EXP 19
11690: PUSH
11691: LD_EXP 22
11695: AND
11696: IFFALSE 11789
11698: GO 11700
11700: DISABLE
11701: LD_INT 0
11703: PPUSH
// begin enable ;
11704: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11705: LD_ADDR_VAR 0 1
11709: PUSH
11710: LD_INT 22
11712: PUSH
11713: LD_OWVAR 2
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PUSH
11722: LD_INT 2
11724: PUSH
11725: LD_INT 25
11727: PUSH
11728: LD_INT 5
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: PUSH
11735: LD_INT 25
11737: PUSH
11738: LD_INT 9
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 8
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PPUSH
11765: CALL_OW 69
11769: PUSH
11770: FOR_IN
11771: IFFALSE 11787
// begin SetClass ( i , 1 ) ;
11773: LD_VAR 0 1
11777: PPUSH
11778: LD_INT 1
11780: PPUSH
11781: CALL_OW 336
// end ;
11785: GO 11770
11787: POP
11788: POP
// end ;
11789: PPOPN 1
11791: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
11792: LD_EXP 19
11796: PUSH
11797: LD_EXP 23
11801: AND
11802: PUSH
11803: LD_OWVAR 65
11807: PUSH
11808: LD_INT 7
11810: LESS
11811: AND
11812: IFFALSE 11826
11814: GO 11816
11816: DISABLE
// begin enable ;
11817: ENABLE
// game_speed := 7 ;
11818: LD_ADDR_OWVAR 65
11822: PUSH
11823: LD_INT 7
11825: ST_TO_ADDR
// end ;
11826: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
11827: LD_EXP 19
11831: PUSH
11832: LD_EXP 26
11836: AND
11837: IFFALSE 12039
11839: GO 11841
11841: DISABLE
11842: LD_INT 0
11844: PPUSH
11845: PPUSH
11846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
11847: LD_ADDR_VAR 0 3
11851: PUSH
11852: LD_INT 81
11854: PUSH
11855: LD_OWVAR 2
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 21
11866: PUSH
11867: LD_INT 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// if not tmp then
11883: LD_VAR 0 3
11887: NOT
11888: IFFALSE 11892
// exit ;
11890: GO 12039
// if tmp > 5 then
11892: LD_VAR 0 3
11896: PUSH
11897: LD_INT 5
11899: GREATER
11900: IFFALSE 11912
// k := 5 else
11902: LD_ADDR_VAR 0 2
11906: PUSH
11907: LD_INT 5
11909: ST_TO_ADDR
11910: GO 11922
// k := tmp ;
11912: LD_ADDR_VAR 0 2
11916: PUSH
11917: LD_VAR 0 3
11921: ST_TO_ADDR
// for i := 1 to k do
11922: LD_ADDR_VAR 0 1
11926: PUSH
11927: DOUBLE
11928: LD_INT 1
11930: DEC
11931: ST_TO_ADDR
11932: LD_VAR 0 2
11936: PUSH
11937: FOR_TO
11938: IFFALSE 12037
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
11940: LD_VAR 0 3
11944: PUSH
11945: LD_VAR 0 1
11949: ARRAY
11950: PPUSH
11951: LD_VAR 0 1
11955: PUSH
11956: LD_INT 4
11958: MOD
11959: PUSH
11960: LD_INT 1
11962: PLUS
11963: PPUSH
11964: CALL_OW 259
11968: PUSH
11969: LD_INT 10
11971: LESS
11972: IFFALSE 12035
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
11974: LD_VAR 0 3
11978: PUSH
11979: LD_VAR 0 1
11983: ARRAY
11984: PPUSH
11985: LD_VAR 0 1
11989: PUSH
11990: LD_INT 4
11992: MOD
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: PPUSH
11998: LD_VAR 0 3
12002: PUSH
12003: LD_VAR 0 1
12007: ARRAY
12008: PPUSH
12009: LD_VAR 0 1
12013: PUSH
12014: LD_INT 4
12016: MOD
12017: PUSH
12018: LD_INT 1
12020: PLUS
12021: PPUSH
12022: CALL_OW 259
12026: PUSH
12027: LD_INT 1
12029: PLUS
12030: PPUSH
12031: CALL_OW 237
12035: GO 11937
12037: POP
12038: POP
// end ;
12039: PPOPN 3
12041: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12042: LD_EXP 19
12046: PUSH
12047: LD_EXP 27
12051: AND
12052: IFFALSE 12072
12054: GO 12056
12056: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12057: LD_INT 4
12059: PPUSH
12060: LD_OWVAR 2
12064: PPUSH
12065: LD_INT 0
12067: PPUSH
12068: CALL_OW 324
12072: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12073: LD_EXP 19
12077: PUSH
12078: LD_EXP 56
12082: AND
12083: IFFALSE 12103
12085: GO 12087
12087: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12088: LD_INT 19
12090: PPUSH
12091: LD_OWVAR 2
12095: PPUSH
12096: LD_INT 0
12098: PPUSH
12099: CALL_OW 324
12103: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12104: LD_EXP 19
12108: PUSH
12109: LD_EXP 28
12113: AND
12114: IFFALSE 12216
12116: GO 12118
12118: DISABLE
12119: LD_INT 0
12121: PPUSH
12122: PPUSH
// begin enable ;
12123: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_INT 22
12131: PUSH
12132: LD_OWVAR 2
12136: PUSH
12137: EMPTY
12138: LIST
12139: LIST
12140: PUSH
12141: LD_INT 2
12143: PUSH
12144: LD_INT 34
12146: PUSH
12147: LD_INT 11
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: LD_INT 34
12156: PUSH
12157: LD_INT 30
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: PUSH
12169: EMPTY
12170: LIST
12171: LIST
12172: PPUSH
12173: CALL_OW 69
12177: ST_TO_ADDR
// if not tmp then
12178: LD_VAR 0 2
12182: NOT
12183: IFFALSE 12187
// exit ;
12185: GO 12216
// for i in tmp do
12187: LD_ADDR_VAR 0 1
12191: PUSH
12192: LD_VAR 0 2
12196: PUSH
12197: FOR_IN
12198: IFFALSE 12214
// begin SetLives ( i , 0 ) ;
12200: LD_VAR 0 1
12204: PPUSH
12205: LD_INT 0
12207: PPUSH
12208: CALL_OW 234
// end ;
12212: GO 12197
12214: POP
12215: POP
// end ;
12216: PPOPN 2
12218: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12219: LD_EXP 19
12223: PUSH
12224: LD_EXP 29
12228: AND
12229: IFFALSE 12249
12231: GO 12233
12233: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12234: LD_INT 32
12236: PPUSH
12237: LD_OWVAR 2
12241: PPUSH
12242: LD_INT 0
12244: PPUSH
12245: CALL_OW 324
12249: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12250: LD_EXP 19
12254: PUSH
12255: LD_EXP 30
12259: AND
12260: IFFALSE 12441
12262: GO 12264
12264: DISABLE
12265: LD_INT 0
12267: PPUSH
12268: PPUSH
12269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12270: LD_ADDR_VAR 0 2
12274: PUSH
12275: LD_INT 22
12277: PUSH
12278: LD_OWVAR 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: LD_INT 33
12289: PUSH
12290: LD_INT 3
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PPUSH
12301: CALL_OW 69
12305: ST_TO_ADDR
// if not tmp then
12306: LD_VAR 0 2
12310: NOT
12311: IFFALSE 12315
// exit ;
12313: GO 12441
// side := 0 ;
12315: LD_ADDR_VAR 0 3
12319: PUSH
12320: LD_INT 0
12322: ST_TO_ADDR
// for i := 1 to 8 do
12323: LD_ADDR_VAR 0 1
12327: PUSH
12328: DOUBLE
12329: LD_INT 1
12331: DEC
12332: ST_TO_ADDR
12333: LD_INT 8
12335: PUSH
12336: FOR_TO
12337: IFFALSE 12385
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12339: LD_OWVAR 2
12343: PUSH
12344: LD_VAR 0 1
12348: NONEQUAL
12349: PUSH
12350: LD_OWVAR 2
12354: PPUSH
12355: LD_VAR 0 1
12359: PPUSH
12360: CALL_OW 81
12364: PUSH
12365: LD_INT 2
12367: EQUAL
12368: AND
12369: IFFALSE 12383
// begin side := i ;
12371: LD_ADDR_VAR 0 3
12375: PUSH
12376: LD_VAR 0 1
12380: ST_TO_ADDR
// break ;
12381: GO 12385
// end ;
12383: GO 12336
12385: POP
12386: POP
// if not side then
12387: LD_VAR 0 3
12391: NOT
12392: IFFALSE 12396
// exit ;
12394: GO 12441
// for i := 1 to tmp do
12396: LD_ADDR_VAR 0 1
12400: PUSH
12401: DOUBLE
12402: LD_INT 1
12404: DEC
12405: ST_TO_ADDR
12406: LD_VAR 0 2
12410: PUSH
12411: FOR_TO
12412: IFFALSE 12439
// if Prob ( 60 ) then
12414: LD_INT 60
12416: PPUSH
12417: CALL_OW 13
12421: IFFALSE 12437
// SetSide ( i , side ) ;
12423: LD_VAR 0 1
12427: PPUSH
12428: LD_VAR 0 3
12432: PPUSH
12433: CALL_OW 235
12437: GO 12411
12439: POP
12440: POP
// end ;
12441: PPOPN 3
12443: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12444: LD_EXP 19
12448: PUSH
12449: LD_EXP 32
12453: AND
12454: IFFALSE 12573
12456: GO 12458
12458: DISABLE
12459: LD_INT 0
12461: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12462: LD_ADDR_VAR 0 1
12466: PUSH
12467: LD_INT 22
12469: PUSH
12470: LD_OWVAR 2
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: PUSH
12479: LD_INT 21
12481: PUSH
12482: LD_INT 1
12484: PUSH
12485: EMPTY
12486: LIST
12487: LIST
12488: PUSH
12489: LD_INT 3
12491: PUSH
12492: LD_INT 23
12494: PUSH
12495: LD_INT 0
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: LIST
12510: PPUSH
12511: CALL_OW 69
12515: PUSH
12516: FOR_IN
12517: IFFALSE 12571
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12519: LD_VAR 0 1
12523: PPUSH
12524: CALL_OW 257
12528: PUSH
12529: LD_INT 1
12531: PUSH
12532: LD_INT 2
12534: PUSH
12535: LD_INT 3
12537: PUSH
12538: LD_INT 4
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: IN
12547: IFFALSE 12569
// SetClass ( un , rand ( 1 , 4 ) ) ;
12549: LD_VAR 0 1
12553: PPUSH
12554: LD_INT 1
12556: PPUSH
12557: LD_INT 4
12559: PPUSH
12560: CALL_OW 12
12564: PPUSH
12565: CALL_OW 336
12569: GO 12516
12571: POP
12572: POP
// end ;
12573: PPOPN 1
12575: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12576: LD_EXP 19
12580: PUSH
12581: LD_EXP 31
12585: AND
12586: IFFALSE 12665
12588: GO 12590
12590: DISABLE
12591: LD_INT 0
12593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12594: LD_ADDR_VAR 0 1
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_OWVAR 2
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 21
12613: PUSH
12614: LD_INT 3
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PPUSH
12625: CALL_OW 69
12629: ST_TO_ADDR
// if not tmp then
12630: LD_VAR 0 1
12634: NOT
12635: IFFALSE 12639
// exit ;
12637: GO 12665
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12639: LD_VAR 0 1
12643: PUSH
12644: LD_INT 1
12646: PPUSH
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 12
12656: ARRAY
12657: PPUSH
12658: LD_INT 100
12660: PPUSH
12661: CALL_OW 234
// end ;
12665: PPOPN 1
12667: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12668: LD_EXP 19
12672: PUSH
12673: LD_EXP 33
12677: AND
12678: IFFALSE 12776
12680: GO 12682
12682: DISABLE
12683: LD_INT 0
12685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12686: LD_ADDR_VAR 0 1
12690: PUSH
12691: LD_INT 22
12693: PUSH
12694: LD_OWVAR 2
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: PUSH
12703: LD_INT 21
12705: PUSH
12706: LD_INT 1
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: PPUSH
12717: CALL_OW 69
12721: ST_TO_ADDR
// if not tmp then
12722: LD_VAR 0 1
12726: NOT
12727: IFFALSE 12731
// exit ;
12729: GO 12776
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12731: LD_VAR 0 1
12735: PUSH
12736: LD_INT 1
12738: PPUSH
12739: LD_VAR 0 1
12743: PPUSH
12744: CALL_OW 12
12748: ARRAY
12749: PPUSH
12750: LD_INT 1
12752: PPUSH
12753: LD_INT 4
12755: PPUSH
12756: CALL_OW 12
12760: PPUSH
12761: LD_INT 3000
12763: PPUSH
12764: LD_INT 9000
12766: PPUSH
12767: CALL_OW 12
12771: PPUSH
12772: CALL_OW 492
// end ;
12776: PPOPN 1
12778: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12779: LD_EXP 19
12783: PUSH
12784: LD_EXP 34
12788: AND
12789: IFFALSE 12809
12791: GO 12793
12793: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12794: LD_INT 1
12796: PPUSH
12797: LD_OWVAR 2
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 324
12809: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12810: LD_EXP 19
12814: PUSH
12815: LD_EXP 35
12819: AND
12820: IFFALSE 12903
12822: GO 12824
12824: DISABLE
12825: LD_INT 0
12827: PPUSH
12828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12829: LD_ADDR_VAR 0 2
12833: PUSH
12834: LD_INT 22
12836: PUSH
12837: LD_OWVAR 2
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 3
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PPUSH
12860: CALL_OW 69
12864: ST_TO_ADDR
// if not tmp then
12865: LD_VAR 0 2
12869: NOT
12870: IFFALSE 12874
// exit ;
12872: GO 12903
// for i in tmp do
12874: LD_ADDR_VAR 0 1
12878: PUSH
12879: LD_VAR 0 2
12883: PUSH
12884: FOR_IN
12885: IFFALSE 12901
// SetBLevel ( i , 10 ) ;
12887: LD_VAR 0 1
12891: PPUSH
12892: LD_INT 10
12894: PPUSH
12895: CALL_OW 241
12899: GO 12884
12901: POP
12902: POP
// end ;
12903: PPOPN 2
12905: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
12906: LD_EXP 19
12910: PUSH
12911: LD_EXP 36
12915: AND
12916: IFFALSE 13027
12918: GO 12920
12920: DISABLE
12921: LD_INT 0
12923: PPUSH
12924: PPUSH
12925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12926: LD_ADDR_VAR 0 3
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_OWVAR 2
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 1
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PPUSH
12957: CALL_OW 69
12961: ST_TO_ADDR
// if not tmp then
12962: LD_VAR 0 3
12966: NOT
12967: IFFALSE 12971
// exit ;
12969: GO 13027
// un := tmp [ rand ( 1 , tmp ) ] ;
12971: LD_ADDR_VAR 0 2
12975: PUSH
12976: LD_VAR 0 3
12980: PUSH
12981: LD_INT 1
12983: PPUSH
12984: LD_VAR 0 3
12988: PPUSH
12989: CALL_OW 12
12993: ARRAY
12994: ST_TO_ADDR
// if Crawls ( un ) then
12995: LD_VAR 0 2
12999: PPUSH
13000: CALL_OW 318
13004: IFFALSE 13015
// ComWalk ( un ) ;
13006: LD_VAR 0 2
13010: PPUSH
13011: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13015: LD_VAR 0 2
13019: PPUSH
13020: LD_INT 5
13022: PPUSH
13023: CALL_OW 336
// end ;
13027: PPOPN 3
13029: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13030: LD_EXP 19
13034: PUSH
13035: LD_EXP 37
13039: AND
13040: PUSH
13041: LD_OWVAR 67
13045: PUSH
13046: LD_INT 3
13048: LESS
13049: AND
13050: IFFALSE 13069
13052: GO 13054
13054: DISABLE
// Difficulty := Difficulty + 1 ;
13055: LD_ADDR_OWVAR 67
13059: PUSH
13060: LD_OWVAR 67
13064: PUSH
13065: LD_INT 1
13067: PLUS
13068: ST_TO_ADDR
13069: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13070: LD_EXP 19
13074: PUSH
13075: LD_EXP 38
13079: AND
13080: IFFALSE 13183
13082: GO 13084
13084: DISABLE
13085: LD_INT 0
13087: PPUSH
// begin for i := 1 to 5 do
13088: LD_ADDR_VAR 0 1
13092: PUSH
13093: DOUBLE
13094: LD_INT 1
13096: DEC
13097: ST_TO_ADDR
13098: LD_INT 5
13100: PUSH
13101: FOR_TO
13102: IFFALSE 13181
// begin uc_nation := nation_nature ;
13104: LD_ADDR_OWVAR 21
13108: PUSH
13109: LD_INT 0
13111: ST_TO_ADDR
// uc_side := 0 ;
13112: LD_ADDR_OWVAR 20
13116: PUSH
13117: LD_INT 0
13119: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13120: LD_ADDR_OWVAR 29
13124: PUSH
13125: LD_INT 12
13127: PUSH
13128: LD_INT 12
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: ST_TO_ADDR
// hc_agressivity := 20 ;
13135: LD_ADDR_OWVAR 35
13139: PUSH
13140: LD_INT 20
13142: ST_TO_ADDR
// hc_class := class_tiger ;
13143: LD_ADDR_OWVAR 28
13147: PUSH
13148: LD_INT 14
13150: ST_TO_ADDR
// hc_gallery :=  ;
13151: LD_ADDR_OWVAR 33
13155: PUSH
13156: LD_STRING 
13158: ST_TO_ADDR
// hc_name :=  ;
13159: LD_ADDR_OWVAR 26
13163: PUSH
13164: LD_STRING 
13166: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13167: CALL_OW 44
13171: PPUSH
13172: LD_INT 0
13174: PPUSH
13175: CALL_OW 51
// end ;
13179: GO 13101
13181: POP
13182: POP
// end ;
13183: PPOPN 1
13185: END
// every 0 0$1 trigger StreamModeActive and sBomb do
13186: LD_EXP 19
13190: PUSH
13191: LD_EXP 39
13195: AND
13196: IFFALSE 13205
13198: GO 13200
13200: DISABLE
// StreamSibBomb ;
13201: CALL 13206 0 0
13205: END
// export function StreamSibBomb ; var i , x , y ; begin
13206: LD_INT 0
13208: PPUSH
13209: PPUSH
13210: PPUSH
13211: PPUSH
// result := false ;
13212: LD_ADDR_VAR 0 1
13216: PUSH
13217: LD_INT 0
13219: ST_TO_ADDR
// for i := 1 to 16 do
13220: LD_ADDR_VAR 0 2
13224: PUSH
13225: DOUBLE
13226: LD_INT 1
13228: DEC
13229: ST_TO_ADDR
13230: LD_INT 16
13232: PUSH
13233: FOR_TO
13234: IFFALSE 13433
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13236: LD_ADDR_VAR 0 3
13240: PUSH
13241: LD_INT 10
13243: PUSH
13244: LD_INT 20
13246: PUSH
13247: LD_INT 30
13249: PUSH
13250: LD_INT 40
13252: PUSH
13253: LD_INT 50
13255: PUSH
13256: LD_INT 60
13258: PUSH
13259: LD_INT 70
13261: PUSH
13262: LD_INT 80
13264: PUSH
13265: LD_INT 90
13267: PUSH
13268: LD_INT 100
13270: PUSH
13271: LD_INT 110
13273: PUSH
13274: LD_INT 120
13276: PUSH
13277: LD_INT 130
13279: PUSH
13280: LD_INT 140
13282: PUSH
13283: LD_INT 150
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: LIST
13302: PUSH
13303: LD_INT 1
13305: PPUSH
13306: LD_INT 15
13308: PPUSH
13309: CALL_OW 12
13313: ARRAY
13314: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13315: LD_ADDR_VAR 0 4
13319: PUSH
13320: LD_INT 10
13322: PUSH
13323: LD_INT 20
13325: PUSH
13326: LD_INT 30
13328: PUSH
13329: LD_INT 40
13331: PUSH
13332: LD_INT 50
13334: PUSH
13335: LD_INT 60
13337: PUSH
13338: LD_INT 70
13340: PUSH
13341: LD_INT 80
13343: PUSH
13344: LD_INT 90
13346: PUSH
13347: LD_INT 100
13349: PUSH
13350: LD_INT 110
13352: PUSH
13353: LD_INT 120
13355: PUSH
13356: LD_INT 130
13358: PUSH
13359: LD_INT 140
13361: PUSH
13362: LD_INT 150
13364: PUSH
13365: EMPTY
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: PUSH
13382: LD_INT 1
13384: PPUSH
13385: LD_INT 15
13387: PPUSH
13388: CALL_OW 12
13392: ARRAY
13393: ST_TO_ADDR
// if ValidHex ( x , y ) then
13394: LD_VAR 0 3
13398: PPUSH
13399: LD_VAR 0 4
13403: PPUSH
13404: CALL_OW 488
13408: IFFALSE 13431
// begin result := [ x , y ] ;
13410: LD_ADDR_VAR 0 1
13414: PUSH
13415: LD_VAR 0 3
13419: PUSH
13420: LD_VAR 0 4
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: ST_TO_ADDR
// break ;
13429: GO 13433
// end ; end ;
13431: GO 13233
13433: POP
13434: POP
// if result then
13435: LD_VAR 0 1
13439: IFFALSE 13499
// begin ToLua ( playSibBomb() ) ;
13441: LD_STRING playSibBomb()
13443: PPUSH
13444: CALL_OW 559
// wait ( 0 0$14 ) ;
13448: LD_INT 490
13450: PPUSH
13451: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13455: LD_VAR 0 1
13459: PUSH
13460: LD_INT 1
13462: ARRAY
13463: PPUSH
13464: LD_VAR 0 1
13468: PUSH
13469: LD_INT 2
13471: ARRAY
13472: PPUSH
13473: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13477: LD_VAR 0 1
13481: PUSH
13482: LD_INT 1
13484: ARRAY
13485: PPUSH
13486: LD_VAR 0 1
13490: PUSH
13491: LD_INT 2
13493: ARRAY
13494: PPUSH
13495: CALL_OW 429
// end ; end ;
13499: LD_VAR 0 1
13503: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13504: LD_EXP 19
13508: PUSH
13509: LD_EXP 41
13513: AND
13514: IFFALSE 13526
13516: GO 13518
13518: DISABLE
// YouLost (  ) ;
13519: LD_STRING 
13521: PPUSH
13522: CALL_OW 104
13526: END
// every 0 0$1 trigger StreamModeActive and sFog do
13527: LD_EXP 19
13531: PUSH
13532: LD_EXP 40
13536: AND
13537: IFFALSE 13551
13539: GO 13541
13541: DISABLE
// FogOff ( your_side ) ;
13542: LD_OWVAR 2
13546: PPUSH
13547: CALL_OW 344
13551: END
// every 0 0$1 trigger StreamModeActive and sSun do
13552: LD_EXP 19
13556: PUSH
13557: LD_EXP 42
13561: AND
13562: IFFALSE 13590
13564: GO 13566
13566: DISABLE
// begin solar_recharge_percent := 0 ;
13567: LD_ADDR_OWVAR 79
13571: PUSH
13572: LD_INT 0
13574: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13575: LD_INT 10500
13577: PPUSH
13578: CALL_OW 67
// solar_recharge_percent := 100 ;
13582: LD_ADDR_OWVAR 79
13586: PUSH
13587: LD_INT 100
13589: ST_TO_ADDR
// end ;
13590: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13591: LD_EXP 19
13595: PUSH
13596: LD_EXP 43
13600: AND
13601: IFFALSE 13840
13603: GO 13605
13605: DISABLE
13606: LD_INT 0
13608: PPUSH
13609: PPUSH
13610: PPUSH
// begin tmp := [ ] ;
13611: LD_ADDR_VAR 0 3
13615: PUSH
13616: EMPTY
13617: ST_TO_ADDR
// for i := 1 to 6 do
13618: LD_ADDR_VAR 0 1
13622: PUSH
13623: DOUBLE
13624: LD_INT 1
13626: DEC
13627: ST_TO_ADDR
13628: LD_INT 6
13630: PUSH
13631: FOR_TO
13632: IFFALSE 13737
// begin uc_nation := nation_nature ;
13634: LD_ADDR_OWVAR 21
13638: PUSH
13639: LD_INT 0
13641: ST_TO_ADDR
// uc_side := 0 ;
13642: LD_ADDR_OWVAR 20
13646: PUSH
13647: LD_INT 0
13649: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13650: LD_ADDR_OWVAR 29
13654: PUSH
13655: LD_INT 12
13657: PUSH
13658: LD_INT 12
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: ST_TO_ADDR
// hc_agressivity := 20 ;
13665: LD_ADDR_OWVAR 35
13669: PUSH
13670: LD_INT 20
13672: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13673: LD_ADDR_OWVAR 28
13677: PUSH
13678: LD_INT 17
13680: ST_TO_ADDR
// hc_gallery :=  ;
13681: LD_ADDR_OWVAR 33
13685: PUSH
13686: LD_STRING 
13688: ST_TO_ADDR
// hc_name :=  ;
13689: LD_ADDR_OWVAR 26
13693: PUSH
13694: LD_STRING 
13696: ST_TO_ADDR
// un := CreateHuman ;
13697: LD_ADDR_VAR 0 2
13701: PUSH
13702: CALL_OW 44
13706: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13707: LD_VAR 0 2
13711: PPUSH
13712: LD_INT 1
13714: PPUSH
13715: CALL_OW 51
// tmp := tmp ^ un ;
13719: LD_ADDR_VAR 0 3
13723: PUSH
13724: LD_VAR 0 3
13728: PUSH
13729: LD_VAR 0 2
13733: ADD
13734: ST_TO_ADDR
// end ;
13735: GO 13631
13737: POP
13738: POP
// repeat wait ( 0 0$1 ) ;
13739: LD_INT 35
13741: PPUSH
13742: CALL_OW 67
// for un in tmp do
13746: LD_ADDR_VAR 0 2
13750: PUSH
13751: LD_VAR 0 3
13755: PUSH
13756: FOR_IN
13757: IFFALSE 13831
// begin if IsDead ( un ) then
13759: LD_VAR 0 2
13763: PPUSH
13764: CALL_OW 301
13768: IFFALSE 13788
// begin tmp := tmp diff un ;
13770: LD_ADDR_VAR 0 3
13774: PUSH
13775: LD_VAR 0 3
13779: PUSH
13780: LD_VAR 0 2
13784: DIFF
13785: ST_TO_ADDR
// continue ;
13786: GO 13756
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13788: LD_VAR 0 2
13792: PPUSH
13793: LD_INT 3
13795: PUSH
13796: LD_INT 22
13798: PUSH
13799: LD_INT 0
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PPUSH
13810: CALL_OW 69
13814: PPUSH
13815: LD_VAR 0 2
13819: PPUSH
13820: CALL_OW 74
13824: PPUSH
13825: CALL_OW 115
// end ;
13829: GO 13756
13831: POP
13832: POP
// until not tmp ;
13833: LD_VAR 0 3
13837: NOT
13838: IFFALSE 13739
// end ;
13840: PPOPN 3
13842: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13843: LD_EXP 19
13847: PUSH
13848: LD_EXP 44
13852: AND
13853: IFFALSE 13907
13855: GO 13857
13857: DISABLE
// begin ToLua ( displayTroll(); ) ;
13858: LD_STRING displayTroll();
13860: PPUSH
13861: CALL_OW 559
// wait ( 3 3$00 ) ;
13865: LD_INT 6300
13867: PPUSH
13868: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13872: LD_STRING hideTroll();
13874: PPUSH
13875: CALL_OW 559
// wait ( 1 1$00 ) ;
13879: LD_INT 2100
13881: PPUSH
13882: CALL_OW 67
// ToLua ( displayTroll(); ) ;
13886: LD_STRING displayTroll();
13888: PPUSH
13889: CALL_OW 559
// wait ( 1 1$00 ) ;
13893: LD_INT 2100
13895: PPUSH
13896: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13900: LD_STRING hideTroll();
13902: PPUSH
13903: CALL_OW 559
// end ;
13907: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13908: LD_EXP 19
13912: PUSH
13913: LD_EXP 45
13917: AND
13918: IFFALSE 13981
13920: GO 13922
13922: DISABLE
13923: LD_INT 0
13925: PPUSH
// begin p := 0 ;
13926: LD_ADDR_VAR 0 1
13930: PUSH
13931: LD_INT 0
13933: ST_TO_ADDR
// repeat game_speed := 1 ;
13934: LD_ADDR_OWVAR 65
13938: PUSH
13939: LD_INT 1
13941: ST_TO_ADDR
// wait ( 0 0$1 ) ;
13942: LD_INT 35
13944: PPUSH
13945: CALL_OW 67
// p := p + 1 ;
13949: LD_ADDR_VAR 0 1
13953: PUSH
13954: LD_VAR 0 1
13958: PUSH
13959: LD_INT 1
13961: PLUS
13962: ST_TO_ADDR
// until p >= 60 ;
13963: LD_VAR 0 1
13967: PUSH
13968: LD_INT 60
13970: GREATEREQUAL
13971: IFFALSE 13934
// game_speed := 4 ;
13973: LD_ADDR_OWVAR 65
13977: PUSH
13978: LD_INT 4
13980: ST_TO_ADDR
// end ;
13981: PPOPN 1
13983: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
13984: LD_EXP 19
13988: PUSH
13989: LD_EXP 46
13993: AND
13994: IFFALSE 14140
13996: GO 13998
13998: DISABLE
13999: LD_INT 0
14001: PPUSH
14002: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14003: LD_ADDR_VAR 0 1
14007: PUSH
14008: LD_INT 22
14010: PUSH
14011: LD_OWVAR 2
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: LD_INT 2
14022: PUSH
14023: LD_INT 30
14025: PUSH
14026: LD_INT 0
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 30
14035: PUSH
14036: LD_INT 1
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: LIST
14047: PUSH
14048: EMPTY
14049: LIST
14050: LIST
14051: PPUSH
14052: CALL_OW 69
14056: ST_TO_ADDR
// if not depot then
14057: LD_VAR 0 1
14061: NOT
14062: IFFALSE 14066
// exit ;
14064: GO 14140
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14066: LD_ADDR_VAR 0 2
14070: PUSH
14071: LD_VAR 0 1
14075: PUSH
14076: LD_INT 1
14078: PPUSH
14079: LD_VAR 0 1
14083: PPUSH
14084: CALL_OW 12
14088: ARRAY
14089: PPUSH
14090: CALL_OW 274
14094: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14095: LD_VAR 0 2
14099: PPUSH
14100: LD_INT 1
14102: PPUSH
14103: LD_INT 0
14105: PPUSH
14106: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14110: LD_VAR 0 2
14114: PPUSH
14115: LD_INT 2
14117: PPUSH
14118: LD_INT 0
14120: PPUSH
14121: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14125: LD_VAR 0 2
14129: PPUSH
14130: LD_INT 3
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 277
// end ;
14140: PPOPN 2
14142: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14143: LD_EXP 19
14147: PUSH
14148: LD_EXP 47
14152: AND
14153: IFFALSE 14250
14155: GO 14157
14157: DISABLE
14158: LD_INT 0
14160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14161: LD_ADDR_VAR 0 1
14165: PUSH
14166: LD_INT 22
14168: PUSH
14169: LD_OWVAR 2
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: PUSH
14178: LD_INT 21
14180: PUSH
14181: LD_INT 1
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_INT 3
14190: PUSH
14191: LD_INT 23
14193: PUSH
14194: LD_INT 0
14196: PUSH
14197: EMPTY
14198: LIST
14199: LIST
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PUSH
14205: EMPTY
14206: LIST
14207: LIST
14208: LIST
14209: PPUSH
14210: CALL_OW 69
14214: ST_TO_ADDR
// if not tmp then
14215: LD_VAR 0 1
14219: NOT
14220: IFFALSE 14224
// exit ;
14222: GO 14250
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14224: LD_VAR 0 1
14228: PUSH
14229: LD_INT 1
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: CALL_OW 12
14241: ARRAY
14242: PPUSH
14243: LD_INT 200
14245: PPUSH
14246: CALL_OW 234
// end ;
14250: PPOPN 1
14252: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14253: LD_EXP 19
14257: PUSH
14258: LD_EXP 48
14262: AND
14263: IFFALSE 14342
14265: GO 14267
14267: DISABLE
14268: LD_INT 0
14270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14271: LD_ADDR_VAR 0 1
14275: PUSH
14276: LD_INT 22
14278: PUSH
14279: LD_OWVAR 2
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: PUSH
14288: LD_INT 21
14290: PUSH
14291: LD_INT 2
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PPUSH
14302: CALL_OW 69
14306: ST_TO_ADDR
// if not tmp then
14307: LD_VAR 0 1
14311: NOT
14312: IFFALSE 14316
// exit ;
14314: GO 14342
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14316: LD_VAR 0 1
14320: PUSH
14321: LD_INT 1
14323: PPUSH
14324: LD_VAR 0 1
14328: PPUSH
14329: CALL_OW 12
14333: ARRAY
14334: PPUSH
14335: LD_INT 60
14337: PPUSH
14338: CALL_OW 234
// end ;
14342: PPOPN 1
14344: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14345: LD_EXP 19
14349: PUSH
14350: LD_EXP 49
14354: AND
14355: IFFALSE 14454
14357: GO 14359
14359: DISABLE
14360: LD_INT 0
14362: PPUSH
14363: PPUSH
// begin enable ;
14364: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14365: LD_ADDR_VAR 0 1
14369: PUSH
14370: LD_INT 22
14372: PUSH
14373: LD_OWVAR 2
14377: PUSH
14378: EMPTY
14379: LIST
14380: LIST
14381: PUSH
14382: LD_INT 61
14384: PUSH
14385: EMPTY
14386: LIST
14387: PUSH
14388: LD_INT 33
14390: PUSH
14391: LD_INT 2
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: PPUSH
14403: CALL_OW 69
14407: ST_TO_ADDR
// if not tmp then
14408: LD_VAR 0 1
14412: NOT
14413: IFFALSE 14417
// exit ;
14415: GO 14454
// for i in tmp do
14417: LD_ADDR_VAR 0 2
14421: PUSH
14422: LD_VAR 0 1
14426: PUSH
14427: FOR_IN
14428: IFFALSE 14452
// if IsControledBy ( i ) then
14430: LD_VAR 0 2
14434: PPUSH
14435: CALL_OW 312
14439: IFFALSE 14450
// ComUnlink ( i ) ;
14441: LD_VAR 0 2
14445: PPUSH
14446: CALL_OW 136
14450: GO 14427
14452: POP
14453: POP
// end ;
14454: PPOPN 2
14456: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14457: LD_EXP 19
14461: PUSH
14462: LD_EXP 50
14466: AND
14467: IFFALSE 14607
14469: GO 14471
14471: DISABLE
14472: LD_INT 0
14474: PPUSH
14475: PPUSH
// begin ToLua ( displayPowell(); ) ;
14476: LD_STRING displayPowell();
14478: PPUSH
14479: CALL_OW 559
// uc_side := 0 ;
14483: LD_ADDR_OWVAR 20
14487: PUSH
14488: LD_INT 0
14490: ST_TO_ADDR
// uc_nation := 2 ;
14491: LD_ADDR_OWVAR 21
14495: PUSH
14496: LD_INT 2
14498: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14499: LD_ADDR_OWVAR 37
14503: PUSH
14504: LD_INT 14
14506: ST_TO_ADDR
// vc_engine := engine_siberite ;
14507: LD_ADDR_OWVAR 39
14511: PUSH
14512: LD_INT 3
14514: ST_TO_ADDR
// vc_control := control_apeman ;
14515: LD_ADDR_OWVAR 38
14519: PUSH
14520: LD_INT 5
14522: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14523: LD_ADDR_OWVAR 40
14527: PUSH
14528: LD_INT 29
14530: ST_TO_ADDR
// un := CreateVehicle ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: CALL_OW 45
14540: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14541: LD_VAR 0 2
14545: PPUSH
14546: LD_INT 1
14548: PPUSH
14549: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14553: LD_INT 35
14555: PPUSH
14556: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
14560: LD_VAR 0 2
14564: PPUSH
14565: LD_INT 22
14567: PUSH
14568: LD_OWVAR 2
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PPUSH
14577: CALL_OW 69
14581: PPUSH
14582: LD_VAR 0 2
14586: PPUSH
14587: CALL_OW 74
14591: PPUSH
14592: CALL_OW 115
// until IsDead ( un ) ;
14596: LD_VAR 0 2
14600: PPUSH
14601: CALL_OW 301
14605: IFFALSE 14553
// end ;
14607: PPOPN 2
14609: END
// every 0 0$1 trigger StreamModeActive and sStu do
14610: LD_EXP 19
14614: PUSH
14615: LD_EXP 58
14619: AND
14620: IFFALSE 14636
14622: GO 14624
14624: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14625: LD_STRING displayStucuk();
14627: PPUSH
14628: CALL_OW 559
// ResetFog ;
14632: CALL_OW 335
// end ;
14636: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14637: LD_EXP 19
14641: PUSH
14642: LD_EXP 51
14646: AND
14647: IFFALSE 14788
14649: GO 14651
14651: DISABLE
14652: LD_INT 0
14654: PPUSH
14655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14656: LD_ADDR_VAR 0 2
14660: PUSH
14661: LD_INT 22
14663: PUSH
14664: LD_OWVAR 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 21
14675: PUSH
14676: LD_INT 1
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: ST_TO_ADDR
// if not tmp then
14692: LD_VAR 0 2
14696: NOT
14697: IFFALSE 14701
// exit ;
14699: GO 14788
// un := tmp [ rand ( 1 , tmp ) ] ;
14701: LD_ADDR_VAR 0 1
14705: PUSH
14706: LD_VAR 0 2
14710: PUSH
14711: LD_INT 1
14713: PPUSH
14714: LD_VAR 0 2
14718: PPUSH
14719: CALL_OW 12
14723: ARRAY
14724: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14725: LD_VAR 0 1
14729: PPUSH
14730: LD_INT 0
14732: PPUSH
14733: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14737: LD_VAR 0 1
14741: PPUSH
14742: LD_OWVAR 3
14746: PUSH
14747: LD_VAR 0 1
14751: DIFF
14752: PPUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 74
14762: PPUSH
14763: CALL_OW 115
// wait ( 0 0$20 ) ;
14767: LD_INT 700
14769: PPUSH
14770: CALL_OW 67
// SetSide ( un , your_side ) ;
14774: LD_VAR 0 1
14778: PPUSH
14779: LD_OWVAR 2
14783: PPUSH
14784: CALL_OW 235
// end ;
14788: PPOPN 2
14790: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14791: LD_EXP 19
14795: PUSH
14796: LD_EXP 52
14800: AND
14801: IFFALSE 14907
14803: GO 14805
14805: DISABLE
14806: LD_INT 0
14808: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14809: LD_ADDR_VAR 0 1
14813: PUSH
14814: LD_INT 22
14816: PUSH
14817: LD_OWVAR 2
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: PUSH
14826: LD_INT 2
14828: PUSH
14829: LD_INT 30
14831: PUSH
14832: LD_INT 0
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PUSH
14839: LD_INT 30
14841: PUSH
14842: LD_INT 1
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: LIST
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PPUSH
14858: CALL_OW 69
14862: ST_TO_ADDR
// if not depot then
14863: LD_VAR 0 1
14867: NOT
14868: IFFALSE 14872
// exit ;
14870: GO 14907
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
14872: LD_VAR 0 1
14876: PUSH
14877: LD_INT 1
14879: ARRAY
14880: PPUSH
14881: CALL_OW 250
14885: PPUSH
14886: LD_VAR 0 1
14890: PUSH
14891: LD_INT 1
14893: ARRAY
14894: PPUSH
14895: CALL_OW 251
14899: PPUSH
14900: LD_INT 70
14902: PPUSH
14903: CALL_OW 495
// end ;
14907: PPOPN 1
14909: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
14910: LD_EXP 19
14914: PUSH
14915: LD_EXP 53
14919: AND
14920: IFFALSE 15131
14922: GO 14924
14924: DISABLE
14925: LD_INT 0
14927: PPUSH
14928: PPUSH
14929: PPUSH
14930: PPUSH
14931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14932: LD_ADDR_VAR 0 5
14936: PUSH
14937: LD_INT 22
14939: PUSH
14940: LD_OWVAR 2
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PUSH
14949: LD_INT 21
14951: PUSH
14952: LD_INT 1
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PPUSH
14963: CALL_OW 69
14967: ST_TO_ADDR
// if not tmp then
14968: LD_VAR 0 5
14972: NOT
14973: IFFALSE 14977
// exit ;
14975: GO 15131
// for i in tmp do
14977: LD_ADDR_VAR 0 1
14981: PUSH
14982: LD_VAR 0 5
14986: PUSH
14987: FOR_IN
14988: IFFALSE 15129
// begin d := rand ( 0 , 5 ) ;
14990: LD_ADDR_VAR 0 4
14994: PUSH
14995: LD_INT 0
14997: PPUSH
14998: LD_INT 5
15000: PPUSH
15001: CALL_OW 12
15005: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15006: LD_ADDR_VAR 0 2
15010: PUSH
15011: LD_VAR 0 1
15015: PPUSH
15016: CALL_OW 250
15020: PPUSH
15021: LD_VAR 0 4
15025: PPUSH
15026: LD_INT 3
15028: PPUSH
15029: LD_INT 12
15031: PPUSH
15032: CALL_OW 12
15036: PPUSH
15037: CALL_OW 272
15041: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_VAR 0 1
15051: PPUSH
15052: CALL_OW 251
15056: PPUSH
15057: LD_VAR 0 4
15061: PPUSH
15062: LD_INT 3
15064: PPUSH
15065: LD_INT 12
15067: PPUSH
15068: CALL_OW 12
15072: PPUSH
15073: CALL_OW 273
15077: ST_TO_ADDR
// if ValidHex ( x , y ) then
15078: LD_VAR 0 2
15082: PPUSH
15083: LD_VAR 0 3
15087: PPUSH
15088: CALL_OW 488
15092: IFFALSE 15127
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15094: LD_VAR 0 1
15098: PPUSH
15099: LD_VAR 0 2
15103: PPUSH
15104: LD_VAR 0 3
15108: PPUSH
15109: LD_INT 3
15111: PPUSH
15112: LD_INT 6
15114: PPUSH
15115: CALL_OW 12
15119: PPUSH
15120: LD_INT 1
15122: PPUSH
15123: CALL_OW 483
// end ;
15127: GO 14987
15129: POP
15130: POP
// end ;
15131: PPOPN 5
15133: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15134: LD_EXP 19
15138: PUSH
15139: LD_EXP 54
15143: AND
15144: IFFALSE 15238
15146: GO 15148
15148: DISABLE
15149: LD_INT 0
15151: PPUSH
15152: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15153: LD_ADDR_VAR 0 2
15157: PUSH
15158: LD_INT 22
15160: PUSH
15161: LD_OWVAR 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 32
15172: PUSH
15173: LD_INT 1
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: LD_INT 21
15182: PUSH
15183: LD_INT 2
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: LIST
15194: PPUSH
15195: CALL_OW 69
15199: ST_TO_ADDR
// if not tmp then
15200: LD_VAR 0 2
15204: NOT
15205: IFFALSE 15209
// exit ;
15207: GO 15238
// for i in tmp do
15209: LD_ADDR_VAR 0 1
15213: PUSH
15214: LD_VAR 0 2
15218: PUSH
15219: FOR_IN
15220: IFFALSE 15236
// SetFuel ( i , 0 ) ;
15222: LD_VAR 0 1
15226: PPUSH
15227: LD_INT 0
15229: PPUSH
15230: CALL_OW 240
15234: GO 15219
15236: POP
15237: POP
// end ;
15238: PPOPN 2
15240: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15241: LD_EXP 19
15245: PUSH
15246: LD_EXP 55
15250: AND
15251: IFFALSE 15317
15253: GO 15255
15255: DISABLE
15256: LD_INT 0
15258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15259: LD_ADDR_VAR 0 1
15263: PUSH
15264: LD_INT 22
15266: PUSH
15267: LD_OWVAR 2
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: PUSH
15276: LD_INT 30
15278: PUSH
15279: LD_INT 29
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PPUSH
15290: CALL_OW 69
15294: ST_TO_ADDR
// if not tmp then
15295: LD_VAR 0 1
15299: NOT
15300: IFFALSE 15304
// exit ;
15302: GO 15317
// DestroyUnit ( tmp [ 1 ] ) ;
15304: LD_VAR 0 1
15308: PUSH
15309: LD_INT 1
15311: ARRAY
15312: PPUSH
15313: CALL_OW 65
// end ;
15317: PPOPN 1
15319: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15320: LD_EXP 19
15324: PUSH
15325: LD_EXP 57
15329: AND
15330: IFFALSE 15459
15332: GO 15334
15334: DISABLE
15335: LD_INT 0
15337: PPUSH
// begin uc_side := 0 ;
15338: LD_ADDR_OWVAR 20
15342: PUSH
15343: LD_INT 0
15345: ST_TO_ADDR
// uc_nation := nation_arabian ;
15346: LD_ADDR_OWVAR 21
15350: PUSH
15351: LD_INT 2
15353: ST_TO_ADDR
// hc_gallery :=  ;
15354: LD_ADDR_OWVAR 33
15358: PUSH
15359: LD_STRING 
15361: ST_TO_ADDR
// hc_name :=  ;
15362: LD_ADDR_OWVAR 26
15366: PUSH
15367: LD_STRING 
15369: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15370: LD_INT 1
15372: PPUSH
15373: LD_INT 11
15375: PPUSH
15376: LD_INT 10
15378: PPUSH
15379: CALL_OW 380
// un := CreateHuman ;
15383: LD_ADDR_VAR 0 1
15387: PUSH
15388: CALL_OW 44
15392: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15393: LD_VAR 0 1
15397: PPUSH
15398: LD_INT 1
15400: PPUSH
15401: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15405: LD_INT 35
15407: PPUSH
15408: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15412: LD_VAR 0 1
15416: PPUSH
15417: LD_INT 22
15419: PUSH
15420: LD_OWVAR 2
15424: PUSH
15425: EMPTY
15426: LIST
15427: LIST
15428: PPUSH
15429: CALL_OW 69
15433: PPUSH
15434: LD_VAR 0 1
15438: PPUSH
15439: CALL_OW 74
15443: PPUSH
15444: CALL_OW 115
// until IsDead ( un ) ;
15448: LD_VAR 0 1
15452: PPUSH
15453: CALL_OW 301
15457: IFFALSE 15405
// end ;
15459: PPOPN 1
15461: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15462: LD_EXP 19
15466: PUSH
15467: LD_EXP 59
15471: AND
15472: IFFALSE 15484
15474: GO 15476
15476: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15477: LD_STRING earthquake(getX(game), 0, 32)
15479: PPUSH
15480: CALL_OW 559
15484: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15485: LD_EXP 19
15489: PUSH
15490: LD_EXP 60
15494: AND
15495: IFFALSE 15586
15497: GO 15499
15499: DISABLE
15500: LD_INT 0
15502: PPUSH
// begin enable ;
15503: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15504: LD_ADDR_VAR 0 1
15508: PUSH
15509: LD_INT 22
15511: PUSH
15512: LD_OWVAR 2
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PUSH
15521: LD_INT 21
15523: PUSH
15524: LD_INT 2
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: PUSH
15531: LD_INT 33
15533: PUSH
15534: LD_INT 3
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: LIST
15545: PPUSH
15546: CALL_OW 69
15550: ST_TO_ADDR
// if not tmp then
15551: LD_VAR 0 1
15555: NOT
15556: IFFALSE 15560
// exit ;
15558: GO 15586
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15560: LD_VAR 0 1
15564: PUSH
15565: LD_INT 1
15567: PPUSH
15568: LD_VAR 0 1
15572: PPUSH
15573: CALL_OW 12
15577: ARRAY
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: CALL_OW 234
// end ;
15586: PPOPN 1
15588: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15589: LD_EXP 19
15593: PUSH
15594: LD_EXP 61
15598: AND
15599: IFFALSE 15740
15601: GO 15603
15603: DISABLE
15604: LD_INT 0
15606: PPUSH
15607: PPUSH
15608: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15609: LD_ADDR_VAR 0 3
15613: PUSH
15614: LD_INT 22
15616: PUSH
15617: LD_OWVAR 2
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: LD_INT 25
15628: PUSH
15629: LD_INT 1
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PPUSH
15640: CALL_OW 69
15644: ST_TO_ADDR
// if not tmp then
15645: LD_VAR 0 3
15649: NOT
15650: IFFALSE 15654
// exit ;
15652: GO 15740
// un := tmp [ rand ( 1 , tmp ) ] ;
15654: LD_ADDR_VAR 0 2
15658: PUSH
15659: LD_VAR 0 3
15663: PUSH
15664: LD_INT 1
15666: PPUSH
15667: LD_VAR 0 3
15671: PPUSH
15672: CALL_OW 12
15676: ARRAY
15677: ST_TO_ADDR
// if Crawls ( un ) then
15678: LD_VAR 0 2
15682: PPUSH
15683: CALL_OW 318
15687: IFFALSE 15698
// ComWalk ( un ) ;
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15698: LD_VAR 0 2
15702: PPUSH
15703: LD_INT 9
15705: PPUSH
15706: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
15710: LD_INT 28
15712: PPUSH
15713: LD_OWVAR 2
15717: PPUSH
15718: LD_INT 2
15720: PPUSH
15721: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
15725: LD_INT 29
15727: PPUSH
15728: LD_OWVAR 2
15732: PPUSH
15733: LD_INT 2
15735: PPUSH
15736: CALL_OW 322
// end ;
15740: PPOPN 3
15742: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
15743: LD_EXP 19
15747: PUSH
15748: LD_EXP 62
15752: AND
15753: IFFALSE 15864
15755: GO 15757
15757: DISABLE
15758: LD_INT 0
15760: PPUSH
15761: PPUSH
15762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15763: LD_ADDR_VAR 0 3
15767: PUSH
15768: LD_INT 22
15770: PUSH
15771: LD_OWVAR 2
15775: PUSH
15776: EMPTY
15777: LIST
15778: LIST
15779: PUSH
15780: LD_INT 25
15782: PUSH
15783: LD_INT 1
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: EMPTY
15791: LIST
15792: LIST
15793: PPUSH
15794: CALL_OW 69
15798: ST_TO_ADDR
// if not tmp then
15799: LD_VAR 0 3
15803: NOT
15804: IFFALSE 15808
// exit ;
15806: GO 15864
// un := tmp [ rand ( 1 , tmp ) ] ;
15808: LD_ADDR_VAR 0 2
15812: PUSH
15813: LD_VAR 0 3
15817: PUSH
15818: LD_INT 1
15820: PPUSH
15821: LD_VAR 0 3
15825: PPUSH
15826: CALL_OW 12
15830: ARRAY
15831: ST_TO_ADDR
// if Crawls ( un ) then
15832: LD_VAR 0 2
15836: PPUSH
15837: CALL_OW 318
15841: IFFALSE 15852
// ComWalk ( un ) ;
15843: LD_VAR 0 2
15847: PPUSH
15848: CALL_OW 138
// SetClass ( un , class_mortar ) ;
15852: LD_VAR 0 2
15856: PPUSH
15857: LD_INT 8
15859: PPUSH
15860: CALL_OW 336
// end ;
15864: PPOPN 3
15866: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
15867: LD_EXP 19
15871: PUSH
15872: LD_EXP 63
15876: AND
15877: IFFALSE 16021
15879: GO 15881
15881: DISABLE
15882: LD_INT 0
15884: PPUSH
15885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
15886: LD_ADDR_VAR 0 2
15890: PUSH
15891: LD_INT 22
15893: PUSH
15894: LD_OWVAR 2
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 21
15905: PUSH
15906: LD_INT 2
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 2
15915: PUSH
15916: LD_INT 34
15918: PUSH
15919: LD_INT 12
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 34
15928: PUSH
15929: LD_INT 51
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: LD_INT 34
15938: PUSH
15939: LD_INT 32
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: LIST
15950: LIST
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: LIST
15956: PPUSH
15957: CALL_OW 69
15961: ST_TO_ADDR
// if not tmp then
15962: LD_VAR 0 2
15966: NOT
15967: IFFALSE 15971
// exit ;
15969: GO 16021
// for i in tmp do
15971: LD_ADDR_VAR 0 1
15975: PUSH
15976: LD_VAR 0 2
15980: PUSH
15981: FOR_IN
15982: IFFALSE 16019
// if GetCargo ( i , mat_artifact ) = 0 then
15984: LD_VAR 0 1
15988: PPUSH
15989: LD_INT 4
15991: PPUSH
15992: CALL_OW 289
15996: PUSH
15997: LD_INT 0
15999: EQUAL
16000: IFFALSE 16017
// SetCargo ( i , mat_siberit , 100 ) ;
16002: LD_VAR 0 1
16006: PPUSH
16007: LD_INT 3
16009: PPUSH
16010: LD_INT 100
16012: PPUSH
16013: CALL_OW 290
16017: GO 15981
16019: POP
16020: POP
// end ;
16021: PPOPN 2
16023: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
16024: LD_EXP 19
16028: PUSH
16029: LD_EXP 64
16033: AND
16034: IFFALSE 16187
16036: GO 16038
16038: DISABLE
16039: LD_INT 0
16041: PPUSH
16042: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
16043: LD_ADDR_VAR 0 2
16047: PUSH
16048: LD_INT 22
16050: PUSH
16051: LD_OWVAR 2
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PPUSH
16060: CALL_OW 69
16064: ST_TO_ADDR
// if not tmp then
16065: LD_VAR 0 2
16069: NOT
16070: IFFALSE 16074
// exit ;
16072: GO 16187
// for i := 1 to 2 do
16074: LD_ADDR_VAR 0 1
16078: PUSH
16079: DOUBLE
16080: LD_INT 1
16082: DEC
16083: ST_TO_ADDR
16084: LD_INT 2
16086: PUSH
16087: FOR_TO
16088: IFFALSE 16185
// begin uc_side := your_side ;
16090: LD_ADDR_OWVAR 20
16094: PUSH
16095: LD_OWVAR 2
16099: ST_TO_ADDR
// uc_nation := nation_american ;
16100: LD_ADDR_OWVAR 21
16104: PUSH
16105: LD_INT 1
16107: ST_TO_ADDR
// vc_chassis := us_morphling ;
16108: LD_ADDR_OWVAR 37
16112: PUSH
16113: LD_INT 5
16115: ST_TO_ADDR
// vc_engine := engine_siberite ;
16116: LD_ADDR_OWVAR 39
16120: PUSH
16121: LD_INT 3
16123: ST_TO_ADDR
// vc_control := control_computer ;
16124: LD_ADDR_OWVAR 38
16128: PUSH
16129: LD_INT 3
16131: ST_TO_ADDR
// vc_weapon := us_double_laser ;
16132: LD_ADDR_OWVAR 40
16136: PUSH
16137: LD_INT 10
16139: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
16140: CALL_OW 45
16144: PPUSH
16145: LD_VAR 0 2
16149: PUSH
16150: LD_INT 1
16152: ARRAY
16153: PPUSH
16154: CALL_OW 250
16158: PPUSH
16159: LD_VAR 0 2
16163: PUSH
16164: LD_INT 1
16166: ARRAY
16167: PPUSH
16168: CALL_OW 251
16172: PPUSH
16173: LD_INT 12
16175: PPUSH
16176: LD_INT 1
16178: PPUSH
16179: CALL_OW 50
// end ;
16183: GO 16087
16185: POP
16186: POP
// end ;
16187: PPOPN 2
16189: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
16190: LD_EXP 19
16194: PUSH
16195: LD_EXP 65
16199: AND
16200: IFFALSE 16422
16202: GO 16204
16204: DISABLE
16205: LD_INT 0
16207: PPUSH
16208: PPUSH
16209: PPUSH
16210: PPUSH
16211: PPUSH
16212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16213: LD_ADDR_VAR 0 6
16217: PUSH
16218: LD_INT 22
16220: PUSH
16221: LD_OWVAR 2
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 21
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: LD_INT 3
16242: PUSH
16243: LD_INT 23
16245: PUSH
16246: LD_INT 0
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: PUSH
16253: EMPTY
16254: LIST
16255: LIST
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: LIST
16261: PPUSH
16262: CALL_OW 69
16266: ST_TO_ADDR
// if not tmp then
16267: LD_VAR 0 6
16271: NOT
16272: IFFALSE 16276
// exit ;
16274: GO 16422
// s1 := rand ( 1 , 4 ) ;
16276: LD_ADDR_VAR 0 2
16280: PUSH
16281: LD_INT 1
16283: PPUSH
16284: LD_INT 4
16286: PPUSH
16287: CALL_OW 12
16291: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
16292: LD_ADDR_VAR 0 4
16296: PUSH
16297: LD_VAR 0 6
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_VAR 0 2
16310: PPUSH
16311: CALL_OW 259
16315: ST_TO_ADDR
// if s1 = 1 then
16316: LD_VAR 0 2
16320: PUSH
16321: LD_INT 1
16323: EQUAL
16324: IFFALSE 16344
// s2 := rand ( 2 , 4 ) else
16326: LD_ADDR_VAR 0 3
16330: PUSH
16331: LD_INT 2
16333: PPUSH
16334: LD_INT 4
16336: PPUSH
16337: CALL_OW 12
16341: ST_TO_ADDR
16342: GO 16352
// s2 := 1 ;
16344: LD_ADDR_VAR 0 3
16348: PUSH
16349: LD_INT 1
16351: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_VAR 0 6
16361: PUSH
16362: LD_INT 1
16364: ARRAY
16365: PPUSH
16366: LD_VAR 0 3
16370: PPUSH
16371: CALL_OW 259
16375: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16376: LD_VAR 0 6
16380: PUSH
16381: LD_INT 1
16383: ARRAY
16384: PPUSH
16385: LD_VAR 0 2
16389: PPUSH
16390: LD_VAR 0 5
16394: PPUSH
16395: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16399: LD_VAR 0 6
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PPUSH
16408: LD_VAR 0 3
16412: PPUSH
16413: LD_VAR 0 4
16417: PPUSH
16418: CALL_OW 237
// end ;
16422: PPOPN 6
16424: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16425: LD_EXP 19
16429: PUSH
16430: LD_EXP 66
16434: AND
16435: IFFALSE 16514
16437: GO 16439
16439: DISABLE
16440: LD_INT 0
16442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16443: LD_ADDR_VAR 0 1
16447: PUSH
16448: LD_INT 22
16450: PUSH
16451: LD_OWVAR 2
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: PUSH
16460: LD_INT 30
16462: PUSH
16463: LD_INT 3
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 69
16478: ST_TO_ADDR
// if not tmp then
16479: LD_VAR 0 1
16483: NOT
16484: IFFALSE 16488
// exit ;
16486: GO 16514
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16488: LD_VAR 0 1
16492: PUSH
16493: LD_INT 1
16495: PPUSH
16496: LD_VAR 0 1
16500: PPUSH
16501: CALL_OW 12
16505: ARRAY
16506: PPUSH
16507: LD_INT 1
16509: PPUSH
16510: CALL_OW 234
// end ;
16514: PPOPN 1
16516: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16517: LD_EXP 19
16521: PUSH
16522: LD_EXP 67
16526: AND
16527: IFFALSE 16639
16529: GO 16531
16531: DISABLE
16532: LD_INT 0
16534: PPUSH
16535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16536: LD_ADDR_VAR 0 2
16540: PUSH
16541: LD_INT 22
16543: PUSH
16544: LD_OWVAR 2
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PUSH
16553: LD_INT 2
16555: PUSH
16556: LD_INT 30
16558: PUSH
16559: LD_INT 27
16561: PUSH
16562: EMPTY
16563: LIST
16564: LIST
16565: PUSH
16566: LD_INT 30
16568: PUSH
16569: LD_INT 26
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PUSH
16576: LD_INT 30
16578: PUSH
16579: LD_INT 28
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: PPUSH
16596: CALL_OW 69
16600: ST_TO_ADDR
// if not tmp then
16601: LD_VAR 0 2
16605: NOT
16606: IFFALSE 16610
// exit ;
16608: GO 16639
// for i in tmp do
16610: LD_ADDR_VAR 0 1
16614: PUSH
16615: LD_VAR 0 2
16619: PUSH
16620: FOR_IN
16621: IFFALSE 16637
// SetLives ( i , 1 ) ;
16623: LD_VAR 0 1
16627: PPUSH
16628: LD_INT 1
16630: PPUSH
16631: CALL_OW 234
16635: GO 16620
16637: POP
16638: POP
// end ;
16639: PPOPN 2
16641: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16642: LD_EXP 19
16646: PUSH
16647: LD_EXP 68
16651: AND
16652: IFFALSE 16926
16654: GO 16656
16656: DISABLE
16657: LD_INT 0
16659: PPUSH
16660: PPUSH
16661: PPUSH
// begin i := rand ( 1 , 7 ) ;
16662: LD_ADDR_VAR 0 1
16666: PUSH
16667: LD_INT 1
16669: PPUSH
16670: LD_INT 7
16672: PPUSH
16673: CALL_OW 12
16677: ST_TO_ADDR
// case i of 1 :
16678: LD_VAR 0 1
16682: PUSH
16683: LD_INT 1
16685: DOUBLE
16686: EQUAL
16687: IFTRUE 16691
16689: GO 16701
16691: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16692: LD_STRING earthquake(getX(game), 0, 32)
16694: PPUSH
16695: CALL_OW 559
16699: GO 16926
16701: LD_INT 2
16703: DOUBLE
16704: EQUAL
16705: IFTRUE 16709
16707: GO 16723
16709: POP
// begin ToLua ( displayStucuk(); ) ;
16710: LD_STRING displayStucuk();
16712: PPUSH
16713: CALL_OW 559
// ResetFog ;
16717: CALL_OW 335
// end ; 3 :
16721: GO 16926
16723: LD_INT 3
16725: DOUBLE
16726: EQUAL
16727: IFTRUE 16731
16729: GO 16835
16731: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16732: LD_ADDR_VAR 0 2
16736: PUSH
16737: LD_INT 22
16739: PUSH
16740: LD_OWVAR 2
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PUSH
16749: LD_INT 25
16751: PUSH
16752: LD_INT 1
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PPUSH
16763: CALL_OW 69
16767: ST_TO_ADDR
// if not tmp then
16768: LD_VAR 0 2
16772: NOT
16773: IFFALSE 16777
// exit ;
16775: GO 16926
// un := tmp [ rand ( 1 , tmp ) ] ;
16777: LD_ADDR_VAR 0 3
16781: PUSH
16782: LD_VAR 0 2
16786: PUSH
16787: LD_INT 1
16789: PPUSH
16790: LD_VAR 0 2
16794: PPUSH
16795: CALL_OW 12
16799: ARRAY
16800: ST_TO_ADDR
// if Crawls ( un ) then
16801: LD_VAR 0 3
16805: PPUSH
16806: CALL_OW 318
16810: IFFALSE 16821
// ComWalk ( un ) ;
16812: LD_VAR 0 3
16816: PPUSH
16817: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16821: LD_VAR 0 3
16825: PPUSH
16826: LD_INT 8
16828: PPUSH
16829: CALL_OW 336
// end ; 4 :
16833: GO 16926
16835: LD_INT 4
16837: DOUBLE
16838: EQUAL
16839: IFTRUE 16843
16841: GO 16904
16843: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16844: LD_ADDR_VAR 0 2
16848: PUSH
16849: LD_INT 22
16851: PUSH
16852: LD_OWVAR 2
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: PUSH
16861: LD_INT 30
16863: PUSH
16864: LD_INT 29
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PPUSH
16875: CALL_OW 69
16879: ST_TO_ADDR
// if not tmp then
16880: LD_VAR 0 2
16884: NOT
16885: IFFALSE 16889
// exit ;
16887: GO 16926
// DestroyUnit ( tmp [ 1 ] ) ;
16889: LD_VAR 0 2
16893: PUSH
16894: LD_INT 1
16896: ARRAY
16897: PPUSH
16898: CALL_OW 65
// end ; 5 .. 7 :
16902: GO 16926
16904: LD_INT 5
16906: DOUBLE
16907: GREATEREQUAL
16908: IFFALSE 16916
16910: LD_INT 7
16912: DOUBLE
16913: LESSEQUAL
16914: IFTRUE 16918
16916: GO 16925
16918: POP
// StreamSibBomb ; end ;
16919: CALL 13206 0 0
16923: GO 16926
16925: POP
// end ;
16926: PPOPN 3
16928: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
16929: LD_EXP 19
16933: PUSH
16934: LD_EXP 69
16938: AND
16939: IFFALSE 17095
16941: GO 16943
16943: DISABLE
16944: LD_INT 0
16946: PPUSH
16947: PPUSH
16948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
16949: LD_ADDR_VAR 0 2
16953: PUSH
16954: LD_INT 81
16956: PUSH
16957: LD_OWVAR 2
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: LD_INT 2
16968: PUSH
16969: LD_INT 21
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: LD_INT 21
16981: PUSH
16982: LD_INT 2
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: LIST
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PPUSH
16998: CALL_OW 69
17002: ST_TO_ADDR
// if not tmp then
17003: LD_VAR 0 2
17007: NOT
17008: IFFALSE 17012
// exit ;
17010: GO 17095
// p := 0 ;
17012: LD_ADDR_VAR 0 3
17016: PUSH
17017: LD_INT 0
17019: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17020: LD_INT 35
17022: PPUSH
17023: CALL_OW 67
// p := p + 1 ;
17027: LD_ADDR_VAR 0 3
17031: PUSH
17032: LD_VAR 0 3
17036: PUSH
17037: LD_INT 1
17039: PLUS
17040: ST_TO_ADDR
// for i in tmp do
17041: LD_ADDR_VAR 0 1
17045: PUSH
17046: LD_VAR 0 2
17050: PUSH
17051: FOR_IN
17052: IFFALSE 17083
// if GetLives ( i ) < 1000 then
17054: LD_VAR 0 1
17058: PPUSH
17059: CALL_OW 256
17063: PUSH
17064: LD_INT 1000
17066: LESS
17067: IFFALSE 17081
// SetLives ( i , 1000 ) ;
17069: LD_VAR 0 1
17073: PPUSH
17074: LD_INT 1000
17076: PPUSH
17077: CALL_OW 234
17081: GO 17051
17083: POP
17084: POP
// until p > 20 ;
17085: LD_VAR 0 3
17089: PUSH
17090: LD_INT 20
17092: GREATER
17093: IFFALSE 17020
// end ;
17095: PPOPN 3
17097: END
// every 0 0$1 trigger StreamModeActive and sTime do
17098: LD_EXP 19
17102: PUSH
17103: LD_EXP 70
17107: AND
17108: IFFALSE 17143
17110: GO 17112
17112: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
17113: LD_INT 28
17115: PPUSH
17116: LD_OWVAR 2
17120: PPUSH
17121: LD_INT 2
17123: PPUSH
17124: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
17128: LD_INT 30
17130: PPUSH
17131: LD_OWVAR 2
17135: PPUSH
17136: LD_INT 2
17138: PPUSH
17139: CALL_OW 322
// end ;
17143: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
17144: LD_EXP 19
17148: PUSH
17149: LD_EXP 71
17153: AND
17154: IFFALSE 17275
17156: GO 17158
17158: DISABLE
17159: LD_INT 0
17161: PPUSH
17162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17163: LD_ADDR_VAR 0 2
17167: PUSH
17168: LD_INT 22
17170: PUSH
17171: LD_OWVAR 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: LD_INT 21
17182: PUSH
17183: LD_INT 1
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: PUSH
17190: LD_INT 3
17192: PUSH
17193: LD_INT 23
17195: PUSH
17196: LD_INT 0
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: LIST
17211: PPUSH
17212: CALL_OW 69
17216: ST_TO_ADDR
// if not tmp then
17217: LD_VAR 0 2
17221: NOT
17222: IFFALSE 17226
// exit ;
17224: GO 17275
// for i in tmp do
17226: LD_ADDR_VAR 0 1
17230: PUSH
17231: LD_VAR 0 2
17235: PUSH
17236: FOR_IN
17237: IFFALSE 17273
// begin if Crawls ( i ) then
17239: LD_VAR 0 1
17243: PPUSH
17244: CALL_OW 318
17248: IFFALSE 17259
// ComWalk ( i ) ;
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL_OW 138
// SetClass ( i , 2 ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: LD_INT 2
17266: PPUSH
17267: CALL_OW 336
// end ;
17271: GO 17236
17273: POP
17274: POP
// end ;
17275: PPOPN 2
17277: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
17278: LD_EXP 19
17282: PUSH
17283: LD_EXP 72
17287: AND
17288: IFFALSE 17509
17290: GO 17292
17292: DISABLE
17293: LD_INT 0
17295: PPUSH
17296: PPUSH
17297: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
17298: LD_OWVAR 2
17302: PPUSH
17303: LD_INT 9
17305: PPUSH
17306: LD_INT 1
17308: PPUSH
17309: LD_INT 1
17311: PPUSH
17312: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17316: LD_INT 9
17318: PPUSH
17319: LD_OWVAR 2
17323: PPUSH
17324: CALL_OW 343
// uc_side := 9 ;
17328: LD_ADDR_OWVAR 20
17332: PUSH
17333: LD_INT 9
17335: ST_TO_ADDR
// uc_nation := 2 ;
17336: LD_ADDR_OWVAR 21
17340: PUSH
17341: LD_INT 2
17343: ST_TO_ADDR
// hc_name := Dark Warrior ;
17344: LD_ADDR_OWVAR 26
17348: PUSH
17349: LD_STRING Dark Warrior
17351: ST_TO_ADDR
// hc_gallery :=  ;
17352: LD_ADDR_OWVAR 33
17356: PUSH
17357: LD_STRING 
17359: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
17360: LD_INT 1
17362: PPUSH
17363: LD_INT 1
17365: PPUSH
17366: LD_INT 10
17368: PPUSH
17369: CALL_OW 380
// un := CreateHuman ;
17373: LD_ADDR_VAR 0 3
17377: PUSH
17378: CALL_OW 44
17382: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17383: LD_VAR 0 3
17387: PPUSH
17388: LD_INT 1
17390: PPUSH
17391: CALL_OW 51
// p := 0 ;
17395: LD_ADDR_VAR 0 2
17399: PUSH
17400: LD_INT 0
17402: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17403: LD_INT 35
17405: PPUSH
17406: CALL_OW 67
// if GetLives ( un ) < 1000 then
17410: LD_VAR 0 3
17414: PPUSH
17415: CALL_OW 256
17419: PUSH
17420: LD_INT 1000
17422: LESS
17423: IFFALSE 17437
// SetLives ( un , 1000 ) ;
17425: LD_VAR 0 3
17429: PPUSH
17430: LD_INT 1000
17432: PPUSH
17433: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
17437: LD_VAR 0 3
17441: PPUSH
17442: LD_INT 81
17444: PUSH
17445: LD_OWVAR 2
17449: PUSH
17450: EMPTY
17451: LIST
17452: LIST
17453: PPUSH
17454: CALL_OW 69
17458: PPUSH
17459: LD_VAR 0 3
17463: PPUSH
17464: CALL_OW 74
17468: PPUSH
17469: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17473: LD_VAR 0 2
17477: PUSH
17478: LD_INT 60
17480: GREATER
17481: PUSH
17482: LD_VAR 0 3
17486: PPUSH
17487: CALL_OW 301
17491: OR
17492: IFFALSE 17403
// if un then
17494: LD_VAR 0 3
17498: IFFALSE 17509
// RemoveUnit ( un ) ;
17500: LD_VAR 0 3
17504: PPUSH
17505: CALL_OW 64
// end ; end_of_file
17509: PPOPN 3
17511: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17512: LD_INT 0
17514: PPUSH
17515: PPUSH
17516: PPUSH
17517: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17518: LD_VAR 0 1
17522: PPUSH
17523: CALL_OW 264
17527: PUSH
17528: LD_EXP 18
17532: EQUAL
17533: IFFALSE 17605
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17535: LD_INT 68
17537: PPUSH
17538: LD_VAR 0 1
17542: PPUSH
17543: CALL_OW 255
17547: PPUSH
17548: CALL_OW 321
17552: PUSH
17553: LD_INT 2
17555: EQUAL
17556: IFFALSE 17568
// eff := 70 else
17558: LD_ADDR_VAR 0 6
17562: PUSH
17563: LD_INT 70
17565: ST_TO_ADDR
17566: GO 17576
// eff := 30 ;
17568: LD_ADDR_VAR 0 6
17572: PUSH
17573: LD_INT 30
17575: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17576: LD_VAR 0 1
17580: PPUSH
17581: CALL_OW 250
17585: PPUSH
17586: LD_VAR 0 1
17590: PPUSH
17591: CALL_OW 251
17595: PPUSH
17596: LD_VAR 0 6
17600: PPUSH
17601: CALL_OW 495
// end ; end ;
17605: LD_VAR 0 4
17609: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17610: LD_INT 0
17612: PPUSH
17613: PPUSH
17614: PPUSH
17615: PPUSH
17616: PPUSH
17617: PPUSH
// if cmd = 124 then
17618: LD_VAR 0 1
17622: PUSH
17623: LD_INT 124
17625: EQUAL
17626: IFFALSE 17832
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17628: LD_ADDR_VAR 0 5
17632: PUSH
17633: LD_INT 2
17635: PUSH
17636: LD_INT 34
17638: PUSH
17639: LD_INT 53
17641: PUSH
17642: EMPTY
17643: LIST
17644: LIST
17645: PUSH
17646: LD_INT 34
17648: PUSH
17649: LD_INT 14
17651: PUSH
17652: EMPTY
17653: LIST
17654: LIST
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: LIST
17660: PPUSH
17661: CALL_OW 69
17665: ST_TO_ADDR
// if not tmp then
17666: LD_VAR 0 5
17670: NOT
17671: IFFALSE 17675
// exit ;
17673: GO 17832
// for i in tmp do
17675: LD_ADDR_VAR 0 3
17679: PUSH
17680: LD_VAR 0 5
17684: PUSH
17685: FOR_IN
17686: IFFALSE 17830
// begin taskList := GetTaskList ( i ) ;
17688: LD_ADDR_VAR 0 6
17692: PUSH
17693: LD_VAR 0 3
17697: PPUSH
17698: CALL_OW 437
17702: ST_TO_ADDR
// if not taskList then
17703: LD_VAR 0 6
17707: NOT
17708: IFFALSE 17712
// continue ;
17710: GO 17685
// for j = 1 to taskList do
17712: LD_ADDR_VAR 0 4
17716: PUSH
17717: DOUBLE
17718: LD_INT 1
17720: DEC
17721: ST_TO_ADDR
17722: LD_VAR 0 6
17726: PUSH
17727: FOR_TO
17728: IFFALSE 17826
// if taskList [ j ] [ 1 ] = | then
17730: LD_VAR 0 6
17734: PUSH
17735: LD_VAR 0 4
17739: ARRAY
17740: PUSH
17741: LD_INT 1
17743: ARRAY
17744: PUSH
17745: LD_STRING |
17747: EQUAL
17748: IFFALSE 17824
// begin _taskList := Delete ( taskList , 1 ) ;
17750: LD_ADDR_VAR 0 7
17754: PUSH
17755: LD_VAR 0 6
17759: PPUSH
17760: LD_INT 1
17762: PPUSH
17763: CALL_OW 3
17767: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17768: LD_VAR 0 3
17772: PPUSH
17773: LD_VAR 0 7
17777: PPUSH
17778: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17782: LD_VAR 0 3
17786: PPUSH
17787: LD_VAR 0 6
17791: PUSH
17792: LD_VAR 0 4
17796: ARRAY
17797: PUSH
17798: LD_INT 2
17800: ARRAY
17801: PPUSH
17802: LD_VAR 0 6
17806: PUSH
17807: LD_VAR 0 4
17811: ARRAY
17812: PUSH
17813: LD_INT 3
17815: ARRAY
17816: PPUSH
17817: LD_INT 8
17819: PPUSH
17820: CALL 17837 0 4
// end ;
17824: GO 17727
17826: POP
17827: POP
// end ;
17828: GO 17685
17830: POP
17831: POP
// end ; end ;
17832: LD_VAR 0 2
17836: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17837: LD_INT 0
17839: PPUSH
17840: PPUSH
17841: PPUSH
17842: PPUSH
17843: PPUSH
17844: PPUSH
17845: PPUSH
17846: PPUSH
17847: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17848: LD_VAR 0 1
17852: NOT
17853: PUSH
17854: LD_VAR 0 2
17858: PPUSH
17859: LD_VAR 0 3
17863: PPUSH
17864: CALL_OW 488
17868: NOT
17869: OR
17870: PUSH
17871: LD_VAR 0 4
17875: NOT
17876: OR
17877: IFFALSE 17881
// exit ;
17879: GO 18221
// list := [ ] ;
17881: LD_ADDR_VAR 0 13
17885: PUSH
17886: EMPTY
17887: ST_TO_ADDR
// if x - r < 0 then
17888: LD_VAR 0 2
17892: PUSH
17893: LD_VAR 0 4
17897: MINUS
17898: PUSH
17899: LD_INT 0
17901: LESS
17902: IFFALSE 17914
// min_x := 0 else
17904: LD_ADDR_VAR 0 7
17908: PUSH
17909: LD_INT 0
17911: ST_TO_ADDR
17912: GO 17930
// min_x := x - r ;
17914: LD_ADDR_VAR 0 7
17918: PUSH
17919: LD_VAR 0 2
17923: PUSH
17924: LD_VAR 0 4
17928: MINUS
17929: ST_TO_ADDR
// if y - r < 0 then
17930: LD_VAR 0 3
17934: PUSH
17935: LD_VAR 0 4
17939: MINUS
17940: PUSH
17941: LD_INT 0
17943: LESS
17944: IFFALSE 17956
// min_y := 0 else
17946: LD_ADDR_VAR 0 8
17950: PUSH
17951: LD_INT 0
17953: ST_TO_ADDR
17954: GO 17972
// min_y := y - r ;
17956: LD_ADDR_VAR 0 8
17960: PUSH
17961: LD_VAR 0 3
17965: PUSH
17966: LD_VAR 0 4
17970: MINUS
17971: ST_TO_ADDR
// max_x := x + r ;
17972: LD_ADDR_VAR 0 9
17976: PUSH
17977: LD_VAR 0 2
17981: PUSH
17982: LD_VAR 0 4
17986: PLUS
17987: ST_TO_ADDR
// max_y := y + r ;
17988: LD_ADDR_VAR 0 10
17992: PUSH
17993: LD_VAR 0 3
17997: PUSH
17998: LD_VAR 0 4
18002: PLUS
18003: ST_TO_ADDR
// for _x = min_x to max_x do
18004: LD_ADDR_VAR 0 11
18008: PUSH
18009: DOUBLE
18010: LD_VAR 0 7
18014: DEC
18015: ST_TO_ADDR
18016: LD_VAR 0 9
18020: PUSH
18021: FOR_TO
18022: IFFALSE 18139
// for _y = min_y to max_y do
18024: LD_ADDR_VAR 0 12
18028: PUSH
18029: DOUBLE
18030: LD_VAR 0 8
18034: DEC
18035: ST_TO_ADDR
18036: LD_VAR 0 10
18040: PUSH
18041: FOR_TO
18042: IFFALSE 18135
// begin if not ValidHex ( _x , _y ) then
18044: LD_VAR 0 11
18048: PPUSH
18049: LD_VAR 0 12
18053: PPUSH
18054: CALL_OW 488
18058: NOT
18059: IFFALSE 18063
// continue ;
18061: GO 18041
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18063: LD_VAR 0 11
18067: PPUSH
18068: LD_VAR 0 12
18072: PPUSH
18073: CALL_OW 351
18077: PUSH
18078: LD_VAR 0 11
18082: PPUSH
18083: LD_VAR 0 12
18087: PPUSH
18088: CALL_OW 554
18092: AND
18093: IFFALSE 18133
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18095: LD_ADDR_VAR 0 13
18099: PUSH
18100: LD_VAR 0 13
18104: PPUSH
18105: LD_VAR 0 13
18109: PUSH
18110: LD_INT 1
18112: PLUS
18113: PPUSH
18114: LD_VAR 0 11
18118: PUSH
18119: LD_VAR 0 12
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: PPUSH
18128: CALL_OW 2
18132: ST_TO_ADDR
// end ;
18133: GO 18041
18135: POP
18136: POP
18137: GO 18021
18139: POP
18140: POP
// if not list then
18141: LD_VAR 0 13
18145: NOT
18146: IFFALSE 18150
// exit ;
18148: GO 18221
// for i in list do
18150: LD_ADDR_VAR 0 6
18154: PUSH
18155: LD_VAR 0 13
18159: PUSH
18160: FOR_IN
18161: IFFALSE 18219
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18163: LD_VAR 0 1
18167: PPUSH
18168: LD_STRING M
18170: PUSH
18171: LD_VAR 0 6
18175: PUSH
18176: LD_INT 1
18178: ARRAY
18179: PUSH
18180: LD_VAR 0 6
18184: PUSH
18185: LD_INT 2
18187: ARRAY
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 0
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: PUSH
18210: EMPTY
18211: LIST
18212: PPUSH
18213: CALL_OW 447
18217: GO 18160
18219: POP
18220: POP
// end ;
18221: LD_VAR 0 5
18225: RET
