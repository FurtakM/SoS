// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 181 0 0
// PrepareAllies ;
  12: CALL 2172 0 0
// Action ;
  16: CALL 4314 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// if not Difficulty then
  41: LD_OWVAR 67
  45: NOT
  46: IFFALSE 56
// Difficulty := 2 ;
  48: LD_ADDR_OWVAR 67
  52: PUSH
  53: LD_INT 2
  55: ST_TO_ADDR
// InitVariables ;
  56: CALL 69 0 0
// SetDiplomacy ;
  60: CALL 133 0 0
// end ; end_of_file
  64: LD_VAR 0 1
  68: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// points := 0 ;
  72: LD_ADDR_EXP 8
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// alert := false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// game_over := false ;
  88: LD_ADDR_EXP 7
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// wave_time := 0 0$00 ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// bonus_active := false ;
 104: LD_ADDR_EXP 11
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ignore_wave := false ;
 112: LD_ADDR_EXP 13
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// bonus_num := 0 ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// end ;
 128: LD_VAR 0 1
 132: RET
// export function SetDiplomacy ; begin
 133: LD_INT 0
 135: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 136: LD_INT 92
 138: PPUSH
 139: LD_INT 48
 141: PPUSH
 142: LD_INT 8
 144: PPUSH
 145: LD_INT 32796
 147: NEG
 148: PPUSH
 149: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 153: LD_INT 92
 155: PPUSH
 156: LD_INT 48
 158: PPUSH
 159: LD_INT 8
 161: PPUSH
 162: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 166: LD_INT 5
 168: PPUSH
 169: LD_INT 8
 171: PPUSH
 172: CALL_OW 343
// end ; end_of_file
 176: LD_VAR 0 1
 180: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
 198: PPUSH
 199: PPUSH
 200: PPUSH
// uc_side := 2 ;
 201: LD_ADDR_OWVAR 20
 205: PUSH
 206: LD_INT 2
 208: ST_TO_ADDR
// uc_nation := nation_arabian ;
 209: LD_ADDR_OWVAR 21
 213: PUSH
 214: LD_INT 2
 216: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 1
 222: PPUSH
 223: LD_INT 6
 225: PPUSH
 226: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 230: LD_ADDR_OWVAR 26
 234: PUSH
 235: LD_STRING Nicolas Vervecken
 237: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 238: LD_ADDR_OWVAR 33
 242: PUSH
 243: LD_STRING SecondCharsGal
 245: ST_TO_ADDR
// hc_face_number := 3 ;
 246: LD_ADDR_OWVAR 34
 250: PUSH
 251: LD_INT 3
 253: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 254: LD_ADDR_OWVAR 29
 258: PUSH
 259: LD_INT 11
 261: PUSH
 262: LD_INT 10
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: ST_TO_ADDR
// Vervecken := CreateHuman ;
 269: LD_ADDR_EXP 10
 273: PUSH
 274: CALL_OW 44
 278: ST_TO_ADDR
// InitHc ;
 279: CALL_OW 19
// uc_side := 8 ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_INT 8
 290: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 291: LD_INT 23
 293: PPUSH
 294: CALL_OW 274
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 4000
 304: PUSH
 305: LD_INT 2500
 307: PUSH
 308: LD_INT 1250
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_OWVAR 67
 320: ARRAY
 321: PPUSH
 322: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 326: LD_INT 23
 328: PPUSH
 329: CALL_OW 274
 333: PPUSH
 334: LD_INT 2
 336: PPUSH
 337: LD_INT 300
 339: PPUSH
 340: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 344: LD_INT 23
 346: PPUSH
 347: CALL_OW 274
 351: PPUSH
 352: LD_INT 3
 354: PPUSH
 355: LD_INT 100
 357: PUSH
 358: LD_INT 50
 360: PUSH
 361: LD_INT 30
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: PUSH
 369: LD_OWVAR 67
 373: ARRAY
 374: PPUSH
 375: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 379: LD_ADDR_VAR 0 14
 383: PUSH
 384: LD_INT 23
 386: PPUSH
 387: CALL_OW 250
 391: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 392: LD_ADDR_VAR 0 15
 396: PUSH
 397: LD_INT 23
 399: PPUSH
 400: CALL_OW 251
 404: ST_TO_ADDR
// team := [ ] ;
 405: LD_ADDR_VAR 0 7
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 412: LD_ADDR_VAR 0 8
 416: PUSH
 417: LD_INT 9
 419: PUSH
 420: LD_INT 8
 422: PUSH
 423: LD_INT 7
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_OWVAR 67
 435: ARRAY
 436: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 437: LD_ADDR_VAR 0 9
 441: PUSH
 442: LD_INT 11
 444: PUSH
 445: LD_INT 9
 447: PUSH
 448: LD_INT 8
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_OWVAR 67
 460: ARRAY
 461: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 462: LD_ADDR_VAR 0 10
 466: PUSH
 467: LD_INT 3
 469: PUSH
 470: LD_INT 2
 472: PUSH
 473: LD_INT 2
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: PUSH
 481: LD_OWVAR 67
 485: ARRAY
 486: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 487: LD_ADDR_VAR 0 11
 491: PUSH
 492: LD_INT 5
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: PUSH
 506: LD_OWVAR 67
 510: ARRAY
 511: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 512: LD_ADDR_VAR 0 12
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 2
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 537: LD_ADDR_VAR 0 13
 541: PUSH
 542: LD_INT 6
 544: PUSH
 545: LD_INT 5
 547: PUSH
 548: LD_INT 4
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 562: LD_ADDR_VAR 0 18
 566: PUSH
 567: LD_INT 13
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 26
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 14
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 25
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 14
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 5
 611: PUSH
 612: LD_INT 32
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 14
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 31
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 14
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 14
 659: PUSH
 660: LD_INT 3
 662: PUSH
 663: LD_INT 2
 665: PUSH
 666: LD_INT 25
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 13
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 18
 716: PUSH
 717: LD_OWVAR 67
 721: MINUS
 722: PUSH
 723: LD_INT 1
 725: PLUS
 726: PUSH
 727: FOR_TO
 728: IFFALSE 857
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 730: LD_ADDR_OWVAR 37
 734: PUSH
 735: LD_VAR 0 18
 739: PUSH
 740: LD_VAR 0 2
 744: ARRAY
 745: PUSH
 746: LD_INT 1
 748: ARRAY
 749: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 750: LD_ADDR_OWVAR 39
 754: PUSH
 755: LD_VAR 0 18
 759: PUSH
 760: LD_VAR 0 2
 764: ARRAY
 765: PUSH
 766: LD_INT 2
 768: ARRAY
 769: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 770: LD_ADDR_OWVAR 38
 774: PUSH
 775: LD_VAR 0 18
 779: PUSH
 780: LD_VAR 0 2
 784: ARRAY
 785: PUSH
 786: LD_INT 3
 788: ARRAY
 789: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 790: LD_ADDR_OWVAR 40
 794: PUSH
 795: LD_VAR 0 18
 799: PUSH
 800: LD_VAR 0 2
 804: ARRAY
 805: PUSH
 806: LD_INT 4
 808: ARRAY
 809: ST_TO_ADDR
// un := CreateVehicle ;
 810: LD_ADDR_VAR 0 6
 814: PUSH
 815: CALL_OW 45
 819: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 820: LD_VAR 0 6
 824: PPUSH
 825: LD_INT 0
 827: PPUSH
 828: LD_INT 5
 830: PPUSH
 831: CALL_OW 12
 835: PPUSH
 836: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 840: LD_VAR 0 6
 844: PPUSH
 845: LD_INT 7
 847: PPUSH
 848: LD_INT 0
 850: PPUSH
 851: CALL_OW 49
// end ;
 855: GO 727
 857: POP
 858: POP
// for i = 1 to ape_num do
 859: LD_ADDR_VAR 0 2
 863: PUSH
 864: DOUBLE
 865: LD_INT 1
 867: DEC
 868: ST_TO_ADDR
 869: LD_VAR 0 13
 873: PUSH
 874: FOR_TO
 875: IFFALSE 942
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_INT 16
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 1
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 8
 906: PPUSH
 907: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 911: LD_ADDR_VAR 0 7
 915: PUSH
 916: LD_VAR 0 7
 920: PPUSH
 921: LD_VAR 0 7
 925: PUSH
 926: LD_INT 1
 928: PLUS
 929: PPUSH
 930: CALL_OW 44
 934: PPUSH
 935: CALL_OW 2
 939: ST_TO_ADDR
// end ;
 940: GO 874
 942: POP
 943: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 8
 954: PPUSH
 955: CALL_OW 380
// l1 := CreateHuman ;
 959: LD_ADDR_EXP 2
 963: PUSH
 964: CALL_OW 44
 968: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 969: LD_EXP 2
 973: PPUSH
 974: LD_INT 23
 976: PPUSH
 977: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 981: LD_INT 1
 983: PPUSH
 984: LD_INT 1
 986: PPUSH
 987: LD_VAR 0 8
 991: PPUSH
 992: CALL_OW 380
// l2 := CreateHuman ;
 996: LD_ADDR_EXP 3
1000: PUSH
1001: CALL_OW 44
1005: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1006: LD_EXP 3
1010: PPUSH
1011: LD_INT 23
1013: PPUSH
1014: CALL_OW 52
// for class = 1 to 4 do
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: DOUBLE
1024: LD_INT 1
1026: DEC
1027: ST_TO_ADDR
1028: LD_INT 4
1030: PUSH
1031: FOR_TO
1032: IFFALSE 1131
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: DOUBLE
1040: LD_INT 1
1042: DEC
1043: ST_TO_ADDR
1044: LD_VAR 0 9
1048: PUSH
1049: LD_VAR 0 10
1053: PUSH
1054: LD_VAR 0 11
1058: PUSH
1059: LD_VAR 0 12
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_VAR 0 4
1074: ARRAY
1075: PUSH
1076: FOR_TO
1077: IFFALSE 1127
// begin PrepareHuman ( false , class , skill ) ;
1079: LD_INT 0
1081: PPUSH
1082: LD_VAR 0 4
1086: PPUSH
1087: LD_VAR 0 8
1091: PPUSH
1092: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 7
1105: PPUSH
1106: LD_VAR 0 7
1110: PUSH
1111: LD_INT 1
1113: PLUS
1114: PPUSH
1115: CALL_OW 44
1119: PPUSH
1120: CALL_OW 2
1124: ST_TO_ADDR
// end ;
1125: GO 1076
1127: POP
1128: POP
1129: GO 1031
1131: POP
1132: POP
// for i in team do
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 7
1142: PUSH
1143: FOR_IN
1144: IFFALSE 1620
// begin b := 0 ;
1146: LD_ADDR_VAR 0 5
1150: PUSH
1151: LD_INT 0
1153: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1154: LD_VAR 0 2
1158: PPUSH
1159: CALL_OW 257
1163: PUSH
1164: LD_INT 1
1166: DOUBLE
1167: EQUAL
1168: IFTRUE 1172
1170: GO 1279
1172: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 22
1180: PUSH
1181: LD_OWVAR 20
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 2
1192: PUSH
1193: LD_INT 30
1195: PUSH
1196: LD_INT 32
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 30
1205: PUSH
1206: LD_INT 31
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 58
1220: PUSH
1221: EMPTY
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: ST_TO_ADDR
// if not b then
1234: LD_VAR 0 5
1238: NOT
1239: IFFALSE 1277
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1241: LD_ADDR_VAR 0 5
1245: PUSH
1246: LD_INT 22
1248: PUSH
1249: LD_OWVAR 20
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// end ; class_engineer :
1277: GO 1518
1279: LD_INT 2
1281: DOUBLE
1282: EQUAL
1283: IFTRUE 1287
1285: GO 1326
1287: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_OWVAR 20
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 30
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
1324: GO 1518
1326: LD_INT 3
1328: DOUBLE
1329: EQUAL
1330: IFTRUE 1334
1332: GO 1423
1334: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1335: LD_ADDR_VAR 0 5
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_OWVAR 20
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 21
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 58
1364: PUSH
1365: EMPTY
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: ST_TO_ADDR
// if not b then
1378: LD_VAR 0 5
1382: NOT
1383: IFFALSE 1421
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1385: LD_ADDR_VAR 0 5
1389: PUSH
1390: LD_INT 22
1392: PUSH
1393: LD_OWVAR 20
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 30
1404: PUSH
1405: LD_INT 3
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL_OW 69
1420: ST_TO_ADDR
// end ; class_scientistic :
1421: GO 1518
1423: LD_INT 4
1425: DOUBLE
1426: EQUAL
1427: IFTRUE 1431
1429: GO 1470
1431: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1432: LD_ADDR_VAR 0 5
1436: PUSH
1437: LD_INT 22
1439: PUSH
1440: LD_OWVAR 20
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PPUSH
1463: CALL_OW 69
1467: ST_TO_ADDR
// end ; class_apeman_soldier :
1468: GO 1518
1470: LD_INT 15
1472: DOUBLE
1473: EQUAL
1474: IFTRUE 1478
1476: GO 1517
1478: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1479: LD_ADDR_VAR 0 5
1483: PUSH
1484: LD_INT 22
1486: PUSH
1487: LD_OWVAR 20
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 30
1498: PUSH
1499: LD_INT 5
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: ST_TO_ADDR
1515: GO 1518
1517: POP
// if b then
1518: LD_VAR 0 5
1522: IFFALSE 1593
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1524: LD_VAR 0 5
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: CALL_OW 266
1537: PUSH
1538: LD_INT 31
1540: EQUAL
1541: IFFALSE 1563
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_VAR 0 5
1552: PUSH
1553: LD_INT 1
1555: ARRAY
1556: PPUSH
1557: CALL 5028 0 2
1561: GO 1591
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1563: LD_VAR 0 2
1567: PPUSH
1568: LD_VAR 0 5
1572: PUSH
1573: LD_INT 1
1575: PPUSH
1576: LD_VAR 0 5
1580: PPUSH
1581: CALL_OW 12
1585: ARRAY
1586: PPUSH
1587: CALL_OW 52
1591: GO 1618
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1593: LD_VAR 0 2
1597: PPUSH
1598: LD_VAR 0 14
1602: PPUSH
1603: LD_VAR 0 15
1607: PPUSH
1608: LD_INT 15
1610: PPUSH
1611: LD_INT 0
1613: PPUSH
1614: CALL_OW 50
// end ;
1618: GO 1143
1620: POP
1621: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1622: LD_ADDR_VAR 0 16
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 2
1635: PUSH
1636: LD_INT 1
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PUSH
1644: LD_OWVAR 67
1648: ARRAY
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: PUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 5
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_OWVAR 67
1675: ARRAY
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: LD_INT 5
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 4
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: LIST
1697: PUSH
1698: LD_OWVAR 67
1702: ARRAY
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: LD_INT 30
1710: PUSH
1711: LD_INT 2
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_OWVAR 67
1729: ARRAY
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1741: LD_ADDR_VAR 0 2
1745: PUSH
1746: LD_INT 22
1748: PUSH
1749: LD_OWVAR 20
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 30
1760: PUSH
1761: LD_INT 32
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: PUSH
1777: FOR_IN
1778: IFFALSE 1951
// begin if weapons then
1780: LD_VAR 0 16
1784: IFFALSE 1908
// begin k := rand ( 1 , weapons ) ;
1786: LD_ADDR_VAR 0 3
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_VAR 0 16
1798: PPUSH
1799: CALL_OW 12
1803: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1804: LD_ADDR_VAR 0 17
1808: PUSH
1809: LD_VAR 0 16
1813: PUSH
1814: LD_VAR 0 3
1818: ARRAY
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1824: LD_ADDR_VAR 0 16
1828: PUSH
1829: LD_VAR 0 16
1833: PPUSH
1834: LD_VAR 0 3
1838: PPUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_VAR 0 16
1846: PUSH
1847: LD_VAR 0 3
1851: ARRAY
1852: PUSH
1853: LD_INT 2
1855: ARRAY
1856: PUSH
1857: LD_INT 1
1859: MINUS
1860: PPUSH
1861: CALL 5120 0 4
1865: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1866: LD_VAR 0 16
1870: PUSH
1871: LD_VAR 0 3
1875: ARRAY
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: PUSH
1881: LD_INT 0
1883: EQUAL
1884: IFFALSE 1906
// weapons := Delete ( weapons , k ) ;
1886: LD_ADDR_VAR 0 16
1890: PUSH
1891: LD_VAR 0 16
1895: PPUSH
1896: LD_VAR 0 3
1900: PPUSH
1901: CALL_OW 3
1905: ST_TO_ADDR
// end else
1906: GO 1935
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_INT 27
1915: PUSH
1916: LD_INT 23
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: CALL_OW 12
1933: ARRAY
1934: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1935: LD_VAR 0 2
1939: PPUSH
1940: LD_VAR 0 17
1944: PPUSH
1945: CALL_OW 431
// end ;
1949: GO 1777
1951: POP
1952: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1953: LD_INT 1
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 8
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: CALL_OW 380
// hc_gallery := potter ;
1972: LD_ADDR_OWVAR 33
1976: PUSH
1977: LD_STRING potter
1979: ST_TO_ADDR
// hc_face_number := 1 ;
1980: LD_ADDR_OWVAR 34
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// hc_importance := 100 ;
1988: LD_ADDR_OWVAR 32
1992: PUSH
1993: LD_INT 100
1995: ST_TO_ADDR
// hc_name := Mike Gerste ;
1996: LD_ADDR_OWVAR 26
2000: PUSH
2001: LD_STRING Mike Gerste
2003: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2004: LD_ADDR_OWVAR 29
2008: PUSH
2009: LD_INT 10
2011: PUSH
2012: LD_INT 11
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: ST_TO_ADDR
// legion_commander := CreateHuman ;
2019: LD_ADDR_EXP 1
2023: PUSH
2024: CALL_OW 44
2028: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2029: LD_EXP 1
2033: PPUSH
2034: LD_INT 23
2036: PPUSH
2037: CALL_OW 52
// uc_side := 5 ;
2041: LD_ADDR_OWVAR 20
2045: PUSH
2046: LD_INT 5
2048: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: LD_VAR 0 8
2059: PPUSH
2060: CALL_OW 380
// hc_gallery := potter ;
2064: LD_ADDR_OWVAR 33
2068: PUSH
2069: LD_STRING potter
2071: ST_TO_ADDR
// hc_face_number := 2 ;
2072: LD_ADDR_OWVAR 34
2076: PUSH
2077: LD_INT 2
2079: ST_TO_ADDR
// hc_importance := 0 ;
2080: LD_ADDR_OWVAR 32
2084: PUSH
2085: LD_INT 0
2087: ST_TO_ADDR
// hc_name := George Potter ;
2088: LD_ADDR_OWVAR 26
2092: PUSH
2093: LD_STRING George Potter
2095: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2096: LD_ADDR_OWVAR 29
2100: PUSH
2101: LD_INT 12
2103: PUSH
2104: LD_INT 9
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: ST_TO_ADDR
// potter := CreateHuman ;
2111: LD_ADDR_EXP 4
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2121: LD_EXP 4
2125: PPUSH
2126: LD_INT 4
2128: PPUSH
2129: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2133: LD_EXP 4
2137: PPUSH
2138: LD_INT 103
2140: PPUSH
2141: LD_INT 45
2143: PPUSH
2144: LD_INT 0
2146: PPUSH
2147: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2151: LD_EXP 4
2155: PPUSH
2156: LD_INT 23
2158: PPUSH
2159: CALL_OW 119
// InitHc ( ) ;
2163: CALL_OW 19
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
2178: PPUSH
// uc_side := 5 ;
2179: LD_ADDR_OWVAR 20
2183: PUSH
2184: LD_INT 5
2186: ST_TO_ADDR
// uc_nation := nation_arabian ;
2187: LD_ADDR_OWVAR 21
2191: PUSH
2192: LD_INT 2
2194: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2195: LD_ADDR_VAR 0 4
2199: PUSH
2200: LD_INT 22
2202: PUSH
2203: LD_OWVAR 20
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 30
2214: PUSH
2215: LD_INT 5
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PPUSH
2226: CALL_OW 69
2230: ST_TO_ADDR
// for i = 1 to 3 do
2231: LD_ADDR_VAR 0 2
2235: PUSH
2236: DOUBLE
2237: LD_INT 1
2239: DEC
2240: ST_TO_ADDR
2241: LD_INT 3
2243: PUSH
2244: FOR_TO
2245: IFFALSE 2283
// begin PrepareHuman ( false , 2 , 6 ) ;
2247: LD_INT 0
2249: PPUSH
2250: LD_INT 2
2252: PPUSH
2253: LD_INT 6
2255: PPUSH
2256: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2260: CALL_OW 44
2264: PPUSH
2265: LD_INT 27
2267: PPUSH
2268: LD_INT 22
2270: PPUSH
2271: LD_INT 5
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 50
// end ;
2281: GO 2244
2283: POP
2284: POP
// for i = 1 to 3 do
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: DOUBLE
2291: LD_INT 1
2293: DEC
2294: ST_TO_ADDR
2295: LD_INT 3
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2334
// begin PrepareHuman ( false , 1 , 6 ) ;
2301: LD_INT 0
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 6
2309: PPUSH
2310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2314: CALL_OW 44
2318: PPUSH
2319: LD_VAR 0 4
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 52
// end ;
2332: GO 2298
2334: POP
2335: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_INT 22
2343: PUSH
2344: LD_OWVAR 20
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: LD_INT 30
2358: PUSH
2359: LD_INT 31
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 30
2368: PUSH
2369: LD_INT 32
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2478
// begin PrepareHuman ( false , 1 , 6 ) ;
2393: LD_INT 0
2395: PPUSH
2396: LD_INT 1
2398: PPUSH
2399: LD_INT 6
2401: PPUSH
2402: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2406: CALL_OW 44
2410: PPUSH
2411: LD_VAR 0 2
2415: PPUSH
2416: CALL 5028 0 2
// if GetBType ( i ) = b_bunker then
2420: LD_VAR 0 2
2424: PPUSH
2425: CALL_OW 266
2429: PUSH
2430: LD_INT 32
2432: EQUAL
2433: IFFALSE 2476
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_INT 27
2442: PUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 24
2448: PUSH
2449: LD_INT 28
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_INT 4
2465: MOD
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: ARRAY
2471: PPUSH
2472: CALL_OW 431
// end ;
2476: GO 2390
2478: POP
2479: POP
// for i = 1 to 3 do
2480: LD_ADDR_VAR 0 2
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_INT 3
2492: PUSH
2493: FOR_TO
2494: IFFALSE 2611
// begin vc_chassis := ar_half_tracked ;
2496: LD_ADDR_OWVAR 37
2500: PUSH
2501: LD_INT 14
2503: ST_TO_ADDR
// vc_engine := engine_solar ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_INT 2
2511: ST_TO_ADDR
// vc_control := control_manual ;
2512: LD_ADDR_OWVAR 38
2516: PUSH
2517: LD_INT 1
2519: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2520: LD_ADDR_OWVAR 40
2524: PUSH
2525: LD_INT 25
2527: PUSH
2528: LD_INT 27
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_VAR 0 2
2543: ARRAY
2544: ST_TO_ADDR
// un := CreateVehicle ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2555: LD_VAR 0 3
2559: PPUSH
2560: LD_INT 5
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2567: LD_VAR 0 3
2571: PPUSH
2572: LD_INT 8
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2582: LD_INT 0
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 7
2590: PPUSH
2591: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2595: CALL_OW 44
2599: PPUSH
2600: LD_VAR 0 3
2604: PPUSH
2605: CALL_OW 52
// end ;
2609: GO 2493
2611: POP
2612: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 1
2618: PPUSH
2619: LD_INT 6
2621: PPUSH
2622: CALL_OW 380
// al_commander := CreateHuman ;
2626: LD_ADDR_EXP 5
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2636: LD_EXP 5
2640: PPUSH
2641: LD_INT 22
2643: PUSH
2644: LD_OWVAR 20
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: LD_INT 0
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL_OW 69
2671: PUSH
2672: LD_INT 1
2674: ARRAY
2675: PPUSH
2676: CALL_OW 52
// InitHc ( ) ;
2680: CALL_OW 19
// end ;
2684: LD_VAR 0 1
2688: RET
// export function ChangeSide ( ) ; var i ; begin
2689: LD_INT 0
2691: PPUSH
2692: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_INT 22
2700: PUSH
2701: LD_INT 5
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2730
// SetSide ( i , 8 ) ;
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 8
2723: PPUSH
2724: CALL_OW 235
2728: GO 2713
2730: POP
2731: POP
// end ;
2732: LD_VAR 0 1
2736: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2737: LD_INT 22
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PPUSH
2747: CALL_OW 69
2751: IFFALSE 3265
2753: GO 2755
2755: DISABLE
2756: LD_INT 0
2758: PPUSH
2759: PPUSH
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 5
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: LD_INT 21
2785: PUSH
2786: LD_INT 1
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: LD_INT 21
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PPUSH
2812: CALL_OW 69
2816: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_INT 22
2824: PUSH
2825: LD_INT 5
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 30
2834: PUSH
2835: LD_INT 32
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 3
2844: PUSH
2845: LD_INT 24
2847: PUSH
2848: LD_INT 1000
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 69
2868: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 3
2881: PUSH
2882: LD_INT 54
2884: PUSH
2885: EMPTY
2886: LIST
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 25
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 72
2910: ST_TO_ADDR
// if not list then
2911: LD_VAR 0 2
2915: NOT
2916: IFFALSE 2920
// exit ;
2918: GO 3265
// for i in list do
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: PUSH
2930: FOR_IN
2931: IFFALSE 3263
// begin if b then
2933: LD_VAR 0 5
2937: IFFALSE 3016
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PUSH
2952: LD_INT 2
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 72
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3014
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2967: LD_VAR 0 4
2971: PPUSH
2972: CALL_OW 314
2976: NOT
2977: PUSH
2978: LD_VAR 0 1
2982: PPUSH
2983: CALL_OW 110
2987: PUSH
2988: LD_INT 7
2990: NONEQUAL
2991: AND
2992: IFFALSE 3012
// ComRepairBuilding ( j , b [ 1 ] ) ;
2994: LD_VAR 0 4
2998: PPUSH
2999: LD_VAR 0 5
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: PPUSH
3008: CALL_OW 130
3012: GO 2964
3014: POP
3015: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 256
3025: PUSH
3026: LD_INT 500
3028: LESS
3029: PUSH
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 110
3039: PUSH
3040: LD_INT 7
3042: EQUAL
3043: NOT
3044: AND
3045: IFFALSE 3095
// begin ComMoveToArea ( i , guard_hill ) ;
3047: LD_VAR 0 1
3051: PPUSH
3052: LD_INT 11
3054: PPUSH
3055: CALL_OW 113
// SetTag ( i , 7 ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: LD_INT 7
3066: PPUSH
3067: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 247
3080: PUSH
3081: LD_INT 2
3083: EQUAL
3084: IFFALSE 3095
// begin AddComExitVehicle ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3095: LD_VAR 0 1
3099: PPUSH
3100: CALL_OW 256
3104: PUSH
3105: LD_INT 1000
3107: EQUAL
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 110
3118: PUSH
3119: LD_INT 7
3121: EQUAL
3122: AND
3123: PUSH
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 310
3133: NOT
3134: AND
3135: PUSH
3136: LD_VAR 0 6
3140: AND
3141: IFFALSE 3169
// begin SetTag ( i , 0 ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3155: LD_VAR 0 6
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3169: LD_VAR 0 1
3173: PPUSH
3174: CALL_OW 247
3178: PUSH
3179: LD_INT 2
3181: EQUAL
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 110
3192: PUSH
3193: LD_INT 7
3195: NONEQUAL
3196: AND
3197: PUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 314
3207: NOT
3208: AND
3209: IFFALSE 3261
// if FilterAllUnits ( [ f_side , 7 ] ) then
3211: LD_INT 22
3213: PUSH
3214: LD_INT 7
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PPUSH
3221: CALL_OW 69
3225: IFFALSE 3261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_INT 22
3234: PUSH
3235: LD_INT 7
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 69
3246: PPUSH
3247: LD_VAR 0 1
3251: PPUSH
3252: CALL_OW 74
3256: PPUSH
3257: CALL_OW 115
// end ;
3261: GO 2930
3263: POP
3264: POP
// end ; end_of_file
3265: PPOPN 6
3267: END
// export function Game ; var i , val , areas , wave ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: LD_INT 5
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3306: LD_ADDR_VAR 0 3
3310: PUSH
3311: LD_INT 10
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 30
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_OWVAR 67
3329: ARRAY
3330: ST_TO_ADDR
// wave := 1 ;
3331: LD_ADDR_VAR 0 5
3335: PUSH
3336: LD_INT 1
3338: ST_TO_ADDR
// while ( game_over = false ) do
3339: LD_EXP 7
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3511
// begin repeat begin Wait ( 0 0$01 ) ;
3349: LD_INT 35
3351: PPUSH
3352: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3356: LD_ADDR_EXP 9
3360: PUSH
3361: LD_EXP 9
3365: PUSH
3366: LD_INT 35
3368: PLUS
3369: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3370: LD_INT 22
3372: PUSH
3373: LD_INT 7
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 10
3387: LESS
3388: PUSH
3389: LD_EXP 9
3393: PUSH
3394: LD_INT 21000
3396: GREATEREQUAL
3397: OR
3398: IFFALSE 3349
// wave_time := 0 0$00 ;
3400: LD_ADDR_EXP 9
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3408: LD_INT 5250
3410: PPUSH
3411: CALL_OW 67
// if not ignore_wave then
3415: LD_EXP 13
3419: NOT
3420: IFFALSE 3501
// begin for i = 1 to wave do
3422: LD_ADDR_VAR 0 2
3426: PUSH
3427: DOUBLE
3428: LD_INT 1
3430: DEC
3431: ST_TO_ADDR
3432: LD_VAR 0 5
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3483
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3440: LD_VAR 0 3
3444: PUSH
3445: LD_VAR 0 2
3449: MUL
3450: PPUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 6
3463: MOD
3464: PUSH
3465: LD_INT 1
3467: PLUS
3468: ARRAY
3469: PPUSH
3470: CALL 3516 0 2
// Wait ( 0 0$10 ) ;
3474: LD_INT 350
3476: PPUSH
3477: CALL_OW 67
// end ;
3481: GO 3437
3483: POP
3484: POP
// wave := wave + 1 ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_VAR 0 5
3494: PUSH
3495: LD_INT 1
3497: PLUS
3498: ST_TO_ADDR
// end else
3499: GO 3509
// ignore_wave := false ;
3501: LD_ADDR_EXP 13
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// end ;
3509: GO 3339
// end ;
3511: LD_VAR 0 1
3515: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3516: LD_INT 0
3518: PPUSH
3519: PPUSH
3520: PPUSH
3521: PPUSH
// uc_side := 7 ;
3522: LD_ADDR_OWVAR 20
3526: PUSH
3527: LD_INT 7
3529: ST_TO_ADDR
// uc_nation := 2 ;
3530: LD_ADDR_OWVAR 21
3534: PUSH
3535: LD_INT 2
3537: ST_TO_ADDR
// InitHc ( ) ;
3538: CALL_OW 19
// hc_gallery :=  ;
3542: LD_ADDR_OWVAR 33
3546: PUSH
3547: LD_STRING 
3549: ST_TO_ADDR
// hc_importance := 0 ;
3550: LD_ADDR_OWVAR 32
3554: PUSH
3555: LD_INT 0
3557: ST_TO_ADDR
// hc_name :=  ;
3558: LD_ADDR_OWVAR 26
3562: PUSH
3563: LD_STRING 
3565: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3566: LD_ADDR_OWVAR 29
3570: PUSH
3571: LD_INT 10
3573: PUSH
3574: LD_OWVAR 1
3578: PUSH
3579: LD_INT 21000
3581: DIV
3582: PLUS
3583: PUSH
3584: LD_INT 10
3586: PUSH
3587: LD_OWVAR 1
3591: PUSH
3592: LD_INT 21000
3594: DIV
3595: PLUS
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// for i = 1 to val do
3601: LD_ADDR_VAR 0 4
3605: PUSH
3606: DOUBLE
3607: LD_INT 1
3609: DEC
3610: ST_TO_ADDR
3611: LD_VAR 0 1
3615: PUSH
3616: FOR_TO
3617: IFFALSE 3824
// begin if i mod 9 = 0 then
3619: LD_VAR 0 4
3623: PUSH
3624: LD_INT 9
3626: MOD
3627: PUSH
3628: LD_INT 0
3630: EQUAL
3631: IFFALSE 3643
// class := class_apeman_kamikaze else
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_INT 17
3640: ST_TO_ADDR
3641: GO 3675
// if i mod 4 = 0 then
3643: LD_VAR 0 4
3647: PUSH
3648: LD_INT 4
3650: MOD
3651: PUSH
3652: LD_INT 0
3654: EQUAL
3655: IFFALSE 3667
// class := class_apeman_soldier else
3657: LD_ADDR_VAR 0 6
3661: PUSH
3662: LD_INT 15
3664: ST_TO_ADDR
3665: GO 3675
// class := class_apeman ;
3667: LD_ADDR_VAR 0 6
3671: PUSH
3672: LD_INT 12
3674: ST_TO_ADDR
// if i mod 33 = 0 then
3675: LD_VAR 0 4
3679: PUSH
3680: LD_INT 33
3682: MOD
3683: PUSH
3684: LD_INT 0
3686: EQUAL
3687: IFFALSE 3756
// begin vc_chassis := ar_half_tracked ;
3689: LD_ADDR_OWVAR 37
3693: PUSH
3694: LD_INT 14
3696: ST_TO_ADDR
// vc_control := control_apeman ;
3697: LD_ADDR_OWVAR 38
3701: PUSH
3702: LD_INT 5
3704: ST_TO_ADDR
// vc_engine := engine_combustion ;
3705: LD_ADDR_OWVAR 39
3709: PUSH
3710: LD_INT 1
3712: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3713: LD_ADDR_OWVAR 40
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: LD_INT 29
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 1
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: CALL_OW 12
3742: ARRAY
3743: ST_TO_ADDR
// un := CreateVehicle ;
3744: LD_ADDR_VAR 0 5
3748: PUSH
3749: CALL_OW 45
3753: ST_TO_ADDR
// end else
3754: GO 3781
// begin PrepareHuman ( sex_male , class , 10 ) ;
3756: LD_INT 1
3758: PPUSH
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_INT 10
3766: PPUSH
3767: CALL_OW 380
// un := CreateHuman ;
3771: LD_ADDR_VAR 0 5
3775: PUSH
3776: CALL_OW 44
3780: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3781: LD_VAR 0 5
3785: PPUSH
3786: LD_VAR 0 2
3790: PPUSH
3791: LD_INT 0
3793: PPUSH
3794: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3798: LD_VAR 0 5
3802: PPUSH
3803: CALL_OW 250
3807: PPUSH
3808: LD_VAR 0 5
3812: PPUSH
3813: CALL_OW 251
3817: PPUSH
3818: CALL_OW 494
// end ;
3822: GO 3616
3824: POP
3825: POP
// end ;
3826: LD_VAR 0 3
3830: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3831: LD_EXP 6
3835: PUSH
3836: LD_EXP 7
3840: NOT
3841: AND
3842: IFFALSE 4128
3844: GO 3846
3846: DISABLE
3847: LD_INT 0
3849: PPUSH
3850: PPUSH
3851: PPUSH
// begin enable ;
3852: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_INT 22
3860: PUSH
3861: LD_INT 7
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// if not list then
3873: LD_VAR 0 2
3877: NOT
3878: IFFALSE 3882
// exit ;
3880: GO 4128
// for i in list do
3882: LD_ADDR_VAR 0 1
3886: PUSH
3887: LD_VAR 0 2
3891: PUSH
3892: FOR_IN
3893: IFFALSE 4126
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3895: LD_ADDR_VAR 0 3
3899: PUSH
3900: LD_INT 81
3902: PUSH
3903: LD_INT 7
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 92
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 250
3922: PUSH
3923: LD_VAR 0 1
3927: PPUSH
3928: CALL_OW 251
3932: PUSH
3933: LD_INT 15
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 69
3950: ST_TO_ADDR
// if not enemy then
3951: LD_VAR 0 3
3955: NOT
3956: IFFALSE 4014
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3958: LD_ADDR_VAR 0 3
3962: PUSH
3963: LD_INT 81
3965: PUSH
3966: LD_INT 7
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 92
3975: PUSH
3976: LD_VAR 0 1
3980: PPUSH
3981: CALL_OW 250
3985: PUSH
3986: LD_VAR 0 1
3990: PPUSH
3991: CALL_OW 251
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 69
4013: ST_TO_ADDR
// if not enemy then
4014: LD_VAR 0 3
4018: NOT
4019: IFFALSE 4077
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4021: LD_ADDR_VAR 0 3
4025: PUSH
4026: LD_INT 81
4028: PUSH
4029: LD_INT 7
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 92
4038: PUSH
4039: LD_VAR 0 1
4043: PPUSH
4044: CALL_OW 250
4048: PUSH
4049: LD_VAR 0 1
4053: PPUSH
4054: CALL_OW 251
4058: PUSH
4059: LD_INT 50
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 3
4081: NOT
4082: IFFALSE 4104
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4084: LD_ADDR_VAR 0 3
4088: PUSH
4089: LD_INT 81
4091: PUSH
4092: LD_INT 7
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: ST_TO_ADDR
// if enemy then
4104: LD_VAR 0 3
4108: IFFALSE 4124
// Attack ( i , enemy ) ;
4110: LD_VAR 0 1
4114: PPUSH
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL 4131 0 2
// end ;
4124: GO 3892
4126: POP
4127: POP
// end ;
4128: PPOPN 3
4130: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4131: LD_INT 0
4133: PPUSH
4134: PPUSH
4135: PPUSH
// if not unit then
4136: LD_VAR 0 1
4140: NOT
4141: IFFALSE 4145
// exit ;
4143: GO 4309
// targets_list := [ ] ;
4145: LD_ADDR_VAR 0 5
4149: PUSH
4150: EMPTY
4151: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_VAR 0 2
4161: PPUSH
4162: LD_INT 21
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 3
4174: PUSH
4175: LD_INT 54
4177: PUSH
4178: EMPTY
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 72
4193: PUSH
4194: LD_VAR 0 2
4198: PPUSH
4199: LD_INT 21
4201: PUSH
4202: LD_INT 2
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL_OW 72
4213: PUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: LD_INT 21
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 3
4231: PUSH
4232: LD_INT 58
4234: PUSH
4235: EMPTY
4236: LIST
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 72
4250: PUSH
4251: LD_VAR 0 2
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// for target in targets_list do
4262: LD_ADDR_VAR 0 4
4266: PUSH
4267: LD_VAR 0 5
4271: PUSH
4272: FOR_IN
4273: IFFALSE 4307
// begin if target then
4275: LD_VAR 0 4
4279: IFFALSE 4305
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_VAR 0 4
4290: PPUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 74
4300: PPUSH
4301: CALL_OW 115
// end ;
4305: GO 4272
4307: POP
4308: POP
// end ; end_of_file
4309: LD_VAR 0 3
4313: RET
// export function Action ; begin
4314: LD_INT 0
4316: PPUSH
// InGameOn ;
4317: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4321: LD_INT 23
4323: PPUSH
4324: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4328: LD_EXP 1
4332: PPUSH
4333: LD_STRING DL-1
4335: PPUSH
4336: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4340: LD_EXP 2
4344: PPUSH
4345: LD_STRING DA-1
4347: PPUSH
4348: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4352: LD_EXP 3
4356: PPUSH
4357: LD_STRING DA-2
4359: PPUSH
4360: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4364: LD_EXP 1
4368: PPUSH
4369: LD_STRING DL-2
4371: PPUSH
4372: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4376: LD_EXP 3
4380: PPUSH
4381: LD_STRING DA-3
4383: PPUSH
4384: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4388: LD_EXP 1
4392: PPUSH
4393: LD_STRING DL-3
4395: PPUSH
4396: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_STRING DA-4
4407: PPUSH
4408: CALL_OW 88
// if not dialogue_skipped then
4412: LD_OWVAR 59
4416: NOT
4417: IFFALSE 4502
// begin Wait ( 0 0$01 ) ;
4419: LD_INT 35
4421: PPUSH
4422: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4426: LD_EXP 2
4430: PUSH
4431: LD_EXP 3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4444: LD_EXP 2
4448: PPUSH
4449: LD_INT 107
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4459: LD_EXP 3
4463: PPUSH
4464: LD_INT 108
4466: PPUSH
4467: LD_INT 53
4469: PPUSH
4470: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4474: LD_EXP 2
4478: PPUSH
4479: LD_EXP 4
4483: PPUSH
4484: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4488: LD_EXP 3
4492: PPUSH
4493: LD_EXP 4
4497: PPUSH
4498: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4502: LD_INT 35
4504: PPUSH
4505: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4509: LD_EXP 2
4513: PPUSH
4514: LD_INT 107
4516: PPUSH
4517: LD_INT 53
4519: PPUSH
4520: CALL_OW 307
4524: PUSH
4525: LD_OWVAR 59
4529: OR
4530: IFFALSE 4502
// if not dialogue_skipped then
4532: LD_OWVAR 59
4536: NOT
4537: IFFALSE 4638
// begin ComTurnUnit ( potter , l1 ) ;
4539: LD_EXP 4
4543: PPUSH
4544: LD_EXP 2
4548: PPUSH
4549: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4553: LD_INT 10
4555: PPUSH
4556: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4560: LD_EXP 4
4564: PPUSH
4565: LD_INT 108
4567: PPUSH
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 0
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 483
// Wait ( 0 0$01 ) ;
4581: LD_INT 35
4583: PPUSH
4584: CALL_OW 67
// RemoveUnit ( potter ) ;
4588: LD_EXP 4
4592: PPUSH
4593: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4597: LD_EXP 2
4601: PPUSH
4602: LD_STRING DA-5
4604: PPUSH
4605: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4609: LD_EXP 3
4613: PPUSH
4614: LD_STRING DA-6
4616: PPUSH
4617: CALL_OW 88
// Wait ( 0 0$02 ) ;
4621: LD_INT 70
4623: PPUSH
4624: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4628: LD_INT 25
4630: PPUSH
4631: LD_INT 19
4633: PPUSH
4634: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4638: LD_INT 30
4640: PPUSH
4641: LD_INT 1
4643: PPUSH
4644: CALL 3516 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4648: LD_EXP 5
4652: PPUSH
4653: LD_STRING DLa-1
4655: PPUSH
4656: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4660: LD_EXP 1
4664: PPUSH
4665: LD_STRING DL-5
4667: PPUSH
4668: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4672: LD_INT 23
4674: PPUSH
4675: CALL_OW 87
// InGameOff ;
4679: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4683: LD_STRING C1
4685: PPUSH
4686: CALL_OW 337
// alert := true ;
4690: LD_ADDR_EXP 6
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4698: LD_EXP 5
4702: PPUSH
4703: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4707: LD_EXP 5
4711: PPUSH
4712: LD_INT 11
4714: PPUSH
4715: CALL_OW 173
// Wait ( 0 0$30 ) ;
4719: LD_INT 1050
4721: PPUSH
4722: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4726: LD_INT 20
4728: PPUSH
4729: LD_INT 4
4731: PPUSH
4732: CALL 3516 0 2
// Wait ( 0 0$35 ) ;
4736: LD_INT 1225
4738: PPUSH
4739: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4743: LD_INT 20
4745: PPUSH
4746: LD_INT 5
4748: PPUSH
4749: CALL 3516 0 2
// Wait ( 0 0$03 ) ;
4753: LD_INT 105
4755: PPUSH
4756: CALL_OW 67
// Game ;
4760: CALL 3268 0 0
// end ;
4764: LD_VAR 0 1
4768: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4769: LD_INT 22
4771: PUSH
4772: LD_INT 7
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: PUSH
4788: LD_EXP 8
4792: PUSH
4793: LD_INT 500
4795: GREATEREQUAL
4796: AND
4797: IFFALSE 5025
4799: GO 4801
4801: DISABLE
4802: LD_INT 0
4804: PPUSH
4805: PPUSH
// begin DialogueOn ;
4806: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4810: LD_EXP 10
4814: PPUSH
4815: LD_STRING DVr-1
4817: PPUSH
4818: CALL_OW 94
// DialogueOff ;
4822: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4826: LD_STRING QBonusInfo
4828: PPUSH
4829: CALL_OW 97
4833: PUSH
4834: LD_INT 1
4836: DOUBLE
4837: EQUAL
4838: IFTRUE 4842
4840: GO 4853
4842: POP
// bonus_active := true ; end ;
4843: LD_ADDR_EXP 11
4847: PUSH
4848: LD_INT 1
4850: ST_TO_ADDR
4851: GO 4854
4853: POP
// bonus_num := 4 ;
4854: LD_ADDR_EXP 12
4858: PUSH
4859: LD_INT 4
4861: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4862: LD_OWVAR 2
4866: PPUSH
4867: LD_INT 2
4869: PPUSH
4870: LD_INT 2
4872: PPUSH
4873: LD_INT 23
4875: PPUSH
4876: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: LD_INT 500
4887: PUSH
4888: LD_INT 3500
4890: PUSH
4891: LD_INT 5750
4893: PUSH
4894: LD_INT 10000
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// repeat wait ( [ 5 5$00 , 6 6$00 , 7 7$00 ] [ Difficulty ] ) ;
4903: LD_INT 10500
4905: PUSH
4906: LD_INT 12600
4908: PUSH
4909: LD_INT 14700
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_OWVAR 67
4921: ARRAY
4922: PPUSH
4923: CALL_OW 67
// for i = 1 to tmp do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_VAR 0 1
4941: PUSH
4942: FOR_TO
4943: IFFALSE 4975
// if points >= tmp [ i ] then
4945: LD_EXP 8
4949: PUSH
4950: LD_VAR 0 1
4954: PUSH
4955: LD_VAR 0 2
4959: ARRAY
4960: GREATEREQUAL
4961: IFFALSE 4973
// bonus_num := i ;
4963: LD_ADDR_EXP 12
4967: PUSH
4968: LD_VAR 0 2
4972: ST_TO_ADDR
4973: GO 4942
4975: POP
4976: POP
// case Query ( QBonusInfo ) of 1 :
4977: LD_STRING QBonusInfo
4979: PPUSH
4980: CALL_OW 97
4984: PUSH
4985: LD_INT 1
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5014
4993: POP
// SetArtifactUse ( your_side , art_use_exclamation , art_instant , main_base ) ; end ;
4994: LD_OWVAR 2
4998: PPUSH
4999: LD_INT 12
5001: PPUSH
5002: LD_INT 2
5004: PPUSH
5005: LD_INT 23
5007: PPUSH
5008: CALL_OW 468
5012: GO 5015
5014: POP
// until points >= 15000 ;
5015: LD_EXP 8
5019: PUSH
5020: LD_INT 15000
5022: GREATEREQUAL
5023: IFFALSE 4903
// end ; end_of_file
5025: PPOPN 2
5027: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5028: LD_INT 0
5030: PPUSH
5031: PPUSH
// dir := GetDir ( b ) ;
5032: LD_ADDR_VAR 0 4
5036: PUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 254
5046: ST_TO_ADDR
// if dir < 3 then
5047: LD_VAR 0 4
5051: PUSH
5052: LD_INT 3
5054: LESS
5055: IFFALSE 5073
// dir := dir + 3 else
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: LD_VAR 0 4
5066: PUSH
5067: LD_INT 3
5069: PLUS
5070: ST_TO_ADDR
5071: GO 5087
// dir := dir - 3 ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 3
5085: MINUS
5086: ST_TO_ADDR
// SetDir ( un , dir ) ;
5087: LD_VAR 0 1
5091: PPUSH
5092: LD_VAR 0 4
5096: PPUSH
5097: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5101: LD_VAR 0 1
5105: PPUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: CALL_OW 52
// end ;
5115: LD_VAR 0 3
5119: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5125: LD_ADDR_VAR 0 7
5129: PUSH
5130: LD_VAR 0 1
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_VAR 0 3
5145: PPUSH
5146: LD_VAR 0 4
5150: PPUSH
5151: CALL_OW 1
5155: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_VAR 0 2
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 1
5180: ST_TO_ADDR
// result := tab ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_VAR 0 1
5190: ST_TO_ADDR
// end ;
5191: LD_VAR 0 5
5195: RET
// export function IsDriver ( unit ) ; begin
5196: LD_INT 0
5198: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5199: LD_VAR 0 1
5203: PUSH
5204: LD_INT 55
5206: PUSH
5207: EMPTY
5208: LIST
5209: PPUSH
5210: CALL_OW 69
5214: IN
5215: IFFALSE 5234
// result := IsInUnit ( unit ) else
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: CALL_OW 310
5231: ST_TO_ADDR
5232: GO 5242
// result := false ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: LD_INT 0
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 2
5246: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5247: LD_INT 0
5249: PPUSH
5250: PPUSH
5251: PPUSH
// if not GetControl ( veh ) = control_manual then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 263
5261: PUSH
5262: LD_INT 1
5264: EQUAL
5265: NOT
5266: IFFALSE 5278
// result := false else
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
5276: GO 5423
// if veh in FilterAllUnits ( [ f_empty ] ) then
5278: LD_VAR 0 1
5282: PUSH
5283: LD_INT 58
5285: PUSH
5286: EMPTY
5287: LIST
5288: PPUSH
5289: CALL_OW 69
5293: IN
5294: IFFALSE 5306
// result := false else
5296: LD_ADDR_VAR 0 2
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
5304: GO 5423
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5306: LD_ADDR_VAR 0 4
5310: PUSH
5311: LD_INT 22
5313: PUSH
5314: LD_VAR 0 1
5318: PPUSH
5319: CALL_OW 255
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 55
5330: PUSH
5331: EMPTY
5332: LIST
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if not filter then
5343: LD_VAR 0 4
5347: NOT
5348: IFFALSE 5360
// result := false else
5350: LD_ADDR_VAR 0 2
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
5358: GO 5423
// for i = 1 to filter do
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_VAR 0 4
5374: PUSH
5375: FOR_TO
5376: IFFALSE 5421
// if IsDriver ( filter [ i ] ) = veh then
5378: LD_VAR 0 4
5382: PUSH
5383: LD_VAR 0 3
5387: ARRAY
5388: PPUSH
5389: CALL 5196 0 1
5393: PUSH
5394: LD_VAR 0 1
5398: EQUAL
5399: IFFALSE 5419
// begin result := filter [ i ] ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: LD_VAR 0 3
5415: ARRAY
5416: ST_TO_ADDR
// break ;
5417: GO 5421
// end ;
5419: GO 5375
5421: POP
5422: POP
// end ; end ; end_of_file
5423: LD_VAR 0 2
5427: RET
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
5428: LD_VAR 0 1
5432: PPUSH
5433: CALL 17864 0 1
// if un in [ legion_commander , main_base ] then
5437: LD_VAR 0 1
5441: PUSH
5442: LD_EXP 1
5446: PUSH
5447: LD_INT 23
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: IN
5454: IFFALSE 5464
// game_over := true ;
5456: LD_ADDR_EXP 7
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// if un = al_commander then
5464: LD_VAR 0 1
5468: PUSH
5469: LD_EXP 5
5473: EQUAL
5474: IFFALSE 5480
// ChangeSide ( ) ;
5476: CALL 2689 0 0
// if GetSide ( un ) = 7 then
5480: LD_VAR 0 1
5484: PPUSH
5485: CALL_OW 255
5489: PUSH
5490: LD_INT 7
5492: EQUAL
5493: IFFALSE 5611
// begin if GetClass ( un ) = class_apeman then
5495: LD_VAR 0 1
5499: PPUSH
5500: CALL_OW 257
5504: PUSH
5505: LD_INT 12
5507: EQUAL
5508: IFFALSE 5524
// points := points + 6 ;
5510: LD_ADDR_EXP 8
5514: PUSH
5515: LD_EXP 8
5519: PUSH
5520: LD_INT 6
5522: PLUS
5523: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5524: LD_VAR 0 1
5528: PPUSH
5529: CALL_OW 257
5533: PUSH
5534: LD_INT 17
5536: EQUAL
5537: IFFALSE 5553
// points := points + 11 ;
5539: LD_ADDR_EXP 8
5543: PUSH
5544: LD_EXP 8
5548: PUSH
5549: LD_INT 11
5551: PLUS
5552: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5553: LD_VAR 0 1
5557: PPUSH
5558: CALL_OW 257
5562: PUSH
5563: LD_INT 15
5565: EQUAL
5566: IFFALSE 5582
// points := points + 14 ;
5568: LD_ADDR_EXP 8
5572: PUSH
5573: LD_EXP 8
5577: PUSH
5578: LD_INT 14
5580: PLUS
5581: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5582: LD_VAR 0 1
5586: PPUSH
5587: CALL_OW 247
5591: PUSH
5592: LD_INT 2
5594: EQUAL
5595: IFFALSE 5611
// points := points + 50 ;
5597: LD_ADDR_EXP 8
5601: PUSH
5602: LD_EXP 8
5606: PUSH
5607: LD_INT 50
5609: PLUS
5610: ST_TO_ADDR
// end ; end ;
5611: PPOPN 1
5613: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5614: LD_EXP 5
5618: PPUSH
5619: CALL_OW 256
5623: PUSH
5624: LD_INT 1000
5626: LESS
5627: IFFALSE 5659
5629: GO 5631
5631: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5632: LD_EXP 5
5636: PPUSH
5637: CALL_OW 504
5641: PPUSH
5642: CALL_OW 255
5646: PUSH
5647: LD_INT 8
5649: EQUAL
5650: IFFALSE 5659
// YouLost (  ) ;
5652: LD_STRING 
5654: PPUSH
5655: CALL_OW 104
5659: END
// on DialogueSkipped ( value ) do var i ;
5660: LD_INT 0
5662: PPUSH
// begin RemoveUnit ( potter ) ;
5663: LD_EXP 4
5667: PPUSH
5668: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5672: LD_EXP 2
5676: PUSH
5677: LD_EXP 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PPUSH
5686: CALL_OW 122
// Wait ( 1 ) ;
5690: LD_INT 1
5692: PPUSH
5693: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5697: LD_EXP 2
5701: PPUSH
5702: LD_INT 107
5704: PPUSH
5705: LD_INT 53
5707: PPUSH
5708: LD_INT 0
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5718: LD_EXP 3
5722: PPUSH
5723: LD_INT 108
5725: PPUSH
5726: LD_INT 53
5728: PPUSH
5729: LD_INT 0
5731: PPUSH
5732: LD_INT 0
5734: PPUSH
5735: CALL_OW 483
// Wait ( 1 ) ;
5739: LD_INT 1
5741: PPUSH
5742: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5746: LD_EXP 2
5750: PUSH
5751: LD_EXP 3
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PPUSH
5760: LD_INT 108
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 118
// end ;
5770: PPOPN 2
5772: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5773: LD_INT 0
5775: PPUSH
5776: PPUSH
5777: PPUSH
5778: PPUSH
5779: PPUSH
5780: PPUSH
// begin DialogueOn ;
5781: CALL_OW 6
// uc_side := 8 ;
5785: LD_ADDR_OWVAR 20
5789: PUSH
5790: LD_INT 8
5792: ST_TO_ADDR
// uc_nation := 2 ;
5793: LD_ADDR_OWVAR 21
5797: PUSH
5798: LD_INT 2
5800: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5801: LD_ADDR_VAR 0 5
5805: PUSH
5806: LD_STRING QBonus
5808: PUSH
5809: LD_EXP 12
5813: STR
5814: ST_TO_ADDR
// off := true ;
5815: LD_ADDR_VAR 0 6
5819: PUSH
5820: LD_INT 1
5822: ST_TO_ADDR
// units := [ ] ;
5823: LD_ADDR_VAR 0 7
5827: PUSH
5828: EMPTY
5829: ST_TO_ADDR
// crates := 0 ;
5830: LD_ADDR_VAR 0 8
5834: PUSH
5835: LD_INT 0
5837: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5838: LD_EXP 10
5842: PPUSH
5843: LD_STRING DVr-2
5845: PPUSH
5846: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5850: LD_INT 10
5852: PPUSH
5853: CALL_OW 67
// case Query ( bonus ) of 1 :
5857: LD_VAR 0 5
5861: PPUSH
5862: CALL_OW 97
5866: PUSH
5867: LD_INT 1
5869: DOUBLE
5870: EQUAL
5871: IFTRUE 5875
5873: GO 5960
5875: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5876: LD_ADDR_VAR 0 9
5880: PUSH
5881: LD_INT 1
5883: PUSH
5884: LD_INT 2
5886: PUSH
5887: LD_INT 5
5889: PUSH
5890: LD_INT 8
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_EXP 12
5903: ARRAY
5904: ST_TO_ADDR
// for i = 1 to tmp do
5905: LD_ADDR_VAR 0 10
5909: PUSH
5910: DOUBLE
5911: LD_INT 1
5913: DEC
5914: ST_TO_ADDR
5915: LD_VAR 0 9
5919: PUSH
5920: FOR_TO
5921: IFFALSE 5956
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 15
5928: PPUSH
5929: LD_VAR 0 9
5933: PPUSH
5934: CALL_OW 380
// units := units ^ CreateHuman ;
5938: LD_ADDR_VAR 0 7
5942: PUSH
5943: LD_VAR 0 7
5947: PUSH
5948: CALL_OW 44
5952: ADD
5953: ST_TO_ADDR
// end ;
5954: GO 5920
5956: POP
5957: POP
// end ; 2 :
5958: GO 6368
5960: LD_INT 2
5962: DOUBLE
5963: EQUAL
5964: IFTRUE 5968
5966: GO 6000
5968: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
5969: LD_ADDR_VAR 0 8
5973: PUSH
5974: LD_INT 100
5976: PUSH
5977: LD_INT 150
5979: PUSH
5980: LD_INT 350
5982: PUSH
5983: LD_INT 500
5985: PUSH
5986: EMPTY
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: PUSH
5992: LD_EXP 12
5996: ARRAY
5997: ST_TO_ADDR
// end ; 3 :
5998: GO 6368
6000: LD_INT 3
6002: DOUBLE
6003: EQUAL
6004: IFTRUE 6008
6006: GO 6348
6008: POP
// begin if bonus_num = 1 then
6009: LD_EXP 12
6013: PUSH
6014: LD_INT 1
6016: EQUAL
6017: IFFALSE 6027
// ignore_wave := true ;
6019: LD_ADDR_EXP 13
6023: PUSH
6024: LD_INT 1
6026: ST_TO_ADDR
// if bonus_num = 2 then
6027: LD_EXP 12
6031: PUSH
6032: LD_INT 2
6034: EQUAL
6035: IFFALSE 6155
// begin for i = 1 to 2 do
6037: LD_ADDR_VAR 0 10
6041: PUSH
6042: DOUBLE
6043: LD_INT 1
6045: DEC
6046: ST_TO_ADDR
6047: LD_INT 2
6049: PUSH
6050: FOR_TO
6051: IFFALSE 6153
// begin uc_nation := nation_arabian ;
6053: LD_ADDR_OWVAR 21
6057: PUSH
6058: LD_INT 2
6060: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6061: LD_ADDR_OWVAR 37
6065: PUSH
6066: LD_INT 14
6068: ST_TO_ADDR
// vc_engine := engine_siberite ;
6069: LD_ADDR_OWVAR 39
6073: PUSH
6074: LD_INT 3
6076: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6077: LD_ADDR_OWVAR 38
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 5
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 1
6094: PPUSH
6095: LD_INT 2
6097: PPUSH
6098: CALL_OW 12
6102: ARRAY
6103: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6104: LD_ADDR_OWVAR 40
6108: PUSH
6109: LD_INT 28
6111: PUSH
6112: LD_INT 27
6114: PUSH
6115: LD_INT 25
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: LIST
6122: PUSH
6123: LD_INT 1
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 12
6133: ARRAY
6134: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6135: LD_ADDR_VAR 0 7
6139: PUSH
6140: LD_VAR 0 7
6144: PUSH
6145: CALL_OW 45
6149: ADD
6150: ST_TO_ADDR
// end ;
6151: GO 6050
6153: POP
6154: POP
// end ; if bonus_num = 3 then
6155: LD_EXP 12
6159: PUSH
6160: LD_INT 3
6162: EQUAL
6163: IFFALSE 6287
// begin for i = 1 to 4 do
6165: LD_ADDR_VAR 0 10
6169: PUSH
6170: DOUBLE
6171: LD_INT 1
6173: DEC
6174: ST_TO_ADDR
6175: LD_INT 4
6177: PUSH
6178: FOR_TO
6179: IFFALSE 6285
// begin uc_nation := nation_arabian ;
6181: LD_ADDR_OWVAR 21
6185: PUSH
6186: LD_INT 2
6188: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6189: LD_ADDR_OWVAR 37
6193: PUSH
6194: LD_INT 14
6196: ST_TO_ADDR
// vc_engine := engine_siberite ;
6197: LD_ADDR_OWVAR 39
6201: PUSH
6202: LD_INT 3
6204: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6205: LD_ADDR_OWVAR 38
6209: PUSH
6210: LD_INT 2
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 1
6222: PPUSH
6223: LD_INT 2
6225: PPUSH
6226: CALL_OW 12
6230: ARRAY
6231: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6232: LD_ADDR_OWVAR 40
6236: PUSH
6237: LD_INT 28
6239: PUSH
6240: LD_INT 27
6242: PUSH
6243: LD_INT 28
6245: PUSH
6246: LD_INT 25
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 1
6257: PPUSH
6258: LD_INT 4
6260: PPUSH
6261: CALL_OW 12
6265: ARRAY
6266: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6267: LD_ADDR_VAR 0 7
6271: PUSH
6272: LD_VAR 0 7
6276: PUSH
6277: CALL_OW 45
6281: ADD
6282: ST_TO_ADDR
// end ;
6283: GO 6178
6285: POP
6286: POP
// end ; if bonus_num = 4 then
6287: LD_EXP 12
6291: PUSH
6292: LD_INT 4
6294: EQUAL
6295: IFFALSE 6346
// for i = 1 to 3 do
6297: LD_ADDR_VAR 0 10
6301: PUSH
6302: DOUBLE
6303: LD_INT 1
6305: DEC
6306: ST_TO_ADDR
6307: LD_INT 3
6309: PUSH
6310: FOR_TO
6311: IFFALSE 6344
// begin PrepareHuman ( false , 3 , 8 ) ;
6313: LD_INT 0
6315: PPUSH
6316: LD_INT 3
6318: PPUSH
6319: LD_INT 8
6321: PPUSH
6322: CALL_OW 380
// units := units ^ CreateHuman ;
6326: LD_ADDR_VAR 0 7
6330: PUSH
6331: LD_VAR 0 7
6335: PUSH
6336: CALL_OW 44
6340: ADD
6341: ST_TO_ADDR
// end ;
6342: GO 6310
6344: POP
6345: POP
// end ; 4 :
6346: GO 6368
6348: LD_INT 4
6350: DOUBLE
6351: EQUAL
6352: IFTRUE 6356
6354: GO 6367
6356: POP
// off := false ; end ;
6357: LD_ADDR_VAR 0 6
6361: PUSH
6362: LD_INT 0
6364: ST_TO_ADDR
6365: GO 6368
6367: POP
// DialogueOff ;
6368: CALL_OW 7
// if not off then
6372: LD_VAR 0 6
6376: NOT
6377: IFFALSE 6383
// exit else
6379: GO 6562
6381: GO 6436
// begin SetArtifactUse ( your_side , art_use_exclamation , art_no , main_base ) ;
6383: LD_OWVAR 2
6387: PPUSH
6388: LD_INT 12
6390: PPUSH
6391: LD_INT 0
6393: PPUSH
6394: LD_INT 23
6396: PPUSH
6397: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6401: LD_EXP 10
6405: PPUSH
6406: LD_STRING DVr-3
6408: PUSH
6409: LD_STRING DVr-3a
6411: PUSH
6412: LD_STRING DVr-3b
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 1
6422: PPUSH
6423: LD_INT 3
6425: PPUSH
6426: CALL_OW 12
6430: ARRAY
6431: PPUSH
6432: CALL_OW 94
// end ; if units then
6436: LD_VAR 0 7
6440: IFFALSE 6504
// for i in units do
6442: LD_ADDR_VAR 0 10
6446: PUSH
6447: LD_VAR 0 7
6451: PUSH
6452: FOR_IN
6453: IFFALSE 6502
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6455: LD_VAR 0 10
6459: PPUSH
6460: LD_INT 92
6462: PPUSH
6463: LD_INT 49
6465: PPUSH
6466: LD_INT 20
6468: PPUSH
6469: LD_INT 0
6471: PPUSH
6472: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6476: LD_VAR 0 10
6480: PPUSH
6481: CALL_OW 250
6485: PPUSH
6486: LD_VAR 0 10
6490: PPUSH
6491: CALL_OW 251
6495: PPUSH
6496: CALL_OW 494
// end ;
6500: GO 6452
6502: POP
6503: POP
// if crates then
6504: LD_VAR 0 8
6508: IFFALSE 6562
// for i = 1 to ( crates div 50 ) do
6510: LD_ADDR_VAR 0 10
6514: PUSH
6515: DOUBLE
6516: LD_INT 1
6518: DEC
6519: ST_TO_ADDR
6520: LD_VAR 0 8
6524: PUSH
6525: LD_INT 50
6527: DIV
6528: PUSH
6529: FOR_TO
6530: IFFALSE 6560
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6532: LD_INT 5
6534: PPUSH
6535: LD_INT 92
6537: PPUSH
6538: LD_INT 49
6540: PPUSH
6541: LD_INT 30
6543: PPUSH
6544: LD_INT 1
6546: PPUSH
6547: CALL_OW 56
// wait ( 0 0$02 ) ;
6551: LD_INT 70
6553: PPUSH
6554: CALL_OW 67
// end ;
6558: GO 6529
6560: POP
6561: POP
// end ;
6562: PPOPN 10
6564: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6565: LD_VAR 0 1
6569: PPUSH
6570: LD_VAR 0 2
6574: PPUSH
6575: LD_VAR 0 3
6579: PPUSH
6580: CALL 17962 0 3
// end ;
6584: PPOPN 3
6586: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: CALL 17970 0 1
// end ; end_of_file
6596: PPOPN 1
6598: END
// every 0 0$01 trigger not game_over do
6599: LD_EXP 7
6603: NOT
6604: IFFALSE 6637
6606: GO 6608
6608: DISABLE
// begin enable ;
6609: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6610: LD_ADDR_OWVAR 47
6614: PUSH
6615: LD_STRING #tick
6617: PUSH
6618: LD_OWVAR 1
6622: PUSH
6623: LD_STRING #points
6625: PUSH
6626: LD_EXP 8
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: ST_TO_ADDR
// end ;
6637: END
// every 0 0$01 trigger game_over do
6638: LD_EXP 7
6642: IFFALSE 6701
6644: GO 6646
6646: DISABLE
// begin Wait ( 0 0$02 ) ;
6647: LD_INT 70
6649: PPUSH
6650: CALL_OW 67
// DialogueOn ;
6654: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6658: LD_ADDR_OWVAR 47
6662: PUSH
6663: LD_STRING #game-points
6665: PUSH
6666: LD_OWVAR 78
6670: PUSH
6671: LD_EXP 8
6675: PUSH
6676: LD_STRING #game-time
6678: PUSH
6679: LD_OWVAR 1
6683: PUSH
6684: LD_STRING #game-difficulty
6686: PUSH
6687: LD_OWVAR 67
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// end ; end_of_file
6701: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6702: LD_OWVAR 1
6706: PUSH
6707: LD_INT 52500
6709: LESS
6710: IFFALSE 6734
6712: GO 6714
6714: DISABLE
// begin enable ;
6715: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 5
6721: PPUSH
6722: CALL_OW 12
6726: PPUSH
6727: LD_INT 1
6729: PPUSH
6730: CALL_OW 57
// end ; end_of_file
6734: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
6735: GO 6737
6737: DISABLE
// begin ru_radar := 98 ;
6738: LD_ADDR_EXP 14
6742: PUSH
6743: LD_INT 98
6745: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
6746: LD_ADDR_EXP 15
6750: PUSH
6751: LD_INT 89
6753: ST_TO_ADDR
// us_hack := 99 ;
6754: LD_ADDR_EXP 16
6758: PUSH
6759: LD_INT 99
6761: ST_TO_ADDR
// us_artillery := 97 ;
6762: LD_ADDR_EXP 17
6766: PUSH
6767: LD_INT 97
6769: ST_TO_ADDR
// ar_bio_bomb := 91 ;
6770: LD_ADDR_EXP 18
6774: PUSH
6775: LD_INT 91
6777: ST_TO_ADDR
// tech_Artillery := 80 ;
6778: LD_ADDR_EXP 19
6782: PUSH
6783: LD_INT 80
6785: ST_TO_ADDR
// tech_RadMat := 81 ;
6786: LD_ADDR_EXP 20
6790: PUSH
6791: LD_INT 81
6793: ST_TO_ADDR
// tech_BasicTools := 82 ;
6794: LD_ADDR_EXP 21
6798: PUSH
6799: LD_INT 82
6801: ST_TO_ADDR
// tech_Cargo := 83 ;
6802: LD_ADDR_EXP 22
6806: PUSH
6807: LD_INT 83
6809: ST_TO_ADDR
// tech_Track := 84 ;
6810: LD_ADDR_EXP 23
6814: PUSH
6815: LD_INT 84
6817: ST_TO_ADDR
// tech_Crane := 85 ;
6818: LD_ADDR_EXP 24
6822: PUSH
6823: LD_INT 85
6825: ST_TO_ADDR
// tech_Bulldozer := 86 ;
6826: LD_ADDR_EXP 25
6830: PUSH
6831: LD_INT 86
6833: ST_TO_ADDR
// tech_Hovercraft := 87 ;
6834: LD_ADDR_EXP 26
6838: PUSH
6839: LD_INT 87
6841: ST_TO_ADDR
// end ; end_of_file end_of_file
6842: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6843: GO 6845
6845: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6846: LD_STRING initStreamRollete();
6848: PPUSH
6849: CALL_OW 559
// InitStreamMode ;
6853: CALL 6862 0 0
// DefineStreamItems ( ) ;
6857: CALL 7302 0 0
// end ;
6861: END
// function InitStreamMode ; begin
6862: LD_INT 0
6864: PPUSH
// streamModeActive := false ;
6865: LD_ADDR_EXP 27
6869: PUSH
6870: LD_INT 0
6872: ST_TO_ADDR
// normalCounter := 36 ;
6873: LD_ADDR_EXP 28
6877: PUSH
6878: LD_INT 36
6880: ST_TO_ADDR
// hardcoreCounter := 16 ;
6881: LD_ADDR_EXP 29
6885: PUSH
6886: LD_INT 16
6888: ST_TO_ADDR
// sRocket := false ;
6889: LD_ADDR_EXP 32
6893: PUSH
6894: LD_INT 0
6896: ST_TO_ADDR
// sSpeed := false ;
6897: LD_ADDR_EXP 31
6901: PUSH
6902: LD_INT 0
6904: ST_TO_ADDR
// sEngine := false ;
6905: LD_ADDR_EXP 33
6909: PUSH
6910: LD_INT 0
6912: ST_TO_ADDR
// sSpec := false ;
6913: LD_ADDR_EXP 30
6917: PUSH
6918: LD_INT 0
6920: ST_TO_ADDR
// sLevel := false ;
6921: LD_ADDR_EXP 34
6925: PUSH
6926: LD_INT 0
6928: ST_TO_ADDR
// sArmoury := false ;
6929: LD_ADDR_EXP 35
6933: PUSH
6934: LD_INT 0
6936: ST_TO_ADDR
// sRadar := false ;
6937: LD_ADDR_EXP 36
6941: PUSH
6942: LD_INT 0
6944: ST_TO_ADDR
// sBunker := false ;
6945: LD_ADDR_EXP 37
6949: PUSH
6950: LD_INT 0
6952: ST_TO_ADDR
// sHack := false ;
6953: LD_ADDR_EXP 38
6957: PUSH
6958: LD_INT 0
6960: ST_TO_ADDR
// sFire := false ;
6961: LD_ADDR_EXP 39
6965: PUSH
6966: LD_INT 0
6968: ST_TO_ADDR
// sRefresh := false ;
6969: LD_ADDR_EXP 40
6973: PUSH
6974: LD_INT 0
6976: ST_TO_ADDR
// sExp := false ;
6977: LD_ADDR_EXP 41
6981: PUSH
6982: LD_INT 0
6984: ST_TO_ADDR
// sDepot := false ;
6985: LD_ADDR_EXP 42
6989: PUSH
6990: LD_INT 0
6992: ST_TO_ADDR
// sFlag := false ;
6993: LD_ADDR_EXP 43
6997: PUSH
6998: LD_INT 0
7000: ST_TO_ADDR
// sKamikadze := false ;
7001: LD_ADDR_EXP 51
7005: PUSH
7006: LD_INT 0
7008: ST_TO_ADDR
// sTroll := false ;
7009: LD_ADDR_EXP 52
7013: PUSH
7014: LD_INT 0
7016: ST_TO_ADDR
// sSlow := false ;
7017: LD_ADDR_EXP 53
7021: PUSH
7022: LD_INT 0
7024: ST_TO_ADDR
// sLack := false ;
7025: LD_ADDR_EXP 54
7029: PUSH
7030: LD_INT 0
7032: ST_TO_ADDR
// sTank := false ;
7033: LD_ADDR_EXP 56
7037: PUSH
7038: LD_INT 0
7040: ST_TO_ADDR
// sRemote := false ;
7041: LD_ADDR_EXP 57
7045: PUSH
7046: LD_INT 0
7048: ST_TO_ADDR
// sPowell := false ;
7049: LD_ADDR_EXP 58
7053: PUSH
7054: LD_INT 0
7056: ST_TO_ADDR
// sTeleport := false ;
7057: LD_ADDR_EXP 61
7061: PUSH
7062: LD_INT 0
7064: ST_TO_ADDR
// sOilTower := false ;
7065: LD_ADDR_EXP 63
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// sShovel := false ;
7073: LD_ADDR_EXP 64
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// sSheik := false ;
7081: LD_ADDR_EXP 65
7085: PUSH
7086: LD_INT 0
7088: ST_TO_ADDR
// sEarthquake := false ;
7089: LD_ADDR_EXP 67
7093: PUSH
7094: LD_INT 0
7096: ST_TO_ADDR
// sAI := false ;
7097: LD_ADDR_EXP 68
7101: PUSH
7102: LD_INT 0
7104: ST_TO_ADDR
// sCargo := false ;
7105: LD_ADDR_EXP 71
7109: PUSH
7110: LD_INT 0
7112: ST_TO_ADDR
// sDLaser := false ;
7113: LD_ADDR_EXP 72
7117: PUSH
7118: LD_INT 0
7120: ST_TO_ADDR
// sExchange := false ;
7121: LD_ADDR_EXP 73
7125: PUSH
7126: LD_INT 0
7128: ST_TO_ADDR
// sFac := false ;
7129: LD_ADDR_EXP 74
7133: PUSH
7134: LD_INT 0
7136: ST_TO_ADDR
// sPower := false ;
7137: LD_ADDR_EXP 75
7141: PUSH
7142: LD_INT 0
7144: ST_TO_ADDR
// sRandom := false ;
7145: LD_ADDR_EXP 76
7149: PUSH
7150: LD_INT 0
7152: ST_TO_ADDR
// sShield := false ;
7153: LD_ADDR_EXP 77
7157: PUSH
7158: LD_INT 0
7160: ST_TO_ADDR
// sTime := false ;
7161: LD_ADDR_EXP 78
7165: PUSH
7166: LD_INT 0
7168: ST_TO_ADDR
// sTools := false ;
7169: LD_ADDR_EXP 79
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// sSold := false ;
7177: LD_ADDR_EXP 44
7181: PUSH
7182: LD_INT 0
7184: ST_TO_ADDR
// sDiff := false ;
7185: LD_ADDR_EXP 45
7189: PUSH
7190: LD_INT 0
7192: ST_TO_ADDR
// sFog := false ;
7193: LD_ADDR_EXP 48
7197: PUSH
7198: LD_INT 0
7200: ST_TO_ADDR
// sReset := false ;
7201: LD_ADDR_EXP 49
7205: PUSH
7206: LD_INT 0
7208: ST_TO_ADDR
// sSun := false ;
7209: LD_ADDR_EXP 50
7213: PUSH
7214: LD_INT 0
7216: ST_TO_ADDR
// sTiger := false ;
7217: LD_ADDR_EXP 46
7221: PUSH
7222: LD_INT 0
7224: ST_TO_ADDR
// sBomb := false ;
7225: LD_ADDR_EXP 47
7229: PUSH
7230: LD_INT 0
7232: ST_TO_ADDR
// sWound := false ;
7233: LD_ADDR_EXP 55
7237: PUSH
7238: LD_INT 0
7240: ST_TO_ADDR
// sBetray := false ;
7241: LD_ADDR_EXP 59
7245: PUSH
7246: LD_INT 0
7248: ST_TO_ADDR
// sContamin := false ;
7249: LD_ADDR_EXP 60
7253: PUSH
7254: LD_INT 0
7256: ST_TO_ADDR
// sOil := false ;
7257: LD_ADDR_EXP 62
7261: PUSH
7262: LD_INT 0
7264: ST_TO_ADDR
// sStu := false ;
7265: LD_ADDR_EXP 66
7269: PUSH
7270: LD_INT 0
7272: ST_TO_ADDR
// sBazooka := false ;
7273: LD_ADDR_EXP 69
7277: PUSH
7278: LD_INT 0
7280: ST_TO_ADDR
// sMortar := false ;
7281: LD_ADDR_EXP 70
7285: PUSH
7286: LD_INT 0
7288: ST_TO_ADDR
// sRanger := false ;
7289: LD_ADDR_EXP 80
7293: PUSH
7294: LD_INT 0
7296: ST_TO_ADDR
// end ;
7297: LD_VAR 0 1
7301: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
7302: LD_INT 0
7304: PPUSH
7305: PPUSH
7306: PPUSH
7307: PPUSH
7308: PPUSH
// result := [ ] ;
7309: LD_ADDR_VAR 0 1
7313: PUSH
7314: EMPTY
7315: ST_TO_ADDR
// if campaign_id = 1 then
7316: LD_OWVAR 69
7320: PUSH
7321: LD_INT 1
7323: EQUAL
7324: IFFALSE 10262
// begin case mission_number of 1 :
7326: LD_OWVAR 70
7330: PUSH
7331: LD_INT 1
7333: DOUBLE
7334: EQUAL
7335: IFTRUE 7339
7337: GO 7403
7339: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
7340: LD_ADDR_VAR 0 1
7344: PUSH
7345: LD_INT 2
7347: PUSH
7348: LD_INT 4
7350: PUSH
7351: LD_INT 11
7353: PUSH
7354: LD_INT 12
7356: PUSH
7357: LD_INT 15
7359: PUSH
7360: LD_INT 16
7362: PUSH
7363: LD_INT 22
7365: PUSH
7366: LD_INT 23
7368: PUSH
7369: LD_INT 26
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: LIST
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: LIST
7381: LIST
7382: PUSH
7383: LD_INT 101
7385: PUSH
7386: LD_INT 102
7388: PUSH
7389: LD_INT 106
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: PUSH
7397: EMPTY
7398: LIST
7399: LIST
7400: ST_TO_ADDR
7401: GO 10260
7403: LD_INT 2
7405: DOUBLE
7406: EQUAL
7407: IFTRUE 7411
7409: GO 7483
7411: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7412: LD_ADDR_VAR 0 1
7416: PUSH
7417: LD_INT 2
7419: PUSH
7420: LD_INT 4
7422: PUSH
7423: LD_INT 11
7425: PUSH
7426: LD_INT 12
7428: PUSH
7429: LD_INT 15
7431: PUSH
7432: LD_INT 16
7434: PUSH
7435: LD_INT 22
7437: PUSH
7438: LD_INT 23
7440: PUSH
7441: LD_INT 26
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: LIST
7453: LIST
7454: PUSH
7455: LD_INT 101
7457: PUSH
7458: LD_INT 102
7460: PUSH
7461: LD_INT 105
7463: PUSH
7464: LD_INT 106
7466: PUSH
7467: LD_INT 108
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: LIST
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: ST_TO_ADDR
7481: GO 10260
7483: LD_INT 3
7485: DOUBLE
7486: EQUAL
7487: IFTRUE 7491
7489: GO 7567
7491: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7492: LD_ADDR_VAR 0 1
7496: PUSH
7497: LD_INT 2
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: LD_INT 5
7505: PUSH
7506: LD_INT 11
7508: PUSH
7509: LD_INT 12
7511: PUSH
7512: LD_INT 15
7514: PUSH
7515: LD_INT 16
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_INT 26
7523: PUSH
7524: LD_INT 36
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: LIST
7535: LIST
7536: LIST
7537: LIST
7538: PUSH
7539: LD_INT 101
7541: PUSH
7542: LD_INT 102
7544: PUSH
7545: LD_INT 105
7547: PUSH
7548: LD_INT 106
7550: PUSH
7551: LD_INT 108
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: ST_TO_ADDR
7565: GO 10260
7567: LD_INT 4
7569: DOUBLE
7570: EQUAL
7571: IFTRUE 7575
7573: GO 7659
7575: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7576: LD_ADDR_VAR 0 1
7580: PUSH
7581: LD_INT 2
7583: PUSH
7584: LD_INT 4
7586: PUSH
7587: LD_INT 5
7589: PUSH
7590: LD_INT 8
7592: PUSH
7593: LD_INT 11
7595: PUSH
7596: LD_INT 12
7598: PUSH
7599: LD_INT 15
7601: PUSH
7602: LD_INT 16
7604: PUSH
7605: LD_INT 22
7607: PUSH
7608: LD_INT 23
7610: PUSH
7611: LD_INT 26
7613: PUSH
7614: LD_INT 36
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: LIST
7628: LIST
7629: LIST
7630: PUSH
7631: LD_INT 101
7633: PUSH
7634: LD_INT 102
7636: PUSH
7637: LD_INT 105
7639: PUSH
7640: LD_INT 106
7642: PUSH
7643: LD_INT 108
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: ST_TO_ADDR
7657: GO 10260
7659: LD_INT 5
7661: DOUBLE
7662: EQUAL
7663: IFTRUE 7667
7665: GO 7767
7667: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7668: LD_ADDR_VAR 0 1
7672: PUSH
7673: LD_INT 2
7675: PUSH
7676: LD_INT 4
7678: PUSH
7679: LD_INT 5
7681: PUSH
7682: LD_INT 6
7684: PUSH
7685: LD_INT 8
7687: PUSH
7688: LD_INT 11
7690: PUSH
7691: LD_INT 12
7693: PUSH
7694: LD_INT 15
7696: PUSH
7697: LD_INT 16
7699: PUSH
7700: LD_INT 22
7702: PUSH
7703: LD_INT 23
7705: PUSH
7706: LD_INT 25
7708: PUSH
7709: LD_INT 26
7711: PUSH
7712: LD_INT 36
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 101
7733: PUSH
7734: LD_INT 102
7736: PUSH
7737: LD_INT 105
7739: PUSH
7740: LD_INT 106
7742: PUSH
7743: LD_INT 108
7745: PUSH
7746: LD_INT 109
7748: PUSH
7749: LD_INT 112
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: ST_TO_ADDR
7765: GO 10260
7767: LD_INT 6
7769: DOUBLE
7770: EQUAL
7771: IFTRUE 7775
7773: GO 7895
7775: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7776: LD_ADDR_VAR 0 1
7780: PUSH
7781: LD_INT 2
7783: PUSH
7784: LD_INT 4
7786: PUSH
7787: LD_INT 5
7789: PUSH
7790: LD_INT 6
7792: PUSH
7793: LD_INT 8
7795: PUSH
7796: LD_INT 11
7798: PUSH
7799: LD_INT 12
7801: PUSH
7802: LD_INT 15
7804: PUSH
7805: LD_INT 16
7807: PUSH
7808: LD_INT 20
7810: PUSH
7811: LD_INT 21
7813: PUSH
7814: LD_INT 22
7816: PUSH
7817: LD_INT 23
7819: PUSH
7820: LD_INT 25
7822: PUSH
7823: LD_INT 26
7825: PUSH
7826: LD_INT 30
7828: PUSH
7829: LD_INT 31
7831: PUSH
7832: LD_INT 32
7834: PUSH
7835: LD_INT 36
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: PUSH
7859: LD_INT 101
7861: PUSH
7862: LD_INT 102
7864: PUSH
7865: LD_INT 105
7867: PUSH
7868: LD_INT 106
7870: PUSH
7871: LD_INT 108
7873: PUSH
7874: LD_INT 109
7876: PUSH
7877: LD_INT 112
7879: PUSH
7880: EMPTY
7881: LIST
7882: LIST
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: ST_TO_ADDR
7893: GO 10260
7895: LD_INT 7
7897: DOUBLE
7898: EQUAL
7899: IFTRUE 7903
7901: GO 8003
7903: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: LD_INT 2
7911: PUSH
7912: LD_INT 4
7914: PUSH
7915: LD_INT 5
7917: PUSH
7918: LD_INT 7
7920: PUSH
7921: LD_INT 11
7923: PUSH
7924: LD_INT 12
7926: PUSH
7927: LD_INT 15
7929: PUSH
7930: LD_INT 16
7932: PUSH
7933: LD_INT 20
7935: PUSH
7936: LD_INT 21
7938: PUSH
7939: LD_INT 22
7941: PUSH
7942: LD_INT 23
7944: PUSH
7945: LD_INT 25
7947: PUSH
7948: LD_INT 26
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_INT 101
7969: PUSH
7970: LD_INT 102
7972: PUSH
7973: LD_INT 103
7975: PUSH
7976: LD_INT 105
7978: PUSH
7979: LD_INT 106
7981: PUSH
7982: LD_INT 108
7984: PUSH
7985: LD_INT 112
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: LIST
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: ST_TO_ADDR
8001: GO 10260
8003: LD_INT 8
8005: DOUBLE
8006: EQUAL
8007: IFTRUE 8011
8009: GO 8139
8011: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
8012: LD_ADDR_VAR 0 1
8016: PUSH
8017: LD_INT 2
8019: PUSH
8020: LD_INT 4
8022: PUSH
8023: LD_INT 5
8025: PUSH
8026: LD_INT 6
8028: PUSH
8029: LD_INT 7
8031: PUSH
8032: LD_INT 8
8034: PUSH
8035: LD_INT 11
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 15
8043: PUSH
8044: LD_INT 16
8046: PUSH
8047: LD_INT 20
8049: PUSH
8050: LD_INT 21
8052: PUSH
8053: LD_INT 22
8055: PUSH
8056: LD_INT 23
8058: PUSH
8059: LD_INT 25
8061: PUSH
8062: LD_INT 26
8064: PUSH
8065: LD_INT 30
8067: PUSH
8068: LD_INT 31
8070: PUSH
8071: LD_INT 32
8073: PUSH
8074: LD_INT 36
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: LIST
8081: LIST
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: LIST
8087: LIST
8088: LIST
8089: LIST
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 101
8101: PUSH
8102: LD_INT 102
8104: PUSH
8105: LD_INT 103
8107: PUSH
8108: LD_INT 105
8110: PUSH
8111: LD_INT 106
8113: PUSH
8114: LD_INT 108
8116: PUSH
8117: LD_INT 109
8119: PUSH
8120: LD_INT 112
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: LIST
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: EMPTY
8134: LIST
8135: LIST
8136: ST_TO_ADDR
8137: GO 10260
8139: LD_INT 9
8141: DOUBLE
8142: EQUAL
8143: IFTRUE 8147
8145: GO 8283
8147: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
8148: LD_ADDR_VAR 0 1
8152: PUSH
8153: LD_INT 2
8155: PUSH
8156: LD_INT 4
8158: PUSH
8159: LD_INT 5
8161: PUSH
8162: LD_INT 6
8164: PUSH
8165: LD_INT 7
8167: PUSH
8168: LD_INT 8
8170: PUSH
8171: LD_INT 11
8173: PUSH
8174: LD_INT 12
8176: PUSH
8177: LD_INT 15
8179: PUSH
8180: LD_INT 16
8182: PUSH
8183: LD_INT 20
8185: PUSH
8186: LD_INT 21
8188: PUSH
8189: LD_INT 22
8191: PUSH
8192: LD_INT 23
8194: PUSH
8195: LD_INT 25
8197: PUSH
8198: LD_INT 26
8200: PUSH
8201: LD_INT 28
8203: PUSH
8204: LD_INT 30
8206: PUSH
8207: LD_INT 31
8209: PUSH
8210: LD_INT 32
8212: PUSH
8213: LD_INT 36
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: PUSH
8239: LD_INT 101
8241: PUSH
8242: LD_INT 102
8244: PUSH
8245: LD_INT 103
8247: PUSH
8248: LD_INT 105
8250: PUSH
8251: LD_INT 106
8253: PUSH
8254: LD_INT 108
8256: PUSH
8257: LD_INT 109
8259: PUSH
8260: LD_INT 112
8262: PUSH
8263: LD_INT 114
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: ST_TO_ADDR
8281: GO 10260
8283: LD_INT 10
8285: DOUBLE
8286: EQUAL
8287: IFTRUE 8291
8289: GO 8475
8291: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_INT 2
8299: PUSH
8300: LD_INT 4
8302: PUSH
8303: LD_INT 5
8305: PUSH
8306: LD_INT 6
8308: PUSH
8309: LD_INT 7
8311: PUSH
8312: LD_INT 8
8314: PUSH
8315: LD_INT 9
8317: PUSH
8318: LD_INT 10
8320: PUSH
8321: LD_INT 11
8323: PUSH
8324: LD_INT 12
8326: PUSH
8327: LD_INT 13
8329: PUSH
8330: LD_INT 14
8332: PUSH
8333: LD_INT 15
8335: PUSH
8336: LD_INT 16
8338: PUSH
8339: LD_INT 17
8341: PUSH
8342: LD_INT 18
8344: PUSH
8345: LD_INT 19
8347: PUSH
8348: LD_INT 20
8350: PUSH
8351: LD_INT 21
8353: PUSH
8354: LD_INT 22
8356: PUSH
8357: LD_INT 23
8359: PUSH
8360: LD_INT 24
8362: PUSH
8363: LD_INT 25
8365: PUSH
8366: LD_INT 26
8368: PUSH
8369: LD_INT 28
8371: PUSH
8372: LD_INT 30
8374: PUSH
8375: LD_INT 31
8377: PUSH
8378: LD_INT 32
8380: PUSH
8381: LD_INT 36
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: LIST
8388: LIST
8389: LIST
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: LIST
8406: LIST
8407: LIST
8408: LIST
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: LIST
8414: PUSH
8415: LD_INT 101
8417: PUSH
8418: LD_INT 102
8420: PUSH
8421: LD_INT 103
8423: PUSH
8424: LD_INT 104
8426: PUSH
8427: LD_INT 105
8429: PUSH
8430: LD_INT 106
8432: PUSH
8433: LD_INT 107
8435: PUSH
8436: LD_INT 108
8438: PUSH
8439: LD_INT 109
8441: PUSH
8442: LD_INT 110
8444: PUSH
8445: LD_INT 111
8447: PUSH
8448: LD_INT 112
8450: PUSH
8451: LD_INT 114
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: LIST
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: ST_TO_ADDR
8473: GO 10260
8475: LD_INT 11
8477: DOUBLE
8478: EQUAL
8479: IFTRUE 8483
8481: GO 8675
8483: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8484: LD_ADDR_VAR 0 1
8488: PUSH
8489: LD_INT 2
8491: PUSH
8492: LD_INT 3
8494: PUSH
8495: LD_INT 4
8497: PUSH
8498: LD_INT 5
8500: PUSH
8501: LD_INT 6
8503: PUSH
8504: LD_INT 7
8506: PUSH
8507: LD_INT 8
8509: PUSH
8510: LD_INT 9
8512: PUSH
8513: LD_INT 10
8515: PUSH
8516: LD_INT 11
8518: PUSH
8519: LD_INT 12
8521: PUSH
8522: LD_INT 13
8524: PUSH
8525: LD_INT 14
8527: PUSH
8528: LD_INT 15
8530: PUSH
8531: LD_INT 16
8533: PUSH
8534: LD_INT 17
8536: PUSH
8537: LD_INT 18
8539: PUSH
8540: LD_INT 19
8542: PUSH
8543: LD_INT 20
8545: PUSH
8546: LD_INT 21
8548: PUSH
8549: LD_INT 22
8551: PUSH
8552: LD_INT 23
8554: PUSH
8555: LD_INT 24
8557: PUSH
8558: LD_INT 25
8560: PUSH
8561: LD_INT 26
8563: PUSH
8564: LD_INT 28
8566: PUSH
8567: LD_INT 30
8569: PUSH
8570: LD_INT 31
8572: PUSH
8573: LD_INT 32
8575: PUSH
8576: LD_INT 34
8578: PUSH
8579: LD_INT 36
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: LIST
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: LIST
8612: LIST
8613: LIST
8614: PUSH
8615: LD_INT 101
8617: PUSH
8618: LD_INT 102
8620: PUSH
8621: LD_INT 103
8623: PUSH
8624: LD_INT 104
8626: PUSH
8627: LD_INT 105
8629: PUSH
8630: LD_INT 106
8632: PUSH
8633: LD_INT 107
8635: PUSH
8636: LD_INT 108
8638: PUSH
8639: LD_INT 109
8641: PUSH
8642: LD_INT 110
8644: PUSH
8645: LD_INT 111
8647: PUSH
8648: LD_INT 112
8650: PUSH
8651: LD_INT 114
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: LIST
8666: LIST
8667: LIST
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: ST_TO_ADDR
8673: GO 10260
8675: LD_INT 12
8677: DOUBLE
8678: EQUAL
8679: IFTRUE 8683
8681: GO 8891
8683: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8684: LD_ADDR_VAR 0 1
8688: PUSH
8689: LD_INT 1
8691: PUSH
8692: LD_INT 2
8694: PUSH
8695: LD_INT 3
8697: PUSH
8698: LD_INT 4
8700: PUSH
8701: LD_INT 5
8703: PUSH
8704: LD_INT 6
8706: PUSH
8707: LD_INT 7
8709: PUSH
8710: LD_INT 8
8712: PUSH
8713: LD_INT 9
8715: PUSH
8716: LD_INT 10
8718: PUSH
8719: LD_INT 11
8721: PUSH
8722: LD_INT 12
8724: PUSH
8725: LD_INT 13
8727: PUSH
8728: LD_INT 14
8730: PUSH
8731: LD_INT 15
8733: PUSH
8734: LD_INT 16
8736: PUSH
8737: LD_INT 17
8739: PUSH
8740: LD_INT 18
8742: PUSH
8743: LD_INT 19
8745: PUSH
8746: LD_INT 20
8748: PUSH
8749: LD_INT 21
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_INT 23
8757: PUSH
8758: LD_INT 24
8760: PUSH
8761: LD_INT 25
8763: PUSH
8764: LD_INT 26
8766: PUSH
8767: LD_INT 27
8769: PUSH
8770: LD_INT 28
8772: PUSH
8773: LD_INT 30
8775: PUSH
8776: LD_INT 31
8778: PUSH
8779: LD_INT 32
8781: PUSH
8782: LD_INT 33
8784: PUSH
8785: LD_INT 34
8787: PUSH
8788: LD_INT 36
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: LIST
8795: LIST
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 101
8829: PUSH
8830: LD_INT 102
8832: PUSH
8833: LD_INT 103
8835: PUSH
8836: LD_INT 104
8838: PUSH
8839: LD_INT 105
8841: PUSH
8842: LD_INT 106
8844: PUSH
8845: LD_INT 107
8847: PUSH
8848: LD_INT 108
8850: PUSH
8851: LD_INT 109
8853: PUSH
8854: LD_INT 110
8856: PUSH
8857: LD_INT 111
8859: PUSH
8860: LD_INT 112
8862: PUSH
8863: LD_INT 113
8865: PUSH
8866: LD_INT 114
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: ST_TO_ADDR
8889: GO 10260
8891: LD_INT 13
8893: DOUBLE
8894: EQUAL
8895: IFTRUE 8899
8897: GO 9095
8899: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8900: LD_ADDR_VAR 0 1
8904: PUSH
8905: LD_INT 1
8907: PUSH
8908: LD_INT 2
8910: PUSH
8911: LD_INT 3
8913: PUSH
8914: LD_INT 4
8916: PUSH
8917: LD_INT 5
8919: PUSH
8920: LD_INT 8
8922: PUSH
8923: LD_INT 9
8925: PUSH
8926: LD_INT 10
8928: PUSH
8929: LD_INT 11
8931: PUSH
8932: LD_INT 12
8934: PUSH
8935: LD_INT 14
8937: PUSH
8938: LD_INT 15
8940: PUSH
8941: LD_INT 16
8943: PUSH
8944: LD_INT 17
8946: PUSH
8947: LD_INT 18
8949: PUSH
8950: LD_INT 19
8952: PUSH
8953: LD_INT 20
8955: PUSH
8956: LD_INT 21
8958: PUSH
8959: LD_INT 22
8961: PUSH
8962: LD_INT 23
8964: PUSH
8965: LD_INT 24
8967: PUSH
8968: LD_INT 25
8970: PUSH
8971: LD_INT 26
8973: PUSH
8974: LD_INT 27
8976: PUSH
8977: LD_INT 28
8979: PUSH
8980: LD_INT 30
8982: PUSH
8983: LD_INT 31
8985: PUSH
8986: LD_INT 32
8988: PUSH
8989: LD_INT 33
8991: PUSH
8992: LD_INT 34
8994: PUSH
8995: LD_INT 36
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: LIST
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: LIST
9021: LIST
9022: LIST
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: LIST
9028: LIST
9029: LIST
9030: PUSH
9031: LD_INT 101
9033: PUSH
9034: LD_INT 102
9036: PUSH
9037: LD_INT 103
9039: PUSH
9040: LD_INT 104
9042: PUSH
9043: LD_INT 105
9045: PUSH
9046: LD_INT 106
9048: PUSH
9049: LD_INT 107
9051: PUSH
9052: LD_INT 108
9054: PUSH
9055: LD_INT 109
9057: PUSH
9058: LD_INT 110
9060: PUSH
9061: LD_INT 111
9063: PUSH
9064: LD_INT 112
9066: PUSH
9067: LD_INT 113
9069: PUSH
9070: LD_INT 114
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: LIST
9086: LIST
9087: LIST
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: ST_TO_ADDR
9093: GO 10260
9095: LD_INT 14
9097: DOUBLE
9098: EQUAL
9099: IFTRUE 9103
9101: GO 9315
9103: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
9104: LD_ADDR_VAR 0 1
9108: PUSH
9109: LD_INT 1
9111: PUSH
9112: LD_INT 2
9114: PUSH
9115: LD_INT 3
9117: PUSH
9118: LD_INT 4
9120: PUSH
9121: LD_INT 5
9123: PUSH
9124: LD_INT 6
9126: PUSH
9127: LD_INT 7
9129: PUSH
9130: LD_INT 8
9132: PUSH
9133: LD_INT 9
9135: PUSH
9136: LD_INT 10
9138: PUSH
9139: LD_INT 11
9141: PUSH
9142: LD_INT 12
9144: PUSH
9145: LD_INT 13
9147: PUSH
9148: LD_INT 14
9150: PUSH
9151: LD_INT 15
9153: PUSH
9154: LD_INT 16
9156: PUSH
9157: LD_INT 17
9159: PUSH
9160: LD_INT 18
9162: PUSH
9163: LD_INT 19
9165: PUSH
9166: LD_INT 20
9168: PUSH
9169: LD_INT 21
9171: PUSH
9172: LD_INT 22
9174: PUSH
9175: LD_INT 23
9177: PUSH
9178: LD_INT 24
9180: PUSH
9181: LD_INT 25
9183: PUSH
9184: LD_INT 26
9186: PUSH
9187: LD_INT 27
9189: PUSH
9190: LD_INT 28
9192: PUSH
9193: LD_INT 29
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 31
9201: PUSH
9202: LD_INT 32
9204: PUSH
9205: LD_INT 33
9207: PUSH
9208: LD_INT 34
9210: PUSH
9211: LD_INT 36
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: LIST
9218: LIST
9219: LIST
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: PUSH
9251: LD_INT 101
9253: PUSH
9254: LD_INT 102
9256: PUSH
9257: LD_INT 103
9259: PUSH
9260: LD_INT 104
9262: PUSH
9263: LD_INT 105
9265: PUSH
9266: LD_INT 106
9268: PUSH
9269: LD_INT 107
9271: PUSH
9272: LD_INT 108
9274: PUSH
9275: LD_INT 109
9277: PUSH
9278: LD_INT 110
9280: PUSH
9281: LD_INT 111
9283: PUSH
9284: LD_INT 112
9286: PUSH
9287: LD_INT 113
9289: PUSH
9290: LD_INT 114
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: LIST
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: LIST
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: ST_TO_ADDR
9313: GO 10260
9315: LD_INT 15
9317: DOUBLE
9318: EQUAL
9319: IFTRUE 9323
9321: GO 9535
9323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
9324: LD_ADDR_VAR 0 1
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: LD_INT 2
9334: PUSH
9335: LD_INT 3
9337: PUSH
9338: LD_INT 4
9340: PUSH
9341: LD_INT 5
9343: PUSH
9344: LD_INT 6
9346: PUSH
9347: LD_INT 7
9349: PUSH
9350: LD_INT 8
9352: PUSH
9353: LD_INT 9
9355: PUSH
9356: LD_INT 10
9358: PUSH
9359: LD_INT 11
9361: PUSH
9362: LD_INT 12
9364: PUSH
9365: LD_INT 13
9367: PUSH
9368: LD_INT 14
9370: PUSH
9371: LD_INT 15
9373: PUSH
9374: LD_INT 16
9376: PUSH
9377: LD_INT 17
9379: PUSH
9380: LD_INT 18
9382: PUSH
9383: LD_INT 19
9385: PUSH
9386: LD_INT 20
9388: PUSH
9389: LD_INT 21
9391: PUSH
9392: LD_INT 22
9394: PUSH
9395: LD_INT 23
9397: PUSH
9398: LD_INT 24
9400: PUSH
9401: LD_INT 25
9403: PUSH
9404: LD_INT 26
9406: PUSH
9407: LD_INT 27
9409: PUSH
9410: LD_INT 28
9412: PUSH
9413: LD_INT 29
9415: PUSH
9416: LD_INT 30
9418: PUSH
9419: LD_INT 31
9421: PUSH
9422: LD_INT 32
9424: PUSH
9425: LD_INT 33
9427: PUSH
9428: LD_INT 34
9430: PUSH
9431: LD_INT 36
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: LIST
9464: LIST
9465: LIST
9466: LIST
9467: LIST
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 101
9473: PUSH
9474: LD_INT 102
9476: PUSH
9477: LD_INT 103
9479: PUSH
9480: LD_INT 104
9482: PUSH
9483: LD_INT 105
9485: PUSH
9486: LD_INT 106
9488: PUSH
9489: LD_INT 107
9491: PUSH
9492: LD_INT 108
9494: PUSH
9495: LD_INT 109
9497: PUSH
9498: LD_INT 110
9500: PUSH
9501: LD_INT 111
9503: PUSH
9504: LD_INT 112
9506: PUSH
9507: LD_INT 113
9509: PUSH
9510: LD_INT 114
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: LIST
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: ST_TO_ADDR
9533: GO 10260
9535: LD_INT 16
9537: DOUBLE
9538: EQUAL
9539: IFTRUE 9543
9541: GO 9667
9543: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9544: LD_ADDR_VAR 0 1
9548: PUSH
9549: LD_INT 2
9551: PUSH
9552: LD_INT 4
9554: PUSH
9555: LD_INT 5
9557: PUSH
9558: LD_INT 7
9560: PUSH
9561: LD_INT 11
9563: PUSH
9564: LD_INT 12
9566: PUSH
9567: LD_INT 15
9569: PUSH
9570: LD_INT 16
9572: PUSH
9573: LD_INT 20
9575: PUSH
9576: LD_INT 21
9578: PUSH
9579: LD_INT 22
9581: PUSH
9582: LD_INT 23
9584: PUSH
9585: LD_INT 25
9587: PUSH
9588: LD_INT 26
9590: PUSH
9591: LD_INT 30
9593: PUSH
9594: LD_INT 31
9596: PUSH
9597: LD_INT 32
9599: PUSH
9600: LD_INT 33
9602: PUSH
9603: LD_INT 34
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: PUSH
9627: LD_INT 101
9629: PUSH
9630: LD_INT 102
9632: PUSH
9633: LD_INT 103
9635: PUSH
9636: LD_INT 106
9638: PUSH
9639: LD_INT 108
9641: PUSH
9642: LD_INT 112
9644: PUSH
9645: LD_INT 113
9647: PUSH
9648: LD_INT 114
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: ST_TO_ADDR
9665: GO 10260
9667: LD_INT 17
9669: DOUBLE
9670: EQUAL
9671: IFTRUE 9675
9673: GO 9887
9675: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9676: LD_ADDR_VAR 0 1
9680: PUSH
9681: LD_INT 1
9683: PUSH
9684: LD_INT 2
9686: PUSH
9687: LD_INT 3
9689: PUSH
9690: LD_INT 4
9692: PUSH
9693: LD_INT 5
9695: PUSH
9696: LD_INT 6
9698: PUSH
9699: LD_INT 7
9701: PUSH
9702: LD_INT 8
9704: PUSH
9705: LD_INT 9
9707: PUSH
9708: LD_INT 10
9710: PUSH
9711: LD_INT 11
9713: PUSH
9714: LD_INT 12
9716: PUSH
9717: LD_INT 13
9719: PUSH
9720: LD_INT 14
9722: PUSH
9723: LD_INT 15
9725: PUSH
9726: LD_INT 16
9728: PUSH
9729: LD_INT 17
9731: PUSH
9732: LD_INT 18
9734: PUSH
9735: LD_INT 19
9737: PUSH
9738: LD_INT 20
9740: PUSH
9741: LD_INT 21
9743: PUSH
9744: LD_INT 22
9746: PUSH
9747: LD_INT 23
9749: PUSH
9750: LD_INT 24
9752: PUSH
9753: LD_INT 25
9755: PUSH
9756: LD_INT 26
9758: PUSH
9759: LD_INT 27
9761: PUSH
9762: LD_INT 28
9764: PUSH
9765: LD_INT 29
9767: PUSH
9768: LD_INT 30
9770: PUSH
9771: LD_INT 31
9773: PUSH
9774: LD_INT 32
9776: PUSH
9777: LD_INT 33
9779: PUSH
9780: LD_INT 34
9782: PUSH
9783: LD_INT 36
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: LIST
9822: PUSH
9823: LD_INT 101
9825: PUSH
9826: LD_INT 102
9828: PUSH
9829: LD_INT 103
9831: PUSH
9832: LD_INT 104
9834: PUSH
9835: LD_INT 105
9837: PUSH
9838: LD_INT 106
9840: PUSH
9841: LD_INT 107
9843: PUSH
9844: LD_INT 108
9846: PUSH
9847: LD_INT 109
9849: PUSH
9850: LD_INT 110
9852: PUSH
9853: LD_INT 111
9855: PUSH
9856: LD_INT 112
9858: PUSH
9859: LD_INT 113
9861: PUSH
9862: LD_INT 114
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: PUSH
9881: EMPTY
9882: LIST
9883: LIST
9884: ST_TO_ADDR
9885: GO 10260
9887: LD_INT 18
9889: DOUBLE
9890: EQUAL
9891: IFTRUE 9895
9893: GO 10031
9895: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9896: LD_ADDR_VAR 0 1
9900: PUSH
9901: LD_INT 2
9903: PUSH
9904: LD_INT 4
9906: PUSH
9907: LD_INT 5
9909: PUSH
9910: LD_INT 7
9912: PUSH
9913: LD_INT 11
9915: PUSH
9916: LD_INT 12
9918: PUSH
9919: LD_INT 15
9921: PUSH
9922: LD_INT 16
9924: PUSH
9925: LD_INT 20
9927: PUSH
9928: LD_INT 21
9930: PUSH
9931: LD_INT 22
9933: PUSH
9934: LD_INT 23
9936: PUSH
9937: LD_INT 25
9939: PUSH
9940: LD_INT 26
9942: PUSH
9943: LD_INT 30
9945: PUSH
9946: LD_INT 31
9948: PUSH
9949: LD_INT 32
9951: PUSH
9952: LD_INT 33
9954: PUSH
9955: LD_INT 34
9957: PUSH
9958: LD_INT 35
9960: PUSH
9961: LD_INT 36
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: LIST
9978: LIST
9979: LIST
9980: LIST
9981: LIST
9982: LIST
9983: LIST
9984: LIST
9985: LIST
9986: PUSH
9987: LD_INT 101
9989: PUSH
9990: LD_INT 102
9992: PUSH
9993: LD_INT 103
9995: PUSH
9996: LD_INT 106
9998: PUSH
9999: LD_INT 108
10001: PUSH
10002: LD_INT 112
10004: PUSH
10005: LD_INT 113
10007: PUSH
10008: LD_INT 114
10010: PUSH
10011: LD_INT 115
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: LIST
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: ST_TO_ADDR
10029: GO 10260
10031: LD_INT 19
10033: DOUBLE
10034: EQUAL
10035: IFTRUE 10039
10037: GO 10259
10039: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
10040: LD_ADDR_VAR 0 1
10044: PUSH
10045: LD_INT 1
10047: PUSH
10048: LD_INT 2
10050: PUSH
10051: LD_INT 3
10053: PUSH
10054: LD_INT 4
10056: PUSH
10057: LD_INT 5
10059: PUSH
10060: LD_INT 6
10062: PUSH
10063: LD_INT 7
10065: PUSH
10066: LD_INT 8
10068: PUSH
10069: LD_INT 9
10071: PUSH
10072: LD_INT 10
10074: PUSH
10075: LD_INT 11
10077: PUSH
10078: LD_INT 12
10080: PUSH
10081: LD_INT 13
10083: PUSH
10084: LD_INT 14
10086: PUSH
10087: LD_INT 15
10089: PUSH
10090: LD_INT 16
10092: PUSH
10093: LD_INT 17
10095: PUSH
10096: LD_INT 18
10098: PUSH
10099: LD_INT 19
10101: PUSH
10102: LD_INT 20
10104: PUSH
10105: LD_INT 21
10107: PUSH
10108: LD_INT 22
10110: PUSH
10111: LD_INT 23
10113: PUSH
10114: LD_INT 24
10116: PUSH
10117: LD_INT 25
10119: PUSH
10120: LD_INT 26
10122: PUSH
10123: LD_INT 27
10125: PUSH
10126: LD_INT 28
10128: PUSH
10129: LD_INT 29
10131: PUSH
10132: LD_INT 30
10134: PUSH
10135: LD_INT 31
10137: PUSH
10138: LD_INT 32
10140: PUSH
10141: LD_INT 33
10143: PUSH
10144: LD_INT 34
10146: PUSH
10147: LD_INT 35
10149: PUSH
10150: LD_INT 36
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 101
10193: PUSH
10194: LD_INT 102
10196: PUSH
10197: LD_INT 103
10199: PUSH
10200: LD_INT 104
10202: PUSH
10203: LD_INT 105
10205: PUSH
10206: LD_INT 106
10208: PUSH
10209: LD_INT 107
10211: PUSH
10212: LD_INT 108
10214: PUSH
10215: LD_INT 109
10217: PUSH
10218: LD_INT 110
10220: PUSH
10221: LD_INT 111
10223: PUSH
10224: LD_INT 112
10226: PUSH
10227: LD_INT 113
10229: PUSH
10230: LD_INT 114
10232: PUSH
10233: LD_INT 115
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: LIST
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: ST_TO_ADDR
10257: GO 10260
10259: POP
// end else
10260: GO 10479
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
10262: LD_ADDR_VAR 0 1
10266: PUSH
10267: LD_INT 1
10269: PUSH
10270: LD_INT 2
10272: PUSH
10273: LD_INT 3
10275: PUSH
10276: LD_INT 4
10278: PUSH
10279: LD_INT 5
10281: PUSH
10282: LD_INT 6
10284: PUSH
10285: LD_INT 7
10287: PUSH
10288: LD_INT 8
10290: PUSH
10291: LD_INT 9
10293: PUSH
10294: LD_INT 10
10296: PUSH
10297: LD_INT 11
10299: PUSH
10300: LD_INT 12
10302: PUSH
10303: LD_INT 13
10305: PUSH
10306: LD_INT 14
10308: PUSH
10309: LD_INT 15
10311: PUSH
10312: LD_INT 16
10314: PUSH
10315: LD_INT 17
10317: PUSH
10318: LD_INT 18
10320: PUSH
10321: LD_INT 19
10323: PUSH
10324: LD_INT 20
10326: PUSH
10327: LD_INT 21
10329: PUSH
10330: LD_INT 22
10332: PUSH
10333: LD_INT 23
10335: PUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 25
10341: PUSH
10342: LD_INT 26
10344: PUSH
10345: LD_INT 27
10347: PUSH
10348: LD_INT 28
10350: PUSH
10351: LD_INT 29
10353: PUSH
10354: LD_INT 30
10356: PUSH
10357: LD_INT 31
10359: PUSH
10360: LD_INT 32
10362: PUSH
10363: LD_INT 33
10365: PUSH
10366: LD_INT 34
10368: PUSH
10369: LD_INT 35
10371: PUSH
10372: LD_INT 36
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: LD_INT 101
10415: PUSH
10416: LD_INT 102
10418: PUSH
10419: LD_INT 103
10421: PUSH
10422: LD_INT 104
10424: PUSH
10425: LD_INT 105
10427: PUSH
10428: LD_INT 106
10430: PUSH
10431: LD_INT 107
10433: PUSH
10434: LD_INT 108
10436: PUSH
10437: LD_INT 109
10439: PUSH
10440: LD_INT 110
10442: PUSH
10443: LD_INT 111
10445: PUSH
10446: LD_INT 112
10448: PUSH
10449: LD_INT 113
10451: PUSH
10452: LD_INT 114
10454: PUSH
10455: LD_INT 115
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: LIST
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: ST_TO_ADDR
// if result then
10479: LD_VAR 0 1
10483: IFFALSE 10772
// begin normal :=  ;
10485: LD_ADDR_VAR 0 3
10489: PUSH
10490: LD_STRING 
10492: ST_TO_ADDR
// hardcore :=  ;
10493: LD_ADDR_VAR 0 4
10497: PUSH
10498: LD_STRING 
10500: ST_TO_ADDR
// for i = 1 to normalCounter do
10501: LD_ADDR_VAR 0 5
10505: PUSH
10506: DOUBLE
10507: LD_INT 1
10509: DEC
10510: ST_TO_ADDR
10511: LD_EXP 28
10515: PUSH
10516: FOR_TO
10517: IFFALSE 10618
// begin tmp := 0 ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_STRING 0
10526: ST_TO_ADDR
// if result [ 1 ] then
10527: LD_VAR 0 1
10531: PUSH
10532: LD_INT 1
10534: ARRAY
10535: IFFALSE 10600
// if result [ 1 ] [ 1 ] = i then
10537: LD_VAR 0 1
10541: PUSH
10542: LD_INT 1
10544: ARRAY
10545: PUSH
10546: LD_INT 1
10548: ARRAY
10549: PUSH
10550: LD_VAR 0 5
10554: EQUAL
10555: IFFALSE 10600
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: LD_VAR 0 1
10574: PUSH
10575: LD_INT 1
10577: ARRAY
10578: PPUSH
10579: LD_INT 1
10581: PPUSH
10582: CALL_OW 3
10586: PPUSH
10587: CALL_OW 1
10591: ST_TO_ADDR
// tmp := 1 ;
10592: LD_ADDR_VAR 0 2
10596: PUSH
10597: LD_STRING 1
10599: ST_TO_ADDR
// end ; normal := normal & tmp ;
10600: LD_ADDR_VAR 0 3
10604: PUSH
10605: LD_VAR 0 3
10609: PUSH
10610: LD_VAR 0 2
10614: STR
10615: ST_TO_ADDR
// end ;
10616: GO 10516
10618: POP
10619: POP
// for i = 1 to hardcoreCounter do
10620: LD_ADDR_VAR 0 5
10624: PUSH
10625: DOUBLE
10626: LD_INT 1
10628: DEC
10629: ST_TO_ADDR
10630: LD_EXP 29
10634: PUSH
10635: FOR_TO
10636: IFFALSE 10741
// begin tmp := 0 ;
10638: LD_ADDR_VAR 0 2
10642: PUSH
10643: LD_STRING 0
10645: ST_TO_ADDR
// if result [ 2 ] then
10646: LD_VAR 0 1
10650: PUSH
10651: LD_INT 2
10653: ARRAY
10654: IFFALSE 10723
// if result [ 2 ] [ 1 ] = 100 + i then
10656: LD_VAR 0 1
10660: PUSH
10661: LD_INT 2
10663: ARRAY
10664: PUSH
10665: LD_INT 1
10667: ARRAY
10668: PUSH
10669: LD_INT 100
10671: PUSH
10672: LD_VAR 0 5
10676: PLUS
10677: EQUAL
10678: IFFALSE 10723
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10680: LD_ADDR_VAR 0 1
10684: PUSH
10685: LD_VAR 0 1
10689: PPUSH
10690: LD_INT 2
10692: PPUSH
10693: LD_VAR 0 1
10697: PUSH
10698: LD_INT 2
10700: ARRAY
10701: PPUSH
10702: LD_INT 1
10704: PPUSH
10705: CALL_OW 3
10709: PPUSH
10710: CALL_OW 1
10714: ST_TO_ADDR
// tmp := 1 ;
10715: LD_ADDR_VAR 0 2
10719: PUSH
10720: LD_STRING 1
10722: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10723: LD_ADDR_VAR 0 4
10727: PUSH
10728: LD_VAR 0 4
10732: PUSH
10733: LD_VAR 0 2
10737: STR
10738: ST_TO_ADDR
// end ;
10739: GO 10635
10741: POP
10742: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10743: LD_STRING getStreamItemsFromMission("
10745: PUSH
10746: LD_VAR 0 3
10750: STR
10751: PUSH
10752: LD_STRING ","
10754: STR
10755: PUSH
10756: LD_VAR 0 4
10760: STR
10761: PUSH
10762: LD_STRING ")
10764: STR
10765: PPUSH
10766: CALL_OW 559
// end else
10770: GO 10779
// ToLua ( getStreamItemsFromMission("","") ) ;
10772: LD_STRING getStreamItemsFromMission("","")
10774: PPUSH
10775: CALL_OW 559
// end ;
10779: LD_VAR 0 1
10783: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10784: LD_VAR 0 2
10788: PUSH
10789: LD_INT 100
10791: EQUAL
10792: IFFALSE 11741
// begin if not StreamModeActive then
10794: LD_EXP 27
10798: NOT
10799: IFFALSE 10809
// StreamModeActive := true ;
10801: LD_ADDR_EXP 27
10805: PUSH
10806: LD_INT 1
10808: ST_TO_ADDR
// if p3 = 0 then
10809: LD_VAR 0 3
10813: PUSH
10814: LD_INT 0
10816: EQUAL
10817: IFFALSE 10823
// InitStreamMode ;
10819: CALL 6862 0 0
// if p3 = 1 then
10823: LD_VAR 0 3
10827: PUSH
10828: LD_INT 1
10830: EQUAL
10831: IFFALSE 10841
// sRocket := true ;
10833: LD_ADDR_EXP 32
10837: PUSH
10838: LD_INT 1
10840: ST_TO_ADDR
// if p3 = 2 then
10841: LD_VAR 0 3
10845: PUSH
10846: LD_INT 2
10848: EQUAL
10849: IFFALSE 10859
// sSpeed := true ;
10851: LD_ADDR_EXP 31
10855: PUSH
10856: LD_INT 1
10858: ST_TO_ADDR
// if p3 = 3 then
10859: LD_VAR 0 3
10863: PUSH
10864: LD_INT 3
10866: EQUAL
10867: IFFALSE 10877
// sEngine := true ;
10869: LD_ADDR_EXP 33
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// if p3 = 4 then
10877: LD_VAR 0 3
10881: PUSH
10882: LD_INT 4
10884: EQUAL
10885: IFFALSE 10895
// sSpec := true ;
10887: LD_ADDR_EXP 30
10891: PUSH
10892: LD_INT 1
10894: ST_TO_ADDR
// if p3 = 5 then
10895: LD_VAR 0 3
10899: PUSH
10900: LD_INT 5
10902: EQUAL
10903: IFFALSE 10913
// sLevel := true ;
10905: LD_ADDR_EXP 34
10909: PUSH
10910: LD_INT 1
10912: ST_TO_ADDR
// if p3 = 6 then
10913: LD_VAR 0 3
10917: PUSH
10918: LD_INT 6
10920: EQUAL
10921: IFFALSE 10931
// sArmoury := true ;
10923: LD_ADDR_EXP 35
10927: PUSH
10928: LD_INT 1
10930: ST_TO_ADDR
// if p3 = 7 then
10931: LD_VAR 0 3
10935: PUSH
10936: LD_INT 7
10938: EQUAL
10939: IFFALSE 10949
// sRadar := true ;
10941: LD_ADDR_EXP 36
10945: PUSH
10946: LD_INT 1
10948: ST_TO_ADDR
// if p3 = 8 then
10949: LD_VAR 0 3
10953: PUSH
10954: LD_INT 8
10956: EQUAL
10957: IFFALSE 10967
// sBunker := true ;
10959: LD_ADDR_EXP 37
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// if p3 = 9 then
10967: LD_VAR 0 3
10971: PUSH
10972: LD_INT 9
10974: EQUAL
10975: IFFALSE 10985
// sHack := true ;
10977: LD_ADDR_EXP 38
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// if p3 = 10 then
10985: LD_VAR 0 3
10989: PUSH
10990: LD_INT 10
10992: EQUAL
10993: IFFALSE 11003
// sFire := true ;
10995: LD_ADDR_EXP 39
10999: PUSH
11000: LD_INT 1
11002: ST_TO_ADDR
// if p3 = 11 then
11003: LD_VAR 0 3
11007: PUSH
11008: LD_INT 11
11010: EQUAL
11011: IFFALSE 11021
// sRefresh := true ;
11013: LD_ADDR_EXP 40
11017: PUSH
11018: LD_INT 1
11020: ST_TO_ADDR
// if p3 = 12 then
11021: LD_VAR 0 3
11025: PUSH
11026: LD_INT 12
11028: EQUAL
11029: IFFALSE 11039
// sExp := true ;
11031: LD_ADDR_EXP 41
11035: PUSH
11036: LD_INT 1
11038: ST_TO_ADDR
// if p3 = 13 then
11039: LD_VAR 0 3
11043: PUSH
11044: LD_INT 13
11046: EQUAL
11047: IFFALSE 11057
// sDepot := true ;
11049: LD_ADDR_EXP 42
11053: PUSH
11054: LD_INT 1
11056: ST_TO_ADDR
// if p3 = 14 then
11057: LD_VAR 0 3
11061: PUSH
11062: LD_INT 14
11064: EQUAL
11065: IFFALSE 11075
// sFlag := true ;
11067: LD_ADDR_EXP 43
11071: PUSH
11072: LD_INT 1
11074: ST_TO_ADDR
// if p3 = 15 then
11075: LD_VAR 0 3
11079: PUSH
11080: LD_INT 15
11082: EQUAL
11083: IFFALSE 11093
// sKamikadze := true ;
11085: LD_ADDR_EXP 51
11089: PUSH
11090: LD_INT 1
11092: ST_TO_ADDR
// if p3 = 16 then
11093: LD_VAR 0 3
11097: PUSH
11098: LD_INT 16
11100: EQUAL
11101: IFFALSE 11111
// sTroll := true ;
11103: LD_ADDR_EXP 52
11107: PUSH
11108: LD_INT 1
11110: ST_TO_ADDR
// if p3 = 17 then
11111: LD_VAR 0 3
11115: PUSH
11116: LD_INT 17
11118: EQUAL
11119: IFFALSE 11129
// sSlow := true ;
11121: LD_ADDR_EXP 53
11125: PUSH
11126: LD_INT 1
11128: ST_TO_ADDR
// if p3 = 18 then
11129: LD_VAR 0 3
11133: PUSH
11134: LD_INT 18
11136: EQUAL
11137: IFFALSE 11147
// sLack := true ;
11139: LD_ADDR_EXP 54
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// if p3 = 19 then
11147: LD_VAR 0 3
11151: PUSH
11152: LD_INT 19
11154: EQUAL
11155: IFFALSE 11165
// sTank := true ;
11157: LD_ADDR_EXP 56
11161: PUSH
11162: LD_INT 1
11164: ST_TO_ADDR
// if p3 = 20 then
11165: LD_VAR 0 3
11169: PUSH
11170: LD_INT 20
11172: EQUAL
11173: IFFALSE 11183
// sRemote := true ;
11175: LD_ADDR_EXP 57
11179: PUSH
11180: LD_INT 1
11182: ST_TO_ADDR
// if p3 = 21 then
11183: LD_VAR 0 3
11187: PUSH
11188: LD_INT 21
11190: EQUAL
11191: IFFALSE 11201
// sPowell := true ;
11193: LD_ADDR_EXP 58
11197: PUSH
11198: LD_INT 1
11200: ST_TO_ADDR
// if p3 = 22 then
11201: LD_VAR 0 3
11205: PUSH
11206: LD_INT 22
11208: EQUAL
11209: IFFALSE 11219
// sTeleport := true ;
11211: LD_ADDR_EXP 61
11215: PUSH
11216: LD_INT 1
11218: ST_TO_ADDR
// if p3 = 23 then
11219: LD_VAR 0 3
11223: PUSH
11224: LD_INT 23
11226: EQUAL
11227: IFFALSE 11237
// sOilTower := true ;
11229: LD_ADDR_EXP 63
11233: PUSH
11234: LD_INT 1
11236: ST_TO_ADDR
// if p3 = 24 then
11237: LD_VAR 0 3
11241: PUSH
11242: LD_INT 24
11244: EQUAL
11245: IFFALSE 11255
// sShovel := true ;
11247: LD_ADDR_EXP 64
11251: PUSH
11252: LD_INT 1
11254: ST_TO_ADDR
// if p3 = 25 then
11255: LD_VAR 0 3
11259: PUSH
11260: LD_INT 25
11262: EQUAL
11263: IFFALSE 11273
// sSheik := true ;
11265: LD_ADDR_EXP 65
11269: PUSH
11270: LD_INT 1
11272: ST_TO_ADDR
// if p3 = 26 then
11273: LD_VAR 0 3
11277: PUSH
11278: LD_INT 26
11280: EQUAL
11281: IFFALSE 11291
// sEarthquake := true ;
11283: LD_ADDR_EXP 67
11287: PUSH
11288: LD_INT 1
11290: ST_TO_ADDR
// if p3 = 27 then
11291: LD_VAR 0 3
11295: PUSH
11296: LD_INT 27
11298: EQUAL
11299: IFFALSE 11309
// sAI := true ;
11301: LD_ADDR_EXP 68
11305: PUSH
11306: LD_INT 1
11308: ST_TO_ADDR
// if p3 = 28 then
11309: LD_VAR 0 3
11313: PUSH
11314: LD_INT 28
11316: EQUAL
11317: IFFALSE 11327
// sCargo := true ;
11319: LD_ADDR_EXP 71
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// if p3 = 29 then
11327: LD_VAR 0 3
11331: PUSH
11332: LD_INT 29
11334: EQUAL
11335: IFFALSE 11345
// sDLaser := true ;
11337: LD_ADDR_EXP 72
11341: PUSH
11342: LD_INT 1
11344: ST_TO_ADDR
// if p3 = 30 then
11345: LD_VAR 0 3
11349: PUSH
11350: LD_INT 30
11352: EQUAL
11353: IFFALSE 11363
// sExchange := true ;
11355: LD_ADDR_EXP 73
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// if p3 = 31 then
11363: LD_VAR 0 3
11367: PUSH
11368: LD_INT 31
11370: EQUAL
11371: IFFALSE 11381
// sFac := true ;
11373: LD_ADDR_EXP 74
11377: PUSH
11378: LD_INT 1
11380: ST_TO_ADDR
// if p3 = 32 then
11381: LD_VAR 0 3
11385: PUSH
11386: LD_INT 32
11388: EQUAL
11389: IFFALSE 11399
// sPower := true ;
11391: LD_ADDR_EXP 75
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// if p3 = 33 then
11399: LD_VAR 0 3
11403: PUSH
11404: LD_INT 33
11406: EQUAL
11407: IFFALSE 11417
// sRandom := true ;
11409: LD_ADDR_EXP 76
11413: PUSH
11414: LD_INT 1
11416: ST_TO_ADDR
// if p3 = 34 then
11417: LD_VAR 0 3
11421: PUSH
11422: LD_INT 34
11424: EQUAL
11425: IFFALSE 11435
// sShield := true ;
11427: LD_ADDR_EXP 77
11431: PUSH
11432: LD_INT 1
11434: ST_TO_ADDR
// if p3 = 35 then
11435: LD_VAR 0 3
11439: PUSH
11440: LD_INT 35
11442: EQUAL
11443: IFFALSE 11453
// sTime := true ;
11445: LD_ADDR_EXP 78
11449: PUSH
11450: LD_INT 1
11452: ST_TO_ADDR
// if p3 = 36 then
11453: LD_VAR 0 3
11457: PUSH
11458: LD_INT 36
11460: EQUAL
11461: IFFALSE 11471
// sTools := true ;
11463: LD_ADDR_EXP 79
11467: PUSH
11468: LD_INT 1
11470: ST_TO_ADDR
// if p3 = 101 then
11471: LD_VAR 0 3
11475: PUSH
11476: LD_INT 101
11478: EQUAL
11479: IFFALSE 11489
// sSold := true ;
11481: LD_ADDR_EXP 44
11485: PUSH
11486: LD_INT 1
11488: ST_TO_ADDR
// if p3 = 102 then
11489: LD_VAR 0 3
11493: PUSH
11494: LD_INT 102
11496: EQUAL
11497: IFFALSE 11507
// sDiff := true ;
11499: LD_ADDR_EXP 45
11503: PUSH
11504: LD_INT 1
11506: ST_TO_ADDR
// if p3 = 103 then
11507: LD_VAR 0 3
11511: PUSH
11512: LD_INT 103
11514: EQUAL
11515: IFFALSE 11525
// sFog := true ;
11517: LD_ADDR_EXP 48
11521: PUSH
11522: LD_INT 1
11524: ST_TO_ADDR
// if p3 = 104 then
11525: LD_VAR 0 3
11529: PUSH
11530: LD_INT 104
11532: EQUAL
11533: IFFALSE 11543
// sReset := true ;
11535: LD_ADDR_EXP 49
11539: PUSH
11540: LD_INT 1
11542: ST_TO_ADDR
// if p3 = 105 then
11543: LD_VAR 0 3
11547: PUSH
11548: LD_INT 105
11550: EQUAL
11551: IFFALSE 11561
// sSun := true ;
11553: LD_ADDR_EXP 50
11557: PUSH
11558: LD_INT 1
11560: ST_TO_ADDR
// if p3 = 106 then
11561: LD_VAR 0 3
11565: PUSH
11566: LD_INT 106
11568: EQUAL
11569: IFFALSE 11579
// sTiger := true ;
11571: LD_ADDR_EXP 46
11575: PUSH
11576: LD_INT 1
11578: ST_TO_ADDR
// if p3 = 107 then
11579: LD_VAR 0 3
11583: PUSH
11584: LD_INT 107
11586: EQUAL
11587: IFFALSE 11597
// sBomb := true ;
11589: LD_ADDR_EXP 47
11593: PUSH
11594: LD_INT 1
11596: ST_TO_ADDR
// if p3 = 108 then
11597: LD_VAR 0 3
11601: PUSH
11602: LD_INT 108
11604: EQUAL
11605: IFFALSE 11615
// sWound := true ;
11607: LD_ADDR_EXP 55
11611: PUSH
11612: LD_INT 1
11614: ST_TO_ADDR
// if p3 = 109 then
11615: LD_VAR 0 3
11619: PUSH
11620: LD_INT 109
11622: EQUAL
11623: IFFALSE 11633
// sBetray := true ;
11625: LD_ADDR_EXP 59
11629: PUSH
11630: LD_INT 1
11632: ST_TO_ADDR
// if p3 = 110 then
11633: LD_VAR 0 3
11637: PUSH
11638: LD_INT 110
11640: EQUAL
11641: IFFALSE 11651
// sContamin := true ;
11643: LD_ADDR_EXP 60
11647: PUSH
11648: LD_INT 1
11650: ST_TO_ADDR
// if p3 = 111 then
11651: LD_VAR 0 3
11655: PUSH
11656: LD_INT 111
11658: EQUAL
11659: IFFALSE 11669
// sOil := true ;
11661: LD_ADDR_EXP 62
11665: PUSH
11666: LD_INT 1
11668: ST_TO_ADDR
// if p3 = 112 then
11669: LD_VAR 0 3
11673: PUSH
11674: LD_INT 112
11676: EQUAL
11677: IFFALSE 11687
// sStu := true ;
11679: LD_ADDR_EXP 66
11683: PUSH
11684: LD_INT 1
11686: ST_TO_ADDR
// if p3 = 113 then
11687: LD_VAR 0 3
11691: PUSH
11692: LD_INT 113
11694: EQUAL
11695: IFFALSE 11705
// sBazooka := true ;
11697: LD_ADDR_EXP 69
11701: PUSH
11702: LD_INT 1
11704: ST_TO_ADDR
// if p3 = 114 then
11705: LD_VAR 0 3
11709: PUSH
11710: LD_INT 114
11712: EQUAL
11713: IFFALSE 11723
// sMortar := true ;
11715: LD_ADDR_EXP 70
11719: PUSH
11720: LD_INT 1
11722: ST_TO_ADDR
// if p3 = 115 then
11723: LD_VAR 0 3
11727: PUSH
11728: LD_INT 115
11730: EQUAL
11731: IFFALSE 11741
// sRanger := true ;
11733: LD_ADDR_EXP 80
11737: PUSH
11738: LD_INT 1
11740: ST_TO_ADDR
// end ; end ;
11741: PPOPN 6
11743: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11744: LD_EXP 27
11748: PUSH
11749: LD_EXP 32
11753: AND
11754: IFFALSE 11878
11756: GO 11758
11758: DISABLE
11759: LD_INT 0
11761: PPUSH
11762: PPUSH
// begin enable ;
11763: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11764: LD_ADDR_VAR 0 2
11768: PUSH
11769: LD_INT 22
11771: PUSH
11772: LD_OWVAR 2
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: LD_INT 2
11783: PUSH
11784: LD_INT 34
11786: PUSH
11787: LD_INT 7
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: PUSH
11794: LD_INT 34
11796: PUSH
11797: LD_INT 45
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PUSH
11804: LD_INT 34
11806: PUSH
11807: LD_INT 28
11809: PUSH
11810: EMPTY
11811: LIST
11812: LIST
11813: PUSH
11814: LD_INT 34
11816: PUSH
11817: LD_INT 47
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PPUSH
11835: CALL_OW 69
11839: ST_TO_ADDR
// if not tmp then
11840: LD_VAR 0 2
11844: NOT
11845: IFFALSE 11849
// exit ;
11847: GO 11878
// for i in tmp do
11849: LD_ADDR_VAR 0 1
11853: PUSH
11854: LD_VAR 0 2
11858: PUSH
11859: FOR_IN
11860: IFFALSE 11876
// begin SetLives ( i , 0 ) ;
11862: LD_VAR 0 1
11866: PPUSH
11867: LD_INT 0
11869: PPUSH
11870: CALL_OW 234
// end ;
11874: GO 11859
11876: POP
11877: POP
// end ;
11878: PPOPN 2
11880: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11881: LD_EXP 27
11885: PUSH
11886: LD_EXP 33
11890: AND
11891: IFFALSE 11975
11893: GO 11895
11895: DISABLE
11896: LD_INT 0
11898: PPUSH
11899: PPUSH
// begin enable ;
11900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11901: LD_ADDR_VAR 0 2
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_OWVAR 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 32
11920: PUSH
11921: LD_INT 3
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PPUSH
11932: CALL_OW 69
11936: ST_TO_ADDR
// if not tmp then
11937: LD_VAR 0 2
11941: NOT
11942: IFFALSE 11946
// exit ;
11944: GO 11975
// for i in tmp do
11946: LD_ADDR_VAR 0 1
11950: PUSH
11951: LD_VAR 0 2
11955: PUSH
11956: FOR_IN
11957: IFFALSE 11973
// begin SetLives ( i , 0 ) ;
11959: LD_VAR 0 1
11963: PPUSH
11964: LD_INT 0
11966: PPUSH
11967: CALL_OW 234
// end ;
11971: GO 11956
11973: POP
11974: POP
// end ;
11975: PPOPN 2
11977: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11978: LD_EXP 27
11982: PUSH
11983: LD_EXP 30
11987: AND
11988: IFFALSE 12081
11990: GO 11992
11992: DISABLE
11993: LD_INT 0
11995: PPUSH
// begin enable ;
11996: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11997: LD_ADDR_VAR 0 1
12001: PUSH
12002: LD_INT 22
12004: PUSH
12005: LD_OWVAR 2
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: PUSH
12014: LD_INT 2
12016: PUSH
12017: LD_INT 25
12019: PUSH
12020: LD_INT 5
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: PUSH
12027: LD_INT 25
12029: PUSH
12030: LD_INT 9
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: PUSH
12037: LD_INT 25
12039: PUSH
12040: LD_INT 8
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: LIST
12051: LIST
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PPUSH
12057: CALL_OW 69
12061: PUSH
12062: FOR_IN
12063: IFFALSE 12079
// begin SetClass ( i , 1 ) ;
12065: LD_VAR 0 1
12069: PPUSH
12070: LD_INT 1
12072: PPUSH
12073: CALL_OW 336
// end ;
12077: GO 12062
12079: POP
12080: POP
// end ;
12081: PPOPN 1
12083: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12084: LD_EXP 27
12088: PUSH
12089: LD_EXP 31
12093: AND
12094: PUSH
12095: LD_OWVAR 65
12099: PUSH
12100: LD_INT 7
12102: LESS
12103: AND
12104: IFFALSE 12118
12106: GO 12108
12108: DISABLE
// begin enable ;
12109: ENABLE
// game_speed := 7 ;
12110: LD_ADDR_OWVAR 65
12114: PUSH
12115: LD_INT 7
12117: ST_TO_ADDR
// end ;
12118: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12119: LD_EXP 27
12123: PUSH
12124: LD_EXP 34
12128: AND
12129: IFFALSE 12331
12131: GO 12133
12133: DISABLE
12134: LD_INT 0
12136: PPUSH
12137: PPUSH
12138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12139: LD_ADDR_VAR 0 3
12143: PUSH
12144: LD_INT 81
12146: PUSH
12147: LD_OWVAR 2
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PUSH
12156: LD_INT 21
12158: PUSH
12159: LD_INT 1
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: ST_TO_ADDR
// if not tmp then
12175: LD_VAR 0 3
12179: NOT
12180: IFFALSE 12184
// exit ;
12182: GO 12331
// if tmp > 5 then
12184: LD_VAR 0 3
12188: PUSH
12189: LD_INT 5
12191: GREATER
12192: IFFALSE 12204
// k := 5 else
12194: LD_ADDR_VAR 0 2
12198: PUSH
12199: LD_INT 5
12201: ST_TO_ADDR
12202: GO 12214
// k := tmp ;
12204: LD_ADDR_VAR 0 2
12208: PUSH
12209: LD_VAR 0 3
12213: ST_TO_ADDR
// for i := 1 to k do
12214: LD_ADDR_VAR 0 1
12218: PUSH
12219: DOUBLE
12220: LD_INT 1
12222: DEC
12223: ST_TO_ADDR
12224: LD_VAR 0 2
12228: PUSH
12229: FOR_TO
12230: IFFALSE 12329
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12232: LD_VAR 0 3
12236: PUSH
12237: LD_VAR 0 1
12241: ARRAY
12242: PPUSH
12243: LD_VAR 0 1
12247: PUSH
12248: LD_INT 4
12250: MOD
12251: PUSH
12252: LD_INT 1
12254: PLUS
12255: PPUSH
12256: CALL_OW 259
12260: PUSH
12261: LD_INT 10
12263: LESS
12264: IFFALSE 12327
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12266: LD_VAR 0 3
12270: PUSH
12271: LD_VAR 0 1
12275: ARRAY
12276: PPUSH
12277: LD_VAR 0 1
12281: PUSH
12282: LD_INT 4
12284: MOD
12285: PUSH
12286: LD_INT 1
12288: PLUS
12289: PPUSH
12290: LD_VAR 0 3
12294: PUSH
12295: LD_VAR 0 1
12299: ARRAY
12300: PPUSH
12301: LD_VAR 0 1
12305: PUSH
12306: LD_INT 4
12308: MOD
12309: PUSH
12310: LD_INT 1
12312: PLUS
12313: PPUSH
12314: CALL_OW 259
12318: PUSH
12319: LD_INT 1
12321: PLUS
12322: PPUSH
12323: CALL_OW 237
12327: GO 12229
12329: POP
12330: POP
// end ;
12331: PPOPN 3
12333: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12334: LD_EXP 27
12338: PUSH
12339: LD_EXP 35
12343: AND
12344: IFFALSE 12364
12346: GO 12348
12348: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12349: LD_INT 4
12351: PPUSH
12352: LD_OWVAR 2
12356: PPUSH
12357: LD_INT 0
12359: PPUSH
12360: CALL_OW 324
12364: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12365: LD_EXP 27
12369: PUSH
12370: LD_EXP 64
12374: AND
12375: IFFALSE 12395
12377: GO 12379
12379: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12380: LD_INT 19
12382: PPUSH
12383: LD_OWVAR 2
12387: PPUSH
12388: LD_INT 0
12390: PPUSH
12391: CALL_OW 324
12395: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12396: LD_EXP 27
12400: PUSH
12401: LD_EXP 36
12405: AND
12406: IFFALSE 12508
12408: GO 12410
12410: DISABLE
12411: LD_INT 0
12413: PPUSH
12414: PPUSH
// begin enable ;
12415: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12416: LD_ADDR_VAR 0 2
12420: PUSH
12421: LD_INT 22
12423: PUSH
12424: LD_OWVAR 2
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: LD_INT 2
12435: PUSH
12436: LD_INT 34
12438: PUSH
12439: LD_INT 11
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PUSH
12446: LD_INT 34
12448: PUSH
12449: LD_INT 30
12451: PUSH
12452: EMPTY
12453: LIST
12454: LIST
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: LIST
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: PPUSH
12465: CALL_OW 69
12469: ST_TO_ADDR
// if not tmp then
12470: LD_VAR 0 2
12474: NOT
12475: IFFALSE 12479
// exit ;
12477: GO 12508
// for i in tmp do
12479: LD_ADDR_VAR 0 1
12483: PUSH
12484: LD_VAR 0 2
12488: PUSH
12489: FOR_IN
12490: IFFALSE 12506
// begin SetLives ( i , 0 ) ;
12492: LD_VAR 0 1
12496: PPUSH
12497: LD_INT 0
12499: PPUSH
12500: CALL_OW 234
// end ;
12504: GO 12489
12506: POP
12507: POP
// end ;
12508: PPOPN 2
12510: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12511: LD_EXP 27
12515: PUSH
12516: LD_EXP 37
12520: AND
12521: IFFALSE 12541
12523: GO 12525
12525: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12526: LD_INT 32
12528: PPUSH
12529: LD_OWVAR 2
12533: PPUSH
12534: LD_INT 0
12536: PPUSH
12537: CALL_OW 324
12541: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12542: LD_EXP 27
12546: PUSH
12547: LD_EXP 38
12551: AND
12552: IFFALSE 12733
12554: GO 12556
12556: DISABLE
12557: LD_INT 0
12559: PPUSH
12560: PPUSH
12561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12562: LD_ADDR_VAR 0 2
12566: PUSH
12567: LD_INT 22
12569: PUSH
12570: LD_OWVAR 2
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 33
12581: PUSH
12582: LD_INT 3
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: PPUSH
12593: CALL_OW 69
12597: ST_TO_ADDR
// if not tmp then
12598: LD_VAR 0 2
12602: NOT
12603: IFFALSE 12607
// exit ;
12605: GO 12733
// side := 0 ;
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: LD_INT 0
12614: ST_TO_ADDR
// for i := 1 to 8 do
12615: LD_ADDR_VAR 0 1
12619: PUSH
12620: DOUBLE
12621: LD_INT 1
12623: DEC
12624: ST_TO_ADDR
12625: LD_INT 8
12627: PUSH
12628: FOR_TO
12629: IFFALSE 12677
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12631: LD_OWVAR 2
12635: PUSH
12636: LD_VAR 0 1
12640: NONEQUAL
12641: PUSH
12642: LD_OWVAR 2
12646: PPUSH
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 81
12656: PUSH
12657: LD_INT 2
12659: EQUAL
12660: AND
12661: IFFALSE 12675
// begin side := i ;
12663: LD_ADDR_VAR 0 3
12667: PUSH
12668: LD_VAR 0 1
12672: ST_TO_ADDR
// break ;
12673: GO 12677
// end ;
12675: GO 12628
12677: POP
12678: POP
// if not side then
12679: LD_VAR 0 3
12683: NOT
12684: IFFALSE 12688
// exit ;
12686: GO 12733
// for i := 1 to tmp do
12688: LD_ADDR_VAR 0 1
12692: PUSH
12693: DOUBLE
12694: LD_INT 1
12696: DEC
12697: ST_TO_ADDR
12698: LD_VAR 0 2
12702: PUSH
12703: FOR_TO
12704: IFFALSE 12731
// if Prob ( 60 ) then
12706: LD_INT 60
12708: PPUSH
12709: CALL_OW 13
12713: IFFALSE 12729
// SetSide ( i , side ) ;
12715: LD_VAR 0 1
12719: PPUSH
12720: LD_VAR 0 3
12724: PPUSH
12725: CALL_OW 235
12729: GO 12703
12731: POP
12732: POP
// end ;
12733: PPOPN 3
12735: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12736: LD_EXP 27
12740: PUSH
12741: LD_EXP 40
12745: AND
12746: IFFALSE 12865
12748: GO 12750
12750: DISABLE
12751: LD_INT 0
12753: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12754: LD_ADDR_VAR 0 1
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_OWVAR 2
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PUSH
12771: LD_INT 21
12773: PUSH
12774: LD_INT 1
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 3
12783: PUSH
12784: LD_INT 23
12786: PUSH
12787: LD_INT 0
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 69
12807: PUSH
12808: FOR_IN
12809: IFFALSE 12863
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12811: LD_VAR 0 1
12815: PPUSH
12816: CALL_OW 257
12820: PUSH
12821: LD_INT 1
12823: PUSH
12824: LD_INT 2
12826: PUSH
12827: LD_INT 3
12829: PUSH
12830: LD_INT 4
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: IN
12839: IFFALSE 12861
// SetClass ( un , rand ( 1 , 4 ) ) ;
12841: LD_VAR 0 1
12845: PPUSH
12846: LD_INT 1
12848: PPUSH
12849: LD_INT 4
12851: PPUSH
12852: CALL_OW 12
12856: PPUSH
12857: CALL_OW 336
12861: GO 12808
12863: POP
12864: POP
// end ;
12865: PPOPN 1
12867: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12868: LD_EXP 27
12872: PUSH
12873: LD_EXP 39
12877: AND
12878: IFFALSE 12957
12880: GO 12882
12882: DISABLE
12883: LD_INT 0
12885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12886: LD_ADDR_VAR 0 1
12890: PUSH
12891: LD_INT 22
12893: PUSH
12894: LD_OWVAR 2
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 21
12905: PUSH
12906: LD_INT 3
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PPUSH
12917: CALL_OW 69
12921: ST_TO_ADDR
// if not tmp then
12922: LD_VAR 0 1
12926: NOT
12927: IFFALSE 12931
// exit ;
12929: GO 12957
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: PPUSH
12939: LD_VAR 0 1
12943: PPUSH
12944: CALL_OW 12
12948: ARRAY
12949: PPUSH
12950: LD_INT 100
12952: PPUSH
12953: CALL_OW 234
// end ;
12957: PPOPN 1
12959: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12960: LD_EXP 27
12964: PUSH
12965: LD_EXP 41
12969: AND
12970: IFFALSE 13068
12972: GO 12974
12974: DISABLE
12975: LD_INT 0
12977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12978: LD_ADDR_VAR 0 1
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_OWVAR 2
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 21
12997: PUSH
12998: LD_INT 1
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PPUSH
13009: CALL_OW 69
13013: ST_TO_ADDR
// if not tmp then
13014: LD_VAR 0 1
13018: NOT
13019: IFFALSE 13023
// exit ;
13021: GO 13068
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13023: LD_VAR 0 1
13027: PUSH
13028: LD_INT 1
13030: PPUSH
13031: LD_VAR 0 1
13035: PPUSH
13036: CALL_OW 12
13040: ARRAY
13041: PPUSH
13042: LD_INT 1
13044: PPUSH
13045: LD_INT 4
13047: PPUSH
13048: CALL_OW 12
13052: PPUSH
13053: LD_INT 3000
13055: PPUSH
13056: LD_INT 9000
13058: PPUSH
13059: CALL_OW 12
13063: PPUSH
13064: CALL_OW 492
// end ;
13068: PPOPN 1
13070: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13071: LD_EXP 27
13075: PUSH
13076: LD_EXP 42
13080: AND
13081: IFFALSE 13101
13083: GO 13085
13085: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13086: LD_INT 1
13088: PPUSH
13089: LD_OWVAR 2
13093: PPUSH
13094: LD_INT 0
13096: PPUSH
13097: CALL_OW 324
13101: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13102: LD_EXP 27
13106: PUSH
13107: LD_EXP 43
13111: AND
13112: IFFALSE 13195
13114: GO 13116
13116: DISABLE
13117: LD_INT 0
13119: PPUSH
13120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13121: LD_ADDR_VAR 0 2
13125: PUSH
13126: LD_INT 22
13128: PUSH
13129: LD_OWVAR 2
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 21
13140: PUSH
13141: LD_INT 3
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 69
13156: ST_TO_ADDR
// if not tmp then
13157: LD_VAR 0 2
13161: NOT
13162: IFFALSE 13166
// exit ;
13164: GO 13195
// for i in tmp do
13166: LD_ADDR_VAR 0 1
13170: PUSH
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_IN
13177: IFFALSE 13193
// SetBLevel ( i , 10 ) ;
13179: LD_VAR 0 1
13183: PPUSH
13184: LD_INT 10
13186: PPUSH
13187: CALL_OW 241
13191: GO 13176
13193: POP
13194: POP
// end ;
13195: PPOPN 2
13197: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
13198: LD_EXP 27
13202: PUSH
13203: LD_EXP 44
13207: AND
13208: IFFALSE 13319
13210: GO 13212
13212: DISABLE
13213: LD_INT 0
13215: PPUSH
13216: PPUSH
13217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13218: LD_ADDR_VAR 0 3
13222: PUSH
13223: LD_INT 22
13225: PUSH
13226: LD_OWVAR 2
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 25
13237: PUSH
13238: LD_INT 1
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: EMPTY
13246: LIST
13247: LIST
13248: PPUSH
13249: CALL_OW 69
13253: ST_TO_ADDR
// if not tmp then
13254: LD_VAR 0 3
13258: NOT
13259: IFFALSE 13263
// exit ;
13261: GO 13319
// un := tmp [ rand ( 1 , tmp ) ] ;
13263: LD_ADDR_VAR 0 2
13267: PUSH
13268: LD_VAR 0 3
13272: PUSH
13273: LD_INT 1
13275: PPUSH
13276: LD_VAR 0 3
13280: PPUSH
13281: CALL_OW 12
13285: ARRAY
13286: ST_TO_ADDR
// if Crawls ( un ) then
13287: LD_VAR 0 2
13291: PPUSH
13292: CALL_OW 318
13296: IFFALSE 13307
// ComWalk ( un ) ;
13298: LD_VAR 0 2
13302: PPUSH
13303: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13307: LD_VAR 0 2
13311: PPUSH
13312: LD_INT 5
13314: PPUSH
13315: CALL_OW 336
// end ;
13319: PPOPN 3
13321: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13322: LD_EXP 27
13326: PUSH
13327: LD_EXP 45
13331: AND
13332: PUSH
13333: LD_OWVAR 67
13337: PUSH
13338: LD_INT 3
13340: LESS
13341: AND
13342: IFFALSE 13361
13344: GO 13346
13346: DISABLE
// Difficulty := Difficulty + 1 ;
13347: LD_ADDR_OWVAR 67
13351: PUSH
13352: LD_OWVAR 67
13356: PUSH
13357: LD_INT 1
13359: PLUS
13360: ST_TO_ADDR
13361: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13362: LD_EXP 27
13366: PUSH
13367: LD_EXP 46
13371: AND
13372: IFFALSE 13475
13374: GO 13376
13376: DISABLE
13377: LD_INT 0
13379: PPUSH
// begin for i := 1 to 5 do
13380: LD_ADDR_VAR 0 1
13384: PUSH
13385: DOUBLE
13386: LD_INT 1
13388: DEC
13389: ST_TO_ADDR
13390: LD_INT 5
13392: PUSH
13393: FOR_TO
13394: IFFALSE 13473
// begin uc_nation := nation_nature ;
13396: LD_ADDR_OWVAR 21
13400: PUSH
13401: LD_INT 0
13403: ST_TO_ADDR
// uc_side := 0 ;
13404: LD_ADDR_OWVAR 20
13408: PUSH
13409: LD_INT 0
13411: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13412: LD_ADDR_OWVAR 29
13416: PUSH
13417: LD_INT 12
13419: PUSH
13420: LD_INT 12
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: ST_TO_ADDR
// hc_agressivity := 20 ;
13427: LD_ADDR_OWVAR 35
13431: PUSH
13432: LD_INT 20
13434: ST_TO_ADDR
// hc_class := class_tiger ;
13435: LD_ADDR_OWVAR 28
13439: PUSH
13440: LD_INT 14
13442: ST_TO_ADDR
// hc_gallery :=  ;
13443: LD_ADDR_OWVAR 33
13447: PUSH
13448: LD_STRING 
13450: ST_TO_ADDR
// hc_name :=  ;
13451: LD_ADDR_OWVAR 26
13455: PUSH
13456: LD_STRING 
13458: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13459: CALL_OW 44
13463: PPUSH
13464: LD_INT 0
13466: PPUSH
13467: CALL_OW 51
// end ;
13471: GO 13393
13473: POP
13474: POP
// end ;
13475: PPOPN 1
13477: END
// every 0 0$1 trigger StreamModeActive and sBomb do
13478: LD_EXP 27
13482: PUSH
13483: LD_EXP 47
13487: AND
13488: IFFALSE 13497
13490: GO 13492
13492: DISABLE
// StreamSibBomb ;
13493: CALL 13498 0 0
13497: END
// export function StreamSibBomb ; var i , x , y ; begin
13498: LD_INT 0
13500: PPUSH
13501: PPUSH
13502: PPUSH
13503: PPUSH
// result := false ;
13504: LD_ADDR_VAR 0 1
13508: PUSH
13509: LD_INT 0
13511: ST_TO_ADDR
// for i := 1 to 16 do
13512: LD_ADDR_VAR 0 2
13516: PUSH
13517: DOUBLE
13518: LD_INT 1
13520: DEC
13521: ST_TO_ADDR
13522: LD_INT 16
13524: PUSH
13525: FOR_TO
13526: IFFALSE 13725
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13528: LD_ADDR_VAR 0 3
13532: PUSH
13533: LD_INT 10
13535: PUSH
13536: LD_INT 20
13538: PUSH
13539: LD_INT 30
13541: PUSH
13542: LD_INT 40
13544: PUSH
13545: LD_INT 50
13547: PUSH
13548: LD_INT 60
13550: PUSH
13551: LD_INT 70
13553: PUSH
13554: LD_INT 80
13556: PUSH
13557: LD_INT 90
13559: PUSH
13560: LD_INT 100
13562: PUSH
13563: LD_INT 110
13565: PUSH
13566: LD_INT 120
13568: PUSH
13569: LD_INT 130
13571: PUSH
13572: LD_INT 140
13574: PUSH
13575: LD_INT 150
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: PUSH
13595: LD_INT 1
13597: PPUSH
13598: LD_INT 15
13600: PPUSH
13601: CALL_OW 12
13605: ARRAY
13606: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13607: LD_ADDR_VAR 0 4
13611: PUSH
13612: LD_INT 10
13614: PUSH
13615: LD_INT 20
13617: PUSH
13618: LD_INT 30
13620: PUSH
13621: LD_INT 40
13623: PUSH
13624: LD_INT 50
13626: PUSH
13627: LD_INT 60
13629: PUSH
13630: LD_INT 70
13632: PUSH
13633: LD_INT 80
13635: PUSH
13636: LD_INT 90
13638: PUSH
13639: LD_INT 100
13641: PUSH
13642: LD_INT 110
13644: PUSH
13645: LD_INT 120
13647: PUSH
13648: LD_INT 130
13650: PUSH
13651: LD_INT 140
13653: PUSH
13654: LD_INT 150
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: LIST
13665: LIST
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: LIST
13671: LIST
13672: LIST
13673: PUSH
13674: LD_INT 1
13676: PPUSH
13677: LD_INT 15
13679: PPUSH
13680: CALL_OW 12
13684: ARRAY
13685: ST_TO_ADDR
// if ValidHex ( x , y ) then
13686: LD_VAR 0 3
13690: PPUSH
13691: LD_VAR 0 4
13695: PPUSH
13696: CALL_OW 488
13700: IFFALSE 13723
// begin result := [ x , y ] ;
13702: LD_ADDR_VAR 0 1
13706: PUSH
13707: LD_VAR 0 3
13711: PUSH
13712: LD_VAR 0 4
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: ST_TO_ADDR
// break ;
13721: GO 13725
// end ; end ;
13723: GO 13525
13725: POP
13726: POP
// if result then
13727: LD_VAR 0 1
13731: IFFALSE 13791
// begin ToLua ( playSibBomb() ) ;
13733: LD_STRING playSibBomb()
13735: PPUSH
13736: CALL_OW 559
// wait ( 0 0$14 ) ;
13740: LD_INT 490
13742: PPUSH
13743: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13747: LD_VAR 0 1
13751: PUSH
13752: LD_INT 1
13754: ARRAY
13755: PPUSH
13756: LD_VAR 0 1
13760: PUSH
13761: LD_INT 2
13763: ARRAY
13764: PPUSH
13765: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13769: LD_VAR 0 1
13773: PUSH
13774: LD_INT 1
13776: ARRAY
13777: PPUSH
13778: LD_VAR 0 1
13782: PUSH
13783: LD_INT 2
13785: ARRAY
13786: PPUSH
13787: CALL_OW 429
// end ; end ;
13791: LD_VAR 0 1
13795: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13796: LD_EXP 27
13800: PUSH
13801: LD_EXP 49
13805: AND
13806: IFFALSE 13818
13808: GO 13810
13810: DISABLE
// YouLost (  ) ;
13811: LD_STRING 
13813: PPUSH
13814: CALL_OW 104
13818: END
// every 0 0$1 trigger StreamModeActive and sFog do
13819: LD_EXP 27
13823: PUSH
13824: LD_EXP 48
13828: AND
13829: IFFALSE 13843
13831: GO 13833
13833: DISABLE
// FogOff ( your_side ) ;
13834: LD_OWVAR 2
13838: PPUSH
13839: CALL_OW 344
13843: END
// every 0 0$1 trigger StreamModeActive and sSun do
13844: LD_EXP 27
13848: PUSH
13849: LD_EXP 50
13853: AND
13854: IFFALSE 13882
13856: GO 13858
13858: DISABLE
// begin solar_recharge_percent := 0 ;
13859: LD_ADDR_OWVAR 79
13863: PUSH
13864: LD_INT 0
13866: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13867: LD_INT 10500
13869: PPUSH
13870: CALL_OW 67
// solar_recharge_percent := 100 ;
13874: LD_ADDR_OWVAR 79
13878: PUSH
13879: LD_INT 100
13881: ST_TO_ADDR
// end ;
13882: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13883: LD_EXP 27
13887: PUSH
13888: LD_EXP 51
13892: AND
13893: IFFALSE 14132
13895: GO 13897
13897: DISABLE
13898: LD_INT 0
13900: PPUSH
13901: PPUSH
13902: PPUSH
// begin tmp := [ ] ;
13903: LD_ADDR_VAR 0 3
13907: PUSH
13908: EMPTY
13909: ST_TO_ADDR
// for i := 1 to 6 do
13910: LD_ADDR_VAR 0 1
13914: PUSH
13915: DOUBLE
13916: LD_INT 1
13918: DEC
13919: ST_TO_ADDR
13920: LD_INT 6
13922: PUSH
13923: FOR_TO
13924: IFFALSE 14029
// begin uc_nation := nation_nature ;
13926: LD_ADDR_OWVAR 21
13930: PUSH
13931: LD_INT 0
13933: ST_TO_ADDR
// uc_side := 0 ;
13934: LD_ADDR_OWVAR 20
13938: PUSH
13939: LD_INT 0
13941: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13942: LD_ADDR_OWVAR 29
13946: PUSH
13947: LD_INT 12
13949: PUSH
13950: LD_INT 12
13952: PUSH
13953: EMPTY
13954: LIST
13955: LIST
13956: ST_TO_ADDR
// hc_agressivity := 20 ;
13957: LD_ADDR_OWVAR 35
13961: PUSH
13962: LD_INT 20
13964: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13965: LD_ADDR_OWVAR 28
13969: PUSH
13970: LD_INT 17
13972: ST_TO_ADDR
// hc_gallery :=  ;
13973: LD_ADDR_OWVAR 33
13977: PUSH
13978: LD_STRING 
13980: ST_TO_ADDR
// hc_name :=  ;
13981: LD_ADDR_OWVAR 26
13985: PUSH
13986: LD_STRING 
13988: ST_TO_ADDR
// un := CreateHuman ;
13989: LD_ADDR_VAR 0 2
13993: PUSH
13994: CALL_OW 44
13998: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13999: LD_VAR 0 2
14003: PPUSH
14004: LD_INT 1
14006: PPUSH
14007: CALL_OW 51
// tmp := tmp ^ un ;
14011: LD_ADDR_VAR 0 3
14015: PUSH
14016: LD_VAR 0 3
14020: PUSH
14021: LD_VAR 0 2
14025: ADD
14026: ST_TO_ADDR
// end ;
14027: GO 13923
14029: POP
14030: POP
// repeat wait ( 0 0$1 ) ;
14031: LD_INT 35
14033: PPUSH
14034: CALL_OW 67
// for un in tmp do
14038: LD_ADDR_VAR 0 2
14042: PUSH
14043: LD_VAR 0 3
14047: PUSH
14048: FOR_IN
14049: IFFALSE 14123
// begin if IsDead ( un ) then
14051: LD_VAR 0 2
14055: PPUSH
14056: CALL_OW 301
14060: IFFALSE 14080
// begin tmp := tmp diff un ;
14062: LD_ADDR_VAR 0 3
14066: PUSH
14067: LD_VAR 0 3
14071: PUSH
14072: LD_VAR 0 2
14076: DIFF
14077: ST_TO_ADDR
// continue ;
14078: GO 14048
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 3
14087: PUSH
14088: LD_INT 22
14090: PUSH
14091: LD_INT 0
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PUSH
14098: EMPTY
14099: LIST
14100: LIST
14101: PPUSH
14102: CALL_OW 69
14106: PPUSH
14107: LD_VAR 0 2
14111: PPUSH
14112: CALL_OW 74
14116: PPUSH
14117: CALL_OW 115
// end ;
14121: GO 14048
14123: POP
14124: POP
// until not tmp ;
14125: LD_VAR 0 3
14129: NOT
14130: IFFALSE 14031
// end ;
14132: PPOPN 3
14134: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14135: LD_EXP 27
14139: PUSH
14140: LD_EXP 52
14144: AND
14145: IFFALSE 14199
14147: GO 14149
14149: DISABLE
// begin ToLua ( displayTroll(); ) ;
14150: LD_STRING displayTroll();
14152: PPUSH
14153: CALL_OW 559
// wait ( 3 3$00 ) ;
14157: LD_INT 6300
14159: PPUSH
14160: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14164: LD_STRING hideTroll();
14166: PPUSH
14167: CALL_OW 559
// wait ( 1 1$00 ) ;
14171: LD_INT 2100
14173: PPUSH
14174: CALL_OW 67
// ToLua ( displayTroll(); ) ;
14178: LD_STRING displayTroll();
14180: PPUSH
14181: CALL_OW 559
// wait ( 1 1$00 ) ;
14185: LD_INT 2100
14187: PPUSH
14188: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14192: LD_STRING hideTroll();
14194: PPUSH
14195: CALL_OW 559
// end ;
14199: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14200: LD_EXP 27
14204: PUSH
14205: LD_EXP 53
14209: AND
14210: IFFALSE 14273
14212: GO 14214
14214: DISABLE
14215: LD_INT 0
14217: PPUSH
// begin p := 0 ;
14218: LD_ADDR_VAR 0 1
14222: PUSH
14223: LD_INT 0
14225: ST_TO_ADDR
// repeat game_speed := 1 ;
14226: LD_ADDR_OWVAR 65
14230: PUSH
14231: LD_INT 1
14233: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14234: LD_INT 35
14236: PPUSH
14237: CALL_OW 67
// p := p + 1 ;
14241: LD_ADDR_VAR 0 1
14245: PUSH
14246: LD_VAR 0 1
14250: PUSH
14251: LD_INT 1
14253: PLUS
14254: ST_TO_ADDR
// until p >= 60 ;
14255: LD_VAR 0 1
14259: PUSH
14260: LD_INT 60
14262: GREATEREQUAL
14263: IFFALSE 14226
// game_speed := 4 ;
14265: LD_ADDR_OWVAR 65
14269: PUSH
14270: LD_INT 4
14272: ST_TO_ADDR
// end ;
14273: PPOPN 1
14275: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14276: LD_EXP 27
14280: PUSH
14281: LD_EXP 54
14285: AND
14286: IFFALSE 14432
14288: GO 14290
14290: DISABLE
14291: LD_INT 0
14293: PPUSH
14294: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14295: LD_ADDR_VAR 0 1
14299: PUSH
14300: LD_INT 22
14302: PUSH
14303: LD_OWVAR 2
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: LD_INT 2
14314: PUSH
14315: LD_INT 30
14317: PUSH
14318: LD_INT 0
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 30
14327: PUSH
14328: LD_INT 1
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: LIST
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PPUSH
14344: CALL_OW 69
14348: ST_TO_ADDR
// if not depot then
14349: LD_VAR 0 1
14353: NOT
14354: IFFALSE 14358
// exit ;
14356: GO 14432
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14358: LD_ADDR_VAR 0 2
14362: PUSH
14363: LD_VAR 0 1
14367: PUSH
14368: LD_INT 1
14370: PPUSH
14371: LD_VAR 0 1
14375: PPUSH
14376: CALL_OW 12
14380: ARRAY
14381: PPUSH
14382: CALL_OW 274
14386: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14387: LD_VAR 0 2
14391: PPUSH
14392: LD_INT 1
14394: PPUSH
14395: LD_INT 0
14397: PPUSH
14398: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14402: LD_VAR 0 2
14406: PPUSH
14407: LD_INT 2
14409: PPUSH
14410: LD_INT 0
14412: PPUSH
14413: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14417: LD_VAR 0 2
14421: PPUSH
14422: LD_INT 3
14424: PPUSH
14425: LD_INT 0
14427: PPUSH
14428: CALL_OW 277
// end ;
14432: PPOPN 2
14434: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14435: LD_EXP 27
14439: PUSH
14440: LD_EXP 55
14444: AND
14445: IFFALSE 14542
14447: GO 14449
14449: DISABLE
14450: LD_INT 0
14452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14453: LD_ADDR_VAR 0 1
14457: PUSH
14458: LD_INT 22
14460: PUSH
14461: LD_OWVAR 2
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: LD_INT 21
14472: PUSH
14473: LD_INT 1
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: LD_INT 3
14482: PUSH
14483: LD_INT 23
14485: PUSH
14486: LD_INT 0
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: PUSH
14493: EMPTY
14494: LIST
14495: LIST
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: LIST
14501: PPUSH
14502: CALL_OW 69
14506: ST_TO_ADDR
// if not tmp then
14507: LD_VAR 0 1
14511: NOT
14512: IFFALSE 14516
// exit ;
14514: GO 14542
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14516: LD_VAR 0 1
14520: PUSH
14521: LD_INT 1
14523: PPUSH
14524: LD_VAR 0 1
14528: PPUSH
14529: CALL_OW 12
14533: ARRAY
14534: PPUSH
14535: LD_INT 200
14537: PPUSH
14538: CALL_OW 234
// end ;
14542: PPOPN 1
14544: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14545: LD_EXP 27
14549: PUSH
14550: LD_EXP 56
14554: AND
14555: IFFALSE 14634
14557: GO 14559
14559: DISABLE
14560: LD_INT 0
14562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14563: LD_ADDR_VAR 0 1
14567: PUSH
14568: LD_INT 22
14570: PUSH
14571: LD_OWVAR 2
14575: PUSH
14576: EMPTY
14577: LIST
14578: LIST
14579: PUSH
14580: LD_INT 21
14582: PUSH
14583: LD_INT 2
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PPUSH
14594: CALL_OW 69
14598: ST_TO_ADDR
// if not tmp then
14599: LD_VAR 0 1
14603: NOT
14604: IFFALSE 14608
// exit ;
14606: GO 14634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14608: LD_VAR 0 1
14612: PUSH
14613: LD_INT 1
14615: PPUSH
14616: LD_VAR 0 1
14620: PPUSH
14621: CALL_OW 12
14625: ARRAY
14626: PPUSH
14627: LD_INT 60
14629: PPUSH
14630: CALL_OW 234
// end ;
14634: PPOPN 1
14636: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14637: LD_EXP 27
14641: PUSH
14642: LD_EXP 57
14646: AND
14647: IFFALSE 14746
14649: GO 14651
14651: DISABLE
14652: LD_INT 0
14654: PPUSH
14655: PPUSH
// begin enable ;
14656: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14657: LD_ADDR_VAR 0 1
14661: PUSH
14662: LD_INT 22
14664: PUSH
14665: LD_OWVAR 2
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: PUSH
14674: LD_INT 61
14676: PUSH
14677: EMPTY
14678: LIST
14679: PUSH
14680: LD_INT 33
14682: PUSH
14683: LD_INT 2
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: LIST
14694: PPUSH
14695: CALL_OW 69
14699: ST_TO_ADDR
// if not tmp then
14700: LD_VAR 0 1
14704: NOT
14705: IFFALSE 14709
// exit ;
14707: GO 14746
// for i in tmp do
14709: LD_ADDR_VAR 0 2
14713: PUSH
14714: LD_VAR 0 1
14718: PUSH
14719: FOR_IN
14720: IFFALSE 14744
// if IsControledBy ( i ) then
14722: LD_VAR 0 2
14726: PPUSH
14727: CALL_OW 312
14731: IFFALSE 14742
// ComUnlink ( i ) ;
14733: LD_VAR 0 2
14737: PPUSH
14738: CALL_OW 136
14742: GO 14719
14744: POP
14745: POP
// end ;
14746: PPOPN 2
14748: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14749: LD_EXP 27
14753: PUSH
14754: LD_EXP 58
14758: AND
14759: IFFALSE 14899
14761: GO 14763
14763: DISABLE
14764: LD_INT 0
14766: PPUSH
14767: PPUSH
// begin ToLua ( displayPowell(); ) ;
14768: LD_STRING displayPowell();
14770: PPUSH
14771: CALL_OW 559
// uc_side := 0 ;
14775: LD_ADDR_OWVAR 20
14779: PUSH
14780: LD_INT 0
14782: ST_TO_ADDR
// uc_nation := 2 ;
14783: LD_ADDR_OWVAR 21
14787: PUSH
14788: LD_INT 2
14790: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14791: LD_ADDR_OWVAR 37
14795: PUSH
14796: LD_INT 14
14798: ST_TO_ADDR
// vc_engine := engine_siberite ;
14799: LD_ADDR_OWVAR 39
14803: PUSH
14804: LD_INT 3
14806: ST_TO_ADDR
// vc_control := control_apeman ;
14807: LD_ADDR_OWVAR 38
14811: PUSH
14812: LD_INT 5
14814: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14815: LD_ADDR_OWVAR 40
14819: PUSH
14820: LD_INT 29
14822: ST_TO_ADDR
// un := CreateVehicle ;
14823: LD_ADDR_VAR 0 2
14827: PUSH
14828: CALL_OW 45
14832: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14833: LD_VAR 0 2
14837: PPUSH
14838: LD_INT 1
14840: PPUSH
14841: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14845: LD_INT 35
14847: PPUSH
14848: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
14852: LD_VAR 0 2
14856: PPUSH
14857: LD_INT 22
14859: PUSH
14860: LD_OWVAR 2
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PPUSH
14869: CALL_OW 69
14873: PPUSH
14874: LD_VAR 0 2
14878: PPUSH
14879: CALL_OW 74
14883: PPUSH
14884: CALL_OW 115
// until IsDead ( un ) ;
14888: LD_VAR 0 2
14892: PPUSH
14893: CALL_OW 301
14897: IFFALSE 14845
// end ;
14899: PPOPN 2
14901: END
// every 0 0$1 trigger StreamModeActive and sStu do
14902: LD_EXP 27
14906: PUSH
14907: LD_EXP 66
14911: AND
14912: IFFALSE 14928
14914: GO 14916
14916: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14917: LD_STRING displayStucuk();
14919: PPUSH
14920: CALL_OW 559
// ResetFog ;
14924: CALL_OW 335
// end ;
14928: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14929: LD_EXP 27
14933: PUSH
14934: LD_EXP 59
14938: AND
14939: IFFALSE 15080
14941: GO 14943
14943: DISABLE
14944: LD_INT 0
14946: PPUSH
14947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14948: LD_ADDR_VAR 0 2
14952: PUSH
14953: LD_INT 22
14955: PUSH
14956: LD_OWVAR 2
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PUSH
14965: LD_INT 21
14967: PUSH
14968: LD_INT 1
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PUSH
14975: EMPTY
14976: LIST
14977: LIST
14978: PPUSH
14979: CALL_OW 69
14983: ST_TO_ADDR
// if not tmp then
14984: LD_VAR 0 2
14988: NOT
14989: IFFALSE 14993
// exit ;
14991: GO 15080
// un := tmp [ rand ( 1 , tmp ) ] ;
14993: LD_ADDR_VAR 0 1
14997: PUSH
14998: LD_VAR 0 2
15002: PUSH
15003: LD_INT 1
15005: PPUSH
15006: LD_VAR 0 2
15010: PPUSH
15011: CALL_OW 12
15015: ARRAY
15016: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15017: LD_VAR 0 1
15021: PPUSH
15022: LD_INT 0
15024: PPUSH
15025: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15029: LD_VAR 0 1
15033: PPUSH
15034: LD_OWVAR 3
15038: PUSH
15039: LD_VAR 0 1
15043: DIFF
15044: PPUSH
15045: LD_VAR 0 1
15049: PPUSH
15050: CALL_OW 74
15054: PPUSH
15055: CALL_OW 115
// wait ( 0 0$20 ) ;
15059: LD_INT 700
15061: PPUSH
15062: CALL_OW 67
// SetSide ( un , your_side ) ;
15066: LD_VAR 0 1
15070: PPUSH
15071: LD_OWVAR 2
15075: PPUSH
15076: CALL_OW 235
// end ;
15080: PPOPN 2
15082: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15083: LD_EXP 27
15087: PUSH
15088: LD_EXP 60
15092: AND
15093: IFFALSE 15199
15095: GO 15097
15097: DISABLE
15098: LD_INT 0
15100: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15101: LD_ADDR_VAR 0 1
15105: PUSH
15106: LD_INT 22
15108: PUSH
15109: LD_OWVAR 2
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PUSH
15118: LD_INT 2
15120: PUSH
15121: LD_INT 30
15123: PUSH
15124: LD_INT 0
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 30
15133: PUSH
15134: LD_INT 1
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: LIST
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PPUSH
15150: CALL_OW 69
15154: ST_TO_ADDR
// if not depot then
15155: LD_VAR 0 1
15159: NOT
15160: IFFALSE 15164
// exit ;
15162: GO 15199
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15164: LD_VAR 0 1
15168: PUSH
15169: LD_INT 1
15171: ARRAY
15172: PPUSH
15173: CALL_OW 250
15177: PPUSH
15178: LD_VAR 0 1
15182: PUSH
15183: LD_INT 1
15185: ARRAY
15186: PPUSH
15187: CALL_OW 251
15191: PPUSH
15192: LD_INT 70
15194: PPUSH
15195: CALL_OW 495
// end ;
15199: PPOPN 1
15201: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
15202: LD_EXP 27
15206: PUSH
15207: LD_EXP 61
15211: AND
15212: IFFALSE 15423
15214: GO 15216
15216: DISABLE
15217: LD_INT 0
15219: PPUSH
15220: PPUSH
15221: PPUSH
15222: PPUSH
15223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15224: LD_ADDR_VAR 0 5
15228: PUSH
15229: LD_INT 22
15231: PUSH
15232: LD_OWVAR 2
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PUSH
15241: LD_INT 21
15243: PUSH
15244: LD_INT 1
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: PPUSH
15255: CALL_OW 69
15259: ST_TO_ADDR
// if not tmp then
15260: LD_VAR 0 5
15264: NOT
15265: IFFALSE 15269
// exit ;
15267: GO 15423
// for i in tmp do
15269: LD_ADDR_VAR 0 1
15273: PUSH
15274: LD_VAR 0 5
15278: PUSH
15279: FOR_IN
15280: IFFALSE 15421
// begin d := rand ( 0 , 5 ) ;
15282: LD_ADDR_VAR 0 4
15286: PUSH
15287: LD_INT 0
15289: PPUSH
15290: LD_INT 5
15292: PPUSH
15293: CALL_OW 12
15297: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15298: LD_ADDR_VAR 0 2
15302: PUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 250
15312: PPUSH
15313: LD_VAR 0 4
15317: PPUSH
15318: LD_INT 3
15320: PPUSH
15321: LD_INT 12
15323: PPUSH
15324: CALL_OW 12
15328: PPUSH
15329: CALL_OW 272
15333: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15334: LD_ADDR_VAR 0 3
15338: PUSH
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 251
15348: PPUSH
15349: LD_VAR 0 4
15353: PPUSH
15354: LD_INT 3
15356: PPUSH
15357: LD_INT 12
15359: PPUSH
15360: CALL_OW 12
15364: PPUSH
15365: CALL_OW 273
15369: ST_TO_ADDR
// if ValidHex ( x , y ) then
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_VAR 0 3
15379: PPUSH
15380: CALL_OW 488
15384: IFFALSE 15419
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15386: LD_VAR 0 1
15390: PPUSH
15391: LD_VAR 0 2
15395: PPUSH
15396: LD_VAR 0 3
15400: PPUSH
15401: LD_INT 3
15403: PPUSH
15404: LD_INT 6
15406: PPUSH
15407: CALL_OW 12
15411: PPUSH
15412: LD_INT 1
15414: PPUSH
15415: CALL_OW 483
// end ;
15419: GO 15279
15421: POP
15422: POP
// end ;
15423: PPOPN 5
15425: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15426: LD_EXP 27
15430: PUSH
15431: LD_EXP 62
15435: AND
15436: IFFALSE 15530
15438: GO 15440
15440: DISABLE
15441: LD_INT 0
15443: PPUSH
15444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15445: LD_ADDR_VAR 0 2
15449: PUSH
15450: LD_INT 22
15452: PUSH
15453: LD_OWVAR 2
15457: PUSH
15458: EMPTY
15459: LIST
15460: LIST
15461: PUSH
15462: LD_INT 32
15464: PUSH
15465: LD_INT 1
15467: PUSH
15468: EMPTY
15469: LIST
15470: LIST
15471: PUSH
15472: LD_INT 21
15474: PUSH
15475: LD_INT 2
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: LIST
15486: PPUSH
15487: CALL_OW 69
15491: ST_TO_ADDR
// if not tmp then
15492: LD_VAR 0 2
15496: NOT
15497: IFFALSE 15501
// exit ;
15499: GO 15530
// for i in tmp do
15501: LD_ADDR_VAR 0 1
15505: PUSH
15506: LD_VAR 0 2
15510: PUSH
15511: FOR_IN
15512: IFFALSE 15528
// SetFuel ( i , 0 ) ;
15514: LD_VAR 0 1
15518: PPUSH
15519: LD_INT 0
15521: PPUSH
15522: CALL_OW 240
15526: GO 15511
15528: POP
15529: POP
// end ;
15530: PPOPN 2
15532: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15533: LD_EXP 27
15537: PUSH
15538: LD_EXP 63
15542: AND
15543: IFFALSE 15609
15545: GO 15547
15547: DISABLE
15548: LD_INT 0
15550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15551: LD_ADDR_VAR 0 1
15555: PUSH
15556: LD_INT 22
15558: PUSH
15559: LD_OWVAR 2
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 30
15570: PUSH
15571: LD_INT 29
15573: PUSH
15574: EMPTY
15575: LIST
15576: LIST
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: PPUSH
15582: CALL_OW 69
15586: ST_TO_ADDR
// if not tmp then
15587: LD_VAR 0 1
15591: NOT
15592: IFFALSE 15596
// exit ;
15594: GO 15609
// DestroyUnit ( tmp [ 1 ] ) ;
15596: LD_VAR 0 1
15600: PUSH
15601: LD_INT 1
15603: ARRAY
15604: PPUSH
15605: CALL_OW 65
// end ;
15609: PPOPN 1
15611: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15612: LD_EXP 27
15616: PUSH
15617: LD_EXP 65
15621: AND
15622: IFFALSE 15751
15624: GO 15626
15626: DISABLE
15627: LD_INT 0
15629: PPUSH
// begin uc_side := 0 ;
15630: LD_ADDR_OWVAR 20
15634: PUSH
15635: LD_INT 0
15637: ST_TO_ADDR
// uc_nation := nation_arabian ;
15638: LD_ADDR_OWVAR 21
15642: PUSH
15643: LD_INT 2
15645: ST_TO_ADDR
// hc_gallery :=  ;
15646: LD_ADDR_OWVAR 33
15650: PUSH
15651: LD_STRING 
15653: ST_TO_ADDR
// hc_name :=  ;
15654: LD_ADDR_OWVAR 26
15658: PUSH
15659: LD_STRING 
15661: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15662: LD_INT 1
15664: PPUSH
15665: LD_INT 11
15667: PPUSH
15668: LD_INT 10
15670: PPUSH
15671: CALL_OW 380
// un := CreateHuman ;
15675: LD_ADDR_VAR 0 1
15679: PUSH
15680: CALL_OW 44
15684: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15685: LD_VAR 0 1
15689: PPUSH
15690: LD_INT 1
15692: PPUSH
15693: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15697: LD_INT 35
15699: PPUSH
15700: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15704: LD_VAR 0 1
15708: PPUSH
15709: LD_INT 22
15711: PUSH
15712: LD_OWVAR 2
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: PPUSH
15721: CALL_OW 69
15725: PPUSH
15726: LD_VAR 0 1
15730: PPUSH
15731: CALL_OW 74
15735: PPUSH
15736: CALL_OW 115
// until IsDead ( un ) ;
15740: LD_VAR 0 1
15744: PPUSH
15745: CALL_OW 301
15749: IFFALSE 15697
// end ;
15751: PPOPN 1
15753: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15754: LD_EXP 27
15758: PUSH
15759: LD_EXP 67
15763: AND
15764: IFFALSE 15776
15766: GO 15768
15768: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15769: LD_STRING earthquake(getX(game), 0, 32)
15771: PPUSH
15772: CALL_OW 559
15776: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15777: LD_EXP 27
15781: PUSH
15782: LD_EXP 68
15786: AND
15787: IFFALSE 15878
15789: GO 15791
15791: DISABLE
15792: LD_INT 0
15794: PPUSH
// begin enable ;
15795: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15796: LD_ADDR_VAR 0 1
15800: PUSH
15801: LD_INT 22
15803: PUSH
15804: LD_OWVAR 2
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: LD_INT 21
15815: PUSH
15816: LD_INT 2
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: LD_INT 33
15825: PUSH
15826: LD_INT 3
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: LIST
15837: PPUSH
15838: CALL_OW 69
15842: ST_TO_ADDR
// if not tmp then
15843: LD_VAR 0 1
15847: NOT
15848: IFFALSE 15852
// exit ;
15850: GO 15878
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15852: LD_VAR 0 1
15856: PUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_VAR 0 1
15864: PPUSH
15865: CALL_OW 12
15869: ARRAY
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: CALL_OW 234
// end ;
15878: PPOPN 1
15880: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15881: LD_EXP 27
15885: PUSH
15886: LD_EXP 69
15890: AND
15891: IFFALSE 16032
15893: GO 15895
15895: DISABLE
15896: LD_INT 0
15898: PPUSH
15899: PPUSH
15900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15901: LD_ADDR_VAR 0 3
15905: PUSH
15906: LD_INT 22
15908: PUSH
15909: LD_OWVAR 2
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PUSH
15918: LD_INT 25
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: PPUSH
15932: CALL_OW 69
15936: ST_TO_ADDR
// if not tmp then
15937: LD_VAR 0 3
15941: NOT
15942: IFFALSE 15946
// exit ;
15944: GO 16032
// un := tmp [ rand ( 1 , tmp ) ] ;
15946: LD_ADDR_VAR 0 2
15950: PUSH
15951: LD_VAR 0 3
15955: PUSH
15956: LD_INT 1
15958: PPUSH
15959: LD_VAR 0 3
15963: PPUSH
15964: CALL_OW 12
15968: ARRAY
15969: ST_TO_ADDR
// if Crawls ( un ) then
15970: LD_VAR 0 2
15974: PPUSH
15975: CALL_OW 318
15979: IFFALSE 15990
// ComWalk ( un ) ;
15981: LD_VAR 0 2
15985: PPUSH
15986: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15990: LD_VAR 0 2
15994: PPUSH
15995: LD_INT 9
15997: PPUSH
15998: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
16002: LD_INT 28
16004: PPUSH
16005: LD_OWVAR 2
16009: PPUSH
16010: LD_INT 2
16012: PPUSH
16013: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
16017: LD_INT 29
16019: PPUSH
16020: LD_OWVAR 2
16024: PPUSH
16025: LD_INT 2
16027: PPUSH
16028: CALL_OW 322
// end ;
16032: PPOPN 3
16034: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
16035: LD_EXP 27
16039: PUSH
16040: LD_EXP 70
16044: AND
16045: IFFALSE 16156
16047: GO 16049
16049: DISABLE
16050: LD_INT 0
16052: PPUSH
16053: PPUSH
16054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16055: LD_ADDR_VAR 0 3
16059: PUSH
16060: LD_INT 22
16062: PUSH
16063: LD_OWVAR 2
16067: PUSH
16068: EMPTY
16069: LIST
16070: LIST
16071: PUSH
16072: LD_INT 25
16074: PUSH
16075: LD_INT 1
16077: PUSH
16078: EMPTY
16079: LIST
16080: LIST
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PPUSH
16086: CALL_OW 69
16090: ST_TO_ADDR
// if not tmp then
16091: LD_VAR 0 3
16095: NOT
16096: IFFALSE 16100
// exit ;
16098: GO 16156
// un := tmp [ rand ( 1 , tmp ) ] ;
16100: LD_ADDR_VAR 0 2
16104: PUSH
16105: LD_VAR 0 3
16109: PUSH
16110: LD_INT 1
16112: PPUSH
16113: LD_VAR 0 3
16117: PPUSH
16118: CALL_OW 12
16122: ARRAY
16123: ST_TO_ADDR
// if Crawls ( un ) then
16124: LD_VAR 0 2
16128: PPUSH
16129: CALL_OW 318
16133: IFFALSE 16144
// ComWalk ( un ) ;
16135: LD_VAR 0 2
16139: PPUSH
16140: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16144: LD_VAR 0 2
16148: PPUSH
16149: LD_INT 8
16151: PPUSH
16152: CALL_OW 336
// end ;
16156: PPOPN 3
16158: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
16159: LD_EXP 27
16163: PUSH
16164: LD_EXP 71
16168: AND
16169: IFFALSE 16313
16171: GO 16173
16173: DISABLE
16174: LD_INT 0
16176: PPUSH
16177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
16178: LD_ADDR_VAR 0 2
16182: PUSH
16183: LD_INT 22
16185: PUSH
16186: LD_OWVAR 2
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PUSH
16195: LD_INT 21
16197: PUSH
16198: LD_INT 2
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: PUSH
16205: LD_INT 2
16207: PUSH
16208: LD_INT 34
16210: PUSH
16211: LD_INT 12
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PUSH
16218: LD_INT 34
16220: PUSH
16221: LD_INT 51
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: LD_INT 34
16230: PUSH
16231: LD_INT 32
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: EMPTY
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: LIST
16248: PPUSH
16249: CALL_OW 69
16253: ST_TO_ADDR
// if not tmp then
16254: LD_VAR 0 2
16258: NOT
16259: IFFALSE 16263
// exit ;
16261: GO 16313
// for i in tmp do
16263: LD_ADDR_VAR 0 1
16267: PUSH
16268: LD_VAR 0 2
16272: PUSH
16273: FOR_IN
16274: IFFALSE 16311
// if GetCargo ( i , mat_artifact ) = 0 then
16276: LD_VAR 0 1
16280: PPUSH
16281: LD_INT 4
16283: PPUSH
16284: CALL_OW 289
16288: PUSH
16289: LD_INT 0
16291: EQUAL
16292: IFFALSE 16309
// SetCargo ( i , mat_siberit , 100 ) ;
16294: LD_VAR 0 1
16298: PPUSH
16299: LD_INT 3
16301: PPUSH
16302: LD_INT 100
16304: PPUSH
16305: CALL_OW 290
16309: GO 16273
16311: POP
16312: POP
// end ;
16313: PPOPN 2
16315: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
16316: LD_EXP 27
16320: PUSH
16321: LD_EXP 72
16325: AND
16326: IFFALSE 16479
16328: GO 16330
16330: DISABLE
16331: LD_INT 0
16333: PPUSH
16334: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
16335: LD_ADDR_VAR 0 2
16339: PUSH
16340: LD_INT 22
16342: PUSH
16343: LD_OWVAR 2
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PPUSH
16352: CALL_OW 69
16356: ST_TO_ADDR
// if not tmp then
16357: LD_VAR 0 2
16361: NOT
16362: IFFALSE 16366
// exit ;
16364: GO 16479
// for i := 1 to 2 do
16366: LD_ADDR_VAR 0 1
16370: PUSH
16371: DOUBLE
16372: LD_INT 1
16374: DEC
16375: ST_TO_ADDR
16376: LD_INT 2
16378: PUSH
16379: FOR_TO
16380: IFFALSE 16477
// begin uc_side := your_side ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_OWVAR 2
16391: ST_TO_ADDR
// uc_nation := nation_american ;
16392: LD_ADDR_OWVAR 21
16396: PUSH
16397: LD_INT 1
16399: ST_TO_ADDR
// vc_chassis := us_morphling ;
16400: LD_ADDR_OWVAR 37
16404: PUSH
16405: LD_INT 5
16407: ST_TO_ADDR
// vc_engine := engine_siberite ;
16408: LD_ADDR_OWVAR 39
16412: PUSH
16413: LD_INT 3
16415: ST_TO_ADDR
// vc_control := control_computer ;
16416: LD_ADDR_OWVAR 38
16420: PUSH
16421: LD_INT 3
16423: ST_TO_ADDR
// vc_weapon := us_double_laser ;
16424: LD_ADDR_OWVAR 40
16428: PUSH
16429: LD_INT 10
16431: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
16432: CALL_OW 45
16436: PPUSH
16437: LD_VAR 0 2
16441: PUSH
16442: LD_INT 1
16444: ARRAY
16445: PPUSH
16446: CALL_OW 250
16450: PPUSH
16451: LD_VAR 0 2
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 251
16464: PPUSH
16465: LD_INT 12
16467: PPUSH
16468: LD_INT 1
16470: PPUSH
16471: CALL_OW 50
// end ;
16475: GO 16379
16477: POP
16478: POP
// end ;
16479: PPOPN 2
16481: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
16482: LD_EXP 27
16486: PUSH
16487: LD_EXP 73
16491: AND
16492: IFFALSE 16714
16494: GO 16496
16496: DISABLE
16497: LD_INT 0
16499: PPUSH
16500: PPUSH
16501: PPUSH
16502: PPUSH
16503: PPUSH
16504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16505: LD_ADDR_VAR 0 6
16509: PUSH
16510: LD_INT 22
16512: PUSH
16513: LD_OWVAR 2
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: LD_INT 21
16524: PUSH
16525: LD_INT 1
16527: PUSH
16528: EMPTY
16529: LIST
16530: LIST
16531: PUSH
16532: LD_INT 3
16534: PUSH
16535: LD_INT 23
16537: PUSH
16538: LD_INT 0
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: PPUSH
16554: CALL_OW 69
16558: ST_TO_ADDR
// if not tmp then
16559: LD_VAR 0 6
16563: NOT
16564: IFFALSE 16568
// exit ;
16566: GO 16714
// s1 := rand ( 1 , 4 ) ;
16568: LD_ADDR_VAR 0 2
16572: PUSH
16573: LD_INT 1
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 12
16583: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
16584: LD_ADDR_VAR 0 4
16588: PUSH
16589: LD_VAR 0 6
16593: PUSH
16594: LD_INT 1
16596: ARRAY
16597: PPUSH
16598: LD_VAR 0 2
16602: PPUSH
16603: CALL_OW 259
16607: ST_TO_ADDR
// if s1 = 1 then
16608: LD_VAR 0 2
16612: PUSH
16613: LD_INT 1
16615: EQUAL
16616: IFFALSE 16636
// s2 := rand ( 2 , 4 ) else
16618: LD_ADDR_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: PPUSH
16626: LD_INT 4
16628: PPUSH
16629: CALL_OW 12
16633: ST_TO_ADDR
16634: GO 16644
// s2 := 1 ;
16636: LD_ADDR_VAR 0 3
16640: PUSH
16641: LD_INT 1
16643: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16644: LD_ADDR_VAR 0 5
16648: PUSH
16649: LD_VAR 0 6
16653: PUSH
16654: LD_INT 1
16656: ARRAY
16657: PPUSH
16658: LD_VAR 0 3
16662: PPUSH
16663: CALL_OW 259
16667: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16668: LD_VAR 0 6
16672: PUSH
16673: LD_INT 1
16675: ARRAY
16676: PPUSH
16677: LD_VAR 0 2
16681: PPUSH
16682: LD_VAR 0 5
16686: PPUSH
16687: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16691: LD_VAR 0 6
16695: PUSH
16696: LD_INT 1
16698: ARRAY
16699: PPUSH
16700: LD_VAR 0 3
16704: PPUSH
16705: LD_VAR 0 4
16709: PPUSH
16710: CALL_OW 237
// end ;
16714: PPOPN 6
16716: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16717: LD_EXP 27
16721: PUSH
16722: LD_EXP 74
16726: AND
16727: IFFALSE 16806
16729: GO 16731
16731: DISABLE
16732: LD_INT 0
16734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16735: LD_ADDR_VAR 0 1
16739: PUSH
16740: LD_INT 22
16742: PUSH
16743: LD_OWVAR 2
16747: PUSH
16748: EMPTY
16749: LIST
16750: LIST
16751: PUSH
16752: LD_INT 30
16754: PUSH
16755: LD_INT 3
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PPUSH
16766: CALL_OW 69
16770: ST_TO_ADDR
// if not tmp then
16771: LD_VAR 0 1
16775: NOT
16776: IFFALSE 16780
// exit ;
16778: GO 16806
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16780: LD_VAR 0 1
16784: PUSH
16785: LD_INT 1
16787: PPUSH
16788: LD_VAR 0 1
16792: PPUSH
16793: CALL_OW 12
16797: ARRAY
16798: PPUSH
16799: LD_INT 1
16801: PPUSH
16802: CALL_OW 234
// end ;
16806: PPOPN 1
16808: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16809: LD_EXP 27
16813: PUSH
16814: LD_EXP 75
16818: AND
16819: IFFALSE 16931
16821: GO 16823
16823: DISABLE
16824: LD_INT 0
16826: PPUSH
16827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16828: LD_ADDR_VAR 0 2
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_OWVAR 2
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: PUSH
16845: LD_INT 2
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 27
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 30
16860: PUSH
16861: LD_INT 26
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PUSH
16868: LD_INT 30
16870: PUSH
16871: LD_INT 28
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: LIST
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PPUSH
16888: CALL_OW 69
16892: ST_TO_ADDR
// if not tmp then
16893: LD_VAR 0 2
16897: NOT
16898: IFFALSE 16902
// exit ;
16900: GO 16931
// for i in tmp do
16902: LD_ADDR_VAR 0 1
16906: PUSH
16907: LD_VAR 0 2
16911: PUSH
16912: FOR_IN
16913: IFFALSE 16929
// SetLives ( i , 1 ) ;
16915: LD_VAR 0 1
16919: PPUSH
16920: LD_INT 1
16922: PPUSH
16923: CALL_OW 234
16927: GO 16912
16929: POP
16930: POP
// end ;
16931: PPOPN 2
16933: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16934: LD_EXP 27
16938: PUSH
16939: LD_EXP 76
16943: AND
16944: IFFALSE 17218
16946: GO 16948
16948: DISABLE
16949: LD_INT 0
16951: PPUSH
16952: PPUSH
16953: PPUSH
// begin i := rand ( 1 , 7 ) ;
16954: LD_ADDR_VAR 0 1
16958: PUSH
16959: LD_INT 1
16961: PPUSH
16962: LD_INT 7
16964: PPUSH
16965: CALL_OW 12
16969: ST_TO_ADDR
// case i of 1 :
16970: LD_VAR 0 1
16974: PUSH
16975: LD_INT 1
16977: DOUBLE
16978: EQUAL
16979: IFTRUE 16983
16981: GO 16993
16983: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16984: LD_STRING earthquake(getX(game), 0, 32)
16986: PPUSH
16987: CALL_OW 559
16991: GO 17218
16993: LD_INT 2
16995: DOUBLE
16996: EQUAL
16997: IFTRUE 17001
16999: GO 17015
17001: POP
// begin ToLua ( displayStucuk(); ) ;
17002: LD_STRING displayStucuk();
17004: PPUSH
17005: CALL_OW 559
// ResetFog ;
17009: CALL_OW 335
// end ; 3 :
17013: GO 17218
17015: LD_INT 3
17017: DOUBLE
17018: EQUAL
17019: IFTRUE 17023
17021: GO 17127
17023: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17024: LD_ADDR_VAR 0 2
17028: PUSH
17029: LD_INT 22
17031: PUSH
17032: LD_OWVAR 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: LD_INT 25
17043: PUSH
17044: LD_INT 1
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: PPUSH
17055: CALL_OW 69
17059: ST_TO_ADDR
// if not tmp then
17060: LD_VAR 0 2
17064: NOT
17065: IFFALSE 17069
// exit ;
17067: GO 17218
// un := tmp [ rand ( 1 , tmp ) ] ;
17069: LD_ADDR_VAR 0 3
17073: PUSH
17074: LD_VAR 0 2
17078: PUSH
17079: LD_INT 1
17081: PPUSH
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 12
17091: ARRAY
17092: ST_TO_ADDR
// if Crawls ( un ) then
17093: LD_VAR 0 3
17097: PPUSH
17098: CALL_OW 318
17102: IFFALSE 17113
// ComWalk ( un ) ;
17104: LD_VAR 0 3
17108: PPUSH
17109: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17113: LD_VAR 0 3
17117: PPUSH
17118: LD_INT 8
17120: PPUSH
17121: CALL_OW 336
// end ; 4 :
17125: GO 17218
17127: LD_INT 4
17129: DOUBLE
17130: EQUAL
17131: IFTRUE 17135
17133: GO 17196
17135: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17136: LD_ADDR_VAR 0 2
17140: PUSH
17141: LD_INT 22
17143: PUSH
17144: LD_OWVAR 2
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: LD_INT 30
17155: PUSH
17156: LD_INT 29
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: PPUSH
17167: CALL_OW 69
17171: ST_TO_ADDR
// if not tmp then
17172: LD_VAR 0 2
17176: NOT
17177: IFFALSE 17181
// exit ;
17179: GO 17218
// DestroyUnit ( tmp [ 1 ] ) ;
17181: LD_VAR 0 2
17185: PUSH
17186: LD_INT 1
17188: ARRAY
17189: PPUSH
17190: CALL_OW 65
// end ; 5 .. 7 :
17194: GO 17218
17196: LD_INT 5
17198: DOUBLE
17199: GREATEREQUAL
17200: IFFALSE 17208
17202: LD_INT 7
17204: DOUBLE
17205: LESSEQUAL
17206: IFTRUE 17210
17208: GO 17217
17210: POP
// StreamSibBomb ; end ;
17211: CALL 13498 0 0
17215: GO 17218
17217: POP
// end ;
17218: PPOPN 3
17220: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
17221: LD_EXP 27
17225: PUSH
17226: LD_EXP 77
17230: AND
17231: IFFALSE 17387
17233: GO 17235
17235: DISABLE
17236: LD_INT 0
17238: PPUSH
17239: PPUSH
17240: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
17241: LD_ADDR_VAR 0 2
17245: PUSH
17246: LD_INT 81
17248: PUSH
17249: LD_OWVAR 2
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: PUSH
17258: LD_INT 2
17260: PUSH
17261: LD_INT 21
17263: PUSH
17264: LD_INT 1
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: LD_INT 21
17273: PUSH
17274: LD_INT 2
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: LIST
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PPUSH
17290: CALL_OW 69
17294: ST_TO_ADDR
// if not tmp then
17295: LD_VAR 0 2
17299: NOT
17300: IFFALSE 17304
// exit ;
17302: GO 17387
// p := 0 ;
17304: LD_ADDR_VAR 0 3
17308: PUSH
17309: LD_INT 0
17311: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17312: LD_INT 35
17314: PPUSH
17315: CALL_OW 67
// p := p + 1 ;
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_VAR 0 3
17328: PUSH
17329: LD_INT 1
17331: PLUS
17332: ST_TO_ADDR
// for i in tmp do
17333: LD_ADDR_VAR 0 1
17337: PUSH
17338: LD_VAR 0 2
17342: PUSH
17343: FOR_IN
17344: IFFALSE 17375
// if GetLives ( i ) < 1000 then
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 256
17355: PUSH
17356: LD_INT 1000
17358: LESS
17359: IFFALSE 17373
// SetLives ( i , 1000 ) ;
17361: LD_VAR 0 1
17365: PPUSH
17366: LD_INT 1000
17368: PPUSH
17369: CALL_OW 234
17373: GO 17343
17375: POP
17376: POP
// until p > 20 ;
17377: LD_VAR 0 3
17381: PUSH
17382: LD_INT 20
17384: GREATER
17385: IFFALSE 17312
// end ;
17387: PPOPN 3
17389: END
// every 0 0$1 trigger StreamModeActive and sTime do
17390: LD_EXP 27
17394: PUSH
17395: LD_EXP 78
17399: AND
17400: IFFALSE 17435
17402: GO 17404
17404: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
17405: LD_INT 28
17407: PPUSH
17408: LD_OWVAR 2
17412: PPUSH
17413: LD_INT 2
17415: PPUSH
17416: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
17420: LD_INT 30
17422: PPUSH
17423: LD_OWVAR 2
17427: PPUSH
17428: LD_INT 2
17430: PPUSH
17431: CALL_OW 322
// end ;
17435: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
17436: LD_EXP 27
17440: PUSH
17441: LD_EXP 79
17445: AND
17446: IFFALSE 17567
17448: GO 17450
17450: DISABLE
17451: LD_INT 0
17453: PPUSH
17454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17455: LD_ADDR_VAR 0 2
17459: PUSH
17460: LD_INT 22
17462: PUSH
17463: LD_OWVAR 2
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: PUSH
17472: LD_INT 21
17474: PUSH
17475: LD_INT 1
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 3
17484: PUSH
17485: LD_INT 23
17487: PUSH
17488: LD_INT 0
17490: PUSH
17491: EMPTY
17492: LIST
17493: LIST
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: PUSH
17499: EMPTY
17500: LIST
17501: LIST
17502: LIST
17503: PPUSH
17504: CALL_OW 69
17508: ST_TO_ADDR
// if not tmp then
17509: LD_VAR 0 2
17513: NOT
17514: IFFALSE 17518
// exit ;
17516: GO 17567
// for i in tmp do
17518: LD_ADDR_VAR 0 1
17522: PUSH
17523: LD_VAR 0 2
17527: PUSH
17528: FOR_IN
17529: IFFALSE 17565
// begin if Crawls ( i ) then
17531: LD_VAR 0 1
17535: PPUSH
17536: CALL_OW 318
17540: IFFALSE 17551
// ComWalk ( i ) ;
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 138
// SetClass ( i , 2 ) ;
17551: LD_VAR 0 1
17555: PPUSH
17556: LD_INT 2
17558: PPUSH
17559: CALL_OW 336
// end ;
17563: GO 17528
17565: POP
17566: POP
// end ;
17567: PPOPN 2
17569: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
17570: LD_EXP 27
17574: PUSH
17575: LD_EXP 80
17579: AND
17580: IFFALSE 17861
17582: GO 17584
17584: DISABLE
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
17590: LD_OWVAR 2
17594: PPUSH
17595: LD_INT 9
17597: PPUSH
17598: LD_INT 1
17600: PPUSH
17601: LD_INT 1
17603: PPUSH
17604: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17608: LD_INT 9
17610: PPUSH
17611: LD_OWVAR 2
17615: PPUSH
17616: CALL_OW 343
// uc_side := 9 ;
17620: LD_ADDR_OWVAR 20
17624: PUSH
17625: LD_INT 9
17627: ST_TO_ADDR
// uc_nation := 2 ;
17628: LD_ADDR_OWVAR 21
17632: PUSH
17633: LD_INT 2
17635: ST_TO_ADDR
// hc_name := Dark Warrior ;
17636: LD_ADDR_OWVAR 26
17640: PUSH
17641: LD_STRING Dark Warrior
17643: ST_TO_ADDR
// hc_gallery :=  ;
17644: LD_ADDR_OWVAR 33
17648: PUSH
17649: LD_STRING 
17651: ST_TO_ADDR
// hc_noskilllimit := true ;
17652: LD_ADDR_OWVAR 76
17656: PUSH
17657: LD_INT 1
17659: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
17660: LD_ADDR_OWVAR 31
17664: PUSH
17665: LD_INT 30
17667: PUSH
17668: LD_INT 30
17670: PUSH
17671: LD_INT 30
17673: PUSH
17674: LD_INT 30
17676: PUSH
17677: EMPTY
17678: LIST
17679: LIST
17680: LIST
17681: LIST
17682: ST_TO_ADDR
// un := CreateHuman ;
17683: LD_ADDR_VAR 0 3
17687: PUSH
17688: CALL_OW 44
17692: ST_TO_ADDR
// hc_noskilllimit := false ;
17693: LD_ADDR_OWVAR 76
17697: PUSH
17698: LD_INT 0
17700: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17701: LD_VAR 0 3
17705: PPUSH
17706: LD_INT 1
17708: PPUSH
17709: CALL_OW 51
// p := 0 ;
17713: LD_ADDR_VAR 0 2
17717: PUSH
17718: LD_INT 0
17720: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17721: LD_INT 35
17723: PPUSH
17724: CALL_OW 67
// p := p + 1 ;
17728: LD_ADDR_VAR 0 2
17732: PUSH
17733: LD_VAR 0 2
17737: PUSH
17738: LD_INT 1
17740: PLUS
17741: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
17742: LD_VAR 0 3
17746: PPUSH
17747: CALL_OW 256
17751: PUSH
17752: LD_INT 1000
17754: LESS
17755: IFFALSE 17769
// SetLives ( un , 1000 ) ;
17757: LD_VAR 0 3
17761: PPUSH
17762: LD_INT 1000
17764: PPUSH
17765: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
17769: LD_VAR 0 3
17773: PPUSH
17774: LD_INT 81
17776: PUSH
17777: LD_OWVAR 2
17781: PUSH
17782: EMPTY
17783: LIST
17784: LIST
17785: PUSH
17786: LD_INT 91
17788: PUSH
17789: LD_VAR 0 3
17793: PUSH
17794: LD_INT 30
17796: PUSH
17797: EMPTY
17798: LIST
17799: LIST
17800: LIST
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: PPUSH
17806: CALL_OW 69
17810: PPUSH
17811: LD_VAR 0 3
17815: PPUSH
17816: CALL_OW 74
17820: PPUSH
17821: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17825: LD_VAR 0 2
17829: PUSH
17830: LD_INT 60
17832: GREATER
17833: PUSH
17834: LD_VAR 0 3
17838: PPUSH
17839: CALL_OW 301
17843: OR
17844: IFFALSE 17721
// if un then
17846: LD_VAR 0 3
17850: IFFALSE 17861
// RemoveUnit ( un ) ;
17852: LD_VAR 0 3
17856: PPUSH
17857: CALL_OW 64
// end ; end_of_file
17861: PPOPN 3
17863: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
17864: LD_INT 0
17866: PPUSH
17867: PPUSH
17868: PPUSH
17869: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17870: LD_VAR 0 1
17874: PPUSH
17875: CALL_OW 264
17879: PUSH
17880: LD_EXP 18
17884: EQUAL
17885: IFFALSE 17957
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17887: LD_INT 68
17889: PPUSH
17890: LD_VAR 0 1
17894: PPUSH
17895: CALL_OW 255
17899: PPUSH
17900: CALL_OW 321
17904: PUSH
17905: LD_INT 2
17907: EQUAL
17908: IFFALSE 17920
// eff := 70 else
17910: LD_ADDR_VAR 0 4
17914: PUSH
17915: LD_INT 70
17917: ST_TO_ADDR
17918: GO 17928
// eff := 30 ;
17920: LD_ADDR_VAR 0 4
17924: PUSH
17925: LD_INT 30
17927: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17928: LD_VAR 0 1
17932: PPUSH
17933: CALL_OW 250
17937: PPUSH
17938: LD_VAR 0 1
17942: PPUSH
17943: CALL_OW 251
17947: PPUSH
17948: LD_VAR 0 4
17952: PPUSH
17953: CALL_OW 495
// end ; end ;
17957: LD_VAR 0 2
17961: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
17962: LD_INT 0
17964: PPUSH
// end ;
17965: LD_VAR 0 4
17969: RET
// export function SOS_Command ( cmd ) ; begin
17970: LD_INT 0
17972: PPUSH
// end ;
17973: LD_VAR 0 2
17977: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
17978: LD_VAR 0 1
17982: PUSH
17983: LD_INT 255
17985: EQUAL
17986: PUSH
17987: LD_VAR 0 2
17991: PPUSH
17992: CALL_OW 264
17996: PUSH
17997: LD_INT 14
17999: PUSH
18000: LD_INT 53
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: IN
18007: AND
18008: PUSH
18009: LD_VAR 0 4
18013: PPUSH
18014: LD_VAR 0 5
18018: PPUSH
18019: CALL_OW 488
18023: AND
18024: IFFALSE 18048
// CutTreeXYR ( unit , x , y , 12 ) ;
18026: LD_VAR 0 2
18030: PPUSH
18031: LD_VAR 0 4
18035: PPUSH
18036: LD_VAR 0 5
18040: PPUSH
18041: LD_INT 12
18043: PPUSH
18044: CALL 18051 0 4
// end ;
18048: PPOPN 5
18050: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18051: LD_INT 0
18053: PPUSH
18054: PPUSH
18055: PPUSH
18056: PPUSH
18057: PPUSH
18058: PPUSH
18059: PPUSH
18060: PPUSH
18061: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18062: LD_VAR 0 1
18066: NOT
18067: PUSH
18068: LD_VAR 0 2
18072: PPUSH
18073: LD_VAR 0 3
18077: PPUSH
18078: CALL_OW 488
18082: NOT
18083: OR
18084: PUSH
18085: LD_VAR 0 4
18089: NOT
18090: OR
18091: IFFALSE 18095
// exit ;
18093: GO 18435
// list := [ ] ;
18095: LD_ADDR_VAR 0 13
18099: PUSH
18100: EMPTY
18101: ST_TO_ADDR
// if x - r < 0 then
18102: LD_VAR 0 2
18106: PUSH
18107: LD_VAR 0 4
18111: MINUS
18112: PUSH
18113: LD_INT 0
18115: LESS
18116: IFFALSE 18128
// min_x := 0 else
18118: LD_ADDR_VAR 0 7
18122: PUSH
18123: LD_INT 0
18125: ST_TO_ADDR
18126: GO 18144
// min_x := x - r ;
18128: LD_ADDR_VAR 0 7
18132: PUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: MINUS
18143: ST_TO_ADDR
// if y - r < 0 then
18144: LD_VAR 0 3
18148: PUSH
18149: LD_VAR 0 4
18153: MINUS
18154: PUSH
18155: LD_INT 0
18157: LESS
18158: IFFALSE 18170
// min_y := 0 else
18160: LD_ADDR_VAR 0 8
18164: PUSH
18165: LD_INT 0
18167: ST_TO_ADDR
18168: GO 18186
// min_y := y - r ;
18170: LD_ADDR_VAR 0 8
18174: PUSH
18175: LD_VAR 0 3
18179: PUSH
18180: LD_VAR 0 4
18184: MINUS
18185: ST_TO_ADDR
// max_x := x + r ;
18186: LD_ADDR_VAR 0 9
18190: PUSH
18191: LD_VAR 0 2
18195: PUSH
18196: LD_VAR 0 4
18200: PLUS
18201: ST_TO_ADDR
// max_y := y + r ;
18202: LD_ADDR_VAR 0 10
18206: PUSH
18207: LD_VAR 0 3
18211: PUSH
18212: LD_VAR 0 4
18216: PLUS
18217: ST_TO_ADDR
// for _x = min_x to max_x do
18218: LD_ADDR_VAR 0 11
18222: PUSH
18223: DOUBLE
18224: LD_VAR 0 7
18228: DEC
18229: ST_TO_ADDR
18230: LD_VAR 0 9
18234: PUSH
18235: FOR_TO
18236: IFFALSE 18353
// for _y = min_y to max_y do
18238: LD_ADDR_VAR 0 12
18242: PUSH
18243: DOUBLE
18244: LD_VAR 0 8
18248: DEC
18249: ST_TO_ADDR
18250: LD_VAR 0 10
18254: PUSH
18255: FOR_TO
18256: IFFALSE 18349
// begin if not ValidHex ( _x , _y ) then
18258: LD_VAR 0 11
18262: PPUSH
18263: LD_VAR 0 12
18267: PPUSH
18268: CALL_OW 488
18272: NOT
18273: IFFALSE 18277
// continue ;
18275: GO 18255
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18277: LD_VAR 0 11
18281: PPUSH
18282: LD_VAR 0 12
18286: PPUSH
18287: CALL_OW 351
18291: PUSH
18292: LD_VAR 0 11
18296: PPUSH
18297: LD_VAR 0 12
18301: PPUSH
18302: CALL_OW 554
18306: AND
18307: IFFALSE 18347
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18309: LD_ADDR_VAR 0 13
18313: PUSH
18314: LD_VAR 0 13
18318: PPUSH
18319: LD_VAR 0 13
18323: PUSH
18324: LD_INT 1
18326: PLUS
18327: PPUSH
18328: LD_VAR 0 11
18332: PUSH
18333: LD_VAR 0 12
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PPUSH
18342: CALL_OW 2
18346: ST_TO_ADDR
// end ;
18347: GO 18255
18349: POP
18350: POP
18351: GO 18235
18353: POP
18354: POP
// if not list then
18355: LD_VAR 0 13
18359: NOT
18360: IFFALSE 18364
// exit ;
18362: GO 18435
// for i in list do
18364: LD_ADDR_VAR 0 6
18368: PUSH
18369: LD_VAR 0 13
18373: PUSH
18374: FOR_IN
18375: IFFALSE 18433
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18377: LD_VAR 0 1
18381: PPUSH
18382: LD_STRING M
18384: PUSH
18385: LD_VAR 0 6
18389: PUSH
18390: LD_INT 1
18392: ARRAY
18393: PUSH
18394: LD_VAR 0 6
18398: PUSH
18399: LD_INT 2
18401: ARRAY
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 0
18408: PUSH
18409: LD_INT 0
18411: PUSH
18412: LD_INT 0
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: PPUSH
18427: CALL_OW 447
18431: GO 18374
18433: POP
18434: POP
// end ;
18435: LD_VAR 0 5
18439: RET
