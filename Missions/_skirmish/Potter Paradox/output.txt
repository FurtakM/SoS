// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 181 0 0
// PrepareAllies ;
  12: CALL 2172 0 0
// Action ;
  16: CALL 4314 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// if not Difficulty then
  41: LD_OWVAR 67
  45: NOT
  46: IFFALSE 56
// Difficulty := 2 ;
  48: LD_ADDR_OWVAR 67
  52: PUSH
  53: LD_INT 2
  55: ST_TO_ADDR
// InitVariables ;
  56: CALL 69 0 0
// SetDiplomacy ;
  60: CALL 133 0 0
// end ; end_of_file
  64: LD_VAR 0 1
  68: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// points := 0 ;
  72: LD_ADDR_EXP 8
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// alert := false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// game_over := false ;
  88: LD_ADDR_EXP 7
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// wave_time := 0 0$00 ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// bonus_active := false ;
 104: LD_ADDR_EXP 11
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ignore_wave := false ;
 112: LD_ADDR_EXP 13
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// bonus_num := 0 ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// end ;
 128: LD_VAR 0 1
 132: RET
// export function SetDiplomacy ; begin
 133: LD_INT 0
 135: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 136: LD_INT 92
 138: PPUSH
 139: LD_INT 48
 141: PPUSH
 142: LD_INT 8
 144: PPUSH
 145: LD_INT 32796
 147: NEG
 148: PPUSH
 149: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 153: LD_INT 92
 155: PPUSH
 156: LD_INT 48
 158: PPUSH
 159: LD_INT 8
 161: PPUSH
 162: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 166: LD_INT 5
 168: PPUSH
 169: LD_INT 8
 171: PPUSH
 172: CALL_OW 343
// end ; end_of_file
 176: LD_VAR 0 1
 180: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
 198: PPUSH
 199: PPUSH
 200: PPUSH
// uc_side := 2 ;
 201: LD_ADDR_OWVAR 20
 205: PUSH
 206: LD_INT 2
 208: ST_TO_ADDR
// uc_nation := nation_arabian ;
 209: LD_ADDR_OWVAR 21
 213: PUSH
 214: LD_INT 2
 216: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 1
 222: PPUSH
 223: LD_INT 6
 225: PPUSH
 226: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 230: LD_ADDR_OWVAR 26
 234: PUSH
 235: LD_STRING Nicolas Vervecken
 237: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 238: LD_ADDR_OWVAR 33
 242: PUSH
 243: LD_STRING SecondCharsGal
 245: ST_TO_ADDR
// hc_face_number := 3 ;
 246: LD_ADDR_OWVAR 34
 250: PUSH
 251: LD_INT 3
 253: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 254: LD_ADDR_OWVAR 29
 258: PUSH
 259: LD_INT 11
 261: PUSH
 262: LD_INT 10
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: ST_TO_ADDR
// Vervecken := CreateHuman ;
 269: LD_ADDR_EXP 10
 273: PUSH
 274: CALL_OW 44
 278: ST_TO_ADDR
// InitHc ;
 279: CALL_OW 19
// uc_side := 8 ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_INT 8
 290: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 291: LD_INT 23
 293: PPUSH
 294: CALL_OW 274
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 4000
 304: PUSH
 305: LD_INT 2500
 307: PUSH
 308: LD_INT 1250
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_OWVAR 67
 320: ARRAY
 321: PPUSH
 322: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 326: LD_INT 23
 328: PPUSH
 329: CALL_OW 274
 333: PPUSH
 334: LD_INT 2
 336: PPUSH
 337: LD_INT 300
 339: PPUSH
 340: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 344: LD_INT 23
 346: PPUSH
 347: CALL_OW 274
 351: PPUSH
 352: LD_INT 3
 354: PPUSH
 355: LD_INT 100
 357: PUSH
 358: LD_INT 50
 360: PUSH
 361: LD_INT 30
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: PUSH
 369: LD_OWVAR 67
 373: ARRAY
 374: PPUSH
 375: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 379: LD_ADDR_VAR 0 14
 383: PUSH
 384: LD_INT 23
 386: PPUSH
 387: CALL_OW 250
 391: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 392: LD_ADDR_VAR 0 15
 396: PUSH
 397: LD_INT 23
 399: PPUSH
 400: CALL_OW 251
 404: ST_TO_ADDR
// team := [ ] ;
 405: LD_ADDR_VAR 0 7
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 412: LD_ADDR_VAR 0 8
 416: PUSH
 417: LD_INT 9
 419: PUSH
 420: LD_INT 8
 422: PUSH
 423: LD_INT 7
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_OWVAR 67
 435: ARRAY
 436: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 437: LD_ADDR_VAR 0 9
 441: PUSH
 442: LD_INT 11
 444: PUSH
 445: LD_INT 9
 447: PUSH
 448: LD_INT 8
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_OWVAR 67
 460: ARRAY
 461: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 462: LD_ADDR_VAR 0 10
 466: PUSH
 467: LD_INT 3
 469: PUSH
 470: LD_INT 2
 472: PUSH
 473: LD_INT 2
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: PUSH
 481: LD_OWVAR 67
 485: ARRAY
 486: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 487: LD_ADDR_VAR 0 11
 491: PUSH
 492: LD_INT 5
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: PUSH
 506: LD_OWVAR 67
 510: ARRAY
 511: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 512: LD_ADDR_VAR 0 12
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 2
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 537: LD_ADDR_VAR 0 13
 541: PUSH
 542: LD_INT 6
 544: PUSH
 545: LD_INT 5
 547: PUSH
 548: LD_INT 4
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 562: LD_ADDR_VAR 0 18
 566: PUSH
 567: LD_INT 13
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 26
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 14
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 25
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 14
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 5
 611: PUSH
 612: LD_INT 32
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 14
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 31
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 14
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 14
 659: PUSH
 660: LD_INT 3
 662: PUSH
 663: LD_INT 2
 665: PUSH
 666: LD_INT 25
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 13
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 18
 716: PUSH
 717: LD_OWVAR 67
 721: MINUS
 722: PUSH
 723: LD_INT 1
 725: PLUS
 726: PUSH
 727: FOR_TO
 728: IFFALSE 857
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 730: LD_ADDR_OWVAR 37
 734: PUSH
 735: LD_VAR 0 18
 739: PUSH
 740: LD_VAR 0 2
 744: ARRAY
 745: PUSH
 746: LD_INT 1
 748: ARRAY
 749: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 750: LD_ADDR_OWVAR 39
 754: PUSH
 755: LD_VAR 0 18
 759: PUSH
 760: LD_VAR 0 2
 764: ARRAY
 765: PUSH
 766: LD_INT 2
 768: ARRAY
 769: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 770: LD_ADDR_OWVAR 38
 774: PUSH
 775: LD_VAR 0 18
 779: PUSH
 780: LD_VAR 0 2
 784: ARRAY
 785: PUSH
 786: LD_INT 3
 788: ARRAY
 789: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 790: LD_ADDR_OWVAR 40
 794: PUSH
 795: LD_VAR 0 18
 799: PUSH
 800: LD_VAR 0 2
 804: ARRAY
 805: PUSH
 806: LD_INT 4
 808: ARRAY
 809: ST_TO_ADDR
// un := CreateVehicle ;
 810: LD_ADDR_VAR 0 6
 814: PUSH
 815: CALL_OW 45
 819: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 820: LD_VAR 0 6
 824: PPUSH
 825: LD_INT 0
 827: PPUSH
 828: LD_INT 5
 830: PPUSH
 831: CALL_OW 12
 835: PPUSH
 836: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 840: LD_VAR 0 6
 844: PPUSH
 845: LD_INT 7
 847: PPUSH
 848: LD_INT 0
 850: PPUSH
 851: CALL_OW 49
// end ;
 855: GO 727
 857: POP
 858: POP
// for i = 1 to ape_num do
 859: LD_ADDR_VAR 0 2
 863: PUSH
 864: DOUBLE
 865: LD_INT 1
 867: DEC
 868: ST_TO_ADDR
 869: LD_VAR 0 13
 873: PUSH
 874: FOR_TO
 875: IFFALSE 942
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_INT 16
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 1
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 8
 906: PPUSH
 907: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 911: LD_ADDR_VAR 0 7
 915: PUSH
 916: LD_VAR 0 7
 920: PPUSH
 921: LD_VAR 0 7
 925: PUSH
 926: LD_INT 1
 928: PLUS
 929: PPUSH
 930: CALL_OW 44
 934: PPUSH
 935: CALL_OW 2
 939: ST_TO_ADDR
// end ;
 940: GO 874
 942: POP
 943: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 8
 954: PPUSH
 955: CALL_OW 380
// l1 := CreateHuman ;
 959: LD_ADDR_EXP 2
 963: PUSH
 964: CALL_OW 44
 968: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 969: LD_EXP 2
 973: PPUSH
 974: LD_INT 23
 976: PPUSH
 977: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 981: LD_INT 1
 983: PPUSH
 984: LD_INT 1
 986: PPUSH
 987: LD_VAR 0 8
 991: PPUSH
 992: CALL_OW 380
// l2 := CreateHuman ;
 996: LD_ADDR_EXP 3
1000: PUSH
1001: CALL_OW 44
1005: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1006: LD_EXP 3
1010: PPUSH
1011: LD_INT 23
1013: PPUSH
1014: CALL_OW 52
// for class = 1 to 4 do
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: DOUBLE
1024: LD_INT 1
1026: DEC
1027: ST_TO_ADDR
1028: LD_INT 4
1030: PUSH
1031: FOR_TO
1032: IFFALSE 1131
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: DOUBLE
1040: LD_INT 1
1042: DEC
1043: ST_TO_ADDR
1044: LD_VAR 0 9
1048: PUSH
1049: LD_VAR 0 10
1053: PUSH
1054: LD_VAR 0 11
1058: PUSH
1059: LD_VAR 0 12
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_VAR 0 4
1074: ARRAY
1075: PUSH
1076: FOR_TO
1077: IFFALSE 1127
// begin PrepareHuman ( false , class , skill ) ;
1079: LD_INT 0
1081: PPUSH
1082: LD_VAR 0 4
1086: PPUSH
1087: LD_VAR 0 8
1091: PPUSH
1092: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 7
1105: PPUSH
1106: LD_VAR 0 7
1110: PUSH
1111: LD_INT 1
1113: PLUS
1114: PPUSH
1115: CALL_OW 44
1119: PPUSH
1120: CALL_OW 2
1124: ST_TO_ADDR
// end ;
1125: GO 1076
1127: POP
1128: POP
1129: GO 1031
1131: POP
1132: POP
// for i in team do
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 7
1142: PUSH
1143: FOR_IN
1144: IFFALSE 1620
// begin b := 0 ;
1146: LD_ADDR_VAR 0 5
1150: PUSH
1151: LD_INT 0
1153: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1154: LD_VAR 0 2
1158: PPUSH
1159: CALL_OW 257
1163: PUSH
1164: LD_INT 1
1166: DOUBLE
1167: EQUAL
1168: IFTRUE 1172
1170: GO 1279
1172: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 22
1180: PUSH
1181: LD_OWVAR 20
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 2
1192: PUSH
1193: LD_INT 30
1195: PUSH
1196: LD_INT 32
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 30
1205: PUSH
1206: LD_INT 31
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 58
1220: PUSH
1221: EMPTY
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: ST_TO_ADDR
// if not b then
1234: LD_VAR 0 5
1238: NOT
1239: IFFALSE 1277
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1241: LD_ADDR_VAR 0 5
1245: PUSH
1246: LD_INT 22
1248: PUSH
1249: LD_OWVAR 20
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// end ; class_engineer :
1277: GO 1518
1279: LD_INT 2
1281: DOUBLE
1282: EQUAL
1283: IFTRUE 1287
1285: GO 1326
1287: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_OWVAR 20
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 30
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
1324: GO 1518
1326: LD_INT 3
1328: DOUBLE
1329: EQUAL
1330: IFTRUE 1334
1332: GO 1423
1334: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1335: LD_ADDR_VAR 0 5
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_OWVAR 20
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 21
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 58
1364: PUSH
1365: EMPTY
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: ST_TO_ADDR
// if not b then
1378: LD_VAR 0 5
1382: NOT
1383: IFFALSE 1421
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1385: LD_ADDR_VAR 0 5
1389: PUSH
1390: LD_INT 22
1392: PUSH
1393: LD_OWVAR 20
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 30
1404: PUSH
1405: LD_INT 3
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL_OW 69
1420: ST_TO_ADDR
// end ; class_scientistic :
1421: GO 1518
1423: LD_INT 4
1425: DOUBLE
1426: EQUAL
1427: IFTRUE 1431
1429: GO 1470
1431: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1432: LD_ADDR_VAR 0 5
1436: PUSH
1437: LD_INT 22
1439: PUSH
1440: LD_OWVAR 20
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PPUSH
1463: CALL_OW 69
1467: ST_TO_ADDR
// end ; class_apeman_soldier :
1468: GO 1518
1470: LD_INT 15
1472: DOUBLE
1473: EQUAL
1474: IFTRUE 1478
1476: GO 1517
1478: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1479: LD_ADDR_VAR 0 5
1483: PUSH
1484: LD_INT 22
1486: PUSH
1487: LD_OWVAR 20
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 30
1498: PUSH
1499: LD_INT 5
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: ST_TO_ADDR
1515: GO 1518
1517: POP
// if b then
1518: LD_VAR 0 5
1522: IFFALSE 1593
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1524: LD_VAR 0 5
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: CALL_OW 266
1537: PUSH
1538: LD_INT 31
1540: EQUAL
1541: IFFALSE 1563
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_VAR 0 5
1552: PUSH
1553: LD_INT 1
1555: ARRAY
1556: PPUSH
1557: CALL 5028 0 2
1561: GO 1591
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1563: LD_VAR 0 2
1567: PPUSH
1568: LD_VAR 0 5
1572: PUSH
1573: LD_INT 1
1575: PPUSH
1576: LD_VAR 0 5
1580: PPUSH
1581: CALL_OW 12
1585: ARRAY
1586: PPUSH
1587: CALL_OW 52
1591: GO 1618
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1593: LD_VAR 0 2
1597: PPUSH
1598: LD_VAR 0 14
1602: PPUSH
1603: LD_VAR 0 15
1607: PPUSH
1608: LD_INT 15
1610: PPUSH
1611: LD_INT 0
1613: PPUSH
1614: CALL_OW 50
// end ;
1618: GO 1143
1620: POP
1621: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1622: LD_ADDR_VAR 0 16
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 2
1635: PUSH
1636: LD_INT 1
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PUSH
1644: LD_OWVAR 67
1648: ARRAY
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: PUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 5
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_OWVAR 67
1675: ARRAY
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: LD_INT 5
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 4
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: LIST
1697: PUSH
1698: LD_OWVAR 67
1702: ARRAY
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: LD_INT 30
1710: PUSH
1711: LD_INT 2
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_OWVAR 67
1729: ARRAY
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1741: LD_ADDR_VAR 0 2
1745: PUSH
1746: LD_INT 22
1748: PUSH
1749: LD_OWVAR 20
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 30
1760: PUSH
1761: LD_INT 32
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: PUSH
1777: FOR_IN
1778: IFFALSE 1951
// begin if weapons then
1780: LD_VAR 0 16
1784: IFFALSE 1908
// begin k := rand ( 1 , weapons ) ;
1786: LD_ADDR_VAR 0 3
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_VAR 0 16
1798: PPUSH
1799: CALL_OW 12
1803: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1804: LD_ADDR_VAR 0 17
1808: PUSH
1809: LD_VAR 0 16
1813: PUSH
1814: LD_VAR 0 3
1818: ARRAY
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1824: LD_ADDR_VAR 0 16
1828: PUSH
1829: LD_VAR 0 16
1833: PPUSH
1834: LD_VAR 0 3
1838: PPUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_VAR 0 16
1846: PUSH
1847: LD_VAR 0 3
1851: ARRAY
1852: PUSH
1853: LD_INT 2
1855: ARRAY
1856: PUSH
1857: LD_INT 1
1859: MINUS
1860: PPUSH
1861: CALL 5120 0 4
1865: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1866: LD_VAR 0 16
1870: PUSH
1871: LD_VAR 0 3
1875: ARRAY
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: PUSH
1881: LD_INT 0
1883: EQUAL
1884: IFFALSE 1906
// weapons := Delete ( weapons , k ) ;
1886: LD_ADDR_VAR 0 16
1890: PUSH
1891: LD_VAR 0 16
1895: PPUSH
1896: LD_VAR 0 3
1900: PPUSH
1901: CALL_OW 3
1905: ST_TO_ADDR
// end else
1906: GO 1935
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_INT 27
1915: PUSH
1916: LD_INT 23
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: CALL_OW 12
1933: ARRAY
1934: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1935: LD_VAR 0 2
1939: PPUSH
1940: LD_VAR 0 17
1944: PPUSH
1945: CALL_OW 431
// end ;
1949: GO 1777
1951: POP
1952: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1953: LD_INT 1
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 8
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: CALL_OW 380
// hc_gallery := potter ;
1972: LD_ADDR_OWVAR 33
1976: PUSH
1977: LD_STRING potter
1979: ST_TO_ADDR
// hc_face_number := 1 ;
1980: LD_ADDR_OWVAR 34
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// hc_importance := 100 ;
1988: LD_ADDR_OWVAR 32
1992: PUSH
1993: LD_INT 100
1995: ST_TO_ADDR
// hc_name := Mike Gerste ;
1996: LD_ADDR_OWVAR 26
2000: PUSH
2001: LD_STRING Mike Gerste
2003: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2004: LD_ADDR_OWVAR 29
2008: PUSH
2009: LD_INT 10
2011: PUSH
2012: LD_INT 11
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: ST_TO_ADDR
// legion_commander := CreateHuman ;
2019: LD_ADDR_EXP 1
2023: PUSH
2024: CALL_OW 44
2028: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2029: LD_EXP 1
2033: PPUSH
2034: LD_INT 23
2036: PPUSH
2037: CALL_OW 52
// uc_side := 5 ;
2041: LD_ADDR_OWVAR 20
2045: PUSH
2046: LD_INT 5
2048: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: LD_VAR 0 8
2059: PPUSH
2060: CALL_OW 380
// hc_gallery := potter ;
2064: LD_ADDR_OWVAR 33
2068: PUSH
2069: LD_STRING potter
2071: ST_TO_ADDR
// hc_face_number := 2 ;
2072: LD_ADDR_OWVAR 34
2076: PUSH
2077: LD_INT 2
2079: ST_TO_ADDR
// hc_importance := 0 ;
2080: LD_ADDR_OWVAR 32
2084: PUSH
2085: LD_INT 0
2087: ST_TO_ADDR
// hc_name := George Potter ;
2088: LD_ADDR_OWVAR 26
2092: PUSH
2093: LD_STRING George Potter
2095: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2096: LD_ADDR_OWVAR 29
2100: PUSH
2101: LD_INT 12
2103: PUSH
2104: LD_INT 9
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: ST_TO_ADDR
// potter := CreateHuman ;
2111: LD_ADDR_EXP 4
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2121: LD_EXP 4
2125: PPUSH
2126: LD_INT 4
2128: PPUSH
2129: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2133: LD_EXP 4
2137: PPUSH
2138: LD_INT 103
2140: PPUSH
2141: LD_INT 45
2143: PPUSH
2144: LD_INT 0
2146: PPUSH
2147: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2151: LD_EXP 4
2155: PPUSH
2156: LD_INT 23
2158: PPUSH
2159: CALL_OW 119
// InitHc ( ) ;
2163: CALL_OW 19
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
2178: PPUSH
// uc_side := 5 ;
2179: LD_ADDR_OWVAR 20
2183: PUSH
2184: LD_INT 5
2186: ST_TO_ADDR
// uc_nation := nation_arabian ;
2187: LD_ADDR_OWVAR 21
2191: PUSH
2192: LD_INT 2
2194: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2195: LD_ADDR_VAR 0 4
2199: PUSH
2200: LD_INT 22
2202: PUSH
2203: LD_OWVAR 20
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 30
2214: PUSH
2215: LD_INT 5
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PPUSH
2226: CALL_OW 69
2230: ST_TO_ADDR
// for i = 1 to 3 do
2231: LD_ADDR_VAR 0 2
2235: PUSH
2236: DOUBLE
2237: LD_INT 1
2239: DEC
2240: ST_TO_ADDR
2241: LD_INT 3
2243: PUSH
2244: FOR_TO
2245: IFFALSE 2283
// begin PrepareHuman ( false , 2 , 6 ) ;
2247: LD_INT 0
2249: PPUSH
2250: LD_INT 2
2252: PPUSH
2253: LD_INT 6
2255: PPUSH
2256: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2260: CALL_OW 44
2264: PPUSH
2265: LD_INT 27
2267: PPUSH
2268: LD_INT 22
2270: PPUSH
2271: LD_INT 5
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 50
// end ;
2281: GO 2244
2283: POP
2284: POP
// for i = 1 to 3 do
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: DOUBLE
2291: LD_INT 1
2293: DEC
2294: ST_TO_ADDR
2295: LD_INT 3
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2334
// begin PrepareHuman ( false , 1 , 6 ) ;
2301: LD_INT 0
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 6
2309: PPUSH
2310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2314: CALL_OW 44
2318: PPUSH
2319: LD_VAR 0 4
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 52
// end ;
2332: GO 2298
2334: POP
2335: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_INT 22
2343: PUSH
2344: LD_OWVAR 20
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: LD_INT 30
2358: PUSH
2359: LD_INT 31
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 30
2368: PUSH
2369: LD_INT 32
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2478
// begin PrepareHuman ( false , 1 , 6 ) ;
2393: LD_INT 0
2395: PPUSH
2396: LD_INT 1
2398: PPUSH
2399: LD_INT 6
2401: PPUSH
2402: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2406: CALL_OW 44
2410: PPUSH
2411: LD_VAR 0 2
2415: PPUSH
2416: CALL 5028 0 2
// if GetBType ( i ) = b_bunker then
2420: LD_VAR 0 2
2424: PPUSH
2425: CALL_OW 266
2429: PUSH
2430: LD_INT 32
2432: EQUAL
2433: IFFALSE 2476
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_INT 27
2442: PUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 24
2448: PUSH
2449: LD_INT 28
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_INT 4
2465: MOD
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: ARRAY
2471: PPUSH
2472: CALL_OW 431
// end ;
2476: GO 2390
2478: POP
2479: POP
// for i = 1 to 3 do
2480: LD_ADDR_VAR 0 2
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_INT 3
2492: PUSH
2493: FOR_TO
2494: IFFALSE 2611
// begin vc_chassis := ar_half_tracked ;
2496: LD_ADDR_OWVAR 37
2500: PUSH
2501: LD_INT 14
2503: ST_TO_ADDR
// vc_engine := engine_solar ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_INT 2
2511: ST_TO_ADDR
// vc_control := control_manual ;
2512: LD_ADDR_OWVAR 38
2516: PUSH
2517: LD_INT 1
2519: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2520: LD_ADDR_OWVAR 40
2524: PUSH
2525: LD_INT 25
2527: PUSH
2528: LD_INT 27
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_VAR 0 2
2543: ARRAY
2544: ST_TO_ADDR
// un := CreateVehicle ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2555: LD_VAR 0 3
2559: PPUSH
2560: LD_INT 5
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2567: LD_VAR 0 3
2571: PPUSH
2572: LD_INT 8
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2582: LD_INT 0
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 7
2590: PPUSH
2591: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2595: CALL_OW 44
2599: PPUSH
2600: LD_VAR 0 3
2604: PPUSH
2605: CALL_OW 52
// end ;
2609: GO 2493
2611: POP
2612: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 1
2618: PPUSH
2619: LD_INT 6
2621: PPUSH
2622: CALL_OW 380
// al_commander := CreateHuman ;
2626: LD_ADDR_EXP 5
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2636: LD_EXP 5
2640: PPUSH
2641: LD_INT 22
2643: PUSH
2644: LD_OWVAR 20
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: LD_INT 0
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL_OW 69
2671: PUSH
2672: LD_INT 1
2674: ARRAY
2675: PPUSH
2676: CALL_OW 52
// InitHc ( ) ;
2680: CALL_OW 19
// end ;
2684: LD_VAR 0 1
2688: RET
// export function ChangeSide ( ) ; var i ; begin
2689: LD_INT 0
2691: PPUSH
2692: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_INT 22
2700: PUSH
2701: LD_INT 5
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2730
// SetSide ( i , 8 ) ;
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 8
2723: PPUSH
2724: CALL_OW 235
2728: GO 2713
2730: POP
2731: POP
// end ;
2732: LD_VAR 0 1
2736: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2737: LD_INT 22
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PPUSH
2747: CALL_OW 69
2751: IFFALSE 3265
2753: GO 2755
2755: DISABLE
2756: LD_INT 0
2758: PPUSH
2759: PPUSH
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 5
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: LD_INT 21
2785: PUSH
2786: LD_INT 1
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: LD_INT 21
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PPUSH
2812: CALL_OW 69
2816: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_INT 22
2824: PUSH
2825: LD_INT 5
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 30
2834: PUSH
2835: LD_INT 32
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 3
2844: PUSH
2845: LD_INT 24
2847: PUSH
2848: LD_INT 1000
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 69
2868: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 3
2881: PUSH
2882: LD_INT 54
2884: PUSH
2885: EMPTY
2886: LIST
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 25
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 72
2910: ST_TO_ADDR
// if not list then
2911: LD_VAR 0 2
2915: NOT
2916: IFFALSE 2920
// exit ;
2918: GO 3265
// for i in list do
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: PUSH
2930: FOR_IN
2931: IFFALSE 3263
// begin if b then
2933: LD_VAR 0 5
2937: IFFALSE 3016
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PUSH
2952: LD_INT 2
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 72
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3014
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2967: LD_VAR 0 4
2971: PPUSH
2972: CALL_OW 314
2976: NOT
2977: PUSH
2978: LD_VAR 0 1
2982: PPUSH
2983: CALL_OW 110
2987: PUSH
2988: LD_INT 7
2990: NONEQUAL
2991: AND
2992: IFFALSE 3012
// ComRepairBuilding ( j , b [ 1 ] ) ;
2994: LD_VAR 0 4
2998: PPUSH
2999: LD_VAR 0 5
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: PPUSH
3008: CALL_OW 130
3012: GO 2964
3014: POP
3015: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 256
3025: PUSH
3026: LD_INT 500
3028: LESS
3029: PUSH
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 110
3039: PUSH
3040: LD_INT 7
3042: EQUAL
3043: NOT
3044: AND
3045: IFFALSE 3095
// begin ComMoveToArea ( i , guard_hill ) ;
3047: LD_VAR 0 1
3051: PPUSH
3052: LD_INT 11
3054: PPUSH
3055: CALL_OW 113
// SetTag ( i , 7 ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: LD_INT 7
3066: PPUSH
3067: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 247
3080: PUSH
3081: LD_INT 2
3083: EQUAL
3084: IFFALSE 3095
// begin AddComExitVehicle ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3095: LD_VAR 0 1
3099: PPUSH
3100: CALL_OW 256
3104: PUSH
3105: LD_INT 1000
3107: EQUAL
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 110
3118: PUSH
3119: LD_INT 7
3121: EQUAL
3122: AND
3123: PUSH
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 310
3133: NOT
3134: AND
3135: PUSH
3136: LD_VAR 0 6
3140: AND
3141: IFFALSE 3169
// begin SetTag ( i , 0 ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3155: LD_VAR 0 6
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3169: LD_VAR 0 1
3173: PPUSH
3174: CALL_OW 247
3178: PUSH
3179: LD_INT 2
3181: EQUAL
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 110
3192: PUSH
3193: LD_INT 7
3195: NONEQUAL
3196: AND
3197: PUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 314
3207: NOT
3208: AND
3209: IFFALSE 3261
// if FilterAllUnits ( [ f_side , 7 ] ) then
3211: LD_INT 22
3213: PUSH
3214: LD_INT 7
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PPUSH
3221: CALL_OW 69
3225: IFFALSE 3261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_INT 22
3234: PUSH
3235: LD_INT 7
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 69
3246: PPUSH
3247: LD_VAR 0 1
3251: PPUSH
3252: CALL_OW 74
3256: PPUSH
3257: CALL_OW 115
// end ;
3261: GO 2930
3263: POP
3264: POP
// end ; end_of_file
3265: PPOPN 6
3267: END
// export function Game ; var i , val , areas , wave ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: LD_INT 5
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3306: LD_ADDR_VAR 0 3
3310: PUSH
3311: LD_INT 10
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 30
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_OWVAR 67
3329: ARRAY
3330: ST_TO_ADDR
// wave := 1 ;
3331: LD_ADDR_VAR 0 5
3335: PUSH
3336: LD_INT 1
3338: ST_TO_ADDR
// while ( game_over = false ) do
3339: LD_EXP 7
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3511
// begin repeat begin Wait ( 0 0$01 ) ;
3349: LD_INT 35
3351: PPUSH
3352: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3356: LD_ADDR_EXP 9
3360: PUSH
3361: LD_EXP 9
3365: PUSH
3366: LD_INT 35
3368: PLUS
3369: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3370: LD_INT 22
3372: PUSH
3373: LD_INT 7
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 10
3387: LESS
3388: PUSH
3389: LD_EXP 9
3393: PUSH
3394: LD_INT 21000
3396: GREATEREQUAL
3397: OR
3398: IFFALSE 3349
// wave_time := 0 0$00 ;
3400: LD_ADDR_EXP 9
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3408: LD_INT 5250
3410: PPUSH
3411: CALL_OW 67
// if not ignore_wave then
3415: LD_EXP 13
3419: NOT
3420: IFFALSE 3501
// begin for i = 1 to wave do
3422: LD_ADDR_VAR 0 2
3426: PUSH
3427: DOUBLE
3428: LD_INT 1
3430: DEC
3431: ST_TO_ADDR
3432: LD_VAR 0 5
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3483
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3440: LD_VAR 0 3
3444: PUSH
3445: LD_VAR 0 2
3449: MUL
3450: PPUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 6
3463: MOD
3464: PUSH
3465: LD_INT 1
3467: PLUS
3468: ARRAY
3469: PPUSH
3470: CALL 3516 0 2
// Wait ( 0 0$10 ) ;
3474: LD_INT 350
3476: PPUSH
3477: CALL_OW 67
// end ;
3481: GO 3437
3483: POP
3484: POP
// wave := wave + 1 ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_VAR 0 5
3494: PUSH
3495: LD_INT 1
3497: PLUS
3498: ST_TO_ADDR
// end else
3499: GO 3509
// ignore_wave := false ;
3501: LD_ADDR_EXP 13
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// end ;
3509: GO 3339
// end ;
3511: LD_VAR 0 1
3515: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3516: LD_INT 0
3518: PPUSH
3519: PPUSH
3520: PPUSH
3521: PPUSH
// uc_side := 7 ;
3522: LD_ADDR_OWVAR 20
3526: PUSH
3527: LD_INT 7
3529: ST_TO_ADDR
// uc_nation := 2 ;
3530: LD_ADDR_OWVAR 21
3534: PUSH
3535: LD_INT 2
3537: ST_TO_ADDR
// InitHc ( ) ;
3538: CALL_OW 19
// hc_gallery :=  ;
3542: LD_ADDR_OWVAR 33
3546: PUSH
3547: LD_STRING 
3549: ST_TO_ADDR
// hc_importance := 0 ;
3550: LD_ADDR_OWVAR 32
3554: PUSH
3555: LD_INT 0
3557: ST_TO_ADDR
// hc_name :=  ;
3558: LD_ADDR_OWVAR 26
3562: PUSH
3563: LD_STRING 
3565: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3566: LD_ADDR_OWVAR 29
3570: PUSH
3571: LD_INT 10
3573: PUSH
3574: LD_OWVAR 1
3578: PUSH
3579: LD_INT 21000
3581: DIV
3582: PLUS
3583: PUSH
3584: LD_INT 10
3586: PUSH
3587: LD_OWVAR 1
3591: PUSH
3592: LD_INT 21000
3594: DIV
3595: PLUS
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// for i = 1 to val do
3601: LD_ADDR_VAR 0 4
3605: PUSH
3606: DOUBLE
3607: LD_INT 1
3609: DEC
3610: ST_TO_ADDR
3611: LD_VAR 0 1
3615: PUSH
3616: FOR_TO
3617: IFFALSE 3824
// begin if i mod 9 = 0 then
3619: LD_VAR 0 4
3623: PUSH
3624: LD_INT 9
3626: MOD
3627: PUSH
3628: LD_INT 0
3630: EQUAL
3631: IFFALSE 3643
// class := class_apeman_kamikaze else
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_INT 17
3640: ST_TO_ADDR
3641: GO 3675
// if i mod 4 = 0 then
3643: LD_VAR 0 4
3647: PUSH
3648: LD_INT 4
3650: MOD
3651: PUSH
3652: LD_INT 0
3654: EQUAL
3655: IFFALSE 3667
// class := class_apeman_soldier else
3657: LD_ADDR_VAR 0 6
3661: PUSH
3662: LD_INT 15
3664: ST_TO_ADDR
3665: GO 3675
// class := class_apeman ;
3667: LD_ADDR_VAR 0 6
3671: PUSH
3672: LD_INT 12
3674: ST_TO_ADDR
// if i mod 33 = 0 then
3675: LD_VAR 0 4
3679: PUSH
3680: LD_INT 33
3682: MOD
3683: PUSH
3684: LD_INT 0
3686: EQUAL
3687: IFFALSE 3756
// begin vc_chassis := ar_half_tracked ;
3689: LD_ADDR_OWVAR 37
3693: PUSH
3694: LD_INT 14
3696: ST_TO_ADDR
// vc_control := control_apeman ;
3697: LD_ADDR_OWVAR 38
3701: PUSH
3702: LD_INT 5
3704: ST_TO_ADDR
// vc_engine := engine_combustion ;
3705: LD_ADDR_OWVAR 39
3709: PUSH
3710: LD_INT 1
3712: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3713: LD_ADDR_OWVAR 40
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: LD_INT 29
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 1
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: CALL_OW 12
3742: ARRAY
3743: ST_TO_ADDR
// un := CreateVehicle ;
3744: LD_ADDR_VAR 0 5
3748: PUSH
3749: CALL_OW 45
3753: ST_TO_ADDR
// end else
3754: GO 3781
// begin PrepareHuman ( sex_male , class , 10 ) ;
3756: LD_INT 1
3758: PPUSH
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_INT 10
3766: PPUSH
3767: CALL_OW 380
// un := CreateHuman ;
3771: LD_ADDR_VAR 0 5
3775: PUSH
3776: CALL_OW 44
3780: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3781: LD_VAR 0 5
3785: PPUSH
3786: LD_VAR 0 2
3790: PPUSH
3791: LD_INT 0
3793: PPUSH
3794: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3798: LD_VAR 0 5
3802: PPUSH
3803: CALL_OW 250
3807: PPUSH
3808: LD_VAR 0 5
3812: PPUSH
3813: CALL_OW 251
3817: PPUSH
3818: CALL_OW 494
// end ;
3822: GO 3616
3824: POP
3825: POP
// end ;
3826: LD_VAR 0 3
3830: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3831: LD_EXP 6
3835: PUSH
3836: LD_EXP 7
3840: NOT
3841: AND
3842: IFFALSE 4128
3844: GO 3846
3846: DISABLE
3847: LD_INT 0
3849: PPUSH
3850: PPUSH
3851: PPUSH
// begin enable ;
3852: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_INT 22
3860: PUSH
3861: LD_INT 7
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// if not list then
3873: LD_VAR 0 2
3877: NOT
3878: IFFALSE 3882
// exit ;
3880: GO 4128
// for i in list do
3882: LD_ADDR_VAR 0 1
3886: PUSH
3887: LD_VAR 0 2
3891: PUSH
3892: FOR_IN
3893: IFFALSE 4126
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3895: LD_ADDR_VAR 0 3
3899: PUSH
3900: LD_INT 81
3902: PUSH
3903: LD_INT 7
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 92
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 250
3922: PUSH
3923: LD_VAR 0 1
3927: PPUSH
3928: CALL_OW 251
3932: PUSH
3933: LD_INT 15
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 69
3950: ST_TO_ADDR
// if not enemy then
3951: LD_VAR 0 3
3955: NOT
3956: IFFALSE 4014
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3958: LD_ADDR_VAR 0 3
3962: PUSH
3963: LD_INT 81
3965: PUSH
3966: LD_INT 7
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 92
3975: PUSH
3976: LD_VAR 0 1
3980: PPUSH
3981: CALL_OW 250
3985: PUSH
3986: LD_VAR 0 1
3990: PPUSH
3991: CALL_OW 251
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 69
4013: ST_TO_ADDR
// if not enemy then
4014: LD_VAR 0 3
4018: NOT
4019: IFFALSE 4077
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4021: LD_ADDR_VAR 0 3
4025: PUSH
4026: LD_INT 81
4028: PUSH
4029: LD_INT 7
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 92
4038: PUSH
4039: LD_VAR 0 1
4043: PPUSH
4044: CALL_OW 250
4048: PUSH
4049: LD_VAR 0 1
4053: PPUSH
4054: CALL_OW 251
4058: PUSH
4059: LD_INT 50
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 3
4081: NOT
4082: IFFALSE 4104
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4084: LD_ADDR_VAR 0 3
4088: PUSH
4089: LD_INT 81
4091: PUSH
4092: LD_INT 7
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: ST_TO_ADDR
// if enemy then
4104: LD_VAR 0 3
4108: IFFALSE 4124
// Attack ( i , enemy ) ;
4110: LD_VAR 0 1
4114: PPUSH
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL 4131 0 2
// end ;
4124: GO 3892
4126: POP
4127: POP
// end ;
4128: PPOPN 3
4130: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4131: LD_INT 0
4133: PPUSH
4134: PPUSH
4135: PPUSH
// if not unit then
4136: LD_VAR 0 1
4140: NOT
4141: IFFALSE 4145
// exit ;
4143: GO 4309
// targets_list := [ ] ;
4145: LD_ADDR_VAR 0 5
4149: PUSH
4150: EMPTY
4151: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_VAR 0 2
4161: PPUSH
4162: LD_INT 21
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 3
4174: PUSH
4175: LD_INT 54
4177: PUSH
4178: EMPTY
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 72
4193: PUSH
4194: LD_VAR 0 2
4198: PPUSH
4199: LD_INT 21
4201: PUSH
4202: LD_INT 2
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL_OW 72
4213: PUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: LD_INT 21
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 3
4231: PUSH
4232: LD_INT 58
4234: PUSH
4235: EMPTY
4236: LIST
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 72
4250: PUSH
4251: LD_VAR 0 2
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// for target in targets_list do
4262: LD_ADDR_VAR 0 4
4266: PUSH
4267: LD_VAR 0 5
4271: PUSH
4272: FOR_IN
4273: IFFALSE 4307
// begin if target then
4275: LD_VAR 0 4
4279: IFFALSE 4305
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_VAR 0 4
4290: PPUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 74
4300: PPUSH
4301: CALL_OW 115
// end ;
4305: GO 4272
4307: POP
4308: POP
// end ; end_of_file
4309: LD_VAR 0 3
4313: RET
// export function Action ; begin
4314: LD_INT 0
4316: PPUSH
// InGameOn ;
4317: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4321: LD_INT 23
4323: PPUSH
4324: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4328: LD_EXP 1
4332: PPUSH
4333: LD_STRING DL-1
4335: PPUSH
4336: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4340: LD_EXP 2
4344: PPUSH
4345: LD_STRING DA-1
4347: PPUSH
4348: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4352: LD_EXP 3
4356: PPUSH
4357: LD_STRING DA-2
4359: PPUSH
4360: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4364: LD_EXP 1
4368: PPUSH
4369: LD_STRING DL-2
4371: PPUSH
4372: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4376: LD_EXP 3
4380: PPUSH
4381: LD_STRING DA-3
4383: PPUSH
4384: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4388: LD_EXP 1
4392: PPUSH
4393: LD_STRING DL-3
4395: PPUSH
4396: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_STRING DA-4
4407: PPUSH
4408: CALL_OW 88
// if not dialogue_skipped then
4412: LD_OWVAR 59
4416: NOT
4417: IFFALSE 4502
// begin Wait ( 0 0$01 ) ;
4419: LD_INT 35
4421: PPUSH
4422: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4426: LD_EXP 2
4430: PUSH
4431: LD_EXP 3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4444: LD_EXP 2
4448: PPUSH
4449: LD_INT 107
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4459: LD_EXP 3
4463: PPUSH
4464: LD_INT 108
4466: PPUSH
4467: LD_INT 53
4469: PPUSH
4470: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4474: LD_EXP 2
4478: PPUSH
4479: LD_EXP 4
4483: PPUSH
4484: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4488: LD_EXP 3
4492: PPUSH
4493: LD_EXP 4
4497: PPUSH
4498: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4502: LD_INT 35
4504: PPUSH
4505: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4509: LD_EXP 2
4513: PPUSH
4514: LD_INT 107
4516: PPUSH
4517: LD_INT 53
4519: PPUSH
4520: CALL_OW 307
4524: PUSH
4525: LD_OWVAR 59
4529: OR
4530: IFFALSE 4502
// if not dialogue_skipped then
4532: LD_OWVAR 59
4536: NOT
4537: IFFALSE 4638
// begin ComTurnUnit ( potter , l1 ) ;
4539: LD_EXP 4
4543: PPUSH
4544: LD_EXP 2
4548: PPUSH
4549: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4553: LD_INT 10
4555: PPUSH
4556: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4560: LD_EXP 4
4564: PPUSH
4565: LD_INT 108
4567: PPUSH
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 0
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 483
// Wait ( 0 0$01 ) ;
4581: LD_INT 35
4583: PPUSH
4584: CALL_OW 67
// RemoveUnit ( potter ) ;
4588: LD_EXP 4
4592: PPUSH
4593: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4597: LD_EXP 2
4601: PPUSH
4602: LD_STRING DA-5
4604: PPUSH
4605: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4609: LD_EXP 3
4613: PPUSH
4614: LD_STRING DA-6
4616: PPUSH
4617: CALL_OW 88
// Wait ( 0 0$02 ) ;
4621: LD_INT 70
4623: PPUSH
4624: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4628: LD_INT 25
4630: PPUSH
4631: LD_INT 19
4633: PPUSH
4634: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4638: LD_INT 30
4640: PPUSH
4641: LD_INT 1
4643: PPUSH
4644: CALL 3516 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4648: LD_EXP 5
4652: PPUSH
4653: LD_STRING DLa-1
4655: PPUSH
4656: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4660: LD_EXP 1
4664: PPUSH
4665: LD_STRING DL-5
4667: PPUSH
4668: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4672: LD_INT 23
4674: PPUSH
4675: CALL_OW 87
// InGameOff ;
4679: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4683: LD_STRING C1
4685: PPUSH
4686: CALL_OW 337
// alert := true ;
4690: LD_ADDR_EXP 6
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4698: LD_EXP 5
4702: PPUSH
4703: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4707: LD_EXP 5
4711: PPUSH
4712: LD_INT 11
4714: PPUSH
4715: CALL_OW 173
// Wait ( 0 0$30 ) ;
4719: LD_INT 1050
4721: PPUSH
4722: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4726: LD_INT 20
4728: PPUSH
4729: LD_INT 4
4731: PPUSH
4732: CALL 3516 0 2
// Wait ( 0 0$35 ) ;
4736: LD_INT 1225
4738: PPUSH
4739: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4743: LD_INT 20
4745: PPUSH
4746: LD_INT 5
4748: PPUSH
4749: CALL 3516 0 2
// Wait ( 0 0$03 ) ;
4753: LD_INT 105
4755: PPUSH
4756: CALL_OW 67
// Game ;
4760: CALL 3268 0 0
// end ;
4764: LD_VAR 0 1
4768: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4769: LD_INT 22
4771: PUSH
4772: LD_INT 7
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: PUSH
4788: LD_EXP 8
4792: PUSH
4793: LD_INT 500
4795: GREATEREQUAL
4796: AND
4797: IFFALSE 5025
4799: GO 4801
4801: DISABLE
4802: LD_INT 0
4804: PPUSH
4805: PPUSH
// begin DialogueOn ;
4806: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4810: LD_EXP 10
4814: PPUSH
4815: LD_STRING DVr-1
4817: PPUSH
4818: CALL_OW 94
// DialogueOff ;
4822: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4826: LD_STRING QBonusInfo
4828: PPUSH
4829: CALL_OW 97
4833: PUSH
4834: LD_INT 1
4836: DOUBLE
4837: EQUAL
4838: IFTRUE 4842
4840: GO 4853
4842: POP
// bonus_active := true ; end ;
4843: LD_ADDR_EXP 11
4847: PUSH
4848: LD_INT 1
4850: ST_TO_ADDR
4851: GO 4854
4853: POP
// bonus_num := 4 ;
4854: LD_ADDR_EXP 12
4858: PUSH
4859: LD_INT 4
4861: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4862: LD_OWVAR 2
4866: PPUSH
4867: LD_INT 2
4869: PPUSH
4870: LD_INT 2
4872: PPUSH
4873: LD_INT 23
4875: PPUSH
4876: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: LD_INT 500
4887: PUSH
4888: LD_INT 3500
4890: PUSH
4891: LD_INT 5750
4893: PUSH
4894: LD_INT 10000
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// repeat wait ( [ 5 5$00 , 6 6$00 , 7 7$00 ] [ Difficulty ] ) ;
4903: LD_INT 10500
4905: PUSH
4906: LD_INT 12600
4908: PUSH
4909: LD_INT 14700
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_OWVAR 67
4921: ARRAY
4922: PPUSH
4923: CALL_OW 67
// for i = 1 to tmp do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_VAR 0 1
4941: PUSH
4942: FOR_TO
4943: IFFALSE 4975
// if points >= tmp [ i ] then
4945: LD_EXP 8
4949: PUSH
4950: LD_VAR 0 1
4954: PUSH
4955: LD_VAR 0 2
4959: ARRAY
4960: GREATEREQUAL
4961: IFFALSE 4973
// bonus_num := i ;
4963: LD_ADDR_EXP 12
4967: PUSH
4968: LD_VAR 0 2
4972: ST_TO_ADDR
4973: GO 4942
4975: POP
4976: POP
// case Query ( QBonusInfo ) of 1 :
4977: LD_STRING QBonusInfo
4979: PPUSH
4980: CALL_OW 97
4984: PUSH
4985: LD_INT 1
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5014
4993: POP
// SetArtifactUse ( your_side , art_use_exclamation , art_instant , main_base ) ; end ;
4994: LD_OWVAR 2
4998: PPUSH
4999: LD_INT 12
5001: PPUSH
5002: LD_INT 2
5004: PPUSH
5005: LD_INT 23
5007: PPUSH
5008: CALL_OW 468
5012: GO 5015
5014: POP
// until points >= 15000 ;
5015: LD_EXP 8
5019: PUSH
5020: LD_INT 15000
5022: GREATEREQUAL
5023: IFFALSE 4903
// end ; end_of_file
5025: PPOPN 2
5027: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5028: LD_INT 0
5030: PPUSH
5031: PPUSH
// dir := GetDir ( b ) ;
5032: LD_ADDR_VAR 0 4
5036: PUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 254
5046: ST_TO_ADDR
// if dir < 3 then
5047: LD_VAR 0 4
5051: PUSH
5052: LD_INT 3
5054: LESS
5055: IFFALSE 5073
// dir := dir + 3 else
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: LD_VAR 0 4
5066: PUSH
5067: LD_INT 3
5069: PLUS
5070: ST_TO_ADDR
5071: GO 5087
// dir := dir - 3 ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 3
5085: MINUS
5086: ST_TO_ADDR
// SetDir ( un , dir ) ;
5087: LD_VAR 0 1
5091: PPUSH
5092: LD_VAR 0 4
5096: PPUSH
5097: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5101: LD_VAR 0 1
5105: PPUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: CALL_OW 52
// end ;
5115: LD_VAR 0 3
5119: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5125: LD_ADDR_VAR 0 7
5129: PUSH
5130: LD_VAR 0 1
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_VAR 0 3
5145: PPUSH
5146: LD_VAR 0 4
5150: PPUSH
5151: CALL_OW 1
5155: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_VAR 0 2
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 1
5180: ST_TO_ADDR
// result := tab ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_VAR 0 1
5190: ST_TO_ADDR
// end ;
5191: LD_VAR 0 5
5195: RET
// export function IsDriver ( unit ) ; begin
5196: LD_INT 0
5198: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5199: LD_VAR 0 1
5203: PUSH
5204: LD_INT 55
5206: PUSH
5207: EMPTY
5208: LIST
5209: PPUSH
5210: CALL_OW 69
5214: IN
5215: IFFALSE 5234
// result := IsInUnit ( unit ) else
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: CALL_OW 310
5231: ST_TO_ADDR
5232: GO 5242
// result := false ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: LD_INT 0
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 2
5246: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5247: LD_INT 0
5249: PPUSH
5250: PPUSH
5251: PPUSH
// if not GetControl ( veh ) = control_manual then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 263
5261: PUSH
5262: LD_INT 1
5264: EQUAL
5265: NOT
5266: IFFALSE 5278
// result := false else
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
5276: GO 5423
// if veh in FilterAllUnits ( [ f_empty ] ) then
5278: LD_VAR 0 1
5282: PUSH
5283: LD_INT 58
5285: PUSH
5286: EMPTY
5287: LIST
5288: PPUSH
5289: CALL_OW 69
5293: IN
5294: IFFALSE 5306
// result := false else
5296: LD_ADDR_VAR 0 2
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
5304: GO 5423
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5306: LD_ADDR_VAR 0 4
5310: PUSH
5311: LD_INT 22
5313: PUSH
5314: LD_VAR 0 1
5318: PPUSH
5319: CALL_OW 255
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 55
5330: PUSH
5331: EMPTY
5332: LIST
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if not filter then
5343: LD_VAR 0 4
5347: NOT
5348: IFFALSE 5360
// result := false else
5350: LD_ADDR_VAR 0 2
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
5358: GO 5423
// for i = 1 to filter do
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_VAR 0 4
5374: PUSH
5375: FOR_TO
5376: IFFALSE 5421
// if IsDriver ( filter [ i ] ) = veh then
5378: LD_VAR 0 4
5382: PUSH
5383: LD_VAR 0 3
5387: ARRAY
5388: PPUSH
5389: CALL 5196 0 1
5393: PUSH
5394: LD_VAR 0 1
5398: EQUAL
5399: IFFALSE 5419
// begin result := filter [ i ] ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: LD_VAR 0 3
5415: ARRAY
5416: ST_TO_ADDR
// break ;
5417: GO 5421
// end ;
5419: GO 5375
5421: POP
5422: POP
// end ; end ; end_of_file
5423: LD_VAR 0 2
5427: RET
// on UnitDestroyed ( un ) do begin if un in [ legion_commander , main_base ] then
5428: LD_VAR 0 1
5432: PUSH
5433: LD_EXP 1
5437: PUSH
5438: LD_INT 23
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: IN
5445: IFFALSE 5455
// game_over := true ;
5447: LD_ADDR_EXP 7
5451: PUSH
5452: LD_INT 1
5454: ST_TO_ADDR
// if un = al_commander then
5455: LD_VAR 0 1
5459: PUSH
5460: LD_EXP 5
5464: EQUAL
5465: IFFALSE 5471
// ChangeSide ( ) ;
5467: CALL 2689 0 0
// if GetSide ( un ) = 7 then
5471: LD_VAR 0 1
5475: PPUSH
5476: CALL_OW 255
5480: PUSH
5481: LD_INT 7
5483: EQUAL
5484: IFFALSE 5602
// begin if GetClass ( un ) = class_apeman then
5486: LD_VAR 0 1
5490: PPUSH
5491: CALL_OW 257
5495: PUSH
5496: LD_INT 12
5498: EQUAL
5499: IFFALSE 5515
// points := points + 6 ;
5501: LD_ADDR_EXP 8
5505: PUSH
5506: LD_EXP 8
5510: PUSH
5511: LD_INT 6
5513: PLUS
5514: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5515: LD_VAR 0 1
5519: PPUSH
5520: CALL_OW 257
5524: PUSH
5525: LD_INT 17
5527: EQUAL
5528: IFFALSE 5544
// points := points + 11 ;
5530: LD_ADDR_EXP 8
5534: PUSH
5535: LD_EXP 8
5539: PUSH
5540: LD_INT 11
5542: PLUS
5543: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5544: LD_VAR 0 1
5548: PPUSH
5549: CALL_OW 257
5553: PUSH
5554: LD_INT 15
5556: EQUAL
5557: IFFALSE 5573
// points := points + 14 ;
5559: LD_ADDR_EXP 8
5563: PUSH
5564: LD_EXP 8
5568: PUSH
5569: LD_INT 14
5571: PLUS
5572: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5573: LD_VAR 0 1
5577: PPUSH
5578: CALL_OW 247
5582: PUSH
5583: LD_INT 2
5585: EQUAL
5586: IFFALSE 5602
// points := points + 50 ;
5588: LD_ADDR_EXP 8
5592: PUSH
5593: LD_EXP 8
5597: PUSH
5598: LD_INT 50
5600: PLUS
5601: ST_TO_ADDR
// end ; end ;
5602: PPOPN 1
5604: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5605: LD_EXP 5
5609: PPUSH
5610: CALL_OW 256
5614: PUSH
5615: LD_INT 1000
5617: LESS
5618: IFFALSE 5650
5620: GO 5622
5622: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5623: LD_EXP 5
5627: PPUSH
5628: CALL_OW 504
5632: PPUSH
5633: CALL_OW 255
5637: PUSH
5638: LD_INT 8
5640: EQUAL
5641: IFFALSE 5650
// YouLost (  ) ;
5643: LD_STRING 
5645: PPUSH
5646: CALL_OW 104
5650: END
// on EnterBuilding ( b , un ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] and GetClass ( un ) in [ class_apeman , class_apeman_soldier , class_apeman_kamikaze ] then
5651: LD_VAR 0 1
5655: PPUSH
5656: CALL_OW 266
5660: PUSH
5661: LD_INT 0
5663: PUSH
5664: LD_INT 1
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: IN
5671: PUSH
5672: LD_VAR 0 2
5676: PPUSH
5677: CALL_OW 257
5681: PUSH
5682: LD_INT 12
5684: PUSH
5685: LD_INT 15
5687: PUSH
5688: LD_INT 17
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: IN
5696: AND
5697: IFFALSE 5718
// begin wait ( 0 0$0.3 ) ;
5699: LD_INT 10
5701: PPUSH
5702: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
5706: LD_VAR 0 2
5710: PPUSH
5711: LD_INT 16
5713: PPUSH
5714: CALL_OW 336
// end ; end ;
5718: PPOPN 2
5720: END
// on DialogueSkipped ( value ) do var i ;
5721: LD_INT 0
5723: PPUSH
// begin RemoveUnit ( potter ) ;
5724: LD_EXP 4
5728: PPUSH
5729: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5733: LD_EXP 2
5737: PUSH
5738: LD_EXP 3
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: PPUSH
5747: CALL_OW 122
// Wait ( 1 ) ;
5751: LD_INT 1
5753: PPUSH
5754: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5758: LD_EXP 2
5762: PPUSH
5763: LD_INT 107
5765: PPUSH
5766: LD_INT 53
5768: PPUSH
5769: LD_INT 0
5771: PPUSH
5772: LD_INT 0
5774: PPUSH
5775: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5779: LD_EXP 3
5783: PPUSH
5784: LD_INT 108
5786: PPUSH
5787: LD_INT 53
5789: PPUSH
5790: LD_INT 0
5792: PPUSH
5793: LD_INT 0
5795: PPUSH
5796: CALL_OW 483
// Wait ( 1 ) ;
5800: LD_INT 1
5802: PPUSH
5803: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5807: LD_EXP 2
5811: PUSH
5812: LD_EXP 3
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: PPUSH
5821: LD_INT 108
5823: PPUSH
5824: LD_INT 1
5826: PPUSH
5827: CALL_OW 118
// end ;
5831: PPOPN 2
5833: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5834: LD_INT 0
5836: PPUSH
5837: PPUSH
5838: PPUSH
5839: PPUSH
5840: PPUSH
5841: PPUSH
// begin DialogueOn ;
5842: CALL_OW 6
// uc_side := 8 ;
5846: LD_ADDR_OWVAR 20
5850: PUSH
5851: LD_INT 8
5853: ST_TO_ADDR
// uc_nation := 2 ;
5854: LD_ADDR_OWVAR 21
5858: PUSH
5859: LD_INT 2
5861: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5862: LD_ADDR_VAR 0 5
5866: PUSH
5867: LD_STRING QBonus
5869: PUSH
5870: LD_EXP 12
5874: STR
5875: ST_TO_ADDR
// off := true ;
5876: LD_ADDR_VAR 0 6
5880: PUSH
5881: LD_INT 1
5883: ST_TO_ADDR
// units := [ ] ;
5884: LD_ADDR_VAR 0 7
5888: PUSH
5889: EMPTY
5890: ST_TO_ADDR
// crates := 0 ;
5891: LD_ADDR_VAR 0 8
5895: PUSH
5896: LD_INT 0
5898: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5899: LD_EXP 10
5903: PPUSH
5904: LD_STRING DVr-2
5906: PPUSH
5907: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5911: LD_INT 10
5913: PPUSH
5914: CALL_OW 67
// case Query ( bonus ) of 1 :
5918: LD_VAR 0 5
5922: PPUSH
5923: CALL_OW 97
5927: PUSH
5928: LD_INT 1
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5936
5934: GO 6021
5936: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5937: LD_ADDR_VAR 0 9
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 2
5947: PUSH
5948: LD_INT 5
5950: PUSH
5951: LD_INT 8
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: PUSH
5960: LD_EXP 12
5964: ARRAY
5965: ST_TO_ADDR
// for i = 1 to tmp do
5966: LD_ADDR_VAR 0 10
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_VAR 0 9
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6017
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5984: LD_INT 0
5986: PPUSH
5987: LD_INT 15
5989: PPUSH
5990: LD_VAR 0 9
5994: PPUSH
5995: CALL_OW 380
// units := units ^ CreateHuman ;
5999: LD_ADDR_VAR 0 7
6003: PUSH
6004: LD_VAR 0 7
6008: PUSH
6009: CALL_OW 44
6013: ADD
6014: ST_TO_ADDR
// end ;
6015: GO 5981
6017: POP
6018: POP
// end ; 2 :
6019: GO 6429
6021: LD_INT 2
6023: DOUBLE
6024: EQUAL
6025: IFTRUE 6029
6027: GO 6061
6029: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
6030: LD_ADDR_VAR 0 8
6034: PUSH
6035: LD_INT 100
6037: PUSH
6038: LD_INT 150
6040: PUSH
6041: LD_INT 350
6043: PUSH
6044: LD_INT 500
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: PUSH
6053: LD_EXP 12
6057: ARRAY
6058: ST_TO_ADDR
// end ; 3 :
6059: GO 6429
6061: LD_INT 3
6063: DOUBLE
6064: EQUAL
6065: IFTRUE 6069
6067: GO 6409
6069: POP
// begin if bonus_num = 1 then
6070: LD_EXP 12
6074: PUSH
6075: LD_INT 1
6077: EQUAL
6078: IFFALSE 6088
// ignore_wave := true ;
6080: LD_ADDR_EXP 13
6084: PUSH
6085: LD_INT 1
6087: ST_TO_ADDR
// if bonus_num = 2 then
6088: LD_EXP 12
6092: PUSH
6093: LD_INT 2
6095: EQUAL
6096: IFFALSE 6216
// begin for i = 1 to 2 do
6098: LD_ADDR_VAR 0 10
6102: PUSH
6103: DOUBLE
6104: LD_INT 1
6106: DEC
6107: ST_TO_ADDR
6108: LD_INT 2
6110: PUSH
6111: FOR_TO
6112: IFFALSE 6214
// begin uc_nation := nation_arabian ;
6114: LD_ADDR_OWVAR 21
6118: PUSH
6119: LD_INT 2
6121: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6122: LD_ADDR_OWVAR 37
6126: PUSH
6127: LD_INT 14
6129: ST_TO_ADDR
// vc_engine := engine_siberite ;
6130: LD_ADDR_OWVAR 39
6134: PUSH
6135: LD_INT 3
6137: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6138: LD_ADDR_OWVAR 38
6142: PUSH
6143: LD_INT 2
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PUSH
6153: LD_INT 1
6155: PPUSH
6156: LD_INT 2
6158: PPUSH
6159: CALL_OW 12
6163: ARRAY
6164: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6165: LD_ADDR_OWVAR 40
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: LD_INT 27
6175: PUSH
6176: LD_INT 25
6178: PUSH
6179: EMPTY
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 1
6186: PPUSH
6187: LD_INT 3
6189: PPUSH
6190: CALL_OW 12
6194: ARRAY
6195: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6196: LD_ADDR_VAR 0 7
6200: PUSH
6201: LD_VAR 0 7
6205: PUSH
6206: CALL_OW 45
6210: ADD
6211: ST_TO_ADDR
// end ;
6212: GO 6111
6214: POP
6215: POP
// end ; if bonus_num = 3 then
6216: LD_EXP 12
6220: PUSH
6221: LD_INT 3
6223: EQUAL
6224: IFFALSE 6348
// begin for i = 1 to 4 do
6226: LD_ADDR_VAR 0 10
6230: PUSH
6231: DOUBLE
6232: LD_INT 1
6234: DEC
6235: ST_TO_ADDR
6236: LD_INT 4
6238: PUSH
6239: FOR_TO
6240: IFFALSE 6346
// begin uc_nation := nation_arabian ;
6242: LD_ADDR_OWVAR 21
6246: PUSH
6247: LD_INT 2
6249: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6250: LD_ADDR_OWVAR 37
6254: PUSH
6255: LD_INT 14
6257: ST_TO_ADDR
// vc_engine := engine_siberite ;
6258: LD_ADDR_OWVAR 39
6262: PUSH
6263: LD_INT 3
6265: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6266: LD_ADDR_OWVAR 38
6270: PUSH
6271: LD_INT 2
6273: PUSH
6274: LD_INT 5
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PUSH
6281: LD_INT 1
6283: PPUSH
6284: LD_INT 2
6286: PPUSH
6287: CALL_OW 12
6291: ARRAY
6292: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6293: LD_ADDR_OWVAR 40
6297: PUSH
6298: LD_INT 28
6300: PUSH
6301: LD_INT 27
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: LD_INT 25
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 1
6318: PPUSH
6319: LD_INT 4
6321: PPUSH
6322: CALL_OW 12
6326: ARRAY
6327: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6328: LD_ADDR_VAR 0 7
6332: PUSH
6333: LD_VAR 0 7
6337: PUSH
6338: CALL_OW 45
6342: ADD
6343: ST_TO_ADDR
// end ;
6344: GO 6239
6346: POP
6347: POP
// end ; if bonus_num = 4 then
6348: LD_EXP 12
6352: PUSH
6353: LD_INT 4
6355: EQUAL
6356: IFFALSE 6407
// for i = 1 to 3 do
6358: LD_ADDR_VAR 0 10
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_INT 3
6370: PUSH
6371: FOR_TO
6372: IFFALSE 6405
// begin PrepareHuman ( false , 3 , 8 ) ;
6374: LD_INT 0
6376: PPUSH
6377: LD_INT 3
6379: PPUSH
6380: LD_INT 8
6382: PPUSH
6383: CALL_OW 380
// units := units ^ CreateHuman ;
6387: LD_ADDR_VAR 0 7
6391: PUSH
6392: LD_VAR 0 7
6396: PUSH
6397: CALL_OW 44
6401: ADD
6402: ST_TO_ADDR
// end ;
6403: GO 6371
6405: POP
6406: POP
// end ; 4 :
6407: GO 6429
6409: LD_INT 4
6411: DOUBLE
6412: EQUAL
6413: IFTRUE 6417
6415: GO 6428
6417: POP
// off := false ; end ;
6418: LD_ADDR_VAR 0 6
6422: PUSH
6423: LD_INT 0
6425: ST_TO_ADDR
6426: GO 6429
6428: POP
// DialogueOff ;
6429: CALL_OW 7
// if not off then
6433: LD_VAR 0 6
6437: NOT
6438: IFFALSE 6444
// exit else
6440: GO 6623
6442: GO 6497
// begin SetArtifactUse ( your_side , art_use_exclamation , art_no , main_base ) ;
6444: LD_OWVAR 2
6448: PPUSH
6449: LD_INT 12
6451: PPUSH
6452: LD_INT 0
6454: PPUSH
6455: LD_INT 23
6457: PPUSH
6458: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6462: LD_EXP 10
6466: PPUSH
6467: LD_STRING DVr-3
6469: PUSH
6470: LD_STRING DVr-3a
6472: PUSH
6473: LD_STRING DVr-3b
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_INT 3
6486: PPUSH
6487: CALL_OW 12
6491: ARRAY
6492: PPUSH
6493: CALL_OW 94
// end ; if units then
6497: LD_VAR 0 7
6501: IFFALSE 6565
// for i in units do
6503: LD_ADDR_VAR 0 10
6507: PUSH
6508: LD_VAR 0 7
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6563
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6516: LD_VAR 0 10
6520: PPUSH
6521: LD_INT 92
6523: PPUSH
6524: LD_INT 49
6526: PPUSH
6527: LD_INT 20
6529: PPUSH
6530: LD_INT 0
6532: PPUSH
6533: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6537: LD_VAR 0 10
6541: PPUSH
6542: CALL_OW 250
6546: PPUSH
6547: LD_VAR 0 10
6551: PPUSH
6552: CALL_OW 251
6556: PPUSH
6557: CALL_OW 494
// end ;
6561: GO 6513
6563: POP
6564: POP
// if crates then
6565: LD_VAR 0 8
6569: IFFALSE 6623
// for i = 1 to ( crates div 50 ) do
6571: LD_ADDR_VAR 0 10
6575: PUSH
6576: DOUBLE
6577: LD_INT 1
6579: DEC
6580: ST_TO_ADDR
6581: LD_VAR 0 8
6585: PUSH
6586: LD_INT 50
6588: DIV
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6621
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6593: LD_INT 5
6595: PPUSH
6596: LD_INT 92
6598: PPUSH
6599: LD_INT 49
6601: PPUSH
6602: LD_INT 30
6604: PPUSH
6605: LD_INT 1
6607: PPUSH
6608: CALL_OW 56
// wait ( 0 0$02 ) ;
6612: LD_INT 70
6614: PPUSH
6615: CALL_OW 67
// end ;
6619: GO 6590
6621: POP
6622: POP
// end ;
6623: PPOPN 10
6625: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6626: LD_VAR 0 1
6630: PPUSH
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_VAR 0 3
6640: PPUSH
6641: CALL 17582 0 3
// end ;
6645: PPOPN 3
6647: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6648: LD_VAR 0 1
6652: PPUSH
6653: CALL 17680 0 1
// end ; end_of_file
6657: PPOPN 1
6659: END
// every 0 0$01 trigger not game_over do
6660: LD_EXP 7
6664: NOT
6665: IFFALSE 6698
6667: GO 6669
6669: DISABLE
// begin enable ;
6670: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6671: LD_ADDR_OWVAR 47
6675: PUSH
6676: LD_STRING #tick
6678: PUSH
6679: LD_OWVAR 1
6683: PUSH
6684: LD_STRING #points
6686: PUSH
6687: LD_EXP 8
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: ST_TO_ADDR
// end ;
6698: END
// every 0 0$01 trigger game_over do
6699: LD_EXP 7
6703: IFFALSE 6762
6705: GO 6707
6707: DISABLE
// begin Wait ( 0 0$02 ) ;
6708: LD_INT 70
6710: PPUSH
6711: CALL_OW 67
// DialogueOn ;
6715: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6719: LD_ADDR_OWVAR 47
6723: PUSH
6724: LD_STRING #game-points
6726: PUSH
6727: LD_OWVAR 78
6731: PUSH
6732: LD_EXP 8
6736: PUSH
6737: LD_STRING #game-time
6739: PUSH
6740: LD_OWVAR 1
6744: PUSH
6745: LD_STRING #game-difficulty
6747: PUSH
6748: LD_OWVAR 67
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: ST_TO_ADDR
// end ; end_of_file
6762: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6763: LD_OWVAR 1
6767: PUSH
6768: LD_INT 52500
6770: LESS
6771: IFFALSE 6795
6773: GO 6775
6775: DISABLE
// begin enable ;
6776: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6777: LD_INT 1
6779: PPUSH
6780: LD_INT 5
6782: PPUSH
6783: CALL_OW 12
6787: PPUSH
6788: LD_INT 1
6790: PPUSH
6791: CALL_OW 57
// end ; end_of_file
6795: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
6796: GO 6798
6798: DISABLE
// begin ru_radar := 98 ;
6799: LD_ADDR_EXP 14
6803: PUSH
6804: LD_INT 98
6806: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
6807: LD_ADDR_EXP 15
6811: PUSH
6812: LD_INT 89
6814: ST_TO_ADDR
// us_hack := 99 ;
6815: LD_ADDR_EXP 16
6819: PUSH
6820: LD_INT 99
6822: ST_TO_ADDR
// us_artillery := 97 ;
6823: LD_ADDR_EXP 17
6827: PUSH
6828: LD_INT 97
6830: ST_TO_ADDR
// ar_bio_bomb := 91 ;
6831: LD_ADDR_EXP 18
6835: PUSH
6836: LD_INT 91
6838: ST_TO_ADDR
// end ; end_of_file end_of_file
6839: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6840: GO 6842
6842: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6843: LD_STRING initStreamRollete();
6845: PPUSH
6846: CALL_OW 559
// InitStreamMode ;
6850: CALL 6859 0 0
// DefineStreamItems ( ) ;
6854: CALL 7299 0 0
// end ;
6858: END
// function InitStreamMode ; begin
6859: LD_INT 0
6861: PPUSH
// streamModeActive := false ;
6862: LD_ADDR_EXP 19
6866: PUSH
6867: LD_INT 0
6869: ST_TO_ADDR
// normalCounter := 26 ;
6870: LD_ADDR_EXP 20
6874: PUSH
6875: LD_INT 26
6877: ST_TO_ADDR
// hardcoreCounter := 12 ;
6878: LD_ADDR_EXP 21
6882: PUSH
6883: LD_INT 12
6885: ST_TO_ADDR
// sRocket := false ;
6886: LD_ADDR_EXP 24
6890: PUSH
6891: LD_INT 0
6893: ST_TO_ADDR
// sSpeed := false ;
6894: LD_ADDR_EXP 23
6898: PUSH
6899: LD_INT 0
6901: ST_TO_ADDR
// sEngine := false ;
6902: LD_ADDR_EXP 25
6906: PUSH
6907: LD_INT 0
6909: ST_TO_ADDR
// sSpec := false ;
6910: LD_ADDR_EXP 22
6914: PUSH
6915: LD_INT 0
6917: ST_TO_ADDR
// sLevel := false ;
6918: LD_ADDR_EXP 26
6922: PUSH
6923: LD_INT 0
6925: ST_TO_ADDR
// sArmoury := false ;
6926: LD_ADDR_EXP 27
6930: PUSH
6931: LD_INT 0
6933: ST_TO_ADDR
// sRadar := false ;
6934: LD_ADDR_EXP 28
6938: PUSH
6939: LD_INT 0
6941: ST_TO_ADDR
// sBunker := false ;
6942: LD_ADDR_EXP 29
6946: PUSH
6947: LD_INT 0
6949: ST_TO_ADDR
// sHack := false ;
6950: LD_ADDR_EXP 30
6954: PUSH
6955: LD_INT 0
6957: ST_TO_ADDR
// sFire := false ;
6958: LD_ADDR_EXP 31
6962: PUSH
6963: LD_INT 0
6965: ST_TO_ADDR
// sRefresh := false ;
6966: LD_ADDR_EXP 32
6970: PUSH
6971: LD_INT 0
6973: ST_TO_ADDR
// sExp := false ;
6974: LD_ADDR_EXP 33
6978: PUSH
6979: LD_INT 0
6981: ST_TO_ADDR
// sDepot := false ;
6982: LD_ADDR_EXP 34
6986: PUSH
6987: LD_INT 0
6989: ST_TO_ADDR
// sFlag := false ;
6990: LD_ADDR_EXP 35
6994: PUSH
6995: LD_INT 0
6997: ST_TO_ADDR
// sKamikadze := false ;
6998: LD_ADDR_EXP 43
7002: PUSH
7003: LD_INT 0
7005: ST_TO_ADDR
// sTroll := false ;
7006: LD_ADDR_EXP 44
7010: PUSH
7011: LD_INT 0
7013: ST_TO_ADDR
// sSlow := false ;
7014: LD_ADDR_EXP 45
7018: PUSH
7019: LD_INT 0
7021: ST_TO_ADDR
// sLack := false ;
7022: LD_ADDR_EXP 46
7026: PUSH
7027: LD_INT 0
7029: ST_TO_ADDR
// sTank := false ;
7030: LD_ADDR_EXP 48
7034: PUSH
7035: LD_INT 0
7037: ST_TO_ADDR
// sRemote := false ;
7038: LD_ADDR_EXP 49
7042: PUSH
7043: LD_INT 0
7045: ST_TO_ADDR
// sPowell := false ;
7046: LD_ADDR_EXP 50
7050: PUSH
7051: LD_INT 0
7053: ST_TO_ADDR
// sTeleport := false ;
7054: LD_ADDR_EXP 53
7058: PUSH
7059: LD_INT 0
7061: ST_TO_ADDR
// sOilTower := false ;
7062: LD_ADDR_EXP 55
7066: PUSH
7067: LD_INT 0
7069: ST_TO_ADDR
// sShovel := false ;
7070: LD_ADDR_EXP 56
7074: PUSH
7075: LD_INT 0
7077: ST_TO_ADDR
// sSheik := false ;
7078: LD_ADDR_EXP 57
7082: PUSH
7083: LD_INT 0
7085: ST_TO_ADDR
// sEarthquake := false ;
7086: LD_ADDR_EXP 59
7090: PUSH
7091: LD_INT 0
7093: ST_TO_ADDR
// sAI := false ;
7094: LD_ADDR_EXP 60
7098: PUSH
7099: LD_INT 0
7101: ST_TO_ADDR
// sCargo := false ;
7102: LD_ADDR_EXP 63
7106: PUSH
7107: LD_INT 0
7109: ST_TO_ADDR
// sDLaser := false ;
7110: LD_ADDR_EXP 64
7114: PUSH
7115: LD_INT 0
7117: ST_TO_ADDR
// sExchange := false ;
7118: LD_ADDR_EXP 65
7122: PUSH
7123: LD_INT 0
7125: ST_TO_ADDR
// sFac := false ;
7126: LD_ADDR_EXP 66
7130: PUSH
7131: LD_INT 0
7133: ST_TO_ADDR
// sPower := false ;
7134: LD_ADDR_EXP 67
7138: PUSH
7139: LD_INT 0
7141: ST_TO_ADDR
// sRandom := false ;
7142: LD_ADDR_EXP 68
7146: PUSH
7147: LD_INT 0
7149: ST_TO_ADDR
// sShield := false ;
7150: LD_ADDR_EXP 69
7154: PUSH
7155: LD_INT 0
7157: ST_TO_ADDR
// sTime := false ;
7158: LD_ADDR_EXP 70
7162: PUSH
7163: LD_INT 0
7165: ST_TO_ADDR
// sTools := false ;
7166: LD_ADDR_EXP 71
7170: PUSH
7171: LD_INT 0
7173: ST_TO_ADDR
// sSold := false ;
7174: LD_ADDR_EXP 36
7178: PUSH
7179: LD_INT 0
7181: ST_TO_ADDR
// sDiff := false ;
7182: LD_ADDR_EXP 37
7186: PUSH
7187: LD_INT 0
7189: ST_TO_ADDR
// sFog := false ;
7190: LD_ADDR_EXP 40
7194: PUSH
7195: LD_INT 0
7197: ST_TO_ADDR
// sReset := false ;
7198: LD_ADDR_EXP 41
7202: PUSH
7203: LD_INT 0
7205: ST_TO_ADDR
// sSun := false ;
7206: LD_ADDR_EXP 42
7210: PUSH
7211: LD_INT 0
7213: ST_TO_ADDR
// sTiger := false ;
7214: LD_ADDR_EXP 38
7218: PUSH
7219: LD_INT 0
7221: ST_TO_ADDR
// sBomb := false ;
7222: LD_ADDR_EXP 39
7226: PUSH
7227: LD_INT 0
7229: ST_TO_ADDR
// sWound := false ;
7230: LD_ADDR_EXP 47
7234: PUSH
7235: LD_INT 0
7237: ST_TO_ADDR
// sBetray := false ;
7238: LD_ADDR_EXP 51
7242: PUSH
7243: LD_INT 0
7245: ST_TO_ADDR
// sContamin := false ;
7246: LD_ADDR_EXP 52
7250: PUSH
7251: LD_INT 0
7253: ST_TO_ADDR
// sOil := false ;
7254: LD_ADDR_EXP 54
7258: PUSH
7259: LD_INT 0
7261: ST_TO_ADDR
// sStu := false ;
7262: LD_ADDR_EXP 58
7266: PUSH
7267: LD_INT 0
7269: ST_TO_ADDR
// sBazooka := false ;
7270: LD_ADDR_EXP 61
7274: PUSH
7275: LD_INT 0
7277: ST_TO_ADDR
// sMortar := false ;
7278: LD_ADDR_EXP 62
7282: PUSH
7283: LD_INT 0
7285: ST_TO_ADDR
// sRanger := false ;
7286: LD_ADDR_EXP 72
7290: PUSH
7291: LD_INT 0
7293: ST_TO_ADDR
// end ;
7294: LD_VAR 0 1
7298: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
7299: LD_INT 0
7301: PPUSH
7302: PPUSH
7303: PPUSH
7304: PPUSH
7305: PPUSH
// result := [ ] ;
7306: LD_ADDR_VAR 0 1
7310: PUSH
7311: EMPTY
7312: ST_TO_ADDR
// if campaign_id = 1 then
7313: LD_OWVAR 69
7317: PUSH
7318: LD_INT 1
7320: EQUAL
7321: IFFALSE 10257
// begin case mission_number of 1 :
7323: LD_OWVAR 70
7327: PUSH
7328: LD_INT 1
7330: DOUBLE
7331: EQUAL
7332: IFTRUE 7336
7334: GO 7400
7336: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
7337: LD_ADDR_VAR 0 1
7341: PUSH
7342: LD_INT 2
7344: PUSH
7345: LD_INT 4
7347: PUSH
7348: LD_INT 11
7350: PUSH
7351: LD_INT 12
7353: PUSH
7354: LD_INT 15
7356: PUSH
7357: LD_INT 16
7359: PUSH
7360: LD_INT 22
7362: PUSH
7363: LD_INT 23
7365: PUSH
7366: LD_INT 26
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: LIST
7376: LIST
7377: LIST
7378: LIST
7379: PUSH
7380: LD_INT 101
7382: PUSH
7383: LD_INT 102
7385: PUSH
7386: LD_INT 106
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: LIST
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: ST_TO_ADDR
7398: GO 10257
7400: LD_INT 2
7402: DOUBLE
7403: EQUAL
7404: IFTRUE 7408
7406: GO 7480
7408: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7409: LD_ADDR_VAR 0 1
7413: PUSH
7414: LD_INT 2
7416: PUSH
7417: LD_INT 4
7419: PUSH
7420: LD_INT 11
7422: PUSH
7423: LD_INT 12
7425: PUSH
7426: LD_INT 15
7428: PUSH
7429: LD_INT 16
7431: PUSH
7432: LD_INT 22
7434: PUSH
7435: LD_INT 23
7437: PUSH
7438: LD_INT 26
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: LIST
7450: LIST
7451: PUSH
7452: LD_INT 101
7454: PUSH
7455: LD_INT 102
7457: PUSH
7458: LD_INT 105
7460: PUSH
7461: LD_INT 106
7463: PUSH
7464: LD_INT 108
7466: PUSH
7467: EMPTY
7468: LIST
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: ST_TO_ADDR
7478: GO 10257
7480: LD_INT 3
7482: DOUBLE
7483: EQUAL
7484: IFTRUE 7488
7486: GO 7564
7488: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7489: LD_ADDR_VAR 0 1
7493: PUSH
7494: LD_INT 2
7496: PUSH
7497: LD_INT 4
7499: PUSH
7500: LD_INT 5
7502: PUSH
7503: LD_INT 11
7505: PUSH
7506: LD_INT 12
7508: PUSH
7509: LD_INT 15
7511: PUSH
7512: LD_INT 16
7514: PUSH
7515: LD_INT 22
7517: PUSH
7518: LD_INT 26
7520: PUSH
7521: LD_INT 36
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: LIST
7529: LIST
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 101
7538: PUSH
7539: LD_INT 102
7541: PUSH
7542: LD_INT 105
7544: PUSH
7545: LD_INT 106
7547: PUSH
7548: LD_INT 108
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: ST_TO_ADDR
7562: GO 10257
7564: LD_INT 4
7566: DOUBLE
7567: EQUAL
7568: IFTRUE 7572
7570: GO 7656
7572: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7573: LD_ADDR_VAR 0 1
7577: PUSH
7578: LD_INT 2
7580: PUSH
7581: LD_INT 4
7583: PUSH
7584: LD_INT 5
7586: PUSH
7587: LD_INT 8
7589: PUSH
7590: LD_INT 11
7592: PUSH
7593: LD_INT 12
7595: PUSH
7596: LD_INT 15
7598: PUSH
7599: LD_INT 16
7601: PUSH
7602: LD_INT 22
7604: PUSH
7605: LD_INT 23
7607: PUSH
7608: LD_INT 26
7610: PUSH
7611: LD_INT 36
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 101
7630: PUSH
7631: LD_INT 102
7633: PUSH
7634: LD_INT 105
7636: PUSH
7637: LD_INT 106
7639: PUSH
7640: LD_INT 108
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: ST_TO_ADDR
7654: GO 10257
7656: LD_INT 5
7658: DOUBLE
7659: EQUAL
7660: IFTRUE 7664
7662: GO 7764
7664: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7665: LD_ADDR_VAR 0 1
7669: PUSH
7670: LD_INT 2
7672: PUSH
7673: LD_INT 4
7675: PUSH
7676: LD_INT 5
7678: PUSH
7679: LD_INT 6
7681: PUSH
7682: LD_INT 8
7684: PUSH
7685: LD_INT 11
7687: PUSH
7688: LD_INT 12
7690: PUSH
7691: LD_INT 15
7693: PUSH
7694: LD_INT 16
7696: PUSH
7697: LD_INT 22
7699: PUSH
7700: LD_INT 23
7702: PUSH
7703: LD_INT 25
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 36
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: LD_INT 101
7730: PUSH
7731: LD_INT 102
7733: PUSH
7734: LD_INT 105
7736: PUSH
7737: LD_INT 106
7739: PUSH
7740: LD_INT 108
7742: PUSH
7743: LD_INT 109
7745: PUSH
7746: LD_INT 112
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: ST_TO_ADDR
7762: GO 10257
7764: LD_INT 6
7766: DOUBLE
7767: EQUAL
7768: IFTRUE 7772
7770: GO 7892
7772: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7773: LD_ADDR_VAR 0 1
7777: PUSH
7778: LD_INT 2
7780: PUSH
7781: LD_INT 4
7783: PUSH
7784: LD_INT 5
7786: PUSH
7787: LD_INT 6
7789: PUSH
7790: LD_INT 8
7792: PUSH
7793: LD_INT 11
7795: PUSH
7796: LD_INT 12
7798: PUSH
7799: LD_INT 15
7801: PUSH
7802: LD_INT 16
7804: PUSH
7805: LD_INT 20
7807: PUSH
7808: LD_INT 21
7810: PUSH
7811: LD_INT 22
7813: PUSH
7814: LD_INT 23
7816: PUSH
7817: LD_INT 25
7819: PUSH
7820: LD_INT 26
7822: PUSH
7823: LD_INT 30
7825: PUSH
7826: LD_INT 31
7828: PUSH
7829: LD_INT 32
7831: PUSH
7832: LD_INT 36
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: LIST
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: LIST
7855: PUSH
7856: LD_INT 101
7858: PUSH
7859: LD_INT 102
7861: PUSH
7862: LD_INT 105
7864: PUSH
7865: LD_INT 106
7867: PUSH
7868: LD_INT 108
7870: PUSH
7871: LD_INT 109
7873: PUSH
7874: LD_INT 112
7876: PUSH
7877: EMPTY
7878: LIST
7879: LIST
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: LIST
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: ST_TO_ADDR
7890: GO 10257
7892: LD_INT 7
7894: DOUBLE
7895: EQUAL
7896: IFTRUE 7900
7898: GO 8000
7900: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7901: LD_ADDR_VAR 0 1
7905: PUSH
7906: LD_INT 2
7908: PUSH
7909: LD_INT 4
7911: PUSH
7912: LD_INT 5
7914: PUSH
7915: LD_INT 7
7917: PUSH
7918: LD_INT 11
7920: PUSH
7921: LD_INT 12
7923: PUSH
7924: LD_INT 15
7926: PUSH
7927: LD_INT 16
7929: PUSH
7930: LD_INT 20
7932: PUSH
7933: LD_INT 21
7935: PUSH
7936: LD_INT 22
7938: PUSH
7939: LD_INT 23
7941: PUSH
7942: LD_INT 25
7944: PUSH
7945: LD_INT 26
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: LIST
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: LIST
7963: PUSH
7964: LD_INT 101
7966: PUSH
7967: LD_INT 102
7969: PUSH
7970: LD_INT 103
7972: PUSH
7973: LD_INT 105
7975: PUSH
7976: LD_INT 106
7978: PUSH
7979: LD_INT 108
7981: PUSH
7982: LD_INT 112
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: ST_TO_ADDR
7998: GO 10257
8000: LD_INT 8
8002: DOUBLE
8003: EQUAL
8004: IFTRUE 8008
8006: GO 8136
8008: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
8009: LD_ADDR_VAR 0 1
8013: PUSH
8014: LD_INT 2
8016: PUSH
8017: LD_INT 4
8019: PUSH
8020: LD_INT 5
8022: PUSH
8023: LD_INT 6
8025: PUSH
8026: LD_INT 7
8028: PUSH
8029: LD_INT 8
8031: PUSH
8032: LD_INT 11
8034: PUSH
8035: LD_INT 12
8037: PUSH
8038: LD_INT 15
8040: PUSH
8041: LD_INT 16
8043: PUSH
8044: LD_INT 20
8046: PUSH
8047: LD_INT 21
8049: PUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 23
8055: PUSH
8056: LD_INT 25
8058: PUSH
8059: LD_INT 26
8061: PUSH
8062: LD_INT 30
8064: PUSH
8065: LD_INT 31
8067: PUSH
8068: LD_INT 32
8070: PUSH
8071: LD_INT 36
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: LIST
8081: LIST
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: LIST
8087: LIST
8088: LIST
8089: LIST
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: PUSH
8096: LD_INT 101
8098: PUSH
8099: LD_INT 102
8101: PUSH
8102: LD_INT 103
8104: PUSH
8105: LD_INT 105
8107: PUSH
8108: LD_INT 106
8110: PUSH
8111: LD_INT 108
8113: PUSH
8114: LD_INT 109
8116: PUSH
8117: LD_INT 112
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: LIST
8127: LIST
8128: LIST
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: ST_TO_ADDR
8134: GO 10257
8136: LD_INT 9
8138: DOUBLE
8139: EQUAL
8140: IFTRUE 8144
8142: GO 8280
8144: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
8145: LD_ADDR_VAR 0 1
8149: PUSH
8150: LD_INT 2
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: LD_INT 5
8158: PUSH
8159: LD_INT 6
8161: PUSH
8162: LD_INT 7
8164: PUSH
8165: LD_INT 8
8167: PUSH
8168: LD_INT 11
8170: PUSH
8171: LD_INT 12
8173: PUSH
8174: LD_INT 15
8176: PUSH
8177: LD_INT 16
8179: PUSH
8180: LD_INT 20
8182: PUSH
8183: LD_INT 21
8185: PUSH
8186: LD_INT 22
8188: PUSH
8189: LD_INT 23
8191: PUSH
8192: LD_INT 25
8194: PUSH
8195: LD_INT 26
8197: PUSH
8198: LD_INT 28
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 31
8206: PUSH
8207: LD_INT 32
8209: PUSH
8210: LD_INT 36
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 101
8238: PUSH
8239: LD_INT 102
8241: PUSH
8242: LD_INT 103
8244: PUSH
8245: LD_INT 105
8247: PUSH
8248: LD_INT 106
8250: PUSH
8251: LD_INT 108
8253: PUSH
8254: LD_INT 109
8256: PUSH
8257: LD_INT 112
8259: PUSH
8260: LD_INT 114
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: ST_TO_ADDR
8278: GO 10257
8280: LD_INT 10
8282: DOUBLE
8283: EQUAL
8284: IFTRUE 8288
8286: GO 8472
8288: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: LD_INT 2
8296: PUSH
8297: LD_INT 4
8299: PUSH
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: LD_INT 8
8311: PUSH
8312: LD_INT 9
8314: PUSH
8315: LD_INT 10
8317: PUSH
8318: LD_INT 11
8320: PUSH
8321: LD_INT 12
8323: PUSH
8324: LD_INT 13
8326: PUSH
8327: LD_INT 14
8329: PUSH
8330: LD_INT 15
8332: PUSH
8333: LD_INT 16
8335: PUSH
8336: LD_INT 17
8338: PUSH
8339: LD_INT 18
8341: PUSH
8342: LD_INT 19
8344: PUSH
8345: LD_INT 20
8347: PUSH
8348: LD_INT 21
8350: PUSH
8351: LD_INT 22
8353: PUSH
8354: LD_INT 23
8356: PUSH
8357: LD_INT 24
8359: PUSH
8360: LD_INT 25
8362: PUSH
8363: LD_INT 26
8365: PUSH
8366: LD_INT 28
8368: PUSH
8369: LD_INT 30
8371: PUSH
8372: LD_INT 31
8374: PUSH
8375: LD_INT 32
8377: PUSH
8378: LD_INT 36
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: LIST
8387: LIST
8388: LIST
8389: LIST
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: LIST
8406: LIST
8407: LIST
8408: LIST
8409: LIST
8410: LIST
8411: PUSH
8412: LD_INT 101
8414: PUSH
8415: LD_INT 102
8417: PUSH
8418: LD_INT 103
8420: PUSH
8421: LD_INT 104
8423: PUSH
8424: LD_INT 105
8426: PUSH
8427: LD_INT 106
8429: PUSH
8430: LD_INT 107
8432: PUSH
8433: LD_INT 108
8435: PUSH
8436: LD_INT 109
8438: PUSH
8439: LD_INT 110
8441: PUSH
8442: LD_INT 111
8444: PUSH
8445: LD_INT 112
8447: PUSH
8448: LD_INT 114
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: LIST
8464: LIST
8465: PUSH
8466: EMPTY
8467: LIST
8468: LIST
8469: ST_TO_ADDR
8470: GO 10257
8472: LD_INT 11
8474: DOUBLE
8475: EQUAL
8476: IFTRUE 8480
8478: GO 8672
8480: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8481: LD_ADDR_VAR 0 1
8485: PUSH
8486: LD_INT 2
8488: PUSH
8489: LD_INT 3
8491: PUSH
8492: LD_INT 4
8494: PUSH
8495: LD_INT 5
8497: PUSH
8498: LD_INT 6
8500: PUSH
8501: LD_INT 7
8503: PUSH
8504: LD_INT 8
8506: PUSH
8507: LD_INT 9
8509: PUSH
8510: LD_INT 10
8512: PUSH
8513: LD_INT 11
8515: PUSH
8516: LD_INT 12
8518: PUSH
8519: LD_INT 13
8521: PUSH
8522: LD_INT 14
8524: PUSH
8525: LD_INT 15
8527: PUSH
8528: LD_INT 16
8530: PUSH
8531: LD_INT 17
8533: PUSH
8534: LD_INT 18
8536: PUSH
8537: LD_INT 19
8539: PUSH
8540: LD_INT 20
8542: PUSH
8543: LD_INT 21
8545: PUSH
8546: LD_INT 22
8548: PUSH
8549: LD_INT 23
8551: PUSH
8552: LD_INT 24
8554: PUSH
8555: LD_INT 25
8557: PUSH
8558: LD_INT 26
8560: PUSH
8561: LD_INT 28
8563: PUSH
8564: LD_INT 30
8566: PUSH
8567: LD_INT 31
8569: PUSH
8570: LD_INT 32
8572: PUSH
8573: LD_INT 34
8575: PUSH
8576: LD_INT 36
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: LIST
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 101
8614: PUSH
8615: LD_INT 102
8617: PUSH
8618: LD_INT 103
8620: PUSH
8621: LD_INT 104
8623: PUSH
8624: LD_INT 105
8626: PUSH
8627: LD_INT 106
8629: PUSH
8630: LD_INT 107
8632: PUSH
8633: LD_INT 108
8635: PUSH
8636: LD_INT 109
8638: PUSH
8639: LD_INT 110
8641: PUSH
8642: LD_INT 111
8644: PUSH
8645: LD_INT 112
8647: PUSH
8648: LD_INT 114
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: ST_TO_ADDR
8670: GO 10257
8672: LD_INT 12
8674: DOUBLE
8675: EQUAL
8676: IFTRUE 8680
8678: GO 8888
8680: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8681: LD_ADDR_VAR 0 1
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: LD_INT 2
8691: PUSH
8692: LD_INT 3
8694: PUSH
8695: LD_INT 4
8697: PUSH
8698: LD_INT 5
8700: PUSH
8701: LD_INT 6
8703: PUSH
8704: LD_INT 7
8706: PUSH
8707: LD_INT 8
8709: PUSH
8710: LD_INT 9
8712: PUSH
8713: LD_INT 10
8715: PUSH
8716: LD_INT 11
8718: PUSH
8719: LD_INT 12
8721: PUSH
8722: LD_INT 13
8724: PUSH
8725: LD_INT 14
8727: PUSH
8728: LD_INT 15
8730: PUSH
8731: LD_INT 16
8733: PUSH
8734: LD_INT 17
8736: PUSH
8737: LD_INT 18
8739: PUSH
8740: LD_INT 19
8742: PUSH
8743: LD_INT 20
8745: PUSH
8746: LD_INT 21
8748: PUSH
8749: LD_INT 22
8751: PUSH
8752: LD_INT 23
8754: PUSH
8755: LD_INT 24
8757: PUSH
8758: LD_INT 25
8760: PUSH
8761: LD_INT 26
8763: PUSH
8764: LD_INT 27
8766: PUSH
8767: LD_INT 28
8769: PUSH
8770: LD_INT 30
8772: PUSH
8773: LD_INT 31
8775: PUSH
8776: LD_INT 32
8778: PUSH
8779: LD_INT 33
8781: PUSH
8782: LD_INT 34
8784: PUSH
8785: LD_INT 36
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: LIST
8792: LIST
8793: LIST
8794: LIST
8795: LIST
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 101
8826: PUSH
8827: LD_INT 102
8829: PUSH
8830: LD_INT 103
8832: PUSH
8833: LD_INT 104
8835: PUSH
8836: LD_INT 105
8838: PUSH
8839: LD_INT 106
8841: PUSH
8842: LD_INT 107
8844: PUSH
8845: LD_INT 108
8847: PUSH
8848: LD_INT 109
8850: PUSH
8851: LD_INT 110
8853: PUSH
8854: LD_INT 111
8856: PUSH
8857: LD_INT 112
8859: PUSH
8860: LD_INT 113
8862: PUSH
8863: LD_INT 114
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: ST_TO_ADDR
8886: GO 10257
8888: LD_INT 13
8890: DOUBLE
8891: EQUAL
8892: IFTRUE 8896
8894: GO 9092
8896: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8897: LD_ADDR_VAR 0 1
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: LD_INT 2
8907: PUSH
8908: LD_INT 3
8910: PUSH
8911: LD_INT 4
8913: PUSH
8914: LD_INT 5
8916: PUSH
8917: LD_INT 8
8919: PUSH
8920: LD_INT 9
8922: PUSH
8923: LD_INT 10
8925: PUSH
8926: LD_INT 11
8928: PUSH
8929: LD_INT 12
8931: PUSH
8932: LD_INT 14
8934: PUSH
8935: LD_INT 15
8937: PUSH
8938: LD_INT 16
8940: PUSH
8941: LD_INT 17
8943: PUSH
8944: LD_INT 18
8946: PUSH
8947: LD_INT 19
8949: PUSH
8950: LD_INT 20
8952: PUSH
8953: LD_INT 21
8955: PUSH
8956: LD_INT 22
8958: PUSH
8959: LD_INT 23
8961: PUSH
8962: LD_INT 24
8964: PUSH
8965: LD_INT 25
8967: PUSH
8968: LD_INT 26
8970: PUSH
8971: LD_INT 27
8973: PUSH
8974: LD_INT 28
8976: PUSH
8977: LD_INT 30
8979: PUSH
8980: LD_INT 31
8982: PUSH
8983: LD_INT 32
8985: PUSH
8986: LD_INT 33
8988: PUSH
8989: LD_INT 34
8991: PUSH
8992: LD_INT 36
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: LIST
8999: LIST
9000: LIST
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: LIST
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: LIST
9021: LIST
9022: LIST
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: PUSH
9028: LD_INT 101
9030: PUSH
9031: LD_INT 102
9033: PUSH
9034: LD_INT 103
9036: PUSH
9037: LD_INT 104
9039: PUSH
9040: LD_INT 105
9042: PUSH
9043: LD_INT 106
9045: PUSH
9046: LD_INT 107
9048: PUSH
9049: LD_INT 108
9051: PUSH
9052: LD_INT 109
9054: PUSH
9055: LD_INT 110
9057: PUSH
9058: LD_INT 111
9060: PUSH
9061: LD_INT 112
9063: PUSH
9064: LD_INT 113
9066: PUSH
9067: LD_INT 114
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: ST_TO_ADDR
9090: GO 10257
9092: LD_INT 14
9094: DOUBLE
9095: EQUAL
9096: IFTRUE 9100
9098: GO 9312
9100: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
9101: LD_ADDR_VAR 0 1
9105: PUSH
9106: LD_INT 1
9108: PUSH
9109: LD_INT 2
9111: PUSH
9112: LD_INT 3
9114: PUSH
9115: LD_INT 4
9117: PUSH
9118: LD_INT 5
9120: PUSH
9121: LD_INT 6
9123: PUSH
9124: LD_INT 7
9126: PUSH
9127: LD_INT 8
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 11
9138: PUSH
9139: LD_INT 12
9141: PUSH
9142: LD_INT 13
9144: PUSH
9145: LD_INT 14
9147: PUSH
9148: LD_INT 15
9150: PUSH
9151: LD_INT 16
9153: PUSH
9154: LD_INT 17
9156: PUSH
9157: LD_INT 18
9159: PUSH
9160: LD_INT 19
9162: PUSH
9163: LD_INT 20
9165: PUSH
9166: LD_INT 21
9168: PUSH
9169: LD_INT 22
9171: PUSH
9172: LD_INT 23
9174: PUSH
9175: LD_INT 24
9177: PUSH
9178: LD_INT 25
9180: PUSH
9181: LD_INT 26
9183: PUSH
9184: LD_INT 27
9186: PUSH
9187: LD_INT 28
9189: PUSH
9190: LD_INT 29
9192: PUSH
9193: LD_INT 30
9195: PUSH
9196: LD_INT 31
9198: PUSH
9199: LD_INT 32
9201: PUSH
9202: LD_INT 33
9204: PUSH
9205: LD_INT 34
9207: PUSH
9208: LD_INT 36
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: LIST
9215: LIST
9216: LIST
9217: LIST
9218: LIST
9219: LIST
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_INT 101
9250: PUSH
9251: LD_INT 102
9253: PUSH
9254: LD_INT 103
9256: PUSH
9257: LD_INT 104
9259: PUSH
9260: LD_INT 105
9262: PUSH
9263: LD_INT 106
9265: PUSH
9266: LD_INT 107
9268: PUSH
9269: LD_INT 108
9271: PUSH
9272: LD_INT 109
9274: PUSH
9275: LD_INT 110
9277: PUSH
9278: LD_INT 111
9280: PUSH
9281: LD_INT 112
9283: PUSH
9284: LD_INT 113
9286: PUSH
9287: LD_INT 114
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: LIST
9294: LIST
9295: LIST
9296: LIST
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: ST_TO_ADDR
9310: GO 10257
9312: LD_INT 15
9314: DOUBLE
9315: EQUAL
9316: IFTRUE 9320
9318: GO 9532
9320: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
9321: LD_ADDR_VAR 0 1
9325: PUSH
9326: LD_INT 1
9328: PUSH
9329: LD_INT 2
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: LD_INT 4
9337: PUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 6
9343: PUSH
9344: LD_INT 7
9346: PUSH
9347: LD_INT 8
9349: PUSH
9350: LD_INT 9
9352: PUSH
9353: LD_INT 10
9355: PUSH
9356: LD_INT 11
9358: PUSH
9359: LD_INT 12
9361: PUSH
9362: LD_INT 13
9364: PUSH
9365: LD_INT 14
9367: PUSH
9368: LD_INT 15
9370: PUSH
9371: LD_INT 16
9373: PUSH
9374: LD_INT 17
9376: PUSH
9377: LD_INT 18
9379: PUSH
9380: LD_INT 19
9382: PUSH
9383: LD_INT 20
9385: PUSH
9386: LD_INT 21
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 23
9394: PUSH
9395: LD_INT 24
9397: PUSH
9398: LD_INT 25
9400: PUSH
9401: LD_INT 26
9403: PUSH
9404: LD_INT 27
9406: PUSH
9407: LD_INT 28
9409: PUSH
9410: LD_INT 29
9412: PUSH
9413: LD_INT 30
9415: PUSH
9416: LD_INT 31
9418: PUSH
9419: LD_INT 32
9421: PUSH
9422: LD_INT 33
9424: PUSH
9425: LD_INT 34
9427: PUSH
9428: LD_INT 36
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: LIST
9464: LIST
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 101
9470: PUSH
9471: LD_INT 102
9473: PUSH
9474: LD_INT 103
9476: PUSH
9477: LD_INT 104
9479: PUSH
9480: LD_INT 105
9482: PUSH
9483: LD_INT 106
9485: PUSH
9486: LD_INT 107
9488: PUSH
9489: LD_INT 108
9491: PUSH
9492: LD_INT 109
9494: PUSH
9495: LD_INT 110
9497: PUSH
9498: LD_INT 111
9500: PUSH
9501: LD_INT 112
9503: PUSH
9504: LD_INT 113
9506: PUSH
9507: LD_INT 114
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: ST_TO_ADDR
9530: GO 10257
9532: LD_INT 16
9534: DOUBLE
9535: EQUAL
9536: IFTRUE 9540
9538: GO 9664
9540: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9541: LD_ADDR_VAR 0 1
9545: PUSH
9546: LD_INT 2
9548: PUSH
9549: LD_INT 4
9551: PUSH
9552: LD_INT 5
9554: PUSH
9555: LD_INT 7
9557: PUSH
9558: LD_INT 11
9560: PUSH
9561: LD_INT 12
9563: PUSH
9564: LD_INT 15
9566: PUSH
9567: LD_INT 16
9569: PUSH
9570: LD_INT 20
9572: PUSH
9573: LD_INT 21
9575: PUSH
9576: LD_INT 22
9578: PUSH
9579: LD_INT 23
9581: PUSH
9582: LD_INT 25
9584: PUSH
9585: LD_INT 26
9587: PUSH
9588: LD_INT 30
9590: PUSH
9591: LD_INT 31
9593: PUSH
9594: LD_INT 32
9596: PUSH
9597: LD_INT 33
9599: PUSH
9600: LD_INT 34
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 101
9626: PUSH
9627: LD_INT 102
9629: PUSH
9630: LD_INT 103
9632: PUSH
9633: LD_INT 106
9635: PUSH
9636: LD_INT 108
9638: PUSH
9639: LD_INT 112
9641: PUSH
9642: LD_INT 113
9644: PUSH
9645: LD_INT 114
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: PUSH
9658: EMPTY
9659: LIST
9660: LIST
9661: ST_TO_ADDR
9662: GO 10257
9664: LD_INT 17
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9884
9672: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9673: LD_ADDR_VAR 0 1
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: LD_INT 2
9683: PUSH
9684: LD_INT 3
9686: PUSH
9687: LD_INT 4
9689: PUSH
9690: LD_INT 5
9692: PUSH
9693: LD_INT 6
9695: PUSH
9696: LD_INT 7
9698: PUSH
9699: LD_INT 8
9701: PUSH
9702: LD_INT 9
9704: PUSH
9705: LD_INT 10
9707: PUSH
9708: LD_INT 11
9710: PUSH
9711: LD_INT 12
9713: PUSH
9714: LD_INT 13
9716: PUSH
9717: LD_INT 14
9719: PUSH
9720: LD_INT 15
9722: PUSH
9723: LD_INT 16
9725: PUSH
9726: LD_INT 17
9728: PUSH
9729: LD_INT 18
9731: PUSH
9732: LD_INT 19
9734: PUSH
9735: LD_INT 20
9737: PUSH
9738: LD_INT 21
9740: PUSH
9741: LD_INT 22
9743: PUSH
9744: LD_INT 23
9746: PUSH
9747: LD_INT 24
9749: PUSH
9750: LD_INT 25
9752: PUSH
9753: LD_INT 26
9755: PUSH
9756: LD_INT 27
9758: PUSH
9759: LD_INT 28
9761: PUSH
9762: LD_INT 29
9764: PUSH
9765: LD_INT 30
9767: PUSH
9768: LD_INT 31
9770: PUSH
9771: LD_INT 32
9773: PUSH
9774: LD_INT 33
9776: PUSH
9777: LD_INT 34
9779: PUSH
9780: LD_INT 36
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: LIST
9819: PUSH
9820: LD_INT 101
9822: PUSH
9823: LD_INT 102
9825: PUSH
9826: LD_INT 103
9828: PUSH
9829: LD_INT 104
9831: PUSH
9832: LD_INT 105
9834: PUSH
9835: LD_INT 106
9837: PUSH
9838: LD_INT 107
9840: PUSH
9841: LD_INT 108
9843: PUSH
9844: LD_INT 109
9846: PUSH
9847: LD_INT 110
9849: PUSH
9850: LD_INT 111
9852: PUSH
9853: LD_INT 112
9855: PUSH
9856: LD_INT 113
9858: PUSH
9859: LD_INT 114
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: ST_TO_ADDR
9882: GO 10257
9884: LD_INT 18
9886: DOUBLE
9887: EQUAL
9888: IFTRUE 9892
9890: GO 10028
9892: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9893: LD_ADDR_VAR 0 1
9897: PUSH
9898: LD_INT 2
9900: PUSH
9901: LD_INT 4
9903: PUSH
9904: LD_INT 5
9906: PUSH
9907: LD_INT 7
9909: PUSH
9910: LD_INT 11
9912: PUSH
9913: LD_INT 12
9915: PUSH
9916: LD_INT 15
9918: PUSH
9919: LD_INT 16
9921: PUSH
9922: LD_INT 20
9924: PUSH
9925: LD_INT 21
9927: PUSH
9928: LD_INT 22
9930: PUSH
9931: LD_INT 23
9933: PUSH
9934: LD_INT 25
9936: PUSH
9937: LD_INT 26
9939: PUSH
9940: LD_INT 30
9942: PUSH
9943: LD_INT 31
9945: PUSH
9946: LD_INT 32
9948: PUSH
9949: LD_INT 33
9951: PUSH
9952: LD_INT 34
9954: PUSH
9955: LD_INT 35
9957: PUSH
9958: LD_INT 36
9960: PUSH
9961: EMPTY
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: LIST
9978: LIST
9979: LIST
9980: LIST
9981: LIST
9982: LIST
9983: PUSH
9984: LD_INT 101
9986: PUSH
9987: LD_INT 102
9989: PUSH
9990: LD_INT 103
9992: PUSH
9993: LD_INT 106
9995: PUSH
9996: LD_INT 108
9998: PUSH
9999: LD_INT 112
10001: PUSH
10002: LD_INT 113
10004: PUSH
10005: LD_INT 114
10007: PUSH
10008: LD_INT 115
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: LIST
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: ST_TO_ADDR
10026: GO 10257
10028: LD_INT 19
10030: DOUBLE
10031: EQUAL
10032: IFTRUE 10036
10034: GO 10256
10036: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
10037: LD_ADDR_VAR 0 1
10041: PUSH
10042: LD_INT 1
10044: PUSH
10045: LD_INT 2
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 4
10053: PUSH
10054: LD_INT 5
10056: PUSH
10057: LD_INT 6
10059: PUSH
10060: LD_INT 7
10062: PUSH
10063: LD_INT 8
10065: PUSH
10066: LD_INT 9
10068: PUSH
10069: LD_INT 10
10071: PUSH
10072: LD_INT 11
10074: PUSH
10075: LD_INT 12
10077: PUSH
10078: LD_INT 13
10080: PUSH
10081: LD_INT 14
10083: PUSH
10084: LD_INT 15
10086: PUSH
10087: LD_INT 16
10089: PUSH
10090: LD_INT 17
10092: PUSH
10093: LD_INT 18
10095: PUSH
10096: LD_INT 19
10098: PUSH
10099: LD_INT 20
10101: PUSH
10102: LD_INT 21
10104: PUSH
10105: LD_INT 22
10107: PUSH
10108: LD_INT 23
10110: PUSH
10111: LD_INT 24
10113: PUSH
10114: LD_INT 25
10116: PUSH
10117: LD_INT 26
10119: PUSH
10120: LD_INT 27
10122: PUSH
10123: LD_INT 28
10125: PUSH
10126: LD_INT 29
10128: PUSH
10129: LD_INT 30
10131: PUSH
10132: LD_INT 31
10134: PUSH
10135: LD_INT 32
10137: PUSH
10138: LD_INT 33
10140: PUSH
10141: LD_INT 34
10143: PUSH
10144: LD_INT 35
10146: PUSH
10147: LD_INT 36
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: PUSH
10188: LD_INT 101
10190: PUSH
10191: LD_INT 102
10193: PUSH
10194: LD_INT 103
10196: PUSH
10197: LD_INT 104
10199: PUSH
10200: LD_INT 105
10202: PUSH
10203: LD_INT 106
10205: PUSH
10206: LD_INT 107
10208: PUSH
10209: LD_INT 108
10211: PUSH
10212: LD_INT 109
10214: PUSH
10215: LD_INT 110
10217: PUSH
10218: LD_INT 111
10220: PUSH
10221: LD_INT 112
10223: PUSH
10224: LD_INT 113
10226: PUSH
10227: LD_INT 114
10229: PUSH
10230: LD_INT 115
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: LIST
10247: LIST
10248: LIST
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: ST_TO_ADDR
10254: GO 10257
10256: POP
// end ; if result then
10257: LD_VAR 0 1
10261: IFFALSE 10550
// begin normal :=  ;
10263: LD_ADDR_VAR 0 3
10267: PUSH
10268: LD_STRING 
10270: ST_TO_ADDR
// hardcore :=  ;
10271: LD_ADDR_VAR 0 4
10275: PUSH
10276: LD_STRING 
10278: ST_TO_ADDR
// for i = 1 to normalCounter do
10279: LD_ADDR_VAR 0 5
10283: PUSH
10284: DOUBLE
10285: LD_INT 1
10287: DEC
10288: ST_TO_ADDR
10289: LD_EXP 20
10293: PUSH
10294: FOR_TO
10295: IFFALSE 10396
// begin tmp := 0 ;
10297: LD_ADDR_VAR 0 2
10301: PUSH
10302: LD_STRING 0
10304: ST_TO_ADDR
// if result [ 1 ] then
10305: LD_VAR 0 1
10309: PUSH
10310: LD_INT 1
10312: ARRAY
10313: IFFALSE 10378
// if result [ 1 ] [ 1 ] = i then
10315: LD_VAR 0 1
10319: PUSH
10320: LD_INT 1
10322: ARRAY
10323: PUSH
10324: LD_INT 1
10326: ARRAY
10327: PUSH
10328: LD_VAR 0 5
10332: EQUAL
10333: IFFALSE 10378
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
10335: LD_ADDR_VAR 0 1
10339: PUSH
10340: LD_VAR 0 1
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: LD_VAR 0 1
10352: PUSH
10353: LD_INT 1
10355: ARRAY
10356: PPUSH
10357: LD_INT 1
10359: PPUSH
10360: CALL_OW 3
10364: PPUSH
10365: CALL_OW 1
10369: ST_TO_ADDR
// tmp := 1 ;
10370: LD_ADDR_VAR 0 2
10374: PUSH
10375: LD_STRING 1
10377: ST_TO_ADDR
// end ; normal := normal & tmp ;
10378: LD_ADDR_VAR 0 3
10382: PUSH
10383: LD_VAR 0 3
10387: PUSH
10388: LD_VAR 0 2
10392: STR
10393: ST_TO_ADDR
// end ;
10394: GO 10294
10396: POP
10397: POP
// for i = 1 to hardcoreCounter do
10398: LD_ADDR_VAR 0 5
10402: PUSH
10403: DOUBLE
10404: LD_INT 1
10406: DEC
10407: ST_TO_ADDR
10408: LD_EXP 21
10412: PUSH
10413: FOR_TO
10414: IFFALSE 10519
// begin tmp := 0 ;
10416: LD_ADDR_VAR 0 2
10420: PUSH
10421: LD_STRING 0
10423: ST_TO_ADDR
// if result [ 2 ] then
10424: LD_VAR 0 1
10428: PUSH
10429: LD_INT 2
10431: ARRAY
10432: IFFALSE 10501
// if result [ 2 ] [ 1 ] = 100 + i then
10434: LD_VAR 0 1
10438: PUSH
10439: LD_INT 2
10441: ARRAY
10442: PUSH
10443: LD_INT 1
10445: ARRAY
10446: PUSH
10447: LD_INT 100
10449: PUSH
10450: LD_VAR 0 5
10454: PLUS
10455: EQUAL
10456: IFFALSE 10501
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10458: LD_ADDR_VAR 0 1
10462: PUSH
10463: LD_VAR 0 1
10467: PPUSH
10468: LD_INT 2
10470: PPUSH
10471: LD_VAR 0 1
10475: PUSH
10476: LD_INT 2
10478: ARRAY
10479: PPUSH
10480: LD_INT 1
10482: PPUSH
10483: CALL_OW 3
10487: PPUSH
10488: CALL_OW 1
10492: ST_TO_ADDR
// tmp := 1 ;
10493: LD_ADDR_VAR 0 2
10497: PUSH
10498: LD_STRING 1
10500: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10501: LD_ADDR_VAR 0 4
10505: PUSH
10506: LD_VAR 0 4
10510: PUSH
10511: LD_VAR 0 2
10515: STR
10516: ST_TO_ADDR
// end ;
10517: GO 10413
10519: POP
10520: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10521: LD_STRING getStreamItemsFromMission("
10523: PUSH
10524: LD_VAR 0 3
10528: STR
10529: PUSH
10530: LD_STRING ","
10532: STR
10533: PUSH
10534: LD_VAR 0 4
10538: STR
10539: PUSH
10540: LD_STRING ")
10542: STR
10543: PPUSH
10544: CALL_OW 559
// end else
10548: GO 10557
// ToLua ( getStreamItemsFromMission("","") ) ;
10550: LD_STRING getStreamItemsFromMission("","")
10552: PPUSH
10553: CALL_OW 559
// end ;
10557: LD_VAR 0 1
10561: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10562: LD_VAR 0 2
10566: PUSH
10567: LD_INT 100
10569: EQUAL
10570: IFFALSE 11519
// begin if not StreamModeActive then
10572: LD_EXP 19
10576: NOT
10577: IFFALSE 10587
// StreamModeActive := true ;
10579: LD_ADDR_EXP 19
10583: PUSH
10584: LD_INT 1
10586: ST_TO_ADDR
// if p3 = 0 then
10587: LD_VAR 0 3
10591: PUSH
10592: LD_INT 0
10594: EQUAL
10595: IFFALSE 10601
// InitStreamMode ;
10597: CALL 6859 0 0
// if p3 = 1 then
10601: LD_VAR 0 3
10605: PUSH
10606: LD_INT 1
10608: EQUAL
10609: IFFALSE 10619
// sRocket := true ;
10611: LD_ADDR_EXP 24
10615: PUSH
10616: LD_INT 1
10618: ST_TO_ADDR
// if p3 = 2 then
10619: LD_VAR 0 3
10623: PUSH
10624: LD_INT 2
10626: EQUAL
10627: IFFALSE 10637
// sSpeed := true ;
10629: LD_ADDR_EXP 23
10633: PUSH
10634: LD_INT 1
10636: ST_TO_ADDR
// if p3 = 3 then
10637: LD_VAR 0 3
10641: PUSH
10642: LD_INT 3
10644: EQUAL
10645: IFFALSE 10655
// sEngine := true ;
10647: LD_ADDR_EXP 25
10651: PUSH
10652: LD_INT 1
10654: ST_TO_ADDR
// if p3 = 4 then
10655: LD_VAR 0 3
10659: PUSH
10660: LD_INT 4
10662: EQUAL
10663: IFFALSE 10673
// sSpec := true ;
10665: LD_ADDR_EXP 22
10669: PUSH
10670: LD_INT 1
10672: ST_TO_ADDR
// if p3 = 5 then
10673: LD_VAR 0 3
10677: PUSH
10678: LD_INT 5
10680: EQUAL
10681: IFFALSE 10691
// sLevel := true ;
10683: LD_ADDR_EXP 26
10687: PUSH
10688: LD_INT 1
10690: ST_TO_ADDR
// if p3 = 6 then
10691: LD_VAR 0 3
10695: PUSH
10696: LD_INT 6
10698: EQUAL
10699: IFFALSE 10709
// sArmoury := true ;
10701: LD_ADDR_EXP 27
10705: PUSH
10706: LD_INT 1
10708: ST_TO_ADDR
// if p3 = 7 then
10709: LD_VAR 0 3
10713: PUSH
10714: LD_INT 7
10716: EQUAL
10717: IFFALSE 10727
// sRadar := true ;
10719: LD_ADDR_EXP 28
10723: PUSH
10724: LD_INT 1
10726: ST_TO_ADDR
// if p3 = 8 then
10727: LD_VAR 0 3
10731: PUSH
10732: LD_INT 8
10734: EQUAL
10735: IFFALSE 10745
// sBunker := true ;
10737: LD_ADDR_EXP 29
10741: PUSH
10742: LD_INT 1
10744: ST_TO_ADDR
// if p3 = 9 then
10745: LD_VAR 0 3
10749: PUSH
10750: LD_INT 9
10752: EQUAL
10753: IFFALSE 10763
// sHack := true ;
10755: LD_ADDR_EXP 30
10759: PUSH
10760: LD_INT 1
10762: ST_TO_ADDR
// if p3 = 10 then
10763: LD_VAR 0 3
10767: PUSH
10768: LD_INT 10
10770: EQUAL
10771: IFFALSE 10781
// sFire := true ;
10773: LD_ADDR_EXP 31
10777: PUSH
10778: LD_INT 1
10780: ST_TO_ADDR
// if p3 = 11 then
10781: LD_VAR 0 3
10785: PUSH
10786: LD_INT 11
10788: EQUAL
10789: IFFALSE 10799
// sRefresh := true ;
10791: LD_ADDR_EXP 32
10795: PUSH
10796: LD_INT 1
10798: ST_TO_ADDR
// if p3 = 12 then
10799: LD_VAR 0 3
10803: PUSH
10804: LD_INT 12
10806: EQUAL
10807: IFFALSE 10817
// sExp := true ;
10809: LD_ADDR_EXP 33
10813: PUSH
10814: LD_INT 1
10816: ST_TO_ADDR
// if p3 = 13 then
10817: LD_VAR 0 3
10821: PUSH
10822: LD_INT 13
10824: EQUAL
10825: IFFALSE 10835
// sDepot := true ;
10827: LD_ADDR_EXP 34
10831: PUSH
10832: LD_INT 1
10834: ST_TO_ADDR
// if p3 = 14 then
10835: LD_VAR 0 3
10839: PUSH
10840: LD_INT 14
10842: EQUAL
10843: IFFALSE 10853
// sFlag := true ;
10845: LD_ADDR_EXP 35
10849: PUSH
10850: LD_INT 1
10852: ST_TO_ADDR
// if p3 = 15 then
10853: LD_VAR 0 3
10857: PUSH
10858: LD_INT 15
10860: EQUAL
10861: IFFALSE 10871
// sKamikadze := true ;
10863: LD_ADDR_EXP 43
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
// if p3 = 16 then
10871: LD_VAR 0 3
10875: PUSH
10876: LD_INT 16
10878: EQUAL
10879: IFFALSE 10889
// sTroll := true ;
10881: LD_ADDR_EXP 44
10885: PUSH
10886: LD_INT 1
10888: ST_TO_ADDR
// if p3 = 17 then
10889: LD_VAR 0 3
10893: PUSH
10894: LD_INT 17
10896: EQUAL
10897: IFFALSE 10907
// sSlow := true ;
10899: LD_ADDR_EXP 45
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// if p3 = 18 then
10907: LD_VAR 0 3
10911: PUSH
10912: LD_INT 18
10914: EQUAL
10915: IFFALSE 10925
// sLack := true ;
10917: LD_ADDR_EXP 46
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// if p3 = 19 then
10925: LD_VAR 0 3
10929: PUSH
10930: LD_INT 19
10932: EQUAL
10933: IFFALSE 10943
// sTank := true ;
10935: LD_ADDR_EXP 48
10939: PUSH
10940: LD_INT 1
10942: ST_TO_ADDR
// if p3 = 20 then
10943: LD_VAR 0 3
10947: PUSH
10948: LD_INT 20
10950: EQUAL
10951: IFFALSE 10961
// sRemote := true ;
10953: LD_ADDR_EXP 49
10957: PUSH
10958: LD_INT 1
10960: ST_TO_ADDR
// if p3 = 21 then
10961: LD_VAR 0 3
10965: PUSH
10966: LD_INT 21
10968: EQUAL
10969: IFFALSE 10979
// sPowell := true ;
10971: LD_ADDR_EXP 50
10975: PUSH
10976: LD_INT 1
10978: ST_TO_ADDR
// if p3 = 22 then
10979: LD_VAR 0 3
10983: PUSH
10984: LD_INT 22
10986: EQUAL
10987: IFFALSE 10997
// sTeleport := true ;
10989: LD_ADDR_EXP 53
10993: PUSH
10994: LD_INT 1
10996: ST_TO_ADDR
// if p3 = 23 then
10997: LD_VAR 0 3
11001: PUSH
11002: LD_INT 23
11004: EQUAL
11005: IFFALSE 11015
// sOilTower := true ;
11007: LD_ADDR_EXP 55
11011: PUSH
11012: LD_INT 1
11014: ST_TO_ADDR
// if p3 = 24 then
11015: LD_VAR 0 3
11019: PUSH
11020: LD_INT 24
11022: EQUAL
11023: IFFALSE 11033
// sShovel := true ;
11025: LD_ADDR_EXP 56
11029: PUSH
11030: LD_INT 1
11032: ST_TO_ADDR
// if p3 = 25 then
11033: LD_VAR 0 3
11037: PUSH
11038: LD_INT 25
11040: EQUAL
11041: IFFALSE 11051
// sSheik := true ;
11043: LD_ADDR_EXP 57
11047: PUSH
11048: LD_INT 1
11050: ST_TO_ADDR
// if p3 = 26 then
11051: LD_VAR 0 3
11055: PUSH
11056: LD_INT 26
11058: EQUAL
11059: IFFALSE 11069
// sEarthquake := true ;
11061: LD_ADDR_EXP 59
11065: PUSH
11066: LD_INT 1
11068: ST_TO_ADDR
// if p3 = 27 then
11069: LD_VAR 0 3
11073: PUSH
11074: LD_INT 27
11076: EQUAL
11077: IFFALSE 11087
// sAI := true ;
11079: LD_ADDR_EXP 60
11083: PUSH
11084: LD_INT 1
11086: ST_TO_ADDR
// if p3 = 28 then
11087: LD_VAR 0 3
11091: PUSH
11092: LD_INT 28
11094: EQUAL
11095: IFFALSE 11105
// sCargo := true ;
11097: LD_ADDR_EXP 63
11101: PUSH
11102: LD_INT 1
11104: ST_TO_ADDR
// if p3 = 29 then
11105: LD_VAR 0 3
11109: PUSH
11110: LD_INT 29
11112: EQUAL
11113: IFFALSE 11123
// sDLaser := true ;
11115: LD_ADDR_EXP 64
11119: PUSH
11120: LD_INT 1
11122: ST_TO_ADDR
// if p3 = 30 then
11123: LD_VAR 0 3
11127: PUSH
11128: LD_INT 30
11130: EQUAL
11131: IFFALSE 11141
// sExchange := true ;
11133: LD_ADDR_EXP 65
11137: PUSH
11138: LD_INT 1
11140: ST_TO_ADDR
// if p3 = 31 then
11141: LD_VAR 0 3
11145: PUSH
11146: LD_INT 31
11148: EQUAL
11149: IFFALSE 11159
// sFac := true ;
11151: LD_ADDR_EXP 66
11155: PUSH
11156: LD_INT 1
11158: ST_TO_ADDR
// if p3 = 32 then
11159: LD_VAR 0 3
11163: PUSH
11164: LD_INT 32
11166: EQUAL
11167: IFFALSE 11177
// sPower := true ;
11169: LD_ADDR_EXP 67
11173: PUSH
11174: LD_INT 1
11176: ST_TO_ADDR
// if p3 = 33 then
11177: LD_VAR 0 3
11181: PUSH
11182: LD_INT 33
11184: EQUAL
11185: IFFALSE 11195
// sRandom := true ;
11187: LD_ADDR_EXP 68
11191: PUSH
11192: LD_INT 1
11194: ST_TO_ADDR
// if p3 = 34 then
11195: LD_VAR 0 3
11199: PUSH
11200: LD_INT 34
11202: EQUAL
11203: IFFALSE 11213
// sShield := true ;
11205: LD_ADDR_EXP 69
11209: PUSH
11210: LD_INT 1
11212: ST_TO_ADDR
// if p3 = 35 then
11213: LD_VAR 0 3
11217: PUSH
11218: LD_INT 35
11220: EQUAL
11221: IFFALSE 11231
// sTime := true ;
11223: LD_ADDR_EXP 70
11227: PUSH
11228: LD_INT 1
11230: ST_TO_ADDR
// if p3 = 36 then
11231: LD_VAR 0 3
11235: PUSH
11236: LD_INT 36
11238: EQUAL
11239: IFFALSE 11249
// sTools := true ;
11241: LD_ADDR_EXP 71
11245: PUSH
11246: LD_INT 1
11248: ST_TO_ADDR
// if p3 = 101 then
11249: LD_VAR 0 3
11253: PUSH
11254: LD_INT 101
11256: EQUAL
11257: IFFALSE 11267
// sSold := true ;
11259: LD_ADDR_EXP 36
11263: PUSH
11264: LD_INT 1
11266: ST_TO_ADDR
// if p3 = 102 then
11267: LD_VAR 0 3
11271: PUSH
11272: LD_INT 102
11274: EQUAL
11275: IFFALSE 11285
// sDiff := true ;
11277: LD_ADDR_EXP 37
11281: PUSH
11282: LD_INT 1
11284: ST_TO_ADDR
// if p3 = 103 then
11285: LD_VAR 0 3
11289: PUSH
11290: LD_INT 103
11292: EQUAL
11293: IFFALSE 11303
// sFog := true ;
11295: LD_ADDR_EXP 40
11299: PUSH
11300: LD_INT 1
11302: ST_TO_ADDR
// if p3 = 104 then
11303: LD_VAR 0 3
11307: PUSH
11308: LD_INT 104
11310: EQUAL
11311: IFFALSE 11321
// sReset := true ;
11313: LD_ADDR_EXP 41
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// if p3 = 105 then
11321: LD_VAR 0 3
11325: PUSH
11326: LD_INT 105
11328: EQUAL
11329: IFFALSE 11339
// sSun := true ;
11331: LD_ADDR_EXP 42
11335: PUSH
11336: LD_INT 1
11338: ST_TO_ADDR
// if p3 = 106 then
11339: LD_VAR 0 3
11343: PUSH
11344: LD_INT 106
11346: EQUAL
11347: IFFALSE 11357
// sTiger := true ;
11349: LD_ADDR_EXP 38
11353: PUSH
11354: LD_INT 1
11356: ST_TO_ADDR
// if p3 = 107 then
11357: LD_VAR 0 3
11361: PUSH
11362: LD_INT 107
11364: EQUAL
11365: IFFALSE 11375
// sBomb := true ;
11367: LD_ADDR_EXP 39
11371: PUSH
11372: LD_INT 1
11374: ST_TO_ADDR
// if p3 = 108 then
11375: LD_VAR 0 3
11379: PUSH
11380: LD_INT 108
11382: EQUAL
11383: IFFALSE 11393
// sWound := true ;
11385: LD_ADDR_EXP 47
11389: PUSH
11390: LD_INT 1
11392: ST_TO_ADDR
// if p3 = 109 then
11393: LD_VAR 0 3
11397: PUSH
11398: LD_INT 109
11400: EQUAL
11401: IFFALSE 11411
// sBetray := true ;
11403: LD_ADDR_EXP 51
11407: PUSH
11408: LD_INT 1
11410: ST_TO_ADDR
// if p3 = 110 then
11411: LD_VAR 0 3
11415: PUSH
11416: LD_INT 110
11418: EQUAL
11419: IFFALSE 11429
// sContamin := true ;
11421: LD_ADDR_EXP 52
11425: PUSH
11426: LD_INT 1
11428: ST_TO_ADDR
// if p3 = 111 then
11429: LD_VAR 0 3
11433: PUSH
11434: LD_INT 111
11436: EQUAL
11437: IFFALSE 11447
// sOil := true ;
11439: LD_ADDR_EXP 54
11443: PUSH
11444: LD_INT 1
11446: ST_TO_ADDR
// if p3 = 112 then
11447: LD_VAR 0 3
11451: PUSH
11452: LD_INT 112
11454: EQUAL
11455: IFFALSE 11465
// sStu := true ;
11457: LD_ADDR_EXP 58
11461: PUSH
11462: LD_INT 1
11464: ST_TO_ADDR
// if p3 = 113 then
11465: LD_VAR 0 3
11469: PUSH
11470: LD_INT 113
11472: EQUAL
11473: IFFALSE 11483
// sBazooka := true ;
11475: LD_ADDR_EXP 61
11479: PUSH
11480: LD_INT 1
11482: ST_TO_ADDR
// if p3 = 114 then
11483: LD_VAR 0 3
11487: PUSH
11488: LD_INT 114
11490: EQUAL
11491: IFFALSE 11501
// sMortar := true ;
11493: LD_ADDR_EXP 62
11497: PUSH
11498: LD_INT 1
11500: ST_TO_ADDR
// if p3 = 115 then
11501: LD_VAR 0 3
11505: PUSH
11506: LD_INT 115
11508: EQUAL
11509: IFFALSE 11519
// sRanger := true ;
11511: LD_ADDR_EXP 72
11515: PUSH
11516: LD_INT 1
11518: ST_TO_ADDR
// end ; end ;
11519: PPOPN 6
11521: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11522: LD_EXP 19
11526: PUSH
11527: LD_EXP 24
11531: AND
11532: IFFALSE 11656
11534: GO 11536
11536: DISABLE
11537: LD_INT 0
11539: PPUSH
11540: PPUSH
// begin enable ;
11541: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11542: LD_ADDR_VAR 0 2
11546: PUSH
11547: LD_INT 22
11549: PUSH
11550: LD_OWVAR 2
11554: PUSH
11555: EMPTY
11556: LIST
11557: LIST
11558: PUSH
11559: LD_INT 2
11561: PUSH
11562: LD_INT 34
11564: PUSH
11565: LD_INT 7
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 34
11574: PUSH
11575: LD_INT 45
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 34
11584: PUSH
11585: LD_INT 28
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 34
11594: PUSH
11595: LD_INT 47
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PPUSH
11613: CALL_OW 69
11617: ST_TO_ADDR
// if not tmp then
11618: LD_VAR 0 2
11622: NOT
11623: IFFALSE 11627
// exit ;
11625: GO 11656
// for i in tmp do
11627: LD_ADDR_VAR 0 1
11631: PUSH
11632: LD_VAR 0 2
11636: PUSH
11637: FOR_IN
11638: IFFALSE 11654
// begin SetLives ( i , 0 ) ;
11640: LD_VAR 0 1
11644: PPUSH
11645: LD_INT 0
11647: PPUSH
11648: CALL_OW 234
// end ;
11652: GO 11637
11654: POP
11655: POP
// end ;
11656: PPOPN 2
11658: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11659: LD_EXP 19
11663: PUSH
11664: LD_EXP 25
11668: AND
11669: IFFALSE 11753
11671: GO 11673
11673: DISABLE
11674: LD_INT 0
11676: PPUSH
11677: PPUSH
// begin enable ;
11678: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11679: LD_ADDR_VAR 0 2
11683: PUSH
11684: LD_INT 22
11686: PUSH
11687: LD_OWVAR 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: LD_INT 32
11698: PUSH
11699: LD_INT 3
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PPUSH
11710: CALL_OW 69
11714: ST_TO_ADDR
// if not tmp then
11715: LD_VAR 0 2
11719: NOT
11720: IFFALSE 11724
// exit ;
11722: GO 11753
// for i in tmp do
11724: LD_ADDR_VAR 0 1
11728: PUSH
11729: LD_VAR 0 2
11733: PUSH
11734: FOR_IN
11735: IFFALSE 11751
// begin SetLives ( i , 0 ) ;
11737: LD_VAR 0 1
11741: PPUSH
11742: LD_INT 0
11744: PPUSH
11745: CALL_OW 234
// end ;
11749: GO 11734
11751: POP
11752: POP
// end ;
11753: PPOPN 2
11755: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11756: LD_EXP 19
11760: PUSH
11761: LD_EXP 22
11765: AND
11766: IFFALSE 11859
11768: GO 11770
11770: DISABLE
11771: LD_INT 0
11773: PPUSH
// begin enable ;
11774: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11775: LD_ADDR_VAR 0 1
11779: PUSH
11780: LD_INT 22
11782: PUSH
11783: LD_OWVAR 2
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: PUSH
11792: LD_INT 2
11794: PUSH
11795: LD_INT 25
11797: PUSH
11798: LD_INT 5
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 25
11807: PUSH
11808: LD_INT 9
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: PUSH
11815: LD_INT 25
11817: PUSH
11818: LD_INT 8
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PPUSH
11835: CALL_OW 69
11839: PUSH
11840: FOR_IN
11841: IFFALSE 11857
// begin SetClass ( i , 1 ) ;
11843: LD_VAR 0 1
11847: PPUSH
11848: LD_INT 1
11850: PPUSH
11851: CALL_OW 336
// end ;
11855: GO 11840
11857: POP
11858: POP
// end ;
11859: PPOPN 1
11861: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
11862: LD_EXP 19
11866: PUSH
11867: LD_EXP 23
11871: AND
11872: PUSH
11873: LD_OWVAR 65
11877: PUSH
11878: LD_INT 7
11880: LESS
11881: AND
11882: IFFALSE 11896
11884: GO 11886
11886: DISABLE
// begin enable ;
11887: ENABLE
// game_speed := 7 ;
11888: LD_ADDR_OWVAR 65
11892: PUSH
11893: LD_INT 7
11895: ST_TO_ADDR
// end ;
11896: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
11897: LD_EXP 19
11901: PUSH
11902: LD_EXP 26
11906: AND
11907: IFFALSE 12109
11909: GO 11911
11911: DISABLE
11912: LD_INT 0
11914: PPUSH
11915: PPUSH
11916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
11917: LD_ADDR_VAR 0 3
11921: PUSH
11922: LD_INT 81
11924: PUSH
11925: LD_OWVAR 2
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 21
11936: PUSH
11937: LD_INT 1
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: PPUSH
11948: CALL_OW 69
11952: ST_TO_ADDR
// if not tmp then
11953: LD_VAR 0 3
11957: NOT
11958: IFFALSE 11962
// exit ;
11960: GO 12109
// if tmp > 5 then
11962: LD_VAR 0 3
11966: PUSH
11967: LD_INT 5
11969: GREATER
11970: IFFALSE 11982
// k := 5 else
11972: LD_ADDR_VAR 0 2
11976: PUSH
11977: LD_INT 5
11979: ST_TO_ADDR
11980: GO 11992
// k := tmp ;
11982: LD_ADDR_VAR 0 2
11986: PUSH
11987: LD_VAR 0 3
11991: ST_TO_ADDR
// for i := 1 to k do
11992: LD_ADDR_VAR 0 1
11996: PUSH
11997: DOUBLE
11998: LD_INT 1
12000: DEC
12001: ST_TO_ADDR
12002: LD_VAR 0 2
12006: PUSH
12007: FOR_TO
12008: IFFALSE 12107
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12010: LD_VAR 0 3
12014: PUSH
12015: LD_VAR 0 1
12019: ARRAY
12020: PPUSH
12021: LD_VAR 0 1
12025: PUSH
12026: LD_INT 4
12028: MOD
12029: PUSH
12030: LD_INT 1
12032: PLUS
12033: PPUSH
12034: CALL_OW 259
12038: PUSH
12039: LD_INT 10
12041: LESS
12042: IFFALSE 12105
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12044: LD_VAR 0 3
12048: PUSH
12049: LD_VAR 0 1
12053: ARRAY
12054: PPUSH
12055: LD_VAR 0 1
12059: PUSH
12060: LD_INT 4
12062: MOD
12063: PUSH
12064: LD_INT 1
12066: PLUS
12067: PPUSH
12068: LD_VAR 0 3
12072: PUSH
12073: LD_VAR 0 1
12077: ARRAY
12078: PPUSH
12079: LD_VAR 0 1
12083: PUSH
12084: LD_INT 4
12086: MOD
12087: PUSH
12088: LD_INT 1
12090: PLUS
12091: PPUSH
12092: CALL_OW 259
12096: PUSH
12097: LD_INT 1
12099: PLUS
12100: PPUSH
12101: CALL_OW 237
12105: GO 12007
12107: POP
12108: POP
// end ;
12109: PPOPN 3
12111: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12112: LD_EXP 19
12116: PUSH
12117: LD_EXP 27
12121: AND
12122: IFFALSE 12142
12124: GO 12126
12126: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12127: LD_INT 4
12129: PPUSH
12130: LD_OWVAR 2
12134: PPUSH
12135: LD_INT 0
12137: PPUSH
12138: CALL_OW 324
12142: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12143: LD_EXP 19
12147: PUSH
12148: LD_EXP 56
12152: AND
12153: IFFALSE 12173
12155: GO 12157
12157: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12158: LD_INT 19
12160: PPUSH
12161: LD_OWVAR 2
12165: PPUSH
12166: LD_INT 0
12168: PPUSH
12169: CALL_OW 324
12173: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12174: LD_EXP 19
12178: PUSH
12179: LD_EXP 28
12183: AND
12184: IFFALSE 12286
12186: GO 12188
12188: DISABLE
12189: LD_INT 0
12191: PPUSH
12192: PPUSH
// begin enable ;
12193: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12194: LD_ADDR_VAR 0 2
12198: PUSH
12199: LD_INT 22
12201: PUSH
12202: LD_OWVAR 2
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: PUSH
12211: LD_INT 2
12213: PUSH
12214: LD_INT 34
12216: PUSH
12217: LD_INT 11
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: PUSH
12224: LD_INT 34
12226: PUSH
12227: LD_INT 30
12229: PUSH
12230: EMPTY
12231: LIST
12232: LIST
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: LIST
12238: PUSH
12239: EMPTY
12240: LIST
12241: LIST
12242: PPUSH
12243: CALL_OW 69
12247: ST_TO_ADDR
// if not tmp then
12248: LD_VAR 0 2
12252: NOT
12253: IFFALSE 12257
// exit ;
12255: GO 12286
// for i in tmp do
12257: LD_ADDR_VAR 0 1
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12284
// begin SetLives ( i , 0 ) ;
12270: LD_VAR 0 1
12274: PPUSH
12275: LD_INT 0
12277: PPUSH
12278: CALL_OW 234
// end ;
12282: GO 12267
12284: POP
12285: POP
// end ;
12286: PPOPN 2
12288: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12289: LD_EXP 19
12293: PUSH
12294: LD_EXP 29
12298: AND
12299: IFFALSE 12319
12301: GO 12303
12303: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12304: LD_INT 32
12306: PPUSH
12307: LD_OWVAR 2
12311: PPUSH
12312: LD_INT 0
12314: PPUSH
12315: CALL_OW 324
12319: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12320: LD_EXP 19
12324: PUSH
12325: LD_EXP 30
12329: AND
12330: IFFALSE 12511
12332: GO 12334
12334: DISABLE
12335: LD_INT 0
12337: PPUSH
12338: PPUSH
12339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12340: LD_ADDR_VAR 0 2
12344: PUSH
12345: LD_INT 22
12347: PUSH
12348: LD_OWVAR 2
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PUSH
12357: LD_INT 33
12359: PUSH
12360: LD_INT 3
12362: PUSH
12363: EMPTY
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PPUSH
12371: CALL_OW 69
12375: ST_TO_ADDR
// if not tmp then
12376: LD_VAR 0 2
12380: NOT
12381: IFFALSE 12385
// exit ;
12383: GO 12511
// side := 0 ;
12385: LD_ADDR_VAR 0 3
12389: PUSH
12390: LD_INT 0
12392: ST_TO_ADDR
// for i := 1 to 8 do
12393: LD_ADDR_VAR 0 1
12397: PUSH
12398: DOUBLE
12399: LD_INT 1
12401: DEC
12402: ST_TO_ADDR
12403: LD_INT 8
12405: PUSH
12406: FOR_TO
12407: IFFALSE 12455
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12409: LD_OWVAR 2
12413: PUSH
12414: LD_VAR 0 1
12418: NONEQUAL
12419: PUSH
12420: LD_OWVAR 2
12424: PPUSH
12425: LD_VAR 0 1
12429: PPUSH
12430: CALL_OW 81
12434: PUSH
12435: LD_INT 2
12437: EQUAL
12438: AND
12439: IFFALSE 12453
// begin side := i ;
12441: LD_ADDR_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ST_TO_ADDR
// break ;
12451: GO 12455
// end ;
12453: GO 12406
12455: POP
12456: POP
// if not side then
12457: LD_VAR 0 3
12461: NOT
12462: IFFALSE 12466
// exit ;
12464: GO 12511
// for i := 1 to tmp do
12466: LD_ADDR_VAR 0 1
12470: PUSH
12471: DOUBLE
12472: LD_INT 1
12474: DEC
12475: ST_TO_ADDR
12476: LD_VAR 0 2
12480: PUSH
12481: FOR_TO
12482: IFFALSE 12509
// if Prob ( 60 ) then
12484: LD_INT 60
12486: PPUSH
12487: CALL_OW 13
12491: IFFALSE 12507
// SetSide ( i , side ) ;
12493: LD_VAR 0 1
12497: PPUSH
12498: LD_VAR 0 3
12502: PPUSH
12503: CALL_OW 235
12507: GO 12481
12509: POP
12510: POP
// end ;
12511: PPOPN 3
12513: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12514: LD_EXP 19
12518: PUSH
12519: LD_EXP 32
12523: AND
12524: IFFALSE 12643
12526: GO 12528
12528: DISABLE
12529: LD_INT 0
12531: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12532: LD_ADDR_VAR 0 1
12536: PUSH
12537: LD_INT 22
12539: PUSH
12540: LD_OWVAR 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 21
12551: PUSH
12552: LD_INT 1
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 3
12561: PUSH
12562: LD_INT 23
12564: PUSH
12565: LD_INT 0
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: PPUSH
12581: CALL_OW 69
12585: PUSH
12586: FOR_IN
12587: IFFALSE 12641
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12589: LD_VAR 0 1
12593: PPUSH
12594: CALL_OW 257
12598: PUSH
12599: LD_INT 1
12601: PUSH
12602: LD_INT 2
12604: PUSH
12605: LD_INT 3
12607: PUSH
12608: LD_INT 4
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: IN
12617: IFFALSE 12639
// SetClass ( un , rand ( 1 , 4 ) ) ;
12619: LD_VAR 0 1
12623: PPUSH
12624: LD_INT 1
12626: PPUSH
12627: LD_INT 4
12629: PPUSH
12630: CALL_OW 12
12634: PPUSH
12635: CALL_OW 336
12639: GO 12586
12641: POP
12642: POP
// end ;
12643: PPOPN 1
12645: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12646: LD_EXP 19
12650: PUSH
12651: LD_EXP 31
12655: AND
12656: IFFALSE 12735
12658: GO 12660
12660: DISABLE
12661: LD_INT 0
12663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12664: LD_ADDR_VAR 0 1
12668: PUSH
12669: LD_INT 22
12671: PUSH
12672: LD_OWVAR 2
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 21
12683: PUSH
12684: LD_INT 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 69
12699: ST_TO_ADDR
// if not tmp then
12700: LD_VAR 0 1
12704: NOT
12705: IFFALSE 12709
// exit ;
12707: GO 12735
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12709: LD_VAR 0 1
12713: PUSH
12714: LD_INT 1
12716: PPUSH
12717: LD_VAR 0 1
12721: PPUSH
12722: CALL_OW 12
12726: ARRAY
12727: PPUSH
12728: LD_INT 100
12730: PPUSH
12731: CALL_OW 234
// end ;
12735: PPOPN 1
12737: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12738: LD_EXP 19
12742: PUSH
12743: LD_EXP 33
12747: AND
12748: IFFALSE 12846
12750: GO 12752
12752: DISABLE
12753: LD_INT 0
12755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12756: LD_ADDR_VAR 0 1
12760: PUSH
12761: LD_INT 22
12763: PUSH
12764: LD_OWVAR 2
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: LD_INT 21
12775: PUSH
12776: LD_INT 1
12778: PUSH
12779: EMPTY
12780: LIST
12781: LIST
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PPUSH
12787: CALL_OW 69
12791: ST_TO_ADDR
// if not tmp then
12792: LD_VAR 0 1
12796: NOT
12797: IFFALSE 12801
// exit ;
12799: GO 12846
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12801: LD_VAR 0 1
12805: PUSH
12806: LD_INT 1
12808: PPUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: CALL_OW 12
12818: ARRAY
12819: PPUSH
12820: LD_INT 1
12822: PPUSH
12823: LD_INT 4
12825: PPUSH
12826: CALL_OW 12
12830: PPUSH
12831: LD_INT 3000
12833: PPUSH
12834: LD_INT 9000
12836: PPUSH
12837: CALL_OW 12
12841: PPUSH
12842: CALL_OW 492
// end ;
12846: PPOPN 1
12848: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12849: LD_EXP 19
12853: PUSH
12854: LD_EXP 34
12858: AND
12859: IFFALSE 12879
12861: GO 12863
12863: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12864: LD_INT 1
12866: PPUSH
12867: LD_OWVAR 2
12871: PPUSH
12872: LD_INT 0
12874: PPUSH
12875: CALL_OW 324
12879: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12880: LD_EXP 19
12884: PUSH
12885: LD_EXP 35
12889: AND
12890: IFFALSE 12973
12892: GO 12894
12894: DISABLE
12895: LD_INT 0
12897: PPUSH
12898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12899: LD_ADDR_VAR 0 2
12903: PUSH
12904: LD_INT 22
12906: PUSH
12907: LD_OWVAR 2
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 21
12918: PUSH
12919: LD_INT 3
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PPUSH
12930: CALL_OW 69
12934: ST_TO_ADDR
// if not tmp then
12935: LD_VAR 0 2
12939: NOT
12940: IFFALSE 12944
// exit ;
12942: GO 12973
// for i in tmp do
12944: LD_ADDR_VAR 0 1
12948: PUSH
12949: LD_VAR 0 2
12953: PUSH
12954: FOR_IN
12955: IFFALSE 12971
// SetBLevel ( i , 10 ) ;
12957: LD_VAR 0 1
12961: PPUSH
12962: LD_INT 10
12964: PPUSH
12965: CALL_OW 241
12969: GO 12954
12971: POP
12972: POP
// end ;
12973: PPOPN 2
12975: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
12976: LD_EXP 19
12980: PUSH
12981: LD_EXP 36
12985: AND
12986: IFFALSE 13097
12988: GO 12990
12990: DISABLE
12991: LD_INT 0
12993: PPUSH
12994: PPUSH
12995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12996: LD_ADDR_VAR 0 3
13000: PUSH
13001: LD_INT 22
13003: PUSH
13004: LD_OWVAR 2
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 25
13015: PUSH
13016: LD_INT 1
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: PPUSH
13027: CALL_OW 69
13031: ST_TO_ADDR
// if not tmp then
13032: LD_VAR 0 3
13036: NOT
13037: IFFALSE 13041
// exit ;
13039: GO 13097
// un := tmp [ rand ( 1 , tmp ) ] ;
13041: LD_ADDR_VAR 0 2
13045: PUSH
13046: LD_VAR 0 3
13050: PUSH
13051: LD_INT 1
13053: PPUSH
13054: LD_VAR 0 3
13058: PPUSH
13059: CALL_OW 12
13063: ARRAY
13064: ST_TO_ADDR
// if Crawls ( un ) then
13065: LD_VAR 0 2
13069: PPUSH
13070: CALL_OW 318
13074: IFFALSE 13085
// ComWalk ( un ) ;
13076: LD_VAR 0 2
13080: PPUSH
13081: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13085: LD_VAR 0 2
13089: PPUSH
13090: LD_INT 5
13092: PPUSH
13093: CALL_OW 336
// end ;
13097: PPOPN 3
13099: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13100: LD_EXP 19
13104: PUSH
13105: LD_EXP 37
13109: AND
13110: PUSH
13111: LD_OWVAR 67
13115: PUSH
13116: LD_INT 3
13118: LESS
13119: AND
13120: IFFALSE 13139
13122: GO 13124
13124: DISABLE
// Difficulty := Difficulty + 1 ;
13125: LD_ADDR_OWVAR 67
13129: PUSH
13130: LD_OWVAR 67
13134: PUSH
13135: LD_INT 1
13137: PLUS
13138: ST_TO_ADDR
13139: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13140: LD_EXP 19
13144: PUSH
13145: LD_EXP 38
13149: AND
13150: IFFALSE 13253
13152: GO 13154
13154: DISABLE
13155: LD_INT 0
13157: PPUSH
// begin for i := 1 to 5 do
13158: LD_ADDR_VAR 0 1
13162: PUSH
13163: DOUBLE
13164: LD_INT 1
13166: DEC
13167: ST_TO_ADDR
13168: LD_INT 5
13170: PUSH
13171: FOR_TO
13172: IFFALSE 13251
// begin uc_nation := nation_nature ;
13174: LD_ADDR_OWVAR 21
13178: PUSH
13179: LD_INT 0
13181: ST_TO_ADDR
// uc_side := 0 ;
13182: LD_ADDR_OWVAR 20
13186: PUSH
13187: LD_INT 0
13189: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13190: LD_ADDR_OWVAR 29
13194: PUSH
13195: LD_INT 12
13197: PUSH
13198: LD_INT 12
13200: PUSH
13201: EMPTY
13202: LIST
13203: LIST
13204: ST_TO_ADDR
// hc_agressivity := 20 ;
13205: LD_ADDR_OWVAR 35
13209: PUSH
13210: LD_INT 20
13212: ST_TO_ADDR
// hc_class := class_tiger ;
13213: LD_ADDR_OWVAR 28
13217: PUSH
13218: LD_INT 14
13220: ST_TO_ADDR
// hc_gallery :=  ;
13221: LD_ADDR_OWVAR 33
13225: PUSH
13226: LD_STRING 
13228: ST_TO_ADDR
// hc_name :=  ;
13229: LD_ADDR_OWVAR 26
13233: PUSH
13234: LD_STRING 
13236: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13237: CALL_OW 44
13241: PPUSH
13242: LD_INT 0
13244: PPUSH
13245: CALL_OW 51
// end ;
13249: GO 13171
13251: POP
13252: POP
// end ;
13253: PPOPN 1
13255: END
// every 0 0$1 trigger StreamModeActive and sBomb do
13256: LD_EXP 19
13260: PUSH
13261: LD_EXP 39
13265: AND
13266: IFFALSE 13275
13268: GO 13270
13270: DISABLE
// StreamSibBomb ;
13271: CALL 13276 0 0
13275: END
// export function StreamSibBomb ; var i , x , y ; begin
13276: LD_INT 0
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
// result := false ;
13282: LD_ADDR_VAR 0 1
13286: PUSH
13287: LD_INT 0
13289: ST_TO_ADDR
// for i := 1 to 16 do
13290: LD_ADDR_VAR 0 2
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_INT 16
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13503
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13306: LD_ADDR_VAR 0 3
13310: PUSH
13311: LD_INT 10
13313: PUSH
13314: LD_INT 20
13316: PUSH
13317: LD_INT 30
13319: PUSH
13320: LD_INT 40
13322: PUSH
13323: LD_INT 50
13325: PUSH
13326: LD_INT 60
13328: PUSH
13329: LD_INT 70
13331: PUSH
13332: LD_INT 80
13334: PUSH
13335: LD_INT 90
13337: PUSH
13338: LD_INT 100
13340: PUSH
13341: LD_INT 110
13343: PUSH
13344: LD_INT 120
13346: PUSH
13347: LD_INT 130
13349: PUSH
13350: LD_INT 140
13352: PUSH
13353: LD_INT 150
13355: PUSH
13356: EMPTY
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 1
13375: PPUSH
13376: LD_INT 15
13378: PPUSH
13379: CALL_OW 12
13383: ARRAY
13384: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13385: LD_ADDR_VAR 0 4
13389: PUSH
13390: LD_INT 10
13392: PUSH
13393: LD_INT 20
13395: PUSH
13396: LD_INT 30
13398: PUSH
13399: LD_INT 40
13401: PUSH
13402: LD_INT 50
13404: PUSH
13405: LD_INT 60
13407: PUSH
13408: LD_INT 70
13410: PUSH
13411: LD_INT 80
13413: PUSH
13414: LD_INT 90
13416: PUSH
13417: LD_INT 100
13419: PUSH
13420: LD_INT 110
13422: PUSH
13423: LD_INT 120
13425: PUSH
13426: LD_INT 130
13428: PUSH
13429: LD_INT 140
13431: PUSH
13432: LD_INT 150
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: PUSH
13452: LD_INT 1
13454: PPUSH
13455: LD_INT 15
13457: PPUSH
13458: CALL_OW 12
13462: ARRAY
13463: ST_TO_ADDR
// if ValidHex ( x , y ) then
13464: LD_VAR 0 3
13468: PPUSH
13469: LD_VAR 0 4
13473: PPUSH
13474: CALL_OW 488
13478: IFFALSE 13501
// begin result := [ x , y ] ;
13480: LD_ADDR_VAR 0 1
13484: PUSH
13485: LD_VAR 0 3
13489: PUSH
13490: LD_VAR 0 4
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: ST_TO_ADDR
// break ;
13499: GO 13503
// end ; end ;
13501: GO 13303
13503: POP
13504: POP
// if result then
13505: LD_VAR 0 1
13509: IFFALSE 13569
// begin ToLua ( playSibBomb() ) ;
13511: LD_STRING playSibBomb()
13513: PPUSH
13514: CALL_OW 559
// wait ( 0 0$14 ) ;
13518: LD_INT 490
13520: PPUSH
13521: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13525: LD_VAR 0 1
13529: PUSH
13530: LD_INT 1
13532: ARRAY
13533: PPUSH
13534: LD_VAR 0 1
13538: PUSH
13539: LD_INT 2
13541: ARRAY
13542: PPUSH
13543: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13547: LD_VAR 0 1
13551: PUSH
13552: LD_INT 1
13554: ARRAY
13555: PPUSH
13556: LD_VAR 0 1
13560: PUSH
13561: LD_INT 2
13563: ARRAY
13564: PPUSH
13565: CALL_OW 429
// end ; end ;
13569: LD_VAR 0 1
13573: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13574: LD_EXP 19
13578: PUSH
13579: LD_EXP 41
13583: AND
13584: IFFALSE 13596
13586: GO 13588
13588: DISABLE
// YouLost (  ) ;
13589: LD_STRING 
13591: PPUSH
13592: CALL_OW 104
13596: END
// every 0 0$1 trigger StreamModeActive and sFog do
13597: LD_EXP 19
13601: PUSH
13602: LD_EXP 40
13606: AND
13607: IFFALSE 13621
13609: GO 13611
13611: DISABLE
// FogOff ( your_side ) ;
13612: LD_OWVAR 2
13616: PPUSH
13617: CALL_OW 344
13621: END
// every 0 0$1 trigger StreamModeActive and sSun do
13622: LD_EXP 19
13626: PUSH
13627: LD_EXP 42
13631: AND
13632: IFFALSE 13660
13634: GO 13636
13636: DISABLE
// begin solar_recharge_percent := 0 ;
13637: LD_ADDR_OWVAR 79
13641: PUSH
13642: LD_INT 0
13644: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13645: LD_INT 10500
13647: PPUSH
13648: CALL_OW 67
// solar_recharge_percent := 100 ;
13652: LD_ADDR_OWVAR 79
13656: PUSH
13657: LD_INT 100
13659: ST_TO_ADDR
// end ;
13660: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13661: LD_EXP 19
13665: PUSH
13666: LD_EXP 43
13670: AND
13671: IFFALSE 13910
13673: GO 13675
13675: DISABLE
13676: LD_INT 0
13678: PPUSH
13679: PPUSH
13680: PPUSH
// begin tmp := [ ] ;
13681: LD_ADDR_VAR 0 3
13685: PUSH
13686: EMPTY
13687: ST_TO_ADDR
// for i := 1 to 6 do
13688: LD_ADDR_VAR 0 1
13692: PUSH
13693: DOUBLE
13694: LD_INT 1
13696: DEC
13697: ST_TO_ADDR
13698: LD_INT 6
13700: PUSH
13701: FOR_TO
13702: IFFALSE 13807
// begin uc_nation := nation_nature ;
13704: LD_ADDR_OWVAR 21
13708: PUSH
13709: LD_INT 0
13711: ST_TO_ADDR
// uc_side := 0 ;
13712: LD_ADDR_OWVAR 20
13716: PUSH
13717: LD_INT 0
13719: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13720: LD_ADDR_OWVAR 29
13724: PUSH
13725: LD_INT 12
13727: PUSH
13728: LD_INT 12
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: ST_TO_ADDR
// hc_agressivity := 20 ;
13735: LD_ADDR_OWVAR 35
13739: PUSH
13740: LD_INT 20
13742: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13743: LD_ADDR_OWVAR 28
13747: PUSH
13748: LD_INT 17
13750: ST_TO_ADDR
// hc_gallery :=  ;
13751: LD_ADDR_OWVAR 33
13755: PUSH
13756: LD_STRING 
13758: ST_TO_ADDR
// hc_name :=  ;
13759: LD_ADDR_OWVAR 26
13763: PUSH
13764: LD_STRING 
13766: ST_TO_ADDR
// un := CreateHuman ;
13767: LD_ADDR_VAR 0 2
13771: PUSH
13772: CALL_OW 44
13776: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13777: LD_VAR 0 2
13781: PPUSH
13782: LD_INT 1
13784: PPUSH
13785: CALL_OW 51
// tmp := tmp ^ un ;
13789: LD_ADDR_VAR 0 3
13793: PUSH
13794: LD_VAR 0 3
13798: PUSH
13799: LD_VAR 0 2
13803: ADD
13804: ST_TO_ADDR
// end ;
13805: GO 13701
13807: POP
13808: POP
// repeat wait ( 0 0$1 ) ;
13809: LD_INT 35
13811: PPUSH
13812: CALL_OW 67
// for un in tmp do
13816: LD_ADDR_VAR 0 2
13820: PUSH
13821: LD_VAR 0 3
13825: PUSH
13826: FOR_IN
13827: IFFALSE 13901
// begin if IsDead ( un ) then
13829: LD_VAR 0 2
13833: PPUSH
13834: CALL_OW 301
13838: IFFALSE 13858
// begin tmp := tmp diff un ;
13840: LD_ADDR_VAR 0 3
13844: PUSH
13845: LD_VAR 0 3
13849: PUSH
13850: LD_VAR 0 2
13854: DIFF
13855: ST_TO_ADDR
// continue ;
13856: GO 13826
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13858: LD_VAR 0 2
13862: PPUSH
13863: LD_INT 3
13865: PUSH
13866: LD_INT 22
13868: PUSH
13869: LD_INT 0
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: PUSH
13876: EMPTY
13877: LIST
13878: LIST
13879: PPUSH
13880: CALL_OW 69
13884: PPUSH
13885: LD_VAR 0 2
13889: PPUSH
13890: CALL_OW 74
13894: PPUSH
13895: CALL_OW 115
// end ;
13899: GO 13826
13901: POP
13902: POP
// until not tmp ;
13903: LD_VAR 0 3
13907: NOT
13908: IFFALSE 13809
// end ;
13910: PPOPN 3
13912: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13913: LD_EXP 19
13917: PUSH
13918: LD_EXP 44
13922: AND
13923: IFFALSE 13977
13925: GO 13927
13927: DISABLE
// begin ToLua ( displayTroll(); ) ;
13928: LD_STRING displayTroll();
13930: PPUSH
13931: CALL_OW 559
// wait ( 3 3$00 ) ;
13935: LD_INT 6300
13937: PPUSH
13938: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13942: LD_STRING hideTroll();
13944: PPUSH
13945: CALL_OW 559
// wait ( 1 1$00 ) ;
13949: LD_INT 2100
13951: PPUSH
13952: CALL_OW 67
// ToLua ( displayTroll(); ) ;
13956: LD_STRING displayTroll();
13958: PPUSH
13959: CALL_OW 559
// wait ( 1 1$00 ) ;
13963: LD_INT 2100
13965: PPUSH
13966: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13970: LD_STRING hideTroll();
13972: PPUSH
13973: CALL_OW 559
// end ;
13977: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13978: LD_EXP 19
13982: PUSH
13983: LD_EXP 45
13987: AND
13988: IFFALSE 14051
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
// begin p := 0 ;
13996: LD_ADDR_VAR 0 1
14000: PUSH
14001: LD_INT 0
14003: ST_TO_ADDR
// repeat game_speed := 1 ;
14004: LD_ADDR_OWVAR 65
14008: PUSH
14009: LD_INT 1
14011: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14012: LD_INT 35
14014: PPUSH
14015: CALL_OW 67
// p := p + 1 ;
14019: LD_ADDR_VAR 0 1
14023: PUSH
14024: LD_VAR 0 1
14028: PUSH
14029: LD_INT 1
14031: PLUS
14032: ST_TO_ADDR
// until p >= 60 ;
14033: LD_VAR 0 1
14037: PUSH
14038: LD_INT 60
14040: GREATEREQUAL
14041: IFFALSE 14004
// game_speed := 4 ;
14043: LD_ADDR_OWVAR 65
14047: PUSH
14048: LD_INT 4
14050: ST_TO_ADDR
// end ;
14051: PPOPN 1
14053: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14054: LD_EXP 19
14058: PUSH
14059: LD_EXP 46
14063: AND
14064: IFFALSE 14210
14066: GO 14068
14068: DISABLE
14069: LD_INT 0
14071: PPUSH
14072: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14073: LD_ADDR_VAR 0 1
14077: PUSH
14078: LD_INT 22
14080: PUSH
14081: LD_OWVAR 2
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 2
14092: PUSH
14093: LD_INT 30
14095: PUSH
14096: LD_INT 0
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PUSH
14103: LD_INT 30
14105: PUSH
14106: LD_INT 1
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PPUSH
14122: CALL_OW 69
14126: ST_TO_ADDR
// if not depot then
14127: LD_VAR 0 1
14131: NOT
14132: IFFALSE 14136
// exit ;
14134: GO 14210
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14136: LD_ADDR_VAR 0 2
14140: PUSH
14141: LD_VAR 0 1
14145: PUSH
14146: LD_INT 1
14148: PPUSH
14149: LD_VAR 0 1
14153: PPUSH
14154: CALL_OW 12
14158: ARRAY
14159: PPUSH
14160: CALL_OW 274
14164: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14165: LD_VAR 0 2
14169: PPUSH
14170: LD_INT 1
14172: PPUSH
14173: LD_INT 0
14175: PPUSH
14176: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14180: LD_VAR 0 2
14184: PPUSH
14185: LD_INT 2
14187: PPUSH
14188: LD_INT 0
14190: PPUSH
14191: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14195: LD_VAR 0 2
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_INT 0
14205: PPUSH
14206: CALL_OW 277
// end ;
14210: PPOPN 2
14212: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14213: LD_EXP 19
14217: PUSH
14218: LD_EXP 47
14222: AND
14223: IFFALSE 14320
14225: GO 14227
14227: DISABLE
14228: LD_INT 0
14230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14231: LD_ADDR_VAR 0 1
14235: PUSH
14236: LD_INT 22
14238: PUSH
14239: LD_OWVAR 2
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 21
14250: PUSH
14251: LD_INT 1
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: LD_INT 3
14260: PUSH
14261: LD_INT 23
14263: PUSH
14264: LD_INT 0
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: LIST
14279: PPUSH
14280: CALL_OW 69
14284: ST_TO_ADDR
// if not tmp then
14285: LD_VAR 0 1
14289: NOT
14290: IFFALSE 14294
// exit ;
14292: GO 14320
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14294: LD_VAR 0 1
14298: PUSH
14299: LD_INT 1
14301: PPUSH
14302: LD_VAR 0 1
14306: PPUSH
14307: CALL_OW 12
14311: ARRAY
14312: PPUSH
14313: LD_INT 200
14315: PPUSH
14316: CALL_OW 234
// end ;
14320: PPOPN 1
14322: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14323: LD_EXP 19
14327: PUSH
14328: LD_EXP 48
14332: AND
14333: IFFALSE 14412
14335: GO 14337
14337: DISABLE
14338: LD_INT 0
14340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14341: LD_ADDR_VAR 0 1
14345: PUSH
14346: LD_INT 22
14348: PUSH
14349: LD_OWVAR 2
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: LD_INT 21
14360: PUSH
14361: LD_INT 2
14363: PUSH
14364: EMPTY
14365: LIST
14366: LIST
14367: PUSH
14368: EMPTY
14369: LIST
14370: LIST
14371: PPUSH
14372: CALL_OW 69
14376: ST_TO_ADDR
// if not tmp then
14377: LD_VAR 0 1
14381: NOT
14382: IFFALSE 14386
// exit ;
14384: GO 14412
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14386: LD_VAR 0 1
14390: PUSH
14391: LD_INT 1
14393: PPUSH
14394: LD_VAR 0 1
14398: PPUSH
14399: CALL_OW 12
14403: ARRAY
14404: PPUSH
14405: LD_INT 60
14407: PPUSH
14408: CALL_OW 234
// end ;
14412: PPOPN 1
14414: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14415: LD_EXP 19
14419: PUSH
14420: LD_EXP 49
14424: AND
14425: IFFALSE 14524
14427: GO 14429
14429: DISABLE
14430: LD_INT 0
14432: PPUSH
14433: PPUSH
// begin enable ;
14434: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14435: LD_ADDR_VAR 0 1
14439: PUSH
14440: LD_INT 22
14442: PUSH
14443: LD_OWVAR 2
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: PUSH
14452: LD_INT 61
14454: PUSH
14455: EMPTY
14456: LIST
14457: PUSH
14458: LD_INT 33
14460: PUSH
14461: LD_INT 2
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: LIST
14472: PPUSH
14473: CALL_OW 69
14477: ST_TO_ADDR
// if not tmp then
14478: LD_VAR 0 1
14482: NOT
14483: IFFALSE 14487
// exit ;
14485: GO 14524
// for i in tmp do
14487: LD_ADDR_VAR 0 2
14491: PUSH
14492: LD_VAR 0 1
14496: PUSH
14497: FOR_IN
14498: IFFALSE 14522
// if IsControledBy ( i ) then
14500: LD_VAR 0 2
14504: PPUSH
14505: CALL_OW 312
14509: IFFALSE 14520
// ComUnlink ( i ) ;
14511: LD_VAR 0 2
14515: PPUSH
14516: CALL_OW 136
14520: GO 14497
14522: POP
14523: POP
// end ;
14524: PPOPN 2
14526: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14527: LD_EXP 19
14531: PUSH
14532: LD_EXP 50
14536: AND
14537: IFFALSE 14677
14539: GO 14541
14541: DISABLE
14542: LD_INT 0
14544: PPUSH
14545: PPUSH
// begin ToLua ( displayPowell(); ) ;
14546: LD_STRING displayPowell();
14548: PPUSH
14549: CALL_OW 559
// uc_side := 0 ;
14553: LD_ADDR_OWVAR 20
14557: PUSH
14558: LD_INT 0
14560: ST_TO_ADDR
// uc_nation := 2 ;
14561: LD_ADDR_OWVAR 21
14565: PUSH
14566: LD_INT 2
14568: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14569: LD_ADDR_OWVAR 37
14573: PUSH
14574: LD_INT 14
14576: ST_TO_ADDR
// vc_engine := engine_siberite ;
14577: LD_ADDR_OWVAR 39
14581: PUSH
14582: LD_INT 3
14584: ST_TO_ADDR
// vc_control := control_apeman ;
14585: LD_ADDR_OWVAR 38
14589: PUSH
14590: LD_INT 5
14592: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14593: LD_ADDR_OWVAR 40
14597: PUSH
14598: LD_INT 29
14600: ST_TO_ADDR
// un := CreateVehicle ;
14601: LD_ADDR_VAR 0 2
14605: PUSH
14606: CALL_OW 45
14610: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14611: LD_VAR 0 2
14615: PPUSH
14616: LD_INT 1
14618: PPUSH
14619: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14623: LD_INT 35
14625: PPUSH
14626: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
14630: LD_VAR 0 2
14634: PPUSH
14635: LD_INT 22
14637: PUSH
14638: LD_OWVAR 2
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PPUSH
14647: CALL_OW 69
14651: PPUSH
14652: LD_VAR 0 2
14656: PPUSH
14657: CALL_OW 74
14661: PPUSH
14662: CALL_OW 115
// until IsDead ( un ) ;
14666: LD_VAR 0 2
14670: PPUSH
14671: CALL_OW 301
14675: IFFALSE 14623
// end ;
14677: PPOPN 2
14679: END
// every 0 0$1 trigger StreamModeActive and sStu do
14680: LD_EXP 19
14684: PUSH
14685: LD_EXP 58
14689: AND
14690: IFFALSE 14706
14692: GO 14694
14694: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14695: LD_STRING displayStucuk();
14697: PPUSH
14698: CALL_OW 559
// ResetFog ;
14702: CALL_OW 335
// end ;
14706: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14707: LD_EXP 19
14711: PUSH
14712: LD_EXP 51
14716: AND
14717: IFFALSE 14858
14719: GO 14721
14721: DISABLE
14722: LD_INT 0
14724: PPUSH
14725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14726: LD_ADDR_VAR 0 2
14730: PUSH
14731: LD_INT 22
14733: PUSH
14734: LD_OWVAR 2
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: PUSH
14743: LD_INT 21
14745: PUSH
14746: LD_INT 1
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PUSH
14753: EMPTY
14754: LIST
14755: LIST
14756: PPUSH
14757: CALL_OW 69
14761: ST_TO_ADDR
// if not tmp then
14762: LD_VAR 0 2
14766: NOT
14767: IFFALSE 14771
// exit ;
14769: GO 14858
// un := tmp [ rand ( 1 , tmp ) ] ;
14771: LD_ADDR_VAR 0 1
14775: PUSH
14776: LD_VAR 0 2
14780: PUSH
14781: LD_INT 1
14783: PPUSH
14784: LD_VAR 0 2
14788: PPUSH
14789: CALL_OW 12
14793: ARRAY
14794: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14795: LD_VAR 0 1
14799: PPUSH
14800: LD_INT 0
14802: PPUSH
14803: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_OWVAR 3
14816: PUSH
14817: LD_VAR 0 1
14821: DIFF
14822: PPUSH
14823: LD_VAR 0 1
14827: PPUSH
14828: CALL_OW 74
14832: PPUSH
14833: CALL_OW 115
// wait ( 0 0$20 ) ;
14837: LD_INT 700
14839: PPUSH
14840: CALL_OW 67
// SetSide ( un , your_side ) ;
14844: LD_VAR 0 1
14848: PPUSH
14849: LD_OWVAR 2
14853: PPUSH
14854: CALL_OW 235
// end ;
14858: PPOPN 2
14860: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14861: LD_EXP 19
14865: PUSH
14866: LD_EXP 52
14870: AND
14871: IFFALSE 14977
14873: GO 14875
14875: DISABLE
14876: LD_INT 0
14878: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14879: LD_ADDR_VAR 0 1
14883: PUSH
14884: LD_INT 22
14886: PUSH
14887: LD_OWVAR 2
14891: PUSH
14892: EMPTY
14893: LIST
14894: LIST
14895: PUSH
14896: LD_INT 2
14898: PUSH
14899: LD_INT 30
14901: PUSH
14902: LD_INT 0
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: PUSH
14909: LD_INT 30
14911: PUSH
14912: LD_INT 1
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: LIST
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PPUSH
14928: CALL_OW 69
14932: ST_TO_ADDR
// if not depot then
14933: LD_VAR 0 1
14937: NOT
14938: IFFALSE 14942
// exit ;
14940: GO 14977
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
14942: LD_VAR 0 1
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: PPUSH
14951: CALL_OW 250
14955: PPUSH
14956: LD_VAR 0 1
14960: PUSH
14961: LD_INT 1
14963: ARRAY
14964: PPUSH
14965: CALL_OW 251
14969: PPUSH
14970: LD_INT 70
14972: PPUSH
14973: CALL_OW 495
// end ;
14977: PPOPN 1
14979: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
14980: LD_EXP 19
14984: PUSH
14985: LD_EXP 53
14989: AND
14990: IFFALSE 15201
14992: GO 14994
14994: DISABLE
14995: LD_INT 0
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15002: LD_ADDR_VAR 0 5
15006: PUSH
15007: LD_INT 22
15009: PUSH
15010: LD_OWVAR 2
15014: PUSH
15015: EMPTY
15016: LIST
15017: LIST
15018: PUSH
15019: LD_INT 21
15021: PUSH
15022: LD_INT 1
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PUSH
15029: EMPTY
15030: LIST
15031: LIST
15032: PPUSH
15033: CALL_OW 69
15037: ST_TO_ADDR
// if not tmp then
15038: LD_VAR 0 5
15042: NOT
15043: IFFALSE 15047
// exit ;
15045: GO 15201
// for i in tmp do
15047: LD_ADDR_VAR 0 1
15051: PUSH
15052: LD_VAR 0 5
15056: PUSH
15057: FOR_IN
15058: IFFALSE 15199
// begin d := rand ( 0 , 5 ) ;
15060: LD_ADDR_VAR 0 4
15064: PUSH
15065: LD_INT 0
15067: PPUSH
15068: LD_INT 5
15070: PPUSH
15071: CALL_OW 12
15075: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15076: LD_ADDR_VAR 0 2
15080: PUSH
15081: LD_VAR 0 1
15085: PPUSH
15086: CALL_OW 250
15090: PPUSH
15091: LD_VAR 0 4
15095: PPUSH
15096: LD_INT 3
15098: PPUSH
15099: LD_INT 12
15101: PPUSH
15102: CALL_OW 12
15106: PPUSH
15107: CALL_OW 272
15111: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15112: LD_ADDR_VAR 0 3
15116: PUSH
15117: LD_VAR 0 1
15121: PPUSH
15122: CALL_OW 251
15126: PPUSH
15127: LD_VAR 0 4
15131: PPUSH
15132: LD_INT 3
15134: PPUSH
15135: LD_INT 12
15137: PPUSH
15138: CALL_OW 12
15142: PPUSH
15143: CALL_OW 273
15147: ST_TO_ADDR
// if ValidHex ( x , y ) then
15148: LD_VAR 0 2
15152: PPUSH
15153: LD_VAR 0 3
15157: PPUSH
15158: CALL_OW 488
15162: IFFALSE 15197
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15164: LD_VAR 0 1
15168: PPUSH
15169: LD_VAR 0 2
15173: PPUSH
15174: LD_VAR 0 3
15178: PPUSH
15179: LD_INT 3
15181: PPUSH
15182: LD_INT 6
15184: PPUSH
15185: CALL_OW 12
15189: PPUSH
15190: LD_INT 1
15192: PPUSH
15193: CALL_OW 483
// end ;
15197: GO 15057
15199: POP
15200: POP
// end ;
15201: PPOPN 5
15203: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15204: LD_EXP 19
15208: PUSH
15209: LD_EXP 54
15213: AND
15214: IFFALSE 15308
15216: GO 15218
15218: DISABLE
15219: LD_INT 0
15221: PPUSH
15222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15223: LD_ADDR_VAR 0 2
15227: PUSH
15228: LD_INT 22
15230: PUSH
15231: LD_OWVAR 2
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 32
15242: PUSH
15243: LD_INT 1
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: LD_INT 21
15252: PUSH
15253: LD_INT 2
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PUSH
15260: EMPTY
15261: LIST
15262: LIST
15263: LIST
15264: PPUSH
15265: CALL_OW 69
15269: ST_TO_ADDR
// if not tmp then
15270: LD_VAR 0 2
15274: NOT
15275: IFFALSE 15279
// exit ;
15277: GO 15308
// for i in tmp do
15279: LD_ADDR_VAR 0 1
15283: PUSH
15284: LD_VAR 0 2
15288: PUSH
15289: FOR_IN
15290: IFFALSE 15306
// SetFuel ( i , 0 ) ;
15292: LD_VAR 0 1
15296: PPUSH
15297: LD_INT 0
15299: PPUSH
15300: CALL_OW 240
15304: GO 15289
15306: POP
15307: POP
// end ;
15308: PPOPN 2
15310: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15311: LD_EXP 19
15315: PUSH
15316: LD_EXP 55
15320: AND
15321: IFFALSE 15387
15323: GO 15325
15325: DISABLE
15326: LD_INT 0
15328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15329: LD_ADDR_VAR 0 1
15333: PUSH
15334: LD_INT 22
15336: PUSH
15337: LD_OWVAR 2
15341: PUSH
15342: EMPTY
15343: LIST
15344: LIST
15345: PUSH
15346: LD_INT 30
15348: PUSH
15349: LD_INT 29
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PPUSH
15360: CALL_OW 69
15364: ST_TO_ADDR
// if not tmp then
15365: LD_VAR 0 1
15369: NOT
15370: IFFALSE 15374
// exit ;
15372: GO 15387
// DestroyUnit ( tmp [ 1 ] ) ;
15374: LD_VAR 0 1
15378: PUSH
15379: LD_INT 1
15381: ARRAY
15382: PPUSH
15383: CALL_OW 65
// end ;
15387: PPOPN 1
15389: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15390: LD_EXP 19
15394: PUSH
15395: LD_EXP 57
15399: AND
15400: IFFALSE 15529
15402: GO 15404
15404: DISABLE
15405: LD_INT 0
15407: PPUSH
// begin uc_side := 0 ;
15408: LD_ADDR_OWVAR 20
15412: PUSH
15413: LD_INT 0
15415: ST_TO_ADDR
// uc_nation := nation_arabian ;
15416: LD_ADDR_OWVAR 21
15420: PUSH
15421: LD_INT 2
15423: ST_TO_ADDR
// hc_gallery :=  ;
15424: LD_ADDR_OWVAR 33
15428: PUSH
15429: LD_STRING 
15431: ST_TO_ADDR
// hc_name :=  ;
15432: LD_ADDR_OWVAR 26
15436: PUSH
15437: LD_STRING 
15439: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15440: LD_INT 1
15442: PPUSH
15443: LD_INT 11
15445: PPUSH
15446: LD_INT 10
15448: PPUSH
15449: CALL_OW 380
// un := CreateHuman ;
15453: LD_ADDR_VAR 0 1
15457: PUSH
15458: CALL_OW 44
15462: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15463: LD_VAR 0 1
15467: PPUSH
15468: LD_INT 1
15470: PPUSH
15471: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15475: LD_INT 35
15477: PPUSH
15478: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15482: LD_VAR 0 1
15486: PPUSH
15487: LD_INT 22
15489: PUSH
15490: LD_OWVAR 2
15494: PUSH
15495: EMPTY
15496: LIST
15497: LIST
15498: PPUSH
15499: CALL_OW 69
15503: PPUSH
15504: LD_VAR 0 1
15508: PPUSH
15509: CALL_OW 74
15513: PPUSH
15514: CALL_OW 115
// until IsDead ( un ) ;
15518: LD_VAR 0 1
15522: PPUSH
15523: CALL_OW 301
15527: IFFALSE 15475
// end ;
15529: PPOPN 1
15531: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15532: LD_EXP 19
15536: PUSH
15537: LD_EXP 59
15541: AND
15542: IFFALSE 15554
15544: GO 15546
15546: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15547: LD_STRING earthquake(getX(game), 0, 32)
15549: PPUSH
15550: CALL_OW 559
15554: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15555: LD_EXP 19
15559: PUSH
15560: LD_EXP 60
15564: AND
15565: IFFALSE 15656
15567: GO 15569
15569: DISABLE
15570: LD_INT 0
15572: PPUSH
// begin enable ;
15573: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15574: LD_ADDR_VAR 0 1
15578: PUSH
15579: LD_INT 22
15581: PUSH
15582: LD_OWVAR 2
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: LD_INT 21
15593: PUSH
15594: LD_INT 2
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PUSH
15601: LD_INT 33
15603: PUSH
15604: LD_INT 3
15606: PUSH
15607: EMPTY
15608: LIST
15609: LIST
15610: PUSH
15611: EMPTY
15612: LIST
15613: LIST
15614: LIST
15615: PPUSH
15616: CALL_OW 69
15620: ST_TO_ADDR
// if not tmp then
15621: LD_VAR 0 1
15625: NOT
15626: IFFALSE 15630
// exit ;
15628: GO 15656
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15630: LD_VAR 0 1
15634: PUSH
15635: LD_INT 1
15637: PPUSH
15638: LD_VAR 0 1
15642: PPUSH
15643: CALL_OW 12
15647: ARRAY
15648: PPUSH
15649: LD_INT 1
15651: PPUSH
15652: CALL_OW 234
// end ;
15656: PPOPN 1
15658: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15659: LD_EXP 19
15663: PUSH
15664: LD_EXP 61
15668: AND
15669: IFFALSE 15810
15671: GO 15673
15673: DISABLE
15674: LD_INT 0
15676: PPUSH
15677: PPUSH
15678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15679: LD_ADDR_VAR 0 3
15683: PUSH
15684: LD_INT 22
15686: PUSH
15687: LD_OWVAR 2
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PUSH
15696: LD_INT 25
15698: PUSH
15699: LD_INT 1
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PUSH
15706: EMPTY
15707: LIST
15708: LIST
15709: PPUSH
15710: CALL_OW 69
15714: ST_TO_ADDR
// if not tmp then
15715: LD_VAR 0 3
15719: NOT
15720: IFFALSE 15724
// exit ;
15722: GO 15810
// un := tmp [ rand ( 1 , tmp ) ] ;
15724: LD_ADDR_VAR 0 2
15728: PUSH
15729: LD_VAR 0 3
15733: PUSH
15734: LD_INT 1
15736: PPUSH
15737: LD_VAR 0 3
15741: PPUSH
15742: CALL_OW 12
15746: ARRAY
15747: ST_TO_ADDR
// if Crawls ( un ) then
15748: LD_VAR 0 2
15752: PPUSH
15753: CALL_OW 318
15757: IFFALSE 15768
// ComWalk ( un ) ;
15759: LD_VAR 0 2
15763: PPUSH
15764: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15768: LD_VAR 0 2
15772: PPUSH
15773: LD_INT 9
15775: PPUSH
15776: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
15780: LD_INT 28
15782: PPUSH
15783: LD_OWVAR 2
15787: PPUSH
15788: LD_INT 2
15790: PPUSH
15791: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
15795: LD_INT 29
15797: PPUSH
15798: LD_OWVAR 2
15802: PPUSH
15803: LD_INT 2
15805: PPUSH
15806: CALL_OW 322
// end ;
15810: PPOPN 3
15812: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
15813: LD_EXP 19
15817: PUSH
15818: LD_EXP 62
15822: AND
15823: IFFALSE 15934
15825: GO 15827
15827: DISABLE
15828: LD_INT 0
15830: PPUSH
15831: PPUSH
15832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15833: LD_ADDR_VAR 0 3
15837: PUSH
15838: LD_INT 22
15840: PUSH
15841: LD_OWVAR 2
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 1
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: EMPTY
15861: LIST
15862: LIST
15863: PPUSH
15864: CALL_OW 69
15868: ST_TO_ADDR
// if not tmp then
15869: LD_VAR 0 3
15873: NOT
15874: IFFALSE 15878
// exit ;
15876: GO 15934
// un := tmp [ rand ( 1 , tmp ) ] ;
15878: LD_ADDR_VAR 0 2
15882: PUSH
15883: LD_VAR 0 3
15887: PUSH
15888: LD_INT 1
15890: PPUSH
15891: LD_VAR 0 3
15895: PPUSH
15896: CALL_OW 12
15900: ARRAY
15901: ST_TO_ADDR
// if Crawls ( un ) then
15902: LD_VAR 0 2
15906: PPUSH
15907: CALL_OW 318
15911: IFFALSE 15922
// ComWalk ( un ) ;
15913: LD_VAR 0 2
15917: PPUSH
15918: CALL_OW 138
// SetClass ( un , class_mortar ) ;
15922: LD_VAR 0 2
15926: PPUSH
15927: LD_INT 8
15929: PPUSH
15930: CALL_OW 336
// end ;
15934: PPOPN 3
15936: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
15937: LD_EXP 19
15941: PUSH
15942: LD_EXP 63
15946: AND
15947: IFFALSE 16091
15949: GO 15951
15951: DISABLE
15952: LD_INT 0
15954: PPUSH
15955: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
15956: LD_ADDR_VAR 0 2
15960: PUSH
15961: LD_INT 22
15963: PUSH
15964: LD_OWVAR 2
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: LD_INT 21
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PUSH
15983: LD_INT 2
15985: PUSH
15986: LD_INT 34
15988: PUSH
15989: LD_INT 12
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: LD_INT 34
15998: PUSH
15999: LD_INT 51
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PUSH
16006: LD_INT 34
16008: PUSH
16009: LD_INT 32
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 69
16031: ST_TO_ADDR
// if not tmp then
16032: LD_VAR 0 2
16036: NOT
16037: IFFALSE 16041
// exit ;
16039: GO 16091
// for i in tmp do
16041: LD_ADDR_VAR 0 1
16045: PUSH
16046: LD_VAR 0 2
16050: PUSH
16051: FOR_IN
16052: IFFALSE 16089
// if GetCargo ( i , mat_artifact ) = 0 then
16054: LD_VAR 0 1
16058: PPUSH
16059: LD_INT 4
16061: PPUSH
16062: CALL_OW 289
16066: PUSH
16067: LD_INT 0
16069: EQUAL
16070: IFFALSE 16087
// SetCargo ( i , mat_siberit , 100 ) ;
16072: LD_VAR 0 1
16076: PPUSH
16077: LD_INT 3
16079: PPUSH
16080: LD_INT 100
16082: PPUSH
16083: CALL_OW 290
16087: GO 16051
16089: POP
16090: POP
// end ;
16091: PPOPN 2
16093: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
16094: LD_EXP 19
16098: PUSH
16099: LD_EXP 64
16103: AND
16104: IFFALSE 16257
16106: GO 16108
16108: DISABLE
16109: LD_INT 0
16111: PPUSH
16112: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
16113: LD_ADDR_VAR 0 2
16117: PUSH
16118: LD_INT 22
16120: PUSH
16121: LD_OWVAR 2
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: PPUSH
16130: CALL_OW 69
16134: ST_TO_ADDR
// if not tmp then
16135: LD_VAR 0 2
16139: NOT
16140: IFFALSE 16144
// exit ;
16142: GO 16257
// for i := 1 to 2 do
16144: LD_ADDR_VAR 0 1
16148: PUSH
16149: DOUBLE
16150: LD_INT 1
16152: DEC
16153: ST_TO_ADDR
16154: LD_INT 2
16156: PUSH
16157: FOR_TO
16158: IFFALSE 16255
// begin uc_side := your_side ;
16160: LD_ADDR_OWVAR 20
16164: PUSH
16165: LD_OWVAR 2
16169: ST_TO_ADDR
// uc_nation := nation_american ;
16170: LD_ADDR_OWVAR 21
16174: PUSH
16175: LD_INT 1
16177: ST_TO_ADDR
// vc_chassis := us_morphling ;
16178: LD_ADDR_OWVAR 37
16182: PUSH
16183: LD_INT 5
16185: ST_TO_ADDR
// vc_engine := engine_siberite ;
16186: LD_ADDR_OWVAR 39
16190: PUSH
16191: LD_INT 3
16193: ST_TO_ADDR
// vc_control := control_computer ;
16194: LD_ADDR_OWVAR 38
16198: PUSH
16199: LD_INT 3
16201: ST_TO_ADDR
// vc_weapon := us_double_laser ;
16202: LD_ADDR_OWVAR 40
16206: PUSH
16207: LD_INT 10
16209: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
16210: CALL_OW 45
16214: PPUSH
16215: LD_VAR 0 2
16219: PUSH
16220: LD_INT 1
16222: ARRAY
16223: PPUSH
16224: CALL_OW 250
16228: PPUSH
16229: LD_VAR 0 2
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: CALL_OW 251
16242: PPUSH
16243: LD_INT 12
16245: PPUSH
16246: LD_INT 1
16248: PPUSH
16249: CALL_OW 50
// end ;
16253: GO 16157
16255: POP
16256: POP
// end ;
16257: PPOPN 2
16259: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
16260: LD_EXP 19
16264: PUSH
16265: LD_EXP 65
16269: AND
16270: IFFALSE 16492
16272: GO 16274
16274: DISABLE
16275: LD_INT 0
16277: PPUSH
16278: PPUSH
16279: PPUSH
16280: PPUSH
16281: PPUSH
16282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16283: LD_ADDR_VAR 0 6
16287: PUSH
16288: LD_INT 22
16290: PUSH
16291: LD_OWVAR 2
16295: PUSH
16296: EMPTY
16297: LIST
16298: LIST
16299: PUSH
16300: LD_INT 21
16302: PUSH
16303: LD_INT 1
16305: PUSH
16306: EMPTY
16307: LIST
16308: LIST
16309: PUSH
16310: LD_INT 3
16312: PUSH
16313: LD_INT 23
16315: PUSH
16316: LD_INT 0
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: LIST
16331: PPUSH
16332: CALL_OW 69
16336: ST_TO_ADDR
// if not tmp then
16337: LD_VAR 0 6
16341: NOT
16342: IFFALSE 16346
// exit ;
16344: GO 16492
// s1 := rand ( 1 , 4 ) ;
16346: LD_ADDR_VAR 0 2
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 4
16356: PPUSH
16357: CALL_OW 12
16361: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
16362: LD_ADDR_VAR 0 4
16366: PUSH
16367: LD_VAR 0 6
16371: PUSH
16372: LD_INT 1
16374: ARRAY
16375: PPUSH
16376: LD_VAR 0 2
16380: PPUSH
16381: CALL_OW 259
16385: ST_TO_ADDR
// if s1 = 1 then
16386: LD_VAR 0 2
16390: PUSH
16391: LD_INT 1
16393: EQUAL
16394: IFFALSE 16414
// s2 := rand ( 2 , 4 ) else
16396: LD_ADDR_VAR 0 3
16400: PUSH
16401: LD_INT 2
16403: PPUSH
16404: LD_INT 4
16406: PPUSH
16407: CALL_OW 12
16411: ST_TO_ADDR
16412: GO 16422
// s2 := 1 ;
16414: LD_ADDR_VAR 0 3
16418: PUSH
16419: LD_INT 1
16421: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16422: LD_ADDR_VAR 0 5
16426: PUSH
16427: LD_VAR 0 6
16431: PUSH
16432: LD_INT 1
16434: ARRAY
16435: PPUSH
16436: LD_VAR 0 3
16440: PPUSH
16441: CALL_OW 259
16445: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16446: LD_VAR 0 6
16450: PUSH
16451: LD_INT 1
16453: ARRAY
16454: PPUSH
16455: LD_VAR 0 2
16459: PPUSH
16460: LD_VAR 0 5
16464: PPUSH
16465: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16469: LD_VAR 0 6
16473: PUSH
16474: LD_INT 1
16476: ARRAY
16477: PPUSH
16478: LD_VAR 0 3
16482: PPUSH
16483: LD_VAR 0 4
16487: PPUSH
16488: CALL_OW 237
// end ;
16492: PPOPN 6
16494: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16495: LD_EXP 19
16499: PUSH
16500: LD_EXP 66
16504: AND
16505: IFFALSE 16584
16507: GO 16509
16509: DISABLE
16510: LD_INT 0
16512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16513: LD_ADDR_VAR 0 1
16517: PUSH
16518: LD_INT 22
16520: PUSH
16521: LD_OWVAR 2
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 30
16532: PUSH
16533: LD_INT 3
16535: PUSH
16536: EMPTY
16537: LIST
16538: LIST
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: ST_TO_ADDR
// if not tmp then
16549: LD_VAR 0 1
16553: NOT
16554: IFFALSE 16558
// exit ;
16556: GO 16584
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16558: LD_VAR 0 1
16562: PUSH
16563: LD_INT 1
16565: PPUSH
16566: LD_VAR 0 1
16570: PPUSH
16571: CALL_OW 12
16575: ARRAY
16576: PPUSH
16577: LD_INT 1
16579: PPUSH
16580: CALL_OW 234
// end ;
16584: PPOPN 1
16586: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16587: LD_EXP 19
16591: PUSH
16592: LD_EXP 67
16596: AND
16597: IFFALSE 16709
16599: GO 16601
16601: DISABLE
16602: LD_INT 0
16604: PPUSH
16605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16606: LD_ADDR_VAR 0 2
16610: PUSH
16611: LD_INT 22
16613: PUSH
16614: LD_OWVAR 2
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: PUSH
16623: LD_INT 2
16625: PUSH
16626: LD_INT 30
16628: PUSH
16629: LD_INT 27
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 26
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 28
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: LIST
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: PPUSH
16666: CALL_OW 69
16670: ST_TO_ADDR
// if not tmp then
16671: LD_VAR 0 2
16675: NOT
16676: IFFALSE 16680
// exit ;
16678: GO 16709
// for i in tmp do
16680: LD_ADDR_VAR 0 1
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: FOR_IN
16691: IFFALSE 16707
// SetLives ( i , 1 ) ;
16693: LD_VAR 0 1
16697: PPUSH
16698: LD_INT 1
16700: PPUSH
16701: CALL_OW 234
16705: GO 16690
16707: POP
16708: POP
// end ;
16709: PPOPN 2
16711: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16712: LD_EXP 19
16716: PUSH
16717: LD_EXP 68
16721: AND
16722: IFFALSE 16996
16724: GO 16726
16726: DISABLE
16727: LD_INT 0
16729: PPUSH
16730: PPUSH
16731: PPUSH
// begin i := rand ( 1 , 7 ) ;
16732: LD_ADDR_VAR 0 1
16736: PUSH
16737: LD_INT 1
16739: PPUSH
16740: LD_INT 7
16742: PPUSH
16743: CALL_OW 12
16747: ST_TO_ADDR
// case i of 1 :
16748: LD_VAR 0 1
16752: PUSH
16753: LD_INT 1
16755: DOUBLE
16756: EQUAL
16757: IFTRUE 16761
16759: GO 16771
16761: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16762: LD_STRING earthquake(getX(game), 0, 32)
16764: PPUSH
16765: CALL_OW 559
16769: GO 16996
16771: LD_INT 2
16773: DOUBLE
16774: EQUAL
16775: IFTRUE 16779
16777: GO 16793
16779: POP
// begin ToLua ( displayStucuk(); ) ;
16780: LD_STRING displayStucuk();
16782: PPUSH
16783: CALL_OW 559
// ResetFog ;
16787: CALL_OW 335
// end ; 3 :
16791: GO 16996
16793: LD_INT 3
16795: DOUBLE
16796: EQUAL
16797: IFTRUE 16801
16799: GO 16905
16801: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16802: LD_ADDR_VAR 0 2
16806: PUSH
16807: LD_INT 22
16809: PUSH
16810: LD_OWVAR 2
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: LD_INT 25
16821: PUSH
16822: LD_INT 1
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 69
16837: ST_TO_ADDR
// if not tmp then
16838: LD_VAR 0 2
16842: NOT
16843: IFFALSE 16847
// exit ;
16845: GO 16996
// un := tmp [ rand ( 1 , tmp ) ] ;
16847: LD_ADDR_VAR 0 3
16851: PUSH
16852: LD_VAR 0 2
16856: PUSH
16857: LD_INT 1
16859: PPUSH
16860: LD_VAR 0 2
16864: PPUSH
16865: CALL_OW 12
16869: ARRAY
16870: ST_TO_ADDR
// if Crawls ( un ) then
16871: LD_VAR 0 3
16875: PPUSH
16876: CALL_OW 318
16880: IFFALSE 16891
// ComWalk ( un ) ;
16882: LD_VAR 0 3
16886: PPUSH
16887: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16891: LD_VAR 0 3
16895: PPUSH
16896: LD_INT 8
16898: PPUSH
16899: CALL_OW 336
// end ; 4 :
16903: GO 16996
16905: LD_INT 4
16907: DOUBLE
16908: EQUAL
16909: IFTRUE 16913
16911: GO 16974
16913: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16914: LD_ADDR_VAR 0 2
16918: PUSH
16919: LD_INT 22
16921: PUSH
16922: LD_OWVAR 2
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 30
16933: PUSH
16934: LD_INT 29
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PPUSH
16945: CALL_OW 69
16949: ST_TO_ADDR
// if not tmp then
16950: LD_VAR 0 2
16954: NOT
16955: IFFALSE 16959
// exit ;
16957: GO 16996
// DestroyUnit ( tmp [ 1 ] ) ;
16959: LD_VAR 0 2
16963: PUSH
16964: LD_INT 1
16966: ARRAY
16967: PPUSH
16968: CALL_OW 65
// end ; 5 .. 7 :
16972: GO 16996
16974: LD_INT 5
16976: DOUBLE
16977: GREATEREQUAL
16978: IFFALSE 16986
16980: LD_INT 7
16982: DOUBLE
16983: LESSEQUAL
16984: IFTRUE 16988
16986: GO 16995
16988: POP
// StreamSibBomb ; end ;
16989: CALL 13276 0 0
16993: GO 16996
16995: POP
// end ;
16996: PPOPN 3
16998: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
16999: LD_EXP 19
17003: PUSH
17004: LD_EXP 69
17008: AND
17009: IFFALSE 17165
17011: GO 17013
17013: DISABLE
17014: LD_INT 0
17016: PPUSH
17017: PPUSH
17018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
17019: LD_ADDR_VAR 0 2
17023: PUSH
17024: LD_INT 81
17026: PUSH
17027: LD_OWVAR 2
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: PUSH
17036: LD_INT 2
17038: PUSH
17039: LD_INT 21
17041: PUSH
17042: LD_INT 1
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 21
17051: PUSH
17052: LD_INT 2
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: LIST
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PPUSH
17068: CALL_OW 69
17072: ST_TO_ADDR
// if not tmp then
17073: LD_VAR 0 2
17077: NOT
17078: IFFALSE 17082
// exit ;
17080: GO 17165
// p := 0 ;
17082: LD_ADDR_VAR 0 3
17086: PUSH
17087: LD_INT 0
17089: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17090: LD_INT 35
17092: PPUSH
17093: CALL_OW 67
// p := p + 1 ;
17097: LD_ADDR_VAR 0 3
17101: PUSH
17102: LD_VAR 0 3
17106: PUSH
17107: LD_INT 1
17109: PLUS
17110: ST_TO_ADDR
// for i in tmp do
17111: LD_ADDR_VAR 0 1
17115: PUSH
17116: LD_VAR 0 2
17120: PUSH
17121: FOR_IN
17122: IFFALSE 17153
// if GetLives ( i ) < 1000 then
17124: LD_VAR 0 1
17128: PPUSH
17129: CALL_OW 256
17133: PUSH
17134: LD_INT 1000
17136: LESS
17137: IFFALSE 17151
// SetLives ( i , 1000 ) ;
17139: LD_VAR 0 1
17143: PPUSH
17144: LD_INT 1000
17146: PPUSH
17147: CALL_OW 234
17151: GO 17121
17153: POP
17154: POP
// until p > 20 ;
17155: LD_VAR 0 3
17159: PUSH
17160: LD_INT 20
17162: GREATER
17163: IFFALSE 17090
// end ;
17165: PPOPN 3
17167: END
// every 0 0$1 trigger StreamModeActive and sTime do
17168: LD_EXP 19
17172: PUSH
17173: LD_EXP 70
17177: AND
17178: IFFALSE 17213
17180: GO 17182
17182: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
17183: LD_INT 28
17185: PPUSH
17186: LD_OWVAR 2
17190: PPUSH
17191: LD_INT 2
17193: PPUSH
17194: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
17198: LD_INT 30
17200: PPUSH
17201: LD_OWVAR 2
17205: PPUSH
17206: LD_INT 2
17208: PPUSH
17209: CALL_OW 322
// end ;
17213: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
17214: LD_EXP 19
17218: PUSH
17219: LD_EXP 71
17223: AND
17224: IFFALSE 17345
17226: GO 17228
17228: DISABLE
17229: LD_INT 0
17231: PPUSH
17232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17233: LD_ADDR_VAR 0 2
17237: PUSH
17238: LD_INT 22
17240: PUSH
17241: LD_OWVAR 2
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: PUSH
17250: LD_INT 21
17252: PUSH
17253: LD_INT 1
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: PUSH
17260: LD_INT 3
17262: PUSH
17263: LD_INT 23
17265: PUSH
17266: LD_INT 0
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: LIST
17281: PPUSH
17282: CALL_OW 69
17286: ST_TO_ADDR
// if not tmp then
17287: LD_VAR 0 2
17291: NOT
17292: IFFALSE 17296
// exit ;
17294: GO 17345
// for i in tmp do
17296: LD_ADDR_VAR 0 1
17300: PUSH
17301: LD_VAR 0 2
17305: PUSH
17306: FOR_IN
17307: IFFALSE 17343
// begin if Crawls ( i ) then
17309: LD_VAR 0 1
17313: PPUSH
17314: CALL_OW 318
17318: IFFALSE 17329
// ComWalk ( i ) ;
17320: LD_VAR 0 1
17324: PPUSH
17325: CALL_OW 138
// SetClass ( i , 2 ) ;
17329: LD_VAR 0 1
17333: PPUSH
17334: LD_INT 2
17336: PPUSH
17337: CALL_OW 336
// end ;
17341: GO 17306
17343: POP
17344: POP
// end ;
17345: PPOPN 2
17347: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
17348: LD_EXP 19
17352: PUSH
17353: LD_EXP 72
17357: AND
17358: IFFALSE 17579
17360: GO 17362
17362: DISABLE
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
17367: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
17368: LD_OWVAR 2
17372: PPUSH
17373: LD_INT 9
17375: PPUSH
17376: LD_INT 1
17378: PPUSH
17379: LD_INT 1
17381: PPUSH
17382: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17386: LD_INT 9
17388: PPUSH
17389: LD_OWVAR 2
17393: PPUSH
17394: CALL_OW 343
// uc_side := 9 ;
17398: LD_ADDR_OWVAR 20
17402: PUSH
17403: LD_INT 9
17405: ST_TO_ADDR
// uc_nation := 2 ;
17406: LD_ADDR_OWVAR 21
17410: PUSH
17411: LD_INT 2
17413: ST_TO_ADDR
// hc_name := Dark Warrior ;
17414: LD_ADDR_OWVAR 26
17418: PUSH
17419: LD_STRING Dark Warrior
17421: ST_TO_ADDR
// hc_gallery :=  ;
17422: LD_ADDR_OWVAR 33
17426: PUSH
17427: LD_STRING 
17429: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
17430: LD_INT 1
17432: PPUSH
17433: LD_INT 1
17435: PPUSH
17436: LD_INT 10
17438: PPUSH
17439: CALL_OW 380
// un := CreateHuman ;
17443: LD_ADDR_VAR 0 3
17447: PUSH
17448: CALL_OW 44
17452: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17453: LD_VAR 0 3
17457: PPUSH
17458: LD_INT 1
17460: PPUSH
17461: CALL_OW 51
// p := 0 ;
17465: LD_ADDR_VAR 0 2
17469: PUSH
17470: LD_INT 0
17472: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17473: LD_INT 35
17475: PPUSH
17476: CALL_OW 67
// if GetLives ( un ) < 1000 then
17480: LD_VAR 0 3
17484: PPUSH
17485: CALL_OW 256
17489: PUSH
17490: LD_INT 1000
17492: LESS
17493: IFFALSE 17507
// SetLives ( un , 1000 ) ;
17495: LD_VAR 0 3
17499: PPUSH
17500: LD_INT 1000
17502: PPUSH
17503: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
17507: LD_VAR 0 3
17511: PPUSH
17512: LD_INT 81
17514: PUSH
17515: LD_OWVAR 2
17519: PUSH
17520: EMPTY
17521: LIST
17522: LIST
17523: PPUSH
17524: CALL_OW 69
17528: PPUSH
17529: LD_VAR 0 3
17533: PPUSH
17534: CALL_OW 74
17538: PPUSH
17539: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17543: LD_VAR 0 2
17547: PUSH
17548: LD_INT 60
17550: GREATER
17551: PUSH
17552: LD_VAR 0 3
17556: PPUSH
17557: CALL_OW 301
17561: OR
17562: IFFALSE 17473
// if un then
17564: LD_VAR 0 3
17568: IFFALSE 17579
// RemoveUnit ( un ) ;
17570: LD_VAR 0 3
17574: PPUSH
17575: CALL_OW 64
// end ; end_of_file
17579: PPOPN 3
17581: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17582: LD_INT 0
17584: PPUSH
17585: PPUSH
17586: PPUSH
17587: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17588: LD_VAR 0 1
17592: PPUSH
17593: CALL_OW 264
17597: PUSH
17598: LD_EXP 18
17602: EQUAL
17603: IFFALSE 17675
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17605: LD_INT 68
17607: PPUSH
17608: LD_VAR 0 1
17612: PPUSH
17613: CALL_OW 255
17617: PPUSH
17618: CALL_OW 321
17622: PUSH
17623: LD_INT 2
17625: EQUAL
17626: IFFALSE 17638
// eff := 70 else
17628: LD_ADDR_VAR 0 6
17632: PUSH
17633: LD_INT 70
17635: ST_TO_ADDR
17636: GO 17646
// eff := 30 ;
17638: LD_ADDR_VAR 0 6
17642: PUSH
17643: LD_INT 30
17645: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17646: LD_VAR 0 1
17650: PPUSH
17651: CALL_OW 250
17655: PPUSH
17656: LD_VAR 0 1
17660: PPUSH
17661: CALL_OW 251
17665: PPUSH
17666: LD_VAR 0 6
17670: PPUSH
17671: CALL_OW 495
// end ; end ;
17675: LD_VAR 0 4
17679: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17680: LD_INT 0
17682: PPUSH
17683: PPUSH
17684: PPUSH
17685: PPUSH
17686: PPUSH
17687: PPUSH
// if cmd = 124 then
17688: LD_VAR 0 1
17692: PUSH
17693: LD_INT 124
17695: EQUAL
17696: IFFALSE 17902
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17698: LD_ADDR_VAR 0 5
17702: PUSH
17703: LD_INT 2
17705: PUSH
17706: LD_INT 34
17708: PUSH
17709: LD_INT 53
17711: PUSH
17712: EMPTY
17713: LIST
17714: LIST
17715: PUSH
17716: LD_INT 34
17718: PUSH
17719: LD_INT 14
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: LIST
17730: PPUSH
17731: CALL_OW 69
17735: ST_TO_ADDR
// if not tmp then
17736: LD_VAR 0 5
17740: NOT
17741: IFFALSE 17745
// exit ;
17743: GO 17902
// for i in tmp do
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_VAR 0 5
17754: PUSH
17755: FOR_IN
17756: IFFALSE 17900
// begin taskList := GetTaskList ( i ) ;
17758: LD_ADDR_VAR 0 6
17762: PUSH
17763: LD_VAR 0 3
17767: PPUSH
17768: CALL_OW 437
17772: ST_TO_ADDR
// if not taskList then
17773: LD_VAR 0 6
17777: NOT
17778: IFFALSE 17782
// continue ;
17780: GO 17755
// for j = 1 to taskList do
17782: LD_ADDR_VAR 0 4
17786: PUSH
17787: DOUBLE
17788: LD_INT 1
17790: DEC
17791: ST_TO_ADDR
17792: LD_VAR 0 6
17796: PUSH
17797: FOR_TO
17798: IFFALSE 17896
// if taskList [ j ] [ 1 ] = | then
17800: LD_VAR 0 6
17804: PUSH
17805: LD_VAR 0 4
17809: ARRAY
17810: PUSH
17811: LD_INT 1
17813: ARRAY
17814: PUSH
17815: LD_STRING |
17817: EQUAL
17818: IFFALSE 17894
// begin _taskList := Delete ( taskList , 1 ) ;
17820: LD_ADDR_VAR 0 7
17824: PUSH
17825: LD_VAR 0 6
17829: PPUSH
17830: LD_INT 1
17832: PPUSH
17833: CALL_OW 3
17837: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17838: LD_VAR 0 3
17842: PPUSH
17843: LD_VAR 0 7
17847: PPUSH
17848: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17852: LD_VAR 0 3
17856: PPUSH
17857: LD_VAR 0 6
17861: PUSH
17862: LD_VAR 0 4
17866: ARRAY
17867: PUSH
17868: LD_INT 2
17870: ARRAY
17871: PPUSH
17872: LD_VAR 0 6
17876: PUSH
17877: LD_VAR 0 4
17881: ARRAY
17882: PUSH
17883: LD_INT 3
17885: ARRAY
17886: PPUSH
17887: LD_INT 8
17889: PPUSH
17890: CALL 17907 0 4
// end ;
17894: GO 17797
17896: POP
17897: POP
// end ;
17898: GO 17755
17900: POP
17901: POP
// end ; end ;
17902: LD_VAR 0 2
17906: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17907: LD_INT 0
17909: PPUSH
17910: PPUSH
17911: PPUSH
17912: PPUSH
17913: PPUSH
17914: PPUSH
17915: PPUSH
17916: PPUSH
17917: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17918: LD_VAR 0 1
17922: NOT
17923: PUSH
17924: LD_VAR 0 2
17928: PPUSH
17929: LD_VAR 0 3
17933: PPUSH
17934: CALL_OW 488
17938: NOT
17939: OR
17940: PUSH
17941: LD_VAR 0 4
17945: NOT
17946: OR
17947: IFFALSE 17951
// exit ;
17949: GO 18291
// list := [ ] ;
17951: LD_ADDR_VAR 0 13
17955: PUSH
17956: EMPTY
17957: ST_TO_ADDR
// if x - r < 0 then
17958: LD_VAR 0 2
17962: PUSH
17963: LD_VAR 0 4
17967: MINUS
17968: PUSH
17969: LD_INT 0
17971: LESS
17972: IFFALSE 17984
// min_x := 0 else
17974: LD_ADDR_VAR 0 7
17978: PUSH
17979: LD_INT 0
17981: ST_TO_ADDR
17982: GO 18000
// min_x := x - r ;
17984: LD_ADDR_VAR 0 7
17988: PUSH
17989: LD_VAR 0 2
17993: PUSH
17994: LD_VAR 0 4
17998: MINUS
17999: ST_TO_ADDR
// if y - r < 0 then
18000: LD_VAR 0 3
18004: PUSH
18005: LD_VAR 0 4
18009: MINUS
18010: PUSH
18011: LD_INT 0
18013: LESS
18014: IFFALSE 18026
// min_y := 0 else
18016: LD_ADDR_VAR 0 8
18020: PUSH
18021: LD_INT 0
18023: ST_TO_ADDR
18024: GO 18042
// min_y := y - r ;
18026: LD_ADDR_VAR 0 8
18030: PUSH
18031: LD_VAR 0 3
18035: PUSH
18036: LD_VAR 0 4
18040: MINUS
18041: ST_TO_ADDR
// max_x := x + r ;
18042: LD_ADDR_VAR 0 9
18046: PUSH
18047: LD_VAR 0 2
18051: PUSH
18052: LD_VAR 0 4
18056: PLUS
18057: ST_TO_ADDR
// max_y := y + r ;
18058: LD_ADDR_VAR 0 10
18062: PUSH
18063: LD_VAR 0 3
18067: PUSH
18068: LD_VAR 0 4
18072: PLUS
18073: ST_TO_ADDR
// for _x = min_x to max_x do
18074: LD_ADDR_VAR 0 11
18078: PUSH
18079: DOUBLE
18080: LD_VAR 0 7
18084: DEC
18085: ST_TO_ADDR
18086: LD_VAR 0 9
18090: PUSH
18091: FOR_TO
18092: IFFALSE 18209
// for _y = min_y to max_y do
18094: LD_ADDR_VAR 0 12
18098: PUSH
18099: DOUBLE
18100: LD_VAR 0 8
18104: DEC
18105: ST_TO_ADDR
18106: LD_VAR 0 10
18110: PUSH
18111: FOR_TO
18112: IFFALSE 18205
// begin if not ValidHex ( _x , _y ) then
18114: LD_VAR 0 11
18118: PPUSH
18119: LD_VAR 0 12
18123: PPUSH
18124: CALL_OW 488
18128: NOT
18129: IFFALSE 18133
// continue ;
18131: GO 18111
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18133: LD_VAR 0 11
18137: PPUSH
18138: LD_VAR 0 12
18142: PPUSH
18143: CALL_OW 351
18147: PUSH
18148: LD_VAR 0 11
18152: PPUSH
18153: LD_VAR 0 12
18157: PPUSH
18158: CALL_OW 554
18162: AND
18163: IFFALSE 18203
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18165: LD_ADDR_VAR 0 13
18169: PUSH
18170: LD_VAR 0 13
18174: PPUSH
18175: LD_VAR 0 13
18179: PUSH
18180: LD_INT 1
18182: PLUS
18183: PPUSH
18184: LD_VAR 0 11
18188: PUSH
18189: LD_VAR 0 12
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: PPUSH
18198: CALL_OW 2
18202: ST_TO_ADDR
// end ;
18203: GO 18111
18205: POP
18206: POP
18207: GO 18091
18209: POP
18210: POP
// if not list then
18211: LD_VAR 0 13
18215: NOT
18216: IFFALSE 18220
// exit ;
18218: GO 18291
// for i in list do
18220: LD_ADDR_VAR 0 6
18224: PUSH
18225: LD_VAR 0 13
18229: PUSH
18230: FOR_IN
18231: IFFALSE 18289
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18233: LD_VAR 0 1
18237: PPUSH
18238: LD_STRING M
18240: PUSH
18241: LD_VAR 0 6
18245: PUSH
18246: LD_INT 1
18248: ARRAY
18249: PUSH
18250: LD_VAR 0 6
18254: PUSH
18255: LD_INT 2
18257: ARRAY
18258: PUSH
18259: LD_INT 0
18261: PUSH
18262: LD_INT 0
18264: PUSH
18265: LD_INT 0
18267: PUSH
18268: LD_INT 0
18270: PUSH
18271: EMPTY
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: PUSH
18280: EMPTY
18281: LIST
18282: PPUSH
18283: CALL_OW 447
18287: GO 18230
18289: POP
18290: POP
// end ;
18291: LD_VAR 0 5
18295: RET
