// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 219 0 0
// PrepareAllies ;
  12: CALL 2210 0 0
// Action ;
  16: CALL 4352 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// case query ( textdiff ) of 1 :
  28: LD_STRING textdiff
  30: PPUSH
  31: CALL_OW 97
  35: PUSH
  36: LD_INT 1
  38: DOUBLE
  39: EQUAL
  40: IFTRUE 44
  42: GO 55
  44: POP
// Difficulty := 1 ; 2 :
  45: LD_ADDR_OWVAR 67
  49: PUSH
  50: LD_INT 1
  52: ST_TO_ADDR
  53: GO 94
  55: LD_INT 2
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 74
  63: POP
// Difficulty := 2 ; 3 :
  64: LD_ADDR_OWVAR 67
  68: PUSH
  69: LD_INT 2
  71: ST_TO_ADDR
  72: GO 94
  74: LD_INT 3
  76: DOUBLE
  77: EQUAL
  78: IFTRUE 82
  80: GO 93
  82: POP
// Difficulty := 3 ; end ;
  83: LD_ADDR_OWVAR 67
  87: PUSH
  88: LD_INT 3
  90: ST_TO_ADDR
  91: GO 94
  93: POP
// InitVariables ;
  94: CALL 107 0 0
// SetDiplomacy ;
  98: CALL 171 0 0
// end ; end_of_file
 102: LD_VAR 0 1
 106: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
 107: LD_INT 0
 109: PPUSH
// points := 0 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// alert := false ;
 118: LD_ADDR_EXP 6
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// game_over := false ;
 126: LD_ADDR_EXP 7
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// wave_time := 0 0$00 ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// bonus_active := false ;
 142: LD_ADDR_EXP 11
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// ignore_wave := false ;
 150: LD_ADDR_EXP 13
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// bonus_num := 0 ;
 158: LD_ADDR_EXP 12
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// end ;
 166: LD_VAR 0 1
 170: RET
// export function SetDiplomacy ; begin
 171: LD_INT 0
 173: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 174: LD_INT 92
 176: PPUSH
 177: LD_INT 48
 179: PPUSH
 180: LD_INT 8
 182: PPUSH
 183: LD_INT 32796
 185: NEG
 186: PPUSH
 187: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 191: LD_INT 92
 193: PPUSH
 194: LD_INT 48
 196: PPUSH
 197: LD_INT 8
 199: PPUSH
 200: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 204: LD_INT 5
 206: PPUSH
 207: LD_INT 8
 209: PPUSH
 210: CALL_OW 343
// end ; end_of_file
 214: LD_VAR 0 1
 218: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
 235: PPUSH
 236: PPUSH
 237: PPUSH
 238: PPUSH
// uc_side := 2 ;
 239: LD_ADDR_OWVAR 20
 243: PUSH
 244: LD_INT 2
 246: ST_TO_ADDR
// uc_nation := nation_arabian ;
 247: LD_ADDR_OWVAR 21
 251: PUSH
 252: LD_INT 2
 254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 255: LD_INT 1
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: LD_INT 6
 263: PPUSH
 264: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 268: LD_ADDR_OWVAR 26
 272: PUSH
 273: LD_STRING Nicolas Vervecken
 275: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 276: LD_ADDR_OWVAR 33
 280: PUSH
 281: LD_STRING SecondCharsGal
 283: ST_TO_ADDR
// hc_face_number := 3 ;
 284: LD_ADDR_OWVAR 34
 288: PUSH
 289: LD_INT 3
 291: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 292: LD_ADDR_OWVAR 29
 296: PUSH
 297: LD_INT 11
 299: PUSH
 300: LD_INT 10
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: ST_TO_ADDR
// Vervecken := CreateHuman ;
 307: LD_ADDR_EXP 10
 311: PUSH
 312: CALL_OW 44
 316: ST_TO_ADDR
// InitHc ;
 317: CALL_OW 19
// uc_side := 8 ;
 321: LD_ADDR_OWVAR 20
 325: PUSH
 326: LD_INT 8
 328: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 329: LD_INT 23
 331: PPUSH
 332: CALL_OW 274
 336: PPUSH
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 4000
 342: PUSH
 343: LD_INT 2500
 345: PUSH
 346: LD_INT 1250
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: PPUSH
 360: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 364: LD_INT 23
 366: PPUSH
 367: CALL_OW 274
 371: PPUSH
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 300
 377: PPUSH
 378: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 382: LD_INT 23
 384: PPUSH
 385: CALL_OW 274
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 100
 395: PUSH
 396: LD_INT 50
 398: PUSH
 399: LD_INT 30
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_OWVAR 67
 411: ARRAY
 412: PPUSH
 413: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 417: LD_ADDR_VAR 0 14
 421: PUSH
 422: LD_INT 23
 424: PPUSH
 425: CALL_OW 250
 429: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 430: LD_ADDR_VAR 0 15
 434: PUSH
 435: LD_INT 23
 437: PPUSH
 438: CALL_OW 251
 442: ST_TO_ADDR
// team := [ ] ;
 443: LD_ADDR_VAR 0 7
 447: PUSH
 448: EMPTY
 449: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 450: LD_ADDR_VAR 0 8
 454: PUSH
 455: LD_INT 9
 457: PUSH
 458: LD_INT 8
 460: PUSH
 461: LD_INT 7
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_OWVAR 67
 473: ARRAY
 474: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 475: LD_ADDR_VAR 0 9
 479: PUSH
 480: LD_INT 11
 482: PUSH
 483: LD_INT 9
 485: PUSH
 486: LD_INT 8
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: PUSH
 494: LD_OWVAR 67
 498: ARRAY
 499: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 500: LD_ADDR_VAR 0 10
 504: PUSH
 505: LD_INT 3
 507: PUSH
 508: LD_INT 2
 510: PUSH
 511: LD_INT 2
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 525: LD_ADDR_VAR 0 11
 529: PUSH
 530: LD_INT 5
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: LD_OWVAR 67
 548: ARRAY
 549: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 550: LD_ADDR_VAR 0 12
 554: PUSH
 555: LD_INT 3
 557: PUSH
 558: LD_INT 2
 560: PUSH
 561: LD_INT 2
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_OWVAR 67
 573: ARRAY
 574: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 575: LD_ADDR_VAR 0 13
 579: PUSH
 580: LD_INT 6
 582: PUSH
 583: LD_INT 5
 585: PUSH
 586: LD_INT 4
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_OWVAR 67
 598: ARRAY
 599: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 600: LD_ADDR_VAR 0 18
 604: PUSH
 605: LD_INT 13
 607: PUSH
 608: LD_INT 1
 610: PUSH
 611: LD_INT 1
 613: PUSH
 614: LD_INT 26
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 14
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 1
 631: PUSH
 632: LD_INT 25
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 14
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 5
 649: PUSH
 650: LD_INT 32
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 14
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 1
 667: PUSH
 668: LD_INT 31
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 14
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 2
 685: PUSH
 686: LD_INT 24
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: LD_INT 14
 697: PUSH
 698: LD_INT 3
 700: PUSH
 701: LD_INT 2
 703: PUSH
 704: LD_INT 25
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: LIST
 711: LIST
 712: PUSH
 713: LD_INT 13
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 1
 721: PUSH
 722: LD_INT 24
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 740: LD_ADDR_VAR 0 2
 744: PUSH
 745: DOUBLE
 746: LD_INT 1
 748: DEC
 749: ST_TO_ADDR
 750: LD_VAR 0 18
 754: PUSH
 755: LD_OWVAR 67
 759: MINUS
 760: PUSH
 761: LD_INT 1
 763: PLUS
 764: PUSH
 765: FOR_TO
 766: IFFALSE 895
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 768: LD_ADDR_OWVAR 37
 772: PUSH
 773: LD_VAR 0 18
 777: PUSH
 778: LD_VAR 0 2
 782: ARRAY
 783: PUSH
 784: LD_INT 1
 786: ARRAY
 787: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 788: LD_ADDR_OWVAR 39
 792: PUSH
 793: LD_VAR 0 18
 797: PUSH
 798: LD_VAR 0 2
 802: ARRAY
 803: PUSH
 804: LD_INT 2
 806: ARRAY
 807: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 808: LD_ADDR_OWVAR 38
 812: PUSH
 813: LD_VAR 0 18
 817: PUSH
 818: LD_VAR 0 2
 822: ARRAY
 823: PUSH
 824: LD_INT 3
 826: ARRAY
 827: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 828: LD_ADDR_OWVAR 40
 832: PUSH
 833: LD_VAR 0 18
 837: PUSH
 838: LD_VAR 0 2
 842: ARRAY
 843: PUSH
 844: LD_INT 4
 846: ARRAY
 847: ST_TO_ADDR
// un := CreateVehicle ;
 848: LD_ADDR_VAR 0 6
 852: PUSH
 853: CALL_OW 45
 857: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 858: LD_VAR 0 6
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL_OW 12
 873: PPUSH
 874: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 878: LD_VAR 0 6
 882: PPUSH
 883: LD_INT 7
 885: PPUSH
 886: LD_INT 0
 888: PPUSH
 889: CALL_OW 49
// end ;
 893: GO 765
 895: POP
 896: POP
// for i = 1 to ape_num do
 897: LD_ADDR_VAR 0 2
 901: PUSH
 902: DOUBLE
 903: LD_INT 1
 905: DEC
 906: ST_TO_ADDR
 907: LD_VAR 0 13
 911: PUSH
 912: FOR_TO
 913: IFFALSE 980
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 915: LD_INT 0
 917: PPUSH
 918: LD_INT 16
 920: PUSH
 921: LD_INT 15
 923: PUSH
 924: EMPTY
 925: LIST
 926: LIST
 927: PUSH
 928: LD_INT 1
 930: PPUSH
 931: LD_INT 2
 933: PPUSH
 934: CALL_OW 12
 938: ARRAY
 939: PPUSH
 940: LD_VAR 0 8
 944: PPUSH
 945: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 949: LD_ADDR_VAR 0 7
 953: PUSH
 954: LD_VAR 0 7
 958: PPUSH
 959: LD_VAR 0 7
 963: PUSH
 964: LD_INT 1
 966: PLUS
 967: PPUSH
 968: CALL_OW 44
 972: PPUSH
 973: CALL_OW 2
 977: ST_TO_ADDR
// end ;
 978: GO 912
 980: POP
 981: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 982: LD_INT 1
 984: PPUSH
 985: LD_INT 1
 987: PPUSH
 988: LD_VAR 0 8
 992: PPUSH
 993: CALL_OW 380
// l1 := CreateHuman ;
 997: LD_ADDR_EXP 2
1001: PUSH
1002: CALL_OW 44
1006: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
1007: LD_EXP 2
1011: PPUSH
1012: LD_INT 23
1014: PPUSH
1015: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
1019: LD_INT 1
1021: PPUSH
1022: LD_INT 1
1024: PPUSH
1025: LD_VAR 0 8
1029: PPUSH
1030: CALL_OW 380
// l2 := CreateHuman ;
1034: LD_ADDR_EXP 3
1038: PUSH
1039: CALL_OW 44
1043: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1044: LD_EXP 3
1048: PPUSH
1049: LD_INT 23
1051: PPUSH
1052: CALL_OW 52
// for class = 1 to 4 do
1056: LD_ADDR_VAR 0 4
1060: PUSH
1061: DOUBLE
1062: LD_INT 1
1064: DEC
1065: ST_TO_ADDR
1066: LD_INT 4
1068: PUSH
1069: FOR_TO
1070: IFFALSE 1169
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_VAR 0 9
1086: PUSH
1087: LD_VAR 0 10
1091: PUSH
1092: LD_VAR 0 11
1096: PUSH
1097: LD_VAR 0 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_VAR 0 4
1112: ARRAY
1113: PUSH
1114: FOR_TO
1115: IFFALSE 1165
// begin PrepareHuman ( false , class , skill ) ;
1117: LD_INT 0
1119: PPUSH
1120: LD_VAR 0 4
1124: PPUSH
1125: LD_VAR 0 8
1129: PPUSH
1130: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1134: LD_ADDR_VAR 0 7
1138: PUSH
1139: LD_VAR 0 7
1143: PPUSH
1144: LD_VAR 0 7
1148: PUSH
1149: LD_INT 1
1151: PLUS
1152: PPUSH
1153: CALL_OW 44
1157: PPUSH
1158: CALL_OW 2
1162: ST_TO_ADDR
// end ;
1163: GO 1114
1165: POP
1166: POP
1167: GO 1069
1169: POP
1170: POP
// for i in team do
1171: LD_ADDR_VAR 0 2
1175: PUSH
1176: LD_VAR 0 7
1180: PUSH
1181: FOR_IN
1182: IFFALSE 1658
// begin b := 0 ;
1184: LD_ADDR_VAR 0 5
1188: PUSH
1189: LD_INT 0
1191: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1192: LD_VAR 0 2
1196: PPUSH
1197: CALL_OW 257
1201: PUSH
1202: LD_INT 1
1204: DOUBLE
1205: EQUAL
1206: IFTRUE 1210
1208: GO 1317
1210: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1211: LD_ADDR_VAR 0 5
1215: PUSH
1216: LD_INT 22
1218: PUSH
1219: LD_OWVAR 20
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: PUSH
1228: LD_INT 2
1230: PUSH
1231: LD_INT 30
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 30
1243: PUSH
1244: LD_INT 31
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: PUSH
1251: EMPTY
1252: LIST
1253: LIST
1254: LIST
1255: PUSH
1256: LD_INT 58
1258: PUSH
1259: EMPTY
1260: LIST
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: LIST
1266: PPUSH
1267: CALL_OW 69
1271: ST_TO_ADDR
// if not b then
1272: LD_VAR 0 5
1276: NOT
1277: IFFALSE 1315
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1279: LD_ADDR_VAR 0 5
1283: PUSH
1284: LD_INT 22
1286: PUSH
1287: LD_OWVAR 20
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PUSH
1296: LD_INT 30
1298: PUSH
1299: LD_INT 5
1301: PUSH
1302: EMPTY
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: PPUSH
1310: CALL_OW 69
1314: ST_TO_ADDR
// end ; class_engineer :
1315: GO 1556
1317: LD_INT 2
1319: DOUBLE
1320: EQUAL
1321: IFTRUE 1325
1323: GO 1364
1325: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1326: LD_ADDR_VAR 0 5
1330: PUSH
1331: LD_INT 22
1333: PUSH
1334: LD_OWVAR 20
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: PUSH
1343: LD_INT 30
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: EMPTY
1354: LIST
1355: LIST
1356: PPUSH
1357: CALL_OW 69
1361: ST_TO_ADDR
1362: GO 1556
1364: LD_INT 3
1366: DOUBLE
1367: EQUAL
1368: IFTRUE 1372
1370: GO 1461
1372: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1373: LD_ADDR_VAR 0 5
1377: PUSH
1378: LD_INT 22
1380: PUSH
1381: LD_OWVAR 20
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 21
1392: PUSH
1393: LD_INT 2
1395: PUSH
1396: EMPTY
1397: LIST
1398: LIST
1399: PUSH
1400: LD_INT 58
1402: PUSH
1403: EMPTY
1404: LIST
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PPUSH
1411: CALL_OW 69
1415: ST_TO_ADDR
// if not b then
1416: LD_VAR 0 5
1420: NOT
1421: IFFALSE 1459
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1423: LD_ADDR_VAR 0 5
1427: PUSH
1428: LD_INT 22
1430: PUSH
1431: LD_OWVAR 20
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: PUSH
1440: LD_INT 30
1442: PUSH
1443: LD_INT 3
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: PPUSH
1454: CALL_OW 69
1458: ST_TO_ADDR
// end ; class_scientistic :
1459: GO 1556
1461: LD_INT 4
1463: DOUBLE
1464: EQUAL
1465: IFTRUE 1469
1467: GO 1508
1469: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1470: LD_ADDR_VAR 0 5
1474: PUSH
1475: LD_INT 22
1477: PUSH
1478: LD_OWVAR 20
1482: PUSH
1483: EMPTY
1484: LIST
1485: LIST
1486: PUSH
1487: LD_INT 30
1489: PUSH
1490: LD_INT 8
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PUSH
1497: EMPTY
1498: LIST
1499: LIST
1500: PPUSH
1501: CALL_OW 69
1505: ST_TO_ADDR
// end ; class_apeman_soldier :
1506: GO 1556
1508: LD_INT 15
1510: DOUBLE
1511: EQUAL
1512: IFTRUE 1516
1514: GO 1555
1516: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1517: LD_ADDR_VAR 0 5
1521: PUSH
1522: LD_INT 22
1524: PUSH
1525: LD_OWVAR 20
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 30
1536: PUSH
1537: LD_INT 5
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: PPUSH
1548: CALL_OW 69
1552: ST_TO_ADDR
1553: GO 1556
1555: POP
// if b then
1556: LD_VAR 0 5
1560: IFFALSE 1631
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1562: LD_VAR 0 5
1566: PUSH
1567: LD_INT 1
1569: ARRAY
1570: PPUSH
1571: CALL_OW 266
1575: PUSH
1576: LD_INT 31
1578: EQUAL
1579: IFFALSE 1601
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1581: LD_VAR 0 2
1585: PPUSH
1586: LD_VAR 0 5
1590: PUSH
1591: LD_INT 1
1593: ARRAY
1594: PPUSH
1595: CALL 5049 0 2
1599: GO 1629
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1601: LD_VAR 0 2
1605: PPUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_INT 1
1613: PPUSH
1614: LD_VAR 0 5
1618: PPUSH
1619: CALL_OW 12
1623: ARRAY
1624: PPUSH
1625: CALL_OW 52
1629: GO 1656
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1631: LD_VAR 0 2
1635: PPUSH
1636: LD_VAR 0 14
1640: PPUSH
1641: LD_VAR 0 15
1645: PPUSH
1646: LD_INT 15
1648: PPUSH
1649: LD_INT 0
1651: PPUSH
1652: CALL_OW 50
// end ;
1656: GO 1181
1658: POP
1659: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1660: LD_ADDR_VAR 0 16
1664: PUSH
1665: LD_INT 26
1667: PUSH
1668: LD_INT 3
1670: PUSH
1671: LD_INT 2
1673: PUSH
1674: LD_INT 1
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PUSH
1682: LD_OWVAR 67
1686: ARRAY
1687: PUSH
1688: EMPTY
1689: LIST
1690: LIST
1691: PUSH
1692: LD_INT 25
1694: PUSH
1695: LD_INT 5
1697: PUSH
1698: LD_INT 4
1700: PUSH
1701: LD_INT 3
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: LIST
1708: PUSH
1709: LD_OWVAR 67
1713: ARRAY
1714: PUSH
1715: EMPTY
1716: LIST
1717: LIST
1718: PUSH
1719: LD_INT 24
1721: PUSH
1722: LD_INT 5
1724: PUSH
1725: LD_INT 5
1727: PUSH
1728: LD_INT 4
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: LIST
1735: PUSH
1736: LD_OWVAR 67
1740: ARRAY
1741: PUSH
1742: EMPTY
1743: LIST
1744: LIST
1745: PUSH
1746: LD_INT 30
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 1
1754: PUSH
1755: LD_INT 1
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: LIST
1762: PUSH
1763: LD_OWVAR 67
1767: ARRAY
1768: PUSH
1769: EMPTY
1770: LIST
1771: LIST
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1779: LD_ADDR_VAR 0 2
1783: PUSH
1784: LD_INT 22
1786: PUSH
1787: LD_OWVAR 20
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 30
1798: PUSH
1799: LD_INT 32
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: PPUSH
1810: CALL_OW 69
1814: PUSH
1815: FOR_IN
1816: IFFALSE 1989
// begin if weapons then
1818: LD_VAR 0 16
1822: IFFALSE 1946
// begin k := rand ( 1 , weapons ) ;
1824: LD_ADDR_VAR 0 3
1828: PUSH
1829: LD_INT 1
1831: PPUSH
1832: LD_VAR 0 16
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1842: LD_ADDR_VAR 0 17
1846: PUSH
1847: LD_VAR 0 16
1851: PUSH
1852: LD_VAR 0 3
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1862: LD_ADDR_VAR 0 16
1866: PUSH
1867: LD_VAR 0 16
1871: PPUSH
1872: LD_VAR 0 3
1876: PPUSH
1877: LD_INT 2
1879: PPUSH
1880: LD_VAR 0 16
1884: PUSH
1885: LD_VAR 0 3
1889: ARRAY
1890: PUSH
1891: LD_INT 2
1893: ARRAY
1894: PUSH
1895: LD_INT 1
1897: MINUS
1898: PPUSH
1899: CALL 5141 0 4
1903: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1904: LD_VAR 0 16
1908: PUSH
1909: LD_VAR 0 3
1913: ARRAY
1914: PUSH
1915: LD_INT 2
1917: ARRAY
1918: PUSH
1919: LD_INT 0
1921: EQUAL
1922: IFFALSE 1944
// weapons := Delete ( weapons , k ) ;
1924: LD_ADDR_VAR 0 16
1928: PUSH
1929: LD_VAR 0 16
1933: PPUSH
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 3
1943: ST_TO_ADDR
// end else
1944: GO 1973
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1946: LD_ADDR_VAR 0 17
1950: PUSH
1951: LD_INT 27
1953: PUSH
1954: LD_INT 23
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: PUSH
1961: LD_INT 1
1963: PPUSH
1964: LD_INT 2
1966: PPUSH
1967: CALL_OW 12
1971: ARRAY
1972: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1973: LD_VAR 0 2
1977: PPUSH
1978: LD_VAR 0 17
1982: PPUSH
1983: CALL_OW 431
// end ;
1987: GO 1815
1989: POP
1990: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1991: LD_INT 1
1993: PPUSH
1994: LD_INT 1
1996: PPUSH
1997: LD_VAR 0 8
2001: PUSH
2002: LD_INT 1
2004: PLUS
2005: PPUSH
2006: CALL_OW 380
// hc_gallery := potter ;
2010: LD_ADDR_OWVAR 33
2014: PUSH
2015: LD_STRING potter
2017: ST_TO_ADDR
// hc_face_number := 1 ;
2018: LD_ADDR_OWVAR 34
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// hc_importance := 100 ;
2026: LD_ADDR_OWVAR 32
2030: PUSH
2031: LD_INT 100
2033: ST_TO_ADDR
// hc_name := Mike Gerste ;
2034: LD_ADDR_OWVAR 26
2038: PUSH
2039: LD_STRING Mike Gerste
2041: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2042: LD_ADDR_OWVAR 29
2046: PUSH
2047: LD_INT 10
2049: PUSH
2050: LD_INT 11
2052: PUSH
2053: EMPTY
2054: LIST
2055: LIST
2056: ST_TO_ADDR
// legion_commander := CreateHuman ;
2057: LD_ADDR_EXP 1
2061: PUSH
2062: CALL_OW 44
2066: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2067: LD_EXP 1
2071: PPUSH
2072: LD_INT 23
2074: PPUSH
2075: CALL_OW 52
// uc_side := 5 ;
2079: LD_ADDR_OWVAR 20
2083: PUSH
2084: LD_INT 5
2086: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2087: LD_INT 1
2089: PPUSH
2090: LD_INT 4
2092: PPUSH
2093: LD_VAR 0 8
2097: PPUSH
2098: CALL_OW 380
// hc_gallery := potter ;
2102: LD_ADDR_OWVAR 33
2106: PUSH
2107: LD_STRING potter
2109: ST_TO_ADDR
// hc_face_number := 2 ;
2110: LD_ADDR_OWVAR 34
2114: PUSH
2115: LD_INT 2
2117: ST_TO_ADDR
// hc_importance := 0 ;
2118: LD_ADDR_OWVAR 32
2122: PUSH
2123: LD_INT 0
2125: ST_TO_ADDR
// hc_name := George Potter ;
2126: LD_ADDR_OWVAR 26
2130: PUSH
2131: LD_STRING George Potter
2133: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2134: LD_ADDR_OWVAR 29
2138: PUSH
2139: LD_INT 12
2141: PUSH
2142: LD_INT 9
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: ST_TO_ADDR
// potter := CreateHuman ;
2149: LD_ADDR_EXP 4
2153: PUSH
2154: CALL_OW 44
2158: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2159: LD_EXP 4
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2171: LD_EXP 4
2175: PPUSH
2176: LD_INT 103
2178: PPUSH
2179: LD_INT 45
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2189: LD_EXP 4
2193: PPUSH
2194: LD_INT 23
2196: PPUSH
2197: CALL_OW 119
// InitHc ( ) ;
2201: CALL_OW 19
// end ; end_of_file
2205: LD_VAR 0 1
2209: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2210: LD_INT 0
2212: PPUSH
2213: PPUSH
2214: PPUSH
2215: PPUSH
2216: PPUSH
// uc_side := 5 ;
2217: LD_ADDR_OWVAR 20
2221: PUSH
2222: LD_INT 5
2224: ST_TO_ADDR
// uc_nation := nation_arabian ;
2225: LD_ADDR_OWVAR 21
2229: PUSH
2230: LD_INT 2
2232: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2233: LD_ADDR_VAR 0 4
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_OWVAR 20
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 30
2252: PUSH
2253: LD_INT 5
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: PPUSH
2264: CALL_OW 69
2268: ST_TO_ADDR
// for i = 1 to 3 do
2269: LD_ADDR_VAR 0 2
2273: PUSH
2274: DOUBLE
2275: LD_INT 1
2277: DEC
2278: ST_TO_ADDR
2279: LD_INT 3
2281: PUSH
2282: FOR_TO
2283: IFFALSE 2321
// begin PrepareHuman ( false , 2 , 6 ) ;
2285: LD_INT 0
2287: PPUSH
2288: LD_INT 2
2290: PPUSH
2291: LD_INT 6
2293: PPUSH
2294: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2298: CALL_OW 44
2302: PPUSH
2303: LD_INT 27
2305: PPUSH
2306: LD_INT 22
2308: PPUSH
2309: LD_INT 5
2311: PPUSH
2312: LD_INT 0
2314: PPUSH
2315: CALL_OW 50
// end ;
2319: GO 2282
2321: POP
2322: POP
// for i = 1 to 3 do
2323: LD_ADDR_VAR 0 2
2327: PUSH
2328: DOUBLE
2329: LD_INT 1
2331: DEC
2332: ST_TO_ADDR
2333: LD_INT 3
2335: PUSH
2336: FOR_TO
2337: IFFALSE 2372
// begin PrepareHuman ( false , 1 , 6 ) ;
2339: LD_INT 0
2341: PPUSH
2342: LD_INT 1
2344: PPUSH
2345: LD_INT 6
2347: PPUSH
2348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2352: CALL_OW 44
2356: PPUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 1
2364: ARRAY
2365: PPUSH
2366: CALL_OW 52
// end ;
2370: GO 2336
2372: POP
2373: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2374: LD_ADDR_VAR 0 2
2378: PUSH
2379: LD_INT 22
2381: PUSH
2382: LD_OWVAR 20
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: PUSH
2391: LD_INT 2
2393: PUSH
2394: LD_INT 30
2396: PUSH
2397: LD_INT 31
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 30
2406: PUSH
2407: LD_INT 32
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: LIST
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: PPUSH
2423: CALL_OW 69
2427: PUSH
2428: FOR_IN
2429: IFFALSE 2516
// begin PrepareHuman ( false , 1 , 6 ) ;
2431: LD_INT 0
2433: PPUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_INT 6
2439: PPUSH
2440: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2444: CALL_OW 44
2448: PPUSH
2449: LD_VAR 0 2
2453: PPUSH
2454: CALL 5049 0 2
// if GetBType ( i ) = b_bunker then
2458: LD_VAR 0 2
2462: PPUSH
2463: CALL_OW 266
2467: PUSH
2468: LD_INT 32
2470: EQUAL
2471: IFFALSE 2514
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2473: LD_VAR 0 2
2477: PPUSH
2478: LD_INT 27
2480: PUSH
2481: LD_INT 25
2483: PUSH
2484: LD_INT 24
2486: PUSH
2487: LD_INT 28
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PUSH
2496: LD_VAR 0 2
2500: PUSH
2501: LD_INT 4
2503: MOD
2504: PUSH
2505: LD_INT 1
2507: PLUS
2508: ARRAY
2509: PPUSH
2510: CALL_OW 431
// end ;
2514: GO 2428
2516: POP
2517: POP
// for i = 1 to 3 do
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: DOUBLE
2524: LD_INT 1
2526: DEC
2527: ST_TO_ADDR
2528: LD_INT 3
2530: PUSH
2531: FOR_TO
2532: IFFALSE 2649
// begin vc_chassis := ar_half_tracked ;
2534: LD_ADDR_OWVAR 37
2538: PUSH
2539: LD_INT 14
2541: ST_TO_ADDR
// vc_engine := engine_solar ;
2542: LD_ADDR_OWVAR 39
2546: PUSH
2547: LD_INT 2
2549: ST_TO_ADDR
// vc_control := control_manual ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_INT 1
2557: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2558: LD_ADDR_OWVAR 40
2562: PUSH
2563: LD_INT 25
2565: PUSH
2566: LD_INT 27
2568: PUSH
2569: LD_INT 26
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: LIST
2576: PUSH
2577: LD_VAR 0 2
2581: ARRAY
2582: ST_TO_ADDR
// un := CreateVehicle ;
2583: LD_ADDR_VAR 0 3
2587: PUSH
2588: CALL_OW 45
2592: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2593: LD_VAR 0 3
2597: PPUSH
2598: LD_INT 5
2600: PPUSH
2601: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2605: LD_VAR 0 3
2609: PPUSH
2610: LD_INT 8
2612: PPUSH
2613: LD_INT 0
2615: PPUSH
2616: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2620: LD_INT 0
2622: PPUSH
2623: LD_INT 3
2625: PPUSH
2626: LD_INT 7
2628: PPUSH
2629: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2633: CALL_OW 44
2637: PPUSH
2638: LD_VAR 0 3
2642: PPUSH
2643: CALL_OW 52
// end ;
2647: GO 2531
2649: POP
2650: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2651: LD_INT 1
2653: PPUSH
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 6
2659: PPUSH
2660: CALL_OW 380
// al_commander := CreateHuman ;
2664: LD_ADDR_EXP 5
2668: PUSH
2669: CALL_OW 44
2673: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2674: LD_EXP 5
2678: PPUSH
2679: LD_INT 22
2681: PUSH
2682: LD_OWVAR 20
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: PUSH
2691: LD_INT 30
2693: PUSH
2694: LD_INT 0
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PPUSH
2705: CALL_OW 69
2709: PUSH
2710: LD_INT 1
2712: ARRAY
2713: PPUSH
2714: CALL_OW 52
// InitHc ( ) ;
2718: CALL_OW 19
// end ;
2722: LD_VAR 0 1
2726: RET
// export function ChangeSide ( ) ; var i ; begin
2727: LD_INT 0
2729: PPUSH
2730: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2731: LD_ADDR_VAR 0 2
2735: PUSH
2736: LD_INT 22
2738: PUSH
2739: LD_INT 5
2741: PUSH
2742: EMPTY
2743: LIST
2744: LIST
2745: PPUSH
2746: CALL_OW 69
2750: PUSH
2751: FOR_IN
2752: IFFALSE 2768
// SetSide ( i , 8 ) ;
2754: LD_VAR 0 2
2758: PPUSH
2759: LD_INT 8
2761: PPUSH
2762: CALL_OW 235
2766: GO 2751
2768: POP
2769: POP
// end ;
2770: LD_VAR 0 1
2774: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2775: LD_INT 22
2777: PUSH
2778: LD_INT 5
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PPUSH
2785: CALL_OW 69
2789: IFFALSE 3303
2791: GO 2793
2793: DISABLE
2794: LD_INT 0
2796: PPUSH
2797: PPUSH
2798: PPUSH
2799: PPUSH
2800: PPUSH
2801: PPUSH
// begin enable ;
2802: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2803: LD_ADDR_VAR 0 2
2807: PUSH
2808: LD_INT 22
2810: PUSH
2811: LD_INT 5
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 2
2820: PUSH
2821: LD_INT 21
2823: PUSH
2824: LD_INT 1
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: LD_INT 21
2833: PUSH
2834: LD_INT 2
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: EMPTY
2842: LIST
2843: LIST
2844: LIST
2845: PUSH
2846: EMPTY
2847: LIST
2848: LIST
2849: PPUSH
2850: CALL_OW 69
2854: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2855: LD_ADDR_VAR 0 5
2859: PUSH
2860: LD_INT 22
2862: PUSH
2863: LD_INT 5
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: PUSH
2870: LD_INT 30
2872: PUSH
2873: LD_INT 32
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: LD_INT 3
2882: PUSH
2883: LD_INT 24
2885: PUSH
2886: LD_INT 1000
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: EMPTY
2894: LIST
2895: LIST
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: LIST
2901: PPUSH
2902: CALL_OW 69
2906: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2907: LD_ADDR_VAR 0 6
2911: PUSH
2912: LD_VAR 0 2
2916: PPUSH
2917: LD_INT 3
2919: PUSH
2920: LD_INT 54
2922: PUSH
2923: EMPTY
2924: LIST
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PUSH
2930: LD_INT 25
2932: PUSH
2933: LD_INT 3
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: EMPTY
2941: LIST
2942: LIST
2943: PPUSH
2944: CALL_OW 72
2948: ST_TO_ADDR
// if not list then
2949: LD_VAR 0 2
2953: NOT
2954: IFFALSE 2958
// exit ;
2956: GO 3303
// for i in list do
2958: LD_ADDR_VAR 0 1
2962: PUSH
2963: LD_VAR 0 2
2967: PUSH
2968: FOR_IN
2969: IFFALSE 3301
// begin if b then
2971: LD_VAR 0 5
2975: IFFALSE 3054
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2977: LD_ADDR_VAR 0 4
2981: PUSH
2982: LD_VAR 0 2
2986: PPUSH
2987: LD_INT 25
2989: PUSH
2990: LD_INT 2
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: PPUSH
2997: CALL_OW 72
3001: PUSH
3002: FOR_IN
3003: IFFALSE 3052
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
3005: LD_VAR 0 4
3009: PPUSH
3010: CALL_OW 314
3014: NOT
3015: PUSH
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 110
3025: PUSH
3026: LD_INT 7
3028: NONEQUAL
3029: AND
3030: IFFALSE 3050
// ComRepairBuilding ( j , b [ 1 ] ) ;
3032: LD_VAR 0 4
3036: PPUSH
3037: LD_VAR 0 5
3041: PUSH
3042: LD_INT 1
3044: ARRAY
3045: PPUSH
3046: CALL_OW 130
3050: GO 3002
3052: POP
3053: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3054: LD_VAR 0 1
3058: PPUSH
3059: CALL_OW 256
3063: PUSH
3064: LD_INT 500
3066: LESS
3067: PUSH
3068: LD_VAR 0 1
3072: PPUSH
3073: CALL_OW 110
3077: PUSH
3078: LD_INT 7
3080: EQUAL
3081: NOT
3082: AND
3083: IFFALSE 3133
// begin ComMoveToArea ( i , guard_hill ) ;
3085: LD_VAR 0 1
3089: PPUSH
3090: LD_INT 11
3092: PPUSH
3093: CALL_OW 113
// SetTag ( i , 7 ) ;
3097: LD_VAR 0 1
3101: PPUSH
3102: LD_INT 7
3104: PPUSH
3105: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 247
3118: PUSH
3119: LD_INT 2
3121: EQUAL
3122: IFFALSE 3133
// begin AddComExitVehicle ( i ) ;
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3133: LD_VAR 0 1
3137: PPUSH
3138: CALL_OW 256
3142: PUSH
3143: LD_INT 1000
3145: EQUAL
3146: PUSH
3147: LD_VAR 0 1
3151: PPUSH
3152: CALL_OW 110
3156: PUSH
3157: LD_INT 7
3159: EQUAL
3160: AND
3161: PUSH
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 310
3171: NOT
3172: AND
3173: PUSH
3174: LD_VAR 0 6
3178: AND
3179: IFFALSE 3207
// begin SetTag ( i , 0 ) ;
3181: LD_VAR 0 1
3185: PPUSH
3186: LD_INT 0
3188: PPUSH
3189: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3193: LD_VAR 0 6
3197: PPUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3207: LD_VAR 0 1
3211: PPUSH
3212: CALL_OW 247
3216: PUSH
3217: LD_INT 2
3219: EQUAL
3220: PUSH
3221: LD_VAR 0 1
3225: PPUSH
3226: CALL_OW 110
3230: PUSH
3231: LD_INT 7
3233: NONEQUAL
3234: AND
3235: PUSH
3236: LD_VAR 0 1
3240: PPUSH
3241: CALL_OW 314
3245: NOT
3246: AND
3247: IFFALSE 3299
// if FilterAllUnits ( [ f_side , 7 ] ) then
3249: LD_INT 22
3251: PUSH
3252: LD_INT 7
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PPUSH
3259: CALL_OW 69
3263: IFFALSE 3299
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3265: LD_VAR 0 1
3269: PPUSH
3270: LD_INT 22
3272: PUSH
3273: LD_INT 7
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PPUSH
3280: CALL_OW 69
3284: PPUSH
3285: LD_VAR 0 1
3289: PPUSH
3290: CALL_OW 74
3294: PPUSH
3295: CALL_OW 115
// end ;
3299: GO 2968
3301: POP
3302: POP
// end ; end_of_file
3303: PPOPN 6
3305: END
// export function Game ; var i , val , areas , wave ; begin
3306: LD_INT 0
3308: PPUSH
3309: PPUSH
3310: PPUSH
3311: PPUSH
3312: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3313: LD_ADDR_VAR 0 4
3317: PUSH
3318: LD_INT 1
3320: PUSH
3321: LD_INT 2
3323: PUSH
3324: LD_INT 3
3326: PUSH
3327: LD_INT 4
3329: PUSH
3330: LD_INT 5
3332: PUSH
3333: LD_INT 6
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3344: LD_ADDR_VAR 0 3
3348: PUSH
3349: LD_INT 10
3351: PUSH
3352: LD_INT 20
3354: PUSH
3355: LD_INT 30
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_OWVAR 67
3367: ARRAY
3368: ST_TO_ADDR
// wave := 1 ;
3369: LD_ADDR_VAR 0 5
3373: PUSH
3374: LD_INT 1
3376: ST_TO_ADDR
// while ( game_over = false ) do
3377: LD_EXP 7
3381: PUSH
3382: LD_INT 0
3384: EQUAL
3385: IFFALSE 3549
// begin repeat begin Wait ( 0 0$01 ) ;
3387: LD_INT 35
3389: PPUSH
3390: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3394: LD_ADDR_EXP 9
3398: PUSH
3399: LD_EXP 9
3403: PUSH
3404: LD_INT 35
3406: PLUS
3407: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3408: LD_INT 22
3410: PUSH
3411: LD_INT 7
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PPUSH
3418: CALL_OW 69
3422: PUSH
3423: LD_INT 10
3425: LESS
3426: PUSH
3427: LD_EXP 9
3431: PUSH
3432: LD_INT 21000
3434: GREATEREQUAL
3435: OR
3436: IFFALSE 3387
// wave_time := 0 0$00 ;
3438: LD_ADDR_EXP 9
3442: PUSH
3443: LD_INT 0
3445: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3446: LD_INT 5250
3448: PPUSH
3449: CALL_OW 67
// if not ignore_wave then
3453: LD_EXP 13
3457: NOT
3458: IFFALSE 3539
// begin for i = 1 to wave do
3460: LD_ADDR_VAR 0 2
3464: PUSH
3465: DOUBLE
3466: LD_INT 1
3468: DEC
3469: ST_TO_ADDR
3470: LD_VAR 0 5
3474: PUSH
3475: FOR_TO
3476: IFFALSE 3521
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3478: LD_VAR 0 3
3482: PUSH
3483: LD_VAR 0 2
3487: MUL
3488: PPUSH
3489: LD_VAR 0 4
3493: PUSH
3494: LD_VAR 0 2
3498: PUSH
3499: LD_INT 6
3501: MOD
3502: PUSH
3503: LD_INT 1
3505: PLUS
3506: ARRAY
3507: PPUSH
3508: CALL 3554 0 2
// Wait ( 0 0$10 ) ;
3512: LD_INT 350
3514: PPUSH
3515: CALL_OW 67
// end ;
3519: GO 3475
3521: POP
3522: POP
// wave := wave + 1 ;
3523: LD_ADDR_VAR 0 5
3527: PUSH
3528: LD_VAR 0 5
3532: PUSH
3533: LD_INT 1
3535: PLUS
3536: ST_TO_ADDR
// end else
3537: GO 3547
// ignore_wave := false ;
3539: LD_ADDR_EXP 13
3543: PUSH
3544: LD_INT 0
3546: ST_TO_ADDR
// end ;
3547: GO 3377
// end ;
3549: LD_VAR 0 1
3553: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3554: LD_INT 0
3556: PPUSH
3557: PPUSH
3558: PPUSH
3559: PPUSH
// uc_side := 7 ;
3560: LD_ADDR_OWVAR 20
3564: PUSH
3565: LD_INT 7
3567: ST_TO_ADDR
// uc_nation := 2 ;
3568: LD_ADDR_OWVAR 21
3572: PUSH
3573: LD_INT 2
3575: ST_TO_ADDR
// InitHc ( ) ;
3576: CALL_OW 19
// hc_gallery :=  ;
3580: LD_ADDR_OWVAR 33
3584: PUSH
3585: LD_STRING 
3587: ST_TO_ADDR
// hc_importance := 0 ;
3588: LD_ADDR_OWVAR 32
3592: PUSH
3593: LD_INT 0
3595: ST_TO_ADDR
// hc_name :=  ;
3596: LD_ADDR_OWVAR 26
3600: PUSH
3601: LD_STRING 
3603: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3604: LD_ADDR_OWVAR 29
3608: PUSH
3609: LD_INT 10
3611: PUSH
3612: LD_OWVAR 1
3616: PUSH
3617: LD_INT 21000
3619: DIV
3620: PLUS
3621: PUSH
3622: LD_INT 10
3624: PUSH
3625: LD_OWVAR 1
3629: PUSH
3630: LD_INT 21000
3632: DIV
3633: PLUS
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: ST_TO_ADDR
// for i = 1 to val do
3639: LD_ADDR_VAR 0 4
3643: PUSH
3644: DOUBLE
3645: LD_INT 1
3647: DEC
3648: ST_TO_ADDR
3649: LD_VAR 0 1
3653: PUSH
3654: FOR_TO
3655: IFFALSE 3862
// begin if i mod 9 = 0 then
3657: LD_VAR 0 4
3661: PUSH
3662: LD_INT 9
3664: MOD
3665: PUSH
3666: LD_INT 0
3668: EQUAL
3669: IFFALSE 3681
// class := class_apeman_kamikaze else
3671: LD_ADDR_VAR 0 6
3675: PUSH
3676: LD_INT 17
3678: ST_TO_ADDR
3679: GO 3713
// if i mod 4 = 0 then
3681: LD_VAR 0 4
3685: PUSH
3686: LD_INT 4
3688: MOD
3689: PUSH
3690: LD_INT 0
3692: EQUAL
3693: IFFALSE 3705
// class := class_apeman_soldier else
3695: LD_ADDR_VAR 0 6
3699: PUSH
3700: LD_INT 15
3702: ST_TO_ADDR
3703: GO 3713
// class := class_apeman ;
3705: LD_ADDR_VAR 0 6
3709: PUSH
3710: LD_INT 12
3712: ST_TO_ADDR
// if i mod 33 = 0 then
3713: LD_VAR 0 4
3717: PUSH
3718: LD_INT 33
3720: MOD
3721: PUSH
3722: LD_INT 0
3724: EQUAL
3725: IFFALSE 3794
// begin vc_chassis := ar_half_tracked ;
3727: LD_ADDR_OWVAR 37
3731: PUSH
3732: LD_INT 14
3734: ST_TO_ADDR
// vc_control := control_apeman ;
3735: LD_ADDR_OWVAR 38
3739: PUSH
3740: LD_INT 5
3742: ST_TO_ADDR
// vc_engine := engine_combustion ;
3743: LD_ADDR_OWVAR 39
3747: PUSH
3748: LD_INT 1
3750: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3751: LD_ADDR_OWVAR 40
3755: PUSH
3756: LD_INT 28
3758: PUSH
3759: LD_INT 27
3761: PUSH
3762: LD_INT 29
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 1
3772: PPUSH
3773: LD_INT 2
3775: PPUSH
3776: CALL_OW 12
3780: ARRAY
3781: ST_TO_ADDR
// un := CreateVehicle ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: CALL_OW 45
3791: ST_TO_ADDR
// end else
3792: GO 3819
// begin PrepareHuman ( sex_male , class , 10 ) ;
3794: LD_INT 1
3796: PPUSH
3797: LD_VAR 0 6
3801: PPUSH
3802: LD_INT 10
3804: PPUSH
3805: CALL_OW 380
// un := CreateHuman ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: CALL_OW 44
3818: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3819: LD_VAR 0 5
3823: PPUSH
3824: LD_VAR 0 2
3828: PPUSH
3829: LD_INT 0
3831: PPUSH
3832: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3836: LD_VAR 0 5
3840: PPUSH
3841: CALL_OW 250
3845: PPUSH
3846: LD_VAR 0 5
3850: PPUSH
3851: CALL_OW 251
3855: PPUSH
3856: CALL_OW 494
// end ;
3860: GO 3654
3862: POP
3863: POP
// end ;
3864: LD_VAR 0 3
3868: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3869: LD_EXP 6
3873: PUSH
3874: LD_EXP 7
3878: NOT
3879: AND
3880: IFFALSE 4166
3882: GO 3884
3884: DISABLE
3885: LD_INT 0
3887: PPUSH
3888: PPUSH
3889: PPUSH
// begin enable ;
3890: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: LD_INT 22
3898: PUSH
3899: LD_INT 7
3901: PUSH
3902: EMPTY
3903: LIST
3904: LIST
3905: PPUSH
3906: CALL_OW 69
3910: ST_TO_ADDR
// if not list then
3911: LD_VAR 0 2
3915: NOT
3916: IFFALSE 3920
// exit ;
3918: GO 4166
// for i in list do
3920: LD_ADDR_VAR 0 1
3924: PUSH
3925: LD_VAR 0 2
3929: PUSH
3930: FOR_IN
3931: IFFALSE 4164
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3933: LD_ADDR_VAR 0 3
3937: PUSH
3938: LD_INT 81
3940: PUSH
3941: LD_INT 7
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: PUSH
3948: LD_INT 92
3950: PUSH
3951: LD_VAR 0 1
3955: PPUSH
3956: CALL_OW 250
3960: PUSH
3961: LD_VAR 0 1
3965: PPUSH
3966: CALL_OW 251
3970: PUSH
3971: LD_INT 15
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: PUSH
3980: EMPTY
3981: LIST
3982: LIST
3983: PPUSH
3984: CALL_OW 69
3988: ST_TO_ADDR
// if not enemy then
3989: LD_VAR 0 3
3993: NOT
3994: IFFALSE 4052
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3996: LD_ADDR_VAR 0 3
4000: PUSH
4001: LD_INT 81
4003: PUSH
4004: LD_INT 7
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: PUSH
4011: LD_INT 92
4013: PUSH
4014: LD_VAR 0 1
4018: PPUSH
4019: CALL_OW 250
4023: PUSH
4024: LD_VAR 0 1
4028: PPUSH
4029: CALL_OW 251
4033: PUSH
4034: LD_INT 30
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: LIST
4041: LIST
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: PPUSH
4047: CALL_OW 69
4051: ST_TO_ADDR
// if not enemy then
4052: LD_VAR 0 3
4056: NOT
4057: IFFALSE 4115
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4059: LD_ADDR_VAR 0 3
4063: PUSH
4064: LD_INT 81
4066: PUSH
4067: LD_INT 7
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PUSH
4074: LD_INT 92
4076: PUSH
4077: LD_VAR 0 1
4081: PPUSH
4082: CALL_OW 250
4086: PUSH
4087: LD_VAR 0 1
4091: PPUSH
4092: CALL_OW 251
4096: PUSH
4097: LD_INT 50
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PPUSH
4110: CALL_OW 69
4114: ST_TO_ADDR
// if not enemy then
4115: LD_VAR 0 3
4119: NOT
4120: IFFALSE 4142
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4122: LD_ADDR_VAR 0 3
4126: PUSH
4127: LD_INT 81
4129: PUSH
4130: LD_INT 7
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PPUSH
4137: CALL_OW 69
4141: ST_TO_ADDR
// if enemy then
4142: LD_VAR 0 3
4146: IFFALSE 4162
// Attack ( i , enemy ) ;
4148: LD_VAR 0 1
4152: PPUSH
4153: LD_VAR 0 3
4157: PPUSH
4158: CALL 4169 0 2
// end ;
4162: GO 3930
4164: POP
4165: POP
// end ;
4166: PPOPN 3
4168: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4169: LD_INT 0
4171: PPUSH
4172: PPUSH
4173: PPUSH
// if not unit then
4174: LD_VAR 0 1
4178: NOT
4179: IFFALSE 4183
// exit ;
4181: GO 4347
// targets_list := [ ] ;
4183: LD_ADDR_VAR 0 5
4187: PUSH
4188: EMPTY
4189: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4190: LD_ADDR_VAR 0 5
4194: PUSH
4195: LD_VAR 0 2
4199: PPUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 54
4215: PUSH
4216: EMPTY
4217: LIST
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PPUSH
4227: CALL_OW 72
4231: PUSH
4232: LD_VAR 0 2
4236: PPUSH
4237: LD_INT 21
4239: PUSH
4240: LD_INT 2
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PPUSH
4247: CALL_OW 72
4251: PUSH
4252: LD_VAR 0 2
4256: PPUSH
4257: LD_INT 21
4259: PUSH
4260: LD_INT 3
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: LD_INT 58
4272: PUSH
4273: EMPTY
4274: LIST
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PPUSH
4284: CALL_OW 72
4288: PUSH
4289: LD_VAR 0 2
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: LIST
4298: LIST
4299: ST_TO_ADDR
// for target in targets_list do
4300: LD_ADDR_VAR 0 4
4304: PUSH
4305: LD_VAR 0 5
4309: PUSH
4310: FOR_IN
4311: IFFALSE 4345
// begin if target then
4313: LD_VAR 0 4
4317: IFFALSE 4343
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4319: LD_VAR 0 1
4323: PPUSH
4324: LD_VAR 0 4
4328: PPUSH
4329: LD_VAR 0 1
4333: PPUSH
4334: CALL_OW 74
4338: PPUSH
4339: CALL_OW 115
// end ;
4343: GO 4310
4345: POP
4346: POP
// end ; end_of_file
4347: LD_VAR 0 3
4351: RET
// export function Action ; begin
4352: LD_INT 0
4354: PPUSH
// InGameOn ;
4355: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4359: LD_INT 23
4361: PPUSH
4362: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4366: LD_EXP 1
4370: PPUSH
4371: LD_STRING DL-1
4373: PPUSH
4374: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4378: LD_EXP 2
4382: PPUSH
4383: LD_STRING DA-1
4385: PPUSH
4386: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4390: LD_EXP 3
4394: PPUSH
4395: LD_STRING DA-2
4397: PPUSH
4398: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4402: LD_EXP 1
4406: PPUSH
4407: LD_STRING DL-2
4409: PPUSH
4410: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4414: LD_EXP 3
4418: PPUSH
4419: LD_STRING DA-3
4421: PPUSH
4422: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4426: LD_EXP 1
4430: PPUSH
4431: LD_STRING DL-3
4433: PPUSH
4434: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4438: LD_EXP 2
4442: PPUSH
4443: LD_STRING DA-4
4445: PPUSH
4446: CALL_OW 88
// if not dialogue_skipped then
4450: LD_OWVAR 59
4454: NOT
4455: IFFALSE 4540
// begin Wait ( 0 0$01 ) ;
4457: LD_INT 35
4459: PPUSH
4460: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4464: LD_EXP 2
4468: PUSH
4469: LD_EXP 3
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PPUSH
4478: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4482: LD_EXP 2
4486: PPUSH
4487: LD_INT 107
4489: PPUSH
4490: LD_INT 53
4492: PPUSH
4493: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4497: LD_EXP 3
4501: PPUSH
4502: LD_INT 108
4504: PPUSH
4505: LD_INT 53
4507: PPUSH
4508: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4512: LD_EXP 2
4516: PPUSH
4517: LD_EXP 4
4521: PPUSH
4522: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4526: LD_EXP 3
4530: PPUSH
4531: LD_EXP 4
4535: PPUSH
4536: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4540: LD_INT 35
4542: PPUSH
4543: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4547: LD_EXP 2
4551: PPUSH
4552: LD_INT 107
4554: PPUSH
4555: LD_INT 53
4557: PPUSH
4558: CALL_OW 307
4562: PUSH
4563: LD_OWVAR 59
4567: OR
4568: IFFALSE 4540
// if not dialogue_skipped then
4570: LD_OWVAR 59
4574: NOT
4575: IFFALSE 4676
// begin ComTurnUnit ( potter , l1 ) ;
4577: LD_EXP 4
4581: PPUSH
4582: LD_EXP 2
4586: PPUSH
4587: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4591: LD_INT 10
4593: PPUSH
4594: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4598: LD_EXP 4
4602: PPUSH
4603: LD_INT 108
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: LD_INT 0
4614: PPUSH
4615: CALL_OW 483
// Wait ( 0 0$01 ) ;
4619: LD_INT 35
4621: PPUSH
4622: CALL_OW 67
// RemoveUnit ( potter ) ;
4626: LD_EXP 4
4630: PPUSH
4631: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4635: LD_EXP 2
4639: PPUSH
4640: LD_STRING DA-5
4642: PPUSH
4643: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4647: LD_EXP 3
4651: PPUSH
4652: LD_STRING DA-6
4654: PPUSH
4655: CALL_OW 88
// Wait ( 0 0$02 ) ;
4659: LD_INT 70
4661: PPUSH
4662: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4666: LD_INT 25
4668: PPUSH
4669: LD_INT 19
4671: PPUSH
4672: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4676: LD_INT 30
4678: PPUSH
4679: LD_INT 1
4681: PPUSH
4682: CALL 3554 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4686: LD_EXP 5
4690: PPUSH
4691: LD_STRING DLa-1
4693: PPUSH
4694: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4698: LD_EXP 1
4702: PPUSH
4703: LD_STRING DL-5
4705: PPUSH
4706: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4710: LD_INT 23
4712: PPUSH
4713: CALL_OW 87
// InGameOff ;
4717: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4721: LD_STRING C1
4723: PPUSH
4724: CALL_OW 337
// alert := true ;
4728: LD_ADDR_EXP 6
4732: PUSH
4733: LD_INT 1
4735: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4736: LD_EXP 5
4740: PPUSH
4741: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4745: LD_EXP 5
4749: PPUSH
4750: LD_INT 11
4752: PPUSH
4753: CALL_OW 173
// Wait ( 0 0$30 ) ;
4757: LD_INT 1050
4759: PPUSH
4760: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4764: LD_INT 20
4766: PPUSH
4767: LD_INT 4
4769: PPUSH
4770: CALL 3554 0 2
// Wait ( 0 0$35 ) ;
4774: LD_INT 1225
4776: PPUSH
4777: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4781: LD_INT 20
4783: PPUSH
4784: LD_INT 5
4786: PPUSH
4787: CALL 3554 0 2
// Wait ( 0 0$03 ) ;
4791: LD_INT 105
4793: PPUSH
4794: CALL_OW 67
// Game ;
4798: CALL 3306 0 0
// end ;
4802: LD_VAR 0 1
4806: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4807: LD_INT 22
4809: PUSH
4810: LD_INT 7
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: PPUSH
4817: CALL_OW 69
4821: PUSH
4822: LD_INT 0
4824: EQUAL
4825: PUSH
4826: LD_EXP 8
4830: PUSH
4831: LD_INT 500
4833: GREATEREQUAL
4834: AND
4835: IFFALSE 5046
4837: GO 4839
4839: DISABLE
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
// begin DialogueOn ;
4844: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4848: LD_EXP 10
4852: PPUSH
4853: LD_STRING DVr-1
4855: PPUSH
4856: CALL_OW 94
// DialogueOff ;
4860: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4864: LD_STRING QBonusInfo
4866: PPUSH
4867: CALL_OW 97
4871: PUSH
4872: LD_INT 1
4874: DOUBLE
4875: EQUAL
4876: IFTRUE 4880
4878: GO 4891
4880: POP
// bonus_active := true ; end ;
4881: LD_ADDR_EXP 11
4885: PUSH
4886: LD_INT 1
4888: ST_TO_ADDR
4889: GO 4892
4891: POP
// bonus_num := 4 ;
4892: LD_ADDR_EXP 12
4896: PUSH
4897: LD_INT 4
4899: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4900: LD_OWVAR 2
4904: PPUSH
4905: LD_INT 2
4907: PPUSH
4908: LD_INT 2
4910: PPUSH
4911: LD_INT 23
4913: PPUSH
4914: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4918: LD_ADDR_VAR 0 1
4922: PUSH
4923: LD_INT 500
4925: PUSH
4926: LD_INT 3500
4928: PUSH
4929: LD_INT 5750
4931: PUSH
4932: LD_INT 10000
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: LIST
4940: ST_TO_ADDR
// repeat wait ( 5 5$00 ) ;
4941: LD_INT 10500
4943: PPUSH
4944: CALL_OW 67
// for i = 1 to tmp do
4948: LD_ADDR_VAR 0 2
4952: PUSH
4953: DOUBLE
4954: LD_INT 1
4956: DEC
4957: ST_TO_ADDR
4958: LD_VAR 0 1
4962: PUSH
4963: FOR_TO
4964: IFFALSE 4996
// if points >= tmp [ i ] then
4966: LD_EXP 8
4970: PUSH
4971: LD_VAR 0 1
4975: PUSH
4976: LD_VAR 0 2
4980: ARRAY
4981: GREATEREQUAL
4982: IFFALSE 4994
// bonus_num := i ;
4984: LD_ADDR_EXP 12
4988: PUSH
4989: LD_VAR 0 2
4993: ST_TO_ADDR
4994: GO 4963
4996: POP
4997: POP
// case Query ( QBonusInfo ) of 1 :
4998: LD_STRING QBonusInfo
5000: PPUSH
5001: CALL_OW 97
5005: PUSH
5006: LD_INT 1
5008: DOUBLE
5009: EQUAL
5010: IFTRUE 5014
5012: GO 5035
5014: POP
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ; end ;
5015: LD_OWVAR 2
5019: PPUSH
5020: LD_INT 2
5022: PPUSH
5023: LD_INT 2
5025: PPUSH
5026: LD_INT 23
5028: PPUSH
5029: CALL_OW 468
5033: GO 5036
5035: POP
// until points >= 15000 ;
5036: LD_EXP 8
5040: PUSH
5041: LD_INT 15000
5043: GREATEREQUAL
5044: IFFALSE 4941
// end ; end_of_file
5046: PPOPN 2
5048: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
// dir := GetDir ( b ) ;
5053: LD_ADDR_VAR 0 4
5057: PUSH
5058: LD_VAR 0 2
5062: PPUSH
5063: CALL_OW 254
5067: ST_TO_ADDR
// if dir < 3 then
5068: LD_VAR 0 4
5072: PUSH
5073: LD_INT 3
5075: LESS
5076: IFFALSE 5094
// dir := dir + 3 else
5078: LD_ADDR_VAR 0 4
5082: PUSH
5083: LD_VAR 0 4
5087: PUSH
5088: LD_INT 3
5090: PLUS
5091: ST_TO_ADDR
5092: GO 5108
// dir := dir - 3 ;
5094: LD_ADDR_VAR 0 4
5098: PUSH
5099: LD_VAR 0 4
5103: PUSH
5104: LD_INT 3
5106: MINUS
5107: ST_TO_ADDR
// SetDir ( un , dir ) ;
5108: LD_VAR 0 1
5112: PPUSH
5113: LD_VAR 0 4
5117: PPUSH
5118: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5122: LD_VAR 0 1
5126: PPUSH
5127: LD_VAR 0 2
5131: PPUSH
5132: CALL_OW 52
// end ;
5136: LD_VAR 0 3
5140: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5141: LD_INT 0
5143: PPUSH
5144: PPUSH
5145: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5146: LD_ADDR_VAR 0 7
5150: PUSH
5151: LD_VAR 0 1
5155: PUSH
5156: LD_VAR 0 2
5160: ARRAY
5161: PPUSH
5162: LD_VAR 0 3
5166: PPUSH
5167: LD_VAR 0 4
5171: PPUSH
5172: CALL_OW 1
5176: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5177: LD_ADDR_VAR 0 1
5181: PUSH
5182: LD_VAR 0 1
5186: PPUSH
5187: LD_VAR 0 2
5191: PPUSH
5192: LD_VAR 0 7
5196: PPUSH
5197: CALL_OW 1
5201: ST_TO_ADDR
// result := tab ;
5202: LD_ADDR_VAR 0 5
5206: PUSH
5207: LD_VAR 0 1
5211: ST_TO_ADDR
// end ;
5212: LD_VAR 0 5
5216: RET
// export function IsDriver ( unit ) ; begin
5217: LD_INT 0
5219: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5220: LD_VAR 0 1
5224: PUSH
5225: LD_INT 55
5227: PUSH
5228: EMPTY
5229: LIST
5230: PPUSH
5231: CALL_OW 69
5235: IN
5236: IFFALSE 5255
// result := IsInUnit ( unit ) else
5238: LD_ADDR_VAR 0 2
5242: PUSH
5243: LD_VAR 0 1
5247: PPUSH
5248: CALL_OW 310
5252: ST_TO_ADDR
5253: GO 5263
// result := false ;
5255: LD_ADDR_VAR 0 2
5259: PUSH
5260: LD_INT 0
5262: ST_TO_ADDR
// end ;
5263: LD_VAR 0 2
5267: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5268: LD_INT 0
5270: PPUSH
5271: PPUSH
5272: PPUSH
// if not GetControl ( veh ) = control_manual then
5273: LD_VAR 0 1
5277: PPUSH
5278: CALL_OW 263
5282: PUSH
5283: LD_INT 1
5285: EQUAL
5286: NOT
5287: IFFALSE 5299
// result := false else
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: LD_INT 0
5296: ST_TO_ADDR
5297: GO 5444
// if veh in FilterAllUnits ( [ f_empty ] ) then
5299: LD_VAR 0 1
5303: PUSH
5304: LD_INT 58
5306: PUSH
5307: EMPTY
5308: LIST
5309: PPUSH
5310: CALL_OW 69
5314: IN
5315: IFFALSE 5327
// result := false else
5317: LD_ADDR_VAR 0 2
5321: PUSH
5322: LD_INT 0
5324: ST_TO_ADDR
5325: GO 5444
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5327: LD_ADDR_VAR 0 4
5331: PUSH
5332: LD_INT 22
5334: PUSH
5335: LD_VAR 0 1
5339: PPUSH
5340: CALL_OW 255
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 55
5351: PUSH
5352: EMPTY
5353: LIST
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PPUSH
5359: CALL_OW 69
5363: ST_TO_ADDR
// if not filter then
5364: LD_VAR 0 4
5368: NOT
5369: IFFALSE 5381
// result := false else
5371: LD_ADDR_VAR 0 2
5375: PUSH
5376: LD_INT 0
5378: ST_TO_ADDR
5379: GO 5444
// for i = 1 to filter do
5381: LD_ADDR_VAR 0 3
5385: PUSH
5386: DOUBLE
5387: LD_INT 1
5389: DEC
5390: ST_TO_ADDR
5391: LD_VAR 0 4
5395: PUSH
5396: FOR_TO
5397: IFFALSE 5442
// if IsDriver ( filter [ i ] ) = veh then
5399: LD_VAR 0 4
5403: PUSH
5404: LD_VAR 0 3
5408: ARRAY
5409: PPUSH
5410: CALL 5217 0 1
5414: PUSH
5415: LD_VAR 0 1
5419: EQUAL
5420: IFFALSE 5440
// begin result := filter [ i ] ;
5422: LD_ADDR_VAR 0 2
5426: PUSH
5427: LD_VAR 0 4
5431: PUSH
5432: LD_VAR 0 3
5436: ARRAY
5437: ST_TO_ADDR
// break ;
5438: GO 5442
// end ;
5440: GO 5396
5442: POP
5443: POP
// end ; end ; end_of_file
5444: LD_VAR 0 2
5448: RET
// on UnitDestroyed ( un ) do begin if un in [ legion_commander , main_base ] then
5449: LD_VAR 0 1
5453: PUSH
5454: LD_EXP 1
5458: PUSH
5459: LD_INT 23
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: IN
5466: IFFALSE 5476
// game_over := true ;
5468: LD_ADDR_EXP 7
5472: PUSH
5473: LD_INT 1
5475: ST_TO_ADDR
// if un = al_commander then
5476: LD_VAR 0 1
5480: PUSH
5481: LD_EXP 5
5485: EQUAL
5486: IFFALSE 5492
// ChangeSide ( ) ;
5488: CALL 2727 0 0
// if GetSide ( un ) = 7 then
5492: LD_VAR 0 1
5496: PPUSH
5497: CALL_OW 255
5501: PUSH
5502: LD_INT 7
5504: EQUAL
5505: IFFALSE 5623
// begin if GetClass ( un ) = class_apeman then
5507: LD_VAR 0 1
5511: PPUSH
5512: CALL_OW 257
5516: PUSH
5517: LD_INT 12
5519: EQUAL
5520: IFFALSE 5536
// points := points + 6 ;
5522: LD_ADDR_EXP 8
5526: PUSH
5527: LD_EXP 8
5531: PUSH
5532: LD_INT 6
5534: PLUS
5535: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5536: LD_VAR 0 1
5540: PPUSH
5541: CALL_OW 257
5545: PUSH
5546: LD_INT 17
5548: EQUAL
5549: IFFALSE 5565
// points := points + 11 ;
5551: LD_ADDR_EXP 8
5555: PUSH
5556: LD_EXP 8
5560: PUSH
5561: LD_INT 11
5563: PLUS
5564: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5565: LD_VAR 0 1
5569: PPUSH
5570: CALL_OW 257
5574: PUSH
5575: LD_INT 15
5577: EQUAL
5578: IFFALSE 5594
// points := points + 14 ;
5580: LD_ADDR_EXP 8
5584: PUSH
5585: LD_EXP 8
5589: PUSH
5590: LD_INT 14
5592: PLUS
5593: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5594: LD_VAR 0 1
5598: PPUSH
5599: CALL_OW 247
5603: PUSH
5604: LD_INT 2
5606: EQUAL
5607: IFFALSE 5623
// points := points + 50 ;
5609: LD_ADDR_EXP 8
5613: PUSH
5614: LD_EXP 8
5618: PUSH
5619: LD_INT 50
5621: PLUS
5622: ST_TO_ADDR
// end ; end ;
5623: PPOPN 1
5625: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5626: LD_EXP 5
5630: PPUSH
5631: CALL_OW 256
5635: PUSH
5636: LD_INT 1000
5638: LESS
5639: IFFALSE 5671
5641: GO 5643
5643: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5644: LD_EXP 5
5648: PPUSH
5649: CALL_OW 504
5653: PPUSH
5654: CALL_OW 255
5658: PUSH
5659: LD_INT 8
5661: EQUAL
5662: IFFALSE 5671
// YouLost (  ) ;
5664: LD_STRING 
5666: PPUSH
5667: CALL_OW 104
5671: END
// on EnterBuilding ( b , un ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] and GetClass ( un ) in [ class_apeman , class_apeman_soldier , class_apeman_kamikaze ] then
5672: LD_VAR 0 1
5676: PPUSH
5677: CALL_OW 266
5681: PUSH
5682: LD_INT 0
5684: PUSH
5685: LD_INT 1
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: IN
5692: PUSH
5693: LD_VAR 0 2
5697: PPUSH
5698: CALL_OW 257
5702: PUSH
5703: LD_INT 12
5705: PUSH
5706: LD_INT 15
5708: PUSH
5709: LD_INT 17
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: IN
5717: AND
5718: IFFALSE 5739
// begin wait ( 0 0$0.3 ) ;
5720: LD_INT 10
5722: PPUSH
5723: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
5727: LD_VAR 0 2
5731: PPUSH
5732: LD_INT 16
5734: PPUSH
5735: CALL_OW 336
// end ; end ;
5739: PPOPN 2
5741: END
// on DialogueSkipped ( value ) do var i ;
5742: LD_INT 0
5744: PPUSH
// begin RemoveUnit ( potter ) ;
5745: LD_EXP 4
5749: PPUSH
5750: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5754: LD_EXP 2
5758: PUSH
5759: LD_EXP 3
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PPUSH
5768: CALL_OW 122
// Wait ( 1 ) ;
5772: LD_INT 1
5774: PPUSH
5775: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5779: LD_EXP 2
5783: PPUSH
5784: LD_INT 107
5786: PPUSH
5787: LD_INT 53
5789: PPUSH
5790: LD_INT 0
5792: PPUSH
5793: LD_INT 0
5795: PPUSH
5796: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5800: LD_EXP 3
5804: PPUSH
5805: LD_INT 108
5807: PPUSH
5808: LD_INT 53
5810: PPUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 0
5816: PPUSH
5817: CALL_OW 483
// Wait ( 1 ) ;
5821: LD_INT 1
5823: PPUSH
5824: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5828: LD_EXP 2
5832: PUSH
5833: LD_EXP 3
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: PPUSH
5842: LD_INT 108
5844: PPUSH
5845: LD_INT 1
5847: PPUSH
5848: CALL_OW 118
// end ;
5852: PPOPN 2
5854: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5855: LD_INT 0
5857: PPUSH
5858: PPUSH
5859: PPUSH
5860: PPUSH
5861: PPUSH
5862: PPUSH
// begin uc_side := 8 ;
5863: LD_ADDR_OWVAR 20
5867: PUSH
5868: LD_INT 8
5870: ST_TO_ADDR
// uc_nation := 2 ;
5871: LD_ADDR_OWVAR 21
5875: PUSH
5876: LD_INT 2
5878: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5879: LD_ADDR_VAR 0 5
5883: PUSH
5884: LD_STRING QBonus
5886: PUSH
5887: LD_EXP 12
5891: STR
5892: ST_TO_ADDR
// off := true ;
5893: LD_ADDR_VAR 0 6
5897: PUSH
5898: LD_INT 1
5900: ST_TO_ADDR
// units := [ ] ;
5901: LD_ADDR_VAR 0 7
5905: PUSH
5906: EMPTY
5907: ST_TO_ADDR
// crates := 0 ;
5908: LD_ADDR_VAR 0 8
5912: PUSH
5913: LD_INT 0
5915: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5916: LD_EXP 10
5920: PPUSH
5921: LD_STRING DVr-2
5923: PPUSH
5924: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5928: LD_INT 10
5930: PPUSH
5931: CALL_OW 67
// case Query ( bonus ) of 1 :
5935: LD_VAR 0 5
5939: PPUSH
5940: CALL_OW 97
5944: PUSH
5945: LD_INT 1
5947: DOUBLE
5948: EQUAL
5949: IFTRUE 5953
5951: GO 6038
5953: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5954: LD_ADDR_VAR 0 9
5958: PUSH
5959: LD_INT 1
5961: PUSH
5962: LD_INT 2
5964: PUSH
5965: LD_INT 5
5967: PUSH
5968: LD_INT 8
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_EXP 12
5981: ARRAY
5982: ST_TO_ADDR
// for i = 1 to tmp do
5983: LD_ADDR_VAR 0 10
5987: PUSH
5988: DOUBLE
5989: LD_INT 1
5991: DEC
5992: ST_TO_ADDR
5993: LD_VAR 0 9
5997: PUSH
5998: FOR_TO
5999: IFFALSE 6034
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
6001: LD_INT 0
6003: PPUSH
6004: LD_INT 15
6006: PPUSH
6007: LD_VAR 0 9
6011: PPUSH
6012: CALL_OW 380
// units := units ^ CreateHuman ;
6016: LD_ADDR_VAR 0 7
6020: PUSH
6021: LD_VAR 0 7
6025: PUSH
6026: CALL_OW 44
6030: ADD
6031: ST_TO_ADDR
// end ;
6032: GO 5998
6034: POP
6035: POP
// end ; 2 :
6036: GO 6446
6038: LD_INT 2
6040: DOUBLE
6041: EQUAL
6042: IFTRUE 6046
6044: GO 6078
6046: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
6047: LD_ADDR_VAR 0 8
6051: PUSH
6052: LD_INT 100
6054: PUSH
6055: LD_INT 150
6057: PUSH
6058: LD_INT 350
6060: PUSH
6061: LD_INT 500
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: LIST
6068: LIST
6069: PUSH
6070: LD_EXP 12
6074: ARRAY
6075: ST_TO_ADDR
// end ; 3 :
6076: GO 6446
6078: LD_INT 3
6080: DOUBLE
6081: EQUAL
6082: IFTRUE 6086
6084: GO 6426
6086: POP
// begin if bonus_num = 1 then
6087: LD_EXP 12
6091: PUSH
6092: LD_INT 1
6094: EQUAL
6095: IFFALSE 6105
// ignore_wave := true ;
6097: LD_ADDR_EXP 13
6101: PUSH
6102: LD_INT 1
6104: ST_TO_ADDR
// if bonus_num = 2 then
6105: LD_EXP 12
6109: PUSH
6110: LD_INT 2
6112: EQUAL
6113: IFFALSE 6233
// begin for i = 1 to 2 do
6115: LD_ADDR_VAR 0 10
6119: PUSH
6120: DOUBLE
6121: LD_INT 1
6123: DEC
6124: ST_TO_ADDR
6125: LD_INT 2
6127: PUSH
6128: FOR_TO
6129: IFFALSE 6231
// begin uc_nation := nation_arabian ;
6131: LD_ADDR_OWVAR 21
6135: PUSH
6136: LD_INT 2
6138: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6139: LD_ADDR_OWVAR 37
6143: PUSH
6144: LD_INT 14
6146: ST_TO_ADDR
// vc_engine := engine_siberite ;
6147: LD_ADDR_OWVAR 39
6151: PUSH
6152: LD_INT 3
6154: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6155: LD_ADDR_OWVAR 38
6159: PUSH
6160: LD_INT 2
6162: PUSH
6163: LD_INT 5
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 1
6172: PPUSH
6173: LD_INT 2
6175: PPUSH
6176: CALL_OW 12
6180: ARRAY
6181: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6182: LD_ADDR_OWVAR 40
6186: PUSH
6187: LD_INT 28
6189: PUSH
6190: LD_INT 27
6192: PUSH
6193: LD_INT 25
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: PUSH
6201: LD_INT 1
6203: PPUSH
6204: LD_INT 3
6206: PPUSH
6207: CALL_OW 12
6211: ARRAY
6212: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6213: LD_ADDR_VAR 0 7
6217: PUSH
6218: LD_VAR 0 7
6222: PUSH
6223: CALL_OW 45
6227: ADD
6228: ST_TO_ADDR
// end ;
6229: GO 6128
6231: POP
6232: POP
// end ; if bonus_num = 3 then
6233: LD_EXP 12
6237: PUSH
6238: LD_INT 3
6240: EQUAL
6241: IFFALSE 6365
// begin for i = 1 to 4 do
6243: LD_ADDR_VAR 0 10
6247: PUSH
6248: DOUBLE
6249: LD_INT 1
6251: DEC
6252: ST_TO_ADDR
6253: LD_INT 4
6255: PUSH
6256: FOR_TO
6257: IFFALSE 6363
// begin uc_nation := nation_arabian ;
6259: LD_ADDR_OWVAR 21
6263: PUSH
6264: LD_INT 2
6266: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6267: LD_ADDR_OWVAR 37
6271: PUSH
6272: LD_INT 14
6274: ST_TO_ADDR
// vc_engine := engine_siberite ;
6275: LD_ADDR_OWVAR 39
6279: PUSH
6280: LD_INT 3
6282: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6283: LD_ADDR_OWVAR 38
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 5
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 1
6300: PPUSH
6301: LD_INT 2
6303: PPUSH
6304: CALL_OW 12
6308: ARRAY
6309: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6310: LD_ADDR_OWVAR 40
6314: PUSH
6315: LD_INT 28
6317: PUSH
6318: LD_INT 27
6320: PUSH
6321: LD_INT 28
6323: PUSH
6324: LD_INT 25
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 1
6335: PPUSH
6336: LD_INT 4
6338: PPUSH
6339: CALL_OW 12
6343: ARRAY
6344: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6345: LD_ADDR_VAR 0 7
6349: PUSH
6350: LD_VAR 0 7
6354: PUSH
6355: CALL_OW 45
6359: ADD
6360: ST_TO_ADDR
// end ;
6361: GO 6256
6363: POP
6364: POP
// end ; if bonus_num = 4 then
6365: LD_EXP 12
6369: PUSH
6370: LD_INT 4
6372: EQUAL
6373: IFFALSE 6424
// for i = 1 to 3 do
6375: LD_ADDR_VAR 0 10
6379: PUSH
6380: DOUBLE
6381: LD_INT 1
6383: DEC
6384: ST_TO_ADDR
6385: LD_INT 3
6387: PUSH
6388: FOR_TO
6389: IFFALSE 6422
// begin PrepareHuman ( false , 3 , 8 ) ;
6391: LD_INT 0
6393: PPUSH
6394: LD_INT 3
6396: PPUSH
6397: LD_INT 8
6399: PPUSH
6400: CALL_OW 380
// units := units ^ CreateHuman ;
6404: LD_ADDR_VAR 0 7
6408: PUSH
6409: LD_VAR 0 7
6413: PUSH
6414: CALL_OW 44
6418: ADD
6419: ST_TO_ADDR
// end ;
6420: GO 6388
6422: POP
6423: POP
// end ; 4 :
6424: GO 6446
6426: LD_INT 4
6428: DOUBLE
6429: EQUAL
6430: IFTRUE 6434
6432: GO 6445
6434: POP
// off := false ; end ;
6435: LD_ADDR_VAR 0 6
6439: PUSH
6440: LD_INT 0
6442: ST_TO_ADDR
6443: GO 6446
6445: POP
// if not off then
6446: LD_VAR 0 6
6450: NOT
6451: IFFALSE 6457
// exit else
6453: GO 6636
6455: GO 6510
// begin SetArtifactUse ( your_side , art_exp_mid , art_no , main_base ) ;
6457: LD_OWVAR 2
6461: PPUSH
6462: LD_INT 2
6464: PPUSH
6465: LD_INT 0
6467: PPUSH
6468: LD_INT 23
6470: PPUSH
6471: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6475: LD_EXP 10
6479: PPUSH
6480: LD_STRING DVr-3
6482: PUSH
6483: LD_STRING DVr-3a
6485: PUSH
6486: LD_STRING DVr-3b
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 1
6496: PPUSH
6497: LD_INT 3
6499: PPUSH
6500: CALL_OW 12
6504: ARRAY
6505: PPUSH
6506: CALL_OW 94
// end ; if units then
6510: LD_VAR 0 7
6514: IFFALSE 6578
// for i in units do
6516: LD_ADDR_VAR 0 10
6520: PUSH
6521: LD_VAR 0 7
6525: PUSH
6526: FOR_IN
6527: IFFALSE 6576
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6529: LD_VAR 0 10
6533: PPUSH
6534: LD_INT 92
6536: PPUSH
6537: LD_INT 49
6539: PPUSH
6540: LD_INT 20
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6550: LD_VAR 0 10
6554: PPUSH
6555: CALL_OW 250
6559: PPUSH
6560: LD_VAR 0 10
6564: PPUSH
6565: CALL_OW 251
6569: PPUSH
6570: CALL_OW 494
// end ;
6574: GO 6526
6576: POP
6577: POP
// if crates then
6578: LD_VAR 0 8
6582: IFFALSE 6636
// for i = 1 to ( crates div 50 ) do
6584: LD_ADDR_VAR 0 10
6588: PUSH
6589: DOUBLE
6590: LD_INT 1
6592: DEC
6593: ST_TO_ADDR
6594: LD_VAR 0 8
6598: PUSH
6599: LD_INT 50
6601: DIV
6602: PUSH
6603: FOR_TO
6604: IFFALSE 6634
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6606: LD_INT 5
6608: PPUSH
6609: LD_INT 92
6611: PPUSH
6612: LD_INT 49
6614: PPUSH
6615: LD_INT 30
6617: PPUSH
6618: LD_INT 1
6620: PPUSH
6621: CALL_OW 56
// wait ( 0 0$02 ) ;
6625: LD_INT 70
6627: PPUSH
6628: CALL_OW 67
// end ;
6632: GO 6603
6634: POP
6635: POP
// end ; end_of_file
6636: PPOPN 10
6638: END
// every 0 0$01 trigger not game_over do
6639: LD_EXP 7
6643: NOT
6644: IFFALSE 6677
6646: GO 6648
6648: DISABLE
// begin enable ;
6649: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6650: LD_ADDR_OWVAR 47
6654: PUSH
6655: LD_STRING #tick
6657: PUSH
6658: LD_OWVAR 1
6662: PUSH
6663: LD_STRING #points
6665: PUSH
6666: LD_EXP 8
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: ST_TO_ADDR
// end ;
6677: END
// every 0 0$01 trigger game_over do
6678: LD_EXP 7
6682: IFFALSE 6741
6684: GO 6686
6686: DISABLE
// begin Wait ( 0 0$02 ) ;
6687: LD_INT 70
6689: PPUSH
6690: CALL_OW 67
// DialogueOn ;
6694: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6698: LD_ADDR_OWVAR 47
6702: PUSH
6703: LD_STRING #game-points
6705: PUSH
6706: LD_OWVAR 78
6710: PUSH
6711: LD_EXP 8
6715: PUSH
6716: LD_STRING #game-time
6718: PUSH
6719: LD_OWVAR 1
6723: PUSH
6724: LD_STRING #game-difficulty
6726: PUSH
6727: LD_OWVAR 67
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: ST_TO_ADDR
// end ; end_of_file
6741: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6742: LD_OWVAR 1
6746: PUSH
6747: LD_INT 52500
6749: LESS
6750: IFFALSE 6774
6752: GO 6754
6754: DISABLE
// begin enable ;
6755: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6756: LD_INT 1
6758: PPUSH
6759: LD_INT 5
6761: PPUSH
6762: CALL_OW 12
6766: PPUSH
6767: LD_INT 1
6769: PPUSH
6770: CALL_OW 57
// end ;
6774: END
