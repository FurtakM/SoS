// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 166 0 0
// PrepareAllies ;
  12: CALL 2157 0 0
// Action ;
  16: CALL 4299 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// InitVariables ;
  41: CALL 54 0 0
// SetDiplomacy ;
  45: CALL 118 0 0
// end ; end_of_file
  49: LD_VAR 0 1
  53: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  54: LD_INT 0
  56: PPUSH
// points := 0 ;
  57: LD_ADDR_EXP 8
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// alert := false ;
  65: LD_ADDR_EXP 6
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// game_over := false ;
  73: LD_ADDR_EXP 7
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// wave_time := 0 0$00 ;
  81: LD_ADDR_EXP 9
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// bonus_active := false ;
  89: LD_ADDR_EXP 11
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// ignore_wave := false ;
  97: LD_ADDR_EXP 13
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// bonus_num := 0 ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// end ;
 113: LD_VAR 0 1
 117: RET
// export function SetDiplomacy ; begin
 118: LD_INT 0
 120: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 121: LD_INT 92
 123: PPUSH
 124: LD_INT 48
 126: PPUSH
 127: LD_INT 8
 129: PPUSH
 130: LD_INT 32796
 132: NEG
 133: PPUSH
 134: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 138: LD_INT 92
 140: PPUSH
 141: LD_INT 48
 143: PPUSH
 144: LD_INT 8
 146: PPUSH
 147: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 151: LD_INT 5
 153: PPUSH
 154: LD_INT 8
 156: PPUSH
 157: CALL_OW 343
// end ; end_of_file
 161: LD_VAR 0 1
 165: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 166: LD_INT 0
 168: PPUSH
 169: PPUSH
 170: PPUSH
 171: PPUSH
 172: PPUSH
 173: PPUSH
 174: PPUSH
 175: PPUSH
 176: PPUSH
 177: PPUSH
 178: PPUSH
 179: PPUSH
 180: PPUSH
 181: PPUSH
 182: PPUSH
 183: PPUSH
 184: PPUSH
 185: PPUSH
// uc_side := 2 ;
 186: LD_ADDR_OWVAR 20
 190: PUSH
 191: LD_INT 2
 193: ST_TO_ADDR
// uc_nation := nation_arabian ;
 194: LD_ADDR_OWVAR 21
 198: PUSH
 199: LD_INT 2
 201: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 202: LD_INT 1
 204: PPUSH
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 6
 210: PPUSH
 211: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 215: LD_ADDR_OWVAR 26
 219: PUSH
 220: LD_STRING Nicolas Vervecken
 222: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 223: LD_ADDR_OWVAR 33
 227: PUSH
 228: LD_STRING SecondCharsGal
 230: ST_TO_ADDR
// hc_face_number := 3 ;
 231: LD_ADDR_OWVAR 34
 235: PUSH
 236: LD_INT 3
 238: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 239: LD_ADDR_OWVAR 29
 243: PUSH
 244: LD_INT 11
 246: PUSH
 247: LD_INT 10
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// Vervecken := CreateHuman ;
 254: LD_ADDR_EXP 10
 258: PUSH
 259: CALL_OW 44
 263: ST_TO_ADDR
// InitHc ;
 264: CALL_OW 19
// uc_side := 8 ;
 268: LD_ADDR_OWVAR 20
 272: PUSH
 273: LD_INT 8
 275: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 276: LD_INT 23
 278: PPUSH
 279: CALL_OW 274
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 4000
 289: PUSH
 290: LD_INT 2500
 292: PUSH
 293: LD_INT 1250
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: LD_OWVAR 67
 305: ARRAY
 306: PPUSH
 307: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 311: LD_INT 23
 313: PPUSH
 314: CALL_OW 274
 318: PPUSH
 319: LD_INT 2
 321: PPUSH
 322: LD_INT 300
 324: PPUSH
 325: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 329: LD_INT 23
 331: PPUSH
 332: CALL_OW 274
 336: PPUSH
 337: LD_INT 3
 339: PPUSH
 340: LD_INT 100
 342: PUSH
 343: LD_INT 50
 345: PUSH
 346: LD_INT 30
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: PPUSH
 360: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 364: LD_ADDR_VAR 0 14
 368: PUSH
 369: LD_INT 23
 371: PPUSH
 372: CALL_OW 250
 376: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 377: LD_ADDR_VAR 0 15
 381: PUSH
 382: LD_INT 23
 384: PPUSH
 385: CALL_OW 251
 389: ST_TO_ADDR
// team := [ ] ;
 390: LD_ADDR_VAR 0 7
 394: PUSH
 395: EMPTY
 396: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 397: LD_ADDR_VAR 0 8
 401: PUSH
 402: LD_INT 9
 404: PUSH
 405: LD_INT 8
 407: PUSH
 408: LD_INT 7
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_OWVAR 67
 420: ARRAY
 421: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 422: LD_ADDR_VAR 0 9
 426: PUSH
 427: LD_INT 11
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: LD_INT 8
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_OWVAR 67
 445: ARRAY
 446: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 447: LD_ADDR_VAR 0 10
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: LD_INT 2
 457: PUSH
 458: LD_INT 2
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: LIST
 465: PUSH
 466: LD_OWVAR 67
 470: ARRAY
 471: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 472: LD_ADDR_VAR 0 11
 476: PUSH
 477: LD_INT 5
 479: PUSH
 480: LD_INT 4
 482: PUSH
 483: LD_INT 3
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_OWVAR 67
 495: ARRAY
 496: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 497: LD_ADDR_VAR 0 12
 501: PUSH
 502: LD_INT 3
 504: PUSH
 505: LD_INT 2
 507: PUSH
 508: LD_INT 2
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: PUSH
 516: LD_OWVAR 67
 520: ARRAY
 521: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 522: LD_ADDR_VAR 0 13
 526: PUSH
 527: LD_INT 6
 529: PUSH
 530: LD_INT 5
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: EMPTY
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_OWVAR 67
 545: ARRAY
 546: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 547: LD_ADDR_VAR 0 18
 551: PUSH
 552: LD_INT 13
 554: PUSH
 555: LD_INT 1
 557: PUSH
 558: LD_INT 1
 560: PUSH
 561: LD_INT 26
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: PUSH
 570: LD_INT 14
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 1
 578: PUSH
 579: LD_INT 25
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 14
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 32
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: LD_INT 14
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 1
 614: PUSH
 615: LD_INT 31
 617: PUSH
 618: EMPTY
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PUSH
 624: LD_INT 14
 626: PUSH
 627: LD_INT 3
 629: PUSH
 630: LD_INT 2
 632: PUSH
 633: LD_INT 24
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: PUSH
 642: LD_INT 14
 644: PUSH
 645: LD_INT 3
 647: PUSH
 648: LD_INT 2
 650: PUSH
 651: LD_INT 25
 653: PUSH
 654: EMPTY
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PUSH
 660: LD_INT 13
 662: PUSH
 663: LD_INT 3
 665: PUSH
 666: LD_INT 1
 668: PUSH
 669: LD_INT 24
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: LIST
 686: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 687: LD_ADDR_VAR 0 2
 691: PUSH
 692: DOUBLE
 693: LD_INT 1
 695: DEC
 696: ST_TO_ADDR
 697: LD_VAR 0 18
 701: PUSH
 702: LD_OWVAR 67
 706: MINUS
 707: PUSH
 708: LD_INT 1
 710: PLUS
 711: PUSH
 712: FOR_TO
 713: IFFALSE 842
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 715: LD_ADDR_OWVAR 37
 719: PUSH
 720: LD_VAR 0 18
 724: PUSH
 725: LD_VAR 0 2
 729: ARRAY
 730: PUSH
 731: LD_INT 1
 733: ARRAY
 734: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 735: LD_ADDR_OWVAR 39
 739: PUSH
 740: LD_VAR 0 18
 744: PUSH
 745: LD_VAR 0 2
 749: ARRAY
 750: PUSH
 751: LD_INT 2
 753: ARRAY
 754: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 755: LD_ADDR_OWVAR 38
 759: PUSH
 760: LD_VAR 0 18
 764: PUSH
 765: LD_VAR 0 2
 769: ARRAY
 770: PUSH
 771: LD_INT 3
 773: ARRAY
 774: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 775: LD_ADDR_OWVAR 40
 779: PUSH
 780: LD_VAR 0 18
 784: PUSH
 785: LD_VAR 0 2
 789: ARRAY
 790: PUSH
 791: LD_INT 4
 793: ARRAY
 794: ST_TO_ADDR
// un := CreateVehicle ;
 795: LD_ADDR_VAR 0 6
 799: PUSH
 800: CALL_OW 45
 804: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 805: LD_VAR 0 6
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: LD_INT 5
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 825: LD_VAR 0 6
 829: PPUSH
 830: LD_INT 7
 832: PPUSH
 833: LD_INT 0
 835: PPUSH
 836: CALL_OW 49
// end ;
 840: GO 712
 842: POP
 843: POP
// for i = 1 to ape_num do
 844: LD_ADDR_VAR 0 2
 848: PUSH
 849: DOUBLE
 850: LD_INT 1
 852: DEC
 853: ST_TO_ADDR
 854: LD_VAR 0 13
 858: PUSH
 859: FOR_TO
 860: IFFALSE 927
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 862: LD_INT 0
 864: PPUSH
 865: LD_INT 16
 867: PUSH
 868: LD_INT 15
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: LD_INT 1
 877: PPUSH
 878: LD_INT 2
 880: PPUSH
 881: CALL_OW 12
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 8
 891: PPUSH
 892: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 896: LD_ADDR_VAR 0 7
 900: PUSH
 901: LD_VAR 0 7
 905: PPUSH
 906: LD_VAR 0 7
 910: PUSH
 911: LD_INT 1
 913: PLUS
 914: PPUSH
 915: CALL_OW 44
 919: PPUSH
 920: CALL_OW 2
 924: ST_TO_ADDR
// end ;
 925: GO 859
 927: POP
 928: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 1
 934: PPUSH
 935: LD_VAR 0 8
 939: PPUSH
 940: CALL_OW 380
// l1 := CreateHuman ;
 944: LD_ADDR_EXP 2
 948: PUSH
 949: CALL_OW 44
 953: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 954: LD_EXP 2
 958: PPUSH
 959: LD_INT 23
 961: PPUSH
 962: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 966: LD_INT 1
 968: PPUSH
 969: LD_INT 1
 971: PPUSH
 972: LD_VAR 0 8
 976: PPUSH
 977: CALL_OW 380
// l2 := CreateHuman ;
 981: LD_ADDR_EXP 3
 985: PUSH
 986: CALL_OW 44
 990: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
 991: LD_EXP 3
 995: PPUSH
 996: LD_INT 23
 998: PPUSH
 999: CALL_OW 52
// for class = 1 to 4 do
1003: LD_ADDR_VAR 0 4
1007: PUSH
1008: DOUBLE
1009: LD_INT 1
1011: DEC
1012: ST_TO_ADDR
1013: LD_INT 4
1015: PUSH
1016: FOR_TO
1017: IFFALSE 1116
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1019: LD_ADDR_VAR 0 2
1023: PUSH
1024: DOUBLE
1025: LD_INT 1
1027: DEC
1028: ST_TO_ADDR
1029: LD_VAR 0 9
1033: PUSH
1034: LD_VAR 0 10
1038: PUSH
1039: LD_VAR 0 11
1043: PUSH
1044: LD_VAR 0 12
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: LD_VAR 0 4
1059: ARRAY
1060: PUSH
1061: FOR_TO
1062: IFFALSE 1112
// begin PrepareHuman ( false , class , skill ) ;
1064: LD_INT 0
1066: PPUSH
1067: LD_VAR 0 4
1071: PPUSH
1072: LD_VAR 0 8
1076: PPUSH
1077: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1081: LD_ADDR_VAR 0 7
1085: PUSH
1086: LD_VAR 0 7
1090: PPUSH
1091: LD_VAR 0 7
1095: PUSH
1096: LD_INT 1
1098: PLUS
1099: PPUSH
1100: CALL_OW 44
1104: PPUSH
1105: CALL_OW 2
1109: ST_TO_ADDR
// end ;
1110: GO 1061
1112: POP
1113: POP
1114: GO 1016
1116: POP
1117: POP
// for i in team do
1118: LD_ADDR_VAR 0 2
1122: PUSH
1123: LD_VAR 0 7
1127: PUSH
1128: FOR_IN
1129: IFFALSE 1605
// begin b := 0 ;
1131: LD_ADDR_VAR 0 5
1135: PUSH
1136: LD_INT 0
1138: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1139: LD_VAR 0 2
1143: PPUSH
1144: CALL_OW 257
1148: PUSH
1149: LD_INT 1
1151: DOUBLE
1152: EQUAL
1153: IFTRUE 1157
1155: GO 1264
1157: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1158: LD_ADDR_VAR 0 5
1162: PUSH
1163: LD_INT 22
1165: PUSH
1166: LD_OWVAR 20
1170: PUSH
1171: EMPTY
1172: LIST
1173: LIST
1174: PUSH
1175: LD_INT 2
1177: PUSH
1178: LD_INT 30
1180: PUSH
1181: LD_INT 32
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 31
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 58
1205: PUSH
1206: EMPTY
1207: LIST
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: LIST
1213: PPUSH
1214: CALL_OW 69
1218: ST_TO_ADDR
// if not b then
1219: LD_VAR 0 5
1223: NOT
1224: IFFALSE 1262
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1226: LD_ADDR_VAR 0 5
1230: PUSH
1231: LD_INT 22
1233: PUSH
1234: LD_OWVAR 20
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: LD_INT 5
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: PPUSH
1257: CALL_OW 69
1261: ST_TO_ADDR
// end ; class_engineer :
1262: GO 1503
1264: LD_INT 2
1266: DOUBLE
1267: EQUAL
1268: IFTRUE 1272
1270: GO 1311
1272: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1273: LD_ADDR_VAR 0 5
1277: PUSH
1278: LD_INT 22
1280: PUSH
1281: LD_OWVAR 20
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 30
1292: PUSH
1293: LD_INT 1
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL_OW 69
1308: ST_TO_ADDR
1309: GO 1503
1311: LD_INT 3
1313: DOUBLE
1314: EQUAL
1315: IFTRUE 1319
1317: GO 1408
1319: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1320: LD_ADDR_VAR 0 5
1324: PUSH
1325: LD_INT 22
1327: PUSH
1328: LD_OWVAR 20
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 2
1342: PUSH
1343: EMPTY
1344: LIST
1345: LIST
1346: PUSH
1347: LD_INT 58
1349: PUSH
1350: EMPTY
1351: LIST
1352: PUSH
1353: EMPTY
1354: LIST
1355: LIST
1356: LIST
1357: PPUSH
1358: CALL_OW 69
1362: ST_TO_ADDR
// if not b then
1363: LD_VAR 0 5
1367: NOT
1368: IFFALSE 1406
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1370: LD_ADDR_VAR 0 5
1374: PUSH
1375: LD_INT 22
1377: PUSH
1378: LD_OWVAR 20
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: LD_INT 30
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: PPUSH
1401: CALL_OW 69
1405: ST_TO_ADDR
// end ; class_scientistic :
1406: GO 1503
1408: LD_INT 4
1410: DOUBLE
1411: EQUAL
1412: IFTRUE 1416
1414: GO 1455
1416: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1417: LD_ADDR_VAR 0 5
1421: PUSH
1422: LD_INT 22
1424: PUSH
1425: LD_OWVAR 20
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: PUSH
1434: LD_INT 30
1436: PUSH
1437: LD_INT 8
1439: PUSH
1440: EMPTY
1441: LIST
1442: LIST
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PPUSH
1448: CALL_OW 69
1452: ST_TO_ADDR
// end ; class_apeman_soldier :
1453: GO 1503
1455: LD_INT 15
1457: DOUBLE
1458: EQUAL
1459: IFTRUE 1463
1461: GO 1502
1463: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1464: LD_ADDR_VAR 0 5
1468: PUSH
1469: LD_INT 22
1471: PUSH
1472: LD_OWVAR 20
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 30
1483: PUSH
1484: LD_INT 5
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: PUSH
1491: EMPTY
1492: LIST
1493: LIST
1494: PPUSH
1495: CALL_OW 69
1499: ST_TO_ADDR
1500: GO 1503
1502: POP
// if b then
1503: LD_VAR 0 5
1507: IFFALSE 1578
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1509: LD_VAR 0 5
1513: PUSH
1514: LD_INT 1
1516: ARRAY
1517: PPUSH
1518: CALL_OW 266
1522: PUSH
1523: LD_INT 31
1525: EQUAL
1526: IFFALSE 1548
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_VAR 0 5
1537: PUSH
1538: LD_INT 1
1540: ARRAY
1541: PPUSH
1542: CALL 4996 0 2
1546: GO 1576
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_VAR 0 5
1557: PUSH
1558: LD_INT 1
1560: PPUSH
1561: LD_VAR 0 5
1565: PPUSH
1566: CALL_OW 12
1570: ARRAY
1571: PPUSH
1572: CALL_OW 52
1576: GO 1603
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_VAR 0 14
1587: PPUSH
1588: LD_VAR 0 15
1592: PPUSH
1593: LD_INT 15
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 50
// end ;
1603: GO 1128
1605: POP
1606: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1607: LD_ADDR_VAR 0 16
1611: PUSH
1612: LD_INT 26
1614: PUSH
1615: LD_INT 3
1617: PUSH
1618: LD_INT 2
1620: PUSH
1621: LD_INT 1
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: PUSH
1629: LD_OWVAR 67
1633: ARRAY
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: LD_INT 25
1641: PUSH
1642: LD_INT 5
1644: PUSH
1645: LD_INT 4
1647: PUSH
1648: LD_INT 3
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: PUSH
1656: LD_OWVAR 67
1660: ARRAY
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: PUSH
1666: LD_INT 24
1668: PUSH
1669: LD_INT 5
1671: PUSH
1672: LD_INT 5
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: LIST
1682: PUSH
1683: LD_OWVAR 67
1687: ARRAY
1688: PUSH
1689: EMPTY
1690: LIST
1691: LIST
1692: PUSH
1693: LD_INT 30
1695: PUSH
1696: LD_INT 2
1698: PUSH
1699: LD_INT 1
1701: PUSH
1702: LD_INT 1
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: LIST
1709: PUSH
1710: LD_OWVAR 67
1714: ARRAY
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1726: LD_ADDR_VAR 0 2
1730: PUSH
1731: LD_INT 22
1733: PUSH
1734: LD_OWVAR 20
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 30
1745: PUSH
1746: LD_INT 32
1748: PUSH
1749: EMPTY
1750: LIST
1751: LIST
1752: PUSH
1753: EMPTY
1754: LIST
1755: LIST
1756: PPUSH
1757: CALL_OW 69
1761: PUSH
1762: FOR_IN
1763: IFFALSE 1936
// begin if weapons then
1765: LD_VAR 0 16
1769: IFFALSE 1893
// begin k := rand ( 1 , weapons ) ;
1771: LD_ADDR_VAR 0 3
1775: PUSH
1776: LD_INT 1
1778: PPUSH
1779: LD_VAR 0 16
1783: PPUSH
1784: CALL_OW 12
1788: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1789: LD_ADDR_VAR 0 17
1793: PUSH
1794: LD_VAR 0 16
1798: PUSH
1799: LD_VAR 0 3
1803: ARRAY
1804: PUSH
1805: LD_INT 1
1807: ARRAY
1808: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1809: LD_ADDR_VAR 0 16
1813: PUSH
1814: LD_VAR 0 16
1818: PPUSH
1819: LD_VAR 0 3
1823: PPUSH
1824: LD_INT 2
1826: PPUSH
1827: LD_VAR 0 16
1831: PUSH
1832: LD_VAR 0 3
1836: ARRAY
1837: PUSH
1838: LD_INT 2
1840: ARRAY
1841: PUSH
1842: LD_INT 1
1844: MINUS
1845: PPUSH
1846: CALL 5088 0 4
1850: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1851: LD_VAR 0 16
1855: PUSH
1856: LD_VAR 0 3
1860: ARRAY
1861: PUSH
1862: LD_INT 2
1864: ARRAY
1865: PUSH
1866: LD_INT 0
1868: EQUAL
1869: IFFALSE 1891
// weapons := Delete ( weapons , k ) ;
1871: LD_ADDR_VAR 0 16
1875: PUSH
1876: LD_VAR 0 16
1880: PPUSH
1881: LD_VAR 0 3
1885: PPUSH
1886: CALL_OW 3
1890: ST_TO_ADDR
// end else
1891: GO 1920
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1893: LD_ADDR_VAR 0 17
1897: PUSH
1898: LD_INT 27
1900: PUSH
1901: LD_INT 23
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: PUSH
1908: LD_INT 1
1910: PPUSH
1911: LD_INT 2
1913: PPUSH
1914: CALL_OW 12
1918: ARRAY
1919: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1920: LD_VAR 0 2
1924: PPUSH
1925: LD_VAR 0 17
1929: PPUSH
1930: CALL_OW 431
// end ;
1934: GO 1762
1936: POP
1937: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1938: LD_INT 1
1940: PPUSH
1941: LD_INT 1
1943: PPUSH
1944: LD_VAR 0 8
1948: PUSH
1949: LD_INT 1
1951: PLUS
1952: PPUSH
1953: CALL_OW 380
// hc_gallery := potter ;
1957: LD_ADDR_OWVAR 33
1961: PUSH
1962: LD_STRING potter
1964: ST_TO_ADDR
// hc_face_number := 1 ;
1965: LD_ADDR_OWVAR 34
1969: PUSH
1970: LD_INT 1
1972: ST_TO_ADDR
// hc_importance := 100 ;
1973: LD_ADDR_OWVAR 32
1977: PUSH
1978: LD_INT 100
1980: ST_TO_ADDR
// hc_name := Mike Gerste ;
1981: LD_ADDR_OWVAR 26
1985: PUSH
1986: LD_STRING Mike Gerste
1988: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1989: LD_ADDR_OWVAR 29
1993: PUSH
1994: LD_INT 10
1996: PUSH
1997: LD_INT 11
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: ST_TO_ADDR
// legion_commander := CreateHuman ;
2004: LD_ADDR_EXP 1
2008: PUSH
2009: CALL_OW 44
2013: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2014: LD_EXP 1
2018: PPUSH
2019: LD_INT 23
2021: PPUSH
2022: CALL_OW 52
// uc_side := 5 ;
2026: LD_ADDR_OWVAR 20
2030: PUSH
2031: LD_INT 5
2033: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2034: LD_INT 1
2036: PPUSH
2037: LD_INT 4
2039: PPUSH
2040: LD_VAR 0 8
2044: PPUSH
2045: CALL_OW 380
// hc_gallery := potter ;
2049: LD_ADDR_OWVAR 33
2053: PUSH
2054: LD_STRING potter
2056: ST_TO_ADDR
// hc_face_number := 2 ;
2057: LD_ADDR_OWVAR 34
2061: PUSH
2062: LD_INT 2
2064: ST_TO_ADDR
// hc_importance := 0 ;
2065: LD_ADDR_OWVAR 32
2069: PUSH
2070: LD_INT 0
2072: ST_TO_ADDR
// hc_name := George Potter ;
2073: LD_ADDR_OWVAR 26
2077: PUSH
2078: LD_STRING George Potter
2080: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2081: LD_ADDR_OWVAR 29
2085: PUSH
2086: LD_INT 12
2088: PUSH
2089: LD_INT 9
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: ST_TO_ADDR
// potter := CreateHuman ;
2096: LD_ADDR_EXP 4
2100: PUSH
2101: CALL_OW 44
2105: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2106: LD_EXP 4
2110: PPUSH
2111: LD_INT 4
2113: PPUSH
2114: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2118: LD_EXP 4
2122: PPUSH
2123: LD_INT 103
2125: PPUSH
2126: LD_INT 45
2128: PPUSH
2129: LD_INT 0
2131: PPUSH
2132: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2136: LD_EXP 4
2140: PPUSH
2141: LD_INT 23
2143: PPUSH
2144: CALL_OW 119
// InitHc ( ) ;
2148: CALL_OW 19
// end ; end_of_file
2152: LD_VAR 0 1
2156: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2157: LD_INT 0
2159: PPUSH
2160: PPUSH
2161: PPUSH
2162: PPUSH
2163: PPUSH
// uc_side := 5 ;
2164: LD_ADDR_OWVAR 20
2168: PUSH
2169: LD_INT 5
2171: ST_TO_ADDR
// uc_nation := nation_arabian ;
2172: LD_ADDR_OWVAR 21
2176: PUSH
2177: LD_INT 2
2179: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2180: LD_ADDR_VAR 0 4
2184: PUSH
2185: LD_INT 22
2187: PUSH
2188: LD_OWVAR 20
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 30
2199: PUSH
2200: LD_INT 5
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: PUSH
2207: EMPTY
2208: LIST
2209: LIST
2210: PPUSH
2211: CALL_OW 69
2215: ST_TO_ADDR
// for i = 1 to 3 do
2216: LD_ADDR_VAR 0 2
2220: PUSH
2221: DOUBLE
2222: LD_INT 1
2224: DEC
2225: ST_TO_ADDR
2226: LD_INT 3
2228: PUSH
2229: FOR_TO
2230: IFFALSE 2268
// begin PrepareHuman ( false , 2 , 6 ) ;
2232: LD_INT 0
2234: PPUSH
2235: LD_INT 2
2237: PPUSH
2238: LD_INT 6
2240: PPUSH
2241: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2245: CALL_OW 44
2249: PPUSH
2250: LD_INT 27
2252: PPUSH
2253: LD_INT 22
2255: PPUSH
2256: LD_INT 5
2258: PPUSH
2259: LD_INT 0
2261: PPUSH
2262: CALL_OW 50
// end ;
2266: GO 2229
2268: POP
2269: POP
// for i = 1 to 3 do
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_INT 3
2282: PUSH
2283: FOR_TO
2284: IFFALSE 2319
// begin PrepareHuman ( false , 1 , 6 ) ;
2286: LD_INT 0
2288: PPUSH
2289: LD_INT 1
2291: PPUSH
2292: LD_INT 6
2294: PPUSH
2295: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2299: CALL_OW 44
2303: PPUSH
2304: LD_VAR 0 4
2308: PUSH
2309: LD_INT 1
2311: ARRAY
2312: PPUSH
2313: CALL_OW 52
// end ;
2317: GO 2283
2319: POP
2320: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_INT 22
2328: PUSH
2329: LD_OWVAR 20
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PUSH
2338: LD_INT 2
2340: PUSH
2341: LD_INT 30
2343: PUSH
2344: LD_INT 31
2346: PUSH
2347: EMPTY
2348: LIST
2349: LIST
2350: PUSH
2351: LD_INT 30
2353: PUSH
2354: LD_INT 32
2356: PUSH
2357: EMPTY
2358: LIST
2359: LIST
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 69
2374: PUSH
2375: FOR_IN
2376: IFFALSE 2463
// begin PrepareHuman ( false , 1 , 6 ) ;
2378: LD_INT 0
2380: PPUSH
2381: LD_INT 1
2383: PPUSH
2384: LD_INT 6
2386: PPUSH
2387: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2391: CALL_OW 44
2395: PPUSH
2396: LD_VAR 0 2
2400: PPUSH
2401: CALL 4996 0 2
// if GetBType ( i ) = b_bunker then
2405: LD_VAR 0 2
2409: PPUSH
2410: CALL_OW 266
2414: PUSH
2415: LD_INT 32
2417: EQUAL
2418: IFFALSE 2461
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2420: LD_VAR 0 2
2424: PPUSH
2425: LD_INT 27
2427: PUSH
2428: LD_INT 25
2430: PUSH
2431: LD_INT 24
2433: PUSH
2434: LD_INT 28
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_INT 4
2450: MOD
2451: PUSH
2452: LD_INT 1
2454: PLUS
2455: ARRAY
2456: PPUSH
2457: CALL_OW 431
// end ;
2461: GO 2375
2463: POP
2464: POP
// for i = 1 to 3 do
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: DOUBLE
2471: LD_INT 1
2473: DEC
2474: ST_TO_ADDR
2475: LD_INT 3
2477: PUSH
2478: FOR_TO
2479: IFFALSE 2596
// begin vc_chassis := ar_half_tracked ;
2481: LD_ADDR_OWVAR 37
2485: PUSH
2486: LD_INT 14
2488: ST_TO_ADDR
// vc_engine := engine_solar ;
2489: LD_ADDR_OWVAR 39
2493: PUSH
2494: LD_INT 2
2496: ST_TO_ADDR
// vc_control := control_manual ;
2497: LD_ADDR_OWVAR 38
2501: PUSH
2502: LD_INT 1
2504: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2505: LD_ADDR_OWVAR 40
2509: PUSH
2510: LD_INT 25
2512: PUSH
2513: LD_INT 27
2515: PUSH
2516: LD_INT 26
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: PUSH
2524: LD_VAR 0 2
2528: ARRAY
2529: ST_TO_ADDR
// un := CreateVehicle ;
2530: LD_ADDR_VAR 0 3
2534: PUSH
2535: CALL_OW 45
2539: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2540: LD_VAR 0 3
2544: PPUSH
2545: LD_INT 5
2547: PPUSH
2548: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2552: LD_VAR 0 3
2556: PPUSH
2557: LD_INT 8
2559: PPUSH
2560: LD_INT 0
2562: PPUSH
2563: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2567: LD_INT 0
2569: PPUSH
2570: LD_INT 3
2572: PPUSH
2573: LD_INT 7
2575: PPUSH
2576: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2580: CALL_OW 44
2584: PPUSH
2585: LD_VAR 0 3
2589: PPUSH
2590: CALL_OW 52
// end ;
2594: GO 2478
2596: POP
2597: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2598: LD_INT 1
2600: PPUSH
2601: LD_INT 1
2603: PPUSH
2604: LD_INT 6
2606: PPUSH
2607: CALL_OW 380
// al_commander := CreateHuman ;
2611: LD_ADDR_EXP 5
2615: PUSH
2616: CALL_OW 44
2620: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2621: LD_EXP 5
2625: PPUSH
2626: LD_INT 22
2628: PUSH
2629: LD_OWVAR 20
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 30
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PPUSH
2652: CALL_OW 69
2656: PUSH
2657: LD_INT 1
2659: ARRAY
2660: PPUSH
2661: CALL_OW 52
// InitHc ( ) ;
2665: CALL_OW 19
// end ;
2669: LD_VAR 0 1
2673: RET
// export function ChangeSide ( ) ; var i ; begin
2674: LD_INT 0
2676: PPUSH
2677: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_INT 22
2685: PUSH
2686: LD_INT 5
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: FOR_IN
2699: IFFALSE 2715
// SetSide ( i , 8 ) ;
2701: LD_VAR 0 2
2705: PPUSH
2706: LD_INT 8
2708: PPUSH
2709: CALL_OW 235
2713: GO 2698
2715: POP
2716: POP
// end ;
2717: LD_VAR 0 1
2721: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2722: LD_INT 22
2724: PUSH
2725: LD_INT 5
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 69
2736: IFFALSE 3250
2738: GO 2740
2740: DISABLE
2741: LD_INT 0
2743: PPUSH
2744: PPUSH
2745: PPUSH
2746: PPUSH
2747: PPUSH
2748: PPUSH
// begin enable ;
2749: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 5
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 2
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 1
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: LD_INT 21
2780: PUSH
2781: LD_INT 2
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: LIST
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PPUSH
2797: CALL_OW 69
2801: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2802: LD_ADDR_VAR 0 5
2806: PUSH
2807: LD_INT 22
2809: PUSH
2810: LD_INT 5
2812: PUSH
2813: EMPTY
2814: LIST
2815: LIST
2816: PUSH
2817: LD_INT 30
2819: PUSH
2820: LD_INT 32
2822: PUSH
2823: EMPTY
2824: LIST
2825: LIST
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 24
2832: PUSH
2833: LD_INT 1000
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: PUSH
2840: EMPTY
2841: LIST
2842: LIST
2843: PUSH
2844: EMPTY
2845: LIST
2846: LIST
2847: LIST
2848: PPUSH
2849: CALL_OW 69
2853: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2854: LD_ADDR_VAR 0 6
2858: PUSH
2859: LD_VAR 0 2
2863: PPUSH
2864: LD_INT 3
2866: PUSH
2867: LD_INT 54
2869: PUSH
2870: EMPTY
2871: LIST
2872: PUSH
2873: EMPTY
2874: LIST
2875: LIST
2876: PUSH
2877: LD_INT 25
2879: PUSH
2880: LD_INT 3
2882: PUSH
2883: EMPTY
2884: LIST
2885: LIST
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PPUSH
2891: CALL_OW 72
2895: ST_TO_ADDR
// if not list then
2896: LD_VAR 0 2
2900: NOT
2901: IFFALSE 2905
// exit ;
2903: GO 3250
// for i in list do
2905: LD_ADDR_VAR 0 1
2909: PUSH
2910: LD_VAR 0 2
2914: PUSH
2915: FOR_IN
2916: IFFALSE 3248
// begin if b then
2918: LD_VAR 0 5
2922: IFFALSE 3001
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2924: LD_ADDR_VAR 0 4
2928: PUSH
2929: LD_VAR 0 2
2933: PPUSH
2934: LD_INT 25
2936: PUSH
2937: LD_INT 2
2939: PUSH
2940: EMPTY
2941: LIST
2942: LIST
2943: PPUSH
2944: CALL_OW 72
2948: PUSH
2949: FOR_IN
2950: IFFALSE 2999
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2952: LD_VAR 0 4
2956: PPUSH
2957: CALL_OW 314
2961: NOT
2962: PUSH
2963: LD_VAR 0 1
2967: PPUSH
2968: CALL_OW 110
2972: PUSH
2973: LD_INT 7
2975: NONEQUAL
2976: AND
2977: IFFALSE 2997
// ComRepairBuilding ( j , b [ 1 ] ) ;
2979: LD_VAR 0 4
2983: PPUSH
2984: LD_VAR 0 5
2988: PUSH
2989: LD_INT 1
2991: ARRAY
2992: PPUSH
2993: CALL_OW 130
2997: GO 2949
2999: POP
3000: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3001: LD_VAR 0 1
3005: PPUSH
3006: CALL_OW 256
3010: PUSH
3011: LD_INT 500
3013: LESS
3014: PUSH
3015: LD_VAR 0 1
3019: PPUSH
3020: CALL_OW 110
3024: PUSH
3025: LD_INT 7
3027: EQUAL
3028: NOT
3029: AND
3030: IFFALSE 3080
// begin ComMoveToArea ( i , guard_hill ) ;
3032: LD_VAR 0 1
3036: PPUSH
3037: LD_INT 11
3039: PPUSH
3040: CALL_OW 113
// SetTag ( i , 7 ) ;
3044: LD_VAR 0 1
3048: PPUSH
3049: LD_INT 7
3051: PPUSH
3052: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3056: LD_VAR 0 1
3060: PPUSH
3061: CALL_OW 247
3065: PUSH
3066: LD_INT 2
3068: EQUAL
3069: IFFALSE 3080
// begin AddComExitVehicle ( i ) ;
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 256
3089: PUSH
3090: LD_INT 1000
3092: EQUAL
3093: PUSH
3094: LD_VAR 0 1
3098: PPUSH
3099: CALL_OW 110
3103: PUSH
3104: LD_INT 7
3106: EQUAL
3107: AND
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 310
3118: NOT
3119: AND
3120: PUSH
3121: LD_VAR 0 6
3125: AND
3126: IFFALSE 3154
// begin SetTag ( i , 0 ) ;
3128: LD_VAR 0 1
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3140: LD_VAR 0 6
3144: PPUSH
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3154: LD_VAR 0 1
3158: PPUSH
3159: CALL_OW 247
3163: PUSH
3164: LD_INT 2
3166: EQUAL
3167: PUSH
3168: LD_VAR 0 1
3172: PPUSH
3173: CALL_OW 110
3177: PUSH
3178: LD_INT 7
3180: NONEQUAL
3181: AND
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 314
3192: NOT
3193: AND
3194: IFFALSE 3246
// if FilterAllUnits ( [ f_side , 7 ] ) then
3196: LD_INT 22
3198: PUSH
3199: LD_INT 7
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PPUSH
3206: CALL_OW 69
3210: IFFALSE 3246
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3212: LD_VAR 0 1
3216: PPUSH
3217: LD_INT 22
3219: PUSH
3220: LD_INT 7
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PPUSH
3227: CALL_OW 69
3231: PPUSH
3232: LD_VAR 0 1
3236: PPUSH
3237: CALL_OW 74
3241: PPUSH
3242: CALL_OW 115
// end ;
3246: GO 2915
3248: POP
3249: POP
// end ; end_of_file
3250: PPOPN 6
3252: END
// export function Game ; var i , val , areas , wave ; begin
3253: LD_INT 0
3255: PPUSH
3256: PPUSH
3257: PPUSH
3258: PPUSH
3259: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3260: LD_ADDR_VAR 0 4
3264: PUSH
3265: LD_INT 1
3267: PUSH
3268: LD_INT 2
3270: PUSH
3271: LD_INT 3
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 5
3279: PUSH
3280: LD_INT 6
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3291: LD_ADDR_VAR 0 3
3295: PUSH
3296: LD_INT 10
3298: PUSH
3299: LD_INT 20
3301: PUSH
3302: LD_INT 30
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: LD_OWVAR 67
3314: ARRAY
3315: ST_TO_ADDR
// wave := 1 ;
3316: LD_ADDR_VAR 0 5
3320: PUSH
3321: LD_INT 1
3323: ST_TO_ADDR
// while ( game_over = false ) do
3324: LD_EXP 7
3328: PUSH
3329: LD_INT 0
3331: EQUAL
3332: IFFALSE 3496
// begin repeat begin Wait ( 0 0$01 ) ;
3334: LD_INT 35
3336: PPUSH
3337: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3341: LD_ADDR_EXP 9
3345: PUSH
3346: LD_EXP 9
3350: PUSH
3351: LD_INT 35
3353: PLUS
3354: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3355: LD_INT 22
3357: PUSH
3358: LD_INT 7
3360: PUSH
3361: EMPTY
3362: LIST
3363: LIST
3364: PPUSH
3365: CALL_OW 69
3369: PUSH
3370: LD_INT 10
3372: LESS
3373: PUSH
3374: LD_EXP 9
3378: PUSH
3379: LD_INT 21000
3381: GREATEREQUAL
3382: OR
3383: IFFALSE 3334
// wave_time := 0 0$00 ;
3385: LD_ADDR_EXP 9
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3393: LD_INT 5250
3395: PPUSH
3396: CALL_OW 67
// if not ignore_wave then
3400: LD_EXP 13
3404: NOT
3405: IFFALSE 3486
// begin for i = 1 to wave do
3407: LD_ADDR_VAR 0 2
3411: PUSH
3412: DOUBLE
3413: LD_INT 1
3415: DEC
3416: ST_TO_ADDR
3417: LD_VAR 0 5
3421: PUSH
3422: FOR_TO
3423: IFFALSE 3468
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3425: LD_VAR 0 3
3429: PUSH
3430: LD_VAR 0 2
3434: MUL
3435: PPUSH
3436: LD_VAR 0 4
3440: PUSH
3441: LD_VAR 0 2
3445: PUSH
3446: LD_INT 6
3448: MOD
3449: PUSH
3450: LD_INT 1
3452: PLUS
3453: ARRAY
3454: PPUSH
3455: CALL 3501 0 2
// Wait ( 0 0$10 ) ;
3459: LD_INT 350
3461: PPUSH
3462: CALL_OW 67
// end ;
3466: GO 3422
3468: POP
3469: POP
// wave := wave + 1 ;
3470: LD_ADDR_VAR 0 5
3474: PUSH
3475: LD_VAR 0 5
3479: PUSH
3480: LD_INT 1
3482: PLUS
3483: ST_TO_ADDR
// end else
3484: GO 3494
// ignore_wave := false ;
3486: LD_ADDR_EXP 13
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// end ;
3494: GO 3324
// end ;
3496: LD_VAR 0 1
3500: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3501: LD_INT 0
3503: PPUSH
3504: PPUSH
3505: PPUSH
3506: PPUSH
// uc_side := 7 ;
3507: LD_ADDR_OWVAR 20
3511: PUSH
3512: LD_INT 7
3514: ST_TO_ADDR
// uc_nation := 2 ;
3515: LD_ADDR_OWVAR 21
3519: PUSH
3520: LD_INT 2
3522: ST_TO_ADDR
// InitHc ( ) ;
3523: CALL_OW 19
// hc_gallery :=  ;
3527: LD_ADDR_OWVAR 33
3531: PUSH
3532: LD_STRING 
3534: ST_TO_ADDR
// hc_importance := 0 ;
3535: LD_ADDR_OWVAR 32
3539: PUSH
3540: LD_INT 0
3542: ST_TO_ADDR
// hc_name :=  ;
3543: LD_ADDR_OWVAR 26
3547: PUSH
3548: LD_STRING 
3550: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3551: LD_ADDR_OWVAR 29
3555: PUSH
3556: LD_INT 10
3558: PUSH
3559: LD_OWVAR 1
3563: PUSH
3564: LD_INT 21000
3566: DIV
3567: PLUS
3568: PUSH
3569: LD_INT 10
3571: PUSH
3572: LD_OWVAR 1
3576: PUSH
3577: LD_INT 21000
3579: DIV
3580: PLUS
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: ST_TO_ADDR
// for i = 1 to val do
3586: LD_ADDR_VAR 0 4
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_VAR 0 1
3600: PUSH
3601: FOR_TO
3602: IFFALSE 3809
// begin if i mod 9 = 0 then
3604: LD_VAR 0 4
3608: PUSH
3609: LD_INT 9
3611: MOD
3612: PUSH
3613: LD_INT 0
3615: EQUAL
3616: IFFALSE 3628
// class := class_apeman_kamikaze else
3618: LD_ADDR_VAR 0 6
3622: PUSH
3623: LD_INT 17
3625: ST_TO_ADDR
3626: GO 3660
// if i mod 4 = 0 then
3628: LD_VAR 0 4
3632: PUSH
3633: LD_INT 4
3635: MOD
3636: PUSH
3637: LD_INT 0
3639: EQUAL
3640: IFFALSE 3652
// class := class_apeman_soldier else
3642: LD_ADDR_VAR 0 6
3646: PUSH
3647: LD_INT 15
3649: ST_TO_ADDR
3650: GO 3660
// class := class_apeman ;
3652: LD_ADDR_VAR 0 6
3656: PUSH
3657: LD_INT 12
3659: ST_TO_ADDR
// if i mod 33 = 0 then
3660: LD_VAR 0 4
3664: PUSH
3665: LD_INT 33
3667: MOD
3668: PUSH
3669: LD_INT 0
3671: EQUAL
3672: IFFALSE 3741
// begin vc_chassis := ar_half_tracked ;
3674: LD_ADDR_OWVAR 37
3678: PUSH
3679: LD_INT 14
3681: ST_TO_ADDR
// vc_control := control_apeman ;
3682: LD_ADDR_OWVAR 38
3686: PUSH
3687: LD_INT 5
3689: ST_TO_ADDR
// vc_engine := engine_combustion ;
3690: LD_ADDR_OWVAR 39
3694: PUSH
3695: LD_INT 1
3697: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3698: LD_ADDR_OWVAR 40
3702: PUSH
3703: LD_INT 28
3705: PUSH
3706: LD_INT 27
3708: PUSH
3709: LD_INT 29
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 1
3719: PPUSH
3720: LD_INT 2
3722: PPUSH
3723: CALL_OW 12
3727: ARRAY
3728: ST_TO_ADDR
// un := CreateVehicle ;
3729: LD_ADDR_VAR 0 5
3733: PUSH
3734: CALL_OW 45
3738: ST_TO_ADDR
// end else
3739: GO 3766
// begin PrepareHuman ( sex_male , class , 10 ) ;
3741: LD_INT 1
3743: PPUSH
3744: LD_VAR 0 6
3748: PPUSH
3749: LD_INT 10
3751: PPUSH
3752: CALL_OW 380
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 5
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3766: LD_VAR 0 5
3770: PPUSH
3771: LD_VAR 0 2
3775: PPUSH
3776: LD_INT 0
3778: PPUSH
3779: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3783: LD_VAR 0 5
3787: PPUSH
3788: CALL_OW 250
3792: PPUSH
3793: LD_VAR 0 5
3797: PPUSH
3798: CALL_OW 251
3802: PPUSH
3803: CALL_OW 494
// end ;
3807: GO 3601
3809: POP
3810: POP
// end ;
3811: LD_VAR 0 3
3815: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3816: LD_EXP 6
3820: PUSH
3821: LD_EXP 7
3825: NOT
3826: AND
3827: IFFALSE 4113
3829: GO 3831
3831: DISABLE
3832: LD_INT 0
3834: PPUSH
3835: PPUSH
3836: PPUSH
// begin enable ;
3837: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3838: LD_ADDR_VAR 0 2
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_INT 7
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: ST_TO_ADDR
// if not list then
3858: LD_VAR 0 2
3862: NOT
3863: IFFALSE 3867
// exit ;
3865: GO 4113
// for i in list do
3867: LD_ADDR_VAR 0 1
3871: PUSH
3872: LD_VAR 0 2
3876: PUSH
3877: FOR_IN
3878: IFFALSE 4111
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3880: LD_ADDR_VAR 0 3
3884: PUSH
3885: LD_INT 81
3887: PUSH
3888: LD_INT 7
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: LD_INT 92
3897: PUSH
3898: LD_VAR 0 1
3902: PPUSH
3903: CALL_OW 250
3907: PUSH
3908: LD_VAR 0 1
3912: PPUSH
3913: CALL_OW 251
3917: PUSH
3918: LD_INT 15
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: PPUSH
3931: CALL_OW 69
3935: ST_TO_ADDR
// if not enemy then
3936: LD_VAR 0 3
3940: NOT
3941: IFFALSE 3999
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3943: LD_ADDR_VAR 0 3
3947: PUSH
3948: LD_INT 81
3950: PUSH
3951: LD_INT 7
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: PUSH
3958: LD_INT 92
3960: PUSH
3961: LD_VAR 0 1
3965: PPUSH
3966: CALL_OW 250
3970: PUSH
3971: LD_VAR 0 1
3975: PPUSH
3976: CALL_OW 251
3980: PUSH
3981: LD_INT 30
3983: PUSH
3984: EMPTY
3985: LIST
3986: LIST
3987: LIST
3988: LIST
3989: PUSH
3990: EMPTY
3991: LIST
3992: LIST
3993: PPUSH
3994: CALL_OW 69
3998: ST_TO_ADDR
// if not enemy then
3999: LD_VAR 0 3
4003: NOT
4004: IFFALSE 4062
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4006: LD_ADDR_VAR 0 3
4010: PUSH
4011: LD_INT 81
4013: PUSH
4014: LD_INT 7
4016: PUSH
4017: EMPTY
4018: LIST
4019: LIST
4020: PUSH
4021: LD_INT 92
4023: PUSH
4024: LD_VAR 0 1
4028: PPUSH
4029: CALL_OW 250
4033: PUSH
4034: LD_VAR 0 1
4038: PPUSH
4039: CALL_OW 251
4043: PUSH
4044: LD_INT 50
4046: PUSH
4047: EMPTY
4048: LIST
4049: LIST
4050: LIST
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: PPUSH
4057: CALL_OW 69
4061: ST_TO_ADDR
// if not enemy then
4062: LD_VAR 0 3
4066: NOT
4067: IFFALSE 4089
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4069: LD_ADDR_VAR 0 3
4073: PUSH
4074: LD_INT 81
4076: PUSH
4077: LD_INT 7
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 69
4088: ST_TO_ADDR
// if enemy then
4089: LD_VAR 0 3
4093: IFFALSE 4109
// Attack ( i , enemy ) ;
4095: LD_VAR 0 1
4099: PPUSH
4100: LD_VAR 0 3
4104: PPUSH
4105: CALL 4116 0 2
// end ;
4109: GO 3877
4111: POP
4112: POP
// end ;
4113: PPOPN 3
4115: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4116: LD_INT 0
4118: PPUSH
4119: PPUSH
4120: PPUSH
// if not unit then
4121: LD_VAR 0 1
4125: NOT
4126: IFFALSE 4130
// exit ;
4128: GO 4294
// targets_list := [ ] ;
4130: LD_ADDR_VAR 0 5
4134: PUSH
4135: EMPTY
4136: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4137: LD_ADDR_VAR 0 5
4141: PUSH
4142: LD_VAR 0 2
4146: PPUSH
4147: LD_INT 21
4149: PUSH
4150: LD_INT 1
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PUSH
4157: LD_INT 3
4159: PUSH
4160: LD_INT 54
4162: PUSH
4163: EMPTY
4164: LIST
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PPUSH
4174: CALL_OW 72
4178: PUSH
4179: LD_VAR 0 2
4183: PPUSH
4184: LD_INT 21
4186: PUSH
4187: LD_INT 2
4189: PUSH
4190: EMPTY
4191: LIST
4192: LIST
4193: PPUSH
4194: CALL_OW 72
4198: PUSH
4199: LD_VAR 0 2
4203: PPUSH
4204: LD_INT 21
4206: PUSH
4207: LD_INT 3
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 3
4216: PUSH
4217: LD_INT 58
4219: PUSH
4220: EMPTY
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PPUSH
4231: CALL_OW 72
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: LIST
4246: ST_TO_ADDR
// for target in targets_list do
4247: LD_ADDR_VAR 0 4
4251: PUSH
4252: LD_VAR 0 5
4256: PUSH
4257: FOR_IN
4258: IFFALSE 4292
// begin if target then
4260: LD_VAR 0 4
4264: IFFALSE 4290
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4266: LD_VAR 0 1
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: LD_VAR 0 1
4280: PPUSH
4281: CALL_OW 74
4285: PPUSH
4286: CALL_OW 115
// end ;
4290: GO 4257
4292: POP
4293: POP
// end ; end_of_file
4294: LD_VAR 0 3
4298: RET
// export function Action ; begin
4299: LD_INT 0
4301: PPUSH
// InGameOn ;
4302: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4306: LD_INT 23
4308: PPUSH
4309: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4313: LD_EXP 1
4317: PPUSH
4318: LD_STRING DL-1
4320: PPUSH
4321: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4325: LD_EXP 2
4329: PPUSH
4330: LD_STRING DA-1
4332: PPUSH
4333: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4337: LD_EXP 3
4341: PPUSH
4342: LD_STRING DA-2
4344: PPUSH
4345: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4349: LD_EXP 1
4353: PPUSH
4354: LD_STRING DL-2
4356: PPUSH
4357: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4361: LD_EXP 3
4365: PPUSH
4366: LD_STRING DA-3
4368: PPUSH
4369: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4373: LD_EXP 1
4377: PPUSH
4378: LD_STRING DL-3
4380: PPUSH
4381: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4385: LD_EXP 2
4389: PPUSH
4390: LD_STRING DA-4
4392: PPUSH
4393: CALL_OW 88
// if not dialogue_skipped then
4397: LD_OWVAR 59
4401: NOT
4402: IFFALSE 4487
// begin Wait ( 0 0$01 ) ;
4404: LD_INT 35
4406: PPUSH
4407: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4411: LD_EXP 2
4415: PUSH
4416: LD_EXP 3
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PPUSH
4425: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4429: LD_EXP 2
4433: PPUSH
4434: LD_INT 107
4436: PPUSH
4437: LD_INT 53
4439: PPUSH
4440: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4444: LD_EXP 3
4448: PPUSH
4449: LD_INT 108
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4459: LD_EXP 2
4463: PPUSH
4464: LD_EXP 4
4468: PPUSH
4469: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4473: LD_EXP 3
4477: PPUSH
4478: LD_EXP 4
4482: PPUSH
4483: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4487: LD_INT 35
4489: PPUSH
4490: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4494: LD_EXP 2
4498: PPUSH
4499: LD_INT 107
4501: PPUSH
4502: LD_INT 53
4504: PPUSH
4505: CALL_OW 307
4509: PUSH
4510: LD_OWVAR 59
4514: OR
4515: IFFALSE 4487
// if not dialogue_skipped then
4517: LD_OWVAR 59
4521: NOT
4522: IFFALSE 4623
// begin ComTurnUnit ( potter , l1 ) ;
4524: LD_EXP 4
4528: PPUSH
4529: LD_EXP 2
4533: PPUSH
4534: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4538: LD_INT 10
4540: PPUSH
4541: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4545: LD_EXP 4
4549: PPUSH
4550: LD_INT 108
4552: PPUSH
4553: LD_INT 1
4555: PPUSH
4556: LD_INT 0
4558: PPUSH
4559: LD_INT 0
4561: PPUSH
4562: CALL_OW 483
// Wait ( 0 0$01 ) ;
4566: LD_INT 35
4568: PPUSH
4569: CALL_OW 67
// RemoveUnit ( potter ) ;
4573: LD_EXP 4
4577: PPUSH
4578: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4582: LD_EXP 2
4586: PPUSH
4587: LD_STRING DA-5
4589: PPUSH
4590: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4594: LD_EXP 3
4598: PPUSH
4599: LD_STRING DA-6
4601: PPUSH
4602: CALL_OW 88
// Wait ( 0 0$02 ) ;
4606: LD_INT 70
4608: PPUSH
4609: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4613: LD_INT 25
4615: PPUSH
4616: LD_INT 19
4618: PPUSH
4619: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4623: LD_INT 30
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL 3501 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4633: LD_EXP 5
4637: PPUSH
4638: LD_STRING DLa-1
4640: PPUSH
4641: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4645: LD_EXP 1
4649: PPUSH
4650: LD_STRING DL-5
4652: PPUSH
4653: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4657: LD_INT 23
4659: PPUSH
4660: CALL_OW 87
// InGameOff ;
4664: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4668: LD_STRING C1
4670: PPUSH
4671: CALL_OW 337
// alert := true ;
4675: LD_ADDR_EXP 6
4679: PUSH
4680: LD_INT 1
4682: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4683: LD_EXP 5
4687: PPUSH
4688: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4692: LD_EXP 5
4696: PPUSH
4697: LD_INT 11
4699: PPUSH
4700: CALL_OW 173
// Wait ( 0 0$30 ) ;
4704: LD_INT 1050
4706: PPUSH
4707: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4711: LD_INT 20
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL 3501 0 2
// Wait ( 0 0$35 ) ;
4721: LD_INT 1225
4723: PPUSH
4724: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4728: LD_INT 20
4730: PPUSH
4731: LD_INT 5
4733: PPUSH
4734: CALL 3501 0 2
// Wait ( 0 0$03 ) ;
4738: LD_INT 105
4740: PPUSH
4741: CALL_OW 67
// Game ;
4745: CALL 3253 0 0
// end ;
4749: LD_VAR 0 1
4753: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4754: LD_INT 22
4756: PUSH
4757: LD_INT 7
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PPUSH
4764: CALL_OW 69
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: PUSH
4773: LD_EXP 8
4777: PUSH
4778: LD_INT 500
4780: GREATEREQUAL
4781: AND
4782: IFFALSE 4993
4784: GO 4786
4786: DISABLE
4787: LD_INT 0
4789: PPUSH
4790: PPUSH
// begin DialogueOn ;
4791: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4795: LD_EXP 10
4799: PPUSH
4800: LD_STRING DVr-1
4802: PPUSH
4803: CALL_OW 94
// DialogueOff ;
4807: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4811: LD_STRING QBonusInfo
4813: PPUSH
4814: CALL_OW 97
4818: PUSH
4819: LD_INT 1
4821: DOUBLE
4822: EQUAL
4823: IFTRUE 4827
4825: GO 4838
4827: POP
// bonus_active := true ; end ;
4828: LD_ADDR_EXP 11
4832: PUSH
4833: LD_INT 1
4835: ST_TO_ADDR
4836: GO 4839
4838: POP
// bonus_num := 4 ;
4839: LD_ADDR_EXP 12
4843: PUSH
4844: LD_INT 4
4846: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4847: LD_OWVAR 2
4851: PPUSH
4852: LD_INT 2
4854: PPUSH
4855: LD_INT 2
4857: PPUSH
4858: LD_INT 23
4860: PPUSH
4861: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4865: LD_ADDR_VAR 0 1
4869: PUSH
4870: LD_INT 500
4872: PUSH
4873: LD_INT 3500
4875: PUSH
4876: LD_INT 5750
4878: PUSH
4879: LD_INT 10000
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: ST_TO_ADDR
// repeat wait ( 5 5$00 ) ;
4888: LD_INT 10500
4890: PPUSH
4891: CALL_OW 67
// for i = 1 to tmp do
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: DOUBLE
4901: LD_INT 1
4903: DEC
4904: ST_TO_ADDR
4905: LD_VAR 0 1
4909: PUSH
4910: FOR_TO
4911: IFFALSE 4943
// if points >= tmp [ i ] then
4913: LD_EXP 8
4917: PUSH
4918: LD_VAR 0 1
4922: PUSH
4923: LD_VAR 0 2
4927: ARRAY
4928: GREATEREQUAL
4929: IFFALSE 4941
// bonus_num := i ;
4931: LD_ADDR_EXP 12
4935: PUSH
4936: LD_VAR 0 2
4940: ST_TO_ADDR
4941: GO 4910
4943: POP
4944: POP
// case Query ( QBonusInfo ) of 1 :
4945: LD_STRING QBonusInfo
4947: PPUSH
4948: CALL_OW 97
4952: PUSH
4953: LD_INT 1
4955: DOUBLE
4956: EQUAL
4957: IFTRUE 4961
4959: GO 4982
4961: POP
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ; end ;
4962: LD_OWVAR 2
4966: PPUSH
4967: LD_INT 2
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 23
4975: PPUSH
4976: CALL_OW 468
4980: GO 4983
4982: POP
// until points >= 15000 ;
4983: LD_EXP 8
4987: PUSH
4988: LD_INT 15000
4990: GREATEREQUAL
4991: IFFALSE 4888
// end ; end_of_file
4993: PPOPN 2
4995: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
4996: LD_INT 0
4998: PPUSH
4999: PPUSH
// dir := GetDir ( b ) ;
5000: LD_ADDR_VAR 0 4
5004: PUSH
5005: LD_VAR 0 2
5009: PPUSH
5010: CALL_OW 254
5014: ST_TO_ADDR
// if dir < 3 then
5015: LD_VAR 0 4
5019: PUSH
5020: LD_INT 3
5022: LESS
5023: IFFALSE 5041
// dir := dir + 3 else
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: LD_VAR 0 4
5034: PUSH
5035: LD_INT 3
5037: PLUS
5038: ST_TO_ADDR
5039: GO 5055
// dir := dir - 3 ;
5041: LD_ADDR_VAR 0 4
5045: PUSH
5046: LD_VAR 0 4
5050: PUSH
5051: LD_INT 3
5053: MINUS
5054: ST_TO_ADDR
// SetDir ( un , dir ) ;
5055: LD_VAR 0 1
5059: PPUSH
5060: LD_VAR 0 4
5064: PPUSH
5065: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5069: LD_VAR 0 1
5073: PPUSH
5074: LD_VAR 0 2
5078: PPUSH
5079: CALL_OW 52
// end ;
5083: LD_VAR 0 3
5087: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5088: LD_INT 0
5090: PPUSH
5091: PPUSH
5092: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5093: LD_ADDR_VAR 0 7
5097: PUSH
5098: LD_VAR 0 1
5102: PUSH
5103: LD_VAR 0 2
5107: ARRAY
5108: PPUSH
5109: LD_VAR 0 3
5113: PPUSH
5114: LD_VAR 0 4
5118: PPUSH
5119: CALL_OW 1
5123: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5124: LD_ADDR_VAR 0 1
5128: PUSH
5129: LD_VAR 0 1
5133: PPUSH
5134: LD_VAR 0 2
5138: PPUSH
5139: LD_VAR 0 7
5143: PPUSH
5144: CALL_OW 1
5148: ST_TO_ADDR
// result := tab ;
5149: LD_ADDR_VAR 0 5
5153: PUSH
5154: LD_VAR 0 1
5158: ST_TO_ADDR
// end ;
5159: LD_VAR 0 5
5163: RET
// export function IsDriver ( unit ) ; begin
5164: LD_INT 0
5166: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5167: LD_VAR 0 1
5171: PUSH
5172: LD_INT 55
5174: PUSH
5175: EMPTY
5176: LIST
5177: PPUSH
5178: CALL_OW 69
5182: IN
5183: IFFALSE 5202
// result := IsInUnit ( unit ) else
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: LD_VAR 0 1
5194: PPUSH
5195: CALL_OW 310
5199: ST_TO_ADDR
5200: GO 5210
// result := false ;
5202: LD_ADDR_VAR 0 2
5206: PUSH
5207: LD_INT 0
5209: ST_TO_ADDR
// end ;
5210: LD_VAR 0 2
5214: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5215: LD_INT 0
5217: PPUSH
5218: PPUSH
5219: PPUSH
// if not GetControl ( veh ) = control_manual then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 263
5229: PUSH
5230: LD_INT 1
5232: EQUAL
5233: NOT
5234: IFFALSE 5246
// result := false else
5236: LD_ADDR_VAR 0 2
5240: PUSH
5241: LD_INT 0
5243: ST_TO_ADDR
5244: GO 5391
// if veh in FilterAllUnits ( [ f_empty ] ) then
5246: LD_VAR 0 1
5250: PUSH
5251: LD_INT 58
5253: PUSH
5254: EMPTY
5255: LIST
5256: PPUSH
5257: CALL_OW 69
5261: IN
5262: IFFALSE 5274
// result := false else
5264: LD_ADDR_VAR 0 2
5268: PUSH
5269: LD_INT 0
5271: ST_TO_ADDR
5272: GO 5391
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5274: LD_ADDR_VAR 0 4
5278: PUSH
5279: LD_INT 22
5281: PUSH
5282: LD_VAR 0 1
5286: PPUSH
5287: CALL_OW 255
5291: PUSH
5292: EMPTY
5293: LIST
5294: LIST
5295: PUSH
5296: LD_INT 55
5298: PUSH
5299: EMPTY
5300: LIST
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PPUSH
5306: CALL_OW 69
5310: ST_TO_ADDR
// if not filter then
5311: LD_VAR 0 4
5315: NOT
5316: IFFALSE 5328
// result := false else
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_INT 0
5325: ST_TO_ADDR
5326: GO 5391
// for i = 1 to filter do
5328: LD_ADDR_VAR 0 3
5332: PUSH
5333: DOUBLE
5334: LD_INT 1
5336: DEC
5337: ST_TO_ADDR
5338: LD_VAR 0 4
5342: PUSH
5343: FOR_TO
5344: IFFALSE 5389
// if IsDriver ( filter [ i ] ) = veh then
5346: LD_VAR 0 4
5350: PUSH
5351: LD_VAR 0 3
5355: ARRAY
5356: PPUSH
5357: CALL 5164 0 1
5361: PUSH
5362: LD_VAR 0 1
5366: EQUAL
5367: IFFALSE 5387
// begin result := filter [ i ] ;
5369: LD_ADDR_VAR 0 2
5373: PUSH
5374: LD_VAR 0 4
5378: PUSH
5379: LD_VAR 0 3
5383: ARRAY
5384: ST_TO_ADDR
// break ;
5385: GO 5389
// end ;
5387: GO 5343
5389: POP
5390: POP
// end ; end ; end_of_file
5391: LD_VAR 0 2
5395: RET
// on UnitDestroyed ( un ) do begin if un in [ legion_commander , main_base ] then
5396: LD_VAR 0 1
5400: PUSH
5401: LD_EXP 1
5405: PUSH
5406: LD_INT 23
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: IN
5413: IFFALSE 5423
// game_over := true ;
5415: LD_ADDR_EXP 7
5419: PUSH
5420: LD_INT 1
5422: ST_TO_ADDR
// if un = al_commander then
5423: LD_VAR 0 1
5427: PUSH
5428: LD_EXP 5
5432: EQUAL
5433: IFFALSE 5439
// ChangeSide ( ) ;
5435: CALL 2674 0 0
// if GetSide ( un ) = 7 then
5439: LD_VAR 0 1
5443: PPUSH
5444: CALL_OW 255
5448: PUSH
5449: LD_INT 7
5451: EQUAL
5452: IFFALSE 5570
// begin if GetClass ( un ) = class_apeman then
5454: LD_VAR 0 1
5458: PPUSH
5459: CALL_OW 257
5463: PUSH
5464: LD_INT 12
5466: EQUAL
5467: IFFALSE 5483
// points := points + 6 ;
5469: LD_ADDR_EXP 8
5473: PUSH
5474: LD_EXP 8
5478: PUSH
5479: LD_INT 6
5481: PLUS
5482: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5483: LD_VAR 0 1
5487: PPUSH
5488: CALL_OW 257
5492: PUSH
5493: LD_INT 17
5495: EQUAL
5496: IFFALSE 5512
// points := points + 11 ;
5498: LD_ADDR_EXP 8
5502: PUSH
5503: LD_EXP 8
5507: PUSH
5508: LD_INT 11
5510: PLUS
5511: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5512: LD_VAR 0 1
5516: PPUSH
5517: CALL_OW 257
5521: PUSH
5522: LD_INT 15
5524: EQUAL
5525: IFFALSE 5541
// points := points + 14 ;
5527: LD_ADDR_EXP 8
5531: PUSH
5532: LD_EXP 8
5536: PUSH
5537: LD_INT 14
5539: PLUS
5540: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5541: LD_VAR 0 1
5545: PPUSH
5546: CALL_OW 247
5550: PUSH
5551: LD_INT 2
5553: EQUAL
5554: IFFALSE 5570
// points := points + 50 ;
5556: LD_ADDR_EXP 8
5560: PUSH
5561: LD_EXP 8
5565: PUSH
5566: LD_INT 50
5568: PLUS
5569: ST_TO_ADDR
// end ; end ;
5570: PPOPN 1
5572: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5573: LD_EXP 5
5577: PPUSH
5578: CALL_OW 256
5582: PUSH
5583: LD_INT 1000
5585: LESS
5586: IFFALSE 5618
5588: GO 5590
5590: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5591: LD_EXP 5
5595: PPUSH
5596: CALL_OW 504
5600: PPUSH
5601: CALL_OW 255
5605: PUSH
5606: LD_INT 8
5608: EQUAL
5609: IFFALSE 5618
// YouLost (  ) ;
5611: LD_STRING 
5613: PPUSH
5614: CALL_OW 104
5618: END
// on EnterBuilding ( b , un ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] and GetClass ( un ) in [ class_apeman , class_apeman_soldier , class_apeman_kamikaze ] then
5619: LD_VAR 0 1
5623: PPUSH
5624: CALL_OW 266
5628: PUSH
5629: LD_INT 0
5631: PUSH
5632: LD_INT 1
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: IN
5639: PUSH
5640: LD_VAR 0 2
5644: PPUSH
5645: CALL_OW 257
5649: PUSH
5650: LD_INT 12
5652: PUSH
5653: LD_INT 15
5655: PUSH
5656: LD_INT 17
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: LIST
5663: IN
5664: AND
5665: IFFALSE 5686
// begin wait ( 0 0$0.3 ) ;
5667: LD_INT 10
5669: PPUSH
5670: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
5674: LD_VAR 0 2
5678: PPUSH
5679: LD_INT 16
5681: PPUSH
5682: CALL_OW 336
// end ; end ;
5686: PPOPN 2
5688: END
// on DialogueSkipped ( value ) do var i ;
5689: LD_INT 0
5691: PPUSH
// begin RemoveUnit ( potter ) ;
5692: LD_EXP 4
5696: PPUSH
5697: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5701: LD_EXP 2
5705: PUSH
5706: LD_EXP 3
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PPUSH
5715: CALL_OW 122
// Wait ( 1 ) ;
5719: LD_INT 1
5721: PPUSH
5722: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5726: LD_EXP 2
5730: PPUSH
5731: LD_INT 107
5733: PPUSH
5734: LD_INT 53
5736: PPUSH
5737: LD_INT 0
5739: PPUSH
5740: LD_INT 0
5742: PPUSH
5743: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5747: LD_EXP 3
5751: PPUSH
5752: LD_INT 108
5754: PPUSH
5755: LD_INT 53
5757: PPUSH
5758: LD_INT 0
5760: PPUSH
5761: LD_INT 0
5763: PPUSH
5764: CALL_OW 483
// Wait ( 1 ) ;
5768: LD_INT 1
5770: PPUSH
5771: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5775: LD_EXP 2
5779: PUSH
5780: LD_EXP 3
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PPUSH
5789: LD_INT 108
5791: PPUSH
5792: LD_INT 1
5794: PPUSH
5795: CALL_OW 118
// end ;
5799: PPOPN 2
5801: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5802: LD_INT 0
5804: PPUSH
5805: PPUSH
5806: PPUSH
5807: PPUSH
5808: PPUSH
5809: PPUSH
// begin uc_side := 8 ;
5810: LD_ADDR_OWVAR 20
5814: PUSH
5815: LD_INT 8
5817: ST_TO_ADDR
// uc_nation := 2 ;
5818: LD_ADDR_OWVAR 21
5822: PUSH
5823: LD_INT 2
5825: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5826: LD_ADDR_VAR 0 5
5830: PUSH
5831: LD_STRING QBonus
5833: PUSH
5834: LD_EXP 12
5838: STR
5839: ST_TO_ADDR
// off := true ;
5840: LD_ADDR_VAR 0 6
5844: PUSH
5845: LD_INT 1
5847: ST_TO_ADDR
// units := [ ] ;
5848: LD_ADDR_VAR 0 7
5852: PUSH
5853: EMPTY
5854: ST_TO_ADDR
// crates := 0 ;
5855: LD_ADDR_VAR 0 8
5859: PUSH
5860: LD_INT 0
5862: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5863: LD_EXP 10
5867: PPUSH
5868: LD_STRING DVr-2
5870: PPUSH
5871: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5875: LD_INT 10
5877: PPUSH
5878: CALL_OW 67
// case Query ( bonus ) of 1 :
5882: LD_VAR 0 5
5886: PPUSH
5887: CALL_OW 97
5891: PUSH
5892: LD_INT 1
5894: DOUBLE
5895: EQUAL
5896: IFTRUE 5900
5898: GO 5985
5900: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5901: LD_ADDR_VAR 0 9
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 5
5914: PUSH
5915: LD_INT 8
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: LD_EXP 12
5928: ARRAY
5929: ST_TO_ADDR
// for i = 1 to tmp do
5930: LD_ADDR_VAR 0 10
5934: PUSH
5935: DOUBLE
5936: LD_INT 1
5938: DEC
5939: ST_TO_ADDR
5940: LD_VAR 0 9
5944: PUSH
5945: FOR_TO
5946: IFFALSE 5981
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5948: LD_INT 0
5950: PPUSH
5951: LD_INT 15
5953: PPUSH
5954: LD_VAR 0 9
5958: PPUSH
5959: CALL_OW 380
// units := units ^ CreateHuman ;
5963: LD_ADDR_VAR 0 7
5967: PUSH
5968: LD_VAR 0 7
5972: PUSH
5973: CALL_OW 44
5977: ADD
5978: ST_TO_ADDR
// end ;
5979: GO 5945
5981: POP
5982: POP
// end ; 2 :
5983: GO 6393
5985: LD_INT 2
5987: DOUBLE
5988: EQUAL
5989: IFTRUE 5993
5991: GO 6025
5993: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
5994: LD_ADDR_VAR 0 8
5998: PUSH
5999: LD_INT 100
6001: PUSH
6002: LD_INT 150
6004: PUSH
6005: LD_INT 350
6007: PUSH
6008: LD_INT 500
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: LD_EXP 12
6021: ARRAY
6022: ST_TO_ADDR
// end ; 3 :
6023: GO 6393
6025: LD_INT 3
6027: DOUBLE
6028: EQUAL
6029: IFTRUE 6033
6031: GO 6373
6033: POP
// begin if bonus_num = 1 then
6034: LD_EXP 12
6038: PUSH
6039: LD_INT 1
6041: EQUAL
6042: IFFALSE 6052
// ignore_wave := true ;
6044: LD_ADDR_EXP 13
6048: PUSH
6049: LD_INT 1
6051: ST_TO_ADDR
// if bonus_num = 2 then
6052: LD_EXP 12
6056: PUSH
6057: LD_INT 2
6059: EQUAL
6060: IFFALSE 6180
// begin for i = 1 to 2 do
6062: LD_ADDR_VAR 0 10
6066: PUSH
6067: DOUBLE
6068: LD_INT 1
6070: DEC
6071: ST_TO_ADDR
6072: LD_INT 2
6074: PUSH
6075: FOR_TO
6076: IFFALSE 6178
// begin uc_nation := nation_arabian ;
6078: LD_ADDR_OWVAR 21
6082: PUSH
6083: LD_INT 2
6085: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6086: LD_ADDR_OWVAR 37
6090: PUSH
6091: LD_INT 14
6093: ST_TO_ADDR
// vc_engine := engine_siberite ;
6094: LD_ADDR_OWVAR 39
6098: PUSH
6099: LD_INT 3
6101: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6102: LD_ADDR_OWVAR 38
6106: PUSH
6107: LD_INT 2
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 1
6119: PPUSH
6120: LD_INT 2
6122: PPUSH
6123: CALL_OW 12
6127: ARRAY
6128: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6129: LD_ADDR_OWVAR 40
6133: PUSH
6134: LD_INT 28
6136: PUSH
6137: LD_INT 27
6139: PUSH
6140: LD_INT 25
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 1
6150: PPUSH
6151: LD_INT 3
6153: PPUSH
6154: CALL_OW 12
6158: ARRAY
6159: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6160: LD_ADDR_VAR 0 7
6164: PUSH
6165: LD_VAR 0 7
6169: PUSH
6170: CALL_OW 45
6174: ADD
6175: ST_TO_ADDR
// end ;
6176: GO 6075
6178: POP
6179: POP
// end ; if bonus_num = 3 then
6180: LD_EXP 12
6184: PUSH
6185: LD_INT 3
6187: EQUAL
6188: IFFALSE 6312
// begin for i = 1 to 4 do
6190: LD_ADDR_VAR 0 10
6194: PUSH
6195: DOUBLE
6196: LD_INT 1
6198: DEC
6199: ST_TO_ADDR
6200: LD_INT 4
6202: PUSH
6203: FOR_TO
6204: IFFALSE 6310
// begin uc_nation := nation_arabian ;
6206: LD_ADDR_OWVAR 21
6210: PUSH
6211: LD_INT 2
6213: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6214: LD_ADDR_OWVAR 37
6218: PUSH
6219: LD_INT 14
6221: ST_TO_ADDR
// vc_engine := engine_siberite ;
6222: LD_ADDR_OWVAR 39
6226: PUSH
6227: LD_INT 3
6229: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6230: LD_ADDR_OWVAR 38
6234: PUSH
6235: LD_INT 2
6237: PUSH
6238: LD_INT 5
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 1
6247: PPUSH
6248: LD_INT 2
6250: PPUSH
6251: CALL_OW 12
6255: ARRAY
6256: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6257: LD_ADDR_OWVAR 40
6261: PUSH
6262: LD_INT 28
6264: PUSH
6265: LD_INT 27
6267: PUSH
6268: LD_INT 28
6270: PUSH
6271: LD_INT 25
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 1
6282: PPUSH
6283: LD_INT 4
6285: PPUSH
6286: CALL_OW 12
6290: ARRAY
6291: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6292: LD_ADDR_VAR 0 7
6296: PUSH
6297: LD_VAR 0 7
6301: PUSH
6302: CALL_OW 45
6306: ADD
6307: ST_TO_ADDR
// end ;
6308: GO 6203
6310: POP
6311: POP
// end ; if bonus_num = 4 then
6312: LD_EXP 12
6316: PUSH
6317: LD_INT 4
6319: EQUAL
6320: IFFALSE 6371
// for i = 1 to 3 do
6322: LD_ADDR_VAR 0 10
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 3
6334: PUSH
6335: FOR_TO
6336: IFFALSE 6369
// begin PrepareHuman ( false , 3 , 8 ) ;
6338: LD_INT 0
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: LD_INT 8
6346: PPUSH
6347: CALL_OW 380
// units := units ^ CreateHuman ;
6351: LD_ADDR_VAR 0 7
6355: PUSH
6356: LD_VAR 0 7
6360: PUSH
6361: CALL_OW 44
6365: ADD
6366: ST_TO_ADDR
// end ;
6367: GO 6335
6369: POP
6370: POP
// end ; 4 :
6371: GO 6393
6373: LD_INT 4
6375: DOUBLE
6376: EQUAL
6377: IFTRUE 6381
6379: GO 6392
6381: POP
// off := false ; end ;
6382: LD_ADDR_VAR 0 6
6386: PUSH
6387: LD_INT 0
6389: ST_TO_ADDR
6390: GO 6393
6392: POP
// if not off then
6393: LD_VAR 0 6
6397: NOT
6398: IFFALSE 6404
// exit else
6400: GO 6583
6402: GO 6457
// begin SetArtifactUse ( your_side , art_exp_mid , art_no , main_base ) ;
6404: LD_OWVAR 2
6408: PPUSH
6409: LD_INT 2
6411: PPUSH
6412: LD_INT 0
6414: PPUSH
6415: LD_INT 23
6417: PPUSH
6418: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6422: LD_EXP 10
6426: PPUSH
6427: LD_STRING DVr-3
6429: PUSH
6430: LD_STRING DVr-3a
6432: PUSH
6433: LD_STRING DVr-3b
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: PUSH
6441: LD_INT 1
6443: PPUSH
6444: LD_INT 3
6446: PPUSH
6447: CALL_OW 12
6451: ARRAY
6452: PPUSH
6453: CALL_OW 94
// end ; if units then
6457: LD_VAR 0 7
6461: IFFALSE 6525
// for i in units do
6463: LD_ADDR_VAR 0 10
6467: PUSH
6468: LD_VAR 0 7
6472: PUSH
6473: FOR_IN
6474: IFFALSE 6523
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6476: LD_VAR 0 10
6480: PPUSH
6481: LD_INT 92
6483: PPUSH
6484: LD_INT 49
6486: PPUSH
6487: LD_INT 20
6489: PPUSH
6490: LD_INT 0
6492: PPUSH
6493: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6497: LD_VAR 0 10
6501: PPUSH
6502: CALL_OW 250
6506: PPUSH
6507: LD_VAR 0 10
6511: PPUSH
6512: CALL_OW 251
6516: PPUSH
6517: CALL_OW 494
// end ;
6521: GO 6473
6523: POP
6524: POP
// if crates then
6525: LD_VAR 0 8
6529: IFFALSE 6583
// for i = 1 to ( crates div 50 ) do
6531: LD_ADDR_VAR 0 10
6535: PUSH
6536: DOUBLE
6537: LD_INT 1
6539: DEC
6540: ST_TO_ADDR
6541: LD_VAR 0 8
6545: PUSH
6546: LD_INT 50
6548: DIV
6549: PUSH
6550: FOR_TO
6551: IFFALSE 6581
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 92
6558: PPUSH
6559: LD_INT 49
6561: PPUSH
6562: LD_INT 30
6564: PPUSH
6565: LD_INT 1
6567: PPUSH
6568: CALL_OW 56
// wait ( 0 0$02 ) ;
6572: LD_INT 70
6574: PPUSH
6575: CALL_OW 67
// end ;
6579: GO 6550
6581: POP
6582: POP
// end ; end_of_file
6583: PPOPN 10
6585: END
// every 0 0$01 trigger not game_over do
6586: LD_EXP 7
6590: NOT
6591: IFFALSE 6624
6593: GO 6595
6595: DISABLE
// begin enable ;
6596: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6597: LD_ADDR_OWVAR 47
6601: PUSH
6602: LD_STRING #tick
6604: PUSH
6605: LD_OWVAR 1
6609: PUSH
6610: LD_STRING #points
6612: PUSH
6613: LD_EXP 8
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: ST_TO_ADDR
// end ;
6624: END
// every 0 0$01 trigger game_over do
6625: LD_EXP 7
6629: IFFALSE 6688
6631: GO 6633
6633: DISABLE
// begin Wait ( 0 0$02 ) ;
6634: LD_INT 70
6636: PPUSH
6637: CALL_OW 67
// DialogueOn ;
6641: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6645: LD_ADDR_OWVAR 47
6649: PUSH
6650: LD_STRING #game-points
6652: PUSH
6653: LD_OWVAR 78
6657: PUSH
6658: LD_EXP 8
6662: PUSH
6663: LD_STRING #game-time
6665: PUSH
6666: LD_OWVAR 1
6670: PUSH
6671: LD_STRING #game-difficulty
6673: PUSH
6674: LD_OWVAR 67
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: ST_TO_ADDR
// end ; end_of_file
6688: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6689: LD_OWVAR 1
6693: PUSH
6694: LD_INT 52500
6696: LESS
6697: IFFALSE 6721
6699: GO 6701
6701: DISABLE
// begin enable ;
6702: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6703: LD_INT 1
6705: PPUSH
6706: LD_INT 5
6708: PPUSH
6709: CALL_OW 12
6713: PPUSH
6714: LD_INT 1
6716: PPUSH
6717: CALL_OW 57
// end ;
6721: END
