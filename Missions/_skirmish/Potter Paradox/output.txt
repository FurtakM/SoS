// starting begin ResetFog ;
   0: CALL_OW 335
// InitGame ;
   4: CALL 21 0 0
// PrepareLegion ;
   8: CALL 181 0 0
// PrepareAllies ;
  12: CALL 2172 0 0
// Action ;
  16: CALL 4314 0 0
// end ;
  20: END
// function InitGame ; begin
  21: LD_INT 0
  23: PPUSH
// RandomizeAll ;
  24: CALL_OW 11
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 0
  35: PPUSH
  36: CALL_OW 426
  40: ST_TO_ADDR
// if not Difficulty then
  41: LD_OWVAR 67
  45: NOT
  46: IFFALSE 56
// Difficulty := 2 ;
  48: LD_ADDR_OWVAR 67
  52: PUSH
  53: LD_INT 2
  55: ST_TO_ADDR
// InitVariables ;
  56: CALL 69 0 0
// SetDiplomacy ;
  60: CALL 133 0 0
// end ; end_of_file
  64: LD_VAR 0 1
  68: RET
// export legion_commander , l1 , l2 , potter , al_commander , alert , game_over , points , wave_time , Vervecken , bonus_active , bonus_num , ignore_wave ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// points := 0 ;
  72: LD_ADDR_EXP 8
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// alert := false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// game_over := false ;
  88: LD_ADDR_EXP 7
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// wave_time := 0 0$00 ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// bonus_active := false ;
 104: LD_ADDR_EXP 11
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ignore_wave := false ;
 112: LD_ADDR_EXP 13
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// bonus_num := 0 ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// end ;
 128: LD_VAR 0 1
 132: RET
// export function SetDiplomacy ; begin
 133: LD_INT 0
 135: PPUSH
// PlaceSeeing ( 92 , 48 , 8 , - 32796 ) ;
 136: LD_INT 92
 138: PPUSH
 139: LD_INT 48
 141: PPUSH
 142: LD_INT 8
 144: PPUSH
 145: LD_INT 32796
 147: NEG
 148: PPUSH
 149: CALL_OW 330
// RemoveSeeing ( 92 , 48 , 8 ) ;
 153: LD_INT 92
 155: PPUSH
 156: LD_INT 48
 158: PPUSH
 159: LD_INT 8
 161: PPUSH
 162: CALL_OW 331
// ChangeSideFog ( 5 , 8 ) ;
 166: LD_INT 5
 168: PPUSH
 169: LD_INT 8
 171: PPUSH
 172: CALL_OW 343
// end ; end_of_file
 176: LD_VAR 0 1
 180: RET
// export function PrepareLegion ; var i , k , class , b , un , team , skill , sold_num , eng_num , mech_num , sci_num , ape_num , dep_x , dep_y , weapons , weapon , vehicles ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
 198: PPUSH
 199: PPUSH
 200: PPUSH
// uc_side := 2 ;
 201: LD_ADDR_OWVAR 20
 205: PUSH
 206: LD_INT 2
 208: ST_TO_ADDR
// uc_nation := nation_arabian ;
 209: LD_ADDR_OWVAR 21
 213: PUSH
 214: LD_INT 2
 216: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 1
 222: PPUSH
 223: LD_INT 6
 225: PPUSH
 226: CALL_OW 380
// hc_name := Nicolas Vervecken ;
 230: LD_ADDR_OWVAR 26
 234: PUSH
 235: LD_STRING Nicolas Vervecken
 237: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 238: LD_ADDR_OWVAR 33
 242: PUSH
 243: LD_STRING SecondCharsGal
 245: ST_TO_ADDR
// hc_face_number := 3 ;
 246: LD_ADDR_OWVAR 34
 250: PUSH
 251: LD_INT 3
 253: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
 254: LD_ADDR_OWVAR 29
 258: PUSH
 259: LD_INT 11
 261: PUSH
 262: LD_INT 10
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: ST_TO_ADDR
// Vervecken := CreateHuman ;
 269: LD_ADDR_EXP 10
 273: PUSH
 274: CALL_OW 44
 278: ST_TO_ADDR
// InitHc ;
 279: CALL_OW 19
// uc_side := 8 ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_INT 8
 290: ST_TO_ADDR
// SetResourceType ( GetBase ( main_base ) , mat_cans , [ 4000 , 2500 , 1250 ] [ Difficulty ] ) ;
 291: LD_INT 23
 293: PPUSH
 294: CALL_OW 274
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 4000
 304: PUSH
 305: LD_INT 2500
 307: PUSH
 308: LD_INT 1250
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_OWVAR 67
 320: ARRAY
 321: PPUSH
 322: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_oil , 300 ) ;
 326: LD_INT 23
 328: PPUSH
 329: CALL_OW 274
 333: PPUSH
 334: LD_INT 2
 336: PPUSH
 337: LD_INT 300
 339: PPUSH
 340: CALL_OW 277
// SetResourceType ( GetBase ( main_base ) , mat_siberit , [ 100 , 50 , 30 ] [ Difficulty ] ) ;
 344: LD_INT 23
 346: PPUSH
 347: CALL_OW 274
 351: PPUSH
 352: LD_INT 3
 354: PPUSH
 355: LD_INT 100
 357: PUSH
 358: LD_INT 50
 360: PUSH
 361: LD_INT 30
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: PUSH
 369: LD_OWVAR 67
 373: ARRAY
 374: PPUSH
 375: CALL_OW 277
// dep_x := GetX ( main_base ) ;
 379: LD_ADDR_VAR 0 14
 383: PUSH
 384: LD_INT 23
 386: PPUSH
 387: CALL_OW 250
 391: ST_TO_ADDR
// dep_y := GetY ( main_base ) ;
 392: LD_ADDR_VAR 0 15
 396: PUSH
 397: LD_INT 23
 399: PPUSH
 400: CALL_OW 251
 404: ST_TO_ADDR
// team := [ ] ;
 405: LD_ADDR_VAR 0 7
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
 412: LD_ADDR_VAR 0 8
 416: PUSH
 417: LD_INT 9
 419: PUSH
 420: LD_INT 8
 422: PUSH
 423: LD_INT 7
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_OWVAR 67
 435: ARRAY
 436: ST_TO_ADDR
// sold_num := [ 11 , 9 , 8 ] [ Difficulty ] ;
 437: LD_ADDR_VAR 0 9
 441: PUSH
 442: LD_INT 11
 444: PUSH
 445: LD_INT 9
 447: PUSH
 448: LD_INT 8
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_OWVAR 67
 460: ARRAY
 461: ST_TO_ADDR
// eng_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 462: LD_ADDR_VAR 0 10
 466: PUSH
 467: LD_INT 3
 469: PUSH
 470: LD_INT 2
 472: PUSH
 473: LD_INT 2
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: PUSH
 481: LD_OWVAR 67
 485: ARRAY
 486: ST_TO_ADDR
// mech_num := [ 5 , 4 , 3 ] [ Difficulty ] ;
 487: LD_ADDR_VAR 0 11
 491: PUSH
 492: LD_INT 5
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: PUSH
 506: LD_OWVAR 67
 510: ARRAY
 511: ST_TO_ADDR
// sci_num := [ 3 , 2 , 2 ] [ Difficulty ] ;
 512: LD_ADDR_VAR 0 12
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 2
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: ST_TO_ADDR
// ape_num := [ 6 , 5 , 4 ] [ Difficulty ] ;
 537: LD_ADDR_VAR 0 13
 541: PUSH
 542: LD_INT 6
 544: PUSH
 545: LD_INT 5
 547: PUSH
 548: LD_INT 4
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: ST_TO_ADDR
// vehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower ] , [ ar_half_tracked , engine_siberite , control_manual , ar_gatling_gun ] , [ ar_half_tracked , engine_siberite , control_apeman , ar_cargo_bay ] , [ ar_half_tracked , engine_siberite , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_siberite , control_remote , ar_double_machine_gun ] , [ ar_half_tracked , engine_siberite , control_remote , ar_gatling_gun ] , [ ar_medium_trike , engine_siberite , control_manual , ar_double_machine_gun ] ] ;
 562: LD_ADDR_VAR 0 18
 566: PUSH
 567: LD_INT 13
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 26
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 14
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 25
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 14
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 5
 611: PUSH
 612: LD_INT 32
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 14
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 31
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 14
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 14
 659: PUSH
 660: LD_INT 3
 662: PUSH
 663: LD_INT 2
 665: PUSH
 666: LD_INT 25
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 13
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: ST_TO_ADDR
// for i = 1 to vehicles - Difficulty + 1 do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 18
 716: PUSH
 717: LD_OWVAR 67
 721: MINUS
 722: PUSH
 723: LD_INT 1
 725: PLUS
 726: PUSH
 727: FOR_TO
 728: IFFALSE 857
// begin vc_chassis := vehicles [ i ] [ 1 ] ;
 730: LD_ADDR_OWVAR 37
 734: PUSH
 735: LD_VAR 0 18
 739: PUSH
 740: LD_VAR 0 2
 744: ARRAY
 745: PUSH
 746: LD_INT 1
 748: ARRAY
 749: ST_TO_ADDR
// vc_engine := vehicles [ i ] [ 2 ] ;
 750: LD_ADDR_OWVAR 39
 754: PUSH
 755: LD_VAR 0 18
 759: PUSH
 760: LD_VAR 0 2
 764: ARRAY
 765: PUSH
 766: LD_INT 2
 768: ARRAY
 769: ST_TO_ADDR
// vc_control := vehicles [ i ] [ 3 ] ;
 770: LD_ADDR_OWVAR 38
 774: PUSH
 775: LD_VAR 0 18
 779: PUSH
 780: LD_VAR 0 2
 784: ARRAY
 785: PUSH
 786: LD_INT 3
 788: ARRAY
 789: ST_TO_ADDR
// vc_weapon := vehicles [ i ] [ 4 ] ;
 790: LD_ADDR_OWVAR 40
 794: PUSH
 795: LD_VAR 0 18
 799: PUSH
 800: LD_VAR 0 2
 804: ARRAY
 805: PUSH
 806: LD_INT 4
 808: ARRAY
 809: ST_TO_ADDR
// un := CreateVehicle ;
 810: LD_ADDR_VAR 0 6
 814: PUSH
 815: CALL_OW 45
 819: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
 820: LD_VAR 0 6
 824: PPUSH
 825: LD_INT 0
 827: PPUSH
 828: LD_INT 5
 830: PPUSH
 831: CALL_OW 12
 835: PPUSH
 836: CALL_OW 233
// PlaceUnitArea ( un , parking , false ) ;
 840: LD_VAR 0 6
 844: PPUSH
 845: LD_INT 7
 847: PPUSH
 848: LD_INT 0
 850: PPUSH
 851: CALL_OW 49
// end ;
 855: GO 727
 857: POP
 858: POP
// for i = 1 to ape_num do
 859: LD_ADDR_VAR 0 2
 863: PUSH
 864: DOUBLE
 865: LD_INT 1
 867: DEC
 868: ST_TO_ADDR
 869: LD_VAR 0 13
 873: PUSH
 874: FOR_TO
 875: IFFALSE 942
// begin PrepareHuman ( false , [ class_apeman_engineer , class_apeman_soldier ] [ rand ( 1 , 2 ) ] , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_INT 16
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 1
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 8
 906: PPUSH
 907: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
 911: LD_ADDR_VAR 0 7
 915: PUSH
 916: LD_VAR 0 7
 920: PPUSH
 921: LD_VAR 0 7
 925: PUSH
 926: LD_INT 1
 928: PLUS
 929: PPUSH
 930: CALL_OW 44
 934: PPUSH
 935: CALL_OW 2
 939: ST_TO_ADDR
// end ;
 940: GO 874
 942: POP
 943: POP
// PrepareHuman ( sex_male , 1 , skill ) ;
 944: LD_INT 1
 946: PPUSH
 947: LD_INT 1
 949: PPUSH
 950: LD_VAR 0 8
 954: PPUSH
 955: CALL_OW 380
// l1 := CreateHuman ;
 959: LD_ADDR_EXP 2
 963: PUSH
 964: CALL_OW 44
 968: ST_TO_ADDR
// PlaceHumanInUnit ( l1 , main_base ) ;
 969: LD_EXP 2
 973: PPUSH
 974: LD_INT 23
 976: PPUSH
 977: CALL_OW 52
// PrepareHuman ( sex_male , 1 , skill ) ;
 981: LD_INT 1
 983: PPUSH
 984: LD_INT 1
 986: PPUSH
 987: LD_VAR 0 8
 991: PPUSH
 992: CALL_OW 380
// l2 := CreateHuman ;
 996: LD_ADDR_EXP 3
1000: PUSH
1001: CALL_OW 44
1005: ST_TO_ADDR
// PlaceHumanInUnit ( l2 , main_base ) ;
1006: LD_EXP 3
1010: PPUSH
1011: LD_INT 23
1013: PPUSH
1014: CALL_OW 52
// for class = 1 to 4 do
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: DOUBLE
1024: LD_INT 1
1026: DEC
1027: ST_TO_ADDR
1028: LD_INT 4
1030: PUSH
1031: FOR_TO
1032: IFFALSE 1131
// for i = 1 to [ sold_num , eng_num , mech_num , sci_num ] [ class ] do
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: DOUBLE
1040: LD_INT 1
1042: DEC
1043: ST_TO_ADDR
1044: LD_VAR 0 9
1048: PUSH
1049: LD_VAR 0 10
1053: PUSH
1054: LD_VAR 0 11
1058: PUSH
1059: LD_VAR 0 12
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_VAR 0 4
1074: ARRAY
1075: PUSH
1076: FOR_TO
1077: IFFALSE 1127
// begin PrepareHuman ( false , class , skill ) ;
1079: LD_INT 0
1081: PPUSH
1082: LD_VAR 0 4
1086: PPUSH
1087: LD_VAR 0 8
1091: PPUSH
1092: CALL_OW 380
// team := Insert ( team , team + 1 , CreateHuman ) ;
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 7
1105: PPUSH
1106: LD_VAR 0 7
1110: PUSH
1111: LD_INT 1
1113: PLUS
1114: PPUSH
1115: CALL_OW 44
1119: PPUSH
1120: CALL_OW 2
1124: ST_TO_ADDR
// end ;
1125: GO 1076
1127: POP
1128: POP
1129: GO 1031
1131: POP
1132: POP
// for i in team do
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 7
1142: PUSH
1143: FOR_IN
1144: IFFALSE 1620
// begin b := 0 ;
1146: LD_ADDR_VAR 0 5
1150: PUSH
1151: LD_INT 0
1153: ST_TO_ADDR
// case GetClass ( i ) of class_soldier :
1154: LD_VAR 0 2
1158: PPUSH
1159: CALL_OW 257
1163: PUSH
1164: LD_INT 1
1166: DOUBLE
1167: EQUAL
1168: IFTRUE 1172
1170: GO 1279
1172: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ;
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 22
1180: PUSH
1181: LD_OWVAR 20
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 2
1192: PUSH
1193: LD_INT 30
1195: PUSH
1196: LD_INT 32
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: LD_INT 30
1205: PUSH
1206: LD_INT 31
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 58
1220: PUSH
1221: EMPTY
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: ST_TO_ADDR
// if not b then
1234: LD_VAR 0 5
1238: NOT
1239: IFFALSE 1277
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
1241: LD_ADDR_VAR 0 5
1245: PUSH
1246: LD_INT 22
1248: PUSH
1249: LD_OWVAR 20
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// end ; class_engineer :
1277: GO 1518
1279: LD_INT 2
1281: DOUBLE
1282: EQUAL
1283: IFTRUE 1287
1285: GO 1326
1287: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_warehouse ] ] ) ; class_mechanic :
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_OWVAR 20
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 30
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
1324: GO 1518
1326: LD_INT 3
1328: DOUBLE
1329: EQUAL
1330: IFTRUE 1334
1332: GO 1423
1334: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1335: LD_ADDR_VAR 0 5
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_OWVAR 20
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 21
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 58
1364: PUSH
1365: EMPTY
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: ST_TO_ADDR
// if not b then
1378: LD_VAR 0 5
1382: NOT
1383: IFFALSE 1421
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_factory ] ] ) ;
1385: LD_ADDR_VAR 0 5
1389: PUSH
1390: LD_INT 22
1392: PUSH
1393: LD_OWVAR 20
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 30
1404: PUSH
1405: LD_INT 3
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL_OW 69
1420: ST_TO_ADDR
// end ; class_scientistic :
1421: GO 1518
1423: LD_INT 4
1425: DOUBLE
1426: EQUAL
1427: IFTRUE 1431
1429: GO 1470
1431: POP
// begin b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_lab_full ] ] ) ;
1432: LD_ADDR_VAR 0 5
1436: PUSH
1437: LD_INT 22
1439: PUSH
1440: LD_OWVAR 20
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PPUSH
1463: CALL_OW 69
1467: ST_TO_ADDR
// end ; class_apeman_soldier :
1468: GO 1518
1470: LD_INT 15
1472: DOUBLE
1473: EQUAL
1474: IFTRUE 1478
1476: GO 1517
1478: POP
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ; end ;
1479: LD_ADDR_VAR 0 5
1483: PUSH
1484: LD_INT 22
1486: PUSH
1487: LD_OWVAR 20
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 30
1498: PUSH
1499: LD_INT 5
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: ST_TO_ADDR
1515: GO 1518
1517: POP
// if b then
1518: LD_VAR 0 5
1522: IFFALSE 1593
// begin if GetBType ( b [ 1 ] ) = b_breastwork then
1524: LD_VAR 0 5
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: CALL_OW 266
1537: PUSH
1538: LD_INT 31
1540: EQUAL
1541: IFFALSE 1563
// PlaceHumanInBunker ( i , b [ 1 ] ) else
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_VAR 0 5
1552: PUSH
1553: LD_INT 1
1555: ARRAY
1556: PPUSH
1557: CALL 5028 0 2
1561: GO 1591
// PlaceHumanInUnit ( i , b [ rand ( 1 , b ) ] ) end else
1563: LD_VAR 0 2
1567: PPUSH
1568: LD_VAR 0 5
1572: PUSH
1573: LD_INT 1
1575: PPUSH
1576: LD_VAR 0 5
1580: PPUSH
1581: CALL_OW 12
1585: ARRAY
1586: PPUSH
1587: CALL_OW 52
1591: GO 1618
// PlaceUnitXYR ( i , dep_x , dep_y , 15 , false ) ;
1593: LD_VAR 0 2
1597: PPUSH
1598: LD_VAR 0 14
1602: PPUSH
1603: LD_VAR 0 15
1607: PPUSH
1608: LD_INT 15
1610: PPUSH
1611: LD_INT 0
1613: PPUSH
1614: CALL_OW 50
// end ;
1618: GO 1143
1620: POP
1621: POP
// weapons := [ [ ar_flame_thrower , [ 3 , 2 , 1 ] [ Difficulty ] ] , [ ar_gatling_gun , [ 5 , 4 , 3 ] [ Difficulty ] ] , [ ar_double_machine_gun , [ 5 , 5 , 4 ] [ Difficulty ] ] , [ ar_radar , [ 2 , 1 , 1 ] [ Difficulty ] ] ] ;
1622: LD_ADDR_VAR 0 16
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 2
1635: PUSH
1636: LD_INT 1
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PUSH
1644: LD_OWVAR 67
1648: ARRAY
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: PUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 5
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_OWVAR 67
1675: ARRAY
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: LD_INT 5
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 4
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: LIST
1697: PUSH
1698: LD_OWVAR 67
1702: ARRAY
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: LD_INT 30
1710: PUSH
1711: LD_INT 2
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_OWVAR 67
1729: ARRAY
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_bunker ] ] ) do
1741: LD_ADDR_VAR 0 2
1745: PUSH
1746: LD_INT 22
1748: PUSH
1749: LD_OWVAR 20
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 30
1760: PUSH
1761: LD_INT 32
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: PUSH
1777: FOR_IN
1778: IFFALSE 1951
// begin if weapons then
1780: LD_VAR 0 16
1784: IFFALSE 1908
// begin k := rand ( 1 , weapons ) ;
1786: LD_ADDR_VAR 0 3
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_VAR 0 16
1798: PPUSH
1799: CALL_OW 12
1803: ST_TO_ADDR
// weapon := weapons [ k ] [ 1 ] ;
1804: LD_ADDR_VAR 0 17
1808: PUSH
1809: LD_VAR 0 16
1813: PUSH
1814: LD_VAR 0 3
1818: ARRAY
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: ST_TO_ADDR
// weapons := Replace2 ( weapons , k , 2 , weapons [ k ] [ 2 ] - 1 ) ;
1824: LD_ADDR_VAR 0 16
1828: PUSH
1829: LD_VAR 0 16
1833: PPUSH
1834: LD_VAR 0 3
1838: PPUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_VAR 0 16
1846: PUSH
1847: LD_VAR 0 3
1851: ARRAY
1852: PUSH
1853: LD_INT 2
1855: ARRAY
1856: PUSH
1857: LD_INT 1
1859: MINUS
1860: PPUSH
1861: CALL 5120 0 4
1865: ST_TO_ADDR
// if weapons [ k ] [ 2 ] = 0 then
1866: LD_VAR 0 16
1870: PUSH
1871: LD_VAR 0 3
1875: ARRAY
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: PUSH
1881: LD_INT 0
1883: EQUAL
1884: IFFALSE 1906
// weapons := Delete ( weapons , k ) ;
1886: LD_ADDR_VAR 0 16
1890: PUSH
1891: LD_VAR 0 16
1895: PPUSH
1896: LD_VAR 0 3
1900: PPUSH
1901: CALL_OW 3
1905: ST_TO_ADDR
// end else
1906: GO 1935
// weapon := [ ar_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_INT 27
1915: PUSH
1916: LD_INT 23
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: CALL_OW 12
1933: ARRAY
1934: ST_TO_ADDR
// PlaceWeaponTurret ( i , weapon ) ;
1935: LD_VAR 0 2
1939: PPUSH
1940: LD_VAR 0 17
1944: PPUSH
1945: CALL_OW 431
// end ;
1949: GO 1777
1951: POP
1952: POP
// PrepareHuman ( sex_male , 1 , skill + 1 ) ;
1953: LD_INT 1
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 8
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: CALL_OW 380
// hc_gallery := potter ;
1972: LD_ADDR_OWVAR 33
1976: PUSH
1977: LD_STRING potter
1979: ST_TO_ADDR
// hc_face_number := 1 ;
1980: LD_ADDR_OWVAR 34
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// hc_importance := 100 ;
1988: LD_ADDR_OWVAR 32
1992: PUSH
1993: LD_INT 100
1995: ST_TO_ADDR
// hc_name := Mike Gerste ;
1996: LD_ADDR_OWVAR 26
2000: PUSH
2001: LD_STRING Mike Gerste
2003: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2004: LD_ADDR_OWVAR 29
2008: PUSH
2009: LD_INT 10
2011: PUSH
2012: LD_INT 11
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: ST_TO_ADDR
// legion_commander := CreateHuman ;
2019: LD_ADDR_EXP 1
2023: PUSH
2024: CALL_OW 44
2028: ST_TO_ADDR
// PlaceHumanInUnit ( legion_commander , main_base ) ;
2029: LD_EXP 1
2033: PPUSH
2034: LD_INT 23
2036: PPUSH
2037: CALL_OW 52
// uc_side := 5 ;
2041: LD_ADDR_OWVAR 20
2045: PUSH
2046: LD_INT 5
2048: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , skill ) ;
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: LD_VAR 0 8
2059: PPUSH
2060: CALL_OW 380
// hc_gallery := potter ;
2064: LD_ADDR_OWVAR 33
2068: PUSH
2069: LD_STRING potter
2071: ST_TO_ADDR
// hc_face_number := 2 ;
2072: LD_ADDR_OWVAR 34
2076: PUSH
2077: LD_INT 2
2079: ST_TO_ADDR
// hc_importance := 0 ;
2080: LD_ADDR_OWVAR 32
2084: PUSH
2085: LD_INT 0
2087: ST_TO_ADDR
// hc_name := George Potter ;
2088: LD_ADDR_OWVAR 26
2092: PUSH
2093: LD_STRING George Potter
2095: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
2096: LD_ADDR_OWVAR 29
2100: PUSH
2101: LD_INT 12
2103: PUSH
2104: LD_INT 9
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: ST_TO_ADDR
// potter := CreateHuman ;
2111: LD_ADDR_EXP 4
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// SetDir ( potter , 4 ) ;
2121: LD_EXP 4
2125: PPUSH
2126: LD_INT 4
2128: PPUSH
2129: CALL_OW 233
// PlaceUnitXY ( potter , 103 , 45 , false ) ;
2133: LD_EXP 4
2137: PPUSH
2138: LD_INT 103
2140: PPUSH
2141: LD_INT 45
2143: PPUSH
2144: LD_INT 0
2146: PPUSH
2147: CALL_OW 48
// ComTurnUnit ( potter , main_base ) ;
2151: LD_EXP 4
2155: PPUSH
2156: LD_INT 23
2158: PPUSH
2159: CALL_OW 119
// InitHc ( ) ;
2163: CALL_OW 19
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export function PrepareAllies ; var i , un , b , list ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
2178: PPUSH
// uc_side := 5 ;
2179: LD_ADDR_OWVAR 20
2183: PUSH
2184: LD_INT 5
2186: ST_TO_ADDR
// uc_nation := nation_arabian ;
2187: LD_ADDR_OWVAR 21
2191: PUSH
2192: LD_INT 2
2194: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_barracks ] ] ) ;
2195: LD_ADDR_VAR 0 4
2199: PUSH
2200: LD_INT 22
2202: PUSH
2203: LD_OWVAR 20
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 30
2214: PUSH
2215: LD_INT 5
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PPUSH
2226: CALL_OW 69
2230: ST_TO_ADDR
// for i = 1 to 3 do
2231: LD_ADDR_VAR 0 2
2235: PUSH
2236: DOUBLE
2237: LD_INT 1
2239: DEC
2240: ST_TO_ADDR
2241: LD_INT 3
2243: PUSH
2244: FOR_TO
2245: IFFALSE 2283
// begin PrepareHuman ( false , 2 , 6 ) ;
2247: LD_INT 0
2249: PPUSH
2250: LD_INT 2
2252: PPUSH
2253: LD_INT 6
2255: PPUSH
2256: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 27 , 22 , 5 , false ) ;
2260: CALL_OW 44
2264: PPUSH
2265: LD_INT 27
2267: PPUSH
2268: LD_INT 22
2270: PPUSH
2271: LD_INT 5
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 50
// end ;
2281: GO 2244
2283: POP
2284: POP
// for i = 1 to 3 do
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: DOUBLE
2291: LD_INT 1
2293: DEC
2294: ST_TO_ADDR
2295: LD_INT 3
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2334
// begin PrepareHuman ( false , 1 , 6 ) ;
2301: LD_INT 0
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 6
2309: PPUSH
2310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b [ 1 ] ) ;
2314: CALL_OW 44
2318: PPUSH
2319: LD_VAR 0 4
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 52
// end ;
2332: GO 2298
2334: POP
2335: POP
// for i in FilterAllUnits ( [ [ f_side , uc_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) do
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_INT 22
2343: PUSH
2344: LD_OWVAR 20
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: LD_INT 30
2358: PUSH
2359: LD_INT 31
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 30
2368: PUSH
2369: LD_INT 32
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2478
// begin PrepareHuman ( false , 1 , 6 ) ;
2393: LD_INT 0
2395: PPUSH
2396: LD_INT 1
2398: PPUSH
2399: LD_INT 6
2401: PPUSH
2402: CALL_OW 380
// PlaceHumanInBunker ( CreateHuman , i ) ;
2406: CALL_OW 44
2410: PPUSH
2411: LD_VAR 0 2
2415: PPUSH
2416: CALL 5028 0 2
// if GetBType ( i ) = b_bunker then
2420: LD_VAR 0 2
2424: PPUSH
2425: CALL_OW 266
2429: PUSH
2430: LD_INT 32
2432: EQUAL
2433: IFFALSE 2476
// PlaceWeaponTurret ( i , [ ar_gun , ar_gatling_gun , ar_double_machine_gun , ar_rocket_launcher ] [ i mod 4 + 1 ] ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_INT 27
2442: PUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 24
2448: PUSH
2449: LD_INT 28
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_INT 4
2465: MOD
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: ARRAY
2471: PPUSH
2472: CALL_OW 431
// end ;
2476: GO 2390
2478: POP
2479: POP
// for i = 1 to 3 do
2480: LD_ADDR_VAR 0 2
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_INT 3
2492: PUSH
2493: FOR_TO
2494: IFFALSE 2611
// begin vc_chassis := ar_half_tracked ;
2496: LD_ADDR_OWVAR 37
2500: PUSH
2501: LD_INT 14
2503: ST_TO_ADDR
// vc_engine := engine_solar ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_INT 2
2511: ST_TO_ADDR
// vc_control := control_manual ;
2512: LD_ADDR_OWVAR 38
2516: PUSH
2517: LD_INT 1
2519: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ i ] ;
2520: LD_ADDR_OWVAR 40
2524: PUSH
2525: LD_INT 25
2527: PUSH
2528: LD_INT 27
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_VAR 0 2
2543: ARRAY
2544: ST_TO_ADDR
// un := CreateVehicle ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2555: LD_VAR 0 3
2559: PPUSH
2560: LD_INT 5
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitArea ( un , parking_2 , false ) ;
2567: LD_VAR 0 3
2571: PPUSH
2572: LD_INT 8
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// PrepareHuman ( false , 3 , 7 ) ;
2582: LD_INT 0
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 7
2590: PPUSH
2591: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
2595: CALL_OW 44
2599: PPUSH
2600: LD_VAR 0 3
2604: PPUSH
2605: CALL_OW 52
// end ;
2609: GO 2493
2611: POP
2612: POP
// PrepareHuman ( sex_male , 1 , 6 ) ;
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 1
2618: PPUSH
2619: LD_INT 6
2621: PPUSH
2622: CALL_OW 380
// al_commander := CreateHuman ;
2626: LD_ADDR_EXP 5
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceHumanInUnit ( al_commander , FilterAllUnits ( [ [ f_side , uc_side ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
2636: LD_EXP 5
2640: PPUSH
2641: LD_INT 22
2643: PUSH
2644: LD_OWVAR 20
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: LD_INT 0
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL_OW 69
2671: PUSH
2672: LD_INT 1
2674: ARRAY
2675: PPUSH
2676: CALL_OW 52
// InitHc ( ) ;
2680: CALL_OW 19
// end ;
2684: LD_VAR 0 1
2688: RET
// export function ChangeSide ( ) ; var i ; begin
2689: LD_INT 0
2691: PPUSH
2692: PPUSH
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_INT 22
2700: PUSH
2701: LD_INT 5
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2730
// SetSide ( i , 8 ) ;
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 8
2723: PPUSH
2724: CALL_OW 235
2728: GO 2713
2730: POP
2731: POP
// end ;
2732: LD_VAR 0 1
2736: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 5 ] ) do var i , list , d , j , b , m ;
2737: LD_INT 22
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PPUSH
2747: CALL_OW 69
2751: IFFALSE 3265
2753: GO 2755
2755: DISABLE
2756: LD_INT 0
2758: PPUSH
2759: PPUSH
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// list := FilterAllUnits ( [ [ f_side , 5 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 5
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: LD_INT 21
2785: PUSH
2786: LD_INT 1
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: LD_INT 21
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PPUSH
2812: CALL_OW 69
2816: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_INT 22
2824: PUSH
2825: LD_INT 5
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 30
2834: PUSH
2835: LD_INT 32
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 3
2844: PUSH
2845: LD_INT 24
2847: PUSH
2848: LD_INT 1000
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 69
2868: ST_TO_ADDR
// m := UnitFilter ( list , [ [ f_not , [ f_inside ] ] , [ f_class , 3 ] ] ) ;
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 3
2881: PUSH
2882: LD_INT 54
2884: PUSH
2885: EMPTY
2886: LIST
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 25
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 72
2910: ST_TO_ADDR
// if not list then
2911: LD_VAR 0 2
2915: NOT
2916: IFFALSE 2920
// exit ;
2918: GO 3265
// for i in list do
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: PUSH
2930: FOR_IN
2931: IFFALSE 3263
// begin if b then
2933: LD_VAR 0 5
2937: IFFALSE 3016
// for j in UnitFilter ( list , [ f_class , 2 ] ) do
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PUSH
2952: LD_INT 2
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 72
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3014
// if not HasTask ( j ) and GetTag ( i ) <> 7 then
2967: LD_VAR 0 4
2971: PPUSH
2972: CALL_OW 314
2976: NOT
2977: PUSH
2978: LD_VAR 0 1
2982: PPUSH
2983: CALL_OW 110
2987: PUSH
2988: LD_INT 7
2990: NONEQUAL
2991: AND
2992: IFFALSE 3012
// ComRepairBuilding ( j , b [ 1 ] ) ;
2994: LD_VAR 0 4
2998: PPUSH
2999: LD_VAR 0 5
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: PPUSH
3008: CALL_OW 130
3012: GO 2964
3014: POP
3015: POP
// if GetLives ( i ) < 500 and not GetTag ( i ) = 7 then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 256
3025: PUSH
3026: LD_INT 500
3028: LESS
3029: PUSH
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 110
3039: PUSH
3040: LD_INT 7
3042: EQUAL
3043: NOT
3044: AND
3045: IFFALSE 3095
// begin ComMoveToArea ( i , guard_hill ) ;
3047: LD_VAR 0 1
3051: PPUSH
3052: LD_INT 11
3054: PPUSH
3055: CALL_OW 113
// SetTag ( i , 7 ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: LD_INT 7
3066: PPUSH
3067: CALL_OW 109
// if GetType ( i ) = unit_vehicle then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 247
3080: PUSH
3081: LD_INT 2
3083: EQUAL
3084: IFFALSE 3095
// begin AddComExitVehicle ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 181
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 7 and not IsInUnit ( i ) and m then
3095: LD_VAR 0 1
3099: PPUSH
3100: CALL_OW 256
3104: PUSH
3105: LD_INT 1000
3107: EQUAL
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 110
3118: PUSH
3119: LD_INT 7
3121: EQUAL
3122: AND
3123: PUSH
3124: LD_VAR 0 1
3128: PPUSH
3129: CALL_OW 310
3133: NOT
3134: AND
3135: PUSH
3136: LD_VAR 0 6
3140: AND
3141: IFFALSE 3169
// begin SetTag ( i , 0 ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 109
// ComEnterUnit ( m , i ) ;
3155: LD_VAR 0 6
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 120
// end ; if GetType ( i ) = unit_vehicle and GetTag ( i ) <> 7 and not HasTask ( i ) then
3169: LD_VAR 0 1
3173: PPUSH
3174: CALL_OW 247
3178: PUSH
3179: LD_INT 2
3181: EQUAL
3182: PUSH
3183: LD_VAR 0 1
3187: PPUSH
3188: CALL_OW 110
3192: PUSH
3193: LD_INT 7
3195: NONEQUAL
3196: AND
3197: PUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: CALL_OW 314
3207: NOT
3208: AND
3209: IFFALSE 3261
// if FilterAllUnits ( [ f_side , 7 ] ) then
3211: LD_INT 22
3213: PUSH
3214: LD_INT 7
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PPUSH
3221: CALL_OW 69
3225: IFFALSE 3261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_INT 22
3234: PUSH
3235: LD_INT 7
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 69
3246: PPUSH
3247: LD_VAR 0 1
3251: PPUSH
3252: CALL_OW 74
3256: PPUSH
3257: CALL_OW 115
// end ;
3261: GO 2930
3263: POP
3264: POP
// end ; end_of_file
3265: PPOPN 6
3267: END
// export function Game ; var i , val , areas , wave ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
// areas := [ north_west_1 , west_2 , south_west_3 , north_4 , east_5 , south_east_6 ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: LD_INT 5
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: ST_TO_ADDR
// val := [ 10 , 20 , 30 ] [ Difficulty ] ;
3306: LD_ADDR_VAR 0 3
3310: PUSH
3311: LD_INT 10
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 30
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_OWVAR 67
3329: ARRAY
3330: ST_TO_ADDR
// wave := 1 ;
3331: LD_ADDR_VAR 0 5
3335: PUSH
3336: LD_INT 1
3338: ST_TO_ADDR
// while ( game_over = false ) do
3339: LD_EXP 7
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3511
// begin repeat begin Wait ( 0 0$01 ) ;
3349: LD_INT 35
3351: PPUSH
3352: CALL_OW 67
// wave_time := wave_time + 0 0$01 ;
3356: LD_ADDR_EXP 9
3360: PUSH
3361: LD_EXP 9
3365: PUSH
3366: LD_INT 35
3368: PLUS
3369: ST_TO_ADDR
// end until FilterAllUnits ( [ f_side , 7 ] ) < 10 or wave_time >= 10 10$00 ;
3370: LD_INT 22
3372: PUSH
3373: LD_INT 7
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 10
3387: LESS
3388: PUSH
3389: LD_EXP 9
3393: PUSH
3394: LD_INT 21000
3396: GREATEREQUAL
3397: OR
3398: IFFALSE 3349
// wave_time := 0 0$00 ;
3400: LD_ADDR_EXP 9
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// Wait ( 2 2$30 ) ;
3408: LD_INT 5250
3410: PPUSH
3411: CALL_OW 67
// if not ignore_wave then
3415: LD_EXP 13
3419: NOT
3420: IFFALSE 3501
// begin for i = 1 to wave do
3422: LD_ADDR_VAR 0 2
3426: PUSH
3427: DOUBLE
3428: LD_INT 1
3430: DEC
3431: ST_TO_ADDR
3432: LD_VAR 0 5
3436: PUSH
3437: FOR_TO
3438: IFFALSE 3483
// begin SpawnPotter ( val * i , areas [ i mod 6 + 1 ] ) ;
3440: LD_VAR 0 3
3444: PUSH
3445: LD_VAR 0 2
3449: MUL
3450: PPUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 6
3463: MOD
3464: PUSH
3465: LD_INT 1
3467: PLUS
3468: ARRAY
3469: PPUSH
3470: CALL 3516 0 2
// Wait ( 0 0$10 ) ;
3474: LD_INT 350
3476: PPUSH
3477: CALL_OW 67
// end ;
3481: GO 3437
3483: POP
3484: POP
// wave := wave + 1 ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_VAR 0 5
3494: PUSH
3495: LD_INT 1
3497: PLUS
3498: ST_TO_ADDR
// end else
3499: GO 3509
// ignore_wave := false ;
3501: LD_ADDR_EXP 13
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// end ;
3509: GO 3339
// end ;
3511: LD_VAR 0 1
3515: RET
// export function SpawnPotter ( val , area ) ; var i , un , class ; begin
3516: LD_INT 0
3518: PPUSH
3519: PPUSH
3520: PPUSH
3521: PPUSH
// uc_side := 7 ;
3522: LD_ADDR_OWVAR 20
3526: PUSH
3527: LD_INT 7
3529: ST_TO_ADDR
// uc_nation := 2 ;
3530: LD_ADDR_OWVAR 21
3534: PUSH
3535: LD_INT 2
3537: ST_TO_ADDR
// InitHc ( ) ;
3538: CALL_OW 19
// hc_gallery :=  ;
3542: LD_ADDR_OWVAR 33
3546: PUSH
3547: LD_STRING 
3549: ST_TO_ADDR
// hc_importance := 0 ;
3550: LD_ADDR_OWVAR 32
3554: PUSH
3555: LD_INT 0
3557: ST_TO_ADDR
// hc_name :=  ;
3558: LD_ADDR_OWVAR 26
3562: PUSH
3563: LD_STRING 
3565: ST_TO_ADDR
// hc_attr := [ 10 + ( tick div 10 10$00 ) , 10 + ( tick div 10 10$00 ) ] ;
3566: LD_ADDR_OWVAR 29
3570: PUSH
3571: LD_INT 10
3573: PUSH
3574: LD_OWVAR 1
3578: PUSH
3579: LD_INT 21000
3581: DIV
3582: PLUS
3583: PUSH
3584: LD_INT 10
3586: PUSH
3587: LD_OWVAR 1
3591: PUSH
3592: LD_INT 21000
3594: DIV
3595: PLUS
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// for i = 1 to val do
3601: LD_ADDR_VAR 0 4
3605: PUSH
3606: DOUBLE
3607: LD_INT 1
3609: DEC
3610: ST_TO_ADDR
3611: LD_VAR 0 1
3615: PUSH
3616: FOR_TO
3617: IFFALSE 3824
// begin if i mod 9 = 0 then
3619: LD_VAR 0 4
3623: PUSH
3624: LD_INT 9
3626: MOD
3627: PUSH
3628: LD_INT 0
3630: EQUAL
3631: IFFALSE 3643
// class := class_apeman_kamikaze else
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_INT 17
3640: ST_TO_ADDR
3641: GO 3675
// if i mod 4 = 0 then
3643: LD_VAR 0 4
3647: PUSH
3648: LD_INT 4
3650: MOD
3651: PUSH
3652: LD_INT 0
3654: EQUAL
3655: IFFALSE 3667
// class := class_apeman_soldier else
3657: LD_ADDR_VAR 0 6
3661: PUSH
3662: LD_INT 15
3664: ST_TO_ADDR
3665: GO 3675
// class := class_apeman ;
3667: LD_ADDR_VAR 0 6
3671: PUSH
3672: LD_INT 12
3674: ST_TO_ADDR
// if i mod 33 = 0 then
3675: LD_VAR 0 4
3679: PUSH
3680: LD_INT 33
3682: MOD
3683: PUSH
3684: LD_INT 0
3686: EQUAL
3687: IFFALSE 3756
// begin vc_chassis := ar_half_tracked ;
3689: LD_ADDR_OWVAR 37
3693: PUSH
3694: LD_INT 14
3696: ST_TO_ADDR
// vc_control := control_apeman ;
3697: LD_ADDR_OWVAR 38
3701: PUSH
3702: LD_INT 5
3704: ST_TO_ADDR
// vc_engine := engine_combustion ;
3705: LD_ADDR_OWVAR 39
3709: PUSH
3710: LD_INT 1
3712: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 2 ) ] ;
3713: LD_ADDR_OWVAR 40
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: LD_INT 29
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 1
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: CALL_OW 12
3742: ARRAY
3743: ST_TO_ADDR
// un := CreateVehicle ;
3744: LD_ADDR_VAR 0 5
3748: PUSH
3749: CALL_OW 45
3753: ST_TO_ADDR
// end else
3754: GO 3781
// begin PrepareHuman ( sex_male , class , 10 ) ;
3756: LD_INT 1
3758: PPUSH
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_INT 10
3766: PPUSH
3767: CALL_OW 380
// un := CreateHuman ;
3771: LD_ADDR_VAR 0 5
3775: PUSH
3776: CALL_OW 44
3780: ST_TO_ADDR
// end ; PlaceUnitArea ( un , area , false ) ;
3781: LD_VAR 0 5
3785: PPUSH
3786: LD_VAR 0 2
3790: PPUSH
3791: LD_INT 0
3793: PPUSH
3794: CALL_OW 49
// EffectTeleport ( GetX ( un ) , GetY ( un ) ) ;
3798: LD_VAR 0 5
3802: PPUSH
3803: CALL_OW 250
3807: PPUSH
3808: LD_VAR 0 5
3812: PPUSH
3813: CALL_OW 251
3817: PPUSH
3818: CALL_OW 494
// end ;
3822: GO 3616
3824: POP
3825: POP
// end ;
3826: LD_VAR 0 3
3830: RET
// every 0 0$0.3 trigger alert and not game_over do var i , list , enemy ;
3831: LD_EXP 6
3835: PUSH
3836: LD_EXP 7
3840: NOT
3841: AND
3842: IFFALSE 4128
3844: GO 3846
3846: DISABLE
3847: LD_INT 0
3849: PPUSH
3850: PPUSH
3851: PPUSH
// begin enable ;
3852: ENABLE
// list := FilterAllUnits ( [ f_side , 7 ] ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_INT 22
3860: PUSH
3861: LD_INT 7
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// if not list then
3873: LD_VAR 0 2
3877: NOT
3878: IFFALSE 3882
// exit ;
3880: GO 4128
// for i in list do
3882: LD_ADDR_VAR 0 1
3886: PUSH
3887: LD_VAR 0 2
3891: PUSH
3892: FOR_IN
3893: IFFALSE 4126
// begin enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 15 ] ] ) ;
3895: LD_ADDR_VAR 0 3
3899: PUSH
3900: LD_INT 81
3902: PUSH
3903: LD_INT 7
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 92
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 250
3922: PUSH
3923: LD_VAR 0 1
3927: PPUSH
3928: CALL_OW 251
3932: PUSH
3933: LD_INT 15
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 69
3950: ST_TO_ADDR
// if not enemy then
3951: LD_VAR 0 3
3955: NOT
3956: IFFALSE 4014
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 30 ] ] ) ;
3958: LD_ADDR_VAR 0 3
3962: PUSH
3963: LD_INT 81
3965: PUSH
3966: LD_INT 7
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 92
3975: PUSH
3976: LD_VAR 0 1
3980: PPUSH
3981: CALL_OW 250
3985: PUSH
3986: LD_VAR 0 1
3990: PPUSH
3991: CALL_OW 251
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 69
4013: ST_TO_ADDR
// if not enemy then
4014: LD_VAR 0 3
4018: NOT
4019: IFFALSE 4077
// enemy := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_distxy , GetX ( i ) , GetY ( i ) , 50 ] ] ) ;
4021: LD_ADDR_VAR 0 3
4025: PUSH
4026: LD_INT 81
4028: PUSH
4029: LD_INT 7
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 92
4038: PUSH
4039: LD_VAR 0 1
4043: PPUSH
4044: CALL_OW 250
4048: PUSH
4049: LD_VAR 0 1
4053: PPUSH
4054: CALL_OW 251
4058: PUSH
4059: LD_INT 50
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 3
4081: NOT
4082: IFFALSE 4104
// enemy := FilterAllUnits ( [ f_enemy , 7 ] ) ;
4084: LD_ADDR_VAR 0 3
4088: PUSH
4089: LD_INT 81
4091: PUSH
4092: LD_INT 7
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: ST_TO_ADDR
// if enemy then
4104: LD_VAR 0 3
4108: IFFALSE 4124
// Attack ( i , enemy ) ;
4110: LD_VAR 0 1
4114: PPUSH
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL 4131 0 2
// end ;
4124: GO 3892
4126: POP
4127: POP
// end ;
4128: PPOPN 3
4130: END
// function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
4131: LD_INT 0
4133: PPUSH
4134: PPUSH
4135: PPUSH
// if not unit then
4136: LD_VAR 0 1
4140: NOT
4141: IFFALSE 4145
// exit ;
4143: GO 4309
// targets_list := [ ] ;
4145: LD_ADDR_VAR 0 5
4149: PUSH
4150: EMPTY
4151: ST_TO_ADDR
// targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_VAR 0 2
4161: PPUSH
4162: LD_INT 21
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 3
4174: PUSH
4175: LD_INT 54
4177: PUSH
4178: EMPTY
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 72
4193: PUSH
4194: LD_VAR 0 2
4198: PPUSH
4199: LD_INT 21
4201: PUSH
4202: LD_INT 2
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL_OW 72
4213: PUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: LD_INT 21
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 3
4231: PUSH
4232: LD_INT 58
4234: PUSH
4235: EMPTY
4236: LIST
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 72
4250: PUSH
4251: LD_VAR 0 2
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// for target in targets_list do
4262: LD_ADDR_VAR 0 4
4266: PUSH
4267: LD_VAR 0 5
4271: PUSH
4272: FOR_IN
4273: IFFALSE 4307
// begin if target then
4275: LD_VAR 0 4
4279: IFFALSE 4305
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_VAR 0 4
4290: PPUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 74
4300: PPUSH
4301: CALL_OW 115
// end ;
4305: GO 4272
4307: POP
4308: POP
// end ; end_of_file
4309: LD_VAR 0 3
4313: RET
// export function Action ; begin
4314: LD_INT 0
4316: PPUSH
// InGameOn ;
4317: CALL_OW 8
// CenterNowOnUnits ( main_base ) ;
4321: LD_INT 23
4323: PPUSH
4324: CALL_OW 87
// Say ( legion_commander , DL-1 ) ;
4328: LD_EXP 1
4332: PPUSH
4333: LD_STRING DL-1
4335: PPUSH
4336: CALL_OW 88
// Say ( l1 , DA-1 ) ;
4340: LD_EXP 2
4344: PPUSH
4345: LD_STRING DA-1
4347: PPUSH
4348: CALL_OW 88
// Say ( l2 , DA-2 ) ;
4352: LD_EXP 3
4356: PPUSH
4357: LD_STRING DA-2
4359: PPUSH
4360: CALL_OW 88
// Say ( legion_commander , DL-2 ) ;
4364: LD_EXP 1
4368: PPUSH
4369: LD_STRING DL-2
4371: PPUSH
4372: CALL_OW 88
// Say ( l2 , DA-3 ) ;
4376: LD_EXP 3
4380: PPUSH
4381: LD_STRING DA-3
4383: PPUSH
4384: CALL_OW 88
// Say ( legion_commander , DL-3 ) ;
4388: LD_EXP 1
4392: PPUSH
4393: LD_STRING DL-3
4395: PPUSH
4396: CALL_OW 88
// Say ( l1 , DA-4 ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_STRING DA-4
4407: PPUSH
4408: CALL_OW 88
// if not dialogue_skipped then
4412: LD_OWVAR 59
4416: NOT
4417: IFFALSE 4502
// begin Wait ( 0 0$01 ) ;
4419: LD_INT 35
4421: PPUSH
4422: CALL_OW 67
// ComExitBuilding ( [ l1 , l2 ] ) ;
4426: LD_EXP 2
4430: PUSH
4431: LD_EXP 3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 122
// AddComMoveXY ( l1 , 107 , 53 ) ;
4444: LD_EXP 2
4448: PPUSH
4449: LD_INT 107
4451: PPUSH
4452: LD_INT 53
4454: PPUSH
4455: CALL_OW 171
// AddComMoveXY ( l2 , 108 , 53 ) ;
4459: LD_EXP 3
4463: PPUSH
4464: LD_INT 108
4466: PPUSH
4467: LD_INT 53
4469: PPUSH
4470: CALL_OW 171
// AddComTurnUnit ( l1 , potter ) ;
4474: LD_EXP 2
4478: PPUSH
4479: LD_EXP 4
4483: PPUSH
4484: CALL_OW 179
// AddComTurnUnit ( l2 , potter ) ;
4488: LD_EXP 3
4492: PPUSH
4493: LD_EXP 4
4497: PPUSH
4498: CALL_OW 179
// end ; repeat Wait ( 0 0$01 ) ;
4502: LD_INT 35
4504: PPUSH
4505: CALL_OW 67
// until IsAt ( l1 , 107 , 53 ) or dialogue_skipped ;
4509: LD_EXP 2
4513: PPUSH
4514: LD_INT 107
4516: PPUSH
4517: LD_INT 53
4519: PPUSH
4520: CALL_OW 307
4524: PUSH
4525: LD_OWVAR 59
4529: OR
4530: IFFALSE 4502
// if not dialogue_skipped then
4532: LD_OWVAR 59
4536: NOT
4537: IFFALSE 4638
// begin ComTurnUnit ( potter , l1 ) ;
4539: LD_EXP 4
4543: PPUSH
4544: LD_EXP 2
4548: PPUSH
4549: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4553: LD_INT 10
4555: PPUSH
4556: CALL_OW 67
// TeleportUnit ( potter , 108 , 1 , 0 , false ) ;
4560: LD_EXP 4
4564: PPUSH
4565: LD_INT 108
4567: PPUSH
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 0
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 483
// Wait ( 0 0$01 ) ;
4581: LD_INT 35
4583: PPUSH
4584: CALL_OW 67
// RemoveUnit ( potter ) ;
4588: LD_EXP 4
4592: PPUSH
4593: CALL_OW 64
// Say ( l1 , DA-5 ) ;
4597: LD_EXP 2
4601: PPUSH
4602: LD_STRING DA-5
4604: PPUSH
4605: CALL_OW 88
// Say ( l2 , DA-6 ) ;
4609: LD_EXP 3
4613: PPUSH
4614: LD_STRING DA-6
4616: PPUSH
4617: CALL_OW 88
// Wait ( 0 0$02 ) ;
4621: LD_INT 70
4623: PPUSH
4624: CALL_OW 67
// CenterOnXY ( 25 , 19 ) ;
4628: LD_INT 25
4630: PPUSH
4631: LD_INT 19
4633: PPUSH
4634: CALL_OW 84
// end ; SpawnPotter ( 30 , north_west_1 ) ;
4638: LD_INT 30
4640: PPUSH
4641: LD_INT 1
4643: PPUSH
4644: CALL 3516 0 2
// SayRadio ( al_commander , DLa-1 ) ;
4648: LD_EXP 5
4652: PPUSH
4653: LD_STRING DLa-1
4655: PPUSH
4656: CALL_OW 94
// Say ( legion_commander , DL-5 ) ;
4660: LD_EXP 1
4664: PPUSH
4665: LD_STRING DL-5
4667: PPUSH
4668: CALL_OW 88
// CenterNowOnUnits ( main_base ) ;
4672: LD_INT 23
4674: PPUSH
4675: CALL_OW 87
// InGameOff ;
4679: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4683: LD_STRING C1
4685: PPUSH
4686: CALL_OW 337
// alert := true ;
4690: LD_ADDR_EXP 6
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
// ComExitBuilding ( al_commander ) ;
4698: LD_EXP 5
4702: PPUSH
4703: CALL_OW 122
// AddComMoveToArea ( al_commander , guard_hill ) ;
4707: LD_EXP 5
4711: PPUSH
4712: LD_INT 11
4714: PPUSH
4715: CALL_OW 173
// Wait ( 0 0$30 ) ;
4719: LD_INT 1050
4721: PPUSH
4722: CALL_OW 67
// SpawnPotter ( 20 , north_4 ) ;
4726: LD_INT 20
4728: PPUSH
4729: LD_INT 4
4731: PPUSH
4732: CALL 3516 0 2
// Wait ( 0 0$35 ) ;
4736: LD_INT 1225
4738: PPUSH
4739: CALL_OW 67
// SpawnPotter ( 20 , east_5 ) ;
4743: LD_INT 20
4745: PPUSH
4746: LD_INT 5
4748: PPUSH
4749: CALL 3516 0 2
// Wait ( 0 0$03 ) ;
4753: LD_INT 105
4755: PPUSH
4756: CALL_OW 67
// Game ;
4760: CALL 3268 0 0
// end ;
4764: LD_VAR 0 1
4768: RET
// every 0 0$10 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 and points >= 500 do var tmp , i ;
4769: LD_INT 22
4771: PUSH
4772: LD_INT 7
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: PUSH
4788: LD_EXP 8
4792: PUSH
4793: LD_INT 500
4795: GREATEREQUAL
4796: AND
4797: IFFALSE 5025
4799: GO 4801
4801: DISABLE
4802: LD_INT 0
4804: PPUSH
4805: PPUSH
// begin DialogueOn ;
4806: CALL_OW 6
// SayRadio ( Vervecken , DVr-1 ) ;
4810: LD_EXP 10
4814: PPUSH
4815: LD_STRING DVr-1
4817: PPUSH
4818: CALL_OW 94
// DialogueOff ;
4822: CALL_OW 7
// case Query ( QBonusInfo ) of 1 :
4826: LD_STRING QBonusInfo
4828: PPUSH
4829: CALL_OW 97
4833: PUSH
4834: LD_INT 1
4836: DOUBLE
4837: EQUAL
4838: IFTRUE 4842
4840: GO 4853
4842: POP
// bonus_active := true ; end ;
4843: LD_ADDR_EXP 11
4847: PUSH
4848: LD_INT 1
4850: ST_TO_ADDR
4851: GO 4854
4853: POP
// bonus_num := 4 ;
4854: LD_ADDR_EXP 12
4858: PUSH
4859: LD_INT 4
4861: ST_TO_ADDR
// SetArtifactUse ( your_side , art_exp_mid , art_instant , main_base ) ;
4862: LD_OWVAR 2
4866: PPUSH
4867: LD_INT 2
4869: PPUSH
4870: LD_INT 2
4872: PPUSH
4873: LD_INT 23
4875: PPUSH
4876: CALL_OW 468
// tmp := [ 500 , 3500 , 5750 , 10000 ] ;
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: LD_INT 500
4887: PUSH
4888: LD_INT 3500
4890: PUSH
4891: LD_INT 5750
4893: PUSH
4894: LD_INT 10000
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// repeat wait ( [ 5 5$00 , 6 6$00 , 7 7$00 ] [ Difficulty ] ) ;
4903: LD_INT 10500
4905: PUSH
4906: LD_INT 12600
4908: PUSH
4909: LD_INT 14700
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_OWVAR 67
4921: ARRAY
4922: PPUSH
4923: CALL_OW 67
// for i = 1 to tmp do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_VAR 0 1
4941: PUSH
4942: FOR_TO
4943: IFFALSE 4975
// if points >= tmp [ i ] then
4945: LD_EXP 8
4949: PUSH
4950: LD_VAR 0 1
4954: PUSH
4955: LD_VAR 0 2
4959: ARRAY
4960: GREATEREQUAL
4961: IFFALSE 4973
// bonus_num := i ;
4963: LD_ADDR_EXP 12
4967: PUSH
4968: LD_VAR 0 2
4972: ST_TO_ADDR
4973: GO 4942
4975: POP
4976: POP
// case Query ( QBonusInfo ) of 1 :
4977: LD_STRING QBonusInfo
4979: PPUSH
4980: CALL_OW 97
4984: PUSH
4985: LD_INT 1
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5014
4993: POP
// SetArtifactUse ( your_side , art_use_exclamation , art_instant , main_base ) ; end ;
4994: LD_OWVAR 2
4998: PPUSH
4999: LD_INT 12
5001: PPUSH
5002: LD_INT 2
5004: PPUSH
5005: LD_INT 23
5007: PPUSH
5008: CALL_OW 468
5012: GO 5015
5014: POP
// until points >= 15000 ;
5015: LD_EXP 8
5019: PUSH
5020: LD_INT 15000
5022: GREATEREQUAL
5023: IFFALSE 4903
// end ; end_of_file
5025: PPOPN 2
5027: END
// export function PlaceHumanInBunker ( un , b ) ; var dir ; begin
5028: LD_INT 0
5030: PPUSH
5031: PPUSH
// dir := GetDir ( b ) ;
5032: LD_ADDR_VAR 0 4
5036: PUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 254
5046: ST_TO_ADDR
// if dir < 3 then
5047: LD_VAR 0 4
5051: PUSH
5052: LD_INT 3
5054: LESS
5055: IFFALSE 5073
// dir := dir + 3 else
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: LD_VAR 0 4
5066: PUSH
5067: LD_INT 3
5069: PLUS
5070: ST_TO_ADDR
5071: GO 5087
// dir := dir - 3 ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 3
5085: MINUS
5086: ST_TO_ADDR
// SetDir ( un , dir ) ;
5087: LD_VAR 0 1
5091: PPUSH
5092: LD_VAR 0 4
5096: PPUSH
5097: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5101: LD_VAR 0 1
5105: PPUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: CALL_OW 52
// end ;
5115: LD_VAR 0 3
5119: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
5125: LD_ADDR_VAR 0 7
5129: PUSH
5130: LD_VAR 0 1
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_VAR 0 3
5145: PPUSH
5146: LD_VAR 0 4
5150: PPUSH
5151: CALL_OW 1
5155: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_VAR 0 2
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 1
5180: ST_TO_ADDR
// result := tab ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_VAR 0 1
5190: ST_TO_ADDR
// end ;
5191: LD_VAR 0 5
5195: RET
// export function IsDriver ( unit ) ; begin
5196: LD_INT 0
5198: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5199: LD_VAR 0 1
5203: PUSH
5204: LD_INT 55
5206: PUSH
5207: EMPTY
5208: LIST
5209: PPUSH
5210: CALL_OW 69
5214: IN
5215: IFFALSE 5234
// result := IsInUnit ( unit ) else
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: CALL_OW 310
5231: ST_TO_ADDR
5232: GO 5242
// result := false ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: LD_INT 0
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 2
5246: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5247: LD_INT 0
5249: PPUSH
5250: PPUSH
5251: PPUSH
// if not GetControl ( veh ) = control_manual then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 263
5261: PUSH
5262: LD_INT 1
5264: EQUAL
5265: NOT
5266: IFFALSE 5278
// result := false else
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
5276: GO 5423
// if veh in FilterAllUnits ( [ f_empty ] ) then
5278: LD_VAR 0 1
5282: PUSH
5283: LD_INT 58
5285: PUSH
5286: EMPTY
5287: LIST
5288: PPUSH
5289: CALL_OW 69
5293: IN
5294: IFFALSE 5306
// result := false else
5296: LD_ADDR_VAR 0 2
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
5304: GO 5423
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5306: LD_ADDR_VAR 0 4
5310: PUSH
5311: LD_INT 22
5313: PUSH
5314: LD_VAR 0 1
5318: PPUSH
5319: CALL_OW 255
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 55
5330: PUSH
5331: EMPTY
5332: LIST
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if not filter then
5343: LD_VAR 0 4
5347: NOT
5348: IFFALSE 5360
// result := false else
5350: LD_ADDR_VAR 0 2
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
5358: GO 5423
// for i = 1 to filter do
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_VAR 0 4
5374: PUSH
5375: FOR_TO
5376: IFFALSE 5421
// if IsDriver ( filter [ i ] ) = veh then
5378: LD_VAR 0 4
5382: PUSH
5383: LD_VAR 0 3
5387: ARRAY
5388: PPUSH
5389: CALL 5196 0 1
5393: PUSH
5394: LD_VAR 0 1
5398: EQUAL
5399: IFFALSE 5419
// begin result := filter [ i ] ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: LD_VAR 0 3
5415: ARRAY
5416: ST_TO_ADDR
// break ;
5417: GO 5421
// end ;
5419: GO 5375
5421: POP
5422: POP
// end ; end ; end_of_file
5423: LD_VAR 0 2
5427: RET
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
5428: LD_VAR 0 1
5432: PPUSH
5433: CALL 17618 0 1
// if un in [ legion_commander , main_base ] then
5437: LD_VAR 0 1
5441: PUSH
5442: LD_EXP 1
5446: PUSH
5447: LD_INT 23
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: IN
5454: IFFALSE 5464
// game_over := true ;
5456: LD_ADDR_EXP 7
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// if un = al_commander then
5464: LD_VAR 0 1
5468: PUSH
5469: LD_EXP 5
5473: EQUAL
5474: IFFALSE 5480
// ChangeSide ( ) ;
5476: CALL 2689 0 0
// if GetSide ( un ) = 7 then
5480: LD_VAR 0 1
5484: PPUSH
5485: CALL_OW 255
5489: PUSH
5490: LD_INT 7
5492: EQUAL
5493: IFFALSE 5611
// begin if GetClass ( un ) = class_apeman then
5495: LD_VAR 0 1
5499: PPUSH
5500: CALL_OW 257
5504: PUSH
5505: LD_INT 12
5507: EQUAL
5508: IFFALSE 5524
// points := points + 6 ;
5510: LD_ADDR_EXP 8
5514: PUSH
5515: LD_EXP 8
5519: PUSH
5520: LD_INT 6
5522: PLUS
5523: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_kamikaze then
5524: LD_VAR 0 1
5528: PPUSH
5529: CALL_OW 257
5533: PUSH
5534: LD_INT 17
5536: EQUAL
5537: IFFALSE 5553
// points := points + 11 ;
5539: LD_ADDR_EXP 8
5543: PUSH
5544: LD_EXP 8
5548: PUSH
5549: LD_INT 11
5551: PLUS
5552: ST_TO_ADDR
// if GetClass ( un ) = class_apeman_soldier then
5553: LD_VAR 0 1
5557: PPUSH
5558: CALL_OW 257
5562: PUSH
5563: LD_INT 15
5565: EQUAL
5566: IFFALSE 5582
// points := points + 14 ;
5568: LD_ADDR_EXP 8
5572: PUSH
5573: LD_EXP 8
5577: PUSH
5578: LD_INT 14
5580: PLUS
5581: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
5582: LD_VAR 0 1
5586: PPUSH
5587: CALL_OW 247
5591: PUSH
5592: LD_INT 2
5594: EQUAL
5595: IFFALSE 5611
// points := points + 50 ;
5597: LD_ADDR_EXP 8
5601: PUSH
5602: LD_EXP 8
5606: PUSH
5607: LD_INT 50
5609: PLUS
5610: ST_TO_ADDR
// end ; end ;
5611: PPOPN 1
5613: END
// every 0 0$01 trigger GetLives ( al_commander ) < 1000 do
5614: LD_EXP 5
5618: PPUSH
5619: CALL_OW 256
5623: PUSH
5624: LD_INT 1000
5626: LESS
5627: IFFALSE 5659
5629: GO 5631
5631: DISABLE
// if GetSide ( UnitShoot ( al_commander ) ) = 8 then
5632: LD_EXP 5
5636: PPUSH
5637: CALL_OW 504
5641: PPUSH
5642: CALL_OW 255
5646: PUSH
5647: LD_INT 8
5649: EQUAL
5650: IFFALSE 5659
// YouLost (  ) ;
5652: LD_STRING 
5654: PPUSH
5655: CALL_OW 104
5659: END
// on DialogueSkipped ( value ) do var i ;
5660: LD_INT 0
5662: PPUSH
// begin RemoveUnit ( potter ) ;
5663: LD_EXP 4
5667: PPUSH
5668: CALL_OW 64
// ComExitBuilding ( [ l1 , l2 ] ) ;
5672: LD_EXP 2
5676: PUSH
5677: LD_EXP 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PPUSH
5686: CALL_OW 122
// Wait ( 1 ) ;
5690: LD_INT 1
5692: PPUSH
5693: CALL_OW 67
// TeleportUnit ( l1 , 107 , 53 , 0 , false ) ;
5697: LD_EXP 2
5701: PPUSH
5702: LD_INT 107
5704: PPUSH
5705: LD_INT 53
5707: PPUSH
5708: LD_INT 0
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 483
// TeleportUnit ( l2 , 108 , 53 , 0 , false ) ;
5718: LD_EXP 3
5722: PPUSH
5723: LD_INT 108
5725: PPUSH
5726: LD_INT 53
5728: PPUSH
5729: LD_INT 0
5731: PPUSH
5732: LD_INT 0
5734: PPUSH
5735: CALL_OW 483
// Wait ( 1 ) ;
5739: LD_INT 1
5741: PPUSH
5742: CALL_OW 67
// ComTurnXY ( [ l1 , l2 ] , 108 , 1 ) ;
5746: LD_EXP 2
5750: PUSH
5751: LD_EXP 3
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PPUSH
5760: LD_INT 108
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 118
// end ;
5770: PPOPN 2
5772: END
// on ArtifactUsed ( side , button , p3 , p4 ) do var bonus , off , units , crates , tmp , i ;
5773: LD_INT 0
5775: PPUSH
5776: PPUSH
5777: PPUSH
5778: PPUSH
5779: PPUSH
5780: PPUSH
// begin DialogueOn ;
5781: CALL_OW 6
// uc_side := 8 ;
5785: LD_ADDR_OWVAR 20
5789: PUSH
5790: LD_INT 8
5792: ST_TO_ADDR
// uc_nation := 2 ;
5793: LD_ADDR_OWVAR 21
5797: PUSH
5798: LD_INT 2
5800: ST_TO_ADDR
// bonus := QBonus & bonus_num ;
5801: LD_ADDR_VAR 0 5
5805: PUSH
5806: LD_STRING QBonus
5808: PUSH
5809: LD_EXP 12
5813: STR
5814: ST_TO_ADDR
// off := true ;
5815: LD_ADDR_VAR 0 6
5819: PUSH
5820: LD_INT 1
5822: ST_TO_ADDR
// units := [ ] ;
5823: LD_ADDR_VAR 0 7
5827: PUSH
5828: EMPTY
5829: ST_TO_ADDR
// crates := 0 ;
5830: LD_ADDR_VAR 0 8
5834: PUSH
5835: LD_INT 0
5837: ST_TO_ADDR
// SayRadio ( Vervecken , DVr-2 ) ;
5838: LD_EXP 10
5842: PPUSH
5843: LD_STRING DVr-2
5845: PPUSH
5846: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
5850: LD_INT 10
5852: PPUSH
5853: CALL_OW 67
// case Query ( bonus ) of 1 :
5857: LD_VAR 0 5
5861: PPUSH
5862: CALL_OW 97
5866: PUSH
5867: LD_INT 1
5869: DOUBLE
5870: EQUAL
5871: IFTRUE 5875
5873: GO 5960
5875: POP
// begin tmp := [ 1 , 2 , 5 , 8 ] [ bonus_num ] ;
5876: LD_ADDR_VAR 0 9
5880: PUSH
5881: LD_INT 1
5883: PUSH
5884: LD_INT 2
5886: PUSH
5887: LD_INT 5
5889: PUSH
5890: LD_INT 8
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_EXP 12
5903: ARRAY
5904: ST_TO_ADDR
// for i = 1 to tmp do
5905: LD_ADDR_VAR 0 10
5909: PUSH
5910: DOUBLE
5911: LD_INT 1
5913: DEC
5914: ST_TO_ADDR
5915: LD_VAR 0 9
5919: PUSH
5920: FOR_TO
5921: IFFALSE 5956
// begin PrepareHuman ( false , class_apeman_soldier , tmp ) ;
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 15
5928: PPUSH
5929: LD_VAR 0 9
5933: PPUSH
5934: CALL_OW 380
// units := units ^ CreateHuman ;
5938: LD_ADDR_VAR 0 7
5942: PUSH
5943: LD_VAR 0 7
5947: PUSH
5948: CALL_OW 44
5952: ADD
5953: ST_TO_ADDR
// end ;
5954: GO 5920
5956: POP
5957: POP
// end ; 2 :
5958: GO 6368
5960: LD_INT 2
5962: DOUBLE
5963: EQUAL
5964: IFTRUE 5968
5966: GO 6000
5968: POP
// begin crates := [ 100 , 150 , 350 , 500 ] [ bonus_num ] ;
5969: LD_ADDR_VAR 0 8
5973: PUSH
5974: LD_INT 100
5976: PUSH
5977: LD_INT 150
5979: PUSH
5980: LD_INT 350
5982: PUSH
5983: LD_INT 500
5985: PUSH
5986: EMPTY
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: PUSH
5992: LD_EXP 12
5996: ARRAY
5997: ST_TO_ADDR
// end ; 3 :
5998: GO 6368
6000: LD_INT 3
6002: DOUBLE
6003: EQUAL
6004: IFTRUE 6008
6006: GO 6348
6008: POP
// begin if bonus_num = 1 then
6009: LD_EXP 12
6013: PUSH
6014: LD_INT 1
6016: EQUAL
6017: IFFALSE 6027
// ignore_wave := true ;
6019: LD_ADDR_EXP 13
6023: PUSH
6024: LD_INT 1
6026: ST_TO_ADDR
// if bonus_num = 2 then
6027: LD_EXP 12
6031: PUSH
6032: LD_INT 2
6034: EQUAL
6035: IFFALSE 6155
// begin for i = 1 to 2 do
6037: LD_ADDR_VAR 0 10
6041: PUSH
6042: DOUBLE
6043: LD_INT 1
6045: DEC
6046: ST_TO_ADDR
6047: LD_INT 2
6049: PUSH
6050: FOR_TO
6051: IFFALSE 6153
// begin uc_nation := nation_arabian ;
6053: LD_ADDR_OWVAR 21
6057: PUSH
6058: LD_INT 2
6060: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6061: LD_ADDR_OWVAR 37
6065: PUSH
6066: LD_INT 14
6068: ST_TO_ADDR
// vc_engine := engine_siberite ;
6069: LD_ADDR_OWVAR 39
6073: PUSH
6074: LD_INT 3
6076: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6077: LD_ADDR_OWVAR 38
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 5
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 1
6094: PPUSH
6095: LD_INT 2
6097: PPUSH
6098: CALL_OW 12
6102: ARRAY
6103: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ rand ( 1 , 3 ) ] ;
6104: LD_ADDR_OWVAR 40
6108: PUSH
6109: LD_INT 28
6111: PUSH
6112: LD_INT 27
6114: PUSH
6115: LD_INT 25
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: LIST
6122: PUSH
6123: LD_INT 1
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 12
6133: ARRAY
6134: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6135: LD_ADDR_VAR 0 7
6139: PUSH
6140: LD_VAR 0 7
6144: PUSH
6145: CALL_OW 45
6149: ADD
6150: ST_TO_ADDR
// end ;
6151: GO 6050
6153: POP
6154: POP
// end ; if bonus_num = 3 then
6155: LD_EXP 12
6159: PUSH
6160: LD_INT 3
6162: EQUAL
6163: IFFALSE 6287
// begin for i = 1 to 4 do
6165: LD_ADDR_VAR 0 10
6169: PUSH
6170: DOUBLE
6171: LD_INT 1
6173: DEC
6174: ST_TO_ADDR
6175: LD_INT 4
6177: PUSH
6178: FOR_TO
6179: IFFALSE 6285
// begin uc_nation := nation_arabian ;
6181: LD_ADDR_OWVAR 21
6185: PUSH
6186: LD_INT 2
6188: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6189: LD_ADDR_OWVAR 37
6193: PUSH
6194: LD_INT 14
6196: ST_TO_ADDR
// vc_engine := engine_siberite ;
6197: LD_ADDR_OWVAR 39
6201: PUSH
6202: LD_INT 3
6204: ST_TO_ADDR
// vc_control := [ control_remote , control_apeman ] [ rand ( 1 , 2 ) ] ;
6205: LD_ADDR_OWVAR 38
6209: PUSH
6210: LD_INT 2
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 1
6222: PPUSH
6223: LD_INT 2
6225: PPUSH
6226: CALL_OW 12
6230: ARRAY
6231: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ rand ( 1 , 4 ) ] ;
6232: LD_ADDR_OWVAR 40
6236: PUSH
6237: LD_INT 28
6239: PUSH
6240: LD_INT 27
6242: PUSH
6243: LD_INT 28
6245: PUSH
6246: LD_INT 25
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 1
6257: PPUSH
6258: LD_INT 4
6260: PPUSH
6261: CALL_OW 12
6265: ARRAY
6266: ST_TO_ADDR
// units := units ^ CreateVehicle ;
6267: LD_ADDR_VAR 0 7
6271: PUSH
6272: LD_VAR 0 7
6276: PUSH
6277: CALL_OW 45
6281: ADD
6282: ST_TO_ADDR
// end ;
6283: GO 6178
6285: POP
6286: POP
// end ; if bonus_num = 4 then
6287: LD_EXP 12
6291: PUSH
6292: LD_INT 4
6294: EQUAL
6295: IFFALSE 6346
// for i = 1 to 3 do
6297: LD_ADDR_VAR 0 10
6301: PUSH
6302: DOUBLE
6303: LD_INT 1
6305: DEC
6306: ST_TO_ADDR
6307: LD_INT 3
6309: PUSH
6310: FOR_TO
6311: IFFALSE 6344
// begin PrepareHuman ( false , 3 , 8 ) ;
6313: LD_INT 0
6315: PPUSH
6316: LD_INT 3
6318: PPUSH
6319: LD_INT 8
6321: PPUSH
6322: CALL_OW 380
// units := units ^ CreateHuman ;
6326: LD_ADDR_VAR 0 7
6330: PUSH
6331: LD_VAR 0 7
6335: PUSH
6336: CALL_OW 44
6340: ADD
6341: ST_TO_ADDR
// end ;
6342: GO 6310
6344: POP
6345: POP
// end ; 4 :
6346: GO 6368
6348: LD_INT 4
6350: DOUBLE
6351: EQUAL
6352: IFTRUE 6356
6354: GO 6367
6356: POP
// off := false ; end ;
6357: LD_ADDR_VAR 0 6
6361: PUSH
6362: LD_INT 0
6364: ST_TO_ADDR
6365: GO 6368
6367: POP
// DialogueOff ;
6368: CALL_OW 7
// if not off then
6372: LD_VAR 0 6
6376: NOT
6377: IFFALSE 6383
// exit else
6379: GO 6562
6381: GO 6436
// begin SetArtifactUse ( your_side , art_use_exclamation , art_no , main_base ) ;
6383: LD_OWVAR 2
6387: PPUSH
6388: LD_INT 12
6390: PPUSH
6391: LD_INT 0
6393: PPUSH
6394: LD_INT 23
6396: PPUSH
6397: CALL_OW 468
// SayRadio ( Vervecken , [ DVr-3 , DVr-3a , DVr-3b ] [ rand ( 1 , 3 ) ] ) ;
6401: LD_EXP 10
6405: PPUSH
6406: LD_STRING DVr-3
6408: PUSH
6409: LD_STRING DVr-3a
6411: PUSH
6412: LD_STRING DVr-3b
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 1
6422: PPUSH
6423: LD_INT 3
6425: PPUSH
6426: CALL_OW 12
6430: ARRAY
6431: PPUSH
6432: CALL_OW 94
// end ; if units then
6436: LD_VAR 0 7
6440: IFFALSE 6504
// for i in units do
6442: LD_ADDR_VAR 0 10
6446: PUSH
6447: LD_VAR 0 7
6451: PUSH
6452: FOR_IN
6453: IFFALSE 6502
// begin PlaceUnitXYR ( i , 92 , 49 , 20 , false ) ;
6455: LD_VAR 0 10
6459: PPUSH
6460: LD_INT 92
6462: PPUSH
6463: LD_INT 49
6465: PPUSH
6466: LD_INT 20
6468: PPUSH
6469: LD_INT 0
6471: PPUSH
6472: CALL_OW 50
// EffectTeleport ( GetX ( i ) , GetY ( i ) ) ;
6476: LD_VAR 0 10
6480: PPUSH
6481: CALL_OW 250
6485: PPUSH
6486: LD_VAR 0 10
6490: PPUSH
6491: CALL_OW 251
6495: PPUSH
6496: CALL_OW 494
// end ;
6500: GO 6452
6502: POP
6503: POP
// if crates then
6504: LD_VAR 0 8
6508: IFFALSE 6562
// for i = 1 to ( crates div 50 ) do
6510: LD_ADDR_VAR 0 10
6514: PUSH
6515: DOUBLE
6516: LD_INT 1
6518: DEC
6519: ST_TO_ADDR
6520: LD_VAR 0 8
6524: PUSH
6525: LD_INT 50
6527: DIV
6528: PUSH
6529: FOR_TO
6530: IFFALSE 6560
// begin CreateCratesXYR ( 5 , 92 , 49 , 30 , true ) ;
6532: LD_INT 5
6534: PPUSH
6535: LD_INT 92
6537: PPUSH
6538: LD_INT 49
6540: PPUSH
6541: LD_INT 30
6543: PPUSH
6544: LD_INT 1
6546: PPUSH
6547: CALL_OW 56
// wait ( 0 0$02 ) ;
6551: LD_INT 70
6553: PPUSH
6554: CALL_OW 67
// end ;
6558: GO 6529
6560: POP
6561: POP
// end ;
6562: PPOPN 10
6564: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6565: LD_VAR 0 1
6569: PPUSH
6570: LD_VAR 0 2
6574: PPUSH
6575: LD_VAR 0 3
6579: PPUSH
6580: CALL 17716 0 3
// end ;
6584: PPOPN 3
6586: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: CALL 17724 0 1
// end ; end_of_file
6596: PPOPN 1
6598: END
// every 0 0$01 trigger not game_over do
6599: LD_EXP 7
6603: NOT
6604: IFFALSE 6637
6606: GO 6608
6608: DISABLE
// begin enable ;
6609: ENABLE
// display_strings := [ #tick , tick , #points , points ] ;
6610: LD_ADDR_OWVAR 47
6614: PUSH
6615: LD_STRING #tick
6617: PUSH
6618: LD_OWVAR 1
6622: PUSH
6623: LD_STRING #points
6625: PUSH
6626: LD_EXP 8
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: ST_TO_ADDR
// end ;
6637: END
// every 0 0$01 trigger game_over do
6638: LD_EXP 7
6642: IFFALSE 6701
6644: GO 6646
6646: DISABLE
// begin Wait ( 0 0$02 ) ;
6647: LD_INT 70
6649: PPUSH
6650: CALL_OW 67
// DialogueOn ;
6654: CALL_OW 6
// display_strings := [ #game-points , profile_name , points , #game-time , tick , #game-difficulty , difficulty ] ;
6658: LD_ADDR_OWVAR 47
6662: PUSH
6663: LD_STRING #game-points
6665: PUSH
6666: LD_OWVAR 78
6670: PUSH
6671: LD_EXP 8
6675: PUSH
6676: LD_STRING #game-time
6678: PUSH
6679: LD_OWVAR 1
6683: PUSH
6684: LD_STRING #game-difficulty
6686: PUSH
6687: LD_OWVAR 67
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// end ; end_of_file
6701: END
// every 2 2$10 + 0 0$30 trigger tick < 25 25$00 do
6702: LD_OWVAR 1
6706: PUSH
6707: LD_INT 52500
6709: LESS
6710: IFFALSE 6734
6712: GO 6714
6714: DISABLE
// begin enable ;
6715: ENABLE
// CreateCratesAnywhere ( rand ( 1 , 5 ) , true ) ;
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 5
6721: PPUSH
6722: CALL_OW 12
6726: PPUSH
6727: LD_INT 1
6729: PPUSH
6730: CALL_OW 57
// end ; end_of_file
6734: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
6735: GO 6737
6737: DISABLE
// begin ru_radar := 98 ;
6738: LD_ADDR_EXP 14
6742: PUSH
6743: LD_INT 98
6745: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
6746: LD_ADDR_EXP 15
6750: PUSH
6751: LD_INT 89
6753: ST_TO_ADDR
// us_hack := 99 ;
6754: LD_ADDR_EXP 16
6758: PUSH
6759: LD_INT 99
6761: ST_TO_ADDR
// us_artillery := 97 ;
6762: LD_ADDR_EXP 17
6766: PUSH
6767: LD_INT 97
6769: ST_TO_ADDR
// ar_bio_bomb := 91 ;
6770: LD_ADDR_EXP 18
6774: PUSH
6775: LD_INT 91
6777: ST_TO_ADDR
// end ; end_of_file end_of_file
6778: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6779: GO 6781
6781: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6782: LD_STRING initStreamRollete();
6784: PPUSH
6785: CALL_OW 559
// InitStreamMode ;
6789: CALL 6798 0 0
// DefineStreamItems ( ) ;
6793: CALL 7238 0 0
// end ;
6797: END
// function InitStreamMode ; begin
6798: LD_INT 0
6800: PPUSH
// streamModeActive := false ;
6801: LD_ADDR_EXP 19
6805: PUSH
6806: LD_INT 0
6808: ST_TO_ADDR
// normalCounter := 36 ;
6809: LD_ADDR_EXP 20
6813: PUSH
6814: LD_INT 36
6816: ST_TO_ADDR
// hardcoreCounter := 16 ;
6817: LD_ADDR_EXP 21
6821: PUSH
6822: LD_INT 16
6824: ST_TO_ADDR
// sRocket := false ;
6825: LD_ADDR_EXP 24
6829: PUSH
6830: LD_INT 0
6832: ST_TO_ADDR
// sSpeed := false ;
6833: LD_ADDR_EXP 23
6837: PUSH
6838: LD_INT 0
6840: ST_TO_ADDR
// sEngine := false ;
6841: LD_ADDR_EXP 25
6845: PUSH
6846: LD_INT 0
6848: ST_TO_ADDR
// sSpec := false ;
6849: LD_ADDR_EXP 22
6853: PUSH
6854: LD_INT 0
6856: ST_TO_ADDR
// sLevel := false ;
6857: LD_ADDR_EXP 26
6861: PUSH
6862: LD_INT 0
6864: ST_TO_ADDR
// sArmoury := false ;
6865: LD_ADDR_EXP 27
6869: PUSH
6870: LD_INT 0
6872: ST_TO_ADDR
// sRadar := false ;
6873: LD_ADDR_EXP 28
6877: PUSH
6878: LD_INT 0
6880: ST_TO_ADDR
// sBunker := false ;
6881: LD_ADDR_EXP 29
6885: PUSH
6886: LD_INT 0
6888: ST_TO_ADDR
// sHack := false ;
6889: LD_ADDR_EXP 30
6893: PUSH
6894: LD_INT 0
6896: ST_TO_ADDR
// sFire := false ;
6897: LD_ADDR_EXP 31
6901: PUSH
6902: LD_INT 0
6904: ST_TO_ADDR
// sRefresh := false ;
6905: LD_ADDR_EXP 32
6909: PUSH
6910: LD_INT 0
6912: ST_TO_ADDR
// sExp := false ;
6913: LD_ADDR_EXP 33
6917: PUSH
6918: LD_INT 0
6920: ST_TO_ADDR
// sDepot := false ;
6921: LD_ADDR_EXP 34
6925: PUSH
6926: LD_INT 0
6928: ST_TO_ADDR
// sFlag := false ;
6929: LD_ADDR_EXP 35
6933: PUSH
6934: LD_INT 0
6936: ST_TO_ADDR
// sKamikadze := false ;
6937: LD_ADDR_EXP 43
6941: PUSH
6942: LD_INT 0
6944: ST_TO_ADDR
// sTroll := false ;
6945: LD_ADDR_EXP 44
6949: PUSH
6950: LD_INT 0
6952: ST_TO_ADDR
// sSlow := false ;
6953: LD_ADDR_EXP 45
6957: PUSH
6958: LD_INT 0
6960: ST_TO_ADDR
// sLack := false ;
6961: LD_ADDR_EXP 46
6965: PUSH
6966: LD_INT 0
6968: ST_TO_ADDR
// sTank := false ;
6969: LD_ADDR_EXP 48
6973: PUSH
6974: LD_INT 0
6976: ST_TO_ADDR
// sRemote := false ;
6977: LD_ADDR_EXP 49
6981: PUSH
6982: LD_INT 0
6984: ST_TO_ADDR
// sPowell := false ;
6985: LD_ADDR_EXP 50
6989: PUSH
6990: LD_INT 0
6992: ST_TO_ADDR
// sTeleport := false ;
6993: LD_ADDR_EXP 53
6997: PUSH
6998: LD_INT 0
7000: ST_TO_ADDR
// sOilTower := false ;
7001: LD_ADDR_EXP 55
7005: PUSH
7006: LD_INT 0
7008: ST_TO_ADDR
// sShovel := false ;
7009: LD_ADDR_EXP 56
7013: PUSH
7014: LD_INT 0
7016: ST_TO_ADDR
// sSheik := false ;
7017: LD_ADDR_EXP 57
7021: PUSH
7022: LD_INT 0
7024: ST_TO_ADDR
// sEarthquake := false ;
7025: LD_ADDR_EXP 59
7029: PUSH
7030: LD_INT 0
7032: ST_TO_ADDR
// sAI := false ;
7033: LD_ADDR_EXP 60
7037: PUSH
7038: LD_INT 0
7040: ST_TO_ADDR
// sCargo := false ;
7041: LD_ADDR_EXP 63
7045: PUSH
7046: LD_INT 0
7048: ST_TO_ADDR
// sDLaser := false ;
7049: LD_ADDR_EXP 64
7053: PUSH
7054: LD_INT 0
7056: ST_TO_ADDR
// sExchange := false ;
7057: LD_ADDR_EXP 65
7061: PUSH
7062: LD_INT 0
7064: ST_TO_ADDR
// sFac := false ;
7065: LD_ADDR_EXP 66
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// sPower := false ;
7073: LD_ADDR_EXP 67
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// sRandom := false ;
7081: LD_ADDR_EXP 68
7085: PUSH
7086: LD_INT 0
7088: ST_TO_ADDR
// sShield := false ;
7089: LD_ADDR_EXP 69
7093: PUSH
7094: LD_INT 0
7096: ST_TO_ADDR
// sTime := false ;
7097: LD_ADDR_EXP 70
7101: PUSH
7102: LD_INT 0
7104: ST_TO_ADDR
// sTools := false ;
7105: LD_ADDR_EXP 71
7109: PUSH
7110: LD_INT 0
7112: ST_TO_ADDR
// sSold := false ;
7113: LD_ADDR_EXP 36
7117: PUSH
7118: LD_INT 0
7120: ST_TO_ADDR
// sDiff := false ;
7121: LD_ADDR_EXP 37
7125: PUSH
7126: LD_INT 0
7128: ST_TO_ADDR
// sFog := false ;
7129: LD_ADDR_EXP 40
7133: PUSH
7134: LD_INT 0
7136: ST_TO_ADDR
// sReset := false ;
7137: LD_ADDR_EXP 41
7141: PUSH
7142: LD_INT 0
7144: ST_TO_ADDR
// sSun := false ;
7145: LD_ADDR_EXP 42
7149: PUSH
7150: LD_INT 0
7152: ST_TO_ADDR
// sTiger := false ;
7153: LD_ADDR_EXP 38
7157: PUSH
7158: LD_INT 0
7160: ST_TO_ADDR
// sBomb := false ;
7161: LD_ADDR_EXP 39
7165: PUSH
7166: LD_INT 0
7168: ST_TO_ADDR
// sWound := false ;
7169: LD_ADDR_EXP 47
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// sBetray := false ;
7177: LD_ADDR_EXP 51
7181: PUSH
7182: LD_INT 0
7184: ST_TO_ADDR
// sContamin := false ;
7185: LD_ADDR_EXP 52
7189: PUSH
7190: LD_INT 0
7192: ST_TO_ADDR
// sOil := false ;
7193: LD_ADDR_EXP 54
7197: PUSH
7198: LD_INT 0
7200: ST_TO_ADDR
// sStu := false ;
7201: LD_ADDR_EXP 58
7205: PUSH
7206: LD_INT 0
7208: ST_TO_ADDR
// sBazooka := false ;
7209: LD_ADDR_EXP 61
7213: PUSH
7214: LD_INT 0
7216: ST_TO_ADDR
// sMortar := false ;
7217: LD_ADDR_EXP 62
7221: PUSH
7222: LD_INT 0
7224: ST_TO_ADDR
// sRanger := false ;
7225: LD_ADDR_EXP 72
7229: PUSH
7230: LD_INT 0
7232: ST_TO_ADDR
// end ;
7233: LD_VAR 0 1
7237: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
7238: LD_INT 0
7240: PPUSH
7241: PPUSH
7242: PPUSH
7243: PPUSH
7244: PPUSH
// result := [ ] ;
7245: LD_ADDR_VAR 0 1
7249: PUSH
7250: EMPTY
7251: ST_TO_ADDR
// if campaign_id = 1 then
7252: LD_OWVAR 69
7256: PUSH
7257: LD_INT 1
7259: EQUAL
7260: IFFALSE 10198
// begin case mission_number of 1 :
7262: LD_OWVAR 70
7266: PUSH
7267: LD_INT 1
7269: DOUBLE
7270: EQUAL
7271: IFTRUE 7275
7273: GO 7339
7275: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
7276: LD_ADDR_VAR 0 1
7280: PUSH
7281: LD_INT 2
7283: PUSH
7284: LD_INT 4
7286: PUSH
7287: LD_INT 11
7289: PUSH
7290: LD_INT 12
7292: PUSH
7293: LD_INT 15
7295: PUSH
7296: LD_INT 16
7298: PUSH
7299: LD_INT 22
7301: PUSH
7302: LD_INT 23
7304: PUSH
7305: LD_INT 26
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: LIST
7315: LIST
7316: LIST
7317: LIST
7318: PUSH
7319: LD_INT 101
7321: PUSH
7322: LD_INT 102
7324: PUSH
7325: LD_INT 106
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: ST_TO_ADDR
7337: GO 10196
7339: LD_INT 2
7341: DOUBLE
7342: EQUAL
7343: IFTRUE 7347
7345: GO 7419
7347: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7348: LD_ADDR_VAR 0 1
7352: PUSH
7353: LD_INT 2
7355: PUSH
7356: LD_INT 4
7358: PUSH
7359: LD_INT 11
7361: PUSH
7362: LD_INT 12
7364: PUSH
7365: LD_INT 15
7367: PUSH
7368: LD_INT 16
7370: PUSH
7371: LD_INT 22
7373: PUSH
7374: LD_INT 23
7376: PUSH
7377: LD_INT 26
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PUSH
7391: LD_INT 101
7393: PUSH
7394: LD_INT 102
7396: PUSH
7397: LD_INT 105
7399: PUSH
7400: LD_INT 106
7402: PUSH
7403: LD_INT 108
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: LIST
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: ST_TO_ADDR
7417: GO 10196
7419: LD_INT 3
7421: DOUBLE
7422: EQUAL
7423: IFTRUE 7427
7425: GO 7503
7427: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7428: LD_ADDR_VAR 0 1
7432: PUSH
7433: LD_INT 2
7435: PUSH
7436: LD_INT 4
7438: PUSH
7439: LD_INT 5
7441: PUSH
7442: LD_INT 11
7444: PUSH
7445: LD_INT 12
7447: PUSH
7448: LD_INT 15
7450: PUSH
7451: LD_INT 16
7453: PUSH
7454: LD_INT 22
7456: PUSH
7457: LD_INT 26
7459: PUSH
7460: LD_INT 36
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: LIST
7474: PUSH
7475: LD_INT 101
7477: PUSH
7478: LD_INT 102
7480: PUSH
7481: LD_INT 105
7483: PUSH
7484: LD_INT 106
7486: PUSH
7487: LD_INT 108
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: ST_TO_ADDR
7501: GO 10196
7503: LD_INT 4
7505: DOUBLE
7506: EQUAL
7507: IFTRUE 7511
7509: GO 7595
7511: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7512: LD_ADDR_VAR 0 1
7516: PUSH
7517: LD_INT 2
7519: PUSH
7520: LD_INT 4
7522: PUSH
7523: LD_INT 5
7525: PUSH
7526: LD_INT 8
7528: PUSH
7529: LD_INT 11
7531: PUSH
7532: LD_INT 12
7534: PUSH
7535: LD_INT 15
7537: PUSH
7538: LD_INT 16
7540: PUSH
7541: LD_INT 22
7543: PUSH
7544: LD_INT 23
7546: PUSH
7547: LD_INT 26
7549: PUSH
7550: LD_INT 36
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 101
7569: PUSH
7570: LD_INT 102
7572: PUSH
7573: LD_INT 105
7575: PUSH
7576: LD_INT 106
7578: PUSH
7579: LD_INT 108
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: ST_TO_ADDR
7593: GO 10196
7595: LD_INT 5
7597: DOUBLE
7598: EQUAL
7599: IFTRUE 7603
7601: GO 7703
7603: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7604: LD_ADDR_VAR 0 1
7608: PUSH
7609: LD_INT 2
7611: PUSH
7612: LD_INT 4
7614: PUSH
7615: LD_INT 5
7617: PUSH
7618: LD_INT 6
7620: PUSH
7621: LD_INT 8
7623: PUSH
7624: LD_INT 11
7626: PUSH
7627: LD_INT 12
7629: PUSH
7630: LD_INT 15
7632: PUSH
7633: LD_INT 16
7635: PUSH
7636: LD_INT 22
7638: PUSH
7639: LD_INT 23
7641: PUSH
7642: LD_INT 25
7644: PUSH
7645: LD_INT 26
7647: PUSH
7648: LD_INT 36
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: LIST
7659: LIST
7660: LIST
7661: LIST
7662: LIST
7663: LIST
7664: LIST
7665: LIST
7666: PUSH
7667: LD_INT 101
7669: PUSH
7670: LD_INT 102
7672: PUSH
7673: LD_INT 105
7675: PUSH
7676: LD_INT 106
7678: PUSH
7679: LD_INT 108
7681: PUSH
7682: LD_INT 109
7684: PUSH
7685: LD_INT 112
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: LIST
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: ST_TO_ADDR
7701: GO 10196
7703: LD_INT 6
7705: DOUBLE
7706: EQUAL
7707: IFTRUE 7711
7709: GO 7831
7711: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7712: LD_ADDR_VAR 0 1
7716: PUSH
7717: LD_INT 2
7719: PUSH
7720: LD_INT 4
7722: PUSH
7723: LD_INT 5
7725: PUSH
7726: LD_INT 6
7728: PUSH
7729: LD_INT 8
7731: PUSH
7732: LD_INT 11
7734: PUSH
7735: LD_INT 12
7737: PUSH
7738: LD_INT 15
7740: PUSH
7741: LD_INT 16
7743: PUSH
7744: LD_INT 20
7746: PUSH
7747: LD_INT 21
7749: PUSH
7750: LD_INT 22
7752: PUSH
7753: LD_INT 23
7755: PUSH
7756: LD_INT 25
7758: PUSH
7759: LD_INT 26
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 31
7767: PUSH
7768: LD_INT 32
7770: PUSH
7771: LD_INT 36
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: LIST
7789: LIST
7790: LIST
7791: LIST
7792: LIST
7793: LIST
7794: PUSH
7795: LD_INT 101
7797: PUSH
7798: LD_INT 102
7800: PUSH
7801: LD_INT 105
7803: PUSH
7804: LD_INT 106
7806: PUSH
7807: LD_INT 108
7809: PUSH
7810: LD_INT 109
7812: PUSH
7813: LD_INT 112
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: LIST
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: ST_TO_ADDR
7829: GO 10196
7831: LD_INT 7
7833: DOUBLE
7834: EQUAL
7835: IFTRUE 7839
7837: GO 7939
7839: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7840: LD_ADDR_VAR 0 1
7844: PUSH
7845: LD_INT 2
7847: PUSH
7848: LD_INT 4
7850: PUSH
7851: LD_INT 5
7853: PUSH
7854: LD_INT 7
7856: PUSH
7857: LD_INT 11
7859: PUSH
7860: LD_INT 12
7862: PUSH
7863: LD_INT 15
7865: PUSH
7866: LD_INT 16
7868: PUSH
7869: LD_INT 20
7871: PUSH
7872: LD_INT 21
7874: PUSH
7875: LD_INT 22
7877: PUSH
7878: LD_INT 23
7880: PUSH
7881: LD_INT 25
7883: PUSH
7884: LD_INT 26
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: LIST
7893: LIST
7894: LIST
7895: LIST
7896: LIST
7897: LIST
7898: LIST
7899: LIST
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 101
7905: PUSH
7906: LD_INT 102
7908: PUSH
7909: LD_INT 103
7911: PUSH
7912: LD_INT 105
7914: PUSH
7915: LD_INT 106
7917: PUSH
7918: LD_INT 108
7920: PUSH
7921: LD_INT 112
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: LIST
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: ST_TO_ADDR
7937: GO 10196
7939: LD_INT 8
7941: DOUBLE
7942: EQUAL
7943: IFTRUE 7947
7945: GO 8075
7947: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
7948: LD_ADDR_VAR 0 1
7952: PUSH
7953: LD_INT 2
7955: PUSH
7956: LD_INT 4
7958: PUSH
7959: LD_INT 5
7961: PUSH
7962: LD_INT 6
7964: PUSH
7965: LD_INT 7
7967: PUSH
7968: LD_INT 8
7970: PUSH
7971: LD_INT 11
7973: PUSH
7974: LD_INT 12
7976: PUSH
7977: LD_INT 15
7979: PUSH
7980: LD_INT 16
7982: PUSH
7983: LD_INT 20
7985: PUSH
7986: LD_INT 21
7988: PUSH
7989: LD_INT 22
7991: PUSH
7992: LD_INT 23
7994: PUSH
7995: LD_INT 25
7997: PUSH
7998: LD_INT 26
8000: PUSH
8001: LD_INT 30
8003: PUSH
8004: LD_INT 31
8006: PUSH
8007: LD_INT 32
8009: PUSH
8010: LD_INT 36
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: LIST
8033: LIST
8034: PUSH
8035: LD_INT 101
8037: PUSH
8038: LD_INT 102
8040: PUSH
8041: LD_INT 103
8043: PUSH
8044: LD_INT 105
8046: PUSH
8047: LD_INT 106
8049: PUSH
8050: LD_INT 108
8052: PUSH
8053: LD_INT 109
8055: PUSH
8056: LD_INT 112
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: ST_TO_ADDR
8073: GO 10196
8075: LD_INT 9
8077: DOUBLE
8078: EQUAL
8079: IFTRUE 8083
8081: GO 8219
8083: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
8084: LD_ADDR_VAR 0 1
8088: PUSH
8089: LD_INT 2
8091: PUSH
8092: LD_INT 4
8094: PUSH
8095: LD_INT 5
8097: PUSH
8098: LD_INT 6
8100: PUSH
8101: LD_INT 7
8103: PUSH
8104: LD_INT 8
8106: PUSH
8107: LD_INT 11
8109: PUSH
8110: LD_INT 12
8112: PUSH
8113: LD_INT 15
8115: PUSH
8116: LD_INT 16
8118: PUSH
8119: LD_INT 20
8121: PUSH
8122: LD_INT 21
8124: PUSH
8125: LD_INT 22
8127: PUSH
8128: LD_INT 23
8130: PUSH
8131: LD_INT 25
8133: PUSH
8134: LD_INT 26
8136: PUSH
8137: LD_INT 28
8139: PUSH
8140: LD_INT 30
8142: PUSH
8143: LD_INT 31
8145: PUSH
8146: LD_INT 32
8148: PUSH
8149: LD_INT 36
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: LIST
8159: LIST
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: LIST
8169: LIST
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: PUSH
8175: LD_INT 101
8177: PUSH
8178: LD_INT 102
8180: PUSH
8181: LD_INT 103
8183: PUSH
8184: LD_INT 105
8186: PUSH
8187: LD_INT 106
8189: PUSH
8190: LD_INT 108
8192: PUSH
8193: LD_INT 109
8195: PUSH
8196: LD_INT 112
8198: PUSH
8199: LD_INT 114
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: ST_TO_ADDR
8217: GO 10196
8219: LD_INT 10
8221: DOUBLE
8222: EQUAL
8223: IFTRUE 8227
8225: GO 8411
8227: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
8228: LD_ADDR_VAR 0 1
8232: PUSH
8233: LD_INT 2
8235: PUSH
8236: LD_INT 4
8238: PUSH
8239: LD_INT 5
8241: PUSH
8242: LD_INT 6
8244: PUSH
8245: LD_INT 7
8247: PUSH
8248: LD_INT 8
8250: PUSH
8251: LD_INT 9
8253: PUSH
8254: LD_INT 10
8256: PUSH
8257: LD_INT 11
8259: PUSH
8260: LD_INT 12
8262: PUSH
8263: LD_INT 13
8265: PUSH
8266: LD_INT 14
8268: PUSH
8269: LD_INT 15
8271: PUSH
8272: LD_INT 16
8274: PUSH
8275: LD_INT 17
8277: PUSH
8278: LD_INT 18
8280: PUSH
8281: LD_INT 19
8283: PUSH
8284: LD_INT 20
8286: PUSH
8287: LD_INT 21
8289: PUSH
8290: LD_INT 22
8292: PUSH
8293: LD_INT 23
8295: PUSH
8296: LD_INT 24
8298: PUSH
8299: LD_INT 25
8301: PUSH
8302: LD_INT 26
8304: PUSH
8305: LD_INT 28
8307: PUSH
8308: LD_INT 30
8310: PUSH
8311: LD_INT 31
8313: PUSH
8314: LD_INT 32
8316: PUSH
8317: LD_INT 36
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: LIST
8328: LIST
8329: LIST
8330: LIST
8331: LIST
8332: LIST
8333: LIST
8334: LIST
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: LIST
8340: LIST
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: LIST
8350: PUSH
8351: LD_INT 101
8353: PUSH
8354: LD_INT 102
8356: PUSH
8357: LD_INT 103
8359: PUSH
8360: LD_INT 104
8362: PUSH
8363: LD_INT 105
8365: PUSH
8366: LD_INT 106
8368: PUSH
8369: LD_INT 107
8371: PUSH
8372: LD_INT 108
8374: PUSH
8375: LD_INT 109
8377: PUSH
8378: LD_INT 110
8380: PUSH
8381: LD_INT 111
8383: PUSH
8384: LD_INT 112
8386: PUSH
8387: LD_INT 114
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: LIST
8402: LIST
8403: LIST
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: ST_TO_ADDR
8409: GO 10196
8411: LD_INT 11
8413: DOUBLE
8414: EQUAL
8415: IFTRUE 8419
8417: GO 8611
8419: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8420: LD_ADDR_VAR 0 1
8424: PUSH
8425: LD_INT 2
8427: PUSH
8428: LD_INT 3
8430: PUSH
8431: LD_INT 4
8433: PUSH
8434: LD_INT 5
8436: PUSH
8437: LD_INT 6
8439: PUSH
8440: LD_INT 7
8442: PUSH
8443: LD_INT 8
8445: PUSH
8446: LD_INT 9
8448: PUSH
8449: LD_INT 10
8451: PUSH
8452: LD_INT 11
8454: PUSH
8455: LD_INT 12
8457: PUSH
8458: LD_INT 13
8460: PUSH
8461: LD_INT 14
8463: PUSH
8464: LD_INT 15
8466: PUSH
8467: LD_INT 16
8469: PUSH
8470: LD_INT 17
8472: PUSH
8473: LD_INT 18
8475: PUSH
8476: LD_INT 19
8478: PUSH
8479: LD_INT 20
8481: PUSH
8482: LD_INT 21
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 23
8490: PUSH
8491: LD_INT 24
8493: PUSH
8494: LD_INT 25
8496: PUSH
8497: LD_INT 26
8499: PUSH
8500: LD_INT 28
8502: PUSH
8503: LD_INT 30
8505: PUSH
8506: LD_INT 31
8508: PUSH
8509: LD_INT 32
8511: PUSH
8512: LD_INT 34
8514: PUSH
8515: LD_INT 36
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: LIST
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: LIST
8540: LIST
8541: LIST
8542: LIST
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_INT 101
8553: PUSH
8554: LD_INT 102
8556: PUSH
8557: LD_INT 103
8559: PUSH
8560: LD_INT 104
8562: PUSH
8563: LD_INT 105
8565: PUSH
8566: LD_INT 106
8568: PUSH
8569: LD_INT 107
8571: PUSH
8572: LD_INT 108
8574: PUSH
8575: LD_INT 109
8577: PUSH
8578: LD_INT 110
8580: PUSH
8581: LD_INT 111
8583: PUSH
8584: LD_INT 112
8586: PUSH
8587: LD_INT 114
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: ST_TO_ADDR
8609: GO 10196
8611: LD_INT 12
8613: DOUBLE
8614: EQUAL
8615: IFTRUE 8619
8617: GO 8827
8619: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8620: LD_ADDR_VAR 0 1
8624: PUSH
8625: LD_INT 1
8627: PUSH
8628: LD_INT 2
8630: PUSH
8631: LD_INT 3
8633: PUSH
8634: LD_INT 4
8636: PUSH
8637: LD_INT 5
8639: PUSH
8640: LD_INT 6
8642: PUSH
8643: LD_INT 7
8645: PUSH
8646: LD_INT 8
8648: PUSH
8649: LD_INT 9
8651: PUSH
8652: LD_INT 10
8654: PUSH
8655: LD_INT 11
8657: PUSH
8658: LD_INT 12
8660: PUSH
8661: LD_INT 13
8663: PUSH
8664: LD_INT 14
8666: PUSH
8667: LD_INT 15
8669: PUSH
8670: LD_INT 16
8672: PUSH
8673: LD_INT 17
8675: PUSH
8676: LD_INT 18
8678: PUSH
8679: LD_INT 19
8681: PUSH
8682: LD_INT 20
8684: PUSH
8685: LD_INT 21
8687: PUSH
8688: LD_INT 22
8690: PUSH
8691: LD_INT 23
8693: PUSH
8694: LD_INT 24
8696: PUSH
8697: LD_INT 25
8699: PUSH
8700: LD_INT 26
8702: PUSH
8703: LD_INT 27
8705: PUSH
8706: LD_INT 28
8708: PUSH
8709: LD_INT 30
8711: PUSH
8712: LD_INT 31
8714: PUSH
8715: LD_INT 32
8717: PUSH
8718: LD_INT 33
8720: PUSH
8721: LD_INT 34
8723: PUSH
8724: LD_INT 36
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: LIST
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_INT 101
8765: PUSH
8766: LD_INT 102
8768: PUSH
8769: LD_INT 103
8771: PUSH
8772: LD_INT 104
8774: PUSH
8775: LD_INT 105
8777: PUSH
8778: LD_INT 106
8780: PUSH
8781: LD_INT 107
8783: PUSH
8784: LD_INT 108
8786: PUSH
8787: LD_INT 109
8789: PUSH
8790: LD_INT 110
8792: PUSH
8793: LD_INT 111
8795: PUSH
8796: LD_INT 112
8798: PUSH
8799: LD_INT 113
8801: PUSH
8802: LD_INT 114
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: ST_TO_ADDR
8825: GO 10196
8827: LD_INT 13
8829: DOUBLE
8830: EQUAL
8831: IFTRUE 8835
8833: GO 9031
8835: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: LD_INT 1
8843: PUSH
8844: LD_INT 2
8846: PUSH
8847: LD_INT 3
8849: PUSH
8850: LD_INT 4
8852: PUSH
8853: LD_INT 5
8855: PUSH
8856: LD_INT 8
8858: PUSH
8859: LD_INT 9
8861: PUSH
8862: LD_INT 10
8864: PUSH
8865: LD_INT 11
8867: PUSH
8868: LD_INT 12
8870: PUSH
8871: LD_INT 14
8873: PUSH
8874: LD_INT 15
8876: PUSH
8877: LD_INT 16
8879: PUSH
8880: LD_INT 17
8882: PUSH
8883: LD_INT 18
8885: PUSH
8886: LD_INT 19
8888: PUSH
8889: LD_INT 20
8891: PUSH
8892: LD_INT 21
8894: PUSH
8895: LD_INT 22
8897: PUSH
8898: LD_INT 23
8900: PUSH
8901: LD_INT 24
8903: PUSH
8904: LD_INT 25
8906: PUSH
8907: LD_INT 26
8909: PUSH
8910: LD_INT 27
8912: PUSH
8913: LD_INT 28
8915: PUSH
8916: LD_INT 30
8918: PUSH
8919: LD_INT 31
8921: PUSH
8922: LD_INT 32
8924: PUSH
8925: LD_INT 33
8927: PUSH
8928: LD_INT 34
8930: PUSH
8931: LD_INT 36
8933: PUSH
8934: EMPTY
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: LIST
8940: LIST
8941: LIST
8942: LIST
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: LIST
8963: LIST
8964: LIST
8965: LIST
8966: PUSH
8967: LD_INT 101
8969: PUSH
8970: LD_INT 102
8972: PUSH
8973: LD_INT 103
8975: PUSH
8976: LD_INT 104
8978: PUSH
8979: LD_INT 105
8981: PUSH
8982: LD_INT 106
8984: PUSH
8985: LD_INT 107
8987: PUSH
8988: LD_INT 108
8990: PUSH
8991: LD_INT 109
8993: PUSH
8994: LD_INT 110
8996: PUSH
8997: LD_INT 111
8999: PUSH
9000: LD_INT 112
9002: PUSH
9003: LD_INT 113
9005: PUSH
9006: LD_INT 114
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: LIST
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: LIST
9021: LIST
9022: LIST
9023: LIST
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: ST_TO_ADDR
9029: GO 10196
9031: LD_INT 14
9033: DOUBLE
9034: EQUAL
9035: IFTRUE 9039
9037: GO 9251
9039: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
9040: LD_ADDR_VAR 0 1
9044: PUSH
9045: LD_INT 1
9047: PUSH
9048: LD_INT 2
9050: PUSH
9051: LD_INT 3
9053: PUSH
9054: LD_INT 4
9056: PUSH
9057: LD_INT 5
9059: PUSH
9060: LD_INT 6
9062: PUSH
9063: LD_INT 7
9065: PUSH
9066: LD_INT 8
9068: PUSH
9069: LD_INT 9
9071: PUSH
9072: LD_INT 10
9074: PUSH
9075: LD_INT 11
9077: PUSH
9078: LD_INT 12
9080: PUSH
9081: LD_INT 13
9083: PUSH
9084: LD_INT 14
9086: PUSH
9087: LD_INT 15
9089: PUSH
9090: LD_INT 16
9092: PUSH
9093: LD_INT 17
9095: PUSH
9096: LD_INT 18
9098: PUSH
9099: LD_INT 19
9101: PUSH
9102: LD_INT 20
9104: PUSH
9105: LD_INT 21
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_INT 23
9113: PUSH
9114: LD_INT 24
9116: PUSH
9117: LD_INT 25
9119: PUSH
9120: LD_INT 26
9122: PUSH
9123: LD_INT 27
9125: PUSH
9126: LD_INT 28
9128: PUSH
9129: LD_INT 29
9131: PUSH
9132: LD_INT 30
9134: PUSH
9135: LD_INT 31
9137: PUSH
9138: LD_INT 32
9140: PUSH
9141: LD_INT 33
9143: PUSH
9144: LD_INT 34
9146: PUSH
9147: LD_INT 36
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: LIST
9180: LIST
9181: LIST
9182: LIST
9183: LIST
9184: LIST
9185: LIST
9186: PUSH
9187: LD_INT 101
9189: PUSH
9190: LD_INT 102
9192: PUSH
9193: LD_INT 103
9195: PUSH
9196: LD_INT 104
9198: PUSH
9199: LD_INT 105
9201: PUSH
9202: LD_INT 106
9204: PUSH
9205: LD_INT 107
9207: PUSH
9208: LD_INT 108
9210: PUSH
9211: LD_INT 109
9213: PUSH
9214: LD_INT 110
9216: PUSH
9217: LD_INT 111
9219: PUSH
9220: LD_INT 112
9222: PUSH
9223: LD_INT 113
9225: PUSH
9226: LD_INT 114
9228: PUSH
9229: EMPTY
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: ST_TO_ADDR
9249: GO 10196
9251: LD_INT 15
9253: DOUBLE
9254: EQUAL
9255: IFTRUE 9259
9257: GO 9471
9259: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
9260: LD_ADDR_VAR 0 1
9264: PUSH
9265: LD_INT 1
9267: PUSH
9268: LD_INT 2
9270: PUSH
9271: LD_INT 3
9273: PUSH
9274: LD_INT 4
9276: PUSH
9277: LD_INT 5
9279: PUSH
9280: LD_INT 6
9282: PUSH
9283: LD_INT 7
9285: PUSH
9286: LD_INT 8
9288: PUSH
9289: LD_INT 9
9291: PUSH
9292: LD_INT 10
9294: PUSH
9295: LD_INT 11
9297: PUSH
9298: LD_INT 12
9300: PUSH
9301: LD_INT 13
9303: PUSH
9304: LD_INT 14
9306: PUSH
9307: LD_INT 15
9309: PUSH
9310: LD_INT 16
9312: PUSH
9313: LD_INT 17
9315: PUSH
9316: LD_INT 18
9318: PUSH
9319: LD_INT 19
9321: PUSH
9322: LD_INT 20
9324: PUSH
9325: LD_INT 21
9327: PUSH
9328: LD_INT 22
9330: PUSH
9331: LD_INT 23
9333: PUSH
9334: LD_INT 24
9336: PUSH
9337: LD_INT 25
9339: PUSH
9340: LD_INT 26
9342: PUSH
9343: LD_INT 27
9345: PUSH
9346: LD_INT 28
9348: PUSH
9349: LD_INT 29
9351: PUSH
9352: LD_INT 30
9354: PUSH
9355: LD_INT 31
9357: PUSH
9358: LD_INT 32
9360: PUSH
9361: LD_INT 33
9363: PUSH
9364: LD_INT 34
9366: PUSH
9367: LD_INT 36
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: PUSH
9407: LD_INT 101
9409: PUSH
9410: LD_INT 102
9412: PUSH
9413: LD_INT 103
9415: PUSH
9416: LD_INT 104
9418: PUSH
9419: LD_INT 105
9421: PUSH
9422: LD_INT 106
9424: PUSH
9425: LD_INT 107
9427: PUSH
9428: LD_INT 108
9430: PUSH
9431: LD_INT 109
9433: PUSH
9434: LD_INT 110
9436: PUSH
9437: LD_INT 111
9439: PUSH
9440: LD_INT 112
9442: PUSH
9443: LD_INT 113
9445: PUSH
9446: LD_INT 114
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: LIST
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: ST_TO_ADDR
9469: GO 10196
9471: LD_INT 16
9473: DOUBLE
9474: EQUAL
9475: IFTRUE 9479
9477: GO 9603
9479: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9480: LD_ADDR_VAR 0 1
9484: PUSH
9485: LD_INT 2
9487: PUSH
9488: LD_INT 4
9490: PUSH
9491: LD_INT 5
9493: PUSH
9494: LD_INT 7
9496: PUSH
9497: LD_INT 11
9499: PUSH
9500: LD_INT 12
9502: PUSH
9503: LD_INT 15
9505: PUSH
9506: LD_INT 16
9508: PUSH
9509: LD_INT 20
9511: PUSH
9512: LD_INT 21
9514: PUSH
9515: LD_INT 22
9517: PUSH
9518: LD_INT 23
9520: PUSH
9521: LD_INT 25
9523: PUSH
9524: LD_INT 26
9526: PUSH
9527: LD_INT 30
9529: PUSH
9530: LD_INT 31
9532: PUSH
9533: LD_INT 32
9535: PUSH
9536: LD_INT 33
9538: PUSH
9539: LD_INT 34
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: PUSH
9563: LD_INT 101
9565: PUSH
9566: LD_INT 102
9568: PUSH
9569: LD_INT 103
9571: PUSH
9572: LD_INT 106
9574: PUSH
9575: LD_INT 108
9577: PUSH
9578: LD_INT 112
9580: PUSH
9581: LD_INT 113
9583: PUSH
9584: LD_INT 114
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: ST_TO_ADDR
9601: GO 10196
9603: LD_INT 17
9605: DOUBLE
9606: EQUAL
9607: IFTRUE 9611
9609: GO 9823
9611: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9612: LD_ADDR_VAR 0 1
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: LD_INT 2
9622: PUSH
9623: LD_INT 3
9625: PUSH
9626: LD_INT 4
9628: PUSH
9629: LD_INT 5
9631: PUSH
9632: LD_INT 6
9634: PUSH
9635: LD_INT 7
9637: PUSH
9638: LD_INT 8
9640: PUSH
9641: LD_INT 9
9643: PUSH
9644: LD_INT 10
9646: PUSH
9647: LD_INT 11
9649: PUSH
9650: LD_INT 12
9652: PUSH
9653: LD_INT 13
9655: PUSH
9656: LD_INT 14
9658: PUSH
9659: LD_INT 15
9661: PUSH
9662: LD_INT 16
9664: PUSH
9665: LD_INT 17
9667: PUSH
9668: LD_INT 18
9670: PUSH
9671: LD_INT 19
9673: PUSH
9674: LD_INT 20
9676: PUSH
9677: LD_INT 21
9679: PUSH
9680: LD_INT 22
9682: PUSH
9683: LD_INT 23
9685: PUSH
9686: LD_INT 24
9688: PUSH
9689: LD_INT 25
9691: PUSH
9692: LD_INT 26
9694: PUSH
9695: LD_INT 27
9697: PUSH
9698: LD_INT 28
9700: PUSH
9701: LD_INT 29
9703: PUSH
9704: LD_INT 30
9706: PUSH
9707: LD_INT 31
9709: PUSH
9710: LD_INT 32
9712: PUSH
9713: LD_INT 33
9715: PUSH
9716: LD_INT 34
9718: PUSH
9719: LD_INT 36
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: LIST
9735: LIST
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: LIST
9747: LIST
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 101
9761: PUSH
9762: LD_INT 102
9764: PUSH
9765: LD_INT 103
9767: PUSH
9768: LD_INT 104
9770: PUSH
9771: LD_INT 105
9773: PUSH
9774: LD_INT 106
9776: PUSH
9777: LD_INT 107
9779: PUSH
9780: LD_INT 108
9782: PUSH
9783: LD_INT 109
9785: PUSH
9786: LD_INT 110
9788: PUSH
9789: LD_INT 111
9791: PUSH
9792: LD_INT 112
9794: PUSH
9795: LD_INT 113
9797: PUSH
9798: LD_INT 114
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: ST_TO_ADDR
9821: GO 10196
9823: LD_INT 18
9825: DOUBLE
9826: EQUAL
9827: IFTRUE 9831
9829: GO 9967
9831: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9832: LD_ADDR_VAR 0 1
9836: PUSH
9837: LD_INT 2
9839: PUSH
9840: LD_INT 4
9842: PUSH
9843: LD_INT 5
9845: PUSH
9846: LD_INT 7
9848: PUSH
9849: LD_INT 11
9851: PUSH
9852: LD_INT 12
9854: PUSH
9855: LD_INT 15
9857: PUSH
9858: LD_INT 16
9860: PUSH
9861: LD_INT 20
9863: PUSH
9864: LD_INT 21
9866: PUSH
9867: LD_INT 22
9869: PUSH
9870: LD_INT 23
9872: PUSH
9873: LD_INT 25
9875: PUSH
9876: LD_INT 26
9878: PUSH
9879: LD_INT 30
9881: PUSH
9882: LD_INT 31
9884: PUSH
9885: LD_INT 32
9887: PUSH
9888: LD_INT 33
9890: PUSH
9891: LD_INT 34
9893: PUSH
9894: LD_INT 35
9896: PUSH
9897: LD_INT 36
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 101
9925: PUSH
9926: LD_INT 102
9928: PUSH
9929: LD_INT 103
9931: PUSH
9932: LD_INT 106
9934: PUSH
9935: LD_INT 108
9937: PUSH
9938: LD_INT 112
9940: PUSH
9941: LD_INT 113
9943: PUSH
9944: LD_INT 114
9946: PUSH
9947: LD_INT 115
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: LIST
9960: PUSH
9961: EMPTY
9962: LIST
9963: LIST
9964: ST_TO_ADDR
9965: GO 10196
9967: LD_INT 19
9969: DOUBLE
9970: EQUAL
9971: IFTRUE 9975
9973: GO 10195
9975: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
9976: LD_ADDR_VAR 0 1
9980: PUSH
9981: LD_INT 1
9983: PUSH
9984: LD_INT 2
9986: PUSH
9987: LD_INT 3
9989: PUSH
9990: LD_INT 4
9992: PUSH
9993: LD_INT 5
9995: PUSH
9996: LD_INT 6
9998: PUSH
9999: LD_INT 7
10001: PUSH
10002: LD_INT 8
10004: PUSH
10005: LD_INT 9
10007: PUSH
10008: LD_INT 10
10010: PUSH
10011: LD_INT 11
10013: PUSH
10014: LD_INT 12
10016: PUSH
10017: LD_INT 13
10019: PUSH
10020: LD_INT 14
10022: PUSH
10023: LD_INT 15
10025: PUSH
10026: LD_INT 16
10028: PUSH
10029: LD_INT 17
10031: PUSH
10032: LD_INT 18
10034: PUSH
10035: LD_INT 19
10037: PUSH
10038: LD_INT 20
10040: PUSH
10041: LD_INT 21
10043: PUSH
10044: LD_INT 22
10046: PUSH
10047: LD_INT 23
10049: PUSH
10050: LD_INT 24
10052: PUSH
10053: LD_INT 25
10055: PUSH
10056: LD_INT 26
10058: PUSH
10059: LD_INT 27
10061: PUSH
10062: LD_INT 28
10064: PUSH
10065: LD_INT 29
10067: PUSH
10068: LD_INT 30
10070: PUSH
10071: LD_INT 31
10073: PUSH
10074: LD_INT 32
10076: PUSH
10077: LD_INT 33
10079: PUSH
10080: LD_INT 34
10082: PUSH
10083: LD_INT 35
10085: PUSH
10086: LD_INT 36
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: PUSH
10127: LD_INT 101
10129: PUSH
10130: LD_INT 102
10132: PUSH
10133: LD_INT 103
10135: PUSH
10136: LD_INT 104
10138: PUSH
10139: LD_INT 105
10141: PUSH
10142: LD_INT 106
10144: PUSH
10145: LD_INT 107
10147: PUSH
10148: LD_INT 108
10150: PUSH
10151: LD_INT 109
10153: PUSH
10154: LD_INT 110
10156: PUSH
10157: LD_INT 111
10159: PUSH
10160: LD_INT 112
10162: PUSH
10163: LD_INT 113
10165: PUSH
10166: LD_INT 114
10168: PUSH
10169: LD_INT 115
10171: PUSH
10172: EMPTY
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: ST_TO_ADDR
10193: GO 10196
10195: POP
// end else
10196: GO 10233
// if campaign_id = 5 then
10198: LD_OWVAR 69
10202: PUSH
10203: LD_INT 5
10205: EQUAL
10206: IFFALSE 10233
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
10208: LD_ADDR_VAR 0 1
10212: PUSH
10213: LD_INT 1
10215: PUSH
10216: LD_INT 2
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 100
10225: PUSH
10226: EMPTY
10227: LIST
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: ST_TO_ADDR
// end ; if result then
10233: LD_VAR 0 1
10237: IFFALSE 10526
// begin normal :=  ;
10239: LD_ADDR_VAR 0 3
10243: PUSH
10244: LD_STRING 
10246: ST_TO_ADDR
// hardcore :=  ;
10247: LD_ADDR_VAR 0 4
10251: PUSH
10252: LD_STRING 
10254: ST_TO_ADDR
// for i = 1 to normalCounter do
10255: LD_ADDR_VAR 0 5
10259: PUSH
10260: DOUBLE
10261: LD_INT 1
10263: DEC
10264: ST_TO_ADDR
10265: LD_EXP 20
10269: PUSH
10270: FOR_TO
10271: IFFALSE 10372
// begin tmp := 0 ;
10273: LD_ADDR_VAR 0 2
10277: PUSH
10278: LD_STRING 0
10280: ST_TO_ADDR
// if result [ 1 ] then
10281: LD_VAR 0 1
10285: PUSH
10286: LD_INT 1
10288: ARRAY
10289: IFFALSE 10354
// if result [ 1 ] [ 1 ] = i then
10291: LD_VAR 0 1
10295: PUSH
10296: LD_INT 1
10298: ARRAY
10299: PUSH
10300: LD_INT 1
10302: ARRAY
10303: PUSH
10304: LD_VAR 0 5
10308: EQUAL
10309: IFFALSE 10354
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
10311: LD_ADDR_VAR 0 1
10315: PUSH
10316: LD_VAR 0 1
10320: PPUSH
10321: LD_INT 1
10323: PPUSH
10324: LD_VAR 0 1
10328: PUSH
10329: LD_INT 1
10331: ARRAY
10332: PPUSH
10333: LD_INT 1
10335: PPUSH
10336: CALL_OW 3
10340: PPUSH
10341: CALL_OW 1
10345: ST_TO_ADDR
// tmp := 1 ;
10346: LD_ADDR_VAR 0 2
10350: PUSH
10351: LD_STRING 1
10353: ST_TO_ADDR
// end ; normal := normal & tmp ;
10354: LD_ADDR_VAR 0 3
10358: PUSH
10359: LD_VAR 0 3
10363: PUSH
10364: LD_VAR 0 2
10368: STR
10369: ST_TO_ADDR
// end ;
10370: GO 10270
10372: POP
10373: POP
// for i = 1 to hardcoreCounter do
10374: LD_ADDR_VAR 0 5
10378: PUSH
10379: DOUBLE
10380: LD_INT 1
10382: DEC
10383: ST_TO_ADDR
10384: LD_EXP 21
10388: PUSH
10389: FOR_TO
10390: IFFALSE 10495
// begin tmp := 0 ;
10392: LD_ADDR_VAR 0 2
10396: PUSH
10397: LD_STRING 0
10399: ST_TO_ADDR
// if result [ 2 ] then
10400: LD_VAR 0 1
10404: PUSH
10405: LD_INT 2
10407: ARRAY
10408: IFFALSE 10477
// if result [ 2 ] [ 1 ] = 100 + i then
10410: LD_VAR 0 1
10414: PUSH
10415: LD_INT 2
10417: ARRAY
10418: PUSH
10419: LD_INT 1
10421: ARRAY
10422: PUSH
10423: LD_INT 100
10425: PUSH
10426: LD_VAR 0 5
10430: PLUS
10431: EQUAL
10432: IFFALSE 10477
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10434: LD_ADDR_VAR 0 1
10438: PUSH
10439: LD_VAR 0 1
10443: PPUSH
10444: LD_INT 2
10446: PPUSH
10447: LD_VAR 0 1
10451: PUSH
10452: LD_INT 2
10454: ARRAY
10455: PPUSH
10456: LD_INT 1
10458: PPUSH
10459: CALL_OW 3
10463: PPUSH
10464: CALL_OW 1
10468: ST_TO_ADDR
// tmp := 1 ;
10469: LD_ADDR_VAR 0 2
10473: PUSH
10474: LD_STRING 1
10476: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10477: LD_ADDR_VAR 0 4
10481: PUSH
10482: LD_VAR 0 4
10486: PUSH
10487: LD_VAR 0 2
10491: STR
10492: ST_TO_ADDR
// end ;
10493: GO 10389
10495: POP
10496: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10497: LD_STRING getStreamItemsFromMission("
10499: PUSH
10500: LD_VAR 0 3
10504: STR
10505: PUSH
10506: LD_STRING ","
10508: STR
10509: PUSH
10510: LD_VAR 0 4
10514: STR
10515: PUSH
10516: LD_STRING ")
10518: STR
10519: PPUSH
10520: CALL_OW 559
// end else
10524: GO 10533
// ToLua ( getStreamItemsFromMission("","") ) ;
10526: LD_STRING getStreamItemsFromMission("","")
10528: PPUSH
10529: CALL_OW 559
// end ;
10533: LD_VAR 0 1
10537: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10538: LD_VAR 0 2
10542: PUSH
10543: LD_INT 100
10545: EQUAL
10546: IFFALSE 11495
// begin if not StreamModeActive then
10548: LD_EXP 19
10552: NOT
10553: IFFALSE 10563
// StreamModeActive := true ;
10555: LD_ADDR_EXP 19
10559: PUSH
10560: LD_INT 1
10562: ST_TO_ADDR
// if p3 = 0 then
10563: LD_VAR 0 3
10567: PUSH
10568: LD_INT 0
10570: EQUAL
10571: IFFALSE 10577
// InitStreamMode ;
10573: CALL 6798 0 0
// if p3 = 1 then
10577: LD_VAR 0 3
10581: PUSH
10582: LD_INT 1
10584: EQUAL
10585: IFFALSE 10595
// sRocket := true ;
10587: LD_ADDR_EXP 24
10591: PUSH
10592: LD_INT 1
10594: ST_TO_ADDR
// if p3 = 2 then
10595: LD_VAR 0 3
10599: PUSH
10600: LD_INT 2
10602: EQUAL
10603: IFFALSE 10613
// sSpeed := true ;
10605: LD_ADDR_EXP 23
10609: PUSH
10610: LD_INT 1
10612: ST_TO_ADDR
// if p3 = 3 then
10613: LD_VAR 0 3
10617: PUSH
10618: LD_INT 3
10620: EQUAL
10621: IFFALSE 10631
// sEngine := true ;
10623: LD_ADDR_EXP 25
10627: PUSH
10628: LD_INT 1
10630: ST_TO_ADDR
// if p3 = 4 then
10631: LD_VAR 0 3
10635: PUSH
10636: LD_INT 4
10638: EQUAL
10639: IFFALSE 10649
// sSpec := true ;
10641: LD_ADDR_EXP 22
10645: PUSH
10646: LD_INT 1
10648: ST_TO_ADDR
// if p3 = 5 then
10649: LD_VAR 0 3
10653: PUSH
10654: LD_INT 5
10656: EQUAL
10657: IFFALSE 10667
// sLevel := true ;
10659: LD_ADDR_EXP 26
10663: PUSH
10664: LD_INT 1
10666: ST_TO_ADDR
// if p3 = 6 then
10667: LD_VAR 0 3
10671: PUSH
10672: LD_INT 6
10674: EQUAL
10675: IFFALSE 10685
// sArmoury := true ;
10677: LD_ADDR_EXP 27
10681: PUSH
10682: LD_INT 1
10684: ST_TO_ADDR
// if p3 = 7 then
10685: LD_VAR 0 3
10689: PUSH
10690: LD_INT 7
10692: EQUAL
10693: IFFALSE 10703
// sRadar := true ;
10695: LD_ADDR_EXP 28
10699: PUSH
10700: LD_INT 1
10702: ST_TO_ADDR
// if p3 = 8 then
10703: LD_VAR 0 3
10707: PUSH
10708: LD_INT 8
10710: EQUAL
10711: IFFALSE 10721
// sBunker := true ;
10713: LD_ADDR_EXP 29
10717: PUSH
10718: LD_INT 1
10720: ST_TO_ADDR
// if p3 = 9 then
10721: LD_VAR 0 3
10725: PUSH
10726: LD_INT 9
10728: EQUAL
10729: IFFALSE 10739
// sHack := true ;
10731: LD_ADDR_EXP 30
10735: PUSH
10736: LD_INT 1
10738: ST_TO_ADDR
// if p3 = 10 then
10739: LD_VAR 0 3
10743: PUSH
10744: LD_INT 10
10746: EQUAL
10747: IFFALSE 10757
// sFire := true ;
10749: LD_ADDR_EXP 31
10753: PUSH
10754: LD_INT 1
10756: ST_TO_ADDR
// if p3 = 11 then
10757: LD_VAR 0 3
10761: PUSH
10762: LD_INT 11
10764: EQUAL
10765: IFFALSE 10775
// sRefresh := true ;
10767: LD_ADDR_EXP 32
10771: PUSH
10772: LD_INT 1
10774: ST_TO_ADDR
// if p3 = 12 then
10775: LD_VAR 0 3
10779: PUSH
10780: LD_INT 12
10782: EQUAL
10783: IFFALSE 10793
// sExp := true ;
10785: LD_ADDR_EXP 33
10789: PUSH
10790: LD_INT 1
10792: ST_TO_ADDR
// if p3 = 13 then
10793: LD_VAR 0 3
10797: PUSH
10798: LD_INT 13
10800: EQUAL
10801: IFFALSE 10811
// sDepot := true ;
10803: LD_ADDR_EXP 34
10807: PUSH
10808: LD_INT 1
10810: ST_TO_ADDR
// if p3 = 14 then
10811: LD_VAR 0 3
10815: PUSH
10816: LD_INT 14
10818: EQUAL
10819: IFFALSE 10829
// sFlag := true ;
10821: LD_ADDR_EXP 35
10825: PUSH
10826: LD_INT 1
10828: ST_TO_ADDR
// if p3 = 15 then
10829: LD_VAR 0 3
10833: PUSH
10834: LD_INT 15
10836: EQUAL
10837: IFFALSE 10847
// sKamikadze := true ;
10839: LD_ADDR_EXP 43
10843: PUSH
10844: LD_INT 1
10846: ST_TO_ADDR
// if p3 = 16 then
10847: LD_VAR 0 3
10851: PUSH
10852: LD_INT 16
10854: EQUAL
10855: IFFALSE 10865
// sTroll := true ;
10857: LD_ADDR_EXP 44
10861: PUSH
10862: LD_INT 1
10864: ST_TO_ADDR
// if p3 = 17 then
10865: LD_VAR 0 3
10869: PUSH
10870: LD_INT 17
10872: EQUAL
10873: IFFALSE 10883
// sSlow := true ;
10875: LD_ADDR_EXP 45
10879: PUSH
10880: LD_INT 1
10882: ST_TO_ADDR
// if p3 = 18 then
10883: LD_VAR 0 3
10887: PUSH
10888: LD_INT 18
10890: EQUAL
10891: IFFALSE 10901
// sLack := true ;
10893: LD_ADDR_EXP 46
10897: PUSH
10898: LD_INT 1
10900: ST_TO_ADDR
// if p3 = 19 then
10901: LD_VAR 0 3
10905: PUSH
10906: LD_INT 19
10908: EQUAL
10909: IFFALSE 10919
// sTank := true ;
10911: LD_ADDR_EXP 48
10915: PUSH
10916: LD_INT 1
10918: ST_TO_ADDR
// if p3 = 20 then
10919: LD_VAR 0 3
10923: PUSH
10924: LD_INT 20
10926: EQUAL
10927: IFFALSE 10937
// sRemote := true ;
10929: LD_ADDR_EXP 49
10933: PUSH
10934: LD_INT 1
10936: ST_TO_ADDR
// if p3 = 21 then
10937: LD_VAR 0 3
10941: PUSH
10942: LD_INT 21
10944: EQUAL
10945: IFFALSE 10955
// sPowell := true ;
10947: LD_ADDR_EXP 50
10951: PUSH
10952: LD_INT 1
10954: ST_TO_ADDR
// if p3 = 22 then
10955: LD_VAR 0 3
10959: PUSH
10960: LD_INT 22
10962: EQUAL
10963: IFFALSE 10973
// sTeleport := true ;
10965: LD_ADDR_EXP 53
10969: PUSH
10970: LD_INT 1
10972: ST_TO_ADDR
// if p3 = 23 then
10973: LD_VAR 0 3
10977: PUSH
10978: LD_INT 23
10980: EQUAL
10981: IFFALSE 10991
// sOilTower := true ;
10983: LD_ADDR_EXP 55
10987: PUSH
10988: LD_INT 1
10990: ST_TO_ADDR
// if p3 = 24 then
10991: LD_VAR 0 3
10995: PUSH
10996: LD_INT 24
10998: EQUAL
10999: IFFALSE 11009
// sShovel := true ;
11001: LD_ADDR_EXP 56
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
// if p3 = 25 then
11009: LD_VAR 0 3
11013: PUSH
11014: LD_INT 25
11016: EQUAL
11017: IFFALSE 11027
// sSheik := true ;
11019: LD_ADDR_EXP 57
11023: PUSH
11024: LD_INT 1
11026: ST_TO_ADDR
// if p3 = 26 then
11027: LD_VAR 0 3
11031: PUSH
11032: LD_INT 26
11034: EQUAL
11035: IFFALSE 11045
// sEarthquake := true ;
11037: LD_ADDR_EXP 59
11041: PUSH
11042: LD_INT 1
11044: ST_TO_ADDR
// if p3 = 27 then
11045: LD_VAR 0 3
11049: PUSH
11050: LD_INT 27
11052: EQUAL
11053: IFFALSE 11063
// sAI := true ;
11055: LD_ADDR_EXP 60
11059: PUSH
11060: LD_INT 1
11062: ST_TO_ADDR
// if p3 = 28 then
11063: LD_VAR 0 3
11067: PUSH
11068: LD_INT 28
11070: EQUAL
11071: IFFALSE 11081
// sCargo := true ;
11073: LD_ADDR_EXP 63
11077: PUSH
11078: LD_INT 1
11080: ST_TO_ADDR
// if p3 = 29 then
11081: LD_VAR 0 3
11085: PUSH
11086: LD_INT 29
11088: EQUAL
11089: IFFALSE 11099
// sDLaser := true ;
11091: LD_ADDR_EXP 64
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// if p3 = 30 then
11099: LD_VAR 0 3
11103: PUSH
11104: LD_INT 30
11106: EQUAL
11107: IFFALSE 11117
// sExchange := true ;
11109: LD_ADDR_EXP 65
11113: PUSH
11114: LD_INT 1
11116: ST_TO_ADDR
// if p3 = 31 then
11117: LD_VAR 0 3
11121: PUSH
11122: LD_INT 31
11124: EQUAL
11125: IFFALSE 11135
// sFac := true ;
11127: LD_ADDR_EXP 66
11131: PUSH
11132: LD_INT 1
11134: ST_TO_ADDR
// if p3 = 32 then
11135: LD_VAR 0 3
11139: PUSH
11140: LD_INT 32
11142: EQUAL
11143: IFFALSE 11153
// sPower := true ;
11145: LD_ADDR_EXP 67
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// if p3 = 33 then
11153: LD_VAR 0 3
11157: PUSH
11158: LD_INT 33
11160: EQUAL
11161: IFFALSE 11171
// sRandom := true ;
11163: LD_ADDR_EXP 68
11167: PUSH
11168: LD_INT 1
11170: ST_TO_ADDR
// if p3 = 34 then
11171: LD_VAR 0 3
11175: PUSH
11176: LD_INT 34
11178: EQUAL
11179: IFFALSE 11189
// sShield := true ;
11181: LD_ADDR_EXP 69
11185: PUSH
11186: LD_INT 1
11188: ST_TO_ADDR
// if p3 = 35 then
11189: LD_VAR 0 3
11193: PUSH
11194: LD_INT 35
11196: EQUAL
11197: IFFALSE 11207
// sTime := true ;
11199: LD_ADDR_EXP 70
11203: PUSH
11204: LD_INT 1
11206: ST_TO_ADDR
// if p3 = 36 then
11207: LD_VAR 0 3
11211: PUSH
11212: LD_INT 36
11214: EQUAL
11215: IFFALSE 11225
// sTools := true ;
11217: LD_ADDR_EXP 71
11221: PUSH
11222: LD_INT 1
11224: ST_TO_ADDR
// if p3 = 101 then
11225: LD_VAR 0 3
11229: PUSH
11230: LD_INT 101
11232: EQUAL
11233: IFFALSE 11243
// sSold := true ;
11235: LD_ADDR_EXP 36
11239: PUSH
11240: LD_INT 1
11242: ST_TO_ADDR
// if p3 = 102 then
11243: LD_VAR 0 3
11247: PUSH
11248: LD_INT 102
11250: EQUAL
11251: IFFALSE 11261
// sDiff := true ;
11253: LD_ADDR_EXP 37
11257: PUSH
11258: LD_INT 1
11260: ST_TO_ADDR
// if p3 = 103 then
11261: LD_VAR 0 3
11265: PUSH
11266: LD_INT 103
11268: EQUAL
11269: IFFALSE 11279
// sFog := true ;
11271: LD_ADDR_EXP 40
11275: PUSH
11276: LD_INT 1
11278: ST_TO_ADDR
// if p3 = 104 then
11279: LD_VAR 0 3
11283: PUSH
11284: LD_INT 104
11286: EQUAL
11287: IFFALSE 11297
// sReset := true ;
11289: LD_ADDR_EXP 41
11293: PUSH
11294: LD_INT 1
11296: ST_TO_ADDR
// if p3 = 105 then
11297: LD_VAR 0 3
11301: PUSH
11302: LD_INT 105
11304: EQUAL
11305: IFFALSE 11315
// sSun := true ;
11307: LD_ADDR_EXP 42
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// if p3 = 106 then
11315: LD_VAR 0 3
11319: PUSH
11320: LD_INT 106
11322: EQUAL
11323: IFFALSE 11333
// sTiger := true ;
11325: LD_ADDR_EXP 38
11329: PUSH
11330: LD_INT 1
11332: ST_TO_ADDR
// if p3 = 107 then
11333: LD_VAR 0 3
11337: PUSH
11338: LD_INT 107
11340: EQUAL
11341: IFFALSE 11351
// sBomb := true ;
11343: LD_ADDR_EXP 39
11347: PUSH
11348: LD_INT 1
11350: ST_TO_ADDR
// if p3 = 108 then
11351: LD_VAR 0 3
11355: PUSH
11356: LD_INT 108
11358: EQUAL
11359: IFFALSE 11369
// sWound := true ;
11361: LD_ADDR_EXP 47
11365: PUSH
11366: LD_INT 1
11368: ST_TO_ADDR
// if p3 = 109 then
11369: LD_VAR 0 3
11373: PUSH
11374: LD_INT 109
11376: EQUAL
11377: IFFALSE 11387
// sBetray := true ;
11379: LD_ADDR_EXP 51
11383: PUSH
11384: LD_INT 1
11386: ST_TO_ADDR
// if p3 = 110 then
11387: LD_VAR 0 3
11391: PUSH
11392: LD_INT 110
11394: EQUAL
11395: IFFALSE 11405
// sContamin := true ;
11397: LD_ADDR_EXP 52
11401: PUSH
11402: LD_INT 1
11404: ST_TO_ADDR
// if p3 = 111 then
11405: LD_VAR 0 3
11409: PUSH
11410: LD_INT 111
11412: EQUAL
11413: IFFALSE 11423
// sOil := true ;
11415: LD_ADDR_EXP 54
11419: PUSH
11420: LD_INT 1
11422: ST_TO_ADDR
// if p3 = 112 then
11423: LD_VAR 0 3
11427: PUSH
11428: LD_INT 112
11430: EQUAL
11431: IFFALSE 11441
// sStu := true ;
11433: LD_ADDR_EXP 58
11437: PUSH
11438: LD_INT 1
11440: ST_TO_ADDR
// if p3 = 113 then
11441: LD_VAR 0 3
11445: PUSH
11446: LD_INT 113
11448: EQUAL
11449: IFFALSE 11459
// sBazooka := true ;
11451: LD_ADDR_EXP 61
11455: PUSH
11456: LD_INT 1
11458: ST_TO_ADDR
// if p3 = 114 then
11459: LD_VAR 0 3
11463: PUSH
11464: LD_INT 114
11466: EQUAL
11467: IFFALSE 11477
// sMortar := true ;
11469: LD_ADDR_EXP 62
11473: PUSH
11474: LD_INT 1
11476: ST_TO_ADDR
// if p3 = 115 then
11477: LD_VAR 0 3
11481: PUSH
11482: LD_INT 115
11484: EQUAL
11485: IFFALSE 11495
// sRanger := true ;
11487: LD_ADDR_EXP 72
11491: PUSH
11492: LD_INT 1
11494: ST_TO_ADDR
// end ; end ;
11495: PPOPN 6
11497: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11498: LD_EXP 19
11502: PUSH
11503: LD_EXP 24
11507: AND
11508: IFFALSE 11632
11510: GO 11512
11512: DISABLE
11513: LD_INT 0
11515: PPUSH
11516: PPUSH
// begin enable ;
11517: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11518: LD_ADDR_VAR 0 2
11522: PUSH
11523: LD_INT 22
11525: PUSH
11526: LD_OWVAR 2
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: PUSH
11535: LD_INT 2
11537: PUSH
11538: LD_INT 34
11540: PUSH
11541: LD_INT 7
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 34
11550: PUSH
11551: LD_INT 45
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: LD_INT 34
11560: PUSH
11561: LD_INT 28
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: PUSH
11568: LD_INT 34
11570: PUSH
11571: LD_INT 47
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PPUSH
11589: CALL_OW 69
11593: ST_TO_ADDR
// if not tmp then
11594: LD_VAR 0 2
11598: NOT
11599: IFFALSE 11603
// exit ;
11601: GO 11632
// for i in tmp do
11603: LD_ADDR_VAR 0 1
11607: PUSH
11608: LD_VAR 0 2
11612: PUSH
11613: FOR_IN
11614: IFFALSE 11630
// begin SetLives ( i , 0 ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 234
// end ;
11628: GO 11613
11630: POP
11631: POP
// end ;
11632: PPOPN 2
11634: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11635: LD_EXP 19
11639: PUSH
11640: LD_EXP 25
11644: AND
11645: IFFALSE 11729
11647: GO 11649
11649: DISABLE
11650: LD_INT 0
11652: PPUSH
11653: PPUSH
// begin enable ;
11654: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11655: LD_ADDR_VAR 0 2
11659: PUSH
11660: LD_INT 22
11662: PUSH
11663: LD_OWVAR 2
11667: PUSH
11668: EMPTY
11669: LIST
11670: LIST
11671: PUSH
11672: LD_INT 32
11674: PUSH
11675: LD_INT 3
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: ST_TO_ADDR
// if not tmp then
11691: LD_VAR 0 2
11695: NOT
11696: IFFALSE 11700
// exit ;
11698: GO 11729
// for i in tmp do
11700: LD_ADDR_VAR 0 1
11704: PUSH
11705: LD_VAR 0 2
11709: PUSH
11710: FOR_IN
11711: IFFALSE 11727
// begin SetLives ( i , 0 ) ;
11713: LD_VAR 0 1
11717: PPUSH
11718: LD_INT 0
11720: PPUSH
11721: CALL_OW 234
// end ;
11725: GO 11710
11727: POP
11728: POP
// end ;
11729: PPOPN 2
11731: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11732: LD_EXP 19
11736: PUSH
11737: LD_EXP 22
11741: AND
11742: IFFALSE 11835
11744: GO 11746
11746: DISABLE
11747: LD_INT 0
11749: PPUSH
// begin enable ;
11750: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11751: LD_ADDR_VAR 0 1
11755: PUSH
11756: LD_INT 22
11758: PUSH
11759: LD_OWVAR 2
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: PUSH
11768: LD_INT 2
11770: PUSH
11771: LD_INT 25
11773: PUSH
11774: LD_INT 5
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: LD_INT 25
11783: PUSH
11784: LD_INT 9
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 25
11793: PUSH
11794: LD_INT 8
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: PUSH
11807: EMPTY
11808: LIST
11809: LIST
11810: PPUSH
11811: CALL_OW 69
11815: PUSH
11816: FOR_IN
11817: IFFALSE 11833
// begin SetClass ( i , 1 ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: LD_INT 1
11826: PPUSH
11827: CALL_OW 336
// end ;
11831: GO 11816
11833: POP
11834: POP
// end ;
11835: PPOPN 1
11837: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
11838: LD_EXP 19
11842: PUSH
11843: LD_EXP 23
11847: AND
11848: PUSH
11849: LD_OWVAR 65
11853: PUSH
11854: LD_INT 7
11856: LESS
11857: AND
11858: IFFALSE 11872
11860: GO 11862
11862: DISABLE
// begin enable ;
11863: ENABLE
// game_speed := 7 ;
11864: LD_ADDR_OWVAR 65
11868: PUSH
11869: LD_INT 7
11871: ST_TO_ADDR
// end ;
11872: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
11873: LD_EXP 19
11877: PUSH
11878: LD_EXP 26
11882: AND
11883: IFFALSE 12085
11885: GO 11887
11887: DISABLE
11888: LD_INT 0
11890: PPUSH
11891: PPUSH
11892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
11893: LD_ADDR_VAR 0 3
11897: PUSH
11898: LD_INT 81
11900: PUSH
11901: LD_OWVAR 2
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 21
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: PPUSH
11924: CALL_OW 69
11928: ST_TO_ADDR
// if not tmp then
11929: LD_VAR 0 3
11933: NOT
11934: IFFALSE 11938
// exit ;
11936: GO 12085
// if tmp > 5 then
11938: LD_VAR 0 3
11942: PUSH
11943: LD_INT 5
11945: GREATER
11946: IFFALSE 11958
// k := 5 else
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_INT 5
11955: ST_TO_ADDR
11956: GO 11968
// k := tmp ;
11958: LD_ADDR_VAR 0 2
11962: PUSH
11963: LD_VAR 0 3
11967: ST_TO_ADDR
// for i := 1 to k do
11968: LD_ADDR_VAR 0 1
11972: PUSH
11973: DOUBLE
11974: LD_INT 1
11976: DEC
11977: ST_TO_ADDR
11978: LD_VAR 0 2
11982: PUSH
11983: FOR_TO
11984: IFFALSE 12083
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
11986: LD_VAR 0 3
11990: PUSH
11991: LD_VAR 0 1
11995: ARRAY
11996: PPUSH
11997: LD_VAR 0 1
12001: PUSH
12002: LD_INT 4
12004: MOD
12005: PUSH
12006: LD_INT 1
12008: PLUS
12009: PPUSH
12010: CALL_OW 259
12014: PUSH
12015: LD_INT 10
12017: LESS
12018: IFFALSE 12081
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12020: LD_VAR 0 3
12024: PUSH
12025: LD_VAR 0 1
12029: ARRAY
12030: PPUSH
12031: LD_VAR 0 1
12035: PUSH
12036: LD_INT 4
12038: MOD
12039: PUSH
12040: LD_INT 1
12042: PLUS
12043: PPUSH
12044: LD_VAR 0 3
12048: PUSH
12049: LD_VAR 0 1
12053: ARRAY
12054: PPUSH
12055: LD_VAR 0 1
12059: PUSH
12060: LD_INT 4
12062: MOD
12063: PUSH
12064: LD_INT 1
12066: PLUS
12067: PPUSH
12068: CALL_OW 259
12072: PUSH
12073: LD_INT 1
12075: PLUS
12076: PPUSH
12077: CALL_OW 237
12081: GO 11983
12083: POP
12084: POP
// end ;
12085: PPOPN 3
12087: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12088: LD_EXP 19
12092: PUSH
12093: LD_EXP 27
12097: AND
12098: IFFALSE 12118
12100: GO 12102
12102: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12103: LD_INT 4
12105: PPUSH
12106: LD_OWVAR 2
12110: PPUSH
12111: LD_INT 0
12113: PPUSH
12114: CALL_OW 324
12118: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12119: LD_EXP 19
12123: PUSH
12124: LD_EXP 56
12128: AND
12129: IFFALSE 12149
12131: GO 12133
12133: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12134: LD_INT 19
12136: PPUSH
12137: LD_OWVAR 2
12141: PPUSH
12142: LD_INT 0
12144: PPUSH
12145: CALL_OW 324
12149: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12150: LD_EXP 19
12154: PUSH
12155: LD_EXP 28
12159: AND
12160: IFFALSE 12262
12162: GO 12164
12164: DISABLE
12165: LD_INT 0
12167: PPUSH
12168: PPUSH
// begin enable ;
12169: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: LD_INT 22
12177: PUSH
12178: LD_OWVAR 2
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 2
12189: PUSH
12190: LD_INT 34
12192: PUSH
12193: LD_INT 11
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: LD_INT 34
12202: PUSH
12203: LD_INT 30
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: PUSH
12215: EMPTY
12216: LIST
12217: LIST
12218: PPUSH
12219: CALL_OW 69
12223: ST_TO_ADDR
// if not tmp then
12224: LD_VAR 0 2
12228: NOT
12229: IFFALSE 12233
// exit ;
12231: GO 12262
// for i in tmp do
12233: LD_ADDR_VAR 0 1
12237: PUSH
12238: LD_VAR 0 2
12242: PUSH
12243: FOR_IN
12244: IFFALSE 12260
// begin SetLives ( i , 0 ) ;
12246: LD_VAR 0 1
12250: PPUSH
12251: LD_INT 0
12253: PPUSH
12254: CALL_OW 234
// end ;
12258: GO 12243
12260: POP
12261: POP
// end ;
12262: PPOPN 2
12264: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12265: LD_EXP 19
12269: PUSH
12270: LD_EXP 29
12274: AND
12275: IFFALSE 12295
12277: GO 12279
12279: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12280: LD_INT 32
12282: PPUSH
12283: LD_OWVAR 2
12287: PPUSH
12288: LD_INT 0
12290: PPUSH
12291: CALL_OW 324
12295: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12296: LD_EXP 19
12300: PUSH
12301: LD_EXP 30
12305: AND
12306: IFFALSE 12487
12308: GO 12310
12310: DISABLE
12311: LD_INT 0
12313: PPUSH
12314: PPUSH
12315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12316: LD_ADDR_VAR 0 2
12320: PUSH
12321: LD_INT 22
12323: PUSH
12324: LD_OWVAR 2
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PUSH
12333: LD_INT 33
12335: PUSH
12336: LD_INT 3
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PPUSH
12347: CALL_OW 69
12351: ST_TO_ADDR
// if not tmp then
12352: LD_VAR 0 2
12356: NOT
12357: IFFALSE 12361
// exit ;
12359: GO 12487
// side := 0 ;
12361: LD_ADDR_VAR 0 3
12365: PUSH
12366: LD_INT 0
12368: ST_TO_ADDR
// for i := 1 to 8 do
12369: LD_ADDR_VAR 0 1
12373: PUSH
12374: DOUBLE
12375: LD_INT 1
12377: DEC
12378: ST_TO_ADDR
12379: LD_INT 8
12381: PUSH
12382: FOR_TO
12383: IFFALSE 12431
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12385: LD_OWVAR 2
12389: PUSH
12390: LD_VAR 0 1
12394: NONEQUAL
12395: PUSH
12396: LD_OWVAR 2
12400: PPUSH
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 81
12410: PUSH
12411: LD_INT 2
12413: EQUAL
12414: AND
12415: IFFALSE 12429
// begin side := i ;
12417: LD_ADDR_VAR 0 3
12421: PUSH
12422: LD_VAR 0 1
12426: ST_TO_ADDR
// break ;
12427: GO 12431
// end ;
12429: GO 12382
12431: POP
12432: POP
// if not side then
12433: LD_VAR 0 3
12437: NOT
12438: IFFALSE 12442
// exit ;
12440: GO 12487
// for i := 1 to tmp do
12442: LD_ADDR_VAR 0 1
12446: PUSH
12447: DOUBLE
12448: LD_INT 1
12450: DEC
12451: ST_TO_ADDR
12452: LD_VAR 0 2
12456: PUSH
12457: FOR_TO
12458: IFFALSE 12485
// if Prob ( 60 ) then
12460: LD_INT 60
12462: PPUSH
12463: CALL_OW 13
12467: IFFALSE 12483
// SetSide ( i , side ) ;
12469: LD_VAR 0 1
12473: PPUSH
12474: LD_VAR 0 3
12478: PPUSH
12479: CALL_OW 235
12483: GO 12457
12485: POP
12486: POP
// end ;
12487: PPOPN 3
12489: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12490: LD_EXP 19
12494: PUSH
12495: LD_EXP 32
12499: AND
12500: IFFALSE 12619
12502: GO 12504
12504: DISABLE
12505: LD_INT 0
12507: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12508: LD_ADDR_VAR 0 1
12512: PUSH
12513: LD_INT 22
12515: PUSH
12516: LD_OWVAR 2
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: LD_INT 21
12527: PUSH
12528: LD_INT 1
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 3
12537: PUSH
12538: LD_INT 23
12540: PUSH
12541: LD_INT 0
12543: PUSH
12544: EMPTY
12545: LIST
12546: LIST
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PPUSH
12557: CALL_OW 69
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12617
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12565: LD_VAR 0 1
12569: PPUSH
12570: CALL_OW 257
12574: PUSH
12575: LD_INT 1
12577: PUSH
12578: LD_INT 2
12580: PUSH
12581: LD_INT 3
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: IN
12593: IFFALSE 12615
// SetClass ( un , rand ( 1 , 4 ) ) ;
12595: LD_VAR 0 1
12599: PPUSH
12600: LD_INT 1
12602: PPUSH
12603: LD_INT 4
12605: PPUSH
12606: CALL_OW 12
12610: PPUSH
12611: CALL_OW 336
12615: GO 12562
12617: POP
12618: POP
// end ;
12619: PPOPN 1
12621: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12622: LD_EXP 19
12626: PUSH
12627: LD_EXP 31
12631: AND
12632: IFFALSE 12711
12634: GO 12636
12636: DISABLE
12637: LD_INT 0
12639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12640: LD_ADDR_VAR 0 1
12644: PUSH
12645: LD_INT 22
12647: PUSH
12648: LD_OWVAR 2
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 21
12659: PUSH
12660: LD_INT 3
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PPUSH
12671: CALL_OW 69
12675: ST_TO_ADDR
// if not tmp then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12711
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: PPUSH
12693: LD_VAR 0 1
12697: PPUSH
12698: CALL_OW 12
12702: ARRAY
12703: PPUSH
12704: LD_INT 100
12706: PPUSH
12707: CALL_OW 234
// end ;
12711: PPOPN 1
12713: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12714: LD_EXP 19
12718: PUSH
12719: LD_EXP 33
12723: AND
12724: IFFALSE 12822
12726: GO 12728
12728: DISABLE
12729: LD_INT 0
12731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_INT 22
12739: PUSH
12740: LD_OWVAR 2
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PUSH
12749: LD_INT 21
12751: PUSH
12752: LD_INT 1
12754: PUSH
12755: EMPTY
12756: LIST
12757: LIST
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PPUSH
12763: CALL_OW 69
12767: ST_TO_ADDR
// if not tmp then
12768: LD_VAR 0 1
12772: NOT
12773: IFFALSE 12777
// exit ;
12775: GO 12822
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12777: LD_VAR 0 1
12781: PUSH
12782: LD_INT 1
12784: PPUSH
12785: LD_VAR 0 1
12789: PPUSH
12790: CALL_OW 12
12794: ARRAY
12795: PPUSH
12796: LD_INT 1
12798: PPUSH
12799: LD_INT 4
12801: PPUSH
12802: CALL_OW 12
12806: PPUSH
12807: LD_INT 3000
12809: PPUSH
12810: LD_INT 9000
12812: PPUSH
12813: CALL_OW 12
12817: PPUSH
12818: CALL_OW 492
// end ;
12822: PPOPN 1
12824: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12825: LD_EXP 19
12829: PUSH
12830: LD_EXP 34
12834: AND
12835: IFFALSE 12855
12837: GO 12839
12839: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12840: LD_INT 1
12842: PPUSH
12843: LD_OWVAR 2
12847: PPUSH
12848: LD_INT 0
12850: PPUSH
12851: CALL_OW 324
12855: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12856: LD_EXP 19
12860: PUSH
12861: LD_EXP 35
12865: AND
12866: IFFALSE 12949
12868: GO 12870
12870: DISABLE
12871: LD_INT 0
12873: PPUSH
12874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12875: LD_ADDR_VAR 0 2
12879: PUSH
12880: LD_INT 22
12882: PUSH
12883: LD_OWVAR 2
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 21
12894: PUSH
12895: LD_INT 3
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: EMPTY
12903: LIST
12904: LIST
12905: PPUSH
12906: CALL_OW 69
12910: ST_TO_ADDR
// if not tmp then
12911: LD_VAR 0 2
12915: NOT
12916: IFFALSE 12920
// exit ;
12918: GO 12949
// for i in tmp do
12920: LD_ADDR_VAR 0 1
12924: PUSH
12925: LD_VAR 0 2
12929: PUSH
12930: FOR_IN
12931: IFFALSE 12947
// SetBLevel ( i , 10 ) ;
12933: LD_VAR 0 1
12937: PPUSH
12938: LD_INT 10
12940: PPUSH
12941: CALL_OW 241
12945: GO 12930
12947: POP
12948: POP
// end ;
12949: PPOPN 2
12951: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
12952: LD_EXP 19
12956: PUSH
12957: LD_EXP 36
12961: AND
12962: IFFALSE 13073
12964: GO 12966
12966: DISABLE
12967: LD_INT 0
12969: PPUSH
12970: PPUSH
12971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12972: LD_ADDR_VAR 0 3
12976: PUSH
12977: LD_INT 22
12979: PUSH
12980: LD_OWVAR 2
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 25
12991: PUSH
12992: LD_INT 1
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PPUSH
13003: CALL_OW 69
13007: ST_TO_ADDR
// if not tmp then
13008: LD_VAR 0 3
13012: NOT
13013: IFFALSE 13017
// exit ;
13015: GO 13073
// un := tmp [ rand ( 1 , tmp ) ] ;
13017: LD_ADDR_VAR 0 2
13021: PUSH
13022: LD_VAR 0 3
13026: PUSH
13027: LD_INT 1
13029: PPUSH
13030: LD_VAR 0 3
13034: PPUSH
13035: CALL_OW 12
13039: ARRAY
13040: ST_TO_ADDR
// if Crawls ( un ) then
13041: LD_VAR 0 2
13045: PPUSH
13046: CALL_OW 318
13050: IFFALSE 13061
// ComWalk ( un ) ;
13052: LD_VAR 0 2
13056: PPUSH
13057: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13061: LD_VAR 0 2
13065: PPUSH
13066: LD_INT 5
13068: PPUSH
13069: CALL_OW 336
// end ;
13073: PPOPN 3
13075: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13076: LD_EXP 19
13080: PUSH
13081: LD_EXP 37
13085: AND
13086: PUSH
13087: LD_OWVAR 67
13091: PUSH
13092: LD_INT 3
13094: LESS
13095: AND
13096: IFFALSE 13115
13098: GO 13100
13100: DISABLE
// Difficulty := Difficulty + 1 ;
13101: LD_ADDR_OWVAR 67
13105: PUSH
13106: LD_OWVAR 67
13110: PUSH
13111: LD_INT 1
13113: PLUS
13114: ST_TO_ADDR
13115: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13116: LD_EXP 19
13120: PUSH
13121: LD_EXP 38
13125: AND
13126: IFFALSE 13229
13128: GO 13130
13130: DISABLE
13131: LD_INT 0
13133: PPUSH
// begin for i := 1 to 5 do
13134: LD_ADDR_VAR 0 1
13138: PUSH
13139: DOUBLE
13140: LD_INT 1
13142: DEC
13143: ST_TO_ADDR
13144: LD_INT 5
13146: PUSH
13147: FOR_TO
13148: IFFALSE 13227
// begin uc_nation := nation_nature ;
13150: LD_ADDR_OWVAR 21
13154: PUSH
13155: LD_INT 0
13157: ST_TO_ADDR
// uc_side := 0 ;
13158: LD_ADDR_OWVAR 20
13162: PUSH
13163: LD_INT 0
13165: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13166: LD_ADDR_OWVAR 29
13170: PUSH
13171: LD_INT 12
13173: PUSH
13174: LD_INT 12
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: ST_TO_ADDR
// hc_agressivity := 20 ;
13181: LD_ADDR_OWVAR 35
13185: PUSH
13186: LD_INT 20
13188: ST_TO_ADDR
// hc_class := class_tiger ;
13189: LD_ADDR_OWVAR 28
13193: PUSH
13194: LD_INT 14
13196: ST_TO_ADDR
// hc_gallery :=  ;
13197: LD_ADDR_OWVAR 33
13201: PUSH
13202: LD_STRING 
13204: ST_TO_ADDR
// hc_name :=  ;
13205: LD_ADDR_OWVAR 26
13209: PUSH
13210: LD_STRING 
13212: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13213: CALL_OW 44
13217: PPUSH
13218: LD_INT 0
13220: PPUSH
13221: CALL_OW 51
// end ;
13225: GO 13147
13227: POP
13228: POP
// end ;
13229: PPOPN 1
13231: END
// every 0 0$1 trigger StreamModeActive and sBomb do
13232: LD_EXP 19
13236: PUSH
13237: LD_EXP 39
13241: AND
13242: IFFALSE 13251
13244: GO 13246
13246: DISABLE
// StreamSibBomb ;
13247: CALL 13252 0 0
13251: END
// export function StreamSibBomb ; var i , x , y ; begin
13252: LD_INT 0
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
// result := false ;
13258: LD_ADDR_VAR 0 1
13262: PUSH
13263: LD_INT 0
13265: ST_TO_ADDR
// for i := 1 to 16 do
13266: LD_ADDR_VAR 0 2
13270: PUSH
13271: DOUBLE
13272: LD_INT 1
13274: DEC
13275: ST_TO_ADDR
13276: LD_INT 16
13278: PUSH
13279: FOR_TO
13280: IFFALSE 13479
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13282: LD_ADDR_VAR 0 3
13286: PUSH
13287: LD_INT 10
13289: PUSH
13290: LD_INT 20
13292: PUSH
13293: LD_INT 30
13295: PUSH
13296: LD_INT 40
13298: PUSH
13299: LD_INT 50
13301: PUSH
13302: LD_INT 60
13304: PUSH
13305: LD_INT 70
13307: PUSH
13308: LD_INT 80
13310: PUSH
13311: LD_INT 90
13313: PUSH
13314: LD_INT 100
13316: PUSH
13317: LD_INT 110
13319: PUSH
13320: LD_INT 120
13322: PUSH
13323: LD_INT 130
13325: PUSH
13326: LD_INT 140
13328: PUSH
13329: LD_INT 150
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: PUSH
13349: LD_INT 1
13351: PPUSH
13352: LD_INT 15
13354: PPUSH
13355: CALL_OW 12
13359: ARRAY
13360: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13361: LD_ADDR_VAR 0 4
13365: PUSH
13366: LD_INT 10
13368: PUSH
13369: LD_INT 20
13371: PUSH
13372: LD_INT 30
13374: PUSH
13375: LD_INT 40
13377: PUSH
13378: LD_INT 50
13380: PUSH
13381: LD_INT 60
13383: PUSH
13384: LD_INT 70
13386: PUSH
13387: LD_INT 80
13389: PUSH
13390: LD_INT 90
13392: PUSH
13393: LD_INT 100
13395: PUSH
13396: LD_INT 110
13398: PUSH
13399: LD_INT 120
13401: PUSH
13402: LD_INT 130
13404: PUSH
13405: LD_INT 140
13407: PUSH
13408: LD_INT 150
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: PUSH
13428: LD_INT 1
13430: PPUSH
13431: LD_INT 15
13433: PPUSH
13434: CALL_OW 12
13438: ARRAY
13439: ST_TO_ADDR
// if ValidHex ( x , y ) then
13440: LD_VAR 0 3
13444: PPUSH
13445: LD_VAR 0 4
13449: PPUSH
13450: CALL_OW 488
13454: IFFALSE 13477
// begin result := [ x , y ] ;
13456: LD_ADDR_VAR 0 1
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_VAR 0 4
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: ST_TO_ADDR
// break ;
13475: GO 13479
// end ; end ;
13477: GO 13279
13479: POP
13480: POP
// if result then
13481: LD_VAR 0 1
13485: IFFALSE 13545
// begin ToLua ( playSibBomb() ) ;
13487: LD_STRING playSibBomb()
13489: PPUSH
13490: CALL_OW 559
// wait ( 0 0$14 ) ;
13494: LD_INT 490
13496: PPUSH
13497: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13501: LD_VAR 0 1
13505: PUSH
13506: LD_INT 1
13508: ARRAY
13509: PPUSH
13510: LD_VAR 0 1
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PPUSH
13519: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13523: LD_VAR 0 1
13527: PUSH
13528: LD_INT 1
13530: ARRAY
13531: PPUSH
13532: LD_VAR 0 1
13536: PUSH
13537: LD_INT 2
13539: ARRAY
13540: PPUSH
13541: CALL_OW 429
// end ; end ;
13545: LD_VAR 0 1
13549: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13550: LD_EXP 19
13554: PUSH
13555: LD_EXP 41
13559: AND
13560: IFFALSE 13572
13562: GO 13564
13564: DISABLE
// YouLost (  ) ;
13565: LD_STRING 
13567: PPUSH
13568: CALL_OW 104
13572: END
// every 0 0$1 trigger StreamModeActive and sFog do
13573: LD_EXP 19
13577: PUSH
13578: LD_EXP 40
13582: AND
13583: IFFALSE 13597
13585: GO 13587
13587: DISABLE
// FogOff ( your_side ) ;
13588: LD_OWVAR 2
13592: PPUSH
13593: CALL_OW 344
13597: END
// every 0 0$1 trigger StreamModeActive and sSun do
13598: LD_EXP 19
13602: PUSH
13603: LD_EXP 42
13607: AND
13608: IFFALSE 13636
13610: GO 13612
13612: DISABLE
// begin solar_recharge_percent := 0 ;
13613: LD_ADDR_OWVAR 79
13617: PUSH
13618: LD_INT 0
13620: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13621: LD_INT 10500
13623: PPUSH
13624: CALL_OW 67
// solar_recharge_percent := 100 ;
13628: LD_ADDR_OWVAR 79
13632: PUSH
13633: LD_INT 100
13635: ST_TO_ADDR
// end ;
13636: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13637: LD_EXP 19
13641: PUSH
13642: LD_EXP 43
13646: AND
13647: IFFALSE 13886
13649: GO 13651
13651: DISABLE
13652: LD_INT 0
13654: PPUSH
13655: PPUSH
13656: PPUSH
// begin tmp := [ ] ;
13657: LD_ADDR_VAR 0 3
13661: PUSH
13662: EMPTY
13663: ST_TO_ADDR
// for i := 1 to 6 do
13664: LD_ADDR_VAR 0 1
13668: PUSH
13669: DOUBLE
13670: LD_INT 1
13672: DEC
13673: ST_TO_ADDR
13674: LD_INT 6
13676: PUSH
13677: FOR_TO
13678: IFFALSE 13783
// begin uc_nation := nation_nature ;
13680: LD_ADDR_OWVAR 21
13684: PUSH
13685: LD_INT 0
13687: ST_TO_ADDR
// uc_side := 0 ;
13688: LD_ADDR_OWVAR 20
13692: PUSH
13693: LD_INT 0
13695: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13696: LD_ADDR_OWVAR 29
13700: PUSH
13701: LD_INT 12
13703: PUSH
13704: LD_INT 12
13706: PUSH
13707: EMPTY
13708: LIST
13709: LIST
13710: ST_TO_ADDR
// hc_agressivity := 20 ;
13711: LD_ADDR_OWVAR 35
13715: PUSH
13716: LD_INT 20
13718: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13719: LD_ADDR_OWVAR 28
13723: PUSH
13724: LD_INT 17
13726: ST_TO_ADDR
// hc_gallery :=  ;
13727: LD_ADDR_OWVAR 33
13731: PUSH
13732: LD_STRING 
13734: ST_TO_ADDR
// hc_name :=  ;
13735: LD_ADDR_OWVAR 26
13739: PUSH
13740: LD_STRING 
13742: ST_TO_ADDR
// un := CreateHuman ;
13743: LD_ADDR_VAR 0 2
13747: PUSH
13748: CALL_OW 44
13752: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13753: LD_VAR 0 2
13757: PPUSH
13758: LD_INT 1
13760: PPUSH
13761: CALL_OW 51
// tmp := tmp ^ un ;
13765: LD_ADDR_VAR 0 3
13769: PUSH
13770: LD_VAR 0 3
13774: PUSH
13775: LD_VAR 0 2
13779: ADD
13780: ST_TO_ADDR
// end ;
13781: GO 13677
13783: POP
13784: POP
// repeat wait ( 0 0$1 ) ;
13785: LD_INT 35
13787: PPUSH
13788: CALL_OW 67
// for un in tmp do
13792: LD_ADDR_VAR 0 2
13796: PUSH
13797: LD_VAR 0 3
13801: PUSH
13802: FOR_IN
13803: IFFALSE 13877
// begin if IsDead ( un ) then
13805: LD_VAR 0 2
13809: PPUSH
13810: CALL_OW 301
13814: IFFALSE 13834
// begin tmp := tmp diff un ;
13816: LD_ADDR_VAR 0 3
13820: PUSH
13821: LD_VAR 0 3
13825: PUSH
13826: LD_VAR 0 2
13830: DIFF
13831: ST_TO_ADDR
// continue ;
13832: GO 13802
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13834: LD_VAR 0 2
13838: PPUSH
13839: LD_INT 3
13841: PUSH
13842: LD_INT 22
13844: PUSH
13845: LD_INT 0
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PPUSH
13856: CALL_OW 69
13860: PPUSH
13861: LD_VAR 0 2
13865: PPUSH
13866: CALL_OW 74
13870: PPUSH
13871: CALL_OW 115
// end ;
13875: GO 13802
13877: POP
13878: POP
// until not tmp ;
13879: LD_VAR 0 3
13883: NOT
13884: IFFALSE 13785
// end ;
13886: PPOPN 3
13888: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13889: LD_EXP 19
13893: PUSH
13894: LD_EXP 44
13898: AND
13899: IFFALSE 13953
13901: GO 13903
13903: DISABLE
// begin ToLua ( displayTroll(); ) ;
13904: LD_STRING displayTroll();
13906: PPUSH
13907: CALL_OW 559
// wait ( 3 3$00 ) ;
13911: LD_INT 6300
13913: PPUSH
13914: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13918: LD_STRING hideTroll();
13920: PPUSH
13921: CALL_OW 559
// wait ( 1 1$00 ) ;
13925: LD_INT 2100
13927: PPUSH
13928: CALL_OW 67
// ToLua ( displayTroll(); ) ;
13932: LD_STRING displayTroll();
13934: PPUSH
13935: CALL_OW 559
// wait ( 1 1$00 ) ;
13939: LD_INT 2100
13941: PPUSH
13942: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13946: LD_STRING hideTroll();
13948: PPUSH
13949: CALL_OW 559
// end ;
13953: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13954: LD_EXP 19
13958: PUSH
13959: LD_EXP 45
13963: AND
13964: IFFALSE 14027
13966: GO 13968
13968: DISABLE
13969: LD_INT 0
13971: PPUSH
// begin p := 0 ;
13972: LD_ADDR_VAR 0 1
13976: PUSH
13977: LD_INT 0
13979: ST_TO_ADDR
// repeat game_speed := 1 ;
13980: LD_ADDR_OWVAR 65
13984: PUSH
13985: LD_INT 1
13987: ST_TO_ADDR
// wait ( 0 0$1 ) ;
13988: LD_INT 35
13990: PPUSH
13991: CALL_OW 67
// p := p + 1 ;
13995: LD_ADDR_VAR 0 1
13999: PUSH
14000: LD_VAR 0 1
14004: PUSH
14005: LD_INT 1
14007: PLUS
14008: ST_TO_ADDR
// until p >= 60 ;
14009: LD_VAR 0 1
14013: PUSH
14014: LD_INT 60
14016: GREATEREQUAL
14017: IFFALSE 13980
// game_speed := 4 ;
14019: LD_ADDR_OWVAR 65
14023: PUSH
14024: LD_INT 4
14026: ST_TO_ADDR
// end ;
14027: PPOPN 1
14029: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14030: LD_EXP 19
14034: PUSH
14035: LD_EXP 46
14039: AND
14040: IFFALSE 14186
14042: GO 14044
14044: DISABLE
14045: LD_INT 0
14047: PPUSH
14048: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14049: LD_ADDR_VAR 0 1
14053: PUSH
14054: LD_INT 22
14056: PUSH
14057: LD_OWVAR 2
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: PUSH
14066: LD_INT 2
14068: PUSH
14069: LD_INT 30
14071: PUSH
14072: LD_INT 0
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PUSH
14079: LD_INT 30
14081: PUSH
14082: LD_INT 1
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PPUSH
14098: CALL_OW 69
14102: ST_TO_ADDR
// if not depot then
14103: LD_VAR 0 1
14107: NOT
14108: IFFALSE 14112
// exit ;
14110: GO 14186
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14112: LD_ADDR_VAR 0 2
14116: PUSH
14117: LD_VAR 0 1
14121: PUSH
14122: LD_INT 1
14124: PPUSH
14125: LD_VAR 0 1
14129: PPUSH
14130: CALL_OW 12
14134: ARRAY
14135: PPUSH
14136: CALL_OW 274
14140: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14141: LD_VAR 0 2
14145: PPUSH
14146: LD_INT 1
14148: PPUSH
14149: LD_INT 0
14151: PPUSH
14152: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_INT 2
14163: PPUSH
14164: LD_INT 0
14166: PPUSH
14167: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14171: LD_VAR 0 2
14175: PPUSH
14176: LD_INT 3
14178: PPUSH
14179: LD_INT 0
14181: PPUSH
14182: CALL_OW 277
// end ;
14186: PPOPN 2
14188: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14189: LD_EXP 19
14193: PUSH
14194: LD_EXP 47
14198: AND
14199: IFFALSE 14296
14201: GO 14203
14203: DISABLE
14204: LD_INT 0
14206: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14207: LD_ADDR_VAR 0 1
14211: PUSH
14212: LD_INT 22
14214: PUSH
14215: LD_OWVAR 2
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PUSH
14224: LD_INT 21
14226: PUSH
14227: LD_INT 1
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: LD_INT 3
14236: PUSH
14237: LD_INT 23
14239: PUSH
14240: LD_INT 0
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: PPUSH
14256: CALL_OW 69
14260: ST_TO_ADDR
// if not tmp then
14261: LD_VAR 0 1
14265: NOT
14266: IFFALSE 14270
// exit ;
14268: GO 14296
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14270: LD_VAR 0 1
14274: PUSH
14275: LD_INT 1
14277: PPUSH
14278: LD_VAR 0 1
14282: PPUSH
14283: CALL_OW 12
14287: ARRAY
14288: PPUSH
14289: LD_INT 200
14291: PPUSH
14292: CALL_OW 234
// end ;
14296: PPOPN 1
14298: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14299: LD_EXP 19
14303: PUSH
14304: LD_EXP 48
14308: AND
14309: IFFALSE 14388
14311: GO 14313
14313: DISABLE
14314: LD_INT 0
14316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14317: LD_ADDR_VAR 0 1
14321: PUSH
14322: LD_INT 22
14324: PUSH
14325: LD_OWVAR 2
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 2
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PPUSH
14348: CALL_OW 69
14352: ST_TO_ADDR
// if not tmp then
14353: LD_VAR 0 1
14357: NOT
14358: IFFALSE 14362
// exit ;
14360: GO 14388
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14362: LD_VAR 0 1
14366: PUSH
14367: LD_INT 1
14369: PPUSH
14370: LD_VAR 0 1
14374: PPUSH
14375: CALL_OW 12
14379: ARRAY
14380: PPUSH
14381: LD_INT 60
14383: PPUSH
14384: CALL_OW 234
// end ;
14388: PPOPN 1
14390: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14391: LD_EXP 19
14395: PUSH
14396: LD_EXP 49
14400: AND
14401: IFFALSE 14500
14403: GO 14405
14405: DISABLE
14406: LD_INT 0
14408: PPUSH
14409: PPUSH
// begin enable ;
14410: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14411: LD_ADDR_VAR 0 1
14415: PUSH
14416: LD_INT 22
14418: PUSH
14419: LD_OWVAR 2
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 61
14430: PUSH
14431: EMPTY
14432: LIST
14433: PUSH
14434: LD_INT 33
14436: PUSH
14437: LD_INT 2
14439: PUSH
14440: EMPTY
14441: LIST
14442: LIST
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: LIST
14448: PPUSH
14449: CALL_OW 69
14453: ST_TO_ADDR
// if not tmp then
14454: LD_VAR 0 1
14458: NOT
14459: IFFALSE 14463
// exit ;
14461: GO 14500
// for i in tmp do
14463: LD_ADDR_VAR 0 2
14467: PUSH
14468: LD_VAR 0 1
14472: PUSH
14473: FOR_IN
14474: IFFALSE 14498
// if IsControledBy ( i ) then
14476: LD_VAR 0 2
14480: PPUSH
14481: CALL_OW 312
14485: IFFALSE 14496
// ComUnlink ( i ) ;
14487: LD_VAR 0 2
14491: PPUSH
14492: CALL_OW 136
14496: GO 14473
14498: POP
14499: POP
// end ;
14500: PPOPN 2
14502: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14503: LD_EXP 19
14507: PUSH
14508: LD_EXP 50
14512: AND
14513: IFFALSE 14653
14515: GO 14517
14517: DISABLE
14518: LD_INT 0
14520: PPUSH
14521: PPUSH
// begin ToLua ( displayPowell(); ) ;
14522: LD_STRING displayPowell();
14524: PPUSH
14525: CALL_OW 559
// uc_side := 0 ;
14529: LD_ADDR_OWVAR 20
14533: PUSH
14534: LD_INT 0
14536: ST_TO_ADDR
// uc_nation := 2 ;
14537: LD_ADDR_OWVAR 21
14541: PUSH
14542: LD_INT 2
14544: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14545: LD_ADDR_OWVAR 37
14549: PUSH
14550: LD_INT 14
14552: ST_TO_ADDR
// vc_engine := engine_siberite ;
14553: LD_ADDR_OWVAR 39
14557: PUSH
14558: LD_INT 3
14560: ST_TO_ADDR
// vc_control := control_apeman ;
14561: LD_ADDR_OWVAR 38
14565: PUSH
14566: LD_INT 5
14568: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14569: LD_ADDR_OWVAR 40
14573: PUSH
14574: LD_INT 29
14576: ST_TO_ADDR
// un := CreateVehicle ;
14577: LD_ADDR_VAR 0 2
14581: PUSH
14582: CALL_OW 45
14586: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14587: LD_VAR 0 2
14591: PPUSH
14592: LD_INT 1
14594: PPUSH
14595: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14599: LD_INT 35
14601: PPUSH
14602: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
14606: LD_VAR 0 2
14610: PPUSH
14611: LD_INT 22
14613: PUSH
14614: LD_OWVAR 2
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PPUSH
14623: CALL_OW 69
14627: PPUSH
14628: LD_VAR 0 2
14632: PPUSH
14633: CALL_OW 74
14637: PPUSH
14638: CALL_OW 115
// until IsDead ( un ) ;
14642: LD_VAR 0 2
14646: PPUSH
14647: CALL_OW 301
14651: IFFALSE 14599
// end ;
14653: PPOPN 2
14655: END
// every 0 0$1 trigger StreamModeActive and sStu do
14656: LD_EXP 19
14660: PUSH
14661: LD_EXP 58
14665: AND
14666: IFFALSE 14682
14668: GO 14670
14670: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14671: LD_STRING displayStucuk();
14673: PPUSH
14674: CALL_OW 559
// ResetFog ;
14678: CALL_OW 335
// end ;
14682: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14683: LD_EXP 19
14687: PUSH
14688: LD_EXP 51
14692: AND
14693: IFFALSE 14834
14695: GO 14697
14697: DISABLE
14698: LD_INT 0
14700: PPUSH
14701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14702: LD_ADDR_VAR 0 2
14706: PUSH
14707: LD_INT 22
14709: PUSH
14710: LD_OWVAR 2
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: LD_INT 21
14721: PUSH
14722: LD_INT 1
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PPUSH
14733: CALL_OW 69
14737: ST_TO_ADDR
// if not tmp then
14738: LD_VAR 0 2
14742: NOT
14743: IFFALSE 14747
// exit ;
14745: GO 14834
// un := tmp [ rand ( 1 , tmp ) ] ;
14747: LD_ADDR_VAR 0 1
14751: PUSH
14752: LD_VAR 0 2
14756: PUSH
14757: LD_INT 1
14759: PPUSH
14760: LD_VAR 0 2
14764: PPUSH
14765: CALL_OW 12
14769: ARRAY
14770: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14771: LD_VAR 0 1
14775: PPUSH
14776: LD_INT 0
14778: PPUSH
14779: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14783: LD_VAR 0 1
14787: PPUSH
14788: LD_OWVAR 3
14792: PUSH
14793: LD_VAR 0 1
14797: DIFF
14798: PPUSH
14799: LD_VAR 0 1
14803: PPUSH
14804: CALL_OW 74
14808: PPUSH
14809: CALL_OW 115
// wait ( 0 0$20 ) ;
14813: LD_INT 700
14815: PPUSH
14816: CALL_OW 67
// SetSide ( un , your_side ) ;
14820: LD_VAR 0 1
14824: PPUSH
14825: LD_OWVAR 2
14829: PPUSH
14830: CALL_OW 235
// end ;
14834: PPOPN 2
14836: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14837: LD_EXP 19
14841: PUSH
14842: LD_EXP 52
14846: AND
14847: IFFALSE 14953
14849: GO 14851
14851: DISABLE
14852: LD_INT 0
14854: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14855: LD_ADDR_VAR 0 1
14859: PUSH
14860: LD_INT 22
14862: PUSH
14863: LD_OWVAR 2
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 2
14874: PUSH
14875: LD_INT 30
14877: PUSH
14878: LD_INT 0
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 30
14887: PUSH
14888: LD_INT 1
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: LIST
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: PPUSH
14904: CALL_OW 69
14908: ST_TO_ADDR
// if not depot then
14909: LD_VAR 0 1
14913: NOT
14914: IFFALSE 14918
// exit ;
14916: GO 14953
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
14918: LD_VAR 0 1
14922: PUSH
14923: LD_INT 1
14925: ARRAY
14926: PPUSH
14927: CALL_OW 250
14931: PPUSH
14932: LD_VAR 0 1
14936: PUSH
14937: LD_INT 1
14939: ARRAY
14940: PPUSH
14941: CALL_OW 251
14945: PPUSH
14946: LD_INT 70
14948: PPUSH
14949: CALL_OW 495
// end ;
14953: PPOPN 1
14955: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
14956: LD_EXP 19
14960: PUSH
14961: LD_EXP 53
14965: AND
14966: IFFALSE 15177
14968: GO 14970
14970: DISABLE
14971: LD_INT 0
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
14977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14978: LD_ADDR_VAR 0 5
14982: PUSH
14983: LD_INT 22
14985: PUSH
14986: LD_OWVAR 2
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: PUSH
14995: LD_INT 21
14997: PUSH
14998: LD_INT 1
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PPUSH
15009: CALL_OW 69
15013: ST_TO_ADDR
// if not tmp then
15014: LD_VAR 0 5
15018: NOT
15019: IFFALSE 15023
// exit ;
15021: GO 15177
// for i in tmp do
15023: LD_ADDR_VAR 0 1
15027: PUSH
15028: LD_VAR 0 5
15032: PUSH
15033: FOR_IN
15034: IFFALSE 15175
// begin d := rand ( 0 , 5 ) ;
15036: LD_ADDR_VAR 0 4
15040: PUSH
15041: LD_INT 0
15043: PPUSH
15044: LD_INT 5
15046: PPUSH
15047: CALL_OW 12
15051: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15052: LD_ADDR_VAR 0 2
15056: PUSH
15057: LD_VAR 0 1
15061: PPUSH
15062: CALL_OW 250
15066: PPUSH
15067: LD_VAR 0 4
15071: PPUSH
15072: LD_INT 3
15074: PPUSH
15075: LD_INT 12
15077: PPUSH
15078: CALL_OW 12
15082: PPUSH
15083: CALL_OW 272
15087: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15088: LD_ADDR_VAR 0 3
15092: PUSH
15093: LD_VAR 0 1
15097: PPUSH
15098: CALL_OW 251
15102: PPUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_INT 3
15110: PPUSH
15111: LD_INT 12
15113: PPUSH
15114: CALL_OW 12
15118: PPUSH
15119: CALL_OW 273
15123: ST_TO_ADDR
// if ValidHex ( x , y ) then
15124: LD_VAR 0 2
15128: PPUSH
15129: LD_VAR 0 3
15133: PPUSH
15134: CALL_OW 488
15138: IFFALSE 15173
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15140: LD_VAR 0 1
15144: PPUSH
15145: LD_VAR 0 2
15149: PPUSH
15150: LD_VAR 0 3
15154: PPUSH
15155: LD_INT 3
15157: PPUSH
15158: LD_INT 6
15160: PPUSH
15161: CALL_OW 12
15165: PPUSH
15166: LD_INT 1
15168: PPUSH
15169: CALL_OW 483
// end ;
15173: GO 15033
15175: POP
15176: POP
// end ;
15177: PPOPN 5
15179: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15180: LD_EXP 19
15184: PUSH
15185: LD_EXP 54
15189: AND
15190: IFFALSE 15284
15192: GO 15194
15194: DISABLE
15195: LD_INT 0
15197: PPUSH
15198: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15199: LD_ADDR_VAR 0 2
15203: PUSH
15204: LD_INT 22
15206: PUSH
15207: LD_OWVAR 2
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: PUSH
15216: LD_INT 32
15218: PUSH
15219: LD_INT 1
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 21
15228: PUSH
15229: LD_INT 2
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: LIST
15240: PPUSH
15241: CALL_OW 69
15245: ST_TO_ADDR
// if not tmp then
15246: LD_VAR 0 2
15250: NOT
15251: IFFALSE 15255
// exit ;
15253: GO 15284
// for i in tmp do
15255: LD_ADDR_VAR 0 1
15259: PUSH
15260: LD_VAR 0 2
15264: PUSH
15265: FOR_IN
15266: IFFALSE 15282
// SetFuel ( i , 0 ) ;
15268: LD_VAR 0 1
15272: PPUSH
15273: LD_INT 0
15275: PPUSH
15276: CALL_OW 240
15280: GO 15265
15282: POP
15283: POP
// end ;
15284: PPOPN 2
15286: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15287: LD_EXP 19
15291: PUSH
15292: LD_EXP 55
15296: AND
15297: IFFALSE 15363
15299: GO 15301
15301: DISABLE
15302: LD_INT 0
15304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15305: LD_ADDR_VAR 0 1
15309: PUSH
15310: LD_INT 22
15312: PUSH
15313: LD_OWVAR 2
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 30
15324: PUSH
15325: LD_INT 29
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PPUSH
15336: CALL_OW 69
15340: ST_TO_ADDR
// if not tmp then
15341: LD_VAR 0 1
15345: NOT
15346: IFFALSE 15350
// exit ;
15348: GO 15363
// DestroyUnit ( tmp [ 1 ] ) ;
15350: LD_VAR 0 1
15354: PUSH
15355: LD_INT 1
15357: ARRAY
15358: PPUSH
15359: CALL_OW 65
// end ;
15363: PPOPN 1
15365: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15366: LD_EXP 19
15370: PUSH
15371: LD_EXP 57
15375: AND
15376: IFFALSE 15505
15378: GO 15380
15380: DISABLE
15381: LD_INT 0
15383: PPUSH
// begin uc_side := 0 ;
15384: LD_ADDR_OWVAR 20
15388: PUSH
15389: LD_INT 0
15391: ST_TO_ADDR
// uc_nation := nation_arabian ;
15392: LD_ADDR_OWVAR 21
15396: PUSH
15397: LD_INT 2
15399: ST_TO_ADDR
// hc_gallery :=  ;
15400: LD_ADDR_OWVAR 33
15404: PUSH
15405: LD_STRING 
15407: ST_TO_ADDR
// hc_name :=  ;
15408: LD_ADDR_OWVAR 26
15412: PUSH
15413: LD_STRING 
15415: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15416: LD_INT 1
15418: PPUSH
15419: LD_INT 11
15421: PPUSH
15422: LD_INT 10
15424: PPUSH
15425: CALL_OW 380
// un := CreateHuman ;
15429: LD_ADDR_VAR 0 1
15433: PUSH
15434: CALL_OW 44
15438: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15439: LD_VAR 0 1
15443: PPUSH
15444: LD_INT 1
15446: PPUSH
15447: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15451: LD_INT 35
15453: PPUSH
15454: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15458: LD_VAR 0 1
15462: PPUSH
15463: LD_INT 22
15465: PUSH
15466: LD_OWVAR 2
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PPUSH
15475: CALL_OW 69
15479: PPUSH
15480: LD_VAR 0 1
15484: PPUSH
15485: CALL_OW 74
15489: PPUSH
15490: CALL_OW 115
// until IsDead ( un ) ;
15494: LD_VAR 0 1
15498: PPUSH
15499: CALL_OW 301
15503: IFFALSE 15451
// end ;
15505: PPOPN 1
15507: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15508: LD_EXP 19
15512: PUSH
15513: LD_EXP 59
15517: AND
15518: IFFALSE 15530
15520: GO 15522
15522: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15523: LD_STRING earthquake(getX(game), 0, 32)
15525: PPUSH
15526: CALL_OW 559
15530: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15531: LD_EXP 19
15535: PUSH
15536: LD_EXP 60
15540: AND
15541: IFFALSE 15632
15543: GO 15545
15545: DISABLE
15546: LD_INT 0
15548: PPUSH
// begin enable ;
15549: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15550: LD_ADDR_VAR 0 1
15554: PUSH
15555: LD_INT 22
15557: PUSH
15558: LD_OWVAR 2
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PUSH
15567: LD_INT 21
15569: PUSH
15570: LD_INT 2
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: PUSH
15577: LD_INT 33
15579: PUSH
15580: LD_INT 3
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: LIST
15591: PPUSH
15592: CALL_OW 69
15596: ST_TO_ADDR
// if not tmp then
15597: LD_VAR 0 1
15601: NOT
15602: IFFALSE 15606
// exit ;
15604: GO 15632
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15606: LD_VAR 0 1
15610: PUSH
15611: LD_INT 1
15613: PPUSH
15614: LD_VAR 0 1
15618: PPUSH
15619: CALL_OW 12
15623: ARRAY
15624: PPUSH
15625: LD_INT 1
15627: PPUSH
15628: CALL_OW 234
// end ;
15632: PPOPN 1
15634: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15635: LD_EXP 19
15639: PUSH
15640: LD_EXP 61
15644: AND
15645: IFFALSE 15786
15647: GO 15649
15649: DISABLE
15650: LD_INT 0
15652: PPUSH
15653: PPUSH
15654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15655: LD_ADDR_VAR 0 3
15659: PUSH
15660: LD_INT 22
15662: PUSH
15663: LD_OWVAR 2
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 25
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PPUSH
15686: CALL_OW 69
15690: ST_TO_ADDR
// if not tmp then
15691: LD_VAR 0 3
15695: NOT
15696: IFFALSE 15700
// exit ;
15698: GO 15786
// un := tmp [ rand ( 1 , tmp ) ] ;
15700: LD_ADDR_VAR 0 2
15704: PUSH
15705: LD_VAR 0 3
15709: PUSH
15710: LD_INT 1
15712: PPUSH
15713: LD_VAR 0 3
15717: PPUSH
15718: CALL_OW 12
15722: ARRAY
15723: ST_TO_ADDR
// if Crawls ( un ) then
15724: LD_VAR 0 2
15728: PPUSH
15729: CALL_OW 318
15733: IFFALSE 15744
// ComWalk ( un ) ;
15735: LD_VAR 0 2
15739: PPUSH
15740: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15744: LD_VAR 0 2
15748: PPUSH
15749: LD_INT 9
15751: PPUSH
15752: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
15756: LD_INT 28
15758: PPUSH
15759: LD_OWVAR 2
15763: PPUSH
15764: LD_INT 2
15766: PPUSH
15767: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
15771: LD_INT 29
15773: PPUSH
15774: LD_OWVAR 2
15778: PPUSH
15779: LD_INT 2
15781: PPUSH
15782: CALL_OW 322
// end ;
15786: PPOPN 3
15788: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
15789: LD_EXP 19
15793: PUSH
15794: LD_EXP 62
15798: AND
15799: IFFALSE 15910
15801: GO 15803
15803: DISABLE
15804: LD_INT 0
15806: PPUSH
15807: PPUSH
15808: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15809: LD_ADDR_VAR 0 3
15813: PUSH
15814: LD_INT 22
15816: PUSH
15817: LD_OWVAR 2
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PUSH
15826: LD_INT 25
15828: PUSH
15829: LD_INT 1
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PUSH
15836: EMPTY
15837: LIST
15838: LIST
15839: PPUSH
15840: CALL_OW 69
15844: ST_TO_ADDR
// if not tmp then
15845: LD_VAR 0 3
15849: NOT
15850: IFFALSE 15854
// exit ;
15852: GO 15910
// un := tmp [ rand ( 1 , tmp ) ] ;
15854: LD_ADDR_VAR 0 2
15858: PUSH
15859: LD_VAR 0 3
15863: PUSH
15864: LD_INT 1
15866: PPUSH
15867: LD_VAR 0 3
15871: PPUSH
15872: CALL_OW 12
15876: ARRAY
15877: ST_TO_ADDR
// if Crawls ( un ) then
15878: LD_VAR 0 2
15882: PPUSH
15883: CALL_OW 318
15887: IFFALSE 15898
// ComWalk ( un ) ;
15889: LD_VAR 0 2
15893: PPUSH
15894: CALL_OW 138
// SetClass ( un , class_mortar ) ;
15898: LD_VAR 0 2
15902: PPUSH
15903: LD_INT 8
15905: PPUSH
15906: CALL_OW 336
// end ;
15910: PPOPN 3
15912: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
15913: LD_EXP 19
15917: PUSH
15918: LD_EXP 63
15922: AND
15923: IFFALSE 16067
15925: GO 15927
15927: DISABLE
15928: LD_INT 0
15930: PPUSH
15931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
15932: LD_ADDR_VAR 0 2
15936: PUSH
15937: LD_INT 22
15939: PUSH
15940: LD_OWVAR 2
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: LD_INT 21
15951: PUSH
15952: LD_INT 2
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: PUSH
15959: LD_INT 2
15961: PUSH
15962: LD_INT 34
15964: PUSH
15965: LD_INT 12
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: PUSH
15972: LD_INT 34
15974: PUSH
15975: LD_INT 51
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PUSH
15982: LD_INT 34
15984: PUSH
15985: LD_INT 32
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: ST_TO_ADDR
// if not tmp then
16008: LD_VAR 0 2
16012: NOT
16013: IFFALSE 16017
// exit ;
16015: GO 16067
// for i in tmp do
16017: LD_ADDR_VAR 0 1
16021: PUSH
16022: LD_VAR 0 2
16026: PUSH
16027: FOR_IN
16028: IFFALSE 16065
// if GetCargo ( i , mat_artifact ) = 0 then
16030: LD_VAR 0 1
16034: PPUSH
16035: LD_INT 4
16037: PPUSH
16038: CALL_OW 289
16042: PUSH
16043: LD_INT 0
16045: EQUAL
16046: IFFALSE 16063
// SetCargo ( i , mat_siberit , 100 ) ;
16048: LD_VAR 0 1
16052: PPUSH
16053: LD_INT 3
16055: PPUSH
16056: LD_INT 100
16058: PPUSH
16059: CALL_OW 290
16063: GO 16027
16065: POP
16066: POP
// end ;
16067: PPOPN 2
16069: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
16070: LD_EXP 19
16074: PUSH
16075: LD_EXP 64
16079: AND
16080: IFFALSE 16233
16082: GO 16084
16084: DISABLE
16085: LD_INT 0
16087: PPUSH
16088: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
16089: LD_ADDR_VAR 0 2
16093: PUSH
16094: LD_INT 22
16096: PUSH
16097: LD_OWVAR 2
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 69
16110: ST_TO_ADDR
// if not tmp then
16111: LD_VAR 0 2
16115: NOT
16116: IFFALSE 16120
// exit ;
16118: GO 16233
// for i := 1 to 2 do
16120: LD_ADDR_VAR 0 1
16124: PUSH
16125: DOUBLE
16126: LD_INT 1
16128: DEC
16129: ST_TO_ADDR
16130: LD_INT 2
16132: PUSH
16133: FOR_TO
16134: IFFALSE 16231
// begin uc_side := your_side ;
16136: LD_ADDR_OWVAR 20
16140: PUSH
16141: LD_OWVAR 2
16145: ST_TO_ADDR
// uc_nation := nation_american ;
16146: LD_ADDR_OWVAR 21
16150: PUSH
16151: LD_INT 1
16153: ST_TO_ADDR
// vc_chassis := us_morphling ;
16154: LD_ADDR_OWVAR 37
16158: PUSH
16159: LD_INT 5
16161: ST_TO_ADDR
// vc_engine := engine_siberite ;
16162: LD_ADDR_OWVAR 39
16166: PUSH
16167: LD_INT 3
16169: ST_TO_ADDR
// vc_control := control_computer ;
16170: LD_ADDR_OWVAR 38
16174: PUSH
16175: LD_INT 3
16177: ST_TO_ADDR
// vc_weapon := us_double_laser ;
16178: LD_ADDR_OWVAR 40
16182: PUSH
16183: LD_INT 10
16185: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
16186: CALL_OW 45
16190: PPUSH
16191: LD_VAR 0 2
16195: PUSH
16196: LD_INT 1
16198: ARRAY
16199: PPUSH
16200: CALL_OW 250
16204: PPUSH
16205: LD_VAR 0 2
16209: PUSH
16210: LD_INT 1
16212: ARRAY
16213: PPUSH
16214: CALL_OW 251
16218: PPUSH
16219: LD_INT 12
16221: PPUSH
16222: LD_INT 1
16224: PPUSH
16225: CALL_OW 50
// end ;
16229: GO 16133
16231: POP
16232: POP
// end ;
16233: PPOPN 2
16235: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
16236: LD_EXP 19
16240: PUSH
16241: LD_EXP 65
16245: AND
16246: IFFALSE 16468
16248: GO 16250
16250: DISABLE
16251: LD_INT 0
16253: PPUSH
16254: PPUSH
16255: PPUSH
16256: PPUSH
16257: PPUSH
16258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16259: LD_ADDR_VAR 0 6
16263: PUSH
16264: LD_INT 22
16266: PUSH
16267: LD_OWVAR 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: LD_INT 21
16278: PUSH
16279: LD_INT 1
16281: PUSH
16282: EMPTY
16283: LIST
16284: LIST
16285: PUSH
16286: LD_INT 3
16288: PUSH
16289: LD_INT 23
16291: PUSH
16292: LD_INT 0
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: LIST
16307: PPUSH
16308: CALL_OW 69
16312: ST_TO_ADDR
// if not tmp then
16313: LD_VAR 0 6
16317: NOT
16318: IFFALSE 16322
// exit ;
16320: GO 16468
// s1 := rand ( 1 , 4 ) ;
16322: LD_ADDR_VAR 0 2
16326: PUSH
16327: LD_INT 1
16329: PPUSH
16330: LD_INT 4
16332: PPUSH
16333: CALL_OW 12
16337: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
16338: LD_ADDR_VAR 0 4
16342: PUSH
16343: LD_VAR 0 6
16347: PUSH
16348: LD_INT 1
16350: ARRAY
16351: PPUSH
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 259
16361: ST_TO_ADDR
// if s1 = 1 then
16362: LD_VAR 0 2
16366: PUSH
16367: LD_INT 1
16369: EQUAL
16370: IFFALSE 16390
// s2 := rand ( 2 , 4 ) else
16372: LD_ADDR_VAR 0 3
16376: PUSH
16377: LD_INT 2
16379: PPUSH
16380: LD_INT 4
16382: PPUSH
16383: CALL_OW 12
16387: ST_TO_ADDR
16388: GO 16398
// s2 := 1 ;
16390: LD_ADDR_VAR 0 3
16394: PUSH
16395: LD_INT 1
16397: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16398: LD_ADDR_VAR 0 5
16402: PUSH
16403: LD_VAR 0 6
16407: PUSH
16408: LD_INT 1
16410: ARRAY
16411: PPUSH
16412: LD_VAR 0 3
16416: PPUSH
16417: CALL_OW 259
16421: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16422: LD_VAR 0 6
16426: PUSH
16427: LD_INT 1
16429: ARRAY
16430: PPUSH
16431: LD_VAR 0 2
16435: PPUSH
16436: LD_VAR 0 5
16440: PPUSH
16441: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16445: LD_VAR 0 6
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: LD_VAR 0 3
16458: PPUSH
16459: LD_VAR 0 4
16463: PPUSH
16464: CALL_OW 237
// end ;
16468: PPOPN 6
16470: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16471: LD_EXP 19
16475: PUSH
16476: LD_EXP 66
16480: AND
16481: IFFALSE 16560
16483: GO 16485
16485: DISABLE
16486: LD_INT 0
16488: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16489: LD_ADDR_VAR 0 1
16493: PUSH
16494: LD_INT 22
16496: PUSH
16497: LD_OWVAR 2
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: LD_INT 30
16508: PUSH
16509: LD_INT 3
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: PPUSH
16520: CALL_OW 69
16524: ST_TO_ADDR
// if not tmp then
16525: LD_VAR 0 1
16529: NOT
16530: IFFALSE 16534
// exit ;
16532: GO 16560
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16534: LD_VAR 0 1
16538: PUSH
16539: LD_INT 1
16541: PPUSH
16542: LD_VAR 0 1
16546: PPUSH
16547: CALL_OW 12
16551: ARRAY
16552: PPUSH
16553: LD_INT 1
16555: PPUSH
16556: CALL_OW 234
// end ;
16560: PPOPN 1
16562: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16563: LD_EXP 19
16567: PUSH
16568: LD_EXP 67
16572: AND
16573: IFFALSE 16685
16575: GO 16577
16577: DISABLE
16578: LD_INT 0
16580: PPUSH
16581: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16582: LD_ADDR_VAR 0 2
16586: PUSH
16587: LD_INT 22
16589: PUSH
16590: LD_OWVAR 2
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: PUSH
16599: LD_INT 2
16601: PUSH
16602: LD_INT 30
16604: PUSH
16605: LD_INT 27
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 30
16614: PUSH
16615: LD_INT 26
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: LD_INT 30
16624: PUSH
16625: LD_INT 28
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: LIST
16636: LIST
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: PPUSH
16642: CALL_OW 69
16646: ST_TO_ADDR
// if not tmp then
16647: LD_VAR 0 2
16651: NOT
16652: IFFALSE 16656
// exit ;
16654: GO 16685
// for i in tmp do
16656: LD_ADDR_VAR 0 1
16660: PUSH
16661: LD_VAR 0 2
16665: PUSH
16666: FOR_IN
16667: IFFALSE 16683
// SetLives ( i , 1 ) ;
16669: LD_VAR 0 1
16673: PPUSH
16674: LD_INT 1
16676: PPUSH
16677: CALL_OW 234
16681: GO 16666
16683: POP
16684: POP
// end ;
16685: PPOPN 2
16687: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16688: LD_EXP 19
16692: PUSH
16693: LD_EXP 68
16697: AND
16698: IFFALSE 16972
16700: GO 16702
16702: DISABLE
16703: LD_INT 0
16705: PPUSH
16706: PPUSH
16707: PPUSH
// begin i := rand ( 1 , 7 ) ;
16708: LD_ADDR_VAR 0 1
16712: PUSH
16713: LD_INT 1
16715: PPUSH
16716: LD_INT 7
16718: PPUSH
16719: CALL_OW 12
16723: ST_TO_ADDR
// case i of 1 :
16724: LD_VAR 0 1
16728: PUSH
16729: LD_INT 1
16731: DOUBLE
16732: EQUAL
16733: IFTRUE 16737
16735: GO 16747
16737: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16738: LD_STRING earthquake(getX(game), 0, 32)
16740: PPUSH
16741: CALL_OW 559
16745: GO 16972
16747: LD_INT 2
16749: DOUBLE
16750: EQUAL
16751: IFTRUE 16755
16753: GO 16769
16755: POP
// begin ToLua ( displayStucuk(); ) ;
16756: LD_STRING displayStucuk();
16758: PPUSH
16759: CALL_OW 559
// ResetFog ;
16763: CALL_OW 335
// end ; 3 :
16767: GO 16972
16769: LD_INT 3
16771: DOUBLE
16772: EQUAL
16773: IFTRUE 16777
16775: GO 16881
16777: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16778: LD_ADDR_VAR 0 2
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_OWVAR 2
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 25
16797: PUSH
16798: LD_INT 1
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PPUSH
16809: CALL_OW 69
16813: ST_TO_ADDR
// if not tmp then
16814: LD_VAR 0 2
16818: NOT
16819: IFFALSE 16823
// exit ;
16821: GO 16972
// un := tmp [ rand ( 1 , tmp ) ] ;
16823: LD_ADDR_VAR 0 3
16827: PUSH
16828: LD_VAR 0 2
16832: PUSH
16833: LD_INT 1
16835: PPUSH
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 12
16845: ARRAY
16846: ST_TO_ADDR
// if Crawls ( un ) then
16847: LD_VAR 0 3
16851: PPUSH
16852: CALL_OW 318
16856: IFFALSE 16867
// ComWalk ( un ) ;
16858: LD_VAR 0 3
16862: PPUSH
16863: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16867: LD_VAR 0 3
16871: PPUSH
16872: LD_INT 8
16874: PPUSH
16875: CALL_OW 336
// end ; 4 :
16879: GO 16972
16881: LD_INT 4
16883: DOUBLE
16884: EQUAL
16885: IFTRUE 16889
16887: GO 16950
16889: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16890: LD_ADDR_VAR 0 2
16894: PUSH
16895: LD_INT 22
16897: PUSH
16898: LD_OWVAR 2
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: LD_INT 30
16909: PUSH
16910: LD_INT 29
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: PPUSH
16921: CALL_OW 69
16925: ST_TO_ADDR
// if not tmp then
16926: LD_VAR 0 2
16930: NOT
16931: IFFALSE 16935
// exit ;
16933: GO 16972
// DestroyUnit ( tmp [ 1 ] ) ;
16935: LD_VAR 0 2
16939: PUSH
16940: LD_INT 1
16942: ARRAY
16943: PPUSH
16944: CALL_OW 65
// end ; 5 .. 7 :
16948: GO 16972
16950: LD_INT 5
16952: DOUBLE
16953: GREATEREQUAL
16954: IFFALSE 16962
16956: LD_INT 7
16958: DOUBLE
16959: LESSEQUAL
16960: IFTRUE 16964
16962: GO 16971
16964: POP
// StreamSibBomb ; end ;
16965: CALL 13252 0 0
16969: GO 16972
16971: POP
// end ;
16972: PPOPN 3
16974: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
16975: LD_EXP 19
16979: PUSH
16980: LD_EXP 69
16984: AND
16985: IFFALSE 17141
16987: GO 16989
16989: DISABLE
16990: LD_INT 0
16992: PPUSH
16993: PPUSH
16994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
16995: LD_ADDR_VAR 0 2
16999: PUSH
17000: LD_INT 81
17002: PUSH
17003: LD_OWVAR 2
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 2
17014: PUSH
17015: LD_INT 21
17017: PUSH
17018: LD_INT 1
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: LD_INT 21
17027: PUSH
17028: LD_INT 2
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: LIST
17039: PUSH
17040: EMPTY
17041: LIST
17042: LIST
17043: PPUSH
17044: CALL_OW 69
17048: ST_TO_ADDR
// if not tmp then
17049: LD_VAR 0 2
17053: NOT
17054: IFFALSE 17058
// exit ;
17056: GO 17141
// p := 0 ;
17058: LD_ADDR_VAR 0 3
17062: PUSH
17063: LD_INT 0
17065: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17066: LD_INT 35
17068: PPUSH
17069: CALL_OW 67
// p := p + 1 ;
17073: LD_ADDR_VAR 0 3
17077: PUSH
17078: LD_VAR 0 3
17082: PUSH
17083: LD_INT 1
17085: PLUS
17086: ST_TO_ADDR
// for i in tmp do
17087: LD_ADDR_VAR 0 1
17091: PUSH
17092: LD_VAR 0 2
17096: PUSH
17097: FOR_IN
17098: IFFALSE 17129
// if GetLives ( i ) < 1000 then
17100: LD_VAR 0 1
17104: PPUSH
17105: CALL_OW 256
17109: PUSH
17110: LD_INT 1000
17112: LESS
17113: IFFALSE 17127
// SetLives ( i , 1000 ) ;
17115: LD_VAR 0 1
17119: PPUSH
17120: LD_INT 1000
17122: PPUSH
17123: CALL_OW 234
17127: GO 17097
17129: POP
17130: POP
// until p > 20 ;
17131: LD_VAR 0 3
17135: PUSH
17136: LD_INT 20
17138: GREATER
17139: IFFALSE 17066
// end ;
17141: PPOPN 3
17143: END
// every 0 0$1 trigger StreamModeActive and sTime do
17144: LD_EXP 19
17148: PUSH
17149: LD_EXP 70
17153: AND
17154: IFFALSE 17189
17156: GO 17158
17158: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
17159: LD_INT 28
17161: PPUSH
17162: LD_OWVAR 2
17166: PPUSH
17167: LD_INT 2
17169: PPUSH
17170: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
17174: LD_INT 30
17176: PPUSH
17177: LD_OWVAR 2
17181: PPUSH
17182: LD_INT 2
17184: PPUSH
17185: CALL_OW 322
// end ;
17189: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
17190: LD_EXP 19
17194: PUSH
17195: LD_EXP 71
17199: AND
17200: IFFALSE 17321
17202: GO 17204
17204: DISABLE
17205: LD_INT 0
17207: PPUSH
17208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17209: LD_ADDR_VAR 0 2
17213: PUSH
17214: LD_INT 22
17216: PUSH
17217: LD_OWVAR 2
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 21
17228: PUSH
17229: LD_INT 1
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 3
17238: PUSH
17239: LD_INT 23
17241: PUSH
17242: LD_INT 0
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: PUSH
17249: EMPTY
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: ST_TO_ADDR
// if not tmp then
17263: LD_VAR 0 2
17267: NOT
17268: IFFALSE 17272
// exit ;
17270: GO 17321
// for i in tmp do
17272: LD_ADDR_VAR 0 1
17276: PUSH
17277: LD_VAR 0 2
17281: PUSH
17282: FOR_IN
17283: IFFALSE 17319
// begin if Crawls ( i ) then
17285: LD_VAR 0 1
17289: PPUSH
17290: CALL_OW 318
17294: IFFALSE 17305
// ComWalk ( i ) ;
17296: LD_VAR 0 1
17300: PPUSH
17301: CALL_OW 138
// SetClass ( i , 2 ) ;
17305: LD_VAR 0 1
17309: PPUSH
17310: LD_INT 2
17312: PPUSH
17313: CALL_OW 336
// end ;
17317: GO 17282
17319: POP
17320: POP
// end ;
17321: PPOPN 2
17323: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
17324: LD_EXP 19
17328: PUSH
17329: LD_EXP 72
17333: AND
17334: IFFALSE 17615
17336: GO 17338
17338: DISABLE
17339: LD_INT 0
17341: PPUSH
17342: PPUSH
17343: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
17344: LD_OWVAR 2
17348: PPUSH
17349: LD_INT 9
17351: PPUSH
17352: LD_INT 1
17354: PPUSH
17355: LD_INT 1
17357: PPUSH
17358: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17362: LD_INT 9
17364: PPUSH
17365: LD_OWVAR 2
17369: PPUSH
17370: CALL_OW 343
// uc_side := 9 ;
17374: LD_ADDR_OWVAR 20
17378: PUSH
17379: LD_INT 9
17381: ST_TO_ADDR
// uc_nation := 2 ;
17382: LD_ADDR_OWVAR 21
17386: PUSH
17387: LD_INT 2
17389: ST_TO_ADDR
// hc_name := Dark Warrior ;
17390: LD_ADDR_OWVAR 26
17394: PUSH
17395: LD_STRING Dark Warrior
17397: ST_TO_ADDR
// hc_gallery :=  ;
17398: LD_ADDR_OWVAR 33
17402: PUSH
17403: LD_STRING 
17405: ST_TO_ADDR
// hc_noskilllimit := true ;
17406: LD_ADDR_OWVAR 76
17410: PUSH
17411: LD_INT 1
17413: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
17414: LD_ADDR_OWVAR 31
17418: PUSH
17419: LD_INT 30
17421: PUSH
17422: LD_INT 30
17424: PUSH
17425: LD_INT 30
17427: PUSH
17428: LD_INT 30
17430: PUSH
17431: EMPTY
17432: LIST
17433: LIST
17434: LIST
17435: LIST
17436: ST_TO_ADDR
// un := CreateHuman ;
17437: LD_ADDR_VAR 0 3
17441: PUSH
17442: CALL_OW 44
17446: ST_TO_ADDR
// hc_noskilllimit := false ;
17447: LD_ADDR_OWVAR 76
17451: PUSH
17452: LD_INT 0
17454: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17455: LD_VAR 0 3
17459: PPUSH
17460: LD_INT 1
17462: PPUSH
17463: CALL_OW 51
// p := 0 ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 0
17474: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17475: LD_INT 35
17477: PPUSH
17478: CALL_OW 67
// p := p + 1 ;
17482: LD_ADDR_VAR 0 2
17486: PUSH
17487: LD_VAR 0 2
17491: PUSH
17492: LD_INT 1
17494: PLUS
17495: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
17496: LD_VAR 0 3
17500: PPUSH
17501: CALL_OW 256
17505: PUSH
17506: LD_INT 1000
17508: LESS
17509: IFFALSE 17523
// SetLives ( un , 1000 ) ;
17511: LD_VAR 0 3
17515: PPUSH
17516: LD_INT 1000
17518: PPUSH
17519: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
17523: LD_VAR 0 3
17527: PPUSH
17528: LD_INT 81
17530: PUSH
17531: LD_OWVAR 2
17535: PUSH
17536: EMPTY
17537: LIST
17538: LIST
17539: PUSH
17540: LD_INT 91
17542: PUSH
17543: LD_VAR 0 3
17547: PUSH
17548: LD_INT 30
17550: PUSH
17551: EMPTY
17552: LIST
17553: LIST
17554: LIST
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PPUSH
17560: CALL_OW 69
17564: PPUSH
17565: LD_VAR 0 3
17569: PPUSH
17570: CALL_OW 74
17574: PPUSH
17575: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17579: LD_VAR 0 2
17583: PUSH
17584: LD_INT 60
17586: GREATER
17587: PUSH
17588: LD_VAR 0 3
17592: PPUSH
17593: CALL_OW 301
17597: OR
17598: IFFALSE 17475
// if un then
17600: LD_VAR 0 3
17604: IFFALSE 17615
// RemoveUnit ( un ) ;
17606: LD_VAR 0 3
17610: PPUSH
17611: CALL_OW 64
// end ; end_of_file
17615: PPOPN 3
17617: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
17618: LD_INT 0
17620: PPUSH
17621: PPUSH
17622: PPUSH
17623: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17624: LD_VAR 0 1
17628: PPUSH
17629: CALL_OW 264
17633: PUSH
17634: LD_EXP 18
17638: EQUAL
17639: IFFALSE 17711
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17641: LD_INT 68
17643: PPUSH
17644: LD_VAR 0 1
17648: PPUSH
17649: CALL_OW 255
17653: PPUSH
17654: CALL_OW 321
17658: PUSH
17659: LD_INT 2
17661: EQUAL
17662: IFFALSE 17674
// eff := 70 else
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_INT 70
17671: ST_TO_ADDR
17672: GO 17682
// eff := 30 ;
17674: LD_ADDR_VAR 0 4
17678: PUSH
17679: LD_INT 30
17681: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17682: LD_VAR 0 1
17686: PPUSH
17687: CALL_OW 250
17691: PPUSH
17692: LD_VAR 0 1
17696: PPUSH
17697: CALL_OW 251
17701: PPUSH
17702: LD_VAR 0 4
17706: PPUSH
17707: CALL_OW 495
// end ; end ;
17711: LD_VAR 0 2
17715: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
17716: LD_INT 0
17718: PPUSH
// end ;
17719: LD_VAR 0 4
17723: RET
// export function SOS_Command ( cmd ) ; begin
17724: LD_INT 0
17726: PPUSH
// end ;
17727: LD_VAR 0 2
17731: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
17732: LD_VAR 0 1
17736: PUSH
17737: LD_INT 255
17739: EQUAL
17740: PUSH
17741: LD_VAR 0 2
17745: PPUSH
17746: CALL_OW 264
17750: PUSH
17751: LD_INT 14
17753: PUSH
17754: LD_INT 53
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: IN
17761: AND
17762: PUSH
17763: LD_VAR 0 4
17767: PPUSH
17768: LD_VAR 0 5
17772: PPUSH
17773: CALL_OW 488
17777: AND
17778: IFFALSE 17802
// CutTreeXYR ( unit , x , y , 12 ) ;
17780: LD_VAR 0 2
17784: PPUSH
17785: LD_VAR 0 4
17789: PPUSH
17790: LD_VAR 0 5
17794: PPUSH
17795: LD_INT 12
17797: PPUSH
17798: CALL 17805 0 4
// end ;
17802: PPOPN 5
17804: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17805: LD_INT 0
17807: PPUSH
17808: PPUSH
17809: PPUSH
17810: PPUSH
17811: PPUSH
17812: PPUSH
17813: PPUSH
17814: PPUSH
17815: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17816: LD_VAR 0 1
17820: NOT
17821: PUSH
17822: LD_VAR 0 2
17826: PPUSH
17827: LD_VAR 0 3
17831: PPUSH
17832: CALL_OW 488
17836: NOT
17837: OR
17838: PUSH
17839: LD_VAR 0 4
17843: NOT
17844: OR
17845: IFFALSE 17849
// exit ;
17847: GO 18189
// list := [ ] ;
17849: LD_ADDR_VAR 0 13
17853: PUSH
17854: EMPTY
17855: ST_TO_ADDR
// if x - r < 0 then
17856: LD_VAR 0 2
17860: PUSH
17861: LD_VAR 0 4
17865: MINUS
17866: PUSH
17867: LD_INT 0
17869: LESS
17870: IFFALSE 17882
// min_x := 0 else
17872: LD_ADDR_VAR 0 7
17876: PUSH
17877: LD_INT 0
17879: ST_TO_ADDR
17880: GO 17898
// min_x := x - r ;
17882: LD_ADDR_VAR 0 7
17886: PUSH
17887: LD_VAR 0 2
17891: PUSH
17892: LD_VAR 0 4
17896: MINUS
17897: ST_TO_ADDR
// if y - r < 0 then
17898: LD_VAR 0 3
17902: PUSH
17903: LD_VAR 0 4
17907: MINUS
17908: PUSH
17909: LD_INT 0
17911: LESS
17912: IFFALSE 17924
// min_y := 0 else
17914: LD_ADDR_VAR 0 8
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
17922: GO 17940
// min_y := y - r ;
17924: LD_ADDR_VAR 0 8
17928: PUSH
17929: LD_VAR 0 3
17933: PUSH
17934: LD_VAR 0 4
17938: MINUS
17939: ST_TO_ADDR
// max_x := x + r ;
17940: LD_ADDR_VAR 0 9
17944: PUSH
17945: LD_VAR 0 2
17949: PUSH
17950: LD_VAR 0 4
17954: PLUS
17955: ST_TO_ADDR
// max_y := y + r ;
17956: LD_ADDR_VAR 0 10
17960: PUSH
17961: LD_VAR 0 3
17965: PUSH
17966: LD_VAR 0 4
17970: PLUS
17971: ST_TO_ADDR
// for _x = min_x to max_x do
17972: LD_ADDR_VAR 0 11
17976: PUSH
17977: DOUBLE
17978: LD_VAR 0 7
17982: DEC
17983: ST_TO_ADDR
17984: LD_VAR 0 9
17988: PUSH
17989: FOR_TO
17990: IFFALSE 18107
// for _y = min_y to max_y do
17992: LD_ADDR_VAR 0 12
17996: PUSH
17997: DOUBLE
17998: LD_VAR 0 8
18002: DEC
18003: ST_TO_ADDR
18004: LD_VAR 0 10
18008: PUSH
18009: FOR_TO
18010: IFFALSE 18103
// begin if not ValidHex ( _x , _y ) then
18012: LD_VAR 0 11
18016: PPUSH
18017: LD_VAR 0 12
18021: PPUSH
18022: CALL_OW 488
18026: NOT
18027: IFFALSE 18031
// continue ;
18029: GO 18009
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18031: LD_VAR 0 11
18035: PPUSH
18036: LD_VAR 0 12
18040: PPUSH
18041: CALL_OW 351
18045: PUSH
18046: LD_VAR 0 11
18050: PPUSH
18051: LD_VAR 0 12
18055: PPUSH
18056: CALL_OW 554
18060: AND
18061: IFFALSE 18101
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18063: LD_ADDR_VAR 0 13
18067: PUSH
18068: LD_VAR 0 13
18072: PPUSH
18073: LD_VAR 0 13
18077: PUSH
18078: LD_INT 1
18080: PLUS
18081: PPUSH
18082: LD_VAR 0 11
18086: PUSH
18087: LD_VAR 0 12
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: PPUSH
18096: CALL_OW 2
18100: ST_TO_ADDR
// end ;
18101: GO 18009
18103: POP
18104: POP
18105: GO 17989
18107: POP
18108: POP
// if not list then
18109: LD_VAR 0 13
18113: NOT
18114: IFFALSE 18118
// exit ;
18116: GO 18189
// for i in list do
18118: LD_ADDR_VAR 0 6
18122: PUSH
18123: LD_VAR 0 13
18127: PUSH
18128: FOR_IN
18129: IFFALSE 18187
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18131: LD_VAR 0 1
18135: PPUSH
18136: LD_STRING M
18138: PUSH
18139: LD_VAR 0 6
18143: PUSH
18144: LD_INT 1
18146: ARRAY
18147: PUSH
18148: LD_VAR 0 6
18152: PUSH
18153: LD_INT 2
18155: ARRAY
18156: PUSH
18157: LD_INT 0
18159: PUSH
18160: LD_INT 0
18162: PUSH
18163: LD_INT 0
18165: PUSH
18166: LD_INT 0
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: LIST
18173: LIST
18174: LIST
18175: LIST
18176: LIST
18177: PUSH
18178: EMPTY
18179: LIST
18180: PPUSH
18181: CALL_OW 447
18185: GO 18128
18187: POP
18188: POP
// end ;
18189: LD_VAR 0 5
18193: RET
