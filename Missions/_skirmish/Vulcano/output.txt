// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3532 0 0
// PrepareLegion ;
  27: CALL 7063 0 0
// Action ;
  31: CALL 10742 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16057 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL 29715 0 1
// if GetSide ( un ) = your_side then
2516: LD_VAR 0 1
2520: PPUSH
2521: CALL_OW 255
2525: PUSH
2526: LD_OWVAR 2
2530: EQUAL
2531: IFFALSE 2547
// dead_counter := dead_counter + 1 ;
2533: LD_ADDR_EXP 14
2537: PUSH
2538: LD_EXP 14
2542: PUSH
2543: LD_INT 1
2545: PLUS
2546: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2547: LD_VAR 0 1
2551: PPUSH
2552: CALL_OW 255
2556: PUSH
2557: LD_INT 81
2559: PUSH
2560: LD_OWVAR 2
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PPUSH
2569: CALL_OW 69
2573: IN
2574: IFFALSE 2590
// kill_counter := kill_counter + 1 ;
2576: LD_ADDR_EXP 15
2580: PUSH
2581: LD_EXP 15
2585: PUSH
2586: LD_INT 1
2588: PLUS
2589: ST_TO_ADDR
// if un = player_commander then
2590: LD_VAR 0 1
2594: PUSH
2595: LD_EXP 10
2599: EQUAL
2600: IFFALSE 2609
// YouLost ( vulcano-lost ) ;
2602: LD_STRING vulcano-lost
2604: PPUSH
2605: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2609: LD_VAR 0 1
2613: PUSH
2614: LD_INT 22
2616: PUSH
2617: LD_INT 3
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 3
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: IN
2643: IFFALSE 2759
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2645: LD_VAR 0 1
2649: PPUSH
2650: CALL_OW 266
2654: PUSH
2655: LD_INT 33
2657: EQUAL
2658: PUSH
2659: LD_VAR 0 1
2663: PPUSH
2664: CALL_OW 266
2668: PUSH
2669: LD_INT 28
2671: EQUAL
2672: OR
2673: IFFALSE 2759
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2675: LD_ADDR_EXP 26
2679: PUSH
2680: LD_EXP 26
2684: PUSH
2685: LD_VAR 0 1
2689: PPUSH
2690: CALL_OW 266
2694: ADD
2695: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2696: LD_ADDR_EXP 26
2700: PUSH
2701: LD_EXP 26
2705: PUSH
2706: LD_VAR 0 1
2710: PPUSH
2711: CALL_OW 250
2715: ADD
2716: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2717: LD_ADDR_EXP 26
2721: PUSH
2722: LD_EXP 26
2726: PUSH
2727: LD_VAR 0 1
2731: PPUSH
2732: CALL_OW 251
2736: ADD
2737: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2738: LD_ADDR_EXP 26
2742: PUSH
2743: LD_EXP 26
2747: PUSH
2748: LD_VAR 0 1
2752: PPUSH
2753: CALL_OW 254
2757: ADD
2758: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2759: LD_VAR 0 1
2763: PUSH
2764: LD_INT 22
2766: PUSH
2767: LD_INT 8
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: LD_INT 21
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PPUSH
2788: CALL_OW 69
2792: IN
2793: IFFALSE 2937
// begin if GetBType ( un ) = b_barracks then
2795: LD_VAR 0 1
2799: PPUSH
2800: CALL_OW 266
2804: PUSH
2805: LD_INT 5
2807: EQUAL
2808: IFFALSE 2826
// legion_blist := legion_blist ^ b_armoury else
2810: LD_ADDR_EXP 34
2814: PUSH
2815: LD_EXP 34
2819: PUSH
2820: LD_INT 4
2822: ADD
2823: ST_TO_ADDR
2824: GO 2874
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2826: LD_VAR 0 1
2830: PPUSH
2831: CALL_OW 266
2835: PUSH
2836: LD_INT 1
2838: PUSH
2839: LD_INT 6
2841: PUSH
2842: LD_INT 8
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: LIST
2849: IN
2850: NOT
2851: IFFALSE 2874
// legion_blist := legion_blist ^ GetBType ( un ) ;
2853: LD_ADDR_EXP 34
2857: PUSH
2858: LD_EXP 34
2862: PUSH
2863: LD_VAR 0 1
2867: PPUSH
2868: CALL_OW 266
2872: ADD
2873: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2874: LD_ADDR_EXP 34
2878: PUSH
2879: LD_EXP 34
2883: PUSH
2884: LD_VAR 0 1
2888: PPUSH
2889: CALL_OW 250
2893: ADD
2894: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2895: LD_ADDR_EXP 34
2899: PUSH
2900: LD_EXP 34
2904: PUSH
2905: LD_VAR 0 1
2909: PPUSH
2910: CALL_OW 251
2914: ADD
2915: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2916: LD_ADDR_EXP 34
2920: PUSH
2921: LD_EXP 34
2925: PUSH
2926: LD_VAR 0 1
2930: PPUSH
2931: CALL_OW 254
2935: ADD
2936: ST_TO_ADDR
// end ; if un in legion_force then
2937: LD_VAR 0 1
2941: PUSH
2942: LD_EXP 31
2946: IN
2947: IFFALSE 2965
// legion_force := legion_force diff un ;
2949: LD_ADDR_EXP 31
2953: PUSH
2954: LD_EXP 31
2958: PUSH
2959: LD_VAR 0 1
2963: DIFF
2964: ST_TO_ADDR
// if un in ru_force then
2965: LD_VAR 0 1
2969: PUSH
2970: LD_EXP 23
2974: IN
2975: IFFALSE 2993
// ru_force := ru_force diff un ;
2977: LD_ADDR_EXP 23
2981: PUSH
2982: LD_EXP 23
2986: PUSH
2987: LD_VAR 0 1
2991: DIFF
2992: ST_TO_ADDR
// if un in al_force then
2993: LD_VAR 0 1
2997: PUSH
2998: LD_EXP 38
3002: IN
3003: IFFALSE 3021
// al_force := al_force diff un ;
3005: LD_ADDR_EXP 38
3009: PUSH
3010: LD_EXP 38
3014: PUSH
3015: LD_VAR 0 1
3019: DIFF
3020: ST_TO_ADDR
// end ;
3021: PPOPN 1
3023: END
// on BuildingComplete ( b ) do var i ;
3024: LD_INT 0
3026: PPUSH
// begin if GetSide ( b ) = 8 then
3027: LD_VAR 0 1
3031: PPUSH
3032: CALL_OW 255
3036: PUSH
3037: LD_INT 8
3039: EQUAL
3040: IFFALSE 3080
// for i = 1 to 4 do
3042: LD_ADDR_VAR 0 2
3046: PUSH
3047: DOUBLE
3048: LD_INT 1
3050: DEC
3051: ST_TO_ADDR
3052: LD_INT 4
3054: PUSH
3055: FOR_TO
3056: IFFALSE 3078
// legion_blist := Delete ( legion_blist , 1 ) ;
3058: LD_ADDR_EXP 34
3062: PUSH
3063: LD_EXP 34
3067: PPUSH
3068: LD_INT 1
3070: PPUSH
3071: CALL_OW 3
3075: ST_TO_ADDR
3076: GO 3055
3078: POP
3079: POP
// if GetSide ( b ) = 3 then
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 255
3089: PUSH
3090: LD_INT 3
3092: EQUAL
3093: IFFALSE 3133
// for i = 1 to 4 do
3095: LD_ADDR_VAR 0 2
3099: PUSH
3100: DOUBLE
3101: LD_INT 1
3103: DEC
3104: ST_TO_ADDR
3105: LD_INT 4
3107: PUSH
3108: FOR_TO
3109: IFFALSE 3131
// ru_blist := Delete ( ru_blist , 1 ) ;
3111: LD_ADDR_EXP 26
3115: PUSH
3116: LD_EXP 26
3120: PPUSH
3121: LD_INT 1
3123: PPUSH
3124: CALL_OW 3
3128: ST_TO_ADDR
3129: GO 3108
3131: POP
3132: POP
// end ;
3133: PPOPN 2
3135: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3136: LD_VAR 0 1
3140: PPUSH
3141: CALL_OW 264
3145: PUSH
3146: LD_INT 51
3148: PUSH
3149: LD_INT 48
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: IN
3156: NOT
3157: IFFALSE 3205
// begin if GetSide ( veh ) = 3 then
3159: LD_VAR 0 1
3163: PPUSH
3164: CALL_OW 255
3168: PUSH
3169: LD_INT 3
3171: EQUAL
3172: IFFALSE 3205
// begin ComMoveXY ( veh , 149 , 8 ) ;
3174: LD_VAR 0 1
3178: PPUSH
3179: LD_INT 149
3181: PPUSH
3182: LD_INT 8
3184: PPUSH
3185: CALL_OW 111
// ru_force := ru_force ^ veh ;
3189: LD_ADDR_EXP 23
3193: PUSH
3194: LD_EXP 23
3198: PUSH
3199: LD_VAR 0 1
3203: ADD
3204: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3205: LD_VAR 0 1
3209: PPUSH
3210: CALL_OW 264
3214: PUSH
3215: LD_INT 32
3217: PUSH
3218: LD_INT 31
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: IN
3225: NOT
3226: IFFALSE 3259
// begin if GetSide ( veh ) = 8 then
3228: LD_VAR 0 1
3232: PPUSH
3233: CALL_OW 255
3237: PUSH
3238: LD_INT 8
3240: EQUAL
3241: IFFALSE 3259
// legion_force := legion_force ^ veh ;
3243: LD_ADDR_EXP 31
3247: PUSH
3248: LD_EXP 31
3252: PUSH
3253: LD_VAR 0 1
3257: ADD
3258: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3259: LD_VAR 0 1
3263: PPUSH
3264: CALL_OW 255
3268: PUSH
3269: LD_INT 7
3271: EQUAL
3272: PUSH
3273: LD_OWVAR 2
3277: PUSH
3278: LD_INT 7
3280: NONEQUAL
3281: AND
3282: IFFALSE 3300
// al_force := al_force ^ veh ;
3284: LD_ADDR_EXP 38
3288: PUSH
3289: LD_EXP 38
3293: PUSH
3294: LD_VAR 0 1
3298: ADD
3299: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3300: LD_VAR 0 1
3304: PPUSH
3305: CALL_OW 255
3309: PUSH
3310: LD_OWVAR 2
3314: EQUAL
3315: IFFALSE 3331
// veh_counter := veh_counter + 1 ;
3317: LD_ADDR_EXP 16
3321: PUSH
3322: LD_EXP 16
3326: PUSH
3327: LD_INT 1
3329: PLUS
3330: ST_TO_ADDR
// end ;
3331: PPOPN 2
3333: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3334: LD_VAR 0 1
3338: PPUSH
3339: CALL_OW 255
3343: PUSH
3344: LD_OWVAR 2
3348: NONEQUAL
3349: IFFALSE 3365
// sib_contamin_counter := sib_contamin_counter + 1 ;
3351: LD_ADDR_EXP 18
3355: PUSH
3356: LD_EXP 18
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: ST_TO_ADDR
// end ;
3365: PPOPN 3
3367: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 255
3377: PUSH
3378: LD_OWVAR 2
3382: EQUAL
3383: IFFALSE 3399
// tech_counter := tech_counter + 1 ;
3385: LD_ADDR_EXP 17
3389: PUSH
3390: LD_EXP 17
3394: PUSH
3395: LD_INT 1
3397: PLUS
3398: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3399: LD_VAR 0 1
3403: PUSH
3404: LD_INT 53
3406: EQUAL
3407: PUSH
3408: LD_OWVAR 2
3412: PUSH
3413: LD_INT 1
3415: EQUAL
3416: AND
3417: IFFALSE 3432
// SetTech ( 80 , 1 , state_researched ) ;
3419: LD_INT 80
3421: PPUSH
3422: LD_INT 1
3424: PPUSH
3425: LD_INT 2
3427: PPUSH
3428: CALL_OW 322
// end ;
3432: PPOPN 2
3434: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3435: LD_INT 25
3437: PUSH
3438: LD_INT 12
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: PUSH
3450: LD_INT 9
3452: LESS
3453: IFFALSE 3495
3455: GO 3457
3457: DISABLE
3458: LD_INT 0
3460: PPUSH
// begin enable ;
3461: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3462: LD_ADDR_VAR 0 1
3466: PUSH
3467: LD_INT 25
3469: PUSH
3470: LD_INT 12
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PPUSH
3477: CALL_OW 69
3481: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3482: LD_INT 8
3484: PUSH
3485: LD_VAR 0 1
3489: MINUS
3490: PPUSH
3491: CALL 1890 0 1
// end ;
3495: PPOPN 1
3497: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3498: LD_VAR 0 1
3502: PPUSH
3503: LD_VAR 0 2
3507: PPUSH
3508: LD_VAR 0 3
3512: PPUSH
3513: CALL 29813 0 3
// end ;
3517: PPOPN 3
3519: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3520: LD_VAR 0 1
3524: PPUSH
3525: CALL 29821 0 1
// end ; end_of_file
3529: PPOPN 1
3531: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3532: LD_INT 0
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
3538: PPUSH
3539: PPUSH
3540: PPUSH
3541: PPUSH
3542: PPUSH
3543: PPUSH
3544: PPUSH
// uc_side := 3 ;
3545: LD_ADDR_OWVAR 20
3549: PUSH
3550: LD_INT 3
3552: ST_TO_ADDR
// uc_nation := nation_russian ;
3553: LD_ADDR_OWVAR 21
3557: PUSH
3558: LD_INT 3
3560: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3561: LD_ADDR_VAR 0 4
3565: PUSH
3566: LD_INT 22
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 30
3578: PUSH
3579: LD_INT 1
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PPUSH
3590: CALL_OW 69
3594: PUSH
3595: LD_INT 1
3597: ARRAY
3598: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_INT 22
3606: PUSH
3607: LD_INT 3
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 30
3616: PUSH
3617: LD_INT 3
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 69
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3637: LD_ADDR_VAR 0 6
3641: PUSH
3642: LD_INT 22
3644: PUSH
3645: LD_INT 3
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: LD_INT 30
3654: PUSH
3655: LD_INT 34
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PPUSH
3666: CALL_OW 69
3670: PUSH
3671: LD_INT 1
3673: ARRAY
3674: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3675: LD_ADDR_VAR 0 8
3679: PUSH
3680: LD_INT 22
3682: PUSH
3683: LD_INT 3
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PUSH
3690: LD_INT 30
3692: PUSH
3693: LD_INT 33
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PPUSH
3704: CALL_OW 69
3708: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3709: LD_ADDR_VAR 0 7
3713: PUSH
3714: LD_INT 22
3716: PUSH
3717: LD_INT 3
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_INT 30
3726: PUSH
3727: LD_INT 5
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PPUSH
3738: CALL_OW 69
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: ST_TO_ADDR
// ru_blist := [ ] ;
3747: LD_ADDR_EXP 26
3751: PUSH
3752: EMPTY
3753: ST_TO_ADDR
// ru_vlist := [ ] ;
3754: LD_ADDR_EXP 27
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3761: LD_ADDR_EXP 30
3765: PUSH
3766: LD_INT 183
3768: PUSH
3769: LD_INT 62
3771: PUSH
3772: LD_INT 147
3774: PUSH
3775: LD_INT 44
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3784: LD_INT 30
3786: PUSH
3787: LD_INT 34
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 1
3810: ARRAY
3811: PPUSH
3812: LD_EXP 30
3816: PUSH
3817: LD_INT 2
3819: ARRAY
3820: PPUSH
3821: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3825: LD_ADDR_EXP 28
3829: PUSH
3830: LD_INT 4
3832: PUSH
3833: LD_INT 5
3835: PUSH
3836: LD_INT 6
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_OWVAR 67
3848: ARRAY
3849: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3850: LD_VAR 0 4
3854: PPUSH
3855: CALL_OW 274
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 3000
3865: PPUSH
3866: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3870: LD_VAR 0 4
3874: PPUSH
3875: CALL_OW 274
3879: PPUSH
3880: LD_INT 2
3882: PPUSH
3883: LD_INT 300
3885: PPUSH
3886: CALL_OW 277
// hc_gallery :=  ;
3890: LD_ADDR_OWVAR 33
3894: PUSH
3895: LD_STRING 
3897: ST_TO_ADDR
// hc_name :=  ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING 
3905: ST_TO_ADDR
// hc_importance := 0 ;
3906: LD_ADDR_OWVAR 32
3910: PUSH
3911: LD_INT 0
3913: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3914: LD_ADDR_EXP 24
3918: PUSH
3919: LD_INT 5
3921: PUSH
3922: LD_INT 6
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: LIST
3932: PUSH
3933: LD_OWVAR 67
3937: ARRAY
3938: ST_TO_ADDR
// for i = 1 to 6 do
3939: LD_ADDR_VAR 0 2
3943: PUSH
3944: DOUBLE
3945: LD_INT 1
3947: DEC
3948: ST_TO_ADDR
3949: LD_INT 6
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4111
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 9
3960: PPUSH
3961: LD_EXP 24
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 3
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3980: LD_VAR 0 3
3984: PPUSH
3985: LD_VAR 0 7
3989: PPUSH
3990: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3994: LD_INT 0
3996: PPUSH
3997: LD_INT 4
3999: PPUSH
4000: LD_EXP 24
4004: PPUSH
4005: CALL_OW 380
// un := CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4019: LD_VAR 0 3
4023: PPUSH
4024: LD_INT 24
4026: PPUSH
4027: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4031: LD_INT 0
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: LD_EXP 24
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4056: LD_VAR 0 3
4060: PPUSH
4061: LD_VAR 0 5
4065: PPUSH
4066: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4070: LD_INT 0
4072: PPUSH
4073: LD_INT 2
4075: PPUSH
4076: LD_EXP 24
4080: PPUSH
4081: CALL_OW 380
// un := CreateHuman ;
4085: LD_ADDR_VAR 0 3
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4095: LD_VAR 0 3
4099: PPUSH
4100: LD_VAR 0 4
4104: PPUSH
4105: CALL_OW 52
// end ;
4109: GO 3952
4111: POP
4112: POP
// russian_prepared := true ;
4113: LD_ADDR_EXP 2
4117: PUSH
4118: LD_INT 1
4120: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4121: LD_VAR 0 5
4125: PPUSH
4126: LD_INT 21
4128: PPUSH
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 3
4134: PPUSH
4135: LD_INT 51
4137: PPUSH
4138: CALL_OW 125
// end ;
4142: LD_VAR 0 1
4146: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4147: LD_INT 22
4149: PUSH
4150: LD_INT 3
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PPUSH
4157: CALL_OW 69
4161: PUSH
4162: LD_INT 0
4164: GREATER
4165: PUSH
4166: LD_EXP 2
4170: AND
4171: IFFALSE 6634
4173: GO 4175
4175: DISABLE
4176: LD_INT 0
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
4189: PPUSH
4190: PPUSH
4191: PPUSH
4192: PPUSH
4193: PPUSH
4194: PPUSH
// begin enable ;
4195: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4196: LD_ADDR_VAR 0 1
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: LD_INT 3
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: PUSH
4211: LD_INT 30
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PPUSH
4225: CALL_OW 69
4229: PUSH
4230: LD_INT 1
4232: ARRAY
4233: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4234: LD_ADDR_VAR 0 2
4238: PUSH
4239: LD_INT 22
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 3
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 69
4267: PUSH
4268: LD_INT 1
4270: ARRAY
4271: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4272: LD_ADDR_VAR 0 3
4276: PUSH
4277: LD_INT 22
4279: PUSH
4280: LD_INT 3
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 30
4289: PUSH
4290: LD_INT 34
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: PPUSH
4301: CALL_OW 69
4305: PUSH
4306: LD_INT 1
4308: ARRAY
4309: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4310: LD_ADDR_VAR 0 4
4314: PUSH
4315: LD_INT 22
4317: PUSH
4318: LD_INT 3
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 30
4327: PUSH
4328: LD_INT 33
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4344: LD_ADDR_VAR 0 8
4348: PUSH
4349: LD_INT 22
4351: PUSH
4352: LD_INT 3
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 30
4361: PUSH
4362: LD_INT 5
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PPUSH
4373: CALL_OW 69
4377: PUSH
4378: LD_INT 1
4380: ARRAY
4381: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4382: LD_ADDR_VAR 0 5
4386: PUSH
4387: LD_INT 22
4389: PUSH
4390: LD_INT 3
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 21
4399: PUSH
4400: LD_INT 3
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PPUSH
4411: CALL_OW 69
4415: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 6
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4450: LD_ADDR_VAR 0 7
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 21
4467: PUSH
4468: LD_INT 1
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 69
4483: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4484: LD_ADDR_VAR 0 9
4488: PUSH
4489: LD_VAR 0 7
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 2
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4509: LD_ADDR_VAR 0 10
4513: PUSH
4514: LD_VAR 0 7
4518: PPUSH
4519: LD_INT 25
4521: PUSH
4522: LD_INT 3
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PPUSH
4529: CALL_OW 72
4533: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4534: LD_ADDR_VAR 0 11
4538: PUSH
4539: LD_VAR 0 7
4543: PPUSH
4544: LD_INT 25
4546: PUSH
4547: LD_INT 4
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 72
4558: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4559: LD_INT 22
4561: PUSH
4562: LD_INT 3
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 34
4571: PUSH
4572: LD_INT 51
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PPUSH
4583: CALL_OW 69
4587: PUSH
4588: LD_INT 0
4590: GREATER
4591: PUSH
4592: LD_EXP 25
4596: PUSH
4597: LD_INT 0
4599: EQUAL
4600: AND
4601: IFFALSE 4641
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4603: LD_ADDR_EXP 25
4607: PUSH
4608: LD_INT 22
4610: PUSH
4611: LD_INT 3
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: PUSH
4618: LD_INT 34
4620: PUSH
4621: LD_INT 51
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PPUSH
4632: CALL_OW 69
4636: PUSH
4637: LD_INT 1
4639: ARRAY
4640: ST_TO_ADDR
// if ru_cargo then
4641: LD_EXP 25
4645: IFFALSE 4943
// begin if IsInArea ( ru_cargo , ru_base ) then
4647: LD_EXP 25
4651: PPUSH
4652: LD_INT 9
4654: PPUSH
4655: CALL_OW 308
4659: IFFALSE 4738
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4661: LD_EXP 25
4665: PPUSH
4666: LD_INT 1
4668: PPUSH
4669: CALL_OW 289
4673: PUSH
4674: LD_INT 0
4676: EQUAL
4677: IFFALSE 4695
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4679: LD_EXP 25
4683: PPUSH
4684: LD_VAR 0 3
4688: PPUSH
4689: CALL_OW 120
4693: GO 4736
// if not HasTask ( ru_cargo ) then
4695: LD_EXP 25
4699: PPUSH
4700: CALL_OW 314
4704: NOT
4705: IFFALSE 4736
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4707: LD_EXP 25
4711: PPUSH
4712: LD_VAR 0 1
4716: PPUSH
4717: CALL_OW 250
4721: PPUSH
4722: LD_VAR 0 1
4726: PPUSH
4727: CALL_OW 251
4731: PPUSH
4732: CALL_OW 111
// end else
4736: GO 4943
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4738: LD_EXP 25
4742: PPUSH
4743: CALL_OW 314
4747: NOT
4748: PUSH
4749: LD_EXP 25
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: CALL_OW 289
4761: PUSH
4762: LD_INT 100
4764: LESS
4765: AND
4766: IFFALSE 4832
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4768: LD_ADDR_VAR 0 16
4772: PUSH
4773: LD_INT 11
4775: PPUSH
4776: CALL_OW 435
4780: ST_TO_ADDR
// if cr > 0 then
4781: LD_VAR 0 16
4785: PUSH
4786: LD_INT 0
4788: GREATER
4789: IFFALSE 4820
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4791: LD_EXP 25
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_VAR 0 16
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: CALL_OW 117
4818: GO 4832
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4820: LD_EXP 25
4824: PPUSH
4825: LD_INT 11
4827: PPUSH
4828: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4832: LD_EXP 25
4836: PPUSH
4837: CALL_OW 314
4841: NOT
4842: PUSH
4843: LD_EXP 25
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL_OW 308
4855: NOT
4856: AND
4857: PUSH
4858: LD_EXP 25
4862: PPUSH
4863: LD_INT 1
4865: PPUSH
4866: CALL_OW 289
4870: PUSH
4871: LD_INT 100
4873: EQUAL
4874: AND
4875: IFFALSE 4889
// ComMoveToArea ( ru_cargo , cargoa ) ;
4877: LD_EXP 25
4881: PPUSH
4882: LD_INT 10
4884: PPUSH
4885: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4889: LD_EXP 25
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 308
4901: PUSH
4902: LD_VAR 0 8
4906: AND
4907: IFFALSE 4943
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4909: LD_VAR 0 7
4913: PPUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 9
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 72
4928: PUSH
4929: LD_INT 1
4931: ARRAY
4932: PPUSH
4933: LD_INT 139
4935: PPUSH
4936: LD_INT 24
4938: PPUSH
4939: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4943: LD_EXP 25
4947: PUSH
4948: LD_INT 0
4950: EQUAL
4951: PUSH
4952: LD_VAR 0 2
4956: AND
4957: PUSH
4958: LD_VAR 0 2
4962: PPUSH
4963: CALL_OW 461
4967: PUSH
4968: LD_INT 2
4970: EQUAL
4971: AND
4972: IFFALSE 4995
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4974: LD_VAR 0 2
4978: PPUSH
4979: LD_INT 21
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: LD_INT 3
4987: PPUSH
4988: LD_INT 51
4990: PPUSH
4991: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4995: LD_VAR 0 7
4999: PPUSH
5000: LD_INT 25
5002: PUSH
5003: LD_INT 9
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PPUSH
5010: CALL_OW 72
5014: IFFALSE 5078
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5016: LD_VAR 0 7
5020: PPUSH
5021: LD_INT 25
5023: PUSH
5024: LD_INT 9
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PPUSH
5031: CALL_OW 72
5035: PPUSH
5036: LD_INT 22
5038: PUSH
5039: LD_OWVAR 2
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 3
5050: PUSH
5051: LD_INT 21
5053: PUSH
5054: LD_INT 3
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PPUSH
5069: CALL_OW 69
5073: PPUSH
5074: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5078: LD_VAR 0 2
5082: PUSH
5083: LD_EXP 27
5087: PUSH
5088: LD_INT 0
5090: GREATER
5091: AND
5092: IFFALSE 5192
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5094: LD_VAR 0 2
5098: PPUSH
5099: CALL_OW 461
5103: PUSH
5104: LD_INT 2
5106: EQUAL
5107: IFFALSE 5192
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5109: LD_VAR 0 2
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 1
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 2
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 3
5139: ARRAY
5140: PPUSH
5141: LD_EXP 27
5145: PUSH
5146: LD_INT 4
5148: ARRAY
5149: PPUSH
5150: CALL_OW 125
// for i = 1 to 4 do
5154: LD_ADDR_VAR 0 12
5158: PUSH
5159: DOUBLE
5160: LD_INT 1
5162: DEC
5163: ST_TO_ADDR
5164: LD_INT 4
5166: PUSH
5167: FOR_TO
5168: IFFALSE 5190
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5170: LD_ADDR_EXP 27
5174: PUSH
5175: LD_EXP 27
5179: PPUSH
5180: LD_INT 1
5182: PPUSH
5183: CALL_OW 3
5187: ST_TO_ADDR
5188: GO 5167
5190: POP
5191: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5192: LD_INT 24
5194: PPUSH
5195: CALL_OW 461
5199: PUSH
5200: LD_INT 2
5202: EQUAL
5203: PUSH
5204: LD_EXP 4
5208: AND
5209: IFFALSE 5237
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5211: LD_INT 25
5213: PPUSH
5214: LD_INT 3
5216: PPUSH
5217: CALL_OW 321
5221: PUSH
5222: LD_INT 1
5224: EQUAL
5225: IFFALSE 5237
// ComResearch ( ru_lab , tech_sibfiss ) ;
5227: LD_INT 24
5229: PPUSH
5230: LD_INT 25
5232: PPUSH
5233: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5237: LD_INT 25
5239: PPUSH
5240: LD_INT 3
5242: PPUSH
5243: CALL_OW 321
5247: PUSH
5248: LD_INT 2
5250: EQUAL
5251: PUSH
5252: LD_OWVAR 1
5256: PUSH
5257: LD_INT 10500
5259: MOD
5260: PUSH
5261: LD_INT 0
5263: EQUAL
5264: AND
5265: IFFALSE 5303
// if BuildingStatus ( ru_factory ) = bs_idle then
5267: LD_VAR 0 2
5271: PPUSH
5272: CALL_OW 461
5276: PUSH
5277: LD_INT 2
5279: EQUAL
5280: IFFALSE 5303
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5282: LD_VAR 0 2
5286: PPUSH
5287: LD_INT 23
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: LD_INT 3
5295: PPUSH
5296: LD_INT 48
5298: PPUSH
5299: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5303: LD_INT 22
5305: PUSH
5306: LD_INT 3
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: PUSH
5313: LD_INT 34
5315: PUSH
5316: LD_INT 48
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: PUSH
5332: LD_INT 0
5334: GREATER
5335: IFFALSE 5709
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5337: LD_ADDR_VAR 0 17
5341: PUSH
5342: LD_INT 22
5344: PUSH
5345: LD_INT 3
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: PUSH
5352: LD_INT 34
5354: PUSH
5355: LD_INT 48
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PPUSH
5366: CALL_OW 69
5370: PUSH
5371: LD_INT 1
5373: ARRAY
5374: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5375: LD_VAR 0 17
5379: PPUSH
5380: LD_INT 9
5382: PPUSH
5383: CALL_OW 308
5387: IFFALSE 5405
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5389: LD_VAR 0 17
5393: PPUSH
5394: LD_VAR 0 3
5398: PPUSH
5399: CALL_OW 120
5403: GO 5709
// if not HasTask ( sib_bomb ) then
5405: LD_VAR 0 17
5409: PPUSH
5410: CALL_OW 314
5414: NOT
5415: IFFALSE 5709
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5417: LD_INT 22
5419: PUSH
5420: LD_OWVAR 2
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 1
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 256
5456: PUSH
5457: LD_INT 250
5459: GREATER
5460: IFFALSE 5553
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5462: LD_VAR 0 17
5466: PPUSH
5467: LD_INT 22
5469: PUSH
5470: LD_OWVAR 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PPUSH
5493: CALL_OW 69
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: CALL_OW 250
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_OWVAR 2
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 30
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PPUSH
5533: CALL_OW 69
5537: PUSH
5538: LD_INT 1
5540: ARRAY
5541: PPUSH
5542: CALL_OW 251
5546: PPUSH
5547: CALL_OW 116
5551: GO 5709
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5553: LD_INT 22
5555: PUSH
5556: LD_OWVAR 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 21
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL_OW 69
5583: PUSH
5584: LD_INT 0
5586: GREATER
5587: IFFALSE 5680
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5589: LD_VAR 0 17
5593: PPUSH
5594: LD_INT 22
5596: PUSH
5597: LD_OWVAR 2
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 21
5608: PUSH
5609: LD_INT 3
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: PUSH
5625: LD_INT 1
5627: ARRAY
5628: PPUSH
5629: CALL_OW 250
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_OWVAR 2
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 21
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PPUSH
5660: CALL_OW 69
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 251
5673: PPUSH
5674: CALL_OW 116
5678: GO 5709
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5680: LD_VAR 0 17
5684: PPUSH
5685: LD_EXP 10
5689: PPUSH
5690: CALL_OW 250
5694: PPUSH
5695: LD_EXP 10
5699: PPUSH
5700: CALL_OW 251
5704: PPUSH
5705: CALL_OW 116
// end ; if ru_can_attack then
5709: LD_EXP 3
5713: IFFALSE 5861
// if ru_time > 0 0$00 then
5715: LD_EXP 29
5719: PUSH
5720: LD_INT 0
5722: GREATER
5723: IFFALSE 5741
// ru_time := ru_time - 0 0$01 else
5725: LD_ADDR_EXP 29
5729: PUSH
5730: LD_EXP 29
5734: PUSH
5735: LD_INT 35
5737: MINUS
5738: ST_TO_ADDR
5739: GO 5861
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5741: LD_ADDR_EXP 29
5745: PUSH
5746: LD_INT 20265
5748: PPUSH
5749: LD_INT 30765
5751: PPUSH
5752: CALL_OW 12
5756: ST_TO_ADDR
// for i = 1 to ru_amount do
5757: LD_ADDR_VAR 0 12
5761: PUSH
5762: DOUBLE
5763: LD_INT 1
5765: DEC
5766: ST_TO_ADDR
5767: LD_EXP 28
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5859
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5775: LD_ADDR_EXP 27
5779: PUSH
5780: LD_EXP 27
5784: PUSH
5785: LD_INT 23
5787: ADD
5788: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5789: LD_ADDR_EXP 27
5793: PUSH
5794: LD_EXP 27
5798: PUSH
5799: LD_INT 3
5801: ADD
5802: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5803: LD_ADDR_EXP 27
5807: PUSH
5808: LD_EXP 27
5812: PUSH
5813: LD_INT 3
5815: ADD
5816: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5817: LD_ADDR_EXP 27
5821: PUSH
5822: LD_EXP 27
5826: PUSH
5827: LD_INT 46
5829: PUSH
5830: LD_INT 45
5832: PUSH
5833: LD_INT 47
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_INT 1
5843: PPUSH
5844: LD_INT 2
5846: PPUSH
5847: LD_INT 3
5849: PPUSH
5850: CALL_OW 14
5854: ARRAY
5855: ADD
5856: ST_TO_ADDR
// end ;
5857: GO 5772
5859: POP
5860: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5861: LD_VAR 0 4
5865: PPUSH
5866: LD_INT 35
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 72
5880: PUSH
5881: LD_INT 0
5883: GREATER
5884: IFFALSE 5932
// if BuildingStatus ( ru_factory ) = bs_idle then
5886: LD_VAR 0 2
5890: PPUSH
5891: CALL_OW 461
5895: PUSH
5896: LD_INT 2
5898: EQUAL
5899: IFFALSE 5932
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5901: LD_VAR 0 4
5905: PPUSH
5906: LD_INT 35
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PPUSH
5916: CALL_OW 72
5920: PUSH
5921: LD_INT 1
5923: ARRAY
5924: PPUSH
5925: LD_INT 47
5927: PPUSH
5928: CALL_OW 148
// if ru_force = ru_amount then
5932: LD_EXP 23
5936: PUSH
5937: LD_EXP 28
5941: EQUAL
5942: IFFALSE 6074
// begin for i = 1 to ru_force do
5944: LD_ADDR_VAR 0 12
5948: PUSH
5949: DOUBLE
5950: LD_INT 1
5952: DEC
5953: ST_TO_ADDR
5954: LD_EXP 23
5958: PUSH
5959: FOR_TO
5960: IFFALSE 6070
// if IsInArea ( ru_force [ i ] , ru_base ) then
5962: LD_EXP 23
5966: PUSH
5967: LD_VAR 0 12
5971: ARRAY
5972: PPUSH
5973: LD_INT 9
5975: PPUSH
5976: CALL_OW 308
5980: IFFALSE 6004
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5982: LD_EXP 23
5986: PUSH
5987: LD_VAR 0 12
5991: ARRAY
5992: PPUSH
5993: LD_VAR 0 3
5997: PPUSH
5998: CALL_OW 120
6002: GO 6068
// if not HasTask ( ru_force [ i ] ) then
6004: LD_EXP 23
6008: PUSH
6009: LD_VAR 0 12
6013: ARRAY
6014: PPUSH
6015: CALL_OW 314
6019: NOT
6020: IFFALSE 6068
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6022: LD_EXP 23
6026: PUSH
6027: LD_VAR 0 12
6031: ARRAY
6032: PPUSH
6033: LD_INT 81
6035: PUSH
6036: LD_INT 3
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 69
6047: PPUSH
6048: LD_EXP 23
6052: PUSH
6053: LD_VAR 0 12
6057: ARRAY
6058: PPUSH
6059: CALL_OW 74
6063: PPUSH
6064: CALL_OW 115
6068: GO 5959
6070: POP
6071: POP
// end else
6072: GO 6224
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6074: LD_EXP 23
6078: PPUSH
6079: LD_INT 3
6081: PUSH
6082: LD_INT 95
6084: PUSH
6085: LD_INT 18
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PPUSH
6096: CALL_OW 72
6100: PUSH
6101: LD_INT 0
6103: GREATER
6104: IFFALSE 6224
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6106: LD_ADDR_VAR 0 13
6110: PUSH
6111: LD_EXP 23
6115: PPUSH
6116: LD_INT 3
6118: PUSH
6119: LD_INT 95
6121: PUSH
6122: LD_INT 18
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: PPUSH
6133: CALL_OW 72
6137: ST_TO_ADDR
// for i = 1 to tmp do
6138: LD_ADDR_VAR 0 12
6142: PUSH
6143: DOUBLE
6144: LD_INT 1
6146: DEC
6147: ST_TO_ADDR
6148: LD_VAR 0 13
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6222
// if not HasTask ( tmp [ i ] ) then
6156: LD_VAR 0 13
6160: PUSH
6161: LD_VAR 0 12
6165: ARRAY
6166: PPUSH
6167: CALL_OW 314
6171: NOT
6172: IFFALSE 6220
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6174: LD_EXP 23
6178: PUSH
6179: LD_VAR 0 12
6183: ARRAY
6184: PPUSH
6185: LD_INT 81
6187: PUSH
6188: LD_INT 3
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 69
6199: PPUSH
6200: LD_EXP 23
6204: PUSH
6205: LD_VAR 0 12
6209: ARRAY
6210: PPUSH
6211: CALL_OW 74
6215: PPUSH
6216: CALL_OW 115
6220: GO 6153
6222: POP
6223: POP
// end ; if ru_engs > 0 then
6224: LD_VAR 0 9
6228: PUSH
6229: LD_INT 0
6231: GREATER
6232: IFFALSE 6634
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6234: LD_VAR 0 5
6238: PPUSH
6239: LD_INT 3
6241: PUSH
6242: LD_INT 24
6244: PUSH
6245: LD_INT 1000
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: LD_INT 0
6263: GREATER
6264: IFFALSE 6419
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6266: LD_ADDR_VAR 0 14
6270: PUSH
6271: LD_VAR 0 5
6275: PPUSH
6276: LD_INT 3
6278: PUSH
6279: LD_INT 24
6281: PUSH
6282: LD_INT 1000
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: CALL_OW 72
6297: ST_TO_ADDR
// for i = 1 to ru_engs do
6298: LD_ADDR_VAR 0 12
6302: PUSH
6303: DOUBLE
6304: LD_INT 1
6306: DEC
6307: ST_TO_ADDR
6308: LD_VAR 0 9
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6415
// begin if IsInUnit ( ru_engs [ i ] ) then
6316: LD_VAR 0 9
6320: PUSH
6321: LD_VAR 0 12
6325: ARRAY
6326: PPUSH
6327: CALL_OW 310
6331: IFFALSE 6350
// ComExitBuilding ( ru_engs [ i ] ) else
6333: LD_VAR 0 9
6337: PUSH
6338: LD_VAR 0 12
6342: ARRAY
6343: PPUSH
6344: CALL_OW 122
6348: GO 6413
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 256
6382: PUSH
6383: LD_INT 600
6385: GREATER
6386: AND
6387: IFFALSE 6413
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6389: LD_VAR 0 9
6393: PUSH
6394: LD_VAR 0 12
6398: ARRAY
6399: PPUSH
6400: LD_VAR 0 14
6404: PUSH
6405: LD_INT 1
6407: ARRAY
6408: PPUSH
6409: CALL_OW 130
// end ;
6413: GO 6313
6415: POP
6416: POP
// end else
6417: GO 6634
// begin if ru_blist = 0 then
6419: LD_EXP 26
6423: PUSH
6424: LD_INT 0
6426: EQUAL
6427: IFFALSE 6509
// begin for i = 1 to ru_engs do
6429: LD_ADDR_VAR 0 12
6433: PUSH
6434: DOUBLE
6435: LD_INT 1
6437: DEC
6438: ST_TO_ADDR
6439: LD_VAR 0 9
6443: PUSH
6444: FOR_TO
6445: IFFALSE 6505
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 314
6462: NOT
6463: PUSH
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 310
6479: NOT
6480: AND
6481: IFFALSE 6503
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6483: LD_VAR 0 9
6487: PUSH
6488: LD_VAR 0 12
6492: ARRAY
6493: PPUSH
6494: LD_VAR 0 1
6498: PPUSH
6499: CALL_OW 120
6503: GO 6444
6505: POP
6506: POP
// end else
6507: GO 6634
// begin for i = 1 to ru_engs do
6509: LD_ADDR_VAR 0 12
6513: PUSH
6514: DOUBLE
6515: LD_INT 1
6517: DEC
6518: ST_TO_ADDR
6519: LD_VAR 0 9
6523: PUSH
6524: FOR_TO
6525: IFFALSE 6632
// begin if IsInUnit ( ru_engs [ i ] ) then
6527: LD_VAR 0 9
6531: PUSH
6532: LD_VAR 0 12
6536: ARRAY
6537: PPUSH
6538: CALL_OW 310
6542: IFFALSE 6561
// ComExitBuilding ( ru_engs [ i ] ) else
6544: LD_VAR 0 9
6548: PUSH
6549: LD_VAR 0 12
6553: ARRAY
6554: PPUSH
6555: CALL_OW 122
6559: GO 6630
// if not HasTask ( ru_engs [ i ] ) then
6561: LD_VAR 0 9
6565: PUSH
6566: LD_VAR 0 12
6570: ARRAY
6571: PPUSH
6572: CALL_OW 314
6576: NOT
6577: IFFALSE 6630
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6579: LD_VAR 0 9
6583: PUSH
6584: LD_VAR 0 12
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 1
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 2
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PPUSH
6617: LD_EXP 26
6621: PUSH
6622: LD_INT 4
6624: ARRAY
6625: PPUSH
6626: CALL_OW 145
// end ;
6630: GO 6524
6632: POP
6633: POP
// end ; end ; end ; end ;
6634: PPOPN 17
6636: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6637: LD_EXP 2
6641: PUSH
6642: LD_INT 11
6644: PPUSH
6645: CALL_OW 435
6649: PUSH
6650: LD_INT 20
6652: LESS
6653: AND
6654: IFFALSE 6717
6656: GO 6658
6658: DISABLE
// begin enable ;
6659: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6660: LD_INT 1
6662: PPUSH
6663: LD_INT 5
6665: PPUSH
6666: CALL_OW 12
6670: PPUSH
6671: LD_INT 11
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6681: LD_INT 1505
6683: PPUSH
6684: LD_INT 2100
6686: PPUSH
6687: CALL_OW 12
6691: PPUSH
6692: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6696: LD_INT 1
6698: PPUSH
6699: LD_INT 5
6701: PPUSH
6702: CALL_OW 12
6706: PPUSH
6707: LD_INT 11
6709: PPUSH
6710: LD_INT 1
6712: PPUSH
6713: CALL_OW 55
// end ;
6717: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6718: LD_EXP 4
6722: PUSH
6723: LD_INT 0
6725: EQUAL
6726: IFFALSE 6841
6728: GO 6730
6730: DISABLE
6731: LD_INT 0
6733: PPUSH
6734: PPUSH
// begin enable ;
6735: ENABLE
// i := Rand ( 0 , 100 ) ;
6736: LD_ADDR_VAR 0 1
6740: PUSH
6741: LD_INT 0
6743: PPUSH
6744: LD_INT 100
6746: PPUSH
6747: CALL_OW 12
6751: ST_TO_ADDR
// case your_side of 1 :
6752: LD_OWVAR 2
6756: PUSH
6757: LD_INT 1
6759: DOUBLE
6760: EQUAL
6761: IFTRUE 6765
6763: GO 6776
6765: POP
// tmp := 10 ; 2 :
6766: LD_ADDR_VAR 0 2
6770: PUSH
6771: LD_INT 10
6773: ST_TO_ADDR
6774: GO 6815
6776: LD_INT 2
6778: DOUBLE
6779: EQUAL
6780: IFTRUE 6784
6782: GO 6795
6784: POP
// tmp := 0 ; 7 :
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_INT 0
6792: ST_TO_ADDR
6793: GO 6815
6795: LD_INT 7
6797: DOUBLE
6798: EQUAL
6799: IFTRUE 6803
6801: GO 6814
6803: POP
// tmp := 15 ; end ;
6804: LD_ADDR_VAR 0 2
6808: PUSH
6809: LD_INT 15
6811: ST_TO_ADDR
6812: GO 6815
6814: POP
// if i < chance_to_bomb + tmp then
6815: LD_VAR 0 1
6819: PUSH
6820: LD_EXP 5
6824: PUSH
6825: LD_VAR 0 2
6829: PLUS
6830: LESS
6831: IFFALSE 6841
// ru_sib_bomb := true ;
6833: LD_ADDR_EXP 4
6837: PUSH
6838: LD_INT 1
6840: ST_TO_ADDR
// end ;
6841: PPOPN 2
6843: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6844: LD_INT 22
6846: PUSH
6847: LD_OWVAR 2
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 34
6858: PUSH
6859: LD_INT 8
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: PPUSH
6870: CALL_OW 69
6874: IFFALSE 6887
6876: GO 6878
6878: DISABLE
// begin ru_sib_bomb := true ;
6879: LD_ADDR_EXP 4
6883: PUSH
6884: LD_INT 1
6886: ST_TO_ADDR
// end ;
6887: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6888: LD_INT 22
6890: PUSH
6891: LD_INT 3
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 34
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PPUSH
6912: CALL_OW 69
6916: IFFALSE 7015
6918: GO 6920
6920: DISABLE
6921: LD_INT 0
6923: PPUSH
// begin enable ;
6924: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6925: LD_ADDR_VAR 0 1
6929: PUSH
6930: LD_INT 1
6932: PUSH
6933: LD_INT 3
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_INT 2
6945: PPUSH
6946: CALL_OW 12
6950: ARRAY
6951: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6952: LD_INT 22
6954: PUSH
6955: LD_INT 3
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: PUSH
6962: LD_INT 30
6964: PUSH
6965: LD_INT 34
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: PUSH
6981: LD_INT 1
6983: ARRAY
6984: PPUSH
6985: LD_EXP 30
6989: PUSH
6990: LD_VAR 0 1
6994: ARRAY
6995: PPUSH
6996: LD_EXP 30
7000: PUSH
7001: LD_VAR 0 1
7005: PUSH
7006: LD_INT 1
7008: PLUS
7009: ARRAY
7010: PPUSH
7011: CALL_OW 243
// end ; end_of_file
7015: PPOPN 1
7017: END
// export function RemoveLegion ; var i ; begin
7018: LD_INT 0
7020: PPUSH
7021: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_INT 22
7029: PUSH
7030: LD_INT 8
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: PUSH
7042: FOR_IN
7043: IFFALSE 7056
// RemoveUnit ( i ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: CALL_OW 64
7054: GO 7042
7056: POP
7057: POP
// end ;
7058: LD_VAR 0 1
7062: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7063: LD_INT 0
7065: PPUSH
7066: PPUSH
7067: PPUSH
7068: PPUSH
7069: PPUSH
7070: PPUSH
7071: PPUSH
7072: PPUSH
7073: PPUSH
7074: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7075: LD_ADDR_VAR 0 7
7079: PUSH
7080: LD_INT 22
7082: PUSH
7083: LD_INT 8
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: PUSH
7109: LD_INT 1
7111: ARRAY
7112: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7113: LD_ADDR_VAR 0 8
7117: PUSH
7118: LD_INT 22
7120: PUSH
7121: LD_INT 8
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 30
7130: PUSH
7131: LD_INT 3
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PPUSH
7142: CALL_OW 69
7146: PUSH
7147: LD_INT 1
7149: ARRAY
7150: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7151: LD_ADDR_VAR 0 9
7155: PUSH
7156: LD_INT 22
7158: PUSH
7159: LD_INT 8
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 2
7168: PUSH
7169: LD_INT 30
7171: PUSH
7172: LD_INT 6
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 30
7181: PUSH
7182: LD_INT 8
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 1
7205: ARRAY
7206: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7207: LD_ADDR_VAR 0 10
7211: PUSH
7212: LD_INT 22
7214: PUSH
7215: LD_INT 8
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 30
7224: PUSH
7225: LD_INT 32
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: PPUSH
7236: CALL_OW 69
7240: ST_TO_ADDR
// uc_side := 8 ;
7241: LD_ADDR_OWVAR 20
7245: PUSH
7246: LD_INT 8
7248: ST_TO_ADDR
// uc_nation := nation_arabian ;
7249: LD_ADDR_OWVAR 21
7253: PUSH
7254: LD_INT 2
7256: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7257: LD_ADDR_EXP 32
7261: PUSH
7262: LD_INT 5
7264: PUSH
7265: LD_INT 6
7267: PUSH
7268: LD_INT 7
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: PUSH
7276: LD_OWVAR 67
7280: ARRAY
7281: ST_TO_ADDR
// legion_blist := [ ] ;
7282: LD_ADDR_EXP 34
7286: PUSH
7287: EMPTY
7288: ST_TO_ADDR
// legion_vlist := [ ] ;
7289: LD_ADDR_EXP 35
7293: PUSH
7294: EMPTY
7295: ST_TO_ADDR
// legion_force := [ ] ;
7296: LD_ADDR_EXP 31
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// legion_enemy := - 1 ;
7303: LD_ADDR_EXP 36
7307: PUSH
7308: LD_INT 1
7310: NEG
7311: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7312: LD_VAR 0 7
7316: PPUSH
7317: CALL_OW 274
7321: PPUSH
7322: LD_INT 1
7324: PPUSH
7325: LD_INT 10000
7327: PPUSH
7328: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7332: LD_VAR 0 7
7336: PPUSH
7337: CALL_OW 274
7341: PPUSH
7342: LD_INT 3
7344: PPUSH
7345: LD_INT 1000
7347: PPUSH
7348: CALL_OW 277
// for i = 1 to l_towers do
7352: LD_ADDR_VAR 0 3
7356: PUSH
7357: DOUBLE
7358: LD_INT 1
7360: DEC
7361: ST_TO_ADDR
7362: LD_VAR 0 10
7366: PUSH
7367: FOR_TO
7368: IFFALSE 7417
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7370: LD_INT 0
7372: PPUSH
7373: LD_INT 1
7375: PPUSH
7376: LD_EXP 32
7380: PPUSH
7381: CALL_OW 380
// un := CreateHuman ;
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: CALL_OW 44
7394: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_VAR 0 10
7404: PUSH
7405: LD_VAR 0 3
7409: ARRAY
7410: PPUSH
7411: CALL_OW 52
// end ;
7415: GO 7367
7417: POP
7418: POP
// for i = 1 to 4 do
7419: LD_ADDR_VAR 0 3
7423: PUSH
7424: DOUBLE
7425: LD_INT 1
7427: DEC
7428: ST_TO_ADDR
7429: LD_INT 4
7431: PUSH
7432: FOR_TO
7433: IFFALSE 7526
// for p = 1 to 2 do
7435: LD_ADDR_VAR 0 6
7439: PUSH
7440: DOUBLE
7441: LD_INT 1
7443: DEC
7444: ST_TO_ADDR
7445: LD_INT 2
7447: PUSH
7448: FOR_TO
7449: IFFALSE 7522
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7451: LD_INT 0
7453: PPUSH
7454: LD_INT 8
7456: PPUSH
7457: LD_EXP 32
7461: PPUSH
7462: CALL_OW 380
// un := CreateHuman ;
7466: LD_ADDR_VAR 0 2
7470: PUSH
7471: CALL_OW 44
7475: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_INT 22
7483: PUSH
7484: LD_INT 8
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 5
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: PUSH
7510: LD_VAR 0 6
7514: ARRAY
7515: PPUSH
7516: CALL_OW 52
// end ;
7520: GO 7448
7522: POP
7523: POP
7524: GO 7432
7526: POP
7527: POP
// for i = 1 to 4 do
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: DOUBLE
7534: LD_INT 1
7536: DEC
7537: ST_TO_ADDR
7538: LD_INT 4
7540: PUSH
7541: FOR_TO
7542: IFFALSE 7585
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7544: LD_INT 0
7546: PPUSH
7547: LD_INT 4
7549: PPUSH
7550: LD_EXP 32
7554: PPUSH
7555: CALL_OW 380
// un := CreateHuman ;
7559: LD_ADDR_VAR 0 2
7563: PUSH
7564: CALL_OW 44
7568: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7569: LD_VAR 0 2
7573: PPUSH
7574: LD_VAR 0 9
7578: PPUSH
7579: CALL_OW 52
// end ;
7583: GO 7541
7585: POP
7586: POP
// for i = 1 to 6 do
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: DOUBLE
7593: LD_INT 1
7595: DEC
7596: ST_TO_ADDR
7597: LD_INT 6
7599: PUSH
7600: FOR_TO
7601: IFFALSE 7644
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7603: LD_INT 0
7605: PPUSH
7606: LD_INT 3
7608: PPUSH
7609: LD_EXP 32
7613: PPUSH
7614: CALL_OW 380
// un := CreateHuman ;
7618: LD_ADDR_VAR 0 2
7622: PUSH
7623: CALL_OW 44
7627: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7628: LD_VAR 0 2
7632: PPUSH
7633: LD_VAR 0 8
7637: PPUSH
7638: CALL_OW 52
// end ;
7642: GO 7600
7644: POP
7645: POP
// for i = 1 to 5 do
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_INT 5
7658: PUSH
7659: FOR_TO
7660: IFFALSE 7703
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7662: LD_INT 0
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: LD_EXP 32
7672: PPUSH
7673: CALL_OW 380
// un := CreateHuman ;
7677: LD_ADDR_VAR 0 2
7681: PUSH
7682: CALL_OW 44
7686: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_VAR 0 7
7696: PPUSH
7697: CALL_OW 52
// end ;
7701: GO 7659
7703: POP
7704: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7705: LD_ADDR_VAR 0 4
7709: PUSH
7710: LD_INT 199
7712: PPUSH
7713: LD_INT 134
7715: PPUSH
7716: LD_INT 216
7718: PPUSH
7719: LD_INT 141
7721: PPUSH
7722: LD_INT 6
7724: PPUSH
7725: CALL 1562 0 5
7729: ST_TO_ADDR
// p := 1 ;
7730: LD_ADDR_VAR 0 6
7734: PUSH
7735: LD_INT 1
7737: ST_TO_ADDR
// for i = 1 to 3 do
7738: LD_ADDR_VAR 0 3
7742: PUSH
7743: DOUBLE
7744: LD_INT 1
7746: DEC
7747: ST_TO_ADDR
7748: LD_INT 3
7750: PUSH
7751: FOR_TO
7752: IFFALSE 8005
// begin vc_chassis := ar_half_tracked ;
7754: LD_ADDR_OWVAR 37
7758: PUSH
7759: LD_INT 14
7761: ST_TO_ADDR
// vc_engine := engine_siberite ;
7762: LD_ADDR_OWVAR 39
7766: PUSH
7767: LD_INT 3
7769: ST_TO_ADDR
// vc_control := control_manual ;
7770: LD_ADDR_OWVAR 38
7774: PUSH
7775: LD_INT 1
7777: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7778: LD_ADDR_OWVAR 40
7782: PUSH
7783: LD_INT 31
7785: ST_TO_ADDR
// veh := CreateVehicle ;
7786: LD_ADDR_VAR 0 5
7790: PUSH
7791: CALL_OW 45
7795: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7796: LD_VAR 0 4
7800: PUSH
7801: LD_VAR 0 6
7805: ARRAY
7806: PPUSH
7807: LD_VAR 0 4
7811: PUSH
7812: LD_VAR 0 6
7816: PUSH
7817: LD_INT 1
7819: PLUS
7820: ARRAY
7821: PPUSH
7822: CALL_OW 428
7826: PUSH
7827: LD_INT 0
7829: EQUAL
7830: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7832: LD_VAR 0 5
7836: PPUSH
7837: LD_VAR 0 4
7841: PUSH
7842: LD_VAR 0 6
7846: ARRAY
7847: PPUSH
7848: LD_VAR 0 4
7852: PUSH
7853: LD_VAR 0 6
7857: PUSH
7858: LD_INT 1
7860: PLUS
7861: ARRAY
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 48
7870: GO 7960
// begin repeat p := p + 2 ;
7872: LD_ADDR_VAR 0 6
7876: PUSH
7877: LD_VAR 0 6
7881: PUSH
7882: LD_INT 2
7884: PLUS
7885: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7886: LD_VAR 0 4
7890: PUSH
7891: LD_VAR 0 6
7895: ARRAY
7896: PPUSH
7897: LD_VAR 0 4
7901: PUSH
7902: LD_VAR 0 6
7906: PUSH
7907: LD_INT 1
7909: PLUS
7910: ARRAY
7911: PPUSH
7912: CALL_OW 428
7916: PUSH
7917: LD_INT 0
7919: EQUAL
7920: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7922: LD_VAR 0 5
7926: PPUSH
7927: LD_VAR 0 4
7931: PUSH
7932: LD_VAR 0 6
7936: ARRAY
7937: PPUSH
7938: LD_VAR 0 4
7942: PUSH
7943: LD_VAR 0 6
7947: PUSH
7948: LD_INT 1
7950: PLUS
7951: ARRAY
7952: PPUSH
7953: LD_INT 0
7955: PPUSH
7956: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7960: LD_INT 0
7962: PPUSH
7963: LD_INT 3
7965: PPUSH
7966: LD_EXP 32
7970: PUSH
7971: LD_INT 1
7973: PLUS
7974: PPUSH
7975: CALL_OW 380
// un := CreateHuman ;
7979: LD_ADDR_VAR 0 2
7983: PUSH
7984: CALL_OW 44
7988: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7989: LD_VAR 0 2
7993: PPUSH
7994: LD_VAR 0 5
7998: PPUSH
7999: CALL_OW 52
// end ;
8003: GO 7751
8005: POP
8006: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
8007: LD_INT 198
8009: PPUSH
8010: LD_INT 94
8012: PPUSH
8013: LD_INT 8
8015: PPUSH
8016: LD_INT 10
8018: PPUSH
8019: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8023: LD_INT 167
8025: PPUSH
8026: LD_INT 130
8028: PPUSH
8029: LD_INT 8
8031: PPUSH
8032: LD_INT 10
8034: PPUSH
8035: CALL_OW 330
// legion_mines := [ ] ;
8039: LD_ADDR_EXP 33
8043: PUSH
8044: EMPTY
8045: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_INT 176
8053: PPUSH
8054: LD_INT 122
8056: PPUSH
8057: LD_INT 188
8059: PPUSH
8060: LD_INT 126
8062: PPUSH
8063: LD_INT 6
8065: PPUSH
8066: CALL 1562 0 5
8070: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8071: LD_ADDR_EXP 33
8075: PUSH
8076: LD_EXP 33
8080: PUSH
8081: LD_INT 197
8083: PPUSH
8084: LD_INT 91
8086: PPUSH
8087: LD_INT 205
8089: PPUSH
8090: LD_INT 96
8092: PPUSH
8093: LD_INT 4
8095: PPUSH
8096: CALL 1562 0 5
8100: ADD
8101: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8102: LD_ADDR_EXP 33
8106: PUSH
8107: LD_EXP 33
8111: PUSH
8112: LD_INT 184
8114: PPUSH
8115: LD_INT 151
8117: PPUSH
8118: LD_INT 178
8120: PPUSH
8121: LD_INT 130
8123: PPUSH
8124: LD_INT 9
8126: PPUSH
8127: CALL 1562 0 5
8131: ADD
8132: ST_TO_ADDR
// if Difficulty > 1 then
8133: LD_OWVAR 67
8137: PUSH
8138: LD_INT 1
8140: GREATER
8141: IFFALSE 8174
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8143: LD_ADDR_EXP 33
8147: PUSH
8148: LD_EXP 33
8152: PUSH
8153: LD_INT 166
8155: PPUSH
8156: LD_INT 126
8158: PPUSH
8159: LD_INT 181
8161: PPUSH
8162: LD_INT 136
8164: PPUSH
8165: LD_INT 5
8167: PPUSH
8168: CALL 1562 0 5
8172: ADD
8173: ST_TO_ADDR
// p := 1 ;
8174: LD_ADDR_VAR 0 6
8178: PUSH
8179: LD_INT 1
8181: ST_TO_ADDR
// for i = 1 to 24 do
8182: LD_ADDR_VAR 0 3
8186: PUSH
8187: DOUBLE
8188: LD_INT 1
8190: DEC
8191: ST_TO_ADDR
8192: LD_INT 24
8194: PUSH
8195: FOR_TO
8196: IFFALSE 8250
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8198: LD_EXP 33
8202: PUSH
8203: LD_VAR 0 6
8207: ARRAY
8208: PPUSH
8209: LD_EXP 33
8213: PUSH
8214: LD_VAR 0 6
8218: PUSH
8219: LD_INT 1
8221: PLUS
8222: ARRAY
8223: PPUSH
8224: LD_INT 8
8226: PPUSH
8227: LD_INT 0
8229: PPUSH
8230: CALL_OW 454
// p := p + 2 ;
8234: LD_ADDR_VAR 0 6
8238: PUSH
8239: LD_VAR 0 6
8243: PUSH
8244: LD_INT 2
8246: PLUS
8247: ST_TO_ADDR
// end ;
8248: GO 8195
8250: POP
8251: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8252: LD_ADDR_EXP 35
8256: PUSH
8257: LD_INT 13
8259: PUSH
8260: LD_INT 3
8262: PUSH
8263: LD_INT 2
8265: PUSH
8266: LD_INT 32
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: ST_TO_ADDR
// end ;
8275: LD_VAR 0 1
8279: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8280: LD_INT 22
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: PUSH
8295: LD_INT 0
8297: GREATER
8298: IFFALSE 10484
8300: GO 8302
8302: DISABLE
8303: LD_INT 0
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
8316: PPUSH
8317: PPUSH
8318: PPUSH
8319: PPUSH
8320: PPUSH
8321: PPUSH
// begin enable ;
8322: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8323: LD_ADDR_VAR 0 8
8327: PUSH
8328: LD_INT 22
8330: PUSH
8331: LD_INT 8
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 30
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: PUSH
8348: EMPTY
8349: LIST
8350: LIST
8351: PPUSH
8352: CALL_OW 69
8356: PUSH
8357: LD_INT 1
8359: ARRAY
8360: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8361: LD_ADDR_VAR 0 9
8365: PUSH
8366: LD_INT 22
8368: PUSH
8369: LD_INT 8
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: LD_INT 30
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PPUSH
8390: CALL_OW 69
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8399: LD_ADDR_VAR 0 10
8403: PUSH
8404: LD_INT 22
8406: PUSH
8407: LD_INT 8
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 2
8416: PUSH
8417: LD_INT 30
8419: PUSH
8420: LD_INT 6
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: LD_INT 30
8429: PUSH
8430: LD_INT 8
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PPUSH
8446: CALL_OW 69
8450: PUSH
8451: LD_INT 1
8453: ARRAY
8454: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8455: LD_ADDR_VAR 0 11
8459: PUSH
8460: LD_INT 22
8462: PUSH
8463: LD_INT 8
8465: PUSH
8466: EMPTY
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 30
8472: PUSH
8473: LD_INT 32
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PPUSH
8484: CALL_OW 69
8488: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8489: LD_ADDR_VAR 0 16
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 8
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 25
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8523: LD_ADDR_VAR 0 15
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 8
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PUSH
8538: LD_INT 25
8540: PUSH
8541: LD_INT 1
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PPUSH
8552: CALL_OW 69
8556: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8557: LD_ADDR_VAR 0 14
8561: PUSH
8562: LD_INT 22
8564: PUSH
8565: LD_INT 8
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: PUSH
8572: LD_INT 25
8574: PUSH
8575: LD_INT 3
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PPUSH
8586: CALL_OW 69
8590: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8591: LD_ADDR_VAR 0 13
8595: PUSH
8596: LD_INT 22
8598: PUSH
8599: LD_INT 8
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 25
8608: PUSH
8609: LD_INT 4
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PPUSH
8620: CALL_OW 69
8624: ST_TO_ADDR
// if l_eng then
8625: LD_VAR 0 16
8629: IFFALSE 9044
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8631: LD_ADDR_VAR 0 5
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 21
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8665: LD_VAR 0 5
8669: PPUSH
8670: LD_INT 3
8672: PUSH
8673: LD_INT 24
8675: PUSH
8676: LD_INT 1000
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PPUSH
8687: CALL_OW 72
8691: PUSH
8692: LD_INT 0
8694: GREATER
8695: IFFALSE 8829
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8697: LD_ADDR_VAR 0 3
8701: PUSH
8702: LD_VAR 0 5
8706: PPUSH
8707: LD_INT 3
8709: PUSH
8710: LD_INT 24
8712: PUSH
8713: LD_INT 1000
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PPUSH
8724: CALL_OW 72
8728: ST_TO_ADDR
// for i = 1 to l_eng do
8729: LD_ADDR_VAR 0 2
8733: PUSH
8734: DOUBLE
8735: LD_INT 1
8737: DEC
8738: ST_TO_ADDR
8739: LD_VAR 0 16
8743: PUSH
8744: FOR_TO
8745: IFFALSE 8825
// if IsInUnit ( l_eng [ i ] ) then
8747: LD_VAR 0 16
8751: PUSH
8752: LD_VAR 0 2
8756: ARRAY
8757: PPUSH
8758: CALL_OW 310
8762: IFFALSE 8781
// ComExitBuilding ( l_eng [ i ] ) else
8764: LD_VAR 0 16
8768: PUSH
8769: LD_VAR 0 2
8773: ARRAY
8774: PPUSH
8775: CALL_OW 122
8779: GO 8823
// if not HasTask ( l_eng [ i ] ) then
8781: LD_VAR 0 16
8785: PUSH
8786: LD_VAR 0 2
8790: ARRAY
8791: PPUSH
8792: CALL_OW 314
8796: NOT
8797: IFFALSE 8823
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8799: LD_VAR 0 16
8803: PUSH
8804: LD_VAR 0 2
8808: ARRAY
8809: PPUSH
8810: LD_VAR 0 3
8814: PUSH
8815: LD_INT 1
8817: ARRAY
8818: PPUSH
8819: CALL_OW 130
8823: GO 8744
8825: POP
8826: POP
// end else
8827: GO 9044
// begin if legion_blist > 0 then
8829: LD_EXP 34
8833: PUSH
8834: LD_INT 0
8836: GREATER
8837: IFFALSE 8966
// begin for i = 1 to l_eng do
8839: LD_ADDR_VAR 0 2
8843: PUSH
8844: DOUBLE
8845: LD_INT 1
8847: DEC
8848: ST_TO_ADDR
8849: LD_VAR 0 16
8853: PUSH
8854: FOR_TO
8855: IFFALSE 8962
// if IsInUnit ( l_eng [ i ] ) then
8857: LD_VAR 0 16
8861: PUSH
8862: LD_VAR 0 2
8866: ARRAY
8867: PPUSH
8868: CALL_OW 310
8872: IFFALSE 8891
// ComExitBuilding ( l_eng [ i ] ) else
8874: LD_VAR 0 16
8878: PUSH
8879: LD_VAR 0 2
8883: ARRAY
8884: PPUSH
8885: CALL_OW 122
8889: GO 8960
// if not HasTask ( l_eng [ i ] ) then
8891: LD_VAR 0 16
8895: PUSH
8896: LD_VAR 0 2
8900: ARRAY
8901: PPUSH
8902: CALL_OW 314
8906: NOT
8907: IFFALSE 8960
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8909: LD_VAR 0 16
8913: PUSH
8914: LD_VAR 0 2
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 1
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 2
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 3
8945: ARRAY
8946: PPUSH
8947: LD_EXP 34
8951: PUSH
8952: LD_INT 4
8954: ARRAY
8955: PPUSH
8956: CALL_OW 145
8960: GO 8854
8962: POP
8963: POP
// end else
8964: GO 9044
// for i = 1 to l_eng do
8966: LD_ADDR_VAR 0 2
8970: PUSH
8971: DOUBLE
8972: LD_INT 1
8974: DEC
8975: ST_TO_ADDR
8976: LD_VAR 0 16
8980: PUSH
8981: FOR_TO
8982: IFFALSE 9042
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8984: LD_VAR 0 16
8988: PUSH
8989: LD_VAR 0 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 310
8999: NOT
9000: PUSH
9001: LD_VAR 0 16
9005: PUSH
9006: LD_VAR 0 2
9010: ARRAY
9011: PPUSH
9012: CALL_OW 314
9016: NOT
9017: AND
9018: IFFALSE 9040
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9020: LD_VAR 0 16
9024: PUSH
9025: LD_VAR 0 2
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 8
9035: PPUSH
9036: CALL_OW 120
9040: GO 8981
9042: POP
9043: POP
// end ; end ; if l_factory then
9044: LD_VAR 0 9
9048: IFFALSE 9448
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9050: LD_INT 22
9052: PUSH
9053: LD_INT 8
9055: PUSH
9056: EMPTY
9057: LIST
9058: LIST
9059: PUSH
9060: LD_INT 33
9062: PUSH
9063: LD_INT 2
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PUSH
9070: LD_INT 3
9072: PUSH
9073: LD_INT 61
9075: PUSH
9076: EMPTY
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: PUSH
9093: LD_INT 0
9095: GREATER
9096: PUSH
9097: LD_INT 22
9099: PUSH
9100: LD_INT 8
9102: PUSH
9103: EMPTY
9104: LIST
9105: LIST
9106: PUSH
9107: LD_INT 34
9109: PUSH
9110: LD_INT 31
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PPUSH
9121: CALL_OW 69
9125: PUSH
9126: LD_INT 0
9128: GREATER
9129: AND
9130: IFFALSE 9250
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9132: LD_INT 22
9134: PUSH
9135: LD_INT 8
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: PUSH
9142: LD_INT 33
9144: PUSH
9145: LD_INT 2
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: LD_INT 61
9157: PUSH
9158: EMPTY
9159: LIST
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PUSH
9165: EMPTY
9166: LIST
9167: LIST
9168: LIST
9169: PPUSH
9170: CALL_OW 69
9174: PUSH
9175: LD_INT 1
9177: ARRAY
9178: PPUSH
9179: LD_INT 22
9181: PUSH
9182: LD_INT 8
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PUSH
9189: LD_INT 34
9191: PUSH
9192: LD_INT 31
9194: PUSH
9195: EMPTY
9196: LIST
9197: LIST
9198: PUSH
9199: EMPTY
9200: LIST
9201: LIST
9202: PPUSH
9203: CALL_OW 69
9207: PUSH
9208: LD_INT 1
9210: PPUSH
9211: LD_INT 22
9213: PUSH
9214: LD_INT 8
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: LD_INT 34
9223: PUSH
9224: LD_INT 31
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL_OW 69
9239: PPUSH
9240: CALL_OW 12
9244: ARRAY
9245: PPUSH
9246: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9250: LD_EXP 35
9254: PUSH
9255: LD_INT 0
9257: GREATER
9258: PUSH
9259: LD_VAR 0 9
9263: PPUSH
9264: CALL_OW 461
9268: PUSH
9269: LD_INT 2
9271: EQUAL
9272: AND
9273: IFFALSE 9358
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9275: LD_VAR 0 9
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 1
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 2
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 3
9305: ARRAY
9306: PPUSH
9307: LD_EXP 35
9311: PUSH
9312: LD_INT 4
9314: ARRAY
9315: PPUSH
9316: CALL_OW 125
// for i = 1 to 4 do
9320: LD_ADDR_VAR 0 2
9324: PUSH
9325: DOUBLE
9326: LD_INT 1
9328: DEC
9329: ST_TO_ADDR
9330: LD_INT 4
9332: PUSH
9333: FOR_TO
9334: IFFALSE 9356
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9336: LD_ADDR_EXP 35
9340: PUSH
9341: LD_EXP 35
9345: PPUSH
9346: LD_INT 1
9348: PPUSH
9349: CALL_OW 3
9353: ST_TO_ADDR
9354: GO 9333
9356: POP
9357: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9358: LD_VAR 0 11
9362: PPUSH
9363: LD_INT 35
9365: PUSH
9366: LD_INT 0
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: PPUSH
9373: CALL_OW 72
9377: PUSH
9378: LD_INT 0
9380: GREATER
9381: PUSH
9382: LD_VAR 0 9
9386: PPUSH
9387: CALL_OW 461
9391: PUSH
9392: LD_INT 2
9394: EQUAL
9395: AND
9396: IFFALSE 9448
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9398: LD_VAR 0 11
9402: PPUSH
9403: LD_INT 35
9405: PUSH
9406: LD_INT 0
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 72
9417: PUSH
9418: LD_INT 1
9420: ARRAY
9421: PPUSH
9422: LD_INT 28
9424: PUSH
9425: LD_INT 27
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: LD_INT 1
9434: PPUSH
9435: LD_INT 2
9437: PPUSH
9438: CALL_OW 12
9442: ARRAY
9443: PPUSH
9444: CALL_OW 148
// end ; if legion_enemy > 0 then
9448: LD_EXP 36
9452: PUSH
9453: LD_INT 0
9455: GREATER
9456: IFFALSE 10036
// begin if tick mod 11 11$00 = 0 then
9458: LD_OWVAR 1
9462: PUSH
9463: LD_INT 23100
9465: MOD
9466: PUSH
9467: LD_INT 0
9469: EQUAL
9470: IFFALSE 9720
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9472: LD_ADDR_EXP 35
9476: PUSH
9477: LD_EXP 35
9481: PUSH
9482: LD_INT 13
9484: PUSH
9485: LD_INT 1
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: LIST
9495: ADD
9496: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9497: LD_ADDR_EXP 35
9501: PUSH
9502: LD_EXP 35
9506: PUSH
9507: LD_INT 28
9509: PUSH
9510: LD_INT 27
9512: PUSH
9513: LD_INT 29
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: PUSH
9521: LD_INT 1
9523: PPUSH
9524: LD_INT 3
9526: PPUSH
9527: CALL_OW 12
9531: ARRAY
9532: ADD
9533: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9534: LD_ADDR_EXP 35
9538: PUSH
9539: LD_EXP 35
9543: PUSH
9544: LD_INT 13
9546: PUSH
9547: LD_INT 1
9549: PUSH
9550: LD_INT 2
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: ADD
9558: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9559: LD_ADDR_EXP 35
9563: PUSH
9564: LD_EXP 35
9568: PUSH
9569: LD_INT 28
9571: PUSH
9572: LD_INT 27
9574: PUSH
9575: LD_INT 29
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 1
9585: PPUSH
9586: LD_INT 3
9588: PPUSH
9589: CALL_OW 12
9593: ARRAY
9594: ADD
9595: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9596: LD_ADDR_EXP 35
9600: PUSH
9601: LD_EXP 35
9605: PUSH
9606: LD_INT 13
9608: PUSH
9609: LD_INT 1
9611: PUSH
9612: LD_INT 2
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: ADD
9620: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9621: LD_ADDR_EXP 35
9625: PUSH
9626: LD_EXP 35
9630: PUSH
9631: LD_INT 28
9633: PUSH
9634: LD_INT 27
9636: PUSH
9637: LD_INT 29
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_INT 1
9647: PPUSH
9648: LD_INT 3
9650: PPUSH
9651: CALL_OW 12
9655: ARRAY
9656: ADD
9657: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9658: LD_ADDR_EXP 35
9662: PUSH
9663: LD_EXP 35
9667: PUSH
9668: LD_INT 13
9670: PUSH
9671: LD_INT 1
9673: PUSH
9674: LD_INT 2
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: ADD
9682: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9683: LD_ADDR_EXP 35
9687: PUSH
9688: LD_EXP 35
9692: PUSH
9693: LD_INT 28
9695: PUSH
9696: LD_INT 27
9698: PUSH
9699: LD_INT 29
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 3
9712: PPUSH
9713: CALL_OW 12
9717: ARRAY
9718: ADD
9719: ST_TO_ADDR
// end ; if legion_force >= 7 then
9720: LD_EXP 31
9724: PUSH
9725: LD_INT 7
9727: GREATEREQUAL
9728: IFFALSE 9911
// begin for i = 1 to legion_force do
9730: LD_ADDR_VAR 0 2
9734: PUSH
9735: DOUBLE
9736: LD_INT 1
9738: DEC
9739: ST_TO_ADDR
9740: LD_EXP 31
9744: PUSH
9745: FOR_TO
9746: IFFALSE 9909
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9748: LD_EXP 31
9752: PUSH
9753: LD_VAR 0 2
9757: ARRAY
9758: PPUSH
9759: CALL_OW 314
9763: NOT
9764: PUSH
9765: LD_EXP 31
9769: PUSH
9770: LD_VAR 0 2
9774: ARRAY
9775: PPUSH
9776: CALL_OW 110
9780: PUSH
9781: LD_INT 11
9783: NONEQUAL
9784: AND
9785: IFFALSE 9907
// begin case legion_enemy of 1 :
9787: LD_EXP 36
9791: PUSH
9792: LD_INT 1
9794: DOUBLE
9795: EQUAL
9796: IFTRUE 9800
9798: GO 9824
9800: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9801: LD_EXP 31
9805: PUSH
9806: LD_VAR 0 2
9810: ARRAY
9811: PPUSH
9812: LD_INT 142
9814: PPUSH
9815: LD_INT 144
9817: PPUSH
9818: CALL_OW 111
9822: GO 9889
9824: LD_INT 2
9826: DOUBLE
9827: EQUAL
9828: IFTRUE 9832
9830: GO 9856
9832: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9833: LD_EXP 31
9837: PUSH
9838: LD_VAR 0 2
9842: ARRAY
9843: PPUSH
9844: LD_INT 101
9846: PPUSH
9847: LD_INT 34
9849: PPUSH
9850: CALL_OW 111
9854: GO 9889
9856: LD_INT 7
9858: DOUBLE
9859: EQUAL
9860: IFTRUE 9864
9862: GO 9888
9864: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9865: LD_EXP 31
9869: PUSH
9870: LD_VAR 0 2
9874: ARRAY
9875: PPUSH
9876: LD_INT 173
9878: PPUSH
9879: LD_INT 127
9881: PPUSH
9882: CALL_OW 111
9886: GO 9889
9888: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9889: LD_EXP 31
9893: PUSH
9894: LD_VAR 0 2
9898: ARRAY
9899: PPUSH
9900: LD_INT 11
9902: PPUSH
9903: CALL_OW 109
// end ; end ;
9907: GO 9745
9909: POP
9910: POP
// end ; if legion_force then
9911: LD_EXP 31
9915: IFFALSE 10036
// begin tmp := legion_force ;
9917: LD_ADDR_VAR 0 3
9921: PUSH
9922: LD_EXP 31
9926: ST_TO_ADDR
// for i = 1 to tmp do
9927: LD_ADDR_VAR 0 2
9931: PUSH
9932: DOUBLE
9933: LD_INT 1
9935: DEC
9936: ST_TO_ADDR
9937: LD_VAR 0 3
9941: PUSH
9942: FOR_TO
9943: IFFALSE 10034
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9945: LD_VAR 0 3
9949: PUSH
9950: LD_VAR 0 2
9954: ARRAY
9955: PPUSH
9956: CALL_OW 314
9960: NOT
9961: PUSH
9962: LD_EXP 31
9966: PUSH
9967: LD_VAR 0 2
9971: ARRAY
9972: PPUSH
9973: CALL_OW 110
9977: PUSH
9978: LD_INT 11
9980: EQUAL
9981: AND
9982: IFFALSE 10032
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9984: LD_VAR 0 3
9988: PUSH
9989: LD_VAR 0 2
9993: ARRAY
9994: PPUSH
9995: LD_INT 22
9997: PUSH
9998: LD_EXP 36
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PPUSH
10007: CALL_OW 69
10011: PPUSH
10012: LD_VAR 0 3
10016: PUSH
10017: LD_VAR 0 2
10021: ARRAY
10022: PPUSH
10023: CALL_OW 74
10027: PPUSH
10028: CALL_OW 115
10032: GO 9942
10034: POP
10035: POP
// end ; end ; p := 1 ;
10036: LD_ADDR_VAR 0 6
10040: PUSH
10041: LD_INT 1
10043: ST_TO_ADDR
// for i = 1 to 24 do
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: DOUBLE
10050: LD_INT 1
10052: DEC
10053: ST_TO_ADDR
10054: LD_INT 24
10056: PUSH
10057: FOR_TO
10058: IFFALSE 10188
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10060: LD_EXP 33
10064: PUSH
10065: LD_VAR 0 6
10069: ARRAY
10070: PPUSH
10071: LD_EXP 33
10075: PUSH
10076: LD_VAR 0 6
10080: PUSH
10081: LD_INT 1
10083: PLUS
10084: ARRAY
10085: PPUSH
10086: CALL_OW 428
10090: PUSH
10091: LD_INT 0
10093: GREATER
10094: IFFALSE 10172
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10096: LD_EXP 33
10100: PUSH
10101: LD_VAR 0 6
10105: ARRAY
10106: PPUSH
10107: LD_EXP 33
10111: PUSH
10112: LD_VAR 0 6
10116: PUSH
10117: LD_INT 1
10119: PLUS
10120: ARRAY
10121: PPUSH
10122: CALL_OW 428
10126: PPUSH
10127: CALL_OW 255
10131: PUSH
10132: LD_EXP 36
10136: EQUAL
10137: IFFALSE 10172
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10139: LD_EXP 33
10143: PUSH
10144: LD_VAR 0 6
10148: ARRAY
10149: PPUSH
10150: LD_EXP 33
10154: PUSH
10155: LD_VAR 0 6
10159: PUSH
10160: LD_INT 1
10162: PLUS
10163: ARRAY
10164: PPUSH
10165: LD_INT 8
10167: PPUSH
10168: CALL_OW 456
// p := p + 2 ;
10172: LD_ADDR_VAR 0 6
10176: PUSH
10177: LD_VAR 0 6
10181: PUSH
10182: LD_INT 2
10184: PLUS
10185: ST_TO_ADDR
// end ;
10186: GO 10057
10188: POP
10189: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10190: LD_INT 22
10192: PUSH
10193: LD_INT 8
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: LD_INT 32
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PPUSH
10214: CALL_OW 69
10218: IFFALSE 10332
// begin if l_cargo = false then
10220: LD_VAR 0 17
10224: PUSH
10225: LD_INT 0
10227: EQUAL
10228: IFFALSE 10264
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10230: LD_ADDR_VAR 0 17
10234: PUSH
10235: LD_INT 22
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 34
10247: PUSH
10248: LD_INT 32
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 69
10263: ST_TO_ADDR
// if l_cargo then
10264: LD_VAR 0 17
10268: IFFALSE 10332
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10270: LD_ADDR_VAR 0 7
10274: PUSH
10275: LD_INT 14
10277: PPUSH
10278: CALL_OW 435
10282: ST_TO_ADDR
// if cr > 0 then
10283: LD_VAR 0 7
10287: PUSH
10288: LD_INT 0
10290: GREATER
10291: IFFALSE 10332
// if not HasTask ( l_cargo ) then
10293: LD_VAR 0 17
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10332
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10305: LD_VAR 0 17
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 1
10317: ARRAY
10318: PPUSH
10319: LD_VAR 0 7
10323: PUSH
10324: LD_INT 2
10326: ARRAY
10327: PPUSH
10328: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10332: LD_OWVAR 1
10336: PUSH
10337: LD_INT 52500
10339: PUSH
10340: LD_INT 46200
10342: PUSH
10343: LD_INT 42000
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_OWVAR 67
10355: ARRAY
10356: EQUAL
10357: PUSH
10358: LD_INT 1
10360: PPUSH
10361: CALL_OW 469
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PUSH
10370: LD_INT 112
10372: EQUAL
10373: AND
10374: PUSH
10375: LD_INT 1
10377: PPUSH
10378: CALL_OW 469
10382: PUSH
10383: LD_INT 2
10385: ARRAY
10386: PUSH
10387: LD_INT 67
10389: EQUAL
10390: AND
10391: IFFALSE 10484
// begin un := l_eng [ 1 ] ;
10393: LD_ADDR_VAR 0 1
10397: PUSH
10398: LD_VAR 0 16
10402: PUSH
10403: LD_INT 1
10405: ARRAY
10406: ST_TO_ADDR
// if IsInUnit ( un ) then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 310
10416: IFFALSE 10427
// ComExitBuilding ( un ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10427: LD_VAR 0 1
10431: PPUSH
10432: LD_INT 1
10434: PPUSH
10435: CALL_OW 469
10439: PUSH
10440: LD_INT 1
10442: ARRAY
10443: PPUSH
10444: LD_INT 1
10446: PPUSH
10447: CALL_OW 469
10451: PUSH
10452: LD_INT 2
10454: ARRAY
10455: PPUSH
10456: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_INT 207
10467: PPUSH
10468: LD_INT 123
10470: PPUSH
10471: CALL_OW 171
// AddComUnload ( un ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 219
// end ; end ;
10484: PPOPN 17
10486: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10487: LD_OWVAR 67
10491: PUSH
10492: LD_INT 1
10494: GREATER
10495: IFFALSE 10700
10497: GO 10499
10499: DISABLE
10500: LD_INT 0
10502: PPUSH
10503: PPUSH
10504: PPUSH
10505: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10506: LD_INT 35
10508: PPUSH
10509: LD_INT 12635
10511: PPUSH
10512: CALL_OW 12
10516: PPUSH
10517: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10521: LD_ADDR_VAR 0 2
10525: PUSH
10526: LD_INT 22
10528: PUSH
10529: LD_INT 8
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: PUSH
10536: LD_INT 25
10538: PUSH
10539: LD_INT 4
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: ST_TO_ADDR
// p := 1 ;
10555: LD_ADDR_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10563: LD_ADDR_VAR 0 3
10567: PUSH
10568: LD_INT 116
10570: PUSH
10571: LD_INT 139
10573: PUSH
10574: LD_INT 69
10576: PUSH
10577: LD_INT 13
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: ST_TO_ADDR
// for i = 1 to 2 do
10586: LD_ADDR_VAR 0 1
10590: PUSH
10591: DOUBLE
10592: LD_INT 1
10594: DEC
10595: ST_TO_ADDR
10596: LD_INT 2
10598: PUSH
10599: FOR_TO
10600: IFFALSE 10698
// begin if IsInUnit ( sci [ i ] ) then
10602: LD_VAR 0 2
10606: PUSH
10607: LD_VAR 0 1
10611: ARRAY
10612: PPUSH
10613: CALL_OW 310
10617: IFFALSE 10634
// ComExitBuilding ( sci [ i ] ) ;
10619: LD_VAR 0 2
10623: PUSH
10624: LD_VAR 0 1
10628: ARRAY
10629: PPUSH
10630: CALL_OW 122
// Wait ( 0 0$03 ) ;
10634: LD_INT 105
10636: PPUSH
10637: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10641: LD_VAR 0 2
10645: PUSH
10646: LD_VAR 0 1
10650: ARRAY
10651: PPUSH
10652: LD_VAR 0 3
10656: PUSH
10657: LD_VAR 0 4
10661: ARRAY
10662: PPUSH
10663: LD_VAR 0 3
10667: PUSH
10668: LD_VAR 0 4
10672: PUSH
10673: LD_INT 1
10675: PLUS
10676: ARRAY
10677: PPUSH
10678: CALL_OW 158
// p := p + 2 ;
10682: LD_ADDR_VAR 0 4
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: LD_INT 2
10694: PLUS
10695: ST_TO_ADDR
// end ;
10696: GO 10599
10698: POP
10699: POP
// end ;
10700: PPOPN 4
10702: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10703: LD_INT 14
10705: PPUSH
10706: CALL_OW 435
10710: PUSH
10711: LD_INT 20
10713: LESS
10714: IFFALSE 10741
10716: GO 10718
10718: DISABLE
// begin enable ;
10719: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10720: LD_INT 1
10722: PPUSH
10723: LD_INT 5
10725: PPUSH
10726: CALL_OW 12
10730: PPUSH
10731: LD_INT 14
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 55
// end ; end_of_file
10741: END
// export function Action ; var un , gamemode , speaker ; begin
10742: LD_INT 0
10744: PPUSH
10745: PPUSH
10746: PPUSH
10747: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10748: LD_ADDR_OWVAR 67
10752: PUSH
10753: LD_INT 0
10755: PPUSH
10756: CALL_OW 426
10760: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10761: LD_ADDR_VAR 0 3
10765: PUSH
10766: LD_INT 1
10768: PPUSH
10769: CALL_OW 426
10773: ST_TO_ADDR
// if gamemode = 1 then
10774: LD_VAR 0 3
10778: PUSH
10779: LD_INT 1
10781: EQUAL
10782: IFFALSE 10806
// begin your_side := 1 ;
10784: LD_ADDR_OWVAR 2
10788: PUSH
10789: LD_INT 1
10791: ST_TO_ADDR
// legion_enemy := 1 ;
10792: LD_ADDR_EXP 36
10796: PUSH
10797: LD_INT 1
10799: ST_TO_ADDR
// PrepareAmerican ;
10800: CALL 221 0 0
// end else
10804: GO 10858
// if gamemode = 2 then
10806: LD_VAR 0 3
10810: PUSH
10811: LD_INT 2
10813: EQUAL
10814: IFFALSE 10838
// begin your_side := 2 ;
10816: LD_ADDR_OWVAR 2
10820: PUSH
10821: LD_INT 2
10823: ST_TO_ADDR
// legion_enemy := 2 ;
10824: LD_ADDR_EXP 36
10828: PUSH
10829: LD_INT 2
10831: ST_TO_ADDR
// PrepareArabian ;
10832: CALL 18147 0 0
// end else
10836: GO 10858
// begin your_side := 7 ;
10838: LD_ADDR_OWVAR 2
10842: PUSH
10843: LD_INT 7
10845: ST_TO_ADDR
// legion_enemy := 7 ;
10846: LD_ADDR_EXP 36
10850: PUSH
10851: LD_INT 7
10853: ST_TO_ADDR
// PrepareAlliance ;
10854: CALL 15558 0 0
// end ; if your_side = 1 then
10858: LD_OWVAR 2
10862: PUSH
10863: LD_INT 1
10865: EQUAL
10866: IFFALSE 11344
// begin case Query ( QVul4 ) of 1 :
10868: LD_STRING QVul4
10870: PPUSH
10871: CALL_OW 97
10875: PUSH
10876: LD_INT 1
10878: DOUBLE
10879: EQUAL
10880: IFTRUE 10884
10882: GO 10887
10884: POP
// ; end ;
10885: GO 10888
10887: POP
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10892: LD_INT 8
10894: PPUSH
10895: LD_INT 5
10897: PPUSH
10898: CALL_OW 86
// uc_side := 4 ;
10902: LD_ADDR_OWVAR 20
10906: PUSH
10907: LD_INT 4
10909: ST_TO_ADDR
// uc_nation := 1 ;
10910: LD_ADDR_OWVAR 21
10914: PUSH
10915: LD_INT 1
10917: ST_TO_ADDR
// hc_importance := 0 ;
10918: LD_ADDR_OWVAR 32
10922: PUSH
10923: LD_INT 0
10925: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10926: LD_INT 1
10928: PPUSH
10929: LD_INT 3
10931: PPUSH
10932: LD_EXP 21
10936: PPUSH
10937: CALL_OW 380
// un := CreateHuman ;
10941: LD_ADDR_VAR 0 2
10945: PUSH
10946: CALL_OW 44
10950: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10951: LD_VAR 0 2
10955: PPUSH
10956: LD_INT 12
10958: PPUSH
10959: LD_INT 9
10961: PPUSH
10962: LD_INT 0
10964: PPUSH
10965: CALL_OW 48
// hc_name := Stuart Carey ;
10969: LD_ADDR_OWVAR 26
10973: PUSH
10974: LD_STRING Stuart Carey
10976: ST_TO_ADDR
// hc_class := 1 ;
10977: LD_ADDR_OWVAR 28
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// hc_gallery := vulcano ;
10985: LD_ADDR_OWVAR 33
10989: PUSH
10990: LD_STRING vulcano
10992: ST_TO_ADDR
// hc_face_number := 1 ;
10993: LD_ADDR_OWVAR 34
10997: PUSH
10998: LD_INT 1
11000: ST_TO_ADDR
// us_guy := CreateHuman ;
11001: LD_ADDR_EXP 22
11005: PUSH
11006: CALL_OW 44
11010: ST_TO_ADDR
// InitHc ;
11011: CALL_OW 19
// if rand ( 0 , 1 ) then
11015: LD_INT 0
11017: PPUSH
11018: LD_INT 1
11020: PPUSH
11021: CALL_OW 12
11025: IFFALSE 11042
// PrepareHuman ( sex_male , 3 , 6 ) else
11027: LD_INT 1
11029: PPUSH
11030: LD_INT 3
11032: PPUSH
11033: LD_INT 6
11035: PPUSH
11036: CALL_OW 380
11040: GO 11055
// PrepareHuman ( sex_female , 4 , 8 ) ;
11042: LD_INT 2
11044: PPUSH
11045: LD_INT 4
11047: PPUSH
11048: LD_INT 8
11050: PPUSH
11051: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11055: LD_VAR 0 2
11059: PPUSH
11060: LD_EXP 19
11064: PPUSH
11065: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11069: LD_EXP 19
11073: PPUSH
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 119
// if GetSex ( un ) = sex_male then
11083: LD_VAR 0 2
11087: PPUSH
11088: CALL_OW 258
11092: PUSH
11093: LD_INT 1
11095: EQUAL
11096: IFFALSE 11179
// begin Say ( un , VD-un1 ) ;
11098: LD_VAR 0 2
11102: PPUSH
11103: LD_STRING VD-un1
11105: PPUSH
11106: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11110: LD_EXP 19
11114: PPUSH
11115: LD_STRING VDc-1
11117: PPUSH
11118: CALL_OW 88
// Say ( un , VD-un2 ) ;
11122: LD_VAR 0 2
11126: PPUSH
11127: LD_STRING VD-un2
11129: PPUSH
11130: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11134: LD_EXP 19
11138: PPUSH
11139: LD_STRING VDc-2
11141: PPUSH
11142: CALL_OW 88
// Say ( un , VD-un3 ) ;
11146: LD_VAR 0 2
11150: PPUSH
11151: LD_STRING VD-un3
11153: PPUSH
11154: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11158: LD_INT 7
11160: PPUSH
11161: CALL_OW 67
// Say ( un , VD-un4 ) ;
11165: LD_VAR 0 2
11169: PPUSH
11170: LD_STRING VD-un4
11172: PPUSH
11173: CALL_OW 88
// end else
11177: GO 11258
// begin Say ( un , VD-unf1 ) ;
11179: LD_VAR 0 2
11183: PPUSH
11184: LD_STRING VD-unf1
11186: PPUSH
11187: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11191: LD_EXP 19
11195: PPUSH
11196: LD_STRING VDc-1
11198: PPUSH
11199: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11203: LD_VAR 0 2
11207: PPUSH
11208: LD_STRING VD-unf2
11210: PPUSH
11211: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11215: LD_EXP 19
11219: PPUSH
11220: LD_STRING VDc-2
11222: PPUSH
11223: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11227: LD_VAR 0 2
11231: PPUSH
11232: LD_STRING VD-unf3
11234: PPUSH
11235: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11239: LD_INT 7
11241: PPUSH
11242: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11246: LD_VAR 0 2
11250: PPUSH
11251: LD_STRING VD-unf4
11253: PPUSH
11254: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11258: LD_VAR 0 2
11262: PPUSH
11263: LD_INT 2
11265: PPUSH
11266: LD_INT 2
11268: PPUSH
11269: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11273: LD_EXP 19
11277: PPUSH
11278: LD_STRING VDc-3
11280: PPUSH
11281: CALL_OW 88
// InGameOff ;
11285: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11289: LD_STRING CVulc1
11291: PPUSH
11292: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11303: LD_VAR 0 2
11307: PPUSH
11308: CALL_OW 250
11312: PUSH
11313: LD_INT 2
11315: EQUAL
11316: PUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PUSH
11327: LD_INT 2
11329: EQUAL
11330: AND
11331: IFFALSE 11296
// RemoveUnit ( un ) ;
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 64
// end else
11342: GO 11721
// if your_side = 2 then
11344: LD_OWVAR 2
11348: PUSH
11349: LD_INT 2
11351: EQUAL
11352: IFFALSE 11568
// begin CenterNowOnUnits ( player_commander ) ;
11354: LD_EXP 10
11358: PPUSH
11359: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11363: LD_ADDR_VAR 0 4
11367: PUSH
11368: LD_INT 22
11370: PUSH
11371: LD_INT 2
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: LD_INT 21
11380: PUSH
11381: LD_INT 1
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: PPUSH
11392: CALL_OW 69
11396: PUSH
11397: LD_EXP 51
11401: DIFF
11402: ST_TO_ADDR
// if speaker then
11403: LD_VAR 0 4
11407: IFFALSE 11559
// begin InGameOn ;
11409: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11413: LD_EXP 51
11417: PPUSH
11418: LD_STRING VSd-1
11420: PPUSH
11421: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11425: LD_VAR 0 4
11429: PUSH
11430: LD_INT 1
11432: ARRAY
11433: PPUSH
11434: CALL_OW 258
11438: PUSH
11439: LD_INT 1
11441: EQUAL
11442: IFFALSE 11462
// Say ( speaker [ 1 ] , VAd-1 ) else
11444: LD_VAR 0 4
11448: PUSH
11449: LD_INT 1
11451: ARRAY
11452: PPUSH
11453: LD_STRING VAd-1
11455: PPUSH
11456: CALL_OW 88
11460: GO 11478
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11462: LD_VAR 0 4
11466: PUSH
11467: LD_INT 1
11469: ARRAY
11470: PPUSH
11471: LD_STRING VAfd-1
11473: PPUSH
11474: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11478: LD_EXP 51
11482: PPUSH
11483: LD_STRING VSd-2
11485: PPUSH
11486: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11490: LD_VAR 0 4
11494: PUSH
11495: LD_INT 1
11497: ARRAY
11498: PPUSH
11499: CALL_OW 258
11503: PUSH
11504: LD_INT 1
11506: EQUAL
11507: IFFALSE 11527
// Say ( speaker [ 1 ] , VAd-2 ) else
11509: LD_VAR 0 4
11513: PUSH
11514: LD_INT 1
11516: ARRAY
11517: PPUSH
11518: LD_STRING VAd-2
11520: PPUSH
11521: CALL_OW 88
11525: GO 11543
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11527: LD_VAR 0 4
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PPUSH
11536: LD_STRING VAfd-2
11538: PPUSH
11539: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11543: LD_EXP 51
11547: PPUSH
11548: LD_STRING VSd-3
11550: PPUSH
11551: CALL_OW 88
// InGameOff ;
11555: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11559: LD_STRING CVulc5
11561: PPUSH
11562: CALL_OW 337
// end else
11566: GO 11721
// if your_side = 7 then
11568: LD_OWVAR 2
11572: PUSH
11573: LD_INT 7
11575: EQUAL
11576: IFFALSE 11721
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11578: LD_ADDR_VAR 0 4
11582: PUSH
11583: LD_INT 22
11585: PUSH
11586: LD_INT 7
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: LD_INT 21
11595: PUSH
11596: LD_INT 1
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PPUSH
11607: CALL_OW 69
11611: PUSH
11612: LD_EXP 37
11616: DIFF
11617: ST_TO_ADDR
// if speaker then
11618: LD_VAR 0 4
11622: IFFALSE 11714
// begin CenterNowOnUnits ( al_commander ) ;
11624: LD_EXP 37
11628: PPUSH
11629: CALL_OW 87
// InGameOn ;
11633: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11637: LD_EXP 37
11641: PPUSH
11642: LD_STRING VPd-1
11644: PPUSH
11645: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11649: LD_VAR 0 4
11653: PUSH
11654: LD_INT 1
11656: ARRAY
11657: PPUSH
11658: CALL_OW 258
11662: IFFALSE 11682
// Say ( speaker [ 1 ] , VPpd-1 ) else
11664: LD_VAR 0 4
11668: PUSH
11669: LD_INT 1
11671: ARRAY
11672: PPUSH
11673: LD_STRING VPpd-1
11675: PPUSH
11676: CALL_OW 88
11680: GO 11698
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11682: LD_VAR 0 4
11686: PUSH
11687: LD_INT 1
11689: ARRAY
11690: PPUSH
11691: LD_STRING VPpdf-1
11693: PPUSH
11694: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11698: LD_EXP 37
11702: PPUSH
11703: LD_STRING VPd-2
11705: PPUSH
11706: CALL_OW 88
// InGameOff ;
11710: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11714: LD_STRING CVulc7
11716: PPUSH
11717: CALL_OW 337
// end ; SaveForQuickRestart ;
11721: CALL_OW 22
// end ;
11725: LD_VAR 0 1
11729: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11730: LD_INT 22
11732: PUSH
11733: LD_INT 2
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PUSH
11740: LD_INT 30
11742: PUSH
11743: LD_INT 3
11745: PUSH
11746: EMPTY
11747: LIST
11748: LIST
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PPUSH
11754: CALL_OW 69
11758: IFFALSE 11802
11760: GO 11762
11762: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11763: LD_STRING CVulc6
11765: PPUSH
11766: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11770: LD_INT 52500
11772: PUSH
11773: LD_INT 47250
11775: PUSH
11776: LD_INT 42000
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: LIST
11783: PUSH
11784: LD_OWVAR 67
11788: ARRAY
11789: PPUSH
11790: CALL_OW 67
// ru_can_attack := true ;
11794: LD_ADDR_EXP 3
11798: PUSH
11799: LD_INT 1
11801: ST_TO_ADDR
// end ;
11802: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11803: LD_INT 50
11805: PPUSH
11806: CALL_OW 255
11810: PUSH
11811: LD_INT 1
11813: EQUAL
11814: PUSH
11815: LD_INT 22
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 2
11827: PUSH
11828: LD_INT 30
11830: PUSH
11831: LD_INT 3
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: LD_INT 30
11840: PUSH
11841: LD_INT 1
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: OR
11862: IFFALSE 12096
11864: GO 11866
11866: DISABLE
11867: LD_INT 0
11869: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11870: LD_STRING CVulc2
11872: PPUSH
11873: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11877: LD_ADDR_VAR 0 1
11881: PUSH
11882: LD_INT 22
11884: PUSH
11885: LD_INT 1
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 25
11894: PUSH
11895: LD_INT 2
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 69
11910: PUSH
11911: LD_EXP 19
11915: DIFF
11916: ST_TO_ADDR
// DialogueOn ;
11917: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_INT 1
11935: ARRAY
11936: PPUSH
11937: CALL_OW 258
11941: PUSH
11942: LD_INT 1
11944: EQUAL
11945: IFFALSE 11965
// Say ( speaker [ 1 ] , VDb-1 ) else
11947: LD_VAR 0 1
11951: PUSH
11952: LD_INT 1
11954: ARRAY
11955: PPUSH
11956: LD_STRING VDb-1
11958: PPUSH
11959: CALL_OW 88
11963: GO 11981
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11965: LD_VAR 0 1
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PPUSH
11974: LD_STRING VDbf-1
11976: PPUSH
11977: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11981: LD_INT 10
11983: PPUSH
11984: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11988: LD_VAR 0 1
11992: PUSH
11993: LD_INT 1
11995: ARRAY
11996: PPUSH
11997: CALL_OW 258
12001: PUSH
12002: LD_INT 1
12004: EQUAL
12005: IFFALSE 12025
// Say ( speaker [ 1 ] , VDb-2 ) else
12007: LD_VAR 0 1
12011: PUSH
12012: LD_INT 1
12014: ARRAY
12015: PPUSH
12016: LD_STRING VDb-2
12018: PPUSH
12019: CALL_OW 88
12023: GO 12041
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12025: LD_VAR 0 1
12029: PUSH
12030: LD_INT 1
12032: ARRAY
12033: PPUSH
12034: LD_STRING VDbf-2
12036: PPUSH
12037: CALL_OW 88
// DWait ( 0 0$01 ) ;
12041: LD_INT 35
12043: PPUSH
12044: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12048: LD_EXP 19
12052: PPUSH
12053: LD_STRING VDb-com1
12055: PPUSH
12056: CALL_OW 88
// DialogueOff ;
12060: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12064: LD_INT 44100
12066: PUSH
12067: LD_INT 36750
12069: PUSH
12070: LD_INT 31500
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: PUSH
12078: LD_OWVAR 67
12082: ARRAY
12083: PPUSH
12084: CALL_OW 67
// ru_can_attack := true ;
12088: LD_ADDR_EXP 3
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// end ;
12096: PPOPN 1
12098: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12099: LD_INT 22
12101: PUSH
12102: LD_INT 7
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PUSH
12109: LD_INT 30
12111: PUSH
12112: LD_INT 3
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PPUSH
12123: CALL_OW 69
12127: IFFALSE 12164
12129: GO 12131
12131: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12132: LD_INT 42000
12134: PUSH
12135: LD_INT 34650
12137: PUSH
12138: LD_INT 29400
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: LIST
12145: PUSH
12146: LD_OWVAR 67
12150: ARRAY
12151: PPUSH
12152: CALL_OW 67
// ru_can_attack := true ;
12156: LD_ADDR_EXP 3
12160: PUSH
12161: LD_INT 1
12163: ST_TO_ADDR
// end ;
12164: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12165: LD_INT 58
12167: PPUSH
12168: CALL_OW 255
12172: PUSH
12173: LD_INT 1
12175: EQUAL
12176: IFFALSE 12383
12178: GO 12180
12180: DISABLE
12181: LD_INT 0
12183: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12184: LD_ADDR_VAR 0 1
12188: PUSH
12189: LD_INT 22
12191: PUSH
12192: LD_INT 1
12194: PUSH
12195: EMPTY
12196: LIST
12197: LIST
12198: PUSH
12199: LD_INT 25
12201: PUSH
12202: LD_INT 2
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: PUSH
12209: EMPTY
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: ST_TO_ADDR
// DialogueOn ;
12218: CALL_OW 6
// if speaker then
12222: LD_VAR 0 1
12226: IFFALSE 12281
// if GetSex ( speaker [ 1 ] ) = sex_male then
12228: LD_VAR 0 1
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: CALL_OW 258
12241: PUSH
12242: LD_INT 1
12244: EQUAL
12245: IFFALSE 12265
// Say ( speaker [ 1 ] , VDe-1 ) else
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: ARRAY
12255: PPUSH
12256: LD_STRING VDe-1
12258: PPUSH
12259: CALL_OW 88
12263: GO 12281
// Say ( speaker [ 1 ] , VDef-1 ) ;
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING VDef-1
12276: PPUSH
12277: CALL_OW 88
// case Query ( SibNote ) of 1 :
12281: LD_STRING SibNote
12283: PPUSH
12284: CALL_OW 97
12288: PUSH
12289: LD_INT 1
12291: DOUBLE
12292: EQUAL
12293: IFTRUE 12297
12295: GO 12300
12297: POP
// ; end ;
12298: GO 12301
12300: POP
// if speaker then
12301: LD_VAR 0 1
12305: IFFALSE 12360
// if GetSex ( speaker [ 1 ] ) = sex_male then
12307: LD_VAR 0 1
12311: PUSH
12312: LD_INT 1
12314: ARRAY
12315: PPUSH
12316: CALL_OW 258
12320: PUSH
12321: LD_INT 1
12323: EQUAL
12324: IFFALSE 12344
// Say ( speaker [ 1 ] , VDe-2 ) else
12326: LD_VAR 0 1
12330: PUSH
12331: LD_INT 1
12333: ARRAY
12334: PPUSH
12335: LD_STRING VDe-2
12337: PPUSH
12338: CALL_OW 88
12342: GO 12360
// Say ( speaker [ 1 ] , VDef-2 ) ;
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 1
12351: ARRAY
12352: PPUSH
12353: LD_STRING VDef-2
12355: PPUSH
12356: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12360: LD_EXP 19
12364: PPUSH
12365: LD_STRING VDc-4
12367: PPUSH
12368: CALL_OW 88
// DialogueOff ;
12372: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12376: LD_STRING CVulc3
12378: PPUSH
12379: CALL_OW 337
// end ;
12383: PPOPN 1
12385: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12386: LD_OWVAR 2
12390: PUSH
12391: LD_INT 1
12393: EQUAL
12394: PUSH
12395: LD_INT 22
12397: PUSH
12398: LD_INT 1
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: LD_INT 30
12407: PUSH
12408: LD_INT 3
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PPUSH
12419: CALL_OW 69
12423: PUSH
12424: LD_INT 0
12426: GREATER
12427: AND
12428: IFFALSE 12862
12430: GO 12432
12432: DISABLE
12433: LD_INT 0
12435: PPUSH
12436: PPUSH
12437: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12438: LD_INT 245
12440: PPUSH
12441: LD_INT 1295
12443: PPUSH
12444: CALL_OW 12
12448: PPUSH
12449: CALL_OW 67
// DialogueOn ;
12453: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12457: LD_EXP 22
12461: PPUSH
12462: LD_STRING VDG-1
12464: PPUSH
12465: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12469: LD_EXP 19
12473: PPUSH
12474: LD_STRING VDc-5
12476: PPUSH
12477: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12481: LD_EXP 22
12485: PPUSH
12486: LD_STRING VDG-2
12488: PPUSH
12489: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12493: LD_EXP 19
12497: PPUSH
12498: LD_STRING VDc-6
12500: PPUSH
12501: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12505: LD_EXP 22
12509: PPUSH
12510: LD_STRING VDG-3
12512: PPUSH
12513: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12517: LD_EXP 19
12521: PPUSH
12522: LD_STRING VDc-7
12524: PPUSH
12525: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12529: LD_EXP 22
12533: PPUSH
12534: LD_STRING VDG-4
12536: PPUSH
12537: CALL_OW 94
// DialogueOff ;
12541: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12545: LD_STRING CVulc4
12547: PPUSH
12548: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12552: LD_INT 18900
12554: PUSH
12555: LD_INT 21000
12557: PUSH
12558: LD_INT 23100
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: PUSH
12566: LD_OWVAR 67
12570: ARRAY
12571: PPUSH
12572: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12576: LD_ADDR_VAR 0 1
12580: PUSH
12581: DOUBLE
12582: LD_INT 1
12584: DEC
12585: ST_TO_ADDR
12586: LD_INT 4
12588: PUSH
12589: LD_INT 5
12591: PUSH
12592: LD_INT 6
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: LIST
12599: PUSH
12600: LD_OWVAR 67
12604: ARRAY
12605: PUSH
12606: FOR_TO
12607: IFFALSE 12851
// begin uc_side := 1 ;
12609: LD_ADDR_OWVAR 20
12613: PUSH
12614: LD_INT 1
12616: ST_TO_ADDR
// uc_nation := 1 ;
12617: LD_ADDR_OWVAR 21
12621: PUSH
12622: LD_INT 1
12624: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12625: LD_INT 0
12627: PPUSH
12628: LD_INT 1
12630: PPUSH
12631: LD_INT 4
12633: PPUSH
12634: CALL_OW 12
12638: PPUSH
12639: LD_EXP 21
12643: PPUSH
12644: CALL_OW 380
// un := CreateHuman ;
12648: LD_ADDR_VAR 0 2
12652: PUSH
12653: CALL_OW 44
12657: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12658: LD_VAR 0 2
12662: PPUSH
12663: LD_INT 2
12665: PPUSH
12666: CALL_OW 233
// if GetClass ( un ) = 3 then
12670: LD_VAR 0 2
12674: PPUSH
12675: CALL_OW 257
12679: PUSH
12680: LD_INT 3
12682: EQUAL
12683: IFFALSE 12834
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12685: LD_ADDR_OWVAR 37
12689: PUSH
12690: LD_INT 2
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: LD_VAR 0 1
12704: PUSH
12705: LD_INT 2
12707: MOD
12708: ARRAY
12709: ST_TO_ADDR
// vc_engine := engine_combustion ;
12710: LD_ADDR_OWVAR 39
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// vc_control := control_manual ;
12718: LD_ADDR_OWVAR 38
12722: PUSH
12723: LD_INT 1
12725: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12726: LD_ADDR_OWVAR 40
12730: PUSH
12731: LD_INT 9
12733: PUSH
12734: LD_INT 9
12736: PUSH
12737: LD_INT 5
12739: PUSH
12740: LD_INT 11
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: PUSH
12749: LD_INT 1
12751: PPUSH
12752: LD_INT 4
12754: PPUSH
12755: CALL_OW 12
12759: ARRAY
12760: ST_TO_ADDR
// veh := CreateVehicle ;
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: CALL_OW 45
12770: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12771: LD_VAR 0 3
12775: PPUSH
12776: LD_INT 2
12778: PPUSH
12779: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12783: LD_VAR 0 3
12787: PPUSH
12788: LD_INT 77
12790: PPUSH
12791: LD_INT 88
12793: PPUSH
12794: CALL_OW 12
12798: PPUSH
12799: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12803: LD_VAR 0 3
12807: PPUSH
12808: LD_INT 1
12810: PPUSH
12811: LD_INT 0
12813: PPUSH
12814: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12818: LD_VAR 0 2
12822: PPUSH
12823: LD_VAR 0 3
12827: PPUSH
12828: CALL_OW 52
// end else
12832: GO 12849
// PlaceUnitArea ( un , start_north , false ) ;
12834: LD_VAR 0 2
12838: PPUSH
12839: LD_INT 1
12841: PPUSH
12842: LD_INT 0
12844: PPUSH
12845: CALL_OW 49
// end ;
12849: GO 12606
12851: POP
12852: POP
// CenterNowOnUnits ( un ) ;
12853: LD_VAR 0 2
12857: PPUSH
12858: CALL_OW 87
// end ;
12862: PPOPN 3
12864: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12865: LD_INT 21
12867: PPUSH
12868: LD_INT 22
12870: PUSH
12871: LD_OWVAR 2
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 70
12884: IFFALSE 13205
12886: GO 12888
12888: DISABLE
12889: LD_INT 0
12891: PPUSH
12892: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12893: LD_ADDR_VAR 0 2
12897: PUSH
12898: LD_INT 22
12900: PUSH
12901: LD_OWVAR 2
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 2
12912: PUSH
12913: LD_INT 25
12915: PUSH
12916: LD_INT 1
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: LD_INT 25
12925: PUSH
12926: LD_INT 2
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 25
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 4
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: PUSH
12969: LD_EXP 10
12973: DIFF
12974: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12975: LD_ADDR_VAR 0 1
12979: PUSH
12980: LD_VAR 0 2
12984: PPUSH
12985: LD_INT 112
12987: PPUSH
12988: LD_INT 67
12990: PPUSH
12991: CALL_OW 73
12995: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12996: LD_VAR 0 1
13000: PPUSH
13001: CALL_OW 255
13005: PUSH
13006: LD_INT 7
13008: EQUAL
13009: IFFALSE 13052
// if GetSex ( un ) = sex_male then
13011: LD_VAR 0 1
13015: PPUSH
13016: CALL_OW 258
13020: PUSH
13021: LD_INT 1
13023: EQUAL
13024: IFFALSE 13040
// Say ( un , VD-find-al ) else
13026: LD_VAR 0 1
13030: PPUSH
13031: LD_STRING VD-find-al
13033: PPUSH
13034: CALL_OW 88
13038: GO 13052
// Say ( un , VD-find-al-f ) ;
13040: LD_VAR 0 1
13044: PPUSH
13045: LD_STRING VD-find-al-f
13047: PPUSH
13048: CALL_OW 88
// if GetSide ( un ) = 2 then
13052: LD_VAR 0 1
13056: PPUSH
13057: CALL_OW 255
13061: PUSH
13062: LD_INT 2
13064: EQUAL
13065: IFFALSE 13108
// if GetSex ( un ) = sex_male then
13067: LD_VAR 0 1
13071: PPUSH
13072: CALL_OW 258
13076: PUSH
13077: LD_INT 1
13079: EQUAL
13080: IFFALSE 13096
// Say ( un , VD-find-ar ) else
13082: LD_VAR 0 1
13086: PPUSH
13087: LD_STRING VD-find-ar
13089: PPUSH
13090: CALL_OW 88
13094: GO 13108
// Say ( un , VD-find-ar-f ) ;
13096: LD_VAR 0 1
13100: PPUSH
13101: LD_STRING VD-find-ar-f
13103: PPUSH
13104: CALL_OW 88
// if GetSide ( un ) = 1 then
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 255
13117: PUSH
13118: LD_INT 1
13120: EQUAL
13121: IFFALSE 13188
// begin if GetSex ( un ) = sex_male then
13123: LD_VAR 0 1
13127: PPUSH
13128: CALL_OW 258
13132: PUSH
13133: LD_INT 1
13135: EQUAL
13136: IFFALSE 13164
// begin Say ( un , VD-find-us ) ;
13138: LD_VAR 0 1
13142: PPUSH
13143: LD_STRING VD-find-us
13145: PPUSH
13146: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13150: LD_VAR 0 1
13154: PPUSH
13155: LD_STRING VD-find-us2
13157: PPUSH
13158: CALL_OW 88
// end else
13162: GO 13188
// begin Say ( un , VD-find-us-f ) ;
13164: LD_VAR 0 1
13168: PPUSH
13169: LD_STRING VD-find-us-f
13171: PPUSH
13172: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13176: LD_VAR 0 1
13180: PPUSH
13181: LD_STRING VD-find-us2-f
13183: PPUSH
13184: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13188: LD_INT 10
13190: PPUSH
13191: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13195: LD_INT 112
13197: PPUSH
13198: LD_INT 67
13200: PPUSH
13201: CALL_OW 86
// end ;
13205: PPOPN 2
13207: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13208: LD_EXP 7
13212: IFFALSE 13714
13214: GO 13216
13216: DISABLE
13217: LD_INT 0
13219: PPUSH
// begin if your_side = 1 then
13220: LD_OWVAR 2
13224: PUSH
13225: LD_INT 1
13227: EQUAL
13228: IFFALSE 13409
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13230: LD_ADDR_VAR 0 1
13234: PUSH
13235: LD_INT 22
13237: PUSH
13238: LD_INT 1
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: LD_INT 25
13247: PUSH
13248: LD_INT 4
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 19
13268: DIFF
13269: ST_TO_ADDR
// if not speaker then
13270: LD_VAR 0 1
13274: NOT
13275: IFFALSE 13279
// exit ;
13277: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13279: LD_VAR 0 1
13283: PUSH
13284: LD_INT 1
13286: ARRAY
13287: PPUSH
13288: CALL_OW 258
13292: PUSH
13293: LD_INT 1
13295: EQUAL
13296: IFFALSE 13316
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13298: LD_VAR 0 1
13302: PUSH
13303: LD_INT 1
13305: ARRAY
13306: PPUSH
13307: LD_STRING VD-us-sci-art-1
13309: PPUSH
13310: CALL_OW 88
13314: GO 13332
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING VD-us-fsci-art-1
13327: PPUSH
13328: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13332: LD_EXP 19
13336: PPUSH
13337: LD_STRING VDc-art1
13339: PPUSH
13340: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13344: LD_VAR 0 1
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: PPUSH
13353: CALL_OW 258
13357: PUSH
13358: LD_INT 1
13360: EQUAL
13361: IFFALSE 13381
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13363: LD_VAR 0 1
13367: PUSH
13368: LD_INT 1
13370: ARRAY
13371: PPUSH
13372: LD_STRING VD-us-sci-art-2
13374: PPUSH
13375: CALL_OW 88
13379: GO 13397
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13381: LD_VAR 0 1
13385: PUSH
13386: LD_INT 1
13388: ARRAY
13389: PPUSH
13390: LD_STRING VD-us-fsci-art-2
13392: PPUSH
13393: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13397: LD_EXP 19
13401: PPUSH
13402: LD_STRING VDc-art2
13404: PPUSH
13405: CALL_OW 88
// end ; if your_side = 2 then
13409: LD_OWVAR 2
13413: PUSH
13414: LD_INT 2
13416: EQUAL
13417: IFFALSE 13521
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13419: LD_ADDR_VAR 0 1
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_INT 2
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: PUSH
13434: LD_INT 25
13436: PUSH
13437: LD_INT 4
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PPUSH
13448: CALL_OW 69
13452: PUSH
13453: LD_EXP 51
13457: DIFF
13458: ST_TO_ADDR
// if not speaker then
13459: LD_VAR 0 1
13463: NOT
13464: IFFALSE 13468
// exit ;
13466: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13468: LD_VAR 0 1
13472: PUSH
13473: LD_INT 1
13475: ARRAY
13476: PPUSH
13477: CALL_OW 258
13481: PUSH
13482: LD_INT 1
13484: EQUAL
13485: IFFALSE 13505
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13487: LD_VAR 0 1
13491: PUSH
13492: LD_INT 1
13494: ARRAY
13495: PPUSH
13496: LD_STRING VD-ar-sci-art-1
13498: PPUSH
13499: CALL_OW 88
13503: GO 13521
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13505: LD_VAR 0 1
13509: PUSH
13510: LD_INT 1
13512: ARRAY
13513: PPUSH
13514: LD_STRING VD-ar-fsci-art-1
13516: PPUSH
13517: CALL_OW 88
// end ; if your_side = 7 then
13521: LD_OWVAR 2
13525: PUSH
13526: LD_INT 7
13528: EQUAL
13529: IFFALSE 13714
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13531: LD_ADDR_VAR 0 1
13535: PUSH
13536: LD_INT 22
13538: PUSH
13539: LD_INT 7
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 25
13548: PUSH
13549: LD_INT 4
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PUSH
13565: LD_EXP 37
13569: DIFF
13570: ST_TO_ADDR
// if speaker then
13571: LD_VAR 0 1
13575: IFFALSE 13707
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13577: LD_VAR 0 1
13581: PUSH
13582: LD_INT 1
13584: ARRAY
13585: PPUSH
13586: CALL_OW 258
13590: PUSH
13591: LD_INT 1
13593: EQUAL
13594: IFFALSE 13614
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13596: LD_VAR 0 1
13600: PUSH
13601: LD_INT 1
13603: ARRAY
13604: PPUSH
13605: LD_STRING VD-al-sci-art-1
13607: PPUSH
13608: CALL_OW 88
13612: GO 13630
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13614: LD_VAR 0 1
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: PPUSH
13623: LD_STRING VD-al-fsci-art-1
13625: PPUSH
13626: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13630: LD_EXP 37
13634: PPUSH
13635: LD_STRING VPd-art-1
13637: PPUSH
13638: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13642: LD_VAR 0 1
13646: PUSH
13647: LD_INT 1
13649: ARRAY
13650: PPUSH
13651: CALL_OW 258
13655: PUSH
13656: LD_INT 1
13658: EQUAL
13659: IFFALSE 13679
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13661: LD_VAR 0 1
13665: PUSH
13666: LD_INT 1
13668: ARRAY
13669: PPUSH
13670: LD_STRING VD-al-sci-art-2
13672: PPUSH
13673: CALL_OW 88
13677: GO 13695
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13679: LD_VAR 0 1
13683: PUSH
13684: LD_INT 1
13686: ARRAY
13687: PPUSH
13688: LD_STRING VD-al-fsci-art-2
13690: PPUSH
13691: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13695: LD_EXP 37
13699: PPUSH
13700: LD_STRING VPd-art-2
13702: PPUSH
13703: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13707: LD_STRING CVulc7out
13709: PPUSH
13710: CALL_OW 337
// end ; end ;
13714: PPOPN 1
13716: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13717: LD_INT 8
13719: PPUSH
13720: LD_INT 22
13722: PUSH
13723: LD_OWVAR 2
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: PPUSH
13732: CALL_OW 69
13736: PPUSH
13737: LD_INT 8
13739: PPUSH
13740: CALL 2145 0 2
13744: PPUSH
13745: CALL_OW 292
13749: IFFALSE 13892
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin if your_side = 1 then
13757: LD_OWVAR 2
13761: PUSH
13762: LD_INT 1
13764: EQUAL
13765: IFFALSE 13848
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13767: LD_ADDR_VAR 0 1
13771: PUSH
13772: LD_INT 22
13774: PUSH
13775: LD_INT 1
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_EXP 19
13791: DIFF
13792: ST_TO_ADDR
// if speaker then
13793: LD_VAR 0 1
13797: IFFALSE 13848
// if GetSex ( speaker [ 1 ] ) then
13799: LD_VAR 0 1
13803: PUSH
13804: LD_INT 1
13806: ARRAY
13807: PPUSH
13808: CALL_OW 258
13812: IFFALSE 13832
// Say ( speaker [ 1 ] , VD-legion-us ) else
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 1
13821: ARRAY
13822: PPUSH
13823: LD_STRING VD-legion-us
13825: PPUSH
13826: CALL_OW 88
13830: GO 13848
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13832: LD_VAR 0 1
13836: PUSH
13837: LD_INT 1
13839: ARRAY
13840: PPUSH
13841: LD_STRING VD-legion-us-f
13843: PPUSH
13844: CALL_OW 88
// end ; if your_side = 2 then
13848: LD_OWVAR 2
13852: PUSH
13853: LD_INT 2
13855: EQUAL
13856: IFFALSE 13870
// Say ( ar_commander , VD-legion-ar ) ;
13858: LD_EXP 51
13862: PPUSH
13863: LD_STRING VD-legion-ar
13865: PPUSH
13866: CALL_OW 88
// if your_side = 7 then
13870: LD_OWVAR 2
13874: PUSH
13875: LD_INT 7
13877: EQUAL
13878: IFFALSE 13892
// Say ( al_commander , VD-legion-al ) ;
13880: LD_EXP 37
13884: PPUSH
13885: LD_STRING VD-legion-al
13887: PPUSH
13888: CALL_OW 88
// end ;
13892: PPOPN 1
13894: END
// every 0 0$01 trigger mine_vulc do
13895: LD_EXP 12
13899: IFFALSE 13916
13901: GO 13903
13903: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13904: LD_EXP 10
13908: PPUSH
13909: LD_STRING VD-vulc-mines
13911: PPUSH
13912: CALL_OW 88
// end ;
13916: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13917: LD_OWVAR 67
13921: PUSH
13922: LD_INT 1
13924: GREATER
13925: IFFALSE 14044
13927: GO 13929
13929: DISABLE
13930: LD_INT 0
13932: PPUSH
13933: PPUSH
13934: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13935: LD_ADDR_VAR 0 1
13939: PUSH
13940: LD_INT 123
13942: PUSH
13943: LD_INT 95
13945: PUSH
13946: LD_INT 119
13948: PUSH
13949: LD_INT 89
13951: PUSH
13952: LD_INT 115
13954: PUSH
13955: LD_INT 81
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: ST_TO_ADDR
// p := 1 ;
13966: LD_ADDR_VAR 0 2
13970: PUSH
13971: LD_INT 1
13973: ST_TO_ADDR
// for i = 1 to 3 do
13974: LD_ADDR_VAR 0 3
13978: PUSH
13979: DOUBLE
13980: LD_INT 1
13982: DEC
13983: ST_TO_ADDR
13984: LD_INT 3
13986: PUSH
13987: FOR_TO
13988: IFFALSE 14042
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13990: LD_VAR 0 1
13994: PUSH
13995: LD_VAR 0 2
13999: ARRAY
14000: PPUSH
14001: LD_VAR 0 1
14005: PUSH
14006: LD_VAR 0 2
14010: PUSH
14011: LD_INT 1
14013: PLUS
14014: ARRAY
14015: PPUSH
14016: LD_INT 8
14018: PPUSH
14019: LD_INT 0
14021: PPUSH
14022: CALL_OW 454
// p := p + 2 ;
14026: LD_ADDR_VAR 0 2
14030: PUSH
14031: LD_VAR 0 2
14035: PUSH
14036: LD_INT 2
14038: PLUS
14039: ST_TO_ADDR
// end ;
14040: GO 13987
14042: POP
14043: POP
// end ;
14044: PPOPN 3
14046: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14047: LD_OWVAR 67
14051: PUSH
14052: LD_INT 1
14054: GREATER
14055: PUSH
14056: LD_INT 22
14058: PPUSH
14059: LD_INT 22
14061: PUSH
14062: LD_OWVAR 2
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PPUSH
14071: CALL_OW 70
14075: AND
14076: IFFALSE 14280
14078: GO 14080
14080: DISABLE
14081: LD_INT 0
14083: PPUSH
14084: PPUSH
14085: PPUSH
// begin enable ;
14086: ENABLE
// p := 1 ;
14087: LD_ADDR_VAR 0 1
14091: PUSH
14092: LD_INT 1
14094: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14095: LD_ADDR_VAR 0 3
14099: PUSH
14100: LD_INT 123
14102: PUSH
14103: LD_INT 95
14105: PUSH
14106: LD_INT 119
14108: PUSH
14109: LD_INT 89
14111: PUSH
14112: LD_INT 115
14114: PUSH
14115: LD_INT 81
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: ST_TO_ADDR
// for i = 1 to 3 do
14126: LD_ADDR_VAR 0 2
14130: PUSH
14131: DOUBLE
14132: LD_INT 1
14134: DEC
14135: ST_TO_ADDR
14136: LD_INT 3
14138: PUSH
14139: FOR_TO
14140: IFFALSE 14278
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14142: LD_VAR 0 3
14146: PUSH
14147: LD_VAR 0 1
14151: ARRAY
14152: PPUSH
14153: LD_VAR 0 3
14157: PUSH
14158: LD_VAR 0 1
14162: PUSH
14163: LD_INT 1
14165: PLUS
14166: ARRAY
14167: PPUSH
14168: CALL_OW 428
14172: PUSH
14173: LD_INT 0
14175: GREATER
14176: IFFALSE 14262
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14178: LD_VAR 0 3
14182: PUSH
14183: LD_VAR 0 1
14187: ARRAY
14188: PPUSH
14189: LD_VAR 0 3
14193: PUSH
14194: LD_VAR 0 1
14198: PUSH
14199: LD_INT 1
14201: PLUS
14202: ARRAY
14203: PPUSH
14204: CALL_OW 428
14208: PPUSH
14209: CALL_OW 255
14213: PUSH
14214: LD_OWVAR 2
14218: EQUAL
14219: IFFALSE 14262
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14221: LD_VAR 0 3
14225: PUSH
14226: LD_VAR 0 1
14230: ARRAY
14231: PPUSH
14232: LD_VAR 0 3
14236: PUSH
14237: LD_VAR 0 1
14241: PUSH
14242: LD_INT 1
14244: PLUS
14245: ARRAY
14246: PPUSH
14247: LD_INT 8
14249: PPUSH
14250: CALL_OW 456
// mine_vulc := true ;
14254: LD_ADDR_EXP 12
14258: PUSH
14259: LD_INT 1
14261: ST_TO_ADDR
// end ; p := p + 2 ;
14262: LD_ADDR_VAR 0 1
14266: PUSH
14267: LD_VAR 0 1
14271: PUSH
14272: LD_INT 2
14274: PLUS
14275: ST_TO_ADDR
// end ;
14276: GO 14139
14278: POP
14279: POP
// end ;
14280: PPOPN 3
14282: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14283: LD_INT 22
14285: PUSH
14286: LD_INT 3
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: PPUSH
14293: CALL_OW 69
14297: PUSH
14298: LD_INT 0
14300: EQUAL
14301: PUSH
14302: LD_OWVAR 2
14306: PUSH
14307: LD_INT 2
14309: NONEQUAL
14310: AND
14311: IFFALSE 14320
14313: GO 14315
14315: DISABLE
// Win ;
14316: CALL 14377 0 0
14320: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14321: LD_INT 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 8
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 22
14336: PUSH
14337: LD_INT 3
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: PPUSH
14349: CALL_OW 69
14353: PUSH
14354: LD_INT 0
14356: EQUAL
14357: PUSH
14358: LD_OWVAR 2
14362: PUSH
14363: LD_INT 2
14365: EQUAL
14366: AND
14367: IFFALSE 14376
14369: GO 14371
14371: DISABLE
// Win ;
14372: CALL 14377 0 0
14376: END
// function Win ; var points ; begin
14377: LD_INT 0
14379: PPUSH
14380: PPUSH
// case Query ( VulcWin ) of 1 :
14381: LD_STRING VulcWin
14383: PPUSH
14384: CALL_OW 97
14388: PUSH
14389: LD_INT 1
14391: DOUBLE
14392: EQUAL
14393: IFTRUE 14397
14395: GO 14400
14397: POP
// ; end ;
14398: GO 14401
14400: POP
// if medal_enabled then
14401: LD_EXP 13
14405: IFFALSE 14419
// AddMedal ( vulc_1 , 1 ) else
14407: LD_STRING vulc_1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: CALL_OW 101
14417: GO 14430
// AddMedal ( vulc_1 , - 1 ) ;
14419: LD_STRING vulc_1
14421: PPUSH
14422: LD_INT 1
14424: NEG
14425: PPUSH
14426: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14430: LD_INT 22
14432: PUSH
14433: LD_INT 8
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 69
14444: PUSH
14445: LD_INT 0
14447: EQUAL
14448: IFFALSE 14462
// AddMedal ( vulc_2 , 1 ) else
14450: LD_STRING vulc_2
14452: PPUSH
14453: LD_INT 1
14455: PPUSH
14456: CALL_OW 101
14460: GO 14473
// AddMedal ( vulc_2 , - 1 ) ;
14462: LD_STRING vulc_2
14464: PPUSH
14465: LD_INT 1
14467: NEG
14468: PPUSH
14469: CALL_OW 101
// points := CalculateCommanderPoints ;
14473: LD_ADDR_VAR 0 2
14477: PUSH
14478: CALL 2266 0 0
14482: ST_TO_ADDR
// if points >= 2000 then
14483: LD_VAR 0 2
14487: PUSH
14488: LD_INT 2000
14490: GREATEREQUAL
14491: IFFALSE 14505
// AddMedal ( vulc_3 , 2 ) else
14493: LD_STRING vulc_3
14495: PPUSH
14496: LD_INT 2
14498: PPUSH
14499: CALL_OW 101
14503: GO 14538
// if points >= 0 then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 0
14512: GREATEREQUAL
14513: IFFALSE 14527
// AddMedal ( vulc_3 , 1 ) else
14515: LD_STRING vulc_3
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 101
14525: GO 14538
// AddMedal ( vulc_3 , - 1 ) ;
14527: LD_STRING vulc_3
14529: PPUSH
14530: LD_INT 1
14532: NEG
14533: PPUSH
14534: CALL_OW 101
// GiveMedals ( MAIN ) ;
14538: LD_STRING MAIN
14540: PPUSH
14541: CALL_OW 102
// YouWin ;
14545: CALL_OW 103
// end ; end_of_file
14549: LD_VAR 0 1
14553: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14554: LD_INT 13
14556: PPUSH
14557: LD_INT 21
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PPUSH
14567: CALL_OW 70
14571: PUSH
14572: LD_INT 0
14574: GREATER
14575: IFFALSE 14642
14577: GO 14579
14579: DISABLE
14580: LD_INT 0
14582: PPUSH
14583: PPUSH
// begin enable ;
14584: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_INT 13
14592: PPUSH
14593: LD_INT 21
14595: PUSH
14596: LD_INT 1
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 70
14607: PUSH
14608: FOR_IN
14609: IFFALSE 14640
// if GetLives ( i ) > 4 then
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 256
14620: PUSH
14621: LD_INT 4
14623: GREATER
14624: IFFALSE 14638
// SetLives ( i , 4 ) ;
14626: LD_VAR 0 1
14630: PPUSH
14631: LD_INT 4
14633: PPUSH
14634: CALL_OW 234
14638: GO 14608
14640: POP
14641: POP
// end ;
14642: PPOPN 2
14644: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14645: LD_VAR 0 1
14649: PPUSH
14650: CALL_OW 255
14654: PUSH
14655: LD_OWVAR 2
14659: EQUAL
14660: IFFALSE 14670
// player_res_art := true ;
14662: LD_ADDR_EXP 6
14666: PUSH
14667: LD_INT 1
14669: ST_TO_ADDR
// end ;
14670: PPOPN 1
14672: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14673: LD_INT 22
14675: PUSH
14676: LD_OWVAR 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: LD_INT 2
14687: PUSH
14688: LD_INT 30
14690: PUSH
14691: LD_INT 8
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: LD_INT 30
14700: PUSH
14701: LD_INT 11
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: PPUSH
14717: CALL_OW 69
14721: PUSH
14722: LD_EXP 6
14726: AND
14727: IFFALSE 15071
14729: GO 14731
14731: DISABLE
14732: LD_INT 0
14734: PPUSH
14735: PPUSH
14736: PPUSH
// begin enable ;
14737: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14738: LD_ADDR_VAR 0 1
14742: PUSH
14743: LD_INT 1
14745: PPUSH
14746: CALL_OW 469
14750: PUSH
14751: LD_INT 1
14753: ARRAY
14754: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14755: LD_ADDR_VAR 0 2
14759: PUSH
14760: LD_INT 1
14762: PPUSH
14763: CALL_OW 469
14767: PUSH
14768: LD_INT 2
14770: ARRAY
14771: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14772: LD_ADDR_VAR 0 3
14776: PUSH
14777: LD_INT 22
14779: PUSH
14780: LD_OWVAR 2
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PUSH
14789: LD_INT 2
14791: PUSH
14792: LD_INT 30
14794: PUSH
14795: LD_INT 8
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 30
14804: PUSH
14805: LD_INT 11
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: EMPTY
14813: LIST
14814: LIST
14815: LIST
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: PPUSH
14821: CALL_OW 69
14825: PPUSH
14826: LD_VAR 0 1
14830: PPUSH
14831: LD_VAR 0 2
14835: PPUSH
14836: CALL_OW 73
14840: ST_TO_ADDR
// if player_artifact_ready = false then
14841: LD_EXP 7
14845: PUSH
14846: LD_INT 0
14848: EQUAL
14849: IFFALSE 14955
// if GetDistUnitXY ( lab , x , y ) < 6 then
14851: LD_VAR 0 3
14855: PPUSH
14856: LD_VAR 0 1
14860: PPUSH
14861: LD_VAR 0 2
14865: PPUSH
14866: CALL_OW 297
14870: PUSH
14871: LD_INT 6
14873: LESS
14874: IFFALSE 14935
// begin if BuildingStatus ( lab ) = bs_idle then
14876: LD_VAR 0 3
14880: PPUSH
14881: CALL_OW 461
14885: PUSH
14886: LD_INT 2
14888: EQUAL
14889: IFFALSE 14913
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14891: LD_OWVAR 2
14895: PPUSH
14896: LD_INT 1
14898: PPUSH
14899: LD_INT 2
14901: PPUSH
14902: LD_VAR 0 3
14906: PPUSH
14907: CALL_OW 468
14911: GO 14933
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14913: LD_OWVAR 2
14917: PPUSH
14918: LD_INT 1
14920: PPUSH
14921: LD_INT 1
14923: PPUSH
14924: LD_VAR 0 3
14928: PPUSH
14929: CALL_OW 468
// end else
14933: GO 14955
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14935: LD_OWVAR 2
14939: PPUSH
14940: LD_INT 1
14942: PPUSH
14943: LD_INT 1
14945: PPUSH
14946: LD_VAR 0 3
14950: PPUSH
14951: CALL_OW 468
// if player_artifact_ready then
14955: LD_EXP 7
14959: IFFALSE 15071
// if GetDistUnitXY ( lab , x , y ) < 6 then
14961: LD_VAR 0 3
14965: PPUSH
14966: LD_VAR 0 1
14970: PPUSH
14971: LD_VAR 0 2
14975: PPUSH
14976: CALL_OW 297
14980: PUSH
14981: LD_INT 6
14983: LESS
14984: IFFALSE 15049
// begin if BuildingStatus ( lab ) = bs_idle then
14986: LD_VAR 0 3
14990: PPUSH
14991: CALL_OW 461
14995: PUSH
14996: LD_INT 2
14998: EQUAL
14999: IFFALSE 15025
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
15001: LD_OWVAR 2
15005: PPUSH
15006: LD_EXP 8
15010: PPUSH
15011: LD_INT 4
15013: PPUSH
15014: LD_VAR 0 3
15018: PPUSH
15019: CALL_OW 468
15023: GO 15047
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15025: LD_OWVAR 2
15029: PPUSH
15030: LD_EXP 8
15034: PPUSH
15035: LD_INT 1
15037: PPUSH
15038: LD_VAR 0 3
15042: PPUSH
15043: CALL_OW 468
// end else
15047: GO 15071
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15049: LD_OWVAR 2
15053: PPUSH
15054: LD_EXP 8
15058: PPUSH
15059: LD_INT 1
15061: PPUSH
15062: LD_VAR 0 3
15066: PPUSH
15067: CALL_OW 468
// end ;
15071: PPOPN 3
15073: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15074: LD_INT 0
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
15080: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15081: LD_ADDR_VAR 0 5
15085: PUSH
15086: LD_INT 1
15088: PPUSH
15089: CALL_OW 469
15093: PUSH
15094: LD_INT 1
15096: ARRAY
15097: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15098: LD_ADDR_VAR 0 6
15102: PUSH
15103: LD_INT 1
15105: PPUSH
15106: CALL_OW 469
15110: PUSH
15111: LD_INT 2
15113: ARRAY
15114: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15115: LD_ADDR_VAR 0 8
15119: PUSH
15120: LD_INT 22
15122: PUSH
15123: LD_OWVAR 2
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PUSH
15132: LD_INT 2
15134: PUSH
15135: LD_INT 30
15137: PUSH
15138: LD_INT 8
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 30
15147: PUSH
15148: LD_INT 11
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: LIST
15159: PUSH
15160: EMPTY
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PPUSH
15169: LD_VAR 0 5
15173: PPUSH
15174: LD_VAR 0 6
15178: PPUSH
15179: CALL_OW 73
15183: ST_TO_ADDR
// if icon = art_exp_left then
15184: LD_VAR 0 2
15188: PUSH
15189: LD_INT 1
15191: EQUAL
15192: IFFALSE 15231
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15194: LD_VAR 0 8
15198: PPUSH
15199: LD_EXP 9
15203: PPUSH
15204: LD_INT 1
15206: PPUSH
15207: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15211: LD_OWVAR 2
15215: PPUSH
15216: LD_INT 1
15218: PPUSH
15219: LD_INT 0
15221: PPUSH
15222: LD_VAR 0 8
15226: PPUSH
15227: CALL_OW 468
// end ; if icon = art_icon then
15231: LD_VAR 0 2
15235: PUSH
15236: LD_EXP 8
15240: EQUAL
15241: IFFALSE 15455
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15243: LD_VAR 0 3
15247: PUSH
15248: LD_INT 21
15250: PUSH
15251: LD_INT 3
15253: PUSH
15254: EMPTY
15255: LIST
15256: LIST
15257: PPUSH
15258: CALL_OW 69
15262: IN
15263: IFFALSE 15455
// begin side := GetSide ( cr1 ) ;
15265: LD_ADDR_VAR 0 9
15269: PUSH
15270: LD_VAR 0 3
15274: PPUSH
15275: CALL_OW 255
15279: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15280: LD_INT 22
15282: PUSH
15283: LD_VAR 0 9
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 30
15294: PUSH
15295: LD_INT 28
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PPUSH
15306: CALL_OW 69
15310: PUSH
15311: LD_INT 0
15313: GREATER
15314: IFFALSE 15455
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15316: LD_ADDR_VAR 0 7
15320: PUSH
15321: LD_INT 22
15323: PUSH
15324: LD_VAR 0 9
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 2
15335: PUSH
15336: LD_INT 30
15338: PUSH
15339: LD_INT 26
15341: PUSH
15342: EMPTY
15343: LIST
15344: LIST
15345: PUSH
15346: LD_INT 30
15348: PUSH
15349: LD_INT 27
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: PUSH
15356: LD_INT 30
15358: PUSH
15359: LD_INT 28
15361: PUSH
15362: EMPTY
15363: LIST
15364: LIST
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: PUSH
15372: EMPTY
15373: LIST
15374: LIST
15375: PPUSH
15376: CALL_OW 69
15380: PUSH
15381: FOR_IN
15382: IFFALSE 15398
// SetLives ( i , 1 ) ;
15384: LD_VAR 0 7
15388: PPUSH
15389: LD_INT 1
15391: PPUSH
15392: CALL_OW 234
15396: GO 15381
15398: POP
15399: POP
// player_res_art := false ;
15400: LD_ADDR_EXP 6
15404: PUSH
15405: LD_INT 0
15407: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15408: LD_OWVAR 2
15412: PPUSH
15413: LD_EXP 8
15417: PPUSH
15418: LD_INT 1
15420: PPUSH
15421: LD_VAR 0 8
15425: PPUSH
15426: CALL_OW 468
// Wait ( time_to_reuse ) ;
15430: LD_EXP 11
15434: PPUSH
15435: CALL_OW 67
// player_res_art := true ;
15439: LD_ADDR_EXP 6
15443: PUSH
15444: LD_INT 1
15446: ST_TO_ADDR
// medal_enabled := true ;
15447: LD_ADDR_EXP 13
15451: PUSH
15452: LD_INT 1
15454: ST_TO_ADDR
// end ; end ; end ; end ;
15455: PPOPN 9
15457: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15458: LD_VAR 0 1
15462: PPUSH
15463: CALL_OW 255
15467: PUSH
15468: LD_OWVAR 2
15472: EQUAL
15473: IFFALSE 15510
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15475: LD_OWVAR 2
15479: PPUSH
15480: LD_INT 1
15482: PPUSH
15483: LD_INT 0
15485: PPUSH
15486: LD_VAR 0 1
15490: PPUSH
15491: CALL_OW 468
// player_artifact_ready := true ;
15495: LD_ADDR_EXP 7
15499: PUSH
15500: LD_INT 1
15502: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15503: LD_STRING ArtVulcano
15505: PPUSH
15506: CALL_OW 339
// end ; end ;
15510: PPOPN 1
15512: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15513: LD_OWVAR 2
15517: PPUSH
15518: LD_INT 1
15520: PPUSH
15521: LD_INT 2
15523: PPUSH
15524: LD_VAR 0 1
15528: PPUSH
15529: CALL_OW 468
// end ; end_of_file
15533: PPOPN 2
15535: END
// every 0 0$01 do
15536: GO 15538
15538: DISABLE
// begin enable ;
15539: ENABLE
// Display_Strings := [ #tick , tick ] ;
15540: LD_ADDR_OWVAR 47
15544: PUSH
15545: LD_STRING #tick
15547: PUSH
15548: LD_OWVAR 1
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: ST_TO_ADDR
// end ; end_of_file
15557: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15558: LD_INT 0
15560: PPUSH
15561: PPUSH
15562: PPUSH
15563: PPUSH
15564: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15565: LD_ADDR_EXP 39
15569: PUSH
15570: LD_INT 7
15572: PUSH
15573: LD_INT 6
15575: PUSH
15576: LD_INT 5
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: PUSH
15584: LD_OWVAR 67
15588: ARRAY
15589: ST_TO_ADDR
// al_force := [ ] ;
15590: LD_ADDR_EXP 38
15594: PUSH
15595: EMPTY
15596: ST_TO_ADDR
// RemoveAlliance ;
15597: CALL 15975 0 0
// ResetFog ;
15601: CALL_OW 335
// your_side := 7 ;
15605: LD_ADDR_OWVAR 2
15609: PUSH
15610: LD_INT 7
15612: ST_TO_ADDR
// uc_side := 7 ;
15613: LD_ADDR_OWVAR 20
15617: PUSH
15618: LD_INT 7
15620: ST_TO_ADDR
// hc_gallery :=  ;
15621: LD_ADDR_OWVAR 33
15625: PUSH
15626: LD_STRING 
15628: ST_TO_ADDR
// hc_name :=  ;
15629: LD_ADDR_OWVAR 26
15633: PUSH
15634: LD_STRING 
15636: ST_TO_ADDR
// hc_importance := 0 ;
15637: LD_ADDR_OWVAR 32
15641: PUSH
15642: LD_INT 0
15644: ST_TO_ADDR
// for i = 1 to 17 do
15645: LD_ADDR_VAR 0 2
15649: PUSH
15650: DOUBLE
15651: LD_INT 1
15653: DEC
15654: ST_TO_ADDR
15655: LD_INT 17
15657: PUSH
15658: FOR_TO
15659: IFFALSE 15739
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15661: LD_ADDR_OWVAR 21
15665: PUSH
15666: LD_INT 1
15668: PUSH
15669: LD_INT 3
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: PUSH
15676: LD_INT 1
15678: PPUSH
15679: LD_INT 2
15681: PPUSH
15682: CALL_OW 12
15686: ARRAY
15687: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15688: LD_INT 0
15690: PPUSH
15691: LD_INT 1
15693: PPUSH
15694: LD_INT 4
15696: PPUSH
15697: CALL_OW 12
15701: PPUSH
15702: LD_EXP 39
15706: PPUSH
15707: CALL_OW 380
// un := CreateHuman ;
15711: LD_ADDR_VAR 0 4
15715: PUSH
15716: CALL_OW 44
15720: ST_TO_ADDR
// al_force := al_force ^ un ;
15721: LD_ADDR_EXP 38
15725: PUSH
15726: LD_EXP 38
15730: PUSH
15731: LD_VAR 0 4
15735: ADD
15736: ST_TO_ADDR
// end ;
15737: GO 15658
15739: POP
15740: POP
// hc_importance := 100 ;
15741: LD_ADDR_OWVAR 32
15745: PUSH
15746: LD_INT 100
15748: ST_TO_ADDR
// uc_nation := 1 ;
15749: LD_ADDR_OWVAR 21
15753: PUSH
15754: LD_INT 1
15756: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 1
15762: PPUSH
15763: LD_EXP 39
15767: PPUSH
15768: CALL_OW 380
// al_commander := CreateHuman ;
15772: LD_ADDR_EXP 37
15776: PUSH
15777: CALL_OW 44
15781: ST_TO_ADDR
// player_commander := al_commander ;
15782: LD_ADDR_EXP 10
15786: PUSH
15787: LD_EXP 37
15791: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15792: LD_ADDR_VAR 0 5
15796: PUSH
15797: LD_STRING text
15799: PPUSH
15800: LD_INT 9
15802: PUSH
15803: LD_INT 9
15805: PUSH
15806: LD_INT 8
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: LIST
15813: PUSH
15814: LD_OWVAR 67
15818: ARRAY
15819: PPUSH
15820: LD_INT 9
15822: PUSH
15823: LD_INT 9
15825: PUSH
15826: LD_INT 8
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: PUSH
15834: LD_OWVAR 67
15838: ARRAY
15839: PPUSH
15840: LD_INT -5
15842: PUSH
15843: LD_EXP 37
15847: PUSH
15848: LD_INT -3
15850: PUSH
15851: LD_INT -2
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: LIST
15858: LIST
15859: PUSH
15860: LD_EXP 38
15864: ADD
15865: PPUSH
15866: LD_INT 1
15868: PUSH
15869: LD_INT 3
15871: PUSH
15872: LD_INT 2
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: LD_INT 4
15884: PUSH
15885: LD_INT 1
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: PUSH
15892: LD_INT 9
15894: PUSH
15895: LD_INT 5
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: LIST
15903: LIST
15904: LIST
15905: PPUSH
15906: CALL_OW 42
15910: ST_TO_ADDR
// team := team ^ al_commander ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_VAR 0 5
15920: PUSH
15921: LD_EXP 37
15925: ADD
15926: ST_TO_ADDR
// for i = 1 to team do
15927: LD_ADDR_VAR 0 2
15931: PUSH
15932: DOUBLE
15933: LD_INT 1
15935: DEC
15936: ST_TO_ADDR
15937: LD_VAR 0 5
15941: PUSH
15942: FOR_TO
15943: IFFALSE 15968
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15945: LD_VAR 0 5
15949: PUSH
15950: LD_VAR 0 2
15954: ARRAY
15955: PPUSH
15956: LD_INT 15
15958: PPUSH
15959: LD_INT 0
15961: PPUSH
15962: CALL_OW 49
15966: GO 15942
15968: POP
15969: POP
// end ;
15970: LD_VAR 0 1
15974: RET
// export function RemoveAlliance ; var i ; begin
15975: LD_INT 0
15977: PPUSH
15978: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15979: LD_INT 22
15981: PUSH
15982: LD_INT 7
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: PUSH
15989: LD_INT 30
15991: PUSH
15992: LD_INT 1
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: PUSH
16008: LD_INT 1
16010: ARRAY
16011: PPUSH
16012: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16016: LD_ADDR_VAR 0 2
16020: PUSH
16021: LD_INT 22
16023: PUSH
16024: LD_INT 7
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PPUSH
16031: CALL_OW 69
16035: PUSH
16036: FOR_IN
16037: IFFALSE 16050
// RemoveUnit ( i ) ;
16039: LD_VAR 0 2
16043: PPUSH
16044: CALL_OW 64
16048: GO 16036
16050: POP
16051: POP
// end ;
16052: LD_VAR 0 1
16056: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16057: LD_INT 0
16059: PPUSH
16060: PPUSH
16061: PPUSH
16062: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16063: LD_INT 31
16065: PPUSH
16066: LD_INT 7
16068: PPUSH
16069: LD_INT 2
16071: PPUSH
16072: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16076: LD_INT 32
16078: PPUSH
16079: LD_INT 7
16081: PPUSH
16082: LD_INT 2
16084: PPUSH
16085: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16089: LD_INT 59
16091: PPUSH
16092: LD_INT 7
16094: PPUSH
16095: LD_INT 2
16097: PPUSH
16098: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16102: LD_ADDR_EXP 39
16106: PUSH
16107: LD_INT 5
16109: PUSH
16110: LD_INT 6
16112: PUSH
16113: LD_INT 7
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: LIST
16120: PUSH
16121: LD_OWVAR 67
16125: ARRAY
16126: ST_TO_ADDR
// al_force := [ ] ;
16127: LD_ADDR_EXP 38
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// al_vehs := [ ] ;
16134: LD_ADDR_EXP 44
16138: PUSH
16139: EMPTY
16140: ST_TO_ADDR
// uc_side := 7 ;
16141: LD_ADDR_OWVAR 20
16145: PUSH
16146: LD_INT 7
16148: ST_TO_ADDR
// uc_nation := 1 ;
16149: LD_ADDR_OWVAR 21
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// bc_type := b_oil_mine ;
16157: LD_ADDR_OWVAR 42
16161: PUSH
16162: LD_INT 29
16164: ST_TO_ADDR
// b := CreateBuilding ;
16165: LD_ADDR_VAR 0 4
16169: PUSH
16170: CALL_OW 46
16174: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16175: LD_VAR 0 4
16179: PPUSH
16180: LD_INT 61
16182: PPUSH
16183: LD_INT 7
16185: PPUSH
16186: LD_INT 0
16188: PPUSH
16189: LD_INT 0
16191: PPUSH
16192: CALL_OW 50
// bc_type := b_siberite_mine ;
16196: LD_ADDR_OWVAR 42
16200: PUSH
16201: LD_INT 30
16203: ST_TO_ADDR
// b := CreateBuilding ;
16204: LD_ADDR_VAR 0 4
16208: PUSH
16209: CALL_OW 46
16213: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16214: LD_VAR 0 4
16218: PPUSH
16219: LD_INT 69
16221: PPUSH
16222: LD_INT 13
16224: PPUSH
16225: LD_INT 0
16227: PPUSH
16228: LD_INT 0
16230: PPUSH
16231: CALL_OW 50
// hc_gallery :=  ;
16235: LD_ADDR_OWVAR 33
16239: PUSH
16240: LD_STRING 
16242: ST_TO_ADDR
// hc_name :=  ;
16243: LD_ADDR_OWVAR 26
16247: PUSH
16248: LD_STRING 
16250: ST_TO_ADDR
// hc_importance := 0 ;
16251: LD_ADDR_OWVAR 32
16255: PUSH
16256: LD_INT 0
16258: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16259: LD_ADDR_VAR 0 2
16263: PUSH
16264: LD_INT 22
16266: PUSH
16267: LD_INT 7
16269: PUSH
16270: EMPTY
16271: LIST
16272: LIST
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 32
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PPUSH
16288: CALL_OW 69
16292: PUSH
16293: FOR_IN
16294: IFFALSE 16364
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16296: LD_ADDR_OWVAR 21
16300: PUSH
16301: LD_INT 1
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: LD_INT 1
16313: PPUSH
16314: LD_INT 2
16316: PPUSH
16317: CALL_OW 12
16321: ARRAY
16322: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16323: LD_INT 0
16325: PPUSH
16326: LD_INT 1
16328: PPUSH
16329: LD_EXP 39
16333: PPUSH
16334: CALL_OW 380
// un := CreateHuman ;
16338: LD_ADDR_VAR 0 3
16342: PUSH
16343: CALL_OW 44
16347: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16348: LD_VAR 0 3
16352: PPUSH
16353: LD_VAR 0 2
16357: PPUSH
16358: CALL_OW 52
// end ;
16362: GO 16293
16364: POP
16365: POP
// for i = 1 to 3 do
16366: LD_ADDR_VAR 0 2
16370: PUSH
16371: DOUBLE
16372: LD_INT 1
16374: DEC
16375: ST_TO_ADDR
16376: LD_INT 3
16378: PUSH
16379: FOR_TO
16380: IFFALSE 16448
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16382: LD_ADDR_OWVAR 21
16386: PUSH
16387: LD_INT 1
16389: PUSH
16390: LD_INT 3
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 1
16399: PPUSH
16400: LD_INT 2
16402: PPUSH
16403: CALL_OW 12
16407: ARRAY
16408: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16409: LD_INT 0
16411: PPUSH
16412: LD_INT 4
16414: PPUSH
16415: LD_EXP 39
16419: PPUSH
16420: CALL_OW 380
// un := CreateHuman ;
16424: LD_ADDR_VAR 0 3
16428: PUSH
16429: CALL_OW 44
16433: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16434: LD_VAR 0 3
16438: PPUSH
16439: LD_INT 164
16441: PPUSH
16442: CALL_OW 52
// end ;
16446: GO 16379
16448: POP
16449: POP
// for i = 1 to 6 do
16450: LD_ADDR_VAR 0 2
16454: PUSH
16455: DOUBLE
16456: LD_INT 1
16458: DEC
16459: ST_TO_ADDR
16460: LD_INT 6
16462: PUSH
16463: FOR_TO
16464: IFFALSE 16555
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16466: LD_ADDR_OWVAR 21
16470: PUSH
16471: LD_INT 1
16473: PUSH
16474: LD_INT 3
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: PUSH
16481: LD_INT 1
16483: PPUSH
16484: LD_INT 2
16486: PPUSH
16487: CALL_OW 12
16491: ARRAY
16492: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16493: LD_INT 0
16495: PPUSH
16496: LD_INT 5
16498: PUSH
16499: LD_INT 9
16501: PUSH
16502: LD_INT 9
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: LIST
16509: PUSH
16510: LD_INT 1
16512: PPUSH
16513: LD_INT 3
16515: PPUSH
16516: CALL_OW 12
16520: ARRAY
16521: PPUSH
16522: LD_EXP 39
16526: PPUSH
16527: CALL_OW 380
// un := CreateHuman ;
16531: LD_ADDR_VAR 0 3
16535: PUSH
16536: CALL_OW 44
16540: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16541: LD_VAR 0 3
16545: PPUSH
16546: LD_INT 173
16548: PPUSH
16549: CALL_OW 52
// end ;
16553: GO 16463
16555: POP
16556: POP
// for i = 1 to 6 do
16557: LD_ADDR_VAR 0 2
16561: PUSH
16562: DOUBLE
16563: LD_INT 1
16565: DEC
16566: ST_TO_ADDR
16567: LD_INT 6
16569: PUSH
16570: FOR_TO
16571: IFFALSE 16669
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16573: LD_ADDR_OWVAR 21
16577: PUSH
16578: LD_INT 1
16580: PUSH
16581: LD_INT 3
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PUSH
16588: LD_INT 1
16590: PPUSH
16591: LD_INT 2
16593: PPUSH
16594: CALL_OW 12
16598: ARRAY
16599: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16600: LD_INT 0
16602: PPUSH
16603: LD_INT 3
16605: PPUSH
16606: LD_EXP 39
16610: PPUSH
16611: CALL_OW 380
// un := CreateHuman ;
16615: LD_ADDR_VAR 0 3
16619: PUSH
16620: CALL_OW 44
16624: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16625: LD_VAR 0 3
16629: PPUSH
16630: LD_INT 22
16632: PUSH
16633: LD_INT 7
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: LD_INT 30
16642: PUSH
16643: LD_INT 3
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PPUSH
16654: CALL_OW 69
16658: PUSH
16659: LD_INT 1
16661: ARRAY
16662: PPUSH
16663: CALL_OW 52
// end ;
16667: GO 16570
16669: POP
16670: POP
// for i = 1 to 4 do
16671: LD_ADDR_VAR 0 2
16675: PUSH
16676: DOUBLE
16677: LD_INT 1
16679: DEC
16680: ST_TO_ADDR
16681: LD_INT 4
16683: PUSH
16684: FOR_TO
16685: IFFALSE 16753
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16687: LD_ADDR_OWVAR 21
16691: PUSH
16692: LD_INT 1
16694: PUSH
16695: LD_INT 3
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: PUSH
16702: LD_INT 1
16704: PPUSH
16705: LD_INT 2
16707: PPUSH
16708: CALL_OW 12
16712: ARRAY
16713: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16714: LD_INT 0
16716: PPUSH
16717: LD_INT 2
16719: PPUSH
16720: LD_EXP 39
16724: PPUSH
16725: CALL_OW 380
// un := CreateHuman ;
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: CALL_OW 44
16738: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16739: LD_VAR 0 3
16743: PPUSH
16744: LD_INT 162
16746: PPUSH
16747: CALL_OW 52
// end ;
16751: GO 16684
16753: POP
16754: POP
// uc_nation := 3 ;
16755: LD_ADDR_OWVAR 21
16759: PUSH
16760: LD_INT 3
16762: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16763: LD_ADDR_OWVAR 37
16767: PUSH
16768: LD_INT 21
16770: ST_TO_ADDR
// vc_engine := engine_siberite ;
16771: LD_ADDR_OWVAR 39
16775: PUSH
16776: LD_INT 3
16778: ST_TO_ADDR
// vc_control := control_computer ;
16779: LD_ADDR_OWVAR 38
16783: PUSH
16784: LD_INT 3
16786: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16787: LD_ADDR_OWVAR 40
16791: PUSH
16792: LD_INT 51
16794: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16795: CALL_OW 45
16799: PPUSH
16800: LD_INT 49
16802: PPUSH
16803: LD_INT 13
16805: PPUSH
16806: LD_INT 0
16808: PPUSH
16809: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16813: LD_ADDR_EXP 46
16817: PUSH
16818: LD_INT 22
16820: PUSH
16821: LD_INT 7
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 30
16830: PUSH
16831: LD_INT 33
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PPUSH
16842: CALL_OW 69
16846: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16847: LD_ADDR_VAR 0 2
16851: PUSH
16852: DOUBLE
16853: LD_INT 1
16855: DEC
16856: ST_TO_ADDR
16857: LD_INT 22
16859: PUSH
16860: LD_INT 7
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 30
16869: PUSH
16870: LD_INT 33
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: PUSH
16877: LD_INT 35
16879: PUSH
16880: LD_INT 0
16882: PUSH
16883: EMPTY
16884: LIST
16885: LIST
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: PUSH
16892: EMPTY
16893: LIST
16894: PPUSH
16895: CALL_OW 69
16899: PUSH
16900: FOR_TO
16901: IFFALSE 16961
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16903: LD_INT 22
16905: PUSH
16906: LD_INT 7
16908: PUSH
16909: EMPTY
16910: LIST
16911: LIST
16912: PUSH
16913: LD_INT 30
16915: PUSH
16916: LD_INT 33
16918: PUSH
16919: EMPTY
16920: LIST
16921: LIST
16922: PUSH
16923: LD_INT 35
16925: PUSH
16926: LD_INT 0
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: PPUSH
16941: CALL_OW 69
16945: PUSH
16946: LD_VAR 0 2
16950: ARRAY
16951: PPUSH
16952: LD_INT 49
16954: PPUSH
16955: CALL_OW 208
16959: GO 16900
16961: POP
16962: POP
// end ;
16963: LD_VAR 0 1
16967: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16968: LD_OWVAR 2
16972: PUSH
16973: LD_INT 1
16975: EQUAL
16976: IFFALSE 18144
16978: GO 16980
16980: DISABLE
16981: LD_INT 0
16983: PPUSH
16984: PPUSH
16985: PPUSH
16986: PPUSH
// begin enable ;
16987: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16988: LD_ADDR_EXP 50
16992: PUSH
16993: LD_INT 22
16995: PUSH
16996: LD_INT 7
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PUSH
17003: LD_INT 21
17005: PUSH
17006: LD_INT 3
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: PPUSH
17017: CALL_OW 69
17021: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17022: LD_ADDR_EXP 48
17026: PUSH
17027: LD_INT 164
17029: PUSH
17030: LD_INT 197
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17037: LD_ADDR_EXP 47
17041: PUSH
17042: LD_INT 22
17044: PUSH
17045: LD_INT 7
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: PUSH
17052: LD_INT 30
17054: PUSH
17055: LD_INT 1
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: PPUSH
17066: CALL_OW 69
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17075: LD_ADDR_EXP 49
17079: PUSH
17080: LD_INT 22
17082: PUSH
17083: LD_INT 7
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 30
17092: PUSH
17093: LD_INT 3
17095: PUSH
17096: EMPTY
17097: LIST
17098: LIST
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17113: LD_INT 22
17115: PUSH
17116: LD_INT 7
17118: PUSH
17119: EMPTY
17120: LIST
17121: LIST
17122: PUSH
17123: LD_INT 34
17125: PUSH
17126: LD_INT 51
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PPUSH
17137: CALL_OW 69
17141: IFFALSE 17181
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17143: LD_ADDR_EXP 45
17147: PUSH
17148: LD_INT 22
17150: PUSH
17151: LD_INT 7
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 34
17160: PUSH
17161: LD_INT 51
17163: PUSH
17164: EMPTY
17165: LIST
17166: LIST
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PPUSH
17172: CALL_OW 69
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17181: LD_ADDR_EXP 41
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_INT 7
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 25
17198: PUSH
17199: LD_INT 9
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: PPUSH
17210: CALL_OW 69
17214: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17215: LD_ADDR_EXP 40
17219: PUSH
17220: LD_INT 22
17222: PUSH
17223: LD_INT 7
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 25
17232: PUSH
17233: LD_INT 2
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PPUSH
17244: CALL_OW 69
17248: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17249: LD_ADDR_EXP 42
17253: PUSH
17254: LD_INT 22
17256: PUSH
17257: LD_INT 7
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: LD_INT 25
17266: PUSH
17267: LD_INT 3
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PPUSH
17278: CALL_OW 69
17282: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17283: LD_ADDR_EXP 43
17287: PUSH
17288: LD_INT 22
17290: PUSH
17291: LD_INT 7
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: PUSH
17298: LD_INT 25
17300: PUSH
17301: LD_INT 4
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: PPUSH
17312: CALL_OW 69
17316: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17317: LD_EXP 41
17321: PPUSH
17322: LD_INT 81
17324: PUSH
17325: LD_INT 7
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PPUSH
17332: CALL_OW 69
17336: PPUSH
17337: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17341: LD_EXP 45
17345: PPUSH
17346: CALL_OW 314
17350: NOT
17351: PUSH
17352: LD_EXP 45
17356: PPUSH
17357: LD_INT 1
17359: PPUSH
17360: CALL_OW 289
17364: PUSH
17365: LD_INT 100
17367: LESS
17368: AND
17369: IFFALSE 17417
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17371: LD_ADDR_VAR 0 4
17375: PUSH
17376: LD_INT 12
17378: PPUSH
17379: CALL_OW 435
17383: ST_TO_ADDR
// if cr then
17384: LD_VAR 0 4
17388: IFFALSE 17417
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17390: LD_EXP 45
17394: PPUSH
17395: LD_VAR 0 4
17399: PUSH
17400: LD_INT 1
17402: ARRAY
17403: PPUSH
17404: LD_VAR 0 4
17408: PUSH
17409: LD_INT 2
17411: ARRAY
17412: PPUSH
17413: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17417: LD_EXP 50
17421: PPUSH
17422: LD_INT 3
17424: PUSH
17425: LD_INT 24
17427: PUSH
17428: LD_INT 1000
17430: PUSH
17431: EMPTY
17432: LIST
17433: LIST
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: PPUSH
17439: CALL_OW 72
17443: IFFALSE 17573
// begin if al_eng then
17445: LD_EXP 40
17449: IFFALSE 17571
// for i = 1 to al_eng do
17451: LD_ADDR_VAR 0 1
17455: PUSH
17456: DOUBLE
17457: LD_INT 1
17459: DEC
17460: ST_TO_ADDR
17461: LD_EXP 40
17465: PUSH
17466: FOR_TO
17467: IFFALSE 17569
// if IsInUnit ( al_eng [ i ] ) then
17469: LD_EXP 40
17473: PUSH
17474: LD_VAR 0 1
17478: ARRAY
17479: PPUSH
17480: CALL_OW 310
17484: IFFALSE 17503
// ComExitBuilding ( al_eng [ i ] ) else
17486: LD_EXP 40
17490: PUSH
17491: LD_VAR 0 1
17495: ARRAY
17496: PPUSH
17497: CALL_OW 122
17501: GO 17567
// if not HasTask ( al_eng [ i ] ) then
17503: LD_EXP 40
17507: PUSH
17508: LD_VAR 0 1
17512: ARRAY
17513: PPUSH
17514: CALL_OW 314
17518: NOT
17519: IFFALSE 17567
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17521: LD_EXP 40
17525: PUSH
17526: LD_VAR 0 1
17530: ARRAY
17531: PPUSH
17532: LD_EXP 50
17536: PPUSH
17537: LD_INT 3
17539: PUSH
17540: LD_INT 24
17542: PUSH
17543: LD_INT 1000
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: EMPTY
17551: LIST
17552: LIST
17553: PPUSH
17554: CALL_OW 72
17558: PUSH
17559: LD_INT 1
17561: ARRAY
17562: PPUSH
17563: CALL_OW 130
17567: GO 17466
17569: POP
17570: POP
// end else
17571: GO 17655
// if al_eng then
17573: LD_EXP 40
17577: IFFALSE 17655
// if not IsInUnit ( al_eng [ 1 ] ) then
17579: LD_EXP 40
17583: PUSH
17584: LD_INT 1
17586: ARRAY
17587: PPUSH
17588: CALL_OW 310
17592: NOT
17593: IFFALSE 17655
// for i = 1 to al_eng do
17595: LD_ADDR_VAR 0 1
17599: PUSH
17600: DOUBLE
17601: LD_INT 1
17603: DEC
17604: ST_TO_ADDR
17605: LD_EXP 40
17609: PUSH
17610: FOR_TO
17611: IFFALSE 17653
// if not IsInUnit ( al_eng [ i ] ) then
17613: LD_EXP 40
17617: PUSH
17618: LD_VAR 0 1
17622: ARRAY
17623: PPUSH
17624: CALL_OW 310
17628: NOT
17629: IFFALSE 17651
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17631: LD_EXP 40
17635: PUSH
17636: LD_VAR 0 1
17640: ARRAY
17641: PPUSH
17642: LD_EXP 47
17646: PPUSH
17647: CALL_OW 120
17651: GO 17610
17653: POP
17654: POP
// if al_vehs then
17655: LD_EXP 44
17659: IFFALSE 17759
// if BuildingStatus ( al_fac ) = bs_idle then
17661: LD_EXP 49
17665: PPUSH
17666: CALL_OW 461
17670: PUSH
17671: LD_INT 2
17673: EQUAL
17674: IFFALSE 17759
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17676: LD_EXP 49
17680: PPUSH
17681: LD_EXP 44
17685: PUSH
17686: LD_INT 1
17688: ARRAY
17689: PPUSH
17690: LD_EXP 44
17694: PUSH
17695: LD_INT 2
17697: ARRAY
17698: PPUSH
17699: LD_EXP 44
17703: PUSH
17704: LD_INT 3
17706: ARRAY
17707: PPUSH
17708: LD_EXP 44
17712: PUSH
17713: LD_INT 4
17715: ARRAY
17716: PPUSH
17717: CALL_OW 125
// for i = 1 to 4 do
17721: LD_ADDR_VAR 0 1
17725: PUSH
17726: DOUBLE
17727: LD_INT 1
17729: DEC
17730: ST_TO_ADDR
17731: LD_INT 4
17733: PUSH
17734: FOR_TO
17735: IFFALSE 17757
// al_vehs := Delete ( al_vehs , 1 ) ;
17737: LD_ADDR_EXP 44
17741: PUSH
17742: LD_EXP 44
17746: PPUSH
17747: LD_INT 1
17749: PPUSH
17750: CALL_OW 3
17754: ST_TO_ADDR
17755: GO 17734
17757: POP
17758: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17759: LD_EXP 38
17763: PUSH
17764: LD_INT 0
17766: EQUAL
17767: PUSH
17768: LD_OWVAR 1
17772: PUSH
17773: LD_INT 23100
17775: MOD
17776: PUSH
17777: LD_INT 0
17779: EQUAL
17780: AND
17781: IFFALSE 17895
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17783: LD_ADDR_VAR 0 1
17787: PUSH
17788: DOUBLE
17789: LD_INT 1
17791: DEC
17792: ST_TO_ADDR
17793: LD_INT 4
17795: PUSH
17796: LD_INT 5
17798: PUSH
17799: LD_INT 6
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: LIST
17806: PUSH
17807: LD_OWVAR 67
17811: ARRAY
17812: PUSH
17813: FOR_TO
17814: IFFALSE 17893
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17816: LD_ADDR_EXP 44
17820: PUSH
17821: LD_EXP 44
17825: PUSH
17826: LD_INT 23
17828: ADD
17829: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17830: LD_ADDR_EXP 44
17834: PUSH
17835: LD_EXP 44
17839: PUSH
17840: LD_INT 1
17842: ADD
17843: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17844: LD_ADDR_EXP 44
17848: PUSH
17849: LD_EXP 44
17853: PUSH
17854: LD_INT 3
17856: ADD
17857: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17858: LD_ADDR_EXP 44
17862: PUSH
17863: LD_EXP 44
17867: PUSH
17868: LD_INT 46
17870: PUSH
17871: LD_INT 47
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: LD_INT 1
17880: PPUSH
17881: LD_INT 2
17883: PPUSH
17884: CALL_OW 12
17888: ARRAY
17889: ADD
17890: ST_TO_ADDR
// end ;
17891: GO 17813
17893: POP
17894: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17895: LD_INT 22
17897: PUSH
17898: LD_INT 7
17900: PUSH
17901: EMPTY
17902: LIST
17903: LIST
17904: PUSH
17905: LD_INT 34
17907: PUSH
17908: LD_INT 51
17910: PUSH
17911: EMPTY
17912: LIST
17913: LIST
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PPUSH
17919: CALL_OW 69
17923: PUSH
17924: LD_INT 0
17926: EQUAL
17927: IFFALSE 17950
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17929: LD_EXP 49
17933: PPUSH
17934: LD_INT 21
17936: PPUSH
17937: LD_INT 1
17939: PPUSH
17940: LD_INT 3
17942: PPUSH
17943: LD_INT 51
17945: PPUSH
17946: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17950: LD_EXP 38
17954: PUSH
17955: LD_OWVAR 1
17959: PUSH
17960: LD_INT 25200
17962: MOD
17963: PUSH
17964: LD_INT 0
17966: EQUAL
17967: AND
17968: IFFALSE 18031
// begin for i = 1 to al_force do
17970: LD_ADDR_VAR 0 1
17974: PUSH
17975: DOUBLE
17976: LD_INT 1
17978: DEC
17979: ST_TO_ADDR
17980: LD_EXP 38
17984: PUSH
17985: FOR_TO
17986: IFFALSE 18029
// if GetTag ( al_force [ i ] ) <> 11 then
17988: LD_EXP 38
17992: PUSH
17993: LD_VAR 0 1
17997: ARRAY
17998: PPUSH
17999: CALL_OW 110
18003: PUSH
18004: LD_INT 11
18006: NONEQUAL
18007: IFFALSE 18027
// SetTag ( al_force [ i ] , 11 ) ;
18009: LD_EXP 38
18013: PUSH
18014: LD_VAR 0 1
18018: ARRAY
18019: PPUSH
18020: LD_INT 11
18022: PPUSH
18023: CALL_OW 109
18027: GO 17985
18029: POP
18030: POP
// end ; if al_force then
18031: LD_EXP 38
18035: IFFALSE 18144
// for i = 1 to al_force do
18037: LD_ADDR_VAR 0 1
18041: PUSH
18042: DOUBLE
18043: LD_INT 1
18045: DEC
18046: ST_TO_ADDR
18047: LD_EXP 38
18051: PUSH
18052: FOR_TO
18053: IFFALSE 18142
// begin if GetTag ( al_force [ i ] ) = 11 then
18055: LD_EXP 38
18059: PUSH
18060: LD_VAR 0 1
18064: ARRAY
18065: PPUSH
18066: CALL_OW 110
18070: PUSH
18071: LD_INT 11
18073: EQUAL
18074: IFFALSE 18140
// begin if not HasTask ( al_force [ i ] ) then
18076: LD_EXP 38
18080: PUSH
18081: LD_VAR 0 1
18085: ARRAY
18086: PPUSH
18087: CALL_OW 314
18091: NOT
18092: IFFALSE 18140
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18094: LD_EXP 38
18098: PUSH
18099: LD_VAR 0 1
18103: ARRAY
18104: PPUSH
18105: LD_INT 81
18107: PUSH
18108: LD_INT 7
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: PPUSH
18115: CALL_OW 69
18119: PPUSH
18120: LD_EXP 38
18124: PUSH
18125: LD_VAR 0 1
18129: ARRAY
18130: PPUSH
18131: CALL_OW 74
18135: PPUSH
18136: CALL_OW 115
// end ; end ;
18140: GO 18052
18142: POP
18143: POP
// end ; end_of_file
18144: PPOPN 4
18146: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18147: LD_INT 0
18149: PPUSH
18150: PPUSH
18151: PPUSH
18152: PPUSH
18153: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18154: LD_ADDR_EXP 53
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: LD_INT 6
18164: PUSH
18165: LD_INT 5
18167: PUSH
18168: EMPTY
18169: LIST
18170: LIST
18171: LIST
18172: PUSH
18173: LD_OWVAR 67
18177: ARRAY
18178: ST_TO_ADDR
// ar_force := [ ] ;
18179: LD_ADDR_EXP 52
18183: PUSH
18184: EMPTY
18185: ST_TO_ADDR
// RemoveAlliance ;
18186: CALL 15975 0 0
// RemoveEnvironmentArea ( evn ) ;
18190: LD_INT 17
18192: PPUSH
18193: CALL_OW 355
// your_side := 2 ;
18197: LD_ADDR_OWVAR 2
18201: PUSH
18202: LD_INT 2
18204: ST_TO_ADDR
// uc_side := 2 ;
18205: LD_ADDR_OWVAR 20
18209: PUSH
18210: LD_INT 2
18212: ST_TO_ADDR
// uc_nation := nation_arabian ;
18213: LD_ADDR_OWVAR 21
18217: PUSH
18218: LD_INT 2
18220: ST_TO_ADDR
// hc_gallery :=  ;
18221: LD_ADDR_OWVAR 33
18225: PUSH
18226: LD_STRING 
18228: ST_TO_ADDR
// hc_name :=  ;
18229: LD_ADDR_OWVAR 26
18233: PUSH
18234: LD_STRING 
18236: ST_TO_ADDR
// hc_importance := 0 ;
18237: LD_ADDR_OWVAR 32
18241: PUSH
18242: LD_INT 0
18244: ST_TO_ADDR
// for i = 1 to 15 do
18245: LD_ADDR_VAR 0 2
18249: PUSH
18250: DOUBLE
18251: LD_INT 1
18253: DEC
18254: ST_TO_ADDR
18255: LD_INT 15
18257: PUSH
18258: FOR_TO
18259: IFFALSE 18312
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18261: LD_INT 0
18263: PPUSH
18264: LD_INT 1
18266: PPUSH
18267: LD_INT 4
18269: PPUSH
18270: CALL_OW 12
18274: PPUSH
18275: LD_EXP 53
18279: PPUSH
18280: CALL_OW 380
// un := CreateHuman ;
18284: LD_ADDR_VAR 0 4
18288: PUSH
18289: CALL_OW 44
18293: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18294: LD_ADDR_EXP 52
18298: PUSH
18299: LD_EXP 52
18303: PUSH
18304: LD_VAR 0 4
18308: ADD
18309: ST_TO_ADDR
// end ;
18310: GO 18258
18312: POP
18313: POP
// hc_importance := 100 ;
18314: LD_ADDR_OWVAR 32
18318: PUSH
18319: LD_INT 100
18321: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18322: LD_INT 1
18324: PPUSH
18325: LD_INT 11
18327: PPUSH
18328: LD_EXP 53
18332: PPUSH
18333: CALL_OW 380
// ar_commander := CreateHuman ;
18337: LD_ADDR_EXP 51
18341: PUSH
18342: CALL_OW 44
18346: ST_TO_ADDR
// player_commander := ar_commander ;
18347: LD_ADDR_EXP 10
18351: PUSH
18352: LD_EXP 51
18356: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18357: LD_ADDR_VAR 0 5
18361: PUSH
18362: LD_STRING text
18364: PPUSH
18365: LD_INT 11
18367: PUSH
18368: LD_INT 10
18370: PUSH
18371: LD_INT 9
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: LIST
18378: PUSH
18379: LD_OWVAR 67
18383: ARRAY
18384: PPUSH
18385: LD_INT 11
18387: PUSH
18388: LD_INT 10
18390: PUSH
18391: LD_INT 9
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: LD_OWVAR 67
18403: ARRAY
18404: PPUSH
18405: LD_INT -5
18407: PUSH
18408: LD_EXP 51
18412: PUSH
18413: LD_INT -3
18415: PUSH
18416: LD_INT -2
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: LIST
18423: LIST
18424: PUSH
18425: LD_EXP 52
18429: ADD
18430: PPUSH
18431: LD_INT 1
18433: PUSH
18434: LD_INT 3
18436: PUSH
18437: LD_INT 2
18439: PUSH
18440: LD_INT 1
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 8
18459: PUSH
18460: EMPTY
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: LIST
18466: PPUSH
18467: CALL_OW 42
18471: ST_TO_ADDR
// team := team ^ ar_commander ;
18472: LD_ADDR_VAR 0 5
18476: PUSH
18477: LD_VAR 0 5
18481: PUSH
18482: LD_EXP 51
18486: ADD
18487: ST_TO_ADDR
// for i = 1 to team do
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_VAR 0 5
18502: PUSH
18503: FOR_TO
18504: IFFALSE 18529
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18506: LD_VAR 0 5
18510: PUSH
18511: LD_VAR 0 2
18515: ARRAY
18516: PPUSH
18517: LD_INT 16
18519: PPUSH
18520: LD_INT 0
18522: PPUSH
18523: CALL_OW 49
18527: GO 18503
18529: POP
18530: POP
// uc_side := 0 ;
18531: LD_ADDR_OWVAR 20
18535: PUSH
18536: LD_INT 0
18538: ST_TO_ADDR
// uc_nation := 0 ;
18539: LD_ADDR_OWVAR 21
18543: PUSH
18544: LD_INT 0
18546: ST_TO_ADDR
// vc_chassis := 31 ;
18547: LD_ADDR_OWVAR 37
18551: PUSH
18552: LD_INT 31
18554: ST_TO_ADDR
// vc_control := control_rider ;
18555: LD_ADDR_OWVAR 38
18559: PUSH
18560: LD_INT 4
18562: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18563: CALL_OW 45
18567: PPUSH
18568: LD_INT 96
18570: PPUSH
18571: LD_INT 20
18573: PPUSH
18574: LD_INT 0
18576: PPUSH
18577: CALL_OW 48
// end ; end_of_file
18581: LD_VAR 0 1
18585: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18586: GO 18588
18588: DISABLE
// begin ru_radar := 98 ;
18589: LD_ADDR_EXP 54
18593: PUSH
18594: LD_INT 98
18596: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18597: LD_ADDR_EXP 55
18601: PUSH
18602: LD_INT 89
18604: ST_TO_ADDR
// us_hack := 99 ;
18605: LD_ADDR_EXP 56
18609: PUSH
18610: LD_INT 99
18612: ST_TO_ADDR
// us_artillery := 97 ;
18613: LD_ADDR_EXP 57
18617: PUSH
18618: LD_INT 97
18620: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18621: LD_ADDR_EXP 58
18625: PUSH
18626: LD_INT 91
18628: ST_TO_ADDR
// tech_Artillery := 80 ;
18629: LD_ADDR_EXP 59
18633: PUSH
18634: LD_INT 80
18636: ST_TO_ADDR
// tech_RadMat := 81 ;
18637: LD_ADDR_EXP 60
18641: PUSH
18642: LD_INT 81
18644: ST_TO_ADDR
// tech_BasicTools := 82 ;
18645: LD_ADDR_EXP 61
18649: PUSH
18650: LD_INT 82
18652: ST_TO_ADDR
// tech_Cargo := 83 ;
18653: LD_ADDR_EXP 62
18657: PUSH
18658: LD_INT 83
18660: ST_TO_ADDR
// tech_Track := 84 ;
18661: LD_ADDR_EXP 63
18665: PUSH
18666: LD_INT 84
18668: ST_TO_ADDR
// tech_Crane := 85 ;
18669: LD_ADDR_EXP 64
18673: PUSH
18674: LD_INT 85
18676: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18677: LD_ADDR_EXP 65
18681: PUSH
18682: LD_INT 86
18684: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18685: LD_ADDR_EXP 66
18689: PUSH
18690: LD_INT 87
18692: ST_TO_ADDR
// end ; end_of_file end_of_file
18693: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18694: GO 18696
18696: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18697: LD_STRING initStreamRollete();
18699: PPUSH
18700: CALL_OW 559
// InitStreamMode ;
18704: CALL 18713 0 0
// DefineStreamItems ( ) ;
18708: CALL 19153 0 0
// end ;
18712: END
// function InitStreamMode ; begin
18713: LD_INT 0
18715: PPUSH
// streamModeActive := false ;
18716: LD_ADDR_EXP 67
18720: PUSH
18721: LD_INT 0
18723: ST_TO_ADDR
// normalCounter := 36 ;
18724: LD_ADDR_EXP 68
18728: PUSH
18729: LD_INT 36
18731: ST_TO_ADDR
// hardcoreCounter := 16 ;
18732: LD_ADDR_EXP 69
18736: PUSH
18737: LD_INT 16
18739: ST_TO_ADDR
// sRocket := false ;
18740: LD_ADDR_EXP 72
18744: PUSH
18745: LD_INT 0
18747: ST_TO_ADDR
// sSpeed := false ;
18748: LD_ADDR_EXP 71
18752: PUSH
18753: LD_INT 0
18755: ST_TO_ADDR
// sEngine := false ;
18756: LD_ADDR_EXP 73
18760: PUSH
18761: LD_INT 0
18763: ST_TO_ADDR
// sSpec := false ;
18764: LD_ADDR_EXP 70
18768: PUSH
18769: LD_INT 0
18771: ST_TO_ADDR
// sLevel := false ;
18772: LD_ADDR_EXP 74
18776: PUSH
18777: LD_INT 0
18779: ST_TO_ADDR
// sArmoury := false ;
18780: LD_ADDR_EXP 75
18784: PUSH
18785: LD_INT 0
18787: ST_TO_ADDR
// sRadar := false ;
18788: LD_ADDR_EXP 76
18792: PUSH
18793: LD_INT 0
18795: ST_TO_ADDR
// sBunker := false ;
18796: LD_ADDR_EXP 77
18800: PUSH
18801: LD_INT 0
18803: ST_TO_ADDR
// sHack := false ;
18804: LD_ADDR_EXP 78
18808: PUSH
18809: LD_INT 0
18811: ST_TO_ADDR
// sFire := false ;
18812: LD_ADDR_EXP 79
18816: PUSH
18817: LD_INT 0
18819: ST_TO_ADDR
// sRefresh := false ;
18820: LD_ADDR_EXP 80
18824: PUSH
18825: LD_INT 0
18827: ST_TO_ADDR
// sExp := false ;
18828: LD_ADDR_EXP 81
18832: PUSH
18833: LD_INT 0
18835: ST_TO_ADDR
// sDepot := false ;
18836: LD_ADDR_EXP 82
18840: PUSH
18841: LD_INT 0
18843: ST_TO_ADDR
// sFlag := false ;
18844: LD_ADDR_EXP 83
18848: PUSH
18849: LD_INT 0
18851: ST_TO_ADDR
// sKamikadze := false ;
18852: LD_ADDR_EXP 91
18856: PUSH
18857: LD_INT 0
18859: ST_TO_ADDR
// sTroll := false ;
18860: LD_ADDR_EXP 92
18864: PUSH
18865: LD_INT 0
18867: ST_TO_ADDR
// sSlow := false ;
18868: LD_ADDR_EXP 93
18872: PUSH
18873: LD_INT 0
18875: ST_TO_ADDR
// sLack := false ;
18876: LD_ADDR_EXP 94
18880: PUSH
18881: LD_INT 0
18883: ST_TO_ADDR
// sTank := false ;
18884: LD_ADDR_EXP 96
18888: PUSH
18889: LD_INT 0
18891: ST_TO_ADDR
// sRemote := false ;
18892: LD_ADDR_EXP 97
18896: PUSH
18897: LD_INT 0
18899: ST_TO_ADDR
// sPowell := false ;
18900: LD_ADDR_EXP 98
18904: PUSH
18905: LD_INT 0
18907: ST_TO_ADDR
// sTeleport := false ;
18908: LD_ADDR_EXP 101
18912: PUSH
18913: LD_INT 0
18915: ST_TO_ADDR
// sOilTower := false ;
18916: LD_ADDR_EXP 103
18920: PUSH
18921: LD_INT 0
18923: ST_TO_ADDR
// sShovel := false ;
18924: LD_ADDR_EXP 104
18928: PUSH
18929: LD_INT 0
18931: ST_TO_ADDR
// sSheik := false ;
18932: LD_ADDR_EXP 105
18936: PUSH
18937: LD_INT 0
18939: ST_TO_ADDR
// sEarthquake := false ;
18940: LD_ADDR_EXP 107
18944: PUSH
18945: LD_INT 0
18947: ST_TO_ADDR
// sAI := false ;
18948: LD_ADDR_EXP 108
18952: PUSH
18953: LD_INT 0
18955: ST_TO_ADDR
// sCargo := false ;
18956: LD_ADDR_EXP 111
18960: PUSH
18961: LD_INT 0
18963: ST_TO_ADDR
// sDLaser := false ;
18964: LD_ADDR_EXP 112
18968: PUSH
18969: LD_INT 0
18971: ST_TO_ADDR
// sExchange := false ;
18972: LD_ADDR_EXP 113
18976: PUSH
18977: LD_INT 0
18979: ST_TO_ADDR
// sFac := false ;
18980: LD_ADDR_EXP 114
18984: PUSH
18985: LD_INT 0
18987: ST_TO_ADDR
// sPower := false ;
18988: LD_ADDR_EXP 115
18992: PUSH
18993: LD_INT 0
18995: ST_TO_ADDR
// sRandom := false ;
18996: LD_ADDR_EXP 116
19000: PUSH
19001: LD_INT 0
19003: ST_TO_ADDR
// sShield := false ;
19004: LD_ADDR_EXP 117
19008: PUSH
19009: LD_INT 0
19011: ST_TO_ADDR
// sTime := false ;
19012: LD_ADDR_EXP 118
19016: PUSH
19017: LD_INT 0
19019: ST_TO_ADDR
// sTools := false ;
19020: LD_ADDR_EXP 119
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// sSold := false ;
19028: LD_ADDR_EXP 84
19032: PUSH
19033: LD_INT 0
19035: ST_TO_ADDR
// sDiff := false ;
19036: LD_ADDR_EXP 85
19040: PUSH
19041: LD_INT 0
19043: ST_TO_ADDR
// sFog := false ;
19044: LD_ADDR_EXP 88
19048: PUSH
19049: LD_INT 0
19051: ST_TO_ADDR
// sReset := false ;
19052: LD_ADDR_EXP 89
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// sSun := false ;
19060: LD_ADDR_EXP 90
19064: PUSH
19065: LD_INT 0
19067: ST_TO_ADDR
// sTiger := false ;
19068: LD_ADDR_EXP 86
19072: PUSH
19073: LD_INT 0
19075: ST_TO_ADDR
// sBomb := false ;
19076: LD_ADDR_EXP 87
19080: PUSH
19081: LD_INT 0
19083: ST_TO_ADDR
// sWound := false ;
19084: LD_ADDR_EXP 95
19088: PUSH
19089: LD_INT 0
19091: ST_TO_ADDR
// sBetray := false ;
19092: LD_ADDR_EXP 99
19096: PUSH
19097: LD_INT 0
19099: ST_TO_ADDR
// sContamin := false ;
19100: LD_ADDR_EXP 100
19104: PUSH
19105: LD_INT 0
19107: ST_TO_ADDR
// sOil := false ;
19108: LD_ADDR_EXP 102
19112: PUSH
19113: LD_INT 0
19115: ST_TO_ADDR
// sStu := false ;
19116: LD_ADDR_EXP 106
19120: PUSH
19121: LD_INT 0
19123: ST_TO_ADDR
// sBazooka := false ;
19124: LD_ADDR_EXP 109
19128: PUSH
19129: LD_INT 0
19131: ST_TO_ADDR
// sMortar := false ;
19132: LD_ADDR_EXP 110
19136: PUSH
19137: LD_INT 0
19139: ST_TO_ADDR
// sRanger := false ;
19140: LD_ADDR_EXP 120
19144: PUSH
19145: LD_INT 0
19147: ST_TO_ADDR
// end ;
19148: LD_VAR 0 1
19152: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19153: LD_INT 0
19155: PPUSH
19156: PPUSH
19157: PPUSH
19158: PPUSH
19159: PPUSH
// result := [ ] ;
19160: LD_ADDR_VAR 0 1
19164: PUSH
19165: EMPTY
19166: ST_TO_ADDR
// if campaign_id = 1 then
19167: LD_OWVAR 69
19171: PUSH
19172: LD_INT 1
19174: EQUAL
19175: IFFALSE 22113
// begin case mission_number of 1 :
19177: LD_OWVAR 70
19181: PUSH
19182: LD_INT 1
19184: DOUBLE
19185: EQUAL
19186: IFTRUE 19190
19188: GO 19254
19190: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19191: LD_ADDR_VAR 0 1
19195: PUSH
19196: LD_INT 2
19198: PUSH
19199: LD_INT 4
19201: PUSH
19202: LD_INT 11
19204: PUSH
19205: LD_INT 12
19207: PUSH
19208: LD_INT 15
19210: PUSH
19211: LD_INT 16
19213: PUSH
19214: LD_INT 22
19216: PUSH
19217: LD_INT 23
19219: PUSH
19220: LD_INT 26
19222: PUSH
19223: EMPTY
19224: LIST
19225: LIST
19226: LIST
19227: LIST
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: LIST
19233: PUSH
19234: LD_INT 101
19236: PUSH
19237: LD_INT 102
19239: PUSH
19240: LD_INT 106
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: LIST
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: ST_TO_ADDR
19252: GO 22111
19254: LD_INT 2
19256: DOUBLE
19257: EQUAL
19258: IFTRUE 19262
19260: GO 19334
19262: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19263: LD_ADDR_VAR 0 1
19267: PUSH
19268: LD_INT 2
19270: PUSH
19271: LD_INT 4
19273: PUSH
19274: LD_INT 11
19276: PUSH
19277: LD_INT 12
19279: PUSH
19280: LD_INT 15
19282: PUSH
19283: LD_INT 16
19285: PUSH
19286: LD_INT 22
19288: PUSH
19289: LD_INT 23
19291: PUSH
19292: LD_INT 26
19294: PUSH
19295: EMPTY
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: LIST
19305: PUSH
19306: LD_INT 101
19308: PUSH
19309: LD_INT 102
19311: PUSH
19312: LD_INT 105
19314: PUSH
19315: LD_INT 106
19317: PUSH
19318: LD_INT 108
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: LIST
19325: LIST
19326: LIST
19327: PUSH
19328: EMPTY
19329: LIST
19330: LIST
19331: ST_TO_ADDR
19332: GO 22111
19334: LD_INT 3
19336: DOUBLE
19337: EQUAL
19338: IFTRUE 19342
19340: GO 19418
19342: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19343: LD_ADDR_VAR 0 1
19347: PUSH
19348: LD_INT 2
19350: PUSH
19351: LD_INT 4
19353: PUSH
19354: LD_INT 5
19356: PUSH
19357: LD_INT 11
19359: PUSH
19360: LD_INT 12
19362: PUSH
19363: LD_INT 15
19365: PUSH
19366: LD_INT 16
19368: PUSH
19369: LD_INT 22
19371: PUSH
19372: LD_INT 26
19374: PUSH
19375: LD_INT 36
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: LIST
19386: LIST
19387: LIST
19388: LIST
19389: PUSH
19390: LD_INT 101
19392: PUSH
19393: LD_INT 102
19395: PUSH
19396: LD_INT 105
19398: PUSH
19399: LD_INT 106
19401: PUSH
19402: LD_INT 108
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: PUSH
19412: EMPTY
19413: LIST
19414: LIST
19415: ST_TO_ADDR
19416: GO 22111
19418: LD_INT 4
19420: DOUBLE
19421: EQUAL
19422: IFTRUE 19426
19424: GO 19510
19426: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19427: LD_ADDR_VAR 0 1
19431: PUSH
19432: LD_INT 2
19434: PUSH
19435: LD_INT 4
19437: PUSH
19438: LD_INT 5
19440: PUSH
19441: LD_INT 8
19443: PUSH
19444: LD_INT 11
19446: PUSH
19447: LD_INT 12
19449: PUSH
19450: LD_INT 15
19452: PUSH
19453: LD_INT 16
19455: PUSH
19456: LD_INT 22
19458: PUSH
19459: LD_INT 23
19461: PUSH
19462: LD_INT 26
19464: PUSH
19465: LD_INT 36
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: LIST
19474: LIST
19475: LIST
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: LIST
19481: PUSH
19482: LD_INT 101
19484: PUSH
19485: LD_INT 102
19487: PUSH
19488: LD_INT 105
19490: PUSH
19491: LD_INT 106
19493: PUSH
19494: LD_INT 108
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: ST_TO_ADDR
19508: GO 22111
19510: LD_INT 5
19512: DOUBLE
19513: EQUAL
19514: IFTRUE 19518
19516: GO 19618
19518: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19519: LD_ADDR_VAR 0 1
19523: PUSH
19524: LD_INT 2
19526: PUSH
19527: LD_INT 4
19529: PUSH
19530: LD_INT 5
19532: PUSH
19533: LD_INT 6
19535: PUSH
19536: LD_INT 8
19538: PUSH
19539: LD_INT 11
19541: PUSH
19542: LD_INT 12
19544: PUSH
19545: LD_INT 15
19547: PUSH
19548: LD_INT 16
19550: PUSH
19551: LD_INT 22
19553: PUSH
19554: LD_INT 23
19556: PUSH
19557: LD_INT 25
19559: PUSH
19560: LD_INT 26
19562: PUSH
19563: LD_INT 36
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 101
19584: PUSH
19585: LD_INT 102
19587: PUSH
19588: LD_INT 105
19590: PUSH
19591: LD_INT 106
19593: PUSH
19594: LD_INT 108
19596: PUSH
19597: LD_INT 109
19599: PUSH
19600: LD_INT 112
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: LIST
19609: LIST
19610: LIST
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: ST_TO_ADDR
19616: GO 22111
19618: LD_INT 6
19620: DOUBLE
19621: EQUAL
19622: IFTRUE 19626
19624: GO 19746
19626: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19627: LD_ADDR_VAR 0 1
19631: PUSH
19632: LD_INT 2
19634: PUSH
19635: LD_INT 4
19637: PUSH
19638: LD_INT 5
19640: PUSH
19641: LD_INT 6
19643: PUSH
19644: LD_INT 8
19646: PUSH
19647: LD_INT 11
19649: PUSH
19650: LD_INT 12
19652: PUSH
19653: LD_INT 15
19655: PUSH
19656: LD_INT 16
19658: PUSH
19659: LD_INT 20
19661: PUSH
19662: LD_INT 21
19664: PUSH
19665: LD_INT 22
19667: PUSH
19668: LD_INT 23
19670: PUSH
19671: LD_INT 25
19673: PUSH
19674: LD_INT 26
19676: PUSH
19677: LD_INT 30
19679: PUSH
19680: LD_INT 31
19682: PUSH
19683: LD_INT 32
19685: PUSH
19686: LD_INT 36
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: LIST
19693: LIST
19694: LIST
19695: LIST
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: LIST
19707: LIST
19708: LIST
19709: PUSH
19710: LD_INT 101
19712: PUSH
19713: LD_INT 102
19715: PUSH
19716: LD_INT 105
19718: PUSH
19719: LD_INT 106
19721: PUSH
19722: LD_INT 108
19724: PUSH
19725: LD_INT 109
19727: PUSH
19728: LD_INT 112
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: ST_TO_ADDR
19744: GO 22111
19746: LD_INT 7
19748: DOUBLE
19749: EQUAL
19750: IFTRUE 19754
19752: GO 19854
19754: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19755: LD_ADDR_VAR 0 1
19759: PUSH
19760: LD_INT 2
19762: PUSH
19763: LD_INT 4
19765: PUSH
19766: LD_INT 5
19768: PUSH
19769: LD_INT 7
19771: PUSH
19772: LD_INT 11
19774: PUSH
19775: LD_INT 12
19777: PUSH
19778: LD_INT 15
19780: PUSH
19781: LD_INT 16
19783: PUSH
19784: LD_INT 20
19786: PUSH
19787: LD_INT 21
19789: PUSH
19790: LD_INT 22
19792: PUSH
19793: LD_INT 23
19795: PUSH
19796: LD_INT 25
19798: PUSH
19799: LD_INT 26
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: LIST
19815: LIST
19816: LIST
19817: PUSH
19818: LD_INT 101
19820: PUSH
19821: LD_INT 102
19823: PUSH
19824: LD_INT 103
19826: PUSH
19827: LD_INT 105
19829: PUSH
19830: LD_INT 106
19832: PUSH
19833: LD_INT 108
19835: PUSH
19836: LD_INT 112
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: ST_TO_ADDR
19852: GO 22111
19854: LD_INT 8
19856: DOUBLE
19857: EQUAL
19858: IFTRUE 19862
19860: GO 19990
19862: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19863: LD_ADDR_VAR 0 1
19867: PUSH
19868: LD_INT 2
19870: PUSH
19871: LD_INT 4
19873: PUSH
19874: LD_INT 5
19876: PUSH
19877: LD_INT 6
19879: PUSH
19880: LD_INT 7
19882: PUSH
19883: LD_INT 8
19885: PUSH
19886: LD_INT 11
19888: PUSH
19889: LD_INT 12
19891: PUSH
19892: LD_INT 15
19894: PUSH
19895: LD_INT 16
19897: PUSH
19898: LD_INT 20
19900: PUSH
19901: LD_INT 21
19903: PUSH
19904: LD_INT 22
19906: PUSH
19907: LD_INT 23
19909: PUSH
19910: LD_INT 25
19912: PUSH
19913: LD_INT 26
19915: PUSH
19916: LD_INT 30
19918: PUSH
19919: LD_INT 31
19921: PUSH
19922: LD_INT 32
19924: PUSH
19925: LD_INT 36
19927: PUSH
19928: EMPTY
19929: LIST
19930: LIST
19931: LIST
19932: LIST
19933: LIST
19934: LIST
19935: LIST
19936: LIST
19937: LIST
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: PUSH
19950: LD_INT 101
19952: PUSH
19953: LD_INT 102
19955: PUSH
19956: LD_INT 103
19958: PUSH
19959: LD_INT 105
19961: PUSH
19962: LD_INT 106
19964: PUSH
19965: LD_INT 108
19967: PUSH
19968: LD_INT 109
19970: PUSH
19971: LD_INT 112
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: ST_TO_ADDR
19988: GO 22111
19990: LD_INT 9
19992: DOUBLE
19993: EQUAL
19994: IFTRUE 19998
19996: GO 20134
19998: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19999: LD_ADDR_VAR 0 1
20003: PUSH
20004: LD_INT 2
20006: PUSH
20007: LD_INT 4
20009: PUSH
20010: LD_INT 5
20012: PUSH
20013: LD_INT 6
20015: PUSH
20016: LD_INT 7
20018: PUSH
20019: LD_INT 8
20021: PUSH
20022: LD_INT 11
20024: PUSH
20025: LD_INT 12
20027: PUSH
20028: LD_INT 15
20030: PUSH
20031: LD_INT 16
20033: PUSH
20034: LD_INT 20
20036: PUSH
20037: LD_INT 21
20039: PUSH
20040: LD_INT 22
20042: PUSH
20043: LD_INT 23
20045: PUSH
20046: LD_INT 25
20048: PUSH
20049: LD_INT 26
20051: PUSH
20052: LD_INT 28
20054: PUSH
20055: LD_INT 30
20057: PUSH
20058: LD_INT 31
20060: PUSH
20061: LD_INT 32
20063: PUSH
20064: LD_INT 36
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: LIST
20071: LIST
20072: LIST
20073: LIST
20074: LIST
20075: LIST
20076: LIST
20077: LIST
20078: LIST
20079: LIST
20080: LIST
20081: LIST
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: PUSH
20090: LD_INT 101
20092: PUSH
20093: LD_INT 102
20095: PUSH
20096: LD_INT 103
20098: PUSH
20099: LD_INT 105
20101: PUSH
20102: LD_INT 106
20104: PUSH
20105: LD_INT 108
20107: PUSH
20108: LD_INT 109
20110: PUSH
20111: LD_INT 112
20113: PUSH
20114: LD_INT 114
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: LIST
20121: LIST
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: ST_TO_ADDR
20132: GO 22111
20134: LD_INT 10
20136: DOUBLE
20137: EQUAL
20138: IFTRUE 20142
20140: GO 20326
20142: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20143: LD_ADDR_VAR 0 1
20147: PUSH
20148: LD_INT 2
20150: PUSH
20151: LD_INT 4
20153: PUSH
20154: LD_INT 5
20156: PUSH
20157: LD_INT 6
20159: PUSH
20160: LD_INT 7
20162: PUSH
20163: LD_INT 8
20165: PUSH
20166: LD_INT 9
20168: PUSH
20169: LD_INT 10
20171: PUSH
20172: LD_INT 11
20174: PUSH
20175: LD_INT 12
20177: PUSH
20178: LD_INT 13
20180: PUSH
20181: LD_INT 14
20183: PUSH
20184: LD_INT 15
20186: PUSH
20187: LD_INT 16
20189: PUSH
20190: LD_INT 17
20192: PUSH
20193: LD_INT 18
20195: PUSH
20196: LD_INT 19
20198: PUSH
20199: LD_INT 20
20201: PUSH
20202: LD_INT 21
20204: PUSH
20205: LD_INT 22
20207: PUSH
20208: LD_INT 23
20210: PUSH
20211: LD_INT 24
20213: PUSH
20214: LD_INT 25
20216: PUSH
20217: LD_INT 26
20219: PUSH
20220: LD_INT 28
20222: PUSH
20223: LD_INT 30
20225: PUSH
20226: LD_INT 31
20228: PUSH
20229: LD_INT 32
20231: PUSH
20232: LD_INT 36
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: LIST
20239: LIST
20240: LIST
20241: LIST
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: LIST
20251: LIST
20252: LIST
20253: LIST
20254: LIST
20255: LIST
20256: LIST
20257: LIST
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: LIST
20264: LIST
20265: PUSH
20266: LD_INT 101
20268: PUSH
20269: LD_INT 102
20271: PUSH
20272: LD_INT 103
20274: PUSH
20275: LD_INT 104
20277: PUSH
20278: LD_INT 105
20280: PUSH
20281: LD_INT 106
20283: PUSH
20284: LD_INT 107
20286: PUSH
20287: LD_INT 108
20289: PUSH
20290: LD_INT 109
20292: PUSH
20293: LD_INT 110
20295: PUSH
20296: LD_INT 111
20298: PUSH
20299: LD_INT 112
20301: PUSH
20302: LD_INT 114
20304: PUSH
20305: EMPTY
20306: LIST
20307: LIST
20308: LIST
20309: LIST
20310: LIST
20311: LIST
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: PUSH
20320: EMPTY
20321: LIST
20322: LIST
20323: ST_TO_ADDR
20324: GO 22111
20326: LD_INT 11
20328: DOUBLE
20329: EQUAL
20330: IFTRUE 20334
20332: GO 20526
20334: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20335: LD_ADDR_VAR 0 1
20339: PUSH
20340: LD_INT 2
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 4
20348: PUSH
20349: LD_INT 5
20351: PUSH
20352: LD_INT 6
20354: PUSH
20355: LD_INT 7
20357: PUSH
20358: LD_INT 8
20360: PUSH
20361: LD_INT 9
20363: PUSH
20364: LD_INT 10
20366: PUSH
20367: LD_INT 11
20369: PUSH
20370: LD_INT 12
20372: PUSH
20373: LD_INT 13
20375: PUSH
20376: LD_INT 14
20378: PUSH
20379: LD_INT 15
20381: PUSH
20382: LD_INT 16
20384: PUSH
20385: LD_INT 17
20387: PUSH
20388: LD_INT 18
20390: PUSH
20391: LD_INT 19
20393: PUSH
20394: LD_INT 20
20396: PUSH
20397: LD_INT 21
20399: PUSH
20400: LD_INT 22
20402: PUSH
20403: LD_INT 23
20405: PUSH
20406: LD_INT 24
20408: PUSH
20409: LD_INT 25
20411: PUSH
20412: LD_INT 26
20414: PUSH
20415: LD_INT 28
20417: PUSH
20418: LD_INT 30
20420: PUSH
20421: LD_INT 31
20423: PUSH
20424: LD_INT 32
20426: PUSH
20427: LD_INT 34
20429: PUSH
20430: LD_INT 36
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: LIST
20455: LIST
20456: LIST
20457: LIST
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: PUSH
20466: LD_INT 101
20468: PUSH
20469: LD_INT 102
20471: PUSH
20472: LD_INT 103
20474: PUSH
20475: LD_INT 104
20477: PUSH
20478: LD_INT 105
20480: PUSH
20481: LD_INT 106
20483: PUSH
20484: LD_INT 107
20486: PUSH
20487: LD_INT 108
20489: PUSH
20490: LD_INT 109
20492: PUSH
20493: LD_INT 110
20495: PUSH
20496: LD_INT 111
20498: PUSH
20499: LD_INT 112
20501: PUSH
20502: LD_INT 114
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: LIST
20509: LIST
20510: LIST
20511: LIST
20512: LIST
20513: LIST
20514: LIST
20515: LIST
20516: LIST
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: ST_TO_ADDR
20524: GO 22111
20526: LD_INT 12
20528: DOUBLE
20529: EQUAL
20530: IFTRUE 20534
20532: GO 20742
20534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20535: LD_ADDR_VAR 0 1
20539: PUSH
20540: LD_INT 1
20542: PUSH
20543: LD_INT 2
20545: PUSH
20546: LD_INT 3
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: LD_INT 5
20554: PUSH
20555: LD_INT 6
20557: PUSH
20558: LD_INT 7
20560: PUSH
20561: LD_INT 8
20563: PUSH
20564: LD_INT 9
20566: PUSH
20567: LD_INT 10
20569: PUSH
20570: LD_INT 11
20572: PUSH
20573: LD_INT 12
20575: PUSH
20576: LD_INT 13
20578: PUSH
20579: LD_INT 14
20581: PUSH
20582: LD_INT 15
20584: PUSH
20585: LD_INT 16
20587: PUSH
20588: LD_INT 17
20590: PUSH
20591: LD_INT 18
20593: PUSH
20594: LD_INT 19
20596: PUSH
20597: LD_INT 20
20599: PUSH
20600: LD_INT 21
20602: PUSH
20603: LD_INT 22
20605: PUSH
20606: LD_INT 23
20608: PUSH
20609: LD_INT 24
20611: PUSH
20612: LD_INT 25
20614: PUSH
20615: LD_INT 26
20617: PUSH
20618: LD_INT 27
20620: PUSH
20621: LD_INT 28
20623: PUSH
20624: LD_INT 30
20626: PUSH
20627: LD_INT 31
20629: PUSH
20630: LD_INT 32
20632: PUSH
20633: LD_INT 33
20635: PUSH
20636: LD_INT 34
20638: PUSH
20639: LD_INT 36
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: LIST
20676: LIST
20677: PUSH
20678: LD_INT 101
20680: PUSH
20681: LD_INT 102
20683: PUSH
20684: LD_INT 103
20686: PUSH
20687: LD_INT 104
20689: PUSH
20690: LD_INT 105
20692: PUSH
20693: LD_INT 106
20695: PUSH
20696: LD_INT 107
20698: PUSH
20699: LD_INT 108
20701: PUSH
20702: LD_INT 109
20704: PUSH
20705: LD_INT 110
20707: PUSH
20708: LD_INT 111
20710: PUSH
20711: LD_INT 112
20713: PUSH
20714: LD_INT 113
20716: PUSH
20717: LD_INT 114
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: LIST
20724: LIST
20725: LIST
20726: LIST
20727: LIST
20728: LIST
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: PUSH
20736: EMPTY
20737: LIST
20738: LIST
20739: ST_TO_ADDR
20740: GO 22111
20742: LD_INT 13
20744: DOUBLE
20745: EQUAL
20746: IFTRUE 20750
20748: GO 20946
20750: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20751: LD_ADDR_VAR 0 1
20755: PUSH
20756: LD_INT 1
20758: PUSH
20759: LD_INT 2
20761: PUSH
20762: LD_INT 3
20764: PUSH
20765: LD_INT 4
20767: PUSH
20768: LD_INT 5
20770: PUSH
20771: LD_INT 8
20773: PUSH
20774: LD_INT 9
20776: PUSH
20777: LD_INT 10
20779: PUSH
20780: LD_INT 11
20782: PUSH
20783: LD_INT 12
20785: PUSH
20786: LD_INT 14
20788: PUSH
20789: LD_INT 15
20791: PUSH
20792: LD_INT 16
20794: PUSH
20795: LD_INT 17
20797: PUSH
20798: LD_INT 18
20800: PUSH
20801: LD_INT 19
20803: PUSH
20804: LD_INT 20
20806: PUSH
20807: LD_INT 21
20809: PUSH
20810: LD_INT 22
20812: PUSH
20813: LD_INT 23
20815: PUSH
20816: LD_INT 24
20818: PUSH
20819: LD_INT 25
20821: PUSH
20822: LD_INT 26
20824: PUSH
20825: LD_INT 27
20827: PUSH
20828: LD_INT 28
20830: PUSH
20831: LD_INT 30
20833: PUSH
20834: LD_INT 31
20836: PUSH
20837: LD_INT 32
20839: PUSH
20840: LD_INT 33
20842: PUSH
20843: LD_INT 34
20845: PUSH
20846: LD_INT 36
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: LIST
20858: LIST
20859: LIST
20860: LIST
20861: LIST
20862: LIST
20863: LIST
20864: LIST
20865: LIST
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: PUSH
20882: LD_INT 101
20884: PUSH
20885: LD_INT 102
20887: PUSH
20888: LD_INT 103
20890: PUSH
20891: LD_INT 104
20893: PUSH
20894: LD_INT 105
20896: PUSH
20897: LD_INT 106
20899: PUSH
20900: LD_INT 107
20902: PUSH
20903: LD_INT 108
20905: PUSH
20906: LD_INT 109
20908: PUSH
20909: LD_INT 110
20911: PUSH
20912: LD_INT 111
20914: PUSH
20915: LD_INT 112
20917: PUSH
20918: LD_INT 113
20920: PUSH
20921: LD_INT 114
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: LIST
20928: LIST
20929: LIST
20930: LIST
20931: LIST
20932: LIST
20933: LIST
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: ST_TO_ADDR
20944: GO 22111
20946: LD_INT 14
20948: DOUBLE
20949: EQUAL
20950: IFTRUE 20954
20952: GO 21166
20954: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20955: LD_ADDR_VAR 0 1
20959: PUSH
20960: LD_INT 1
20962: PUSH
20963: LD_INT 2
20965: PUSH
20966: LD_INT 3
20968: PUSH
20969: LD_INT 4
20971: PUSH
20972: LD_INT 5
20974: PUSH
20975: LD_INT 6
20977: PUSH
20978: LD_INT 7
20980: PUSH
20981: LD_INT 8
20983: PUSH
20984: LD_INT 9
20986: PUSH
20987: LD_INT 10
20989: PUSH
20990: LD_INT 11
20992: PUSH
20993: LD_INT 12
20995: PUSH
20996: LD_INT 13
20998: PUSH
20999: LD_INT 14
21001: PUSH
21002: LD_INT 15
21004: PUSH
21005: LD_INT 16
21007: PUSH
21008: LD_INT 17
21010: PUSH
21011: LD_INT 18
21013: PUSH
21014: LD_INT 19
21016: PUSH
21017: LD_INT 20
21019: PUSH
21020: LD_INT 21
21022: PUSH
21023: LD_INT 22
21025: PUSH
21026: LD_INT 23
21028: PUSH
21029: LD_INT 24
21031: PUSH
21032: LD_INT 25
21034: PUSH
21035: LD_INT 26
21037: PUSH
21038: LD_INT 27
21040: PUSH
21041: LD_INT 28
21043: PUSH
21044: LD_INT 29
21046: PUSH
21047: LD_INT 30
21049: PUSH
21050: LD_INT 31
21052: PUSH
21053: LD_INT 32
21055: PUSH
21056: LD_INT 33
21058: PUSH
21059: LD_INT 34
21061: PUSH
21062: LD_INT 36
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: LIST
21069: LIST
21070: LIST
21071: LIST
21072: LIST
21073: LIST
21074: LIST
21075: LIST
21076: LIST
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: PUSH
21102: LD_INT 101
21104: PUSH
21105: LD_INT 102
21107: PUSH
21108: LD_INT 103
21110: PUSH
21111: LD_INT 104
21113: PUSH
21114: LD_INT 105
21116: PUSH
21117: LD_INT 106
21119: PUSH
21120: LD_INT 107
21122: PUSH
21123: LD_INT 108
21125: PUSH
21126: LD_INT 109
21128: PUSH
21129: LD_INT 110
21131: PUSH
21132: LD_INT 111
21134: PUSH
21135: LD_INT 112
21137: PUSH
21138: LD_INT 113
21140: PUSH
21141: LD_INT 114
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: PUSH
21160: EMPTY
21161: LIST
21162: LIST
21163: ST_TO_ADDR
21164: GO 22111
21166: LD_INT 15
21168: DOUBLE
21169: EQUAL
21170: IFTRUE 21174
21172: GO 21386
21174: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21175: LD_ADDR_VAR 0 1
21179: PUSH
21180: LD_INT 1
21182: PUSH
21183: LD_INT 2
21185: PUSH
21186: LD_INT 3
21188: PUSH
21189: LD_INT 4
21191: PUSH
21192: LD_INT 5
21194: PUSH
21195: LD_INT 6
21197: PUSH
21198: LD_INT 7
21200: PUSH
21201: LD_INT 8
21203: PUSH
21204: LD_INT 9
21206: PUSH
21207: LD_INT 10
21209: PUSH
21210: LD_INT 11
21212: PUSH
21213: LD_INT 12
21215: PUSH
21216: LD_INT 13
21218: PUSH
21219: LD_INT 14
21221: PUSH
21222: LD_INT 15
21224: PUSH
21225: LD_INT 16
21227: PUSH
21228: LD_INT 17
21230: PUSH
21231: LD_INT 18
21233: PUSH
21234: LD_INT 19
21236: PUSH
21237: LD_INT 20
21239: PUSH
21240: LD_INT 21
21242: PUSH
21243: LD_INT 22
21245: PUSH
21246: LD_INT 23
21248: PUSH
21249: LD_INT 24
21251: PUSH
21252: LD_INT 25
21254: PUSH
21255: LD_INT 26
21257: PUSH
21258: LD_INT 27
21260: PUSH
21261: LD_INT 28
21263: PUSH
21264: LD_INT 29
21266: PUSH
21267: LD_INT 30
21269: PUSH
21270: LD_INT 31
21272: PUSH
21273: LD_INT 32
21275: PUSH
21276: LD_INT 33
21278: PUSH
21279: LD_INT 34
21281: PUSH
21282: LD_INT 36
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: LIST
21290: LIST
21291: LIST
21292: LIST
21293: LIST
21294: LIST
21295: LIST
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: PUSH
21322: LD_INT 101
21324: PUSH
21325: LD_INT 102
21327: PUSH
21328: LD_INT 103
21330: PUSH
21331: LD_INT 104
21333: PUSH
21334: LD_INT 105
21336: PUSH
21337: LD_INT 106
21339: PUSH
21340: LD_INT 107
21342: PUSH
21343: LD_INT 108
21345: PUSH
21346: LD_INT 109
21348: PUSH
21349: LD_INT 110
21351: PUSH
21352: LD_INT 111
21354: PUSH
21355: LD_INT 112
21357: PUSH
21358: LD_INT 113
21360: PUSH
21361: LD_INT 114
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: ST_TO_ADDR
21384: GO 22111
21386: LD_INT 16
21388: DOUBLE
21389: EQUAL
21390: IFTRUE 21394
21392: GO 21518
21394: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21395: LD_ADDR_VAR 0 1
21399: PUSH
21400: LD_INT 2
21402: PUSH
21403: LD_INT 4
21405: PUSH
21406: LD_INT 5
21408: PUSH
21409: LD_INT 7
21411: PUSH
21412: LD_INT 11
21414: PUSH
21415: LD_INT 12
21417: PUSH
21418: LD_INT 15
21420: PUSH
21421: LD_INT 16
21423: PUSH
21424: LD_INT 20
21426: PUSH
21427: LD_INT 21
21429: PUSH
21430: LD_INT 22
21432: PUSH
21433: LD_INT 23
21435: PUSH
21436: LD_INT 25
21438: PUSH
21439: LD_INT 26
21441: PUSH
21442: LD_INT 30
21444: PUSH
21445: LD_INT 31
21447: PUSH
21448: LD_INT 32
21450: PUSH
21451: LD_INT 33
21453: PUSH
21454: LD_INT 34
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: LIST
21463: LIST
21464: LIST
21465: LIST
21466: LIST
21467: LIST
21468: LIST
21469: LIST
21470: LIST
21471: LIST
21472: LIST
21473: LIST
21474: LIST
21475: LIST
21476: LIST
21477: PUSH
21478: LD_INT 101
21480: PUSH
21481: LD_INT 102
21483: PUSH
21484: LD_INT 103
21486: PUSH
21487: LD_INT 106
21489: PUSH
21490: LD_INT 108
21492: PUSH
21493: LD_INT 112
21495: PUSH
21496: LD_INT 113
21498: PUSH
21499: LD_INT 114
21501: PUSH
21502: EMPTY
21503: LIST
21504: LIST
21505: LIST
21506: LIST
21507: LIST
21508: LIST
21509: LIST
21510: LIST
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: ST_TO_ADDR
21516: GO 22111
21518: LD_INT 17
21520: DOUBLE
21521: EQUAL
21522: IFTRUE 21526
21524: GO 21738
21526: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21527: LD_ADDR_VAR 0 1
21531: PUSH
21532: LD_INT 1
21534: PUSH
21535: LD_INT 2
21537: PUSH
21538: LD_INT 3
21540: PUSH
21541: LD_INT 4
21543: PUSH
21544: LD_INT 5
21546: PUSH
21547: LD_INT 6
21549: PUSH
21550: LD_INT 7
21552: PUSH
21553: LD_INT 8
21555: PUSH
21556: LD_INT 9
21558: PUSH
21559: LD_INT 10
21561: PUSH
21562: LD_INT 11
21564: PUSH
21565: LD_INT 12
21567: PUSH
21568: LD_INT 13
21570: PUSH
21571: LD_INT 14
21573: PUSH
21574: LD_INT 15
21576: PUSH
21577: LD_INT 16
21579: PUSH
21580: LD_INT 17
21582: PUSH
21583: LD_INT 18
21585: PUSH
21586: LD_INT 19
21588: PUSH
21589: LD_INT 20
21591: PUSH
21592: LD_INT 21
21594: PUSH
21595: LD_INT 22
21597: PUSH
21598: LD_INT 23
21600: PUSH
21601: LD_INT 24
21603: PUSH
21604: LD_INT 25
21606: PUSH
21607: LD_INT 26
21609: PUSH
21610: LD_INT 27
21612: PUSH
21613: LD_INT 28
21615: PUSH
21616: LD_INT 29
21618: PUSH
21619: LD_INT 30
21621: PUSH
21622: LD_INT 31
21624: PUSH
21625: LD_INT 32
21627: PUSH
21628: LD_INT 33
21630: PUSH
21631: LD_INT 34
21633: PUSH
21634: LD_INT 36
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: LIST
21641: LIST
21642: LIST
21643: LIST
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: LIST
21671: LIST
21672: LIST
21673: PUSH
21674: LD_INT 101
21676: PUSH
21677: LD_INT 102
21679: PUSH
21680: LD_INT 103
21682: PUSH
21683: LD_INT 104
21685: PUSH
21686: LD_INT 105
21688: PUSH
21689: LD_INT 106
21691: PUSH
21692: LD_INT 107
21694: PUSH
21695: LD_INT 108
21697: PUSH
21698: LD_INT 109
21700: PUSH
21701: LD_INT 110
21703: PUSH
21704: LD_INT 111
21706: PUSH
21707: LD_INT 112
21709: PUSH
21710: LD_INT 113
21712: PUSH
21713: LD_INT 114
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: LIST
21720: LIST
21721: LIST
21722: LIST
21723: LIST
21724: LIST
21725: LIST
21726: LIST
21727: LIST
21728: LIST
21729: LIST
21730: LIST
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: ST_TO_ADDR
21736: GO 22111
21738: LD_INT 18
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21882
21746: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21747: LD_ADDR_VAR 0 1
21751: PUSH
21752: LD_INT 2
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 5
21760: PUSH
21761: LD_INT 7
21763: PUSH
21764: LD_INT 11
21766: PUSH
21767: LD_INT 12
21769: PUSH
21770: LD_INT 15
21772: PUSH
21773: LD_INT 16
21775: PUSH
21776: LD_INT 20
21778: PUSH
21779: LD_INT 21
21781: PUSH
21782: LD_INT 22
21784: PUSH
21785: LD_INT 23
21787: PUSH
21788: LD_INT 25
21790: PUSH
21791: LD_INT 26
21793: PUSH
21794: LD_INT 30
21796: PUSH
21797: LD_INT 31
21799: PUSH
21800: LD_INT 32
21802: PUSH
21803: LD_INT 33
21805: PUSH
21806: LD_INT 34
21808: PUSH
21809: LD_INT 35
21811: PUSH
21812: LD_INT 36
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: LIST
21819: LIST
21820: LIST
21821: LIST
21822: LIST
21823: LIST
21824: LIST
21825: LIST
21826: LIST
21827: LIST
21828: LIST
21829: LIST
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: LIST
21837: PUSH
21838: LD_INT 101
21840: PUSH
21841: LD_INT 102
21843: PUSH
21844: LD_INT 103
21846: PUSH
21847: LD_INT 106
21849: PUSH
21850: LD_INT 108
21852: PUSH
21853: LD_INT 112
21855: PUSH
21856: LD_INT 113
21858: PUSH
21859: LD_INT 114
21861: PUSH
21862: LD_INT 115
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: LIST
21869: LIST
21870: LIST
21871: LIST
21872: LIST
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: ST_TO_ADDR
21880: GO 22111
21882: LD_INT 19
21884: DOUBLE
21885: EQUAL
21886: IFTRUE 21890
21888: GO 22110
21890: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21891: LD_ADDR_VAR 0 1
21895: PUSH
21896: LD_INT 1
21898: PUSH
21899: LD_INT 2
21901: PUSH
21902: LD_INT 3
21904: PUSH
21905: LD_INT 4
21907: PUSH
21908: LD_INT 5
21910: PUSH
21911: LD_INT 6
21913: PUSH
21914: LD_INT 7
21916: PUSH
21917: LD_INT 8
21919: PUSH
21920: LD_INT 9
21922: PUSH
21923: LD_INT 10
21925: PUSH
21926: LD_INT 11
21928: PUSH
21929: LD_INT 12
21931: PUSH
21932: LD_INT 13
21934: PUSH
21935: LD_INT 14
21937: PUSH
21938: LD_INT 15
21940: PUSH
21941: LD_INT 16
21943: PUSH
21944: LD_INT 17
21946: PUSH
21947: LD_INT 18
21949: PUSH
21950: LD_INT 19
21952: PUSH
21953: LD_INT 20
21955: PUSH
21956: LD_INT 21
21958: PUSH
21959: LD_INT 22
21961: PUSH
21962: LD_INT 23
21964: PUSH
21965: LD_INT 24
21967: PUSH
21968: LD_INT 25
21970: PUSH
21971: LD_INT 26
21973: PUSH
21974: LD_INT 27
21976: PUSH
21977: LD_INT 28
21979: PUSH
21980: LD_INT 29
21982: PUSH
21983: LD_INT 30
21985: PUSH
21986: LD_INT 31
21988: PUSH
21989: LD_INT 32
21991: PUSH
21992: LD_INT 33
21994: PUSH
21995: LD_INT 34
21997: PUSH
21998: LD_INT 35
22000: PUSH
22001: LD_INT 36
22003: PUSH
22004: EMPTY
22005: LIST
22006: LIST
22007: LIST
22008: LIST
22009: LIST
22010: LIST
22011: LIST
22012: LIST
22013: LIST
22014: LIST
22015: LIST
22016: LIST
22017: LIST
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: LIST
22026: LIST
22027: LIST
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: PUSH
22042: LD_INT 101
22044: PUSH
22045: LD_INT 102
22047: PUSH
22048: LD_INT 103
22050: PUSH
22051: LD_INT 104
22053: PUSH
22054: LD_INT 105
22056: PUSH
22057: LD_INT 106
22059: PUSH
22060: LD_INT 107
22062: PUSH
22063: LD_INT 108
22065: PUSH
22066: LD_INT 109
22068: PUSH
22069: LD_INT 110
22071: PUSH
22072: LD_INT 111
22074: PUSH
22075: LD_INT 112
22077: PUSH
22078: LD_INT 113
22080: PUSH
22081: LD_INT 114
22083: PUSH
22084: LD_INT 115
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: LIST
22091: LIST
22092: LIST
22093: LIST
22094: LIST
22095: LIST
22096: LIST
22097: LIST
22098: LIST
22099: LIST
22100: LIST
22101: LIST
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: ST_TO_ADDR
22108: GO 22111
22110: POP
// end else
22111: GO 22330
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22113: LD_ADDR_VAR 0 1
22117: PUSH
22118: LD_INT 1
22120: PUSH
22121: LD_INT 2
22123: PUSH
22124: LD_INT 3
22126: PUSH
22127: LD_INT 4
22129: PUSH
22130: LD_INT 5
22132: PUSH
22133: LD_INT 6
22135: PUSH
22136: LD_INT 7
22138: PUSH
22139: LD_INT 8
22141: PUSH
22142: LD_INT 9
22144: PUSH
22145: LD_INT 10
22147: PUSH
22148: LD_INT 11
22150: PUSH
22151: LD_INT 12
22153: PUSH
22154: LD_INT 13
22156: PUSH
22157: LD_INT 14
22159: PUSH
22160: LD_INT 15
22162: PUSH
22163: LD_INT 16
22165: PUSH
22166: LD_INT 17
22168: PUSH
22169: LD_INT 18
22171: PUSH
22172: LD_INT 19
22174: PUSH
22175: LD_INT 20
22177: PUSH
22178: LD_INT 21
22180: PUSH
22181: LD_INT 22
22183: PUSH
22184: LD_INT 23
22186: PUSH
22187: LD_INT 24
22189: PUSH
22190: LD_INT 25
22192: PUSH
22193: LD_INT 26
22195: PUSH
22196: LD_INT 27
22198: PUSH
22199: LD_INT 28
22201: PUSH
22202: LD_INT 29
22204: PUSH
22205: LD_INT 30
22207: PUSH
22208: LD_INT 31
22210: PUSH
22211: LD_INT 32
22213: PUSH
22214: LD_INT 33
22216: PUSH
22217: LD_INT 34
22219: PUSH
22220: LD_INT 35
22222: PUSH
22223: LD_INT 36
22225: PUSH
22226: EMPTY
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: LIST
22232: LIST
22233: LIST
22234: LIST
22235: LIST
22236: LIST
22237: LIST
22238: LIST
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: PUSH
22264: LD_INT 101
22266: PUSH
22267: LD_INT 102
22269: PUSH
22270: LD_INT 103
22272: PUSH
22273: LD_INT 104
22275: PUSH
22276: LD_INT 105
22278: PUSH
22279: LD_INT 106
22281: PUSH
22282: LD_INT 107
22284: PUSH
22285: LD_INT 108
22287: PUSH
22288: LD_INT 109
22290: PUSH
22291: LD_INT 110
22293: PUSH
22294: LD_INT 111
22296: PUSH
22297: LD_INT 112
22299: PUSH
22300: LD_INT 113
22302: PUSH
22303: LD_INT 114
22305: PUSH
22306: LD_INT 115
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: LIST
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: ST_TO_ADDR
// if result then
22330: LD_VAR 0 1
22334: IFFALSE 22623
// begin normal :=  ;
22336: LD_ADDR_VAR 0 3
22340: PUSH
22341: LD_STRING 
22343: ST_TO_ADDR
// hardcore :=  ;
22344: LD_ADDR_VAR 0 4
22348: PUSH
22349: LD_STRING 
22351: ST_TO_ADDR
// for i = 1 to normalCounter do
22352: LD_ADDR_VAR 0 5
22356: PUSH
22357: DOUBLE
22358: LD_INT 1
22360: DEC
22361: ST_TO_ADDR
22362: LD_EXP 68
22366: PUSH
22367: FOR_TO
22368: IFFALSE 22469
// begin tmp := 0 ;
22370: LD_ADDR_VAR 0 2
22374: PUSH
22375: LD_STRING 0
22377: ST_TO_ADDR
// if result [ 1 ] then
22378: LD_VAR 0 1
22382: PUSH
22383: LD_INT 1
22385: ARRAY
22386: IFFALSE 22451
// if result [ 1 ] [ 1 ] = i then
22388: LD_VAR 0 1
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PUSH
22397: LD_INT 1
22399: ARRAY
22400: PUSH
22401: LD_VAR 0 5
22405: EQUAL
22406: IFFALSE 22451
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22408: LD_ADDR_VAR 0 1
22412: PUSH
22413: LD_VAR 0 1
22417: PPUSH
22418: LD_INT 1
22420: PPUSH
22421: LD_VAR 0 1
22425: PUSH
22426: LD_INT 1
22428: ARRAY
22429: PPUSH
22430: LD_INT 1
22432: PPUSH
22433: CALL_OW 3
22437: PPUSH
22438: CALL_OW 1
22442: ST_TO_ADDR
// tmp := 1 ;
22443: LD_ADDR_VAR 0 2
22447: PUSH
22448: LD_STRING 1
22450: ST_TO_ADDR
// end ; normal := normal & tmp ;
22451: LD_ADDR_VAR 0 3
22455: PUSH
22456: LD_VAR 0 3
22460: PUSH
22461: LD_VAR 0 2
22465: STR
22466: ST_TO_ADDR
// end ;
22467: GO 22367
22469: POP
22470: POP
// for i = 1 to hardcoreCounter do
22471: LD_ADDR_VAR 0 5
22475: PUSH
22476: DOUBLE
22477: LD_INT 1
22479: DEC
22480: ST_TO_ADDR
22481: LD_EXP 69
22485: PUSH
22486: FOR_TO
22487: IFFALSE 22592
// begin tmp := 0 ;
22489: LD_ADDR_VAR 0 2
22493: PUSH
22494: LD_STRING 0
22496: ST_TO_ADDR
// if result [ 2 ] then
22497: LD_VAR 0 1
22501: PUSH
22502: LD_INT 2
22504: ARRAY
22505: IFFALSE 22574
// if result [ 2 ] [ 1 ] = 100 + i then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 2
22514: ARRAY
22515: PUSH
22516: LD_INT 1
22518: ARRAY
22519: PUSH
22520: LD_INT 100
22522: PUSH
22523: LD_VAR 0 5
22527: PLUS
22528: EQUAL
22529: IFFALSE 22574
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22531: LD_ADDR_VAR 0 1
22535: PUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: LD_INT 2
22543: PPUSH
22544: LD_VAR 0 1
22548: PUSH
22549: LD_INT 2
22551: ARRAY
22552: PPUSH
22553: LD_INT 1
22555: PPUSH
22556: CALL_OW 3
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
// tmp := 1 ;
22566: LD_ADDR_VAR 0 2
22570: PUSH
22571: LD_STRING 1
22573: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22574: LD_ADDR_VAR 0 4
22578: PUSH
22579: LD_VAR 0 4
22583: PUSH
22584: LD_VAR 0 2
22588: STR
22589: ST_TO_ADDR
// end ;
22590: GO 22486
22592: POP
22593: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22594: LD_STRING getStreamItemsFromMission("
22596: PUSH
22597: LD_VAR 0 3
22601: STR
22602: PUSH
22603: LD_STRING ","
22605: STR
22606: PUSH
22607: LD_VAR 0 4
22611: STR
22612: PUSH
22613: LD_STRING ")
22615: STR
22616: PPUSH
22617: CALL_OW 559
// end else
22621: GO 22630
// ToLua ( getStreamItemsFromMission("","") ) ;
22623: LD_STRING getStreamItemsFromMission("","")
22625: PPUSH
22626: CALL_OW 559
// end ;
22630: LD_VAR 0 1
22634: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22635: LD_VAR 0 2
22639: PUSH
22640: LD_INT 100
22642: EQUAL
22643: IFFALSE 23592
// begin if not StreamModeActive then
22645: LD_EXP 67
22649: NOT
22650: IFFALSE 22660
// StreamModeActive := true ;
22652: LD_ADDR_EXP 67
22656: PUSH
22657: LD_INT 1
22659: ST_TO_ADDR
// if p3 = 0 then
22660: LD_VAR 0 3
22664: PUSH
22665: LD_INT 0
22667: EQUAL
22668: IFFALSE 22674
// InitStreamMode ;
22670: CALL 18713 0 0
// if p3 = 1 then
22674: LD_VAR 0 3
22678: PUSH
22679: LD_INT 1
22681: EQUAL
22682: IFFALSE 22692
// sRocket := true ;
22684: LD_ADDR_EXP 72
22688: PUSH
22689: LD_INT 1
22691: ST_TO_ADDR
// if p3 = 2 then
22692: LD_VAR 0 3
22696: PUSH
22697: LD_INT 2
22699: EQUAL
22700: IFFALSE 22710
// sSpeed := true ;
22702: LD_ADDR_EXP 71
22706: PUSH
22707: LD_INT 1
22709: ST_TO_ADDR
// if p3 = 3 then
22710: LD_VAR 0 3
22714: PUSH
22715: LD_INT 3
22717: EQUAL
22718: IFFALSE 22728
// sEngine := true ;
22720: LD_ADDR_EXP 73
22724: PUSH
22725: LD_INT 1
22727: ST_TO_ADDR
// if p3 = 4 then
22728: LD_VAR 0 3
22732: PUSH
22733: LD_INT 4
22735: EQUAL
22736: IFFALSE 22746
// sSpec := true ;
22738: LD_ADDR_EXP 70
22742: PUSH
22743: LD_INT 1
22745: ST_TO_ADDR
// if p3 = 5 then
22746: LD_VAR 0 3
22750: PUSH
22751: LD_INT 5
22753: EQUAL
22754: IFFALSE 22764
// sLevel := true ;
22756: LD_ADDR_EXP 74
22760: PUSH
22761: LD_INT 1
22763: ST_TO_ADDR
// if p3 = 6 then
22764: LD_VAR 0 3
22768: PUSH
22769: LD_INT 6
22771: EQUAL
22772: IFFALSE 22782
// sArmoury := true ;
22774: LD_ADDR_EXP 75
22778: PUSH
22779: LD_INT 1
22781: ST_TO_ADDR
// if p3 = 7 then
22782: LD_VAR 0 3
22786: PUSH
22787: LD_INT 7
22789: EQUAL
22790: IFFALSE 22800
// sRadar := true ;
22792: LD_ADDR_EXP 76
22796: PUSH
22797: LD_INT 1
22799: ST_TO_ADDR
// if p3 = 8 then
22800: LD_VAR 0 3
22804: PUSH
22805: LD_INT 8
22807: EQUAL
22808: IFFALSE 22818
// sBunker := true ;
22810: LD_ADDR_EXP 77
22814: PUSH
22815: LD_INT 1
22817: ST_TO_ADDR
// if p3 = 9 then
22818: LD_VAR 0 3
22822: PUSH
22823: LD_INT 9
22825: EQUAL
22826: IFFALSE 22836
// sHack := true ;
22828: LD_ADDR_EXP 78
22832: PUSH
22833: LD_INT 1
22835: ST_TO_ADDR
// if p3 = 10 then
22836: LD_VAR 0 3
22840: PUSH
22841: LD_INT 10
22843: EQUAL
22844: IFFALSE 22854
// sFire := true ;
22846: LD_ADDR_EXP 79
22850: PUSH
22851: LD_INT 1
22853: ST_TO_ADDR
// if p3 = 11 then
22854: LD_VAR 0 3
22858: PUSH
22859: LD_INT 11
22861: EQUAL
22862: IFFALSE 22872
// sRefresh := true ;
22864: LD_ADDR_EXP 80
22868: PUSH
22869: LD_INT 1
22871: ST_TO_ADDR
// if p3 = 12 then
22872: LD_VAR 0 3
22876: PUSH
22877: LD_INT 12
22879: EQUAL
22880: IFFALSE 22890
// sExp := true ;
22882: LD_ADDR_EXP 81
22886: PUSH
22887: LD_INT 1
22889: ST_TO_ADDR
// if p3 = 13 then
22890: LD_VAR 0 3
22894: PUSH
22895: LD_INT 13
22897: EQUAL
22898: IFFALSE 22908
// sDepot := true ;
22900: LD_ADDR_EXP 82
22904: PUSH
22905: LD_INT 1
22907: ST_TO_ADDR
// if p3 = 14 then
22908: LD_VAR 0 3
22912: PUSH
22913: LD_INT 14
22915: EQUAL
22916: IFFALSE 22926
// sFlag := true ;
22918: LD_ADDR_EXP 83
22922: PUSH
22923: LD_INT 1
22925: ST_TO_ADDR
// if p3 = 15 then
22926: LD_VAR 0 3
22930: PUSH
22931: LD_INT 15
22933: EQUAL
22934: IFFALSE 22944
// sKamikadze := true ;
22936: LD_ADDR_EXP 91
22940: PUSH
22941: LD_INT 1
22943: ST_TO_ADDR
// if p3 = 16 then
22944: LD_VAR 0 3
22948: PUSH
22949: LD_INT 16
22951: EQUAL
22952: IFFALSE 22962
// sTroll := true ;
22954: LD_ADDR_EXP 92
22958: PUSH
22959: LD_INT 1
22961: ST_TO_ADDR
// if p3 = 17 then
22962: LD_VAR 0 3
22966: PUSH
22967: LD_INT 17
22969: EQUAL
22970: IFFALSE 22980
// sSlow := true ;
22972: LD_ADDR_EXP 93
22976: PUSH
22977: LD_INT 1
22979: ST_TO_ADDR
// if p3 = 18 then
22980: LD_VAR 0 3
22984: PUSH
22985: LD_INT 18
22987: EQUAL
22988: IFFALSE 22998
// sLack := true ;
22990: LD_ADDR_EXP 94
22994: PUSH
22995: LD_INT 1
22997: ST_TO_ADDR
// if p3 = 19 then
22998: LD_VAR 0 3
23002: PUSH
23003: LD_INT 19
23005: EQUAL
23006: IFFALSE 23016
// sTank := true ;
23008: LD_ADDR_EXP 96
23012: PUSH
23013: LD_INT 1
23015: ST_TO_ADDR
// if p3 = 20 then
23016: LD_VAR 0 3
23020: PUSH
23021: LD_INT 20
23023: EQUAL
23024: IFFALSE 23034
// sRemote := true ;
23026: LD_ADDR_EXP 97
23030: PUSH
23031: LD_INT 1
23033: ST_TO_ADDR
// if p3 = 21 then
23034: LD_VAR 0 3
23038: PUSH
23039: LD_INT 21
23041: EQUAL
23042: IFFALSE 23052
// sPowell := true ;
23044: LD_ADDR_EXP 98
23048: PUSH
23049: LD_INT 1
23051: ST_TO_ADDR
// if p3 = 22 then
23052: LD_VAR 0 3
23056: PUSH
23057: LD_INT 22
23059: EQUAL
23060: IFFALSE 23070
// sTeleport := true ;
23062: LD_ADDR_EXP 101
23066: PUSH
23067: LD_INT 1
23069: ST_TO_ADDR
// if p3 = 23 then
23070: LD_VAR 0 3
23074: PUSH
23075: LD_INT 23
23077: EQUAL
23078: IFFALSE 23088
// sOilTower := true ;
23080: LD_ADDR_EXP 103
23084: PUSH
23085: LD_INT 1
23087: ST_TO_ADDR
// if p3 = 24 then
23088: LD_VAR 0 3
23092: PUSH
23093: LD_INT 24
23095: EQUAL
23096: IFFALSE 23106
// sShovel := true ;
23098: LD_ADDR_EXP 104
23102: PUSH
23103: LD_INT 1
23105: ST_TO_ADDR
// if p3 = 25 then
23106: LD_VAR 0 3
23110: PUSH
23111: LD_INT 25
23113: EQUAL
23114: IFFALSE 23124
// sSheik := true ;
23116: LD_ADDR_EXP 105
23120: PUSH
23121: LD_INT 1
23123: ST_TO_ADDR
// if p3 = 26 then
23124: LD_VAR 0 3
23128: PUSH
23129: LD_INT 26
23131: EQUAL
23132: IFFALSE 23142
// sEarthquake := true ;
23134: LD_ADDR_EXP 107
23138: PUSH
23139: LD_INT 1
23141: ST_TO_ADDR
// if p3 = 27 then
23142: LD_VAR 0 3
23146: PUSH
23147: LD_INT 27
23149: EQUAL
23150: IFFALSE 23160
// sAI := true ;
23152: LD_ADDR_EXP 108
23156: PUSH
23157: LD_INT 1
23159: ST_TO_ADDR
// if p3 = 28 then
23160: LD_VAR 0 3
23164: PUSH
23165: LD_INT 28
23167: EQUAL
23168: IFFALSE 23178
// sCargo := true ;
23170: LD_ADDR_EXP 111
23174: PUSH
23175: LD_INT 1
23177: ST_TO_ADDR
// if p3 = 29 then
23178: LD_VAR 0 3
23182: PUSH
23183: LD_INT 29
23185: EQUAL
23186: IFFALSE 23196
// sDLaser := true ;
23188: LD_ADDR_EXP 112
23192: PUSH
23193: LD_INT 1
23195: ST_TO_ADDR
// if p3 = 30 then
23196: LD_VAR 0 3
23200: PUSH
23201: LD_INT 30
23203: EQUAL
23204: IFFALSE 23214
// sExchange := true ;
23206: LD_ADDR_EXP 113
23210: PUSH
23211: LD_INT 1
23213: ST_TO_ADDR
// if p3 = 31 then
23214: LD_VAR 0 3
23218: PUSH
23219: LD_INT 31
23221: EQUAL
23222: IFFALSE 23232
// sFac := true ;
23224: LD_ADDR_EXP 114
23228: PUSH
23229: LD_INT 1
23231: ST_TO_ADDR
// if p3 = 32 then
23232: LD_VAR 0 3
23236: PUSH
23237: LD_INT 32
23239: EQUAL
23240: IFFALSE 23250
// sPower := true ;
23242: LD_ADDR_EXP 115
23246: PUSH
23247: LD_INT 1
23249: ST_TO_ADDR
// if p3 = 33 then
23250: LD_VAR 0 3
23254: PUSH
23255: LD_INT 33
23257: EQUAL
23258: IFFALSE 23268
// sRandom := true ;
23260: LD_ADDR_EXP 116
23264: PUSH
23265: LD_INT 1
23267: ST_TO_ADDR
// if p3 = 34 then
23268: LD_VAR 0 3
23272: PUSH
23273: LD_INT 34
23275: EQUAL
23276: IFFALSE 23286
// sShield := true ;
23278: LD_ADDR_EXP 117
23282: PUSH
23283: LD_INT 1
23285: ST_TO_ADDR
// if p3 = 35 then
23286: LD_VAR 0 3
23290: PUSH
23291: LD_INT 35
23293: EQUAL
23294: IFFALSE 23304
// sTime := true ;
23296: LD_ADDR_EXP 118
23300: PUSH
23301: LD_INT 1
23303: ST_TO_ADDR
// if p3 = 36 then
23304: LD_VAR 0 3
23308: PUSH
23309: LD_INT 36
23311: EQUAL
23312: IFFALSE 23322
// sTools := true ;
23314: LD_ADDR_EXP 119
23318: PUSH
23319: LD_INT 1
23321: ST_TO_ADDR
// if p3 = 101 then
23322: LD_VAR 0 3
23326: PUSH
23327: LD_INT 101
23329: EQUAL
23330: IFFALSE 23340
// sSold := true ;
23332: LD_ADDR_EXP 84
23336: PUSH
23337: LD_INT 1
23339: ST_TO_ADDR
// if p3 = 102 then
23340: LD_VAR 0 3
23344: PUSH
23345: LD_INT 102
23347: EQUAL
23348: IFFALSE 23358
// sDiff := true ;
23350: LD_ADDR_EXP 85
23354: PUSH
23355: LD_INT 1
23357: ST_TO_ADDR
// if p3 = 103 then
23358: LD_VAR 0 3
23362: PUSH
23363: LD_INT 103
23365: EQUAL
23366: IFFALSE 23376
// sFog := true ;
23368: LD_ADDR_EXP 88
23372: PUSH
23373: LD_INT 1
23375: ST_TO_ADDR
// if p3 = 104 then
23376: LD_VAR 0 3
23380: PUSH
23381: LD_INT 104
23383: EQUAL
23384: IFFALSE 23394
// sReset := true ;
23386: LD_ADDR_EXP 89
23390: PUSH
23391: LD_INT 1
23393: ST_TO_ADDR
// if p3 = 105 then
23394: LD_VAR 0 3
23398: PUSH
23399: LD_INT 105
23401: EQUAL
23402: IFFALSE 23412
// sSun := true ;
23404: LD_ADDR_EXP 90
23408: PUSH
23409: LD_INT 1
23411: ST_TO_ADDR
// if p3 = 106 then
23412: LD_VAR 0 3
23416: PUSH
23417: LD_INT 106
23419: EQUAL
23420: IFFALSE 23430
// sTiger := true ;
23422: LD_ADDR_EXP 86
23426: PUSH
23427: LD_INT 1
23429: ST_TO_ADDR
// if p3 = 107 then
23430: LD_VAR 0 3
23434: PUSH
23435: LD_INT 107
23437: EQUAL
23438: IFFALSE 23448
// sBomb := true ;
23440: LD_ADDR_EXP 87
23444: PUSH
23445: LD_INT 1
23447: ST_TO_ADDR
// if p3 = 108 then
23448: LD_VAR 0 3
23452: PUSH
23453: LD_INT 108
23455: EQUAL
23456: IFFALSE 23466
// sWound := true ;
23458: LD_ADDR_EXP 95
23462: PUSH
23463: LD_INT 1
23465: ST_TO_ADDR
// if p3 = 109 then
23466: LD_VAR 0 3
23470: PUSH
23471: LD_INT 109
23473: EQUAL
23474: IFFALSE 23484
// sBetray := true ;
23476: LD_ADDR_EXP 99
23480: PUSH
23481: LD_INT 1
23483: ST_TO_ADDR
// if p3 = 110 then
23484: LD_VAR 0 3
23488: PUSH
23489: LD_INT 110
23491: EQUAL
23492: IFFALSE 23502
// sContamin := true ;
23494: LD_ADDR_EXP 100
23498: PUSH
23499: LD_INT 1
23501: ST_TO_ADDR
// if p3 = 111 then
23502: LD_VAR 0 3
23506: PUSH
23507: LD_INT 111
23509: EQUAL
23510: IFFALSE 23520
// sOil := true ;
23512: LD_ADDR_EXP 102
23516: PUSH
23517: LD_INT 1
23519: ST_TO_ADDR
// if p3 = 112 then
23520: LD_VAR 0 3
23524: PUSH
23525: LD_INT 112
23527: EQUAL
23528: IFFALSE 23538
// sStu := true ;
23530: LD_ADDR_EXP 106
23534: PUSH
23535: LD_INT 1
23537: ST_TO_ADDR
// if p3 = 113 then
23538: LD_VAR 0 3
23542: PUSH
23543: LD_INT 113
23545: EQUAL
23546: IFFALSE 23556
// sBazooka := true ;
23548: LD_ADDR_EXP 109
23552: PUSH
23553: LD_INT 1
23555: ST_TO_ADDR
// if p3 = 114 then
23556: LD_VAR 0 3
23560: PUSH
23561: LD_INT 114
23563: EQUAL
23564: IFFALSE 23574
// sMortar := true ;
23566: LD_ADDR_EXP 110
23570: PUSH
23571: LD_INT 1
23573: ST_TO_ADDR
// if p3 = 115 then
23574: LD_VAR 0 3
23578: PUSH
23579: LD_INT 115
23581: EQUAL
23582: IFFALSE 23592
// sRanger := true ;
23584: LD_ADDR_EXP 120
23588: PUSH
23589: LD_INT 1
23591: ST_TO_ADDR
// end ; end ;
23592: PPOPN 6
23594: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23595: LD_EXP 67
23599: PUSH
23600: LD_EXP 72
23604: AND
23605: IFFALSE 23729
23607: GO 23609
23609: DISABLE
23610: LD_INT 0
23612: PPUSH
23613: PPUSH
// begin enable ;
23614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23615: LD_ADDR_VAR 0 2
23619: PUSH
23620: LD_INT 22
23622: PUSH
23623: LD_OWVAR 2
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 2
23634: PUSH
23635: LD_INT 34
23637: PUSH
23638: LD_INT 7
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: LD_INT 34
23647: PUSH
23648: LD_INT 45
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: PUSH
23655: LD_INT 34
23657: PUSH
23658: LD_INT 28
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 34
23667: PUSH
23668: LD_INT 47
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: LIST
23680: LIST
23681: PUSH
23682: EMPTY
23683: LIST
23684: LIST
23685: PPUSH
23686: CALL_OW 69
23690: ST_TO_ADDR
// if not tmp then
23691: LD_VAR 0 2
23695: NOT
23696: IFFALSE 23700
// exit ;
23698: GO 23729
// for i in tmp do
23700: LD_ADDR_VAR 0 1
23704: PUSH
23705: LD_VAR 0 2
23709: PUSH
23710: FOR_IN
23711: IFFALSE 23727
// begin SetLives ( i , 0 ) ;
23713: LD_VAR 0 1
23717: PPUSH
23718: LD_INT 0
23720: PPUSH
23721: CALL_OW 234
// end ;
23725: GO 23710
23727: POP
23728: POP
// end ;
23729: PPOPN 2
23731: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23732: LD_EXP 67
23736: PUSH
23737: LD_EXP 73
23741: AND
23742: IFFALSE 23826
23744: GO 23746
23746: DISABLE
23747: LD_INT 0
23749: PPUSH
23750: PPUSH
// begin enable ;
23751: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23752: LD_ADDR_VAR 0 2
23756: PUSH
23757: LD_INT 22
23759: PUSH
23760: LD_OWVAR 2
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 32
23771: PUSH
23772: LD_INT 3
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PPUSH
23783: CALL_OW 69
23787: ST_TO_ADDR
// if not tmp then
23788: LD_VAR 0 2
23792: NOT
23793: IFFALSE 23797
// exit ;
23795: GO 23826
// for i in tmp do
23797: LD_ADDR_VAR 0 1
23801: PUSH
23802: LD_VAR 0 2
23806: PUSH
23807: FOR_IN
23808: IFFALSE 23824
// begin SetLives ( i , 0 ) ;
23810: LD_VAR 0 1
23814: PPUSH
23815: LD_INT 0
23817: PPUSH
23818: CALL_OW 234
// end ;
23822: GO 23807
23824: POP
23825: POP
// end ;
23826: PPOPN 2
23828: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23829: LD_EXP 67
23833: PUSH
23834: LD_EXP 70
23838: AND
23839: IFFALSE 23932
23841: GO 23843
23843: DISABLE
23844: LD_INT 0
23846: PPUSH
// begin enable ;
23847: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23848: LD_ADDR_VAR 0 1
23852: PUSH
23853: LD_INT 22
23855: PUSH
23856: LD_OWVAR 2
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 2
23867: PUSH
23868: LD_INT 25
23870: PUSH
23871: LD_INT 5
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: PUSH
23878: LD_INT 25
23880: PUSH
23881: LD_INT 9
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 25
23890: PUSH
23891: LD_INT 8
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: PPUSH
23908: CALL_OW 69
23912: PUSH
23913: FOR_IN
23914: IFFALSE 23930
// begin SetClass ( i , 1 ) ;
23916: LD_VAR 0 1
23920: PPUSH
23921: LD_INT 1
23923: PPUSH
23924: CALL_OW 336
// end ;
23928: GO 23913
23930: POP
23931: POP
// end ;
23932: PPOPN 1
23934: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23935: LD_EXP 67
23939: PUSH
23940: LD_EXP 71
23944: AND
23945: PUSH
23946: LD_OWVAR 65
23950: PUSH
23951: LD_INT 7
23953: LESS
23954: AND
23955: IFFALSE 23969
23957: GO 23959
23959: DISABLE
// begin enable ;
23960: ENABLE
// game_speed := 7 ;
23961: LD_ADDR_OWVAR 65
23965: PUSH
23966: LD_INT 7
23968: ST_TO_ADDR
// end ;
23969: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23970: LD_EXP 67
23974: PUSH
23975: LD_EXP 74
23979: AND
23980: IFFALSE 24182
23982: GO 23984
23984: DISABLE
23985: LD_INT 0
23987: PPUSH
23988: PPUSH
23989: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23990: LD_ADDR_VAR 0 3
23994: PUSH
23995: LD_INT 81
23997: PUSH
23998: LD_OWVAR 2
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PUSH
24007: LD_INT 21
24009: PUSH
24010: LD_INT 1
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PPUSH
24021: CALL_OW 69
24025: ST_TO_ADDR
// if not tmp then
24026: LD_VAR 0 3
24030: NOT
24031: IFFALSE 24035
// exit ;
24033: GO 24182
// if tmp > 5 then
24035: LD_VAR 0 3
24039: PUSH
24040: LD_INT 5
24042: GREATER
24043: IFFALSE 24055
// k := 5 else
24045: LD_ADDR_VAR 0 2
24049: PUSH
24050: LD_INT 5
24052: ST_TO_ADDR
24053: GO 24065
// k := tmp ;
24055: LD_ADDR_VAR 0 2
24059: PUSH
24060: LD_VAR 0 3
24064: ST_TO_ADDR
// for i := 1 to k do
24065: LD_ADDR_VAR 0 1
24069: PUSH
24070: DOUBLE
24071: LD_INT 1
24073: DEC
24074: ST_TO_ADDR
24075: LD_VAR 0 2
24079: PUSH
24080: FOR_TO
24081: IFFALSE 24180
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24083: LD_VAR 0 3
24087: PUSH
24088: LD_VAR 0 1
24092: ARRAY
24093: PPUSH
24094: LD_VAR 0 1
24098: PUSH
24099: LD_INT 4
24101: MOD
24102: PUSH
24103: LD_INT 1
24105: PLUS
24106: PPUSH
24107: CALL_OW 259
24111: PUSH
24112: LD_INT 10
24114: LESS
24115: IFFALSE 24178
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24117: LD_VAR 0 3
24121: PUSH
24122: LD_VAR 0 1
24126: ARRAY
24127: PPUSH
24128: LD_VAR 0 1
24132: PUSH
24133: LD_INT 4
24135: MOD
24136: PUSH
24137: LD_INT 1
24139: PLUS
24140: PPUSH
24141: LD_VAR 0 3
24145: PUSH
24146: LD_VAR 0 1
24150: ARRAY
24151: PPUSH
24152: LD_VAR 0 1
24156: PUSH
24157: LD_INT 4
24159: MOD
24160: PUSH
24161: LD_INT 1
24163: PLUS
24164: PPUSH
24165: CALL_OW 259
24169: PUSH
24170: LD_INT 1
24172: PLUS
24173: PPUSH
24174: CALL_OW 237
24178: GO 24080
24180: POP
24181: POP
// end ;
24182: PPOPN 3
24184: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24185: LD_EXP 67
24189: PUSH
24190: LD_EXP 75
24194: AND
24195: IFFALSE 24215
24197: GO 24199
24199: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24200: LD_INT 4
24202: PPUSH
24203: LD_OWVAR 2
24207: PPUSH
24208: LD_INT 0
24210: PPUSH
24211: CALL_OW 324
24215: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24216: LD_EXP 67
24220: PUSH
24221: LD_EXP 104
24225: AND
24226: IFFALSE 24246
24228: GO 24230
24230: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24231: LD_INT 19
24233: PPUSH
24234: LD_OWVAR 2
24238: PPUSH
24239: LD_INT 0
24241: PPUSH
24242: CALL_OW 324
24246: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24247: LD_EXP 67
24251: PUSH
24252: LD_EXP 76
24256: AND
24257: IFFALSE 24359
24259: GO 24261
24261: DISABLE
24262: LD_INT 0
24264: PPUSH
24265: PPUSH
// begin enable ;
24266: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24267: LD_ADDR_VAR 0 2
24271: PUSH
24272: LD_INT 22
24274: PUSH
24275: LD_OWVAR 2
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 2
24286: PUSH
24287: LD_INT 34
24289: PUSH
24290: LD_INT 11
24292: PUSH
24293: EMPTY
24294: LIST
24295: LIST
24296: PUSH
24297: LD_INT 34
24299: PUSH
24300: LD_INT 30
24302: PUSH
24303: EMPTY
24304: LIST
24305: LIST
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: LIST
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: PPUSH
24316: CALL_OW 69
24320: ST_TO_ADDR
// if not tmp then
24321: LD_VAR 0 2
24325: NOT
24326: IFFALSE 24330
// exit ;
24328: GO 24359
// for i in tmp do
24330: LD_ADDR_VAR 0 1
24334: PUSH
24335: LD_VAR 0 2
24339: PUSH
24340: FOR_IN
24341: IFFALSE 24357
// begin SetLives ( i , 0 ) ;
24343: LD_VAR 0 1
24347: PPUSH
24348: LD_INT 0
24350: PPUSH
24351: CALL_OW 234
// end ;
24355: GO 24340
24357: POP
24358: POP
// end ;
24359: PPOPN 2
24361: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24362: LD_EXP 67
24366: PUSH
24367: LD_EXP 77
24371: AND
24372: IFFALSE 24392
24374: GO 24376
24376: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24377: LD_INT 32
24379: PPUSH
24380: LD_OWVAR 2
24384: PPUSH
24385: LD_INT 0
24387: PPUSH
24388: CALL_OW 324
24392: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24393: LD_EXP 67
24397: PUSH
24398: LD_EXP 78
24402: AND
24403: IFFALSE 24584
24405: GO 24407
24407: DISABLE
24408: LD_INT 0
24410: PPUSH
24411: PPUSH
24412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24413: LD_ADDR_VAR 0 2
24417: PUSH
24418: LD_INT 22
24420: PUSH
24421: LD_OWVAR 2
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: PUSH
24430: LD_INT 33
24432: PUSH
24433: LD_INT 3
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PPUSH
24444: CALL_OW 69
24448: ST_TO_ADDR
// if not tmp then
24449: LD_VAR 0 2
24453: NOT
24454: IFFALSE 24458
// exit ;
24456: GO 24584
// side := 0 ;
24458: LD_ADDR_VAR 0 3
24462: PUSH
24463: LD_INT 0
24465: ST_TO_ADDR
// for i := 1 to 8 do
24466: LD_ADDR_VAR 0 1
24470: PUSH
24471: DOUBLE
24472: LD_INT 1
24474: DEC
24475: ST_TO_ADDR
24476: LD_INT 8
24478: PUSH
24479: FOR_TO
24480: IFFALSE 24528
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24482: LD_OWVAR 2
24486: PUSH
24487: LD_VAR 0 1
24491: NONEQUAL
24492: PUSH
24493: LD_OWVAR 2
24497: PPUSH
24498: LD_VAR 0 1
24502: PPUSH
24503: CALL_OW 81
24507: PUSH
24508: LD_INT 2
24510: EQUAL
24511: AND
24512: IFFALSE 24526
// begin side := i ;
24514: LD_ADDR_VAR 0 3
24518: PUSH
24519: LD_VAR 0 1
24523: ST_TO_ADDR
// break ;
24524: GO 24528
// end ;
24526: GO 24479
24528: POP
24529: POP
// if not side then
24530: LD_VAR 0 3
24534: NOT
24535: IFFALSE 24539
// exit ;
24537: GO 24584
// for i := 1 to tmp do
24539: LD_ADDR_VAR 0 1
24543: PUSH
24544: DOUBLE
24545: LD_INT 1
24547: DEC
24548: ST_TO_ADDR
24549: LD_VAR 0 2
24553: PUSH
24554: FOR_TO
24555: IFFALSE 24582
// if Prob ( 60 ) then
24557: LD_INT 60
24559: PPUSH
24560: CALL_OW 13
24564: IFFALSE 24580
// SetSide ( i , side ) ;
24566: LD_VAR 0 1
24570: PPUSH
24571: LD_VAR 0 3
24575: PPUSH
24576: CALL_OW 235
24580: GO 24554
24582: POP
24583: POP
// end ;
24584: PPOPN 3
24586: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24587: LD_EXP 67
24591: PUSH
24592: LD_EXP 80
24596: AND
24597: IFFALSE 24716
24599: GO 24601
24601: DISABLE
24602: LD_INT 0
24604: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24605: LD_ADDR_VAR 0 1
24609: PUSH
24610: LD_INT 22
24612: PUSH
24613: LD_OWVAR 2
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: LD_INT 21
24624: PUSH
24625: LD_INT 1
24627: PUSH
24628: EMPTY
24629: LIST
24630: LIST
24631: PUSH
24632: LD_INT 3
24634: PUSH
24635: LD_INT 23
24637: PUSH
24638: LD_INT 0
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: PUSH
24645: EMPTY
24646: LIST
24647: LIST
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: LIST
24653: PPUSH
24654: CALL_OW 69
24658: PUSH
24659: FOR_IN
24660: IFFALSE 24714
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24662: LD_VAR 0 1
24666: PPUSH
24667: CALL_OW 257
24671: PUSH
24672: LD_INT 1
24674: PUSH
24675: LD_INT 2
24677: PUSH
24678: LD_INT 3
24680: PUSH
24681: LD_INT 4
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: LIST
24688: LIST
24689: IN
24690: IFFALSE 24712
// SetClass ( un , rand ( 1 , 4 ) ) ;
24692: LD_VAR 0 1
24696: PPUSH
24697: LD_INT 1
24699: PPUSH
24700: LD_INT 4
24702: PPUSH
24703: CALL_OW 12
24707: PPUSH
24708: CALL_OW 336
24712: GO 24659
24714: POP
24715: POP
// end ;
24716: PPOPN 1
24718: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24719: LD_EXP 67
24723: PUSH
24724: LD_EXP 79
24728: AND
24729: IFFALSE 24808
24731: GO 24733
24733: DISABLE
24734: LD_INT 0
24736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24737: LD_ADDR_VAR 0 1
24741: PUSH
24742: LD_INT 22
24744: PUSH
24745: LD_OWVAR 2
24749: PUSH
24750: EMPTY
24751: LIST
24752: LIST
24753: PUSH
24754: LD_INT 21
24756: PUSH
24757: LD_INT 3
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PPUSH
24768: CALL_OW 69
24772: ST_TO_ADDR
// if not tmp then
24773: LD_VAR 0 1
24777: NOT
24778: IFFALSE 24782
// exit ;
24780: GO 24808
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24782: LD_VAR 0 1
24786: PUSH
24787: LD_INT 1
24789: PPUSH
24790: LD_VAR 0 1
24794: PPUSH
24795: CALL_OW 12
24799: ARRAY
24800: PPUSH
24801: LD_INT 100
24803: PPUSH
24804: CALL_OW 234
// end ;
24808: PPOPN 1
24810: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24811: LD_EXP 67
24815: PUSH
24816: LD_EXP 81
24820: AND
24821: IFFALSE 24919
24823: GO 24825
24825: DISABLE
24826: LD_INT 0
24828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24829: LD_ADDR_VAR 0 1
24833: PUSH
24834: LD_INT 22
24836: PUSH
24837: LD_OWVAR 2
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: PUSH
24846: LD_INT 21
24848: PUSH
24849: LD_INT 1
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: PPUSH
24860: CALL_OW 69
24864: ST_TO_ADDR
// if not tmp then
24865: LD_VAR 0 1
24869: NOT
24870: IFFALSE 24874
// exit ;
24872: GO 24919
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24874: LD_VAR 0 1
24878: PUSH
24879: LD_INT 1
24881: PPUSH
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 12
24891: ARRAY
24892: PPUSH
24893: LD_INT 1
24895: PPUSH
24896: LD_INT 4
24898: PPUSH
24899: CALL_OW 12
24903: PPUSH
24904: LD_INT 3000
24906: PPUSH
24907: LD_INT 9000
24909: PPUSH
24910: CALL_OW 12
24914: PPUSH
24915: CALL_OW 492
// end ;
24919: PPOPN 1
24921: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24922: LD_EXP 67
24926: PUSH
24927: LD_EXP 82
24931: AND
24932: IFFALSE 24952
24934: GO 24936
24936: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24937: LD_INT 1
24939: PPUSH
24940: LD_OWVAR 2
24944: PPUSH
24945: LD_INT 0
24947: PPUSH
24948: CALL_OW 324
24952: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24953: LD_EXP 67
24957: PUSH
24958: LD_EXP 83
24962: AND
24963: IFFALSE 25046
24965: GO 24967
24967: DISABLE
24968: LD_INT 0
24970: PPUSH
24971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24972: LD_ADDR_VAR 0 2
24976: PUSH
24977: LD_INT 22
24979: PUSH
24980: LD_OWVAR 2
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: PUSH
24989: LD_INT 21
24991: PUSH
24992: LD_INT 3
24994: PUSH
24995: EMPTY
24996: LIST
24997: LIST
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PPUSH
25003: CALL_OW 69
25007: ST_TO_ADDR
// if not tmp then
25008: LD_VAR 0 2
25012: NOT
25013: IFFALSE 25017
// exit ;
25015: GO 25046
// for i in tmp do
25017: LD_ADDR_VAR 0 1
25021: PUSH
25022: LD_VAR 0 2
25026: PUSH
25027: FOR_IN
25028: IFFALSE 25044
// SetBLevel ( i , 10 ) ;
25030: LD_VAR 0 1
25034: PPUSH
25035: LD_INT 10
25037: PPUSH
25038: CALL_OW 241
25042: GO 25027
25044: POP
25045: POP
// end ;
25046: PPOPN 2
25048: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25049: LD_EXP 67
25053: PUSH
25054: LD_EXP 84
25058: AND
25059: IFFALSE 25170
25061: GO 25063
25063: DISABLE
25064: LD_INT 0
25066: PPUSH
25067: PPUSH
25068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25069: LD_ADDR_VAR 0 3
25073: PUSH
25074: LD_INT 22
25076: PUSH
25077: LD_OWVAR 2
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: LD_INT 25
25088: PUSH
25089: LD_INT 1
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PUSH
25096: EMPTY
25097: LIST
25098: LIST
25099: PPUSH
25100: CALL_OW 69
25104: ST_TO_ADDR
// if not tmp then
25105: LD_VAR 0 3
25109: NOT
25110: IFFALSE 25114
// exit ;
25112: GO 25170
// un := tmp [ rand ( 1 , tmp ) ] ;
25114: LD_ADDR_VAR 0 2
25118: PUSH
25119: LD_VAR 0 3
25123: PUSH
25124: LD_INT 1
25126: PPUSH
25127: LD_VAR 0 3
25131: PPUSH
25132: CALL_OW 12
25136: ARRAY
25137: ST_TO_ADDR
// if Crawls ( un ) then
25138: LD_VAR 0 2
25142: PPUSH
25143: CALL_OW 318
25147: IFFALSE 25158
// ComWalk ( un ) ;
25149: LD_VAR 0 2
25153: PPUSH
25154: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25158: LD_VAR 0 2
25162: PPUSH
25163: LD_INT 5
25165: PPUSH
25166: CALL_OW 336
// end ;
25170: PPOPN 3
25172: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25173: LD_EXP 67
25177: PUSH
25178: LD_EXP 85
25182: AND
25183: PUSH
25184: LD_OWVAR 67
25188: PUSH
25189: LD_INT 3
25191: LESS
25192: AND
25193: IFFALSE 25212
25195: GO 25197
25197: DISABLE
// Difficulty := Difficulty + 1 ;
25198: LD_ADDR_OWVAR 67
25202: PUSH
25203: LD_OWVAR 67
25207: PUSH
25208: LD_INT 1
25210: PLUS
25211: ST_TO_ADDR
25212: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25213: LD_EXP 67
25217: PUSH
25218: LD_EXP 86
25222: AND
25223: IFFALSE 25326
25225: GO 25227
25227: DISABLE
25228: LD_INT 0
25230: PPUSH
// begin for i := 1 to 5 do
25231: LD_ADDR_VAR 0 1
25235: PUSH
25236: DOUBLE
25237: LD_INT 1
25239: DEC
25240: ST_TO_ADDR
25241: LD_INT 5
25243: PUSH
25244: FOR_TO
25245: IFFALSE 25324
// begin uc_nation := nation_nature ;
25247: LD_ADDR_OWVAR 21
25251: PUSH
25252: LD_INT 0
25254: ST_TO_ADDR
// uc_side := 0 ;
25255: LD_ADDR_OWVAR 20
25259: PUSH
25260: LD_INT 0
25262: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25263: LD_ADDR_OWVAR 29
25267: PUSH
25268: LD_INT 12
25270: PUSH
25271: LD_INT 12
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: ST_TO_ADDR
// hc_agressivity := 20 ;
25278: LD_ADDR_OWVAR 35
25282: PUSH
25283: LD_INT 20
25285: ST_TO_ADDR
// hc_class := class_tiger ;
25286: LD_ADDR_OWVAR 28
25290: PUSH
25291: LD_INT 14
25293: ST_TO_ADDR
// hc_gallery :=  ;
25294: LD_ADDR_OWVAR 33
25298: PUSH
25299: LD_STRING 
25301: ST_TO_ADDR
// hc_name :=  ;
25302: LD_ADDR_OWVAR 26
25306: PUSH
25307: LD_STRING 
25309: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25310: CALL_OW 44
25314: PPUSH
25315: LD_INT 0
25317: PPUSH
25318: CALL_OW 51
// end ;
25322: GO 25244
25324: POP
25325: POP
// end ;
25326: PPOPN 1
25328: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25329: LD_EXP 67
25333: PUSH
25334: LD_EXP 87
25338: AND
25339: IFFALSE 25348
25341: GO 25343
25343: DISABLE
// StreamSibBomb ;
25344: CALL 25349 0 0
25348: END
// export function StreamSibBomb ; var i , x , y ; begin
25349: LD_INT 0
25351: PPUSH
25352: PPUSH
25353: PPUSH
25354: PPUSH
// result := false ;
25355: LD_ADDR_VAR 0 1
25359: PUSH
25360: LD_INT 0
25362: ST_TO_ADDR
// for i := 1 to 16 do
25363: LD_ADDR_VAR 0 2
25367: PUSH
25368: DOUBLE
25369: LD_INT 1
25371: DEC
25372: ST_TO_ADDR
25373: LD_INT 16
25375: PUSH
25376: FOR_TO
25377: IFFALSE 25576
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25379: LD_ADDR_VAR 0 3
25383: PUSH
25384: LD_INT 10
25386: PUSH
25387: LD_INT 20
25389: PUSH
25390: LD_INT 30
25392: PUSH
25393: LD_INT 40
25395: PUSH
25396: LD_INT 50
25398: PUSH
25399: LD_INT 60
25401: PUSH
25402: LD_INT 70
25404: PUSH
25405: LD_INT 80
25407: PUSH
25408: LD_INT 90
25410: PUSH
25411: LD_INT 100
25413: PUSH
25414: LD_INT 110
25416: PUSH
25417: LD_INT 120
25419: PUSH
25420: LD_INT 130
25422: PUSH
25423: LD_INT 140
25425: PUSH
25426: LD_INT 150
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: PUSH
25446: LD_INT 1
25448: PPUSH
25449: LD_INT 15
25451: PPUSH
25452: CALL_OW 12
25456: ARRAY
25457: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25458: LD_ADDR_VAR 0 4
25462: PUSH
25463: LD_INT 10
25465: PUSH
25466: LD_INT 20
25468: PUSH
25469: LD_INT 30
25471: PUSH
25472: LD_INT 40
25474: PUSH
25475: LD_INT 50
25477: PUSH
25478: LD_INT 60
25480: PUSH
25481: LD_INT 70
25483: PUSH
25484: LD_INT 80
25486: PUSH
25487: LD_INT 90
25489: PUSH
25490: LD_INT 100
25492: PUSH
25493: LD_INT 110
25495: PUSH
25496: LD_INT 120
25498: PUSH
25499: LD_INT 130
25501: PUSH
25502: LD_INT 140
25504: PUSH
25505: LD_INT 150
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: LIST
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 1
25527: PPUSH
25528: LD_INT 15
25530: PPUSH
25531: CALL_OW 12
25535: ARRAY
25536: ST_TO_ADDR
// if ValidHex ( x , y ) then
25537: LD_VAR 0 3
25541: PPUSH
25542: LD_VAR 0 4
25546: PPUSH
25547: CALL_OW 488
25551: IFFALSE 25574
// begin result := [ x , y ] ;
25553: LD_ADDR_VAR 0 1
25557: PUSH
25558: LD_VAR 0 3
25562: PUSH
25563: LD_VAR 0 4
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: ST_TO_ADDR
// break ;
25572: GO 25576
// end ; end ;
25574: GO 25376
25576: POP
25577: POP
// if result then
25578: LD_VAR 0 1
25582: IFFALSE 25642
// begin ToLua ( playSibBomb() ) ;
25584: LD_STRING playSibBomb()
25586: PPUSH
25587: CALL_OW 559
// wait ( 0 0$14 ) ;
25591: LD_INT 490
25593: PPUSH
25594: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25598: LD_VAR 0 1
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 1
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25620: LD_VAR 0 1
25624: PUSH
25625: LD_INT 1
25627: ARRAY
25628: PPUSH
25629: LD_VAR 0 1
25633: PUSH
25634: LD_INT 2
25636: ARRAY
25637: PPUSH
25638: CALL_OW 429
// end ; end ;
25642: LD_VAR 0 1
25646: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25647: LD_EXP 67
25651: PUSH
25652: LD_EXP 89
25656: AND
25657: IFFALSE 25669
25659: GO 25661
25661: DISABLE
// YouLost (  ) ;
25662: LD_STRING 
25664: PPUSH
25665: CALL_OW 104
25669: END
// every 0 0$1 trigger StreamModeActive and sFog do
25670: LD_EXP 67
25674: PUSH
25675: LD_EXP 88
25679: AND
25680: IFFALSE 25694
25682: GO 25684
25684: DISABLE
// FogOff ( your_side ) ;
25685: LD_OWVAR 2
25689: PPUSH
25690: CALL_OW 344
25694: END
// every 0 0$1 trigger StreamModeActive and sSun do
25695: LD_EXP 67
25699: PUSH
25700: LD_EXP 90
25704: AND
25705: IFFALSE 25733
25707: GO 25709
25709: DISABLE
// begin solar_recharge_percent := 0 ;
25710: LD_ADDR_OWVAR 79
25714: PUSH
25715: LD_INT 0
25717: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25718: LD_INT 10500
25720: PPUSH
25721: CALL_OW 67
// solar_recharge_percent := 100 ;
25725: LD_ADDR_OWVAR 79
25729: PUSH
25730: LD_INT 100
25732: ST_TO_ADDR
// end ;
25733: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25734: LD_EXP 67
25738: PUSH
25739: LD_EXP 91
25743: AND
25744: IFFALSE 25983
25746: GO 25748
25748: DISABLE
25749: LD_INT 0
25751: PPUSH
25752: PPUSH
25753: PPUSH
// begin tmp := [ ] ;
25754: LD_ADDR_VAR 0 3
25758: PUSH
25759: EMPTY
25760: ST_TO_ADDR
// for i := 1 to 6 do
25761: LD_ADDR_VAR 0 1
25765: PUSH
25766: DOUBLE
25767: LD_INT 1
25769: DEC
25770: ST_TO_ADDR
25771: LD_INT 6
25773: PUSH
25774: FOR_TO
25775: IFFALSE 25880
// begin uc_nation := nation_nature ;
25777: LD_ADDR_OWVAR 21
25781: PUSH
25782: LD_INT 0
25784: ST_TO_ADDR
// uc_side := 0 ;
25785: LD_ADDR_OWVAR 20
25789: PUSH
25790: LD_INT 0
25792: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25793: LD_ADDR_OWVAR 29
25797: PUSH
25798: LD_INT 12
25800: PUSH
25801: LD_INT 12
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: ST_TO_ADDR
// hc_agressivity := 20 ;
25808: LD_ADDR_OWVAR 35
25812: PUSH
25813: LD_INT 20
25815: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25816: LD_ADDR_OWVAR 28
25820: PUSH
25821: LD_INT 17
25823: ST_TO_ADDR
// hc_gallery :=  ;
25824: LD_ADDR_OWVAR 33
25828: PUSH
25829: LD_STRING 
25831: ST_TO_ADDR
// hc_name :=  ;
25832: LD_ADDR_OWVAR 26
25836: PUSH
25837: LD_STRING 
25839: ST_TO_ADDR
// un := CreateHuman ;
25840: LD_ADDR_VAR 0 2
25844: PUSH
25845: CALL_OW 44
25849: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25850: LD_VAR 0 2
25854: PPUSH
25855: LD_INT 1
25857: PPUSH
25858: CALL_OW 51
// tmp := tmp ^ un ;
25862: LD_ADDR_VAR 0 3
25866: PUSH
25867: LD_VAR 0 3
25871: PUSH
25872: LD_VAR 0 2
25876: ADD
25877: ST_TO_ADDR
// end ;
25878: GO 25774
25880: POP
25881: POP
// repeat wait ( 0 0$1 ) ;
25882: LD_INT 35
25884: PPUSH
25885: CALL_OW 67
// for un in tmp do
25889: LD_ADDR_VAR 0 2
25893: PUSH
25894: LD_VAR 0 3
25898: PUSH
25899: FOR_IN
25900: IFFALSE 25974
// begin if IsDead ( un ) then
25902: LD_VAR 0 2
25906: PPUSH
25907: CALL_OW 301
25911: IFFALSE 25931
// begin tmp := tmp diff un ;
25913: LD_ADDR_VAR 0 3
25917: PUSH
25918: LD_VAR 0 3
25922: PUSH
25923: LD_VAR 0 2
25927: DIFF
25928: ST_TO_ADDR
// continue ;
25929: GO 25899
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25931: LD_VAR 0 2
25935: PPUSH
25936: LD_INT 3
25938: PUSH
25939: LD_INT 22
25941: PUSH
25942: LD_INT 0
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: EMPTY
25950: LIST
25951: LIST
25952: PPUSH
25953: CALL_OW 69
25957: PPUSH
25958: LD_VAR 0 2
25962: PPUSH
25963: CALL_OW 74
25967: PPUSH
25968: CALL_OW 115
// end ;
25972: GO 25899
25974: POP
25975: POP
// until not tmp ;
25976: LD_VAR 0 3
25980: NOT
25981: IFFALSE 25882
// end ;
25983: PPOPN 3
25985: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25986: LD_EXP 67
25990: PUSH
25991: LD_EXP 92
25995: AND
25996: IFFALSE 26050
25998: GO 26000
26000: DISABLE
// begin ToLua ( displayTroll(); ) ;
26001: LD_STRING displayTroll();
26003: PPUSH
26004: CALL_OW 559
// wait ( 3 3$00 ) ;
26008: LD_INT 6300
26010: PPUSH
26011: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26015: LD_STRING hideTroll();
26017: PPUSH
26018: CALL_OW 559
// wait ( 1 1$00 ) ;
26022: LD_INT 2100
26024: PPUSH
26025: CALL_OW 67
// ToLua ( displayTroll(); ) ;
26029: LD_STRING displayTroll();
26031: PPUSH
26032: CALL_OW 559
// wait ( 1 1$00 ) ;
26036: LD_INT 2100
26038: PPUSH
26039: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26043: LD_STRING hideTroll();
26045: PPUSH
26046: CALL_OW 559
// end ;
26050: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26051: LD_EXP 67
26055: PUSH
26056: LD_EXP 93
26060: AND
26061: IFFALSE 26124
26063: GO 26065
26065: DISABLE
26066: LD_INT 0
26068: PPUSH
// begin p := 0 ;
26069: LD_ADDR_VAR 0 1
26073: PUSH
26074: LD_INT 0
26076: ST_TO_ADDR
// repeat game_speed := 1 ;
26077: LD_ADDR_OWVAR 65
26081: PUSH
26082: LD_INT 1
26084: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26085: LD_INT 35
26087: PPUSH
26088: CALL_OW 67
// p := p + 1 ;
26092: LD_ADDR_VAR 0 1
26096: PUSH
26097: LD_VAR 0 1
26101: PUSH
26102: LD_INT 1
26104: PLUS
26105: ST_TO_ADDR
// until p >= 60 ;
26106: LD_VAR 0 1
26110: PUSH
26111: LD_INT 60
26113: GREATEREQUAL
26114: IFFALSE 26077
// game_speed := 4 ;
26116: LD_ADDR_OWVAR 65
26120: PUSH
26121: LD_INT 4
26123: ST_TO_ADDR
// end ;
26124: PPOPN 1
26126: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26127: LD_EXP 67
26131: PUSH
26132: LD_EXP 94
26136: AND
26137: IFFALSE 26283
26139: GO 26141
26141: DISABLE
26142: LD_INT 0
26144: PPUSH
26145: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26146: LD_ADDR_VAR 0 1
26150: PUSH
26151: LD_INT 22
26153: PUSH
26154: LD_OWVAR 2
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: LD_INT 2
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 0
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 30
26178: PUSH
26179: LD_INT 1
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: LIST
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PPUSH
26195: CALL_OW 69
26199: ST_TO_ADDR
// if not depot then
26200: LD_VAR 0 1
26204: NOT
26205: IFFALSE 26209
// exit ;
26207: GO 26283
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26209: LD_ADDR_VAR 0 2
26213: PUSH
26214: LD_VAR 0 1
26218: PUSH
26219: LD_INT 1
26221: PPUSH
26222: LD_VAR 0 1
26226: PPUSH
26227: CALL_OW 12
26231: ARRAY
26232: PPUSH
26233: CALL_OW 274
26237: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26238: LD_VAR 0 2
26242: PPUSH
26243: LD_INT 1
26245: PPUSH
26246: LD_INT 0
26248: PPUSH
26249: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26253: LD_VAR 0 2
26257: PPUSH
26258: LD_INT 2
26260: PPUSH
26261: LD_INT 0
26263: PPUSH
26264: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26268: LD_VAR 0 2
26272: PPUSH
26273: LD_INT 3
26275: PPUSH
26276: LD_INT 0
26278: PPUSH
26279: CALL_OW 277
// end ;
26283: PPOPN 2
26285: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26286: LD_EXP 67
26290: PUSH
26291: LD_EXP 95
26295: AND
26296: IFFALSE 26393
26298: GO 26300
26300: DISABLE
26301: LD_INT 0
26303: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26304: LD_ADDR_VAR 0 1
26308: PUSH
26309: LD_INT 22
26311: PUSH
26312: LD_OWVAR 2
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 21
26323: PUSH
26324: LD_INT 1
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: LD_INT 3
26333: PUSH
26334: LD_INT 23
26336: PUSH
26337: LD_INT 0
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: LIST
26352: PPUSH
26353: CALL_OW 69
26357: ST_TO_ADDR
// if not tmp then
26358: LD_VAR 0 1
26362: NOT
26363: IFFALSE 26367
// exit ;
26365: GO 26393
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26367: LD_VAR 0 1
26371: PUSH
26372: LD_INT 1
26374: PPUSH
26375: LD_VAR 0 1
26379: PPUSH
26380: CALL_OW 12
26384: ARRAY
26385: PPUSH
26386: LD_INT 200
26388: PPUSH
26389: CALL_OW 234
// end ;
26393: PPOPN 1
26395: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26396: LD_EXP 67
26400: PUSH
26401: LD_EXP 96
26405: AND
26406: IFFALSE 26485
26408: GO 26410
26410: DISABLE
26411: LD_INT 0
26413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26414: LD_ADDR_VAR 0 1
26418: PUSH
26419: LD_INT 22
26421: PUSH
26422: LD_OWVAR 2
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 21
26433: PUSH
26434: LD_INT 2
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: EMPTY
26442: LIST
26443: LIST
26444: PPUSH
26445: CALL_OW 69
26449: ST_TO_ADDR
// if not tmp then
26450: LD_VAR 0 1
26454: NOT
26455: IFFALSE 26459
// exit ;
26457: GO 26485
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26459: LD_VAR 0 1
26463: PUSH
26464: LD_INT 1
26466: PPUSH
26467: LD_VAR 0 1
26471: PPUSH
26472: CALL_OW 12
26476: ARRAY
26477: PPUSH
26478: LD_INT 60
26480: PPUSH
26481: CALL_OW 234
// end ;
26485: PPOPN 1
26487: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26488: LD_EXP 67
26492: PUSH
26493: LD_EXP 97
26497: AND
26498: IFFALSE 26597
26500: GO 26502
26502: DISABLE
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
// begin enable ;
26507: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26508: LD_ADDR_VAR 0 1
26512: PUSH
26513: LD_INT 22
26515: PUSH
26516: LD_OWVAR 2
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 61
26527: PUSH
26528: EMPTY
26529: LIST
26530: PUSH
26531: LD_INT 33
26533: PUSH
26534: LD_INT 2
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: LIST
26545: PPUSH
26546: CALL_OW 69
26550: ST_TO_ADDR
// if not tmp then
26551: LD_VAR 0 1
26555: NOT
26556: IFFALSE 26560
// exit ;
26558: GO 26597
// for i in tmp do
26560: LD_ADDR_VAR 0 2
26564: PUSH
26565: LD_VAR 0 1
26569: PUSH
26570: FOR_IN
26571: IFFALSE 26595
// if IsControledBy ( i ) then
26573: LD_VAR 0 2
26577: PPUSH
26578: CALL_OW 312
26582: IFFALSE 26593
// ComUnlink ( i ) ;
26584: LD_VAR 0 2
26588: PPUSH
26589: CALL_OW 136
26593: GO 26570
26595: POP
26596: POP
// end ;
26597: PPOPN 2
26599: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26600: LD_EXP 67
26604: PUSH
26605: LD_EXP 98
26609: AND
26610: IFFALSE 26750
26612: GO 26614
26614: DISABLE
26615: LD_INT 0
26617: PPUSH
26618: PPUSH
// begin ToLua ( displayPowell(); ) ;
26619: LD_STRING displayPowell();
26621: PPUSH
26622: CALL_OW 559
// uc_side := 0 ;
26626: LD_ADDR_OWVAR 20
26630: PUSH
26631: LD_INT 0
26633: ST_TO_ADDR
// uc_nation := 2 ;
26634: LD_ADDR_OWVAR 21
26638: PUSH
26639: LD_INT 2
26641: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26642: LD_ADDR_OWVAR 37
26646: PUSH
26647: LD_INT 14
26649: ST_TO_ADDR
// vc_engine := engine_siberite ;
26650: LD_ADDR_OWVAR 39
26654: PUSH
26655: LD_INT 3
26657: ST_TO_ADDR
// vc_control := control_apeman ;
26658: LD_ADDR_OWVAR 38
26662: PUSH
26663: LD_INT 5
26665: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26666: LD_ADDR_OWVAR 40
26670: PUSH
26671: LD_INT 29
26673: ST_TO_ADDR
// un := CreateVehicle ;
26674: LD_ADDR_VAR 0 2
26678: PUSH
26679: CALL_OW 45
26683: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26684: LD_VAR 0 2
26688: PPUSH
26689: LD_INT 1
26691: PPUSH
26692: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26696: LD_INT 35
26698: PPUSH
26699: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26703: LD_VAR 0 2
26707: PPUSH
26708: LD_INT 22
26710: PUSH
26711: LD_OWVAR 2
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PPUSH
26720: CALL_OW 69
26724: PPUSH
26725: LD_VAR 0 2
26729: PPUSH
26730: CALL_OW 74
26734: PPUSH
26735: CALL_OW 115
// until IsDead ( un ) ;
26739: LD_VAR 0 2
26743: PPUSH
26744: CALL_OW 301
26748: IFFALSE 26696
// end ;
26750: PPOPN 2
26752: END
// every 0 0$1 trigger StreamModeActive and sStu do
26753: LD_EXP 67
26757: PUSH
26758: LD_EXP 106
26762: AND
26763: IFFALSE 26779
26765: GO 26767
26767: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26768: LD_STRING displayStucuk();
26770: PPUSH
26771: CALL_OW 559
// ResetFog ;
26775: CALL_OW 335
// end ;
26779: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26780: LD_EXP 67
26784: PUSH
26785: LD_EXP 99
26789: AND
26790: IFFALSE 26931
26792: GO 26794
26794: DISABLE
26795: LD_INT 0
26797: PPUSH
26798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26799: LD_ADDR_VAR 0 2
26803: PUSH
26804: LD_INT 22
26806: PUSH
26807: LD_OWVAR 2
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 21
26818: PUSH
26819: LD_INT 1
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: PPUSH
26830: CALL_OW 69
26834: ST_TO_ADDR
// if not tmp then
26835: LD_VAR 0 2
26839: NOT
26840: IFFALSE 26844
// exit ;
26842: GO 26931
// un := tmp [ rand ( 1 , tmp ) ] ;
26844: LD_ADDR_VAR 0 1
26848: PUSH
26849: LD_VAR 0 2
26853: PUSH
26854: LD_INT 1
26856: PPUSH
26857: LD_VAR 0 2
26861: PPUSH
26862: CALL_OW 12
26866: ARRAY
26867: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26868: LD_VAR 0 1
26872: PPUSH
26873: LD_INT 0
26875: PPUSH
26876: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26880: LD_VAR 0 1
26884: PPUSH
26885: LD_OWVAR 3
26889: PUSH
26890: LD_VAR 0 1
26894: DIFF
26895: PPUSH
26896: LD_VAR 0 1
26900: PPUSH
26901: CALL_OW 74
26905: PPUSH
26906: CALL_OW 115
// wait ( 0 0$20 ) ;
26910: LD_INT 700
26912: PPUSH
26913: CALL_OW 67
// SetSide ( un , your_side ) ;
26917: LD_VAR 0 1
26921: PPUSH
26922: LD_OWVAR 2
26926: PPUSH
26927: CALL_OW 235
// end ;
26931: PPOPN 2
26933: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26934: LD_EXP 67
26938: PUSH
26939: LD_EXP 100
26943: AND
26944: IFFALSE 27050
26946: GO 26948
26948: DISABLE
26949: LD_INT 0
26951: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26952: LD_ADDR_VAR 0 1
26956: PUSH
26957: LD_INT 22
26959: PUSH
26960: LD_OWVAR 2
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 2
26971: PUSH
26972: LD_INT 30
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 30
26984: PUSH
26985: LD_INT 1
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: LIST
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PPUSH
27001: CALL_OW 69
27005: ST_TO_ADDR
// if not depot then
27006: LD_VAR 0 1
27010: NOT
27011: IFFALSE 27015
// exit ;
27013: GO 27050
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
27015: LD_VAR 0 1
27019: PUSH
27020: LD_INT 1
27022: ARRAY
27023: PPUSH
27024: CALL_OW 250
27028: PPUSH
27029: LD_VAR 0 1
27033: PUSH
27034: LD_INT 1
27036: ARRAY
27037: PPUSH
27038: CALL_OW 251
27042: PPUSH
27043: LD_INT 70
27045: PPUSH
27046: CALL_OW 495
// end ;
27050: PPOPN 1
27052: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27053: LD_EXP 67
27057: PUSH
27058: LD_EXP 101
27062: AND
27063: IFFALSE 27274
27065: GO 27067
27067: DISABLE
27068: LD_INT 0
27070: PPUSH
27071: PPUSH
27072: PPUSH
27073: PPUSH
27074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27075: LD_ADDR_VAR 0 5
27079: PUSH
27080: LD_INT 22
27082: PUSH
27083: LD_OWVAR 2
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 21
27094: PUSH
27095: LD_INT 1
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PPUSH
27106: CALL_OW 69
27110: ST_TO_ADDR
// if not tmp then
27111: LD_VAR 0 5
27115: NOT
27116: IFFALSE 27120
// exit ;
27118: GO 27274
// for i in tmp do
27120: LD_ADDR_VAR 0 1
27124: PUSH
27125: LD_VAR 0 5
27129: PUSH
27130: FOR_IN
27131: IFFALSE 27272
// begin d := rand ( 0 , 5 ) ;
27133: LD_ADDR_VAR 0 4
27137: PUSH
27138: LD_INT 0
27140: PPUSH
27141: LD_INT 5
27143: PPUSH
27144: CALL_OW 12
27148: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27149: LD_ADDR_VAR 0 2
27153: PUSH
27154: LD_VAR 0 1
27158: PPUSH
27159: CALL_OW 250
27163: PPUSH
27164: LD_VAR 0 4
27168: PPUSH
27169: LD_INT 3
27171: PPUSH
27172: LD_INT 12
27174: PPUSH
27175: CALL_OW 12
27179: PPUSH
27180: CALL_OW 272
27184: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27185: LD_ADDR_VAR 0 3
27189: PUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL_OW 251
27199: PPUSH
27200: LD_VAR 0 4
27204: PPUSH
27205: LD_INT 3
27207: PPUSH
27208: LD_INT 12
27210: PPUSH
27211: CALL_OW 12
27215: PPUSH
27216: CALL_OW 273
27220: ST_TO_ADDR
// if ValidHex ( x , y ) then
27221: LD_VAR 0 2
27225: PPUSH
27226: LD_VAR 0 3
27230: PPUSH
27231: CALL_OW 488
27235: IFFALSE 27270
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27237: LD_VAR 0 1
27241: PPUSH
27242: LD_VAR 0 2
27246: PPUSH
27247: LD_VAR 0 3
27251: PPUSH
27252: LD_INT 3
27254: PPUSH
27255: LD_INT 6
27257: PPUSH
27258: CALL_OW 12
27262: PPUSH
27263: LD_INT 1
27265: PPUSH
27266: CALL_OW 483
// end ;
27270: GO 27130
27272: POP
27273: POP
// end ;
27274: PPOPN 5
27276: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27277: LD_EXP 67
27281: PUSH
27282: LD_EXP 102
27286: AND
27287: IFFALSE 27381
27289: GO 27291
27291: DISABLE
27292: LD_INT 0
27294: PPUSH
27295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27296: LD_ADDR_VAR 0 2
27300: PUSH
27301: LD_INT 22
27303: PUSH
27304: LD_OWVAR 2
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: PUSH
27313: LD_INT 32
27315: PUSH
27316: LD_INT 1
27318: PUSH
27319: EMPTY
27320: LIST
27321: LIST
27322: PUSH
27323: LD_INT 21
27325: PUSH
27326: LD_INT 2
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: LIST
27337: PPUSH
27338: CALL_OW 69
27342: ST_TO_ADDR
// if not tmp then
27343: LD_VAR 0 2
27347: NOT
27348: IFFALSE 27352
// exit ;
27350: GO 27381
// for i in tmp do
27352: LD_ADDR_VAR 0 1
27356: PUSH
27357: LD_VAR 0 2
27361: PUSH
27362: FOR_IN
27363: IFFALSE 27379
// SetFuel ( i , 0 ) ;
27365: LD_VAR 0 1
27369: PPUSH
27370: LD_INT 0
27372: PPUSH
27373: CALL_OW 240
27377: GO 27362
27379: POP
27380: POP
// end ;
27381: PPOPN 2
27383: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27384: LD_EXP 67
27388: PUSH
27389: LD_EXP 103
27393: AND
27394: IFFALSE 27460
27396: GO 27398
27398: DISABLE
27399: LD_INT 0
27401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27402: LD_ADDR_VAR 0 1
27406: PUSH
27407: LD_INT 22
27409: PUSH
27410: LD_OWVAR 2
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 30
27421: PUSH
27422: LD_INT 29
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PPUSH
27433: CALL_OW 69
27437: ST_TO_ADDR
// if not tmp then
27438: LD_VAR 0 1
27442: NOT
27443: IFFALSE 27447
// exit ;
27445: GO 27460
// DestroyUnit ( tmp [ 1 ] ) ;
27447: LD_VAR 0 1
27451: PUSH
27452: LD_INT 1
27454: ARRAY
27455: PPUSH
27456: CALL_OW 65
// end ;
27460: PPOPN 1
27462: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27463: LD_EXP 67
27467: PUSH
27468: LD_EXP 105
27472: AND
27473: IFFALSE 27602
27475: GO 27477
27477: DISABLE
27478: LD_INT 0
27480: PPUSH
// begin uc_side := 0 ;
27481: LD_ADDR_OWVAR 20
27485: PUSH
27486: LD_INT 0
27488: ST_TO_ADDR
// uc_nation := nation_arabian ;
27489: LD_ADDR_OWVAR 21
27493: PUSH
27494: LD_INT 2
27496: ST_TO_ADDR
// hc_gallery :=  ;
27497: LD_ADDR_OWVAR 33
27501: PUSH
27502: LD_STRING 
27504: ST_TO_ADDR
// hc_name :=  ;
27505: LD_ADDR_OWVAR 26
27509: PUSH
27510: LD_STRING 
27512: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27513: LD_INT 1
27515: PPUSH
27516: LD_INT 11
27518: PPUSH
27519: LD_INT 10
27521: PPUSH
27522: CALL_OW 380
// un := CreateHuman ;
27526: LD_ADDR_VAR 0 1
27530: PUSH
27531: CALL_OW 44
27535: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27536: LD_VAR 0 1
27540: PPUSH
27541: LD_INT 1
27543: PPUSH
27544: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27548: LD_INT 35
27550: PPUSH
27551: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27555: LD_VAR 0 1
27559: PPUSH
27560: LD_INT 22
27562: PUSH
27563: LD_OWVAR 2
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PPUSH
27572: CALL_OW 69
27576: PPUSH
27577: LD_VAR 0 1
27581: PPUSH
27582: CALL_OW 74
27586: PPUSH
27587: CALL_OW 115
// until IsDead ( un ) ;
27591: LD_VAR 0 1
27595: PPUSH
27596: CALL_OW 301
27600: IFFALSE 27548
// end ;
27602: PPOPN 1
27604: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27605: LD_EXP 67
27609: PUSH
27610: LD_EXP 107
27614: AND
27615: IFFALSE 27627
27617: GO 27619
27619: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27620: LD_STRING earthquake(getX(game), 0, 32)
27622: PPUSH
27623: CALL_OW 559
27627: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27628: LD_EXP 67
27632: PUSH
27633: LD_EXP 108
27637: AND
27638: IFFALSE 27729
27640: GO 27642
27642: DISABLE
27643: LD_INT 0
27645: PPUSH
// begin enable ;
27646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27647: LD_ADDR_VAR 0 1
27651: PUSH
27652: LD_INT 22
27654: PUSH
27655: LD_OWVAR 2
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PUSH
27664: LD_INT 21
27666: PUSH
27667: LD_INT 2
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 33
27676: PUSH
27677: LD_INT 3
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: LIST
27688: PPUSH
27689: CALL_OW 69
27693: ST_TO_ADDR
// if not tmp then
27694: LD_VAR 0 1
27698: NOT
27699: IFFALSE 27703
// exit ;
27701: GO 27729
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27703: LD_VAR 0 1
27707: PUSH
27708: LD_INT 1
27710: PPUSH
27711: LD_VAR 0 1
27715: PPUSH
27716: CALL_OW 12
27720: ARRAY
27721: PPUSH
27722: LD_INT 1
27724: PPUSH
27725: CALL_OW 234
// end ;
27729: PPOPN 1
27731: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27732: LD_EXP 67
27736: PUSH
27737: LD_EXP 109
27741: AND
27742: IFFALSE 27883
27744: GO 27746
27746: DISABLE
27747: LD_INT 0
27749: PPUSH
27750: PPUSH
27751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27752: LD_ADDR_VAR 0 3
27756: PUSH
27757: LD_INT 22
27759: PUSH
27760: LD_OWVAR 2
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 25
27771: PUSH
27772: LD_INT 1
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PPUSH
27783: CALL_OW 69
27787: ST_TO_ADDR
// if not tmp then
27788: LD_VAR 0 3
27792: NOT
27793: IFFALSE 27797
// exit ;
27795: GO 27883
// un := tmp [ rand ( 1 , tmp ) ] ;
27797: LD_ADDR_VAR 0 2
27801: PUSH
27802: LD_VAR 0 3
27806: PUSH
27807: LD_INT 1
27809: PPUSH
27810: LD_VAR 0 3
27814: PPUSH
27815: CALL_OW 12
27819: ARRAY
27820: ST_TO_ADDR
// if Crawls ( un ) then
27821: LD_VAR 0 2
27825: PPUSH
27826: CALL_OW 318
27830: IFFALSE 27841
// ComWalk ( un ) ;
27832: LD_VAR 0 2
27836: PPUSH
27837: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27841: LD_VAR 0 2
27845: PPUSH
27846: LD_INT 9
27848: PPUSH
27849: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27853: LD_INT 28
27855: PPUSH
27856: LD_OWVAR 2
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27868: LD_INT 29
27870: PPUSH
27871: LD_OWVAR 2
27875: PPUSH
27876: LD_INT 2
27878: PPUSH
27879: CALL_OW 322
// end ;
27883: PPOPN 3
27885: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27886: LD_EXP 67
27890: PUSH
27891: LD_EXP 110
27895: AND
27896: IFFALSE 28007
27898: GO 27900
27900: DISABLE
27901: LD_INT 0
27903: PPUSH
27904: PPUSH
27905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27906: LD_ADDR_VAR 0 3
27910: PUSH
27911: LD_INT 22
27913: PUSH
27914: LD_OWVAR 2
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 25
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PPUSH
27937: CALL_OW 69
27941: ST_TO_ADDR
// if not tmp then
27942: LD_VAR 0 3
27946: NOT
27947: IFFALSE 27951
// exit ;
27949: GO 28007
// un := tmp [ rand ( 1 , tmp ) ] ;
27951: LD_ADDR_VAR 0 2
27955: PUSH
27956: LD_VAR 0 3
27960: PUSH
27961: LD_INT 1
27963: PPUSH
27964: LD_VAR 0 3
27968: PPUSH
27969: CALL_OW 12
27973: ARRAY
27974: ST_TO_ADDR
// if Crawls ( un ) then
27975: LD_VAR 0 2
27979: PPUSH
27980: CALL_OW 318
27984: IFFALSE 27995
// ComWalk ( un ) ;
27986: LD_VAR 0 2
27990: PPUSH
27991: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27995: LD_VAR 0 2
27999: PPUSH
28000: LD_INT 8
28002: PPUSH
28003: CALL_OW 336
// end ;
28007: PPOPN 3
28009: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
28010: LD_EXP 67
28014: PUSH
28015: LD_EXP 111
28019: AND
28020: IFFALSE 28164
28022: GO 28024
28024: DISABLE
28025: LD_INT 0
28027: PPUSH
28028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
28029: LD_ADDR_VAR 0 2
28033: PUSH
28034: LD_INT 22
28036: PUSH
28037: LD_OWVAR 2
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 21
28048: PUSH
28049: LD_INT 2
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: LD_INT 34
28061: PUSH
28062: LD_INT 12
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 34
28071: PUSH
28072: LD_INT 51
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 34
28081: PUSH
28082: LD_INT 32
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: LIST
28099: PPUSH
28100: CALL_OW 69
28104: ST_TO_ADDR
// if not tmp then
28105: LD_VAR 0 2
28109: NOT
28110: IFFALSE 28114
// exit ;
28112: GO 28164
// for i in tmp do
28114: LD_ADDR_VAR 0 1
28118: PUSH
28119: LD_VAR 0 2
28123: PUSH
28124: FOR_IN
28125: IFFALSE 28162
// if GetCargo ( i , mat_artifact ) = 0 then
28127: LD_VAR 0 1
28131: PPUSH
28132: LD_INT 4
28134: PPUSH
28135: CALL_OW 289
28139: PUSH
28140: LD_INT 0
28142: EQUAL
28143: IFFALSE 28160
// SetCargo ( i , mat_siberit , 100 ) ;
28145: LD_VAR 0 1
28149: PPUSH
28150: LD_INT 3
28152: PPUSH
28153: LD_INT 100
28155: PPUSH
28156: CALL_OW 290
28160: GO 28124
28162: POP
28163: POP
// end ;
28164: PPOPN 2
28166: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28167: LD_EXP 67
28171: PUSH
28172: LD_EXP 112
28176: AND
28177: IFFALSE 28330
28179: GO 28181
28181: DISABLE
28182: LD_INT 0
28184: PPUSH
28185: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28186: LD_ADDR_VAR 0 2
28190: PUSH
28191: LD_INT 22
28193: PUSH
28194: LD_OWVAR 2
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PPUSH
28203: CALL_OW 69
28207: ST_TO_ADDR
// if not tmp then
28208: LD_VAR 0 2
28212: NOT
28213: IFFALSE 28217
// exit ;
28215: GO 28330
// for i := 1 to 2 do
28217: LD_ADDR_VAR 0 1
28221: PUSH
28222: DOUBLE
28223: LD_INT 1
28225: DEC
28226: ST_TO_ADDR
28227: LD_INT 2
28229: PUSH
28230: FOR_TO
28231: IFFALSE 28328
// begin uc_side := your_side ;
28233: LD_ADDR_OWVAR 20
28237: PUSH
28238: LD_OWVAR 2
28242: ST_TO_ADDR
// uc_nation := nation_american ;
28243: LD_ADDR_OWVAR 21
28247: PUSH
28248: LD_INT 1
28250: ST_TO_ADDR
// vc_chassis := us_morphling ;
28251: LD_ADDR_OWVAR 37
28255: PUSH
28256: LD_INT 5
28258: ST_TO_ADDR
// vc_engine := engine_siberite ;
28259: LD_ADDR_OWVAR 39
28263: PUSH
28264: LD_INT 3
28266: ST_TO_ADDR
// vc_control := control_computer ;
28267: LD_ADDR_OWVAR 38
28271: PUSH
28272: LD_INT 3
28274: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28275: LD_ADDR_OWVAR 40
28279: PUSH
28280: LD_INT 10
28282: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
28283: CALL_OW 45
28287: PPUSH
28288: LD_VAR 0 2
28292: PUSH
28293: LD_INT 1
28295: ARRAY
28296: PPUSH
28297: CALL_OW 250
28301: PPUSH
28302: LD_VAR 0 2
28306: PUSH
28307: LD_INT 1
28309: ARRAY
28310: PPUSH
28311: CALL_OW 251
28315: PPUSH
28316: LD_INT 12
28318: PPUSH
28319: LD_INT 1
28321: PPUSH
28322: CALL_OW 50
// end ;
28326: GO 28230
28328: POP
28329: POP
// end ;
28330: PPOPN 2
28332: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28333: LD_EXP 67
28337: PUSH
28338: LD_EXP 113
28342: AND
28343: IFFALSE 28565
28345: GO 28347
28347: DISABLE
28348: LD_INT 0
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28356: LD_ADDR_VAR 0 6
28360: PUSH
28361: LD_INT 22
28363: PUSH
28364: LD_OWVAR 2
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: LD_INT 21
28375: PUSH
28376: LD_INT 1
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PUSH
28383: LD_INT 3
28385: PUSH
28386: LD_INT 23
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PUSH
28396: EMPTY
28397: LIST
28398: LIST
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: LIST
28404: PPUSH
28405: CALL_OW 69
28409: ST_TO_ADDR
// if not tmp then
28410: LD_VAR 0 6
28414: NOT
28415: IFFALSE 28419
// exit ;
28417: GO 28565
// s1 := rand ( 1 , 4 ) ;
28419: LD_ADDR_VAR 0 2
28423: PUSH
28424: LD_INT 1
28426: PPUSH
28427: LD_INT 4
28429: PPUSH
28430: CALL_OW 12
28434: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28435: LD_ADDR_VAR 0 4
28439: PUSH
28440: LD_VAR 0 6
28444: PUSH
28445: LD_INT 1
28447: ARRAY
28448: PPUSH
28449: LD_VAR 0 2
28453: PPUSH
28454: CALL_OW 259
28458: ST_TO_ADDR
// if s1 = 1 then
28459: LD_VAR 0 2
28463: PUSH
28464: LD_INT 1
28466: EQUAL
28467: IFFALSE 28487
// s2 := rand ( 2 , 4 ) else
28469: LD_ADDR_VAR 0 3
28473: PUSH
28474: LD_INT 2
28476: PPUSH
28477: LD_INT 4
28479: PPUSH
28480: CALL_OW 12
28484: ST_TO_ADDR
28485: GO 28495
// s2 := 1 ;
28487: LD_ADDR_VAR 0 3
28491: PUSH
28492: LD_INT 1
28494: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28495: LD_ADDR_VAR 0 5
28499: PUSH
28500: LD_VAR 0 6
28504: PUSH
28505: LD_INT 1
28507: ARRAY
28508: PPUSH
28509: LD_VAR 0 3
28513: PPUSH
28514: CALL_OW 259
28518: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28519: LD_VAR 0 6
28523: PUSH
28524: LD_INT 1
28526: ARRAY
28527: PPUSH
28528: LD_VAR 0 2
28532: PPUSH
28533: LD_VAR 0 5
28537: PPUSH
28538: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28542: LD_VAR 0 6
28546: PUSH
28547: LD_INT 1
28549: ARRAY
28550: PPUSH
28551: LD_VAR 0 3
28555: PPUSH
28556: LD_VAR 0 4
28560: PPUSH
28561: CALL_OW 237
// end ;
28565: PPOPN 6
28567: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28568: LD_EXP 67
28572: PUSH
28573: LD_EXP 114
28577: AND
28578: IFFALSE 28657
28580: GO 28582
28582: DISABLE
28583: LD_INT 0
28585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28586: LD_ADDR_VAR 0 1
28590: PUSH
28591: LD_INT 22
28593: PUSH
28594: LD_OWVAR 2
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 30
28605: PUSH
28606: LD_INT 3
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PPUSH
28617: CALL_OW 69
28621: ST_TO_ADDR
// if not tmp then
28622: LD_VAR 0 1
28626: NOT
28627: IFFALSE 28631
// exit ;
28629: GO 28657
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28631: LD_VAR 0 1
28635: PUSH
28636: LD_INT 1
28638: PPUSH
28639: LD_VAR 0 1
28643: PPUSH
28644: CALL_OW 12
28648: ARRAY
28649: PPUSH
28650: LD_INT 1
28652: PPUSH
28653: CALL_OW 234
// end ;
28657: PPOPN 1
28659: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28660: LD_EXP 67
28664: PUSH
28665: LD_EXP 115
28669: AND
28670: IFFALSE 28782
28672: GO 28674
28674: DISABLE
28675: LD_INT 0
28677: PPUSH
28678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28679: LD_ADDR_VAR 0 2
28683: PUSH
28684: LD_INT 22
28686: PUSH
28687: LD_OWVAR 2
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 2
28698: PUSH
28699: LD_INT 30
28701: PUSH
28702: LD_INT 27
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 30
28711: PUSH
28712: LD_INT 26
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 30
28721: PUSH
28722: LD_INT 28
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: ST_TO_ADDR
// if not tmp then
28744: LD_VAR 0 2
28748: NOT
28749: IFFALSE 28753
// exit ;
28751: GO 28782
// for i in tmp do
28753: LD_ADDR_VAR 0 1
28757: PUSH
28758: LD_VAR 0 2
28762: PUSH
28763: FOR_IN
28764: IFFALSE 28780
// SetLives ( i , 1 ) ;
28766: LD_VAR 0 1
28770: PPUSH
28771: LD_INT 1
28773: PPUSH
28774: CALL_OW 234
28778: GO 28763
28780: POP
28781: POP
// end ;
28782: PPOPN 2
28784: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28785: LD_EXP 67
28789: PUSH
28790: LD_EXP 116
28794: AND
28795: IFFALSE 29069
28797: GO 28799
28799: DISABLE
28800: LD_INT 0
28802: PPUSH
28803: PPUSH
28804: PPUSH
// begin i := rand ( 1 , 7 ) ;
28805: LD_ADDR_VAR 0 1
28809: PUSH
28810: LD_INT 1
28812: PPUSH
28813: LD_INT 7
28815: PPUSH
28816: CALL_OW 12
28820: ST_TO_ADDR
// case i of 1 :
28821: LD_VAR 0 1
28825: PUSH
28826: LD_INT 1
28828: DOUBLE
28829: EQUAL
28830: IFTRUE 28834
28832: GO 28844
28834: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28835: LD_STRING earthquake(getX(game), 0, 32)
28837: PPUSH
28838: CALL_OW 559
28842: GO 29069
28844: LD_INT 2
28846: DOUBLE
28847: EQUAL
28848: IFTRUE 28852
28850: GO 28866
28852: POP
// begin ToLua ( displayStucuk(); ) ;
28853: LD_STRING displayStucuk();
28855: PPUSH
28856: CALL_OW 559
// ResetFog ;
28860: CALL_OW 335
// end ; 3 :
28864: GO 29069
28866: LD_INT 3
28868: DOUBLE
28869: EQUAL
28870: IFTRUE 28874
28872: GO 28978
28874: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28875: LD_ADDR_VAR 0 2
28879: PUSH
28880: LD_INT 22
28882: PUSH
28883: LD_OWVAR 2
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 25
28894: PUSH
28895: LD_INT 1
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PPUSH
28906: CALL_OW 69
28910: ST_TO_ADDR
// if not tmp then
28911: LD_VAR 0 2
28915: NOT
28916: IFFALSE 28920
// exit ;
28918: GO 29069
// un := tmp [ rand ( 1 , tmp ) ] ;
28920: LD_ADDR_VAR 0 3
28924: PUSH
28925: LD_VAR 0 2
28929: PUSH
28930: LD_INT 1
28932: PPUSH
28933: LD_VAR 0 2
28937: PPUSH
28938: CALL_OW 12
28942: ARRAY
28943: ST_TO_ADDR
// if Crawls ( un ) then
28944: LD_VAR 0 3
28948: PPUSH
28949: CALL_OW 318
28953: IFFALSE 28964
// ComWalk ( un ) ;
28955: LD_VAR 0 3
28959: PPUSH
28960: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28964: LD_VAR 0 3
28968: PPUSH
28969: LD_INT 8
28971: PPUSH
28972: CALL_OW 336
// end ; 4 :
28976: GO 29069
28978: LD_INT 4
28980: DOUBLE
28981: EQUAL
28982: IFTRUE 28986
28984: GO 29047
28986: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28987: LD_ADDR_VAR 0 2
28991: PUSH
28992: LD_INT 22
28994: PUSH
28995: LD_OWVAR 2
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 30
29006: PUSH
29007: LD_INT 29
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PPUSH
29018: CALL_OW 69
29022: ST_TO_ADDR
// if not tmp then
29023: LD_VAR 0 2
29027: NOT
29028: IFFALSE 29032
// exit ;
29030: GO 29069
// DestroyUnit ( tmp [ 1 ] ) ;
29032: LD_VAR 0 2
29036: PUSH
29037: LD_INT 1
29039: ARRAY
29040: PPUSH
29041: CALL_OW 65
// end ; 5 .. 7 :
29045: GO 29069
29047: LD_INT 5
29049: DOUBLE
29050: GREATEREQUAL
29051: IFFALSE 29059
29053: LD_INT 7
29055: DOUBLE
29056: LESSEQUAL
29057: IFTRUE 29061
29059: GO 29068
29061: POP
// StreamSibBomb ; end ;
29062: CALL 25349 0 0
29066: GO 29069
29068: POP
// end ;
29069: PPOPN 3
29071: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29072: LD_EXP 67
29076: PUSH
29077: LD_EXP 117
29081: AND
29082: IFFALSE 29238
29084: GO 29086
29086: DISABLE
29087: LD_INT 0
29089: PPUSH
29090: PPUSH
29091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29092: LD_ADDR_VAR 0 2
29096: PUSH
29097: LD_INT 81
29099: PUSH
29100: LD_OWVAR 2
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 2
29111: PUSH
29112: LD_INT 21
29114: PUSH
29115: LD_INT 1
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 21
29124: PUSH
29125: LD_INT 2
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: LIST
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PPUSH
29141: CALL_OW 69
29145: ST_TO_ADDR
// if not tmp then
29146: LD_VAR 0 2
29150: NOT
29151: IFFALSE 29155
// exit ;
29153: GO 29238
// p := 0 ;
29155: LD_ADDR_VAR 0 3
29159: PUSH
29160: LD_INT 0
29162: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29163: LD_INT 35
29165: PPUSH
29166: CALL_OW 67
// p := p + 1 ;
29170: LD_ADDR_VAR 0 3
29174: PUSH
29175: LD_VAR 0 3
29179: PUSH
29180: LD_INT 1
29182: PLUS
29183: ST_TO_ADDR
// for i in tmp do
29184: LD_ADDR_VAR 0 1
29188: PUSH
29189: LD_VAR 0 2
29193: PUSH
29194: FOR_IN
29195: IFFALSE 29226
// if GetLives ( i ) < 1000 then
29197: LD_VAR 0 1
29201: PPUSH
29202: CALL_OW 256
29206: PUSH
29207: LD_INT 1000
29209: LESS
29210: IFFALSE 29224
// SetLives ( i , 1000 ) ;
29212: LD_VAR 0 1
29216: PPUSH
29217: LD_INT 1000
29219: PPUSH
29220: CALL_OW 234
29224: GO 29194
29226: POP
29227: POP
// until p > 20 ;
29228: LD_VAR 0 3
29232: PUSH
29233: LD_INT 20
29235: GREATER
29236: IFFALSE 29163
// end ;
29238: PPOPN 3
29240: END
// every 0 0$1 trigger StreamModeActive and sTime do
29241: LD_EXP 67
29245: PUSH
29246: LD_EXP 118
29250: AND
29251: IFFALSE 29286
29253: GO 29255
29255: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29256: LD_INT 28
29258: PPUSH
29259: LD_OWVAR 2
29263: PPUSH
29264: LD_INT 2
29266: PPUSH
29267: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29271: LD_INT 30
29273: PPUSH
29274: LD_OWVAR 2
29278: PPUSH
29279: LD_INT 2
29281: PPUSH
29282: CALL_OW 322
// end ;
29286: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29287: LD_EXP 67
29291: PUSH
29292: LD_EXP 119
29296: AND
29297: IFFALSE 29418
29299: GO 29301
29301: DISABLE
29302: LD_INT 0
29304: PPUSH
29305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29306: LD_ADDR_VAR 0 2
29310: PUSH
29311: LD_INT 22
29313: PUSH
29314: LD_OWVAR 2
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 21
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 3
29335: PUSH
29336: LD_INT 23
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: LIST
29354: PPUSH
29355: CALL_OW 69
29359: ST_TO_ADDR
// if not tmp then
29360: LD_VAR 0 2
29364: NOT
29365: IFFALSE 29369
// exit ;
29367: GO 29418
// for i in tmp do
29369: LD_ADDR_VAR 0 1
29373: PUSH
29374: LD_VAR 0 2
29378: PUSH
29379: FOR_IN
29380: IFFALSE 29416
// begin if Crawls ( i ) then
29382: LD_VAR 0 1
29386: PPUSH
29387: CALL_OW 318
29391: IFFALSE 29402
// ComWalk ( i ) ;
29393: LD_VAR 0 1
29397: PPUSH
29398: CALL_OW 138
// SetClass ( i , 2 ) ;
29402: LD_VAR 0 1
29406: PPUSH
29407: LD_INT 2
29409: PPUSH
29410: CALL_OW 336
// end ;
29414: GO 29379
29416: POP
29417: POP
// end ;
29418: PPOPN 2
29420: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29421: LD_EXP 67
29425: PUSH
29426: LD_EXP 120
29430: AND
29431: IFFALSE 29712
29433: GO 29435
29435: DISABLE
29436: LD_INT 0
29438: PPUSH
29439: PPUSH
29440: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29441: LD_OWVAR 2
29445: PPUSH
29446: LD_INT 9
29448: PPUSH
29449: LD_INT 1
29451: PPUSH
29452: LD_INT 1
29454: PPUSH
29455: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29459: LD_INT 9
29461: PPUSH
29462: LD_OWVAR 2
29466: PPUSH
29467: CALL_OW 343
// uc_side := 9 ;
29471: LD_ADDR_OWVAR 20
29475: PUSH
29476: LD_INT 9
29478: ST_TO_ADDR
// uc_nation := 2 ;
29479: LD_ADDR_OWVAR 21
29483: PUSH
29484: LD_INT 2
29486: ST_TO_ADDR
// hc_name := Dark Warrior ;
29487: LD_ADDR_OWVAR 26
29491: PUSH
29492: LD_STRING Dark Warrior
29494: ST_TO_ADDR
// hc_gallery :=  ;
29495: LD_ADDR_OWVAR 33
29499: PUSH
29500: LD_STRING 
29502: ST_TO_ADDR
// hc_noskilllimit := true ;
29503: LD_ADDR_OWVAR 76
29507: PUSH
29508: LD_INT 1
29510: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29511: LD_ADDR_OWVAR 31
29515: PUSH
29516: LD_INT 30
29518: PUSH
29519: LD_INT 30
29521: PUSH
29522: LD_INT 30
29524: PUSH
29525: LD_INT 30
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: LIST
29532: LIST
29533: ST_TO_ADDR
// un := CreateHuman ;
29534: LD_ADDR_VAR 0 3
29538: PUSH
29539: CALL_OW 44
29543: ST_TO_ADDR
// hc_noskilllimit := false ;
29544: LD_ADDR_OWVAR 76
29548: PUSH
29549: LD_INT 0
29551: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29552: LD_VAR 0 3
29556: PPUSH
29557: LD_INT 1
29559: PPUSH
29560: CALL_OW 51
// p := 0 ;
29564: LD_ADDR_VAR 0 2
29568: PUSH
29569: LD_INT 0
29571: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29572: LD_INT 35
29574: PPUSH
29575: CALL_OW 67
// p := p + 1 ;
29579: LD_ADDR_VAR 0 2
29583: PUSH
29584: LD_VAR 0 2
29588: PUSH
29589: LD_INT 1
29591: PLUS
29592: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29593: LD_VAR 0 3
29597: PPUSH
29598: CALL_OW 256
29602: PUSH
29603: LD_INT 1000
29605: LESS
29606: IFFALSE 29620
// SetLives ( un , 1000 ) ;
29608: LD_VAR 0 3
29612: PPUSH
29613: LD_INT 1000
29615: PPUSH
29616: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29620: LD_VAR 0 3
29624: PPUSH
29625: LD_INT 81
29627: PUSH
29628: LD_OWVAR 2
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 91
29639: PUSH
29640: LD_VAR 0 3
29644: PUSH
29645: LD_INT 30
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: LIST
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PPUSH
29657: CALL_OW 69
29661: PPUSH
29662: LD_VAR 0 3
29666: PPUSH
29667: CALL_OW 74
29671: PPUSH
29672: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29676: LD_VAR 0 2
29680: PUSH
29681: LD_INT 60
29683: GREATER
29684: PUSH
29685: LD_VAR 0 3
29689: PPUSH
29690: CALL_OW 301
29694: OR
29695: IFFALSE 29572
// if un then
29697: LD_VAR 0 3
29701: IFFALSE 29712
// RemoveUnit ( un ) ;
29703: LD_VAR 0 3
29707: PPUSH
29708: CALL_OW 64
// end ; end_of_file
29712: PPOPN 3
29714: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29715: LD_INT 0
29717: PPUSH
29718: PPUSH
29719: PPUSH
29720: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29721: LD_VAR 0 1
29725: PPUSH
29726: CALL_OW 264
29730: PUSH
29731: LD_EXP 58
29735: EQUAL
29736: IFFALSE 29808
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29738: LD_INT 68
29740: PPUSH
29741: LD_VAR 0 1
29745: PPUSH
29746: CALL_OW 255
29750: PPUSH
29751: CALL_OW 321
29755: PUSH
29756: LD_INT 2
29758: EQUAL
29759: IFFALSE 29771
// eff := 70 else
29761: LD_ADDR_VAR 0 4
29765: PUSH
29766: LD_INT 70
29768: ST_TO_ADDR
29769: GO 29779
// eff := 30 ;
29771: LD_ADDR_VAR 0 4
29775: PUSH
29776: LD_INT 30
29778: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29779: LD_VAR 0 1
29783: PPUSH
29784: CALL_OW 250
29788: PPUSH
29789: LD_VAR 0 1
29793: PPUSH
29794: CALL_OW 251
29798: PPUSH
29799: LD_VAR 0 4
29803: PPUSH
29804: CALL_OW 495
// end ; end ;
29808: LD_VAR 0 2
29812: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29813: LD_INT 0
29815: PPUSH
// end ;
29816: LD_VAR 0 4
29820: RET
// export function SOS_Command ( cmd ) ; begin
29821: LD_INT 0
29823: PPUSH
// end ;
29824: LD_VAR 0 2
29828: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29829: LD_VAR 0 1
29833: PUSH
29834: LD_INT 255
29836: EQUAL
29837: PUSH
29838: LD_VAR 0 2
29842: PPUSH
29843: CALL_OW 264
29847: PUSH
29848: LD_INT 14
29850: PUSH
29851: LD_INT 53
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: IN
29858: AND
29859: PUSH
29860: LD_VAR 0 4
29864: PPUSH
29865: LD_VAR 0 5
29869: PPUSH
29870: CALL_OW 488
29874: AND
29875: IFFALSE 29899
// CutTreeXYR ( unit , x , y , 12 ) ;
29877: LD_VAR 0 2
29881: PPUSH
29882: LD_VAR 0 4
29886: PPUSH
29887: LD_VAR 0 5
29891: PPUSH
29892: LD_INT 12
29894: PPUSH
29895: CALL 29902 0 4
// end ;
29899: PPOPN 5
29901: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29902: LD_INT 0
29904: PPUSH
29905: PPUSH
29906: PPUSH
29907: PPUSH
29908: PPUSH
29909: PPUSH
29910: PPUSH
29911: PPUSH
29912: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29913: LD_VAR 0 1
29917: NOT
29918: PUSH
29919: LD_VAR 0 2
29923: PPUSH
29924: LD_VAR 0 3
29928: PPUSH
29929: CALL_OW 488
29933: NOT
29934: OR
29935: PUSH
29936: LD_VAR 0 4
29940: NOT
29941: OR
29942: IFFALSE 29946
// exit ;
29944: GO 30286
// list := [ ] ;
29946: LD_ADDR_VAR 0 13
29950: PUSH
29951: EMPTY
29952: ST_TO_ADDR
// if x - r < 0 then
29953: LD_VAR 0 2
29957: PUSH
29958: LD_VAR 0 4
29962: MINUS
29963: PUSH
29964: LD_INT 0
29966: LESS
29967: IFFALSE 29979
// min_x := 0 else
29969: LD_ADDR_VAR 0 7
29973: PUSH
29974: LD_INT 0
29976: ST_TO_ADDR
29977: GO 29995
// min_x := x - r ;
29979: LD_ADDR_VAR 0 7
29983: PUSH
29984: LD_VAR 0 2
29988: PUSH
29989: LD_VAR 0 4
29993: MINUS
29994: ST_TO_ADDR
// if y - r < 0 then
29995: LD_VAR 0 3
29999: PUSH
30000: LD_VAR 0 4
30004: MINUS
30005: PUSH
30006: LD_INT 0
30008: LESS
30009: IFFALSE 30021
// min_y := 0 else
30011: LD_ADDR_VAR 0 8
30015: PUSH
30016: LD_INT 0
30018: ST_TO_ADDR
30019: GO 30037
// min_y := y - r ;
30021: LD_ADDR_VAR 0 8
30025: PUSH
30026: LD_VAR 0 3
30030: PUSH
30031: LD_VAR 0 4
30035: MINUS
30036: ST_TO_ADDR
// max_x := x + r ;
30037: LD_ADDR_VAR 0 9
30041: PUSH
30042: LD_VAR 0 2
30046: PUSH
30047: LD_VAR 0 4
30051: PLUS
30052: ST_TO_ADDR
// max_y := y + r ;
30053: LD_ADDR_VAR 0 10
30057: PUSH
30058: LD_VAR 0 3
30062: PUSH
30063: LD_VAR 0 4
30067: PLUS
30068: ST_TO_ADDR
// for _x = min_x to max_x do
30069: LD_ADDR_VAR 0 11
30073: PUSH
30074: DOUBLE
30075: LD_VAR 0 7
30079: DEC
30080: ST_TO_ADDR
30081: LD_VAR 0 9
30085: PUSH
30086: FOR_TO
30087: IFFALSE 30204
// for _y = min_y to max_y do
30089: LD_ADDR_VAR 0 12
30093: PUSH
30094: DOUBLE
30095: LD_VAR 0 8
30099: DEC
30100: ST_TO_ADDR
30101: LD_VAR 0 10
30105: PUSH
30106: FOR_TO
30107: IFFALSE 30200
// begin if not ValidHex ( _x , _y ) then
30109: LD_VAR 0 11
30113: PPUSH
30114: LD_VAR 0 12
30118: PPUSH
30119: CALL_OW 488
30123: NOT
30124: IFFALSE 30128
// continue ;
30126: GO 30106
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30128: LD_VAR 0 11
30132: PPUSH
30133: LD_VAR 0 12
30137: PPUSH
30138: CALL_OW 351
30142: PUSH
30143: LD_VAR 0 11
30147: PPUSH
30148: LD_VAR 0 12
30152: PPUSH
30153: CALL_OW 554
30157: AND
30158: IFFALSE 30198
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30160: LD_ADDR_VAR 0 13
30164: PUSH
30165: LD_VAR 0 13
30169: PPUSH
30170: LD_VAR 0 13
30174: PUSH
30175: LD_INT 1
30177: PLUS
30178: PPUSH
30179: LD_VAR 0 11
30183: PUSH
30184: LD_VAR 0 12
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PPUSH
30193: CALL_OW 2
30197: ST_TO_ADDR
// end ;
30198: GO 30106
30200: POP
30201: POP
30202: GO 30086
30204: POP
30205: POP
// if not list then
30206: LD_VAR 0 13
30210: NOT
30211: IFFALSE 30215
// exit ;
30213: GO 30286
// for i in list do
30215: LD_ADDR_VAR 0 6
30219: PUSH
30220: LD_VAR 0 13
30224: PUSH
30225: FOR_IN
30226: IFFALSE 30284
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30228: LD_VAR 0 1
30232: PPUSH
30233: LD_STRING M
30235: PUSH
30236: LD_VAR 0 6
30240: PUSH
30241: LD_INT 1
30243: ARRAY
30244: PUSH
30245: LD_VAR 0 6
30249: PUSH
30250: LD_INT 2
30252: ARRAY
30253: PUSH
30254: LD_INT 0
30256: PUSH
30257: LD_INT 0
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: PUSH
30275: EMPTY
30276: LIST
30277: PPUSH
30278: CALL_OW 447
30282: GO 30225
30284: POP
30285: POP
// end ;
30286: LD_VAR 0 5
30290: RET
