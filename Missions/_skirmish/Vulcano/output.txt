// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareTrigger ;
   8: CALL 33 0 0
// PrepareVulcanoBase ;
  12: CALL 873 0 0
// PrepareRussian ;
  16: CALL 3449 0 0
// PrepareLegion ;
  20: CALL 6966 0 0
// Action ;
  24: CALL 10645 0 0
// InitArt ;
  28: CALL 194 0 0
// end ;
  32: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  33: LD_INT 0
  35: PPUSH
// base_captured := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// russian_prepared := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// ru_can_attack := false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// ru_sib_bomb := false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 5
  75: PUSH
  76: LD_INT 10
  78: PUSH
  79: LD_INT 25
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: ST_TO_ADDR
// player_res_art := false ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// player_artifact_ready := false ;
 101: LD_ADDR_EXP 7
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// art_icon := art_use_atom ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 7
 116: ST_TO_ADDR
// time_res_art := 600 ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 600
 124: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 21000
 132: ST_TO_ADDR
// mine_vulc := false ;
 133: LD_ADDR_EXP 12
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// medal_enabled := false ;
 141: LD_ADDR_EXP 13
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// dead_counter := 0 ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// kill_counter := 0 ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// veh_counter := 0 ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// tech_counter := 0 ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// end ;
 189: LD_VAR 0 1
 193: RET
// function InitArt ; begin
 194: LD_INT 0
 196: PPUSH
// SetArtifactRes ( your_side , true ) ;
 197: LD_OWVAR 2
 201: PPUSH
 202: LD_INT 1
 204: PPUSH
 205: CALL_OW 467
// end ; end_of_file
 209: LD_VAR 0 1
 213: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 214: LD_INT 0
 216: PPUSH
 217: PPUSH
 218: PPUSH
 219: PPUSH
 220: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 7
 228: PUSH
 229: LD_INT 6
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: PUSH
 240: LD_OWVAR 67
 244: ARRAY
 245: ST_TO_ADDR
// us_force := [ ] ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 253: LD_INT 17
 255: PPUSH
 256: CALL_OW 355
// PrepareAllianceAI ( ) ;
 260: CALL 15316 0 0
// uc_side := 1 ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// uc_nation := nation_american ;
 272: LD_ADDR_OWVAR 21
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// hc_gallery :=  ;
 280: LD_ADDR_OWVAR 33
 284: PUSH
 285: LD_STRING 
 287: ST_TO_ADDR
// hc_name :=  ;
 288: LD_ADDR_OWVAR 26
 292: PUSH
 293: LD_STRING 
 295: ST_TO_ADDR
// hc_importance := 0 ;
 296: LD_ADDR_OWVAR 32
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// for i = 1 to 11 do
 304: LD_ADDR_VAR 0 2
 308: PUSH
 309: DOUBLE
 310: LD_INT 1
 312: DEC
 313: ST_TO_ADDR
 314: LD_INT 11
 316: PUSH
 317: FOR_TO
 318: IFFALSE 371
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 320: LD_INT 0
 322: PPUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 4
 328: PPUSH
 329: CALL_OW 12
 333: PPUSH
 334: LD_EXP 21
 338: PPUSH
 339: CALL_OW 380
// un := CreateHuman ;
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: CALL_OW 44
 352: ST_TO_ADDR
// us_force := us_force ^ un ;
 353: LD_ADDR_EXP 20
 357: PUSH
 358: LD_EXP 20
 362: PUSH
 363: LD_VAR 0 4
 367: ADD
 368: ST_TO_ADDR
// end ;
 369: GO 317
 371: POP
 372: POP
// hc_importance := 100 ;
 373: LD_ADDR_OWVAR 32
 377: PUSH
 378: LD_INT 100
 380: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: LD_EXP 21
 391: PPUSH
 392: CALL_OW 380
// us_commander := CreateHuman ;
 396: LD_ADDR_EXP 19
 400: PUSH
 401: CALL_OW 44
 405: ST_TO_ADDR
// player_commander := us_commander ;
 406: LD_ADDR_EXP 10
 410: PUSH
 411: LD_EXP 19
 415: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 416: LD_ADDR_VAR 0 5
 420: PUSH
 421: LD_STRING text
 423: PPUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 5
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_OWVAR 67
 442: ARRAY
 443: PPUSH
 444: LD_INT 6
 446: PUSH
 447: LD_INT 5
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_OWVAR 67
 462: ARRAY
 463: PPUSH
 464: LD_INT -5
 466: PUSH
 467: LD_EXP 19
 471: PUSH
 472: LD_INT -3
 474: PUSH
 475: LD_INT -2
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: LIST
 483: PUSH
 484: LD_EXP 20
 488: ADD
 489: PPUSH
 490: LD_INT 1
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 2
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 4
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PUSH
 516: LD_INT 5
 518: PUSH
 519: LD_INT 5
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL_OW 42
 548: ST_TO_ADDR
// team := team ^ us_commander ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: LD_EXP 19
 563: ADD
 564: ST_TO_ADDR
// for i = 1 to team do
 565: LD_ADDR_VAR 0 2
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 5
 579: PUSH
 580: FOR_TO
 581: IFFALSE 606
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 583: LD_VAR 0 5
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PPUSH
 594: LD_INT 1
 596: PPUSH
 597: LD_INT 0
 599: PPUSH
 600: CALL_OW 49
 604: GO 580
 606: POP
 607: POP
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 613: LD_OWVAR 1
 617: PUSH
 618: LD_INT 73500
 620: LESS
 621: IFFALSE 648
 623: GO 625
 625: DISABLE
// begin enable ;
 626: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 627: LD_INT 1
 629: PPUSH
 630: LD_INT 5
 632: PPUSH
 633: CALL_OW 12
 637: PPUSH
 638: LD_INT 24
 640: PPUSH
 641: LD_INT 1
 643: PPUSH
 644: CALL_OW 55
// end ;
 648: END
// every 1 1$10 do var time , p , l ;
 649: GO 651
 651: DISABLE
 652: LD_INT 0
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin time := 0 0$44 ;
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 1540
 664: ST_TO_ADDR
// l := 0 ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: LD_INT 0
 672: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 673: LD_VAR 0 1
 677: PPUSH
 678: CALL_OW 67
// l := l + 1 ;
 682: LD_ADDR_VAR 0 3
 686: PUSH
 687: LD_VAR 0 3
 691: PUSH
 692: LD_INT 1
 694: PLUS
 695: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 696: LD_INT 12
 698: PPUSH
 699: CALL_OW 435
 703: PUSH
 704: LD_INT 30
 706: LESS
 707: IFFALSE 766
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 709: LD_INT 1
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL_OW 12
 719: PPUSH
 720: LD_INT 12
 722: PPUSH
 723: LD_INT 1
 725: PPUSH
 726: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 730: LD_INT 1155
 732: PPUSH
 733: LD_INT 1540
 735: PPUSH
 736: CALL_OW 12
 740: PPUSH
 741: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 745: LD_INT 1
 747: PPUSH
 748: LD_INT 5
 750: PPUSH
 751: CALL_OW 12
 755: PPUSH
 756: LD_INT 12
 758: PPUSH
 759: LD_INT 1
 761: PPUSH
 762: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 766: LD_ADDR_VAR 0 2
 770: PUSH
 771: LD_INT 0
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 12
 781: ST_TO_ADDR
// if p then
 782: LD_VAR 0 2
 786: IFFALSE 821
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 788: LD_INT 105
 790: PPUSH
 791: LD_INT 350
 793: PPUSH
 794: CALL_OW 12
 798: PPUSH
 799: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 803: LD_INT 1
 805: PPUSH
 806: LD_INT 4
 808: PPUSH
 809: CALL_OW 12
 813: PPUSH
 814: LD_INT 1
 816: PPUSH
 817: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 15
 828: PUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 11
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: PUSH
 840: LD_OWVAR 67
 844: ARRAY
 845: MOD
 846: PUSH
 847: LD_INT 0
 849: EQUAL
 850: IFFALSE 866
// time := time + 2 2$00 ;
 852: LD_ADDR_VAR 0 1
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 4200
 864: PLUS
 865: ST_TO_ADDR
// end until false ;
 866: LD_INT 0
 868: IFFALSE 673
// end ; end_of_file
 870: PPOPN 3
 872: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
 882: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_INT 22
 890: PUSH
 891: LD_INT 4
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 69
 916: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_INT 470
 924: PUSH
 925: LD_INT 370
 927: PUSH
 928: LD_INT 290
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_OWVAR 67
 940: ARRAY
 941: ST_TO_ADDR
// case Difficulty of 2 :
 942: LD_OWVAR 67
 946: PUSH
 947: LD_INT 2
 949: DOUBLE
 950: EQUAL
 951: IFTRUE 955
 953: GO 986
 955: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 956: LD_VAR 0 3
 960: PPUSH
 961: LD_INT 30
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PPUSH
 971: CALL_OW 72
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 65
// end ; 3 :
 984: GO 1062
 986: LD_INT 3
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1061
 994: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 995: LD_VAR 0 3
 999: PPUSH
1000: LD_INT 30
1002: PUSH
1003: LD_INT 32
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 72
1014: PUSH
1015: LD_INT 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1023: LD_VAR 0 3
1027: PPUSH
1028: LD_INT 30
1030: PUSH
1031: LD_INT 27
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: PPUSH
1038: CALL_OW 72
1042: PUSH
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: CALL_OW 12
1053: ARRAY
1054: PPUSH
1055: CALL_OW 65
// end ; end ;
1059: GO 1062
1061: POP
// for i = 1 to filter do
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: DOUBLE
1068: LD_INT 1
1070: DEC
1071: ST_TO_ADDR
1072: LD_VAR 0 3
1076: PUSH
1077: FOR_TO
1078: IFFALSE 1115
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1080: LD_VAR 0 3
1084: PUSH
1085: LD_VAR 0 2
1089: ARRAY
1090: PPUSH
1091: LD_VAR 0 4
1095: PUSH
1096: LD_INT 29
1098: NEG
1099: PPUSH
1100: LD_INT 29
1102: PPUSH
1103: CALL_OW 12
1107: PLUS
1108: PPUSH
1109: CALL_OW 234
1113: GO 1077
1115: POP
1116: POP
// SetBName ( us_depot , Vulcano1 ) ;
1117: LD_INT 50
1119: PPUSH
1120: LD_STRING Vulcano1
1122: PPUSH
1123: CALL_OW 500
// hc_importance := 0 ;
1127: LD_ADDR_OWVAR 32
1131: PUSH
1132: LD_INT 0
1134: ST_TO_ADDR
// uc_side := 3 ;
1135: LD_ADDR_OWVAR 20
1139: PUSH
1140: LD_INT 3
1142: ST_TO_ADDR
// uc_nation := nation_russian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 3
1150: ST_TO_ADDR
// russian_in_base := [ ] ;
1151: LD_ADDR_VAR 0 8
1155: PUSH
1156: EMPTY
1157: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1158: LD_ADDR_VAR 0 6
1162: PUSH
1163: LD_INT 82
1165: PPUSH
1166: LD_INT 137
1168: PPUSH
1169: LD_INT 106
1171: PPUSH
1172: LD_INT 152
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL 1555 0 5
1182: ST_TO_ADDR
// p := 1 ;
1183: LD_ADDR_VAR 0 7
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: DOUBLE
1197: LD_INT 1
1199: DEC
1200: ST_TO_ADDR
1201: LD_INT 6
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_OWVAR 67
1219: ARRAY
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1334
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1224: LD_INT 0
1226: PPUSH
1227: LD_INT 1
1229: PPUSH
1230: LD_INT 4
1232: PUSH
1233: LD_INT 5
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_OWVAR 67
1248: ARRAY
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1264: LD_ADDR_VAR 0 8
1268: PUSH
1269: LD_VAR 0 8
1273: PUSH
1274: LD_VAR 0 5
1278: ADD
1279: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1280: LD_VAR 0 5
1284: PPUSH
1285: LD_VAR 0 6
1289: PUSH
1290: LD_VAR 0 7
1294: ARRAY
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_VAR 0 7
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: ARRAY
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL_OW 48
// p := p + 2 ;
1318: LD_ADDR_VAR 0 7
1322: PUSH
1323: LD_VAR 0 7
1327: PUSH
1328: LD_INT 2
1330: PLUS
1331: ST_TO_ADDR
// end ;
1332: GO 1221
1334: POP
1335: POP
// end ;
1336: LD_VAR 0 1
1340: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1341: LD_INT 50
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: CALL 2045 0 2
1351: PUSH
1352: LD_INT 40
1354: LESS
1355: IFFALSE 1552
1357: GO 1359
1359: DISABLE
1360: LD_INT 0
1362: PPUSH
1363: PPUSH
// begin uc_side := 4 ;
1364: LD_ADDR_OWVAR 20
1368: PUSH
1369: LD_INT 4
1371: ST_TO_ADDR
// uc_nation := nation_american ;
1372: LD_ADDR_OWVAR 21
1376: PUSH
1377: LD_INT 1
1379: ST_TO_ADDR
// hc_importance := 0 ;
1380: LD_ADDR_OWVAR 32
1384: PUSH
1385: LD_INT 0
1387: ST_TO_ADDR
// for i = 1 to 7 do
1388: LD_ADDR_VAR 0 1
1392: PUSH
1393: DOUBLE
1394: LD_INT 1
1396: DEC
1397: ST_TO_ADDR
1398: LD_INT 7
1400: PUSH
1401: FOR_TO
1402: IFFALSE 1466
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1404: LD_INT 0
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: CALL_OW 12
1417: PPUSH
1418: LD_EXP 21
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1437: LD_VAR 0 2
1441: PPUSH
1442: LD_INT 7
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// SetLives ( un , 10 ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_INT 10
1459: PPUSH
1460: CALL_OW 234
// end ;
1464: GO 1401
1466: POP
1467: POP
// for i = 1 to 5 do
1468: LD_ADDR_VAR 0 1
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 5
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1550
// begin PrepareHuman ( false , 4 , us_skill ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_INT 4
1489: PPUSH
1490: LD_EXP 21
1494: PPUSH
1495: CALL_OW 380
// SetDir ( un , 1 ) ;
1499: LD_VAR 0 2
1503: PPUSH
1504: LD_INT 1
1506: PPUSH
1507: CALL_OW 233
// un := CreateHuman ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: CALL_OW 44
1520: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1521: LD_VAR 0 2
1525: PPUSH
1526: LD_INT 23
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// SetLives ( un , 10 ) ;
1536: LD_VAR 0 2
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: CALL_OW 234
// end ;
1548: GO 1481
1550: POP
1551: POP
// end ; end_of_file
1552: PPOPN 2
1554: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1555: LD_INT 0
1557: PPUSH
1558: PPUSH
1559: PPUSH
// list := [ ] ;
1560: LD_ADDR_VAR 0 7
1564: PUSH
1565: EMPTY
1566: ST_TO_ADDR
// for i = 1 to num do
1567: LD_ADDR_VAR 0 8
1571: PUSH
1572: DOUBLE
1573: LD_INT 1
1575: DEC
1576: ST_TO_ADDR
1577: LD_VAR 0 5
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1639
// begin list := list ^ Rand ( x1 , x2 ) ;
1585: LD_ADDR_VAR 0 7
1589: PUSH
1590: LD_VAR 0 7
1594: PUSH
1595: LD_VAR 0 1
1599: PPUSH
1600: LD_VAR 0 3
1604: PPUSH
1605: CALL_OW 12
1609: ADD
1610: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1611: LD_ADDR_VAR 0 7
1615: PUSH
1616: LD_VAR 0 7
1620: PUSH
1621: LD_VAR 0 2
1625: PPUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: CALL_OW 12
1635: ADD
1636: ST_TO_ADDR
// end ;
1637: GO 1582
1639: POP
1640: POP
// result := list ;
1641: LD_ADDR_VAR 0 6
1645: PUSH
1646: LD_VAR 0 7
1650: ST_TO_ADDR
// end ;
1651: LD_VAR 0 6
1655: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1656: LD_INT 0
1658: PPUSH
1659: PPUSH
1660: PPUSH
1661: PPUSH
// c := Rand ( 1 , 3 ) ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_INT 1
1669: PPUSH
1670: LD_INT 3
1672: PPUSH
1673: CALL_OW 12
1677: ST_TO_ADDR
// for i = 1 to list do
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: DOUBLE
1684: LD_INT 1
1686: DEC
1687: ST_TO_ADDR
1688: LD_VAR 0 1
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1876
// for ta in filter do
1696: LD_ADDR_VAR 0 4
1700: PUSH
1701: LD_VAR 0 2
1705: PUSH
1706: FOR_IN
1707: IFFALSE 1872
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1709: LD_VAR 0 1
1713: PUSH
1714: LD_VAR 0 6
1718: ARRAY
1719: PPUSH
1720: LD_VAR 0 4
1724: PPUSH
1725: CALL_OW 296
1729: PUSH
1730: LD_INT 15
1732: LESSEQUAL
1733: IFFALSE 1870
// begin case c of 1 :
1735: LD_VAR 0 5
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1786
1748: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1749: LD_VAR 0 1
1753: PUSH
1754: LD_VAR 0 6
1758: ARRAY
1759: PPUSH
1760: LD_VAR 0 4
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 154
1784: GO 1870
1786: LD_INT 2
1788: DOUBLE
1789: EQUAL
1790: IFTRUE 1794
1792: GO 1858
1794: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1795: LD_VAR 0 1
1799: PUSH
1800: LD_VAR 0 6
1804: ARRAY
1805: PPUSH
1806: LD_VAR 0 4
1810: PPUSH
1811: CALL_OW 250
1815: PUSH
1816: LD_INT 1
1818: NEG
1819: PPUSH
1820: LD_INT 1
1822: PPUSH
1823: CALL_OW 12
1827: PLUS
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: CALL_OW 251
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: CALL_OW 12
1850: PLUS
1851: PPUSH
1852: CALL_OW 153
1856: GO 1870
1858: LD_INT 3
1860: DOUBLE
1861: EQUAL
1862: IFTRUE 1866
1864: GO 1869
1866: POP
// ; end ;
1867: GO 1870
1869: POP
// end ; end ;
1870: GO 1706
1872: POP
1873: POP
1874: GO 1693
1876: POP
1877: POP
// end ;
1878: LD_VAR 0 3
1882: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
// for i = 1 to n do
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: DOUBLE
1894: LD_INT 1
1896: DEC
1897: ST_TO_ADDR
1898: LD_VAR 0 1
1902: PUSH
1903: FOR_TO
1904: IFFALSE 2038
// begin uc_side := 0 ;
1906: LD_ADDR_OWVAR 20
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// uc_nation := 0 ;
1914: LD_ADDR_OWVAR 21
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// hc_class := class_apeman ;
1922: LD_ADDR_OWVAR 28
1926: PUSH
1927: LD_INT 12
1929: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1930: LD_ADDR_OWVAR 31
1934: PUSH
1935: LD_INT 0
1937: PUSH
1938: LD_INT 0
1940: PUSH
1941: LD_INT 0
1943: PUSH
1944: LD_INT 0
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: ST_TO_ADDR
// hc_name :=  ;
1953: LD_ADDR_OWVAR 26
1957: PUSH
1958: LD_STRING 
1960: ST_TO_ADDR
// hc_gallery :=  ;
1961: LD_ADDR_OWVAR 33
1965: PUSH
1966: LD_STRING 
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// un := CreateHuman ;
1977: LD_ADDR_VAR 0 3
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1987: LD_VAR 0 3
1991: PPUSH
1992: LD_INT 19
1994: PUSH
1995: LD_INT 20
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PPUSH
2014: LD_INT 0
2016: PPUSH
2017: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2021: LD_INT 1155
2023: PPUSH
2024: LD_INT 5355
2026: PPUSH
2027: CALL_OW 12
2031: PPUSH
2032: CALL_OW 67
// end ;
2036: GO 1903
2038: POP
2039: POP
// end ;
2040: LD_VAR 0 2
2044: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2050: LD_ADDR_VAR 0 4
2054: PUSH
2055: LD_INT 22
2057: PUSH
2058: LD_VAR 0 2
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 74
2081: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2082: LD_ADDR_VAR 0 5
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_VAR 0 4
2096: PPUSH
2097: CALL_OW 296
2101: ST_TO_ADDR
// if dist >= 9999 then
2102: LD_VAR 0 5
2106: PUSH
2107: LD_INT 9999
2109: GREATEREQUAL
2110: IFFALSE 2123
// result := - 1 else
2112: LD_ADDR_VAR 0 3
2116: PUSH
2117: LD_INT 1
2119: NEG
2120: ST_TO_ADDR
2121: GO 2133
// result := dist ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 5
2132: ST_TO_ADDR
// end ;
2133: LD_VAR 0 3
2137: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2138: LD_INT 0
2140: PPUSH
2141: PPUSH
2142: PPUSH
2143: PPUSH
// tmp := 9999 ;
2144: LD_ADDR_VAR 0 5
2148: PUSH
2149: LD_INT 9999
2151: ST_TO_ADDR
// for i = 1 to plist do
2152: LD_ADDR_VAR 0 4
2156: PUSH
2157: DOUBLE
2158: LD_INT 1
2160: DEC
2161: ST_TO_ADDR
2162: LD_VAR 0 1
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2242
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2170: LD_VAR 0 1
2174: PUSH
2175: LD_VAR 0 4
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 2
2185: PPUSH
2186: CALL 2045 0 2
2190: PUSH
2191: LD_VAR 0 5
2195: LESS
2196: IFFALSE 2240
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 1
2207: PUSH
2208: LD_VAR 0 4
2212: ARRAY
2213: PPUSH
2214: LD_VAR 0 2
2218: PPUSH
2219: CALL 2045 0 2
2223: ST_TO_ADDR
// unit := plist [ i ] ;
2224: LD_ADDR_VAR 0 6
2228: PUSH
2229: LD_VAR 0 1
2233: PUSH
2234: LD_VAR 0 4
2238: ARRAY
2239: ST_TO_ADDR
// end ;
2240: GO 2167
2242: POP
2243: POP
// result := unit ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: LD_VAR 0 6
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 3
2258: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2266: LD_ADDR_VAR 0 2
2270: PUSH
2271: LD_INT 1000
2273: PUSH
2274: LD_INT 2500
2276: PUSH
2277: LD_INT 5000
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: LD_OWVAR 67
2289: ARRAY
2290: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2291: LD_ADDR_VAR 0 2
2295: PUSH
2296: LD_VAR 0 2
2300: PUSH
2301: LD_INT 1
2303: NEG
2304: PUSH
2305: LD_INT 22
2307: PUSH
2308: LD_OWVAR 2
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: MUL
2336: PUSH
2337: LD_INT 30
2339: MUL
2340: PLUS
2341: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2342: LD_ADDR_VAR 0 2
2346: PUSH
2347: LD_VAR 0 2
2351: PUSH
2352: LD_EXP 15
2356: PUSH
2357: LD_INT 10
2359: MUL
2360: PLUS
2361: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2362: LD_ADDR_VAR 0 2
2366: PUSH
2367: LD_VAR 0 2
2371: PUSH
2372: LD_INT 1
2374: NEG
2375: PUSH
2376: LD_EXP 15
2380: MUL
2381: PUSH
2382: LD_INT 20
2384: MUL
2385: PLUS
2386: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_INT 1
2399: NEG
2400: PUSH
2401: LD_OWVAR 1
2405: PUSH
2406: LD_INT 35
2408: DIVREAL
2409: PUSH
2410: LD_INT 60
2412: DIVREAL
2413: MUL
2414: PUSH
2415: LD_INT 25
2417: MUL
2418: PLUS
2419: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: LD_VAR 0 2
2429: PUSH
2430: LD_EXP 17
2434: PUSH
2435: LD_INT 15
2437: MUL
2438: PLUS
2439: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2440: LD_ADDR_VAR 0 2
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: NEG
2453: PUSH
2454: LD_EXP 18
2458: MUL
2459: PUSH
2460: LD_INT 1000
2462: MUL
2463: PLUS
2464: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 16
2479: PUSH
2480: LD_INT 5
2482: MUL
2483: PLUS
2484: ST_TO_ADDR
// result := points ;
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_VAR 0 2
2494: ST_TO_ADDR
// end ; end_of_file
2495: LD_VAR 0 1
2499: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2500: LD_VAR 0 1
2504: PPUSH
2505: CALL_OW 255
2509: PUSH
2510: LD_OWVAR 2
2514: EQUAL
2515: IFFALSE 2531
// dead_counter := dead_counter + 1 ;
2517: LD_ADDR_EXP 14
2521: PUSH
2522: LD_EXP 14
2526: PUSH
2527: LD_INT 1
2529: PLUS
2530: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 255
2540: PUSH
2541: LD_INT 81
2543: PUSH
2544: LD_OWVAR 2
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: IN
2558: IFFALSE 2574
// kill_counter := kill_counter + 1 ;
2560: LD_ADDR_EXP 15
2564: PUSH
2565: LD_EXP 15
2569: PUSH
2570: LD_INT 1
2572: PLUS
2573: ST_TO_ADDR
// if un = player_commander then
2574: LD_VAR 0 1
2578: PUSH
2579: LD_EXP 10
2583: EQUAL
2584: IFFALSE 2593
// YouLost ( vulcano-lost ) ;
2586: LD_STRING vulcano-lost
2588: PPUSH
2589: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2593: LD_VAR 0 1
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_INT 3
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: PUSH
2608: LD_INT 21
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PPUSH
2622: CALL_OW 69
2626: IN
2627: IFFALSE 2743
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2629: LD_VAR 0 1
2633: PPUSH
2634: CALL_OW 266
2638: PUSH
2639: LD_INT 33
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 266
2652: PUSH
2653: LD_INT 28
2655: EQUAL
2656: OR
2657: IFFALSE 2743
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2659: LD_ADDR_EXP 26
2663: PUSH
2664: LD_EXP 26
2668: PUSH
2669: LD_VAR 0 1
2673: PPUSH
2674: CALL_OW 266
2678: ADD
2679: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2680: LD_ADDR_EXP 26
2684: PUSH
2685: LD_EXP 26
2689: PUSH
2690: LD_VAR 0 1
2694: PPUSH
2695: CALL_OW 250
2699: ADD
2700: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2701: LD_ADDR_EXP 26
2705: PUSH
2706: LD_EXP 26
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 251
2720: ADD
2721: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2722: LD_ADDR_EXP 26
2726: PUSH
2727: LD_EXP 26
2731: PUSH
2732: LD_VAR 0 1
2736: PPUSH
2737: CALL_OW 254
2741: ADD
2742: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2743: LD_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 8
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: IN
2777: IFFALSE 2921
// begin if GetBType ( un ) = b_barracks then
2779: LD_VAR 0 1
2783: PPUSH
2784: CALL_OW 266
2788: PUSH
2789: LD_INT 5
2791: EQUAL
2792: IFFALSE 2810
// legion_blist := legion_blist ^ b_armoury else
2794: LD_ADDR_EXP 34
2798: PUSH
2799: LD_EXP 34
2803: PUSH
2804: LD_INT 4
2806: ADD
2807: ST_TO_ADDR
2808: GO 2858
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2810: LD_VAR 0 1
2814: PPUSH
2815: CALL_OW 266
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 6
2825: PUSH
2826: LD_INT 8
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: IN
2834: NOT
2835: IFFALSE 2858
// legion_blist := legion_blist ^ GetBType ( un ) ;
2837: LD_ADDR_EXP 34
2841: PUSH
2842: LD_EXP 34
2846: PUSH
2847: LD_VAR 0 1
2851: PPUSH
2852: CALL_OW 266
2856: ADD
2857: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2858: LD_ADDR_EXP 34
2862: PUSH
2863: LD_EXP 34
2867: PUSH
2868: LD_VAR 0 1
2872: PPUSH
2873: CALL_OW 250
2877: ADD
2878: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2879: LD_ADDR_EXP 34
2883: PUSH
2884: LD_EXP 34
2888: PUSH
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 251
2898: ADD
2899: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2900: LD_ADDR_EXP 34
2904: PUSH
2905: LD_EXP 34
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: CALL_OW 254
2919: ADD
2920: ST_TO_ADDR
// end ; if un in legion_force then
2921: LD_VAR 0 1
2925: PUSH
2926: LD_EXP 31
2930: IN
2931: IFFALSE 2949
// legion_force := legion_force diff un ;
2933: LD_ADDR_EXP 31
2937: PUSH
2938: LD_EXP 31
2942: PUSH
2943: LD_VAR 0 1
2947: DIFF
2948: ST_TO_ADDR
// if un in ru_force then
2949: LD_VAR 0 1
2953: PUSH
2954: LD_EXP 23
2958: IN
2959: IFFALSE 2977
// ru_force := ru_force diff un ;
2961: LD_ADDR_EXP 23
2965: PUSH
2966: LD_EXP 23
2970: PUSH
2971: LD_VAR 0 1
2975: DIFF
2976: ST_TO_ADDR
// if un in al_force then
2977: LD_VAR 0 1
2981: PUSH
2982: LD_EXP 38
2986: IN
2987: IFFALSE 3005
// al_force := al_force diff un ;
2989: LD_ADDR_EXP 38
2993: PUSH
2994: LD_EXP 38
2998: PUSH
2999: LD_VAR 0 1
3003: DIFF
3004: ST_TO_ADDR
// end ;
3005: PPOPN 1
3007: END
// on BuildingComplete ( b ) do var i ;
3008: LD_INT 0
3010: PPUSH
// begin if GetSide ( b ) = 8 then
3011: LD_VAR 0 1
3015: PPUSH
3016: CALL_OW 255
3020: PUSH
3021: LD_INT 8
3023: EQUAL
3024: IFFALSE 3064
// for i = 1 to 4 do
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: DOUBLE
3032: LD_INT 1
3034: DEC
3035: ST_TO_ADDR
3036: LD_INT 4
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3062
// legion_blist := Delete ( legion_blist , 1 ) ;
3042: LD_ADDR_EXP 34
3046: PUSH
3047: LD_EXP 34
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: CALL_OW 3
3059: ST_TO_ADDR
3060: GO 3039
3062: POP
3063: POP
// if GetSide ( b ) = 3 then
3064: LD_VAR 0 1
3068: PPUSH
3069: CALL_OW 255
3073: PUSH
3074: LD_INT 3
3076: EQUAL
3077: IFFALSE 3117
// for i = 1 to 4 do
3079: LD_ADDR_VAR 0 2
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_INT 4
3091: PUSH
3092: FOR_TO
3093: IFFALSE 3115
// ru_blist := Delete ( ru_blist , 1 ) ;
3095: LD_ADDR_EXP 26
3099: PUSH
3100: LD_EXP 26
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: CALL_OW 3
3112: ST_TO_ADDR
3113: GO 3092
3115: POP
3116: POP
// end ;
3117: PPOPN 2
3119: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3120: LD_VAR 0 1
3124: PPUSH
3125: CALL_OW 264
3129: PUSH
3130: LD_INT 51
3132: PUSH
3133: LD_INT 48
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: IN
3140: NOT
3141: IFFALSE 3189
// begin if GetSide ( veh ) = 3 then
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 255
3152: PUSH
3153: LD_INT 3
3155: EQUAL
3156: IFFALSE 3189
// begin ComMoveXY ( veh , 149 , 8 ) ;
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 149
3165: PPUSH
3166: LD_INT 8
3168: PPUSH
3169: CALL_OW 111
// ru_force := ru_force ^ veh ;
3173: LD_ADDR_EXP 23
3177: PUSH
3178: LD_EXP 23
3182: PUSH
3183: LD_VAR 0 1
3187: ADD
3188: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 264
3198: PUSH
3199: LD_INT 32
3201: PUSH
3202: LD_INT 31
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: IN
3209: NOT
3210: IFFALSE 3243
// begin if GetSide ( veh ) = 8 then
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 255
3221: PUSH
3222: LD_INT 8
3224: EQUAL
3225: IFFALSE 3243
// legion_force := legion_force ^ veh ;
3227: LD_ADDR_EXP 31
3231: PUSH
3232: LD_EXP 31
3236: PUSH
3237: LD_VAR 0 1
3241: ADD
3242: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3243: LD_VAR 0 1
3247: PPUSH
3248: CALL_OW 255
3252: PUSH
3253: LD_INT 7
3255: EQUAL
3256: PUSH
3257: LD_OWVAR 2
3261: PUSH
3262: LD_INT 7
3264: NONEQUAL
3265: AND
3266: IFFALSE 3284
// al_force := al_force ^ veh ;
3268: LD_ADDR_EXP 38
3272: PUSH
3273: LD_EXP 38
3277: PUSH
3278: LD_VAR 0 1
3282: ADD
3283: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3284: LD_VAR 0 1
3288: PPUSH
3289: CALL_OW 255
3293: PUSH
3294: LD_OWVAR 2
3298: EQUAL
3299: IFFALSE 3315
// veh_counter := veh_counter + 1 ;
3301: LD_ADDR_EXP 16
3305: PUSH
3306: LD_EXP 16
3310: PUSH
3311: LD_INT 1
3313: PLUS
3314: ST_TO_ADDR
// end ;
3315: PPOPN 2
3317: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3318: LD_VAR 0 1
3322: PPUSH
3323: CALL_OW 255
3327: PUSH
3328: LD_OWVAR 2
3332: NONEQUAL
3333: IFFALSE 3349
// sib_contamin_counter := sib_contamin_counter + 1 ;
3335: LD_ADDR_EXP 18
3339: PUSH
3340: LD_EXP 18
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: ST_TO_ADDR
// end ;
3349: PPOPN 3
3351: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3352: LD_VAR 0 2
3356: PPUSH
3357: CALL_OW 255
3361: PUSH
3362: LD_OWVAR 2
3366: EQUAL
3367: IFFALSE 3383
// tech_counter := tech_counter + 1 ;
3369: LD_ADDR_EXP 17
3373: PUSH
3374: LD_EXP 17
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: ST_TO_ADDR
// end ;
3383: PPOPN 2
3385: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3386: LD_INT 25
3388: PUSH
3389: LD_INT 12
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 69
3400: PUSH
3401: LD_INT 9
3403: LESS
3404: IFFALSE 3446
3406: GO 3408
3408: DISABLE
3409: LD_INT 0
3411: PPUSH
// begin enable ;
3412: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3413: LD_ADDR_VAR 0 1
3417: PUSH
3418: LD_INT 25
3420: PUSH
3421: LD_INT 12
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PPUSH
3428: CALL_OW 69
3432: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3433: LD_INT 8
3435: PUSH
3436: LD_VAR 0 1
3440: MINUS
3441: PPUSH
3442: CALL 1883 0 1
// end ; end_of_file
3446: PPOPN 1
3448: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3449: LD_INT 0
3451: PPUSH
3452: PPUSH
3453: PPUSH
3454: PPUSH
3455: PPUSH
3456: PPUSH
3457: PPUSH
3458: PPUSH
3459: PPUSH
3460: PPUSH
3461: PPUSH
// uc_side := 3 ;
3462: LD_ADDR_OWVAR 20
3466: PUSH
3467: LD_INT 3
3469: ST_TO_ADDR
// uc_nation := nation_russian ;
3470: LD_ADDR_OWVAR 21
3474: PUSH
3475: LD_INT 3
3477: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3478: LD_ADDR_VAR 0 4
3482: PUSH
3483: LD_INT 22
3485: PUSH
3486: LD_INT 3
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: PUSH
3493: LD_INT 30
3495: PUSH
3496: LD_INT 1
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 69
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3516: LD_ADDR_VAR 0 5
3520: PUSH
3521: LD_INT 22
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: LD_INT 30
3533: PUSH
3534: LD_INT 3
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 69
3549: PUSH
3550: LD_INT 1
3552: ARRAY
3553: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3554: LD_ADDR_VAR 0 6
3558: PUSH
3559: LD_INT 22
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 30
3571: PUSH
3572: LD_INT 34
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PPUSH
3583: CALL_OW 69
3587: PUSH
3588: LD_INT 1
3590: ARRAY
3591: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3592: LD_ADDR_VAR 0 8
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 33
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3626: LD_ADDR_VAR 0 7
3630: PUSH
3631: LD_INT 22
3633: PUSH
3634: LD_INT 3
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: PUSH
3641: LD_INT 30
3643: PUSH
3644: LD_INT 5
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PPUSH
3655: CALL_OW 69
3659: PUSH
3660: LD_INT 1
3662: ARRAY
3663: ST_TO_ADDR
// ru_blist := [ ] ;
3664: LD_ADDR_EXP 26
3668: PUSH
3669: EMPTY
3670: ST_TO_ADDR
// ru_vlist := [ ] ;
3671: LD_ADDR_EXP 27
3675: PUSH
3676: EMPTY
3677: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3678: LD_ADDR_EXP 30
3682: PUSH
3683: LD_INT 183
3685: PUSH
3686: LD_INT 62
3688: PUSH
3689: LD_INT 147
3691: PUSH
3692: LD_INT 44
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3701: LD_INT 30
3703: PUSH
3704: LD_INT 34
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PPUSH
3711: CALL_OW 69
3715: PUSH
3716: LD_INT 1
3718: ARRAY
3719: PPUSH
3720: LD_EXP 30
3724: PUSH
3725: LD_INT 1
3727: ARRAY
3728: PPUSH
3729: LD_EXP 30
3733: PUSH
3734: LD_INT 2
3736: ARRAY
3737: PPUSH
3738: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3742: LD_ADDR_EXP 28
3746: PUSH
3747: LD_INT 4
3749: PUSH
3750: LD_INT 5
3752: PUSH
3753: LD_INT 6
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: LIST
3760: PUSH
3761: LD_OWVAR 67
3765: ARRAY
3766: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3767: LD_VAR 0 4
3771: PPUSH
3772: CALL_OW 274
3776: PPUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 3000
3782: PPUSH
3783: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3787: LD_VAR 0 4
3791: PPUSH
3792: CALL_OW 274
3796: PPUSH
3797: LD_INT 2
3799: PPUSH
3800: LD_INT 300
3802: PPUSH
3803: CALL_OW 277
// hc_gallery :=  ;
3807: LD_ADDR_OWVAR 33
3811: PUSH
3812: LD_STRING 
3814: ST_TO_ADDR
// hc_name :=  ;
3815: LD_ADDR_OWVAR 26
3819: PUSH
3820: LD_STRING 
3822: ST_TO_ADDR
// hc_importance := 0 ;
3823: LD_ADDR_OWVAR 32
3827: PUSH
3828: LD_INT 0
3830: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3831: LD_ADDR_EXP 24
3835: PUSH
3836: LD_INT 5
3838: PUSH
3839: LD_INT 6
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: PUSH
3850: LD_OWVAR 67
3854: ARRAY
3855: ST_TO_ADDR
// for i = 1 to 6 do
3856: LD_ADDR_VAR 0 2
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_INT 6
3868: PUSH
3869: FOR_TO
3870: IFFALSE 4028
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3872: LD_INT 0
3874: PPUSH
3875: LD_INT 9
3877: PPUSH
3878: LD_EXP 24
3882: PPUSH
3883: CALL_OW 380
// un := CreateHuman ;
3887: LD_ADDR_VAR 0 3
3891: PUSH
3892: CALL_OW 44
3896: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3897: LD_VAR 0 3
3901: PPUSH
3902: LD_VAR 0 7
3906: PPUSH
3907: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3911: LD_INT 0
3913: PPUSH
3914: LD_INT 4
3916: PPUSH
3917: LD_EXP 24
3921: PPUSH
3922: CALL_OW 380
// un := CreateHuman ;
3926: LD_ADDR_VAR 0 3
3930: PUSH
3931: CALL_OW 44
3935: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3936: LD_VAR 0 3
3940: PPUSH
3941: LD_INT 24
3943: PPUSH
3944: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3948: LD_INT 0
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_EXP 24
3958: PPUSH
3959: CALL_OW 380
// un := CreateHuman ;
3963: LD_ADDR_VAR 0 3
3967: PUSH
3968: CALL_OW 44
3972: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
3973: LD_VAR 0 3
3977: PPUSH
3978: LD_VAR 0 5
3982: PPUSH
3983: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
3987: LD_INT 0
3989: PPUSH
3990: LD_INT 2
3992: PPUSH
3993: LD_EXP 24
3997: PPUSH
3998: CALL_OW 380
// un := CreateHuman ;
4002: LD_ADDR_VAR 0 3
4006: PUSH
4007: CALL_OW 44
4011: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4012: LD_VAR 0 3
4016: PPUSH
4017: LD_VAR 0 4
4021: PPUSH
4022: CALL_OW 52
// end ;
4026: GO 3869
4028: POP
4029: POP
// russian_prepared := true ;
4030: LD_ADDR_EXP 2
4034: PUSH
4035: LD_INT 1
4037: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4038: LD_VAR 0 5
4042: PPUSH
4043: LD_INT 21
4045: PPUSH
4046: LD_INT 3
4048: PPUSH
4049: LD_INT 3
4051: PPUSH
4052: LD_INT 51
4054: PPUSH
4055: CALL_OW 125
// end ;
4059: LD_VAR 0 1
4063: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4064: LD_INT 22
4066: PUSH
4067: LD_INT 3
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PPUSH
4074: CALL_OW 69
4078: PUSH
4079: LD_INT 0
4081: GREATER
4082: PUSH
4083: LD_EXP 2
4087: AND
4088: IFFALSE 6537
4090: GO 4092
4092: DISABLE
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
4099: PPUSH
4100: PPUSH
4101: PPUSH
4102: PPUSH
4103: PPUSH
4104: PPUSH
4105: PPUSH
4106: PPUSH
4107: PPUSH
4108: PPUSH
4109: PPUSH
4110: PPUSH
4111: PPUSH
// begin enable ;
4112: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4113: LD_ADDR_VAR 0 1
4117: PUSH
4118: LD_INT 22
4120: PUSH
4121: LD_INT 3
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 30
4130: PUSH
4131: LD_INT 1
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4151: LD_ADDR_VAR 0 2
4155: PUSH
4156: LD_INT 22
4158: PUSH
4159: LD_INT 3
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 30
4168: PUSH
4169: LD_INT 3
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PPUSH
4180: CALL_OW 69
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4189: LD_ADDR_VAR 0 3
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 3
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 30
4206: PUSH
4207: LD_INT 34
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PPUSH
4218: CALL_OW 69
4222: PUSH
4223: LD_INT 1
4225: ARRAY
4226: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4227: LD_ADDR_VAR 0 4
4231: PUSH
4232: LD_INT 22
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 33
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4261: LD_ADDR_VAR 0 8
4265: PUSH
4266: LD_INT 22
4268: PUSH
4269: LD_INT 3
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PUSH
4276: LD_INT 30
4278: PUSH
4279: LD_INT 5
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PPUSH
4290: CALL_OW 69
4294: PUSH
4295: LD_INT 1
4297: ARRAY
4298: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4299: LD_ADDR_VAR 0 5
4303: PUSH
4304: LD_INT 22
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 21
4316: PUSH
4317: LD_INT 3
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PPUSH
4328: CALL_OW 69
4332: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: LD_INT 22
4340: PUSH
4341: LD_INT 3
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: LD_INT 21
4350: PUSH
4351: LD_INT 2
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: PPUSH
4362: CALL_OW 69
4366: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 3
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 21
4384: PUSH
4385: LD_INT 1
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4401: LD_ADDR_VAR 0 9
4405: PUSH
4406: LD_VAR 0 7
4410: PPUSH
4411: LD_INT 25
4413: PUSH
4414: LD_INT 2
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 72
4425: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4426: LD_ADDR_VAR 0 10
4430: PUSH
4431: LD_VAR 0 7
4435: PPUSH
4436: LD_INT 25
4438: PUSH
4439: LD_INT 3
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 72
4450: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4451: LD_ADDR_VAR 0 11
4455: PUSH
4456: LD_VAR 0 7
4460: PPUSH
4461: LD_INT 25
4463: PUSH
4464: LD_INT 4
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PPUSH
4471: CALL_OW 72
4475: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4476: LD_INT 22
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 34
4488: PUSH
4489: LD_INT 51
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PPUSH
4500: CALL_OW 69
4504: PUSH
4505: LD_INT 0
4507: GREATER
4508: PUSH
4509: LD_EXP 25
4513: PUSH
4514: LD_INT 0
4516: EQUAL
4517: AND
4518: IFFALSE 4558
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4520: LD_ADDR_EXP 25
4524: PUSH
4525: LD_INT 22
4527: PUSH
4528: LD_INT 3
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: LD_INT 34
4537: PUSH
4538: LD_INT 51
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PPUSH
4549: CALL_OW 69
4553: PUSH
4554: LD_INT 1
4556: ARRAY
4557: ST_TO_ADDR
// if ru_cargo then
4558: LD_EXP 25
4562: IFFALSE 4860
// begin if IsInArea ( ru_cargo , ru_base ) then
4564: LD_EXP 25
4568: PPUSH
4569: LD_INT 9
4571: PPUSH
4572: CALL_OW 308
4576: IFFALSE 4655
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4578: LD_EXP 25
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 289
4590: PUSH
4591: LD_INT 0
4593: EQUAL
4594: IFFALSE 4612
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4596: LD_EXP 25
4600: PPUSH
4601: LD_VAR 0 3
4605: PPUSH
4606: CALL_OW 120
4610: GO 4653
// if not HasTask ( ru_cargo ) then
4612: LD_EXP 25
4616: PPUSH
4617: CALL_OW 314
4621: NOT
4622: IFFALSE 4653
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4624: LD_EXP 25
4628: PPUSH
4629: LD_VAR 0 1
4633: PPUSH
4634: CALL_OW 250
4638: PPUSH
4639: LD_VAR 0 1
4643: PPUSH
4644: CALL_OW 251
4648: PPUSH
4649: CALL_OW 111
// end else
4653: GO 4860
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4655: LD_EXP 25
4659: PPUSH
4660: CALL_OW 314
4664: NOT
4665: PUSH
4666: LD_EXP 25
4670: PPUSH
4671: LD_INT 1
4673: PPUSH
4674: CALL_OW 289
4678: PUSH
4679: LD_INT 100
4681: LESS
4682: AND
4683: IFFALSE 4749
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4685: LD_ADDR_VAR 0 16
4689: PUSH
4690: LD_INT 11
4692: PPUSH
4693: CALL_OW 435
4697: ST_TO_ADDR
// if cr > 0 then
4698: LD_VAR 0 16
4702: PUSH
4703: LD_INT 0
4705: GREATER
4706: IFFALSE 4737
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4708: LD_EXP 25
4712: PPUSH
4713: LD_VAR 0 16
4717: PUSH
4718: LD_INT 1
4720: ARRAY
4721: PPUSH
4722: LD_VAR 0 16
4726: PUSH
4727: LD_INT 2
4729: ARRAY
4730: PPUSH
4731: CALL_OW 117
4735: GO 4749
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4737: LD_EXP 25
4741: PPUSH
4742: LD_INT 11
4744: PPUSH
4745: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4749: LD_EXP 25
4753: PPUSH
4754: CALL_OW 314
4758: NOT
4759: PUSH
4760: LD_EXP 25
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 308
4772: NOT
4773: AND
4774: PUSH
4775: LD_EXP 25
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: CALL_OW 289
4787: PUSH
4788: LD_INT 100
4790: EQUAL
4791: AND
4792: IFFALSE 4806
// ComMoveToArea ( ru_cargo , cargoa ) ;
4794: LD_EXP 25
4798: PPUSH
4799: LD_INT 10
4801: PPUSH
4802: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4806: LD_EXP 25
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 308
4818: PUSH
4819: LD_VAR 0 8
4823: AND
4824: IFFALSE 4860
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4826: LD_VAR 0 7
4830: PPUSH
4831: LD_INT 25
4833: PUSH
4834: LD_INT 9
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: PUSH
4846: LD_INT 1
4848: ARRAY
4849: PPUSH
4850: LD_INT 139
4852: PPUSH
4853: LD_INT 24
4855: PPUSH
4856: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4860: LD_EXP 25
4864: PUSH
4865: LD_INT 0
4867: EQUAL
4868: PUSH
4869: LD_VAR 0 2
4873: AND
4874: PUSH
4875: LD_VAR 0 2
4879: PPUSH
4880: CALL_OW 461
4884: PUSH
4885: LD_INT 2
4887: EQUAL
4888: AND
4889: IFFALSE 4912
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4891: LD_VAR 0 2
4895: PPUSH
4896: LD_INT 21
4898: PPUSH
4899: LD_INT 3
4901: PPUSH
4902: LD_INT 3
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4912: LD_VAR 0 7
4916: PPUSH
4917: LD_INT 25
4919: PUSH
4920: LD_INT 9
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 72
4931: IFFALSE 4995
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4933: LD_VAR 0 7
4937: PPUSH
4938: LD_INT 25
4940: PUSH
4941: LD_INT 9
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 72
4952: PPUSH
4953: LD_INT 22
4955: PUSH
4956: LD_OWVAR 2
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: LD_INT 21
4970: PUSH
4971: LD_INT 3
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PPUSH
4986: CALL_OW 69
4990: PPUSH
4991: CALL 1656 0 2
// if ru_factory and ru_vlist > 0 then
4995: LD_VAR 0 2
4999: PUSH
5000: LD_EXP 27
5004: PUSH
5005: LD_INT 0
5007: GREATER
5008: AND
5009: IFFALSE 5109
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5011: LD_VAR 0 2
5015: PPUSH
5016: CALL_OW 461
5020: PUSH
5021: LD_INT 2
5023: EQUAL
5024: IFFALSE 5109
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5026: LD_VAR 0 2
5030: PPUSH
5031: LD_EXP 27
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PPUSH
5040: LD_EXP 27
5044: PUSH
5045: LD_INT 2
5047: ARRAY
5048: PPUSH
5049: LD_EXP 27
5053: PUSH
5054: LD_INT 3
5056: ARRAY
5057: PPUSH
5058: LD_EXP 27
5062: PUSH
5063: LD_INT 4
5065: ARRAY
5066: PPUSH
5067: CALL_OW 125
// for i = 1 to 4 do
5071: LD_ADDR_VAR 0 12
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 4
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5107
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5087: LD_ADDR_EXP 27
5091: PUSH
5092: LD_EXP 27
5096: PPUSH
5097: LD_INT 1
5099: PPUSH
5100: CALL_OW 3
5104: ST_TO_ADDR
5105: GO 5084
5107: POP
5108: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5109: LD_INT 24
5111: PPUSH
5112: CALL_OW 461
5116: PUSH
5117: LD_INT 2
5119: EQUAL
5120: PUSH
5121: LD_EXP 4
5125: AND
5126: IFFALSE 5154
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5128: LD_INT 25
5130: PPUSH
5131: LD_INT 3
5133: PPUSH
5134: CALL_OW 321
5138: PUSH
5139: LD_INT 1
5141: EQUAL
5142: IFFALSE 5154
// ComResearch ( ru_lab , tech_sibfiss ) ;
5144: LD_INT 24
5146: PPUSH
5147: LD_INT 25
5149: PPUSH
5150: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched then
5154: LD_INT 25
5156: PPUSH
5157: LD_INT 3
5159: PPUSH
5160: CALL_OW 321
5164: PUSH
5165: LD_INT 2
5167: EQUAL
5168: IFFALSE 5206
// if BuildingStatus ( ru_factory ) = bs_idle then
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 461
5179: PUSH
5180: LD_INT 2
5182: EQUAL
5183: IFFALSE 5206
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5185: LD_VAR 0 2
5189: PPUSH
5190: LD_INT 23
5192: PPUSH
5193: LD_INT 3
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 48
5201: PPUSH
5202: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5206: LD_INT 22
5208: PUSH
5209: LD_INT 3
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PUSH
5216: LD_INT 34
5218: PUSH
5219: LD_INT 48
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 69
5234: PUSH
5235: LD_INT 0
5237: GREATER
5238: IFFALSE 5612
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5240: LD_ADDR_VAR 0 17
5244: PUSH
5245: LD_INT 22
5247: PUSH
5248: LD_INT 3
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: LD_INT 34
5257: PUSH
5258: LD_INT 48
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PPUSH
5269: CALL_OW 69
5273: PUSH
5274: LD_INT 1
5276: ARRAY
5277: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5278: LD_VAR 0 17
5282: PPUSH
5283: LD_INT 9
5285: PPUSH
5286: CALL_OW 308
5290: IFFALSE 5308
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5292: LD_VAR 0 17
5296: PPUSH
5297: LD_VAR 0 3
5301: PPUSH
5302: CALL_OW 120
5306: GO 5612
// if not HasTask ( sib_bomb ) then
5308: LD_VAR 0 17
5312: PPUSH
5313: CALL_OW 314
5317: NOT
5318: IFFALSE 5612
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5320: LD_INT 22
5322: PUSH
5323: LD_OWVAR 2
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: PUSH
5332: LD_INT 30
5334: PUSH
5335: LD_INT 1
5337: PUSH
5338: EMPTY
5339: LIST
5340: LIST
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PPUSH
5346: CALL_OW 69
5350: PUSH
5351: LD_INT 1
5353: ARRAY
5354: PPUSH
5355: CALL_OW 256
5359: PUSH
5360: LD_INT 250
5362: GREATER
5363: IFFALSE 5456
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5365: LD_VAR 0 17
5369: PPUSH
5370: LD_INT 22
5372: PUSH
5373: LD_OWVAR 2
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PUSH
5382: LD_INT 30
5384: PUSH
5385: LD_INT 1
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PPUSH
5396: CALL_OW 69
5400: PUSH
5401: LD_INT 1
5403: ARRAY
5404: PPUSH
5405: CALL_OW 250
5409: PPUSH
5410: LD_INT 22
5412: PUSH
5413: LD_OWVAR 2
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: PUSH
5422: LD_INT 30
5424: PUSH
5425: LD_INT 1
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: PUSH
5441: LD_INT 1
5443: ARRAY
5444: PPUSH
5445: CALL_OW 251
5449: PPUSH
5450: CALL_OW 116
5454: GO 5612
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5456: LD_INT 22
5458: PUSH
5459: LD_OWVAR 2
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PUSH
5468: LD_INT 21
5470: PUSH
5471: LD_INT 3
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PPUSH
5482: CALL_OW 69
5486: PUSH
5487: LD_INT 0
5489: GREATER
5490: IFFALSE 5583
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5492: LD_VAR 0 17
5496: PPUSH
5497: LD_INT 22
5499: PUSH
5500: LD_OWVAR 2
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PUSH
5509: LD_INT 21
5511: PUSH
5512: LD_INT 3
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: PUSH
5528: LD_INT 1
5530: ARRAY
5531: PPUSH
5532: CALL_OW 250
5536: PPUSH
5537: LD_INT 22
5539: PUSH
5540: LD_OWVAR 2
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 21
5551: PUSH
5552: LD_INT 3
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL_OW 69
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: CALL_OW 251
5576: PPUSH
5577: CALL_OW 116
5581: GO 5612
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5583: LD_VAR 0 17
5587: PPUSH
5588: LD_EXP 10
5592: PPUSH
5593: CALL_OW 250
5597: PPUSH
5598: LD_EXP 10
5602: PPUSH
5603: CALL_OW 251
5607: PPUSH
5608: CALL_OW 116
// end ; if ru_can_attack then
5612: LD_EXP 3
5616: IFFALSE 5764
// if ru_time > 0 0$00 then
5618: LD_EXP 29
5622: PUSH
5623: LD_INT 0
5625: GREATER
5626: IFFALSE 5644
// ru_time := ru_time - 0 0$01 else
5628: LD_ADDR_EXP 29
5632: PUSH
5633: LD_EXP 29
5637: PUSH
5638: LD_INT 35
5640: MINUS
5641: ST_TO_ADDR
5642: GO 5764
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5644: LD_ADDR_EXP 29
5648: PUSH
5649: LD_INT 20265
5651: PPUSH
5652: LD_INT 30765
5654: PPUSH
5655: CALL_OW 12
5659: ST_TO_ADDR
// for i = 1 to ru_amount do
5660: LD_ADDR_VAR 0 12
5664: PUSH
5665: DOUBLE
5666: LD_INT 1
5668: DEC
5669: ST_TO_ADDR
5670: LD_EXP 28
5674: PUSH
5675: FOR_TO
5676: IFFALSE 5762
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5678: LD_ADDR_EXP 27
5682: PUSH
5683: LD_EXP 27
5687: PUSH
5688: LD_INT 23
5690: ADD
5691: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5692: LD_ADDR_EXP 27
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ADD
5705: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5706: LD_ADDR_EXP 27
5710: PUSH
5711: LD_EXP 27
5715: PUSH
5716: LD_INT 3
5718: ADD
5719: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5720: LD_ADDR_EXP 27
5724: PUSH
5725: LD_EXP 27
5729: PUSH
5730: LD_INT 46
5732: PUSH
5733: LD_INT 45
5735: PUSH
5736: LD_INT 47
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 1
5746: PPUSH
5747: LD_INT 2
5749: PPUSH
5750: LD_INT 3
5752: PPUSH
5753: CALL_OW 14
5757: ARRAY
5758: ADD
5759: ST_TO_ADDR
// end ;
5760: GO 5675
5762: POP
5763: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5764: LD_VAR 0 4
5768: PPUSH
5769: LD_INT 35
5771: PUSH
5772: LD_INT 0
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PPUSH
5779: CALL_OW 72
5783: PUSH
5784: LD_INT 0
5786: GREATER
5787: IFFALSE 5835
// if BuildingStatus ( ru_factory ) = bs_idle then
5789: LD_VAR 0 2
5793: PPUSH
5794: CALL_OW 461
5798: PUSH
5799: LD_INT 2
5801: EQUAL
5802: IFFALSE 5835
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5804: LD_VAR 0 4
5808: PPUSH
5809: LD_INT 35
5811: PUSH
5812: LD_INT 0
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PPUSH
5819: CALL_OW 72
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_INT 47
5830: PPUSH
5831: CALL_OW 148
// if ru_force = ru_amount then
5835: LD_EXP 23
5839: PUSH
5840: LD_EXP 28
5844: EQUAL
5845: IFFALSE 5977
// begin for i = 1 to ru_force do
5847: LD_ADDR_VAR 0 12
5851: PUSH
5852: DOUBLE
5853: LD_INT 1
5855: DEC
5856: ST_TO_ADDR
5857: LD_EXP 23
5861: PUSH
5862: FOR_TO
5863: IFFALSE 5973
// if IsInArea ( ru_force [ i ] , ru_base ) then
5865: LD_EXP 23
5869: PUSH
5870: LD_VAR 0 12
5874: ARRAY
5875: PPUSH
5876: LD_INT 9
5878: PPUSH
5879: CALL_OW 308
5883: IFFALSE 5907
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5885: LD_EXP 23
5889: PUSH
5890: LD_VAR 0 12
5894: ARRAY
5895: PPUSH
5896: LD_VAR 0 3
5900: PPUSH
5901: CALL_OW 120
5905: GO 5971
// if not HasTask ( ru_force [ i ] ) then
5907: LD_EXP 23
5911: PUSH
5912: LD_VAR 0 12
5916: ARRAY
5917: PPUSH
5918: CALL_OW 314
5922: NOT
5923: IFFALSE 5971
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5925: LD_EXP 23
5929: PUSH
5930: LD_VAR 0 12
5934: ARRAY
5935: PPUSH
5936: LD_INT 81
5938: PUSH
5939: LD_INT 3
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PPUSH
5946: CALL_OW 69
5950: PPUSH
5951: LD_EXP 23
5955: PUSH
5956: LD_VAR 0 12
5960: ARRAY
5961: PPUSH
5962: CALL_OW 74
5966: PPUSH
5967: CALL_OW 115
5971: GO 5862
5973: POP
5974: POP
// end else
5975: GO 6127
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
5977: LD_EXP 23
5981: PPUSH
5982: LD_INT 3
5984: PUSH
5985: LD_INT 95
5987: PUSH
5988: LD_INT 18
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: PUSH
6004: LD_INT 0
6006: GREATER
6007: IFFALSE 6127
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6009: LD_ADDR_VAR 0 13
6013: PUSH
6014: LD_EXP 23
6018: PPUSH
6019: LD_INT 3
6021: PUSH
6022: LD_INT 95
6024: PUSH
6025: LD_INT 18
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PPUSH
6036: CALL_OW 72
6040: ST_TO_ADDR
// for i = 1 to tmp do
6041: LD_ADDR_VAR 0 12
6045: PUSH
6046: DOUBLE
6047: LD_INT 1
6049: DEC
6050: ST_TO_ADDR
6051: LD_VAR 0 13
6055: PUSH
6056: FOR_TO
6057: IFFALSE 6125
// if not HasTask ( tmp [ i ] ) then
6059: LD_VAR 0 13
6063: PUSH
6064: LD_VAR 0 12
6068: ARRAY
6069: PPUSH
6070: CALL_OW 314
6074: NOT
6075: IFFALSE 6123
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6077: LD_EXP 23
6081: PUSH
6082: LD_VAR 0 12
6086: ARRAY
6087: PPUSH
6088: LD_INT 81
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PPUSH
6098: CALL_OW 69
6102: PPUSH
6103: LD_EXP 23
6107: PUSH
6108: LD_VAR 0 12
6112: ARRAY
6113: PPUSH
6114: CALL_OW 74
6118: PPUSH
6119: CALL_OW 115
6123: GO 6056
6125: POP
6126: POP
// end ; if ru_engs > 0 then
6127: LD_VAR 0 9
6131: PUSH
6132: LD_INT 0
6134: GREATER
6135: IFFALSE 6537
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6137: LD_VAR 0 5
6141: PPUSH
6142: LD_INT 3
6144: PUSH
6145: LD_INT 24
6147: PUSH
6148: LD_INT 1000
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 72
6163: PUSH
6164: LD_INT 0
6166: GREATER
6167: IFFALSE 6322
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6169: LD_ADDR_VAR 0 14
6173: PUSH
6174: LD_VAR 0 5
6178: PPUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 24
6184: PUSH
6185: LD_INT 1000
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PPUSH
6196: CALL_OW 72
6200: ST_TO_ADDR
// for i = 1 to ru_engs do
6201: LD_ADDR_VAR 0 12
6205: PUSH
6206: DOUBLE
6207: LD_INT 1
6209: DEC
6210: ST_TO_ADDR
6211: LD_VAR 0 9
6215: PUSH
6216: FOR_TO
6217: IFFALSE 6318
// begin if IsInUnit ( ru_engs [ i ] ) then
6219: LD_VAR 0 9
6223: PUSH
6224: LD_VAR 0 12
6228: ARRAY
6229: PPUSH
6230: CALL_OW 310
6234: IFFALSE 6253
// ComExitBuilding ( ru_engs [ i ] ) else
6236: LD_VAR 0 9
6240: PUSH
6241: LD_VAR 0 12
6245: ARRAY
6246: PPUSH
6247: CALL_OW 122
6251: GO 6316
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6253: LD_VAR 0 9
6257: PUSH
6258: LD_VAR 0 12
6262: ARRAY
6263: PPUSH
6264: CALL_OW 314
6268: NOT
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_VAR 0 12
6279: ARRAY
6280: PPUSH
6281: CALL_OW 256
6285: PUSH
6286: LD_INT 600
6288: GREATER
6289: AND
6290: IFFALSE 6316
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6292: LD_VAR 0 9
6296: PUSH
6297: LD_VAR 0 12
6301: ARRAY
6302: PPUSH
6303: LD_VAR 0 14
6307: PUSH
6308: LD_INT 1
6310: ARRAY
6311: PPUSH
6312: CALL_OW 130
// end ;
6316: GO 6216
6318: POP
6319: POP
// end else
6320: GO 6537
// begin if ru_blist = 0 then
6322: LD_EXP 26
6326: PUSH
6327: LD_INT 0
6329: EQUAL
6330: IFFALSE 6412
// begin for i = 1 to ru_engs do
6332: LD_ADDR_VAR 0 12
6336: PUSH
6337: DOUBLE
6338: LD_INT 1
6340: DEC
6341: ST_TO_ADDR
6342: LD_VAR 0 9
6346: PUSH
6347: FOR_TO
6348: IFFALSE 6408
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 310
6382: NOT
6383: AND
6384: IFFALSE 6406
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6386: LD_VAR 0 9
6390: PUSH
6391: LD_VAR 0 12
6395: ARRAY
6396: PPUSH
6397: LD_VAR 0 1
6401: PPUSH
6402: CALL_OW 120
6406: GO 6347
6408: POP
6409: POP
// end else
6410: GO 6537
// begin for i = 1 to ru_engs do
6412: LD_ADDR_VAR 0 12
6416: PUSH
6417: DOUBLE
6418: LD_INT 1
6420: DEC
6421: ST_TO_ADDR
6422: LD_VAR 0 9
6426: PUSH
6427: FOR_TO
6428: IFFALSE 6535
// begin if IsInUnit ( ru_engs [ i ] ) then
6430: LD_VAR 0 9
6434: PUSH
6435: LD_VAR 0 12
6439: ARRAY
6440: PPUSH
6441: CALL_OW 310
6445: IFFALSE 6464
// ComExitBuilding ( ru_engs [ i ] ) else
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 122
6462: GO 6533
// if not HasTask ( ru_engs [ i ] ) then
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 314
6479: NOT
6480: IFFALSE 6533
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6482: LD_VAR 0 9
6486: PUSH
6487: LD_VAR 0 12
6491: ARRAY
6492: PPUSH
6493: LD_EXP 26
6497: PUSH
6498: LD_INT 1
6500: ARRAY
6501: PPUSH
6502: LD_EXP 26
6506: PUSH
6507: LD_INT 2
6509: ARRAY
6510: PPUSH
6511: LD_EXP 26
6515: PUSH
6516: LD_INT 3
6518: ARRAY
6519: PPUSH
6520: LD_EXP 26
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PPUSH
6529: CALL_OW 145
// end ;
6533: GO 6427
6535: POP
6536: POP
// end ; end ; end ; end ;
6537: PPOPN 17
6539: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6540: LD_EXP 2
6544: PUSH
6545: LD_INT 11
6547: PPUSH
6548: CALL_OW 435
6552: PUSH
6553: LD_INT 20
6555: LESS
6556: AND
6557: IFFALSE 6620
6559: GO 6561
6561: DISABLE
// begin enable ;
6562: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6563: LD_INT 1
6565: PPUSH
6566: LD_INT 5
6568: PPUSH
6569: CALL_OW 12
6573: PPUSH
6574: LD_INT 11
6576: PPUSH
6577: LD_INT 1
6579: PPUSH
6580: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6584: LD_INT 1505
6586: PPUSH
6587: LD_INT 2100
6589: PPUSH
6590: CALL_OW 12
6594: PPUSH
6595: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6599: LD_INT 1
6601: PPUSH
6602: LD_INT 5
6604: PPUSH
6605: CALL_OW 12
6609: PPUSH
6610: LD_INT 11
6612: PPUSH
6613: LD_INT 1
6615: PPUSH
6616: CALL_OW 55
// end ;
6620: END
// every 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6621: LD_EXP 4
6625: PUSH
6626: LD_INT 0
6628: EQUAL
6629: IFFALSE 6744
6631: GO 6633
6633: DISABLE
6634: LD_INT 0
6636: PPUSH
6637: PPUSH
// begin enable ;
6638: ENABLE
// i := Rand ( 0 , 100 ) ;
6639: LD_ADDR_VAR 0 1
6643: PUSH
6644: LD_INT 0
6646: PPUSH
6647: LD_INT 100
6649: PPUSH
6650: CALL_OW 12
6654: ST_TO_ADDR
// case your_side of 1 :
6655: LD_OWVAR 2
6659: PUSH
6660: LD_INT 1
6662: DOUBLE
6663: EQUAL
6664: IFTRUE 6668
6666: GO 6679
6668: POP
// tmp := 10 ; 2 :
6669: LD_ADDR_VAR 0 2
6673: PUSH
6674: LD_INT 10
6676: ST_TO_ADDR
6677: GO 6718
6679: LD_INT 2
6681: DOUBLE
6682: EQUAL
6683: IFTRUE 6687
6685: GO 6698
6687: POP
// tmp := 0 ; 7 :
6688: LD_ADDR_VAR 0 2
6692: PUSH
6693: LD_INT 0
6695: ST_TO_ADDR
6696: GO 6718
6698: LD_INT 7
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6717
6706: POP
// tmp := 15 ; end ;
6707: LD_ADDR_VAR 0 2
6711: PUSH
6712: LD_INT 15
6714: ST_TO_ADDR
6715: GO 6718
6717: POP
// if i < chance_to_bomb + tmp then
6718: LD_VAR 0 1
6722: PUSH
6723: LD_EXP 5
6727: PUSH
6728: LD_VAR 0 2
6732: PLUS
6733: LESS
6734: IFFALSE 6744
// ru_sib_bomb := true ;
6736: LD_ADDR_EXP 4
6740: PUSH
6741: LD_INT 1
6743: ST_TO_ADDR
// end ;
6744: PPOPN 2
6746: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6747: LD_INT 22
6749: PUSH
6750: LD_OWVAR 2
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 34
6761: PUSH
6762: LD_INT 8
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: IFFALSE 6790
6779: GO 6781
6781: DISABLE
// begin ru_sib_bomb := true ;
6782: LD_ADDR_EXP 4
6786: PUSH
6787: LD_INT 1
6789: ST_TO_ADDR
// end ;
6790: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6791: LD_INT 22
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: EMPTY
6798: LIST
6799: LIST
6800: PUSH
6801: LD_INT 30
6803: PUSH
6804: LD_INT 34
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 69
6819: IFFALSE 6918
6821: GO 6823
6823: DISABLE
6824: LD_INT 0
6826: PPUSH
// begin enable ;
6827: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 1
6835: PUSH
6836: LD_INT 3
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 1
6845: PPUSH
6846: LD_INT 2
6848: PPUSH
6849: CALL_OW 12
6853: ARRAY
6854: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6855: LD_INT 22
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 30
6867: PUSH
6868: LD_INT 34
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PUSH
6884: LD_INT 1
6886: ARRAY
6887: PPUSH
6888: LD_EXP 30
6892: PUSH
6893: LD_VAR 0 1
6897: ARRAY
6898: PPUSH
6899: LD_EXP 30
6903: PUSH
6904: LD_VAR 0 1
6908: PUSH
6909: LD_INT 1
6911: PLUS
6912: ARRAY
6913: PPUSH
6914: CALL_OW 243
// end ; end_of_file
6918: PPOPN 1
6920: END
// export function RemoveLegion ; var i ; begin
6921: LD_INT 0
6923: PPUSH
6924: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: LD_INT 22
6932: PUSH
6933: LD_INT 8
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PPUSH
6940: CALL_OW 69
6944: PUSH
6945: FOR_IN
6946: IFFALSE 6959
// RemoveUnit ( i ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: CALL_OW 64
6957: GO 6945
6959: POP
6960: POP
// end ;
6961: LD_VAR 0 1
6965: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
6966: LD_INT 0
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
6978: LD_ADDR_VAR 0 7
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 8
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 30
6995: PUSH
6996: LD_INT 1
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: LD_INT 1
7014: ARRAY
7015: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7016: LD_ADDR_VAR 0 8
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_INT 8
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 30
7033: PUSH
7034: LD_INT 3
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: LD_INT 1
7052: ARRAY
7053: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7054: LD_ADDR_VAR 0 9
7058: PUSH
7059: LD_INT 22
7061: PUSH
7062: LD_INT 8
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PUSH
7069: LD_INT 2
7071: PUSH
7072: LD_INT 30
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 30
7084: PUSH
7085: LD_INT 8
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PPUSH
7101: CALL_OW 69
7105: PUSH
7106: LD_INT 1
7108: ARRAY
7109: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7110: LD_ADDR_VAR 0 10
7114: PUSH
7115: LD_INT 22
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 30
7127: PUSH
7128: LD_INT 32
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: ST_TO_ADDR
// uc_side := 8 ;
7144: LD_ADDR_OWVAR 20
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// uc_nation := nation_arabian ;
7152: LD_ADDR_OWVAR 21
7156: PUSH
7157: LD_INT 2
7159: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7160: LD_ADDR_EXP 32
7164: PUSH
7165: LD_INT 5
7167: PUSH
7168: LD_INT 6
7170: PUSH
7171: LD_INT 7
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: LIST
7178: PUSH
7179: LD_OWVAR 67
7183: ARRAY
7184: ST_TO_ADDR
// legion_blist := [ ] ;
7185: LD_ADDR_EXP 34
7189: PUSH
7190: EMPTY
7191: ST_TO_ADDR
// legion_vlist := [ ] ;
7192: LD_ADDR_EXP 35
7196: PUSH
7197: EMPTY
7198: ST_TO_ADDR
// legion_force := [ ] ;
7199: LD_ADDR_EXP 31
7203: PUSH
7204: EMPTY
7205: ST_TO_ADDR
// legion_enemy := - 1 ;
7206: LD_ADDR_EXP 36
7210: PUSH
7211: LD_INT 1
7213: NEG
7214: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7215: LD_VAR 0 7
7219: PPUSH
7220: CALL_OW 274
7224: PPUSH
7225: LD_INT 1
7227: PPUSH
7228: LD_INT 10000
7230: PPUSH
7231: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7235: LD_VAR 0 7
7239: PPUSH
7240: CALL_OW 274
7244: PPUSH
7245: LD_INT 3
7247: PPUSH
7248: LD_INT 1000
7250: PPUSH
7251: CALL_OW 277
// for i = 1 to l_towers do
7255: LD_ADDR_VAR 0 3
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_VAR 0 10
7269: PUSH
7270: FOR_TO
7271: IFFALSE 7320
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7273: LD_INT 0
7275: PPUSH
7276: LD_INT 1
7278: PPUSH
7279: LD_EXP 32
7283: PPUSH
7284: CALL_OW 380
// un := CreateHuman ;
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: CALL_OW 44
7297: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7298: LD_VAR 0 2
7302: PPUSH
7303: LD_VAR 0 10
7307: PUSH
7308: LD_VAR 0 3
7312: ARRAY
7313: PPUSH
7314: CALL_OW 52
// end ;
7318: GO 7270
7320: POP
7321: POP
// for i = 1 to 4 do
7322: LD_ADDR_VAR 0 3
7326: PUSH
7327: DOUBLE
7328: LD_INT 1
7330: DEC
7331: ST_TO_ADDR
7332: LD_INT 4
7334: PUSH
7335: FOR_TO
7336: IFFALSE 7429
// for p = 1 to 2 do
7338: LD_ADDR_VAR 0 6
7342: PUSH
7343: DOUBLE
7344: LD_INT 1
7346: DEC
7347: ST_TO_ADDR
7348: LD_INT 2
7350: PUSH
7351: FOR_TO
7352: IFFALSE 7425
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7354: LD_INT 0
7356: PPUSH
7357: LD_INT 8
7359: PPUSH
7360: LD_EXP 32
7364: PPUSH
7365: CALL_OW 380
// un := CreateHuman ;
7369: LD_ADDR_VAR 0 2
7373: PUSH
7374: CALL_OW 44
7378: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7379: LD_VAR 0 2
7383: PPUSH
7384: LD_INT 22
7386: PUSH
7387: LD_INT 8
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 30
7396: PUSH
7397: LD_INT 5
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: PUSH
7413: LD_VAR 0 6
7417: ARRAY
7418: PPUSH
7419: CALL_OW 52
// end ;
7423: GO 7351
7425: POP
7426: POP
7427: GO 7335
7429: POP
7430: POP
// for i = 1 to 4 do
7431: LD_ADDR_VAR 0 3
7435: PUSH
7436: DOUBLE
7437: LD_INT 1
7439: DEC
7440: ST_TO_ADDR
7441: LD_INT 4
7443: PUSH
7444: FOR_TO
7445: IFFALSE 7488
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7447: LD_INT 0
7449: PPUSH
7450: LD_INT 4
7452: PPUSH
7453: LD_EXP 32
7457: PPUSH
7458: CALL_OW 380
// un := CreateHuman ;
7462: LD_ADDR_VAR 0 2
7466: PUSH
7467: CALL_OW 44
7471: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7472: LD_VAR 0 2
7476: PPUSH
7477: LD_VAR 0 9
7481: PPUSH
7482: CALL_OW 52
// end ;
7486: GO 7444
7488: POP
7489: POP
// for i = 1 to 6 do
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: DOUBLE
7496: LD_INT 1
7498: DEC
7499: ST_TO_ADDR
7500: LD_INT 6
7502: PUSH
7503: FOR_TO
7504: IFFALSE 7547
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7506: LD_INT 0
7508: PPUSH
7509: LD_INT 3
7511: PPUSH
7512: LD_EXP 32
7516: PPUSH
7517: CALL_OW 380
// un := CreateHuman ;
7521: LD_ADDR_VAR 0 2
7525: PUSH
7526: CALL_OW 44
7530: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7531: LD_VAR 0 2
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 52
// end ;
7545: GO 7503
7547: POP
7548: POP
// for i = 1 to 5 do
7549: LD_ADDR_VAR 0 3
7553: PUSH
7554: DOUBLE
7555: LD_INT 1
7557: DEC
7558: ST_TO_ADDR
7559: LD_INT 5
7561: PUSH
7562: FOR_TO
7563: IFFALSE 7606
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7565: LD_INT 0
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: LD_EXP 32
7575: PPUSH
7576: CALL_OW 380
// un := CreateHuman ;
7580: LD_ADDR_VAR 0 2
7584: PUSH
7585: CALL_OW 44
7589: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7590: LD_VAR 0 2
7594: PPUSH
7595: LD_VAR 0 7
7599: PPUSH
7600: CALL_OW 52
// end ;
7604: GO 7562
7606: POP
7607: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7608: LD_ADDR_VAR 0 4
7612: PUSH
7613: LD_INT 199
7615: PPUSH
7616: LD_INT 134
7618: PPUSH
7619: LD_INT 216
7621: PPUSH
7622: LD_INT 141
7624: PPUSH
7625: LD_INT 6
7627: PPUSH
7628: CALL 1555 0 5
7632: ST_TO_ADDR
// p := 1 ;
7633: LD_ADDR_VAR 0 6
7637: PUSH
7638: LD_INT 1
7640: ST_TO_ADDR
// for i = 1 to 3 do
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: DOUBLE
7647: LD_INT 1
7649: DEC
7650: ST_TO_ADDR
7651: LD_INT 3
7653: PUSH
7654: FOR_TO
7655: IFFALSE 7908
// begin vc_chassis := ar_half_tracked ;
7657: LD_ADDR_OWVAR 37
7661: PUSH
7662: LD_INT 14
7664: ST_TO_ADDR
// vc_engine := engine_siberite ;
7665: LD_ADDR_OWVAR 39
7669: PUSH
7670: LD_INT 3
7672: ST_TO_ADDR
// vc_control := control_manual ;
7673: LD_ADDR_OWVAR 38
7677: PUSH
7678: LD_INT 1
7680: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7681: LD_ADDR_OWVAR 40
7685: PUSH
7686: LD_INT 31
7688: ST_TO_ADDR
// veh := CreateVehicle ;
7689: LD_ADDR_VAR 0 5
7693: PUSH
7694: CALL_OW 45
7698: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7699: LD_VAR 0 4
7703: PUSH
7704: LD_VAR 0 6
7708: ARRAY
7709: PPUSH
7710: LD_VAR 0 4
7714: PUSH
7715: LD_VAR 0 6
7719: PUSH
7720: LD_INT 1
7722: PLUS
7723: ARRAY
7724: PPUSH
7725: CALL_OW 428
7729: PUSH
7730: LD_INT 0
7732: EQUAL
7733: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7735: LD_VAR 0 5
7739: PPUSH
7740: LD_VAR 0 4
7744: PUSH
7745: LD_VAR 0 6
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 6
7760: PUSH
7761: LD_INT 1
7763: PLUS
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 48
7773: GO 7863
// begin repeat p := p + 2 ;
7775: LD_ADDR_VAR 0 6
7779: PUSH
7780: LD_VAR 0 6
7784: PUSH
7785: LD_INT 2
7787: PLUS
7788: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7789: LD_VAR 0 4
7793: PUSH
7794: LD_VAR 0 6
7798: ARRAY
7799: PPUSH
7800: LD_VAR 0 4
7804: PUSH
7805: LD_VAR 0 6
7809: PUSH
7810: LD_INT 1
7812: PLUS
7813: ARRAY
7814: PPUSH
7815: CALL_OW 428
7819: PUSH
7820: LD_INT 0
7822: EQUAL
7823: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7825: LD_VAR 0 5
7829: PPUSH
7830: LD_VAR 0 4
7834: PUSH
7835: LD_VAR 0 6
7839: ARRAY
7840: PPUSH
7841: LD_VAR 0 4
7845: PUSH
7846: LD_VAR 0 6
7850: PUSH
7851: LD_INT 1
7853: PLUS
7854: ARRAY
7855: PPUSH
7856: LD_INT 0
7858: PPUSH
7859: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7863: LD_INT 0
7865: PPUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_EXP 32
7873: PUSH
7874: LD_INT 1
7876: PLUS
7877: PPUSH
7878: CALL_OW 380
// un := CreateHuman ;
7882: LD_ADDR_VAR 0 2
7886: PUSH
7887: CALL_OW 44
7891: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7892: LD_VAR 0 2
7896: PPUSH
7897: LD_VAR 0 5
7901: PPUSH
7902: CALL_OW 52
// end ;
7906: GO 7654
7908: POP
7909: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7910: LD_INT 198
7912: PPUSH
7913: LD_INT 94
7915: PPUSH
7916: LD_INT 8
7918: PPUSH
7919: LD_INT 10
7921: PPUSH
7922: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7926: LD_INT 167
7928: PPUSH
7929: LD_INT 130
7931: PPUSH
7932: LD_INT 8
7934: PPUSH
7935: LD_INT 10
7937: PPUSH
7938: CALL_OW 330
// legion_mines := [ ] ;
7942: LD_ADDR_EXP 33
7946: PUSH
7947: EMPTY
7948: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
7949: LD_ADDR_EXP 33
7953: PUSH
7954: LD_INT 176
7956: PPUSH
7957: LD_INT 122
7959: PPUSH
7960: LD_INT 188
7962: PPUSH
7963: LD_INT 126
7965: PPUSH
7966: LD_INT 6
7968: PPUSH
7969: CALL 1555 0 5
7973: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
7974: LD_ADDR_EXP 33
7978: PUSH
7979: LD_EXP 33
7983: PUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 91
7989: PPUSH
7990: LD_INT 205
7992: PPUSH
7993: LD_INT 96
7995: PPUSH
7996: LD_INT 4
7998: PPUSH
7999: CALL 1555 0 5
8003: ADD
8004: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8005: LD_ADDR_EXP 33
8009: PUSH
8010: LD_EXP 33
8014: PUSH
8015: LD_INT 184
8017: PPUSH
8018: LD_INT 151
8020: PPUSH
8021: LD_INT 178
8023: PPUSH
8024: LD_INT 130
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL 1555 0 5
8034: ADD
8035: ST_TO_ADDR
// if Difficulty > 1 then
8036: LD_OWVAR 67
8040: PUSH
8041: LD_INT 1
8043: GREATER
8044: IFFALSE 8077
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_EXP 33
8055: PUSH
8056: LD_INT 166
8058: PPUSH
8059: LD_INT 126
8061: PPUSH
8062: LD_INT 181
8064: PPUSH
8065: LD_INT 136
8067: PPUSH
8068: LD_INT 5
8070: PPUSH
8071: CALL 1555 0 5
8075: ADD
8076: ST_TO_ADDR
// p := 1 ;
8077: LD_ADDR_VAR 0 6
8081: PUSH
8082: LD_INT 1
8084: ST_TO_ADDR
// for i = 1 to 24 do
8085: LD_ADDR_VAR 0 3
8089: PUSH
8090: DOUBLE
8091: LD_INT 1
8093: DEC
8094: ST_TO_ADDR
8095: LD_INT 24
8097: PUSH
8098: FOR_TO
8099: IFFALSE 8153
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8101: LD_EXP 33
8105: PUSH
8106: LD_VAR 0 6
8110: ARRAY
8111: PPUSH
8112: LD_EXP 33
8116: PUSH
8117: LD_VAR 0 6
8121: PUSH
8122: LD_INT 1
8124: PLUS
8125: ARRAY
8126: PPUSH
8127: LD_INT 8
8129: PPUSH
8130: LD_INT 0
8132: PPUSH
8133: CALL_OW 454
// p := p + 2 ;
8137: LD_ADDR_VAR 0 6
8141: PUSH
8142: LD_VAR 0 6
8146: PUSH
8147: LD_INT 2
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: GO 8098
8153: POP
8154: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8155: LD_ADDR_EXP 35
8159: PUSH
8160: LD_INT 13
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: LD_INT 2
8168: PUSH
8169: LD_INT 32
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: ST_TO_ADDR
// end ;
8178: LD_VAR 0 1
8182: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8183: LD_INT 22
8185: PUSH
8186: LD_INT 8
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PPUSH
8193: CALL_OW 69
8197: PUSH
8198: LD_INT 0
8200: GREATER
8201: IFFALSE 10387
8203: GO 8205
8205: DISABLE
8206: LD_INT 0
8208: PPUSH
8209: PPUSH
8210: PPUSH
8211: PPUSH
8212: PPUSH
8213: PPUSH
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
8218: PPUSH
8219: PPUSH
8220: PPUSH
8221: PPUSH
8222: PPUSH
8223: PPUSH
8224: PPUSH
// begin enable ;
8225: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8226: LD_ADDR_VAR 0 8
8230: PUSH
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 30
8243: PUSH
8244: LD_INT 1
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PPUSH
8255: CALL_OW 69
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8264: LD_ADDR_VAR 0 9
8268: PUSH
8269: LD_INT 22
8271: PUSH
8272: LD_INT 8
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 30
8281: PUSH
8282: LD_INT 3
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: PPUSH
8293: CALL_OW 69
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8302: LD_ADDR_VAR 0 10
8306: PUSH
8307: LD_INT 22
8309: PUSH
8310: LD_INT 8
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 2
8319: PUSH
8320: LD_INT 30
8322: PUSH
8323: LD_INT 6
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: LD_INT 30
8332: PUSH
8333: LD_INT 8
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PPUSH
8349: CALL_OW 69
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8358: LD_ADDR_VAR 0 11
8362: PUSH
8363: LD_INT 22
8365: PUSH
8366: LD_INT 8
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: PUSH
8373: LD_INT 30
8375: PUSH
8376: LD_INT 32
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: PUSH
8383: EMPTY
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8392: LD_ADDR_VAR 0 16
8396: PUSH
8397: LD_INT 22
8399: PUSH
8400: LD_INT 8
8402: PUSH
8403: EMPTY
8404: LIST
8405: LIST
8406: PUSH
8407: LD_INT 25
8409: PUSH
8410: LD_INT 2
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PPUSH
8421: CALL_OW 69
8425: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8426: LD_ADDR_VAR 0 15
8430: PUSH
8431: LD_INT 22
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: PUSH
8441: LD_INT 25
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PPUSH
8455: CALL_OW 69
8459: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8460: LD_ADDR_VAR 0 14
8464: PUSH
8465: LD_INT 22
8467: PUSH
8468: LD_INT 8
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: LD_INT 25
8477: PUSH
8478: LD_INT 3
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8494: LD_ADDR_VAR 0 13
8498: PUSH
8499: LD_INT 22
8501: PUSH
8502: LD_INT 8
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 25
8511: PUSH
8512: LD_INT 4
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: ST_TO_ADDR
// if l_eng then
8528: LD_VAR 0 16
8532: IFFALSE 8947
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8534: LD_ADDR_VAR 0 5
8538: PUSH
8539: LD_INT 22
8541: PUSH
8542: LD_INT 8
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 21
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PPUSH
8563: CALL_OW 69
8567: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8568: LD_VAR 0 5
8572: PPUSH
8573: LD_INT 3
8575: PUSH
8576: LD_INT 24
8578: PUSH
8579: LD_INT 1000
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PPUSH
8590: CALL_OW 72
8594: PUSH
8595: LD_INT 0
8597: GREATER
8598: IFFALSE 8732
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8600: LD_ADDR_VAR 0 3
8604: PUSH
8605: LD_VAR 0 5
8609: PPUSH
8610: LD_INT 3
8612: PUSH
8613: LD_INT 24
8615: PUSH
8616: LD_INT 1000
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PPUSH
8627: CALL_OW 72
8631: ST_TO_ADDR
// for i = 1 to l_eng do
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: DOUBLE
8638: LD_INT 1
8640: DEC
8641: ST_TO_ADDR
8642: LD_VAR 0 16
8646: PUSH
8647: FOR_TO
8648: IFFALSE 8728
// if IsInUnit ( l_eng [ i ] ) then
8650: LD_VAR 0 16
8654: PUSH
8655: LD_VAR 0 2
8659: ARRAY
8660: PPUSH
8661: CALL_OW 310
8665: IFFALSE 8684
// ComExitBuilding ( l_eng [ i ] ) else
8667: LD_VAR 0 16
8671: PUSH
8672: LD_VAR 0 2
8676: ARRAY
8677: PPUSH
8678: CALL_OW 122
8682: GO 8726
// if not HasTask ( l_eng [ i ] ) then
8684: LD_VAR 0 16
8688: PUSH
8689: LD_VAR 0 2
8693: ARRAY
8694: PPUSH
8695: CALL_OW 314
8699: NOT
8700: IFFALSE 8726
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8702: LD_VAR 0 16
8706: PUSH
8707: LD_VAR 0 2
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 3
8717: PUSH
8718: LD_INT 1
8720: ARRAY
8721: PPUSH
8722: CALL_OW 130
8726: GO 8647
8728: POP
8729: POP
// end else
8730: GO 8947
// begin if legion_blist > 0 then
8732: LD_EXP 34
8736: PUSH
8737: LD_INT 0
8739: GREATER
8740: IFFALSE 8869
// begin for i = 1 to l_eng do
8742: LD_ADDR_VAR 0 2
8746: PUSH
8747: DOUBLE
8748: LD_INT 1
8750: DEC
8751: ST_TO_ADDR
8752: LD_VAR 0 16
8756: PUSH
8757: FOR_TO
8758: IFFALSE 8865
// if IsInUnit ( l_eng [ i ] ) then
8760: LD_VAR 0 16
8764: PUSH
8765: LD_VAR 0 2
8769: ARRAY
8770: PPUSH
8771: CALL_OW 310
8775: IFFALSE 8794
// ComExitBuilding ( l_eng [ i ] ) else
8777: LD_VAR 0 16
8781: PUSH
8782: LD_VAR 0 2
8786: ARRAY
8787: PPUSH
8788: CALL_OW 122
8792: GO 8863
// if not HasTask ( l_eng [ i ] ) then
8794: LD_VAR 0 16
8798: PUSH
8799: LD_VAR 0 2
8803: ARRAY
8804: PPUSH
8805: CALL_OW 314
8809: NOT
8810: IFFALSE 8863
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8812: LD_VAR 0 16
8816: PUSH
8817: LD_VAR 0 2
8821: ARRAY
8822: PPUSH
8823: LD_EXP 34
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PPUSH
8832: LD_EXP 34
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PPUSH
8841: LD_EXP 34
8845: PUSH
8846: LD_INT 3
8848: ARRAY
8849: PPUSH
8850: LD_EXP 34
8854: PUSH
8855: LD_INT 4
8857: ARRAY
8858: PPUSH
8859: CALL_OW 145
8863: GO 8757
8865: POP
8866: POP
// end else
8867: GO 8947
// for i = 1 to l_eng do
8869: LD_ADDR_VAR 0 2
8873: PUSH
8874: DOUBLE
8875: LD_INT 1
8877: DEC
8878: ST_TO_ADDR
8879: LD_VAR 0 16
8883: PUSH
8884: FOR_TO
8885: IFFALSE 8945
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8887: LD_VAR 0 16
8891: PUSH
8892: LD_VAR 0 2
8896: ARRAY
8897: PPUSH
8898: CALL_OW 310
8902: NOT
8903: PUSH
8904: LD_VAR 0 16
8908: PUSH
8909: LD_VAR 0 2
8913: ARRAY
8914: PPUSH
8915: CALL_OW 314
8919: NOT
8920: AND
8921: IFFALSE 8943
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8923: LD_VAR 0 16
8927: PUSH
8928: LD_VAR 0 2
8932: ARRAY
8933: PPUSH
8934: LD_VAR 0 8
8938: PPUSH
8939: CALL_OW 120
8943: GO 8884
8945: POP
8946: POP
// end ; end ; if l_factory then
8947: LD_VAR 0 9
8951: IFFALSE 9351
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
8953: LD_INT 22
8955: PUSH
8956: LD_INT 8
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: LD_INT 33
8965: PUSH
8966: LD_INT 2
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 3
8975: PUSH
8976: LD_INT 61
8978: PUSH
8979: EMPTY
8980: LIST
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: LIST
8990: PPUSH
8991: CALL_OW 69
8995: PUSH
8996: LD_INT 0
8998: GREATER
8999: PUSH
9000: LD_INT 22
9002: PUSH
9003: LD_INT 8
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: LD_INT 34
9012: PUSH
9013: LD_INT 31
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 69
9028: PUSH
9029: LD_INT 0
9031: GREATER
9032: AND
9033: IFFALSE 9153
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9035: LD_INT 22
9037: PUSH
9038: LD_INT 8
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: LD_INT 33
9047: PUSH
9048: LD_INT 2
9050: PUSH
9051: EMPTY
9052: LIST
9053: LIST
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: LD_INT 61
9060: PUSH
9061: EMPTY
9062: LIST
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: PPUSH
9073: CALL_OW 69
9077: PUSH
9078: LD_INT 1
9080: ARRAY
9081: PPUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 8
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 34
9094: PUSH
9095: LD_INT 31
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL_OW 69
9110: PUSH
9111: LD_INT 1
9113: PPUSH
9114: LD_INT 22
9116: PUSH
9117: LD_INT 8
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 34
9126: PUSH
9127: LD_INT 31
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PPUSH
9143: CALL_OW 12
9147: ARRAY
9148: PPUSH
9149: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9153: LD_EXP 35
9157: PUSH
9158: LD_INT 0
9160: GREATER
9161: PUSH
9162: LD_VAR 0 9
9166: PPUSH
9167: CALL_OW 461
9171: PUSH
9172: LD_INT 2
9174: EQUAL
9175: AND
9176: IFFALSE 9261
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9178: LD_VAR 0 9
9182: PPUSH
9183: LD_EXP 35
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_EXP 35
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: LD_EXP 35
9205: PUSH
9206: LD_INT 3
9208: ARRAY
9209: PPUSH
9210: LD_EXP 35
9214: PUSH
9215: LD_INT 4
9217: ARRAY
9218: PPUSH
9219: CALL_OW 125
// for i = 1 to 4 do
9223: LD_ADDR_VAR 0 2
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 4
9235: PUSH
9236: FOR_TO
9237: IFFALSE 9259
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9239: LD_ADDR_EXP 35
9243: PUSH
9244: LD_EXP 35
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: CALL_OW 3
9256: ST_TO_ADDR
9257: GO 9236
9259: POP
9260: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9261: LD_VAR 0 11
9265: PPUSH
9266: LD_INT 35
9268: PUSH
9269: LD_INT 0
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PPUSH
9276: CALL_OW 72
9280: PUSH
9281: LD_INT 0
9283: GREATER
9284: PUSH
9285: LD_VAR 0 9
9289: PPUSH
9290: CALL_OW 461
9294: PUSH
9295: LD_INT 2
9297: EQUAL
9298: AND
9299: IFFALSE 9351
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9301: LD_VAR 0 11
9305: PPUSH
9306: LD_INT 35
9308: PUSH
9309: LD_INT 0
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PPUSH
9316: CALL_OW 72
9320: PUSH
9321: LD_INT 1
9323: ARRAY
9324: PPUSH
9325: LD_INT 28
9327: PUSH
9328: LD_INT 27
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: CALL_OW 148
// end ; if legion_enemy > 0 then
9351: LD_EXP 36
9355: PUSH
9356: LD_INT 0
9358: GREATER
9359: IFFALSE 9939
// begin if tick mod 11 11$00 = 0 then
9361: LD_OWVAR 1
9365: PUSH
9366: LD_INT 23100
9368: MOD
9369: PUSH
9370: LD_INT 0
9372: EQUAL
9373: IFFALSE 9623
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9375: LD_ADDR_EXP 35
9379: PUSH
9380: LD_EXP 35
9384: PUSH
9385: LD_INT 13
9387: PUSH
9388: LD_INT 1
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: ADD
9399: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9400: LD_ADDR_EXP 35
9404: PUSH
9405: LD_EXP 35
9409: PUSH
9410: LD_INT 28
9412: PUSH
9413: LD_INT 27
9415: PUSH
9416: LD_INT 29
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: LIST
9423: PUSH
9424: LD_INT 1
9426: PPUSH
9427: LD_INT 3
9429: PPUSH
9430: CALL_OW 12
9434: ARRAY
9435: ADD
9436: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9437: LD_ADDR_EXP 35
9441: PUSH
9442: LD_EXP 35
9446: PUSH
9447: LD_INT 13
9449: PUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 2
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: LIST
9460: ADD
9461: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9462: LD_ADDR_EXP 35
9466: PUSH
9467: LD_EXP 35
9471: PUSH
9472: LD_INT 28
9474: PUSH
9475: LD_INT 27
9477: PUSH
9478: LD_INT 29
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 3
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: ADD
9498: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9499: LD_ADDR_EXP 35
9503: PUSH
9504: LD_EXP 35
9508: PUSH
9509: LD_INT 13
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: LD_INT 2
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: ADD
9523: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9524: LD_ADDR_EXP 35
9528: PUSH
9529: LD_EXP 35
9533: PUSH
9534: LD_INT 28
9536: PUSH
9537: LD_INT 27
9539: PUSH
9540: LD_INT 29
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 1
9550: PPUSH
9551: LD_INT 3
9553: PPUSH
9554: CALL_OW 12
9558: ARRAY
9559: ADD
9560: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9561: LD_ADDR_EXP 35
9565: PUSH
9566: LD_EXP 35
9570: PUSH
9571: LD_INT 13
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: ADD
9585: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9586: LD_ADDR_EXP 35
9590: PUSH
9591: LD_EXP 35
9595: PUSH
9596: LD_INT 28
9598: PUSH
9599: LD_INT 27
9601: PUSH
9602: LD_INT 29
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 3
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: ADD
9622: ST_TO_ADDR
// end ; if legion_force >= 7 then
9623: LD_EXP 31
9627: PUSH
9628: LD_INT 7
9630: GREATEREQUAL
9631: IFFALSE 9814
// begin for i = 1 to legion_force do
9633: LD_ADDR_VAR 0 2
9637: PUSH
9638: DOUBLE
9639: LD_INT 1
9641: DEC
9642: ST_TO_ADDR
9643: LD_EXP 31
9647: PUSH
9648: FOR_TO
9649: IFFALSE 9812
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9651: LD_EXP 31
9655: PUSH
9656: LD_VAR 0 2
9660: ARRAY
9661: PPUSH
9662: CALL_OW 314
9666: NOT
9667: PUSH
9668: LD_EXP 31
9672: PUSH
9673: LD_VAR 0 2
9677: ARRAY
9678: PPUSH
9679: CALL_OW 110
9683: PUSH
9684: LD_INT 11
9686: NONEQUAL
9687: AND
9688: IFFALSE 9810
// begin case legion_enemy of 1 :
9690: LD_EXP 36
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9727
9703: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9704: LD_EXP 31
9708: PUSH
9709: LD_VAR 0 2
9713: ARRAY
9714: PPUSH
9715: LD_INT 142
9717: PPUSH
9718: LD_INT 144
9720: PPUSH
9721: CALL_OW 111
9725: GO 9792
9727: LD_INT 2
9729: DOUBLE
9730: EQUAL
9731: IFTRUE 9735
9733: GO 9759
9735: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9736: LD_EXP 31
9740: PUSH
9741: LD_VAR 0 2
9745: ARRAY
9746: PPUSH
9747: LD_INT 101
9749: PPUSH
9750: LD_INT 34
9752: PPUSH
9753: CALL_OW 111
9757: GO 9792
9759: LD_INT 7
9761: DOUBLE
9762: EQUAL
9763: IFTRUE 9767
9765: GO 9791
9767: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9768: LD_EXP 31
9772: PUSH
9773: LD_VAR 0 2
9777: ARRAY
9778: PPUSH
9779: LD_INT 173
9781: PPUSH
9782: LD_INT 127
9784: PPUSH
9785: CALL_OW 111
9789: GO 9792
9791: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 11
9805: PPUSH
9806: CALL_OW 109
// end ; end ;
9810: GO 9648
9812: POP
9813: POP
// end ; if legion_force then
9814: LD_EXP 31
9818: IFFALSE 9939
// begin tmp := legion_force ;
9820: LD_ADDR_VAR 0 3
9824: PUSH
9825: LD_EXP 31
9829: ST_TO_ADDR
// for i = 1 to tmp do
9830: LD_ADDR_VAR 0 2
9834: PUSH
9835: DOUBLE
9836: LD_INT 1
9838: DEC
9839: ST_TO_ADDR
9840: LD_VAR 0 3
9844: PUSH
9845: FOR_TO
9846: IFFALSE 9937
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9848: LD_VAR 0 3
9852: PUSH
9853: LD_VAR 0 2
9857: ARRAY
9858: PPUSH
9859: CALL_OW 314
9863: NOT
9864: PUSH
9865: LD_EXP 31
9869: PUSH
9870: LD_VAR 0 2
9874: ARRAY
9875: PPUSH
9876: CALL_OW 110
9880: PUSH
9881: LD_INT 11
9883: EQUAL
9884: AND
9885: IFFALSE 9935
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9887: LD_VAR 0 3
9891: PUSH
9892: LD_VAR 0 2
9896: ARRAY
9897: PPUSH
9898: LD_INT 22
9900: PUSH
9901: LD_EXP 36
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: PPUSH
9910: CALL_OW 69
9914: PPUSH
9915: LD_VAR 0 3
9919: PUSH
9920: LD_VAR 0 2
9924: ARRAY
9925: PPUSH
9926: CALL_OW 74
9930: PPUSH
9931: CALL_OW 115
9935: GO 9845
9937: POP
9938: POP
// end ; end ; p := 1 ;
9939: LD_ADDR_VAR 0 6
9943: PUSH
9944: LD_INT 1
9946: ST_TO_ADDR
// for i = 1 to 24 do
9947: LD_ADDR_VAR 0 2
9951: PUSH
9952: DOUBLE
9953: LD_INT 1
9955: DEC
9956: ST_TO_ADDR
9957: LD_INT 24
9959: PUSH
9960: FOR_TO
9961: IFFALSE 10091
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
9963: LD_EXP 33
9967: PUSH
9968: LD_VAR 0 6
9972: ARRAY
9973: PPUSH
9974: LD_EXP 33
9978: PUSH
9979: LD_VAR 0 6
9983: PUSH
9984: LD_INT 1
9986: PLUS
9987: ARRAY
9988: PPUSH
9989: CALL_OW 428
9993: PUSH
9994: LD_INT 0
9996: GREATER
9997: IFFALSE 10075
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
9999: LD_EXP 33
10003: PUSH
10004: LD_VAR 0 6
10008: ARRAY
10009: PPUSH
10010: LD_EXP 33
10014: PUSH
10015: LD_VAR 0 6
10019: PUSH
10020: LD_INT 1
10022: PLUS
10023: ARRAY
10024: PPUSH
10025: CALL_OW 428
10029: PPUSH
10030: CALL_OW 255
10034: PUSH
10035: LD_EXP 36
10039: EQUAL
10040: IFFALSE 10075
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10042: LD_EXP 33
10046: PUSH
10047: LD_VAR 0 6
10051: ARRAY
10052: PPUSH
10053: LD_EXP 33
10057: PUSH
10058: LD_VAR 0 6
10062: PUSH
10063: LD_INT 1
10065: PLUS
10066: ARRAY
10067: PPUSH
10068: LD_INT 8
10070: PPUSH
10071: CALL_OW 456
// p := p + 2 ;
10075: LD_ADDR_VAR 0 6
10079: PUSH
10080: LD_VAR 0 6
10084: PUSH
10085: LD_INT 2
10087: PLUS
10088: ST_TO_ADDR
// end ;
10089: GO 9960
10091: POP
10092: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10093: LD_INT 22
10095: PUSH
10096: LD_INT 8
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 34
10105: PUSH
10106: LD_INT 32
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: PPUSH
10117: CALL_OW 69
10121: IFFALSE 10235
// begin if l_cargo = false then
10123: LD_VAR 0 17
10127: PUSH
10128: LD_INT 0
10130: EQUAL
10131: IFFALSE 10167
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10133: LD_ADDR_VAR 0 17
10137: PUSH
10138: LD_INT 22
10140: PUSH
10141: LD_INT 8
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PUSH
10148: LD_INT 34
10150: PUSH
10151: LD_INT 32
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: ST_TO_ADDR
// if l_cargo then
10167: LD_VAR 0 17
10171: IFFALSE 10235
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10173: LD_ADDR_VAR 0 7
10177: PUSH
10178: LD_INT 14
10180: PPUSH
10181: CALL_OW 435
10185: ST_TO_ADDR
// if cr > 0 then
10186: LD_VAR 0 7
10190: PUSH
10191: LD_INT 0
10193: GREATER
10194: IFFALSE 10235
// if not HasTask ( l_cargo ) then
10196: LD_VAR 0 17
10200: PPUSH
10201: CALL_OW 314
10205: NOT
10206: IFFALSE 10235
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10208: LD_VAR 0 17
10212: PPUSH
10213: LD_VAR 0 7
10217: PUSH
10218: LD_INT 1
10220: ARRAY
10221: PPUSH
10222: LD_VAR 0 7
10226: PUSH
10227: LD_INT 2
10229: ARRAY
10230: PPUSH
10231: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10235: LD_OWVAR 1
10239: PUSH
10240: LD_INT 52500
10242: PUSH
10243: LD_INT 46200
10245: PUSH
10246: LD_INT 42000
10248: PUSH
10249: EMPTY
10250: LIST
10251: LIST
10252: LIST
10253: PUSH
10254: LD_OWVAR 67
10258: ARRAY
10259: EQUAL
10260: PUSH
10261: LD_INT 1
10263: PPUSH
10264: CALL_OW 469
10268: PUSH
10269: LD_INT 1
10271: ARRAY
10272: PUSH
10273: LD_INT 112
10275: EQUAL
10276: AND
10277: PUSH
10278: LD_INT 1
10280: PPUSH
10281: CALL_OW 469
10285: PUSH
10286: LD_INT 2
10288: ARRAY
10289: PUSH
10290: LD_INT 67
10292: EQUAL
10293: AND
10294: IFFALSE 10387
// begin un := l_eng [ 1 ] ;
10296: LD_ADDR_VAR 0 1
10300: PUSH
10301: LD_VAR 0 16
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: ST_TO_ADDR
// if IsInUnit ( un ) then
10310: LD_VAR 0 1
10314: PPUSH
10315: CALL_OW 310
10319: IFFALSE 10330
// ComExitBuilding ( un ) ;
10321: LD_VAR 0 1
10325: PPUSH
10326: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10330: LD_VAR 0 1
10334: PPUSH
10335: LD_INT 1
10337: PPUSH
10338: CALL_OW 469
10342: PUSH
10343: LD_INT 1
10345: ARRAY
10346: PPUSH
10347: LD_INT 1
10349: PPUSH
10350: CALL_OW 469
10354: PUSH
10355: LD_INT 2
10357: ARRAY
10358: PPUSH
10359: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10363: LD_VAR 0 1
10367: PPUSH
10368: LD_INT 207
10370: PPUSH
10371: LD_INT 123
10373: PPUSH
10374: CALL_OW 171
// AddComUnload ( un ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 219
// end ; end ;
10387: PPOPN 17
10389: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10390: LD_OWVAR 67
10394: PUSH
10395: LD_INT 1
10397: GREATER
10398: IFFALSE 10603
10400: GO 10402
10402: DISABLE
10403: LD_INT 0
10405: PPUSH
10406: PPUSH
10407: PPUSH
10408: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10409: LD_INT 35
10411: PPUSH
10412: LD_INT 12635
10414: PPUSH
10415: CALL_OW 12
10419: PPUSH
10420: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_INT 22
10431: PUSH
10432: LD_INT 8
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 25
10441: PUSH
10442: LD_INT 4
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: PPUSH
10453: CALL_OW 69
10457: ST_TO_ADDR
// p := 1 ;
10458: LD_ADDR_VAR 0 4
10462: PUSH
10463: LD_INT 1
10465: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10466: LD_ADDR_VAR 0 3
10470: PUSH
10471: LD_INT 116
10473: PUSH
10474: LD_INT 139
10476: PUSH
10477: LD_INT 69
10479: PUSH
10480: LD_INT 13
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: ST_TO_ADDR
// for i = 1 to 2 do
10489: LD_ADDR_VAR 0 1
10493: PUSH
10494: DOUBLE
10495: LD_INT 1
10497: DEC
10498: ST_TO_ADDR
10499: LD_INT 2
10501: PUSH
10502: FOR_TO
10503: IFFALSE 10601
// begin if IsInUnit ( sci [ i ] ) then
10505: LD_VAR 0 2
10509: PUSH
10510: LD_VAR 0 1
10514: ARRAY
10515: PPUSH
10516: CALL_OW 310
10520: IFFALSE 10537
// ComExitBuilding ( sci [ i ] ) ;
10522: LD_VAR 0 2
10526: PUSH
10527: LD_VAR 0 1
10531: ARRAY
10532: PPUSH
10533: CALL_OW 122
// Wait ( 0 0$03 ) ;
10537: LD_INT 105
10539: PPUSH
10540: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10544: LD_VAR 0 2
10548: PUSH
10549: LD_VAR 0 1
10553: ARRAY
10554: PPUSH
10555: LD_VAR 0 3
10559: PUSH
10560: LD_VAR 0 4
10564: ARRAY
10565: PPUSH
10566: LD_VAR 0 3
10570: PUSH
10571: LD_VAR 0 4
10575: PUSH
10576: LD_INT 1
10578: PLUS
10579: ARRAY
10580: PPUSH
10581: CALL_OW 158
// p := p + 2 ;
10585: LD_ADDR_VAR 0 4
10589: PUSH
10590: LD_VAR 0 4
10594: PUSH
10595: LD_INT 2
10597: PLUS
10598: ST_TO_ADDR
// end ;
10599: GO 10502
10601: POP
10602: POP
// end ;
10603: PPOPN 4
10605: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10606: LD_INT 14
10608: PPUSH
10609: CALL_OW 435
10613: PUSH
10614: LD_INT 20
10616: LESS
10617: IFFALSE 10644
10619: GO 10621
10621: DISABLE
// begin enable ;
10622: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10623: LD_INT 1
10625: PPUSH
10626: LD_INT 5
10628: PPUSH
10629: CALL_OW 12
10633: PPUSH
10634: LD_INT 14
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL_OW 55
// end ; end_of_file
10644: END
// export function Action ; var un ; begin
10645: LD_INT 0
10647: PPUSH
10648: PPUSH
// case Query ( QVul1 ) of 1 :
10649: LD_STRING QVul1
10651: PPUSH
10652: CALL_OW 97
10656: PUSH
10657: LD_INT 1
10659: DOUBLE
10660: EQUAL
10661: IFTRUE 10665
10663: GO 10676
10665: POP
// Difficulty := 1 ; 2 :
10666: LD_ADDR_OWVAR 67
10670: PUSH
10671: LD_INT 1
10673: ST_TO_ADDR
10674: GO 10715
10676: LD_INT 2
10678: DOUBLE
10679: EQUAL
10680: IFTRUE 10684
10682: GO 10695
10684: POP
// Difficulty := 2 ; 3 :
10685: LD_ADDR_OWVAR 67
10689: PUSH
10690: LD_INT 2
10692: ST_TO_ADDR
10693: GO 10715
10695: LD_INT 3
10697: DOUBLE
10698: EQUAL
10699: IFTRUE 10703
10701: GO 10714
10703: POP
// Difficulty := 3 ; end ;
10704: LD_ADDR_OWVAR 67
10708: PUSH
10709: LD_INT 3
10711: ST_TO_ADDR
10712: GO 10715
10714: POP
// case Query ( QVul3 ) of 1 :
10715: LD_STRING QVul3
10717: PPUSH
10718: CALL_OW 97
10722: PUSH
10723: LD_INT 1
10725: DOUBLE
10726: EQUAL
10727: IFTRUE 10731
10729: GO 10754
10731: POP
// begin your_side := 1 ;
10732: LD_ADDR_OWVAR 2
10736: PUSH
10737: LD_INT 1
10739: ST_TO_ADDR
// legion_enemy := 1 ;
10740: LD_ADDR_EXP 36
10744: PUSH
10745: LD_INT 1
10747: ST_TO_ADDR
// PrepareAmerican ;
10748: CALL 214 0 0
// end ; 2 :
10752: GO 10817
10754: LD_INT 2
10756: DOUBLE
10757: EQUAL
10758: IFTRUE 10762
10760: GO 10785
10762: POP
// begin your_side := 2 ;
10763: LD_ADDR_OWVAR 2
10767: PUSH
10768: LD_INT 2
10770: ST_TO_ADDR
// legion_enemy := 2 ;
10771: LD_ADDR_EXP 36
10775: PUSH
10776: LD_INT 2
10778: ST_TO_ADDR
// PrepareArabian ;
10779: CALL 17406 0 0
// end ; 3 :
10783: GO 10817
10785: LD_INT 3
10787: DOUBLE
10788: EQUAL
10789: IFTRUE 10793
10791: GO 10816
10793: POP
// begin your_side := 7 ;
10794: LD_ADDR_OWVAR 2
10798: PUSH
10799: LD_INT 7
10801: ST_TO_ADDR
// legion_enemy := 7 ;
10802: LD_ADDR_EXP 36
10806: PUSH
10807: LD_INT 7
10809: ST_TO_ADDR
// PrepareAlliance ;
10810: CALL 14817 0 0
// end ; end ;
10814: GO 10817
10816: POP
// if your_side = 1 then
10817: LD_OWVAR 2
10821: PUSH
10822: LD_INT 1
10824: EQUAL
10825: IFFALSE 11179
// begin case Query ( QVul4 ) of 1 :
10827: LD_STRING QVul4
10829: PPUSH
10830: CALL_OW 97
10834: PUSH
10835: LD_INT 1
10837: DOUBLE
10838: EQUAL
10839: IFTRUE 10843
10841: GO 10846
10843: POP
// ; end ;
10844: GO 10847
10846: POP
// InGameOn ;
10847: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10851: LD_INT 8
10853: PPUSH
10854: LD_INT 5
10856: PPUSH
10857: CALL_OW 86
// uc_side := 4 ;
10861: LD_ADDR_OWVAR 20
10865: PUSH
10866: LD_INT 4
10868: ST_TO_ADDR
// uc_nation := 1 ;
10869: LD_ADDR_OWVAR 21
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// hc_importance := 0 ;
10877: LD_ADDR_OWVAR 32
10881: PUSH
10882: LD_INT 0
10884: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10885: LD_INT 1
10887: PPUSH
10888: LD_INT 3
10890: PPUSH
10891: LD_EXP 21
10895: PPUSH
10896: CALL_OW 380
// un := CreateHuman ;
10900: LD_ADDR_VAR 0 2
10904: PUSH
10905: CALL_OW 44
10909: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10910: LD_VAR 0 2
10914: PPUSH
10915: LD_INT 12
10917: PPUSH
10918: LD_INT 9
10920: PPUSH
10921: LD_INT 0
10923: PPUSH
10924: CALL_OW 48
// hc_name := Stuart Carey ;
10928: LD_ADDR_OWVAR 26
10932: PUSH
10933: LD_STRING Stuart Carey
10935: ST_TO_ADDR
// hc_class := 1 ;
10936: LD_ADDR_OWVAR 28
10940: PUSH
10941: LD_INT 1
10943: ST_TO_ADDR
// hc_gallery := vulcano ;
10944: LD_ADDR_OWVAR 33
10948: PUSH
10949: LD_STRING vulcano
10951: ST_TO_ADDR
// hc_face_number := 1 ;
10952: LD_ADDR_OWVAR 34
10956: PUSH
10957: LD_INT 1
10959: ST_TO_ADDR
// us_guy := CreateHuman ;
10960: LD_ADDR_EXP 22
10964: PUSH
10965: CALL_OW 44
10969: ST_TO_ADDR
// hc_gallery :=  ;
10970: LD_ADDR_OWVAR 33
10974: PUSH
10975: LD_STRING 
10977: ST_TO_ADDR
// hc_name :=  ;
10978: LD_ADDR_OWVAR 26
10982: PUSH
10983: LD_STRING 
10985: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
10986: LD_VAR 0 2
10990: PPUSH
10991: LD_EXP 19
10995: PPUSH
10996: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11000: LD_EXP 19
11004: PPUSH
11005: LD_VAR 0 2
11009: PPUSH
11010: CALL_OW 119
// Say ( un , VD-un1 ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_STRING VD-un1
11021: PPUSH
11022: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11026: LD_EXP 19
11030: PPUSH
11031: LD_STRING VDc-1
11033: PPUSH
11034: CALL_OW 88
// Say ( un , VD-un2 ) ;
11038: LD_VAR 0 2
11042: PPUSH
11043: LD_STRING VD-un2
11045: PPUSH
11046: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11050: LD_EXP 19
11054: PPUSH
11055: LD_STRING VDc-2
11057: PPUSH
11058: CALL_OW 88
// Say ( un , VD-un3 ) ;
11062: LD_VAR 0 2
11066: PPUSH
11067: LD_STRING VD-un3
11069: PPUSH
11070: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11074: LD_INT 7
11076: PPUSH
11077: CALL_OW 67
// Say ( un , VD-un4 ) ;
11081: LD_VAR 0 2
11085: PPUSH
11086: LD_STRING VD-un4
11088: PPUSH
11089: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11093: LD_VAR 0 2
11097: PPUSH
11098: LD_INT 2
11100: PPUSH
11101: LD_INT 2
11103: PPUSH
11104: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11108: LD_EXP 19
11112: PPUSH
11113: LD_STRING VDc-3
11115: PPUSH
11116: CALL_OW 88
// InGameOff ;
11120: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11124: LD_STRING CVulc1
11126: PPUSH
11127: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11131: LD_INT 35
11133: PPUSH
11134: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11138: LD_VAR 0 2
11142: PPUSH
11143: CALL_OW 250
11147: PUSH
11148: LD_INT 2
11150: EQUAL
11151: PUSH
11152: LD_VAR 0 2
11156: PPUSH
11157: CALL_OW 251
11161: PUSH
11162: LD_INT 2
11164: EQUAL
11165: AND
11166: IFFALSE 11131
// RemoveUnit ( un ) ;
11168: LD_VAR 0 2
11172: PPUSH
11173: CALL_OW 64
// end else
11177: GO 11471
// if your_side = 2 then
11179: LD_OWVAR 2
11183: PUSH
11184: LD_INT 2
11186: EQUAL
11187: IFFALSE 11359
// begin CenterNowOnUnits ( player_commander ) ;
11189: LD_EXP 10
11193: PPUSH
11194: CALL_OW 87
// InGameOn ;
11198: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11202: LD_EXP 51
11206: PPUSH
11207: LD_STRING VSd-1
11209: PPUSH
11210: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11214: LD_INT 22
11216: PUSH
11217: LD_INT 2
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PUSH
11224: LD_INT 21
11226: PUSH
11227: LD_INT 1
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 26
11236: PUSH
11237: LD_INT 1
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: LIST
11248: PUSH
11249: EMPTY
11250: LIST
11251: PPUSH
11252: CALL_OW 69
11256: PUSH
11257: LD_INT 2
11259: ARRAY
11260: PPUSH
11261: LD_STRING VAd-1
11263: PPUSH
11264: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11268: LD_EXP 51
11272: PPUSH
11273: LD_STRING VSd-2
11275: PPUSH
11276: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11280: LD_INT 22
11282: PUSH
11283: LD_INT 2
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: LD_INT 21
11292: PUSH
11293: LD_INT 1
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: PUSH
11300: LD_INT 26
11302: PUSH
11303: LD_INT 1
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: PUSH
11310: EMPTY
11311: LIST
11312: LIST
11313: LIST
11314: PUSH
11315: EMPTY
11316: LIST
11317: PPUSH
11318: CALL_OW 69
11322: PUSH
11323: LD_INT 2
11325: ARRAY
11326: PPUSH
11327: LD_STRING VAd-2
11329: PPUSH
11330: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11334: LD_EXP 51
11338: PPUSH
11339: LD_STRING VSd-3
11341: PPUSH
11342: CALL_OW 88
// InGameOff ;
11346: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11350: LD_STRING CVulc5
11352: PPUSH
11353: CALL_OW 337
// end else
11357: GO 11471
// if your_side = 7 then
11359: LD_OWVAR 2
11363: PUSH
11364: LD_INT 7
11366: EQUAL
11367: IFFALSE 11471
// begin CenterNowOnUnits ( al_commander ) ;
11369: LD_EXP 37
11373: PPUSH
11374: CALL_OW 87
// InGameOn ;
11378: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11382: LD_EXP 37
11386: PPUSH
11387: LD_STRING VPd-1
11389: PPUSH
11390: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11394: LD_INT 22
11396: PUSH
11397: LD_INT 7
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: LD_INT 21
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 26
11416: PUSH
11417: LD_INT 1
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: LIST
11428: PUSH
11429: EMPTY
11430: LIST
11431: PPUSH
11432: CALL_OW 69
11436: PUSH
11437: LD_INT 2
11439: ARRAY
11440: PPUSH
11441: LD_STRING VPpd-1
11443: PPUSH
11444: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11448: LD_EXP 37
11452: PPUSH
11453: LD_STRING VPd-2
11455: PPUSH
11456: CALL_OW 88
// InGameOff ;
11460: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11464: LD_STRING CVulc7
11466: PPUSH
11467: CALL_OW 337
// end ; end ;
11471: LD_VAR 0 1
11475: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11476: LD_INT 22
11478: PUSH
11479: LD_INT 2
11481: PUSH
11482: EMPTY
11483: LIST
11484: LIST
11485: PUSH
11486: LD_INT 30
11488: PUSH
11489: LD_INT 3
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: PPUSH
11500: CALL_OW 69
11504: IFFALSE 11548
11506: GO 11508
11508: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11509: LD_STRING CVulc6
11511: PPUSH
11512: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11516: LD_INT 52500
11518: PUSH
11519: LD_INT 47250
11521: PUSH
11522: LD_INT 42000
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_OWVAR 67
11534: ARRAY
11535: PPUSH
11536: CALL_OW 67
// ru_can_attack := true ;
11540: LD_ADDR_EXP 3
11544: PUSH
11545: LD_INT 1
11547: ST_TO_ADDR
// end ;
11548: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11549: LD_INT 50
11551: PPUSH
11552: CALL_OW 255
11556: PUSH
11557: LD_INT 1
11559: EQUAL
11560: PUSH
11561: LD_INT 22
11563: PUSH
11564: LD_INT 1
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 30
11576: PUSH
11577: LD_INT 3
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 30
11586: PUSH
11587: LD_INT 1
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PPUSH
11603: CALL_OW 69
11607: OR
11608: IFFALSE 11785
11610: GO 11612
11612: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11613: LD_STRING CVulc2
11615: PPUSH
11616: CALL_OW 337
// DialogueOn ;
11620: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11624: LD_INT 10
11626: PPUSH
11627: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 25
11643: PUSH
11644: LD_INT 2
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PPUSH
11655: CALL_OW 69
11659: PUSH
11660: LD_EXP 19
11664: DIFF
11665: PUSH
11666: LD_INT 1
11668: ARRAY
11669: PPUSH
11670: LD_STRING VDb-1
11672: PPUSH
11673: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11677: LD_INT 10
11679: PPUSH
11680: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11684: LD_INT 22
11686: PUSH
11687: LD_INT 1
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PUSH
11694: LD_INT 25
11696: PUSH
11697: LD_INT 4
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: PPUSH
11708: CALL_OW 69
11712: PUSH
11713: LD_EXP 19
11717: DIFF
11718: PUSH
11719: LD_INT 1
11721: ARRAY
11722: PPUSH
11723: LD_STRING VDb-2
11725: PPUSH
11726: CALL_OW 88
// DWait ( 0 0$01 ) ;
11730: LD_INT 35
11732: PPUSH
11733: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11737: LD_EXP 19
11741: PPUSH
11742: LD_STRING VDb-com1
11744: PPUSH
11745: CALL_OW 88
// DialogueOff ;
11749: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11753: LD_INT 44100
11755: PUSH
11756: LD_INT 36750
11758: PUSH
11759: LD_INT 31500
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: LIST
11766: PUSH
11767: LD_OWVAR 67
11771: ARRAY
11772: PPUSH
11773: CALL_OW 67
// ru_can_attack := true ;
11777: LD_ADDR_EXP 3
11781: PUSH
11782: LD_INT 1
11784: ST_TO_ADDR
// end ;
11785: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11786: LD_INT 22
11788: PUSH
11789: LD_INT 7
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: PUSH
11796: LD_INT 30
11798: PUSH
11799: LD_INT 3
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: PPUSH
11810: CALL_OW 69
11814: IFFALSE 11851
11816: GO 11818
11818: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11819: LD_INT 42000
11821: PUSH
11822: LD_INT 34650
11824: PUSH
11825: LD_INT 29400
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: LIST
11832: PUSH
11833: LD_OWVAR 67
11837: ARRAY
11838: PPUSH
11839: CALL_OW 67
// ru_can_attack := true ;
11843: LD_ADDR_EXP 3
11847: PUSH
11848: LD_INT 1
11850: ST_TO_ADDR
// end ;
11851: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11852: LD_INT 58
11854: PPUSH
11855: CALL_OW 255
11859: PUSH
11860: LD_INT 1
11862: EQUAL
11863: IFFALSE 11995
11865: GO 11867
11867: DISABLE
// begin DialogueOn ;
11868: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11872: LD_INT 22
11874: PUSH
11875: LD_INT 1
11877: PUSH
11878: EMPTY
11879: LIST
11880: LIST
11881: PUSH
11882: LD_INT 25
11884: PUSH
11885: LD_INT 2
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PPUSH
11896: CALL_OW 69
11900: PUSH
11901: LD_INT 1
11903: ARRAY
11904: PPUSH
11905: LD_STRING VDe-1
11907: PPUSH
11908: CALL_OW 88
// case Query ( SibNote ) of 1 :
11912: LD_STRING SibNote
11914: PPUSH
11915: CALL_OW 97
11919: PUSH
11920: LD_INT 1
11922: DOUBLE
11923: EQUAL
11924: IFTRUE 11928
11926: GO 11931
11928: POP
// ; end ;
11929: GO 11932
11931: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11932: LD_INT 22
11934: PUSH
11935: LD_INT 1
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PUSH
11942: LD_INT 25
11944: PUSH
11945: LD_INT 2
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PPUSH
11956: CALL_OW 69
11960: PUSH
11961: LD_INT 1
11963: ARRAY
11964: PPUSH
11965: LD_STRING VDe-2
11967: PPUSH
11968: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
11972: LD_EXP 19
11976: PPUSH
11977: LD_STRING VDc-4
11979: PPUSH
11980: CALL_OW 88
// DialogueOff ;
11984: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
11988: LD_STRING CVulc3
11990: PPUSH
11991: CALL_OW 337
// end ;
11995: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
11996: LD_OWVAR 2
12000: PUSH
12001: LD_INT 1
12003: EQUAL
12004: PUSH
12005: LD_INT 22
12007: PUSH
12008: LD_INT 1
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: PUSH
12015: LD_INT 30
12017: PUSH
12018: LD_INT 3
12020: PUSH
12021: EMPTY
12022: LIST
12023: LIST
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PPUSH
12029: CALL_OW 69
12033: PUSH
12034: LD_INT 0
12036: GREATER
12037: AND
12038: IFFALSE 12472
12040: GO 12042
12042: DISABLE
12043: LD_INT 0
12045: PPUSH
12046: PPUSH
12047: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12048: LD_INT 245
12050: PPUSH
12051: LD_INT 1295
12053: PPUSH
12054: CALL_OW 12
12058: PPUSH
12059: CALL_OW 67
// DialogueOn ;
12063: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12067: LD_EXP 22
12071: PPUSH
12072: LD_STRING VDG-1
12074: PPUSH
12075: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12079: LD_EXP 19
12083: PPUSH
12084: LD_STRING VDc-5
12086: PPUSH
12087: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12091: LD_EXP 22
12095: PPUSH
12096: LD_STRING VDG-2
12098: PPUSH
12099: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12103: LD_EXP 19
12107: PPUSH
12108: LD_STRING VDc-6
12110: PPUSH
12111: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12115: LD_EXP 22
12119: PPUSH
12120: LD_STRING VDG-3
12122: PPUSH
12123: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12127: LD_EXP 19
12131: PPUSH
12132: LD_STRING VDc-7
12134: PPUSH
12135: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12139: LD_EXP 22
12143: PPUSH
12144: LD_STRING VDG-4
12146: PPUSH
12147: CALL_OW 94
// DialogueOff ;
12151: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12155: LD_STRING CVulc4
12157: PPUSH
12158: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12162: LD_INT 18900
12164: PUSH
12165: LD_INT 21000
12167: PUSH
12168: LD_INT 23100
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: LIST
12175: PUSH
12176: LD_OWVAR 67
12180: ARRAY
12181: PPUSH
12182: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12186: LD_ADDR_VAR 0 1
12190: PUSH
12191: DOUBLE
12192: LD_INT 1
12194: DEC
12195: ST_TO_ADDR
12196: LD_INT 4
12198: PUSH
12199: LD_INT 5
12201: PUSH
12202: LD_INT 6
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: LIST
12209: PUSH
12210: LD_OWVAR 67
12214: ARRAY
12215: PUSH
12216: FOR_TO
12217: IFFALSE 12461
// begin uc_side := 1 ;
12219: LD_ADDR_OWVAR 20
12223: PUSH
12224: LD_INT 1
12226: ST_TO_ADDR
// uc_nation := 1 ;
12227: LD_ADDR_OWVAR 21
12231: PUSH
12232: LD_INT 1
12234: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12235: LD_INT 0
12237: PPUSH
12238: LD_INT 1
12240: PPUSH
12241: LD_INT 4
12243: PPUSH
12244: CALL_OW 12
12248: PPUSH
12249: LD_EXP 21
12253: PPUSH
12254: CALL_OW 380
// un := CreateHuman ;
12258: LD_ADDR_VAR 0 2
12262: PUSH
12263: CALL_OW 44
12267: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12268: LD_VAR 0 2
12272: PPUSH
12273: LD_INT 2
12275: PPUSH
12276: CALL_OW 233
// if GetClass ( un ) = 3 then
12280: LD_VAR 0 2
12284: PPUSH
12285: CALL_OW 257
12289: PUSH
12290: LD_INT 3
12292: EQUAL
12293: IFFALSE 12444
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12295: LD_ADDR_OWVAR 37
12299: PUSH
12300: LD_INT 2
12302: PUSH
12303: LD_INT 3
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: PUSH
12310: LD_VAR 0 1
12314: PUSH
12315: LD_INT 2
12317: MOD
12318: ARRAY
12319: ST_TO_ADDR
// vc_engine := engine_combustion ;
12320: LD_ADDR_OWVAR 39
12324: PUSH
12325: LD_INT 1
12327: ST_TO_ADDR
// vc_control := control_manual ;
12328: LD_ADDR_OWVAR 38
12332: PUSH
12333: LD_INT 1
12335: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12336: LD_ADDR_OWVAR 40
12340: PUSH
12341: LD_INT 9
12343: PUSH
12344: LD_INT 9
12346: PUSH
12347: LD_INT 5
12349: PUSH
12350: LD_INT 11
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: PUSH
12359: LD_INT 1
12361: PPUSH
12362: LD_INT 4
12364: PPUSH
12365: CALL_OW 12
12369: ARRAY
12370: ST_TO_ADDR
// veh := CreateVehicle ;
12371: LD_ADDR_VAR 0 3
12375: PUSH
12376: CALL_OW 45
12380: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12381: LD_VAR 0 3
12385: PPUSH
12386: LD_INT 2
12388: PPUSH
12389: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12393: LD_VAR 0 3
12397: PPUSH
12398: LD_INT 77
12400: PPUSH
12401: LD_INT 88
12403: PPUSH
12404: CALL_OW 12
12408: PPUSH
12409: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12413: LD_VAR 0 3
12417: PPUSH
12418: LD_INT 1
12420: PPUSH
12421: LD_INT 0
12423: PPUSH
12424: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12428: LD_VAR 0 2
12432: PPUSH
12433: LD_VAR 0 3
12437: PPUSH
12438: CALL_OW 52
// end else
12442: GO 12459
// PlaceUnitArea ( un , start_north , false ) ;
12444: LD_VAR 0 2
12448: PPUSH
12449: LD_INT 1
12451: PPUSH
12452: LD_INT 0
12454: PPUSH
12455: CALL_OW 49
// end ;
12459: GO 12216
12461: POP
12462: POP
// CenterNowOnUnits ( un ) ;
12463: LD_VAR 0 2
12467: PPUSH
12468: CALL_OW 87
// end ;
12472: PPOPN 3
12474: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12475: LD_INT 21
12477: PPUSH
12478: LD_INT 22
12480: PUSH
12481: LD_OWVAR 2
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PPUSH
12490: CALL_OW 70
12494: IFFALSE 12716
12496: GO 12498
12498: DISABLE
12499: LD_INT 0
12501: PPUSH
12502: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12503: LD_ADDR_VAR 0 2
12507: PUSH
12508: LD_INT 22
12510: PUSH
12511: LD_OWVAR 2
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 2
12522: PUSH
12523: LD_INT 25
12525: PUSH
12526: LD_INT 1
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: PUSH
12533: LD_INT 25
12535: PUSH
12536: LD_INT 2
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: PUSH
12543: LD_INT 25
12545: PUSH
12546: LD_INT 3
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: LD_INT 25
12555: PUSH
12556: LD_INT 4
12558: PUSH
12559: EMPTY
12560: LIST
12561: LIST
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: LIST
12567: LIST
12568: LIST
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PPUSH
12574: CALL_OW 69
12578: PUSH
12579: LD_EXP 10
12583: DIFF
12584: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12585: LD_ADDR_VAR 0 1
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: LD_INT 112
12597: PPUSH
12598: LD_INT 67
12600: PPUSH
12601: CALL_OW 73
12605: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12606: LD_VAR 0 1
12610: PPUSH
12611: CALL_OW 255
12615: PUSH
12616: LD_INT 7
12618: EQUAL
12619: IFFALSE 12633
// Say ( un , VD-find-al ) ;
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_STRING VD-find-al
12628: PPUSH
12629: CALL_OW 88
// if GetSide ( un ) = 2 then
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 255
12642: PUSH
12643: LD_INT 2
12645: EQUAL
12646: IFFALSE 12660
// Say ( un , VD-find-ar ) ;
12648: LD_VAR 0 1
12652: PPUSH
12653: LD_STRING VD-find-ar
12655: PPUSH
12656: CALL_OW 88
// if GetSide ( un ) = 1 then
12660: LD_VAR 0 1
12664: PPUSH
12665: CALL_OW 255
12669: PUSH
12670: LD_INT 1
12672: EQUAL
12673: IFFALSE 12699
// begin Say ( un , VD-find-us ) ;
12675: LD_VAR 0 1
12679: PPUSH
12680: LD_STRING VD-find-us
12682: PPUSH
12683: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12687: LD_VAR 0 1
12691: PPUSH
12692: LD_STRING VD-find-us2
12694: PPUSH
12695: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12699: LD_INT 10
12701: PPUSH
12702: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12706: LD_INT 112
12708: PPUSH
12709: LD_INT 67
12711: PPUSH
12712: CALL_OW 86
// end ;
12716: PPOPN 2
12718: END
// every 0 0$01 trigger player_artifact_ready do
12719: LD_EXP 7
12723: IFFALSE 13037
12725: GO 12727
12727: DISABLE
// begin if your_side = 1 then
12728: LD_OWVAR 2
12732: PUSH
12733: LD_INT 1
12735: EQUAL
12736: IFFALSE 12854
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12738: LD_INT 22
12740: PUSH
12741: LD_INT 1
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 25
12750: PUSH
12751: LD_INT 4
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PPUSH
12762: CALL_OW 69
12766: PUSH
12767: LD_EXP 19
12771: DIFF
12772: PUSH
12773: LD_INT 1
12775: ARRAY
12776: PPUSH
12777: LD_STRING VD-us-sci-art-1
12779: PPUSH
12780: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12784: LD_EXP 19
12788: PPUSH
12789: LD_STRING VDc-art1
12791: PPUSH
12792: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12796: LD_INT 22
12798: PUSH
12799: LD_INT 1
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 25
12808: PUSH
12809: LD_INT 4
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 69
12824: PUSH
12825: LD_EXP 19
12829: DIFF
12830: PUSH
12831: LD_INT 1
12833: ARRAY
12834: PPUSH
12835: LD_STRING VD-us-sci-art-2
12837: PPUSH
12838: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12842: LD_EXP 19
12846: PPUSH
12847: LD_STRING VDc-art2
12849: PPUSH
12850: CALL_OW 88
// end ; if your_side = 2 then
12854: LD_OWVAR 2
12858: PUSH
12859: LD_INT 2
12861: EQUAL
12862: IFFALSE 12904
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12864: LD_INT 22
12866: PUSH
12867: LD_INT 2
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PUSH
12874: LD_INT 25
12876: PUSH
12877: LD_INT 4
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: PPUSH
12888: CALL_OW 69
12892: PUSH
12893: LD_INT 1
12895: ARRAY
12896: PPUSH
12897: LD_STRING VD-ar-sci-art-1
12899: PPUSH
12900: CALL_OW 88
// end ; if your_side = 7 then
12904: LD_OWVAR 2
12908: PUSH
12909: LD_INT 7
12911: EQUAL
12912: IFFALSE 13037
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12914: LD_INT 22
12916: PUSH
12917: LD_INT 7
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 4
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PPUSH
12938: CALL_OW 69
12942: PUSH
12943: LD_EXP 37
12947: DIFF
12948: PUSH
12949: LD_INT 1
12951: ARRAY
12952: PPUSH
12953: LD_STRING VD-al-sci-art-1
12955: PPUSH
12956: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
12960: LD_EXP 37
12964: PPUSH
12965: LD_STRING VPd-art-1
12967: PPUSH
12968: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
12972: LD_INT 22
12974: PUSH
12975: LD_INT 7
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PPUSH
12996: CALL_OW 69
13000: PUSH
13001: LD_EXP 37
13005: DIFF
13006: PUSH
13007: LD_INT 1
13009: ARRAY
13010: PPUSH
13011: LD_STRING VD-al-sci-art-2
13013: PPUSH
13014: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13018: LD_EXP 37
13022: PPUSH
13023: LD_STRING VPd-art-2
13025: PPUSH
13026: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13030: LD_STRING CVulc7out
13032: PPUSH
13033: CALL_OW 337
// end ; end ;
13037: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13038: LD_INT 8
13040: PPUSH
13041: LD_INT 22
13043: PUSH
13044: LD_OWVAR 2
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PPUSH
13053: CALL_OW 69
13057: PPUSH
13058: LD_INT 8
13060: PPUSH
13061: CALL 2138 0 2
13065: PPUSH
13066: CALL_OW 292
13070: IFFALSE 13161
13072: GO 13074
13074: DISABLE
// begin if your_side = 1 then
13075: LD_OWVAR 2
13079: PUSH
13080: LD_INT 1
13082: EQUAL
13083: IFFALSE 13117
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13085: LD_INT 22
13087: PUSH
13088: LD_INT 1
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PPUSH
13095: CALL_OW 69
13099: PUSH
13100: LD_EXP 19
13104: DIFF
13105: PUSH
13106: LD_INT 1
13108: ARRAY
13109: PPUSH
13110: LD_STRING VD-legion-us
13112: PPUSH
13113: CALL_OW 88
// if your_side = 2 then
13117: LD_OWVAR 2
13121: PUSH
13122: LD_INT 2
13124: EQUAL
13125: IFFALSE 13139
// Say ( ar_commander , VD-legion-ar ) ;
13127: LD_EXP 51
13131: PPUSH
13132: LD_STRING VD-legion-ar
13134: PPUSH
13135: CALL_OW 88
// if your_side = 7 then
13139: LD_OWVAR 2
13143: PUSH
13144: LD_INT 7
13146: EQUAL
13147: IFFALSE 13161
// Say ( al_commander , VD-legion-al ) ;
13149: LD_EXP 37
13153: PPUSH
13154: LD_STRING VD-legion-al
13156: PPUSH
13157: CALL_OW 88
// end ;
13161: END
// every 0 0$01 trigger mine_vulc do
13162: LD_EXP 12
13166: IFFALSE 13183
13168: GO 13170
13170: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13171: LD_EXP 10
13175: PPUSH
13176: LD_STRING VD-vulc-mines
13178: PPUSH
13179: CALL_OW 88
// end ;
13183: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13184: LD_OWVAR 67
13188: PUSH
13189: LD_INT 1
13191: GREATER
13192: IFFALSE 13311
13194: GO 13196
13196: DISABLE
13197: LD_INT 0
13199: PPUSH
13200: PPUSH
13201: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13202: LD_ADDR_VAR 0 1
13206: PUSH
13207: LD_INT 123
13209: PUSH
13210: LD_INT 95
13212: PUSH
13213: LD_INT 119
13215: PUSH
13216: LD_INT 89
13218: PUSH
13219: LD_INT 115
13221: PUSH
13222: LD_INT 81
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: ST_TO_ADDR
// p := 1 ;
13233: LD_ADDR_VAR 0 2
13237: PUSH
13238: LD_INT 1
13240: ST_TO_ADDR
// for i = 1 to 3 do
13241: LD_ADDR_VAR 0 3
13245: PUSH
13246: DOUBLE
13247: LD_INT 1
13249: DEC
13250: ST_TO_ADDR
13251: LD_INT 3
13253: PUSH
13254: FOR_TO
13255: IFFALSE 13309
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13257: LD_VAR 0 1
13261: PUSH
13262: LD_VAR 0 2
13266: ARRAY
13267: PPUSH
13268: LD_VAR 0 1
13272: PUSH
13273: LD_VAR 0 2
13277: PUSH
13278: LD_INT 1
13280: PLUS
13281: ARRAY
13282: PPUSH
13283: LD_INT 8
13285: PPUSH
13286: LD_INT 0
13288: PPUSH
13289: CALL_OW 454
// p := p + 2 ;
13293: LD_ADDR_VAR 0 2
13297: PUSH
13298: LD_VAR 0 2
13302: PUSH
13303: LD_INT 2
13305: PLUS
13306: ST_TO_ADDR
// end ;
13307: GO 13254
13309: POP
13310: POP
// end ;
13311: PPOPN 3
13313: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13314: LD_OWVAR 67
13318: PUSH
13319: LD_INT 1
13321: GREATER
13322: PUSH
13323: LD_INT 22
13325: PPUSH
13326: LD_INT 22
13328: PUSH
13329: LD_OWVAR 2
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 70
13342: AND
13343: IFFALSE 13547
13345: GO 13347
13347: DISABLE
13348: LD_INT 0
13350: PPUSH
13351: PPUSH
13352: PPUSH
// begin enable ;
13353: ENABLE
// p := 1 ;
13354: LD_ADDR_VAR 0 1
13358: PUSH
13359: LD_INT 1
13361: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13362: LD_ADDR_VAR 0 3
13366: PUSH
13367: LD_INT 123
13369: PUSH
13370: LD_INT 95
13372: PUSH
13373: LD_INT 119
13375: PUSH
13376: LD_INT 89
13378: PUSH
13379: LD_INT 115
13381: PUSH
13382: LD_INT 81
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: ST_TO_ADDR
// for i = 1 to 3 do
13393: LD_ADDR_VAR 0 2
13397: PUSH
13398: DOUBLE
13399: LD_INT 1
13401: DEC
13402: ST_TO_ADDR
13403: LD_INT 3
13405: PUSH
13406: FOR_TO
13407: IFFALSE 13545
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13409: LD_VAR 0 3
13413: PUSH
13414: LD_VAR 0 1
13418: ARRAY
13419: PPUSH
13420: LD_VAR 0 3
13424: PUSH
13425: LD_VAR 0 1
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ARRAY
13434: PPUSH
13435: CALL_OW 428
13439: PUSH
13440: LD_INT 0
13442: GREATER
13443: IFFALSE 13529
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13445: LD_VAR 0 3
13449: PUSH
13450: LD_VAR 0 1
13454: ARRAY
13455: PPUSH
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: PUSH
13466: LD_INT 1
13468: PLUS
13469: ARRAY
13470: PPUSH
13471: CALL_OW 428
13475: PPUSH
13476: CALL_OW 255
13480: PUSH
13481: LD_OWVAR 2
13485: EQUAL
13486: IFFALSE 13529
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13488: LD_VAR 0 3
13492: PUSH
13493: LD_VAR 0 1
13497: ARRAY
13498: PPUSH
13499: LD_VAR 0 3
13503: PUSH
13504: LD_VAR 0 1
13508: PUSH
13509: LD_INT 1
13511: PLUS
13512: ARRAY
13513: PPUSH
13514: LD_INT 8
13516: PPUSH
13517: CALL_OW 456
// mine_vulc := true ;
13521: LD_ADDR_EXP 12
13525: PUSH
13526: LD_INT 1
13528: ST_TO_ADDR
// end ; p := p + 2 ;
13529: LD_ADDR_VAR 0 1
13533: PUSH
13534: LD_VAR 0 1
13538: PUSH
13539: LD_INT 2
13541: PLUS
13542: ST_TO_ADDR
// end ;
13543: GO 13406
13545: POP
13546: POP
// end ;
13547: PPOPN 3
13549: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13550: LD_INT 22
13552: PUSH
13553: LD_INT 3
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PUSH
13565: LD_INT 0
13567: EQUAL
13568: PUSH
13569: LD_OWVAR 2
13573: PUSH
13574: LD_INT 2
13576: NONEQUAL
13577: AND
13578: IFFALSE 13587
13580: GO 13582
13582: DISABLE
// Win ;
13583: CALL 13644 0 0
13587: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13588: LD_INT 2
13590: PUSH
13591: LD_INT 22
13593: PUSH
13594: LD_INT 8
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 22
13603: PUSH
13604: LD_INT 3
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: PPUSH
13616: CALL_OW 69
13620: PUSH
13621: LD_INT 0
13623: EQUAL
13624: PUSH
13625: LD_OWVAR 2
13629: PUSH
13630: LD_INT 2
13632: EQUAL
13633: AND
13634: IFFALSE 13643
13636: GO 13638
13638: DISABLE
// Win ;
13639: CALL 13644 0 0
13643: END
// function Win ; var points ; begin
13644: LD_INT 0
13646: PPUSH
13647: PPUSH
// case Query ( VulcWin ) of 1 :
13648: LD_STRING VulcWin
13650: PPUSH
13651: CALL_OW 97
13655: PUSH
13656: LD_INT 1
13658: DOUBLE
13659: EQUAL
13660: IFTRUE 13664
13662: GO 13667
13664: POP
// ; end ;
13665: GO 13668
13667: POP
// if medal_enabled then
13668: LD_EXP 13
13672: IFFALSE 13686
// AddMedal ( vulc_1 , 1 ) else
13674: LD_STRING vulc_1
13676: PPUSH
13677: LD_INT 1
13679: PPUSH
13680: CALL_OW 101
13684: GO 13697
// AddMedal ( vulc_1 , - 1 ) ;
13686: LD_STRING vulc_1
13688: PPUSH
13689: LD_INT 1
13691: NEG
13692: PPUSH
13693: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13697: LD_INT 22
13699: PUSH
13700: LD_INT 8
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: PUSH
13712: LD_INT 0
13714: EQUAL
13715: IFFALSE 13729
// AddMedal ( vulc_2 , 1 ) else
13717: LD_STRING vulc_2
13719: PPUSH
13720: LD_INT 1
13722: PPUSH
13723: CALL_OW 101
13727: GO 13740
// AddMedal ( vulc_2 , - 1 ) ;
13729: LD_STRING vulc_2
13731: PPUSH
13732: LD_INT 1
13734: NEG
13735: PPUSH
13736: CALL_OW 101
// points := CalculateCommanderPoints ;
13740: LD_ADDR_VAR 0 2
13744: PUSH
13745: CALL 2259 0 0
13749: ST_TO_ADDR
// if points >= 2000 then
13750: LD_VAR 0 2
13754: PUSH
13755: LD_INT 2000
13757: GREATEREQUAL
13758: IFFALSE 13772
// AddMedal ( vulc_3 , 2 ) else
13760: LD_STRING vulc_3
13762: PPUSH
13763: LD_INT 2
13765: PPUSH
13766: CALL_OW 101
13770: GO 13805
// if points >= 0 then
13772: LD_VAR 0 2
13776: PUSH
13777: LD_INT 0
13779: GREATEREQUAL
13780: IFFALSE 13794
// AddMedal ( vulc_3 , 1 ) else
13782: LD_STRING vulc_3
13784: PPUSH
13785: LD_INT 1
13787: PPUSH
13788: CALL_OW 101
13792: GO 13805
// AddMedal ( vulc_3 , - 1 ) ;
13794: LD_STRING vulc_3
13796: PPUSH
13797: LD_INT 1
13799: NEG
13800: PPUSH
13801: CALL_OW 101
// GiveMedals ( MAIN ) ;
13805: LD_STRING MAIN
13807: PPUSH
13808: CALL_OW 102
// YouWin ;
13812: CALL_OW 103
// end ; end_of_file
13816: LD_VAR 0 1
13820: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13821: LD_INT 13
13823: PPUSH
13824: LD_INT 21
13826: PUSH
13827: LD_INT 1
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PPUSH
13834: CALL_OW 70
13838: PUSH
13839: LD_INT 0
13841: GREATER
13842: IFFALSE 13909
13844: GO 13846
13846: DISABLE
13847: LD_INT 0
13849: PPUSH
13850: PPUSH
// begin enable ;
13851: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13852: LD_ADDR_VAR 0 1
13856: PUSH
13857: LD_INT 13
13859: PPUSH
13860: LD_INT 21
13862: PUSH
13863: LD_INT 1
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: PPUSH
13870: CALL_OW 70
13874: PUSH
13875: FOR_IN
13876: IFFALSE 13907
// if GetLives ( i ) > 4 then
13878: LD_VAR 0 1
13882: PPUSH
13883: CALL_OW 256
13887: PUSH
13888: LD_INT 4
13890: GREATER
13891: IFFALSE 13905
// SetLives ( i , 4 ) ;
13893: LD_VAR 0 1
13897: PPUSH
13898: LD_INT 4
13900: PPUSH
13901: CALL_OW 234
13905: GO 13875
13907: POP
13908: POP
// end ;
13909: PPOPN 2
13911: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13912: LD_VAR 0 1
13916: PPUSH
13917: CALL_OW 255
13921: PUSH
13922: LD_OWVAR 2
13926: EQUAL
13927: IFFALSE 13937
// player_res_art := true ;
13929: LD_ADDR_EXP 6
13933: PUSH
13934: LD_INT 1
13936: ST_TO_ADDR
// end ;
13937: PPOPN 1
13939: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13940: LD_INT 22
13942: PUSH
13943: LD_OWVAR 2
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 30
13957: PUSH
13958: LD_INT 8
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: LD_INT 30
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: EMPTY
13976: LIST
13977: LIST
13978: LIST
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PPUSH
13984: CALL_OW 69
13988: PUSH
13989: LD_EXP 6
13993: AND
13994: IFFALSE 14338
13996: GO 13998
13998: DISABLE
13999: LD_INT 0
14001: PPUSH
14002: PPUSH
14003: PPUSH
// begin enable ;
14004: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14005: LD_ADDR_VAR 0 1
14009: PUSH
14010: LD_INT 1
14012: PPUSH
14013: CALL_OW 469
14017: PUSH
14018: LD_INT 1
14020: ARRAY
14021: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14022: LD_ADDR_VAR 0 2
14026: PUSH
14027: LD_INT 1
14029: PPUSH
14030: CALL_OW 469
14034: PUSH
14035: LD_INT 2
14037: ARRAY
14038: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14039: LD_ADDR_VAR 0 3
14043: PUSH
14044: LD_INT 22
14046: PUSH
14047: LD_OWVAR 2
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: PUSH
14056: LD_INT 2
14058: PUSH
14059: LD_INT 30
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PUSH
14069: LD_INT 30
14071: PUSH
14072: LD_INT 11
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: PPUSH
14088: CALL_OW 69
14092: PPUSH
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PPUSH
14103: CALL_OW 73
14107: ST_TO_ADDR
// if player_artifact_ready = false then
14108: LD_EXP 7
14112: PUSH
14113: LD_INT 0
14115: EQUAL
14116: IFFALSE 14222
// if GetDistUnitXY ( lab , x , y ) < 6 then
14118: LD_VAR 0 3
14122: PPUSH
14123: LD_VAR 0 1
14127: PPUSH
14128: LD_VAR 0 2
14132: PPUSH
14133: CALL_OW 297
14137: PUSH
14138: LD_INT 6
14140: LESS
14141: IFFALSE 14202
// begin if BuildingStatus ( lab ) = bs_idle then
14143: LD_VAR 0 3
14147: PPUSH
14148: CALL_OW 461
14152: PUSH
14153: LD_INT 2
14155: EQUAL
14156: IFFALSE 14180
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14158: LD_OWVAR 2
14162: PPUSH
14163: LD_INT 1
14165: PPUSH
14166: LD_INT 2
14168: PPUSH
14169: LD_VAR 0 3
14173: PPUSH
14174: CALL_OW 468
14178: GO 14200
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14180: LD_OWVAR 2
14184: PPUSH
14185: LD_INT 1
14187: PPUSH
14188: LD_INT 1
14190: PPUSH
14191: LD_VAR 0 3
14195: PPUSH
14196: CALL_OW 468
// end else
14200: GO 14222
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14202: LD_OWVAR 2
14206: PPUSH
14207: LD_INT 1
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_VAR 0 3
14217: PPUSH
14218: CALL_OW 468
// if player_artifact_ready then
14222: LD_EXP 7
14226: IFFALSE 14338
// if GetDistUnitXY ( lab , x , y ) < 6 then
14228: LD_VAR 0 3
14232: PPUSH
14233: LD_VAR 0 1
14237: PPUSH
14238: LD_VAR 0 2
14242: PPUSH
14243: CALL_OW 297
14247: PUSH
14248: LD_INT 6
14250: LESS
14251: IFFALSE 14316
// begin if BuildingStatus ( lab ) = bs_idle then
14253: LD_VAR 0 3
14257: PPUSH
14258: CALL_OW 461
14262: PUSH
14263: LD_INT 2
14265: EQUAL
14266: IFFALSE 14292
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14268: LD_OWVAR 2
14272: PPUSH
14273: LD_EXP 8
14277: PPUSH
14278: LD_INT 4
14280: PPUSH
14281: LD_VAR 0 3
14285: PPUSH
14286: CALL_OW 468
14290: GO 14314
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14292: LD_OWVAR 2
14296: PPUSH
14297: LD_EXP 8
14301: PPUSH
14302: LD_INT 1
14304: PPUSH
14305: LD_VAR 0 3
14309: PPUSH
14310: CALL_OW 468
// end else
14314: GO 14338
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14316: LD_OWVAR 2
14320: PPUSH
14321: LD_EXP 8
14325: PPUSH
14326: LD_INT 1
14328: PPUSH
14329: LD_VAR 0 3
14333: PPUSH
14334: CALL_OW 468
// end ;
14338: PPOPN 3
14340: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14341: LD_INT 0
14343: PPUSH
14344: PPUSH
14345: PPUSH
14346: PPUSH
14347: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14348: LD_ADDR_VAR 0 5
14352: PUSH
14353: LD_INT 1
14355: PPUSH
14356: CALL_OW 469
14360: PUSH
14361: LD_INT 1
14363: ARRAY
14364: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14365: LD_ADDR_VAR 0 6
14369: PUSH
14370: LD_INT 1
14372: PPUSH
14373: CALL_OW 469
14377: PUSH
14378: LD_INT 2
14380: ARRAY
14381: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14382: LD_ADDR_VAR 0 8
14386: PUSH
14387: LD_INT 22
14389: PUSH
14390: LD_OWVAR 2
14394: PUSH
14395: EMPTY
14396: LIST
14397: LIST
14398: PUSH
14399: LD_INT 2
14401: PUSH
14402: LD_INT 30
14404: PUSH
14405: LD_INT 8
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: PUSH
14412: LD_INT 30
14414: PUSH
14415: LD_INT 11
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: LIST
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PPUSH
14431: CALL_OW 69
14435: PPUSH
14436: LD_VAR 0 5
14440: PPUSH
14441: LD_VAR 0 6
14445: PPUSH
14446: CALL_OW 73
14450: ST_TO_ADDR
// if icon = art_exp_left then
14451: LD_VAR 0 2
14455: PUSH
14456: LD_INT 1
14458: EQUAL
14459: IFFALSE 14498
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14461: LD_VAR 0 8
14465: PPUSH
14466: LD_EXP 9
14470: PPUSH
14471: LD_INT 1
14473: PPUSH
14474: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14478: LD_OWVAR 2
14482: PPUSH
14483: LD_INT 1
14485: PPUSH
14486: LD_INT 0
14488: PPUSH
14489: LD_VAR 0 8
14493: PPUSH
14494: CALL_OW 468
// end ; if icon = art_icon then
14498: LD_VAR 0 2
14502: PUSH
14503: LD_EXP 8
14507: EQUAL
14508: IFFALSE 14714
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14510: LD_VAR 0 3
14514: PUSH
14515: LD_INT 21
14517: PUSH
14518: LD_INT 3
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: IN
14530: IFFALSE 14714
// begin side := GetSide ( cr1 ) ;
14532: LD_ADDR_VAR 0 9
14536: PUSH
14537: LD_VAR 0 3
14541: PPUSH
14542: CALL_OW 255
14546: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14547: LD_INT 22
14549: PUSH
14550: LD_VAR 0 9
14554: PUSH
14555: EMPTY
14556: LIST
14557: LIST
14558: PUSH
14559: LD_INT 30
14561: PUSH
14562: LD_INT 28
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PPUSH
14573: CALL_OW 69
14577: PUSH
14578: LD_INT 0
14580: GREATER
14581: IFFALSE 14714
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14583: LD_ADDR_VAR 0 7
14587: PUSH
14588: LD_INT 22
14590: PUSH
14591: LD_VAR 0 9
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PUSH
14600: LD_INT 2
14602: PUSH
14603: LD_INT 30
14605: PUSH
14606: LD_INT 26
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 30
14615: PUSH
14616: LD_INT 27
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PUSH
14623: LD_INT 30
14625: PUSH
14626: LD_INT 28
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: PPUSH
14643: CALL_OW 69
14647: PUSH
14648: FOR_IN
14649: IFFALSE 14665
// SetLives ( i , 1 ) ;
14651: LD_VAR 0 7
14655: PPUSH
14656: LD_INT 1
14658: PPUSH
14659: CALL_OW 234
14663: GO 14648
14665: POP
14666: POP
// player_res_art := false ;
14667: LD_ADDR_EXP 6
14671: PUSH
14672: LD_INT 0
14674: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14675: LD_OWVAR 2
14679: PPUSH
14680: LD_EXP 8
14684: PPUSH
14685: LD_INT 1
14687: PPUSH
14688: LD_VAR 0 8
14692: PPUSH
14693: CALL_OW 468
// Wait ( time_to_reuse ) ;
14697: LD_EXP 11
14701: PPUSH
14702: CALL_OW 67
// player_res_art := true ;
14706: LD_ADDR_EXP 6
14710: PUSH
14711: LD_INT 1
14713: ST_TO_ADDR
// end ; end ; end ; end ;
14714: PPOPN 9
14716: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14717: LD_VAR 0 1
14721: PPUSH
14722: CALL_OW 255
14726: PUSH
14727: LD_OWVAR 2
14731: EQUAL
14732: IFFALSE 14769
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14734: LD_OWVAR 2
14738: PPUSH
14739: LD_INT 1
14741: PPUSH
14742: LD_INT 0
14744: PPUSH
14745: LD_VAR 0 1
14749: PPUSH
14750: CALL_OW 468
// player_artifact_ready := true ;
14754: LD_ADDR_EXP 7
14758: PUSH
14759: LD_INT 1
14761: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14762: LD_STRING ArtVulcano
14764: PPUSH
14765: CALL_OW 339
// end ; end ;
14769: PPOPN 1
14771: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14772: LD_OWVAR 2
14776: PPUSH
14777: LD_INT 1
14779: PPUSH
14780: LD_INT 2
14782: PPUSH
14783: LD_VAR 0 1
14787: PPUSH
14788: CALL_OW 468
// end ; end_of_file
14792: PPOPN 2
14794: END
// every 0 0$01 do
14795: GO 14797
14797: DISABLE
// begin enable ;
14798: ENABLE
// Display_Strings := [ #tick , tick ] ;
14799: LD_ADDR_OWVAR 47
14803: PUSH
14804: LD_STRING #tick
14806: PUSH
14807: LD_OWVAR 1
14811: PUSH
14812: EMPTY
14813: LIST
14814: LIST
14815: ST_TO_ADDR
// end ; end_of_file
14816: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14817: LD_INT 0
14819: PPUSH
14820: PPUSH
14821: PPUSH
14822: PPUSH
14823: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14824: LD_ADDR_EXP 39
14828: PUSH
14829: LD_INT 7
14831: PUSH
14832: LD_INT 6
14834: PUSH
14835: LD_INT 5
14837: PUSH
14838: EMPTY
14839: LIST
14840: LIST
14841: LIST
14842: PUSH
14843: LD_OWVAR 67
14847: ARRAY
14848: ST_TO_ADDR
// al_force := [ ] ;
14849: LD_ADDR_EXP 38
14853: PUSH
14854: EMPTY
14855: ST_TO_ADDR
// RemoveAlliance ;
14856: CALL 15234 0 0
// ResetFog ;
14860: CALL_OW 335
// your_side := 7 ;
14864: LD_ADDR_OWVAR 2
14868: PUSH
14869: LD_INT 7
14871: ST_TO_ADDR
// uc_side := 7 ;
14872: LD_ADDR_OWVAR 20
14876: PUSH
14877: LD_INT 7
14879: ST_TO_ADDR
// hc_gallery :=  ;
14880: LD_ADDR_OWVAR 33
14884: PUSH
14885: LD_STRING 
14887: ST_TO_ADDR
// hc_name :=  ;
14888: LD_ADDR_OWVAR 26
14892: PUSH
14893: LD_STRING 
14895: ST_TO_ADDR
// hc_importance := 0 ;
14896: LD_ADDR_OWVAR 32
14900: PUSH
14901: LD_INT 0
14903: ST_TO_ADDR
// for i = 1 to 17 do
14904: LD_ADDR_VAR 0 2
14908: PUSH
14909: DOUBLE
14910: LD_INT 1
14912: DEC
14913: ST_TO_ADDR
14914: LD_INT 17
14916: PUSH
14917: FOR_TO
14918: IFFALSE 14998
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14920: LD_ADDR_OWVAR 21
14924: PUSH
14925: LD_INT 1
14927: PUSH
14928: LD_INT 3
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: PUSH
14935: LD_INT 1
14937: PPUSH
14938: LD_INT 2
14940: PPUSH
14941: CALL_OW 12
14945: ARRAY
14946: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14947: LD_INT 0
14949: PPUSH
14950: LD_INT 1
14952: PPUSH
14953: LD_INT 4
14955: PPUSH
14956: CALL_OW 12
14960: PPUSH
14961: LD_EXP 39
14965: PPUSH
14966: CALL_OW 380
// un := CreateHuman ;
14970: LD_ADDR_VAR 0 4
14974: PUSH
14975: CALL_OW 44
14979: ST_TO_ADDR
// al_force := al_force ^ un ;
14980: LD_ADDR_EXP 38
14984: PUSH
14985: LD_EXP 38
14989: PUSH
14990: LD_VAR 0 4
14994: ADD
14995: ST_TO_ADDR
// end ;
14996: GO 14917
14998: POP
14999: POP
// hc_importance := 100 ;
15000: LD_ADDR_OWVAR 32
15004: PUSH
15005: LD_INT 100
15007: ST_TO_ADDR
// uc_nation := 1 ;
15008: LD_ADDR_OWVAR 21
15012: PUSH
15013: LD_INT 1
15015: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15016: LD_INT 1
15018: PPUSH
15019: LD_INT 1
15021: PPUSH
15022: LD_EXP 39
15026: PPUSH
15027: CALL_OW 380
// al_commander := CreateHuman ;
15031: LD_ADDR_EXP 37
15035: PUSH
15036: CALL_OW 44
15040: ST_TO_ADDR
// player_commander := al_commander ;
15041: LD_ADDR_EXP 10
15045: PUSH
15046: LD_EXP 37
15050: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15051: LD_ADDR_VAR 0 5
15055: PUSH
15056: LD_STRING text
15058: PPUSH
15059: LD_INT 9
15061: PUSH
15062: LD_INT 9
15064: PUSH
15065: LD_INT 8
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: LIST
15072: PUSH
15073: LD_OWVAR 67
15077: ARRAY
15078: PPUSH
15079: LD_INT 9
15081: PUSH
15082: LD_INT 9
15084: PUSH
15085: LD_INT 8
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: LIST
15092: PUSH
15093: LD_OWVAR 67
15097: ARRAY
15098: PPUSH
15099: LD_INT -5
15101: PUSH
15102: LD_EXP 37
15106: PUSH
15107: LD_INT -3
15109: PUSH
15110: LD_INT -2
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: PUSH
15119: LD_EXP 38
15123: ADD
15124: PPUSH
15125: LD_INT 1
15127: PUSH
15128: LD_INT 3
15130: PUSH
15131: LD_INT 2
15133: PUSH
15134: LD_INT 1
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: LD_INT 4
15143: PUSH
15144: LD_INT 1
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PUSH
15151: LD_INT 9
15153: PUSH
15154: LD_INT 5
15156: PUSH
15157: EMPTY
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: PPUSH
15165: CALL_OW 42
15169: ST_TO_ADDR
// team := team ^ al_commander ;
15170: LD_ADDR_VAR 0 5
15174: PUSH
15175: LD_VAR 0 5
15179: PUSH
15180: LD_EXP 37
15184: ADD
15185: ST_TO_ADDR
// for i = 1 to team do
15186: LD_ADDR_VAR 0 2
15190: PUSH
15191: DOUBLE
15192: LD_INT 1
15194: DEC
15195: ST_TO_ADDR
15196: LD_VAR 0 5
15200: PUSH
15201: FOR_TO
15202: IFFALSE 15227
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15204: LD_VAR 0 5
15208: PUSH
15209: LD_VAR 0 2
15213: ARRAY
15214: PPUSH
15215: LD_INT 15
15217: PPUSH
15218: LD_INT 0
15220: PPUSH
15221: CALL_OW 49
15225: GO 15201
15227: POP
15228: POP
// end ;
15229: LD_VAR 0 1
15233: RET
// export function RemoveAlliance ; var i ; begin
15234: LD_INT 0
15236: PPUSH
15237: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15238: LD_INT 22
15240: PUSH
15241: LD_INT 7
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: PUSH
15248: LD_INT 30
15250: PUSH
15251: LD_INT 1
15253: PUSH
15254: EMPTY
15255: LIST
15256: LIST
15257: PUSH
15258: EMPTY
15259: LIST
15260: LIST
15261: PPUSH
15262: CALL_OW 69
15266: PUSH
15267: LD_INT 1
15269: ARRAY
15270: PPUSH
15271: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15275: LD_ADDR_VAR 0 2
15279: PUSH
15280: LD_INT 22
15282: PUSH
15283: LD_INT 7
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PPUSH
15290: CALL_OW 69
15294: PUSH
15295: FOR_IN
15296: IFFALSE 15309
// RemoveUnit ( i ) ;
15298: LD_VAR 0 2
15302: PPUSH
15303: CALL_OW 64
15307: GO 15295
15309: POP
15310: POP
// end ;
15311: LD_VAR 0 1
15315: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15316: LD_INT 0
15318: PPUSH
15319: PPUSH
15320: PPUSH
15321: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15322: LD_INT 31
15324: PPUSH
15325: LD_INT 7
15327: PPUSH
15328: LD_INT 2
15330: PPUSH
15331: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15335: LD_INT 32
15337: PPUSH
15338: LD_INT 7
15340: PPUSH
15341: LD_INT 2
15343: PPUSH
15344: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15348: LD_INT 59
15350: PPUSH
15351: LD_INT 7
15353: PPUSH
15354: LD_INT 2
15356: PPUSH
15357: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15361: LD_ADDR_EXP 39
15365: PUSH
15366: LD_INT 5
15368: PUSH
15369: LD_INT 6
15371: PUSH
15372: LD_INT 7
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: LIST
15379: PUSH
15380: LD_OWVAR 67
15384: ARRAY
15385: ST_TO_ADDR
// al_force := [ ] ;
15386: LD_ADDR_EXP 38
15390: PUSH
15391: EMPTY
15392: ST_TO_ADDR
// al_vehs := [ ] ;
15393: LD_ADDR_EXP 44
15397: PUSH
15398: EMPTY
15399: ST_TO_ADDR
// uc_side := 7 ;
15400: LD_ADDR_OWVAR 20
15404: PUSH
15405: LD_INT 7
15407: ST_TO_ADDR
// uc_nation := 1 ;
15408: LD_ADDR_OWVAR 21
15412: PUSH
15413: LD_INT 1
15415: ST_TO_ADDR
// bc_type := b_oil_mine ;
15416: LD_ADDR_OWVAR 42
15420: PUSH
15421: LD_INT 29
15423: ST_TO_ADDR
// b := CreateBuilding ;
15424: LD_ADDR_VAR 0 4
15428: PUSH
15429: CALL_OW 46
15433: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15434: LD_VAR 0 4
15438: PPUSH
15439: LD_INT 61
15441: PPUSH
15442: LD_INT 7
15444: PPUSH
15445: LD_INT 0
15447: PPUSH
15448: LD_INT 0
15450: PPUSH
15451: CALL_OW 50
// bc_type := b_siberite_mine ;
15455: LD_ADDR_OWVAR 42
15459: PUSH
15460: LD_INT 30
15462: ST_TO_ADDR
// b := CreateBuilding ;
15463: LD_ADDR_VAR 0 4
15467: PUSH
15468: CALL_OW 46
15472: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15473: LD_VAR 0 4
15477: PPUSH
15478: LD_INT 69
15480: PPUSH
15481: LD_INT 13
15483: PPUSH
15484: LD_INT 0
15486: PPUSH
15487: LD_INT 0
15489: PPUSH
15490: CALL_OW 50
// hc_gallery :=  ;
15494: LD_ADDR_OWVAR 33
15498: PUSH
15499: LD_STRING 
15501: ST_TO_ADDR
// hc_name :=  ;
15502: LD_ADDR_OWVAR 26
15506: PUSH
15507: LD_STRING 
15509: ST_TO_ADDR
// hc_importance := 0 ;
15510: LD_ADDR_OWVAR 32
15514: PUSH
15515: LD_INT 0
15517: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15518: LD_ADDR_VAR 0 2
15522: PUSH
15523: LD_INT 22
15525: PUSH
15526: LD_INT 7
15528: PUSH
15529: EMPTY
15530: LIST
15531: LIST
15532: PUSH
15533: LD_INT 30
15535: PUSH
15536: LD_INT 32
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: CALL_OW 69
15551: PUSH
15552: FOR_IN
15553: IFFALSE 15623
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15555: LD_ADDR_OWVAR 21
15559: PUSH
15560: LD_INT 1
15562: PUSH
15563: LD_INT 3
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PUSH
15570: LD_INT 1
15572: PPUSH
15573: LD_INT 2
15575: PPUSH
15576: CALL_OW 12
15580: ARRAY
15581: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15582: LD_INT 0
15584: PPUSH
15585: LD_INT 1
15587: PPUSH
15588: LD_EXP 39
15592: PPUSH
15593: CALL_OW 380
// un := CreateHuman ;
15597: LD_ADDR_VAR 0 3
15601: PUSH
15602: CALL_OW 44
15606: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15607: LD_VAR 0 3
15611: PPUSH
15612: LD_VAR 0 2
15616: PPUSH
15617: CALL_OW 52
// end ;
15621: GO 15552
15623: POP
15624: POP
// for i = 1 to 3 do
15625: LD_ADDR_VAR 0 2
15629: PUSH
15630: DOUBLE
15631: LD_INT 1
15633: DEC
15634: ST_TO_ADDR
15635: LD_INT 3
15637: PUSH
15638: FOR_TO
15639: IFFALSE 15707
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15641: LD_ADDR_OWVAR 21
15645: PUSH
15646: LD_INT 1
15648: PUSH
15649: LD_INT 3
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: PUSH
15656: LD_INT 1
15658: PPUSH
15659: LD_INT 2
15661: PPUSH
15662: CALL_OW 12
15666: ARRAY
15667: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15668: LD_INT 0
15670: PPUSH
15671: LD_INT 4
15673: PPUSH
15674: LD_EXP 39
15678: PPUSH
15679: CALL_OW 380
// un := CreateHuman ;
15683: LD_ADDR_VAR 0 3
15687: PUSH
15688: CALL_OW 44
15692: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15693: LD_VAR 0 3
15697: PPUSH
15698: LD_INT 164
15700: PPUSH
15701: CALL_OW 52
// end ;
15705: GO 15638
15707: POP
15708: POP
// for i = 1 to 6 do
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: DOUBLE
15715: LD_INT 1
15717: DEC
15718: ST_TO_ADDR
15719: LD_INT 6
15721: PUSH
15722: FOR_TO
15723: IFFALSE 15814
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15725: LD_ADDR_OWVAR 21
15729: PUSH
15730: LD_INT 1
15732: PUSH
15733: LD_INT 3
15735: PUSH
15736: EMPTY
15737: LIST
15738: LIST
15739: PUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 2
15745: PPUSH
15746: CALL_OW 12
15750: ARRAY
15751: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15752: LD_INT 0
15754: PPUSH
15755: LD_INT 5
15757: PUSH
15758: LD_INT 9
15760: PUSH
15761: LD_INT 9
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: PUSH
15769: LD_INT 1
15771: PPUSH
15772: LD_INT 3
15774: PPUSH
15775: CALL_OW 12
15779: ARRAY
15780: PPUSH
15781: LD_EXP 39
15785: PPUSH
15786: CALL_OW 380
// un := CreateHuman ;
15790: LD_ADDR_VAR 0 3
15794: PUSH
15795: CALL_OW 44
15799: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15800: LD_VAR 0 3
15804: PPUSH
15805: LD_INT 173
15807: PPUSH
15808: CALL_OW 52
// end ;
15812: GO 15722
15814: POP
15815: POP
// for i = 1 to 6 do
15816: LD_ADDR_VAR 0 2
15820: PUSH
15821: DOUBLE
15822: LD_INT 1
15824: DEC
15825: ST_TO_ADDR
15826: LD_INT 6
15828: PUSH
15829: FOR_TO
15830: IFFALSE 15928
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15832: LD_ADDR_OWVAR 21
15836: PUSH
15837: LD_INT 1
15839: PUSH
15840: LD_INT 3
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: PUSH
15847: LD_INT 1
15849: PPUSH
15850: LD_INT 2
15852: PPUSH
15853: CALL_OW 12
15857: ARRAY
15858: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15859: LD_INT 0
15861: PPUSH
15862: LD_INT 3
15864: PPUSH
15865: LD_EXP 39
15869: PPUSH
15870: CALL_OW 380
// un := CreateHuman ;
15874: LD_ADDR_VAR 0 3
15878: PUSH
15879: CALL_OW 44
15883: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15884: LD_VAR 0 3
15888: PPUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 7
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 30
15901: PUSH
15902: LD_INT 3
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PPUSH
15913: CALL_OW 69
15917: PUSH
15918: LD_INT 1
15920: ARRAY
15921: PPUSH
15922: CALL_OW 52
// end ;
15926: GO 15829
15928: POP
15929: POP
// for i = 1 to 4 do
15930: LD_ADDR_VAR 0 2
15934: PUSH
15935: DOUBLE
15936: LD_INT 1
15938: DEC
15939: ST_TO_ADDR
15940: LD_INT 4
15942: PUSH
15943: FOR_TO
15944: IFFALSE 16012
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15946: LD_ADDR_OWVAR 21
15950: PUSH
15951: LD_INT 1
15953: PUSH
15954: LD_INT 3
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 1
15963: PPUSH
15964: LD_INT 2
15966: PPUSH
15967: CALL_OW 12
15971: ARRAY
15972: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
15973: LD_INT 0
15975: PPUSH
15976: LD_INT 2
15978: PPUSH
15979: LD_EXP 39
15983: PPUSH
15984: CALL_OW 380
// un := CreateHuman ;
15988: LD_ADDR_VAR 0 3
15992: PUSH
15993: CALL_OW 44
15997: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
15998: LD_VAR 0 3
16002: PPUSH
16003: LD_INT 162
16005: PPUSH
16006: CALL_OW 52
// end ;
16010: GO 15943
16012: POP
16013: POP
// uc_nation := 3 ;
16014: LD_ADDR_OWVAR 21
16018: PUSH
16019: LD_INT 3
16021: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16022: LD_ADDR_OWVAR 37
16026: PUSH
16027: LD_INT 21
16029: ST_TO_ADDR
// vc_engine := engine_siberite ;
16030: LD_ADDR_OWVAR 39
16034: PUSH
16035: LD_INT 3
16037: ST_TO_ADDR
// vc_control := control_computer ;
16038: LD_ADDR_OWVAR 38
16042: PUSH
16043: LD_INT 3
16045: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16046: LD_ADDR_OWVAR 40
16050: PUSH
16051: LD_INT 51
16053: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16054: CALL_OW 45
16058: PPUSH
16059: LD_INT 49
16061: PPUSH
16062: LD_INT 13
16064: PPUSH
16065: LD_INT 0
16067: PPUSH
16068: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16072: LD_ADDR_EXP 46
16076: PUSH
16077: LD_INT 22
16079: PUSH
16080: LD_INT 7
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: PUSH
16087: LD_INT 30
16089: PUSH
16090: LD_INT 33
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PPUSH
16101: CALL_OW 69
16105: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16106: LD_ADDR_VAR 0 2
16110: PUSH
16111: DOUBLE
16112: LD_INT 1
16114: DEC
16115: ST_TO_ADDR
16116: LD_INT 22
16118: PUSH
16119: LD_INT 7
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PUSH
16126: LD_INT 30
16128: PUSH
16129: LD_INT 33
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 35
16138: PUSH
16139: LD_INT 0
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: PUSH
16151: EMPTY
16152: LIST
16153: PPUSH
16154: CALL_OW 69
16158: PUSH
16159: FOR_TO
16160: IFFALSE 16220
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16162: LD_INT 22
16164: PUSH
16165: LD_INT 7
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PUSH
16172: LD_INT 30
16174: PUSH
16175: LD_INT 33
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PUSH
16182: LD_INT 35
16184: PUSH
16185: LD_INT 0
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PUSH
16192: EMPTY
16193: LIST
16194: LIST
16195: LIST
16196: PUSH
16197: EMPTY
16198: LIST
16199: PPUSH
16200: CALL_OW 69
16204: PUSH
16205: LD_VAR 0 2
16209: ARRAY
16210: PPUSH
16211: LD_INT 49
16213: PPUSH
16214: CALL_OW 208
16218: GO 16159
16220: POP
16221: POP
// end ;
16222: LD_VAR 0 1
16226: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16227: LD_OWVAR 2
16231: PUSH
16232: LD_INT 1
16234: EQUAL
16235: IFFALSE 17403
16237: GO 16239
16239: DISABLE
16240: LD_INT 0
16242: PPUSH
16243: PPUSH
16244: PPUSH
16245: PPUSH
// begin enable ;
16246: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16247: LD_ADDR_EXP 50
16251: PUSH
16252: LD_INT 22
16254: PUSH
16255: LD_INT 7
16257: PUSH
16258: EMPTY
16259: LIST
16260: LIST
16261: PUSH
16262: LD_INT 21
16264: PUSH
16265: LD_INT 3
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 69
16280: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16281: LD_ADDR_EXP 48
16285: PUSH
16286: LD_INT 164
16288: PUSH
16289: LD_INT 197
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16296: LD_ADDR_EXP 47
16300: PUSH
16301: LD_INT 22
16303: PUSH
16304: LD_INT 7
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: LD_INT 30
16313: PUSH
16314: LD_INT 1
16316: PUSH
16317: EMPTY
16318: LIST
16319: LIST
16320: PUSH
16321: EMPTY
16322: LIST
16323: LIST
16324: PPUSH
16325: CALL_OW 69
16329: PUSH
16330: LD_INT 1
16332: ARRAY
16333: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16334: LD_ADDR_EXP 49
16338: PUSH
16339: LD_INT 22
16341: PUSH
16342: LD_INT 7
16344: PUSH
16345: EMPTY
16346: LIST
16347: LIST
16348: PUSH
16349: LD_INT 30
16351: PUSH
16352: LD_INT 3
16354: PUSH
16355: EMPTY
16356: LIST
16357: LIST
16358: PUSH
16359: EMPTY
16360: LIST
16361: LIST
16362: PPUSH
16363: CALL_OW 69
16367: PUSH
16368: LD_INT 1
16370: ARRAY
16371: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16372: LD_INT 22
16374: PUSH
16375: LD_INT 7
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 34
16384: PUSH
16385: LD_INT 51
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PPUSH
16396: CALL_OW 69
16400: IFFALSE 16440
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16402: LD_ADDR_EXP 45
16406: PUSH
16407: LD_INT 22
16409: PUSH
16410: LD_INT 7
16412: PUSH
16413: EMPTY
16414: LIST
16415: LIST
16416: PUSH
16417: LD_INT 34
16419: PUSH
16420: LD_INT 51
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: EMPTY
16428: LIST
16429: LIST
16430: PPUSH
16431: CALL_OW 69
16435: PUSH
16436: LD_INT 1
16438: ARRAY
16439: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16440: LD_ADDR_EXP 41
16444: PUSH
16445: LD_INT 22
16447: PUSH
16448: LD_INT 7
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: PUSH
16455: LD_INT 25
16457: PUSH
16458: LD_INT 9
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: PUSH
16465: EMPTY
16466: LIST
16467: LIST
16468: PPUSH
16469: CALL_OW 69
16473: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16474: LD_ADDR_EXP 40
16478: PUSH
16479: LD_INT 22
16481: PUSH
16482: LD_INT 7
16484: PUSH
16485: EMPTY
16486: LIST
16487: LIST
16488: PUSH
16489: LD_INT 25
16491: PUSH
16492: LD_INT 2
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PPUSH
16503: CALL_OW 69
16507: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16508: LD_ADDR_EXP 42
16512: PUSH
16513: LD_INT 22
16515: PUSH
16516: LD_INT 7
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PUSH
16523: LD_INT 25
16525: PUSH
16526: LD_INT 3
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PPUSH
16537: CALL_OW 69
16541: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16542: LD_ADDR_EXP 43
16546: PUSH
16547: LD_INT 22
16549: PUSH
16550: LD_INT 7
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: PUSH
16557: LD_INT 25
16559: PUSH
16560: LD_INT 4
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PPUSH
16571: CALL_OW 69
16575: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16576: LD_EXP 41
16580: PPUSH
16581: LD_INT 81
16583: PUSH
16584: LD_INT 7
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 69
16595: PPUSH
16596: CALL 1656 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16600: LD_EXP 45
16604: PPUSH
16605: CALL_OW 314
16609: NOT
16610: PUSH
16611: LD_EXP 45
16615: PPUSH
16616: LD_INT 1
16618: PPUSH
16619: CALL_OW 289
16623: PUSH
16624: LD_INT 100
16626: LESS
16627: AND
16628: IFFALSE 16676
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16630: LD_ADDR_VAR 0 4
16634: PUSH
16635: LD_INT 12
16637: PPUSH
16638: CALL_OW 435
16642: ST_TO_ADDR
// if cr then
16643: LD_VAR 0 4
16647: IFFALSE 16676
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16649: LD_EXP 45
16653: PPUSH
16654: LD_VAR 0 4
16658: PUSH
16659: LD_INT 1
16661: ARRAY
16662: PPUSH
16663: LD_VAR 0 4
16667: PUSH
16668: LD_INT 2
16670: ARRAY
16671: PPUSH
16672: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16676: LD_EXP 50
16680: PPUSH
16681: LD_INT 3
16683: PUSH
16684: LD_INT 24
16686: PUSH
16687: LD_INT 1000
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PPUSH
16698: CALL_OW 72
16702: IFFALSE 16832
// begin if al_eng then
16704: LD_EXP 40
16708: IFFALSE 16830
// for i = 1 to al_eng do
16710: LD_ADDR_VAR 0 1
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_EXP 40
16724: PUSH
16725: FOR_TO
16726: IFFALSE 16828
// if IsInUnit ( al_eng [ i ] ) then
16728: LD_EXP 40
16732: PUSH
16733: LD_VAR 0 1
16737: ARRAY
16738: PPUSH
16739: CALL_OW 310
16743: IFFALSE 16762
// ComExitBuilding ( al_eng [ i ] ) else
16745: LD_EXP 40
16749: PUSH
16750: LD_VAR 0 1
16754: ARRAY
16755: PPUSH
16756: CALL_OW 122
16760: GO 16826
// if not HasTask ( al_eng [ i ] ) then
16762: LD_EXP 40
16766: PUSH
16767: LD_VAR 0 1
16771: ARRAY
16772: PPUSH
16773: CALL_OW 314
16777: NOT
16778: IFFALSE 16826
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16780: LD_EXP 40
16784: PUSH
16785: LD_VAR 0 1
16789: ARRAY
16790: PPUSH
16791: LD_EXP 50
16795: PPUSH
16796: LD_INT 3
16798: PUSH
16799: LD_INT 24
16801: PUSH
16802: LD_INT 1000
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: EMPTY
16810: LIST
16811: LIST
16812: PPUSH
16813: CALL_OW 72
16817: PUSH
16818: LD_INT 1
16820: ARRAY
16821: PPUSH
16822: CALL_OW 130
16826: GO 16725
16828: POP
16829: POP
// end else
16830: GO 16914
// if al_eng then
16832: LD_EXP 40
16836: IFFALSE 16914
// if not IsInUnit ( al_eng [ 1 ] ) then
16838: LD_EXP 40
16842: PUSH
16843: LD_INT 1
16845: ARRAY
16846: PPUSH
16847: CALL_OW 310
16851: NOT
16852: IFFALSE 16914
// for i = 1 to al_eng do
16854: LD_ADDR_VAR 0 1
16858: PUSH
16859: DOUBLE
16860: LD_INT 1
16862: DEC
16863: ST_TO_ADDR
16864: LD_EXP 40
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16912
// if not IsInUnit ( al_eng [ i ] ) then
16872: LD_EXP 40
16876: PUSH
16877: LD_VAR 0 1
16881: ARRAY
16882: PPUSH
16883: CALL_OW 310
16887: NOT
16888: IFFALSE 16910
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16890: LD_EXP 40
16894: PUSH
16895: LD_VAR 0 1
16899: ARRAY
16900: PPUSH
16901: LD_EXP 47
16905: PPUSH
16906: CALL_OW 120
16910: GO 16869
16912: POP
16913: POP
// if al_vehs then
16914: LD_EXP 44
16918: IFFALSE 17018
// if BuildingStatus ( al_fac ) = bs_idle then
16920: LD_EXP 49
16924: PPUSH
16925: CALL_OW 461
16929: PUSH
16930: LD_INT 2
16932: EQUAL
16933: IFFALSE 17018
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16935: LD_EXP 49
16939: PPUSH
16940: LD_EXP 44
16944: PUSH
16945: LD_INT 1
16947: ARRAY
16948: PPUSH
16949: LD_EXP 44
16953: PUSH
16954: LD_INT 2
16956: ARRAY
16957: PPUSH
16958: LD_EXP 44
16962: PUSH
16963: LD_INT 3
16965: ARRAY
16966: PPUSH
16967: LD_EXP 44
16971: PUSH
16972: LD_INT 4
16974: ARRAY
16975: PPUSH
16976: CALL_OW 125
// for i = 1 to 4 do
16980: LD_ADDR_VAR 0 1
16984: PUSH
16985: DOUBLE
16986: LD_INT 1
16988: DEC
16989: ST_TO_ADDR
16990: LD_INT 4
16992: PUSH
16993: FOR_TO
16994: IFFALSE 17016
// al_vehs := Delete ( al_vehs , 1 ) ;
16996: LD_ADDR_EXP 44
17000: PUSH
17001: LD_EXP 44
17005: PPUSH
17006: LD_INT 1
17008: PPUSH
17009: CALL_OW 3
17013: ST_TO_ADDR
17014: GO 16993
17016: POP
17017: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17018: LD_EXP 38
17022: PUSH
17023: LD_INT 0
17025: EQUAL
17026: PUSH
17027: LD_OWVAR 1
17031: PUSH
17032: LD_INT 23100
17034: MOD
17035: PUSH
17036: LD_INT 0
17038: EQUAL
17039: AND
17040: IFFALSE 17154
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17042: LD_ADDR_VAR 0 1
17046: PUSH
17047: DOUBLE
17048: LD_INT 1
17050: DEC
17051: ST_TO_ADDR
17052: LD_INT 4
17054: PUSH
17055: LD_INT 5
17057: PUSH
17058: LD_INT 6
17060: PUSH
17061: EMPTY
17062: LIST
17063: LIST
17064: LIST
17065: PUSH
17066: LD_OWVAR 67
17070: ARRAY
17071: PUSH
17072: FOR_TO
17073: IFFALSE 17152
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17075: LD_ADDR_EXP 44
17079: PUSH
17080: LD_EXP 44
17084: PUSH
17085: LD_INT 23
17087: ADD
17088: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17089: LD_ADDR_EXP 44
17093: PUSH
17094: LD_EXP 44
17098: PUSH
17099: LD_INT 1
17101: ADD
17102: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17103: LD_ADDR_EXP 44
17107: PUSH
17108: LD_EXP 44
17112: PUSH
17113: LD_INT 3
17115: ADD
17116: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17117: LD_ADDR_EXP 44
17121: PUSH
17122: LD_EXP 44
17126: PUSH
17127: LD_INT 46
17129: PUSH
17130: LD_INT 47
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PUSH
17137: LD_INT 1
17139: PPUSH
17140: LD_INT 2
17142: PPUSH
17143: CALL_OW 12
17147: ARRAY
17148: ADD
17149: ST_TO_ADDR
// end ;
17150: GO 17072
17152: POP
17153: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17154: LD_INT 22
17156: PUSH
17157: LD_INT 7
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: PUSH
17164: LD_INT 34
17166: PUSH
17167: LD_INT 51
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: PUSH
17174: EMPTY
17175: LIST
17176: LIST
17177: PPUSH
17178: CALL_OW 69
17182: PUSH
17183: LD_INT 0
17185: EQUAL
17186: IFFALSE 17209
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17188: LD_EXP 49
17192: PPUSH
17193: LD_INT 21
17195: PPUSH
17196: LD_INT 1
17198: PPUSH
17199: LD_INT 3
17201: PPUSH
17202: LD_INT 51
17204: PPUSH
17205: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17209: LD_EXP 38
17213: PUSH
17214: LD_OWVAR 1
17218: PUSH
17219: LD_INT 25200
17221: MOD
17222: PUSH
17223: LD_INT 0
17225: EQUAL
17226: AND
17227: IFFALSE 17290
// begin for i = 1 to al_force do
17229: LD_ADDR_VAR 0 1
17233: PUSH
17234: DOUBLE
17235: LD_INT 1
17237: DEC
17238: ST_TO_ADDR
17239: LD_EXP 38
17243: PUSH
17244: FOR_TO
17245: IFFALSE 17288
// if GetTag ( al_force [ i ] ) <> 11 then
17247: LD_EXP 38
17251: PUSH
17252: LD_VAR 0 1
17256: ARRAY
17257: PPUSH
17258: CALL_OW 110
17262: PUSH
17263: LD_INT 11
17265: NONEQUAL
17266: IFFALSE 17286
// SetTag ( al_force [ i ] , 11 ) ;
17268: LD_EXP 38
17272: PUSH
17273: LD_VAR 0 1
17277: ARRAY
17278: PPUSH
17279: LD_INT 11
17281: PPUSH
17282: CALL_OW 109
17286: GO 17244
17288: POP
17289: POP
// end ; if al_force then
17290: LD_EXP 38
17294: IFFALSE 17403
// for i = 1 to al_force do
17296: LD_ADDR_VAR 0 1
17300: PUSH
17301: DOUBLE
17302: LD_INT 1
17304: DEC
17305: ST_TO_ADDR
17306: LD_EXP 38
17310: PUSH
17311: FOR_TO
17312: IFFALSE 17401
// begin if GetTag ( al_force [ i ] ) = 11 then
17314: LD_EXP 38
17318: PUSH
17319: LD_VAR 0 1
17323: ARRAY
17324: PPUSH
17325: CALL_OW 110
17329: PUSH
17330: LD_INT 11
17332: EQUAL
17333: IFFALSE 17399
// begin if not HasTask ( al_force [ i ] ) then
17335: LD_EXP 38
17339: PUSH
17340: LD_VAR 0 1
17344: ARRAY
17345: PPUSH
17346: CALL_OW 314
17350: NOT
17351: IFFALSE 17399
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17353: LD_EXP 38
17357: PUSH
17358: LD_VAR 0 1
17362: ARRAY
17363: PPUSH
17364: LD_INT 81
17366: PUSH
17367: LD_INT 7
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: PPUSH
17374: CALL_OW 69
17378: PPUSH
17379: LD_EXP 38
17383: PUSH
17384: LD_VAR 0 1
17388: ARRAY
17389: PPUSH
17390: CALL_OW 74
17394: PPUSH
17395: CALL_OW 115
// end ; end ;
17399: GO 17311
17401: POP
17402: POP
// end ; end_of_file
17403: PPOPN 4
17405: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17406: LD_INT 0
17408: PPUSH
17409: PPUSH
17410: PPUSH
17411: PPUSH
17412: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17413: LD_ADDR_EXP 53
17417: PUSH
17418: LD_INT 7
17420: PUSH
17421: LD_INT 6
17423: PUSH
17424: LD_INT 5
17426: PUSH
17427: EMPTY
17428: LIST
17429: LIST
17430: LIST
17431: PUSH
17432: LD_OWVAR 67
17436: ARRAY
17437: ST_TO_ADDR
// ar_force := [ ] ;
17438: LD_ADDR_EXP 52
17442: PUSH
17443: EMPTY
17444: ST_TO_ADDR
// RemoveAlliance ;
17445: CALL 15234 0 0
// RemoveEnvironmentArea ( evn ) ;
17449: LD_INT 17
17451: PPUSH
17452: CALL_OW 355
// your_side := 2 ;
17456: LD_ADDR_OWVAR 2
17460: PUSH
17461: LD_INT 2
17463: ST_TO_ADDR
// uc_side := 2 ;
17464: LD_ADDR_OWVAR 20
17468: PUSH
17469: LD_INT 2
17471: ST_TO_ADDR
// uc_nation := nation_arabian ;
17472: LD_ADDR_OWVAR 21
17476: PUSH
17477: LD_INT 2
17479: ST_TO_ADDR
// hc_gallery :=  ;
17480: LD_ADDR_OWVAR 33
17484: PUSH
17485: LD_STRING 
17487: ST_TO_ADDR
// hc_name :=  ;
17488: LD_ADDR_OWVAR 26
17492: PUSH
17493: LD_STRING 
17495: ST_TO_ADDR
// hc_importance := 0 ;
17496: LD_ADDR_OWVAR 32
17500: PUSH
17501: LD_INT 0
17503: ST_TO_ADDR
// for i = 1 to 15 do
17504: LD_ADDR_VAR 0 2
17508: PUSH
17509: DOUBLE
17510: LD_INT 1
17512: DEC
17513: ST_TO_ADDR
17514: LD_INT 15
17516: PUSH
17517: FOR_TO
17518: IFFALSE 17571
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17520: LD_INT 0
17522: PPUSH
17523: LD_INT 1
17525: PPUSH
17526: LD_INT 4
17528: PPUSH
17529: CALL_OW 12
17533: PPUSH
17534: LD_EXP 53
17538: PPUSH
17539: CALL_OW 380
// un := CreateHuman ;
17543: LD_ADDR_VAR 0 4
17547: PUSH
17548: CALL_OW 44
17552: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17553: LD_ADDR_EXP 52
17557: PUSH
17558: LD_EXP 52
17562: PUSH
17563: LD_VAR 0 4
17567: ADD
17568: ST_TO_ADDR
// end ;
17569: GO 17517
17571: POP
17572: POP
// hc_importance := 100 ;
17573: LD_ADDR_OWVAR 32
17577: PUSH
17578: LD_INT 100
17580: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17581: LD_INT 1
17583: PPUSH
17584: LD_INT 11
17586: PPUSH
17587: LD_EXP 53
17591: PPUSH
17592: CALL_OW 380
// ar_commander := CreateHuman ;
17596: LD_ADDR_EXP 51
17600: PUSH
17601: CALL_OW 44
17605: ST_TO_ADDR
// player_commander := ar_commander ;
17606: LD_ADDR_EXP 10
17610: PUSH
17611: LD_EXP 51
17615: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17616: LD_ADDR_VAR 0 5
17620: PUSH
17621: LD_STRING text
17623: PPUSH
17624: LD_INT 11
17626: PUSH
17627: LD_INT 10
17629: PUSH
17630: LD_INT 9
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: PUSH
17638: LD_OWVAR 67
17642: ARRAY
17643: PPUSH
17644: LD_INT 11
17646: PUSH
17647: LD_INT 10
17649: PUSH
17650: LD_INT 9
17652: PUSH
17653: EMPTY
17654: LIST
17655: LIST
17656: LIST
17657: PUSH
17658: LD_OWVAR 67
17662: ARRAY
17663: PPUSH
17664: LD_INT -5
17666: PUSH
17667: LD_EXP 51
17671: PUSH
17672: LD_INT -3
17674: PUSH
17675: LD_INT -2
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: LIST
17682: LIST
17683: PUSH
17684: LD_EXP 52
17688: ADD
17689: PPUSH
17690: LD_INT 1
17692: PUSH
17693: LD_INT 3
17695: PUSH
17696: LD_INT 2
17698: PUSH
17699: LD_INT 1
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: PUSH
17706: LD_INT 4
17708: PUSH
17709: LD_INT 1
17711: PUSH
17712: EMPTY
17713: LIST
17714: LIST
17715: PUSH
17716: LD_INT 8
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: PPUSH
17726: CALL_OW 42
17730: ST_TO_ADDR
// team := team ^ ar_commander ;
17731: LD_ADDR_VAR 0 5
17735: PUSH
17736: LD_VAR 0 5
17740: PUSH
17741: LD_EXP 51
17745: ADD
17746: ST_TO_ADDR
// for i = 1 to team do
17747: LD_ADDR_VAR 0 2
17751: PUSH
17752: DOUBLE
17753: LD_INT 1
17755: DEC
17756: ST_TO_ADDR
17757: LD_VAR 0 5
17761: PUSH
17762: FOR_TO
17763: IFFALSE 17788
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 2
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 0
17781: PPUSH
17782: CALL_OW 49
17786: GO 17762
17788: POP
17789: POP
// uc_side := 0 ;
17790: LD_ADDR_OWVAR 20
17794: PUSH
17795: LD_INT 0
17797: ST_TO_ADDR
// uc_nation := 0 ;
17798: LD_ADDR_OWVAR 21
17802: PUSH
17803: LD_INT 0
17805: ST_TO_ADDR
// vc_chassis := 31 ;
17806: LD_ADDR_OWVAR 37
17810: PUSH
17811: LD_INT 31
17813: ST_TO_ADDR
// vc_control := control_rider ;
17814: LD_ADDR_OWVAR 38
17818: PUSH
17819: LD_INT 4
17821: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17822: CALL_OW 45
17826: PPUSH
17827: LD_INT 96
17829: PPUSH
17830: LD_INT 20
17832: PPUSH
17833: LD_INT 0
17835: PPUSH
17836: CALL_OW 48
// end ;
17840: LD_VAR 0 1
17844: RET
