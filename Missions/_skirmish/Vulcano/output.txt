// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3489 0 0
// PrepareLegion ;
  27: CALL 7020 0 0
// Action ;
  31: CALL 10699 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 15321 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ; end_of_file
3486: PPOPN 1
3488: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3489: LD_INT 0
3491: PPUSH
3492: PPUSH
3493: PPUSH
3494: PPUSH
3495: PPUSH
3496: PPUSH
3497: PPUSH
3498: PPUSH
3499: PPUSH
3500: PPUSH
3501: PPUSH
// uc_side := 3 ;
3502: LD_ADDR_OWVAR 20
3506: PUSH
3507: LD_INT 3
3509: ST_TO_ADDR
// uc_nation := nation_russian ;
3510: LD_ADDR_OWVAR 21
3514: PUSH
3515: LD_INT 3
3517: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3518: LD_ADDR_VAR 0 4
3522: PUSH
3523: LD_INT 22
3525: PUSH
3526: LD_INT 3
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 30
3535: PUSH
3536: LD_INT 1
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PPUSH
3547: CALL_OW 69
3551: PUSH
3552: LD_INT 1
3554: ARRAY
3555: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3556: LD_ADDR_VAR 0 5
3560: PUSH
3561: LD_INT 22
3563: PUSH
3564: LD_INT 3
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: PUSH
3571: LD_INT 30
3573: PUSH
3574: LD_INT 3
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PPUSH
3585: CALL_OW 69
3589: PUSH
3590: LD_INT 1
3592: ARRAY
3593: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3594: LD_ADDR_VAR 0 6
3598: PUSH
3599: LD_INT 22
3601: PUSH
3602: LD_INT 3
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: PUSH
3609: LD_INT 30
3611: PUSH
3612: LD_INT 34
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL_OW 69
3627: PUSH
3628: LD_INT 1
3630: ARRAY
3631: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3632: LD_ADDR_VAR 0 8
3636: PUSH
3637: LD_INT 22
3639: PUSH
3640: LD_INT 3
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: LD_INT 33
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PUSH
3657: EMPTY
3658: LIST
3659: LIST
3660: PPUSH
3661: CALL_OW 69
3665: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3666: LD_ADDR_VAR 0 7
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 5
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: PUSH
3700: LD_INT 1
3702: ARRAY
3703: ST_TO_ADDR
// ru_blist := [ ] ;
3704: LD_ADDR_EXP 26
3708: PUSH
3709: EMPTY
3710: ST_TO_ADDR
// ru_vlist := [ ] ;
3711: LD_ADDR_EXP 27
3715: PUSH
3716: EMPTY
3717: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3718: LD_ADDR_EXP 30
3722: PUSH
3723: LD_INT 183
3725: PUSH
3726: LD_INT 62
3728: PUSH
3729: LD_INT 147
3731: PUSH
3732: LD_INT 44
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: LIST
3740: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3741: LD_INT 30
3743: PUSH
3744: LD_INT 34
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: PUSH
3756: LD_INT 1
3758: ARRAY
3759: PPUSH
3760: LD_EXP 30
3764: PUSH
3765: LD_INT 1
3767: ARRAY
3768: PPUSH
3769: LD_EXP 30
3773: PUSH
3774: LD_INT 2
3776: ARRAY
3777: PPUSH
3778: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3782: LD_ADDR_EXP 28
3786: PUSH
3787: LD_INT 4
3789: PUSH
3790: LD_INT 5
3792: PUSH
3793: LD_INT 6
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: LIST
3800: PUSH
3801: LD_OWVAR 67
3805: ARRAY
3806: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3807: LD_VAR 0 4
3811: PPUSH
3812: CALL_OW 274
3816: PPUSH
3817: LD_INT 1
3819: PPUSH
3820: LD_INT 3000
3822: PPUSH
3823: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3827: LD_VAR 0 4
3831: PPUSH
3832: CALL_OW 274
3836: PPUSH
3837: LD_INT 2
3839: PPUSH
3840: LD_INT 300
3842: PPUSH
3843: CALL_OW 277
// hc_gallery :=  ;
3847: LD_ADDR_OWVAR 33
3851: PUSH
3852: LD_STRING 
3854: ST_TO_ADDR
// hc_name :=  ;
3855: LD_ADDR_OWVAR 26
3859: PUSH
3860: LD_STRING 
3862: ST_TO_ADDR
// hc_importance := 0 ;
3863: LD_ADDR_OWVAR 32
3867: PUSH
3868: LD_INT 0
3870: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3871: LD_ADDR_EXP 24
3875: PUSH
3876: LD_INT 5
3878: PUSH
3879: LD_INT 6
3881: PUSH
3882: LD_INT 7
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: LIST
3889: PUSH
3890: LD_OWVAR 67
3894: ARRAY
3895: ST_TO_ADDR
// for i = 1 to 6 do
3896: LD_ADDR_VAR 0 2
3900: PUSH
3901: DOUBLE
3902: LD_INT 1
3904: DEC
3905: ST_TO_ADDR
3906: LD_INT 6
3908: PUSH
3909: FOR_TO
3910: IFFALSE 4068
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3912: LD_INT 0
3914: PPUSH
3915: LD_INT 9
3917: PPUSH
3918: LD_EXP 24
3922: PPUSH
3923: CALL_OW 380
// un := CreateHuman ;
3927: LD_ADDR_VAR 0 3
3931: PUSH
3932: CALL_OW 44
3936: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3937: LD_VAR 0 3
3941: PPUSH
3942: LD_VAR 0 7
3946: PPUSH
3947: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3951: LD_INT 0
3953: PPUSH
3954: LD_INT 4
3956: PPUSH
3957: LD_EXP 24
3961: PPUSH
3962: CALL_OW 380
// un := CreateHuman ;
3966: LD_ADDR_VAR 0 3
3970: PUSH
3971: CALL_OW 44
3975: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3976: LD_VAR 0 3
3980: PPUSH
3981: LD_INT 24
3983: PPUSH
3984: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 3
3993: PPUSH
3994: LD_EXP 24
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 3
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4013: LD_VAR 0 3
4017: PPUSH
4018: LD_VAR 0 5
4022: PPUSH
4023: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4027: LD_INT 0
4029: PPUSH
4030: LD_INT 2
4032: PPUSH
4033: LD_EXP 24
4037: PPUSH
4038: CALL_OW 380
// un := CreateHuman ;
4042: LD_ADDR_VAR 0 3
4046: PUSH
4047: CALL_OW 44
4051: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4052: LD_VAR 0 3
4056: PPUSH
4057: LD_VAR 0 4
4061: PPUSH
4062: CALL_OW 52
// end ;
4066: GO 3909
4068: POP
4069: POP
// russian_prepared := true ;
4070: LD_ADDR_EXP 2
4074: PUSH
4075: LD_INT 1
4077: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4078: LD_VAR 0 5
4082: PPUSH
4083: LD_INT 21
4085: PPUSH
4086: LD_INT 3
4088: PPUSH
4089: LD_INT 3
4091: PPUSH
4092: LD_INT 51
4094: PPUSH
4095: CALL_OW 125
// end ;
4099: LD_VAR 0 1
4103: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4104: LD_INT 22
4106: PUSH
4107: LD_INT 3
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: PUSH
4119: LD_INT 0
4121: GREATER
4122: PUSH
4123: LD_EXP 2
4127: AND
4128: IFFALSE 6591
4130: GO 4132
4132: DISABLE
4133: LD_INT 0
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
4145: PPUSH
4146: PPUSH
4147: PPUSH
4148: PPUSH
4149: PPUSH
4150: PPUSH
4151: PPUSH
// begin enable ;
4152: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4153: LD_ADDR_VAR 0 1
4157: PUSH
4158: LD_INT 22
4160: PUSH
4161: LD_INT 3
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 30
4170: PUSH
4171: LD_INT 1
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: PPUSH
4182: CALL_OW 69
4186: PUSH
4187: LD_INT 1
4189: ARRAY
4190: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4191: LD_ADDR_VAR 0 2
4195: PUSH
4196: LD_INT 22
4198: PUSH
4199: LD_INT 3
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 30
4208: PUSH
4209: LD_INT 3
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PPUSH
4220: CALL_OW 69
4224: PUSH
4225: LD_INT 1
4227: ARRAY
4228: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4229: LD_ADDR_VAR 0 3
4233: PUSH
4234: LD_INT 22
4236: PUSH
4237: LD_INT 3
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: LD_INT 30
4246: PUSH
4247: LD_INT 34
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: PPUSH
4258: CALL_OW 69
4262: PUSH
4263: LD_INT 1
4265: ARRAY
4266: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_INT 22
4274: PUSH
4275: LD_INT 3
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 30
4284: PUSH
4285: LD_INT 33
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PPUSH
4296: CALL_OW 69
4300: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4301: LD_ADDR_VAR 0 8
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 5
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: PUSH
4335: LD_INT 1
4337: ARRAY
4338: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4339: LD_ADDR_VAR 0 5
4343: PUSH
4344: LD_INT 22
4346: PUSH
4347: LD_INT 3
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: LD_INT 21
4356: PUSH
4357: LD_INT 3
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: PPUSH
4368: CALL_OW 69
4372: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4373: LD_ADDR_VAR 0 6
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4407: LD_ADDR_VAR 0 7
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 1
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4441: LD_ADDR_VAR 0 9
4445: PUSH
4446: LD_VAR 0 7
4450: PPUSH
4451: LD_INT 25
4453: PUSH
4454: LD_INT 2
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 72
4465: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4466: LD_ADDR_VAR 0 10
4470: PUSH
4471: LD_VAR 0 7
4475: PPUSH
4476: LD_INT 25
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 72
4490: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4491: LD_ADDR_VAR 0 11
4495: PUSH
4496: LD_VAR 0 7
4500: PPUSH
4501: LD_INT 25
4503: PUSH
4504: LD_INT 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: PPUSH
4511: CALL_OW 72
4515: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4516: LD_INT 22
4518: PUSH
4519: LD_INT 3
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: PUSH
4526: LD_INT 34
4528: PUSH
4529: LD_INT 51
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: EMPTY
4537: LIST
4538: LIST
4539: PPUSH
4540: CALL_OW 69
4544: PUSH
4545: LD_INT 0
4547: GREATER
4548: PUSH
4549: LD_EXP 25
4553: PUSH
4554: LD_INT 0
4556: EQUAL
4557: AND
4558: IFFALSE 4598
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4560: LD_ADDR_EXP 25
4564: PUSH
4565: LD_INT 22
4567: PUSH
4568: LD_INT 3
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: PUSH
4575: LD_INT 34
4577: PUSH
4578: LD_INT 51
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: PPUSH
4589: CALL_OW 69
4593: PUSH
4594: LD_INT 1
4596: ARRAY
4597: ST_TO_ADDR
// if ru_cargo then
4598: LD_EXP 25
4602: IFFALSE 4900
// begin if IsInArea ( ru_cargo , ru_base ) then
4604: LD_EXP 25
4608: PPUSH
4609: LD_INT 9
4611: PPUSH
4612: CALL_OW 308
4616: IFFALSE 4695
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4618: LD_EXP 25
4622: PPUSH
4623: LD_INT 1
4625: PPUSH
4626: CALL_OW 289
4630: PUSH
4631: LD_INT 0
4633: EQUAL
4634: IFFALSE 4652
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4636: LD_EXP 25
4640: PPUSH
4641: LD_VAR 0 3
4645: PPUSH
4646: CALL_OW 120
4650: GO 4693
// if not HasTask ( ru_cargo ) then
4652: LD_EXP 25
4656: PPUSH
4657: CALL_OW 314
4661: NOT
4662: IFFALSE 4693
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4664: LD_EXP 25
4668: PPUSH
4669: LD_VAR 0 1
4673: PPUSH
4674: CALL_OW 250
4678: PPUSH
4679: LD_VAR 0 1
4683: PPUSH
4684: CALL_OW 251
4688: PPUSH
4689: CALL_OW 111
// end else
4693: GO 4900
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4695: LD_EXP 25
4699: PPUSH
4700: CALL_OW 314
4704: NOT
4705: PUSH
4706: LD_EXP 25
4710: PPUSH
4711: LD_INT 1
4713: PPUSH
4714: CALL_OW 289
4718: PUSH
4719: LD_INT 100
4721: LESS
4722: AND
4723: IFFALSE 4789
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4725: LD_ADDR_VAR 0 16
4729: PUSH
4730: LD_INT 11
4732: PPUSH
4733: CALL_OW 435
4737: ST_TO_ADDR
// if cr > 0 then
4738: LD_VAR 0 16
4742: PUSH
4743: LD_INT 0
4745: GREATER
4746: IFFALSE 4777
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4748: LD_EXP 25
4752: PPUSH
4753: LD_VAR 0 16
4757: PUSH
4758: LD_INT 1
4760: ARRAY
4761: PPUSH
4762: LD_VAR 0 16
4766: PUSH
4767: LD_INT 2
4769: ARRAY
4770: PPUSH
4771: CALL_OW 117
4775: GO 4789
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4777: LD_EXP 25
4781: PPUSH
4782: LD_INT 11
4784: PPUSH
4785: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4789: LD_EXP 25
4793: PPUSH
4794: CALL_OW 314
4798: NOT
4799: PUSH
4800: LD_EXP 25
4804: PPUSH
4805: LD_INT 10
4807: PPUSH
4808: CALL_OW 308
4812: NOT
4813: AND
4814: PUSH
4815: LD_EXP 25
4819: PPUSH
4820: LD_INT 1
4822: PPUSH
4823: CALL_OW 289
4827: PUSH
4828: LD_INT 100
4830: EQUAL
4831: AND
4832: IFFALSE 4846
// ComMoveToArea ( ru_cargo , cargoa ) ;
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4846: LD_EXP 25
4850: PPUSH
4851: LD_INT 10
4853: PPUSH
4854: CALL_OW 308
4858: PUSH
4859: LD_VAR 0 8
4863: AND
4864: IFFALSE 4900
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4866: LD_VAR 0 7
4870: PPUSH
4871: LD_INT 25
4873: PUSH
4874: LD_INT 9
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL_OW 72
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 139
4892: PPUSH
4893: LD_INT 24
4895: PPUSH
4896: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4900: LD_EXP 25
4904: PUSH
4905: LD_INT 0
4907: EQUAL
4908: PUSH
4909: LD_VAR 0 2
4913: AND
4914: PUSH
4915: LD_VAR 0 2
4919: PPUSH
4920: CALL_OW 461
4924: PUSH
4925: LD_INT 2
4927: EQUAL
4928: AND
4929: IFFALSE 4952
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4931: LD_VAR 0 2
4935: PPUSH
4936: LD_INT 21
4938: PPUSH
4939: LD_INT 3
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_INT 51
4947: PPUSH
4948: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4952: LD_VAR 0 7
4956: PPUSH
4957: LD_INT 25
4959: PUSH
4960: LD_INT 9
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: PPUSH
4967: CALL_OW 72
4971: IFFALSE 5035
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4973: LD_VAR 0 7
4977: PPUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 9
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PPUSH
4988: CALL_OW 72
4992: PPUSH
4993: LD_INT 22
4995: PUSH
4996: LD_OWVAR 2
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 3
5007: PUSH
5008: LD_INT 21
5010: PUSH
5011: LD_INT 3
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL_OW 69
5030: PPUSH
5031: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5035: LD_VAR 0 2
5039: PUSH
5040: LD_EXP 27
5044: PUSH
5045: LD_INT 0
5047: GREATER
5048: AND
5049: IFFALSE 5149
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5051: LD_VAR 0 2
5055: PPUSH
5056: CALL_OW 461
5060: PUSH
5061: LD_INT 2
5063: EQUAL
5064: IFFALSE 5149
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5066: LD_VAR 0 2
5070: PPUSH
5071: LD_EXP 27
5075: PUSH
5076: LD_INT 1
5078: ARRAY
5079: PPUSH
5080: LD_EXP 27
5084: PUSH
5085: LD_INT 2
5087: ARRAY
5088: PPUSH
5089: LD_EXP 27
5093: PUSH
5094: LD_INT 3
5096: ARRAY
5097: PPUSH
5098: LD_EXP 27
5102: PUSH
5103: LD_INT 4
5105: ARRAY
5106: PPUSH
5107: CALL_OW 125
// for i = 1 to 4 do
5111: LD_ADDR_VAR 0 12
5115: PUSH
5116: DOUBLE
5117: LD_INT 1
5119: DEC
5120: ST_TO_ADDR
5121: LD_INT 4
5123: PUSH
5124: FOR_TO
5125: IFFALSE 5147
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5127: LD_ADDR_EXP 27
5131: PUSH
5132: LD_EXP 27
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: CALL_OW 3
5144: ST_TO_ADDR
5145: GO 5124
5147: POP
5148: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5149: LD_INT 24
5151: PPUSH
5152: CALL_OW 461
5156: PUSH
5157: LD_INT 2
5159: EQUAL
5160: PUSH
5161: LD_EXP 4
5165: AND
5166: IFFALSE 5194
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5168: LD_INT 25
5170: PPUSH
5171: LD_INT 3
5173: PPUSH
5174: CALL_OW 321
5178: PUSH
5179: LD_INT 1
5181: EQUAL
5182: IFFALSE 5194
// ComResearch ( ru_lab , tech_sibfiss ) ;
5184: LD_INT 24
5186: PPUSH
5187: LD_INT 25
5189: PPUSH
5190: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5194: LD_INT 25
5196: PPUSH
5197: LD_INT 3
5199: PPUSH
5200: CALL_OW 321
5204: PUSH
5205: LD_INT 2
5207: EQUAL
5208: PUSH
5209: LD_OWVAR 1
5213: PUSH
5214: LD_INT 10500
5216: MOD
5217: PUSH
5218: LD_INT 0
5220: EQUAL
5221: AND
5222: IFFALSE 5260
// if BuildingStatus ( ru_factory ) = bs_idle then
5224: LD_VAR 0 2
5228: PPUSH
5229: CALL_OW 461
5233: PUSH
5234: LD_INT 2
5236: EQUAL
5237: IFFALSE 5260
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5239: LD_VAR 0 2
5243: PPUSH
5244: LD_INT 23
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 48
5255: PPUSH
5256: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5260: LD_INT 22
5262: PUSH
5263: LD_INT 3
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PUSH
5270: LD_INT 34
5272: PUSH
5273: LD_INT 48
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: PUSH
5289: LD_INT 0
5291: GREATER
5292: IFFALSE 5666
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5294: LD_ADDR_VAR 0 17
5298: PUSH
5299: LD_INT 22
5301: PUSH
5302: LD_INT 3
5304: PUSH
5305: EMPTY
5306: LIST
5307: LIST
5308: PUSH
5309: LD_INT 34
5311: PUSH
5312: LD_INT 48
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PPUSH
5323: CALL_OW 69
5327: PUSH
5328: LD_INT 1
5330: ARRAY
5331: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5332: LD_VAR 0 17
5336: PPUSH
5337: LD_INT 9
5339: PPUSH
5340: CALL_OW 308
5344: IFFALSE 5362
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5346: LD_VAR 0 17
5350: PPUSH
5351: LD_VAR 0 3
5355: PPUSH
5356: CALL_OW 120
5360: GO 5666
// if not HasTask ( sib_bomb ) then
5362: LD_VAR 0 17
5366: PPUSH
5367: CALL_OW 314
5371: NOT
5372: IFFALSE 5666
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5374: LD_INT 22
5376: PUSH
5377: LD_OWVAR 2
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 30
5388: PUSH
5389: LD_INT 1
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: PUSH
5405: LD_INT 1
5407: ARRAY
5408: PPUSH
5409: CALL_OW 256
5413: PUSH
5414: LD_INT 250
5416: GREATER
5417: IFFALSE 5510
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5419: LD_VAR 0 17
5423: PPUSH
5424: LD_INT 22
5426: PUSH
5427: LD_OWVAR 2
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 30
5438: PUSH
5439: LD_INT 1
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: PPUSH
5450: CALL_OW 69
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: CALL_OW 250
5463: PPUSH
5464: LD_INT 22
5466: PUSH
5467: LD_OWVAR 2
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 30
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PPUSH
5490: CALL_OW 69
5494: PUSH
5495: LD_INT 1
5497: ARRAY
5498: PPUSH
5499: CALL_OW 251
5503: PPUSH
5504: CALL_OW 116
5508: GO 5666
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5510: LD_INT 22
5512: PUSH
5513: LD_OWVAR 2
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 21
5524: PUSH
5525: LD_INT 3
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PPUSH
5536: CALL_OW 69
5540: PUSH
5541: LD_INT 0
5543: GREATER
5544: IFFALSE 5637
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5546: LD_VAR 0 17
5550: PPUSH
5551: LD_INT 22
5553: PUSH
5554: LD_OWVAR 2
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PUSH
5563: LD_INT 21
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PPUSH
5577: CALL_OW 69
5581: PUSH
5582: LD_INT 1
5584: ARRAY
5585: PPUSH
5586: CALL_OW 250
5590: PPUSH
5591: LD_INT 22
5593: PUSH
5594: LD_OWVAR 2
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: PUSH
5603: LD_INT 21
5605: PUSH
5606: LD_INT 3
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: PUSH
5613: EMPTY
5614: LIST
5615: LIST
5616: PPUSH
5617: CALL_OW 69
5621: PUSH
5622: LD_INT 1
5624: ARRAY
5625: PPUSH
5626: CALL_OW 251
5630: PPUSH
5631: CALL_OW 116
5635: GO 5666
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5637: LD_VAR 0 17
5641: PPUSH
5642: LD_EXP 10
5646: PPUSH
5647: CALL_OW 250
5651: PPUSH
5652: LD_EXP 10
5656: PPUSH
5657: CALL_OW 251
5661: PPUSH
5662: CALL_OW 116
// end ; if ru_can_attack then
5666: LD_EXP 3
5670: IFFALSE 5818
// if ru_time > 0 0$00 then
5672: LD_EXP 29
5676: PUSH
5677: LD_INT 0
5679: GREATER
5680: IFFALSE 5698
// ru_time := ru_time - 0 0$01 else
5682: LD_ADDR_EXP 29
5686: PUSH
5687: LD_EXP 29
5691: PUSH
5692: LD_INT 35
5694: MINUS
5695: ST_TO_ADDR
5696: GO 5818
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5698: LD_ADDR_EXP 29
5702: PUSH
5703: LD_INT 20265
5705: PPUSH
5706: LD_INT 30765
5708: PPUSH
5709: CALL_OW 12
5713: ST_TO_ADDR
// for i = 1 to ru_amount do
5714: LD_ADDR_VAR 0 12
5718: PUSH
5719: DOUBLE
5720: LD_INT 1
5722: DEC
5723: ST_TO_ADDR
5724: LD_EXP 28
5728: PUSH
5729: FOR_TO
5730: IFFALSE 5816
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5732: LD_ADDR_EXP 27
5736: PUSH
5737: LD_EXP 27
5741: PUSH
5742: LD_INT 23
5744: ADD
5745: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5746: LD_ADDR_EXP 27
5750: PUSH
5751: LD_EXP 27
5755: PUSH
5756: LD_INT 3
5758: ADD
5759: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5760: LD_ADDR_EXP 27
5764: PUSH
5765: LD_EXP 27
5769: PUSH
5770: LD_INT 3
5772: ADD
5773: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5774: LD_ADDR_EXP 27
5778: PUSH
5779: LD_EXP 27
5783: PUSH
5784: LD_INT 46
5786: PUSH
5787: LD_INT 45
5789: PUSH
5790: LD_INT 47
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_INT 2
5803: PPUSH
5804: LD_INT 3
5806: PPUSH
5807: CALL_OW 14
5811: ARRAY
5812: ADD
5813: ST_TO_ADDR
// end ;
5814: GO 5729
5816: POP
5817: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5818: LD_VAR 0 4
5822: PPUSH
5823: LD_INT 35
5825: PUSH
5826: LD_INT 0
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PPUSH
5833: CALL_OW 72
5837: PUSH
5838: LD_INT 0
5840: GREATER
5841: IFFALSE 5889
// if BuildingStatus ( ru_factory ) = bs_idle then
5843: LD_VAR 0 2
5847: PPUSH
5848: CALL_OW 461
5852: PUSH
5853: LD_INT 2
5855: EQUAL
5856: IFFALSE 5889
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5858: LD_VAR 0 4
5862: PPUSH
5863: LD_INT 35
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: PPUSH
5873: CALL_OW 72
5877: PUSH
5878: LD_INT 1
5880: ARRAY
5881: PPUSH
5882: LD_INT 47
5884: PPUSH
5885: CALL_OW 148
// if ru_force = ru_amount then
5889: LD_EXP 23
5893: PUSH
5894: LD_EXP 28
5898: EQUAL
5899: IFFALSE 6031
// begin for i = 1 to ru_force do
5901: LD_ADDR_VAR 0 12
5905: PUSH
5906: DOUBLE
5907: LD_INT 1
5909: DEC
5910: ST_TO_ADDR
5911: LD_EXP 23
5915: PUSH
5916: FOR_TO
5917: IFFALSE 6027
// if IsInArea ( ru_force [ i ] , ru_base ) then
5919: LD_EXP 23
5923: PUSH
5924: LD_VAR 0 12
5928: ARRAY
5929: PPUSH
5930: LD_INT 9
5932: PPUSH
5933: CALL_OW 308
5937: IFFALSE 5961
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5939: LD_EXP 23
5943: PUSH
5944: LD_VAR 0 12
5948: ARRAY
5949: PPUSH
5950: LD_VAR 0 3
5954: PPUSH
5955: CALL_OW 120
5959: GO 6025
// if not HasTask ( ru_force [ i ] ) then
5961: LD_EXP 23
5965: PUSH
5966: LD_VAR 0 12
5970: ARRAY
5971: PPUSH
5972: CALL_OW 314
5976: NOT
5977: IFFALSE 6025
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5979: LD_EXP 23
5983: PUSH
5984: LD_VAR 0 12
5988: ARRAY
5989: PPUSH
5990: LD_INT 81
5992: PUSH
5993: LD_INT 3
5995: PUSH
5996: EMPTY
5997: LIST
5998: LIST
5999: PPUSH
6000: CALL_OW 69
6004: PPUSH
6005: LD_EXP 23
6009: PUSH
6010: LD_VAR 0 12
6014: ARRAY
6015: PPUSH
6016: CALL_OW 74
6020: PPUSH
6021: CALL_OW 115
6025: GO 5916
6027: POP
6028: POP
// end else
6029: GO 6181
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6031: LD_EXP 23
6035: PPUSH
6036: LD_INT 3
6038: PUSH
6039: LD_INT 95
6041: PUSH
6042: LD_INT 18
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PPUSH
6053: CALL_OW 72
6057: PUSH
6058: LD_INT 0
6060: GREATER
6061: IFFALSE 6181
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6063: LD_ADDR_VAR 0 13
6067: PUSH
6068: LD_EXP 23
6072: PPUSH
6073: LD_INT 3
6075: PUSH
6076: LD_INT 95
6078: PUSH
6079: LD_INT 18
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: PPUSH
6090: CALL_OW 72
6094: ST_TO_ADDR
// for i = 1 to tmp do
6095: LD_ADDR_VAR 0 12
6099: PUSH
6100: DOUBLE
6101: LD_INT 1
6103: DEC
6104: ST_TO_ADDR
6105: LD_VAR 0 13
6109: PUSH
6110: FOR_TO
6111: IFFALSE 6179
// if not HasTask ( tmp [ i ] ) then
6113: LD_VAR 0 13
6117: PUSH
6118: LD_VAR 0 12
6122: ARRAY
6123: PPUSH
6124: CALL_OW 314
6128: NOT
6129: IFFALSE 6177
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6131: LD_EXP 23
6135: PUSH
6136: LD_VAR 0 12
6140: ARRAY
6141: PPUSH
6142: LD_INT 81
6144: PUSH
6145: LD_INT 3
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: PPUSH
6157: LD_EXP 23
6161: PUSH
6162: LD_VAR 0 12
6166: ARRAY
6167: PPUSH
6168: CALL_OW 74
6172: PPUSH
6173: CALL_OW 115
6177: GO 6110
6179: POP
6180: POP
// end ; if ru_engs > 0 then
6181: LD_VAR 0 9
6185: PUSH
6186: LD_INT 0
6188: GREATER
6189: IFFALSE 6591
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6191: LD_VAR 0 5
6195: PPUSH
6196: LD_INT 3
6198: PUSH
6199: LD_INT 24
6201: PUSH
6202: LD_INT 1000
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PPUSH
6213: CALL_OW 72
6217: PUSH
6218: LD_INT 0
6220: GREATER
6221: IFFALSE 6376
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6223: LD_ADDR_VAR 0 14
6227: PUSH
6228: LD_VAR 0 5
6232: PPUSH
6233: LD_INT 3
6235: PUSH
6236: LD_INT 24
6238: PUSH
6239: LD_INT 1000
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: PPUSH
6250: CALL_OW 72
6254: ST_TO_ADDR
// for i = 1 to ru_engs do
6255: LD_ADDR_VAR 0 12
6259: PUSH
6260: DOUBLE
6261: LD_INT 1
6263: DEC
6264: ST_TO_ADDR
6265: LD_VAR 0 9
6269: PUSH
6270: FOR_TO
6271: IFFALSE 6372
// begin if IsInUnit ( ru_engs [ i ] ) then
6273: LD_VAR 0 9
6277: PUSH
6278: LD_VAR 0 12
6282: ARRAY
6283: PPUSH
6284: CALL_OW 310
6288: IFFALSE 6307
// ComExitBuilding ( ru_engs [ i ] ) else
6290: LD_VAR 0 9
6294: PUSH
6295: LD_VAR 0 12
6299: ARRAY
6300: PPUSH
6301: CALL_OW 122
6305: GO 6370
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 314
6322: NOT
6323: PUSH
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 256
6339: PUSH
6340: LD_INT 600
6342: GREATER
6343: AND
6344: IFFALSE 6370
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6346: LD_VAR 0 9
6350: PUSH
6351: LD_VAR 0 12
6355: ARRAY
6356: PPUSH
6357: LD_VAR 0 14
6361: PUSH
6362: LD_INT 1
6364: ARRAY
6365: PPUSH
6366: CALL_OW 130
// end ;
6370: GO 6270
6372: POP
6373: POP
// end else
6374: GO 6591
// begin if ru_blist = 0 then
6376: LD_EXP 26
6380: PUSH
6381: LD_INT 0
6383: EQUAL
6384: IFFALSE 6466
// begin for i = 1 to ru_engs do
6386: LD_ADDR_VAR 0 12
6390: PUSH
6391: DOUBLE
6392: LD_INT 1
6394: DEC
6395: ST_TO_ADDR
6396: LD_VAR 0 9
6400: PUSH
6401: FOR_TO
6402: IFFALSE 6462
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6404: LD_VAR 0 9
6408: PUSH
6409: LD_VAR 0 12
6413: ARRAY
6414: PPUSH
6415: CALL_OW 314
6419: NOT
6420: PUSH
6421: LD_VAR 0 9
6425: PUSH
6426: LD_VAR 0 12
6430: ARRAY
6431: PPUSH
6432: CALL_OW 310
6436: NOT
6437: AND
6438: IFFALSE 6460
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6440: LD_VAR 0 9
6444: PUSH
6445: LD_VAR 0 12
6449: ARRAY
6450: PPUSH
6451: LD_VAR 0 1
6455: PPUSH
6456: CALL_OW 120
6460: GO 6401
6462: POP
6463: POP
// end else
6464: GO 6591
// begin for i = 1 to ru_engs do
6466: LD_ADDR_VAR 0 12
6470: PUSH
6471: DOUBLE
6472: LD_INT 1
6474: DEC
6475: ST_TO_ADDR
6476: LD_VAR 0 9
6480: PUSH
6481: FOR_TO
6482: IFFALSE 6589
// begin if IsInUnit ( ru_engs [ i ] ) then
6484: LD_VAR 0 9
6488: PUSH
6489: LD_VAR 0 12
6493: ARRAY
6494: PPUSH
6495: CALL_OW 310
6499: IFFALSE 6518
// ComExitBuilding ( ru_engs [ i ] ) else
6501: LD_VAR 0 9
6505: PUSH
6506: LD_VAR 0 12
6510: ARRAY
6511: PPUSH
6512: CALL_OW 122
6516: GO 6587
// if not HasTask ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 314
6533: NOT
6534: IFFALSE 6587
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6536: LD_VAR 0 9
6540: PUSH
6541: LD_VAR 0 12
6545: ARRAY
6546: PPUSH
6547: LD_EXP 26
6551: PUSH
6552: LD_INT 1
6554: ARRAY
6555: PPUSH
6556: LD_EXP 26
6560: PUSH
6561: LD_INT 2
6563: ARRAY
6564: PPUSH
6565: LD_EXP 26
6569: PUSH
6570: LD_INT 3
6572: ARRAY
6573: PPUSH
6574: LD_EXP 26
6578: PUSH
6579: LD_INT 4
6581: ARRAY
6582: PPUSH
6583: CALL_OW 145
// end ;
6587: GO 6481
6589: POP
6590: POP
// end ; end ; end ; end ;
6591: PPOPN 17
6593: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6594: LD_EXP 2
6598: PUSH
6599: LD_INT 11
6601: PPUSH
6602: CALL_OW 435
6606: PUSH
6607: LD_INT 20
6609: LESS
6610: AND
6611: IFFALSE 6674
6613: GO 6615
6615: DISABLE
// begin enable ;
6616: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6617: LD_INT 1
6619: PPUSH
6620: LD_INT 5
6622: PPUSH
6623: CALL_OW 12
6627: PPUSH
6628: LD_INT 11
6630: PPUSH
6631: LD_INT 1
6633: PPUSH
6634: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6638: LD_INT 1505
6640: PPUSH
6641: LD_INT 2100
6643: PPUSH
6644: CALL_OW 12
6648: PPUSH
6649: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 5
6658: PPUSH
6659: CALL_OW 12
6663: PPUSH
6664: LD_INT 11
6666: PPUSH
6667: LD_INT 1
6669: PPUSH
6670: CALL_OW 55
// end ;
6674: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6675: LD_EXP 4
6679: PUSH
6680: LD_INT 0
6682: EQUAL
6683: IFFALSE 6798
6685: GO 6687
6687: DISABLE
6688: LD_INT 0
6690: PPUSH
6691: PPUSH
// begin enable ;
6692: ENABLE
// i := Rand ( 0 , 100 ) ;
6693: LD_ADDR_VAR 0 1
6697: PUSH
6698: LD_INT 0
6700: PPUSH
6701: LD_INT 100
6703: PPUSH
6704: CALL_OW 12
6708: ST_TO_ADDR
// case your_side of 1 :
6709: LD_OWVAR 2
6713: PUSH
6714: LD_INT 1
6716: DOUBLE
6717: EQUAL
6718: IFTRUE 6722
6720: GO 6733
6722: POP
// tmp := 10 ; 2 :
6723: LD_ADDR_VAR 0 2
6727: PUSH
6728: LD_INT 10
6730: ST_TO_ADDR
6731: GO 6772
6733: LD_INT 2
6735: DOUBLE
6736: EQUAL
6737: IFTRUE 6741
6739: GO 6752
6741: POP
// tmp := 0 ; 7 :
6742: LD_ADDR_VAR 0 2
6746: PUSH
6747: LD_INT 0
6749: ST_TO_ADDR
6750: GO 6772
6752: LD_INT 7
6754: DOUBLE
6755: EQUAL
6756: IFTRUE 6760
6758: GO 6771
6760: POP
// tmp := 15 ; end ;
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_INT 15
6768: ST_TO_ADDR
6769: GO 6772
6771: POP
// if i < chance_to_bomb + tmp then
6772: LD_VAR 0 1
6776: PUSH
6777: LD_EXP 5
6781: PUSH
6782: LD_VAR 0 2
6786: PLUS
6787: LESS
6788: IFFALSE 6798
// ru_sib_bomb := true ;
6790: LD_ADDR_EXP 4
6794: PUSH
6795: LD_INT 1
6797: ST_TO_ADDR
// end ;
6798: PPOPN 2
6800: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6801: LD_INT 22
6803: PUSH
6804: LD_OWVAR 2
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PUSH
6813: LD_INT 34
6815: PUSH
6816: LD_INT 8
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL_OW 69
6831: IFFALSE 6844
6833: GO 6835
6835: DISABLE
// begin ru_sib_bomb := true ;
6836: LD_ADDR_EXP 4
6840: PUSH
6841: LD_INT 1
6843: ST_TO_ADDR
// end ;
6844: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6845: LD_INT 22
6847: PUSH
6848: LD_INT 3
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 30
6857: PUSH
6858: LD_INT 34
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: PPUSH
6869: CALL_OW 69
6873: IFFALSE 6972
6875: GO 6877
6877: DISABLE
6878: LD_INT 0
6880: PPUSH
// begin enable ;
6881: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6882: LD_ADDR_VAR 0 1
6886: PUSH
6887: LD_INT 1
6889: PUSH
6890: LD_INT 3
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: LD_INT 1
6899: PPUSH
6900: LD_INT 2
6902: PPUSH
6903: CALL_OW 12
6907: ARRAY
6908: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6909: LD_INT 22
6911: PUSH
6912: LD_INT 3
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 30
6921: PUSH
6922: LD_INT 34
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PPUSH
6933: CALL_OW 69
6937: PUSH
6938: LD_INT 1
6940: ARRAY
6941: PPUSH
6942: LD_EXP 30
6946: PUSH
6947: LD_VAR 0 1
6951: ARRAY
6952: PPUSH
6953: LD_EXP 30
6957: PUSH
6958: LD_VAR 0 1
6962: PUSH
6963: LD_INT 1
6965: PLUS
6966: ARRAY
6967: PPUSH
6968: CALL_OW 243
// end ; end_of_file
6972: PPOPN 1
6974: END
// export function RemoveLegion ; var i ; begin
6975: LD_INT 0
6977: PPUSH
6978: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6979: LD_ADDR_VAR 0 2
6983: PUSH
6984: LD_INT 22
6986: PUSH
6987: LD_INT 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PPUSH
6994: CALL_OW 69
6998: PUSH
6999: FOR_IN
7000: IFFALSE 7013
// RemoveUnit ( i ) ;
7002: LD_VAR 0 2
7006: PPUSH
7007: CALL_OW 64
7011: GO 6999
7013: POP
7014: POP
// end ;
7015: LD_VAR 0 1
7019: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7020: LD_INT 0
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7032: LD_ADDR_VAR 0 7
7036: PUSH
7037: LD_INT 22
7039: PUSH
7040: LD_INT 8
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PUSH
7047: LD_INT 30
7049: PUSH
7050: LD_INT 1
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PPUSH
7061: CALL_OW 69
7065: PUSH
7066: LD_INT 1
7068: ARRAY
7069: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7070: LD_ADDR_VAR 0 8
7074: PUSH
7075: LD_INT 22
7077: PUSH
7078: LD_INT 8
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PUSH
7085: LD_INT 30
7087: PUSH
7088: LD_INT 3
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: PPUSH
7099: CALL_OW 69
7103: PUSH
7104: LD_INT 1
7106: ARRAY
7107: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7108: LD_ADDR_VAR 0 9
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_INT 8
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 30
7128: PUSH
7129: LD_INT 6
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: PUSH
7136: LD_INT 30
7138: PUSH
7139: LD_INT 8
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PPUSH
7155: CALL_OW 69
7159: PUSH
7160: LD_INT 1
7162: ARRAY
7163: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7164: LD_ADDR_VAR 0 10
7168: PUSH
7169: LD_INT 22
7171: PUSH
7172: LD_INT 8
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 30
7181: PUSH
7182: LD_INT 32
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PPUSH
7193: CALL_OW 69
7197: ST_TO_ADDR
// uc_side := 8 ;
7198: LD_ADDR_OWVAR 20
7202: PUSH
7203: LD_INT 8
7205: ST_TO_ADDR
// uc_nation := nation_arabian ;
7206: LD_ADDR_OWVAR 21
7210: PUSH
7211: LD_INT 2
7213: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7214: LD_ADDR_EXP 32
7218: PUSH
7219: LD_INT 5
7221: PUSH
7222: LD_INT 6
7224: PUSH
7225: LD_INT 7
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: LIST
7232: PUSH
7233: LD_OWVAR 67
7237: ARRAY
7238: ST_TO_ADDR
// legion_blist := [ ] ;
7239: LD_ADDR_EXP 34
7243: PUSH
7244: EMPTY
7245: ST_TO_ADDR
// legion_vlist := [ ] ;
7246: LD_ADDR_EXP 35
7250: PUSH
7251: EMPTY
7252: ST_TO_ADDR
// legion_force := [ ] ;
7253: LD_ADDR_EXP 31
7257: PUSH
7258: EMPTY
7259: ST_TO_ADDR
// legion_enemy := - 1 ;
7260: LD_ADDR_EXP 36
7264: PUSH
7265: LD_INT 1
7267: NEG
7268: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7269: LD_VAR 0 7
7273: PPUSH
7274: CALL_OW 274
7278: PPUSH
7279: LD_INT 1
7281: PPUSH
7282: LD_INT 10000
7284: PPUSH
7285: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7289: LD_VAR 0 7
7293: PPUSH
7294: CALL_OW 274
7298: PPUSH
7299: LD_INT 3
7301: PPUSH
7302: LD_INT 1000
7304: PPUSH
7305: CALL_OW 277
// for i = 1 to l_towers do
7309: LD_ADDR_VAR 0 3
7313: PUSH
7314: DOUBLE
7315: LD_INT 1
7317: DEC
7318: ST_TO_ADDR
7319: LD_VAR 0 10
7323: PUSH
7324: FOR_TO
7325: IFFALSE 7374
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7327: LD_INT 0
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: LD_EXP 32
7337: PPUSH
7338: CALL_OW 380
// un := CreateHuman ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: CALL_OW 44
7351: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7352: LD_VAR 0 2
7356: PPUSH
7357: LD_VAR 0 10
7361: PUSH
7362: LD_VAR 0 3
7366: ARRAY
7367: PPUSH
7368: CALL_OW 52
// end ;
7372: GO 7324
7374: POP
7375: POP
// for i = 1 to 4 do
7376: LD_ADDR_VAR 0 3
7380: PUSH
7381: DOUBLE
7382: LD_INT 1
7384: DEC
7385: ST_TO_ADDR
7386: LD_INT 4
7388: PUSH
7389: FOR_TO
7390: IFFALSE 7483
// for p = 1 to 2 do
7392: LD_ADDR_VAR 0 6
7396: PUSH
7397: DOUBLE
7398: LD_INT 1
7400: DEC
7401: ST_TO_ADDR
7402: LD_INT 2
7404: PUSH
7405: FOR_TO
7406: IFFALSE 7479
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7408: LD_INT 0
7410: PPUSH
7411: LD_INT 8
7413: PPUSH
7414: LD_EXP 32
7418: PPUSH
7419: CALL_OW 380
// un := CreateHuman ;
7423: LD_ADDR_VAR 0 2
7427: PUSH
7428: CALL_OW 44
7432: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7433: LD_VAR 0 2
7437: PPUSH
7438: LD_INT 22
7440: PUSH
7441: LD_INT 8
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 30
7450: PUSH
7451: LD_INT 5
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PPUSH
7462: CALL_OW 69
7466: PUSH
7467: LD_VAR 0 6
7471: ARRAY
7472: PPUSH
7473: CALL_OW 52
// end ;
7477: GO 7405
7479: POP
7480: POP
7481: GO 7389
7483: POP
7484: POP
// for i = 1 to 4 do
7485: LD_ADDR_VAR 0 3
7489: PUSH
7490: DOUBLE
7491: LD_INT 1
7493: DEC
7494: ST_TO_ADDR
7495: LD_INT 4
7497: PUSH
7498: FOR_TO
7499: IFFALSE 7542
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7501: LD_INT 0
7503: PPUSH
7504: LD_INT 4
7506: PPUSH
7507: LD_EXP 32
7511: PPUSH
7512: CALL_OW 380
// un := CreateHuman ;
7516: LD_ADDR_VAR 0 2
7520: PUSH
7521: CALL_OW 44
7525: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7526: LD_VAR 0 2
7530: PPUSH
7531: LD_VAR 0 9
7535: PPUSH
7536: CALL_OW 52
// end ;
7540: GO 7498
7542: POP
7543: POP
// for i = 1 to 6 do
7544: LD_ADDR_VAR 0 3
7548: PUSH
7549: DOUBLE
7550: LD_INT 1
7552: DEC
7553: ST_TO_ADDR
7554: LD_INT 6
7556: PUSH
7557: FOR_TO
7558: IFFALSE 7601
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7560: LD_INT 0
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_EXP 32
7570: PPUSH
7571: CALL_OW 380
// un := CreateHuman ;
7575: LD_ADDR_VAR 0 2
7579: PUSH
7580: CALL_OW 44
7584: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7585: LD_VAR 0 2
7589: PPUSH
7590: LD_VAR 0 8
7594: PPUSH
7595: CALL_OW 52
// end ;
7599: GO 7557
7601: POP
7602: POP
// for i = 1 to 5 do
7603: LD_ADDR_VAR 0 3
7607: PUSH
7608: DOUBLE
7609: LD_INT 1
7611: DEC
7612: ST_TO_ADDR
7613: LD_INT 5
7615: PUSH
7616: FOR_TO
7617: IFFALSE 7660
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7619: LD_INT 0
7621: PPUSH
7622: LD_INT 2
7624: PPUSH
7625: LD_EXP 32
7629: PPUSH
7630: CALL_OW 380
// un := CreateHuman ;
7634: LD_ADDR_VAR 0 2
7638: PUSH
7639: CALL_OW 44
7643: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7644: LD_VAR 0 2
7648: PPUSH
7649: LD_VAR 0 7
7653: PPUSH
7654: CALL_OW 52
// end ;
7658: GO 7616
7660: POP
7661: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7662: LD_ADDR_VAR 0 4
7666: PUSH
7667: LD_INT 199
7669: PPUSH
7670: LD_INT 134
7672: PPUSH
7673: LD_INT 216
7675: PPUSH
7676: LD_INT 141
7678: PPUSH
7679: LD_INT 6
7681: PPUSH
7682: CALL 1562 0 5
7686: ST_TO_ADDR
// p := 1 ;
7687: LD_ADDR_VAR 0 6
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i = 1 to 3 do
7695: LD_ADDR_VAR 0 3
7699: PUSH
7700: DOUBLE
7701: LD_INT 1
7703: DEC
7704: ST_TO_ADDR
7705: LD_INT 3
7707: PUSH
7708: FOR_TO
7709: IFFALSE 7962
// begin vc_chassis := ar_half_tracked ;
7711: LD_ADDR_OWVAR 37
7715: PUSH
7716: LD_INT 14
7718: ST_TO_ADDR
// vc_engine := engine_siberite ;
7719: LD_ADDR_OWVAR 39
7723: PUSH
7724: LD_INT 3
7726: ST_TO_ADDR
// vc_control := control_manual ;
7727: LD_ADDR_OWVAR 38
7731: PUSH
7732: LD_INT 1
7734: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7735: LD_ADDR_OWVAR 40
7739: PUSH
7740: LD_INT 31
7742: ST_TO_ADDR
// veh := CreateVehicle ;
7743: LD_ADDR_VAR 0 5
7747: PUSH
7748: CALL_OW 45
7752: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7753: LD_VAR 0 4
7757: PUSH
7758: LD_VAR 0 6
7762: ARRAY
7763: PPUSH
7764: LD_VAR 0 4
7768: PUSH
7769: LD_VAR 0 6
7773: PUSH
7774: LD_INT 1
7776: PLUS
7777: ARRAY
7778: PPUSH
7779: CALL_OW 428
7783: PUSH
7784: LD_INT 0
7786: EQUAL
7787: IFFALSE 7829
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7789: LD_VAR 0 5
7793: PPUSH
7794: LD_VAR 0 4
7798: PUSH
7799: LD_VAR 0 6
7803: ARRAY
7804: PPUSH
7805: LD_VAR 0 4
7809: PUSH
7810: LD_VAR 0 6
7814: PUSH
7815: LD_INT 1
7817: PLUS
7818: ARRAY
7819: PPUSH
7820: LD_INT 0
7822: PPUSH
7823: CALL_OW 48
7827: GO 7917
// begin repeat p := p + 2 ;
7829: LD_ADDR_VAR 0 6
7833: PUSH
7834: LD_VAR 0 6
7838: PUSH
7839: LD_INT 2
7841: PLUS
7842: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7843: LD_VAR 0 4
7847: PUSH
7848: LD_VAR 0 6
7852: ARRAY
7853: PPUSH
7854: LD_VAR 0 4
7858: PUSH
7859: LD_VAR 0 6
7863: PUSH
7864: LD_INT 1
7866: PLUS
7867: ARRAY
7868: PPUSH
7869: CALL_OW 428
7873: PUSH
7874: LD_INT 0
7876: EQUAL
7877: IFFALSE 7829
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7879: LD_VAR 0 5
7883: PPUSH
7884: LD_VAR 0 4
7888: PUSH
7889: LD_VAR 0 6
7893: ARRAY
7894: PPUSH
7895: LD_VAR 0 4
7899: PUSH
7900: LD_VAR 0 6
7904: PUSH
7905: LD_INT 1
7907: PLUS
7908: ARRAY
7909: PPUSH
7910: LD_INT 0
7912: PPUSH
7913: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7917: LD_INT 0
7919: PPUSH
7920: LD_INT 3
7922: PPUSH
7923: LD_EXP 32
7927: PUSH
7928: LD_INT 1
7930: PLUS
7931: PPUSH
7932: CALL_OW 380
// un := CreateHuman ;
7936: LD_ADDR_VAR 0 2
7940: PUSH
7941: CALL_OW 44
7945: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7946: LD_VAR 0 2
7950: PPUSH
7951: LD_VAR 0 5
7955: PPUSH
7956: CALL_OW 52
// end ;
7960: GO 7708
7962: POP
7963: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7964: LD_INT 198
7966: PPUSH
7967: LD_INT 94
7969: PPUSH
7970: LD_INT 8
7972: PPUSH
7973: LD_INT 10
7975: PPUSH
7976: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7980: LD_INT 167
7982: PPUSH
7983: LD_INT 130
7985: PPUSH
7986: LD_INT 8
7988: PPUSH
7989: LD_INT 10
7991: PPUSH
7992: CALL_OW 330
// legion_mines := [ ] ;
7996: LD_ADDR_EXP 33
8000: PUSH
8001: EMPTY
8002: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8003: LD_ADDR_EXP 33
8007: PUSH
8008: LD_INT 176
8010: PPUSH
8011: LD_INT 122
8013: PPUSH
8014: LD_INT 188
8016: PPUSH
8017: LD_INT 126
8019: PPUSH
8020: LD_INT 6
8022: PPUSH
8023: CALL 1562 0 5
8027: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8028: LD_ADDR_EXP 33
8032: PUSH
8033: LD_EXP 33
8037: PUSH
8038: LD_INT 197
8040: PPUSH
8041: LD_INT 91
8043: PPUSH
8044: LD_INT 205
8046: PPUSH
8047: LD_INT 96
8049: PPUSH
8050: LD_INT 4
8052: PPUSH
8053: CALL 1562 0 5
8057: ADD
8058: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8059: LD_ADDR_EXP 33
8063: PUSH
8064: LD_EXP 33
8068: PUSH
8069: LD_INT 184
8071: PPUSH
8072: LD_INT 151
8074: PPUSH
8075: LD_INT 178
8077: PPUSH
8078: LD_INT 130
8080: PPUSH
8081: LD_INT 9
8083: PPUSH
8084: CALL 1562 0 5
8088: ADD
8089: ST_TO_ADDR
// if Difficulty > 1 then
8090: LD_OWVAR 67
8094: PUSH
8095: LD_INT 1
8097: GREATER
8098: IFFALSE 8131
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8100: LD_ADDR_EXP 33
8104: PUSH
8105: LD_EXP 33
8109: PUSH
8110: LD_INT 166
8112: PPUSH
8113: LD_INT 126
8115: PPUSH
8116: LD_INT 181
8118: PPUSH
8119: LD_INT 136
8121: PPUSH
8122: LD_INT 5
8124: PPUSH
8125: CALL 1562 0 5
8129: ADD
8130: ST_TO_ADDR
// p := 1 ;
8131: LD_ADDR_VAR 0 6
8135: PUSH
8136: LD_INT 1
8138: ST_TO_ADDR
// for i = 1 to 24 do
8139: LD_ADDR_VAR 0 3
8143: PUSH
8144: DOUBLE
8145: LD_INT 1
8147: DEC
8148: ST_TO_ADDR
8149: LD_INT 24
8151: PUSH
8152: FOR_TO
8153: IFFALSE 8207
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8155: LD_EXP 33
8159: PUSH
8160: LD_VAR 0 6
8164: ARRAY
8165: PPUSH
8166: LD_EXP 33
8170: PUSH
8171: LD_VAR 0 6
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: ARRAY
8180: PPUSH
8181: LD_INT 8
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 454
// p := p + 2 ;
8191: LD_ADDR_VAR 0 6
8195: PUSH
8196: LD_VAR 0 6
8200: PUSH
8201: LD_INT 2
8203: PLUS
8204: ST_TO_ADDR
// end ;
8205: GO 8152
8207: POP
8208: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8209: LD_ADDR_EXP 35
8213: PUSH
8214: LD_INT 13
8216: PUSH
8217: LD_INT 3
8219: PUSH
8220: LD_INT 2
8222: PUSH
8223: LD_INT 32
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: ST_TO_ADDR
// end ;
8232: LD_VAR 0 1
8236: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8237: LD_INT 22
8239: PUSH
8240: LD_INT 8
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: PPUSH
8247: CALL_OW 69
8251: PUSH
8252: LD_INT 0
8254: GREATER
8255: IFFALSE 10441
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
8272: PPUSH
8273: PPUSH
8274: PPUSH
8275: PPUSH
8276: PPUSH
8277: PPUSH
8278: PPUSH
// begin enable ;
8279: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8280: LD_ADDR_VAR 0 8
8284: PUSH
8285: LD_INT 22
8287: PUSH
8288: LD_INT 8
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 30
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: EMPTY
8302: LIST
8303: LIST
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PPUSH
8309: CALL_OW 69
8313: PUSH
8314: LD_INT 1
8316: ARRAY
8317: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8318: LD_ADDR_VAR 0 9
8322: PUSH
8323: LD_INT 22
8325: PUSH
8326: LD_INT 8
8328: PUSH
8329: EMPTY
8330: LIST
8331: LIST
8332: PUSH
8333: LD_INT 30
8335: PUSH
8336: LD_INT 3
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: PPUSH
8347: CALL_OW 69
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8356: LD_ADDR_VAR 0 10
8360: PUSH
8361: LD_INT 22
8363: PUSH
8364: LD_INT 8
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 2
8373: PUSH
8374: LD_INT 30
8376: PUSH
8377: LD_INT 6
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PUSH
8384: LD_INT 30
8386: PUSH
8387: LD_INT 8
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 69
8407: PUSH
8408: LD_INT 1
8410: ARRAY
8411: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8412: LD_ADDR_VAR 0 11
8416: PUSH
8417: LD_INT 22
8419: PUSH
8420: LD_INT 8
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: LD_INT 30
8429: PUSH
8430: LD_INT 32
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: PPUSH
8441: CALL_OW 69
8445: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8446: LD_ADDR_VAR 0 16
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 25
8463: PUSH
8464: LD_INT 2
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8480: LD_ADDR_VAR 0 15
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8514: LD_ADDR_VAR 0 14
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 3
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8548: LD_ADDR_VAR 0 13
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 4
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// if l_eng then
8582: LD_VAR 0 16
8586: IFFALSE 9001
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8588: LD_ADDR_VAR 0 5
8592: PUSH
8593: LD_INT 22
8595: PUSH
8596: LD_INT 8
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: LD_INT 21
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 69
8621: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8622: LD_VAR 0 5
8626: PPUSH
8627: LD_INT 3
8629: PUSH
8630: LD_INT 24
8632: PUSH
8633: LD_INT 1000
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 72
8648: PUSH
8649: LD_INT 0
8651: GREATER
8652: IFFALSE 8786
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8654: LD_ADDR_VAR 0 3
8658: PUSH
8659: LD_VAR 0 5
8663: PPUSH
8664: LD_INT 3
8666: PUSH
8667: LD_INT 24
8669: PUSH
8670: LD_INT 1000
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PPUSH
8681: CALL_OW 72
8685: ST_TO_ADDR
// for i = 1 to l_eng do
8686: LD_ADDR_VAR 0 2
8690: PUSH
8691: DOUBLE
8692: LD_INT 1
8694: DEC
8695: ST_TO_ADDR
8696: LD_VAR 0 16
8700: PUSH
8701: FOR_TO
8702: IFFALSE 8782
// if IsInUnit ( l_eng [ i ] ) then
8704: LD_VAR 0 16
8708: PUSH
8709: LD_VAR 0 2
8713: ARRAY
8714: PPUSH
8715: CALL_OW 310
8719: IFFALSE 8738
// ComExitBuilding ( l_eng [ i ] ) else
8721: LD_VAR 0 16
8725: PUSH
8726: LD_VAR 0 2
8730: ARRAY
8731: PPUSH
8732: CALL_OW 122
8736: GO 8780
// if not HasTask ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 314
8753: NOT
8754: IFFALSE 8780
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8756: LD_VAR 0 16
8760: PUSH
8761: LD_VAR 0 2
8765: ARRAY
8766: PPUSH
8767: LD_VAR 0 3
8771: PUSH
8772: LD_INT 1
8774: ARRAY
8775: PPUSH
8776: CALL_OW 130
8780: GO 8701
8782: POP
8783: POP
// end else
8784: GO 9001
// begin if legion_blist > 0 then
8786: LD_EXP 34
8790: PUSH
8791: LD_INT 0
8793: GREATER
8794: IFFALSE 8923
// begin for i = 1 to l_eng do
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: DOUBLE
8802: LD_INT 1
8804: DEC
8805: ST_TO_ADDR
8806: LD_VAR 0 16
8810: PUSH
8811: FOR_TO
8812: IFFALSE 8919
// if IsInUnit ( l_eng [ i ] ) then
8814: LD_VAR 0 16
8818: PUSH
8819: LD_VAR 0 2
8823: ARRAY
8824: PPUSH
8825: CALL_OW 310
8829: IFFALSE 8848
// ComExitBuilding ( l_eng [ i ] ) else
8831: LD_VAR 0 16
8835: PUSH
8836: LD_VAR 0 2
8840: ARRAY
8841: PPUSH
8842: CALL_OW 122
8846: GO 8917
// if not HasTask ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 314
8863: NOT
8864: IFFALSE 8917
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8866: LD_VAR 0 16
8870: PUSH
8871: LD_VAR 0 2
8875: ARRAY
8876: PPUSH
8877: LD_EXP 34
8881: PUSH
8882: LD_INT 1
8884: ARRAY
8885: PPUSH
8886: LD_EXP 34
8890: PUSH
8891: LD_INT 2
8893: ARRAY
8894: PPUSH
8895: LD_EXP 34
8899: PUSH
8900: LD_INT 3
8902: ARRAY
8903: PPUSH
8904: LD_EXP 34
8908: PUSH
8909: LD_INT 4
8911: ARRAY
8912: PPUSH
8913: CALL_OW 145
8917: GO 8811
8919: POP
8920: POP
// end else
8921: GO 9001
// for i = 1 to l_eng do
8923: LD_ADDR_VAR 0 2
8927: PUSH
8928: DOUBLE
8929: LD_INT 1
8931: DEC
8932: ST_TO_ADDR
8933: LD_VAR 0 16
8937: PUSH
8938: FOR_TO
8939: IFFALSE 8999
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8941: LD_VAR 0 16
8945: PUSH
8946: LD_VAR 0 2
8950: ARRAY
8951: PPUSH
8952: CALL_OW 310
8956: NOT
8957: PUSH
8958: LD_VAR 0 16
8962: PUSH
8963: LD_VAR 0 2
8967: ARRAY
8968: PPUSH
8969: CALL_OW 314
8973: NOT
8974: AND
8975: IFFALSE 8997
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8977: LD_VAR 0 16
8981: PUSH
8982: LD_VAR 0 2
8986: ARRAY
8987: PPUSH
8988: LD_VAR 0 8
8992: PPUSH
8993: CALL_OW 120
8997: GO 8938
8999: POP
9000: POP
// end ; end ; if l_factory then
9001: LD_VAR 0 9
9005: IFFALSE 9405
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9007: LD_INT 22
9009: PUSH
9010: LD_INT 8
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: LD_INT 33
9019: PUSH
9020: LD_INT 2
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: LD_INT 61
9032: PUSH
9033: EMPTY
9034: LIST
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: LIST
9044: PPUSH
9045: CALL_OW 69
9049: PUSH
9050: LD_INT 0
9052: GREATER
9053: PUSH
9054: LD_INT 22
9056: PUSH
9057: LD_INT 8
9059: PUSH
9060: EMPTY
9061: LIST
9062: LIST
9063: PUSH
9064: LD_INT 34
9066: PUSH
9067: LD_INT 31
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PPUSH
9078: CALL_OW 69
9082: PUSH
9083: LD_INT 0
9085: GREATER
9086: AND
9087: IFFALSE 9207
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9089: LD_INT 22
9091: PUSH
9092: LD_INT 8
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: PUSH
9099: LD_INT 33
9101: PUSH
9102: LD_INT 2
9104: PUSH
9105: EMPTY
9106: LIST
9107: LIST
9108: PUSH
9109: LD_INT 3
9111: PUSH
9112: LD_INT 61
9114: PUSH
9115: EMPTY
9116: LIST
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: LIST
9126: PPUSH
9127: CALL_OW 69
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_INT 22
9138: PUSH
9139: LD_INT 8
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: PUSH
9146: LD_INT 34
9148: PUSH
9149: LD_INT 31
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PPUSH
9160: CALL_OW 69
9164: PUSH
9165: LD_INT 1
9167: PPUSH
9168: LD_INT 22
9170: PUSH
9171: LD_INT 8
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PUSH
9178: LD_INT 34
9180: PUSH
9181: LD_INT 31
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PUSH
9188: EMPTY
9189: LIST
9190: LIST
9191: PPUSH
9192: CALL_OW 69
9196: PPUSH
9197: CALL_OW 12
9201: ARRAY
9202: PPUSH
9203: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9207: LD_EXP 35
9211: PUSH
9212: LD_INT 0
9214: GREATER
9215: PUSH
9216: LD_VAR 0 9
9220: PPUSH
9221: CALL_OW 461
9225: PUSH
9226: LD_INT 2
9228: EQUAL
9229: AND
9230: IFFALSE 9315
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9232: LD_VAR 0 9
9236: PPUSH
9237: LD_EXP 35
9241: PUSH
9242: LD_INT 1
9244: ARRAY
9245: PPUSH
9246: LD_EXP 35
9250: PUSH
9251: LD_INT 2
9253: ARRAY
9254: PPUSH
9255: LD_EXP 35
9259: PUSH
9260: LD_INT 3
9262: ARRAY
9263: PPUSH
9264: LD_EXP 35
9268: PUSH
9269: LD_INT 4
9271: ARRAY
9272: PPUSH
9273: CALL_OW 125
// for i = 1 to 4 do
9277: LD_ADDR_VAR 0 2
9281: PUSH
9282: DOUBLE
9283: LD_INT 1
9285: DEC
9286: ST_TO_ADDR
9287: LD_INT 4
9289: PUSH
9290: FOR_TO
9291: IFFALSE 9313
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9293: LD_ADDR_EXP 35
9297: PUSH
9298: LD_EXP 35
9302: PPUSH
9303: LD_INT 1
9305: PPUSH
9306: CALL_OW 3
9310: ST_TO_ADDR
9311: GO 9290
9313: POP
9314: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9315: LD_VAR 0 11
9319: PPUSH
9320: LD_INT 35
9322: PUSH
9323: LD_INT 0
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PPUSH
9330: CALL_OW 72
9334: PUSH
9335: LD_INT 0
9337: GREATER
9338: PUSH
9339: LD_VAR 0 9
9343: PPUSH
9344: CALL_OW 461
9348: PUSH
9349: LD_INT 2
9351: EQUAL
9352: AND
9353: IFFALSE 9405
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9355: LD_VAR 0 11
9359: PPUSH
9360: LD_INT 35
9362: PUSH
9363: LD_INT 0
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 72
9374: PUSH
9375: LD_INT 1
9377: ARRAY
9378: PPUSH
9379: LD_INT 28
9381: PUSH
9382: LD_INT 27
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PUSH
9389: LD_INT 1
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 12
9399: ARRAY
9400: PPUSH
9401: CALL_OW 148
// end ; if legion_enemy > 0 then
9405: LD_EXP 36
9409: PUSH
9410: LD_INT 0
9412: GREATER
9413: IFFALSE 9993
// begin if tick mod 11 11$00 = 0 then
9415: LD_OWVAR 1
9419: PUSH
9420: LD_INT 23100
9422: MOD
9423: PUSH
9424: LD_INT 0
9426: EQUAL
9427: IFFALSE 9677
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9429: LD_ADDR_EXP 35
9433: PUSH
9434: LD_EXP 35
9438: PUSH
9439: LD_INT 13
9441: PUSH
9442: LD_INT 1
9444: PUSH
9445: LD_INT 2
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: LIST
9452: ADD
9453: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9454: LD_ADDR_EXP 35
9458: PUSH
9459: LD_EXP 35
9463: PUSH
9464: LD_INT 28
9466: PUSH
9467: LD_INT 27
9469: PUSH
9470: LD_INT 29
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: LIST
9477: PUSH
9478: LD_INT 1
9480: PPUSH
9481: LD_INT 3
9483: PPUSH
9484: CALL_OW 12
9488: ARRAY
9489: ADD
9490: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9491: LD_ADDR_EXP 35
9495: PUSH
9496: LD_EXP 35
9500: PUSH
9501: LD_INT 13
9503: PUSH
9504: LD_INT 1
9506: PUSH
9507: LD_INT 2
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: ADD
9515: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9516: LD_ADDR_EXP 35
9520: PUSH
9521: LD_EXP 35
9525: PUSH
9526: LD_INT 28
9528: PUSH
9529: LD_INT 27
9531: PUSH
9532: LD_INT 29
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 1
9542: PPUSH
9543: LD_INT 3
9545: PPUSH
9546: CALL_OW 12
9550: ARRAY
9551: ADD
9552: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9553: LD_ADDR_EXP 35
9557: PUSH
9558: LD_EXP 35
9562: PUSH
9563: LD_INT 13
9565: PUSH
9566: LD_INT 1
9568: PUSH
9569: LD_INT 2
9571: PUSH
9572: EMPTY
9573: LIST
9574: LIST
9575: LIST
9576: ADD
9577: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9578: LD_ADDR_EXP 35
9582: PUSH
9583: LD_EXP 35
9587: PUSH
9588: LD_INT 28
9590: PUSH
9591: LD_INT 27
9593: PUSH
9594: LD_INT 29
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 3
9607: PPUSH
9608: CALL_OW 12
9612: ARRAY
9613: ADD
9614: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9615: LD_ADDR_EXP 35
9619: PUSH
9620: LD_EXP 35
9624: PUSH
9625: LD_INT 13
9627: PUSH
9628: LD_INT 1
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: ADD
9639: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9640: LD_ADDR_EXP 35
9644: PUSH
9645: LD_EXP 35
9649: PUSH
9650: LD_INT 28
9652: PUSH
9653: LD_INT 27
9655: PUSH
9656: LD_INT 29
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 1
9666: PPUSH
9667: LD_INT 3
9669: PPUSH
9670: CALL_OW 12
9674: ARRAY
9675: ADD
9676: ST_TO_ADDR
// end ; if legion_force >= 7 then
9677: LD_EXP 31
9681: PUSH
9682: LD_INT 7
9684: GREATEREQUAL
9685: IFFALSE 9868
// begin for i = 1 to legion_force do
9687: LD_ADDR_VAR 0 2
9691: PUSH
9692: DOUBLE
9693: LD_INT 1
9695: DEC
9696: ST_TO_ADDR
9697: LD_EXP 31
9701: PUSH
9702: FOR_TO
9703: IFFALSE 9866
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9705: LD_EXP 31
9709: PUSH
9710: LD_VAR 0 2
9714: ARRAY
9715: PPUSH
9716: CALL_OW 314
9720: NOT
9721: PUSH
9722: LD_EXP 31
9726: PUSH
9727: LD_VAR 0 2
9731: ARRAY
9732: PPUSH
9733: CALL_OW 110
9737: PUSH
9738: LD_INT 11
9740: NONEQUAL
9741: AND
9742: IFFALSE 9864
// begin case legion_enemy of 1 :
9744: LD_EXP 36
9748: PUSH
9749: LD_INT 1
9751: DOUBLE
9752: EQUAL
9753: IFTRUE 9757
9755: GO 9781
9757: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9758: LD_EXP 31
9762: PUSH
9763: LD_VAR 0 2
9767: ARRAY
9768: PPUSH
9769: LD_INT 142
9771: PPUSH
9772: LD_INT 144
9774: PPUSH
9775: CALL_OW 111
9779: GO 9846
9781: LD_INT 2
9783: DOUBLE
9784: EQUAL
9785: IFTRUE 9789
9787: GO 9813
9789: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9790: LD_EXP 31
9794: PUSH
9795: LD_VAR 0 2
9799: ARRAY
9800: PPUSH
9801: LD_INT 101
9803: PPUSH
9804: LD_INT 34
9806: PPUSH
9807: CALL_OW 111
9811: GO 9846
9813: LD_INT 7
9815: DOUBLE
9816: EQUAL
9817: IFTRUE 9821
9819: GO 9845
9821: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9822: LD_EXP 31
9826: PUSH
9827: LD_VAR 0 2
9831: ARRAY
9832: PPUSH
9833: LD_INT 173
9835: PPUSH
9836: LD_INT 127
9838: PPUSH
9839: CALL_OW 111
9843: GO 9846
9845: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9846: LD_EXP 31
9850: PUSH
9851: LD_VAR 0 2
9855: ARRAY
9856: PPUSH
9857: LD_INT 11
9859: PPUSH
9860: CALL_OW 109
// end ; end ;
9864: GO 9702
9866: POP
9867: POP
// end ; if legion_force then
9868: LD_EXP 31
9872: IFFALSE 9993
// begin tmp := legion_force ;
9874: LD_ADDR_VAR 0 3
9878: PUSH
9879: LD_EXP 31
9883: ST_TO_ADDR
// for i = 1 to tmp do
9884: LD_ADDR_VAR 0 2
9888: PUSH
9889: DOUBLE
9890: LD_INT 1
9892: DEC
9893: ST_TO_ADDR
9894: LD_VAR 0 3
9898: PUSH
9899: FOR_TO
9900: IFFALSE 9991
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9902: LD_VAR 0 3
9906: PUSH
9907: LD_VAR 0 2
9911: ARRAY
9912: PPUSH
9913: CALL_OW 314
9917: NOT
9918: PUSH
9919: LD_EXP 31
9923: PUSH
9924: LD_VAR 0 2
9928: ARRAY
9929: PPUSH
9930: CALL_OW 110
9934: PUSH
9935: LD_INT 11
9937: EQUAL
9938: AND
9939: IFFALSE 9989
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9941: LD_VAR 0 3
9945: PUSH
9946: LD_VAR 0 2
9950: ARRAY
9951: PPUSH
9952: LD_INT 22
9954: PUSH
9955: LD_EXP 36
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PPUSH
9964: CALL_OW 69
9968: PPUSH
9969: LD_VAR 0 3
9973: PUSH
9974: LD_VAR 0 2
9978: ARRAY
9979: PPUSH
9980: CALL_OW 74
9984: PPUSH
9985: CALL_OW 115
9989: GO 9899
9991: POP
9992: POP
// end ; end ; p := 1 ;
9993: LD_ADDR_VAR 0 6
9997: PUSH
9998: LD_INT 1
10000: ST_TO_ADDR
// for i = 1 to 24 do
10001: LD_ADDR_VAR 0 2
10005: PUSH
10006: DOUBLE
10007: LD_INT 1
10009: DEC
10010: ST_TO_ADDR
10011: LD_INT 24
10013: PUSH
10014: FOR_TO
10015: IFFALSE 10145
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10017: LD_EXP 33
10021: PUSH
10022: LD_VAR 0 6
10026: ARRAY
10027: PPUSH
10028: LD_EXP 33
10032: PUSH
10033: LD_VAR 0 6
10037: PUSH
10038: LD_INT 1
10040: PLUS
10041: ARRAY
10042: PPUSH
10043: CALL_OW 428
10047: PUSH
10048: LD_INT 0
10050: GREATER
10051: IFFALSE 10129
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10053: LD_EXP 33
10057: PUSH
10058: LD_VAR 0 6
10062: ARRAY
10063: PPUSH
10064: LD_EXP 33
10068: PUSH
10069: LD_VAR 0 6
10073: PUSH
10074: LD_INT 1
10076: PLUS
10077: ARRAY
10078: PPUSH
10079: CALL_OW 428
10083: PPUSH
10084: CALL_OW 255
10088: PUSH
10089: LD_EXP 36
10093: EQUAL
10094: IFFALSE 10129
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10096: LD_EXP 33
10100: PUSH
10101: LD_VAR 0 6
10105: ARRAY
10106: PPUSH
10107: LD_EXP 33
10111: PUSH
10112: LD_VAR 0 6
10116: PUSH
10117: LD_INT 1
10119: PLUS
10120: ARRAY
10121: PPUSH
10122: LD_INT 8
10124: PPUSH
10125: CALL_OW 456
// p := p + 2 ;
10129: LD_ADDR_VAR 0 6
10133: PUSH
10134: LD_VAR 0 6
10138: PUSH
10139: LD_INT 2
10141: PLUS
10142: ST_TO_ADDR
// end ;
10143: GO 10014
10145: POP
10146: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10147: LD_INT 22
10149: PUSH
10150: LD_INT 8
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: LD_INT 34
10159: PUSH
10160: LD_INT 32
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PPUSH
10171: CALL_OW 69
10175: IFFALSE 10289
// begin if l_cargo = false then
10177: LD_VAR 0 17
10181: PUSH
10182: LD_INT 0
10184: EQUAL
10185: IFFALSE 10221
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10187: LD_ADDR_VAR 0 17
10191: PUSH
10192: LD_INT 22
10194: PUSH
10195: LD_INT 8
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 34
10204: PUSH
10205: LD_INT 32
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PUSH
10212: EMPTY
10213: LIST
10214: LIST
10215: PPUSH
10216: CALL_OW 69
10220: ST_TO_ADDR
// if l_cargo then
10221: LD_VAR 0 17
10225: IFFALSE 10289
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10227: LD_ADDR_VAR 0 7
10231: PUSH
10232: LD_INT 14
10234: PPUSH
10235: CALL_OW 435
10239: ST_TO_ADDR
// if cr > 0 then
10240: LD_VAR 0 7
10244: PUSH
10245: LD_INT 0
10247: GREATER
10248: IFFALSE 10289
// if not HasTask ( l_cargo ) then
10250: LD_VAR 0 17
10254: PPUSH
10255: CALL_OW 314
10259: NOT
10260: IFFALSE 10289
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10262: LD_VAR 0 17
10266: PPUSH
10267: LD_VAR 0 7
10271: PUSH
10272: LD_INT 1
10274: ARRAY
10275: PPUSH
10276: LD_VAR 0 7
10280: PUSH
10281: LD_INT 2
10283: ARRAY
10284: PPUSH
10285: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10289: LD_OWVAR 1
10293: PUSH
10294: LD_INT 52500
10296: PUSH
10297: LD_INT 46200
10299: PUSH
10300: LD_INT 42000
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: LD_OWVAR 67
10312: ARRAY
10313: EQUAL
10314: PUSH
10315: LD_INT 1
10317: PPUSH
10318: CALL_OW 469
10322: PUSH
10323: LD_INT 1
10325: ARRAY
10326: PUSH
10327: LD_INT 112
10329: EQUAL
10330: AND
10331: PUSH
10332: LD_INT 1
10334: PPUSH
10335: CALL_OW 469
10339: PUSH
10340: LD_INT 2
10342: ARRAY
10343: PUSH
10344: LD_INT 67
10346: EQUAL
10347: AND
10348: IFFALSE 10441
// begin un := l_eng [ 1 ] ;
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_VAR 0 16
10359: PUSH
10360: LD_INT 1
10362: ARRAY
10363: ST_TO_ADDR
// if IsInUnit ( un ) then
10364: LD_VAR 0 1
10368: PPUSH
10369: CALL_OW 310
10373: IFFALSE 10384
// ComExitBuilding ( un ) ;
10375: LD_VAR 0 1
10379: PPUSH
10380: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 1
10391: PPUSH
10392: CALL_OW 469
10396: PUSH
10397: LD_INT 1
10399: ARRAY
10400: PPUSH
10401: LD_INT 1
10403: PPUSH
10404: CALL_OW 469
10408: PUSH
10409: LD_INT 2
10411: ARRAY
10412: PPUSH
10413: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10417: LD_VAR 0 1
10421: PPUSH
10422: LD_INT 207
10424: PPUSH
10425: LD_INT 123
10427: PPUSH
10428: CALL_OW 171
// AddComUnload ( un ) ;
10432: LD_VAR 0 1
10436: PPUSH
10437: CALL_OW 219
// end ; end ;
10441: PPOPN 17
10443: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10444: LD_OWVAR 67
10448: PUSH
10449: LD_INT 1
10451: GREATER
10452: IFFALSE 10657
10454: GO 10456
10456: DISABLE
10457: LD_INT 0
10459: PPUSH
10460: PPUSH
10461: PPUSH
10462: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10463: LD_INT 35
10465: PPUSH
10466: LD_INT 12635
10468: PPUSH
10469: CALL_OW 12
10473: PPUSH
10474: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10478: LD_ADDR_VAR 0 2
10482: PUSH
10483: LD_INT 22
10485: PUSH
10486: LD_INT 8
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PUSH
10493: LD_INT 25
10495: PUSH
10496: LD_INT 4
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL_OW 69
10511: ST_TO_ADDR
// p := 1 ;
10512: LD_ADDR_VAR 0 4
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10520: LD_ADDR_VAR 0 3
10524: PUSH
10525: LD_INT 116
10527: PUSH
10528: LD_INT 139
10530: PUSH
10531: LD_INT 69
10533: PUSH
10534: LD_INT 13
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: ST_TO_ADDR
// for i = 1 to 2 do
10543: LD_ADDR_VAR 0 1
10547: PUSH
10548: DOUBLE
10549: LD_INT 1
10551: DEC
10552: ST_TO_ADDR
10553: LD_INT 2
10555: PUSH
10556: FOR_TO
10557: IFFALSE 10655
// begin if IsInUnit ( sci [ i ] ) then
10559: LD_VAR 0 2
10563: PUSH
10564: LD_VAR 0 1
10568: ARRAY
10569: PPUSH
10570: CALL_OW 310
10574: IFFALSE 10591
// ComExitBuilding ( sci [ i ] ) ;
10576: LD_VAR 0 2
10580: PUSH
10581: LD_VAR 0 1
10585: ARRAY
10586: PPUSH
10587: CALL_OW 122
// Wait ( 0 0$03 ) ;
10591: LD_INT 105
10593: PPUSH
10594: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10598: LD_VAR 0 2
10602: PUSH
10603: LD_VAR 0 1
10607: ARRAY
10608: PPUSH
10609: LD_VAR 0 3
10613: PUSH
10614: LD_VAR 0 4
10618: ARRAY
10619: PPUSH
10620: LD_VAR 0 3
10624: PUSH
10625: LD_VAR 0 4
10629: PUSH
10630: LD_INT 1
10632: PLUS
10633: ARRAY
10634: PPUSH
10635: CALL_OW 158
// p := p + 2 ;
10639: LD_ADDR_VAR 0 4
10643: PUSH
10644: LD_VAR 0 4
10648: PUSH
10649: LD_INT 2
10651: PLUS
10652: ST_TO_ADDR
// end ;
10653: GO 10556
10655: POP
10656: POP
// end ;
10657: PPOPN 4
10659: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10660: LD_INT 14
10662: PPUSH
10663: CALL_OW 435
10667: PUSH
10668: LD_INT 20
10670: LESS
10671: IFFALSE 10698
10673: GO 10675
10675: DISABLE
// begin enable ;
10676: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10677: LD_INT 1
10679: PPUSH
10680: LD_INT 5
10682: PPUSH
10683: CALL_OW 12
10687: PPUSH
10688: LD_INT 14
10690: PPUSH
10691: LD_INT 1
10693: PPUSH
10694: CALL_OW 55
// end ; end_of_file
10698: END
// export function Action ; var un , gamemode ; begin
10699: LD_INT 0
10701: PPUSH
10702: PPUSH
10703: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10704: LD_ADDR_OWVAR 67
10708: PUSH
10709: LD_INT 0
10711: PPUSH
10712: CALL_OW 426
10716: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10717: LD_ADDR_VAR 0 3
10721: PUSH
10722: LD_INT 1
10724: PPUSH
10725: CALL_OW 426
10729: ST_TO_ADDR
// if gamemode = 1 then
10730: LD_VAR 0 3
10734: PUSH
10735: LD_INT 1
10737: EQUAL
10738: IFFALSE 10762
// begin your_side := 1 ;
10740: LD_ADDR_OWVAR 2
10744: PUSH
10745: LD_INT 1
10747: ST_TO_ADDR
// legion_enemy := 1 ;
10748: LD_ADDR_EXP 36
10752: PUSH
10753: LD_INT 1
10755: ST_TO_ADDR
// PrepareAmerican ;
10756: CALL 221 0 0
// end else
10760: GO 10814
// if gamemode = 2 then
10762: LD_VAR 0 3
10766: PUSH
10767: LD_INT 2
10769: EQUAL
10770: IFFALSE 10794
// begin your_side := 2 ;
10772: LD_ADDR_OWVAR 2
10776: PUSH
10777: LD_INT 2
10779: ST_TO_ADDR
// legion_enemy := 2 ;
10780: LD_ADDR_EXP 36
10784: PUSH
10785: LD_INT 2
10787: ST_TO_ADDR
// PrepareArabian ;
10788: CALL 17411 0 0
// end else
10792: GO 10814
// begin your_side := 7 ;
10794: LD_ADDR_OWVAR 2
10798: PUSH
10799: LD_INT 7
10801: ST_TO_ADDR
// legion_enemy := 7 ;
10802: LD_ADDR_EXP 36
10806: PUSH
10807: LD_INT 7
10809: ST_TO_ADDR
// PrepareAlliance ;
10810: CALL 14822 0 0
// end ; if your_side = 1 then
10814: LD_OWVAR 2
10818: PUSH
10819: LD_INT 1
10821: EQUAL
10822: IFFALSE 11176
// begin case Query ( QVul4 ) of 1 :
10824: LD_STRING QVul4
10826: PPUSH
10827: CALL_OW 97
10831: PUSH
10832: LD_INT 1
10834: DOUBLE
10835: EQUAL
10836: IFTRUE 10840
10838: GO 10843
10840: POP
// ; end ;
10841: GO 10844
10843: POP
// InGameOn ;
10844: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10848: LD_INT 8
10850: PPUSH
10851: LD_INT 5
10853: PPUSH
10854: CALL_OW 86
// uc_side := 4 ;
10858: LD_ADDR_OWVAR 20
10862: PUSH
10863: LD_INT 4
10865: ST_TO_ADDR
// uc_nation := 1 ;
10866: LD_ADDR_OWVAR 21
10870: PUSH
10871: LD_INT 1
10873: ST_TO_ADDR
// hc_importance := 0 ;
10874: LD_ADDR_OWVAR 32
10878: PUSH
10879: LD_INT 0
10881: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10882: LD_INT 1
10884: PPUSH
10885: LD_INT 3
10887: PPUSH
10888: LD_EXP 21
10892: PPUSH
10893: CALL_OW 380
// un := CreateHuman ;
10897: LD_ADDR_VAR 0 2
10901: PUSH
10902: CALL_OW 44
10906: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_INT 12
10914: PPUSH
10915: LD_INT 9
10917: PPUSH
10918: LD_INT 0
10920: PPUSH
10921: CALL_OW 48
// hc_name := Stuart Carey ;
10925: LD_ADDR_OWVAR 26
10929: PUSH
10930: LD_STRING Stuart Carey
10932: ST_TO_ADDR
// hc_class := 1 ;
10933: LD_ADDR_OWVAR 28
10937: PUSH
10938: LD_INT 1
10940: ST_TO_ADDR
// hc_gallery := vulcano ;
10941: LD_ADDR_OWVAR 33
10945: PUSH
10946: LD_STRING vulcano
10948: ST_TO_ADDR
// hc_face_number := 1 ;
10949: LD_ADDR_OWVAR 34
10953: PUSH
10954: LD_INT 1
10956: ST_TO_ADDR
// us_guy := CreateHuman ;
10957: LD_ADDR_EXP 22
10961: PUSH
10962: CALL_OW 44
10966: ST_TO_ADDR
// hc_gallery :=  ;
10967: LD_ADDR_OWVAR 33
10971: PUSH
10972: LD_STRING 
10974: ST_TO_ADDR
// hc_name :=  ;
10975: LD_ADDR_OWVAR 26
10979: PUSH
10980: LD_STRING 
10982: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
10983: LD_VAR 0 2
10987: PPUSH
10988: LD_EXP 19
10992: PPUSH
10993: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
10997: LD_EXP 19
11001: PPUSH
11002: LD_VAR 0 2
11006: PPUSH
11007: CALL_OW 119
// Say ( un , VD-un1 ) ;
11011: LD_VAR 0 2
11015: PPUSH
11016: LD_STRING VD-un1
11018: PPUSH
11019: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11023: LD_EXP 19
11027: PPUSH
11028: LD_STRING VDc-1
11030: PPUSH
11031: CALL_OW 88
// Say ( un , VD-un2 ) ;
11035: LD_VAR 0 2
11039: PPUSH
11040: LD_STRING VD-un2
11042: PPUSH
11043: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11047: LD_EXP 19
11051: PPUSH
11052: LD_STRING VDc-2
11054: PPUSH
11055: CALL_OW 88
// Say ( un , VD-un3 ) ;
11059: LD_VAR 0 2
11063: PPUSH
11064: LD_STRING VD-un3
11066: PPUSH
11067: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11071: LD_INT 7
11073: PPUSH
11074: CALL_OW 67
// Say ( un , VD-un4 ) ;
11078: LD_VAR 0 2
11082: PPUSH
11083: LD_STRING VD-un4
11085: PPUSH
11086: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11090: LD_VAR 0 2
11094: PPUSH
11095: LD_INT 2
11097: PPUSH
11098: LD_INT 2
11100: PPUSH
11101: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11105: LD_EXP 19
11109: PPUSH
11110: LD_STRING VDc-3
11112: PPUSH
11113: CALL_OW 88
// InGameOff ;
11117: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11121: LD_STRING CVulc1
11123: PPUSH
11124: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11128: LD_INT 35
11130: PPUSH
11131: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11135: LD_VAR 0 2
11139: PPUSH
11140: CALL_OW 250
11144: PUSH
11145: LD_INT 2
11147: EQUAL
11148: PUSH
11149: LD_VAR 0 2
11153: PPUSH
11154: CALL_OW 251
11158: PUSH
11159: LD_INT 2
11161: EQUAL
11162: AND
11163: IFFALSE 11128
// RemoveUnit ( un ) ;
11165: LD_VAR 0 2
11169: PPUSH
11170: CALL_OW 64
// end else
11174: GO 11468
// if your_side = 2 then
11176: LD_OWVAR 2
11180: PUSH
11181: LD_INT 2
11183: EQUAL
11184: IFFALSE 11356
// begin CenterNowOnUnits ( player_commander ) ;
11186: LD_EXP 10
11190: PPUSH
11191: CALL_OW 87
// InGameOn ;
11195: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11199: LD_EXP 51
11203: PPUSH
11204: LD_STRING VSd-1
11206: PPUSH
11207: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11211: LD_INT 22
11213: PUSH
11214: LD_INT 2
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: LD_INT 21
11223: PUSH
11224: LD_INT 1
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: PUSH
11231: LD_INT 26
11233: PUSH
11234: LD_INT 1
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: LIST
11245: PUSH
11246: EMPTY
11247: LIST
11248: PPUSH
11249: CALL_OW 69
11253: PUSH
11254: LD_INT 2
11256: ARRAY
11257: PPUSH
11258: LD_STRING VAd-1
11260: PPUSH
11261: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11265: LD_EXP 51
11269: PPUSH
11270: LD_STRING VSd-2
11272: PPUSH
11273: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11277: LD_INT 22
11279: PUSH
11280: LD_INT 2
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 21
11289: PUSH
11290: LD_INT 1
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 26
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: LIST
11311: PUSH
11312: EMPTY
11313: LIST
11314: PPUSH
11315: CALL_OW 69
11319: PUSH
11320: LD_INT 2
11322: ARRAY
11323: PPUSH
11324: LD_STRING VAd-2
11326: PPUSH
11327: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11331: LD_EXP 51
11335: PPUSH
11336: LD_STRING VSd-3
11338: PPUSH
11339: CALL_OW 88
// InGameOff ;
11343: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11347: LD_STRING CVulc5
11349: PPUSH
11350: CALL_OW 337
// end else
11354: GO 11468
// if your_side = 7 then
11356: LD_OWVAR 2
11360: PUSH
11361: LD_INT 7
11363: EQUAL
11364: IFFALSE 11468
// begin CenterNowOnUnits ( al_commander ) ;
11366: LD_EXP 37
11370: PPUSH
11371: CALL_OW 87
// InGameOn ;
11375: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11379: LD_EXP 37
11383: PPUSH
11384: LD_STRING VPd-1
11386: PPUSH
11387: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11391: LD_INT 22
11393: PUSH
11394: LD_INT 7
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: LD_INT 21
11403: PUSH
11404: LD_INT 1
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 26
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: PUSH
11426: EMPTY
11427: LIST
11428: PPUSH
11429: CALL_OW 69
11433: PUSH
11434: LD_INT 2
11436: ARRAY
11437: PPUSH
11438: LD_STRING VPpd-1
11440: PPUSH
11441: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11445: LD_EXP 37
11449: PPUSH
11450: LD_STRING VPd-2
11452: PPUSH
11453: CALL_OW 88
// InGameOff ;
11457: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11461: LD_STRING CVulc7
11463: PPUSH
11464: CALL_OW 337
// end ; end ;
11468: LD_VAR 0 1
11472: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11473: LD_INT 22
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: LD_INT 30
11485: PUSH
11486: LD_INT 3
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 69
11501: IFFALSE 11545
11503: GO 11505
11505: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11506: LD_STRING CVulc6
11508: PPUSH
11509: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11513: LD_INT 52500
11515: PUSH
11516: LD_INT 47250
11518: PUSH
11519: LD_INT 42000
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: PUSH
11527: LD_OWVAR 67
11531: ARRAY
11532: PPUSH
11533: CALL_OW 67
// ru_can_attack := true ;
11537: LD_ADDR_EXP 3
11541: PUSH
11542: LD_INT 1
11544: ST_TO_ADDR
// end ;
11545: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11546: LD_INT 50
11548: PPUSH
11549: CALL_OW 255
11553: PUSH
11554: LD_INT 1
11556: EQUAL
11557: PUSH
11558: LD_INT 22
11560: PUSH
11561: LD_INT 1
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: PUSH
11568: LD_INT 2
11570: PUSH
11571: LD_INT 30
11573: PUSH
11574: LD_INT 3
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: LD_INT 30
11583: PUSH
11584: LD_INT 1
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 69
11604: OR
11605: IFFALSE 11782
11607: GO 11609
11609: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11610: LD_STRING CVulc2
11612: PPUSH
11613: CALL_OW 337
// DialogueOn ;
11617: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11621: LD_INT 10
11623: PPUSH
11624: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11628: LD_INT 22
11630: PUSH
11631: LD_INT 1
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_INT 25
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: PUSH
11648: EMPTY
11649: LIST
11650: LIST
11651: PPUSH
11652: CALL_OW 69
11656: PUSH
11657: LD_EXP 19
11661: DIFF
11662: PUSH
11663: LD_INT 1
11665: ARRAY
11666: PPUSH
11667: LD_STRING VDb-1
11669: PPUSH
11670: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11674: LD_INT 10
11676: PPUSH
11677: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11681: LD_INT 22
11683: PUSH
11684: LD_INT 1
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 25
11693: PUSH
11694: LD_INT 4
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PPUSH
11705: CALL_OW 69
11709: PUSH
11710: LD_EXP 19
11714: DIFF
11715: PUSH
11716: LD_INT 1
11718: ARRAY
11719: PPUSH
11720: LD_STRING VDb-2
11722: PPUSH
11723: CALL_OW 88
// DWait ( 0 0$01 ) ;
11727: LD_INT 35
11729: PPUSH
11730: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11734: LD_EXP 19
11738: PPUSH
11739: LD_STRING VDb-com1
11741: PPUSH
11742: CALL_OW 88
// DialogueOff ;
11746: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11750: LD_INT 44100
11752: PUSH
11753: LD_INT 36750
11755: PUSH
11756: LD_INT 31500
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: LIST
11763: PUSH
11764: LD_OWVAR 67
11768: ARRAY
11769: PPUSH
11770: CALL_OW 67
// ru_can_attack := true ;
11774: LD_ADDR_EXP 3
11778: PUSH
11779: LD_INT 1
11781: ST_TO_ADDR
// end ;
11782: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11783: LD_INT 22
11785: PUSH
11786: LD_INT 7
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: LD_INT 30
11795: PUSH
11796: LD_INT 3
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PUSH
11803: EMPTY
11804: LIST
11805: LIST
11806: PPUSH
11807: CALL_OW 69
11811: IFFALSE 11848
11813: GO 11815
11815: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11816: LD_INT 42000
11818: PUSH
11819: LD_INT 34650
11821: PUSH
11822: LD_INT 29400
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: LIST
11829: PUSH
11830: LD_OWVAR 67
11834: ARRAY
11835: PPUSH
11836: CALL_OW 67
// ru_can_attack := true ;
11840: LD_ADDR_EXP 3
11844: PUSH
11845: LD_INT 1
11847: ST_TO_ADDR
// end ;
11848: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11849: LD_INT 58
11851: PPUSH
11852: CALL_OW 255
11856: PUSH
11857: LD_INT 1
11859: EQUAL
11860: IFFALSE 11992
11862: GO 11864
11864: DISABLE
// begin DialogueOn ;
11865: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11869: LD_INT 22
11871: PUSH
11872: LD_INT 1
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 25
11881: PUSH
11882: LD_INT 2
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PPUSH
11893: CALL_OW 69
11897: PUSH
11898: LD_INT 1
11900: ARRAY
11901: PPUSH
11902: LD_STRING VDe-1
11904: PPUSH
11905: CALL_OW 88
// case Query ( SibNote ) of 1 :
11909: LD_STRING SibNote
11911: PPUSH
11912: CALL_OW 97
11916: PUSH
11917: LD_INT 1
11919: DOUBLE
11920: EQUAL
11921: IFTRUE 11925
11923: GO 11928
11925: POP
// ; end ;
11926: GO 11929
11928: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11929: LD_INT 22
11931: PUSH
11932: LD_INT 1
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 25
11941: PUSH
11942: LD_INT 2
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: PPUSH
11953: CALL_OW 69
11957: PUSH
11958: LD_INT 1
11960: ARRAY
11961: PPUSH
11962: LD_STRING VDe-2
11964: PPUSH
11965: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
11969: LD_EXP 19
11973: PPUSH
11974: LD_STRING VDc-4
11976: PPUSH
11977: CALL_OW 88
// DialogueOff ;
11981: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
11985: LD_STRING CVulc3
11987: PPUSH
11988: CALL_OW 337
// end ;
11992: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
11993: LD_OWVAR 2
11997: PUSH
11998: LD_INT 1
12000: EQUAL
12001: PUSH
12002: LD_INT 22
12004: PUSH
12005: LD_INT 1
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 30
12014: PUSH
12015: LD_INT 3
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PPUSH
12026: CALL_OW 69
12030: PUSH
12031: LD_INT 0
12033: GREATER
12034: AND
12035: IFFALSE 12469
12037: GO 12039
12039: DISABLE
12040: LD_INT 0
12042: PPUSH
12043: PPUSH
12044: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12045: LD_INT 245
12047: PPUSH
12048: LD_INT 1295
12050: PPUSH
12051: CALL_OW 12
12055: PPUSH
12056: CALL_OW 67
// DialogueOn ;
12060: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12064: LD_EXP 22
12068: PPUSH
12069: LD_STRING VDG-1
12071: PPUSH
12072: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12076: LD_EXP 19
12080: PPUSH
12081: LD_STRING VDc-5
12083: PPUSH
12084: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12088: LD_EXP 22
12092: PPUSH
12093: LD_STRING VDG-2
12095: PPUSH
12096: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12100: LD_EXP 19
12104: PPUSH
12105: LD_STRING VDc-6
12107: PPUSH
12108: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12112: LD_EXP 22
12116: PPUSH
12117: LD_STRING VDG-3
12119: PPUSH
12120: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12124: LD_EXP 19
12128: PPUSH
12129: LD_STRING VDc-7
12131: PPUSH
12132: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12136: LD_EXP 22
12140: PPUSH
12141: LD_STRING VDG-4
12143: PPUSH
12144: CALL_OW 94
// DialogueOff ;
12148: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12152: LD_STRING CVulc4
12154: PPUSH
12155: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12159: LD_INT 18900
12161: PUSH
12162: LD_INT 21000
12164: PUSH
12165: LD_INT 23100
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: LIST
12172: PUSH
12173: LD_OWVAR 67
12177: ARRAY
12178: PPUSH
12179: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12183: LD_ADDR_VAR 0 1
12187: PUSH
12188: DOUBLE
12189: LD_INT 1
12191: DEC
12192: ST_TO_ADDR
12193: LD_INT 4
12195: PUSH
12196: LD_INT 5
12198: PUSH
12199: LD_INT 6
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: PUSH
12207: LD_OWVAR 67
12211: ARRAY
12212: PUSH
12213: FOR_TO
12214: IFFALSE 12458
// begin uc_side := 1 ;
12216: LD_ADDR_OWVAR 20
12220: PUSH
12221: LD_INT 1
12223: ST_TO_ADDR
// uc_nation := 1 ;
12224: LD_ADDR_OWVAR 21
12228: PUSH
12229: LD_INT 1
12231: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12232: LD_INT 0
12234: PPUSH
12235: LD_INT 1
12237: PPUSH
12238: LD_INT 4
12240: PPUSH
12241: CALL_OW 12
12245: PPUSH
12246: LD_EXP 21
12250: PPUSH
12251: CALL_OW 380
// un := CreateHuman ;
12255: LD_ADDR_VAR 0 2
12259: PUSH
12260: CALL_OW 44
12264: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12265: LD_VAR 0 2
12269: PPUSH
12270: LD_INT 2
12272: PPUSH
12273: CALL_OW 233
// if GetClass ( un ) = 3 then
12277: LD_VAR 0 2
12281: PPUSH
12282: CALL_OW 257
12286: PUSH
12287: LD_INT 3
12289: EQUAL
12290: IFFALSE 12441
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12292: LD_ADDR_OWVAR 37
12296: PUSH
12297: LD_INT 2
12299: PUSH
12300: LD_INT 3
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: PUSH
12307: LD_VAR 0 1
12311: PUSH
12312: LD_INT 2
12314: MOD
12315: ARRAY
12316: ST_TO_ADDR
// vc_engine := engine_combustion ;
12317: LD_ADDR_OWVAR 39
12321: PUSH
12322: LD_INT 1
12324: ST_TO_ADDR
// vc_control := control_manual ;
12325: LD_ADDR_OWVAR 38
12329: PUSH
12330: LD_INT 1
12332: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12333: LD_ADDR_OWVAR 40
12337: PUSH
12338: LD_INT 9
12340: PUSH
12341: LD_INT 9
12343: PUSH
12344: LD_INT 5
12346: PUSH
12347: LD_INT 11
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: LD_INT 1
12358: PPUSH
12359: LD_INT 4
12361: PPUSH
12362: CALL_OW 12
12366: ARRAY
12367: ST_TO_ADDR
// veh := CreateVehicle ;
12368: LD_ADDR_VAR 0 3
12372: PUSH
12373: CALL_OW 45
12377: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12378: LD_VAR 0 3
12382: PPUSH
12383: LD_INT 2
12385: PPUSH
12386: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12390: LD_VAR 0 3
12394: PPUSH
12395: LD_INT 77
12397: PPUSH
12398: LD_INT 88
12400: PPUSH
12401: CALL_OW 12
12405: PPUSH
12406: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12410: LD_VAR 0 3
12414: PPUSH
12415: LD_INT 1
12417: PPUSH
12418: LD_INT 0
12420: PPUSH
12421: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12425: LD_VAR 0 2
12429: PPUSH
12430: LD_VAR 0 3
12434: PPUSH
12435: CALL_OW 52
// end else
12439: GO 12456
// PlaceUnitArea ( un , start_north , false ) ;
12441: LD_VAR 0 2
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: LD_INT 0
12451: PPUSH
12452: CALL_OW 49
// end ;
12456: GO 12213
12458: POP
12459: POP
// CenterNowOnUnits ( un ) ;
12460: LD_VAR 0 2
12464: PPUSH
12465: CALL_OW 87
// end ;
12469: PPOPN 3
12471: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12472: LD_INT 21
12474: PPUSH
12475: LD_INT 22
12477: PUSH
12478: LD_OWVAR 2
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: PPUSH
12487: CALL_OW 70
12491: IFFALSE 12713
12493: GO 12495
12495: DISABLE
12496: LD_INT 0
12498: PPUSH
12499: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12500: LD_ADDR_VAR 0 2
12504: PUSH
12505: LD_INT 22
12507: PUSH
12508: LD_OWVAR 2
12512: PUSH
12513: EMPTY
12514: LIST
12515: LIST
12516: PUSH
12517: LD_INT 2
12519: PUSH
12520: LD_INT 25
12522: PUSH
12523: LD_INT 1
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: LD_INT 25
12532: PUSH
12533: LD_INT 2
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PUSH
12540: LD_INT 25
12542: PUSH
12543: LD_INT 3
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 25
12552: PUSH
12553: LD_INT 4
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 69
12575: PUSH
12576: LD_EXP 10
12580: DIFF
12581: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12582: LD_ADDR_VAR 0 1
12586: PUSH
12587: LD_VAR 0 2
12591: PPUSH
12592: LD_INT 112
12594: PPUSH
12595: LD_INT 67
12597: PPUSH
12598: CALL_OW 73
12602: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12603: LD_VAR 0 1
12607: PPUSH
12608: CALL_OW 255
12612: PUSH
12613: LD_INT 7
12615: EQUAL
12616: IFFALSE 12630
// Say ( un , VD-find-al ) ;
12618: LD_VAR 0 1
12622: PPUSH
12623: LD_STRING VD-find-al
12625: PPUSH
12626: CALL_OW 88
// if GetSide ( un ) = 2 then
12630: LD_VAR 0 1
12634: PPUSH
12635: CALL_OW 255
12639: PUSH
12640: LD_INT 2
12642: EQUAL
12643: IFFALSE 12657
// Say ( un , VD-find-ar ) ;
12645: LD_VAR 0 1
12649: PPUSH
12650: LD_STRING VD-find-ar
12652: PPUSH
12653: CALL_OW 88
// if GetSide ( un ) = 1 then
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 255
12666: PUSH
12667: LD_INT 1
12669: EQUAL
12670: IFFALSE 12696
// begin Say ( un , VD-find-us ) ;
12672: LD_VAR 0 1
12676: PPUSH
12677: LD_STRING VD-find-us
12679: PPUSH
12680: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12684: LD_VAR 0 1
12688: PPUSH
12689: LD_STRING VD-find-us2
12691: PPUSH
12692: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12696: LD_INT 10
12698: PPUSH
12699: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12703: LD_INT 112
12705: PPUSH
12706: LD_INT 67
12708: PPUSH
12709: CALL_OW 86
// end ;
12713: PPOPN 2
12715: END
// every 0 0$01 trigger player_artifact_ready do
12716: LD_EXP 7
12720: IFFALSE 13034
12722: GO 12724
12724: DISABLE
// begin if your_side = 1 then
12725: LD_OWVAR 2
12729: PUSH
12730: LD_INT 1
12732: EQUAL
12733: IFFALSE 12851
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12735: LD_INT 22
12737: PUSH
12738: LD_INT 1
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 4
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: EMPTY
12756: LIST
12757: LIST
12758: PPUSH
12759: CALL_OW 69
12763: PUSH
12764: LD_EXP 19
12768: DIFF
12769: PUSH
12770: LD_INT 1
12772: ARRAY
12773: PPUSH
12774: LD_STRING VD-us-sci-art-1
12776: PPUSH
12777: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12781: LD_EXP 19
12785: PPUSH
12786: LD_STRING VDc-art1
12788: PPUSH
12789: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 25
12805: PUSH
12806: LD_INT 4
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PPUSH
12817: CALL_OW 69
12821: PUSH
12822: LD_EXP 19
12826: DIFF
12827: PUSH
12828: LD_INT 1
12830: ARRAY
12831: PPUSH
12832: LD_STRING VD-us-sci-art-2
12834: PPUSH
12835: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12839: LD_EXP 19
12843: PPUSH
12844: LD_STRING VDc-art2
12846: PPUSH
12847: CALL_OW 88
// end ; if your_side = 2 then
12851: LD_OWVAR 2
12855: PUSH
12856: LD_INT 2
12858: EQUAL
12859: IFFALSE 12901
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12861: LD_INT 22
12863: PUSH
12864: LD_INT 2
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 25
12873: PUSH
12874: LD_INT 4
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PPUSH
12885: CALL_OW 69
12889: PUSH
12890: LD_INT 1
12892: ARRAY
12893: PPUSH
12894: LD_STRING VD-ar-sci-art-1
12896: PPUSH
12897: CALL_OW 88
// end ; if your_side = 7 then
12901: LD_OWVAR 2
12905: PUSH
12906: LD_INT 7
12908: EQUAL
12909: IFFALSE 13034
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12911: LD_INT 22
12913: PUSH
12914: LD_INT 7
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 25
12923: PUSH
12924: LD_INT 4
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PPUSH
12935: CALL_OW 69
12939: PUSH
12940: LD_EXP 37
12944: DIFF
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PPUSH
12950: LD_STRING VD-al-sci-art-1
12952: PPUSH
12953: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
12957: LD_EXP 37
12961: PPUSH
12962: LD_STRING VPd-art-1
12964: PPUSH
12965: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
12969: LD_INT 22
12971: PUSH
12972: LD_INT 7
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: LD_INT 25
12981: PUSH
12982: LD_INT 4
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PPUSH
12993: CALL_OW 69
12997: PUSH
12998: LD_EXP 37
13002: DIFF
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: PPUSH
13008: LD_STRING VD-al-sci-art-2
13010: PPUSH
13011: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13015: LD_EXP 37
13019: PPUSH
13020: LD_STRING VPd-art-2
13022: PPUSH
13023: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13027: LD_STRING CVulc7out
13029: PPUSH
13030: CALL_OW 337
// end ; end ;
13034: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13035: LD_INT 8
13037: PPUSH
13038: LD_INT 22
13040: PUSH
13041: LD_OWVAR 2
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PPUSH
13050: CALL_OW 69
13054: PPUSH
13055: LD_INT 8
13057: PPUSH
13058: CALL 2145 0 2
13062: PPUSH
13063: CALL_OW 292
13067: IFFALSE 13158
13069: GO 13071
13071: DISABLE
// begin if your_side = 1 then
13072: LD_OWVAR 2
13076: PUSH
13077: LD_INT 1
13079: EQUAL
13080: IFFALSE 13114
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13082: LD_INT 22
13084: PUSH
13085: LD_INT 1
13087: PUSH
13088: EMPTY
13089: LIST
13090: LIST
13091: PPUSH
13092: CALL_OW 69
13096: PUSH
13097: LD_EXP 19
13101: DIFF
13102: PUSH
13103: LD_INT 1
13105: ARRAY
13106: PPUSH
13107: LD_STRING VD-legion-us
13109: PPUSH
13110: CALL_OW 88
// if your_side = 2 then
13114: LD_OWVAR 2
13118: PUSH
13119: LD_INT 2
13121: EQUAL
13122: IFFALSE 13136
// Say ( ar_commander , VD-legion-ar ) ;
13124: LD_EXP 51
13128: PPUSH
13129: LD_STRING VD-legion-ar
13131: PPUSH
13132: CALL_OW 88
// if your_side = 7 then
13136: LD_OWVAR 2
13140: PUSH
13141: LD_INT 7
13143: EQUAL
13144: IFFALSE 13158
// Say ( al_commander , VD-legion-al ) ;
13146: LD_EXP 37
13150: PPUSH
13151: LD_STRING VD-legion-al
13153: PPUSH
13154: CALL_OW 88
// end ;
13158: END
// every 0 0$01 trigger mine_vulc do
13159: LD_EXP 12
13163: IFFALSE 13180
13165: GO 13167
13167: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13168: LD_EXP 10
13172: PPUSH
13173: LD_STRING VD-vulc-mines
13175: PPUSH
13176: CALL_OW 88
// end ;
13180: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13181: LD_OWVAR 67
13185: PUSH
13186: LD_INT 1
13188: GREATER
13189: IFFALSE 13308
13191: GO 13193
13193: DISABLE
13194: LD_INT 0
13196: PPUSH
13197: PPUSH
13198: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13199: LD_ADDR_VAR 0 1
13203: PUSH
13204: LD_INT 123
13206: PUSH
13207: LD_INT 95
13209: PUSH
13210: LD_INT 119
13212: PUSH
13213: LD_INT 89
13215: PUSH
13216: LD_INT 115
13218: PUSH
13219: LD_INT 81
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: LIST
13229: ST_TO_ADDR
// p := 1 ;
13230: LD_ADDR_VAR 0 2
13234: PUSH
13235: LD_INT 1
13237: ST_TO_ADDR
// for i = 1 to 3 do
13238: LD_ADDR_VAR 0 3
13242: PUSH
13243: DOUBLE
13244: LD_INT 1
13246: DEC
13247: ST_TO_ADDR
13248: LD_INT 3
13250: PUSH
13251: FOR_TO
13252: IFFALSE 13306
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13254: LD_VAR 0 1
13258: PUSH
13259: LD_VAR 0 2
13263: ARRAY
13264: PPUSH
13265: LD_VAR 0 1
13269: PUSH
13270: LD_VAR 0 2
13274: PUSH
13275: LD_INT 1
13277: PLUS
13278: ARRAY
13279: PPUSH
13280: LD_INT 8
13282: PPUSH
13283: LD_INT 0
13285: PPUSH
13286: CALL_OW 454
// p := p + 2 ;
13290: LD_ADDR_VAR 0 2
13294: PUSH
13295: LD_VAR 0 2
13299: PUSH
13300: LD_INT 2
13302: PLUS
13303: ST_TO_ADDR
// end ;
13304: GO 13251
13306: POP
13307: POP
// end ;
13308: PPOPN 3
13310: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13311: LD_OWVAR 67
13315: PUSH
13316: LD_INT 1
13318: GREATER
13319: PUSH
13320: LD_INT 22
13322: PPUSH
13323: LD_INT 22
13325: PUSH
13326: LD_OWVAR 2
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PPUSH
13335: CALL_OW 70
13339: AND
13340: IFFALSE 13544
13342: GO 13344
13344: DISABLE
13345: LD_INT 0
13347: PPUSH
13348: PPUSH
13349: PPUSH
// begin enable ;
13350: ENABLE
// p := 1 ;
13351: LD_ADDR_VAR 0 1
13355: PUSH
13356: LD_INT 1
13358: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13359: LD_ADDR_VAR 0 3
13363: PUSH
13364: LD_INT 123
13366: PUSH
13367: LD_INT 95
13369: PUSH
13370: LD_INT 119
13372: PUSH
13373: LD_INT 89
13375: PUSH
13376: LD_INT 115
13378: PUSH
13379: LD_INT 81
13381: PUSH
13382: EMPTY
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: ST_TO_ADDR
// for i = 1 to 3 do
13390: LD_ADDR_VAR 0 2
13394: PUSH
13395: DOUBLE
13396: LD_INT 1
13398: DEC
13399: ST_TO_ADDR
13400: LD_INT 3
13402: PUSH
13403: FOR_TO
13404: IFFALSE 13542
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13406: LD_VAR 0 3
13410: PUSH
13411: LD_VAR 0 1
13415: ARRAY
13416: PPUSH
13417: LD_VAR 0 3
13421: PUSH
13422: LD_VAR 0 1
13426: PUSH
13427: LD_INT 1
13429: PLUS
13430: ARRAY
13431: PPUSH
13432: CALL_OW 428
13436: PUSH
13437: LD_INT 0
13439: GREATER
13440: IFFALSE 13526
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13442: LD_VAR 0 3
13446: PUSH
13447: LD_VAR 0 1
13451: ARRAY
13452: PPUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_VAR 0 1
13462: PUSH
13463: LD_INT 1
13465: PLUS
13466: ARRAY
13467: PPUSH
13468: CALL_OW 428
13472: PPUSH
13473: CALL_OW 255
13477: PUSH
13478: LD_OWVAR 2
13482: EQUAL
13483: IFFALSE 13526
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13485: LD_VAR 0 3
13489: PUSH
13490: LD_VAR 0 1
13494: ARRAY
13495: PPUSH
13496: LD_VAR 0 3
13500: PUSH
13501: LD_VAR 0 1
13505: PUSH
13506: LD_INT 1
13508: PLUS
13509: ARRAY
13510: PPUSH
13511: LD_INT 8
13513: PPUSH
13514: CALL_OW 456
// mine_vulc := true ;
13518: LD_ADDR_EXP 12
13522: PUSH
13523: LD_INT 1
13525: ST_TO_ADDR
// end ; p := p + 2 ;
13526: LD_ADDR_VAR 0 1
13530: PUSH
13531: LD_VAR 0 1
13535: PUSH
13536: LD_INT 2
13538: PLUS
13539: ST_TO_ADDR
// end ;
13540: GO 13403
13542: POP
13543: POP
// end ;
13544: PPOPN 3
13546: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13547: LD_INT 22
13549: PUSH
13550: LD_INT 3
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PPUSH
13557: CALL_OW 69
13561: PUSH
13562: LD_INT 0
13564: EQUAL
13565: PUSH
13566: LD_OWVAR 2
13570: PUSH
13571: LD_INT 2
13573: NONEQUAL
13574: AND
13575: IFFALSE 13584
13577: GO 13579
13579: DISABLE
// Win ;
13580: CALL 13641 0 0
13584: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13585: LD_INT 2
13587: PUSH
13588: LD_INT 22
13590: PUSH
13591: LD_INT 8
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 22
13600: PUSH
13601: LD_INT 3
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PUSH
13618: LD_INT 0
13620: EQUAL
13621: PUSH
13622: LD_OWVAR 2
13626: PUSH
13627: LD_INT 2
13629: EQUAL
13630: AND
13631: IFFALSE 13640
13633: GO 13635
13635: DISABLE
// Win ;
13636: CALL 13641 0 0
13640: END
// function Win ; var points ; begin
13641: LD_INT 0
13643: PPUSH
13644: PPUSH
// case Query ( VulcWin ) of 1 :
13645: LD_STRING VulcWin
13647: PPUSH
13648: CALL_OW 97
13652: PUSH
13653: LD_INT 1
13655: DOUBLE
13656: EQUAL
13657: IFTRUE 13661
13659: GO 13664
13661: POP
// ; end ;
13662: GO 13665
13664: POP
// if medal_enabled then
13665: LD_EXP 13
13669: IFFALSE 13683
// AddMedal ( vulc_1 , 1 ) else
13671: LD_STRING vulc_1
13673: PPUSH
13674: LD_INT 1
13676: PPUSH
13677: CALL_OW 101
13681: GO 13694
// AddMedal ( vulc_1 , - 1 ) ;
13683: LD_STRING vulc_1
13685: PPUSH
13686: LD_INT 1
13688: NEG
13689: PPUSH
13690: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13694: LD_INT 22
13696: PUSH
13697: LD_INT 8
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: PPUSH
13704: CALL_OW 69
13708: PUSH
13709: LD_INT 0
13711: EQUAL
13712: IFFALSE 13726
// AddMedal ( vulc_2 , 1 ) else
13714: LD_STRING vulc_2
13716: PPUSH
13717: LD_INT 1
13719: PPUSH
13720: CALL_OW 101
13724: GO 13737
// AddMedal ( vulc_2 , - 1 ) ;
13726: LD_STRING vulc_2
13728: PPUSH
13729: LD_INT 1
13731: NEG
13732: PPUSH
13733: CALL_OW 101
// points := CalculateCommanderPoints ;
13737: LD_ADDR_VAR 0 2
13741: PUSH
13742: CALL 2266 0 0
13746: ST_TO_ADDR
// if points >= 2000 then
13747: LD_VAR 0 2
13751: PUSH
13752: LD_INT 2000
13754: GREATEREQUAL
13755: IFFALSE 13769
// AddMedal ( vulc_3 , 2 ) else
13757: LD_STRING vulc_3
13759: PPUSH
13760: LD_INT 2
13762: PPUSH
13763: CALL_OW 101
13767: GO 13802
// if points >= 0 then
13769: LD_VAR 0 2
13773: PUSH
13774: LD_INT 0
13776: GREATEREQUAL
13777: IFFALSE 13791
// AddMedal ( vulc_3 , 1 ) else
13779: LD_STRING vulc_3
13781: PPUSH
13782: LD_INT 1
13784: PPUSH
13785: CALL_OW 101
13789: GO 13802
// AddMedal ( vulc_3 , - 1 ) ;
13791: LD_STRING vulc_3
13793: PPUSH
13794: LD_INT 1
13796: NEG
13797: PPUSH
13798: CALL_OW 101
// GiveMedals ( MAIN ) ;
13802: LD_STRING MAIN
13804: PPUSH
13805: CALL_OW 102
// YouWin ;
13809: CALL_OW 103
// end ; end_of_file
13813: LD_VAR 0 1
13817: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13818: LD_INT 13
13820: PPUSH
13821: LD_INT 21
13823: PUSH
13824: LD_INT 1
13826: PUSH
13827: EMPTY
13828: LIST
13829: LIST
13830: PPUSH
13831: CALL_OW 70
13835: PUSH
13836: LD_INT 0
13838: GREATER
13839: IFFALSE 13906
13841: GO 13843
13843: DISABLE
13844: LD_INT 0
13846: PPUSH
13847: PPUSH
// begin enable ;
13848: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13849: LD_ADDR_VAR 0 1
13853: PUSH
13854: LD_INT 13
13856: PPUSH
13857: LD_INT 21
13859: PUSH
13860: LD_INT 1
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PPUSH
13867: CALL_OW 70
13871: PUSH
13872: FOR_IN
13873: IFFALSE 13904
// if GetLives ( i ) > 4 then
13875: LD_VAR 0 1
13879: PPUSH
13880: CALL_OW 256
13884: PUSH
13885: LD_INT 4
13887: GREATER
13888: IFFALSE 13902
// SetLives ( i , 4 ) ;
13890: LD_VAR 0 1
13894: PPUSH
13895: LD_INT 4
13897: PPUSH
13898: CALL_OW 234
13902: GO 13872
13904: POP
13905: POP
// end ;
13906: PPOPN 2
13908: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13909: LD_VAR 0 1
13913: PPUSH
13914: CALL_OW 255
13918: PUSH
13919: LD_OWVAR 2
13923: EQUAL
13924: IFFALSE 13934
// player_res_art := true ;
13926: LD_ADDR_EXP 6
13930: PUSH
13931: LD_INT 1
13933: ST_TO_ADDR
// end ;
13934: PPOPN 1
13936: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13937: LD_INT 22
13939: PUSH
13940: LD_OWVAR 2
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: LD_INT 2
13951: PUSH
13952: LD_INT 30
13954: PUSH
13955: LD_INT 8
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: LD_INT 30
13964: PUSH
13965: LD_INT 11
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: LIST
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: PPUSH
13981: CALL_OW 69
13985: PUSH
13986: LD_EXP 6
13990: AND
13991: IFFALSE 14335
13993: GO 13995
13995: DISABLE
13996: LD_INT 0
13998: PPUSH
13999: PPUSH
14000: PPUSH
// begin enable ;
14001: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14002: LD_ADDR_VAR 0 1
14006: PUSH
14007: LD_INT 1
14009: PPUSH
14010: CALL_OW 469
14014: PUSH
14015: LD_INT 1
14017: ARRAY
14018: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_INT 1
14026: PPUSH
14027: CALL_OW 469
14031: PUSH
14032: LD_INT 2
14034: ARRAY
14035: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14036: LD_ADDR_VAR 0 3
14040: PUSH
14041: LD_INT 22
14043: PUSH
14044: LD_OWVAR 2
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PUSH
14053: LD_INT 2
14055: PUSH
14056: LD_INT 30
14058: PUSH
14059: LD_INT 8
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: PUSH
14066: LD_INT 30
14068: PUSH
14069: LD_INT 11
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: LIST
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PPUSH
14085: CALL_OW 69
14089: PPUSH
14090: LD_VAR 0 1
14094: PPUSH
14095: LD_VAR 0 2
14099: PPUSH
14100: CALL_OW 73
14104: ST_TO_ADDR
// if player_artifact_ready = false then
14105: LD_EXP 7
14109: PUSH
14110: LD_INT 0
14112: EQUAL
14113: IFFALSE 14219
// if GetDistUnitXY ( lab , x , y ) < 6 then
14115: LD_VAR 0 3
14119: PPUSH
14120: LD_VAR 0 1
14124: PPUSH
14125: LD_VAR 0 2
14129: PPUSH
14130: CALL_OW 297
14134: PUSH
14135: LD_INT 6
14137: LESS
14138: IFFALSE 14199
// begin if BuildingStatus ( lab ) = bs_idle then
14140: LD_VAR 0 3
14144: PPUSH
14145: CALL_OW 461
14149: PUSH
14150: LD_INT 2
14152: EQUAL
14153: IFFALSE 14177
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14155: LD_OWVAR 2
14159: PPUSH
14160: LD_INT 1
14162: PPUSH
14163: LD_INT 2
14165: PPUSH
14166: LD_VAR 0 3
14170: PPUSH
14171: CALL_OW 468
14175: GO 14197
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14177: LD_OWVAR 2
14181: PPUSH
14182: LD_INT 1
14184: PPUSH
14185: LD_INT 1
14187: PPUSH
14188: LD_VAR 0 3
14192: PPUSH
14193: CALL_OW 468
// end else
14197: GO 14219
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14199: LD_OWVAR 2
14203: PPUSH
14204: LD_INT 1
14206: PPUSH
14207: LD_INT 1
14209: PPUSH
14210: LD_VAR 0 3
14214: PPUSH
14215: CALL_OW 468
// if player_artifact_ready then
14219: LD_EXP 7
14223: IFFALSE 14335
// if GetDistUnitXY ( lab , x , y ) < 6 then
14225: LD_VAR 0 3
14229: PPUSH
14230: LD_VAR 0 1
14234: PPUSH
14235: LD_VAR 0 2
14239: PPUSH
14240: CALL_OW 297
14244: PUSH
14245: LD_INT 6
14247: LESS
14248: IFFALSE 14313
// begin if BuildingStatus ( lab ) = bs_idle then
14250: LD_VAR 0 3
14254: PPUSH
14255: CALL_OW 461
14259: PUSH
14260: LD_INT 2
14262: EQUAL
14263: IFFALSE 14289
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14265: LD_OWVAR 2
14269: PPUSH
14270: LD_EXP 8
14274: PPUSH
14275: LD_INT 4
14277: PPUSH
14278: LD_VAR 0 3
14282: PPUSH
14283: CALL_OW 468
14287: GO 14311
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14289: LD_OWVAR 2
14293: PPUSH
14294: LD_EXP 8
14298: PPUSH
14299: LD_INT 1
14301: PPUSH
14302: LD_VAR 0 3
14306: PPUSH
14307: CALL_OW 468
// end else
14311: GO 14335
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14313: LD_OWVAR 2
14317: PPUSH
14318: LD_EXP 8
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: LD_VAR 0 3
14330: PPUSH
14331: CALL_OW 468
// end ;
14335: PPOPN 3
14337: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14338: LD_INT 0
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14345: LD_ADDR_VAR 0 5
14349: PUSH
14350: LD_INT 1
14352: PPUSH
14353: CALL_OW 469
14357: PUSH
14358: LD_INT 1
14360: ARRAY
14361: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14362: LD_ADDR_VAR 0 6
14366: PUSH
14367: LD_INT 1
14369: PPUSH
14370: CALL_OW 469
14374: PUSH
14375: LD_INT 2
14377: ARRAY
14378: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14379: LD_ADDR_VAR 0 8
14383: PUSH
14384: LD_INT 22
14386: PUSH
14387: LD_OWVAR 2
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: PUSH
14396: LD_INT 2
14398: PUSH
14399: LD_INT 30
14401: PUSH
14402: LD_INT 8
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PUSH
14409: LD_INT 30
14411: PUSH
14412: LD_INT 11
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PPUSH
14428: CALL_OW 69
14432: PPUSH
14433: LD_VAR 0 5
14437: PPUSH
14438: LD_VAR 0 6
14442: PPUSH
14443: CALL_OW 73
14447: ST_TO_ADDR
// if icon = art_exp_left then
14448: LD_VAR 0 2
14452: PUSH
14453: LD_INT 1
14455: EQUAL
14456: IFFALSE 14495
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14458: LD_VAR 0 8
14462: PPUSH
14463: LD_EXP 9
14467: PPUSH
14468: LD_INT 1
14470: PPUSH
14471: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14475: LD_OWVAR 2
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 0
14485: PPUSH
14486: LD_VAR 0 8
14490: PPUSH
14491: CALL_OW 468
// end ; if icon = art_icon then
14495: LD_VAR 0 2
14499: PUSH
14500: LD_EXP 8
14504: EQUAL
14505: IFFALSE 14719
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14507: LD_VAR 0 3
14511: PUSH
14512: LD_INT 21
14514: PUSH
14515: LD_INT 3
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PPUSH
14522: CALL_OW 69
14526: IN
14527: IFFALSE 14719
// begin side := GetSide ( cr1 ) ;
14529: LD_ADDR_VAR 0 9
14533: PUSH
14534: LD_VAR 0 3
14538: PPUSH
14539: CALL_OW 255
14543: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14544: LD_INT 22
14546: PUSH
14547: LD_VAR 0 9
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PUSH
14556: LD_INT 30
14558: PUSH
14559: LD_INT 28
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PUSH
14566: EMPTY
14567: LIST
14568: LIST
14569: PPUSH
14570: CALL_OW 69
14574: PUSH
14575: LD_INT 0
14577: GREATER
14578: IFFALSE 14719
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14580: LD_ADDR_VAR 0 7
14584: PUSH
14585: LD_INT 22
14587: PUSH
14588: LD_VAR 0 9
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: LD_INT 2
14599: PUSH
14600: LD_INT 30
14602: PUSH
14603: LD_INT 26
14605: PUSH
14606: EMPTY
14607: LIST
14608: LIST
14609: PUSH
14610: LD_INT 30
14612: PUSH
14613: LD_INT 27
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: LD_INT 30
14622: PUSH
14623: LD_INT 28
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PPUSH
14640: CALL_OW 69
14644: PUSH
14645: FOR_IN
14646: IFFALSE 14662
// SetLives ( i , 1 ) ;
14648: LD_VAR 0 7
14652: PPUSH
14653: LD_INT 1
14655: PPUSH
14656: CALL_OW 234
14660: GO 14645
14662: POP
14663: POP
// player_res_art := false ;
14664: LD_ADDR_EXP 6
14668: PUSH
14669: LD_INT 0
14671: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14672: LD_OWVAR 2
14676: PPUSH
14677: LD_EXP 8
14681: PPUSH
14682: LD_INT 1
14684: PPUSH
14685: LD_VAR 0 8
14689: PPUSH
14690: CALL_OW 468
// Wait ( time_to_reuse ) ;
14694: LD_EXP 11
14698: PPUSH
14699: CALL_OW 67
// player_res_art := true ;
14703: LD_ADDR_EXP 6
14707: PUSH
14708: LD_INT 1
14710: ST_TO_ADDR
// medal_enabled := true ;
14711: LD_ADDR_EXP 13
14715: PUSH
14716: LD_INT 1
14718: ST_TO_ADDR
// end ; end ; end ; end ;
14719: PPOPN 9
14721: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14722: LD_VAR 0 1
14726: PPUSH
14727: CALL_OW 255
14731: PUSH
14732: LD_OWVAR 2
14736: EQUAL
14737: IFFALSE 14774
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14739: LD_OWVAR 2
14743: PPUSH
14744: LD_INT 1
14746: PPUSH
14747: LD_INT 0
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 468
// player_artifact_ready := true ;
14759: LD_ADDR_EXP 7
14763: PUSH
14764: LD_INT 1
14766: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14767: LD_STRING ArtVulcano
14769: PPUSH
14770: CALL_OW 339
// end ; end ;
14774: PPOPN 1
14776: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14777: LD_OWVAR 2
14781: PPUSH
14782: LD_INT 1
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: LD_VAR 0 1
14792: PPUSH
14793: CALL_OW 468
// end ; end_of_file
14797: PPOPN 2
14799: END
// every 0 0$01 do
14800: GO 14802
14802: DISABLE
// begin enable ;
14803: ENABLE
// Display_Strings := [ #tick , tick ] ;
14804: LD_ADDR_OWVAR 47
14808: PUSH
14809: LD_STRING #tick
14811: PUSH
14812: LD_OWVAR 1
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: ST_TO_ADDR
// end ; end_of_file
14821: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14822: LD_INT 0
14824: PPUSH
14825: PPUSH
14826: PPUSH
14827: PPUSH
14828: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14829: LD_ADDR_EXP 39
14833: PUSH
14834: LD_INT 7
14836: PUSH
14837: LD_INT 6
14839: PUSH
14840: LD_INT 5
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: LIST
14847: PUSH
14848: LD_OWVAR 67
14852: ARRAY
14853: ST_TO_ADDR
// al_force := [ ] ;
14854: LD_ADDR_EXP 38
14858: PUSH
14859: EMPTY
14860: ST_TO_ADDR
// RemoveAlliance ;
14861: CALL 15239 0 0
// ResetFog ;
14865: CALL_OW 335
// your_side := 7 ;
14869: LD_ADDR_OWVAR 2
14873: PUSH
14874: LD_INT 7
14876: ST_TO_ADDR
// uc_side := 7 ;
14877: LD_ADDR_OWVAR 20
14881: PUSH
14882: LD_INT 7
14884: ST_TO_ADDR
// hc_gallery :=  ;
14885: LD_ADDR_OWVAR 33
14889: PUSH
14890: LD_STRING 
14892: ST_TO_ADDR
// hc_name :=  ;
14893: LD_ADDR_OWVAR 26
14897: PUSH
14898: LD_STRING 
14900: ST_TO_ADDR
// hc_importance := 0 ;
14901: LD_ADDR_OWVAR 32
14905: PUSH
14906: LD_INT 0
14908: ST_TO_ADDR
// for i = 1 to 17 do
14909: LD_ADDR_VAR 0 2
14913: PUSH
14914: DOUBLE
14915: LD_INT 1
14917: DEC
14918: ST_TO_ADDR
14919: LD_INT 17
14921: PUSH
14922: FOR_TO
14923: IFFALSE 15003
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14925: LD_ADDR_OWVAR 21
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: LD_INT 3
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: PUSH
14940: LD_INT 1
14942: PPUSH
14943: LD_INT 2
14945: PPUSH
14946: CALL_OW 12
14950: ARRAY
14951: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14952: LD_INT 0
14954: PPUSH
14955: LD_INT 1
14957: PPUSH
14958: LD_INT 4
14960: PPUSH
14961: CALL_OW 12
14965: PPUSH
14966: LD_EXP 39
14970: PPUSH
14971: CALL_OW 380
// un := CreateHuman ;
14975: LD_ADDR_VAR 0 4
14979: PUSH
14980: CALL_OW 44
14984: ST_TO_ADDR
// al_force := al_force ^ un ;
14985: LD_ADDR_EXP 38
14989: PUSH
14990: LD_EXP 38
14994: PUSH
14995: LD_VAR 0 4
14999: ADD
15000: ST_TO_ADDR
// end ;
15001: GO 14922
15003: POP
15004: POP
// hc_importance := 100 ;
15005: LD_ADDR_OWVAR 32
15009: PUSH
15010: LD_INT 100
15012: ST_TO_ADDR
// uc_nation := 1 ;
15013: LD_ADDR_OWVAR 21
15017: PUSH
15018: LD_INT 1
15020: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15021: LD_INT 1
15023: PPUSH
15024: LD_INT 1
15026: PPUSH
15027: LD_EXP 39
15031: PPUSH
15032: CALL_OW 380
// al_commander := CreateHuman ;
15036: LD_ADDR_EXP 37
15040: PUSH
15041: CALL_OW 44
15045: ST_TO_ADDR
// player_commander := al_commander ;
15046: LD_ADDR_EXP 10
15050: PUSH
15051: LD_EXP 37
15055: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15056: LD_ADDR_VAR 0 5
15060: PUSH
15061: LD_STRING text
15063: PPUSH
15064: LD_INT 9
15066: PUSH
15067: LD_INT 9
15069: PUSH
15070: LD_INT 8
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: LIST
15077: PUSH
15078: LD_OWVAR 67
15082: ARRAY
15083: PPUSH
15084: LD_INT 9
15086: PUSH
15087: LD_INT 9
15089: PUSH
15090: LD_INT 8
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: PUSH
15098: LD_OWVAR 67
15102: ARRAY
15103: PPUSH
15104: LD_INT -5
15106: PUSH
15107: LD_EXP 37
15111: PUSH
15112: LD_INT -3
15114: PUSH
15115: LD_INT -2
15117: PUSH
15118: EMPTY
15119: LIST
15120: LIST
15121: LIST
15122: LIST
15123: PUSH
15124: LD_EXP 38
15128: ADD
15129: PPUSH
15130: LD_INT 1
15132: PUSH
15133: LD_INT 3
15135: PUSH
15136: LD_INT 2
15138: PUSH
15139: LD_INT 1
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PUSH
15146: LD_INT 4
15148: PUSH
15149: LD_INT 1
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: PUSH
15156: LD_INT 9
15158: PUSH
15159: LD_INT 5
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: PPUSH
15170: CALL_OW 42
15174: ST_TO_ADDR
// team := team ^ al_commander ;
15175: LD_ADDR_VAR 0 5
15179: PUSH
15180: LD_VAR 0 5
15184: PUSH
15185: LD_EXP 37
15189: ADD
15190: ST_TO_ADDR
// for i = 1 to team do
15191: LD_ADDR_VAR 0 2
15195: PUSH
15196: DOUBLE
15197: LD_INT 1
15199: DEC
15200: ST_TO_ADDR
15201: LD_VAR 0 5
15205: PUSH
15206: FOR_TO
15207: IFFALSE 15232
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15209: LD_VAR 0 5
15213: PUSH
15214: LD_VAR 0 2
15218: ARRAY
15219: PPUSH
15220: LD_INT 15
15222: PPUSH
15223: LD_INT 0
15225: PPUSH
15226: CALL_OW 49
15230: GO 15206
15232: POP
15233: POP
// end ;
15234: LD_VAR 0 1
15238: RET
// export function RemoveAlliance ; var i ; begin
15239: LD_INT 0
15241: PPUSH
15242: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15243: LD_INT 22
15245: PUSH
15246: LD_INT 7
15248: PUSH
15249: EMPTY
15250: LIST
15251: LIST
15252: PUSH
15253: LD_INT 30
15255: PUSH
15256: LD_INT 1
15258: PUSH
15259: EMPTY
15260: LIST
15261: LIST
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PPUSH
15267: CALL_OW 69
15271: PUSH
15272: LD_INT 1
15274: ARRAY
15275: PPUSH
15276: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15280: LD_ADDR_VAR 0 2
15284: PUSH
15285: LD_INT 22
15287: PUSH
15288: LD_INT 7
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PPUSH
15295: CALL_OW 69
15299: PUSH
15300: FOR_IN
15301: IFFALSE 15314
// RemoveUnit ( i ) ;
15303: LD_VAR 0 2
15307: PPUSH
15308: CALL_OW 64
15312: GO 15300
15314: POP
15315: POP
// end ;
15316: LD_VAR 0 1
15320: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15321: LD_INT 0
15323: PPUSH
15324: PPUSH
15325: PPUSH
15326: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15327: LD_INT 31
15329: PPUSH
15330: LD_INT 7
15332: PPUSH
15333: LD_INT 2
15335: PPUSH
15336: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15340: LD_INT 32
15342: PPUSH
15343: LD_INT 7
15345: PPUSH
15346: LD_INT 2
15348: PPUSH
15349: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15353: LD_INT 59
15355: PPUSH
15356: LD_INT 7
15358: PPUSH
15359: LD_INT 2
15361: PPUSH
15362: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15366: LD_ADDR_EXP 39
15370: PUSH
15371: LD_INT 5
15373: PUSH
15374: LD_INT 6
15376: PUSH
15377: LD_INT 7
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: LIST
15384: PUSH
15385: LD_OWVAR 67
15389: ARRAY
15390: ST_TO_ADDR
// al_force := [ ] ;
15391: LD_ADDR_EXP 38
15395: PUSH
15396: EMPTY
15397: ST_TO_ADDR
// al_vehs := [ ] ;
15398: LD_ADDR_EXP 44
15402: PUSH
15403: EMPTY
15404: ST_TO_ADDR
// uc_side := 7 ;
15405: LD_ADDR_OWVAR 20
15409: PUSH
15410: LD_INT 7
15412: ST_TO_ADDR
// uc_nation := 1 ;
15413: LD_ADDR_OWVAR 21
15417: PUSH
15418: LD_INT 1
15420: ST_TO_ADDR
// bc_type := b_oil_mine ;
15421: LD_ADDR_OWVAR 42
15425: PUSH
15426: LD_INT 29
15428: ST_TO_ADDR
// b := CreateBuilding ;
15429: LD_ADDR_VAR 0 4
15433: PUSH
15434: CALL_OW 46
15438: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15439: LD_VAR 0 4
15443: PPUSH
15444: LD_INT 61
15446: PPUSH
15447: LD_INT 7
15449: PPUSH
15450: LD_INT 0
15452: PPUSH
15453: LD_INT 0
15455: PPUSH
15456: CALL_OW 50
// bc_type := b_siberite_mine ;
15460: LD_ADDR_OWVAR 42
15464: PUSH
15465: LD_INT 30
15467: ST_TO_ADDR
// b := CreateBuilding ;
15468: LD_ADDR_VAR 0 4
15472: PUSH
15473: CALL_OW 46
15477: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15478: LD_VAR 0 4
15482: PPUSH
15483: LD_INT 69
15485: PPUSH
15486: LD_INT 13
15488: PPUSH
15489: LD_INT 0
15491: PPUSH
15492: LD_INT 0
15494: PPUSH
15495: CALL_OW 50
// hc_gallery :=  ;
15499: LD_ADDR_OWVAR 33
15503: PUSH
15504: LD_STRING 
15506: ST_TO_ADDR
// hc_name :=  ;
15507: LD_ADDR_OWVAR 26
15511: PUSH
15512: LD_STRING 
15514: ST_TO_ADDR
// hc_importance := 0 ;
15515: LD_ADDR_OWVAR 32
15519: PUSH
15520: LD_INT 0
15522: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15523: LD_ADDR_VAR 0 2
15527: PUSH
15528: LD_INT 22
15530: PUSH
15531: LD_INT 7
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: LD_INT 30
15540: PUSH
15541: LD_INT 32
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PPUSH
15552: CALL_OW 69
15556: PUSH
15557: FOR_IN
15558: IFFALSE 15628
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15560: LD_ADDR_OWVAR 21
15564: PUSH
15565: LD_INT 1
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PUSH
15575: LD_INT 1
15577: PPUSH
15578: LD_INT 2
15580: PPUSH
15581: CALL_OW 12
15585: ARRAY
15586: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15587: LD_INT 0
15589: PPUSH
15590: LD_INT 1
15592: PPUSH
15593: LD_EXP 39
15597: PPUSH
15598: CALL_OW 380
// un := CreateHuman ;
15602: LD_ADDR_VAR 0 3
15606: PUSH
15607: CALL_OW 44
15611: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15612: LD_VAR 0 3
15616: PPUSH
15617: LD_VAR 0 2
15621: PPUSH
15622: CALL_OW 52
// end ;
15626: GO 15557
15628: POP
15629: POP
// for i = 1 to 3 do
15630: LD_ADDR_VAR 0 2
15634: PUSH
15635: DOUBLE
15636: LD_INT 1
15638: DEC
15639: ST_TO_ADDR
15640: LD_INT 3
15642: PUSH
15643: FOR_TO
15644: IFFALSE 15712
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15646: LD_ADDR_OWVAR 21
15650: PUSH
15651: LD_INT 1
15653: PUSH
15654: LD_INT 3
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: PUSH
15661: LD_INT 1
15663: PPUSH
15664: LD_INT 2
15666: PPUSH
15667: CALL_OW 12
15671: ARRAY
15672: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15673: LD_INT 0
15675: PPUSH
15676: LD_INT 4
15678: PPUSH
15679: LD_EXP 39
15683: PPUSH
15684: CALL_OW 380
// un := CreateHuman ;
15688: LD_ADDR_VAR 0 3
15692: PUSH
15693: CALL_OW 44
15697: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15698: LD_VAR 0 3
15702: PPUSH
15703: LD_INT 164
15705: PPUSH
15706: CALL_OW 52
// end ;
15710: GO 15643
15712: POP
15713: POP
// for i = 1 to 6 do
15714: LD_ADDR_VAR 0 2
15718: PUSH
15719: DOUBLE
15720: LD_INT 1
15722: DEC
15723: ST_TO_ADDR
15724: LD_INT 6
15726: PUSH
15727: FOR_TO
15728: IFFALSE 15819
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15730: LD_ADDR_OWVAR 21
15734: PUSH
15735: LD_INT 1
15737: PUSH
15738: LD_INT 3
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 1
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: CALL_OW 12
15755: ARRAY
15756: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15757: LD_INT 0
15759: PPUSH
15760: LD_INT 5
15762: PUSH
15763: LD_INT 9
15765: PUSH
15766: LD_INT 9
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 1
15776: PPUSH
15777: LD_INT 3
15779: PPUSH
15780: CALL_OW 12
15784: ARRAY
15785: PPUSH
15786: LD_EXP 39
15790: PPUSH
15791: CALL_OW 380
// un := CreateHuman ;
15795: LD_ADDR_VAR 0 3
15799: PUSH
15800: CALL_OW 44
15804: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15805: LD_VAR 0 3
15809: PPUSH
15810: LD_INT 173
15812: PPUSH
15813: CALL_OW 52
// end ;
15817: GO 15727
15819: POP
15820: POP
// for i = 1 to 6 do
15821: LD_ADDR_VAR 0 2
15825: PUSH
15826: DOUBLE
15827: LD_INT 1
15829: DEC
15830: ST_TO_ADDR
15831: LD_INT 6
15833: PUSH
15834: FOR_TO
15835: IFFALSE 15933
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15837: LD_ADDR_OWVAR 21
15841: PUSH
15842: LD_INT 1
15844: PUSH
15845: LD_INT 3
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 1
15854: PPUSH
15855: LD_INT 2
15857: PPUSH
15858: CALL_OW 12
15862: ARRAY
15863: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15864: LD_INT 0
15866: PPUSH
15867: LD_INT 3
15869: PPUSH
15870: LD_EXP 39
15874: PPUSH
15875: CALL_OW 380
// un := CreateHuman ;
15879: LD_ADDR_VAR 0 3
15883: PUSH
15884: CALL_OW 44
15888: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15889: LD_VAR 0 3
15893: PPUSH
15894: LD_INT 22
15896: PUSH
15897: LD_INT 7
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PUSH
15904: LD_INT 30
15906: PUSH
15907: LD_INT 3
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PPUSH
15918: CALL_OW 69
15922: PUSH
15923: LD_INT 1
15925: ARRAY
15926: PPUSH
15927: CALL_OW 52
// end ;
15931: GO 15834
15933: POP
15934: POP
// for i = 1 to 4 do
15935: LD_ADDR_VAR 0 2
15939: PUSH
15940: DOUBLE
15941: LD_INT 1
15943: DEC
15944: ST_TO_ADDR
15945: LD_INT 4
15947: PUSH
15948: FOR_TO
15949: IFFALSE 16017
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15951: LD_ADDR_OWVAR 21
15955: PUSH
15956: LD_INT 1
15958: PUSH
15959: LD_INT 3
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 1
15968: PPUSH
15969: LD_INT 2
15971: PPUSH
15972: CALL_OW 12
15976: ARRAY
15977: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
15978: LD_INT 0
15980: PPUSH
15981: LD_INT 2
15983: PPUSH
15984: LD_EXP 39
15988: PPUSH
15989: CALL_OW 380
// un := CreateHuman ;
15993: LD_ADDR_VAR 0 3
15997: PUSH
15998: CALL_OW 44
16002: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16003: LD_VAR 0 3
16007: PPUSH
16008: LD_INT 162
16010: PPUSH
16011: CALL_OW 52
// end ;
16015: GO 15948
16017: POP
16018: POP
// uc_nation := 3 ;
16019: LD_ADDR_OWVAR 21
16023: PUSH
16024: LD_INT 3
16026: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16027: LD_ADDR_OWVAR 37
16031: PUSH
16032: LD_INT 21
16034: ST_TO_ADDR
// vc_engine := engine_siberite ;
16035: LD_ADDR_OWVAR 39
16039: PUSH
16040: LD_INT 3
16042: ST_TO_ADDR
// vc_control := control_computer ;
16043: LD_ADDR_OWVAR 38
16047: PUSH
16048: LD_INT 3
16050: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16051: LD_ADDR_OWVAR 40
16055: PUSH
16056: LD_INT 51
16058: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16059: CALL_OW 45
16063: PPUSH
16064: LD_INT 49
16066: PPUSH
16067: LD_INT 13
16069: PPUSH
16070: LD_INT 0
16072: PPUSH
16073: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16077: LD_ADDR_EXP 46
16081: PUSH
16082: LD_INT 22
16084: PUSH
16085: LD_INT 7
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PUSH
16092: LD_INT 30
16094: PUSH
16095: LD_INT 33
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 69
16110: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16111: LD_ADDR_VAR 0 2
16115: PUSH
16116: DOUBLE
16117: LD_INT 1
16119: DEC
16120: ST_TO_ADDR
16121: LD_INT 22
16123: PUSH
16124: LD_INT 7
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: PUSH
16131: LD_INT 30
16133: PUSH
16134: LD_INT 33
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: PUSH
16141: LD_INT 35
16143: PUSH
16144: LD_INT 0
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: LIST
16155: PUSH
16156: EMPTY
16157: LIST
16158: PPUSH
16159: CALL_OW 69
16163: PUSH
16164: FOR_TO
16165: IFFALSE 16225
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16167: LD_INT 22
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PUSH
16177: LD_INT 30
16179: PUSH
16180: LD_INT 33
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: PUSH
16187: LD_INT 35
16189: PUSH
16190: LD_INT 0
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: LIST
16201: PUSH
16202: EMPTY
16203: LIST
16204: PPUSH
16205: CALL_OW 69
16209: PUSH
16210: LD_VAR 0 2
16214: ARRAY
16215: PPUSH
16216: LD_INT 49
16218: PPUSH
16219: CALL_OW 208
16223: GO 16164
16225: POP
16226: POP
// end ;
16227: LD_VAR 0 1
16231: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16232: LD_OWVAR 2
16236: PUSH
16237: LD_INT 1
16239: EQUAL
16240: IFFALSE 17408
16242: GO 16244
16244: DISABLE
16245: LD_INT 0
16247: PPUSH
16248: PPUSH
16249: PPUSH
16250: PPUSH
// begin enable ;
16251: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16252: LD_ADDR_EXP 50
16256: PUSH
16257: LD_INT 22
16259: PUSH
16260: LD_INT 7
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: PUSH
16267: LD_INT 21
16269: PUSH
16270: LD_INT 3
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: PUSH
16277: EMPTY
16278: LIST
16279: LIST
16280: PPUSH
16281: CALL_OW 69
16285: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16286: LD_ADDR_EXP 48
16290: PUSH
16291: LD_INT 164
16293: PUSH
16294: LD_INT 197
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16301: LD_ADDR_EXP 47
16305: PUSH
16306: LD_INT 22
16308: PUSH
16309: LD_INT 7
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: PUSH
16316: LD_INT 30
16318: PUSH
16319: LD_INT 1
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PPUSH
16330: CALL_OW 69
16334: PUSH
16335: LD_INT 1
16337: ARRAY
16338: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16339: LD_ADDR_EXP 49
16343: PUSH
16344: LD_INT 22
16346: PUSH
16347: LD_INT 7
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 30
16356: PUSH
16357: LD_INT 3
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PPUSH
16368: CALL_OW 69
16372: PUSH
16373: LD_INT 1
16375: ARRAY
16376: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16377: LD_INT 22
16379: PUSH
16380: LD_INT 7
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: PUSH
16387: LD_INT 34
16389: PUSH
16390: LD_INT 51
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PPUSH
16401: CALL_OW 69
16405: IFFALSE 16445
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16407: LD_ADDR_EXP 45
16411: PUSH
16412: LD_INT 22
16414: PUSH
16415: LD_INT 7
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 34
16424: PUSH
16425: LD_INT 51
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PPUSH
16436: CALL_OW 69
16440: PUSH
16441: LD_INT 1
16443: ARRAY
16444: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16445: LD_ADDR_EXP 41
16449: PUSH
16450: LD_INT 22
16452: PUSH
16453: LD_INT 7
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: PUSH
16460: LD_INT 25
16462: PUSH
16463: LD_INT 9
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 69
16478: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16479: LD_ADDR_EXP 40
16483: PUSH
16484: LD_INT 22
16486: PUSH
16487: LD_INT 7
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: LD_INT 25
16496: PUSH
16497: LD_INT 2
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PPUSH
16508: CALL_OW 69
16512: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16513: LD_ADDR_EXP 42
16517: PUSH
16518: LD_INT 22
16520: PUSH
16521: LD_INT 7
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: LD_INT 25
16530: PUSH
16531: LD_INT 3
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: PUSH
16538: EMPTY
16539: LIST
16540: LIST
16541: PPUSH
16542: CALL_OW 69
16546: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16547: LD_ADDR_EXP 43
16551: PUSH
16552: LD_INT 22
16554: PUSH
16555: LD_INT 7
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: LD_INT 25
16564: PUSH
16565: LD_INT 4
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PPUSH
16576: CALL_OW 69
16580: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16581: LD_EXP 41
16585: PPUSH
16586: LD_INT 81
16588: PUSH
16589: LD_INT 7
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: PPUSH
16596: CALL_OW 69
16600: PPUSH
16601: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16605: LD_EXP 45
16609: PPUSH
16610: CALL_OW 314
16614: NOT
16615: PUSH
16616: LD_EXP 45
16620: PPUSH
16621: LD_INT 1
16623: PPUSH
16624: CALL_OW 289
16628: PUSH
16629: LD_INT 100
16631: LESS
16632: AND
16633: IFFALSE 16681
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16635: LD_ADDR_VAR 0 4
16639: PUSH
16640: LD_INT 12
16642: PPUSH
16643: CALL_OW 435
16647: ST_TO_ADDR
// if cr then
16648: LD_VAR 0 4
16652: IFFALSE 16681
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16654: LD_EXP 45
16658: PPUSH
16659: LD_VAR 0 4
16663: PUSH
16664: LD_INT 1
16666: ARRAY
16667: PPUSH
16668: LD_VAR 0 4
16672: PUSH
16673: LD_INT 2
16675: ARRAY
16676: PPUSH
16677: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16681: LD_EXP 50
16685: PPUSH
16686: LD_INT 3
16688: PUSH
16689: LD_INT 24
16691: PUSH
16692: LD_INT 1000
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: EMPTY
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 72
16707: IFFALSE 16837
// begin if al_eng then
16709: LD_EXP 40
16713: IFFALSE 16835
// for i = 1 to al_eng do
16715: LD_ADDR_VAR 0 1
16719: PUSH
16720: DOUBLE
16721: LD_INT 1
16723: DEC
16724: ST_TO_ADDR
16725: LD_EXP 40
16729: PUSH
16730: FOR_TO
16731: IFFALSE 16833
// if IsInUnit ( al_eng [ i ] ) then
16733: LD_EXP 40
16737: PUSH
16738: LD_VAR 0 1
16742: ARRAY
16743: PPUSH
16744: CALL_OW 310
16748: IFFALSE 16767
// ComExitBuilding ( al_eng [ i ] ) else
16750: LD_EXP 40
16754: PUSH
16755: LD_VAR 0 1
16759: ARRAY
16760: PPUSH
16761: CALL_OW 122
16765: GO 16831
// if not HasTask ( al_eng [ i ] ) then
16767: LD_EXP 40
16771: PUSH
16772: LD_VAR 0 1
16776: ARRAY
16777: PPUSH
16778: CALL_OW 314
16782: NOT
16783: IFFALSE 16831
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16785: LD_EXP 40
16789: PUSH
16790: LD_VAR 0 1
16794: ARRAY
16795: PPUSH
16796: LD_EXP 50
16800: PPUSH
16801: LD_INT 3
16803: PUSH
16804: LD_INT 24
16806: PUSH
16807: LD_INT 1000
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PPUSH
16818: CALL_OW 72
16822: PUSH
16823: LD_INT 1
16825: ARRAY
16826: PPUSH
16827: CALL_OW 130
16831: GO 16730
16833: POP
16834: POP
// end else
16835: GO 16919
// if al_eng then
16837: LD_EXP 40
16841: IFFALSE 16919
// if not IsInUnit ( al_eng [ 1 ] ) then
16843: LD_EXP 40
16847: PUSH
16848: LD_INT 1
16850: ARRAY
16851: PPUSH
16852: CALL_OW 310
16856: NOT
16857: IFFALSE 16919
// for i = 1 to al_eng do
16859: LD_ADDR_VAR 0 1
16863: PUSH
16864: DOUBLE
16865: LD_INT 1
16867: DEC
16868: ST_TO_ADDR
16869: LD_EXP 40
16873: PUSH
16874: FOR_TO
16875: IFFALSE 16917
// if not IsInUnit ( al_eng [ i ] ) then
16877: LD_EXP 40
16881: PUSH
16882: LD_VAR 0 1
16886: ARRAY
16887: PPUSH
16888: CALL_OW 310
16892: NOT
16893: IFFALSE 16915
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16895: LD_EXP 40
16899: PUSH
16900: LD_VAR 0 1
16904: ARRAY
16905: PPUSH
16906: LD_EXP 47
16910: PPUSH
16911: CALL_OW 120
16915: GO 16874
16917: POP
16918: POP
// if al_vehs then
16919: LD_EXP 44
16923: IFFALSE 17023
// if BuildingStatus ( al_fac ) = bs_idle then
16925: LD_EXP 49
16929: PPUSH
16930: CALL_OW 461
16934: PUSH
16935: LD_INT 2
16937: EQUAL
16938: IFFALSE 17023
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16940: LD_EXP 49
16944: PPUSH
16945: LD_EXP 44
16949: PUSH
16950: LD_INT 1
16952: ARRAY
16953: PPUSH
16954: LD_EXP 44
16958: PUSH
16959: LD_INT 2
16961: ARRAY
16962: PPUSH
16963: LD_EXP 44
16967: PUSH
16968: LD_INT 3
16970: ARRAY
16971: PPUSH
16972: LD_EXP 44
16976: PUSH
16977: LD_INT 4
16979: ARRAY
16980: PPUSH
16981: CALL_OW 125
// for i = 1 to 4 do
16985: LD_ADDR_VAR 0 1
16989: PUSH
16990: DOUBLE
16991: LD_INT 1
16993: DEC
16994: ST_TO_ADDR
16995: LD_INT 4
16997: PUSH
16998: FOR_TO
16999: IFFALSE 17021
// al_vehs := Delete ( al_vehs , 1 ) ;
17001: LD_ADDR_EXP 44
17005: PUSH
17006: LD_EXP 44
17010: PPUSH
17011: LD_INT 1
17013: PPUSH
17014: CALL_OW 3
17018: ST_TO_ADDR
17019: GO 16998
17021: POP
17022: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17023: LD_EXP 38
17027: PUSH
17028: LD_INT 0
17030: EQUAL
17031: PUSH
17032: LD_OWVAR 1
17036: PUSH
17037: LD_INT 23100
17039: MOD
17040: PUSH
17041: LD_INT 0
17043: EQUAL
17044: AND
17045: IFFALSE 17159
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17047: LD_ADDR_VAR 0 1
17051: PUSH
17052: DOUBLE
17053: LD_INT 1
17055: DEC
17056: ST_TO_ADDR
17057: LD_INT 4
17059: PUSH
17060: LD_INT 5
17062: PUSH
17063: LD_INT 6
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: LIST
17070: PUSH
17071: LD_OWVAR 67
17075: ARRAY
17076: PUSH
17077: FOR_TO
17078: IFFALSE 17157
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17080: LD_ADDR_EXP 44
17084: PUSH
17085: LD_EXP 44
17089: PUSH
17090: LD_INT 23
17092: ADD
17093: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17094: LD_ADDR_EXP 44
17098: PUSH
17099: LD_EXP 44
17103: PUSH
17104: LD_INT 1
17106: ADD
17107: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17108: LD_ADDR_EXP 44
17112: PUSH
17113: LD_EXP 44
17117: PUSH
17118: LD_INT 3
17120: ADD
17121: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17122: LD_ADDR_EXP 44
17126: PUSH
17127: LD_EXP 44
17131: PUSH
17132: LD_INT 46
17134: PUSH
17135: LD_INT 47
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: LD_INT 1
17144: PPUSH
17145: LD_INT 2
17147: PPUSH
17148: CALL_OW 12
17152: ARRAY
17153: ADD
17154: ST_TO_ADDR
// end ;
17155: GO 17077
17157: POP
17158: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17159: LD_INT 22
17161: PUSH
17162: LD_INT 7
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: PUSH
17169: LD_INT 34
17171: PUSH
17172: LD_INT 51
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: PPUSH
17183: CALL_OW 69
17187: PUSH
17188: LD_INT 0
17190: EQUAL
17191: IFFALSE 17214
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17193: LD_EXP 49
17197: PPUSH
17198: LD_INT 21
17200: PPUSH
17201: LD_INT 1
17203: PPUSH
17204: LD_INT 3
17206: PPUSH
17207: LD_INT 51
17209: PPUSH
17210: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17214: LD_EXP 38
17218: PUSH
17219: LD_OWVAR 1
17223: PUSH
17224: LD_INT 25200
17226: MOD
17227: PUSH
17228: LD_INT 0
17230: EQUAL
17231: AND
17232: IFFALSE 17295
// begin for i = 1 to al_force do
17234: LD_ADDR_VAR 0 1
17238: PUSH
17239: DOUBLE
17240: LD_INT 1
17242: DEC
17243: ST_TO_ADDR
17244: LD_EXP 38
17248: PUSH
17249: FOR_TO
17250: IFFALSE 17293
// if GetTag ( al_force [ i ] ) <> 11 then
17252: LD_EXP 38
17256: PUSH
17257: LD_VAR 0 1
17261: ARRAY
17262: PPUSH
17263: CALL_OW 110
17267: PUSH
17268: LD_INT 11
17270: NONEQUAL
17271: IFFALSE 17291
// SetTag ( al_force [ i ] , 11 ) ;
17273: LD_EXP 38
17277: PUSH
17278: LD_VAR 0 1
17282: ARRAY
17283: PPUSH
17284: LD_INT 11
17286: PPUSH
17287: CALL_OW 109
17291: GO 17249
17293: POP
17294: POP
// end ; if al_force then
17295: LD_EXP 38
17299: IFFALSE 17408
// for i = 1 to al_force do
17301: LD_ADDR_VAR 0 1
17305: PUSH
17306: DOUBLE
17307: LD_INT 1
17309: DEC
17310: ST_TO_ADDR
17311: LD_EXP 38
17315: PUSH
17316: FOR_TO
17317: IFFALSE 17406
// begin if GetTag ( al_force [ i ] ) = 11 then
17319: LD_EXP 38
17323: PUSH
17324: LD_VAR 0 1
17328: ARRAY
17329: PPUSH
17330: CALL_OW 110
17334: PUSH
17335: LD_INT 11
17337: EQUAL
17338: IFFALSE 17404
// begin if not HasTask ( al_force [ i ] ) then
17340: LD_EXP 38
17344: PUSH
17345: LD_VAR 0 1
17349: ARRAY
17350: PPUSH
17351: CALL_OW 314
17355: NOT
17356: IFFALSE 17404
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17358: LD_EXP 38
17362: PUSH
17363: LD_VAR 0 1
17367: ARRAY
17368: PPUSH
17369: LD_INT 81
17371: PUSH
17372: LD_INT 7
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: PPUSH
17384: LD_EXP 38
17388: PUSH
17389: LD_VAR 0 1
17393: ARRAY
17394: PPUSH
17395: CALL_OW 74
17399: PPUSH
17400: CALL_OW 115
// end ; end ;
17404: GO 17316
17406: POP
17407: POP
// end ; end_of_file
17408: PPOPN 4
17410: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17411: LD_INT 0
17413: PPUSH
17414: PPUSH
17415: PPUSH
17416: PPUSH
17417: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17418: LD_ADDR_EXP 53
17422: PUSH
17423: LD_INT 7
17425: PUSH
17426: LD_INT 6
17428: PUSH
17429: LD_INT 5
17431: PUSH
17432: EMPTY
17433: LIST
17434: LIST
17435: LIST
17436: PUSH
17437: LD_OWVAR 67
17441: ARRAY
17442: ST_TO_ADDR
// ar_force := [ ] ;
17443: LD_ADDR_EXP 52
17447: PUSH
17448: EMPTY
17449: ST_TO_ADDR
// RemoveAlliance ;
17450: CALL 15239 0 0
// RemoveEnvironmentArea ( evn ) ;
17454: LD_INT 17
17456: PPUSH
17457: CALL_OW 355
// your_side := 2 ;
17461: LD_ADDR_OWVAR 2
17465: PUSH
17466: LD_INT 2
17468: ST_TO_ADDR
// uc_side := 2 ;
17469: LD_ADDR_OWVAR 20
17473: PUSH
17474: LD_INT 2
17476: ST_TO_ADDR
// uc_nation := nation_arabian ;
17477: LD_ADDR_OWVAR 21
17481: PUSH
17482: LD_INT 2
17484: ST_TO_ADDR
// hc_gallery :=  ;
17485: LD_ADDR_OWVAR 33
17489: PUSH
17490: LD_STRING 
17492: ST_TO_ADDR
// hc_name :=  ;
17493: LD_ADDR_OWVAR 26
17497: PUSH
17498: LD_STRING 
17500: ST_TO_ADDR
// hc_importance := 0 ;
17501: LD_ADDR_OWVAR 32
17505: PUSH
17506: LD_INT 0
17508: ST_TO_ADDR
// for i = 1 to 15 do
17509: LD_ADDR_VAR 0 2
17513: PUSH
17514: DOUBLE
17515: LD_INT 1
17517: DEC
17518: ST_TO_ADDR
17519: LD_INT 15
17521: PUSH
17522: FOR_TO
17523: IFFALSE 17576
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17525: LD_INT 0
17527: PPUSH
17528: LD_INT 1
17530: PPUSH
17531: LD_INT 4
17533: PPUSH
17534: CALL_OW 12
17538: PPUSH
17539: LD_EXP 53
17543: PPUSH
17544: CALL_OW 380
// un := CreateHuman ;
17548: LD_ADDR_VAR 0 4
17552: PUSH
17553: CALL_OW 44
17557: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17558: LD_ADDR_EXP 52
17562: PUSH
17563: LD_EXP 52
17567: PUSH
17568: LD_VAR 0 4
17572: ADD
17573: ST_TO_ADDR
// end ;
17574: GO 17522
17576: POP
17577: POP
// hc_importance := 100 ;
17578: LD_ADDR_OWVAR 32
17582: PUSH
17583: LD_INT 100
17585: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17586: LD_INT 1
17588: PPUSH
17589: LD_INT 11
17591: PPUSH
17592: LD_EXP 53
17596: PPUSH
17597: CALL_OW 380
// ar_commander := CreateHuman ;
17601: LD_ADDR_EXP 51
17605: PUSH
17606: CALL_OW 44
17610: ST_TO_ADDR
// player_commander := ar_commander ;
17611: LD_ADDR_EXP 10
17615: PUSH
17616: LD_EXP 51
17620: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17621: LD_ADDR_VAR 0 5
17625: PUSH
17626: LD_STRING text
17628: PPUSH
17629: LD_INT 11
17631: PUSH
17632: LD_INT 10
17634: PUSH
17635: LD_INT 9
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: LIST
17642: PUSH
17643: LD_OWVAR 67
17647: ARRAY
17648: PPUSH
17649: LD_INT 11
17651: PUSH
17652: LD_INT 10
17654: PUSH
17655: LD_INT 9
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: LIST
17662: PUSH
17663: LD_OWVAR 67
17667: ARRAY
17668: PPUSH
17669: LD_INT -5
17671: PUSH
17672: LD_EXP 51
17676: PUSH
17677: LD_INT -3
17679: PUSH
17680: LD_INT -2
17682: PUSH
17683: EMPTY
17684: LIST
17685: LIST
17686: LIST
17687: LIST
17688: PUSH
17689: LD_EXP 52
17693: ADD
17694: PPUSH
17695: LD_INT 1
17697: PUSH
17698: LD_INT 3
17700: PUSH
17701: LD_INT 2
17703: PUSH
17704: LD_INT 1
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: PUSH
17711: LD_INT 4
17713: PUSH
17714: LD_INT 1
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PUSH
17721: LD_INT 8
17723: PUSH
17724: EMPTY
17725: LIST
17726: LIST
17727: LIST
17728: LIST
17729: LIST
17730: PPUSH
17731: CALL_OW 42
17735: ST_TO_ADDR
// team := team ^ ar_commander ;
17736: LD_ADDR_VAR 0 5
17740: PUSH
17741: LD_VAR 0 5
17745: PUSH
17746: LD_EXP 51
17750: ADD
17751: ST_TO_ADDR
// for i = 1 to team do
17752: LD_ADDR_VAR 0 2
17756: PUSH
17757: DOUBLE
17758: LD_INT 1
17760: DEC
17761: ST_TO_ADDR
17762: LD_VAR 0 5
17766: PUSH
17767: FOR_TO
17768: IFFALSE 17793
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17770: LD_VAR 0 5
17774: PUSH
17775: LD_VAR 0 2
17779: ARRAY
17780: PPUSH
17781: LD_INT 16
17783: PPUSH
17784: LD_INT 0
17786: PPUSH
17787: CALL_OW 49
17791: GO 17767
17793: POP
17794: POP
// uc_side := 0 ;
17795: LD_ADDR_OWVAR 20
17799: PUSH
17800: LD_INT 0
17802: ST_TO_ADDR
// uc_nation := 0 ;
17803: LD_ADDR_OWVAR 21
17807: PUSH
17808: LD_INT 0
17810: ST_TO_ADDR
// vc_chassis := 31 ;
17811: LD_ADDR_OWVAR 37
17815: PUSH
17816: LD_INT 31
17818: ST_TO_ADDR
// vc_control := control_rider ;
17819: LD_ADDR_OWVAR 38
17823: PUSH
17824: LD_INT 4
17826: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17827: CALL_OW 45
17831: PPUSH
17832: LD_INT 96
17834: PPUSH
17835: LD_INT 20
17837: PPUSH
17838: LD_INT 0
17840: PPUSH
17841: CALL_OW 48
// end ;
17845: LD_VAR 0 1
17849: RET
