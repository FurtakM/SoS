// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareTrigger ;
   8: CALL 33 0 0
// PrepareVulcanoBase ;
  12: CALL 873 0 0
// PrepareRussian ;
  16: CALL 3449 0 0
// PrepareLegion ;
  20: CALL 6966 0 0
// Action ;
  24: CALL 10693 0 0
// InitArt ;
  28: CALL 194 0 0
// end ;
  32: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  33: LD_INT 0
  35: PPUSH
// base_captured := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// russian_prepared := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// ru_can_attack := false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// ru_sib_bomb := false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// chance_to_bomb := [ 5 , 15 , 30 ] [ Difficulty ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 5
  75: PUSH
  76: LD_INT 15
  78: PUSH
  79: LD_INT 30
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: ST_TO_ADDR
// player_res_art := false ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// player_artifact_ready := false ;
 101: LD_ADDR_EXP 7
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// art_icon := art_use_atom ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 7
 116: ST_TO_ADDR
// time_res_art := 600 ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 600
 124: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 21000
 132: ST_TO_ADDR
// mine_vulc := false ;
 133: LD_ADDR_EXP 12
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// medal_enabled := false ;
 141: LD_ADDR_EXP 13
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// dead_counter := 0 ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// kill_counter := 0 ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// veh_counter := 0 ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// tech_counter := 0 ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// end ;
 189: LD_VAR 0 1
 193: RET
// function InitArt ; begin
 194: LD_INT 0
 196: PPUSH
// SetArtifactRes ( your_side , true ) ;
 197: LD_OWVAR 2
 201: PPUSH
 202: LD_INT 1
 204: PPUSH
 205: CALL_OW 467
// end ; end_of_file
 209: LD_VAR 0 1
 213: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 214: LD_INT 0
 216: PPUSH
 217: PPUSH
 218: PPUSH
 219: PPUSH
 220: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 7
 228: PUSH
 229: LD_INT 6
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: PUSH
 240: LD_OWVAR 67
 244: ARRAY
 245: ST_TO_ADDR
// us_force := [ ] ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 253: LD_INT 17
 255: PPUSH
 256: CALL_OW 355
// PrepareAllianceAI ( ) ;
 260: CALL 15364 0 0
// uc_side := 1 ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// uc_nation := nation_american ;
 272: LD_ADDR_OWVAR 21
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// hc_gallery :=  ;
 280: LD_ADDR_OWVAR 33
 284: PUSH
 285: LD_STRING 
 287: ST_TO_ADDR
// hc_name :=  ;
 288: LD_ADDR_OWVAR 26
 292: PUSH
 293: LD_STRING 
 295: ST_TO_ADDR
// hc_importance := 0 ;
 296: LD_ADDR_OWVAR 32
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// for i = 1 to 11 do
 304: LD_ADDR_VAR 0 2
 308: PUSH
 309: DOUBLE
 310: LD_INT 1
 312: DEC
 313: ST_TO_ADDR
 314: LD_INT 11
 316: PUSH
 317: FOR_TO
 318: IFFALSE 371
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 320: LD_INT 0
 322: PPUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 4
 328: PPUSH
 329: CALL_OW 12
 333: PPUSH
 334: LD_EXP 21
 338: PPUSH
 339: CALL_OW 380
// un := CreateHuman ;
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: CALL_OW 44
 352: ST_TO_ADDR
// us_force := us_force ^ un ;
 353: LD_ADDR_EXP 20
 357: PUSH
 358: LD_EXP 20
 362: PUSH
 363: LD_VAR 0 4
 367: ADD
 368: ST_TO_ADDR
// end ;
 369: GO 317
 371: POP
 372: POP
// hc_importance := 100 ;
 373: LD_ADDR_OWVAR 32
 377: PUSH
 378: LD_INT 100
 380: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: LD_EXP 21
 391: PPUSH
 392: CALL_OW 380
// us_commander := CreateHuman ;
 396: LD_ADDR_EXP 19
 400: PUSH
 401: CALL_OW 44
 405: ST_TO_ADDR
// player_commander := us_commander ;
 406: LD_ADDR_EXP 10
 410: PUSH
 411: LD_EXP 19
 415: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 416: LD_ADDR_VAR 0 5
 420: PUSH
 421: LD_STRING text
 423: PPUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 5
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_OWVAR 67
 442: ARRAY
 443: PPUSH
 444: LD_INT 6
 446: PUSH
 447: LD_INT 5
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_OWVAR 67
 462: ARRAY
 463: PPUSH
 464: LD_INT -5
 466: PUSH
 467: LD_EXP 19
 471: PUSH
 472: LD_INT -3
 474: PUSH
 475: LD_INT -2
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: LIST
 483: PUSH
 484: LD_EXP 20
 488: ADD
 489: PPUSH
 490: LD_INT 1
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 2
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 4
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PUSH
 516: LD_INT 5
 518: PUSH
 519: LD_INT 5
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL_OW 42
 548: ST_TO_ADDR
// team := team ^ us_commander ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: LD_EXP 19
 563: ADD
 564: ST_TO_ADDR
// for i = 1 to team do
 565: LD_ADDR_VAR 0 2
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 5
 579: PUSH
 580: FOR_TO
 581: IFFALSE 606
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 583: LD_VAR 0 5
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PPUSH
 594: LD_INT 1
 596: PPUSH
 597: LD_INT 0
 599: PPUSH
 600: CALL_OW 49
 604: GO 580
 606: POP
 607: POP
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 613: LD_OWVAR 1
 617: PUSH
 618: LD_INT 73500
 620: LESS
 621: IFFALSE 648
 623: GO 625
 625: DISABLE
// begin enable ;
 626: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 627: LD_INT 1
 629: PPUSH
 630: LD_INT 5
 632: PPUSH
 633: CALL_OW 12
 637: PPUSH
 638: LD_INT 24
 640: PPUSH
 641: LD_INT 1
 643: PPUSH
 644: CALL_OW 55
// end ;
 648: END
// every 1 1$10 do var time , p , l ;
 649: GO 651
 651: DISABLE
 652: LD_INT 0
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin time := 0 0$44 ;
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 1540
 664: ST_TO_ADDR
// l := 0 ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: LD_INT 0
 672: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 673: LD_VAR 0 1
 677: PPUSH
 678: CALL_OW 67
// l := l + 1 ;
 682: LD_ADDR_VAR 0 3
 686: PUSH
 687: LD_VAR 0 3
 691: PUSH
 692: LD_INT 1
 694: PLUS
 695: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 696: LD_INT 12
 698: PPUSH
 699: CALL_OW 435
 703: PUSH
 704: LD_INT 30
 706: LESS
 707: IFFALSE 766
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 709: LD_INT 1
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL_OW 12
 719: PPUSH
 720: LD_INT 12
 722: PPUSH
 723: LD_INT 1
 725: PPUSH
 726: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 730: LD_INT 1155
 732: PPUSH
 733: LD_INT 1540
 735: PPUSH
 736: CALL_OW 12
 740: PPUSH
 741: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 745: LD_INT 1
 747: PPUSH
 748: LD_INT 5
 750: PPUSH
 751: CALL_OW 12
 755: PPUSH
 756: LD_INT 12
 758: PPUSH
 759: LD_INT 1
 761: PPUSH
 762: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 766: LD_ADDR_VAR 0 2
 770: PUSH
 771: LD_INT 0
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 12
 781: ST_TO_ADDR
// if p then
 782: LD_VAR 0 2
 786: IFFALSE 821
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 788: LD_INT 105
 790: PPUSH
 791: LD_INT 350
 793: PPUSH
 794: CALL_OW 12
 798: PPUSH
 799: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 803: LD_INT 1
 805: PPUSH
 806: LD_INT 4
 808: PPUSH
 809: CALL_OW 12
 813: PPUSH
 814: LD_INT 1
 816: PPUSH
 817: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 15
 828: PUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 11
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: PUSH
 840: LD_OWVAR 67
 844: ARRAY
 845: MOD
 846: PUSH
 847: LD_INT 0
 849: EQUAL
 850: IFFALSE 866
// time := time + 2 2$00 ;
 852: LD_ADDR_VAR 0 1
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 4200
 864: PLUS
 865: ST_TO_ADDR
// end until false ;
 866: LD_INT 0
 868: IFFALSE 673
// end ; end_of_file
 870: PPOPN 3
 872: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
 882: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_INT 22
 890: PUSH
 891: LD_INT 4
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 69
 916: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_INT 470
 924: PUSH
 925: LD_INT 370
 927: PUSH
 928: LD_INT 290
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_OWVAR 67
 940: ARRAY
 941: ST_TO_ADDR
// case Difficulty of 2 :
 942: LD_OWVAR 67
 946: PUSH
 947: LD_INT 2
 949: DOUBLE
 950: EQUAL
 951: IFTRUE 955
 953: GO 986
 955: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 956: LD_VAR 0 3
 960: PPUSH
 961: LD_INT 30
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PPUSH
 971: CALL_OW 72
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 65
// end ; 3 :
 984: GO 1062
 986: LD_INT 3
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1061
 994: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 995: LD_VAR 0 3
 999: PPUSH
1000: LD_INT 30
1002: PUSH
1003: LD_INT 32
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 72
1014: PUSH
1015: LD_INT 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1023: LD_VAR 0 3
1027: PPUSH
1028: LD_INT 30
1030: PUSH
1031: LD_INT 27
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: PPUSH
1038: CALL_OW 72
1042: PUSH
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: CALL_OW 12
1053: ARRAY
1054: PPUSH
1055: CALL_OW 65
// end ; end ;
1059: GO 1062
1061: POP
// for i = 1 to filter do
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: DOUBLE
1068: LD_INT 1
1070: DEC
1071: ST_TO_ADDR
1072: LD_VAR 0 3
1076: PUSH
1077: FOR_TO
1078: IFFALSE 1115
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1080: LD_VAR 0 3
1084: PUSH
1085: LD_VAR 0 2
1089: ARRAY
1090: PPUSH
1091: LD_VAR 0 4
1095: PUSH
1096: LD_INT 29
1098: NEG
1099: PPUSH
1100: LD_INT 29
1102: PPUSH
1103: CALL_OW 12
1107: PLUS
1108: PPUSH
1109: CALL_OW 234
1113: GO 1077
1115: POP
1116: POP
// SetBName ( us_depot , Vulcano1 ) ;
1117: LD_INT 50
1119: PPUSH
1120: LD_STRING Vulcano1
1122: PPUSH
1123: CALL_OW 500
// hc_importance := 0 ;
1127: LD_ADDR_OWVAR 32
1131: PUSH
1132: LD_INT 0
1134: ST_TO_ADDR
// uc_side := 3 ;
1135: LD_ADDR_OWVAR 20
1139: PUSH
1140: LD_INT 3
1142: ST_TO_ADDR
// uc_nation := nation_russian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 3
1150: ST_TO_ADDR
// russian_in_base := [ ] ;
1151: LD_ADDR_VAR 0 8
1155: PUSH
1156: EMPTY
1157: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1158: LD_ADDR_VAR 0 6
1162: PUSH
1163: LD_INT 82
1165: PPUSH
1166: LD_INT 137
1168: PPUSH
1169: LD_INT 106
1171: PPUSH
1172: LD_INT 152
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL 1555 0 5
1182: ST_TO_ADDR
// p := 1 ;
1183: LD_ADDR_VAR 0 7
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: DOUBLE
1197: LD_INT 1
1199: DEC
1200: ST_TO_ADDR
1201: LD_INT 6
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_OWVAR 67
1219: ARRAY
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1334
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1224: LD_INT 0
1226: PPUSH
1227: LD_INT 1
1229: PPUSH
1230: LD_INT 4
1232: PUSH
1233: LD_INT 5
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_OWVAR 67
1248: ARRAY
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1264: LD_ADDR_VAR 0 8
1268: PUSH
1269: LD_VAR 0 8
1273: PUSH
1274: LD_VAR 0 5
1278: ADD
1279: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1280: LD_VAR 0 5
1284: PPUSH
1285: LD_VAR 0 6
1289: PUSH
1290: LD_VAR 0 7
1294: ARRAY
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_VAR 0 7
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: ARRAY
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL_OW 48
// p := p + 2 ;
1318: LD_ADDR_VAR 0 7
1322: PUSH
1323: LD_VAR 0 7
1327: PUSH
1328: LD_INT 2
1330: PLUS
1331: ST_TO_ADDR
// end ;
1332: GO 1221
1334: POP
1335: POP
// end ;
1336: LD_VAR 0 1
1340: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1341: LD_INT 50
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: CALL 2045 0 2
1351: PUSH
1352: LD_INT 40
1354: LESS
1355: IFFALSE 1552
1357: GO 1359
1359: DISABLE
1360: LD_INT 0
1362: PPUSH
1363: PPUSH
// begin uc_side := 4 ;
1364: LD_ADDR_OWVAR 20
1368: PUSH
1369: LD_INT 4
1371: ST_TO_ADDR
// uc_nation := nation_american ;
1372: LD_ADDR_OWVAR 21
1376: PUSH
1377: LD_INT 1
1379: ST_TO_ADDR
// hc_importance := 0 ;
1380: LD_ADDR_OWVAR 32
1384: PUSH
1385: LD_INT 0
1387: ST_TO_ADDR
// for i = 1 to 7 do
1388: LD_ADDR_VAR 0 1
1392: PUSH
1393: DOUBLE
1394: LD_INT 1
1396: DEC
1397: ST_TO_ADDR
1398: LD_INT 7
1400: PUSH
1401: FOR_TO
1402: IFFALSE 1466
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1404: LD_INT 0
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: CALL_OW 12
1417: PPUSH
1418: LD_EXP 21
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1437: LD_VAR 0 2
1441: PPUSH
1442: LD_INT 7
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// SetLives ( un , 10 ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_INT 10
1459: PPUSH
1460: CALL_OW 234
// end ;
1464: GO 1401
1466: POP
1467: POP
// for i = 1 to 5 do
1468: LD_ADDR_VAR 0 1
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 5
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1550
// begin PrepareHuman ( false , 4 , us_skill ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_INT 4
1489: PPUSH
1490: LD_EXP 21
1494: PPUSH
1495: CALL_OW 380
// SetDir ( un , 1 ) ;
1499: LD_VAR 0 2
1503: PPUSH
1504: LD_INT 1
1506: PPUSH
1507: CALL_OW 233
// un := CreateHuman ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: CALL_OW 44
1520: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1521: LD_VAR 0 2
1525: PPUSH
1526: LD_INT 23
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// SetLives ( un , 10 ) ;
1536: LD_VAR 0 2
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: CALL_OW 234
// end ;
1548: GO 1481
1550: POP
1551: POP
// end ; end_of_file
1552: PPOPN 2
1554: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1555: LD_INT 0
1557: PPUSH
1558: PPUSH
1559: PPUSH
// list := [ ] ;
1560: LD_ADDR_VAR 0 7
1564: PUSH
1565: EMPTY
1566: ST_TO_ADDR
// for i = 1 to num do
1567: LD_ADDR_VAR 0 8
1571: PUSH
1572: DOUBLE
1573: LD_INT 1
1575: DEC
1576: ST_TO_ADDR
1577: LD_VAR 0 5
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1639
// begin list := list ^ Rand ( x1 , x2 ) ;
1585: LD_ADDR_VAR 0 7
1589: PUSH
1590: LD_VAR 0 7
1594: PUSH
1595: LD_VAR 0 1
1599: PPUSH
1600: LD_VAR 0 3
1604: PPUSH
1605: CALL_OW 12
1609: ADD
1610: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1611: LD_ADDR_VAR 0 7
1615: PUSH
1616: LD_VAR 0 7
1620: PUSH
1621: LD_VAR 0 2
1625: PPUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: CALL_OW 12
1635: ADD
1636: ST_TO_ADDR
// end ;
1637: GO 1582
1639: POP
1640: POP
// result := list ;
1641: LD_ADDR_VAR 0 6
1645: PUSH
1646: LD_VAR 0 7
1650: ST_TO_ADDR
// end ;
1651: LD_VAR 0 6
1655: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1656: LD_INT 0
1658: PPUSH
1659: PPUSH
1660: PPUSH
1661: PPUSH
// c := Rand ( 1 , 3 ) ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_INT 1
1669: PPUSH
1670: LD_INT 3
1672: PPUSH
1673: CALL_OW 12
1677: ST_TO_ADDR
// for i = 1 to list do
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: DOUBLE
1684: LD_INT 1
1686: DEC
1687: ST_TO_ADDR
1688: LD_VAR 0 1
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1876
// for ta in filter do
1696: LD_ADDR_VAR 0 4
1700: PUSH
1701: LD_VAR 0 2
1705: PUSH
1706: FOR_IN
1707: IFFALSE 1872
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1709: LD_VAR 0 1
1713: PUSH
1714: LD_VAR 0 6
1718: ARRAY
1719: PPUSH
1720: LD_VAR 0 4
1724: PPUSH
1725: CALL_OW 296
1729: PUSH
1730: LD_INT 15
1732: LESSEQUAL
1733: IFFALSE 1870
// begin case c of 1 :
1735: LD_VAR 0 5
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1786
1748: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1749: LD_VAR 0 1
1753: PUSH
1754: LD_VAR 0 6
1758: ARRAY
1759: PPUSH
1760: LD_VAR 0 4
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 154
1784: GO 1870
1786: LD_INT 2
1788: DOUBLE
1789: EQUAL
1790: IFTRUE 1794
1792: GO 1858
1794: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1795: LD_VAR 0 1
1799: PUSH
1800: LD_VAR 0 6
1804: ARRAY
1805: PPUSH
1806: LD_VAR 0 4
1810: PPUSH
1811: CALL_OW 250
1815: PUSH
1816: LD_INT 1
1818: NEG
1819: PPUSH
1820: LD_INT 1
1822: PPUSH
1823: CALL_OW 12
1827: PLUS
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: CALL_OW 251
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: CALL_OW 12
1850: PLUS
1851: PPUSH
1852: CALL_OW 153
1856: GO 1870
1858: LD_INT 3
1860: DOUBLE
1861: EQUAL
1862: IFTRUE 1866
1864: GO 1869
1866: POP
// ; end ;
1867: GO 1870
1869: POP
// end ; end ;
1870: GO 1706
1872: POP
1873: POP
1874: GO 1693
1876: POP
1877: POP
// end ;
1878: LD_VAR 0 3
1882: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
// for i = 1 to n do
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: DOUBLE
1894: LD_INT 1
1896: DEC
1897: ST_TO_ADDR
1898: LD_VAR 0 1
1902: PUSH
1903: FOR_TO
1904: IFFALSE 2038
// begin uc_side := 0 ;
1906: LD_ADDR_OWVAR 20
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// uc_nation := 0 ;
1914: LD_ADDR_OWVAR 21
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// hc_class := class_apeman ;
1922: LD_ADDR_OWVAR 28
1926: PUSH
1927: LD_INT 12
1929: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1930: LD_ADDR_OWVAR 31
1934: PUSH
1935: LD_INT 0
1937: PUSH
1938: LD_INT 0
1940: PUSH
1941: LD_INT 0
1943: PUSH
1944: LD_INT 0
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: ST_TO_ADDR
// hc_name :=  ;
1953: LD_ADDR_OWVAR 26
1957: PUSH
1958: LD_STRING 
1960: ST_TO_ADDR
// hc_gallery :=  ;
1961: LD_ADDR_OWVAR 33
1965: PUSH
1966: LD_STRING 
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// un := CreateHuman ;
1977: LD_ADDR_VAR 0 3
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1987: LD_VAR 0 3
1991: PPUSH
1992: LD_INT 19
1994: PUSH
1995: LD_INT 20
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PPUSH
2014: LD_INT 0
2016: PPUSH
2017: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2021: LD_INT 1155
2023: PPUSH
2024: LD_INT 5355
2026: PPUSH
2027: CALL_OW 12
2031: PPUSH
2032: CALL_OW 67
// end ;
2036: GO 1903
2038: POP
2039: POP
// end ;
2040: LD_VAR 0 2
2044: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2050: LD_ADDR_VAR 0 4
2054: PUSH
2055: LD_INT 22
2057: PUSH
2058: LD_VAR 0 2
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 74
2081: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2082: LD_ADDR_VAR 0 5
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_VAR 0 4
2096: PPUSH
2097: CALL_OW 296
2101: ST_TO_ADDR
// if dist >= 9999 then
2102: LD_VAR 0 5
2106: PUSH
2107: LD_INT 9999
2109: GREATEREQUAL
2110: IFFALSE 2123
// result := - 1 else
2112: LD_ADDR_VAR 0 3
2116: PUSH
2117: LD_INT 1
2119: NEG
2120: ST_TO_ADDR
2121: GO 2133
// result := dist ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 5
2132: ST_TO_ADDR
// end ;
2133: LD_VAR 0 3
2137: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2138: LD_INT 0
2140: PPUSH
2141: PPUSH
2142: PPUSH
2143: PPUSH
// tmp := 9999 ;
2144: LD_ADDR_VAR 0 5
2148: PUSH
2149: LD_INT 9999
2151: ST_TO_ADDR
// for i = 1 to plist do
2152: LD_ADDR_VAR 0 4
2156: PUSH
2157: DOUBLE
2158: LD_INT 1
2160: DEC
2161: ST_TO_ADDR
2162: LD_VAR 0 1
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2242
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2170: LD_VAR 0 1
2174: PUSH
2175: LD_VAR 0 4
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 2
2185: PPUSH
2186: CALL 2045 0 2
2190: PUSH
2191: LD_VAR 0 5
2195: LESS
2196: IFFALSE 2240
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 1
2207: PUSH
2208: LD_VAR 0 4
2212: ARRAY
2213: PPUSH
2214: LD_VAR 0 2
2218: PPUSH
2219: CALL 2045 0 2
2223: ST_TO_ADDR
// unit := plist [ i ] ;
2224: LD_ADDR_VAR 0 6
2228: PUSH
2229: LD_VAR 0 1
2233: PUSH
2234: LD_VAR 0 4
2238: ARRAY
2239: ST_TO_ADDR
// end ;
2240: GO 2167
2242: POP
2243: POP
// result := unit ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: LD_VAR 0 6
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 3
2258: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2266: LD_ADDR_VAR 0 2
2270: PUSH
2271: LD_INT 1000
2273: PUSH
2274: LD_INT 2500
2276: PUSH
2277: LD_INT 5000
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: LD_OWVAR 67
2289: ARRAY
2290: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2291: LD_ADDR_VAR 0 2
2295: PUSH
2296: LD_VAR 0 2
2300: PUSH
2301: LD_INT 1
2303: NEG
2304: PUSH
2305: LD_INT 22
2307: PUSH
2308: LD_OWVAR 2
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: MUL
2336: PUSH
2337: LD_INT 30
2339: MUL
2340: PLUS
2341: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2342: LD_ADDR_VAR 0 2
2346: PUSH
2347: LD_VAR 0 2
2351: PUSH
2352: LD_EXP 15
2356: PUSH
2357: LD_INT 10
2359: MUL
2360: PLUS
2361: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2362: LD_ADDR_VAR 0 2
2366: PUSH
2367: LD_VAR 0 2
2371: PUSH
2372: LD_INT 1
2374: NEG
2375: PUSH
2376: LD_EXP 15
2380: MUL
2381: PUSH
2382: LD_INT 20
2384: MUL
2385: PLUS
2386: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_INT 1
2399: NEG
2400: PUSH
2401: LD_OWVAR 1
2405: PUSH
2406: LD_INT 35
2408: DIVREAL
2409: PUSH
2410: LD_INT 60
2412: DIVREAL
2413: MUL
2414: PUSH
2415: LD_INT 25
2417: MUL
2418: PLUS
2419: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: LD_VAR 0 2
2429: PUSH
2430: LD_EXP 17
2434: PUSH
2435: LD_INT 15
2437: MUL
2438: PLUS
2439: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2440: LD_ADDR_VAR 0 2
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: NEG
2453: PUSH
2454: LD_EXP 18
2458: MUL
2459: PUSH
2460: LD_INT 1000
2462: MUL
2463: PLUS
2464: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 16
2479: PUSH
2480: LD_INT 5
2482: MUL
2483: PLUS
2484: ST_TO_ADDR
// result := points ;
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_VAR 0 2
2494: ST_TO_ADDR
// end ; end_of_file
2495: LD_VAR 0 1
2499: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2500: LD_VAR 0 1
2504: PPUSH
2505: CALL_OW 255
2509: PUSH
2510: LD_OWVAR 2
2514: EQUAL
2515: IFFALSE 2531
// dead_counter := dead_counter + 1 ;
2517: LD_ADDR_EXP 14
2521: PUSH
2522: LD_EXP 14
2526: PUSH
2527: LD_INT 1
2529: PLUS
2530: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 255
2540: PUSH
2541: LD_INT 81
2543: PUSH
2544: LD_OWVAR 2
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: IN
2558: IFFALSE 2574
// kill_counter := kill_counter + 1 ;
2560: LD_ADDR_EXP 15
2564: PUSH
2565: LD_EXP 15
2569: PUSH
2570: LD_INT 1
2572: PLUS
2573: ST_TO_ADDR
// if un = player_commander then
2574: LD_VAR 0 1
2578: PUSH
2579: LD_EXP 10
2583: EQUAL
2584: IFFALSE 2593
// YouLost ( vulcano-lost ) ;
2586: LD_STRING vulcano-lost
2588: PPUSH
2589: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2593: LD_VAR 0 1
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_INT 3
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: PUSH
2608: LD_INT 21
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PPUSH
2622: CALL_OW 69
2626: IN
2627: IFFALSE 2743
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2629: LD_VAR 0 1
2633: PPUSH
2634: CALL_OW 266
2638: PUSH
2639: LD_INT 33
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 266
2652: PUSH
2653: LD_INT 28
2655: EQUAL
2656: OR
2657: IFFALSE 2743
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2659: LD_ADDR_EXP 26
2663: PUSH
2664: LD_EXP 26
2668: PUSH
2669: LD_VAR 0 1
2673: PPUSH
2674: CALL_OW 266
2678: ADD
2679: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2680: LD_ADDR_EXP 26
2684: PUSH
2685: LD_EXP 26
2689: PUSH
2690: LD_VAR 0 1
2694: PPUSH
2695: CALL_OW 250
2699: ADD
2700: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2701: LD_ADDR_EXP 26
2705: PUSH
2706: LD_EXP 26
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 251
2720: ADD
2721: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2722: LD_ADDR_EXP 26
2726: PUSH
2727: LD_EXP 26
2731: PUSH
2732: LD_VAR 0 1
2736: PPUSH
2737: CALL_OW 254
2741: ADD
2742: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2743: LD_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 8
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: IN
2777: IFFALSE 2921
// begin if GetBType ( un ) = b_barracks then
2779: LD_VAR 0 1
2783: PPUSH
2784: CALL_OW 266
2788: PUSH
2789: LD_INT 5
2791: EQUAL
2792: IFFALSE 2810
// legion_blist := legion_blist ^ b_armoury else
2794: LD_ADDR_EXP 34
2798: PUSH
2799: LD_EXP 34
2803: PUSH
2804: LD_INT 4
2806: ADD
2807: ST_TO_ADDR
2808: GO 2858
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2810: LD_VAR 0 1
2814: PPUSH
2815: CALL_OW 266
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 6
2825: PUSH
2826: LD_INT 8
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: IN
2834: NOT
2835: IFFALSE 2858
// legion_blist := legion_blist ^ GetBType ( un ) ;
2837: LD_ADDR_EXP 34
2841: PUSH
2842: LD_EXP 34
2846: PUSH
2847: LD_VAR 0 1
2851: PPUSH
2852: CALL_OW 266
2856: ADD
2857: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2858: LD_ADDR_EXP 34
2862: PUSH
2863: LD_EXP 34
2867: PUSH
2868: LD_VAR 0 1
2872: PPUSH
2873: CALL_OW 250
2877: ADD
2878: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2879: LD_ADDR_EXP 34
2883: PUSH
2884: LD_EXP 34
2888: PUSH
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 251
2898: ADD
2899: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2900: LD_ADDR_EXP 34
2904: PUSH
2905: LD_EXP 34
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: CALL_OW 254
2919: ADD
2920: ST_TO_ADDR
// end ; if un in legion_force then
2921: LD_VAR 0 1
2925: PUSH
2926: LD_EXP 31
2930: IN
2931: IFFALSE 2949
// legion_force := legion_force diff un ;
2933: LD_ADDR_EXP 31
2937: PUSH
2938: LD_EXP 31
2942: PUSH
2943: LD_VAR 0 1
2947: DIFF
2948: ST_TO_ADDR
// if un in ru_force then
2949: LD_VAR 0 1
2953: PUSH
2954: LD_EXP 23
2958: IN
2959: IFFALSE 2977
// ru_force := ru_force diff un ;
2961: LD_ADDR_EXP 23
2965: PUSH
2966: LD_EXP 23
2970: PUSH
2971: LD_VAR 0 1
2975: DIFF
2976: ST_TO_ADDR
// if un in al_force then
2977: LD_VAR 0 1
2981: PUSH
2982: LD_EXP 38
2986: IN
2987: IFFALSE 3005
// al_force := al_force diff un ;
2989: LD_ADDR_EXP 38
2993: PUSH
2994: LD_EXP 38
2998: PUSH
2999: LD_VAR 0 1
3003: DIFF
3004: ST_TO_ADDR
// end ;
3005: PPOPN 1
3007: END
// on BuildingComplete ( b ) do var i ;
3008: LD_INT 0
3010: PPUSH
// begin if GetSide ( b ) = 8 then
3011: LD_VAR 0 1
3015: PPUSH
3016: CALL_OW 255
3020: PUSH
3021: LD_INT 8
3023: EQUAL
3024: IFFALSE 3064
// for i = 1 to 4 do
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: DOUBLE
3032: LD_INT 1
3034: DEC
3035: ST_TO_ADDR
3036: LD_INT 4
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3062
// legion_blist := Delete ( legion_blist , 1 ) ;
3042: LD_ADDR_EXP 34
3046: PUSH
3047: LD_EXP 34
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: CALL_OW 3
3059: ST_TO_ADDR
3060: GO 3039
3062: POP
3063: POP
// if GetSide ( b ) = 3 then
3064: LD_VAR 0 1
3068: PPUSH
3069: CALL_OW 255
3073: PUSH
3074: LD_INT 3
3076: EQUAL
3077: IFFALSE 3117
// for i = 1 to 4 do
3079: LD_ADDR_VAR 0 2
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_INT 4
3091: PUSH
3092: FOR_TO
3093: IFFALSE 3115
// ru_blist := Delete ( ru_blist , 1 ) ;
3095: LD_ADDR_EXP 26
3099: PUSH
3100: LD_EXP 26
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: CALL_OW 3
3112: ST_TO_ADDR
3113: GO 3092
3115: POP
3116: POP
// end ;
3117: PPOPN 2
3119: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3120: LD_VAR 0 1
3124: PPUSH
3125: CALL_OW 264
3129: PUSH
3130: LD_INT 51
3132: PUSH
3133: LD_INT 48
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: IN
3140: NOT
3141: IFFALSE 3189
// begin if GetSide ( veh ) = 3 then
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 255
3152: PUSH
3153: LD_INT 3
3155: EQUAL
3156: IFFALSE 3189
// begin ComMoveXY ( veh , 149 , 8 ) ;
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 149
3165: PPUSH
3166: LD_INT 8
3168: PPUSH
3169: CALL_OW 111
// ru_force := ru_force ^ veh ;
3173: LD_ADDR_EXP 23
3177: PUSH
3178: LD_EXP 23
3182: PUSH
3183: LD_VAR 0 1
3187: ADD
3188: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 264
3198: PUSH
3199: LD_INT 32
3201: PUSH
3202: LD_INT 31
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: IN
3209: NOT
3210: IFFALSE 3243
// begin if GetSide ( veh ) = 8 then
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 255
3221: PUSH
3222: LD_INT 8
3224: EQUAL
3225: IFFALSE 3243
// legion_force := legion_force ^ veh ;
3227: LD_ADDR_EXP 31
3231: PUSH
3232: LD_EXP 31
3236: PUSH
3237: LD_VAR 0 1
3241: ADD
3242: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3243: LD_VAR 0 1
3247: PPUSH
3248: CALL_OW 255
3252: PUSH
3253: LD_INT 7
3255: EQUAL
3256: PUSH
3257: LD_OWVAR 2
3261: PUSH
3262: LD_INT 7
3264: NONEQUAL
3265: AND
3266: IFFALSE 3284
// al_force := al_force ^ veh ;
3268: LD_ADDR_EXP 38
3272: PUSH
3273: LD_EXP 38
3277: PUSH
3278: LD_VAR 0 1
3282: ADD
3283: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3284: LD_VAR 0 1
3288: PPUSH
3289: CALL_OW 255
3293: PUSH
3294: LD_OWVAR 2
3298: EQUAL
3299: IFFALSE 3315
// veh_counter := veh_counter + 1 ;
3301: LD_ADDR_EXP 16
3305: PUSH
3306: LD_EXP 16
3310: PUSH
3311: LD_INT 1
3313: PLUS
3314: ST_TO_ADDR
// end ;
3315: PPOPN 2
3317: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3318: LD_VAR 0 1
3322: PPUSH
3323: CALL_OW 255
3327: PUSH
3328: LD_OWVAR 2
3332: NONEQUAL
3333: IFFALSE 3349
// sib_contamin_counter := sib_contamin_counter + 1 ;
3335: LD_ADDR_EXP 18
3339: PUSH
3340: LD_EXP 18
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: ST_TO_ADDR
// end ;
3349: PPOPN 3
3351: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3352: LD_VAR 0 2
3356: PPUSH
3357: CALL_OW 255
3361: PUSH
3362: LD_OWVAR 2
3366: EQUAL
3367: IFFALSE 3383
// tech_counter := tech_counter + 1 ;
3369: LD_ADDR_EXP 17
3373: PUSH
3374: LD_EXP 17
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: ST_TO_ADDR
// end ;
3383: PPOPN 2
3385: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3386: LD_INT 25
3388: PUSH
3389: LD_INT 12
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 69
3400: PUSH
3401: LD_INT 9
3403: LESS
3404: IFFALSE 3446
3406: GO 3408
3408: DISABLE
3409: LD_INT 0
3411: PPUSH
// begin enable ;
3412: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3413: LD_ADDR_VAR 0 1
3417: PUSH
3418: LD_INT 25
3420: PUSH
3421: LD_INT 12
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PPUSH
3428: CALL_OW 69
3432: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3433: LD_INT 8
3435: PUSH
3436: LD_VAR 0 1
3440: MINUS
3441: PPUSH
3442: CALL 1883 0 1
// end ; end_of_file
3446: PPOPN 1
3448: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3449: LD_INT 0
3451: PPUSH
3452: PPUSH
3453: PPUSH
3454: PPUSH
3455: PPUSH
3456: PPUSH
3457: PPUSH
3458: PPUSH
3459: PPUSH
3460: PPUSH
3461: PPUSH
// uc_side := 3 ;
3462: LD_ADDR_OWVAR 20
3466: PUSH
3467: LD_INT 3
3469: ST_TO_ADDR
// uc_nation := nation_russian ;
3470: LD_ADDR_OWVAR 21
3474: PUSH
3475: LD_INT 3
3477: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3478: LD_ADDR_VAR 0 4
3482: PUSH
3483: LD_INT 22
3485: PUSH
3486: LD_INT 3
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: PUSH
3493: LD_INT 30
3495: PUSH
3496: LD_INT 1
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 69
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3516: LD_ADDR_VAR 0 5
3520: PUSH
3521: LD_INT 22
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: LD_INT 30
3533: PUSH
3534: LD_INT 3
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 69
3549: PUSH
3550: LD_INT 1
3552: ARRAY
3553: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3554: LD_ADDR_VAR 0 6
3558: PUSH
3559: LD_INT 22
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 30
3571: PUSH
3572: LD_INT 34
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PPUSH
3583: CALL_OW 69
3587: PUSH
3588: LD_INT 1
3590: ARRAY
3591: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3592: LD_ADDR_VAR 0 8
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 33
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3626: LD_ADDR_VAR 0 7
3630: PUSH
3631: LD_INT 22
3633: PUSH
3634: LD_INT 3
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: PUSH
3641: LD_INT 30
3643: PUSH
3644: LD_INT 5
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PPUSH
3655: CALL_OW 69
3659: PUSH
3660: LD_INT 1
3662: ARRAY
3663: ST_TO_ADDR
// ru_blist := [ ] ;
3664: LD_ADDR_EXP 26
3668: PUSH
3669: EMPTY
3670: ST_TO_ADDR
// ru_vlist := [ ] ;
3671: LD_ADDR_EXP 27
3675: PUSH
3676: EMPTY
3677: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3678: LD_ADDR_EXP 30
3682: PUSH
3683: LD_INT 183
3685: PUSH
3686: LD_INT 62
3688: PUSH
3689: LD_INT 147
3691: PUSH
3692: LD_INT 44
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3701: LD_INT 30
3703: PUSH
3704: LD_INT 34
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PPUSH
3711: CALL_OW 69
3715: PUSH
3716: LD_INT 1
3718: ARRAY
3719: PPUSH
3720: LD_EXP 30
3724: PUSH
3725: LD_INT 1
3727: ARRAY
3728: PPUSH
3729: LD_EXP 30
3733: PUSH
3734: LD_INT 2
3736: ARRAY
3737: PPUSH
3738: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3742: LD_ADDR_EXP 28
3746: PUSH
3747: LD_INT 4
3749: PUSH
3750: LD_INT 5
3752: PUSH
3753: LD_INT 6
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: LIST
3760: PUSH
3761: LD_OWVAR 67
3765: ARRAY
3766: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3767: LD_VAR 0 4
3771: PPUSH
3772: CALL_OW 274
3776: PPUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 3000
3782: PPUSH
3783: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3787: LD_VAR 0 4
3791: PPUSH
3792: CALL_OW 274
3796: PPUSH
3797: LD_INT 2
3799: PPUSH
3800: LD_INT 300
3802: PPUSH
3803: CALL_OW 277
// hc_gallery :=  ;
3807: LD_ADDR_OWVAR 33
3811: PUSH
3812: LD_STRING 
3814: ST_TO_ADDR
// hc_name :=  ;
3815: LD_ADDR_OWVAR 26
3819: PUSH
3820: LD_STRING 
3822: ST_TO_ADDR
// hc_importance := 0 ;
3823: LD_ADDR_OWVAR 32
3827: PUSH
3828: LD_INT 0
3830: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3831: LD_ADDR_EXP 24
3835: PUSH
3836: LD_INT 5
3838: PUSH
3839: LD_INT 6
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: PUSH
3850: LD_OWVAR 67
3854: ARRAY
3855: ST_TO_ADDR
// for i = 1 to 6 do
3856: LD_ADDR_VAR 0 2
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_INT 6
3868: PUSH
3869: FOR_TO
3870: IFFALSE 4028
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3872: LD_INT 0
3874: PPUSH
3875: LD_INT 9
3877: PPUSH
3878: LD_EXP 24
3882: PPUSH
3883: CALL_OW 380
// un := CreateHuman ;
3887: LD_ADDR_VAR 0 3
3891: PUSH
3892: CALL_OW 44
3896: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3897: LD_VAR 0 3
3901: PPUSH
3902: LD_VAR 0 7
3906: PPUSH
3907: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3911: LD_INT 0
3913: PPUSH
3914: LD_INT 4
3916: PPUSH
3917: LD_EXP 24
3921: PPUSH
3922: CALL_OW 380
// un := CreateHuman ;
3926: LD_ADDR_VAR 0 3
3930: PUSH
3931: CALL_OW 44
3935: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3936: LD_VAR 0 3
3940: PPUSH
3941: LD_INT 24
3943: PPUSH
3944: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3948: LD_INT 0
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_EXP 24
3958: PPUSH
3959: CALL_OW 380
// un := CreateHuman ;
3963: LD_ADDR_VAR 0 3
3967: PUSH
3968: CALL_OW 44
3972: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
3973: LD_VAR 0 3
3977: PPUSH
3978: LD_VAR 0 5
3982: PPUSH
3983: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
3987: LD_INT 0
3989: PPUSH
3990: LD_INT 2
3992: PPUSH
3993: LD_EXP 24
3997: PPUSH
3998: CALL_OW 380
// un := CreateHuman ;
4002: LD_ADDR_VAR 0 3
4006: PUSH
4007: CALL_OW 44
4011: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4012: LD_VAR 0 3
4016: PPUSH
4017: LD_VAR 0 4
4021: PPUSH
4022: CALL_OW 52
// end ;
4026: GO 3869
4028: POP
4029: POP
// russian_prepared := true ;
4030: LD_ADDR_EXP 2
4034: PUSH
4035: LD_INT 1
4037: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4038: LD_VAR 0 5
4042: PPUSH
4043: LD_INT 21
4045: PPUSH
4046: LD_INT 3
4048: PPUSH
4049: LD_INT 3
4051: PPUSH
4052: LD_INT 51
4054: PPUSH
4055: CALL_OW 125
// end ;
4059: LD_VAR 0 1
4063: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4064: LD_INT 22
4066: PUSH
4067: LD_INT 3
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PPUSH
4074: CALL_OW 69
4078: PUSH
4079: LD_INT 0
4081: GREATER
4082: PUSH
4083: LD_EXP 2
4087: AND
4088: IFFALSE 6537
4090: GO 4092
4092: DISABLE
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
4099: PPUSH
4100: PPUSH
4101: PPUSH
4102: PPUSH
4103: PPUSH
4104: PPUSH
4105: PPUSH
4106: PPUSH
4107: PPUSH
4108: PPUSH
4109: PPUSH
4110: PPUSH
4111: PPUSH
// begin enable ;
4112: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4113: LD_ADDR_VAR 0 1
4117: PUSH
4118: LD_INT 22
4120: PUSH
4121: LD_INT 3
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 30
4130: PUSH
4131: LD_INT 1
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4151: LD_ADDR_VAR 0 2
4155: PUSH
4156: LD_INT 22
4158: PUSH
4159: LD_INT 3
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 30
4168: PUSH
4169: LD_INT 3
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PPUSH
4180: CALL_OW 69
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4189: LD_ADDR_VAR 0 3
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 3
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 30
4206: PUSH
4207: LD_INT 34
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PPUSH
4218: CALL_OW 69
4222: PUSH
4223: LD_INT 1
4225: ARRAY
4226: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4227: LD_ADDR_VAR 0 4
4231: PUSH
4232: LD_INT 22
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 33
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4261: LD_ADDR_VAR 0 8
4265: PUSH
4266: LD_INT 22
4268: PUSH
4269: LD_INT 3
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PUSH
4276: LD_INT 30
4278: PUSH
4279: LD_INT 5
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PPUSH
4290: CALL_OW 69
4294: PUSH
4295: LD_INT 1
4297: ARRAY
4298: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4299: LD_ADDR_VAR 0 5
4303: PUSH
4304: LD_INT 22
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 21
4316: PUSH
4317: LD_INT 3
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PPUSH
4328: CALL_OW 69
4332: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: LD_INT 22
4340: PUSH
4341: LD_INT 3
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: LD_INT 21
4350: PUSH
4351: LD_INT 2
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: PPUSH
4362: CALL_OW 69
4366: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 3
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 21
4384: PUSH
4385: LD_INT 1
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4401: LD_ADDR_VAR 0 9
4405: PUSH
4406: LD_VAR 0 7
4410: PPUSH
4411: LD_INT 25
4413: PUSH
4414: LD_INT 2
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 72
4425: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4426: LD_ADDR_VAR 0 10
4430: PUSH
4431: LD_VAR 0 7
4435: PPUSH
4436: LD_INT 25
4438: PUSH
4439: LD_INT 3
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 72
4450: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4451: LD_ADDR_VAR 0 11
4455: PUSH
4456: LD_VAR 0 7
4460: PPUSH
4461: LD_INT 25
4463: PUSH
4464: LD_INT 4
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PPUSH
4471: CALL_OW 72
4475: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4476: LD_INT 22
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 34
4488: PUSH
4489: LD_INT 51
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PPUSH
4500: CALL_OW 69
4504: PUSH
4505: LD_INT 0
4507: GREATER
4508: PUSH
4509: LD_EXP 25
4513: PUSH
4514: LD_INT 0
4516: EQUAL
4517: AND
4518: IFFALSE 4558
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4520: LD_ADDR_EXP 25
4524: PUSH
4525: LD_INT 22
4527: PUSH
4528: LD_INT 3
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: LD_INT 34
4537: PUSH
4538: LD_INT 51
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PPUSH
4549: CALL_OW 69
4553: PUSH
4554: LD_INT 1
4556: ARRAY
4557: ST_TO_ADDR
// if ru_cargo then
4558: LD_EXP 25
4562: IFFALSE 4860
// begin if IsInArea ( ru_cargo , ru_base ) then
4564: LD_EXP 25
4568: PPUSH
4569: LD_INT 9
4571: PPUSH
4572: CALL_OW 308
4576: IFFALSE 4655
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4578: LD_EXP 25
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 289
4590: PUSH
4591: LD_INT 0
4593: EQUAL
4594: IFFALSE 4612
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4596: LD_EXP 25
4600: PPUSH
4601: LD_VAR 0 3
4605: PPUSH
4606: CALL_OW 120
4610: GO 4653
// if not HasTask ( ru_cargo ) then
4612: LD_EXP 25
4616: PPUSH
4617: CALL_OW 314
4621: NOT
4622: IFFALSE 4653
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4624: LD_EXP 25
4628: PPUSH
4629: LD_VAR 0 1
4633: PPUSH
4634: CALL_OW 250
4638: PPUSH
4639: LD_VAR 0 1
4643: PPUSH
4644: CALL_OW 251
4648: PPUSH
4649: CALL_OW 111
// end else
4653: GO 4860
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4655: LD_EXP 25
4659: PPUSH
4660: CALL_OW 314
4664: NOT
4665: PUSH
4666: LD_EXP 25
4670: PPUSH
4671: LD_INT 1
4673: PPUSH
4674: CALL_OW 289
4678: PUSH
4679: LD_INT 100
4681: LESS
4682: AND
4683: IFFALSE 4749
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4685: LD_ADDR_VAR 0 16
4689: PUSH
4690: LD_INT 11
4692: PPUSH
4693: CALL_OW 435
4697: ST_TO_ADDR
// if cr > 0 then
4698: LD_VAR 0 16
4702: PUSH
4703: LD_INT 0
4705: GREATER
4706: IFFALSE 4737
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4708: LD_EXP 25
4712: PPUSH
4713: LD_VAR 0 16
4717: PUSH
4718: LD_INT 1
4720: ARRAY
4721: PPUSH
4722: LD_VAR 0 16
4726: PUSH
4727: LD_INT 2
4729: ARRAY
4730: PPUSH
4731: CALL_OW 117
4735: GO 4749
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4737: LD_EXP 25
4741: PPUSH
4742: LD_INT 11
4744: PPUSH
4745: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4749: LD_EXP 25
4753: PPUSH
4754: CALL_OW 314
4758: NOT
4759: PUSH
4760: LD_EXP 25
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 308
4772: NOT
4773: AND
4774: PUSH
4775: LD_EXP 25
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: CALL_OW 289
4787: PUSH
4788: LD_INT 100
4790: EQUAL
4791: AND
4792: IFFALSE 4806
// ComMoveToArea ( ru_cargo , cargoa ) ;
4794: LD_EXP 25
4798: PPUSH
4799: LD_INT 10
4801: PPUSH
4802: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4806: LD_EXP 25
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 308
4818: PUSH
4819: LD_VAR 0 8
4823: AND
4824: IFFALSE 4860
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4826: LD_VAR 0 7
4830: PPUSH
4831: LD_INT 25
4833: PUSH
4834: LD_INT 9
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: PUSH
4846: LD_INT 1
4848: ARRAY
4849: PPUSH
4850: LD_INT 139
4852: PPUSH
4853: LD_INT 24
4855: PPUSH
4856: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4860: LD_EXP 25
4864: PUSH
4865: LD_INT 0
4867: EQUAL
4868: PUSH
4869: LD_VAR 0 2
4873: AND
4874: PUSH
4875: LD_VAR 0 2
4879: PPUSH
4880: CALL_OW 461
4884: PUSH
4885: LD_INT 2
4887: EQUAL
4888: AND
4889: IFFALSE 4912
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4891: LD_VAR 0 2
4895: PPUSH
4896: LD_INT 21
4898: PPUSH
4899: LD_INT 3
4901: PPUSH
4902: LD_INT 3
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4912: LD_VAR 0 7
4916: PPUSH
4917: LD_INT 25
4919: PUSH
4920: LD_INT 9
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 72
4931: IFFALSE 4995
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4933: LD_VAR 0 7
4937: PPUSH
4938: LD_INT 25
4940: PUSH
4941: LD_INT 9
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 72
4952: PPUSH
4953: LD_INT 22
4955: PUSH
4956: LD_OWVAR 2
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: LD_INT 21
4970: PUSH
4971: LD_INT 3
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PPUSH
4986: CALL_OW 69
4990: PPUSH
4991: CALL 1656 0 2
// if ru_factory and ru_vlist > 0 then
4995: LD_VAR 0 2
4999: PUSH
5000: LD_EXP 27
5004: PUSH
5005: LD_INT 0
5007: GREATER
5008: AND
5009: IFFALSE 5109
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5011: LD_VAR 0 2
5015: PPUSH
5016: CALL_OW 461
5020: PUSH
5021: LD_INT 2
5023: EQUAL
5024: IFFALSE 5109
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5026: LD_VAR 0 2
5030: PPUSH
5031: LD_EXP 27
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PPUSH
5040: LD_EXP 27
5044: PUSH
5045: LD_INT 2
5047: ARRAY
5048: PPUSH
5049: LD_EXP 27
5053: PUSH
5054: LD_INT 3
5056: ARRAY
5057: PPUSH
5058: LD_EXP 27
5062: PUSH
5063: LD_INT 4
5065: ARRAY
5066: PPUSH
5067: CALL_OW 125
// for i = 1 to 4 do
5071: LD_ADDR_VAR 0 12
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 4
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5107
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5087: LD_ADDR_EXP 27
5091: PUSH
5092: LD_EXP 27
5096: PPUSH
5097: LD_INT 1
5099: PPUSH
5100: CALL_OW 3
5104: ST_TO_ADDR
5105: GO 5084
5107: POP
5108: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5109: LD_INT 24
5111: PPUSH
5112: CALL_OW 461
5116: PUSH
5117: LD_INT 2
5119: EQUAL
5120: PUSH
5121: LD_EXP 4
5125: AND
5126: IFFALSE 5154
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5128: LD_INT 25
5130: PPUSH
5131: LD_INT 3
5133: PPUSH
5134: CALL_OW 321
5138: PUSH
5139: LD_INT 1
5141: EQUAL
5142: IFFALSE 5154
// ComResearch ( ru_lab , tech_sibfiss ) ;
5144: LD_INT 24
5146: PPUSH
5147: LD_INT 25
5149: PPUSH
5150: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched then
5154: LD_INT 25
5156: PPUSH
5157: LD_INT 3
5159: PPUSH
5160: CALL_OW 321
5164: PUSH
5165: LD_INT 2
5167: EQUAL
5168: IFFALSE 5206
// if BuildingStatus ( ru_factory ) = bs_idle then
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 461
5179: PUSH
5180: LD_INT 2
5182: EQUAL
5183: IFFALSE 5206
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5185: LD_VAR 0 2
5189: PPUSH
5190: LD_INT 23
5192: PPUSH
5193: LD_INT 3
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 48
5201: PPUSH
5202: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5206: LD_INT 22
5208: PUSH
5209: LD_INT 3
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PUSH
5216: LD_INT 34
5218: PUSH
5219: LD_INT 48
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 69
5234: PUSH
5235: LD_INT 0
5237: GREATER
5238: IFFALSE 5612
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5240: LD_ADDR_VAR 0 17
5244: PUSH
5245: LD_INT 22
5247: PUSH
5248: LD_INT 3
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: LD_INT 34
5257: PUSH
5258: LD_INT 48
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PPUSH
5269: CALL_OW 69
5273: PUSH
5274: LD_INT 1
5276: ARRAY
5277: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5278: LD_VAR 0 17
5282: PPUSH
5283: LD_INT 9
5285: PPUSH
5286: CALL_OW 308
5290: IFFALSE 5308
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5292: LD_VAR 0 17
5296: PPUSH
5297: LD_VAR 0 3
5301: PPUSH
5302: CALL_OW 120
5306: GO 5612
// if not HasTask ( sib_bomb ) then
5308: LD_VAR 0 17
5312: PPUSH
5313: CALL_OW 314
5317: NOT
5318: IFFALSE 5612
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5320: LD_INT 22
5322: PUSH
5323: LD_OWVAR 2
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: PUSH
5332: LD_INT 30
5334: PUSH
5335: LD_INT 1
5337: PUSH
5338: EMPTY
5339: LIST
5340: LIST
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PPUSH
5346: CALL_OW 69
5350: PUSH
5351: LD_INT 1
5353: ARRAY
5354: PPUSH
5355: CALL_OW 256
5359: PUSH
5360: LD_INT 250
5362: GREATER
5363: IFFALSE 5456
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5365: LD_VAR 0 17
5369: PPUSH
5370: LD_INT 22
5372: PUSH
5373: LD_OWVAR 2
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PUSH
5382: LD_INT 30
5384: PUSH
5385: LD_INT 1
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PPUSH
5396: CALL_OW 69
5400: PUSH
5401: LD_INT 1
5403: ARRAY
5404: PPUSH
5405: CALL_OW 250
5409: PPUSH
5410: LD_INT 22
5412: PUSH
5413: LD_OWVAR 2
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: PUSH
5422: LD_INT 30
5424: PUSH
5425: LD_INT 1
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: PUSH
5441: LD_INT 1
5443: ARRAY
5444: PPUSH
5445: CALL_OW 251
5449: PPUSH
5450: CALL_OW 116
5454: GO 5612
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5456: LD_INT 22
5458: PUSH
5459: LD_OWVAR 2
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PUSH
5468: LD_INT 21
5470: PUSH
5471: LD_INT 3
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PPUSH
5482: CALL_OW 69
5486: PUSH
5487: LD_INT 0
5489: GREATER
5490: IFFALSE 5583
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5492: LD_VAR 0 17
5496: PPUSH
5497: LD_INT 22
5499: PUSH
5500: LD_OWVAR 2
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PUSH
5509: LD_INT 21
5511: PUSH
5512: LD_INT 3
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: PUSH
5528: LD_INT 1
5530: ARRAY
5531: PPUSH
5532: CALL_OW 250
5536: PPUSH
5537: LD_INT 22
5539: PUSH
5540: LD_OWVAR 2
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 21
5551: PUSH
5552: LD_INT 3
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL_OW 69
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: CALL_OW 251
5576: PPUSH
5577: CALL_OW 116
5581: GO 5612
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5583: LD_VAR 0 17
5587: PPUSH
5588: LD_EXP 10
5592: PPUSH
5593: CALL_OW 250
5597: PPUSH
5598: LD_EXP 10
5602: PPUSH
5603: CALL_OW 251
5607: PPUSH
5608: CALL_OW 116
// end ; if ru_can_attack then
5612: LD_EXP 3
5616: IFFALSE 5764
// if ru_time > 0 0$00 then
5618: LD_EXP 29
5622: PUSH
5623: LD_INT 0
5625: GREATER
5626: IFFALSE 5644
// ru_time := ru_time - 0 0$01 else
5628: LD_ADDR_EXP 29
5632: PUSH
5633: LD_EXP 29
5637: PUSH
5638: LD_INT 35
5640: MINUS
5641: ST_TO_ADDR
5642: GO 5764
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5644: LD_ADDR_EXP 29
5648: PUSH
5649: LD_INT 20265
5651: PPUSH
5652: LD_INT 30765
5654: PPUSH
5655: CALL_OW 12
5659: ST_TO_ADDR
// for i = 1 to ru_amount do
5660: LD_ADDR_VAR 0 12
5664: PUSH
5665: DOUBLE
5666: LD_INT 1
5668: DEC
5669: ST_TO_ADDR
5670: LD_EXP 28
5674: PUSH
5675: FOR_TO
5676: IFFALSE 5762
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5678: LD_ADDR_EXP 27
5682: PUSH
5683: LD_EXP 27
5687: PUSH
5688: LD_INT 23
5690: ADD
5691: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5692: LD_ADDR_EXP 27
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ADD
5705: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5706: LD_ADDR_EXP 27
5710: PUSH
5711: LD_EXP 27
5715: PUSH
5716: LD_INT 3
5718: ADD
5719: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5720: LD_ADDR_EXP 27
5724: PUSH
5725: LD_EXP 27
5729: PUSH
5730: LD_INT 46
5732: PUSH
5733: LD_INT 45
5735: PUSH
5736: LD_INT 47
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 1
5746: PPUSH
5747: LD_INT 2
5749: PPUSH
5750: LD_INT 3
5752: PPUSH
5753: CALL_OW 14
5757: ARRAY
5758: ADD
5759: ST_TO_ADDR
// end ;
5760: GO 5675
5762: POP
5763: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5764: LD_VAR 0 4
5768: PPUSH
5769: LD_INT 35
5771: PUSH
5772: LD_INT 0
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PPUSH
5779: CALL_OW 72
5783: PUSH
5784: LD_INT 0
5786: GREATER
5787: IFFALSE 5835
// if BuildingStatus ( ru_factory ) = bs_idle then
5789: LD_VAR 0 2
5793: PPUSH
5794: CALL_OW 461
5798: PUSH
5799: LD_INT 2
5801: EQUAL
5802: IFFALSE 5835
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5804: LD_VAR 0 4
5808: PPUSH
5809: LD_INT 35
5811: PUSH
5812: LD_INT 0
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PPUSH
5819: CALL_OW 72
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_INT 47
5830: PPUSH
5831: CALL_OW 148
// if ru_force = ru_amount then
5835: LD_EXP 23
5839: PUSH
5840: LD_EXP 28
5844: EQUAL
5845: IFFALSE 5977
// begin for i = 1 to ru_force do
5847: LD_ADDR_VAR 0 12
5851: PUSH
5852: DOUBLE
5853: LD_INT 1
5855: DEC
5856: ST_TO_ADDR
5857: LD_EXP 23
5861: PUSH
5862: FOR_TO
5863: IFFALSE 5973
// if IsInArea ( ru_force [ i ] , ru_base ) then
5865: LD_EXP 23
5869: PUSH
5870: LD_VAR 0 12
5874: ARRAY
5875: PPUSH
5876: LD_INT 9
5878: PPUSH
5879: CALL_OW 308
5883: IFFALSE 5907
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5885: LD_EXP 23
5889: PUSH
5890: LD_VAR 0 12
5894: ARRAY
5895: PPUSH
5896: LD_VAR 0 3
5900: PPUSH
5901: CALL_OW 120
5905: GO 5971
// if not HasTask ( ru_force [ i ] ) then
5907: LD_EXP 23
5911: PUSH
5912: LD_VAR 0 12
5916: ARRAY
5917: PPUSH
5918: CALL_OW 314
5922: NOT
5923: IFFALSE 5971
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5925: LD_EXP 23
5929: PUSH
5930: LD_VAR 0 12
5934: ARRAY
5935: PPUSH
5936: LD_INT 81
5938: PUSH
5939: LD_INT 3
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PPUSH
5946: CALL_OW 69
5950: PPUSH
5951: LD_EXP 23
5955: PUSH
5956: LD_VAR 0 12
5960: ARRAY
5961: PPUSH
5962: CALL_OW 74
5966: PPUSH
5967: CALL_OW 115
5971: GO 5862
5973: POP
5974: POP
// end else
5975: GO 6127
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
5977: LD_EXP 23
5981: PPUSH
5982: LD_INT 3
5984: PUSH
5985: LD_INT 95
5987: PUSH
5988: LD_INT 18
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: PUSH
6004: LD_INT 0
6006: GREATER
6007: IFFALSE 6127
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6009: LD_ADDR_VAR 0 13
6013: PUSH
6014: LD_EXP 23
6018: PPUSH
6019: LD_INT 3
6021: PUSH
6022: LD_INT 95
6024: PUSH
6025: LD_INT 18
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PPUSH
6036: CALL_OW 72
6040: ST_TO_ADDR
// for i = 1 to tmp do
6041: LD_ADDR_VAR 0 12
6045: PUSH
6046: DOUBLE
6047: LD_INT 1
6049: DEC
6050: ST_TO_ADDR
6051: LD_VAR 0 13
6055: PUSH
6056: FOR_TO
6057: IFFALSE 6125
// if not HasTask ( tmp [ i ] ) then
6059: LD_VAR 0 13
6063: PUSH
6064: LD_VAR 0 12
6068: ARRAY
6069: PPUSH
6070: CALL_OW 314
6074: NOT
6075: IFFALSE 6123
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6077: LD_EXP 23
6081: PUSH
6082: LD_VAR 0 12
6086: ARRAY
6087: PPUSH
6088: LD_INT 81
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PPUSH
6098: CALL_OW 69
6102: PPUSH
6103: LD_EXP 23
6107: PUSH
6108: LD_VAR 0 12
6112: ARRAY
6113: PPUSH
6114: CALL_OW 74
6118: PPUSH
6119: CALL_OW 115
6123: GO 6056
6125: POP
6126: POP
// end ; if ru_engs > 0 then
6127: LD_VAR 0 9
6131: PUSH
6132: LD_INT 0
6134: GREATER
6135: IFFALSE 6537
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6137: LD_VAR 0 5
6141: PPUSH
6142: LD_INT 3
6144: PUSH
6145: LD_INT 24
6147: PUSH
6148: LD_INT 1000
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 72
6163: PUSH
6164: LD_INT 0
6166: GREATER
6167: IFFALSE 6322
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6169: LD_ADDR_VAR 0 14
6173: PUSH
6174: LD_VAR 0 5
6178: PPUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 24
6184: PUSH
6185: LD_INT 1000
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PPUSH
6196: CALL_OW 72
6200: ST_TO_ADDR
// for i = 1 to ru_engs do
6201: LD_ADDR_VAR 0 12
6205: PUSH
6206: DOUBLE
6207: LD_INT 1
6209: DEC
6210: ST_TO_ADDR
6211: LD_VAR 0 9
6215: PUSH
6216: FOR_TO
6217: IFFALSE 6318
// begin if IsInUnit ( ru_engs [ i ] ) then
6219: LD_VAR 0 9
6223: PUSH
6224: LD_VAR 0 12
6228: ARRAY
6229: PPUSH
6230: CALL_OW 310
6234: IFFALSE 6253
// ComExitBuilding ( ru_engs [ i ] ) else
6236: LD_VAR 0 9
6240: PUSH
6241: LD_VAR 0 12
6245: ARRAY
6246: PPUSH
6247: CALL_OW 122
6251: GO 6316
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6253: LD_VAR 0 9
6257: PUSH
6258: LD_VAR 0 12
6262: ARRAY
6263: PPUSH
6264: CALL_OW 314
6268: NOT
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_VAR 0 12
6279: ARRAY
6280: PPUSH
6281: CALL_OW 256
6285: PUSH
6286: LD_INT 600
6288: GREATER
6289: AND
6290: IFFALSE 6316
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6292: LD_VAR 0 9
6296: PUSH
6297: LD_VAR 0 12
6301: ARRAY
6302: PPUSH
6303: LD_VAR 0 14
6307: PUSH
6308: LD_INT 1
6310: ARRAY
6311: PPUSH
6312: CALL_OW 130
// end ;
6316: GO 6216
6318: POP
6319: POP
// end else
6320: GO 6537
// begin if ru_blist = 0 then
6322: LD_EXP 26
6326: PUSH
6327: LD_INT 0
6329: EQUAL
6330: IFFALSE 6412
// begin for i = 1 to ru_engs do
6332: LD_ADDR_VAR 0 12
6336: PUSH
6337: DOUBLE
6338: LD_INT 1
6340: DEC
6341: ST_TO_ADDR
6342: LD_VAR 0 9
6346: PUSH
6347: FOR_TO
6348: IFFALSE 6408
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 310
6382: NOT
6383: AND
6384: IFFALSE 6406
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6386: LD_VAR 0 9
6390: PUSH
6391: LD_VAR 0 12
6395: ARRAY
6396: PPUSH
6397: LD_VAR 0 1
6401: PPUSH
6402: CALL_OW 120
6406: GO 6347
6408: POP
6409: POP
// end else
6410: GO 6537
// begin for i = 1 to ru_engs do
6412: LD_ADDR_VAR 0 12
6416: PUSH
6417: DOUBLE
6418: LD_INT 1
6420: DEC
6421: ST_TO_ADDR
6422: LD_VAR 0 9
6426: PUSH
6427: FOR_TO
6428: IFFALSE 6535
// begin if IsInUnit ( ru_engs [ i ] ) then
6430: LD_VAR 0 9
6434: PUSH
6435: LD_VAR 0 12
6439: ARRAY
6440: PPUSH
6441: CALL_OW 310
6445: IFFALSE 6464
// ComExitBuilding ( ru_engs [ i ] ) else
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 122
6462: GO 6533
// if not HasTask ( ru_engs [ i ] ) then
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 314
6479: NOT
6480: IFFALSE 6533
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6482: LD_VAR 0 9
6486: PUSH
6487: LD_VAR 0 12
6491: ARRAY
6492: PPUSH
6493: LD_EXP 26
6497: PUSH
6498: LD_INT 1
6500: ARRAY
6501: PPUSH
6502: LD_EXP 26
6506: PUSH
6507: LD_INT 2
6509: ARRAY
6510: PPUSH
6511: LD_EXP 26
6515: PUSH
6516: LD_INT 3
6518: ARRAY
6519: PPUSH
6520: LD_EXP 26
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PPUSH
6529: CALL_OW 145
// end ;
6533: GO 6427
6535: POP
6536: POP
// end ; end ; end ; end ;
6537: PPOPN 17
6539: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6540: LD_EXP 2
6544: PUSH
6545: LD_INT 11
6547: PPUSH
6548: CALL_OW 435
6552: PUSH
6553: LD_INT 20
6555: LESS
6556: AND
6557: IFFALSE 6620
6559: GO 6561
6561: DISABLE
// begin enable ;
6562: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6563: LD_INT 1
6565: PPUSH
6566: LD_INT 5
6568: PPUSH
6569: CALL_OW 12
6573: PPUSH
6574: LD_INT 11
6576: PPUSH
6577: LD_INT 1
6579: PPUSH
6580: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6584: LD_INT 1505
6586: PPUSH
6587: LD_INT 2100
6589: PPUSH
6590: CALL_OW 12
6594: PPUSH
6595: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6599: LD_INT 1
6601: PPUSH
6602: LD_INT 5
6604: PPUSH
6605: CALL_OW 12
6609: PPUSH
6610: LD_INT 11
6612: PPUSH
6613: LD_INT 1
6615: PPUSH
6616: CALL_OW 55
// end ;
6620: END
// every 20 20$00 trigger ru_sib_bomb = false do var i , tmp ;
6621: LD_EXP 4
6625: PUSH
6626: LD_INT 0
6628: EQUAL
6629: IFFALSE 6744
6631: GO 6633
6633: DISABLE
6634: LD_INT 0
6636: PPUSH
6637: PPUSH
// begin enable ;
6638: ENABLE
// i := Rand ( 0 , 100 ) ;
6639: LD_ADDR_VAR 0 1
6643: PUSH
6644: LD_INT 0
6646: PPUSH
6647: LD_INT 100
6649: PPUSH
6650: CALL_OW 12
6654: ST_TO_ADDR
// case your_side of 1 :
6655: LD_OWVAR 2
6659: PUSH
6660: LD_INT 1
6662: DOUBLE
6663: EQUAL
6664: IFTRUE 6668
6666: GO 6679
6668: POP
// tmp := 10 ; 2 :
6669: LD_ADDR_VAR 0 2
6673: PUSH
6674: LD_INT 10
6676: ST_TO_ADDR
6677: GO 6718
6679: LD_INT 2
6681: DOUBLE
6682: EQUAL
6683: IFTRUE 6687
6685: GO 6698
6687: POP
// tmp := 0 ; 7 :
6688: LD_ADDR_VAR 0 2
6692: PUSH
6693: LD_INT 0
6695: ST_TO_ADDR
6696: GO 6718
6698: LD_INT 7
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6717
6706: POP
// tmp := 15 ; end ;
6707: LD_ADDR_VAR 0 2
6711: PUSH
6712: LD_INT 15
6714: ST_TO_ADDR
6715: GO 6718
6717: POP
// if i < chance_to_bomb + tmp then
6718: LD_VAR 0 1
6722: PUSH
6723: LD_EXP 5
6727: PUSH
6728: LD_VAR 0 2
6732: PLUS
6733: LESS
6734: IFFALSE 6744
// ru_sib_bomb := true ;
6736: LD_ADDR_EXP 4
6740: PUSH
6741: LD_INT 1
6743: ST_TO_ADDR
// end ;
6744: PPOPN 2
6746: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6747: LD_INT 22
6749: PUSH
6750: LD_OWVAR 2
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 34
6761: PUSH
6762: LD_INT 8
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: IFFALSE 6790
6779: GO 6781
6781: DISABLE
// begin ru_sib_bomb := true ;
6782: LD_ADDR_EXP 4
6786: PUSH
6787: LD_INT 1
6789: ST_TO_ADDR
// end ;
6790: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6791: LD_INT 22
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: EMPTY
6798: LIST
6799: LIST
6800: PUSH
6801: LD_INT 30
6803: PUSH
6804: LD_INT 34
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 69
6819: IFFALSE 6918
6821: GO 6823
6823: DISABLE
6824: LD_INT 0
6826: PPUSH
// begin enable ;
6827: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 1
6835: PUSH
6836: LD_INT 3
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 1
6845: PPUSH
6846: LD_INT 2
6848: PPUSH
6849: CALL_OW 12
6853: ARRAY
6854: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6855: LD_INT 22
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 30
6867: PUSH
6868: LD_INT 34
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PUSH
6884: LD_INT 1
6886: ARRAY
6887: PPUSH
6888: LD_EXP 30
6892: PUSH
6893: LD_VAR 0 1
6897: ARRAY
6898: PPUSH
6899: LD_EXP 30
6903: PUSH
6904: LD_VAR 0 1
6908: PUSH
6909: LD_INT 1
6911: PLUS
6912: ARRAY
6913: PPUSH
6914: CALL_OW 243
// end ; end_of_file
6918: PPOPN 1
6920: END
// export function RemoveLegion ; var i ; begin
6921: LD_INT 0
6923: PPUSH
6924: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: LD_INT 22
6932: PUSH
6933: LD_INT 8
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PPUSH
6940: CALL_OW 69
6944: PUSH
6945: FOR_IN
6946: IFFALSE 6959
// RemoveUnit ( i ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: CALL_OW 64
6957: GO 6945
6959: POP
6960: POP
// end ;
6961: LD_VAR 0 1
6965: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
6966: LD_INT 0
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
6978: LD_ADDR_VAR 0 7
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 8
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 30
6995: PUSH
6996: LD_INT 1
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: LD_INT 1
7014: ARRAY
7015: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7016: LD_ADDR_VAR 0 8
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_INT 8
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 30
7033: PUSH
7034: LD_INT 3
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: LD_INT 1
7052: ARRAY
7053: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7054: LD_ADDR_VAR 0 9
7058: PUSH
7059: LD_INT 22
7061: PUSH
7062: LD_INT 8
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PUSH
7069: LD_INT 2
7071: PUSH
7072: LD_INT 30
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 30
7084: PUSH
7085: LD_INT 8
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PPUSH
7101: CALL_OW 69
7105: PUSH
7106: LD_INT 1
7108: ARRAY
7109: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7110: LD_ADDR_VAR 0 10
7114: PUSH
7115: LD_INT 22
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 30
7127: PUSH
7128: LD_INT 32
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: ST_TO_ADDR
// uc_side := 8 ;
7144: LD_ADDR_OWVAR 20
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// uc_nation := nation_arabian ;
7152: LD_ADDR_OWVAR 21
7156: PUSH
7157: LD_INT 2
7159: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7160: LD_ADDR_EXP 32
7164: PUSH
7165: LD_INT 5
7167: PUSH
7168: LD_INT 6
7170: PUSH
7171: LD_INT 7
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: LIST
7178: PUSH
7179: LD_OWVAR 67
7183: ARRAY
7184: ST_TO_ADDR
// legion_blist := [ ] ;
7185: LD_ADDR_EXP 34
7189: PUSH
7190: EMPTY
7191: ST_TO_ADDR
// legion_vlist := [ ] ;
7192: LD_ADDR_EXP 35
7196: PUSH
7197: EMPTY
7198: ST_TO_ADDR
// legion_force := [ ] ;
7199: LD_ADDR_EXP 31
7203: PUSH
7204: EMPTY
7205: ST_TO_ADDR
// legion_enemy := - 1 ;
7206: LD_ADDR_EXP 36
7210: PUSH
7211: LD_INT 1
7213: NEG
7214: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7215: LD_VAR 0 7
7219: PPUSH
7220: CALL_OW 274
7224: PPUSH
7225: LD_INT 1
7227: PPUSH
7228: LD_INT 10000
7230: PPUSH
7231: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7235: LD_VAR 0 7
7239: PPUSH
7240: CALL_OW 274
7244: PPUSH
7245: LD_INT 3
7247: PPUSH
7248: LD_INT 1000
7250: PPUSH
7251: CALL_OW 277
// for i = 1 to l_towers do
7255: LD_ADDR_VAR 0 3
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_VAR 0 10
7269: PUSH
7270: FOR_TO
7271: IFFALSE 7320
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7273: LD_INT 0
7275: PPUSH
7276: LD_INT 1
7278: PPUSH
7279: LD_EXP 32
7283: PPUSH
7284: CALL_OW 380
// un := CreateHuman ;
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: CALL_OW 44
7297: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7298: LD_VAR 0 2
7302: PPUSH
7303: LD_VAR 0 10
7307: PUSH
7308: LD_VAR 0 3
7312: ARRAY
7313: PPUSH
7314: CALL_OW 52
// end ;
7318: GO 7270
7320: POP
7321: POP
// for i = 1 to 4 do
7322: LD_ADDR_VAR 0 3
7326: PUSH
7327: DOUBLE
7328: LD_INT 1
7330: DEC
7331: ST_TO_ADDR
7332: LD_INT 4
7334: PUSH
7335: FOR_TO
7336: IFFALSE 7429
// for p = 1 to 2 do
7338: LD_ADDR_VAR 0 6
7342: PUSH
7343: DOUBLE
7344: LD_INT 1
7346: DEC
7347: ST_TO_ADDR
7348: LD_INT 2
7350: PUSH
7351: FOR_TO
7352: IFFALSE 7425
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7354: LD_INT 0
7356: PPUSH
7357: LD_INT 8
7359: PPUSH
7360: LD_EXP 32
7364: PPUSH
7365: CALL_OW 380
// un := CreateHuman ;
7369: LD_ADDR_VAR 0 2
7373: PUSH
7374: CALL_OW 44
7378: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7379: LD_VAR 0 2
7383: PPUSH
7384: LD_INT 22
7386: PUSH
7387: LD_INT 8
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 30
7396: PUSH
7397: LD_INT 5
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: PUSH
7413: LD_VAR 0 6
7417: ARRAY
7418: PPUSH
7419: CALL_OW 52
// end ;
7423: GO 7351
7425: POP
7426: POP
7427: GO 7335
7429: POP
7430: POP
// for i = 1 to 4 do
7431: LD_ADDR_VAR 0 3
7435: PUSH
7436: DOUBLE
7437: LD_INT 1
7439: DEC
7440: ST_TO_ADDR
7441: LD_INT 4
7443: PUSH
7444: FOR_TO
7445: IFFALSE 7488
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7447: LD_INT 0
7449: PPUSH
7450: LD_INT 4
7452: PPUSH
7453: LD_EXP 32
7457: PPUSH
7458: CALL_OW 380
// un := CreateHuman ;
7462: LD_ADDR_VAR 0 2
7466: PUSH
7467: CALL_OW 44
7471: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7472: LD_VAR 0 2
7476: PPUSH
7477: LD_VAR 0 9
7481: PPUSH
7482: CALL_OW 52
// end ;
7486: GO 7444
7488: POP
7489: POP
// for i = 1 to 6 do
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: DOUBLE
7496: LD_INT 1
7498: DEC
7499: ST_TO_ADDR
7500: LD_INT 6
7502: PUSH
7503: FOR_TO
7504: IFFALSE 7547
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7506: LD_INT 0
7508: PPUSH
7509: LD_INT 3
7511: PPUSH
7512: LD_EXP 32
7516: PPUSH
7517: CALL_OW 380
// un := CreateHuman ;
7521: LD_ADDR_VAR 0 2
7525: PUSH
7526: CALL_OW 44
7530: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7531: LD_VAR 0 2
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 52
// end ;
7545: GO 7503
7547: POP
7548: POP
// for i = 1 to 5 do
7549: LD_ADDR_VAR 0 3
7553: PUSH
7554: DOUBLE
7555: LD_INT 1
7557: DEC
7558: ST_TO_ADDR
7559: LD_INT 5
7561: PUSH
7562: FOR_TO
7563: IFFALSE 7606
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7565: LD_INT 0
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: LD_EXP 32
7575: PPUSH
7576: CALL_OW 380
// un := CreateHuman ;
7580: LD_ADDR_VAR 0 2
7584: PUSH
7585: CALL_OW 44
7589: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7590: LD_VAR 0 2
7594: PPUSH
7595: LD_VAR 0 7
7599: PPUSH
7600: CALL_OW 52
// end ;
7604: GO 7562
7606: POP
7607: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7608: LD_ADDR_VAR 0 4
7612: PUSH
7613: LD_INT 199
7615: PPUSH
7616: LD_INT 134
7618: PPUSH
7619: LD_INT 216
7621: PPUSH
7622: LD_INT 141
7624: PPUSH
7625: LD_INT 6
7627: PPUSH
7628: CALL 1555 0 5
7632: ST_TO_ADDR
// p := 1 ;
7633: LD_ADDR_VAR 0 6
7637: PUSH
7638: LD_INT 1
7640: ST_TO_ADDR
// for i = 1 to 3 do
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: DOUBLE
7647: LD_INT 1
7649: DEC
7650: ST_TO_ADDR
7651: LD_INT 3
7653: PUSH
7654: FOR_TO
7655: IFFALSE 7908
// begin vc_chassis := ar_half_tracked ;
7657: LD_ADDR_OWVAR 37
7661: PUSH
7662: LD_INT 14
7664: ST_TO_ADDR
// vc_engine := engine_siberite ;
7665: LD_ADDR_OWVAR 39
7669: PUSH
7670: LD_INT 3
7672: ST_TO_ADDR
// vc_control := control_manual ;
7673: LD_ADDR_OWVAR 38
7677: PUSH
7678: LD_INT 1
7680: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7681: LD_ADDR_OWVAR 40
7685: PUSH
7686: LD_INT 31
7688: ST_TO_ADDR
// veh := CreateVehicle ;
7689: LD_ADDR_VAR 0 5
7693: PUSH
7694: CALL_OW 45
7698: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7699: LD_VAR 0 4
7703: PUSH
7704: LD_VAR 0 6
7708: ARRAY
7709: PPUSH
7710: LD_VAR 0 4
7714: PUSH
7715: LD_VAR 0 6
7719: PUSH
7720: LD_INT 1
7722: PLUS
7723: ARRAY
7724: PPUSH
7725: CALL_OW 428
7729: PUSH
7730: LD_INT 0
7732: EQUAL
7733: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7735: LD_VAR 0 5
7739: PPUSH
7740: LD_VAR 0 4
7744: PUSH
7745: LD_VAR 0 6
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 6
7760: PUSH
7761: LD_INT 1
7763: PLUS
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 48
7773: GO 7863
// begin repeat p := p + 2 ;
7775: LD_ADDR_VAR 0 6
7779: PUSH
7780: LD_VAR 0 6
7784: PUSH
7785: LD_INT 2
7787: PLUS
7788: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7789: LD_VAR 0 4
7793: PUSH
7794: LD_VAR 0 6
7798: ARRAY
7799: PPUSH
7800: LD_VAR 0 4
7804: PUSH
7805: LD_VAR 0 6
7809: PUSH
7810: LD_INT 1
7812: PLUS
7813: ARRAY
7814: PPUSH
7815: CALL_OW 428
7819: PUSH
7820: LD_INT 0
7822: EQUAL
7823: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7825: LD_VAR 0 5
7829: PPUSH
7830: LD_VAR 0 4
7834: PUSH
7835: LD_VAR 0 6
7839: ARRAY
7840: PPUSH
7841: LD_VAR 0 4
7845: PUSH
7846: LD_VAR 0 6
7850: PUSH
7851: LD_INT 1
7853: PLUS
7854: ARRAY
7855: PPUSH
7856: LD_INT 0
7858: PPUSH
7859: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7863: LD_INT 0
7865: PPUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_EXP 32
7873: PUSH
7874: LD_INT 1
7876: PLUS
7877: PPUSH
7878: CALL_OW 380
// un := CreateHuman ;
7882: LD_ADDR_VAR 0 2
7886: PUSH
7887: CALL_OW 44
7891: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7892: LD_VAR 0 2
7896: PPUSH
7897: LD_VAR 0 5
7901: PPUSH
7902: CALL_OW 52
// end ;
7906: GO 7654
7908: POP
7909: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7910: LD_INT 198
7912: PPUSH
7913: LD_INT 94
7915: PPUSH
7916: LD_INT 8
7918: PPUSH
7919: LD_INT 10
7921: PPUSH
7922: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7926: LD_INT 167
7928: PPUSH
7929: LD_INT 130
7931: PPUSH
7932: LD_INT 8
7934: PPUSH
7935: LD_INT 10
7937: PPUSH
7938: CALL_OW 330
// legion_mines := [ ] ;
7942: LD_ADDR_EXP 33
7946: PUSH
7947: EMPTY
7948: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
7949: LD_ADDR_EXP 33
7953: PUSH
7954: LD_INT 176
7956: PPUSH
7957: LD_INT 122
7959: PPUSH
7960: LD_INT 188
7962: PPUSH
7963: LD_INT 126
7965: PPUSH
7966: LD_INT 6
7968: PPUSH
7969: CALL 1555 0 5
7973: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
7974: LD_ADDR_EXP 33
7978: PUSH
7979: LD_EXP 33
7983: PUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 91
7989: PPUSH
7990: LD_INT 205
7992: PPUSH
7993: LD_INT 96
7995: PPUSH
7996: LD_INT 4
7998: PPUSH
7999: CALL 1555 0 5
8003: ADD
8004: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8005: LD_ADDR_EXP 33
8009: PUSH
8010: LD_EXP 33
8014: PUSH
8015: LD_INT 184
8017: PPUSH
8018: LD_INT 151
8020: PPUSH
8021: LD_INT 178
8023: PPUSH
8024: LD_INT 130
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL 1555 0 5
8034: ADD
8035: ST_TO_ADDR
// if Difficulty > 1 then
8036: LD_OWVAR 67
8040: PUSH
8041: LD_INT 1
8043: GREATER
8044: IFFALSE 8077
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_EXP 33
8055: PUSH
8056: LD_INT 166
8058: PPUSH
8059: LD_INT 126
8061: PPUSH
8062: LD_INT 181
8064: PPUSH
8065: LD_INT 136
8067: PPUSH
8068: LD_INT 5
8070: PPUSH
8071: CALL 1555 0 5
8075: ADD
8076: ST_TO_ADDR
// p := 1 ;
8077: LD_ADDR_VAR 0 6
8081: PUSH
8082: LD_INT 1
8084: ST_TO_ADDR
// for i = 1 to 24 do
8085: LD_ADDR_VAR 0 3
8089: PUSH
8090: DOUBLE
8091: LD_INT 1
8093: DEC
8094: ST_TO_ADDR
8095: LD_INT 24
8097: PUSH
8098: FOR_TO
8099: IFFALSE 8153
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8101: LD_EXP 33
8105: PUSH
8106: LD_VAR 0 6
8110: ARRAY
8111: PPUSH
8112: LD_EXP 33
8116: PUSH
8117: LD_VAR 0 6
8121: PUSH
8122: LD_INT 1
8124: PLUS
8125: ARRAY
8126: PPUSH
8127: LD_INT 8
8129: PPUSH
8130: LD_INT 0
8132: PPUSH
8133: CALL_OW 454
// p := p + 2 ;
8137: LD_ADDR_VAR 0 6
8141: PUSH
8142: LD_VAR 0 6
8146: PUSH
8147: LD_INT 2
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: GO 8098
8153: POP
8154: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8155: LD_ADDR_EXP 35
8159: PUSH
8160: LD_INT 13
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: LD_INT 2
8168: PUSH
8169: LD_INT 32
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: ST_TO_ADDR
// end ;
8178: LD_VAR 0 1
8182: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8183: LD_INT 22
8185: PUSH
8186: LD_INT 8
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PPUSH
8193: CALL_OW 69
8197: PUSH
8198: LD_INT 0
8200: GREATER
8201: IFFALSE 10435
8203: GO 8205
8205: DISABLE
8206: LD_INT 0
8208: PPUSH
8209: PPUSH
8210: PPUSH
8211: PPUSH
8212: PPUSH
8213: PPUSH
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
8218: PPUSH
8219: PPUSH
8220: PPUSH
8221: PPUSH
8222: PPUSH
8223: PPUSH
8224: PPUSH
// begin enable ;
8225: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8226: LD_ADDR_VAR 0 8
8230: PUSH
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 30
8243: PUSH
8244: LD_INT 1
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PPUSH
8255: CALL_OW 69
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8264: LD_ADDR_VAR 0 9
8268: PUSH
8269: LD_INT 22
8271: PUSH
8272: LD_INT 8
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 30
8281: PUSH
8282: LD_INT 3
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: PPUSH
8293: CALL_OW 69
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8302: LD_ADDR_VAR 0 10
8306: PUSH
8307: LD_INT 22
8309: PUSH
8310: LD_INT 8
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 2
8319: PUSH
8320: LD_INT 30
8322: PUSH
8323: LD_INT 6
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: LD_INT 30
8332: PUSH
8333: LD_INT 8
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PPUSH
8349: CALL_OW 69
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8358: LD_ADDR_VAR 0 11
8362: PUSH
8363: LD_INT 22
8365: PUSH
8366: LD_INT 8
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: PUSH
8373: LD_INT 30
8375: PUSH
8376: LD_INT 32
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: PUSH
8383: EMPTY
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8392: LD_ADDR_VAR 0 16
8396: PUSH
8397: LD_INT 22
8399: PUSH
8400: LD_INT 8
8402: PUSH
8403: EMPTY
8404: LIST
8405: LIST
8406: PUSH
8407: LD_INT 25
8409: PUSH
8410: LD_INT 2
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PPUSH
8421: CALL_OW 69
8425: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8426: LD_ADDR_VAR 0 15
8430: PUSH
8431: LD_INT 22
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: PUSH
8441: LD_INT 25
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PPUSH
8455: CALL_OW 69
8459: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8460: LD_ADDR_VAR 0 14
8464: PUSH
8465: LD_INT 22
8467: PUSH
8468: LD_INT 8
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: LD_INT 25
8477: PUSH
8478: LD_INT 3
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8494: LD_ADDR_VAR 0 13
8498: PUSH
8499: LD_INT 22
8501: PUSH
8502: LD_INT 8
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 25
8511: PUSH
8512: LD_INT 4
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: ST_TO_ADDR
// if l_eng then
8528: LD_VAR 0 16
8532: IFFALSE 8947
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8534: LD_ADDR_VAR 0 5
8538: PUSH
8539: LD_INT 22
8541: PUSH
8542: LD_INT 8
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 21
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PPUSH
8563: CALL_OW 69
8567: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8568: LD_VAR 0 5
8572: PPUSH
8573: LD_INT 3
8575: PUSH
8576: LD_INT 24
8578: PUSH
8579: LD_INT 1000
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PPUSH
8590: CALL_OW 72
8594: PUSH
8595: LD_INT 0
8597: GREATER
8598: IFFALSE 8732
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8600: LD_ADDR_VAR 0 3
8604: PUSH
8605: LD_VAR 0 5
8609: PPUSH
8610: LD_INT 3
8612: PUSH
8613: LD_INT 24
8615: PUSH
8616: LD_INT 1000
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PPUSH
8627: CALL_OW 72
8631: ST_TO_ADDR
// for i = 1 to l_eng do
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: DOUBLE
8638: LD_INT 1
8640: DEC
8641: ST_TO_ADDR
8642: LD_VAR 0 16
8646: PUSH
8647: FOR_TO
8648: IFFALSE 8728
// if IsInUnit ( l_eng [ i ] ) then
8650: LD_VAR 0 16
8654: PUSH
8655: LD_VAR 0 2
8659: ARRAY
8660: PPUSH
8661: CALL_OW 310
8665: IFFALSE 8684
// ComExitBuilding ( l_eng [ i ] ) else
8667: LD_VAR 0 16
8671: PUSH
8672: LD_VAR 0 2
8676: ARRAY
8677: PPUSH
8678: CALL_OW 122
8682: GO 8726
// if not HasTask ( l_eng [ i ] ) then
8684: LD_VAR 0 16
8688: PUSH
8689: LD_VAR 0 2
8693: ARRAY
8694: PPUSH
8695: CALL_OW 314
8699: NOT
8700: IFFALSE 8726
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8702: LD_VAR 0 16
8706: PUSH
8707: LD_VAR 0 2
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 3
8717: PUSH
8718: LD_INT 1
8720: ARRAY
8721: PPUSH
8722: CALL_OW 130
8726: GO 8647
8728: POP
8729: POP
// end else
8730: GO 8947
// begin if legion_blist > 0 then
8732: LD_EXP 34
8736: PUSH
8737: LD_INT 0
8739: GREATER
8740: IFFALSE 8869
// begin for i = 1 to l_eng do
8742: LD_ADDR_VAR 0 2
8746: PUSH
8747: DOUBLE
8748: LD_INT 1
8750: DEC
8751: ST_TO_ADDR
8752: LD_VAR 0 16
8756: PUSH
8757: FOR_TO
8758: IFFALSE 8865
// if IsInUnit ( l_eng [ i ] ) then
8760: LD_VAR 0 16
8764: PUSH
8765: LD_VAR 0 2
8769: ARRAY
8770: PPUSH
8771: CALL_OW 310
8775: IFFALSE 8794
// ComExitBuilding ( l_eng [ i ] ) else
8777: LD_VAR 0 16
8781: PUSH
8782: LD_VAR 0 2
8786: ARRAY
8787: PPUSH
8788: CALL_OW 122
8792: GO 8863
// if not HasTask ( l_eng [ i ] ) then
8794: LD_VAR 0 16
8798: PUSH
8799: LD_VAR 0 2
8803: ARRAY
8804: PPUSH
8805: CALL_OW 314
8809: NOT
8810: IFFALSE 8863
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8812: LD_VAR 0 16
8816: PUSH
8817: LD_VAR 0 2
8821: ARRAY
8822: PPUSH
8823: LD_EXP 34
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PPUSH
8832: LD_EXP 34
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PPUSH
8841: LD_EXP 34
8845: PUSH
8846: LD_INT 3
8848: ARRAY
8849: PPUSH
8850: LD_EXP 34
8854: PUSH
8855: LD_INT 4
8857: ARRAY
8858: PPUSH
8859: CALL_OW 145
8863: GO 8757
8865: POP
8866: POP
// end else
8867: GO 8947
// for i = 1 to l_eng do
8869: LD_ADDR_VAR 0 2
8873: PUSH
8874: DOUBLE
8875: LD_INT 1
8877: DEC
8878: ST_TO_ADDR
8879: LD_VAR 0 16
8883: PUSH
8884: FOR_TO
8885: IFFALSE 8945
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8887: LD_VAR 0 16
8891: PUSH
8892: LD_VAR 0 2
8896: ARRAY
8897: PPUSH
8898: CALL_OW 310
8902: NOT
8903: PUSH
8904: LD_VAR 0 16
8908: PUSH
8909: LD_VAR 0 2
8913: ARRAY
8914: PPUSH
8915: CALL_OW 314
8919: NOT
8920: AND
8921: IFFALSE 8943
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8923: LD_VAR 0 16
8927: PUSH
8928: LD_VAR 0 2
8932: ARRAY
8933: PPUSH
8934: LD_VAR 0 8
8938: PPUSH
8939: CALL_OW 120
8943: GO 8884
8945: POP
8946: POP
// end ; end ; if l_factory then
8947: LD_VAR 0 9
8951: IFFALSE 9351
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
8953: LD_INT 22
8955: PUSH
8956: LD_INT 8
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: LD_INT 33
8965: PUSH
8966: LD_INT 2
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 3
8975: PUSH
8976: LD_INT 61
8978: PUSH
8979: EMPTY
8980: LIST
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: LIST
8990: PPUSH
8991: CALL_OW 69
8995: PUSH
8996: LD_INT 0
8998: GREATER
8999: PUSH
9000: LD_INT 22
9002: PUSH
9003: LD_INT 8
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: LD_INT 34
9012: PUSH
9013: LD_INT 31
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 69
9028: PUSH
9029: LD_INT 0
9031: GREATER
9032: AND
9033: IFFALSE 9153
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9035: LD_INT 22
9037: PUSH
9038: LD_INT 8
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: LD_INT 33
9047: PUSH
9048: LD_INT 2
9050: PUSH
9051: EMPTY
9052: LIST
9053: LIST
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: LD_INT 61
9060: PUSH
9061: EMPTY
9062: LIST
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: PPUSH
9073: CALL_OW 69
9077: PUSH
9078: LD_INT 1
9080: ARRAY
9081: PPUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 8
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 34
9094: PUSH
9095: LD_INT 31
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL_OW 69
9110: PUSH
9111: LD_INT 1
9113: PPUSH
9114: LD_INT 22
9116: PUSH
9117: LD_INT 8
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 34
9126: PUSH
9127: LD_INT 31
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PPUSH
9143: CALL_OW 12
9147: ARRAY
9148: PPUSH
9149: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9153: LD_EXP 35
9157: PUSH
9158: LD_INT 0
9160: GREATER
9161: PUSH
9162: LD_VAR 0 9
9166: PPUSH
9167: CALL_OW 461
9171: PUSH
9172: LD_INT 2
9174: EQUAL
9175: AND
9176: IFFALSE 9261
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9178: LD_VAR 0 9
9182: PPUSH
9183: LD_EXP 35
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_EXP 35
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: LD_EXP 35
9205: PUSH
9206: LD_INT 3
9208: ARRAY
9209: PPUSH
9210: LD_EXP 35
9214: PUSH
9215: LD_INT 4
9217: ARRAY
9218: PPUSH
9219: CALL_OW 125
// for i = 1 to 4 do
9223: LD_ADDR_VAR 0 2
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 4
9235: PUSH
9236: FOR_TO
9237: IFFALSE 9259
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9239: LD_ADDR_EXP 35
9243: PUSH
9244: LD_EXP 35
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: CALL_OW 3
9256: ST_TO_ADDR
9257: GO 9236
9259: POP
9260: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9261: LD_VAR 0 11
9265: PPUSH
9266: LD_INT 35
9268: PUSH
9269: LD_INT 0
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PPUSH
9276: CALL_OW 72
9280: PUSH
9281: LD_INT 0
9283: GREATER
9284: PUSH
9285: LD_VAR 0 9
9289: PPUSH
9290: CALL_OW 461
9294: PUSH
9295: LD_INT 2
9297: EQUAL
9298: AND
9299: IFFALSE 9351
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9301: LD_VAR 0 11
9305: PPUSH
9306: LD_INT 35
9308: PUSH
9309: LD_INT 0
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PPUSH
9316: CALL_OW 72
9320: PUSH
9321: LD_INT 1
9323: ARRAY
9324: PPUSH
9325: LD_INT 28
9327: PUSH
9328: LD_INT 27
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: CALL_OW 148
// end ; if legion_enemy > 0 then
9351: LD_EXP 36
9355: PUSH
9356: LD_INT 0
9358: GREATER
9359: IFFALSE 9987
// begin if tick mod 11 11$00 = 0 then
9361: LD_OWVAR 1
9365: PUSH
9366: LD_INT 23100
9368: MOD
9369: PUSH
9370: LD_INT 0
9372: EQUAL
9373: IFFALSE 9623
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9375: LD_ADDR_EXP 35
9379: PUSH
9380: LD_EXP 35
9384: PUSH
9385: LD_INT 13
9387: PUSH
9388: LD_INT 1
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: ADD
9399: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9400: LD_ADDR_EXP 35
9404: PUSH
9405: LD_EXP 35
9409: PUSH
9410: LD_INT 28
9412: PUSH
9413: LD_INT 27
9415: PUSH
9416: LD_INT 29
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: LIST
9423: PUSH
9424: LD_INT 1
9426: PPUSH
9427: LD_INT 3
9429: PPUSH
9430: CALL_OW 12
9434: ARRAY
9435: ADD
9436: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9437: LD_ADDR_EXP 35
9441: PUSH
9442: LD_EXP 35
9446: PUSH
9447: LD_INT 13
9449: PUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 2
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: LIST
9460: ADD
9461: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9462: LD_ADDR_EXP 35
9466: PUSH
9467: LD_EXP 35
9471: PUSH
9472: LD_INT 28
9474: PUSH
9475: LD_INT 27
9477: PUSH
9478: LD_INT 29
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 3
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: ADD
9498: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9499: LD_ADDR_EXP 35
9503: PUSH
9504: LD_EXP 35
9508: PUSH
9509: LD_INT 13
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: LD_INT 2
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: ADD
9523: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9524: LD_ADDR_EXP 35
9528: PUSH
9529: LD_EXP 35
9533: PUSH
9534: LD_INT 28
9536: PUSH
9537: LD_INT 27
9539: PUSH
9540: LD_INT 29
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 1
9550: PPUSH
9551: LD_INT 3
9553: PPUSH
9554: CALL_OW 12
9558: ARRAY
9559: ADD
9560: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9561: LD_ADDR_EXP 35
9565: PUSH
9566: LD_EXP 35
9570: PUSH
9571: LD_INT 13
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: ADD
9585: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9586: LD_ADDR_EXP 35
9590: PUSH
9591: LD_EXP 35
9595: PUSH
9596: LD_INT 28
9598: PUSH
9599: LD_INT 27
9601: PUSH
9602: LD_INT 29
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 3
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: ADD
9622: ST_TO_ADDR
// end ; if legion_force >= 7 then
9623: LD_EXP 31
9627: PUSH
9628: LD_INT 7
9630: GREATEREQUAL
9631: IFFALSE 9814
// begin for i = 1 to legion_force do
9633: LD_ADDR_VAR 0 2
9637: PUSH
9638: DOUBLE
9639: LD_INT 1
9641: DEC
9642: ST_TO_ADDR
9643: LD_EXP 31
9647: PUSH
9648: FOR_TO
9649: IFFALSE 9812
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9651: LD_EXP 31
9655: PUSH
9656: LD_VAR 0 2
9660: ARRAY
9661: PPUSH
9662: CALL_OW 314
9666: NOT
9667: PUSH
9668: LD_EXP 31
9672: PUSH
9673: LD_VAR 0 2
9677: ARRAY
9678: PPUSH
9679: CALL_OW 110
9683: PUSH
9684: LD_INT 11
9686: NONEQUAL
9687: AND
9688: IFFALSE 9810
// begin case legion_enemy of 1 :
9690: LD_EXP 36
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9727
9703: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9704: LD_EXP 31
9708: PUSH
9709: LD_VAR 0 2
9713: ARRAY
9714: PPUSH
9715: LD_INT 142
9717: PPUSH
9718: LD_INT 144
9720: PPUSH
9721: CALL_OW 111
9725: GO 9792
9727: LD_INT 2
9729: DOUBLE
9730: EQUAL
9731: IFTRUE 9735
9733: GO 9759
9735: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9736: LD_EXP 31
9740: PUSH
9741: LD_VAR 0 2
9745: ARRAY
9746: PPUSH
9747: LD_INT 101
9749: PPUSH
9750: LD_INT 34
9752: PPUSH
9753: CALL_OW 111
9757: GO 9792
9759: LD_INT 7
9761: DOUBLE
9762: EQUAL
9763: IFTRUE 9767
9765: GO 9791
9767: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9768: LD_EXP 31
9772: PUSH
9773: LD_VAR 0 2
9777: ARRAY
9778: PPUSH
9779: LD_INT 173
9781: PPUSH
9782: LD_INT 127
9784: PPUSH
9785: CALL_OW 111
9789: GO 9792
9791: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 11
9805: PPUSH
9806: CALL_OW 109
// end ; end ;
9810: GO 9648
9812: POP
9813: POP
// end ; if UnitFilter ( legion_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
9814: LD_EXP 31
9818: PPUSH
9819: LD_INT 3
9821: PUSH
9822: LD_INT 95
9824: PUSH
9825: LD_INT 18
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: CALL_OW 72
9840: PUSH
9841: LD_INT 0
9843: GREATER
9844: IFFALSE 9987
// begin tmp := UnitFilter ( legion_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
9846: LD_ADDR_VAR 0 3
9850: PUSH
9851: LD_EXP 31
9855: PPUSH
9856: LD_INT 3
9858: PUSH
9859: LD_INT 95
9861: PUSH
9862: LD_INT 18
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PPUSH
9873: CALL_OW 72
9877: ST_TO_ADDR
// for i = 1 to tmp do
9878: LD_ADDR_VAR 0 2
9882: PUSH
9883: DOUBLE
9884: LD_INT 1
9886: DEC
9887: ST_TO_ADDR
9888: LD_VAR 0 3
9892: PUSH
9893: FOR_TO
9894: IFFALSE 9985
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9896: LD_VAR 0 3
9900: PUSH
9901: LD_VAR 0 2
9905: ARRAY
9906: PPUSH
9907: CALL_OW 314
9911: NOT
9912: PUSH
9913: LD_EXP 31
9917: PUSH
9918: LD_VAR 0 2
9922: ARRAY
9923: PPUSH
9924: CALL_OW 110
9928: PUSH
9929: LD_INT 11
9931: EQUAL
9932: AND
9933: IFFALSE 9983
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9935: LD_VAR 0 3
9939: PUSH
9940: LD_VAR 0 2
9944: ARRAY
9945: PPUSH
9946: LD_INT 22
9948: PUSH
9949: LD_EXP 36
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: PPUSH
9963: LD_VAR 0 3
9967: PUSH
9968: LD_VAR 0 2
9972: ARRAY
9973: PPUSH
9974: CALL_OW 74
9978: PPUSH
9979: CALL_OW 115
9983: GO 9893
9985: POP
9986: POP
// end ; end ; p := 1 ;
9987: LD_ADDR_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ST_TO_ADDR
// for i = 1 to 24 do
9995: LD_ADDR_VAR 0 2
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_INT 24
10007: PUSH
10008: FOR_TO
10009: IFFALSE 10139
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10011: LD_EXP 33
10015: PUSH
10016: LD_VAR 0 6
10020: ARRAY
10021: PPUSH
10022: LD_EXP 33
10026: PUSH
10027: LD_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: PLUS
10035: ARRAY
10036: PPUSH
10037: CALL_OW 428
10041: PUSH
10042: LD_INT 0
10044: GREATER
10045: IFFALSE 10123
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10047: LD_EXP 33
10051: PUSH
10052: LD_VAR 0 6
10056: ARRAY
10057: PPUSH
10058: LD_EXP 33
10062: PUSH
10063: LD_VAR 0 6
10067: PUSH
10068: LD_INT 1
10070: PLUS
10071: ARRAY
10072: PPUSH
10073: CALL_OW 428
10077: PPUSH
10078: CALL_OW 255
10082: PUSH
10083: LD_EXP 36
10087: EQUAL
10088: IFFALSE 10123
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10090: LD_EXP 33
10094: PUSH
10095: LD_VAR 0 6
10099: ARRAY
10100: PPUSH
10101: LD_EXP 33
10105: PUSH
10106: LD_VAR 0 6
10110: PUSH
10111: LD_INT 1
10113: PLUS
10114: ARRAY
10115: PPUSH
10116: LD_INT 8
10118: PPUSH
10119: CALL_OW 456
// p := p + 2 ;
10123: LD_ADDR_VAR 0 6
10127: PUSH
10128: LD_VAR 0 6
10132: PUSH
10133: LD_INT 2
10135: PLUS
10136: ST_TO_ADDR
// end ;
10137: GO 10008
10139: POP
10140: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10141: LD_INT 22
10143: PUSH
10144: LD_INT 8
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 34
10153: PUSH
10154: LD_INT 32
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PPUSH
10165: CALL_OW 69
10169: IFFALSE 10283
// begin if l_cargo = false then
10171: LD_VAR 0 17
10175: PUSH
10176: LD_INT 0
10178: EQUAL
10179: IFFALSE 10215
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10181: LD_ADDR_VAR 0 17
10185: PUSH
10186: LD_INT 22
10188: PUSH
10189: LD_INT 8
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PUSH
10196: LD_INT 34
10198: PUSH
10199: LD_INT 32
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PPUSH
10210: CALL_OW 69
10214: ST_TO_ADDR
// if l_cargo then
10215: LD_VAR 0 17
10219: IFFALSE 10283
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10221: LD_ADDR_VAR 0 7
10225: PUSH
10226: LD_INT 14
10228: PPUSH
10229: CALL_OW 435
10233: ST_TO_ADDR
// if cr > 0 then
10234: LD_VAR 0 7
10238: PUSH
10239: LD_INT 0
10241: GREATER
10242: IFFALSE 10283
// if not HasTask ( l_cargo ) then
10244: LD_VAR 0 17
10248: PPUSH
10249: CALL_OW 314
10253: NOT
10254: IFFALSE 10283
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10256: LD_VAR 0 17
10260: PPUSH
10261: LD_VAR 0 7
10265: PUSH
10266: LD_INT 1
10268: ARRAY
10269: PPUSH
10270: LD_VAR 0 7
10274: PUSH
10275: LD_INT 2
10277: ARRAY
10278: PPUSH
10279: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10283: LD_OWVAR 1
10287: PUSH
10288: LD_INT 52500
10290: PUSH
10291: LD_INT 46200
10293: PUSH
10294: LD_INT 42000
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: PUSH
10302: LD_OWVAR 67
10306: ARRAY
10307: EQUAL
10308: PUSH
10309: LD_INT 1
10311: PPUSH
10312: CALL_OW 469
10316: PUSH
10317: LD_INT 1
10319: ARRAY
10320: PUSH
10321: LD_INT 112
10323: EQUAL
10324: AND
10325: PUSH
10326: LD_INT 1
10328: PPUSH
10329: CALL_OW 469
10333: PUSH
10334: LD_INT 2
10336: ARRAY
10337: PUSH
10338: LD_INT 67
10340: EQUAL
10341: AND
10342: IFFALSE 10435
// begin un := l_eng [ 1 ] ;
10344: LD_ADDR_VAR 0 1
10348: PUSH
10349: LD_VAR 0 16
10353: PUSH
10354: LD_INT 1
10356: ARRAY
10357: ST_TO_ADDR
// if IsInUnit ( un ) then
10358: LD_VAR 0 1
10362: PPUSH
10363: CALL_OW 310
10367: IFFALSE 10378
// ComExitBuilding ( un ) ;
10369: LD_VAR 0 1
10373: PPUSH
10374: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 469
10390: PUSH
10391: LD_INT 1
10393: ARRAY
10394: PPUSH
10395: LD_INT 1
10397: PPUSH
10398: CALL_OW 469
10402: PUSH
10403: LD_INT 2
10405: ARRAY
10406: PPUSH
10407: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10411: LD_VAR 0 1
10415: PPUSH
10416: LD_INT 207
10418: PPUSH
10419: LD_INT 123
10421: PPUSH
10422: CALL_OW 171
// AddComUnload ( un ) ;
10426: LD_VAR 0 1
10430: PPUSH
10431: CALL_OW 219
// end ; end ;
10435: PPOPN 17
10437: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10438: LD_OWVAR 67
10442: PUSH
10443: LD_INT 1
10445: GREATER
10446: IFFALSE 10651
10448: GO 10450
10450: DISABLE
10451: LD_INT 0
10453: PPUSH
10454: PPUSH
10455: PPUSH
10456: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10457: LD_INT 35
10459: PPUSH
10460: LD_INT 12635
10462: PPUSH
10463: CALL_OW 12
10467: PPUSH
10468: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10472: LD_ADDR_VAR 0 2
10476: PUSH
10477: LD_INT 22
10479: PUSH
10480: LD_INT 8
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PUSH
10487: LD_INT 25
10489: PUSH
10490: LD_INT 4
10492: PUSH
10493: EMPTY
10494: LIST
10495: LIST
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 69
10505: ST_TO_ADDR
// p := 1 ;
10506: LD_ADDR_VAR 0 4
10510: PUSH
10511: LD_INT 1
10513: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10514: LD_ADDR_VAR 0 3
10518: PUSH
10519: LD_INT 116
10521: PUSH
10522: LD_INT 139
10524: PUSH
10525: LD_INT 69
10527: PUSH
10528: LD_INT 13
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: ST_TO_ADDR
// for i = 1 to 2 do
10537: LD_ADDR_VAR 0 1
10541: PUSH
10542: DOUBLE
10543: LD_INT 1
10545: DEC
10546: ST_TO_ADDR
10547: LD_INT 2
10549: PUSH
10550: FOR_TO
10551: IFFALSE 10649
// begin if IsInUnit ( sci [ i ] ) then
10553: LD_VAR 0 2
10557: PUSH
10558: LD_VAR 0 1
10562: ARRAY
10563: PPUSH
10564: CALL_OW 310
10568: IFFALSE 10585
// ComExitBuilding ( sci [ i ] ) ;
10570: LD_VAR 0 2
10574: PUSH
10575: LD_VAR 0 1
10579: ARRAY
10580: PPUSH
10581: CALL_OW 122
// Wait ( 0 0$03 ) ;
10585: LD_INT 105
10587: PPUSH
10588: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10592: LD_VAR 0 2
10596: PUSH
10597: LD_VAR 0 1
10601: ARRAY
10602: PPUSH
10603: LD_VAR 0 3
10607: PUSH
10608: LD_VAR 0 4
10612: ARRAY
10613: PPUSH
10614: LD_VAR 0 3
10618: PUSH
10619: LD_VAR 0 4
10623: PUSH
10624: LD_INT 1
10626: PLUS
10627: ARRAY
10628: PPUSH
10629: CALL_OW 158
// p := p + 2 ;
10633: LD_ADDR_VAR 0 4
10637: PUSH
10638: LD_VAR 0 4
10642: PUSH
10643: LD_INT 2
10645: PLUS
10646: ST_TO_ADDR
// end ;
10647: GO 10550
10649: POP
10650: POP
// end ;
10651: PPOPN 4
10653: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10654: LD_INT 14
10656: PPUSH
10657: CALL_OW 435
10661: PUSH
10662: LD_INT 20
10664: LESS
10665: IFFALSE 10692
10667: GO 10669
10669: DISABLE
// begin enable ;
10670: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10671: LD_INT 1
10673: PPUSH
10674: LD_INT 5
10676: PPUSH
10677: CALL_OW 12
10681: PPUSH
10682: LD_INT 14
10684: PPUSH
10685: LD_INT 1
10687: PPUSH
10688: CALL_OW 55
// end ; end_of_file
10692: END
// export function Action ; var un ; begin
10693: LD_INT 0
10695: PPUSH
10696: PPUSH
// case Query ( QVul1 ) of 1 :
10697: LD_STRING QVul1
10699: PPUSH
10700: CALL_OW 97
10704: PUSH
10705: LD_INT 1
10707: DOUBLE
10708: EQUAL
10709: IFTRUE 10713
10711: GO 10724
10713: POP
// Difficulty := 1 ; 2 :
10714: LD_ADDR_OWVAR 67
10718: PUSH
10719: LD_INT 1
10721: ST_TO_ADDR
10722: GO 10763
10724: LD_INT 2
10726: DOUBLE
10727: EQUAL
10728: IFTRUE 10732
10730: GO 10743
10732: POP
// Difficulty := 2 ; 3 :
10733: LD_ADDR_OWVAR 67
10737: PUSH
10738: LD_INT 2
10740: ST_TO_ADDR
10741: GO 10763
10743: LD_INT 3
10745: DOUBLE
10746: EQUAL
10747: IFTRUE 10751
10749: GO 10762
10751: POP
// Difficulty := 3 ; end ;
10752: LD_ADDR_OWVAR 67
10756: PUSH
10757: LD_INT 3
10759: ST_TO_ADDR
10760: GO 10763
10762: POP
// case Query ( QVul3 ) of 1 :
10763: LD_STRING QVul3
10765: PPUSH
10766: CALL_OW 97
10770: PUSH
10771: LD_INT 1
10773: DOUBLE
10774: EQUAL
10775: IFTRUE 10779
10777: GO 10802
10779: POP
// begin your_side := 1 ;
10780: LD_ADDR_OWVAR 2
10784: PUSH
10785: LD_INT 1
10787: ST_TO_ADDR
// legion_enemy := 1 ;
10788: LD_ADDR_EXP 36
10792: PUSH
10793: LD_INT 1
10795: ST_TO_ADDR
// PrepareAmerican ;
10796: CALL 214 0 0
// end ; 2 :
10800: GO 10865
10802: LD_INT 2
10804: DOUBLE
10805: EQUAL
10806: IFTRUE 10810
10808: GO 10833
10810: POP
// begin your_side := 2 ;
10811: LD_ADDR_OWVAR 2
10815: PUSH
10816: LD_INT 2
10818: ST_TO_ADDR
// legion_enemy := 2 ;
10819: LD_ADDR_EXP 36
10823: PUSH
10824: LD_INT 2
10826: ST_TO_ADDR
// PrepareArabian ;
10827: CALL 17454 0 0
// end ; 3 :
10831: GO 10865
10833: LD_INT 3
10835: DOUBLE
10836: EQUAL
10837: IFTRUE 10841
10839: GO 10864
10841: POP
// begin your_side := 7 ;
10842: LD_ADDR_OWVAR 2
10846: PUSH
10847: LD_INT 7
10849: ST_TO_ADDR
// legion_enemy := 7 ;
10850: LD_ADDR_EXP 36
10854: PUSH
10855: LD_INT 7
10857: ST_TO_ADDR
// PrepareAlliance ;
10858: CALL 14865 0 0
// end ; end ;
10862: GO 10865
10864: POP
// if your_side = 1 then
10865: LD_OWVAR 2
10869: PUSH
10870: LD_INT 1
10872: EQUAL
10873: IFFALSE 11227
// begin case Query ( QVul4 ) of 1 :
10875: LD_STRING QVul4
10877: PPUSH
10878: CALL_OW 97
10882: PUSH
10883: LD_INT 1
10885: DOUBLE
10886: EQUAL
10887: IFTRUE 10891
10889: GO 10894
10891: POP
// ; end ;
10892: GO 10895
10894: POP
// InGameOn ;
10895: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10899: LD_INT 8
10901: PPUSH
10902: LD_INT 5
10904: PPUSH
10905: CALL_OW 86
// uc_side := 4 ;
10909: LD_ADDR_OWVAR 20
10913: PUSH
10914: LD_INT 4
10916: ST_TO_ADDR
// uc_nation := 1 ;
10917: LD_ADDR_OWVAR 21
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// hc_importance := 0 ;
10925: LD_ADDR_OWVAR 32
10929: PUSH
10930: LD_INT 0
10932: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10933: LD_INT 1
10935: PPUSH
10936: LD_INT 3
10938: PPUSH
10939: LD_EXP 21
10943: PPUSH
10944: CALL_OW 380
// un := CreateHuman ;
10948: LD_ADDR_VAR 0 2
10952: PUSH
10953: CALL_OW 44
10957: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10958: LD_VAR 0 2
10962: PPUSH
10963: LD_INT 12
10965: PPUSH
10966: LD_INT 9
10968: PPUSH
10969: LD_INT 0
10971: PPUSH
10972: CALL_OW 48
// hc_name := Stuart Carey ;
10976: LD_ADDR_OWVAR 26
10980: PUSH
10981: LD_STRING Stuart Carey
10983: ST_TO_ADDR
// hc_class := 1 ;
10984: LD_ADDR_OWVAR 28
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// hc_gallery := vulcano ;
10992: LD_ADDR_OWVAR 33
10996: PUSH
10997: LD_STRING vulcano
10999: ST_TO_ADDR
// hc_face_number := 1 ;
11000: LD_ADDR_OWVAR 34
11004: PUSH
11005: LD_INT 1
11007: ST_TO_ADDR
// us_guy := CreateHuman ;
11008: LD_ADDR_EXP 22
11012: PUSH
11013: CALL_OW 44
11017: ST_TO_ADDR
// hc_gallery :=  ;
11018: LD_ADDR_OWVAR 33
11022: PUSH
11023: LD_STRING 
11025: ST_TO_ADDR
// hc_name :=  ;
11026: LD_ADDR_OWVAR 26
11030: PUSH
11031: LD_STRING 
11033: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11034: LD_VAR 0 2
11038: PPUSH
11039: LD_EXP 19
11043: PPUSH
11044: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11048: LD_EXP 19
11052: PPUSH
11053: LD_VAR 0 2
11057: PPUSH
11058: CALL_OW 119
// Say ( un , VD-un1 ) ;
11062: LD_VAR 0 2
11066: PPUSH
11067: LD_STRING VD-un1
11069: PPUSH
11070: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11074: LD_EXP 19
11078: PPUSH
11079: LD_STRING VDc-1
11081: PPUSH
11082: CALL_OW 88
// Say ( un , VD-un2 ) ;
11086: LD_VAR 0 2
11090: PPUSH
11091: LD_STRING VD-un2
11093: PPUSH
11094: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11098: LD_EXP 19
11102: PPUSH
11103: LD_STRING VDc-2
11105: PPUSH
11106: CALL_OW 88
// Say ( un , VD-un3 ) ;
11110: LD_VAR 0 2
11114: PPUSH
11115: LD_STRING VD-un3
11117: PPUSH
11118: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11122: LD_INT 7
11124: PPUSH
11125: CALL_OW 67
// Say ( un , VD-un4 ) ;
11129: LD_VAR 0 2
11133: PPUSH
11134: LD_STRING VD-un4
11136: PPUSH
11137: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11141: LD_VAR 0 2
11145: PPUSH
11146: LD_INT 2
11148: PPUSH
11149: LD_INT 2
11151: PPUSH
11152: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11156: LD_EXP 19
11160: PPUSH
11161: LD_STRING VDc-3
11163: PPUSH
11164: CALL_OW 88
// InGameOff ;
11168: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11172: LD_STRING CVulc1
11174: PPUSH
11175: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11179: LD_INT 35
11181: PPUSH
11182: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11186: LD_VAR 0 2
11190: PPUSH
11191: CALL_OW 250
11195: PUSH
11196: LD_INT 2
11198: EQUAL
11199: PUSH
11200: LD_VAR 0 2
11204: PPUSH
11205: CALL_OW 251
11209: PUSH
11210: LD_INT 2
11212: EQUAL
11213: AND
11214: IFFALSE 11179
// RemoveUnit ( un ) ;
11216: LD_VAR 0 2
11220: PPUSH
11221: CALL_OW 64
// end else
11225: GO 11519
// if your_side = 2 then
11227: LD_OWVAR 2
11231: PUSH
11232: LD_INT 2
11234: EQUAL
11235: IFFALSE 11407
// begin CenterNowOnUnits ( player_commander ) ;
11237: LD_EXP 10
11241: PPUSH
11242: CALL_OW 87
// InGameOn ;
11246: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11250: LD_EXP 51
11254: PPUSH
11255: LD_STRING VSd-1
11257: PPUSH
11258: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11262: LD_INT 22
11264: PUSH
11265: LD_INT 2
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PUSH
11272: LD_INT 21
11274: PUSH
11275: LD_INT 1
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 26
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: EMPTY
11293: LIST
11294: LIST
11295: LIST
11296: PUSH
11297: EMPTY
11298: LIST
11299: PPUSH
11300: CALL_OW 69
11304: PUSH
11305: LD_INT 2
11307: ARRAY
11308: PPUSH
11309: LD_STRING VAd-1
11311: PPUSH
11312: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11316: LD_EXP 51
11320: PPUSH
11321: LD_STRING VSd-2
11323: PPUSH
11324: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11328: LD_INT 22
11330: PUSH
11331: LD_INT 2
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 21
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 26
11350: PUSH
11351: LD_INT 1
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: LIST
11362: PUSH
11363: EMPTY
11364: LIST
11365: PPUSH
11366: CALL_OW 69
11370: PUSH
11371: LD_INT 2
11373: ARRAY
11374: PPUSH
11375: LD_STRING VAd-2
11377: PPUSH
11378: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11382: LD_EXP 51
11386: PPUSH
11387: LD_STRING VSd-3
11389: PPUSH
11390: CALL_OW 88
// InGameOff ;
11394: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11398: LD_STRING CVulc5
11400: PPUSH
11401: CALL_OW 337
// end else
11405: GO 11519
// if your_side = 7 then
11407: LD_OWVAR 2
11411: PUSH
11412: LD_INT 7
11414: EQUAL
11415: IFFALSE 11519
// begin CenterNowOnUnits ( al_commander ) ;
11417: LD_EXP 37
11421: PPUSH
11422: CALL_OW 87
// InGameOn ;
11426: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11430: LD_EXP 37
11434: PPUSH
11435: LD_STRING VPd-1
11437: PPUSH
11438: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11442: LD_INT 22
11444: PUSH
11445: LD_INT 7
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: PUSH
11452: LD_INT 21
11454: PUSH
11455: LD_INT 1
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: PUSH
11462: LD_INT 26
11464: PUSH
11465: LD_INT 1
11467: PUSH
11468: EMPTY
11469: LIST
11470: LIST
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: LIST
11476: PUSH
11477: EMPTY
11478: LIST
11479: PPUSH
11480: CALL_OW 69
11484: PUSH
11485: LD_INT 2
11487: ARRAY
11488: PPUSH
11489: LD_STRING VPpd-1
11491: PPUSH
11492: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11496: LD_EXP 37
11500: PPUSH
11501: LD_STRING VPd-2
11503: PPUSH
11504: CALL_OW 88
// InGameOff ;
11508: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11512: LD_STRING CVulc7
11514: PPUSH
11515: CALL_OW 337
// end ; end ;
11519: LD_VAR 0 1
11523: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11524: LD_INT 22
11526: PUSH
11527: LD_INT 2
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 30
11536: PUSH
11537: LD_INT 3
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PPUSH
11548: CALL_OW 69
11552: IFFALSE 11596
11554: GO 11556
11556: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11557: LD_STRING CVulc6
11559: PPUSH
11560: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11564: LD_INT 52500
11566: PUSH
11567: LD_INT 47250
11569: PUSH
11570: LD_INT 42000
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: LIST
11577: PUSH
11578: LD_OWVAR 67
11582: ARRAY
11583: PPUSH
11584: CALL_OW 67
// ru_can_attack := true ;
11588: LD_ADDR_EXP 3
11592: PUSH
11593: LD_INT 1
11595: ST_TO_ADDR
// end ;
11596: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11597: LD_INT 50
11599: PPUSH
11600: CALL_OW 255
11604: PUSH
11605: LD_INT 1
11607: EQUAL
11608: PUSH
11609: LD_INT 22
11611: PUSH
11612: LD_INT 1
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 2
11621: PUSH
11622: LD_INT 30
11624: PUSH
11625: LD_INT 3
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PUSH
11632: LD_INT 30
11634: PUSH
11635: LD_INT 1
11637: PUSH
11638: EMPTY
11639: LIST
11640: LIST
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: LIST
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: PPUSH
11651: CALL_OW 69
11655: OR
11656: IFFALSE 11833
11658: GO 11660
11660: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11661: LD_STRING CVulc2
11663: PPUSH
11664: CALL_OW 337
// DialogueOn ;
11668: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11672: LD_INT 10
11674: PPUSH
11675: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11679: LD_INT 22
11681: PUSH
11682: LD_INT 1
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PUSH
11689: LD_INT 25
11691: PUSH
11692: LD_INT 2
11694: PUSH
11695: EMPTY
11696: LIST
11697: LIST
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: PPUSH
11703: CALL_OW 69
11707: PUSH
11708: LD_EXP 19
11712: DIFF
11713: PUSH
11714: LD_INT 1
11716: ARRAY
11717: PPUSH
11718: LD_STRING VDb-1
11720: PPUSH
11721: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11725: LD_INT 10
11727: PPUSH
11728: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11732: LD_INT 22
11734: PUSH
11735: LD_INT 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 25
11744: PUSH
11745: LD_INT 4
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: EMPTY
11753: LIST
11754: LIST
11755: PPUSH
11756: CALL_OW 69
11760: PUSH
11761: LD_EXP 19
11765: DIFF
11766: PUSH
11767: LD_INT 1
11769: ARRAY
11770: PPUSH
11771: LD_STRING VDb-2
11773: PPUSH
11774: CALL_OW 88
// DWait ( 0 0$01 ) ;
11778: LD_INT 35
11780: PPUSH
11781: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11785: LD_EXP 19
11789: PPUSH
11790: LD_STRING VDb-com1
11792: PPUSH
11793: CALL_OW 88
// DialogueOff ;
11797: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11801: LD_INT 44100
11803: PUSH
11804: LD_INT 36750
11806: PUSH
11807: LD_INT 31500
11809: PUSH
11810: EMPTY
11811: LIST
11812: LIST
11813: LIST
11814: PUSH
11815: LD_OWVAR 67
11819: ARRAY
11820: PPUSH
11821: CALL_OW 67
// ru_can_attack := true ;
11825: LD_ADDR_EXP 3
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// end ;
11833: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11834: LD_INT 22
11836: PUSH
11837: LD_INT 7
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 30
11846: PUSH
11847: LD_INT 3
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: PPUSH
11858: CALL_OW 69
11862: IFFALSE 11899
11864: GO 11866
11866: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11867: LD_INT 42000
11869: PUSH
11870: LD_INT 34650
11872: PUSH
11873: LD_INT 29400
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: LIST
11880: PUSH
11881: LD_OWVAR 67
11885: ARRAY
11886: PPUSH
11887: CALL_OW 67
// ru_can_attack := true ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_INT 1
11898: ST_TO_ADDR
// end ;
11899: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11900: LD_INT 58
11902: PPUSH
11903: CALL_OW 255
11907: PUSH
11908: LD_INT 1
11910: EQUAL
11911: IFFALSE 12043
11913: GO 11915
11915: DISABLE
// begin DialogueOn ;
11916: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11920: LD_INT 22
11922: PUSH
11923: LD_INT 1
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PUSH
11930: LD_INT 25
11932: PUSH
11933: LD_INT 2
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PPUSH
11944: CALL_OW 69
11948: PUSH
11949: LD_INT 1
11951: ARRAY
11952: PPUSH
11953: LD_STRING VDe-1
11955: PPUSH
11956: CALL_OW 88
// case Query ( SibNote ) of 1 :
11960: LD_STRING SibNote
11962: PPUSH
11963: CALL_OW 97
11967: PUSH
11968: LD_INT 1
11970: DOUBLE
11971: EQUAL
11972: IFTRUE 11976
11974: GO 11979
11976: POP
// ; end ;
11977: GO 11980
11979: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11980: LD_INT 22
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 25
11992: PUSH
11993: LD_INT 2
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: PUSH
12009: LD_INT 1
12011: ARRAY
12012: PPUSH
12013: LD_STRING VDe-2
12015: PPUSH
12016: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12020: LD_EXP 19
12024: PPUSH
12025: LD_STRING VDc-4
12027: PPUSH
12028: CALL_OW 88
// DialogueOff ;
12032: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12036: LD_STRING CVulc3
12038: PPUSH
12039: CALL_OW 337
// end ;
12043: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12044: LD_OWVAR 2
12048: PUSH
12049: LD_INT 1
12051: EQUAL
12052: PUSH
12053: LD_INT 22
12055: PUSH
12056: LD_INT 1
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: LD_INT 30
12065: PUSH
12066: LD_INT 3
12068: PUSH
12069: EMPTY
12070: LIST
12071: LIST
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 69
12081: PUSH
12082: LD_INT 0
12084: GREATER
12085: AND
12086: IFFALSE 12520
12088: GO 12090
12090: DISABLE
12091: LD_INT 0
12093: PPUSH
12094: PPUSH
12095: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12096: LD_INT 245
12098: PPUSH
12099: LD_INT 1295
12101: PPUSH
12102: CALL_OW 12
12106: PPUSH
12107: CALL_OW 67
// DialogueOn ;
12111: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12115: LD_EXP 22
12119: PPUSH
12120: LD_STRING VDG-1
12122: PPUSH
12123: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12127: LD_EXP 19
12131: PPUSH
12132: LD_STRING VDc-5
12134: PPUSH
12135: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12139: LD_EXP 22
12143: PPUSH
12144: LD_STRING VDG-2
12146: PPUSH
12147: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12151: LD_EXP 19
12155: PPUSH
12156: LD_STRING VDc-6
12158: PPUSH
12159: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12163: LD_EXP 22
12167: PPUSH
12168: LD_STRING VDG-3
12170: PPUSH
12171: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12175: LD_EXP 19
12179: PPUSH
12180: LD_STRING VDc-7
12182: PPUSH
12183: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12187: LD_EXP 22
12191: PPUSH
12192: LD_STRING VDG-4
12194: PPUSH
12195: CALL_OW 94
// DialogueOff ;
12199: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12203: LD_STRING CVulc4
12205: PPUSH
12206: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12210: LD_INT 18900
12212: PUSH
12213: LD_INT 21000
12215: PUSH
12216: LD_INT 23100
12218: PUSH
12219: EMPTY
12220: LIST
12221: LIST
12222: LIST
12223: PUSH
12224: LD_OWVAR 67
12228: ARRAY
12229: PPUSH
12230: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12234: LD_ADDR_VAR 0 1
12238: PUSH
12239: DOUBLE
12240: LD_INT 1
12242: DEC
12243: ST_TO_ADDR
12244: LD_INT 4
12246: PUSH
12247: LD_INT 5
12249: PUSH
12250: LD_INT 6
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: LIST
12257: PUSH
12258: LD_OWVAR 67
12262: ARRAY
12263: PUSH
12264: FOR_TO
12265: IFFALSE 12509
// begin uc_side := 1 ;
12267: LD_ADDR_OWVAR 20
12271: PUSH
12272: LD_INT 1
12274: ST_TO_ADDR
// uc_nation := 1 ;
12275: LD_ADDR_OWVAR 21
12279: PUSH
12280: LD_INT 1
12282: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12283: LD_INT 0
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: LD_INT 4
12291: PPUSH
12292: CALL_OW 12
12296: PPUSH
12297: LD_EXP 21
12301: PPUSH
12302: CALL_OW 380
// un := CreateHuman ;
12306: LD_ADDR_VAR 0 2
12310: PUSH
12311: CALL_OW 44
12315: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12316: LD_VAR 0 2
12320: PPUSH
12321: LD_INT 2
12323: PPUSH
12324: CALL_OW 233
// if GetClass ( un ) = 3 then
12328: LD_VAR 0 2
12332: PPUSH
12333: CALL_OW 257
12337: PUSH
12338: LD_INT 3
12340: EQUAL
12341: IFFALSE 12492
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12343: LD_ADDR_OWVAR 37
12347: PUSH
12348: LD_INT 2
12350: PUSH
12351: LD_INT 3
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_VAR 0 1
12362: PUSH
12363: LD_INT 2
12365: MOD
12366: ARRAY
12367: ST_TO_ADDR
// vc_engine := engine_combustion ;
12368: LD_ADDR_OWVAR 39
12372: PUSH
12373: LD_INT 1
12375: ST_TO_ADDR
// vc_control := control_manual ;
12376: LD_ADDR_OWVAR 38
12380: PUSH
12381: LD_INT 1
12383: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12384: LD_ADDR_OWVAR 40
12388: PUSH
12389: LD_INT 9
12391: PUSH
12392: LD_INT 9
12394: PUSH
12395: LD_INT 5
12397: PUSH
12398: LD_INT 11
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: PUSH
12407: LD_INT 1
12409: PPUSH
12410: LD_INT 4
12412: PPUSH
12413: CALL_OW 12
12417: ARRAY
12418: ST_TO_ADDR
// veh := CreateVehicle ;
12419: LD_ADDR_VAR 0 3
12423: PUSH
12424: CALL_OW 45
12428: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12429: LD_VAR 0 3
12433: PPUSH
12434: LD_INT 2
12436: PPUSH
12437: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12441: LD_VAR 0 3
12445: PPUSH
12446: LD_INT 77
12448: PPUSH
12449: LD_INT 88
12451: PPUSH
12452: CALL_OW 12
12456: PPUSH
12457: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12461: LD_VAR 0 3
12465: PPUSH
12466: LD_INT 1
12468: PPUSH
12469: LD_INT 0
12471: PPUSH
12472: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12476: LD_VAR 0 2
12480: PPUSH
12481: LD_VAR 0 3
12485: PPUSH
12486: CALL_OW 52
// end else
12490: GO 12507
// PlaceUnitArea ( un , start_north , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 1
12499: PPUSH
12500: LD_INT 0
12502: PPUSH
12503: CALL_OW 49
// end ;
12507: GO 12264
12509: POP
12510: POP
// CenterNowOnUnits ( un ) ;
12511: LD_VAR 0 2
12515: PPUSH
12516: CALL_OW 87
// end ;
12520: PPOPN 3
12522: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12523: LD_INT 21
12525: PPUSH
12526: LD_INT 22
12528: PUSH
12529: LD_OWVAR 2
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PPUSH
12538: CALL_OW 70
12542: IFFALSE 12764
12544: GO 12546
12546: DISABLE
12547: LD_INT 0
12549: PPUSH
12550: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12551: LD_ADDR_VAR 0 2
12555: PUSH
12556: LD_INT 22
12558: PUSH
12559: LD_OWVAR 2
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PUSH
12568: LD_INT 2
12570: PUSH
12571: LD_INT 25
12573: PUSH
12574: LD_INT 1
12576: PUSH
12577: EMPTY
12578: LIST
12579: LIST
12580: PUSH
12581: LD_INT 25
12583: PUSH
12584: LD_INT 2
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: PUSH
12591: LD_INT 25
12593: PUSH
12594: LD_INT 3
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 25
12603: PUSH
12604: LD_INT 4
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PPUSH
12622: CALL_OW 69
12626: PUSH
12627: LD_EXP 10
12631: DIFF
12632: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_VAR 0 2
12642: PPUSH
12643: LD_INT 112
12645: PPUSH
12646: LD_INT 67
12648: PPUSH
12649: CALL_OW 73
12653: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12654: LD_VAR 0 1
12658: PPUSH
12659: CALL_OW 255
12663: PUSH
12664: LD_INT 7
12666: EQUAL
12667: IFFALSE 12681
// Say ( un , VD-find-al ) ;
12669: LD_VAR 0 1
12673: PPUSH
12674: LD_STRING VD-find-al
12676: PPUSH
12677: CALL_OW 88
// if GetSide ( un ) = 2 then
12681: LD_VAR 0 1
12685: PPUSH
12686: CALL_OW 255
12690: PUSH
12691: LD_INT 2
12693: EQUAL
12694: IFFALSE 12708
// Say ( un , VD-find-ar ) ;
12696: LD_VAR 0 1
12700: PPUSH
12701: LD_STRING VD-find-ar
12703: PPUSH
12704: CALL_OW 88
// if GetSide ( un ) = 1 then
12708: LD_VAR 0 1
12712: PPUSH
12713: CALL_OW 255
12717: PUSH
12718: LD_INT 1
12720: EQUAL
12721: IFFALSE 12747
// begin Say ( un , VD-find-us ) ;
12723: LD_VAR 0 1
12727: PPUSH
12728: LD_STRING VD-find-us
12730: PPUSH
12731: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12735: LD_VAR 0 1
12739: PPUSH
12740: LD_STRING VD-find-us2
12742: PPUSH
12743: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12747: LD_INT 10
12749: PPUSH
12750: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12754: LD_INT 112
12756: PPUSH
12757: LD_INT 67
12759: PPUSH
12760: CALL_OW 86
// end ;
12764: PPOPN 2
12766: END
// every 0 0$01 trigger player_artifact_ready do
12767: LD_EXP 7
12771: IFFALSE 13085
12773: GO 12775
12775: DISABLE
// begin if your_side = 1 then
12776: LD_OWVAR 2
12780: PUSH
12781: LD_INT 1
12783: EQUAL
12784: IFFALSE 12902
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12786: LD_INT 22
12788: PUSH
12789: LD_INT 1
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 25
12798: PUSH
12799: LD_INT 4
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PPUSH
12810: CALL_OW 69
12814: PUSH
12815: LD_EXP 19
12819: DIFF
12820: PUSH
12821: LD_INT 1
12823: ARRAY
12824: PPUSH
12825: LD_STRING VD-us-sci-art-1
12827: PPUSH
12828: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12832: LD_EXP 19
12836: PPUSH
12837: LD_STRING VDc-art1
12839: PPUSH
12840: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12844: LD_INT 22
12846: PUSH
12847: LD_INT 1
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: LD_INT 25
12856: PUSH
12857: LD_INT 4
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PPUSH
12868: CALL_OW 69
12872: PUSH
12873: LD_EXP 19
12877: DIFF
12878: PUSH
12879: LD_INT 1
12881: ARRAY
12882: PPUSH
12883: LD_STRING VD-us-sci-art-2
12885: PPUSH
12886: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12890: LD_EXP 19
12894: PPUSH
12895: LD_STRING VDc-art2
12897: PPUSH
12898: CALL_OW 88
// end ; if your_side = 2 then
12902: LD_OWVAR 2
12906: PUSH
12907: LD_INT 2
12909: EQUAL
12910: IFFALSE 12952
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12912: LD_INT 22
12914: PUSH
12915: LD_INT 2
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 25
12924: PUSH
12925: LD_INT 4
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PPUSH
12936: CALL_OW 69
12940: PUSH
12941: LD_INT 1
12943: ARRAY
12944: PPUSH
12945: LD_STRING VD-ar-sci-art-1
12947: PPUSH
12948: CALL_OW 88
// end ; if your_side = 7 then
12952: LD_OWVAR 2
12956: PUSH
12957: LD_INT 7
12959: EQUAL
12960: IFFALSE 13085
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 25
12974: PUSH
12975: LD_INT 4
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PPUSH
12986: CALL_OW 69
12990: PUSH
12991: LD_EXP 37
12995: DIFF
12996: PUSH
12997: LD_INT 1
12999: ARRAY
13000: PPUSH
13001: LD_STRING VD-al-sci-art-1
13003: PPUSH
13004: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13008: LD_EXP 37
13012: PPUSH
13013: LD_STRING VPd-art-1
13015: PPUSH
13016: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13020: LD_INT 22
13022: PUSH
13023: LD_INT 7
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PUSH
13030: LD_INT 25
13032: PUSH
13033: LD_INT 4
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PPUSH
13044: CALL_OW 69
13048: PUSH
13049: LD_EXP 37
13053: DIFF
13054: PUSH
13055: LD_INT 1
13057: ARRAY
13058: PPUSH
13059: LD_STRING VD-al-sci-art-2
13061: PPUSH
13062: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13066: LD_EXP 37
13070: PPUSH
13071: LD_STRING VPd-art-2
13073: PPUSH
13074: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13078: LD_STRING CVulc7out
13080: PPUSH
13081: CALL_OW 337
// end ; end ;
13085: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13086: LD_INT 8
13088: PPUSH
13089: LD_INT 22
13091: PUSH
13092: LD_OWVAR 2
13096: PUSH
13097: EMPTY
13098: LIST
13099: LIST
13100: PPUSH
13101: CALL_OW 69
13105: PPUSH
13106: LD_INT 8
13108: PPUSH
13109: CALL 2138 0 2
13113: PPUSH
13114: CALL_OW 292
13118: IFFALSE 13209
13120: GO 13122
13122: DISABLE
// begin if your_side = 1 then
13123: LD_OWVAR 2
13127: PUSH
13128: LD_INT 1
13130: EQUAL
13131: IFFALSE 13165
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13133: LD_INT 22
13135: PUSH
13136: LD_INT 1
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PPUSH
13143: CALL_OW 69
13147: PUSH
13148: LD_EXP 19
13152: DIFF
13153: PUSH
13154: LD_INT 1
13156: ARRAY
13157: PPUSH
13158: LD_STRING VD-legion-us
13160: PPUSH
13161: CALL_OW 88
// if your_side = 2 then
13165: LD_OWVAR 2
13169: PUSH
13170: LD_INT 2
13172: EQUAL
13173: IFFALSE 13187
// Say ( ar_commander , VD-legion-ar ) ;
13175: LD_EXP 51
13179: PPUSH
13180: LD_STRING VD-legion-ar
13182: PPUSH
13183: CALL_OW 88
// if your_side = 7 then
13187: LD_OWVAR 2
13191: PUSH
13192: LD_INT 7
13194: EQUAL
13195: IFFALSE 13209
// Say ( al_commander , VD-legion-al ) ;
13197: LD_EXP 37
13201: PPUSH
13202: LD_STRING VD-legion-al
13204: PPUSH
13205: CALL_OW 88
// end ;
13209: END
// every 0 0$01 trigger mine_vulc do
13210: LD_EXP 12
13214: IFFALSE 13231
13216: GO 13218
13218: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13219: LD_EXP 10
13223: PPUSH
13224: LD_STRING VD-vulc-mines
13226: PPUSH
13227: CALL_OW 88
// end ;
13231: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13232: LD_OWVAR 67
13236: PUSH
13237: LD_INT 1
13239: GREATER
13240: IFFALSE 13359
13242: GO 13244
13244: DISABLE
13245: LD_INT 0
13247: PPUSH
13248: PPUSH
13249: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13250: LD_ADDR_VAR 0 1
13254: PUSH
13255: LD_INT 123
13257: PUSH
13258: LD_INT 95
13260: PUSH
13261: LD_INT 119
13263: PUSH
13264: LD_INT 89
13266: PUSH
13267: LD_INT 115
13269: PUSH
13270: LD_INT 81
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: ST_TO_ADDR
// p := 1 ;
13281: LD_ADDR_VAR 0 2
13285: PUSH
13286: LD_INT 1
13288: ST_TO_ADDR
// for i = 1 to 3 do
13289: LD_ADDR_VAR 0 3
13293: PUSH
13294: DOUBLE
13295: LD_INT 1
13297: DEC
13298: ST_TO_ADDR
13299: LD_INT 3
13301: PUSH
13302: FOR_TO
13303: IFFALSE 13357
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13305: LD_VAR 0 1
13309: PUSH
13310: LD_VAR 0 2
13314: ARRAY
13315: PPUSH
13316: LD_VAR 0 1
13320: PUSH
13321: LD_VAR 0 2
13325: PUSH
13326: LD_INT 1
13328: PLUS
13329: ARRAY
13330: PPUSH
13331: LD_INT 8
13333: PPUSH
13334: LD_INT 0
13336: PPUSH
13337: CALL_OW 454
// p := p + 2 ;
13341: LD_ADDR_VAR 0 2
13345: PUSH
13346: LD_VAR 0 2
13350: PUSH
13351: LD_INT 2
13353: PLUS
13354: ST_TO_ADDR
// end ;
13355: GO 13302
13357: POP
13358: POP
// end ;
13359: PPOPN 3
13361: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13362: LD_OWVAR 67
13366: PUSH
13367: LD_INT 1
13369: GREATER
13370: PUSH
13371: LD_INT 22
13373: PPUSH
13374: LD_INT 22
13376: PUSH
13377: LD_OWVAR 2
13381: PUSH
13382: EMPTY
13383: LIST
13384: LIST
13385: PPUSH
13386: CALL_OW 70
13390: AND
13391: IFFALSE 13595
13393: GO 13395
13395: DISABLE
13396: LD_INT 0
13398: PPUSH
13399: PPUSH
13400: PPUSH
// begin enable ;
13401: ENABLE
// p := 1 ;
13402: LD_ADDR_VAR 0 1
13406: PUSH
13407: LD_INT 1
13409: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13410: LD_ADDR_VAR 0 3
13414: PUSH
13415: LD_INT 123
13417: PUSH
13418: LD_INT 95
13420: PUSH
13421: LD_INT 119
13423: PUSH
13424: LD_INT 89
13426: PUSH
13427: LD_INT 115
13429: PUSH
13430: LD_INT 81
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: ST_TO_ADDR
// for i = 1 to 3 do
13441: LD_ADDR_VAR 0 2
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_INT 3
13453: PUSH
13454: FOR_TO
13455: IFFALSE 13593
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13457: LD_VAR 0 3
13461: PUSH
13462: LD_VAR 0 1
13466: ARRAY
13467: PPUSH
13468: LD_VAR 0 3
13472: PUSH
13473: LD_VAR 0 1
13477: PUSH
13478: LD_INT 1
13480: PLUS
13481: ARRAY
13482: PPUSH
13483: CALL_OW 428
13487: PUSH
13488: LD_INT 0
13490: GREATER
13491: IFFALSE 13577
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13493: LD_VAR 0 3
13497: PUSH
13498: LD_VAR 0 1
13502: ARRAY
13503: PPUSH
13504: LD_VAR 0 3
13508: PUSH
13509: LD_VAR 0 1
13513: PUSH
13514: LD_INT 1
13516: PLUS
13517: ARRAY
13518: PPUSH
13519: CALL_OW 428
13523: PPUSH
13524: CALL_OW 255
13528: PUSH
13529: LD_OWVAR 2
13533: EQUAL
13534: IFFALSE 13577
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13536: LD_VAR 0 3
13540: PUSH
13541: LD_VAR 0 1
13545: ARRAY
13546: PPUSH
13547: LD_VAR 0 3
13551: PUSH
13552: LD_VAR 0 1
13556: PUSH
13557: LD_INT 1
13559: PLUS
13560: ARRAY
13561: PPUSH
13562: LD_INT 8
13564: PPUSH
13565: CALL_OW 456
// mine_vulc := true ;
13569: LD_ADDR_EXP 12
13573: PUSH
13574: LD_INT 1
13576: ST_TO_ADDR
// end ; p := p + 2 ;
13577: LD_ADDR_VAR 0 1
13581: PUSH
13582: LD_VAR 0 1
13586: PUSH
13587: LD_INT 2
13589: PLUS
13590: ST_TO_ADDR
// end ;
13591: GO 13454
13593: POP
13594: POP
// end ;
13595: PPOPN 3
13597: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13598: LD_INT 22
13600: PUSH
13601: LD_INT 3
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PPUSH
13608: CALL_OW 69
13612: PUSH
13613: LD_INT 0
13615: EQUAL
13616: PUSH
13617: LD_OWVAR 2
13621: PUSH
13622: LD_INT 2
13624: NONEQUAL
13625: AND
13626: IFFALSE 13635
13628: GO 13630
13630: DISABLE
// Win ;
13631: CALL 13692 0 0
13635: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13636: LD_INT 2
13638: PUSH
13639: LD_INT 22
13641: PUSH
13642: LD_INT 8
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PUSH
13649: LD_INT 22
13651: PUSH
13652: LD_INT 3
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: PUSH
13659: EMPTY
13660: LIST
13661: LIST
13662: LIST
13663: PPUSH
13664: CALL_OW 69
13668: PUSH
13669: LD_INT 0
13671: EQUAL
13672: PUSH
13673: LD_OWVAR 2
13677: PUSH
13678: LD_INT 2
13680: EQUAL
13681: AND
13682: IFFALSE 13691
13684: GO 13686
13686: DISABLE
// Win ;
13687: CALL 13692 0 0
13691: END
// function Win ; var points ; begin
13692: LD_INT 0
13694: PPUSH
13695: PPUSH
// case Query ( VulcWin ) of 1 :
13696: LD_STRING VulcWin
13698: PPUSH
13699: CALL_OW 97
13703: PUSH
13704: LD_INT 1
13706: DOUBLE
13707: EQUAL
13708: IFTRUE 13712
13710: GO 13715
13712: POP
// ; end ;
13713: GO 13716
13715: POP
// if medal_enabled then
13716: LD_EXP 13
13720: IFFALSE 13734
// AddMedal ( vulc_1 , 1 ) else
13722: LD_STRING vulc_1
13724: PPUSH
13725: LD_INT 1
13727: PPUSH
13728: CALL_OW 101
13732: GO 13745
// AddMedal ( vulc_1 , - 1 ) ;
13734: LD_STRING vulc_1
13736: PPUSH
13737: LD_INT 1
13739: NEG
13740: PPUSH
13741: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13745: LD_INT 22
13747: PUSH
13748: LD_INT 8
13750: PUSH
13751: EMPTY
13752: LIST
13753: LIST
13754: PPUSH
13755: CALL_OW 69
13759: PUSH
13760: LD_INT 0
13762: EQUAL
13763: IFFALSE 13777
// AddMedal ( vulc_2 , 1 ) else
13765: LD_STRING vulc_2
13767: PPUSH
13768: LD_INT 1
13770: PPUSH
13771: CALL_OW 101
13775: GO 13788
// AddMedal ( vulc_2 , - 1 ) ;
13777: LD_STRING vulc_2
13779: PPUSH
13780: LD_INT 1
13782: NEG
13783: PPUSH
13784: CALL_OW 101
// points := CalculateCommanderPoints ;
13788: LD_ADDR_VAR 0 2
13792: PUSH
13793: CALL 2259 0 0
13797: ST_TO_ADDR
// if points >= 2000 then
13798: LD_VAR 0 2
13802: PUSH
13803: LD_INT 2000
13805: GREATEREQUAL
13806: IFFALSE 13820
// AddMedal ( vulc_3 , 2 ) else
13808: LD_STRING vulc_3
13810: PPUSH
13811: LD_INT 2
13813: PPUSH
13814: CALL_OW 101
13818: GO 13853
// if points >= 0 then
13820: LD_VAR 0 2
13824: PUSH
13825: LD_INT 0
13827: GREATEREQUAL
13828: IFFALSE 13842
// AddMedal ( vulc_3 , 1 ) else
13830: LD_STRING vulc_3
13832: PPUSH
13833: LD_INT 1
13835: PPUSH
13836: CALL_OW 101
13840: GO 13853
// AddMedal ( vulc_3 , - 1 ) ;
13842: LD_STRING vulc_3
13844: PPUSH
13845: LD_INT 1
13847: NEG
13848: PPUSH
13849: CALL_OW 101
// GiveMedals ( MAIN ) ;
13853: LD_STRING MAIN
13855: PPUSH
13856: CALL_OW 102
// YouWin ;
13860: CALL_OW 103
// end ; end_of_file
13864: LD_VAR 0 1
13868: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13869: LD_INT 13
13871: PPUSH
13872: LD_INT 21
13874: PUSH
13875: LD_INT 1
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 70
13886: PUSH
13887: LD_INT 0
13889: GREATER
13890: IFFALSE 13957
13892: GO 13894
13894: DISABLE
13895: LD_INT 0
13897: PPUSH
13898: PPUSH
// begin enable ;
13899: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13900: LD_ADDR_VAR 0 1
13904: PUSH
13905: LD_INT 13
13907: PPUSH
13908: LD_INT 21
13910: PUSH
13911: LD_INT 1
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: PPUSH
13918: CALL_OW 70
13922: PUSH
13923: FOR_IN
13924: IFFALSE 13955
// if GetLives ( i ) > 4 then
13926: LD_VAR 0 1
13930: PPUSH
13931: CALL_OW 256
13935: PUSH
13936: LD_INT 4
13938: GREATER
13939: IFFALSE 13953
// SetLives ( i , 4 ) ;
13941: LD_VAR 0 1
13945: PPUSH
13946: LD_INT 4
13948: PPUSH
13949: CALL_OW 234
13953: GO 13923
13955: POP
13956: POP
// end ;
13957: PPOPN 2
13959: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13960: LD_VAR 0 1
13964: PPUSH
13965: CALL_OW 255
13969: PUSH
13970: LD_OWVAR 2
13974: EQUAL
13975: IFFALSE 13985
// player_res_art := true ;
13977: LD_ADDR_EXP 6
13981: PUSH
13982: LD_INT 1
13984: ST_TO_ADDR
// end ;
13985: PPOPN 1
13987: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13988: LD_INT 22
13990: PUSH
13991: LD_OWVAR 2
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 2
14002: PUSH
14003: LD_INT 30
14005: PUSH
14006: LD_INT 8
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: PUSH
14013: LD_INT 30
14015: PUSH
14016: LD_INT 11
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: LIST
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PPUSH
14032: CALL_OW 69
14036: PUSH
14037: LD_EXP 6
14041: AND
14042: IFFALSE 14386
14044: GO 14046
14046: DISABLE
14047: LD_INT 0
14049: PPUSH
14050: PPUSH
14051: PPUSH
// begin enable ;
14052: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14053: LD_ADDR_VAR 0 1
14057: PUSH
14058: LD_INT 1
14060: PPUSH
14061: CALL_OW 469
14065: PUSH
14066: LD_INT 1
14068: ARRAY
14069: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14070: LD_ADDR_VAR 0 2
14074: PUSH
14075: LD_INT 1
14077: PPUSH
14078: CALL_OW 469
14082: PUSH
14083: LD_INT 2
14085: ARRAY
14086: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14087: LD_ADDR_VAR 0 3
14091: PUSH
14092: LD_INT 22
14094: PUSH
14095: LD_OWVAR 2
14099: PUSH
14100: EMPTY
14101: LIST
14102: LIST
14103: PUSH
14104: LD_INT 2
14106: PUSH
14107: LD_INT 30
14109: PUSH
14110: LD_INT 8
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 30
14119: PUSH
14120: LD_INT 11
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: LIST
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PPUSH
14136: CALL_OW 69
14140: PPUSH
14141: LD_VAR 0 1
14145: PPUSH
14146: LD_VAR 0 2
14150: PPUSH
14151: CALL_OW 73
14155: ST_TO_ADDR
// if player_artifact_ready = false then
14156: LD_EXP 7
14160: PUSH
14161: LD_INT 0
14163: EQUAL
14164: IFFALSE 14270
// if GetDistUnitXY ( lab , x , y ) < 6 then
14166: LD_VAR 0 3
14170: PPUSH
14171: LD_VAR 0 1
14175: PPUSH
14176: LD_VAR 0 2
14180: PPUSH
14181: CALL_OW 297
14185: PUSH
14186: LD_INT 6
14188: LESS
14189: IFFALSE 14250
// begin if BuildingStatus ( lab ) = bs_idle then
14191: LD_VAR 0 3
14195: PPUSH
14196: CALL_OW 461
14200: PUSH
14201: LD_INT 2
14203: EQUAL
14204: IFFALSE 14228
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14206: LD_OWVAR 2
14210: PPUSH
14211: LD_INT 1
14213: PPUSH
14214: LD_INT 2
14216: PPUSH
14217: LD_VAR 0 3
14221: PPUSH
14222: CALL_OW 468
14226: GO 14248
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14228: LD_OWVAR 2
14232: PPUSH
14233: LD_INT 1
14235: PPUSH
14236: LD_INT 1
14238: PPUSH
14239: LD_VAR 0 3
14243: PPUSH
14244: CALL_OW 468
// end else
14248: GO 14270
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14250: LD_OWVAR 2
14254: PPUSH
14255: LD_INT 1
14257: PPUSH
14258: LD_INT 1
14260: PPUSH
14261: LD_VAR 0 3
14265: PPUSH
14266: CALL_OW 468
// if player_artifact_ready then
14270: LD_EXP 7
14274: IFFALSE 14386
// if GetDistUnitXY ( lab , x , y ) < 6 then
14276: LD_VAR 0 3
14280: PPUSH
14281: LD_VAR 0 1
14285: PPUSH
14286: LD_VAR 0 2
14290: PPUSH
14291: CALL_OW 297
14295: PUSH
14296: LD_INT 6
14298: LESS
14299: IFFALSE 14364
// begin if BuildingStatus ( lab ) = bs_idle then
14301: LD_VAR 0 3
14305: PPUSH
14306: CALL_OW 461
14310: PUSH
14311: LD_INT 2
14313: EQUAL
14314: IFFALSE 14340
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14316: LD_OWVAR 2
14320: PPUSH
14321: LD_EXP 8
14325: PPUSH
14326: LD_INT 4
14328: PPUSH
14329: LD_VAR 0 3
14333: PPUSH
14334: CALL_OW 468
14338: GO 14362
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14340: LD_OWVAR 2
14344: PPUSH
14345: LD_EXP 8
14349: PPUSH
14350: LD_INT 1
14352: PPUSH
14353: LD_VAR 0 3
14357: PPUSH
14358: CALL_OW 468
// end else
14362: GO 14386
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14364: LD_OWVAR 2
14368: PPUSH
14369: LD_EXP 8
14373: PPUSH
14374: LD_INT 1
14376: PPUSH
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 468
// end ;
14386: PPOPN 3
14388: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14389: LD_INT 0
14391: PPUSH
14392: PPUSH
14393: PPUSH
14394: PPUSH
14395: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14396: LD_ADDR_VAR 0 5
14400: PUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 469
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14413: LD_ADDR_VAR 0 6
14417: PUSH
14418: LD_INT 1
14420: PPUSH
14421: CALL_OW 469
14425: PUSH
14426: LD_INT 2
14428: ARRAY
14429: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14430: LD_ADDR_VAR 0 8
14434: PUSH
14435: LD_INT 22
14437: PUSH
14438: LD_OWVAR 2
14442: PUSH
14443: EMPTY
14444: LIST
14445: LIST
14446: PUSH
14447: LD_INT 2
14449: PUSH
14450: LD_INT 30
14452: PUSH
14453: LD_INT 8
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 30
14462: PUSH
14463: LD_INT 11
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: PUSH
14475: EMPTY
14476: LIST
14477: LIST
14478: PPUSH
14479: CALL_OW 69
14483: PPUSH
14484: LD_VAR 0 5
14488: PPUSH
14489: LD_VAR 0 6
14493: PPUSH
14494: CALL_OW 73
14498: ST_TO_ADDR
// if icon = art_exp_left then
14499: LD_VAR 0 2
14503: PUSH
14504: LD_INT 1
14506: EQUAL
14507: IFFALSE 14546
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14509: LD_VAR 0 8
14513: PPUSH
14514: LD_EXP 9
14518: PPUSH
14519: LD_INT 1
14521: PPUSH
14522: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14526: LD_OWVAR 2
14530: PPUSH
14531: LD_INT 1
14533: PPUSH
14534: LD_INT 0
14536: PPUSH
14537: LD_VAR 0 8
14541: PPUSH
14542: CALL_OW 468
// end ; if icon = art_icon then
14546: LD_VAR 0 2
14550: PUSH
14551: LD_EXP 8
14555: EQUAL
14556: IFFALSE 14762
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14558: LD_VAR 0 3
14562: PUSH
14563: LD_INT 21
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PPUSH
14573: CALL_OW 69
14577: IN
14578: IFFALSE 14762
// begin side := GetSide ( cr1 ) ;
14580: LD_ADDR_VAR 0 9
14584: PUSH
14585: LD_VAR 0 3
14589: PPUSH
14590: CALL_OW 255
14594: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14595: LD_INT 22
14597: PUSH
14598: LD_VAR 0 9
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: LD_INT 30
14609: PUSH
14610: LD_INT 28
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PPUSH
14621: CALL_OW 69
14625: PUSH
14626: LD_INT 0
14628: GREATER
14629: IFFALSE 14762
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14631: LD_ADDR_VAR 0 7
14635: PUSH
14636: LD_INT 22
14638: PUSH
14639: LD_VAR 0 9
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 2
14650: PUSH
14651: LD_INT 30
14653: PUSH
14654: LD_INT 26
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: LD_INT 30
14663: PUSH
14664: LD_INT 27
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PUSH
14671: LD_INT 30
14673: PUSH
14674: LD_INT 28
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PPUSH
14691: CALL_OW 69
14695: PUSH
14696: FOR_IN
14697: IFFALSE 14713
// SetLives ( i , 1 ) ;
14699: LD_VAR 0 7
14703: PPUSH
14704: LD_INT 1
14706: PPUSH
14707: CALL_OW 234
14711: GO 14696
14713: POP
14714: POP
// player_res_art := false ;
14715: LD_ADDR_EXP 6
14719: PUSH
14720: LD_INT 0
14722: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14723: LD_OWVAR 2
14727: PPUSH
14728: LD_EXP 8
14732: PPUSH
14733: LD_INT 1
14735: PPUSH
14736: LD_VAR 0 8
14740: PPUSH
14741: CALL_OW 468
// Wait ( time_to_reuse ) ;
14745: LD_EXP 11
14749: PPUSH
14750: CALL_OW 67
// player_res_art := true ;
14754: LD_ADDR_EXP 6
14758: PUSH
14759: LD_INT 1
14761: ST_TO_ADDR
// end ; end ; end ; end ;
14762: PPOPN 9
14764: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14765: LD_VAR 0 1
14769: PPUSH
14770: CALL_OW 255
14774: PUSH
14775: LD_OWVAR 2
14779: EQUAL
14780: IFFALSE 14817
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14782: LD_OWVAR 2
14786: PPUSH
14787: LD_INT 1
14789: PPUSH
14790: LD_INT 0
14792: PPUSH
14793: LD_VAR 0 1
14797: PPUSH
14798: CALL_OW 468
// player_artifact_ready := true ;
14802: LD_ADDR_EXP 7
14806: PUSH
14807: LD_INT 1
14809: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14810: LD_STRING ArtVulcano
14812: PPUSH
14813: CALL_OW 339
// end ; end ;
14817: PPOPN 1
14819: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14820: LD_OWVAR 2
14824: PPUSH
14825: LD_INT 1
14827: PPUSH
14828: LD_INT 2
14830: PPUSH
14831: LD_VAR 0 1
14835: PPUSH
14836: CALL_OW 468
// end ; end_of_file
14840: PPOPN 2
14842: END
// every 0 0$01 do
14843: GO 14845
14845: DISABLE
// begin enable ;
14846: ENABLE
// Display_Strings := [ #tick , tick ] ;
14847: LD_ADDR_OWVAR 47
14851: PUSH
14852: LD_STRING #tick
14854: PUSH
14855: LD_OWVAR 1
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: ST_TO_ADDR
// end ; end_of_file
14864: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14865: LD_INT 0
14867: PPUSH
14868: PPUSH
14869: PPUSH
14870: PPUSH
14871: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14872: LD_ADDR_EXP 39
14876: PUSH
14877: LD_INT 7
14879: PUSH
14880: LD_INT 6
14882: PUSH
14883: LD_INT 5
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: LIST
14890: PUSH
14891: LD_OWVAR 67
14895: ARRAY
14896: ST_TO_ADDR
// al_force := [ ] ;
14897: LD_ADDR_EXP 38
14901: PUSH
14902: EMPTY
14903: ST_TO_ADDR
// RemoveAlliance ;
14904: CALL 15282 0 0
// ResetFog ;
14908: CALL_OW 335
// your_side := 7 ;
14912: LD_ADDR_OWVAR 2
14916: PUSH
14917: LD_INT 7
14919: ST_TO_ADDR
// uc_side := 7 ;
14920: LD_ADDR_OWVAR 20
14924: PUSH
14925: LD_INT 7
14927: ST_TO_ADDR
// hc_gallery :=  ;
14928: LD_ADDR_OWVAR 33
14932: PUSH
14933: LD_STRING 
14935: ST_TO_ADDR
// hc_name :=  ;
14936: LD_ADDR_OWVAR 26
14940: PUSH
14941: LD_STRING 
14943: ST_TO_ADDR
// hc_importance := 0 ;
14944: LD_ADDR_OWVAR 32
14948: PUSH
14949: LD_INT 0
14951: ST_TO_ADDR
// for i = 1 to 17 do
14952: LD_ADDR_VAR 0 2
14956: PUSH
14957: DOUBLE
14958: LD_INT 1
14960: DEC
14961: ST_TO_ADDR
14962: LD_INT 17
14964: PUSH
14965: FOR_TO
14966: IFFALSE 15046
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14968: LD_ADDR_OWVAR 21
14972: PUSH
14973: LD_INT 1
14975: PUSH
14976: LD_INT 3
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PUSH
14983: LD_INT 1
14985: PPUSH
14986: LD_INT 2
14988: PPUSH
14989: CALL_OW 12
14993: ARRAY
14994: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14995: LD_INT 0
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: LD_INT 4
15003: PPUSH
15004: CALL_OW 12
15008: PPUSH
15009: LD_EXP 39
15013: PPUSH
15014: CALL_OW 380
// un := CreateHuman ;
15018: LD_ADDR_VAR 0 4
15022: PUSH
15023: CALL_OW 44
15027: ST_TO_ADDR
// al_force := al_force ^ un ;
15028: LD_ADDR_EXP 38
15032: PUSH
15033: LD_EXP 38
15037: PUSH
15038: LD_VAR 0 4
15042: ADD
15043: ST_TO_ADDR
// end ;
15044: GO 14965
15046: POP
15047: POP
// hc_importance := 100 ;
15048: LD_ADDR_OWVAR 32
15052: PUSH
15053: LD_INT 100
15055: ST_TO_ADDR
// uc_nation := 1 ;
15056: LD_ADDR_OWVAR 21
15060: PUSH
15061: LD_INT 1
15063: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15064: LD_INT 1
15066: PPUSH
15067: LD_INT 1
15069: PPUSH
15070: LD_EXP 39
15074: PPUSH
15075: CALL_OW 380
// al_commander := CreateHuman ;
15079: LD_ADDR_EXP 37
15083: PUSH
15084: CALL_OW 44
15088: ST_TO_ADDR
// player_commander := al_commander ;
15089: LD_ADDR_EXP 10
15093: PUSH
15094: LD_EXP 37
15098: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15099: LD_ADDR_VAR 0 5
15103: PUSH
15104: LD_STRING text
15106: PPUSH
15107: LD_INT 9
15109: PUSH
15110: LD_INT 9
15112: PUSH
15113: LD_INT 8
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: LIST
15120: PUSH
15121: LD_OWVAR 67
15125: ARRAY
15126: PPUSH
15127: LD_INT 9
15129: PUSH
15130: LD_INT 9
15132: PUSH
15133: LD_INT 8
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: LIST
15140: PUSH
15141: LD_OWVAR 67
15145: ARRAY
15146: PPUSH
15147: LD_INT -5
15149: PUSH
15150: LD_EXP 37
15154: PUSH
15155: LD_INT -3
15157: PUSH
15158: LD_INT -2
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: PUSH
15167: LD_EXP 38
15171: ADD
15172: PPUSH
15173: LD_INT 1
15175: PUSH
15176: LD_INT 3
15178: PUSH
15179: LD_INT 2
15181: PUSH
15182: LD_INT 1
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: PUSH
15189: LD_INT 4
15191: PUSH
15192: LD_INT 1
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: PUSH
15199: LD_INT 9
15201: PUSH
15202: LD_INT 5
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: PPUSH
15213: CALL_OW 42
15217: ST_TO_ADDR
// team := team ^ al_commander ;
15218: LD_ADDR_VAR 0 5
15222: PUSH
15223: LD_VAR 0 5
15227: PUSH
15228: LD_EXP 37
15232: ADD
15233: ST_TO_ADDR
// for i = 1 to team do
15234: LD_ADDR_VAR 0 2
15238: PUSH
15239: DOUBLE
15240: LD_INT 1
15242: DEC
15243: ST_TO_ADDR
15244: LD_VAR 0 5
15248: PUSH
15249: FOR_TO
15250: IFFALSE 15275
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15252: LD_VAR 0 5
15256: PUSH
15257: LD_VAR 0 2
15261: ARRAY
15262: PPUSH
15263: LD_INT 15
15265: PPUSH
15266: LD_INT 0
15268: PPUSH
15269: CALL_OW 49
15273: GO 15249
15275: POP
15276: POP
// end ;
15277: LD_VAR 0 1
15281: RET
// export function RemoveAlliance ; var i ; begin
15282: LD_INT 0
15284: PPUSH
15285: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15286: LD_INT 22
15288: PUSH
15289: LD_INT 7
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 30
15298: PUSH
15299: LD_INT 1
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PPUSH
15310: CALL_OW 69
15314: PUSH
15315: LD_INT 1
15317: ARRAY
15318: PPUSH
15319: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15323: LD_ADDR_VAR 0 2
15327: PUSH
15328: LD_INT 22
15330: PUSH
15331: LD_INT 7
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PPUSH
15338: CALL_OW 69
15342: PUSH
15343: FOR_IN
15344: IFFALSE 15357
// RemoveUnit ( i ) ;
15346: LD_VAR 0 2
15350: PPUSH
15351: CALL_OW 64
15355: GO 15343
15357: POP
15358: POP
// end ;
15359: LD_VAR 0 1
15363: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15364: LD_INT 0
15366: PPUSH
15367: PPUSH
15368: PPUSH
15369: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15370: LD_INT 31
15372: PPUSH
15373: LD_INT 7
15375: PPUSH
15376: LD_INT 2
15378: PPUSH
15379: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15383: LD_INT 32
15385: PPUSH
15386: LD_INT 7
15388: PPUSH
15389: LD_INT 2
15391: PPUSH
15392: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15396: LD_INT 59
15398: PPUSH
15399: LD_INT 7
15401: PPUSH
15402: LD_INT 2
15404: PPUSH
15405: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15409: LD_ADDR_EXP 39
15413: PUSH
15414: LD_INT 5
15416: PUSH
15417: LD_INT 6
15419: PUSH
15420: LD_INT 7
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: LIST
15427: PUSH
15428: LD_OWVAR 67
15432: ARRAY
15433: ST_TO_ADDR
// al_force := [ ] ;
15434: LD_ADDR_EXP 38
15438: PUSH
15439: EMPTY
15440: ST_TO_ADDR
// al_vehs := [ ] ;
15441: LD_ADDR_EXP 44
15445: PUSH
15446: EMPTY
15447: ST_TO_ADDR
// uc_side := 7 ;
15448: LD_ADDR_OWVAR 20
15452: PUSH
15453: LD_INT 7
15455: ST_TO_ADDR
// uc_nation := 1 ;
15456: LD_ADDR_OWVAR 21
15460: PUSH
15461: LD_INT 1
15463: ST_TO_ADDR
// bc_type := b_oil_mine ;
15464: LD_ADDR_OWVAR 42
15468: PUSH
15469: LD_INT 29
15471: ST_TO_ADDR
// b := CreateBuilding ;
15472: LD_ADDR_VAR 0 4
15476: PUSH
15477: CALL_OW 46
15481: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15482: LD_VAR 0 4
15486: PPUSH
15487: LD_INT 61
15489: PPUSH
15490: LD_INT 7
15492: PPUSH
15493: LD_INT 0
15495: PPUSH
15496: LD_INT 0
15498: PPUSH
15499: CALL_OW 50
// bc_type := b_siberite_mine ;
15503: LD_ADDR_OWVAR 42
15507: PUSH
15508: LD_INT 30
15510: ST_TO_ADDR
// b := CreateBuilding ;
15511: LD_ADDR_VAR 0 4
15515: PUSH
15516: CALL_OW 46
15520: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15521: LD_VAR 0 4
15525: PPUSH
15526: LD_INT 69
15528: PPUSH
15529: LD_INT 13
15531: PPUSH
15532: LD_INT 0
15534: PPUSH
15535: LD_INT 0
15537: PPUSH
15538: CALL_OW 50
// hc_gallery :=  ;
15542: LD_ADDR_OWVAR 33
15546: PUSH
15547: LD_STRING 
15549: ST_TO_ADDR
// hc_name :=  ;
15550: LD_ADDR_OWVAR 26
15554: PUSH
15555: LD_STRING 
15557: ST_TO_ADDR
// hc_importance := 0 ;
15558: LD_ADDR_OWVAR 32
15562: PUSH
15563: LD_INT 0
15565: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15566: LD_ADDR_VAR 0 2
15570: PUSH
15571: LD_INT 22
15573: PUSH
15574: LD_INT 7
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 30
15583: PUSH
15584: LD_INT 32
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PPUSH
15595: CALL_OW 69
15599: PUSH
15600: FOR_IN
15601: IFFALSE 15671
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15603: LD_ADDR_OWVAR 21
15607: PUSH
15608: LD_INT 1
15610: PUSH
15611: LD_INT 3
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: LD_INT 1
15620: PPUSH
15621: LD_INT 2
15623: PPUSH
15624: CALL_OW 12
15628: ARRAY
15629: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15630: LD_INT 0
15632: PPUSH
15633: LD_INT 1
15635: PPUSH
15636: LD_EXP 39
15640: PPUSH
15641: CALL_OW 380
// un := CreateHuman ;
15645: LD_ADDR_VAR 0 3
15649: PUSH
15650: CALL_OW 44
15654: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15655: LD_VAR 0 3
15659: PPUSH
15660: LD_VAR 0 2
15664: PPUSH
15665: CALL_OW 52
// end ;
15669: GO 15600
15671: POP
15672: POP
// for i = 1 to 3 do
15673: LD_ADDR_VAR 0 2
15677: PUSH
15678: DOUBLE
15679: LD_INT 1
15681: DEC
15682: ST_TO_ADDR
15683: LD_INT 3
15685: PUSH
15686: FOR_TO
15687: IFFALSE 15755
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15689: LD_ADDR_OWVAR 21
15693: PUSH
15694: LD_INT 1
15696: PUSH
15697: LD_INT 3
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 1
15706: PPUSH
15707: LD_INT 2
15709: PPUSH
15710: CALL_OW 12
15714: ARRAY
15715: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15716: LD_INT 0
15718: PPUSH
15719: LD_INT 4
15721: PPUSH
15722: LD_EXP 39
15726: PPUSH
15727: CALL_OW 380
// un := CreateHuman ;
15731: LD_ADDR_VAR 0 3
15735: PUSH
15736: CALL_OW 44
15740: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15741: LD_VAR 0 3
15745: PPUSH
15746: LD_INT 164
15748: PPUSH
15749: CALL_OW 52
// end ;
15753: GO 15686
15755: POP
15756: POP
// for i = 1 to 6 do
15757: LD_ADDR_VAR 0 2
15761: PUSH
15762: DOUBLE
15763: LD_INT 1
15765: DEC
15766: ST_TO_ADDR
15767: LD_INT 6
15769: PUSH
15770: FOR_TO
15771: IFFALSE 15862
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15773: LD_ADDR_OWVAR 21
15777: PUSH
15778: LD_INT 1
15780: PUSH
15781: LD_INT 3
15783: PUSH
15784: EMPTY
15785: LIST
15786: LIST
15787: PUSH
15788: LD_INT 1
15790: PPUSH
15791: LD_INT 2
15793: PPUSH
15794: CALL_OW 12
15798: ARRAY
15799: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15800: LD_INT 0
15802: PPUSH
15803: LD_INT 5
15805: PUSH
15806: LD_INT 9
15808: PUSH
15809: LD_INT 9
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 3
15822: PPUSH
15823: CALL_OW 12
15827: ARRAY
15828: PPUSH
15829: LD_EXP 39
15833: PPUSH
15834: CALL_OW 380
// un := CreateHuman ;
15838: LD_ADDR_VAR 0 3
15842: PUSH
15843: CALL_OW 44
15847: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15848: LD_VAR 0 3
15852: PPUSH
15853: LD_INT 173
15855: PPUSH
15856: CALL_OW 52
// end ;
15860: GO 15770
15862: POP
15863: POP
// for i = 1 to 6 do
15864: LD_ADDR_VAR 0 2
15868: PUSH
15869: DOUBLE
15870: LD_INT 1
15872: DEC
15873: ST_TO_ADDR
15874: LD_INT 6
15876: PUSH
15877: FOR_TO
15878: IFFALSE 15976
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15880: LD_ADDR_OWVAR 21
15884: PUSH
15885: LD_INT 1
15887: PUSH
15888: LD_INT 3
15890: PUSH
15891: EMPTY
15892: LIST
15893: LIST
15894: PUSH
15895: LD_INT 1
15897: PPUSH
15898: LD_INT 2
15900: PPUSH
15901: CALL_OW 12
15905: ARRAY
15906: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15907: LD_INT 0
15909: PPUSH
15910: LD_INT 3
15912: PPUSH
15913: LD_EXP 39
15917: PPUSH
15918: CALL_OW 380
// un := CreateHuman ;
15922: LD_ADDR_VAR 0 3
15926: PUSH
15927: CALL_OW 44
15931: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15932: LD_VAR 0 3
15936: PPUSH
15937: LD_INT 22
15939: PUSH
15940: LD_INT 7
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: LD_INT 30
15949: PUSH
15950: LD_INT 3
15952: PUSH
15953: EMPTY
15954: LIST
15955: LIST
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PPUSH
15961: CALL_OW 69
15965: PUSH
15966: LD_INT 1
15968: ARRAY
15969: PPUSH
15970: CALL_OW 52
// end ;
15974: GO 15877
15976: POP
15977: POP
// for i = 1 to 4 do
15978: LD_ADDR_VAR 0 2
15982: PUSH
15983: DOUBLE
15984: LD_INT 1
15986: DEC
15987: ST_TO_ADDR
15988: LD_INT 4
15990: PUSH
15991: FOR_TO
15992: IFFALSE 16060
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15994: LD_ADDR_OWVAR 21
15998: PUSH
15999: LD_INT 1
16001: PUSH
16002: LD_INT 3
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: PUSH
16009: LD_INT 1
16011: PPUSH
16012: LD_INT 2
16014: PPUSH
16015: CALL_OW 12
16019: ARRAY
16020: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16021: LD_INT 0
16023: PPUSH
16024: LD_INT 2
16026: PPUSH
16027: LD_EXP 39
16031: PPUSH
16032: CALL_OW 380
// un := CreateHuman ;
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: CALL_OW 44
16045: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16046: LD_VAR 0 3
16050: PPUSH
16051: LD_INT 162
16053: PPUSH
16054: CALL_OW 52
// end ;
16058: GO 15991
16060: POP
16061: POP
// uc_nation := 3 ;
16062: LD_ADDR_OWVAR 21
16066: PUSH
16067: LD_INT 3
16069: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16070: LD_ADDR_OWVAR 37
16074: PUSH
16075: LD_INT 21
16077: ST_TO_ADDR
// vc_engine := engine_siberite ;
16078: LD_ADDR_OWVAR 39
16082: PUSH
16083: LD_INT 3
16085: ST_TO_ADDR
// vc_control := control_computer ;
16086: LD_ADDR_OWVAR 38
16090: PUSH
16091: LD_INT 3
16093: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16094: LD_ADDR_OWVAR 40
16098: PUSH
16099: LD_INT 51
16101: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16102: CALL_OW 45
16106: PPUSH
16107: LD_INT 49
16109: PPUSH
16110: LD_INT 13
16112: PPUSH
16113: LD_INT 0
16115: PPUSH
16116: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16120: LD_ADDR_EXP 46
16124: PUSH
16125: LD_INT 22
16127: PUSH
16128: LD_INT 7
16130: PUSH
16131: EMPTY
16132: LIST
16133: LIST
16134: PUSH
16135: LD_INT 30
16137: PUSH
16138: LD_INT 33
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PPUSH
16149: CALL_OW 69
16153: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16154: LD_ADDR_VAR 0 2
16158: PUSH
16159: DOUBLE
16160: LD_INT 1
16162: DEC
16163: ST_TO_ADDR
16164: LD_INT 22
16166: PUSH
16167: LD_INT 7
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: PUSH
16174: LD_INT 30
16176: PUSH
16177: LD_INT 33
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: PUSH
16184: LD_INT 35
16186: PUSH
16187: LD_INT 0
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: LIST
16198: PUSH
16199: EMPTY
16200: LIST
16201: PPUSH
16202: CALL_OW 69
16206: PUSH
16207: FOR_TO
16208: IFFALSE 16268
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16210: LD_INT 22
16212: PUSH
16213: LD_INT 7
16215: PUSH
16216: EMPTY
16217: LIST
16218: LIST
16219: PUSH
16220: LD_INT 30
16222: PUSH
16223: LD_INT 33
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 35
16232: PUSH
16233: LD_INT 0
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: LIST
16244: PUSH
16245: EMPTY
16246: LIST
16247: PPUSH
16248: CALL_OW 69
16252: PUSH
16253: LD_VAR 0 2
16257: ARRAY
16258: PPUSH
16259: LD_INT 49
16261: PPUSH
16262: CALL_OW 208
16266: GO 16207
16268: POP
16269: POP
// end ;
16270: LD_VAR 0 1
16274: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16275: LD_OWVAR 2
16279: PUSH
16280: LD_INT 1
16282: EQUAL
16283: IFFALSE 17451
16285: GO 16287
16287: DISABLE
16288: LD_INT 0
16290: PPUSH
16291: PPUSH
16292: PPUSH
16293: PPUSH
// begin enable ;
16294: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16295: LD_ADDR_EXP 50
16299: PUSH
16300: LD_INT 22
16302: PUSH
16303: LD_INT 7
16305: PUSH
16306: EMPTY
16307: LIST
16308: LIST
16309: PUSH
16310: LD_INT 21
16312: PUSH
16313: LD_INT 3
16315: PUSH
16316: EMPTY
16317: LIST
16318: LIST
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PPUSH
16324: CALL_OW 69
16328: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16329: LD_ADDR_EXP 48
16333: PUSH
16334: LD_INT 164
16336: PUSH
16337: LD_INT 197
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16344: LD_ADDR_EXP 47
16348: PUSH
16349: LD_INT 22
16351: PUSH
16352: LD_INT 7
16354: PUSH
16355: EMPTY
16356: LIST
16357: LIST
16358: PUSH
16359: LD_INT 30
16361: PUSH
16362: LD_INT 1
16364: PUSH
16365: EMPTY
16366: LIST
16367: LIST
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PPUSH
16373: CALL_OW 69
16377: PUSH
16378: LD_INT 1
16380: ARRAY
16381: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16382: LD_ADDR_EXP 49
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_INT 7
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 30
16399: PUSH
16400: LD_INT 3
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PPUSH
16411: CALL_OW 69
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16420: LD_INT 22
16422: PUSH
16423: LD_INT 7
16425: PUSH
16426: EMPTY
16427: LIST
16428: LIST
16429: PUSH
16430: LD_INT 34
16432: PUSH
16433: LD_INT 51
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PPUSH
16444: CALL_OW 69
16448: IFFALSE 16488
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16450: LD_ADDR_EXP 45
16454: PUSH
16455: LD_INT 22
16457: PUSH
16458: LD_INT 7
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: PUSH
16465: LD_INT 34
16467: PUSH
16468: LD_INT 51
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: PUSH
16475: EMPTY
16476: LIST
16477: LIST
16478: PPUSH
16479: CALL_OW 69
16483: PUSH
16484: LD_INT 1
16486: ARRAY
16487: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16488: LD_ADDR_EXP 41
16492: PUSH
16493: LD_INT 22
16495: PUSH
16496: LD_INT 7
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 25
16505: PUSH
16506: LD_INT 9
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PPUSH
16517: CALL_OW 69
16521: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16522: LD_ADDR_EXP 40
16526: PUSH
16527: LD_INT 22
16529: PUSH
16530: LD_INT 7
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PUSH
16537: LD_INT 25
16539: PUSH
16540: LD_INT 2
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PPUSH
16551: CALL_OW 69
16555: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16556: LD_ADDR_EXP 42
16560: PUSH
16561: LD_INT 22
16563: PUSH
16564: LD_INT 7
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 25
16573: PUSH
16574: LD_INT 3
16576: PUSH
16577: EMPTY
16578: LIST
16579: LIST
16580: PUSH
16581: EMPTY
16582: LIST
16583: LIST
16584: PPUSH
16585: CALL_OW 69
16589: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16590: LD_ADDR_EXP 43
16594: PUSH
16595: LD_INT 22
16597: PUSH
16598: LD_INT 7
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: LD_INT 25
16607: PUSH
16608: LD_INT 4
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PPUSH
16619: CALL_OW 69
16623: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16624: LD_EXP 41
16628: PPUSH
16629: LD_INT 81
16631: PUSH
16632: LD_INT 7
16634: PUSH
16635: EMPTY
16636: LIST
16637: LIST
16638: PPUSH
16639: CALL_OW 69
16643: PPUSH
16644: CALL 1656 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16648: LD_EXP 45
16652: PPUSH
16653: CALL_OW 314
16657: NOT
16658: PUSH
16659: LD_EXP 45
16663: PPUSH
16664: LD_INT 1
16666: PPUSH
16667: CALL_OW 289
16671: PUSH
16672: LD_INT 100
16674: LESS
16675: AND
16676: IFFALSE 16724
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16678: LD_ADDR_VAR 0 4
16682: PUSH
16683: LD_INT 12
16685: PPUSH
16686: CALL_OW 435
16690: ST_TO_ADDR
// if cr then
16691: LD_VAR 0 4
16695: IFFALSE 16724
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16697: LD_EXP 45
16701: PPUSH
16702: LD_VAR 0 4
16706: PUSH
16707: LD_INT 1
16709: ARRAY
16710: PPUSH
16711: LD_VAR 0 4
16715: PUSH
16716: LD_INT 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16724: LD_EXP 50
16728: PPUSH
16729: LD_INT 3
16731: PUSH
16732: LD_INT 24
16734: PUSH
16735: LD_INT 1000
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PPUSH
16746: CALL_OW 72
16750: IFFALSE 16880
// begin if al_eng then
16752: LD_EXP 40
16756: IFFALSE 16878
// for i = 1 to al_eng do
16758: LD_ADDR_VAR 0 1
16762: PUSH
16763: DOUBLE
16764: LD_INT 1
16766: DEC
16767: ST_TO_ADDR
16768: LD_EXP 40
16772: PUSH
16773: FOR_TO
16774: IFFALSE 16876
// if IsInUnit ( al_eng [ i ] ) then
16776: LD_EXP 40
16780: PUSH
16781: LD_VAR 0 1
16785: ARRAY
16786: PPUSH
16787: CALL_OW 310
16791: IFFALSE 16810
// ComExitBuilding ( al_eng [ i ] ) else
16793: LD_EXP 40
16797: PUSH
16798: LD_VAR 0 1
16802: ARRAY
16803: PPUSH
16804: CALL_OW 122
16808: GO 16874
// if not HasTask ( al_eng [ i ] ) then
16810: LD_EXP 40
16814: PUSH
16815: LD_VAR 0 1
16819: ARRAY
16820: PPUSH
16821: CALL_OW 314
16825: NOT
16826: IFFALSE 16874
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16828: LD_EXP 40
16832: PUSH
16833: LD_VAR 0 1
16837: ARRAY
16838: PPUSH
16839: LD_EXP 50
16843: PPUSH
16844: LD_INT 3
16846: PUSH
16847: LD_INT 24
16849: PUSH
16850: LD_INT 1000
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: PPUSH
16861: CALL_OW 72
16865: PUSH
16866: LD_INT 1
16868: ARRAY
16869: PPUSH
16870: CALL_OW 130
16874: GO 16773
16876: POP
16877: POP
// end else
16878: GO 16962
// if al_eng then
16880: LD_EXP 40
16884: IFFALSE 16962
// if not IsInUnit ( al_eng [ 1 ] ) then
16886: LD_EXP 40
16890: PUSH
16891: LD_INT 1
16893: ARRAY
16894: PPUSH
16895: CALL_OW 310
16899: NOT
16900: IFFALSE 16962
// for i = 1 to al_eng do
16902: LD_ADDR_VAR 0 1
16906: PUSH
16907: DOUBLE
16908: LD_INT 1
16910: DEC
16911: ST_TO_ADDR
16912: LD_EXP 40
16916: PUSH
16917: FOR_TO
16918: IFFALSE 16960
// if not IsInUnit ( al_eng [ i ] ) then
16920: LD_EXP 40
16924: PUSH
16925: LD_VAR 0 1
16929: ARRAY
16930: PPUSH
16931: CALL_OW 310
16935: NOT
16936: IFFALSE 16958
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16938: LD_EXP 40
16942: PUSH
16943: LD_VAR 0 1
16947: ARRAY
16948: PPUSH
16949: LD_EXP 47
16953: PPUSH
16954: CALL_OW 120
16958: GO 16917
16960: POP
16961: POP
// if al_vehs then
16962: LD_EXP 44
16966: IFFALSE 17066
// if BuildingStatus ( al_fac ) = bs_idle then
16968: LD_EXP 49
16972: PPUSH
16973: CALL_OW 461
16977: PUSH
16978: LD_INT 2
16980: EQUAL
16981: IFFALSE 17066
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16983: LD_EXP 49
16987: PPUSH
16988: LD_EXP 44
16992: PUSH
16993: LD_INT 1
16995: ARRAY
16996: PPUSH
16997: LD_EXP 44
17001: PUSH
17002: LD_INT 2
17004: ARRAY
17005: PPUSH
17006: LD_EXP 44
17010: PUSH
17011: LD_INT 3
17013: ARRAY
17014: PPUSH
17015: LD_EXP 44
17019: PUSH
17020: LD_INT 4
17022: ARRAY
17023: PPUSH
17024: CALL_OW 125
// for i = 1 to 4 do
17028: LD_ADDR_VAR 0 1
17032: PUSH
17033: DOUBLE
17034: LD_INT 1
17036: DEC
17037: ST_TO_ADDR
17038: LD_INT 4
17040: PUSH
17041: FOR_TO
17042: IFFALSE 17064
// al_vehs := Delete ( al_vehs , 1 ) ;
17044: LD_ADDR_EXP 44
17048: PUSH
17049: LD_EXP 44
17053: PPUSH
17054: LD_INT 1
17056: PPUSH
17057: CALL_OW 3
17061: ST_TO_ADDR
17062: GO 17041
17064: POP
17065: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17066: LD_EXP 38
17070: PUSH
17071: LD_INT 0
17073: EQUAL
17074: PUSH
17075: LD_OWVAR 1
17079: PUSH
17080: LD_INT 23100
17082: MOD
17083: PUSH
17084: LD_INT 0
17086: EQUAL
17087: AND
17088: IFFALSE 17202
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17090: LD_ADDR_VAR 0 1
17094: PUSH
17095: DOUBLE
17096: LD_INT 1
17098: DEC
17099: ST_TO_ADDR
17100: LD_INT 4
17102: PUSH
17103: LD_INT 5
17105: PUSH
17106: LD_INT 6
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: LIST
17113: PUSH
17114: LD_OWVAR 67
17118: ARRAY
17119: PUSH
17120: FOR_TO
17121: IFFALSE 17200
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17123: LD_ADDR_EXP 44
17127: PUSH
17128: LD_EXP 44
17132: PUSH
17133: LD_INT 23
17135: ADD
17136: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17137: LD_ADDR_EXP 44
17141: PUSH
17142: LD_EXP 44
17146: PUSH
17147: LD_INT 1
17149: ADD
17150: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17151: LD_ADDR_EXP 44
17155: PUSH
17156: LD_EXP 44
17160: PUSH
17161: LD_INT 3
17163: ADD
17164: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17165: LD_ADDR_EXP 44
17169: PUSH
17170: LD_EXP 44
17174: PUSH
17175: LD_INT 46
17177: PUSH
17178: LD_INT 47
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 1
17187: PPUSH
17188: LD_INT 2
17190: PPUSH
17191: CALL_OW 12
17195: ARRAY
17196: ADD
17197: ST_TO_ADDR
// end ;
17198: GO 17120
17200: POP
17201: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17202: LD_INT 22
17204: PUSH
17205: LD_INT 7
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PUSH
17212: LD_INT 34
17214: PUSH
17215: LD_INT 51
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PPUSH
17226: CALL_OW 69
17230: PUSH
17231: LD_INT 0
17233: EQUAL
17234: IFFALSE 17257
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17236: LD_EXP 49
17240: PPUSH
17241: LD_INT 21
17243: PPUSH
17244: LD_INT 1
17246: PPUSH
17247: LD_INT 3
17249: PPUSH
17250: LD_INT 51
17252: PPUSH
17253: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17257: LD_EXP 38
17261: PUSH
17262: LD_OWVAR 1
17266: PUSH
17267: LD_INT 25200
17269: MOD
17270: PUSH
17271: LD_INT 0
17273: EQUAL
17274: AND
17275: IFFALSE 17338
// begin for i = 1 to al_force do
17277: LD_ADDR_VAR 0 1
17281: PUSH
17282: DOUBLE
17283: LD_INT 1
17285: DEC
17286: ST_TO_ADDR
17287: LD_EXP 38
17291: PUSH
17292: FOR_TO
17293: IFFALSE 17336
// if GetTag ( al_force [ i ] ) <> 11 then
17295: LD_EXP 38
17299: PUSH
17300: LD_VAR 0 1
17304: ARRAY
17305: PPUSH
17306: CALL_OW 110
17310: PUSH
17311: LD_INT 11
17313: NONEQUAL
17314: IFFALSE 17334
// SetTag ( al_force [ i ] , 11 ) ;
17316: LD_EXP 38
17320: PUSH
17321: LD_VAR 0 1
17325: ARRAY
17326: PPUSH
17327: LD_INT 11
17329: PPUSH
17330: CALL_OW 109
17334: GO 17292
17336: POP
17337: POP
// end ; if al_force then
17338: LD_EXP 38
17342: IFFALSE 17451
// for i = 1 to al_force do
17344: LD_ADDR_VAR 0 1
17348: PUSH
17349: DOUBLE
17350: LD_INT 1
17352: DEC
17353: ST_TO_ADDR
17354: LD_EXP 38
17358: PUSH
17359: FOR_TO
17360: IFFALSE 17449
// begin if GetTag ( al_force [ i ] ) = 11 then
17362: LD_EXP 38
17366: PUSH
17367: LD_VAR 0 1
17371: ARRAY
17372: PPUSH
17373: CALL_OW 110
17377: PUSH
17378: LD_INT 11
17380: EQUAL
17381: IFFALSE 17447
// begin if not HasTask ( al_force [ i ] ) then
17383: LD_EXP 38
17387: PUSH
17388: LD_VAR 0 1
17392: ARRAY
17393: PPUSH
17394: CALL_OW 314
17398: NOT
17399: IFFALSE 17447
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17401: LD_EXP 38
17405: PUSH
17406: LD_VAR 0 1
17410: ARRAY
17411: PPUSH
17412: LD_INT 81
17414: PUSH
17415: LD_INT 7
17417: PUSH
17418: EMPTY
17419: LIST
17420: LIST
17421: PPUSH
17422: CALL_OW 69
17426: PPUSH
17427: LD_EXP 38
17431: PUSH
17432: LD_VAR 0 1
17436: ARRAY
17437: PPUSH
17438: CALL_OW 74
17442: PPUSH
17443: CALL_OW 115
// end ; end ;
17447: GO 17359
17449: POP
17450: POP
// end ; end_of_file
17451: PPOPN 4
17453: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
17459: PPUSH
17460: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17461: LD_ADDR_EXP 53
17465: PUSH
17466: LD_INT 7
17468: PUSH
17469: LD_INT 6
17471: PUSH
17472: LD_INT 5
17474: PUSH
17475: EMPTY
17476: LIST
17477: LIST
17478: LIST
17479: PUSH
17480: LD_OWVAR 67
17484: ARRAY
17485: ST_TO_ADDR
// ar_force := [ ] ;
17486: LD_ADDR_EXP 52
17490: PUSH
17491: EMPTY
17492: ST_TO_ADDR
// RemoveAlliance ;
17493: CALL 15282 0 0
// RemoveEnvironmentArea ( evn ) ;
17497: LD_INT 17
17499: PPUSH
17500: CALL_OW 355
// your_side := 2 ;
17504: LD_ADDR_OWVAR 2
17508: PUSH
17509: LD_INT 2
17511: ST_TO_ADDR
// uc_side := 2 ;
17512: LD_ADDR_OWVAR 20
17516: PUSH
17517: LD_INT 2
17519: ST_TO_ADDR
// uc_nation := nation_arabian ;
17520: LD_ADDR_OWVAR 21
17524: PUSH
17525: LD_INT 2
17527: ST_TO_ADDR
// hc_gallery :=  ;
17528: LD_ADDR_OWVAR 33
17532: PUSH
17533: LD_STRING 
17535: ST_TO_ADDR
// hc_name :=  ;
17536: LD_ADDR_OWVAR 26
17540: PUSH
17541: LD_STRING 
17543: ST_TO_ADDR
// hc_importance := 0 ;
17544: LD_ADDR_OWVAR 32
17548: PUSH
17549: LD_INT 0
17551: ST_TO_ADDR
// for i = 1 to 15 do
17552: LD_ADDR_VAR 0 2
17556: PUSH
17557: DOUBLE
17558: LD_INT 1
17560: DEC
17561: ST_TO_ADDR
17562: LD_INT 15
17564: PUSH
17565: FOR_TO
17566: IFFALSE 17619
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17568: LD_INT 0
17570: PPUSH
17571: LD_INT 1
17573: PPUSH
17574: LD_INT 4
17576: PPUSH
17577: CALL_OW 12
17581: PPUSH
17582: LD_EXP 53
17586: PPUSH
17587: CALL_OW 380
// un := CreateHuman ;
17591: LD_ADDR_VAR 0 4
17595: PUSH
17596: CALL_OW 44
17600: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17601: LD_ADDR_EXP 52
17605: PUSH
17606: LD_EXP 52
17610: PUSH
17611: LD_VAR 0 4
17615: ADD
17616: ST_TO_ADDR
// end ;
17617: GO 17565
17619: POP
17620: POP
// hc_importance := 100 ;
17621: LD_ADDR_OWVAR 32
17625: PUSH
17626: LD_INT 100
17628: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17629: LD_INT 1
17631: PPUSH
17632: LD_INT 11
17634: PPUSH
17635: LD_EXP 53
17639: PPUSH
17640: CALL_OW 380
// ar_commander := CreateHuman ;
17644: LD_ADDR_EXP 51
17648: PUSH
17649: CALL_OW 44
17653: ST_TO_ADDR
// player_commander := ar_commander ;
17654: LD_ADDR_EXP 10
17658: PUSH
17659: LD_EXP 51
17663: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17664: LD_ADDR_VAR 0 5
17668: PUSH
17669: LD_STRING text
17671: PPUSH
17672: LD_INT 11
17674: PUSH
17675: LD_INT 10
17677: PUSH
17678: LD_INT 9
17680: PUSH
17681: EMPTY
17682: LIST
17683: LIST
17684: LIST
17685: PUSH
17686: LD_OWVAR 67
17690: ARRAY
17691: PPUSH
17692: LD_INT 11
17694: PUSH
17695: LD_INT 10
17697: PUSH
17698: LD_INT 9
17700: PUSH
17701: EMPTY
17702: LIST
17703: LIST
17704: LIST
17705: PUSH
17706: LD_OWVAR 67
17710: ARRAY
17711: PPUSH
17712: LD_INT -5
17714: PUSH
17715: LD_EXP 51
17719: PUSH
17720: LD_INT -3
17722: PUSH
17723: LD_INT -2
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: LIST
17730: LIST
17731: PUSH
17732: LD_EXP 52
17736: ADD
17737: PPUSH
17738: LD_INT 1
17740: PUSH
17741: LD_INT 3
17743: PUSH
17744: LD_INT 2
17746: PUSH
17747: LD_INT 1
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: PUSH
17754: LD_INT 4
17756: PUSH
17757: LD_INT 1
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: PUSH
17764: LD_INT 8
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 42
17778: ST_TO_ADDR
// team := team ^ ar_commander ;
17779: LD_ADDR_VAR 0 5
17783: PUSH
17784: LD_VAR 0 5
17788: PUSH
17789: LD_EXP 51
17793: ADD
17794: ST_TO_ADDR
// for i = 1 to team do
17795: LD_ADDR_VAR 0 2
17799: PUSH
17800: DOUBLE
17801: LD_INT 1
17803: DEC
17804: ST_TO_ADDR
17805: LD_VAR 0 5
17809: PUSH
17810: FOR_TO
17811: IFFALSE 17836
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17813: LD_VAR 0 5
17817: PUSH
17818: LD_VAR 0 2
17822: ARRAY
17823: PPUSH
17824: LD_INT 16
17826: PPUSH
17827: LD_INT 0
17829: PPUSH
17830: CALL_OW 49
17834: GO 17810
17836: POP
17837: POP
// uc_side := 0 ;
17838: LD_ADDR_OWVAR 20
17842: PUSH
17843: LD_INT 0
17845: ST_TO_ADDR
// uc_nation := 0 ;
17846: LD_ADDR_OWVAR 21
17850: PUSH
17851: LD_INT 0
17853: ST_TO_ADDR
// vc_chassis := 31 ;
17854: LD_ADDR_OWVAR 37
17858: PUSH
17859: LD_INT 31
17861: ST_TO_ADDR
// vc_control := control_rider ;
17862: LD_ADDR_OWVAR 38
17866: PUSH
17867: LD_INT 4
17869: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17870: CALL_OW 45
17874: PPUSH
17875: LD_INT 96
17877: PPUSH
17878: LD_INT 20
17880: PPUSH
17881: LD_INT 0
17883: PPUSH
17884: CALL_OW 48
// end ;
17888: LD_VAR 0 1
17892: RET
