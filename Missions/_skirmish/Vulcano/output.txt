// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareTrigger ;
   8: CALL 33 0 0
// PrepareVulcanoBase ;
  12: CALL 873 0 0
// PrepareRussian ;
  16: CALL 3482 0 0
// PrepareLegion ;
  20: CALL 7013 0 0
// Action ;
  24: CALL 10692 0 0
// InitArt ;
  28: CALL 194 0 0
// end ;
  32: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  33: LD_INT 0
  35: PPUSH
// base_captured := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// russian_prepared := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// ru_can_attack := false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// ru_sib_bomb := false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 5
  75: PUSH
  76: LD_INT 10
  78: PUSH
  79: LD_INT 25
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: ST_TO_ADDR
// player_res_art := false ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// player_artifact_ready := false ;
 101: LD_ADDR_EXP 7
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// art_icon := art_use_atom ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 7
 116: ST_TO_ADDR
// time_res_art := 600 ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 600
 124: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 21000
 132: ST_TO_ADDR
// mine_vulc := false ;
 133: LD_ADDR_EXP 12
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// medal_enabled := false ;
 141: LD_ADDR_EXP 13
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// dead_counter := 0 ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// kill_counter := 0 ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// veh_counter := 0 ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// tech_counter := 0 ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// end ;
 189: LD_VAR 0 1
 193: RET
// function InitArt ; begin
 194: LD_INT 0
 196: PPUSH
// SetArtifactRes ( your_side , true ) ;
 197: LD_OWVAR 2
 201: PPUSH
 202: LD_INT 1
 204: PPUSH
 205: CALL_OW 467
// end ; end_of_file
 209: LD_VAR 0 1
 213: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 214: LD_INT 0
 216: PPUSH
 217: PPUSH
 218: PPUSH
 219: PPUSH
 220: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 7
 228: PUSH
 229: LD_INT 6
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: PUSH
 240: LD_OWVAR 67
 244: ARRAY
 245: ST_TO_ADDR
// us_force := [ ] ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 253: LD_INT 17
 255: PPUSH
 256: CALL_OW 355
// PrepareAllianceAI ( ) ;
 260: CALL 15371 0 0
// uc_side := 1 ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// uc_nation := nation_american ;
 272: LD_ADDR_OWVAR 21
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// hc_gallery :=  ;
 280: LD_ADDR_OWVAR 33
 284: PUSH
 285: LD_STRING 
 287: ST_TO_ADDR
// hc_name :=  ;
 288: LD_ADDR_OWVAR 26
 292: PUSH
 293: LD_STRING 
 295: ST_TO_ADDR
// hc_importance := 0 ;
 296: LD_ADDR_OWVAR 32
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// for i = 1 to 11 do
 304: LD_ADDR_VAR 0 2
 308: PUSH
 309: DOUBLE
 310: LD_INT 1
 312: DEC
 313: ST_TO_ADDR
 314: LD_INT 11
 316: PUSH
 317: FOR_TO
 318: IFFALSE 371
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 320: LD_INT 0
 322: PPUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 4
 328: PPUSH
 329: CALL_OW 12
 333: PPUSH
 334: LD_EXP 21
 338: PPUSH
 339: CALL_OW 380
// un := CreateHuman ;
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: CALL_OW 44
 352: ST_TO_ADDR
// us_force := us_force ^ un ;
 353: LD_ADDR_EXP 20
 357: PUSH
 358: LD_EXP 20
 362: PUSH
 363: LD_VAR 0 4
 367: ADD
 368: ST_TO_ADDR
// end ;
 369: GO 317
 371: POP
 372: POP
// hc_importance := 100 ;
 373: LD_ADDR_OWVAR 32
 377: PUSH
 378: LD_INT 100
 380: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: LD_EXP 21
 391: PPUSH
 392: CALL_OW 380
// us_commander := CreateHuman ;
 396: LD_ADDR_EXP 19
 400: PUSH
 401: CALL_OW 44
 405: ST_TO_ADDR
// player_commander := us_commander ;
 406: LD_ADDR_EXP 10
 410: PUSH
 411: LD_EXP 19
 415: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 416: LD_ADDR_VAR 0 5
 420: PUSH
 421: LD_STRING text
 423: PPUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 5
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_OWVAR 67
 442: ARRAY
 443: PPUSH
 444: LD_INT 6
 446: PUSH
 447: LD_INT 5
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_OWVAR 67
 462: ARRAY
 463: PPUSH
 464: LD_INT -5
 466: PUSH
 467: LD_EXP 19
 471: PUSH
 472: LD_INT -3
 474: PUSH
 475: LD_INT -2
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: LIST
 483: PUSH
 484: LD_EXP 20
 488: ADD
 489: PPUSH
 490: LD_INT 1
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 2
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 4
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PUSH
 516: LD_INT 5
 518: PUSH
 519: LD_INT 5
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL_OW 42
 548: ST_TO_ADDR
// team := team ^ us_commander ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: LD_EXP 19
 563: ADD
 564: ST_TO_ADDR
// for i = 1 to team do
 565: LD_ADDR_VAR 0 2
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 5
 579: PUSH
 580: FOR_TO
 581: IFFALSE 606
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 583: LD_VAR 0 5
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PPUSH
 594: LD_INT 1
 596: PPUSH
 597: LD_INT 0
 599: PPUSH
 600: CALL_OW 49
 604: GO 580
 606: POP
 607: POP
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 613: LD_OWVAR 1
 617: PUSH
 618: LD_INT 73500
 620: LESS
 621: IFFALSE 648
 623: GO 625
 625: DISABLE
// begin enable ;
 626: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 627: LD_INT 1
 629: PPUSH
 630: LD_INT 5
 632: PPUSH
 633: CALL_OW 12
 637: PPUSH
 638: LD_INT 24
 640: PPUSH
 641: LD_INT 1
 643: PPUSH
 644: CALL_OW 55
// end ;
 648: END
// every 1 1$10 do var time , p , l ;
 649: GO 651
 651: DISABLE
 652: LD_INT 0
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin time := 0 0$44 ;
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 1540
 664: ST_TO_ADDR
// l := 0 ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: LD_INT 0
 672: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 673: LD_VAR 0 1
 677: PPUSH
 678: CALL_OW 67
// l := l + 1 ;
 682: LD_ADDR_VAR 0 3
 686: PUSH
 687: LD_VAR 0 3
 691: PUSH
 692: LD_INT 1
 694: PLUS
 695: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 696: LD_INT 12
 698: PPUSH
 699: CALL_OW 435
 703: PUSH
 704: LD_INT 30
 706: LESS
 707: IFFALSE 766
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 709: LD_INT 1
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL_OW 12
 719: PPUSH
 720: LD_INT 12
 722: PPUSH
 723: LD_INT 1
 725: PPUSH
 726: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 730: LD_INT 1155
 732: PPUSH
 733: LD_INT 1540
 735: PPUSH
 736: CALL_OW 12
 740: PPUSH
 741: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 745: LD_INT 1
 747: PPUSH
 748: LD_INT 5
 750: PPUSH
 751: CALL_OW 12
 755: PPUSH
 756: LD_INT 12
 758: PPUSH
 759: LD_INT 1
 761: PPUSH
 762: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 766: LD_ADDR_VAR 0 2
 770: PUSH
 771: LD_INT 0
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 12
 781: ST_TO_ADDR
// if p then
 782: LD_VAR 0 2
 786: IFFALSE 821
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 788: LD_INT 105
 790: PPUSH
 791: LD_INT 350
 793: PPUSH
 794: CALL_OW 12
 798: PPUSH
 799: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 803: LD_INT 1
 805: PPUSH
 806: LD_INT 4
 808: PPUSH
 809: CALL_OW 12
 813: PPUSH
 814: LD_INT 1
 816: PPUSH
 817: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 15
 828: PUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 11
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: PUSH
 840: LD_OWVAR 67
 844: ARRAY
 845: MOD
 846: PUSH
 847: LD_INT 0
 849: EQUAL
 850: IFFALSE 866
// time := time + 2 2$00 ;
 852: LD_ADDR_VAR 0 1
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 4200
 864: PLUS
 865: ST_TO_ADDR
// end until false ;
 866: LD_INT 0
 868: IFFALSE 673
// end ; end_of_file
 870: PPOPN 3
 872: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
 882: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_INT 22
 890: PUSH
 891: LD_INT 4
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 69
 916: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_INT 470
 924: PUSH
 925: LD_INT 370
 927: PUSH
 928: LD_INT 290
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_OWVAR 67
 940: ARRAY
 941: ST_TO_ADDR
// case Difficulty of 2 :
 942: LD_OWVAR 67
 946: PUSH
 947: LD_INT 2
 949: DOUBLE
 950: EQUAL
 951: IFTRUE 955
 953: GO 986
 955: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 956: LD_VAR 0 3
 960: PPUSH
 961: LD_INT 30
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PPUSH
 971: CALL_OW 72
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 65
// end ; 3 :
 984: GO 1062
 986: LD_INT 3
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1061
 994: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 995: LD_VAR 0 3
 999: PPUSH
1000: LD_INT 30
1002: PUSH
1003: LD_INT 32
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 72
1014: PUSH
1015: LD_INT 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1023: LD_VAR 0 3
1027: PPUSH
1028: LD_INT 30
1030: PUSH
1031: LD_INT 27
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: PPUSH
1038: CALL_OW 72
1042: PUSH
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: CALL_OW 12
1053: ARRAY
1054: PPUSH
1055: CALL_OW 65
// end ; end ;
1059: GO 1062
1061: POP
// for i = 1 to filter do
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: DOUBLE
1068: LD_INT 1
1070: DEC
1071: ST_TO_ADDR
1072: LD_VAR 0 3
1076: PUSH
1077: FOR_TO
1078: IFFALSE 1115
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1080: LD_VAR 0 3
1084: PUSH
1085: LD_VAR 0 2
1089: ARRAY
1090: PPUSH
1091: LD_VAR 0 4
1095: PUSH
1096: LD_INT 29
1098: NEG
1099: PPUSH
1100: LD_INT 29
1102: PPUSH
1103: CALL_OW 12
1107: PLUS
1108: PPUSH
1109: CALL_OW 234
1113: GO 1077
1115: POP
1116: POP
// SetBName ( us_depot , Vulcano1 ) ;
1117: LD_INT 50
1119: PPUSH
1120: LD_STRING Vulcano1
1122: PPUSH
1123: CALL_OW 500
// hc_importance := 0 ;
1127: LD_ADDR_OWVAR 32
1131: PUSH
1132: LD_INT 0
1134: ST_TO_ADDR
// uc_side := 3 ;
1135: LD_ADDR_OWVAR 20
1139: PUSH
1140: LD_INT 3
1142: ST_TO_ADDR
// uc_nation := nation_russian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 3
1150: ST_TO_ADDR
// russian_in_base := [ ] ;
1151: LD_ADDR_VAR 0 8
1155: PUSH
1156: EMPTY
1157: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1158: LD_ADDR_VAR 0 6
1162: PUSH
1163: LD_INT 82
1165: PPUSH
1166: LD_INT 137
1168: PPUSH
1169: LD_INT 106
1171: PPUSH
1172: LD_INT 152
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL 1555 0 5
1182: ST_TO_ADDR
// p := 1 ;
1183: LD_ADDR_VAR 0 7
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: DOUBLE
1197: LD_INT 1
1199: DEC
1200: ST_TO_ADDR
1201: LD_INT 6
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_OWVAR 67
1219: ARRAY
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1334
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1224: LD_INT 0
1226: PPUSH
1227: LD_INT 1
1229: PPUSH
1230: LD_INT 4
1232: PUSH
1233: LD_INT 5
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_OWVAR 67
1248: ARRAY
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1264: LD_ADDR_VAR 0 8
1268: PUSH
1269: LD_VAR 0 8
1273: PUSH
1274: LD_VAR 0 5
1278: ADD
1279: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1280: LD_VAR 0 5
1284: PPUSH
1285: LD_VAR 0 6
1289: PUSH
1290: LD_VAR 0 7
1294: ARRAY
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_VAR 0 7
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: ARRAY
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL_OW 48
// p := p + 2 ;
1318: LD_ADDR_VAR 0 7
1322: PUSH
1323: LD_VAR 0 7
1327: PUSH
1328: LD_INT 2
1330: PLUS
1331: ST_TO_ADDR
// end ;
1332: GO 1221
1334: POP
1335: POP
// end ;
1336: LD_VAR 0 1
1340: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1341: LD_INT 50
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: CALL 2045 0 2
1351: PUSH
1352: LD_INT 40
1354: LESS
1355: IFFALSE 1552
1357: GO 1359
1359: DISABLE
1360: LD_INT 0
1362: PPUSH
1363: PPUSH
// begin uc_side := 4 ;
1364: LD_ADDR_OWVAR 20
1368: PUSH
1369: LD_INT 4
1371: ST_TO_ADDR
// uc_nation := nation_american ;
1372: LD_ADDR_OWVAR 21
1376: PUSH
1377: LD_INT 1
1379: ST_TO_ADDR
// hc_importance := 0 ;
1380: LD_ADDR_OWVAR 32
1384: PUSH
1385: LD_INT 0
1387: ST_TO_ADDR
// for i = 1 to 7 do
1388: LD_ADDR_VAR 0 1
1392: PUSH
1393: DOUBLE
1394: LD_INT 1
1396: DEC
1397: ST_TO_ADDR
1398: LD_INT 7
1400: PUSH
1401: FOR_TO
1402: IFFALSE 1466
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1404: LD_INT 0
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: CALL_OW 12
1417: PPUSH
1418: LD_EXP 21
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1437: LD_VAR 0 2
1441: PPUSH
1442: LD_INT 7
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// SetLives ( un , 10 ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_INT 10
1459: PPUSH
1460: CALL_OW 234
// end ;
1464: GO 1401
1466: POP
1467: POP
// for i = 1 to 5 do
1468: LD_ADDR_VAR 0 1
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 5
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1550
// begin PrepareHuman ( false , 4 , us_skill ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_INT 4
1489: PPUSH
1490: LD_EXP 21
1494: PPUSH
1495: CALL_OW 380
// SetDir ( un , 1 ) ;
1499: LD_VAR 0 2
1503: PPUSH
1504: LD_INT 1
1506: PPUSH
1507: CALL_OW 233
// un := CreateHuman ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: CALL_OW 44
1520: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1521: LD_VAR 0 2
1525: PPUSH
1526: LD_INT 23
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// SetLives ( un , 10 ) ;
1536: LD_VAR 0 2
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: CALL_OW 234
// end ;
1548: GO 1481
1550: POP
1551: POP
// end ; end_of_file
1552: PPOPN 2
1554: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1555: LD_INT 0
1557: PPUSH
1558: PPUSH
1559: PPUSH
// list := [ ] ;
1560: LD_ADDR_VAR 0 7
1564: PUSH
1565: EMPTY
1566: ST_TO_ADDR
// for i = 1 to num do
1567: LD_ADDR_VAR 0 8
1571: PUSH
1572: DOUBLE
1573: LD_INT 1
1575: DEC
1576: ST_TO_ADDR
1577: LD_VAR 0 5
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1639
// begin list := list ^ Rand ( x1 , x2 ) ;
1585: LD_ADDR_VAR 0 7
1589: PUSH
1590: LD_VAR 0 7
1594: PUSH
1595: LD_VAR 0 1
1599: PPUSH
1600: LD_VAR 0 3
1604: PPUSH
1605: CALL_OW 12
1609: ADD
1610: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1611: LD_ADDR_VAR 0 7
1615: PUSH
1616: LD_VAR 0 7
1620: PUSH
1621: LD_VAR 0 2
1625: PPUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: CALL_OW 12
1635: ADD
1636: ST_TO_ADDR
// end ;
1637: GO 1582
1639: POP
1640: POP
// result := list ;
1641: LD_ADDR_VAR 0 6
1645: PUSH
1646: LD_VAR 0 7
1650: ST_TO_ADDR
// end ;
1651: LD_VAR 0 6
1655: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1656: LD_INT 0
1658: PPUSH
1659: PPUSH
1660: PPUSH
1661: PPUSH
// c := Rand ( 1 , 3 ) ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_INT 1
1669: PPUSH
1670: LD_INT 3
1672: PPUSH
1673: CALL_OW 12
1677: ST_TO_ADDR
// for i = 1 to list do
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: DOUBLE
1684: LD_INT 1
1686: DEC
1687: ST_TO_ADDR
1688: LD_VAR 0 1
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1876
// for ta in filter do
1696: LD_ADDR_VAR 0 4
1700: PUSH
1701: LD_VAR 0 2
1705: PUSH
1706: FOR_IN
1707: IFFALSE 1872
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1709: LD_VAR 0 1
1713: PUSH
1714: LD_VAR 0 6
1718: ARRAY
1719: PPUSH
1720: LD_VAR 0 4
1724: PPUSH
1725: CALL_OW 296
1729: PUSH
1730: LD_INT 15
1732: LESSEQUAL
1733: IFFALSE 1870
// begin case c of 1 :
1735: LD_VAR 0 5
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1786
1748: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1749: LD_VAR 0 1
1753: PUSH
1754: LD_VAR 0 6
1758: ARRAY
1759: PPUSH
1760: LD_VAR 0 4
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 154
1784: GO 1870
1786: LD_INT 2
1788: DOUBLE
1789: EQUAL
1790: IFTRUE 1794
1792: GO 1858
1794: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1795: LD_VAR 0 1
1799: PUSH
1800: LD_VAR 0 6
1804: ARRAY
1805: PPUSH
1806: LD_VAR 0 4
1810: PPUSH
1811: CALL_OW 250
1815: PUSH
1816: LD_INT 1
1818: NEG
1819: PPUSH
1820: LD_INT 1
1822: PPUSH
1823: CALL_OW 12
1827: PLUS
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: CALL_OW 251
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: CALL_OW 12
1850: PLUS
1851: PPUSH
1852: CALL_OW 153
1856: GO 1870
1858: LD_INT 3
1860: DOUBLE
1861: EQUAL
1862: IFTRUE 1866
1864: GO 1869
1866: POP
// ; end ;
1867: GO 1870
1869: POP
// end ; end ;
1870: GO 1706
1872: POP
1873: POP
1874: GO 1693
1876: POP
1877: POP
// end ;
1878: LD_VAR 0 3
1882: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
// for i = 1 to n do
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: DOUBLE
1894: LD_INT 1
1896: DEC
1897: ST_TO_ADDR
1898: LD_VAR 0 1
1902: PUSH
1903: FOR_TO
1904: IFFALSE 2038
// begin uc_side := 0 ;
1906: LD_ADDR_OWVAR 20
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// uc_nation := 0 ;
1914: LD_ADDR_OWVAR 21
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// hc_class := class_apeman ;
1922: LD_ADDR_OWVAR 28
1926: PUSH
1927: LD_INT 12
1929: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1930: LD_ADDR_OWVAR 31
1934: PUSH
1935: LD_INT 0
1937: PUSH
1938: LD_INT 0
1940: PUSH
1941: LD_INT 0
1943: PUSH
1944: LD_INT 0
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: ST_TO_ADDR
// hc_name :=  ;
1953: LD_ADDR_OWVAR 26
1957: PUSH
1958: LD_STRING 
1960: ST_TO_ADDR
// hc_gallery :=  ;
1961: LD_ADDR_OWVAR 33
1965: PUSH
1966: LD_STRING 
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// un := CreateHuman ;
1977: LD_ADDR_VAR 0 3
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1987: LD_VAR 0 3
1991: PPUSH
1992: LD_INT 19
1994: PUSH
1995: LD_INT 20
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PPUSH
2014: LD_INT 0
2016: PPUSH
2017: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2021: LD_INT 1155
2023: PPUSH
2024: LD_INT 5355
2026: PPUSH
2027: CALL_OW 12
2031: PPUSH
2032: CALL_OW 67
// end ;
2036: GO 1903
2038: POP
2039: POP
// end ;
2040: LD_VAR 0 2
2044: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2050: LD_ADDR_VAR 0 4
2054: PUSH
2055: LD_INT 22
2057: PUSH
2058: LD_VAR 0 2
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 74
2081: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2082: LD_ADDR_VAR 0 5
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_VAR 0 4
2096: PPUSH
2097: CALL_OW 296
2101: ST_TO_ADDR
// if dist >= 9999 then
2102: LD_VAR 0 5
2106: PUSH
2107: LD_INT 9999
2109: GREATEREQUAL
2110: IFFALSE 2123
// result := - 1 else
2112: LD_ADDR_VAR 0 3
2116: PUSH
2117: LD_INT 1
2119: NEG
2120: ST_TO_ADDR
2121: GO 2133
// result := dist ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 5
2132: ST_TO_ADDR
// end ;
2133: LD_VAR 0 3
2137: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2138: LD_INT 0
2140: PPUSH
2141: PPUSH
2142: PPUSH
2143: PPUSH
// tmp := 9999 ;
2144: LD_ADDR_VAR 0 5
2148: PUSH
2149: LD_INT 9999
2151: ST_TO_ADDR
// for i = 1 to plist do
2152: LD_ADDR_VAR 0 4
2156: PUSH
2157: DOUBLE
2158: LD_INT 1
2160: DEC
2161: ST_TO_ADDR
2162: LD_VAR 0 1
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2242
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2170: LD_VAR 0 1
2174: PUSH
2175: LD_VAR 0 4
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 2
2185: PPUSH
2186: CALL 2045 0 2
2190: PUSH
2191: LD_VAR 0 5
2195: LESS
2196: IFFALSE 2240
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 1
2207: PUSH
2208: LD_VAR 0 4
2212: ARRAY
2213: PPUSH
2214: LD_VAR 0 2
2218: PPUSH
2219: CALL 2045 0 2
2223: ST_TO_ADDR
// unit := plist [ i ] ;
2224: LD_ADDR_VAR 0 6
2228: PUSH
2229: LD_VAR 0 1
2233: PUSH
2234: LD_VAR 0 4
2238: ARRAY
2239: ST_TO_ADDR
// end ;
2240: GO 2167
2242: POP
2243: POP
// result := unit ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: LD_VAR 0 6
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 3
2258: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2266: LD_ADDR_VAR 0 2
2270: PUSH
2271: LD_INT 1000
2273: PUSH
2274: LD_INT 2500
2276: PUSH
2277: LD_INT 5000
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: LD_OWVAR 67
2289: ARRAY
2290: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2291: LD_ADDR_VAR 0 2
2295: PUSH
2296: LD_VAR 0 2
2300: PUSH
2301: LD_INT 1
2303: NEG
2304: PUSH
2305: LD_INT 22
2307: PUSH
2308: LD_OWVAR 2
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: MUL
2336: PUSH
2337: LD_INT 30
2339: MUL
2340: PLUS
2341: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2342: LD_ADDR_VAR 0 2
2346: PUSH
2347: LD_VAR 0 2
2351: PUSH
2352: LD_EXP 15
2356: PUSH
2357: LD_INT 10
2359: MUL
2360: PLUS
2361: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2362: LD_ADDR_VAR 0 2
2366: PUSH
2367: LD_VAR 0 2
2371: PUSH
2372: LD_INT 1
2374: NEG
2375: PUSH
2376: LD_EXP 15
2380: MUL
2381: PUSH
2382: LD_INT 20
2384: MUL
2385: PLUS
2386: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_INT 1
2399: NEG
2400: PUSH
2401: LD_OWVAR 1
2405: PUSH
2406: LD_INT 35
2408: DIVREAL
2409: PUSH
2410: LD_INT 60
2412: DIVREAL
2413: MUL
2414: PUSH
2415: LD_INT 25
2417: MUL
2418: PLUS
2419: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: LD_VAR 0 2
2429: PUSH
2430: LD_EXP 17
2434: PUSH
2435: LD_INT 15
2437: MUL
2438: PLUS
2439: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2440: LD_ADDR_VAR 0 2
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: NEG
2453: PUSH
2454: LD_EXP 18
2458: MUL
2459: PUSH
2460: LD_INT 1000
2462: MUL
2463: PLUS
2464: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 16
2479: PUSH
2480: LD_INT 5
2482: MUL
2483: PLUS
2484: ST_TO_ADDR
// result := points ;
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_VAR 0 2
2494: ST_TO_ADDR
// end ; end_of_file
2495: LD_VAR 0 1
2499: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2500: LD_VAR 0 1
2504: PPUSH
2505: CALL_OW 255
2509: PUSH
2510: LD_OWVAR 2
2514: EQUAL
2515: IFFALSE 2531
// dead_counter := dead_counter + 1 ;
2517: LD_ADDR_EXP 14
2521: PUSH
2522: LD_EXP 14
2526: PUSH
2527: LD_INT 1
2529: PLUS
2530: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 255
2540: PUSH
2541: LD_INT 81
2543: PUSH
2544: LD_OWVAR 2
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: IN
2558: IFFALSE 2574
// kill_counter := kill_counter + 1 ;
2560: LD_ADDR_EXP 15
2564: PUSH
2565: LD_EXP 15
2569: PUSH
2570: LD_INT 1
2572: PLUS
2573: ST_TO_ADDR
// if un = player_commander then
2574: LD_VAR 0 1
2578: PUSH
2579: LD_EXP 10
2583: EQUAL
2584: IFFALSE 2593
// YouLost ( vulcano-lost ) ;
2586: LD_STRING vulcano-lost
2588: PPUSH
2589: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2593: LD_VAR 0 1
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_INT 3
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: PUSH
2608: LD_INT 21
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PPUSH
2622: CALL_OW 69
2626: IN
2627: IFFALSE 2743
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2629: LD_VAR 0 1
2633: PPUSH
2634: CALL_OW 266
2638: PUSH
2639: LD_INT 33
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 266
2652: PUSH
2653: LD_INT 28
2655: EQUAL
2656: OR
2657: IFFALSE 2743
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2659: LD_ADDR_EXP 26
2663: PUSH
2664: LD_EXP 26
2668: PUSH
2669: LD_VAR 0 1
2673: PPUSH
2674: CALL_OW 266
2678: ADD
2679: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2680: LD_ADDR_EXP 26
2684: PUSH
2685: LD_EXP 26
2689: PUSH
2690: LD_VAR 0 1
2694: PPUSH
2695: CALL_OW 250
2699: ADD
2700: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2701: LD_ADDR_EXP 26
2705: PUSH
2706: LD_EXP 26
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 251
2720: ADD
2721: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2722: LD_ADDR_EXP 26
2726: PUSH
2727: LD_EXP 26
2731: PUSH
2732: LD_VAR 0 1
2736: PPUSH
2737: CALL_OW 254
2741: ADD
2742: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2743: LD_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 8
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: IN
2777: IFFALSE 2921
// begin if GetBType ( un ) = b_barracks then
2779: LD_VAR 0 1
2783: PPUSH
2784: CALL_OW 266
2788: PUSH
2789: LD_INT 5
2791: EQUAL
2792: IFFALSE 2810
// legion_blist := legion_blist ^ b_armoury else
2794: LD_ADDR_EXP 34
2798: PUSH
2799: LD_EXP 34
2803: PUSH
2804: LD_INT 4
2806: ADD
2807: ST_TO_ADDR
2808: GO 2858
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2810: LD_VAR 0 1
2814: PPUSH
2815: CALL_OW 266
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 6
2825: PUSH
2826: LD_INT 8
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: IN
2834: NOT
2835: IFFALSE 2858
// legion_blist := legion_blist ^ GetBType ( un ) ;
2837: LD_ADDR_EXP 34
2841: PUSH
2842: LD_EXP 34
2846: PUSH
2847: LD_VAR 0 1
2851: PPUSH
2852: CALL_OW 266
2856: ADD
2857: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2858: LD_ADDR_EXP 34
2862: PUSH
2863: LD_EXP 34
2867: PUSH
2868: LD_VAR 0 1
2872: PPUSH
2873: CALL_OW 250
2877: ADD
2878: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2879: LD_ADDR_EXP 34
2883: PUSH
2884: LD_EXP 34
2888: PUSH
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 251
2898: ADD
2899: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2900: LD_ADDR_EXP 34
2904: PUSH
2905: LD_EXP 34
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: CALL_OW 254
2919: ADD
2920: ST_TO_ADDR
// end ; if un in legion_force then
2921: LD_VAR 0 1
2925: PUSH
2926: LD_EXP 31
2930: IN
2931: IFFALSE 2949
// legion_force := legion_force diff un ;
2933: LD_ADDR_EXP 31
2937: PUSH
2938: LD_EXP 31
2942: PUSH
2943: LD_VAR 0 1
2947: DIFF
2948: ST_TO_ADDR
// if un in ru_force then
2949: LD_VAR 0 1
2953: PUSH
2954: LD_EXP 23
2958: IN
2959: IFFALSE 2977
// ru_force := ru_force diff un ;
2961: LD_ADDR_EXP 23
2965: PUSH
2966: LD_EXP 23
2970: PUSH
2971: LD_VAR 0 1
2975: DIFF
2976: ST_TO_ADDR
// if un in al_force then
2977: LD_VAR 0 1
2981: PUSH
2982: LD_EXP 38
2986: IN
2987: IFFALSE 3005
// al_force := al_force diff un ;
2989: LD_ADDR_EXP 38
2993: PUSH
2994: LD_EXP 38
2998: PUSH
2999: LD_VAR 0 1
3003: DIFF
3004: ST_TO_ADDR
// end ;
3005: PPOPN 1
3007: END
// on BuildingComplete ( b ) do var i ;
3008: LD_INT 0
3010: PPUSH
// begin if GetSide ( b ) = 8 then
3011: LD_VAR 0 1
3015: PPUSH
3016: CALL_OW 255
3020: PUSH
3021: LD_INT 8
3023: EQUAL
3024: IFFALSE 3064
// for i = 1 to 4 do
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: DOUBLE
3032: LD_INT 1
3034: DEC
3035: ST_TO_ADDR
3036: LD_INT 4
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3062
// legion_blist := Delete ( legion_blist , 1 ) ;
3042: LD_ADDR_EXP 34
3046: PUSH
3047: LD_EXP 34
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: CALL_OW 3
3059: ST_TO_ADDR
3060: GO 3039
3062: POP
3063: POP
// if GetSide ( b ) = 3 then
3064: LD_VAR 0 1
3068: PPUSH
3069: CALL_OW 255
3073: PUSH
3074: LD_INT 3
3076: EQUAL
3077: IFFALSE 3117
// for i = 1 to 4 do
3079: LD_ADDR_VAR 0 2
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_INT 4
3091: PUSH
3092: FOR_TO
3093: IFFALSE 3115
// ru_blist := Delete ( ru_blist , 1 ) ;
3095: LD_ADDR_EXP 26
3099: PUSH
3100: LD_EXP 26
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: CALL_OW 3
3112: ST_TO_ADDR
3113: GO 3092
3115: POP
3116: POP
// end ;
3117: PPOPN 2
3119: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3120: LD_VAR 0 1
3124: PPUSH
3125: CALL_OW 264
3129: PUSH
3130: LD_INT 51
3132: PUSH
3133: LD_INT 48
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: IN
3140: NOT
3141: IFFALSE 3189
// begin if GetSide ( veh ) = 3 then
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 255
3152: PUSH
3153: LD_INT 3
3155: EQUAL
3156: IFFALSE 3189
// begin ComMoveXY ( veh , 149 , 8 ) ;
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 149
3165: PPUSH
3166: LD_INT 8
3168: PPUSH
3169: CALL_OW 111
// ru_force := ru_force ^ veh ;
3173: LD_ADDR_EXP 23
3177: PUSH
3178: LD_EXP 23
3182: PUSH
3183: LD_VAR 0 1
3187: ADD
3188: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 264
3198: PUSH
3199: LD_INT 32
3201: PUSH
3202: LD_INT 31
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: IN
3209: NOT
3210: IFFALSE 3243
// begin if GetSide ( veh ) = 8 then
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 255
3221: PUSH
3222: LD_INT 8
3224: EQUAL
3225: IFFALSE 3243
// legion_force := legion_force ^ veh ;
3227: LD_ADDR_EXP 31
3231: PUSH
3232: LD_EXP 31
3236: PUSH
3237: LD_VAR 0 1
3241: ADD
3242: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3243: LD_VAR 0 1
3247: PPUSH
3248: CALL_OW 255
3252: PUSH
3253: LD_INT 7
3255: EQUAL
3256: PUSH
3257: LD_OWVAR 2
3261: PUSH
3262: LD_INT 7
3264: NONEQUAL
3265: AND
3266: IFFALSE 3284
// al_force := al_force ^ veh ;
3268: LD_ADDR_EXP 38
3272: PUSH
3273: LD_EXP 38
3277: PUSH
3278: LD_VAR 0 1
3282: ADD
3283: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3284: LD_VAR 0 1
3288: PPUSH
3289: CALL_OW 255
3293: PUSH
3294: LD_OWVAR 2
3298: EQUAL
3299: IFFALSE 3315
// veh_counter := veh_counter + 1 ;
3301: LD_ADDR_EXP 16
3305: PUSH
3306: LD_EXP 16
3310: PUSH
3311: LD_INT 1
3313: PLUS
3314: ST_TO_ADDR
// end ;
3315: PPOPN 2
3317: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3318: LD_VAR 0 1
3322: PPUSH
3323: CALL_OW 255
3327: PUSH
3328: LD_OWVAR 2
3332: NONEQUAL
3333: IFFALSE 3349
// sib_contamin_counter := sib_contamin_counter + 1 ;
3335: LD_ADDR_EXP 18
3339: PUSH
3340: LD_EXP 18
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: ST_TO_ADDR
// end ;
3349: PPOPN 3
3351: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3352: LD_VAR 0 2
3356: PPUSH
3357: CALL_OW 255
3361: PUSH
3362: LD_OWVAR 2
3366: EQUAL
3367: IFFALSE 3383
// tech_counter := tech_counter + 1 ;
3369: LD_ADDR_EXP 17
3373: PUSH
3374: LD_EXP 17
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3383: LD_VAR 0 1
3387: PUSH
3388: LD_INT 53
3390: EQUAL
3391: PUSH
3392: LD_OWVAR 2
3396: PUSH
3397: LD_INT 1
3399: EQUAL
3400: AND
3401: IFFALSE 3416
// SetTech ( 80 , 1 , state_researched ) ;
3403: LD_INT 80
3405: PPUSH
3406: LD_INT 1
3408: PPUSH
3409: LD_INT 2
3411: PPUSH
3412: CALL_OW 322
// end ;
3416: PPOPN 2
3418: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3419: LD_INT 25
3421: PUSH
3422: LD_INT 12
3424: PUSH
3425: EMPTY
3426: LIST
3427: LIST
3428: PPUSH
3429: CALL_OW 69
3433: PUSH
3434: LD_INT 9
3436: LESS
3437: IFFALSE 3479
3439: GO 3441
3441: DISABLE
3442: LD_INT 0
3444: PPUSH
// begin enable ;
3445: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3446: LD_ADDR_VAR 0 1
3450: PUSH
3451: LD_INT 25
3453: PUSH
3454: LD_INT 12
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3466: LD_INT 8
3468: PUSH
3469: LD_VAR 0 1
3473: MINUS
3474: PPUSH
3475: CALL 1883 0 1
// end ; end_of_file
3479: PPOPN 1
3481: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3482: LD_INT 0
3484: PPUSH
3485: PPUSH
3486: PPUSH
3487: PPUSH
3488: PPUSH
3489: PPUSH
3490: PPUSH
3491: PPUSH
3492: PPUSH
3493: PPUSH
3494: PPUSH
// uc_side := 3 ;
3495: LD_ADDR_OWVAR 20
3499: PUSH
3500: LD_INT 3
3502: ST_TO_ADDR
// uc_nation := nation_russian ;
3503: LD_ADDR_OWVAR 21
3507: PUSH
3508: LD_INT 3
3510: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3511: LD_ADDR_VAR 0 4
3515: PUSH
3516: LD_INT 22
3518: PUSH
3519: LD_INT 3
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: PUSH
3526: LD_INT 30
3528: PUSH
3529: LD_INT 1
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PUSH
3536: EMPTY
3537: LIST
3538: LIST
3539: PPUSH
3540: CALL_OW 69
3544: PUSH
3545: LD_INT 1
3547: ARRAY
3548: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3549: LD_ADDR_VAR 0 5
3553: PUSH
3554: LD_INT 22
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PUSH
3564: LD_INT 30
3566: PUSH
3567: LD_INT 3
3569: PUSH
3570: EMPTY
3571: LIST
3572: LIST
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: PPUSH
3578: CALL_OW 69
3582: PUSH
3583: LD_INT 1
3585: ARRAY
3586: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_INT 22
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 30
3604: PUSH
3605: LD_INT 34
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 69
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3625: LD_ADDR_VAR 0 8
3629: PUSH
3630: LD_INT 22
3632: PUSH
3633: LD_INT 3
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 30
3642: PUSH
3643: LD_INT 33
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PPUSH
3654: CALL_OW 69
3658: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3659: LD_ADDR_VAR 0 7
3663: PUSH
3664: LD_INT 22
3666: PUSH
3667: LD_INT 3
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: LD_INT 30
3676: PUSH
3677: LD_INT 5
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: PPUSH
3688: CALL_OW 69
3692: PUSH
3693: LD_INT 1
3695: ARRAY
3696: ST_TO_ADDR
// ru_blist := [ ] ;
3697: LD_ADDR_EXP 26
3701: PUSH
3702: EMPTY
3703: ST_TO_ADDR
// ru_vlist := [ ] ;
3704: LD_ADDR_EXP 27
3708: PUSH
3709: EMPTY
3710: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3711: LD_ADDR_EXP 30
3715: PUSH
3716: LD_INT 183
3718: PUSH
3719: LD_INT 62
3721: PUSH
3722: LD_INT 147
3724: PUSH
3725: LD_INT 44
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3734: LD_INT 30
3736: PUSH
3737: LD_INT 34
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PPUSH
3744: CALL_OW 69
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_EXP 30
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: PPUSH
3762: LD_EXP 30
3766: PUSH
3767: LD_INT 2
3769: ARRAY
3770: PPUSH
3771: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3775: LD_ADDR_EXP 28
3779: PUSH
3780: LD_INT 4
3782: PUSH
3783: LD_INT 5
3785: PUSH
3786: LD_INT 6
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: LIST
3793: PUSH
3794: LD_OWVAR 67
3798: ARRAY
3799: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3800: LD_VAR 0 4
3804: PPUSH
3805: CALL_OW 274
3809: PPUSH
3810: LD_INT 1
3812: PPUSH
3813: LD_INT 3000
3815: PPUSH
3816: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: CALL_OW 274
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: LD_INT 300
3835: PPUSH
3836: CALL_OW 277
// hc_gallery :=  ;
3840: LD_ADDR_OWVAR 33
3844: PUSH
3845: LD_STRING 
3847: ST_TO_ADDR
// hc_name :=  ;
3848: LD_ADDR_OWVAR 26
3852: PUSH
3853: LD_STRING 
3855: ST_TO_ADDR
// hc_importance := 0 ;
3856: LD_ADDR_OWVAR 32
3860: PUSH
3861: LD_INT 0
3863: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3864: LD_ADDR_EXP 24
3868: PUSH
3869: LD_INT 5
3871: PUSH
3872: LD_INT 6
3874: PUSH
3875: LD_INT 7
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: LIST
3882: PUSH
3883: LD_OWVAR 67
3887: ARRAY
3888: ST_TO_ADDR
// for i = 1 to 6 do
3889: LD_ADDR_VAR 0 2
3893: PUSH
3894: DOUBLE
3895: LD_INT 1
3897: DEC
3898: ST_TO_ADDR
3899: LD_INT 6
3901: PUSH
3902: FOR_TO
3903: IFFALSE 4061
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3905: LD_INT 0
3907: PPUSH
3908: LD_INT 9
3910: PPUSH
3911: LD_EXP 24
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3930: LD_VAR 0 3
3934: PPUSH
3935: LD_VAR 0 7
3939: PPUSH
3940: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3944: LD_INT 0
3946: PPUSH
3947: LD_INT 4
3949: PPUSH
3950: LD_EXP 24
3954: PPUSH
3955: CALL_OW 380
// un := CreateHuman ;
3959: LD_ADDR_VAR 0 3
3963: PUSH
3964: CALL_OW 44
3968: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3969: LD_VAR 0 3
3973: PPUSH
3974: LD_INT 24
3976: PPUSH
3977: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3981: LD_INT 0
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_EXP 24
3991: PPUSH
3992: CALL_OW 380
// un := CreateHuman ;
3996: LD_ADDR_VAR 0 3
4000: PUSH
4001: CALL_OW 44
4005: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4006: LD_VAR 0 3
4010: PPUSH
4011: LD_VAR 0 5
4015: PPUSH
4016: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4020: LD_INT 0
4022: PPUSH
4023: LD_INT 2
4025: PPUSH
4026: LD_EXP 24
4030: PPUSH
4031: CALL_OW 380
// un := CreateHuman ;
4035: LD_ADDR_VAR 0 3
4039: PUSH
4040: CALL_OW 44
4044: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4045: LD_VAR 0 3
4049: PPUSH
4050: LD_VAR 0 4
4054: PPUSH
4055: CALL_OW 52
// end ;
4059: GO 3902
4061: POP
4062: POP
// russian_prepared := true ;
4063: LD_ADDR_EXP 2
4067: PUSH
4068: LD_INT 1
4070: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4071: LD_VAR 0 5
4075: PPUSH
4076: LD_INT 21
4078: PPUSH
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_INT 51
4087: PPUSH
4088: CALL_OW 125
// end ;
4092: LD_VAR 0 1
4096: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4097: LD_INT 22
4099: PUSH
4100: LD_INT 3
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PPUSH
4107: CALL_OW 69
4111: PUSH
4112: LD_INT 0
4114: GREATER
4115: PUSH
4116: LD_EXP 2
4120: AND
4121: IFFALSE 6584
4123: GO 4125
4125: DISABLE
4126: LD_INT 0
4128: PPUSH
4129: PPUSH
4130: PPUSH
4131: PPUSH
4132: PPUSH
4133: PPUSH
4134: PPUSH
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
// begin enable ;
4145: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4146: LD_ADDR_VAR 0 1
4150: PUSH
4151: LD_INT 22
4153: PUSH
4154: LD_INT 3
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PUSH
4161: LD_INT 30
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PPUSH
4175: CALL_OW 69
4179: PUSH
4180: LD_INT 1
4182: ARRAY
4183: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: LD_INT 22
4191: PUSH
4192: LD_INT 3
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: PUSH
4199: LD_INT 30
4201: PUSH
4202: LD_INT 3
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PPUSH
4213: CALL_OW 69
4217: PUSH
4218: LD_INT 1
4220: ARRAY
4221: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4222: LD_ADDR_VAR 0 3
4226: PUSH
4227: LD_INT 22
4229: PUSH
4230: LD_INT 3
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 30
4239: PUSH
4240: LD_INT 34
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: PPUSH
4251: CALL_OW 69
4255: PUSH
4256: LD_INT 1
4258: ARRAY
4259: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4260: LD_ADDR_VAR 0 4
4264: PUSH
4265: LD_INT 22
4267: PUSH
4268: LD_INT 3
4270: PUSH
4271: EMPTY
4272: LIST
4273: LIST
4274: PUSH
4275: LD_INT 30
4277: PUSH
4278: LD_INT 33
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PPUSH
4289: CALL_OW 69
4293: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4294: LD_ADDR_VAR 0 8
4298: PUSH
4299: LD_INT 22
4301: PUSH
4302: LD_INT 3
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 30
4311: PUSH
4312: LD_INT 5
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PPUSH
4323: CALL_OW 69
4327: PUSH
4328: LD_INT 1
4330: ARRAY
4331: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4332: LD_ADDR_VAR 0 5
4336: PUSH
4337: LD_INT 22
4339: PUSH
4340: LD_INT 3
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 21
4349: PUSH
4350: LD_INT 3
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PPUSH
4361: CALL_OW 69
4365: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4366: LD_ADDR_VAR 0 6
4370: PUSH
4371: LD_INT 22
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 21
4383: PUSH
4384: LD_INT 2
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PPUSH
4395: CALL_OW 69
4399: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4400: LD_ADDR_VAR 0 7
4404: PUSH
4405: LD_INT 22
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 21
4417: PUSH
4418: LD_INT 1
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL_OW 69
4433: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4434: LD_ADDR_VAR 0 9
4438: PUSH
4439: LD_VAR 0 7
4443: PPUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PPUSH
4454: CALL_OW 72
4458: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4459: LD_ADDR_VAR 0 10
4463: PUSH
4464: LD_VAR 0 7
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 3
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 72
4483: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4484: LD_ADDR_VAR 0 11
4488: PUSH
4489: LD_VAR 0 7
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 4
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4509: LD_INT 22
4511: PUSH
4512: LD_INT 3
4514: PUSH
4515: EMPTY
4516: LIST
4517: LIST
4518: PUSH
4519: LD_INT 34
4521: PUSH
4522: LD_INT 51
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: PUSH
4538: LD_INT 0
4540: GREATER
4541: PUSH
4542: LD_EXP 25
4546: PUSH
4547: LD_INT 0
4549: EQUAL
4550: AND
4551: IFFALSE 4591
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4553: LD_ADDR_EXP 25
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 3
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 34
4570: PUSH
4571: LD_INT 51
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL_OW 69
4586: PUSH
4587: LD_INT 1
4589: ARRAY
4590: ST_TO_ADDR
// if ru_cargo then
4591: LD_EXP 25
4595: IFFALSE 4893
// begin if IsInArea ( ru_cargo , ru_base ) then
4597: LD_EXP 25
4601: PPUSH
4602: LD_INT 9
4604: PPUSH
4605: CALL_OW 308
4609: IFFALSE 4688
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4611: LD_EXP 25
4615: PPUSH
4616: LD_INT 1
4618: PPUSH
4619: CALL_OW 289
4623: PUSH
4624: LD_INT 0
4626: EQUAL
4627: IFFALSE 4645
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4629: LD_EXP 25
4633: PPUSH
4634: LD_VAR 0 3
4638: PPUSH
4639: CALL_OW 120
4643: GO 4686
// if not HasTask ( ru_cargo ) then
4645: LD_EXP 25
4649: PPUSH
4650: CALL_OW 314
4654: NOT
4655: IFFALSE 4686
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4657: LD_EXP 25
4661: PPUSH
4662: LD_VAR 0 1
4666: PPUSH
4667: CALL_OW 250
4671: PPUSH
4672: LD_VAR 0 1
4676: PPUSH
4677: CALL_OW 251
4681: PPUSH
4682: CALL_OW 111
// end else
4686: GO 4893
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4688: LD_EXP 25
4692: PPUSH
4693: CALL_OW 314
4697: NOT
4698: PUSH
4699: LD_EXP 25
4703: PPUSH
4704: LD_INT 1
4706: PPUSH
4707: CALL_OW 289
4711: PUSH
4712: LD_INT 100
4714: LESS
4715: AND
4716: IFFALSE 4782
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4718: LD_ADDR_VAR 0 16
4722: PUSH
4723: LD_INT 11
4725: PPUSH
4726: CALL_OW 435
4730: ST_TO_ADDR
// if cr > 0 then
4731: LD_VAR 0 16
4735: PUSH
4736: LD_INT 0
4738: GREATER
4739: IFFALSE 4770
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4741: LD_EXP 25
4745: PPUSH
4746: LD_VAR 0 16
4750: PUSH
4751: LD_INT 1
4753: ARRAY
4754: PPUSH
4755: LD_VAR 0 16
4759: PUSH
4760: LD_INT 2
4762: ARRAY
4763: PPUSH
4764: CALL_OW 117
4768: GO 4782
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4770: LD_EXP 25
4774: PPUSH
4775: LD_INT 11
4777: PPUSH
4778: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4782: LD_EXP 25
4786: PPUSH
4787: CALL_OW 314
4791: NOT
4792: PUSH
4793: LD_EXP 25
4797: PPUSH
4798: LD_INT 10
4800: PPUSH
4801: CALL_OW 308
4805: NOT
4806: AND
4807: PUSH
4808: LD_EXP 25
4812: PPUSH
4813: LD_INT 1
4815: PPUSH
4816: CALL_OW 289
4820: PUSH
4821: LD_INT 100
4823: EQUAL
4824: AND
4825: IFFALSE 4839
// ComMoveToArea ( ru_cargo , cargoa ) ;
4827: LD_EXP 25
4831: PPUSH
4832: LD_INT 10
4834: PPUSH
4835: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4839: LD_EXP 25
4843: PPUSH
4844: LD_INT 10
4846: PPUSH
4847: CALL_OW 308
4851: PUSH
4852: LD_VAR 0 8
4856: AND
4857: IFFALSE 4893
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4859: LD_VAR 0 7
4863: PPUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 9
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PPUSH
4874: CALL_OW 72
4878: PUSH
4879: LD_INT 1
4881: ARRAY
4882: PPUSH
4883: LD_INT 139
4885: PPUSH
4886: LD_INT 24
4888: PPUSH
4889: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 0
4900: EQUAL
4901: PUSH
4902: LD_VAR 0 2
4906: AND
4907: PUSH
4908: LD_VAR 0 2
4912: PPUSH
4913: CALL_OW 461
4917: PUSH
4918: LD_INT 2
4920: EQUAL
4921: AND
4922: IFFALSE 4945
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4924: LD_VAR 0 2
4928: PPUSH
4929: LD_INT 21
4931: PPUSH
4932: LD_INT 3
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 51
4940: PPUSH
4941: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4945: LD_VAR 0 7
4949: PPUSH
4950: LD_INT 25
4952: PUSH
4953: LD_INT 9
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PPUSH
4960: CALL_OW 72
4964: IFFALSE 5028
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4966: LD_VAR 0 7
4970: PPUSH
4971: LD_INT 25
4973: PUSH
4974: LD_INT 9
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: PPUSH
4981: CALL_OW 72
4985: PPUSH
4986: LD_INT 22
4988: PUSH
4989: LD_OWVAR 2
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 3
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PPUSH
5024: CALL 1656 0 2
// if ru_factory and ru_vlist > 0 then
5028: LD_VAR 0 2
5032: PUSH
5033: LD_EXP 27
5037: PUSH
5038: LD_INT 0
5040: GREATER
5041: AND
5042: IFFALSE 5142
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5044: LD_VAR 0 2
5048: PPUSH
5049: CALL_OW 461
5053: PUSH
5054: LD_INT 2
5056: EQUAL
5057: IFFALSE 5142
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5059: LD_VAR 0 2
5063: PPUSH
5064: LD_EXP 27
5068: PUSH
5069: LD_INT 1
5071: ARRAY
5072: PPUSH
5073: LD_EXP 27
5077: PUSH
5078: LD_INT 2
5080: ARRAY
5081: PPUSH
5082: LD_EXP 27
5086: PUSH
5087: LD_INT 3
5089: ARRAY
5090: PPUSH
5091: LD_EXP 27
5095: PUSH
5096: LD_INT 4
5098: ARRAY
5099: PPUSH
5100: CALL_OW 125
// for i = 1 to 4 do
5104: LD_ADDR_VAR 0 12
5108: PUSH
5109: DOUBLE
5110: LD_INT 1
5112: DEC
5113: ST_TO_ADDR
5114: LD_INT 4
5116: PUSH
5117: FOR_TO
5118: IFFALSE 5140
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5120: LD_ADDR_EXP 27
5124: PUSH
5125: LD_EXP 27
5129: PPUSH
5130: LD_INT 1
5132: PPUSH
5133: CALL_OW 3
5137: ST_TO_ADDR
5138: GO 5117
5140: POP
5141: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5142: LD_INT 24
5144: PPUSH
5145: CALL_OW 461
5149: PUSH
5150: LD_INT 2
5152: EQUAL
5153: PUSH
5154: LD_EXP 4
5158: AND
5159: IFFALSE 5187
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5161: LD_INT 25
5163: PPUSH
5164: LD_INT 3
5166: PPUSH
5167: CALL_OW 321
5171: PUSH
5172: LD_INT 1
5174: EQUAL
5175: IFFALSE 5187
// ComResearch ( ru_lab , tech_sibfiss ) ;
5177: LD_INT 24
5179: PPUSH
5180: LD_INT 25
5182: PPUSH
5183: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5187: LD_INT 25
5189: PPUSH
5190: LD_INT 3
5192: PPUSH
5193: CALL_OW 321
5197: PUSH
5198: LD_INT 2
5200: EQUAL
5201: PUSH
5202: LD_OWVAR 1
5206: PUSH
5207: LD_INT 10500
5209: MOD
5210: PUSH
5211: LD_INT 0
5213: EQUAL
5214: AND
5215: IFFALSE 5253
// if BuildingStatus ( ru_factory ) = bs_idle then
5217: LD_VAR 0 2
5221: PPUSH
5222: CALL_OW 461
5226: PUSH
5227: LD_INT 2
5229: EQUAL
5230: IFFALSE 5253
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5232: LD_VAR 0 2
5236: PPUSH
5237: LD_INT 23
5239: PPUSH
5240: LD_INT 3
5242: PPUSH
5243: LD_INT 3
5245: PPUSH
5246: LD_INT 48
5248: PPUSH
5249: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5253: LD_INT 22
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 34
5265: PUSH
5266: LD_INT 48
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: PPUSH
5277: CALL_OW 69
5281: PUSH
5282: LD_INT 0
5284: GREATER
5285: IFFALSE 5659
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5287: LD_ADDR_VAR 0 17
5291: PUSH
5292: LD_INT 22
5294: PUSH
5295: LD_INT 3
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PUSH
5302: LD_INT 34
5304: PUSH
5305: LD_INT 48
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PPUSH
5316: CALL_OW 69
5320: PUSH
5321: LD_INT 1
5323: ARRAY
5324: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5325: LD_VAR 0 17
5329: PPUSH
5330: LD_INT 9
5332: PPUSH
5333: CALL_OW 308
5337: IFFALSE 5355
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5339: LD_VAR 0 17
5343: PPUSH
5344: LD_VAR 0 3
5348: PPUSH
5349: CALL_OW 120
5353: GO 5659
// if not HasTask ( sib_bomb ) then
5355: LD_VAR 0 17
5359: PPUSH
5360: CALL_OW 314
5364: NOT
5365: IFFALSE 5659
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5367: LD_INT 22
5369: PUSH
5370: LD_OWVAR 2
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: PPUSH
5393: CALL_OW 69
5397: PUSH
5398: LD_INT 1
5400: ARRAY
5401: PPUSH
5402: CALL_OW 256
5406: PUSH
5407: LD_INT 250
5409: GREATER
5410: IFFALSE 5503
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5412: LD_VAR 0 17
5416: PPUSH
5417: LD_INT 22
5419: PUSH
5420: LD_OWVAR 2
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 1
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 250
5456: PPUSH
5457: LD_INT 22
5459: PUSH
5460: LD_OWVAR 2
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 30
5471: PUSH
5472: LD_INT 1
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PPUSH
5483: CALL_OW 69
5487: PUSH
5488: LD_INT 1
5490: ARRAY
5491: PPUSH
5492: CALL_OW 251
5496: PPUSH
5497: CALL_OW 116
5501: GO 5659
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5503: LD_INT 22
5505: PUSH
5506: LD_OWVAR 2
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PUSH
5515: LD_INT 21
5517: PUSH
5518: LD_INT 3
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL_OW 69
5533: PUSH
5534: LD_INT 0
5536: GREATER
5537: IFFALSE 5630
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5539: LD_VAR 0 17
5543: PPUSH
5544: LD_INT 22
5546: PUSH
5547: LD_OWVAR 2
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 21
5558: PUSH
5559: LD_INT 3
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 69
5574: PUSH
5575: LD_INT 1
5577: ARRAY
5578: PPUSH
5579: CALL_OW 250
5583: PPUSH
5584: LD_INT 22
5586: PUSH
5587: LD_OWVAR 2
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PUSH
5596: LD_INT 21
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: PPUSH
5610: CALL_OW 69
5614: PUSH
5615: LD_INT 1
5617: ARRAY
5618: PPUSH
5619: CALL_OW 251
5623: PPUSH
5624: CALL_OW 116
5628: GO 5659
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5630: LD_VAR 0 17
5634: PPUSH
5635: LD_EXP 10
5639: PPUSH
5640: CALL_OW 250
5644: PPUSH
5645: LD_EXP 10
5649: PPUSH
5650: CALL_OW 251
5654: PPUSH
5655: CALL_OW 116
// end ; if ru_can_attack then
5659: LD_EXP 3
5663: IFFALSE 5811
// if ru_time > 0 0$00 then
5665: LD_EXP 29
5669: PUSH
5670: LD_INT 0
5672: GREATER
5673: IFFALSE 5691
// ru_time := ru_time - 0 0$01 else
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_EXP 29
5684: PUSH
5685: LD_INT 35
5687: MINUS
5688: ST_TO_ADDR
5689: GO 5811
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5691: LD_ADDR_EXP 29
5695: PUSH
5696: LD_INT 20265
5698: PPUSH
5699: LD_INT 30765
5701: PPUSH
5702: CALL_OW 12
5706: ST_TO_ADDR
// for i = 1 to ru_amount do
5707: LD_ADDR_VAR 0 12
5711: PUSH
5712: DOUBLE
5713: LD_INT 1
5715: DEC
5716: ST_TO_ADDR
5717: LD_EXP 28
5721: PUSH
5722: FOR_TO
5723: IFFALSE 5809
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5725: LD_ADDR_EXP 27
5729: PUSH
5730: LD_EXP 27
5734: PUSH
5735: LD_INT 23
5737: ADD
5738: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5739: LD_ADDR_EXP 27
5743: PUSH
5744: LD_EXP 27
5748: PUSH
5749: LD_INT 3
5751: ADD
5752: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5753: LD_ADDR_EXP 27
5757: PUSH
5758: LD_EXP 27
5762: PUSH
5763: LD_INT 3
5765: ADD
5766: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5767: LD_ADDR_EXP 27
5771: PUSH
5772: LD_EXP 27
5776: PUSH
5777: LD_INT 46
5779: PUSH
5780: LD_INT 45
5782: PUSH
5783: LD_INT 47
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_INT 2
5796: PPUSH
5797: LD_INT 3
5799: PPUSH
5800: CALL_OW 14
5804: ARRAY
5805: ADD
5806: ST_TO_ADDR
// end ;
5807: GO 5722
5809: POP
5810: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5811: LD_VAR 0 4
5815: PPUSH
5816: LD_INT 35
5818: PUSH
5819: LD_INT 0
5821: PUSH
5822: EMPTY
5823: LIST
5824: LIST
5825: PPUSH
5826: CALL_OW 72
5830: PUSH
5831: LD_INT 0
5833: GREATER
5834: IFFALSE 5882
// if BuildingStatus ( ru_factory ) = bs_idle then
5836: LD_VAR 0 2
5840: PPUSH
5841: CALL_OW 461
5845: PUSH
5846: LD_INT 2
5848: EQUAL
5849: IFFALSE 5882
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5851: LD_VAR 0 4
5855: PPUSH
5856: LD_INT 35
5858: PUSH
5859: LD_INT 0
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PPUSH
5866: CALL_OW 72
5870: PUSH
5871: LD_INT 1
5873: ARRAY
5874: PPUSH
5875: LD_INT 47
5877: PPUSH
5878: CALL_OW 148
// if ru_force = ru_amount then
5882: LD_EXP 23
5886: PUSH
5887: LD_EXP 28
5891: EQUAL
5892: IFFALSE 6024
// begin for i = 1 to ru_force do
5894: LD_ADDR_VAR 0 12
5898: PUSH
5899: DOUBLE
5900: LD_INT 1
5902: DEC
5903: ST_TO_ADDR
5904: LD_EXP 23
5908: PUSH
5909: FOR_TO
5910: IFFALSE 6020
// if IsInArea ( ru_force [ i ] , ru_base ) then
5912: LD_EXP 23
5916: PUSH
5917: LD_VAR 0 12
5921: ARRAY
5922: PPUSH
5923: LD_INT 9
5925: PPUSH
5926: CALL_OW 308
5930: IFFALSE 5954
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5932: LD_EXP 23
5936: PUSH
5937: LD_VAR 0 12
5941: ARRAY
5942: PPUSH
5943: LD_VAR 0 3
5947: PPUSH
5948: CALL_OW 120
5952: GO 6018
// if not HasTask ( ru_force [ i ] ) then
5954: LD_EXP 23
5958: PUSH
5959: LD_VAR 0 12
5963: ARRAY
5964: PPUSH
5965: CALL_OW 314
5969: NOT
5970: IFFALSE 6018
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5972: LD_EXP 23
5976: PUSH
5977: LD_VAR 0 12
5981: ARRAY
5982: PPUSH
5983: LD_INT 81
5985: PUSH
5986: LD_INT 3
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL_OW 69
5997: PPUSH
5998: LD_EXP 23
6002: PUSH
6003: LD_VAR 0 12
6007: ARRAY
6008: PPUSH
6009: CALL_OW 74
6013: PPUSH
6014: CALL_OW 115
6018: GO 5909
6020: POP
6021: POP
// end else
6022: GO 6174
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6024: LD_EXP 23
6028: PPUSH
6029: LD_INT 3
6031: PUSH
6032: LD_INT 95
6034: PUSH
6035: LD_INT 18
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: PPUSH
6046: CALL_OW 72
6050: PUSH
6051: LD_INT 0
6053: GREATER
6054: IFFALSE 6174
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6056: LD_ADDR_VAR 0 13
6060: PUSH
6061: LD_EXP 23
6065: PPUSH
6066: LD_INT 3
6068: PUSH
6069: LD_INT 95
6071: PUSH
6072: LD_INT 18
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PPUSH
6083: CALL_OW 72
6087: ST_TO_ADDR
// for i = 1 to tmp do
6088: LD_ADDR_VAR 0 12
6092: PUSH
6093: DOUBLE
6094: LD_INT 1
6096: DEC
6097: ST_TO_ADDR
6098: LD_VAR 0 13
6102: PUSH
6103: FOR_TO
6104: IFFALSE 6172
// if not HasTask ( tmp [ i ] ) then
6106: LD_VAR 0 13
6110: PUSH
6111: LD_VAR 0 12
6115: ARRAY
6116: PPUSH
6117: CALL_OW 314
6121: NOT
6122: IFFALSE 6170
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6124: LD_EXP 23
6128: PUSH
6129: LD_VAR 0 12
6133: ARRAY
6134: PPUSH
6135: LD_INT 81
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PPUSH
6145: CALL_OW 69
6149: PPUSH
6150: LD_EXP 23
6154: PUSH
6155: LD_VAR 0 12
6159: ARRAY
6160: PPUSH
6161: CALL_OW 74
6165: PPUSH
6166: CALL_OW 115
6170: GO 6103
6172: POP
6173: POP
// end ; if ru_engs > 0 then
6174: LD_VAR 0 9
6178: PUSH
6179: LD_INT 0
6181: GREATER
6182: IFFALSE 6584
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6184: LD_VAR 0 5
6188: PPUSH
6189: LD_INT 3
6191: PUSH
6192: LD_INT 24
6194: PUSH
6195: LD_INT 1000
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL_OW 72
6210: PUSH
6211: LD_INT 0
6213: GREATER
6214: IFFALSE 6369
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6216: LD_ADDR_VAR 0 14
6220: PUSH
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_INT 3
6228: PUSH
6229: LD_INT 24
6231: PUSH
6232: LD_INT 1000
6234: PUSH
6235: EMPTY
6236: LIST
6237: LIST
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PPUSH
6243: CALL_OW 72
6247: ST_TO_ADDR
// for i = 1 to ru_engs do
6248: LD_ADDR_VAR 0 12
6252: PUSH
6253: DOUBLE
6254: LD_INT 1
6256: DEC
6257: ST_TO_ADDR
6258: LD_VAR 0 9
6262: PUSH
6263: FOR_TO
6264: IFFALSE 6365
// begin if IsInUnit ( ru_engs [ i ] ) then
6266: LD_VAR 0 9
6270: PUSH
6271: LD_VAR 0 12
6275: ARRAY
6276: PPUSH
6277: CALL_OW 310
6281: IFFALSE 6300
// ComExitBuilding ( ru_engs [ i ] ) else
6283: LD_VAR 0 9
6287: PUSH
6288: LD_VAR 0 12
6292: ARRAY
6293: PPUSH
6294: CALL_OW 122
6298: GO 6363
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6300: LD_VAR 0 9
6304: PUSH
6305: LD_VAR 0 12
6309: ARRAY
6310: PPUSH
6311: CALL_OW 314
6315: NOT
6316: PUSH
6317: LD_VAR 0 9
6321: PUSH
6322: LD_VAR 0 12
6326: ARRAY
6327: PPUSH
6328: CALL_OW 256
6332: PUSH
6333: LD_INT 600
6335: GREATER
6336: AND
6337: IFFALSE 6363
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6339: LD_VAR 0 9
6343: PUSH
6344: LD_VAR 0 12
6348: ARRAY
6349: PPUSH
6350: LD_VAR 0 14
6354: PUSH
6355: LD_INT 1
6357: ARRAY
6358: PPUSH
6359: CALL_OW 130
// end ;
6363: GO 6263
6365: POP
6366: POP
// end else
6367: GO 6584
// begin if ru_blist = 0 then
6369: LD_EXP 26
6373: PUSH
6374: LD_INT 0
6376: EQUAL
6377: IFFALSE 6459
// begin for i = 1 to ru_engs do
6379: LD_ADDR_VAR 0 12
6383: PUSH
6384: DOUBLE
6385: LD_INT 1
6387: DEC
6388: ST_TO_ADDR
6389: LD_VAR 0 9
6393: PUSH
6394: FOR_TO
6395: IFFALSE 6455
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6397: LD_VAR 0 9
6401: PUSH
6402: LD_VAR 0 12
6406: ARRAY
6407: PPUSH
6408: CALL_OW 314
6412: NOT
6413: PUSH
6414: LD_VAR 0 9
6418: PUSH
6419: LD_VAR 0 12
6423: ARRAY
6424: PPUSH
6425: CALL_OW 310
6429: NOT
6430: AND
6431: IFFALSE 6453
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6433: LD_VAR 0 9
6437: PUSH
6438: LD_VAR 0 12
6442: ARRAY
6443: PPUSH
6444: LD_VAR 0 1
6448: PPUSH
6449: CALL_OW 120
6453: GO 6394
6455: POP
6456: POP
// end else
6457: GO 6584
// begin for i = 1 to ru_engs do
6459: LD_ADDR_VAR 0 12
6463: PUSH
6464: DOUBLE
6465: LD_INT 1
6467: DEC
6468: ST_TO_ADDR
6469: LD_VAR 0 9
6473: PUSH
6474: FOR_TO
6475: IFFALSE 6582
// begin if IsInUnit ( ru_engs [ i ] ) then
6477: LD_VAR 0 9
6481: PUSH
6482: LD_VAR 0 12
6486: ARRAY
6487: PPUSH
6488: CALL_OW 310
6492: IFFALSE 6511
// ComExitBuilding ( ru_engs [ i ] ) else
6494: LD_VAR 0 9
6498: PUSH
6499: LD_VAR 0 12
6503: ARRAY
6504: PPUSH
6505: CALL_OW 122
6509: GO 6580
// if not HasTask ( ru_engs [ i ] ) then
6511: LD_VAR 0 9
6515: PUSH
6516: LD_VAR 0 12
6520: ARRAY
6521: PPUSH
6522: CALL_OW 314
6526: NOT
6527: IFFALSE 6580
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6529: LD_VAR 0 9
6533: PUSH
6534: LD_VAR 0 12
6538: ARRAY
6539: PPUSH
6540: LD_EXP 26
6544: PUSH
6545: LD_INT 1
6547: ARRAY
6548: PPUSH
6549: LD_EXP 26
6553: PUSH
6554: LD_INT 2
6556: ARRAY
6557: PPUSH
6558: LD_EXP 26
6562: PUSH
6563: LD_INT 3
6565: ARRAY
6566: PPUSH
6567: LD_EXP 26
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PPUSH
6576: CALL_OW 145
// end ;
6580: GO 6474
6582: POP
6583: POP
// end ; end ; end ; end ;
6584: PPOPN 17
6586: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6587: LD_EXP 2
6591: PUSH
6592: LD_INT 11
6594: PPUSH
6595: CALL_OW 435
6599: PUSH
6600: LD_INT 20
6602: LESS
6603: AND
6604: IFFALSE 6667
6606: GO 6608
6608: DISABLE
// begin enable ;
6609: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 5
6615: PPUSH
6616: CALL_OW 12
6620: PPUSH
6621: LD_INT 11
6623: PPUSH
6624: LD_INT 1
6626: PPUSH
6627: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6631: LD_INT 1505
6633: PPUSH
6634: LD_INT 2100
6636: PPUSH
6637: CALL_OW 12
6641: PPUSH
6642: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6646: LD_INT 1
6648: PPUSH
6649: LD_INT 5
6651: PPUSH
6652: CALL_OW 12
6656: PPUSH
6657: LD_INT 11
6659: PPUSH
6660: LD_INT 1
6662: PPUSH
6663: CALL_OW 55
// end ;
6667: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6668: LD_EXP 4
6672: PUSH
6673: LD_INT 0
6675: EQUAL
6676: IFFALSE 6791
6678: GO 6680
6680: DISABLE
6681: LD_INT 0
6683: PPUSH
6684: PPUSH
// begin enable ;
6685: ENABLE
// i := Rand ( 0 , 100 ) ;
6686: LD_ADDR_VAR 0 1
6690: PUSH
6691: LD_INT 0
6693: PPUSH
6694: LD_INT 100
6696: PPUSH
6697: CALL_OW 12
6701: ST_TO_ADDR
// case your_side of 1 :
6702: LD_OWVAR 2
6706: PUSH
6707: LD_INT 1
6709: DOUBLE
6710: EQUAL
6711: IFTRUE 6715
6713: GO 6726
6715: POP
// tmp := 10 ; 2 :
6716: LD_ADDR_VAR 0 2
6720: PUSH
6721: LD_INT 10
6723: ST_TO_ADDR
6724: GO 6765
6726: LD_INT 2
6728: DOUBLE
6729: EQUAL
6730: IFTRUE 6734
6732: GO 6745
6734: POP
// tmp := 0 ; 7 :
6735: LD_ADDR_VAR 0 2
6739: PUSH
6740: LD_INT 0
6742: ST_TO_ADDR
6743: GO 6765
6745: LD_INT 7
6747: DOUBLE
6748: EQUAL
6749: IFTRUE 6753
6751: GO 6764
6753: POP
// tmp := 15 ; end ;
6754: LD_ADDR_VAR 0 2
6758: PUSH
6759: LD_INT 15
6761: ST_TO_ADDR
6762: GO 6765
6764: POP
// if i < chance_to_bomb + tmp then
6765: LD_VAR 0 1
6769: PUSH
6770: LD_EXP 5
6774: PUSH
6775: LD_VAR 0 2
6779: PLUS
6780: LESS
6781: IFFALSE 6791
// ru_sib_bomb := true ;
6783: LD_ADDR_EXP 4
6787: PUSH
6788: LD_INT 1
6790: ST_TO_ADDR
// end ;
6791: PPOPN 2
6793: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6794: LD_INT 22
6796: PUSH
6797: LD_OWVAR 2
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: PUSH
6806: LD_INT 34
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PPUSH
6820: CALL_OW 69
6824: IFFALSE 6837
6826: GO 6828
6828: DISABLE
// begin ru_sib_bomb := true ;
6829: LD_ADDR_EXP 4
6833: PUSH
6834: LD_INT 1
6836: ST_TO_ADDR
// end ;
6837: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6838: LD_INT 22
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PUSH
6848: LD_INT 30
6850: PUSH
6851: LD_INT 34
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PPUSH
6862: CALL_OW 69
6866: IFFALSE 6965
6868: GO 6870
6870: DISABLE
6871: LD_INT 0
6873: PPUSH
// begin enable ;
6874: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6875: LD_ADDR_VAR 0 1
6879: PUSH
6880: LD_INT 1
6882: PUSH
6883: LD_INT 3
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 1
6892: PPUSH
6893: LD_INT 2
6895: PPUSH
6896: CALL_OW 12
6900: ARRAY
6901: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6902: LD_INT 22
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PUSH
6912: LD_INT 30
6914: PUSH
6915: LD_INT 34
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PPUSH
6926: CALL_OW 69
6930: PUSH
6931: LD_INT 1
6933: ARRAY
6934: PPUSH
6935: LD_EXP 30
6939: PUSH
6940: LD_VAR 0 1
6944: ARRAY
6945: PPUSH
6946: LD_EXP 30
6950: PUSH
6951: LD_VAR 0 1
6955: PUSH
6956: LD_INT 1
6958: PLUS
6959: ARRAY
6960: PPUSH
6961: CALL_OW 243
// end ; end_of_file
6965: PPOPN 1
6967: END
// export function RemoveLegion ; var i ; begin
6968: LD_INT 0
6970: PPUSH
6971: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: LD_INT 22
6979: PUSH
6980: LD_INT 8
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: PPUSH
6987: CALL_OW 69
6991: PUSH
6992: FOR_IN
6993: IFFALSE 7006
// RemoveUnit ( i ) ;
6995: LD_VAR 0 2
6999: PPUSH
7000: CALL_OW 64
7004: GO 6992
7006: POP
7007: POP
// end ;
7008: LD_VAR 0 1
7012: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7013: LD_INT 0
7015: PPUSH
7016: PPUSH
7017: PPUSH
7018: PPUSH
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7025: LD_ADDR_VAR 0 7
7029: PUSH
7030: LD_INT 22
7032: PUSH
7033: LD_INT 8
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 30
7042: PUSH
7043: LD_INT 1
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PPUSH
7054: CALL_OW 69
7058: PUSH
7059: LD_INT 1
7061: ARRAY
7062: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7063: LD_ADDR_VAR 0 8
7067: PUSH
7068: LD_INT 22
7070: PUSH
7071: LD_INT 8
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PUSH
7078: LD_INT 30
7080: PUSH
7081: LD_INT 3
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PPUSH
7092: CALL_OW 69
7096: PUSH
7097: LD_INT 1
7099: ARRAY
7100: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7101: LD_ADDR_VAR 0 9
7105: PUSH
7106: LD_INT 22
7108: PUSH
7109: LD_INT 8
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 2
7118: PUSH
7119: LD_INT 30
7121: PUSH
7122: LD_INT 6
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 30
7131: PUSH
7132: LD_INT 8
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: PUSH
7153: LD_INT 1
7155: ARRAY
7156: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7157: LD_ADDR_VAR 0 10
7161: PUSH
7162: LD_INT 22
7164: PUSH
7165: LD_INT 8
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 30
7174: PUSH
7175: LD_INT 32
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: ST_TO_ADDR
// uc_side := 8 ;
7191: LD_ADDR_OWVAR 20
7195: PUSH
7196: LD_INT 8
7198: ST_TO_ADDR
// uc_nation := nation_arabian ;
7199: LD_ADDR_OWVAR 21
7203: PUSH
7204: LD_INT 2
7206: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7207: LD_ADDR_EXP 32
7211: PUSH
7212: LD_INT 5
7214: PUSH
7215: LD_INT 6
7217: PUSH
7218: LD_INT 7
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_OWVAR 67
7230: ARRAY
7231: ST_TO_ADDR
// legion_blist := [ ] ;
7232: LD_ADDR_EXP 34
7236: PUSH
7237: EMPTY
7238: ST_TO_ADDR
// legion_vlist := [ ] ;
7239: LD_ADDR_EXP 35
7243: PUSH
7244: EMPTY
7245: ST_TO_ADDR
// legion_force := [ ] ;
7246: LD_ADDR_EXP 31
7250: PUSH
7251: EMPTY
7252: ST_TO_ADDR
// legion_enemy := - 1 ;
7253: LD_ADDR_EXP 36
7257: PUSH
7258: LD_INT 1
7260: NEG
7261: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7262: LD_VAR 0 7
7266: PPUSH
7267: CALL_OW 274
7271: PPUSH
7272: LD_INT 1
7274: PPUSH
7275: LD_INT 10000
7277: PPUSH
7278: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7282: LD_VAR 0 7
7286: PPUSH
7287: CALL_OW 274
7291: PPUSH
7292: LD_INT 3
7294: PPUSH
7295: LD_INT 1000
7297: PPUSH
7298: CALL_OW 277
// for i = 1 to l_towers do
7302: LD_ADDR_VAR 0 3
7306: PUSH
7307: DOUBLE
7308: LD_INT 1
7310: DEC
7311: ST_TO_ADDR
7312: LD_VAR 0 10
7316: PUSH
7317: FOR_TO
7318: IFFALSE 7367
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7320: LD_INT 0
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_EXP 32
7330: PPUSH
7331: CALL_OW 380
// un := CreateHuman ;
7335: LD_ADDR_VAR 0 2
7339: PUSH
7340: CALL_OW 44
7344: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7345: LD_VAR 0 2
7349: PPUSH
7350: LD_VAR 0 10
7354: PUSH
7355: LD_VAR 0 3
7359: ARRAY
7360: PPUSH
7361: CALL_OW 52
// end ;
7365: GO 7317
7367: POP
7368: POP
// for i = 1 to 4 do
7369: LD_ADDR_VAR 0 3
7373: PUSH
7374: DOUBLE
7375: LD_INT 1
7377: DEC
7378: ST_TO_ADDR
7379: LD_INT 4
7381: PUSH
7382: FOR_TO
7383: IFFALSE 7476
// for p = 1 to 2 do
7385: LD_ADDR_VAR 0 6
7389: PUSH
7390: DOUBLE
7391: LD_INT 1
7393: DEC
7394: ST_TO_ADDR
7395: LD_INT 2
7397: PUSH
7398: FOR_TO
7399: IFFALSE 7472
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7401: LD_INT 0
7403: PPUSH
7404: LD_INT 8
7406: PPUSH
7407: LD_EXP 32
7411: PPUSH
7412: CALL_OW 380
// un := CreateHuman ;
7416: LD_ADDR_VAR 0 2
7420: PUSH
7421: CALL_OW 44
7425: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7426: LD_VAR 0 2
7430: PPUSH
7431: LD_INT 22
7433: PUSH
7434: LD_INT 8
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PUSH
7441: LD_INT 30
7443: PUSH
7444: LD_INT 5
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PPUSH
7455: CALL_OW 69
7459: PUSH
7460: LD_VAR 0 6
7464: ARRAY
7465: PPUSH
7466: CALL_OW 52
// end ;
7470: GO 7398
7472: POP
7473: POP
7474: GO 7382
7476: POP
7477: POP
// for i = 1 to 4 do
7478: LD_ADDR_VAR 0 3
7482: PUSH
7483: DOUBLE
7484: LD_INT 1
7486: DEC
7487: ST_TO_ADDR
7488: LD_INT 4
7490: PUSH
7491: FOR_TO
7492: IFFALSE 7535
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7494: LD_INT 0
7496: PPUSH
7497: LD_INT 4
7499: PPUSH
7500: LD_EXP 32
7504: PPUSH
7505: CALL_OW 380
// un := CreateHuman ;
7509: LD_ADDR_VAR 0 2
7513: PUSH
7514: CALL_OW 44
7518: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7519: LD_VAR 0 2
7523: PPUSH
7524: LD_VAR 0 9
7528: PPUSH
7529: CALL_OW 52
// end ;
7533: GO 7491
7535: POP
7536: POP
// for i = 1 to 6 do
7537: LD_ADDR_VAR 0 3
7541: PUSH
7542: DOUBLE
7543: LD_INT 1
7545: DEC
7546: ST_TO_ADDR
7547: LD_INT 6
7549: PUSH
7550: FOR_TO
7551: IFFALSE 7594
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 3
7558: PPUSH
7559: LD_EXP 32
7563: PPUSH
7564: CALL_OW 380
// un := CreateHuman ;
7568: LD_ADDR_VAR 0 2
7572: PUSH
7573: CALL_OW 44
7577: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7578: LD_VAR 0 2
7582: PPUSH
7583: LD_VAR 0 8
7587: PPUSH
7588: CALL_OW 52
// end ;
7592: GO 7550
7594: POP
7595: POP
// for i = 1 to 5 do
7596: LD_ADDR_VAR 0 3
7600: PUSH
7601: DOUBLE
7602: LD_INT 1
7604: DEC
7605: ST_TO_ADDR
7606: LD_INT 5
7608: PUSH
7609: FOR_TO
7610: IFFALSE 7653
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7612: LD_INT 0
7614: PPUSH
7615: LD_INT 2
7617: PPUSH
7618: LD_EXP 32
7622: PPUSH
7623: CALL_OW 380
// un := CreateHuman ;
7627: LD_ADDR_VAR 0 2
7631: PUSH
7632: CALL_OW 44
7636: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7637: LD_VAR 0 2
7641: PPUSH
7642: LD_VAR 0 7
7646: PPUSH
7647: CALL_OW 52
// end ;
7651: GO 7609
7653: POP
7654: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7655: LD_ADDR_VAR 0 4
7659: PUSH
7660: LD_INT 199
7662: PPUSH
7663: LD_INT 134
7665: PPUSH
7666: LD_INT 216
7668: PPUSH
7669: LD_INT 141
7671: PPUSH
7672: LD_INT 6
7674: PPUSH
7675: CALL 1555 0 5
7679: ST_TO_ADDR
// p := 1 ;
7680: LD_ADDR_VAR 0 6
7684: PUSH
7685: LD_INT 1
7687: ST_TO_ADDR
// for i = 1 to 3 do
7688: LD_ADDR_VAR 0 3
7692: PUSH
7693: DOUBLE
7694: LD_INT 1
7696: DEC
7697: ST_TO_ADDR
7698: LD_INT 3
7700: PUSH
7701: FOR_TO
7702: IFFALSE 7955
// begin vc_chassis := ar_half_tracked ;
7704: LD_ADDR_OWVAR 37
7708: PUSH
7709: LD_INT 14
7711: ST_TO_ADDR
// vc_engine := engine_siberite ;
7712: LD_ADDR_OWVAR 39
7716: PUSH
7717: LD_INT 3
7719: ST_TO_ADDR
// vc_control := control_manual ;
7720: LD_ADDR_OWVAR 38
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7728: LD_ADDR_OWVAR 40
7732: PUSH
7733: LD_INT 31
7735: ST_TO_ADDR
// veh := CreateVehicle ;
7736: LD_ADDR_VAR 0 5
7740: PUSH
7741: CALL_OW 45
7745: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7746: LD_VAR 0 4
7750: PUSH
7751: LD_VAR 0 6
7755: ARRAY
7756: PPUSH
7757: LD_VAR 0 4
7761: PUSH
7762: LD_VAR 0 6
7766: PUSH
7767: LD_INT 1
7769: PLUS
7770: ARRAY
7771: PPUSH
7772: CALL_OW 428
7776: PUSH
7777: LD_INT 0
7779: EQUAL
7780: IFFALSE 7822
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7782: LD_VAR 0 5
7786: PPUSH
7787: LD_VAR 0 4
7791: PUSH
7792: LD_VAR 0 6
7796: ARRAY
7797: PPUSH
7798: LD_VAR 0 4
7802: PUSH
7803: LD_VAR 0 6
7807: PUSH
7808: LD_INT 1
7810: PLUS
7811: ARRAY
7812: PPUSH
7813: LD_INT 0
7815: PPUSH
7816: CALL_OW 48
7820: GO 7910
// begin repeat p := p + 2 ;
7822: LD_ADDR_VAR 0 6
7826: PUSH
7827: LD_VAR 0 6
7831: PUSH
7832: LD_INT 2
7834: PLUS
7835: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7836: LD_VAR 0 4
7840: PUSH
7841: LD_VAR 0 6
7845: ARRAY
7846: PPUSH
7847: LD_VAR 0 4
7851: PUSH
7852: LD_VAR 0 6
7856: PUSH
7857: LD_INT 1
7859: PLUS
7860: ARRAY
7861: PPUSH
7862: CALL_OW 428
7866: PUSH
7867: LD_INT 0
7869: EQUAL
7870: IFFALSE 7822
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7872: LD_VAR 0 5
7876: PPUSH
7877: LD_VAR 0 4
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_VAR 0 4
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ARRAY
7902: PPUSH
7903: LD_INT 0
7905: PPUSH
7906: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7910: LD_INT 0
7912: PPUSH
7913: LD_INT 3
7915: PPUSH
7916: LD_EXP 32
7920: PUSH
7921: LD_INT 1
7923: PLUS
7924: PPUSH
7925: CALL_OW 380
// un := CreateHuman ;
7929: LD_ADDR_VAR 0 2
7933: PUSH
7934: CALL_OW 44
7938: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7939: LD_VAR 0 2
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 52
// end ;
7953: GO 7701
7955: POP
7956: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7957: LD_INT 198
7959: PPUSH
7960: LD_INT 94
7962: PPUSH
7963: LD_INT 8
7965: PPUSH
7966: LD_INT 10
7968: PPUSH
7969: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7973: LD_INT 167
7975: PPUSH
7976: LD_INT 130
7978: PPUSH
7979: LD_INT 8
7981: PPUSH
7982: LD_INT 10
7984: PPUSH
7985: CALL_OW 330
// legion_mines := [ ] ;
7989: LD_ADDR_EXP 33
7993: PUSH
7994: EMPTY
7995: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
7996: LD_ADDR_EXP 33
8000: PUSH
8001: LD_INT 176
8003: PPUSH
8004: LD_INT 122
8006: PPUSH
8007: LD_INT 188
8009: PPUSH
8010: LD_INT 126
8012: PPUSH
8013: LD_INT 6
8015: PPUSH
8016: CALL 1555 0 5
8020: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8021: LD_ADDR_EXP 33
8025: PUSH
8026: LD_EXP 33
8030: PUSH
8031: LD_INT 197
8033: PPUSH
8034: LD_INT 91
8036: PPUSH
8037: LD_INT 205
8039: PPUSH
8040: LD_INT 96
8042: PPUSH
8043: LD_INT 4
8045: PPUSH
8046: CALL 1555 0 5
8050: ADD
8051: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8052: LD_ADDR_EXP 33
8056: PUSH
8057: LD_EXP 33
8061: PUSH
8062: LD_INT 184
8064: PPUSH
8065: LD_INT 151
8067: PPUSH
8068: LD_INT 178
8070: PPUSH
8071: LD_INT 130
8073: PPUSH
8074: LD_INT 9
8076: PPUSH
8077: CALL 1555 0 5
8081: ADD
8082: ST_TO_ADDR
// if Difficulty > 1 then
8083: LD_OWVAR 67
8087: PUSH
8088: LD_INT 1
8090: GREATER
8091: IFFALSE 8124
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8093: LD_ADDR_EXP 33
8097: PUSH
8098: LD_EXP 33
8102: PUSH
8103: LD_INT 166
8105: PPUSH
8106: LD_INT 126
8108: PPUSH
8109: LD_INT 181
8111: PPUSH
8112: LD_INT 136
8114: PPUSH
8115: LD_INT 5
8117: PPUSH
8118: CALL 1555 0 5
8122: ADD
8123: ST_TO_ADDR
// p := 1 ;
8124: LD_ADDR_VAR 0 6
8128: PUSH
8129: LD_INT 1
8131: ST_TO_ADDR
// for i = 1 to 24 do
8132: LD_ADDR_VAR 0 3
8136: PUSH
8137: DOUBLE
8138: LD_INT 1
8140: DEC
8141: ST_TO_ADDR
8142: LD_INT 24
8144: PUSH
8145: FOR_TO
8146: IFFALSE 8200
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8148: LD_EXP 33
8152: PUSH
8153: LD_VAR 0 6
8157: ARRAY
8158: PPUSH
8159: LD_EXP 33
8163: PUSH
8164: LD_VAR 0 6
8168: PUSH
8169: LD_INT 1
8171: PLUS
8172: ARRAY
8173: PPUSH
8174: LD_INT 8
8176: PPUSH
8177: LD_INT 0
8179: PPUSH
8180: CALL_OW 454
// p := p + 2 ;
8184: LD_ADDR_VAR 0 6
8188: PUSH
8189: LD_VAR 0 6
8193: PUSH
8194: LD_INT 2
8196: PLUS
8197: ST_TO_ADDR
// end ;
8198: GO 8145
8200: POP
8201: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8202: LD_ADDR_EXP 35
8206: PUSH
8207: LD_INT 13
8209: PUSH
8210: LD_INT 3
8212: PUSH
8213: LD_INT 2
8215: PUSH
8216: LD_INT 32
8218: PUSH
8219: EMPTY
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: ST_TO_ADDR
// end ;
8225: LD_VAR 0 1
8229: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8230: LD_INT 22
8232: PUSH
8233: LD_INT 8
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PPUSH
8240: CALL_OW 69
8244: PUSH
8245: LD_INT 0
8247: GREATER
8248: IFFALSE 10434
8250: GO 8252
8252: DISABLE
8253: LD_INT 0
8255: PPUSH
8256: PPUSH
8257: PPUSH
8258: PPUSH
8259: PPUSH
8260: PPUSH
8261: PPUSH
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
// begin enable ;
8272: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8273: LD_ADDR_VAR 0 8
8277: PUSH
8278: LD_INT 22
8280: PUSH
8281: LD_INT 8
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 30
8290: PUSH
8291: LD_INT 1
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PPUSH
8302: CALL_OW 69
8306: PUSH
8307: LD_INT 1
8309: ARRAY
8310: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8311: LD_ADDR_VAR 0 9
8315: PUSH
8316: LD_INT 22
8318: PUSH
8319: LD_INT 8
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PUSH
8326: LD_INT 30
8328: PUSH
8329: LD_INT 3
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PPUSH
8340: CALL_OW 69
8344: PUSH
8345: LD_INT 1
8347: ARRAY
8348: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8349: LD_ADDR_VAR 0 10
8353: PUSH
8354: LD_INT 22
8356: PUSH
8357: LD_INT 8
8359: PUSH
8360: EMPTY
8361: LIST
8362: LIST
8363: PUSH
8364: LD_INT 2
8366: PUSH
8367: LD_INT 30
8369: PUSH
8370: LD_INT 6
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: LD_INT 30
8379: PUSH
8380: LD_INT 8
8382: PUSH
8383: EMPTY
8384: LIST
8385: LIST
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: PPUSH
8396: CALL_OW 69
8400: PUSH
8401: LD_INT 1
8403: ARRAY
8404: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8405: LD_ADDR_VAR 0 11
8409: PUSH
8410: LD_INT 22
8412: PUSH
8413: LD_INT 8
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 30
8422: PUSH
8423: LD_INT 32
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PPUSH
8434: CALL_OW 69
8438: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8439: LD_ADDR_VAR 0 16
8443: PUSH
8444: LD_INT 22
8446: PUSH
8447: LD_INT 8
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PUSH
8454: LD_INT 25
8456: PUSH
8457: LD_INT 2
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: PPUSH
8468: CALL_OW 69
8472: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8473: LD_ADDR_VAR 0 15
8477: PUSH
8478: LD_INT 22
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 25
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8507: LD_ADDR_VAR 0 14
8511: PUSH
8512: LD_INT 22
8514: PUSH
8515: LD_INT 8
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 25
8524: PUSH
8525: LD_INT 3
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PUSH
8532: EMPTY
8533: LIST
8534: LIST
8535: PPUSH
8536: CALL_OW 69
8540: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8541: LD_ADDR_VAR 0 13
8545: PUSH
8546: LD_INT 22
8548: PUSH
8549: LD_INT 8
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PUSH
8556: LD_INT 25
8558: PUSH
8559: LD_INT 4
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 69
8574: ST_TO_ADDR
// if l_eng then
8575: LD_VAR 0 16
8579: IFFALSE 8994
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8581: LD_ADDR_VAR 0 5
8585: PUSH
8586: LD_INT 22
8588: PUSH
8589: LD_INT 8
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: LD_INT 21
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PPUSH
8610: CALL_OW 69
8614: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8615: LD_VAR 0 5
8619: PPUSH
8620: LD_INT 3
8622: PUSH
8623: LD_INT 24
8625: PUSH
8626: LD_INT 1000
8628: PUSH
8629: EMPTY
8630: LIST
8631: LIST
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PPUSH
8637: CALL_OW 72
8641: PUSH
8642: LD_INT 0
8644: GREATER
8645: IFFALSE 8779
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8647: LD_ADDR_VAR 0 3
8651: PUSH
8652: LD_VAR 0 5
8656: PPUSH
8657: LD_INT 3
8659: PUSH
8660: LD_INT 24
8662: PUSH
8663: LD_INT 1000
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PPUSH
8674: CALL_OW 72
8678: ST_TO_ADDR
// for i = 1 to l_eng do
8679: LD_ADDR_VAR 0 2
8683: PUSH
8684: DOUBLE
8685: LD_INT 1
8687: DEC
8688: ST_TO_ADDR
8689: LD_VAR 0 16
8693: PUSH
8694: FOR_TO
8695: IFFALSE 8775
// if IsInUnit ( l_eng [ i ] ) then
8697: LD_VAR 0 16
8701: PUSH
8702: LD_VAR 0 2
8706: ARRAY
8707: PPUSH
8708: CALL_OW 310
8712: IFFALSE 8731
// ComExitBuilding ( l_eng [ i ] ) else
8714: LD_VAR 0 16
8718: PUSH
8719: LD_VAR 0 2
8723: ARRAY
8724: PPUSH
8725: CALL_OW 122
8729: GO 8773
// if not HasTask ( l_eng [ i ] ) then
8731: LD_VAR 0 16
8735: PUSH
8736: LD_VAR 0 2
8740: ARRAY
8741: PPUSH
8742: CALL_OW 314
8746: NOT
8747: IFFALSE 8773
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8749: LD_VAR 0 16
8753: PUSH
8754: LD_VAR 0 2
8758: ARRAY
8759: PPUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 1
8767: ARRAY
8768: PPUSH
8769: CALL_OW 130
8773: GO 8694
8775: POP
8776: POP
// end else
8777: GO 8994
// begin if legion_blist > 0 then
8779: LD_EXP 34
8783: PUSH
8784: LD_INT 0
8786: GREATER
8787: IFFALSE 8916
// begin for i = 1 to l_eng do
8789: LD_ADDR_VAR 0 2
8793: PUSH
8794: DOUBLE
8795: LD_INT 1
8797: DEC
8798: ST_TO_ADDR
8799: LD_VAR 0 16
8803: PUSH
8804: FOR_TO
8805: IFFALSE 8912
// if IsInUnit ( l_eng [ i ] ) then
8807: LD_VAR 0 16
8811: PUSH
8812: LD_VAR 0 2
8816: ARRAY
8817: PPUSH
8818: CALL_OW 310
8822: IFFALSE 8841
// ComExitBuilding ( l_eng [ i ] ) else
8824: LD_VAR 0 16
8828: PUSH
8829: LD_VAR 0 2
8833: ARRAY
8834: PPUSH
8835: CALL_OW 122
8839: GO 8910
// if not HasTask ( l_eng [ i ] ) then
8841: LD_VAR 0 16
8845: PUSH
8846: LD_VAR 0 2
8850: ARRAY
8851: PPUSH
8852: CALL_OW 314
8856: NOT
8857: IFFALSE 8910
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8859: LD_VAR 0 16
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: PPUSH
8870: LD_EXP 34
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: LD_EXP 34
8883: PUSH
8884: LD_INT 2
8886: ARRAY
8887: PPUSH
8888: LD_EXP 34
8892: PUSH
8893: LD_INT 3
8895: ARRAY
8896: PPUSH
8897: LD_EXP 34
8901: PUSH
8902: LD_INT 4
8904: ARRAY
8905: PPUSH
8906: CALL_OW 145
8910: GO 8804
8912: POP
8913: POP
// end else
8914: GO 8994
// for i = 1 to l_eng do
8916: LD_ADDR_VAR 0 2
8920: PUSH
8921: DOUBLE
8922: LD_INT 1
8924: DEC
8925: ST_TO_ADDR
8926: LD_VAR 0 16
8930: PUSH
8931: FOR_TO
8932: IFFALSE 8992
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8934: LD_VAR 0 16
8938: PUSH
8939: LD_VAR 0 2
8943: ARRAY
8944: PPUSH
8945: CALL_OW 310
8949: NOT
8950: PUSH
8951: LD_VAR 0 16
8955: PUSH
8956: LD_VAR 0 2
8960: ARRAY
8961: PPUSH
8962: CALL_OW 314
8966: NOT
8967: AND
8968: IFFALSE 8990
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8970: LD_VAR 0 16
8974: PUSH
8975: LD_VAR 0 2
8979: ARRAY
8980: PPUSH
8981: LD_VAR 0 8
8985: PPUSH
8986: CALL_OW 120
8990: GO 8931
8992: POP
8993: POP
// end ; end ; if l_factory then
8994: LD_VAR 0 9
8998: IFFALSE 9398
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9000: LD_INT 22
9002: PUSH
9003: LD_INT 8
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: LD_INT 33
9012: PUSH
9013: LD_INT 2
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: LD_INT 3
9022: PUSH
9023: LD_INT 61
9025: PUSH
9026: EMPTY
9027: LIST
9028: PUSH
9029: EMPTY
9030: LIST
9031: LIST
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: PPUSH
9038: CALL_OW 69
9042: PUSH
9043: LD_INT 0
9045: GREATER
9046: PUSH
9047: LD_INT 22
9049: PUSH
9050: LD_INT 8
9052: PUSH
9053: EMPTY
9054: LIST
9055: LIST
9056: PUSH
9057: LD_INT 34
9059: PUSH
9060: LD_INT 31
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PPUSH
9071: CALL_OW 69
9075: PUSH
9076: LD_INT 0
9078: GREATER
9079: AND
9080: IFFALSE 9200
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9082: LD_INT 22
9084: PUSH
9085: LD_INT 8
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 33
9094: PUSH
9095: LD_INT 2
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 3
9104: PUSH
9105: LD_INT 61
9107: PUSH
9108: EMPTY
9109: LIST
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: LIST
9119: PPUSH
9120: CALL_OW 69
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: LD_INT 22
9131: PUSH
9132: LD_INT 8
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PUSH
9139: LD_INT 34
9141: PUSH
9142: LD_INT 31
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PUSH
9149: EMPTY
9150: LIST
9151: LIST
9152: PPUSH
9153: CALL_OW 69
9157: PUSH
9158: LD_INT 1
9160: PPUSH
9161: LD_INT 22
9163: PUSH
9164: LD_INT 8
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: PUSH
9171: LD_INT 34
9173: PUSH
9174: LD_INT 31
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PPUSH
9185: CALL_OW 69
9189: PPUSH
9190: CALL_OW 12
9194: ARRAY
9195: PPUSH
9196: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9200: LD_EXP 35
9204: PUSH
9205: LD_INT 0
9207: GREATER
9208: PUSH
9209: LD_VAR 0 9
9213: PPUSH
9214: CALL_OW 461
9218: PUSH
9219: LD_INT 2
9221: EQUAL
9222: AND
9223: IFFALSE 9308
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9225: LD_VAR 0 9
9229: PPUSH
9230: LD_EXP 35
9234: PUSH
9235: LD_INT 1
9237: ARRAY
9238: PPUSH
9239: LD_EXP 35
9243: PUSH
9244: LD_INT 2
9246: ARRAY
9247: PPUSH
9248: LD_EXP 35
9252: PUSH
9253: LD_INT 3
9255: ARRAY
9256: PPUSH
9257: LD_EXP 35
9261: PUSH
9262: LD_INT 4
9264: ARRAY
9265: PPUSH
9266: CALL_OW 125
// for i = 1 to 4 do
9270: LD_ADDR_VAR 0 2
9274: PUSH
9275: DOUBLE
9276: LD_INT 1
9278: DEC
9279: ST_TO_ADDR
9280: LD_INT 4
9282: PUSH
9283: FOR_TO
9284: IFFALSE 9306
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9286: LD_ADDR_EXP 35
9290: PUSH
9291: LD_EXP 35
9295: PPUSH
9296: LD_INT 1
9298: PPUSH
9299: CALL_OW 3
9303: ST_TO_ADDR
9304: GO 9283
9306: POP
9307: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9308: LD_VAR 0 11
9312: PPUSH
9313: LD_INT 35
9315: PUSH
9316: LD_INT 0
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PPUSH
9323: CALL_OW 72
9327: PUSH
9328: LD_INT 0
9330: GREATER
9331: PUSH
9332: LD_VAR 0 9
9336: PPUSH
9337: CALL_OW 461
9341: PUSH
9342: LD_INT 2
9344: EQUAL
9345: AND
9346: IFFALSE 9398
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9348: LD_VAR 0 11
9352: PPUSH
9353: LD_INT 35
9355: PUSH
9356: LD_INT 0
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: PPUSH
9363: CALL_OW 72
9367: PUSH
9368: LD_INT 1
9370: ARRAY
9371: PPUSH
9372: LD_INT 28
9374: PUSH
9375: LD_INT 27
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PUSH
9382: LD_INT 1
9384: PPUSH
9385: LD_INT 2
9387: PPUSH
9388: CALL_OW 12
9392: ARRAY
9393: PPUSH
9394: CALL_OW 148
// end ; if legion_enemy > 0 then
9398: LD_EXP 36
9402: PUSH
9403: LD_INT 0
9405: GREATER
9406: IFFALSE 9986
// begin if tick mod 11 11$00 = 0 then
9408: LD_OWVAR 1
9412: PUSH
9413: LD_INT 23100
9415: MOD
9416: PUSH
9417: LD_INT 0
9419: EQUAL
9420: IFFALSE 9670
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9422: LD_ADDR_EXP 35
9426: PUSH
9427: LD_EXP 35
9431: PUSH
9432: LD_INT 13
9434: PUSH
9435: LD_INT 1
9437: PUSH
9438: LD_INT 2
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: LIST
9445: ADD
9446: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9447: LD_ADDR_EXP 35
9451: PUSH
9452: LD_EXP 35
9456: PUSH
9457: LD_INT 28
9459: PUSH
9460: LD_INT 27
9462: PUSH
9463: LD_INT 29
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 1
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: CALL_OW 12
9481: ARRAY
9482: ADD
9483: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9484: LD_ADDR_EXP 35
9488: PUSH
9489: LD_EXP 35
9493: PUSH
9494: LD_INT 13
9496: PUSH
9497: LD_INT 1
9499: PUSH
9500: LD_INT 2
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: ADD
9508: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9509: LD_ADDR_EXP 35
9513: PUSH
9514: LD_EXP 35
9518: PUSH
9519: LD_INT 28
9521: PUSH
9522: LD_INT 27
9524: PUSH
9525: LD_INT 29
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: PUSH
9533: LD_INT 1
9535: PPUSH
9536: LD_INT 3
9538: PPUSH
9539: CALL_OW 12
9543: ARRAY
9544: ADD
9545: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9546: LD_ADDR_EXP 35
9550: PUSH
9551: LD_EXP 35
9555: PUSH
9556: LD_INT 13
9558: PUSH
9559: LD_INT 1
9561: PUSH
9562: LD_INT 2
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: LIST
9569: ADD
9570: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9571: LD_ADDR_EXP 35
9575: PUSH
9576: LD_EXP 35
9580: PUSH
9581: LD_INT 28
9583: PUSH
9584: LD_INT 27
9586: PUSH
9587: LD_INT 29
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: LIST
9594: PUSH
9595: LD_INT 1
9597: PPUSH
9598: LD_INT 3
9600: PPUSH
9601: CALL_OW 12
9605: ARRAY
9606: ADD
9607: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9608: LD_ADDR_EXP 35
9612: PUSH
9613: LD_EXP 35
9617: PUSH
9618: LD_INT 13
9620: PUSH
9621: LD_INT 1
9623: PUSH
9624: LD_INT 2
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: LIST
9631: ADD
9632: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9633: LD_ADDR_EXP 35
9637: PUSH
9638: LD_EXP 35
9642: PUSH
9643: LD_INT 28
9645: PUSH
9646: LD_INT 27
9648: PUSH
9649: LD_INT 29
9651: PUSH
9652: EMPTY
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 1
9659: PPUSH
9660: LD_INT 3
9662: PPUSH
9663: CALL_OW 12
9667: ARRAY
9668: ADD
9669: ST_TO_ADDR
// end ; if legion_force >= 7 then
9670: LD_EXP 31
9674: PUSH
9675: LD_INT 7
9677: GREATEREQUAL
9678: IFFALSE 9861
// begin for i = 1 to legion_force do
9680: LD_ADDR_VAR 0 2
9684: PUSH
9685: DOUBLE
9686: LD_INT 1
9688: DEC
9689: ST_TO_ADDR
9690: LD_EXP 31
9694: PUSH
9695: FOR_TO
9696: IFFALSE 9859
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9698: LD_EXP 31
9702: PUSH
9703: LD_VAR 0 2
9707: ARRAY
9708: PPUSH
9709: CALL_OW 314
9713: NOT
9714: PUSH
9715: LD_EXP 31
9719: PUSH
9720: LD_VAR 0 2
9724: ARRAY
9725: PPUSH
9726: CALL_OW 110
9730: PUSH
9731: LD_INT 11
9733: NONEQUAL
9734: AND
9735: IFFALSE 9857
// begin case legion_enemy of 1 :
9737: LD_EXP 36
9741: PUSH
9742: LD_INT 1
9744: DOUBLE
9745: EQUAL
9746: IFTRUE 9750
9748: GO 9774
9750: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9751: LD_EXP 31
9755: PUSH
9756: LD_VAR 0 2
9760: ARRAY
9761: PPUSH
9762: LD_INT 142
9764: PPUSH
9765: LD_INT 144
9767: PPUSH
9768: CALL_OW 111
9772: GO 9839
9774: LD_INT 2
9776: DOUBLE
9777: EQUAL
9778: IFTRUE 9782
9780: GO 9806
9782: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9783: LD_EXP 31
9787: PUSH
9788: LD_VAR 0 2
9792: ARRAY
9793: PPUSH
9794: LD_INT 101
9796: PPUSH
9797: LD_INT 34
9799: PPUSH
9800: CALL_OW 111
9804: GO 9839
9806: LD_INT 7
9808: DOUBLE
9809: EQUAL
9810: IFTRUE 9814
9812: GO 9838
9814: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9815: LD_EXP 31
9819: PUSH
9820: LD_VAR 0 2
9824: ARRAY
9825: PPUSH
9826: LD_INT 173
9828: PPUSH
9829: LD_INT 127
9831: PPUSH
9832: CALL_OW 111
9836: GO 9839
9838: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9839: LD_EXP 31
9843: PUSH
9844: LD_VAR 0 2
9848: ARRAY
9849: PPUSH
9850: LD_INT 11
9852: PPUSH
9853: CALL_OW 109
// end ; end ;
9857: GO 9695
9859: POP
9860: POP
// end ; if legion_force then
9861: LD_EXP 31
9865: IFFALSE 9986
// begin tmp := legion_force ;
9867: LD_ADDR_VAR 0 3
9871: PUSH
9872: LD_EXP 31
9876: ST_TO_ADDR
// for i = 1 to tmp do
9877: LD_ADDR_VAR 0 2
9881: PUSH
9882: DOUBLE
9883: LD_INT 1
9885: DEC
9886: ST_TO_ADDR
9887: LD_VAR 0 3
9891: PUSH
9892: FOR_TO
9893: IFFALSE 9984
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9895: LD_VAR 0 3
9899: PUSH
9900: LD_VAR 0 2
9904: ARRAY
9905: PPUSH
9906: CALL_OW 314
9910: NOT
9911: PUSH
9912: LD_EXP 31
9916: PUSH
9917: LD_VAR 0 2
9921: ARRAY
9922: PPUSH
9923: CALL_OW 110
9927: PUSH
9928: LD_INT 11
9930: EQUAL
9931: AND
9932: IFFALSE 9982
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9934: LD_VAR 0 3
9938: PUSH
9939: LD_VAR 0 2
9943: ARRAY
9944: PPUSH
9945: LD_INT 22
9947: PUSH
9948: LD_EXP 36
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PPUSH
9957: CALL_OW 69
9961: PPUSH
9962: LD_VAR 0 3
9966: PUSH
9967: LD_VAR 0 2
9971: ARRAY
9972: PPUSH
9973: CALL_OW 74
9977: PPUSH
9978: CALL_OW 115
9982: GO 9892
9984: POP
9985: POP
// end ; end ; p := 1 ;
9986: LD_ADDR_VAR 0 6
9990: PUSH
9991: LD_INT 1
9993: ST_TO_ADDR
// for i = 1 to 24 do
9994: LD_ADDR_VAR 0 2
9998: PUSH
9999: DOUBLE
10000: LD_INT 1
10002: DEC
10003: ST_TO_ADDR
10004: LD_INT 24
10006: PUSH
10007: FOR_TO
10008: IFFALSE 10138
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10010: LD_EXP 33
10014: PUSH
10015: LD_VAR 0 6
10019: ARRAY
10020: PPUSH
10021: LD_EXP 33
10025: PUSH
10026: LD_VAR 0 6
10030: PUSH
10031: LD_INT 1
10033: PLUS
10034: ARRAY
10035: PPUSH
10036: CALL_OW 428
10040: PUSH
10041: LD_INT 0
10043: GREATER
10044: IFFALSE 10122
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10046: LD_EXP 33
10050: PUSH
10051: LD_VAR 0 6
10055: ARRAY
10056: PPUSH
10057: LD_EXP 33
10061: PUSH
10062: LD_VAR 0 6
10066: PUSH
10067: LD_INT 1
10069: PLUS
10070: ARRAY
10071: PPUSH
10072: CALL_OW 428
10076: PPUSH
10077: CALL_OW 255
10081: PUSH
10082: LD_EXP 36
10086: EQUAL
10087: IFFALSE 10122
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10089: LD_EXP 33
10093: PUSH
10094: LD_VAR 0 6
10098: ARRAY
10099: PPUSH
10100: LD_EXP 33
10104: PUSH
10105: LD_VAR 0 6
10109: PUSH
10110: LD_INT 1
10112: PLUS
10113: ARRAY
10114: PPUSH
10115: LD_INT 8
10117: PPUSH
10118: CALL_OW 456
// p := p + 2 ;
10122: LD_ADDR_VAR 0 6
10126: PUSH
10127: LD_VAR 0 6
10131: PUSH
10132: LD_INT 2
10134: PLUS
10135: ST_TO_ADDR
// end ;
10136: GO 10007
10138: POP
10139: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10140: LD_INT 22
10142: PUSH
10143: LD_INT 8
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: PUSH
10150: LD_INT 34
10152: PUSH
10153: LD_INT 32
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PPUSH
10164: CALL_OW 69
10168: IFFALSE 10282
// begin if l_cargo = false then
10170: LD_VAR 0 17
10174: PUSH
10175: LD_INT 0
10177: EQUAL
10178: IFFALSE 10214
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10180: LD_ADDR_VAR 0 17
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 8
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 34
10197: PUSH
10198: LD_INT 32
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: PPUSH
10209: CALL_OW 69
10213: ST_TO_ADDR
// if l_cargo then
10214: LD_VAR 0 17
10218: IFFALSE 10282
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10220: LD_ADDR_VAR 0 7
10224: PUSH
10225: LD_INT 14
10227: PPUSH
10228: CALL_OW 435
10232: ST_TO_ADDR
// if cr > 0 then
10233: LD_VAR 0 7
10237: PUSH
10238: LD_INT 0
10240: GREATER
10241: IFFALSE 10282
// if not HasTask ( l_cargo ) then
10243: LD_VAR 0 17
10247: PPUSH
10248: CALL_OW 314
10252: NOT
10253: IFFALSE 10282
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10255: LD_VAR 0 17
10259: PPUSH
10260: LD_VAR 0 7
10264: PUSH
10265: LD_INT 1
10267: ARRAY
10268: PPUSH
10269: LD_VAR 0 7
10273: PUSH
10274: LD_INT 2
10276: ARRAY
10277: PPUSH
10278: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10282: LD_OWVAR 1
10286: PUSH
10287: LD_INT 52500
10289: PUSH
10290: LD_INT 46200
10292: PUSH
10293: LD_INT 42000
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_OWVAR 67
10305: ARRAY
10306: EQUAL
10307: PUSH
10308: LD_INT 1
10310: PPUSH
10311: CALL_OW 469
10315: PUSH
10316: LD_INT 1
10318: ARRAY
10319: PUSH
10320: LD_INT 112
10322: EQUAL
10323: AND
10324: PUSH
10325: LD_INT 1
10327: PPUSH
10328: CALL_OW 469
10332: PUSH
10333: LD_INT 2
10335: ARRAY
10336: PUSH
10337: LD_INT 67
10339: EQUAL
10340: AND
10341: IFFALSE 10434
// begin un := l_eng [ 1 ] ;
10343: LD_ADDR_VAR 0 1
10347: PUSH
10348: LD_VAR 0 16
10352: PUSH
10353: LD_INT 1
10355: ARRAY
10356: ST_TO_ADDR
// if IsInUnit ( un ) then
10357: LD_VAR 0 1
10361: PPUSH
10362: CALL_OW 310
10366: IFFALSE 10377
// ComExitBuilding ( un ) ;
10368: LD_VAR 0 1
10372: PPUSH
10373: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10377: LD_VAR 0 1
10381: PPUSH
10382: LD_INT 1
10384: PPUSH
10385: CALL_OW 469
10389: PUSH
10390: LD_INT 1
10392: ARRAY
10393: PPUSH
10394: LD_INT 1
10396: PPUSH
10397: CALL_OW 469
10401: PUSH
10402: LD_INT 2
10404: ARRAY
10405: PPUSH
10406: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10410: LD_VAR 0 1
10414: PPUSH
10415: LD_INT 207
10417: PPUSH
10418: LD_INT 123
10420: PPUSH
10421: CALL_OW 171
// AddComUnload ( un ) ;
10425: LD_VAR 0 1
10429: PPUSH
10430: CALL_OW 219
// end ; end ;
10434: PPOPN 17
10436: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10437: LD_OWVAR 67
10441: PUSH
10442: LD_INT 1
10444: GREATER
10445: IFFALSE 10650
10447: GO 10449
10449: DISABLE
10450: LD_INT 0
10452: PPUSH
10453: PPUSH
10454: PPUSH
10455: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10456: LD_INT 35
10458: PPUSH
10459: LD_INT 12635
10461: PPUSH
10462: CALL_OW 12
10466: PPUSH
10467: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10471: LD_ADDR_VAR 0 2
10475: PUSH
10476: LD_INT 22
10478: PUSH
10479: LD_INT 8
10481: PUSH
10482: EMPTY
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 25
10488: PUSH
10489: LD_INT 4
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: CALL_OW 69
10504: ST_TO_ADDR
// p := 1 ;
10505: LD_ADDR_VAR 0 4
10509: PUSH
10510: LD_INT 1
10512: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10513: LD_ADDR_VAR 0 3
10517: PUSH
10518: LD_INT 116
10520: PUSH
10521: LD_INT 139
10523: PUSH
10524: LD_INT 69
10526: PUSH
10527: LD_INT 13
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: ST_TO_ADDR
// for i = 1 to 2 do
10536: LD_ADDR_VAR 0 1
10540: PUSH
10541: DOUBLE
10542: LD_INT 1
10544: DEC
10545: ST_TO_ADDR
10546: LD_INT 2
10548: PUSH
10549: FOR_TO
10550: IFFALSE 10648
// begin if IsInUnit ( sci [ i ] ) then
10552: LD_VAR 0 2
10556: PUSH
10557: LD_VAR 0 1
10561: ARRAY
10562: PPUSH
10563: CALL_OW 310
10567: IFFALSE 10584
// ComExitBuilding ( sci [ i ] ) ;
10569: LD_VAR 0 2
10573: PUSH
10574: LD_VAR 0 1
10578: ARRAY
10579: PPUSH
10580: CALL_OW 122
// Wait ( 0 0$03 ) ;
10584: LD_INT 105
10586: PPUSH
10587: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10591: LD_VAR 0 2
10595: PUSH
10596: LD_VAR 0 1
10600: ARRAY
10601: PPUSH
10602: LD_VAR 0 3
10606: PUSH
10607: LD_VAR 0 4
10611: ARRAY
10612: PPUSH
10613: LD_VAR 0 3
10617: PUSH
10618: LD_VAR 0 4
10622: PUSH
10623: LD_INT 1
10625: PLUS
10626: ARRAY
10627: PPUSH
10628: CALL_OW 158
// p := p + 2 ;
10632: LD_ADDR_VAR 0 4
10636: PUSH
10637: LD_VAR 0 4
10641: PUSH
10642: LD_INT 2
10644: PLUS
10645: ST_TO_ADDR
// end ;
10646: GO 10549
10648: POP
10649: POP
// end ;
10650: PPOPN 4
10652: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10653: LD_INT 14
10655: PPUSH
10656: CALL_OW 435
10660: PUSH
10661: LD_INT 20
10663: LESS
10664: IFFALSE 10691
10666: GO 10668
10668: DISABLE
// begin enable ;
10669: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10670: LD_INT 1
10672: PPUSH
10673: LD_INT 5
10675: PPUSH
10676: CALL_OW 12
10680: PPUSH
10681: LD_INT 14
10683: PPUSH
10684: LD_INT 1
10686: PPUSH
10687: CALL_OW 55
// end ; end_of_file
10691: END
// export function Action ; var un ; begin
10692: LD_INT 0
10694: PPUSH
10695: PPUSH
// case Query ( QVul1 ) of 1 :
10696: LD_STRING QVul1
10698: PPUSH
10699: CALL_OW 97
10703: PUSH
10704: LD_INT 1
10706: DOUBLE
10707: EQUAL
10708: IFTRUE 10712
10710: GO 10723
10712: POP
// Difficulty := 1 ; 2 :
10713: LD_ADDR_OWVAR 67
10717: PUSH
10718: LD_INT 1
10720: ST_TO_ADDR
10721: GO 10762
10723: LD_INT 2
10725: DOUBLE
10726: EQUAL
10727: IFTRUE 10731
10729: GO 10742
10731: POP
// Difficulty := 2 ; 3 :
10732: LD_ADDR_OWVAR 67
10736: PUSH
10737: LD_INT 2
10739: ST_TO_ADDR
10740: GO 10762
10742: LD_INT 3
10744: DOUBLE
10745: EQUAL
10746: IFTRUE 10750
10748: GO 10761
10750: POP
// Difficulty := 3 ; end ;
10751: LD_ADDR_OWVAR 67
10755: PUSH
10756: LD_INT 3
10758: ST_TO_ADDR
10759: GO 10762
10761: POP
// case Query ( QVul3 ) of 1 :
10762: LD_STRING QVul3
10764: PPUSH
10765: CALL_OW 97
10769: PUSH
10770: LD_INT 1
10772: DOUBLE
10773: EQUAL
10774: IFTRUE 10778
10776: GO 10801
10778: POP
// begin your_side := 1 ;
10779: LD_ADDR_OWVAR 2
10783: PUSH
10784: LD_INT 1
10786: ST_TO_ADDR
// legion_enemy := 1 ;
10787: LD_ADDR_EXP 36
10791: PUSH
10792: LD_INT 1
10794: ST_TO_ADDR
// PrepareAmerican ;
10795: CALL 214 0 0
// end ; 2 :
10799: GO 10864
10801: LD_INT 2
10803: DOUBLE
10804: EQUAL
10805: IFTRUE 10809
10807: GO 10832
10809: POP
// begin your_side := 2 ;
10810: LD_ADDR_OWVAR 2
10814: PUSH
10815: LD_INT 2
10817: ST_TO_ADDR
// legion_enemy := 2 ;
10818: LD_ADDR_EXP 36
10822: PUSH
10823: LD_INT 2
10825: ST_TO_ADDR
// PrepareArabian ;
10826: CALL 17461 0 0
// end ; 3 :
10830: GO 10864
10832: LD_INT 3
10834: DOUBLE
10835: EQUAL
10836: IFTRUE 10840
10838: GO 10863
10840: POP
// begin your_side := 7 ;
10841: LD_ADDR_OWVAR 2
10845: PUSH
10846: LD_INT 7
10848: ST_TO_ADDR
// legion_enemy := 7 ;
10849: LD_ADDR_EXP 36
10853: PUSH
10854: LD_INT 7
10856: ST_TO_ADDR
// PrepareAlliance ;
10857: CALL 14872 0 0
// end ; end ;
10861: GO 10864
10863: POP
// if your_side = 1 then
10864: LD_OWVAR 2
10868: PUSH
10869: LD_INT 1
10871: EQUAL
10872: IFFALSE 11226
// begin case Query ( QVul4 ) of 1 :
10874: LD_STRING QVul4
10876: PPUSH
10877: CALL_OW 97
10881: PUSH
10882: LD_INT 1
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 10893
10890: POP
// ; end ;
10891: GO 10894
10893: POP
// InGameOn ;
10894: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10898: LD_INT 8
10900: PPUSH
10901: LD_INT 5
10903: PPUSH
10904: CALL_OW 86
// uc_side := 4 ;
10908: LD_ADDR_OWVAR 20
10912: PUSH
10913: LD_INT 4
10915: ST_TO_ADDR
// uc_nation := 1 ;
10916: LD_ADDR_OWVAR 21
10920: PUSH
10921: LD_INT 1
10923: ST_TO_ADDR
// hc_importance := 0 ;
10924: LD_ADDR_OWVAR 32
10928: PUSH
10929: LD_INT 0
10931: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10932: LD_INT 1
10934: PPUSH
10935: LD_INT 3
10937: PPUSH
10938: LD_EXP 21
10942: PPUSH
10943: CALL_OW 380
// un := CreateHuman ;
10947: LD_ADDR_VAR 0 2
10951: PUSH
10952: CALL_OW 44
10956: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_INT 12
10964: PPUSH
10965: LD_INT 9
10967: PPUSH
10968: LD_INT 0
10970: PPUSH
10971: CALL_OW 48
// hc_name := Stuart Carey ;
10975: LD_ADDR_OWVAR 26
10979: PUSH
10980: LD_STRING Stuart Carey
10982: ST_TO_ADDR
// hc_class := 1 ;
10983: LD_ADDR_OWVAR 28
10987: PUSH
10988: LD_INT 1
10990: ST_TO_ADDR
// hc_gallery := vulcano ;
10991: LD_ADDR_OWVAR 33
10995: PUSH
10996: LD_STRING vulcano
10998: ST_TO_ADDR
// hc_face_number := 1 ;
10999: LD_ADDR_OWVAR 34
11003: PUSH
11004: LD_INT 1
11006: ST_TO_ADDR
// us_guy := CreateHuman ;
11007: LD_ADDR_EXP 22
11011: PUSH
11012: CALL_OW 44
11016: ST_TO_ADDR
// hc_gallery :=  ;
11017: LD_ADDR_OWVAR 33
11021: PUSH
11022: LD_STRING 
11024: ST_TO_ADDR
// hc_name :=  ;
11025: LD_ADDR_OWVAR 26
11029: PUSH
11030: LD_STRING 
11032: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11033: LD_VAR 0 2
11037: PPUSH
11038: LD_EXP 19
11042: PPUSH
11043: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11047: LD_EXP 19
11051: PPUSH
11052: LD_VAR 0 2
11056: PPUSH
11057: CALL_OW 119
// Say ( un , VD-un1 ) ;
11061: LD_VAR 0 2
11065: PPUSH
11066: LD_STRING VD-un1
11068: PPUSH
11069: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11073: LD_EXP 19
11077: PPUSH
11078: LD_STRING VDc-1
11080: PPUSH
11081: CALL_OW 88
// Say ( un , VD-un2 ) ;
11085: LD_VAR 0 2
11089: PPUSH
11090: LD_STRING VD-un2
11092: PPUSH
11093: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11097: LD_EXP 19
11101: PPUSH
11102: LD_STRING VDc-2
11104: PPUSH
11105: CALL_OW 88
// Say ( un , VD-un3 ) ;
11109: LD_VAR 0 2
11113: PPUSH
11114: LD_STRING VD-un3
11116: PPUSH
11117: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11121: LD_INT 7
11123: PPUSH
11124: CALL_OW 67
// Say ( un , VD-un4 ) ;
11128: LD_VAR 0 2
11132: PPUSH
11133: LD_STRING VD-un4
11135: PPUSH
11136: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11140: LD_VAR 0 2
11144: PPUSH
11145: LD_INT 2
11147: PPUSH
11148: LD_INT 2
11150: PPUSH
11151: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11155: LD_EXP 19
11159: PPUSH
11160: LD_STRING VDc-3
11162: PPUSH
11163: CALL_OW 88
// InGameOff ;
11167: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11171: LD_STRING CVulc1
11173: PPUSH
11174: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11178: LD_INT 35
11180: PPUSH
11181: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11185: LD_VAR 0 2
11189: PPUSH
11190: CALL_OW 250
11194: PUSH
11195: LD_INT 2
11197: EQUAL
11198: PUSH
11199: LD_VAR 0 2
11203: PPUSH
11204: CALL_OW 251
11208: PUSH
11209: LD_INT 2
11211: EQUAL
11212: AND
11213: IFFALSE 11178
// RemoveUnit ( un ) ;
11215: LD_VAR 0 2
11219: PPUSH
11220: CALL_OW 64
// end else
11224: GO 11518
// if your_side = 2 then
11226: LD_OWVAR 2
11230: PUSH
11231: LD_INT 2
11233: EQUAL
11234: IFFALSE 11406
// begin CenterNowOnUnits ( player_commander ) ;
11236: LD_EXP 10
11240: PPUSH
11241: CALL_OW 87
// InGameOn ;
11245: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11249: LD_EXP 51
11253: PPUSH
11254: LD_STRING VSd-1
11256: PPUSH
11257: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11261: LD_INT 22
11263: PUSH
11264: LD_INT 2
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: LD_INT 21
11273: PUSH
11274: LD_INT 1
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: PUSH
11281: LD_INT 26
11283: PUSH
11284: LD_INT 1
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: EMPTY
11292: LIST
11293: LIST
11294: LIST
11295: PUSH
11296: EMPTY
11297: LIST
11298: PPUSH
11299: CALL_OW 69
11303: PUSH
11304: LD_INT 2
11306: ARRAY
11307: PPUSH
11308: LD_STRING VAd-1
11310: PPUSH
11311: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11315: LD_EXP 51
11319: PPUSH
11320: LD_STRING VSd-2
11322: PPUSH
11323: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11327: LD_INT 22
11329: PUSH
11330: LD_INT 2
11332: PUSH
11333: EMPTY
11334: LIST
11335: LIST
11336: PUSH
11337: LD_INT 21
11339: PUSH
11340: LD_INT 1
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PUSH
11347: LD_INT 26
11349: PUSH
11350: LD_INT 1
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: LIST
11361: PUSH
11362: EMPTY
11363: LIST
11364: PPUSH
11365: CALL_OW 69
11369: PUSH
11370: LD_INT 2
11372: ARRAY
11373: PPUSH
11374: LD_STRING VAd-2
11376: PPUSH
11377: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11381: LD_EXP 51
11385: PPUSH
11386: LD_STRING VSd-3
11388: PPUSH
11389: CALL_OW 88
// InGameOff ;
11393: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11397: LD_STRING CVulc5
11399: PPUSH
11400: CALL_OW 337
// end else
11404: GO 11518
// if your_side = 7 then
11406: LD_OWVAR 2
11410: PUSH
11411: LD_INT 7
11413: EQUAL
11414: IFFALSE 11518
// begin CenterNowOnUnits ( al_commander ) ;
11416: LD_EXP 37
11420: PPUSH
11421: CALL_OW 87
// InGameOn ;
11425: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11429: LD_EXP 37
11433: PPUSH
11434: LD_STRING VPd-1
11436: PPUSH
11437: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11441: LD_INT 22
11443: PUSH
11444: LD_INT 7
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PUSH
11451: LD_INT 21
11453: PUSH
11454: LD_INT 1
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: PUSH
11461: LD_INT 26
11463: PUSH
11464: LD_INT 1
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PUSH
11471: EMPTY
11472: LIST
11473: LIST
11474: LIST
11475: PUSH
11476: EMPTY
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: PUSH
11484: LD_INT 2
11486: ARRAY
11487: PPUSH
11488: LD_STRING VPpd-1
11490: PPUSH
11491: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11495: LD_EXP 37
11499: PPUSH
11500: LD_STRING VPd-2
11502: PPUSH
11503: CALL_OW 88
// InGameOff ;
11507: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11511: LD_STRING CVulc7
11513: PPUSH
11514: CALL_OW 337
// end ; end ;
11518: LD_VAR 0 1
11522: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11523: LD_INT 22
11525: PUSH
11526: LD_INT 2
11528: PUSH
11529: EMPTY
11530: LIST
11531: LIST
11532: PUSH
11533: LD_INT 30
11535: PUSH
11536: LD_INT 3
11538: PUSH
11539: EMPTY
11540: LIST
11541: LIST
11542: PUSH
11543: EMPTY
11544: LIST
11545: LIST
11546: PPUSH
11547: CALL_OW 69
11551: IFFALSE 11595
11553: GO 11555
11555: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11556: LD_STRING CVulc6
11558: PPUSH
11559: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11563: LD_INT 52500
11565: PUSH
11566: LD_INT 47250
11568: PUSH
11569: LD_INT 42000
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: PUSH
11577: LD_OWVAR 67
11581: ARRAY
11582: PPUSH
11583: CALL_OW 67
// ru_can_attack := true ;
11587: LD_ADDR_EXP 3
11591: PUSH
11592: LD_INT 1
11594: ST_TO_ADDR
// end ;
11595: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11596: LD_INT 50
11598: PPUSH
11599: CALL_OW 255
11603: PUSH
11604: LD_INT 1
11606: EQUAL
11607: PUSH
11608: LD_INT 22
11610: PUSH
11611: LD_INT 1
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 2
11620: PUSH
11621: LD_INT 30
11623: PUSH
11624: LD_INT 3
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PUSH
11631: LD_INT 30
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: PPUSH
11650: CALL_OW 69
11654: OR
11655: IFFALSE 11832
11657: GO 11659
11659: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11660: LD_STRING CVulc2
11662: PPUSH
11663: CALL_OW 337
// DialogueOn ;
11667: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11671: LD_INT 10
11673: PPUSH
11674: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11678: LD_INT 22
11680: PUSH
11681: LD_INT 1
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: PUSH
11688: LD_INT 25
11690: PUSH
11691: LD_INT 2
11693: PUSH
11694: EMPTY
11695: LIST
11696: LIST
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PPUSH
11702: CALL_OW 69
11706: PUSH
11707: LD_EXP 19
11711: DIFF
11712: PUSH
11713: LD_INT 1
11715: ARRAY
11716: PPUSH
11717: LD_STRING VDb-1
11719: PPUSH
11720: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11724: LD_INT 10
11726: PPUSH
11727: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11731: LD_INT 22
11733: PUSH
11734: LD_INT 1
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 25
11743: PUSH
11744: LD_INT 4
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PPUSH
11755: CALL_OW 69
11759: PUSH
11760: LD_EXP 19
11764: DIFF
11765: PUSH
11766: LD_INT 1
11768: ARRAY
11769: PPUSH
11770: LD_STRING VDb-2
11772: PPUSH
11773: CALL_OW 88
// DWait ( 0 0$01 ) ;
11777: LD_INT 35
11779: PPUSH
11780: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11784: LD_EXP 19
11788: PPUSH
11789: LD_STRING VDb-com1
11791: PPUSH
11792: CALL_OW 88
// DialogueOff ;
11796: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11800: LD_INT 44100
11802: PUSH
11803: LD_INT 36750
11805: PUSH
11806: LD_INT 31500
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: LIST
11813: PUSH
11814: LD_OWVAR 67
11818: ARRAY
11819: PPUSH
11820: CALL_OW 67
// ru_can_attack := true ;
11824: LD_ADDR_EXP 3
11828: PUSH
11829: LD_INT 1
11831: ST_TO_ADDR
// end ;
11832: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11833: LD_INT 22
11835: PUSH
11836: LD_INT 7
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: LD_INT 30
11845: PUSH
11846: LD_INT 3
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: IFFALSE 11898
11863: GO 11865
11865: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11866: LD_INT 42000
11868: PUSH
11869: LD_INT 34650
11871: PUSH
11872: LD_INT 29400
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: LIST
11879: PUSH
11880: LD_OWVAR 67
11884: ARRAY
11885: PPUSH
11886: CALL_OW 67
// ru_can_attack := true ;
11890: LD_ADDR_EXP 3
11894: PUSH
11895: LD_INT 1
11897: ST_TO_ADDR
// end ;
11898: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11899: LD_INT 58
11901: PPUSH
11902: CALL_OW 255
11906: PUSH
11907: LD_INT 1
11909: EQUAL
11910: IFFALSE 12042
11912: GO 11914
11914: DISABLE
// begin DialogueOn ;
11915: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11919: LD_INT 22
11921: PUSH
11922: LD_INT 1
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 25
11931: PUSH
11932: LD_INT 2
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: PPUSH
11943: CALL_OW 69
11947: PUSH
11948: LD_INT 1
11950: ARRAY
11951: PPUSH
11952: LD_STRING VDe-1
11954: PPUSH
11955: CALL_OW 88
// case Query ( SibNote ) of 1 :
11959: LD_STRING SibNote
11961: PPUSH
11962: CALL_OW 97
11966: PUSH
11967: LD_INT 1
11969: DOUBLE
11970: EQUAL
11971: IFTRUE 11975
11973: GO 11978
11975: POP
// ; end ;
11976: GO 11979
11978: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11979: LD_INT 22
11981: PUSH
11982: LD_INT 1
11984: PUSH
11985: EMPTY
11986: LIST
11987: LIST
11988: PUSH
11989: LD_INT 25
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PPUSH
12003: CALL_OW 69
12007: PUSH
12008: LD_INT 1
12010: ARRAY
12011: PPUSH
12012: LD_STRING VDe-2
12014: PPUSH
12015: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12019: LD_EXP 19
12023: PPUSH
12024: LD_STRING VDc-4
12026: PPUSH
12027: CALL_OW 88
// DialogueOff ;
12031: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12035: LD_STRING CVulc3
12037: PPUSH
12038: CALL_OW 337
// end ;
12042: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12043: LD_OWVAR 2
12047: PUSH
12048: LD_INT 1
12050: EQUAL
12051: PUSH
12052: LD_INT 22
12054: PUSH
12055: LD_INT 1
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: LD_INT 30
12064: PUSH
12065: LD_INT 3
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: PPUSH
12076: CALL_OW 69
12080: PUSH
12081: LD_INT 0
12083: GREATER
12084: AND
12085: IFFALSE 12519
12087: GO 12089
12089: DISABLE
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
12094: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12095: LD_INT 245
12097: PPUSH
12098: LD_INT 1295
12100: PPUSH
12101: CALL_OW 12
12105: PPUSH
12106: CALL_OW 67
// DialogueOn ;
12110: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12114: LD_EXP 22
12118: PPUSH
12119: LD_STRING VDG-1
12121: PPUSH
12122: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12126: LD_EXP 19
12130: PPUSH
12131: LD_STRING VDc-5
12133: PPUSH
12134: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12138: LD_EXP 22
12142: PPUSH
12143: LD_STRING VDG-2
12145: PPUSH
12146: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12150: LD_EXP 19
12154: PPUSH
12155: LD_STRING VDc-6
12157: PPUSH
12158: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12162: LD_EXP 22
12166: PPUSH
12167: LD_STRING VDG-3
12169: PPUSH
12170: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12174: LD_EXP 19
12178: PPUSH
12179: LD_STRING VDc-7
12181: PPUSH
12182: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12186: LD_EXP 22
12190: PPUSH
12191: LD_STRING VDG-4
12193: PPUSH
12194: CALL_OW 94
// DialogueOff ;
12198: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12202: LD_STRING CVulc4
12204: PPUSH
12205: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12209: LD_INT 18900
12211: PUSH
12212: LD_INT 21000
12214: PUSH
12215: LD_INT 23100
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: LIST
12222: PUSH
12223: LD_OWVAR 67
12227: ARRAY
12228: PPUSH
12229: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12233: LD_ADDR_VAR 0 1
12237: PUSH
12238: DOUBLE
12239: LD_INT 1
12241: DEC
12242: ST_TO_ADDR
12243: LD_INT 4
12245: PUSH
12246: LD_INT 5
12248: PUSH
12249: LD_INT 6
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: PUSH
12257: LD_OWVAR 67
12261: ARRAY
12262: PUSH
12263: FOR_TO
12264: IFFALSE 12508
// begin uc_side := 1 ;
12266: LD_ADDR_OWVAR 20
12270: PUSH
12271: LD_INT 1
12273: ST_TO_ADDR
// uc_nation := 1 ;
12274: LD_ADDR_OWVAR 21
12278: PUSH
12279: LD_INT 1
12281: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12282: LD_INT 0
12284: PPUSH
12285: LD_INT 1
12287: PPUSH
12288: LD_INT 4
12290: PPUSH
12291: CALL_OW 12
12295: PPUSH
12296: LD_EXP 21
12300: PPUSH
12301: CALL_OW 380
// un := CreateHuman ;
12305: LD_ADDR_VAR 0 2
12309: PUSH
12310: CALL_OW 44
12314: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12315: LD_VAR 0 2
12319: PPUSH
12320: LD_INT 2
12322: PPUSH
12323: CALL_OW 233
// if GetClass ( un ) = 3 then
12327: LD_VAR 0 2
12331: PPUSH
12332: CALL_OW 257
12336: PUSH
12337: LD_INT 3
12339: EQUAL
12340: IFFALSE 12491
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12342: LD_ADDR_OWVAR 37
12346: PUSH
12347: LD_INT 2
12349: PUSH
12350: LD_INT 3
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PUSH
12357: LD_VAR 0 1
12361: PUSH
12362: LD_INT 2
12364: MOD
12365: ARRAY
12366: ST_TO_ADDR
// vc_engine := engine_combustion ;
12367: LD_ADDR_OWVAR 39
12371: PUSH
12372: LD_INT 1
12374: ST_TO_ADDR
// vc_control := control_manual ;
12375: LD_ADDR_OWVAR 38
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12383: LD_ADDR_OWVAR 40
12387: PUSH
12388: LD_INT 9
12390: PUSH
12391: LD_INT 9
12393: PUSH
12394: LD_INT 5
12396: PUSH
12397: LD_INT 11
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: PUSH
12406: LD_INT 1
12408: PPUSH
12409: LD_INT 4
12411: PPUSH
12412: CALL_OW 12
12416: ARRAY
12417: ST_TO_ADDR
// veh := CreateVehicle ;
12418: LD_ADDR_VAR 0 3
12422: PUSH
12423: CALL_OW 45
12427: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12428: LD_VAR 0 3
12432: PPUSH
12433: LD_INT 2
12435: PPUSH
12436: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12440: LD_VAR 0 3
12444: PPUSH
12445: LD_INT 77
12447: PPUSH
12448: LD_INT 88
12450: PPUSH
12451: CALL_OW 12
12455: PPUSH
12456: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12460: LD_VAR 0 3
12464: PPUSH
12465: LD_INT 1
12467: PPUSH
12468: LD_INT 0
12470: PPUSH
12471: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: LD_VAR 0 3
12484: PPUSH
12485: CALL_OW 52
// end else
12489: GO 12506
// PlaceUnitArea ( un , start_north , false ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: LD_INT 0
12501: PPUSH
12502: CALL_OW 49
// end ;
12506: GO 12263
12508: POP
12509: POP
// CenterNowOnUnits ( un ) ;
12510: LD_VAR 0 2
12514: PPUSH
12515: CALL_OW 87
// end ;
12519: PPOPN 3
12521: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12522: LD_INT 21
12524: PPUSH
12525: LD_INT 22
12527: PUSH
12528: LD_OWVAR 2
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PPUSH
12537: CALL_OW 70
12541: IFFALSE 12763
12543: GO 12545
12545: DISABLE
12546: LD_INT 0
12548: PPUSH
12549: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: LD_INT 22
12557: PUSH
12558: LD_OWVAR 2
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: PUSH
12567: LD_INT 2
12569: PUSH
12570: LD_INT 25
12572: PUSH
12573: LD_INT 1
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PUSH
12580: LD_INT 25
12582: PUSH
12583: LD_INT 2
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PUSH
12590: LD_INT 25
12592: PUSH
12593: LD_INT 3
12595: PUSH
12596: EMPTY
12597: LIST
12598: LIST
12599: PUSH
12600: LD_INT 25
12602: PUSH
12603: LD_INT 4
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PPUSH
12621: CALL_OW 69
12625: PUSH
12626: LD_EXP 10
12630: DIFF
12631: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12632: LD_ADDR_VAR 0 1
12636: PUSH
12637: LD_VAR 0 2
12641: PPUSH
12642: LD_INT 112
12644: PPUSH
12645: LD_INT 67
12647: PPUSH
12648: CALL_OW 73
12652: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12653: LD_VAR 0 1
12657: PPUSH
12658: CALL_OW 255
12662: PUSH
12663: LD_INT 7
12665: EQUAL
12666: IFFALSE 12680
// Say ( un , VD-find-al ) ;
12668: LD_VAR 0 1
12672: PPUSH
12673: LD_STRING VD-find-al
12675: PPUSH
12676: CALL_OW 88
// if GetSide ( un ) = 2 then
12680: LD_VAR 0 1
12684: PPUSH
12685: CALL_OW 255
12689: PUSH
12690: LD_INT 2
12692: EQUAL
12693: IFFALSE 12707
// Say ( un , VD-find-ar ) ;
12695: LD_VAR 0 1
12699: PPUSH
12700: LD_STRING VD-find-ar
12702: PPUSH
12703: CALL_OW 88
// if GetSide ( un ) = 1 then
12707: LD_VAR 0 1
12711: PPUSH
12712: CALL_OW 255
12716: PUSH
12717: LD_INT 1
12719: EQUAL
12720: IFFALSE 12746
// begin Say ( un , VD-find-us ) ;
12722: LD_VAR 0 1
12726: PPUSH
12727: LD_STRING VD-find-us
12729: PPUSH
12730: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12734: LD_VAR 0 1
12738: PPUSH
12739: LD_STRING VD-find-us2
12741: PPUSH
12742: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12746: LD_INT 10
12748: PPUSH
12749: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12753: LD_INT 112
12755: PPUSH
12756: LD_INT 67
12758: PPUSH
12759: CALL_OW 86
// end ;
12763: PPOPN 2
12765: END
// every 0 0$01 trigger player_artifact_ready do
12766: LD_EXP 7
12770: IFFALSE 13084
12772: GO 12774
12774: DISABLE
// begin if your_side = 1 then
12775: LD_OWVAR 2
12779: PUSH
12780: LD_INT 1
12782: EQUAL
12783: IFFALSE 12901
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12785: LD_INT 22
12787: PUSH
12788: LD_INT 1
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 4
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PPUSH
12809: CALL_OW 69
12813: PUSH
12814: LD_EXP 19
12818: DIFF
12819: PUSH
12820: LD_INT 1
12822: ARRAY
12823: PPUSH
12824: LD_STRING VD-us-sci-art-1
12826: PPUSH
12827: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12831: LD_EXP 19
12835: PPUSH
12836: LD_STRING VDc-art1
12838: PPUSH
12839: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12843: LD_INT 22
12845: PUSH
12846: LD_INT 1
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 25
12855: PUSH
12856: LD_INT 4
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PPUSH
12867: CALL_OW 69
12871: PUSH
12872: LD_EXP 19
12876: DIFF
12877: PUSH
12878: LD_INT 1
12880: ARRAY
12881: PPUSH
12882: LD_STRING VD-us-sci-art-2
12884: PPUSH
12885: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12889: LD_EXP 19
12893: PPUSH
12894: LD_STRING VDc-art2
12896: PPUSH
12897: CALL_OW 88
// end ; if your_side = 2 then
12901: LD_OWVAR 2
12905: PUSH
12906: LD_INT 2
12908: EQUAL
12909: IFFALSE 12951
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12911: LD_INT 22
12913: PUSH
12914: LD_INT 2
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 25
12923: PUSH
12924: LD_INT 4
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PPUSH
12935: CALL_OW 69
12939: PUSH
12940: LD_INT 1
12942: ARRAY
12943: PPUSH
12944: LD_STRING VD-ar-sci-art-1
12946: PPUSH
12947: CALL_OW 88
// end ; if your_side = 7 then
12951: LD_OWVAR 2
12955: PUSH
12956: LD_INT 7
12958: EQUAL
12959: IFFALSE 13084
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12961: LD_INT 22
12963: PUSH
12964: LD_INT 7
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: LD_INT 25
12973: PUSH
12974: LD_INT 4
12976: PUSH
12977: EMPTY
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: PPUSH
12985: CALL_OW 69
12989: PUSH
12990: LD_EXP 37
12994: DIFF
12995: PUSH
12996: LD_INT 1
12998: ARRAY
12999: PPUSH
13000: LD_STRING VD-al-sci-art-1
13002: PPUSH
13003: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13007: LD_EXP 37
13011: PPUSH
13012: LD_STRING VPd-art-1
13014: PPUSH
13015: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13019: LD_INT 22
13021: PUSH
13022: LD_INT 7
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PUSH
13029: LD_INT 25
13031: PUSH
13032: LD_INT 4
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: PPUSH
13043: CALL_OW 69
13047: PUSH
13048: LD_EXP 37
13052: DIFF
13053: PUSH
13054: LD_INT 1
13056: ARRAY
13057: PPUSH
13058: LD_STRING VD-al-sci-art-2
13060: PPUSH
13061: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13065: LD_EXP 37
13069: PPUSH
13070: LD_STRING VPd-art-2
13072: PPUSH
13073: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13077: LD_STRING CVulc7out
13079: PPUSH
13080: CALL_OW 337
// end ; end ;
13084: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13085: LD_INT 8
13087: PPUSH
13088: LD_INT 22
13090: PUSH
13091: LD_OWVAR 2
13095: PUSH
13096: EMPTY
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL_OW 69
13104: PPUSH
13105: LD_INT 8
13107: PPUSH
13108: CALL 2138 0 2
13112: PPUSH
13113: CALL_OW 292
13117: IFFALSE 13208
13119: GO 13121
13121: DISABLE
// begin if your_side = 1 then
13122: LD_OWVAR 2
13126: PUSH
13127: LD_INT 1
13129: EQUAL
13130: IFFALSE 13164
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13132: LD_INT 22
13134: PUSH
13135: LD_INT 1
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PPUSH
13142: CALL_OW 69
13146: PUSH
13147: LD_EXP 19
13151: DIFF
13152: PUSH
13153: LD_INT 1
13155: ARRAY
13156: PPUSH
13157: LD_STRING VD-legion-us
13159: PPUSH
13160: CALL_OW 88
// if your_side = 2 then
13164: LD_OWVAR 2
13168: PUSH
13169: LD_INT 2
13171: EQUAL
13172: IFFALSE 13186
// Say ( ar_commander , VD-legion-ar ) ;
13174: LD_EXP 51
13178: PPUSH
13179: LD_STRING VD-legion-ar
13181: PPUSH
13182: CALL_OW 88
// if your_side = 7 then
13186: LD_OWVAR 2
13190: PUSH
13191: LD_INT 7
13193: EQUAL
13194: IFFALSE 13208
// Say ( al_commander , VD-legion-al ) ;
13196: LD_EXP 37
13200: PPUSH
13201: LD_STRING VD-legion-al
13203: PPUSH
13204: CALL_OW 88
// end ;
13208: END
// every 0 0$01 trigger mine_vulc do
13209: LD_EXP 12
13213: IFFALSE 13230
13215: GO 13217
13217: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13218: LD_EXP 10
13222: PPUSH
13223: LD_STRING VD-vulc-mines
13225: PPUSH
13226: CALL_OW 88
// end ;
13230: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13231: LD_OWVAR 67
13235: PUSH
13236: LD_INT 1
13238: GREATER
13239: IFFALSE 13358
13241: GO 13243
13243: DISABLE
13244: LD_INT 0
13246: PPUSH
13247: PPUSH
13248: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13249: LD_ADDR_VAR 0 1
13253: PUSH
13254: LD_INT 123
13256: PUSH
13257: LD_INT 95
13259: PUSH
13260: LD_INT 119
13262: PUSH
13263: LD_INT 89
13265: PUSH
13266: LD_INT 115
13268: PUSH
13269: LD_INT 81
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: ST_TO_ADDR
// p := 1 ;
13280: LD_ADDR_VAR 0 2
13284: PUSH
13285: LD_INT 1
13287: ST_TO_ADDR
// for i = 1 to 3 do
13288: LD_ADDR_VAR 0 3
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_INT 3
13300: PUSH
13301: FOR_TO
13302: IFFALSE 13356
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13304: LD_VAR 0 1
13308: PUSH
13309: LD_VAR 0 2
13313: ARRAY
13314: PPUSH
13315: LD_VAR 0 1
13319: PUSH
13320: LD_VAR 0 2
13324: PUSH
13325: LD_INT 1
13327: PLUS
13328: ARRAY
13329: PPUSH
13330: LD_INT 8
13332: PPUSH
13333: LD_INT 0
13335: PPUSH
13336: CALL_OW 454
// p := p + 2 ;
13340: LD_ADDR_VAR 0 2
13344: PUSH
13345: LD_VAR 0 2
13349: PUSH
13350: LD_INT 2
13352: PLUS
13353: ST_TO_ADDR
// end ;
13354: GO 13301
13356: POP
13357: POP
// end ;
13358: PPOPN 3
13360: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13361: LD_OWVAR 67
13365: PUSH
13366: LD_INT 1
13368: GREATER
13369: PUSH
13370: LD_INT 22
13372: PPUSH
13373: LD_INT 22
13375: PUSH
13376: LD_OWVAR 2
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PPUSH
13385: CALL_OW 70
13389: AND
13390: IFFALSE 13594
13392: GO 13394
13394: DISABLE
13395: LD_INT 0
13397: PPUSH
13398: PPUSH
13399: PPUSH
// begin enable ;
13400: ENABLE
// p := 1 ;
13401: LD_ADDR_VAR 0 1
13405: PUSH
13406: LD_INT 1
13408: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13409: LD_ADDR_VAR 0 3
13413: PUSH
13414: LD_INT 123
13416: PUSH
13417: LD_INT 95
13419: PUSH
13420: LD_INT 119
13422: PUSH
13423: LD_INT 89
13425: PUSH
13426: LD_INT 115
13428: PUSH
13429: LD_INT 81
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: ST_TO_ADDR
// for i = 1 to 3 do
13440: LD_ADDR_VAR 0 2
13444: PUSH
13445: DOUBLE
13446: LD_INT 1
13448: DEC
13449: ST_TO_ADDR
13450: LD_INT 3
13452: PUSH
13453: FOR_TO
13454: IFFALSE 13592
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: ARRAY
13466: PPUSH
13467: LD_VAR 0 3
13471: PUSH
13472: LD_VAR 0 1
13476: PUSH
13477: LD_INT 1
13479: PLUS
13480: ARRAY
13481: PPUSH
13482: CALL_OW 428
13486: PUSH
13487: LD_INT 0
13489: GREATER
13490: IFFALSE 13576
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13492: LD_VAR 0 3
13496: PUSH
13497: LD_VAR 0 1
13501: ARRAY
13502: PPUSH
13503: LD_VAR 0 3
13507: PUSH
13508: LD_VAR 0 1
13512: PUSH
13513: LD_INT 1
13515: PLUS
13516: ARRAY
13517: PPUSH
13518: CALL_OW 428
13522: PPUSH
13523: CALL_OW 255
13527: PUSH
13528: LD_OWVAR 2
13532: EQUAL
13533: IFFALSE 13576
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13535: LD_VAR 0 3
13539: PUSH
13540: LD_VAR 0 1
13544: ARRAY
13545: PPUSH
13546: LD_VAR 0 3
13550: PUSH
13551: LD_VAR 0 1
13555: PUSH
13556: LD_INT 1
13558: PLUS
13559: ARRAY
13560: PPUSH
13561: LD_INT 8
13563: PPUSH
13564: CALL_OW 456
// mine_vulc := true ;
13568: LD_ADDR_EXP 12
13572: PUSH
13573: LD_INT 1
13575: ST_TO_ADDR
// end ; p := p + 2 ;
13576: LD_ADDR_VAR 0 1
13580: PUSH
13581: LD_VAR 0 1
13585: PUSH
13586: LD_INT 2
13588: PLUS
13589: ST_TO_ADDR
// end ;
13590: GO 13453
13592: POP
13593: POP
// end ;
13594: PPOPN 3
13596: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13597: LD_INT 22
13599: PUSH
13600: LD_INT 3
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 69
13611: PUSH
13612: LD_INT 0
13614: EQUAL
13615: PUSH
13616: LD_OWVAR 2
13620: PUSH
13621: LD_INT 2
13623: NONEQUAL
13624: AND
13625: IFFALSE 13634
13627: GO 13629
13629: DISABLE
// Win ;
13630: CALL 13691 0 0
13634: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13635: LD_INT 2
13637: PUSH
13638: LD_INT 22
13640: PUSH
13641: LD_INT 8
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: PUSH
13648: LD_INT 22
13650: PUSH
13651: LD_INT 3
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: LIST
13662: PPUSH
13663: CALL_OW 69
13667: PUSH
13668: LD_INT 0
13670: EQUAL
13671: PUSH
13672: LD_OWVAR 2
13676: PUSH
13677: LD_INT 2
13679: EQUAL
13680: AND
13681: IFFALSE 13690
13683: GO 13685
13685: DISABLE
// Win ;
13686: CALL 13691 0 0
13690: END
// function Win ; var points ; begin
13691: LD_INT 0
13693: PPUSH
13694: PPUSH
// case Query ( VulcWin ) of 1 :
13695: LD_STRING VulcWin
13697: PPUSH
13698: CALL_OW 97
13702: PUSH
13703: LD_INT 1
13705: DOUBLE
13706: EQUAL
13707: IFTRUE 13711
13709: GO 13714
13711: POP
// ; end ;
13712: GO 13715
13714: POP
// if medal_enabled then
13715: LD_EXP 13
13719: IFFALSE 13733
// AddMedal ( vulc_1 , 1 ) else
13721: LD_STRING vulc_1
13723: PPUSH
13724: LD_INT 1
13726: PPUSH
13727: CALL_OW 101
13731: GO 13744
// AddMedal ( vulc_1 , - 1 ) ;
13733: LD_STRING vulc_1
13735: PPUSH
13736: LD_INT 1
13738: NEG
13739: PPUSH
13740: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13744: LD_INT 22
13746: PUSH
13747: LD_INT 8
13749: PUSH
13750: EMPTY
13751: LIST
13752: LIST
13753: PPUSH
13754: CALL_OW 69
13758: PUSH
13759: LD_INT 0
13761: EQUAL
13762: IFFALSE 13776
// AddMedal ( vulc_2 , 1 ) else
13764: LD_STRING vulc_2
13766: PPUSH
13767: LD_INT 1
13769: PPUSH
13770: CALL_OW 101
13774: GO 13787
// AddMedal ( vulc_2 , - 1 ) ;
13776: LD_STRING vulc_2
13778: PPUSH
13779: LD_INT 1
13781: NEG
13782: PPUSH
13783: CALL_OW 101
// points := CalculateCommanderPoints ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: CALL 2259 0 0
13796: ST_TO_ADDR
// if points >= 2000 then
13797: LD_VAR 0 2
13801: PUSH
13802: LD_INT 2000
13804: GREATEREQUAL
13805: IFFALSE 13819
// AddMedal ( vulc_3 , 2 ) else
13807: LD_STRING vulc_3
13809: PPUSH
13810: LD_INT 2
13812: PPUSH
13813: CALL_OW 101
13817: GO 13852
// if points >= 0 then
13819: LD_VAR 0 2
13823: PUSH
13824: LD_INT 0
13826: GREATEREQUAL
13827: IFFALSE 13841
// AddMedal ( vulc_3 , 1 ) else
13829: LD_STRING vulc_3
13831: PPUSH
13832: LD_INT 1
13834: PPUSH
13835: CALL_OW 101
13839: GO 13852
// AddMedal ( vulc_3 , - 1 ) ;
13841: LD_STRING vulc_3
13843: PPUSH
13844: LD_INT 1
13846: NEG
13847: PPUSH
13848: CALL_OW 101
// GiveMedals ( MAIN ) ;
13852: LD_STRING MAIN
13854: PPUSH
13855: CALL_OW 102
// YouWin ;
13859: CALL_OW 103
// end ; end_of_file
13863: LD_VAR 0 1
13867: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13868: LD_INT 13
13870: PPUSH
13871: LD_INT 21
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PPUSH
13881: CALL_OW 70
13885: PUSH
13886: LD_INT 0
13888: GREATER
13889: IFFALSE 13956
13891: GO 13893
13893: DISABLE
13894: LD_INT 0
13896: PPUSH
13897: PPUSH
// begin enable ;
13898: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13899: LD_ADDR_VAR 0 1
13903: PUSH
13904: LD_INT 13
13906: PPUSH
13907: LD_INT 21
13909: PUSH
13910: LD_INT 1
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PPUSH
13917: CALL_OW 70
13921: PUSH
13922: FOR_IN
13923: IFFALSE 13954
// if GetLives ( i ) > 4 then
13925: LD_VAR 0 1
13929: PPUSH
13930: CALL_OW 256
13934: PUSH
13935: LD_INT 4
13937: GREATER
13938: IFFALSE 13952
// SetLives ( i , 4 ) ;
13940: LD_VAR 0 1
13944: PPUSH
13945: LD_INT 4
13947: PPUSH
13948: CALL_OW 234
13952: GO 13922
13954: POP
13955: POP
// end ;
13956: PPOPN 2
13958: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13959: LD_VAR 0 1
13963: PPUSH
13964: CALL_OW 255
13968: PUSH
13969: LD_OWVAR 2
13973: EQUAL
13974: IFFALSE 13984
// player_res_art := true ;
13976: LD_ADDR_EXP 6
13980: PUSH
13981: LD_INT 1
13983: ST_TO_ADDR
// end ;
13984: PPOPN 1
13986: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13987: LD_INT 22
13989: PUSH
13990: LD_OWVAR 2
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 2
14001: PUSH
14002: LD_INT 30
14004: PUSH
14005: LD_INT 8
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: PUSH
14012: LD_INT 30
14014: PUSH
14015: LD_INT 11
14017: PUSH
14018: EMPTY
14019: LIST
14020: LIST
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PPUSH
14031: CALL_OW 69
14035: PUSH
14036: LD_EXP 6
14040: AND
14041: IFFALSE 14385
14043: GO 14045
14045: DISABLE
14046: LD_INT 0
14048: PPUSH
14049: PPUSH
14050: PPUSH
// begin enable ;
14051: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14052: LD_ADDR_VAR 0 1
14056: PUSH
14057: LD_INT 1
14059: PPUSH
14060: CALL_OW 469
14064: PUSH
14065: LD_INT 1
14067: ARRAY
14068: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14069: LD_ADDR_VAR 0 2
14073: PUSH
14074: LD_INT 1
14076: PPUSH
14077: CALL_OW 469
14081: PUSH
14082: LD_INT 2
14084: ARRAY
14085: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14086: LD_ADDR_VAR 0 3
14090: PUSH
14091: LD_INT 22
14093: PUSH
14094: LD_OWVAR 2
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PUSH
14103: LD_INT 2
14105: PUSH
14106: LD_INT 30
14108: PUSH
14109: LD_INT 8
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: PUSH
14116: LD_INT 30
14118: PUSH
14119: LD_INT 11
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: LIST
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PPUSH
14135: CALL_OW 69
14139: PPUSH
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_VAR 0 2
14149: PPUSH
14150: CALL_OW 73
14154: ST_TO_ADDR
// if player_artifact_ready = false then
14155: LD_EXP 7
14159: PUSH
14160: LD_INT 0
14162: EQUAL
14163: IFFALSE 14269
// if GetDistUnitXY ( lab , x , y ) < 6 then
14165: LD_VAR 0 3
14169: PPUSH
14170: LD_VAR 0 1
14174: PPUSH
14175: LD_VAR 0 2
14179: PPUSH
14180: CALL_OW 297
14184: PUSH
14185: LD_INT 6
14187: LESS
14188: IFFALSE 14249
// begin if BuildingStatus ( lab ) = bs_idle then
14190: LD_VAR 0 3
14194: PPUSH
14195: CALL_OW 461
14199: PUSH
14200: LD_INT 2
14202: EQUAL
14203: IFFALSE 14227
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14205: LD_OWVAR 2
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 2
14215: PPUSH
14216: LD_VAR 0 3
14220: PPUSH
14221: CALL_OW 468
14225: GO 14247
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14227: LD_OWVAR 2
14231: PPUSH
14232: LD_INT 1
14234: PPUSH
14235: LD_INT 1
14237: PPUSH
14238: LD_VAR 0 3
14242: PPUSH
14243: CALL_OW 468
// end else
14247: GO 14269
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14249: LD_OWVAR 2
14253: PPUSH
14254: LD_INT 1
14256: PPUSH
14257: LD_INT 1
14259: PPUSH
14260: LD_VAR 0 3
14264: PPUSH
14265: CALL_OW 468
// if player_artifact_ready then
14269: LD_EXP 7
14273: IFFALSE 14385
// if GetDistUnitXY ( lab , x , y ) < 6 then
14275: LD_VAR 0 3
14279: PPUSH
14280: LD_VAR 0 1
14284: PPUSH
14285: LD_VAR 0 2
14289: PPUSH
14290: CALL_OW 297
14294: PUSH
14295: LD_INT 6
14297: LESS
14298: IFFALSE 14363
// begin if BuildingStatus ( lab ) = bs_idle then
14300: LD_VAR 0 3
14304: PPUSH
14305: CALL_OW 461
14309: PUSH
14310: LD_INT 2
14312: EQUAL
14313: IFFALSE 14339
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14315: LD_OWVAR 2
14319: PPUSH
14320: LD_EXP 8
14324: PPUSH
14325: LD_INT 4
14327: PPUSH
14328: LD_VAR 0 3
14332: PPUSH
14333: CALL_OW 468
14337: GO 14361
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14339: LD_OWVAR 2
14343: PPUSH
14344: LD_EXP 8
14348: PPUSH
14349: LD_INT 1
14351: PPUSH
14352: LD_VAR 0 3
14356: PPUSH
14357: CALL_OW 468
// end else
14361: GO 14385
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14363: LD_OWVAR 2
14367: PPUSH
14368: LD_EXP 8
14372: PPUSH
14373: LD_INT 1
14375: PPUSH
14376: LD_VAR 0 3
14380: PPUSH
14381: CALL_OW 468
// end ;
14385: PPOPN 3
14387: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14388: LD_INT 0
14390: PPUSH
14391: PPUSH
14392: PPUSH
14393: PPUSH
14394: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14395: LD_ADDR_VAR 0 5
14399: PUSH
14400: LD_INT 1
14402: PPUSH
14403: CALL_OW 469
14407: PUSH
14408: LD_INT 1
14410: ARRAY
14411: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14412: LD_ADDR_VAR 0 6
14416: PUSH
14417: LD_INT 1
14419: PPUSH
14420: CALL_OW 469
14424: PUSH
14425: LD_INT 2
14427: ARRAY
14428: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14429: LD_ADDR_VAR 0 8
14433: PUSH
14434: LD_INT 22
14436: PUSH
14437: LD_OWVAR 2
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PUSH
14446: LD_INT 2
14448: PUSH
14449: LD_INT 30
14451: PUSH
14452: LD_INT 8
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 30
14461: PUSH
14462: LD_INT 11
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: LIST
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PPUSH
14478: CALL_OW 69
14482: PPUSH
14483: LD_VAR 0 5
14487: PPUSH
14488: LD_VAR 0 6
14492: PPUSH
14493: CALL_OW 73
14497: ST_TO_ADDR
// if icon = art_exp_left then
14498: LD_VAR 0 2
14502: PUSH
14503: LD_INT 1
14505: EQUAL
14506: IFFALSE 14545
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14508: LD_VAR 0 8
14512: PPUSH
14513: LD_EXP 9
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14525: LD_OWVAR 2
14529: PPUSH
14530: LD_INT 1
14532: PPUSH
14533: LD_INT 0
14535: PPUSH
14536: LD_VAR 0 8
14540: PPUSH
14541: CALL_OW 468
// end ; if icon = art_icon then
14545: LD_VAR 0 2
14549: PUSH
14550: LD_EXP 8
14554: EQUAL
14555: IFFALSE 14769
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14557: LD_VAR 0 3
14561: PUSH
14562: LD_INT 21
14564: PUSH
14565: LD_INT 3
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PPUSH
14572: CALL_OW 69
14576: IN
14577: IFFALSE 14769
// begin side := GetSide ( cr1 ) ;
14579: LD_ADDR_VAR 0 9
14583: PUSH
14584: LD_VAR 0 3
14588: PPUSH
14589: CALL_OW 255
14593: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14594: LD_INT 22
14596: PUSH
14597: LD_VAR 0 9
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PUSH
14606: LD_INT 30
14608: PUSH
14609: LD_INT 28
14611: PUSH
14612: EMPTY
14613: LIST
14614: LIST
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PPUSH
14620: CALL_OW 69
14624: PUSH
14625: LD_INT 0
14627: GREATER
14628: IFFALSE 14769
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14630: LD_ADDR_VAR 0 7
14634: PUSH
14635: LD_INT 22
14637: PUSH
14638: LD_VAR 0 9
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 2
14649: PUSH
14650: LD_INT 30
14652: PUSH
14653: LD_INT 26
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: PUSH
14660: LD_INT 30
14662: PUSH
14663: LD_INT 27
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: LD_INT 30
14672: PUSH
14673: LD_INT 28
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PPUSH
14690: CALL_OW 69
14694: PUSH
14695: FOR_IN
14696: IFFALSE 14712
// SetLives ( i , 1 ) ;
14698: LD_VAR 0 7
14702: PPUSH
14703: LD_INT 1
14705: PPUSH
14706: CALL_OW 234
14710: GO 14695
14712: POP
14713: POP
// player_res_art := false ;
14714: LD_ADDR_EXP 6
14718: PUSH
14719: LD_INT 0
14721: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14722: LD_OWVAR 2
14726: PPUSH
14727: LD_EXP 8
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: LD_VAR 0 8
14739: PPUSH
14740: CALL_OW 468
// Wait ( time_to_reuse ) ;
14744: LD_EXP 11
14748: PPUSH
14749: CALL_OW 67
// player_res_art := true ;
14753: LD_ADDR_EXP 6
14757: PUSH
14758: LD_INT 1
14760: ST_TO_ADDR
// medal_enabled := true ;
14761: LD_ADDR_EXP 13
14765: PUSH
14766: LD_INT 1
14768: ST_TO_ADDR
// end ; end ; end ; end ;
14769: PPOPN 9
14771: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14772: LD_VAR 0 1
14776: PPUSH
14777: CALL_OW 255
14781: PUSH
14782: LD_OWVAR 2
14786: EQUAL
14787: IFFALSE 14824
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14789: LD_OWVAR 2
14793: PPUSH
14794: LD_INT 1
14796: PPUSH
14797: LD_INT 0
14799: PPUSH
14800: LD_VAR 0 1
14804: PPUSH
14805: CALL_OW 468
// player_artifact_ready := true ;
14809: LD_ADDR_EXP 7
14813: PUSH
14814: LD_INT 1
14816: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14817: LD_STRING ArtVulcano
14819: PPUSH
14820: CALL_OW 339
// end ; end ;
14824: PPOPN 1
14826: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14827: LD_OWVAR 2
14831: PPUSH
14832: LD_INT 1
14834: PPUSH
14835: LD_INT 2
14837: PPUSH
14838: LD_VAR 0 1
14842: PPUSH
14843: CALL_OW 468
// end ; end_of_file
14847: PPOPN 2
14849: END
// every 0 0$01 do
14850: GO 14852
14852: DISABLE
// begin enable ;
14853: ENABLE
// Display_Strings := [ #tick , tick ] ;
14854: LD_ADDR_OWVAR 47
14858: PUSH
14859: LD_STRING #tick
14861: PUSH
14862: LD_OWVAR 1
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: ST_TO_ADDR
// end ; end_of_file
14871: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14872: LD_INT 0
14874: PPUSH
14875: PPUSH
14876: PPUSH
14877: PPUSH
14878: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14879: LD_ADDR_EXP 39
14883: PUSH
14884: LD_INT 7
14886: PUSH
14887: LD_INT 6
14889: PUSH
14890: LD_INT 5
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: PUSH
14898: LD_OWVAR 67
14902: ARRAY
14903: ST_TO_ADDR
// al_force := [ ] ;
14904: LD_ADDR_EXP 38
14908: PUSH
14909: EMPTY
14910: ST_TO_ADDR
// RemoveAlliance ;
14911: CALL 15289 0 0
// ResetFog ;
14915: CALL_OW 335
// your_side := 7 ;
14919: LD_ADDR_OWVAR 2
14923: PUSH
14924: LD_INT 7
14926: ST_TO_ADDR
// uc_side := 7 ;
14927: LD_ADDR_OWVAR 20
14931: PUSH
14932: LD_INT 7
14934: ST_TO_ADDR
// hc_gallery :=  ;
14935: LD_ADDR_OWVAR 33
14939: PUSH
14940: LD_STRING 
14942: ST_TO_ADDR
// hc_name :=  ;
14943: LD_ADDR_OWVAR 26
14947: PUSH
14948: LD_STRING 
14950: ST_TO_ADDR
// hc_importance := 0 ;
14951: LD_ADDR_OWVAR 32
14955: PUSH
14956: LD_INT 0
14958: ST_TO_ADDR
// for i = 1 to 17 do
14959: LD_ADDR_VAR 0 2
14963: PUSH
14964: DOUBLE
14965: LD_INT 1
14967: DEC
14968: ST_TO_ADDR
14969: LD_INT 17
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15053
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14975: LD_ADDR_OWVAR 21
14979: PUSH
14980: LD_INT 1
14982: PUSH
14983: LD_INT 3
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: PUSH
14990: LD_INT 1
14992: PPUSH
14993: LD_INT 2
14995: PPUSH
14996: CALL_OW 12
15000: ARRAY
15001: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15002: LD_INT 0
15004: PPUSH
15005: LD_INT 1
15007: PPUSH
15008: LD_INT 4
15010: PPUSH
15011: CALL_OW 12
15015: PPUSH
15016: LD_EXP 39
15020: PPUSH
15021: CALL_OW 380
// un := CreateHuman ;
15025: LD_ADDR_VAR 0 4
15029: PUSH
15030: CALL_OW 44
15034: ST_TO_ADDR
// al_force := al_force ^ un ;
15035: LD_ADDR_EXP 38
15039: PUSH
15040: LD_EXP 38
15044: PUSH
15045: LD_VAR 0 4
15049: ADD
15050: ST_TO_ADDR
// end ;
15051: GO 14972
15053: POP
15054: POP
// hc_importance := 100 ;
15055: LD_ADDR_OWVAR 32
15059: PUSH
15060: LD_INT 100
15062: ST_TO_ADDR
// uc_nation := 1 ;
15063: LD_ADDR_OWVAR 21
15067: PUSH
15068: LD_INT 1
15070: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15071: LD_INT 1
15073: PPUSH
15074: LD_INT 1
15076: PPUSH
15077: LD_EXP 39
15081: PPUSH
15082: CALL_OW 380
// al_commander := CreateHuman ;
15086: LD_ADDR_EXP 37
15090: PUSH
15091: CALL_OW 44
15095: ST_TO_ADDR
// player_commander := al_commander ;
15096: LD_ADDR_EXP 10
15100: PUSH
15101: LD_EXP 37
15105: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15106: LD_ADDR_VAR 0 5
15110: PUSH
15111: LD_STRING text
15113: PPUSH
15114: LD_INT 9
15116: PUSH
15117: LD_INT 9
15119: PUSH
15120: LD_INT 8
15122: PUSH
15123: EMPTY
15124: LIST
15125: LIST
15126: LIST
15127: PUSH
15128: LD_OWVAR 67
15132: ARRAY
15133: PPUSH
15134: LD_INT 9
15136: PUSH
15137: LD_INT 9
15139: PUSH
15140: LD_INT 8
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: LIST
15147: PUSH
15148: LD_OWVAR 67
15152: ARRAY
15153: PPUSH
15154: LD_INT -5
15156: PUSH
15157: LD_EXP 37
15161: PUSH
15162: LD_INT -3
15164: PUSH
15165: LD_INT -2
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: LIST
15172: LIST
15173: PUSH
15174: LD_EXP 38
15178: ADD
15179: PPUSH
15180: LD_INT 1
15182: PUSH
15183: LD_INT 3
15185: PUSH
15186: LD_INT 2
15188: PUSH
15189: LD_INT 1
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: PUSH
15196: LD_INT 4
15198: PUSH
15199: LD_INT 1
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PUSH
15206: LD_INT 9
15208: PUSH
15209: LD_INT 5
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL_OW 42
15224: ST_TO_ADDR
// team := team ^ al_commander ;
15225: LD_ADDR_VAR 0 5
15229: PUSH
15230: LD_VAR 0 5
15234: PUSH
15235: LD_EXP 37
15239: ADD
15240: ST_TO_ADDR
// for i = 1 to team do
15241: LD_ADDR_VAR 0 2
15245: PUSH
15246: DOUBLE
15247: LD_INT 1
15249: DEC
15250: ST_TO_ADDR
15251: LD_VAR 0 5
15255: PUSH
15256: FOR_TO
15257: IFFALSE 15282
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15259: LD_VAR 0 5
15263: PUSH
15264: LD_VAR 0 2
15268: ARRAY
15269: PPUSH
15270: LD_INT 15
15272: PPUSH
15273: LD_INT 0
15275: PPUSH
15276: CALL_OW 49
15280: GO 15256
15282: POP
15283: POP
// end ;
15284: LD_VAR 0 1
15288: RET
// export function RemoveAlliance ; var i ; begin
15289: LD_INT 0
15291: PPUSH
15292: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15293: LD_INT 22
15295: PUSH
15296: LD_INT 7
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: PUSH
15303: LD_INT 30
15305: PUSH
15306: LD_INT 1
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: PUSH
15313: EMPTY
15314: LIST
15315: LIST
15316: PPUSH
15317: CALL_OW 69
15321: PUSH
15322: LD_INT 1
15324: ARRAY
15325: PPUSH
15326: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15330: LD_ADDR_VAR 0 2
15334: PUSH
15335: LD_INT 22
15337: PUSH
15338: LD_INT 7
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: PPUSH
15345: CALL_OW 69
15349: PUSH
15350: FOR_IN
15351: IFFALSE 15364
// RemoveUnit ( i ) ;
15353: LD_VAR 0 2
15357: PPUSH
15358: CALL_OW 64
15362: GO 15350
15364: POP
15365: POP
// end ;
15366: LD_VAR 0 1
15370: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15371: LD_INT 0
15373: PPUSH
15374: PPUSH
15375: PPUSH
15376: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15377: LD_INT 31
15379: PPUSH
15380: LD_INT 7
15382: PPUSH
15383: LD_INT 2
15385: PPUSH
15386: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15390: LD_INT 32
15392: PPUSH
15393: LD_INT 7
15395: PPUSH
15396: LD_INT 2
15398: PPUSH
15399: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15403: LD_INT 59
15405: PPUSH
15406: LD_INT 7
15408: PPUSH
15409: LD_INT 2
15411: PPUSH
15412: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15416: LD_ADDR_EXP 39
15420: PUSH
15421: LD_INT 5
15423: PUSH
15424: LD_INT 6
15426: PUSH
15427: LD_INT 7
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: LIST
15434: PUSH
15435: LD_OWVAR 67
15439: ARRAY
15440: ST_TO_ADDR
// al_force := [ ] ;
15441: LD_ADDR_EXP 38
15445: PUSH
15446: EMPTY
15447: ST_TO_ADDR
// al_vehs := [ ] ;
15448: LD_ADDR_EXP 44
15452: PUSH
15453: EMPTY
15454: ST_TO_ADDR
// uc_side := 7 ;
15455: LD_ADDR_OWVAR 20
15459: PUSH
15460: LD_INT 7
15462: ST_TO_ADDR
// uc_nation := 1 ;
15463: LD_ADDR_OWVAR 21
15467: PUSH
15468: LD_INT 1
15470: ST_TO_ADDR
// bc_type := b_oil_mine ;
15471: LD_ADDR_OWVAR 42
15475: PUSH
15476: LD_INT 29
15478: ST_TO_ADDR
// b := CreateBuilding ;
15479: LD_ADDR_VAR 0 4
15483: PUSH
15484: CALL_OW 46
15488: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15489: LD_VAR 0 4
15493: PPUSH
15494: LD_INT 61
15496: PPUSH
15497: LD_INT 7
15499: PPUSH
15500: LD_INT 0
15502: PPUSH
15503: LD_INT 0
15505: PPUSH
15506: CALL_OW 50
// bc_type := b_siberite_mine ;
15510: LD_ADDR_OWVAR 42
15514: PUSH
15515: LD_INT 30
15517: ST_TO_ADDR
// b := CreateBuilding ;
15518: LD_ADDR_VAR 0 4
15522: PUSH
15523: CALL_OW 46
15527: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15528: LD_VAR 0 4
15532: PPUSH
15533: LD_INT 69
15535: PPUSH
15536: LD_INT 13
15538: PPUSH
15539: LD_INT 0
15541: PPUSH
15542: LD_INT 0
15544: PPUSH
15545: CALL_OW 50
// hc_gallery :=  ;
15549: LD_ADDR_OWVAR 33
15553: PUSH
15554: LD_STRING 
15556: ST_TO_ADDR
// hc_name :=  ;
15557: LD_ADDR_OWVAR 26
15561: PUSH
15562: LD_STRING 
15564: ST_TO_ADDR
// hc_importance := 0 ;
15565: LD_ADDR_OWVAR 32
15569: PUSH
15570: LD_INT 0
15572: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15573: LD_ADDR_VAR 0 2
15577: PUSH
15578: LD_INT 22
15580: PUSH
15581: LD_INT 7
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: PUSH
15588: LD_INT 30
15590: PUSH
15591: LD_INT 32
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: PUSH
15607: FOR_IN
15608: IFFALSE 15678
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15610: LD_ADDR_OWVAR 21
15614: PUSH
15615: LD_INT 1
15617: PUSH
15618: LD_INT 3
15620: PUSH
15621: EMPTY
15622: LIST
15623: LIST
15624: PUSH
15625: LD_INT 1
15627: PPUSH
15628: LD_INT 2
15630: PPUSH
15631: CALL_OW 12
15635: ARRAY
15636: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15637: LD_INT 0
15639: PPUSH
15640: LD_INT 1
15642: PPUSH
15643: LD_EXP 39
15647: PPUSH
15648: CALL_OW 380
// un := CreateHuman ;
15652: LD_ADDR_VAR 0 3
15656: PUSH
15657: CALL_OW 44
15661: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15662: LD_VAR 0 3
15666: PPUSH
15667: LD_VAR 0 2
15671: PPUSH
15672: CALL_OW 52
// end ;
15676: GO 15607
15678: POP
15679: POP
// for i = 1 to 3 do
15680: LD_ADDR_VAR 0 2
15684: PUSH
15685: DOUBLE
15686: LD_INT 1
15688: DEC
15689: ST_TO_ADDR
15690: LD_INT 3
15692: PUSH
15693: FOR_TO
15694: IFFALSE 15762
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15696: LD_ADDR_OWVAR 21
15700: PUSH
15701: LD_INT 1
15703: PUSH
15704: LD_INT 3
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PUSH
15711: LD_INT 1
15713: PPUSH
15714: LD_INT 2
15716: PPUSH
15717: CALL_OW 12
15721: ARRAY
15722: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15723: LD_INT 0
15725: PPUSH
15726: LD_INT 4
15728: PPUSH
15729: LD_EXP 39
15733: PPUSH
15734: CALL_OW 380
// un := CreateHuman ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: CALL_OW 44
15747: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15748: LD_VAR 0 3
15752: PPUSH
15753: LD_INT 164
15755: PPUSH
15756: CALL_OW 52
// end ;
15760: GO 15693
15762: POP
15763: POP
// for i = 1 to 6 do
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: DOUBLE
15770: LD_INT 1
15772: DEC
15773: ST_TO_ADDR
15774: LD_INT 6
15776: PUSH
15777: FOR_TO
15778: IFFALSE 15869
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15780: LD_ADDR_OWVAR 21
15784: PUSH
15785: LD_INT 1
15787: PUSH
15788: LD_INT 3
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 1
15797: PPUSH
15798: LD_INT 2
15800: PPUSH
15801: CALL_OW 12
15805: ARRAY
15806: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15807: LD_INT 0
15809: PPUSH
15810: LD_INT 5
15812: PUSH
15813: LD_INT 9
15815: PUSH
15816: LD_INT 9
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: LIST
15823: PUSH
15824: LD_INT 1
15826: PPUSH
15827: LD_INT 3
15829: PPUSH
15830: CALL_OW 12
15834: ARRAY
15835: PPUSH
15836: LD_EXP 39
15840: PPUSH
15841: CALL_OW 380
// un := CreateHuman ;
15845: LD_ADDR_VAR 0 3
15849: PUSH
15850: CALL_OW 44
15854: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15855: LD_VAR 0 3
15859: PPUSH
15860: LD_INT 173
15862: PPUSH
15863: CALL_OW 52
// end ;
15867: GO 15777
15869: POP
15870: POP
// for i = 1 to 6 do
15871: LD_ADDR_VAR 0 2
15875: PUSH
15876: DOUBLE
15877: LD_INT 1
15879: DEC
15880: ST_TO_ADDR
15881: LD_INT 6
15883: PUSH
15884: FOR_TO
15885: IFFALSE 15983
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15887: LD_ADDR_OWVAR 21
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: LD_INT 3
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PUSH
15902: LD_INT 1
15904: PPUSH
15905: LD_INT 2
15907: PPUSH
15908: CALL_OW 12
15912: ARRAY
15913: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15914: LD_INT 0
15916: PPUSH
15917: LD_INT 3
15919: PPUSH
15920: LD_EXP 39
15924: PPUSH
15925: CALL_OW 380
// un := CreateHuman ;
15929: LD_ADDR_VAR 0 3
15933: PUSH
15934: CALL_OW 44
15938: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15939: LD_VAR 0 3
15943: PPUSH
15944: LD_INT 22
15946: PUSH
15947: LD_INT 7
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: LD_INT 30
15956: PUSH
15957: LD_INT 3
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: PPUSH
15968: CALL_OW 69
15972: PUSH
15973: LD_INT 1
15975: ARRAY
15976: PPUSH
15977: CALL_OW 52
// end ;
15981: GO 15884
15983: POP
15984: POP
// for i = 1 to 4 do
15985: LD_ADDR_VAR 0 2
15989: PUSH
15990: DOUBLE
15991: LD_INT 1
15993: DEC
15994: ST_TO_ADDR
15995: LD_INT 4
15997: PUSH
15998: FOR_TO
15999: IFFALSE 16067
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16001: LD_ADDR_OWVAR 21
16005: PUSH
16006: LD_INT 1
16008: PUSH
16009: LD_INT 3
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 1
16018: PPUSH
16019: LD_INT 2
16021: PPUSH
16022: CALL_OW 12
16026: ARRAY
16027: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16028: LD_INT 0
16030: PPUSH
16031: LD_INT 2
16033: PPUSH
16034: LD_EXP 39
16038: PPUSH
16039: CALL_OW 380
// un := CreateHuman ;
16043: LD_ADDR_VAR 0 3
16047: PUSH
16048: CALL_OW 44
16052: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16053: LD_VAR 0 3
16057: PPUSH
16058: LD_INT 162
16060: PPUSH
16061: CALL_OW 52
// end ;
16065: GO 15998
16067: POP
16068: POP
// uc_nation := 3 ;
16069: LD_ADDR_OWVAR 21
16073: PUSH
16074: LD_INT 3
16076: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16077: LD_ADDR_OWVAR 37
16081: PUSH
16082: LD_INT 21
16084: ST_TO_ADDR
// vc_engine := engine_siberite ;
16085: LD_ADDR_OWVAR 39
16089: PUSH
16090: LD_INT 3
16092: ST_TO_ADDR
// vc_control := control_computer ;
16093: LD_ADDR_OWVAR 38
16097: PUSH
16098: LD_INT 3
16100: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16101: LD_ADDR_OWVAR 40
16105: PUSH
16106: LD_INT 51
16108: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16109: CALL_OW 45
16113: PPUSH
16114: LD_INT 49
16116: PPUSH
16117: LD_INT 13
16119: PPUSH
16120: LD_INT 0
16122: PPUSH
16123: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16127: LD_ADDR_EXP 46
16131: PUSH
16132: LD_INT 22
16134: PUSH
16135: LD_INT 7
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PUSH
16142: LD_INT 30
16144: PUSH
16145: LD_INT 33
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PPUSH
16156: CALL_OW 69
16160: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16161: LD_ADDR_VAR 0 2
16165: PUSH
16166: DOUBLE
16167: LD_INT 1
16169: DEC
16170: ST_TO_ADDR
16171: LD_INT 22
16173: PUSH
16174: LD_INT 7
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: PUSH
16181: LD_INT 30
16183: PUSH
16184: LD_INT 33
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: PUSH
16191: LD_INT 35
16193: PUSH
16194: LD_INT 0
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: LIST
16205: PUSH
16206: EMPTY
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PUSH
16214: FOR_TO
16215: IFFALSE 16275
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16217: LD_INT 22
16219: PUSH
16220: LD_INT 7
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: PUSH
16227: LD_INT 30
16229: PUSH
16230: LD_INT 33
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: PUSH
16237: LD_INT 35
16239: PUSH
16240: LD_INT 0
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: PUSH
16247: EMPTY
16248: LIST
16249: LIST
16250: LIST
16251: PUSH
16252: EMPTY
16253: LIST
16254: PPUSH
16255: CALL_OW 69
16259: PUSH
16260: LD_VAR 0 2
16264: ARRAY
16265: PPUSH
16266: LD_INT 49
16268: PPUSH
16269: CALL_OW 208
16273: GO 16214
16275: POP
16276: POP
// end ;
16277: LD_VAR 0 1
16281: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16282: LD_OWVAR 2
16286: PUSH
16287: LD_INT 1
16289: EQUAL
16290: IFFALSE 17458
16292: GO 16294
16294: DISABLE
16295: LD_INT 0
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
// begin enable ;
16301: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16302: LD_ADDR_EXP 50
16306: PUSH
16307: LD_INT 22
16309: PUSH
16310: LD_INT 7
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PUSH
16317: LD_INT 21
16319: PUSH
16320: LD_INT 3
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PPUSH
16331: CALL_OW 69
16335: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16336: LD_ADDR_EXP 48
16340: PUSH
16341: LD_INT 164
16343: PUSH
16344: LD_INT 197
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16351: LD_ADDR_EXP 47
16355: PUSH
16356: LD_INT 22
16358: PUSH
16359: LD_INT 7
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 30
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: PPUSH
16380: CALL_OW 69
16384: PUSH
16385: LD_INT 1
16387: ARRAY
16388: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16389: LD_ADDR_EXP 49
16393: PUSH
16394: LD_INT 22
16396: PUSH
16397: LD_INT 7
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: PUSH
16404: LD_INT 30
16406: PUSH
16407: LD_INT 3
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PPUSH
16418: CALL_OW 69
16422: PUSH
16423: LD_INT 1
16425: ARRAY
16426: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16427: LD_INT 22
16429: PUSH
16430: LD_INT 7
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PUSH
16437: LD_INT 34
16439: PUSH
16440: LD_INT 51
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: PUSH
16447: EMPTY
16448: LIST
16449: LIST
16450: PPUSH
16451: CALL_OW 69
16455: IFFALSE 16495
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16457: LD_ADDR_EXP 45
16461: PUSH
16462: LD_INT 22
16464: PUSH
16465: LD_INT 7
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 34
16474: PUSH
16475: LD_INT 51
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PPUSH
16486: CALL_OW 69
16490: PUSH
16491: LD_INT 1
16493: ARRAY
16494: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16495: LD_ADDR_EXP 41
16499: PUSH
16500: LD_INT 22
16502: PUSH
16503: LD_INT 7
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PUSH
16510: LD_INT 25
16512: PUSH
16513: LD_INT 9
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PPUSH
16524: CALL_OW 69
16528: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16529: LD_ADDR_EXP 40
16533: PUSH
16534: LD_INT 22
16536: PUSH
16537: LD_INT 7
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PUSH
16544: LD_INT 25
16546: PUSH
16547: LD_INT 2
16549: PUSH
16550: EMPTY
16551: LIST
16552: LIST
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PPUSH
16558: CALL_OW 69
16562: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16563: LD_ADDR_EXP 42
16567: PUSH
16568: LD_INT 22
16570: PUSH
16571: LD_INT 7
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: LD_INT 25
16580: PUSH
16581: LD_INT 3
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PPUSH
16592: CALL_OW 69
16596: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16597: LD_ADDR_EXP 43
16601: PUSH
16602: LD_INT 22
16604: PUSH
16605: LD_INT 7
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 25
16614: PUSH
16615: LD_INT 4
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: PPUSH
16626: CALL_OW 69
16630: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16631: LD_EXP 41
16635: PPUSH
16636: LD_INT 81
16638: PUSH
16639: LD_INT 7
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PPUSH
16646: CALL_OW 69
16650: PPUSH
16651: CALL 1656 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16655: LD_EXP 45
16659: PPUSH
16660: CALL_OW 314
16664: NOT
16665: PUSH
16666: LD_EXP 45
16670: PPUSH
16671: LD_INT 1
16673: PPUSH
16674: CALL_OW 289
16678: PUSH
16679: LD_INT 100
16681: LESS
16682: AND
16683: IFFALSE 16731
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16685: LD_ADDR_VAR 0 4
16689: PUSH
16690: LD_INT 12
16692: PPUSH
16693: CALL_OW 435
16697: ST_TO_ADDR
// if cr then
16698: LD_VAR 0 4
16702: IFFALSE 16731
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16704: LD_EXP 45
16708: PPUSH
16709: LD_VAR 0 4
16713: PUSH
16714: LD_INT 1
16716: ARRAY
16717: PPUSH
16718: LD_VAR 0 4
16722: PUSH
16723: LD_INT 2
16725: ARRAY
16726: PPUSH
16727: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16731: LD_EXP 50
16735: PPUSH
16736: LD_INT 3
16738: PUSH
16739: LD_INT 24
16741: PUSH
16742: LD_INT 1000
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PUSH
16749: EMPTY
16750: LIST
16751: LIST
16752: PPUSH
16753: CALL_OW 72
16757: IFFALSE 16887
// begin if al_eng then
16759: LD_EXP 40
16763: IFFALSE 16885
// for i = 1 to al_eng do
16765: LD_ADDR_VAR 0 1
16769: PUSH
16770: DOUBLE
16771: LD_INT 1
16773: DEC
16774: ST_TO_ADDR
16775: LD_EXP 40
16779: PUSH
16780: FOR_TO
16781: IFFALSE 16883
// if IsInUnit ( al_eng [ i ] ) then
16783: LD_EXP 40
16787: PUSH
16788: LD_VAR 0 1
16792: ARRAY
16793: PPUSH
16794: CALL_OW 310
16798: IFFALSE 16817
// ComExitBuilding ( al_eng [ i ] ) else
16800: LD_EXP 40
16804: PUSH
16805: LD_VAR 0 1
16809: ARRAY
16810: PPUSH
16811: CALL_OW 122
16815: GO 16881
// if not HasTask ( al_eng [ i ] ) then
16817: LD_EXP 40
16821: PUSH
16822: LD_VAR 0 1
16826: ARRAY
16827: PPUSH
16828: CALL_OW 314
16832: NOT
16833: IFFALSE 16881
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16835: LD_EXP 40
16839: PUSH
16840: LD_VAR 0 1
16844: ARRAY
16845: PPUSH
16846: LD_EXP 50
16850: PPUSH
16851: LD_INT 3
16853: PUSH
16854: LD_INT 24
16856: PUSH
16857: LD_INT 1000
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PPUSH
16868: CALL_OW 72
16872: PUSH
16873: LD_INT 1
16875: ARRAY
16876: PPUSH
16877: CALL_OW 130
16881: GO 16780
16883: POP
16884: POP
// end else
16885: GO 16969
// if al_eng then
16887: LD_EXP 40
16891: IFFALSE 16969
// if not IsInUnit ( al_eng [ 1 ] ) then
16893: LD_EXP 40
16897: PUSH
16898: LD_INT 1
16900: ARRAY
16901: PPUSH
16902: CALL_OW 310
16906: NOT
16907: IFFALSE 16969
// for i = 1 to al_eng do
16909: LD_ADDR_VAR 0 1
16913: PUSH
16914: DOUBLE
16915: LD_INT 1
16917: DEC
16918: ST_TO_ADDR
16919: LD_EXP 40
16923: PUSH
16924: FOR_TO
16925: IFFALSE 16967
// if not IsInUnit ( al_eng [ i ] ) then
16927: LD_EXP 40
16931: PUSH
16932: LD_VAR 0 1
16936: ARRAY
16937: PPUSH
16938: CALL_OW 310
16942: NOT
16943: IFFALSE 16965
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16945: LD_EXP 40
16949: PUSH
16950: LD_VAR 0 1
16954: ARRAY
16955: PPUSH
16956: LD_EXP 47
16960: PPUSH
16961: CALL_OW 120
16965: GO 16924
16967: POP
16968: POP
// if al_vehs then
16969: LD_EXP 44
16973: IFFALSE 17073
// if BuildingStatus ( al_fac ) = bs_idle then
16975: LD_EXP 49
16979: PPUSH
16980: CALL_OW 461
16984: PUSH
16985: LD_INT 2
16987: EQUAL
16988: IFFALSE 17073
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16990: LD_EXP 49
16994: PPUSH
16995: LD_EXP 44
16999: PUSH
17000: LD_INT 1
17002: ARRAY
17003: PPUSH
17004: LD_EXP 44
17008: PUSH
17009: LD_INT 2
17011: ARRAY
17012: PPUSH
17013: LD_EXP 44
17017: PUSH
17018: LD_INT 3
17020: ARRAY
17021: PPUSH
17022: LD_EXP 44
17026: PUSH
17027: LD_INT 4
17029: ARRAY
17030: PPUSH
17031: CALL_OW 125
// for i = 1 to 4 do
17035: LD_ADDR_VAR 0 1
17039: PUSH
17040: DOUBLE
17041: LD_INT 1
17043: DEC
17044: ST_TO_ADDR
17045: LD_INT 4
17047: PUSH
17048: FOR_TO
17049: IFFALSE 17071
// al_vehs := Delete ( al_vehs , 1 ) ;
17051: LD_ADDR_EXP 44
17055: PUSH
17056: LD_EXP 44
17060: PPUSH
17061: LD_INT 1
17063: PPUSH
17064: CALL_OW 3
17068: ST_TO_ADDR
17069: GO 17048
17071: POP
17072: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17073: LD_EXP 38
17077: PUSH
17078: LD_INT 0
17080: EQUAL
17081: PUSH
17082: LD_OWVAR 1
17086: PUSH
17087: LD_INT 23100
17089: MOD
17090: PUSH
17091: LD_INT 0
17093: EQUAL
17094: AND
17095: IFFALSE 17209
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17097: LD_ADDR_VAR 0 1
17101: PUSH
17102: DOUBLE
17103: LD_INT 1
17105: DEC
17106: ST_TO_ADDR
17107: LD_INT 4
17109: PUSH
17110: LD_INT 5
17112: PUSH
17113: LD_INT 6
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: LIST
17120: PUSH
17121: LD_OWVAR 67
17125: ARRAY
17126: PUSH
17127: FOR_TO
17128: IFFALSE 17207
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17130: LD_ADDR_EXP 44
17134: PUSH
17135: LD_EXP 44
17139: PUSH
17140: LD_INT 23
17142: ADD
17143: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17144: LD_ADDR_EXP 44
17148: PUSH
17149: LD_EXP 44
17153: PUSH
17154: LD_INT 1
17156: ADD
17157: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17158: LD_ADDR_EXP 44
17162: PUSH
17163: LD_EXP 44
17167: PUSH
17168: LD_INT 3
17170: ADD
17171: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17172: LD_ADDR_EXP 44
17176: PUSH
17177: LD_EXP 44
17181: PUSH
17182: LD_INT 46
17184: PUSH
17185: LD_INT 47
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 1
17194: PPUSH
17195: LD_INT 2
17197: PPUSH
17198: CALL_OW 12
17202: ARRAY
17203: ADD
17204: ST_TO_ADDR
// end ;
17205: GO 17127
17207: POP
17208: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17209: LD_INT 22
17211: PUSH
17212: LD_INT 7
17214: PUSH
17215: EMPTY
17216: LIST
17217: LIST
17218: PUSH
17219: LD_INT 34
17221: PUSH
17222: LD_INT 51
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PPUSH
17233: CALL_OW 69
17237: PUSH
17238: LD_INT 0
17240: EQUAL
17241: IFFALSE 17264
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17243: LD_EXP 49
17247: PPUSH
17248: LD_INT 21
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: LD_INT 3
17256: PPUSH
17257: LD_INT 51
17259: PPUSH
17260: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17264: LD_EXP 38
17268: PUSH
17269: LD_OWVAR 1
17273: PUSH
17274: LD_INT 25200
17276: MOD
17277: PUSH
17278: LD_INT 0
17280: EQUAL
17281: AND
17282: IFFALSE 17345
// begin for i = 1 to al_force do
17284: LD_ADDR_VAR 0 1
17288: PUSH
17289: DOUBLE
17290: LD_INT 1
17292: DEC
17293: ST_TO_ADDR
17294: LD_EXP 38
17298: PUSH
17299: FOR_TO
17300: IFFALSE 17343
// if GetTag ( al_force [ i ] ) <> 11 then
17302: LD_EXP 38
17306: PUSH
17307: LD_VAR 0 1
17311: ARRAY
17312: PPUSH
17313: CALL_OW 110
17317: PUSH
17318: LD_INT 11
17320: NONEQUAL
17321: IFFALSE 17341
// SetTag ( al_force [ i ] , 11 ) ;
17323: LD_EXP 38
17327: PUSH
17328: LD_VAR 0 1
17332: ARRAY
17333: PPUSH
17334: LD_INT 11
17336: PPUSH
17337: CALL_OW 109
17341: GO 17299
17343: POP
17344: POP
// end ; if al_force then
17345: LD_EXP 38
17349: IFFALSE 17458
// for i = 1 to al_force do
17351: LD_ADDR_VAR 0 1
17355: PUSH
17356: DOUBLE
17357: LD_INT 1
17359: DEC
17360: ST_TO_ADDR
17361: LD_EXP 38
17365: PUSH
17366: FOR_TO
17367: IFFALSE 17456
// begin if GetTag ( al_force [ i ] ) = 11 then
17369: LD_EXP 38
17373: PUSH
17374: LD_VAR 0 1
17378: ARRAY
17379: PPUSH
17380: CALL_OW 110
17384: PUSH
17385: LD_INT 11
17387: EQUAL
17388: IFFALSE 17454
// begin if not HasTask ( al_force [ i ] ) then
17390: LD_EXP 38
17394: PUSH
17395: LD_VAR 0 1
17399: ARRAY
17400: PPUSH
17401: CALL_OW 314
17405: NOT
17406: IFFALSE 17454
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17408: LD_EXP 38
17412: PUSH
17413: LD_VAR 0 1
17417: ARRAY
17418: PPUSH
17419: LD_INT 81
17421: PUSH
17422: LD_INT 7
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PPUSH
17429: CALL_OW 69
17433: PPUSH
17434: LD_EXP 38
17438: PUSH
17439: LD_VAR 0 1
17443: ARRAY
17444: PPUSH
17445: CALL_OW 74
17449: PPUSH
17450: CALL_OW 115
// end ; end ;
17454: GO 17366
17456: POP
17457: POP
// end ; end_of_file
17458: PPOPN 4
17460: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17461: LD_INT 0
17463: PPUSH
17464: PPUSH
17465: PPUSH
17466: PPUSH
17467: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17468: LD_ADDR_EXP 53
17472: PUSH
17473: LD_INT 7
17475: PUSH
17476: LD_INT 6
17478: PUSH
17479: LD_INT 5
17481: PUSH
17482: EMPTY
17483: LIST
17484: LIST
17485: LIST
17486: PUSH
17487: LD_OWVAR 67
17491: ARRAY
17492: ST_TO_ADDR
// ar_force := [ ] ;
17493: LD_ADDR_EXP 52
17497: PUSH
17498: EMPTY
17499: ST_TO_ADDR
// RemoveAlliance ;
17500: CALL 15289 0 0
// RemoveEnvironmentArea ( evn ) ;
17504: LD_INT 17
17506: PPUSH
17507: CALL_OW 355
// your_side := 2 ;
17511: LD_ADDR_OWVAR 2
17515: PUSH
17516: LD_INT 2
17518: ST_TO_ADDR
// uc_side := 2 ;
17519: LD_ADDR_OWVAR 20
17523: PUSH
17524: LD_INT 2
17526: ST_TO_ADDR
// uc_nation := nation_arabian ;
17527: LD_ADDR_OWVAR 21
17531: PUSH
17532: LD_INT 2
17534: ST_TO_ADDR
// hc_gallery :=  ;
17535: LD_ADDR_OWVAR 33
17539: PUSH
17540: LD_STRING 
17542: ST_TO_ADDR
// hc_name :=  ;
17543: LD_ADDR_OWVAR 26
17547: PUSH
17548: LD_STRING 
17550: ST_TO_ADDR
// hc_importance := 0 ;
17551: LD_ADDR_OWVAR 32
17555: PUSH
17556: LD_INT 0
17558: ST_TO_ADDR
// for i = 1 to 15 do
17559: LD_ADDR_VAR 0 2
17563: PUSH
17564: DOUBLE
17565: LD_INT 1
17567: DEC
17568: ST_TO_ADDR
17569: LD_INT 15
17571: PUSH
17572: FOR_TO
17573: IFFALSE 17626
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17575: LD_INT 0
17577: PPUSH
17578: LD_INT 1
17580: PPUSH
17581: LD_INT 4
17583: PPUSH
17584: CALL_OW 12
17588: PPUSH
17589: LD_EXP 53
17593: PPUSH
17594: CALL_OW 380
// un := CreateHuman ;
17598: LD_ADDR_VAR 0 4
17602: PUSH
17603: CALL_OW 44
17607: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17608: LD_ADDR_EXP 52
17612: PUSH
17613: LD_EXP 52
17617: PUSH
17618: LD_VAR 0 4
17622: ADD
17623: ST_TO_ADDR
// end ;
17624: GO 17572
17626: POP
17627: POP
// hc_importance := 100 ;
17628: LD_ADDR_OWVAR 32
17632: PUSH
17633: LD_INT 100
17635: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17636: LD_INT 1
17638: PPUSH
17639: LD_INT 11
17641: PPUSH
17642: LD_EXP 53
17646: PPUSH
17647: CALL_OW 380
// ar_commander := CreateHuman ;
17651: LD_ADDR_EXP 51
17655: PUSH
17656: CALL_OW 44
17660: ST_TO_ADDR
// player_commander := ar_commander ;
17661: LD_ADDR_EXP 10
17665: PUSH
17666: LD_EXP 51
17670: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17671: LD_ADDR_VAR 0 5
17675: PUSH
17676: LD_STRING text
17678: PPUSH
17679: LD_INT 11
17681: PUSH
17682: LD_INT 10
17684: PUSH
17685: LD_INT 9
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: PUSH
17693: LD_OWVAR 67
17697: ARRAY
17698: PPUSH
17699: LD_INT 11
17701: PUSH
17702: LD_INT 10
17704: PUSH
17705: LD_INT 9
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: LIST
17712: PUSH
17713: LD_OWVAR 67
17717: ARRAY
17718: PPUSH
17719: LD_INT -5
17721: PUSH
17722: LD_EXP 51
17726: PUSH
17727: LD_INT -3
17729: PUSH
17730: LD_INT -2
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: PUSH
17739: LD_EXP 52
17743: ADD
17744: PPUSH
17745: LD_INT 1
17747: PUSH
17748: LD_INT 3
17750: PUSH
17751: LD_INT 2
17753: PUSH
17754: LD_INT 1
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: PUSH
17761: LD_INT 4
17763: PUSH
17764: LD_INT 1
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: PUSH
17771: LD_INT 8
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 42
17785: ST_TO_ADDR
// team := team ^ ar_commander ;
17786: LD_ADDR_VAR 0 5
17790: PUSH
17791: LD_VAR 0 5
17795: PUSH
17796: LD_EXP 51
17800: ADD
17801: ST_TO_ADDR
// for i = 1 to team do
17802: LD_ADDR_VAR 0 2
17806: PUSH
17807: DOUBLE
17808: LD_INT 1
17810: DEC
17811: ST_TO_ADDR
17812: LD_VAR 0 5
17816: PUSH
17817: FOR_TO
17818: IFFALSE 17843
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17820: LD_VAR 0 5
17824: PUSH
17825: LD_VAR 0 2
17829: ARRAY
17830: PPUSH
17831: LD_INT 16
17833: PPUSH
17834: LD_INT 0
17836: PPUSH
17837: CALL_OW 49
17841: GO 17817
17843: POP
17844: POP
// uc_side := 0 ;
17845: LD_ADDR_OWVAR 20
17849: PUSH
17850: LD_INT 0
17852: ST_TO_ADDR
// uc_nation := 0 ;
17853: LD_ADDR_OWVAR 21
17857: PUSH
17858: LD_INT 0
17860: ST_TO_ADDR
// vc_chassis := 31 ;
17861: LD_ADDR_OWVAR 37
17865: PUSH
17866: LD_INT 31
17868: ST_TO_ADDR
// vc_control := control_rider ;
17869: LD_ADDR_OWVAR 38
17873: PUSH
17874: LD_INT 4
17876: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17877: CALL_OW 45
17881: PPUSH
17882: LD_INT 96
17884: PPUSH
17885: LD_INT 20
17887: PPUSH
17888: LD_INT 0
17890: PPUSH
17891: CALL_OW 48
// end ;
17895: LD_VAR 0 1
17899: RET
