// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3523 0 0
// PrepareLegion ;
  27: CALL 7054 0 0
// Action ;
  31: CALL 10733 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 15355 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ;
3486: PPOPN 1
3488: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3489: LD_VAR 0 1
3493: PPUSH
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_VAR 0 3
3503: PPUSH
3504: CALL 17928 0 3
// end ;
3508: PPOPN 3
3510: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: CALL 18026 0 1
// end ; end_of_file
3520: PPOPN 1
3522: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3523: LD_INT 0
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
3529: PPUSH
3530: PPUSH
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
// uc_side := 3 ;
3536: LD_ADDR_OWVAR 20
3540: PUSH
3541: LD_INT 3
3543: ST_TO_ADDR
// uc_nation := nation_russian ;
3544: LD_ADDR_OWVAR 21
3548: PUSH
3549: LD_INT 3
3551: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3552: LD_ADDR_VAR 0 4
3556: PUSH
3557: LD_INT 22
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 30
3569: PUSH
3570: LD_INT 1
3572: PUSH
3573: EMPTY
3574: LIST
3575: LIST
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PPUSH
3581: CALL_OW 69
3585: PUSH
3586: LD_INT 1
3588: ARRAY
3589: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3590: LD_ADDR_VAR 0 5
3594: PUSH
3595: LD_INT 22
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 30
3607: PUSH
3608: LD_INT 3
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PPUSH
3619: CALL_OW 69
3623: PUSH
3624: LD_INT 1
3626: ARRAY
3627: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_INT 22
3635: PUSH
3636: LD_INT 3
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 30
3645: PUSH
3646: LD_INT 34
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 69
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3666: LD_ADDR_VAR 0 8
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 33
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3700: LD_ADDR_VAR 0 7
3704: PUSH
3705: LD_INT 22
3707: PUSH
3708: LD_INT 3
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 30
3717: PUSH
3718: LD_INT 5
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PPUSH
3729: CALL_OW 69
3733: PUSH
3734: LD_INT 1
3736: ARRAY
3737: ST_TO_ADDR
// ru_blist := [ ] ;
3738: LD_ADDR_EXP 26
3742: PUSH
3743: EMPTY
3744: ST_TO_ADDR
// ru_vlist := [ ] ;
3745: LD_ADDR_EXP 27
3749: PUSH
3750: EMPTY
3751: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3752: LD_ADDR_EXP 30
3756: PUSH
3757: LD_INT 183
3759: PUSH
3760: LD_INT 62
3762: PUSH
3763: LD_INT 147
3765: PUSH
3766: LD_INT 44
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3775: LD_INT 30
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PPUSH
3785: CALL_OW 69
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_EXP 30
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 2
3810: ARRAY
3811: PPUSH
3812: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3816: LD_ADDR_EXP 28
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: LD_INT 5
3826: PUSH
3827: LD_INT 6
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: LIST
3834: PUSH
3835: LD_OWVAR 67
3839: ARRAY
3840: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3841: LD_VAR 0 4
3845: PPUSH
3846: CALL_OW 274
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 3000
3856: PPUSH
3857: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3861: LD_VAR 0 4
3865: PPUSH
3866: CALL_OW 274
3870: PPUSH
3871: LD_INT 2
3873: PPUSH
3874: LD_INT 300
3876: PPUSH
3877: CALL_OW 277
// hc_gallery :=  ;
3881: LD_ADDR_OWVAR 33
3885: PUSH
3886: LD_STRING 
3888: ST_TO_ADDR
// hc_name :=  ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING 
3896: ST_TO_ADDR
// hc_importance := 0 ;
3897: LD_ADDR_OWVAR 32
3901: PUSH
3902: LD_INT 0
3904: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3905: LD_ADDR_EXP 24
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: LD_INT 6
3915: PUSH
3916: LD_INT 7
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: ST_TO_ADDR
// for i = 1 to 6 do
3930: LD_ADDR_VAR 0 2
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 6
3942: PUSH
3943: FOR_TO
3944: IFFALSE 4102
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3946: LD_INT 0
3948: PPUSH
3949: LD_INT 9
3951: PPUSH
3952: LD_EXP 24
3956: PPUSH
3957: CALL_OW 380
// un := CreateHuman ;
3961: LD_ADDR_VAR 0 3
3965: PUSH
3966: CALL_OW 44
3970: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_VAR 0 7
3980: PPUSH
3981: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 4
3990: PPUSH
3991: LD_EXP 24
3995: PPUSH
3996: CALL_OW 380
// un := CreateHuman ;
4000: LD_ADDR_VAR 0 3
4004: PUSH
4005: CALL_OW 44
4009: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4010: LD_VAR 0 3
4014: PPUSH
4015: LD_INT 24
4017: PPUSH
4018: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4022: LD_INT 0
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_EXP 24
4032: PPUSH
4033: CALL_OW 380
// un := CreateHuman ;
4037: LD_ADDR_VAR 0 3
4041: PUSH
4042: CALL_OW 44
4046: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_VAR 0 5
4056: PPUSH
4057: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4061: LD_INT 0
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: LD_EXP 24
4071: PPUSH
4072: CALL_OW 380
// un := CreateHuman ;
4076: LD_ADDR_VAR 0 3
4080: PUSH
4081: CALL_OW 44
4085: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_VAR 0 4
4095: PPUSH
4096: CALL_OW 52
// end ;
4100: GO 3943
4102: POP
4103: POP
// russian_prepared := true ;
4104: LD_ADDR_EXP 2
4108: PUSH
4109: LD_INT 1
4111: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_INT 21
4119: PPUSH
4120: LD_INT 3
4122: PPUSH
4123: LD_INT 3
4125: PPUSH
4126: LD_INT 51
4128: PPUSH
4129: CALL_OW 125
// end ;
4133: LD_VAR 0 1
4137: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4138: LD_INT 22
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 69
4152: PUSH
4153: LD_INT 0
4155: GREATER
4156: PUSH
4157: LD_EXP 2
4161: AND
4162: IFFALSE 6625
4164: GO 4166
4166: DISABLE
4167: LD_INT 0
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
4173: PPUSH
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
// begin enable ;
4186: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4187: LD_ADDR_VAR 0 1
4191: PUSH
4192: LD_INT 22
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 30
4204: PUSH
4205: LD_INT 1
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PPUSH
4216: CALL_OW 69
4220: PUSH
4221: LD_INT 1
4223: ARRAY
4224: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: LD_INT 22
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 30
4242: PUSH
4243: LD_INT 3
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: PUSH
4259: LD_INT 1
4261: ARRAY
4262: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4263: LD_ADDR_VAR 0 3
4267: PUSH
4268: LD_INT 22
4270: PUSH
4271: LD_INT 3
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PUSH
4278: LD_INT 30
4280: PUSH
4281: LD_INT 34
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PPUSH
4292: CALL_OW 69
4296: PUSH
4297: LD_INT 1
4299: ARRAY
4300: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4301: LD_ADDR_VAR 0 4
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4335: LD_ADDR_VAR 0 8
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 3
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 30
4352: PUSH
4353: LD_INT 5
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PPUSH
4364: CALL_OW 69
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4373: LD_ADDR_VAR 0 5
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4407: LD_ADDR_VAR 0 6
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4441: LD_ADDR_VAR 0 7
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 1
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4475: LD_ADDR_VAR 0 9
4479: PUSH
4480: LD_VAR 0 7
4484: PPUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PPUSH
4495: CALL_OW 72
4499: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4500: LD_ADDR_VAR 0 10
4504: PUSH
4505: LD_VAR 0 7
4509: PPUSH
4510: LD_INT 25
4512: PUSH
4513: LD_INT 3
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 72
4524: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4525: LD_ADDR_VAR 0 11
4529: PUSH
4530: LD_VAR 0 7
4534: PPUSH
4535: LD_INT 25
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PPUSH
4545: CALL_OW 72
4549: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4550: LD_INT 22
4552: PUSH
4553: LD_INT 3
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 34
4562: PUSH
4563: LD_INT 51
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: CALL_OW 69
4578: PUSH
4579: LD_INT 0
4581: GREATER
4582: PUSH
4583: LD_EXP 25
4587: PUSH
4588: LD_INT 0
4590: EQUAL
4591: AND
4592: IFFALSE 4632
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4594: LD_ADDR_EXP 25
4598: PUSH
4599: LD_INT 22
4601: PUSH
4602: LD_INT 3
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 34
4611: PUSH
4612: LD_INT 51
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 69
4627: PUSH
4628: LD_INT 1
4630: ARRAY
4631: ST_TO_ADDR
// if ru_cargo then
4632: LD_EXP 25
4636: IFFALSE 4934
// begin if IsInArea ( ru_cargo , ru_base ) then
4638: LD_EXP 25
4642: PPUSH
4643: LD_INT 9
4645: PPUSH
4646: CALL_OW 308
4650: IFFALSE 4729
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4652: LD_EXP 25
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: EQUAL
4668: IFFALSE 4686
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4670: LD_EXP 25
4674: PPUSH
4675: LD_VAR 0 3
4679: PPUSH
4680: CALL_OW 120
4684: GO 4727
// if not HasTask ( ru_cargo ) then
4686: LD_EXP 25
4690: PPUSH
4691: CALL_OW 314
4695: NOT
4696: IFFALSE 4727
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4698: LD_EXP 25
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 250
4712: PPUSH
4713: LD_VAR 0 1
4717: PPUSH
4718: CALL_OW 251
4722: PPUSH
4723: CALL_OW 111
// end else
4727: GO 4934
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4729: LD_EXP 25
4733: PPUSH
4734: CALL_OW 314
4738: NOT
4739: PUSH
4740: LD_EXP 25
4744: PPUSH
4745: LD_INT 1
4747: PPUSH
4748: CALL_OW 289
4752: PUSH
4753: LD_INT 100
4755: LESS
4756: AND
4757: IFFALSE 4823
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4759: LD_ADDR_VAR 0 16
4763: PUSH
4764: LD_INT 11
4766: PPUSH
4767: CALL_OW 435
4771: ST_TO_ADDR
// if cr > 0 then
4772: LD_VAR 0 16
4776: PUSH
4777: LD_INT 0
4779: GREATER
4780: IFFALSE 4811
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4782: LD_EXP 25
4786: PPUSH
4787: LD_VAR 0 16
4791: PUSH
4792: LD_INT 1
4794: ARRAY
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 2
4803: ARRAY
4804: PPUSH
4805: CALL_OW 117
4809: GO 4823
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4811: LD_EXP 25
4815: PPUSH
4816: LD_INT 11
4818: PPUSH
4819: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4823: LD_EXP 25
4827: PPUSH
4828: CALL_OW 314
4832: NOT
4833: PUSH
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 308
4846: NOT
4847: AND
4848: PUSH
4849: LD_EXP 25
4853: PPUSH
4854: LD_INT 1
4856: PPUSH
4857: CALL_OW 289
4861: PUSH
4862: LD_INT 100
4864: EQUAL
4865: AND
4866: IFFALSE 4880
// ComMoveToArea ( ru_cargo , cargoa ) ;
4868: LD_EXP 25
4872: PPUSH
4873: LD_INT 10
4875: PPUSH
4876: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4880: LD_EXP 25
4884: PPUSH
4885: LD_INT 10
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_VAR 0 8
4897: AND
4898: IFFALSE 4934
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4900: LD_VAR 0 7
4904: PPUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 9
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 72
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 139
4926: PPUSH
4927: LD_INT 24
4929: PPUSH
4930: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4934: LD_EXP 25
4938: PUSH
4939: LD_INT 0
4941: EQUAL
4942: PUSH
4943: LD_VAR 0 2
4947: AND
4948: PUSH
4949: LD_VAR 0 2
4953: PPUSH
4954: CALL_OW 461
4958: PUSH
4959: LD_INT 2
4961: EQUAL
4962: AND
4963: IFFALSE 4986
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4965: LD_VAR 0 2
4969: PPUSH
4970: LD_INT 21
4972: PPUSH
4973: LD_INT 3
4975: PPUSH
4976: LD_INT 3
4978: PPUSH
4979: LD_INT 51
4981: PPUSH
4982: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4986: LD_VAR 0 7
4990: PPUSH
4991: LD_INT 25
4993: PUSH
4994: LD_INT 9
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 72
5005: IFFALSE 5069
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5007: LD_VAR 0 7
5011: PPUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 9
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PPUSH
5022: CALL_OW 72
5026: PPUSH
5027: LD_INT 22
5029: PUSH
5030: LD_OWVAR 2
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 3
5041: PUSH
5042: LD_INT 21
5044: PUSH
5045: LD_INT 3
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PPUSH
5065: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5069: LD_VAR 0 2
5073: PUSH
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 0
5081: GREATER
5082: AND
5083: IFFALSE 5183
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5085: LD_VAR 0 2
5089: PPUSH
5090: CALL_OW 461
5094: PUSH
5095: LD_INT 2
5097: EQUAL
5098: IFFALSE 5183
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5100: LD_VAR 0 2
5104: PPUSH
5105: LD_EXP 27
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 2
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 3
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 4
5139: ARRAY
5140: PPUSH
5141: CALL_OW 125
// for i = 1 to 4 do
5145: LD_ADDR_VAR 0 12
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 4
5157: PUSH
5158: FOR_TO
5159: IFFALSE 5181
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5161: LD_ADDR_EXP 27
5165: PUSH
5166: LD_EXP 27
5170: PPUSH
5171: LD_INT 1
5173: PPUSH
5174: CALL_OW 3
5178: ST_TO_ADDR
5179: GO 5158
5181: POP
5182: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5183: LD_INT 24
5185: PPUSH
5186: CALL_OW 461
5190: PUSH
5191: LD_INT 2
5193: EQUAL
5194: PUSH
5195: LD_EXP 4
5199: AND
5200: IFFALSE 5228
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5202: LD_INT 25
5204: PPUSH
5205: LD_INT 3
5207: PPUSH
5208: CALL_OW 321
5212: PUSH
5213: LD_INT 1
5215: EQUAL
5216: IFFALSE 5228
// ComResearch ( ru_lab , tech_sibfiss ) ;
5218: LD_INT 24
5220: PPUSH
5221: LD_INT 25
5223: PPUSH
5224: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5228: LD_INT 25
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: CALL_OW 321
5238: PUSH
5239: LD_INT 2
5241: EQUAL
5242: PUSH
5243: LD_OWVAR 1
5247: PUSH
5248: LD_INT 10500
5250: MOD
5251: PUSH
5252: LD_INT 0
5254: EQUAL
5255: AND
5256: IFFALSE 5294
// if BuildingStatus ( ru_factory ) = bs_idle then
5258: LD_VAR 0 2
5262: PPUSH
5263: CALL_OW 461
5267: PUSH
5268: LD_INT 2
5270: EQUAL
5271: IFFALSE 5294
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5273: LD_VAR 0 2
5277: PPUSH
5278: LD_INT 23
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: LD_INT 3
5286: PPUSH
5287: LD_INT 48
5289: PPUSH
5290: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5294: LD_INT 22
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_INT 48
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: PPUSH
5318: CALL_OW 69
5322: PUSH
5323: LD_INT 0
5325: GREATER
5326: IFFALSE 5700
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5328: LD_ADDR_VAR 0 17
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 3
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 34
5345: PUSH
5346: LD_INT 48
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL_OW 69
5361: PUSH
5362: LD_INT 1
5364: ARRAY
5365: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5366: LD_VAR 0 17
5370: PPUSH
5371: LD_INT 9
5373: PPUSH
5374: CALL_OW 308
5378: IFFALSE 5396
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5380: LD_VAR 0 17
5384: PPUSH
5385: LD_VAR 0 3
5389: PPUSH
5390: CALL_OW 120
5394: GO 5700
// if not HasTask ( sib_bomb ) then
5396: LD_VAR 0 17
5400: PPUSH
5401: CALL_OW 314
5405: NOT
5406: IFFALSE 5700
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5408: LD_INT 22
5410: PUSH
5411: LD_OWVAR 2
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: PUSH
5420: LD_INT 30
5422: PUSH
5423: LD_INT 1
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PPUSH
5434: CALL_OW 69
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_INT 250
5450: GREATER
5451: IFFALSE 5544
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5453: LD_VAR 0 17
5457: PPUSH
5458: LD_INT 22
5460: PUSH
5461: LD_OWVAR 2
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 30
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 69
5488: PUSH
5489: LD_INT 1
5491: ARRAY
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 22
5500: PUSH
5501: LD_OWVAR 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 30
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 69
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: CALL_OW 251
5537: PPUSH
5538: CALL_OW 116
5542: GO 5700
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5544: LD_INT 22
5546: PUSH
5547: LD_OWVAR 2
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 21
5558: PUSH
5559: LD_INT 3
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 69
5574: PUSH
5575: LD_INT 0
5577: GREATER
5578: IFFALSE 5671
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5580: LD_VAR 0 17
5584: PPUSH
5585: LD_INT 22
5587: PUSH
5588: LD_OWVAR 2
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: LD_INT 21
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_INT 1
5618: ARRAY
5619: PPUSH
5620: CALL_OW 250
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_OWVAR 2
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 21
5639: PUSH
5640: LD_INT 3
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: PUSH
5656: LD_INT 1
5658: ARRAY
5659: PPUSH
5660: CALL_OW 251
5664: PPUSH
5665: CALL_OW 116
5669: GO 5700
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5671: LD_VAR 0 17
5675: PPUSH
5676: LD_EXP 10
5680: PPUSH
5681: CALL_OW 250
5685: PPUSH
5686: LD_EXP 10
5690: PPUSH
5691: CALL_OW 251
5695: PPUSH
5696: CALL_OW 116
// end ; if ru_can_attack then
5700: LD_EXP 3
5704: IFFALSE 5852
// if ru_time > 0 0$00 then
5706: LD_EXP 29
5710: PUSH
5711: LD_INT 0
5713: GREATER
5714: IFFALSE 5732
// ru_time := ru_time - 0 0$01 else
5716: LD_ADDR_EXP 29
5720: PUSH
5721: LD_EXP 29
5725: PUSH
5726: LD_INT 35
5728: MINUS
5729: ST_TO_ADDR
5730: GO 5852
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5732: LD_ADDR_EXP 29
5736: PUSH
5737: LD_INT 20265
5739: PPUSH
5740: LD_INT 30765
5742: PPUSH
5743: CALL_OW 12
5747: ST_TO_ADDR
// for i = 1 to ru_amount do
5748: LD_ADDR_VAR 0 12
5752: PUSH
5753: DOUBLE
5754: LD_INT 1
5756: DEC
5757: ST_TO_ADDR
5758: LD_EXP 28
5762: PUSH
5763: FOR_TO
5764: IFFALSE 5850
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5766: LD_ADDR_EXP 27
5770: PUSH
5771: LD_EXP 27
5775: PUSH
5776: LD_INT 23
5778: ADD
5779: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5780: LD_ADDR_EXP 27
5784: PUSH
5785: LD_EXP 27
5789: PUSH
5790: LD_INT 3
5792: ADD
5793: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5794: LD_ADDR_EXP 27
5798: PUSH
5799: LD_EXP 27
5803: PUSH
5804: LD_INT 3
5806: ADD
5807: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5808: LD_ADDR_EXP 27
5812: PUSH
5813: LD_EXP 27
5817: PUSH
5818: LD_INT 46
5820: PUSH
5821: LD_INT 45
5823: PUSH
5824: LD_INT 47
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 2
5837: PPUSH
5838: LD_INT 3
5840: PPUSH
5841: CALL_OW 14
5845: ARRAY
5846: ADD
5847: ST_TO_ADDR
// end ;
5848: GO 5763
5850: POP
5851: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5852: LD_VAR 0 4
5856: PPUSH
5857: LD_INT 35
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PPUSH
5867: CALL_OW 72
5871: PUSH
5872: LD_INT 0
5874: GREATER
5875: IFFALSE 5923
// if BuildingStatus ( ru_factory ) = bs_idle then
5877: LD_VAR 0 2
5881: PPUSH
5882: CALL_OW 461
5886: PUSH
5887: LD_INT 2
5889: EQUAL
5890: IFFALSE 5923
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5892: LD_VAR 0 4
5896: PPUSH
5897: LD_INT 35
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PPUSH
5907: CALL_OW 72
5911: PUSH
5912: LD_INT 1
5914: ARRAY
5915: PPUSH
5916: LD_INT 47
5918: PPUSH
5919: CALL_OW 148
// if ru_force = ru_amount then
5923: LD_EXP 23
5927: PUSH
5928: LD_EXP 28
5932: EQUAL
5933: IFFALSE 6065
// begin for i = 1 to ru_force do
5935: LD_ADDR_VAR 0 12
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_EXP 23
5949: PUSH
5950: FOR_TO
5951: IFFALSE 6061
// if IsInArea ( ru_force [ i ] , ru_base ) then
5953: LD_EXP 23
5957: PUSH
5958: LD_VAR 0 12
5962: ARRAY
5963: PPUSH
5964: LD_INT 9
5966: PPUSH
5967: CALL_OW 308
5971: IFFALSE 5995
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5973: LD_EXP 23
5977: PUSH
5978: LD_VAR 0 12
5982: ARRAY
5983: PPUSH
5984: LD_VAR 0 3
5988: PPUSH
5989: CALL_OW 120
5993: GO 6059
// if not HasTask ( ru_force [ i ] ) then
5995: LD_EXP 23
5999: PUSH
6000: LD_VAR 0 12
6004: ARRAY
6005: PPUSH
6006: CALL_OW 314
6010: NOT
6011: IFFALSE 6059
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6013: LD_EXP 23
6017: PUSH
6018: LD_VAR 0 12
6022: ARRAY
6023: PPUSH
6024: LD_INT 81
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PPUSH
6034: CALL_OW 69
6038: PPUSH
6039: LD_EXP 23
6043: PUSH
6044: LD_VAR 0 12
6048: ARRAY
6049: PPUSH
6050: CALL_OW 74
6054: PPUSH
6055: CALL_OW 115
6059: GO 5950
6061: POP
6062: POP
// end else
6063: GO 6215
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6065: LD_EXP 23
6069: PPUSH
6070: LD_INT 3
6072: PUSH
6073: LD_INT 95
6075: PUSH
6076: LD_INT 18
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: PUSH
6092: LD_INT 0
6094: GREATER
6095: IFFALSE 6215
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6097: LD_ADDR_VAR 0 13
6101: PUSH
6102: LD_EXP 23
6106: PPUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 95
6112: PUSH
6113: LD_INT 18
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 72
6128: ST_TO_ADDR
// for i = 1 to tmp do
6129: LD_ADDR_VAR 0 12
6133: PUSH
6134: DOUBLE
6135: LD_INT 1
6137: DEC
6138: ST_TO_ADDR
6139: LD_VAR 0 13
6143: PUSH
6144: FOR_TO
6145: IFFALSE 6213
// if not HasTask ( tmp [ i ] ) then
6147: LD_VAR 0 13
6151: PUSH
6152: LD_VAR 0 12
6156: ARRAY
6157: PPUSH
6158: CALL_OW 314
6162: NOT
6163: IFFALSE 6211
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6165: LD_EXP 23
6169: PUSH
6170: LD_VAR 0 12
6174: ARRAY
6175: PPUSH
6176: LD_INT 81
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PPUSH
6191: LD_EXP 23
6195: PUSH
6196: LD_VAR 0 12
6200: ARRAY
6201: PPUSH
6202: CALL_OW 74
6206: PPUSH
6207: CALL_OW 115
6211: GO 6144
6213: POP
6214: POP
// end ; if ru_engs > 0 then
6215: LD_VAR 0 9
6219: PUSH
6220: LD_INT 0
6222: GREATER
6223: IFFALSE 6625
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6225: LD_VAR 0 5
6229: PPUSH
6230: LD_INT 3
6232: PUSH
6233: LD_INT 24
6235: PUSH
6236: LD_INT 1000
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_INT 0
6254: GREATER
6255: IFFALSE 6410
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6257: LD_ADDR_VAR 0 14
6261: PUSH
6262: LD_VAR 0 5
6266: PPUSH
6267: LD_INT 3
6269: PUSH
6270: LD_INT 24
6272: PUSH
6273: LD_INT 1000
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 72
6288: ST_TO_ADDR
// for i = 1 to ru_engs do
6289: LD_ADDR_VAR 0 12
6293: PUSH
6294: DOUBLE
6295: LD_INT 1
6297: DEC
6298: ST_TO_ADDR
6299: LD_VAR 0 9
6303: PUSH
6304: FOR_TO
6305: IFFALSE 6406
// begin if IsInUnit ( ru_engs [ i ] ) then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 310
6322: IFFALSE 6341
// ComExitBuilding ( ru_engs [ i ] ) else
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 122
6339: GO 6404
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6341: LD_VAR 0 9
6345: PUSH
6346: LD_VAR 0 12
6350: ARRAY
6351: PPUSH
6352: CALL_OW 314
6356: NOT
6357: PUSH
6358: LD_VAR 0 9
6362: PUSH
6363: LD_VAR 0 12
6367: ARRAY
6368: PPUSH
6369: CALL_OW 256
6373: PUSH
6374: LD_INT 600
6376: GREATER
6377: AND
6378: IFFALSE 6404
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6380: LD_VAR 0 9
6384: PUSH
6385: LD_VAR 0 12
6389: ARRAY
6390: PPUSH
6391: LD_VAR 0 14
6395: PUSH
6396: LD_INT 1
6398: ARRAY
6399: PPUSH
6400: CALL_OW 130
// end ;
6404: GO 6304
6406: POP
6407: POP
// end else
6408: GO 6625
// begin if ru_blist = 0 then
6410: LD_EXP 26
6414: PUSH
6415: LD_INT 0
6417: EQUAL
6418: IFFALSE 6500
// begin for i = 1 to ru_engs do
6420: LD_ADDR_VAR 0 12
6424: PUSH
6425: DOUBLE
6426: LD_INT 1
6428: DEC
6429: ST_TO_ADDR
6430: LD_VAR 0 9
6434: PUSH
6435: FOR_TO
6436: IFFALSE 6496
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6438: LD_VAR 0 9
6442: PUSH
6443: LD_VAR 0 12
6447: ARRAY
6448: PPUSH
6449: CALL_OW 314
6453: NOT
6454: PUSH
6455: LD_VAR 0 9
6459: PUSH
6460: LD_VAR 0 12
6464: ARRAY
6465: PPUSH
6466: CALL_OW 310
6470: NOT
6471: AND
6472: IFFALSE 6494
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6474: LD_VAR 0 9
6478: PUSH
6479: LD_VAR 0 12
6483: ARRAY
6484: PPUSH
6485: LD_VAR 0 1
6489: PPUSH
6490: CALL_OW 120
6494: GO 6435
6496: POP
6497: POP
// end else
6498: GO 6625
// begin for i = 1 to ru_engs do
6500: LD_ADDR_VAR 0 12
6504: PUSH
6505: DOUBLE
6506: LD_INT 1
6508: DEC
6509: ST_TO_ADDR
6510: LD_VAR 0 9
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6623
// begin if IsInUnit ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 310
6533: IFFALSE 6552
// ComExitBuilding ( ru_engs [ i ] ) else
6535: LD_VAR 0 9
6539: PUSH
6540: LD_VAR 0 12
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
6550: GO 6621
// if not HasTask ( ru_engs [ i ] ) then
6552: LD_VAR 0 9
6556: PUSH
6557: LD_VAR 0 12
6561: ARRAY
6562: PPUSH
6563: CALL_OW 314
6567: NOT
6568: IFFALSE 6621
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6570: LD_VAR 0 9
6574: PUSH
6575: LD_VAR 0 12
6579: ARRAY
6580: PPUSH
6581: LD_EXP 26
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 2
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 3
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 4
6615: ARRAY
6616: PPUSH
6617: CALL_OW 145
// end ;
6621: GO 6515
6623: POP
6624: POP
// end ; end ; end ; end ;
6625: PPOPN 17
6627: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6628: LD_EXP 2
6632: PUSH
6633: LD_INT 11
6635: PPUSH
6636: CALL_OW 435
6640: PUSH
6641: LD_INT 20
6643: LESS
6644: AND
6645: IFFALSE 6708
6647: GO 6649
6649: DISABLE
// begin enable ;
6650: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6651: LD_INT 1
6653: PPUSH
6654: LD_INT 5
6656: PPUSH
6657: CALL_OW 12
6661: PPUSH
6662: LD_INT 11
6664: PPUSH
6665: LD_INT 1
6667: PPUSH
6668: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6672: LD_INT 1505
6674: PPUSH
6675: LD_INT 2100
6677: PPUSH
6678: CALL_OW 12
6682: PPUSH
6683: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 5
6692: PPUSH
6693: CALL_OW 12
6697: PPUSH
6698: LD_INT 11
6700: PPUSH
6701: LD_INT 1
6703: PPUSH
6704: CALL_OW 55
// end ;
6708: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6709: LD_EXP 4
6713: PUSH
6714: LD_INT 0
6716: EQUAL
6717: IFFALSE 6832
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
6725: PPUSH
// begin enable ;
6726: ENABLE
// i := Rand ( 0 , 100 ) ;
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: LD_INT 0
6734: PPUSH
6735: LD_INT 100
6737: PPUSH
6738: CALL_OW 12
6742: ST_TO_ADDR
// case your_side of 1 :
6743: LD_OWVAR 2
6747: PUSH
6748: LD_INT 1
6750: DOUBLE
6751: EQUAL
6752: IFTRUE 6756
6754: GO 6767
6756: POP
// tmp := 10 ; 2 :
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 10
6764: ST_TO_ADDR
6765: GO 6806
6767: LD_INT 2
6769: DOUBLE
6770: EQUAL
6771: IFTRUE 6775
6773: GO 6786
6775: POP
// tmp := 0 ; 7 :
6776: LD_ADDR_VAR 0 2
6780: PUSH
6781: LD_INT 0
6783: ST_TO_ADDR
6784: GO 6806
6786: LD_INT 7
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6805
6794: POP
// tmp := 15 ; end ;
6795: LD_ADDR_VAR 0 2
6799: PUSH
6800: LD_INT 15
6802: ST_TO_ADDR
6803: GO 6806
6805: POP
// if i < chance_to_bomb + tmp then
6806: LD_VAR 0 1
6810: PUSH
6811: LD_EXP 5
6815: PUSH
6816: LD_VAR 0 2
6820: PLUS
6821: LESS
6822: IFFALSE 6832
// ru_sib_bomb := true ;
6824: LD_ADDR_EXP 4
6828: PUSH
6829: LD_INT 1
6831: ST_TO_ADDR
// end ;
6832: PPOPN 2
6834: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6835: LD_INT 22
6837: PUSH
6838: LD_OWVAR 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 34
6849: PUSH
6850: LD_INT 8
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 69
6865: IFFALSE 6878
6867: GO 6869
6869: DISABLE
// begin ru_sib_bomb := true ;
6870: LD_ADDR_EXP 4
6874: PUSH
6875: LD_INT 1
6877: ST_TO_ADDR
// end ;
6878: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6879: LD_INT 22
6881: PUSH
6882: LD_INT 3
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 30
6891: PUSH
6892: LD_INT 34
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PPUSH
6903: CALL_OW 69
6907: IFFALSE 7006
6909: GO 6911
6911: DISABLE
6912: LD_INT 0
6914: PPUSH
// begin enable ;
6915: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 1
6933: PPUSH
6934: LD_INT 2
6936: PPUSH
6937: CALL_OW 12
6941: ARRAY
6942: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6943: LD_INT 22
6945: PUSH
6946: LD_INT 3
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: LD_INT 30
6955: PUSH
6956: LD_INT 34
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_EXP 30
6980: PUSH
6981: LD_VAR 0 1
6985: ARRAY
6986: PPUSH
6987: LD_EXP 30
6991: PUSH
6992: LD_VAR 0 1
6996: PUSH
6997: LD_INT 1
6999: PLUS
7000: ARRAY
7001: PPUSH
7002: CALL_OW 243
// end ; end_of_file
7006: PPOPN 1
7008: END
// export function RemoveLegion ; var i ; begin
7009: LD_INT 0
7011: PPUSH
7012: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7013: LD_ADDR_VAR 0 2
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 69
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7047
// RemoveUnit ( i ) ;
7036: LD_VAR 0 2
7040: PPUSH
7041: CALL_OW 64
7045: GO 7033
7047: POP
7048: POP
// end ;
7049: LD_VAR 0 1
7053: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
7059: PPUSH
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
7064: PPUSH
7065: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7066: LD_ADDR_VAR 0 7
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 8
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 30
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL_OW 69
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7104: LD_ADDR_VAR 0 8
7108: PUSH
7109: LD_INT 22
7111: PUSH
7112: LD_INT 8
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 30
7121: PUSH
7122: LD_INT 3
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PPUSH
7133: CALL_OW 69
7137: PUSH
7138: LD_INT 1
7140: ARRAY
7141: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7142: LD_ADDR_VAR 0 9
7146: PUSH
7147: LD_INT 22
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: LD_INT 30
7162: PUSH
7163: LD_INT 6
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 30
7172: PUSH
7173: LD_INT 8
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PPUSH
7189: CALL_OW 69
7193: PUSH
7194: LD_INT 1
7196: ARRAY
7197: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7198: LD_ADDR_VAR 0 10
7202: PUSH
7203: LD_INT 22
7205: PUSH
7206: LD_INT 8
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 30
7215: PUSH
7216: LD_INT 32
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL_OW 69
7231: ST_TO_ADDR
// uc_side := 8 ;
7232: LD_ADDR_OWVAR 20
7236: PUSH
7237: LD_INT 8
7239: ST_TO_ADDR
// uc_nation := nation_arabian ;
7240: LD_ADDR_OWVAR 21
7244: PUSH
7245: LD_INT 2
7247: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7248: LD_ADDR_EXP 32
7252: PUSH
7253: LD_INT 5
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: LD_INT 7
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: PUSH
7267: LD_OWVAR 67
7271: ARRAY
7272: ST_TO_ADDR
// legion_blist := [ ] ;
7273: LD_ADDR_EXP 34
7277: PUSH
7278: EMPTY
7279: ST_TO_ADDR
// legion_vlist := [ ] ;
7280: LD_ADDR_EXP 35
7284: PUSH
7285: EMPTY
7286: ST_TO_ADDR
// legion_force := [ ] ;
7287: LD_ADDR_EXP 31
7291: PUSH
7292: EMPTY
7293: ST_TO_ADDR
// legion_enemy := - 1 ;
7294: LD_ADDR_EXP 36
7298: PUSH
7299: LD_INT 1
7301: NEG
7302: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7303: LD_VAR 0 7
7307: PPUSH
7308: CALL_OW 274
7312: PPUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 10000
7318: PPUSH
7319: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7323: LD_VAR 0 7
7327: PPUSH
7328: CALL_OW 274
7332: PPUSH
7333: LD_INT 3
7335: PPUSH
7336: LD_INT 1000
7338: PPUSH
7339: CALL_OW 277
// for i = 1 to l_towers do
7343: LD_ADDR_VAR 0 3
7347: PUSH
7348: DOUBLE
7349: LD_INT 1
7351: DEC
7352: ST_TO_ADDR
7353: LD_VAR 0 10
7357: PUSH
7358: FOR_TO
7359: IFFALSE 7408
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7361: LD_INT 0
7363: PPUSH
7364: LD_INT 1
7366: PPUSH
7367: LD_EXP 32
7371: PPUSH
7372: CALL_OW 380
// un := CreateHuman ;
7376: LD_ADDR_VAR 0 2
7380: PUSH
7381: CALL_OW 44
7385: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7386: LD_VAR 0 2
7390: PPUSH
7391: LD_VAR 0 10
7395: PUSH
7396: LD_VAR 0 3
7400: ARRAY
7401: PPUSH
7402: CALL_OW 52
// end ;
7406: GO 7358
7408: POP
7409: POP
// for i = 1 to 4 do
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: DOUBLE
7416: LD_INT 1
7418: DEC
7419: ST_TO_ADDR
7420: LD_INT 4
7422: PUSH
7423: FOR_TO
7424: IFFALSE 7517
// for p = 1 to 2 do
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: DOUBLE
7432: LD_INT 1
7434: DEC
7435: ST_TO_ADDR
7436: LD_INT 2
7438: PUSH
7439: FOR_TO
7440: IFFALSE 7513
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7442: LD_INT 0
7444: PPUSH
7445: LD_INT 8
7447: PPUSH
7448: LD_EXP 32
7452: PPUSH
7453: CALL_OW 380
// un := CreateHuman ;
7457: LD_ADDR_VAR 0 2
7461: PUSH
7462: CALL_OW 44
7466: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7467: LD_VAR 0 2
7471: PPUSH
7472: LD_INT 22
7474: PUSH
7475: LD_INT 8
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 30
7484: PUSH
7485: LD_INT 5
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PPUSH
7496: CALL_OW 69
7500: PUSH
7501: LD_VAR 0 6
7505: ARRAY
7506: PPUSH
7507: CALL_OW 52
// end ;
7511: GO 7439
7513: POP
7514: POP
7515: GO 7423
7517: POP
7518: POP
// for i = 1 to 4 do
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: DOUBLE
7525: LD_INT 1
7527: DEC
7528: ST_TO_ADDR
7529: LD_INT 4
7531: PUSH
7532: FOR_TO
7533: IFFALSE 7576
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7535: LD_INT 0
7537: PPUSH
7538: LD_INT 4
7540: PPUSH
7541: LD_EXP 32
7545: PPUSH
7546: CALL_OW 380
// un := CreateHuman ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: CALL_OW 44
7559: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7560: LD_VAR 0 2
7564: PPUSH
7565: LD_VAR 0 9
7569: PPUSH
7570: CALL_OW 52
// end ;
7574: GO 7532
7576: POP
7577: POP
// for i = 1 to 6 do
7578: LD_ADDR_VAR 0 3
7582: PUSH
7583: DOUBLE
7584: LD_INT 1
7586: DEC
7587: ST_TO_ADDR
7588: LD_INT 6
7590: PUSH
7591: FOR_TO
7592: IFFALSE 7635
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_EXP 32
7604: PPUSH
7605: CALL_OW 380
// un := CreateHuman ;
7609: LD_ADDR_VAR 0 2
7613: PUSH
7614: CALL_OW 44
7618: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7619: LD_VAR 0 2
7623: PPUSH
7624: LD_VAR 0 8
7628: PPUSH
7629: CALL_OW 52
// end ;
7633: GO 7591
7635: POP
7636: POP
// for i = 1 to 5 do
7637: LD_ADDR_VAR 0 3
7641: PUSH
7642: DOUBLE
7643: LD_INT 1
7645: DEC
7646: ST_TO_ADDR
7647: LD_INT 5
7649: PUSH
7650: FOR_TO
7651: IFFALSE 7694
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7653: LD_INT 0
7655: PPUSH
7656: LD_INT 2
7658: PPUSH
7659: LD_EXP 32
7663: PPUSH
7664: CALL_OW 380
// un := CreateHuman ;
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: CALL_OW 44
7677: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7678: LD_VAR 0 2
7682: PPUSH
7683: LD_VAR 0 7
7687: PPUSH
7688: CALL_OW 52
// end ;
7692: GO 7650
7694: POP
7695: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7696: LD_ADDR_VAR 0 4
7700: PUSH
7701: LD_INT 199
7703: PPUSH
7704: LD_INT 134
7706: PPUSH
7707: LD_INT 216
7709: PPUSH
7710: LD_INT 141
7712: PPUSH
7713: LD_INT 6
7715: PPUSH
7716: CALL 1562 0 5
7720: ST_TO_ADDR
// p := 1 ;
7721: LD_ADDR_VAR 0 6
7725: PUSH
7726: LD_INT 1
7728: ST_TO_ADDR
// for i = 1 to 3 do
7729: LD_ADDR_VAR 0 3
7733: PUSH
7734: DOUBLE
7735: LD_INT 1
7737: DEC
7738: ST_TO_ADDR
7739: LD_INT 3
7741: PUSH
7742: FOR_TO
7743: IFFALSE 7996
// begin vc_chassis := ar_half_tracked ;
7745: LD_ADDR_OWVAR 37
7749: PUSH
7750: LD_INT 14
7752: ST_TO_ADDR
// vc_engine := engine_siberite ;
7753: LD_ADDR_OWVAR 39
7757: PUSH
7758: LD_INT 3
7760: ST_TO_ADDR
// vc_control := control_manual ;
7761: LD_ADDR_OWVAR 38
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7769: LD_ADDR_OWVAR 40
7773: PUSH
7774: LD_INT 31
7776: ST_TO_ADDR
// veh := CreateVehicle ;
7777: LD_ADDR_VAR 0 5
7781: PUSH
7782: CALL_OW 45
7786: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7787: LD_VAR 0 4
7791: PUSH
7792: LD_VAR 0 6
7796: ARRAY
7797: PPUSH
7798: LD_VAR 0 4
7802: PUSH
7803: LD_VAR 0 6
7807: PUSH
7808: LD_INT 1
7810: PLUS
7811: ARRAY
7812: PPUSH
7813: CALL_OW 428
7817: PUSH
7818: LD_INT 0
7820: EQUAL
7821: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7823: LD_VAR 0 5
7827: PPUSH
7828: LD_VAR 0 4
7832: PUSH
7833: LD_VAR 0 6
7837: ARRAY
7838: PPUSH
7839: LD_VAR 0 4
7843: PUSH
7844: LD_VAR 0 6
7848: PUSH
7849: LD_INT 1
7851: PLUS
7852: ARRAY
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 48
7861: GO 7951
// begin repeat p := p + 2 ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_VAR 0 6
7872: PUSH
7873: LD_INT 2
7875: PLUS
7876: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7877: LD_VAR 0 4
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_VAR 0 4
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ARRAY
7902: PPUSH
7903: CALL_OW 428
7907: PUSH
7908: LD_INT 0
7910: EQUAL
7911: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7913: LD_VAR 0 5
7917: PPUSH
7918: LD_VAR 0 4
7922: PUSH
7923: LD_VAR 0 6
7927: ARRAY
7928: PPUSH
7929: LD_VAR 0 4
7933: PUSH
7934: LD_VAR 0 6
7938: PUSH
7939: LD_INT 1
7941: PLUS
7942: ARRAY
7943: PPUSH
7944: LD_INT 0
7946: PPUSH
7947: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7951: LD_INT 0
7953: PPUSH
7954: LD_INT 3
7956: PPUSH
7957: LD_EXP 32
7961: PUSH
7962: LD_INT 1
7964: PLUS
7965: PPUSH
7966: CALL_OW 380
// un := CreateHuman ;
7970: LD_ADDR_VAR 0 2
7974: PUSH
7975: CALL_OW 44
7979: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7980: LD_VAR 0 2
7984: PPUSH
7985: LD_VAR 0 5
7989: PPUSH
7990: CALL_OW 52
// end ;
7994: GO 7742
7996: POP
7997: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7998: LD_INT 198
8000: PPUSH
8001: LD_INT 94
8003: PPUSH
8004: LD_INT 8
8006: PPUSH
8007: LD_INT 10
8009: PPUSH
8010: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8014: LD_INT 167
8016: PPUSH
8017: LD_INT 130
8019: PPUSH
8020: LD_INT 8
8022: PPUSH
8023: LD_INT 10
8025: PPUSH
8026: CALL_OW 330
// legion_mines := [ ] ;
8030: LD_ADDR_EXP 33
8034: PUSH
8035: EMPTY
8036: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8037: LD_ADDR_EXP 33
8041: PUSH
8042: LD_INT 176
8044: PPUSH
8045: LD_INT 122
8047: PPUSH
8048: LD_INT 188
8050: PPUSH
8051: LD_INT 126
8053: PPUSH
8054: LD_INT 6
8056: PPUSH
8057: CALL 1562 0 5
8061: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8062: LD_ADDR_EXP 33
8066: PUSH
8067: LD_EXP 33
8071: PUSH
8072: LD_INT 197
8074: PPUSH
8075: LD_INT 91
8077: PPUSH
8078: LD_INT 205
8080: PPUSH
8081: LD_INT 96
8083: PPUSH
8084: LD_INT 4
8086: PPUSH
8087: CALL 1562 0 5
8091: ADD
8092: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8093: LD_ADDR_EXP 33
8097: PUSH
8098: LD_EXP 33
8102: PUSH
8103: LD_INT 184
8105: PPUSH
8106: LD_INT 151
8108: PPUSH
8109: LD_INT 178
8111: PPUSH
8112: LD_INT 130
8114: PPUSH
8115: LD_INT 9
8117: PPUSH
8118: CALL 1562 0 5
8122: ADD
8123: ST_TO_ADDR
// if Difficulty > 1 then
8124: LD_OWVAR 67
8128: PUSH
8129: LD_INT 1
8131: GREATER
8132: IFFALSE 8165
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8134: LD_ADDR_EXP 33
8138: PUSH
8139: LD_EXP 33
8143: PUSH
8144: LD_INT 166
8146: PPUSH
8147: LD_INT 126
8149: PPUSH
8150: LD_INT 181
8152: PPUSH
8153: LD_INT 136
8155: PPUSH
8156: LD_INT 5
8158: PPUSH
8159: CALL 1562 0 5
8163: ADD
8164: ST_TO_ADDR
// p := 1 ;
8165: LD_ADDR_VAR 0 6
8169: PUSH
8170: LD_INT 1
8172: ST_TO_ADDR
// for i = 1 to 24 do
8173: LD_ADDR_VAR 0 3
8177: PUSH
8178: DOUBLE
8179: LD_INT 1
8181: DEC
8182: ST_TO_ADDR
8183: LD_INT 24
8185: PUSH
8186: FOR_TO
8187: IFFALSE 8241
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8189: LD_EXP 33
8193: PUSH
8194: LD_VAR 0 6
8198: ARRAY
8199: PPUSH
8200: LD_EXP 33
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: LD_INT 1
8212: PLUS
8213: ARRAY
8214: PPUSH
8215: LD_INT 8
8217: PPUSH
8218: LD_INT 0
8220: PPUSH
8221: CALL_OW 454
// p := p + 2 ;
8225: LD_ADDR_VAR 0 6
8229: PUSH
8230: LD_VAR 0 6
8234: PUSH
8235: LD_INT 2
8237: PLUS
8238: ST_TO_ADDR
// end ;
8239: GO 8186
8241: POP
8242: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8243: LD_ADDR_EXP 35
8247: PUSH
8248: LD_INT 13
8250: PUSH
8251: LD_INT 3
8253: PUSH
8254: LD_INT 2
8256: PUSH
8257: LD_INT 32
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: ST_TO_ADDR
// end ;
8266: LD_VAR 0 1
8270: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 69
8285: PUSH
8286: LD_INT 0
8288: GREATER
8289: IFFALSE 10475
8291: GO 8293
8293: DISABLE
8294: LD_INT 0
8296: PPUSH
8297: PPUSH
8298: PPUSH
8299: PPUSH
8300: PPUSH
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
// begin enable ;
8313: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_INT 22
8321: PUSH
8322: LD_INT 8
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: LD_INT 30
8331: PUSH
8332: LD_INT 1
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PPUSH
8343: CALL_OW 69
8347: PUSH
8348: LD_INT 1
8350: ARRAY
8351: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8352: LD_ADDR_VAR 0 9
8356: PUSH
8357: LD_INT 22
8359: PUSH
8360: LD_INT 8
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 30
8369: PUSH
8370: LD_INT 3
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8390: LD_ADDR_VAR 0 10
8394: PUSH
8395: LD_INT 22
8397: PUSH
8398: LD_INT 8
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 2
8407: PUSH
8408: LD_INT 30
8410: PUSH
8411: LD_INT 6
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 30
8420: PUSH
8421: LD_INT 8
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PPUSH
8437: CALL_OW 69
8441: PUSH
8442: LD_INT 1
8444: ARRAY
8445: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8446: LD_ADDR_VAR 0 11
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 32
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8480: LD_ADDR_VAR 0 16
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 2
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8514: LD_ADDR_VAR 0 15
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8548: LD_ADDR_VAR 0 14
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 3
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8582: LD_ADDR_VAR 0 13
8586: PUSH
8587: LD_INT 22
8589: PUSH
8590: LD_INT 8
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: PUSH
8597: LD_INT 25
8599: PUSH
8600: LD_INT 4
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PPUSH
8611: CALL_OW 69
8615: ST_TO_ADDR
// if l_eng then
8616: LD_VAR 0 16
8620: IFFALSE 9035
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8622: LD_ADDR_VAR 0 5
8626: PUSH
8627: LD_INT 22
8629: PUSH
8630: LD_INT 8
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: LD_INT 21
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PPUSH
8651: CALL_OW 69
8655: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8656: LD_VAR 0 5
8660: PPUSH
8661: LD_INT 3
8663: PUSH
8664: LD_INT 24
8666: PUSH
8667: LD_INT 1000
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL_OW 72
8682: PUSH
8683: LD_INT 0
8685: GREATER
8686: IFFALSE 8820
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8688: LD_ADDR_VAR 0 3
8692: PUSH
8693: LD_VAR 0 5
8697: PPUSH
8698: LD_INT 3
8700: PUSH
8701: LD_INT 24
8703: PUSH
8704: LD_INT 1000
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PPUSH
8715: CALL_OW 72
8719: ST_TO_ADDR
// for i = 1 to l_eng do
8720: LD_ADDR_VAR 0 2
8724: PUSH
8725: DOUBLE
8726: LD_INT 1
8728: DEC
8729: ST_TO_ADDR
8730: LD_VAR 0 16
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8816
// if IsInUnit ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 310
8753: IFFALSE 8772
// ComExitBuilding ( l_eng [ i ] ) else
8755: LD_VAR 0 16
8759: PUSH
8760: LD_VAR 0 2
8764: ARRAY
8765: PPUSH
8766: CALL_OW 122
8770: GO 8814
// if not HasTask ( l_eng [ i ] ) then
8772: LD_VAR 0 16
8776: PUSH
8777: LD_VAR 0 2
8781: ARRAY
8782: PPUSH
8783: CALL_OW 314
8787: NOT
8788: IFFALSE 8814
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8790: LD_VAR 0 16
8794: PUSH
8795: LD_VAR 0 2
8799: ARRAY
8800: PPUSH
8801: LD_VAR 0 3
8805: PUSH
8806: LD_INT 1
8808: ARRAY
8809: PPUSH
8810: CALL_OW 130
8814: GO 8735
8816: POP
8817: POP
// end else
8818: GO 9035
// begin if legion_blist > 0 then
8820: LD_EXP 34
8824: PUSH
8825: LD_INT 0
8827: GREATER
8828: IFFALSE 8957
// begin for i = 1 to l_eng do
8830: LD_ADDR_VAR 0 2
8834: PUSH
8835: DOUBLE
8836: LD_INT 1
8838: DEC
8839: ST_TO_ADDR
8840: LD_VAR 0 16
8844: PUSH
8845: FOR_TO
8846: IFFALSE 8953
// if IsInUnit ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 310
8863: IFFALSE 8882
// ComExitBuilding ( l_eng [ i ] ) else
8865: LD_VAR 0 16
8869: PUSH
8870: LD_VAR 0 2
8874: ARRAY
8875: PPUSH
8876: CALL_OW 122
8880: GO 8951
// if not HasTask ( l_eng [ i ] ) then
8882: LD_VAR 0 16
8886: PUSH
8887: LD_VAR 0 2
8891: ARRAY
8892: PPUSH
8893: CALL_OW 314
8897: NOT
8898: IFFALSE 8951
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8900: LD_VAR 0 16
8904: PUSH
8905: LD_VAR 0 2
8909: ARRAY
8910: PPUSH
8911: LD_EXP 34
8915: PUSH
8916: LD_INT 1
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 2
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 3
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 4
8945: ARRAY
8946: PPUSH
8947: CALL_OW 145
8951: GO 8845
8953: POP
8954: POP
// end else
8955: GO 9035
// for i = 1 to l_eng do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: DOUBLE
8963: LD_INT 1
8965: DEC
8966: ST_TO_ADDR
8967: LD_VAR 0 16
8971: PUSH
8972: FOR_TO
8973: IFFALSE 9033
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8975: LD_VAR 0 16
8979: PUSH
8980: LD_VAR 0 2
8984: ARRAY
8985: PPUSH
8986: CALL_OW 310
8990: NOT
8991: PUSH
8992: LD_VAR 0 16
8996: PUSH
8997: LD_VAR 0 2
9001: ARRAY
9002: PPUSH
9003: CALL_OW 314
9007: NOT
9008: AND
9009: IFFALSE 9031
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9011: LD_VAR 0 16
9015: PUSH
9016: LD_VAR 0 2
9020: ARRAY
9021: PPUSH
9022: LD_VAR 0 8
9026: PPUSH
9027: CALL_OW 120
9031: GO 8972
9033: POP
9034: POP
// end ; end ; if l_factory then
9035: LD_VAR 0 9
9039: IFFALSE 9439
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9041: LD_INT 22
9043: PUSH
9044: LD_INT 8
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: LD_INT 33
9053: PUSH
9054: LD_INT 2
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 3
9063: PUSH
9064: LD_INT 61
9066: PUSH
9067: EMPTY
9068: LIST
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PPUSH
9079: CALL_OW 69
9083: PUSH
9084: LD_INT 0
9086: GREATER
9087: PUSH
9088: LD_INT 22
9090: PUSH
9091: LD_INT 8
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 34
9100: PUSH
9101: LD_INT 31
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL_OW 69
9116: PUSH
9117: LD_INT 0
9119: GREATER
9120: AND
9121: IFFALSE 9241
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9123: LD_INT 22
9125: PUSH
9126: LD_INT 8
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 33
9135: PUSH
9136: LD_INT 2
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 61
9148: PUSH
9149: EMPTY
9150: LIST
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: PUSH
9166: LD_INT 1
9168: ARRAY
9169: PPUSH
9170: LD_INT 22
9172: PUSH
9173: LD_INT 8
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 34
9182: PUSH
9183: LD_INT 31
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PUSH
9199: LD_INT 1
9201: PPUSH
9202: LD_INT 22
9204: PUSH
9205: LD_INT 8
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 34
9214: PUSH
9215: LD_INT 31
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PPUSH
9226: CALL_OW 69
9230: PPUSH
9231: CALL_OW 12
9235: ARRAY
9236: PPUSH
9237: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9241: LD_EXP 35
9245: PUSH
9246: LD_INT 0
9248: GREATER
9249: PUSH
9250: LD_VAR 0 9
9254: PPUSH
9255: CALL_OW 461
9259: PUSH
9260: LD_INT 2
9262: EQUAL
9263: AND
9264: IFFALSE 9349
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9266: LD_VAR 0 9
9270: PPUSH
9271: LD_EXP 35
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 3
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: PPUSH
9307: CALL_OW 125
// for i = 1 to 4 do
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: DOUBLE
9317: LD_INT 1
9319: DEC
9320: ST_TO_ADDR
9321: LD_INT 4
9323: PUSH
9324: FOR_TO
9325: IFFALSE 9347
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9327: LD_ADDR_EXP 35
9331: PUSH
9332: LD_EXP 35
9336: PPUSH
9337: LD_INT 1
9339: PPUSH
9340: CALL_OW 3
9344: ST_TO_ADDR
9345: GO 9324
9347: POP
9348: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9349: LD_VAR 0 11
9353: PPUSH
9354: LD_INT 35
9356: PUSH
9357: LD_INT 0
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 72
9368: PUSH
9369: LD_INT 0
9371: GREATER
9372: PUSH
9373: LD_VAR 0 9
9377: PPUSH
9378: CALL_OW 461
9382: PUSH
9383: LD_INT 2
9385: EQUAL
9386: AND
9387: IFFALSE 9439
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9389: LD_VAR 0 11
9393: PPUSH
9394: LD_INT 35
9396: PUSH
9397: LD_INT 0
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 72
9408: PUSH
9409: LD_INT 1
9411: ARRAY
9412: PPUSH
9413: LD_INT 28
9415: PUSH
9416: LD_INT 27
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 2
9428: PPUSH
9429: CALL_OW 12
9433: ARRAY
9434: PPUSH
9435: CALL_OW 148
// end ; if legion_enemy > 0 then
9439: LD_EXP 36
9443: PUSH
9444: LD_INT 0
9446: GREATER
9447: IFFALSE 10027
// begin if tick mod 11 11$00 = 0 then
9449: LD_OWVAR 1
9453: PUSH
9454: LD_INT 23100
9456: MOD
9457: PUSH
9458: LD_INT 0
9460: EQUAL
9461: IFFALSE 9711
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9463: LD_ADDR_EXP 35
9467: PUSH
9468: LD_EXP 35
9472: PUSH
9473: LD_INT 13
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: ADD
9487: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9488: LD_ADDR_EXP 35
9492: PUSH
9493: LD_EXP 35
9497: PUSH
9498: LD_INT 28
9500: PUSH
9501: LD_INT 27
9503: PUSH
9504: LD_INT 29
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 1
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: ARRAY
9523: ADD
9524: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9525: LD_ADDR_EXP 35
9529: PUSH
9530: LD_EXP 35
9534: PUSH
9535: LD_INT 13
9537: PUSH
9538: LD_INT 1
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: ADD
9549: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9550: LD_ADDR_EXP 35
9554: PUSH
9555: LD_EXP 35
9559: PUSH
9560: LD_INT 28
9562: PUSH
9563: LD_INT 27
9565: PUSH
9566: LD_INT 29
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 1
9576: PPUSH
9577: LD_INT 3
9579: PPUSH
9580: CALL_OW 12
9584: ARRAY
9585: ADD
9586: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9587: LD_ADDR_EXP 35
9591: PUSH
9592: LD_EXP 35
9596: PUSH
9597: LD_INT 13
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: LD_INT 2
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: ADD
9611: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9612: LD_ADDR_EXP 35
9616: PUSH
9617: LD_EXP 35
9621: PUSH
9622: LD_INT 28
9624: PUSH
9625: LD_INT 27
9627: PUSH
9628: LD_INT 29
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 1
9638: PPUSH
9639: LD_INT 3
9641: PPUSH
9642: CALL_OW 12
9646: ARRAY
9647: ADD
9648: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9649: LD_ADDR_EXP 35
9653: PUSH
9654: LD_EXP 35
9658: PUSH
9659: LD_INT 13
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 2
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: ADD
9673: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9674: LD_ADDR_EXP 35
9678: PUSH
9679: LD_EXP 35
9683: PUSH
9684: LD_INT 28
9686: PUSH
9687: LD_INT 27
9689: PUSH
9690: LD_INT 29
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 1
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: CALL_OW 12
9708: ARRAY
9709: ADD
9710: ST_TO_ADDR
// end ; if legion_force >= 7 then
9711: LD_EXP 31
9715: PUSH
9716: LD_INT 7
9718: GREATEREQUAL
9719: IFFALSE 9902
// begin for i = 1 to legion_force do
9721: LD_ADDR_VAR 0 2
9725: PUSH
9726: DOUBLE
9727: LD_INT 1
9729: DEC
9730: ST_TO_ADDR
9731: LD_EXP 31
9735: PUSH
9736: FOR_TO
9737: IFFALSE 9900
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9739: LD_EXP 31
9743: PUSH
9744: LD_VAR 0 2
9748: ARRAY
9749: PPUSH
9750: CALL_OW 314
9754: NOT
9755: PUSH
9756: LD_EXP 31
9760: PUSH
9761: LD_VAR 0 2
9765: ARRAY
9766: PPUSH
9767: CALL_OW 110
9771: PUSH
9772: LD_INT 11
9774: NONEQUAL
9775: AND
9776: IFFALSE 9898
// begin case legion_enemy of 1 :
9778: LD_EXP 36
9782: PUSH
9783: LD_INT 1
9785: DOUBLE
9786: EQUAL
9787: IFTRUE 9791
9789: GO 9815
9791: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 142
9805: PPUSH
9806: LD_INT 144
9808: PPUSH
9809: CALL_OW 111
9813: GO 9880
9815: LD_INT 2
9817: DOUBLE
9818: EQUAL
9819: IFTRUE 9823
9821: GO 9847
9823: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9824: LD_EXP 31
9828: PUSH
9829: LD_VAR 0 2
9833: ARRAY
9834: PPUSH
9835: LD_INT 101
9837: PPUSH
9838: LD_INT 34
9840: PPUSH
9841: CALL_OW 111
9845: GO 9880
9847: LD_INT 7
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9879
9855: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9856: LD_EXP 31
9860: PUSH
9861: LD_VAR 0 2
9865: ARRAY
9866: PPUSH
9867: LD_INT 173
9869: PPUSH
9870: LD_INT 127
9872: PPUSH
9873: CALL_OW 111
9877: GO 9880
9879: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9880: LD_EXP 31
9884: PUSH
9885: LD_VAR 0 2
9889: ARRAY
9890: PPUSH
9891: LD_INT 11
9893: PPUSH
9894: CALL_OW 109
// end ; end ;
9898: GO 9736
9900: POP
9901: POP
// end ; if legion_force then
9902: LD_EXP 31
9906: IFFALSE 10027
// begin tmp := legion_force ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_EXP 31
9917: ST_TO_ADDR
// for i = 1 to tmp do
9918: LD_ADDR_VAR 0 2
9922: PUSH
9923: DOUBLE
9924: LD_INT 1
9926: DEC
9927: ST_TO_ADDR
9928: LD_VAR 0 3
9932: PUSH
9933: FOR_TO
9934: IFFALSE 10025
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9936: LD_VAR 0 3
9940: PUSH
9941: LD_VAR 0 2
9945: ARRAY
9946: PPUSH
9947: CALL_OW 314
9951: NOT
9952: PUSH
9953: LD_EXP 31
9957: PUSH
9958: LD_VAR 0 2
9962: ARRAY
9963: PPUSH
9964: CALL_OW 110
9968: PUSH
9969: LD_INT 11
9971: EQUAL
9972: AND
9973: IFFALSE 10023
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9975: LD_VAR 0 3
9979: PUSH
9980: LD_VAR 0 2
9984: ARRAY
9985: PPUSH
9986: LD_INT 22
9988: PUSH
9989: LD_EXP 36
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PPUSH
9998: CALL_OW 69
10002: PPUSH
10003: LD_VAR 0 3
10007: PUSH
10008: LD_VAR 0 2
10012: ARRAY
10013: PPUSH
10014: CALL_OW 74
10018: PPUSH
10019: CALL_OW 115
10023: GO 9933
10025: POP
10026: POP
// end ; end ; p := 1 ;
10027: LD_ADDR_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: ST_TO_ADDR
// for i = 1 to 24 do
10035: LD_ADDR_VAR 0 2
10039: PUSH
10040: DOUBLE
10041: LD_INT 1
10043: DEC
10044: ST_TO_ADDR
10045: LD_INT 24
10047: PUSH
10048: FOR_TO
10049: IFFALSE 10179
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10051: LD_EXP 33
10055: PUSH
10056: LD_VAR 0 6
10060: ARRAY
10061: PPUSH
10062: LD_EXP 33
10066: PUSH
10067: LD_VAR 0 6
10071: PUSH
10072: LD_INT 1
10074: PLUS
10075: ARRAY
10076: PPUSH
10077: CALL_OW 428
10081: PUSH
10082: LD_INT 0
10084: GREATER
10085: IFFALSE 10163
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10087: LD_EXP 33
10091: PUSH
10092: LD_VAR 0 6
10096: ARRAY
10097: PPUSH
10098: LD_EXP 33
10102: PUSH
10103: LD_VAR 0 6
10107: PUSH
10108: LD_INT 1
10110: PLUS
10111: ARRAY
10112: PPUSH
10113: CALL_OW 428
10117: PPUSH
10118: CALL_OW 255
10122: PUSH
10123: LD_EXP 36
10127: EQUAL
10128: IFFALSE 10163
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10130: LD_EXP 33
10134: PUSH
10135: LD_VAR 0 6
10139: ARRAY
10140: PPUSH
10141: LD_EXP 33
10145: PUSH
10146: LD_VAR 0 6
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 8
10158: PPUSH
10159: CALL_OW 456
// p := p + 2 ;
10163: LD_ADDR_VAR 0 6
10167: PUSH
10168: LD_VAR 0 6
10172: PUSH
10173: LD_INT 2
10175: PLUS
10176: ST_TO_ADDR
// end ;
10177: GO 10048
10179: POP
10180: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10181: LD_INT 22
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 34
10193: PUSH
10194: LD_INT 32
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PPUSH
10205: CALL_OW 69
10209: IFFALSE 10323
// begin if l_cargo = false then
10211: LD_VAR 0 17
10215: PUSH
10216: LD_INT 0
10218: EQUAL
10219: IFFALSE 10255
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10221: LD_ADDR_VAR 0 17
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_INT 8
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 34
10238: PUSH
10239: LD_INT 32
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: ST_TO_ADDR
// if l_cargo then
10255: LD_VAR 0 17
10259: IFFALSE 10323
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10261: LD_ADDR_VAR 0 7
10265: PUSH
10266: LD_INT 14
10268: PPUSH
10269: CALL_OW 435
10273: ST_TO_ADDR
// if cr > 0 then
10274: LD_VAR 0 7
10278: PUSH
10279: LD_INT 0
10281: GREATER
10282: IFFALSE 10323
// if not HasTask ( l_cargo ) then
10284: LD_VAR 0 17
10288: PPUSH
10289: CALL_OW 314
10293: NOT
10294: IFFALSE 10323
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10296: LD_VAR 0 17
10300: PPUSH
10301: LD_VAR 0 7
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 2
10317: ARRAY
10318: PPUSH
10319: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10323: LD_OWVAR 1
10327: PUSH
10328: LD_INT 52500
10330: PUSH
10331: LD_INT 46200
10333: PUSH
10334: LD_INT 42000
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: LD_OWVAR 67
10346: ARRAY
10347: EQUAL
10348: PUSH
10349: LD_INT 1
10351: PPUSH
10352: CALL_OW 469
10356: PUSH
10357: LD_INT 1
10359: ARRAY
10360: PUSH
10361: LD_INT 112
10363: EQUAL
10364: AND
10365: PUSH
10366: LD_INT 1
10368: PPUSH
10369: CALL_OW 469
10373: PUSH
10374: LD_INT 2
10376: ARRAY
10377: PUSH
10378: LD_INT 67
10380: EQUAL
10381: AND
10382: IFFALSE 10475
// begin un := l_eng [ 1 ] ;
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_VAR 0 16
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: ST_TO_ADDR
// if IsInUnit ( un ) then
10398: LD_VAR 0 1
10402: PPUSH
10403: CALL_OW 310
10407: IFFALSE 10418
// ComExitBuilding ( un ) ;
10409: LD_VAR 0 1
10413: PPUSH
10414: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: LD_INT 1
10425: PPUSH
10426: CALL_OW 469
10430: PUSH
10431: LD_INT 1
10433: ARRAY
10434: PPUSH
10435: LD_INT 1
10437: PPUSH
10438: CALL_OW 469
10442: PUSH
10443: LD_INT 2
10445: ARRAY
10446: PPUSH
10447: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10451: LD_VAR 0 1
10455: PPUSH
10456: LD_INT 207
10458: PPUSH
10459: LD_INT 123
10461: PPUSH
10462: CALL_OW 171
// AddComUnload ( un ) ;
10466: LD_VAR 0 1
10470: PPUSH
10471: CALL_OW 219
// end ; end ;
10475: PPOPN 17
10477: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10478: LD_OWVAR 67
10482: PUSH
10483: LD_INT 1
10485: GREATER
10486: IFFALSE 10691
10488: GO 10490
10490: DISABLE
10491: LD_INT 0
10493: PPUSH
10494: PPUSH
10495: PPUSH
10496: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10497: LD_INT 35
10499: PPUSH
10500: LD_INT 12635
10502: PPUSH
10503: CALL_OW 12
10507: PPUSH
10508: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10512: LD_ADDR_VAR 0 2
10516: PUSH
10517: LD_INT 22
10519: PUSH
10520: LD_INT 8
10522: PUSH
10523: EMPTY
10524: LIST
10525: LIST
10526: PUSH
10527: LD_INT 25
10529: PUSH
10530: LD_INT 4
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PPUSH
10541: CALL_OW 69
10545: ST_TO_ADDR
// p := 1 ;
10546: LD_ADDR_VAR 0 4
10550: PUSH
10551: LD_INT 1
10553: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10554: LD_ADDR_VAR 0 3
10558: PUSH
10559: LD_INT 116
10561: PUSH
10562: LD_INT 139
10564: PUSH
10565: LD_INT 69
10567: PUSH
10568: LD_INT 13
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: ST_TO_ADDR
// for i = 1 to 2 do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: DOUBLE
10583: LD_INT 1
10585: DEC
10586: ST_TO_ADDR
10587: LD_INT 2
10589: PUSH
10590: FOR_TO
10591: IFFALSE 10689
// begin if IsInUnit ( sci [ i ] ) then
10593: LD_VAR 0 2
10597: PUSH
10598: LD_VAR 0 1
10602: ARRAY
10603: PPUSH
10604: CALL_OW 310
10608: IFFALSE 10625
// ComExitBuilding ( sci [ i ] ) ;
10610: LD_VAR 0 2
10614: PUSH
10615: LD_VAR 0 1
10619: ARRAY
10620: PPUSH
10621: CALL_OW 122
// Wait ( 0 0$03 ) ;
10625: LD_INT 105
10627: PPUSH
10628: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10632: LD_VAR 0 2
10636: PUSH
10637: LD_VAR 0 1
10641: ARRAY
10642: PPUSH
10643: LD_VAR 0 3
10647: PUSH
10648: LD_VAR 0 4
10652: ARRAY
10653: PPUSH
10654: LD_VAR 0 3
10658: PUSH
10659: LD_VAR 0 4
10663: PUSH
10664: LD_INT 1
10666: PLUS
10667: ARRAY
10668: PPUSH
10669: CALL_OW 158
// p := p + 2 ;
10673: LD_ADDR_VAR 0 4
10677: PUSH
10678: LD_VAR 0 4
10682: PUSH
10683: LD_INT 2
10685: PLUS
10686: ST_TO_ADDR
// end ;
10687: GO 10590
10689: POP
10690: POP
// end ;
10691: PPOPN 4
10693: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10694: LD_INT 14
10696: PPUSH
10697: CALL_OW 435
10701: PUSH
10702: LD_INT 20
10704: LESS
10705: IFFALSE 10732
10707: GO 10709
10709: DISABLE
// begin enable ;
10710: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10711: LD_INT 1
10713: PPUSH
10714: LD_INT 5
10716: PPUSH
10717: CALL_OW 12
10721: PPUSH
10722: LD_INT 14
10724: PPUSH
10725: LD_INT 1
10727: PPUSH
10728: CALL_OW 55
// end ; end_of_file
10732: END
// export function Action ; var un , gamemode ; begin
10733: LD_INT 0
10735: PPUSH
10736: PPUSH
10737: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10738: LD_ADDR_OWVAR 67
10742: PUSH
10743: LD_INT 0
10745: PPUSH
10746: CALL_OW 426
10750: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10751: LD_ADDR_VAR 0 3
10755: PUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 426
10763: ST_TO_ADDR
// if gamemode = 1 then
10764: LD_VAR 0 3
10768: PUSH
10769: LD_INT 1
10771: EQUAL
10772: IFFALSE 10796
// begin your_side := 1 ;
10774: LD_ADDR_OWVAR 2
10778: PUSH
10779: LD_INT 1
10781: ST_TO_ADDR
// legion_enemy := 1 ;
10782: LD_ADDR_EXP 36
10786: PUSH
10787: LD_INT 1
10789: ST_TO_ADDR
// PrepareAmerican ;
10790: CALL 221 0 0
// end else
10794: GO 10848
// if gamemode = 2 then
10796: LD_VAR 0 3
10800: PUSH
10801: LD_INT 2
10803: EQUAL
10804: IFFALSE 10828
// begin your_side := 2 ;
10806: LD_ADDR_OWVAR 2
10810: PUSH
10811: LD_INT 2
10813: ST_TO_ADDR
// legion_enemy := 2 ;
10814: LD_ADDR_EXP 36
10818: PUSH
10819: LD_INT 2
10821: ST_TO_ADDR
// PrepareArabian ;
10822: CALL 17445 0 0
// end else
10826: GO 10848
// begin your_side := 7 ;
10828: LD_ADDR_OWVAR 2
10832: PUSH
10833: LD_INT 7
10835: ST_TO_ADDR
// legion_enemy := 7 ;
10836: LD_ADDR_EXP 36
10840: PUSH
10841: LD_INT 7
10843: ST_TO_ADDR
// PrepareAlliance ;
10844: CALL 14856 0 0
// end ; if your_side = 1 then
10848: LD_OWVAR 2
10852: PUSH
10853: LD_INT 1
10855: EQUAL
10856: IFFALSE 11210
// begin case Query ( QVul4 ) of 1 :
10858: LD_STRING QVul4
10860: PPUSH
10861: CALL_OW 97
10865: PUSH
10866: LD_INT 1
10868: DOUBLE
10869: EQUAL
10870: IFTRUE 10874
10872: GO 10877
10874: POP
// ; end ;
10875: GO 10878
10877: POP
// InGameOn ;
10878: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10882: LD_INT 8
10884: PPUSH
10885: LD_INT 5
10887: PPUSH
10888: CALL_OW 86
// uc_side := 4 ;
10892: LD_ADDR_OWVAR 20
10896: PUSH
10897: LD_INT 4
10899: ST_TO_ADDR
// uc_nation := 1 ;
10900: LD_ADDR_OWVAR 21
10904: PUSH
10905: LD_INT 1
10907: ST_TO_ADDR
// hc_importance := 0 ;
10908: LD_ADDR_OWVAR 32
10912: PUSH
10913: LD_INT 0
10915: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10916: LD_INT 1
10918: PPUSH
10919: LD_INT 3
10921: PPUSH
10922: LD_EXP 21
10926: PPUSH
10927: CALL_OW 380
// un := CreateHuman ;
10931: LD_ADDR_VAR 0 2
10935: PUSH
10936: CALL_OW 44
10940: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10941: LD_VAR 0 2
10945: PPUSH
10946: LD_INT 12
10948: PPUSH
10949: LD_INT 9
10951: PPUSH
10952: LD_INT 0
10954: PPUSH
10955: CALL_OW 48
// hc_name := Stuart Carey ;
10959: LD_ADDR_OWVAR 26
10963: PUSH
10964: LD_STRING Stuart Carey
10966: ST_TO_ADDR
// hc_class := 1 ;
10967: LD_ADDR_OWVAR 28
10971: PUSH
10972: LD_INT 1
10974: ST_TO_ADDR
// hc_gallery := vulcano ;
10975: LD_ADDR_OWVAR 33
10979: PUSH
10980: LD_STRING vulcano
10982: ST_TO_ADDR
// hc_face_number := 1 ;
10983: LD_ADDR_OWVAR 34
10987: PUSH
10988: LD_INT 1
10990: ST_TO_ADDR
// us_guy := CreateHuman ;
10991: LD_ADDR_EXP 22
10995: PUSH
10996: CALL_OW 44
11000: ST_TO_ADDR
// hc_gallery :=  ;
11001: LD_ADDR_OWVAR 33
11005: PUSH
11006: LD_STRING 
11008: ST_TO_ADDR
// hc_name :=  ;
11009: LD_ADDR_OWVAR 26
11013: PUSH
11014: LD_STRING 
11016: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11017: LD_VAR 0 2
11021: PPUSH
11022: LD_EXP 19
11026: PPUSH
11027: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11031: LD_EXP 19
11035: PPUSH
11036: LD_VAR 0 2
11040: PPUSH
11041: CALL_OW 119
// Say ( un , VD-un1 ) ;
11045: LD_VAR 0 2
11049: PPUSH
11050: LD_STRING VD-un1
11052: PPUSH
11053: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11057: LD_EXP 19
11061: PPUSH
11062: LD_STRING VDc-1
11064: PPUSH
11065: CALL_OW 88
// Say ( un , VD-un2 ) ;
11069: LD_VAR 0 2
11073: PPUSH
11074: LD_STRING VD-un2
11076: PPUSH
11077: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11081: LD_EXP 19
11085: PPUSH
11086: LD_STRING VDc-2
11088: PPUSH
11089: CALL_OW 88
// Say ( un , VD-un3 ) ;
11093: LD_VAR 0 2
11097: PPUSH
11098: LD_STRING VD-un3
11100: PPUSH
11101: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11105: LD_INT 7
11107: PPUSH
11108: CALL_OW 67
// Say ( un , VD-un4 ) ;
11112: LD_VAR 0 2
11116: PPUSH
11117: LD_STRING VD-un4
11119: PPUSH
11120: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11124: LD_VAR 0 2
11128: PPUSH
11129: LD_INT 2
11131: PPUSH
11132: LD_INT 2
11134: PPUSH
11135: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11139: LD_EXP 19
11143: PPUSH
11144: LD_STRING VDc-3
11146: PPUSH
11147: CALL_OW 88
// InGameOff ;
11151: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11155: LD_STRING CVulc1
11157: PPUSH
11158: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11162: LD_INT 35
11164: PPUSH
11165: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11169: LD_VAR 0 2
11173: PPUSH
11174: CALL_OW 250
11178: PUSH
11179: LD_INT 2
11181: EQUAL
11182: PUSH
11183: LD_VAR 0 2
11187: PPUSH
11188: CALL_OW 251
11192: PUSH
11193: LD_INT 2
11195: EQUAL
11196: AND
11197: IFFALSE 11162
// RemoveUnit ( un ) ;
11199: LD_VAR 0 2
11203: PPUSH
11204: CALL_OW 64
// end else
11208: GO 11502
// if your_side = 2 then
11210: LD_OWVAR 2
11214: PUSH
11215: LD_INT 2
11217: EQUAL
11218: IFFALSE 11390
// begin CenterNowOnUnits ( player_commander ) ;
11220: LD_EXP 10
11224: PPUSH
11225: CALL_OW 87
// InGameOn ;
11229: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11233: LD_EXP 51
11237: PPUSH
11238: LD_STRING VSd-1
11240: PPUSH
11241: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11245: LD_INT 22
11247: PUSH
11248: LD_INT 2
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: LD_INT 21
11257: PUSH
11258: LD_INT 1
11260: PUSH
11261: EMPTY
11262: LIST
11263: LIST
11264: PUSH
11265: LD_INT 26
11267: PUSH
11268: LD_INT 1
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: LIST
11279: PUSH
11280: EMPTY
11281: LIST
11282: PPUSH
11283: CALL_OW 69
11287: PUSH
11288: LD_INT 2
11290: ARRAY
11291: PPUSH
11292: LD_STRING VAd-1
11294: PPUSH
11295: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11299: LD_EXP 51
11303: PPUSH
11304: LD_STRING VSd-2
11306: PPUSH
11307: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11311: LD_INT 22
11313: PUSH
11314: LD_INT 2
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: PUSH
11321: LD_INT 21
11323: PUSH
11324: LD_INT 1
11326: PUSH
11327: EMPTY
11328: LIST
11329: LIST
11330: PUSH
11331: LD_INT 26
11333: PUSH
11334: LD_INT 1
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: PUSH
11341: EMPTY
11342: LIST
11343: LIST
11344: LIST
11345: PUSH
11346: EMPTY
11347: LIST
11348: PPUSH
11349: CALL_OW 69
11353: PUSH
11354: LD_INT 2
11356: ARRAY
11357: PPUSH
11358: LD_STRING VAd-2
11360: PPUSH
11361: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11365: LD_EXP 51
11369: PPUSH
11370: LD_STRING VSd-3
11372: PPUSH
11373: CALL_OW 88
// InGameOff ;
11377: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11381: LD_STRING CVulc5
11383: PPUSH
11384: CALL_OW 337
// end else
11388: GO 11502
// if your_side = 7 then
11390: LD_OWVAR 2
11394: PUSH
11395: LD_INT 7
11397: EQUAL
11398: IFFALSE 11502
// begin CenterNowOnUnits ( al_commander ) ;
11400: LD_EXP 37
11404: PPUSH
11405: CALL_OW 87
// InGameOn ;
11409: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11413: LD_EXP 37
11417: PPUSH
11418: LD_STRING VPd-1
11420: PPUSH
11421: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11425: LD_INT 22
11427: PUSH
11428: LD_INT 7
11430: PUSH
11431: EMPTY
11432: LIST
11433: LIST
11434: PUSH
11435: LD_INT 21
11437: PUSH
11438: LD_INT 1
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: PUSH
11445: LD_INT 26
11447: PUSH
11448: LD_INT 1
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: EMPTY
11456: LIST
11457: LIST
11458: LIST
11459: PUSH
11460: EMPTY
11461: LIST
11462: PPUSH
11463: CALL_OW 69
11467: PUSH
11468: LD_INT 2
11470: ARRAY
11471: PPUSH
11472: LD_STRING VPpd-1
11474: PPUSH
11475: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11479: LD_EXP 37
11483: PPUSH
11484: LD_STRING VPd-2
11486: PPUSH
11487: CALL_OW 88
// InGameOff ;
11491: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11495: LD_STRING CVulc7
11497: PPUSH
11498: CALL_OW 337
// end ; end ;
11502: LD_VAR 0 1
11506: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11507: LD_INT 22
11509: PUSH
11510: LD_INT 2
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: PUSH
11517: LD_INT 30
11519: PUSH
11520: LD_INT 3
11522: PUSH
11523: EMPTY
11524: LIST
11525: LIST
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PPUSH
11531: CALL_OW 69
11535: IFFALSE 11579
11537: GO 11539
11539: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11540: LD_STRING CVulc6
11542: PPUSH
11543: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11547: LD_INT 52500
11549: PUSH
11550: LD_INT 47250
11552: PUSH
11553: LD_INT 42000
11555: PUSH
11556: EMPTY
11557: LIST
11558: LIST
11559: LIST
11560: PUSH
11561: LD_OWVAR 67
11565: ARRAY
11566: PPUSH
11567: CALL_OW 67
// ru_can_attack := true ;
11571: LD_ADDR_EXP 3
11575: PUSH
11576: LD_INT 1
11578: ST_TO_ADDR
// end ;
11579: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11580: LD_INT 50
11582: PPUSH
11583: CALL_OW 255
11587: PUSH
11588: LD_INT 1
11590: EQUAL
11591: PUSH
11592: LD_INT 22
11594: PUSH
11595: LD_INT 1
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: LD_INT 2
11604: PUSH
11605: LD_INT 30
11607: PUSH
11608: LD_INT 3
11610: PUSH
11611: EMPTY
11612: LIST
11613: LIST
11614: PUSH
11615: LD_INT 30
11617: PUSH
11618: LD_INT 1
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: LIST
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PPUSH
11634: CALL_OW 69
11638: OR
11639: IFFALSE 11816
11641: GO 11643
11643: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11644: LD_STRING CVulc2
11646: PPUSH
11647: CALL_OW 337
// DialogueOn ;
11651: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11655: LD_INT 10
11657: PPUSH
11658: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11662: LD_INT 22
11664: PUSH
11665: LD_INT 1
11667: PUSH
11668: EMPTY
11669: LIST
11670: LIST
11671: PUSH
11672: LD_INT 25
11674: PUSH
11675: LD_INT 2
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: PUSH
11691: LD_EXP 19
11695: DIFF
11696: PUSH
11697: LD_INT 1
11699: ARRAY
11700: PPUSH
11701: LD_STRING VDb-1
11703: PPUSH
11704: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11708: LD_INT 10
11710: PPUSH
11711: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11715: LD_INT 22
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: LD_INT 25
11727: PUSH
11728: LD_INT 4
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 69
11743: PUSH
11744: LD_EXP 19
11748: DIFF
11749: PUSH
11750: LD_INT 1
11752: ARRAY
11753: PPUSH
11754: LD_STRING VDb-2
11756: PPUSH
11757: CALL_OW 88
// DWait ( 0 0$01 ) ;
11761: LD_INT 35
11763: PPUSH
11764: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11768: LD_EXP 19
11772: PPUSH
11773: LD_STRING VDb-com1
11775: PPUSH
11776: CALL_OW 88
// DialogueOff ;
11780: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11784: LD_INT 44100
11786: PUSH
11787: LD_INT 36750
11789: PUSH
11790: LD_INT 31500
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PUSH
11798: LD_OWVAR 67
11802: ARRAY
11803: PPUSH
11804: CALL_OW 67
// ru_can_attack := true ;
11808: LD_ADDR_EXP 3
11812: PUSH
11813: LD_INT 1
11815: ST_TO_ADDR
// end ;
11816: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11817: LD_INT 22
11819: PUSH
11820: LD_INT 7
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: PUSH
11827: LD_INT 30
11829: PUSH
11830: LD_INT 3
11832: PUSH
11833: EMPTY
11834: LIST
11835: LIST
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: PPUSH
11841: CALL_OW 69
11845: IFFALSE 11882
11847: GO 11849
11849: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11850: LD_INT 42000
11852: PUSH
11853: LD_INT 34650
11855: PUSH
11856: LD_INT 29400
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: LIST
11863: PUSH
11864: LD_OWVAR 67
11868: ARRAY
11869: PPUSH
11870: CALL_OW 67
// ru_can_attack := true ;
11874: LD_ADDR_EXP 3
11878: PUSH
11879: LD_INT 1
11881: ST_TO_ADDR
// end ;
11882: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11883: LD_INT 58
11885: PPUSH
11886: CALL_OW 255
11890: PUSH
11891: LD_INT 1
11893: EQUAL
11894: IFFALSE 12026
11896: GO 11898
11898: DISABLE
// begin DialogueOn ;
11899: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11903: LD_INT 22
11905: PUSH
11906: LD_INT 1
11908: PUSH
11909: EMPTY
11910: LIST
11911: LIST
11912: PUSH
11913: LD_INT 25
11915: PUSH
11916: LD_INT 2
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PPUSH
11936: LD_STRING VDe-1
11938: PPUSH
11939: CALL_OW 88
// case Query ( SibNote ) of 1 :
11943: LD_STRING SibNote
11945: PPUSH
11946: CALL_OW 97
11950: PUSH
11951: LD_INT 1
11953: DOUBLE
11954: EQUAL
11955: IFTRUE 11959
11957: GO 11962
11959: POP
// ; end ;
11960: GO 11963
11962: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11963: LD_INT 22
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PUSH
11973: LD_INT 25
11975: PUSH
11976: LD_INT 2
11978: PUSH
11979: EMPTY
11980: LIST
11981: LIST
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PPUSH
11987: CALL_OW 69
11991: PUSH
11992: LD_INT 1
11994: ARRAY
11995: PPUSH
11996: LD_STRING VDe-2
11998: PPUSH
11999: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12003: LD_EXP 19
12007: PPUSH
12008: LD_STRING VDc-4
12010: PPUSH
12011: CALL_OW 88
// DialogueOff ;
12015: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12019: LD_STRING CVulc3
12021: PPUSH
12022: CALL_OW 337
// end ;
12026: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12027: LD_OWVAR 2
12031: PUSH
12032: LD_INT 1
12034: EQUAL
12035: PUSH
12036: LD_INT 22
12038: PUSH
12039: LD_INT 1
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 30
12048: PUSH
12049: LD_INT 3
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: PUSH
12065: LD_INT 0
12067: GREATER
12068: AND
12069: IFFALSE 12503
12071: GO 12073
12073: DISABLE
12074: LD_INT 0
12076: PPUSH
12077: PPUSH
12078: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12079: LD_INT 245
12081: PPUSH
12082: LD_INT 1295
12084: PPUSH
12085: CALL_OW 12
12089: PPUSH
12090: CALL_OW 67
// DialogueOn ;
12094: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12098: LD_EXP 22
12102: PPUSH
12103: LD_STRING VDG-1
12105: PPUSH
12106: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12110: LD_EXP 19
12114: PPUSH
12115: LD_STRING VDc-5
12117: PPUSH
12118: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12122: LD_EXP 22
12126: PPUSH
12127: LD_STRING VDG-2
12129: PPUSH
12130: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12134: LD_EXP 19
12138: PPUSH
12139: LD_STRING VDc-6
12141: PPUSH
12142: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12146: LD_EXP 22
12150: PPUSH
12151: LD_STRING VDG-3
12153: PPUSH
12154: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12158: LD_EXP 19
12162: PPUSH
12163: LD_STRING VDc-7
12165: PPUSH
12166: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12170: LD_EXP 22
12174: PPUSH
12175: LD_STRING VDG-4
12177: PPUSH
12178: CALL_OW 94
// DialogueOff ;
12182: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12186: LD_STRING CVulc4
12188: PPUSH
12189: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12193: LD_INT 18900
12195: PUSH
12196: LD_INT 21000
12198: PUSH
12199: LD_INT 23100
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: PUSH
12207: LD_OWVAR 67
12211: ARRAY
12212: PPUSH
12213: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: DOUBLE
12223: LD_INT 1
12225: DEC
12226: ST_TO_ADDR
12227: LD_INT 4
12229: PUSH
12230: LD_INT 5
12232: PUSH
12233: LD_INT 6
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: LIST
12240: PUSH
12241: LD_OWVAR 67
12245: ARRAY
12246: PUSH
12247: FOR_TO
12248: IFFALSE 12492
// begin uc_side := 1 ;
12250: LD_ADDR_OWVAR 20
12254: PUSH
12255: LD_INT 1
12257: ST_TO_ADDR
// uc_nation := 1 ;
12258: LD_ADDR_OWVAR 21
12262: PUSH
12263: LD_INT 1
12265: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12266: LD_INT 0
12268: PPUSH
12269: LD_INT 1
12271: PPUSH
12272: LD_INT 4
12274: PPUSH
12275: CALL_OW 12
12279: PPUSH
12280: LD_EXP 21
12284: PPUSH
12285: CALL_OW 380
// un := CreateHuman ;
12289: LD_ADDR_VAR 0 2
12293: PUSH
12294: CALL_OW 44
12298: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12299: LD_VAR 0 2
12303: PPUSH
12304: LD_INT 2
12306: PPUSH
12307: CALL_OW 233
// if GetClass ( un ) = 3 then
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 257
12320: PUSH
12321: LD_INT 3
12323: EQUAL
12324: IFFALSE 12475
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12326: LD_ADDR_OWVAR 37
12330: PUSH
12331: LD_INT 2
12333: PUSH
12334: LD_INT 3
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_VAR 0 1
12345: PUSH
12346: LD_INT 2
12348: MOD
12349: ARRAY
12350: ST_TO_ADDR
// vc_engine := engine_combustion ;
12351: LD_ADDR_OWVAR 39
12355: PUSH
12356: LD_INT 1
12358: ST_TO_ADDR
// vc_control := control_manual ;
12359: LD_ADDR_OWVAR 38
12363: PUSH
12364: LD_INT 1
12366: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12367: LD_ADDR_OWVAR 40
12371: PUSH
12372: LD_INT 9
12374: PUSH
12375: LD_INT 9
12377: PUSH
12378: LD_INT 5
12380: PUSH
12381: LD_INT 11
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: PUSH
12390: LD_INT 1
12392: PPUSH
12393: LD_INT 4
12395: PPUSH
12396: CALL_OW 12
12400: ARRAY
12401: ST_TO_ADDR
// veh := CreateVehicle ;
12402: LD_ADDR_VAR 0 3
12406: PUSH
12407: CALL_OW 45
12411: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12412: LD_VAR 0 3
12416: PPUSH
12417: LD_INT 2
12419: PPUSH
12420: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12424: LD_VAR 0 3
12428: PPUSH
12429: LD_INT 77
12431: PPUSH
12432: LD_INT 88
12434: PPUSH
12435: CALL_OW 12
12439: PPUSH
12440: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12444: LD_VAR 0 3
12448: PPUSH
12449: LD_INT 1
12451: PPUSH
12452: LD_INT 0
12454: PPUSH
12455: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12459: LD_VAR 0 2
12463: PPUSH
12464: LD_VAR 0 3
12468: PPUSH
12469: CALL_OW 52
// end else
12473: GO 12490
// PlaceUnitArea ( un , start_north , false ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: LD_INT 1
12482: PPUSH
12483: LD_INT 0
12485: PPUSH
12486: CALL_OW 49
// end ;
12490: GO 12247
12492: POP
12493: POP
// CenterNowOnUnits ( un ) ;
12494: LD_VAR 0 2
12498: PPUSH
12499: CALL_OW 87
// end ;
12503: PPOPN 3
12505: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12506: LD_INT 21
12508: PPUSH
12509: LD_INT 22
12511: PUSH
12512: LD_OWVAR 2
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PPUSH
12521: CALL_OW 70
12525: IFFALSE 12747
12527: GO 12529
12529: DISABLE
12530: LD_INT 0
12532: PPUSH
12533: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12534: LD_ADDR_VAR 0 2
12538: PUSH
12539: LD_INT 22
12541: PUSH
12542: LD_OWVAR 2
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 2
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 1
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: LD_INT 25
12566: PUSH
12567: LD_INT 2
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PUSH
12574: LD_INT 25
12576: PUSH
12577: LD_INT 3
12579: PUSH
12580: EMPTY
12581: LIST
12582: LIST
12583: PUSH
12584: LD_INT 25
12586: PUSH
12587: LD_INT 4
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: LIST
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: PUSH
12610: LD_EXP 10
12614: DIFF
12615: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12616: LD_ADDR_VAR 0 1
12620: PUSH
12621: LD_VAR 0 2
12625: PPUSH
12626: LD_INT 112
12628: PPUSH
12629: LD_INT 67
12631: PPUSH
12632: CALL_OW 73
12636: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12637: LD_VAR 0 1
12641: PPUSH
12642: CALL_OW 255
12646: PUSH
12647: LD_INT 7
12649: EQUAL
12650: IFFALSE 12664
// Say ( un , VD-find-al ) ;
12652: LD_VAR 0 1
12656: PPUSH
12657: LD_STRING VD-find-al
12659: PPUSH
12660: CALL_OW 88
// if GetSide ( un ) = 2 then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 255
12673: PUSH
12674: LD_INT 2
12676: EQUAL
12677: IFFALSE 12691
// Say ( un , VD-find-ar ) ;
12679: LD_VAR 0 1
12683: PPUSH
12684: LD_STRING VD-find-ar
12686: PPUSH
12687: CALL_OW 88
// if GetSide ( un ) = 1 then
12691: LD_VAR 0 1
12695: PPUSH
12696: CALL_OW 255
12700: PUSH
12701: LD_INT 1
12703: EQUAL
12704: IFFALSE 12730
// begin Say ( un , VD-find-us ) ;
12706: LD_VAR 0 1
12710: PPUSH
12711: LD_STRING VD-find-us
12713: PPUSH
12714: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12718: LD_VAR 0 1
12722: PPUSH
12723: LD_STRING VD-find-us2
12725: PPUSH
12726: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12730: LD_INT 10
12732: PPUSH
12733: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12737: LD_INT 112
12739: PPUSH
12740: LD_INT 67
12742: PPUSH
12743: CALL_OW 86
// end ;
12747: PPOPN 2
12749: END
// every 0 0$01 trigger player_artifact_ready do
12750: LD_EXP 7
12754: IFFALSE 13068
12756: GO 12758
12758: DISABLE
// begin if your_side = 1 then
12759: LD_OWVAR 2
12763: PUSH
12764: LD_INT 1
12766: EQUAL
12767: IFFALSE 12885
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12769: LD_INT 22
12771: PUSH
12772: LD_INT 1
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PUSH
12779: LD_INT 25
12781: PUSH
12782: LD_INT 4
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PPUSH
12793: CALL_OW 69
12797: PUSH
12798: LD_EXP 19
12802: DIFF
12803: PUSH
12804: LD_INT 1
12806: ARRAY
12807: PPUSH
12808: LD_STRING VD-us-sci-art-1
12810: PPUSH
12811: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12815: LD_EXP 19
12819: PPUSH
12820: LD_STRING VDc-art1
12822: PPUSH
12823: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12827: LD_INT 22
12829: PUSH
12830: LD_INT 1
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: LD_INT 25
12839: PUSH
12840: LD_INT 4
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PPUSH
12851: CALL_OW 69
12855: PUSH
12856: LD_EXP 19
12860: DIFF
12861: PUSH
12862: LD_INT 1
12864: ARRAY
12865: PPUSH
12866: LD_STRING VD-us-sci-art-2
12868: PPUSH
12869: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12873: LD_EXP 19
12877: PPUSH
12878: LD_STRING VDc-art2
12880: PPUSH
12881: CALL_OW 88
// end ; if your_side = 2 then
12885: LD_OWVAR 2
12889: PUSH
12890: LD_INT 2
12892: EQUAL
12893: IFFALSE 12935
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12895: LD_INT 22
12897: PUSH
12898: LD_INT 2
12900: PUSH
12901: EMPTY
12902: LIST
12903: LIST
12904: PUSH
12905: LD_INT 25
12907: PUSH
12908: LD_INT 4
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: PPUSH
12919: CALL_OW 69
12923: PUSH
12924: LD_INT 1
12926: ARRAY
12927: PPUSH
12928: LD_STRING VD-ar-sci-art-1
12930: PPUSH
12931: CALL_OW 88
// end ; if your_side = 7 then
12935: LD_OWVAR 2
12939: PUSH
12940: LD_INT 7
12942: EQUAL
12943: IFFALSE 13068
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 25
12957: PUSH
12958: LD_INT 4
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_EXP 37
12978: DIFF
12979: PUSH
12980: LD_INT 1
12982: ARRAY
12983: PPUSH
12984: LD_STRING VD-al-sci-art-1
12986: PPUSH
12987: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
12991: LD_EXP 37
12995: PPUSH
12996: LD_STRING VPd-art-1
12998: PPUSH
12999: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13003: LD_INT 22
13005: PUSH
13006: LD_INT 7
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 25
13015: PUSH
13016: LD_INT 4
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: PPUSH
13027: CALL_OW 69
13031: PUSH
13032: LD_EXP 37
13036: DIFF
13037: PUSH
13038: LD_INT 1
13040: ARRAY
13041: PPUSH
13042: LD_STRING VD-al-sci-art-2
13044: PPUSH
13045: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13049: LD_EXP 37
13053: PPUSH
13054: LD_STRING VPd-art-2
13056: PPUSH
13057: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13061: LD_STRING CVulc7out
13063: PPUSH
13064: CALL_OW 337
// end ; end ;
13068: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13069: LD_INT 8
13071: PPUSH
13072: LD_INT 22
13074: PUSH
13075: LD_OWVAR 2
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PPUSH
13084: CALL_OW 69
13088: PPUSH
13089: LD_INT 8
13091: PPUSH
13092: CALL 2145 0 2
13096: PPUSH
13097: CALL_OW 292
13101: IFFALSE 13192
13103: GO 13105
13105: DISABLE
// begin if your_side = 1 then
13106: LD_OWVAR 2
13110: PUSH
13111: LD_INT 1
13113: EQUAL
13114: IFFALSE 13148
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13116: LD_INT 22
13118: PUSH
13119: LD_INT 1
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PPUSH
13126: CALL_OW 69
13130: PUSH
13131: LD_EXP 19
13135: DIFF
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING VD-legion-us
13143: PPUSH
13144: CALL_OW 88
// if your_side = 2 then
13148: LD_OWVAR 2
13152: PUSH
13153: LD_INT 2
13155: EQUAL
13156: IFFALSE 13170
// Say ( ar_commander , VD-legion-ar ) ;
13158: LD_EXP 51
13162: PPUSH
13163: LD_STRING VD-legion-ar
13165: PPUSH
13166: CALL_OW 88
// if your_side = 7 then
13170: LD_OWVAR 2
13174: PUSH
13175: LD_INT 7
13177: EQUAL
13178: IFFALSE 13192
// Say ( al_commander , VD-legion-al ) ;
13180: LD_EXP 37
13184: PPUSH
13185: LD_STRING VD-legion-al
13187: PPUSH
13188: CALL_OW 88
// end ;
13192: END
// every 0 0$01 trigger mine_vulc do
13193: LD_EXP 12
13197: IFFALSE 13214
13199: GO 13201
13201: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13202: LD_EXP 10
13206: PPUSH
13207: LD_STRING VD-vulc-mines
13209: PPUSH
13210: CALL_OW 88
// end ;
13214: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13215: LD_OWVAR 67
13219: PUSH
13220: LD_INT 1
13222: GREATER
13223: IFFALSE 13342
13225: GO 13227
13227: DISABLE
13228: LD_INT 0
13230: PPUSH
13231: PPUSH
13232: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13233: LD_ADDR_VAR 0 1
13237: PUSH
13238: LD_INT 123
13240: PUSH
13241: LD_INT 95
13243: PUSH
13244: LD_INT 119
13246: PUSH
13247: LD_INT 89
13249: PUSH
13250: LD_INT 115
13252: PUSH
13253: LD_INT 81
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: ST_TO_ADDR
// p := 1 ;
13264: LD_ADDR_VAR 0 2
13268: PUSH
13269: LD_INT 1
13271: ST_TO_ADDR
// for i = 1 to 3 do
13272: LD_ADDR_VAR 0 3
13276: PUSH
13277: DOUBLE
13278: LD_INT 1
13280: DEC
13281: ST_TO_ADDR
13282: LD_INT 3
13284: PUSH
13285: FOR_TO
13286: IFFALSE 13340
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13288: LD_VAR 0 1
13292: PUSH
13293: LD_VAR 0 2
13297: ARRAY
13298: PPUSH
13299: LD_VAR 0 1
13303: PUSH
13304: LD_VAR 0 2
13308: PUSH
13309: LD_INT 1
13311: PLUS
13312: ARRAY
13313: PPUSH
13314: LD_INT 8
13316: PPUSH
13317: LD_INT 0
13319: PPUSH
13320: CALL_OW 454
// p := p + 2 ;
13324: LD_ADDR_VAR 0 2
13328: PUSH
13329: LD_VAR 0 2
13333: PUSH
13334: LD_INT 2
13336: PLUS
13337: ST_TO_ADDR
// end ;
13338: GO 13285
13340: POP
13341: POP
// end ;
13342: PPOPN 3
13344: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13345: LD_OWVAR 67
13349: PUSH
13350: LD_INT 1
13352: GREATER
13353: PUSH
13354: LD_INT 22
13356: PPUSH
13357: LD_INT 22
13359: PUSH
13360: LD_OWVAR 2
13364: PUSH
13365: EMPTY
13366: LIST
13367: LIST
13368: PPUSH
13369: CALL_OW 70
13373: AND
13374: IFFALSE 13578
13376: GO 13378
13378: DISABLE
13379: LD_INT 0
13381: PPUSH
13382: PPUSH
13383: PPUSH
// begin enable ;
13384: ENABLE
// p := 1 ;
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_INT 1
13392: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13393: LD_ADDR_VAR 0 3
13397: PUSH
13398: LD_INT 123
13400: PUSH
13401: LD_INT 95
13403: PUSH
13404: LD_INT 119
13406: PUSH
13407: LD_INT 89
13409: PUSH
13410: LD_INT 115
13412: PUSH
13413: LD_INT 81
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: ST_TO_ADDR
// for i = 1 to 3 do
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: DOUBLE
13430: LD_INT 1
13432: DEC
13433: ST_TO_ADDR
13434: LD_INT 3
13436: PUSH
13437: FOR_TO
13438: IFFALSE 13576
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13440: LD_VAR 0 3
13444: PUSH
13445: LD_VAR 0 1
13449: ARRAY
13450: PPUSH
13451: LD_VAR 0 3
13455: PUSH
13456: LD_VAR 0 1
13460: PUSH
13461: LD_INT 1
13463: PLUS
13464: ARRAY
13465: PPUSH
13466: CALL_OW 428
13470: PUSH
13471: LD_INT 0
13473: GREATER
13474: IFFALSE 13560
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13476: LD_VAR 0 3
13480: PUSH
13481: LD_VAR 0 1
13485: ARRAY
13486: PPUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_VAR 0 1
13496: PUSH
13497: LD_INT 1
13499: PLUS
13500: ARRAY
13501: PPUSH
13502: CALL_OW 428
13506: PPUSH
13507: CALL_OW 255
13511: PUSH
13512: LD_OWVAR 2
13516: EQUAL
13517: IFFALSE 13560
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13519: LD_VAR 0 3
13523: PUSH
13524: LD_VAR 0 1
13528: ARRAY
13529: PPUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 1
13539: PUSH
13540: LD_INT 1
13542: PLUS
13543: ARRAY
13544: PPUSH
13545: LD_INT 8
13547: PPUSH
13548: CALL_OW 456
// mine_vulc := true ;
13552: LD_ADDR_EXP 12
13556: PUSH
13557: LD_INT 1
13559: ST_TO_ADDR
// end ; p := p + 2 ;
13560: LD_ADDR_VAR 0 1
13564: PUSH
13565: LD_VAR 0 1
13569: PUSH
13570: LD_INT 2
13572: PLUS
13573: ST_TO_ADDR
// end ;
13574: GO 13437
13576: POP
13577: POP
// end ;
13578: PPOPN 3
13580: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13581: LD_INT 22
13583: PUSH
13584: LD_INT 3
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PPUSH
13591: CALL_OW 69
13595: PUSH
13596: LD_INT 0
13598: EQUAL
13599: PUSH
13600: LD_OWVAR 2
13604: PUSH
13605: LD_INT 2
13607: NONEQUAL
13608: AND
13609: IFFALSE 13618
13611: GO 13613
13613: DISABLE
// Win ;
13614: CALL 13675 0 0
13618: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13619: LD_INT 2
13621: PUSH
13622: LD_INT 22
13624: PUSH
13625: LD_INT 8
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: PUSH
13632: LD_INT 22
13634: PUSH
13635: LD_INT 3
13637: PUSH
13638: EMPTY
13639: LIST
13640: LIST
13641: PUSH
13642: EMPTY
13643: LIST
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 69
13651: PUSH
13652: LD_INT 0
13654: EQUAL
13655: PUSH
13656: LD_OWVAR 2
13660: PUSH
13661: LD_INT 2
13663: EQUAL
13664: AND
13665: IFFALSE 13674
13667: GO 13669
13669: DISABLE
// Win ;
13670: CALL 13675 0 0
13674: END
// function Win ; var points ; begin
13675: LD_INT 0
13677: PPUSH
13678: PPUSH
// case Query ( VulcWin ) of 1 :
13679: LD_STRING VulcWin
13681: PPUSH
13682: CALL_OW 97
13686: PUSH
13687: LD_INT 1
13689: DOUBLE
13690: EQUAL
13691: IFTRUE 13695
13693: GO 13698
13695: POP
// ; end ;
13696: GO 13699
13698: POP
// if medal_enabled then
13699: LD_EXP 13
13703: IFFALSE 13717
// AddMedal ( vulc_1 , 1 ) else
13705: LD_STRING vulc_1
13707: PPUSH
13708: LD_INT 1
13710: PPUSH
13711: CALL_OW 101
13715: GO 13728
// AddMedal ( vulc_1 , - 1 ) ;
13717: LD_STRING vulc_1
13719: PPUSH
13720: LD_INT 1
13722: NEG
13723: PPUSH
13724: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13728: LD_INT 22
13730: PUSH
13731: LD_INT 8
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PPUSH
13738: CALL_OW 69
13742: PUSH
13743: LD_INT 0
13745: EQUAL
13746: IFFALSE 13760
// AddMedal ( vulc_2 , 1 ) else
13748: LD_STRING vulc_2
13750: PPUSH
13751: LD_INT 1
13753: PPUSH
13754: CALL_OW 101
13758: GO 13771
// AddMedal ( vulc_2 , - 1 ) ;
13760: LD_STRING vulc_2
13762: PPUSH
13763: LD_INT 1
13765: NEG
13766: PPUSH
13767: CALL_OW 101
// points := CalculateCommanderPoints ;
13771: LD_ADDR_VAR 0 2
13775: PUSH
13776: CALL 2266 0 0
13780: ST_TO_ADDR
// if points >= 2000 then
13781: LD_VAR 0 2
13785: PUSH
13786: LD_INT 2000
13788: GREATEREQUAL
13789: IFFALSE 13803
// AddMedal ( vulc_3 , 2 ) else
13791: LD_STRING vulc_3
13793: PPUSH
13794: LD_INT 2
13796: PPUSH
13797: CALL_OW 101
13801: GO 13836
// if points >= 0 then
13803: LD_VAR 0 2
13807: PUSH
13808: LD_INT 0
13810: GREATEREQUAL
13811: IFFALSE 13825
// AddMedal ( vulc_3 , 1 ) else
13813: LD_STRING vulc_3
13815: PPUSH
13816: LD_INT 1
13818: PPUSH
13819: CALL_OW 101
13823: GO 13836
// AddMedal ( vulc_3 , - 1 ) ;
13825: LD_STRING vulc_3
13827: PPUSH
13828: LD_INT 1
13830: NEG
13831: PPUSH
13832: CALL_OW 101
// GiveMedals ( MAIN ) ;
13836: LD_STRING MAIN
13838: PPUSH
13839: CALL_OW 102
// YouWin ;
13843: CALL_OW 103
// end ; end_of_file
13847: LD_VAR 0 1
13851: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13852: LD_INT 13
13854: PPUSH
13855: LD_INT 21
13857: PUSH
13858: LD_INT 1
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PPUSH
13865: CALL_OW 70
13869: PUSH
13870: LD_INT 0
13872: GREATER
13873: IFFALSE 13940
13875: GO 13877
13877: DISABLE
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
// begin enable ;
13882: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13883: LD_ADDR_VAR 0 1
13887: PUSH
13888: LD_INT 13
13890: PPUSH
13891: LD_INT 21
13893: PUSH
13894: LD_INT 1
13896: PUSH
13897: EMPTY
13898: LIST
13899: LIST
13900: PPUSH
13901: CALL_OW 70
13905: PUSH
13906: FOR_IN
13907: IFFALSE 13938
// if GetLives ( i ) > 4 then
13909: LD_VAR 0 1
13913: PPUSH
13914: CALL_OW 256
13918: PUSH
13919: LD_INT 4
13921: GREATER
13922: IFFALSE 13936
// SetLives ( i , 4 ) ;
13924: LD_VAR 0 1
13928: PPUSH
13929: LD_INT 4
13931: PPUSH
13932: CALL_OW 234
13936: GO 13906
13938: POP
13939: POP
// end ;
13940: PPOPN 2
13942: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13943: LD_VAR 0 1
13947: PPUSH
13948: CALL_OW 255
13952: PUSH
13953: LD_OWVAR 2
13957: EQUAL
13958: IFFALSE 13968
// player_res_art := true ;
13960: LD_ADDR_EXP 6
13964: PUSH
13965: LD_INT 1
13967: ST_TO_ADDR
// end ;
13968: PPOPN 1
13970: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13971: LD_INT 22
13973: PUSH
13974: LD_OWVAR 2
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PUSH
13983: LD_INT 2
13985: PUSH
13986: LD_INT 30
13988: PUSH
13989: LD_INT 8
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 30
13998: PUSH
13999: LD_INT 11
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: LIST
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PPUSH
14015: CALL_OW 69
14019: PUSH
14020: LD_EXP 6
14024: AND
14025: IFFALSE 14369
14027: GO 14029
14029: DISABLE
14030: LD_INT 0
14032: PPUSH
14033: PPUSH
14034: PPUSH
// begin enable ;
14035: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14036: LD_ADDR_VAR 0 1
14040: PUSH
14041: LD_INT 1
14043: PPUSH
14044: CALL_OW 469
14048: PUSH
14049: LD_INT 1
14051: ARRAY
14052: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14053: LD_ADDR_VAR 0 2
14057: PUSH
14058: LD_INT 1
14060: PPUSH
14061: CALL_OW 469
14065: PUSH
14066: LD_INT 2
14068: ARRAY
14069: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14070: LD_ADDR_VAR 0 3
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_OWVAR 2
14082: PUSH
14083: EMPTY
14084: LIST
14085: LIST
14086: PUSH
14087: LD_INT 2
14089: PUSH
14090: LD_INT 30
14092: PUSH
14093: LD_INT 8
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: PUSH
14100: LD_INT 30
14102: PUSH
14103: LD_INT 11
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: LIST
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PPUSH
14119: CALL_OW 69
14123: PPUSH
14124: LD_VAR 0 1
14128: PPUSH
14129: LD_VAR 0 2
14133: PPUSH
14134: CALL_OW 73
14138: ST_TO_ADDR
// if player_artifact_ready = false then
14139: LD_EXP 7
14143: PUSH
14144: LD_INT 0
14146: EQUAL
14147: IFFALSE 14253
// if GetDistUnitXY ( lab , x , y ) < 6 then
14149: LD_VAR 0 3
14153: PPUSH
14154: LD_VAR 0 1
14158: PPUSH
14159: LD_VAR 0 2
14163: PPUSH
14164: CALL_OW 297
14168: PUSH
14169: LD_INT 6
14171: LESS
14172: IFFALSE 14233
// begin if BuildingStatus ( lab ) = bs_idle then
14174: LD_VAR 0 3
14178: PPUSH
14179: CALL_OW 461
14183: PUSH
14184: LD_INT 2
14186: EQUAL
14187: IFFALSE 14211
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14189: LD_OWVAR 2
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: LD_INT 2
14199: PPUSH
14200: LD_VAR 0 3
14204: PPUSH
14205: CALL_OW 468
14209: GO 14231
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14211: LD_OWVAR 2
14215: PPUSH
14216: LD_INT 1
14218: PPUSH
14219: LD_INT 1
14221: PPUSH
14222: LD_VAR 0 3
14226: PPUSH
14227: CALL_OW 468
// end else
14231: GO 14253
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14233: LD_OWVAR 2
14237: PPUSH
14238: LD_INT 1
14240: PPUSH
14241: LD_INT 1
14243: PPUSH
14244: LD_VAR 0 3
14248: PPUSH
14249: CALL_OW 468
// if player_artifact_ready then
14253: LD_EXP 7
14257: IFFALSE 14369
// if GetDistUnitXY ( lab , x , y ) < 6 then
14259: LD_VAR 0 3
14263: PPUSH
14264: LD_VAR 0 1
14268: PPUSH
14269: LD_VAR 0 2
14273: PPUSH
14274: CALL_OW 297
14278: PUSH
14279: LD_INT 6
14281: LESS
14282: IFFALSE 14347
// begin if BuildingStatus ( lab ) = bs_idle then
14284: LD_VAR 0 3
14288: PPUSH
14289: CALL_OW 461
14293: PUSH
14294: LD_INT 2
14296: EQUAL
14297: IFFALSE 14323
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14299: LD_OWVAR 2
14303: PPUSH
14304: LD_EXP 8
14308: PPUSH
14309: LD_INT 4
14311: PPUSH
14312: LD_VAR 0 3
14316: PPUSH
14317: CALL_OW 468
14321: GO 14345
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14323: LD_OWVAR 2
14327: PPUSH
14328: LD_EXP 8
14332: PPUSH
14333: LD_INT 1
14335: PPUSH
14336: LD_VAR 0 3
14340: PPUSH
14341: CALL_OW 468
// end else
14345: GO 14369
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14347: LD_OWVAR 2
14351: PPUSH
14352: LD_EXP 8
14356: PPUSH
14357: LD_INT 1
14359: PPUSH
14360: LD_VAR 0 3
14364: PPUSH
14365: CALL_OW 468
// end ;
14369: PPOPN 3
14371: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14372: LD_INT 0
14374: PPUSH
14375: PPUSH
14376: PPUSH
14377: PPUSH
14378: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14379: LD_ADDR_VAR 0 5
14383: PUSH
14384: LD_INT 1
14386: PPUSH
14387: CALL_OW 469
14391: PUSH
14392: LD_INT 1
14394: ARRAY
14395: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14396: LD_ADDR_VAR 0 6
14400: PUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 469
14408: PUSH
14409: LD_INT 2
14411: ARRAY
14412: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14413: LD_ADDR_VAR 0 8
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_OWVAR 2
14425: PUSH
14426: EMPTY
14427: LIST
14428: LIST
14429: PUSH
14430: LD_INT 2
14432: PUSH
14433: LD_INT 30
14435: PUSH
14436: LD_INT 8
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 30
14445: PUSH
14446: LD_INT 11
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PPUSH
14462: CALL_OW 69
14466: PPUSH
14467: LD_VAR 0 5
14471: PPUSH
14472: LD_VAR 0 6
14476: PPUSH
14477: CALL_OW 73
14481: ST_TO_ADDR
// if icon = art_exp_left then
14482: LD_VAR 0 2
14486: PUSH
14487: LD_INT 1
14489: EQUAL
14490: IFFALSE 14529
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14492: LD_VAR 0 8
14496: PPUSH
14497: LD_EXP 9
14501: PPUSH
14502: LD_INT 1
14504: PPUSH
14505: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14509: LD_OWVAR 2
14513: PPUSH
14514: LD_INT 1
14516: PPUSH
14517: LD_INT 0
14519: PPUSH
14520: LD_VAR 0 8
14524: PPUSH
14525: CALL_OW 468
// end ; if icon = art_icon then
14529: LD_VAR 0 2
14533: PUSH
14534: LD_EXP 8
14538: EQUAL
14539: IFFALSE 14753
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14541: LD_VAR 0 3
14545: PUSH
14546: LD_INT 21
14548: PUSH
14549: LD_INT 3
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PPUSH
14556: CALL_OW 69
14560: IN
14561: IFFALSE 14753
// begin side := GetSide ( cr1 ) ;
14563: LD_ADDR_VAR 0 9
14567: PUSH
14568: LD_VAR 0 3
14572: PPUSH
14573: CALL_OW 255
14577: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14578: LD_INT 22
14580: PUSH
14581: LD_VAR 0 9
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: PUSH
14590: LD_INT 30
14592: PUSH
14593: LD_INT 28
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PPUSH
14604: CALL_OW 69
14608: PUSH
14609: LD_INT 0
14611: GREATER
14612: IFFALSE 14753
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14614: LD_ADDR_VAR 0 7
14618: PUSH
14619: LD_INT 22
14621: PUSH
14622: LD_VAR 0 9
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: LD_INT 30
14636: PUSH
14637: LD_INT 26
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PUSH
14644: LD_INT 30
14646: PUSH
14647: LD_INT 27
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PUSH
14654: LD_INT 30
14656: PUSH
14657: LD_INT 28
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: PPUSH
14674: CALL_OW 69
14678: PUSH
14679: FOR_IN
14680: IFFALSE 14696
// SetLives ( i , 1 ) ;
14682: LD_VAR 0 7
14686: PPUSH
14687: LD_INT 1
14689: PPUSH
14690: CALL_OW 234
14694: GO 14679
14696: POP
14697: POP
// player_res_art := false ;
14698: LD_ADDR_EXP 6
14702: PUSH
14703: LD_INT 0
14705: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14706: LD_OWVAR 2
14710: PPUSH
14711: LD_EXP 8
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: LD_VAR 0 8
14723: PPUSH
14724: CALL_OW 468
// Wait ( time_to_reuse ) ;
14728: LD_EXP 11
14732: PPUSH
14733: CALL_OW 67
// player_res_art := true ;
14737: LD_ADDR_EXP 6
14741: PUSH
14742: LD_INT 1
14744: ST_TO_ADDR
// medal_enabled := true ;
14745: LD_ADDR_EXP 13
14749: PUSH
14750: LD_INT 1
14752: ST_TO_ADDR
// end ; end ; end ; end ;
14753: PPOPN 9
14755: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14756: LD_VAR 0 1
14760: PPUSH
14761: CALL_OW 255
14765: PUSH
14766: LD_OWVAR 2
14770: EQUAL
14771: IFFALSE 14808
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14773: LD_OWVAR 2
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: LD_INT 0
14783: PPUSH
14784: LD_VAR 0 1
14788: PPUSH
14789: CALL_OW 468
// player_artifact_ready := true ;
14793: LD_ADDR_EXP 7
14797: PUSH
14798: LD_INT 1
14800: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14801: LD_STRING ArtVulcano
14803: PPUSH
14804: CALL_OW 339
// end ; end ;
14808: PPOPN 1
14810: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14811: LD_OWVAR 2
14815: PPUSH
14816: LD_INT 1
14818: PPUSH
14819: LD_INT 2
14821: PPUSH
14822: LD_VAR 0 1
14826: PPUSH
14827: CALL_OW 468
// end ; end_of_file
14831: PPOPN 2
14833: END
// every 0 0$01 do
14834: GO 14836
14836: DISABLE
// begin enable ;
14837: ENABLE
// Display_Strings := [ #tick , tick ] ;
14838: LD_ADDR_OWVAR 47
14842: PUSH
14843: LD_STRING #tick
14845: PUSH
14846: LD_OWVAR 1
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: ST_TO_ADDR
// end ; end_of_file
14855: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14856: LD_INT 0
14858: PPUSH
14859: PPUSH
14860: PPUSH
14861: PPUSH
14862: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14863: LD_ADDR_EXP 39
14867: PUSH
14868: LD_INT 7
14870: PUSH
14871: LD_INT 6
14873: PUSH
14874: LD_INT 5
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: LIST
14881: PUSH
14882: LD_OWVAR 67
14886: ARRAY
14887: ST_TO_ADDR
// al_force := [ ] ;
14888: LD_ADDR_EXP 38
14892: PUSH
14893: EMPTY
14894: ST_TO_ADDR
// RemoveAlliance ;
14895: CALL 15273 0 0
// ResetFog ;
14899: CALL_OW 335
// your_side := 7 ;
14903: LD_ADDR_OWVAR 2
14907: PUSH
14908: LD_INT 7
14910: ST_TO_ADDR
// uc_side := 7 ;
14911: LD_ADDR_OWVAR 20
14915: PUSH
14916: LD_INT 7
14918: ST_TO_ADDR
// hc_gallery :=  ;
14919: LD_ADDR_OWVAR 33
14923: PUSH
14924: LD_STRING 
14926: ST_TO_ADDR
// hc_name :=  ;
14927: LD_ADDR_OWVAR 26
14931: PUSH
14932: LD_STRING 
14934: ST_TO_ADDR
// hc_importance := 0 ;
14935: LD_ADDR_OWVAR 32
14939: PUSH
14940: LD_INT 0
14942: ST_TO_ADDR
// for i = 1 to 17 do
14943: LD_ADDR_VAR 0 2
14947: PUSH
14948: DOUBLE
14949: LD_INT 1
14951: DEC
14952: ST_TO_ADDR
14953: LD_INT 17
14955: PUSH
14956: FOR_TO
14957: IFFALSE 15037
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14959: LD_ADDR_OWVAR 21
14963: PUSH
14964: LD_INT 1
14966: PUSH
14967: LD_INT 3
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PUSH
14974: LD_INT 1
14976: PPUSH
14977: LD_INT 2
14979: PPUSH
14980: CALL_OW 12
14984: ARRAY
14985: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14986: LD_INT 0
14988: PPUSH
14989: LD_INT 1
14991: PPUSH
14992: LD_INT 4
14994: PPUSH
14995: CALL_OW 12
14999: PPUSH
15000: LD_EXP 39
15004: PPUSH
15005: CALL_OW 380
// un := CreateHuman ;
15009: LD_ADDR_VAR 0 4
15013: PUSH
15014: CALL_OW 44
15018: ST_TO_ADDR
// al_force := al_force ^ un ;
15019: LD_ADDR_EXP 38
15023: PUSH
15024: LD_EXP 38
15028: PUSH
15029: LD_VAR 0 4
15033: ADD
15034: ST_TO_ADDR
// end ;
15035: GO 14956
15037: POP
15038: POP
// hc_importance := 100 ;
15039: LD_ADDR_OWVAR 32
15043: PUSH
15044: LD_INT 100
15046: ST_TO_ADDR
// uc_nation := 1 ;
15047: LD_ADDR_OWVAR 21
15051: PUSH
15052: LD_INT 1
15054: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15055: LD_INT 1
15057: PPUSH
15058: LD_INT 1
15060: PPUSH
15061: LD_EXP 39
15065: PPUSH
15066: CALL_OW 380
// al_commander := CreateHuman ;
15070: LD_ADDR_EXP 37
15074: PUSH
15075: CALL_OW 44
15079: ST_TO_ADDR
// player_commander := al_commander ;
15080: LD_ADDR_EXP 10
15084: PUSH
15085: LD_EXP 37
15089: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15090: LD_ADDR_VAR 0 5
15094: PUSH
15095: LD_STRING text
15097: PPUSH
15098: LD_INT 9
15100: PUSH
15101: LD_INT 9
15103: PUSH
15104: LD_INT 8
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: LIST
15111: PUSH
15112: LD_OWVAR 67
15116: ARRAY
15117: PPUSH
15118: LD_INT 9
15120: PUSH
15121: LD_INT 9
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: LIST
15131: PUSH
15132: LD_OWVAR 67
15136: ARRAY
15137: PPUSH
15138: LD_INT -5
15140: PUSH
15141: LD_EXP 37
15145: PUSH
15146: LD_INT -3
15148: PUSH
15149: LD_INT -2
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: PUSH
15158: LD_EXP 38
15162: ADD
15163: PPUSH
15164: LD_INT 1
15166: PUSH
15167: LD_INT 3
15169: PUSH
15170: LD_INT 2
15172: PUSH
15173: LD_INT 1
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: LD_INT 4
15182: PUSH
15183: LD_INT 1
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: LD_INT 9
15192: PUSH
15193: LD_INT 5
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL_OW 42
15208: ST_TO_ADDR
// team := team ^ al_commander ;
15209: LD_ADDR_VAR 0 5
15213: PUSH
15214: LD_VAR 0 5
15218: PUSH
15219: LD_EXP 37
15223: ADD
15224: ST_TO_ADDR
// for i = 1 to team do
15225: LD_ADDR_VAR 0 2
15229: PUSH
15230: DOUBLE
15231: LD_INT 1
15233: DEC
15234: ST_TO_ADDR
15235: LD_VAR 0 5
15239: PUSH
15240: FOR_TO
15241: IFFALSE 15266
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15243: LD_VAR 0 5
15247: PUSH
15248: LD_VAR 0 2
15252: ARRAY
15253: PPUSH
15254: LD_INT 15
15256: PPUSH
15257: LD_INT 0
15259: PPUSH
15260: CALL_OW 49
15264: GO 15240
15266: POP
15267: POP
// end ;
15268: LD_VAR 0 1
15272: RET
// export function RemoveAlliance ; var i ; begin
15273: LD_INT 0
15275: PPUSH
15276: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15277: LD_INT 22
15279: PUSH
15280: LD_INT 7
15282: PUSH
15283: EMPTY
15284: LIST
15285: LIST
15286: PUSH
15287: LD_INT 30
15289: PUSH
15290: LD_INT 1
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PPUSH
15301: CALL_OW 69
15305: PUSH
15306: LD_INT 1
15308: ARRAY
15309: PPUSH
15310: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15314: LD_ADDR_VAR 0 2
15318: PUSH
15319: LD_INT 22
15321: PUSH
15322: LD_INT 7
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: PPUSH
15329: CALL_OW 69
15333: PUSH
15334: FOR_IN
15335: IFFALSE 15348
// RemoveUnit ( i ) ;
15337: LD_VAR 0 2
15341: PPUSH
15342: CALL_OW 64
15346: GO 15334
15348: POP
15349: POP
// end ;
15350: LD_VAR 0 1
15354: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15355: LD_INT 0
15357: PPUSH
15358: PPUSH
15359: PPUSH
15360: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15361: LD_INT 31
15363: PPUSH
15364: LD_INT 7
15366: PPUSH
15367: LD_INT 2
15369: PPUSH
15370: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15374: LD_INT 32
15376: PPUSH
15377: LD_INT 7
15379: PPUSH
15380: LD_INT 2
15382: PPUSH
15383: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15387: LD_INT 59
15389: PPUSH
15390: LD_INT 7
15392: PPUSH
15393: LD_INT 2
15395: PPUSH
15396: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15400: LD_ADDR_EXP 39
15404: PUSH
15405: LD_INT 5
15407: PUSH
15408: LD_INT 6
15410: PUSH
15411: LD_INT 7
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_OWVAR 67
15423: ARRAY
15424: ST_TO_ADDR
// al_force := [ ] ;
15425: LD_ADDR_EXP 38
15429: PUSH
15430: EMPTY
15431: ST_TO_ADDR
// al_vehs := [ ] ;
15432: LD_ADDR_EXP 44
15436: PUSH
15437: EMPTY
15438: ST_TO_ADDR
// uc_side := 7 ;
15439: LD_ADDR_OWVAR 20
15443: PUSH
15444: LD_INT 7
15446: ST_TO_ADDR
// uc_nation := 1 ;
15447: LD_ADDR_OWVAR 21
15451: PUSH
15452: LD_INT 1
15454: ST_TO_ADDR
// bc_type := b_oil_mine ;
15455: LD_ADDR_OWVAR 42
15459: PUSH
15460: LD_INT 29
15462: ST_TO_ADDR
// b := CreateBuilding ;
15463: LD_ADDR_VAR 0 4
15467: PUSH
15468: CALL_OW 46
15472: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15473: LD_VAR 0 4
15477: PPUSH
15478: LD_INT 61
15480: PPUSH
15481: LD_INT 7
15483: PPUSH
15484: LD_INT 0
15486: PPUSH
15487: LD_INT 0
15489: PPUSH
15490: CALL_OW 50
// bc_type := b_siberite_mine ;
15494: LD_ADDR_OWVAR 42
15498: PUSH
15499: LD_INT 30
15501: ST_TO_ADDR
// b := CreateBuilding ;
15502: LD_ADDR_VAR 0 4
15506: PUSH
15507: CALL_OW 46
15511: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15512: LD_VAR 0 4
15516: PPUSH
15517: LD_INT 69
15519: PPUSH
15520: LD_INT 13
15522: PPUSH
15523: LD_INT 0
15525: PPUSH
15526: LD_INT 0
15528: PPUSH
15529: CALL_OW 50
// hc_gallery :=  ;
15533: LD_ADDR_OWVAR 33
15537: PUSH
15538: LD_STRING 
15540: ST_TO_ADDR
// hc_name :=  ;
15541: LD_ADDR_OWVAR 26
15545: PUSH
15546: LD_STRING 
15548: ST_TO_ADDR
// hc_importance := 0 ;
15549: LD_ADDR_OWVAR 32
15553: PUSH
15554: LD_INT 0
15556: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15557: LD_ADDR_VAR 0 2
15561: PUSH
15562: LD_INT 22
15564: PUSH
15565: LD_INT 7
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 30
15574: PUSH
15575: LD_INT 32
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: PUSH
15582: EMPTY
15583: LIST
15584: LIST
15585: PPUSH
15586: CALL_OW 69
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15662
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15594: LD_ADDR_OWVAR 21
15598: PUSH
15599: LD_INT 1
15601: PUSH
15602: LD_INT 3
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PUSH
15609: LD_INT 1
15611: PPUSH
15612: LD_INT 2
15614: PPUSH
15615: CALL_OW 12
15619: ARRAY
15620: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15621: LD_INT 0
15623: PPUSH
15624: LD_INT 1
15626: PPUSH
15627: LD_EXP 39
15631: PPUSH
15632: CALL_OW 380
// un := CreateHuman ;
15636: LD_ADDR_VAR 0 3
15640: PUSH
15641: CALL_OW 44
15645: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15646: LD_VAR 0 3
15650: PPUSH
15651: LD_VAR 0 2
15655: PPUSH
15656: CALL_OW 52
// end ;
15660: GO 15591
15662: POP
15663: POP
// for i = 1 to 3 do
15664: LD_ADDR_VAR 0 2
15668: PUSH
15669: DOUBLE
15670: LD_INT 1
15672: DEC
15673: ST_TO_ADDR
15674: LD_INT 3
15676: PUSH
15677: FOR_TO
15678: IFFALSE 15746
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15680: LD_ADDR_OWVAR 21
15684: PUSH
15685: LD_INT 1
15687: PUSH
15688: LD_INT 3
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: PUSH
15695: LD_INT 1
15697: PPUSH
15698: LD_INT 2
15700: PPUSH
15701: CALL_OW 12
15705: ARRAY
15706: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15707: LD_INT 0
15709: PPUSH
15710: LD_INT 4
15712: PPUSH
15713: LD_EXP 39
15717: PPUSH
15718: CALL_OW 380
// un := CreateHuman ;
15722: LD_ADDR_VAR 0 3
15726: PUSH
15727: CALL_OW 44
15731: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15732: LD_VAR 0 3
15736: PPUSH
15737: LD_INT 164
15739: PPUSH
15740: CALL_OW 52
// end ;
15744: GO 15677
15746: POP
15747: POP
// for i = 1 to 6 do
15748: LD_ADDR_VAR 0 2
15752: PUSH
15753: DOUBLE
15754: LD_INT 1
15756: DEC
15757: ST_TO_ADDR
15758: LD_INT 6
15760: PUSH
15761: FOR_TO
15762: IFFALSE 15853
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15764: LD_ADDR_OWVAR 21
15768: PUSH
15769: LD_INT 1
15771: PUSH
15772: LD_INT 3
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: PUSH
15779: LD_INT 1
15781: PPUSH
15782: LD_INT 2
15784: PPUSH
15785: CALL_OW 12
15789: ARRAY
15790: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15791: LD_INT 0
15793: PPUSH
15794: LD_INT 5
15796: PUSH
15797: LD_INT 9
15799: PUSH
15800: LD_INT 9
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: LIST
15807: PUSH
15808: LD_INT 1
15810: PPUSH
15811: LD_INT 3
15813: PPUSH
15814: CALL_OW 12
15818: ARRAY
15819: PPUSH
15820: LD_EXP 39
15824: PPUSH
15825: CALL_OW 380
// un := CreateHuman ;
15829: LD_ADDR_VAR 0 3
15833: PUSH
15834: CALL_OW 44
15838: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15839: LD_VAR 0 3
15843: PPUSH
15844: LD_INT 173
15846: PPUSH
15847: CALL_OW 52
// end ;
15851: GO 15761
15853: POP
15854: POP
// for i = 1 to 6 do
15855: LD_ADDR_VAR 0 2
15859: PUSH
15860: DOUBLE
15861: LD_INT 1
15863: DEC
15864: ST_TO_ADDR
15865: LD_INT 6
15867: PUSH
15868: FOR_TO
15869: IFFALSE 15967
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15871: LD_ADDR_OWVAR 21
15875: PUSH
15876: LD_INT 1
15878: PUSH
15879: LD_INT 3
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: PUSH
15886: LD_INT 1
15888: PPUSH
15889: LD_INT 2
15891: PPUSH
15892: CALL_OW 12
15896: ARRAY
15897: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15898: LD_INT 0
15900: PPUSH
15901: LD_INT 3
15903: PPUSH
15904: LD_EXP 39
15908: PPUSH
15909: CALL_OW 380
// un := CreateHuman ;
15913: LD_ADDR_VAR 0 3
15917: PUSH
15918: CALL_OW 44
15922: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15923: LD_VAR 0 3
15927: PPUSH
15928: LD_INT 22
15930: PUSH
15931: LD_INT 7
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PUSH
15938: LD_INT 30
15940: PUSH
15941: LD_INT 3
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: EMPTY
15949: LIST
15950: LIST
15951: PPUSH
15952: CALL_OW 69
15956: PUSH
15957: LD_INT 1
15959: ARRAY
15960: PPUSH
15961: CALL_OW 52
// end ;
15965: GO 15868
15967: POP
15968: POP
// for i = 1 to 4 do
15969: LD_ADDR_VAR 0 2
15973: PUSH
15974: DOUBLE
15975: LD_INT 1
15977: DEC
15978: ST_TO_ADDR
15979: LD_INT 4
15981: PUSH
15982: FOR_TO
15983: IFFALSE 16051
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15985: LD_ADDR_OWVAR 21
15989: PUSH
15990: LD_INT 1
15992: PUSH
15993: LD_INT 3
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PUSH
16000: LD_INT 1
16002: PPUSH
16003: LD_INT 2
16005: PPUSH
16006: CALL_OW 12
16010: ARRAY
16011: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16012: LD_INT 0
16014: PPUSH
16015: LD_INT 2
16017: PPUSH
16018: LD_EXP 39
16022: PPUSH
16023: CALL_OW 380
// un := CreateHuman ;
16027: LD_ADDR_VAR 0 3
16031: PUSH
16032: CALL_OW 44
16036: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16037: LD_VAR 0 3
16041: PPUSH
16042: LD_INT 162
16044: PPUSH
16045: CALL_OW 52
// end ;
16049: GO 15982
16051: POP
16052: POP
// uc_nation := 3 ;
16053: LD_ADDR_OWVAR 21
16057: PUSH
16058: LD_INT 3
16060: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16061: LD_ADDR_OWVAR 37
16065: PUSH
16066: LD_INT 21
16068: ST_TO_ADDR
// vc_engine := engine_siberite ;
16069: LD_ADDR_OWVAR 39
16073: PUSH
16074: LD_INT 3
16076: ST_TO_ADDR
// vc_control := control_computer ;
16077: LD_ADDR_OWVAR 38
16081: PUSH
16082: LD_INT 3
16084: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16085: LD_ADDR_OWVAR 40
16089: PUSH
16090: LD_INT 51
16092: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16093: CALL_OW 45
16097: PPUSH
16098: LD_INT 49
16100: PPUSH
16101: LD_INT 13
16103: PPUSH
16104: LD_INT 0
16106: PPUSH
16107: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16111: LD_ADDR_EXP 46
16115: PUSH
16116: LD_INT 22
16118: PUSH
16119: LD_INT 7
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PUSH
16126: LD_INT 30
16128: PUSH
16129: LD_INT 33
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PPUSH
16140: CALL_OW 69
16144: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16145: LD_ADDR_VAR 0 2
16149: PUSH
16150: DOUBLE
16151: LD_INT 1
16153: DEC
16154: ST_TO_ADDR
16155: LD_INT 22
16157: PUSH
16158: LD_INT 7
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: LD_INT 30
16167: PUSH
16168: LD_INT 33
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: PUSH
16175: LD_INT 35
16177: PUSH
16178: LD_INT 0
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: LIST
16189: PUSH
16190: EMPTY
16191: LIST
16192: PPUSH
16193: CALL_OW 69
16197: PUSH
16198: FOR_TO
16199: IFFALSE 16259
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16201: LD_INT 22
16203: PUSH
16204: LD_INT 7
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: PUSH
16211: LD_INT 30
16213: PUSH
16214: LD_INT 33
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: PUSH
16221: LD_INT 35
16223: PUSH
16224: LD_INT 0
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: LIST
16235: PUSH
16236: EMPTY
16237: LIST
16238: PPUSH
16239: CALL_OW 69
16243: PUSH
16244: LD_VAR 0 2
16248: ARRAY
16249: PPUSH
16250: LD_INT 49
16252: PPUSH
16253: CALL_OW 208
16257: GO 16198
16259: POP
16260: POP
// end ;
16261: LD_VAR 0 1
16265: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16266: LD_OWVAR 2
16270: PUSH
16271: LD_INT 1
16273: EQUAL
16274: IFFALSE 17442
16276: GO 16278
16278: DISABLE
16279: LD_INT 0
16281: PPUSH
16282: PPUSH
16283: PPUSH
16284: PPUSH
// begin enable ;
16285: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16286: LD_ADDR_EXP 50
16290: PUSH
16291: LD_INT 22
16293: PUSH
16294: LD_INT 7
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PUSH
16301: LD_INT 21
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: PPUSH
16315: CALL_OW 69
16319: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16320: LD_ADDR_EXP 48
16324: PUSH
16325: LD_INT 164
16327: PUSH
16328: LD_INT 197
16330: PUSH
16331: EMPTY
16332: LIST
16333: LIST
16334: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16335: LD_ADDR_EXP 47
16339: PUSH
16340: LD_INT 22
16342: PUSH
16343: LD_INT 7
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: PUSH
16350: LD_INT 30
16352: PUSH
16353: LD_INT 1
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PPUSH
16364: CALL_OW 69
16368: PUSH
16369: LD_INT 1
16371: ARRAY
16372: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16373: LD_ADDR_EXP 49
16377: PUSH
16378: LD_INT 22
16380: PUSH
16381: LD_INT 7
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PUSH
16388: LD_INT 30
16390: PUSH
16391: LD_INT 3
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PPUSH
16402: CALL_OW 69
16406: PUSH
16407: LD_INT 1
16409: ARRAY
16410: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16411: LD_INT 22
16413: PUSH
16414: LD_INT 7
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: LD_INT 34
16423: PUSH
16424: LD_INT 51
16426: PUSH
16427: EMPTY
16428: LIST
16429: LIST
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PPUSH
16435: CALL_OW 69
16439: IFFALSE 16479
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16441: LD_ADDR_EXP 45
16445: PUSH
16446: LD_INT 22
16448: PUSH
16449: LD_INT 7
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: PUSH
16456: LD_INT 34
16458: PUSH
16459: LD_INT 51
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PPUSH
16470: CALL_OW 69
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16479: LD_ADDR_EXP 41
16483: PUSH
16484: LD_INT 22
16486: PUSH
16487: LD_INT 7
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: LD_INT 25
16496: PUSH
16497: LD_INT 9
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PPUSH
16508: CALL_OW 69
16512: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16513: LD_ADDR_EXP 40
16517: PUSH
16518: LD_INT 22
16520: PUSH
16521: LD_INT 7
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: LD_INT 25
16530: PUSH
16531: LD_INT 2
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: PUSH
16538: EMPTY
16539: LIST
16540: LIST
16541: PPUSH
16542: CALL_OW 69
16546: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16547: LD_ADDR_EXP 42
16551: PUSH
16552: LD_INT 22
16554: PUSH
16555: LD_INT 7
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: LD_INT 25
16564: PUSH
16565: LD_INT 3
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PPUSH
16576: CALL_OW 69
16580: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16581: LD_ADDR_EXP 43
16585: PUSH
16586: LD_INT 22
16588: PUSH
16589: LD_INT 7
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: PUSH
16596: LD_INT 25
16598: PUSH
16599: LD_INT 4
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PPUSH
16610: CALL_OW 69
16614: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16615: LD_EXP 41
16619: PPUSH
16620: LD_INT 81
16622: PUSH
16623: LD_INT 7
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PPUSH
16630: CALL_OW 69
16634: PPUSH
16635: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16639: LD_EXP 45
16643: PPUSH
16644: CALL_OW 314
16648: NOT
16649: PUSH
16650: LD_EXP 45
16654: PPUSH
16655: LD_INT 1
16657: PPUSH
16658: CALL_OW 289
16662: PUSH
16663: LD_INT 100
16665: LESS
16666: AND
16667: IFFALSE 16715
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16669: LD_ADDR_VAR 0 4
16673: PUSH
16674: LD_INT 12
16676: PPUSH
16677: CALL_OW 435
16681: ST_TO_ADDR
// if cr then
16682: LD_VAR 0 4
16686: IFFALSE 16715
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16688: LD_EXP 45
16692: PPUSH
16693: LD_VAR 0 4
16697: PUSH
16698: LD_INT 1
16700: ARRAY
16701: PPUSH
16702: LD_VAR 0 4
16706: PUSH
16707: LD_INT 2
16709: ARRAY
16710: PPUSH
16711: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16715: LD_EXP 50
16719: PPUSH
16720: LD_INT 3
16722: PUSH
16723: LD_INT 24
16725: PUSH
16726: LD_INT 1000
16728: PUSH
16729: EMPTY
16730: LIST
16731: LIST
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PPUSH
16737: CALL_OW 72
16741: IFFALSE 16871
// begin if al_eng then
16743: LD_EXP 40
16747: IFFALSE 16869
// for i = 1 to al_eng do
16749: LD_ADDR_VAR 0 1
16753: PUSH
16754: DOUBLE
16755: LD_INT 1
16757: DEC
16758: ST_TO_ADDR
16759: LD_EXP 40
16763: PUSH
16764: FOR_TO
16765: IFFALSE 16867
// if IsInUnit ( al_eng [ i ] ) then
16767: LD_EXP 40
16771: PUSH
16772: LD_VAR 0 1
16776: ARRAY
16777: PPUSH
16778: CALL_OW 310
16782: IFFALSE 16801
// ComExitBuilding ( al_eng [ i ] ) else
16784: LD_EXP 40
16788: PUSH
16789: LD_VAR 0 1
16793: ARRAY
16794: PPUSH
16795: CALL_OW 122
16799: GO 16865
// if not HasTask ( al_eng [ i ] ) then
16801: LD_EXP 40
16805: PUSH
16806: LD_VAR 0 1
16810: ARRAY
16811: PPUSH
16812: CALL_OW 314
16816: NOT
16817: IFFALSE 16865
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16819: LD_EXP 40
16823: PUSH
16824: LD_VAR 0 1
16828: ARRAY
16829: PPUSH
16830: LD_EXP 50
16834: PPUSH
16835: LD_INT 3
16837: PUSH
16838: LD_INT 24
16840: PUSH
16841: LD_INT 1000
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: PPUSH
16852: CALL_OW 72
16856: PUSH
16857: LD_INT 1
16859: ARRAY
16860: PPUSH
16861: CALL_OW 130
16865: GO 16764
16867: POP
16868: POP
// end else
16869: GO 16953
// if al_eng then
16871: LD_EXP 40
16875: IFFALSE 16953
// if not IsInUnit ( al_eng [ 1 ] ) then
16877: LD_EXP 40
16881: PUSH
16882: LD_INT 1
16884: ARRAY
16885: PPUSH
16886: CALL_OW 310
16890: NOT
16891: IFFALSE 16953
// for i = 1 to al_eng do
16893: LD_ADDR_VAR 0 1
16897: PUSH
16898: DOUBLE
16899: LD_INT 1
16901: DEC
16902: ST_TO_ADDR
16903: LD_EXP 40
16907: PUSH
16908: FOR_TO
16909: IFFALSE 16951
// if not IsInUnit ( al_eng [ i ] ) then
16911: LD_EXP 40
16915: PUSH
16916: LD_VAR 0 1
16920: ARRAY
16921: PPUSH
16922: CALL_OW 310
16926: NOT
16927: IFFALSE 16949
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16929: LD_EXP 40
16933: PUSH
16934: LD_VAR 0 1
16938: ARRAY
16939: PPUSH
16940: LD_EXP 47
16944: PPUSH
16945: CALL_OW 120
16949: GO 16908
16951: POP
16952: POP
// if al_vehs then
16953: LD_EXP 44
16957: IFFALSE 17057
// if BuildingStatus ( al_fac ) = bs_idle then
16959: LD_EXP 49
16963: PPUSH
16964: CALL_OW 461
16968: PUSH
16969: LD_INT 2
16971: EQUAL
16972: IFFALSE 17057
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16974: LD_EXP 49
16978: PPUSH
16979: LD_EXP 44
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: PPUSH
16988: LD_EXP 44
16992: PUSH
16993: LD_INT 2
16995: ARRAY
16996: PPUSH
16997: LD_EXP 44
17001: PUSH
17002: LD_INT 3
17004: ARRAY
17005: PPUSH
17006: LD_EXP 44
17010: PUSH
17011: LD_INT 4
17013: ARRAY
17014: PPUSH
17015: CALL_OW 125
// for i = 1 to 4 do
17019: LD_ADDR_VAR 0 1
17023: PUSH
17024: DOUBLE
17025: LD_INT 1
17027: DEC
17028: ST_TO_ADDR
17029: LD_INT 4
17031: PUSH
17032: FOR_TO
17033: IFFALSE 17055
// al_vehs := Delete ( al_vehs , 1 ) ;
17035: LD_ADDR_EXP 44
17039: PUSH
17040: LD_EXP 44
17044: PPUSH
17045: LD_INT 1
17047: PPUSH
17048: CALL_OW 3
17052: ST_TO_ADDR
17053: GO 17032
17055: POP
17056: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17057: LD_EXP 38
17061: PUSH
17062: LD_INT 0
17064: EQUAL
17065: PUSH
17066: LD_OWVAR 1
17070: PUSH
17071: LD_INT 23100
17073: MOD
17074: PUSH
17075: LD_INT 0
17077: EQUAL
17078: AND
17079: IFFALSE 17193
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17081: LD_ADDR_VAR 0 1
17085: PUSH
17086: DOUBLE
17087: LD_INT 1
17089: DEC
17090: ST_TO_ADDR
17091: LD_INT 4
17093: PUSH
17094: LD_INT 5
17096: PUSH
17097: LD_INT 6
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: LIST
17104: PUSH
17105: LD_OWVAR 67
17109: ARRAY
17110: PUSH
17111: FOR_TO
17112: IFFALSE 17191
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17114: LD_ADDR_EXP 44
17118: PUSH
17119: LD_EXP 44
17123: PUSH
17124: LD_INT 23
17126: ADD
17127: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17128: LD_ADDR_EXP 44
17132: PUSH
17133: LD_EXP 44
17137: PUSH
17138: LD_INT 1
17140: ADD
17141: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17142: LD_ADDR_EXP 44
17146: PUSH
17147: LD_EXP 44
17151: PUSH
17152: LD_INT 3
17154: ADD
17155: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17156: LD_ADDR_EXP 44
17160: PUSH
17161: LD_EXP 44
17165: PUSH
17166: LD_INT 46
17168: PUSH
17169: LD_INT 47
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 1
17178: PPUSH
17179: LD_INT 2
17181: PPUSH
17182: CALL_OW 12
17186: ARRAY
17187: ADD
17188: ST_TO_ADDR
// end ;
17189: GO 17111
17191: POP
17192: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17193: LD_INT 22
17195: PUSH
17196: LD_INT 7
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 34
17205: PUSH
17206: LD_INT 51
17208: PUSH
17209: EMPTY
17210: LIST
17211: LIST
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: PPUSH
17217: CALL_OW 69
17221: PUSH
17222: LD_INT 0
17224: EQUAL
17225: IFFALSE 17248
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17227: LD_EXP 49
17231: PPUSH
17232: LD_INT 21
17234: PPUSH
17235: LD_INT 1
17237: PPUSH
17238: LD_INT 3
17240: PPUSH
17241: LD_INT 51
17243: PPUSH
17244: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17248: LD_EXP 38
17252: PUSH
17253: LD_OWVAR 1
17257: PUSH
17258: LD_INT 25200
17260: MOD
17261: PUSH
17262: LD_INT 0
17264: EQUAL
17265: AND
17266: IFFALSE 17329
// begin for i = 1 to al_force do
17268: LD_ADDR_VAR 0 1
17272: PUSH
17273: DOUBLE
17274: LD_INT 1
17276: DEC
17277: ST_TO_ADDR
17278: LD_EXP 38
17282: PUSH
17283: FOR_TO
17284: IFFALSE 17327
// if GetTag ( al_force [ i ] ) <> 11 then
17286: LD_EXP 38
17290: PUSH
17291: LD_VAR 0 1
17295: ARRAY
17296: PPUSH
17297: CALL_OW 110
17301: PUSH
17302: LD_INT 11
17304: NONEQUAL
17305: IFFALSE 17325
// SetTag ( al_force [ i ] , 11 ) ;
17307: LD_EXP 38
17311: PUSH
17312: LD_VAR 0 1
17316: ARRAY
17317: PPUSH
17318: LD_INT 11
17320: PPUSH
17321: CALL_OW 109
17325: GO 17283
17327: POP
17328: POP
// end ; if al_force then
17329: LD_EXP 38
17333: IFFALSE 17442
// for i = 1 to al_force do
17335: LD_ADDR_VAR 0 1
17339: PUSH
17340: DOUBLE
17341: LD_INT 1
17343: DEC
17344: ST_TO_ADDR
17345: LD_EXP 38
17349: PUSH
17350: FOR_TO
17351: IFFALSE 17440
// begin if GetTag ( al_force [ i ] ) = 11 then
17353: LD_EXP 38
17357: PUSH
17358: LD_VAR 0 1
17362: ARRAY
17363: PPUSH
17364: CALL_OW 110
17368: PUSH
17369: LD_INT 11
17371: EQUAL
17372: IFFALSE 17438
// begin if not HasTask ( al_force [ i ] ) then
17374: LD_EXP 38
17378: PUSH
17379: LD_VAR 0 1
17383: ARRAY
17384: PPUSH
17385: CALL_OW 314
17389: NOT
17390: IFFALSE 17438
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17392: LD_EXP 38
17396: PUSH
17397: LD_VAR 0 1
17401: ARRAY
17402: PPUSH
17403: LD_INT 81
17405: PUSH
17406: LD_INT 7
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: PPUSH
17413: CALL_OW 69
17417: PPUSH
17418: LD_EXP 38
17422: PUSH
17423: LD_VAR 0 1
17427: ARRAY
17428: PPUSH
17429: CALL_OW 74
17433: PPUSH
17434: CALL_OW 115
// end ; end ;
17438: GO 17350
17440: POP
17441: POP
// end ; end_of_file
17442: PPOPN 4
17444: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17445: LD_INT 0
17447: PPUSH
17448: PPUSH
17449: PPUSH
17450: PPUSH
17451: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17452: LD_ADDR_EXP 53
17456: PUSH
17457: LD_INT 7
17459: PUSH
17460: LD_INT 6
17462: PUSH
17463: LD_INT 5
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: LIST
17470: PUSH
17471: LD_OWVAR 67
17475: ARRAY
17476: ST_TO_ADDR
// ar_force := [ ] ;
17477: LD_ADDR_EXP 52
17481: PUSH
17482: EMPTY
17483: ST_TO_ADDR
// RemoveAlliance ;
17484: CALL 15273 0 0
// RemoveEnvironmentArea ( evn ) ;
17488: LD_INT 17
17490: PPUSH
17491: CALL_OW 355
// your_side := 2 ;
17495: LD_ADDR_OWVAR 2
17499: PUSH
17500: LD_INT 2
17502: ST_TO_ADDR
// uc_side := 2 ;
17503: LD_ADDR_OWVAR 20
17507: PUSH
17508: LD_INT 2
17510: ST_TO_ADDR
// uc_nation := nation_arabian ;
17511: LD_ADDR_OWVAR 21
17515: PUSH
17516: LD_INT 2
17518: ST_TO_ADDR
// hc_gallery :=  ;
17519: LD_ADDR_OWVAR 33
17523: PUSH
17524: LD_STRING 
17526: ST_TO_ADDR
// hc_name :=  ;
17527: LD_ADDR_OWVAR 26
17531: PUSH
17532: LD_STRING 
17534: ST_TO_ADDR
// hc_importance := 0 ;
17535: LD_ADDR_OWVAR 32
17539: PUSH
17540: LD_INT 0
17542: ST_TO_ADDR
// for i = 1 to 15 do
17543: LD_ADDR_VAR 0 2
17547: PUSH
17548: DOUBLE
17549: LD_INT 1
17551: DEC
17552: ST_TO_ADDR
17553: LD_INT 15
17555: PUSH
17556: FOR_TO
17557: IFFALSE 17610
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17559: LD_INT 0
17561: PPUSH
17562: LD_INT 1
17564: PPUSH
17565: LD_INT 4
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: LD_EXP 53
17577: PPUSH
17578: CALL_OW 380
// un := CreateHuman ;
17582: LD_ADDR_VAR 0 4
17586: PUSH
17587: CALL_OW 44
17591: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17592: LD_ADDR_EXP 52
17596: PUSH
17597: LD_EXP 52
17601: PUSH
17602: LD_VAR 0 4
17606: ADD
17607: ST_TO_ADDR
// end ;
17608: GO 17556
17610: POP
17611: POP
// hc_importance := 100 ;
17612: LD_ADDR_OWVAR 32
17616: PUSH
17617: LD_INT 100
17619: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17620: LD_INT 1
17622: PPUSH
17623: LD_INT 11
17625: PPUSH
17626: LD_EXP 53
17630: PPUSH
17631: CALL_OW 380
// ar_commander := CreateHuman ;
17635: LD_ADDR_EXP 51
17639: PUSH
17640: CALL_OW 44
17644: ST_TO_ADDR
// player_commander := ar_commander ;
17645: LD_ADDR_EXP 10
17649: PUSH
17650: LD_EXP 51
17654: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17655: LD_ADDR_VAR 0 5
17659: PUSH
17660: LD_STRING text
17662: PPUSH
17663: LD_INT 11
17665: PUSH
17666: LD_INT 10
17668: PUSH
17669: LD_INT 9
17671: PUSH
17672: EMPTY
17673: LIST
17674: LIST
17675: LIST
17676: PUSH
17677: LD_OWVAR 67
17681: ARRAY
17682: PPUSH
17683: LD_INT 11
17685: PUSH
17686: LD_INT 10
17688: PUSH
17689: LD_INT 9
17691: PUSH
17692: EMPTY
17693: LIST
17694: LIST
17695: LIST
17696: PUSH
17697: LD_OWVAR 67
17701: ARRAY
17702: PPUSH
17703: LD_INT -5
17705: PUSH
17706: LD_EXP 51
17710: PUSH
17711: LD_INT -3
17713: PUSH
17714: LD_INT -2
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: PUSH
17723: LD_EXP 52
17727: ADD
17728: PPUSH
17729: LD_INT 1
17731: PUSH
17732: LD_INT 3
17734: PUSH
17735: LD_INT 2
17737: PUSH
17738: LD_INT 1
17740: PUSH
17741: EMPTY
17742: LIST
17743: LIST
17744: PUSH
17745: LD_INT 4
17747: PUSH
17748: LD_INT 1
17750: PUSH
17751: EMPTY
17752: LIST
17753: LIST
17754: PUSH
17755: LD_INT 8
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: PPUSH
17765: CALL_OW 42
17769: ST_TO_ADDR
// team := team ^ ar_commander ;
17770: LD_ADDR_VAR 0 5
17774: PUSH
17775: LD_VAR 0 5
17779: PUSH
17780: LD_EXP 51
17784: ADD
17785: ST_TO_ADDR
// for i = 1 to team do
17786: LD_ADDR_VAR 0 2
17790: PUSH
17791: DOUBLE
17792: LD_INT 1
17794: DEC
17795: ST_TO_ADDR
17796: LD_VAR 0 5
17800: PUSH
17801: FOR_TO
17802: IFFALSE 17827
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17804: LD_VAR 0 5
17808: PUSH
17809: LD_VAR 0 2
17813: ARRAY
17814: PPUSH
17815: LD_INT 16
17817: PPUSH
17818: LD_INT 0
17820: PPUSH
17821: CALL_OW 49
17825: GO 17801
17827: POP
17828: POP
// uc_side := 0 ;
17829: LD_ADDR_OWVAR 20
17833: PUSH
17834: LD_INT 0
17836: ST_TO_ADDR
// uc_nation := 0 ;
17837: LD_ADDR_OWVAR 21
17841: PUSH
17842: LD_INT 0
17844: ST_TO_ADDR
// vc_chassis := 31 ;
17845: LD_ADDR_OWVAR 37
17849: PUSH
17850: LD_INT 31
17852: ST_TO_ADDR
// vc_control := control_rider ;
17853: LD_ADDR_OWVAR 38
17857: PUSH
17858: LD_INT 4
17860: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17861: CALL_OW 45
17865: PPUSH
17866: LD_INT 96
17868: PPUSH
17869: LD_INT 20
17871: PPUSH
17872: LD_INT 0
17874: PPUSH
17875: CALL_OW 48
// end ; end_of_file
17879: LD_VAR 0 1
17883: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17884: GO 17886
17886: DISABLE
// begin ru_radar := 98 ;
17887: LD_ADDR_EXP 54
17891: PUSH
17892: LD_INT 98
17894: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17895: LD_ADDR_EXP 55
17899: PUSH
17900: LD_INT 89
17902: ST_TO_ADDR
// us_hack := 99 ;
17903: LD_ADDR_EXP 56
17907: PUSH
17908: LD_INT 99
17910: ST_TO_ADDR
// us_artillery := 97 ;
17911: LD_ADDR_EXP 57
17915: PUSH
17916: LD_INT 97
17918: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17919: LD_ADDR_EXP 58
17923: PUSH
17924: LD_INT 91
17926: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
17927: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17928: LD_INT 0
17930: PPUSH
17931: PPUSH
17932: PPUSH
17933: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17934: LD_VAR 0 1
17938: PPUSH
17939: CALL_OW 264
17943: PUSH
17944: LD_EXP 58
17948: EQUAL
17949: IFFALSE 18021
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17951: LD_INT 68
17953: PPUSH
17954: LD_VAR 0 1
17958: PPUSH
17959: CALL_OW 255
17963: PPUSH
17964: CALL_OW 321
17968: PUSH
17969: LD_INT 2
17971: EQUAL
17972: IFFALSE 17984
// eff := 70 else
17974: LD_ADDR_VAR 0 6
17978: PUSH
17979: LD_INT 70
17981: ST_TO_ADDR
17982: GO 17992
// eff := 30 ;
17984: LD_ADDR_VAR 0 6
17988: PUSH
17989: LD_INT 30
17991: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17992: LD_VAR 0 1
17996: PPUSH
17997: CALL_OW 250
18001: PPUSH
18002: LD_VAR 0 1
18006: PPUSH
18007: CALL_OW 251
18011: PPUSH
18012: LD_VAR 0 6
18016: PPUSH
18017: CALL_OW 495
// end ; end ;
18021: LD_VAR 0 4
18025: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18026: LD_INT 0
18028: PPUSH
18029: PPUSH
18030: PPUSH
18031: PPUSH
18032: PPUSH
18033: PPUSH
// if cmd = 124 then
18034: LD_VAR 0 1
18038: PUSH
18039: LD_INT 124
18041: EQUAL
18042: IFFALSE 18248
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18044: LD_ADDR_VAR 0 5
18048: PUSH
18049: LD_INT 2
18051: PUSH
18052: LD_INT 34
18054: PUSH
18055: LD_INT 53
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: PUSH
18062: LD_INT 34
18064: PUSH
18065: LD_INT 14
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: LIST
18076: PPUSH
18077: CALL_OW 69
18081: ST_TO_ADDR
// if not tmp then
18082: LD_VAR 0 5
18086: NOT
18087: IFFALSE 18091
// exit ;
18089: GO 18248
// for i in tmp do
18091: LD_ADDR_VAR 0 3
18095: PUSH
18096: LD_VAR 0 5
18100: PUSH
18101: FOR_IN
18102: IFFALSE 18246
// begin taskList := GetTaskList ( i ) ;
18104: LD_ADDR_VAR 0 6
18108: PUSH
18109: LD_VAR 0 3
18113: PPUSH
18114: CALL_OW 437
18118: ST_TO_ADDR
// if not taskList then
18119: LD_VAR 0 6
18123: NOT
18124: IFFALSE 18128
// continue ;
18126: GO 18101
// for j = 1 to taskList do
18128: LD_ADDR_VAR 0 4
18132: PUSH
18133: DOUBLE
18134: LD_INT 1
18136: DEC
18137: ST_TO_ADDR
18138: LD_VAR 0 6
18142: PUSH
18143: FOR_TO
18144: IFFALSE 18242
// if taskList [ j ] [ 1 ] = | then
18146: LD_VAR 0 6
18150: PUSH
18151: LD_VAR 0 4
18155: ARRAY
18156: PUSH
18157: LD_INT 1
18159: ARRAY
18160: PUSH
18161: LD_STRING |
18163: EQUAL
18164: IFFALSE 18240
// begin _taskList := Delete ( taskList , 1 ) ;
18166: LD_ADDR_VAR 0 7
18170: PUSH
18171: LD_VAR 0 6
18175: PPUSH
18176: LD_INT 1
18178: PPUSH
18179: CALL_OW 3
18183: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18184: LD_VAR 0 3
18188: PPUSH
18189: LD_VAR 0 7
18193: PPUSH
18194: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18198: LD_VAR 0 3
18202: PPUSH
18203: LD_VAR 0 6
18207: PUSH
18208: LD_VAR 0 4
18212: ARRAY
18213: PUSH
18214: LD_INT 2
18216: ARRAY
18217: PPUSH
18218: LD_VAR 0 6
18222: PUSH
18223: LD_VAR 0 4
18227: ARRAY
18228: PUSH
18229: LD_INT 3
18231: ARRAY
18232: PPUSH
18233: LD_INT 8
18235: PPUSH
18236: CALL 18253 0 4
// end ;
18240: GO 18143
18242: POP
18243: POP
// end ;
18244: GO 18101
18246: POP
18247: POP
// end ; end ;
18248: LD_VAR 0 2
18252: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18253: LD_INT 0
18255: PPUSH
18256: PPUSH
18257: PPUSH
18258: PPUSH
18259: PPUSH
18260: PPUSH
18261: PPUSH
18262: PPUSH
18263: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18264: LD_VAR 0 1
18268: NOT
18269: PUSH
18270: LD_VAR 0 2
18274: PPUSH
18275: LD_VAR 0 3
18279: PPUSH
18280: CALL_OW 488
18284: NOT
18285: OR
18286: PUSH
18287: LD_VAR 0 4
18291: NOT
18292: OR
18293: IFFALSE 18297
// exit ;
18295: GO 18637
// list := [ ] ;
18297: LD_ADDR_VAR 0 13
18301: PUSH
18302: EMPTY
18303: ST_TO_ADDR
// if x - r < 0 then
18304: LD_VAR 0 2
18308: PUSH
18309: LD_VAR 0 4
18313: MINUS
18314: PUSH
18315: LD_INT 0
18317: LESS
18318: IFFALSE 18330
// min_x := 0 else
18320: LD_ADDR_VAR 0 7
18324: PUSH
18325: LD_INT 0
18327: ST_TO_ADDR
18328: GO 18346
// min_x := x - r ;
18330: LD_ADDR_VAR 0 7
18334: PUSH
18335: LD_VAR 0 2
18339: PUSH
18340: LD_VAR 0 4
18344: MINUS
18345: ST_TO_ADDR
// if y - r < 0 then
18346: LD_VAR 0 3
18350: PUSH
18351: LD_VAR 0 4
18355: MINUS
18356: PUSH
18357: LD_INT 0
18359: LESS
18360: IFFALSE 18372
// min_y := 0 else
18362: LD_ADDR_VAR 0 8
18366: PUSH
18367: LD_INT 0
18369: ST_TO_ADDR
18370: GO 18388
// min_y := y - r ;
18372: LD_ADDR_VAR 0 8
18376: PUSH
18377: LD_VAR 0 3
18381: PUSH
18382: LD_VAR 0 4
18386: MINUS
18387: ST_TO_ADDR
// max_x := x + r ;
18388: LD_ADDR_VAR 0 9
18392: PUSH
18393: LD_VAR 0 2
18397: PUSH
18398: LD_VAR 0 4
18402: PLUS
18403: ST_TO_ADDR
// max_y := y + r ;
18404: LD_ADDR_VAR 0 10
18408: PUSH
18409: LD_VAR 0 3
18413: PUSH
18414: LD_VAR 0 4
18418: PLUS
18419: ST_TO_ADDR
// for _x = min_x to max_x do
18420: LD_ADDR_VAR 0 11
18424: PUSH
18425: DOUBLE
18426: LD_VAR 0 7
18430: DEC
18431: ST_TO_ADDR
18432: LD_VAR 0 9
18436: PUSH
18437: FOR_TO
18438: IFFALSE 18555
// for _y = min_y to max_y do
18440: LD_ADDR_VAR 0 12
18444: PUSH
18445: DOUBLE
18446: LD_VAR 0 8
18450: DEC
18451: ST_TO_ADDR
18452: LD_VAR 0 10
18456: PUSH
18457: FOR_TO
18458: IFFALSE 18551
// begin if not ValidHex ( _x , _y ) then
18460: LD_VAR 0 11
18464: PPUSH
18465: LD_VAR 0 12
18469: PPUSH
18470: CALL_OW 488
18474: NOT
18475: IFFALSE 18479
// continue ;
18477: GO 18457
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18479: LD_VAR 0 11
18483: PPUSH
18484: LD_VAR 0 12
18488: PPUSH
18489: CALL_OW 351
18493: PUSH
18494: LD_VAR 0 11
18498: PPUSH
18499: LD_VAR 0 12
18503: PPUSH
18504: CALL_OW 554
18508: AND
18509: IFFALSE 18549
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18511: LD_ADDR_VAR 0 13
18515: PUSH
18516: LD_VAR 0 13
18520: PPUSH
18521: LD_VAR 0 13
18525: PUSH
18526: LD_INT 1
18528: PLUS
18529: PPUSH
18530: LD_VAR 0 11
18534: PUSH
18535: LD_VAR 0 12
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PPUSH
18544: CALL_OW 2
18548: ST_TO_ADDR
// end ;
18549: GO 18457
18551: POP
18552: POP
18553: GO 18437
18555: POP
18556: POP
// if not list then
18557: LD_VAR 0 13
18561: NOT
18562: IFFALSE 18566
// exit ;
18564: GO 18637
// for i in list do
18566: LD_ADDR_VAR 0 6
18570: PUSH
18571: LD_VAR 0 13
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18635
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18579: LD_VAR 0 1
18583: PPUSH
18584: LD_STRING M
18586: PUSH
18587: LD_VAR 0 6
18591: PUSH
18592: LD_INT 1
18594: ARRAY
18595: PUSH
18596: LD_VAR 0 6
18600: PUSH
18601: LD_INT 2
18603: ARRAY
18604: PUSH
18605: LD_INT 0
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: LIST
18625: PUSH
18626: EMPTY
18627: LIST
18628: PPUSH
18629: CALL_OW 447
18633: GO 18576
18635: POP
18636: POP
// end ;
18637: LD_VAR 0 5
18641: RET
