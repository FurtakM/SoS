// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareTrigger ;
   8: CALL 33 0 0
// PrepareVulcanoBase ;
  12: CALL 873 0 0
// PrepareRussian ;
  16: CALL 3482 0 0
// PrepareLegion ;
  20: CALL 6999 0 0
// Action ;
  24: CALL 10678 0 0
// InitArt ;
  28: CALL 194 0 0
// end ;
  32: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  33: LD_INT 0
  35: PPUSH
// base_captured := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// russian_prepared := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// ru_can_attack := false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// ru_sib_bomb := false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 5
  75: PUSH
  76: LD_INT 10
  78: PUSH
  79: LD_INT 25
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: ST_TO_ADDR
// player_res_art := false ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// player_artifact_ready := false ;
 101: LD_ADDR_EXP 7
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// art_icon := art_use_atom ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 7
 116: ST_TO_ADDR
// time_res_art := 600 ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 600
 124: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 21000
 132: ST_TO_ADDR
// mine_vulc := false ;
 133: LD_ADDR_EXP 12
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// medal_enabled := false ;
 141: LD_ADDR_EXP 13
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// dead_counter := 0 ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// kill_counter := 0 ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// veh_counter := 0 ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// tech_counter := 0 ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// end ;
 189: LD_VAR 0 1
 193: RET
// function InitArt ; begin
 194: LD_INT 0
 196: PPUSH
// SetArtifactRes ( your_side , true ) ;
 197: LD_OWVAR 2
 201: PPUSH
 202: LD_INT 1
 204: PPUSH
 205: CALL_OW 467
// end ; end_of_file
 209: LD_VAR 0 1
 213: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 214: LD_INT 0
 216: PPUSH
 217: PPUSH
 218: PPUSH
 219: PPUSH
 220: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 7
 228: PUSH
 229: LD_INT 6
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: PUSH
 240: LD_OWVAR 67
 244: ARRAY
 245: ST_TO_ADDR
// us_force := [ ] ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 253: LD_INT 17
 255: PPUSH
 256: CALL_OW 355
// PrepareAllianceAI ( ) ;
 260: CALL 15357 0 0
// uc_side := 1 ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// uc_nation := nation_american ;
 272: LD_ADDR_OWVAR 21
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// hc_gallery :=  ;
 280: LD_ADDR_OWVAR 33
 284: PUSH
 285: LD_STRING 
 287: ST_TO_ADDR
// hc_name :=  ;
 288: LD_ADDR_OWVAR 26
 292: PUSH
 293: LD_STRING 
 295: ST_TO_ADDR
// hc_importance := 0 ;
 296: LD_ADDR_OWVAR 32
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// for i = 1 to 11 do
 304: LD_ADDR_VAR 0 2
 308: PUSH
 309: DOUBLE
 310: LD_INT 1
 312: DEC
 313: ST_TO_ADDR
 314: LD_INT 11
 316: PUSH
 317: FOR_TO
 318: IFFALSE 371
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 320: LD_INT 0
 322: PPUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 4
 328: PPUSH
 329: CALL_OW 12
 333: PPUSH
 334: LD_EXP 21
 338: PPUSH
 339: CALL_OW 380
// un := CreateHuman ;
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: CALL_OW 44
 352: ST_TO_ADDR
// us_force := us_force ^ un ;
 353: LD_ADDR_EXP 20
 357: PUSH
 358: LD_EXP 20
 362: PUSH
 363: LD_VAR 0 4
 367: ADD
 368: ST_TO_ADDR
// end ;
 369: GO 317
 371: POP
 372: POP
// hc_importance := 100 ;
 373: LD_ADDR_OWVAR 32
 377: PUSH
 378: LD_INT 100
 380: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: LD_EXP 21
 391: PPUSH
 392: CALL_OW 380
// us_commander := CreateHuman ;
 396: LD_ADDR_EXP 19
 400: PUSH
 401: CALL_OW 44
 405: ST_TO_ADDR
// player_commander := us_commander ;
 406: LD_ADDR_EXP 10
 410: PUSH
 411: LD_EXP 19
 415: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 416: LD_ADDR_VAR 0 5
 420: PUSH
 421: LD_STRING text
 423: PPUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 5
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_OWVAR 67
 442: ARRAY
 443: PPUSH
 444: LD_INT 6
 446: PUSH
 447: LD_INT 5
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_OWVAR 67
 462: ARRAY
 463: PPUSH
 464: LD_INT -5
 466: PUSH
 467: LD_EXP 19
 471: PUSH
 472: LD_INT -3
 474: PUSH
 475: LD_INT -2
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: LIST
 483: PUSH
 484: LD_EXP 20
 488: ADD
 489: PPUSH
 490: LD_INT 1
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 2
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 4
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PUSH
 516: LD_INT 5
 518: PUSH
 519: LD_INT 5
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL_OW 42
 548: ST_TO_ADDR
// team := team ^ us_commander ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: LD_EXP 19
 563: ADD
 564: ST_TO_ADDR
// for i = 1 to team do
 565: LD_ADDR_VAR 0 2
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 5
 579: PUSH
 580: FOR_TO
 581: IFFALSE 606
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 583: LD_VAR 0 5
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PPUSH
 594: LD_INT 1
 596: PPUSH
 597: LD_INT 0
 599: PPUSH
 600: CALL_OW 49
 604: GO 580
 606: POP
 607: POP
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 613: LD_OWVAR 1
 617: PUSH
 618: LD_INT 73500
 620: LESS
 621: IFFALSE 648
 623: GO 625
 625: DISABLE
// begin enable ;
 626: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 627: LD_INT 1
 629: PPUSH
 630: LD_INT 5
 632: PPUSH
 633: CALL_OW 12
 637: PPUSH
 638: LD_INT 24
 640: PPUSH
 641: LD_INT 1
 643: PPUSH
 644: CALL_OW 55
// end ;
 648: END
// every 1 1$10 do var time , p , l ;
 649: GO 651
 651: DISABLE
 652: LD_INT 0
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin time := 0 0$44 ;
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 1540
 664: ST_TO_ADDR
// l := 0 ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: LD_INT 0
 672: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 673: LD_VAR 0 1
 677: PPUSH
 678: CALL_OW 67
// l := l + 1 ;
 682: LD_ADDR_VAR 0 3
 686: PUSH
 687: LD_VAR 0 3
 691: PUSH
 692: LD_INT 1
 694: PLUS
 695: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 696: LD_INT 12
 698: PPUSH
 699: CALL_OW 435
 703: PUSH
 704: LD_INT 30
 706: LESS
 707: IFFALSE 766
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 709: LD_INT 1
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL_OW 12
 719: PPUSH
 720: LD_INT 12
 722: PPUSH
 723: LD_INT 1
 725: PPUSH
 726: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 730: LD_INT 1155
 732: PPUSH
 733: LD_INT 1540
 735: PPUSH
 736: CALL_OW 12
 740: PPUSH
 741: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 745: LD_INT 1
 747: PPUSH
 748: LD_INT 5
 750: PPUSH
 751: CALL_OW 12
 755: PPUSH
 756: LD_INT 12
 758: PPUSH
 759: LD_INT 1
 761: PPUSH
 762: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 766: LD_ADDR_VAR 0 2
 770: PUSH
 771: LD_INT 0
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 12
 781: ST_TO_ADDR
// if p then
 782: LD_VAR 0 2
 786: IFFALSE 821
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 788: LD_INT 105
 790: PPUSH
 791: LD_INT 350
 793: PPUSH
 794: CALL_OW 12
 798: PPUSH
 799: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 803: LD_INT 1
 805: PPUSH
 806: LD_INT 4
 808: PPUSH
 809: CALL_OW 12
 813: PPUSH
 814: LD_INT 1
 816: PPUSH
 817: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 15
 828: PUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 11
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: PUSH
 840: LD_OWVAR 67
 844: ARRAY
 845: MOD
 846: PUSH
 847: LD_INT 0
 849: EQUAL
 850: IFFALSE 866
// time := time + 2 2$00 ;
 852: LD_ADDR_VAR 0 1
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 4200
 864: PLUS
 865: ST_TO_ADDR
// end until false ;
 866: LD_INT 0
 868: IFFALSE 673
// end ; end_of_file
 870: PPOPN 3
 872: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
 882: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_INT 22
 890: PUSH
 891: LD_INT 4
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 69
 916: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_INT 470
 924: PUSH
 925: LD_INT 370
 927: PUSH
 928: LD_INT 290
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_OWVAR 67
 940: ARRAY
 941: ST_TO_ADDR
// case Difficulty of 2 :
 942: LD_OWVAR 67
 946: PUSH
 947: LD_INT 2
 949: DOUBLE
 950: EQUAL
 951: IFTRUE 955
 953: GO 986
 955: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 956: LD_VAR 0 3
 960: PPUSH
 961: LD_INT 30
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PPUSH
 971: CALL_OW 72
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 65
// end ; 3 :
 984: GO 1062
 986: LD_INT 3
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1061
 994: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 995: LD_VAR 0 3
 999: PPUSH
1000: LD_INT 30
1002: PUSH
1003: LD_INT 32
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 72
1014: PUSH
1015: LD_INT 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1023: LD_VAR 0 3
1027: PPUSH
1028: LD_INT 30
1030: PUSH
1031: LD_INT 27
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: PPUSH
1038: CALL_OW 72
1042: PUSH
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: CALL_OW 12
1053: ARRAY
1054: PPUSH
1055: CALL_OW 65
// end ; end ;
1059: GO 1062
1061: POP
// for i = 1 to filter do
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: DOUBLE
1068: LD_INT 1
1070: DEC
1071: ST_TO_ADDR
1072: LD_VAR 0 3
1076: PUSH
1077: FOR_TO
1078: IFFALSE 1115
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1080: LD_VAR 0 3
1084: PUSH
1085: LD_VAR 0 2
1089: ARRAY
1090: PPUSH
1091: LD_VAR 0 4
1095: PUSH
1096: LD_INT 29
1098: NEG
1099: PPUSH
1100: LD_INT 29
1102: PPUSH
1103: CALL_OW 12
1107: PLUS
1108: PPUSH
1109: CALL_OW 234
1113: GO 1077
1115: POP
1116: POP
// SetBName ( us_depot , Vulcano1 ) ;
1117: LD_INT 50
1119: PPUSH
1120: LD_STRING Vulcano1
1122: PPUSH
1123: CALL_OW 500
// hc_importance := 0 ;
1127: LD_ADDR_OWVAR 32
1131: PUSH
1132: LD_INT 0
1134: ST_TO_ADDR
// uc_side := 3 ;
1135: LD_ADDR_OWVAR 20
1139: PUSH
1140: LD_INT 3
1142: ST_TO_ADDR
// uc_nation := nation_russian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 3
1150: ST_TO_ADDR
// russian_in_base := [ ] ;
1151: LD_ADDR_VAR 0 8
1155: PUSH
1156: EMPTY
1157: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1158: LD_ADDR_VAR 0 6
1162: PUSH
1163: LD_INT 82
1165: PPUSH
1166: LD_INT 137
1168: PPUSH
1169: LD_INT 106
1171: PPUSH
1172: LD_INT 152
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL 1555 0 5
1182: ST_TO_ADDR
// p := 1 ;
1183: LD_ADDR_VAR 0 7
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: DOUBLE
1197: LD_INT 1
1199: DEC
1200: ST_TO_ADDR
1201: LD_INT 6
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_OWVAR 67
1219: ARRAY
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1334
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1224: LD_INT 0
1226: PPUSH
1227: LD_INT 1
1229: PPUSH
1230: LD_INT 4
1232: PUSH
1233: LD_INT 5
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_OWVAR 67
1248: ARRAY
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1264: LD_ADDR_VAR 0 8
1268: PUSH
1269: LD_VAR 0 8
1273: PUSH
1274: LD_VAR 0 5
1278: ADD
1279: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1280: LD_VAR 0 5
1284: PPUSH
1285: LD_VAR 0 6
1289: PUSH
1290: LD_VAR 0 7
1294: ARRAY
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_VAR 0 7
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: ARRAY
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL_OW 48
// p := p + 2 ;
1318: LD_ADDR_VAR 0 7
1322: PUSH
1323: LD_VAR 0 7
1327: PUSH
1328: LD_INT 2
1330: PLUS
1331: ST_TO_ADDR
// end ;
1332: GO 1221
1334: POP
1335: POP
// end ;
1336: LD_VAR 0 1
1340: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1341: LD_INT 50
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: CALL 2045 0 2
1351: PUSH
1352: LD_INT 40
1354: LESS
1355: IFFALSE 1552
1357: GO 1359
1359: DISABLE
1360: LD_INT 0
1362: PPUSH
1363: PPUSH
// begin uc_side := 4 ;
1364: LD_ADDR_OWVAR 20
1368: PUSH
1369: LD_INT 4
1371: ST_TO_ADDR
// uc_nation := nation_american ;
1372: LD_ADDR_OWVAR 21
1376: PUSH
1377: LD_INT 1
1379: ST_TO_ADDR
// hc_importance := 0 ;
1380: LD_ADDR_OWVAR 32
1384: PUSH
1385: LD_INT 0
1387: ST_TO_ADDR
// for i = 1 to 7 do
1388: LD_ADDR_VAR 0 1
1392: PUSH
1393: DOUBLE
1394: LD_INT 1
1396: DEC
1397: ST_TO_ADDR
1398: LD_INT 7
1400: PUSH
1401: FOR_TO
1402: IFFALSE 1466
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1404: LD_INT 0
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: CALL_OW 12
1417: PPUSH
1418: LD_EXP 21
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1437: LD_VAR 0 2
1441: PPUSH
1442: LD_INT 7
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// SetLives ( un , 10 ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_INT 10
1459: PPUSH
1460: CALL_OW 234
// end ;
1464: GO 1401
1466: POP
1467: POP
// for i = 1 to 5 do
1468: LD_ADDR_VAR 0 1
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 5
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1550
// begin PrepareHuman ( false , 4 , us_skill ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_INT 4
1489: PPUSH
1490: LD_EXP 21
1494: PPUSH
1495: CALL_OW 380
// SetDir ( un , 1 ) ;
1499: LD_VAR 0 2
1503: PPUSH
1504: LD_INT 1
1506: PPUSH
1507: CALL_OW 233
// un := CreateHuman ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: CALL_OW 44
1520: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1521: LD_VAR 0 2
1525: PPUSH
1526: LD_INT 23
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// SetLives ( un , 10 ) ;
1536: LD_VAR 0 2
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: CALL_OW 234
// end ;
1548: GO 1481
1550: POP
1551: POP
// end ; end_of_file
1552: PPOPN 2
1554: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1555: LD_INT 0
1557: PPUSH
1558: PPUSH
1559: PPUSH
// list := [ ] ;
1560: LD_ADDR_VAR 0 7
1564: PUSH
1565: EMPTY
1566: ST_TO_ADDR
// for i = 1 to num do
1567: LD_ADDR_VAR 0 8
1571: PUSH
1572: DOUBLE
1573: LD_INT 1
1575: DEC
1576: ST_TO_ADDR
1577: LD_VAR 0 5
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1639
// begin list := list ^ Rand ( x1 , x2 ) ;
1585: LD_ADDR_VAR 0 7
1589: PUSH
1590: LD_VAR 0 7
1594: PUSH
1595: LD_VAR 0 1
1599: PPUSH
1600: LD_VAR 0 3
1604: PPUSH
1605: CALL_OW 12
1609: ADD
1610: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1611: LD_ADDR_VAR 0 7
1615: PUSH
1616: LD_VAR 0 7
1620: PUSH
1621: LD_VAR 0 2
1625: PPUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: CALL_OW 12
1635: ADD
1636: ST_TO_ADDR
// end ;
1637: GO 1582
1639: POP
1640: POP
// result := list ;
1641: LD_ADDR_VAR 0 6
1645: PUSH
1646: LD_VAR 0 7
1650: ST_TO_ADDR
// end ;
1651: LD_VAR 0 6
1655: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1656: LD_INT 0
1658: PPUSH
1659: PPUSH
1660: PPUSH
1661: PPUSH
// c := Rand ( 1 , 3 ) ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_INT 1
1669: PPUSH
1670: LD_INT 3
1672: PPUSH
1673: CALL_OW 12
1677: ST_TO_ADDR
// for i = 1 to list do
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: DOUBLE
1684: LD_INT 1
1686: DEC
1687: ST_TO_ADDR
1688: LD_VAR 0 1
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1876
// for ta in filter do
1696: LD_ADDR_VAR 0 4
1700: PUSH
1701: LD_VAR 0 2
1705: PUSH
1706: FOR_IN
1707: IFFALSE 1872
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1709: LD_VAR 0 1
1713: PUSH
1714: LD_VAR 0 6
1718: ARRAY
1719: PPUSH
1720: LD_VAR 0 4
1724: PPUSH
1725: CALL_OW 296
1729: PUSH
1730: LD_INT 15
1732: LESSEQUAL
1733: IFFALSE 1870
// begin case c of 1 :
1735: LD_VAR 0 5
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1786
1748: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1749: LD_VAR 0 1
1753: PUSH
1754: LD_VAR 0 6
1758: ARRAY
1759: PPUSH
1760: LD_VAR 0 4
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 154
1784: GO 1870
1786: LD_INT 2
1788: DOUBLE
1789: EQUAL
1790: IFTRUE 1794
1792: GO 1858
1794: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1795: LD_VAR 0 1
1799: PUSH
1800: LD_VAR 0 6
1804: ARRAY
1805: PPUSH
1806: LD_VAR 0 4
1810: PPUSH
1811: CALL_OW 250
1815: PUSH
1816: LD_INT 1
1818: NEG
1819: PPUSH
1820: LD_INT 1
1822: PPUSH
1823: CALL_OW 12
1827: PLUS
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: CALL_OW 251
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: CALL_OW 12
1850: PLUS
1851: PPUSH
1852: CALL_OW 153
1856: GO 1870
1858: LD_INT 3
1860: DOUBLE
1861: EQUAL
1862: IFTRUE 1866
1864: GO 1869
1866: POP
// ; end ;
1867: GO 1870
1869: POP
// end ; end ;
1870: GO 1706
1872: POP
1873: POP
1874: GO 1693
1876: POP
1877: POP
// end ;
1878: LD_VAR 0 3
1882: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
// for i = 1 to n do
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: DOUBLE
1894: LD_INT 1
1896: DEC
1897: ST_TO_ADDR
1898: LD_VAR 0 1
1902: PUSH
1903: FOR_TO
1904: IFFALSE 2038
// begin uc_side := 0 ;
1906: LD_ADDR_OWVAR 20
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// uc_nation := 0 ;
1914: LD_ADDR_OWVAR 21
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// hc_class := class_apeman ;
1922: LD_ADDR_OWVAR 28
1926: PUSH
1927: LD_INT 12
1929: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1930: LD_ADDR_OWVAR 31
1934: PUSH
1935: LD_INT 0
1937: PUSH
1938: LD_INT 0
1940: PUSH
1941: LD_INT 0
1943: PUSH
1944: LD_INT 0
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: ST_TO_ADDR
// hc_name :=  ;
1953: LD_ADDR_OWVAR 26
1957: PUSH
1958: LD_STRING 
1960: ST_TO_ADDR
// hc_gallery :=  ;
1961: LD_ADDR_OWVAR 33
1965: PUSH
1966: LD_STRING 
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// un := CreateHuman ;
1977: LD_ADDR_VAR 0 3
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1987: LD_VAR 0 3
1991: PPUSH
1992: LD_INT 19
1994: PUSH
1995: LD_INT 20
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PPUSH
2014: LD_INT 0
2016: PPUSH
2017: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2021: LD_INT 1155
2023: PPUSH
2024: LD_INT 5355
2026: PPUSH
2027: CALL_OW 12
2031: PPUSH
2032: CALL_OW 67
// end ;
2036: GO 1903
2038: POP
2039: POP
// end ;
2040: LD_VAR 0 2
2044: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2050: LD_ADDR_VAR 0 4
2054: PUSH
2055: LD_INT 22
2057: PUSH
2058: LD_VAR 0 2
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 74
2081: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2082: LD_ADDR_VAR 0 5
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_VAR 0 4
2096: PPUSH
2097: CALL_OW 296
2101: ST_TO_ADDR
// if dist >= 9999 then
2102: LD_VAR 0 5
2106: PUSH
2107: LD_INT 9999
2109: GREATEREQUAL
2110: IFFALSE 2123
// result := - 1 else
2112: LD_ADDR_VAR 0 3
2116: PUSH
2117: LD_INT 1
2119: NEG
2120: ST_TO_ADDR
2121: GO 2133
// result := dist ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 5
2132: ST_TO_ADDR
// end ;
2133: LD_VAR 0 3
2137: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2138: LD_INT 0
2140: PPUSH
2141: PPUSH
2142: PPUSH
2143: PPUSH
// tmp := 9999 ;
2144: LD_ADDR_VAR 0 5
2148: PUSH
2149: LD_INT 9999
2151: ST_TO_ADDR
// for i = 1 to plist do
2152: LD_ADDR_VAR 0 4
2156: PUSH
2157: DOUBLE
2158: LD_INT 1
2160: DEC
2161: ST_TO_ADDR
2162: LD_VAR 0 1
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2242
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2170: LD_VAR 0 1
2174: PUSH
2175: LD_VAR 0 4
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 2
2185: PPUSH
2186: CALL 2045 0 2
2190: PUSH
2191: LD_VAR 0 5
2195: LESS
2196: IFFALSE 2240
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 1
2207: PUSH
2208: LD_VAR 0 4
2212: ARRAY
2213: PPUSH
2214: LD_VAR 0 2
2218: PPUSH
2219: CALL 2045 0 2
2223: ST_TO_ADDR
// unit := plist [ i ] ;
2224: LD_ADDR_VAR 0 6
2228: PUSH
2229: LD_VAR 0 1
2233: PUSH
2234: LD_VAR 0 4
2238: ARRAY
2239: ST_TO_ADDR
// end ;
2240: GO 2167
2242: POP
2243: POP
// result := unit ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: LD_VAR 0 6
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 3
2258: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2266: LD_ADDR_VAR 0 2
2270: PUSH
2271: LD_INT 1000
2273: PUSH
2274: LD_INT 2500
2276: PUSH
2277: LD_INT 5000
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: LD_OWVAR 67
2289: ARRAY
2290: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2291: LD_ADDR_VAR 0 2
2295: PUSH
2296: LD_VAR 0 2
2300: PUSH
2301: LD_INT 1
2303: NEG
2304: PUSH
2305: LD_INT 22
2307: PUSH
2308: LD_OWVAR 2
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: MUL
2336: PUSH
2337: LD_INT 30
2339: MUL
2340: PLUS
2341: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2342: LD_ADDR_VAR 0 2
2346: PUSH
2347: LD_VAR 0 2
2351: PUSH
2352: LD_EXP 15
2356: PUSH
2357: LD_INT 10
2359: MUL
2360: PLUS
2361: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2362: LD_ADDR_VAR 0 2
2366: PUSH
2367: LD_VAR 0 2
2371: PUSH
2372: LD_INT 1
2374: NEG
2375: PUSH
2376: LD_EXP 15
2380: MUL
2381: PUSH
2382: LD_INT 20
2384: MUL
2385: PLUS
2386: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_INT 1
2399: NEG
2400: PUSH
2401: LD_OWVAR 1
2405: PUSH
2406: LD_INT 35
2408: DIVREAL
2409: PUSH
2410: LD_INT 60
2412: DIVREAL
2413: MUL
2414: PUSH
2415: LD_INT 25
2417: MUL
2418: PLUS
2419: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: LD_VAR 0 2
2429: PUSH
2430: LD_EXP 17
2434: PUSH
2435: LD_INT 15
2437: MUL
2438: PLUS
2439: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2440: LD_ADDR_VAR 0 2
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: NEG
2453: PUSH
2454: LD_EXP 18
2458: MUL
2459: PUSH
2460: LD_INT 1000
2462: MUL
2463: PLUS
2464: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 16
2479: PUSH
2480: LD_INT 5
2482: MUL
2483: PLUS
2484: ST_TO_ADDR
// result := points ;
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_VAR 0 2
2494: ST_TO_ADDR
// end ; end_of_file
2495: LD_VAR 0 1
2499: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2500: LD_VAR 0 1
2504: PPUSH
2505: CALL_OW 255
2509: PUSH
2510: LD_OWVAR 2
2514: EQUAL
2515: IFFALSE 2531
// dead_counter := dead_counter + 1 ;
2517: LD_ADDR_EXP 14
2521: PUSH
2522: LD_EXP 14
2526: PUSH
2527: LD_INT 1
2529: PLUS
2530: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 255
2540: PUSH
2541: LD_INT 81
2543: PUSH
2544: LD_OWVAR 2
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: IN
2558: IFFALSE 2574
// kill_counter := kill_counter + 1 ;
2560: LD_ADDR_EXP 15
2564: PUSH
2565: LD_EXP 15
2569: PUSH
2570: LD_INT 1
2572: PLUS
2573: ST_TO_ADDR
// if un = player_commander then
2574: LD_VAR 0 1
2578: PUSH
2579: LD_EXP 10
2583: EQUAL
2584: IFFALSE 2593
// YouLost ( vulcano-lost ) ;
2586: LD_STRING vulcano-lost
2588: PPUSH
2589: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2593: LD_VAR 0 1
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_INT 3
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: PUSH
2608: LD_INT 21
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PPUSH
2622: CALL_OW 69
2626: IN
2627: IFFALSE 2743
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2629: LD_VAR 0 1
2633: PPUSH
2634: CALL_OW 266
2638: PUSH
2639: LD_INT 33
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 266
2652: PUSH
2653: LD_INT 28
2655: EQUAL
2656: OR
2657: IFFALSE 2743
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2659: LD_ADDR_EXP 26
2663: PUSH
2664: LD_EXP 26
2668: PUSH
2669: LD_VAR 0 1
2673: PPUSH
2674: CALL_OW 266
2678: ADD
2679: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2680: LD_ADDR_EXP 26
2684: PUSH
2685: LD_EXP 26
2689: PUSH
2690: LD_VAR 0 1
2694: PPUSH
2695: CALL_OW 250
2699: ADD
2700: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2701: LD_ADDR_EXP 26
2705: PUSH
2706: LD_EXP 26
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 251
2720: ADD
2721: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2722: LD_ADDR_EXP 26
2726: PUSH
2727: LD_EXP 26
2731: PUSH
2732: LD_VAR 0 1
2736: PPUSH
2737: CALL_OW 254
2741: ADD
2742: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2743: LD_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 8
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: IN
2777: IFFALSE 2921
// begin if GetBType ( un ) = b_barracks then
2779: LD_VAR 0 1
2783: PPUSH
2784: CALL_OW 266
2788: PUSH
2789: LD_INT 5
2791: EQUAL
2792: IFFALSE 2810
// legion_blist := legion_blist ^ b_armoury else
2794: LD_ADDR_EXP 34
2798: PUSH
2799: LD_EXP 34
2803: PUSH
2804: LD_INT 4
2806: ADD
2807: ST_TO_ADDR
2808: GO 2858
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2810: LD_VAR 0 1
2814: PPUSH
2815: CALL_OW 266
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 6
2825: PUSH
2826: LD_INT 8
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: IN
2834: NOT
2835: IFFALSE 2858
// legion_blist := legion_blist ^ GetBType ( un ) ;
2837: LD_ADDR_EXP 34
2841: PUSH
2842: LD_EXP 34
2846: PUSH
2847: LD_VAR 0 1
2851: PPUSH
2852: CALL_OW 266
2856: ADD
2857: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2858: LD_ADDR_EXP 34
2862: PUSH
2863: LD_EXP 34
2867: PUSH
2868: LD_VAR 0 1
2872: PPUSH
2873: CALL_OW 250
2877: ADD
2878: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2879: LD_ADDR_EXP 34
2883: PUSH
2884: LD_EXP 34
2888: PUSH
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 251
2898: ADD
2899: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2900: LD_ADDR_EXP 34
2904: PUSH
2905: LD_EXP 34
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: CALL_OW 254
2919: ADD
2920: ST_TO_ADDR
// end ; if un in legion_force then
2921: LD_VAR 0 1
2925: PUSH
2926: LD_EXP 31
2930: IN
2931: IFFALSE 2949
// legion_force := legion_force diff un ;
2933: LD_ADDR_EXP 31
2937: PUSH
2938: LD_EXP 31
2942: PUSH
2943: LD_VAR 0 1
2947: DIFF
2948: ST_TO_ADDR
// if un in ru_force then
2949: LD_VAR 0 1
2953: PUSH
2954: LD_EXP 23
2958: IN
2959: IFFALSE 2977
// ru_force := ru_force diff un ;
2961: LD_ADDR_EXP 23
2965: PUSH
2966: LD_EXP 23
2970: PUSH
2971: LD_VAR 0 1
2975: DIFF
2976: ST_TO_ADDR
// if un in al_force then
2977: LD_VAR 0 1
2981: PUSH
2982: LD_EXP 38
2986: IN
2987: IFFALSE 3005
// al_force := al_force diff un ;
2989: LD_ADDR_EXP 38
2993: PUSH
2994: LD_EXP 38
2998: PUSH
2999: LD_VAR 0 1
3003: DIFF
3004: ST_TO_ADDR
// end ;
3005: PPOPN 1
3007: END
// on BuildingComplete ( b ) do var i ;
3008: LD_INT 0
3010: PPUSH
// begin if GetSide ( b ) = 8 then
3011: LD_VAR 0 1
3015: PPUSH
3016: CALL_OW 255
3020: PUSH
3021: LD_INT 8
3023: EQUAL
3024: IFFALSE 3064
// for i = 1 to 4 do
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: DOUBLE
3032: LD_INT 1
3034: DEC
3035: ST_TO_ADDR
3036: LD_INT 4
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3062
// legion_blist := Delete ( legion_blist , 1 ) ;
3042: LD_ADDR_EXP 34
3046: PUSH
3047: LD_EXP 34
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: CALL_OW 3
3059: ST_TO_ADDR
3060: GO 3039
3062: POP
3063: POP
// if GetSide ( b ) = 3 then
3064: LD_VAR 0 1
3068: PPUSH
3069: CALL_OW 255
3073: PUSH
3074: LD_INT 3
3076: EQUAL
3077: IFFALSE 3117
// for i = 1 to 4 do
3079: LD_ADDR_VAR 0 2
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_INT 4
3091: PUSH
3092: FOR_TO
3093: IFFALSE 3115
// ru_blist := Delete ( ru_blist , 1 ) ;
3095: LD_ADDR_EXP 26
3099: PUSH
3100: LD_EXP 26
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: CALL_OW 3
3112: ST_TO_ADDR
3113: GO 3092
3115: POP
3116: POP
// end ;
3117: PPOPN 2
3119: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3120: LD_VAR 0 1
3124: PPUSH
3125: CALL_OW 264
3129: PUSH
3130: LD_INT 51
3132: PUSH
3133: LD_INT 48
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: IN
3140: NOT
3141: IFFALSE 3189
// begin if GetSide ( veh ) = 3 then
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 255
3152: PUSH
3153: LD_INT 3
3155: EQUAL
3156: IFFALSE 3189
// begin ComMoveXY ( veh , 149 , 8 ) ;
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 149
3165: PPUSH
3166: LD_INT 8
3168: PPUSH
3169: CALL_OW 111
// ru_force := ru_force ^ veh ;
3173: LD_ADDR_EXP 23
3177: PUSH
3178: LD_EXP 23
3182: PUSH
3183: LD_VAR 0 1
3187: ADD
3188: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 264
3198: PUSH
3199: LD_INT 32
3201: PUSH
3202: LD_INT 31
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: IN
3209: NOT
3210: IFFALSE 3243
// begin if GetSide ( veh ) = 8 then
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 255
3221: PUSH
3222: LD_INT 8
3224: EQUAL
3225: IFFALSE 3243
// legion_force := legion_force ^ veh ;
3227: LD_ADDR_EXP 31
3231: PUSH
3232: LD_EXP 31
3236: PUSH
3237: LD_VAR 0 1
3241: ADD
3242: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3243: LD_VAR 0 1
3247: PPUSH
3248: CALL_OW 255
3252: PUSH
3253: LD_INT 7
3255: EQUAL
3256: PUSH
3257: LD_OWVAR 2
3261: PUSH
3262: LD_INT 7
3264: NONEQUAL
3265: AND
3266: IFFALSE 3284
// al_force := al_force ^ veh ;
3268: LD_ADDR_EXP 38
3272: PUSH
3273: LD_EXP 38
3277: PUSH
3278: LD_VAR 0 1
3282: ADD
3283: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3284: LD_VAR 0 1
3288: PPUSH
3289: CALL_OW 255
3293: PUSH
3294: LD_OWVAR 2
3298: EQUAL
3299: IFFALSE 3315
// veh_counter := veh_counter + 1 ;
3301: LD_ADDR_EXP 16
3305: PUSH
3306: LD_EXP 16
3310: PUSH
3311: LD_INT 1
3313: PLUS
3314: ST_TO_ADDR
// end ;
3315: PPOPN 2
3317: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3318: LD_VAR 0 1
3322: PPUSH
3323: CALL_OW 255
3327: PUSH
3328: LD_OWVAR 2
3332: NONEQUAL
3333: IFFALSE 3349
// sib_contamin_counter := sib_contamin_counter + 1 ;
3335: LD_ADDR_EXP 18
3339: PUSH
3340: LD_EXP 18
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: ST_TO_ADDR
// end ;
3349: PPOPN 3
3351: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3352: LD_VAR 0 2
3356: PPUSH
3357: CALL_OW 255
3361: PUSH
3362: LD_OWVAR 2
3366: EQUAL
3367: IFFALSE 3383
// tech_counter := tech_counter + 1 ;
3369: LD_ADDR_EXP 17
3373: PUSH
3374: LD_EXP 17
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3383: LD_VAR 0 1
3387: PUSH
3388: LD_INT 53
3390: EQUAL
3391: PUSH
3392: LD_OWVAR 2
3396: PUSH
3397: LD_INT 1
3399: EQUAL
3400: AND
3401: IFFALSE 3416
// SetTech ( 80 , 1 , state_researched ) ;
3403: LD_INT 80
3405: PPUSH
3406: LD_INT 1
3408: PPUSH
3409: LD_INT 2
3411: PPUSH
3412: CALL_OW 322
// end ;
3416: PPOPN 2
3418: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3419: LD_INT 25
3421: PUSH
3422: LD_INT 12
3424: PUSH
3425: EMPTY
3426: LIST
3427: LIST
3428: PPUSH
3429: CALL_OW 69
3433: PUSH
3434: LD_INT 9
3436: LESS
3437: IFFALSE 3479
3439: GO 3441
3441: DISABLE
3442: LD_INT 0
3444: PPUSH
// begin enable ;
3445: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3446: LD_ADDR_VAR 0 1
3450: PUSH
3451: LD_INT 25
3453: PUSH
3454: LD_INT 12
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3466: LD_INT 8
3468: PUSH
3469: LD_VAR 0 1
3473: MINUS
3474: PPUSH
3475: CALL 1883 0 1
// end ; end_of_file
3479: PPOPN 1
3481: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3482: LD_INT 0
3484: PPUSH
3485: PPUSH
3486: PPUSH
3487: PPUSH
3488: PPUSH
3489: PPUSH
3490: PPUSH
3491: PPUSH
3492: PPUSH
3493: PPUSH
3494: PPUSH
// uc_side := 3 ;
3495: LD_ADDR_OWVAR 20
3499: PUSH
3500: LD_INT 3
3502: ST_TO_ADDR
// uc_nation := nation_russian ;
3503: LD_ADDR_OWVAR 21
3507: PUSH
3508: LD_INT 3
3510: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3511: LD_ADDR_VAR 0 4
3515: PUSH
3516: LD_INT 22
3518: PUSH
3519: LD_INT 3
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: PUSH
3526: LD_INT 30
3528: PUSH
3529: LD_INT 1
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PUSH
3536: EMPTY
3537: LIST
3538: LIST
3539: PPUSH
3540: CALL_OW 69
3544: PUSH
3545: LD_INT 1
3547: ARRAY
3548: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3549: LD_ADDR_VAR 0 5
3553: PUSH
3554: LD_INT 22
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PUSH
3564: LD_INT 30
3566: PUSH
3567: LD_INT 3
3569: PUSH
3570: EMPTY
3571: LIST
3572: LIST
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: PPUSH
3578: CALL_OW 69
3582: PUSH
3583: LD_INT 1
3585: ARRAY
3586: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_INT 22
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 30
3604: PUSH
3605: LD_INT 34
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 69
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3625: LD_ADDR_VAR 0 8
3629: PUSH
3630: LD_INT 22
3632: PUSH
3633: LD_INT 3
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 30
3642: PUSH
3643: LD_INT 33
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PPUSH
3654: CALL_OW 69
3658: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3659: LD_ADDR_VAR 0 7
3663: PUSH
3664: LD_INT 22
3666: PUSH
3667: LD_INT 3
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: LD_INT 30
3676: PUSH
3677: LD_INT 5
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: PPUSH
3688: CALL_OW 69
3692: PUSH
3693: LD_INT 1
3695: ARRAY
3696: ST_TO_ADDR
// ru_blist := [ ] ;
3697: LD_ADDR_EXP 26
3701: PUSH
3702: EMPTY
3703: ST_TO_ADDR
// ru_vlist := [ ] ;
3704: LD_ADDR_EXP 27
3708: PUSH
3709: EMPTY
3710: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3711: LD_ADDR_EXP 30
3715: PUSH
3716: LD_INT 183
3718: PUSH
3719: LD_INT 62
3721: PUSH
3722: LD_INT 147
3724: PUSH
3725: LD_INT 44
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3734: LD_INT 30
3736: PUSH
3737: LD_INT 34
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PPUSH
3744: CALL_OW 69
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_EXP 30
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: PPUSH
3762: LD_EXP 30
3766: PUSH
3767: LD_INT 2
3769: ARRAY
3770: PPUSH
3771: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3775: LD_ADDR_EXP 28
3779: PUSH
3780: LD_INT 4
3782: PUSH
3783: LD_INT 5
3785: PUSH
3786: LD_INT 6
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: LIST
3793: PUSH
3794: LD_OWVAR 67
3798: ARRAY
3799: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3800: LD_VAR 0 4
3804: PPUSH
3805: CALL_OW 274
3809: PPUSH
3810: LD_INT 1
3812: PPUSH
3813: LD_INT 3000
3815: PPUSH
3816: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: CALL_OW 274
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: LD_INT 300
3835: PPUSH
3836: CALL_OW 277
// hc_gallery :=  ;
3840: LD_ADDR_OWVAR 33
3844: PUSH
3845: LD_STRING 
3847: ST_TO_ADDR
// hc_name :=  ;
3848: LD_ADDR_OWVAR 26
3852: PUSH
3853: LD_STRING 
3855: ST_TO_ADDR
// hc_importance := 0 ;
3856: LD_ADDR_OWVAR 32
3860: PUSH
3861: LD_INT 0
3863: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3864: LD_ADDR_EXP 24
3868: PUSH
3869: LD_INT 5
3871: PUSH
3872: LD_INT 6
3874: PUSH
3875: LD_INT 7
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: LIST
3882: PUSH
3883: LD_OWVAR 67
3887: ARRAY
3888: ST_TO_ADDR
// for i = 1 to 6 do
3889: LD_ADDR_VAR 0 2
3893: PUSH
3894: DOUBLE
3895: LD_INT 1
3897: DEC
3898: ST_TO_ADDR
3899: LD_INT 6
3901: PUSH
3902: FOR_TO
3903: IFFALSE 4061
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3905: LD_INT 0
3907: PPUSH
3908: LD_INT 9
3910: PPUSH
3911: LD_EXP 24
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3930: LD_VAR 0 3
3934: PPUSH
3935: LD_VAR 0 7
3939: PPUSH
3940: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3944: LD_INT 0
3946: PPUSH
3947: LD_INT 4
3949: PPUSH
3950: LD_EXP 24
3954: PPUSH
3955: CALL_OW 380
// un := CreateHuman ;
3959: LD_ADDR_VAR 0 3
3963: PUSH
3964: CALL_OW 44
3968: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3969: LD_VAR 0 3
3973: PPUSH
3974: LD_INT 24
3976: PPUSH
3977: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3981: LD_INT 0
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_EXP 24
3991: PPUSH
3992: CALL_OW 380
// un := CreateHuman ;
3996: LD_ADDR_VAR 0 3
4000: PUSH
4001: CALL_OW 44
4005: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4006: LD_VAR 0 3
4010: PPUSH
4011: LD_VAR 0 5
4015: PPUSH
4016: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4020: LD_INT 0
4022: PPUSH
4023: LD_INT 2
4025: PPUSH
4026: LD_EXP 24
4030: PPUSH
4031: CALL_OW 380
// un := CreateHuman ;
4035: LD_ADDR_VAR 0 3
4039: PUSH
4040: CALL_OW 44
4044: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4045: LD_VAR 0 3
4049: PPUSH
4050: LD_VAR 0 4
4054: PPUSH
4055: CALL_OW 52
// end ;
4059: GO 3902
4061: POP
4062: POP
// russian_prepared := true ;
4063: LD_ADDR_EXP 2
4067: PUSH
4068: LD_INT 1
4070: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4071: LD_VAR 0 5
4075: PPUSH
4076: LD_INT 21
4078: PPUSH
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_INT 51
4087: PPUSH
4088: CALL_OW 125
// end ;
4092: LD_VAR 0 1
4096: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4097: LD_INT 22
4099: PUSH
4100: LD_INT 3
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PPUSH
4107: CALL_OW 69
4111: PUSH
4112: LD_INT 0
4114: GREATER
4115: PUSH
4116: LD_EXP 2
4120: AND
4121: IFFALSE 6570
4123: GO 4125
4125: DISABLE
4126: LD_INT 0
4128: PPUSH
4129: PPUSH
4130: PPUSH
4131: PPUSH
4132: PPUSH
4133: PPUSH
4134: PPUSH
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
// begin enable ;
4145: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4146: LD_ADDR_VAR 0 1
4150: PUSH
4151: LD_INT 22
4153: PUSH
4154: LD_INT 3
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PUSH
4161: LD_INT 30
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PPUSH
4175: CALL_OW 69
4179: PUSH
4180: LD_INT 1
4182: ARRAY
4183: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: LD_INT 22
4191: PUSH
4192: LD_INT 3
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: PUSH
4199: LD_INT 30
4201: PUSH
4202: LD_INT 3
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PPUSH
4213: CALL_OW 69
4217: PUSH
4218: LD_INT 1
4220: ARRAY
4221: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4222: LD_ADDR_VAR 0 3
4226: PUSH
4227: LD_INT 22
4229: PUSH
4230: LD_INT 3
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 30
4239: PUSH
4240: LD_INT 34
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: PPUSH
4251: CALL_OW 69
4255: PUSH
4256: LD_INT 1
4258: ARRAY
4259: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4260: LD_ADDR_VAR 0 4
4264: PUSH
4265: LD_INT 22
4267: PUSH
4268: LD_INT 3
4270: PUSH
4271: EMPTY
4272: LIST
4273: LIST
4274: PUSH
4275: LD_INT 30
4277: PUSH
4278: LD_INT 33
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PPUSH
4289: CALL_OW 69
4293: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4294: LD_ADDR_VAR 0 8
4298: PUSH
4299: LD_INT 22
4301: PUSH
4302: LD_INT 3
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 30
4311: PUSH
4312: LD_INT 5
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PPUSH
4323: CALL_OW 69
4327: PUSH
4328: LD_INT 1
4330: ARRAY
4331: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4332: LD_ADDR_VAR 0 5
4336: PUSH
4337: LD_INT 22
4339: PUSH
4340: LD_INT 3
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 21
4349: PUSH
4350: LD_INT 3
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PPUSH
4361: CALL_OW 69
4365: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4366: LD_ADDR_VAR 0 6
4370: PUSH
4371: LD_INT 22
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 21
4383: PUSH
4384: LD_INT 2
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PPUSH
4395: CALL_OW 69
4399: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4400: LD_ADDR_VAR 0 7
4404: PUSH
4405: LD_INT 22
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 21
4417: PUSH
4418: LD_INT 1
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL_OW 69
4433: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4434: LD_ADDR_VAR 0 9
4438: PUSH
4439: LD_VAR 0 7
4443: PPUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PPUSH
4454: CALL_OW 72
4458: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4459: LD_ADDR_VAR 0 10
4463: PUSH
4464: LD_VAR 0 7
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 3
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 72
4483: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4484: LD_ADDR_VAR 0 11
4488: PUSH
4489: LD_VAR 0 7
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 4
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4509: LD_INT 22
4511: PUSH
4512: LD_INT 3
4514: PUSH
4515: EMPTY
4516: LIST
4517: LIST
4518: PUSH
4519: LD_INT 34
4521: PUSH
4522: LD_INT 51
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: PUSH
4538: LD_INT 0
4540: GREATER
4541: PUSH
4542: LD_EXP 25
4546: PUSH
4547: LD_INT 0
4549: EQUAL
4550: AND
4551: IFFALSE 4591
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4553: LD_ADDR_EXP 25
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 3
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 34
4570: PUSH
4571: LD_INT 51
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL_OW 69
4586: PUSH
4587: LD_INT 1
4589: ARRAY
4590: ST_TO_ADDR
// if ru_cargo then
4591: LD_EXP 25
4595: IFFALSE 4893
// begin if IsInArea ( ru_cargo , ru_base ) then
4597: LD_EXP 25
4601: PPUSH
4602: LD_INT 9
4604: PPUSH
4605: CALL_OW 308
4609: IFFALSE 4688
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4611: LD_EXP 25
4615: PPUSH
4616: LD_INT 1
4618: PPUSH
4619: CALL_OW 289
4623: PUSH
4624: LD_INT 0
4626: EQUAL
4627: IFFALSE 4645
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4629: LD_EXP 25
4633: PPUSH
4634: LD_VAR 0 3
4638: PPUSH
4639: CALL_OW 120
4643: GO 4686
// if not HasTask ( ru_cargo ) then
4645: LD_EXP 25
4649: PPUSH
4650: CALL_OW 314
4654: NOT
4655: IFFALSE 4686
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4657: LD_EXP 25
4661: PPUSH
4662: LD_VAR 0 1
4666: PPUSH
4667: CALL_OW 250
4671: PPUSH
4672: LD_VAR 0 1
4676: PPUSH
4677: CALL_OW 251
4681: PPUSH
4682: CALL_OW 111
// end else
4686: GO 4893
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4688: LD_EXP 25
4692: PPUSH
4693: CALL_OW 314
4697: NOT
4698: PUSH
4699: LD_EXP 25
4703: PPUSH
4704: LD_INT 1
4706: PPUSH
4707: CALL_OW 289
4711: PUSH
4712: LD_INT 100
4714: LESS
4715: AND
4716: IFFALSE 4782
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4718: LD_ADDR_VAR 0 16
4722: PUSH
4723: LD_INT 11
4725: PPUSH
4726: CALL_OW 435
4730: ST_TO_ADDR
// if cr > 0 then
4731: LD_VAR 0 16
4735: PUSH
4736: LD_INT 0
4738: GREATER
4739: IFFALSE 4770
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4741: LD_EXP 25
4745: PPUSH
4746: LD_VAR 0 16
4750: PUSH
4751: LD_INT 1
4753: ARRAY
4754: PPUSH
4755: LD_VAR 0 16
4759: PUSH
4760: LD_INT 2
4762: ARRAY
4763: PPUSH
4764: CALL_OW 117
4768: GO 4782
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4770: LD_EXP 25
4774: PPUSH
4775: LD_INT 11
4777: PPUSH
4778: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4782: LD_EXP 25
4786: PPUSH
4787: CALL_OW 314
4791: NOT
4792: PUSH
4793: LD_EXP 25
4797: PPUSH
4798: LD_INT 10
4800: PPUSH
4801: CALL_OW 308
4805: NOT
4806: AND
4807: PUSH
4808: LD_EXP 25
4812: PPUSH
4813: LD_INT 1
4815: PPUSH
4816: CALL_OW 289
4820: PUSH
4821: LD_INT 100
4823: EQUAL
4824: AND
4825: IFFALSE 4839
// ComMoveToArea ( ru_cargo , cargoa ) ;
4827: LD_EXP 25
4831: PPUSH
4832: LD_INT 10
4834: PPUSH
4835: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4839: LD_EXP 25
4843: PPUSH
4844: LD_INT 10
4846: PPUSH
4847: CALL_OW 308
4851: PUSH
4852: LD_VAR 0 8
4856: AND
4857: IFFALSE 4893
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4859: LD_VAR 0 7
4863: PPUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 9
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PPUSH
4874: CALL_OW 72
4878: PUSH
4879: LD_INT 1
4881: ARRAY
4882: PPUSH
4883: LD_INT 139
4885: PPUSH
4886: LD_INT 24
4888: PPUSH
4889: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 0
4900: EQUAL
4901: PUSH
4902: LD_VAR 0 2
4906: AND
4907: PUSH
4908: LD_VAR 0 2
4912: PPUSH
4913: CALL_OW 461
4917: PUSH
4918: LD_INT 2
4920: EQUAL
4921: AND
4922: IFFALSE 4945
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4924: LD_VAR 0 2
4928: PPUSH
4929: LD_INT 21
4931: PPUSH
4932: LD_INT 3
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 51
4940: PPUSH
4941: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4945: LD_VAR 0 7
4949: PPUSH
4950: LD_INT 25
4952: PUSH
4953: LD_INT 9
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PPUSH
4960: CALL_OW 72
4964: IFFALSE 5028
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4966: LD_VAR 0 7
4970: PPUSH
4971: LD_INT 25
4973: PUSH
4974: LD_INT 9
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: PPUSH
4981: CALL_OW 72
4985: PPUSH
4986: LD_INT 22
4988: PUSH
4989: LD_OWVAR 2
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 3
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PPUSH
5024: CALL 1656 0 2
// if ru_factory and ru_vlist > 0 then
5028: LD_VAR 0 2
5032: PUSH
5033: LD_EXP 27
5037: PUSH
5038: LD_INT 0
5040: GREATER
5041: AND
5042: IFFALSE 5142
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5044: LD_VAR 0 2
5048: PPUSH
5049: CALL_OW 461
5053: PUSH
5054: LD_INT 2
5056: EQUAL
5057: IFFALSE 5142
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5059: LD_VAR 0 2
5063: PPUSH
5064: LD_EXP 27
5068: PUSH
5069: LD_INT 1
5071: ARRAY
5072: PPUSH
5073: LD_EXP 27
5077: PUSH
5078: LD_INT 2
5080: ARRAY
5081: PPUSH
5082: LD_EXP 27
5086: PUSH
5087: LD_INT 3
5089: ARRAY
5090: PPUSH
5091: LD_EXP 27
5095: PUSH
5096: LD_INT 4
5098: ARRAY
5099: PPUSH
5100: CALL_OW 125
// for i = 1 to 4 do
5104: LD_ADDR_VAR 0 12
5108: PUSH
5109: DOUBLE
5110: LD_INT 1
5112: DEC
5113: ST_TO_ADDR
5114: LD_INT 4
5116: PUSH
5117: FOR_TO
5118: IFFALSE 5140
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5120: LD_ADDR_EXP 27
5124: PUSH
5125: LD_EXP 27
5129: PPUSH
5130: LD_INT 1
5132: PPUSH
5133: CALL_OW 3
5137: ST_TO_ADDR
5138: GO 5117
5140: POP
5141: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5142: LD_INT 24
5144: PPUSH
5145: CALL_OW 461
5149: PUSH
5150: LD_INT 2
5152: EQUAL
5153: PUSH
5154: LD_EXP 4
5158: AND
5159: IFFALSE 5187
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5161: LD_INT 25
5163: PPUSH
5164: LD_INT 3
5166: PPUSH
5167: CALL_OW 321
5171: PUSH
5172: LD_INT 1
5174: EQUAL
5175: IFFALSE 5187
// ComResearch ( ru_lab , tech_sibfiss ) ;
5177: LD_INT 24
5179: PPUSH
5180: LD_INT 25
5182: PPUSH
5183: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched then
5187: LD_INT 25
5189: PPUSH
5190: LD_INT 3
5192: PPUSH
5193: CALL_OW 321
5197: PUSH
5198: LD_INT 2
5200: EQUAL
5201: IFFALSE 5239
// if BuildingStatus ( ru_factory ) = bs_idle then
5203: LD_VAR 0 2
5207: PPUSH
5208: CALL_OW 461
5212: PUSH
5213: LD_INT 2
5215: EQUAL
5216: IFFALSE 5239
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5218: LD_VAR 0 2
5222: PPUSH
5223: LD_INT 23
5225: PPUSH
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 3
5231: PPUSH
5232: LD_INT 48
5234: PPUSH
5235: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5239: LD_INT 22
5241: PUSH
5242: LD_INT 3
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: PUSH
5249: LD_INT 34
5251: PUSH
5252: LD_INT 48
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL_OW 69
5267: PUSH
5268: LD_INT 0
5270: GREATER
5271: IFFALSE 5645
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5273: LD_ADDR_VAR 0 17
5277: PUSH
5278: LD_INT 22
5280: PUSH
5281: LD_INT 3
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: PUSH
5288: LD_INT 34
5290: PUSH
5291: LD_INT 48
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PPUSH
5302: CALL_OW 69
5306: PUSH
5307: LD_INT 1
5309: ARRAY
5310: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5311: LD_VAR 0 17
5315: PPUSH
5316: LD_INT 9
5318: PPUSH
5319: CALL_OW 308
5323: IFFALSE 5341
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5325: LD_VAR 0 17
5329: PPUSH
5330: LD_VAR 0 3
5334: PPUSH
5335: CALL_OW 120
5339: GO 5645
// if not HasTask ( sib_bomb ) then
5341: LD_VAR 0 17
5345: PPUSH
5346: CALL_OW 314
5350: NOT
5351: IFFALSE 5645
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5353: LD_INT 22
5355: PUSH
5356: LD_OWVAR 2
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 30
5367: PUSH
5368: LD_INT 1
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 69
5383: PUSH
5384: LD_INT 1
5386: ARRAY
5387: PPUSH
5388: CALL_OW 256
5392: PUSH
5393: LD_INT 250
5395: GREATER
5396: IFFALSE 5489
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5398: LD_VAR 0 17
5402: PPUSH
5403: LD_INT 22
5405: PUSH
5406: LD_OWVAR 2
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PUSH
5415: LD_INT 30
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL_OW 69
5433: PUSH
5434: LD_INT 1
5436: ARRAY
5437: PPUSH
5438: CALL_OW 250
5442: PPUSH
5443: LD_INT 22
5445: PUSH
5446: LD_OWVAR 2
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 30
5457: PUSH
5458: LD_INT 1
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PPUSH
5469: CALL_OW 69
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PPUSH
5478: CALL_OW 251
5482: PPUSH
5483: CALL_OW 116
5487: GO 5645
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5489: LD_INT 22
5491: PUSH
5492: LD_OWVAR 2
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 21
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PPUSH
5515: CALL_OW 69
5519: PUSH
5520: LD_INT 0
5522: GREATER
5523: IFFALSE 5616
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5525: LD_VAR 0 17
5529: PPUSH
5530: LD_INT 22
5532: PUSH
5533: LD_OWVAR 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 21
5544: PUSH
5545: LD_INT 3
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PPUSH
5556: CALL_OW 69
5560: PUSH
5561: LD_INT 1
5563: ARRAY
5564: PPUSH
5565: CALL_OW 250
5569: PPUSH
5570: LD_INT 22
5572: PUSH
5573: LD_OWVAR 2
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 21
5584: PUSH
5585: LD_INT 3
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PPUSH
5596: CALL_OW 69
5600: PUSH
5601: LD_INT 1
5603: ARRAY
5604: PPUSH
5605: CALL_OW 251
5609: PPUSH
5610: CALL_OW 116
5614: GO 5645
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5616: LD_VAR 0 17
5620: PPUSH
5621: LD_EXP 10
5625: PPUSH
5626: CALL_OW 250
5630: PPUSH
5631: LD_EXP 10
5635: PPUSH
5636: CALL_OW 251
5640: PPUSH
5641: CALL_OW 116
// end ; if ru_can_attack then
5645: LD_EXP 3
5649: IFFALSE 5797
// if ru_time > 0 0$00 then
5651: LD_EXP 29
5655: PUSH
5656: LD_INT 0
5658: GREATER
5659: IFFALSE 5677
// ru_time := ru_time - 0 0$01 else
5661: LD_ADDR_EXP 29
5665: PUSH
5666: LD_EXP 29
5670: PUSH
5671: LD_INT 35
5673: MINUS
5674: ST_TO_ADDR
5675: GO 5797
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5677: LD_ADDR_EXP 29
5681: PUSH
5682: LD_INT 20265
5684: PPUSH
5685: LD_INT 30765
5687: PPUSH
5688: CALL_OW 12
5692: ST_TO_ADDR
// for i = 1 to ru_amount do
5693: LD_ADDR_VAR 0 12
5697: PUSH
5698: DOUBLE
5699: LD_INT 1
5701: DEC
5702: ST_TO_ADDR
5703: LD_EXP 28
5707: PUSH
5708: FOR_TO
5709: IFFALSE 5795
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5711: LD_ADDR_EXP 27
5715: PUSH
5716: LD_EXP 27
5720: PUSH
5721: LD_INT 23
5723: ADD
5724: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5725: LD_ADDR_EXP 27
5729: PUSH
5730: LD_EXP 27
5734: PUSH
5735: LD_INT 3
5737: ADD
5738: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5739: LD_ADDR_EXP 27
5743: PUSH
5744: LD_EXP 27
5748: PUSH
5749: LD_INT 3
5751: ADD
5752: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5753: LD_ADDR_EXP 27
5757: PUSH
5758: LD_EXP 27
5762: PUSH
5763: LD_INT 46
5765: PUSH
5766: LD_INT 45
5768: PUSH
5769: LD_INT 47
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 1
5779: PPUSH
5780: LD_INT 2
5782: PPUSH
5783: LD_INT 3
5785: PPUSH
5786: CALL_OW 14
5790: ARRAY
5791: ADD
5792: ST_TO_ADDR
// end ;
5793: GO 5708
5795: POP
5796: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5797: LD_VAR 0 4
5801: PPUSH
5802: LD_INT 35
5804: PUSH
5805: LD_INT 0
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: PPUSH
5812: CALL_OW 72
5816: PUSH
5817: LD_INT 0
5819: GREATER
5820: IFFALSE 5868
// if BuildingStatus ( ru_factory ) = bs_idle then
5822: LD_VAR 0 2
5826: PPUSH
5827: CALL_OW 461
5831: PUSH
5832: LD_INT 2
5834: EQUAL
5835: IFFALSE 5868
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5837: LD_VAR 0 4
5841: PPUSH
5842: LD_INT 35
5844: PUSH
5845: LD_INT 0
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 72
5856: PUSH
5857: LD_INT 1
5859: ARRAY
5860: PPUSH
5861: LD_INT 47
5863: PPUSH
5864: CALL_OW 148
// if ru_force = ru_amount then
5868: LD_EXP 23
5872: PUSH
5873: LD_EXP 28
5877: EQUAL
5878: IFFALSE 6010
// begin for i = 1 to ru_force do
5880: LD_ADDR_VAR 0 12
5884: PUSH
5885: DOUBLE
5886: LD_INT 1
5888: DEC
5889: ST_TO_ADDR
5890: LD_EXP 23
5894: PUSH
5895: FOR_TO
5896: IFFALSE 6006
// if IsInArea ( ru_force [ i ] , ru_base ) then
5898: LD_EXP 23
5902: PUSH
5903: LD_VAR 0 12
5907: ARRAY
5908: PPUSH
5909: LD_INT 9
5911: PPUSH
5912: CALL_OW 308
5916: IFFALSE 5940
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5918: LD_EXP 23
5922: PUSH
5923: LD_VAR 0 12
5927: ARRAY
5928: PPUSH
5929: LD_VAR 0 3
5933: PPUSH
5934: CALL_OW 120
5938: GO 6004
// if not HasTask ( ru_force [ i ] ) then
5940: LD_EXP 23
5944: PUSH
5945: LD_VAR 0 12
5949: ARRAY
5950: PPUSH
5951: CALL_OW 314
5955: NOT
5956: IFFALSE 6004
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5958: LD_EXP 23
5962: PUSH
5963: LD_VAR 0 12
5967: ARRAY
5968: PPUSH
5969: LD_INT 81
5971: PUSH
5972: LD_INT 3
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PPUSH
5979: CALL_OW 69
5983: PPUSH
5984: LD_EXP 23
5988: PUSH
5989: LD_VAR 0 12
5993: ARRAY
5994: PPUSH
5995: CALL_OW 74
5999: PPUSH
6000: CALL_OW 115
6004: GO 5895
6006: POP
6007: POP
// end else
6008: GO 6160
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6010: LD_EXP 23
6014: PPUSH
6015: LD_INT 3
6017: PUSH
6018: LD_INT 95
6020: PUSH
6021: LD_INT 18
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PPUSH
6032: CALL_OW 72
6036: PUSH
6037: LD_INT 0
6039: GREATER
6040: IFFALSE 6160
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6042: LD_ADDR_VAR 0 13
6046: PUSH
6047: LD_EXP 23
6051: PPUSH
6052: LD_INT 3
6054: PUSH
6055: LD_INT 95
6057: PUSH
6058: LD_INT 18
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i = 1 to tmp do
6074: LD_ADDR_VAR 0 12
6078: PUSH
6079: DOUBLE
6080: LD_INT 1
6082: DEC
6083: ST_TO_ADDR
6084: LD_VAR 0 13
6088: PUSH
6089: FOR_TO
6090: IFFALSE 6158
// if not HasTask ( tmp [ i ] ) then
6092: LD_VAR 0 13
6096: PUSH
6097: LD_VAR 0 12
6101: ARRAY
6102: PPUSH
6103: CALL_OW 314
6107: NOT
6108: IFFALSE 6156
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6110: LD_EXP 23
6114: PUSH
6115: LD_VAR 0 12
6119: ARRAY
6120: PPUSH
6121: LD_INT 81
6123: PUSH
6124: LD_INT 3
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PPUSH
6131: CALL_OW 69
6135: PPUSH
6136: LD_EXP 23
6140: PUSH
6141: LD_VAR 0 12
6145: ARRAY
6146: PPUSH
6147: CALL_OW 74
6151: PPUSH
6152: CALL_OW 115
6156: GO 6089
6158: POP
6159: POP
// end ; if ru_engs > 0 then
6160: LD_VAR 0 9
6164: PUSH
6165: LD_INT 0
6167: GREATER
6168: IFFALSE 6570
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6170: LD_VAR 0 5
6174: PPUSH
6175: LD_INT 3
6177: PUSH
6178: LD_INT 24
6180: PUSH
6181: LD_INT 1000
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PPUSH
6192: CALL_OW 72
6196: PUSH
6197: LD_INT 0
6199: GREATER
6200: IFFALSE 6355
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6202: LD_ADDR_VAR 0 14
6206: PUSH
6207: LD_VAR 0 5
6211: PPUSH
6212: LD_INT 3
6214: PUSH
6215: LD_INT 24
6217: PUSH
6218: LD_INT 1000
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PPUSH
6229: CALL_OW 72
6233: ST_TO_ADDR
// for i = 1 to ru_engs do
6234: LD_ADDR_VAR 0 12
6238: PUSH
6239: DOUBLE
6240: LD_INT 1
6242: DEC
6243: ST_TO_ADDR
6244: LD_VAR 0 9
6248: PUSH
6249: FOR_TO
6250: IFFALSE 6351
// begin if IsInUnit ( ru_engs [ i ] ) then
6252: LD_VAR 0 9
6256: PUSH
6257: LD_VAR 0 12
6261: ARRAY
6262: PPUSH
6263: CALL_OW 310
6267: IFFALSE 6286
// ComExitBuilding ( ru_engs [ i ] ) else
6269: LD_VAR 0 9
6273: PUSH
6274: LD_VAR 0 12
6278: ARRAY
6279: PPUSH
6280: CALL_OW 122
6284: GO 6349
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6286: LD_VAR 0 9
6290: PUSH
6291: LD_VAR 0 12
6295: ARRAY
6296: PPUSH
6297: CALL_OW 314
6301: NOT
6302: PUSH
6303: LD_VAR 0 9
6307: PUSH
6308: LD_VAR 0 12
6312: ARRAY
6313: PPUSH
6314: CALL_OW 256
6318: PUSH
6319: LD_INT 600
6321: GREATER
6322: AND
6323: IFFALSE 6349
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6325: LD_VAR 0 9
6329: PUSH
6330: LD_VAR 0 12
6334: ARRAY
6335: PPUSH
6336: LD_VAR 0 14
6340: PUSH
6341: LD_INT 1
6343: ARRAY
6344: PPUSH
6345: CALL_OW 130
// end ;
6349: GO 6249
6351: POP
6352: POP
// end else
6353: GO 6570
// begin if ru_blist = 0 then
6355: LD_EXP 26
6359: PUSH
6360: LD_INT 0
6362: EQUAL
6363: IFFALSE 6445
// begin for i = 1 to ru_engs do
6365: LD_ADDR_VAR 0 12
6369: PUSH
6370: DOUBLE
6371: LD_INT 1
6373: DEC
6374: ST_TO_ADDR
6375: LD_VAR 0 9
6379: PUSH
6380: FOR_TO
6381: IFFALSE 6441
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6383: LD_VAR 0 9
6387: PUSH
6388: LD_VAR 0 12
6392: ARRAY
6393: PPUSH
6394: CALL_OW 314
6398: NOT
6399: PUSH
6400: LD_VAR 0 9
6404: PUSH
6405: LD_VAR 0 12
6409: ARRAY
6410: PPUSH
6411: CALL_OW 310
6415: NOT
6416: AND
6417: IFFALSE 6439
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6419: LD_VAR 0 9
6423: PUSH
6424: LD_VAR 0 12
6428: ARRAY
6429: PPUSH
6430: LD_VAR 0 1
6434: PPUSH
6435: CALL_OW 120
6439: GO 6380
6441: POP
6442: POP
// end else
6443: GO 6570
// begin for i = 1 to ru_engs do
6445: LD_ADDR_VAR 0 12
6449: PUSH
6450: DOUBLE
6451: LD_INT 1
6453: DEC
6454: ST_TO_ADDR
6455: LD_VAR 0 9
6459: PUSH
6460: FOR_TO
6461: IFFALSE 6568
// begin if IsInUnit ( ru_engs [ i ] ) then
6463: LD_VAR 0 9
6467: PUSH
6468: LD_VAR 0 12
6472: ARRAY
6473: PPUSH
6474: CALL_OW 310
6478: IFFALSE 6497
// ComExitBuilding ( ru_engs [ i ] ) else
6480: LD_VAR 0 9
6484: PUSH
6485: LD_VAR 0 12
6489: ARRAY
6490: PPUSH
6491: CALL_OW 122
6495: GO 6566
// if not HasTask ( ru_engs [ i ] ) then
6497: LD_VAR 0 9
6501: PUSH
6502: LD_VAR 0 12
6506: ARRAY
6507: PPUSH
6508: CALL_OW 314
6512: NOT
6513: IFFALSE 6566
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6515: LD_VAR 0 9
6519: PUSH
6520: LD_VAR 0 12
6524: ARRAY
6525: PPUSH
6526: LD_EXP 26
6530: PUSH
6531: LD_INT 1
6533: ARRAY
6534: PPUSH
6535: LD_EXP 26
6539: PUSH
6540: LD_INT 2
6542: ARRAY
6543: PPUSH
6544: LD_EXP 26
6548: PUSH
6549: LD_INT 3
6551: ARRAY
6552: PPUSH
6553: LD_EXP 26
6557: PUSH
6558: LD_INT 4
6560: ARRAY
6561: PPUSH
6562: CALL_OW 145
// end ;
6566: GO 6460
6568: POP
6569: POP
// end ; end ; end ; end ;
6570: PPOPN 17
6572: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6573: LD_EXP 2
6577: PUSH
6578: LD_INT 11
6580: PPUSH
6581: CALL_OW 435
6585: PUSH
6586: LD_INT 20
6588: LESS
6589: AND
6590: IFFALSE 6653
6592: GO 6594
6594: DISABLE
// begin enable ;
6595: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6596: LD_INT 1
6598: PPUSH
6599: LD_INT 5
6601: PPUSH
6602: CALL_OW 12
6606: PPUSH
6607: LD_INT 11
6609: PPUSH
6610: LD_INT 1
6612: PPUSH
6613: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6617: LD_INT 1505
6619: PPUSH
6620: LD_INT 2100
6622: PPUSH
6623: CALL_OW 12
6627: PPUSH
6628: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 5
6637: PPUSH
6638: CALL_OW 12
6642: PPUSH
6643: LD_INT 11
6645: PPUSH
6646: LD_INT 1
6648: PPUSH
6649: CALL_OW 55
// end ;
6653: END
// every 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6654: LD_EXP 4
6658: PUSH
6659: LD_INT 0
6661: EQUAL
6662: IFFALSE 6777
6664: GO 6666
6666: DISABLE
6667: LD_INT 0
6669: PPUSH
6670: PPUSH
// begin enable ;
6671: ENABLE
// i := Rand ( 0 , 100 ) ;
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: LD_INT 0
6679: PPUSH
6680: LD_INT 100
6682: PPUSH
6683: CALL_OW 12
6687: ST_TO_ADDR
// case your_side of 1 :
6688: LD_OWVAR 2
6692: PUSH
6693: LD_INT 1
6695: DOUBLE
6696: EQUAL
6697: IFTRUE 6701
6699: GO 6712
6701: POP
// tmp := 10 ; 2 :
6702: LD_ADDR_VAR 0 2
6706: PUSH
6707: LD_INT 10
6709: ST_TO_ADDR
6710: GO 6751
6712: LD_INT 2
6714: DOUBLE
6715: EQUAL
6716: IFTRUE 6720
6718: GO 6731
6720: POP
// tmp := 0 ; 7 :
6721: LD_ADDR_VAR 0 2
6725: PUSH
6726: LD_INT 0
6728: ST_TO_ADDR
6729: GO 6751
6731: LD_INT 7
6733: DOUBLE
6734: EQUAL
6735: IFTRUE 6739
6737: GO 6750
6739: POP
// tmp := 15 ; end ;
6740: LD_ADDR_VAR 0 2
6744: PUSH
6745: LD_INT 15
6747: ST_TO_ADDR
6748: GO 6751
6750: POP
// if i < chance_to_bomb + tmp then
6751: LD_VAR 0 1
6755: PUSH
6756: LD_EXP 5
6760: PUSH
6761: LD_VAR 0 2
6765: PLUS
6766: LESS
6767: IFFALSE 6777
// ru_sib_bomb := true ;
6769: LD_ADDR_EXP 4
6773: PUSH
6774: LD_INT 1
6776: ST_TO_ADDR
// end ;
6777: PPOPN 2
6779: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6780: LD_INT 22
6782: PUSH
6783: LD_OWVAR 2
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 34
6794: PUSH
6795: LD_INT 8
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: IFFALSE 6823
6812: GO 6814
6814: DISABLE
// begin ru_sib_bomb := true ;
6815: LD_ADDR_EXP 4
6819: PUSH
6820: LD_INT 1
6822: ST_TO_ADDR
// end ;
6823: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6824: LD_INT 22
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: PUSH
6834: LD_INT 30
6836: PUSH
6837: LD_INT 34
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL_OW 69
6852: IFFALSE 6951
6854: GO 6856
6856: DISABLE
6857: LD_INT 0
6859: PPUSH
// begin enable ;
6860: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6861: LD_ADDR_VAR 0 1
6865: PUSH
6866: LD_INT 1
6868: PUSH
6869: LD_INT 3
6871: PUSH
6872: EMPTY
6873: LIST
6874: LIST
6875: PUSH
6876: LD_INT 1
6878: PPUSH
6879: LD_INT 2
6881: PPUSH
6882: CALL_OW 12
6886: ARRAY
6887: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6888: LD_INT 22
6890: PUSH
6891: LD_INT 3
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 34
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PPUSH
6912: CALL_OW 69
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: LD_EXP 30
6925: PUSH
6926: LD_VAR 0 1
6930: ARRAY
6931: PPUSH
6932: LD_EXP 30
6936: PUSH
6937: LD_VAR 0 1
6941: PUSH
6942: LD_INT 1
6944: PLUS
6945: ARRAY
6946: PPUSH
6947: CALL_OW 243
// end ; end_of_file
6951: PPOPN 1
6953: END
// export function RemoveLegion ; var i ; begin
6954: LD_INT 0
6956: PPUSH
6957: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6958: LD_ADDR_VAR 0 2
6962: PUSH
6963: LD_INT 22
6965: PUSH
6966: LD_INT 8
6968: PUSH
6969: EMPTY
6970: LIST
6971: LIST
6972: PPUSH
6973: CALL_OW 69
6977: PUSH
6978: FOR_IN
6979: IFFALSE 6992
// RemoveUnit ( i ) ;
6981: LD_VAR 0 2
6985: PPUSH
6986: CALL_OW 64
6990: GO 6978
6992: POP
6993: POP
// end ;
6994: LD_VAR 0 1
6998: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
6999: LD_INT 0
7001: PPUSH
7002: PPUSH
7003: PPUSH
7004: PPUSH
7005: PPUSH
7006: PPUSH
7007: PPUSH
7008: PPUSH
7009: PPUSH
7010: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7011: LD_ADDR_VAR 0 7
7015: PUSH
7016: LD_INT 22
7018: PUSH
7019: LD_INT 8
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 30
7028: PUSH
7029: LD_INT 1
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PPUSH
7040: CALL_OW 69
7044: PUSH
7045: LD_INT 1
7047: ARRAY
7048: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7049: LD_ADDR_VAR 0 8
7053: PUSH
7054: LD_INT 22
7056: PUSH
7057: LD_INT 8
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 30
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PPUSH
7078: CALL_OW 69
7082: PUSH
7083: LD_INT 1
7085: ARRAY
7086: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7087: LD_ADDR_VAR 0 9
7091: PUSH
7092: LD_INT 22
7094: PUSH
7095: LD_INT 8
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: PUSH
7102: LD_INT 2
7104: PUSH
7105: LD_INT 30
7107: PUSH
7108: LD_INT 6
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: LD_INT 30
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PPUSH
7134: CALL_OW 69
7138: PUSH
7139: LD_INT 1
7141: ARRAY
7142: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7143: LD_ADDR_VAR 0 10
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 8
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: LD_INT 30
7160: PUSH
7161: LD_INT 32
7163: PUSH
7164: EMPTY
7165: LIST
7166: LIST
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PPUSH
7172: CALL_OW 69
7176: ST_TO_ADDR
// uc_side := 8 ;
7177: LD_ADDR_OWVAR 20
7181: PUSH
7182: LD_INT 8
7184: ST_TO_ADDR
// uc_nation := nation_arabian ;
7185: LD_ADDR_OWVAR 21
7189: PUSH
7190: LD_INT 2
7192: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7193: LD_ADDR_EXP 32
7197: PUSH
7198: LD_INT 5
7200: PUSH
7201: LD_INT 6
7203: PUSH
7204: LD_INT 7
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_OWVAR 67
7216: ARRAY
7217: ST_TO_ADDR
// legion_blist := [ ] ;
7218: LD_ADDR_EXP 34
7222: PUSH
7223: EMPTY
7224: ST_TO_ADDR
// legion_vlist := [ ] ;
7225: LD_ADDR_EXP 35
7229: PUSH
7230: EMPTY
7231: ST_TO_ADDR
// legion_force := [ ] ;
7232: LD_ADDR_EXP 31
7236: PUSH
7237: EMPTY
7238: ST_TO_ADDR
// legion_enemy := - 1 ;
7239: LD_ADDR_EXP 36
7243: PUSH
7244: LD_INT 1
7246: NEG
7247: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7248: LD_VAR 0 7
7252: PPUSH
7253: CALL_OW 274
7257: PPUSH
7258: LD_INT 1
7260: PPUSH
7261: LD_INT 10000
7263: PPUSH
7264: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7268: LD_VAR 0 7
7272: PPUSH
7273: CALL_OW 274
7277: PPUSH
7278: LD_INT 3
7280: PPUSH
7281: LD_INT 1000
7283: PPUSH
7284: CALL_OW 277
// for i = 1 to l_towers do
7288: LD_ADDR_VAR 0 3
7292: PUSH
7293: DOUBLE
7294: LD_INT 1
7296: DEC
7297: ST_TO_ADDR
7298: LD_VAR 0 10
7302: PUSH
7303: FOR_TO
7304: IFFALSE 7353
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7306: LD_INT 0
7308: PPUSH
7309: LD_INT 1
7311: PPUSH
7312: LD_EXP 32
7316: PPUSH
7317: CALL_OW 380
// un := CreateHuman ;
7321: LD_ADDR_VAR 0 2
7325: PUSH
7326: CALL_OW 44
7330: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7331: LD_VAR 0 2
7335: PPUSH
7336: LD_VAR 0 10
7340: PUSH
7341: LD_VAR 0 3
7345: ARRAY
7346: PPUSH
7347: CALL_OW 52
// end ;
7351: GO 7303
7353: POP
7354: POP
// for i = 1 to 4 do
7355: LD_ADDR_VAR 0 3
7359: PUSH
7360: DOUBLE
7361: LD_INT 1
7363: DEC
7364: ST_TO_ADDR
7365: LD_INT 4
7367: PUSH
7368: FOR_TO
7369: IFFALSE 7462
// for p = 1 to 2 do
7371: LD_ADDR_VAR 0 6
7375: PUSH
7376: DOUBLE
7377: LD_INT 1
7379: DEC
7380: ST_TO_ADDR
7381: LD_INT 2
7383: PUSH
7384: FOR_TO
7385: IFFALSE 7458
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7387: LD_INT 0
7389: PPUSH
7390: LD_INT 8
7392: PPUSH
7393: LD_EXP 32
7397: PPUSH
7398: CALL_OW 380
// un := CreateHuman ;
7402: LD_ADDR_VAR 0 2
7406: PUSH
7407: CALL_OW 44
7411: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7412: LD_VAR 0 2
7416: PPUSH
7417: LD_INT 22
7419: PUSH
7420: LD_INT 8
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: LD_INT 30
7429: PUSH
7430: LD_INT 5
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PPUSH
7441: CALL_OW 69
7445: PUSH
7446: LD_VAR 0 6
7450: ARRAY
7451: PPUSH
7452: CALL_OW 52
// end ;
7456: GO 7384
7458: POP
7459: POP
7460: GO 7368
7462: POP
7463: POP
// for i = 1 to 4 do
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: DOUBLE
7470: LD_INT 1
7472: DEC
7473: ST_TO_ADDR
7474: LD_INT 4
7476: PUSH
7477: FOR_TO
7478: IFFALSE 7521
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7480: LD_INT 0
7482: PPUSH
7483: LD_INT 4
7485: PPUSH
7486: LD_EXP 32
7490: PPUSH
7491: CALL_OW 380
// un := CreateHuman ;
7495: LD_ADDR_VAR 0 2
7499: PUSH
7500: CALL_OW 44
7504: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7505: LD_VAR 0 2
7509: PPUSH
7510: LD_VAR 0 9
7514: PPUSH
7515: CALL_OW 52
// end ;
7519: GO 7477
7521: POP
7522: POP
// for i = 1 to 6 do
7523: LD_ADDR_VAR 0 3
7527: PUSH
7528: DOUBLE
7529: LD_INT 1
7531: DEC
7532: ST_TO_ADDR
7533: LD_INT 6
7535: PUSH
7536: FOR_TO
7537: IFFALSE 7580
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7539: LD_INT 0
7541: PPUSH
7542: LD_INT 3
7544: PPUSH
7545: LD_EXP 32
7549: PPUSH
7550: CALL_OW 380
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 2
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7564: LD_VAR 0 2
7568: PPUSH
7569: LD_VAR 0 8
7573: PPUSH
7574: CALL_OW 52
// end ;
7578: GO 7536
7580: POP
7581: POP
// for i = 1 to 5 do
7582: LD_ADDR_VAR 0 3
7586: PUSH
7587: DOUBLE
7588: LD_INT 1
7590: DEC
7591: ST_TO_ADDR
7592: LD_INT 5
7594: PUSH
7595: FOR_TO
7596: IFFALSE 7639
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7598: LD_INT 0
7600: PPUSH
7601: LD_INT 2
7603: PPUSH
7604: LD_EXP 32
7608: PPUSH
7609: CALL_OW 380
// un := CreateHuman ;
7613: LD_ADDR_VAR 0 2
7617: PUSH
7618: CALL_OW 44
7622: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7623: LD_VAR 0 2
7627: PPUSH
7628: LD_VAR 0 7
7632: PPUSH
7633: CALL_OW 52
// end ;
7637: GO 7595
7639: POP
7640: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7641: LD_ADDR_VAR 0 4
7645: PUSH
7646: LD_INT 199
7648: PPUSH
7649: LD_INT 134
7651: PPUSH
7652: LD_INT 216
7654: PPUSH
7655: LD_INT 141
7657: PPUSH
7658: LD_INT 6
7660: PPUSH
7661: CALL 1555 0 5
7665: ST_TO_ADDR
// p := 1 ;
7666: LD_ADDR_VAR 0 6
7670: PUSH
7671: LD_INT 1
7673: ST_TO_ADDR
// for i = 1 to 3 do
7674: LD_ADDR_VAR 0 3
7678: PUSH
7679: DOUBLE
7680: LD_INT 1
7682: DEC
7683: ST_TO_ADDR
7684: LD_INT 3
7686: PUSH
7687: FOR_TO
7688: IFFALSE 7941
// begin vc_chassis := ar_half_tracked ;
7690: LD_ADDR_OWVAR 37
7694: PUSH
7695: LD_INT 14
7697: ST_TO_ADDR
// vc_engine := engine_siberite ;
7698: LD_ADDR_OWVAR 39
7702: PUSH
7703: LD_INT 3
7705: ST_TO_ADDR
// vc_control := control_manual ;
7706: LD_ADDR_OWVAR 38
7710: PUSH
7711: LD_INT 1
7713: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7714: LD_ADDR_OWVAR 40
7718: PUSH
7719: LD_INT 31
7721: ST_TO_ADDR
// veh := CreateVehicle ;
7722: LD_ADDR_VAR 0 5
7726: PUSH
7727: CALL_OW 45
7731: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7732: LD_VAR 0 4
7736: PUSH
7737: LD_VAR 0 6
7741: ARRAY
7742: PPUSH
7743: LD_VAR 0 4
7747: PUSH
7748: LD_VAR 0 6
7752: PUSH
7753: LD_INT 1
7755: PLUS
7756: ARRAY
7757: PPUSH
7758: CALL_OW 428
7762: PUSH
7763: LD_INT 0
7765: EQUAL
7766: IFFALSE 7808
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7768: LD_VAR 0 5
7772: PPUSH
7773: LD_VAR 0 4
7777: PUSH
7778: LD_VAR 0 6
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 6
7793: PUSH
7794: LD_INT 1
7796: PLUS
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 48
7806: GO 7896
// begin repeat p := p + 2 ;
7808: LD_ADDR_VAR 0 6
7812: PUSH
7813: LD_VAR 0 6
7817: PUSH
7818: LD_INT 2
7820: PLUS
7821: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7822: LD_VAR 0 4
7826: PUSH
7827: LD_VAR 0 6
7831: ARRAY
7832: PPUSH
7833: LD_VAR 0 4
7837: PUSH
7838: LD_VAR 0 6
7842: PUSH
7843: LD_INT 1
7845: PLUS
7846: ARRAY
7847: PPUSH
7848: CALL_OW 428
7852: PUSH
7853: LD_INT 0
7855: EQUAL
7856: IFFALSE 7808
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7858: LD_VAR 0 5
7862: PPUSH
7863: LD_VAR 0 4
7867: PUSH
7868: LD_VAR 0 6
7872: ARRAY
7873: PPUSH
7874: LD_VAR 0 4
7878: PUSH
7879: LD_VAR 0 6
7883: PUSH
7884: LD_INT 1
7886: PLUS
7887: ARRAY
7888: PPUSH
7889: LD_INT 0
7891: PPUSH
7892: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 3
7901: PPUSH
7902: LD_EXP 32
7906: PUSH
7907: LD_INT 1
7909: PLUS
7910: PPUSH
7911: CALL_OW 380
// un := CreateHuman ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: CALL_OW 44
7924: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7925: LD_VAR 0 2
7929: PPUSH
7930: LD_VAR 0 5
7934: PPUSH
7935: CALL_OW 52
// end ;
7939: GO 7687
7941: POP
7942: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7943: LD_INT 198
7945: PPUSH
7946: LD_INT 94
7948: PPUSH
7949: LD_INT 8
7951: PPUSH
7952: LD_INT 10
7954: PPUSH
7955: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7959: LD_INT 167
7961: PPUSH
7962: LD_INT 130
7964: PPUSH
7965: LD_INT 8
7967: PPUSH
7968: LD_INT 10
7970: PPUSH
7971: CALL_OW 330
// legion_mines := [ ] ;
7975: LD_ADDR_EXP 33
7979: PUSH
7980: EMPTY
7981: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
7982: LD_ADDR_EXP 33
7986: PUSH
7987: LD_INT 176
7989: PPUSH
7990: LD_INT 122
7992: PPUSH
7993: LD_INT 188
7995: PPUSH
7996: LD_INT 126
7998: PPUSH
7999: LD_INT 6
8001: PPUSH
8002: CALL 1555 0 5
8006: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8007: LD_ADDR_EXP 33
8011: PUSH
8012: LD_EXP 33
8016: PUSH
8017: LD_INT 197
8019: PPUSH
8020: LD_INT 91
8022: PPUSH
8023: LD_INT 205
8025: PPUSH
8026: LD_INT 96
8028: PPUSH
8029: LD_INT 4
8031: PPUSH
8032: CALL 1555 0 5
8036: ADD
8037: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8038: LD_ADDR_EXP 33
8042: PUSH
8043: LD_EXP 33
8047: PUSH
8048: LD_INT 184
8050: PPUSH
8051: LD_INT 151
8053: PPUSH
8054: LD_INT 178
8056: PPUSH
8057: LD_INT 130
8059: PPUSH
8060: LD_INT 9
8062: PPUSH
8063: CALL 1555 0 5
8067: ADD
8068: ST_TO_ADDR
// if Difficulty > 1 then
8069: LD_OWVAR 67
8073: PUSH
8074: LD_INT 1
8076: GREATER
8077: IFFALSE 8110
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8079: LD_ADDR_EXP 33
8083: PUSH
8084: LD_EXP 33
8088: PUSH
8089: LD_INT 166
8091: PPUSH
8092: LD_INT 126
8094: PPUSH
8095: LD_INT 181
8097: PPUSH
8098: LD_INT 136
8100: PPUSH
8101: LD_INT 5
8103: PPUSH
8104: CALL 1555 0 5
8108: ADD
8109: ST_TO_ADDR
// p := 1 ;
8110: LD_ADDR_VAR 0 6
8114: PUSH
8115: LD_INT 1
8117: ST_TO_ADDR
// for i = 1 to 24 do
8118: LD_ADDR_VAR 0 3
8122: PUSH
8123: DOUBLE
8124: LD_INT 1
8126: DEC
8127: ST_TO_ADDR
8128: LD_INT 24
8130: PUSH
8131: FOR_TO
8132: IFFALSE 8186
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8134: LD_EXP 33
8138: PUSH
8139: LD_VAR 0 6
8143: ARRAY
8144: PPUSH
8145: LD_EXP 33
8149: PUSH
8150: LD_VAR 0 6
8154: PUSH
8155: LD_INT 1
8157: PLUS
8158: ARRAY
8159: PPUSH
8160: LD_INT 8
8162: PPUSH
8163: LD_INT 0
8165: PPUSH
8166: CALL_OW 454
// p := p + 2 ;
8170: LD_ADDR_VAR 0 6
8174: PUSH
8175: LD_VAR 0 6
8179: PUSH
8180: LD_INT 2
8182: PLUS
8183: ST_TO_ADDR
// end ;
8184: GO 8131
8186: POP
8187: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8188: LD_ADDR_EXP 35
8192: PUSH
8193: LD_INT 13
8195: PUSH
8196: LD_INT 3
8198: PUSH
8199: LD_INT 2
8201: PUSH
8202: LD_INT 32
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: ST_TO_ADDR
// end ;
8211: LD_VAR 0 1
8215: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8216: LD_INT 22
8218: PUSH
8219: LD_INT 8
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: PPUSH
8226: CALL_OW 69
8230: PUSH
8231: LD_INT 0
8233: GREATER
8234: IFFALSE 10420
8236: GO 8238
8238: DISABLE
8239: LD_INT 0
8241: PPUSH
8242: PPUSH
8243: PPUSH
8244: PPUSH
8245: PPUSH
8246: PPUSH
8247: PPUSH
8248: PPUSH
8249: PPUSH
8250: PPUSH
8251: PPUSH
8252: PPUSH
8253: PPUSH
8254: PPUSH
8255: PPUSH
8256: PPUSH
8257: PPUSH
// begin enable ;
8258: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8259: LD_ADDR_VAR 0 8
8263: PUSH
8264: LD_INT 22
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PUSH
8274: LD_INT 30
8276: PUSH
8277: LD_INT 1
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PPUSH
8288: CALL_OW 69
8292: PUSH
8293: LD_INT 1
8295: ARRAY
8296: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8297: LD_ADDR_VAR 0 9
8301: PUSH
8302: LD_INT 22
8304: PUSH
8305: LD_INT 8
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PUSH
8312: LD_INT 30
8314: PUSH
8315: LD_INT 3
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 69
8330: PUSH
8331: LD_INT 1
8333: ARRAY
8334: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8335: LD_ADDR_VAR 0 10
8339: PUSH
8340: LD_INT 22
8342: PUSH
8343: LD_INT 8
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: PUSH
8350: LD_INT 2
8352: PUSH
8353: LD_INT 30
8355: PUSH
8356: LD_INT 6
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: PUSH
8363: LD_INT 30
8365: PUSH
8366: LD_INT 8
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: LIST
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PPUSH
8382: CALL_OW 69
8386: PUSH
8387: LD_INT 1
8389: ARRAY
8390: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8391: LD_ADDR_VAR 0 11
8395: PUSH
8396: LD_INT 22
8398: PUSH
8399: LD_INT 8
8401: PUSH
8402: EMPTY
8403: LIST
8404: LIST
8405: PUSH
8406: LD_INT 30
8408: PUSH
8409: LD_INT 32
8411: PUSH
8412: EMPTY
8413: LIST
8414: LIST
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8425: LD_ADDR_VAR 0 16
8429: PUSH
8430: LD_INT 22
8432: PUSH
8433: LD_INT 8
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: PUSH
8440: LD_INT 25
8442: PUSH
8443: LD_INT 2
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8459: LD_ADDR_VAR 0 15
8463: PUSH
8464: LD_INT 22
8466: PUSH
8467: LD_INT 8
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: LD_INT 25
8476: PUSH
8477: LD_INT 1
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8493: LD_ADDR_VAR 0 14
8497: PUSH
8498: LD_INT 22
8500: PUSH
8501: LD_INT 8
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PUSH
8508: LD_INT 25
8510: PUSH
8511: LD_INT 3
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8527: LD_ADDR_VAR 0 13
8531: PUSH
8532: LD_INT 22
8534: PUSH
8535: LD_INT 8
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 25
8544: PUSH
8545: LD_INT 4
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if l_eng then
8561: LD_VAR 0 16
8565: IFFALSE 8980
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8567: LD_ADDR_VAR 0 5
8571: PUSH
8572: LD_INT 22
8574: PUSH
8575: LD_INT 8
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 21
8584: PUSH
8585: LD_INT 3
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PPUSH
8596: CALL_OW 69
8600: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8601: LD_VAR 0 5
8605: PPUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 24
8611: PUSH
8612: LD_INT 1000
8614: PUSH
8615: EMPTY
8616: LIST
8617: LIST
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PPUSH
8623: CALL_OW 72
8627: PUSH
8628: LD_INT 0
8630: GREATER
8631: IFFALSE 8765
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8633: LD_ADDR_VAR 0 3
8637: PUSH
8638: LD_VAR 0 5
8642: PPUSH
8643: LD_INT 3
8645: PUSH
8646: LD_INT 24
8648: PUSH
8649: LD_INT 1000
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 72
8664: ST_TO_ADDR
// for i = 1 to l_eng do
8665: LD_ADDR_VAR 0 2
8669: PUSH
8670: DOUBLE
8671: LD_INT 1
8673: DEC
8674: ST_TO_ADDR
8675: LD_VAR 0 16
8679: PUSH
8680: FOR_TO
8681: IFFALSE 8761
// if IsInUnit ( l_eng [ i ] ) then
8683: LD_VAR 0 16
8687: PUSH
8688: LD_VAR 0 2
8692: ARRAY
8693: PPUSH
8694: CALL_OW 310
8698: IFFALSE 8717
// ComExitBuilding ( l_eng [ i ] ) else
8700: LD_VAR 0 16
8704: PUSH
8705: LD_VAR 0 2
8709: ARRAY
8710: PPUSH
8711: CALL_OW 122
8715: GO 8759
// if not HasTask ( l_eng [ i ] ) then
8717: LD_VAR 0 16
8721: PUSH
8722: LD_VAR 0 2
8726: ARRAY
8727: PPUSH
8728: CALL_OW 314
8732: NOT
8733: IFFALSE 8759
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8735: LD_VAR 0 16
8739: PUSH
8740: LD_VAR 0 2
8744: ARRAY
8745: PPUSH
8746: LD_VAR 0 3
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: CALL_OW 130
8759: GO 8680
8761: POP
8762: POP
// end else
8763: GO 8980
// begin if legion_blist > 0 then
8765: LD_EXP 34
8769: PUSH
8770: LD_INT 0
8772: GREATER
8773: IFFALSE 8902
// begin for i = 1 to l_eng do
8775: LD_ADDR_VAR 0 2
8779: PUSH
8780: DOUBLE
8781: LD_INT 1
8783: DEC
8784: ST_TO_ADDR
8785: LD_VAR 0 16
8789: PUSH
8790: FOR_TO
8791: IFFALSE 8898
// if IsInUnit ( l_eng [ i ] ) then
8793: LD_VAR 0 16
8797: PUSH
8798: LD_VAR 0 2
8802: ARRAY
8803: PPUSH
8804: CALL_OW 310
8808: IFFALSE 8827
// ComExitBuilding ( l_eng [ i ] ) else
8810: LD_VAR 0 16
8814: PUSH
8815: LD_VAR 0 2
8819: ARRAY
8820: PPUSH
8821: CALL_OW 122
8825: GO 8896
// if not HasTask ( l_eng [ i ] ) then
8827: LD_VAR 0 16
8831: PUSH
8832: LD_VAR 0 2
8836: ARRAY
8837: PPUSH
8838: CALL_OW 314
8842: NOT
8843: IFFALSE 8896
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8845: LD_VAR 0 16
8849: PUSH
8850: LD_VAR 0 2
8854: ARRAY
8855: PPUSH
8856: LD_EXP 34
8860: PUSH
8861: LD_INT 1
8863: ARRAY
8864: PPUSH
8865: LD_EXP 34
8869: PUSH
8870: LD_INT 2
8872: ARRAY
8873: PPUSH
8874: LD_EXP 34
8878: PUSH
8879: LD_INT 3
8881: ARRAY
8882: PPUSH
8883: LD_EXP 34
8887: PUSH
8888: LD_INT 4
8890: ARRAY
8891: PPUSH
8892: CALL_OW 145
8896: GO 8790
8898: POP
8899: POP
// end else
8900: GO 8980
// for i = 1 to l_eng do
8902: LD_ADDR_VAR 0 2
8906: PUSH
8907: DOUBLE
8908: LD_INT 1
8910: DEC
8911: ST_TO_ADDR
8912: LD_VAR 0 16
8916: PUSH
8917: FOR_TO
8918: IFFALSE 8978
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8920: LD_VAR 0 16
8924: PUSH
8925: LD_VAR 0 2
8929: ARRAY
8930: PPUSH
8931: CALL_OW 310
8935: NOT
8936: PUSH
8937: LD_VAR 0 16
8941: PUSH
8942: LD_VAR 0 2
8946: ARRAY
8947: PPUSH
8948: CALL_OW 314
8952: NOT
8953: AND
8954: IFFALSE 8976
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8956: LD_VAR 0 16
8960: PUSH
8961: LD_VAR 0 2
8965: ARRAY
8966: PPUSH
8967: LD_VAR 0 8
8971: PPUSH
8972: CALL_OW 120
8976: GO 8917
8978: POP
8979: POP
// end ; end ; if l_factory then
8980: LD_VAR 0 9
8984: IFFALSE 9384
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
8986: LD_INT 22
8988: PUSH
8989: LD_INT 8
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: LD_INT 33
8998: PUSH
8999: LD_INT 2
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PUSH
9006: LD_INT 3
9008: PUSH
9009: LD_INT 61
9011: PUSH
9012: EMPTY
9013: LIST
9014: PUSH
9015: EMPTY
9016: LIST
9017: LIST
9018: PUSH
9019: EMPTY
9020: LIST
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 69
9028: PUSH
9029: LD_INT 0
9031: GREATER
9032: PUSH
9033: LD_INT 22
9035: PUSH
9036: LD_INT 8
9038: PUSH
9039: EMPTY
9040: LIST
9041: LIST
9042: PUSH
9043: LD_INT 34
9045: PUSH
9046: LD_INT 31
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: EMPTY
9054: LIST
9055: LIST
9056: PPUSH
9057: CALL_OW 69
9061: PUSH
9062: LD_INT 0
9064: GREATER
9065: AND
9066: IFFALSE 9186
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9068: LD_INT 22
9070: PUSH
9071: LD_INT 8
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 33
9080: PUSH
9081: LD_INT 2
9083: PUSH
9084: EMPTY
9085: LIST
9086: LIST
9087: PUSH
9088: LD_INT 3
9090: PUSH
9091: LD_INT 61
9093: PUSH
9094: EMPTY
9095: LIST
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL_OW 69
9110: PUSH
9111: LD_INT 1
9113: ARRAY
9114: PPUSH
9115: LD_INT 22
9117: PUSH
9118: LD_INT 8
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: LD_INT 34
9127: PUSH
9128: LD_INT 31
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: PUSH
9144: LD_INT 1
9146: PPUSH
9147: LD_INT 22
9149: PUSH
9150: LD_INT 8
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PUSH
9157: LD_INT 34
9159: PUSH
9160: LD_INT 31
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: PPUSH
9171: CALL_OW 69
9175: PPUSH
9176: CALL_OW 12
9180: ARRAY
9181: PPUSH
9182: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9186: LD_EXP 35
9190: PUSH
9191: LD_INT 0
9193: GREATER
9194: PUSH
9195: LD_VAR 0 9
9199: PPUSH
9200: CALL_OW 461
9204: PUSH
9205: LD_INT 2
9207: EQUAL
9208: AND
9209: IFFALSE 9294
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9211: LD_VAR 0 9
9215: PPUSH
9216: LD_EXP 35
9220: PUSH
9221: LD_INT 1
9223: ARRAY
9224: PPUSH
9225: LD_EXP 35
9229: PUSH
9230: LD_INT 2
9232: ARRAY
9233: PPUSH
9234: LD_EXP 35
9238: PUSH
9239: LD_INT 3
9241: ARRAY
9242: PPUSH
9243: LD_EXP 35
9247: PUSH
9248: LD_INT 4
9250: ARRAY
9251: PPUSH
9252: CALL_OW 125
// for i = 1 to 4 do
9256: LD_ADDR_VAR 0 2
9260: PUSH
9261: DOUBLE
9262: LD_INT 1
9264: DEC
9265: ST_TO_ADDR
9266: LD_INT 4
9268: PUSH
9269: FOR_TO
9270: IFFALSE 9292
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9272: LD_ADDR_EXP 35
9276: PUSH
9277: LD_EXP 35
9281: PPUSH
9282: LD_INT 1
9284: PPUSH
9285: CALL_OW 3
9289: ST_TO_ADDR
9290: GO 9269
9292: POP
9293: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9294: LD_VAR 0 11
9298: PPUSH
9299: LD_INT 35
9301: PUSH
9302: LD_INT 0
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 72
9313: PUSH
9314: LD_INT 0
9316: GREATER
9317: PUSH
9318: LD_VAR 0 9
9322: PPUSH
9323: CALL_OW 461
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: AND
9332: IFFALSE 9384
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9334: LD_VAR 0 11
9338: PPUSH
9339: LD_INT 35
9341: PUSH
9342: LD_INT 0
9344: PUSH
9345: EMPTY
9346: LIST
9347: LIST
9348: PPUSH
9349: CALL_OW 72
9353: PUSH
9354: LD_INT 1
9356: ARRAY
9357: PPUSH
9358: LD_INT 28
9360: PUSH
9361: LD_INT 27
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PUSH
9368: LD_INT 1
9370: PPUSH
9371: LD_INT 2
9373: PPUSH
9374: CALL_OW 12
9378: ARRAY
9379: PPUSH
9380: CALL_OW 148
// end ; if legion_enemy > 0 then
9384: LD_EXP 36
9388: PUSH
9389: LD_INT 0
9391: GREATER
9392: IFFALSE 9972
// begin if tick mod 11 11$00 = 0 then
9394: LD_OWVAR 1
9398: PUSH
9399: LD_INT 23100
9401: MOD
9402: PUSH
9403: LD_INT 0
9405: EQUAL
9406: IFFALSE 9656
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9408: LD_ADDR_EXP 35
9412: PUSH
9413: LD_EXP 35
9417: PUSH
9418: LD_INT 13
9420: PUSH
9421: LD_INT 1
9423: PUSH
9424: LD_INT 2
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: LIST
9431: ADD
9432: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9433: LD_ADDR_EXP 35
9437: PUSH
9438: LD_EXP 35
9442: PUSH
9443: LD_INT 28
9445: PUSH
9446: LD_INT 27
9448: PUSH
9449: LD_INT 29
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: LIST
9456: PUSH
9457: LD_INT 1
9459: PPUSH
9460: LD_INT 3
9462: PPUSH
9463: CALL_OW 12
9467: ARRAY
9468: ADD
9469: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9470: LD_ADDR_EXP 35
9474: PUSH
9475: LD_EXP 35
9479: PUSH
9480: LD_INT 13
9482: PUSH
9483: LD_INT 1
9485: PUSH
9486: LD_INT 2
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: LIST
9493: ADD
9494: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9495: LD_ADDR_EXP 35
9499: PUSH
9500: LD_EXP 35
9504: PUSH
9505: LD_INT 28
9507: PUSH
9508: LD_INT 27
9510: PUSH
9511: LD_INT 29
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: PUSH
9519: LD_INT 1
9521: PPUSH
9522: LD_INT 3
9524: PPUSH
9525: CALL_OW 12
9529: ARRAY
9530: ADD
9531: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9532: LD_ADDR_EXP 35
9536: PUSH
9537: LD_EXP 35
9541: PUSH
9542: LD_INT 13
9544: PUSH
9545: LD_INT 1
9547: PUSH
9548: LD_INT 2
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: LIST
9555: ADD
9556: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9557: LD_ADDR_EXP 35
9561: PUSH
9562: LD_EXP 35
9566: PUSH
9567: LD_INT 28
9569: PUSH
9570: LD_INT 27
9572: PUSH
9573: LD_INT 29
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 1
9583: PPUSH
9584: LD_INT 3
9586: PPUSH
9587: CALL_OW 12
9591: ARRAY
9592: ADD
9593: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9594: LD_ADDR_EXP 35
9598: PUSH
9599: LD_EXP 35
9603: PUSH
9604: LD_INT 13
9606: PUSH
9607: LD_INT 1
9609: PUSH
9610: LD_INT 2
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: ADD
9618: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9619: LD_ADDR_EXP 35
9623: PUSH
9624: LD_EXP 35
9628: PUSH
9629: LD_INT 28
9631: PUSH
9632: LD_INT 27
9634: PUSH
9635: LD_INT 29
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: LIST
9642: PUSH
9643: LD_INT 1
9645: PPUSH
9646: LD_INT 3
9648: PPUSH
9649: CALL_OW 12
9653: ARRAY
9654: ADD
9655: ST_TO_ADDR
// end ; if legion_force >= 7 then
9656: LD_EXP 31
9660: PUSH
9661: LD_INT 7
9663: GREATEREQUAL
9664: IFFALSE 9847
// begin for i = 1 to legion_force do
9666: LD_ADDR_VAR 0 2
9670: PUSH
9671: DOUBLE
9672: LD_INT 1
9674: DEC
9675: ST_TO_ADDR
9676: LD_EXP 31
9680: PUSH
9681: FOR_TO
9682: IFFALSE 9845
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9684: LD_EXP 31
9688: PUSH
9689: LD_VAR 0 2
9693: ARRAY
9694: PPUSH
9695: CALL_OW 314
9699: NOT
9700: PUSH
9701: LD_EXP 31
9705: PUSH
9706: LD_VAR 0 2
9710: ARRAY
9711: PPUSH
9712: CALL_OW 110
9716: PUSH
9717: LD_INT 11
9719: NONEQUAL
9720: AND
9721: IFFALSE 9843
// begin case legion_enemy of 1 :
9723: LD_EXP 36
9727: PUSH
9728: LD_INT 1
9730: DOUBLE
9731: EQUAL
9732: IFTRUE 9736
9734: GO 9760
9736: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9737: LD_EXP 31
9741: PUSH
9742: LD_VAR 0 2
9746: ARRAY
9747: PPUSH
9748: LD_INT 142
9750: PPUSH
9751: LD_INT 144
9753: PPUSH
9754: CALL_OW 111
9758: GO 9825
9760: LD_INT 2
9762: DOUBLE
9763: EQUAL
9764: IFTRUE 9768
9766: GO 9792
9768: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9769: LD_EXP 31
9773: PUSH
9774: LD_VAR 0 2
9778: ARRAY
9779: PPUSH
9780: LD_INT 101
9782: PPUSH
9783: LD_INT 34
9785: PPUSH
9786: CALL_OW 111
9790: GO 9825
9792: LD_INT 7
9794: DOUBLE
9795: EQUAL
9796: IFTRUE 9800
9798: GO 9824
9800: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9801: LD_EXP 31
9805: PUSH
9806: LD_VAR 0 2
9810: ARRAY
9811: PPUSH
9812: LD_INT 173
9814: PPUSH
9815: LD_INT 127
9817: PPUSH
9818: CALL_OW 111
9822: GO 9825
9824: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9825: LD_EXP 31
9829: PUSH
9830: LD_VAR 0 2
9834: ARRAY
9835: PPUSH
9836: LD_INT 11
9838: PPUSH
9839: CALL_OW 109
// end ; end ;
9843: GO 9681
9845: POP
9846: POP
// end ; if legion_force then
9847: LD_EXP 31
9851: IFFALSE 9972
// begin tmp := legion_force ;
9853: LD_ADDR_VAR 0 3
9857: PUSH
9858: LD_EXP 31
9862: ST_TO_ADDR
// for i = 1 to tmp do
9863: LD_ADDR_VAR 0 2
9867: PUSH
9868: DOUBLE
9869: LD_INT 1
9871: DEC
9872: ST_TO_ADDR
9873: LD_VAR 0 3
9877: PUSH
9878: FOR_TO
9879: IFFALSE 9970
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9881: LD_VAR 0 3
9885: PUSH
9886: LD_VAR 0 2
9890: ARRAY
9891: PPUSH
9892: CALL_OW 314
9896: NOT
9897: PUSH
9898: LD_EXP 31
9902: PUSH
9903: LD_VAR 0 2
9907: ARRAY
9908: PPUSH
9909: CALL_OW 110
9913: PUSH
9914: LD_INT 11
9916: EQUAL
9917: AND
9918: IFFALSE 9968
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9920: LD_VAR 0 3
9924: PUSH
9925: LD_VAR 0 2
9929: ARRAY
9930: PPUSH
9931: LD_INT 22
9933: PUSH
9934: LD_EXP 36
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PPUSH
9943: CALL_OW 69
9947: PPUSH
9948: LD_VAR 0 3
9952: PUSH
9953: LD_VAR 0 2
9957: ARRAY
9958: PPUSH
9959: CALL_OW 74
9963: PPUSH
9964: CALL_OW 115
9968: GO 9878
9970: POP
9971: POP
// end ; end ; p := 1 ;
9972: LD_ADDR_VAR 0 6
9976: PUSH
9977: LD_INT 1
9979: ST_TO_ADDR
// for i = 1 to 24 do
9980: LD_ADDR_VAR 0 2
9984: PUSH
9985: DOUBLE
9986: LD_INT 1
9988: DEC
9989: ST_TO_ADDR
9990: LD_INT 24
9992: PUSH
9993: FOR_TO
9994: IFFALSE 10124
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
9996: LD_EXP 33
10000: PUSH
10001: LD_VAR 0 6
10005: ARRAY
10006: PPUSH
10007: LD_EXP 33
10011: PUSH
10012: LD_VAR 0 6
10016: PUSH
10017: LD_INT 1
10019: PLUS
10020: ARRAY
10021: PPUSH
10022: CALL_OW 428
10026: PUSH
10027: LD_INT 0
10029: GREATER
10030: IFFALSE 10108
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10032: LD_EXP 33
10036: PUSH
10037: LD_VAR 0 6
10041: ARRAY
10042: PPUSH
10043: LD_EXP 33
10047: PUSH
10048: LD_VAR 0 6
10052: PUSH
10053: LD_INT 1
10055: PLUS
10056: ARRAY
10057: PPUSH
10058: CALL_OW 428
10062: PPUSH
10063: CALL_OW 255
10067: PUSH
10068: LD_EXP 36
10072: EQUAL
10073: IFFALSE 10108
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10075: LD_EXP 33
10079: PUSH
10080: LD_VAR 0 6
10084: ARRAY
10085: PPUSH
10086: LD_EXP 33
10090: PUSH
10091: LD_VAR 0 6
10095: PUSH
10096: LD_INT 1
10098: PLUS
10099: ARRAY
10100: PPUSH
10101: LD_INT 8
10103: PPUSH
10104: CALL_OW 456
// p := p + 2 ;
10108: LD_ADDR_VAR 0 6
10112: PUSH
10113: LD_VAR 0 6
10117: PUSH
10118: LD_INT 2
10120: PLUS
10121: ST_TO_ADDR
// end ;
10122: GO 9993
10124: POP
10125: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10126: LD_INT 22
10128: PUSH
10129: LD_INT 8
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 34
10138: PUSH
10139: LD_INT 32
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: PPUSH
10150: CALL_OW 69
10154: IFFALSE 10268
// begin if l_cargo = false then
10156: LD_VAR 0 17
10160: PUSH
10161: LD_INT 0
10163: EQUAL
10164: IFFALSE 10200
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10166: LD_ADDR_VAR 0 17
10170: PUSH
10171: LD_INT 22
10173: PUSH
10174: LD_INT 8
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PUSH
10181: LD_INT 34
10183: PUSH
10184: LD_INT 32
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PPUSH
10195: CALL_OW 69
10199: ST_TO_ADDR
// if l_cargo then
10200: LD_VAR 0 17
10204: IFFALSE 10268
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10206: LD_ADDR_VAR 0 7
10210: PUSH
10211: LD_INT 14
10213: PPUSH
10214: CALL_OW 435
10218: ST_TO_ADDR
// if cr > 0 then
10219: LD_VAR 0 7
10223: PUSH
10224: LD_INT 0
10226: GREATER
10227: IFFALSE 10268
// if not HasTask ( l_cargo ) then
10229: LD_VAR 0 17
10233: PPUSH
10234: CALL_OW 314
10238: NOT
10239: IFFALSE 10268
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10241: LD_VAR 0 17
10245: PPUSH
10246: LD_VAR 0 7
10250: PUSH
10251: LD_INT 1
10253: ARRAY
10254: PPUSH
10255: LD_VAR 0 7
10259: PUSH
10260: LD_INT 2
10262: ARRAY
10263: PPUSH
10264: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10268: LD_OWVAR 1
10272: PUSH
10273: LD_INT 52500
10275: PUSH
10276: LD_INT 46200
10278: PUSH
10279: LD_INT 42000
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: LIST
10286: PUSH
10287: LD_OWVAR 67
10291: ARRAY
10292: EQUAL
10293: PUSH
10294: LD_INT 1
10296: PPUSH
10297: CALL_OW 469
10301: PUSH
10302: LD_INT 1
10304: ARRAY
10305: PUSH
10306: LD_INT 112
10308: EQUAL
10309: AND
10310: PUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 469
10318: PUSH
10319: LD_INT 2
10321: ARRAY
10322: PUSH
10323: LD_INT 67
10325: EQUAL
10326: AND
10327: IFFALSE 10420
// begin un := l_eng [ 1 ] ;
10329: LD_ADDR_VAR 0 1
10333: PUSH
10334: LD_VAR 0 16
10338: PUSH
10339: LD_INT 1
10341: ARRAY
10342: ST_TO_ADDR
// if IsInUnit ( un ) then
10343: LD_VAR 0 1
10347: PPUSH
10348: CALL_OW 310
10352: IFFALSE 10363
// ComExitBuilding ( un ) ;
10354: LD_VAR 0 1
10358: PPUSH
10359: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10363: LD_VAR 0 1
10367: PPUSH
10368: LD_INT 1
10370: PPUSH
10371: CALL_OW 469
10375: PUSH
10376: LD_INT 1
10378: ARRAY
10379: PPUSH
10380: LD_INT 1
10382: PPUSH
10383: CALL_OW 469
10387: PUSH
10388: LD_INT 2
10390: ARRAY
10391: PPUSH
10392: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10396: LD_VAR 0 1
10400: PPUSH
10401: LD_INT 207
10403: PPUSH
10404: LD_INT 123
10406: PPUSH
10407: CALL_OW 171
// AddComUnload ( un ) ;
10411: LD_VAR 0 1
10415: PPUSH
10416: CALL_OW 219
// end ; end ;
10420: PPOPN 17
10422: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10423: LD_OWVAR 67
10427: PUSH
10428: LD_INT 1
10430: GREATER
10431: IFFALSE 10636
10433: GO 10435
10435: DISABLE
10436: LD_INT 0
10438: PPUSH
10439: PPUSH
10440: PPUSH
10441: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10442: LD_INT 35
10444: PPUSH
10445: LD_INT 12635
10447: PPUSH
10448: CALL_OW 12
10452: PPUSH
10453: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10457: LD_ADDR_VAR 0 2
10461: PUSH
10462: LD_INT 22
10464: PUSH
10465: LD_INT 8
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: LD_INT 25
10474: PUSH
10475: LD_INT 4
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: EMPTY
10483: LIST
10484: LIST
10485: PPUSH
10486: CALL_OW 69
10490: ST_TO_ADDR
// p := 1 ;
10491: LD_ADDR_VAR 0 4
10495: PUSH
10496: LD_INT 1
10498: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10499: LD_ADDR_VAR 0 3
10503: PUSH
10504: LD_INT 116
10506: PUSH
10507: LD_INT 139
10509: PUSH
10510: LD_INT 69
10512: PUSH
10513: LD_INT 13
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: ST_TO_ADDR
// for i = 1 to 2 do
10522: LD_ADDR_VAR 0 1
10526: PUSH
10527: DOUBLE
10528: LD_INT 1
10530: DEC
10531: ST_TO_ADDR
10532: LD_INT 2
10534: PUSH
10535: FOR_TO
10536: IFFALSE 10634
// begin if IsInUnit ( sci [ i ] ) then
10538: LD_VAR 0 2
10542: PUSH
10543: LD_VAR 0 1
10547: ARRAY
10548: PPUSH
10549: CALL_OW 310
10553: IFFALSE 10570
// ComExitBuilding ( sci [ i ] ) ;
10555: LD_VAR 0 2
10559: PUSH
10560: LD_VAR 0 1
10564: ARRAY
10565: PPUSH
10566: CALL_OW 122
// Wait ( 0 0$03 ) ;
10570: LD_INT 105
10572: PPUSH
10573: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10577: LD_VAR 0 2
10581: PUSH
10582: LD_VAR 0 1
10586: ARRAY
10587: PPUSH
10588: LD_VAR 0 3
10592: PUSH
10593: LD_VAR 0 4
10597: ARRAY
10598: PPUSH
10599: LD_VAR 0 3
10603: PUSH
10604: LD_VAR 0 4
10608: PUSH
10609: LD_INT 1
10611: PLUS
10612: ARRAY
10613: PPUSH
10614: CALL_OW 158
// p := p + 2 ;
10618: LD_ADDR_VAR 0 4
10622: PUSH
10623: LD_VAR 0 4
10627: PUSH
10628: LD_INT 2
10630: PLUS
10631: ST_TO_ADDR
// end ;
10632: GO 10535
10634: POP
10635: POP
// end ;
10636: PPOPN 4
10638: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10639: LD_INT 14
10641: PPUSH
10642: CALL_OW 435
10646: PUSH
10647: LD_INT 20
10649: LESS
10650: IFFALSE 10677
10652: GO 10654
10654: DISABLE
// begin enable ;
10655: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10656: LD_INT 1
10658: PPUSH
10659: LD_INT 5
10661: PPUSH
10662: CALL_OW 12
10666: PPUSH
10667: LD_INT 14
10669: PPUSH
10670: LD_INT 1
10672: PPUSH
10673: CALL_OW 55
// end ; end_of_file
10677: END
// export function Action ; var un ; begin
10678: LD_INT 0
10680: PPUSH
10681: PPUSH
// case Query ( QVul1 ) of 1 :
10682: LD_STRING QVul1
10684: PPUSH
10685: CALL_OW 97
10689: PUSH
10690: LD_INT 1
10692: DOUBLE
10693: EQUAL
10694: IFTRUE 10698
10696: GO 10709
10698: POP
// Difficulty := 1 ; 2 :
10699: LD_ADDR_OWVAR 67
10703: PUSH
10704: LD_INT 1
10706: ST_TO_ADDR
10707: GO 10748
10709: LD_INT 2
10711: DOUBLE
10712: EQUAL
10713: IFTRUE 10717
10715: GO 10728
10717: POP
// Difficulty := 2 ; 3 :
10718: LD_ADDR_OWVAR 67
10722: PUSH
10723: LD_INT 2
10725: ST_TO_ADDR
10726: GO 10748
10728: LD_INT 3
10730: DOUBLE
10731: EQUAL
10732: IFTRUE 10736
10734: GO 10747
10736: POP
// Difficulty := 3 ; end ;
10737: LD_ADDR_OWVAR 67
10741: PUSH
10742: LD_INT 3
10744: ST_TO_ADDR
10745: GO 10748
10747: POP
// case Query ( QVul3 ) of 1 :
10748: LD_STRING QVul3
10750: PPUSH
10751: CALL_OW 97
10755: PUSH
10756: LD_INT 1
10758: DOUBLE
10759: EQUAL
10760: IFTRUE 10764
10762: GO 10787
10764: POP
// begin your_side := 1 ;
10765: LD_ADDR_OWVAR 2
10769: PUSH
10770: LD_INT 1
10772: ST_TO_ADDR
// legion_enemy := 1 ;
10773: LD_ADDR_EXP 36
10777: PUSH
10778: LD_INT 1
10780: ST_TO_ADDR
// PrepareAmerican ;
10781: CALL 214 0 0
// end ; 2 :
10785: GO 10850
10787: LD_INT 2
10789: DOUBLE
10790: EQUAL
10791: IFTRUE 10795
10793: GO 10818
10795: POP
// begin your_side := 2 ;
10796: LD_ADDR_OWVAR 2
10800: PUSH
10801: LD_INT 2
10803: ST_TO_ADDR
// legion_enemy := 2 ;
10804: LD_ADDR_EXP 36
10808: PUSH
10809: LD_INT 2
10811: ST_TO_ADDR
// PrepareArabian ;
10812: CALL 17447 0 0
// end ; 3 :
10816: GO 10850
10818: LD_INT 3
10820: DOUBLE
10821: EQUAL
10822: IFTRUE 10826
10824: GO 10849
10826: POP
// begin your_side := 7 ;
10827: LD_ADDR_OWVAR 2
10831: PUSH
10832: LD_INT 7
10834: ST_TO_ADDR
// legion_enemy := 7 ;
10835: LD_ADDR_EXP 36
10839: PUSH
10840: LD_INT 7
10842: ST_TO_ADDR
// PrepareAlliance ;
10843: CALL 14858 0 0
// end ; end ;
10847: GO 10850
10849: POP
// if your_side = 1 then
10850: LD_OWVAR 2
10854: PUSH
10855: LD_INT 1
10857: EQUAL
10858: IFFALSE 11212
// begin case Query ( QVul4 ) of 1 :
10860: LD_STRING QVul4
10862: PPUSH
10863: CALL_OW 97
10867: PUSH
10868: LD_INT 1
10870: DOUBLE
10871: EQUAL
10872: IFTRUE 10876
10874: GO 10879
10876: POP
// ; end ;
10877: GO 10880
10879: POP
// InGameOn ;
10880: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10884: LD_INT 8
10886: PPUSH
10887: LD_INT 5
10889: PPUSH
10890: CALL_OW 86
// uc_side := 4 ;
10894: LD_ADDR_OWVAR 20
10898: PUSH
10899: LD_INT 4
10901: ST_TO_ADDR
// uc_nation := 1 ;
10902: LD_ADDR_OWVAR 21
10906: PUSH
10907: LD_INT 1
10909: ST_TO_ADDR
// hc_importance := 0 ;
10910: LD_ADDR_OWVAR 32
10914: PUSH
10915: LD_INT 0
10917: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10918: LD_INT 1
10920: PPUSH
10921: LD_INT 3
10923: PPUSH
10924: LD_EXP 21
10928: PPUSH
10929: CALL_OW 380
// un := CreateHuman ;
10933: LD_ADDR_VAR 0 2
10937: PUSH
10938: CALL_OW 44
10942: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10943: LD_VAR 0 2
10947: PPUSH
10948: LD_INT 12
10950: PPUSH
10951: LD_INT 9
10953: PPUSH
10954: LD_INT 0
10956: PPUSH
10957: CALL_OW 48
// hc_name := Stuart Carey ;
10961: LD_ADDR_OWVAR 26
10965: PUSH
10966: LD_STRING Stuart Carey
10968: ST_TO_ADDR
// hc_class := 1 ;
10969: LD_ADDR_OWVAR 28
10973: PUSH
10974: LD_INT 1
10976: ST_TO_ADDR
// hc_gallery := vulcano ;
10977: LD_ADDR_OWVAR 33
10981: PUSH
10982: LD_STRING vulcano
10984: ST_TO_ADDR
// hc_face_number := 1 ;
10985: LD_ADDR_OWVAR 34
10989: PUSH
10990: LD_INT 1
10992: ST_TO_ADDR
// us_guy := CreateHuman ;
10993: LD_ADDR_EXP 22
10997: PUSH
10998: CALL_OW 44
11002: ST_TO_ADDR
// hc_gallery :=  ;
11003: LD_ADDR_OWVAR 33
11007: PUSH
11008: LD_STRING 
11010: ST_TO_ADDR
// hc_name :=  ;
11011: LD_ADDR_OWVAR 26
11015: PUSH
11016: LD_STRING 
11018: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11019: LD_VAR 0 2
11023: PPUSH
11024: LD_EXP 19
11028: PPUSH
11029: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11033: LD_EXP 19
11037: PPUSH
11038: LD_VAR 0 2
11042: PPUSH
11043: CALL_OW 119
// Say ( un , VD-un1 ) ;
11047: LD_VAR 0 2
11051: PPUSH
11052: LD_STRING VD-un1
11054: PPUSH
11055: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11059: LD_EXP 19
11063: PPUSH
11064: LD_STRING VDc-1
11066: PPUSH
11067: CALL_OW 88
// Say ( un , VD-un2 ) ;
11071: LD_VAR 0 2
11075: PPUSH
11076: LD_STRING VD-un2
11078: PPUSH
11079: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11083: LD_EXP 19
11087: PPUSH
11088: LD_STRING VDc-2
11090: PPUSH
11091: CALL_OW 88
// Say ( un , VD-un3 ) ;
11095: LD_VAR 0 2
11099: PPUSH
11100: LD_STRING VD-un3
11102: PPUSH
11103: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11107: LD_INT 7
11109: PPUSH
11110: CALL_OW 67
// Say ( un , VD-un4 ) ;
11114: LD_VAR 0 2
11118: PPUSH
11119: LD_STRING VD-un4
11121: PPUSH
11122: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11126: LD_VAR 0 2
11130: PPUSH
11131: LD_INT 2
11133: PPUSH
11134: LD_INT 2
11136: PPUSH
11137: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11141: LD_EXP 19
11145: PPUSH
11146: LD_STRING VDc-3
11148: PPUSH
11149: CALL_OW 88
// InGameOff ;
11153: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11157: LD_STRING CVulc1
11159: PPUSH
11160: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11164: LD_INT 35
11166: PPUSH
11167: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11171: LD_VAR 0 2
11175: PPUSH
11176: CALL_OW 250
11180: PUSH
11181: LD_INT 2
11183: EQUAL
11184: PUSH
11185: LD_VAR 0 2
11189: PPUSH
11190: CALL_OW 251
11194: PUSH
11195: LD_INT 2
11197: EQUAL
11198: AND
11199: IFFALSE 11164
// RemoveUnit ( un ) ;
11201: LD_VAR 0 2
11205: PPUSH
11206: CALL_OW 64
// end else
11210: GO 11504
// if your_side = 2 then
11212: LD_OWVAR 2
11216: PUSH
11217: LD_INT 2
11219: EQUAL
11220: IFFALSE 11392
// begin CenterNowOnUnits ( player_commander ) ;
11222: LD_EXP 10
11226: PPUSH
11227: CALL_OW 87
// InGameOn ;
11231: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11235: LD_EXP 51
11239: PPUSH
11240: LD_STRING VSd-1
11242: PPUSH
11243: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11247: LD_INT 22
11249: PUSH
11250: LD_INT 2
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: PUSH
11257: LD_INT 21
11259: PUSH
11260: LD_INT 1
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PUSH
11267: LD_INT 26
11269: PUSH
11270: LD_INT 1
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: PUSH
11282: EMPTY
11283: LIST
11284: PPUSH
11285: CALL_OW 69
11289: PUSH
11290: LD_INT 2
11292: ARRAY
11293: PPUSH
11294: LD_STRING VAd-1
11296: PPUSH
11297: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11301: LD_EXP 51
11305: PPUSH
11306: LD_STRING VSd-2
11308: PPUSH
11309: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11313: LD_INT 22
11315: PUSH
11316: LD_INT 2
11318: PUSH
11319: EMPTY
11320: LIST
11321: LIST
11322: PUSH
11323: LD_INT 21
11325: PUSH
11326: LD_INT 1
11328: PUSH
11329: EMPTY
11330: LIST
11331: LIST
11332: PUSH
11333: LD_INT 26
11335: PUSH
11336: LD_INT 1
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: PPUSH
11351: CALL_OW 69
11355: PUSH
11356: LD_INT 2
11358: ARRAY
11359: PPUSH
11360: LD_STRING VAd-2
11362: PPUSH
11363: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11367: LD_EXP 51
11371: PPUSH
11372: LD_STRING VSd-3
11374: PPUSH
11375: CALL_OW 88
// InGameOff ;
11379: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11383: LD_STRING CVulc5
11385: PPUSH
11386: CALL_OW 337
// end else
11390: GO 11504
// if your_side = 7 then
11392: LD_OWVAR 2
11396: PUSH
11397: LD_INT 7
11399: EQUAL
11400: IFFALSE 11504
// begin CenterNowOnUnits ( al_commander ) ;
11402: LD_EXP 37
11406: PPUSH
11407: CALL_OW 87
// InGameOn ;
11411: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11415: LD_EXP 37
11419: PPUSH
11420: LD_STRING VPd-1
11422: PPUSH
11423: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11427: LD_INT 22
11429: PUSH
11430: LD_INT 7
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 21
11439: PUSH
11440: LD_INT 1
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 26
11449: PUSH
11450: LD_INT 1
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: PUSH
11462: EMPTY
11463: LIST
11464: PPUSH
11465: CALL_OW 69
11469: PUSH
11470: LD_INT 2
11472: ARRAY
11473: PPUSH
11474: LD_STRING VPpd-1
11476: PPUSH
11477: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11481: LD_EXP 37
11485: PPUSH
11486: LD_STRING VPd-2
11488: PPUSH
11489: CALL_OW 88
// InGameOff ;
11493: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11497: LD_STRING CVulc7
11499: PPUSH
11500: CALL_OW 337
// end ; end ;
11504: LD_VAR 0 1
11508: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11509: LD_INT 22
11511: PUSH
11512: LD_INT 2
11514: PUSH
11515: EMPTY
11516: LIST
11517: LIST
11518: PUSH
11519: LD_INT 30
11521: PUSH
11522: LD_INT 3
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: EMPTY
11530: LIST
11531: LIST
11532: PPUSH
11533: CALL_OW 69
11537: IFFALSE 11581
11539: GO 11541
11541: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11542: LD_STRING CVulc6
11544: PPUSH
11545: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11549: LD_INT 52500
11551: PUSH
11552: LD_INT 47250
11554: PUSH
11555: LD_INT 42000
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: LIST
11562: PUSH
11563: LD_OWVAR 67
11567: ARRAY
11568: PPUSH
11569: CALL_OW 67
// ru_can_attack := true ;
11573: LD_ADDR_EXP 3
11577: PUSH
11578: LD_INT 1
11580: ST_TO_ADDR
// end ;
11581: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11582: LD_INT 50
11584: PPUSH
11585: CALL_OW 255
11589: PUSH
11590: LD_INT 1
11592: EQUAL
11593: PUSH
11594: LD_INT 22
11596: PUSH
11597: LD_INT 1
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: LD_INT 2
11606: PUSH
11607: LD_INT 30
11609: PUSH
11610: LD_INT 3
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: LD_INT 30
11619: PUSH
11620: LD_INT 1
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: LIST
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 69
11640: OR
11641: IFFALSE 11818
11643: GO 11645
11645: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11646: LD_STRING CVulc2
11648: PPUSH
11649: CALL_OW 337
// DialogueOn ;
11653: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11657: LD_INT 10
11659: PPUSH
11660: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11664: LD_INT 22
11666: PUSH
11667: LD_INT 1
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 2
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: PPUSH
11688: CALL_OW 69
11692: PUSH
11693: LD_EXP 19
11697: DIFF
11698: PUSH
11699: LD_INT 1
11701: ARRAY
11702: PPUSH
11703: LD_STRING VDb-1
11705: PPUSH
11706: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11710: LD_INT 10
11712: PPUSH
11713: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11717: LD_INT 22
11719: PUSH
11720: LD_INT 1
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 25
11729: PUSH
11730: LD_INT 4
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PPUSH
11741: CALL_OW 69
11745: PUSH
11746: LD_EXP 19
11750: DIFF
11751: PUSH
11752: LD_INT 1
11754: ARRAY
11755: PPUSH
11756: LD_STRING VDb-2
11758: PPUSH
11759: CALL_OW 88
// DWait ( 0 0$01 ) ;
11763: LD_INT 35
11765: PPUSH
11766: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11770: LD_EXP 19
11774: PPUSH
11775: LD_STRING VDb-com1
11777: PPUSH
11778: CALL_OW 88
// DialogueOff ;
11782: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11786: LD_INT 44100
11788: PUSH
11789: LD_INT 36750
11791: PUSH
11792: LD_INT 31500
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: LD_OWVAR 67
11804: ARRAY
11805: PPUSH
11806: CALL_OW 67
// ru_can_attack := true ;
11810: LD_ADDR_EXP 3
11814: PUSH
11815: LD_INT 1
11817: ST_TO_ADDR
// end ;
11818: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11819: LD_INT 22
11821: PUSH
11822: LD_INT 7
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 30
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PPUSH
11843: CALL_OW 69
11847: IFFALSE 11884
11849: GO 11851
11851: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11852: LD_INT 42000
11854: PUSH
11855: LD_INT 34650
11857: PUSH
11858: LD_INT 29400
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PUSH
11866: LD_OWVAR 67
11870: ARRAY
11871: PPUSH
11872: CALL_OW 67
// ru_can_attack := true ;
11876: LD_ADDR_EXP 3
11880: PUSH
11881: LD_INT 1
11883: ST_TO_ADDR
// end ;
11884: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11885: LD_INT 58
11887: PPUSH
11888: CALL_OW 255
11892: PUSH
11893: LD_INT 1
11895: EQUAL
11896: IFFALSE 12028
11898: GO 11900
11900: DISABLE
// begin DialogueOn ;
11901: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11905: LD_INT 22
11907: PUSH
11908: LD_INT 1
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 25
11917: PUSH
11918: LD_INT 2
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: PUSH
11934: LD_INT 1
11936: ARRAY
11937: PPUSH
11938: LD_STRING VDe-1
11940: PPUSH
11941: CALL_OW 88
// case Query ( SibNote ) of 1 :
11945: LD_STRING SibNote
11947: PPUSH
11948: CALL_OW 97
11952: PUSH
11953: LD_INT 1
11955: DOUBLE
11956: EQUAL
11957: IFTRUE 11961
11959: GO 11964
11961: POP
// ; end ;
11962: GO 11965
11964: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11965: LD_INT 22
11967: PUSH
11968: LD_INT 1
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 25
11977: PUSH
11978: LD_INT 2
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PUSH
11985: EMPTY
11986: LIST
11987: LIST
11988: PPUSH
11989: CALL_OW 69
11993: PUSH
11994: LD_INT 1
11996: ARRAY
11997: PPUSH
11998: LD_STRING VDe-2
12000: PPUSH
12001: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12005: LD_EXP 19
12009: PPUSH
12010: LD_STRING VDc-4
12012: PPUSH
12013: CALL_OW 88
// DialogueOff ;
12017: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12021: LD_STRING CVulc3
12023: PPUSH
12024: CALL_OW 337
// end ;
12028: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12029: LD_OWVAR 2
12033: PUSH
12034: LD_INT 1
12036: EQUAL
12037: PUSH
12038: LD_INT 22
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 30
12050: PUSH
12051: LD_INT 3
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PPUSH
12062: CALL_OW 69
12066: PUSH
12067: LD_INT 0
12069: GREATER
12070: AND
12071: IFFALSE 12505
12073: GO 12075
12075: DISABLE
12076: LD_INT 0
12078: PPUSH
12079: PPUSH
12080: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12081: LD_INT 245
12083: PPUSH
12084: LD_INT 1295
12086: PPUSH
12087: CALL_OW 12
12091: PPUSH
12092: CALL_OW 67
// DialogueOn ;
12096: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12100: LD_EXP 22
12104: PPUSH
12105: LD_STRING VDG-1
12107: PPUSH
12108: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12112: LD_EXP 19
12116: PPUSH
12117: LD_STRING VDc-5
12119: PPUSH
12120: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12124: LD_EXP 22
12128: PPUSH
12129: LD_STRING VDG-2
12131: PPUSH
12132: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12136: LD_EXP 19
12140: PPUSH
12141: LD_STRING VDc-6
12143: PPUSH
12144: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12148: LD_EXP 22
12152: PPUSH
12153: LD_STRING VDG-3
12155: PPUSH
12156: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12160: LD_EXP 19
12164: PPUSH
12165: LD_STRING VDc-7
12167: PPUSH
12168: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12172: LD_EXP 22
12176: PPUSH
12177: LD_STRING VDG-4
12179: PPUSH
12180: CALL_OW 94
// DialogueOff ;
12184: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12188: LD_STRING CVulc4
12190: PPUSH
12191: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12195: LD_INT 18900
12197: PUSH
12198: LD_INT 21000
12200: PUSH
12201: LD_INT 23100
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: LIST
12208: PUSH
12209: LD_OWVAR 67
12213: ARRAY
12214: PPUSH
12215: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12219: LD_ADDR_VAR 0 1
12223: PUSH
12224: DOUBLE
12225: LD_INT 1
12227: DEC
12228: ST_TO_ADDR
12229: LD_INT 4
12231: PUSH
12232: LD_INT 5
12234: PUSH
12235: LD_INT 6
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: LIST
12242: PUSH
12243: LD_OWVAR 67
12247: ARRAY
12248: PUSH
12249: FOR_TO
12250: IFFALSE 12494
// begin uc_side := 1 ;
12252: LD_ADDR_OWVAR 20
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// uc_nation := 1 ;
12260: LD_ADDR_OWVAR 21
12264: PUSH
12265: LD_INT 1
12267: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12268: LD_INT 0
12270: PPUSH
12271: LD_INT 1
12273: PPUSH
12274: LD_INT 4
12276: PPUSH
12277: CALL_OW 12
12281: PPUSH
12282: LD_EXP 21
12286: PPUSH
12287: CALL_OW 380
// un := CreateHuman ;
12291: LD_ADDR_VAR 0 2
12295: PUSH
12296: CALL_OW 44
12300: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 2
12308: PPUSH
12309: CALL_OW 233
// if GetClass ( un ) = 3 then
12313: LD_VAR 0 2
12317: PPUSH
12318: CALL_OW 257
12322: PUSH
12323: LD_INT 3
12325: EQUAL
12326: IFFALSE 12477
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12328: LD_ADDR_OWVAR 37
12332: PUSH
12333: LD_INT 2
12335: PUSH
12336: LD_INT 3
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: LD_VAR 0 1
12347: PUSH
12348: LD_INT 2
12350: MOD
12351: ARRAY
12352: ST_TO_ADDR
// vc_engine := engine_combustion ;
12353: LD_ADDR_OWVAR 39
12357: PUSH
12358: LD_INT 1
12360: ST_TO_ADDR
// vc_control := control_manual ;
12361: LD_ADDR_OWVAR 38
12365: PUSH
12366: LD_INT 1
12368: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12369: LD_ADDR_OWVAR 40
12373: PUSH
12374: LD_INT 9
12376: PUSH
12377: LD_INT 9
12379: PUSH
12380: LD_INT 5
12382: PUSH
12383: LD_INT 11
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 1
12394: PPUSH
12395: LD_INT 4
12397: PPUSH
12398: CALL_OW 12
12402: ARRAY
12403: ST_TO_ADDR
// veh := CreateVehicle ;
12404: LD_ADDR_VAR 0 3
12408: PUSH
12409: CALL_OW 45
12413: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12414: LD_VAR 0 3
12418: PPUSH
12419: LD_INT 2
12421: PPUSH
12422: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12426: LD_VAR 0 3
12430: PPUSH
12431: LD_INT 77
12433: PPUSH
12434: LD_INT 88
12436: PPUSH
12437: CALL_OW 12
12441: PPUSH
12442: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12446: LD_VAR 0 3
12450: PPUSH
12451: LD_INT 1
12453: PPUSH
12454: LD_INT 0
12456: PPUSH
12457: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12461: LD_VAR 0 2
12465: PPUSH
12466: LD_VAR 0 3
12470: PPUSH
12471: CALL_OW 52
// end else
12475: GO 12492
// PlaceUnitArea ( un , start_north , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 1
12484: PPUSH
12485: LD_INT 0
12487: PPUSH
12488: CALL_OW 49
// end ;
12492: GO 12249
12494: POP
12495: POP
// CenterNowOnUnits ( un ) ;
12496: LD_VAR 0 2
12500: PPUSH
12501: CALL_OW 87
// end ;
12505: PPOPN 3
12507: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12508: LD_INT 21
12510: PPUSH
12511: LD_INT 22
12513: PUSH
12514: LD_OWVAR 2
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PPUSH
12523: CALL_OW 70
12527: IFFALSE 12749
12529: GO 12531
12531: DISABLE
12532: LD_INT 0
12534: PPUSH
12535: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12536: LD_ADDR_VAR 0 2
12540: PUSH
12541: LD_INT 22
12543: PUSH
12544: LD_OWVAR 2
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: LD_INT 2
12555: PUSH
12556: LD_INT 25
12558: PUSH
12559: LD_INT 1
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 2
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: LD_INT 25
12578: PUSH
12579: LD_INT 3
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: LD_INT 25
12588: PUSH
12589: LD_INT 4
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: EMPTY
12597: LIST
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: PPUSH
12607: CALL_OW 69
12611: PUSH
12612: LD_EXP 10
12616: DIFF
12617: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_VAR 0 2
12627: PPUSH
12628: LD_INT 112
12630: PPUSH
12631: LD_INT 67
12633: PPUSH
12634: CALL_OW 73
12638: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12639: LD_VAR 0 1
12643: PPUSH
12644: CALL_OW 255
12648: PUSH
12649: LD_INT 7
12651: EQUAL
12652: IFFALSE 12666
// Say ( un , VD-find-al ) ;
12654: LD_VAR 0 1
12658: PPUSH
12659: LD_STRING VD-find-al
12661: PPUSH
12662: CALL_OW 88
// if GetSide ( un ) = 2 then
12666: LD_VAR 0 1
12670: PPUSH
12671: CALL_OW 255
12675: PUSH
12676: LD_INT 2
12678: EQUAL
12679: IFFALSE 12693
// Say ( un , VD-find-ar ) ;
12681: LD_VAR 0 1
12685: PPUSH
12686: LD_STRING VD-find-ar
12688: PPUSH
12689: CALL_OW 88
// if GetSide ( un ) = 1 then
12693: LD_VAR 0 1
12697: PPUSH
12698: CALL_OW 255
12702: PUSH
12703: LD_INT 1
12705: EQUAL
12706: IFFALSE 12732
// begin Say ( un , VD-find-us ) ;
12708: LD_VAR 0 1
12712: PPUSH
12713: LD_STRING VD-find-us
12715: PPUSH
12716: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12720: LD_VAR 0 1
12724: PPUSH
12725: LD_STRING VD-find-us2
12727: PPUSH
12728: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12732: LD_INT 10
12734: PPUSH
12735: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12739: LD_INT 112
12741: PPUSH
12742: LD_INT 67
12744: PPUSH
12745: CALL_OW 86
// end ;
12749: PPOPN 2
12751: END
// every 0 0$01 trigger player_artifact_ready do
12752: LD_EXP 7
12756: IFFALSE 13070
12758: GO 12760
12760: DISABLE
// begin if your_side = 1 then
12761: LD_OWVAR 2
12765: PUSH
12766: LD_INT 1
12768: EQUAL
12769: IFFALSE 12887
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12771: LD_INT 22
12773: PUSH
12774: LD_INT 1
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 25
12783: PUSH
12784: LD_INT 4
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PPUSH
12795: CALL_OW 69
12799: PUSH
12800: LD_EXP 19
12804: DIFF
12805: PUSH
12806: LD_INT 1
12808: ARRAY
12809: PPUSH
12810: LD_STRING VD-us-sci-art-1
12812: PPUSH
12813: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12817: LD_EXP 19
12821: PPUSH
12822: LD_STRING VDc-art1
12824: PPUSH
12825: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12829: LD_INT 22
12831: PUSH
12832: LD_INT 1
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 25
12841: PUSH
12842: LD_INT 4
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PPUSH
12853: CALL_OW 69
12857: PUSH
12858: LD_EXP 19
12862: DIFF
12863: PUSH
12864: LD_INT 1
12866: ARRAY
12867: PPUSH
12868: LD_STRING VD-us-sci-art-2
12870: PPUSH
12871: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12875: LD_EXP 19
12879: PPUSH
12880: LD_STRING VDc-art2
12882: PPUSH
12883: CALL_OW 88
// end ; if your_side = 2 then
12887: LD_OWVAR 2
12891: PUSH
12892: LD_INT 2
12894: EQUAL
12895: IFFALSE 12937
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12897: LD_INT 22
12899: PUSH
12900: LD_INT 2
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: PUSH
12907: LD_INT 25
12909: PUSH
12910: LD_INT 4
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PPUSH
12921: CALL_OW 69
12925: PUSH
12926: LD_INT 1
12928: ARRAY
12929: PPUSH
12930: LD_STRING VD-ar-sci-art-1
12932: PPUSH
12933: CALL_OW 88
// end ; if your_side = 7 then
12937: LD_OWVAR 2
12941: PUSH
12942: LD_INT 7
12944: EQUAL
12945: IFFALSE 13070
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12947: LD_INT 22
12949: PUSH
12950: LD_INT 7
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PUSH
12957: LD_INT 25
12959: PUSH
12960: LD_INT 4
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PPUSH
12971: CALL_OW 69
12975: PUSH
12976: LD_EXP 37
12980: DIFF
12981: PUSH
12982: LD_INT 1
12984: ARRAY
12985: PPUSH
12986: LD_STRING VD-al-sci-art-1
12988: PPUSH
12989: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
12993: LD_EXP 37
12997: PPUSH
12998: LD_STRING VPd-art-1
13000: PPUSH
13001: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13005: LD_INT 22
13007: PUSH
13008: LD_INT 7
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 25
13017: PUSH
13018: LD_INT 4
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PPUSH
13029: CALL_OW 69
13033: PUSH
13034: LD_EXP 37
13038: DIFF
13039: PUSH
13040: LD_INT 1
13042: ARRAY
13043: PPUSH
13044: LD_STRING VD-al-sci-art-2
13046: PPUSH
13047: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13051: LD_EXP 37
13055: PPUSH
13056: LD_STRING VPd-art-2
13058: PPUSH
13059: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13063: LD_STRING CVulc7out
13065: PPUSH
13066: CALL_OW 337
// end ; end ;
13070: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13071: LD_INT 8
13073: PPUSH
13074: LD_INT 22
13076: PUSH
13077: LD_OWVAR 2
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PPUSH
13086: CALL_OW 69
13090: PPUSH
13091: LD_INT 8
13093: PPUSH
13094: CALL 2138 0 2
13098: PPUSH
13099: CALL_OW 292
13103: IFFALSE 13194
13105: GO 13107
13107: DISABLE
// begin if your_side = 1 then
13108: LD_OWVAR 2
13112: PUSH
13113: LD_INT 1
13115: EQUAL
13116: IFFALSE 13150
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13118: LD_INT 22
13120: PUSH
13121: LD_INT 1
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PPUSH
13128: CALL_OW 69
13132: PUSH
13133: LD_EXP 19
13137: DIFF
13138: PUSH
13139: LD_INT 1
13141: ARRAY
13142: PPUSH
13143: LD_STRING VD-legion-us
13145: PPUSH
13146: CALL_OW 88
// if your_side = 2 then
13150: LD_OWVAR 2
13154: PUSH
13155: LD_INT 2
13157: EQUAL
13158: IFFALSE 13172
// Say ( ar_commander , VD-legion-ar ) ;
13160: LD_EXP 51
13164: PPUSH
13165: LD_STRING VD-legion-ar
13167: PPUSH
13168: CALL_OW 88
// if your_side = 7 then
13172: LD_OWVAR 2
13176: PUSH
13177: LD_INT 7
13179: EQUAL
13180: IFFALSE 13194
// Say ( al_commander , VD-legion-al ) ;
13182: LD_EXP 37
13186: PPUSH
13187: LD_STRING VD-legion-al
13189: PPUSH
13190: CALL_OW 88
// end ;
13194: END
// every 0 0$01 trigger mine_vulc do
13195: LD_EXP 12
13199: IFFALSE 13216
13201: GO 13203
13203: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13204: LD_EXP 10
13208: PPUSH
13209: LD_STRING VD-vulc-mines
13211: PPUSH
13212: CALL_OW 88
// end ;
13216: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13217: LD_OWVAR 67
13221: PUSH
13222: LD_INT 1
13224: GREATER
13225: IFFALSE 13344
13227: GO 13229
13229: DISABLE
13230: LD_INT 0
13232: PPUSH
13233: PPUSH
13234: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13235: LD_ADDR_VAR 0 1
13239: PUSH
13240: LD_INT 123
13242: PUSH
13243: LD_INT 95
13245: PUSH
13246: LD_INT 119
13248: PUSH
13249: LD_INT 89
13251: PUSH
13252: LD_INT 115
13254: PUSH
13255: LD_INT 81
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// p := 1 ;
13266: LD_ADDR_VAR 0 2
13270: PUSH
13271: LD_INT 1
13273: ST_TO_ADDR
// for i = 1 to 3 do
13274: LD_ADDR_VAR 0 3
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_INT 3
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13342
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13290: LD_VAR 0 1
13294: PUSH
13295: LD_VAR 0 2
13299: ARRAY
13300: PPUSH
13301: LD_VAR 0 1
13305: PUSH
13306: LD_VAR 0 2
13310: PUSH
13311: LD_INT 1
13313: PLUS
13314: ARRAY
13315: PPUSH
13316: LD_INT 8
13318: PPUSH
13319: LD_INT 0
13321: PPUSH
13322: CALL_OW 454
// p := p + 2 ;
13326: LD_ADDR_VAR 0 2
13330: PUSH
13331: LD_VAR 0 2
13335: PUSH
13336: LD_INT 2
13338: PLUS
13339: ST_TO_ADDR
// end ;
13340: GO 13287
13342: POP
13343: POP
// end ;
13344: PPOPN 3
13346: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13347: LD_OWVAR 67
13351: PUSH
13352: LD_INT 1
13354: GREATER
13355: PUSH
13356: LD_INT 22
13358: PPUSH
13359: LD_INT 22
13361: PUSH
13362: LD_OWVAR 2
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: PPUSH
13371: CALL_OW 70
13375: AND
13376: IFFALSE 13580
13378: GO 13380
13380: DISABLE
13381: LD_INT 0
13383: PPUSH
13384: PPUSH
13385: PPUSH
// begin enable ;
13386: ENABLE
// p := 1 ;
13387: LD_ADDR_VAR 0 1
13391: PUSH
13392: LD_INT 1
13394: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13395: LD_ADDR_VAR 0 3
13399: PUSH
13400: LD_INT 123
13402: PUSH
13403: LD_INT 95
13405: PUSH
13406: LD_INT 119
13408: PUSH
13409: LD_INT 89
13411: PUSH
13412: LD_INT 115
13414: PUSH
13415: LD_INT 81
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: ST_TO_ADDR
// for i = 1 to 3 do
13426: LD_ADDR_VAR 0 2
13430: PUSH
13431: DOUBLE
13432: LD_INT 1
13434: DEC
13435: ST_TO_ADDR
13436: LD_INT 3
13438: PUSH
13439: FOR_TO
13440: IFFALSE 13578
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13442: LD_VAR 0 3
13446: PUSH
13447: LD_VAR 0 1
13451: ARRAY
13452: PPUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_VAR 0 1
13462: PUSH
13463: LD_INT 1
13465: PLUS
13466: ARRAY
13467: PPUSH
13468: CALL_OW 428
13472: PUSH
13473: LD_INT 0
13475: GREATER
13476: IFFALSE 13562
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13478: LD_VAR 0 3
13482: PUSH
13483: LD_VAR 0 1
13487: ARRAY
13488: PPUSH
13489: LD_VAR 0 3
13493: PUSH
13494: LD_VAR 0 1
13498: PUSH
13499: LD_INT 1
13501: PLUS
13502: ARRAY
13503: PPUSH
13504: CALL_OW 428
13508: PPUSH
13509: CALL_OW 255
13513: PUSH
13514: LD_OWVAR 2
13518: EQUAL
13519: IFFALSE 13562
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13521: LD_VAR 0 3
13525: PUSH
13526: LD_VAR 0 1
13530: ARRAY
13531: PPUSH
13532: LD_VAR 0 3
13536: PUSH
13537: LD_VAR 0 1
13541: PUSH
13542: LD_INT 1
13544: PLUS
13545: ARRAY
13546: PPUSH
13547: LD_INT 8
13549: PPUSH
13550: CALL_OW 456
// mine_vulc := true ;
13554: LD_ADDR_EXP 12
13558: PUSH
13559: LD_INT 1
13561: ST_TO_ADDR
// end ; p := p + 2 ;
13562: LD_ADDR_VAR 0 1
13566: PUSH
13567: LD_VAR 0 1
13571: PUSH
13572: LD_INT 2
13574: PLUS
13575: ST_TO_ADDR
// end ;
13576: GO 13439
13578: POP
13579: POP
// end ;
13580: PPOPN 3
13582: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13583: LD_INT 22
13585: PUSH
13586: LD_INT 3
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PPUSH
13593: CALL_OW 69
13597: PUSH
13598: LD_INT 0
13600: EQUAL
13601: PUSH
13602: LD_OWVAR 2
13606: PUSH
13607: LD_INT 2
13609: NONEQUAL
13610: AND
13611: IFFALSE 13620
13613: GO 13615
13615: DISABLE
// Win ;
13616: CALL 13677 0 0
13620: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13621: LD_INT 2
13623: PUSH
13624: LD_INT 22
13626: PUSH
13627: LD_INT 8
13629: PUSH
13630: EMPTY
13631: LIST
13632: LIST
13633: PUSH
13634: LD_INT 22
13636: PUSH
13637: LD_INT 3
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: PUSH
13654: LD_INT 0
13656: EQUAL
13657: PUSH
13658: LD_OWVAR 2
13662: PUSH
13663: LD_INT 2
13665: EQUAL
13666: AND
13667: IFFALSE 13676
13669: GO 13671
13671: DISABLE
// Win ;
13672: CALL 13677 0 0
13676: END
// function Win ; var points ; begin
13677: LD_INT 0
13679: PPUSH
13680: PPUSH
// case Query ( VulcWin ) of 1 :
13681: LD_STRING VulcWin
13683: PPUSH
13684: CALL_OW 97
13688: PUSH
13689: LD_INT 1
13691: DOUBLE
13692: EQUAL
13693: IFTRUE 13697
13695: GO 13700
13697: POP
// ; end ;
13698: GO 13701
13700: POP
// if medal_enabled then
13701: LD_EXP 13
13705: IFFALSE 13719
// AddMedal ( vulc_1 , 1 ) else
13707: LD_STRING vulc_1
13709: PPUSH
13710: LD_INT 1
13712: PPUSH
13713: CALL_OW 101
13717: GO 13730
// AddMedal ( vulc_1 , - 1 ) ;
13719: LD_STRING vulc_1
13721: PPUSH
13722: LD_INT 1
13724: NEG
13725: PPUSH
13726: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13730: LD_INT 22
13732: PUSH
13733: LD_INT 8
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: PPUSH
13740: CALL_OW 69
13744: PUSH
13745: LD_INT 0
13747: EQUAL
13748: IFFALSE 13762
// AddMedal ( vulc_2 , 1 ) else
13750: LD_STRING vulc_2
13752: PPUSH
13753: LD_INT 1
13755: PPUSH
13756: CALL_OW 101
13760: GO 13773
// AddMedal ( vulc_2 , - 1 ) ;
13762: LD_STRING vulc_2
13764: PPUSH
13765: LD_INT 1
13767: NEG
13768: PPUSH
13769: CALL_OW 101
// points := CalculateCommanderPoints ;
13773: LD_ADDR_VAR 0 2
13777: PUSH
13778: CALL 2259 0 0
13782: ST_TO_ADDR
// if points >= 2000 then
13783: LD_VAR 0 2
13787: PUSH
13788: LD_INT 2000
13790: GREATEREQUAL
13791: IFFALSE 13805
// AddMedal ( vulc_3 , 2 ) else
13793: LD_STRING vulc_3
13795: PPUSH
13796: LD_INT 2
13798: PPUSH
13799: CALL_OW 101
13803: GO 13838
// if points >= 0 then
13805: LD_VAR 0 2
13809: PUSH
13810: LD_INT 0
13812: GREATEREQUAL
13813: IFFALSE 13827
// AddMedal ( vulc_3 , 1 ) else
13815: LD_STRING vulc_3
13817: PPUSH
13818: LD_INT 1
13820: PPUSH
13821: CALL_OW 101
13825: GO 13838
// AddMedal ( vulc_3 , - 1 ) ;
13827: LD_STRING vulc_3
13829: PPUSH
13830: LD_INT 1
13832: NEG
13833: PPUSH
13834: CALL_OW 101
// GiveMedals ( MAIN ) ;
13838: LD_STRING MAIN
13840: PPUSH
13841: CALL_OW 102
// YouWin ;
13845: CALL_OW 103
// end ; end_of_file
13849: LD_VAR 0 1
13853: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13854: LD_INT 13
13856: PPUSH
13857: LD_INT 21
13859: PUSH
13860: LD_INT 1
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PPUSH
13867: CALL_OW 70
13871: PUSH
13872: LD_INT 0
13874: GREATER
13875: IFFALSE 13942
13877: GO 13879
13879: DISABLE
13880: LD_INT 0
13882: PPUSH
13883: PPUSH
// begin enable ;
13884: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13885: LD_ADDR_VAR 0 1
13889: PUSH
13890: LD_INT 13
13892: PPUSH
13893: LD_INT 21
13895: PUSH
13896: LD_INT 1
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: PPUSH
13903: CALL_OW 70
13907: PUSH
13908: FOR_IN
13909: IFFALSE 13940
// if GetLives ( i ) > 4 then
13911: LD_VAR 0 1
13915: PPUSH
13916: CALL_OW 256
13920: PUSH
13921: LD_INT 4
13923: GREATER
13924: IFFALSE 13938
// SetLives ( i , 4 ) ;
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_INT 4
13933: PPUSH
13934: CALL_OW 234
13938: GO 13908
13940: POP
13941: POP
// end ;
13942: PPOPN 2
13944: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13945: LD_VAR 0 1
13949: PPUSH
13950: CALL_OW 255
13954: PUSH
13955: LD_OWVAR 2
13959: EQUAL
13960: IFFALSE 13970
// player_res_art := true ;
13962: LD_ADDR_EXP 6
13966: PUSH
13967: LD_INT 1
13969: ST_TO_ADDR
// end ;
13970: PPOPN 1
13972: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13973: LD_INT 22
13975: PUSH
13976: LD_OWVAR 2
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: LD_INT 2
13987: PUSH
13988: LD_INT 30
13990: PUSH
13991: LD_INT 8
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: PUSH
13998: LD_INT 30
14000: PUSH
14001: LD_INT 11
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: LIST
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PPUSH
14017: CALL_OW 69
14021: PUSH
14022: LD_EXP 6
14026: AND
14027: IFFALSE 14371
14029: GO 14031
14031: DISABLE
14032: LD_INT 0
14034: PPUSH
14035: PPUSH
14036: PPUSH
// begin enable ;
14037: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14038: LD_ADDR_VAR 0 1
14042: PUSH
14043: LD_INT 1
14045: PPUSH
14046: CALL_OW 469
14050: PUSH
14051: LD_INT 1
14053: ARRAY
14054: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14055: LD_ADDR_VAR 0 2
14059: PUSH
14060: LD_INT 1
14062: PPUSH
14063: CALL_OW 469
14067: PUSH
14068: LD_INT 2
14070: ARRAY
14071: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14072: LD_ADDR_VAR 0 3
14076: PUSH
14077: LD_INT 22
14079: PUSH
14080: LD_OWVAR 2
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 2
14091: PUSH
14092: LD_INT 30
14094: PUSH
14095: LD_INT 8
14097: PUSH
14098: EMPTY
14099: LIST
14100: LIST
14101: PUSH
14102: LD_INT 30
14104: PUSH
14105: LD_INT 11
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: LIST
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: PPUSH
14121: CALL_OW 69
14125: PPUSH
14126: LD_VAR 0 1
14130: PPUSH
14131: LD_VAR 0 2
14135: PPUSH
14136: CALL_OW 73
14140: ST_TO_ADDR
// if player_artifact_ready = false then
14141: LD_EXP 7
14145: PUSH
14146: LD_INT 0
14148: EQUAL
14149: IFFALSE 14255
// if GetDistUnitXY ( lab , x , y ) < 6 then
14151: LD_VAR 0 3
14155: PPUSH
14156: LD_VAR 0 1
14160: PPUSH
14161: LD_VAR 0 2
14165: PPUSH
14166: CALL_OW 297
14170: PUSH
14171: LD_INT 6
14173: LESS
14174: IFFALSE 14235
// begin if BuildingStatus ( lab ) = bs_idle then
14176: LD_VAR 0 3
14180: PPUSH
14181: CALL_OW 461
14185: PUSH
14186: LD_INT 2
14188: EQUAL
14189: IFFALSE 14213
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14191: LD_OWVAR 2
14195: PPUSH
14196: LD_INT 1
14198: PPUSH
14199: LD_INT 2
14201: PPUSH
14202: LD_VAR 0 3
14206: PPUSH
14207: CALL_OW 468
14211: GO 14233
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14213: LD_OWVAR 2
14217: PPUSH
14218: LD_INT 1
14220: PPUSH
14221: LD_INT 1
14223: PPUSH
14224: LD_VAR 0 3
14228: PPUSH
14229: CALL_OW 468
// end else
14233: GO 14255
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14235: LD_OWVAR 2
14239: PPUSH
14240: LD_INT 1
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: LD_VAR 0 3
14250: PPUSH
14251: CALL_OW 468
// if player_artifact_ready then
14255: LD_EXP 7
14259: IFFALSE 14371
// if GetDistUnitXY ( lab , x , y ) < 6 then
14261: LD_VAR 0 3
14265: PPUSH
14266: LD_VAR 0 1
14270: PPUSH
14271: LD_VAR 0 2
14275: PPUSH
14276: CALL_OW 297
14280: PUSH
14281: LD_INT 6
14283: LESS
14284: IFFALSE 14349
// begin if BuildingStatus ( lab ) = bs_idle then
14286: LD_VAR 0 3
14290: PPUSH
14291: CALL_OW 461
14295: PUSH
14296: LD_INT 2
14298: EQUAL
14299: IFFALSE 14325
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14301: LD_OWVAR 2
14305: PPUSH
14306: LD_EXP 8
14310: PPUSH
14311: LD_INT 4
14313: PPUSH
14314: LD_VAR 0 3
14318: PPUSH
14319: CALL_OW 468
14323: GO 14347
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14325: LD_OWVAR 2
14329: PPUSH
14330: LD_EXP 8
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_VAR 0 3
14342: PPUSH
14343: CALL_OW 468
// end else
14347: GO 14371
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14349: LD_OWVAR 2
14353: PPUSH
14354: LD_EXP 8
14358: PPUSH
14359: LD_INT 1
14361: PPUSH
14362: LD_VAR 0 3
14366: PPUSH
14367: CALL_OW 468
// end ;
14371: PPOPN 3
14373: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14374: LD_INT 0
14376: PPUSH
14377: PPUSH
14378: PPUSH
14379: PPUSH
14380: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14381: LD_ADDR_VAR 0 5
14385: PUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 469
14393: PUSH
14394: LD_INT 1
14396: ARRAY
14397: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14398: LD_ADDR_VAR 0 6
14402: PUSH
14403: LD_INT 1
14405: PPUSH
14406: CALL_OW 469
14410: PUSH
14411: LD_INT 2
14413: ARRAY
14414: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14415: LD_ADDR_VAR 0 8
14419: PUSH
14420: LD_INT 22
14422: PUSH
14423: LD_OWVAR 2
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PUSH
14432: LD_INT 2
14434: PUSH
14435: LD_INT 30
14437: PUSH
14438: LD_INT 8
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 30
14447: PUSH
14448: LD_INT 11
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: PUSH
14460: EMPTY
14461: LIST
14462: LIST
14463: PPUSH
14464: CALL_OW 69
14468: PPUSH
14469: LD_VAR 0 5
14473: PPUSH
14474: LD_VAR 0 6
14478: PPUSH
14479: CALL_OW 73
14483: ST_TO_ADDR
// if icon = art_exp_left then
14484: LD_VAR 0 2
14488: PUSH
14489: LD_INT 1
14491: EQUAL
14492: IFFALSE 14531
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14494: LD_VAR 0 8
14498: PPUSH
14499: LD_EXP 9
14503: PPUSH
14504: LD_INT 1
14506: PPUSH
14507: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14511: LD_OWVAR 2
14515: PPUSH
14516: LD_INT 1
14518: PPUSH
14519: LD_INT 0
14521: PPUSH
14522: LD_VAR 0 8
14526: PPUSH
14527: CALL_OW 468
// end ; if icon = art_icon then
14531: LD_VAR 0 2
14535: PUSH
14536: LD_EXP 8
14540: EQUAL
14541: IFFALSE 14755
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14543: LD_VAR 0 3
14547: PUSH
14548: LD_INT 21
14550: PUSH
14551: LD_INT 3
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 69
14562: IN
14563: IFFALSE 14755
// begin side := GetSide ( cr1 ) ;
14565: LD_ADDR_VAR 0 9
14569: PUSH
14570: LD_VAR 0 3
14574: PPUSH
14575: CALL_OW 255
14579: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14580: LD_INT 22
14582: PUSH
14583: LD_VAR 0 9
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: PUSH
14592: LD_INT 30
14594: PUSH
14595: LD_INT 28
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PPUSH
14606: CALL_OW 69
14610: PUSH
14611: LD_INT 0
14613: GREATER
14614: IFFALSE 14755
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14616: LD_ADDR_VAR 0 7
14620: PUSH
14621: LD_INT 22
14623: PUSH
14624: LD_VAR 0 9
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: LD_INT 2
14635: PUSH
14636: LD_INT 30
14638: PUSH
14639: LD_INT 26
14641: PUSH
14642: EMPTY
14643: LIST
14644: LIST
14645: PUSH
14646: LD_INT 30
14648: PUSH
14649: LD_INT 27
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PUSH
14656: LD_INT 30
14658: PUSH
14659: LD_INT 28
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PPUSH
14676: CALL_OW 69
14680: PUSH
14681: FOR_IN
14682: IFFALSE 14698
// SetLives ( i , 1 ) ;
14684: LD_VAR 0 7
14688: PPUSH
14689: LD_INT 1
14691: PPUSH
14692: CALL_OW 234
14696: GO 14681
14698: POP
14699: POP
// player_res_art := false ;
14700: LD_ADDR_EXP 6
14704: PUSH
14705: LD_INT 0
14707: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14708: LD_OWVAR 2
14712: PPUSH
14713: LD_EXP 8
14717: PPUSH
14718: LD_INT 1
14720: PPUSH
14721: LD_VAR 0 8
14725: PPUSH
14726: CALL_OW 468
// Wait ( time_to_reuse ) ;
14730: LD_EXP 11
14734: PPUSH
14735: CALL_OW 67
// player_res_art := true ;
14739: LD_ADDR_EXP 6
14743: PUSH
14744: LD_INT 1
14746: ST_TO_ADDR
// medal_enabled := true ;
14747: LD_ADDR_EXP 13
14751: PUSH
14752: LD_INT 1
14754: ST_TO_ADDR
// end ; end ; end ; end ;
14755: PPOPN 9
14757: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14758: LD_VAR 0 1
14762: PPUSH
14763: CALL_OW 255
14767: PUSH
14768: LD_OWVAR 2
14772: EQUAL
14773: IFFALSE 14810
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14775: LD_OWVAR 2
14779: PPUSH
14780: LD_INT 1
14782: PPUSH
14783: LD_INT 0
14785: PPUSH
14786: LD_VAR 0 1
14790: PPUSH
14791: CALL_OW 468
// player_artifact_ready := true ;
14795: LD_ADDR_EXP 7
14799: PUSH
14800: LD_INT 1
14802: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14803: LD_STRING ArtVulcano
14805: PPUSH
14806: CALL_OW 339
// end ; end ;
14810: PPOPN 1
14812: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14813: LD_OWVAR 2
14817: PPUSH
14818: LD_INT 1
14820: PPUSH
14821: LD_INT 2
14823: PPUSH
14824: LD_VAR 0 1
14828: PPUSH
14829: CALL_OW 468
// end ; end_of_file
14833: PPOPN 2
14835: END
// every 0 0$01 do
14836: GO 14838
14838: DISABLE
// begin enable ;
14839: ENABLE
// Display_Strings := [ #tick , tick ] ;
14840: LD_ADDR_OWVAR 47
14844: PUSH
14845: LD_STRING #tick
14847: PUSH
14848: LD_OWVAR 1
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: ST_TO_ADDR
// end ; end_of_file
14857: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14858: LD_INT 0
14860: PPUSH
14861: PPUSH
14862: PPUSH
14863: PPUSH
14864: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14865: LD_ADDR_EXP 39
14869: PUSH
14870: LD_INT 7
14872: PUSH
14873: LD_INT 6
14875: PUSH
14876: LD_INT 5
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: PUSH
14884: LD_OWVAR 67
14888: ARRAY
14889: ST_TO_ADDR
// al_force := [ ] ;
14890: LD_ADDR_EXP 38
14894: PUSH
14895: EMPTY
14896: ST_TO_ADDR
// RemoveAlliance ;
14897: CALL 15275 0 0
// ResetFog ;
14901: CALL_OW 335
// your_side := 7 ;
14905: LD_ADDR_OWVAR 2
14909: PUSH
14910: LD_INT 7
14912: ST_TO_ADDR
// uc_side := 7 ;
14913: LD_ADDR_OWVAR 20
14917: PUSH
14918: LD_INT 7
14920: ST_TO_ADDR
// hc_gallery :=  ;
14921: LD_ADDR_OWVAR 33
14925: PUSH
14926: LD_STRING 
14928: ST_TO_ADDR
// hc_name :=  ;
14929: LD_ADDR_OWVAR 26
14933: PUSH
14934: LD_STRING 
14936: ST_TO_ADDR
// hc_importance := 0 ;
14937: LD_ADDR_OWVAR 32
14941: PUSH
14942: LD_INT 0
14944: ST_TO_ADDR
// for i = 1 to 17 do
14945: LD_ADDR_VAR 0 2
14949: PUSH
14950: DOUBLE
14951: LD_INT 1
14953: DEC
14954: ST_TO_ADDR
14955: LD_INT 17
14957: PUSH
14958: FOR_TO
14959: IFFALSE 15039
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14961: LD_ADDR_OWVAR 21
14965: PUSH
14966: LD_INT 1
14968: PUSH
14969: LD_INT 3
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: PUSH
14976: LD_INT 1
14978: PPUSH
14979: LD_INT 2
14981: PPUSH
14982: CALL_OW 12
14986: ARRAY
14987: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14988: LD_INT 0
14990: PPUSH
14991: LD_INT 1
14993: PPUSH
14994: LD_INT 4
14996: PPUSH
14997: CALL_OW 12
15001: PPUSH
15002: LD_EXP 39
15006: PPUSH
15007: CALL_OW 380
// un := CreateHuman ;
15011: LD_ADDR_VAR 0 4
15015: PUSH
15016: CALL_OW 44
15020: ST_TO_ADDR
// al_force := al_force ^ un ;
15021: LD_ADDR_EXP 38
15025: PUSH
15026: LD_EXP 38
15030: PUSH
15031: LD_VAR 0 4
15035: ADD
15036: ST_TO_ADDR
// end ;
15037: GO 14958
15039: POP
15040: POP
// hc_importance := 100 ;
15041: LD_ADDR_OWVAR 32
15045: PUSH
15046: LD_INT 100
15048: ST_TO_ADDR
// uc_nation := 1 ;
15049: LD_ADDR_OWVAR 21
15053: PUSH
15054: LD_INT 1
15056: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15057: LD_INT 1
15059: PPUSH
15060: LD_INT 1
15062: PPUSH
15063: LD_EXP 39
15067: PPUSH
15068: CALL_OW 380
// al_commander := CreateHuman ;
15072: LD_ADDR_EXP 37
15076: PUSH
15077: CALL_OW 44
15081: ST_TO_ADDR
// player_commander := al_commander ;
15082: LD_ADDR_EXP 10
15086: PUSH
15087: LD_EXP 37
15091: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15092: LD_ADDR_VAR 0 5
15096: PUSH
15097: LD_STRING text
15099: PPUSH
15100: LD_INT 9
15102: PUSH
15103: LD_INT 9
15105: PUSH
15106: LD_INT 8
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: LIST
15113: PUSH
15114: LD_OWVAR 67
15118: ARRAY
15119: PPUSH
15120: LD_INT 9
15122: PUSH
15123: LD_INT 9
15125: PUSH
15126: LD_INT 8
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: LIST
15133: PUSH
15134: LD_OWVAR 67
15138: ARRAY
15139: PPUSH
15140: LD_INT -5
15142: PUSH
15143: LD_EXP 37
15147: PUSH
15148: LD_INT -3
15150: PUSH
15151: LD_INT -2
15153: PUSH
15154: EMPTY
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: PUSH
15160: LD_EXP 38
15164: ADD
15165: PPUSH
15166: LD_INT 1
15168: PUSH
15169: LD_INT 3
15171: PUSH
15172: LD_INT 2
15174: PUSH
15175: LD_INT 1
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 4
15184: PUSH
15185: LD_INT 1
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 9
15194: PUSH
15195: LD_INT 5
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 42
15210: ST_TO_ADDR
// team := team ^ al_commander ;
15211: LD_ADDR_VAR 0 5
15215: PUSH
15216: LD_VAR 0 5
15220: PUSH
15221: LD_EXP 37
15225: ADD
15226: ST_TO_ADDR
// for i = 1 to team do
15227: LD_ADDR_VAR 0 2
15231: PUSH
15232: DOUBLE
15233: LD_INT 1
15235: DEC
15236: ST_TO_ADDR
15237: LD_VAR 0 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15268
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15245: LD_VAR 0 5
15249: PUSH
15250: LD_VAR 0 2
15254: ARRAY
15255: PPUSH
15256: LD_INT 15
15258: PPUSH
15259: LD_INT 0
15261: PPUSH
15262: CALL_OW 49
15266: GO 15242
15268: POP
15269: POP
// end ;
15270: LD_VAR 0 1
15274: RET
// export function RemoveAlliance ; var i ; begin
15275: LD_INT 0
15277: PPUSH
15278: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15279: LD_INT 22
15281: PUSH
15282: LD_INT 7
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: PUSH
15289: LD_INT 30
15291: PUSH
15292: LD_INT 1
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: PPUSH
15303: CALL_OW 69
15307: PUSH
15308: LD_INT 1
15310: ARRAY
15311: PPUSH
15312: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15316: LD_ADDR_VAR 0 2
15320: PUSH
15321: LD_INT 22
15323: PUSH
15324: LD_INT 7
15326: PUSH
15327: EMPTY
15328: LIST
15329: LIST
15330: PPUSH
15331: CALL_OW 69
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15350
// RemoveUnit ( i ) ;
15339: LD_VAR 0 2
15343: PPUSH
15344: CALL_OW 64
15348: GO 15336
15350: POP
15351: POP
// end ;
15352: LD_VAR 0 1
15356: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15357: LD_INT 0
15359: PPUSH
15360: PPUSH
15361: PPUSH
15362: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15363: LD_INT 31
15365: PPUSH
15366: LD_INT 7
15368: PPUSH
15369: LD_INT 2
15371: PPUSH
15372: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15376: LD_INT 32
15378: PPUSH
15379: LD_INT 7
15381: PPUSH
15382: LD_INT 2
15384: PPUSH
15385: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15389: LD_INT 59
15391: PPUSH
15392: LD_INT 7
15394: PPUSH
15395: LD_INT 2
15397: PPUSH
15398: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15402: LD_ADDR_EXP 39
15406: PUSH
15407: LD_INT 5
15409: PUSH
15410: LD_INT 6
15412: PUSH
15413: LD_INT 7
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: LIST
15420: PUSH
15421: LD_OWVAR 67
15425: ARRAY
15426: ST_TO_ADDR
// al_force := [ ] ;
15427: LD_ADDR_EXP 38
15431: PUSH
15432: EMPTY
15433: ST_TO_ADDR
// al_vehs := [ ] ;
15434: LD_ADDR_EXP 44
15438: PUSH
15439: EMPTY
15440: ST_TO_ADDR
// uc_side := 7 ;
15441: LD_ADDR_OWVAR 20
15445: PUSH
15446: LD_INT 7
15448: ST_TO_ADDR
// uc_nation := 1 ;
15449: LD_ADDR_OWVAR 21
15453: PUSH
15454: LD_INT 1
15456: ST_TO_ADDR
// bc_type := b_oil_mine ;
15457: LD_ADDR_OWVAR 42
15461: PUSH
15462: LD_INT 29
15464: ST_TO_ADDR
// b := CreateBuilding ;
15465: LD_ADDR_VAR 0 4
15469: PUSH
15470: CALL_OW 46
15474: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15475: LD_VAR 0 4
15479: PPUSH
15480: LD_INT 61
15482: PPUSH
15483: LD_INT 7
15485: PPUSH
15486: LD_INT 0
15488: PPUSH
15489: LD_INT 0
15491: PPUSH
15492: CALL_OW 50
// bc_type := b_siberite_mine ;
15496: LD_ADDR_OWVAR 42
15500: PUSH
15501: LD_INT 30
15503: ST_TO_ADDR
// b := CreateBuilding ;
15504: LD_ADDR_VAR 0 4
15508: PUSH
15509: CALL_OW 46
15513: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15514: LD_VAR 0 4
15518: PPUSH
15519: LD_INT 69
15521: PPUSH
15522: LD_INT 13
15524: PPUSH
15525: LD_INT 0
15527: PPUSH
15528: LD_INT 0
15530: PPUSH
15531: CALL_OW 50
// hc_gallery :=  ;
15535: LD_ADDR_OWVAR 33
15539: PUSH
15540: LD_STRING 
15542: ST_TO_ADDR
// hc_name :=  ;
15543: LD_ADDR_OWVAR 26
15547: PUSH
15548: LD_STRING 
15550: ST_TO_ADDR
// hc_importance := 0 ;
15551: LD_ADDR_OWVAR 32
15555: PUSH
15556: LD_INT 0
15558: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15559: LD_ADDR_VAR 0 2
15563: PUSH
15564: LD_INT 22
15566: PUSH
15567: LD_INT 7
15569: PUSH
15570: EMPTY
15571: LIST
15572: LIST
15573: PUSH
15574: LD_INT 30
15576: PUSH
15577: LD_INT 32
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: PPUSH
15588: CALL_OW 69
15592: PUSH
15593: FOR_IN
15594: IFFALSE 15664
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15596: LD_ADDR_OWVAR 21
15600: PUSH
15601: LD_INT 1
15603: PUSH
15604: LD_INT 3
15606: PUSH
15607: EMPTY
15608: LIST
15609: LIST
15610: PUSH
15611: LD_INT 1
15613: PPUSH
15614: LD_INT 2
15616: PPUSH
15617: CALL_OW 12
15621: ARRAY
15622: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15623: LD_INT 0
15625: PPUSH
15626: LD_INT 1
15628: PPUSH
15629: LD_EXP 39
15633: PPUSH
15634: CALL_OW 380
// un := CreateHuman ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: CALL_OW 44
15647: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15648: LD_VAR 0 3
15652: PPUSH
15653: LD_VAR 0 2
15657: PPUSH
15658: CALL_OW 52
// end ;
15662: GO 15593
15664: POP
15665: POP
// for i = 1 to 3 do
15666: LD_ADDR_VAR 0 2
15670: PUSH
15671: DOUBLE
15672: LD_INT 1
15674: DEC
15675: ST_TO_ADDR
15676: LD_INT 3
15678: PUSH
15679: FOR_TO
15680: IFFALSE 15748
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15682: LD_ADDR_OWVAR 21
15686: PUSH
15687: LD_INT 1
15689: PUSH
15690: LD_INT 3
15692: PUSH
15693: EMPTY
15694: LIST
15695: LIST
15696: PUSH
15697: LD_INT 1
15699: PPUSH
15700: LD_INT 2
15702: PPUSH
15703: CALL_OW 12
15707: ARRAY
15708: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15709: LD_INT 0
15711: PPUSH
15712: LD_INT 4
15714: PPUSH
15715: LD_EXP 39
15719: PPUSH
15720: CALL_OW 380
// un := CreateHuman ;
15724: LD_ADDR_VAR 0 3
15728: PUSH
15729: CALL_OW 44
15733: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15734: LD_VAR 0 3
15738: PPUSH
15739: LD_INT 164
15741: PPUSH
15742: CALL_OW 52
// end ;
15746: GO 15679
15748: POP
15749: POP
// for i = 1 to 6 do
15750: LD_ADDR_VAR 0 2
15754: PUSH
15755: DOUBLE
15756: LD_INT 1
15758: DEC
15759: ST_TO_ADDR
15760: LD_INT 6
15762: PUSH
15763: FOR_TO
15764: IFFALSE 15855
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15766: LD_ADDR_OWVAR 21
15770: PUSH
15771: LD_INT 1
15773: PUSH
15774: LD_INT 3
15776: PUSH
15777: EMPTY
15778: LIST
15779: LIST
15780: PUSH
15781: LD_INT 1
15783: PPUSH
15784: LD_INT 2
15786: PPUSH
15787: CALL_OW 12
15791: ARRAY
15792: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15793: LD_INT 0
15795: PPUSH
15796: LD_INT 5
15798: PUSH
15799: LD_INT 9
15801: PUSH
15802: LD_INT 9
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: LIST
15809: PUSH
15810: LD_INT 1
15812: PPUSH
15813: LD_INT 3
15815: PPUSH
15816: CALL_OW 12
15820: ARRAY
15821: PPUSH
15822: LD_EXP 39
15826: PPUSH
15827: CALL_OW 380
// un := CreateHuman ;
15831: LD_ADDR_VAR 0 3
15835: PUSH
15836: CALL_OW 44
15840: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15841: LD_VAR 0 3
15845: PPUSH
15846: LD_INT 173
15848: PPUSH
15849: CALL_OW 52
// end ;
15853: GO 15763
15855: POP
15856: POP
// for i = 1 to 6 do
15857: LD_ADDR_VAR 0 2
15861: PUSH
15862: DOUBLE
15863: LD_INT 1
15865: DEC
15866: ST_TO_ADDR
15867: LD_INT 6
15869: PUSH
15870: FOR_TO
15871: IFFALSE 15969
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15873: LD_ADDR_OWVAR 21
15877: PUSH
15878: LD_INT 1
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: PUSH
15888: LD_INT 1
15890: PPUSH
15891: LD_INT 2
15893: PPUSH
15894: CALL_OW 12
15898: ARRAY
15899: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15900: LD_INT 0
15902: PPUSH
15903: LD_INT 3
15905: PPUSH
15906: LD_EXP 39
15910: PPUSH
15911: CALL_OW 380
// un := CreateHuman ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: CALL_OW 44
15924: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15925: LD_VAR 0 3
15929: PPUSH
15930: LD_INT 22
15932: PUSH
15933: LD_INT 7
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: LD_INT 30
15942: PUSH
15943: LD_INT 3
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PPUSH
15954: CALL_OW 69
15958: PUSH
15959: LD_INT 1
15961: ARRAY
15962: PPUSH
15963: CALL_OW 52
// end ;
15967: GO 15870
15969: POP
15970: POP
// for i = 1 to 4 do
15971: LD_ADDR_VAR 0 2
15975: PUSH
15976: DOUBLE
15977: LD_INT 1
15979: DEC
15980: ST_TO_ADDR
15981: LD_INT 4
15983: PUSH
15984: FOR_TO
15985: IFFALSE 16053
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15987: LD_ADDR_OWVAR 21
15991: PUSH
15992: LD_INT 1
15994: PUSH
15995: LD_INT 3
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: PUSH
16002: LD_INT 1
16004: PPUSH
16005: LD_INT 2
16007: PPUSH
16008: CALL_OW 12
16012: ARRAY
16013: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16014: LD_INT 0
16016: PPUSH
16017: LD_INT 2
16019: PPUSH
16020: LD_EXP 39
16024: PPUSH
16025: CALL_OW 380
// un := CreateHuman ;
16029: LD_ADDR_VAR 0 3
16033: PUSH
16034: CALL_OW 44
16038: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16039: LD_VAR 0 3
16043: PPUSH
16044: LD_INT 162
16046: PPUSH
16047: CALL_OW 52
// end ;
16051: GO 15984
16053: POP
16054: POP
// uc_nation := 3 ;
16055: LD_ADDR_OWVAR 21
16059: PUSH
16060: LD_INT 3
16062: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16063: LD_ADDR_OWVAR 37
16067: PUSH
16068: LD_INT 21
16070: ST_TO_ADDR
// vc_engine := engine_siberite ;
16071: LD_ADDR_OWVAR 39
16075: PUSH
16076: LD_INT 3
16078: ST_TO_ADDR
// vc_control := control_computer ;
16079: LD_ADDR_OWVAR 38
16083: PUSH
16084: LD_INT 3
16086: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16087: LD_ADDR_OWVAR 40
16091: PUSH
16092: LD_INT 51
16094: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16095: CALL_OW 45
16099: PPUSH
16100: LD_INT 49
16102: PPUSH
16103: LD_INT 13
16105: PPUSH
16106: LD_INT 0
16108: PPUSH
16109: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16113: LD_ADDR_EXP 46
16117: PUSH
16118: LD_INT 22
16120: PUSH
16121: LD_INT 7
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: PUSH
16128: LD_INT 30
16130: PUSH
16131: LD_INT 33
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PPUSH
16142: CALL_OW 69
16146: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16147: LD_ADDR_VAR 0 2
16151: PUSH
16152: DOUBLE
16153: LD_INT 1
16155: DEC
16156: ST_TO_ADDR
16157: LD_INT 22
16159: PUSH
16160: LD_INT 7
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: LD_INT 30
16169: PUSH
16170: LD_INT 33
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PUSH
16177: LD_INT 35
16179: PUSH
16180: LD_INT 0
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: LIST
16191: PUSH
16192: EMPTY
16193: LIST
16194: PPUSH
16195: CALL_OW 69
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16261
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16203: LD_INT 22
16205: PUSH
16206: LD_INT 7
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: LD_INT 30
16215: PUSH
16216: LD_INT 33
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: LD_INT 35
16225: PUSH
16226: LD_INT 0
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: LIST
16237: PUSH
16238: EMPTY
16239: LIST
16240: PPUSH
16241: CALL_OW 69
16245: PUSH
16246: LD_VAR 0 2
16250: ARRAY
16251: PPUSH
16252: LD_INT 49
16254: PPUSH
16255: CALL_OW 208
16259: GO 16200
16261: POP
16262: POP
// end ;
16263: LD_VAR 0 1
16267: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16268: LD_OWVAR 2
16272: PUSH
16273: LD_INT 1
16275: EQUAL
16276: IFFALSE 17444
16278: GO 16280
16280: DISABLE
16281: LD_INT 0
16283: PPUSH
16284: PPUSH
16285: PPUSH
16286: PPUSH
// begin enable ;
16287: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16288: LD_ADDR_EXP 50
16292: PUSH
16293: LD_INT 22
16295: PUSH
16296: LD_INT 7
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 21
16305: PUSH
16306: LD_INT 3
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PPUSH
16317: CALL_OW 69
16321: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16322: LD_ADDR_EXP 48
16326: PUSH
16327: LD_INT 164
16329: PUSH
16330: LD_INT 197
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16337: LD_ADDR_EXP 47
16341: PUSH
16342: LD_INT 22
16344: PUSH
16345: LD_INT 7
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: LD_INT 30
16354: PUSH
16355: LD_INT 1
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PPUSH
16366: CALL_OW 69
16370: PUSH
16371: LD_INT 1
16373: ARRAY
16374: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16375: LD_ADDR_EXP 49
16379: PUSH
16380: LD_INT 22
16382: PUSH
16383: LD_INT 7
16385: PUSH
16386: EMPTY
16387: LIST
16388: LIST
16389: PUSH
16390: LD_INT 30
16392: PUSH
16393: LD_INT 3
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: PPUSH
16404: CALL_OW 69
16408: PUSH
16409: LD_INT 1
16411: ARRAY
16412: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16413: LD_INT 22
16415: PUSH
16416: LD_INT 7
16418: PUSH
16419: EMPTY
16420: LIST
16421: LIST
16422: PUSH
16423: LD_INT 34
16425: PUSH
16426: LD_INT 51
16428: PUSH
16429: EMPTY
16430: LIST
16431: LIST
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PPUSH
16437: CALL_OW 69
16441: IFFALSE 16481
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16443: LD_ADDR_EXP 45
16447: PUSH
16448: LD_INT 22
16450: PUSH
16451: LD_INT 7
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: PUSH
16458: LD_INT 34
16460: PUSH
16461: LD_INT 51
16463: PUSH
16464: EMPTY
16465: LIST
16466: LIST
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PPUSH
16472: CALL_OW 69
16476: PUSH
16477: LD_INT 1
16479: ARRAY
16480: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16481: LD_ADDR_EXP 41
16485: PUSH
16486: LD_INT 22
16488: PUSH
16489: LD_INT 7
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 25
16498: PUSH
16499: LD_INT 9
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16515: LD_ADDR_EXP 40
16519: PUSH
16520: LD_INT 22
16522: PUSH
16523: LD_INT 7
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 25
16532: PUSH
16533: LD_INT 2
16535: PUSH
16536: EMPTY
16537: LIST
16538: LIST
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16549: LD_ADDR_EXP 42
16553: PUSH
16554: LD_INT 22
16556: PUSH
16557: LD_INT 7
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: PUSH
16564: LD_INT 25
16566: PUSH
16567: LD_INT 3
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PPUSH
16578: CALL_OW 69
16582: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16583: LD_ADDR_EXP 43
16587: PUSH
16588: LD_INT 22
16590: PUSH
16591: LD_INT 7
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: PUSH
16598: LD_INT 25
16600: PUSH
16601: LD_INT 4
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PPUSH
16612: CALL_OW 69
16616: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16617: LD_EXP 41
16621: PPUSH
16622: LD_INT 81
16624: PUSH
16625: LD_INT 7
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: PPUSH
16632: CALL_OW 69
16636: PPUSH
16637: CALL 1656 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16641: LD_EXP 45
16645: PPUSH
16646: CALL_OW 314
16650: NOT
16651: PUSH
16652: LD_EXP 45
16656: PPUSH
16657: LD_INT 1
16659: PPUSH
16660: CALL_OW 289
16664: PUSH
16665: LD_INT 100
16667: LESS
16668: AND
16669: IFFALSE 16717
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16671: LD_ADDR_VAR 0 4
16675: PUSH
16676: LD_INT 12
16678: PPUSH
16679: CALL_OW 435
16683: ST_TO_ADDR
// if cr then
16684: LD_VAR 0 4
16688: IFFALSE 16717
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16690: LD_EXP 45
16694: PPUSH
16695: LD_VAR 0 4
16699: PUSH
16700: LD_INT 1
16702: ARRAY
16703: PPUSH
16704: LD_VAR 0 4
16708: PUSH
16709: LD_INT 2
16711: ARRAY
16712: PPUSH
16713: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16717: LD_EXP 50
16721: PPUSH
16722: LD_INT 3
16724: PUSH
16725: LD_INT 24
16727: PUSH
16728: LD_INT 1000
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL_OW 72
16743: IFFALSE 16873
// begin if al_eng then
16745: LD_EXP 40
16749: IFFALSE 16871
// for i = 1 to al_eng do
16751: LD_ADDR_VAR 0 1
16755: PUSH
16756: DOUBLE
16757: LD_INT 1
16759: DEC
16760: ST_TO_ADDR
16761: LD_EXP 40
16765: PUSH
16766: FOR_TO
16767: IFFALSE 16869
// if IsInUnit ( al_eng [ i ] ) then
16769: LD_EXP 40
16773: PUSH
16774: LD_VAR 0 1
16778: ARRAY
16779: PPUSH
16780: CALL_OW 310
16784: IFFALSE 16803
// ComExitBuilding ( al_eng [ i ] ) else
16786: LD_EXP 40
16790: PUSH
16791: LD_VAR 0 1
16795: ARRAY
16796: PPUSH
16797: CALL_OW 122
16801: GO 16867
// if not HasTask ( al_eng [ i ] ) then
16803: LD_EXP 40
16807: PUSH
16808: LD_VAR 0 1
16812: ARRAY
16813: PPUSH
16814: CALL_OW 314
16818: NOT
16819: IFFALSE 16867
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16821: LD_EXP 40
16825: PUSH
16826: LD_VAR 0 1
16830: ARRAY
16831: PPUSH
16832: LD_EXP 50
16836: PPUSH
16837: LD_INT 3
16839: PUSH
16840: LD_INT 24
16842: PUSH
16843: LD_INT 1000
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 72
16858: PUSH
16859: LD_INT 1
16861: ARRAY
16862: PPUSH
16863: CALL_OW 130
16867: GO 16766
16869: POP
16870: POP
// end else
16871: GO 16955
// if al_eng then
16873: LD_EXP 40
16877: IFFALSE 16955
// if not IsInUnit ( al_eng [ 1 ] ) then
16879: LD_EXP 40
16883: PUSH
16884: LD_INT 1
16886: ARRAY
16887: PPUSH
16888: CALL_OW 310
16892: NOT
16893: IFFALSE 16955
// for i = 1 to al_eng do
16895: LD_ADDR_VAR 0 1
16899: PUSH
16900: DOUBLE
16901: LD_INT 1
16903: DEC
16904: ST_TO_ADDR
16905: LD_EXP 40
16909: PUSH
16910: FOR_TO
16911: IFFALSE 16953
// if not IsInUnit ( al_eng [ i ] ) then
16913: LD_EXP 40
16917: PUSH
16918: LD_VAR 0 1
16922: ARRAY
16923: PPUSH
16924: CALL_OW 310
16928: NOT
16929: IFFALSE 16951
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16931: LD_EXP 40
16935: PUSH
16936: LD_VAR 0 1
16940: ARRAY
16941: PPUSH
16942: LD_EXP 47
16946: PPUSH
16947: CALL_OW 120
16951: GO 16910
16953: POP
16954: POP
// if al_vehs then
16955: LD_EXP 44
16959: IFFALSE 17059
// if BuildingStatus ( al_fac ) = bs_idle then
16961: LD_EXP 49
16965: PPUSH
16966: CALL_OW 461
16970: PUSH
16971: LD_INT 2
16973: EQUAL
16974: IFFALSE 17059
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16976: LD_EXP 49
16980: PPUSH
16981: LD_EXP 44
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: PPUSH
16990: LD_EXP 44
16994: PUSH
16995: LD_INT 2
16997: ARRAY
16998: PPUSH
16999: LD_EXP 44
17003: PUSH
17004: LD_INT 3
17006: ARRAY
17007: PPUSH
17008: LD_EXP 44
17012: PUSH
17013: LD_INT 4
17015: ARRAY
17016: PPUSH
17017: CALL_OW 125
// for i = 1 to 4 do
17021: LD_ADDR_VAR 0 1
17025: PUSH
17026: DOUBLE
17027: LD_INT 1
17029: DEC
17030: ST_TO_ADDR
17031: LD_INT 4
17033: PUSH
17034: FOR_TO
17035: IFFALSE 17057
// al_vehs := Delete ( al_vehs , 1 ) ;
17037: LD_ADDR_EXP 44
17041: PUSH
17042: LD_EXP 44
17046: PPUSH
17047: LD_INT 1
17049: PPUSH
17050: CALL_OW 3
17054: ST_TO_ADDR
17055: GO 17034
17057: POP
17058: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17059: LD_EXP 38
17063: PUSH
17064: LD_INT 0
17066: EQUAL
17067: PUSH
17068: LD_OWVAR 1
17072: PUSH
17073: LD_INT 23100
17075: MOD
17076: PUSH
17077: LD_INT 0
17079: EQUAL
17080: AND
17081: IFFALSE 17195
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17083: LD_ADDR_VAR 0 1
17087: PUSH
17088: DOUBLE
17089: LD_INT 1
17091: DEC
17092: ST_TO_ADDR
17093: LD_INT 4
17095: PUSH
17096: LD_INT 5
17098: PUSH
17099: LD_INT 6
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: PUSH
17107: LD_OWVAR 67
17111: ARRAY
17112: PUSH
17113: FOR_TO
17114: IFFALSE 17193
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17116: LD_ADDR_EXP 44
17120: PUSH
17121: LD_EXP 44
17125: PUSH
17126: LD_INT 23
17128: ADD
17129: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17130: LD_ADDR_EXP 44
17134: PUSH
17135: LD_EXP 44
17139: PUSH
17140: LD_INT 1
17142: ADD
17143: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17144: LD_ADDR_EXP 44
17148: PUSH
17149: LD_EXP 44
17153: PUSH
17154: LD_INT 3
17156: ADD
17157: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17158: LD_ADDR_EXP 44
17162: PUSH
17163: LD_EXP 44
17167: PUSH
17168: LD_INT 46
17170: PUSH
17171: LD_INT 47
17173: PUSH
17174: EMPTY
17175: LIST
17176: LIST
17177: PUSH
17178: LD_INT 1
17180: PPUSH
17181: LD_INT 2
17183: PPUSH
17184: CALL_OW 12
17188: ARRAY
17189: ADD
17190: ST_TO_ADDR
// end ;
17191: GO 17113
17193: POP
17194: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17195: LD_INT 22
17197: PUSH
17198: LD_INT 7
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 34
17207: PUSH
17208: LD_INT 51
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: EMPTY
17216: LIST
17217: LIST
17218: PPUSH
17219: CALL_OW 69
17223: PUSH
17224: LD_INT 0
17226: EQUAL
17227: IFFALSE 17250
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17229: LD_EXP 49
17233: PPUSH
17234: LD_INT 21
17236: PPUSH
17237: LD_INT 1
17239: PPUSH
17240: LD_INT 3
17242: PPUSH
17243: LD_INT 51
17245: PPUSH
17246: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17250: LD_EXP 38
17254: PUSH
17255: LD_OWVAR 1
17259: PUSH
17260: LD_INT 25200
17262: MOD
17263: PUSH
17264: LD_INT 0
17266: EQUAL
17267: AND
17268: IFFALSE 17331
// begin for i = 1 to al_force do
17270: LD_ADDR_VAR 0 1
17274: PUSH
17275: DOUBLE
17276: LD_INT 1
17278: DEC
17279: ST_TO_ADDR
17280: LD_EXP 38
17284: PUSH
17285: FOR_TO
17286: IFFALSE 17329
// if GetTag ( al_force [ i ] ) <> 11 then
17288: LD_EXP 38
17292: PUSH
17293: LD_VAR 0 1
17297: ARRAY
17298: PPUSH
17299: CALL_OW 110
17303: PUSH
17304: LD_INT 11
17306: NONEQUAL
17307: IFFALSE 17327
// SetTag ( al_force [ i ] , 11 ) ;
17309: LD_EXP 38
17313: PUSH
17314: LD_VAR 0 1
17318: ARRAY
17319: PPUSH
17320: LD_INT 11
17322: PPUSH
17323: CALL_OW 109
17327: GO 17285
17329: POP
17330: POP
// end ; if al_force then
17331: LD_EXP 38
17335: IFFALSE 17444
// for i = 1 to al_force do
17337: LD_ADDR_VAR 0 1
17341: PUSH
17342: DOUBLE
17343: LD_INT 1
17345: DEC
17346: ST_TO_ADDR
17347: LD_EXP 38
17351: PUSH
17352: FOR_TO
17353: IFFALSE 17442
// begin if GetTag ( al_force [ i ] ) = 11 then
17355: LD_EXP 38
17359: PUSH
17360: LD_VAR 0 1
17364: ARRAY
17365: PPUSH
17366: CALL_OW 110
17370: PUSH
17371: LD_INT 11
17373: EQUAL
17374: IFFALSE 17440
// begin if not HasTask ( al_force [ i ] ) then
17376: LD_EXP 38
17380: PUSH
17381: LD_VAR 0 1
17385: ARRAY
17386: PPUSH
17387: CALL_OW 314
17391: NOT
17392: IFFALSE 17440
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17394: LD_EXP 38
17398: PUSH
17399: LD_VAR 0 1
17403: ARRAY
17404: PPUSH
17405: LD_INT 81
17407: PUSH
17408: LD_INT 7
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: PPUSH
17415: CALL_OW 69
17419: PPUSH
17420: LD_EXP 38
17424: PUSH
17425: LD_VAR 0 1
17429: ARRAY
17430: PPUSH
17431: CALL_OW 74
17435: PPUSH
17436: CALL_OW 115
// end ; end ;
17440: GO 17352
17442: POP
17443: POP
// end ; end_of_file
17444: PPOPN 4
17446: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17447: LD_INT 0
17449: PPUSH
17450: PPUSH
17451: PPUSH
17452: PPUSH
17453: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17454: LD_ADDR_EXP 53
17458: PUSH
17459: LD_INT 7
17461: PUSH
17462: LD_INT 6
17464: PUSH
17465: LD_INT 5
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: PUSH
17473: LD_OWVAR 67
17477: ARRAY
17478: ST_TO_ADDR
// ar_force := [ ] ;
17479: LD_ADDR_EXP 52
17483: PUSH
17484: EMPTY
17485: ST_TO_ADDR
// RemoveAlliance ;
17486: CALL 15275 0 0
// RemoveEnvironmentArea ( evn ) ;
17490: LD_INT 17
17492: PPUSH
17493: CALL_OW 355
// your_side := 2 ;
17497: LD_ADDR_OWVAR 2
17501: PUSH
17502: LD_INT 2
17504: ST_TO_ADDR
// uc_side := 2 ;
17505: LD_ADDR_OWVAR 20
17509: PUSH
17510: LD_INT 2
17512: ST_TO_ADDR
// uc_nation := nation_arabian ;
17513: LD_ADDR_OWVAR 21
17517: PUSH
17518: LD_INT 2
17520: ST_TO_ADDR
// hc_gallery :=  ;
17521: LD_ADDR_OWVAR 33
17525: PUSH
17526: LD_STRING 
17528: ST_TO_ADDR
// hc_name :=  ;
17529: LD_ADDR_OWVAR 26
17533: PUSH
17534: LD_STRING 
17536: ST_TO_ADDR
// hc_importance := 0 ;
17537: LD_ADDR_OWVAR 32
17541: PUSH
17542: LD_INT 0
17544: ST_TO_ADDR
// for i = 1 to 15 do
17545: LD_ADDR_VAR 0 2
17549: PUSH
17550: DOUBLE
17551: LD_INT 1
17553: DEC
17554: ST_TO_ADDR
17555: LD_INT 15
17557: PUSH
17558: FOR_TO
17559: IFFALSE 17612
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17561: LD_INT 0
17563: PPUSH
17564: LD_INT 1
17566: PPUSH
17567: LD_INT 4
17569: PPUSH
17570: CALL_OW 12
17574: PPUSH
17575: LD_EXP 53
17579: PPUSH
17580: CALL_OW 380
// un := CreateHuman ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: CALL_OW 44
17593: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17594: LD_ADDR_EXP 52
17598: PUSH
17599: LD_EXP 52
17603: PUSH
17604: LD_VAR 0 4
17608: ADD
17609: ST_TO_ADDR
// end ;
17610: GO 17558
17612: POP
17613: POP
// hc_importance := 100 ;
17614: LD_ADDR_OWVAR 32
17618: PUSH
17619: LD_INT 100
17621: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 11
17627: PPUSH
17628: LD_EXP 53
17632: PPUSH
17633: CALL_OW 380
// ar_commander := CreateHuman ;
17637: LD_ADDR_EXP 51
17641: PUSH
17642: CALL_OW 44
17646: ST_TO_ADDR
// player_commander := ar_commander ;
17647: LD_ADDR_EXP 10
17651: PUSH
17652: LD_EXP 51
17656: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17657: LD_ADDR_VAR 0 5
17661: PUSH
17662: LD_STRING text
17664: PPUSH
17665: LD_INT 11
17667: PUSH
17668: LD_INT 10
17670: PUSH
17671: LD_INT 9
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: LIST
17678: PUSH
17679: LD_OWVAR 67
17683: ARRAY
17684: PPUSH
17685: LD_INT 11
17687: PUSH
17688: LD_INT 10
17690: PUSH
17691: LD_INT 9
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: PUSH
17699: LD_OWVAR 67
17703: ARRAY
17704: PPUSH
17705: LD_INT -5
17707: PUSH
17708: LD_EXP 51
17712: PUSH
17713: LD_INT -3
17715: PUSH
17716: LD_INT -2
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: PUSH
17725: LD_EXP 52
17729: ADD
17730: PPUSH
17731: LD_INT 1
17733: PUSH
17734: LD_INT 3
17736: PUSH
17737: LD_INT 2
17739: PUSH
17740: LD_INT 1
17742: PUSH
17743: EMPTY
17744: LIST
17745: LIST
17746: PUSH
17747: LD_INT 4
17749: PUSH
17750: LD_INT 1
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: PUSH
17757: LD_INT 8
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: PPUSH
17767: CALL_OW 42
17771: ST_TO_ADDR
// team := team ^ ar_commander ;
17772: LD_ADDR_VAR 0 5
17776: PUSH
17777: LD_VAR 0 5
17781: PUSH
17782: LD_EXP 51
17786: ADD
17787: ST_TO_ADDR
// for i = 1 to team do
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: DOUBLE
17794: LD_INT 1
17796: DEC
17797: ST_TO_ADDR
17798: LD_VAR 0 5
17802: PUSH
17803: FOR_TO
17804: IFFALSE 17829
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17806: LD_VAR 0 5
17810: PUSH
17811: LD_VAR 0 2
17815: ARRAY
17816: PPUSH
17817: LD_INT 16
17819: PPUSH
17820: LD_INT 0
17822: PPUSH
17823: CALL_OW 49
17827: GO 17803
17829: POP
17830: POP
// uc_side := 0 ;
17831: LD_ADDR_OWVAR 20
17835: PUSH
17836: LD_INT 0
17838: ST_TO_ADDR
// uc_nation := 0 ;
17839: LD_ADDR_OWVAR 21
17843: PUSH
17844: LD_INT 0
17846: ST_TO_ADDR
// vc_chassis := 31 ;
17847: LD_ADDR_OWVAR 37
17851: PUSH
17852: LD_INT 31
17854: ST_TO_ADDR
// vc_control := control_rider ;
17855: LD_ADDR_OWVAR 38
17859: PUSH
17860: LD_INT 4
17862: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17863: CALL_OW 45
17867: PPUSH
17868: LD_INT 96
17870: PPUSH
17871: LD_INT 20
17873: PPUSH
17874: LD_INT 0
17876: PPUSH
17877: CALL_OW 48
// end ;
17881: LD_VAR 0 1
17885: RET
