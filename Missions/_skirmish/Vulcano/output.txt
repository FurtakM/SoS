// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3523 0 0
// PrepareLegion ;
  27: CALL 7054 0 0
// Action ;
  31: CALL 10733 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16048 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ;
3486: PPOPN 1
3488: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3489: LD_VAR 0 1
3493: PPUSH
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_VAR 0 3
3503: PPUSH
3504: CALL 29345 0 3
// end ;
3508: PPOPN 3
3510: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: CALL 29443 0 1
// end ; end_of_file
3520: PPOPN 1
3522: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3523: LD_INT 0
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
3529: PPUSH
3530: PPUSH
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
// uc_side := 3 ;
3536: LD_ADDR_OWVAR 20
3540: PUSH
3541: LD_INT 3
3543: ST_TO_ADDR
// uc_nation := nation_russian ;
3544: LD_ADDR_OWVAR 21
3548: PUSH
3549: LD_INT 3
3551: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3552: LD_ADDR_VAR 0 4
3556: PUSH
3557: LD_INT 22
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 30
3569: PUSH
3570: LD_INT 1
3572: PUSH
3573: EMPTY
3574: LIST
3575: LIST
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PPUSH
3581: CALL_OW 69
3585: PUSH
3586: LD_INT 1
3588: ARRAY
3589: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3590: LD_ADDR_VAR 0 5
3594: PUSH
3595: LD_INT 22
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 30
3607: PUSH
3608: LD_INT 3
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PPUSH
3619: CALL_OW 69
3623: PUSH
3624: LD_INT 1
3626: ARRAY
3627: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_INT 22
3635: PUSH
3636: LD_INT 3
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 30
3645: PUSH
3646: LD_INT 34
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 69
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3666: LD_ADDR_VAR 0 8
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 33
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3700: LD_ADDR_VAR 0 7
3704: PUSH
3705: LD_INT 22
3707: PUSH
3708: LD_INT 3
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 30
3717: PUSH
3718: LD_INT 5
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PPUSH
3729: CALL_OW 69
3733: PUSH
3734: LD_INT 1
3736: ARRAY
3737: ST_TO_ADDR
// ru_blist := [ ] ;
3738: LD_ADDR_EXP 26
3742: PUSH
3743: EMPTY
3744: ST_TO_ADDR
// ru_vlist := [ ] ;
3745: LD_ADDR_EXP 27
3749: PUSH
3750: EMPTY
3751: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3752: LD_ADDR_EXP 30
3756: PUSH
3757: LD_INT 183
3759: PUSH
3760: LD_INT 62
3762: PUSH
3763: LD_INT 147
3765: PUSH
3766: LD_INT 44
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3775: LD_INT 30
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PPUSH
3785: CALL_OW 69
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_EXP 30
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 2
3810: ARRAY
3811: PPUSH
3812: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3816: LD_ADDR_EXP 28
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: LD_INT 5
3826: PUSH
3827: LD_INT 6
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: LIST
3834: PUSH
3835: LD_OWVAR 67
3839: ARRAY
3840: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3841: LD_VAR 0 4
3845: PPUSH
3846: CALL_OW 274
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 3000
3856: PPUSH
3857: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3861: LD_VAR 0 4
3865: PPUSH
3866: CALL_OW 274
3870: PPUSH
3871: LD_INT 2
3873: PPUSH
3874: LD_INT 300
3876: PPUSH
3877: CALL_OW 277
// hc_gallery :=  ;
3881: LD_ADDR_OWVAR 33
3885: PUSH
3886: LD_STRING 
3888: ST_TO_ADDR
// hc_name :=  ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING 
3896: ST_TO_ADDR
// hc_importance := 0 ;
3897: LD_ADDR_OWVAR 32
3901: PUSH
3902: LD_INT 0
3904: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3905: LD_ADDR_EXP 24
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: LD_INT 6
3915: PUSH
3916: LD_INT 7
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: ST_TO_ADDR
// for i = 1 to 6 do
3930: LD_ADDR_VAR 0 2
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 6
3942: PUSH
3943: FOR_TO
3944: IFFALSE 4102
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3946: LD_INT 0
3948: PPUSH
3949: LD_INT 9
3951: PPUSH
3952: LD_EXP 24
3956: PPUSH
3957: CALL_OW 380
// un := CreateHuman ;
3961: LD_ADDR_VAR 0 3
3965: PUSH
3966: CALL_OW 44
3970: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_VAR 0 7
3980: PPUSH
3981: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 4
3990: PPUSH
3991: LD_EXP 24
3995: PPUSH
3996: CALL_OW 380
// un := CreateHuman ;
4000: LD_ADDR_VAR 0 3
4004: PUSH
4005: CALL_OW 44
4009: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4010: LD_VAR 0 3
4014: PPUSH
4015: LD_INT 24
4017: PPUSH
4018: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4022: LD_INT 0
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_EXP 24
4032: PPUSH
4033: CALL_OW 380
// un := CreateHuman ;
4037: LD_ADDR_VAR 0 3
4041: PUSH
4042: CALL_OW 44
4046: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_VAR 0 5
4056: PPUSH
4057: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4061: LD_INT 0
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: LD_EXP 24
4071: PPUSH
4072: CALL_OW 380
// un := CreateHuman ;
4076: LD_ADDR_VAR 0 3
4080: PUSH
4081: CALL_OW 44
4085: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_VAR 0 4
4095: PPUSH
4096: CALL_OW 52
// end ;
4100: GO 3943
4102: POP
4103: POP
// russian_prepared := true ;
4104: LD_ADDR_EXP 2
4108: PUSH
4109: LD_INT 1
4111: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_INT 21
4119: PPUSH
4120: LD_INT 3
4122: PPUSH
4123: LD_INT 3
4125: PPUSH
4126: LD_INT 51
4128: PPUSH
4129: CALL_OW 125
// end ;
4133: LD_VAR 0 1
4137: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4138: LD_INT 22
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 69
4152: PUSH
4153: LD_INT 0
4155: GREATER
4156: PUSH
4157: LD_EXP 2
4161: AND
4162: IFFALSE 6625
4164: GO 4166
4166: DISABLE
4167: LD_INT 0
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
4173: PPUSH
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
// begin enable ;
4186: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4187: LD_ADDR_VAR 0 1
4191: PUSH
4192: LD_INT 22
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 30
4204: PUSH
4205: LD_INT 1
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PPUSH
4216: CALL_OW 69
4220: PUSH
4221: LD_INT 1
4223: ARRAY
4224: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: LD_INT 22
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 30
4242: PUSH
4243: LD_INT 3
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: PUSH
4259: LD_INT 1
4261: ARRAY
4262: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4263: LD_ADDR_VAR 0 3
4267: PUSH
4268: LD_INT 22
4270: PUSH
4271: LD_INT 3
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PUSH
4278: LD_INT 30
4280: PUSH
4281: LD_INT 34
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PPUSH
4292: CALL_OW 69
4296: PUSH
4297: LD_INT 1
4299: ARRAY
4300: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4301: LD_ADDR_VAR 0 4
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4335: LD_ADDR_VAR 0 8
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 3
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 30
4352: PUSH
4353: LD_INT 5
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PPUSH
4364: CALL_OW 69
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4373: LD_ADDR_VAR 0 5
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4407: LD_ADDR_VAR 0 6
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4441: LD_ADDR_VAR 0 7
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 1
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4475: LD_ADDR_VAR 0 9
4479: PUSH
4480: LD_VAR 0 7
4484: PPUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PPUSH
4495: CALL_OW 72
4499: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4500: LD_ADDR_VAR 0 10
4504: PUSH
4505: LD_VAR 0 7
4509: PPUSH
4510: LD_INT 25
4512: PUSH
4513: LD_INT 3
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 72
4524: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4525: LD_ADDR_VAR 0 11
4529: PUSH
4530: LD_VAR 0 7
4534: PPUSH
4535: LD_INT 25
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PPUSH
4545: CALL_OW 72
4549: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4550: LD_INT 22
4552: PUSH
4553: LD_INT 3
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 34
4562: PUSH
4563: LD_INT 51
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: CALL_OW 69
4578: PUSH
4579: LD_INT 0
4581: GREATER
4582: PUSH
4583: LD_EXP 25
4587: PUSH
4588: LD_INT 0
4590: EQUAL
4591: AND
4592: IFFALSE 4632
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4594: LD_ADDR_EXP 25
4598: PUSH
4599: LD_INT 22
4601: PUSH
4602: LD_INT 3
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 34
4611: PUSH
4612: LD_INT 51
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 69
4627: PUSH
4628: LD_INT 1
4630: ARRAY
4631: ST_TO_ADDR
// if ru_cargo then
4632: LD_EXP 25
4636: IFFALSE 4934
// begin if IsInArea ( ru_cargo , ru_base ) then
4638: LD_EXP 25
4642: PPUSH
4643: LD_INT 9
4645: PPUSH
4646: CALL_OW 308
4650: IFFALSE 4729
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4652: LD_EXP 25
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: EQUAL
4668: IFFALSE 4686
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4670: LD_EXP 25
4674: PPUSH
4675: LD_VAR 0 3
4679: PPUSH
4680: CALL_OW 120
4684: GO 4727
// if not HasTask ( ru_cargo ) then
4686: LD_EXP 25
4690: PPUSH
4691: CALL_OW 314
4695: NOT
4696: IFFALSE 4727
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4698: LD_EXP 25
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 250
4712: PPUSH
4713: LD_VAR 0 1
4717: PPUSH
4718: CALL_OW 251
4722: PPUSH
4723: CALL_OW 111
// end else
4727: GO 4934
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4729: LD_EXP 25
4733: PPUSH
4734: CALL_OW 314
4738: NOT
4739: PUSH
4740: LD_EXP 25
4744: PPUSH
4745: LD_INT 1
4747: PPUSH
4748: CALL_OW 289
4752: PUSH
4753: LD_INT 100
4755: LESS
4756: AND
4757: IFFALSE 4823
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4759: LD_ADDR_VAR 0 16
4763: PUSH
4764: LD_INT 11
4766: PPUSH
4767: CALL_OW 435
4771: ST_TO_ADDR
// if cr > 0 then
4772: LD_VAR 0 16
4776: PUSH
4777: LD_INT 0
4779: GREATER
4780: IFFALSE 4811
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4782: LD_EXP 25
4786: PPUSH
4787: LD_VAR 0 16
4791: PUSH
4792: LD_INT 1
4794: ARRAY
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 2
4803: ARRAY
4804: PPUSH
4805: CALL_OW 117
4809: GO 4823
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4811: LD_EXP 25
4815: PPUSH
4816: LD_INT 11
4818: PPUSH
4819: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4823: LD_EXP 25
4827: PPUSH
4828: CALL_OW 314
4832: NOT
4833: PUSH
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 308
4846: NOT
4847: AND
4848: PUSH
4849: LD_EXP 25
4853: PPUSH
4854: LD_INT 1
4856: PPUSH
4857: CALL_OW 289
4861: PUSH
4862: LD_INT 100
4864: EQUAL
4865: AND
4866: IFFALSE 4880
// ComMoveToArea ( ru_cargo , cargoa ) ;
4868: LD_EXP 25
4872: PPUSH
4873: LD_INT 10
4875: PPUSH
4876: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4880: LD_EXP 25
4884: PPUSH
4885: LD_INT 10
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_VAR 0 8
4897: AND
4898: IFFALSE 4934
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4900: LD_VAR 0 7
4904: PPUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 9
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 72
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 139
4926: PPUSH
4927: LD_INT 24
4929: PPUSH
4930: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4934: LD_EXP 25
4938: PUSH
4939: LD_INT 0
4941: EQUAL
4942: PUSH
4943: LD_VAR 0 2
4947: AND
4948: PUSH
4949: LD_VAR 0 2
4953: PPUSH
4954: CALL_OW 461
4958: PUSH
4959: LD_INT 2
4961: EQUAL
4962: AND
4963: IFFALSE 4986
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4965: LD_VAR 0 2
4969: PPUSH
4970: LD_INT 21
4972: PPUSH
4973: LD_INT 3
4975: PPUSH
4976: LD_INT 3
4978: PPUSH
4979: LD_INT 51
4981: PPUSH
4982: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4986: LD_VAR 0 7
4990: PPUSH
4991: LD_INT 25
4993: PUSH
4994: LD_INT 9
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 72
5005: IFFALSE 5069
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5007: LD_VAR 0 7
5011: PPUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 9
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PPUSH
5022: CALL_OW 72
5026: PPUSH
5027: LD_INT 22
5029: PUSH
5030: LD_OWVAR 2
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 3
5041: PUSH
5042: LD_INT 21
5044: PUSH
5045: LD_INT 3
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PPUSH
5065: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5069: LD_VAR 0 2
5073: PUSH
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 0
5081: GREATER
5082: AND
5083: IFFALSE 5183
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5085: LD_VAR 0 2
5089: PPUSH
5090: CALL_OW 461
5094: PUSH
5095: LD_INT 2
5097: EQUAL
5098: IFFALSE 5183
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5100: LD_VAR 0 2
5104: PPUSH
5105: LD_EXP 27
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 2
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 3
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 4
5139: ARRAY
5140: PPUSH
5141: CALL_OW 125
// for i = 1 to 4 do
5145: LD_ADDR_VAR 0 12
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 4
5157: PUSH
5158: FOR_TO
5159: IFFALSE 5181
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5161: LD_ADDR_EXP 27
5165: PUSH
5166: LD_EXP 27
5170: PPUSH
5171: LD_INT 1
5173: PPUSH
5174: CALL_OW 3
5178: ST_TO_ADDR
5179: GO 5158
5181: POP
5182: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5183: LD_INT 24
5185: PPUSH
5186: CALL_OW 461
5190: PUSH
5191: LD_INT 2
5193: EQUAL
5194: PUSH
5195: LD_EXP 4
5199: AND
5200: IFFALSE 5228
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5202: LD_INT 25
5204: PPUSH
5205: LD_INT 3
5207: PPUSH
5208: CALL_OW 321
5212: PUSH
5213: LD_INT 1
5215: EQUAL
5216: IFFALSE 5228
// ComResearch ( ru_lab , tech_sibfiss ) ;
5218: LD_INT 24
5220: PPUSH
5221: LD_INT 25
5223: PPUSH
5224: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5228: LD_INT 25
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: CALL_OW 321
5238: PUSH
5239: LD_INT 2
5241: EQUAL
5242: PUSH
5243: LD_OWVAR 1
5247: PUSH
5248: LD_INT 10500
5250: MOD
5251: PUSH
5252: LD_INT 0
5254: EQUAL
5255: AND
5256: IFFALSE 5294
// if BuildingStatus ( ru_factory ) = bs_idle then
5258: LD_VAR 0 2
5262: PPUSH
5263: CALL_OW 461
5267: PUSH
5268: LD_INT 2
5270: EQUAL
5271: IFFALSE 5294
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5273: LD_VAR 0 2
5277: PPUSH
5278: LD_INT 23
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: LD_INT 3
5286: PPUSH
5287: LD_INT 48
5289: PPUSH
5290: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5294: LD_INT 22
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_INT 48
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: PPUSH
5318: CALL_OW 69
5322: PUSH
5323: LD_INT 0
5325: GREATER
5326: IFFALSE 5700
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5328: LD_ADDR_VAR 0 17
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 3
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 34
5345: PUSH
5346: LD_INT 48
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL_OW 69
5361: PUSH
5362: LD_INT 1
5364: ARRAY
5365: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5366: LD_VAR 0 17
5370: PPUSH
5371: LD_INT 9
5373: PPUSH
5374: CALL_OW 308
5378: IFFALSE 5396
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5380: LD_VAR 0 17
5384: PPUSH
5385: LD_VAR 0 3
5389: PPUSH
5390: CALL_OW 120
5394: GO 5700
// if not HasTask ( sib_bomb ) then
5396: LD_VAR 0 17
5400: PPUSH
5401: CALL_OW 314
5405: NOT
5406: IFFALSE 5700
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5408: LD_INT 22
5410: PUSH
5411: LD_OWVAR 2
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: PUSH
5420: LD_INT 30
5422: PUSH
5423: LD_INT 1
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PPUSH
5434: CALL_OW 69
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_INT 250
5450: GREATER
5451: IFFALSE 5544
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5453: LD_VAR 0 17
5457: PPUSH
5458: LD_INT 22
5460: PUSH
5461: LD_OWVAR 2
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 30
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 69
5488: PUSH
5489: LD_INT 1
5491: ARRAY
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 22
5500: PUSH
5501: LD_OWVAR 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 30
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 69
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: CALL_OW 251
5537: PPUSH
5538: CALL_OW 116
5542: GO 5700
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5544: LD_INT 22
5546: PUSH
5547: LD_OWVAR 2
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 21
5558: PUSH
5559: LD_INT 3
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 69
5574: PUSH
5575: LD_INT 0
5577: GREATER
5578: IFFALSE 5671
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5580: LD_VAR 0 17
5584: PPUSH
5585: LD_INT 22
5587: PUSH
5588: LD_OWVAR 2
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: LD_INT 21
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_INT 1
5618: ARRAY
5619: PPUSH
5620: CALL_OW 250
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_OWVAR 2
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 21
5639: PUSH
5640: LD_INT 3
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: PUSH
5656: LD_INT 1
5658: ARRAY
5659: PPUSH
5660: CALL_OW 251
5664: PPUSH
5665: CALL_OW 116
5669: GO 5700
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5671: LD_VAR 0 17
5675: PPUSH
5676: LD_EXP 10
5680: PPUSH
5681: CALL_OW 250
5685: PPUSH
5686: LD_EXP 10
5690: PPUSH
5691: CALL_OW 251
5695: PPUSH
5696: CALL_OW 116
// end ; if ru_can_attack then
5700: LD_EXP 3
5704: IFFALSE 5852
// if ru_time > 0 0$00 then
5706: LD_EXP 29
5710: PUSH
5711: LD_INT 0
5713: GREATER
5714: IFFALSE 5732
// ru_time := ru_time - 0 0$01 else
5716: LD_ADDR_EXP 29
5720: PUSH
5721: LD_EXP 29
5725: PUSH
5726: LD_INT 35
5728: MINUS
5729: ST_TO_ADDR
5730: GO 5852
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5732: LD_ADDR_EXP 29
5736: PUSH
5737: LD_INT 20265
5739: PPUSH
5740: LD_INT 30765
5742: PPUSH
5743: CALL_OW 12
5747: ST_TO_ADDR
// for i = 1 to ru_amount do
5748: LD_ADDR_VAR 0 12
5752: PUSH
5753: DOUBLE
5754: LD_INT 1
5756: DEC
5757: ST_TO_ADDR
5758: LD_EXP 28
5762: PUSH
5763: FOR_TO
5764: IFFALSE 5850
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5766: LD_ADDR_EXP 27
5770: PUSH
5771: LD_EXP 27
5775: PUSH
5776: LD_INT 23
5778: ADD
5779: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5780: LD_ADDR_EXP 27
5784: PUSH
5785: LD_EXP 27
5789: PUSH
5790: LD_INT 3
5792: ADD
5793: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5794: LD_ADDR_EXP 27
5798: PUSH
5799: LD_EXP 27
5803: PUSH
5804: LD_INT 3
5806: ADD
5807: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5808: LD_ADDR_EXP 27
5812: PUSH
5813: LD_EXP 27
5817: PUSH
5818: LD_INT 46
5820: PUSH
5821: LD_INT 45
5823: PUSH
5824: LD_INT 47
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 2
5837: PPUSH
5838: LD_INT 3
5840: PPUSH
5841: CALL_OW 14
5845: ARRAY
5846: ADD
5847: ST_TO_ADDR
// end ;
5848: GO 5763
5850: POP
5851: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5852: LD_VAR 0 4
5856: PPUSH
5857: LD_INT 35
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PPUSH
5867: CALL_OW 72
5871: PUSH
5872: LD_INT 0
5874: GREATER
5875: IFFALSE 5923
// if BuildingStatus ( ru_factory ) = bs_idle then
5877: LD_VAR 0 2
5881: PPUSH
5882: CALL_OW 461
5886: PUSH
5887: LD_INT 2
5889: EQUAL
5890: IFFALSE 5923
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5892: LD_VAR 0 4
5896: PPUSH
5897: LD_INT 35
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PPUSH
5907: CALL_OW 72
5911: PUSH
5912: LD_INT 1
5914: ARRAY
5915: PPUSH
5916: LD_INT 47
5918: PPUSH
5919: CALL_OW 148
// if ru_force = ru_amount then
5923: LD_EXP 23
5927: PUSH
5928: LD_EXP 28
5932: EQUAL
5933: IFFALSE 6065
// begin for i = 1 to ru_force do
5935: LD_ADDR_VAR 0 12
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_EXP 23
5949: PUSH
5950: FOR_TO
5951: IFFALSE 6061
// if IsInArea ( ru_force [ i ] , ru_base ) then
5953: LD_EXP 23
5957: PUSH
5958: LD_VAR 0 12
5962: ARRAY
5963: PPUSH
5964: LD_INT 9
5966: PPUSH
5967: CALL_OW 308
5971: IFFALSE 5995
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5973: LD_EXP 23
5977: PUSH
5978: LD_VAR 0 12
5982: ARRAY
5983: PPUSH
5984: LD_VAR 0 3
5988: PPUSH
5989: CALL_OW 120
5993: GO 6059
// if not HasTask ( ru_force [ i ] ) then
5995: LD_EXP 23
5999: PUSH
6000: LD_VAR 0 12
6004: ARRAY
6005: PPUSH
6006: CALL_OW 314
6010: NOT
6011: IFFALSE 6059
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6013: LD_EXP 23
6017: PUSH
6018: LD_VAR 0 12
6022: ARRAY
6023: PPUSH
6024: LD_INT 81
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PPUSH
6034: CALL_OW 69
6038: PPUSH
6039: LD_EXP 23
6043: PUSH
6044: LD_VAR 0 12
6048: ARRAY
6049: PPUSH
6050: CALL_OW 74
6054: PPUSH
6055: CALL_OW 115
6059: GO 5950
6061: POP
6062: POP
// end else
6063: GO 6215
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6065: LD_EXP 23
6069: PPUSH
6070: LD_INT 3
6072: PUSH
6073: LD_INT 95
6075: PUSH
6076: LD_INT 18
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: PUSH
6092: LD_INT 0
6094: GREATER
6095: IFFALSE 6215
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6097: LD_ADDR_VAR 0 13
6101: PUSH
6102: LD_EXP 23
6106: PPUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 95
6112: PUSH
6113: LD_INT 18
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 72
6128: ST_TO_ADDR
// for i = 1 to tmp do
6129: LD_ADDR_VAR 0 12
6133: PUSH
6134: DOUBLE
6135: LD_INT 1
6137: DEC
6138: ST_TO_ADDR
6139: LD_VAR 0 13
6143: PUSH
6144: FOR_TO
6145: IFFALSE 6213
// if not HasTask ( tmp [ i ] ) then
6147: LD_VAR 0 13
6151: PUSH
6152: LD_VAR 0 12
6156: ARRAY
6157: PPUSH
6158: CALL_OW 314
6162: NOT
6163: IFFALSE 6211
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6165: LD_EXP 23
6169: PUSH
6170: LD_VAR 0 12
6174: ARRAY
6175: PPUSH
6176: LD_INT 81
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PPUSH
6191: LD_EXP 23
6195: PUSH
6196: LD_VAR 0 12
6200: ARRAY
6201: PPUSH
6202: CALL_OW 74
6206: PPUSH
6207: CALL_OW 115
6211: GO 6144
6213: POP
6214: POP
// end ; if ru_engs > 0 then
6215: LD_VAR 0 9
6219: PUSH
6220: LD_INT 0
6222: GREATER
6223: IFFALSE 6625
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6225: LD_VAR 0 5
6229: PPUSH
6230: LD_INT 3
6232: PUSH
6233: LD_INT 24
6235: PUSH
6236: LD_INT 1000
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_INT 0
6254: GREATER
6255: IFFALSE 6410
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6257: LD_ADDR_VAR 0 14
6261: PUSH
6262: LD_VAR 0 5
6266: PPUSH
6267: LD_INT 3
6269: PUSH
6270: LD_INT 24
6272: PUSH
6273: LD_INT 1000
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 72
6288: ST_TO_ADDR
// for i = 1 to ru_engs do
6289: LD_ADDR_VAR 0 12
6293: PUSH
6294: DOUBLE
6295: LD_INT 1
6297: DEC
6298: ST_TO_ADDR
6299: LD_VAR 0 9
6303: PUSH
6304: FOR_TO
6305: IFFALSE 6406
// begin if IsInUnit ( ru_engs [ i ] ) then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 310
6322: IFFALSE 6341
// ComExitBuilding ( ru_engs [ i ] ) else
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 122
6339: GO 6404
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6341: LD_VAR 0 9
6345: PUSH
6346: LD_VAR 0 12
6350: ARRAY
6351: PPUSH
6352: CALL_OW 314
6356: NOT
6357: PUSH
6358: LD_VAR 0 9
6362: PUSH
6363: LD_VAR 0 12
6367: ARRAY
6368: PPUSH
6369: CALL_OW 256
6373: PUSH
6374: LD_INT 600
6376: GREATER
6377: AND
6378: IFFALSE 6404
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6380: LD_VAR 0 9
6384: PUSH
6385: LD_VAR 0 12
6389: ARRAY
6390: PPUSH
6391: LD_VAR 0 14
6395: PUSH
6396: LD_INT 1
6398: ARRAY
6399: PPUSH
6400: CALL_OW 130
// end ;
6404: GO 6304
6406: POP
6407: POP
// end else
6408: GO 6625
// begin if ru_blist = 0 then
6410: LD_EXP 26
6414: PUSH
6415: LD_INT 0
6417: EQUAL
6418: IFFALSE 6500
// begin for i = 1 to ru_engs do
6420: LD_ADDR_VAR 0 12
6424: PUSH
6425: DOUBLE
6426: LD_INT 1
6428: DEC
6429: ST_TO_ADDR
6430: LD_VAR 0 9
6434: PUSH
6435: FOR_TO
6436: IFFALSE 6496
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6438: LD_VAR 0 9
6442: PUSH
6443: LD_VAR 0 12
6447: ARRAY
6448: PPUSH
6449: CALL_OW 314
6453: NOT
6454: PUSH
6455: LD_VAR 0 9
6459: PUSH
6460: LD_VAR 0 12
6464: ARRAY
6465: PPUSH
6466: CALL_OW 310
6470: NOT
6471: AND
6472: IFFALSE 6494
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6474: LD_VAR 0 9
6478: PUSH
6479: LD_VAR 0 12
6483: ARRAY
6484: PPUSH
6485: LD_VAR 0 1
6489: PPUSH
6490: CALL_OW 120
6494: GO 6435
6496: POP
6497: POP
// end else
6498: GO 6625
// begin for i = 1 to ru_engs do
6500: LD_ADDR_VAR 0 12
6504: PUSH
6505: DOUBLE
6506: LD_INT 1
6508: DEC
6509: ST_TO_ADDR
6510: LD_VAR 0 9
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6623
// begin if IsInUnit ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 310
6533: IFFALSE 6552
// ComExitBuilding ( ru_engs [ i ] ) else
6535: LD_VAR 0 9
6539: PUSH
6540: LD_VAR 0 12
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
6550: GO 6621
// if not HasTask ( ru_engs [ i ] ) then
6552: LD_VAR 0 9
6556: PUSH
6557: LD_VAR 0 12
6561: ARRAY
6562: PPUSH
6563: CALL_OW 314
6567: NOT
6568: IFFALSE 6621
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6570: LD_VAR 0 9
6574: PUSH
6575: LD_VAR 0 12
6579: ARRAY
6580: PPUSH
6581: LD_EXP 26
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 2
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 3
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 4
6615: ARRAY
6616: PPUSH
6617: CALL_OW 145
// end ;
6621: GO 6515
6623: POP
6624: POP
// end ; end ; end ; end ;
6625: PPOPN 17
6627: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6628: LD_EXP 2
6632: PUSH
6633: LD_INT 11
6635: PPUSH
6636: CALL_OW 435
6640: PUSH
6641: LD_INT 20
6643: LESS
6644: AND
6645: IFFALSE 6708
6647: GO 6649
6649: DISABLE
// begin enable ;
6650: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6651: LD_INT 1
6653: PPUSH
6654: LD_INT 5
6656: PPUSH
6657: CALL_OW 12
6661: PPUSH
6662: LD_INT 11
6664: PPUSH
6665: LD_INT 1
6667: PPUSH
6668: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6672: LD_INT 1505
6674: PPUSH
6675: LD_INT 2100
6677: PPUSH
6678: CALL_OW 12
6682: PPUSH
6683: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 5
6692: PPUSH
6693: CALL_OW 12
6697: PPUSH
6698: LD_INT 11
6700: PPUSH
6701: LD_INT 1
6703: PPUSH
6704: CALL_OW 55
// end ;
6708: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6709: LD_EXP 4
6713: PUSH
6714: LD_INT 0
6716: EQUAL
6717: IFFALSE 6832
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
6725: PPUSH
// begin enable ;
6726: ENABLE
// i := Rand ( 0 , 100 ) ;
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: LD_INT 0
6734: PPUSH
6735: LD_INT 100
6737: PPUSH
6738: CALL_OW 12
6742: ST_TO_ADDR
// case your_side of 1 :
6743: LD_OWVAR 2
6747: PUSH
6748: LD_INT 1
6750: DOUBLE
6751: EQUAL
6752: IFTRUE 6756
6754: GO 6767
6756: POP
// tmp := 10 ; 2 :
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 10
6764: ST_TO_ADDR
6765: GO 6806
6767: LD_INT 2
6769: DOUBLE
6770: EQUAL
6771: IFTRUE 6775
6773: GO 6786
6775: POP
// tmp := 0 ; 7 :
6776: LD_ADDR_VAR 0 2
6780: PUSH
6781: LD_INT 0
6783: ST_TO_ADDR
6784: GO 6806
6786: LD_INT 7
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6805
6794: POP
// tmp := 15 ; end ;
6795: LD_ADDR_VAR 0 2
6799: PUSH
6800: LD_INT 15
6802: ST_TO_ADDR
6803: GO 6806
6805: POP
// if i < chance_to_bomb + tmp then
6806: LD_VAR 0 1
6810: PUSH
6811: LD_EXP 5
6815: PUSH
6816: LD_VAR 0 2
6820: PLUS
6821: LESS
6822: IFFALSE 6832
// ru_sib_bomb := true ;
6824: LD_ADDR_EXP 4
6828: PUSH
6829: LD_INT 1
6831: ST_TO_ADDR
// end ;
6832: PPOPN 2
6834: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6835: LD_INT 22
6837: PUSH
6838: LD_OWVAR 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 34
6849: PUSH
6850: LD_INT 8
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 69
6865: IFFALSE 6878
6867: GO 6869
6869: DISABLE
// begin ru_sib_bomb := true ;
6870: LD_ADDR_EXP 4
6874: PUSH
6875: LD_INT 1
6877: ST_TO_ADDR
// end ;
6878: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6879: LD_INT 22
6881: PUSH
6882: LD_INT 3
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 30
6891: PUSH
6892: LD_INT 34
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PPUSH
6903: CALL_OW 69
6907: IFFALSE 7006
6909: GO 6911
6911: DISABLE
6912: LD_INT 0
6914: PPUSH
// begin enable ;
6915: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 1
6933: PPUSH
6934: LD_INT 2
6936: PPUSH
6937: CALL_OW 12
6941: ARRAY
6942: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6943: LD_INT 22
6945: PUSH
6946: LD_INT 3
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: LD_INT 30
6955: PUSH
6956: LD_INT 34
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_EXP 30
6980: PUSH
6981: LD_VAR 0 1
6985: ARRAY
6986: PPUSH
6987: LD_EXP 30
6991: PUSH
6992: LD_VAR 0 1
6996: PUSH
6997: LD_INT 1
6999: PLUS
7000: ARRAY
7001: PPUSH
7002: CALL_OW 243
// end ; end_of_file
7006: PPOPN 1
7008: END
// export function RemoveLegion ; var i ; begin
7009: LD_INT 0
7011: PPUSH
7012: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7013: LD_ADDR_VAR 0 2
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 69
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7047
// RemoveUnit ( i ) ;
7036: LD_VAR 0 2
7040: PPUSH
7041: CALL_OW 64
7045: GO 7033
7047: POP
7048: POP
// end ;
7049: LD_VAR 0 1
7053: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
7059: PPUSH
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
7064: PPUSH
7065: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7066: LD_ADDR_VAR 0 7
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 8
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 30
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL_OW 69
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7104: LD_ADDR_VAR 0 8
7108: PUSH
7109: LD_INT 22
7111: PUSH
7112: LD_INT 8
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 30
7121: PUSH
7122: LD_INT 3
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PPUSH
7133: CALL_OW 69
7137: PUSH
7138: LD_INT 1
7140: ARRAY
7141: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7142: LD_ADDR_VAR 0 9
7146: PUSH
7147: LD_INT 22
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: LD_INT 30
7162: PUSH
7163: LD_INT 6
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 30
7172: PUSH
7173: LD_INT 8
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PPUSH
7189: CALL_OW 69
7193: PUSH
7194: LD_INT 1
7196: ARRAY
7197: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7198: LD_ADDR_VAR 0 10
7202: PUSH
7203: LD_INT 22
7205: PUSH
7206: LD_INT 8
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 30
7215: PUSH
7216: LD_INT 32
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL_OW 69
7231: ST_TO_ADDR
// uc_side := 8 ;
7232: LD_ADDR_OWVAR 20
7236: PUSH
7237: LD_INT 8
7239: ST_TO_ADDR
// uc_nation := nation_arabian ;
7240: LD_ADDR_OWVAR 21
7244: PUSH
7245: LD_INT 2
7247: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7248: LD_ADDR_EXP 32
7252: PUSH
7253: LD_INT 5
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: LD_INT 7
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: PUSH
7267: LD_OWVAR 67
7271: ARRAY
7272: ST_TO_ADDR
// legion_blist := [ ] ;
7273: LD_ADDR_EXP 34
7277: PUSH
7278: EMPTY
7279: ST_TO_ADDR
// legion_vlist := [ ] ;
7280: LD_ADDR_EXP 35
7284: PUSH
7285: EMPTY
7286: ST_TO_ADDR
// legion_force := [ ] ;
7287: LD_ADDR_EXP 31
7291: PUSH
7292: EMPTY
7293: ST_TO_ADDR
// legion_enemy := - 1 ;
7294: LD_ADDR_EXP 36
7298: PUSH
7299: LD_INT 1
7301: NEG
7302: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7303: LD_VAR 0 7
7307: PPUSH
7308: CALL_OW 274
7312: PPUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 10000
7318: PPUSH
7319: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7323: LD_VAR 0 7
7327: PPUSH
7328: CALL_OW 274
7332: PPUSH
7333: LD_INT 3
7335: PPUSH
7336: LD_INT 1000
7338: PPUSH
7339: CALL_OW 277
// for i = 1 to l_towers do
7343: LD_ADDR_VAR 0 3
7347: PUSH
7348: DOUBLE
7349: LD_INT 1
7351: DEC
7352: ST_TO_ADDR
7353: LD_VAR 0 10
7357: PUSH
7358: FOR_TO
7359: IFFALSE 7408
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7361: LD_INT 0
7363: PPUSH
7364: LD_INT 1
7366: PPUSH
7367: LD_EXP 32
7371: PPUSH
7372: CALL_OW 380
// un := CreateHuman ;
7376: LD_ADDR_VAR 0 2
7380: PUSH
7381: CALL_OW 44
7385: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7386: LD_VAR 0 2
7390: PPUSH
7391: LD_VAR 0 10
7395: PUSH
7396: LD_VAR 0 3
7400: ARRAY
7401: PPUSH
7402: CALL_OW 52
// end ;
7406: GO 7358
7408: POP
7409: POP
// for i = 1 to 4 do
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: DOUBLE
7416: LD_INT 1
7418: DEC
7419: ST_TO_ADDR
7420: LD_INT 4
7422: PUSH
7423: FOR_TO
7424: IFFALSE 7517
// for p = 1 to 2 do
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: DOUBLE
7432: LD_INT 1
7434: DEC
7435: ST_TO_ADDR
7436: LD_INT 2
7438: PUSH
7439: FOR_TO
7440: IFFALSE 7513
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7442: LD_INT 0
7444: PPUSH
7445: LD_INT 8
7447: PPUSH
7448: LD_EXP 32
7452: PPUSH
7453: CALL_OW 380
// un := CreateHuman ;
7457: LD_ADDR_VAR 0 2
7461: PUSH
7462: CALL_OW 44
7466: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7467: LD_VAR 0 2
7471: PPUSH
7472: LD_INT 22
7474: PUSH
7475: LD_INT 8
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 30
7484: PUSH
7485: LD_INT 5
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PPUSH
7496: CALL_OW 69
7500: PUSH
7501: LD_VAR 0 6
7505: ARRAY
7506: PPUSH
7507: CALL_OW 52
// end ;
7511: GO 7439
7513: POP
7514: POP
7515: GO 7423
7517: POP
7518: POP
// for i = 1 to 4 do
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: DOUBLE
7525: LD_INT 1
7527: DEC
7528: ST_TO_ADDR
7529: LD_INT 4
7531: PUSH
7532: FOR_TO
7533: IFFALSE 7576
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7535: LD_INT 0
7537: PPUSH
7538: LD_INT 4
7540: PPUSH
7541: LD_EXP 32
7545: PPUSH
7546: CALL_OW 380
// un := CreateHuman ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: CALL_OW 44
7559: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7560: LD_VAR 0 2
7564: PPUSH
7565: LD_VAR 0 9
7569: PPUSH
7570: CALL_OW 52
// end ;
7574: GO 7532
7576: POP
7577: POP
// for i = 1 to 6 do
7578: LD_ADDR_VAR 0 3
7582: PUSH
7583: DOUBLE
7584: LD_INT 1
7586: DEC
7587: ST_TO_ADDR
7588: LD_INT 6
7590: PUSH
7591: FOR_TO
7592: IFFALSE 7635
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_EXP 32
7604: PPUSH
7605: CALL_OW 380
// un := CreateHuman ;
7609: LD_ADDR_VAR 0 2
7613: PUSH
7614: CALL_OW 44
7618: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7619: LD_VAR 0 2
7623: PPUSH
7624: LD_VAR 0 8
7628: PPUSH
7629: CALL_OW 52
// end ;
7633: GO 7591
7635: POP
7636: POP
// for i = 1 to 5 do
7637: LD_ADDR_VAR 0 3
7641: PUSH
7642: DOUBLE
7643: LD_INT 1
7645: DEC
7646: ST_TO_ADDR
7647: LD_INT 5
7649: PUSH
7650: FOR_TO
7651: IFFALSE 7694
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7653: LD_INT 0
7655: PPUSH
7656: LD_INT 2
7658: PPUSH
7659: LD_EXP 32
7663: PPUSH
7664: CALL_OW 380
// un := CreateHuman ;
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: CALL_OW 44
7677: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7678: LD_VAR 0 2
7682: PPUSH
7683: LD_VAR 0 7
7687: PPUSH
7688: CALL_OW 52
// end ;
7692: GO 7650
7694: POP
7695: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7696: LD_ADDR_VAR 0 4
7700: PUSH
7701: LD_INT 199
7703: PPUSH
7704: LD_INT 134
7706: PPUSH
7707: LD_INT 216
7709: PPUSH
7710: LD_INT 141
7712: PPUSH
7713: LD_INT 6
7715: PPUSH
7716: CALL 1562 0 5
7720: ST_TO_ADDR
// p := 1 ;
7721: LD_ADDR_VAR 0 6
7725: PUSH
7726: LD_INT 1
7728: ST_TO_ADDR
// for i = 1 to 3 do
7729: LD_ADDR_VAR 0 3
7733: PUSH
7734: DOUBLE
7735: LD_INT 1
7737: DEC
7738: ST_TO_ADDR
7739: LD_INT 3
7741: PUSH
7742: FOR_TO
7743: IFFALSE 7996
// begin vc_chassis := ar_half_tracked ;
7745: LD_ADDR_OWVAR 37
7749: PUSH
7750: LD_INT 14
7752: ST_TO_ADDR
// vc_engine := engine_siberite ;
7753: LD_ADDR_OWVAR 39
7757: PUSH
7758: LD_INT 3
7760: ST_TO_ADDR
// vc_control := control_manual ;
7761: LD_ADDR_OWVAR 38
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7769: LD_ADDR_OWVAR 40
7773: PUSH
7774: LD_INT 31
7776: ST_TO_ADDR
// veh := CreateVehicle ;
7777: LD_ADDR_VAR 0 5
7781: PUSH
7782: CALL_OW 45
7786: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7787: LD_VAR 0 4
7791: PUSH
7792: LD_VAR 0 6
7796: ARRAY
7797: PPUSH
7798: LD_VAR 0 4
7802: PUSH
7803: LD_VAR 0 6
7807: PUSH
7808: LD_INT 1
7810: PLUS
7811: ARRAY
7812: PPUSH
7813: CALL_OW 428
7817: PUSH
7818: LD_INT 0
7820: EQUAL
7821: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7823: LD_VAR 0 5
7827: PPUSH
7828: LD_VAR 0 4
7832: PUSH
7833: LD_VAR 0 6
7837: ARRAY
7838: PPUSH
7839: LD_VAR 0 4
7843: PUSH
7844: LD_VAR 0 6
7848: PUSH
7849: LD_INT 1
7851: PLUS
7852: ARRAY
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 48
7861: GO 7951
// begin repeat p := p + 2 ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_VAR 0 6
7872: PUSH
7873: LD_INT 2
7875: PLUS
7876: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7877: LD_VAR 0 4
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_VAR 0 4
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ARRAY
7902: PPUSH
7903: CALL_OW 428
7907: PUSH
7908: LD_INT 0
7910: EQUAL
7911: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7913: LD_VAR 0 5
7917: PPUSH
7918: LD_VAR 0 4
7922: PUSH
7923: LD_VAR 0 6
7927: ARRAY
7928: PPUSH
7929: LD_VAR 0 4
7933: PUSH
7934: LD_VAR 0 6
7938: PUSH
7939: LD_INT 1
7941: PLUS
7942: ARRAY
7943: PPUSH
7944: LD_INT 0
7946: PPUSH
7947: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7951: LD_INT 0
7953: PPUSH
7954: LD_INT 3
7956: PPUSH
7957: LD_EXP 32
7961: PUSH
7962: LD_INT 1
7964: PLUS
7965: PPUSH
7966: CALL_OW 380
// un := CreateHuman ;
7970: LD_ADDR_VAR 0 2
7974: PUSH
7975: CALL_OW 44
7979: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7980: LD_VAR 0 2
7984: PPUSH
7985: LD_VAR 0 5
7989: PPUSH
7990: CALL_OW 52
// end ;
7994: GO 7742
7996: POP
7997: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7998: LD_INT 198
8000: PPUSH
8001: LD_INT 94
8003: PPUSH
8004: LD_INT 8
8006: PPUSH
8007: LD_INT 10
8009: PPUSH
8010: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8014: LD_INT 167
8016: PPUSH
8017: LD_INT 130
8019: PPUSH
8020: LD_INT 8
8022: PPUSH
8023: LD_INT 10
8025: PPUSH
8026: CALL_OW 330
// legion_mines := [ ] ;
8030: LD_ADDR_EXP 33
8034: PUSH
8035: EMPTY
8036: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8037: LD_ADDR_EXP 33
8041: PUSH
8042: LD_INT 176
8044: PPUSH
8045: LD_INT 122
8047: PPUSH
8048: LD_INT 188
8050: PPUSH
8051: LD_INT 126
8053: PPUSH
8054: LD_INT 6
8056: PPUSH
8057: CALL 1562 0 5
8061: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8062: LD_ADDR_EXP 33
8066: PUSH
8067: LD_EXP 33
8071: PUSH
8072: LD_INT 197
8074: PPUSH
8075: LD_INT 91
8077: PPUSH
8078: LD_INT 205
8080: PPUSH
8081: LD_INT 96
8083: PPUSH
8084: LD_INT 4
8086: PPUSH
8087: CALL 1562 0 5
8091: ADD
8092: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8093: LD_ADDR_EXP 33
8097: PUSH
8098: LD_EXP 33
8102: PUSH
8103: LD_INT 184
8105: PPUSH
8106: LD_INT 151
8108: PPUSH
8109: LD_INT 178
8111: PPUSH
8112: LD_INT 130
8114: PPUSH
8115: LD_INT 9
8117: PPUSH
8118: CALL 1562 0 5
8122: ADD
8123: ST_TO_ADDR
// if Difficulty > 1 then
8124: LD_OWVAR 67
8128: PUSH
8129: LD_INT 1
8131: GREATER
8132: IFFALSE 8165
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8134: LD_ADDR_EXP 33
8138: PUSH
8139: LD_EXP 33
8143: PUSH
8144: LD_INT 166
8146: PPUSH
8147: LD_INT 126
8149: PPUSH
8150: LD_INT 181
8152: PPUSH
8153: LD_INT 136
8155: PPUSH
8156: LD_INT 5
8158: PPUSH
8159: CALL 1562 0 5
8163: ADD
8164: ST_TO_ADDR
// p := 1 ;
8165: LD_ADDR_VAR 0 6
8169: PUSH
8170: LD_INT 1
8172: ST_TO_ADDR
// for i = 1 to 24 do
8173: LD_ADDR_VAR 0 3
8177: PUSH
8178: DOUBLE
8179: LD_INT 1
8181: DEC
8182: ST_TO_ADDR
8183: LD_INT 24
8185: PUSH
8186: FOR_TO
8187: IFFALSE 8241
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8189: LD_EXP 33
8193: PUSH
8194: LD_VAR 0 6
8198: ARRAY
8199: PPUSH
8200: LD_EXP 33
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: LD_INT 1
8212: PLUS
8213: ARRAY
8214: PPUSH
8215: LD_INT 8
8217: PPUSH
8218: LD_INT 0
8220: PPUSH
8221: CALL_OW 454
// p := p + 2 ;
8225: LD_ADDR_VAR 0 6
8229: PUSH
8230: LD_VAR 0 6
8234: PUSH
8235: LD_INT 2
8237: PLUS
8238: ST_TO_ADDR
// end ;
8239: GO 8186
8241: POP
8242: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8243: LD_ADDR_EXP 35
8247: PUSH
8248: LD_INT 13
8250: PUSH
8251: LD_INT 3
8253: PUSH
8254: LD_INT 2
8256: PUSH
8257: LD_INT 32
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: ST_TO_ADDR
// end ;
8266: LD_VAR 0 1
8270: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 69
8285: PUSH
8286: LD_INT 0
8288: GREATER
8289: IFFALSE 10475
8291: GO 8293
8293: DISABLE
8294: LD_INT 0
8296: PPUSH
8297: PPUSH
8298: PPUSH
8299: PPUSH
8300: PPUSH
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
// begin enable ;
8313: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_INT 22
8321: PUSH
8322: LD_INT 8
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: LD_INT 30
8331: PUSH
8332: LD_INT 1
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PPUSH
8343: CALL_OW 69
8347: PUSH
8348: LD_INT 1
8350: ARRAY
8351: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8352: LD_ADDR_VAR 0 9
8356: PUSH
8357: LD_INT 22
8359: PUSH
8360: LD_INT 8
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 30
8369: PUSH
8370: LD_INT 3
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8390: LD_ADDR_VAR 0 10
8394: PUSH
8395: LD_INT 22
8397: PUSH
8398: LD_INT 8
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 2
8407: PUSH
8408: LD_INT 30
8410: PUSH
8411: LD_INT 6
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 30
8420: PUSH
8421: LD_INT 8
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PPUSH
8437: CALL_OW 69
8441: PUSH
8442: LD_INT 1
8444: ARRAY
8445: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8446: LD_ADDR_VAR 0 11
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 32
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8480: LD_ADDR_VAR 0 16
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 2
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8514: LD_ADDR_VAR 0 15
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8548: LD_ADDR_VAR 0 14
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 3
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8582: LD_ADDR_VAR 0 13
8586: PUSH
8587: LD_INT 22
8589: PUSH
8590: LD_INT 8
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: PUSH
8597: LD_INT 25
8599: PUSH
8600: LD_INT 4
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PPUSH
8611: CALL_OW 69
8615: ST_TO_ADDR
// if l_eng then
8616: LD_VAR 0 16
8620: IFFALSE 9035
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8622: LD_ADDR_VAR 0 5
8626: PUSH
8627: LD_INT 22
8629: PUSH
8630: LD_INT 8
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: LD_INT 21
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PPUSH
8651: CALL_OW 69
8655: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8656: LD_VAR 0 5
8660: PPUSH
8661: LD_INT 3
8663: PUSH
8664: LD_INT 24
8666: PUSH
8667: LD_INT 1000
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL_OW 72
8682: PUSH
8683: LD_INT 0
8685: GREATER
8686: IFFALSE 8820
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8688: LD_ADDR_VAR 0 3
8692: PUSH
8693: LD_VAR 0 5
8697: PPUSH
8698: LD_INT 3
8700: PUSH
8701: LD_INT 24
8703: PUSH
8704: LD_INT 1000
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PPUSH
8715: CALL_OW 72
8719: ST_TO_ADDR
// for i = 1 to l_eng do
8720: LD_ADDR_VAR 0 2
8724: PUSH
8725: DOUBLE
8726: LD_INT 1
8728: DEC
8729: ST_TO_ADDR
8730: LD_VAR 0 16
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8816
// if IsInUnit ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 310
8753: IFFALSE 8772
// ComExitBuilding ( l_eng [ i ] ) else
8755: LD_VAR 0 16
8759: PUSH
8760: LD_VAR 0 2
8764: ARRAY
8765: PPUSH
8766: CALL_OW 122
8770: GO 8814
// if not HasTask ( l_eng [ i ] ) then
8772: LD_VAR 0 16
8776: PUSH
8777: LD_VAR 0 2
8781: ARRAY
8782: PPUSH
8783: CALL_OW 314
8787: NOT
8788: IFFALSE 8814
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8790: LD_VAR 0 16
8794: PUSH
8795: LD_VAR 0 2
8799: ARRAY
8800: PPUSH
8801: LD_VAR 0 3
8805: PUSH
8806: LD_INT 1
8808: ARRAY
8809: PPUSH
8810: CALL_OW 130
8814: GO 8735
8816: POP
8817: POP
// end else
8818: GO 9035
// begin if legion_blist > 0 then
8820: LD_EXP 34
8824: PUSH
8825: LD_INT 0
8827: GREATER
8828: IFFALSE 8957
// begin for i = 1 to l_eng do
8830: LD_ADDR_VAR 0 2
8834: PUSH
8835: DOUBLE
8836: LD_INT 1
8838: DEC
8839: ST_TO_ADDR
8840: LD_VAR 0 16
8844: PUSH
8845: FOR_TO
8846: IFFALSE 8953
// if IsInUnit ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 310
8863: IFFALSE 8882
// ComExitBuilding ( l_eng [ i ] ) else
8865: LD_VAR 0 16
8869: PUSH
8870: LD_VAR 0 2
8874: ARRAY
8875: PPUSH
8876: CALL_OW 122
8880: GO 8951
// if not HasTask ( l_eng [ i ] ) then
8882: LD_VAR 0 16
8886: PUSH
8887: LD_VAR 0 2
8891: ARRAY
8892: PPUSH
8893: CALL_OW 314
8897: NOT
8898: IFFALSE 8951
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8900: LD_VAR 0 16
8904: PUSH
8905: LD_VAR 0 2
8909: ARRAY
8910: PPUSH
8911: LD_EXP 34
8915: PUSH
8916: LD_INT 1
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 2
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 3
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 4
8945: ARRAY
8946: PPUSH
8947: CALL_OW 145
8951: GO 8845
8953: POP
8954: POP
// end else
8955: GO 9035
// for i = 1 to l_eng do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: DOUBLE
8963: LD_INT 1
8965: DEC
8966: ST_TO_ADDR
8967: LD_VAR 0 16
8971: PUSH
8972: FOR_TO
8973: IFFALSE 9033
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8975: LD_VAR 0 16
8979: PUSH
8980: LD_VAR 0 2
8984: ARRAY
8985: PPUSH
8986: CALL_OW 310
8990: NOT
8991: PUSH
8992: LD_VAR 0 16
8996: PUSH
8997: LD_VAR 0 2
9001: ARRAY
9002: PPUSH
9003: CALL_OW 314
9007: NOT
9008: AND
9009: IFFALSE 9031
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9011: LD_VAR 0 16
9015: PUSH
9016: LD_VAR 0 2
9020: ARRAY
9021: PPUSH
9022: LD_VAR 0 8
9026: PPUSH
9027: CALL_OW 120
9031: GO 8972
9033: POP
9034: POP
// end ; end ; if l_factory then
9035: LD_VAR 0 9
9039: IFFALSE 9439
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9041: LD_INT 22
9043: PUSH
9044: LD_INT 8
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: LD_INT 33
9053: PUSH
9054: LD_INT 2
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 3
9063: PUSH
9064: LD_INT 61
9066: PUSH
9067: EMPTY
9068: LIST
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PPUSH
9079: CALL_OW 69
9083: PUSH
9084: LD_INT 0
9086: GREATER
9087: PUSH
9088: LD_INT 22
9090: PUSH
9091: LD_INT 8
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 34
9100: PUSH
9101: LD_INT 31
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL_OW 69
9116: PUSH
9117: LD_INT 0
9119: GREATER
9120: AND
9121: IFFALSE 9241
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9123: LD_INT 22
9125: PUSH
9126: LD_INT 8
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 33
9135: PUSH
9136: LD_INT 2
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 61
9148: PUSH
9149: EMPTY
9150: LIST
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: PUSH
9166: LD_INT 1
9168: ARRAY
9169: PPUSH
9170: LD_INT 22
9172: PUSH
9173: LD_INT 8
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 34
9182: PUSH
9183: LD_INT 31
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PUSH
9199: LD_INT 1
9201: PPUSH
9202: LD_INT 22
9204: PUSH
9205: LD_INT 8
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 34
9214: PUSH
9215: LD_INT 31
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PPUSH
9226: CALL_OW 69
9230: PPUSH
9231: CALL_OW 12
9235: ARRAY
9236: PPUSH
9237: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9241: LD_EXP 35
9245: PUSH
9246: LD_INT 0
9248: GREATER
9249: PUSH
9250: LD_VAR 0 9
9254: PPUSH
9255: CALL_OW 461
9259: PUSH
9260: LD_INT 2
9262: EQUAL
9263: AND
9264: IFFALSE 9349
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9266: LD_VAR 0 9
9270: PPUSH
9271: LD_EXP 35
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 3
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: PPUSH
9307: CALL_OW 125
// for i = 1 to 4 do
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: DOUBLE
9317: LD_INT 1
9319: DEC
9320: ST_TO_ADDR
9321: LD_INT 4
9323: PUSH
9324: FOR_TO
9325: IFFALSE 9347
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9327: LD_ADDR_EXP 35
9331: PUSH
9332: LD_EXP 35
9336: PPUSH
9337: LD_INT 1
9339: PPUSH
9340: CALL_OW 3
9344: ST_TO_ADDR
9345: GO 9324
9347: POP
9348: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9349: LD_VAR 0 11
9353: PPUSH
9354: LD_INT 35
9356: PUSH
9357: LD_INT 0
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 72
9368: PUSH
9369: LD_INT 0
9371: GREATER
9372: PUSH
9373: LD_VAR 0 9
9377: PPUSH
9378: CALL_OW 461
9382: PUSH
9383: LD_INT 2
9385: EQUAL
9386: AND
9387: IFFALSE 9439
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9389: LD_VAR 0 11
9393: PPUSH
9394: LD_INT 35
9396: PUSH
9397: LD_INT 0
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 72
9408: PUSH
9409: LD_INT 1
9411: ARRAY
9412: PPUSH
9413: LD_INT 28
9415: PUSH
9416: LD_INT 27
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 2
9428: PPUSH
9429: CALL_OW 12
9433: ARRAY
9434: PPUSH
9435: CALL_OW 148
// end ; if legion_enemy > 0 then
9439: LD_EXP 36
9443: PUSH
9444: LD_INT 0
9446: GREATER
9447: IFFALSE 10027
// begin if tick mod 11 11$00 = 0 then
9449: LD_OWVAR 1
9453: PUSH
9454: LD_INT 23100
9456: MOD
9457: PUSH
9458: LD_INT 0
9460: EQUAL
9461: IFFALSE 9711
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9463: LD_ADDR_EXP 35
9467: PUSH
9468: LD_EXP 35
9472: PUSH
9473: LD_INT 13
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: ADD
9487: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9488: LD_ADDR_EXP 35
9492: PUSH
9493: LD_EXP 35
9497: PUSH
9498: LD_INT 28
9500: PUSH
9501: LD_INT 27
9503: PUSH
9504: LD_INT 29
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 1
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: ARRAY
9523: ADD
9524: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9525: LD_ADDR_EXP 35
9529: PUSH
9530: LD_EXP 35
9534: PUSH
9535: LD_INT 13
9537: PUSH
9538: LD_INT 1
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: ADD
9549: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9550: LD_ADDR_EXP 35
9554: PUSH
9555: LD_EXP 35
9559: PUSH
9560: LD_INT 28
9562: PUSH
9563: LD_INT 27
9565: PUSH
9566: LD_INT 29
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 1
9576: PPUSH
9577: LD_INT 3
9579: PPUSH
9580: CALL_OW 12
9584: ARRAY
9585: ADD
9586: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9587: LD_ADDR_EXP 35
9591: PUSH
9592: LD_EXP 35
9596: PUSH
9597: LD_INT 13
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: LD_INT 2
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: ADD
9611: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9612: LD_ADDR_EXP 35
9616: PUSH
9617: LD_EXP 35
9621: PUSH
9622: LD_INT 28
9624: PUSH
9625: LD_INT 27
9627: PUSH
9628: LD_INT 29
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 1
9638: PPUSH
9639: LD_INT 3
9641: PPUSH
9642: CALL_OW 12
9646: ARRAY
9647: ADD
9648: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9649: LD_ADDR_EXP 35
9653: PUSH
9654: LD_EXP 35
9658: PUSH
9659: LD_INT 13
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 2
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: ADD
9673: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9674: LD_ADDR_EXP 35
9678: PUSH
9679: LD_EXP 35
9683: PUSH
9684: LD_INT 28
9686: PUSH
9687: LD_INT 27
9689: PUSH
9690: LD_INT 29
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 1
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: CALL_OW 12
9708: ARRAY
9709: ADD
9710: ST_TO_ADDR
// end ; if legion_force >= 7 then
9711: LD_EXP 31
9715: PUSH
9716: LD_INT 7
9718: GREATEREQUAL
9719: IFFALSE 9902
// begin for i = 1 to legion_force do
9721: LD_ADDR_VAR 0 2
9725: PUSH
9726: DOUBLE
9727: LD_INT 1
9729: DEC
9730: ST_TO_ADDR
9731: LD_EXP 31
9735: PUSH
9736: FOR_TO
9737: IFFALSE 9900
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9739: LD_EXP 31
9743: PUSH
9744: LD_VAR 0 2
9748: ARRAY
9749: PPUSH
9750: CALL_OW 314
9754: NOT
9755: PUSH
9756: LD_EXP 31
9760: PUSH
9761: LD_VAR 0 2
9765: ARRAY
9766: PPUSH
9767: CALL_OW 110
9771: PUSH
9772: LD_INT 11
9774: NONEQUAL
9775: AND
9776: IFFALSE 9898
// begin case legion_enemy of 1 :
9778: LD_EXP 36
9782: PUSH
9783: LD_INT 1
9785: DOUBLE
9786: EQUAL
9787: IFTRUE 9791
9789: GO 9815
9791: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 142
9805: PPUSH
9806: LD_INT 144
9808: PPUSH
9809: CALL_OW 111
9813: GO 9880
9815: LD_INT 2
9817: DOUBLE
9818: EQUAL
9819: IFTRUE 9823
9821: GO 9847
9823: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9824: LD_EXP 31
9828: PUSH
9829: LD_VAR 0 2
9833: ARRAY
9834: PPUSH
9835: LD_INT 101
9837: PPUSH
9838: LD_INT 34
9840: PPUSH
9841: CALL_OW 111
9845: GO 9880
9847: LD_INT 7
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9879
9855: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9856: LD_EXP 31
9860: PUSH
9861: LD_VAR 0 2
9865: ARRAY
9866: PPUSH
9867: LD_INT 173
9869: PPUSH
9870: LD_INT 127
9872: PPUSH
9873: CALL_OW 111
9877: GO 9880
9879: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9880: LD_EXP 31
9884: PUSH
9885: LD_VAR 0 2
9889: ARRAY
9890: PPUSH
9891: LD_INT 11
9893: PPUSH
9894: CALL_OW 109
// end ; end ;
9898: GO 9736
9900: POP
9901: POP
// end ; if legion_force then
9902: LD_EXP 31
9906: IFFALSE 10027
// begin tmp := legion_force ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_EXP 31
9917: ST_TO_ADDR
// for i = 1 to tmp do
9918: LD_ADDR_VAR 0 2
9922: PUSH
9923: DOUBLE
9924: LD_INT 1
9926: DEC
9927: ST_TO_ADDR
9928: LD_VAR 0 3
9932: PUSH
9933: FOR_TO
9934: IFFALSE 10025
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9936: LD_VAR 0 3
9940: PUSH
9941: LD_VAR 0 2
9945: ARRAY
9946: PPUSH
9947: CALL_OW 314
9951: NOT
9952: PUSH
9953: LD_EXP 31
9957: PUSH
9958: LD_VAR 0 2
9962: ARRAY
9963: PPUSH
9964: CALL_OW 110
9968: PUSH
9969: LD_INT 11
9971: EQUAL
9972: AND
9973: IFFALSE 10023
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9975: LD_VAR 0 3
9979: PUSH
9980: LD_VAR 0 2
9984: ARRAY
9985: PPUSH
9986: LD_INT 22
9988: PUSH
9989: LD_EXP 36
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PPUSH
9998: CALL_OW 69
10002: PPUSH
10003: LD_VAR 0 3
10007: PUSH
10008: LD_VAR 0 2
10012: ARRAY
10013: PPUSH
10014: CALL_OW 74
10018: PPUSH
10019: CALL_OW 115
10023: GO 9933
10025: POP
10026: POP
// end ; end ; p := 1 ;
10027: LD_ADDR_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: ST_TO_ADDR
// for i = 1 to 24 do
10035: LD_ADDR_VAR 0 2
10039: PUSH
10040: DOUBLE
10041: LD_INT 1
10043: DEC
10044: ST_TO_ADDR
10045: LD_INT 24
10047: PUSH
10048: FOR_TO
10049: IFFALSE 10179
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10051: LD_EXP 33
10055: PUSH
10056: LD_VAR 0 6
10060: ARRAY
10061: PPUSH
10062: LD_EXP 33
10066: PUSH
10067: LD_VAR 0 6
10071: PUSH
10072: LD_INT 1
10074: PLUS
10075: ARRAY
10076: PPUSH
10077: CALL_OW 428
10081: PUSH
10082: LD_INT 0
10084: GREATER
10085: IFFALSE 10163
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10087: LD_EXP 33
10091: PUSH
10092: LD_VAR 0 6
10096: ARRAY
10097: PPUSH
10098: LD_EXP 33
10102: PUSH
10103: LD_VAR 0 6
10107: PUSH
10108: LD_INT 1
10110: PLUS
10111: ARRAY
10112: PPUSH
10113: CALL_OW 428
10117: PPUSH
10118: CALL_OW 255
10122: PUSH
10123: LD_EXP 36
10127: EQUAL
10128: IFFALSE 10163
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10130: LD_EXP 33
10134: PUSH
10135: LD_VAR 0 6
10139: ARRAY
10140: PPUSH
10141: LD_EXP 33
10145: PUSH
10146: LD_VAR 0 6
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 8
10158: PPUSH
10159: CALL_OW 456
// p := p + 2 ;
10163: LD_ADDR_VAR 0 6
10167: PUSH
10168: LD_VAR 0 6
10172: PUSH
10173: LD_INT 2
10175: PLUS
10176: ST_TO_ADDR
// end ;
10177: GO 10048
10179: POP
10180: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10181: LD_INT 22
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 34
10193: PUSH
10194: LD_INT 32
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PPUSH
10205: CALL_OW 69
10209: IFFALSE 10323
// begin if l_cargo = false then
10211: LD_VAR 0 17
10215: PUSH
10216: LD_INT 0
10218: EQUAL
10219: IFFALSE 10255
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10221: LD_ADDR_VAR 0 17
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_INT 8
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 34
10238: PUSH
10239: LD_INT 32
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: ST_TO_ADDR
// if l_cargo then
10255: LD_VAR 0 17
10259: IFFALSE 10323
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10261: LD_ADDR_VAR 0 7
10265: PUSH
10266: LD_INT 14
10268: PPUSH
10269: CALL_OW 435
10273: ST_TO_ADDR
// if cr > 0 then
10274: LD_VAR 0 7
10278: PUSH
10279: LD_INT 0
10281: GREATER
10282: IFFALSE 10323
// if not HasTask ( l_cargo ) then
10284: LD_VAR 0 17
10288: PPUSH
10289: CALL_OW 314
10293: NOT
10294: IFFALSE 10323
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10296: LD_VAR 0 17
10300: PPUSH
10301: LD_VAR 0 7
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 2
10317: ARRAY
10318: PPUSH
10319: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10323: LD_OWVAR 1
10327: PUSH
10328: LD_INT 52500
10330: PUSH
10331: LD_INT 46200
10333: PUSH
10334: LD_INT 42000
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: LD_OWVAR 67
10346: ARRAY
10347: EQUAL
10348: PUSH
10349: LD_INT 1
10351: PPUSH
10352: CALL_OW 469
10356: PUSH
10357: LD_INT 1
10359: ARRAY
10360: PUSH
10361: LD_INT 112
10363: EQUAL
10364: AND
10365: PUSH
10366: LD_INT 1
10368: PPUSH
10369: CALL_OW 469
10373: PUSH
10374: LD_INT 2
10376: ARRAY
10377: PUSH
10378: LD_INT 67
10380: EQUAL
10381: AND
10382: IFFALSE 10475
// begin un := l_eng [ 1 ] ;
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_VAR 0 16
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: ST_TO_ADDR
// if IsInUnit ( un ) then
10398: LD_VAR 0 1
10402: PPUSH
10403: CALL_OW 310
10407: IFFALSE 10418
// ComExitBuilding ( un ) ;
10409: LD_VAR 0 1
10413: PPUSH
10414: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: LD_INT 1
10425: PPUSH
10426: CALL_OW 469
10430: PUSH
10431: LD_INT 1
10433: ARRAY
10434: PPUSH
10435: LD_INT 1
10437: PPUSH
10438: CALL_OW 469
10442: PUSH
10443: LD_INT 2
10445: ARRAY
10446: PPUSH
10447: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10451: LD_VAR 0 1
10455: PPUSH
10456: LD_INT 207
10458: PPUSH
10459: LD_INT 123
10461: PPUSH
10462: CALL_OW 171
// AddComUnload ( un ) ;
10466: LD_VAR 0 1
10470: PPUSH
10471: CALL_OW 219
// end ; end ;
10475: PPOPN 17
10477: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10478: LD_OWVAR 67
10482: PUSH
10483: LD_INT 1
10485: GREATER
10486: IFFALSE 10691
10488: GO 10490
10490: DISABLE
10491: LD_INT 0
10493: PPUSH
10494: PPUSH
10495: PPUSH
10496: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10497: LD_INT 35
10499: PPUSH
10500: LD_INT 12635
10502: PPUSH
10503: CALL_OW 12
10507: PPUSH
10508: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10512: LD_ADDR_VAR 0 2
10516: PUSH
10517: LD_INT 22
10519: PUSH
10520: LD_INT 8
10522: PUSH
10523: EMPTY
10524: LIST
10525: LIST
10526: PUSH
10527: LD_INT 25
10529: PUSH
10530: LD_INT 4
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PPUSH
10541: CALL_OW 69
10545: ST_TO_ADDR
// p := 1 ;
10546: LD_ADDR_VAR 0 4
10550: PUSH
10551: LD_INT 1
10553: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10554: LD_ADDR_VAR 0 3
10558: PUSH
10559: LD_INT 116
10561: PUSH
10562: LD_INT 139
10564: PUSH
10565: LD_INT 69
10567: PUSH
10568: LD_INT 13
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: ST_TO_ADDR
// for i = 1 to 2 do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: DOUBLE
10583: LD_INT 1
10585: DEC
10586: ST_TO_ADDR
10587: LD_INT 2
10589: PUSH
10590: FOR_TO
10591: IFFALSE 10689
// begin if IsInUnit ( sci [ i ] ) then
10593: LD_VAR 0 2
10597: PUSH
10598: LD_VAR 0 1
10602: ARRAY
10603: PPUSH
10604: CALL_OW 310
10608: IFFALSE 10625
// ComExitBuilding ( sci [ i ] ) ;
10610: LD_VAR 0 2
10614: PUSH
10615: LD_VAR 0 1
10619: ARRAY
10620: PPUSH
10621: CALL_OW 122
// Wait ( 0 0$03 ) ;
10625: LD_INT 105
10627: PPUSH
10628: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10632: LD_VAR 0 2
10636: PUSH
10637: LD_VAR 0 1
10641: ARRAY
10642: PPUSH
10643: LD_VAR 0 3
10647: PUSH
10648: LD_VAR 0 4
10652: ARRAY
10653: PPUSH
10654: LD_VAR 0 3
10658: PUSH
10659: LD_VAR 0 4
10663: PUSH
10664: LD_INT 1
10666: PLUS
10667: ARRAY
10668: PPUSH
10669: CALL_OW 158
// p := p + 2 ;
10673: LD_ADDR_VAR 0 4
10677: PUSH
10678: LD_VAR 0 4
10682: PUSH
10683: LD_INT 2
10685: PLUS
10686: ST_TO_ADDR
// end ;
10687: GO 10590
10689: POP
10690: POP
// end ;
10691: PPOPN 4
10693: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10694: LD_INT 14
10696: PPUSH
10697: CALL_OW 435
10701: PUSH
10702: LD_INT 20
10704: LESS
10705: IFFALSE 10732
10707: GO 10709
10709: DISABLE
// begin enable ;
10710: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10711: LD_INT 1
10713: PPUSH
10714: LD_INT 5
10716: PPUSH
10717: CALL_OW 12
10721: PPUSH
10722: LD_INT 14
10724: PPUSH
10725: LD_INT 1
10727: PPUSH
10728: CALL_OW 55
// end ; end_of_file
10732: END
// export function Action ; var un , gamemode , speaker ; begin
10733: LD_INT 0
10735: PPUSH
10736: PPUSH
10737: PPUSH
10738: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10739: LD_ADDR_OWVAR 67
10743: PUSH
10744: LD_INT 0
10746: PPUSH
10747: CALL_OW 426
10751: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: PPUSH
10760: CALL_OW 426
10764: ST_TO_ADDR
// if gamemode = 1 then
10765: LD_VAR 0 3
10769: PUSH
10770: LD_INT 1
10772: EQUAL
10773: IFFALSE 10797
// begin your_side := 1 ;
10775: LD_ADDR_OWVAR 2
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// legion_enemy := 1 ;
10783: LD_ADDR_EXP 36
10787: PUSH
10788: LD_INT 1
10790: ST_TO_ADDR
// PrepareAmerican ;
10791: CALL 221 0 0
// end else
10795: GO 10849
// if gamemode = 2 then
10797: LD_VAR 0 3
10801: PUSH
10802: LD_INT 2
10804: EQUAL
10805: IFFALSE 10829
// begin your_side := 2 ;
10807: LD_ADDR_OWVAR 2
10811: PUSH
10812: LD_INT 2
10814: ST_TO_ADDR
// legion_enemy := 2 ;
10815: LD_ADDR_EXP 36
10819: PUSH
10820: LD_INT 2
10822: ST_TO_ADDR
// PrepareArabian ;
10823: CALL 18138 0 0
// end else
10827: GO 10849
// begin your_side := 7 ;
10829: LD_ADDR_OWVAR 2
10833: PUSH
10834: LD_INT 7
10836: ST_TO_ADDR
// legion_enemy := 7 ;
10837: LD_ADDR_EXP 36
10841: PUSH
10842: LD_INT 7
10844: ST_TO_ADDR
// PrepareAlliance ;
10845: CALL 15549 0 0
// end ; if your_side = 1 then
10849: LD_OWVAR 2
10853: PUSH
10854: LD_INT 1
10856: EQUAL
10857: IFFALSE 11335
// begin case Query ( QVul4 ) of 1 :
10859: LD_STRING QVul4
10861: PPUSH
10862: CALL_OW 97
10866: PUSH
10867: LD_INT 1
10869: DOUBLE
10870: EQUAL
10871: IFTRUE 10875
10873: GO 10878
10875: POP
// ; end ;
10876: GO 10879
10878: POP
// InGameOn ;
10879: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10883: LD_INT 8
10885: PPUSH
10886: LD_INT 5
10888: PPUSH
10889: CALL_OW 86
// uc_side := 4 ;
10893: LD_ADDR_OWVAR 20
10897: PUSH
10898: LD_INT 4
10900: ST_TO_ADDR
// uc_nation := 1 ;
10901: LD_ADDR_OWVAR 21
10905: PUSH
10906: LD_INT 1
10908: ST_TO_ADDR
// hc_importance := 0 ;
10909: LD_ADDR_OWVAR 32
10913: PUSH
10914: LD_INT 0
10916: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10917: LD_INT 1
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_EXP 21
10927: PPUSH
10928: CALL_OW 380
// un := CreateHuman ;
10932: LD_ADDR_VAR 0 2
10936: PUSH
10937: CALL_OW 44
10941: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10942: LD_VAR 0 2
10946: PPUSH
10947: LD_INT 12
10949: PPUSH
10950: LD_INT 9
10952: PPUSH
10953: LD_INT 0
10955: PPUSH
10956: CALL_OW 48
// hc_name := Stuart Carey ;
10960: LD_ADDR_OWVAR 26
10964: PUSH
10965: LD_STRING Stuart Carey
10967: ST_TO_ADDR
// hc_class := 1 ;
10968: LD_ADDR_OWVAR 28
10972: PUSH
10973: LD_INT 1
10975: ST_TO_ADDR
// hc_gallery := vulcano ;
10976: LD_ADDR_OWVAR 33
10980: PUSH
10981: LD_STRING vulcano
10983: ST_TO_ADDR
// hc_face_number := 1 ;
10984: LD_ADDR_OWVAR 34
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// us_guy := CreateHuman ;
10992: LD_ADDR_EXP 22
10996: PUSH
10997: CALL_OW 44
11001: ST_TO_ADDR
// InitHc ;
11002: CALL_OW 19
// if rand ( 0 , 1 ) then
11006: LD_INT 0
11008: PPUSH
11009: LD_INT 1
11011: PPUSH
11012: CALL_OW 12
11016: IFFALSE 11033
// PrepareHuman ( sex_male , 3 , 6 ) else
11018: LD_INT 1
11020: PPUSH
11021: LD_INT 3
11023: PPUSH
11024: LD_INT 6
11026: PPUSH
11027: CALL_OW 380
11031: GO 11046
// PrepareHuman ( sex_female , 4 , 8 ) ;
11033: LD_INT 2
11035: PPUSH
11036: LD_INT 4
11038: PPUSH
11039: LD_INT 8
11041: PPUSH
11042: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_EXP 19
11055: PPUSH
11056: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11060: LD_EXP 19
11064: PPUSH
11065: LD_VAR 0 2
11069: PPUSH
11070: CALL_OW 119
// if GetSex ( un ) = sex_male then
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 258
11083: PUSH
11084: LD_INT 1
11086: EQUAL
11087: IFFALSE 11170
// begin Say ( un , VD-un1 ) ;
11089: LD_VAR 0 2
11093: PPUSH
11094: LD_STRING VD-un1
11096: PPUSH
11097: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11101: LD_EXP 19
11105: PPUSH
11106: LD_STRING VDc-1
11108: PPUSH
11109: CALL_OW 88
// Say ( un , VD-un2 ) ;
11113: LD_VAR 0 2
11117: PPUSH
11118: LD_STRING VD-un2
11120: PPUSH
11121: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11125: LD_EXP 19
11129: PPUSH
11130: LD_STRING VDc-2
11132: PPUSH
11133: CALL_OW 88
// Say ( un , VD-un3 ) ;
11137: LD_VAR 0 2
11141: PPUSH
11142: LD_STRING VD-un3
11144: PPUSH
11145: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11149: LD_INT 7
11151: PPUSH
11152: CALL_OW 67
// Say ( un , VD-un4 ) ;
11156: LD_VAR 0 2
11160: PPUSH
11161: LD_STRING VD-un4
11163: PPUSH
11164: CALL_OW 88
// end else
11168: GO 11249
// begin Say ( un , VD-unf1 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_STRING VD-unf1
11177: PPUSH
11178: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11182: LD_EXP 19
11186: PPUSH
11187: LD_STRING VDc-1
11189: PPUSH
11190: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11194: LD_VAR 0 2
11198: PPUSH
11199: LD_STRING VD-unf2
11201: PPUSH
11202: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11206: LD_EXP 19
11210: PPUSH
11211: LD_STRING VDc-2
11213: PPUSH
11214: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11218: LD_VAR 0 2
11222: PPUSH
11223: LD_STRING VD-unf3
11225: PPUSH
11226: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11230: LD_INT 7
11232: PPUSH
11233: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11237: LD_VAR 0 2
11241: PPUSH
11242: LD_STRING VD-unf4
11244: PPUSH
11245: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11249: LD_VAR 0 2
11253: PPUSH
11254: LD_INT 2
11256: PPUSH
11257: LD_INT 2
11259: PPUSH
11260: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11264: LD_EXP 19
11268: PPUSH
11269: LD_STRING VDc-3
11271: PPUSH
11272: CALL_OW 88
// InGameOff ;
11276: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11280: LD_STRING CVulc1
11282: PPUSH
11283: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11287: LD_INT 35
11289: PPUSH
11290: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11294: LD_VAR 0 2
11298: PPUSH
11299: CALL_OW 250
11303: PUSH
11304: LD_INT 2
11306: EQUAL
11307: PUSH
11308: LD_VAR 0 2
11312: PPUSH
11313: CALL_OW 251
11317: PUSH
11318: LD_INT 2
11320: EQUAL
11321: AND
11322: IFFALSE 11287
// RemoveUnit ( un ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: CALL_OW 64
// end else
11333: GO 11712
// if your_side = 2 then
11335: LD_OWVAR 2
11339: PUSH
11340: LD_INT 2
11342: EQUAL
11343: IFFALSE 11559
// begin CenterNowOnUnits ( player_commander ) ;
11345: LD_EXP 10
11349: PPUSH
11350: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11354: LD_ADDR_VAR 0 4
11358: PUSH
11359: LD_INT 22
11361: PUSH
11362: LD_INT 2
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PUSH
11369: LD_INT 21
11371: PUSH
11372: LD_INT 1
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PPUSH
11383: CALL_OW 69
11387: PUSH
11388: LD_EXP 51
11392: DIFF
11393: ST_TO_ADDR
// if speaker then
11394: LD_VAR 0 4
11398: IFFALSE 11550
// begin InGameOn ;
11400: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11404: LD_EXP 51
11408: PPUSH
11409: LD_STRING VSd-1
11411: PPUSH
11412: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11416: LD_VAR 0 4
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: CALL_OW 258
11429: PUSH
11430: LD_INT 1
11432: EQUAL
11433: IFFALSE 11453
// Say ( speaker [ 1 ] , VAd-1 ) else
11435: LD_VAR 0 4
11439: PUSH
11440: LD_INT 1
11442: ARRAY
11443: PPUSH
11444: LD_STRING VAd-1
11446: PPUSH
11447: CALL_OW 88
11451: GO 11469
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11453: LD_VAR 0 4
11457: PUSH
11458: LD_INT 1
11460: ARRAY
11461: PPUSH
11462: LD_STRING VAfd-1
11464: PPUSH
11465: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11469: LD_EXP 51
11473: PPUSH
11474: LD_STRING VSd-2
11476: PPUSH
11477: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11481: LD_VAR 0 4
11485: PUSH
11486: LD_INT 1
11488: ARRAY
11489: PPUSH
11490: CALL_OW 258
11494: PUSH
11495: LD_INT 1
11497: EQUAL
11498: IFFALSE 11518
// Say ( speaker [ 1 ] , VAd-2 ) else
11500: LD_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ARRAY
11508: PPUSH
11509: LD_STRING VAd-2
11511: PPUSH
11512: CALL_OW 88
11516: GO 11534
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11518: LD_VAR 0 4
11522: PUSH
11523: LD_INT 1
11525: ARRAY
11526: PPUSH
11527: LD_STRING VAfd-2
11529: PPUSH
11530: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11534: LD_EXP 51
11538: PPUSH
11539: LD_STRING VSd-3
11541: PPUSH
11542: CALL_OW 88
// InGameOff ;
11546: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11550: LD_STRING CVulc5
11552: PPUSH
11553: CALL_OW 337
// end else
11557: GO 11712
// if your_side = 7 then
11559: LD_OWVAR 2
11563: PUSH
11564: LD_INT 7
11566: EQUAL
11567: IFFALSE 11712
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11569: LD_ADDR_VAR 0 4
11573: PUSH
11574: LD_INT 22
11576: PUSH
11577: LD_INT 7
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 21
11586: PUSH
11587: LD_INT 1
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PPUSH
11598: CALL_OW 69
11602: PUSH
11603: LD_EXP 37
11607: DIFF
11608: ST_TO_ADDR
// if speaker then
11609: LD_VAR 0 4
11613: IFFALSE 11705
// begin CenterNowOnUnits ( al_commander ) ;
11615: LD_EXP 37
11619: PPUSH
11620: CALL_OW 87
// InGameOn ;
11624: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11628: LD_EXP 37
11632: PPUSH
11633: LD_STRING VPd-1
11635: PPUSH
11636: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11640: LD_VAR 0 4
11644: PUSH
11645: LD_INT 1
11647: ARRAY
11648: PPUSH
11649: CALL_OW 258
11653: IFFALSE 11673
// Say ( speaker [ 1 ] , VPpd-1 ) else
11655: LD_VAR 0 4
11659: PUSH
11660: LD_INT 1
11662: ARRAY
11663: PPUSH
11664: LD_STRING VPpd-1
11666: PPUSH
11667: CALL_OW 88
11671: GO 11689
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11673: LD_VAR 0 4
11677: PUSH
11678: LD_INT 1
11680: ARRAY
11681: PPUSH
11682: LD_STRING VPpdf-1
11684: PPUSH
11685: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11689: LD_EXP 37
11693: PPUSH
11694: LD_STRING VPd-2
11696: PPUSH
11697: CALL_OW 88
// InGameOff ;
11701: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11705: LD_STRING CVulc7
11707: PPUSH
11708: CALL_OW 337
// end ; SaveForQuickRestart ;
11712: CALL_OW 22
// end ;
11716: LD_VAR 0 1
11720: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11721: LD_INT 22
11723: PUSH
11724: LD_INT 2
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: LD_INT 30
11733: PUSH
11734: LD_INT 3
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PPUSH
11745: CALL_OW 69
11749: IFFALSE 11793
11751: GO 11753
11753: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11754: LD_STRING CVulc6
11756: PPUSH
11757: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11761: LD_INT 52500
11763: PUSH
11764: LD_INT 47250
11766: PUSH
11767: LD_INT 42000
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_OWVAR 67
11779: ARRAY
11780: PPUSH
11781: CALL_OW 67
// ru_can_attack := true ;
11785: LD_ADDR_EXP 3
11789: PUSH
11790: LD_INT 1
11792: ST_TO_ADDR
// end ;
11793: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11794: LD_INT 50
11796: PPUSH
11797: CALL_OW 255
11801: PUSH
11802: LD_INT 1
11804: EQUAL
11805: PUSH
11806: LD_INT 22
11808: PUSH
11809: LD_INT 1
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: LD_INT 30
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 30
11831: PUSH
11832: LD_INT 1
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: CALL_OW 69
11852: OR
11853: IFFALSE 12087
11855: GO 11857
11857: DISABLE
11858: LD_INT 0
11860: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11861: LD_STRING CVulc2
11863: PPUSH
11864: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11868: LD_ADDR_VAR 0 1
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_INT 1
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 25
11885: PUSH
11886: LD_INT 2
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PPUSH
11897: CALL_OW 69
11901: PUSH
11902: LD_EXP 19
11906: DIFF
11907: ST_TO_ADDR
// DialogueOn ;
11908: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11912: LD_INT 10
11914: PPUSH
11915: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11919: LD_VAR 0 1
11923: PUSH
11924: LD_INT 1
11926: ARRAY
11927: PPUSH
11928: CALL_OW 258
11932: PUSH
11933: LD_INT 1
11935: EQUAL
11936: IFFALSE 11956
// Say ( speaker [ 1 ] , VDb-1 ) else
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 1
11945: ARRAY
11946: PPUSH
11947: LD_STRING VDb-1
11949: PPUSH
11950: CALL_OW 88
11954: GO 11972
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11956: LD_VAR 0 1
11960: PUSH
11961: LD_INT 1
11963: ARRAY
11964: PPUSH
11965: LD_STRING VDbf-1
11967: PPUSH
11968: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11972: LD_INT 10
11974: PPUSH
11975: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11979: LD_VAR 0 1
11983: PUSH
11984: LD_INT 1
11986: ARRAY
11987: PPUSH
11988: CALL_OW 258
11992: PUSH
11993: LD_INT 1
11995: EQUAL
11996: IFFALSE 12016
// Say ( speaker [ 1 ] , VDb-2 ) else
11998: LD_VAR 0 1
12002: PUSH
12003: LD_INT 1
12005: ARRAY
12006: PPUSH
12007: LD_STRING VDb-2
12009: PPUSH
12010: CALL_OW 88
12014: GO 12032
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12016: LD_VAR 0 1
12020: PUSH
12021: LD_INT 1
12023: ARRAY
12024: PPUSH
12025: LD_STRING VDbf-2
12027: PPUSH
12028: CALL_OW 88
// DWait ( 0 0$01 ) ;
12032: LD_INT 35
12034: PPUSH
12035: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12039: LD_EXP 19
12043: PPUSH
12044: LD_STRING VDb-com1
12046: PPUSH
12047: CALL_OW 88
// DialogueOff ;
12051: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12055: LD_INT 44100
12057: PUSH
12058: LD_INT 36750
12060: PUSH
12061: LD_INT 31500
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: PUSH
12069: LD_OWVAR 67
12073: ARRAY
12074: PPUSH
12075: CALL_OW 67
// ru_can_attack := true ;
12079: LD_ADDR_EXP 3
12083: PUSH
12084: LD_INT 1
12086: ST_TO_ADDR
// end ;
12087: PPOPN 1
12089: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12090: LD_INT 22
12092: PUSH
12093: LD_INT 7
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 30
12102: PUSH
12103: LD_INT 3
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: IFFALSE 12155
12120: GO 12122
12122: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12123: LD_INT 42000
12125: PUSH
12126: LD_INT 34650
12128: PUSH
12129: LD_INT 29400
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: LIST
12136: PUSH
12137: LD_OWVAR 67
12141: ARRAY
12142: PPUSH
12143: CALL_OW 67
// ru_can_attack := true ;
12147: LD_ADDR_EXP 3
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// end ;
12155: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12156: LD_INT 58
12158: PPUSH
12159: CALL_OW 255
12163: PUSH
12164: LD_INT 1
12166: EQUAL
12167: IFFALSE 12374
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12175: LD_ADDR_VAR 0 1
12179: PUSH
12180: LD_INT 22
12182: PUSH
12183: LD_INT 1
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 25
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PPUSH
12204: CALL_OW 69
12208: ST_TO_ADDR
// DialogueOn ;
12209: CALL_OW 6
// if speaker then
12213: LD_VAR 0 1
12217: IFFALSE 12272
// if GetSex ( speaker [ 1 ] ) = sex_male then
12219: LD_VAR 0 1
12223: PUSH
12224: LD_INT 1
12226: ARRAY
12227: PPUSH
12228: CALL_OW 258
12232: PUSH
12233: LD_INT 1
12235: EQUAL
12236: IFFALSE 12256
// Say ( speaker [ 1 ] , VDe-1 ) else
12238: LD_VAR 0 1
12242: PUSH
12243: LD_INT 1
12245: ARRAY
12246: PPUSH
12247: LD_STRING VDe-1
12249: PPUSH
12250: CALL_OW 88
12254: GO 12272
// Say ( speaker [ 1 ] , VDef-1 ) ;
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 1
12263: ARRAY
12264: PPUSH
12265: LD_STRING VDef-1
12267: PPUSH
12268: CALL_OW 88
// case Query ( SibNote ) of 1 :
12272: LD_STRING SibNote
12274: PPUSH
12275: CALL_OW 97
12279: PUSH
12280: LD_INT 1
12282: DOUBLE
12283: EQUAL
12284: IFTRUE 12288
12286: GO 12291
12288: POP
// ; end ;
12289: GO 12292
12291: POP
// if speaker then
12292: LD_VAR 0 1
12296: IFFALSE 12351
// if GetSex ( speaker [ 1 ] ) = sex_male then
12298: LD_VAR 0 1
12302: PUSH
12303: LD_INT 1
12305: ARRAY
12306: PPUSH
12307: CALL_OW 258
12311: PUSH
12312: LD_INT 1
12314: EQUAL
12315: IFFALSE 12335
// Say ( speaker [ 1 ] , VDe-2 ) else
12317: LD_VAR 0 1
12321: PUSH
12322: LD_INT 1
12324: ARRAY
12325: PPUSH
12326: LD_STRING VDe-2
12328: PPUSH
12329: CALL_OW 88
12333: GO 12351
// Say ( speaker [ 1 ] , VDef-2 ) ;
12335: LD_VAR 0 1
12339: PUSH
12340: LD_INT 1
12342: ARRAY
12343: PPUSH
12344: LD_STRING VDef-2
12346: PPUSH
12347: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12351: LD_EXP 19
12355: PPUSH
12356: LD_STRING VDc-4
12358: PPUSH
12359: CALL_OW 88
// DialogueOff ;
12363: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12367: LD_STRING CVulc3
12369: PPUSH
12370: CALL_OW 337
// end ;
12374: PPOPN 1
12376: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12377: LD_OWVAR 2
12381: PUSH
12382: LD_INT 1
12384: EQUAL
12385: PUSH
12386: LD_INT 22
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PUSH
12396: LD_INT 30
12398: PUSH
12399: LD_INT 3
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PUSH
12406: EMPTY
12407: LIST
12408: LIST
12409: PPUSH
12410: CALL_OW 69
12414: PUSH
12415: LD_INT 0
12417: GREATER
12418: AND
12419: IFFALSE 12853
12421: GO 12423
12423: DISABLE
12424: LD_INT 0
12426: PPUSH
12427: PPUSH
12428: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12429: LD_INT 245
12431: PPUSH
12432: LD_INT 1295
12434: PPUSH
12435: CALL_OW 12
12439: PPUSH
12440: CALL_OW 67
// DialogueOn ;
12444: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12448: LD_EXP 22
12452: PPUSH
12453: LD_STRING VDG-1
12455: PPUSH
12456: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12460: LD_EXP 19
12464: PPUSH
12465: LD_STRING VDc-5
12467: PPUSH
12468: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12472: LD_EXP 22
12476: PPUSH
12477: LD_STRING VDG-2
12479: PPUSH
12480: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12484: LD_EXP 19
12488: PPUSH
12489: LD_STRING VDc-6
12491: PPUSH
12492: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12496: LD_EXP 22
12500: PPUSH
12501: LD_STRING VDG-3
12503: PPUSH
12504: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12508: LD_EXP 19
12512: PPUSH
12513: LD_STRING VDc-7
12515: PPUSH
12516: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12520: LD_EXP 22
12524: PPUSH
12525: LD_STRING VDG-4
12527: PPUSH
12528: CALL_OW 94
// DialogueOff ;
12532: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12536: LD_STRING CVulc4
12538: PPUSH
12539: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12543: LD_INT 18900
12545: PUSH
12546: LD_INT 21000
12548: PUSH
12549: LD_INT 23100
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PUSH
12557: LD_OWVAR 67
12561: ARRAY
12562: PPUSH
12563: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12567: LD_ADDR_VAR 0 1
12571: PUSH
12572: DOUBLE
12573: LD_INT 1
12575: DEC
12576: ST_TO_ADDR
12577: LD_INT 4
12579: PUSH
12580: LD_INT 5
12582: PUSH
12583: LD_INT 6
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: LD_OWVAR 67
12595: ARRAY
12596: PUSH
12597: FOR_TO
12598: IFFALSE 12842
// begin uc_side := 1 ;
12600: LD_ADDR_OWVAR 20
12604: PUSH
12605: LD_INT 1
12607: ST_TO_ADDR
// uc_nation := 1 ;
12608: LD_ADDR_OWVAR 21
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12616: LD_INT 0
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: LD_INT 4
12624: PPUSH
12625: CALL_OW 12
12629: PPUSH
12630: LD_EXP 21
12634: PPUSH
12635: CALL_OW 380
// un := CreateHuman ;
12639: LD_ADDR_VAR 0 2
12643: PUSH
12644: CALL_OW 44
12648: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12649: LD_VAR 0 2
12653: PPUSH
12654: LD_INT 2
12656: PPUSH
12657: CALL_OW 233
// if GetClass ( un ) = 3 then
12661: LD_VAR 0 2
12665: PPUSH
12666: CALL_OW 257
12670: PUSH
12671: LD_INT 3
12673: EQUAL
12674: IFFALSE 12825
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12676: LD_ADDR_OWVAR 37
12680: PUSH
12681: LD_INT 2
12683: PUSH
12684: LD_INT 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: LD_VAR 0 1
12695: PUSH
12696: LD_INT 2
12698: MOD
12699: ARRAY
12700: ST_TO_ADDR
// vc_engine := engine_combustion ;
12701: LD_ADDR_OWVAR 39
12705: PUSH
12706: LD_INT 1
12708: ST_TO_ADDR
// vc_control := control_manual ;
12709: LD_ADDR_OWVAR 38
12713: PUSH
12714: LD_INT 1
12716: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12717: LD_ADDR_OWVAR 40
12721: PUSH
12722: LD_INT 9
12724: PUSH
12725: LD_INT 9
12727: PUSH
12728: LD_INT 5
12730: PUSH
12731: LD_INT 11
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 1
12742: PPUSH
12743: LD_INT 4
12745: PPUSH
12746: CALL_OW 12
12750: ARRAY
12751: ST_TO_ADDR
// veh := CreateVehicle ;
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: CALL_OW 45
12761: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12762: LD_VAR 0 3
12766: PPUSH
12767: LD_INT 2
12769: PPUSH
12770: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12774: LD_VAR 0 3
12778: PPUSH
12779: LD_INT 77
12781: PPUSH
12782: LD_INT 88
12784: PPUSH
12785: CALL_OW 12
12789: PPUSH
12790: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12794: LD_VAR 0 3
12798: PPUSH
12799: LD_INT 1
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: CALL_OW 52
// end else
12823: GO 12840
// PlaceUnitArea ( un , start_north , false ) ;
12825: LD_VAR 0 2
12829: PPUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 49
// end ;
12840: GO 12597
12842: POP
12843: POP
// CenterNowOnUnits ( un ) ;
12844: LD_VAR 0 2
12848: PPUSH
12849: CALL_OW 87
// end ;
12853: PPOPN 3
12855: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12856: LD_INT 21
12858: PPUSH
12859: LD_INT 22
12861: PUSH
12862: LD_OWVAR 2
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PPUSH
12871: CALL_OW 70
12875: IFFALSE 13196
12877: GO 12879
12879: DISABLE
12880: LD_INT 0
12882: PPUSH
12883: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12884: LD_ADDR_VAR 0 2
12888: PUSH
12889: LD_INT 22
12891: PUSH
12892: LD_OWVAR 2
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PUSH
12901: LD_INT 2
12903: PUSH
12904: LD_INT 25
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 25
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 25
12936: PUSH
12937: LD_INT 4
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PPUSH
12955: CALL_OW 69
12959: PUSH
12960: LD_EXP 10
12964: DIFF
12965: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12966: LD_ADDR_VAR 0 1
12970: PUSH
12971: LD_VAR 0 2
12975: PPUSH
12976: LD_INT 112
12978: PPUSH
12979: LD_INT 67
12981: PPUSH
12982: CALL_OW 73
12986: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12987: LD_VAR 0 1
12991: PPUSH
12992: CALL_OW 255
12996: PUSH
12997: LD_INT 7
12999: EQUAL
13000: IFFALSE 13043
// if GetSex ( un ) = sex_male then
13002: LD_VAR 0 1
13006: PPUSH
13007: CALL_OW 258
13011: PUSH
13012: LD_INT 1
13014: EQUAL
13015: IFFALSE 13031
// Say ( un , VD-find-al ) else
13017: LD_VAR 0 1
13021: PPUSH
13022: LD_STRING VD-find-al
13024: PPUSH
13025: CALL_OW 88
13029: GO 13043
// Say ( un , VD-find-al-f ) ;
13031: LD_VAR 0 1
13035: PPUSH
13036: LD_STRING VD-find-al-f
13038: PPUSH
13039: CALL_OW 88
// if GetSide ( un ) = 2 then
13043: LD_VAR 0 1
13047: PPUSH
13048: CALL_OW 255
13052: PUSH
13053: LD_INT 2
13055: EQUAL
13056: IFFALSE 13099
// if GetSex ( un ) = sex_male then
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL_OW 258
13067: PUSH
13068: LD_INT 1
13070: EQUAL
13071: IFFALSE 13087
// Say ( un , VD-find-ar ) else
13073: LD_VAR 0 1
13077: PPUSH
13078: LD_STRING VD-find-ar
13080: PPUSH
13081: CALL_OW 88
13085: GO 13099
// Say ( un , VD-find-ar-f ) ;
13087: LD_VAR 0 1
13091: PPUSH
13092: LD_STRING VD-find-ar-f
13094: PPUSH
13095: CALL_OW 88
// if GetSide ( un ) = 1 then
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 255
13108: PUSH
13109: LD_INT 1
13111: EQUAL
13112: IFFALSE 13179
// begin if GetSex ( un ) = sex_male then
13114: LD_VAR 0 1
13118: PPUSH
13119: CALL_OW 258
13123: PUSH
13124: LD_INT 1
13126: EQUAL
13127: IFFALSE 13155
// begin Say ( un , VD-find-us ) ;
13129: LD_VAR 0 1
13133: PPUSH
13134: LD_STRING VD-find-us
13136: PPUSH
13137: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_STRING VD-find-us2
13148: PPUSH
13149: CALL_OW 88
// end else
13153: GO 13179
// begin Say ( un , VD-find-us-f ) ;
13155: LD_VAR 0 1
13159: PPUSH
13160: LD_STRING VD-find-us-f
13162: PPUSH
13163: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13167: LD_VAR 0 1
13171: PPUSH
13172: LD_STRING VD-find-us2-f
13174: PPUSH
13175: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13179: LD_INT 10
13181: PPUSH
13182: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13186: LD_INT 112
13188: PPUSH
13189: LD_INT 67
13191: PPUSH
13192: CALL_OW 86
// end ;
13196: PPOPN 2
13198: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13199: LD_EXP 7
13203: IFFALSE 13705
13205: GO 13207
13207: DISABLE
13208: LD_INT 0
13210: PPUSH
// begin if your_side = 1 then
13211: LD_OWVAR 2
13215: PUSH
13216: LD_INT 1
13218: EQUAL
13219: IFFALSE 13400
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13221: LD_ADDR_VAR 0 1
13225: PUSH
13226: LD_INT 22
13228: PUSH
13229: LD_INT 1
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: PUSH
13236: LD_INT 25
13238: PUSH
13239: LD_INT 4
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PPUSH
13250: CALL_OW 69
13254: PUSH
13255: LD_EXP 19
13259: DIFF
13260: ST_TO_ADDR
// if not speaker then
13261: LD_VAR 0 1
13265: NOT
13266: IFFALSE 13270
// exit ;
13268: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13270: LD_VAR 0 1
13274: PUSH
13275: LD_INT 1
13277: ARRAY
13278: PPUSH
13279: CALL_OW 258
13283: PUSH
13284: LD_INT 1
13286: EQUAL
13287: IFFALSE 13307
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13289: LD_VAR 0 1
13293: PUSH
13294: LD_INT 1
13296: ARRAY
13297: PPUSH
13298: LD_STRING VD-us-sci-art-1
13300: PPUSH
13301: CALL_OW 88
13305: GO 13323
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13307: LD_VAR 0 1
13311: PUSH
13312: LD_INT 1
13314: ARRAY
13315: PPUSH
13316: LD_STRING VD-us-fsci-art-1
13318: PPUSH
13319: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13323: LD_EXP 19
13327: PPUSH
13328: LD_STRING VDc-art1
13330: PPUSH
13331: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13335: LD_VAR 0 1
13339: PUSH
13340: LD_INT 1
13342: ARRAY
13343: PPUSH
13344: CALL_OW 258
13348: PUSH
13349: LD_INT 1
13351: EQUAL
13352: IFFALSE 13372
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13354: LD_VAR 0 1
13358: PUSH
13359: LD_INT 1
13361: ARRAY
13362: PPUSH
13363: LD_STRING VD-us-sci-art-2
13365: PPUSH
13366: CALL_OW 88
13370: GO 13388
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13372: LD_VAR 0 1
13376: PUSH
13377: LD_INT 1
13379: ARRAY
13380: PPUSH
13381: LD_STRING VD-us-fsci-art-2
13383: PPUSH
13384: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13388: LD_EXP 19
13392: PPUSH
13393: LD_STRING VDc-art2
13395: PPUSH
13396: CALL_OW 88
// end ; if your_side = 2 then
13400: LD_OWVAR 2
13404: PUSH
13405: LD_INT 2
13407: EQUAL
13408: IFFALSE 13512
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13410: LD_ADDR_VAR 0 1
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_INT 2
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: LD_INT 25
13427: PUSH
13428: LD_INT 4
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: LD_EXP 51
13448: DIFF
13449: ST_TO_ADDR
// if not speaker then
13450: LD_VAR 0 1
13454: NOT
13455: IFFALSE 13459
// exit ;
13457: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13459: LD_VAR 0 1
13463: PUSH
13464: LD_INT 1
13466: ARRAY
13467: PPUSH
13468: CALL_OW 258
13472: PUSH
13473: LD_INT 1
13475: EQUAL
13476: IFFALSE 13496
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13478: LD_VAR 0 1
13482: PUSH
13483: LD_INT 1
13485: ARRAY
13486: PPUSH
13487: LD_STRING VD-ar-sci-art-1
13489: PPUSH
13490: CALL_OW 88
13494: GO 13512
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13496: LD_VAR 0 1
13500: PUSH
13501: LD_INT 1
13503: ARRAY
13504: PPUSH
13505: LD_STRING VD-ar-fsci-art-1
13507: PPUSH
13508: CALL_OW 88
// end ; if your_side = 7 then
13512: LD_OWVAR 2
13516: PUSH
13517: LD_INT 7
13519: EQUAL
13520: IFFALSE 13705
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13522: LD_ADDR_VAR 0 1
13526: PUSH
13527: LD_INT 22
13529: PUSH
13530: LD_INT 7
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PUSH
13537: LD_INT 25
13539: PUSH
13540: LD_INT 4
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PPUSH
13551: CALL_OW 69
13555: PUSH
13556: LD_EXP 37
13560: DIFF
13561: ST_TO_ADDR
// if speaker then
13562: LD_VAR 0 1
13566: IFFALSE 13698
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13568: LD_VAR 0 1
13572: PUSH
13573: LD_INT 1
13575: ARRAY
13576: PPUSH
13577: CALL_OW 258
13581: PUSH
13582: LD_INT 1
13584: EQUAL
13585: IFFALSE 13605
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13587: LD_VAR 0 1
13591: PUSH
13592: LD_INT 1
13594: ARRAY
13595: PPUSH
13596: LD_STRING VD-al-sci-art-1
13598: PPUSH
13599: CALL_OW 88
13603: GO 13621
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13605: LD_VAR 0 1
13609: PUSH
13610: LD_INT 1
13612: ARRAY
13613: PPUSH
13614: LD_STRING VD-al-fsci-art-1
13616: PPUSH
13617: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13621: LD_EXP 37
13625: PPUSH
13626: LD_STRING VPd-art-1
13628: PPUSH
13629: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13633: LD_VAR 0 1
13637: PUSH
13638: LD_INT 1
13640: ARRAY
13641: PPUSH
13642: CALL_OW 258
13646: PUSH
13647: LD_INT 1
13649: EQUAL
13650: IFFALSE 13670
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13652: LD_VAR 0 1
13656: PUSH
13657: LD_INT 1
13659: ARRAY
13660: PPUSH
13661: LD_STRING VD-al-sci-art-2
13663: PPUSH
13664: CALL_OW 88
13668: GO 13686
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13670: LD_VAR 0 1
13674: PUSH
13675: LD_INT 1
13677: ARRAY
13678: PPUSH
13679: LD_STRING VD-al-fsci-art-2
13681: PPUSH
13682: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13686: LD_EXP 37
13690: PPUSH
13691: LD_STRING VPd-art-2
13693: PPUSH
13694: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13698: LD_STRING CVulc7out
13700: PPUSH
13701: CALL_OW 337
// end ; end ;
13705: PPOPN 1
13707: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13708: LD_INT 8
13710: PPUSH
13711: LD_INT 22
13713: PUSH
13714: LD_OWVAR 2
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PPUSH
13723: CALL_OW 69
13727: PPUSH
13728: LD_INT 8
13730: PPUSH
13731: CALL 2145 0 2
13735: PPUSH
13736: CALL_OW 292
13740: IFFALSE 13883
13742: GO 13744
13744: DISABLE
13745: LD_INT 0
13747: PPUSH
// begin if your_side = 1 then
13748: LD_OWVAR 2
13752: PUSH
13753: LD_INT 1
13755: EQUAL
13756: IFFALSE 13839
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_INT 22
13765: PUSH
13766: LD_INT 1
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PPUSH
13773: CALL_OW 69
13777: PUSH
13778: LD_EXP 19
13782: DIFF
13783: ST_TO_ADDR
// if speaker then
13784: LD_VAR 0 1
13788: IFFALSE 13839
// if GetSex ( speaker [ 1 ] ) then
13790: LD_VAR 0 1
13794: PUSH
13795: LD_INT 1
13797: ARRAY
13798: PPUSH
13799: CALL_OW 258
13803: IFFALSE 13823
// Say ( speaker [ 1 ] , VD-legion-us ) else
13805: LD_VAR 0 1
13809: PUSH
13810: LD_INT 1
13812: ARRAY
13813: PPUSH
13814: LD_STRING VD-legion-us
13816: PPUSH
13817: CALL_OW 88
13821: GO 13839
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13823: LD_VAR 0 1
13827: PUSH
13828: LD_INT 1
13830: ARRAY
13831: PPUSH
13832: LD_STRING VD-legion-us-f
13834: PPUSH
13835: CALL_OW 88
// end ; if your_side = 2 then
13839: LD_OWVAR 2
13843: PUSH
13844: LD_INT 2
13846: EQUAL
13847: IFFALSE 13861
// Say ( ar_commander , VD-legion-ar ) ;
13849: LD_EXP 51
13853: PPUSH
13854: LD_STRING VD-legion-ar
13856: PPUSH
13857: CALL_OW 88
// if your_side = 7 then
13861: LD_OWVAR 2
13865: PUSH
13866: LD_INT 7
13868: EQUAL
13869: IFFALSE 13883
// Say ( al_commander , VD-legion-al ) ;
13871: LD_EXP 37
13875: PPUSH
13876: LD_STRING VD-legion-al
13878: PPUSH
13879: CALL_OW 88
// end ;
13883: PPOPN 1
13885: END
// every 0 0$01 trigger mine_vulc do
13886: LD_EXP 12
13890: IFFALSE 13907
13892: GO 13894
13894: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13895: LD_EXP 10
13899: PPUSH
13900: LD_STRING VD-vulc-mines
13902: PPUSH
13903: CALL_OW 88
// end ;
13907: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13908: LD_OWVAR 67
13912: PUSH
13913: LD_INT 1
13915: GREATER
13916: IFFALSE 14035
13918: GO 13920
13920: DISABLE
13921: LD_INT 0
13923: PPUSH
13924: PPUSH
13925: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13926: LD_ADDR_VAR 0 1
13930: PUSH
13931: LD_INT 123
13933: PUSH
13934: LD_INT 95
13936: PUSH
13937: LD_INT 119
13939: PUSH
13940: LD_INT 89
13942: PUSH
13943: LD_INT 115
13945: PUSH
13946: LD_INT 81
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: ST_TO_ADDR
// p := 1 ;
13957: LD_ADDR_VAR 0 2
13961: PUSH
13962: LD_INT 1
13964: ST_TO_ADDR
// for i = 1 to 3 do
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: DOUBLE
13971: LD_INT 1
13973: DEC
13974: ST_TO_ADDR
13975: LD_INT 3
13977: PUSH
13978: FOR_TO
13979: IFFALSE 14033
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13981: LD_VAR 0 1
13985: PUSH
13986: LD_VAR 0 2
13990: ARRAY
13991: PPUSH
13992: LD_VAR 0 1
13996: PUSH
13997: LD_VAR 0 2
14001: PUSH
14002: LD_INT 1
14004: PLUS
14005: ARRAY
14006: PPUSH
14007: LD_INT 8
14009: PPUSH
14010: LD_INT 0
14012: PPUSH
14013: CALL_OW 454
// p := p + 2 ;
14017: LD_ADDR_VAR 0 2
14021: PUSH
14022: LD_VAR 0 2
14026: PUSH
14027: LD_INT 2
14029: PLUS
14030: ST_TO_ADDR
// end ;
14031: GO 13978
14033: POP
14034: POP
// end ;
14035: PPOPN 3
14037: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14038: LD_OWVAR 67
14042: PUSH
14043: LD_INT 1
14045: GREATER
14046: PUSH
14047: LD_INT 22
14049: PPUSH
14050: LD_INT 22
14052: PUSH
14053: LD_OWVAR 2
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PPUSH
14062: CALL_OW 70
14066: AND
14067: IFFALSE 14271
14069: GO 14071
14071: DISABLE
14072: LD_INT 0
14074: PPUSH
14075: PPUSH
14076: PPUSH
// begin enable ;
14077: ENABLE
// p := 1 ;
14078: LD_ADDR_VAR 0 1
14082: PUSH
14083: LD_INT 1
14085: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14086: LD_ADDR_VAR 0 3
14090: PUSH
14091: LD_INT 123
14093: PUSH
14094: LD_INT 95
14096: PUSH
14097: LD_INT 119
14099: PUSH
14100: LD_INT 89
14102: PUSH
14103: LD_INT 115
14105: PUSH
14106: LD_INT 81
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: ST_TO_ADDR
// for i = 1 to 3 do
14117: LD_ADDR_VAR 0 2
14121: PUSH
14122: DOUBLE
14123: LD_INT 1
14125: DEC
14126: ST_TO_ADDR
14127: LD_INT 3
14129: PUSH
14130: FOR_TO
14131: IFFALSE 14269
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14133: LD_VAR 0 3
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: PPUSH
14144: LD_VAR 0 3
14148: PUSH
14149: LD_VAR 0 1
14153: PUSH
14154: LD_INT 1
14156: PLUS
14157: ARRAY
14158: PPUSH
14159: CALL_OW 428
14163: PUSH
14164: LD_INT 0
14166: GREATER
14167: IFFALSE 14253
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14169: LD_VAR 0 3
14173: PUSH
14174: LD_VAR 0 1
14178: ARRAY
14179: PPUSH
14180: LD_VAR 0 3
14184: PUSH
14185: LD_VAR 0 1
14189: PUSH
14190: LD_INT 1
14192: PLUS
14193: ARRAY
14194: PPUSH
14195: CALL_OW 428
14199: PPUSH
14200: CALL_OW 255
14204: PUSH
14205: LD_OWVAR 2
14209: EQUAL
14210: IFFALSE 14253
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14212: LD_VAR 0 3
14216: PUSH
14217: LD_VAR 0 1
14221: ARRAY
14222: PPUSH
14223: LD_VAR 0 3
14227: PUSH
14228: LD_VAR 0 1
14232: PUSH
14233: LD_INT 1
14235: PLUS
14236: ARRAY
14237: PPUSH
14238: LD_INT 8
14240: PPUSH
14241: CALL_OW 456
// mine_vulc := true ;
14245: LD_ADDR_EXP 12
14249: PUSH
14250: LD_INT 1
14252: ST_TO_ADDR
// end ; p := p + 2 ;
14253: LD_ADDR_VAR 0 1
14257: PUSH
14258: LD_VAR 0 1
14262: PUSH
14263: LD_INT 2
14265: PLUS
14266: ST_TO_ADDR
// end ;
14267: GO 14130
14269: POP
14270: POP
// end ;
14271: PPOPN 3
14273: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14274: LD_INT 22
14276: PUSH
14277: LD_INT 3
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 69
14288: PUSH
14289: LD_INT 0
14291: EQUAL
14292: PUSH
14293: LD_OWVAR 2
14297: PUSH
14298: LD_INT 2
14300: NONEQUAL
14301: AND
14302: IFFALSE 14311
14304: GO 14306
14306: DISABLE
// Win ;
14307: CALL 14368 0 0
14311: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14312: LD_INT 2
14314: PUSH
14315: LD_INT 22
14317: PUSH
14318: LD_INT 8
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 22
14327: PUSH
14328: LD_INT 3
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 69
14344: PUSH
14345: LD_INT 0
14347: EQUAL
14348: PUSH
14349: LD_OWVAR 2
14353: PUSH
14354: LD_INT 2
14356: EQUAL
14357: AND
14358: IFFALSE 14367
14360: GO 14362
14362: DISABLE
// Win ;
14363: CALL 14368 0 0
14367: END
// function Win ; var points ; begin
14368: LD_INT 0
14370: PPUSH
14371: PPUSH
// case Query ( VulcWin ) of 1 :
14372: LD_STRING VulcWin
14374: PPUSH
14375: CALL_OW 97
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14391
14388: POP
// ; end ;
14389: GO 14392
14391: POP
// if medal_enabled then
14392: LD_EXP 13
14396: IFFALSE 14410
// AddMedal ( vulc_1 , 1 ) else
14398: LD_STRING vulc_1
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 101
14408: GO 14421
// AddMedal ( vulc_1 , - 1 ) ;
14410: LD_STRING vulc_1
14412: PPUSH
14413: LD_INT 1
14415: NEG
14416: PPUSH
14417: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14421: LD_INT 22
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PPUSH
14431: CALL_OW 69
14435: PUSH
14436: LD_INT 0
14438: EQUAL
14439: IFFALSE 14453
// AddMedal ( vulc_2 , 1 ) else
14441: LD_STRING vulc_2
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: CALL_OW 101
14451: GO 14464
// AddMedal ( vulc_2 , - 1 ) ;
14453: LD_STRING vulc_2
14455: PPUSH
14456: LD_INT 1
14458: NEG
14459: PPUSH
14460: CALL_OW 101
// points := CalculateCommanderPoints ;
14464: LD_ADDR_VAR 0 2
14468: PUSH
14469: CALL 2266 0 0
14473: ST_TO_ADDR
// if points >= 2000 then
14474: LD_VAR 0 2
14478: PUSH
14479: LD_INT 2000
14481: GREATEREQUAL
14482: IFFALSE 14496
// AddMedal ( vulc_3 , 2 ) else
14484: LD_STRING vulc_3
14486: PPUSH
14487: LD_INT 2
14489: PPUSH
14490: CALL_OW 101
14494: GO 14529
// if points >= 0 then
14496: LD_VAR 0 2
14500: PUSH
14501: LD_INT 0
14503: GREATEREQUAL
14504: IFFALSE 14518
// AddMedal ( vulc_3 , 1 ) else
14506: LD_STRING vulc_3
14508: PPUSH
14509: LD_INT 1
14511: PPUSH
14512: CALL_OW 101
14516: GO 14529
// AddMedal ( vulc_3 , - 1 ) ;
14518: LD_STRING vulc_3
14520: PPUSH
14521: LD_INT 1
14523: NEG
14524: PPUSH
14525: CALL_OW 101
// GiveMedals ( MAIN ) ;
14529: LD_STRING MAIN
14531: PPUSH
14532: CALL_OW 102
// YouWin ;
14536: CALL_OW 103
// end ; end_of_file
14540: LD_VAR 0 1
14544: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14545: LD_INT 13
14547: PPUSH
14548: LD_INT 21
14550: PUSH
14551: LD_INT 1
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 70
14562: PUSH
14563: LD_INT 0
14565: GREATER
14566: IFFALSE 14633
14568: GO 14570
14570: DISABLE
14571: LD_INT 0
14573: PPUSH
14574: PPUSH
// begin enable ;
14575: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14576: LD_ADDR_VAR 0 1
14580: PUSH
14581: LD_INT 13
14583: PPUSH
14584: LD_INT 21
14586: PUSH
14587: LD_INT 1
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PPUSH
14594: CALL_OW 70
14598: PUSH
14599: FOR_IN
14600: IFFALSE 14631
// if GetLives ( i ) > 4 then
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 256
14611: PUSH
14612: LD_INT 4
14614: GREATER
14615: IFFALSE 14629
// SetLives ( i , 4 ) ;
14617: LD_VAR 0 1
14621: PPUSH
14622: LD_INT 4
14624: PPUSH
14625: CALL_OW 234
14629: GO 14599
14631: POP
14632: POP
// end ;
14633: PPOPN 2
14635: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14636: LD_VAR 0 1
14640: PPUSH
14641: CALL_OW 255
14645: PUSH
14646: LD_OWVAR 2
14650: EQUAL
14651: IFFALSE 14661
// player_res_art := true ;
14653: LD_ADDR_EXP 6
14657: PUSH
14658: LD_INT 1
14660: ST_TO_ADDR
// end ;
14661: PPOPN 1
14663: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14664: LD_INT 22
14666: PUSH
14667: LD_OWVAR 2
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 2
14678: PUSH
14679: LD_INT 30
14681: PUSH
14682: LD_INT 8
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PUSH
14689: LD_INT 30
14691: PUSH
14692: LD_INT 11
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: LIST
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: PUSH
14713: LD_EXP 6
14717: AND
14718: IFFALSE 15062
14720: GO 14722
14722: DISABLE
14723: LD_INT 0
14725: PPUSH
14726: PPUSH
14727: PPUSH
// begin enable ;
14728: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14729: LD_ADDR_VAR 0 1
14733: PUSH
14734: LD_INT 1
14736: PPUSH
14737: CALL_OW 469
14741: PUSH
14742: LD_INT 1
14744: ARRAY
14745: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14746: LD_ADDR_VAR 0 2
14750: PUSH
14751: LD_INT 1
14753: PPUSH
14754: CALL_OW 469
14758: PUSH
14759: LD_INT 2
14761: ARRAY
14762: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14763: LD_ADDR_VAR 0 3
14767: PUSH
14768: LD_INT 22
14770: PUSH
14771: LD_OWVAR 2
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: LD_INT 2
14782: PUSH
14783: LD_INT 30
14785: PUSH
14786: LD_INT 8
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 30
14795: PUSH
14796: LD_INT 11
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: LIST
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PPUSH
14812: CALL_OW 69
14816: PPUSH
14817: LD_VAR 0 1
14821: PPUSH
14822: LD_VAR 0 2
14826: PPUSH
14827: CALL_OW 73
14831: ST_TO_ADDR
// if player_artifact_ready = false then
14832: LD_EXP 7
14836: PUSH
14837: LD_INT 0
14839: EQUAL
14840: IFFALSE 14946
// if GetDistUnitXY ( lab , x , y ) < 6 then
14842: LD_VAR 0 3
14846: PPUSH
14847: LD_VAR 0 1
14851: PPUSH
14852: LD_VAR 0 2
14856: PPUSH
14857: CALL_OW 297
14861: PUSH
14862: LD_INT 6
14864: LESS
14865: IFFALSE 14926
// begin if BuildingStatus ( lab ) = bs_idle then
14867: LD_VAR 0 3
14871: PPUSH
14872: CALL_OW 461
14876: PUSH
14877: LD_INT 2
14879: EQUAL
14880: IFFALSE 14904
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14882: LD_OWVAR 2
14886: PPUSH
14887: LD_INT 1
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: LD_VAR 0 3
14897: PPUSH
14898: CALL_OW 468
14902: GO 14924
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14904: LD_OWVAR 2
14908: PPUSH
14909: LD_INT 1
14911: PPUSH
14912: LD_INT 1
14914: PPUSH
14915: LD_VAR 0 3
14919: PPUSH
14920: CALL_OW 468
// end else
14924: GO 14946
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14926: LD_OWVAR 2
14930: PPUSH
14931: LD_INT 1
14933: PPUSH
14934: LD_INT 1
14936: PPUSH
14937: LD_VAR 0 3
14941: PPUSH
14942: CALL_OW 468
// if player_artifact_ready then
14946: LD_EXP 7
14950: IFFALSE 15062
// if GetDistUnitXY ( lab , x , y ) < 6 then
14952: LD_VAR 0 3
14956: PPUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_VAR 0 2
14966: PPUSH
14967: CALL_OW 297
14971: PUSH
14972: LD_INT 6
14974: LESS
14975: IFFALSE 15040
// begin if BuildingStatus ( lab ) = bs_idle then
14977: LD_VAR 0 3
14981: PPUSH
14982: CALL_OW 461
14986: PUSH
14987: LD_INT 2
14989: EQUAL
14990: IFFALSE 15016
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14992: LD_OWVAR 2
14996: PPUSH
14997: LD_EXP 8
15001: PPUSH
15002: LD_INT 4
15004: PPUSH
15005: LD_VAR 0 3
15009: PPUSH
15010: CALL_OW 468
15014: GO 15038
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15016: LD_OWVAR 2
15020: PPUSH
15021: LD_EXP 8
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: LD_VAR 0 3
15033: PPUSH
15034: CALL_OW 468
// end else
15038: GO 15062
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15040: LD_OWVAR 2
15044: PPUSH
15045: LD_EXP 8
15049: PPUSH
15050: LD_INT 1
15052: PPUSH
15053: LD_VAR 0 3
15057: PPUSH
15058: CALL_OW 468
// end ;
15062: PPOPN 3
15064: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15065: LD_INT 0
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15072: LD_ADDR_VAR 0 5
15076: PUSH
15077: LD_INT 1
15079: PPUSH
15080: CALL_OW 469
15084: PUSH
15085: LD_INT 1
15087: ARRAY
15088: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15089: LD_ADDR_VAR 0 6
15093: PUSH
15094: LD_INT 1
15096: PPUSH
15097: CALL_OW 469
15101: PUSH
15102: LD_INT 2
15104: ARRAY
15105: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15106: LD_ADDR_VAR 0 8
15110: PUSH
15111: LD_INT 22
15113: PUSH
15114: LD_OWVAR 2
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PUSH
15123: LD_INT 2
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: LD_INT 8
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: PUSH
15136: LD_INT 30
15138: PUSH
15139: LD_INT 11
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: LIST
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PPUSH
15155: CALL_OW 69
15159: PPUSH
15160: LD_VAR 0 5
15164: PPUSH
15165: LD_VAR 0 6
15169: PPUSH
15170: CALL_OW 73
15174: ST_TO_ADDR
// if icon = art_exp_left then
15175: LD_VAR 0 2
15179: PUSH
15180: LD_INT 1
15182: EQUAL
15183: IFFALSE 15222
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15185: LD_VAR 0 8
15189: PPUSH
15190: LD_EXP 9
15194: PPUSH
15195: LD_INT 1
15197: PPUSH
15198: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15202: LD_OWVAR 2
15206: PPUSH
15207: LD_INT 1
15209: PPUSH
15210: LD_INT 0
15212: PPUSH
15213: LD_VAR 0 8
15217: PPUSH
15218: CALL_OW 468
// end ; if icon = art_icon then
15222: LD_VAR 0 2
15226: PUSH
15227: LD_EXP 8
15231: EQUAL
15232: IFFALSE 15446
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15234: LD_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 3
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: PPUSH
15249: CALL_OW 69
15253: IN
15254: IFFALSE 15446
// begin side := GetSide ( cr1 ) ;
15256: LD_ADDR_VAR 0 9
15260: PUSH
15261: LD_VAR 0 3
15265: PPUSH
15266: CALL_OW 255
15270: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15271: LD_INT 22
15273: PUSH
15274: LD_VAR 0 9
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: PUSH
15283: LD_INT 30
15285: PUSH
15286: LD_INT 28
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: CALL_OW 69
15301: PUSH
15302: LD_INT 0
15304: GREATER
15305: IFFALSE 15446
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_INT 22
15314: PUSH
15315: LD_VAR 0 9
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 2
15326: PUSH
15327: LD_INT 30
15329: PUSH
15330: LD_INT 26
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 30
15339: PUSH
15340: LD_INT 27
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 30
15349: PUSH
15350: LD_INT 28
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PPUSH
15367: CALL_OW 69
15371: PUSH
15372: FOR_IN
15373: IFFALSE 15389
// SetLives ( i , 1 ) ;
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 234
15387: GO 15372
15389: POP
15390: POP
// player_res_art := false ;
15391: LD_ADDR_EXP 6
15395: PUSH
15396: LD_INT 0
15398: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15399: LD_OWVAR 2
15403: PPUSH
15404: LD_EXP 8
15408: PPUSH
15409: LD_INT 1
15411: PPUSH
15412: LD_VAR 0 8
15416: PPUSH
15417: CALL_OW 468
// Wait ( time_to_reuse ) ;
15421: LD_EXP 11
15425: PPUSH
15426: CALL_OW 67
// player_res_art := true ;
15430: LD_ADDR_EXP 6
15434: PUSH
15435: LD_INT 1
15437: ST_TO_ADDR
// medal_enabled := true ;
15438: LD_ADDR_EXP 13
15442: PUSH
15443: LD_INT 1
15445: ST_TO_ADDR
// end ; end ; end ; end ;
15446: PPOPN 9
15448: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15449: LD_VAR 0 1
15453: PPUSH
15454: CALL_OW 255
15458: PUSH
15459: LD_OWVAR 2
15463: EQUAL
15464: IFFALSE 15501
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15466: LD_OWVAR 2
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: LD_VAR 0 1
15481: PPUSH
15482: CALL_OW 468
// player_artifact_ready := true ;
15486: LD_ADDR_EXP 7
15490: PUSH
15491: LD_INT 1
15493: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15494: LD_STRING ArtVulcano
15496: PPUSH
15497: CALL_OW 339
// end ; end ;
15501: PPOPN 1
15503: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15504: LD_OWVAR 2
15508: PPUSH
15509: LD_INT 1
15511: PPUSH
15512: LD_INT 2
15514: PPUSH
15515: LD_VAR 0 1
15519: PPUSH
15520: CALL_OW 468
// end ; end_of_file
15524: PPOPN 2
15526: END
// every 0 0$01 do
15527: GO 15529
15529: DISABLE
// begin enable ;
15530: ENABLE
// Display_Strings := [ #tick , tick ] ;
15531: LD_ADDR_OWVAR 47
15535: PUSH
15536: LD_STRING #tick
15538: PUSH
15539: LD_OWVAR 1
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: ST_TO_ADDR
// end ; end_of_file
15548: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15549: LD_INT 0
15551: PPUSH
15552: PPUSH
15553: PPUSH
15554: PPUSH
15555: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15556: LD_ADDR_EXP 39
15560: PUSH
15561: LD_INT 7
15563: PUSH
15564: LD_INT 6
15566: PUSH
15567: LD_INT 5
15569: PUSH
15570: EMPTY
15571: LIST
15572: LIST
15573: LIST
15574: PUSH
15575: LD_OWVAR 67
15579: ARRAY
15580: ST_TO_ADDR
// al_force := [ ] ;
15581: LD_ADDR_EXP 38
15585: PUSH
15586: EMPTY
15587: ST_TO_ADDR
// RemoveAlliance ;
15588: CALL 15966 0 0
// ResetFog ;
15592: CALL_OW 335
// your_side := 7 ;
15596: LD_ADDR_OWVAR 2
15600: PUSH
15601: LD_INT 7
15603: ST_TO_ADDR
// uc_side := 7 ;
15604: LD_ADDR_OWVAR 20
15608: PUSH
15609: LD_INT 7
15611: ST_TO_ADDR
// hc_gallery :=  ;
15612: LD_ADDR_OWVAR 33
15616: PUSH
15617: LD_STRING 
15619: ST_TO_ADDR
// hc_name :=  ;
15620: LD_ADDR_OWVAR 26
15624: PUSH
15625: LD_STRING 
15627: ST_TO_ADDR
// hc_importance := 0 ;
15628: LD_ADDR_OWVAR 32
15632: PUSH
15633: LD_INT 0
15635: ST_TO_ADDR
// for i = 1 to 17 do
15636: LD_ADDR_VAR 0 2
15640: PUSH
15641: DOUBLE
15642: LD_INT 1
15644: DEC
15645: ST_TO_ADDR
15646: LD_INT 17
15648: PUSH
15649: FOR_TO
15650: IFFALSE 15730
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15652: LD_ADDR_OWVAR 21
15656: PUSH
15657: LD_INT 1
15659: PUSH
15660: LD_INT 3
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: PUSH
15667: LD_INT 1
15669: PPUSH
15670: LD_INT 2
15672: PPUSH
15673: CALL_OW 12
15677: ARRAY
15678: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15679: LD_INT 0
15681: PPUSH
15682: LD_INT 1
15684: PPUSH
15685: LD_INT 4
15687: PPUSH
15688: CALL_OW 12
15692: PPUSH
15693: LD_EXP 39
15697: PPUSH
15698: CALL_OW 380
// un := CreateHuman ;
15702: LD_ADDR_VAR 0 4
15706: PUSH
15707: CALL_OW 44
15711: ST_TO_ADDR
// al_force := al_force ^ un ;
15712: LD_ADDR_EXP 38
15716: PUSH
15717: LD_EXP 38
15721: PUSH
15722: LD_VAR 0 4
15726: ADD
15727: ST_TO_ADDR
// end ;
15728: GO 15649
15730: POP
15731: POP
// hc_importance := 100 ;
15732: LD_ADDR_OWVAR 32
15736: PUSH
15737: LD_INT 100
15739: ST_TO_ADDR
// uc_nation := 1 ;
15740: LD_ADDR_OWVAR 21
15744: PUSH
15745: LD_INT 1
15747: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 1
15753: PPUSH
15754: LD_EXP 39
15758: PPUSH
15759: CALL_OW 380
// al_commander := CreateHuman ;
15763: LD_ADDR_EXP 37
15767: PUSH
15768: CALL_OW 44
15772: ST_TO_ADDR
// player_commander := al_commander ;
15773: LD_ADDR_EXP 10
15777: PUSH
15778: LD_EXP 37
15782: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15783: LD_ADDR_VAR 0 5
15787: PUSH
15788: LD_STRING text
15790: PPUSH
15791: LD_INT 9
15793: PUSH
15794: LD_INT 9
15796: PUSH
15797: LD_INT 8
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: LIST
15804: PUSH
15805: LD_OWVAR 67
15809: ARRAY
15810: PPUSH
15811: LD_INT 9
15813: PUSH
15814: LD_INT 9
15816: PUSH
15817: LD_INT 8
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: LIST
15824: PUSH
15825: LD_OWVAR 67
15829: ARRAY
15830: PPUSH
15831: LD_INT -5
15833: PUSH
15834: LD_EXP 37
15838: PUSH
15839: LD_INT -3
15841: PUSH
15842: LD_INT -2
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: LIST
15849: LIST
15850: PUSH
15851: LD_EXP 38
15855: ADD
15856: PPUSH
15857: LD_INT 1
15859: PUSH
15860: LD_INT 3
15862: PUSH
15863: LD_INT 2
15865: PUSH
15866: LD_INT 1
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: PUSH
15873: LD_INT 4
15875: PUSH
15876: LD_INT 1
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: LD_INT 9
15885: PUSH
15886: LD_INT 5
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 42
15901: ST_TO_ADDR
// team := team ^ al_commander ;
15902: LD_ADDR_VAR 0 5
15906: PUSH
15907: LD_VAR 0 5
15911: PUSH
15912: LD_EXP 37
15916: ADD
15917: ST_TO_ADDR
// for i = 1 to team do
15918: LD_ADDR_VAR 0 2
15922: PUSH
15923: DOUBLE
15924: LD_INT 1
15926: DEC
15927: ST_TO_ADDR
15928: LD_VAR 0 5
15932: PUSH
15933: FOR_TO
15934: IFFALSE 15959
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15936: LD_VAR 0 5
15940: PUSH
15941: LD_VAR 0 2
15945: ARRAY
15946: PPUSH
15947: LD_INT 15
15949: PPUSH
15950: LD_INT 0
15952: PPUSH
15953: CALL_OW 49
15957: GO 15933
15959: POP
15960: POP
// end ;
15961: LD_VAR 0 1
15965: RET
// export function RemoveAlliance ; var i ; begin
15966: LD_INT 0
15968: PPUSH
15969: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15970: LD_INT 22
15972: PUSH
15973: LD_INT 7
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PUSH
15980: LD_INT 30
15982: PUSH
15983: LD_INT 1
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 69
15998: PUSH
15999: LD_INT 1
16001: ARRAY
16002: PPUSH
16003: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_INT 22
16014: PUSH
16015: LD_INT 7
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PPUSH
16022: CALL_OW 69
16026: PUSH
16027: FOR_IN
16028: IFFALSE 16041
// RemoveUnit ( i ) ;
16030: LD_VAR 0 2
16034: PPUSH
16035: CALL_OW 64
16039: GO 16027
16041: POP
16042: POP
// end ;
16043: LD_VAR 0 1
16047: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16048: LD_INT 0
16050: PPUSH
16051: PPUSH
16052: PPUSH
16053: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16054: LD_INT 31
16056: PPUSH
16057: LD_INT 7
16059: PPUSH
16060: LD_INT 2
16062: PPUSH
16063: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16067: LD_INT 32
16069: PPUSH
16070: LD_INT 7
16072: PPUSH
16073: LD_INT 2
16075: PPUSH
16076: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16080: LD_INT 59
16082: PPUSH
16083: LD_INT 7
16085: PPUSH
16086: LD_INT 2
16088: PPUSH
16089: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16093: LD_ADDR_EXP 39
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 6
16103: PUSH
16104: LD_INT 7
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: LD_OWVAR 67
16116: ARRAY
16117: ST_TO_ADDR
// al_force := [ ] ;
16118: LD_ADDR_EXP 38
16122: PUSH
16123: EMPTY
16124: ST_TO_ADDR
// al_vehs := [ ] ;
16125: LD_ADDR_EXP 44
16129: PUSH
16130: EMPTY
16131: ST_TO_ADDR
// uc_side := 7 ;
16132: LD_ADDR_OWVAR 20
16136: PUSH
16137: LD_INT 7
16139: ST_TO_ADDR
// uc_nation := 1 ;
16140: LD_ADDR_OWVAR 21
16144: PUSH
16145: LD_INT 1
16147: ST_TO_ADDR
// bc_type := b_oil_mine ;
16148: LD_ADDR_OWVAR 42
16152: PUSH
16153: LD_INT 29
16155: ST_TO_ADDR
// b := CreateBuilding ;
16156: LD_ADDR_VAR 0 4
16160: PUSH
16161: CALL_OW 46
16165: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16166: LD_VAR 0 4
16170: PPUSH
16171: LD_INT 61
16173: PPUSH
16174: LD_INT 7
16176: PPUSH
16177: LD_INT 0
16179: PPUSH
16180: LD_INT 0
16182: PPUSH
16183: CALL_OW 50
// bc_type := b_siberite_mine ;
16187: LD_ADDR_OWVAR 42
16191: PUSH
16192: LD_INT 30
16194: ST_TO_ADDR
// b := CreateBuilding ;
16195: LD_ADDR_VAR 0 4
16199: PUSH
16200: CALL_OW 46
16204: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16205: LD_VAR 0 4
16209: PPUSH
16210: LD_INT 69
16212: PPUSH
16213: LD_INT 13
16215: PPUSH
16216: LD_INT 0
16218: PPUSH
16219: LD_INT 0
16221: PPUSH
16222: CALL_OW 50
// hc_gallery :=  ;
16226: LD_ADDR_OWVAR 33
16230: PUSH
16231: LD_STRING 
16233: ST_TO_ADDR
// hc_name :=  ;
16234: LD_ADDR_OWVAR 26
16238: PUSH
16239: LD_STRING 
16241: ST_TO_ADDR
// hc_importance := 0 ;
16242: LD_ADDR_OWVAR 32
16246: PUSH
16247: LD_INT 0
16249: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16250: LD_ADDR_VAR 0 2
16254: PUSH
16255: LD_INT 22
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: LD_INT 30
16267: PUSH
16268: LD_INT 32
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: PUSH
16284: FOR_IN
16285: IFFALSE 16355
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16287: LD_ADDR_OWVAR 21
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: LD_INT 3
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 1
16304: PPUSH
16305: LD_INT 2
16307: PPUSH
16308: CALL_OW 12
16312: ARRAY
16313: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16314: LD_INT 0
16316: PPUSH
16317: LD_INT 1
16319: PPUSH
16320: LD_EXP 39
16324: PPUSH
16325: CALL_OW 380
// un := CreateHuman ;
16329: LD_ADDR_VAR 0 3
16333: PUSH
16334: CALL_OW 44
16338: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16339: LD_VAR 0 3
16343: PPUSH
16344: LD_VAR 0 2
16348: PPUSH
16349: CALL_OW 52
// end ;
16353: GO 16284
16355: POP
16356: POP
// for i = 1 to 3 do
16357: LD_ADDR_VAR 0 2
16361: PUSH
16362: DOUBLE
16363: LD_INT 1
16365: DEC
16366: ST_TO_ADDR
16367: LD_INT 3
16369: PUSH
16370: FOR_TO
16371: IFFALSE 16439
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16373: LD_ADDR_OWVAR 21
16377: PUSH
16378: LD_INT 1
16380: PUSH
16381: LD_INT 3
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_INT 2
16393: PPUSH
16394: CALL_OW 12
16398: ARRAY
16399: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16400: LD_INT 0
16402: PPUSH
16403: LD_INT 4
16405: PPUSH
16406: LD_EXP 39
16410: PPUSH
16411: CALL_OW 380
// un := CreateHuman ;
16415: LD_ADDR_VAR 0 3
16419: PUSH
16420: CALL_OW 44
16424: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: LD_INT 164
16432: PPUSH
16433: CALL_OW 52
// end ;
16437: GO 16370
16439: POP
16440: POP
// for i = 1 to 6 do
16441: LD_ADDR_VAR 0 2
16445: PUSH
16446: DOUBLE
16447: LD_INT 1
16449: DEC
16450: ST_TO_ADDR
16451: LD_INT 6
16453: PUSH
16454: FOR_TO
16455: IFFALSE 16546
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16457: LD_ADDR_OWVAR 21
16461: PUSH
16462: LD_INT 1
16464: PUSH
16465: LD_INT 3
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 1
16474: PPUSH
16475: LD_INT 2
16477: PPUSH
16478: CALL_OW 12
16482: ARRAY
16483: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16484: LD_INT 0
16486: PPUSH
16487: LD_INT 5
16489: PUSH
16490: LD_INT 9
16492: PUSH
16493: LD_INT 9
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 1
16503: PPUSH
16504: LD_INT 3
16506: PPUSH
16507: CALL_OW 12
16511: ARRAY
16512: PPUSH
16513: LD_EXP 39
16517: PPUSH
16518: CALL_OW 380
// un := CreateHuman ;
16522: LD_ADDR_VAR 0 3
16526: PUSH
16527: CALL_OW 44
16531: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16532: LD_VAR 0 3
16536: PPUSH
16537: LD_INT 173
16539: PPUSH
16540: CALL_OW 52
// end ;
16544: GO 16454
16546: POP
16547: POP
// for i = 1 to 6 do
16548: LD_ADDR_VAR 0 2
16552: PUSH
16553: DOUBLE
16554: LD_INT 1
16556: DEC
16557: ST_TO_ADDR
16558: LD_INT 6
16560: PUSH
16561: FOR_TO
16562: IFFALSE 16660
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16564: LD_ADDR_OWVAR 21
16568: PUSH
16569: LD_INT 1
16571: PUSH
16572: LD_INT 3
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 1
16581: PPUSH
16582: LD_INT 2
16584: PPUSH
16585: CALL_OW 12
16589: ARRAY
16590: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16591: LD_INT 0
16593: PPUSH
16594: LD_INT 3
16596: PPUSH
16597: LD_EXP 39
16601: PPUSH
16602: CALL_OW 380
// un := CreateHuman ;
16606: LD_ADDR_VAR 0 3
16610: PUSH
16611: CALL_OW 44
16615: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16616: LD_VAR 0 3
16620: PPUSH
16621: LD_INT 22
16623: PUSH
16624: LD_INT 7
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: LD_INT 30
16633: PUSH
16634: LD_INT 3
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL_OW 69
16649: PUSH
16650: LD_INT 1
16652: ARRAY
16653: PPUSH
16654: CALL_OW 52
// end ;
16658: GO 16561
16660: POP
16661: POP
// for i = 1 to 4 do
16662: LD_ADDR_VAR 0 2
16666: PUSH
16667: DOUBLE
16668: LD_INT 1
16670: DEC
16671: ST_TO_ADDR
16672: LD_INT 4
16674: PUSH
16675: FOR_TO
16676: IFFALSE 16744
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16678: LD_ADDR_OWVAR 21
16682: PUSH
16683: LD_INT 1
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 1
16695: PPUSH
16696: LD_INT 2
16698: PPUSH
16699: CALL_OW 12
16703: ARRAY
16704: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16705: LD_INT 0
16707: PPUSH
16708: LD_INT 2
16710: PPUSH
16711: LD_EXP 39
16715: PPUSH
16716: CALL_OW 380
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 3
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16730: LD_VAR 0 3
16734: PPUSH
16735: LD_INT 162
16737: PPUSH
16738: CALL_OW 52
// end ;
16742: GO 16675
16744: POP
16745: POP
// uc_nation := 3 ;
16746: LD_ADDR_OWVAR 21
16750: PUSH
16751: LD_INT 3
16753: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16754: LD_ADDR_OWVAR 37
16758: PUSH
16759: LD_INT 21
16761: ST_TO_ADDR
// vc_engine := engine_siberite ;
16762: LD_ADDR_OWVAR 39
16766: PUSH
16767: LD_INT 3
16769: ST_TO_ADDR
// vc_control := control_computer ;
16770: LD_ADDR_OWVAR 38
16774: PUSH
16775: LD_INT 3
16777: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16778: LD_ADDR_OWVAR 40
16782: PUSH
16783: LD_INT 51
16785: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16786: CALL_OW 45
16790: PPUSH
16791: LD_INT 49
16793: PPUSH
16794: LD_INT 13
16796: PPUSH
16797: LD_INT 0
16799: PPUSH
16800: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16804: LD_ADDR_EXP 46
16808: PUSH
16809: LD_INT 22
16811: PUSH
16812: LD_INT 7
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: LD_INT 30
16821: PUSH
16822: LD_INT 33
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 69
16837: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: DOUBLE
16844: LD_INT 1
16846: DEC
16847: ST_TO_ADDR
16848: LD_INT 22
16850: PUSH
16851: LD_INT 7
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 30
16860: PUSH
16861: LD_INT 33
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PUSH
16868: LD_INT 35
16870: PUSH
16871: LD_INT 0
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: PUSH
16883: EMPTY
16884: LIST
16885: PPUSH
16886: CALL_OW 69
16890: PUSH
16891: FOR_TO
16892: IFFALSE 16952
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16894: LD_INT 22
16896: PUSH
16897: LD_INT 7
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: LD_INT 30
16906: PUSH
16907: LD_INT 33
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: PUSH
16914: LD_INT 35
16916: PUSH
16917: LD_INT 0
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: LIST
16928: PUSH
16929: EMPTY
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_VAR 0 2
16941: ARRAY
16942: PPUSH
16943: LD_INT 49
16945: PPUSH
16946: CALL_OW 208
16950: GO 16891
16952: POP
16953: POP
// end ;
16954: LD_VAR 0 1
16958: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16959: LD_OWVAR 2
16963: PUSH
16964: LD_INT 1
16966: EQUAL
16967: IFFALSE 18135
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
16976: PPUSH
16977: PPUSH
// begin enable ;
16978: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16979: LD_ADDR_EXP 50
16983: PUSH
16984: LD_INT 22
16986: PUSH
16987: LD_INT 7
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 21
16996: PUSH
16997: LD_INT 3
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PPUSH
17008: CALL_OW 69
17012: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17013: LD_ADDR_EXP 48
17017: PUSH
17018: LD_INT 164
17020: PUSH
17021: LD_INT 197
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17028: LD_ADDR_EXP 47
17032: PUSH
17033: LD_INT 22
17035: PUSH
17036: LD_INT 7
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 30
17045: PUSH
17046: LD_INT 1
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PUSH
17053: EMPTY
17054: LIST
17055: LIST
17056: PPUSH
17057: CALL_OW 69
17061: PUSH
17062: LD_INT 1
17064: ARRAY
17065: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17066: LD_ADDR_EXP 49
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 7
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 30
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17104: LD_INT 22
17106: PUSH
17107: LD_INT 7
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: LD_INT 34
17116: PUSH
17117: LD_INT 51
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PPUSH
17128: CALL_OW 69
17132: IFFALSE 17172
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17134: LD_ADDR_EXP 45
17138: PUSH
17139: LD_INT 22
17141: PUSH
17142: LD_INT 7
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 34
17151: PUSH
17152: LD_INT 51
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PPUSH
17163: CALL_OW 69
17167: PUSH
17168: LD_INT 1
17170: ARRAY
17171: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17172: LD_ADDR_EXP 41
17176: PUSH
17177: LD_INT 22
17179: PUSH
17180: LD_INT 7
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 9
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PPUSH
17201: CALL_OW 69
17205: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17206: LD_ADDR_EXP 40
17210: PUSH
17211: LD_INT 22
17213: PUSH
17214: LD_INT 7
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: LD_INT 25
17223: PUSH
17224: LD_INT 2
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PPUSH
17235: CALL_OW 69
17239: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17240: LD_ADDR_EXP 42
17244: PUSH
17245: LD_INT 22
17247: PUSH
17248: LD_INT 7
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: LD_INT 25
17257: PUSH
17258: LD_INT 3
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17274: LD_ADDR_EXP 43
17278: PUSH
17279: LD_INT 22
17281: PUSH
17282: LD_INT 7
17284: PUSH
17285: EMPTY
17286: LIST
17287: LIST
17288: PUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PPUSH
17303: CALL_OW 69
17307: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17308: LD_EXP 41
17312: PPUSH
17313: LD_INT 81
17315: PUSH
17316: LD_INT 7
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: PPUSH
17328: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17332: LD_EXP 45
17336: PPUSH
17337: CALL_OW 314
17341: NOT
17342: PUSH
17343: LD_EXP 45
17347: PPUSH
17348: LD_INT 1
17350: PPUSH
17351: CALL_OW 289
17355: PUSH
17356: LD_INT 100
17358: LESS
17359: AND
17360: IFFALSE 17408
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17362: LD_ADDR_VAR 0 4
17366: PUSH
17367: LD_INT 12
17369: PPUSH
17370: CALL_OW 435
17374: ST_TO_ADDR
// if cr then
17375: LD_VAR 0 4
17379: IFFALSE 17408
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17381: LD_EXP 45
17385: PPUSH
17386: LD_VAR 0 4
17390: PUSH
17391: LD_INT 1
17393: ARRAY
17394: PPUSH
17395: LD_VAR 0 4
17399: PUSH
17400: LD_INT 2
17402: ARRAY
17403: PPUSH
17404: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17408: LD_EXP 50
17412: PPUSH
17413: LD_INT 3
17415: PUSH
17416: LD_INT 24
17418: PUSH
17419: LD_INT 1000
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: PUSH
17426: EMPTY
17427: LIST
17428: LIST
17429: PPUSH
17430: CALL_OW 72
17434: IFFALSE 17564
// begin if al_eng then
17436: LD_EXP 40
17440: IFFALSE 17562
// for i = 1 to al_eng do
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: DOUBLE
17448: LD_INT 1
17450: DEC
17451: ST_TO_ADDR
17452: LD_EXP 40
17456: PUSH
17457: FOR_TO
17458: IFFALSE 17560
// if IsInUnit ( al_eng [ i ] ) then
17460: LD_EXP 40
17464: PUSH
17465: LD_VAR 0 1
17469: ARRAY
17470: PPUSH
17471: CALL_OW 310
17475: IFFALSE 17494
// ComExitBuilding ( al_eng [ i ] ) else
17477: LD_EXP 40
17481: PUSH
17482: LD_VAR 0 1
17486: ARRAY
17487: PPUSH
17488: CALL_OW 122
17492: GO 17558
// if not HasTask ( al_eng [ i ] ) then
17494: LD_EXP 40
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 314
17509: NOT
17510: IFFALSE 17558
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17512: LD_EXP 40
17516: PUSH
17517: LD_VAR 0 1
17521: ARRAY
17522: PPUSH
17523: LD_EXP 50
17527: PPUSH
17528: LD_INT 3
17530: PUSH
17531: LD_INT 24
17533: PUSH
17534: LD_INT 1000
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: EMPTY
17542: LIST
17543: LIST
17544: PPUSH
17545: CALL_OW 72
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: CALL_OW 130
17558: GO 17457
17560: POP
17561: POP
// end else
17562: GO 17646
// if al_eng then
17564: LD_EXP 40
17568: IFFALSE 17646
// if not IsInUnit ( al_eng [ 1 ] ) then
17570: LD_EXP 40
17574: PUSH
17575: LD_INT 1
17577: ARRAY
17578: PPUSH
17579: CALL_OW 310
17583: NOT
17584: IFFALSE 17646
// for i = 1 to al_eng do
17586: LD_ADDR_VAR 0 1
17590: PUSH
17591: DOUBLE
17592: LD_INT 1
17594: DEC
17595: ST_TO_ADDR
17596: LD_EXP 40
17600: PUSH
17601: FOR_TO
17602: IFFALSE 17644
// if not IsInUnit ( al_eng [ i ] ) then
17604: LD_EXP 40
17608: PUSH
17609: LD_VAR 0 1
17613: ARRAY
17614: PPUSH
17615: CALL_OW 310
17619: NOT
17620: IFFALSE 17642
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17622: LD_EXP 40
17626: PUSH
17627: LD_VAR 0 1
17631: ARRAY
17632: PPUSH
17633: LD_EXP 47
17637: PPUSH
17638: CALL_OW 120
17642: GO 17601
17644: POP
17645: POP
// if al_vehs then
17646: LD_EXP 44
17650: IFFALSE 17750
// if BuildingStatus ( al_fac ) = bs_idle then
17652: LD_EXP 49
17656: PPUSH
17657: CALL_OW 461
17661: PUSH
17662: LD_INT 2
17664: EQUAL
17665: IFFALSE 17750
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17667: LD_EXP 49
17671: PPUSH
17672: LD_EXP 44
17676: PUSH
17677: LD_INT 1
17679: ARRAY
17680: PPUSH
17681: LD_EXP 44
17685: PUSH
17686: LD_INT 2
17688: ARRAY
17689: PPUSH
17690: LD_EXP 44
17694: PUSH
17695: LD_INT 3
17697: ARRAY
17698: PPUSH
17699: LD_EXP 44
17703: PUSH
17704: LD_INT 4
17706: ARRAY
17707: PPUSH
17708: CALL_OW 125
// for i = 1 to 4 do
17712: LD_ADDR_VAR 0 1
17716: PUSH
17717: DOUBLE
17718: LD_INT 1
17720: DEC
17721: ST_TO_ADDR
17722: LD_INT 4
17724: PUSH
17725: FOR_TO
17726: IFFALSE 17748
// al_vehs := Delete ( al_vehs , 1 ) ;
17728: LD_ADDR_EXP 44
17732: PUSH
17733: LD_EXP 44
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 3
17745: ST_TO_ADDR
17746: GO 17725
17748: POP
17749: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17750: LD_EXP 38
17754: PUSH
17755: LD_INT 0
17757: EQUAL
17758: PUSH
17759: LD_OWVAR 1
17763: PUSH
17764: LD_INT 23100
17766: MOD
17767: PUSH
17768: LD_INT 0
17770: EQUAL
17771: AND
17772: IFFALSE 17886
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17774: LD_ADDR_VAR 0 1
17778: PUSH
17779: DOUBLE
17780: LD_INT 1
17782: DEC
17783: ST_TO_ADDR
17784: LD_INT 4
17786: PUSH
17787: LD_INT 5
17789: PUSH
17790: LD_INT 6
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: LIST
17797: PUSH
17798: LD_OWVAR 67
17802: ARRAY
17803: PUSH
17804: FOR_TO
17805: IFFALSE 17884
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17807: LD_ADDR_EXP 44
17811: PUSH
17812: LD_EXP 44
17816: PUSH
17817: LD_INT 23
17819: ADD
17820: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17821: LD_ADDR_EXP 44
17825: PUSH
17826: LD_EXP 44
17830: PUSH
17831: LD_INT 1
17833: ADD
17834: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17835: LD_ADDR_EXP 44
17839: PUSH
17840: LD_EXP 44
17844: PUSH
17845: LD_INT 3
17847: ADD
17848: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17849: LD_ADDR_EXP 44
17853: PUSH
17854: LD_EXP 44
17858: PUSH
17859: LD_INT 46
17861: PUSH
17862: LD_INT 47
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: PUSH
17869: LD_INT 1
17871: PPUSH
17872: LD_INT 2
17874: PPUSH
17875: CALL_OW 12
17879: ARRAY
17880: ADD
17881: ST_TO_ADDR
// end ;
17882: GO 17804
17884: POP
17885: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17886: LD_INT 22
17888: PUSH
17889: LD_INT 7
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PUSH
17896: LD_INT 34
17898: PUSH
17899: LD_INT 51
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PPUSH
17910: CALL_OW 69
17914: PUSH
17915: LD_INT 0
17917: EQUAL
17918: IFFALSE 17941
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17920: LD_EXP 49
17924: PPUSH
17925: LD_INT 21
17927: PPUSH
17928: LD_INT 1
17930: PPUSH
17931: LD_INT 3
17933: PPUSH
17934: LD_INT 51
17936: PPUSH
17937: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17941: LD_EXP 38
17945: PUSH
17946: LD_OWVAR 1
17950: PUSH
17951: LD_INT 25200
17953: MOD
17954: PUSH
17955: LD_INT 0
17957: EQUAL
17958: AND
17959: IFFALSE 18022
// begin for i = 1 to al_force do
17961: LD_ADDR_VAR 0 1
17965: PUSH
17966: DOUBLE
17967: LD_INT 1
17969: DEC
17970: ST_TO_ADDR
17971: LD_EXP 38
17975: PUSH
17976: FOR_TO
17977: IFFALSE 18020
// if GetTag ( al_force [ i ] ) <> 11 then
17979: LD_EXP 38
17983: PUSH
17984: LD_VAR 0 1
17988: ARRAY
17989: PPUSH
17990: CALL_OW 110
17994: PUSH
17995: LD_INT 11
17997: NONEQUAL
17998: IFFALSE 18018
// SetTag ( al_force [ i ] , 11 ) ;
18000: LD_EXP 38
18004: PUSH
18005: LD_VAR 0 1
18009: ARRAY
18010: PPUSH
18011: LD_INT 11
18013: PPUSH
18014: CALL_OW 109
18018: GO 17976
18020: POP
18021: POP
// end ; if al_force then
18022: LD_EXP 38
18026: IFFALSE 18135
// for i = 1 to al_force do
18028: LD_ADDR_VAR 0 1
18032: PUSH
18033: DOUBLE
18034: LD_INT 1
18036: DEC
18037: ST_TO_ADDR
18038: LD_EXP 38
18042: PUSH
18043: FOR_TO
18044: IFFALSE 18133
// begin if GetTag ( al_force [ i ] ) = 11 then
18046: LD_EXP 38
18050: PUSH
18051: LD_VAR 0 1
18055: ARRAY
18056: PPUSH
18057: CALL_OW 110
18061: PUSH
18062: LD_INT 11
18064: EQUAL
18065: IFFALSE 18131
// begin if not HasTask ( al_force [ i ] ) then
18067: LD_EXP 38
18071: PUSH
18072: LD_VAR 0 1
18076: ARRAY
18077: PPUSH
18078: CALL_OW 314
18082: NOT
18083: IFFALSE 18131
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18085: LD_EXP 38
18089: PUSH
18090: LD_VAR 0 1
18094: ARRAY
18095: PPUSH
18096: LD_INT 81
18098: PUSH
18099: LD_INT 7
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: PPUSH
18106: CALL_OW 69
18110: PPUSH
18111: LD_EXP 38
18115: PUSH
18116: LD_VAR 0 1
18120: ARRAY
18121: PPUSH
18122: CALL_OW 74
18126: PPUSH
18127: CALL_OW 115
// end ; end ;
18131: GO 18043
18133: POP
18134: POP
// end ; end_of_file
18135: PPOPN 4
18137: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18138: LD_INT 0
18140: PPUSH
18141: PPUSH
18142: PPUSH
18143: PPUSH
18144: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18145: LD_ADDR_EXP 53
18149: PUSH
18150: LD_INT 7
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 5
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: LIST
18163: PUSH
18164: LD_OWVAR 67
18168: ARRAY
18169: ST_TO_ADDR
// ar_force := [ ] ;
18170: LD_ADDR_EXP 52
18174: PUSH
18175: EMPTY
18176: ST_TO_ADDR
// RemoveAlliance ;
18177: CALL 15966 0 0
// RemoveEnvironmentArea ( evn ) ;
18181: LD_INT 17
18183: PPUSH
18184: CALL_OW 355
// your_side := 2 ;
18188: LD_ADDR_OWVAR 2
18192: PUSH
18193: LD_INT 2
18195: ST_TO_ADDR
// uc_side := 2 ;
18196: LD_ADDR_OWVAR 20
18200: PUSH
18201: LD_INT 2
18203: ST_TO_ADDR
// uc_nation := nation_arabian ;
18204: LD_ADDR_OWVAR 21
18208: PUSH
18209: LD_INT 2
18211: ST_TO_ADDR
// hc_gallery :=  ;
18212: LD_ADDR_OWVAR 33
18216: PUSH
18217: LD_STRING 
18219: ST_TO_ADDR
// hc_name :=  ;
18220: LD_ADDR_OWVAR 26
18224: PUSH
18225: LD_STRING 
18227: ST_TO_ADDR
// hc_importance := 0 ;
18228: LD_ADDR_OWVAR 32
18232: PUSH
18233: LD_INT 0
18235: ST_TO_ADDR
// for i = 1 to 15 do
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: DOUBLE
18242: LD_INT 1
18244: DEC
18245: ST_TO_ADDR
18246: LD_INT 15
18248: PUSH
18249: FOR_TO
18250: IFFALSE 18303
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18252: LD_INT 0
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_INT 4
18260: PPUSH
18261: CALL_OW 12
18265: PPUSH
18266: LD_EXP 53
18270: PPUSH
18271: CALL_OW 380
// un := CreateHuman ;
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: CALL_OW 44
18284: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18285: LD_ADDR_EXP 52
18289: PUSH
18290: LD_EXP 52
18294: PUSH
18295: LD_VAR 0 4
18299: ADD
18300: ST_TO_ADDR
// end ;
18301: GO 18249
18303: POP
18304: POP
// hc_importance := 100 ;
18305: LD_ADDR_OWVAR 32
18309: PUSH
18310: LD_INT 100
18312: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18313: LD_INT 1
18315: PPUSH
18316: LD_INT 11
18318: PPUSH
18319: LD_EXP 53
18323: PPUSH
18324: CALL_OW 380
// ar_commander := CreateHuman ;
18328: LD_ADDR_EXP 51
18332: PUSH
18333: CALL_OW 44
18337: ST_TO_ADDR
// player_commander := ar_commander ;
18338: LD_ADDR_EXP 10
18342: PUSH
18343: LD_EXP 51
18347: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18348: LD_ADDR_VAR 0 5
18352: PUSH
18353: LD_STRING text
18355: PPUSH
18356: LD_INT 11
18358: PUSH
18359: LD_INT 10
18361: PUSH
18362: LD_INT 9
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: PUSH
18370: LD_OWVAR 67
18374: ARRAY
18375: PPUSH
18376: LD_INT 11
18378: PUSH
18379: LD_INT 10
18381: PUSH
18382: LD_INT 9
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: LD_OWVAR 67
18394: ARRAY
18395: PPUSH
18396: LD_INT -5
18398: PUSH
18399: LD_EXP 51
18403: PUSH
18404: LD_INT -3
18406: PUSH
18407: LD_INT -2
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: PUSH
18416: LD_EXP 52
18420: ADD
18421: PPUSH
18422: LD_INT 1
18424: PUSH
18425: LD_INT 3
18427: PUSH
18428: LD_INT 2
18430: PUSH
18431: LD_INT 1
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: PUSH
18438: LD_INT 4
18440: PUSH
18441: LD_INT 1
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PUSH
18448: LD_INT 8
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: PPUSH
18458: CALL_OW 42
18462: ST_TO_ADDR
// team := team ^ ar_commander ;
18463: LD_ADDR_VAR 0 5
18467: PUSH
18468: LD_VAR 0 5
18472: PUSH
18473: LD_EXP 51
18477: ADD
18478: ST_TO_ADDR
// for i = 1 to team do
18479: LD_ADDR_VAR 0 2
18483: PUSH
18484: DOUBLE
18485: LD_INT 1
18487: DEC
18488: ST_TO_ADDR
18489: LD_VAR 0 5
18493: PUSH
18494: FOR_TO
18495: IFFALSE 18520
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18497: LD_VAR 0 5
18501: PUSH
18502: LD_VAR 0 2
18506: ARRAY
18507: PPUSH
18508: LD_INT 16
18510: PPUSH
18511: LD_INT 0
18513: PPUSH
18514: CALL_OW 49
18518: GO 18494
18520: POP
18521: POP
// uc_side := 0 ;
18522: LD_ADDR_OWVAR 20
18526: PUSH
18527: LD_INT 0
18529: ST_TO_ADDR
// uc_nation := 0 ;
18530: LD_ADDR_OWVAR 21
18534: PUSH
18535: LD_INT 0
18537: ST_TO_ADDR
// vc_chassis := 31 ;
18538: LD_ADDR_OWVAR 37
18542: PUSH
18543: LD_INT 31
18545: ST_TO_ADDR
// vc_control := control_rider ;
18546: LD_ADDR_OWVAR 38
18550: PUSH
18551: LD_INT 4
18553: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18554: CALL_OW 45
18558: PPUSH
18559: LD_INT 96
18561: PPUSH
18562: LD_INT 20
18564: PPUSH
18565: LD_INT 0
18567: PPUSH
18568: CALL_OW 48
// end ; end_of_file
18572: LD_VAR 0 1
18576: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18577: GO 18579
18579: DISABLE
// begin ru_radar := 98 ;
18580: LD_ADDR_EXP 54
18584: PUSH
18585: LD_INT 98
18587: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18588: LD_ADDR_EXP 55
18592: PUSH
18593: LD_INT 89
18595: ST_TO_ADDR
// us_hack := 99 ;
18596: LD_ADDR_EXP 56
18600: PUSH
18601: LD_INT 99
18603: ST_TO_ADDR
// us_artillery := 97 ;
18604: LD_ADDR_EXP 57
18608: PUSH
18609: LD_INT 97
18611: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18612: LD_ADDR_EXP 58
18616: PUSH
18617: LD_INT 91
18619: ST_TO_ADDR
// end ; end_of_file end_of_file
18620: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18621: GO 18623
18623: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18624: LD_STRING initStreamRollete();
18626: PPUSH
18627: CALL_OW 559
// InitStreamMode ;
18631: CALL 18640 0 0
// DefineStreamItems ( ) ;
18635: CALL 19080 0 0
// end ;
18639: END
// function InitStreamMode ; begin
18640: LD_INT 0
18642: PPUSH
// streamModeActive := false ;
18643: LD_ADDR_EXP 59
18647: PUSH
18648: LD_INT 0
18650: ST_TO_ADDR
// normalCounter := 26 ;
18651: LD_ADDR_EXP 60
18655: PUSH
18656: LD_INT 26
18658: ST_TO_ADDR
// hardcoreCounter := 12 ;
18659: LD_ADDR_EXP 61
18663: PUSH
18664: LD_INT 12
18666: ST_TO_ADDR
// sRocket := false ;
18667: LD_ADDR_EXP 64
18671: PUSH
18672: LD_INT 0
18674: ST_TO_ADDR
// sSpeed := false ;
18675: LD_ADDR_EXP 63
18679: PUSH
18680: LD_INT 0
18682: ST_TO_ADDR
// sEngine := false ;
18683: LD_ADDR_EXP 65
18687: PUSH
18688: LD_INT 0
18690: ST_TO_ADDR
// sSpec := false ;
18691: LD_ADDR_EXP 62
18695: PUSH
18696: LD_INT 0
18698: ST_TO_ADDR
// sLevel := false ;
18699: LD_ADDR_EXP 66
18703: PUSH
18704: LD_INT 0
18706: ST_TO_ADDR
// sArmoury := false ;
18707: LD_ADDR_EXP 67
18711: PUSH
18712: LD_INT 0
18714: ST_TO_ADDR
// sRadar := false ;
18715: LD_ADDR_EXP 68
18719: PUSH
18720: LD_INT 0
18722: ST_TO_ADDR
// sBunker := false ;
18723: LD_ADDR_EXP 69
18727: PUSH
18728: LD_INT 0
18730: ST_TO_ADDR
// sHack := false ;
18731: LD_ADDR_EXP 70
18735: PUSH
18736: LD_INT 0
18738: ST_TO_ADDR
// sFire := false ;
18739: LD_ADDR_EXP 71
18743: PUSH
18744: LD_INT 0
18746: ST_TO_ADDR
// sRefresh := false ;
18747: LD_ADDR_EXP 72
18751: PUSH
18752: LD_INT 0
18754: ST_TO_ADDR
// sExp := false ;
18755: LD_ADDR_EXP 73
18759: PUSH
18760: LD_INT 0
18762: ST_TO_ADDR
// sDepot := false ;
18763: LD_ADDR_EXP 74
18767: PUSH
18768: LD_INT 0
18770: ST_TO_ADDR
// sFlag := false ;
18771: LD_ADDR_EXP 75
18775: PUSH
18776: LD_INT 0
18778: ST_TO_ADDR
// sKamikadze := false ;
18779: LD_ADDR_EXP 83
18783: PUSH
18784: LD_INT 0
18786: ST_TO_ADDR
// sTroll := false ;
18787: LD_ADDR_EXP 84
18791: PUSH
18792: LD_INT 0
18794: ST_TO_ADDR
// sSlow := false ;
18795: LD_ADDR_EXP 85
18799: PUSH
18800: LD_INT 0
18802: ST_TO_ADDR
// sLack := false ;
18803: LD_ADDR_EXP 86
18807: PUSH
18808: LD_INT 0
18810: ST_TO_ADDR
// sTank := false ;
18811: LD_ADDR_EXP 88
18815: PUSH
18816: LD_INT 0
18818: ST_TO_ADDR
// sRemote := false ;
18819: LD_ADDR_EXP 89
18823: PUSH
18824: LD_INT 0
18826: ST_TO_ADDR
// sPowell := false ;
18827: LD_ADDR_EXP 90
18831: PUSH
18832: LD_INT 0
18834: ST_TO_ADDR
// sTeleport := false ;
18835: LD_ADDR_EXP 93
18839: PUSH
18840: LD_INT 0
18842: ST_TO_ADDR
// sOilTower := false ;
18843: LD_ADDR_EXP 95
18847: PUSH
18848: LD_INT 0
18850: ST_TO_ADDR
// sShovel := false ;
18851: LD_ADDR_EXP 96
18855: PUSH
18856: LD_INT 0
18858: ST_TO_ADDR
// sSheik := false ;
18859: LD_ADDR_EXP 97
18863: PUSH
18864: LD_INT 0
18866: ST_TO_ADDR
// sEarthquake := false ;
18867: LD_ADDR_EXP 99
18871: PUSH
18872: LD_INT 0
18874: ST_TO_ADDR
// sAI := false ;
18875: LD_ADDR_EXP 100
18879: PUSH
18880: LD_INT 0
18882: ST_TO_ADDR
// sCargo := false ;
18883: LD_ADDR_EXP 103
18887: PUSH
18888: LD_INT 0
18890: ST_TO_ADDR
// sDLaser := false ;
18891: LD_ADDR_EXP 104
18895: PUSH
18896: LD_INT 0
18898: ST_TO_ADDR
// sExchange := false ;
18899: LD_ADDR_EXP 105
18903: PUSH
18904: LD_INT 0
18906: ST_TO_ADDR
// sFac := false ;
18907: LD_ADDR_EXP 106
18911: PUSH
18912: LD_INT 0
18914: ST_TO_ADDR
// sPower := false ;
18915: LD_ADDR_EXP 107
18919: PUSH
18920: LD_INT 0
18922: ST_TO_ADDR
// sRandom := false ;
18923: LD_ADDR_EXP 108
18927: PUSH
18928: LD_INT 0
18930: ST_TO_ADDR
// sShield := false ;
18931: LD_ADDR_EXP 109
18935: PUSH
18936: LD_INT 0
18938: ST_TO_ADDR
// sTime := false ;
18939: LD_ADDR_EXP 110
18943: PUSH
18944: LD_INT 0
18946: ST_TO_ADDR
// sTools := false ;
18947: LD_ADDR_EXP 111
18951: PUSH
18952: LD_INT 0
18954: ST_TO_ADDR
// sSold := false ;
18955: LD_ADDR_EXP 76
18959: PUSH
18960: LD_INT 0
18962: ST_TO_ADDR
// sDiff := false ;
18963: LD_ADDR_EXP 77
18967: PUSH
18968: LD_INT 0
18970: ST_TO_ADDR
// sFog := false ;
18971: LD_ADDR_EXP 80
18975: PUSH
18976: LD_INT 0
18978: ST_TO_ADDR
// sReset := false ;
18979: LD_ADDR_EXP 81
18983: PUSH
18984: LD_INT 0
18986: ST_TO_ADDR
// sSun := false ;
18987: LD_ADDR_EXP 82
18991: PUSH
18992: LD_INT 0
18994: ST_TO_ADDR
// sTiger := false ;
18995: LD_ADDR_EXP 78
18999: PUSH
19000: LD_INT 0
19002: ST_TO_ADDR
// sBomb := false ;
19003: LD_ADDR_EXP 79
19007: PUSH
19008: LD_INT 0
19010: ST_TO_ADDR
// sWound := false ;
19011: LD_ADDR_EXP 87
19015: PUSH
19016: LD_INT 0
19018: ST_TO_ADDR
// sBetray := false ;
19019: LD_ADDR_EXP 91
19023: PUSH
19024: LD_INT 0
19026: ST_TO_ADDR
// sContamin := false ;
19027: LD_ADDR_EXP 92
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// sOil := false ;
19035: LD_ADDR_EXP 94
19039: PUSH
19040: LD_INT 0
19042: ST_TO_ADDR
// sStu := false ;
19043: LD_ADDR_EXP 98
19047: PUSH
19048: LD_INT 0
19050: ST_TO_ADDR
// sBazooka := false ;
19051: LD_ADDR_EXP 101
19055: PUSH
19056: LD_INT 0
19058: ST_TO_ADDR
// sMortar := false ;
19059: LD_ADDR_EXP 102
19063: PUSH
19064: LD_INT 0
19066: ST_TO_ADDR
// sRanger := false ;
19067: LD_ADDR_EXP 112
19071: PUSH
19072: LD_INT 0
19074: ST_TO_ADDR
// end ;
19075: LD_VAR 0 1
19079: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19080: LD_INT 0
19082: PPUSH
19083: PPUSH
19084: PPUSH
19085: PPUSH
19086: PPUSH
// result := [ ] ;
19087: LD_ADDR_VAR 0 1
19091: PUSH
19092: EMPTY
19093: ST_TO_ADDR
// if campaign_id = 1 then
19094: LD_OWVAR 69
19098: PUSH
19099: LD_INT 1
19101: EQUAL
19102: IFFALSE 22050
// begin case mission_number of 1 :
19104: LD_OWVAR 70
19108: PUSH
19109: LD_INT 1
19111: DOUBLE
19112: EQUAL
19113: IFTRUE 19117
19115: GO 19181
19117: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19118: LD_ADDR_VAR 0 1
19122: PUSH
19123: LD_INT 2
19125: PUSH
19126: LD_INT 4
19128: PUSH
19129: LD_INT 11
19131: PUSH
19132: LD_INT 12
19134: PUSH
19135: LD_INT 15
19137: PUSH
19138: LD_INT 16
19140: PUSH
19141: LD_INT 22
19143: PUSH
19144: LD_INT 23
19146: PUSH
19147: LD_INT 26
19149: PUSH
19150: EMPTY
19151: LIST
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: PUSH
19161: LD_INT 101
19163: PUSH
19164: LD_INT 102
19166: PUSH
19167: LD_INT 106
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: LIST
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: ST_TO_ADDR
19179: GO 22050
19181: LD_INT 2
19183: DOUBLE
19184: EQUAL
19185: IFTRUE 19189
19187: GO 19261
19189: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19190: LD_ADDR_VAR 0 1
19194: PUSH
19195: LD_INT 2
19197: PUSH
19198: LD_INT 4
19200: PUSH
19201: LD_INT 11
19203: PUSH
19204: LD_INT 12
19206: PUSH
19207: LD_INT 15
19209: PUSH
19210: LD_INT 16
19212: PUSH
19213: LD_INT 22
19215: PUSH
19216: LD_INT 23
19218: PUSH
19219: LD_INT 26
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: LIST
19226: LIST
19227: LIST
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: PUSH
19233: LD_INT 101
19235: PUSH
19236: LD_INT 102
19238: PUSH
19239: LD_INT 105
19241: PUSH
19242: LD_INT 106
19244: PUSH
19245: LD_INT 108
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: ST_TO_ADDR
19259: GO 22050
19261: LD_INT 3
19263: DOUBLE
19264: EQUAL
19265: IFTRUE 19269
19267: GO 19345
19269: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19270: LD_ADDR_VAR 0 1
19274: PUSH
19275: LD_INT 2
19277: PUSH
19278: LD_INT 4
19280: PUSH
19281: LD_INT 5
19283: PUSH
19284: LD_INT 11
19286: PUSH
19287: LD_INT 12
19289: PUSH
19290: LD_INT 15
19292: PUSH
19293: LD_INT 16
19295: PUSH
19296: LD_INT 22
19298: PUSH
19299: LD_INT 26
19301: PUSH
19302: LD_INT 36
19304: PUSH
19305: EMPTY
19306: LIST
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 101
19319: PUSH
19320: LD_INT 102
19322: PUSH
19323: LD_INT 105
19325: PUSH
19326: LD_INT 106
19328: PUSH
19329: LD_INT 108
19331: PUSH
19332: EMPTY
19333: LIST
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: ST_TO_ADDR
19343: GO 22050
19345: LD_INT 4
19347: DOUBLE
19348: EQUAL
19349: IFTRUE 19353
19351: GO 19437
19353: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19354: LD_ADDR_VAR 0 1
19358: PUSH
19359: LD_INT 2
19361: PUSH
19362: LD_INT 4
19364: PUSH
19365: LD_INT 5
19367: PUSH
19368: LD_INT 8
19370: PUSH
19371: LD_INT 11
19373: PUSH
19374: LD_INT 12
19376: PUSH
19377: LD_INT 15
19379: PUSH
19380: LD_INT 16
19382: PUSH
19383: LD_INT 22
19385: PUSH
19386: LD_INT 23
19388: PUSH
19389: LD_INT 26
19391: PUSH
19392: LD_INT 36
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: PUSH
19409: LD_INT 101
19411: PUSH
19412: LD_INT 102
19414: PUSH
19415: LD_INT 105
19417: PUSH
19418: LD_INT 106
19420: PUSH
19421: LD_INT 108
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: ST_TO_ADDR
19435: GO 22050
19437: LD_INT 5
19439: DOUBLE
19440: EQUAL
19441: IFTRUE 19445
19443: GO 19545
19445: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19446: LD_ADDR_VAR 0 1
19450: PUSH
19451: LD_INT 2
19453: PUSH
19454: LD_INT 4
19456: PUSH
19457: LD_INT 5
19459: PUSH
19460: LD_INT 6
19462: PUSH
19463: LD_INT 8
19465: PUSH
19466: LD_INT 11
19468: PUSH
19469: LD_INT 12
19471: PUSH
19472: LD_INT 15
19474: PUSH
19475: LD_INT 16
19477: PUSH
19478: LD_INT 22
19480: PUSH
19481: LD_INT 23
19483: PUSH
19484: LD_INT 25
19486: PUSH
19487: LD_INT 26
19489: PUSH
19490: LD_INT 36
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: PUSH
19509: LD_INT 101
19511: PUSH
19512: LD_INT 102
19514: PUSH
19515: LD_INT 105
19517: PUSH
19518: LD_INT 106
19520: PUSH
19521: LD_INT 108
19523: PUSH
19524: LD_INT 109
19526: PUSH
19527: LD_INT 112
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: LIST
19536: LIST
19537: LIST
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: ST_TO_ADDR
19543: GO 22050
19545: LD_INT 6
19547: DOUBLE
19548: EQUAL
19549: IFTRUE 19553
19551: GO 19673
19553: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19554: LD_ADDR_VAR 0 1
19558: PUSH
19559: LD_INT 2
19561: PUSH
19562: LD_INT 4
19564: PUSH
19565: LD_INT 5
19567: PUSH
19568: LD_INT 6
19570: PUSH
19571: LD_INT 8
19573: PUSH
19574: LD_INT 11
19576: PUSH
19577: LD_INT 12
19579: PUSH
19580: LD_INT 15
19582: PUSH
19583: LD_INT 16
19585: PUSH
19586: LD_INT 20
19588: PUSH
19589: LD_INT 21
19591: PUSH
19592: LD_INT 22
19594: PUSH
19595: LD_INT 23
19597: PUSH
19598: LD_INT 25
19600: PUSH
19601: LD_INT 26
19603: PUSH
19604: LD_INT 30
19606: PUSH
19607: LD_INT 31
19609: PUSH
19610: LD_INT 32
19612: PUSH
19613: LD_INT 36
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: LIST
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: PUSH
19637: LD_INT 101
19639: PUSH
19640: LD_INT 102
19642: PUSH
19643: LD_INT 105
19645: PUSH
19646: LD_INT 106
19648: PUSH
19649: LD_INT 108
19651: PUSH
19652: LD_INT 109
19654: PUSH
19655: LD_INT 112
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: ST_TO_ADDR
19671: GO 22050
19673: LD_INT 7
19675: DOUBLE
19676: EQUAL
19677: IFTRUE 19681
19679: GO 19781
19681: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19682: LD_ADDR_VAR 0 1
19686: PUSH
19687: LD_INT 2
19689: PUSH
19690: LD_INT 4
19692: PUSH
19693: LD_INT 5
19695: PUSH
19696: LD_INT 7
19698: PUSH
19699: LD_INT 11
19701: PUSH
19702: LD_INT 12
19704: PUSH
19705: LD_INT 15
19707: PUSH
19708: LD_INT 16
19710: PUSH
19711: LD_INT 20
19713: PUSH
19714: LD_INT 21
19716: PUSH
19717: LD_INT 22
19719: PUSH
19720: LD_INT 23
19722: PUSH
19723: LD_INT 25
19725: PUSH
19726: LD_INT 26
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: PUSH
19745: LD_INT 101
19747: PUSH
19748: LD_INT 102
19750: PUSH
19751: LD_INT 103
19753: PUSH
19754: LD_INT 105
19756: PUSH
19757: LD_INT 106
19759: PUSH
19760: LD_INT 108
19762: PUSH
19763: LD_INT 112
19765: PUSH
19766: EMPTY
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 22050
19781: LD_INT 8
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19917
19789: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_INT 2
19797: PUSH
19798: LD_INT 4
19800: PUSH
19801: LD_INT 5
19803: PUSH
19804: LD_INT 6
19806: PUSH
19807: LD_INT 7
19809: PUSH
19810: LD_INT 8
19812: PUSH
19813: LD_INT 11
19815: PUSH
19816: LD_INT 12
19818: PUSH
19819: LD_INT 15
19821: PUSH
19822: LD_INT 16
19824: PUSH
19825: LD_INT 20
19827: PUSH
19828: LD_INT 21
19830: PUSH
19831: LD_INT 22
19833: PUSH
19834: LD_INT 23
19836: PUSH
19837: LD_INT 25
19839: PUSH
19840: LD_INT 26
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_INT 31
19848: PUSH
19849: LD_INT 32
19851: PUSH
19852: LD_INT 36
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: PUSH
19877: LD_INT 101
19879: PUSH
19880: LD_INT 102
19882: PUSH
19883: LD_INT 103
19885: PUSH
19886: LD_INT 105
19888: PUSH
19889: LD_INT 106
19891: PUSH
19892: LD_INT 108
19894: PUSH
19895: LD_INT 109
19897: PUSH
19898: LD_INT 112
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: ST_TO_ADDR
19915: GO 22050
19917: LD_INT 9
19919: DOUBLE
19920: EQUAL
19921: IFTRUE 19925
19923: GO 20061
19925: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19926: LD_ADDR_VAR 0 1
19930: PUSH
19931: LD_INT 2
19933: PUSH
19934: LD_INT 4
19936: PUSH
19937: LD_INT 5
19939: PUSH
19940: LD_INT 6
19942: PUSH
19943: LD_INT 7
19945: PUSH
19946: LD_INT 8
19948: PUSH
19949: LD_INT 11
19951: PUSH
19952: LD_INT 12
19954: PUSH
19955: LD_INT 15
19957: PUSH
19958: LD_INT 16
19960: PUSH
19961: LD_INT 20
19963: PUSH
19964: LD_INT 21
19966: PUSH
19967: LD_INT 22
19969: PUSH
19970: LD_INT 23
19972: PUSH
19973: LD_INT 25
19975: PUSH
19976: LD_INT 26
19978: PUSH
19979: LD_INT 28
19981: PUSH
19982: LD_INT 30
19984: PUSH
19985: LD_INT 31
19987: PUSH
19988: LD_INT 32
19990: PUSH
19991: LD_INT 36
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: PUSH
20017: LD_INT 101
20019: PUSH
20020: LD_INT 102
20022: PUSH
20023: LD_INT 103
20025: PUSH
20026: LD_INT 105
20028: PUSH
20029: LD_INT 106
20031: PUSH
20032: LD_INT 108
20034: PUSH
20035: LD_INT 109
20037: PUSH
20038: LD_INT 112
20040: PUSH
20041: LD_INT 114
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: LIST
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 22050
20061: LD_INT 10
20063: DOUBLE
20064: EQUAL
20065: IFTRUE 20069
20067: GO 20253
20069: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20070: LD_ADDR_VAR 0 1
20074: PUSH
20075: LD_INT 2
20077: PUSH
20078: LD_INT 4
20080: PUSH
20081: LD_INT 5
20083: PUSH
20084: LD_INT 6
20086: PUSH
20087: LD_INT 7
20089: PUSH
20090: LD_INT 8
20092: PUSH
20093: LD_INT 9
20095: PUSH
20096: LD_INT 10
20098: PUSH
20099: LD_INT 11
20101: PUSH
20102: LD_INT 12
20104: PUSH
20105: LD_INT 13
20107: PUSH
20108: LD_INT 14
20110: PUSH
20111: LD_INT 15
20113: PUSH
20114: LD_INT 16
20116: PUSH
20117: LD_INT 17
20119: PUSH
20120: LD_INT 18
20122: PUSH
20123: LD_INT 19
20125: PUSH
20126: LD_INT 20
20128: PUSH
20129: LD_INT 21
20131: PUSH
20132: LD_INT 22
20134: PUSH
20135: LD_INT 23
20137: PUSH
20138: LD_INT 24
20140: PUSH
20141: LD_INT 25
20143: PUSH
20144: LD_INT 26
20146: PUSH
20147: LD_INT 28
20149: PUSH
20150: LD_INT 30
20152: PUSH
20153: LD_INT 31
20155: PUSH
20156: LD_INT 32
20158: PUSH
20159: LD_INT 36
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 101
20195: PUSH
20196: LD_INT 102
20198: PUSH
20199: LD_INT 103
20201: PUSH
20202: LD_INT 104
20204: PUSH
20205: LD_INT 105
20207: PUSH
20208: LD_INT 106
20210: PUSH
20211: LD_INT 107
20213: PUSH
20214: LD_INT 108
20216: PUSH
20217: LD_INT 109
20219: PUSH
20220: LD_INT 110
20222: PUSH
20223: LD_INT 111
20225: PUSH
20226: LD_INT 112
20228: PUSH
20229: LD_INT 114
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: LIST
20236: LIST
20237: LIST
20238: LIST
20239: LIST
20240: LIST
20241: LIST
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 22050
20253: LD_INT 11
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20453
20261: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20262: LD_ADDR_VAR 0 1
20266: PUSH
20267: LD_INT 2
20269: PUSH
20270: LD_INT 3
20272: PUSH
20273: LD_INT 4
20275: PUSH
20276: LD_INT 5
20278: PUSH
20279: LD_INT 6
20281: PUSH
20282: LD_INT 7
20284: PUSH
20285: LD_INT 8
20287: PUSH
20288: LD_INT 9
20290: PUSH
20291: LD_INT 10
20293: PUSH
20294: LD_INT 11
20296: PUSH
20297: LD_INT 12
20299: PUSH
20300: LD_INT 13
20302: PUSH
20303: LD_INT 14
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 16
20311: PUSH
20312: LD_INT 17
20314: PUSH
20315: LD_INT 18
20317: PUSH
20318: LD_INT 19
20320: PUSH
20321: LD_INT 20
20323: PUSH
20324: LD_INT 21
20326: PUSH
20327: LD_INT 22
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: LD_INT 24
20335: PUSH
20336: LD_INT 25
20338: PUSH
20339: LD_INT 26
20341: PUSH
20342: LD_INT 28
20344: PUSH
20345: LD_INT 30
20347: PUSH
20348: LD_INT 31
20350: PUSH
20351: LD_INT 32
20353: PUSH
20354: LD_INT 34
20356: PUSH
20357: LD_INT 36
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: PUSH
20393: LD_INT 101
20395: PUSH
20396: LD_INT 102
20398: PUSH
20399: LD_INT 103
20401: PUSH
20402: LD_INT 104
20404: PUSH
20405: LD_INT 105
20407: PUSH
20408: LD_INT 106
20410: PUSH
20411: LD_INT 107
20413: PUSH
20414: LD_INT 108
20416: PUSH
20417: LD_INT 109
20419: PUSH
20420: LD_INT 110
20422: PUSH
20423: LD_INT 111
20425: PUSH
20426: LD_INT 112
20428: PUSH
20429: LD_INT 114
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: ST_TO_ADDR
20451: GO 22050
20453: LD_INT 12
20455: DOUBLE
20456: EQUAL
20457: IFTRUE 20461
20459: GO 20669
20461: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20462: LD_ADDR_VAR 0 1
20466: PUSH
20467: LD_INT 1
20469: PUSH
20470: LD_INT 2
20472: PUSH
20473: LD_INT 3
20475: PUSH
20476: LD_INT 4
20478: PUSH
20479: LD_INT 5
20481: PUSH
20482: LD_INT 6
20484: PUSH
20485: LD_INT 7
20487: PUSH
20488: LD_INT 8
20490: PUSH
20491: LD_INT 9
20493: PUSH
20494: LD_INT 10
20496: PUSH
20497: LD_INT 11
20499: PUSH
20500: LD_INT 12
20502: PUSH
20503: LD_INT 13
20505: PUSH
20506: LD_INT 14
20508: PUSH
20509: LD_INT 15
20511: PUSH
20512: LD_INT 16
20514: PUSH
20515: LD_INT 17
20517: PUSH
20518: LD_INT 18
20520: PUSH
20521: LD_INT 19
20523: PUSH
20524: LD_INT 20
20526: PUSH
20527: LD_INT 21
20529: PUSH
20530: LD_INT 22
20532: PUSH
20533: LD_INT 23
20535: PUSH
20536: LD_INT 24
20538: PUSH
20539: LD_INT 25
20541: PUSH
20542: LD_INT 26
20544: PUSH
20545: LD_INT 27
20547: PUSH
20548: LD_INT 28
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 31
20556: PUSH
20557: LD_INT 32
20559: PUSH
20560: LD_INT 33
20562: PUSH
20563: LD_INT 34
20565: PUSH
20566: LD_INT 36
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: PUSH
20605: LD_INT 101
20607: PUSH
20608: LD_INT 102
20610: PUSH
20611: LD_INT 103
20613: PUSH
20614: LD_INT 104
20616: PUSH
20617: LD_INT 105
20619: PUSH
20620: LD_INT 106
20622: PUSH
20623: LD_INT 107
20625: PUSH
20626: LD_INT 108
20628: PUSH
20629: LD_INT 109
20631: PUSH
20632: LD_INT 110
20634: PUSH
20635: LD_INT 111
20637: PUSH
20638: LD_INT 112
20640: PUSH
20641: LD_INT 113
20643: PUSH
20644: LD_INT 114
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 22050
20669: LD_INT 13
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20885
20677: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20678: LD_ADDR_VAR 0 1
20682: PUSH
20683: LD_INT 1
20685: PUSH
20686: LD_INT 2
20688: PUSH
20689: LD_INT 3
20691: PUSH
20692: LD_INT 4
20694: PUSH
20695: LD_INT 5
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: LD_INT 7
20703: PUSH
20704: LD_INT 8
20706: PUSH
20707: LD_INT 9
20709: PUSH
20710: LD_INT 10
20712: PUSH
20713: LD_INT 11
20715: PUSH
20716: LD_INT 12
20718: PUSH
20719: LD_INT 13
20721: PUSH
20722: LD_INT 14
20724: PUSH
20725: LD_INT 15
20727: PUSH
20728: LD_INT 16
20730: PUSH
20731: LD_INT 17
20733: PUSH
20734: LD_INT 18
20736: PUSH
20737: LD_INT 19
20739: PUSH
20740: LD_INT 20
20742: PUSH
20743: LD_INT 21
20745: PUSH
20746: LD_INT 22
20748: PUSH
20749: LD_INT 23
20751: PUSH
20752: LD_INT 24
20754: PUSH
20755: LD_INT 25
20757: PUSH
20758: LD_INT 26
20760: PUSH
20761: LD_INT 27
20763: PUSH
20764: LD_INT 28
20766: PUSH
20767: LD_INT 30
20769: PUSH
20770: LD_INT 31
20772: PUSH
20773: LD_INT 32
20775: PUSH
20776: LD_INT 33
20778: PUSH
20779: LD_INT 34
20781: PUSH
20782: LD_INT 36
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: PUSH
20821: LD_INT 101
20823: PUSH
20824: LD_INT 102
20826: PUSH
20827: LD_INT 103
20829: PUSH
20830: LD_INT 104
20832: PUSH
20833: LD_INT 105
20835: PUSH
20836: LD_INT 106
20838: PUSH
20839: LD_INT 107
20841: PUSH
20842: LD_INT 108
20844: PUSH
20845: LD_INT 109
20847: PUSH
20848: LD_INT 110
20850: PUSH
20851: LD_INT 111
20853: PUSH
20854: LD_INT 112
20856: PUSH
20857: LD_INT 113
20859: PUSH
20860: LD_INT 114
20862: PUSH
20863: EMPTY
20864: LIST
20865: LIST
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: ST_TO_ADDR
20883: GO 22050
20885: LD_INT 14
20887: DOUBLE
20888: EQUAL
20889: IFTRUE 20893
20891: GO 21105
20893: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20894: LD_ADDR_VAR 0 1
20898: PUSH
20899: LD_INT 1
20901: PUSH
20902: LD_INT 2
20904: PUSH
20905: LD_INT 3
20907: PUSH
20908: LD_INT 4
20910: PUSH
20911: LD_INT 5
20913: PUSH
20914: LD_INT 6
20916: PUSH
20917: LD_INT 7
20919: PUSH
20920: LD_INT 8
20922: PUSH
20923: LD_INT 9
20925: PUSH
20926: LD_INT 10
20928: PUSH
20929: LD_INT 11
20931: PUSH
20932: LD_INT 12
20934: PUSH
20935: LD_INT 13
20937: PUSH
20938: LD_INT 14
20940: PUSH
20941: LD_INT 15
20943: PUSH
20944: LD_INT 16
20946: PUSH
20947: LD_INT 17
20949: PUSH
20950: LD_INT 18
20952: PUSH
20953: LD_INT 19
20955: PUSH
20956: LD_INT 20
20958: PUSH
20959: LD_INT 21
20961: PUSH
20962: LD_INT 22
20964: PUSH
20965: LD_INT 23
20967: PUSH
20968: LD_INT 24
20970: PUSH
20971: LD_INT 25
20973: PUSH
20974: LD_INT 26
20976: PUSH
20977: LD_INT 27
20979: PUSH
20980: LD_INT 28
20982: PUSH
20983: LD_INT 29
20985: PUSH
20986: LD_INT 30
20988: PUSH
20989: LD_INT 31
20991: PUSH
20992: LD_INT 32
20994: PUSH
20995: LD_INT 33
20997: PUSH
20998: LD_INT 34
21000: PUSH
21001: LD_INT 36
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: LIST
21015: LIST
21016: LIST
21017: LIST
21018: LIST
21019: LIST
21020: LIST
21021: LIST
21022: LIST
21023: LIST
21024: LIST
21025: LIST
21026: LIST
21027: LIST
21028: LIST
21029: LIST
21030: LIST
21031: LIST
21032: LIST
21033: LIST
21034: LIST
21035: LIST
21036: LIST
21037: LIST
21038: LIST
21039: LIST
21040: PUSH
21041: LD_INT 101
21043: PUSH
21044: LD_INT 102
21046: PUSH
21047: LD_INT 103
21049: PUSH
21050: LD_INT 104
21052: PUSH
21053: LD_INT 105
21055: PUSH
21056: LD_INT 106
21058: PUSH
21059: LD_INT 107
21061: PUSH
21062: LD_INT 108
21064: PUSH
21065: LD_INT 109
21067: PUSH
21068: LD_INT 110
21070: PUSH
21071: LD_INT 111
21073: PUSH
21074: LD_INT 112
21076: PUSH
21077: LD_INT 113
21079: PUSH
21080: LD_INT 114
21082: PUSH
21083: EMPTY
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: PUSH
21099: EMPTY
21100: LIST
21101: LIST
21102: ST_TO_ADDR
21103: GO 22050
21105: LD_INT 15
21107: DOUBLE
21108: EQUAL
21109: IFTRUE 21113
21111: GO 21325
21113: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21114: LD_ADDR_VAR 0 1
21118: PUSH
21119: LD_INT 1
21121: PUSH
21122: LD_INT 2
21124: PUSH
21125: LD_INT 3
21127: PUSH
21128: LD_INT 4
21130: PUSH
21131: LD_INT 5
21133: PUSH
21134: LD_INT 6
21136: PUSH
21137: LD_INT 7
21139: PUSH
21140: LD_INT 8
21142: PUSH
21143: LD_INT 9
21145: PUSH
21146: LD_INT 10
21148: PUSH
21149: LD_INT 11
21151: PUSH
21152: LD_INT 12
21154: PUSH
21155: LD_INT 13
21157: PUSH
21158: LD_INT 14
21160: PUSH
21161: LD_INT 15
21163: PUSH
21164: LD_INT 16
21166: PUSH
21167: LD_INT 17
21169: PUSH
21170: LD_INT 18
21172: PUSH
21173: LD_INT 19
21175: PUSH
21176: LD_INT 20
21178: PUSH
21179: LD_INT 21
21181: PUSH
21182: LD_INT 22
21184: PUSH
21185: LD_INT 23
21187: PUSH
21188: LD_INT 24
21190: PUSH
21191: LD_INT 25
21193: PUSH
21194: LD_INT 26
21196: PUSH
21197: LD_INT 27
21199: PUSH
21200: LD_INT 28
21202: PUSH
21203: LD_INT 29
21205: PUSH
21206: LD_INT 30
21208: PUSH
21209: LD_INT 31
21211: PUSH
21212: LD_INT 32
21214: PUSH
21215: LD_INT 33
21217: PUSH
21218: LD_INT 34
21220: PUSH
21221: LD_INT 36
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: LIST
21245: LIST
21246: LIST
21247: LIST
21248: LIST
21249: LIST
21250: LIST
21251: LIST
21252: LIST
21253: LIST
21254: LIST
21255: LIST
21256: LIST
21257: LIST
21258: LIST
21259: LIST
21260: PUSH
21261: LD_INT 101
21263: PUSH
21264: LD_INT 102
21266: PUSH
21267: LD_INT 103
21269: PUSH
21270: LD_INT 104
21272: PUSH
21273: LD_INT 105
21275: PUSH
21276: LD_INT 106
21278: PUSH
21279: LD_INT 107
21281: PUSH
21282: LD_INT 108
21284: PUSH
21285: LD_INT 109
21287: PUSH
21288: LD_INT 110
21290: PUSH
21291: LD_INT 111
21293: PUSH
21294: LD_INT 112
21296: PUSH
21297: LD_INT 113
21299: PUSH
21300: LD_INT 114
21302: PUSH
21303: EMPTY
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: ST_TO_ADDR
21323: GO 22050
21325: LD_INT 16
21327: DOUBLE
21328: EQUAL
21329: IFTRUE 21333
21331: GO 21457
21333: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: LD_INT 2
21341: PUSH
21342: LD_INT 4
21344: PUSH
21345: LD_INT 5
21347: PUSH
21348: LD_INT 7
21350: PUSH
21351: LD_INT 11
21353: PUSH
21354: LD_INT 12
21356: PUSH
21357: LD_INT 15
21359: PUSH
21360: LD_INT 16
21362: PUSH
21363: LD_INT 20
21365: PUSH
21366: LD_INT 21
21368: PUSH
21369: LD_INT 22
21371: PUSH
21372: LD_INT 23
21374: PUSH
21375: LD_INT 25
21377: PUSH
21378: LD_INT 26
21380: PUSH
21381: LD_INT 30
21383: PUSH
21384: LD_INT 31
21386: PUSH
21387: LD_INT 32
21389: PUSH
21390: LD_INT 33
21392: PUSH
21393: LD_INT 34
21395: PUSH
21396: EMPTY
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: LIST
21402: LIST
21403: LIST
21404: LIST
21405: LIST
21406: LIST
21407: LIST
21408: LIST
21409: LIST
21410: LIST
21411: LIST
21412: LIST
21413: LIST
21414: LIST
21415: LIST
21416: PUSH
21417: LD_INT 101
21419: PUSH
21420: LD_INT 102
21422: PUSH
21423: LD_INT 103
21425: PUSH
21426: LD_INT 106
21428: PUSH
21429: LD_INT 108
21431: PUSH
21432: LD_INT 112
21434: PUSH
21435: LD_INT 113
21437: PUSH
21438: LD_INT 114
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: LIST
21448: LIST
21449: LIST
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: ST_TO_ADDR
21455: GO 22050
21457: LD_INT 17
21459: DOUBLE
21460: EQUAL
21461: IFTRUE 21465
21463: GO 21677
21465: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21466: LD_ADDR_VAR 0 1
21470: PUSH
21471: LD_INT 1
21473: PUSH
21474: LD_INT 2
21476: PUSH
21477: LD_INT 3
21479: PUSH
21480: LD_INT 4
21482: PUSH
21483: LD_INT 5
21485: PUSH
21486: LD_INT 6
21488: PUSH
21489: LD_INT 7
21491: PUSH
21492: LD_INT 8
21494: PUSH
21495: LD_INT 9
21497: PUSH
21498: LD_INT 10
21500: PUSH
21501: LD_INT 11
21503: PUSH
21504: LD_INT 12
21506: PUSH
21507: LD_INT 13
21509: PUSH
21510: LD_INT 14
21512: PUSH
21513: LD_INT 15
21515: PUSH
21516: LD_INT 16
21518: PUSH
21519: LD_INT 17
21521: PUSH
21522: LD_INT 18
21524: PUSH
21525: LD_INT 19
21527: PUSH
21528: LD_INT 20
21530: PUSH
21531: LD_INT 21
21533: PUSH
21534: LD_INT 22
21536: PUSH
21537: LD_INT 23
21539: PUSH
21540: LD_INT 24
21542: PUSH
21543: LD_INT 25
21545: PUSH
21546: LD_INT 26
21548: PUSH
21549: LD_INT 27
21551: PUSH
21552: LD_INT 28
21554: PUSH
21555: LD_INT 29
21557: PUSH
21558: LD_INT 30
21560: PUSH
21561: LD_INT 31
21563: PUSH
21564: LD_INT 32
21566: PUSH
21567: LD_INT 33
21569: PUSH
21570: LD_INT 34
21572: PUSH
21573: LD_INT 36
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: LIST
21599: LIST
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: LIST
21607: LIST
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 101
21615: PUSH
21616: LD_INT 102
21618: PUSH
21619: LD_INT 103
21621: PUSH
21622: LD_INT 104
21624: PUSH
21625: LD_INT 105
21627: PUSH
21628: LD_INT 106
21630: PUSH
21631: LD_INT 107
21633: PUSH
21634: LD_INT 108
21636: PUSH
21637: LD_INT 109
21639: PUSH
21640: LD_INT 110
21642: PUSH
21643: LD_INT 111
21645: PUSH
21646: LD_INT 112
21648: PUSH
21649: LD_INT 113
21651: PUSH
21652: LD_INT 114
21654: PUSH
21655: EMPTY
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: PUSH
21671: EMPTY
21672: LIST
21673: LIST
21674: ST_TO_ADDR
21675: GO 22050
21677: LD_INT 18
21679: DOUBLE
21680: EQUAL
21681: IFTRUE 21685
21683: GO 21821
21685: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21686: LD_ADDR_VAR 0 1
21690: PUSH
21691: LD_INT 2
21693: PUSH
21694: LD_INT 4
21696: PUSH
21697: LD_INT 5
21699: PUSH
21700: LD_INT 7
21702: PUSH
21703: LD_INT 11
21705: PUSH
21706: LD_INT 12
21708: PUSH
21709: LD_INT 15
21711: PUSH
21712: LD_INT 16
21714: PUSH
21715: LD_INT 20
21717: PUSH
21718: LD_INT 21
21720: PUSH
21721: LD_INT 22
21723: PUSH
21724: LD_INT 23
21726: PUSH
21727: LD_INT 25
21729: PUSH
21730: LD_INT 26
21732: PUSH
21733: LD_INT 30
21735: PUSH
21736: LD_INT 31
21738: PUSH
21739: LD_INT 32
21741: PUSH
21742: LD_INT 33
21744: PUSH
21745: LD_INT 34
21747: PUSH
21748: LD_INT 35
21750: PUSH
21751: LD_INT 36
21753: PUSH
21754: EMPTY
21755: LIST
21756: LIST
21757: LIST
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: LIST
21763: LIST
21764: LIST
21765: LIST
21766: LIST
21767: LIST
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: LIST
21773: LIST
21774: LIST
21775: LIST
21776: PUSH
21777: LD_INT 101
21779: PUSH
21780: LD_INT 102
21782: PUSH
21783: LD_INT 103
21785: PUSH
21786: LD_INT 106
21788: PUSH
21789: LD_INT 108
21791: PUSH
21792: LD_INT 112
21794: PUSH
21795: LD_INT 113
21797: PUSH
21798: LD_INT 114
21800: PUSH
21801: LD_INT 115
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: LIST
21813: LIST
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: ST_TO_ADDR
21819: GO 22050
21821: LD_INT 19
21823: DOUBLE
21824: EQUAL
21825: IFTRUE 21829
21827: GO 22049
21829: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21830: LD_ADDR_VAR 0 1
21834: PUSH
21835: LD_INT 1
21837: PUSH
21838: LD_INT 2
21840: PUSH
21841: LD_INT 3
21843: PUSH
21844: LD_INT 4
21846: PUSH
21847: LD_INT 5
21849: PUSH
21850: LD_INT 6
21852: PUSH
21853: LD_INT 7
21855: PUSH
21856: LD_INT 8
21858: PUSH
21859: LD_INT 9
21861: PUSH
21862: LD_INT 10
21864: PUSH
21865: LD_INT 11
21867: PUSH
21868: LD_INT 12
21870: PUSH
21871: LD_INT 13
21873: PUSH
21874: LD_INT 14
21876: PUSH
21877: LD_INT 15
21879: PUSH
21880: LD_INT 16
21882: PUSH
21883: LD_INT 17
21885: PUSH
21886: LD_INT 18
21888: PUSH
21889: LD_INT 19
21891: PUSH
21892: LD_INT 20
21894: PUSH
21895: LD_INT 21
21897: PUSH
21898: LD_INT 22
21900: PUSH
21901: LD_INT 23
21903: PUSH
21904: LD_INT 24
21906: PUSH
21907: LD_INT 25
21909: PUSH
21910: LD_INT 26
21912: PUSH
21913: LD_INT 27
21915: PUSH
21916: LD_INT 28
21918: PUSH
21919: LD_INT 29
21921: PUSH
21922: LD_INT 30
21924: PUSH
21925: LD_INT 31
21927: PUSH
21928: LD_INT 32
21930: PUSH
21931: LD_INT 33
21933: PUSH
21934: LD_INT 34
21936: PUSH
21937: LD_INT 35
21939: PUSH
21940: LD_INT 36
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: LIST
21953: LIST
21954: LIST
21955: LIST
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: LIST
21961: LIST
21962: LIST
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: PUSH
21981: LD_INT 101
21983: PUSH
21984: LD_INT 102
21986: PUSH
21987: LD_INT 103
21989: PUSH
21990: LD_INT 104
21992: PUSH
21993: LD_INT 105
21995: PUSH
21996: LD_INT 106
21998: PUSH
21999: LD_INT 107
22001: PUSH
22002: LD_INT 108
22004: PUSH
22005: LD_INT 109
22007: PUSH
22008: LD_INT 110
22010: PUSH
22011: LD_INT 111
22013: PUSH
22014: LD_INT 112
22016: PUSH
22017: LD_INT 113
22019: PUSH
22020: LD_INT 114
22022: PUSH
22023: LD_INT 115
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: LIST
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: ST_TO_ADDR
22047: GO 22050
22049: POP
// end ; if result then
22050: LD_VAR 0 1
22054: IFFALSE 22343
// begin normal :=  ;
22056: LD_ADDR_VAR 0 3
22060: PUSH
22061: LD_STRING 
22063: ST_TO_ADDR
// hardcore :=  ;
22064: LD_ADDR_VAR 0 4
22068: PUSH
22069: LD_STRING 
22071: ST_TO_ADDR
// for i = 1 to normalCounter do
22072: LD_ADDR_VAR 0 5
22076: PUSH
22077: DOUBLE
22078: LD_INT 1
22080: DEC
22081: ST_TO_ADDR
22082: LD_EXP 60
22086: PUSH
22087: FOR_TO
22088: IFFALSE 22189
// begin tmp := 0 ;
22090: LD_ADDR_VAR 0 2
22094: PUSH
22095: LD_STRING 0
22097: ST_TO_ADDR
// if result [ 1 ] then
22098: LD_VAR 0 1
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: IFFALSE 22171
// if result [ 1 ] [ 1 ] = i then
22108: LD_VAR 0 1
22112: PUSH
22113: LD_INT 1
22115: ARRAY
22116: PUSH
22117: LD_INT 1
22119: ARRAY
22120: PUSH
22121: LD_VAR 0 5
22125: EQUAL
22126: IFFALSE 22171
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22128: LD_ADDR_VAR 0 1
22132: PUSH
22133: LD_VAR 0 1
22137: PPUSH
22138: LD_INT 1
22140: PPUSH
22141: LD_VAR 0 1
22145: PUSH
22146: LD_INT 1
22148: ARRAY
22149: PPUSH
22150: LD_INT 1
22152: PPUSH
22153: CALL_OW 3
22157: PPUSH
22158: CALL_OW 1
22162: ST_TO_ADDR
// tmp := 1 ;
22163: LD_ADDR_VAR 0 2
22167: PUSH
22168: LD_STRING 1
22170: ST_TO_ADDR
// end ; normal := normal & tmp ;
22171: LD_ADDR_VAR 0 3
22175: PUSH
22176: LD_VAR 0 3
22180: PUSH
22181: LD_VAR 0 2
22185: STR
22186: ST_TO_ADDR
// end ;
22187: GO 22087
22189: POP
22190: POP
// for i = 1 to hardcoreCounter do
22191: LD_ADDR_VAR 0 5
22195: PUSH
22196: DOUBLE
22197: LD_INT 1
22199: DEC
22200: ST_TO_ADDR
22201: LD_EXP 61
22205: PUSH
22206: FOR_TO
22207: IFFALSE 22312
// begin tmp := 0 ;
22209: LD_ADDR_VAR 0 2
22213: PUSH
22214: LD_STRING 0
22216: ST_TO_ADDR
// if result [ 2 ] then
22217: LD_VAR 0 1
22221: PUSH
22222: LD_INT 2
22224: ARRAY
22225: IFFALSE 22294
// if result [ 2 ] [ 1 ] = 100 + i then
22227: LD_VAR 0 1
22231: PUSH
22232: LD_INT 2
22234: ARRAY
22235: PUSH
22236: LD_INT 1
22238: ARRAY
22239: PUSH
22240: LD_INT 100
22242: PUSH
22243: LD_VAR 0 5
22247: PLUS
22248: EQUAL
22249: IFFALSE 22294
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22251: LD_ADDR_VAR 0 1
22255: PUSH
22256: LD_VAR 0 1
22260: PPUSH
22261: LD_INT 2
22263: PPUSH
22264: LD_VAR 0 1
22268: PUSH
22269: LD_INT 2
22271: ARRAY
22272: PPUSH
22273: LD_INT 1
22275: PPUSH
22276: CALL_OW 3
22280: PPUSH
22281: CALL_OW 1
22285: ST_TO_ADDR
// tmp := 1 ;
22286: LD_ADDR_VAR 0 2
22290: PUSH
22291: LD_STRING 1
22293: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22294: LD_ADDR_VAR 0 4
22298: PUSH
22299: LD_VAR 0 4
22303: PUSH
22304: LD_VAR 0 2
22308: STR
22309: ST_TO_ADDR
// end ;
22310: GO 22206
22312: POP
22313: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22314: LD_STRING getStreamItemsFromMission("
22316: PUSH
22317: LD_VAR 0 3
22321: STR
22322: PUSH
22323: LD_STRING ","
22325: STR
22326: PUSH
22327: LD_VAR 0 4
22331: STR
22332: PUSH
22333: LD_STRING ")
22335: STR
22336: PPUSH
22337: CALL_OW 559
// end else
22341: GO 22350
// ToLua ( getStreamItemsFromMission("","") ) ;
22343: LD_STRING getStreamItemsFromMission("","")
22345: PPUSH
22346: CALL_OW 559
// end ;
22350: LD_VAR 0 1
22354: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22355: LD_VAR 0 2
22359: PUSH
22360: LD_INT 100
22362: EQUAL
22363: IFFALSE 23312
// begin if not StreamModeActive then
22365: LD_EXP 59
22369: NOT
22370: IFFALSE 22380
// StreamModeActive := true ;
22372: LD_ADDR_EXP 59
22376: PUSH
22377: LD_INT 1
22379: ST_TO_ADDR
// if p3 = 0 then
22380: LD_VAR 0 3
22384: PUSH
22385: LD_INT 0
22387: EQUAL
22388: IFFALSE 22394
// InitStreamMode ;
22390: CALL 18640 0 0
// if p3 = 1 then
22394: LD_VAR 0 3
22398: PUSH
22399: LD_INT 1
22401: EQUAL
22402: IFFALSE 22412
// sRocket := true ;
22404: LD_ADDR_EXP 64
22408: PUSH
22409: LD_INT 1
22411: ST_TO_ADDR
// if p3 = 2 then
22412: LD_VAR 0 3
22416: PUSH
22417: LD_INT 2
22419: EQUAL
22420: IFFALSE 22430
// sSpeed := true ;
22422: LD_ADDR_EXP 63
22426: PUSH
22427: LD_INT 1
22429: ST_TO_ADDR
// if p3 = 3 then
22430: LD_VAR 0 3
22434: PUSH
22435: LD_INT 3
22437: EQUAL
22438: IFFALSE 22448
// sEngine := true ;
22440: LD_ADDR_EXP 65
22444: PUSH
22445: LD_INT 1
22447: ST_TO_ADDR
// if p3 = 4 then
22448: LD_VAR 0 3
22452: PUSH
22453: LD_INT 4
22455: EQUAL
22456: IFFALSE 22466
// sSpec := true ;
22458: LD_ADDR_EXP 62
22462: PUSH
22463: LD_INT 1
22465: ST_TO_ADDR
// if p3 = 5 then
22466: LD_VAR 0 3
22470: PUSH
22471: LD_INT 5
22473: EQUAL
22474: IFFALSE 22484
// sLevel := true ;
22476: LD_ADDR_EXP 66
22480: PUSH
22481: LD_INT 1
22483: ST_TO_ADDR
// if p3 = 6 then
22484: LD_VAR 0 3
22488: PUSH
22489: LD_INT 6
22491: EQUAL
22492: IFFALSE 22502
// sArmoury := true ;
22494: LD_ADDR_EXP 67
22498: PUSH
22499: LD_INT 1
22501: ST_TO_ADDR
// if p3 = 7 then
22502: LD_VAR 0 3
22506: PUSH
22507: LD_INT 7
22509: EQUAL
22510: IFFALSE 22520
// sRadar := true ;
22512: LD_ADDR_EXP 68
22516: PUSH
22517: LD_INT 1
22519: ST_TO_ADDR
// if p3 = 8 then
22520: LD_VAR 0 3
22524: PUSH
22525: LD_INT 8
22527: EQUAL
22528: IFFALSE 22538
// sBunker := true ;
22530: LD_ADDR_EXP 69
22534: PUSH
22535: LD_INT 1
22537: ST_TO_ADDR
// if p3 = 9 then
22538: LD_VAR 0 3
22542: PUSH
22543: LD_INT 9
22545: EQUAL
22546: IFFALSE 22556
// sHack := true ;
22548: LD_ADDR_EXP 70
22552: PUSH
22553: LD_INT 1
22555: ST_TO_ADDR
// if p3 = 10 then
22556: LD_VAR 0 3
22560: PUSH
22561: LD_INT 10
22563: EQUAL
22564: IFFALSE 22574
// sFire := true ;
22566: LD_ADDR_EXP 71
22570: PUSH
22571: LD_INT 1
22573: ST_TO_ADDR
// if p3 = 11 then
22574: LD_VAR 0 3
22578: PUSH
22579: LD_INT 11
22581: EQUAL
22582: IFFALSE 22592
// sRefresh := true ;
22584: LD_ADDR_EXP 72
22588: PUSH
22589: LD_INT 1
22591: ST_TO_ADDR
// if p3 = 12 then
22592: LD_VAR 0 3
22596: PUSH
22597: LD_INT 12
22599: EQUAL
22600: IFFALSE 22610
// sExp := true ;
22602: LD_ADDR_EXP 73
22606: PUSH
22607: LD_INT 1
22609: ST_TO_ADDR
// if p3 = 13 then
22610: LD_VAR 0 3
22614: PUSH
22615: LD_INT 13
22617: EQUAL
22618: IFFALSE 22628
// sDepot := true ;
22620: LD_ADDR_EXP 74
22624: PUSH
22625: LD_INT 1
22627: ST_TO_ADDR
// if p3 = 14 then
22628: LD_VAR 0 3
22632: PUSH
22633: LD_INT 14
22635: EQUAL
22636: IFFALSE 22646
// sFlag := true ;
22638: LD_ADDR_EXP 75
22642: PUSH
22643: LD_INT 1
22645: ST_TO_ADDR
// if p3 = 15 then
22646: LD_VAR 0 3
22650: PUSH
22651: LD_INT 15
22653: EQUAL
22654: IFFALSE 22664
// sKamikadze := true ;
22656: LD_ADDR_EXP 83
22660: PUSH
22661: LD_INT 1
22663: ST_TO_ADDR
// if p3 = 16 then
22664: LD_VAR 0 3
22668: PUSH
22669: LD_INT 16
22671: EQUAL
22672: IFFALSE 22682
// sTroll := true ;
22674: LD_ADDR_EXP 84
22678: PUSH
22679: LD_INT 1
22681: ST_TO_ADDR
// if p3 = 17 then
22682: LD_VAR 0 3
22686: PUSH
22687: LD_INT 17
22689: EQUAL
22690: IFFALSE 22700
// sSlow := true ;
22692: LD_ADDR_EXP 85
22696: PUSH
22697: LD_INT 1
22699: ST_TO_ADDR
// if p3 = 18 then
22700: LD_VAR 0 3
22704: PUSH
22705: LD_INT 18
22707: EQUAL
22708: IFFALSE 22718
// sLack := true ;
22710: LD_ADDR_EXP 86
22714: PUSH
22715: LD_INT 1
22717: ST_TO_ADDR
// if p3 = 19 then
22718: LD_VAR 0 3
22722: PUSH
22723: LD_INT 19
22725: EQUAL
22726: IFFALSE 22736
// sTank := true ;
22728: LD_ADDR_EXP 88
22732: PUSH
22733: LD_INT 1
22735: ST_TO_ADDR
// if p3 = 20 then
22736: LD_VAR 0 3
22740: PUSH
22741: LD_INT 20
22743: EQUAL
22744: IFFALSE 22754
// sRemote := true ;
22746: LD_ADDR_EXP 89
22750: PUSH
22751: LD_INT 1
22753: ST_TO_ADDR
// if p3 = 21 then
22754: LD_VAR 0 3
22758: PUSH
22759: LD_INT 21
22761: EQUAL
22762: IFFALSE 22772
// sPowell := true ;
22764: LD_ADDR_EXP 90
22768: PUSH
22769: LD_INT 1
22771: ST_TO_ADDR
// if p3 = 22 then
22772: LD_VAR 0 3
22776: PUSH
22777: LD_INT 22
22779: EQUAL
22780: IFFALSE 22790
// sTeleport := true ;
22782: LD_ADDR_EXP 93
22786: PUSH
22787: LD_INT 1
22789: ST_TO_ADDR
// if p3 = 23 then
22790: LD_VAR 0 3
22794: PUSH
22795: LD_INT 23
22797: EQUAL
22798: IFFALSE 22808
// sOilTower := true ;
22800: LD_ADDR_EXP 95
22804: PUSH
22805: LD_INT 1
22807: ST_TO_ADDR
// if p3 = 24 then
22808: LD_VAR 0 3
22812: PUSH
22813: LD_INT 24
22815: EQUAL
22816: IFFALSE 22826
// sShovel := true ;
22818: LD_ADDR_EXP 96
22822: PUSH
22823: LD_INT 1
22825: ST_TO_ADDR
// if p3 = 25 then
22826: LD_VAR 0 3
22830: PUSH
22831: LD_INT 25
22833: EQUAL
22834: IFFALSE 22844
// sSheik := true ;
22836: LD_ADDR_EXP 97
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
// if p3 = 26 then
22844: LD_VAR 0 3
22848: PUSH
22849: LD_INT 26
22851: EQUAL
22852: IFFALSE 22862
// sEarthquake := true ;
22854: LD_ADDR_EXP 99
22858: PUSH
22859: LD_INT 1
22861: ST_TO_ADDR
// if p3 = 27 then
22862: LD_VAR 0 3
22866: PUSH
22867: LD_INT 27
22869: EQUAL
22870: IFFALSE 22880
// sAI := true ;
22872: LD_ADDR_EXP 100
22876: PUSH
22877: LD_INT 1
22879: ST_TO_ADDR
// if p3 = 28 then
22880: LD_VAR 0 3
22884: PUSH
22885: LD_INT 28
22887: EQUAL
22888: IFFALSE 22898
// sCargo := true ;
22890: LD_ADDR_EXP 103
22894: PUSH
22895: LD_INT 1
22897: ST_TO_ADDR
// if p3 = 29 then
22898: LD_VAR 0 3
22902: PUSH
22903: LD_INT 29
22905: EQUAL
22906: IFFALSE 22916
// sDLaser := true ;
22908: LD_ADDR_EXP 104
22912: PUSH
22913: LD_INT 1
22915: ST_TO_ADDR
// if p3 = 30 then
22916: LD_VAR 0 3
22920: PUSH
22921: LD_INT 30
22923: EQUAL
22924: IFFALSE 22934
// sExchange := true ;
22926: LD_ADDR_EXP 105
22930: PUSH
22931: LD_INT 1
22933: ST_TO_ADDR
// if p3 = 31 then
22934: LD_VAR 0 3
22938: PUSH
22939: LD_INT 31
22941: EQUAL
22942: IFFALSE 22952
// sFac := true ;
22944: LD_ADDR_EXP 106
22948: PUSH
22949: LD_INT 1
22951: ST_TO_ADDR
// if p3 = 32 then
22952: LD_VAR 0 3
22956: PUSH
22957: LD_INT 32
22959: EQUAL
22960: IFFALSE 22970
// sPower := true ;
22962: LD_ADDR_EXP 107
22966: PUSH
22967: LD_INT 1
22969: ST_TO_ADDR
// if p3 = 33 then
22970: LD_VAR 0 3
22974: PUSH
22975: LD_INT 33
22977: EQUAL
22978: IFFALSE 22988
// sRandom := true ;
22980: LD_ADDR_EXP 108
22984: PUSH
22985: LD_INT 1
22987: ST_TO_ADDR
// if p3 = 34 then
22988: LD_VAR 0 3
22992: PUSH
22993: LD_INT 34
22995: EQUAL
22996: IFFALSE 23006
// sShield := true ;
22998: LD_ADDR_EXP 109
23002: PUSH
23003: LD_INT 1
23005: ST_TO_ADDR
// if p3 = 35 then
23006: LD_VAR 0 3
23010: PUSH
23011: LD_INT 35
23013: EQUAL
23014: IFFALSE 23024
// sTime := true ;
23016: LD_ADDR_EXP 110
23020: PUSH
23021: LD_INT 1
23023: ST_TO_ADDR
// if p3 = 36 then
23024: LD_VAR 0 3
23028: PUSH
23029: LD_INT 36
23031: EQUAL
23032: IFFALSE 23042
// sTools := true ;
23034: LD_ADDR_EXP 111
23038: PUSH
23039: LD_INT 1
23041: ST_TO_ADDR
// if p3 = 101 then
23042: LD_VAR 0 3
23046: PUSH
23047: LD_INT 101
23049: EQUAL
23050: IFFALSE 23060
// sSold := true ;
23052: LD_ADDR_EXP 76
23056: PUSH
23057: LD_INT 1
23059: ST_TO_ADDR
// if p3 = 102 then
23060: LD_VAR 0 3
23064: PUSH
23065: LD_INT 102
23067: EQUAL
23068: IFFALSE 23078
// sDiff := true ;
23070: LD_ADDR_EXP 77
23074: PUSH
23075: LD_INT 1
23077: ST_TO_ADDR
// if p3 = 103 then
23078: LD_VAR 0 3
23082: PUSH
23083: LD_INT 103
23085: EQUAL
23086: IFFALSE 23096
// sFog := true ;
23088: LD_ADDR_EXP 80
23092: PUSH
23093: LD_INT 1
23095: ST_TO_ADDR
// if p3 = 104 then
23096: LD_VAR 0 3
23100: PUSH
23101: LD_INT 104
23103: EQUAL
23104: IFFALSE 23114
// sReset := true ;
23106: LD_ADDR_EXP 81
23110: PUSH
23111: LD_INT 1
23113: ST_TO_ADDR
// if p3 = 105 then
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 105
23121: EQUAL
23122: IFFALSE 23132
// sSun := true ;
23124: LD_ADDR_EXP 82
23128: PUSH
23129: LD_INT 1
23131: ST_TO_ADDR
// if p3 = 106 then
23132: LD_VAR 0 3
23136: PUSH
23137: LD_INT 106
23139: EQUAL
23140: IFFALSE 23150
// sTiger := true ;
23142: LD_ADDR_EXP 78
23146: PUSH
23147: LD_INT 1
23149: ST_TO_ADDR
// if p3 = 107 then
23150: LD_VAR 0 3
23154: PUSH
23155: LD_INT 107
23157: EQUAL
23158: IFFALSE 23168
// sBomb := true ;
23160: LD_ADDR_EXP 79
23164: PUSH
23165: LD_INT 1
23167: ST_TO_ADDR
// if p3 = 108 then
23168: LD_VAR 0 3
23172: PUSH
23173: LD_INT 108
23175: EQUAL
23176: IFFALSE 23186
// sWound := true ;
23178: LD_ADDR_EXP 87
23182: PUSH
23183: LD_INT 1
23185: ST_TO_ADDR
// if p3 = 109 then
23186: LD_VAR 0 3
23190: PUSH
23191: LD_INT 109
23193: EQUAL
23194: IFFALSE 23204
// sBetray := true ;
23196: LD_ADDR_EXP 91
23200: PUSH
23201: LD_INT 1
23203: ST_TO_ADDR
// if p3 = 110 then
23204: LD_VAR 0 3
23208: PUSH
23209: LD_INT 110
23211: EQUAL
23212: IFFALSE 23222
// sContamin := true ;
23214: LD_ADDR_EXP 92
23218: PUSH
23219: LD_INT 1
23221: ST_TO_ADDR
// if p3 = 111 then
23222: LD_VAR 0 3
23226: PUSH
23227: LD_INT 111
23229: EQUAL
23230: IFFALSE 23240
// sOil := true ;
23232: LD_ADDR_EXP 94
23236: PUSH
23237: LD_INT 1
23239: ST_TO_ADDR
// if p3 = 112 then
23240: LD_VAR 0 3
23244: PUSH
23245: LD_INT 112
23247: EQUAL
23248: IFFALSE 23258
// sStu := true ;
23250: LD_ADDR_EXP 98
23254: PUSH
23255: LD_INT 1
23257: ST_TO_ADDR
// if p3 = 113 then
23258: LD_VAR 0 3
23262: PUSH
23263: LD_INT 113
23265: EQUAL
23266: IFFALSE 23276
// sBazooka := true ;
23268: LD_ADDR_EXP 101
23272: PUSH
23273: LD_INT 1
23275: ST_TO_ADDR
// if p3 = 114 then
23276: LD_VAR 0 3
23280: PUSH
23281: LD_INT 114
23283: EQUAL
23284: IFFALSE 23294
// sMortar := true ;
23286: LD_ADDR_EXP 102
23290: PUSH
23291: LD_INT 1
23293: ST_TO_ADDR
// if p3 = 115 then
23294: LD_VAR 0 3
23298: PUSH
23299: LD_INT 115
23301: EQUAL
23302: IFFALSE 23312
// sRanger := true ;
23304: LD_ADDR_EXP 112
23308: PUSH
23309: LD_INT 1
23311: ST_TO_ADDR
// end ; end ;
23312: PPOPN 6
23314: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23315: LD_EXP 59
23319: PUSH
23320: LD_EXP 64
23324: AND
23325: IFFALSE 23449
23327: GO 23329
23329: DISABLE
23330: LD_INT 0
23332: PPUSH
23333: PPUSH
// begin enable ;
23334: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23335: LD_ADDR_VAR 0 2
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_OWVAR 2
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: PUSH
23352: LD_INT 2
23354: PUSH
23355: LD_INT 34
23357: PUSH
23358: LD_INT 7
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 34
23367: PUSH
23368: LD_INT 45
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: LD_INT 34
23377: PUSH
23378: LD_INT 28
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: PUSH
23385: LD_INT 34
23387: PUSH
23388: LD_INT 47
23390: PUSH
23391: EMPTY
23392: LIST
23393: LIST
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: LIST
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PPUSH
23406: CALL_OW 69
23410: ST_TO_ADDR
// if not tmp then
23411: LD_VAR 0 2
23415: NOT
23416: IFFALSE 23420
// exit ;
23418: GO 23449
// for i in tmp do
23420: LD_ADDR_VAR 0 1
23424: PUSH
23425: LD_VAR 0 2
23429: PUSH
23430: FOR_IN
23431: IFFALSE 23447
// begin SetLives ( i , 0 ) ;
23433: LD_VAR 0 1
23437: PPUSH
23438: LD_INT 0
23440: PPUSH
23441: CALL_OW 234
// end ;
23445: GO 23430
23447: POP
23448: POP
// end ;
23449: PPOPN 2
23451: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23452: LD_EXP 59
23456: PUSH
23457: LD_EXP 65
23461: AND
23462: IFFALSE 23546
23464: GO 23466
23466: DISABLE
23467: LD_INT 0
23469: PPUSH
23470: PPUSH
// begin enable ;
23471: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23472: LD_ADDR_VAR 0 2
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_OWVAR 2
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 32
23491: PUSH
23492: LD_INT 3
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: PPUSH
23503: CALL_OW 69
23507: ST_TO_ADDR
// if not tmp then
23508: LD_VAR 0 2
23512: NOT
23513: IFFALSE 23517
// exit ;
23515: GO 23546
// for i in tmp do
23517: LD_ADDR_VAR 0 1
23521: PUSH
23522: LD_VAR 0 2
23526: PUSH
23527: FOR_IN
23528: IFFALSE 23544
// begin SetLives ( i , 0 ) ;
23530: LD_VAR 0 1
23534: PPUSH
23535: LD_INT 0
23537: PPUSH
23538: CALL_OW 234
// end ;
23542: GO 23527
23544: POP
23545: POP
// end ;
23546: PPOPN 2
23548: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23549: LD_EXP 59
23553: PUSH
23554: LD_EXP 62
23558: AND
23559: IFFALSE 23652
23561: GO 23563
23563: DISABLE
23564: LD_INT 0
23566: PPUSH
// begin enable ;
23567: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23568: LD_ADDR_VAR 0 1
23572: PUSH
23573: LD_INT 22
23575: PUSH
23576: LD_OWVAR 2
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 2
23587: PUSH
23588: LD_INT 25
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: PUSH
23598: LD_INT 25
23600: PUSH
23601: LD_INT 9
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 25
23610: PUSH
23611: LD_INT 8
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: LIST
23622: LIST
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PPUSH
23628: CALL_OW 69
23632: PUSH
23633: FOR_IN
23634: IFFALSE 23650
// begin SetClass ( i , 1 ) ;
23636: LD_VAR 0 1
23640: PPUSH
23641: LD_INT 1
23643: PPUSH
23644: CALL_OW 336
// end ;
23648: GO 23633
23650: POP
23651: POP
// end ;
23652: PPOPN 1
23654: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23655: LD_EXP 59
23659: PUSH
23660: LD_EXP 63
23664: AND
23665: PUSH
23666: LD_OWVAR 65
23670: PUSH
23671: LD_INT 7
23673: LESS
23674: AND
23675: IFFALSE 23689
23677: GO 23679
23679: DISABLE
// begin enable ;
23680: ENABLE
// game_speed := 7 ;
23681: LD_ADDR_OWVAR 65
23685: PUSH
23686: LD_INT 7
23688: ST_TO_ADDR
// end ;
23689: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23690: LD_EXP 59
23694: PUSH
23695: LD_EXP 66
23699: AND
23700: IFFALSE 23902
23702: GO 23704
23704: DISABLE
23705: LD_INT 0
23707: PPUSH
23708: PPUSH
23709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23710: LD_ADDR_VAR 0 3
23714: PUSH
23715: LD_INT 81
23717: PUSH
23718: LD_OWVAR 2
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PUSH
23727: LD_INT 21
23729: PUSH
23730: LD_INT 1
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: PPUSH
23741: CALL_OW 69
23745: ST_TO_ADDR
// if not tmp then
23746: LD_VAR 0 3
23750: NOT
23751: IFFALSE 23755
// exit ;
23753: GO 23902
// if tmp > 5 then
23755: LD_VAR 0 3
23759: PUSH
23760: LD_INT 5
23762: GREATER
23763: IFFALSE 23775
// k := 5 else
23765: LD_ADDR_VAR 0 2
23769: PUSH
23770: LD_INT 5
23772: ST_TO_ADDR
23773: GO 23785
// k := tmp ;
23775: LD_ADDR_VAR 0 2
23779: PUSH
23780: LD_VAR 0 3
23784: ST_TO_ADDR
// for i := 1 to k do
23785: LD_ADDR_VAR 0 1
23789: PUSH
23790: DOUBLE
23791: LD_INT 1
23793: DEC
23794: ST_TO_ADDR
23795: LD_VAR 0 2
23799: PUSH
23800: FOR_TO
23801: IFFALSE 23900
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23803: LD_VAR 0 3
23807: PUSH
23808: LD_VAR 0 1
23812: ARRAY
23813: PPUSH
23814: LD_VAR 0 1
23818: PUSH
23819: LD_INT 4
23821: MOD
23822: PUSH
23823: LD_INT 1
23825: PLUS
23826: PPUSH
23827: CALL_OW 259
23831: PUSH
23832: LD_INT 10
23834: LESS
23835: IFFALSE 23898
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23837: LD_VAR 0 3
23841: PUSH
23842: LD_VAR 0 1
23846: ARRAY
23847: PPUSH
23848: LD_VAR 0 1
23852: PUSH
23853: LD_INT 4
23855: MOD
23856: PUSH
23857: LD_INT 1
23859: PLUS
23860: PPUSH
23861: LD_VAR 0 3
23865: PUSH
23866: LD_VAR 0 1
23870: ARRAY
23871: PPUSH
23872: LD_VAR 0 1
23876: PUSH
23877: LD_INT 4
23879: MOD
23880: PUSH
23881: LD_INT 1
23883: PLUS
23884: PPUSH
23885: CALL_OW 259
23889: PUSH
23890: LD_INT 1
23892: PLUS
23893: PPUSH
23894: CALL_OW 237
23898: GO 23800
23900: POP
23901: POP
// end ;
23902: PPOPN 3
23904: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23905: LD_EXP 59
23909: PUSH
23910: LD_EXP 67
23914: AND
23915: IFFALSE 23935
23917: GO 23919
23919: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23920: LD_INT 4
23922: PPUSH
23923: LD_OWVAR 2
23927: PPUSH
23928: LD_INT 0
23930: PPUSH
23931: CALL_OW 324
23935: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23936: LD_EXP 59
23940: PUSH
23941: LD_EXP 96
23945: AND
23946: IFFALSE 23966
23948: GO 23950
23950: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23951: LD_INT 19
23953: PPUSH
23954: LD_OWVAR 2
23958: PPUSH
23959: LD_INT 0
23961: PPUSH
23962: CALL_OW 324
23966: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23967: LD_EXP 59
23971: PUSH
23972: LD_EXP 68
23976: AND
23977: IFFALSE 24079
23979: GO 23981
23981: DISABLE
23982: LD_INT 0
23984: PPUSH
23985: PPUSH
// begin enable ;
23986: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23987: LD_ADDR_VAR 0 2
23991: PUSH
23992: LD_INT 22
23994: PUSH
23995: LD_OWVAR 2
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 2
24006: PUSH
24007: LD_INT 34
24009: PUSH
24010: LD_INT 11
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: PUSH
24017: LD_INT 34
24019: PUSH
24020: LD_INT 30
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: PPUSH
24036: CALL_OW 69
24040: ST_TO_ADDR
// if not tmp then
24041: LD_VAR 0 2
24045: NOT
24046: IFFALSE 24050
// exit ;
24048: GO 24079
// for i in tmp do
24050: LD_ADDR_VAR 0 1
24054: PUSH
24055: LD_VAR 0 2
24059: PUSH
24060: FOR_IN
24061: IFFALSE 24077
// begin SetLives ( i , 0 ) ;
24063: LD_VAR 0 1
24067: PPUSH
24068: LD_INT 0
24070: PPUSH
24071: CALL_OW 234
// end ;
24075: GO 24060
24077: POP
24078: POP
// end ;
24079: PPOPN 2
24081: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24082: LD_EXP 59
24086: PUSH
24087: LD_EXP 69
24091: AND
24092: IFFALSE 24112
24094: GO 24096
24096: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24097: LD_INT 32
24099: PPUSH
24100: LD_OWVAR 2
24104: PPUSH
24105: LD_INT 0
24107: PPUSH
24108: CALL_OW 324
24112: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24113: LD_EXP 59
24117: PUSH
24118: LD_EXP 70
24122: AND
24123: IFFALSE 24304
24125: GO 24127
24127: DISABLE
24128: LD_INT 0
24130: PPUSH
24131: PPUSH
24132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24133: LD_ADDR_VAR 0 2
24137: PUSH
24138: LD_INT 22
24140: PUSH
24141: LD_OWVAR 2
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 33
24152: PUSH
24153: LD_INT 3
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PPUSH
24164: CALL_OW 69
24168: ST_TO_ADDR
// if not tmp then
24169: LD_VAR 0 2
24173: NOT
24174: IFFALSE 24178
// exit ;
24176: GO 24304
// side := 0 ;
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 0
24185: ST_TO_ADDR
// for i := 1 to 8 do
24186: LD_ADDR_VAR 0 1
24190: PUSH
24191: DOUBLE
24192: LD_INT 1
24194: DEC
24195: ST_TO_ADDR
24196: LD_INT 8
24198: PUSH
24199: FOR_TO
24200: IFFALSE 24248
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24202: LD_OWVAR 2
24206: PUSH
24207: LD_VAR 0 1
24211: NONEQUAL
24212: PUSH
24213: LD_OWVAR 2
24217: PPUSH
24218: LD_VAR 0 1
24222: PPUSH
24223: CALL_OW 81
24227: PUSH
24228: LD_INT 2
24230: EQUAL
24231: AND
24232: IFFALSE 24246
// begin side := i ;
24234: LD_ADDR_VAR 0 3
24238: PUSH
24239: LD_VAR 0 1
24243: ST_TO_ADDR
// break ;
24244: GO 24248
// end ;
24246: GO 24199
24248: POP
24249: POP
// if not side then
24250: LD_VAR 0 3
24254: NOT
24255: IFFALSE 24259
// exit ;
24257: GO 24304
// for i := 1 to tmp do
24259: LD_ADDR_VAR 0 1
24263: PUSH
24264: DOUBLE
24265: LD_INT 1
24267: DEC
24268: ST_TO_ADDR
24269: LD_VAR 0 2
24273: PUSH
24274: FOR_TO
24275: IFFALSE 24302
// if Prob ( 30 ) then
24277: LD_INT 30
24279: PPUSH
24280: CALL_OW 13
24284: IFFALSE 24300
// SetSide ( i , side ) ;
24286: LD_VAR 0 1
24290: PPUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 235
24300: GO 24274
24302: POP
24303: POP
// end ;
24304: PPOPN 3
24306: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24307: LD_EXP 59
24311: PUSH
24312: LD_EXP 72
24316: AND
24317: IFFALSE 24436
24319: GO 24321
24321: DISABLE
24322: LD_INT 0
24324: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24325: LD_ADDR_VAR 0 1
24329: PUSH
24330: LD_INT 22
24332: PUSH
24333: LD_OWVAR 2
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: LD_INT 21
24344: PUSH
24345: LD_INT 1
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: PUSH
24352: LD_INT 3
24354: PUSH
24355: LD_INT 23
24357: PUSH
24358: LD_INT 0
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: LIST
24373: PPUSH
24374: CALL_OW 69
24378: PUSH
24379: FOR_IN
24380: IFFALSE 24434
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24382: LD_VAR 0 1
24386: PPUSH
24387: CALL_OW 257
24391: PUSH
24392: LD_INT 1
24394: PUSH
24395: LD_INT 2
24397: PUSH
24398: LD_INT 3
24400: PUSH
24401: LD_INT 4
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: LIST
24408: LIST
24409: IN
24410: IFFALSE 24432
// SetClass ( un , rand ( 1 , 4 ) ) ;
24412: LD_VAR 0 1
24416: PPUSH
24417: LD_INT 1
24419: PPUSH
24420: LD_INT 4
24422: PPUSH
24423: CALL_OW 12
24427: PPUSH
24428: CALL_OW 336
24432: GO 24379
24434: POP
24435: POP
// end ;
24436: PPOPN 1
24438: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24439: LD_EXP 59
24443: PUSH
24444: LD_EXP 71
24448: AND
24449: IFFALSE 24528
24451: GO 24453
24453: DISABLE
24454: LD_INT 0
24456: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24457: LD_ADDR_VAR 0 1
24461: PUSH
24462: LD_INT 22
24464: PUSH
24465: LD_OWVAR 2
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 21
24476: PUSH
24477: LD_INT 3
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PPUSH
24488: CALL_OW 69
24492: ST_TO_ADDR
// if not tmp then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24502
// exit ;
24500: GO 24528
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24502: LD_VAR 0 1
24506: PUSH
24507: LD_INT 1
24509: PPUSH
24510: LD_VAR 0 1
24514: PPUSH
24515: CALL_OW 12
24519: ARRAY
24520: PPUSH
24521: LD_INT 100
24523: PPUSH
24524: CALL_OW 234
// end ;
24528: PPOPN 1
24530: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24531: LD_EXP 59
24535: PUSH
24536: LD_EXP 73
24540: AND
24541: IFFALSE 24639
24543: GO 24545
24545: DISABLE
24546: LD_INT 0
24548: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24549: LD_ADDR_VAR 0 1
24553: PUSH
24554: LD_INT 22
24556: PUSH
24557: LD_OWVAR 2
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: LD_INT 21
24568: PUSH
24569: LD_INT 1
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PPUSH
24580: CALL_OW 69
24584: ST_TO_ADDR
// if not tmp then
24585: LD_VAR 0 1
24589: NOT
24590: IFFALSE 24594
// exit ;
24592: GO 24639
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24594: LD_VAR 0 1
24598: PUSH
24599: LD_INT 1
24601: PPUSH
24602: LD_VAR 0 1
24606: PPUSH
24607: CALL_OW 12
24611: ARRAY
24612: PPUSH
24613: LD_INT 1
24615: PPUSH
24616: LD_INT 4
24618: PPUSH
24619: CALL_OW 12
24623: PPUSH
24624: LD_INT 3000
24626: PPUSH
24627: LD_INT 9000
24629: PPUSH
24630: CALL_OW 12
24634: PPUSH
24635: CALL_OW 492
// end ;
24639: PPOPN 1
24641: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24642: LD_EXP 59
24646: PUSH
24647: LD_EXP 74
24651: AND
24652: IFFALSE 24672
24654: GO 24656
24656: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24657: LD_INT 1
24659: PPUSH
24660: LD_OWVAR 2
24664: PPUSH
24665: LD_INT 0
24667: PPUSH
24668: CALL_OW 324
24672: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24673: LD_EXP 59
24677: PUSH
24678: LD_EXP 75
24682: AND
24683: IFFALSE 24766
24685: GO 24687
24687: DISABLE
24688: LD_INT 0
24690: PPUSH
24691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24692: LD_ADDR_VAR 0 2
24696: PUSH
24697: LD_INT 22
24699: PUSH
24700: LD_OWVAR 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 21
24711: PUSH
24712: LD_INT 3
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PPUSH
24723: CALL_OW 69
24727: ST_TO_ADDR
// if not tmp then
24728: LD_VAR 0 2
24732: NOT
24733: IFFALSE 24737
// exit ;
24735: GO 24766
// for i in tmp do
24737: LD_ADDR_VAR 0 1
24741: PUSH
24742: LD_VAR 0 2
24746: PUSH
24747: FOR_IN
24748: IFFALSE 24764
// SetBLevel ( i , 10 ) ;
24750: LD_VAR 0 1
24754: PPUSH
24755: LD_INT 10
24757: PPUSH
24758: CALL_OW 241
24762: GO 24747
24764: POP
24765: POP
// end ;
24766: PPOPN 2
24768: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24769: LD_EXP 59
24773: PUSH
24774: LD_EXP 76
24778: AND
24779: IFFALSE 24890
24781: GO 24783
24783: DISABLE
24784: LD_INT 0
24786: PPUSH
24787: PPUSH
24788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24789: LD_ADDR_VAR 0 3
24793: PUSH
24794: LD_INT 22
24796: PUSH
24797: LD_OWVAR 2
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: LD_INT 25
24808: PUSH
24809: LD_INT 1
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 69
24824: ST_TO_ADDR
// if not tmp then
24825: LD_VAR 0 3
24829: NOT
24830: IFFALSE 24834
// exit ;
24832: GO 24890
// un := tmp [ rand ( 1 , tmp ) ] ;
24834: LD_ADDR_VAR 0 2
24838: PUSH
24839: LD_VAR 0 3
24843: PUSH
24844: LD_INT 1
24846: PPUSH
24847: LD_VAR 0 3
24851: PPUSH
24852: CALL_OW 12
24856: ARRAY
24857: ST_TO_ADDR
// if Crawls ( un ) then
24858: LD_VAR 0 2
24862: PPUSH
24863: CALL_OW 318
24867: IFFALSE 24878
// ComWalk ( un ) ;
24869: LD_VAR 0 2
24873: PPUSH
24874: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24878: LD_VAR 0 2
24882: PPUSH
24883: LD_INT 5
24885: PPUSH
24886: CALL_OW 336
// end ;
24890: PPOPN 3
24892: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24893: LD_EXP 59
24897: PUSH
24898: LD_EXP 77
24902: AND
24903: PUSH
24904: LD_OWVAR 67
24908: PUSH
24909: LD_INT 3
24911: LESS
24912: AND
24913: IFFALSE 24932
24915: GO 24917
24917: DISABLE
// Difficulty := Difficulty + 1 ;
24918: LD_ADDR_OWVAR 67
24922: PUSH
24923: LD_OWVAR 67
24927: PUSH
24928: LD_INT 1
24930: PLUS
24931: ST_TO_ADDR
24932: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24933: LD_EXP 59
24937: PUSH
24938: LD_EXP 78
24942: AND
24943: IFFALSE 25046
24945: GO 24947
24947: DISABLE
24948: LD_INT 0
24950: PPUSH
// begin for i := 1 to 5 do
24951: LD_ADDR_VAR 0 1
24955: PUSH
24956: DOUBLE
24957: LD_INT 1
24959: DEC
24960: ST_TO_ADDR
24961: LD_INT 5
24963: PUSH
24964: FOR_TO
24965: IFFALSE 25044
// begin uc_nation := nation_nature ;
24967: LD_ADDR_OWVAR 21
24971: PUSH
24972: LD_INT 0
24974: ST_TO_ADDR
// uc_side := 0 ;
24975: LD_ADDR_OWVAR 20
24979: PUSH
24980: LD_INT 0
24982: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24983: LD_ADDR_OWVAR 29
24987: PUSH
24988: LD_INT 12
24990: PUSH
24991: LD_INT 12
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: ST_TO_ADDR
// hc_agressivity := 20 ;
24998: LD_ADDR_OWVAR 35
25002: PUSH
25003: LD_INT 20
25005: ST_TO_ADDR
// hc_class := class_tiger ;
25006: LD_ADDR_OWVAR 28
25010: PUSH
25011: LD_INT 14
25013: ST_TO_ADDR
// hc_gallery :=  ;
25014: LD_ADDR_OWVAR 33
25018: PUSH
25019: LD_STRING 
25021: ST_TO_ADDR
// hc_name :=  ;
25022: LD_ADDR_OWVAR 26
25026: PUSH
25027: LD_STRING 
25029: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25030: CALL_OW 44
25034: PPUSH
25035: LD_INT 0
25037: PPUSH
25038: CALL_OW 51
// end ;
25042: GO 24964
25044: POP
25045: POP
// end ;
25046: PPOPN 1
25048: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25049: LD_EXP 59
25053: PUSH
25054: LD_EXP 79
25058: AND
25059: IFFALSE 25068
25061: GO 25063
25063: DISABLE
// StreamSibBomb ;
25064: CALL 25069 0 0
25068: END
// export function StreamSibBomb ; var i , x , y ; begin
25069: LD_INT 0
25071: PPUSH
25072: PPUSH
25073: PPUSH
25074: PPUSH
// result := false ;
25075: LD_ADDR_VAR 0 1
25079: PUSH
25080: LD_INT 0
25082: ST_TO_ADDR
// for i := 1 to 16 do
25083: LD_ADDR_VAR 0 2
25087: PUSH
25088: DOUBLE
25089: LD_INT 1
25091: DEC
25092: ST_TO_ADDR
25093: LD_INT 16
25095: PUSH
25096: FOR_TO
25097: IFFALSE 25296
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25099: LD_ADDR_VAR 0 3
25103: PUSH
25104: LD_INT 10
25106: PUSH
25107: LD_INT 20
25109: PUSH
25110: LD_INT 30
25112: PUSH
25113: LD_INT 40
25115: PUSH
25116: LD_INT 50
25118: PUSH
25119: LD_INT 60
25121: PUSH
25122: LD_INT 70
25124: PUSH
25125: LD_INT 80
25127: PUSH
25128: LD_INT 90
25130: PUSH
25131: LD_INT 100
25133: PUSH
25134: LD_INT 110
25136: PUSH
25137: LD_INT 120
25139: PUSH
25140: LD_INT 130
25142: PUSH
25143: LD_INT 140
25145: PUSH
25146: LD_INT 150
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: LIST
25153: LIST
25154: LIST
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: LIST
25160: LIST
25161: LIST
25162: LIST
25163: LIST
25164: LIST
25165: PUSH
25166: LD_INT 1
25168: PPUSH
25169: LD_INT 15
25171: PPUSH
25172: CALL_OW 12
25176: ARRAY
25177: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25178: LD_ADDR_VAR 0 4
25182: PUSH
25183: LD_INT 10
25185: PUSH
25186: LD_INT 20
25188: PUSH
25189: LD_INT 30
25191: PUSH
25192: LD_INT 40
25194: PUSH
25195: LD_INT 50
25197: PUSH
25198: LD_INT 60
25200: PUSH
25201: LD_INT 70
25203: PUSH
25204: LD_INT 80
25206: PUSH
25207: LD_INT 90
25209: PUSH
25210: LD_INT 100
25212: PUSH
25213: LD_INT 110
25215: PUSH
25216: LD_INT 120
25218: PUSH
25219: LD_INT 130
25221: PUSH
25222: LD_INT 140
25224: PUSH
25225: LD_INT 150
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: PUSH
25245: LD_INT 1
25247: PPUSH
25248: LD_INT 15
25250: PPUSH
25251: CALL_OW 12
25255: ARRAY
25256: ST_TO_ADDR
// if ValidHex ( x , y ) then
25257: LD_VAR 0 3
25261: PPUSH
25262: LD_VAR 0 4
25266: PPUSH
25267: CALL_OW 488
25271: IFFALSE 25294
// begin result := [ x , y ] ;
25273: LD_ADDR_VAR 0 1
25277: PUSH
25278: LD_VAR 0 3
25282: PUSH
25283: LD_VAR 0 4
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: ST_TO_ADDR
// break ;
25292: GO 25296
// end ; end ;
25294: GO 25096
25296: POP
25297: POP
// if result then
25298: LD_VAR 0 1
25302: IFFALSE 25362
// begin ToLua ( playSibBomb() ) ;
25304: LD_STRING playSibBomb()
25306: PPUSH
25307: CALL_OW 559
// wait ( 0 0$14 ) ;
25311: LD_INT 490
25313: PPUSH
25314: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25318: LD_VAR 0 1
25322: PUSH
25323: LD_INT 1
25325: ARRAY
25326: PPUSH
25327: LD_VAR 0 1
25331: PUSH
25332: LD_INT 2
25334: ARRAY
25335: PPUSH
25336: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25340: LD_VAR 0 1
25344: PUSH
25345: LD_INT 1
25347: ARRAY
25348: PPUSH
25349: LD_VAR 0 1
25353: PUSH
25354: LD_INT 2
25356: ARRAY
25357: PPUSH
25358: CALL_OW 429
// end ; end ;
25362: LD_VAR 0 1
25366: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25367: LD_EXP 59
25371: PUSH
25372: LD_EXP 81
25376: AND
25377: IFFALSE 25389
25379: GO 25381
25381: DISABLE
// YouLost (  ) ;
25382: LD_STRING 
25384: PPUSH
25385: CALL_OW 104
25389: END
// every 0 0$1 trigger StreamModeActive and sFog do
25390: LD_EXP 59
25394: PUSH
25395: LD_EXP 80
25399: AND
25400: IFFALSE 25414
25402: GO 25404
25404: DISABLE
// FogOff ( your_side ) ;
25405: LD_OWVAR 2
25409: PPUSH
25410: CALL_OW 344
25414: END
// every 0 0$1 trigger StreamModeActive and sSun do
25415: LD_EXP 59
25419: PUSH
25420: LD_EXP 82
25424: AND
25425: IFFALSE 25453
25427: GO 25429
25429: DISABLE
// begin solar_recharge_percent := 0 ;
25430: LD_ADDR_OWVAR 79
25434: PUSH
25435: LD_INT 0
25437: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25438: LD_INT 10500
25440: PPUSH
25441: CALL_OW 67
// solar_recharge_percent := 100 ;
25445: LD_ADDR_OWVAR 79
25449: PUSH
25450: LD_INT 100
25452: ST_TO_ADDR
// end ;
25453: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25454: LD_EXP 59
25458: PUSH
25459: LD_EXP 83
25463: AND
25464: IFFALSE 25703
25466: GO 25468
25468: DISABLE
25469: LD_INT 0
25471: PPUSH
25472: PPUSH
25473: PPUSH
// begin tmp := [ ] ;
25474: LD_ADDR_VAR 0 3
25478: PUSH
25479: EMPTY
25480: ST_TO_ADDR
// for i := 1 to 6 do
25481: LD_ADDR_VAR 0 1
25485: PUSH
25486: DOUBLE
25487: LD_INT 1
25489: DEC
25490: ST_TO_ADDR
25491: LD_INT 6
25493: PUSH
25494: FOR_TO
25495: IFFALSE 25600
// begin uc_nation := nation_nature ;
25497: LD_ADDR_OWVAR 21
25501: PUSH
25502: LD_INT 0
25504: ST_TO_ADDR
// uc_side := 0 ;
25505: LD_ADDR_OWVAR 20
25509: PUSH
25510: LD_INT 0
25512: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25513: LD_ADDR_OWVAR 29
25517: PUSH
25518: LD_INT 12
25520: PUSH
25521: LD_INT 12
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: ST_TO_ADDR
// hc_agressivity := 20 ;
25528: LD_ADDR_OWVAR 35
25532: PUSH
25533: LD_INT 20
25535: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25536: LD_ADDR_OWVAR 28
25540: PUSH
25541: LD_INT 17
25543: ST_TO_ADDR
// hc_gallery :=  ;
25544: LD_ADDR_OWVAR 33
25548: PUSH
25549: LD_STRING 
25551: ST_TO_ADDR
// hc_name :=  ;
25552: LD_ADDR_OWVAR 26
25556: PUSH
25557: LD_STRING 
25559: ST_TO_ADDR
// un := CreateHuman ;
25560: LD_ADDR_VAR 0 2
25564: PUSH
25565: CALL_OW 44
25569: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25570: LD_VAR 0 2
25574: PPUSH
25575: LD_INT 1
25577: PPUSH
25578: CALL_OW 51
// tmp := tmp ^ un ;
25582: LD_ADDR_VAR 0 3
25586: PUSH
25587: LD_VAR 0 3
25591: PUSH
25592: LD_VAR 0 2
25596: ADD
25597: ST_TO_ADDR
// end ;
25598: GO 25494
25600: POP
25601: POP
// repeat wait ( 0 0$1 ) ;
25602: LD_INT 35
25604: PPUSH
25605: CALL_OW 67
// for un in tmp do
25609: LD_ADDR_VAR 0 2
25613: PUSH
25614: LD_VAR 0 3
25618: PUSH
25619: FOR_IN
25620: IFFALSE 25694
// begin if IsDead ( un ) then
25622: LD_VAR 0 2
25626: PPUSH
25627: CALL_OW 301
25631: IFFALSE 25651
// begin tmp := tmp diff un ;
25633: LD_ADDR_VAR 0 3
25637: PUSH
25638: LD_VAR 0 3
25642: PUSH
25643: LD_VAR 0 2
25647: DIFF
25648: ST_TO_ADDR
// continue ;
25649: GO 25619
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25651: LD_VAR 0 2
25655: PPUSH
25656: LD_INT 3
25658: PUSH
25659: LD_INT 22
25661: PUSH
25662: LD_INT 0
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PPUSH
25673: CALL_OW 69
25677: PPUSH
25678: LD_VAR 0 2
25682: PPUSH
25683: CALL_OW 74
25687: PPUSH
25688: CALL_OW 115
// end ;
25692: GO 25619
25694: POP
25695: POP
// until not tmp ;
25696: LD_VAR 0 3
25700: NOT
25701: IFFALSE 25602
// end ;
25703: PPOPN 3
25705: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25706: LD_EXP 59
25710: PUSH
25711: LD_EXP 84
25715: AND
25716: IFFALSE 25770
25718: GO 25720
25720: DISABLE
// begin ToLua ( displayTroll(); ) ;
25721: LD_STRING displayTroll();
25723: PPUSH
25724: CALL_OW 559
// wait ( 3 3$00 ) ;
25728: LD_INT 6300
25730: PPUSH
25731: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25735: LD_STRING hideTroll();
25737: PPUSH
25738: CALL_OW 559
// wait ( 1 1$00 ) ;
25742: LD_INT 2100
25744: PPUSH
25745: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25749: LD_STRING displayTroll();
25751: PPUSH
25752: CALL_OW 559
// wait ( 1 1$00 ) ;
25756: LD_INT 2100
25758: PPUSH
25759: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25763: LD_STRING hideTroll();
25765: PPUSH
25766: CALL_OW 559
// end ;
25770: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25771: LD_EXP 59
25775: PUSH
25776: LD_EXP 85
25780: AND
25781: IFFALSE 25844
25783: GO 25785
25785: DISABLE
25786: LD_INT 0
25788: PPUSH
// begin p := 0 ;
25789: LD_ADDR_VAR 0 1
25793: PUSH
25794: LD_INT 0
25796: ST_TO_ADDR
// repeat game_speed := 1 ;
25797: LD_ADDR_OWVAR 65
25801: PUSH
25802: LD_INT 1
25804: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25805: LD_INT 35
25807: PPUSH
25808: CALL_OW 67
// p := p + 1 ;
25812: LD_ADDR_VAR 0 1
25816: PUSH
25817: LD_VAR 0 1
25821: PUSH
25822: LD_INT 1
25824: PLUS
25825: ST_TO_ADDR
// until p >= 60 ;
25826: LD_VAR 0 1
25830: PUSH
25831: LD_INT 60
25833: GREATEREQUAL
25834: IFFALSE 25797
// game_speed := 4 ;
25836: LD_ADDR_OWVAR 65
25840: PUSH
25841: LD_INT 4
25843: ST_TO_ADDR
// end ;
25844: PPOPN 1
25846: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25847: LD_EXP 59
25851: PUSH
25852: LD_EXP 86
25856: AND
25857: IFFALSE 26003
25859: GO 25861
25861: DISABLE
25862: LD_INT 0
25864: PPUSH
25865: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25866: LD_ADDR_VAR 0 1
25870: PUSH
25871: LD_INT 22
25873: PUSH
25874: LD_OWVAR 2
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: LD_INT 30
25888: PUSH
25889: LD_INT 0
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PUSH
25896: LD_INT 30
25898: PUSH
25899: LD_INT 1
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: LIST
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL_OW 69
25919: ST_TO_ADDR
// if not depot then
25920: LD_VAR 0 1
25924: NOT
25925: IFFALSE 25929
// exit ;
25927: GO 26003
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25929: LD_ADDR_VAR 0 2
25933: PUSH
25934: LD_VAR 0 1
25938: PUSH
25939: LD_INT 1
25941: PPUSH
25942: LD_VAR 0 1
25946: PPUSH
25947: CALL_OW 12
25951: ARRAY
25952: PPUSH
25953: CALL_OW 274
25957: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25958: LD_VAR 0 2
25962: PPUSH
25963: LD_INT 1
25965: PPUSH
25966: LD_INT 0
25968: PPUSH
25969: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25973: LD_VAR 0 2
25977: PPUSH
25978: LD_INT 2
25980: PPUSH
25981: LD_INT 0
25983: PPUSH
25984: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25988: LD_VAR 0 2
25992: PPUSH
25993: LD_INT 3
25995: PPUSH
25996: LD_INT 0
25998: PPUSH
25999: CALL_OW 277
// end ;
26003: PPOPN 2
26005: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26006: LD_EXP 59
26010: PUSH
26011: LD_EXP 87
26015: AND
26016: IFFALSE 26113
26018: GO 26020
26020: DISABLE
26021: LD_INT 0
26023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26024: LD_ADDR_VAR 0 1
26028: PUSH
26029: LD_INT 22
26031: PUSH
26032: LD_OWVAR 2
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 21
26043: PUSH
26044: LD_INT 1
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: LD_INT 3
26053: PUSH
26054: LD_INT 23
26056: PUSH
26057: LD_INT 0
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: EMPTY
26065: LIST
26066: LIST
26067: PUSH
26068: EMPTY
26069: LIST
26070: LIST
26071: LIST
26072: PPUSH
26073: CALL_OW 69
26077: ST_TO_ADDR
// if not tmp then
26078: LD_VAR 0 1
26082: NOT
26083: IFFALSE 26087
// exit ;
26085: GO 26113
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26087: LD_VAR 0 1
26091: PUSH
26092: LD_INT 1
26094: PPUSH
26095: LD_VAR 0 1
26099: PPUSH
26100: CALL_OW 12
26104: ARRAY
26105: PPUSH
26106: LD_INT 200
26108: PPUSH
26109: CALL_OW 234
// end ;
26113: PPOPN 1
26115: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26116: LD_EXP 59
26120: PUSH
26121: LD_EXP 88
26125: AND
26126: IFFALSE 26205
26128: GO 26130
26130: DISABLE
26131: LD_INT 0
26133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26134: LD_ADDR_VAR 0 1
26138: PUSH
26139: LD_INT 22
26141: PUSH
26142: LD_OWVAR 2
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_INT 21
26153: PUSH
26154: LD_INT 2
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PPUSH
26165: CALL_OW 69
26169: ST_TO_ADDR
// if not tmp then
26170: LD_VAR 0 1
26174: NOT
26175: IFFALSE 26179
// exit ;
26177: GO 26205
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26179: LD_VAR 0 1
26183: PUSH
26184: LD_INT 1
26186: PPUSH
26187: LD_VAR 0 1
26191: PPUSH
26192: CALL_OW 12
26196: ARRAY
26197: PPUSH
26198: LD_INT 60
26200: PPUSH
26201: CALL_OW 234
// end ;
26205: PPOPN 1
26207: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26208: LD_EXP 59
26212: PUSH
26213: LD_EXP 89
26217: AND
26218: IFFALSE 26317
26220: GO 26222
26222: DISABLE
26223: LD_INT 0
26225: PPUSH
26226: PPUSH
// begin enable ;
26227: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26228: LD_ADDR_VAR 0 1
26232: PUSH
26233: LD_INT 22
26235: PUSH
26236: LD_OWVAR 2
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 61
26247: PUSH
26248: EMPTY
26249: LIST
26250: PUSH
26251: LD_INT 33
26253: PUSH
26254: LD_INT 2
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: LIST
26265: PPUSH
26266: CALL_OW 69
26270: ST_TO_ADDR
// if not tmp then
26271: LD_VAR 0 1
26275: NOT
26276: IFFALSE 26280
// exit ;
26278: GO 26317
// for i in tmp do
26280: LD_ADDR_VAR 0 2
26284: PUSH
26285: LD_VAR 0 1
26289: PUSH
26290: FOR_IN
26291: IFFALSE 26315
// if IsControledBy ( i ) then
26293: LD_VAR 0 2
26297: PPUSH
26298: CALL_OW 312
26302: IFFALSE 26313
// ComUnlink ( i ) ;
26304: LD_VAR 0 2
26308: PPUSH
26309: CALL_OW 136
26313: GO 26290
26315: POP
26316: POP
// end ;
26317: PPOPN 2
26319: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26320: LD_EXP 59
26324: PUSH
26325: LD_EXP 90
26329: AND
26330: IFFALSE 26464
26332: GO 26334
26334: DISABLE
26335: LD_INT 0
26337: PPUSH
26338: PPUSH
// begin ToLua ( displayPowell(); ) ;
26339: LD_STRING displayPowell();
26341: PPUSH
26342: CALL_OW 559
// uc_side := 0 ;
26346: LD_ADDR_OWVAR 20
26350: PUSH
26351: LD_INT 0
26353: ST_TO_ADDR
// uc_nation := 2 ;
26354: LD_ADDR_OWVAR 21
26358: PUSH
26359: LD_INT 2
26361: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26362: LD_ADDR_OWVAR 37
26366: PUSH
26367: LD_INT 14
26369: ST_TO_ADDR
// vc_engine := engine_siberite ;
26370: LD_ADDR_OWVAR 39
26374: PUSH
26375: LD_INT 3
26377: ST_TO_ADDR
// vc_control := control_apeman ;
26378: LD_ADDR_OWVAR 38
26382: PUSH
26383: LD_INT 5
26385: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26386: LD_ADDR_OWVAR 40
26390: PUSH
26391: LD_INT 29
26393: ST_TO_ADDR
// un := CreateVehicle ;
26394: LD_ADDR_VAR 0 2
26398: PUSH
26399: CALL_OW 45
26403: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26404: LD_VAR 0 2
26408: PPUSH
26409: LD_INT 1
26411: PPUSH
26412: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26416: LD_INT 35
26418: PPUSH
26419: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26423: LD_VAR 0 2
26427: PPUSH
26428: LD_OWVAR 3
26432: PUSH
26433: LD_VAR 0 2
26437: DIFF
26438: PPUSH
26439: LD_VAR 0 2
26443: PPUSH
26444: CALL_OW 74
26448: PPUSH
26449: CALL_OW 115
// until IsOk ( un ) ;
26453: LD_VAR 0 2
26457: PPUSH
26458: CALL_OW 302
26462: IFFALSE 26416
// end ;
26464: PPOPN 2
26466: END
// every 0 0$1 trigger StreamModeActive and sStu do
26467: LD_EXP 59
26471: PUSH
26472: LD_EXP 98
26476: AND
26477: IFFALSE 26489
26479: GO 26481
26481: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26482: LD_STRING displayStucuk();
26484: PPUSH
26485: CALL_OW 559
// end ;
26489: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26490: LD_EXP 59
26494: PUSH
26495: LD_EXP 91
26499: AND
26500: IFFALSE 26641
26502: GO 26504
26504: DISABLE
26505: LD_INT 0
26507: PPUSH
26508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26509: LD_ADDR_VAR 0 2
26513: PUSH
26514: LD_INT 22
26516: PUSH
26517: LD_OWVAR 2
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 21
26528: PUSH
26529: LD_INT 1
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: EMPTY
26537: LIST
26538: LIST
26539: PPUSH
26540: CALL_OW 69
26544: ST_TO_ADDR
// if not tmp then
26545: LD_VAR 0 2
26549: NOT
26550: IFFALSE 26554
// exit ;
26552: GO 26641
// un := tmp [ rand ( 1 , tmp ) ] ;
26554: LD_ADDR_VAR 0 1
26558: PUSH
26559: LD_VAR 0 2
26563: PUSH
26564: LD_INT 1
26566: PPUSH
26567: LD_VAR 0 2
26571: PPUSH
26572: CALL_OW 12
26576: ARRAY
26577: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26578: LD_VAR 0 1
26582: PPUSH
26583: LD_INT 0
26585: PPUSH
26586: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26590: LD_VAR 0 1
26594: PPUSH
26595: LD_OWVAR 3
26599: PUSH
26600: LD_VAR 0 1
26604: DIFF
26605: PPUSH
26606: LD_VAR 0 1
26610: PPUSH
26611: CALL_OW 74
26615: PPUSH
26616: CALL_OW 115
// wait ( 0 0$20 ) ;
26620: LD_INT 700
26622: PPUSH
26623: CALL_OW 67
// SetSide ( un , your_side ) ;
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_OWVAR 2
26636: PPUSH
26637: CALL_OW 235
// end ;
26641: PPOPN 2
26643: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26644: LD_EXP 59
26648: PUSH
26649: LD_EXP 92
26653: AND
26654: IFFALSE 26760
26656: GO 26658
26658: DISABLE
26659: LD_INT 0
26661: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26662: LD_ADDR_VAR 0 1
26666: PUSH
26667: LD_INT 22
26669: PUSH
26670: LD_OWVAR 2
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PUSH
26679: LD_INT 2
26681: PUSH
26682: LD_INT 30
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 30
26694: PUSH
26695: LD_INT 1
26697: PUSH
26698: EMPTY
26699: LIST
26700: LIST
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: LIST
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PPUSH
26711: CALL_OW 69
26715: ST_TO_ADDR
// if not depot then
26716: LD_VAR 0 1
26720: NOT
26721: IFFALSE 26725
// exit ;
26723: GO 26760
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26725: LD_VAR 0 1
26729: PUSH
26730: LD_INT 1
26732: ARRAY
26733: PPUSH
26734: CALL_OW 250
26738: PPUSH
26739: LD_VAR 0 1
26743: PUSH
26744: LD_INT 1
26746: ARRAY
26747: PPUSH
26748: CALL_OW 251
26752: PPUSH
26753: LD_INT 70
26755: PPUSH
26756: CALL_OW 495
// end ;
26760: PPOPN 1
26762: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26763: LD_EXP 59
26767: PUSH
26768: LD_EXP 93
26772: AND
26773: IFFALSE 26984
26775: GO 26777
26777: DISABLE
26778: LD_INT 0
26780: PPUSH
26781: PPUSH
26782: PPUSH
26783: PPUSH
26784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26785: LD_ADDR_VAR 0 5
26789: PUSH
26790: LD_INT 22
26792: PUSH
26793: LD_OWVAR 2
26797: PUSH
26798: EMPTY
26799: LIST
26800: LIST
26801: PUSH
26802: LD_INT 21
26804: PUSH
26805: LD_INT 1
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PPUSH
26816: CALL_OW 69
26820: ST_TO_ADDR
// if not tmp then
26821: LD_VAR 0 5
26825: NOT
26826: IFFALSE 26830
// exit ;
26828: GO 26984
// for i in tmp do
26830: LD_ADDR_VAR 0 1
26834: PUSH
26835: LD_VAR 0 5
26839: PUSH
26840: FOR_IN
26841: IFFALSE 26982
// begin d := rand ( 0 , 5 ) ;
26843: LD_ADDR_VAR 0 4
26847: PUSH
26848: LD_INT 0
26850: PPUSH
26851: LD_INT 5
26853: PPUSH
26854: CALL_OW 12
26858: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26859: LD_ADDR_VAR 0 2
26863: PUSH
26864: LD_VAR 0 1
26868: PPUSH
26869: CALL_OW 250
26873: PPUSH
26874: LD_VAR 0 4
26878: PPUSH
26879: LD_INT 3
26881: PPUSH
26882: LD_INT 12
26884: PPUSH
26885: CALL_OW 12
26889: PPUSH
26890: CALL_OW 272
26894: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26895: LD_ADDR_VAR 0 3
26899: PUSH
26900: LD_VAR 0 1
26904: PPUSH
26905: CALL_OW 251
26909: PPUSH
26910: LD_VAR 0 4
26914: PPUSH
26915: LD_INT 3
26917: PPUSH
26918: LD_INT 12
26920: PPUSH
26921: CALL_OW 12
26925: PPUSH
26926: CALL_OW 273
26930: ST_TO_ADDR
// if ValidHex ( x , y ) then
26931: LD_VAR 0 2
26935: PPUSH
26936: LD_VAR 0 3
26940: PPUSH
26941: CALL_OW 488
26945: IFFALSE 26980
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26947: LD_VAR 0 1
26951: PPUSH
26952: LD_VAR 0 2
26956: PPUSH
26957: LD_VAR 0 3
26961: PPUSH
26962: LD_INT 3
26964: PPUSH
26965: LD_INT 6
26967: PPUSH
26968: CALL_OW 12
26972: PPUSH
26973: LD_INT 1
26975: PPUSH
26976: CALL_OW 483
// end ;
26980: GO 26840
26982: POP
26983: POP
// end ;
26984: PPOPN 5
26986: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26987: LD_EXP 59
26991: PUSH
26992: LD_EXP 94
26996: AND
26997: IFFALSE 27091
26999: GO 27001
27001: DISABLE
27002: LD_INT 0
27004: PPUSH
27005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27006: LD_ADDR_VAR 0 2
27010: PUSH
27011: LD_INT 22
27013: PUSH
27014: LD_OWVAR 2
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: PUSH
27023: LD_INT 32
27025: PUSH
27026: LD_INT 1
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 21
27035: PUSH
27036: LD_INT 2
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: LIST
27047: PPUSH
27048: CALL_OW 69
27052: ST_TO_ADDR
// if not tmp then
27053: LD_VAR 0 2
27057: NOT
27058: IFFALSE 27062
// exit ;
27060: GO 27091
// for i in tmp do
27062: LD_ADDR_VAR 0 1
27066: PUSH
27067: LD_VAR 0 2
27071: PUSH
27072: FOR_IN
27073: IFFALSE 27089
// SetFuel ( i , 0 ) ;
27075: LD_VAR 0 1
27079: PPUSH
27080: LD_INT 0
27082: PPUSH
27083: CALL_OW 240
27087: GO 27072
27089: POP
27090: POP
// end ;
27091: PPOPN 2
27093: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27094: LD_EXP 59
27098: PUSH
27099: LD_EXP 95
27103: AND
27104: IFFALSE 27170
27106: GO 27108
27108: DISABLE
27109: LD_INT 0
27111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27112: LD_ADDR_VAR 0 1
27116: PUSH
27117: LD_INT 22
27119: PUSH
27120: LD_OWVAR 2
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 30
27131: PUSH
27132: LD_INT 29
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PPUSH
27143: CALL_OW 69
27147: ST_TO_ADDR
// if not tmp then
27148: LD_VAR 0 1
27152: NOT
27153: IFFALSE 27157
// exit ;
27155: GO 27170
// DestroyUnit ( tmp [ 1 ] ) ;
27157: LD_VAR 0 1
27161: PUSH
27162: LD_INT 1
27164: ARRAY
27165: PPUSH
27166: CALL_OW 65
// end ;
27170: PPOPN 1
27172: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27173: LD_EXP 59
27177: PUSH
27178: LD_EXP 97
27182: AND
27183: IFFALSE 27312
27185: GO 27187
27187: DISABLE
27188: LD_INT 0
27190: PPUSH
// begin uc_side := 0 ;
27191: LD_ADDR_OWVAR 20
27195: PUSH
27196: LD_INT 0
27198: ST_TO_ADDR
// uc_nation := nation_arabian ;
27199: LD_ADDR_OWVAR 21
27203: PUSH
27204: LD_INT 2
27206: ST_TO_ADDR
// hc_gallery :=  ;
27207: LD_ADDR_OWVAR 33
27211: PUSH
27212: LD_STRING 
27214: ST_TO_ADDR
// hc_name :=  ;
27215: LD_ADDR_OWVAR 26
27219: PUSH
27220: LD_STRING 
27222: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27223: LD_INT 1
27225: PPUSH
27226: LD_INT 11
27228: PPUSH
27229: LD_INT 10
27231: PPUSH
27232: CALL_OW 380
// un := CreateHuman ;
27236: LD_ADDR_VAR 0 1
27240: PUSH
27241: CALL_OW 44
27245: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27246: LD_VAR 0 1
27250: PPUSH
27251: LD_INT 1
27253: PPUSH
27254: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27258: LD_INT 35
27260: PPUSH
27261: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27265: LD_VAR 0 1
27269: PPUSH
27270: LD_INT 22
27272: PUSH
27273: LD_OWVAR 2
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PPUSH
27282: CALL_OW 69
27286: PPUSH
27287: LD_VAR 0 1
27291: PPUSH
27292: CALL_OW 74
27296: PPUSH
27297: CALL_OW 115
// until IsDead ( un ) ;
27301: LD_VAR 0 1
27305: PPUSH
27306: CALL_OW 301
27310: IFFALSE 27258
// end ;
27312: PPOPN 1
27314: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27315: LD_EXP 59
27319: PUSH
27320: LD_EXP 99
27324: AND
27325: IFFALSE 27337
27327: GO 27329
27329: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27330: LD_STRING earthquake(getX(game), 0, 32)
27332: PPUSH
27333: CALL_OW 559
27337: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27338: LD_EXP 59
27342: PUSH
27343: LD_EXP 100
27347: AND
27348: IFFALSE 27439
27350: GO 27352
27352: DISABLE
27353: LD_INT 0
27355: PPUSH
// begin enable ;
27356: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27357: LD_ADDR_VAR 0 1
27361: PUSH
27362: LD_INT 22
27364: PUSH
27365: LD_OWVAR 2
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 21
27376: PUSH
27377: LD_INT 2
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 33
27386: PUSH
27387: LD_INT 3
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: LIST
27398: PPUSH
27399: CALL_OW 69
27403: ST_TO_ADDR
// if not tmp then
27404: LD_VAR 0 1
27408: NOT
27409: IFFALSE 27413
// exit ;
27411: GO 27439
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27413: LD_VAR 0 1
27417: PUSH
27418: LD_INT 1
27420: PPUSH
27421: LD_VAR 0 1
27425: PPUSH
27426: CALL_OW 12
27430: ARRAY
27431: PPUSH
27432: LD_INT 1
27434: PPUSH
27435: CALL_OW 234
// end ;
27439: PPOPN 1
27441: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27442: LD_EXP 59
27446: PUSH
27447: LD_EXP 101
27451: AND
27452: IFFALSE 27593
27454: GO 27456
27456: DISABLE
27457: LD_INT 0
27459: PPUSH
27460: PPUSH
27461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27462: LD_ADDR_VAR 0 3
27466: PUSH
27467: LD_INT 22
27469: PUSH
27470: LD_OWVAR 2
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: PUSH
27479: LD_INT 25
27481: PUSH
27482: LD_INT 1
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PPUSH
27493: CALL_OW 69
27497: ST_TO_ADDR
// if not tmp then
27498: LD_VAR 0 3
27502: NOT
27503: IFFALSE 27507
// exit ;
27505: GO 27593
// un := tmp [ rand ( 1 , tmp ) ] ;
27507: LD_ADDR_VAR 0 2
27511: PUSH
27512: LD_VAR 0 3
27516: PUSH
27517: LD_INT 1
27519: PPUSH
27520: LD_VAR 0 3
27524: PPUSH
27525: CALL_OW 12
27529: ARRAY
27530: ST_TO_ADDR
// if Crawls ( un ) then
27531: LD_VAR 0 2
27535: PPUSH
27536: CALL_OW 318
27540: IFFALSE 27551
// ComWalk ( un ) ;
27542: LD_VAR 0 2
27546: PPUSH
27547: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27551: LD_VAR 0 2
27555: PPUSH
27556: LD_INT 9
27558: PPUSH
27559: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27563: LD_INT 28
27565: PPUSH
27566: LD_OWVAR 2
27570: PPUSH
27571: LD_INT 2
27573: PPUSH
27574: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27578: LD_INT 29
27580: PPUSH
27581: LD_OWVAR 2
27585: PPUSH
27586: LD_INT 2
27588: PPUSH
27589: CALL_OW 322
// end ;
27593: PPOPN 3
27595: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27596: LD_EXP 59
27600: PUSH
27601: LD_EXP 102
27605: AND
27606: IFFALSE 27717
27608: GO 27610
27610: DISABLE
27611: LD_INT 0
27613: PPUSH
27614: PPUSH
27615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27616: LD_ADDR_VAR 0 3
27620: PUSH
27621: LD_INT 22
27623: PUSH
27624: LD_OWVAR 2
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 25
27635: PUSH
27636: LD_INT 1
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: PPUSH
27647: CALL_OW 69
27651: ST_TO_ADDR
// if not tmp then
27652: LD_VAR 0 3
27656: NOT
27657: IFFALSE 27661
// exit ;
27659: GO 27717
// un := tmp [ rand ( 1 , tmp ) ] ;
27661: LD_ADDR_VAR 0 2
27665: PUSH
27666: LD_VAR 0 3
27670: PUSH
27671: LD_INT 1
27673: PPUSH
27674: LD_VAR 0 3
27678: PPUSH
27679: CALL_OW 12
27683: ARRAY
27684: ST_TO_ADDR
// if Crawls ( un ) then
27685: LD_VAR 0 2
27689: PPUSH
27690: CALL_OW 318
27694: IFFALSE 27705
// ComWalk ( un ) ;
27696: LD_VAR 0 2
27700: PPUSH
27701: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27705: LD_VAR 0 2
27709: PPUSH
27710: LD_INT 8
27712: PPUSH
27713: CALL_OW 336
// end ;
27717: PPOPN 3
27719: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27720: LD_EXP 59
27724: PUSH
27725: LD_EXP 103
27729: AND
27730: IFFALSE 27874
27732: GO 27734
27734: DISABLE
27735: LD_INT 0
27737: PPUSH
27738: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27739: LD_ADDR_VAR 0 2
27743: PUSH
27744: LD_INT 22
27746: PUSH
27747: LD_OWVAR 2
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 21
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 2
27768: PUSH
27769: LD_INT 34
27771: PUSH
27772: LD_INT 12
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: LD_INT 34
27781: PUSH
27782: LD_INT 51
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PUSH
27789: LD_INT 34
27791: PUSH
27792: LD_INT 32
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: LIST
27803: LIST
27804: PUSH
27805: EMPTY
27806: LIST
27807: LIST
27808: LIST
27809: PPUSH
27810: CALL_OW 69
27814: ST_TO_ADDR
// if not tmp then
27815: LD_VAR 0 2
27819: NOT
27820: IFFALSE 27824
// exit ;
27822: GO 27874
// for i in tmp do
27824: LD_ADDR_VAR 0 1
27828: PUSH
27829: LD_VAR 0 2
27833: PUSH
27834: FOR_IN
27835: IFFALSE 27872
// if GetCargo ( i , mat_artifact ) = 0 then
27837: LD_VAR 0 1
27841: PPUSH
27842: LD_INT 4
27844: PPUSH
27845: CALL_OW 289
27849: PUSH
27850: LD_INT 0
27852: EQUAL
27853: IFFALSE 27870
// SetCargo ( i , mat_siberit , 100 ) ;
27855: LD_VAR 0 1
27859: PPUSH
27860: LD_INT 3
27862: PPUSH
27863: LD_INT 100
27865: PPUSH
27866: CALL_OW 290
27870: GO 27834
27872: POP
27873: POP
// end ;
27874: PPOPN 2
27876: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27877: LD_EXP 59
27881: PUSH
27882: LD_EXP 104
27886: AND
27887: IFFALSE 28040
27889: GO 27891
27891: DISABLE
27892: LD_INT 0
27894: PPUSH
27895: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27896: LD_ADDR_VAR 0 2
27900: PUSH
27901: LD_INT 22
27903: PUSH
27904: LD_OWVAR 2
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PPUSH
27913: CALL_OW 69
27917: ST_TO_ADDR
// if not tmp then
27918: LD_VAR 0 2
27922: NOT
27923: IFFALSE 27927
// exit ;
27925: GO 28040
// for i := 1 to 2 do
27927: LD_ADDR_VAR 0 1
27931: PUSH
27932: DOUBLE
27933: LD_INT 1
27935: DEC
27936: ST_TO_ADDR
27937: LD_INT 2
27939: PUSH
27940: FOR_TO
27941: IFFALSE 28038
// begin uc_side := your_side ;
27943: LD_ADDR_OWVAR 20
27947: PUSH
27948: LD_OWVAR 2
27952: ST_TO_ADDR
// uc_nation := nation_american ;
27953: LD_ADDR_OWVAR 21
27957: PUSH
27958: LD_INT 1
27960: ST_TO_ADDR
// vc_chassis := us_morphling ;
27961: LD_ADDR_OWVAR 37
27965: PUSH
27966: LD_INT 5
27968: ST_TO_ADDR
// vc_engine := engine_siberite ;
27969: LD_ADDR_OWVAR 39
27973: PUSH
27974: LD_INT 3
27976: ST_TO_ADDR
// vc_control := control_computer ;
27977: LD_ADDR_OWVAR 38
27981: PUSH
27982: LD_INT 3
27984: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27985: LD_ADDR_OWVAR 40
27989: PUSH
27990: LD_INT 10
27992: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27993: CALL_OW 45
27997: PPUSH
27998: LD_VAR 0 2
28002: PUSH
28003: LD_INT 1
28005: ARRAY
28006: PPUSH
28007: CALL_OW 250
28011: PPUSH
28012: LD_VAR 0 2
28016: PUSH
28017: LD_INT 1
28019: ARRAY
28020: PPUSH
28021: CALL_OW 251
28025: PPUSH
28026: LD_INT 12
28028: PPUSH
28029: LD_INT 1
28031: PPUSH
28032: CALL_OW 50
// end ;
28036: GO 27940
28038: POP
28039: POP
// end ;
28040: PPOPN 2
28042: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28043: LD_EXP 59
28047: PUSH
28048: LD_EXP 105
28052: AND
28053: IFFALSE 28275
28055: GO 28057
28057: DISABLE
28058: LD_INT 0
28060: PPUSH
28061: PPUSH
28062: PPUSH
28063: PPUSH
28064: PPUSH
28065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28066: LD_ADDR_VAR 0 6
28070: PUSH
28071: LD_INT 22
28073: PUSH
28074: LD_OWVAR 2
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 21
28085: PUSH
28086: LD_INT 1
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PUSH
28093: LD_INT 3
28095: PUSH
28096: LD_INT 23
28098: PUSH
28099: LD_INT 0
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: ST_TO_ADDR
// if not tmp then
28120: LD_VAR 0 6
28124: NOT
28125: IFFALSE 28129
// exit ;
28127: GO 28275
// s1 := rand ( 1 , 4 ) ;
28129: LD_ADDR_VAR 0 2
28133: PUSH
28134: LD_INT 1
28136: PPUSH
28137: LD_INT 4
28139: PPUSH
28140: CALL_OW 12
28144: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28145: LD_ADDR_VAR 0 4
28149: PUSH
28150: LD_VAR 0 6
28154: PUSH
28155: LD_INT 1
28157: ARRAY
28158: PPUSH
28159: LD_VAR 0 2
28163: PPUSH
28164: CALL_OW 259
28168: ST_TO_ADDR
// if s1 = 1 then
28169: LD_VAR 0 2
28173: PUSH
28174: LD_INT 1
28176: EQUAL
28177: IFFALSE 28197
// s2 := rand ( 2 , 4 ) else
28179: LD_ADDR_VAR 0 3
28183: PUSH
28184: LD_INT 2
28186: PPUSH
28187: LD_INT 4
28189: PPUSH
28190: CALL_OW 12
28194: ST_TO_ADDR
28195: GO 28205
// s2 := 1 ;
28197: LD_ADDR_VAR 0 3
28201: PUSH
28202: LD_INT 1
28204: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28205: LD_ADDR_VAR 0 5
28209: PUSH
28210: LD_VAR 0 6
28214: PUSH
28215: LD_INT 1
28217: ARRAY
28218: PPUSH
28219: LD_VAR 0 3
28223: PPUSH
28224: CALL_OW 259
28228: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28229: LD_VAR 0 6
28233: PUSH
28234: LD_INT 1
28236: ARRAY
28237: PPUSH
28238: LD_VAR 0 2
28242: PPUSH
28243: LD_VAR 0 5
28247: PPUSH
28248: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28252: LD_VAR 0 6
28256: PUSH
28257: LD_INT 1
28259: ARRAY
28260: PPUSH
28261: LD_VAR 0 3
28265: PPUSH
28266: LD_VAR 0 4
28270: PPUSH
28271: CALL_OW 237
// end ;
28275: PPOPN 6
28277: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28278: LD_EXP 59
28282: PUSH
28283: LD_EXP 106
28287: AND
28288: IFFALSE 28367
28290: GO 28292
28292: DISABLE
28293: LD_INT 0
28295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28296: LD_ADDR_VAR 0 1
28300: PUSH
28301: LD_INT 22
28303: PUSH
28304: LD_OWVAR 2
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 30
28315: PUSH
28316: LD_INT 3
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PPUSH
28327: CALL_OW 69
28331: ST_TO_ADDR
// if not tmp then
28332: LD_VAR 0 1
28336: NOT
28337: IFFALSE 28341
// exit ;
28339: GO 28367
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28341: LD_VAR 0 1
28345: PUSH
28346: LD_INT 1
28348: PPUSH
28349: LD_VAR 0 1
28353: PPUSH
28354: CALL_OW 12
28358: ARRAY
28359: PPUSH
28360: LD_INT 1
28362: PPUSH
28363: CALL_OW 234
// end ;
28367: PPOPN 1
28369: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28370: LD_EXP 59
28374: PUSH
28375: LD_EXP 107
28379: AND
28380: IFFALSE 28492
28382: GO 28384
28384: DISABLE
28385: LD_INT 0
28387: PPUSH
28388: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28389: LD_ADDR_VAR 0 2
28393: PUSH
28394: LD_INT 22
28396: PUSH
28397: LD_OWVAR 2
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 2
28408: PUSH
28409: LD_INT 30
28411: PUSH
28412: LD_INT 27
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PUSH
28419: LD_INT 30
28421: PUSH
28422: LD_INT 26
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: LD_INT 30
28431: PUSH
28432: LD_INT 28
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: LIST
28443: LIST
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PPUSH
28449: CALL_OW 69
28453: ST_TO_ADDR
// if not tmp then
28454: LD_VAR 0 2
28458: NOT
28459: IFFALSE 28463
// exit ;
28461: GO 28492
// for i in tmp do
28463: LD_ADDR_VAR 0 1
28467: PUSH
28468: LD_VAR 0 2
28472: PUSH
28473: FOR_IN
28474: IFFALSE 28490
// SetLives ( i , 1 ) ;
28476: LD_VAR 0 1
28480: PPUSH
28481: LD_INT 1
28483: PPUSH
28484: CALL_OW 234
28488: GO 28473
28490: POP
28491: POP
// end ;
28492: PPOPN 2
28494: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28495: LD_EXP 59
28499: PUSH
28500: LD_EXP 108
28504: AND
28505: IFFALSE 28775
28507: GO 28509
28509: DISABLE
28510: LD_INT 0
28512: PPUSH
28513: PPUSH
28514: PPUSH
// begin i := rand ( 1 , 7 ) ;
28515: LD_ADDR_VAR 0 1
28519: PUSH
28520: LD_INT 1
28522: PPUSH
28523: LD_INT 7
28525: PPUSH
28526: CALL_OW 12
28530: ST_TO_ADDR
// case i of 1 :
28531: LD_VAR 0 1
28535: PUSH
28536: LD_INT 1
28538: DOUBLE
28539: EQUAL
28540: IFTRUE 28544
28542: GO 28554
28544: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28545: LD_STRING earthquake(getX(game), 0, 32)
28547: PPUSH
28548: CALL_OW 559
28552: GO 28775
28554: LD_INT 2
28556: DOUBLE
28557: EQUAL
28558: IFTRUE 28562
28560: GO 28572
28562: POP
// ToLua ( displayStucuk(); ) ; 3 :
28563: LD_STRING displayStucuk();
28565: PPUSH
28566: CALL_OW 559
28570: GO 28775
28572: LD_INT 3
28574: DOUBLE
28575: EQUAL
28576: IFTRUE 28580
28578: GO 28684
28580: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28581: LD_ADDR_VAR 0 2
28585: PUSH
28586: LD_INT 22
28588: PUSH
28589: LD_OWVAR 2
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 25
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PPUSH
28612: CALL_OW 69
28616: ST_TO_ADDR
// if not tmp then
28617: LD_VAR 0 2
28621: NOT
28622: IFFALSE 28626
// exit ;
28624: GO 28775
// un := tmp [ rand ( 1 , tmp ) ] ;
28626: LD_ADDR_VAR 0 3
28630: PUSH
28631: LD_VAR 0 2
28635: PUSH
28636: LD_INT 1
28638: PPUSH
28639: LD_VAR 0 2
28643: PPUSH
28644: CALL_OW 12
28648: ARRAY
28649: ST_TO_ADDR
// if Crawls ( un ) then
28650: LD_VAR 0 3
28654: PPUSH
28655: CALL_OW 318
28659: IFFALSE 28670
// ComWalk ( un ) ;
28661: LD_VAR 0 3
28665: PPUSH
28666: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28670: LD_VAR 0 3
28674: PPUSH
28675: LD_INT 8
28677: PPUSH
28678: CALL_OW 336
// end ; 4 :
28682: GO 28775
28684: LD_INT 4
28686: DOUBLE
28687: EQUAL
28688: IFTRUE 28692
28690: GO 28753
28692: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28693: LD_ADDR_VAR 0 2
28697: PUSH
28698: LD_INT 22
28700: PUSH
28701: LD_OWVAR 2
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: LD_INT 29
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PPUSH
28724: CALL_OW 69
28728: ST_TO_ADDR
// if not tmp then
28729: LD_VAR 0 2
28733: NOT
28734: IFFALSE 28738
// exit ;
28736: GO 28775
// DestroyUnit ( tmp [ 1 ] ) ;
28738: LD_VAR 0 2
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PPUSH
28747: CALL_OW 65
// end ; 5 .. 7 :
28751: GO 28775
28753: LD_INT 5
28755: DOUBLE
28756: GREATEREQUAL
28757: IFFALSE 28765
28759: LD_INT 7
28761: DOUBLE
28762: LESSEQUAL
28763: IFTRUE 28767
28765: GO 28774
28767: POP
// StreamSibBomb ; end ;
28768: CALL 25069 0 0
28772: GO 28775
28774: POP
// end ;
28775: PPOPN 3
28777: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28778: LD_EXP 59
28782: PUSH
28783: LD_EXP 109
28787: AND
28788: IFFALSE 28944
28790: GO 28792
28792: DISABLE
28793: LD_INT 0
28795: PPUSH
28796: PPUSH
28797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28798: LD_ADDR_VAR 0 2
28802: PUSH
28803: LD_INT 81
28805: PUSH
28806: LD_OWVAR 2
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 2
28817: PUSH
28818: LD_INT 21
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 21
28830: PUSH
28831: LD_INT 2
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: LIST
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PPUSH
28847: CALL_OW 69
28851: ST_TO_ADDR
// if not tmp then
28852: LD_VAR 0 2
28856: NOT
28857: IFFALSE 28861
// exit ;
28859: GO 28944
// p := 0 ;
28861: LD_ADDR_VAR 0 3
28865: PUSH
28866: LD_INT 0
28868: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28869: LD_INT 35
28871: PPUSH
28872: CALL_OW 67
// p := p + 1 ;
28876: LD_ADDR_VAR 0 3
28880: PUSH
28881: LD_VAR 0 3
28885: PUSH
28886: LD_INT 1
28888: PLUS
28889: ST_TO_ADDR
// for i in tmp do
28890: LD_ADDR_VAR 0 1
28894: PUSH
28895: LD_VAR 0 2
28899: PUSH
28900: FOR_IN
28901: IFFALSE 28932
// if GetLives ( i ) < 1000 then
28903: LD_VAR 0 1
28907: PPUSH
28908: CALL_OW 256
28912: PUSH
28913: LD_INT 1000
28915: LESS
28916: IFFALSE 28930
// SetLives ( i , 1000 ) ;
28918: LD_VAR 0 1
28922: PPUSH
28923: LD_INT 1000
28925: PPUSH
28926: CALL_OW 234
28930: GO 28900
28932: POP
28933: POP
// until p > 20 ;
28934: LD_VAR 0 3
28938: PUSH
28939: LD_INT 20
28941: GREATER
28942: IFFALSE 28869
// end ;
28944: PPOPN 3
28946: END
// every 0 0$1 trigger StreamModeActive and sTime do
28947: LD_EXP 59
28951: PUSH
28952: LD_EXP 110
28956: AND
28957: IFFALSE 28992
28959: GO 28961
28961: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28962: LD_INT 28
28964: PPUSH
28965: LD_OWVAR 2
28969: PPUSH
28970: LD_INT 2
28972: PPUSH
28973: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28977: LD_INT 30
28979: PPUSH
28980: LD_OWVAR 2
28984: PPUSH
28985: LD_INT 2
28987: PPUSH
28988: CALL_OW 322
// end ;
28992: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28993: LD_EXP 59
28997: PUSH
28998: LD_EXP 111
29002: AND
29003: IFFALSE 29124
29005: GO 29007
29007: DISABLE
29008: LD_INT 0
29010: PPUSH
29011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29012: LD_ADDR_VAR 0 2
29016: PUSH
29017: LD_INT 22
29019: PUSH
29020: LD_OWVAR 2
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 21
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 3
29041: PUSH
29042: LD_INT 23
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: LIST
29060: PPUSH
29061: CALL_OW 69
29065: ST_TO_ADDR
// if not tmp then
29066: LD_VAR 0 2
29070: NOT
29071: IFFALSE 29075
// exit ;
29073: GO 29124
// for i in tmp do
29075: LD_ADDR_VAR 0 1
29079: PUSH
29080: LD_VAR 0 2
29084: PUSH
29085: FOR_IN
29086: IFFALSE 29122
// begin if Crawls ( i ) then
29088: LD_VAR 0 1
29092: PPUSH
29093: CALL_OW 318
29097: IFFALSE 29108
// ComWalk ( i ) ;
29099: LD_VAR 0 1
29103: PPUSH
29104: CALL_OW 138
// SetClass ( i , 2 ) ;
29108: LD_VAR 0 1
29112: PPUSH
29113: LD_INT 2
29115: PPUSH
29116: CALL_OW 336
// end ;
29120: GO 29085
29122: POP
29123: POP
// end ;
29124: PPOPN 2
29126: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29127: LD_EXP 59
29131: PUSH
29132: LD_EXP 112
29136: AND
29137: IFFALSE 29342
29139: GO 29141
29141: DISABLE
29142: LD_INT 0
29144: PPUSH
29145: PPUSH
29146: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29147: LD_OWVAR 2
29151: PPUSH
29152: LD_INT 9
29154: PPUSH
29155: LD_INT 1
29157: PPUSH
29158: LD_INT 1
29160: PPUSH
29161: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29165: LD_INT 9
29167: PPUSH
29168: LD_OWVAR 2
29172: PPUSH
29173: CALL_OW 343
// hc_name := Dark Warrior ;
29177: LD_ADDR_OWVAR 26
29181: PUSH
29182: LD_STRING Dark Warrior
29184: ST_TO_ADDR
// hc_gallery :=  ;
29185: LD_ADDR_OWVAR 33
29189: PUSH
29190: LD_STRING 
29192: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
29193: LD_INT 1
29195: PPUSH
29196: LD_INT 1
29198: PPUSH
29199: LD_INT 10
29201: PPUSH
29202: CALL_OW 380
// un := CreateHuman ;
29206: LD_ADDR_VAR 0 3
29210: PUSH
29211: CALL_OW 44
29215: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29216: LD_VAR 0 3
29220: PPUSH
29221: LD_INT 1
29223: PPUSH
29224: CALL_OW 51
// p := 0 ;
29228: LD_ADDR_VAR 0 2
29232: PUSH
29233: LD_INT 0
29235: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29236: LD_INT 35
29238: PPUSH
29239: CALL_OW 67
// if GetLives ( un ) < 1000 then
29243: LD_VAR 0 3
29247: PPUSH
29248: CALL_OW 256
29252: PUSH
29253: LD_INT 1000
29255: LESS
29256: IFFALSE 29270
// SetLives ( un , 1000 ) ;
29258: LD_VAR 0 3
29262: PPUSH
29263: LD_INT 1000
29265: PPUSH
29266: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
29270: LD_VAR 0 3
29274: PPUSH
29275: LD_INT 81
29277: PUSH
29278: LD_OWVAR 2
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PPUSH
29287: CALL_OW 69
29291: PPUSH
29292: LD_VAR 0 3
29296: PPUSH
29297: CALL_OW 74
29301: PPUSH
29302: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29306: LD_VAR 0 2
29310: PUSH
29311: LD_INT 60
29313: GREATER
29314: PUSH
29315: LD_VAR 0 3
29319: PPUSH
29320: CALL_OW 301
29324: OR
29325: IFFALSE 29236
// if un then
29327: LD_VAR 0 3
29331: IFFALSE 29342
// RemoveUnit ( un ) ;
29333: LD_VAR 0 3
29337: PPUSH
29338: CALL_OW 64
// end ; end_of_file
29342: PPOPN 3
29344: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
29345: LD_INT 0
29347: PPUSH
29348: PPUSH
29349: PPUSH
29350: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29351: LD_VAR 0 1
29355: PPUSH
29356: CALL_OW 264
29360: PUSH
29361: LD_EXP 58
29365: EQUAL
29366: IFFALSE 29438
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29368: LD_INT 68
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL_OW 255
29380: PPUSH
29381: CALL_OW 321
29385: PUSH
29386: LD_INT 2
29388: EQUAL
29389: IFFALSE 29401
// eff := 70 else
29391: LD_ADDR_VAR 0 6
29395: PUSH
29396: LD_INT 70
29398: ST_TO_ADDR
29399: GO 29409
// eff := 30 ;
29401: LD_ADDR_VAR 0 6
29405: PUSH
29406: LD_INT 30
29408: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29409: LD_VAR 0 1
29413: PPUSH
29414: CALL_OW 250
29418: PPUSH
29419: LD_VAR 0 1
29423: PPUSH
29424: CALL_OW 251
29428: PPUSH
29429: LD_VAR 0 6
29433: PPUSH
29434: CALL_OW 495
// end ; end ;
29438: LD_VAR 0 4
29442: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
29443: LD_INT 0
29445: PPUSH
29446: PPUSH
29447: PPUSH
29448: PPUSH
29449: PPUSH
29450: PPUSH
// if cmd = 124 then
29451: LD_VAR 0 1
29455: PUSH
29456: LD_INT 124
29458: EQUAL
29459: IFFALSE 29665
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
29461: LD_ADDR_VAR 0 5
29465: PUSH
29466: LD_INT 2
29468: PUSH
29469: LD_INT 34
29471: PUSH
29472: LD_INT 53
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 34
29481: PUSH
29482: LD_INT 14
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: LIST
29493: PPUSH
29494: CALL_OW 69
29498: ST_TO_ADDR
// if not tmp then
29499: LD_VAR 0 5
29503: NOT
29504: IFFALSE 29508
// exit ;
29506: GO 29665
// for i in tmp do
29508: LD_ADDR_VAR 0 3
29512: PUSH
29513: LD_VAR 0 5
29517: PUSH
29518: FOR_IN
29519: IFFALSE 29663
// begin taskList := GetTaskList ( i ) ;
29521: LD_ADDR_VAR 0 6
29525: PUSH
29526: LD_VAR 0 3
29530: PPUSH
29531: CALL_OW 437
29535: ST_TO_ADDR
// if not taskList then
29536: LD_VAR 0 6
29540: NOT
29541: IFFALSE 29545
// continue ;
29543: GO 29518
// for j = 1 to taskList do
29545: LD_ADDR_VAR 0 4
29549: PUSH
29550: DOUBLE
29551: LD_INT 1
29553: DEC
29554: ST_TO_ADDR
29555: LD_VAR 0 6
29559: PUSH
29560: FOR_TO
29561: IFFALSE 29659
// if taskList [ j ] [ 1 ] = | then
29563: LD_VAR 0 6
29567: PUSH
29568: LD_VAR 0 4
29572: ARRAY
29573: PUSH
29574: LD_INT 1
29576: ARRAY
29577: PUSH
29578: LD_STRING |
29580: EQUAL
29581: IFFALSE 29657
// begin _taskList := Delete ( taskList , 1 ) ;
29583: LD_ADDR_VAR 0 7
29587: PUSH
29588: LD_VAR 0 6
29592: PPUSH
29593: LD_INT 1
29595: PPUSH
29596: CALL_OW 3
29600: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
29601: LD_VAR 0 3
29605: PPUSH
29606: LD_VAR 0 7
29610: PPUSH
29611: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
29615: LD_VAR 0 3
29619: PPUSH
29620: LD_VAR 0 6
29624: PUSH
29625: LD_VAR 0 4
29629: ARRAY
29630: PUSH
29631: LD_INT 2
29633: ARRAY
29634: PPUSH
29635: LD_VAR 0 6
29639: PUSH
29640: LD_VAR 0 4
29644: ARRAY
29645: PUSH
29646: LD_INT 3
29648: ARRAY
29649: PPUSH
29650: LD_INT 8
29652: PPUSH
29653: CALL 29670 0 4
// end ;
29657: GO 29560
29659: POP
29660: POP
// end ;
29661: GO 29518
29663: POP
29664: POP
// end ; end ;
29665: LD_VAR 0 2
29669: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29670: LD_INT 0
29672: PPUSH
29673: PPUSH
29674: PPUSH
29675: PPUSH
29676: PPUSH
29677: PPUSH
29678: PPUSH
29679: PPUSH
29680: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29681: LD_VAR 0 1
29685: NOT
29686: PUSH
29687: LD_VAR 0 2
29691: PPUSH
29692: LD_VAR 0 3
29696: PPUSH
29697: CALL_OW 488
29701: NOT
29702: OR
29703: PUSH
29704: LD_VAR 0 4
29708: NOT
29709: OR
29710: IFFALSE 29714
// exit ;
29712: GO 30054
// list := [ ] ;
29714: LD_ADDR_VAR 0 13
29718: PUSH
29719: EMPTY
29720: ST_TO_ADDR
// if x - r < 0 then
29721: LD_VAR 0 2
29725: PUSH
29726: LD_VAR 0 4
29730: MINUS
29731: PUSH
29732: LD_INT 0
29734: LESS
29735: IFFALSE 29747
// min_x := 0 else
29737: LD_ADDR_VAR 0 7
29741: PUSH
29742: LD_INT 0
29744: ST_TO_ADDR
29745: GO 29763
// min_x := x - r ;
29747: LD_ADDR_VAR 0 7
29751: PUSH
29752: LD_VAR 0 2
29756: PUSH
29757: LD_VAR 0 4
29761: MINUS
29762: ST_TO_ADDR
// if y - r < 0 then
29763: LD_VAR 0 3
29767: PUSH
29768: LD_VAR 0 4
29772: MINUS
29773: PUSH
29774: LD_INT 0
29776: LESS
29777: IFFALSE 29789
// min_y := 0 else
29779: LD_ADDR_VAR 0 8
29783: PUSH
29784: LD_INT 0
29786: ST_TO_ADDR
29787: GO 29805
// min_y := y - r ;
29789: LD_ADDR_VAR 0 8
29793: PUSH
29794: LD_VAR 0 3
29798: PUSH
29799: LD_VAR 0 4
29803: MINUS
29804: ST_TO_ADDR
// max_x := x + r ;
29805: LD_ADDR_VAR 0 9
29809: PUSH
29810: LD_VAR 0 2
29814: PUSH
29815: LD_VAR 0 4
29819: PLUS
29820: ST_TO_ADDR
// max_y := y + r ;
29821: LD_ADDR_VAR 0 10
29825: PUSH
29826: LD_VAR 0 3
29830: PUSH
29831: LD_VAR 0 4
29835: PLUS
29836: ST_TO_ADDR
// for _x = min_x to max_x do
29837: LD_ADDR_VAR 0 11
29841: PUSH
29842: DOUBLE
29843: LD_VAR 0 7
29847: DEC
29848: ST_TO_ADDR
29849: LD_VAR 0 9
29853: PUSH
29854: FOR_TO
29855: IFFALSE 29972
// for _y = min_y to max_y do
29857: LD_ADDR_VAR 0 12
29861: PUSH
29862: DOUBLE
29863: LD_VAR 0 8
29867: DEC
29868: ST_TO_ADDR
29869: LD_VAR 0 10
29873: PUSH
29874: FOR_TO
29875: IFFALSE 29968
// begin if not ValidHex ( _x , _y ) then
29877: LD_VAR 0 11
29881: PPUSH
29882: LD_VAR 0 12
29886: PPUSH
29887: CALL_OW 488
29891: NOT
29892: IFFALSE 29896
// continue ;
29894: GO 29874
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29896: LD_VAR 0 11
29900: PPUSH
29901: LD_VAR 0 12
29905: PPUSH
29906: CALL_OW 351
29910: PUSH
29911: LD_VAR 0 11
29915: PPUSH
29916: LD_VAR 0 12
29920: PPUSH
29921: CALL_OW 554
29925: AND
29926: IFFALSE 29966
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29928: LD_ADDR_VAR 0 13
29932: PUSH
29933: LD_VAR 0 13
29937: PPUSH
29938: LD_VAR 0 13
29942: PUSH
29943: LD_INT 1
29945: PLUS
29946: PPUSH
29947: LD_VAR 0 11
29951: PUSH
29952: LD_VAR 0 12
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PPUSH
29961: CALL_OW 2
29965: ST_TO_ADDR
// end ;
29966: GO 29874
29968: POP
29969: POP
29970: GO 29854
29972: POP
29973: POP
// if not list then
29974: LD_VAR 0 13
29978: NOT
29979: IFFALSE 29983
// exit ;
29981: GO 30054
// for i in list do
29983: LD_ADDR_VAR 0 6
29987: PUSH
29988: LD_VAR 0 13
29992: PUSH
29993: FOR_IN
29994: IFFALSE 30052
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29996: LD_VAR 0 1
30000: PPUSH
30001: LD_STRING M
30003: PUSH
30004: LD_VAR 0 6
30008: PUSH
30009: LD_INT 1
30011: ARRAY
30012: PUSH
30013: LD_VAR 0 6
30017: PUSH
30018: LD_INT 2
30020: ARRAY
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: PUSH
30043: EMPTY
30044: LIST
30045: PPUSH
30046: CALL_OW 447
30050: GO 29993
30052: POP
30053: POP
// end ;
30054: LD_VAR 0 5
30058: RET
