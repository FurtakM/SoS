// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3523 0 0
// PrepareLegion ;
  27: CALL 7054 0 0
// Action ;
  31: CALL 10733 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16048 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ;
3486: PPOPN 1
3488: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3489: LD_VAR 0 1
3493: PPUSH
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_VAR 0 3
3503: PPUSH
3504: CALL 20885 0 3
// end ;
3508: PPOPN 3
3510: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: CALL 20983 0 1
// end ; end_of_file
3520: PPOPN 1
3522: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3523: LD_INT 0
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
3529: PPUSH
3530: PPUSH
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
// uc_side := 3 ;
3536: LD_ADDR_OWVAR 20
3540: PUSH
3541: LD_INT 3
3543: ST_TO_ADDR
// uc_nation := nation_russian ;
3544: LD_ADDR_OWVAR 21
3548: PUSH
3549: LD_INT 3
3551: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3552: LD_ADDR_VAR 0 4
3556: PUSH
3557: LD_INT 22
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 30
3569: PUSH
3570: LD_INT 1
3572: PUSH
3573: EMPTY
3574: LIST
3575: LIST
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PPUSH
3581: CALL_OW 69
3585: PUSH
3586: LD_INT 1
3588: ARRAY
3589: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3590: LD_ADDR_VAR 0 5
3594: PUSH
3595: LD_INT 22
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 30
3607: PUSH
3608: LD_INT 3
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PPUSH
3619: CALL_OW 69
3623: PUSH
3624: LD_INT 1
3626: ARRAY
3627: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_INT 22
3635: PUSH
3636: LD_INT 3
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 30
3645: PUSH
3646: LD_INT 34
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 69
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3666: LD_ADDR_VAR 0 8
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 33
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3700: LD_ADDR_VAR 0 7
3704: PUSH
3705: LD_INT 22
3707: PUSH
3708: LD_INT 3
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 30
3717: PUSH
3718: LD_INT 5
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PPUSH
3729: CALL_OW 69
3733: PUSH
3734: LD_INT 1
3736: ARRAY
3737: ST_TO_ADDR
// ru_blist := [ ] ;
3738: LD_ADDR_EXP 26
3742: PUSH
3743: EMPTY
3744: ST_TO_ADDR
// ru_vlist := [ ] ;
3745: LD_ADDR_EXP 27
3749: PUSH
3750: EMPTY
3751: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3752: LD_ADDR_EXP 30
3756: PUSH
3757: LD_INT 183
3759: PUSH
3760: LD_INT 62
3762: PUSH
3763: LD_INT 147
3765: PUSH
3766: LD_INT 44
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3775: LD_INT 30
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PPUSH
3785: CALL_OW 69
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_EXP 30
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 2
3810: ARRAY
3811: PPUSH
3812: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3816: LD_ADDR_EXP 28
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: LD_INT 5
3826: PUSH
3827: LD_INT 6
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: LIST
3834: PUSH
3835: LD_OWVAR 67
3839: ARRAY
3840: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3841: LD_VAR 0 4
3845: PPUSH
3846: CALL_OW 274
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 3000
3856: PPUSH
3857: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3861: LD_VAR 0 4
3865: PPUSH
3866: CALL_OW 274
3870: PPUSH
3871: LD_INT 2
3873: PPUSH
3874: LD_INT 300
3876: PPUSH
3877: CALL_OW 277
// hc_gallery :=  ;
3881: LD_ADDR_OWVAR 33
3885: PUSH
3886: LD_STRING 
3888: ST_TO_ADDR
// hc_name :=  ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING 
3896: ST_TO_ADDR
// hc_importance := 0 ;
3897: LD_ADDR_OWVAR 32
3901: PUSH
3902: LD_INT 0
3904: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3905: LD_ADDR_EXP 24
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: LD_INT 6
3915: PUSH
3916: LD_INT 7
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: ST_TO_ADDR
// for i = 1 to 6 do
3930: LD_ADDR_VAR 0 2
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 6
3942: PUSH
3943: FOR_TO
3944: IFFALSE 4102
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3946: LD_INT 0
3948: PPUSH
3949: LD_INT 9
3951: PPUSH
3952: LD_EXP 24
3956: PPUSH
3957: CALL_OW 380
// un := CreateHuman ;
3961: LD_ADDR_VAR 0 3
3965: PUSH
3966: CALL_OW 44
3970: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_VAR 0 7
3980: PPUSH
3981: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 4
3990: PPUSH
3991: LD_EXP 24
3995: PPUSH
3996: CALL_OW 380
// un := CreateHuman ;
4000: LD_ADDR_VAR 0 3
4004: PUSH
4005: CALL_OW 44
4009: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4010: LD_VAR 0 3
4014: PPUSH
4015: LD_INT 24
4017: PPUSH
4018: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4022: LD_INT 0
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_EXP 24
4032: PPUSH
4033: CALL_OW 380
// un := CreateHuman ;
4037: LD_ADDR_VAR 0 3
4041: PUSH
4042: CALL_OW 44
4046: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_VAR 0 5
4056: PPUSH
4057: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4061: LD_INT 0
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: LD_EXP 24
4071: PPUSH
4072: CALL_OW 380
// un := CreateHuman ;
4076: LD_ADDR_VAR 0 3
4080: PUSH
4081: CALL_OW 44
4085: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_VAR 0 4
4095: PPUSH
4096: CALL_OW 52
// end ;
4100: GO 3943
4102: POP
4103: POP
// russian_prepared := true ;
4104: LD_ADDR_EXP 2
4108: PUSH
4109: LD_INT 1
4111: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_INT 21
4119: PPUSH
4120: LD_INT 3
4122: PPUSH
4123: LD_INT 3
4125: PPUSH
4126: LD_INT 51
4128: PPUSH
4129: CALL_OW 125
// end ;
4133: LD_VAR 0 1
4137: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4138: LD_INT 22
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 69
4152: PUSH
4153: LD_INT 0
4155: GREATER
4156: PUSH
4157: LD_EXP 2
4161: AND
4162: IFFALSE 6625
4164: GO 4166
4166: DISABLE
4167: LD_INT 0
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
4173: PPUSH
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
// begin enable ;
4186: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4187: LD_ADDR_VAR 0 1
4191: PUSH
4192: LD_INT 22
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 30
4204: PUSH
4205: LD_INT 1
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PPUSH
4216: CALL_OW 69
4220: PUSH
4221: LD_INT 1
4223: ARRAY
4224: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: LD_INT 22
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 30
4242: PUSH
4243: LD_INT 3
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: PUSH
4259: LD_INT 1
4261: ARRAY
4262: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4263: LD_ADDR_VAR 0 3
4267: PUSH
4268: LD_INT 22
4270: PUSH
4271: LD_INT 3
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PUSH
4278: LD_INT 30
4280: PUSH
4281: LD_INT 34
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PPUSH
4292: CALL_OW 69
4296: PUSH
4297: LD_INT 1
4299: ARRAY
4300: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4301: LD_ADDR_VAR 0 4
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4335: LD_ADDR_VAR 0 8
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 3
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 30
4352: PUSH
4353: LD_INT 5
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PPUSH
4364: CALL_OW 69
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4373: LD_ADDR_VAR 0 5
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4407: LD_ADDR_VAR 0 6
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4441: LD_ADDR_VAR 0 7
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 1
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4475: LD_ADDR_VAR 0 9
4479: PUSH
4480: LD_VAR 0 7
4484: PPUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PPUSH
4495: CALL_OW 72
4499: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4500: LD_ADDR_VAR 0 10
4504: PUSH
4505: LD_VAR 0 7
4509: PPUSH
4510: LD_INT 25
4512: PUSH
4513: LD_INT 3
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 72
4524: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4525: LD_ADDR_VAR 0 11
4529: PUSH
4530: LD_VAR 0 7
4534: PPUSH
4535: LD_INT 25
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PPUSH
4545: CALL_OW 72
4549: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4550: LD_INT 22
4552: PUSH
4553: LD_INT 3
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 34
4562: PUSH
4563: LD_INT 51
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: CALL_OW 69
4578: PUSH
4579: LD_INT 0
4581: GREATER
4582: PUSH
4583: LD_EXP 25
4587: PUSH
4588: LD_INT 0
4590: EQUAL
4591: AND
4592: IFFALSE 4632
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4594: LD_ADDR_EXP 25
4598: PUSH
4599: LD_INT 22
4601: PUSH
4602: LD_INT 3
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 34
4611: PUSH
4612: LD_INT 51
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 69
4627: PUSH
4628: LD_INT 1
4630: ARRAY
4631: ST_TO_ADDR
// if ru_cargo then
4632: LD_EXP 25
4636: IFFALSE 4934
// begin if IsInArea ( ru_cargo , ru_base ) then
4638: LD_EXP 25
4642: PPUSH
4643: LD_INT 9
4645: PPUSH
4646: CALL_OW 308
4650: IFFALSE 4729
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4652: LD_EXP 25
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: EQUAL
4668: IFFALSE 4686
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4670: LD_EXP 25
4674: PPUSH
4675: LD_VAR 0 3
4679: PPUSH
4680: CALL_OW 120
4684: GO 4727
// if not HasTask ( ru_cargo ) then
4686: LD_EXP 25
4690: PPUSH
4691: CALL_OW 314
4695: NOT
4696: IFFALSE 4727
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4698: LD_EXP 25
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 250
4712: PPUSH
4713: LD_VAR 0 1
4717: PPUSH
4718: CALL_OW 251
4722: PPUSH
4723: CALL_OW 111
// end else
4727: GO 4934
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4729: LD_EXP 25
4733: PPUSH
4734: CALL_OW 314
4738: NOT
4739: PUSH
4740: LD_EXP 25
4744: PPUSH
4745: LD_INT 1
4747: PPUSH
4748: CALL_OW 289
4752: PUSH
4753: LD_INT 100
4755: LESS
4756: AND
4757: IFFALSE 4823
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4759: LD_ADDR_VAR 0 16
4763: PUSH
4764: LD_INT 11
4766: PPUSH
4767: CALL_OW 435
4771: ST_TO_ADDR
// if cr > 0 then
4772: LD_VAR 0 16
4776: PUSH
4777: LD_INT 0
4779: GREATER
4780: IFFALSE 4811
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4782: LD_EXP 25
4786: PPUSH
4787: LD_VAR 0 16
4791: PUSH
4792: LD_INT 1
4794: ARRAY
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 2
4803: ARRAY
4804: PPUSH
4805: CALL_OW 117
4809: GO 4823
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4811: LD_EXP 25
4815: PPUSH
4816: LD_INT 11
4818: PPUSH
4819: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4823: LD_EXP 25
4827: PPUSH
4828: CALL_OW 314
4832: NOT
4833: PUSH
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 308
4846: NOT
4847: AND
4848: PUSH
4849: LD_EXP 25
4853: PPUSH
4854: LD_INT 1
4856: PPUSH
4857: CALL_OW 289
4861: PUSH
4862: LD_INT 100
4864: EQUAL
4865: AND
4866: IFFALSE 4880
// ComMoveToArea ( ru_cargo , cargoa ) ;
4868: LD_EXP 25
4872: PPUSH
4873: LD_INT 10
4875: PPUSH
4876: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4880: LD_EXP 25
4884: PPUSH
4885: LD_INT 10
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_VAR 0 8
4897: AND
4898: IFFALSE 4934
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4900: LD_VAR 0 7
4904: PPUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 9
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 72
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 139
4926: PPUSH
4927: LD_INT 24
4929: PPUSH
4930: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4934: LD_EXP 25
4938: PUSH
4939: LD_INT 0
4941: EQUAL
4942: PUSH
4943: LD_VAR 0 2
4947: AND
4948: PUSH
4949: LD_VAR 0 2
4953: PPUSH
4954: CALL_OW 461
4958: PUSH
4959: LD_INT 2
4961: EQUAL
4962: AND
4963: IFFALSE 4986
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4965: LD_VAR 0 2
4969: PPUSH
4970: LD_INT 21
4972: PPUSH
4973: LD_INT 3
4975: PPUSH
4976: LD_INT 3
4978: PPUSH
4979: LD_INT 51
4981: PPUSH
4982: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4986: LD_VAR 0 7
4990: PPUSH
4991: LD_INT 25
4993: PUSH
4994: LD_INT 9
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 72
5005: IFFALSE 5069
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5007: LD_VAR 0 7
5011: PPUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 9
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PPUSH
5022: CALL_OW 72
5026: PPUSH
5027: LD_INT 22
5029: PUSH
5030: LD_OWVAR 2
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 3
5041: PUSH
5042: LD_INT 21
5044: PUSH
5045: LD_INT 3
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PPUSH
5065: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5069: LD_VAR 0 2
5073: PUSH
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 0
5081: GREATER
5082: AND
5083: IFFALSE 5183
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5085: LD_VAR 0 2
5089: PPUSH
5090: CALL_OW 461
5094: PUSH
5095: LD_INT 2
5097: EQUAL
5098: IFFALSE 5183
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5100: LD_VAR 0 2
5104: PPUSH
5105: LD_EXP 27
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 2
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 3
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 4
5139: ARRAY
5140: PPUSH
5141: CALL_OW 125
// for i = 1 to 4 do
5145: LD_ADDR_VAR 0 12
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 4
5157: PUSH
5158: FOR_TO
5159: IFFALSE 5181
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5161: LD_ADDR_EXP 27
5165: PUSH
5166: LD_EXP 27
5170: PPUSH
5171: LD_INT 1
5173: PPUSH
5174: CALL_OW 3
5178: ST_TO_ADDR
5179: GO 5158
5181: POP
5182: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5183: LD_INT 24
5185: PPUSH
5186: CALL_OW 461
5190: PUSH
5191: LD_INT 2
5193: EQUAL
5194: PUSH
5195: LD_EXP 4
5199: AND
5200: IFFALSE 5228
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5202: LD_INT 25
5204: PPUSH
5205: LD_INT 3
5207: PPUSH
5208: CALL_OW 321
5212: PUSH
5213: LD_INT 1
5215: EQUAL
5216: IFFALSE 5228
// ComResearch ( ru_lab , tech_sibfiss ) ;
5218: LD_INT 24
5220: PPUSH
5221: LD_INT 25
5223: PPUSH
5224: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5228: LD_INT 25
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: CALL_OW 321
5238: PUSH
5239: LD_INT 2
5241: EQUAL
5242: PUSH
5243: LD_OWVAR 1
5247: PUSH
5248: LD_INT 10500
5250: MOD
5251: PUSH
5252: LD_INT 0
5254: EQUAL
5255: AND
5256: IFFALSE 5294
// if BuildingStatus ( ru_factory ) = bs_idle then
5258: LD_VAR 0 2
5262: PPUSH
5263: CALL_OW 461
5267: PUSH
5268: LD_INT 2
5270: EQUAL
5271: IFFALSE 5294
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5273: LD_VAR 0 2
5277: PPUSH
5278: LD_INT 23
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: LD_INT 3
5286: PPUSH
5287: LD_INT 48
5289: PPUSH
5290: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5294: LD_INT 22
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_INT 48
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: PPUSH
5318: CALL_OW 69
5322: PUSH
5323: LD_INT 0
5325: GREATER
5326: IFFALSE 5700
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5328: LD_ADDR_VAR 0 17
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 3
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 34
5345: PUSH
5346: LD_INT 48
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL_OW 69
5361: PUSH
5362: LD_INT 1
5364: ARRAY
5365: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5366: LD_VAR 0 17
5370: PPUSH
5371: LD_INT 9
5373: PPUSH
5374: CALL_OW 308
5378: IFFALSE 5396
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5380: LD_VAR 0 17
5384: PPUSH
5385: LD_VAR 0 3
5389: PPUSH
5390: CALL_OW 120
5394: GO 5700
// if not HasTask ( sib_bomb ) then
5396: LD_VAR 0 17
5400: PPUSH
5401: CALL_OW 314
5405: NOT
5406: IFFALSE 5700
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5408: LD_INT 22
5410: PUSH
5411: LD_OWVAR 2
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: PUSH
5420: LD_INT 30
5422: PUSH
5423: LD_INT 1
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PPUSH
5434: CALL_OW 69
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_INT 250
5450: GREATER
5451: IFFALSE 5544
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5453: LD_VAR 0 17
5457: PPUSH
5458: LD_INT 22
5460: PUSH
5461: LD_OWVAR 2
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 30
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 69
5488: PUSH
5489: LD_INT 1
5491: ARRAY
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 22
5500: PUSH
5501: LD_OWVAR 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 30
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 69
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: CALL_OW 251
5537: PPUSH
5538: CALL_OW 116
5542: GO 5700
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5544: LD_INT 22
5546: PUSH
5547: LD_OWVAR 2
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 21
5558: PUSH
5559: LD_INT 3
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 69
5574: PUSH
5575: LD_INT 0
5577: GREATER
5578: IFFALSE 5671
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5580: LD_VAR 0 17
5584: PPUSH
5585: LD_INT 22
5587: PUSH
5588: LD_OWVAR 2
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: LD_INT 21
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_INT 1
5618: ARRAY
5619: PPUSH
5620: CALL_OW 250
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_OWVAR 2
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 21
5639: PUSH
5640: LD_INT 3
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: PUSH
5656: LD_INT 1
5658: ARRAY
5659: PPUSH
5660: CALL_OW 251
5664: PPUSH
5665: CALL_OW 116
5669: GO 5700
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5671: LD_VAR 0 17
5675: PPUSH
5676: LD_EXP 10
5680: PPUSH
5681: CALL_OW 250
5685: PPUSH
5686: LD_EXP 10
5690: PPUSH
5691: CALL_OW 251
5695: PPUSH
5696: CALL_OW 116
// end ; if ru_can_attack then
5700: LD_EXP 3
5704: IFFALSE 5852
// if ru_time > 0 0$00 then
5706: LD_EXP 29
5710: PUSH
5711: LD_INT 0
5713: GREATER
5714: IFFALSE 5732
// ru_time := ru_time - 0 0$01 else
5716: LD_ADDR_EXP 29
5720: PUSH
5721: LD_EXP 29
5725: PUSH
5726: LD_INT 35
5728: MINUS
5729: ST_TO_ADDR
5730: GO 5852
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5732: LD_ADDR_EXP 29
5736: PUSH
5737: LD_INT 20265
5739: PPUSH
5740: LD_INT 30765
5742: PPUSH
5743: CALL_OW 12
5747: ST_TO_ADDR
// for i = 1 to ru_amount do
5748: LD_ADDR_VAR 0 12
5752: PUSH
5753: DOUBLE
5754: LD_INT 1
5756: DEC
5757: ST_TO_ADDR
5758: LD_EXP 28
5762: PUSH
5763: FOR_TO
5764: IFFALSE 5850
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5766: LD_ADDR_EXP 27
5770: PUSH
5771: LD_EXP 27
5775: PUSH
5776: LD_INT 23
5778: ADD
5779: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5780: LD_ADDR_EXP 27
5784: PUSH
5785: LD_EXP 27
5789: PUSH
5790: LD_INT 3
5792: ADD
5793: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5794: LD_ADDR_EXP 27
5798: PUSH
5799: LD_EXP 27
5803: PUSH
5804: LD_INT 3
5806: ADD
5807: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5808: LD_ADDR_EXP 27
5812: PUSH
5813: LD_EXP 27
5817: PUSH
5818: LD_INT 46
5820: PUSH
5821: LD_INT 45
5823: PUSH
5824: LD_INT 47
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 2
5837: PPUSH
5838: LD_INT 3
5840: PPUSH
5841: CALL_OW 14
5845: ARRAY
5846: ADD
5847: ST_TO_ADDR
// end ;
5848: GO 5763
5850: POP
5851: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5852: LD_VAR 0 4
5856: PPUSH
5857: LD_INT 35
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PPUSH
5867: CALL_OW 72
5871: PUSH
5872: LD_INT 0
5874: GREATER
5875: IFFALSE 5923
// if BuildingStatus ( ru_factory ) = bs_idle then
5877: LD_VAR 0 2
5881: PPUSH
5882: CALL_OW 461
5886: PUSH
5887: LD_INT 2
5889: EQUAL
5890: IFFALSE 5923
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5892: LD_VAR 0 4
5896: PPUSH
5897: LD_INT 35
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PPUSH
5907: CALL_OW 72
5911: PUSH
5912: LD_INT 1
5914: ARRAY
5915: PPUSH
5916: LD_INT 47
5918: PPUSH
5919: CALL_OW 148
// if ru_force = ru_amount then
5923: LD_EXP 23
5927: PUSH
5928: LD_EXP 28
5932: EQUAL
5933: IFFALSE 6065
// begin for i = 1 to ru_force do
5935: LD_ADDR_VAR 0 12
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_EXP 23
5949: PUSH
5950: FOR_TO
5951: IFFALSE 6061
// if IsInArea ( ru_force [ i ] , ru_base ) then
5953: LD_EXP 23
5957: PUSH
5958: LD_VAR 0 12
5962: ARRAY
5963: PPUSH
5964: LD_INT 9
5966: PPUSH
5967: CALL_OW 308
5971: IFFALSE 5995
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5973: LD_EXP 23
5977: PUSH
5978: LD_VAR 0 12
5982: ARRAY
5983: PPUSH
5984: LD_VAR 0 3
5988: PPUSH
5989: CALL_OW 120
5993: GO 6059
// if not HasTask ( ru_force [ i ] ) then
5995: LD_EXP 23
5999: PUSH
6000: LD_VAR 0 12
6004: ARRAY
6005: PPUSH
6006: CALL_OW 314
6010: NOT
6011: IFFALSE 6059
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6013: LD_EXP 23
6017: PUSH
6018: LD_VAR 0 12
6022: ARRAY
6023: PPUSH
6024: LD_INT 81
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PPUSH
6034: CALL_OW 69
6038: PPUSH
6039: LD_EXP 23
6043: PUSH
6044: LD_VAR 0 12
6048: ARRAY
6049: PPUSH
6050: CALL_OW 74
6054: PPUSH
6055: CALL_OW 115
6059: GO 5950
6061: POP
6062: POP
// end else
6063: GO 6215
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6065: LD_EXP 23
6069: PPUSH
6070: LD_INT 3
6072: PUSH
6073: LD_INT 95
6075: PUSH
6076: LD_INT 18
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: PUSH
6092: LD_INT 0
6094: GREATER
6095: IFFALSE 6215
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6097: LD_ADDR_VAR 0 13
6101: PUSH
6102: LD_EXP 23
6106: PPUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 95
6112: PUSH
6113: LD_INT 18
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 72
6128: ST_TO_ADDR
// for i = 1 to tmp do
6129: LD_ADDR_VAR 0 12
6133: PUSH
6134: DOUBLE
6135: LD_INT 1
6137: DEC
6138: ST_TO_ADDR
6139: LD_VAR 0 13
6143: PUSH
6144: FOR_TO
6145: IFFALSE 6213
// if not HasTask ( tmp [ i ] ) then
6147: LD_VAR 0 13
6151: PUSH
6152: LD_VAR 0 12
6156: ARRAY
6157: PPUSH
6158: CALL_OW 314
6162: NOT
6163: IFFALSE 6211
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6165: LD_EXP 23
6169: PUSH
6170: LD_VAR 0 12
6174: ARRAY
6175: PPUSH
6176: LD_INT 81
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PPUSH
6191: LD_EXP 23
6195: PUSH
6196: LD_VAR 0 12
6200: ARRAY
6201: PPUSH
6202: CALL_OW 74
6206: PPUSH
6207: CALL_OW 115
6211: GO 6144
6213: POP
6214: POP
// end ; if ru_engs > 0 then
6215: LD_VAR 0 9
6219: PUSH
6220: LD_INT 0
6222: GREATER
6223: IFFALSE 6625
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6225: LD_VAR 0 5
6229: PPUSH
6230: LD_INT 3
6232: PUSH
6233: LD_INT 24
6235: PUSH
6236: LD_INT 1000
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_INT 0
6254: GREATER
6255: IFFALSE 6410
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6257: LD_ADDR_VAR 0 14
6261: PUSH
6262: LD_VAR 0 5
6266: PPUSH
6267: LD_INT 3
6269: PUSH
6270: LD_INT 24
6272: PUSH
6273: LD_INT 1000
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 72
6288: ST_TO_ADDR
// for i = 1 to ru_engs do
6289: LD_ADDR_VAR 0 12
6293: PUSH
6294: DOUBLE
6295: LD_INT 1
6297: DEC
6298: ST_TO_ADDR
6299: LD_VAR 0 9
6303: PUSH
6304: FOR_TO
6305: IFFALSE 6406
// begin if IsInUnit ( ru_engs [ i ] ) then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 310
6322: IFFALSE 6341
// ComExitBuilding ( ru_engs [ i ] ) else
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 122
6339: GO 6404
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6341: LD_VAR 0 9
6345: PUSH
6346: LD_VAR 0 12
6350: ARRAY
6351: PPUSH
6352: CALL_OW 314
6356: NOT
6357: PUSH
6358: LD_VAR 0 9
6362: PUSH
6363: LD_VAR 0 12
6367: ARRAY
6368: PPUSH
6369: CALL_OW 256
6373: PUSH
6374: LD_INT 600
6376: GREATER
6377: AND
6378: IFFALSE 6404
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6380: LD_VAR 0 9
6384: PUSH
6385: LD_VAR 0 12
6389: ARRAY
6390: PPUSH
6391: LD_VAR 0 14
6395: PUSH
6396: LD_INT 1
6398: ARRAY
6399: PPUSH
6400: CALL_OW 130
// end ;
6404: GO 6304
6406: POP
6407: POP
// end else
6408: GO 6625
// begin if ru_blist = 0 then
6410: LD_EXP 26
6414: PUSH
6415: LD_INT 0
6417: EQUAL
6418: IFFALSE 6500
// begin for i = 1 to ru_engs do
6420: LD_ADDR_VAR 0 12
6424: PUSH
6425: DOUBLE
6426: LD_INT 1
6428: DEC
6429: ST_TO_ADDR
6430: LD_VAR 0 9
6434: PUSH
6435: FOR_TO
6436: IFFALSE 6496
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6438: LD_VAR 0 9
6442: PUSH
6443: LD_VAR 0 12
6447: ARRAY
6448: PPUSH
6449: CALL_OW 314
6453: NOT
6454: PUSH
6455: LD_VAR 0 9
6459: PUSH
6460: LD_VAR 0 12
6464: ARRAY
6465: PPUSH
6466: CALL_OW 310
6470: NOT
6471: AND
6472: IFFALSE 6494
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6474: LD_VAR 0 9
6478: PUSH
6479: LD_VAR 0 12
6483: ARRAY
6484: PPUSH
6485: LD_VAR 0 1
6489: PPUSH
6490: CALL_OW 120
6494: GO 6435
6496: POP
6497: POP
// end else
6498: GO 6625
// begin for i = 1 to ru_engs do
6500: LD_ADDR_VAR 0 12
6504: PUSH
6505: DOUBLE
6506: LD_INT 1
6508: DEC
6509: ST_TO_ADDR
6510: LD_VAR 0 9
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6623
// begin if IsInUnit ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 310
6533: IFFALSE 6552
// ComExitBuilding ( ru_engs [ i ] ) else
6535: LD_VAR 0 9
6539: PUSH
6540: LD_VAR 0 12
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
6550: GO 6621
// if not HasTask ( ru_engs [ i ] ) then
6552: LD_VAR 0 9
6556: PUSH
6557: LD_VAR 0 12
6561: ARRAY
6562: PPUSH
6563: CALL_OW 314
6567: NOT
6568: IFFALSE 6621
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6570: LD_VAR 0 9
6574: PUSH
6575: LD_VAR 0 12
6579: ARRAY
6580: PPUSH
6581: LD_EXP 26
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 2
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 3
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 4
6615: ARRAY
6616: PPUSH
6617: CALL_OW 145
// end ;
6621: GO 6515
6623: POP
6624: POP
// end ; end ; end ; end ;
6625: PPOPN 17
6627: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6628: LD_EXP 2
6632: PUSH
6633: LD_INT 11
6635: PPUSH
6636: CALL_OW 435
6640: PUSH
6641: LD_INT 20
6643: LESS
6644: AND
6645: IFFALSE 6708
6647: GO 6649
6649: DISABLE
// begin enable ;
6650: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6651: LD_INT 1
6653: PPUSH
6654: LD_INT 5
6656: PPUSH
6657: CALL_OW 12
6661: PPUSH
6662: LD_INT 11
6664: PPUSH
6665: LD_INT 1
6667: PPUSH
6668: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6672: LD_INT 1505
6674: PPUSH
6675: LD_INT 2100
6677: PPUSH
6678: CALL_OW 12
6682: PPUSH
6683: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 5
6692: PPUSH
6693: CALL_OW 12
6697: PPUSH
6698: LD_INT 11
6700: PPUSH
6701: LD_INT 1
6703: PPUSH
6704: CALL_OW 55
// end ;
6708: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6709: LD_EXP 4
6713: PUSH
6714: LD_INT 0
6716: EQUAL
6717: IFFALSE 6832
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
6725: PPUSH
// begin enable ;
6726: ENABLE
// i := Rand ( 0 , 100 ) ;
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: LD_INT 0
6734: PPUSH
6735: LD_INT 100
6737: PPUSH
6738: CALL_OW 12
6742: ST_TO_ADDR
// case your_side of 1 :
6743: LD_OWVAR 2
6747: PUSH
6748: LD_INT 1
6750: DOUBLE
6751: EQUAL
6752: IFTRUE 6756
6754: GO 6767
6756: POP
// tmp := 10 ; 2 :
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 10
6764: ST_TO_ADDR
6765: GO 6806
6767: LD_INT 2
6769: DOUBLE
6770: EQUAL
6771: IFTRUE 6775
6773: GO 6786
6775: POP
// tmp := 0 ; 7 :
6776: LD_ADDR_VAR 0 2
6780: PUSH
6781: LD_INT 0
6783: ST_TO_ADDR
6784: GO 6806
6786: LD_INT 7
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6805
6794: POP
// tmp := 15 ; end ;
6795: LD_ADDR_VAR 0 2
6799: PUSH
6800: LD_INT 15
6802: ST_TO_ADDR
6803: GO 6806
6805: POP
// if i < chance_to_bomb + tmp then
6806: LD_VAR 0 1
6810: PUSH
6811: LD_EXP 5
6815: PUSH
6816: LD_VAR 0 2
6820: PLUS
6821: LESS
6822: IFFALSE 6832
// ru_sib_bomb := true ;
6824: LD_ADDR_EXP 4
6828: PUSH
6829: LD_INT 1
6831: ST_TO_ADDR
// end ;
6832: PPOPN 2
6834: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6835: LD_INT 22
6837: PUSH
6838: LD_OWVAR 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 34
6849: PUSH
6850: LD_INT 8
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 69
6865: IFFALSE 6878
6867: GO 6869
6869: DISABLE
// begin ru_sib_bomb := true ;
6870: LD_ADDR_EXP 4
6874: PUSH
6875: LD_INT 1
6877: ST_TO_ADDR
// end ;
6878: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6879: LD_INT 22
6881: PUSH
6882: LD_INT 3
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 30
6891: PUSH
6892: LD_INT 34
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PPUSH
6903: CALL_OW 69
6907: IFFALSE 7006
6909: GO 6911
6911: DISABLE
6912: LD_INT 0
6914: PPUSH
// begin enable ;
6915: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 1
6933: PPUSH
6934: LD_INT 2
6936: PPUSH
6937: CALL_OW 12
6941: ARRAY
6942: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6943: LD_INT 22
6945: PUSH
6946: LD_INT 3
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: LD_INT 30
6955: PUSH
6956: LD_INT 34
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_EXP 30
6980: PUSH
6981: LD_VAR 0 1
6985: ARRAY
6986: PPUSH
6987: LD_EXP 30
6991: PUSH
6992: LD_VAR 0 1
6996: PUSH
6997: LD_INT 1
6999: PLUS
7000: ARRAY
7001: PPUSH
7002: CALL_OW 243
// end ; end_of_file
7006: PPOPN 1
7008: END
// export function RemoveLegion ; var i ; begin
7009: LD_INT 0
7011: PPUSH
7012: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7013: LD_ADDR_VAR 0 2
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 69
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7047
// RemoveUnit ( i ) ;
7036: LD_VAR 0 2
7040: PPUSH
7041: CALL_OW 64
7045: GO 7033
7047: POP
7048: POP
// end ;
7049: LD_VAR 0 1
7053: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
7059: PPUSH
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
7064: PPUSH
7065: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7066: LD_ADDR_VAR 0 7
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 8
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 30
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL_OW 69
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7104: LD_ADDR_VAR 0 8
7108: PUSH
7109: LD_INT 22
7111: PUSH
7112: LD_INT 8
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 30
7121: PUSH
7122: LD_INT 3
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PPUSH
7133: CALL_OW 69
7137: PUSH
7138: LD_INT 1
7140: ARRAY
7141: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7142: LD_ADDR_VAR 0 9
7146: PUSH
7147: LD_INT 22
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: LD_INT 30
7162: PUSH
7163: LD_INT 6
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 30
7172: PUSH
7173: LD_INT 8
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PPUSH
7189: CALL_OW 69
7193: PUSH
7194: LD_INT 1
7196: ARRAY
7197: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7198: LD_ADDR_VAR 0 10
7202: PUSH
7203: LD_INT 22
7205: PUSH
7206: LD_INT 8
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 30
7215: PUSH
7216: LD_INT 32
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL_OW 69
7231: ST_TO_ADDR
// uc_side := 8 ;
7232: LD_ADDR_OWVAR 20
7236: PUSH
7237: LD_INT 8
7239: ST_TO_ADDR
// uc_nation := nation_arabian ;
7240: LD_ADDR_OWVAR 21
7244: PUSH
7245: LD_INT 2
7247: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7248: LD_ADDR_EXP 32
7252: PUSH
7253: LD_INT 5
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: LD_INT 7
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: PUSH
7267: LD_OWVAR 67
7271: ARRAY
7272: ST_TO_ADDR
// legion_blist := [ ] ;
7273: LD_ADDR_EXP 34
7277: PUSH
7278: EMPTY
7279: ST_TO_ADDR
// legion_vlist := [ ] ;
7280: LD_ADDR_EXP 35
7284: PUSH
7285: EMPTY
7286: ST_TO_ADDR
// legion_force := [ ] ;
7287: LD_ADDR_EXP 31
7291: PUSH
7292: EMPTY
7293: ST_TO_ADDR
// legion_enemy := - 1 ;
7294: LD_ADDR_EXP 36
7298: PUSH
7299: LD_INT 1
7301: NEG
7302: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7303: LD_VAR 0 7
7307: PPUSH
7308: CALL_OW 274
7312: PPUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 10000
7318: PPUSH
7319: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7323: LD_VAR 0 7
7327: PPUSH
7328: CALL_OW 274
7332: PPUSH
7333: LD_INT 3
7335: PPUSH
7336: LD_INT 1000
7338: PPUSH
7339: CALL_OW 277
// for i = 1 to l_towers do
7343: LD_ADDR_VAR 0 3
7347: PUSH
7348: DOUBLE
7349: LD_INT 1
7351: DEC
7352: ST_TO_ADDR
7353: LD_VAR 0 10
7357: PUSH
7358: FOR_TO
7359: IFFALSE 7408
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7361: LD_INT 0
7363: PPUSH
7364: LD_INT 1
7366: PPUSH
7367: LD_EXP 32
7371: PPUSH
7372: CALL_OW 380
// un := CreateHuman ;
7376: LD_ADDR_VAR 0 2
7380: PUSH
7381: CALL_OW 44
7385: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7386: LD_VAR 0 2
7390: PPUSH
7391: LD_VAR 0 10
7395: PUSH
7396: LD_VAR 0 3
7400: ARRAY
7401: PPUSH
7402: CALL_OW 52
// end ;
7406: GO 7358
7408: POP
7409: POP
// for i = 1 to 4 do
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: DOUBLE
7416: LD_INT 1
7418: DEC
7419: ST_TO_ADDR
7420: LD_INT 4
7422: PUSH
7423: FOR_TO
7424: IFFALSE 7517
// for p = 1 to 2 do
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: DOUBLE
7432: LD_INT 1
7434: DEC
7435: ST_TO_ADDR
7436: LD_INT 2
7438: PUSH
7439: FOR_TO
7440: IFFALSE 7513
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7442: LD_INT 0
7444: PPUSH
7445: LD_INT 8
7447: PPUSH
7448: LD_EXP 32
7452: PPUSH
7453: CALL_OW 380
// un := CreateHuman ;
7457: LD_ADDR_VAR 0 2
7461: PUSH
7462: CALL_OW 44
7466: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7467: LD_VAR 0 2
7471: PPUSH
7472: LD_INT 22
7474: PUSH
7475: LD_INT 8
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 30
7484: PUSH
7485: LD_INT 5
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PPUSH
7496: CALL_OW 69
7500: PUSH
7501: LD_VAR 0 6
7505: ARRAY
7506: PPUSH
7507: CALL_OW 52
// end ;
7511: GO 7439
7513: POP
7514: POP
7515: GO 7423
7517: POP
7518: POP
// for i = 1 to 4 do
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: DOUBLE
7525: LD_INT 1
7527: DEC
7528: ST_TO_ADDR
7529: LD_INT 4
7531: PUSH
7532: FOR_TO
7533: IFFALSE 7576
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7535: LD_INT 0
7537: PPUSH
7538: LD_INT 4
7540: PPUSH
7541: LD_EXP 32
7545: PPUSH
7546: CALL_OW 380
// un := CreateHuman ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: CALL_OW 44
7559: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7560: LD_VAR 0 2
7564: PPUSH
7565: LD_VAR 0 9
7569: PPUSH
7570: CALL_OW 52
// end ;
7574: GO 7532
7576: POP
7577: POP
// for i = 1 to 6 do
7578: LD_ADDR_VAR 0 3
7582: PUSH
7583: DOUBLE
7584: LD_INT 1
7586: DEC
7587: ST_TO_ADDR
7588: LD_INT 6
7590: PUSH
7591: FOR_TO
7592: IFFALSE 7635
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_EXP 32
7604: PPUSH
7605: CALL_OW 380
// un := CreateHuman ;
7609: LD_ADDR_VAR 0 2
7613: PUSH
7614: CALL_OW 44
7618: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7619: LD_VAR 0 2
7623: PPUSH
7624: LD_VAR 0 8
7628: PPUSH
7629: CALL_OW 52
// end ;
7633: GO 7591
7635: POP
7636: POP
// for i = 1 to 5 do
7637: LD_ADDR_VAR 0 3
7641: PUSH
7642: DOUBLE
7643: LD_INT 1
7645: DEC
7646: ST_TO_ADDR
7647: LD_INT 5
7649: PUSH
7650: FOR_TO
7651: IFFALSE 7694
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7653: LD_INT 0
7655: PPUSH
7656: LD_INT 2
7658: PPUSH
7659: LD_EXP 32
7663: PPUSH
7664: CALL_OW 380
// un := CreateHuman ;
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: CALL_OW 44
7677: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7678: LD_VAR 0 2
7682: PPUSH
7683: LD_VAR 0 7
7687: PPUSH
7688: CALL_OW 52
// end ;
7692: GO 7650
7694: POP
7695: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7696: LD_ADDR_VAR 0 4
7700: PUSH
7701: LD_INT 199
7703: PPUSH
7704: LD_INT 134
7706: PPUSH
7707: LD_INT 216
7709: PPUSH
7710: LD_INT 141
7712: PPUSH
7713: LD_INT 6
7715: PPUSH
7716: CALL 1562 0 5
7720: ST_TO_ADDR
// p := 1 ;
7721: LD_ADDR_VAR 0 6
7725: PUSH
7726: LD_INT 1
7728: ST_TO_ADDR
// for i = 1 to 3 do
7729: LD_ADDR_VAR 0 3
7733: PUSH
7734: DOUBLE
7735: LD_INT 1
7737: DEC
7738: ST_TO_ADDR
7739: LD_INT 3
7741: PUSH
7742: FOR_TO
7743: IFFALSE 7996
// begin vc_chassis := ar_half_tracked ;
7745: LD_ADDR_OWVAR 37
7749: PUSH
7750: LD_INT 14
7752: ST_TO_ADDR
// vc_engine := engine_siberite ;
7753: LD_ADDR_OWVAR 39
7757: PUSH
7758: LD_INT 3
7760: ST_TO_ADDR
// vc_control := control_manual ;
7761: LD_ADDR_OWVAR 38
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7769: LD_ADDR_OWVAR 40
7773: PUSH
7774: LD_INT 31
7776: ST_TO_ADDR
// veh := CreateVehicle ;
7777: LD_ADDR_VAR 0 5
7781: PUSH
7782: CALL_OW 45
7786: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7787: LD_VAR 0 4
7791: PUSH
7792: LD_VAR 0 6
7796: ARRAY
7797: PPUSH
7798: LD_VAR 0 4
7802: PUSH
7803: LD_VAR 0 6
7807: PUSH
7808: LD_INT 1
7810: PLUS
7811: ARRAY
7812: PPUSH
7813: CALL_OW 428
7817: PUSH
7818: LD_INT 0
7820: EQUAL
7821: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7823: LD_VAR 0 5
7827: PPUSH
7828: LD_VAR 0 4
7832: PUSH
7833: LD_VAR 0 6
7837: ARRAY
7838: PPUSH
7839: LD_VAR 0 4
7843: PUSH
7844: LD_VAR 0 6
7848: PUSH
7849: LD_INT 1
7851: PLUS
7852: ARRAY
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 48
7861: GO 7951
// begin repeat p := p + 2 ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_VAR 0 6
7872: PUSH
7873: LD_INT 2
7875: PLUS
7876: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7877: LD_VAR 0 4
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_VAR 0 4
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ARRAY
7902: PPUSH
7903: CALL_OW 428
7907: PUSH
7908: LD_INT 0
7910: EQUAL
7911: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7913: LD_VAR 0 5
7917: PPUSH
7918: LD_VAR 0 4
7922: PUSH
7923: LD_VAR 0 6
7927: ARRAY
7928: PPUSH
7929: LD_VAR 0 4
7933: PUSH
7934: LD_VAR 0 6
7938: PUSH
7939: LD_INT 1
7941: PLUS
7942: ARRAY
7943: PPUSH
7944: LD_INT 0
7946: PPUSH
7947: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7951: LD_INT 0
7953: PPUSH
7954: LD_INT 3
7956: PPUSH
7957: LD_EXP 32
7961: PUSH
7962: LD_INT 1
7964: PLUS
7965: PPUSH
7966: CALL_OW 380
// un := CreateHuman ;
7970: LD_ADDR_VAR 0 2
7974: PUSH
7975: CALL_OW 44
7979: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7980: LD_VAR 0 2
7984: PPUSH
7985: LD_VAR 0 5
7989: PPUSH
7990: CALL_OW 52
// end ;
7994: GO 7742
7996: POP
7997: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7998: LD_INT 198
8000: PPUSH
8001: LD_INT 94
8003: PPUSH
8004: LD_INT 8
8006: PPUSH
8007: LD_INT 10
8009: PPUSH
8010: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8014: LD_INT 167
8016: PPUSH
8017: LD_INT 130
8019: PPUSH
8020: LD_INT 8
8022: PPUSH
8023: LD_INT 10
8025: PPUSH
8026: CALL_OW 330
// legion_mines := [ ] ;
8030: LD_ADDR_EXP 33
8034: PUSH
8035: EMPTY
8036: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8037: LD_ADDR_EXP 33
8041: PUSH
8042: LD_INT 176
8044: PPUSH
8045: LD_INT 122
8047: PPUSH
8048: LD_INT 188
8050: PPUSH
8051: LD_INT 126
8053: PPUSH
8054: LD_INT 6
8056: PPUSH
8057: CALL 1562 0 5
8061: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8062: LD_ADDR_EXP 33
8066: PUSH
8067: LD_EXP 33
8071: PUSH
8072: LD_INT 197
8074: PPUSH
8075: LD_INT 91
8077: PPUSH
8078: LD_INT 205
8080: PPUSH
8081: LD_INT 96
8083: PPUSH
8084: LD_INT 4
8086: PPUSH
8087: CALL 1562 0 5
8091: ADD
8092: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8093: LD_ADDR_EXP 33
8097: PUSH
8098: LD_EXP 33
8102: PUSH
8103: LD_INT 184
8105: PPUSH
8106: LD_INT 151
8108: PPUSH
8109: LD_INT 178
8111: PPUSH
8112: LD_INT 130
8114: PPUSH
8115: LD_INT 9
8117: PPUSH
8118: CALL 1562 0 5
8122: ADD
8123: ST_TO_ADDR
// if Difficulty > 1 then
8124: LD_OWVAR 67
8128: PUSH
8129: LD_INT 1
8131: GREATER
8132: IFFALSE 8165
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8134: LD_ADDR_EXP 33
8138: PUSH
8139: LD_EXP 33
8143: PUSH
8144: LD_INT 166
8146: PPUSH
8147: LD_INT 126
8149: PPUSH
8150: LD_INT 181
8152: PPUSH
8153: LD_INT 136
8155: PPUSH
8156: LD_INT 5
8158: PPUSH
8159: CALL 1562 0 5
8163: ADD
8164: ST_TO_ADDR
// p := 1 ;
8165: LD_ADDR_VAR 0 6
8169: PUSH
8170: LD_INT 1
8172: ST_TO_ADDR
// for i = 1 to 24 do
8173: LD_ADDR_VAR 0 3
8177: PUSH
8178: DOUBLE
8179: LD_INT 1
8181: DEC
8182: ST_TO_ADDR
8183: LD_INT 24
8185: PUSH
8186: FOR_TO
8187: IFFALSE 8241
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8189: LD_EXP 33
8193: PUSH
8194: LD_VAR 0 6
8198: ARRAY
8199: PPUSH
8200: LD_EXP 33
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: LD_INT 1
8212: PLUS
8213: ARRAY
8214: PPUSH
8215: LD_INT 8
8217: PPUSH
8218: LD_INT 0
8220: PPUSH
8221: CALL_OW 454
// p := p + 2 ;
8225: LD_ADDR_VAR 0 6
8229: PUSH
8230: LD_VAR 0 6
8234: PUSH
8235: LD_INT 2
8237: PLUS
8238: ST_TO_ADDR
// end ;
8239: GO 8186
8241: POP
8242: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8243: LD_ADDR_EXP 35
8247: PUSH
8248: LD_INT 13
8250: PUSH
8251: LD_INT 3
8253: PUSH
8254: LD_INT 2
8256: PUSH
8257: LD_INT 32
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: ST_TO_ADDR
// end ;
8266: LD_VAR 0 1
8270: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 69
8285: PUSH
8286: LD_INT 0
8288: GREATER
8289: IFFALSE 10475
8291: GO 8293
8293: DISABLE
8294: LD_INT 0
8296: PPUSH
8297: PPUSH
8298: PPUSH
8299: PPUSH
8300: PPUSH
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
// begin enable ;
8313: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_INT 22
8321: PUSH
8322: LD_INT 8
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: LD_INT 30
8331: PUSH
8332: LD_INT 1
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PPUSH
8343: CALL_OW 69
8347: PUSH
8348: LD_INT 1
8350: ARRAY
8351: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8352: LD_ADDR_VAR 0 9
8356: PUSH
8357: LD_INT 22
8359: PUSH
8360: LD_INT 8
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 30
8369: PUSH
8370: LD_INT 3
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8390: LD_ADDR_VAR 0 10
8394: PUSH
8395: LD_INT 22
8397: PUSH
8398: LD_INT 8
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 2
8407: PUSH
8408: LD_INT 30
8410: PUSH
8411: LD_INT 6
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 30
8420: PUSH
8421: LD_INT 8
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PPUSH
8437: CALL_OW 69
8441: PUSH
8442: LD_INT 1
8444: ARRAY
8445: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8446: LD_ADDR_VAR 0 11
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 32
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8480: LD_ADDR_VAR 0 16
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 2
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8514: LD_ADDR_VAR 0 15
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8548: LD_ADDR_VAR 0 14
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 3
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8582: LD_ADDR_VAR 0 13
8586: PUSH
8587: LD_INT 22
8589: PUSH
8590: LD_INT 8
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: PUSH
8597: LD_INT 25
8599: PUSH
8600: LD_INT 4
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PPUSH
8611: CALL_OW 69
8615: ST_TO_ADDR
// if l_eng then
8616: LD_VAR 0 16
8620: IFFALSE 9035
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8622: LD_ADDR_VAR 0 5
8626: PUSH
8627: LD_INT 22
8629: PUSH
8630: LD_INT 8
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: LD_INT 21
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PPUSH
8651: CALL_OW 69
8655: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8656: LD_VAR 0 5
8660: PPUSH
8661: LD_INT 3
8663: PUSH
8664: LD_INT 24
8666: PUSH
8667: LD_INT 1000
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL_OW 72
8682: PUSH
8683: LD_INT 0
8685: GREATER
8686: IFFALSE 8820
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8688: LD_ADDR_VAR 0 3
8692: PUSH
8693: LD_VAR 0 5
8697: PPUSH
8698: LD_INT 3
8700: PUSH
8701: LD_INT 24
8703: PUSH
8704: LD_INT 1000
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PPUSH
8715: CALL_OW 72
8719: ST_TO_ADDR
// for i = 1 to l_eng do
8720: LD_ADDR_VAR 0 2
8724: PUSH
8725: DOUBLE
8726: LD_INT 1
8728: DEC
8729: ST_TO_ADDR
8730: LD_VAR 0 16
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8816
// if IsInUnit ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 310
8753: IFFALSE 8772
// ComExitBuilding ( l_eng [ i ] ) else
8755: LD_VAR 0 16
8759: PUSH
8760: LD_VAR 0 2
8764: ARRAY
8765: PPUSH
8766: CALL_OW 122
8770: GO 8814
// if not HasTask ( l_eng [ i ] ) then
8772: LD_VAR 0 16
8776: PUSH
8777: LD_VAR 0 2
8781: ARRAY
8782: PPUSH
8783: CALL_OW 314
8787: NOT
8788: IFFALSE 8814
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8790: LD_VAR 0 16
8794: PUSH
8795: LD_VAR 0 2
8799: ARRAY
8800: PPUSH
8801: LD_VAR 0 3
8805: PUSH
8806: LD_INT 1
8808: ARRAY
8809: PPUSH
8810: CALL_OW 130
8814: GO 8735
8816: POP
8817: POP
// end else
8818: GO 9035
// begin if legion_blist > 0 then
8820: LD_EXP 34
8824: PUSH
8825: LD_INT 0
8827: GREATER
8828: IFFALSE 8957
// begin for i = 1 to l_eng do
8830: LD_ADDR_VAR 0 2
8834: PUSH
8835: DOUBLE
8836: LD_INT 1
8838: DEC
8839: ST_TO_ADDR
8840: LD_VAR 0 16
8844: PUSH
8845: FOR_TO
8846: IFFALSE 8953
// if IsInUnit ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 310
8863: IFFALSE 8882
// ComExitBuilding ( l_eng [ i ] ) else
8865: LD_VAR 0 16
8869: PUSH
8870: LD_VAR 0 2
8874: ARRAY
8875: PPUSH
8876: CALL_OW 122
8880: GO 8951
// if not HasTask ( l_eng [ i ] ) then
8882: LD_VAR 0 16
8886: PUSH
8887: LD_VAR 0 2
8891: ARRAY
8892: PPUSH
8893: CALL_OW 314
8897: NOT
8898: IFFALSE 8951
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8900: LD_VAR 0 16
8904: PUSH
8905: LD_VAR 0 2
8909: ARRAY
8910: PPUSH
8911: LD_EXP 34
8915: PUSH
8916: LD_INT 1
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 2
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 3
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 4
8945: ARRAY
8946: PPUSH
8947: CALL_OW 145
8951: GO 8845
8953: POP
8954: POP
// end else
8955: GO 9035
// for i = 1 to l_eng do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: DOUBLE
8963: LD_INT 1
8965: DEC
8966: ST_TO_ADDR
8967: LD_VAR 0 16
8971: PUSH
8972: FOR_TO
8973: IFFALSE 9033
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8975: LD_VAR 0 16
8979: PUSH
8980: LD_VAR 0 2
8984: ARRAY
8985: PPUSH
8986: CALL_OW 310
8990: NOT
8991: PUSH
8992: LD_VAR 0 16
8996: PUSH
8997: LD_VAR 0 2
9001: ARRAY
9002: PPUSH
9003: CALL_OW 314
9007: NOT
9008: AND
9009: IFFALSE 9031
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9011: LD_VAR 0 16
9015: PUSH
9016: LD_VAR 0 2
9020: ARRAY
9021: PPUSH
9022: LD_VAR 0 8
9026: PPUSH
9027: CALL_OW 120
9031: GO 8972
9033: POP
9034: POP
// end ; end ; if l_factory then
9035: LD_VAR 0 9
9039: IFFALSE 9439
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9041: LD_INT 22
9043: PUSH
9044: LD_INT 8
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: LD_INT 33
9053: PUSH
9054: LD_INT 2
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 3
9063: PUSH
9064: LD_INT 61
9066: PUSH
9067: EMPTY
9068: LIST
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PPUSH
9079: CALL_OW 69
9083: PUSH
9084: LD_INT 0
9086: GREATER
9087: PUSH
9088: LD_INT 22
9090: PUSH
9091: LD_INT 8
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 34
9100: PUSH
9101: LD_INT 31
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL_OW 69
9116: PUSH
9117: LD_INT 0
9119: GREATER
9120: AND
9121: IFFALSE 9241
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9123: LD_INT 22
9125: PUSH
9126: LD_INT 8
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 33
9135: PUSH
9136: LD_INT 2
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 61
9148: PUSH
9149: EMPTY
9150: LIST
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: PUSH
9166: LD_INT 1
9168: ARRAY
9169: PPUSH
9170: LD_INT 22
9172: PUSH
9173: LD_INT 8
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 34
9182: PUSH
9183: LD_INT 31
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PUSH
9199: LD_INT 1
9201: PPUSH
9202: LD_INT 22
9204: PUSH
9205: LD_INT 8
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 34
9214: PUSH
9215: LD_INT 31
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PPUSH
9226: CALL_OW 69
9230: PPUSH
9231: CALL_OW 12
9235: ARRAY
9236: PPUSH
9237: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9241: LD_EXP 35
9245: PUSH
9246: LD_INT 0
9248: GREATER
9249: PUSH
9250: LD_VAR 0 9
9254: PPUSH
9255: CALL_OW 461
9259: PUSH
9260: LD_INT 2
9262: EQUAL
9263: AND
9264: IFFALSE 9349
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9266: LD_VAR 0 9
9270: PPUSH
9271: LD_EXP 35
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 3
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: PPUSH
9307: CALL_OW 125
// for i = 1 to 4 do
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: DOUBLE
9317: LD_INT 1
9319: DEC
9320: ST_TO_ADDR
9321: LD_INT 4
9323: PUSH
9324: FOR_TO
9325: IFFALSE 9347
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9327: LD_ADDR_EXP 35
9331: PUSH
9332: LD_EXP 35
9336: PPUSH
9337: LD_INT 1
9339: PPUSH
9340: CALL_OW 3
9344: ST_TO_ADDR
9345: GO 9324
9347: POP
9348: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9349: LD_VAR 0 11
9353: PPUSH
9354: LD_INT 35
9356: PUSH
9357: LD_INT 0
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 72
9368: PUSH
9369: LD_INT 0
9371: GREATER
9372: PUSH
9373: LD_VAR 0 9
9377: PPUSH
9378: CALL_OW 461
9382: PUSH
9383: LD_INT 2
9385: EQUAL
9386: AND
9387: IFFALSE 9439
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9389: LD_VAR 0 11
9393: PPUSH
9394: LD_INT 35
9396: PUSH
9397: LD_INT 0
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 72
9408: PUSH
9409: LD_INT 1
9411: ARRAY
9412: PPUSH
9413: LD_INT 28
9415: PUSH
9416: LD_INT 27
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 2
9428: PPUSH
9429: CALL_OW 12
9433: ARRAY
9434: PPUSH
9435: CALL_OW 148
// end ; if legion_enemy > 0 then
9439: LD_EXP 36
9443: PUSH
9444: LD_INT 0
9446: GREATER
9447: IFFALSE 10027
// begin if tick mod 11 11$00 = 0 then
9449: LD_OWVAR 1
9453: PUSH
9454: LD_INT 23100
9456: MOD
9457: PUSH
9458: LD_INT 0
9460: EQUAL
9461: IFFALSE 9711
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9463: LD_ADDR_EXP 35
9467: PUSH
9468: LD_EXP 35
9472: PUSH
9473: LD_INT 13
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: ADD
9487: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9488: LD_ADDR_EXP 35
9492: PUSH
9493: LD_EXP 35
9497: PUSH
9498: LD_INT 28
9500: PUSH
9501: LD_INT 27
9503: PUSH
9504: LD_INT 29
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 1
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: ARRAY
9523: ADD
9524: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9525: LD_ADDR_EXP 35
9529: PUSH
9530: LD_EXP 35
9534: PUSH
9535: LD_INT 13
9537: PUSH
9538: LD_INT 1
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: ADD
9549: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9550: LD_ADDR_EXP 35
9554: PUSH
9555: LD_EXP 35
9559: PUSH
9560: LD_INT 28
9562: PUSH
9563: LD_INT 27
9565: PUSH
9566: LD_INT 29
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 1
9576: PPUSH
9577: LD_INT 3
9579: PPUSH
9580: CALL_OW 12
9584: ARRAY
9585: ADD
9586: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9587: LD_ADDR_EXP 35
9591: PUSH
9592: LD_EXP 35
9596: PUSH
9597: LD_INT 13
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: LD_INT 2
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: ADD
9611: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9612: LD_ADDR_EXP 35
9616: PUSH
9617: LD_EXP 35
9621: PUSH
9622: LD_INT 28
9624: PUSH
9625: LD_INT 27
9627: PUSH
9628: LD_INT 29
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 1
9638: PPUSH
9639: LD_INT 3
9641: PPUSH
9642: CALL_OW 12
9646: ARRAY
9647: ADD
9648: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9649: LD_ADDR_EXP 35
9653: PUSH
9654: LD_EXP 35
9658: PUSH
9659: LD_INT 13
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 2
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: ADD
9673: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9674: LD_ADDR_EXP 35
9678: PUSH
9679: LD_EXP 35
9683: PUSH
9684: LD_INT 28
9686: PUSH
9687: LD_INT 27
9689: PUSH
9690: LD_INT 29
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 1
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: CALL_OW 12
9708: ARRAY
9709: ADD
9710: ST_TO_ADDR
// end ; if legion_force >= 7 then
9711: LD_EXP 31
9715: PUSH
9716: LD_INT 7
9718: GREATEREQUAL
9719: IFFALSE 9902
// begin for i = 1 to legion_force do
9721: LD_ADDR_VAR 0 2
9725: PUSH
9726: DOUBLE
9727: LD_INT 1
9729: DEC
9730: ST_TO_ADDR
9731: LD_EXP 31
9735: PUSH
9736: FOR_TO
9737: IFFALSE 9900
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9739: LD_EXP 31
9743: PUSH
9744: LD_VAR 0 2
9748: ARRAY
9749: PPUSH
9750: CALL_OW 314
9754: NOT
9755: PUSH
9756: LD_EXP 31
9760: PUSH
9761: LD_VAR 0 2
9765: ARRAY
9766: PPUSH
9767: CALL_OW 110
9771: PUSH
9772: LD_INT 11
9774: NONEQUAL
9775: AND
9776: IFFALSE 9898
// begin case legion_enemy of 1 :
9778: LD_EXP 36
9782: PUSH
9783: LD_INT 1
9785: DOUBLE
9786: EQUAL
9787: IFTRUE 9791
9789: GO 9815
9791: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 142
9805: PPUSH
9806: LD_INT 144
9808: PPUSH
9809: CALL_OW 111
9813: GO 9880
9815: LD_INT 2
9817: DOUBLE
9818: EQUAL
9819: IFTRUE 9823
9821: GO 9847
9823: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9824: LD_EXP 31
9828: PUSH
9829: LD_VAR 0 2
9833: ARRAY
9834: PPUSH
9835: LD_INT 101
9837: PPUSH
9838: LD_INT 34
9840: PPUSH
9841: CALL_OW 111
9845: GO 9880
9847: LD_INT 7
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9879
9855: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9856: LD_EXP 31
9860: PUSH
9861: LD_VAR 0 2
9865: ARRAY
9866: PPUSH
9867: LD_INT 173
9869: PPUSH
9870: LD_INT 127
9872: PPUSH
9873: CALL_OW 111
9877: GO 9880
9879: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9880: LD_EXP 31
9884: PUSH
9885: LD_VAR 0 2
9889: ARRAY
9890: PPUSH
9891: LD_INT 11
9893: PPUSH
9894: CALL_OW 109
// end ; end ;
9898: GO 9736
9900: POP
9901: POP
// end ; if legion_force then
9902: LD_EXP 31
9906: IFFALSE 10027
// begin tmp := legion_force ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_EXP 31
9917: ST_TO_ADDR
// for i = 1 to tmp do
9918: LD_ADDR_VAR 0 2
9922: PUSH
9923: DOUBLE
9924: LD_INT 1
9926: DEC
9927: ST_TO_ADDR
9928: LD_VAR 0 3
9932: PUSH
9933: FOR_TO
9934: IFFALSE 10025
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9936: LD_VAR 0 3
9940: PUSH
9941: LD_VAR 0 2
9945: ARRAY
9946: PPUSH
9947: CALL_OW 314
9951: NOT
9952: PUSH
9953: LD_EXP 31
9957: PUSH
9958: LD_VAR 0 2
9962: ARRAY
9963: PPUSH
9964: CALL_OW 110
9968: PUSH
9969: LD_INT 11
9971: EQUAL
9972: AND
9973: IFFALSE 10023
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9975: LD_VAR 0 3
9979: PUSH
9980: LD_VAR 0 2
9984: ARRAY
9985: PPUSH
9986: LD_INT 22
9988: PUSH
9989: LD_EXP 36
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PPUSH
9998: CALL_OW 69
10002: PPUSH
10003: LD_VAR 0 3
10007: PUSH
10008: LD_VAR 0 2
10012: ARRAY
10013: PPUSH
10014: CALL_OW 74
10018: PPUSH
10019: CALL_OW 115
10023: GO 9933
10025: POP
10026: POP
// end ; end ; p := 1 ;
10027: LD_ADDR_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: ST_TO_ADDR
// for i = 1 to 24 do
10035: LD_ADDR_VAR 0 2
10039: PUSH
10040: DOUBLE
10041: LD_INT 1
10043: DEC
10044: ST_TO_ADDR
10045: LD_INT 24
10047: PUSH
10048: FOR_TO
10049: IFFALSE 10179
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10051: LD_EXP 33
10055: PUSH
10056: LD_VAR 0 6
10060: ARRAY
10061: PPUSH
10062: LD_EXP 33
10066: PUSH
10067: LD_VAR 0 6
10071: PUSH
10072: LD_INT 1
10074: PLUS
10075: ARRAY
10076: PPUSH
10077: CALL_OW 428
10081: PUSH
10082: LD_INT 0
10084: GREATER
10085: IFFALSE 10163
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10087: LD_EXP 33
10091: PUSH
10092: LD_VAR 0 6
10096: ARRAY
10097: PPUSH
10098: LD_EXP 33
10102: PUSH
10103: LD_VAR 0 6
10107: PUSH
10108: LD_INT 1
10110: PLUS
10111: ARRAY
10112: PPUSH
10113: CALL_OW 428
10117: PPUSH
10118: CALL_OW 255
10122: PUSH
10123: LD_EXP 36
10127: EQUAL
10128: IFFALSE 10163
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10130: LD_EXP 33
10134: PUSH
10135: LD_VAR 0 6
10139: ARRAY
10140: PPUSH
10141: LD_EXP 33
10145: PUSH
10146: LD_VAR 0 6
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 8
10158: PPUSH
10159: CALL_OW 456
// p := p + 2 ;
10163: LD_ADDR_VAR 0 6
10167: PUSH
10168: LD_VAR 0 6
10172: PUSH
10173: LD_INT 2
10175: PLUS
10176: ST_TO_ADDR
// end ;
10177: GO 10048
10179: POP
10180: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10181: LD_INT 22
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 34
10193: PUSH
10194: LD_INT 32
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PPUSH
10205: CALL_OW 69
10209: IFFALSE 10323
// begin if l_cargo = false then
10211: LD_VAR 0 17
10215: PUSH
10216: LD_INT 0
10218: EQUAL
10219: IFFALSE 10255
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10221: LD_ADDR_VAR 0 17
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_INT 8
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 34
10238: PUSH
10239: LD_INT 32
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: ST_TO_ADDR
// if l_cargo then
10255: LD_VAR 0 17
10259: IFFALSE 10323
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10261: LD_ADDR_VAR 0 7
10265: PUSH
10266: LD_INT 14
10268: PPUSH
10269: CALL_OW 435
10273: ST_TO_ADDR
// if cr > 0 then
10274: LD_VAR 0 7
10278: PUSH
10279: LD_INT 0
10281: GREATER
10282: IFFALSE 10323
// if not HasTask ( l_cargo ) then
10284: LD_VAR 0 17
10288: PPUSH
10289: CALL_OW 314
10293: NOT
10294: IFFALSE 10323
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10296: LD_VAR 0 17
10300: PPUSH
10301: LD_VAR 0 7
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 2
10317: ARRAY
10318: PPUSH
10319: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10323: LD_OWVAR 1
10327: PUSH
10328: LD_INT 52500
10330: PUSH
10331: LD_INT 46200
10333: PUSH
10334: LD_INT 42000
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: LD_OWVAR 67
10346: ARRAY
10347: EQUAL
10348: PUSH
10349: LD_INT 1
10351: PPUSH
10352: CALL_OW 469
10356: PUSH
10357: LD_INT 1
10359: ARRAY
10360: PUSH
10361: LD_INT 112
10363: EQUAL
10364: AND
10365: PUSH
10366: LD_INT 1
10368: PPUSH
10369: CALL_OW 469
10373: PUSH
10374: LD_INT 2
10376: ARRAY
10377: PUSH
10378: LD_INT 67
10380: EQUAL
10381: AND
10382: IFFALSE 10475
// begin un := l_eng [ 1 ] ;
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_VAR 0 16
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: ST_TO_ADDR
// if IsInUnit ( un ) then
10398: LD_VAR 0 1
10402: PPUSH
10403: CALL_OW 310
10407: IFFALSE 10418
// ComExitBuilding ( un ) ;
10409: LD_VAR 0 1
10413: PPUSH
10414: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: LD_INT 1
10425: PPUSH
10426: CALL_OW 469
10430: PUSH
10431: LD_INT 1
10433: ARRAY
10434: PPUSH
10435: LD_INT 1
10437: PPUSH
10438: CALL_OW 469
10442: PUSH
10443: LD_INT 2
10445: ARRAY
10446: PPUSH
10447: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10451: LD_VAR 0 1
10455: PPUSH
10456: LD_INT 207
10458: PPUSH
10459: LD_INT 123
10461: PPUSH
10462: CALL_OW 171
// AddComUnload ( un ) ;
10466: LD_VAR 0 1
10470: PPUSH
10471: CALL_OW 219
// end ; end ;
10475: PPOPN 17
10477: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10478: LD_OWVAR 67
10482: PUSH
10483: LD_INT 1
10485: GREATER
10486: IFFALSE 10691
10488: GO 10490
10490: DISABLE
10491: LD_INT 0
10493: PPUSH
10494: PPUSH
10495: PPUSH
10496: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10497: LD_INT 35
10499: PPUSH
10500: LD_INT 12635
10502: PPUSH
10503: CALL_OW 12
10507: PPUSH
10508: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10512: LD_ADDR_VAR 0 2
10516: PUSH
10517: LD_INT 22
10519: PUSH
10520: LD_INT 8
10522: PUSH
10523: EMPTY
10524: LIST
10525: LIST
10526: PUSH
10527: LD_INT 25
10529: PUSH
10530: LD_INT 4
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PPUSH
10541: CALL_OW 69
10545: ST_TO_ADDR
// p := 1 ;
10546: LD_ADDR_VAR 0 4
10550: PUSH
10551: LD_INT 1
10553: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10554: LD_ADDR_VAR 0 3
10558: PUSH
10559: LD_INT 116
10561: PUSH
10562: LD_INT 139
10564: PUSH
10565: LD_INT 69
10567: PUSH
10568: LD_INT 13
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: ST_TO_ADDR
// for i = 1 to 2 do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: DOUBLE
10583: LD_INT 1
10585: DEC
10586: ST_TO_ADDR
10587: LD_INT 2
10589: PUSH
10590: FOR_TO
10591: IFFALSE 10689
// begin if IsInUnit ( sci [ i ] ) then
10593: LD_VAR 0 2
10597: PUSH
10598: LD_VAR 0 1
10602: ARRAY
10603: PPUSH
10604: CALL_OW 310
10608: IFFALSE 10625
// ComExitBuilding ( sci [ i ] ) ;
10610: LD_VAR 0 2
10614: PUSH
10615: LD_VAR 0 1
10619: ARRAY
10620: PPUSH
10621: CALL_OW 122
// Wait ( 0 0$03 ) ;
10625: LD_INT 105
10627: PPUSH
10628: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10632: LD_VAR 0 2
10636: PUSH
10637: LD_VAR 0 1
10641: ARRAY
10642: PPUSH
10643: LD_VAR 0 3
10647: PUSH
10648: LD_VAR 0 4
10652: ARRAY
10653: PPUSH
10654: LD_VAR 0 3
10658: PUSH
10659: LD_VAR 0 4
10663: PUSH
10664: LD_INT 1
10666: PLUS
10667: ARRAY
10668: PPUSH
10669: CALL_OW 158
// p := p + 2 ;
10673: LD_ADDR_VAR 0 4
10677: PUSH
10678: LD_VAR 0 4
10682: PUSH
10683: LD_INT 2
10685: PLUS
10686: ST_TO_ADDR
// end ;
10687: GO 10590
10689: POP
10690: POP
// end ;
10691: PPOPN 4
10693: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10694: LD_INT 14
10696: PPUSH
10697: CALL_OW 435
10701: PUSH
10702: LD_INT 20
10704: LESS
10705: IFFALSE 10732
10707: GO 10709
10709: DISABLE
// begin enable ;
10710: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10711: LD_INT 1
10713: PPUSH
10714: LD_INT 5
10716: PPUSH
10717: CALL_OW 12
10721: PPUSH
10722: LD_INT 14
10724: PPUSH
10725: LD_INT 1
10727: PPUSH
10728: CALL_OW 55
// end ; end_of_file
10732: END
// export function Action ; var un , gamemode , speaker ; begin
10733: LD_INT 0
10735: PPUSH
10736: PPUSH
10737: PPUSH
10738: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10739: LD_ADDR_OWVAR 67
10743: PUSH
10744: LD_INT 0
10746: PPUSH
10747: CALL_OW 426
10751: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: PPUSH
10760: CALL_OW 426
10764: ST_TO_ADDR
// if gamemode = 1 then
10765: LD_VAR 0 3
10769: PUSH
10770: LD_INT 1
10772: EQUAL
10773: IFFALSE 10797
// begin your_side := 1 ;
10775: LD_ADDR_OWVAR 2
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// legion_enemy := 1 ;
10783: LD_ADDR_EXP 36
10787: PUSH
10788: LD_INT 1
10790: ST_TO_ADDR
// PrepareAmerican ;
10791: CALL 221 0 0
// end else
10795: GO 10849
// if gamemode = 2 then
10797: LD_VAR 0 3
10801: PUSH
10802: LD_INT 2
10804: EQUAL
10805: IFFALSE 10829
// begin your_side := 2 ;
10807: LD_ADDR_OWVAR 2
10811: PUSH
10812: LD_INT 2
10814: ST_TO_ADDR
// legion_enemy := 2 ;
10815: LD_ADDR_EXP 36
10819: PUSH
10820: LD_INT 2
10822: ST_TO_ADDR
// PrepareArabian ;
10823: CALL 18138 0 0
// end else
10827: GO 10849
// begin your_side := 7 ;
10829: LD_ADDR_OWVAR 2
10833: PUSH
10834: LD_INT 7
10836: ST_TO_ADDR
// legion_enemy := 7 ;
10837: LD_ADDR_EXP 36
10841: PUSH
10842: LD_INT 7
10844: ST_TO_ADDR
// PrepareAlliance ;
10845: CALL 15549 0 0
// end ; if your_side = 1 then
10849: LD_OWVAR 2
10853: PUSH
10854: LD_INT 1
10856: EQUAL
10857: IFFALSE 11335
// begin case Query ( QVul4 ) of 1 :
10859: LD_STRING QVul4
10861: PPUSH
10862: CALL_OW 97
10866: PUSH
10867: LD_INT 1
10869: DOUBLE
10870: EQUAL
10871: IFTRUE 10875
10873: GO 10878
10875: POP
// ; end ;
10876: GO 10879
10878: POP
// InGameOn ;
10879: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10883: LD_INT 8
10885: PPUSH
10886: LD_INT 5
10888: PPUSH
10889: CALL_OW 86
// uc_side := 4 ;
10893: LD_ADDR_OWVAR 20
10897: PUSH
10898: LD_INT 4
10900: ST_TO_ADDR
// uc_nation := 1 ;
10901: LD_ADDR_OWVAR 21
10905: PUSH
10906: LD_INT 1
10908: ST_TO_ADDR
// hc_importance := 0 ;
10909: LD_ADDR_OWVAR 32
10913: PUSH
10914: LD_INT 0
10916: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10917: LD_INT 1
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_EXP 21
10927: PPUSH
10928: CALL_OW 380
// un := CreateHuman ;
10932: LD_ADDR_VAR 0 2
10936: PUSH
10937: CALL_OW 44
10941: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10942: LD_VAR 0 2
10946: PPUSH
10947: LD_INT 12
10949: PPUSH
10950: LD_INT 9
10952: PPUSH
10953: LD_INT 0
10955: PPUSH
10956: CALL_OW 48
// hc_name := Stuart Carey ;
10960: LD_ADDR_OWVAR 26
10964: PUSH
10965: LD_STRING Stuart Carey
10967: ST_TO_ADDR
// hc_class := 1 ;
10968: LD_ADDR_OWVAR 28
10972: PUSH
10973: LD_INT 1
10975: ST_TO_ADDR
// hc_gallery := vulcano ;
10976: LD_ADDR_OWVAR 33
10980: PUSH
10981: LD_STRING vulcano
10983: ST_TO_ADDR
// hc_face_number := 1 ;
10984: LD_ADDR_OWVAR 34
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// us_guy := CreateHuman ;
10992: LD_ADDR_EXP 22
10996: PUSH
10997: CALL_OW 44
11001: ST_TO_ADDR
// InitHc ;
11002: CALL_OW 19
// if rand ( 0 , 1 ) then
11006: LD_INT 0
11008: PPUSH
11009: LD_INT 1
11011: PPUSH
11012: CALL_OW 12
11016: IFFALSE 11033
// PrepareHuman ( sex_male , 3 , 6 ) else
11018: LD_INT 1
11020: PPUSH
11021: LD_INT 3
11023: PPUSH
11024: LD_INT 6
11026: PPUSH
11027: CALL_OW 380
11031: GO 11046
// PrepareHuman ( sex_female , 4 , 8 ) ;
11033: LD_INT 2
11035: PPUSH
11036: LD_INT 4
11038: PPUSH
11039: LD_INT 8
11041: PPUSH
11042: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_EXP 19
11055: PPUSH
11056: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11060: LD_EXP 19
11064: PPUSH
11065: LD_VAR 0 2
11069: PPUSH
11070: CALL_OW 119
// if GetSex ( un ) = sex_male then
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 258
11083: PUSH
11084: LD_INT 1
11086: EQUAL
11087: IFFALSE 11170
// begin Say ( un , VD-un1 ) ;
11089: LD_VAR 0 2
11093: PPUSH
11094: LD_STRING VD-un1
11096: PPUSH
11097: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11101: LD_EXP 19
11105: PPUSH
11106: LD_STRING VDc-1
11108: PPUSH
11109: CALL_OW 88
// Say ( un , VD-un2 ) ;
11113: LD_VAR 0 2
11117: PPUSH
11118: LD_STRING VD-un2
11120: PPUSH
11121: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11125: LD_EXP 19
11129: PPUSH
11130: LD_STRING VDc-2
11132: PPUSH
11133: CALL_OW 88
// Say ( un , VD-un3 ) ;
11137: LD_VAR 0 2
11141: PPUSH
11142: LD_STRING VD-un3
11144: PPUSH
11145: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11149: LD_INT 7
11151: PPUSH
11152: CALL_OW 67
// Say ( un , VD-un4 ) ;
11156: LD_VAR 0 2
11160: PPUSH
11161: LD_STRING VD-un4
11163: PPUSH
11164: CALL_OW 88
// end else
11168: GO 11249
// begin Say ( un , VD-unf1 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_STRING VD-unf1
11177: PPUSH
11178: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11182: LD_EXP 19
11186: PPUSH
11187: LD_STRING VDc-1
11189: PPUSH
11190: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11194: LD_VAR 0 2
11198: PPUSH
11199: LD_STRING VD-unf2
11201: PPUSH
11202: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11206: LD_EXP 19
11210: PPUSH
11211: LD_STRING VDc-2
11213: PPUSH
11214: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11218: LD_VAR 0 2
11222: PPUSH
11223: LD_STRING VD-unf3
11225: PPUSH
11226: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11230: LD_INT 7
11232: PPUSH
11233: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11237: LD_VAR 0 2
11241: PPUSH
11242: LD_STRING VD-unf4
11244: PPUSH
11245: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11249: LD_VAR 0 2
11253: PPUSH
11254: LD_INT 2
11256: PPUSH
11257: LD_INT 2
11259: PPUSH
11260: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11264: LD_EXP 19
11268: PPUSH
11269: LD_STRING VDc-3
11271: PPUSH
11272: CALL_OW 88
// InGameOff ;
11276: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11280: LD_STRING CVulc1
11282: PPUSH
11283: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11287: LD_INT 35
11289: PPUSH
11290: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11294: LD_VAR 0 2
11298: PPUSH
11299: CALL_OW 250
11303: PUSH
11304: LD_INT 2
11306: EQUAL
11307: PUSH
11308: LD_VAR 0 2
11312: PPUSH
11313: CALL_OW 251
11317: PUSH
11318: LD_INT 2
11320: EQUAL
11321: AND
11322: IFFALSE 11287
// RemoveUnit ( un ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: CALL_OW 64
// end else
11333: GO 11712
// if your_side = 2 then
11335: LD_OWVAR 2
11339: PUSH
11340: LD_INT 2
11342: EQUAL
11343: IFFALSE 11559
// begin CenterNowOnUnits ( player_commander ) ;
11345: LD_EXP 10
11349: PPUSH
11350: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11354: LD_ADDR_VAR 0 4
11358: PUSH
11359: LD_INT 22
11361: PUSH
11362: LD_INT 2
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PUSH
11369: LD_INT 21
11371: PUSH
11372: LD_INT 1
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PPUSH
11383: CALL_OW 69
11387: PUSH
11388: LD_EXP 51
11392: DIFF
11393: ST_TO_ADDR
// if speaker then
11394: LD_VAR 0 4
11398: IFFALSE 11550
// begin InGameOn ;
11400: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11404: LD_EXP 51
11408: PPUSH
11409: LD_STRING VSd-1
11411: PPUSH
11412: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11416: LD_VAR 0 4
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: CALL_OW 258
11429: PUSH
11430: LD_INT 1
11432: EQUAL
11433: IFFALSE 11453
// Say ( speaker [ 1 ] , VAd-1 ) else
11435: LD_VAR 0 4
11439: PUSH
11440: LD_INT 1
11442: ARRAY
11443: PPUSH
11444: LD_STRING VAd-1
11446: PPUSH
11447: CALL_OW 88
11451: GO 11469
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11453: LD_VAR 0 4
11457: PUSH
11458: LD_INT 1
11460: ARRAY
11461: PPUSH
11462: LD_STRING VAfd-1
11464: PPUSH
11465: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11469: LD_EXP 51
11473: PPUSH
11474: LD_STRING VSd-2
11476: PPUSH
11477: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11481: LD_VAR 0 4
11485: PUSH
11486: LD_INT 1
11488: ARRAY
11489: PPUSH
11490: CALL_OW 258
11494: PUSH
11495: LD_INT 1
11497: EQUAL
11498: IFFALSE 11518
// Say ( speaker [ 1 ] , VAd-2 ) else
11500: LD_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ARRAY
11508: PPUSH
11509: LD_STRING VAd-2
11511: PPUSH
11512: CALL_OW 88
11516: GO 11534
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11518: LD_VAR 0 4
11522: PUSH
11523: LD_INT 1
11525: ARRAY
11526: PPUSH
11527: LD_STRING VAfd-2
11529: PPUSH
11530: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11534: LD_EXP 51
11538: PPUSH
11539: LD_STRING VSd-3
11541: PPUSH
11542: CALL_OW 88
// InGameOff ;
11546: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11550: LD_STRING CVulc5
11552: PPUSH
11553: CALL_OW 337
// end else
11557: GO 11712
// if your_side = 7 then
11559: LD_OWVAR 2
11563: PUSH
11564: LD_INT 7
11566: EQUAL
11567: IFFALSE 11712
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11569: LD_ADDR_VAR 0 4
11573: PUSH
11574: LD_INT 22
11576: PUSH
11577: LD_INT 7
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 21
11586: PUSH
11587: LD_INT 1
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PPUSH
11598: CALL_OW 69
11602: PUSH
11603: LD_EXP 37
11607: DIFF
11608: ST_TO_ADDR
// if speaker then
11609: LD_VAR 0 4
11613: IFFALSE 11705
// begin CenterNowOnUnits ( al_commander ) ;
11615: LD_EXP 37
11619: PPUSH
11620: CALL_OW 87
// InGameOn ;
11624: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11628: LD_EXP 37
11632: PPUSH
11633: LD_STRING VPd-1
11635: PPUSH
11636: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11640: LD_VAR 0 4
11644: PUSH
11645: LD_INT 1
11647: ARRAY
11648: PPUSH
11649: CALL_OW 258
11653: IFFALSE 11673
// Say ( speaker [ 1 ] , VPpd-1 ) else
11655: LD_VAR 0 4
11659: PUSH
11660: LD_INT 1
11662: ARRAY
11663: PPUSH
11664: LD_STRING VPpd-1
11666: PPUSH
11667: CALL_OW 88
11671: GO 11689
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11673: LD_VAR 0 4
11677: PUSH
11678: LD_INT 1
11680: ARRAY
11681: PPUSH
11682: LD_STRING VPpdf-1
11684: PPUSH
11685: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11689: LD_EXP 37
11693: PPUSH
11694: LD_STRING VPd-2
11696: PPUSH
11697: CALL_OW 88
// InGameOff ;
11701: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11705: LD_STRING CVulc7
11707: PPUSH
11708: CALL_OW 337
// end ; SaveForQuickRestart ;
11712: CALL_OW 22
// end ;
11716: LD_VAR 0 1
11720: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11721: LD_INT 22
11723: PUSH
11724: LD_INT 2
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: LD_INT 30
11733: PUSH
11734: LD_INT 3
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PPUSH
11745: CALL_OW 69
11749: IFFALSE 11793
11751: GO 11753
11753: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11754: LD_STRING CVulc6
11756: PPUSH
11757: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11761: LD_INT 52500
11763: PUSH
11764: LD_INT 47250
11766: PUSH
11767: LD_INT 42000
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_OWVAR 67
11779: ARRAY
11780: PPUSH
11781: CALL_OW 67
// ru_can_attack := true ;
11785: LD_ADDR_EXP 3
11789: PUSH
11790: LD_INT 1
11792: ST_TO_ADDR
// end ;
11793: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11794: LD_INT 50
11796: PPUSH
11797: CALL_OW 255
11801: PUSH
11802: LD_INT 1
11804: EQUAL
11805: PUSH
11806: LD_INT 22
11808: PUSH
11809: LD_INT 1
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: LD_INT 30
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 30
11831: PUSH
11832: LD_INT 1
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: CALL_OW 69
11852: OR
11853: IFFALSE 12087
11855: GO 11857
11857: DISABLE
11858: LD_INT 0
11860: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11861: LD_STRING CVulc2
11863: PPUSH
11864: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11868: LD_ADDR_VAR 0 1
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_INT 1
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 25
11885: PUSH
11886: LD_INT 2
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PPUSH
11897: CALL_OW 69
11901: PUSH
11902: LD_EXP 19
11906: DIFF
11907: ST_TO_ADDR
// DialogueOn ;
11908: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11912: LD_INT 10
11914: PPUSH
11915: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11919: LD_VAR 0 1
11923: PUSH
11924: LD_INT 1
11926: ARRAY
11927: PPUSH
11928: CALL_OW 258
11932: PUSH
11933: LD_INT 1
11935: EQUAL
11936: IFFALSE 11956
// Say ( speaker [ 1 ] , VDb-1 ) else
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 1
11945: ARRAY
11946: PPUSH
11947: LD_STRING VDb-1
11949: PPUSH
11950: CALL_OW 88
11954: GO 11972
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11956: LD_VAR 0 1
11960: PUSH
11961: LD_INT 1
11963: ARRAY
11964: PPUSH
11965: LD_STRING VDbf-1
11967: PPUSH
11968: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11972: LD_INT 10
11974: PPUSH
11975: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11979: LD_VAR 0 1
11983: PUSH
11984: LD_INT 1
11986: ARRAY
11987: PPUSH
11988: CALL_OW 258
11992: PUSH
11993: LD_INT 1
11995: EQUAL
11996: IFFALSE 12016
// Say ( speaker [ 1 ] , VDb-2 ) else
11998: LD_VAR 0 1
12002: PUSH
12003: LD_INT 1
12005: ARRAY
12006: PPUSH
12007: LD_STRING VDb-2
12009: PPUSH
12010: CALL_OW 88
12014: GO 12032
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12016: LD_VAR 0 1
12020: PUSH
12021: LD_INT 1
12023: ARRAY
12024: PPUSH
12025: LD_STRING VDbf-2
12027: PPUSH
12028: CALL_OW 88
// DWait ( 0 0$01 ) ;
12032: LD_INT 35
12034: PPUSH
12035: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12039: LD_EXP 19
12043: PPUSH
12044: LD_STRING VDb-com1
12046: PPUSH
12047: CALL_OW 88
// DialogueOff ;
12051: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12055: LD_INT 44100
12057: PUSH
12058: LD_INT 36750
12060: PUSH
12061: LD_INT 31500
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: PUSH
12069: LD_OWVAR 67
12073: ARRAY
12074: PPUSH
12075: CALL_OW 67
// ru_can_attack := true ;
12079: LD_ADDR_EXP 3
12083: PUSH
12084: LD_INT 1
12086: ST_TO_ADDR
// end ;
12087: PPOPN 1
12089: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12090: LD_INT 22
12092: PUSH
12093: LD_INT 7
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 30
12102: PUSH
12103: LD_INT 3
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: IFFALSE 12155
12120: GO 12122
12122: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12123: LD_INT 42000
12125: PUSH
12126: LD_INT 34650
12128: PUSH
12129: LD_INT 29400
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: LIST
12136: PUSH
12137: LD_OWVAR 67
12141: ARRAY
12142: PPUSH
12143: CALL_OW 67
// ru_can_attack := true ;
12147: LD_ADDR_EXP 3
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// end ;
12155: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12156: LD_INT 58
12158: PPUSH
12159: CALL_OW 255
12163: PUSH
12164: LD_INT 1
12166: EQUAL
12167: IFFALSE 12374
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12175: LD_ADDR_VAR 0 1
12179: PUSH
12180: LD_INT 22
12182: PUSH
12183: LD_INT 1
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 25
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PPUSH
12204: CALL_OW 69
12208: ST_TO_ADDR
// DialogueOn ;
12209: CALL_OW 6
// if speaker then
12213: LD_VAR 0 1
12217: IFFALSE 12272
// if GetSex ( speaker [ 1 ] ) = sex_male then
12219: LD_VAR 0 1
12223: PUSH
12224: LD_INT 1
12226: ARRAY
12227: PPUSH
12228: CALL_OW 258
12232: PUSH
12233: LD_INT 1
12235: EQUAL
12236: IFFALSE 12256
// Say ( speaker [ 1 ] , VDe-1 ) else
12238: LD_VAR 0 1
12242: PUSH
12243: LD_INT 1
12245: ARRAY
12246: PPUSH
12247: LD_STRING VDe-1
12249: PPUSH
12250: CALL_OW 88
12254: GO 12272
// Say ( speaker [ 1 ] , VDef-1 ) ;
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 1
12263: ARRAY
12264: PPUSH
12265: LD_STRING VDef-1
12267: PPUSH
12268: CALL_OW 88
// case Query ( SibNote ) of 1 :
12272: LD_STRING SibNote
12274: PPUSH
12275: CALL_OW 97
12279: PUSH
12280: LD_INT 1
12282: DOUBLE
12283: EQUAL
12284: IFTRUE 12288
12286: GO 12291
12288: POP
// ; end ;
12289: GO 12292
12291: POP
// if speaker then
12292: LD_VAR 0 1
12296: IFFALSE 12351
// if GetSex ( speaker [ 1 ] ) = sex_male then
12298: LD_VAR 0 1
12302: PUSH
12303: LD_INT 1
12305: ARRAY
12306: PPUSH
12307: CALL_OW 258
12311: PUSH
12312: LD_INT 1
12314: EQUAL
12315: IFFALSE 12335
// Say ( speaker [ 1 ] , VDe-2 ) else
12317: LD_VAR 0 1
12321: PUSH
12322: LD_INT 1
12324: ARRAY
12325: PPUSH
12326: LD_STRING VDe-2
12328: PPUSH
12329: CALL_OW 88
12333: GO 12351
// Say ( speaker [ 1 ] , VDef-2 ) ;
12335: LD_VAR 0 1
12339: PUSH
12340: LD_INT 1
12342: ARRAY
12343: PPUSH
12344: LD_STRING VDef-2
12346: PPUSH
12347: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12351: LD_EXP 19
12355: PPUSH
12356: LD_STRING VDc-4
12358: PPUSH
12359: CALL_OW 88
// DialogueOff ;
12363: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12367: LD_STRING CVulc3
12369: PPUSH
12370: CALL_OW 337
// end ;
12374: PPOPN 1
12376: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12377: LD_OWVAR 2
12381: PUSH
12382: LD_INT 1
12384: EQUAL
12385: PUSH
12386: LD_INT 22
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PUSH
12396: LD_INT 30
12398: PUSH
12399: LD_INT 3
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PUSH
12406: EMPTY
12407: LIST
12408: LIST
12409: PPUSH
12410: CALL_OW 69
12414: PUSH
12415: LD_INT 0
12417: GREATER
12418: AND
12419: IFFALSE 12853
12421: GO 12423
12423: DISABLE
12424: LD_INT 0
12426: PPUSH
12427: PPUSH
12428: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12429: LD_INT 245
12431: PPUSH
12432: LD_INT 1295
12434: PPUSH
12435: CALL_OW 12
12439: PPUSH
12440: CALL_OW 67
// DialogueOn ;
12444: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12448: LD_EXP 22
12452: PPUSH
12453: LD_STRING VDG-1
12455: PPUSH
12456: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12460: LD_EXP 19
12464: PPUSH
12465: LD_STRING VDc-5
12467: PPUSH
12468: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12472: LD_EXP 22
12476: PPUSH
12477: LD_STRING VDG-2
12479: PPUSH
12480: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12484: LD_EXP 19
12488: PPUSH
12489: LD_STRING VDc-6
12491: PPUSH
12492: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12496: LD_EXP 22
12500: PPUSH
12501: LD_STRING VDG-3
12503: PPUSH
12504: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12508: LD_EXP 19
12512: PPUSH
12513: LD_STRING VDc-7
12515: PPUSH
12516: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12520: LD_EXP 22
12524: PPUSH
12525: LD_STRING VDG-4
12527: PPUSH
12528: CALL_OW 94
// DialogueOff ;
12532: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12536: LD_STRING CVulc4
12538: PPUSH
12539: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12543: LD_INT 18900
12545: PUSH
12546: LD_INT 21000
12548: PUSH
12549: LD_INT 23100
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PUSH
12557: LD_OWVAR 67
12561: ARRAY
12562: PPUSH
12563: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12567: LD_ADDR_VAR 0 1
12571: PUSH
12572: DOUBLE
12573: LD_INT 1
12575: DEC
12576: ST_TO_ADDR
12577: LD_INT 4
12579: PUSH
12580: LD_INT 5
12582: PUSH
12583: LD_INT 6
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: LD_OWVAR 67
12595: ARRAY
12596: PUSH
12597: FOR_TO
12598: IFFALSE 12842
// begin uc_side := 1 ;
12600: LD_ADDR_OWVAR 20
12604: PUSH
12605: LD_INT 1
12607: ST_TO_ADDR
// uc_nation := 1 ;
12608: LD_ADDR_OWVAR 21
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12616: LD_INT 0
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: LD_INT 4
12624: PPUSH
12625: CALL_OW 12
12629: PPUSH
12630: LD_EXP 21
12634: PPUSH
12635: CALL_OW 380
// un := CreateHuman ;
12639: LD_ADDR_VAR 0 2
12643: PUSH
12644: CALL_OW 44
12648: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12649: LD_VAR 0 2
12653: PPUSH
12654: LD_INT 2
12656: PPUSH
12657: CALL_OW 233
// if GetClass ( un ) = 3 then
12661: LD_VAR 0 2
12665: PPUSH
12666: CALL_OW 257
12670: PUSH
12671: LD_INT 3
12673: EQUAL
12674: IFFALSE 12825
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12676: LD_ADDR_OWVAR 37
12680: PUSH
12681: LD_INT 2
12683: PUSH
12684: LD_INT 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: LD_VAR 0 1
12695: PUSH
12696: LD_INT 2
12698: MOD
12699: ARRAY
12700: ST_TO_ADDR
// vc_engine := engine_combustion ;
12701: LD_ADDR_OWVAR 39
12705: PUSH
12706: LD_INT 1
12708: ST_TO_ADDR
// vc_control := control_manual ;
12709: LD_ADDR_OWVAR 38
12713: PUSH
12714: LD_INT 1
12716: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12717: LD_ADDR_OWVAR 40
12721: PUSH
12722: LD_INT 9
12724: PUSH
12725: LD_INT 9
12727: PUSH
12728: LD_INT 5
12730: PUSH
12731: LD_INT 11
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 1
12742: PPUSH
12743: LD_INT 4
12745: PPUSH
12746: CALL_OW 12
12750: ARRAY
12751: ST_TO_ADDR
// veh := CreateVehicle ;
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: CALL_OW 45
12761: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12762: LD_VAR 0 3
12766: PPUSH
12767: LD_INT 2
12769: PPUSH
12770: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12774: LD_VAR 0 3
12778: PPUSH
12779: LD_INT 77
12781: PPUSH
12782: LD_INT 88
12784: PPUSH
12785: CALL_OW 12
12789: PPUSH
12790: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12794: LD_VAR 0 3
12798: PPUSH
12799: LD_INT 1
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: CALL_OW 52
// end else
12823: GO 12840
// PlaceUnitArea ( un , start_north , false ) ;
12825: LD_VAR 0 2
12829: PPUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 49
// end ;
12840: GO 12597
12842: POP
12843: POP
// CenterNowOnUnits ( un ) ;
12844: LD_VAR 0 2
12848: PPUSH
12849: CALL_OW 87
// end ;
12853: PPOPN 3
12855: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12856: LD_INT 21
12858: PPUSH
12859: LD_INT 22
12861: PUSH
12862: LD_OWVAR 2
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PPUSH
12871: CALL_OW 70
12875: IFFALSE 13196
12877: GO 12879
12879: DISABLE
12880: LD_INT 0
12882: PPUSH
12883: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12884: LD_ADDR_VAR 0 2
12888: PUSH
12889: LD_INT 22
12891: PUSH
12892: LD_OWVAR 2
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PUSH
12901: LD_INT 2
12903: PUSH
12904: LD_INT 25
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 25
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 25
12936: PUSH
12937: LD_INT 4
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PPUSH
12955: CALL_OW 69
12959: PUSH
12960: LD_EXP 10
12964: DIFF
12965: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12966: LD_ADDR_VAR 0 1
12970: PUSH
12971: LD_VAR 0 2
12975: PPUSH
12976: LD_INT 112
12978: PPUSH
12979: LD_INT 67
12981: PPUSH
12982: CALL_OW 73
12986: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12987: LD_VAR 0 1
12991: PPUSH
12992: CALL_OW 255
12996: PUSH
12997: LD_INT 7
12999: EQUAL
13000: IFFALSE 13043
// if GetSex ( un ) = sex_male then
13002: LD_VAR 0 1
13006: PPUSH
13007: CALL_OW 258
13011: PUSH
13012: LD_INT 1
13014: EQUAL
13015: IFFALSE 13031
// Say ( un , VD-find-al ) else
13017: LD_VAR 0 1
13021: PPUSH
13022: LD_STRING VD-find-al
13024: PPUSH
13025: CALL_OW 88
13029: GO 13043
// Say ( un , VD-find-al-f ) ;
13031: LD_VAR 0 1
13035: PPUSH
13036: LD_STRING VD-find-al-f
13038: PPUSH
13039: CALL_OW 88
// if GetSide ( un ) = 2 then
13043: LD_VAR 0 1
13047: PPUSH
13048: CALL_OW 255
13052: PUSH
13053: LD_INT 2
13055: EQUAL
13056: IFFALSE 13099
// if GetSex ( un ) = sex_male then
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL_OW 258
13067: PUSH
13068: LD_INT 1
13070: EQUAL
13071: IFFALSE 13087
// Say ( un , VD-find-ar ) else
13073: LD_VAR 0 1
13077: PPUSH
13078: LD_STRING VD-find-ar
13080: PPUSH
13081: CALL_OW 88
13085: GO 13099
// Say ( un , VD-find-ar-f ) ;
13087: LD_VAR 0 1
13091: PPUSH
13092: LD_STRING VD-find-ar-f
13094: PPUSH
13095: CALL_OW 88
// if GetSide ( un ) = 1 then
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 255
13108: PUSH
13109: LD_INT 1
13111: EQUAL
13112: IFFALSE 13179
// begin if GetSex ( un ) = sex_male then
13114: LD_VAR 0 1
13118: PPUSH
13119: CALL_OW 258
13123: PUSH
13124: LD_INT 1
13126: EQUAL
13127: IFFALSE 13155
// begin Say ( un , VD-find-us ) ;
13129: LD_VAR 0 1
13133: PPUSH
13134: LD_STRING VD-find-us
13136: PPUSH
13137: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_STRING VD-find-us2
13148: PPUSH
13149: CALL_OW 88
// end else
13153: GO 13179
// begin Say ( un , VD-find-us-f ) ;
13155: LD_VAR 0 1
13159: PPUSH
13160: LD_STRING VD-find-us-f
13162: PPUSH
13163: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13167: LD_VAR 0 1
13171: PPUSH
13172: LD_STRING VD-find-us2-f
13174: PPUSH
13175: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13179: LD_INT 10
13181: PPUSH
13182: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13186: LD_INT 112
13188: PPUSH
13189: LD_INT 67
13191: PPUSH
13192: CALL_OW 86
// end ;
13196: PPOPN 2
13198: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13199: LD_EXP 7
13203: IFFALSE 13705
13205: GO 13207
13207: DISABLE
13208: LD_INT 0
13210: PPUSH
// begin if your_side = 1 then
13211: LD_OWVAR 2
13215: PUSH
13216: LD_INT 1
13218: EQUAL
13219: IFFALSE 13400
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13221: LD_ADDR_VAR 0 1
13225: PUSH
13226: LD_INT 22
13228: PUSH
13229: LD_INT 1
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: PUSH
13236: LD_INT 25
13238: PUSH
13239: LD_INT 4
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PPUSH
13250: CALL_OW 69
13254: PUSH
13255: LD_EXP 19
13259: DIFF
13260: ST_TO_ADDR
// if not speaker then
13261: LD_VAR 0 1
13265: NOT
13266: IFFALSE 13270
// exit ;
13268: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13270: LD_VAR 0 1
13274: PUSH
13275: LD_INT 1
13277: ARRAY
13278: PPUSH
13279: CALL_OW 258
13283: PUSH
13284: LD_INT 1
13286: EQUAL
13287: IFFALSE 13307
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13289: LD_VAR 0 1
13293: PUSH
13294: LD_INT 1
13296: ARRAY
13297: PPUSH
13298: LD_STRING VD-us-sci-art-1
13300: PPUSH
13301: CALL_OW 88
13305: GO 13323
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13307: LD_VAR 0 1
13311: PUSH
13312: LD_INT 1
13314: ARRAY
13315: PPUSH
13316: LD_STRING VD-us-fsci-art-1
13318: PPUSH
13319: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13323: LD_EXP 19
13327: PPUSH
13328: LD_STRING VDc-art1
13330: PPUSH
13331: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13335: LD_VAR 0 1
13339: PUSH
13340: LD_INT 1
13342: ARRAY
13343: PPUSH
13344: CALL_OW 258
13348: PUSH
13349: LD_INT 1
13351: EQUAL
13352: IFFALSE 13372
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13354: LD_VAR 0 1
13358: PUSH
13359: LD_INT 1
13361: ARRAY
13362: PPUSH
13363: LD_STRING VD-us-sci-art-2
13365: PPUSH
13366: CALL_OW 88
13370: GO 13388
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13372: LD_VAR 0 1
13376: PUSH
13377: LD_INT 1
13379: ARRAY
13380: PPUSH
13381: LD_STRING VD-us-fsci-art-2
13383: PPUSH
13384: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13388: LD_EXP 19
13392: PPUSH
13393: LD_STRING VDc-art2
13395: PPUSH
13396: CALL_OW 88
// end ; if your_side = 2 then
13400: LD_OWVAR 2
13404: PUSH
13405: LD_INT 2
13407: EQUAL
13408: IFFALSE 13512
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13410: LD_ADDR_VAR 0 1
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_INT 2
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: LD_INT 25
13427: PUSH
13428: LD_INT 4
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: LD_EXP 51
13448: DIFF
13449: ST_TO_ADDR
// if not speaker then
13450: LD_VAR 0 1
13454: NOT
13455: IFFALSE 13459
// exit ;
13457: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13459: LD_VAR 0 1
13463: PUSH
13464: LD_INT 1
13466: ARRAY
13467: PPUSH
13468: CALL_OW 258
13472: PUSH
13473: LD_INT 1
13475: EQUAL
13476: IFFALSE 13496
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13478: LD_VAR 0 1
13482: PUSH
13483: LD_INT 1
13485: ARRAY
13486: PPUSH
13487: LD_STRING VD-ar-sci-art-1
13489: PPUSH
13490: CALL_OW 88
13494: GO 13512
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13496: LD_VAR 0 1
13500: PUSH
13501: LD_INT 1
13503: ARRAY
13504: PPUSH
13505: LD_STRING VD-ar-fsci-art-1
13507: PPUSH
13508: CALL_OW 88
// end ; if your_side = 7 then
13512: LD_OWVAR 2
13516: PUSH
13517: LD_INT 7
13519: EQUAL
13520: IFFALSE 13705
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13522: LD_ADDR_VAR 0 1
13526: PUSH
13527: LD_INT 22
13529: PUSH
13530: LD_INT 7
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PUSH
13537: LD_INT 25
13539: PUSH
13540: LD_INT 4
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PPUSH
13551: CALL_OW 69
13555: PUSH
13556: LD_EXP 37
13560: DIFF
13561: ST_TO_ADDR
// if speaker then
13562: LD_VAR 0 1
13566: IFFALSE 13698
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13568: LD_VAR 0 1
13572: PUSH
13573: LD_INT 1
13575: ARRAY
13576: PPUSH
13577: CALL_OW 258
13581: PUSH
13582: LD_INT 1
13584: EQUAL
13585: IFFALSE 13605
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13587: LD_VAR 0 1
13591: PUSH
13592: LD_INT 1
13594: ARRAY
13595: PPUSH
13596: LD_STRING VD-al-sci-art-1
13598: PPUSH
13599: CALL_OW 88
13603: GO 13621
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13605: LD_VAR 0 1
13609: PUSH
13610: LD_INT 1
13612: ARRAY
13613: PPUSH
13614: LD_STRING VD-al-fsci-art-1
13616: PPUSH
13617: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13621: LD_EXP 37
13625: PPUSH
13626: LD_STRING VPd-art-1
13628: PPUSH
13629: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13633: LD_VAR 0 1
13637: PUSH
13638: LD_INT 1
13640: ARRAY
13641: PPUSH
13642: CALL_OW 258
13646: PUSH
13647: LD_INT 1
13649: EQUAL
13650: IFFALSE 13670
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13652: LD_VAR 0 1
13656: PUSH
13657: LD_INT 1
13659: ARRAY
13660: PPUSH
13661: LD_STRING VD-al-sci-art-2
13663: PPUSH
13664: CALL_OW 88
13668: GO 13686
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13670: LD_VAR 0 1
13674: PUSH
13675: LD_INT 1
13677: ARRAY
13678: PPUSH
13679: LD_STRING VD-al-fsci-art-2
13681: PPUSH
13682: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13686: LD_EXP 37
13690: PPUSH
13691: LD_STRING VPd-art-2
13693: PPUSH
13694: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13698: LD_STRING CVulc7out
13700: PPUSH
13701: CALL_OW 337
// end ; end ;
13705: PPOPN 1
13707: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13708: LD_INT 8
13710: PPUSH
13711: LD_INT 22
13713: PUSH
13714: LD_OWVAR 2
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PPUSH
13723: CALL_OW 69
13727: PPUSH
13728: LD_INT 8
13730: PPUSH
13731: CALL 2145 0 2
13735: PPUSH
13736: CALL_OW 292
13740: IFFALSE 13883
13742: GO 13744
13744: DISABLE
13745: LD_INT 0
13747: PPUSH
// begin if your_side = 1 then
13748: LD_OWVAR 2
13752: PUSH
13753: LD_INT 1
13755: EQUAL
13756: IFFALSE 13839
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_INT 22
13765: PUSH
13766: LD_INT 1
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PPUSH
13773: CALL_OW 69
13777: PUSH
13778: LD_EXP 19
13782: DIFF
13783: ST_TO_ADDR
// if speaker then
13784: LD_VAR 0 1
13788: IFFALSE 13839
// if GetSex ( speaker [ 1 ] ) then
13790: LD_VAR 0 1
13794: PUSH
13795: LD_INT 1
13797: ARRAY
13798: PPUSH
13799: CALL_OW 258
13803: IFFALSE 13823
// Say ( speaker [ 1 ] , VD-legion-us ) else
13805: LD_VAR 0 1
13809: PUSH
13810: LD_INT 1
13812: ARRAY
13813: PPUSH
13814: LD_STRING VD-legion-us
13816: PPUSH
13817: CALL_OW 88
13821: GO 13839
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13823: LD_VAR 0 1
13827: PUSH
13828: LD_INT 1
13830: ARRAY
13831: PPUSH
13832: LD_STRING VD-legion-us-f
13834: PPUSH
13835: CALL_OW 88
// end ; if your_side = 2 then
13839: LD_OWVAR 2
13843: PUSH
13844: LD_INT 2
13846: EQUAL
13847: IFFALSE 13861
// Say ( ar_commander , VD-legion-ar ) ;
13849: LD_EXP 51
13853: PPUSH
13854: LD_STRING VD-legion-ar
13856: PPUSH
13857: CALL_OW 88
// if your_side = 7 then
13861: LD_OWVAR 2
13865: PUSH
13866: LD_INT 7
13868: EQUAL
13869: IFFALSE 13883
// Say ( al_commander , VD-legion-al ) ;
13871: LD_EXP 37
13875: PPUSH
13876: LD_STRING VD-legion-al
13878: PPUSH
13879: CALL_OW 88
// end ;
13883: PPOPN 1
13885: END
// every 0 0$01 trigger mine_vulc do
13886: LD_EXP 12
13890: IFFALSE 13907
13892: GO 13894
13894: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13895: LD_EXP 10
13899: PPUSH
13900: LD_STRING VD-vulc-mines
13902: PPUSH
13903: CALL_OW 88
// end ;
13907: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13908: LD_OWVAR 67
13912: PUSH
13913: LD_INT 1
13915: GREATER
13916: IFFALSE 14035
13918: GO 13920
13920: DISABLE
13921: LD_INT 0
13923: PPUSH
13924: PPUSH
13925: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13926: LD_ADDR_VAR 0 1
13930: PUSH
13931: LD_INT 123
13933: PUSH
13934: LD_INT 95
13936: PUSH
13937: LD_INT 119
13939: PUSH
13940: LD_INT 89
13942: PUSH
13943: LD_INT 115
13945: PUSH
13946: LD_INT 81
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: ST_TO_ADDR
// p := 1 ;
13957: LD_ADDR_VAR 0 2
13961: PUSH
13962: LD_INT 1
13964: ST_TO_ADDR
// for i = 1 to 3 do
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: DOUBLE
13971: LD_INT 1
13973: DEC
13974: ST_TO_ADDR
13975: LD_INT 3
13977: PUSH
13978: FOR_TO
13979: IFFALSE 14033
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13981: LD_VAR 0 1
13985: PUSH
13986: LD_VAR 0 2
13990: ARRAY
13991: PPUSH
13992: LD_VAR 0 1
13996: PUSH
13997: LD_VAR 0 2
14001: PUSH
14002: LD_INT 1
14004: PLUS
14005: ARRAY
14006: PPUSH
14007: LD_INT 8
14009: PPUSH
14010: LD_INT 0
14012: PPUSH
14013: CALL_OW 454
// p := p + 2 ;
14017: LD_ADDR_VAR 0 2
14021: PUSH
14022: LD_VAR 0 2
14026: PUSH
14027: LD_INT 2
14029: PLUS
14030: ST_TO_ADDR
// end ;
14031: GO 13978
14033: POP
14034: POP
// end ;
14035: PPOPN 3
14037: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14038: LD_OWVAR 67
14042: PUSH
14043: LD_INT 1
14045: GREATER
14046: PUSH
14047: LD_INT 22
14049: PPUSH
14050: LD_INT 22
14052: PUSH
14053: LD_OWVAR 2
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PPUSH
14062: CALL_OW 70
14066: AND
14067: IFFALSE 14271
14069: GO 14071
14071: DISABLE
14072: LD_INT 0
14074: PPUSH
14075: PPUSH
14076: PPUSH
// begin enable ;
14077: ENABLE
// p := 1 ;
14078: LD_ADDR_VAR 0 1
14082: PUSH
14083: LD_INT 1
14085: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14086: LD_ADDR_VAR 0 3
14090: PUSH
14091: LD_INT 123
14093: PUSH
14094: LD_INT 95
14096: PUSH
14097: LD_INT 119
14099: PUSH
14100: LD_INT 89
14102: PUSH
14103: LD_INT 115
14105: PUSH
14106: LD_INT 81
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: ST_TO_ADDR
// for i = 1 to 3 do
14117: LD_ADDR_VAR 0 2
14121: PUSH
14122: DOUBLE
14123: LD_INT 1
14125: DEC
14126: ST_TO_ADDR
14127: LD_INT 3
14129: PUSH
14130: FOR_TO
14131: IFFALSE 14269
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14133: LD_VAR 0 3
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: PPUSH
14144: LD_VAR 0 3
14148: PUSH
14149: LD_VAR 0 1
14153: PUSH
14154: LD_INT 1
14156: PLUS
14157: ARRAY
14158: PPUSH
14159: CALL_OW 428
14163: PUSH
14164: LD_INT 0
14166: GREATER
14167: IFFALSE 14253
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14169: LD_VAR 0 3
14173: PUSH
14174: LD_VAR 0 1
14178: ARRAY
14179: PPUSH
14180: LD_VAR 0 3
14184: PUSH
14185: LD_VAR 0 1
14189: PUSH
14190: LD_INT 1
14192: PLUS
14193: ARRAY
14194: PPUSH
14195: CALL_OW 428
14199: PPUSH
14200: CALL_OW 255
14204: PUSH
14205: LD_OWVAR 2
14209: EQUAL
14210: IFFALSE 14253
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14212: LD_VAR 0 3
14216: PUSH
14217: LD_VAR 0 1
14221: ARRAY
14222: PPUSH
14223: LD_VAR 0 3
14227: PUSH
14228: LD_VAR 0 1
14232: PUSH
14233: LD_INT 1
14235: PLUS
14236: ARRAY
14237: PPUSH
14238: LD_INT 8
14240: PPUSH
14241: CALL_OW 456
// mine_vulc := true ;
14245: LD_ADDR_EXP 12
14249: PUSH
14250: LD_INT 1
14252: ST_TO_ADDR
// end ; p := p + 2 ;
14253: LD_ADDR_VAR 0 1
14257: PUSH
14258: LD_VAR 0 1
14262: PUSH
14263: LD_INT 2
14265: PLUS
14266: ST_TO_ADDR
// end ;
14267: GO 14130
14269: POP
14270: POP
// end ;
14271: PPOPN 3
14273: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14274: LD_INT 22
14276: PUSH
14277: LD_INT 3
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 69
14288: PUSH
14289: LD_INT 0
14291: EQUAL
14292: PUSH
14293: LD_OWVAR 2
14297: PUSH
14298: LD_INT 2
14300: NONEQUAL
14301: AND
14302: IFFALSE 14311
14304: GO 14306
14306: DISABLE
// Win ;
14307: CALL 14368 0 0
14311: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14312: LD_INT 2
14314: PUSH
14315: LD_INT 22
14317: PUSH
14318: LD_INT 8
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 22
14327: PUSH
14328: LD_INT 3
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 69
14344: PUSH
14345: LD_INT 0
14347: EQUAL
14348: PUSH
14349: LD_OWVAR 2
14353: PUSH
14354: LD_INT 2
14356: EQUAL
14357: AND
14358: IFFALSE 14367
14360: GO 14362
14362: DISABLE
// Win ;
14363: CALL 14368 0 0
14367: END
// function Win ; var points ; begin
14368: LD_INT 0
14370: PPUSH
14371: PPUSH
// case Query ( VulcWin ) of 1 :
14372: LD_STRING VulcWin
14374: PPUSH
14375: CALL_OW 97
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14391
14388: POP
// ; end ;
14389: GO 14392
14391: POP
// if medal_enabled then
14392: LD_EXP 13
14396: IFFALSE 14410
// AddMedal ( vulc_1 , 1 ) else
14398: LD_STRING vulc_1
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 101
14408: GO 14421
// AddMedal ( vulc_1 , - 1 ) ;
14410: LD_STRING vulc_1
14412: PPUSH
14413: LD_INT 1
14415: NEG
14416: PPUSH
14417: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14421: LD_INT 22
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PPUSH
14431: CALL_OW 69
14435: PUSH
14436: LD_INT 0
14438: EQUAL
14439: IFFALSE 14453
// AddMedal ( vulc_2 , 1 ) else
14441: LD_STRING vulc_2
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: CALL_OW 101
14451: GO 14464
// AddMedal ( vulc_2 , - 1 ) ;
14453: LD_STRING vulc_2
14455: PPUSH
14456: LD_INT 1
14458: NEG
14459: PPUSH
14460: CALL_OW 101
// points := CalculateCommanderPoints ;
14464: LD_ADDR_VAR 0 2
14468: PUSH
14469: CALL 2266 0 0
14473: ST_TO_ADDR
// if points >= 2000 then
14474: LD_VAR 0 2
14478: PUSH
14479: LD_INT 2000
14481: GREATEREQUAL
14482: IFFALSE 14496
// AddMedal ( vulc_3 , 2 ) else
14484: LD_STRING vulc_3
14486: PPUSH
14487: LD_INT 2
14489: PPUSH
14490: CALL_OW 101
14494: GO 14529
// if points >= 0 then
14496: LD_VAR 0 2
14500: PUSH
14501: LD_INT 0
14503: GREATEREQUAL
14504: IFFALSE 14518
// AddMedal ( vulc_3 , 1 ) else
14506: LD_STRING vulc_3
14508: PPUSH
14509: LD_INT 1
14511: PPUSH
14512: CALL_OW 101
14516: GO 14529
// AddMedal ( vulc_3 , - 1 ) ;
14518: LD_STRING vulc_3
14520: PPUSH
14521: LD_INT 1
14523: NEG
14524: PPUSH
14525: CALL_OW 101
// GiveMedals ( MAIN ) ;
14529: LD_STRING MAIN
14531: PPUSH
14532: CALL_OW 102
// YouWin ;
14536: CALL_OW 103
// end ; end_of_file
14540: LD_VAR 0 1
14544: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14545: LD_INT 13
14547: PPUSH
14548: LD_INT 21
14550: PUSH
14551: LD_INT 1
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 70
14562: PUSH
14563: LD_INT 0
14565: GREATER
14566: IFFALSE 14633
14568: GO 14570
14570: DISABLE
14571: LD_INT 0
14573: PPUSH
14574: PPUSH
// begin enable ;
14575: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14576: LD_ADDR_VAR 0 1
14580: PUSH
14581: LD_INT 13
14583: PPUSH
14584: LD_INT 21
14586: PUSH
14587: LD_INT 1
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PPUSH
14594: CALL_OW 70
14598: PUSH
14599: FOR_IN
14600: IFFALSE 14631
// if GetLives ( i ) > 4 then
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 256
14611: PUSH
14612: LD_INT 4
14614: GREATER
14615: IFFALSE 14629
// SetLives ( i , 4 ) ;
14617: LD_VAR 0 1
14621: PPUSH
14622: LD_INT 4
14624: PPUSH
14625: CALL_OW 234
14629: GO 14599
14631: POP
14632: POP
// end ;
14633: PPOPN 2
14635: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14636: LD_VAR 0 1
14640: PPUSH
14641: CALL_OW 255
14645: PUSH
14646: LD_OWVAR 2
14650: EQUAL
14651: IFFALSE 14661
// player_res_art := true ;
14653: LD_ADDR_EXP 6
14657: PUSH
14658: LD_INT 1
14660: ST_TO_ADDR
// end ;
14661: PPOPN 1
14663: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14664: LD_INT 22
14666: PUSH
14667: LD_OWVAR 2
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 2
14678: PUSH
14679: LD_INT 30
14681: PUSH
14682: LD_INT 8
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PUSH
14689: LD_INT 30
14691: PUSH
14692: LD_INT 11
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: LIST
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: PUSH
14713: LD_EXP 6
14717: AND
14718: IFFALSE 15062
14720: GO 14722
14722: DISABLE
14723: LD_INT 0
14725: PPUSH
14726: PPUSH
14727: PPUSH
// begin enable ;
14728: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14729: LD_ADDR_VAR 0 1
14733: PUSH
14734: LD_INT 1
14736: PPUSH
14737: CALL_OW 469
14741: PUSH
14742: LD_INT 1
14744: ARRAY
14745: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14746: LD_ADDR_VAR 0 2
14750: PUSH
14751: LD_INT 1
14753: PPUSH
14754: CALL_OW 469
14758: PUSH
14759: LD_INT 2
14761: ARRAY
14762: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14763: LD_ADDR_VAR 0 3
14767: PUSH
14768: LD_INT 22
14770: PUSH
14771: LD_OWVAR 2
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: LD_INT 2
14782: PUSH
14783: LD_INT 30
14785: PUSH
14786: LD_INT 8
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 30
14795: PUSH
14796: LD_INT 11
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: LIST
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PPUSH
14812: CALL_OW 69
14816: PPUSH
14817: LD_VAR 0 1
14821: PPUSH
14822: LD_VAR 0 2
14826: PPUSH
14827: CALL_OW 73
14831: ST_TO_ADDR
// if player_artifact_ready = false then
14832: LD_EXP 7
14836: PUSH
14837: LD_INT 0
14839: EQUAL
14840: IFFALSE 14946
// if GetDistUnitXY ( lab , x , y ) < 6 then
14842: LD_VAR 0 3
14846: PPUSH
14847: LD_VAR 0 1
14851: PPUSH
14852: LD_VAR 0 2
14856: PPUSH
14857: CALL_OW 297
14861: PUSH
14862: LD_INT 6
14864: LESS
14865: IFFALSE 14926
// begin if BuildingStatus ( lab ) = bs_idle then
14867: LD_VAR 0 3
14871: PPUSH
14872: CALL_OW 461
14876: PUSH
14877: LD_INT 2
14879: EQUAL
14880: IFFALSE 14904
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14882: LD_OWVAR 2
14886: PPUSH
14887: LD_INT 1
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: LD_VAR 0 3
14897: PPUSH
14898: CALL_OW 468
14902: GO 14924
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14904: LD_OWVAR 2
14908: PPUSH
14909: LD_INT 1
14911: PPUSH
14912: LD_INT 1
14914: PPUSH
14915: LD_VAR 0 3
14919: PPUSH
14920: CALL_OW 468
// end else
14924: GO 14946
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14926: LD_OWVAR 2
14930: PPUSH
14931: LD_INT 1
14933: PPUSH
14934: LD_INT 1
14936: PPUSH
14937: LD_VAR 0 3
14941: PPUSH
14942: CALL_OW 468
// if player_artifact_ready then
14946: LD_EXP 7
14950: IFFALSE 15062
// if GetDistUnitXY ( lab , x , y ) < 6 then
14952: LD_VAR 0 3
14956: PPUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_VAR 0 2
14966: PPUSH
14967: CALL_OW 297
14971: PUSH
14972: LD_INT 6
14974: LESS
14975: IFFALSE 15040
// begin if BuildingStatus ( lab ) = bs_idle then
14977: LD_VAR 0 3
14981: PPUSH
14982: CALL_OW 461
14986: PUSH
14987: LD_INT 2
14989: EQUAL
14990: IFFALSE 15016
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14992: LD_OWVAR 2
14996: PPUSH
14997: LD_EXP 8
15001: PPUSH
15002: LD_INT 4
15004: PPUSH
15005: LD_VAR 0 3
15009: PPUSH
15010: CALL_OW 468
15014: GO 15038
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15016: LD_OWVAR 2
15020: PPUSH
15021: LD_EXP 8
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: LD_VAR 0 3
15033: PPUSH
15034: CALL_OW 468
// end else
15038: GO 15062
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15040: LD_OWVAR 2
15044: PPUSH
15045: LD_EXP 8
15049: PPUSH
15050: LD_INT 1
15052: PPUSH
15053: LD_VAR 0 3
15057: PPUSH
15058: CALL_OW 468
// end ;
15062: PPOPN 3
15064: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15065: LD_INT 0
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15072: LD_ADDR_VAR 0 5
15076: PUSH
15077: LD_INT 1
15079: PPUSH
15080: CALL_OW 469
15084: PUSH
15085: LD_INT 1
15087: ARRAY
15088: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15089: LD_ADDR_VAR 0 6
15093: PUSH
15094: LD_INT 1
15096: PPUSH
15097: CALL_OW 469
15101: PUSH
15102: LD_INT 2
15104: ARRAY
15105: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15106: LD_ADDR_VAR 0 8
15110: PUSH
15111: LD_INT 22
15113: PUSH
15114: LD_OWVAR 2
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PUSH
15123: LD_INT 2
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: LD_INT 8
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: PUSH
15136: LD_INT 30
15138: PUSH
15139: LD_INT 11
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: LIST
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PPUSH
15155: CALL_OW 69
15159: PPUSH
15160: LD_VAR 0 5
15164: PPUSH
15165: LD_VAR 0 6
15169: PPUSH
15170: CALL_OW 73
15174: ST_TO_ADDR
// if icon = art_exp_left then
15175: LD_VAR 0 2
15179: PUSH
15180: LD_INT 1
15182: EQUAL
15183: IFFALSE 15222
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15185: LD_VAR 0 8
15189: PPUSH
15190: LD_EXP 9
15194: PPUSH
15195: LD_INT 1
15197: PPUSH
15198: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15202: LD_OWVAR 2
15206: PPUSH
15207: LD_INT 1
15209: PPUSH
15210: LD_INT 0
15212: PPUSH
15213: LD_VAR 0 8
15217: PPUSH
15218: CALL_OW 468
// end ; if icon = art_icon then
15222: LD_VAR 0 2
15226: PUSH
15227: LD_EXP 8
15231: EQUAL
15232: IFFALSE 15446
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15234: LD_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 3
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: PPUSH
15249: CALL_OW 69
15253: IN
15254: IFFALSE 15446
// begin side := GetSide ( cr1 ) ;
15256: LD_ADDR_VAR 0 9
15260: PUSH
15261: LD_VAR 0 3
15265: PPUSH
15266: CALL_OW 255
15270: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15271: LD_INT 22
15273: PUSH
15274: LD_VAR 0 9
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: PUSH
15283: LD_INT 30
15285: PUSH
15286: LD_INT 28
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: CALL_OW 69
15301: PUSH
15302: LD_INT 0
15304: GREATER
15305: IFFALSE 15446
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_INT 22
15314: PUSH
15315: LD_VAR 0 9
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 2
15326: PUSH
15327: LD_INT 30
15329: PUSH
15330: LD_INT 26
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 30
15339: PUSH
15340: LD_INT 27
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 30
15349: PUSH
15350: LD_INT 28
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PPUSH
15367: CALL_OW 69
15371: PUSH
15372: FOR_IN
15373: IFFALSE 15389
// SetLives ( i , 1 ) ;
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 234
15387: GO 15372
15389: POP
15390: POP
// player_res_art := false ;
15391: LD_ADDR_EXP 6
15395: PUSH
15396: LD_INT 0
15398: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15399: LD_OWVAR 2
15403: PPUSH
15404: LD_EXP 8
15408: PPUSH
15409: LD_INT 1
15411: PPUSH
15412: LD_VAR 0 8
15416: PPUSH
15417: CALL_OW 468
// Wait ( time_to_reuse ) ;
15421: LD_EXP 11
15425: PPUSH
15426: CALL_OW 67
// player_res_art := true ;
15430: LD_ADDR_EXP 6
15434: PUSH
15435: LD_INT 1
15437: ST_TO_ADDR
// medal_enabled := true ;
15438: LD_ADDR_EXP 13
15442: PUSH
15443: LD_INT 1
15445: ST_TO_ADDR
// end ; end ; end ; end ;
15446: PPOPN 9
15448: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15449: LD_VAR 0 1
15453: PPUSH
15454: CALL_OW 255
15458: PUSH
15459: LD_OWVAR 2
15463: EQUAL
15464: IFFALSE 15501
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15466: LD_OWVAR 2
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: LD_VAR 0 1
15481: PPUSH
15482: CALL_OW 468
// player_artifact_ready := true ;
15486: LD_ADDR_EXP 7
15490: PUSH
15491: LD_INT 1
15493: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15494: LD_STRING ArtVulcano
15496: PPUSH
15497: CALL_OW 339
// end ; end ;
15501: PPOPN 1
15503: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15504: LD_OWVAR 2
15508: PPUSH
15509: LD_INT 1
15511: PPUSH
15512: LD_INT 2
15514: PPUSH
15515: LD_VAR 0 1
15519: PPUSH
15520: CALL_OW 468
// end ; end_of_file
15524: PPOPN 2
15526: END
// every 0 0$01 do
15527: GO 15529
15529: DISABLE
// begin enable ;
15530: ENABLE
// Display_Strings := [ #tick , tick ] ;
15531: LD_ADDR_OWVAR 47
15535: PUSH
15536: LD_STRING #tick
15538: PUSH
15539: LD_OWVAR 1
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: ST_TO_ADDR
// end ; end_of_file
15548: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15549: LD_INT 0
15551: PPUSH
15552: PPUSH
15553: PPUSH
15554: PPUSH
15555: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15556: LD_ADDR_EXP 39
15560: PUSH
15561: LD_INT 7
15563: PUSH
15564: LD_INT 6
15566: PUSH
15567: LD_INT 5
15569: PUSH
15570: EMPTY
15571: LIST
15572: LIST
15573: LIST
15574: PUSH
15575: LD_OWVAR 67
15579: ARRAY
15580: ST_TO_ADDR
// al_force := [ ] ;
15581: LD_ADDR_EXP 38
15585: PUSH
15586: EMPTY
15587: ST_TO_ADDR
// RemoveAlliance ;
15588: CALL 15966 0 0
// ResetFog ;
15592: CALL_OW 335
// your_side := 7 ;
15596: LD_ADDR_OWVAR 2
15600: PUSH
15601: LD_INT 7
15603: ST_TO_ADDR
// uc_side := 7 ;
15604: LD_ADDR_OWVAR 20
15608: PUSH
15609: LD_INT 7
15611: ST_TO_ADDR
// hc_gallery :=  ;
15612: LD_ADDR_OWVAR 33
15616: PUSH
15617: LD_STRING 
15619: ST_TO_ADDR
// hc_name :=  ;
15620: LD_ADDR_OWVAR 26
15624: PUSH
15625: LD_STRING 
15627: ST_TO_ADDR
// hc_importance := 0 ;
15628: LD_ADDR_OWVAR 32
15632: PUSH
15633: LD_INT 0
15635: ST_TO_ADDR
// for i = 1 to 17 do
15636: LD_ADDR_VAR 0 2
15640: PUSH
15641: DOUBLE
15642: LD_INT 1
15644: DEC
15645: ST_TO_ADDR
15646: LD_INT 17
15648: PUSH
15649: FOR_TO
15650: IFFALSE 15730
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15652: LD_ADDR_OWVAR 21
15656: PUSH
15657: LD_INT 1
15659: PUSH
15660: LD_INT 3
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: PUSH
15667: LD_INT 1
15669: PPUSH
15670: LD_INT 2
15672: PPUSH
15673: CALL_OW 12
15677: ARRAY
15678: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15679: LD_INT 0
15681: PPUSH
15682: LD_INT 1
15684: PPUSH
15685: LD_INT 4
15687: PPUSH
15688: CALL_OW 12
15692: PPUSH
15693: LD_EXP 39
15697: PPUSH
15698: CALL_OW 380
// un := CreateHuman ;
15702: LD_ADDR_VAR 0 4
15706: PUSH
15707: CALL_OW 44
15711: ST_TO_ADDR
// al_force := al_force ^ un ;
15712: LD_ADDR_EXP 38
15716: PUSH
15717: LD_EXP 38
15721: PUSH
15722: LD_VAR 0 4
15726: ADD
15727: ST_TO_ADDR
// end ;
15728: GO 15649
15730: POP
15731: POP
// hc_importance := 100 ;
15732: LD_ADDR_OWVAR 32
15736: PUSH
15737: LD_INT 100
15739: ST_TO_ADDR
// uc_nation := 1 ;
15740: LD_ADDR_OWVAR 21
15744: PUSH
15745: LD_INT 1
15747: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 1
15753: PPUSH
15754: LD_EXP 39
15758: PPUSH
15759: CALL_OW 380
// al_commander := CreateHuman ;
15763: LD_ADDR_EXP 37
15767: PUSH
15768: CALL_OW 44
15772: ST_TO_ADDR
// player_commander := al_commander ;
15773: LD_ADDR_EXP 10
15777: PUSH
15778: LD_EXP 37
15782: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15783: LD_ADDR_VAR 0 5
15787: PUSH
15788: LD_STRING text
15790: PPUSH
15791: LD_INT 9
15793: PUSH
15794: LD_INT 9
15796: PUSH
15797: LD_INT 8
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: LIST
15804: PUSH
15805: LD_OWVAR 67
15809: ARRAY
15810: PPUSH
15811: LD_INT 9
15813: PUSH
15814: LD_INT 9
15816: PUSH
15817: LD_INT 8
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: LIST
15824: PUSH
15825: LD_OWVAR 67
15829: ARRAY
15830: PPUSH
15831: LD_INT -5
15833: PUSH
15834: LD_EXP 37
15838: PUSH
15839: LD_INT -3
15841: PUSH
15842: LD_INT -2
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: LIST
15849: LIST
15850: PUSH
15851: LD_EXP 38
15855: ADD
15856: PPUSH
15857: LD_INT 1
15859: PUSH
15860: LD_INT 3
15862: PUSH
15863: LD_INT 2
15865: PUSH
15866: LD_INT 1
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: PUSH
15873: LD_INT 4
15875: PUSH
15876: LD_INT 1
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: LD_INT 9
15885: PUSH
15886: LD_INT 5
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 42
15901: ST_TO_ADDR
// team := team ^ al_commander ;
15902: LD_ADDR_VAR 0 5
15906: PUSH
15907: LD_VAR 0 5
15911: PUSH
15912: LD_EXP 37
15916: ADD
15917: ST_TO_ADDR
// for i = 1 to team do
15918: LD_ADDR_VAR 0 2
15922: PUSH
15923: DOUBLE
15924: LD_INT 1
15926: DEC
15927: ST_TO_ADDR
15928: LD_VAR 0 5
15932: PUSH
15933: FOR_TO
15934: IFFALSE 15959
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15936: LD_VAR 0 5
15940: PUSH
15941: LD_VAR 0 2
15945: ARRAY
15946: PPUSH
15947: LD_INT 15
15949: PPUSH
15950: LD_INT 0
15952: PPUSH
15953: CALL_OW 49
15957: GO 15933
15959: POP
15960: POP
// end ;
15961: LD_VAR 0 1
15965: RET
// export function RemoveAlliance ; var i ; begin
15966: LD_INT 0
15968: PPUSH
15969: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15970: LD_INT 22
15972: PUSH
15973: LD_INT 7
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PUSH
15980: LD_INT 30
15982: PUSH
15983: LD_INT 1
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 69
15998: PUSH
15999: LD_INT 1
16001: ARRAY
16002: PPUSH
16003: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_INT 22
16014: PUSH
16015: LD_INT 7
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PPUSH
16022: CALL_OW 69
16026: PUSH
16027: FOR_IN
16028: IFFALSE 16041
// RemoveUnit ( i ) ;
16030: LD_VAR 0 2
16034: PPUSH
16035: CALL_OW 64
16039: GO 16027
16041: POP
16042: POP
// end ;
16043: LD_VAR 0 1
16047: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16048: LD_INT 0
16050: PPUSH
16051: PPUSH
16052: PPUSH
16053: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16054: LD_INT 31
16056: PPUSH
16057: LD_INT 7
16059: PPUSH
16060: LD_INT 2
16062: PPUSH
16063: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16067: LD_INT 32
16069: PPUSH
16070: LD_INT 7
16072: PPUSH
16073: LD_INT 2
16075: PPUSH
16076: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16080: LD_INT 59
16082: PPUSH
16083: LD_INT 7
16085: PPUSH
16086: LD_INT 2
16088: PPUSH
16089: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16093: LD_ADDR_EXP 39
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 6
16103: PUSH
16104: LD_INT 7
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: LD_OWVAR 67
16116: ARRAY
16117: ST_TO_ADDR
// al_force := [ ] ;
16118: LD_ADDR_EXP 38
16122: PUSH
16123: EMPTY
16124: ST_TO_ADDR
// al_vehs := [ ] ;
16125: LD_ADDR_EXP 44
16129: PUSH
16130: EMPTY
16131: ST_TO_ADDR
// uc_side := 7 ;
16132: LD_ADDR_OWVAR 20
16136: PUSH
16137: LD_INT 7
16139: ST_TO_ADDR
// uc_nation := 1 ;
16140: LD_ADDR_OWVAR 21
16144: PUSH
16145: LD_INT 1
16147: ST_TO_ADDR
// bc_type := b_oil_mine ;
16148: LD_ADDR_OWVAR 42
16152: PUSH
16153: LD_INT 29
16155: ST_TO_ADDR
// b := CreateBuilding ;
16156: LD_ADDR_VAR 0 4
16160: PUSH
16161: CALL_OW 46
16165: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16166: LD_VAR 0 4
16170: PPUSH
16171: LD_INT 61
16173: PPUSH
16174: LD_INT 7
16176: PPUSH
16177: LD_INT 0
16179: PPUSH
16180: LD_INT 0
16182: PPUSH
16183: CALL_OW 50
// bc_type := b_siberite_mine ;
16187: LD_ADDR_OWVAR 42
16191: PUSH
16192: LD_INT 30
16194: ST_TO_ADDR
// b := CreateBuilding ;
16195: LD_ADDR_VAR 0 4
16199: PUSH
16200: CALL_OW 46
16204: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16205: LD_VAR 0 4
16209: PPUSH
16210: LD_INT 69
16212: PPUSH
16213: LD_INT 13
16215: PPUSH
16216: LD_INT 0
16218: PPUSH
16219: LD_INT 0
16221: PPUSH
16222: CALL_OW 50
// hc_gallery :=  ;
16226: LD_ADDR_OWVAR 33
16230: PUSH
16231: LD_STRING 
16233: ST_TO_ADDR
// hc_name :=  ;
16234: LD_ADDR_OWVAR 26
16238: PUSH
16239: LD_STRING 
16241: ST_TO_ADDR
// hc_importance := 0 ;
16242: LD_ADDR_OWVAR 32
16246: PUSH
16247: LD_INT 0
16249: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16250: LD_ADDR_VAR 0 2
16254: PUSH
16255: LD_INT 22
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: LD_INT 30
16267: PUSH
16268: LD_INT 32
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: PUSH
16284: FOR_IN
16285: IFFALSE 16355
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16287: LD_ADDR_OWVAR 21
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: LD_INT 3
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 1
16304: PPUSH
16305: LD_INT 2
16307: PPUSH
16308: CALL_OW 12
16312: ARRAY
16313: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16314: LD_INT 0
16316: PPUSH
16317: LD_INT 1
16319: PPUSH
16320: LD_EXP 39
16324: PPUSH
16325: CALL_OW 380
// un := CreateHuman ;
16329: LD_ADDR_VAR 0 3
16333: PUSH
16334: CALL_OW 44
16338: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16339: LD_VAR 0 3
16343: PPUSH
16344: LD_VAR 0 2
16348: PPUSH
16349: CALL_OW 52
// end ;
16353: GO 16284
16355: POP
16356: POP
// for i = 1 to 3 do
16357: LD_ADDR_VAR 0 2
16361: PUSH
16362: DOUBLE
16363: LD_INT 1
16365: DEC
16366: ST_TO_ADDR
16367: LD_INT 3
16369: PUSH
16370: FOR_TO
16371: IFFALSE 16439
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16373: LD_ADDR_OWVAR 21
16377: PUSH
16378: LD_INT 1
16380: PUSH
16381: LD_INT 3
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_INT 2
16393: PPUSH
16394: CALL_OW 12
16398: ARRAY
16399: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16400: LD_INT 0
16402: PPUSH
16403: LD_INT 4
16405: PPUSH
16406: LD_EXP 39
16410: PPUSH
16411: CALL_OW 380
// un := CreateHuman ;
16415: LD_ADDR_VAR 0 3
16419: PUSH
16420: CALL_OW 44
16424: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: LD_INT 164
16432: PPUSH
16433: CALL_OW 52
// end ;
16437: GO 16370
16439: POP
16440: POP
// for i = 1 to 6 do
16441: LD_ADDR_VAR 0 2
16445: PUSH
16446: DOUBLE
16447: LD_INT 1
16449: DEC
16450: ST_TO_ADDR
16451: LD_INT 6
16453: PUSH
16454: FOR_TO
16455: IFFALSE 16546
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16457: LD_ADDR_OWVAR 21
16461: PUSH
16462: LD_INT 1
16464: PUSH
16465: LD_INT 3
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 1
16474: PPUSH
16475: LD_INT 2
16477: PPUSH
16478: CALL_OW 12
16482: ARRAY
16483: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16484: LD_INT 0
16486: PPUSH
16487: LD_INT 5
16489: PUSH
16490: LD_INT 9
16492: PUSH
16493: LD_INT 9
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 1
16503: PPUSH
16504: LD_INT 3
16506: PPUSH
16507: CALL_OW 12
16511: ARRAY
16512: PPUSH
16513: LD_EXP 39
16517: PPUSH
16518: CALL_OW 380
// un := CreateHuman ;
16522: LD_ADDR_VAR 0 3
16526: PUSH
16527: CALL_OW 44
16531: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16532: LD_VAR 0 3
16536: PPUSH
16537: LD_INT 173
16539: PPUSH
16540: CALL_OW 52
// end ;
16544: GO 16454
16546: POP
16547: POP
// for i = 1 to 6 do
16548: LD_ADDR_VAR 0 2
16552: PUSH
16553: DOUBLE
16554: LD_INT 1
16556: DEC
16557: ST_TO_ADDR
16558: LD_INT 6
16560: PUSH
16561: FOR_TO
16562: IFFALSE 16660
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16564: LD_ADDR_OWVAR 21
16568: PUSH
16569: LD_INT 1
16571: PUSH
16572: LD_INT 3
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 1
16581: PPUSH
16582: LD_INT 2
16584: PPUSH
16585: CALL_OW 12
16589: ARRAY
16590: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16591: LD_INT 0
16593: PPUSH
16594: LD_INT 3
16596: PPUSH
16597: LD_EXP 39
16601: PPUSH
16602: CALL_OW 380
// un := CreateHuman ;
16606: LD_ADDR_VAR 0 3
16610: PUSH
16611: CALL_OW 44
16615: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16616: LD_VAR 0 3
16620: PPUSH
16621: LD_INT 22
16623: PUSH
16624: LD_INT 7
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: LD_INT 30
16633: PUSH
16634: LD_INT 3
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL_OW 69
16649: PUSH
16650: LD_INT 1
16652: ARRAY
16653: PPUSH
16654: CALL_OW 52
// end ;
16658: GO 16561
16660: POP
16661: POP
// for i = 1 to 4 do
16662: LD_ADDR_VAR 0 2
16666: PUSH
16667: DOUBLE
16668: LD_INT 1
16670: DEC
16671: ST_TO_ADDR
16672: LD_INT 4
16674: PUSH
16675: FOR_TO
16676: IFFALSE 16744
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16678: LD_ADDR_OWVAR 21
16682: PUSH
16683: LD_INT 1
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 1
16695: PPUSH
16696: LD_INT 2
16698: PPUSH
16699: CALL_OW 12
16703: ARRAY
16704: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16705: LD_INT 0
16707: PPUSH
16708: LD_INT 2
16710: PPUSH
16711: LD_EXP 39
16715: PPUSH
16716: CALL_OW 380
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 3
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16730: LD_VAR 0 3
16734: PPUSH
16735: LD_INT 162
16737: PPUSH
16738: CALL_OW 52
// end ;
16742: GO 16675
16744: POP
16745: POP
// uc_nation := 3 ;
16746: LD_ADDR_OWVAR 21
16750: PUSH
16751: LD_INT 3
16753: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16754: LD_ADDR_OWVAR 37
16758: PUSH
16759: LD_INT 21
16761: ST_TO_ADDR
// vc_engine := engine_siberite ;
16762: LD_ADDR_OWVAR 39
16766: PUSH
16767: LD_INT 3
16769: ST_TO_ADDR
// vc_control := control_computer ;
16770: LD_ADDR_OWVAR 38
16774: PUSH
16775: LD_INT 3
16777: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16778: LD_ADDR_OWVAR 40
16782: PUSH
16783: LD_INT 51
16785: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16786: CALL_OW 45
16790: PPUSH
16791: LD_INT 49
16793: PPUSH
16794: LD_INT 13
16796: PPUSH
16797: LD_INT 0
16799: PPUSH
16800: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16804: LD_ADDR_EXP 46
16808: PUSH
16809: LD_INT 22
16811: PUSH
16812: LD_INT 7
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: LD_INT 30
16821: PUSH
16822: LD_INT 33
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 69
16837: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: DOUBLE
16844: LD_INT 1
16846: DEC
16847: ST_TO_ADDR
16848: LD_INT 22
16850: PUSH
16851: LD_INT 7
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 30
16860: PUSH
16861: LD_INT 33
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PUSH
16868: LD_INT 35
16870: PUSH
16871: LD_INT 0
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: PUSH
16883: EMPTY
16884: LIST
16885: PPUSH
16886: CALL_OW 69
16890: PUSH
16891: FOR_TO
16892: IFFALSE 16952
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16894: LD_INT 22
16896: PUSH
16897: LD_INT 7
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: LD_INT 30
16906: PUSH
16907: LD_INT 33
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: PUSH
16914: LD_INT 35
16916: PUSH
16917: LD_INT 0
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: LIST
16928: PUSH
16929: EMPTY
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_VAR 0 2
16941: ARRAY
16942: PPUSH
16943: LD_INT 49
16945: PPUSH
16946: CALL_OW 208
16950: GO 16891
16952: POP
16953: POP
// end ;
16954: LD_VAR 0 1
16958: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16959: LD_OWVAR 2
16963: PUSH
16964: LD_INT 1
16966: EQUAL
16967: IFFALSE 18135
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
16976: PPUSH
16977: PPUSH
// begin enable ;
16978: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16979: LD_ADDR_EXP 50
16983: PUSH
16984: LD_INT 22
16986: PUSH
16987: LD_INT 7
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 21
16996: PUSH
16997: LD_INT 3
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PPUSH
17008: CALL_OW 69
17012: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17013: LD_ADDR_EXP 48
17017: PUSH
17018: LD_INT 164
17020: PUSH
17021: LD_INT 197
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17028: LD_ADDR_EXP 47
17032: PUSH
17033: LD_INT 22
17035: PUSH
17036: LD_INT 7
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 30
17045: PUSH
17046: LD_INT 1
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PUSH
17053: EMPTY
17054: LIST
17055: LIST
17056: PPUSH
17057: CALL_OW 69
17061: PUSH
17062: LD_INT 1
17064: ARRAY
17065: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17066: LD_ADDR_EXP 49
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 7
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 30
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17104: LD_INT 22
17106: PUSH
17107: LD_INT 7
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: LD_INT 34
17116: PUSH
17117: LD_INT 51
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PPUSH
17128: CALL_OW 69
17132: IFFALSE 17172
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17134: LD_ADDR_EXP 45
17138: PUSH
17139: LD_INT 22
17141: PUSH
17142: LD_INT 7
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 34
17151: PUSH
17152: LD_INT 51
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PPUSH
17163: CALL_OW 69
17167: PUSH
17168: LD_INT 1
17170: ARRAY
17171: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17172: LD_ADDR_EXP 41
17176: PUSH
17177: LD_INT 22
17179: PUSH
17180: LD_INT 7
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 9
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PPUSH
17201: CALL_OW 69
17205: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17206: LD_ADDR_EXP 40
17210: PUSH
17211: LD_INT 22
17213: PUSH
17214: LD_INT 7
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: LD_INT 25
17223: PUSH
17224: LD_INT 2
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PPUSH
17235: CALL_OW 69
17239: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17240: LD_ADDR_EXP 42
17244: PUSH
17245: LD_INT 22
17247: PUSH
17248: LD_INT 7
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: LD_INT 25
17257: PUSH
17258: LD_INT 3
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17274: LD_ADDR_EXP 43
17278: PUSH
17279: LD_INT 22
17281: PUSH
17282: LD_INT 7
17284: PUSH
17285: EMPTY
17286: LIST
17287: LIST
17288: PUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PPUSH
17303: CALL_OW 69
17307: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17308: LD_EXP 41
17312: PPUSH
17313: LD_INT 81
17315: PUSH
17316: LD_INT 7
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: PPUSH
17328: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17332: LD_EXP 45
17336: PPUSH
17337: CALL_OW 314
17341: NOT
17342: PUSH
17343: LD_EXP 45
17347: PPUSH
17348: LD_INT 1
17350: PPUSH
17351: CALL_OW 289
17355: PUSH
17356: LD_INT 100
17358: LESS
17359: AND
17360: IFFALSE 17408
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17362: LD_ADDR_VAR 0 4
17366: PUSH
17367: LD_INT 12
17369: PPUSH
17370: CALL_OW 435
17374: ST_TO_ADDR
// if cr then
17375: LD_VAR 0 4
17379: IFFALSE 17408
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17381: LD_EXP 45
17385: PPUSH
17386: LD_VAR 0 4
17390: PUSH
17391: LD_INT 1
17393: ARRAY
17394: PPUSH
17395: LD_VAR 0 4
17399: PUSH
17400: LD_INT 2
17402: ARRAY
17403: PPUSH
17404: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17408: LD_EXP 50
17412: PPUSH
17413: LD_INT 3
17415: PUSH
17416: LD_INT 24
17418: PUSH
17419: LD_INT 1000
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: PUSH
17426: EMPTY
17427: LIST
17428: LIST
17429: PPUSH
17430: CALL_OW 72
17434: IFFALSE 17564
// begin if al_eng then
17436: LD_EXP 40
17440: IFFALSE 17562
// for i = 1 to al_eng do
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: DOUBLE
17448: LD_INT 1
17450: DEC
17451: ST_TO_ADDR
17452: LD_EXP 40
17456: PUSH
17457: FOR_TO
17458: IFFALSE 17560
// if IsInUnit ( al_eng [ i ] ) then
17460: LD_EXP 40
17464: PUSH
17465: LD_VAR 0 1
17469: ARRAY
17470: PPUSH
17471: CALL_OW 310
17475: IFFALSE 17494
// ComExitBuilding ( al_eng [ i ] ) else
17477: LD_EXP 40
17481: PUSH
17482: LD_VAR 0 1
17486: ARRAY
17487: PPUSH
17488: CALL_OW 122
17492: GO 17558
// if not HasTask ( al_eng [ i ] ) then
17494: LD_EXP 40
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 314
17509: NOT
17510: IFFALSE 17558
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17512: LD_EXP 40
17516: PUSH
17517: LD_VAR 0 1
17521: ARRAY
17522: PPUSH
17523: LD_EXP 50
17527: PPUSH
17528: LD_INT 3
17530: PUSH
17531: LD_INT 24
17533: PUSH
17534: LD_INT 1000
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: EMPTY
17542: LIST
17543: LIST
17544: PPUSH
17545: CALL_OW 72
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: CALL_OW 130
17558: GO 17457
17560: POP
17561: POP
// end else
17562: GO 17646
// if al_eng then
17564: LD_EXP 40
17568: IFFALSE 17646
// if not IsInUnit ( al_eng [ 1 ] ) then
17570: LD_EXP 40
17574: PUSH
17575: LD_INT 1
17577: ARRAY
17578: PPUSH
17579: CALL_OW 310
17583: NOT
17584: IFFALSE 17646
// for i = 1 to al_eng do
17586: LD_ADDR_VAR 0 1
17590: PUSH
17591: DOUBLE
17592: LD_INT 1
17594: DEC
17595: ST_TO_ADDR
17596: LD_EXP 40
17600: PUSH
17601: FOR_TO
17602: IFFALSE 17644
// if not IsInUnit ( al_eng [ i ] ) then
17604: LD_EXP 40
17608: PUSH
17609: LD_VAR 0 1
17613: ARRAY
17614: PPUSH
17615: CALL_OW 310
17619: NOT
17620: IFFALSE 17642
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17622: LD_EXP 40
17626: PUSH
17627: LD_VAR 0 1
17631: ARRAY
17632: PPUSH
17633: LD_EXP 47
17637: PPUSH
17638: CALL_OW 120
17642: GO 17601
17644: POP
17645: POP
// if al_vehs then
17646: LD_EXP 44
17650: IFFALSE 17750
// if BuildingStatus ( al_fac ) = bs_idle then
17652: LD_EXP 49
17656: PPUSH
17657: CALL_OW 461
17661: PUSH
17662: LD_INT 2
17664: EQUAL
17665: IFFALSE 17750
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17667: LD_EXP 49
17671: PPUSH
17672: LD_EXP 44
17676: PUSH
17677: LD_INT 1
17679: ARRAY
17680: PPUSH
17681: LD_EXP 44
17685: PUSH
17686: LD_INT 2
17688: ARRAY
17689: PPUSH
17690: LD_EXP 44
17694: PUSH
17695: LD_INT 3
17697: ARRAY
17698: PPUSH
17699: LD_EXP 44
17703: PUSH
17704: LD_INT 4
17706: ARRAY
17707: PPUSH
17708: CALL_OW 125
// for i = 1 to 4 do
17712: LD_ADDR_VAR 0 1
17716: PUSH
17717: DOUBLE
17718: LD_INT 1
17720: DEC
17721: ST_TO_ADDR
17722: LD_INT 4
17724: PUSH
17725: FOR_TO
17726: IFFALSE 17748
// al_vehs := Delete ( al_vehs , 1 ) ;
17728: LD_ADDR_EXP 44
17732: PUSH
17733: LD_EXP 44
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 3
17745: ST_TO_ADDR
17746: GO 17725
17748: POP
17749: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17750: LD_EXP 38
17754: PUSH
17755: LD_INT 0
17757: EQUAL
17758: PUSH
17759: LD_OWVAR 1
17763: PUSH
17764: LD_INT 23100
17766: MOD
17767: PUSH
17768: LD_INT 0
17770: EQUAL
17771: AND
17772: IFFALSE 17886
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17774: LD_ADDR_VAR 0 1
17778: PUSH
17779: DOUBLE
17780: LD_INT 1
17782: DEC
17783: ST_TO_ADDR
17784: LD_INT 4
17786: PUSH
17787: LD_INT 5
17789: PUSH
17790: LD_INT 6
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: LIST
17797: PUSH
17798: LD_OWVAR 67
17802: ARRAY
17803: PUSH
17804: FOR_TO
17805: IFFALSE 17884
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17807: LD_ADDR_EXP 44
17811: PUSH
17812: LD_EXP 44
17816: PUSH
17817: LD_INT 23
17819: ADD
17820: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17821: LD_ADDR_EXP 44
17825: PUSH
17826: LD_EXP 44
17830: PUSH
17831: LD_INT 1
17833: ADD
17834: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17835: LD_ADDR_EXP 44
17839: PUSH
17840: LD_EXP 44
17844: PUSH
17845: LD_INT 3
17847: ADD
17848: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17849: LD_ADDR_EXP 44
17853: PUSH
17854: LD_EXP 44
17858: PUSH
17859: LD_INT 46
17861: PUSH
17862: LD_INT 47
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: PUSH
17869: LD_INT 1
17871: PPUSH
17872: LD_INT 2
17874: PPUSH
17875: CALL_OW 12
17879: ARRAY
17880: ADD
17881: ST_TO_ADDR
// end ;
17882: GO 17804
17884: POP
17885: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17886: LD_INT 22
17888: PUSH
17889: LD_INT 7
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PUSH
17896: LD_INT 34
17898: PUSH
17899: LD_INT 51
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PPUSH
17910: CALL_OW 69
17914: PUSH
17915: LD_INT 0
17917: EQUAL
17918: IFFALSE 17941
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17920: LD_EXP 49
17924: PPUSH
17925: LD_INT 21
17927: PPUSH
17928: LD_INT 1
17930: PPUSH
17931: LD_INT 3
17933: PPUSH
17934: LD_INT 51
17936: PPUSH
17937: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17941: LD_EXP 38
17945: PUSH
17946: LD_OWVAR 1
17950: PUSH
17951: LD_INT 25200
17953: MOD
17954: PUSH
17955: LD_INT 0
17957: EQUAL
17958: AND
17959: IFFALSE 18022
// begin for i = 1 to al_force do
17961: LD_ADDR_VAR 0 1
17965: PUSH
17966: DOUBLE
17967: LD_INT 1
17969: DEC
17970: ST_TO_ADDR
17971: LD_EXP 38
17975: PUSH
17976: FOR_TO
17977: IFFALSE 18020
// if GetTag ( al_force [ i ] ) <> 11 then
17979: LD_EXP 38
17983: PUSH
17984: LD_VAR 0 1
17988: ARRAY
17989: PPUSH
17990: CALL_OW 110
17994: PUSH
17995: LD_INT 11
17997: NONEQUAL
17998: IFFALSE 18018
// SetTag ( al_force [ i ] , 11 ) ;
18000: LD_EXP 38
18004: PUSH
18005: LD_VAR 0 1
18009: ARRAY
18010: PPUSH
18011: LD_INT 11
18013: PPUSH
18014: CALL_OW 109
18018: GO 17976
18020: POP
18021: POP
// end ; if al_force then
18022: LD_EXP 38
18026: IFFALSE 18135
// for i = 1 to al_force do
18028: LD_ADDR_VAR 0 1
18032: PUSH
18033: DOUBLE
18034: LD_INT 1
18036: DEC
18037: ST_TO_ADDR
18038: LD_EXP 38
18042: PUSH
18043: FOR_TO
18044: IFFALSE 18133
// begin if GetTag ( al_force [ i ] ) = 11 then
18046: LD_EXP 38
18050: PUSH
18051: LD_VAR 0 1
18055: ARRAY
18056: PPUSH
18057: CALL_OW 110
18061: PUSH
18062: LD_INT 11
18064: EQUAL
18065: IFFALSE 18131
// begin if not HasTask ( al_force [ i ] ) then
18067: LD_EXP 38
18071: PUSH
18072: LD_VAR 0 1
18076: ARRAY
18077: PPUSH
18078: CALL_OW 314
18082: NOT
18083: IFFALSE 18131
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18085: LD_EXP 38
18089: PUSH
18090: LD_VAR 0 1
18094: ARRAY
18095: PPUSH
18096: LD_INT 81
18098: PUSH
18099: LD_INT 7
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: PPUSH
18106: CALL_OW 69
18110: PPUSH
18111: LD_EXP 38
18115: PUSH
18116: LD_VAR 0 1
18120: ARRAY
18121: PPUSH
18122: CALL_OW 74
18126: PPUSH
18127: CALL_OW 115
// end ; end ;
18131: GO 18043
18133: POP
18134: POP
// end ; end_of_file
18135: PPOPN 4
18137: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18138: LD_INT 0
18140: PPUSH
18141: PPUSH
18142: PPUSH
18143: PPUSH
18144: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18145: LD_ADDR_EXP 53
18149: PUSH
18150: LD_INT 7
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 5
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: LIST
18163: PUSH
18164: LD_OWVAR 67
18168: ARRAY
18169: ST_TO_ADDR
// ar_force := [ ] ;
18170: LD_ADDR_EXP 52
18174: PUSH
18175: EMPTY
18176: ST_TO_ADDR
// RemoveAlliance ;
18177: CALL 15966 0 0
// RemoveEnvironmentArea ( evn ) ;
18181: LD_INT 17
18183: PPUSH
18184: CALL_OW 355
// your_side := 2 ;
18188: LD_ADDR_OWVAR 2
18192: PUSH
18193: LD_INT 2
18195: ST_TO_ADDR
// uc_side := 2 ;
18196: LD_ADDR_OWVAR 20
18200: PUSH
18201: LD_INT 2
18203: ST_TO_ADDR
// uc_nation := nation_arabian ;
18204: LD_ADDR_OWVAR 21
18208: PUSH
18209: LD_INT 2
18211: ST_TO_ADDR
// hc_gallery :=  ;
18212: LD_ADDR_OWVAR 33
18216: PUSH
18217: LD_STRING 
18219: ST_TO_ADDR
// hc_name :=  ;
18220: LD_ADDR_OWVAR 26
18224: PUSH
18225: LD_STRING 
18227: ST_TO_ADDR
// hc_importance := 0 ;
18228: LD_ADDR_OWVAR 32
18232: PUSH
18233: LD_INT 0
18235: ST_TO_ADDR
// for i = 1 to 15 do
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: DOUBLE
18242: LD_INT 1
18244: DEC
18245: ST_TO_ADDR
18246: LD_INT 15
18248: PUSH
18249: FOR_TO
18250: IFFALSE 18303
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18252: LD_INT 0
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_INT 4
18260: PPUSH
18261: CALL_OW 12
18265: PPUSH
18266: LD_EXP 53
18270: PPUSH
18271: CALL_OW 380
// un := CreateHuman ;
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: CALL_OW 44
18284: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18285: LD_ADDR_EXP 52
18289: PUSH
18290: LD_EXP 52
18294: PUSH
18295: LD_VAR 0 4
18299: ADD
18300: ST_TO_ADDR
// end ;
18301: GO 18249
18303: POP
18304: POP
// hc_importance := 100 ;
18305: LD_ADDR_OWVAR 32
18309: PUSH
18310: LD_INT 100
18312: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18313: LD_INT 1
18315: PPUSH
18316: LD_INT 11
18318: PPUSH
18319: LD_EXP 53
18323: PPUSH
18324: CALL_OW 380
// ar_commander := CreateHuman ;
18328: LD_ADDR_EXP 51
18332: PUSH
18333: CALL_OW 44
18337: ST_TO_ADDR
// player_commander := ar_commander ;
18338: LD_ADDR_EXP 10
18342: PUSH
18343: LD_EXP 51
18347: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18348: LD_ADDR_VAR 0 5
18352: PUSH
18353: LD_STRING text
18355: PPUSH
18356: LD_INT 11
18358: PUSH
18359: LD_INT 10
18361: PUSH
18362: LD_INT 9
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: PUSH
18370: LD_OWVAR 67
18374: ARRAY
18375: PPUSH
18376: LD_INT 11
18378: PUSH
18379: LD_INT 10
18381: PUSH
18382: LD_INT 9
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: LD_OWVAR 67
18394: ARRAY
18395: PPUSH
18396: LD_INT -5
18398: PUSH
18399: LD_EXP 51
18403: PUSH
18404: LD_INT -3
18406: PUSH
18407: LD_INT -2
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: PUSH
18416: LD_EXP 52
18420: ADD
18421: PPUSH
18422: LD_INT 1
18424: PUSH
18425: LD_INT 3
18427: PUSH
18428: LD_INT 2
18430: PUSH
18431: LD_INT 1
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: PUSH
18438: LD_INT 4
18440: PUSH
18441: LD_INT 1
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PUSH
18448: LD_INT 8
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: PPUSH
18458: CALL_OW 42
18462: ST_TO_ADDR
// team := team ^ ar_commander ;
18463: LD_ADDR_VAR 0 5
18467: PUSH
18468: LD_VAR 0 5
18472: PUSH
18473: LD_EXP 51
18477: ADD
18478: ST_TO_ADDR
// for i = 1 to team do
18479: LD_ADDR_VAR 0 2
18483: PUSH
18484: DOUBLE
18485: LD_INT 1
18487: DEC
18488: ST_TO_ADDR
18489: LD_VAR 0 5
18493: PUSH
18494: FOR_TO
18495: IFFALSE 18520
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18497: LD_VAR 0 5
18501: PUSH
18502: LD_VAR 0 2
18506: ARRAY
18507: PPUSH
18508: LD_INT 16
18510: PPUSH
18511: LD_INT 0
18513: PPUSH
18514: CALL_OW 49
18518: GO 18494
18520: POP
18521: POP
// uc_side := 0 ;
18522: LD_ADDR_OWVAR 20
18526: PUSH
18527: LD_INT 0
18529: ST_TO_ADDR
// uc_nation := 0 ;
18530: LD_ADDR_OWVAR 21
18534: PUSH
18535: LD_INT 0
18537: ST_TO_ADDR
// vc_chassis := 31 ;
18538: LD_ADDR_OWVAR 37
18542: PUSH
18543: LD_INT 31
18545: ST_TO_ADDR
// vc_control := control_rider ;
18546: LD_ADDR_OWVAR 38
18550: PUSH
18551: LD_INT 4
18553: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18554: CALL_OW 45
18558: PPUSH
18559: LD_INT 96
18561: PPUSH
18562: LD_INT 20
18564: PPUSH
18565: LD_INT 0
18567: PPUSH
18568: CALL_OW 48
// end ; end_of_file
18572: LD_VAR 0 1
18576: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18577: GO 18579
18579: DISABLE
// begin ru_radar := 98 ;
18580: LD_ADDR_EXP 54
18584: PUSH
18585: LD_INT 98
18587: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18588: LD_ADDR_EXP 55
18592: PUSH
18593: LD_INT 89
18595: ST_TO_ADDR
// us_hack := 99 ;
18596: LD_ADDR_EXP 56
18600: PUSH
18601: LD_INT 99
18603: ST_TO_ADDR
// us_artillery := 97 ;
18604: LD_ADDR_EXP 57
18608: PUSH
18609: LD_INT 97
18611: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18612: LD_ADDR_EXP 58
18616: PUSH
18617: LD_INT 91
18619: ST_TO_ADDR
// end ; end_of_file end_of_file
18620: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
18621: GO 18623
18623: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18624: LD_STRING initStreamRollete();
18626: PPUSH
18627: CALL_OW 559
// InitStreamMode ;
18631: CALL 18636 0 0
// end ;
18635: END
// function InitStreamMode ; begin
18636: LD_INT 0
18638: PPUSH
// streamModeActive := false ;
18639: LD_ADDR_EXP 59
18643: PUSH
18644: LD_INT 0
18646: ST_TO_ADDR
// sRocket := false ;
18647: LD_ADDR_EXP 62
18651: PUSH
18652: LD_INT 0
18654: ST_TO_ADDR
// sSpeed := false ;
18655: LD_ADDR_EXP 61
18659: PUSH
18660: LD_INT 0
18662: ST_TO_ADDR
// sEngine := false ;
18663: LD_ADDR_EXP 63
18667: PUSH
18668: LD_INT 0
18670: ST_TO_ADDR
// sSpec := false ;
18671: LD_ADDR_EXP 60
18675: PUSH
18676: LD_INT 0
18678: ST_TO_ADDR
// sLevel := false ;
18679: LD_ADDR_EXP 64
18683: PUSH
18684: LD_INT 0
18686: ST_TO_ADDR
// sArmoury := false ;
18687: LD_ADDR_EXP 65
18691: PUSH
18692: LD_INT 0
18694: ST_TO_ADDR
// sRadar := false ;
18695: LD_ADDR_EXP 66
18699: PUSH
18700: LD_INT 0
18702: ST_TO_ADDR
// sBunker := false ;
18703: LD_ADDR_EXP 67
18707: PUSH
18708: LD_INT 0
18710: ST_TO_ADDR
// sHack := false ;
18711: LD_ADDR_EXP 68
18715: PUSH
18716: LD_INT 0
18718: ST_TO_ADDR
// sFire := false ;
18719: LD_ADDR_EXP 69
18723: PUSH
18724: LD_INT 0
18726: ST_TO_ADDR
// sRefresh := false ;
18727: LD_ADDR_EXP 70
18731: PUSH
18732: LD_INT 0
18734: ST_TO_ADDR
// sExp := false ;
18735: LD_ADDR_EXP 71
18739: PUSH
18740: LD_INT 0
18742: ST_TO_ADDR
// sDepot := false ;
18743: LD_ADDR_EXP 72
18747: PUSH
18748: LD_INT 0
18750: ST_TO_ADDR
// sFlag := false ;
18751: LD_ADDR_EXP 73
18755: PUSH
18756: LD_INT 0
18758: ST_TO_ADDR
// sSold := false ;
18759: LD_ADDR_EXP 74
18763: PUSH
18764: LD_INT 0
18766: ST_TO_ADDR
// sDiff := false ;
18767: LD_ADDR_EXP 75
18771: PUSH
18772: LD_INT 0
18774: ST_TO_ADDR
// sTiger := false ;
18775: LD_ADDR_EXP 76
18779: PUSH
18780: LD_INT 0
18782: ST_TO_ADDR
// sBomb := false ;
18783: LD_ADDR_EXP 77
18787: PUSH
18788: LD_INT 0
18790: ST_TO_ADDR
// sFog := false ;
18791: LD_ADDR_EXP 78
18795: PUSH
18796: LD_INT 0
18798: ST_TO_ADDR
// sReset := false ;
18799: LD_ADDR_EXP 79
18803: PUSH
18804: LD_INT 0
18806: ST_TO_ADDR
// sSun := false ;
18807: LD_ADDR_EXP 80
18811: PUSH
18812: LD_INT 0
18814: ST_TO_ADDR
// end ;
18815: LD_VAR 0 1
18819: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
18820: LD_VAR 0 2
18824: PUSH
18825: LD_INT 100
18827: EQUAL
18828: IFFALSE 19237
// begin if not StreamModeActive then
18830: LD_EXP 59
18834: NOT
18835: IFFALSE 18845
// StreamModeActive := true ;
18837: LD_ADDR_EXP 59
18841: PUSH
18842: LD_INT 1
18844: ST_TO_ADDR
// if p3 = 0 then
18845: LD_VAR 0 3
18849: PUSH
18850: LD_INT 0
18852: EQUAL
18853: IFFALSE 18859
// InitStreamMode ;
18855: CALL 18636 0 0
// if p3 = 1 then
18859: LD_VAR 0 3
18863: PUSH
18864: LD_INT 1
18866: EQUAL
18867: IFFALSE 18877
// sRocket := true ;
18869: LD_ADDR_EXP 62
18873: PUSH
18874: LD_INT 1
18876: ST_TO_ADDR
// if p3 = 2 then
18877: LD_VAR 0 3
18881: PUSH
18882: LD_INT 2
18884: EQUAL
18885: IFFALSE 18895
// sSpeed := true ;
18887: LD_ADDR_EXP 61
18891: PUSH
18892: LD_INT 1
18894: ST_TO_ADDR
// if p3 = 3 then
18895: LD_VAR 0 3
18899: PUSH
18900: LD_INT 3
18902: EQUAL
18903: IFFALSE 18913
// sEngine := true ;
18905: LD_ADDR_EXP 63
18909: PUSH
18910: LD_INT 1
18912: ST_TO_ADDR
// if p3 = 4 then
18913: LD_VAR 0 3
18917: PUSH
18918: LD_INT 4
18920: EQUAL
18921: IFFALSE 18931
// sSpec := true ;
18923: LD_ADDR_EXP 60
18927: PUSH
18928: LD_INT 1
18930: ST_TO_ADDR
// if p3 = 5 then
18931: LD_VAR 0 3
18935: PUSH
18936: LD_INT 5
18938: EQUAL
18939: IFFALSE 18949
// sLevel := true ;
18941: LD_ADDR_EXP 64
18945: PUSH
18946: LD_INT 1
18948: ST_TO_ADDR
// if p3 = 6 then
18949: LD_VAR 0 3
18953: PUSH
18954: LD_INT 6
18956: EQUAL
18957: IFFALSE 18967
// sArmoury := true ;
18959: LD_ADDR_EXP 65
18963: PUSH
18964: LD_INT 1
18966: ST_TO_ADDR
// if p3 = 7 then
18967: LD_VAR 0 3
18971: PUSH
18972: LD_INT 7
18974: EQUAL
18975: IFFALSE 18985
// sRadar := true ;
18977: LD_ADDR_EXP 66
18981: PUSH
18982: LD_INT 1
18984: ST_TO_ADDR
// if p3 = 8 then
18985: LD_VAR 0 3
18989: PUSH
18990: LD_INT 8
18992: EQUAL
18993: IFFALSE 19003
// sBunker := true ;
18995: LD_ADDR_EXP 67
18999: PUSH
19000: LD_INT 1
19002: ST_TO_ADDR
// if p3 = 9 then
19003: LD_VAR 0 3
19007: PUSH
19008: LD_INT 9
19010: EQUAL
19011: IFFALSE 19021
// sHack := true ;
19013: LD_ADDR_EXP 68
19017: PUSH
19018: LD_INT 1
19020: ST_TO_ADDR
// if p3 = 10 then
19021: LD_VAR 0 3
19025: PUSH
19026: LD_INT 10
19028: EQUAL
19029: IFFALSE 19039
// sFire := true ;
19031: LD_ADDR_EXP 69
19035: PUSH
19036: LD_INT 1
19038: ST_TO_ADDR
// if p3 = 11 then
19039: LD_VAR 0 3
19043: PUSH
19044: LD_INT 11
19046: EQUAL
19047: IFFALSE 19057
// sRefresh := true ;
19049: LD_ADDR_EXP 70
19053: PUSH
19054: LD_INT 1
19056: ST_TO_ADDR
// if p3 = 12 then
19057: LD_VAR 0 3
19061: PUSH
19062: LD_INT 12
19064: EQUAL
19065: IFFALSE 19075
// sExp := true ;
19067: LD_ADDR_EXP 71
19071: PUSH
19072: LD_INT 1
19074: ST_TO_ADDR
// if p3 = 13 then
19075: LD_VAR 0 3
19079: PUSH
19080: LD_INT 13
19082: EQUAL
19083: IFFALSE 19093
// sDepot := true ;
19085: LD_ADDR_EXP 72
19089: PUSH
19090: LD_INT 1
19092: ST_TO_ADDR
// if p3 = 14 then
19093: LD_VAR 0 3
19097: PUSH
19098: LD_INT 14
19100: EQUAL
19101: IFFALSE 19111
// sFlag := true ;
19103: LD_ADDR_EXP 73
19107: PUSH
19108: LD_INT 1
19110: ST_TO_ADDR
// if p3 = 101 then
19111: LD_VAR 0 3
19115: PUSH
19116: LD_INT 101
19118: EQUAL
19119: IFFALSE 19129
// sSold := true ;
19121: LD_ADDR_EXP 74
19125: PUSH
19126: LD_INT 1
19128: ST_TO_ADDR
// if p3 = 102 then
19129: LD_VAR 0 3
19133: PUSH
19134: LD_INT 102
19136: EQUAL
19137: IFFALSE 19147
// sDiff := true ;
19139: LD_ADDR_EXP 75
19143: PUSH
19144: LD_INT 1
19146: ST_TO_ADDR
// if p3 = 103 then
19147: LD_VAR 0 3
19151: PUSH
19152: LD_INT 103
19154: EQUAL
19155: IFFALSE 19165
// sFog := true ;
19157: LD_ADDR_EXP 78
19161: PUSH
19162: LD_INT 1
19164: ST_TO_ADDR
// if p3 = 104 then
19165: LD_VAR 0 3
19169: PUSH
19170: LD_INT 104
19172: EQUAL
19173: IFFALSE 19183
// sReset := true ;
19175: LD_ADDR_EXP 79
19179: PUSH
19180: LD_INT 1
19182: ST_TO_ADDR
// if p3 = 105 then
19183: LD_VAR 0 3
19187: PUSH
19188: LD_INT 105
19190: EQUAL
19191: IFFALSE 19201
// sSun := true ;
19193: LD_ADDR_EXP 80
19197: PUSH
19198: LD_INT 1
19200: ST_TO_ADDR
// if p3 = 106 then
19201: LD_VAR 0 3
19205: PUSH
19206: LD_INT 106
19208: EQUAL
19209: IFFALSE 19219
// sTiger := true ;
19211: LD_ADDR_EXP 76
19215: PUSH
19216: LD_INT 1
19218: ST_TO_ADDR
// if p3 = 107 then
19219: LD_VAR 0 3
19223: PUSH
19224: LD_INT 107
19226: EQUAL
19227: IFFALSE 19237
// sBomb := true ;
19229: LD_ADDR_EXP 77
19233: PUSH
19234: LD_INT 1
19236: ST_TO_ADDR
// end ; end ;
19237: PPOPN 6
19239: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
19240: LD_EXP 59
19244: PUSH
19245: LD_EXP 62
19249: AND
19250: IFFALSE 19371
19252: GO 19254
19254: DISABLE
19255: LD_INT 0
19257: PPUSH
19258: PPUSH
// begin enable ;
19259: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
19260: LD_ADDR_VAR 0 2
19264: PUSH
19265: LD_INT 22
19267: PUSH
19268: LD_OWVAR 2
19272: PUSH
19273: EMPTY
19274: LIST
19275: LIST
19276: PUSH
19277: LD_INT 2
19279: PUSH
19280: LD_INT 34
19282: PUSH
19283: LD_INT 7
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: PUSH
19290: LD_INT 34
19292: PUSH
19293: LD_INT 45
19295: PUSH
19296: EMPTY
19297: LIST
19298: LIST
19299: PUSH
19300: LD_INT 34
19302: PUSH
19303: LD_INT 28
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: PUSH
19310: LD_INT 34
19312: PUSH
19313: LD_INT 47
19315: PUSH
19316: EMPTY
19317: LIST
19318: LIST
19319: PUSH
19320: EMPTY
19321: LIST
19322: LIST
19323: LIST
19324: LIST
19325: LIST
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PPUSH
19331: CALL_OW 69
19335: ST_TO_ADDR
// if not tmp then
19336: LD_VAR 0 2
19340: NOT
19341: IFFALSE 19345
// exit ;
19343: GO 19371
// for i in tmp do
19345: LD_ADDR_VAR 0 1
19349: PUSH
19350: LD_VAR 0 2
19354: PUSH
19355: FOR_IN
19356: IFFALSE 19369
// begin DestroyUnit ( i ) ;
19358: LD_VAR 0 1
19362: PPUSH
19363: CALL_OW 65
// end ;
19367: GO 19355
19369: POP
19370: POP
// end ;
19371: PPOPN 2
19373: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
19374: LD_EXP 59
19378: PUSH
19379: LD_EXP 63
19383: AND
19384: IFFALSE 19465
19386: GO 19388
19388: DISABLE
19389: LD_INT 0
19391: PPUSH
19392: PPUSH
// begin enable ;
19393: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
19394: LD_ADDR_VAR 0 2
19398: PUSH
19399: LD_INT 22
19401: PUSH
19402: LD_OWVAR 2
19406: PUSH
19407: EMPTY
19408: LIST
19409: LIST
19410: PUSH
19411: LD_INT 32
19413: PUSH
19414: LD_INT 3
19416: PUSH
19417: EMPTY
19418: LIST
19419: LIST
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: PPUSH
19425: CALL_OW 69
19429: ST_TO_ADDR
// if not tmp then
19430: LD_VAR 0 2
19434: NOT
19435: IFFALSE 19439
// exit ;
19437: GO 19465
// for i in tmp do
19439: LD_ADDR_VAR 0 1
19443: PUSH
19444: LD_VAR 0 2
19448: PUSH
19449: FOR_IN
19450: IFFALSE 19463
// begin DestroyUnit ( i ) ;
19452: LD_VAR 0 1
19456: PPUSH
19457: CALL_OW 65
// end ;
19461: GO 19449
19463: POP
19464: POP
// end ;
19465: PPOPN 2
19467: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
19468: LD_EXP 59
19472: PUSH
19473: LD_EXP 60
19477: AND
19478: IFFALSE 19571
19480: GO 19482
19482: DISABLE
19483: LD_INT 0
19485: PPUSH
// begin enable ;
19486: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
19487: LD_ADDR_VAR 0 1
19491: PUSH
19492: LD_INT 22
19494: PUSH
19495: LD_OWVAR 2
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: PUSH
19504: LD_INT 2
19506: PUSH
19507: LD_INT 25
19509: PUSH
19510: LD_INT 5
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: PUSH
19517: LD_INT 25
19519: PUSH
19520: LD_INT 9
19522: PUSH
19523: EMPTY
19524: LIST
19525: LIST
19526: PUSH
19527: LD_INT 25
19529: PUSH
19530: LD_INT 8
19532: PUSH
19533: EMPTY
19534: LIST
19535: LIST
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: LIST
19541: LIST
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: PPUSH
19547: CALL_OW 69
19551: PUSH
19552: FOR_IN
19553: IFFALSE 19569
// begin SetClass ( i , 1 ) ;
19555: LD_VAR 0 1
19559: PPUSH
19560: LD_INT 1
19562: PPUSH
19563: CALL_OW 336
// end ;
19567: GO 19552
19569: POP
19570: POP
// end ;
19571: PPOPN 1
19573: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
19574: LD_EXP 59
19578: PUSH
19579: LD_EXP 61
19583: AND
19584: PUSH
19585: LD_OWVAR 65
19589: PUSH
19590: LD_INT 7
19592: LESS
19593: AND
19594: IFFALSE 19608
19596: GO 19598
19598: DISABLE
// begin enable ;
19599: ENABLE
// game_speed := 7 ;
19600: LD_ADDR_OWVAR 65
19604: PUSH
19605: LD_INT 7
19607: ST_TO_ADDR
// end ;
19608: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
19609: LD_EXP 59
19613: PUSH
19614: LD_EXP 64
19618: AND
19619: IFFALSE 19821
19621: GO 19623
19623: DISABLE
19624: LD_INT 0
19626: PPUSH
19627: PPUSH
19628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
19629: LD_ADDR_VAR 0 3
19633: PUSH
19634: LD_INT 81
19636: PUSH
19637: LD_OWVAR 2
19641: PUSH
19642: EMPTY
19643: LIST
19644: LIST
19645: PUSH
19646: LD_INT 21
19648: PUSH
19649: LD_INT 1
19651: PUSH
19652: EMPTY
19653: LIST
19654: LIST
19655: PUSH
19656: EMPTY
19657: LIST
19658: LIST
19659: PPUSH
19660: CALL_OW 69
19664: ST_TO_ADDR
// if not tmp then
19665: LD_VAR 0 3
19669: NOT
19670: IFFALSE 19674
// exit ;
19672: GO 19821
// if tmp > 5 then
19674: LD_VAR 0 3
19678: PUSH
19679: LD_INT 5
19681: GREATER
19682: IFFALSE 19694
// k := 5 else
19684: LD_ADDR_VAR 0 2
19688: PUSH
19689: LD_INT 5
19691: ST_TO_ADDR
19692: GO 19704
// k := tmp ;
19694: LD_ADDR_VAR 0 2
19698: PUSH
19699: LD_VAR 0 3
19703: ST_TO_ADDR
// for i := 1 to k do
19704: LD_ADDR_VAR 0 1
19708: PUSH
19709: DOUBLE
19710: LD_INT 1
19712: DEC
19713: ST_TO_ADDR
19714: LD_VAR 0 2
19718: PUSH
19719: FOR_TO
19720: IFFALSE 19819
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
19722: LD_VAR 0 3
19726: PUSH
19727: LD_VAR 0 1
19731: ARRAY
19732: PPUSH
19733: LD_VAR 0 1
19737: PUSH
19738: LD_INT 4
19740: MOD
19741: PUSH
19742: LD_INT 1
19744: PLUS
19745: PPUSH
19746: CALL_OW 259
19750: PUSH
19751: LD_INT 10
19753: LESS
19754: IFFALSE 19817
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
19756: LD_VAR 0 3
19760: PUSH
19761: LD_VAR 0 1
19765: ARRAY
19766: PPUSH
19767: LD_VAR 0 1
19771: PUSH
19772: LD_INT 4
19774: MOD
19775: PUSH
19776: LD_INT 1
19778: PLUS
19779: PPUSH
19780: LD_VAR 0 3
19784: PUSH
19785: LD_VAR 0 1
19789: ARRAY
19790: PPUSH
19791: LD_VAR 0 1
19795: PUSH
19796: LD_INT 4
19798: MOD
19799: PUSH
19800: LD_INT 1
19802: PLUS
19803: PPUSH
19804: CALL_OW 259
19808: PUSH
19809: LD_INT 1
19811: PLUS
19812: PPUSH
19813: CALL_OW 237
19817: GO 19719
19819: POP
19820: POP
// end ;
19821: PPOPN 3
19823: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
19824: LD_EXP 59
19828: PUSH
19829: LD_EXP 65
19833: AND
19834: IFFALSE 19854
19836: GO 19838
19838: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
19839: LD_INT 4
19841: PPUSH
19842: LD_OWVAR 2
19846: PPUSH
19847: LD_INT 0
19849: PPUSH
19850: CALL_OW 324
19854: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
19855: LD_EXP 59
19859: PUSH
19860: LD_EXP 66
19864: AND
19865: IFFALSE 19964
19867: GO 19869
19869: DISABLE
19870: LD_INT 0
19872: PPUSH
19873: PPUSH
// begin enable ;
19874: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
19875: LD_ADDR_VAR 0 2
19879: PUSH
19880: LD_INT 22
19882: PUSH
19883: LD_OWVAR 2
19887: PUSH
19888: EMPTY
19889: LIST
19890: LIST
19891: PUSH
19892: LD_INT 2
19894: PUSH
19895: LD_INT 34
19897: PUSH
19898: LD_INT 11
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PUSH
19905: LD_INT 34
19907: PUSH
19908: LD_INT 30
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: LIST
19919: PUSH
19920: EMPTY
19921: LIST
19922: LIST
19923: PPUSH
19924: CALL_OW 69
19928: ST_TO_ADDR
// if not tmp then
19929: LD_VAR 0 2
19933: NOT
19934: IFFALSE 19938
// exit ;
19936: GO 19964
// for i in tmp do
19938: LD_ADDR_VAR 0 1
19942: PUSH
19943: LD_VAR 0 2
19947: PUSH
19948: FOR_IN
19949: IFFALSE 19962
// begin DestroyUnit ( i ) ;
19951: LD_VAR 0 1
19955: PPUSH
19956: CALL_OW 65
// end ;
19960: GO 19948
19962: POP
19963: POP
// end ;
19964: PPOPN 2
19966: END
// every 0 0$1 trigger StreamModeActive and sBunker do
19967: LD_EXP 59
19971: PUSH
19972: LD_EXP 67
19976: AND
19977: IFFALSE 19997
19979: GO 19981
19981: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
19982: LD_INT 32
19984: PPUSH
19985: LD_OWVAR 2
19989: PPUSH
19990: LD_INT 0
19992: PPUSH
19993: CALL_OW 324
19997: END
// every 0 0$1 trigger StreamModeActive and sHack do
19998: LD_EXP 59
20002: PUSH
20003: LD_EXP 68
20007: AND
20008: IFFALSE 20028
20010: GO 20012
20012: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
20013: LD_INT 33
20015: PPUSH
20016: LD_OWVAR 2
20020: PPUSH
20021: LD_INT 0
20023: PPUSH
20024: CALL_OW 322
20028: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
20029: LD_EXP 59
20033: PUSH
20034: LD_EXP 69
20038: AND
20039: IFFALSE 20118
20041: GO 20043
20043: DISABLE
20044: LD_INT 0
20046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20047: LD_ADDR_VAR 0 1
20051: PUSH
20052: LD_INT 22
20054: PUSH
20055: LD_OWVAR 2
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: PUSH
20064: LD_INT 21
20066: PUSH
20067: LD_INT 3
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: PUSH
20074: EMPTY
20075: LIST
20076: LIST
20077: PPUSH
20078: CALL_OW 69
20082: ST_TO_ADDR
// if not tmp then
20083: LD_VAR 0 1
20087: NOT
20088: IFFALSE 20092
// exit ;
20090: GO 20118
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
20092: LD_VAR 0 1
20096: PUSH
20097: LD_INT 1
20099: PPUSH
20100: LD_VAR 0 1
20104: PPUSH
20105: CALL_OW 12
20109: ARRAY
20110: PPUSH
20111: LD_INT 100
20113: PPUSH
20114: CALL_OW 234
// end ;
20118: PPOPN 1
20120: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
20121: LD_EXP 59
20125: PUSH
20126: LD_EXP 71
20130: AND
20131: IFFALSE 20229
20133: GO 20135
20135: DISABLE
20136: LD_INT 0
20138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20139: LD_ADDR_VAR 0 1
20143: PUSH
20144: LD_INT 22
20146: PUSH
20147: LD_OWVAR 2
20151: PUSH
20152: EMPTY
20153: LIST
20154: LIST
20155: PUSH
20156: LD_INT 21
20158: PUSH
20159: LD_INT 1
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: PPUSH
20170: CALL_OW 69
20174: ST_TO_ADDR
// if not tmp then
20175: LD_VAR 0 1
20179: NOT
20180: IFFALSE 20184
// exit ;
20182: GO 20229
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
20184: LD_VAR 0 1
20188: PUSH
20189: LD_INT 1
20191: PPUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 12
20201: ARRAY
20202: PPUSH
20203: LD_INT 1
20205: PPUSH
20206: LD_INT 4
20208: PPUSH
20209: CALL_OW 12
20213: PPUSH
20214: LD_INT 3000
20216: PPUSH
20217: LD_INT 9000
20219: PPUSH
20220: CALL_OW 12
20224: PPUSH
20225: CALL_OW 492
// end ;
20229: PPOPN 1
20231: END
// every 0 0$1 trigger StreamModeActive and sDepot do
20232: LD_EXP 59
20236: PUSH
20237: LD_EXP 72
20241: AND
20242: IFFALSE 20262
20244: GO 20246
20246: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
20247: LD_INT 1
20249: PPUSH
20250: LD_OWVAR 2
20254: PPUSH
20255: LD_INT 0
20257: PPUSH
20258: CALL_OW 324
20262: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
20263: LD_EXP 59
20267: PUSH
20268: LD_EXP 73
20272: AND
20273: IFFALSE 20356
20275: GO 20277
20277: DISABLE
20278: LD_INT 0
20280: PPUSH
20281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20282: LD_ADDR_VAR 0 2
20286: PUSH
20287: LD_INT 22
20289: PUSH
20290: LD_OWVAR 2
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: PUSH
20299: LD_INT 21
20301: PUSH
20302: LD_INT 3
20304: PUSH
20305: EMPTY
20306: LIST
20307: LIST
20308: PUSH
20309: EMPTY
20310: LIST
20311: LIST
20312: PPUSH
20313: CALL_OW 69
20317: ST_TO_ADDR
// if not tmp then
20318: LD_VAR 0 2
20322: NOT
20323: IFFALSE 20327
// exit ;
20325: GO 20356
// for i in tmp do
20327: LD_ADDR_VAR 0 1
20331: PUSH
20332: LD_VAR 0 2
20336: PUSH
20337: FOR_IN
20338: IFFALSE 20354
// SetBLevel ( i , 10 ) ;
20340: LD_VAR 0 1
20344: PPUSH
20345: LD_INT 10
20347: PPUSH
20348: CALL_OW 241
20352: GO 20337
20354: POP
20355: POP
// end ;
20356: PPOPN 2
20358: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
20359: LD_EXP 59
20363: PUSH
20364: LD_EXP 74
20368: AND
20369: IFFALSE 20452
20371: GO 20373
20373: DISABLE
20374: LD_INT 0
20376: PPUSH
20377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20378: LD_ADDR_VAR 0 2
20382: PUSH
20383: LD_INT 22
20385: PUSH
20386: LD_OWVAR 2
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: PUSH
20395: LD_INT 25
20397: PUSH
20398: LD_INT 1
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PPUSH
20409: CALL_OW 69
20413: ST_TO_ADDR
// if not tmp then
20414: LD_VAR 0 2
20418: NOT
20419: IFFALSE 20423
// exit ;
20421: GO 20452
// for i in tmp do
20423: LD_ADDR_VAR 0 1
20427: PUSH
20428: LD_VAR 0 2
20432: PUSH
20433: FOR_IN
20434: IFFALSE 20450
// SetClass ( i , 4 ) ;
20436: LD_VAR 0 1
20440: PPUSH
20441: LD_INT 4
20443: PPUSH
20444: CALL_OW 336
20448: GO 20433
20450: POP
20451: POP
// end ;
20452: PPOPN 2
20454: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
20455: LD_EXP 59
20459: PUSH
20460: LD_EXP 75
20464: AND
20465: PUSH
20466: LD_OWVAR 67
20470: PUSH
20471: LD_INT 3
20473: LESS
20474: AND
20475: IFFALSE 20494
20477: GO 20479
20479: DISABLE
// Difficulty := Difficulty + 1 ;
20480: LD_ADDR_OWVAR 67
20484: PUSH
20485: LD_OWVAR 67
20489: PUSH
20490: LD_INT 1
20492: PLUS
20493: ST_TO_ADDR
20494: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
20495: LD_EXP 59
20499: PUSH
20500: LD_EXP 76
20504: AND
20505: IFFALSE 20608
20507: GO 20509
20509: DISABLE
20510: LD_INT 0
20512: PPUSH
// begin for i := 1 to 5 do
20513: LD_ADDR_VAR 0 1
20517: PUSH
20518: DOUBLE
20519: LD_INT 1
20521: DEC
20522: ST_TO_ADDR
20523: LD_INT 5
20525: PUSH
20526: FOR_TO
20527: IFFALSE 20606
// begin uc_nation := nation_nature ;
20529: LD_ADDR_OWVAR 21
20533: PUSH
20534: LD_INT 0
20536: ST_TO_ADDR
// uc_side := 0 ;
20537: LD_ADDR_OWVAR 20
20541: PUSH
20542: LD_INT 0
20544: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
20545: LD_ADDR_OWVAR 29
20549: PUSH
20550: LD_INT 12
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: ST_TO_ADDR
// hc_agressivity := 20 ;
20560: LD_ADDR_OWVAR 35
20564: PUSH
20565: LD_INT 20
20567: ST_TO_ADDR
// hc_class := class_tiger ;
20568: LD_ADDR_OWVAR 28
20572: PUSH
20573: LD_INT 14
20575: ST_TO_ADDR
// hc_gallery :=  ;
20576: LD_ADDR_OWVAR 33
20580: PUSH
20581: LD_STRING 
20583: ST_TO_ADDR
// hc_name :=  ;
20584: LD_ADDR_OWVAR 26
20588: PUSH
20589: LD_STRING 
20591: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
20592: CALL_OW 44
20596: PPUSH
20597: LD_INT 0
20599: PPUSH
20600: CALL_OW 51
// end ;
20604: GO 20526
20606: POP
20607: POP
// end ;
20608: PPOPN 1
20610: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
20611: LD_EXP 59
20615: PUSH
20616: LD_EXP 77
20620: AND
20621: IFFALSE 20795
20623: GO 20625
20625: DISABLE
20626: LD_INT 0
20628: PPUSH
20629: PPUSH
20630: PPUSH
20631: PPUSH
// begin result := false ;
20632: LD_ADDR_VAR 0 4
20636: PUSH
20637: LD_INT 0
20639: ST_TO_ADDR
// for i := 1 to 8 do
20640: LD_ADDR_VAR 0 1
20644: PUSH
20645: DOUBLE
20646: LD_INT 1
20648: DEC
20649: ST_TO_ADDR
20650: LD_INT 8
20652: PUSH
20653: FOR_TO
20654: IFFALSE 20765
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
20656: LD_ADDR_VAR 0 2
20660: PUSH
20661: LD_INT 10
20663: PUSH
20664: LD_INT 50
20666: PUSH
20667: LD_INT 90
20669: PUSH
20670: LD_INT 140
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_INT 4
20684: PPUSH
20685: CALL_OW 12
20689: ARRAY
20690: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
20691: LD_ADDR_VAR 0 3
20695: PUSH
20696: LD_INT 10
20698: PUSH
20699: LD_INT 50
20701: PUSH
20702: LD_INT 90
20704: PUSH
20705: LD_INT 140
20707: PUSH
20708: EMPTY
20709: LIST
20710: LIST
20711: LIST
20712: LIST
20713: PUSH
20714: LD_INT 1
20716: PPUSH
20717: LD_INT 4
20719: PPUSH
20720: CALL_OW 12
20724: ARRAY
20725: ST_TO_ADDR
// if ValidHex ( x , y ) then
20726: LD_VAR 0 2
20730: PPUSH
20731: LD_VAR 0 3
20735: PPUSH
20736: CALL_OW 488
20740: IFFALSE 20763
// begin result := [ x , y ] ;
20742: LD_ADDR_VAR 0 4
20746: PUSH
20747: LD_VAR 0 2
20751: PUSH
20752: LD_VAR 0 3
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: ST_TO_ADDR
// break ;
20761: GO 20765
// end ; end ;
20763: GO 20653
20765: POP
20766: POP
// if result then
20767: LD_VAR 0 4
20771: IFFALSE 20795
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
20773: LD_VAR 0 4
20777: PUSH
20778: LD_INT 1
20780: ARRAY
20781: PPUSH
20782: LD_VAR 0 4
20786: PUSH
20787: LD_INT 2
20789: ARRAY
20790: PPUSH
20791: CALL_OW 429
// end ;
20795: PPOPN 4
20797: END
// every 0 0$1 trigger StreamModeActive and sReset do
20798: LD_EXP 59
20802: PUSH
20803: LD_EXP 79
20807: AND
20808: IFFALSE 20820
20810: GO 20812
20812: DISABLE
// YouLost (  ) ;
20813: LD_STRING 
20815: PPUSH
20816: CALL_OW 104
20820: END
// every 0 0$1 trigger StreamModeActive and sFog do
20821: LD_EXP 59
20825: PUSH
20826: LD_EXP 78
20830: AND
20831: IFFALSE 20845
20833: GO 20835
20835: DISABLE
// FogOff ( your_side ) ;
20836: LD_OWVAR 2
20840: PPUSH
20841: CALL_OW 344
20845: END
// every 0 0$1 trigger StreamModeActive and sSun do
20846: LD_EXP 59
20850: PUSH
20851: LD_EXP 80
20855: AND
20856: IFFALSE 20884
20858: GO 20860
20860: DISABLE
// begin solar_recharge_percent := 0 ;
20861: LD_ADDR_OWVAR 79
20865: PUSH
20866: LD_INT 0
20868: ST_TO_ADDR
// wait ( 5 5$00 ) ;
20869: LD_INT 10500
20871: PPUSH
20872: CALL_OW 67
// solar_recharge_percent := 100 ;
20876: LD_ADDR_OWVAR 79
20880: PUSH
20881: LD_INT 100
20883: ST_TO_ADDR
// end ; end_of_file
20884: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
20885: LD_INT 0
20887: PPUSH
20888: PPUSH
20889: PPUSH
20890: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
20891: LD_VAR 0 1
20895: PPUSH
20896: CALL_OW 264
20900: PUSH
20901: LD_EXP 58
20905: EQUAL
20906: IFFALSE 20978
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
20908: LD_INT 68
20910: PPUSH
20911: LD_VAR 0 1
20915: PPUSH
20916: CALL_OW 255
20920: PPUSH
20921: CALL_OW 321
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20941
// eff := 70 else
20931: LD_ADDR_VAR 0 6
20935: PUSH
20936: LD_INT 70
20938: ST_TO_ADDR
20939: GO 20949
// eff := 30 ;
20941: LD_ADDR_VAR 0 6
20945: PUSH
20946: LD_INT 30
20948: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
20949: LD_VAR 0 1
20953: PPUSH
20954: CALL_OW 250
20958: PPUSH
20959: LD_VAR 0 1
20963: PPUSH
20964: CALL_OW 251
20968: PPUSH
20969: LD_VAR 0 6
20973: PPUSH
20974: CALL_OW 495
// end ; end ;
20978: LD_VAR 0 4
20982: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
20983: LD_INT 0
20985: PPUSH
20986: PPUSH
20987: PPUSH
20988: PPUSH
20989: PPUSH
20990: PPUSH
// if cmd = 124 then
20991: LD_VAR 0 1
20995: PUSH
20996: LD_INT 124
20998: EQUAL
20999: IFFALSE 21205
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
21001: LD_ADDR_VAR 0 5
21005: PUSH
21006: LD_INT 2
21008: PUSH
21009: LD_INT 34
21011: PUSH
21012: LD_INT 53
21014: PUSH
21015: EMPTY
21016: LIST
21017: LIST
21018: PUSH
21019: LD_INT 34
21021: PUSH
21022: LD_INT 14
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: PUSH
21029: EMPTY
21030: LIST
21031: LIST
21032: LIST
21033: PPUSH
21034: CALL_OW 69
21038: ST_TO_ADDR
// if not tmp then
21039: LD_VAR 0 5
21043: NOT
21044: IFFALSE 21048
// exit ;
21046: GO 21205
// for i in tmp do
21048: LD_ADDR_VAR 0 3
21052: PUSH
21053: LD_VAR 0 5
21057: PUSH
21058: FOR_IN
21059: IFFALSE 21203
// begin taskList := GetTaskList ( i ) ;
21061: LD_ADDR_VAR 0 6
21065: PUSH
21066: LD_VAR 0 3
21070: PPUSH
21071: CALL_OW 437
21075: ST_TO_ADDR
// if not taskList then
21076: LD_VAR 0 6
21080: NOT
21081: IFFALSE 21085
// continue ;
21083: GO 21058
// for j = 1 to taskList do
21085: LD_ADDR_VAR 0 4
21089: PUSH
21090: DOUBLE
21091: LD_INT 1
21093: DEC
21094: ST_TO_ADDR
21095: LD_VAR 0 6
21099: PUSH
21100: FOR_TO
21101: IFFALSE 21199
// if taskList [ j ] [ 1 ] = | then
21103: LD_VAR 0 6
21107: PUSH
21108: LD_VAR 0 4
21112: ARRAY
21113: PUSH
21114: LD_INT 1
21116: ARRAY
21117: PUSH
21118: LD_STRING |
21120: EQUAL
21121: IFFALSE 21197
// begin _taskList := Delete ( taskList , 1 ) ;
21123: LD_ADDR_VAR 0 7
21127: PUSH
21128: LD_VAR 0 6
21132: PPUSH
21133: LD_INT 1
21135: PPUSH
21136: CALL_OW 3
21140: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
21141: LD_VAR 0 3
21145: PPUSH
21146: LD_VAR 0 7
21150: PPUSH
21151: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
21155: LD_VAR 0 3
21159: PPUSH
21160: LD_VAR 0 6
21164: PUSH
21165: LD_VAR 0 4
21169: ARRAY
21170: PUSH
21171: LD_INT 2
21173: ARRAY
21174: PPUSH
21175: LD_VAR 0 6
21179: PUSH
21180: LD_VAR 0 4
21184: ARRAY
21185: PUSH
21186: LD_INT 3
21188: ARRAY
21189: PPUSH
21190: LD_INT 8
21192: PPUSH
21193: CALL 21210 0 4
// end ;
21197: GO 21100
21199: POP
21200: POP
// end ;
21201: GO 21058
21203: POP
21204: POP
// end ; end ;
21205: LD_VAR 0 2
21209: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
21210: LD_INT 0
21212: PPUSH
21213: PPUSH
21214: PPUSH
21215: PPUSH
21216: PPUSH
21217: PPUSH
21218: PPUSH
21219: PPUSH
21220: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
21221: LD_VAR 0 1
21225: NOT
21226: PUSH
21227: LD_VAR 0 2
21231: PPUSH
21232: LD_VAR 0 3
21236: PPUSH
21237: CALL_OW 488
21241: NOT
21242: OR
21243: PUSH
21244: LD_VAR 0 4
21248: NOT
21249: OR
21250: IFFALSE 21254
// exit ;
21252: GO 21594
// list := [ ] ;
21254: LD_ADDR_VAR 0 13
21258: PUSH
21259: EMPTY
21260: ST_TO_ADDR
// if x - r < 0 then
21261: LD_VAR 0 2
21265: PUSH
21266: LD_VAR 0 4
21270: MINUS
21271: PUSH
21272: LD_INT 0
21274: LESS
21275: IFFALSE 21287
// min_x := 0 else
21277: LD_ADDR_VAR 0 7
21281: PUSH
21282: LD_INT 0
21284: ST_TO_ADDR
21285: GO 21303
// min_x := x - r ;
21287: LD_ADDR_VAR 0 7
21291: PUSH
21292: LD_VAR 0 2
21296: PUSH
21297: LD_VAR 0 4
21301: MINUS
21302: ST_TO_ADDR
// if y - r < 0 then
21303: LD_VAR 0 3
21307: PUSH
21308: LD_VAR 0 4
21312: MINUS
21313: PUSH
21314: LD_INT 0
21316: LESS
21317: IFFALSE 21329
// min_y := 0 else
21319: LD_ADDR_VAR 0 8
21323: PUSH
21324: LD_INT 0
21326: ST_TO_ADDR
21327: GO 21345
// min_y := y - r ;
21329: LD_ADDR_VAR 0 8
21333: PUSH
21334: LD_VAR 0 3
21338: PUSH
21339: LD_VAR 0 4
21343: MINUS
21344: ST_TO_ADDR
// max_x := x + r ;
21345: LD_ADDR_VAR 0 9
21349: PUSH
21350: LD_VAR 0 2
21354: PUSH
21355: LD_VAR 0 4
21359: PLUS
21360: ST_TO_ADDR
// max_y := y + r ;
21361: LD_ADDR_VAR 0 10
21365: PUSH
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 4
21375: PLUS
21376: ST_TO_ADDR
// for _x = min_x to max_x do
21377: LD_ADDR_VAR 0 11
21381: PUSH
21382: DOUBLE
21383: LD_VAR 0 7
21387: DEC
21388: ST_TO_ADDR
21389: LD_VAR 0 9
21393: PUSH
21394: FOR_TO
21395: IFFALSE 21512
// for _y = min_y to max_y do
21397: LD_ADDR_VAR 0 12
21401: PUSH
21402: DOUBLE
21403: LD_VAR 0 8
21407: DEC
21408: ST_TO_ADDR
21409: LD_VAR 0 10
21413: PUSH
21414: FOR_TO
21415: IFFALSE 21508
// begin if not ValidHex ( _x , _y ) then
21417: LD_VAR 0 11
21421: PPUSH
21422: LD_VAR 0 12
21426: PPUSH
21427: CALL_OW 488
21431: NOT
21432: IFFALSE 21436
// continue ;
21434: GO 21414
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
21436: LD_VAR 0 11
21440: PPUSH
21441: LD_VAR 0 12
21445: PPUSH
21446: CALL_OW 351
21450: PUSH
21451: LD_VAR 0 11
21455: PPUSH
21456: LD_VAR 0 12
21460: PPUSH
21461: CALL_OW 554
21465: AND
21466: IFFALSE 21506
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
21468: LD_ADDR_VAR 0 13
21472: PUSH
21473: LD_VAR 0 13
21477: PPUSH
21478: LD_VAR 0 13
21482: PUSH
21483: LD_INT 1
21485: PLUS
21486: PPUSH
21487: LD_VAR 0 11
21491: PUSH
21492: LD_VAR 0 12
21496: PUSH
21497: EMPTY
21498: LIST
21499: LIST
21500: PPUSH
21501: CALL_OW 2
21505: ST_TO_ADDR
// end ;
21506: GO 21414
21508: POP
21509: POP
21510: GO 21394
21512: POP
21513: POP
// if not list then
21514: LD_VAR 0 13
21518: NOT
21519: IFFALSE 21523
// exit ;
21521: GO 21594
// for i in list do
21523: LD_ADDR_VAR 0 6
21527: PUSH
21528: LD_VAR 0 13
21532: PUSH
21533: FOR_IN
21534: IFFALSE 21592
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_STRING M
21543: PUSH
21544: LD_VAR 0 6
21548: PUSH
21549: LD_INT 1
21551: ARRAY
21552: PUSH
21553: LD_VAR 0 6
21557: PUSH
21558: LD_INT 2
21560: ARRAY
21561: PUSH
21562: LD_INT 0
21564: PUSH
21565: LD_INT 0
21567: PUSH
21568: LD_INT 0
21570: PUSH
21571: LD_INT 0
21573: PUSH
21574: EMPTY
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: PUSH
21583: EMPTY
21584: LIST
21585: PPUSH
21586: CALL_OW 447
21590: GO 21533
21592: POP
21593: POP
// end ;
21594: LD_VAR 0 5
21598: RET
