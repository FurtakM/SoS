// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3523 0 0
// PrepareLegion ;
  27: CALL 7054 0 0
// Action ;
  31: CALL 10733 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16048 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ;
3486: PPOPN 1
3488: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3489: LD_VAR 0 1
3493: PPUSH
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_VAR 0 3
3503: PPUSH
3504: CALL 29363 0 3
// end ;
3508: PPOPN 3
3510: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: CALL 29461 0 1
// end ; end_of_file
3520: PPOPN 1
3522: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3523: LD_INT 0
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
3529: PPUSH
3530: PPUSH
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
// uc_side := 3 ;
3536: LD_ADDR_OWVAR 20
3540: PUSH
3541: LD_INT 3
3543: ST_TO_ADDR
// uc_nation := nation_russian ;
3544: LD_ADDR_OWVAR 21
3548: PUSH
3549: LD_INT 3
3551: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3552: LD_ADDR_VAR 0 4
3556: PUSH
3557: LD_INT 22
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 30
3569: PUSH
3570: LD_INT 1
3572: PUSH
3573: EMPTY
3574: LIST
3575: LIST
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PPUSH
3581: CALL_OW 69
3585: PUSH
3586: LD_INT 1
3588: ARRAY
3589: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3590: LD_ADDR_VAR 0 5
3594: PUSH
3595: LD_INT 22
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 30
3607: PUSH
3608: LD_INT 3
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PPUSH
3619: CALL_OW 69
3623: PUSH
3624: LD_INT 1
3626: ARRAY
3627: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_INT 22
3635: PUSH
3636: LD_INT 3
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 30
3645: PUSH
3646: LD_INT 34
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 69
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3666: LD_ADDR_VAR 0 8
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 33
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3700: LD_ADDR_VAR 0 7
3704: PUSH
3705: LD_INT 22
3707: PUSH
3708: LD_INT 3
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 30
3717: PUSH
3718: LD_INT 5
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PPUSH
3729: CALL_OW 69
3733: PUSH
3734: LD_INT 1
3736: ARRAY
3737: ST_TO_ADDR
// ru_blist := [ ] ;
3738: LD_ADDR_EXP 26
3742: PUSH
3743: EMPTY
3744: ST_TO_ADDR
// ru_vlist := [ ] ;
3745: LD_ADDR_EXP 27
3749: PUSH
3750: EMPTY
3751: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3752: LD_ADDR_EXP 30
3756: PUSH
3757: LD_INT 183
3759: PUSH
3760: LD_INT 62
3762: PUSH
3763: LD_INT 147
3765: PUSH
3766: LD_INT 44
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3775: LD_INT 30
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PPUSH
3785: CALL_OW 69
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_EXP 30
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 2
3810: ARRAY
3811: PPUSH
3812: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3816: LD_ADDR_EXP 28
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: LD_INT 5
3826: PUSH
3827: LD_INT 6
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: LIST
3834: PUSH
3835: LD_OWVAR 67
3839: ARRAY
3840: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3841: LD_VAR 0 4
3845: PPUSH
3846: CALL_OW 274
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 3000
3856: PPUSH
3857: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3861: LD_VAR 0 4
3865: PPUSH
3866: CALL_OW 274
3870: PPUSH
3871: LD_INT 2
3873: PPUSH
3874: LD_INT 300
3876: PPUSH
3877: CALL_OW 277
// hc_gallery :=  ;
3881: LD_ADDR_OWVAR 33
3885: PUSH
3886: LD_STRING 
3888: ST_TO_ADDR
// hc_name :=  ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING 
3896: ST_TO_ADDR
// hc_importance := 0 ;
3897: LD_ADDR_OWVAR 32
3901: PUSH
3902: LD_INT 0
3904: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3905: LD_ADDR_EXP 24
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: LD_INT 6
3915: PUSH
3916: LD_INT 7
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: ST_TO_ADDR
// for i = 1 to 6 do
3930: LD_ADDR_VAR 0 2
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 6
3942: PUSH
3943: FOR_TO
3944: IFFALSE 4102
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3946: LD_INT 0
3948: PPUSH
3949: LD_INT 9
3951: PPUSH
3952: LD_EXP 24
3956: PPUSH
3957: CALL_OW 380
// un := CreateHuman ;
3961: LD_ADDR_VAR 0 3
3965: PUSH
3966: CALL_OW 44
3970: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_VAR 0 7
3980: PPUSH
3981: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 4
3990: PPUSH
3991: LD_EXP 24
3995: PPUSH
3996: CALL_OW 380
// un := CreateHuman ;
4000: LD_ADDR_VAR 0 3
4004: PUSH
4005: CALL_OW 44
4009: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4010: LD_VAR 0 3
4014: PPUSH
4015: LD_INT 24
4017: PPUSH
4018: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4022: LD_INT 0
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_EXP 24
4032: PPUSH
4033: CALL_OW 380
// un := CreateHuman ;
4037: LD_ADDR_VAR 0 3
4041: PUSH
4042: CALL_OW 44
4046: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_VAR 0 5
4056: PPUSH
4057: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4061: LD_INT 0
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: LD_EXP 24
4071: PPUSH
4072: CALL_OW 380
// un := CreateHuman ;
4076: LD_ADDR_VAR 0 3
4080: PUSH
4081: CALL_OW 44
4085: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_VAR 0 4
4095: PPUSH
4096: CALL_OW 52
// end ;
4100: GO 3943
4102: POP
4103: POP
// russian_prepared := true ;
4104: LD_ADDR_EXP 2
4108: PUSH
4109: LD_INT 1
4111: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_INT 21
4119: PPUSH
4120: LD_INT 3
4122: PPUSH
4123: LD_INT 3
4125: PPUSH
4126: LD_INT 51
4128: PPUSH
4129: CALL_OW 125
// end ;
4133: LD_VAR 0 1
4137: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4138: LD_INT 22
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 69
4152: PUSH
4153: LD_INT 0
4155: GREATER
4156: PUSH
4157: LD_EXP 2
4161: AND
4162: IFFALSE 6625
4164: GO 4166
4166: DISABLE
4167: LD_INT 0
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
4173: PPUSH
4174: PPUSH
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
// begin enable ;
4186: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4187: LD_ADDR_VAR 0 1
4191: PUSH
4192: LD_INT 22
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 30
4204: PUSH
4205: LD_INT 1
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PPUSH
4216: CALL_OW 69
4220: PUSH
4221: LD_INT 1
4223: ARRAY
4224: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: LD_INT 22
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 30
4242: PUSH
4243: LD_INT 3
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: PUSH
4259: LD_INT 1
4261: ARRAY
4262: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4263: LD_ADDR_VAR 0 3
4267: PUSH
4268: LD_INT 22
4270: PUSH
4271: LD_INT 3
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PUSH
4278: LD_INT 30
4280: PUSH
4281: LD_INT 34
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PPUSH
4292: CALL_OW 69
4296: PUSH
4297: LD_INT 1
4299: ARRAY
4300: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4301: LD_ADDR_VAR 0 4
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4335: LD_ADDR_VAR 0 8
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 3
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 30
4352: PUSH
4353: LD_INT 5
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PPUSH
4364: CALL_OW 69
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4373: LD_ADDR_VAR 0 5
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4407: LD_ADDR_VAR 0 6
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4441: LD_ADDR_VAR 0 7
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 1
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4475: LD_ADDR_VAR 0 9
4479: PUSH
4480: LD_VAR 0 7
4484: PPUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PPUSH
4495: CALL_OW 72
4499: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4500: LD_ADDR_VAR 0 10
4504: PUSH
4505: LD_VAR 0 7
4509: PPUSH
4510: LD_INT 25
4512: PUSH
4513: LD_INT 3
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 72
4524: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4525: LD_ADDR_VAR 0 11
4529: PUSH
4530: LD_VAR 0 7
4534: PPUSH
4535: LD_INT 25
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PPUSH
4545: CALL_OW 72
4549: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4550: LD_INT 22
4552: PUSH
4553: LD_INT 3
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 34
4562: PUSH
4563: LD_INT 51
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: CALL_OW 69
4578: PUSH
4579: LD_INT 0
4581: GREATER
4582: PUSH
4583: LD_EXP 25
4587: PUSH
4588: LD_INT 0
4590: EQUAL
4591: AND
4592: IFFALSE 4632
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4594: LD_ADDR_EXP 25
4598: PUSH
4599: LD_INT 22
4601: PUSH
4602: LD_INT 3
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 34
4611: PUSH
4612: LD_INT 51
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 69
4627: PUSH
4628: LD_INT 1
4630: ARRAY
4631: ST_TO_ADDR
// if ru_cargo then
4632: LD_EXP 25
4636: IFFALSE 4934
// begin if IsInArea ( ru_cargo , ru_base ) then
4638: LD_EXP 25
4642: PPUSH
4643: LD_INT 9
4645: PPUSH
4646: CALL_OW 308
4650: IFFALSE 4729
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4652: LD_EXP 25
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: EQUAL
4668: IFFALSE 4686
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4670: LD_EXP 25
4674: PPUSH
4675: LD_VAR 0 3
4679: PPUSH
4680: CALL_OW 120
4684: GO 4727
// if not HasTask ( ru_cargo ) then
4686: LD_EXP 25
4690: PPUSH
4691: CALL_OW 314
4695: NOT
4696: IFFALSE 4727
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4698: LD_EXP 25
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 250
4712: PPUSH
4713: LD_VAR 0 1
4717: PPUSH
4718: CALL_OW 251
4722: PPUSH
4723: CALL_OW 111
// end else
4727: GO 4934
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4729: LD_EXP 25
4733: PPUSH
4734: CALL_OW 314
4738: NOT
4739: PUSH
4740: LD_EXP 25
4744: PPUSH
4745: LD_INT 1
4747: PPUSH
4748: CALL_OW 289
4752: PUSH
4753: LD_INT 100
4755: LESS
4756: AND
4757: IFFALSE 4823
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4759: LD_ADDR_VAR 0 16
4763: PUSH
4764: LD_INT 11
4766: PPUSH
4767: CALL_OW 435
4771: ST_TO_ADDR
// if cr > 0 then
4772: LD_VAR 0 16
4776: PUSH
4777: LD_INT 0
4779: GREATER
4780: IFFALSE 4811
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4782: LD_EXP 25
4786: PPUSH
4787: LD_VAR 0 16
4791: PUSH
4792: LD_INT 1
4794: ARRAY
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 2
4803: ARRAY
4804: PPUSH
4805: CALL_OW 117
4809: GO 4823
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4811: LD_EXP 25
4815: PPUSH
4816: LD_INT 11
4818: PPUSH
4819: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4823: LD_EXP 25
4827: PPUSH
4828: CALL_OW 314
4832: NOT
4833: PUSH
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 308
4846: NOT
4847: AND
4848: PUSH
4849: LD_EXP 25
4853: PPUSH
4854: LD_INT 1
4856: PPUSH
4857: CALL_OW 289
4861: PUSH
4862: LD_INT 100
4864: EQUAL
4865: AND
4866: IFFALSE 4880
// ComMoveToArea ( ru_cargo , cargoa ) ;
4868: LD_EXP 25
4872: PPUSH
4873: LD_INT 10
4875: PPUSH
4876: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4880: LD_EXP 25
4884: PPUSH
4885: LD_INT 10
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_VAR 0 8
4897: AND
4898: IFFALSE 4934
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4900: LD_VAR 0 7
4904: PPUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 9
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 72
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 139
4926: PPUSH
4927: LD_INT 24
4929: PPUSH
4930: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4934: LD_EXP 25
4938: PUSH
4939: LD_INT 0
4941: EQUAL
4942: PUSH
4943: LD_VAR 0 2
4947: AND
4948: PUSH
4949: LD_VAR 0 2
4953: PPUSH
4954: CALL_OW 461
4958: PUSH
4959: LD_INT 2
4961: EQUAL
4962: AND
4963: IFFALSE 4986
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4965: LD_VAR 0 2
4969: PPUSH
4970: LD_INT 21
4972: PPUSH
4973: LD_INT 3
4975: PPUSH
4976: LD_INT 3
4978: PPUSH
4979: LD_INT 51
4981: PPUSH
4982: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4986: LD_VAR 0 7
4990: PPUSH
4991: LD_INT 25
4993: PUSH
4994: LD_INT 9
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 72
5005: IFFALSE 5069
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5007: LD_VAR 0 7
5011: PPUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 9
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PPUSH
5022: CALL_OW 72
5026: PPUSH
5027: LD_INT 22
5029: PUSH
5030: LD_OWVAR 2
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 3
5041: PUSH
5042: LD_INT 21
5044: PUSH
5045: LD_INT 3
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PPUSH
5065: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5069: LD_VAR 0 2
5073: PUSH
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 0
5081: GREATER
5082: AND
5083: IFFALSE 5183
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5085: LD_VAR 0 2
5089: PPUSH
5090: CALL_OW 461
5094: PUSH
5095: LD_INT 2
5097: EQUAL
5098: IFFALSE 5183
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5100: LD_VAR 0 2
5104: PPUSH
5105: LD_EXP 27
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 2
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 3
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 4
5139: ARRAY
5140: PPUSH
5141: CALL_OW 125
// for i = 1 to 4 do
5145: LD_ADDR_VAR 0 12
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 4
5157: PUSH
5158: FOR_TO
5159: IFFALSE 5181
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5161: LD_ADDR_EXP 27
5165: PUSH
5166: LD_EXP 27
5170: PPUSH
5171: LD_INT 1
5173: PPUSH
5174: CALL_OW 3
5178: ST_TO_ADDR
5179: GO 5158
5181: POP
5182: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5183: LD_INT 24
5185: PPUSH
5186: CALL_OW 461
5190: PUSH
5191: LD_INT 2
5193: EQUAL
5194: PUSH
5195: LD_EXP 4
5199: AND
5200: IFFALSE 5228
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5202: LD_INT 25
5204: PPUSH
5205: LD_INT 3
5207: PPUSH
5208: CALL_OW 321
5212: PUSH
5213: LD_INT 1
5215: EQUAL
5216: IFFALSE 5228
// ComResearch ( ru_lab , tech_sibfiss ) ;
5218: LD_INT 24
5220: PPUSH
5221: LD_INT 25
5223: PPUSH
5224: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5228: LD_INT 25
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: CALL_OW 321
5238: PUSH
5239: LD_INT 2
5241: EQUAL
5242: PUSH
5243: LD_OWVAR 1
5247: PUSH
5248: LD_INT 10500
5250: MOD
5251: PUSH
5252: LD_INT 0
5254: EQUAL
5255: AND
5256: IFFALSE 5294
// if BuildingStatus ( ru_factory ) = bs_idle then
5258: LD_VAR 0 2
5262: PPUSH
5263: CALL_OW 461
5267: PUSH
5268: LD_INT 2
5270: EQUAL
5271: IFFALSE 5294
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5273: LD_VAR 0 2
5277: PPUSH
5278: LD_INT 23
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: LD_INT 3
5286: PPUSH
5287: LD_INT 48
5289: PPUSH
5290: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5294: LD_INT 22
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_INT 48
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: PPUSH
5318: CALL_OW 69
5322: PUSH
5323: LD_INT 0
5325: GREATER
5326: IFFALSE 5700
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5328: LD_ADDR_VAR 0 17
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 3
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 34
5345: PUSH
5346: LD_INT 48
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL_OW 69
5361: PUSH
5362: LD_INT 1
5364: ARRAY
5365: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5366: LD_VAR 0 17
5370: PPUSH
5371: LD_INT 9
5373: PPUSH
5374: CALL_OW 308
5378: IFFALSE 5396
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5380: LD_VAR 0 17
5384: PPUSH
5385: LD_VAR 0 3
5389: PPUSH
5390: CALL_OW 120
5394: GO 5700
// if not HasTask ( sib_bomb ) then
5396: LD_VAR 0 17
5400: PPUSH
5401: CALL_OW 314
5405: NOT
5406: IFFALSE 5700
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5408: LD_INT 22
5410: PUSH
5411: LD_OWVAR 2
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: PUSH
5420: LD_INT 30
5422: PUSH
5423: LD_INT 1
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PPUSH
5434: CALL_OW 69
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_INT 250
5450: GREATER
5451: IFFALSE 5544
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5453: LD_VAR 0 17
5457: PPUSH
5458: LD_INT 22
5460: PUSH
5461: LD_OWVAR 2
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 30
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 69
5488: PUSH
5489: LD_INT 1
5491: ARRAY
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 22
5500: PUSH
5501: LD_OWVAR 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 30
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 69
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: CALL_OW 251
5537: PPUSH
5538: CALL_OW 116
5542: GO 5700
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5544: LD_INT 22
5546: PUSH
5547: LD_OWVAR 2
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 21
5558: PUSH
5559: LD_INT 3
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 69
5574: PUSH
5575: LD_INT 0
5577: GREATER
5578: IFFALSE 5671
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5580: LD_VAR 0 17
5584: PPUSH
5585: LD_INT 22
5587: PUSH
5588: LD_OWVAR 2
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: LD_INT 21
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_INT 1
5618: ARRAY
5619: PPUSH
5620: CALL_OW 250
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_OWVAR 2
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 21
5639: PUSH
5640: LD_INT 3
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: PUSH
5656: LD_INT 1
5658: ARRAY
5659: PPUSH
5660: CALL_OW 251
5664: PPUSH
5665: CALL_OW 116
5669: GO 5700
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5671: LD_VAR 0 17
5675: PPUSH
5676: LD_EXP 10
5680: PPUSH
5681: CALL_OW 250
5685: PPUSH
5686: LD_EXP 10
5690: PPUSH
5691: CALL_OW 251
5695: PPUSH
5696: CALL_OW 116
// end ; if ru_can_attack then
5700: LD_EXP 3
5704: IFFALSE 5852
// if ru_time > 0 0$00 then
5706: LD_EXP 29
5710: PUSH
5711: LD_INT 0
5713: GREATER
5714: IFFALSE 5732
// ru_time := ru_time - 0 0$01 else
5716: LD_ADDR_EXP 29
5720: PUSH
5721: LD_EXP 29
5725: PUSH
5726: LD_INT 35
5728: MINUS
5729: ST_TO_ADDR
5730: GO 5852
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5732: LD_ADDR_EXP 29
5736: PUSH
5737: LD_INT 20265
5739: PPUSH
5740: LD_INT 30765
5742: PPUSH
5743: CALL_OW 12
5747: ST_TO_ADDR
// for i = 1 to ru_amount do
5748: LD_ADDR_VAR 0 12
5752: PUSH
5753: DOUBLE
5754: LD_INT 1
5756: DEC
5757: ST_TO_ADDR
5758: LD_EXP 28
5762: PUSH
5763: FOR_TO
5764: IFFALSE 5850
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5766: LD_ADDR_EXP 27
5770: PUSH
5771: LD_EXP 27
5775: PUSH
5776: LD_INT 23
5778: ADD
5779: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5780: LD_ADDR_EXP 27
5784: PUSH
5785: LD_EXP 27
5789: PUSH
5790: LD_INT 3
5792: ADD
5793: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5794: LD_ADDR_EXP 27
5798: PUSH
5799: LD_EXP 27
5803: PUSH
5804: LD_INT 3
5806: ADD
5807: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5808: LD_ADDR_EXP 27
5812: PUSH
5813: LD_EXP 27
5817: PUSH
5818: LD_INT 46
5820: PUSH
5821: LD_INT 45
5823: PUSH
5824: LD_INT 47
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 2
5837: PPUSH
5838: LD_INT 3
5840: PPUSH
5841: CALL_OW 14
5845: ARRAY
5846: ADD
5847: ST_TO_ADDR
// end ;
5848: GO 5763
5850: POP
5851: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5852: LD_VAR 0 4
5856: PPUSH
5857: LD_INT 35
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PPUSH
5867: CALL_OW 72
5871: PUSH
5872: LD_INT 0
5874: GREATER
5875: IFFALSE 5923
// if BuildingStatus ( ru_factory ) = bs_idle then
5877: LD_VAR 0 2
5881: PPUSH
5882: CALL_OW 461
5886: PUSH
5887: LD_INT 2
5889: EQUAL
5890: IFFALSE 5923
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5892: LD_VAR 0 4
5896: PPUSH
5897: LD_INT 35
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PPUSH
5907: CALL_OW 72
5911: PUSH
5912: LD_INT 1
5914: ARRAY
5915: PPUSH
5916: LD_INT 47
5918: PPUSH
5919: CALL_OW 148
// if ru_force = ru_amount then
5923: LD_EXP 23
5927: PUSH
5928: LD_EXP 28
5932: EQUAL
5933: IFFALSE 6065
// begin for i = 1 to ru_force do
5935: LD_ADDR_VAR 0 12
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_EXP 23
5949: PUSH
5950: FOR_TO
5951: IFFALSE 6061
// if IsInArea ( ru_force [ i ] , ru_base ) then
5953: LD_EXP 23
5957: PUSH
5958: LD_VAR 0 12
5962: ARRAY
5963: PPUSH
5964: LD_INT 9
5966: PPUSH
5967: CALL_OW 308
5971: IFFALSE 5995
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5973: LD_EXP 23
5977: PUSH
5978: LD_VAR 0 12
5982: ARRAY
5983: PPUSH
5984: LD_VAR 0 3
5988: PPUSH
5989: CALL_OW 120
5993: GO 6059
// if not HasTask ( ru_force [ i ] ) then
5995: LD_EXP 23
5999: PUSH
6000: LD_VAR 0 12
6004: ARRAY
6005: PPUSH
6006: CALL_OW 314
6010: NOT
6011: IFFALSE 6059
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6013: LD_EXP 23
6017: PUSH
6018: LD_VAR 0 12
6022: ARRAY
6023: PPUSH
6024: LD_INT 81
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PPUSH
6034: CALL_OW 69
6038: PPUSH
6039: LD_EXP 23
6043: PUSH
6044: LD_VAR 0 12
6048: ARRAY
6049: PPUSH
6050: CALL_OW 74
6054: PPUSH
6055: CALL_OW 115
6059: GO 5950
6061: POP
6062: POP
// end else
6063: GO 6215
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6065: LD_EXP 23
6069: PPUSH
6070: LD_INT 3
6072: PUSH
6073: LD_INT 95
6075: PUSH
6076: LD_INT 18
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: PUSH
6092: LD_INT 0
6094: GREATER
6095: IFFALSE 6215
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6097: LD_ADDR_VAR 0 13
6101: PUSH
6102: LD_EXP 23
6106: PPUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 95
6112: PUSH
6113: LD_INT 18
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 72
6128: ST_TO_ADDR
// for i = 1 to tmp do
6129: LD_ADDR_VAR 0 12
6133: PUSH
6134: DOUBLE
6135: LD_INT 1
6137: DEC
6138: ST_TO_ADDR
6139: LD_VAR 0 13
6143: PUSH
6144: FOR_TO
6145: IFFALSE 6213
// if not HasTask ( tmp [ i ] ) then
6147: LD_VAR 0 13
6151: PUSH
6152: LD_VAR 0 12
6156: ARRAY
6157: PPUSH
6158: CALL_OW 314
6162: NOT
6163: IFFALSE 6211
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6165: LD_EXP 23
6169: PUSH
6170: LD_VAR 0 12
6174: ARRAY
6175: PPUSH
6176: LD_INT 81
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PPUSH
6191: LD_EXP 23
6195: PUSH
6196: LD_VAR 0 12
6200: ARRAY
6201: PPUSH
6202: CALL_OW 74
6206: PPUSH
6207: CALL_OW 115
6211: GO 6144
6213: POP
6214: POP
// end ; if ru_engs > 0 then
6215: LD_VAR 0 9
6219: PUSH
6220: LD_INT 0
6222: GREATER
6223: IFFALSE 6625
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6225: LD_VAR 0 5
6229: PPUSH
6230: LD_INT 3
6232: PUSH
6233: LD_INT 24
6235: PUSH
6236: LD_INT 1000
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_INT 0
6254: GREATER
6255: IFFALSE 6410
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6257: LD_ADDR_VAR 0 14
6261: PUSH
6262: LD_VAR 0 5
6266: PPUSH
6267: LD_INT 3
6269: PUSH
6270: LD_INT 24
6272: PUSH
6273: LD_INT 1000
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 72
6288: ST_TO_ADDR
// for i = 1 to ru_engs do
6289: LD_ADDR_VAR 0 12
6293: PUSH
6294: DOUBLE
6295: LD_INT 1
6297: DEC
6298: ST_TO_ADDR
6299: LD_VAR 0 9
6303: PUSH
6304: FOR_TO
6305: IFFALSE 6406
// begin if IsInUnit ( ru_engs [ i ] ) then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 310
6322: IFFALSE 6341
// ComExitBuilding ( ru_engs [ i ] ) else
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 122
6339: GO 6404
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6341: LD_VAR 0 9
6345: PUSH
6346: LD_VAR 0 12
6350: ARRAY
6351: PPUSH
6352: CALL_OW 314
6356: NOT
6357: PUSH
6358: LD_VAR 0 9
6362: PUSH
6363: LD_VAR 0 12
6367: ARRAY
6368: PPUSH
6369: CALL_OW 256
6373: PUSH
6374: LD_INT 600
6376: GREATER
6377: AND
6378: IFFALSE 6404
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6380: LD_VAR 0 9
6384: PUSH
6385: LD_VAR 0 12
6389: ARRAY
6390: PPUSH
6391: LD_VAR 0 14
6395: PUSH
6396: LD_INT 1
6398: ARRAY
6399: PPUSH
6400: CALL_OW 130
// end ;
6404: GO 6304
6406: POP
6407: POP
// end else
6408: GO 6625
// begin if ru_blist = 0 then
6410: LD_EXP 26
6414: PUSH
6415: LD_INT 0
6417: EQUAL
6418: IFFALSE 6500
// begin for i = 1 to ru_engs do
6420: LD_ADDR_VAR 0 12
6424: PUSH
6425: DOUBLE
6426: LD_INT 1
6428: DEC
6429: ST_TO_ADDR
6430: LD_VAR 0 9
6434: PUSH
6435: FOR_TO
6436: IFFALSE 6496
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6438: LD_VAR 0 9
6442: PUSH
6443: LD_VAR 0 12
6447: ARRAY
6448: PPUSH
6449: CALL_OW 314
6453: NOT
6454: PUSH
6455: LD_VAR 0 9
6459: PUSH
6460: LD_VAR 0 12
6464: ARRAY
6465: PPUSH
6466: CALL_OW 310
6470: NOT
6471: AND
6472: IFFALSE 6494
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6474: LD_VAR 0 9
6478: PUSH
6479: LD_VAR 0 12
6483: ARRAY
6484: PPUSH
6485: LD_VAR 0 1
6489: PPUSH
6490: CALL_OW 120
6494: GO 6435
6496: POP
6497: POP
// end else
6498: GO 6625
// begin for i = 1 to ru_engs do
6500: LD_ADDR_VAR 0 12
6504: PUSH
6505: DOUBLE
6506: LD_INT 1
6508: DEC
6509: ST_TO_ADDR
6510: LD_VAR 0 9
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6623
// begin if IsInUnit ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 310
6533: IFFALSE 6552
// ComExitBuilding ( ru_engs [ i ] ) else
6535: LD_VAR 0 9
6539: PUSH
6540: LD_VAR 0 12
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
6550: GO 6621
// if not HasTask ( ru_engs [ i ] ) then
6552: LD_VAR 0 9
6556: PUSH
6557: LD_VAR 0 12
6561: ARRAY
6562: PPUSH
6563: CALL_OW 314
6567: NOT
6568: IFFALSE 6621
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6570: LD_VAR 0 9
6574: PUSH
6575: LD_VAR 0 12
6579: ARRAY
6580: PPUSH
6581: LD_EXP 26
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 2
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 3
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 4
6615: ARRAY
6616: PPUSH
6617: CALL_OW 145
// end ;
6621: GO 6515
6623: POP
6624: POP
// end ; end ; end ; end ;
6625: PPOPN 17
6627: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6628: LD_EXP 2
6632: PUSH
6633: LD_INT 11
6635: PPUSH
6636: CALL_OW 435
6640: PUSH
6641: LD_INT 20
6643: LESS
6644: AND
6645: IFFALSE 6708
6647: GO 6649
6649: DISABLE
// begin enable ;
6650: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6651: LD_INT 1
6653: PPUSH
6654: LD_INT 5
6656: PPUSH
6657: CALL_OW 12
6661: PPUSH
6662: LD_INT 11
6664: PPUSH
6665: LD_INT 1
6667: PPUSH
6668: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6672: LD_INT 1505
6674: PPUSH
6675: LD_INT 2100
6677: PPUSH
6678: CALL_OW 12
6682: PPUSH
6683: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 5
6692: PPUSH
6693: CALL_OW 12
6697: PPUSH
6698: LD_INT 11
6700: PPUSH
6701: LD_INT 1
6703: PPUSH
6704: CALL_OW 55
// end ;
6708: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6709: LD_EXP 4
6713: PUSH
6714: LD_INT 0
6716: EQUAL
6717: IFFALSE 6832
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
6725: PPUSH
// begin enable ;
6726: ENABLE
// i := Rand ( 0 , 100 ) ;
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: LD_INT 0
6734: PPUSH
6735: LD_INT 100
6737: PPUSH
6738: CALL_OW 12
6742: ST_TO_ADDR
// case your_side of 1 :
6743: LD_OWVAR 2
6747: PUSH
6748: LD_INT 1
6750: DOUBLE
6751: EQUAL
6752: IFTRUE 6756
6754: GO 6767
6756: POP
// tmp := 10 ; 2 :
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 10
6764: ST_TO_ADDR
6765: GO 6806
6767: LD_INT 2
6769: DOUBLE
6770: EQUAL
6771: IFTRUE 6775
6773: GO 6786
6775: POP
// tmp := 0 ; 7 :
6776: LD_ADDR_VAR 0 2
6780: PUSH
6781: LD_INT 0
6783: ST_TO_ADDR
6784: GO 6806
6786: LD_INT 7
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6805
6794: POP
// tmp := 15 ; end ;
6795: LD_ADDR_VAR 0 2
6799: PUSH
6800: LD_INT 15
6802: ST_TO_ADDR
6803: GO 6806
6805: POP
// if i < chance_to_bomb + tmp then
6806: LD_VAR 0 1
6810: PUSH
6811: LD_EXP 5
6815: PUSH
6816: LD_VAR 0 2
6820: PLUS
6821: LESS
6822: IFFALSE 6832
// ru_sib_bomb := true ;
6824: LD_ADDR_EXP 4
6828: PUSH
6829: LD_INT 1
6831: ST_TO_ADDR
// end ;
6832: PPOPN 2
6834: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6835: LD_INT 22
6837: PUSH
6838: LD_OWVAR 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 34
6849: PUSH
6850: LD_INT 8
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 69
6865: IFFALSE 6878
6867: GO 6869
6869: DISABLE
// begin ru_sib_bomb := true ;
6870: LD_ADDR_EXP 4
6874: PUSH
6875: LD_INT 1
6877: ST_TO_ADDR
// end ;
6878: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6879: LD_INT 22
6881: PUSH
6882: LD_INT 3
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 30
6891: PUSH
6892: LD_INT 34
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PPUSH
6903: CALL_OW 69
6907: IFFALSE 7006
6909: GO 6911
6911: DISABLE
6912: LD_INT 0
6914: PPUSH
// begin enable ;
6915: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 1
6933: PPUSH
6934: LD_INT 2
6936: PPUSH
6937: CALL_OW 12
6941: ARRAY
6942: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6943: LD_INT 22
6945: PUSH
6946: LD_INT 3
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: LD_INT 30
6955: PUSH
6956: LD_INT 34
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_EXP 30
6980: PUSH
6981: LD_VAR 0 1
6985: ARRAY
6986: PPUSH
6987: LD_EXP 30
6991: PUSH
6992: LD_VAR 0 1
6996: PUSH
6997: LD_INT 1
6999: PLUS
7000: ARRAY
7001: PPUSH
7002: CALL_OW 243
// end ; end_of_file
7006: PPOPN 1
7008: END
// export function RemoveLegion ; var i ; begin
7009: LD_INT 0
7011: PPUSH
7012: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7013: LD_ADDR_VAR 0 2
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 69
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7047
// RemoveUnit ( i ) ;
7036: LD_VAR 0 2
7040: PPUSH
7041: CALL_OW 64
7045: GO 7033
7047: POP
7048: POP
// end ;
7049: LD_VAR 0 1
7053: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
7059: PPUSH
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
7064: PPUSH
7065: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7066: LD_ADDR_VAR 0 7
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 8
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 30
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL_OW 69
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7104: LD_ADDR_VAR 0 8
7108: PUSH
7109: LD_INT 22
7111: PUSH
7112: LD_INT 8
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 30
7121: PUSH
7122: LD_INT 3
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PPUSH
7133: CALL_OW 69
7137: PUSH
7138: LD_INT 1
7140: ARRAY
7141: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7142: LD_ADDR_VAR 0 9
7146: PUSH
7147: LD_INT 22
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: LD_INT 30
7162: PUSH
7163: LD_INT 6
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 30
7172: PUSH
7173: LD_INT 8
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PPUSH
7189: CALL_OW 69
7193: PUSH
7194: LD_INT 1
7196: ARRAY
7197: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7198: LD_ADDR_VAR 0 10
7202: PUSH
7203: LD_INT 22
7205: PUSH
7206: LD_INT 8
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 30
7215: PUSH
7216: LD_INT 32
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL_OW 69
7231: ST_TO_ADDR
// uc_side := 8 ;
7232: LD_ADDR_OWVAR 20
7236: PUSH
7237: LD_INT 8
7239: ST_TO_ADDR
// uc_nation := nation_arabian ;
7240: LD_ADDR_OWVAR 21
7244: PUSH
7245: LD_INT 2
7247: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7248: LD_ADDR_EXP 32
7252: PUSH
7253: LD_INT 5
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: LD_INT 7
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: PUSH
7267: LD_OWVAR 67
7271: ARRAY
7272: ST_TO_ADDR
// legion_blist := [ ] ;
7273: LD_ADDR_EXP 34
7277: PUSH
7278: EMPTY
7279: ST_TO_ADDR
// legion_vlist := [ ] ;
7280: LD_ADDR_EXP 35
7284: PUSH
7285: EMPTY
7286: ST_TO_ADDR
// legion_force := [ ] ;
7287: LD_ADDR_EXP 31
7291: PUSH
7292: EMPTY
7293: ST_TO_ADDR
// legion_enemy := - 1 ;
7294: LD_ADDR_EXP 36
7298: PUSH
7299: LD_INT 1
7301: NEG
7302: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7303: LD_VAR 0 7
7307: PPUSH
7308: CALL_OW 274
7312: PPUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 10000
7318: PPUSH
7319: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7323: LD_VAR 0 7
7327: PPUSH
7328: CALL_OW 274
7332: PPUSH
7333: LD_INT 3
7335: PPUSH
7336: LD_INT 1000
7338: PPUSH
7339: CALL_OW 277
// for i = 1 to l_towers do
7343: LD_ADDR_VAR 0 3
7347: PUSH
7348: DOUBLE
7349: LD_INT 1
7351: DEC
7352: ST_TO_ADDR
7353: LD_VAR 0 10
7357: PUSH
7358: FOR_TO
7359: IFFALSE 7408
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7361: LD_INT 0
7363: PPUSH
7364: LD_INT 1
7366: PPUSH
7367: LD_EXP 32
7371: PPUSH
7372: CALL_OW 380
// un := CreateHuman ;
7376: LD_ADDR_VAR 0 2
7380: PUSH
7381: CALL_OW 44
7385: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7386: LD_VAR 0 2
7390: PPUSH
7391: LD_VAR 0 10
7395: PUSH
7396: LD_VAR 0 3
7400: ARRAY
7401: PPUSH
7402: CALL_OW 52
// end ;
7406: GO 7358
7408: POP
7409: POP
// for i = 1 to 4 do
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: DOUBLE
7416: LD_INT 1
7418: DEC
7419: ST_TO_ADDR
7420: LD_INT 4
7422: PUSH
7423: FOR_TO
7424: IFFALSE 7517
// for p = 1 to 2 do
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: DOUBLE
7432: LD_INT 1
7434: DEC
7435: ST_TO_ADDR
7436: LD_INT 2
7438: PUSH
7439: FOR_TO
7440: IFFALSE 7513
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7442: LD_INT 0
7444: PPUSH
7445: LD_INT 8
7447: PPUSH
7448: LD_EXP 32
7452: PPUSH
7453: CALL_OW 380
// un := CreateHuman ;
7457: LD_ADDR_VAR 0 2
7461: PUSH
7462: CALL_OW 44
7466: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7467: LD_VAR 0 2
7471: PPUSH
7472: LD_INT 22
7474: PUSH
7475: LD_INT 8
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 30
7484: PUSH
7485: LD_INT 5
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PPUSH
7496: CALL_OW 69
7500: PUSH
7501: LD_VAR 0 6
7505: ARRAY
7506: PPUSH
7507: CALL_OW 52
// end ;
7511: GO 7439
7513: POP
7514: POP
7515: GO 7423
7517: POP
7518: POP
// for i = 1 to 4 do
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: DOUBLE
7525: LD_INT 1
7527: DEC
7528: ST_TO_ADDR
7529: LD_INT 4
7531: PUSH
7532: FOR_TO
7533: IFFALSE 7576
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7535: LD_INT 0
7537: PPUSH
7538: LD_INT 4
7540: PPUSH
7541: LD_EXP 32
7545: PPUSH
7546: CALL_OW 380
// un := CreateHuman ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: CALL_OW 44
7559: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7560: LD_VAR 0 2
7564: PPUSH
7565: LD_VAR 0 9
7569: PPUSH
7570: CALL_OW 52
// end ;
7574: GO 7532
7576: POP
7577: POP
// for i = 1 to 6 do
7578: LD_ADDR_VAR 0 3
7582: PUSH
7583: DOUBLE
7584: LD_INT 1
7586: DEC
7587: ST_TO_ADDR
7588: LD_INT 6
7590: PUSH
7591: FOR_TO
7592: IFFALSE 7635
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_EXP 32
7604: PPUSH
7605: CALL_OW 380
// un := CreateHuman ;
7609: LD_ADDR_VAR 0 2
7613: PUSH
7614: CALL_OW 44
7618: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7619: LD_VAR 0 2
7623: PPUSH
7624: LD_VAR 0 8
7628: PPUSH
7629: CALL_OW 52
// end ;
7633: GO 7591
7635: POP
7636: POP
// for i = 1 to 5 do
7637: LD_ADDR_VAR 0 3
7641: PUSH
7642: DOUBLE
7643: LD_INT 1
7645: DEC
7646: ST_TO_ADDR
7647: LD_INT 5
7649: PUSH
7650: FOR_TO
7651: IFFALSE 7694
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7653: LD_INT 0
7655: PPUSH
7656: LD_INT 2
7658: PPUSH
7659: LD_EXP 32
7663: PPUSH
7664: CALL_OW 380
// un := CreateHuman ;
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: CALL_OW 44
7677: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7678: LD_VAR 0 2
7682: PPUSH
7683: LD_VAR 0 7
7687: PPUSH
7688: CALL_OW 52
// end ;
7692: GO 7650
7694: POP
7695: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7696: LD_ADDR_VAR 0 4
7700: PUSH
7701: LD_INT 199
7703: PPUSH
7704: LD_INT 134
7706: PPUSH
7707: LD_INT 216
7709: PPUSH
7710: LD_INT 141
7712: PPUSH
7713: LD_INT 6
7715: PPUSH
7716: CALL 1562 0 5
7720: ST_TO_ADDR
// p := 1 ;
7721: LD_ADDR_VAR 0 6
7725: PUSH
7726: LD_INT 1
7728: ST_TO_ADDR
// for i = 1 to 3 do
7729: LD_ADDR_VAR 0 3
7733: PUSH
7734: DOUBLE
7735: LD_INT 1
7737: DEC
7738: ST_TO_ADDR
7739: LD_INT 3
7741: PUSH
7742: FOR_TO
7743: IFFALSE 7996
// begin vc_chassis := ar_half_tracked ;
7745: LD_ADDR_OWVAR 37
7749: PUSH
7750: LD_INT 14
7752: ST_TO_ADDR
// vc_engine := engine_siberite ;
7753: LD_ADDR_OWVAR 39
7757: PUSH
7758: LD_INT 3
7760: ST_TO_ADDR
// vc_control := control_manual ;
7761: LD_ADDR_OWVAR 38
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7769: LD_ADDR_OWVAR 40
7773: PUSH
7774: LD_INT 31
7776: ST_TO_ADDR
// veh := CreateVehicle ;
7777: LD_ADDR_VAR 0 5
7781: PUSH
7782: CALL_OW 45
7786: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7787: LD_VAR 0 4
7791: PUSH
7792: LD_VAR 0 6
7796: ARRAY
7797: PPUSH
7798: LD_VAR 0 4
7802: PUSH
7803: LD_VAR 0 6
7807: PUSH
7808: LD_INT 1
7810: PLUS
7811: ARRAY
7812: PPUSH
7813: CALL_OW 428
7817: PUSH
7818: LD_INT 0
7820: EQUAL
7821: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7823: LD_VAR 0 5
7827: PPUSH
7828: LD_VAR 0 4
7832: PUSH
7833: LD_VAR 0 6
7837: ARRAY
7838: PPUSH
7839: LD_VAR 0 4
7843: PUSH
7844: LD_VAR 0 6
7848: PUSH
7849: LD_INT 1
7851: PLUS
7852: ARRAY
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 48
7861: GO 7951
// begin repeat p := p + 2 ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_VAR 0 6
7872: PUSH
7873: LD_INT 2
7875: PLUS
7876: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7877: LD_VAR 0 4
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_VAR 0 4
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ARRAY
7902: PPUSH
7903: CALL_OW 428
7907: PUSH
7908: LD_INT 0
7910: EQUAL
7911: IFFALSE 7863
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7913: LD_VAR 0 5
7917: PPUSH
7918: LD_VAR 0 4
7922: PUSH
7923: LD_VAR 0 6
7927: ARRAY
7928: PPUSH
7929: LD_VAR 0 4
7933: PUSH
7934: LD_VAR 0 6
7938: PUSH
7939: LD_INT 1
7941: PLUS
7942: ARRAY
7943: PPUSH
7944: LD_INT 0
7946: PPUSH
7947: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7951: LD_INT 0
7953: PPUSH
7954: LD_INT 3
7956: PPUSH
7957: LD_EXP 32
7961: PUSH
7962: LD_INT 1
7964: PLUS
7965: PPUSH
7966: CALL_OW 380
// un := CreateHuman ;
7970: LD_ADDR_VAR 0 2
7974: PUSH
7975: CALL_OW 44
7979: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7980: LD_VAR 0 2
7984: PPUSH
7985: LD_VAR 0 5
7989: PPUSH
7990: CALL_OW 52
// end ;
7994: GO 7742
7996: POP
7997: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7998: LD_INT 198
8000: PPUSH
8001: LD_INT 94
8003: PPUSH
8004: LD_INT 8
8006: PPUSH
8007: LD_INT 10
8009: PPUSH
8010: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8014: LD_INT 167
8016: PPUSH
8017: LD_INT 130
8019: PPUSH
8020: LD_INT 8
8022: PPUSH
8023: LD_INT 10
8025: PPUSH
8026: CALL_OW 330
// legion_mines := [ ] ;
8030: LD_ADDR_EXP 33
8034: PUSH
8035: EMPTY
8036: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8037: LD_ADDR_EXP 33
8041: PUSH
8042: LD_INT 176
8044: PPUSH
8045: LD_INT 122
8047: PPUSH
8048: LD_INT 188
8050: PPUSH
8051: LD_INT 126
8053: PPUSH
8054: LD_INT 6
8056: PPUSH
8057: CALL 1562 0 5
8061: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8062: LD_ADDR_EXP 33
8066: PUSH
8067: LD_EXP 33
8071: PUSH
8072: LD_INT 197
8074: PPUSH
8075: LD_INT 91
8077: PPUSH
8078: LD_INT 205
8080: PPUSH
8081: LD_INT 96
8083: PPUSH
8084: LD_INT 4
8086: PPUSH
8087: CALL 1562 0 5
8091: ADD
8092: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8093: LD_ADDR_EXP 33
8097: PUSH
8098: LD_EXP 33
8102: PUSH
8103: LD_INT 184
8105: PPUSH
8106: LD_INT 151
8108: PPUSH
8109: LD_INT 178
8111: PPUSH
8112: LD_INT 130
8114: PPUSH
8115: LD_INT 9
8117: PPUSH
8118: CALL 1562 0 5
8122: ADD
8123: ST_TO_ADDR
// if Difficulty > 1 then
8124: LD_OWVAR 67
8128: PUSH
8129: LD_INT 1
8131: GREATER
8132: IFFALSE 8165
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8134: LD_ADDR_EXP 33
8138: PUSH
8139: LD_EXP 33
8143: PUSH
8144: LD_INT 166
8146: PPUSH
8147: LD_INT 126
8149: PPUSH
8150: LD_INT 181
8152: PPUSH
8153: LD_INT 136
8155: PPUSH
8156: LD_INT 5
8158: PPUSH
8159: CALL 1562 0 5
8163: ADD
8164: ST_TO_ADDR
// p := 1 ;
8165: LD_ADDR_VAR 0 6
8169: PUSH
8170: LD_INT 1
8172: ST_TO_ADDR
// for i = 1 to 24 do
8173: LD_ADDR_VAR 0 3
8177: PUSH
8178: DOUBLE
8179: LD_INT 1
8181: DEC
8182: ST_TO_ADDR
8183: LD_INT 24
8185: PUSH
8186: FOR_TO
8187: IFFALSE 8241
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8189: LD_EXP 33
8193: PUSH
8194: LD_VAR 0 6
8198: ARRAY
8199: PPUSH
8200: LD_EXP 33
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: LD_INT 1
8212: PLUS
8213: ARRAY
8214: PPUSH
8215: LD_INT 8
8217: PPUSH
8218: LD_INT 0
8220: PPUSH
8221: CALL_OW 454
// p := p + 2 ;
8225: LD_ADDR_VAR 0 6
8229: PUSH
8230: LD_VAR 0 6
8234: PUSH
8235: LD_INT 2
8237: PLUS
8238: ST_TO_ADDR
// end ;
8239: GO 8186
8241: POP
8242: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8243: LD_ADDR_EXP 35
8247: PUSH
8248: LD_INT 13
8250: PUSH
8251: LD_INT 3
8253: PUSH
8254: LD_INT 2
8256: PUSH
8257: LD_INT 32
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: ST_TO_ADDR
// end ;
8266: LD_VAR 0 1
8270: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 69
8285: PUSH
8286: LD_INT 0
8288: GREATER
8289: IFFALSE 10475
8291: GO 8293
8293: DISABLE
8294: LD_INT 0
8296: PPUSH
8297: PPUSH
8298: PPUSH
8299: PPUSH
8300: PPUSH
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
// begin enable ;
8313: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_INT 22
8321: PUSH
8322: LD_INT 8
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: LD_INT 30
8331: PUSH
8332: LD_INT 1
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PPUSH
8343: CALL_OW 69
8347: PUSH
8348: LD_INT 1
8350: ARRAY
8351: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8352: LD_ADDR_VAR 0 9
8356: PUSH
8357: LD_INT 22
8359: PUSH
8360: LD_INT 8
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 30
8369: PUSH
8370: LD_INT 3
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8390: LD_ADDR_VAR 0 10
8394: PUSH
8395: LD_INT 22
8397: PUSH
8398: LD_INT 8
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 2
8407: PUSH
8408: LD_INT 30
8410: PUSH
8411: LD_INT 6
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 30
8420: PUSH
8421: LD_INT 8
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PPUSH
8437: CALL_OW 69
8441: PUSH
8442: LD_INT 1
8444: ARRAY
8445: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8446: LD_ADDR_VAR 0 11
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 32
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8480: LD_ADDR_VAR 0 16
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 2
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8514: LD_ADDR_VAR 0 15
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8548: LD_ADDR_VAR 0 14
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 3
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8582: LD_ADDR_VAR 0 13
8586: PUSH
8587: LD_INT 22
8589: PUSH
8590: LD_INT 8
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: PUSH
8597: LD_INT 25
8599: PUSH
8600: LD_INT 4
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PPUSH
8611: CALL_OW 69
8615: ST_TO_ADDR
// if l_eng then
8616: LD_VAR 0 16
8620: IFFALSE 9035
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8622: LD_ADDR_VAR 0 5
8626: PUSH
8627: LD_INT 22
8629: PUSH
8630: LD_INT 8
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: LD_INT 21
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PPUSH
8651: CALL_OW 69
8655: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8656: LD_VAR 0 5
8660: PPUSH
8661: LD_INT 3
8663: PUSH
8664: LD_INT 24
8666: PUSH
8667: LD_INT 1000
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL_OW 72
8682: PUSH
8683: LD_INT 0
8685: GREATER
8686: IFFALSE 8820
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8688: LD_ADDR_VAR 0 3
8692: PUSH
8693: LD_VAR 0 5
8697: PPUSH
8698: LD_INT 3
8700: PUSH
8701: LD_INT 24
8703: PUSH
8704: LD_INT 1000
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PPUSH
8715: CALL_OW 72
8719: ST_TO_ADDR
// for i = 1 to l_eng do
8720: LD_ADDR_VAR 0 2
8724: PUSH
8725: DOUBLE
8726: LD_INT 1
8728: DEC
8729: ST_TO_ADDR
8730: LD_VAR 0 16
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8816
// if IsInUnit ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 310
8753: IFFALSE 8772
// ComExitBuilding ( l_eng [ i ] ) else
8755: LD_VAR 0 16
8759: PUSH
8760: LD_VAR 0 2
8764: ARRAY
8765: PPUSH
8766: CALL_OW 122
8770: GO 8814
// if not HasTask ( l_eng [ i ] ) then
8772: LD_VAR 0 16
8776: PUSH
8777: LD_VAR 0 2
8781: ARRAY
8782: PPUSH
8783: CALL_OW 314
8787: NOT
8788: IFFALSE 8814
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8790: LD_VAR 0 16
8794: PUSH
8795: LD_VAR 0 2
8799: ARRAY
8800: PPUSH
8801: LD_VAR 0 3
8805: PUSH
8806: LD_INT 1
8808: ARRAY
8809: PPUSH
8810: CALL_OW 130
8814: GO 8735
8816: POP
8817: POP
// end else
8818: GO 9035
// begin if legion_blist > 0 then
8820: LD_EXP 34
8824: PUSH
8825: LD_INT 0
8827: GREATER
8828: IFFALSE 8957
// begin for i = 1 to l_eng do
8830: LD_ADDR_VAR 0 2
8834: PUSH
8835: DOUBLE
8836: LD_INT 1
8838: DEC
8839: ST_TO_ADDR
8840: LD_VAR 0 16
8844: PUSH
8845: FOR_TO
8846: IFFALSE 8953
// if IsInUnit ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 310
8863: IFFALSE 8882
// ComExitBuilding ( l_eng [ i ] ) else
8865: LD_VAR 0 16
8869: PUSH
8870: LD_VAR 0 2
8874: ARRAY
8875: PPUSH
8876: CALL_OW 122
8880: GO 8951
// if not HasTask ( l_eng [ i ] ) then
8882: LD_VAR 0 16
8886: PUSH
8887: LD_VAR 0 2
8891: ARRAY
8892: PPUSH
8893: CALL_OW 314
8897: NOT
8898: IFFALSE 8951
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8900: LD_VAR 0 16
8904: PUSH
8905: LD_VAR 0 2
8909: ARRAY
8910: PPUSH
8911: LD_EXP 34
8915: PUSH
8916: LD_INT 1
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 2
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 3
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 4
8945: ARRAY
8946: PPUSH
8947: CALL_OW 145
8951: GO 8845
8953: POP
8954: POP
// end else
8955: GO 9035
// for i = 1 to l_eng do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: DOUBLE
8963: LD_INT 1
8965: DEC
8966: ST_TO_ADDR
8967: LD_VAR 0 16
8971: PUSH
8972: FOR_TO
8973: IFFALSE 9033
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8975: LD_VAR 0 16
8979: PUSH
8980: LD_VAR 0 2
8984: ARRAY
8985: PPUSH
8986: CALL_OW 310
8990: NOT
8991: PUSH
8992: LD_VAR 0 16
8996: PUSH
8997: LD_VAR 0 2
9001: ARRAY
9002: PPUSH
9003: CALL_OW 314
9007: NOT
9008: AND
9009: IFFALSE 9031
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9011: LD_VAR 0 16
9015: PUSH
9016: LD_VAR 0 2
9020: ARRAY
9021: PPUSH
9022: LD_VAR 0 8
9026: PPUSH
9027: CALL_OW 120
9031: GO 8972
9033: POP
9034: POP
// end ; end ; if l_factory then
9035: LD_VAR 0 9
9039: IFFALSE 9439
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9041: LD_INT 22
9043: PUSH
9044: LD_INT 8
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: LD_INT 33
9053: PUSH
9054: LD_INT 2
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 3
9063: PUSH
9064: LD_INT 61
9066: PUSH
9067: EMPTY
9068: LIST
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PPUSH
9079: CALL_OW 69
9083: PUSH
9084: LD_INT 0
9086: GREATER
9087: PUSH
9088: LD_INT 22
9090: PUSH
9091: LD_INT 8
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 34
9100: PUSH
9101: LD_INT 31
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL_OW 69
9116: PUSH
9117: LD_INT 0
9119: GREATER
9120: AND
9121: IFFALSE 9241
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9123: LD_INT 22
9125: PUSH
9126: LD_INT 8
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 33
9135: PUSH
9136: LD_INT 2
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 61
9148: PUSH
9149: EMPTY
9150: LIST
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: PUSH
9166: LD_INT 1
9168: ARRAY
9169: PPUSH
9170: LD_INT 22
9172: PUSH
9173: LD_INT 8
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 34
9182: PUSH
9183: LD_INT 31
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PUSH
9199: LD_INT 1
9201: PPUSH
9202: LD_INT 22
9204: PUSH
9205: LD_INT 8
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 34
9214: PUSH
9215: LD_INT 31
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PPUSH
9226: CALL_OW 69
9230: PPUSH
9231: CALL_OW 12
9235: ARRAY
9236: PPUSH
9237: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9241: LD_EXP 35
9245: PUSH
9246: LD_INT 0
9248: GREATER
9249: PUSH
9250: LD_VAR 0 9
9254: PPUSH
9255: CALL_OW 461
9259: PUSH
9260: LD_INT 2
9262: EQUAL
9263: AND
9264: IFFALSE 9349
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9266: LD_VAR 0 9
9270: PPUSH
9271: LD_EXP 35
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 3
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: PPUSH
9307: CALL_OW 125
// for i = 1 to 4 do
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: DOUBLE
9317: LD_INT 1
9319: DEC
9320: ST_TO_ADDR
9321: LD_INT 4
9323: PUSH
9324: FOR_TO
9325: IFFALSE 9347
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9327: LD_ADDR_EXP 35
9331: PUSH
9332: LD_EXP 35
9336: PPUSH
9337: LD_INT 1
9339: PPUSH
9340: CALL_OW 3
9344: ST_TO_ADDR
9345: GO 9324
9347: POP
9348: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9349: LD_VAR 0 11
9353: PPUSH
9354: LD_INT 35
9356: PUSH
9357: LD_INT 0
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 72
9368: PUSH
9369: LD_INT 0
9371: GREATER
9372: PUSH
9373: LD_VAR 0 9
9377: PPUSH
9378: CALL_OW 461
9382: PUSH
9383: LD_INT 2
9385: EQUAL
9386: AND
9387: IFFALSE 9439
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9389: LD_VAR 0 11
9393: PPUSH
9394: LD_INT 35
9396: PUSH
9397: LD_INT 0
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 72
9408: PUSH
9409: LD_INT 1
9411: ARRAY
9412: PPUSH
9413: LD_INT 28
9415: PUSH
9416: LD_INT 27
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 2
9428: PPUSH
9429: CALL_OW 12
9433: ARRAY
9434: PPUSH
9435: CALL_OW 148
// end ; if legion_enemy > 0 then
9439: LD_EXP 36
9443: PUSH
9444: LD_INT 0
9446: GREATER
9447: IFFALSE 10027
// begin if tick mod 11 11$00 = 0 then
9449: LD_OWVAR 1
9453: PUSH
9454: LD_INT 23100
9456: MOD
9457: PUSH
9458: LD_INT 0
9460: EQUAL
9461: IFFALSE 9711
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9463: LD_ADDR_EXP 35
9467: PUSH
9468: LD_EXP 35
9472: PUSH
9473: LD_INT 13
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: ADD
9487: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9488: LD_ADDR_EXP 35
9492: PUSH
9493: LD_EXP 35
9497: PUSH
9498: LD_INT 28
9500: PUSH
9501: LD_INT 27
9503: PUSH
9504: LD_INT 29
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 1
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: ARRAY
9523: ADD
9524: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9525: LD_ADDR_EXP 35
9529: PUSH
9530: LD_EXP 35
9534: PUSH
9535: LD_INT 13
9537: PUSH
9538: LD_INT 1
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: ADD
9549: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9550: LD_ADDR_EXP 35
9554: PUSH
9555: LD_EXP 35
9559: PUSH
9560: LD_INT 28
9562: PUSH
9563: LD_INT 27
9565: PUSH
9566: LD_INT 29
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 1
9576: PPUSH
9577: LD_INT 3
9579: PPUSH
9580: CALL_OW 12
9584: ARRAY
9585: ADD
9586: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9587: LD_ADDR_EXP 35
9591: PUSH
9592: LD_EXP 35
9596: PUSH
9597: LD_INT 13
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: LD_INT 2
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: ADD
9611: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9612: LD_ADDR_EXP 35
9616: PUSH
9617: LD_EXP 35
9621: PUSH
9622: LD_INT 28
9624: PUSH
9625: LD_INT 27
9627: PUSH
9628: LD_INT 29
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 1
9638: PPUSH
9639: LD_INT 3
9641: PPUSH
9642: CALL_OW 12
9646: ARRAY
9647: ADD
9648: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9649: LD_ADDR_EXP 35
9653: PUSH
9654: LD_EXP 35
9658: PUSH
9659: LD_INT 13
9661: PUSH
9662: LD_INT 1
9664: PUSH
9665: LD_INT 2
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: ADD
9673: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9674: LD_ADDR_EXP 35
9678: PUSH
9679: LD_EXP 35
9683: PUSH
9684: LD_INT 28
9686: PUSH
9687: LD_INT 27
9689: PUSH
9690: LD_INT 29
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 1
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: CALL_OW 12
9708: ARRAY
9709: ADD
9710: ST_TO_ADDR
// end ; if legion_force >= 7 then
9711: LD_EXP 31
9715: PUSH
9716: LD_INT 7
9718: GREATEREQUAL
9719: IFFALSE 9902
// begin for i = 1 to legion_force do
9721: LD_ADDR_VAR 0 2
9725: PUSH
9726: DOUBLE
9727: LD_INT 1
9729: DEC
9730: ST_TO_ADDR
9731: LD_EXP 31
9735: PUSH
9736: FOR_TO
9737: IFFALSE 9900
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9739: LD_EXP 31
9743: PUSH
9744: LD_VAR 0 2
9748: ARRAY
9749: PPUSH
9750: CALL_OW 314
9754: NOT
9755: PUSH
9756: LD_EXP 31
9760: PUSH
9761: LD_VAR 0 2
9765: ARRAY
9766: PPUSH
9767: CALL_OW 110
9771: PUSH
9772: LD_INT 11
9774: NONEQUAL
9775: AND
9776: IFFALSE 9898
// begin case legion_enemy of 1 :
9778: LD_EXP 36
9782: PUSH
9783: LD_INT 1
9785: DOUBLE
9786: EQUAL
9787: IFTRUE 9791
9789: GO 9815
9791: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 142
9805: PPUSH
9806: LD_INT 144
9808: PPUSH
9809: CALL_OW 111
9813: GO 9880
9815: LD_INT 2
9817: DOUBLE
9818: EQUAL
9819: IFTRUE 9823
9821: GO 9847
9823: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9824: LD_EXP 31
9828: PUSH
9829: LD_VAR 0 2
9833: ARRAY
9834: PPUSH
9835: LD_INT 101
9837: PPUSH
9838: LD_INT 34
9840: PPUSH
9841: CALL_OW 111
9845: GO 9880
9847: LD_INT 7
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9879
9855: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9856: LD_EXP 31
9860: PUSH
9861: LD_VAR 0 2
9865: ARRAY
9866: PPUSH
9867: LD_INT 173
9869: PPUSH
9870: LD_INT 127
9872: PPUSH
9873: CALL_OW 111
9877: GO 9880
9879: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9880: LD_EXP 31
9884: PUSH
9885: LD_VAR 0 2
9889: ARRAY
9890: PPUSH
9891: LD_INT 11
9893: PPUSH
9894: CALL_OW 109
// end ; end ;
9898: GO 9736
9900: POP
9901: POP
// end ; if legion_force then
9902: LD_EXP 31
9906: IFFALSE 10027
// begin tmp := legion_force ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_EXP 31
9917: ST_TO_ADDR
// for i = 1 to tmp do
9918: LD_ADDR_VAR 0 2
9922: PUSH
9923: DOUBLE
9924: LD_INT 1
9926: DEC
9927: ST_TO_ADDR
9928: LD_VAR 0 3
9932: PUSH
9933: FOR_TO
9934: IFFALSE 10025
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9936: LD_VAR 0 3
9940: PUSH
9941: LD_VAR 0 2
9945: ARRAY
9946: PPUSH
9947: CALL_OW 314
9951: NOT
9952: PUSH
9953: LD_EXP 31
9957: PUSH
9958: LD_VAR 0 2
9962: ARRAY
9963: PPUSH
9964: CALL_OW 110
9968: PUSH
9969: LD_INT 11
9971: EQUAL
9972: AND
9973: IFFALSE 10023
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9975: LD_VAR 0 3
9979: PUSH
9980: LD_VAR 0 2
9984: ARRAY
9985: PPUSH
9986: LD_INT 22
9988: PUSH
9989: LD_EXP 36
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PPUSH
9998: CALL_OW 69
10002: PPUSH
10003: LD_VAR 0 3
10007: PUSH
10008: LD_VAR 0 2
10012: ARRAY
10013: PPUSH
10014: CALL_OW 74
10018: PPUSH
10019: CALL_OW 115
10023: GO 9933
10025: POP
10026: POP
// end ; end ; p := 1 ;
10027: LD_ADDR_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: ST_TO_ADDR
// for i = 1 to 24 do
10035: LD_ADDR_VAR 0 2
10039: PUSH
10040: DOUBLE
10041: LD_INT 1
10043: DEC
10044: ST_TO_ADDR
10045: LD_INT 24
10047: PUSH
10048: FOR_TO
10049: IFFALSE 10179
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10051: LD_EXP 33
10055: PUSH
10056: LD_VAR 0 6
10060: ARRAY
10061: PPUSH
10062: LD_EXP 33
10066: PUSH
10067: LD_VAR 0 6
10071: PUSH
10072: LD_INT 1
10074: PLUS
10075: ARRAY
10076: PPUSH
10077: CALL_OW 428
10081: PUSH
10082: LD_INT 0
10084: GREATER
10085: IFFALSE 10163
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10087: LD_EXP 33
10091: PUSH
10092: LD_VAR 0 6
10096: ARRAY
10097: PPUSH
10098: LD_EXP 33
10102: PUSH
10103: LD_VAR 0 6
10107: PUSH
10108: LD_INT 1
10110: PLUS
10111: ARRAY
10112: PPUSH
10113: CALL_OW 428
10117: PPUSH
10118: CALL_OW 255
10122: PUSH
10123: LD_EXP 36
10127: EQUAL
10128: IFFALSE 10163
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10130: LD_EXP 33
10134: PUSH
10135: LD_VAR 0 6
10139: ARRAY
10140: PPUSH
10141: LD_EXP 33
10145: PUSH
10146: LD_VAR 0 6
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 8
10158: PPUSH
10159: CALL_OW 456
// p := p + 2 ;
10163: LD_ADDR_VAR 0 6
10167: PUSH
10168: LD_VAR 0 6
10172: PUSH
10173: LD_INT 2
10175: PLUS
10176: ST_TO_ADDR
// end ;
10177: GO 10048
10179: POP
10180: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10181: LD_INT 22
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 34
10193: PUSH
10194: LD_INT 32
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PPUSH
10205: CALL_OW 69
10209: IFFALSE 10323
// begin if l_cargo = false then
10211: LD_VAR 0 17
10215: PUSH
10216: LD_INT 0
10218: EQUAL
10219: IFFALSE 10255
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10221: LD_ADDR_VAR 0 17
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_INT 8
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 34
10238: PUSH
10239: LD_INT 32
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: ST_TO_ADDR
// if l_cargo then
10255: LD_VAR 0 17
10259: IFFALSE 10323
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10261: LD_ADDR_VAR 0 7
10265: PUSH
10266: LD_INT 14
10268: PPUSH
10269: CALL_OW 435
10273: ST_TO_ADDR
// if cr > 0 then
10274: LD_VAR 0 7
10278: PUSH
10279: LD_INT 0
10281: GREATER
10282: IFFALSE 10323
// if not HasTask ( l_cargo ) then
10284: LD_VAR 0 17
10288: PPUSH
10289: CALL_OW 314
10293: NOT
10294: IFFALSE 10323
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10296: LD_VAR 0 17
10300: PPUSH
10301: LD_VAR 0 7
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 2
10317: ARRAY
10318: PPUSH
10319: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10323: LD_OWVAR 1
10327: PUSH
10328: LD_INT 52500
10330: PUSH
10331: LD_INT 46200
10333: PUSH
10334: LD_INT 42000
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: LD_OWVAR 67
10346: ARRAY
10347: EQUAL
10348: PUSH
10349: LD_INT 1
10351: PPUSH
10352: CALL_OW 469
10356: PUSH
10357: LD_INT 1
10359: ARRAY
10360: PUSH
10361: LD_INT 112
10363: EQUAL
10364: AND
10365: PUSH
10366: LD_INT 1
10368: PPUSH
10369: CALL_OW 469
10373: PUSH
10374: LD_INT 2
10376: ARRAY
10377: PUSH
10378: LD_INT 67
10380: EQUAL
10381: AND
10382: IFFALSE 10475
// begin un := l_eng [ 1 ] ;
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_VAR 0 16
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: ST_TO_ADDR
// if IsInUnit ( un ) then
10398: LD_VAR 0 1
10402: PPUSH
10403: CALL_OW 310
10407: IFFALSE 10418
// ComExitBuilding ( un ) ;
10409: LD_VAR 0 1
10413: PPUSH
10414: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: LD_INT 1
10425: PPUSH
10426: CALL_OW 469
10430: PUSH
10431: LD_INT 1
10433: ARRAY
10434: PPUSH
10435: LD_INT 1
10437: PPUSH
10438: CALL_OW 469
10442: PUSH
10443: LD_INT 2
10445: ARRAY
10446: PPUSH
10447: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10451: LD_VAR 0 1
10455: PPUSH
10456: LD_INT 207
10458: PPUSH
10459: LD_INT 123
10461: PPUSH
10462: CALL_OW 171
// AddComUnload ( un ) ;
10466: LD_VAR 0 1
10470: PPUSH
10471: CALL_OW 219
// end ; end ;
10475: PPOPN 17
10477: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10478: LD_OWVAR 67
10482: PUSH
10483: LD_INT 1
10485: GREATER
10486: IFFALSE 10691
10488: GO 10490
10490: DISABLE
10491: LD_INT 0
10493: PPUSH
10494: PPUSH
10495: PPUSH
10496: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10497: LD_INT 35
10499: PPUSH
10500: LD_INT 12635
10502: PPUSH
10503: CALL_OW 12
10507: PPUSH
10508: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10512: LD_ADDR_VAR 0 2
10516: PUSH
10517: LD_INT 22
10519: PUSH
10520: LD_INT 8
10522: PUSH
10523: EMPTY
10524: LIST
10525: LIST
10526: PUSH
10527: LD_INT 25
10529: PUSH
10530: LD_INT 4
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PPUSH
10541: CALL_OW 69
10545: ST_TO_ADDR
// p := 1 ;
10546: LD_ADDR_VAR 0 4
10550: PUSH
10551: LD_INT 1
10553: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10554: LD_ADDR_VAR 0 3
10558: PUSH
10559: LD_INT 116
10561: PUSH
10562: LD_INT 139
10564: PUSH
10565: LD_INT 69
10567: PUSH
10568: LD_INT 13
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: ST_TO_ADDR
// for i = 1 to 2 do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: DOUBLE
10583: LD_INT 1
10585: DEC
10586: ST_TO_ADDR
10587: LD_INT 2
10589: PUSH
10590: FOR_TO
10591: IFFALSE 10689
// begin if IsInUnit ( sci [ i ] ) then
10593: LD_VAR 0 2
10597: PUSH
10598: LD_VAR 0 1
10602: ARRAY
10603: PPUSH
10604: CALL_OW 310
10608: IFFALSE 10625
// ComExitBuilding ( sci [ i ] ) ;
10610: LD_VAR 0 2
10614: PUSH
10615: LD_VAR 0 1
10619: ARRAY
10620: PPUSH
10621: CALL_OW 122
// Wait ( 0 0$03 ) ;
10625: LD_INT 105
10627: PPUSH
10628: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10632: LD_VAR 0 2
10636: PUSH
10637: LD_VAR 0 1
10641: ARRAY
10642: PPUSH
10643: LD_VAR 0 3
10647: PUSH
10648: LD_VAR 0 4
10652: ARRAY
10653: PPUSH
10654: LD_VAR 0 3
10658: PUSH
10659: LD_VAR 0 4
10663: PUSH
10664: LD_INT 1
10666: PLUS
10667: ARRAY
10668: PPUSH
10669: CALL_OW 158
// p := p + 2 ;
10673: LD_ADDR_VAR 0 4
10677: PUSH
10678: LD_VAR 0 4
10682: PUSH
10683: LD_INT 2
10685: PLUS
10686: ST_TO_ADDR
// end ;
10687: GO 10590
10689: POP
10690: POP
// end ;
10691: PPOPN 4
10693: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10694: LD_INT 14
10696: PPUSH
10697: CALL_OW 435
10701: PUSH
10702: LD_INT 20
10704: LESS
10705: IFFALSE 10732
10707: GO 10709
10709: DISABLE
// begin enable ;
10710: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10711: LD_INT 1
10713: PPUSH
10714: LD_INT 5
10716: PPUSH
10717: CALL_OW 12
10721: PPUSH
10722: LD_INT 14
10724: PPUSH
10725: LD_INT 1
10727: PPUSH
10728: CALL_OW 55
// end ; end_of_file
10732: END
// export function Action ; var un , gamemode , speaker ; begin
10733: LD_INT 0
10735: PPUSH
10736: PPUSH
10737: PPUSH
10738: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10739: LD_ADDR_OWVAR 67
10743: PUSH
10744: LD_INT 0
10746: PPUSH
10747: CALL_OW 426
10751: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: PPUSH
10760: CALL_OW 426
10764: ST_TO_ADDR
// if gamemode = 1 then
10765: LD_VAR 0 3
10769: PUSH
10770: LD_INT 1
10772: EQUAL
10773: IFFALSE 10797
// begin your_side := 1 ;
10775: LD_ADDR_OWVAR 2
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// legion_enemy := 1 ;
10783: LD_ADDR_EXP 36
10787: PUSH
10788: LD_INT 1
10790: ST_TO_ADDR
// PrepareAmerican ;
10791: CALL 221 0 0
// end else
10795: GO 10849
// if gamemode = 2 then
10797: LD_VAR 0 3
10801: PUSH
10802: LD_INT 2
10804: EQUAL
10805: IFFALSE 10829
// begin your_side := 2 ;
10807: LD_ADDR_OWVAR 2
10811: PUSH
10812: LD_INT 2
10814: ST_TO_ADDR
// legion_enemy := 2 ;
10815: LD_ADDR_EXP 36
10819: PUSH
10820: LD_INT 2
10822: ST_TO_ADDR
// PrepareArabian ;
10823: CALL 18138 0 0
// end else
10827: GO 10849
// begin your_side := 7 ;
10829: LD_ADDR_OWVAR 2
10833: PUSH
10834: LD_INT 7
10836: ST_TO_ADDR
// legion_enemy := 7 ;
10837: LD_ADDR_EXP 36
10841: PUSH
10842: LD_INT 7
10844: ST_TO_ADDR
// PrepareAlliance ;
10845: CALL 15549 0 0
// end ; if your_side = 1 then
10849: LD_OWVAR 2
10853: PUSH
10854: LD_INT 1
10856: EQUAL
10857: IFFALSE 11335
// begin case Query ( QVul4 ) of 1 :
10859: LD_STRING QVul4
10861: PPUSH
10862: CALL_OW 97
10866: PUSH
10867: LD_INT 1
10869: DOUBLE
10870: EQUAL
10871: IFTRUE 10875
10873: GO 10878
10875: POP
// ; end ;
10876: GO 10879
10878: POP
// InGameOn ;
10879: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10883: LD_INT 8
10885: PPUSH
10886: LD_INT 5
10888: PPUSH
10889: CALL_OW 86
// uc_side := 4 ;
10893: LD_ADDR_OWVAR 20
10897: PUSH
10898: LD_INT 4
10900: ST_TO_ADDR
// uc_nation := 1 ;
10901: LD_ADDR_OWVAR 21
10905: PUSH
10906: LD_INT 1
10908: ST_TO_ADDR
// hc_importance := 0 ;
10909: LD_ADDR_OWVAR 32
10913: PUSH
10914: LD_INT 0
10916: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10917: LD_INT 1
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_EXP 21
10927: PPUSH
10928: CALL_OW 380
// un := CreateHuman ;
10932: LD_ADDR_VAR 0 2
10936: PUSH
10937: CALL_OW 44
10941: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10942: LD_VAR 0 2
10946: PPUSH
10947: LD_INT 12
10949: PPUSH
10950: LD_INT 9
10952: PPUSH
10953: LD_INT 0
10955: PPUSH
10956: CALL_OW 48
// hc_name := Stuart Carey ;
10960: LD_ADDR_OWVAR 26
10964: PUSH
10965: LD_STRING Stuart Carey
10967: ST_TO_ADDR
// hc_class := 1 ;
10968: LD_ADDR_OWVAR 28
10972: PUSH
10973: LD_INT 1
10975: ST_TO_ADDR
// hc_gallery := vulcano ;
10976: LD_ADDR_OWVAR 33
10980: PUSH
10981: LD_STRING vulcano
10983: ST_TO_ADDR
// hc_face_number := 1 ;
10984: LD_ADDR_OWVAR 34
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// us_guy := CreateHuman ;
10992: LD_ADDR_EXP 22
10996: PUSH
10997: CALL_OW 44
11001: ST_TO_ADDR
// InitHc ;
11002: CALL_OW 19
// if rand ( 0 , 1 ) then
11006: LD_INT 0
11008: PPUSH
11009: LD_INT 1
11011: PPUSH
11012: CALL_OW 12
11016: IFFALSE 11033
// PrepareHuman ( sex_male , 3 , 6 ) else
11018: LD_INT 1
11020: PPUSH
11021: LD_INT 3
11023: PPUSH
11024: LD_INT 6
11026: PPUSH
11027: CALL_OW 380
11031: GO 11046
// PrepareHuman ( sex_female , 4 , 8 ) ;
11033: LD_INT 2
11035: PPUSH
11036: LD_INT 4
11038: PPUSH
11039: LD_INT 8
11041: PPUSH
11042: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_EXP 19
11055: PPUSH
11056: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11060: LD_EXP 19
11064: PPUSH
11065: LD_VAR 0 2
11069: PPUSH
11070: CALL_OW 119
// if GetSex ( un ) = sex_male then
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 258
11083: PUSH
11084: LD_INT 1
11086: EQUAL
11087: IFFALSE 11170
// begin Say ( un , VD-un1 ) ;
11089: LD_VAR 0 2
11093: PPUSH
11094: LD_STRING VD-un1
11096: PPUSH
11097: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11101: LD_EXP 19
11105: PPUSH
11106: LD_STRING VDc-1
11108: PPUSH
11109: CALL_OW 88
// Say ( un , VD-un2 ) ;
11113: LD_VAR 0 2
11117: PPUSH
11118: LD_STRING VD-un2
11120: PPUSH
11121: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11125: LD_EXP 19
11129: PPUSH
11130: LD_STRING VDc-2
11132: PPUSH
11133: CALL_OW 88
// Say ( un , VD-un3 ) ;
11137: LD_VAR 0 2
11141: PPUSH
11142: LD_STRING VD-un3
11144: PPUSH
11145: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11149: LD_INT 7
11151: PPUSH
11152: CALL_OW 67
// Say ( un , VD-un4 ) ;
11156: LD_VAR 0 2
11160: PPUSH
11161: LD_STRING VD-un4
11163: PPUSH
11164: CALL_OW 88
// end else
11168: GO 11249
// begin Say ( un , VD-unf1 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_STRING VD-unf1
11177: PPUSH
11178: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11182: LD_EXP 19
11186: PPUSH
11187: LD_STRING VDc-1
11189: PPUSH
11190: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11194: LD_VAR 0 2
11198: PPUSH
11199: LD_STRING VD-unf2
11201: PPUSH
11202: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11206: LD_EXP 19
11210: PPUSH
11211: LD_STRING VDc-2
11213: PPUSH
11214: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11218: LD_VAR 0 2
11222: PPUSH
11223: LD_STRING VD-unf3
11225: PPUSH
11226: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11230: LD_INT 7
11232: PPUSH
11233: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11237: LD_VAR 0 2
11241: PPUSH
11242: LD_STRING VD-unf4
11244: PPUSH
11245: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11249: LD_VAR 0 2
11253: PPUSH
11254: LD_INT 2
11256: PPUSH
11257: LD_INT 2
11259: PPUSH
11260: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11264: LD_EXP 19
11268: PPUSH
11269: LD_STRING VDc-3
11271: PPUSH
11272: CALL_OW 88
// InGameOff ;
11276: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11280: LD_STRING CVulc1
11282: PPUSH
11283: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11287: LD_INT 35
11289: PPUSH
11290: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11294: LD_VAR 0 2
11298: PPUSH
11299: CALL_OW 250
11303: PUSH
11304: LD_INT 2
11306: EQUAL
11307: PUSH
11308: LD_VAR 0 2
11312: PPUSH
11313: CALL_OW 251
11317: PUSH
11318: LD_INT 2
11320: EQUAL
11321: AND
11322: IFFALSE 11287
// RemoveUnit ( un ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: CALL_OW 64
// end else
11333: GO 11712
// if your_side = 2 then
11335: LD_OWVAR 2
11339: PUSH
11340: LD_INT 2
11342: EQUAL
11343: IFFALSE 11559
// begin CenterNowOnUnits ( player_commander ) ;
11345: LD_EXP 10
11349: PPUSH
11350: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11354: LD_ADDR_VAR 0 4
11358: PUSH
11359: LD_INT 22
11361: PUSH
11362: LD_INT 2
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PUSH
11369: LD_INT 21
11371: PUSH
11372: LD_INT 1
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PPUSH
11383: CALL_OW 69
11387: PUSH
11388: LD_EXP 51
11392: DIFF
11393: ST_TO_ADDR
// if speaker then
11394: LD_VAR 0 4
11398: IFFALSE 11550
// begin InGameOn ;
11400: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11404: LD_EXP 51
11408: PPUSH
11409: LD_STRING VSd-1
11411: PPUSH
11412: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11416: LD_VAR 0 4
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: CALL_OW 258
11429: PUSH
11430: LD_INT 1
11432: EQUAL
11433: IFFALSE 11453
// Say ( speaker [ 1 ] , VAd-1 ) else
11435: LD_VAR 0 4
11439: PUSH
11440: LD_INT 1
11442: ARRAY
11443: PPUSH
11444: LD_STRING VAd-1
11446: PPUSH
11447: CALL_OW 88
11451: GO 11469
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11453: LD_VAR 0 4
11457: PUSH
11458: LD_INT 1
11460: ARRAY
11461: PPUSH
11462: LD_STRING VAfd-1
11464: PPUSH
11465: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11469: LD_EXP 51
11473: PPUSH
11474: LD_STRING VSd-2
11476: PPUSH
11477: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11481: LD_VAR 0 4
11485: PUSH
11486: LD_INT 1
11488: ARRAY
11489: PPUSH
11490: CALL_OW 258
11494: PUSH
11495: LD_INT 1
11497: EQUAL
11498: IFFALSE 11518
// Say ( speaker [ 1 ] , VAd-2 ) else
11500: LD_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ARRAY
11508: PPUSH
11509: LD_STRING VAd-2
11511: PPUSH
11512: CALL_OW 88
11516: GO 11534
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11518: LD_VAR 0 4
11522: PUSH
11523: LD_INT 1
11525: ARRAY
11526: PPUSH
11527: LD_STRING VAfd-2
11529: PPUSH
11530: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11534: LD_EXP 51
11538: PPUSH
11539: LD_STRING VSd-3
11541: PPUSH
11542: CALL_OW 88
// InGameOff ;
11546: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11550: LD_STRING CVulc5
11552: PPUSH
11553: CALL_OW 337
// end else
11557: GO 11712
// if your_side = 7 then
11559: LD_OWVAR 2
11563: PUSH
11564: LD_INT 7
11566: EQUAL
11567: IFFALSE 11712
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11569: LD_ADDR_VAR 0 4
11573: PUSH
11574: LD_INT 22
11576: PUSH
11577: LD_INT 7
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 21
11586: PUSH
11587: LD_INT 1
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PPUSH
11598: CALL_OW 69
11602: PUSH
11603: LD_EXP 37
11607: DIFF
11608: ST_TO_ADDR
// if speaker then
11609: LD_VAR 0 4
11613: IFFALSE 11705
// begin CenterNowOnUnits ( al_commander ) ;
11615: LD_EXP 37
11619: PPUSH
11620: CALL_OW 87
// InGameOn ;
11624: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11628: LD_EXP 37
11632: PPUSH
11633: LD_STRING VPd-1
11635: PPUSH
11636: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11640: LD_VAR 0 4
11644: PUSH
11645: LD_INT 1
11647: ARRAY
11648: PPUSH
11649: CALL_OW 258
11653: IFFALSE 11673
// Say ( speaker [ 1 ] , VPpd-1 ) else
11655: LD_VAR 0 4
11659: PUSH
11660: LD_INT 1
11662: ARRAY
11663: PPUSH
11664: LD_STRING VPpd-1
11666: PPUSH
11667: CALL_OW 88
11671: GO 11689
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11673: LD_VAR 0 4
11677: PUSH
11678: LD_INT 1
11680: ARRAY
11681: PPUSH
11682: LD_STRING VPpdf-1
11684: PPUSH
11685: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11689: LD_EXP 37
11693: PPUSH
11694: LD_STRING VPd-2
11696: PPUSH
11697: CALL_OW 88
// InGameOff ;
11701: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11705: LD_STRING CVulc7
11707: PPUSH
11708: CALL_OW 337
// end ; SaveForQuickRestart ;
11712: CALL_OW 22
// end ;
11716: LD_VAR 0 1
11720: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11721: LD_INT 22
11723: PUSH
11724: LD_INT 2
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: LD_INT 30
11733: PUSH
11734: LD_INT 3
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PPUSH
11745: CALL_OW 69
11749: IFFALSE 11793
11751: GO 11753
11753: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11754: LD_STRING CVulc6
11756: PPUSH
11757: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11761: LD_INT 52500
11763: PUSH
11764: LD_INT 47250
11766: PUSH
11767: LD_INT 42000
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_OWVAR 67
11779: ARRAY
11780: PPUSH
11781: CALL_OW 67
// ru_can_attack := true ;
11785: LD_ADDR_EXP 3
11789: PUSH
11790: LD_INT 1
11792: ST_TO_ADDR
// end ;
11793: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11794: LD_INT 50
11796: PPUSH
11797: CALL_OW 255
11801: PUSH
11802: LD_INT 1
11804: EQUAL
11805: PUSH
11806: LD_INT 22
11808: PUSH
11809: LD_INT 1
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: LD_INT 30
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 30
11831: PUSH
11832: LD_INT 1
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: CALL_OW 69
11852: OR
11853: IFFALSE 12087
11855: GO 11857
11857: DISABLE
11858: LD_INT 0
11860: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11861: LD_STRING CVulc2
11863: PPUSH
11864: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11868: LD_ADDR_VAR 0 1
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_INT 1
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 25
11885: PUSH
11886: LD_INT 2
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PPUSH
11897: CALL_OW 69
11901: PUSH
11902: LD_EXP 19
11906: DIFF
11907: ST_TO_ADDR
// DialogueOn ;
11908: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11912: LD_INT 10
11914: PPUSH
11915: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11919: LD_VAR 0 1
11923: PUSH
11924: LD_INT 1
11926: ARRAY
11927: PPUSH
11928: CALL_OW 258
11932: PUSH
11933: LD_INT 1
11935: EQUAL
11936: IFFALSE 11956
// Say ( speaker [ 1 ] , VDb-1 ) else
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 1
11945: ARRAY
11946: PPUSH
11947: LD_STRING VDb-1
11949: PPUSH
11950: CALL_OW 88
11954: GO 11972
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11956: LD_VAR 0 1
11960: PUSH
11961: LD_INT 1
11963: ARRAY
11964: PPUSH
11965: LD_STRING VDbf-1
11967: PPUSH
11968: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11972: LD_INT 10
11974: PPUSH
11975: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11979: LD_VAR 0 1
11983: PUSH
11984: LD_INT 1
11986: ARRAY
11987: PPUSH
11988: CALL_OW 258
11992: PUSH
11993: LD_INT 1
11995: EQUAL
11996: IFFALSE 12016
// Say ( speaker [ 1 ] , VDb-2 ) else
11998: LD_VAR 0 1
12002: PUSH
12003: LD_INT 1
12005: ARRAY
12006: PPUSH
12007: LD_STRING VDb-2
12009: PPUSH
12010: CALL_OW 88
12014: GO 12032
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12016: LD_VAR 0 1
12020: PUSH
12021: LD_INT 1
12023: ARRAY
12024: PPUSH
12025: LD_STRING VDbf-2
12027: PPUSH
12028: CALL_OW 88
// DWait ( 0 0$01 ) ;
12032: LD_INT 35
12034: PPUSH
12035: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12039: LD_EXP 19
12043: PPUSH
12044: LD_STRING VDb-com1
12046: PPUSH
12047: CALL_OW 88
// DialogueOff ;
12051: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12055: LD_INT 44100
12057: PUSH
12058: LD_INT 36750
12060: PUSH
12061: LD_INT 31500
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: PUSH
12069: LD_OWVAR 67
12073: ARRAY
12074: PPUSH
12075: CALL_OW 67
// ru_can_attack := true ;
12079: LD_ADDR_EXP 3
12083: PUSH
12084: LD_INT 1
12086: ST_TO_ADDR
// end ;
12087: PPOPN 1
12089: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12090: LD_INT 22
12092: PUSH
12093: LD_INT 7
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 30
12102: PUSH
12103: LD_INT 3
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: IFFALSE 12155
12120: GO 12122
12122: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12123: LD_INT 42000
12125: PUSH
12126: LD_INT 34650
12128: PUSH
12129: LD_INT 29400
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: LIST
12136: PUSH
12137: LD_OWVAR 67
12141: ARRAY
12142: PPUSH
12143: CALL_OW 67
// ru_can_attack := true ;
12147: LD_ADDR_EXP 3
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// end ;
12155: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12156: LD_INT 58
12158: PPUSH
12159: CALL_OW 255
12163: PUSH
12164: LD_INT 1
12166: EQUAL
12167: IFFALSE 12374
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12175: LD_ADDR_VAR 0 1
12179: PUSH
12180: LD_INT 22
12182: PUSH
12183: LD_INT 1
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 25
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PPUSH
12204: CALL_OW 69
12208: ST_TO_ADDR
// DialogueOn ;
12209: CALL_OW 6
// if speaker then
12213: LD_VAR 0 1
12217: IFFALSE 12272
// if GetSex ( speaker [ 1 ] ) = sex_male then
12219: LD_VAR 0 1
12223: PUSH
12224: LD_INT 1
12226: ARRAY
12227: PPUSH
12228: CALL_OW 258
12232: PUSH
12233: LD_INT 1
12235: EQUAL
12236: IFFALSE 12256
// Say ( speaker [ 1 ] , VDe-1 ) else
12238: LD_VAR 0 1
12242: PUSH
12243: LD_INT 1
12245: ARRAY
12246: PPUSH
12247: LD_STRING VDe-1
12249: PPUSH
12250: CALL_OW 88
12254: GO 12272
// Say ( speaker [ 1 ] , VDef-1 ) ;
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 1
12263: ARRAY
12264: PPUSH
12265: LD_STRING VDef-1
12267: PPUSH
12268: CALL_OW 88
// case Query ( SibNote ) of 1 :
12272: LD_STRING SibNote
12274: PPUSH
12275: CALL_OW 97
12279: PUSH
12280: LD_INT 1
12282: DOUBLE
12283: EQUAL
12284: IFTRUE 12288
12286: GO 12291
12288: POP
// ; end ;
12289: GO 12292
12291: POP
// if speaker then
12292: LD_VAR 0 1
12296: IFFALSE 12351
// if GetSex ( speaker [ 1 ] ) = sex_male then
12298: LD_VAR 0 1
12302: PUSH
12303: LD_INT 1
12305: ARRAY
12306: PPUSH
12307: CALL_OW 258
12311: PUSH
12312: LD_INT 1
12314: EQUAL
12315: IFFALSE 12335
// Say ( speaker [ 1 ] , VDe-2 ) else
12317: LD_VAR 0 1
12321: PUSH
12322: LD_INT 1
12324: ARRAY
12325: PPUSH
12326: LD_STRING VDe-2
12328: PPUSH
12329: CALL_OW 88
12333: GO 12351
// Say ( speaker [ 1 ] , VDef-2 ) ;
12335: LD_VAR 0 1
12339: PUSH
12340: LD_INT 1
12342: ARRAY
12343: PPUSH
12344: LD_STRING VDef-2
12346: PPUSH
12347: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12351: LD_EXP 19
12355: PPUSH
12356: LD_STRING VDc-4
12358: PPUSH
12359: CALL_OW 88
// DialogueOff ;
12363: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12367: LD_STRING CVulc3
12369: PPUSH
12370: CALL_OW 337
// end ;
12374: PPOPN 1
12376: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12377: LD_OWVAR 2
12381: PUSH
12382: LD_INT 1
12384: EQUAL
12385: PUSH
12386: LD_INT 22
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PUSH
12396: LD_INT 30
12398: PUSH
12399: LD_INT 3
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PUSH
12406: EMPTY
12407: LIST
12408: LIST
12409: PPUSH
12410: CALL_OW 69
12414: PUSH
12415: LD_INT 0
12417: GREATER
12418: AND
12419: IFFALSE 12853
12421: GO 12423
12423: DISABLE
12424: LD_INT 0
12426: PPUSH
12427: PPUSH
12428: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12429: LD_INT 245
12431: PPUSH
12432: LD_INT 1295
12434: PPUSH
12435: CALL_OW 12
12439: PPUSH
12440: CALL_OW 67
// DialogueOn ;
12444: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12448: LD_EXP 22
12452: PPUSH
12453: LD_STRING VDG-1
12455: PPUSH
12456: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12460: LD_EXP 19
12464: PPUSH
12465: LD_STRING VDc-5
12467: PPUSH
12468: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12472: LD_EXP 22
12476: PPUSH
12477: LD_STRING VDG-2
12479: PPUSH
12480: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12484: LD_EXP 19
12488: PPUSH
12489: LD_STRING VDc-6
12491: PPUSH
12492: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12496: LD_EXP 22
12500: PPUSH
12501: LD_STRING VDG-3
12503: PPUSH
12504: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12508: LD_EXP 19
12512: PPUSH
12513: LD_STRING VDc-7
12515: PPUSH
12516: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12520: LD_EXP 22
12524: PPUSH
12525: LD_STRING VDG-4
12527: PPUSH
12528: CALL_OW 94
// DialogueOff ;
12532: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12536: LD_STRING CVulc4
12538: PPUSH
12539: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12543: LD_INT 18900
12545: PUSH
12546: LD_INT 21000
12548: PUSH
12549: LD_INT 23100
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PUSH
12557: LD_OWVAR 67
12561: ARRAY
12562: PPUSH
12563: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12567: LD_ADDR_VAR 0 1
12571: PUSH
12572: DOUBLE
12573: LD_INT 1
12575: DEC
12576: ST_TO_ADDR
12577: LD_INT 4
12579: PUSH
12580: LD_INT 5
12582: PUSH
12583: LD_INT 6
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: LD_OWVAR 67
12595: ARRAY
12596: PUSH
12597: FOR_TO
12598: IFFALSE 12842
// begin uc_side := 1 ;
12600: LD_ADDR_OWVAR 20
12604: PUSH
12605: LD_INT 1
12607: ST_TO_ADDR
// uc_nation := 1 ;
12608: LD_ADDR_OWVAR 21
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12616: LD_INT 0
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: LD_INT 4
12624: PPUSH
12625: CALL_OW 12
12629: PPUSH
12630: LD_EXP 21
12634: PPUSH
12635: CALL_OW 380
// un := CreateHuman ;
12639: LD_ADDR_VAR 0 2
12643: PUSH
12644: CALL_OW 44
12648: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12649: LD_VAR 0 2
12653: PPUSH
12654: LD_INT 2
12656: PPUSH
12657: CALL_OW 233
// if GetClass ( un ) = 3 then
12661: LD_VAR 0 2
12665: PPUSH
12666: CALL_OW 257
12670: PUSH
12671: LD_INT 3
12673: EQUAL
12674: IFFALSE 12825
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12676: LD_ADDR_OWVAR 37
12680: PUSH
12681: LD_INT 2
12683: PUSH
12684: LD_INT 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: LD_VAR 0 1
12695: PUSH
12696: LD_INT 2
12698: MOD
12699: ARRAY
12700: ST_TO_ADDR
// vc_engine := engine_combustion ;
12701: LD_ADDR_OWVAR 39
12705: PUSH
12706: LD_INT 1
12708: ST_TO_ADDR
// vc_control := control_manual ;
12709: LD_ADDR_OWVAR 38
12713: PUSH
12714: LD_INT 1
12716: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12717: LD_ADDR_OWVAR 40
12721: PUSH
12722: LD_INT 9
12724: PUSH
12725: LD_INT 9
12727: PUSH
12728: LD_INT 5
12730: PUSH
12731: LD_INT 11
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 1
12742: PPUSH
12743: LD_INT 4
12745: PPUSH
12746: CALL_OW 12
12750: ARRAY
12751: ST_TO_ADDR
// veh := CreateVehicle ;
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: CALL_OW 45
12761: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12762: LD_VAR 0 3
12766: PPUSH
12767: LD_INT 2
12769: PPUSH
12770: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12774: LD_VAR 0 3
12778: PPUSH
12779: LD_INT 77
12781: PPUSH
12782: LD_INT 88
12784: PPUSH
12785: CALL_OW 12
12789: PPUSH
12790: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12794: LD_VAR 0 3
12798: PPUSH
12799: LD_INT 1
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: CALL_OW 52
// end else
12823: GO 12840
// PlaceUnitArea ( un , start_north , false ) ;
12825: LD_VAR 0 2
12829: PPUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 49
// end ;
12840: GO 12597
12842: POP
12843: POP
// CenterNowOnUnits ( un ) ;
12844: LD_VAR 0 2
12848: PPUSH
12849: CALL_OW 87
// end ;
12853: PPOPN 3
12855: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12856: LD_INT 21
12858: PPUSH
12859: LD_INT 22
12861: PUSH
12862: LD_OWVAR 2
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PPUSH
12871: CALL_OW 70
12875: IFFALSE 13196
12877: GO 12879
12879: DISABLE
12880: LD_INT 0
12882: PPUSH
12883: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12884: LD_ADDR_VAR 0 2
12888: PUSH
12889: LD_INT 22
12891: PUSH
12892: LD_OWVAR 2
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PUSH
12901: LD_INT 2
12903: PUSH
12904: LD_INT 25
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 25
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 25
12936: PUSH
12937: LD_INT 4
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PPUSH
12955: CALL_OW 69
12959: PUSH
12960: LD_EXP 10
12964: DIFF
12965: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12966: LD_ADDR_VAR 0 1
12970: PUSH
12971: LD_VAR 0 2
12975: PPUSH
12976: LD_INT 112
12978: PPUSH
12979: LD_INT 67
12981: PPUSH
12982: CALL_OW 73
12986: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12987: LD_VAR 0 1
12991: PPUSH
12992: CALL_OW 255
12996: PUSH
12997: LD_INT 7
12999: EQUAL
13000: IFFALSE 13043
// if GetSex ( un ) = sex_male then
13002: LD_VAR 0 1
13006: PPUSH
13007: CALL_OW 258
13011: PUSH
13012: LD_INT 1
13014: EQUAL
13015: IFFALSE 13031
// Say ( un , VD-find-al ) else
13017: LD_VAR 0 1
13021: PPUSH
13022: LD_STRING VD-find-al
13024: PPUSH
13025: CALL_OW 88
13029: GO 13043
// Say ( un , VD-find-al-f ) ;
13031: LD_VAR 0 1
13035: PPUSH
13036: LD_STRING VD-find-al-f
13038: PPUSH
13039: CALL_OW 88
// if GetSide ( un ) = 2 then
13043: LD_VAR 0 1
13047: PPUSH
13048: CALL_OW 255
13052: PUSH
13053: LD_INT 2
13055: EQUAL
13056: IFFALSE 13099
// if GetSex ( un ) = sex_male then
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL_OW 258
13067: PUSH
13068: LD_INT 1
13070: EQUAL
13071: IFFALSE 13087
// Say ( un , VD-find-ar ) else
13073: LD_VAR 0 1
13077: PPUSH
13078: LD_STRING VD-find-ar
13080: PPUSH
13081: CALL_OW 88
13085: GO 13099
// Say ( un , VD-find-ar-f ) ;
13087: LD_VAR 0 1
13091: PPUSH
13092: LD_STRING VD-find-ar-f
13094: PPUSH
13095: CALL_OW 88
// if GetSide ( un ) = 1 then
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 255
13108: PUSH
13109: LD_INT 1
13111: EQUAL
13112: IFFALSE 13179
// begin if GetSex ( un ) = sex_male then
13114: LD_VAR 0 1
13118: PPUSH
13119: CALL_OW 258
13123: PUSH
13124: LD_INT 1
13126: EQUAL
13127: IFFALSE 13155
// begin Say ( un , VD-find-us ) ;
13129: LD_VAR 0 1
13133: PPUSH
13134: LD_STRING VD-find-us
13136: PPUSH
13137: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_STRING VD-find-us2
13148: PPUSH
13149: CALL_OW 88
// end else
13153: GO 13179
// begin Say ( un , VD-find-us-f ) ;
13155: LD_VAR 0 1
13159: PPUSH
13160: LD_STRING VD-find-us-f
13162: PPUSH
13163: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13167: LD_VAR 0 1
13171: PPUSH
13172: LD_STRING VD-find-us2-f
13174: PPUSH
13175: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13179: LD_INT 10
13181: PPUSH
13182: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13186: LD_INT 112
13188: PPUSH
13189: LD_INT 67
13191: PPUSH
13192: CALL_OW 86
// end ;
13196: PPOPN 2
13198: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13199: LD_EXP 7
13203: IFFALSE 13705
13205: GO 13207
13207: DISABLE
13208: LD_INT 0
13210: PPUSH
// begin if your_side = 1 then
13211: LD_OWVAR 2
13215: PUSH
13216: LD_INT 1
13218: EQUAL
13219: IFFALSE 13400
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13221: LD_ADDR_VAR 0 1
13225: PUSH
13226: LD_INT 22
13228: PUSH
13229: LD_INT 1
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: PUSH
13236: LD_INT 25
13238: PUSH
13239: LD_INT 4
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PPUSH
13250: CALL_OW 69
13254: PUSH
13255: LD_EXP 19
13259: DIFF
13260: ST_TO_ADDR
// if not speaker then
13261: LD_VAR 0 1
13265: NOT
13266: IFFALSE 13270
// exit ;
13268: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13270: LD_VAR 0 1
13274: PUSH
13275: LD_INT 1
13277: ARRAY
13278: PPUSH
13279: CALL_OW 258
13283: PUSH
13284: LD_INT 1
13286: EQUAL
13287: IFFALSE 13307
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13289: LD_VAR 0 1
13293: PUSH
13294: LD_INT 1
13296: ARRAY
13297: PPUSH
13298: LD_STRING VD-us-sci-art-1
13300: PPUSH
13301: CALL_OW 88
13305: GO 13323
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13307: LD_VAR 0 1
13311: PUSH
13312: LD_INT 1
13314: ARRAY
13315: PPUSH
13316: LD_STRING VD-us-fsci-art-1
13318: PPUSH
13319: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13323: LD_EXP 19
13327: PPUSH
13328: LD_STRING VDc-art1
13330: PPUSH
13331: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13335: LD_VAR 0 1
13339: PUSH
13340: LD_INT 1
13342: ARRAY
13343: PPUSH
13344: CALL_OW 258
13348: PUSH
13349: LD_INT 1
13351: EQUAL
13352: IFFALSE 13372
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13354: LD_VAR 0 1
13358: PUSH
13359: LD_INT 1
13361: ARRAY
13362: PPUSH
13363: LD_STRING VD-us-sci-art-2
13365: PPUSH
13366: CALL_OW 88
13370: GO 13388
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13372: LD_VAR 0 1
13376: PUSH
13377: LD_INT 1
13379: ARRAY
13380: PPUSH
13381: LD_STRING VD-us-fsci-art-2
13383: PPUSH
13384: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13388: LD_EXP 19
13392: PPUSH
13393: LD_STRING VDc-art2
13395: PPUSH
13396: CALL_OW 88
// end ; if your_side = 2 then
13400: LD_OWVAR 2
13404: PUSH
13405: LD_INT 2
13407: EQUAL
13408: IFFALSE 13512
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13410: LD_ADDR_VAR 0 1
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_INT 2
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: LD_INT 25
13427: PUSH
13428: LD_INT 4
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: LD_EXP 51
13448: DIFF
13449: ST_TO_ADDR
// if not speaker then
13450: LD_VAR 0 1
13454: NOT
13455: IFFALSE 13459
// exit ;
13457: GO 13705
// if GetSex ( speaker [ 1 ] ) = sex_male then
13459: LD_VAR 0 1
13463: PUSH
13464: LD_INT 1
13466: ARRAY
13467: PPUSH
13468: CALL_OW 258
13472: PUSH
13473: LD_INT 1
13475: EQUAL
13476: IFFALSE 13496
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13478: LD_VAR 0 1
13482: PUSH
13483: LD_INT 1
13485: ARRAY
13486: PPUSH
13487: LD_STRING VD-ar-sci-art-1
13489: PPUSH
13490: CALL_OW 88
13494: GO 13512
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13496: LD_VAR 0 1
13500: PUSH
13501: LD_INT 1
13503: ARRAY
13504: PPUSH
13505: LD_STRING VD-ar-fsci-art-1
13507: PPUSH
13508: CALL_OW 88
// end ; if your_side = 7 then
13512: LD_OWVAR 2
13516: PUSH
13517: LD_INT 7
13519: EQUAL
13520: IFFALSE 13705
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13522: LD_ADDR_VAR 0 1
13526: PUSH
13527: LD_INT 22
13529: PUSH
13530: LD_INT 7
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PUSH
13537: LD_INT 25
13539: PUSH
13540: LD_INT 4
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PPUSH
13551: CALL_OW 69
13555: PUSH
13556: LD_EXP 37
13560: DIFF
13561: ST_TO_ADDR
// if speaker then
13562: LD_VAR 0 1
13566: IFFALSE 13698
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13568: LD_VAR 0 1
13572: PUSH
13573: LD_INT 1
13575: ARRAY
13576: PPUSH
13577: CALL_OW 258
13581: PUSH
13582: LD_INT 1
13584: EQUAL
13585: IFFALSE 13605
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13587: LD_VAR 0 1
13591: PUSH
13592: LD_INT 1
13594: ARRAY
13595: PPUSH
13596: LD_STRING VD-al-sci-art-1
13598: PPUSH
13599: CALL_OW 88
13603: GO 13621
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13605: LD_VAR 0 1
13609: PUSH
13610: LD_INT 1
13612: ARRAY
13613: PPUSH
13614: LD_STRING VD-al-fsci-art-1
13616: PPUSH
13617: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13621: LD_EXP 37
13625: PPUSH
13626: LD_STRING VPd-art-1
13628: PPUSH
13629: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13633: LD_VAR 0 1
13637: PUSH
13638: LD_INT 1
13640: ARRAY
13641: PPUSH
13642: CALL_OW 258
13646: PUSH
13647: LD_INT 1
13649: EQUAL
13650: IFFALSE 13670
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13652: LD_VAR 0 1
13656: PUSH
13657: LD_INT 1
13659: ARRAY
13660: PPUSH
13661: LD_STRING VD-al-sci-art-2
13663: PPUSH
13664: CALL_OW 88
13668: GO 13686
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13670: LD_VAR 0 1
13674: PUSH
13675: LD_INT 1
13677: ARRAY
13678: PPUSH
13679: LD_STRING VD-al-fsci-art-2
13681: PPUSH
13682: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13686: LD_EXP 37
13690: PPUSH
13691: LD_STRING VPd-art-2
13693: PPUSH
13694: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13698: LD_STRING CVulc7out
13700: PPUSH
13701: CALL_OW 337
// end ; end ;
13705: PPOPN 1
13707: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13708: LD_INT 8
13710: PPUSH
13711: LD_INT 22
13713: PUSH
13714: LD_OWVAR 2
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PPUSH
13723: CALL_OW 69
13727: PPUSH
13728: LD_INT 8
13730: PPUSH
13731: CALL 2145 0 2
13735: PPUSH
13736: CALL_OW 292
13740: IFFALSE 13883
13742: GO 13744
13744: DISABLE
13745: LD_INT 0
13747: PPUSH
// begin if your_side = 1 then
13748: LD_OWVAR 2
13752: PUSH
13753: LD_INT 1
13755: EQUAL
13756: IFFALSE 13839
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_INT 22
13765: PUSH
13766: LD_INT 1
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PPUSH
13773: CALL_OW 69
13777: PUSH
13778: LD_EXP 19
13782: DIFF
13783: ST_TO_ADDR
// if speaker then
13784: LD_VAR 0 1
13788: IFFALSE 13839
// if GetSex ( speaker [ 1 ] ) then
13790: LD_VAR 0 1
13794: PUSH
13795: LD_INT 1
13797: ARRAY
13798: PPUSH
13799: CALL_OW 258
13803: IFFALSE 13823
// Say ( speaker [ 1 ] , VD-legion-us ) else
13805: LD_VAR 0 1
13809: PUSH
13810: LD_INT 1
13812: ARRAY
13813: PPUSH
13814: LD_STRING VD-legion-us
13816: PPUSH
13817: CALL_OW 88
13821: GO 13839
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13823: LD_VAR 0 1
13827: PUSH
13828: LD_INT 1
13830: ARRAY
13831: PPUSH
13832: LD_STRING VD-legion-us-f
13834: PPUSH
13835: CALL_OW 88
// end ; if your_side = 2 then
13839: LD_OWVAR 2
13843: PUSH
13844: LD_INT 2
13846: EQUAL
13847: IFFALSE 13861
// Say ( ar_commander , VD-legion-ar ) ;
13849: LD_EXP 51
13853: PPUSH
13854: LD_STRING VD-legion-ar
13856: PPUSH
13857: CALL_OW 88
// if your_side = 7 then
13861: LD_OWVAR 2
13865: PUSH
13866: LD_INT 7
13868: EQUAL
13869: IFFALSE 13883
// Say ( al_commander , VD-legion-al ) ;
13871: LD_EXP 37
13875: PPUSH
13876: LD_STRING VD-legion-al
13878: PPUSH
13879: CALL_OW 88
// end ;
13883: PPOPN 1
13885: END
// every 0 0$01 trigger mine_vulc do
13886: LD_EXP 12
13890: IFFALSE 13907
13892: GO 13894
13894: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13895: LD_EXP 10
13899: PPUSH
13900: LD_STRING VD-vulc-mines
13902: PPUSH
13903: CALL_OW 88
// end ;
13907: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13908: LD_OWVAR 67
13912: PUSH
13913: LD_INT 1
13915: GREATER
13916: IFFALSE 14035
13918: GO 13920
13920: DISABLE
13921: LD_INT 0
13923: PPUSH
13924: PPUSH
13925: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13926: LD_ADDR_VAR 0 1
13930: PUSH
13931: LD_INT 123
13933: PUSH
13934: LD_INT 95
13936: PUSH
13937: LD_INT 119
13939: PUSH
13940: LD_INT 89
13942: PUSH
13943: LD_INT 115
13945: PUSH
13946: LD_INT 81
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: ST_TO_ADDR
// p := 1 ;
13957: LD_ADDR_VAR 0 2
13961: PUSH
13962: LD_INT 1
13964: ST_TO_ADDR
// for i = 1 to 3 do
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: DOUBLE
13971: LD_INT 1
13973: DEC
13974: ST_TO_ADDR
13975: LD_INT 3
13977: PUSH
13978: FOR_TO
13979: IFFALSE 14033
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13981: LD_VAR 0 1
13985: PUSH
13986: LD_VAR 0 2
13990: ARRAY
13991: PPUSH
13992: LD_VAR 0 1
13996: PUSH
13997: LD_VAR 0 2
14001: PUSH
14002: LD_INT 1
14004: PLUS
14005: ARRAY
14006: PPUSH
14007: LD_INT 8
14009: PPUSH
14010: LD_INT 0
14012: PPUSH
14013: CALL_OW 454
// p := p + 2 ;
14017: LD_ADDR_VAR 0 2
14021: PUSH
14022: LD_VAR 0 2
14026: PUSH
14027: LD_INT 2
14029: PLUS
14030: ST_TO_ADDR
// end ;
14031: GO 13978
14033: POP
14034: POP
// end ;
14035: PPOPN 3
14037: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14038: LD_OWVAR 67
14042: PUSH
14043: LD_INT 1
14045: GREATER
14046: PUSH
14047: LD_INT 22
14049: PPUSH
14050: LD_INT 22
14052: PUSH
14053: LD_OWVAR 2
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PPUSH
14062: CALL_OW 70
14066: AND
14067: IFFALSE 14271
14069: GO 14071
14071: DISABLE
14072: LD_INT 0
14074: PPUSH
14075: PPUSH
14076: PPUSH
// begin enable ;
14077: ENABLE
// p := 1 ;
14078: LD_ADDR_VAR 0 1
14082: PUSH
14083: LD_INT 1
14085: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14086: LD_ADDR_VAR 0 3
14090: PUSH
14091: LD_INT 123
14093: PUSH
14094: LD_INT 95
14096: PUSH
14097: LD_INT 119
14099: PUSH
14100: LD_INT 89
14102: PUSH
14103: LD_INT 115
14105: PUSH
14106: LD_INT 81
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: ST_TO_ADDR
// for i = 1 to 3 do
14117: LD_ADDR_VAR 0 2
14121: PUSH
14122: DOUBLE
14123: LD_INT 1
14125: DEC
14126: ST_TO_ADDR
14127: LD_INT 3
14129: PUSH
14130: FOR_TO
14131: IFFALSE 14269
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14133: LD_VAR 0 3
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: PPUSH
14144: LD_VAR 0 3
14148: PUSH
14149: LD_VAR 0 1
14153: PUSH
14154: LD_INT 1
14156: PLUS
14157: ARRAY
14158: PPUSH
14159: CALL_OW 428
14163: PUSH
14164: LD_INT 0
14166: GREATER
14167: IFFALSE 14253
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14169: LD_VAR 0 3
14173: PUSH
14174: LD_VAR 0 1
14178: ARRAY
14179: PPUSH
14180: LD_VAR 0 3
14184: PUSH
14185: LD_VAR 0 1
14189: PUSH
14190: LD_INT 1
14192: PLUS
14193: ARRAY
14194: PPUSH
14195: CALL_OW 428
14199: PPUSH
14200: CALL_OW 255
14204: PUSH
14205: LD_OWVAR 2
14209: EQUAL
14210: IFFALSE 14253
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14212: LD_VAR 0 3
14216: PUSH
14217: LD_VAR 0 1
14221: ARRAY
14222: PPUSH
14223: LD_VAR 0 3
14227: PUSH
14228: LD_VAR 0 1
14232: PUSH
14233: LD_INT 1
14235: PLUS
14236: ARRAY
14237: PPUSH
14238: LD_INT 8
14240: PPUSH
14241: CALL_OW 456
// mine_vulc := true ;
14245: LD_ADDR_EXP 12
14249: PUSH
14250: LD_INT 1
14252: ST_TO_ADDR
// end ; p := p + 2 ;
14253: LD_ADDR_VAR 0 1
14257: PUSH
14258: LD_VAR 0 1
14262: PUSH
14263: LD_INT 2
14265: PLUS
14266: ST_TO_ADDR
// end ;
14267: GO 14130
14269: POP
14270: POP
// end ;
14271: PPOPN 3
14273: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14274: LD_INT 22
14276: PUSH
14277: LD_INT 3
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 69
14288: PUSH
14289: LD_INT 0
14291: EQUAL
14292: PUSH
14293: LD_OWVAR 2
14297: PUSH
14298: LD_INT 2
14300: NONEQUAL
14301: AND
14302: IFFALSE 14311
14304: GO 14306
14306: DISABLE
// Win ;
14307: CALL 14368 0 0
14311: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14312: LD_INT 2
14314: PUSH
14315: LD_INT 22
14317: PUSH
14318: LD_INT 8
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 22
14327: PUSH
14328: LD_INT 3
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 69
14344: PUSH
14345: LD_INT 0
14347: EQUAL
14348: PUSH
14349: LD_OWVAR 2
14353: PUSH
14354: LD_INT 2
14356: EQUAL
14357: AND
14358: IFFALSE 14367
14360: GO 14362
14362: DISABLE
// Win ;
14363: CALL 14368 0 0
14367: END
// function Win ; var points ; begin
14368: LD_INT 0
14370: PPUSH
14371: PPUSH
// case Query ( VulcWin ) of 1 :
14372: LD_STRING VulcWin
14374: PPUSH
14375: CALL_OW 97
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14391
14388: POP
// ; end ;
14389: GO 14392
14391: POP
// if medal_enabled then
14392: LD_EXP 13
14396: IFFALSE 14410
// AddMedal ( vulc_1 , 1 ) else
14398: LD_STRING vulc_1
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 101
14408: GO 14421
// AddMedal ( vulc_1 , - 1 ) ;
14410: LD_STRING vulc_1
14412: PPUSH
14413: LD_INT 1
14415: NEG
14416: PPUSH
14417: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14421: LD_INT 22
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PPUSH
14431: CALL_OW 69
14435: PUSH
14436: LD_INT 0
14438: EQUAL
14439: IFFALSE 14453
// AddMedal ( vulc_2 , 1 ) else
14441: LD_STRING vulc_2
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: CALL_OW 101
14451: GO 14464
// AddMedal ( vulc_2 , - 1 ) ;
14453: LD_STRING vulc_2
14455: PPUSH
14456: LD_INT 1
14458: NEG
14459: PPUSH
14460: CALL_OW 101
// points := CalculateCommanderPoints ;
14464: LD_ADDR_VAR 0 2
14468: PUSH
14469: CALL 2266 0 0
14473: ST_TO_ADDR
// if points >= 2000 then
14474: LD_VAR 0 2
14478: PUSH
14479: LD_INT 2000
14481: GREATEREQUAL
14482: IFFALSE 14496
// AddMedal ( vulc_3 , 2 ) else
14484: LD_STRING vulc_3
14486: PPUSH
14487: LD_INT 2
14489: PPUSH
14490: CALL_OW 101
14494: GO 14529
// if points >= 0 then
14496: LD_VAR 0 2
14500: PUSH
14501: LD_INT 0
14503: GREATEREQUAL
14504: IFFALSE 14518
// AddMedal ( vulc_3 , 1 ) else
14506: LD_STRING vulc_3
14508: PPUSH
14509: LD_INT 1
14511: PPUSH
14512: CALL_OW 101
14516: GO 14529
// AddMedal ( vulc_3 , - 1 ) ;
14518: LD_STRING vulc_3
14520: PPUSH
14521: LD_INT 1
14523: NEG
14524: PPUSH
14525: CALL_OW 101
// GiveMedals ( MAIN ) ;
14529: LD_STRING MAIN
14531: PPUSH
14532: CALL_OW 102
// YouWin ;
14536: CALL_OW 103
// end ; end_of_file
14540: LD_VAR 0 1
14544: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14545: LD_INT 13
14547: PPUSH
14548: LD_INT 21
14550: PUSH
14551: LD_INT 1
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 70
14562: PUSH
14563: LD_INT 0
14565: GREATER
14566: IFFALSE 14633
14568: GO 14570
14570: DISABLE
14571: LD_INT 0
14573: PPUSH
14574: PPUSH
// begin enable ;
14575: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14576: LD_ADDR_VAR 0 1
14580: PUSH
14581: LD_INT 13
14583: PPUSH
14584: LD_INT 21
14586: PUSH
14587: LD_INT 1
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PPUSH
14594: CALL_OW 70
14598: PUSH
14599: FOR_IN
14600: IFFALSE 14631
// if GetLives ( i ) > 4 then
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 256
14611: PUSH
14612: LD_INT 4
14614: GREATER
14615: IFFALSE 14629
// SetLives ( i , 4 ) ;
14617: LD_VAR 0 1
14621: PPUSH
14622: LD_INT 4
14624: PPUSH
14625: CALL_OW 234
14629: GO 14599
14631: POP
14632: POP
// end ;
14633: PPOPN 2
14635: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14636: LD_VAR 0 1
14640: PPUSH
14641: CALL_OW 255
14645: PUSH
14646: LD_OWVAR 2
14650: EQUAL
14651: IFFALSE 14661
// player_res_art := true ;
14653: LD_ADDR_EXP 6
14657: PUSH
14658: LD_INT 1
14660: ST_TO_ADDR
// end ;
14661: PPOPN 1
14663: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14664: LD_INT 22
14666: PUSH
14667: LD_OWVAR 2
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 2
14678: PUSH
14679: LD_INT 30
14681: PUSH
14682: LD_INT 8
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PUSH
14689: LD_INT 30
14691: PUSH
14692: LD_INT 11
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: LIST
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: PUSH
14713: LD_EXP 6
14717: AND
14718: IFFALSE 15062
14720: GO 14722
14722: DISABLE
14723: LD_INT 0
14725: PPUSH
14726: PPUSH
14727: PPUSH
// begin enable ;
14728: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14729: LD_ADDR_VAR 0 1
14733: PUSH
14734: LD_INT 1
14736: PPUSH
14737: CALL_OW 469
14741: PUSH
14742: LD_INT 1
14744: ARRAY
14745: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14746: LD_ADDR_VAR 0 2
14750: PUSH
14751: LD_INT 1
14753: PPUSH
14754: CALL_OW 469
14758: PUSH
14759: LD_INT 2
14761: ARRAY
14762: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14763: LD_ADDR_VAR 0 3
14767: PUSH
14768: LD_INT 22
14770: PUSH
14771: LD_OWVAR 2
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: LD_INT 2
14782: PUSH
14783: LD_INT 30
14785: PUSH
14786: LD_INT 8
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 30
14795: PUSH
14796: LD_INT 11
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: LIST
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PPUSH
14812: CALL_OW 69
14816: PPUSH
14817: LD_VAR 0 1
14821: PPUSH
14822: LD_VAR 0 2
14826: PPUSH
14827: CALL_OW 73
14831: ST_TO_ADDR
// if player_artifact_ready = false then
14832: LD_EXP 7
14836: PUSH
14837: LD_INT 0
14839: EQUAL
14840: IFFALSE 14946
// if GetDistUnitXY ( lab , x , y ) < 6 then
14842: LD_VAR 0 3
14846: PPUSH
14847: LD_VAR 0 1
14851: PPUSH
14852: LD_VAR 0 2
14856: PPUSH
14857: CALL_OW 297
14861: PUSH
14862: LD_INT 6
14864: LESS
14865: IFFALSE 14926
// begin if BuildingStatus ( lab ) = bs_idle then
14867: LD_VAR 0 3
14871: PPUSH
14872: CALL_OW 461
14876: PUSH
14877: LD_INT 2
14879: EQUAL
14880: IFFALSE 14904
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14882: LD_OWVAR 2
14886: PPUSH
14887: LD_INT 1
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: LD_VAR 0 3
14897: PPUSH
14898: CALL_OW 468
14902: GO 14924
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14904: LD_OWVAR 2
14908: PPUSH
14909: LD_INT 1
14911: PPUSH
14912: LD_INT 1
14914: PPUSH
14915: LD_VAR 0 3
14919: PPUSH
14920: CALL_OW 468
// end else
14924: GO 14946
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14926: LD_OWVAR 2
14930: PPUSH
14931: LD_INT 1
14933: PPUSH
14934: LD_INT 1
14936: PPUSH
14937: LD_VAR 0 3
14941: PPUSH
14942: CALL_OW 468
// if player_artifact_ready then
14946: LD_EXP 7
14950: IFFALSE 15062
// if GetDistUnitXY ( lab , x , y ) < 6 then
14952: LD_VAR 0 3
14956: PPUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_VAR 0 2
14966: PPUSH
14967: CALL_OW 297
14971: PUSH
14972: LD_INT 6
14974: LESS
14975: IFFALSE 15040
// begin if BuildingStatus ( lab ) = bs_idle then
14977: LD_VAR 0 3
14981: PPUSH
14982: CALL_OW 461
14986: PUSH
14987: LD_INT 2
14989: EQUAL
14990: IFFALSE 15016
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14992: LD_OWVAR 2
14996: PPUSH
14997: LD_EXP 8
15001: PPUSH
15002: LD_INT 4
15004: PPUSH
15005: LD_VAR 0 3
15009: PPUSH
15010: CALL_OW 468
15014: GO 15038
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15016: LD_OWVAR 2
15020: PPUSH
15021: LD_EXP 8
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: LD_VAR 0 3
15033: PPUSH
15034: CALL_OW 468
// end else
15038: GO 15062
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15040: LD_OWVAR 2
15044: PPUSH
15045: LD_EXP 8
15049: PPUSH
15050: LD_INT 1
15052: PPUSH
15053: LD_VAR 0 3
15057: PPUSH
15058: CALL_OW 468
// end ;
15062: PPOPN 3
15064: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15065: LD_INT 0
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15072: LD_ADDR_VAR 0 5
15076: PUSH
15077: LD_INT 1
15079: PPUSH
15080: CALL_OW 469
15084: PUSH
15085: LD_INT 1
15087: ARRAY
15088: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15089: LD_ADDR_VAR 0 6
15093: PUSH
15094: LD_INT 1
15096: PPUSH
15097: CALL_OW 469
15101: PUSH
15102: LD_INT 2
15104: ARRAY
15105: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15106: LD_ADDR_VAR 0 8
15110: PUSH
15111: LD_INT 22
15113: PUSH
15114: LD_OWVAR 2
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PUSH
15123: LD_INT 2
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: LD_INT 8
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: PUSH
15136: LD_INT 30
15138: PUSH
15139: LD_INT 11
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: LIST
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PPUSH
15155: CALL_OW 69
15159: PPUSH
15160: LD_VAR 0 5
15164: PPUSH
15165: LD_VAR 0 6
15169: PPUSH
15170: CALL_OW 73
15174: ST_TO_ADDR
// if icon = art_exp_left then
15175: LD_VAR 0 2
15179: PUSH
15180: LD_INT 1
15182: EQUAL
15183: IFFALSE 15222
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15185: LD_VAR 0 8
15189: PPUSH
15190: LD_EXP 9
15194: PPUSH
15195: LD_INT 1
15197: PPUSH
15198: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15202: LD_OWVAR 2
15206: PPUSH
15207: LD_INT 1
15209: PPUSH
15210: LD_INT 0
15212: PPUSH
15213: LD_VAR 0 8
15217: PPUSH
15218: CALL_OW 468
// end ; if icon = art_icon then
15222: LD_VAR 0 2
15226: PUSH
15227: LD_EXP 8
15231: EQUAL
15232: IFFALSE 15446
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15234: LD_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 3
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: PPUSH
15249: CALL_OW 69
15253: IN
15254: IFFALSE 15446
// begin side := GetSide ( cr1 ) ;
15256: LD_ADDR_VAR 0 9
15260: PUSH
15261: LD_VAR 0 3
15265: PPUSH
15266: CALL_OW 255
15270: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15271: LD_INT 22
15273: PUSH
15274: LD_VAR 0 9
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: PUSH
15283: LD_INT 30
15285: PUSH
15286: LD_INT 28
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: CALL_OW 69
15301: PUSH
15302: LD_INT 0
15304: GREATER
15305: IFFALSE 15446
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_INT 22
15314: PUSH
15315: LD_VAR 0 9
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 2
15326: PUSH
15327: LD_INT 30
15329: PUSH
15330: LD_INT 26
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 30
15339: PUSH
15340: LD_INT 27
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 30
15349: PUSH
15350: LD_INT 28
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PPUSH
15367: CALL_OW 69
15371: PUSH
15372: FOR_IN
15373: IFFALSE 15389
// SetLives ( i , 1 ) ;
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 234
15387: GO 15372
15389: POP
15390: POP
// player_res_art := false ;
15391: LD_ADDR_EXP 6
15395: PUSH
15396: LD_INT 0
15398: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15399: LD_OWVAR 2
15403: PPUSH
15404: LD_EXP 8
15408: PPUSH
15409: LD_INT 1
15411: PPUSH
15412: LD_VAR 0 8
15416: PPUSH
15417: CALL_OW 468
// Wait ( time_to_reuse ) ;
15421: LD_EXP 11
15425: PPUSH
15426: CALL_OW 67
// player_res_art := true ;
15430: LD_ADDR_EXP 6
15434: PUSH
15435: LD_INT 1
15437: ST_TO_ADDR
// medal_enabled := true ;
15438: LD_ADDR_EXP 13
15442: PUSH
15443: LD_INT 1
15445: ST_TO_ADDR
// end ; end ; end ; end ;
15446: PPOPN 9
15448: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15449: LD_VAR 0 1
15453: PPUSH
15454: CALL_OW 255
15458: PUSH
15459: LD_OWVAR 2
15463: EQUAL
15464: IFFALSE 15501
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15466: LD_OWVAR 2
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: LD_VAR 0 1
15481: PPUSH
15482: CALL_OW 468
// player_artifact_ready := true ;
15486: LD_ADDR_EXP 7
15490: PUSH
15491: LD_INT 1
15493: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15494: LD_STRING ArtVulcano
15496: PPUSH
15497: CALL_OW 339
// end ; end ;
15501: PPOPN 1
15503: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15504: LD_OWVAR 2
15508: PPUSH
15509: LD_INT 1
15511: PPUSH
15512: LD_INT 2
15514: PPUSH
15515: LD_VAR 0 1
15519: PPUSH
15520: CALL_OW 468
// end ; end_of_file
15524: PPOPN 2
15526: END
// every 0 0$01 do
15527: GO 15529
15529: DISABLE
// begin enable ;
15530: ENABLE
// Display_Strings := [ #tick , tick ] ;
15531: LD_ADDR_OWVAR 47
15535: PUSH
15536: LD_STRING #tick
15538: PUSH
15539: LD_OWVAR 1
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: ST_TO_ADDR
// end ; end_of_file
15548: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15549: LD_INT 0
15551: PPUSH
15552: PPUSH
15553: PPUSH
15554: PPUSH
15555: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15556: LD_ADDR_EXP 39
15560: PUSH
15561: LD_INT 7
15563: PUSH
15564: LD_INT 6
15566: PUSH
15567: LD_INT 5
15569: PUSH
15570: EMPTY
15571: LIST
15572: LIST
15573: LIST
15574: PUSH
15575: LD_OWVAR 67
15579: ARRAY
15580: ST_TO_ADDR
// al_force := [ ] ;
15581: LD_ADDR_EXP 38
15585: PUSH
15586: EMPTY
15587: ST_TO_ADDR
// RemoveAlliance ;
15588: CALL 15966 0 0
// ResetFog ;
15592: CALL_OW 335
// your_side := 7 ;
15596: LD_ADDR_OWVAR 2
15600: PUSH
15601: LD_INT 7
15603: ST_TO_ADDR
// uc_side := 7 ;
15604: LD_ADDR_OWVAR 20
15608: PUSH
15609: LD_INT 7
15611: ST_TO_ADDR
// hc_gallery :=  ;
15612: LD_ADDR_OWVAR 33
15616: PUSH
15617: LD_STRING 
15619: ST_TO_ADDR
// hc_name :=  ;
15620: LD_ADDR_OWVAR 26
15624: PUSH
15625: LD_STRING 
15627: ST_TO_ADDR
// hc_importance := 0 ;
15628: LD_ADDR_OWVAR 32
15632: PUSH
15633: LD_INT 0
15635: ST_TO_ADDR
// for i = 1 to 17 do
15636: LD_ADDR_VAR 0 2
15640: PUSH
15641: DOUBLE
15642: LD_INT 1
15644: DEC
15645: ST_TO_ADDR
15646: LD_INT 17
15648: PUSH
15649: FOR_TO
15650: IFFALSE 15730
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15652: LD_ADDR_OWVAR 21
15656: PUSH
15657: LD_INT 1
15659: PUSH
15660: LD_INT 3
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: PUSH
15667: LD_INT 1
15669: PPUSH
15670: LD_INT 2
15672: PPUSH
15673: CALL_OW 12
15677: ARRAY
15678: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15679: LD_INT 0
15681: PPUSH
15682: LD_INT 1
15684: PPUSH
15685: LD_INT 4
15687: PPUSH
15688: CALL_OW 12
15692: PPUSH
15693: LD_EXP 39
15697: PPUSH
15698: CALL_OW 380
// un := CreateHuman ;
15702: LD_ADDR_VAR 0 4
15706: PUSH
15707: CALL_OW 44
15711: ST_TO_ADDR
// al_force := al_force ^ un ;
15712: LD_ADDR_EXP 38
15716: PUSH
15717: LD_EXP 38
15721: PUSH
15722: LD_VAR 0 4
15726: ADD
15727: ST_TO_ADDR
// end ;
15728: GO 15649
15730: POP
15731: POP
// hc_importance := 100 ;
15732: LD_ADDR_OWVAR 32
15736: PUSH
15737: LD_INT 100
15739: ST_TO_ADDR
// uc_nation := 1 ;
15740: LD_ADDR_OWVAR 21
15744: PUSH
15745: LD_INT 1
15747: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 1
15753: PPUSH
15754: LD_EXP 39
15758: PPUSH
15759: CALL_OW 380
// al_commander := CreateHuman ;
15763: LD_ADDR_EXP 37
15767: PUSH
15768: CALL_OW 44
15772: ST_TO_ADDR
// player_commander := al_commander ;
15773: LD_ADDR_EXP 10
15777: PUSH
15778: LD_EXP 37
15782: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15783: LD_ADDR_VAR 0 5
15787: PUSH
15788: LD_STRING text
15790: PPUSH
15791: LD_INT 9
15793: PUSH
15794: LD_INT 9
15796: PUSH
15797: LD_INT 8
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: LIST
15804: PUSH
15805: LD_OWVAR 67
15809: ARRAY
15810: PPUSH
15811: LD_INT 9
15813: PUSH
15814: LD_INT 9
15816: PUSH
15817: LD_INT 8
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: LIST
15824: PUSH
15825: LD_OWVAR 67
15829: ARRAY
15830: PPUSH
15831: LD_INT -5
15833: PUSH
15834: LD_EXP 37
15838: PUSH
15839: LD_INT -3
15841: PUSH
15842: LD_INT -2
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: LIST
15849: LIST
15850: PUSH
15851: LD_EXP 38
15855: ADD
15856: PPUSH
15857: LD_INT 1
15859: PUSH
15860: LD_INT 3
15862: PUSH
15863: LD_INT 2
15865: PUSH
15866: LD_INT 1
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: PUSH
15873: LD_INT 4
15875: PUSH
15876: LD_INT 1
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: LD_INT 9
15885: PUSH
15886: LD_INT 5
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 42
15901: ST_TO_ADDR
// team := team ^ al_commander ;
15902: LD_ADDR_VAR 0 5
15906: PUSH
15907: LD_VAR 0 5
15911: PUSH
15912: LD_EXP 37
15916: ADD
15917: ST_TO_ADDR
// for i = 1 to team do
15918: LD_ADDR_VAR 0 2
15922: PUSH
15923: DOUBLE
15924: LD_INT 1
15926: DEC
15927: ST_TO_ADDR
15928: LD_VAR 0 5
15932: PUSH
15933: FOR_TO
15934: IFFALSE 15959
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15936: LD_VAR 0 5
15940: PUSH
15941: LD_VAR 0 2
15945: ARRAY
15946: PPUSH
15947: LD_INT 15
15949: PPUSH
15950: LD_INT 0
15952: PPUSH
15953: CALL_OW 49
15957: GO 15933
15959: POP
15960: POP
// end ;
15961: LD_VAR 0 1
15965: RET
// export function RemoveAlliance ; var i ; begin
15966: LD_INT 0
15968: PPUSH
15969: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15970: LD_INT 22
15972: PUSH
15973: LD_INT 7
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PUSH
15980: LD_INT 30
15982: PUSH
15983: LD_INT 1
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 69
15998: PUSH
15999: LD_INT 1
16001: ARRAY
16002: PPUSH
16003: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_INT 22
16014: PUSH
16015: LD_INT 7
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PPUSH
16022: CALL_OW 69
16026: PUSH
16027: FOR_IN
16028: IFFALSE 16041
// RemoveUnit ( i ) ;
16030: LD_VAR 0 2
16034: PPUSH
16035: CALL_OW 64
16039: GO 16027
16041: POP
16042: POP
// end ;
16043: LD_VAR 0 1
16047: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16048: LD_INT 0
16050: PPUSH
16051: PPUSH
16052: PPUSH
16053: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16054: LD_INT 31
16056: PPUSH
16057: LD_INT 7
16059: PPUSH
16060: LD_INT 2
16062: PPUSH
16063: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16067: LD_INT 32
16069: PPUSH
16070: LD_INT 7
16072: PPUSH
16073: LD_INT 2
16075: PPUSH
16076: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16080: LD_INT 59
16082: PPUSH
16083: LD_INT 7
16085: PPUSH
16086: LD_INT 2
16088: PPUSH
16089: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16093: LD_ADDR_EXP 39
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 6
16103: PUSH
16104: LD_INT 7
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: LD_OWVAR 67
16116: ARRAY
16117: ST_TO_ADDR
// al_force := [ ] ;
16118: LD_ADDR_EXP 38
16122: PUSH
16123: EMPTY
16124: ST_TO_ADDR
// al_vehs := [ ] ;
16125: LD_ADDR_EXP 44
16129: PUSH
16130: EMPTY
16131: ST_TO_ADDR
// uc_side := 7 ;
16132: LD_ADDR_OWVAR 20
16136: PUSH
16137: LD_INT 7
16139: ST_TO_ADDR
// uc_nation := 1 ;
16140: LD_ADDR_OWVAR 21
16144: PUSH
16145: LD_INT 1
16147: ST_TO_ADDR
// bc_type := b_oil_mine ;
16148: LD_ADDR_OWVAR 42
16152: PUSH
16153: LD_INT 29
16155: ST_TO_ADDR
// b := CreateBuilding ;
16156: LD_ADDR_VAR 0 4
16160: PUSH
16161: CALL_OW 46
16165: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16166: LD_VAR 0 4
16170: PPUSH
16171: LD_INT 61
16173: PPUSH
16174: LD_INT 7
16176: PPUSH
16177: LD_INT 0
16179: PPUSH
16180: LD_INT 0
16182: PPUSH
16183: CALL_OW 50
// bc_type := b_siberite_mine ;
16187: LD_ADDR_OWVAR 42
16191: PUSH
16192: LD_INT 30
16194: ST_TO_ADDR
// b := CreateBuilding ;
16195: LD_ADDR_VAR 0 4
16199: PUSH
16200: CALL_OW 46
16204: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16205: LD_VAR 0 4
16209: PPUSH
16210: LD_INT 69
16212: PPUSH
16213: LD_INT 13
16215: PPUSH
16216: LD_INT 0
16218: PPUSH
16219: LD_INT 0
16221: PPUSH
16222: CALL_OW 50
// hc_gallery :=  ;
16226: LD_ADDR_OWVAR 33
16230: PUSH
16231: LD_STRING 
16233: ST_TO_ADDR
// hc_name :=  ;
16234: LD_ADDR_OWVAR 26
16238: PUSH
16239: LD_STRING 
16241: ST_TO_ADDR
// hc_importance := 0 ;
16242: LD_ADDR_OWVAR 32
16246: PUSH
16247: LD_INT 0
16249: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16250: LD_ADDR_VAR 0 2
16254: PUSH
16255: LD_INT 22
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: LD_INT 30
16267: PUSH
16268: LD_INT 32
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: PUSH
16284: FOR_IN
16285: IFFALSE 16355
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16287: LD_ADDR_OWVAR 21
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: LD_INT 3
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 1
16304: PPUSH
16305: LD_INT 2
16307: PPUSH
16308: CALL_OW 12
16312: ARRAY
16313: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16314: LD_INT 0
16316: PPUSH
16317: LD_INT 1
16319: PPUSH
16320: LD_EXP 39
16324: PPUSH
16325: CALL_OW 380
// un := CreateHuman ;
16329: LD_ADDR_VAR 0 3
16333: PUSH
16334: CALL_OW 44
16338: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16339: LD_VAR 0 3
16343: PPUSH
16344: LD_VAR 0 2
16348: PPUSH
16349: CALL_OW 52
// end ;
16353: GO 16284
16355: POP
16356: POP
// for i = 1 to 3 do
16357: LD_ADDR_VAR 0 2
16361: PUSH
16362: DOUBLE
16363: LD_INT 1
16365: DEC
16366: ST_TO_ADDR
16367: LD_INT 3
16369: PUSH
16370: FOR_TO
16371: IFFALSE 16439
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16373: LD_ADDR_OWVAR 21
16377: PUSH
16378: LD_INT 1
16380: PUSH
16381: LD_INT 3
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_INT 2
16393: PPUSH
16394: CALL_OW 12
16398: ARRAY
16399: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16400: LD_INT 0
16402: PPUSH
16403: LD_INT 4
16405: PPUSH
16406: LD_EXP 39
16410: PPUSH
16411: CALL_OW 380
// un := CreateHuman ;
16415: LD_ADDR_VAR 0 3
16419: PUSH
16420: CALL_OW 44
16424: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: LD_INT 164
16432: PPUSH
16433: CALL_OW 52
// end ;
16437: GO 16370
16439: POP
16440: POP
// for i = 1 to 6 do
16441: LD_ADDR_VAR 0 2
16445: PUSH
16446: DOUBLE
16447: LD_INT 1
16449: DEC
16450: ST_TO_ADDR
16451: LD_INT 6
16453: PUSH
16454: FOR_TO
16455: IFFALSE 16546
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16457: LD_ADDR_OWVAR 21
16461: PUSH
16462: LD_INT 1
16464: PUSH
16465: LD_INT 3
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 1
16474: PPUSH
16475: LD_INT 2
16477: PPUSH
16478: CALL_OW 12
16482: ARRAY
16483: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16484: LD_INT 0
16486: PPUSH
16487: LD_INT 5
16489: PUSH
16490: LD_INT 9
16492: PUSH
16493: LD_INT 9
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 1
16503: PPUSH
16504: LD_INT 3
16506: PPUSH
16507: CALL_OW 12
16511: ARRAY
16512: PPUSH
16513: LD_EXP 39
16517: PPUSH
16518: CALL_OW 380
// un := CreateHuman ;
16522: LD_ADDR_VAR 0 3
16526: PUSH
16527: CALL_OW 44
16531: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16532: LD_VAR 0 3
16536: PPUSH
16537: LD_INT 173
16539: PPUSH
16540: CALL_OW 52
// end ;
16544: GO 16454
16546: POP
16547: POP
// for i = 1 to 6 do
16548: LD_ADDR_VAR 0 2
16552: PUSH
16553: DOUBLE
16554: LD_INT 1
16556: DEC
16557: ST_TO_ADDR
16558: LD_INT 6
16560: PUSH
16561: FOR_TO
16562: IFFALSE 16660
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16564: LD_ADDR_OWVAR 21
16568: PUSH
16569: LD_INT 1
16571: PUSH
16572: LD_INT 3
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 1
16581: PPUSH
16582: LD_INT 2
16584: PPUSH
16585: CALL_OW 12
16589: ARRAY
16590: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16591: LD_INT 0
16593: PPUSH
16594: LD_INT 3
16596: PPUSH
16597: LD_EXP 39
16601: PPUSH
16602: CALL_OW 380
// un := CreateHuman ;
16606: LD_ADDR_VAR 0 3
16610: PUSH
16611: CALL_OW 44
16615: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16616: LD_VAR 0 3
16620: PPUSH
16621: LD_INT 22
16623: PUSH
16624: LD_INT 7
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: LD_INT 30
16633: PUSH
16634: LD_INT 3
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL_OW 69
16649: PUSH
16650: LD_INT 1
16652: ARRAY
16653: PPUSH
16654: CALL_OW 52
// end ;
16658: GO 16561
16660: POP
16661: POP
// for i = 1 to 4 do
16662: LD_ADDR_VAR 0 2
16666: PUSH
16667: DOUBLE
16668: LD_INT 1
16670: DEC
16671: ST_TO_ADDR
16672: LD_INT 4
16674: PUSH
16675: FOR_TO
16676: IFFALSE 16744
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16678: LD_ADDR_OWVAR 21
16682: PUSH
16683: LD_INT 1
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 1
16695: PPUSH
16696: LD_INT 2
16698: PPUSH
16699: CALL_OW 12
16703: ARRAY
16704: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16705: LD_INT 0
16707: PPUSH
16708: LD_INT 2
16710: PPUSH
16711: LD_EXP 39
16715: PPUSH
16716: CALL_OW 380
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 3
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16730: LD_VAR 0 3
16734: PPUSH
16735: LD_INT 162
16737: PPUSH
16738: CALL_OW 52
// end ;
16742: GO 16675
16744: POP
16745: POP
// uc_nation := 3 ;
16746: LD_ADDR_OWVAR 21
16750: PUSH
16751: LD_INT 3
16753: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16754: LD_ADDR_OWVAR 37
16758: PUSH
16759: LD_INT 21
16761: ST_TO_ADDR
// vc_engine := engine_siberite ;
16762: LD_ADDR_OWVAR 39
16766: PUSH
16767: LD_INT 3
16769: ST_TO_ADDR
// vc_control := control_computer ;
16770: LD_ADDR_OWVAR 38
16774: PUSH
16775: LD_INT 3
16777: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16778: LD_ADDR_OWVAR 40
16782: PUSH
16783: LD_INT 51
16785: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16786: CALL_OW 45
16790: PPUSH
16791: LD_INT 49
16793: PPUSH
16794: LD_INT 13
16796: PPUSH
16797: LD_INT 0
16799: PPUSH
16800: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16804: LD_ADDR_EXP 46
16808: PUSH
16809: LD_INT 22
16811: PUSH
16812: LD_INT 7
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: LD_INT 30
16821: PUSH
16822: LD_INT 33
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 69
16837: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: DOUBLE
16844: LD_INT 1
16846: DEC
16847: ST_TO_ADDR
16848: LD_INT 22
16850: PUSH
16851: LD_INT 7
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 30
16860: PUSH
16861: LD_INT 33
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PUSH
16868: LD_INT 35
16870: PUSH
16871: LD_INT 0
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: PUSH
16883: EMPTY
16884: LIST
16885: PPUSH
16886: CALL_OW 69
16890: PUSH
16891: FOR_TO
16892: IFFALSE 16952
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16894: LD_INT 22
16896: PUSH
16897: LD_INT 7
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: LD_INT 30
16906: PUSH
16907: LD_INT 33
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: PUSH
16914: LD_INT 35
16916: PUSH
16917: LD_INT 0
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: LIST
16928: PUSH
16929: EMPTY
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_VAR 0 2
16941: ARRAY
16942: PPUSH
16943: LD_INT 49
16945: PPUSH
16946: CALL_OW 208
16950: GO 16891
16952: POP
16953: POP
// end ;
16954: LD_VAR 0 1
16958: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16959: LD_OWVAR 2
16963: PUSH
16964: LD_INT 1
16966: EQUAL
16967: IFFALSE 18135
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
16976: PPUSH
16977: PPUSH
// begin enable ;
16978: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16979: LD_ADDR_EXP 50
16983: PUSH
16984: LD_INT 22
16986: PUSH
16987: LD_INT 7
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 21
16996: PUSH
16997: LD_INT 3
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PPUSH
17008: CALL_OW 69
17012: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17013: LD_ADDR_EXP 48
17017: PUSH
17018: LD_INT 164
17020: PUSH
17021: LD_INT 197
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17028: LD_ADDR_EXP 47
17032: PUSH
17033: LD_INT 22
17035: PUSH
17036: LD_INT 7
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 30
17045: PUSH
17046: LD_INT 1
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PUSH
17053: EMPTY
17054: LIST
17055: LIST
17056: PPUSH
17057: CALL_OW 69
17061: PUSH
17062: LD_INT 1
17064: ARRAY
17065: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17066: LD_ADDR_EXP 49
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 7
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 30
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17104: LD_INT 22
17106: PUSH
17107: LD_INT 7
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: LD_INT 34
17116: PUSH
17117: LD_INT 51
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PPUSH
17128: CALL_OW 69
17132: IFFALSE 17172
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17134: LD_ADDR_EXP 45
17138: PUSH
17139: LD_INT 22
17141: PUSH
17142: LD_INT 7
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 34
17151: PUSH
17152: LD_INT 51
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PPUSH
17163: CALL_OW 69
17167: PUSH
17168: LD_INT 1
17170: ARRAY
17171: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17172: LD_ADDR_EXP 41
17176: PUSH
17177: LD_INT 22
17179: PUSH
17180: LD_INT 7
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 9
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PPUSH
17201: CALL_OW 69
17205: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17206: LD_ADDR_EXP 40
17210: PUSH
17211: LD_INT 22
17213: PUSH
17214: LD_INT 7
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: LD_INT 25
17223: PUSH
17224: LD_INT 2
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PPUSH
17235: CALL_OW 69
17239: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17240: LD_ADDR_EXP 42
17244: PUSH
17245: LD_INT 22
17247: PUSH
17248: LD_INT 7
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: LD_INT 25
17257: PUSH
17258: LD_INT 3
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17274: LD_ADDR_EXP 43
17278: PUSH
17279: LD_INT 22
17281: PUSH
17282: LD_INT 7
17284: PUSH
17285: EMPTY
17286: LIST
17287: LIST
17288: PUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PPUSH
17303: CALL_OW 69
17307: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17308: LD_EXP 41
17312: PPUSH
17313: LD_INT 81
17315: PUSH
17316: LD_INT 7
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: PPUSH
17328: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17332: LD_EXP 45
17336: PPUSH
17337: CALL_OW 314
17341: NOT
17342: PUSH
17343: LD_EXP 45
17347: PPUSH
17348: LD_INT 1
17350: PPUSH
17351: CALL_OW 289
17355: PUSH
17356: LD_INT 100
17358: LESS
17359: AND
17360: IFFALSE 17408
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17362: LD_ADDR_VAR 0 4
17366: PUSH
17367: LD_INT 12
17369: PPUSH
17370: CALL_OW 435
17374: ST_TO_ADDR
// if cr then
17375: LD_VAR 0 4
17379: IFFALSE 17408
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17381: LD_EXP 45
17385: PPUSH
17386: LD_VAR 0 4
17390: PUSH
17391: LD_INT 1
17393: ARRAY
17394: PPUSH
17395: LD_VAR 0 4
17399: PUSH
17400: LD_INT 2
17402: ARRAY
17403: PPUSH
17404: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17408: LD_EXP 50
17412: PPUSH
17413: LD_INT 3
17415: PUSH
17416: LD_INT 24
17418: PUSH
17419: LD_INT 1000
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: PUSH
17426: EMPTY
17427: LIST
17428: LIST
17429: PPUSH
17430: CALL_OW 72
17434: IFFALSE 17564
// begin if al_eng then
17436: LD_EXP 40
17440: IFFALSE 17562
// for i = 1 to al_eng do
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: DOUBLE
17448: LD_INT 1
17450: DEC
17451: ST_TO_ADDR
17452: LD_EXP 40
17456: PUSH
17457: FOR_TO
17458: IFFALSE 17560
// if IsInUnit ( al_eng [ i ] ) then
17460: LD_EXP 40
17464: PUSH
17465: LD_VAR 0 1
17469: ARRAY
17470: PPUSH
17471: CALL_OW 310
17475: IFFALSE 17494
// ComExitBuilding ( al_eng [ i ] ) else
17477: LD_EXP 40
17481: PUSH
17482: LD_VAR 0 1
17486: ARRAY
17487: PPUSH
17488: CALL_OW 122
17492: GO 17558
// if not HasTask ( al_eng [ i ] ) then
17494: LD_EXP 40
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 314
17509: NOT
17510: IFFALSE 17558
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17512: LD_EXP 40
17516: PUSH
17517: LD_VAR 0 1
17521: ARRAY
17522: PPUSH
17523: LD_EXP 50
17527: PPUSH
17528: LD_INT 3
17530: PUSH
17531: LD_INT 24
17533: PUSH
17534: LD_INT 1000
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: EMPTY
17542: LIST
17543: LIST
17544: PPUSH
17545: CALL_OW 72
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: CALL_OW 130
17558: GO 17457
17560: POP
17561: POP
// end else
17562: GO 17646
// if al_eng then
17564: LD_EXP 40
17568: IFFALSE 17646
// if not IsInUnit ( al_eng [ 1 ] ) then
17570: LD_EXP 40
17574: PUSH
17575: LD_INT 1
17577: ARRAY
17578: PPUSH
17579: CALL_OW 310
17583: NOT
17584: IFFALSE 17646
// for i = 1 to al_eng do
17586: LD_ADDR_VAR 0 1
17590: PUSH
17591: DOUBLE
17592: LD_INT 1
17594: DEC
17595: ST_TO_ADDR
17596: LD_EXP 40
17600: PUSH
17601: FOR_TO
17602: IFFALSE 17644
// if not IsInUnit ( al_eng [ i ] ) then
17604: LD_EXP 40
17608: PUSH
17609: LD_VAR 0 1
17613: ARRAY
17614: PPUSH
17615: CALL_OW 310
17619: NOT
17620: IFFALSE 17642
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17622: LD_EXP 40
17626: PUSH
17627: LD_VAR 0 1
17631: ARRAY
17632: PPUSH
17633: LD_EXP 47
17637: PPUSH
17638: CALL_OW 120
17642: GO 17601
17644: POP
17645: POP
// if al_vehs then
17646: LD_EXP 44
17650: IFFALSE 17750
// if BuildingStatus ( al_fac ) = bs_idle then
17652: LD_EXP 49
17656: PPUSH
17657: CALL_OW 461
17661: PUSH
17662: LD_INT 2
17664: EQUAL
17665: IFFALSE 17750
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17667: LD_EXP 49
17671: PPUSH
17672: LD_EXP 44
17676: PUSH
17677: LD_INT 1
17679: ARRAY
17680: PPUSH
17681: LD_EXP 44
17685: PUSH
17686: LD_INT 2
17688: ARRAY
17689: PPUSH
17690: LD_EXP 44
17694: PUSH
17695: LD_INT 3
17697: ARRAY
17698: PPUSH
17699: LD_EXP 44
17703: PUSH
17704: LD_INT 4
17706: ARRAY
17707: PPUSH
17708: CALL_OW 125
// for i = 1 to 4 do
17712: LD_ADDR_VAR 0 1
17716: PUSH
17717: DOUBLE
17718: LD_INT 1
17720: DEC
17721: ST_TO_ADDR
17722: LD_INT 4
17724: PUSH
17725: FOR_TO
17726: IFFALSE 17748
// al_vehs := Delete ( al_vehs , 1 ) ;
17728: LD_ADDR_EXP 44
17732: PUSH
17733: LD_EXP 44
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 3
17745: ST_TO_ADDR
17746: GO 17725
17748: POP
17749: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17750: LD_EXP 38
17754: PUSH
17755: LD_INT 0
17757: EQUAL
17758: PUSH
17759: LD_OWVAR 1
17763: PUSH
17764: LD_INT 23100
17766: MOD
17767: PUSH
17768: LD_INT 0
17770: EQUAL
17771: AND
17772: IFFALSE 17886
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17774: LD_ADDR_VAR 0 1
17778: PUSH
17779: DOUBLE
17780: LD_INT 1
17782: DEC
17783: ST_TO_ADDR
17784: LD_INT 4
17786: PUSH
17787: LD_INT 5
17789: PUSH
17790: LD_INT 6
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: LIST
17797: PUSH
17798: LD_OWVAR 67
17802: ARRAY
17803: PUSH
17804: FOR_TO
17805: IFFALSE 17884
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17807: LD_ADDR_EXP 44
17811: PUSH
17812: LD_EXP 44
17816: PUSH
17817: LD_INT 23
17819: ADD
17820: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17821: LD_ADDR_EXP 44
17825: PUSH
17826: LD_EXP 44
17830: PUSH
17831: LD_INT 1
17833: ADD
17834: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17835: LD_ADDR_EXP 44
17839: PUSH
17840: LD_EXP 44
17844: PUSH
17845: LD_INT 3
17847: ADD
17848: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17849: LD_ADDR_EXP 44
17853: PUSH
17854: LD_EXP 44
17858: PUSH
17859: LD_INT 46
17861: PUSH
17862: LD_INT 47
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: PUSH
17869: LD_INT 1
17871: PPUSH
17872: LD_INT 2
17874: PPUSH
17875: CALL_OW 12
17879: ARRAY
17880: ADD
17881: ST_TO_ADDR
// end ;
17882: GO 17804
17884: POP
17885: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17886: LD_INT 22
17888: PUSH
17889: LD_INT 7
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PUSH
17896: LD_INT 34
17898: PUSH
17899: LD_INT 51
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PPUSH
17910: CALL_OW 69
17914: PUSH
17915: LD_INT 0
17917: EQUAL
17918: IFFALSE 17941
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17920: LD_EXP 49
17924: PPUSH
17925: LD_INT 21
17927: PPUSH
17928: LD_INT 1
17930: PPUSH
17931: LD_INT 3
17933: PPUSH
17934: LD_INT 51
17936: PPUSH
17937: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17941: LD_EXP 38
17945: PUSH
17946: LD_OWVAR 1
17950: PUSH
17951: LD_INT 25200
17953: MOD
17954: PUSH
17955: LD_INT 0
17957: EQUAL
17958: AND
17959: IFFALSE 18022
// begin for i = 1 to al_force do
17961: LD_ADDR_VAR 0 1
17965: PUSH
17966: DOUBLE
17967: LD_INT 1
17969: DEC
17970: ST_TO_ADDR
17971: LD_EXP 38
17975: PUSH
17976: FOR_TO
17977: IFFALSE 18020
// if GetTag ( al_force [ i ] ) <> 11 then
17979: LD_EXP 38
17983: PUSH
17984: LD_VAR 0 1
17988: ARRAY
17989: PPUSH
17990: CALL_OW 110
17994: PUSH
17995: LD_INT 11
17997: NONEQUAL
17998: IFFALSE 18018
// SetTag ( al_force [ i ] , 11 ) ;
18000: LD_EXP 38
18004: PUSH
18005: LD_VAR 0 1
18009: ARRAY
18010: PPUSH
18011: LD_INT 11
18013: PPUSH
18014: CALL_OW 109
18018: GO 17976
18020: POP
18021: POP
// end ; if al_force then
18022: LD_EXP 38
18026: IFFALSE 18135
// for i = 1 to al_force do
18028: LD_ADDR_VAR 0 1
18032: PUSH
18033: DOUBLE
18034: LD_INT 1
18036: DEC
18037: ST_TO_ADDR
18038: LD_EXP 38
18042: PUSH
18043: FOR_TO
18044: IFFALSE 18133
// begin if GetTag ( al_force [ i ] ) = 11 then
18046: LD_EXP 38
18050: PUSH
18051: LD_VAR 0 1
18055: ARRAY
18056: PPUSH
18057: CALL_OW 110
18061: PUSH
18062: LD_INT 11
18064: EQUAL
18065: IFFALSE 18131
// begin if not HasTask ( al_force [ i ] ) then
18067: LD_EXP 38
18071: PUSH
18072: LD_VAR 0 1
18076: ARRAY
18077: PPUSH
18078: CALL_OW 314
18082: NOT
18083: IFFALSE 18131
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18085: LD_EXP 38
18089: PUSH
18090: LD_VAR 0 1
18094: ARRAY
18095: PPUSH
18096: LD_INT 81
18098: PUSH
18099: LD_INT 7
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: PPUSH
18106: CALL_OW 69
18110: PPUSH
18111: LD_EXP 38
18115: PUSH
18116: LD_VAR 0 1
18120: ARRAY
18121: PPUSH
18122: CALL_OW 74
18126: PPUSH
18127: CALL_OW 115
// end ; end ;
18131: GO 18043
18133: POP
18134: POP
// end ; end_of_file
18135: PPOPN 4
18137: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18138: LD_INT 0
18140: PPUSH
18141: PPUSH
18142: PPUSH
18143: PPUSH
18144: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18145: LD_ADDR_EXP 53
18149: PUSH
18150: LD_INT 7
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 5
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: LIST
18163: PUSH
18164: LD_OWVAR 67
18168: ARRAY
18169: ST_TO_ADDR
// ar_force := [ ] ;
18170: LD_ADDR_EXP 52
18174: PUSH
18175: EMPTY
18176: ST_TO_ADDR
// RemoveAlliance ;
18177: CALL 15966 0 0
// RemoveEnvironmentArea ( evn ) ;
18181: LD_INT 17
18183: PPUSH
18184: CALL_OW 355
// your_side := 2 ;
18188: LD_ADDR_OWVAR 2
18192: PUSH
18193: LD_INT 2
18195: ST_TO_ADDR
// uc_side := 2 ;
18196: LD_ADDR_OWVAR 20
18200: PUSH
18201: LD_INT 2
18203: ST_TO_ADDR
// uc_nation := nation_arabian ;
18204: LD_ADDR_OWVAR 21
18208: PUSH
18209: LD_INT 2
18211: ST_TO_ADDR
// hc_gallery :=  ;
18212: LD_ADDR_OWVAR 33
18216: PUSH
18217: LD_STRING 
18219: ST_TO_ADDR
// hc_name :=  ;
18220: LD_ADDR_OWVAR 26
18224: PUSH
18225: LD_STRING 
18227: ST_TO_ADDR
// hc_importance := 0 ;
18228: LD_ADDR_OWVAR 32
18232: PUSH
18233: LD_INT 0
18235: ST_TO_ADDR
// for i = 1 to 15 do
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: DOUBLE
18242: LD_INT 1
18244: DEC
18245: ST_TO_ADDR
18246: LD_INT 15
18248: PUSH
18249: FOR_TO
18250: IFFALSE 18303
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18252: LD_INT 0
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_INT 4
18260: PPUSH
18261: CALL_OW 12
18265: PPUSH
18266: LD_EXP 53
18270: PPUSH
18271: CALL_OW 380
// un := CreateHuman ;
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: CALL_OW 44
18284: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18285: LD_ADDR_EXP 52
18289: PUSH
18290: LD_EXP 52
18294: PUSH
18295: LD_VAR 0 4
18299: ADD
18300: ST_TO_ADDR
// end ;
18301: GO 18249
18303: POP
18304: POP
// hc_importance := 100 ;
18305: LD_ADDR_OWVAR 32
18309: PUSH
18310: LD_INT 100
18312: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18313: LD_INT 1
18315: PPUSH
18316: LD_INT 11
18318: PPUSH
18319: LD_EXP 53
18323: PPUSH
18324: CALL_OW 380
// ar_commander := CreateHuman ;
18328: LD_ADDR_EXP 51
18332: PUSH
18333: CALL_OW 44
18337: ST_TO_ADDR
// player_commander := ar_commander ;
18338: LD_ADDR_EXP 10
18342: PUSH
18343: LD_EXP 51
18347: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18348: LD_ADDR_VAR 0 5
18352: PUSH
18353: LD_STRING text
18355: PPUSH
18356: LD_INT 11
18358: PUSH
18359: LD_INT 10
18361: PUSH
18362: LD_INT 9
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: PUSH
18370: LD_OWVAR 67
18374: ARRAY
18375: PPUSH
18376: LD_INT 11
18378: PUSH
18379: LD_INT 10
18381: PUSH
18382: LD_INT 9
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: LD_OWVAR 67
18394: ARRAY
18395: PPUSH
18396: LD_INT -5
18398: PUSH
18399: LD_EXP 51
18403: PUSH
18404: LD_INT -3
18406: PUSH
18407: LD_INT -2
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: PUSH
18416: LD_EXP 52
18420: ADD
18421: PPUSH
18422: LD_INT 1
18424: PUSH
18425: LD_INT 3
18427: PUSH
18428: LD_INT 2
18430: PUSH
18431: LD_INT 1
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: PUSH
18438: LD_INT 4
18440: PUSH
18441: LD_INT 1
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PUSH
18448: LD_INT 8
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: PPUSH
18458: CALL_OW 42
18462: ST_TO_ADDR
// team := team ^ ar_commander ;
18463: LD_ADDR_VAR 0 5
18467: PUSH
18468: LD_VAR 0 5
18472: PUSH
18473: LD_EXP 51
18477: ADD
18478: ST_TO_ADDR
// for i = 1 to team do
18479: LD_ADDR_VAR 0 2
18483: PUSH
18484: DOUBLE
18485: LD_INT 1
18487: DEC
18488: ST_TO_ADDR
18489: LD_VAR 0 5
18493: PUSH
18494: FOR_TO
18495: IFFALSE 18520
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18497: LD_VAR 0 5
18501: PUSH
18502: LD_VAR 0 2
18506: ARRAY
18507: PPUSH
18508: LD_INT 16
18510: PPUSH
18511: LD_INT 0
18513: PPUSH
18514: CALL_OW 49
18518: GO 18494
18520: POP
18521: POP
// uc_side := 0 ;
18522: LD_ADDR_OWVAR 20
18526: PUSH
18527: LD_INT 0
18529: ST_TO_ADDR
// uc_nation := 0 ;
18530: LD_ADDR_OWVAR 21
18534: PUSH
18535: LD_INT 0
18537: ST_TO_ADDR
// vc_chassis := 31 ;
18538: LD_ADDR_OWVAR 37
18542: PUSH
18543: LD_INT 31
18545: ST_TO_ADDR
// vc_control := control_rider ;
18546: LD_ADDR_OWVAR 38
18550: PUSH
18551: LD_INT 4
18553: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18554: CALL_OW 45
18558: PPUSH
18559: LD_INT 96
18561: PPUSH
18562: LD_INT 20
18564: PPUSH
18565: LD_INT 0
18567: PPUSH
18568: CALL_OW 48
// end ; end_of_file
18572: LD_VAR 0 1
18576: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18577: GO 18579
18579: DISABLE
// begin ru_radar := 98 ;
18580: LD_ADDR_EXP 54
18584: PUSH
18585: LD_INT 98
18587: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18588: LD_ADDR_EXP 55
18592: PUSH
18593: LD_INT 89
18595: ST_TO_ADDR
// us_hack := 99 ;
18596: LD_ADDR_EXP 56
18600: PUSH
18601: LD_INT 99
18603: ST_TO_ADDR
// us_artillery := 97 ;
18604: LD_ADDR_EXP 57
18608: PUSH
18609: LD_INT 97
18611: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18612: LD_ADDR_EXP 58
18616: PUSH
18617: LD_INT 91
18619: ST_TO_ADDR
// end ; end_of_file end_of_file
18620: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18621: GO 18623
18623: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18624: LD_STRING initStreamRollete();
18626: PPUSH
18627: CALL_OW 559
// InitStreamMode ;
18631: CALL 18640 0 0
// DefineStreamItems ( ) ;
18635: CALL 19080 0 0
// end ;
18639: END
// function InitStreamMode ; begin
18640: LD_INT 0
18642: PPUSH
// streamModeActive := false ;
18643: LD_ADDR_EXP 59
18647: PUSH
18648: LD_INT 0
18650: ST_TO_ADDR
// normalCounter := 26 ;
18651: LD_ADDR_EXP 60
18655: PUSH
18656: LD_INT 26
18658: ST_TO_ADDR
// hardcoreCounter := 12 ;
18659: LD_ADDR_EXP 61
18663: PUSH
18664: LD_INT 12
18666: ST_TO_ADDR
// sRocket := false ;
18667: LD_ADDR_EXP 64
18671: PUSH
18672: LD_INT 0
18674: ST_TO_ADDR
// sSpeed := false ;
18675: LD_ADDR_EXP 63
18679: PUSH
18680: LD_INT 0
18682: ST_TO_ADDR
// sEngine := false ;
18683: LD_ADDR_EXP 65
18687: PUSH
18688: LD_INT 0
18690: ST_TO_ADDR
// sSpec := false ;
18691: LD_ADDR_EXP 62
18695: PUSH
18696: LD_INT 0
18698: ST_TO_ADDR
// sLevel := false ;
18699: LD_ADDR_EXP 66
18703: PUSH
18704: LD_INT 0
18706: ST_TO_ADDR
// sArmoury := false ;
18707: LD_ADDR_EXP 67
18711: PUSH
18712: LD_INT 0
18714: ST_TO_ADDR
// sRadar := false ;
18715: LD_ADDR_EXP 68
18719: PUSH
18720: LD_INT 0
18722: ST_TO_ADDR
// sBunker := false ;
18723: LD_ADDR_EXP 69
18727: PUSH
18728: LD_INT 0
18730: ST_TO_ADDR
// sHack := false ;
18731: LD_ADDR_EXP 70
18735: PUSH
18736: LD_INT 0
18738: ST_TO_ADDR
// sFire := false ;
18739: LD_ADDR_EXP 71
18743: PUSH
18744: LD_INT 0
18746: ST_TO_ADDR
// sRefresh := false ;
18747: LD_ADDR_EXP 72
18751: PUSH
18752: LD_INT 0
18754: ST_TO_ADDR
// sExp := false ;
18755: LD_ADDR_EXP 73
18759: PUSH
18760: LD_INT 0
18762: ST_TO_ADDR
// sDepot := false ;
18763: LD_ADDR_EXP 74
18767: PUSH
18768: LD_INT 0
18770: ST_TO_ADDR
// sFlag := false ;
18771: LD_ADDR_EXP 75
18775: PUSH
18776: LD_INT 0
18778: ST_TO_ADDR
// sKamikadze := false ;
18779: LD_ADDR_EXP 83
18783: PUSH
18784: LD_INT 0
18786: ST_TO_ADDR
// sTroll := false ;
18787: LD_ADDR_EXP 84
18791: PUSH
18792: LD_INT 0
18794: ST_TO_ADDR
// sSlow := false ;
18795: LD_ADDR_EXP 85
18799: PUSH
18800: LD_INT 0
18802: ST_TO_ADDR
// sLack := false ;
18803: LD_ADDR_EXP 86
18807: PUSH
18808: LD_INT 0
18810: ST_TO_ADDR
// sTank := false ;
18811: LD_ADDR_EXP 88
18815: PUSH
18816: LD_INT 0
18818: ST_TO_ADDR
// sRemote := false ;
18819: LD_ADDR_EXP 89
18823: PUSH
18824: LD_INT 0
18826: ST_TO_ADDR
// sPowell := false ;
18827: LD_ADDR_EXP 90
18831: PUSH
18832: LD_INT 0
18834: ST_TO_ADDR
// sTeleport := false ;
18835: LD_ADDR_EXP 93
18839: PUSH
18840: LD_INT 0
18842: ST_TO_ADDR
// sOilTower := false ;
18843: LD_ADDR_EXP 95
18847: PUSH
18848: LD_INT 0
18850: ST_TO_ADDR
// sShovel := false ;
18851: LD_ADDR_EXP 96
18855: PUSH
18856: LD_INT 0
18858: ST_TO_ADDR
// sSheik := false ;
18859: LD_ADDR_EXP 97
18863: PUSH
18864: LD_INT 0
18866: ST_TO_ADDR
// sEarthquake := false ;
18867: LD_ADDR_EXP 99
18871: PUSH
18872: LD_INT 0
18874: ST_TO_ADDR
// sAI := false ;
18875: LD_ADDR_EXP 100
18879: PUSH
18880: LD_INT 0
18882: ST_TO_ADDR
// sCargo := false ;
18883: LD_ADDR_EXP 103
18887: PUSH
18888: LD_INT 0
18890: ST_TO_ADDR
// sDLaser := false ;
18891: LD_ADDR_EXP 104
18895: PUSH
18896: LD_INT 0
18898: ST_TO_ADDR
// sExchange := false ;
18899: LD_ADDR_EXP 105
18903: PUSH
18904: LD_INT 0
18906: ST_TO_ADDR
// sFac := false ;
18907: LD_ADDR_EXP 106
18911: PUSH
18912: LD_INT 0
18914: ST_TO_ADDR
// sPower := false ;
18915: LD_ADDR_EXP 107
18919: PUSH
18920: LD_INT 0
18922: ST_TO_ADDR
// sRandom := false ;
18923: LD_ADDR_EXP 108
18927: PUSH
18928: LD_INT 0
18930: ST_TO_ADDR
// sShield := false ;
18931: LD_ADDR_EXP 109
18935: PUSH
18936: LD_INT 0
18938: ST_TO_ADDR
// sTime := false ;
18939: LD_ADDR_EXP 110
18943: PUSH
18944: LD_INT 0
18946: ST_TO_ADDR
// sTools := false ;
18947: LD_ADDR_EXP 111
18951: PUSH
18952: LD_INT 0
18954: ST_TO_ADDR
// sSold := false ;
18955: LD_ADDR_EXP 76
18959: PUSH
18960: LD_INT 0
18962: ST_TO_ADDR
// sDiff := false ;
18963: LD_ADDR_EXP 77
18967: PUSH
18968: LD_INT 0
18970: ST_TO_ADDR
// sFog := false ;
18971: LD_ADDR_EXP 80
18975: PUSH
18976: LD_INT 0
18978: ST_TO_ADDR
// sReset := false ;
18979: LD_ADDR_EXP 81
18983: PUSH
18984: LD_INT 0
18986: ST_TO_ADDR
// sSun := false ;
18987: LD_ADDR_EXP 82
18991: PUSH
18992: LD_INT 0
18994: ST_TO_ADDR
// sTiger := false ;
18995: LD_ADDR_EXP 78
18999: PUSH
19000: LD_INT 0
19002: ST_TO_ADDR
// sBomb := false ;
19003: LD_ADDR_EXP 79
19007: PUSH
19008: LD_INT 0
19010: ST_TO_ADDR
// sWound := false ;
19011: LD_ADDR_EXP 87
19015: PUSH
19016: LD_INT 0
19018: ST_TO_ADDR
// sBetray := false ;
19019: LD_ADDR_EXP 91
19023: PUSH
19024: LD_INT 0
19026: ST_TO_ADDR
// sContamin := false ;
19027: LD_ADDR_EXP 92
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// sOil := false ;
19035: LD_ADDR_EXP 94
19039: PUSH
19040: LD_INT 0
19042: ST_TO_ADDR
// sStu := false ;
19043: LD_ADDR_EXP 98
19047: PUSH
19048: LD_INT 0
19050: ST_TO_ADDR
// sBazooka := false ;
19051: LD_ADDR_EXP 101
19055: PUSH
19056: LD_INT 0
19058: ST_TO_ADDR
// sMortar := false ;
19059: LD_ADDR_EXP 102
19063: PUSH
19064: LD_INT 0
19066: ST_TO_ADDR
// sRanger := false ;
19067: LD_ADDR_EXP 112
19071: PUSH
19072: LD_INT 0
19074: ST_TO_ADDR
// end ;
19075: LD_VAR 0 1
19079: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19080: LD_INT 0
19082: PPUSH
19083: PPUSH
19084: PPUSH
19085: PPUSH
19086: PPUSH
// result := [ ] ;
19087: LD_ADDR_VAR 0 1
19091: PUSH
19092: EMPTY
19093: ST_TO_ADDR
// if campaign_id = 1 then
19094: LD_OWVAR 69
19098: PUSH
19099: LD_INT 1
19101: EQUAL
19102: IFFALSE 22038
// begin case mission_number of 1 :
19104: LD_OWVAR 70
19108: PUSH
19109: LD_INT 1
19111: DOUBLE
19112: EQUAL
19113: IFTRUE 19117
19115: GO 19181
19117: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19118: LD_ADDR_VAR 0 1
19122: PUSH
19123: LD_INT 2
19125: PUSH
19126: LD_INT 4
19128: PUSH
19129: LD_INT 11
19131: PUSH
19132: LD_INT 12
19134: PUSH
19135: LD_INT 15
19137: PUSH
19138: LD_INT 16
19140: PUSH
19141: LD_INT 22
19143: PUSH
19144: LD_INT 23
19146: PUSH
19147: LD_INT 26
19149: PUSH
19150: EMPTY
19151: LIST
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: PUSH
19161: LD_INT 101
19163: PUSH
19164: LD_INT 102
19166: PUSH
19167: LD_INT 106
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: LIST
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: ST_TO_ADDR
19179: GO 22038
19181: LD_INT 2
19183: DOUBLE
19184: EQUAL
19185: IFTRUE 19189
19187: GO 19261
19189: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19190: LD_ADDR_VAR 0 1
19194: PUSH
19195: LD_INT 2
19197: PUSH
19198: LD_INT 4
19200: PUSH
19201: LD_INT 11
19203: PUSH
19204: LD_INT 12
19206: PUSH
19207: LD_INT 15
19209: PUSH
19210: LD_INT 16
19212: PUSH
19213: LD_INT 22
19215: PUSH
19216: LD_INT 23
19218: PUSH
19219: LD_INT 26
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: LIST
19226: LIST
19227: LIST
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: PUSH
19233: LD_INT 101
19235: PUSH
19236: LD_INT 102
19238: PUSH
19239: LD_INT 105
19241: PUSH
19242: LD_INT 106
19244: PUSH
19245: LD_INT 108
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: ST_TO_ADDR
19259: GO 22038
19261: LD_INT 3
19263: DOUBLE
19264: EQUAL
19265: IFTRUE 19269
19267: GO 19345
19269: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19270: LD_ADDR_VAR 0 1
19274: PUSH
19275: LD_INT 2
19277: PUSH
19278: LD_INT 4
19280: PUSH
19281: LD_INT 5
19283: PUSH
19284: LD_INT 11
19286: PUSH
19287: LD_INT 12
19289: PUSH
19290: LD_INT 15
19292: PUSH
19293: LD_INT 16
19295: PUSH
19296: LD_INT 22
19298: PUSH
19299: LD_INT 26
19301: PUSH
19302: LD_INT 36
19304: PUSH
19305: EMPTY
19306: LIST
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 101
19319: PUSH
19320: LD_INT 102
19322: PUSH
19323: LD_INT 105
19325: PUSH
19326: LD_INT 106
19328: PUSH
19329: LD_INT 108
19331: PUSH
19332: EMPTY
19333: LIST
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: ST_TO_ADDR
19343: GO 22038
19345: LD_INT 4
19347: DOUBLE
19348: EQUAL
19349: IFTRUE 19353
19351: GO 19437
19353: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19354: LD_ADDR_VAR 0 1
19358: PUSH
19359: LD_INT 2
19361: PUSH
19362: LD_INT 4
19364: PUSH
19365: LD_INT 5
19367: PUSH
19368: LD_INT 8
19370: PUSH
19371: LD_INT 11
19373: PUSH
19374: LD_INT 12
19376: PUSH
19377: LD_INT 15
19379: PUSH
19380: LD_INT 16
19382: PUSH
19383: LD_INT 22
19385: PUSH
19386: LD_INT 23
19388: PUSH
19389: LD_INT 26
19391: PUSH
19392: LD_INT 36
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: PUSH
19409: LD_INT 101
19411: PUSH
19412: LD_INT 102
19414: PUSH
19415: LD_INT 105
19417: PUSH
19418: LD_INT 106
19420: PUSH
19421: LD_INT 108
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: ST_TO_ADDR
19435: GO 22038
19437: LD_INT 5
19439: DOUBLE
19440: EQUAL
19441: IFTRUE 19445
19443: GO 19545
19445: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19446: LD_ADDR_VAR 0 1
19450: PUSH
19451: LD_INT 2
19453: PUSH
19454: LD_INT 4
19456: PUSH
19457: LD_INT 5
19459: PUSH
19460: LD_INT 6
19462: PUSH
19463: LD_INT 8
19465: PUSH
19466: LD_INT 11
19468: PUSH
19469: LD_INT 12
19471: PUSH
19472: LD_INT 15
19474: PUSH
19475: LD_INT 16
19477: PUSH
19478: LD_INT 22
19480: PUSH
19481: LD_INT 23
19483: PUSH
19484: LD_INT 25
19486: PUSH
19487: LD_INT 26
19489: PUSH
19490: LD_INT 36
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: PUSH
19509: LD_INT 101
19511: PUSH
19512: LD_INT 102
19514: PUSH
19515: LD_INT 105
19517: PUSH
19518: LD_INT 106
19520: PUSH
19521: LD_INT 108
19523: PUSH
19524: LD_INT 109
19526: PUSH
19527: LD_INT 112
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: LIST
19536: LIST
19537: LIST
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: ST_TO_ADDR
19543: GO 22038
19545: LD_INT 6
19547: DOUBLE
19548: EQUAL
19549: IFTRUE 19553
19551: GO 19673
19553: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19554: LD_ADDR_VAR 0 1
19558: PUSH
19559: LD_INT 2
19561: PUSH
19562: LD_INT 4
19564: PUSH
19565: LD_INT 5
19567: PUSH
19568: LD_INT 6
19570: PUSH
19571: LD_INT 8
19573: PUSH
19574: LD_INT 11
19576: PUSH
19577: LD_INT 12
19579: PUSH
19580: LD_INT 15
19582: PUSH
19583: LD_INT 16
19585: PUSH
19586: LD_INT 20
19588: PUSH
19589: LD_INT 21
19591: PUSH
19592: LD_INT 22
19594: PUSH
19595: LD_INT 23
19597: PUSH
19598: LD_INT 25
19600: PUSH
19601: LD_INT 26
19603: PUSH
19604: LD_INT 30
19606: PUSH
19607: LD_INT 31
19609: PUSH
19610: LD_INT 32
19612: PUSH
19613: LD_INT 36
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: LIST
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: PUSH
19637: LD_INT 101
19639: PUSH
19640: LD_INT 102
19642: PUSH
19643: LD_INT 105
19645: PUSH
19646: LD_INT 106
19648: PUSH
19649: LD_INT 108
19651: PUSH
19652: LD_INT 109
19654: PUSH
19655: LD_INT 112
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: ST_TO_ADDR
19671: GO 22038
19673: LD_INT 7
19675: DOUBLE
19676: EQUAL
19677: IFTRUE 19681
19679: GO 19781
19681: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19682: LD_ADDR_VAR 0 1
19686: PUSH
19687: LD_INT 2
19689: PUSH
19690: LD_INT 4
19692: PUSH
19693: LD_INT 5
19695: PUSH
19696: LD_INT 7
19698: PUSH
19699: LD_INT 11
19701: PUSH
19702: LD_INT 12
19704: PUSH
19705: LD_INT 15
19707: PUSH
19708: LD_INT 16
19710: PUSH
19711: LD_INT 20
19713: PUSH
19714: LD_INT 21
19716: PUSH
19717: LD_INT 22
19719: PUSH
19720: LD_INT 23
19722: PUSH
19723: LD_INT 25
19725: PUSH
19726: LD_INT 26
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: PUSH
19745: LD_INT 101
19747: PUSH
19748: LD_INT 102
19750: PUSH
19751: LD_INT 103
19753: PUSH
19754: LD_INT 105
19756: PUSH
19757: LD_INT 106
19759: PUSH
19760: LD_INT 108
19762: PUSH
19763: LD_INT 112
19765: PUSH
19766: EMPTY
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 22038
19781: LD_INT 8
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19917
19789: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_INT 2
19797: PUSH
19798: LD_INT 4
19800: PUSH
19801: LD_INT 5
19803: PUSH
19804: LD_INT 6
19806: PUSH
19807: LD_INT 7
19809: PUSH
19810: LD_INT 8
19812: PUSH
19813: LD_INT 11
19815: PUSH
19816: LD_INT 12
19818: PUSH
19819: LD_INT 15
19821: PUSH
19822: LD_INT 16
19824: PUSH
19825: LD_INT 20
19827: PUSH
19828: LD_INT 21
19830: PUSH
19831: LD_INT 22
19833: PUSH
19834: LD_INT 23
19836: PUSH
19837: LD_INT 25
19839: PUSH
19840: LD_INT 26
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_INT 31
19848: PUSH
19849: LD_INT 32
19851: PUSH
19852: LD_INT 36
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: PUSH
19877: LD_INT 101
19879: PUSH
19880: LD_INT 102
19882: PUSH
19883: LD_INT 103
19885: PUSH
19886: LD_INT 105
19888: PUSH
19889: LD_INT 106
19891: PUSH
19892: LD_INT 108
19894: PUSH
19895: LD_INT 109
19897: PUSH
19898: LD_INT 112
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: ST_TO_ADDR
19915: GO 22038
19917: LD_INT 9
19919: DOUBLE
19920: EQUAL
19921: IFTRUE 19925
19923: GO 20061
19925: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19926: LD_ADDR_VAR 0 1
19930: PUSH
19931: LD_INT 2
19933: PUSH
19934: LD_INT 4
19936: PUSH
19937: LD_INT 5
19939: PUSH
19940: LD_INT 6
19942: PUSH
19943: LD_INT 7
19945: PUSH
19946: LD_INT 8
19948: PUSH
19949: LD_INT 11
19951: PUSH
19952: LD_INT 12
19954: PUSH
19955: LD_INT 15
19957: PUSH
19958: LD_INT 16
19960: PUSH
19961: LD_INT 20
19963: PUSH
19964: LD_INT 21
19966: PUSH
19967: LD_INT 22
19969: PUSH
19970: LD_INT 23
19972: PUSH
19973: LD_INT 25
19975: PUSH
19976: LD_INT 26
19978: PUSH
19979: LD_INT 28
19981: PUSH
19982: LD_INT 30
19984: PUSH
19985: LD_INT 31
19987: PUSH
19988: LD_INT 32
19990: PUSH
19991: LD_INT 36
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: PUSH
20017: LD_INT 101
20019: PUSH
20020: LD_INT 102
20022: PUSH
20023: LD_INT 103
20025: PUSH
20026: LD_INT 105
20028: PUSH
20029: LD_INT 106
20031: PUSH
20032: LD_INT 108
20034: PUSH
20035: LD_INT 109
20037: PUSH
20038: LD_INT 112
20040: PUSH
20041: LD_INT 114
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: LIST
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 22038
20061: LD_INT 10
20063: DOUBLE
20064: EQUAL
20065: IFTRUE 20069
20067: GO 20253
20069: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20070: LD_ADDR_VAR 0 1
20074: PUSH
20075: LD_INT 2
20077: PUSH
20078: LD_INT 4
20080: PUSH
20081: LD_INT 5
20083: PUSH
20084: LD_INT 6
20086: PUSH
20087: LD_INT 7
20089: PUSH
20090: LD_INT 8
20092: PUSH
20093: LD_INT 9
20095: PUSH
20096: LD_INT 10
20098: PUSH
20099: LD_INT 11
20101: PUSH
20102: LD_INT 12
20104: PUSH
20105: LD_INT 13
20107: PUSH
20108: LD_INT 14
20110: PUSH
20111: LD_INT 15
20113: PUSH
20114: LD_INT 16
20116: PUSH
20117: LD_INT 17
20119: PUSH
20120: LD_INT 18
20122: PUSH
20123: LD_INT 19
20125: PUSH
20126: LD_INT 20
20128: PUSH
20129: LD_INT 21
20131: PUSH
20132: LD_INT 22
20134: PUSH
20135: LD_INT 23
20137: PUSH
20138: LD_INT 24
20140: PUSH
20141: LD_INT 25
20143: PUSH
20144: LD_INT 26
20146: PUSH
20147: LD_INT 28
20149: PUSH
20150: LD_INT 30
20152: PUSH
20153: LD_INT 31
20155: PUSH
20156: LD_INT 32
20158: PUSH
20159: LD_INT 36
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 101
20195: PUSH
20196: LD_INT 102
20198: PUSH
20199: LD_INT 103
20201: PUSH
20202: LD_INT 104
20204: PUSH
20205: LD_INT 105
20207: PUSH
20208: LD_INT 106
20210: PUSH
20211: LD_INT 107
20213: PUSH
20214: LD_INT 108
20216: PUSH
20217: LD_INT 109
20219: PUSH
20220: LD_INT 110
20222: PUSH
20223: LD_INT 111
20225: PUSH
20226: LD_INT 112
20228: PUSH
20229: LD_INT 114
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: LIST
20236: LIST
20237: LIST
20238: LIST
20239: LIST
20240: LIST
20241: LIST
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 22038
20253: LD_INT 11
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20453
20261: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20262: LD_ADDR_VAR 0 1
20266: PUSH
20267: LD_INT 2
20269: PUSH
20270: LD_INT 3
20272: PUSH
20273: LD_INT 4
20275: PUSH
20276: LD_INT 5
20278: PUSH
20279: LD_INT 6
20281: PUSH
20282: LD_INT 7
20284: PUSH
20285: LD_INT 8
20287: PUSH
20288: LD_INT 9
20290: PUSH
20291: LD_INT 10
20293: PUSH
20294: LD_INT 11
20296: PUSH
20297: LD_INT 12
20299: PUSH
20300: LD_INT 13
20302: PUSH
20303: LD_INT 14
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 16
20311: PUSH
20312: LD_INT 17
20314: PUSH
20315: LD_INT 18
20317: PUSH
20318: LD_INT 19
20320: PUSH
20321: LD_INT 20
20323: PUSH
20324: LD_INT 21
20326: PUSH
20327: LD_INT 22
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: LD_INT 24
20335: PUSH
20336: LD_INT 25
20338: PUSH
20339: LD_INT 26
20341: PUSH
20342: LD_INT 28
20344: PUSH
20345: LD_INT 30
20347: PUSH
20348: LD_INT 31
20350: PUSH
20351: LD_INT 32
20353: PUSH
20354: LD_INT 34
20356: PUSH
20357: LD_INT 36
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: PUSH
20393: LD_INT 101
20395: PUSH
20396: LD_INT 102
20398: PUSH
20399: LD_INT 103
20401: PUSH
20402: LD_INT 104
20404: PUSH
20405: LD_INT 105
20407: PUSH
20408: LD_INT 106
20410: PUSH
20411: LD_INT 107
20413: PUSH
20414: LD_INT 108
20416: PUSH
20417: LD_INT 109
20419: PUSH
20420: LD_INT 110
20422: PUSH
20423: LD_INT 111
20425: PUSH
20426: LD_INT 112
20428: PUSH
20429: LD_INT 114
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: ST_TO_ADDR
20451: GO 22038
20453: LD_INT 12
20455: DOUBLE
20456: EQUAL
20457: IFTRUE 20461
20459: GO 20669
20461: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20462: LD_ADDR_VAR 0 1
20466: PUSH
20467: LD_INT 1
20469: PUSH
20470: LD_INT 2
20472: PUSH
20473: LD_INT 3
20475: PUSH
20476: LD_INT 4
20478: PUSH
20479: LD_INT 5
20481: PUSH
20482: LD_INT 6
20484: PUSH
20485: LD_INT 7
20487: PUSH
20488: LD_INT 8
20490: PUSH
20491: LD_INT 9
20493: PUSH
20494: LD_INT 10
20496: PUSH
20497: LD_INT 11
20499: PUSH
20500: LD_INT 12
20502: PUSH
20503: LD_INT 13
20505: PUSH
20506: LD_INT 14
20508: PUSH
20509: LD_INT 15
20511: PUSH
20512: LD_INT 16
20514: PUSH
20515: LD_INT 17
20517: PUSH
20518: LD_INT 18
20520: PUSH
20521: LD_INT 19
20523: PUSH
20524: LD_INT 20
20526: PUSH
20527: LD_INT 21
20529: PUSH
20530: LD_INT 22
20532: PUSH
20533: LD_INT 23
20535: PUSH
20536: LD_INT 24
20538: PUSH
20539: LD_INT 25
20541: PUSH
20542: LD_INT 26
20544: PUSH
20545: LD_INT 27
20547: PUSH
20548: LD_INT 28
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 31
20556: PUSH
20557: LD_INT 32
20559: PUSH
20560: LD_INT 33
20562: PUSH
20563: LD_INT 34
20565: PUSH
20566: LD_INT 36
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: PUSH
20605: LD_INT 101
20607: PUSH
20608: LD_INT 102
20610: PUSH
20611: LD_INT 103
20613: PUSH
20614: LD_INT 104
20616: PUSH
20617: LD_INT 105
20619: PUSH
20620: LD_INT 106
20622: PUSH
20623: LD_INT 107
20625: PUSH
20626: LD_INT 108
20628: PUSH
20629: LD_INT 109
20631: PUSH
20632: LD_INT 110
20634: PUSH
20635: LD_INT 111
20637: PUSH
20638: LD_INT 112
20640: PUSH
20641: LD_INT 113
20643: PUSH
20644: LD_INT 114
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 22038
20669: LD_INT 13
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20873
20677: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20678: LD_ADDR_VAR 0 1
20682: PUSH
20683: LD_INT 1
20685: PUSH
20686: LD_INT 2
20688: PUSH
20689: LD_INT 3
20691: PUSH
20692: LD_INT 4
20694: PUSH
20695: LD_INT 5
20697: PUSH
20698: LD_INT 8
20700: PUSH
20701: LD_INT 9
20703: PUSH
20704: LD_INT 10
20706: PUSH
20707: LD_INT 11
20709: PUSH
20710: LD_INT 12
20712: PUSH
20713: LD_INT 14
20715: PUSH
20716: LD_INT 15
20718: PUSH
20719: LD_INT 16
20721: PUSH
20722: LD_INT 17
20724: PUSH
20725: LD_INT 18
20727: PUSH
20728: LD_INT 19
20730: PUSH
20731: LD_INT 20
20733: PUSH
20734: LD_INT 21
20736: PUSH
20737: LD_INT 22
20739: PUSH
20740: LD_INT 23
20742: PUSH
20743: LD_INT 24
20745: PUSH
20746: LD_INT 25
20748: PUSH
20749: LD_INT 26
20751: PUSH
20752: LD_INT 27
20754: PUSH
20755: LD_INT 28
20757: PUSH
20758: LD_INT 30
20760: PUSH
20761: LD_INT 31
20763: PUSH
20764: LD_INT 32
20766: PUSH
20767: LD_INT 33
20769: PUSH
20770: LD_INT 34
20772: PUSH
20773: LD_INT 36
20775: PUSH
20776: EMPTY
20777: LIST
20778: LIST
20779: LIST
20780: LIST
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: PUSH
20809: LD_INT 101
20811: PUSH
20812: LD_INT 102
20814: PUSH
20815: LD_INT 103
20817: PUSH
20818: LD_INT 104
20820: PUSH
20821: LD_INT 105
20823: PUSH
20824: LD_INT 106
20826: PUSH
20827: LD_INT 107
20829: PUSH
20830: LD_INT 108
20832: PUSH
20833: LD_INT 109
20835: PUSH
20836: LD_INT 110
20838: PUSH
20839: LD_INT 111
20841: PUSH
20842: LD_INT 112
20844: PUSH
20845: LD_INT 113
20847: PUSH
20848: LD_INT 114
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: LIST
20858: LIST
20859: LIST
20860: LIST
20861: LIST
20862: LIST
20863: LIST
20864: LIST
20865: LIST
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: ST_TO_ADDR
20871: GO 22038
20873: LD_INT 14
20875: DOUBLE
20876: EQUAL
20877: IFTRUE 20881
20879: GO 21093
20881: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20882: LD_ADDR_VAR 0 1
20886: PUSH
20887: LD_INT 1
20889: PUSH
20890: LD_INT 2
20892: PUSH
20893: LD_INT 3
20895: PUSH
20896: LD_INT 4
20898: PUSH
20899: LD_INT 5
20901: PUSH
20902: LD_INT 6
20904: PUSH
20905: LD_INT 7
20907: PUSH
20908: LD_INT 8
20910: PUSH
20911: LD_INT 9
20913: PUSH
20914: LD_INT 10
20916: PUSH
20917: LD_INT 11
20919: PUSH
20920: LD_INT 12
20922: PUSH
20923: LD_INT 13
20925: PUSH
20926: LD_INT 14
20928: PUSH
20929: LD_INT 15
20931: PUSH
20932: LD_INT 16
20934: PUSH
20935: LD_INT 17
20937: PUSH
20938: LD_INT 18
20940: PUSH
20941: LD_INT 19
20943: PUSH
20944: LD_INT 20
20946: PUSH
20947: LD_INT 21
20949: PUSH
20950: LD_INT 22
20952: PUSH
20953: LD_INT 23
20955: PUSH
20956: LD_INT 24
20958: PUSH
20959: LD_INT 25
20961: PUSH
20962: LD_INT 26
20964: PUSH
20965: LD_INT 27
20967: PUSH
20968: LD_INT 28
20970: PUSH
20971: LD_INT 29
20973: PUSH
20974: LD_INT 30
20976: PUSH
20977: LD_INT 31
20979: PUSH
20980: LD_INT 32
20982: PUSH
20983: LD_INT 33
20985: PUSH
20986: LD_INT 34
20988: PUSH
20989: LD_INT 36
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: LIST
21015: LIST
21016: LIST
21017: LIST
21018: LIST
21019: LIST
21020: LIST
21021: LIST
21022: LIST
21023: LIST
21024: LIST
21025: LIST
21026: LIST
21027: LIST
21028: PUSH
21029: LD_INT 101
21031: PUSH
21032: LD_INT 102
21034: PUSH
21035: LD_INT 103
21037: PUSH
21038: LD_INT 104
21040: PUSH
21041: LD_INT 105
21043: PUSH
21044: LD_INT 106
21046: PUSH
21047: LD_INT 107
21049: PUSH
21050: LD_INT 108
21052: PUSH
21053: LD_INT 109
21055: PUSH
21056: LD_INT 110
21058: PUSH
21059: LD_INT 111
21061: PUSH
21062: LD_INT 112
21064: PUSH
21065: LD_INT 113
21067: PUSH
21068: LD_INT 114
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: LIST
21075: LIST
21076: LIST
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: ST_TO_ADDR
21091: GO 22038
21093: LD_INT 15
21095: DOUBLE
21096: EQUAL
21097: IFTRUE 21101
21099: GO 21313
21101: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21102: LD_ADDR_VAR 0 1
21106: PUSH
21107: LD_INT 1
21109: PUSH
21110: LD_INT 2
21112: PUSH
21113: LD_INT 3
21115: PUSH
21116: LD_INT 4
21118: PUSH
21119: LD_INT 5
21121: PUSH
21122: LD_INT 6
21124: PUSH
21125: LD_INT 7
21127: PUSH
21128: LD_INT 8
21130: PUSH
21131: LD_INT 9
21133: PUSH
21134: LD_INT 10
21136: PUSH
21137: LD_INT 11
21139: PUSH
21140: LD_INT 12
21142: PUSH
21143: LD_INT 13
21145: PUSH
21146: LD_INT 14
21148: PUSH
21149: LD_INT 15
21151: PUSH
21152: LD_INT 16
21154: PUSH
21155: LD_INT 17
21157: PUSH
21158: LD_INT 18
21160: PUSH
21161: LD_INT 19
21163: PUSH
21164: LD_INT 20
21166: PUSH
21167: LD_INT 21
21169: PUSH
21170: LD_INT 22
21172: PUSH
21173: LD_INT 23
21175: PUSH
21176: LD_INT 24
21178: PUSH
21179: LD_INT 25
21181: PUSH
21182: LD_INT 26
21184: PUSH
21185: LD_INT 27
21187: PUSH
21188: LD_INT 28
21190: PUSH
21191: LD_INT 29
21193: PUSH
21194: LD_INT 30
21196: PUSH
21197: LD_INT 31
21199: PUSH
21200: LD_INT 32
21202: PUSH
21203: LD_INT 33
21205: PUSH
21206: LD_INT 34
21208: PUSH
21209: LD_INT 36
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: LIST
21216: LIST
21217: LIST
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: LIST
21245: LIST
21246: LIST
21247: LIST
21248: PUSH
21249: LD_INT 101
21251: PUSH
21252: LD_INT 102
21254: PUSH
21255: LD_INT 103
21257: PUSH
21258: LD_INT 104
21260: PUSH
21261: LD_INT 105
21263: PUSH
21264: LD_INT 106
21266: PUSH
21267: LD_INT 107
21269: PUSH
21270: LD_INT 108
21272: PUSH
21273: LD_INT 109
21275: PUSH
21276: LD_INT 110
21278: PUSH
21279: LD_INT 111
21281: PUSH
21282: LD_INT 112
21284: PUSH
21285: LD_INT 113
21287: PUSH
21288: LD_INT 114
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: LIST
21295: LIST
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: ST_TO_ADDR
21311: GO 22038
21313: LD_INT 16
21315: DOUBLE
21316: EQUAL
21317: IFTRUE 21321
21319: GO 21445
21321: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21322: LD_ADDR_VAR 0 1
21326: PUSH
21327: LD_INT 2
21329: PUSH
21330: LD_INT 4
21332: PUSH
21333: LD_INT 5
21335: PUSH
21336: LD_INT 7
21338: PUSH
21339: LD_INT 11
21341: PUSH
21342: LD_INT 12
21344: PUSH
21345: LD_INT 15
21347: PUSH
21348: LD_INT 16
21350: PUSH
21351: LD_INT 20
21353: PUSH
21354: LD_INT 21
21356: PUSH
21357: LD_INT 22
21359: PUSH
21360: LD_INT 23
21362: PUSH
21363: LD_INT 25
21365: PUSH
21366: LD_INT 26
21368: PUSH
21369: LD_INT 30
21371: PUSH
21372: LD_INT 31
21374: PUSH
21375: LD_INT 32
21377: PUSH
21378: LD_INT 33
21380: PUSH
21381: LD_INT 34
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: LIST
21402: LIST
21403: LIST
21404: PUSH
21405: LD_INT 101
21407: PUSH
21408: LD_INT 102
21410: PUSH
21411: LD_INT 103
21413: PUSH
21414: LD_INT 106
21416: PUSH
21417: LD_INT 108
21419: PUSH
21420: LD_INT 112
21422: PUSH
21423: LD_INT 113
21425: PUSH
21426: LD_INT 114
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: ST_TO_ADDR
21443: GO 22038
21445: LD_INT 17
21447: DOUBLE
21448: EQUAL
21449: IFTRUE 21453
21451: GO 21665
21453: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21454: LD_ADDR_VAR 0 1
21458: PUSH
21459: LD_INT 1
21461: PUSH
21462: LD_INT 2
21464: PUSH
21465: LD_INT 3
21467: PUSH
21468: LD_INT 4
21470: PUSH
21471: LD_INT 5
21473: PUSH
21474: LD_INT 6
21476: PUSH
21477: LD_INT 7
21479: PUSH
21480: LD_INT 8
21482: PUSH
21483: LD_INT 9
21485: PUSH
21486: LD_INT 10
21488: PUSH
21489: LD_INT 11
21491: PUSH
21492: LD_INT 12
21494: PUSH
21495: LD_INT 13
21497: PUSH
21498: LD_INT 14
21500: PUSH
21501: LD_INT 15
21503: PUSH
21504: LD_INT 16
21506: PUSH
21507: LD_INT 17
21509: PUSH
21510: LD_INT 18
21512: PUSH
21513: LD_INT 19
21515: PUSH
21516: LD_INT 20
21518: PUSH
21519: LD_INT 21
21521: PUSH
21522: LD_INT 22
21524: PUSH
21525: LD_INT 23
21527: PUSH
21528: LD_INT 24
21530: PUSH
21531: LD_INT 25
21533: PUSH
21534: LD_INT 26
21536: PUSH
21537: LD_INT 27
21539: PUSH
21540: LD_INT 28
21542: PUSH
21543: LD_INT 29
21545: PUSH
21546: LD_INT 30
21548: PUSH
21549: LD_INT 31
21551: PUSH
21552: LD_INT 32
21554: PUSH
21555: LD_INT 33
21557: PUSH
21558: LD_INT 34
21560: PUSH
21561: LD_INT 36
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: LIST
21568: LIST
21569: LIST
21570: LIST
21571: LIST
21572: LIST
21573: LIST
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: LIST
21599: LIST
21600: PUSH
21601: LD_INT 101
21603: PUSH
21604: LD_INT 102
21606: PUSH
21607: LD_INT 103
21609: PUSH
21610: LD_INT 104
21612: PUSH
21613: LD_INT 105
21615: PUSH
21616: LD_INT 106
21618: PUSH
21619: LD_INT 107
21621: PUSH
21622: LD_INT 108
21624: PUSH
21625: LD_INT 109
21627: PUSH
21628: LD_INT 110
21630: PUSH
21631: LD_INT 111
21633: PUSH
21634: LD_INT 112
21636: PUSH
21637: LD_INT 113
21639: PUSH
21640: LD_INT 114
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: ST_TO_ADDR
21663: GO 22038
21665: LD_INT 18
21667: DOUBLE
21668: EQUAL
21669: IFTRUE 21673
21671: GO 21809
21673: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21674: LD_ADDR_VAR 0 1
21678: PUSH
21679: LD_INT 2
21681: PUSH
21682: LD_INT 4
21684: PUSH
21685: LD_INT 5
21687: PUSH
21688: LD_INT 7
21690: PUSH
21691: LD_INT 11
21693: PUSH
21694: LD_INT 12
21696: PUSH
21697: LD_INT 15
21699: PUSH
21700: LD_INT 16
21702: PUSH
21703: LD_INT 20
21705: PUSH
21706: LD_INT 21
21708: PUSH
21709: LD_INT 22
21711: PUSH
21712: LD_INT 23
21714: PUSH
21715: LD_INT 25
21717: PUSH
21718: LD_INT 26
21720: PUSH
21721: LD_INT 30
21723: PUSH
21724: LD_INT 31
21726: PUSH
21727: LD_INT 32
21729: PUSH
21730: LD_INT 33
21732: PUSH
21733: LD_INT 34
21735: PUSH
21736: LD_INT 35
21738: PUSH
21739: LD_INT 36
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: LIST
21746: LIST
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: LIST
21757: LIST
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: LIST
21763: LIST
21764: PUSH
21765: LD_INT 101
21767: PUSH
21768: LD_INT 102
21770: PUSH
21771: LD_INT 103
21773: PUSH
21774: LD_INT 106
21776: PUSH
21777: LD_INT 108
21779: PUSH
21780: LD_INT 112
21782: PUSH
21783: LD_INT 113
21785: PUSH
21786: LD_INT 114
21788: PUSH
21789: LD_INT 115
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: ST_TO_ADDR
21807: GO 22038
21809: LD_INT 19
21811: DOUBLE
21812: EQUAL
21813: IFTRUE 21817
21815: GO 22037
21817: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21818: LD_ADDR_VAR 0 1
21822: PUSH
21823: LD_INT 1
21825: PUSH
21826: LD_INT 2
21828: PUSH
21829: LD_INT 3
21831: PUSH
21832: LD_INT 4
21834: PUSH
21835: LD_INT 5
21837: PUSH
21838: LD_INT 6
21840: PUSH
21841: LD_INT 7
21843: PUSH
21844: LD_INT 8
21846: PUSH
21847: LD_INT 9
21849: PUSH
21850: LD_INT 10
21852: PUSH
21853: LD_INT 11
21855: PUSH
21856: LD_INT 12
21858: PUSH
21859: LD_INT 13
21861: PUSH
21862: LD_INT 14
21864: PUSH
21865: LD_INT 15
21867: PUSH
21868: LD_INT 16
21870: PUSH
21871: LD_INT 17
21873: PUSH
21874: LD_INT 18
21876: PUSH
21877: LD_INT 19
21879: PUSH
21880: LD_INT 20
21882: PUSH
21883: LD_INT 21
21885: PUSH
21886: LD_INT 22
21888: PUSH
21889: LD_INT 23
21891: PUSH
21892: LD_INT 24
21894: PUSH
21895: LD_INT 25
21897: PUSH
21898: LD_INT 26
21900: PUSH
21901: LD_INT 27
21903: PUSH
21904: LD_INT 28
21906: PUSH
21907: LD_INT 29
21909: PUSH
21910: LD_INT 30
21912: PUSH
21913: LD_INT 31
21915: PUSH
21916: LD_INT 32
21918: PUSH
21919: LD_INT 33
21921: PUSH
21922: LD_INT 34
21924: PUSH
21925: LD_INT 35
21927: PUSH
21928: LD_INT 36
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: LIST
21953: LIST
21954: LIST
21955: LIST
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: LIST
21961: LIST
21962: LIST
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: PUSH
21969: LD_INT 101
21971: PUSH
21972: LD_INT 102
21974: PUSH
21975: LD_INT 103
21977: PUSH
21978: LD_INT 104
21980: PUSH
21981: LD_INT 105
21983: PUSH
21984: LD_INT 106
21986: PUSH
21987: LD_INT 107
21989: PUSH
21990: LD_INT 108
21992: PUSH
21993: LD_INT 109
21995: PUSH
21996: LD_INT 110
21998: PUSH
21999: LD_INT 111
22001: PUSH
22002: LD_INT 112
22004: PUSH
22005: LD_INT 113
22007: PUSH
22008: LD_INT 114
22010: PUSH
22011: LD_INT 115
22013: PUSH
22014: EMPTY
22015: LIST
22016: LIST
22017: LIST
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: LIST
22026: LIST
22027: LIST
22028: LIST
22029: LIST
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: ST_TO_ADDR
22035: GO 22038
22037: POP
// end ; if result then
22038: LD_VAR 0 1
22042: IFFALSE 22331
// begin normal :=  ;
22044: LD_ADDR_VAR 0 3
22048: PUSH
22049: LD_STRING 
22051: ST_TO_ADDR
// hardcore :=  ;
22052: LD_ADDR_VAR 0 4
22056: PUSH
22057: LD_STRING 
22059: ST_TO_ADDR
// for i = 1 to normalCounter do
22060: LD_ADDR_VAR 0 5
22064: PUSH
22065: DOUBLE
22066: LD_INT 1
22068: DEC
22069: ST_TO_ADDR
22070: LD_EXP 60
22074: PUSH
22075: FOR_TO
22076: IFFALSE 22177
// begin tmp := 0 ;
22078: LD_ADDR_VAR 0 2
22082: PUSH
22083: LD_STRING 0
22085: ST_TO_ADDR
// if result [ 1 ] then
22086: LD_VAR 0 1
22090: PUSH
22091: LD_INT 1
22093: ARRAY
22094: IFFALSE 22159
// if result [ 1 ] [ 1 ] = i then
22096: LD_VAR 0 1
22100: PUSH
22101: LD_INT 1
22103: ARRAY
22104: PUSH
22105: LD_INT 1
22107: ARRAY
22108: PUSH
22109: LD_VAR 0 5
22113: EQUAL
22114: IFFALSE 22159
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22116: LD_ADDR_VAR 0 1
22120: PUSH
22121: LD_VAR 0 1
22125: PPUSH
22126: LD_INT 1
22128: PPUSH
22129: LD_VAR 0 1
22133: PUSH
22134: LD_INT 1
22136: ARRAY
22137: PPUSH
22138: LD_INT 1
22140: PPUSH
22141: CALL_OW 3
22145: PPUSH
22146: CALL_OW 1
22150: ST_TO_ADDR
// tmp := 1 ;
22151: LD_ADDR_VAR 0 2
22155: PUSH
22156: LD_STRING 1
22158: ST_TO_ADDR
// end ; normal := normal & tmp ;
22159: LD_ADDR_VAR 0 3
22163: PUSH
22164: LD_VAR 0 3
22168: PUSH
22169: LD_VAR 0 2
22173: STR
22174: ST_TO_ADDR
// end ;
22175: GO 22075
22177: POP
22178: POP
// for i = 1 to hardcoreCounter do
22179: LD_ADDR_VAR 0 5
22183: PUSH
22184: DOUBLE
22185: LD_INT 1
22187: DEC
22188: ST_TO_ADDR
22189: LD_EXP 61
22193: PUSH
22194: FOR_TO
22195: IFFALSE 22300
// begin tmp := 0 ;
22197: LD_ADDR_VAR 0 2
22201: PUSH
22202: LD_STRING 0
22204: ST_TO_ADDR
// if result [ 2 ] then
22205: LD_VAR 0 1
22209: PUSH
22210: LD_INT 2
22212: ARRAY
22213: IFFALSE 22282
// if result [ 2 ] [ 1 ] = 100 + i then
22215: LD_VAR 0 1
22219: PUSH
22220: LD_INT 2
22222: ARRAY
22223: PUSH
22224: LD_INT 1
22226: ARRAY
22227: PUSH
22228: LD_INT 100
22230: PUSH
22231: LD_VAR 0 5
22235: PLUS
22236: EQUAL
22237: IFFALSE 22282
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22239: LD_ADDR_VAR 0 1
22243: PUSH
22244: LD_VAR 0 1
22248: PPUSH
22249: LD_INT 2
22251: PPUSH
22252: LD_VAR 0 1
22256: PUSH
22257: LD_INT 2
22259: ARRAY
22260: PPUSH
22261: LD_INT 1
22263: PPUSH
22264: CALL_OW 3
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// tmp := 1 ;
22274: LD_ADDR_VAR 0 2
22278: PUSH
22279: LD_STRING 1
22281: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22282: LD_ADDR_VAR 0 4
22286: PUSH
22287: LD_VAR 0 4
22291: PUSH
22292: LD_VAR 0 2
22296: STR
22297: ST_TO_ADDR
// end ;
22298: GO 22194
22300: POP
22301: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22302: LD_STRING getStreamItemsFromMission("
22304: PUSH
22305: LD_VAR 0 3
22309: STR
22310: PUSH
22311: LD_STRING ","
22313: STR
22314: PUSH
22315: LD_VAR 0 4
22319: STR
22320: PUSH
22321: LD_STRING ")
22323: STR
22324: PPUSH
22325: CALL_OW 559
// end else
22329: GO 22338
// ToLua ( getStreamItemsFromMission("","") ) ;
22331: LD_STRING getStreamItemsFromMission("","")
22333: PPUSH
22334: CALL_OW 559
// end ;
22338: LD_VAR 0 1
22342: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22343: LD_VAR 0 2
22347: PUSH
22348: LD_INT 100
22350: EQUAL
22351: IFFALSE 23300
// begin if not StreamModeActive then
22353: LD_EXP 59
22357: NOT
22358: IFFALSE 22368
// StreamModeActive := true ;
22360: LD_ADDR_EXP 59
22364: PUSH
22365: LD_INT 1
22367: ST_TO_ADDR
// if p3 = 0 then
22368: LD_VAR 0 3
22372: PUSH
22373: LD_INT 0
22375: EQUAL
22376: IFFALSE 22382
// InitStreamMode ;
22378: CALL 18640 0 0
// if p3 = 1 then
22382: LD_VAR 0 3
22386: PUSH
22387: LD_INT 1
22389: EQUAL
22390: IFFALSE 22400
// sRocket := true ;
22392: LD_ADDR_EXP 64
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
// if p3 = 2 then
22400: LD_VAR 0 3
22404: PUSH
22405: LD_INT 2
22407: EQUAL
22408: IFFALSE 22418
// sSpeed := true ;
22410: LD_ADDR_EXP 63
22414: PUSH
22415: LD_INT 1
22417: ST_TO_ADDR
// if p3 = 3 then
22418: LD_VAR 0 3
22422: PUSH
22423: LD_INT 3
22425: EQUAL
22426: IFFALSE 22436
// sEngine := true ;
22428: LD_ADDR_EXP 65
22432: PUSH
22433: LD_INT 1
22435: ST_TO_ADDR
// if p3 = 4 then
22436: LD_VAR 0 3
22440: PUSH
22441: LD_INT 4
22443: EQUAL
22444: IFFALSE 22454
// sSpec := true ;
22446: LD_ADDR_EXP 62
22450: PUSH
22451: LD_INT 1
22453: ST_TO_ADDR
// if p3 = 5 then
22454: LD_VAR 0 3
22458: PUSH
22459: LD_INT 5
22461: EQUAL
22462: IFFALSE 22472
// sLevel := true ;
22464: LD_ADDR_EXP 66
22468: PUSH
22469: LD_INT 1
22471: ST_TO_ADDR
// if p3 = 6 then
22472: LD_VAR 0 3
22476: PUSH
22477: LD_INT 6
22479: EQUAL
22480: IFFALSE 22490
// sArmoury := true ;
22482: LD_ADDR_EXP 67
22486: PUSH
22487: LD_INT 1
22489: ST_TO_ADDR
// if p3 = 7 then
22490: LD_VAR 0 3
22494: PUSH
22495: LD_INT 7
22497: EQUAL
22498: IFFALSE 22508
// sRadar := true ;
22500: LD_ADDR_EXP 68
22504: PUSH
22505: LD_INT 1
22507: ST_TO_ADDR
// if p3 = 8 then
22508: LD_VAR 0 3
22512: PUSH
22513: LD_INT 8
22515: EQUAL
22516: IFFALSE 22526
// sBunker := true ;
22518: LD_ADDR_EXP 69
22522: PUSH
22523: LD_INT 1
22525: ST_TO_ADDR
// if p3 = 9 then
22526: LD_VAR 0 3
22530: PUSH
22531: LD_INT 9
22533: EQUAL
22534: IFFALSE 22544
// sHack := true ;
22536: LD_ADDR_EXP 70
22540: PUSH
22541: LD_INT 1
22543: ST_TO_ADDR
// if p3 = 10 then
22544: LD_VAR 0 3
22548: PUSH
22549: LD_INT 10
22551: EQUAL
22552: IFFALSE 22562
// sFire := true ;
22554: LD_ADDR_EXP 71
22558: PUSH
22559: LD_INT 1
22561: ST_TO_ADDR
// if p3 = 11 then
22562: LD_VAR 0 3
22566: PUSH
22567: LD_INT 11
22569: EQUAL
22570: IFFALSE 22580
// sRefresh := true ;
22572: LD_ADDR_EXP 72
22576: PUSH
22577: LD_INT 1
22579: ST_TO_ADDR
// if p3 = 12 then
22580: LD_VAR 0 3
22584: PUSH
22585: LD_INT 12
22587: EQUAL
22588: IFFALSE 22598
// sExp := true ;
22590: LD_ADDR_EXP 73
22594: PUSH
22595: LD_INT 1
22597: ST_TO_ADDR
// if p3 = 13 then
22598: LD_VAR 0 3
22602: PUSH
22603: LD_INT 13
22605: EQUAL
22606: IFFALSE 22616
// sDepot := true ;
22608: LD_ADDR_EXP 74
22612: PUSH
22613: LD_INT 1
22615: ST_TO_ADDR
// if p3 = 14 then
22616: LD_VAR 0 3
22620: PUSH
22621: LD_INT 14
22623: EQUAL
22624: IFFALSE 22634
// sFlag := true ;
22626: LD_ADDR_EXP 75
22630: PUSH
22631: LD_INT 1
22633: ST_TO_ADDR
// if p3 = 15 then
22634: LD_VAR 0 3
22638: PUSH
22639: LD_INT 15
22641: EQUAL
22642: IFFALSE 22652
// sKamikadze := true ;
22644: LD_ADDR_EXP 83
22648: PUSH
22649: LD_INT 1
22651: ST_TO_ADDR
// if p3 = 16 then
22652: LD_VAR 0 3
22656: PUSH
22657: LD_INT 16
22659: EQUAL
22660: IFFALSE 22670
// sTroll := true ;
22662: LD_ADDR_EXP 84
22666: PUSH
22667: LD_INT 1
22669: ST_TO_ADDR
// if p3 = 17 then
22670: LD_VAR 0 3
22674: PUSH
22675: LD_INT 17
22677: EQUAL
22678: IFFALSE 22688
// sSlow := true ;
22680: LD_ADDR_EXP 85
22684: PUSH
22685: LD_INT 1
22687: ST_TO_ADDR
// if p3 = 18 then
22688: LD_VAR 0 3
22692: PUSH
22693: LD_INT 18
22695: EQUAL
22696: IFFALSE 22706
// sLack := true ;
22698: LD_ADDR_EXP 86
22702: PUSH
22703: LD_INT 1
22705: ST_TO_ADDR
// if p3 = 19 then
22706: LD_VAR 0 3
22710: PUSH
22711: LD_INT 19
22713: EQUAL
22714: IFFALSE 22724
// sTank := true ;
22716: LD_ADDR_EXP 88
22720: PUSH
22721: LD_INT 1
22723: ST_TO_ADDR
// if p3 = 20 then
22724: LD_VAR 0 3
22728: PUSH
22729: LD_INT 20
22731: EQUAL
22732: IFFALSE 22742
// sRemote := true ;
22734: LD_ADDR_EXP 89
22738: PUSH
22739: LD_INT 1
22741: ST_TO_ADDR
// if p3 = 21 then
22742: LD_VAR 0 3
22746: PUSH
22747: LD_INT 21
22749: EQUAL
22750: IFFALSE 22760
// sPowell := true ;
22752: LD_ADDR_EXP 90
22756: PUSH
22757: LD_INT 1
22759: ST_TO_ADDR
// if p3 = 22 then
22760: LD_VAR 0 3
22764: PUSH
22765: LD_INT 22
22767: EQUAL
22768: IFFALSE 22778
// sTeleport := true ;
22770: LD_ADDR_EXP 93
22774: PUSH
22775: LD_INT 1
22777: ST_TO_ADDR
// if p3 = 23 then
22778: LD_VAR 0 3
22782: PUSH
22783: LD_INT 23
22785: EQUAL
22786: IFFALSE 22796
// sOilTower := true ;
22788: LD_ADDR_EXP 95
22792: PUSH
22793: LD_INT 1
22795: ST_TO_ADDR
// if p3 = 24 then
22796: LD_VAR 0 3
22800: PUSH
22801: LD_INT 24
22803: EQUAL
22804: IFFALSE 22814
// sShovel := true ;
22806: LD_ADDR_EXP 96
22810: PUSH
22811: LD_INT 1
22813: ST_TO_ADDR
// if p3 = 25 then
22814: LD_VAR 0 3
22818: PUSH
22819: LD_INT 25
22821: EQUAL
22822: IFFALSE 22832
// sSheik := true ;
22824: LD_ADDR_EXP 97
22828: PUSH
22829: LD_INT 1
22831: ST_TO_ADDR
// if p3 = 26 then
22832: LD_VAR 0 3
22836: PUSH
22837: LD_INT 26
22839: EQUAL
22840: IFFALSE 22850
// sEarthquake := true ;
22842: LD_ADDR_EXP 99
22846: PUSH
22847: LD_INT 1
22849: ST_TO_ADDR
// if p3 = 27 then
22850: LD_VAR 0 3
22854: PUSH
22855: LD_INT 27
22857: EQUAL
22858: IFFALSE 22868
// sAI := true ;
22860: LD_ADDR_EXP 100
22864: PUSH
22865: LD_INT 1
22867: ST_TO_ADDR
// if p3 = 28 then
22868: LD_VAR 0 3
22872: PUSH
22873: LD_INT 28
22875: EQUAL
22876: IFFALSE 22886
// sCargo := true ;
22878: LD_ADDR_EXP 103
22882: PUSH
22883: LD_INT 1
22885: ST_TO_ADDR
// if p3 = 29 then
22886: LD_VAR 0 3
22890: PUSH
22891: LD_INT 29
22893: EQUAL
22894: IFFALSE 22904
// sDLaser := true ;
22896: LD_ADDR_EXP 104
22900: PUSH
22901: LD_INT 1
22903: ST_TO_ADDR
// if p3 = 30 then
22904: LD_VAR 0 3
22908: PUSH
22909: LD_INT 30
22911: EQUAL
22912: IFFALSE 22922
// sExchange := true ;
22914: LD_ADDR_EXP 105
22918: PUSH
22919: LD_INT 1
22921: ST_TO_ADDR
// if p3 = 31 then
22922: LD_VAR 0 3
22926: PUSH
22927: LD_INT 31
22929: EQUAL
22930: IFFALSE 22940
// sFac := true ;
22932: LD_ADDR_EXP 106
22936: PUSH
22937: LD_INT 1
22939: ST_TO_ADDR
// if p3 = 32 then
22940: LD_VAR 0 3
22944: PUSH
22945: LD_INT 32
22947: EQUAL
22948: IFFALSE 22958
// sPower := true ;
22950: LD_ADDR_EXP 107
22954: PUSH
22955: LD_INT 1
22957: ST_TO_ADDR
// if p3 = 33 then
22958: LD_VAR 0 3
22962: PUSH
22963: LD_INT 33
22965: EQUAL
22966: IFFALSE 22976
// sRandom := true ;
22968: LD_ADDR_EXP 108
22972: PUSH
22973: LD_INT 1
22975: ST_TO_ADDR
// if p3 = 34 then
22976: LD_VAR 0 3
22980: PUSH
22981: LD_INT 34
22983: EQUAL
22984: IFFALSE 22994
// sShield := true ;
22986: LD_ADDR_EXP 109
22990: PUSH
22991: LD_INT 1
22993: ST_TO_ADDR
// if p3 = 35 then
22994: LD_VAR 0 3
22998: PUSH
22999: LD_INT 35
23001: EQUAL
23002: IFFALSE 23012
// sTime := true ;
23004: LD_ADDR_EXP 110
23008: PUSH
23009: LD_INT 1
23011: ST_TO_ADDR
// if p3 = 36 then
23012: LD_VAR 0 3
23016: PUSH
23017: LD_INT 36
23019: EQUAL
23020: IFFALSE 23030
// sTools := true ;
23022: LD_ADDR_EXP 111
23026: PUSH
23027: LD_INT 1
23029: ST_TO_ADDR
// if p3 = 101 then
23030: LD_VAR 0 3
23034: PUSH
23035: LD_INT 101
23037: EQUAL
23038: IFFALSE 23048
// sSold := true ;
23040: LD_ADDR_EXP 76
23044: PUSH
23045: LD_INT 1
23047: ST_TO_ADDR
// if p3 = 102 then
23048: LD_VAR 0 3
23052: PUSH
23053: LD_INT 102
23055: EQUAL
23056: IFFALSE 23066
// sDiff := true ;
23058: LD_ADDR_EXP 77
23062: PUSH
23063: LD_INT 1
23065: ST_TO_ADDR
// if p3 = 103 then
23066: LD_VAR 0 3
23070: PUSH
23071: LD_INT 103
23073: EQUAL
23074: IFFALSE 23084
// sFog := true ;
23076: LD_ADDR_EXP 80
23080: PUSH
23081: LD_INT 1
23083: ST_TO_ADDR
// if p3 = 104 then
23084: LD_VAR 0 3
23088: PUSH
23089: LD_INT 104
23091: EQUAL
23092: IFFALSE 23102
// sReset := true ;
23094: LD_ADDR_EXP 81
23098: PUSH
23099: LD_INT 1
23101: ST_TO_ADDR
// if p3 = 105 then
23102: LD_VAR 0 3
23106: PUSH
23107: LD_INT 105
23109: EQUAL
23110: IFFALSE 23120
// sSun := true ;
23112: LD_ADDR_EXP 82
23116: PUSH
23117: LD_INT 1
23119: ST_TO_ADDR
// if p3 = 106 then
23120: LD_VAR 0 3
23124: PUSH
23125: LD_INT 106
23127: EQUAL
23128: IFFALSE 23138
// sTiger := true ;
23130: LD_ADDR_EXP 78
23134: PUSH
23135: LD_INT 1
23137: ST_TO_ADDR
// if p3 = 107 then
23138: LD_VAR 0 3
23142: PUSH
23143: LD_INT 107
23145: EQUAL
23146: IFFALSE 23156
// sBomb := true ;
23148: LD_ADDR_EXP 79
23152: PUSH
23153: LD_INT 1
23155: ST_TO_ADDR
// if p3 = 108 then
23156: LD_VAR 0 3
23160: PUSH
23161: LD_INT 108
23163: EQUAL
23164: IFFALSE 23174
// sWound := true ;
23166: LD_ADDR_EXP 87
23170: PUSH
23171: LD_INT 1
23173: ST_TO_ADDR
// if p3 = 109 then
23174: LD_VAR 0 3
23178: PUSH
23179: LD_INT 109
23181: EQUAL
23182: IFFALSE 23192
// sBetray := true ;
23184: LD_ADDR_EXP 91
23188: PUSH
23189: LD_INT 1
23191: ST_TO_ADDR
// if p3 = 110 then
23192: LD_VAR 0 3
23196: PUSH
23197: LD_INT 110
23199: EQUAL
23200: IFFALSE 23210
// sContamin := true ;
23202: LD_ADDR_EXP 92
23206: PUSH
23207: LD_INT 1
23209: ST_TO_ADDR
// if p3 = 111 then
23210: LD_VAR 0 3
23214: PUSH
23215: LD_INT 111
23217: EQUAL
23218: IFFALSE 23228
// sOil := true ;
23220: LD_ADDR_EXP 94
23224: PUSH
23225: LD_INT 1
23227: ST_TO_ADDR
// if p3 = 112 then
23228: LD_VAR 0 3
23232: PUSH
23233: LD_INT 112
23235: EQUAL
23236: IFFALSE 23246
// sStu := true ;
23238: LD_ADDR_EXP 98
23242: PUSH
23243: LD_INT 1
23245: ST_TO_ADDR
// if p3 = 113 then
23246: LD_VAR 0 3
23250: PUSH
23251: LD_INT 113
23253: EQUAL
23254: IFFALSE 23264
// sBazooka := true ;
23256: LD_ADDR_EXP 101
23260: PUSH
23261: LD_INT 1
23263: ST_TO_ADDR
// if p3 = 114 then
23264: LD_VAR 0 3
23268: PUSH
23269: LD_INT 114
23271: EQUAL
23272: IFFALSE 23282
// sMortar := true ;
23274: LD_ADDR_EXP 102
23278: PUSH
23279: LD_INT 1
23281: ST_TO_ADDR
// if p3 = 115 then
23282: LD_VAR 0 3
23286: PUSH
23287: LD_INT 115
23289: EQUAL
23290: IFFALSE 23300
// sRanger := true ;
23292: LD_ADDR_EXP 112
23296: PUSH
23297: LD_INT 1
23299: ST_TO_ADDR
// end ; end ;
23300: PPOPN 6
23302: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23303: LD_EXP 59
23307: PUSH
23308: LD_EXP 64
23312: AND
23313: IFFALSE 23437
23315: GO 23317
23317: DISABLE
23318: LD_INT 0
23320: PPUSH
23321: PPUSH
// begin enable ;
23322: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23323: LD_ADDR_VAR 0 2
23327: PUSH
23328: LD_INT 22
23330: PUSH
23331: LD_OWVAR 2
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 2
23342: PUSH
23343: LD_INT 34
23345: PUSH
23346: LD_INT 7
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PUSH
23353: LD_INT 34
23355: PUSH
23356: LD_INT 45
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: PUSH
23363: LD_INT 34
23365: PUSH
23366: LD_INT 28
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: PUSH
23373: LD_INT 34
23375: PUSH
23376: LD_INT 47
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PPUSH
23394: CALL_OW 69
23398: ST_TO_ADDR
// if not tmp then
23399: LD_VAR 0 2
23403: NOT
23404: IFFALSE 23408
// exit ;
23406: GO 23437
// for i in tmp do
23408: LD_ADDR_VAR 0 1
23412: PUSH
23413: LD_VAR 0 2
23417: PUSH
23418: FOR_IN
23419: IFFALSE 23435
// begin SetLives ( i , 0 ) ;
23421: LD_VAR 0 1
23425: PPUSH
23426: LD_INT 0
23428: PPUSH
23429: CALL_OW 234
// end ;
23433: GO 23418
23435: POP
23436: POP
// end ;
23437: PPOPN 2
23439: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23440: LD_EXP 59
23444: PUSH
23445: LD_EXP 65
23449: AND
23450: IFFALSE 23534
23452: GO 23454
23454: DISABLE
23455: LD_INT 0
23457: PPUSH
23458: PPUSH
// begin enable ;
23459: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23460: LD_ADDR_VAR 0 2
23464: PUSH
23465: LD_INT 22
23467: PUSH
23468: LD_OWVAR 2
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 32
23479: PUSH
23480: LD_INT 3
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PPUSH
23491: CALL_OW 69
23495: ST_TO_ADDR
// if not tmp then
23496: LD_VAR 0 2
23500: NOT
23501: IFFALSE 23505
// exit ;
23503: GO 23534
// for i in tmp do
23505: LD_ADDR_VAR 0 1
23509: PUSH
23510: LD_VAR 0 2
23514: PUSH
23515: FOR_IN
23516: IFFALSE 23532
// begin SetLives ( i , 0 ) ;
23518: LD_VAR 0 1
23522: PPUSH
23523: LD_INT 0
23525: PPUSH
23526: CALL_OW 234
// end ;
23530: GO 23515
23532: POP
23533: POP
// end ;
23534: PPOPN 2
23536: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23537: LD_EXP 59
23541: PUSH
23542: LD_EXP 62
23546: AND
23547: IFFALSE 23640
23549: GO 23551
23551: DISABLE
23552: LD_INT 0
23554: PPUSH
// begin enable ;
23555: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23556: LD_ADDR_VAR 0 1
23560: PUSH
23561: LD_INT 22
23563: PUSH
23564: LD_OWVAR 2
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PUSH
23573: LD_INT 2
23575: PUSH
23576: LD_INT 25
23578: PUSH
23579: LD_INT 5
23581: PUSH
23582: EMPTY
23583: LIST
23584: LIST
23585: PUSH
23586: LD_INT 25
23588: PUSH
23589: LD_INT 9
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PUSH
23596: LD_INT 25
23598: PUSH
23599: LD_INT 8
23601: PUSH
23602: EMPTY
23603: LIST
23604: LIST
23605: PUSH
23606: EMPTY
23607: LIST
23608: LIST
23609: LIST
23610: LIST
23611: PUSH
23612: EMPTY
23613: LIST
23614: LIST
23615: PPUSH
23616: CALL_OW 69
23620: PUSH
23621: FOR_IN
23622: IFFALSE 23638
// begin SetClass ( i , 1 ) ;
23624: LD_VAR 0 1
23628: PPUSH
23629: LD_INT 1
23631: PPUSH
23632: CALL_OW 336
// end ;
23636: GO 23621
23638: POP
23639: POP
// end ;
23640: PPOPN 1
23642: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23643: LD_EXP 59
23647: PUSH
23648: LD_EXP 63
23652: AND
23653: PUSH
23654: LD_OWVAR 65
23658: PUSH
23659: LD_INT 7
23661: LESS
23662: AND
23663: IFFALSE 23677
23665: GO 23667
23667: DISABLE
// begin enable ;
23668: ENABLE
// game_speed := 7 ;
23669: LD_ADDR_OWVAR 65
23673: PUSH
23674: LD_INT 7
23676: ST_TO_ADDR
// end ;
23677: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23678: LD_EXP 59
23682: PUSH
23683: LD_EXP 66
23687: AND
23688: IFFALSE 23890
23690: GO 23692
23692: DISABLE
23693: LD_INT 0
23695: PPUSH
23696: PPUSH
23697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23698: LD_ADDR_VAR 0 3
23702: PUSH
23703: LD_INT 81
23705: PUSH
23706: LD_OWVAR 2
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: PUSH
23715: LD_INT 21
23717: PUSH
23718: LD_INT 1
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: PPUSH
23729: CALL_OW 69
23733: ST_TO_ADDR
// if not tmp then
23734: LD_VAR 0 3
23738: NOT
23739: IFFALSE 23743
// exit ;
23741: GO 23890
// if tmp > 5 then
23743: LD_VAR 0 3
23747: PUSH
23748: LD_INT 5
23750: GREATER
23751: IFFALSE 23763
// k := 5 else
23753: LD_ADDR_VAR 0 2
23757: PUSH
23758: LD_INT 5
23760: ST_TO_ADDR
23761: GO 23773
// k := tmp ;
23763: LD_ADDR_VAR 0 2
23767: PUSH
23768: LD_VAR 0 3
23772: ST_TO_ADDR
// for i := 1 to k do
23773: LD_ADDR_VAR 0 1
23777: PUSH
23778: DOUBLE
23779: LD_INT 1
23781: DEC
23782: ST_TO_ADDR
23783: LD_VAR 0 2
23787: PUSH
23788: FOR_TO
23789: IFFALSE 23888
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23791: LD_VAR 0 3
23795: PUSH
23796: LD_VAR 0 1
23800: ARRAY
23801: PPUSH
23802: LD_VAR 0 1
23806: PUSH
23807: LD_INT 4
23809: MOD
23810: PUSH
23811: LD_INT 1
23813: PLUS
23814: PPUSH
23815: CALL_OW 259
23819: PUSH
23820: LD_INT 10
23822: LESS
23823: IFFALSE 23886
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23825: LD_VAR 0 3
23829: PUSH
23830: LD_VAR 0 1
23834: ARRAY
23835: PPUSH
23836: LD_VAR 0 1
23840: PUSH
23841: LD_INT 4
23843: MOD
23844: PUSH
23845: LD_INT 1
23847: PLUS
23848: PPUSH
23849: LD_VAR 0 3
23853: PUSH
23854: LD_VAR 0 1
23858: ARRAY
23859: PPUSH
23860: LD_VAR 0 1
23864: PUSH
23865: LD_INT 4
23867: MOD
23868: PUSH
23869: LD_INT 1
23871: PLUS
23872: PPUSH
23873: CALL_OW 259
23877: PUSH
23878: LD_INT 1
23880: PLUS
23881: PPUSH
23882: CALL_OW 237
23886: GO 23788
23888: POP
23889: POP
// end ;
23890: PPOPN 3
23892: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23893: LD_EXP 59
23897: PUSH
23898: LD_EXP 67
23902: AND
23903: IFFALSE 23923
23905: GO 23907
23907: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23908: LD_INT 4
23910: PPUSH
23911: LD_OWVAR 2
23915: PPUSH
23916: LD_INT 0
23918: PPUSH
23919: CALL_OW 324
23923: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23924: LD_EXP 59
23928: PUSH
23929: LD_EXP 96
23933: AND
23934: IFFALSE 23954
23936: GO 23938
23938: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23939: LD_INT 19
23941: PPUSH
23942: LD_OWVAR 2
23946: PPUSH
23947: LD_INT 0
23949: PPUSH
23950: CALL_OW 324
23954: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23955: LD_EXP 59
23959: PUSH
23960: LD_EXP 68
23964: AND
23965: IFFALSE 24067
23967: GO 23969
23969: DISABLE
23970: LD_INT 0
23972: PPUSH
23973: PPUSH
// begin enable ;
23974: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23975: LD_ADDR_VAR 0 2
23979: PUSH
23980: LD_INT 22
23982: PUSH
23983: LD_OWVAR 2
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PUSH
23992: LD_INT 2
23994: PUSH
23995: LD_INT 34
23997: PUSH
23998: LD_INT 11
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: PUSH
24005: LD_INT 34
24007: PUSH
24008: LD_INT 30
24010: PUSH
24011: EMPTY
24012: LIST
24013: LIST
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: LIST
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PPUSH
24024: CALL_OW 69
24028: ST_TO_ADDR
// if not tmp then
24029: LD_VAR 0 2
24033: NOT
24034: IFFALSE 24038
// exit ;
24036: GO 24067
// for i in tmp do
24038: LD_ADDR_VAR 0 1
24042: PUSH
24043: LD_VAR 0 2
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24065
// begin SetLives ( i , 0 ) ;
24051: LD_VAR 0 1
24055: PPUSH
24056: LD_INT 0
24058: PPUSH
24059: CALL_OW 234
// end ;
24063: GO 24048
24065: POP
24066: POP
// end ;
24067: PPOPN 2
24069: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24070: LD_EXP 59
24074: PUSH
24075: LD_EXP 69
24079: AND
24080: IFFALSE 24100
24082: GO 24084
24084: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24085: LD_INT 32
24087: PPUSH
24088: LD_OWVAR 2
24092: PPUSH
24093: LD_INT 0
24095: PPUSH
24096: CALL_OW 324
24100: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24101: LD_EXP 59
24105: PUSH
24106: LD_EXP 70
24110: AND
24111: IFFALSE 24292
24113: GO 24115
24115: DISABLE
24116: LD_INT 0
24118: PPUSH
24119: PPUSH
24120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24121: LD_ADDR_VAR 0 2
24125: PUSH
24126: LD_INT 22
24128: PUSH
24129: LD_OWVAR 2
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PUSH
24138: LD_INT 33
24140: PUSH
24141: LD_INT 3
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: PPUSH
24152: CALL_OW 69
24156: ST_TO_ADDR
// if not tmp then
24157: LD_VAR 0 2
24161: NOT
24162: IFFALSE 24166
// exit ;
24164: GO 24292
// side := 0 ;
24166: LD_ADDR_VAR 0 3
24170: PUSH
24171: LD_INT 0
24173: ST_TO_ADDR
// for i := 1 to 8 do
24174: LD_ADDR_VAR 0 1
24178: PUSH
24179: DOUBLE
24180: LD_INT 1
24182: DEC
24183: ST_TO_ADDR
24184: LD_INT 8
24186: PUSH
24187: FOR_TO
24188: IFFALSE 24236
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24190: LD_OWVAR 2
24194: PUSH
24195: LD_VAR 0 1
24199: NONEQUAL
24200: PUSH
24201: LD_OWVAR 2
24205: PPUSH
24206: LD_VAR 0 1
24210: PPUSH
24211: CALL_OW 81
24215: PUSH
24216: LD_INT 2
24218: EQUAL
24219: AND
24220: IFFALSE 24234
// begin side := i ;
24222: LD_ADDR_VAR 0 3
24226: PUSH
24227: LD_VAR 0 1
24231: ST_TO_ADDR
// break ;
24232: GO 24236
// end ;
24234: GO 24187
24236: POP
24237: POP
// if not side then
24238: LD_VAR 0 3
24242: NOT
24243: IFFALSE 24247
// exit ;
24245: GO 24292
// for i := 1 to tmp do
24247: LD_ADDR_VAR 0 1
24251: PUSH
24252: DOUBLE
24253: LD_INT 1
24255: DEC
24256: ST_TO_ADDR
24257: LD_VAR 0 2
24261: PUSH
24262: FOR_TO
24263: IFFALSE 24290
// if Prob ( 60 ) then
24265: LD_INT 60
24267: PPUSH
24268: CALL_OW 13
24272: IFFALSE 24288
// SetSide ( i , side ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_VAR 0 3
24283: PPUSH
24284: CALL_OW 235
24288: GO 24262
24290: POP
24291: POP
// end ;
24292: PPOPN 3
24294: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24295: LD_EXP 59
24299: PUSH
24300: LD_EXP 72
24304: AND
24305: IFFALSE 24424
24307: GO 24309
24309: DISABLE
24310: LD_INT 0
24312: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24313: LD_ADDR_VAR 0 1
24317: PUSH
24318: LD_INT 22
24320: PUSH
24321: LD_OWVAR 2
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: PUSH
24330: LD_INT 21
24332: PUSH
24333: LD_INT 1
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PUSH
24340: LD_INT 3
24342: PUSH
24343: LD_INT 23
24345: PUSH
24346: LD_INT 0
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: PPUSH
24362: CALL_OW 69
24366: PUSH
24367: FOR_IN
24368: IFFALSE 24422
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24370: LD_VAR 0 1
24374: PPUSH
24375: CALL_OW 257
24379: PUSH
24380: LD_INT 1
24382: PUSH
24383: LD_INT 2
24385: PUSH
24386: LD_INT 3
24388: PUSH
24389: LD_INT 4
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: LIST
24396: LIST
24397: IN
24398: IFFALSE 24420
// SetClass ( un , rand ( 1 , 4 ) ) ;
24400: LD_VAR 0 1
24404: PPUSH
24405: LD_INT 1
24407: PPUSH
24408: LD_INT 4
24410: PPUSH
24411: CALL_OW 12
24415: PPUSH
24416: CALL_OW 336
24420: GO 24367
24422: POP
24423: POP
// end ;
24424: PPOPN 1
24426: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24427: LD_EXP 59
24431: PUSH
24432: LD_EXP 71
24436: AND
24437: IFFALSE 24516
24439: GO 24441
24441: DISABLE
24442: LD_INT 0
24444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24445: LD_ADDR_VAR 0 1
24449: PUSH
24450: LD_INT 22
24452: PUSH
24453: LD_OWVAR 2
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: PUSH
24462: LD_INT 21
24464: PUSH
24465: LD_INT 3
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: PPUSH
24476: CALL_OW 69
24480: ST_TO_ADDR
// if not tmp then
24481: LD_VAR 0 1
24485: NOT
24486: IFFALSE 24490
// exit ;
24488: GO 24516
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24490: LD_VAR 0 1
24494: PUSH
24495: LD_INT 1
24497: PPUSH
24498: LD_VAR 0 1
24502: PPUSH
24503: CALL_OW 12
24507: ARRAY
24508: PPUSH
24509: LD_INT 100
24511: PPUSH
24512: CALL_OW 234
// end ;
24516: PPOPN 1
24518: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24519: LD_EXP 59
24523: PUSH
24524: LD_EXP 73
24528: AND
24529: IFFALSE 24627
24531: GO 24533
24533: DISABLE
24534: LD_INT 0
24536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24537: LD_ADDR_VAR 0 1
24541: PUSH
24542: LD_INT 22
24544: PUSH
24545: LD_OWVAR 2
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: PUSH
24554: LD_INT 21
24556: PUSH
24557: LD_INT 1
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PPUSH
24568: CALL_OW 69
24572: ST_TO_ADDR
// if not tmp then
24573: LD_VAR 0 1
24577: NOT
24578: IFFALSE 24582
// exit ;
24580: GO 24627
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24582: LD_VAR 0 1
24586: PUSH
24587: LD_INT 1
24589: PPUSH
24590: LD_VAR 0 1
24594: PPUSH
24595: CALL_OW 12
24599: ARRAY
24600: PPUSH
24601: LD_INT 1
24603: PPUSH
24604: LD_INT 4
24606: PPUSH
24607: CALL_OW 12
24611: PPUSH
24612: LD_INT 3000
24614: PPUSH
24615: LD_INT 9000
24617: PPUSH
24618: CALL_OW 12
24622: PPUSH
24623: CALL_OW 492
// end ;
24627: PPOPN 1
24629: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24630: LD_EXP 59
24634: PUSH
24635: LD_EXP 74
24639: AND
24640: IFFALSE 24660
24642: GO 24644
24644: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24645: LD_INT 1
24647: PPUSH
24648: LD_OWVAR 2
24652: PPUSH
24653: LD_INT 0
24655: PPUSH
24656: CALL_OW 324
24660: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24661: LD_EXP 59
24665: PUSH
24666: LD_EXP 75
24670: AND
24671: IFFALSE 24754
24673: GO 24675
24675: DISABLE
24676: LD_INT 0
24678: PPUSH
24679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24680: LD_ADDR_VAR 0 2
24684: PUSH
24685: LD_INT 22
24687: PUSH
24688: LD_OWVAR 2
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 21
24699: PUSH
24700: LD_INT 3
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: PPUSH
24711: CALL_OW 69
24715: ST_TO_ADDR
// if not tmp then
24716: LD_VAR 0 2
24720: NOT
24721: IFFALSE 24725
// exit ;
24723: GO 24754
// for i in tmp do
24725: LD_ADDR_VAR 0 1
24729: PUSH
24730: LD_VAR 0 2
24734: PUSH
24735: FOR_IN
24736: IFFALSE 24752
// SetBLevel ( i , 10 ) ;
24738: LD_VAR 0 1
24742: PPUSH
24743: LD_INT 10
24745: PPUSH
24746: CALL_OW 241
24750: GO 24735
24752: POP
24753: POP
// end ;
24754: PPOPN 2
24756: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24757: LD_EXP 59
24761: PUSH
24762: LD_EXP 76
24766: AND
24767: IFFALSE 24878
24769: GO 24771
24771: DISABLE
24772: LD_INT 0
24774: PPUSH
24775: PPUSH
24776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24777: LD_ADDR_VAR 0 3
24781: PUSH
24782: LD_INT 22
24784: PUSH
24785: LD_OWVAR 2
24789: PUSH
24790: EMPTY
24791: LIST
24792: LIST
24793: PUSH
24794: LD_INT 25
24796: PUSH
24797: LD_INT 1
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: PUSH
24804: EMPTY
24805: LIST
24806: LIST
24807: PPUSH
24808: CALL_OW 69
24812: ST_TO_ADDR
// if not tmp then
24813: LD_VAR 0 3
24817: NOT
24818: IFFALSE 24822
// exit ;
24820: GO 24878
// un := tmp [ rand ( 1 , tmp ) ] ;
24822: LD_ADDR_VAR 0 2
24826: PUSH
24827: LD_VAR 0 3
24831: PUSH
24832: LD_INT 1
24834: PPUSH
24835: LD_VAR 0 3
24839: PPUSH
24840: CALL_OW 12
24844: ARRAY
24845: ST_TO_ADDR
// if Crawls ( un ) then
24846: LD_VAR 0 2
24850: PPUSH
24851: CALL_OW 318
24855: IFFALSE 24866
// ComWalk ( un ) ;
24857: LD_VAR 0 2
24861: PPUSH
24862: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24866: LD_VAR 0 2
24870: PPUSH
24871: LD_INT 5
24873: PPUSH
24874: CALL_OW 336
// end ;
24878: PPOPN 3
24880: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24881: LD_EXP 59
24885: PUSH
24886: LD_EXP 77
24890: AND
24891: PUSH
24892: LD_OWVAR 67
24896: PUSH
24897: LD_INT 3
24899: LESS
24900: AND
24901: IFFALSE 24920
24903: GO 24905
24905: DISABLE
// Difficulty := Difficulty + 1 ;
24906: LD_ADDR_OWVAR 67
24910: PUSH
24911: LD_OWVAR 67
24915: PUSH
24916: LD_INT 1
24918: PLUS
24919: ST_TO_ADDR
24920: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24921: LD_EXP 59
24925: PUSH
24926: LD_EXP 78
24930: AND
24931: IFFALSE 25034
24933: GO 24935
24935: DISABLE
24936: LD_INT 0
24938: PPUSH
// begin for i := 1 to 5 do
24939: LD_ADDR_VAR 0 1
24943: PUSH
24944: DOUBLE
24945: LD_INT 1
24947: DEC
24948: ST_TO_ADDR
24949: LD_INT 5
24951: PUSH
24952: FOR_TO
24953: IFFALSE 25032
// begin uc_nation := nation_nature ;
24955: LD_ADDR_OWVAR 21
24959: PUSH
24960: LD_INT 0
24962: ST_TO_ADDR
// uc_side := 0 ;
24963: LD_ADDR_OWVAR 20
24967: PUSH
24968: LD_INT 0
24970: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24971: LD_ADDR_OWVAR 29
24975: PUSH
24976: LD_INT 12
24978: PUSH
24979: LD_INT 12
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: ST_TO_ADDR
// hc_agressivity := 20 ;
24986: LD_ADDR_OWVAR 35
24990: PUSH
24991: LD_INT 20
24993: ST_TO_ADDR
// hc_class := class_tiger ;
24994: LD_ADDR_OWVAR 28
24998: PUSH
24999: LD_INT 14
25001: ST_TO_ADDR
// hc_gallery :=  ;
25002: LD_ADDR_OWVAR 33
25006: PUSH
25007: LD_STRING 
25009: ST_TO_ADDR
// hc_name :=  ;
25010: LD_ADDR_OWVAR 26
25014: PUSH
25015: LD_STRING 
25017: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25018: CALL_OW 44
25022: PPUSH
25023: LD_INT 0
25025: PPUSH
25026: CALL_OW 51
// end ;
25030: GO 24952
25032: POP
25033: POP
// end ;
25034: PPOPN 1
25036: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25037: LD_EXP 59
25041: PUSH
25042: LD_EXP 79
25046: AND
25047: IFFALSE 25056
25049: GO 25051
25051: DISABLE
// StreamSibBomb ;
25052: CALL 25057 0 0
25056: END
// export function StreamSibBomb ; var i , x , y ; begin
25057: LD_INT 0
25059: PPUSH
25060: PPUSH
25061: PPUSH
25062: PPUSH
// result := false ;
25063: LD_ADDR_VAR 0 1
25067: PUSH
25068: LD_INT 0
25070: ST_TO_ADDR
// for i := 1 to 16 do
25071: LD_ADDR_VAR 0 2
25075: PUSH
25076: DOUBLE
25077: LD_INT 1
25079: DEC
25080: ST_TO_ADDR
25081: LD_INT 16
25083: PUSH
25084: FOR_TO
25085: IFFALSE 25284
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25087: LD_ADDR_VAR 0 3
25091: PUSH
25092: LD_INT 10
25094: PUSH
25095: LD_INT 20
25097: PUSH
25098: LD_INT 30
25100: PUSH
25101: LD_INT 40
25103: PUSH
25104: LD_INT 50
25106: PUSH
25107: LD_INT 60
25109: PUSH
25110: LD_INT 70
25112: PUSH
25113: LD_INT 80
25115: PUSH
25116: LD_INT 90
25118: PUSH
25119: LD_INT 100
25121: PUSH
25122: LD_INT 110
25124: PUSH
25125: LD_INT 120
25127: PUSH
25128: LD_INT 130
25130: PUSH
25131: LD_INT 140
25133: PUSH
25134: LD_INT 150
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: LIST
25141: LIST
25142: LIST
25143: LIST
25144: LIST
25145: LIST
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: LIST
25151: LIST
25152: LIST
25153: PUSH
25154: LD_INT 1
25156: PPUSH
25157: LD_INT 15
25159: PPUSH
25160: CALL_OW 12
25164: ARRAY
25165: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_INT 10
25173: PUSH
25174: LD_INT 20
25176: PUSH
25177: LD_INT 30
25179: PUSH
25180: LD_INT 40
25182: PUSH
25183: LD_INT 50
25185: PUSH
25186: LD_INT 60
25188: PUSH
25189: LD_INT 70
25191: PUSH
25192: LD_INT 80
25194: PUSH
25195: LD_INT 90
25197: PUSH
25198: LD_INT 100
25200: PUSH
25201: LD_INT 110
25203: PUSH
25204: LD_INT 120
25206: PUSH
25207: LD_INT 130
25209: PUSH
25210: LD_INT 140
25212: PUSH
25213: LD_INT 150
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: PUSH
25233: LD_INT 1
25235: PPUSH
25236: LD_INT 15
25238: PPUSH
25239: CALL_OW 12
25243: ARRAY
25244: ST_TO_ADDR
// if ValidHex ( x , y ) then
25245: LD_VAR 0 3
25249: PPUSH
25250: LD_VAR 0 4
25254: PPUSH
25255: CALL_OW 488
25259: IFFALSE 25282
// begin result := [ x , y ] ;
25261: LD_ADDR_VAR 0 1
25265: PUSH
25266: LD_VAR 0 3
25270: PUSH
25271: LD_VAR 0 4
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: ST_TO_ADDR
// break ;
25280: GO 25284
// end ; end ;
25282: GO 25084
25284: POP
25285: POP
// if result then
25286: LD_VAR 0 1
25290: IFFALSE 25350
// begin ToLua ( playSibBomb() ) ;
25292: LD_STRING playSibBomb()
25294: PPUSH
25295: CALL_OW 559
// wait ( 0 0$14 ) ;
25299: LD_INT 490
25301: PPUSH
25302: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25306: LD_VAR 0 1
25310: PUSH
25311: LD_INT 1
25313: ARRAY
25314: PPUSH
25315: LD_VAR 0 1
25319: PUSH
25320: LD_INT 2
25322: ARRAY
25323: PPUSH
25324: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25328: LD_VAR 0 1
25332: PUSH
25333: LD_INT 1
25335: ARRAY
25336: PPUSH
25337: LD_VAR 0 1
25341: PUSH
25342: LD_INT 2
25344: ARRAY
25345: PPUSH
25346: CALL_OW 429
// end ; end ;
25350: LD_VAR 0 1
25354: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25355: LD_EXP 59
25359: PUSH
25360: LD_EXP 81
25364: AND
25365: IFFALSE 25377
25367: GO 25369
25369: DISABLE
// YouLost (  ) ;
25370: LD_STRING 
25372: PPUSH
25373: CALL_OW 104
25377: END
// every 0 0$1 trigger StreamModeActive and sFog do
25378: LD_EXP 59
25382: PUSH
25383: LD_EXP 80
25387: AND
25388: IFFALSE 25402
25390: GO 25392
25392: DISABLE
// FogOff ( your_side ) ;
25393: LD_OWVAR 2
25397: PPUSH
25398: CALL_OW 344
25402: END
// every 0 0$1 trigger StreamModeActive and sSun do
25403: LD_EXP 59
25407: PUSH
25408: LD_EXP 82
25412: AND
25413: IFFALSE 25441
25415: GO 25417
25417: DISABLE
// begin solar_recharge_percent := 0 ;
25418: LD_ADDR_OWVAR 79
25422: PUSH
25423: LD_INT 0
25425: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25426: LD_INT 10500
25428: PPUSH
25429: CALL_OW 67
// solar_recharge_percent := 100 ;
25433: LD_ADDR_OWVAR 79
25437: PUSH
25438: LD_INT 100
25440: ST_TO_ADDR
// end ;
25441: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25442: LD_EXP 59
25446: PUSH
25447: LD_EXP 83
25451: AND
25452: IFFALSE 25691
25454: GO 25456
25456: DISABLE
25457: LD_INT 0
25459: PPUSH
25460: PPUSH
25461: PPUSH
// begin tmp := [ ] ;
25462: LD_ADDR_VAR 0 3
25466: PUSH
25467: EMPTY
25468: ST_TO_ADDR
// for i := 1 to 6 do
25469: LD_ADDR_VAR 0 1
25473: PUSH
25474: DOUBLE
25475: LD_INT 1
25477: DEC
25478: ST_TO_ADDR
25479: LD_INT 6
25481: PUSH
25482: FOR_TO
25483: IFFALSE 25588
// begin uc_nation := nation_nature ;
25485: LD_ADDR_OWVAR 21
25489: PUSH
25490: LD_INT 0
25492: ST_TO_ADDR
// uc_side := 0 ;
25493: LD_ADDR_OWVAR 20
25497: PUSH
25498: LD_INT 0
25500: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25501: LD_ADDR_OWVAR 29
25505: PUSH
25506: LD_INT 12
25508: PUSH
25509: LD_INT 12
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: ST_TO_ADDR
// hc_agressivity := 20 ;
25516: LD_ADDR_OWVAR 35
25520: PUSH
25521: LD_INT 20
25523: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25524: LD_ADDR_OWVAR 28
25528: PUSH
25529: LD_INT 17
25531: ST_TO_ADDR
// hc_gallery :=  ;
25532: LD_ADDR_OWVAR 33
25536: PUSH
25537: LD_STRING 
25539: ST_TO_ADDR
// hc_name :=  ;
25540: LD_ADDR_OWVAR 26
25544: PUSH
25545: LD_STRING 
25547: ST_TO_ADDR
// un := CreateHuman ;
25548: LD_ADDR_VAR 0 2
25552: PUSH
25553: CALL_OW 44
25557: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: CALL_OW 51
// tmp := tmp ^ un ;
25570: LD_ADDR_VAR 0 3
25574: PUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_VAR 0 2
25584: ADD
25585: ST_TO_ADDR
// end ;
25586: GO 25482
25588: POP
25589: POP
// repeat wait ( 0 0$1 ) ;
25590: LD_INT 35
25592: PPUSH
25593: CALL_OW 67
// for un in tmp do
25597: LD_ADDR_VAR 0 2
25601: PUSH
25602: LD_VAR 0 3
25606: PUSH
25607: FOR_IN
25608: IFFALSE 25682
// begin if IsDead ( un ) then
25610: LD_VAR 0 2
25614: PPUSH
25615: CALL_OW 301
25619: IFFALSE 25639
// begin tmp := tmp diff un ;
25621: LD_ADDR_VAR 0 3
25625: PUSH
25626: LD_VAR 0 3
25630: PUSH
25631: LD_VAR 0 2
25635: DIFF
25636: ST_TO_ADDR
// continue ;
25637: GO 25607
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25639: LD_VAR 0 2
25643: PPUSH
25644: LD_INT 3
25646: PUSH
25647: LD_INT 22
25649: PUSH
25650: LD_INT 0
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: PUSH
25657: EMPTY
25658: LIST
25659: LIST
25660: PPUSH
25661: CALL_OW 69
25665: PPUSH
25666: LD_VAR 0 2
25670: PPUSH
25671: CALL_OW 74
25675: PPUSH
25676: CALL_OW 115
// end ;
25680: GO 25607
25682: POP
25683: POP
// until not tmp ;
25684: LD_VAR 0 3
25688: NOT
25689: IFFALSE 25590
// end ;
25691: PPOPN 3
25693: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25694: LD_EXP 59
25698: PUSH
25699: LD_EXP 84
25703: AND
25704: IFFALSE 25758
25706: GO 25708
25708: DISABLE
// begin ToLua ( displayTroll(); ) ;
25709: LD_STRING displayTroll();
25711: PPUSH
25712: CALL_OW 559
// wait ( 3 3$00 ) ;
25716: LD_INT 6300
25718: PPUSH
25719: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25723: LD_STRING hideTroll();
25725: PPUSH
25726: CALL_OW 559
// wait ( 1 1$00 ) ;
25730: LD_INT 2100
25732: PPUSH
25733: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25737: LD_STRING displayTroll();
25739: PPUSH
25740: CALL_OW 559
// wait ( 1 1$00 ) ;
25744: LD_INT 2100
25746: PPUSH
25747: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25751: LD_STRING hideTroll();
25753: PPUSH
25754: CALL_OW 559
// end ;
25758: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25759: LD_EXP 59
25763: PUSH
25764: LD_EXP 85
25768: AND
25769: IFFALSE 25832
25771: GO 25773
25773: DISABLE
25774: LD_INT 0
25776: PPUSH
// begin p := 0 ;
25777: LD_ADDR_VAR 0 1
25781: PUSH
25782: LD_INT 0
25784: ST_TO_ADDR
// repeat game_speed := 1 ;
25785: LD_ADDR_OWVAR 65
25789: PUSH
25790: LD_INT 1
25792: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25793: LD_INT 35
25795: PPUSH
25796: CALL_OW 67
// p := p + 1 ;
25800: LD_ADDR_VAR 0 1
25804: PUSH
25805: LD_VAR 0 1
25809: PUSH
25810: LD_INT 1
25812: PLUS
25813: ST_TO_ADDR
// until p >= 60 ;
25814: LD_VAR 0 1
25818: PUSH
25819: LD_INT 60
25821: GREATEREQUAL
25822: IFFALSE 25785
// game_speed := 4 ;
25824: LD_ADDR_OWVAR 65
25828: PUSH
25829: LD_INT 4
25831: ST_TO_ADDR
// end ;
25832: PPOPN 1
25834: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25835: LD_EXP 59
25839: PUSH
25840: LD_EXP 86
25844: AND
25845: IFFALSE 25991
25847: GO 25849
25849: DISABLE
25850: LD_INT 0
25852: PPUSH
25853: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25854: LD_ADDR_VAR 0 1
25858: PUSH
25859: LD_INT 22
25861: PUSH
25862: LD_OWVAR 2
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: PUSH
25871: LD_INT 2
25873: PUSH
25874: LD_INT 30
25876: PUSH
25877: LD_INT 0
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 30
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: LIST
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PPUSH
25903: CALL_OW 69
25907: ST_TO_ADDR
// if not depot then
25908: LD_VAR 0 1
25912: NOT
25913: IFFALSE 25917
// exit ;
25915: GO 25991
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25917: LD_ADDR_VAR 0 2
25921: PUSH
25922: LD_VAR 0 1
25926: PUSH
25927: LD_INT 1
25929: PPUSH
25930: LD_VAR 0 1
25934: PPUSH
25935: CALL_OW 12
25939: ARRAY
25940: PPUSH
25941: CALL_OW 274
25945: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25946: LD_VAR 0 2
25950: PPUSH
25951: LD_INT 1
25953: PPUSH
25954: LD_INT 0
25956: PPUSH
25957: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25961: LD_VAR 0 2
25965: PPUSH
25966: LD_INT 2
25968: PPUSH
25969: LD_INT 0
25971: PPUSH
25972: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25976: LD_VAR 0 2
25980: PPUSH
25981: LD_INT 3
25983: PPUSH
25984: LD_INT 0
25986: PPUSH
25987: CALL_OW 277
// end ;
25991: PPOPN 2
25993: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25994: LD_EXP 59
25998: PUSH
25999: LD_EXP 87
26003: AND
26004: IFFALSE 26101
26006: GO 26008
26008: DISABLE
26009: LD_INT 0
26011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26012: LD_ADDR_VAR 0 1
26016: PUSH
26017: LD_INT 22
26019: PUSH
26020: LD_OWVAR 2
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 21
26031: PUSH
26032: LD_INT 1
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 3
26041: PUSH
26042: LD_INT 23
26044: PUSH
26045: LD_INT 0
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PUSH
26056: EMPTY
26057: LIST
26058: LIST
26059: LIST
26060: PPUSH
26061: CALL_OW 69
26065: ST_TO_ADDR
// if not tmp then
26066: LD_VAR 0 1
26070: NOT
26071: IFFALSE 26075
// exit ;
26073: GO 26101
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26075: LD_VAR 0 1
26079: PUSH
26080: LD_INT 1
26082: PPUSH
26083: LD_VAR 0 1
26087: PPUSH
26088: CALL_OW 12
26092: ARRAY
26093: PPUSH
26094: LD_INT 200
26096: PPUSH
26097: CALL_OW 234
// end ;
26101: PPOPN 1
26103: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26104: LD_EXP 59
26108: PUSH
26109: LD_EXP 88
26113: AND
26114: IFFALSE 26193
26116: GO 26118
26118: DISABLE
26119: LD_INT 0
26121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26122: LD_ADDR_VAR 0 1
26126: PUSH
26127: LD_INT 22
26129: PUSH
26130: LD_OWVAR 2
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: LD_INT 21
26141: PUSH
26142: LD_INT 2
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PPUSH
26153: CALL_OW 69
26157: ST_TO_ADDR
// if not tmp then
26158: LD_VAR 0 1
26162: NOT
26163: IFFALSE 26167
// exit ;
26165: GO 26193
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26167: LD_VAR 0 1
26171: PUSH
26172: LD_INT 1
26174: PPUSH
26175: LD_VAR 0 1
26179: PPUSH
26180: CALL_OW 12
26184: ARRAY
26185: PPUSH
26186: LD_INT 60
26188: PPUSH
26189: CALL_OW 234
// end ;
26193: PPOPN 1
26195: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26196: LD_EXP 59
26200: PUSH
26201: LD_EXP 89
26205: AND
26206: IFFALSE 26305
26208: GO 26210
26210: DISABLE
26211: LD_INT 0
26213: PPUSH
26214: PPUSH
// begin enable ;
26215: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26216: LD_ADDR_VAR 0 1
26220: PUSH
26221: LD_INT 22
26223: PUSH
26224: LD_OWVAR 2
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: PUSH
26233: LD_INT 61
26235: PUSH
26236: EMPTY
26237: LIST
26238: PUSH
26239: LD_INT 33
26241: PUSH
26242: LD_INT 2
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: LIST
26253: PPUSH
26254: CALL_OW 69
26258: ST_TO_ADDR
// if not tmp then
26259: LD_VAR 0 1
26263: NOT
26264: IFFALSE 26268
// exit ;
26266: GO 26305
// for i in tmp do
26268: LD_ADDR_VAR 0 2
26272: PUSH
26273: LD_VAR 0 1
26277: PUSH
26278: FOR_IN
26279: IFFALSE 26303
// if IsControledBy ( i ) then
26281: LD_VAR 0 2
26285: PPUSH
26286: CALL_OW 312
26290: IFFALSE 26301
// ComUnlink ( i ) ;
26292: LD_VAR 0 2
26296: PPUSH
26297: CALL_OW 136
26301: GO 26278
26303: POP
26304: POP
// end ;
26305: PPOPN 2
26307: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26308: LD_EXP 59
26312: PUSH
26313: LD_EXP 90
26317: AND
26318: IFFALSE 26458
26320: GO 26322
26322: DISABLE
26323: LD_INT 0
26325: PPUSH
26326: PPUSH
// begin ToLua ( displayPowell(); ) ;
26327: LD_STRING displayPowell();
26329: PPUSH
26330: CALL_OW 559
// uc_side := 0 ;
26334: LD_ADDR_OWVAR 20
26338: PUSH
26339: LD_INT 0
26341: ST_TO_ADDR
// uc_nation := 2 ;
26342: LD_ADDR_OWVAR 21
26346: PUSH
26347: LD_INT 2
26349: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26350: LD_ADDR_OWVAR 37
26354: PUSH
26355: LD_INT 14
26357: ST_TO_ADDR
// vc_engine := engine_siberite ;
26358: LD_ADDR_OWVAR 39
26362: PUSH
26363: LD_INT 3
26365: ST_TO_ADDR
// vc_control := control_apeman ;
26366: LD_ADDR_OWVAR 38
26370: PUSH
26371: LD_INT 5
26373: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26374: LD_ADDR_OWVAR 40
26378: PUSH
26379: LD_INT 29
26381: ST_TO_ADDR
// un := CreateVehicle ;
26382: LD_ADDR_VAR 0 2
26386: PUSH
26387: CALL_OW 45
26391: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26392: LD_VAR 0 2
26396: PPUSH
26397: LD_INT 1
26399: PPUSH
26400: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26404: LD_INT 35
26406: PPUSH
26407: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26411: LD_VAR 0 2
26415: PPUSH
26416: LD_INT 22
26418: PUSH
26419: LD_OWVAR 2
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PPUSH
26428: CALL_OW 69
26432: PPUSH
26433: LD_VAR 0 2
26437: PPUSH
26438: CALL_OW 74
26442: PPUSH
26443: CALL_OW 115
// until IsDead ( un ) ;
26447: LD_VAR 0 2
26451: PPUSH
26452: CALL_OW 301
26456: IFFALSE 26404
// end ;
26458: PPOPN 2
26460: END
// every 0 0$1 trigger StreamModeActive and sStu do
26461: LD_EXP 59
26465: PUSH
26466: LD_EXP 98
26470: AND
26471: IFFALSE 26487
26473: GO 26475
26475: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26476: LD_STRING displayStucuk();
26478: PPUSH
26479: CALL_OW 559
// ResetFog ;
26483: CALL_OW 335
// end ;
26487: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26488: LD_EXP 59
26492: PUSH
26493: LD_EXP 91
26497: AND
26498: IFFALSE 26639
26500: GO 26502
26502: DISABLE
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26507: LD_ADDR_VAR 0 2
26511: PUSH
26512: LD_INT 22
26514: PUSH
26515: LD_OWVAR 2
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 21
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL_OW 69
26542: ST_TO_ADDR
// if not tmp then
26543: LD_VAR 0 2
26547: NOT
26548: IFFALSE 26552
// exit ;
26550: GO 26639
// un := tmp [ rand ( 1 , tmp ) ] ;
26552: LD_ADDR_VAR 0 1
26556: PUSH
26557: LD_VAR 0 2
26561: PUSH
26562: LD_INT 1
26564: PPUSH
26565: LD_VAR 0 2
26569: PPUSH
26570: CALL_OW 12
26574: ARRAY
26575: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26576: LD_VAR 0 1
26580: PPUSH
26581: LD_INT 0
26583: PPUSH
26584: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26588: LD_VAR 0 1
26592: PPUSH
26593: LD_OWVAR 3
26597: PUSH
26598: LD_VAR 0 1
26602: DIFF
26603: PPUSH
26604: LD_VAR 0 1
26608: PPUSH
26609: CALL_OW 74
26613: PPUSH
26614: CALL_OW 115
// wait ( 0 0$20 ) ;
26618: LD_INT 700
26620: PPUSH
26621: CALL_OW 67
// SetSide ( un , your_side ) ;
26625: LD_VAR 0 1
26629: PPUSH
26630: LD_OWVAR 2
26634: PPUSH
26635: CALL_OW 235
// end ;
26639: PPOPN 2
26641: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26642: LD_EXP 59
26646: PUSH
26647: LD_EXP 92
26651: AND
26652: IFFALSE 26758
26654: GO 26656
26656: DISABLE
26657: LD_INT 0
26659: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26660: LD_ADDR_VAR 0 1
26664: PUSH
26665: LD_INT 22
26667: PUSH
26668: LD_OWVAR 2
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: PUSH
26677: LD_INT 2
26679: PUSH
26680: LD_INT 30
26682: PUSH
26683: LD_INT 0
26685: PUSH
26686: EMPTY
26687: LIST
26688: LIST
26689: PUSH
26690: LD_INT 30
26692: PUSH
26693: LD_INT 1
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: LIST
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PPUSH
26709: CALL_OW 69
26713: ST_TO_ADDR
// if not depot then
26714: LD_VAR 0 1
26718: NOT
26719: IFFALSE 26723
// exit ;
26721: GO 26758
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26723: LD_VAR 0 1
26727: PUSH
26728: LD_INT 1
26730: ARRAY
26731: PPUSH
26732: CALL_OW 250
26736: PPUSH
26737: LD_VAR 0 1
26741: PUSH
26742: LD_INT 1
26744: ARRAY
26745: PPUSH
26746: CALL_OW 251
26750: PPUSH
26751: LD_INT 70
26753: PPUSH
26754: CALL_OW 495
// end ;
26758: PPOPN 1
26760: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26761: LD_EXP 59
26765: PUSH
26766: LD_EXP 93
26770: AND
26771: IFFALSE 26982
26773: GO 26775
26775: DISABLE
26776: LD_INT 0
26778: PPUSH
26779: PPUSH
26780: PPUSH
26781: PPUSH
26782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26783: LD_ADDR_VAR 0 5
26787: PUSH
26788: LD_INT 22
26790: PUSH
26791: LD_OWVAR 2
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 21
26802: PUSH
26803: LD_INT 1
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PPUSH
26814: CALL_OW 69
26818: ST_TO_ADDR
// if not tmp then
26819: LD_VAR 0 5
26823: NOT
26824: IFFALSE 26828
// exit ;
26826: GO 26982
// for i in tmp do
26828: LD_ADDR_VAR 0 1
26832: PUSH
26833: LD_VAR 0 5
26837: PUSH
26838: FOR_IN
26839: IFFALSE 26980
// begin d := rand ( 0 , 5 ) ;
26841: LD_ADDR_VAR 0 4
26845: PUSH
26846: LD_INT 0
26848: PPUSH
26849: LD_INT 5
26851: PPUSH
26852: CALL_OW 12
26856: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26857: LD_ADDR_VAR 0 2
26861: PUSH
26862: LD_VAR 0 1
26866: PPUSH
26867: CALL_OW 250
26871: PPUSH
26872: LD_VAR 0 4
26876: PPUSH
26877: LD_INT 3
26879: PPUSH
26880: LD_INT 12
26882: PPUSH
26883: CALL_OW 12
26887: PPUSH
26888: CALL_OW 272
26892: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26893: LD_ADDR_VAR 0 3
26897: PUSH
26898: LD_VAR 0 1
26902: PPUSH
26903: CALL_OW 251
26907: PPUSH
26908: LD_VAR 0 4
26912: PPUSH
26913: LD_INT 3
26915: PPUSH
26916: LD_INT 12
26918: PPUSH
26919: CALL_OW 12
26923: PPUSH
26924: CALL_OW 273
26928: ST_TO_ADDR
// if ValidHex ( x , y ) then
26929: LD_VAR 0 2
26933: PPUSH
26934: LD_VAR 0 3
26938: PPUSH
26939: CALL_OW 488
26943: IFFALSE 26978
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26945: LD_VAR 0 1
26949: PPUSH
26950: LD_VAR 0 2
26954: PPUSH
26955: LD_VAR 0 3
26959: PPUSH
26960: LD_INT 3
26962: PPUSH
26963: LD_INT 6
26965: PPUSH
26966: CALL_OW 12
26970: PPUSH
26971: LD_INT 1
26973: PPUSH
26974: CALL_OW 483
// end ;
26978: GO 26838
26980: POP
26981: POP
// end ;
26982: PPOPN 5
26984: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26985: LD_EXP 59
26989: PUSH
26990: LD_EXP 94
26994: AND
26995: IFFALSE 27089
26997: GO 26999
26999: DISABLE
27000: LD_INT 0
27002: PPUSH
27003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27004: LD_ADDR_VAR 0 2
27008: PUSH
27009: LD_INT 22
27011: PUSH
27012: LD_OWVAR 2
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PUSH
27021: LD_INT 32
27023: PUSH
27024: LD_INT 1
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: LD_INT 21
27033: PUSH
27034: LD_INT 2
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: PPUSH
27046: CALL_OW 69
27050: ST_TO_ADDR
// if not tmp then
27051: LD_VAR 0 2
27055: NOT
27056: IFFALSE 27060
// exit ;
27058: GO 27089
// for i in tmp do
27060: LD_ADDR_VAR 0 1
27064: PUSH
27065: LD_VAR 0 2
27069: PUSH
27070: FOR_IN
27071: IFFALSE 27087
// SetFuel ( i , 0 ) ;
27073: LD_VAR 0 1
27077: PPUSH
27078: LD_INT 0
27080: PPUSH
27081: CALL_OW 240
27085: GO 27070
27087: POP
27088: POP
// end ;
27089: PPOPN 2
27091: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27092: LD_EXP 59
27096: PUSH
27097: LD_EXP 95
27101: AND
27102: IFFALSE 27168
27104: GO 27106
27106: DISABLE
27107: LD_INT 0
27109: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27110: LD_ADDR_VAR 0 1
27114: PUSH
27115: LD_INT 22
27117: PUSH
27118: LD_OWVAR 2
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 30
27129: PUSH
27130: LD_INT 29
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PPUSH
27141: CALL_OW 69
27145: ST_TO_ADDR
// if not tmp then
27146: LD_VAR 0 1
27150: NOT
27151: IFFALSE 27155
// exit ;
27153: GO 27168
// DestroyUnit ( tmp [ 1 ] ) ;
27155: LD_VAR 0 1
27159: PUSH
27160: LD_INT 1
27162: ARRAY
27163: PPUSH
27164: CALL_OW 65
// end ;
27168: PPOPN 1
27170: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27171: LD_EXP 59
27175: PUSH
27176: LD_EXP 97
27180: AND
27181: IFFALSE 27310
27183: GO 27185
27185: DISABLE
27186: LD_INT 0
27188: PPUSH
// begin uc_side := 0 ;
27189: LD_ADDR_OWVAR 20
27193: PUSH
27194: LD_INT 0
27196: ST_TO_ADDR
// uc_nation := nation_arabian ;
27197: LD_ADDR_OWVAR 21
27201: PUSH
27202: LD_INT 2
27204: ST_TO_ADDR
// hc_gallery :=  ;
27205: LD_ADDR_OWVAR 33
27209: PUSH
27210: LD_STRING 
27212: ST_TO_ADDR
// hc_name :=  ;
27213: LD_ADDR_OWVAR 26
27217: PUSH
27218: LD_STRING 
27220: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27221: LD_INT 1
27223: PPUSH
27224: LD_INT 11
27226: PPUSH
27227: LD_INT 10
27229: PPUSH
27230: CALL_OW 380
// un := CreateHuman ;
27234: LD_ADDR_VAR 0 1
27238: PUSH
27239: CALL_OW 44
27243: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27244: LD_VAR 0 1
27248: PPUSH
27249: LD_INT 1
27251: PPUSH
27252: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27256: LD_INT 35
27258: PPUSH
27259: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27263: LD_VAR 0 1
27267: PPUSH
27268: LD_INT 22
27270: PUSH
27271: LD_OWVAR 2
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PPUSH
27280: CALL_OW 69
27284: PPUSH
27285: LD_VAR 0 1
27289: PPUSH
27290: CALL_OW 74
27294: PPUSH
27295: CALL_OW 115
// until IsDead ( un ) ;
27299: LD_VAR 0 1
27303: PPUSH
27304: CALL_OW 301
27308: IFFALSE 27256
// end ;
27310: PPOPN 1
27312: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27313: LD_EXP 59
27317: PUSH
27318: LD_EXP 99
27322: AND
27323: IFFALSE 27335
27325: GO 27327
27327: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27328: LD_STRING earthquake(getX(game), 0, 32)
27330: PPUSH
27331: CALL_OW 559
27335: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27336: LD_EXP 59
27340: PUSH
27341: LD_EXP 100
27345: AND
27346: IFFALSE 27437
27348: GO 27350
27350: DISABLE
27351: LD_INT 0
27353: PPUSH
// begin enable ;
27354: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27355: LD_ADDR_VAR 0 1
27359: PUSH
27360: LD_INT 22
27362: PUSH
27363: LD_OWVAR 2
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 21
27374: PUSH
27375: LD_INT 2
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 33
27384: PUSH
27385: LD_INT 3
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: LIST
27396: PPUSH
27397: CALL_OW 69
27401: ST_TO_ADDR
// if not tmp then
27402: LD_VAR 0 1
27406: NOT
27407: IFFALSE 27411
// exit ;
27409: GO 27437
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27411: LD_VAR 0 1
27415: PUSH
27416: LD_INT 1
27418: PPUSH
27419: LD_VAR 0 1
27423: PPUSH
27424: CALL_OW 12
27428: ARRAY
27429: PPUSH
27430: LD_INT 1
27432: PPUSH
27433: CALL_OW 234
// end ;
27437: PPOPN 1
27439: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27440: LD_EXP 59
27444: PUSH
27445: LD_EXP 101
27449: AND
27450: IFFALSE 27591
27452: GO 27454
27454: DISABLE
27455: LD_INT 0
27457: PPUSH
27458: PPUSH
27459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27460: LD_ADDR_VAR 0 3
27464: PUSH
27465: LD_INT 22
27467: PUSH
27468: LD_OWVAR 2
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: PUSH
27477: LD_INT 25
27479: PUSH
27480: LD_INT 1
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PPUSH
27491: CALL_OW 69
27495: ST_TO_ADDR
// if not tmp then
27496: LD_VAR 0 3
27500: NOT
27501: IFFALSE 27505
// exit ;
27503: GO 27591
// un := tmp [ rand ( 1 , tmp ) ] ;
27505: LD_ADDR_VAR 0 2
27509: PUSH
27510: LD_VAR 0 3
27514: PUSH
27515: LD_INT 1
27517: PPUSH
27518: LD_VAR 0 3
27522: PPUSH
27523: CALL_OW 12
27527: ARRAY
27528: ST_TO_ADDR
// if Crawls ( un ) then
27529: LD_VAR 0 2
27533: PPUSH
27534: CALL_OW 318
27538: IFFALSE 27549
// ComWalk ( un ) ;
27540: LD_VAR 0 2
27544: PPUSH
27545: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27549: LD_VAR 0 2
27553: PPUSH
27554: LD_INT 9
27556: PPUSH
27557: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27561: LD_INT 28
27563: PPUSH
27564: LD_OWVAR 2
27568: PPUSH
27569: LD_INT 2
27571: PPUSH
27572: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27576: LD_INT 29
27578: PPUSH
27579: LD_OWVAR 2
27583: PPUSH
27584: LD_INT 2
27586: PPUSH
27587: CALL_OW 322
// end ;
27591: PPOPN 3
27593: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27594: LD_EXP 59
27598: PUSH
27599: LD_EXP 102
27603: AND
27604: IFFALSE 27715
27606: GO 27608
27608: DISABLE
27609: LD_INT 0
27611: PPUSH
27612: PPUSH
27613: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27614: LD_ADDR_VAR 0 3
27618: PUSH
27619: LD_INT 22
27621: PUSH
27622: LD_OWVAR 2
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 25
27633: PUSH
27634: LD_INT 1
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PPUSH
27645: CALL_OW 69
27649: ST_TO_ADDR
// if not tmp then
27650: LD_VAR 0 3
27654: NOT
27655: IFFALSE 27659
// exit ;
27657: GO 27715
// un := tmp [ rand ( 1 , tmp ) ] ;
27659: LD_ADDR_VAR 0 2
27663: PUSH
27664: LD_VAR 0 3
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_VAR 0 3
27676: PPUSH
27677: CALL_OW 12
27681: ARRAY
27682: ST_TO_ADDR
// if Crawls ( un ) then
27683: LD_VAR 0 2
27687: PPUSH
27688: CALL_OW 318
27692: IFFALSE 27703
// ComWalk ( un ) ;
27694: LD_VAR 0 2
27698: PPUSH
27699: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27703: LD_VAR 0 2
27707: PPUSH
27708: LD_INT 8
27710: PPUSH
27711: CALL_OW 336
// end ;
27715: PPOPN 3
27717: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27718: LD_EXP 59
27722: PUSH
27723: LD_EXP 103
27727: AND
27728: IFFALSE 27872
27730: GO 27732
27732: DISABLE
27733: LD_INT 0
27735: PPUSH
27736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27737: LD_ADDR_VAR 0 2
27741: PUSH
27742: LD_INT 22
27744: PUSH
27745: LD_OWVAR 2
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 21
27756: PUSH
27757: LD_INT 2
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 34
27769: PUSH
27770: LD_INT 12
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 34
27779: PUSH
27780: LD_INT 51
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: LD_INT 34
27789: PUSH
27790: LD_INT 32
27792: PUSH
27793: EMPTY
27794: LIST
27795: LIST
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: LIST
27801: LIST
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: LIST
27807: PPUSH
27808: CALL_OW 69
27812: ST_TO_ADDR
// if not tmp then
27813: LD_VAR 0 2
27817: NOT
27818: IFFALSE 27822
// exit ;
27820: GO 27872
// for i in tmp do
27822: LD_ADDR_VAR 0 1
27826: PUSH
27827: LD_VAR 0 2
27831: PUSH
27832: FOR_IN
27833: IFFALSE 27870
// if GetCargo ( i , mat_artifact ) = 0 then
27835: LD_VAR 0 1
27839: PPUSH
27840: LD_INT 4
27842: PPUSH
27843: CALL_OW 289
27847: PUSH
27848: LD_INT 0
27850: EQUAL
27851: IFFALSE 27868
// SetCargo ( i , mat_siberit , 100 ) ;
27853: LD_VAR 0 1
27857: PPUSH
27858: LD_INT 3
27860: PPUSH
27861: LD_INT 100
27863: PPUSH
27864: CALL_OW 290
27868: GO 27832
27870: POP
27871: POP
// end ;
27872: PPOPN 2
27874: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27875: LD_EXP 59
27879: PUSH
27880: LD_EXP 104
27884: AND
27885: IFFALSE 28038
27887: GO 27889
27889: DISABLE
27890: LD_INT 0
27892: PPUSH
27893: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27894: LD_ADDR_VAR 0 2
27898: PUSH
27899: LD_INT 22
27901: PUSH
27902: LD_OWVAR 2
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PPUSH
27911: CALL_OW 69
27915: ST_TO_ADDR
// if not tmp then
27916: LD_VAR 0 2
27920: NOT
27921: IFFALSE 27925
// exit ;
27923: GO 28038
// for i := 1 to 2 do
27925: LD_ADDR_VAR 0 1
27929: PUSH
27930: DOUBLE
27931: LD_INT 1
27933: DEC
27934: ST_TO_ADDR
27935: LD_INT 2
27937: PUSH
27938: FOR_TO
27939: IFFALSE 28036
// begin uc_side := your_side ;
27941: LD_ADDR_OWVAR 20
27945: PUSH
27946: LD_OWVAR 2
27950: ST_TO_ADDR
// uc_nation := nation_american ;
27951: LD_ADDR_OWVAR 21
27955: PUSH
27956: LD_INT 1
27958: ST_TO_ADDR
// vc_chassis := us_morphling ;
27959: LD_ADDR_OWVAR 37
27963: PUSH
27964: LD_INT 5
27966: ST_TO_ADDR
// vc_engine := engine_siberite ;
27967: LD_ADDR_OWVAR 39
27971: PUSH
27972: LD_INT 3
27974: ST_TO_ADDR
// vc_control := control_computer ;
27975: LD_ADDR_OWVAR 38
27979: PUSH
27980: LD_INT 3
27982: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27983: LD_ADDR_OWVAR 40
27987: PUSH
27988: LD_INT 10
27990: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27991: CALL_OW 45
27995: PPUSH
27996: LD_VAR 0 2
28000: PUSH
28001: LD_INT 1
28003: ARRAY
28004: PPUSH
28005: CALL_OW 250
28009: PPUSH
28010: LD_VAR 0 2
28014: PUSH
28015: LD_INT 1
28017: ARRAY
28018: PPUSH
28019: CALL_OW 251
28023: PPUSH
28024: LD_INT 12
28026: PPUSH
28027: LD_INT 1
28029: PPUSH
28030: CALL_OW 50
// end ;
28034: GO 27938
28036: POP
28037: POP
// end ;
28038: PPOPN 2
28040: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28041: LD_EXP 59
28045: PUSH
28046: LD_EXP 105
28050: AND
28051: IFFALSE 28273
28053: GO 28055
28055: DISABLE
28056: LD_INT 0
28058: PPUSH
28059: PPUSH
28060: PPUSH
28061: PPUSH
28062: PPUSH
28063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28064: LD_ADDR_VAR 0 6
28068: PUSH
28069: LD_INT 22
28071: PUSH
28072: LD_OWVAR 2
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 21
28083: PUSH
28084: LD_INT 1
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 3
28093: PUSH
28094: LD_INT 23
28096: PUSH
28097: LD_INT 0
28099: PUSH
28100: EMPTY
28101: LIST
28102: LIST
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: LIST
28112: PPUSH
28113: CALL_OW 69
28117: ST_TO_ADDR
// if not tmp then
28118: LD_VAR 0 6
28122: NOT
28123: IFFALSE 28127
// exit ;
28125: GO 28273
// s1 := rand ( 1 , 4 ) ;
28127: LD_ADDR_VAR 0 2
28131: PUSH
28132: LD_INT 1
28134: PPUSH
28135: LD_INT 4
28137: PPUSH
28138: CALL_OW 12
28142: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28143: LD_ADDR_VAR 0 4
28147: PUSH
28148: LD_VAR 0 6
28152: PUSH
28153: LD_INT 1
28155: ARRAY
28156: PPUSH
28157: LD_VAR 0 2
28161: PPUSH
28162: CALL_OW 259
28166: ST_TO_ADDR
// if s1 = 1 then
28167: LD_VAR 0 2
28171: PUSH
28172: LD_INT 1
28174: EQUAL
28175: IFFALSE 28195
// s2 := rand ( 2 , 4 ) else
28177: LD_ADDR_VAR 0 3
28181: PUSH
28182: LD_INT 2
28184: PPUSH
28185: LD_INT 4
28187: PPUSH
28188: CALL_OW 12
28192: ST_TO_ADDR
28193: GO 28203
// s2 := 1 ;
28195: LD_ADDR_VAR 0 3
28199: PUSH
28200: LD_INT 1
28202: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28203: LD_ADDR_VAR 0 5
28207: PUSH
28208: LD_VAR 0 6
28212: PUSH
28213: LD_INT 1
28215: ARRAY
28216: PPUSH
28217: LD_VAR 0 3
28221: PPUSH
28222: CALL_OW 259
28226: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28227: LD_VAR 0 6
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PPUSH
28236: LD_VAR 0 2
28240: PPUSH
28241: LD_VAR 0 5
28245: PPUSH
28246: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28250: LD_VAR 0 6
28254: PUSH
28255: LD_INT 1
28257: ARRAY
28258: PPUSH
28259: LD_VAR 0 3
28263: PPUSH
28264: LD_VAR 0 4
28268: PPUSH
28269: CALL_OW 237
// end ;
28273: PPOPN 6
28275: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28276: LD_EXP 59
28280: PUSH
28281: LD_EXP 106
28285: AND
28286: IFFALSE 28365
28288: GO 28290
28290: DISABLE
28291: LD_INT 0
28293: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28294: LD_ADDR_VAR 0 1
28298: PUSH
28299: LD_INT 22
28301: PUSH
28302: LD_OWVAR 2
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 30
28313: PUSH
28314: LD_INT 3
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PPUSH
28325: CALL_OW 69
28329: ST_TO_ADDR
// if not tmp then
28330: LD_VAR 0 1
28334: NOT
28335: IFFALSE 28339
// exit ;
28337: GO 28365
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28339: LD_VAR 0 1
28343: PUSH
28344: LD_INT 1
28346: PPUSH
28347: LD_VAR 0 1
28351: PPUSH
28352: CALL_OW 12
28356: ARRAY
28357: PPUSH
28358: LD_INT 1
28360: PPUSH
28361: CALL_OW 234
// end ;
28365: PPOPN 1
28367: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28368: LD_EXP 59
28372: PUSH
28373: LD_EXP 107
28377: AND
28378: IFFALSE 28490
28380: GO 28382
28382: DISABLE
28383: LD_INT 0
28385: PPUSH
28386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28387: LD_ADDR_VAR 0 2
28391: PUSH
28392: LD_INT 22
28394: PUSH
28395: LD_OWVAR 2
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 2
28406: PUSH
28407: LD_INT 30
28409: PUSH
28410: LD_INT 27
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 30
28419: PUSH
28420: LD_INT 26
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 30
28429: PUSH
28430: LD_INT 28
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PPUSH
28447: CALL_OW 69
28451: ST_TO_ADDR
// if not tmp then
28452: LD_VAR 0 2
28456: NOT
28457: IFFALSE 28461
// exit ;
28459: GO 28490
// for i in tmp do
28461: LD_ADDR_VAR 0 1
28465: PUSH
28466: LD_VAR 0 2
28470: PUSH
28471: FOR_IN
28472: IFFALSE 28488
// SetLives ( i , 1 ) ;
28474: LD_VAR 0 1
28478: PPUSH
28479: LD_INT 1
28481: PPUSH
28482: CALL_OW 234
28486: GO 28471
28488: POP
28489: POP
// end ;
28490: PPOPN 2
28492: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28493: LD_EXP 59
28497: PUSH
28498: LD_EXP 108
28502: AND
28503: IFFALSE 28777
28505: GO 28507
28507: DISABLE
28508: LD_INT 0
28510: PPUSH
28511: PPUSH
28512: PPUSH
// begin i := rand ( 1 , 7 ) ;
28513: LD_ADDR_VAR 0 1
28517: PUSH
28518: LD_INT 1
28520: PPUSH
28521: LD_INT 7
28523: PPUSH
28524: CALL_OW 12
28528: ST_TO_ADDR
// case i of 1 :
28529: LD_VAR 0 1
28533: PUSH
28534: LD_INT 1
28536: DOUBLE
28537: EQUAL
28538: IFTRUE 28542
28540: GO 28552
28542: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28543: LD_STRING earthquake(getX(game), 0, 32)
28545: PPUSH
28546: CALL_OW 559
28550: GO 28777
28552: LD_INT 2
28554: DOUBLE
28555: EQUAL
28556: IFTRUE 28560
28558: GO 28574
28560: POP
// begin ToLua ( displayStucuk(); ) ;
28561: LD_STRING displayStucuk();
28563: PPUSH
28564: CALL_OW 559
// ResetFog ;
28568: CALL_OW 335
// end ; 3 :
28572: GO 28777
28574: LD_INT 3
28576: DOUBLE
28577: EQUAL
28578: IFTRUE 28582
28580: GO 28686
28582: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28583: LD_ADDR_VAR 0 2
28587: PUSH
28588: LD_INT 22
28590: PUSH
28591: LD_OWVAR 2
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 25
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PPUSH
28614: CALL_OW 69
28618: ST_TO_ADDR
// if not tmp then
28619: LD_VAR 0 2
28623: NOT
28624: IFFALSE 28628
// exit ;
28626: GO 28777
// un := tmp [ rand ( 1 , tmp ) ] ;
28628: LD_ADDR_VAR 0 3
28632: PUSH
28633: LD_VAR 0 2
28637: PUSH
28638: LD_INT 1
28640: PPUSH
28641: LD_VAR 0 2
28645: PPUSH
28646: CALL_OW 12
28650: ARRAY
28651: ST_TO_ADDR
// if Crawls ( un ) then
28652: LD_VAR 0 3
28656: PPUSH
28657: CALL_OW 318
28661: IFFALSE 28672
// ComWalk ( un ) ;
28663: LD_VAR 0 3
28667: PPUSH
28668: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28672: LD_VAR 0 3
28676: PPUSH
28677: LD_INT 8
28679: PPUSH
28680: CALL_OW 336
// end ; 4 :
28684: GO 28777
28686: LD_INT 4
28688: DOUBLE
28689: EQUAL
28690: IFTRUE 28694
28692: GO 28755
28694: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28695: LD_ADDR_VAR 0 2
28699: PUSH
28700: LD_INT 22
28702: PUSH
28703: LD_OWVAR 2
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 30
28714: PUSH
28715: LD_INT 29
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PPUSH
28726: CALL_OW 69
28730: ST_TO_ADDR
// if not tmp then
28731: LD_VAR 0 2
28735: NOT
28736: IFFALSE 28740
// exit ;
28738: GO 28777
// DestroyUnit ( tmp [ 1 ] ) ;
28740: LD_VAR 0 2
28744: PUSH
28745: LD_INT 1
28747: ARRAY
28748: PPUSH
28749: CALL_OW 65
// end ; 5 .. 7 :
28753: GO 28777
28755: LD_INT 5
28757: DOUBLE
28758: GREATEREQUAL
28759: IFFALSE 28767
28761: LD_INT 7
28763: DOUBLE
28764: LESSEQUAL
28765: IFTRUE 28769
28767: GO 28776
28769: POP
// StreamSibBomb ; end ;
28770: CALL 25057 0 0
28774: GO 28777
28776: POP
// end ;
28777: PPOPN 3
28779: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28780: LD_EXP 59
28784: PUSH
28785: LD_EXP 109
28789: AND
28790: IFFALSE 28946
28792: GO 28794
28794: DISABLE
28795: LD_INT 0
28797: PPUSH
28798: PPUSH
28799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28800: LD_ADDR_VAR 0 2
28804: PUSH
28805: LD_INT 81
28807: PUSH
28808: LD_OWVAR 2
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: LD_INT 21
28822: PUSH
28823: LD_INT 1
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 21
28832: PUSH
28833: LD_INT 2
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PPUSH
28849: CALL_OW 69
28853: ST_TO_ADDR
// if not tmp then
28854: LD_VAR 0 2
28858: NOT
28859: IFFALSE 28863
// exit ;
28861: GO 28946
// p := 0 ;
28863: LD_ADDR_VAR 0 3
28867: PUSH
28868: LD_INT 0
28870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28871: LD_INT 35
28873: PPUSH
28874: CALL_OW 67
// p := p + 1 ;
28878: LD_ADDR_VAR 0 3
28882: PUSH
28883: LD_VAR 0 3
28887: PUSH
28888: LD_INT 1
28890: PLUS
28891: ST_TO_ADDR
// for i in tmp do
28892: LD_ADDR_VAR 0 1
28896: PUSH
28897: LD_VAR 0 2
28901: PUSH
28902: FOR_IN
28903: IFFALSE 28934
// if GetLives ( i ) < 1000 then
28905: LD_VAR 0 1
28909: PPUSH
28910: CALL_OW 256
28914: PUSH
28915: LD_INT 1000
28917: LESS
28918: IFFALSE 28932
// SetLives ( i , 1000 ) ;
28920: LD_VAR 0 1
28924: PPUSH
28925: LD_INT 1000
28927: PPUSH
28928: CALL_OW 234
28932: GO 28902
28934: POP
28935: POP
// until p > 20 ;
28936: LD_VAR 0 3
28940: PUSH
28941: LD_INT 20
28943: GREATER
28944: IFFALSE 28871
// end ;
28946: PPOPN 3
28948: END
// every 0 0$1 trigger StreamModeActive and sTime do
28949: LD_EXP 59
28953: PUSH
28954: LD_EXP 110
28958: AND
28959: IFFALSE 28994
28961: GO 28963
28963: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28964: LD_INT 28
28966: PPUSH
28967: LD_OWVAR 2
28971: PPUSH
28972: LD_INT 2
28974: PPUSH
28975: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28979: LD_INT 30
28981: PPUSH
28982: LD_OWVAR 2
28986: PPUSH
28987: LD_INT 2
28989: PPUSH
28990: CALL_OW 322
// end ;
28994: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28995: LD_EXP 59
28999: PUSH
29000: LD_EXP 111
29004: AND
29005: IFFALSE 29126
29007: GO 29009
29009: DISABLE
29010: LD_INT 0
29012: PPUSH
29013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29014: LD_ADDR_VAR 0 2
29018: PUSH
29019: LD_INT 22
29021: PUSH
29022: LD_OWVAR 2
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: LD_INT 21
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 3
29043: PUSH
29044: LD_INT 23
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: LIST
29062: PPUSH
29063: CALL_OW 69
29067: ST_TO_ADDR
// if not tmp then
29068: LD_VAR 0 2
29072: NOT
29073: IFFALSE 29077
// exit ;
29075: GO 29126
// for i in tmp do
29077: LD_ADDR_VAR 0 1
29081: PUSH
29082: LD_VAR 0 2
29086: PUSH
29087: FOR_IN
29088: IFFALSE 29124
// begin if Crawls ( i ) then
29090: LD_VAR 0 1
29094: PPUSH
29095: CALL_OW 318
29099: IFFALSE 29110
// ComWalk ( i ) ;
29101: LD_VAR 0 1
29105: PPUSH
29106: CALL_OW 138
// SetClass ( i , 2 ) ;
29110: LD_VAR 0 1
29114: PPUSH
29115: LD_INT 2
29117: PPUSH
29118: CALL_OW 336
// end ;
29122: GO 29087
29124: POP
29125: POP
// end ;
29126: PPOPN 2
29128: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29129: LD_EXP 59
29133: PUSH
29134: LD_EXP 112
29138: AND
29139: IFFALSE 29360
29141: GO 29143
29143: DISABLE
29144: LD_INT 0
29146: PPUSH
29147: PPUSH
29148: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29149: LD_OWVAR 2
29153: PPUSH
29154: LD_INT 9
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: LD_INT 1
29162: PPUSH
29163: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29167: LD_INT 9
29169: PPUSH
29170: LD_OWVAR 2
29174: PPUSH
29175: CALL_OW 343
// uc_side := 9 ;
29179: LD_ADDR_OWVAR 20
29183: PUSH
29184: LD_INT 9
29186: ST_TO_ADDR
// uc_nation := 2 ;
29187: LD_ADDR_OWVAR 21
29191: PUSH
29192: LD_INT 2
29194: ST_TO_ADDR
// hc_name := Dark Warrior ;
29195: LD_ADDR_OWVAR 26
29199: PUSH
29200: LD_STRING Dark Warrior
29202: ST_TO_ADDR
// hc_gallery :=  ;
29203: LD_ADDR_OWVAR 33
29207: PUSH
29208: LD_STRING 
29210: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
29211: LD_INT 1
29213: PPUSH
29214: LD_INT 1
29216: PPUSH
29217: LD_INT 10
29219: PPUSH
29220: CALL_OW 380
// un := CreateHuman ;
29224: LD_ADDR_VAR 0 3
29228: PUSH
29229: CALL_OW 44
29233: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29234: LD_VAR 0 3
29238: PPUSH
29239: LD_INT 1
29241: PPUSH
29242: CALL_OW 51
// p := 0 ;
29246: LD_ADDR_VAR 0 2
29250: PUSH
29251: LD_INT 0
29253: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29254: LD_INT 35
29256: PPUSH
29257: CALL_OW 67
// if GetLives ( un ) < 1000 then
29261: LD_VAR 0 3
29265: PPUSH
29266: CALL_OW 256
29270: PUSH
29271: LD_INT 1000
29273: LESS
29274: IFFALSE 29288
// SetLives ( un , 1000 ) ;
29276: LD_VAR 0 3
29280: PPUSH
29281: LD_INT 1000
29283: PPUSH
29284: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
29288: LD_VAR 0 3
29292: PPUSH
29293: LD_INT 81
29295: PUSH
29296: LD_OWVAR 2
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PPUSH
29305: CALL_OW 69
29309: PPUSH
29310: LD_VAR 0 3
29314: PPUSH
29315: CALL_OW 74
29319: PPUSH
29320: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29324: LD_VAR 0 2
29328: PUSH
29329: LD_INT 60
29331: GREATER
29332: PUSH
29333: LD_VAR 0 3
29337: PPUSH
29338: CALL_OW 301
29342: OR
29343: IFFALSE 29254
// if un then
29345: LD_VAR 0 3
29349: IFFALSE 29360
// RemoveUnit ( un ) ;
29351: LD_VAR 0 3
29355: PPUSH
29356: CALL_OW 64
// end ; end_of_file
29360: PPOPN 3
29362: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
29363: LD_INT 0
29365: PPUSH
29366: PPUSH
29367: PPUSH
29368: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29369: LD_VAR 0 1
29373: PPUSH
29374: CALL_OW 264
29378: PUSH
29379: LD_EXP 58
29383: EQUAL
29384: IFFALSE 29456
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29386: LD_INT 68
29388: PPUSH
29389: LD_VAR 0 1
29393: PPUSH
29394: CALL_OW 255
29398: PPUSH
29399: CALL_OW 321
29403: PUSH
29404: LD_INT 2
29406: EQUAL
29407: IFFALSE 29419
// eff := 70 else
29409: LD_ADDR_VAR 0 6
29413: PUSH
29414: LD_INT 70
29416: ST_TO_ADDR
29417: GO 29427
// eff := 30 ;
29419: LD_ADDR_VAR 0 6
29423: PUSH
29424: LD_INT 30
29426: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29427: LD_VAR 0 1
29431: PPUSH
29432: CALL_OW 250
29436: PPUSH
29437: LD_VAR 0 1
29441: PPUSH
29442: CALL_OW 251
29446: PPUSH
29447: LD_VAR 0 6
29451: PPUSH
29452: CALL_OW 495
// end ; end ;
29456: LD_VAR 0 4
29460: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
29461: LD_INT 0
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
29468: PPUSH
// if cmd = 124 then
29469: LD_VAR 0 1
29473: PUSH
29474: LD_INT 124
29476: EQUAL
29477: IFFALSE 29683
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
29479: LD_ADDR_VAR 0 5
29483: PUSH
29484: LD_INT 2
29486: PUSH
29487: LD_INT 34
29489: PUSH
29490: LD_INT 53
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 34
29499: PUSH
29500: LD_INT 14
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: LIST
29511: PPUSH
29512: CALL_OW 69
29516: ST_TO_ADDR
// if not tmp then
29517: LD_VAR 0 5
29521: NOT
29522: IFFALSE 29526
// exit ;
29524: GO 29683
// for i in tmp do
29526: LD_ADDR_VAR 0 3
29530: PUSH
29531: LD_VAR 0 5
29535: PUSH
29536: FOR_IN
29537: IFFALSE 29681
// begin taskList := GetTaskList ( i ) ;
29539: LD_ADDR_VAR 0 6
29543: PUSH
29544: LD_VAR 0 3
29548: PPUSH
29549: CALL_OW 437
29553: ST_TO_ADDR
// if not taskList then
29554: LD_VAR 0 6
29558: NOT
29559: IFFALSE 29563
// continue ;
29561: GO 29536
// for j = 1 to taskList do
29563: LD_ADDR_VAR 0 4
29567: PUSH
29568: DOUBLE
29569: LD_INT 1
29571: DEC
29572: ST_TO_ADDR
29573: LD_VAR 0 6
29577: PUSH
29578: FOR_TO
29579: IFFALSE 29677
// if taskList [ j ] [ 1 ] = | then
29581: LD_VAR 0 6
29585: PUSH
29586: LD_VAR 0 4
29590: ARRAY
29591: PUSH
29592: LD_INT 1
29594: ARRAY
29595: PUSH
29596: LD_STRING |
29598: EQUAL
29599: IFFALSE 29675
// begin _taskList := Delete ( taskList , 1 ) ;
29601: LD_ADDR_VAR 0 7
29605: PUSH
29606: LD_VAR 0 6
29610: PPUSH
29611: LD_INT 1
29613: PPUSH
29614: CALL_OW 3
29618: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
29619: LD_VAR 0 3
29623: PPUSH
29624: LD_VAR 0 7
29628: PPUSH
29629: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
29633: LD_VAR 0 3
29637: PPUSH
29638: LD_VAR 0 6
29642: PUSH
29643: LD_VAR 0 4
29647: ARRAY
29648: PUSH
29649: LD_INT 2
29651: ARRAY
29652: PPUSH
29653: LD_VAR 0 6
29657: PUSH
29658: LD_VAR 0 4
29662: ARRAY
29663: PUSH
29664: LD_INT 3
29666: ARRAY
29667: PPUSH
29668: LD_INT 8
29670: PPUSH
29671: CALL 29688 0 4
// end ;
29675: GO 29578
29677: POP
29678: POP
// end ;
29679: GO 29536
29681: POP
29682: POP
// end ; end ;
29683: LD_VAR 0 2
29687: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29688: LD_INT 0
29690: PPUSH
29691: PPUSH
29692: PPUSH
29693: PPUSH
29694: PPUSH
29695: PPUSH
29696: PPUSH
29697: PPUSH
29698: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29699: LD_VAR 0 1
29703: NOT
29704: PUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: LD_VAR 0 3
29714: PPUSH
29715: CALL_OW 488
29719: NOT
29720: OR
29721: PUSH
29722: LD_VAR 0 4
29726: NOT
29727: OR
29728: IFFALSE 29732
// exit ;
29730: GO 30072
// list := [ ] ;
29732: LD_ADDR_VAR 0 13
29736: PUSH
29737: EMPTY
29738: ST_TO_ADDR
// if x - r < 0 then
29739: LD_VAR 0 2
29743: PUSH
29744: LD_VAR 0 4
29748: MINUS
29749: PUSH
29750: LD_INT 0
29752: LESS
29753: IFFALSE 29765
// min_x := 0 else
29755: LD_ADDR_VAR 0 7
29759: PUSH
29760: LD_INT 0
29762: ST_TO_ADDR
29763: GO 29781
// min_x := x - r ;
29765: LD_ADDR_VAR 0 7
29769: PUSH
29770: LD_VAR 0 2
29774: PUSH
29775: LD_VAR 0 4
29779: MINUS
29780: ST_TO_ADDR
// if y - r < 0 then
29781: LD_VAR 0 3
29785: PUSH
29786: LD_VAR 0 4
29790: MINUS
29791: PUSH
29792: LD_INT 0
29794: LESS
29795: IFFALSE 29807
// min_y := 0 else
29797: LD_ADDR_VAR 0 8
29801: PUSH
29802: LD_INT 0
29804: ST_TO_ADDR
29805: GO 29823
// min_y := y - r ;
29807: LD_ADDR_VAR 0 8
29811: PUSH
29812: LD_VAR 0 3
29816: PUSH
29817: LD_VAR 0 4
29821: MINUS
29822: ST_TO_ADDR
// max_x := x + r ;
29823: LD_ADDR_VAR 0 9
29827: PUSH
29828: LD_VAR 0 2
29832: PUSH
29833: LD_VAR 0 4
29837: PLUS
29838: ST_TO_ADDR
// max_y := y + r ;
29839: LD_ADDR_VAR 0 10
29843: PUSH
29844: LD_VAR 0 3
29848: PUSH
29849: LD_VAR 0 4
29853: PLUS
29854: ST_TO_ADDR
// for _x = min_x to max_x do
29855: LD_ADDR_VAR 0 11
29859: PUSH
29860: DOUBLE
29861: LD_VAR 0 7
29865: DEC
29866: ST_TO_ADDR
29867: LD_VAR 0 9
29871: PUSH
29872: FOR_TO
29873: IFFALSE 29990
// for _y = min_y to max_y do
29875: LD_ADDR_VAR 0 12
29879: PUSH
29880: DOUBLE
29881: LD_VAR 0 8
29885: DEC
29886: ST_TO_ADDR
29887: LD_VAR 0 10
29891: PUSH
29892: FOR_TO
29893: IFFALSE 29986
// begin if not ValidHex ( _x , _y ) then
29895: LD_VAR 0 11
29899: PPUSH
29900: LD_VAR 0 12
29904: PPUSH
29905: CALL_OW 488
29909: NOT
29910: IFFALSE 29914
// continue ;
29912: GO 29892
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29914: LD_VAR 0 11
29918: PPUSH
29919: LD_VAR 0 12
29923: PPUSH
29924: CALL_OW 351
29928: PUSH
29929: LD_VAR 0 11
29933: PPUSH
29934: LD_VAR 0 12
29938: PPUSH
29939: CALL_OW 554
29943: AND
29944: IFFALSE 29984
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29946: LD_ADDR_VAR 0 13
29950: PUSH
29951: LD_VAR 0 13
29955: PPUSH
29956: LD_VAR 0 13
29960: PUSH
29961: LD_INT 1
29963: PLUS
29964: PPUSH
29965: LD_VAR 0 11
29969: PUSH
29970: LD_VAR 0 12
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PPUSH
29979: CALL_OW 2
29983: ST_TO_ADDR
// end ;
29984: GO 29892
29986: POP
29987: POP
29988: GO 29872
29990: POP
29991: POP
// if not list then
29992: LD_VAR 0 13
29996: NOT
29997: IFFALSE 30001
// exit ;
29999: GO 30072
// for i in list do
30001: LD_ADDR_VAR 0 6
30005: PUSH
30006: LD_VAR 0 13
30010: PUSH
30011: FOR_IN
30012: IFFALSE 30070
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30014: LD_VAR 0 1
30018: PPUSH
30019: LD_STRING M
30021: PUSH
30022: LD_VAR 0 6
30026: PUSH
30027: LD_INT 1
30029: ARRAY
30030: PUSH
30031: LD_VAR 0 6
30035: PUSH
30036: LD_INT 2
30038: ARRAY
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: LD_INT 0
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: PUSH
30061: EMPTY
30062: LIST
30063: PPUSH
30064: CALL_OW 447
30068: GO 30011
30070: POP
30071: POP
// end ;
30072: LD_VAR 0 5
30076: RET
