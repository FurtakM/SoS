// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3489 0 0
// PrepareLegion ;
  27: CALL 7020 0 0
// Action ;
  31: CALL 10699 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 15378 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 255
2516: PUSH
2517: LD_OWVAR 2
2521: EQUAL
2522: IFFALSE 2538
// dead_counter := dead_counter + 1 ;
2524: LD_ADDR_EXP 14
2528: PUSH
2529: LD_EXP 14
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 81
2550: PUSH
2551: LD_OWVAR 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 69
2564: IN
2565: IFFALSE 2581
// kill_counter := kill_counter + 1 ;
2567: LD_ADDR_EXP 15
2571: PUSH
2572: LD_EXP 15
2576: PUSH
2577: LD_INT 1
2579: PLUS
2580: ST_TO_ADDR
// if un = player_commander then
2581: LD_VAR 0 1
2585: PUSH
2586: LD_EXP 10
2590: EQUAL
2591: IFFALSE 2600
// YouLost ( vulcano-lost ) ;
2593: LD_STRING vulcano-lost
2595: PPUSH
2596: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2600: LD_VAR 0 1
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 3
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 3
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: IN
2634: IFFALSE 2750
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2636: LD_VAR 0 1
2640: PPUSH
2641: CALL_OW 266
2645: PUSH
2646: LD_INT 33
2648: EQUAL
2649: PUSH
2650: LD_VAR 0 1
2654: PPUSH
2655: CALL_OW 266
2659: PUSH
2660: LD_INT 28
2662: EQUAL
2663: OR
2664: IFFALSE 2750
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2666: LD_ADDR_EXP 26
2670: PUSH
2671: LD_EXP 26
2675: PUSH
2676: LD_VAR 0 1
2680: PPUSH
2681: CALL_OW 266
2685: ADD
2686: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2687: LD_ADDR_EXP 26
2691: PUSH
2692: LD_EXP 26
2696: PUSH
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 250
2706: ADD
2707: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2708: LD_ADDR_EXP 26
2712: PUSH
2713: LD_EXP 26
2717: PUSH
2718: LD_VAR 0 1
2722: PPUSH
2723: CALL_OW 251
2727: ADD
2728: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2729: LD_ADDR_EXP 26
2733: PUSH
2734: LD_EXP 26
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 254
2748: ADD
2749: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2750: LD_VAR 0 1
2754: PUSH
2755: LD_INT 22
2757: PUSH
2758: LD_INT 8
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 21
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 69
2783: IN
2784: IFFALSE 2928
// begin if GetBType ( un ) = b_barracks then
2786: LD_VAR 0 1
2790: PPUSH
2791: CALL_OW 266
2795: PUSH
2796: LD_INT 5
2798: EQUAL
2799: IFFALSE 2817
// legion_blist := legion_blist ^ b_armoury else
2801: LD_ADDR_EXP 34
2805: PUSH
2806: LD_EXP 34
2810: PUSH
2811: LD_INT 4
2813: ADD
2814: ST_TO_ADDR
2815: GO 2865
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2817: LD_VAR 0 1
2821: PPUSH
2822: CALL_OW 266
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 6
2832: PUSH
2833: LD_INT 8
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: IN
2841: NOT
2842: IFFALSE 2865
// legion_blist := legion_blist ^ GetBType ( un ) ;
2844: LD_ADDR_EXP 34
2848: PUSH
2849: LD_EXP 34
2853: PUSH
2854: LD_VAR 0 1
2858: PPUSH
2859: CALL_OW 266
2863: ADD
2864: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2865: LD_ADDR_EXP 34
2869: PUSH
2870: LD_EXP 34
2874: PUSH
2875: LD_VAR 0 1
2879: PPUSH
2880: CALL_OW 250
2884: ADD
2885: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2886: LD_ADDR_EXP 34
2890: PUSH
2891: LD_EXP 34
2895: PUSH
2896: LD_VAR 0 1
2900: PPUSH
2901: CALL_OW 251
2905: ADD
2906: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2907: LD_ADDR_EXP 34
2911: PUSH
2912: LD_EXP 34
2916: PUSH
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 254
2926: ADD
2927: ST_TO_ADDR
// end ; if un in legion_force then
2928: LD_VAR 0 1
2932: PUSH
2933: LD_EXP 31
2937: IN
2938: IFFALSE 2956
// legion_force := legion_force diff un ;
2940: LD_ADDR_EXP 31
2944: PUSH
2945: LD_EXP 31
2949: PUSH
2950: LD_VAR 0 1
2954: DIFF
2955: ST_TO_ADDR
// if un in ru_force then
2956: LD_VAR 0 1
2960: PUSH
2961: LD_EXP 23
2965: IN
2966: IFFALSE 2984
// ru_force := ru_force diff un ;
2968: LD_ADDR_EXP 23
2972: PUSH
2973: LD_EXP 23
2977: PUSH
2978: LD_VAR 0 1
2982: DIFF
2983: ST_TO_ADDR
// if un in al_force then
2984: LD_VAR 0 1
2988: PUSH
2989: LD_EXP 38
2993: IN
2994: IFFALSE 3012
// al_force := al_force diff un ;
2996: LD_ADDR_EXP 38
3000: PUSH
3001: LD_EXP 38
3005: PUSH
3006: LD_VAR 0 1
3010: DIFF
3011: ST_TO_ADDR
// end ;
3012: PPOPN 1
3014: END
// on BuildingComplete ( b ) do var i ;
3015: LD_INT 0
3017: PPUSH
// begin if GetSide ( b ) = 8 then
3018: LD_VAR 0 1
3022: PPUSH
3023: CALL_OW 255
3027: PUSH
3028: LD_INT 8
3030: EQUAL
3031: IFFALSE 3071
// for i = 1 to 4 do
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 4
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3069
// legion_blist := Delete ( legion_blist , 1 ) ;
3049: LD_ADDR_EXP 34
3053: PUSH
3054: LD_EXP 34
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: CALL_OW 3
3066: ST_TO_ADDR
3067: GO 3046
3069: POP
3070: POP
// if GetSide ( b ) = 3 then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 255
3080: PUSH
3081: LD_INT 3
3083: EQUAL
3084: IFFALSE 3124
// for i = 1 to 4 do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: DOUBLE
3092: LD_INT 1
3094: DEC
3095: ST_TO_ADDR
3096: LD_INT 4
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// ru_blist := Delete ( ru_blist , 1 ) ;
3102: LD_ADDR_EXP 26
3106: PUSH
3107: LD_EXP 26
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: CALL_OW 3
3119: ST_TO_ADDR
3120: GO 3099
3122: POP
3123: POP
// end ;
3124: PPOPN 2
3126: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3127: LD_VAR 0 1
3131: PPUSH
3132: CALL_OW 264
3136: PUSH
3137: LD_INT 51
3139: PUSH
3140: LD_INT 48
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: IN
3147: NOT
3148: IFFALSE 3196
// begin if GetSide ( veh ) = 3 then
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 255
3159: PUSH
3160: LD_INT 3
3162: EQUAL
3163: IFFALSE 3196
// begin ComMoveXY ( veh , 149 , 8 ) ;
3165: LD_VAR 0 1
3169: PPUSH
3170: LD_INT 149
3172: PPUSH
3173: LD_INT 8
3175: PPUSH
3176: CALL_OW 111
// ru_force := ru_force ^ veh ;
3180: LD_ADDR_EXP 23
3184: PUSH
3185: LD_EXP 23
3189: PUSH
3190: LD_VAR 0 1
3194: ADD
3195: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3196: LD_VAR 0 1
3200: PPUSH
3201: CALL_OW 264
3205: PUSH
3206: LD_INT 32
3208: PUSH
3209: LD_INT 31
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: IN
3216: NOT
3217: IFFALSE 3250
// begin if GetSide ( veh ) = 8 then
3219: LD_VAR 0 1
3223: PPUSH
3224: CALL_OW 255
3228: PUSH
3229: LD_INT 8
3231: EQUAL
3232: IFFALSE 3250
// legion_force := legion_force ^ veh ;
3234: LD_ADDR_EXP 31
3238: PUSH
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ADD
3249: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3250: LD_VAR 0 1
3254: PPUSH
3255: CALL_OW 255
3259: PUSH
3260: LD_INT 7
3262: EQUAL
3263: PUSH
3264: LD_OWVAR 2
3268: PUSH
3269: LD_INT 7
3271: NONEQUAL
3272: AND
3273: IFFALSE 3291
// al_force := al_force ^ veh ;
3275: LD_ADDR_EXP 38
3279: PUSH
3280: LD_EXP 38
3284: PUSH
3285: LD_VAR 0 1
3289: ADD
3290: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3291: LD_VAR 0 1
3295: PPUSH
3296: CALL_OW 255
3300: PUSH
3301: LD_OWVAR 2
3305: EQUAL
3306: IFFALSE 3322
// veh_counter := veh_counter + 1 ;
3308: LD_ADDR_EXP 16
3312: PUSH
3313: LD_EXP 16
3317: PUSH
3318: LD_INT 1
3320: PLUS
3321: ST_TO_ADDR
// end ;
3322: PPOPN 2
3324: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3325: LD_VAR 0 1
3329: PPUSH
3330: CALL_OW 255
3334: PUSH
3335: LD_OWVAR 2
3339: NONEQUAL
3340: IFFALSE 3356
// sib_contamin_counter := sib_contamin_counter + 1 ;
3342: LD_ADDR_EXP 18
3346: PUSH
3347: LD_EXP 18
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end ;
3356: PPOPN 3
3358: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3359: LD_VAR 0 2
3363: PPUSH
3364: CALL_OW 255
3368: PUSH
3369: LD_OWVAR 2
3373: EQUAL
3374: IFFALSE 3390
// tech_counter := tech_counter + 1 ;
3376: LD_ADDR_EXP 17
3380: PUSH
3381: LD_EXP 17
3385: PUSH
3386: LD_INT 1
3388: PLUS
3389: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3390: LD_VAR 0 1
3394: PUSH
3395: LD_INT 53
3397: EQUAL
3398: PUSH
3399: LD_OWVAR 2
3403: PUSH
3404: LD_INT 1
3406: EQUAL
3407: AND
3408: IFFALSE 3423
// SetTech ( 80 , 1 , state_researched ) ;
3410: LD_INT 80
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 322
// end ;
3423: PPOPN 2
3425: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3426: LD_INT 25
3428: PUSH
3429: LD_INT 12
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 69
3440: PUSH
3441: LD_INT 9
3443: LESS
3444: IFFALSE 3486
3446: GO 3448
3448: DISABLE
3449: LD_INT 0
3451: PPUSH
// begin enable ;
3452: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3453: LD_ADDR_VAR 0 1
3457: PUSH
3458: LD_INT 25
3460: PUSH
3461: LD_INT 12
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3473: LD_INT 8
3475: PUSH
3476: LD_VAR 0 1
3480: MINUS
3481: PPUSH
3482: CALL 1890 0 1
// end ; end_of_file
3486: PPOPN 1
3488: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3489: LD_INT 0
3491: PPUSH
3492: PPUSH
3493: PPUSH
3494: PPUSH
3495: PPUSH
3496: PPUSH
3497: PPUSH
3498: PPUSH
3499: PPUSH
3500: PPUSH
3501: PPUSH
// uc_side := 3 ;
3502: LD_ADDR_OWVAR 20
3506: PUSH
3507: LD_INT 3
3509: ST_TO_ADDR
// uc_nation := nation_russian ;
3510: LD_ADDR_OWVAR 21
3514: PUSH
3515: LD_INT 3
3517: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3518: LD_ADDR_VAR 0 4
3522: PUSH
3523: LD_INT 22
3525: PUSH
3526: LD_INT 3
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 30
3535: PUSH
3536: LD_INT 1
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PPUSH
3547: CALL_OW 69
3551: PUSH
3552: LD_INT 1
3554: ARRAY
3555: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3556: LD_ADDR_VAR 0 5
3560: PUSH
3561: LD_INT 22
3563: PUSH
3564: LD_INT 3
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: PUSH
3571: LD_INT 30
3573: PUSH
3574: LD_INT 3
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PPUSH
3585: CALL_OW 69
3589: PUSH
3590: LD_INT 1
3592: ARRAY
3593: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3594: LD_ADDR_VAR 0 6
3598: PUSH
3599: LD_INT 22
3601: PUSH
3602: LD_INT 3
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: PUSH
3609: LD_INT 30
3611: PUSH
3612: LD_INT 34
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL_OW 69
3627: PUSH
3628: LD_INT 1
3630: ARRAY
3631: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3632: LD_ADDR_VAR 0 8
3636: PUSH
3637: LD_INT 22
3639: PUSH
3640: LD_INT 3
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: LD_INT 33
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PUSH
3657: EMPTY
3658: LIST
3659: LIST
3660: PPUSH
3661: CALL_OW 69
3665: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3666: LD_ADDR_VAR 0 7
3670: PUSH
3671: LD_INT 22
3673: PUSH
3674: LD_INT 3
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 5
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PPUSH
3695: CALL_OW 69
3699: PUSH
3700: LD_INT 1
3702: ARRAY
3703: ST_TO_ADDR
// ru_blist := [ ] ;
3704: LD_ADDR_EXP 26
3708: PUSH
3709: EMPTY
3710: ST_TO_ADDR
// ru_vlist := [ ] ;
3711: LD_ADDR_EXP 27
3715: PUSH
3716: EMPTY
3717: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3718: LD_ADDR_EXP 30
3722: PUSH
3723: LD_INT 183
3725: PUSH
3726: LD_INT 62
3728: PUSH
3729: LD_INT 147
3731: PUSH
3732: LD_INT 44
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: LIST
3740: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3741: LD_INT 30
3743: PUSH
3744: LD_INT 34
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: PUSH
3756: LD_INT 1
3758: ARRAY
3759: PPUSH
3760: LD_EXP 30
3764: PUSH
3765: LD_INT 1
3767: ARRAY
3768: PPUSH
3769: LD_EXP 30
3773: PUSH
3774: LD_INT 2
3776: ARRAY
3777: PPUSH
3778: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3782: LD_ADDR_EXP 28
3786: PUSH
3787: LD_INT 4
3789: PUSH
3790: LD_INT 5
3792: PUSH
3793: LD_INT 6
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: LIST
3800: PUSH
3801: LD_OWVAR 67
3805: ARRAY
3806: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3807: LD_VAR 0 4
3811: PPUSH
3812: CALL_OW 274
3816: PPUSH
3817: LD_INT 1
3819: PPUSH
3820: LD_INT 3000
3822: PPUSH
3823: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3827: LD_VAR 0 4
3831: PPUSH
3832: CALL_OW 274
3836: PPUSH
3837: LD_INT 2
3839: PPUSH
3840: LD_INT 300
3842: PPUSH
3843: CALL_OW 277
// hc_gallery :=  ;
3847: LD_ADDR_OWVAR 33
3851: PUSH
3852: LD_STRING 
3854: ST_TO_ADDR
// hc_name :=  ;
3855: LD_ADDR_OWVAR 26
3859: PUSH
3860: LD_STRING 
3862: ST_TO_ADDR
// hc_importance := 0 ;
3863: LD_ADDR_OWVAR 32
3867: PUSH
3868: LD_INT 0
3870: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3871: LD_ADDR_EXP 24
3875: PUSH
3876: LD_INT 5
3878: PUSH
3879: LD_INT 6
3881: PUSH
3882: LD_INT 7
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: LIST
3889: PUSH
3890: LD_OWVAR 67
3894: ARRAY
3895: ST_TO_ADDR
// for i = 1 to 6 do
3896: LD_ADDR_VAR 0 2
3900: PUSH
3901: DOUBLE
3902: LD_INT 1
3904: DEC
3905: ST_TO_ADDR
3906: LD_INT 6
3908: PUSH
3909: FOR_TO
3910: IFFALSE 4068
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3912: LD_INT 0
3914: PPUSH
3915: LD_INT 9
3917: PPUSH
3918: LD_EXP 24
3922: PPUSH
3923: CALL_OW 380
// un := CreateHuman ;
3927: LD_ADDR_VAR 0 3
3931: PUSH
3932: CALL_OW 44
3936: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3937: LD_VAR 0 3
3941: PPUSH
3942: LD_VAR 0 7
3946: PPUSH
3947: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3951: LD_INT 0
3953: PPUSH
3954: LD_INT 4
3956: PPUSH
3957: LD_EXP 24
3961: PPUSH
3962: CALL_OW 380
// un := CreateHuman ;
3966: LD_ADDR_VAR 0 3
3970: PUSH
3971: CALL_OW 44
3975: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3976: LD_VAR 0 3
3980: PPUSH
3981: LD_INT 24
3983: PPUSH
3984: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 3
3993: PPUSH
3994: LD_EXP 24
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 3
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4013: LD_VAR 0 3
4017: PPUSH
4018: LD_VAR 0 5
4022: PPUSH
4023: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4027: LD_INT 0
4029: PPUSH
4030: LD_INT 2
4032: PPUSH
4033: LD_EXP 24
4037: PPUSH
4038: CALL_OW 380
// un := CreateHuman ;
4042: LD_ADDR_VAR 0 3
4046: PUSH
4047: CALL_OW 44
4051: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4052: LD_VAR 0 3
4056: PPUSH
4057: LD_VAR 0 4
4061: PPUSH
4062: CALL_OW 52
// end ;
4066: GO 3909
4068: POP
4069: POP
// russian_prepared := true ;
4070: LD_ADDR_EXP 2
4074: PUSH
4075: LD_INT 1
4077: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4078: LD_VAR 0 5
4082: PPUSH
4083: LD_INT 21
4085: PPUSH
4086: LD_INT 3
4088: PPUSH
4089: LD_INT 3
4091: PPUSH
4092: LD_INT 51
4094: PPUSH
4095: CALL_OW 125
// end ;
4099: LD_VAR 0 1
4103: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4104: LD_INT 22
4106: PUSH
4107: LD_INT 3
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: PUSH
4119: LD_INT 0
4121: GREATER
4122: PUSH
4123: LD_EXP 2
4127: AND
4128: IFFALSE 6591
4130: GO 4132
4132: DISABLE
4133: LD_INT 0
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
4145: PPUSH
4146: PPUSH
4147: PPUSH
4148: PPUSH
4149: PPUSH
4150: PPUSH
4151: PPUSH
// begin enable ;
4152: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4153: LD_ADDR_VAR 0 1
4157: PUSH
4158: LD_INT 22
4160: PUSH
4161: LD_INT 3
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 30
4170: PUSH
4171: LD_INT 1
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: PPUSH
4182: CALL_OW 69
4186: PUSH
4187: LD_INT 1
4189: ARRAY
4190: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4191: LD_ADDR_VAR 0 2
4195: PUSH
4196: LD_INT 22
4198: PUSH
4199: LD_INT 3
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 30
4208: PUSH
4209: LD_INT 3
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PPUSH
4220: CALL_OW 69
4224: PUSH
4225: LD_INT 1
4227: ARRAY
4228: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4229: LD_ADDR_VAR 0 3
4233: PUSH
4234: LD_INT 22
4236: PUSH
4237: LD_INT 3
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: LD_INT 30
4246: PUSH
4247: LD_INT 34
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: PPUSH
4258: CALL_OW 69
4262: PUSH
4263: LD_INT 1
4265: ARRAY
4266: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_INT 22
4274: PUSH
4275: LD_INT 3
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 30
4284: PUSH
4285: LD_INT 33
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PPUSH
4296: CALL_OW 69
4300: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4301: LD_ADDR_VAR 0 8
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 30
4318: PUSH
4319: LD_INT 5
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: PUSH
4335: LD_INT 1
4337: ARRAY
4338: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4339: LD_ADDR_VAR 0 5
4343: PUSH
4344: LD_INT 22
4346: PUSH
4347: LD_INT 3
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: LD_INT 21
4356: PUSH
4357: LD_INT 3
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: PPUSH
4368: CALL_OW 69
4372: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4373: LD_ADDR_VAR 0 6
4377: PUSH
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4407: LD_ADDR_VAR 0 7
4411: PUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 3
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 21
4424: PUSH
4425: LD_INT 1
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4441: LD_ADDR_VAR 0 9
4445: PUSH
4446: LD_VAR 0 7
4450: PPUSH
4451: LD_INT 25
4453: PUSH
4454: LD_INT 2
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 72
4465: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4466: LD_ADDR_VAR 0 10
4470: PUSH
4471: LD_VAR 0 7
4475: PPUSH
4476: LD_INT 25
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 72
4490: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4491: LD_ADDR_VAR 0 11
4495: PUSH
4496: LD_VAR 0 7
4500: PPUSH
4501: LD_INT 25
4503: PUSH
4504: LD_INT 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: PPUSH
4511: CALL_OW 72
4515: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4516: LD_INT 22
4518: PUSH
4519: LD_INT 3
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: PUSH
4526: LD_INT 34
4528: PUSH
4529: LD_INT 51
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: EMPTY
4537: LIST
4538: LIST
4539: PPUSH
4540: CALL_OW 69
4544: PUSH
4545: LD_INT 0
4547: GREATER
4548: PUSH
4549: LD_EXP 25
4553: PUSH
4554: LD_INT 0
4556: EQUAL
4557: AND
4558: IFFALSE 4598
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4560: LD_ADDR_EXP 25
4564: PUSH
4565: LD_INT 22
4567: PUSH
4568: LD_INT 3
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: PUSH
4575: LD_INT 34
4577: PUSH
4578: LD_INT 51
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: PPUSH
4589: CALL_OW 69
4593: PUSH
4594: LD_INT 1
4596: ARRAY
4597: ST_TO_ADDR
// if ru_cargo then
4598: LD_EXP 25
4602: IFFALSE 4900
// begin if IsInArea ( ru_cargo , ru_base ) then
4604: LD_EXP 25
4608: PPUSH
4609: LD_INT 9
4611: PPUSH
4612: CALL_OW 308
4616: IFFALSE 4695
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4618: LD_EXP 25
4622: PPUSH
4623: LD_INT 1
4625: PPUSH
4626: CALL_OW 289
4630: PUSH
4631: LD_INT 0
4633: EQUAL
4634: IFFALSE 4652
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4636: LD_EXP 25
4640: PPUSH
4641: LD_VAR 0 3
4645: PPUSH
4646: CALL_OW 120
4650: GO 4693
// if not HasTask ( ru_cargo ) then
4652: LD_EXP 25
4656: PPUSH
4657: CALL_OW 314
4661: NOT
4662: IFFALSE 4693
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4664: LD_EXP 25
4668: PPUSH
4669: LD_VAR 0 1
4673: PPUSH
4674: CALL_OW 250
4678: PPUSH
4679: LD_VAR 0 1
4683: PPUSH
4684: CALL_OW 251
4688: PPUSH
4689: CALL_OW 111
// end else
4693: GO 4900
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4695: LD_EXP 25
4699: PPUSH
4700: CALL_OW 314
4704: NOT
4705: PUSH
4706: LD_EXP 25
4710: PPUSH
4711: LD_INT 1
4713: PPUSH
4714: CALL_OW 289
4718: PUSH
4719: LD_INT 100
4721: LESS
4722: AND
4723: IFFALSE 4789
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4725: LD_ADDR_VAR 0 16
4729: PUSH
4730: LD_INT 11
4732: PPUSH
4733: CALL_OW 435
4737: ST_TO_ADDR
// if cr > 0 then
4738: LD_VAR 0 16
4742: PUSH
4743: LD_INT 0
4745: GREATER
4746: IFFALSE 4777
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4748: LD_EXP 25
4752: PPUSH
4753: LD_VAR 0 16
4757: PUSH
4758: LD_INT 1
4760: ARRAY
4761: PPUSH
4762: LD_VAR 0 16
4766: PUSH
4767: LD_INT 2
4769: ARRAY
4770: PPUSH
4771: CALL_OW 117
4775: GO 4789
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4777: LD_EXP 25
4781: PPUSH
4782: LD_INT 11
4784: PPUSH
4785: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4789: LD_EXP 25
4793: PPUSH
4794: CALL_OW 314
4798: NOT
4799: PUSH
4800: LD_EXP 25
4804: PPUSH
4805: LD_INT 10
4807: PPUSH
4808: CALL_OW 308
4812: NOT
4813: AND
4814: PUSH
4815: LD_EXP 25
4819: PPUSH
4820: LD_INT 1
4822: PPUSH
4823: CALL_OW 289
4827: PUSH
4828: LD_INT 100
4830: EQUAL
4831: AND
4832: IFFALSE 4846
// ComMoveToArea ( ru_cargo , cargoa ) ;
4834: LD_EXP 25
4838: PPUSH
4839: LD_INT 10
4841: PPUSH
4842: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4846: LD_EXP 25
4850: PPUSH
4851: LD_INT 10
4853: PPUSH
4854: CALL_OW 308
4858: PUSH
4859: LD_VAR 0 8
4863: AND
4864: IFFALSE 4900
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4866: LD_VAR 0 7
4870: PPUSH
4871: LD_INT 25
4873: PUSH
4874: LD_INT 9
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL_OW 72
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 139
4892: PPUSH
4893: LD_INT 24
4895: PPUSH
4896: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4900: LD_EXP 25
4904: PUSH
4905: LD_INT 0
4907: EQUAL
4908: PUSH
4909: LD_VAR 0 2
4913: AND
4914: PUSH
4915: LD_VAR 0 2
4919: PPUSH
4920: CALL_OW 461
4924: PUSH
4925: LD_INT 2
4927: EQUAL
4928: AND
4929: IFFALSE 4952
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4931: LD_VAR 0 2
4935: PPUSH
4936: LD_INT 21
4938: PPUSH
4939: LD_INT 3
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_INT 51
4947: PPUSH
4948: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4952: LD_VAR 0 7
4956: PPUSH
4957: LD_INT 25
4959: PUSH
4960: LD_INT 9
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: PPUSH
4967: CALL_OW 72
4971: IFFALSE 5035
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4973: LD_VAR 0 7
4977: PPUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 9
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PPUSH
4988: CALL_OW 72
4992: PPUSH
4993: LD_INT 22
4995: PUSH
4996: LD_OWVAR 2
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 3
5007: PUSH
5008: LD_INT 21
5010: PUSH
5011: LD_INT 3
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL_OW 69
5030: PPUSH
5031: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5035: LD_VAR 0 2
5039: PUSH
5040: LD_EXP 27
5044: PUSH
5045: LD_INT 0
5047: GREATER
5048: AND
5049: IFFALSE 5149
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5051: LD_VAR 0 2
5055: PPUSH
5056: CALL_OW 461
5060: PUSH
5061: LD_INT 2
5063: EQUAL
5064: IFFALSE 5149
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5066: LD_VAR 0 2
5070: PPUSH
5071: LD_EXP 27
5075: PUSH
5076: LD_INT 1
5078: ARRAY
5079: PPUSH
5080: LD_EXP 27
5084: PUSH
5085: LD_INT 2
5087: ARRAY
5088: PPUSH
5089: LD_EXP 27
5093: PUSH
5094: LD_INT 3
5096: ARRAY
5097: PPUSH
5098: LD_EXP 27
5102: PUSH
5103: LD_INT 4
5105: ARRAY
5106: PPUSH
5107: CALL_OW 125
// for i = 1 to 4 do
5111: LD_ADDR_VAR 0 12
5115: PUSH
5116: DOUBLE
5117: LD_INT 1
5119: DEC
5120: ST_TO_ADDR
5121: LD_INT 4
5123: PUSH
5124: FOR_TO
5125: IFFALSE 5147
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5127: LD_ADDR_EXP 27
5131: PUSH
5132: LD_EXP 27
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: CALL_OW 3
5144: ST_TO_ADDR
5145: GO 5124
5147: POP
5148: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5149: LD_INT 24
5151: PPUSH
5152: CALL_OW 461
5156: PUSH
5157: LD_INT 2
5159: EQUAL
5160: PUSH
5161: LD_EXP 4
5165: AND
5166: IFFALSE 5194
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5168: LD_INT 25
5170: PPUSH
5171: LD_INT 3
5173: PPUSH
5174: CALL_OW 321
5178: PUSH
5179: LD_INT 1
5181: EQUAL
5182: IFFALSE 5194
// ComResearch ( ru_lab , tech_sibfiss ) ;
5184: LD_INT 24
5186: PPUSH
5187: LD_INT 25
5189: PPUSH
5190: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5194: LD_INT 25
5196: PPUSH
5197: LD_INT 3
5199: PPUSH
5200: CALL_OW 321
5204: PUSH
5205: LD_INT 2
5207: EQUAL
5208: PUSH
5209: LD_OWVAR 1
5213: PUSH
5214: LD_INT 10500
5216: MOD
5217: PUSH
5218: LD_INT 0
5220: EQUAL
5221: AND
5222: IFFALSE 5260
// if BuildingStatus ( ru_factory ) = bs_idle then
5224: LD_VAR 0 2
5228: PPUSH
5229: CALL_OW 461
5233: PUSH
5234: LD_INT 2
5236: EQUAL
5237: IFFALSE 5260
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5239: LD_VAR 0 2
5243: PPUSH
5244: LD_INT 23
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 48
5255: PPUSH
5256: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5260: LD_INT 22
5262: PUSH
5263: LD_INT 3
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PUSH
5270: LD_INT 34
5272: PUSH
5273: LD_INT 48
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: PUSH
5289: LD_INT 0
5291: GREATER
5292: IFFALSE 5666
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5294: LD_ADDR_VAR 0 17
5298: PUSH
5299: LD_INT 22
5301: PUSH
5302: LD_INT 3
5304: PUSH
5305: EMPTY
5306: LIST
5307: LIST
5308: PUSH
5309: LD_INT 34
5311: PUSH
5312: LD_INT 48
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PPUSH
5323: CALL_OW 69
5327: PUSH
5328: LD_INT 1
5330: ARRAY
5331: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5332: LD_VAR 0 17
5336: PPUSH
5337: LD_INT 9
5339: PPUSH
5340: CALL_OW 308
5344: IFFALSE 5362
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5346: LD_VAR 0 17
5350: PPUSH
5351: LD_VAR 0 3
5355: PPUSH
5356: CALL_OW 120
5360: GO 5666
// if not HasTask ( sib_bomb ) then
5362: LD_VAR 0 17
5366: PPUSH
5367: CALL_OW 314
5371: NOT
5372: IFFALSE 5666
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5374: LD_INT 22
5376: PUSH
5377: LD_OWVAR 2
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 30
5388: PUSH
5389: LD_INT 1
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: PUSH
5405: LD_INT 1
5407: ARRAY
5408: PPUSH
5409: CALL_OW 256
5413: PUSH
5414: LD_INT 250
5416: GREATER
5417: IFFALSE 5510
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5419: LD_VAR 0 17
5423: PPUSH
5424: LD_INT 22
5426: PUSH
5427: LD_OWVAR 2
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 30
5438: PUSH
5439: LD_INT 1
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: PPUSH
5450: CALL_OW 69
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: CALL_OW 250
5463: PPUSH
5464: LD_INT 22
5466: PUSH
5467: LD_OWVAR 2
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 30
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PPUSH
5490: CALL_OW 69
5494: PUSH
5495: LD_INT 1
5497: ARRAY
5498: PPUSH
5499: CALL_OW 251
5503: PPUSH
5504: CALL_OW 116
5508: GO 5666
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5510: LD_INT 22
5512: PUSH
5513: LD_OWVAR 2
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 21
5524: PUSH
5525: LD_INT 3
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PPUSH
5536: CALL_OW 69
5540: PUSH
5541: LD_INT 0
5543: GREATER
5544: IFFALSE 5637
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5546: LD_VAR 0 17
5550: PPUSH
5551: LD_INT 22
5553: PUSH
5554: LD_OWVAR 2
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PUSH
5563: LD_INT 21
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PPUSH
5577: CALL_OW 69
5581: PUSH
5582: LD_INT 1
5584: ARRAY
5585: PPUSH
5586: CALL_OW 250
5590: PPUSH
5591: LD_INT 22
5593: PUSH
5594: LD_OWVAR 2
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: PUSH
5603: LD_INT 21
5605: PUSH
5606: LD_INT 3
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: PUSH
5613: EMPTY
5614: LIST
5615: LIST
5616: PPUSH
5617: CALL_OW 69
5621: PUSH
5622: LD_INT 1
5624: ARRAY
5625: PPUSH
5626: CALL_OW 251
5630: PPUSH
5631: CALL_OW 116
5635: GO 5666
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5637: LD_VAR 0 17
5641: PPUSH
5642: LD_EXP 10
5646: PPUSH
5647: CALL_OW 250
5651: PPUSH
5652: LD_EXP 10
5656: PPUSH
5657: CALL_OW 251
5661: PPUSH
5662: CALL_OW 116
// end ; if ru_can_attack then
5666: LD_EXP 3
5670: IFFALSE 5818
// if ru_time > 0 0$00 then
5672: LD_EXP 29
5676: PUSH
5677: LD_INT 0
5679: GREATER
5680: IFFALSE 5698
// ru_time := ru_time - 0 0$01 else
5682: LD_ADDR_EXP 29
5686: PUSH
5687: LD_EXP 29
5691: PUSH
5692: LD_INT 35
5694: MINUS
5695: ST_TO_ADDR
5696: GO 5818
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5698: LD_ADDR_EXP 29
5702: PUSH
5703: LD_INT 20265
5705: PPUSH
5706: LD_INT 30765
5708: PPUSH
5709: CALL_OW 12
5713: ST_TO_ADDR
// for i = 1 to ru_amount do
5714: LD_ADDR_VAR 0 12
5718: PUSH
5719: DOUBLE
5720: LD_INT 1
5722: DEC
5723: ST_TO_ADDR
5724: LD_EXP 28
5728: PUSH
5729: FOR_TO
5730: IFFALSE 5816
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5732: LD_ADDR_EXP 27
5736: PUSH
5737: LD_EXP 27
5741: PUSH
5742: LD_INT 23
5744: ADD
5745: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5746: LD_ADDR_EXP 27
5750: PUSH
5751: LD_EXP 27
5755: PUSH
5756: LD_INT 3
5758: ADD
5759: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5760: LD_ADDR_EXP 27
5764: PUSH
5765: LD_EXP 27
5769: PUSH
5770: LD_INT 3
5772: ADD
5773: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5774: LD_ADDR_EXP 27
5778: PUSH
5779: LD_EXP 27
5783: PUSH
5784: LD_INT 46
5786: PUSH
5787: LD_INT 45
5789: PUSH
5790: LD_INT 47
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_INT 2
5803: PPUSH
5804: LD_INT 3
5806: PPUSH
5807: CALL_OW 14
5811: ARRAY
5812: ADD
5813: ST_TO_ADDR
// end ;
5814: GO 5729
5816: POP
5817: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5818: LD_VAR 0 4
5822: PPUSH
5823: LD_INT 35
5825: PUSH
5826: LD_INT 0
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PPUSH
5833: CALL_OW 72
5837: PUSH
5838: LD_INT 0
5840: GREATER
5841: IFFALSE 5889
// if BuildingStatus ( ru_factory ) = bs_idle then
5843: LD_VAR 0 2
5847: PPUSH
5848: CALL_OW 461
5852: PUSH
5853: LD_INT 2
5855: EQUAL
5856: IFFALSE 5889
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5858: LD_VAR 0 4
5862: PPUSH
5863: LD_INT 35
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: PPUSH
5873: CALL_OW 72
5877: PUSH
5878: LD_INT 1
5880: ARRAY
5881: PPUSH
5882: LD_INT 47
5884: PPUSH
5885: CALL_OW 148
// if ru_force = ru_amount then
5889: LD_EXP 23
5893: PUSH
5894: LD_EXP 28
5898: EQUAL
5899: IFFALSE 6031
// begin for i = 1 to ru_force do
5901: LD_ADDR_VAR 0 12
5905: PUSH
5906: DOUBLE
5907: LD_INT 1
5909: DEC
5910: ST_TO_ADDR
5911: LD_EXP 23
5915: PUSH
5916: FOR_TO
5917: IFFALSE 6027
// if IsInArea ( ru_force [ i ] , ru_base ) then
5919: LD_EXP 23
5923: PUSH
5924: LD_VAR 0 12
5928: ARRAY
5929: PPUSH
5930: LD_INT 9
5932: PPUSH
5933: CALL_OW 308
5937: IFFALSE 5961
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5939: LD_EXP 23
5943: PUSH
5944: LD_VAR 0 12
5948: ARRAY
5949: PPUSH
5950: LD_VAR 0 3
5954: PPUSH
5955: CALL_OW 120
5959: GO 6025
// if not HasTask ( ru_force [ i ] ) then
5961: LD_EXP 23
5965: PUSH
5966: LD_VAR 0 12
5970: ARRAY
5971: PPUSH
5972: CALL_OW 314
5976: NOT
5977: IFFALSE 6025
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5979: LD_EXP 23
5983: PUSH
5984: LD_VAR 0 12
5988: ARRAY
5989: PPUSH
5990: LD_INT 81
5992: PUSH
5993: LD_INT 3
5995: PUSH
5996: EMPTY
5997: LIST
5998: LIST
5999: PPUSH
6000: CALL_OW 69
6004: PPUSH
6005: LD_EXP 23
6009: PUSH
6010: LD_VAR 0 12
6014: ARRAY
6015: PPUSH
6016: CALL_OW 74
6020: PPUSH
6021: CALL_OW 115
6025: GO 5916
6027: POP
6028: POP
// end else
6029: GO 6181
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6031: LD_EXP 23
6035: PPUSH
6036: LD_INT 3
6038: PUSH
6039: LD_INT 95
6041: PUSH
6042: LD_INT 18
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PPUSH
6053: CALL_OW 72
6057: PUSH
6058: LD_INT 0
6060: GREATER
6061: IFFALSE 6181
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6063: LD_ADDR_VAR 0 13
6067: PUSH
6068: LD_EXP 23
6072: PPUSH
6073: LD_INT 3
6075: PUSH
6076: LD_INT 95
6078: PUSH
6079: LD_INT 18
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: PPUSH
6090: CALL_OW 72
6094: ST_TO_ADDR
// for i = 1 to tmp do
6095: LD_ADDR_VAR 0 12
6099: PUSH
6100: DOUBLE
6101: LD_INT 1
6103: DEC
6104: ST_TO_ADDR
6105: LD_VAR 0 13
6109: PUSH
6110: FOR_TO
6111: IFFALSE 6179
// if not HasTask ( tmp [ i ] ) then
6113: LD_VAR 0 13
6117: PUSH
6118: LD_VAR 0 12
6122: ARRAY
6123: PPUSH
6124: CALL_OW 314
6128: NOT
6129: IFFALSE 6177
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6131: LD_EXP 23
6135: PUSH
6136: LD_VAR 0 12
6140: ARRAY
6141: PPUSH
6142: LD_INT 81
6144: PUSH
6145: LD_INT 3
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: PPUSH
6157: LD_EXP 23
6161: PUSH
6162: LD_VAR 0 12
6166: ARRAY
6167: PPUSH
6168: CALL_OW 74
6172: PPUSH
6173: CALL_OW 115
6177: GO 6110
6179: POP
6180: POP
// end ; if ru_engs > 0 then
6181: LD_VAR 0 9
6185: PUSH
6186: LD_INT 0
6188: GREATER
6189: IFFALSE 6591
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6191: LD_VAR 0 5
6195: PPUSH
6196: LD_INT 3
6198: PUSH
6199: LD_INT 24
6201: PUSH
6202: LD_INT 1000
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PPUSH
6213: CALL_OW 72
6217: PUSH
6218: LD_INT 0
6220: GREATER
6221: IFFALSE 6376
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6223: LD_ADDR_VAR 0 14
6227: PUSH
6228: LD_VAR 0 5
6232: PPUSH
6233: LD_INT 3
6235: PUSH
6236: LD_INT 24
6238: PUSH
6239: LD_INT 1000
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: PPUSH
6250: CALL_OW 72
6254: ST_TO_ADDR
// for i = 1 to ru_engs do
6255: LD_ADDR_VAR 0 12
6259: PUSH
6260: DOUBLE
6261: LD_INT 1
6263: DEC
6264: ST_TO_ADDR
6265: LD_VAR 0 9
6269: PUSH
6270: FOR_TO
6271: IFFALSE 6372
// begin if IsInUnit ( ru_engs [ i ] ) then
6273: LD_VAR 0 9
6277: PUSH
6278: LD_VAR 0 12
6282: ARRAY
6283: PPUSH
6284: CALL_OW 310
6288: IFFALSE 6307
// ComExitBuilding ( ru_engs [ i ] ) else
6290: LD_VAR 0 9
6294: PUSH
6295: LD_VAR 0 12
6299: ARRAY
6300: PPUSH
6301: CALL_OW 122
6305: GO 6370
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6307: LD_VAR 0 9
6311: PUSH
6312: LD_VAR 0 12
6316: ARRAY
6317: PPUSH
6318: CALL_OW 314
6322: NOT
6323: PUSH
6324: LD_VAR 0 9
6328: PUSH
6329: LD_VAR 0 12
6333: ARRAY
6334: PPUSH
6335: CALL_OW 256
6339: PUSH
6340: LD_INT 600
6342: GREATER
6343: AND
6344: IFFALSE 6370
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6346: LD_VAR 0 9
6350: PUSH
6351: LD_VAR 0 12
6355: ARRAY
6356: PPUSH
6357: LD_VAR 0 14
6361: PUSH
6362: LD_INT 1
6364: ARRAY
6365: PPUSH
6366: CALL_OW 130
// end ;
6370: GO 6270
6372: POP
6373: POP
// end else
6374: GO 6591
// begin if ru_blist = 0 then
6376: LD_EXP 26
6380: PUSH
6381: LD_INT 0
6383: EQUAL
6384: IFFALSE 6466
// begin for i = 1 to ru_engs do
6386: LD_ADDR_VAR 0 12
6390: PUSH
6391: DOUBLE
6392: LD_INT 1
6394: DEC
6395: ST_TO_ADDR
6396: LD_VAR 0 9
6400: PUSH
6401: FOR_TO
6402: IFFALSE 6462
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6404: LD_VAR 0 9
6408: PUSH
6409: LD_VAR 0 12
6413: ARRAY
6414: PPUSH
6415: CALL_OW 314
6419: NOT
6420: PUSH
6421: LD_VAR 0 9
6425: PUSH
6426: LD_VAR 0 12
6430: ARRAY
6431: PPUSH
6432: CALL_OW 310
6436: NOT
6437: AND
6438: IFFALSE 6460
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6440: LD_VAR 0 9
6444: PUSH
6445: LD_VAR 0 12
6449: ARRAY
6450: PPUSH
6451: LD_VAR 0 1
6455: PPUSH
6456: CALL_OW 120
6460: GO 6401
6462: POP
6463: POP
// end else
6464: GO 6591
// begin for i = 1 to ru_engs do
6466: LD_ADDR_VAR 0 12
6470: PUSH
6471: DOUBLE
6472: LD_INT 1
6474: DEC
6475: ST_TO_ADDR
6476: LD_VAR 0 9
6480: PUSH
6481: FOR_TO
6482: IFFALSE 6589
// begin if IsInUnit ( ru_engs [ i ] ) then
6484: LD_VAR 0 9
6488: PUSH
6489: LD_VAR 0 12
6493: ARRAY
6494: PPUSH
6495: CALL_OW 310
6499: IFFALSE 6518
// ComExitBuilding ( ru_engs [ i ] ) else
6501: LD_VAR 0 9
6505: PUSH
6506: LD_VAR 0 12
6510: ARRAY
6511: PPUSH
6512: CALL_OW 122
6516: GO 6587
// if not HasTask ( ru_engs [ i ] ) then
6518: LD_VAR 0 9
6522: PUSH
6523: LD_VAR 0 12
6527: ARRAY
6528: PPUSH
6529: CALL_OW 314
6533: NOT
6534: IFFALSE 6587
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6536: LD_VAR 0 9
6540: PUSH
6541: LD_VAR 0 12
6545: ARRAY
6546: PPUSH
6547: LD_EXP 26
6551: PUSH
6552: LD_INT 1
6554: ARRAY
6555: PPUSH
6556: LD_EXP 26
6560: PUSH
6561: LD_INT 2
6563: ARRAY
6564: PPUSH
6565: LD_EXP 26
6569: PUSH
6570: LD_INT 3
6572: ARRAY
6573: PPUSH
6574: LD_EXP 26
6578: PUSH
6579: LD_INT 4
6581: ARRAY
6582: PPUSH
6583: CALL_OW 145
// end ;
6587: GO 6481
6589: POP
6590: POP
// end ; end ; end ; end ;
6591: PPOPN 17
6593: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6594: LD_EXP 2
6598: PUSH
6599: LD_INT 11
6601: PPUSH
6602: CALL_OW 435
6606: PUSH
6607: LD_INT 20
6609: LESS
6610: AND
6611: IFFALSE 6674
6613: GO 6615
6615: DISABLE
// begin enable ;
6616: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6617: LD_INT 1
6619: PPUSH
6620: LD_INT 5
6622: PPUSH
6623: CALL_OW 12
6627: PPUSH
6628: LD_INT 11
6630: PPUSH
6631: LD_INT 1
6633: PPUSH
6634: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6638: LD_INT 1505
6640: PPUSH
6641: LD_INT 2100
6643: PPUSH
6644: CALL_OW 12
6648: PPUSH
6649: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 5
6658: PPUSH
6659: CALL_OW 12
6663: PPUSH
6664: LD_INT 11
6666: PPUSH
6667: LD_INT 1
6669: PPUSH
6670: CALL_OW 55
// end ;
6674: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6675: LD_EXP 4
6679: PUSH
6680: LD_INT 0
6682: EQUAL
6683: IFFALSE 6798
6685: GO 6687
6687: DISABLE
6688: LD_INT 0
6690: PPUSH
6691: PPUSH
// begin enable ;
6692: ENABLE
// i := Rand ( 0 , 100 ) ;
6693: LD_ADDR_VAR 0 1
6697: PUSH
6698: LD_INT 0
6700: PPUSH
6701: LD_INT 100
6703: PPUSH
6704: CALL_OW 12
6708: ST_TO_ADDR
// case your_side of 1 :
6709: LD_OWVAR 2
6713: PUSH
6714: LD_INT 1
6716: DOUBLE
6717: EQUAL
6718: IFTRUE 6722
6720: GO 6733
6722: POP
// tmp := 10 ; 2 :
6723: LD_ADDR_VAR 0 2
6727: PUSH
6728: LD_INT 10
6730: ST_TO_ADDR
6731: GO 6772
6733: LD_INT 2
6735: DOUBLE
6736: EQUAL
6737: IFTRUE 6741
6739: GO 6752
6741: POP
// tmp := 0 ; 7 :
6742: LD_ADDR_VAR 0 2
6746: PUSH
6747: LD_INT 0
6749: ST_TO_ADDR
6750: GO 6772
6752: LD_INT 7
6754: DOUBLE
6755: EQUAL
6756: IFTRUE 6760
6758: GO 6771
6760: POP
// tmp := 15 ; end ;
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_INT 15
6768: ST_TO_ADDR
6769: GO 6772
6771: POP
// if i < chance_to_bomb + tmp then
6772: LD_VAR 0 1
6776: PUSH
6777: LD_EXP 5
6781: PUSH
6782: LD_VAR 0 2
6786: PLUS
6787: LESS
6788: IFFALSE 6798
// ru_sib_bomb := true ;
6790: LD_ADDR_EXP 4
6794: PUSH
6795: LD_INT 1
6797: ST_TO_ADDR
// end ;
6798: PPOPN 2
6800: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6801: LD_INT 22
6803: PUSH
6804: LD_OWVAR 2
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PUSH
6813: LD_INT 34
6815: PUSH
6816: LD_INT 8
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL_OW 69
6831: IFFALSE 6844
6833: GO 6835
6835: DISABLE
// begin ru_sib_bomb := true ;
6836: LD_ADDR_EXP 4
6840: PUSH
6841: LD_INT 1
6843: ST_TO_ADDR
// end ;
6844: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6845: LD_INT 22
6847: PUSH
6848: LD_INT 3
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 30
6857: PUSH
6858: LD_INT 34
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: PPUSH
6869: CALL_OW 69
6873: IFFALSE 6972
6875: GO 6877
6877: DISABLE
6878: LD_INT 0
6880: PPUSH
// begin enable ;
6881: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6882: LD_ADDR_VAR 0 1
6886: PUSH
6887: LD_INT 1
6889: PUSH
6890: LD_INT 3
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: LD_INT 1
6899: PPUSH
6900: LD_INT 2
6902: PPUSH
6903: CALL_OW 12
6907: ARRAY
6908: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6909: LD_INT 22
6911: PUSH
6912: LD_INT 3
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 30
6921: PUSH
6922: LD_INT 34
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PPUSH
6933: CALL_OW 69
6937: PUSH
6938: LD_INT 1
6940: ARRAY
6941: PPUSH
6942: LD_EXP 30
6946: PUSH
6947: LD_VAR 0 1
6951: ARRAY
6952: PPUSH
6953: LD_EXP 30
6957: PUSH
6958: LD_VAR 0 1
6962: PUSH
6963: LD_INT 1
6965: PLUS
6966: ARRAY
6967: PPUSH
6968: CALL_OW 243
// end ; end_of_file
6972: PPOPN 1
6974: END
// export function RemoveLegion ; var i ; begin
6975: LD_INT 0
6977: PPUSH
6978: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6979: LD_ADDR_VAR 0 2
6983: PUSH
6984: LD_INT 22
6986: PUSH
6987: LD_INT 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PPUSH
6994: CALL_OW 69
6998: PUSH
6999: FOR_IN
7000: IFFALSE 7013
// RemoveUnit ( i ) ;
7002: LD_VAR 0 2
7006: PPUSH
7007: CALL_OW 64
7011: GO 6999
7013: POP
7014: POP
// end ;
7015: LD_VAR 0 1
7019: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7020: LD_INT 0
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7032: LD_ADDR_VAR 0 7
7036: PUSH
7037: LD_INT 22
7039: PUSH
7040: LD_INT 8
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PUSH
7047: LD_INT 30
7049: PUSH
7050: LD_INT 1
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PPUSH
7061: CALL_OW 69
7065: PUSH
7066: LD_INT 1
7068: ARRAY
7069: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7070: LD_ADDR_VAR 0 8
7074: PUSH
7075: LD_INT 22
7077: PUSH
7078: LD_INT 8
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PUSH
7085: LD_INT 30
7087: PUSH
7088: LD_INT 3
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: PPUSH
7099: CALL_OW 69
7103: PUSH
7104: LD_INT 1
7106: ARRAY
7107: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7108: LD_ADDR_VAR 0 9
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_INT 8
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 30
7128: PUSH
7129: LD_INT 6
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: PUSH
7136: LD_INT 30
7138: PUSH
7139: LD_INT 8
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PPUSH
7155: CALL_OW 69
7159: PUSH
7160: LD_INT 1
7162: ARRAY
7163: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7164: LD_ADDR_VAR 0 10
7168: PUSH
7169: LD_INT 22
7171: PUSH
7172: LD_INT 8
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 30
7181: PUSH
7182: LD_INT 32
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PPUSH
7193: CALL_OW 69
7197: ST_TO_ADDR
// uc_side := 8 ;
7198: LD_ADDR_OWVAR 20
7202: PUSH
7203: LD_INT 8
7205: ST_TO_ADDR
// uc_nation := nation_arabian ;
7206: LD_ADDR_OWVAR 21
7210: PUSH
7211: LD_INT 2
7213: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7214: LD_ADDR_EXP 32
7218: PUSH
7219: LD_INT 5
7221: PUSH
7222: LD_INT 6
7224: PUSH
7225: LD_INT 7
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: LIST
7232: PUSH
7233: LD_OWVAR 67
7237: ARRAY
7238: ST_TO_ADDR
// legion_blist := [ ] ;
7239: LD_ADDR_EXP 34
7243: PUSH
7244: EMPTY
7245: ST_TO_ADDR
// legion_vlist := [ ] ;
7246: LD_ADDR_EXP 35
7250: PUSH
7251: EMPTY
7252: ST_TO_ADDR
// legion_force := [ ] ;
7253: LD_ADDR_EXP 31
7257: PUSH
7258: EMPTY
7259: ST_TO_ADDR
// legion_enemy := - 1 ;
7260: LD_ADDR_EXP 36
7264: PUSH
7265: LD_INT 1
7267: NEG
7268: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7269: LD_VAR 0 7
7273: PPUSH
7274: CALL_OW 274
7278: PPUSH
7279: LD_INT 1
7281: PPUSH
7282: LD_INT 10000
7284: PPUSH
7285: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7289: LD_VAR 0 7
7293: PPUSH
7294: CALL_OW 274
7298: PPUSH
7299: LD_INT 3
7301: PPUSH
7302: LD_INT 1000
7304: PPUSH
7305: CALL_OW 277
// for i = 1 to l_towers do
7309: LD_ADDR_VAR 0 3
7313: PUSH
7314: DOUBLE
7315: LD_INT 1
7317: DEC
7318: ST_TO_ADDR
7319: LD_VAR 0 10
7323: PUSH
7324: FOR_TO
7325: IFFALSE 7374
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7327: LD_INT 0
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: LD_EXP 32
7337: PPUSH
7338: CALL_OW 380
// un := CreateHuman ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: CALL_OW 44
7351: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7352: LD_VAR 0 2
7356: PPUSH
7357: LD_VAR 0 10
7361: PUSH
7362: LD_VAR 0 3
7366: ARRAY
7367: PPUSH
7368: CALL_OW 52
// end ;
7372: GO 7324
7374: POP
7375: POP
// for i = 1 to 4 do
7376: LD_ADDR_VAR 0 3
7380: PUSH
7381: DOUBLE
7382: LD_INT 1
7384: DEC
7385: ST_TO_ADDR
7386: LD_INT 4
7388: PUSH
7389: FOR_TO
7390: IFFALSE 7483
// for p = 1 to 2 do
7392: LD_ADDR_VAR 0 6
7396: PUSH
7397: DOUBLE
7398: LD_INT 1
7400: DEC
7401: ST_TO_ADDR
7402: LD_INT 2
7404: PUSH
7405: FOR_TO
7406: IFFALSE 7479
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7408: LD_INT 0
7410: PPUSH
7411: LD_INT 8
7413: PPUSH
7414: LD_EXP 32
7418: PPUSH
7419: CALL_OW 380
// un := CreateHuman ;
7423: LD_ADDR_VAR 0 2
7427: PUSH
7428: CALL_OW 44
7432: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7433: LD_VAR 0 2
7437: PPUSH
7438: LD_INT 22
7440: PUSH
7441: LD_INT 8
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 30
7450: PUSH
7451: LD_INT 5
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PPUSH
7462: CALL_OW 69
7466: PUSH
7467: LD_VAR 0 6
7471: ARRAY
7472: PPUSH
7473: CALL_OW 52
// end ;
7477: GO 7405
7479: POP
7480: POP
7481: GO 7389
7483: POP
7484: POP
// for i = 1 to 4 do
7485: LD_ADDR_VAR 0 3
7489: PUSH
7490: DOUBLE
7491: LD_INT 1
7493: DEC
7494: ST_TO_ADDR
7495: LD_INT 4
7497: PUSH
7498: FOR_TO
7499: IFFALSE 7542
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7501: LD_INT 0
7503: PPUSH
7504: LD_INT 4
7506: PPUSH
7507: LD_EXP 32
7511: PPUSH
7512: CALL_OW 380
// un := CreateHuman ;
7516: LD_ADDR_VAR 0 2
7520: PUSH
7521: CALL_OW 44
7525: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7526: LD_VAR 0 2
7530: PPUSH
7531: LD_VAR 0 9
7535: PPUSH
7536: CALL_OW 52
// end ;
7540: GO 7498
7542: POP
7543: POP
// for i = 1 to 6 do
7544: LD_ADDR_VAR 0 3
7548: PUSH
7549: DOUBLE
7550: LD_INT 1
7552: DEC
7553: ST_TO_ADDR
7554: LD_INT 6
7556: PUSH
7557: FOR_TO
7558: IFFALSE 7601
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7560: LD_INT 0
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_EXP 32
7570: PPUSH
7571: CALL_OW 380
// un := CreateHuman ;
7575: LD_ADDR_VAR 0 2
7579: PUSH
7580: CALL_OW 44
7584: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7585: LD_VAR 0 2
7589: PPUSH
7590: LD_VAR 0 8
7594: PPUSH
7595: CALL_OW 52
// end ;
7599: GO 7557
7601: POP
7602: POP
// for i = 1 to 5 do
7603: LD_ADDR_VAR 0 3
7607: PUSH
7608: DOUBLE
7609: LD_INT 1
7611: DEC
7612: ST_TO_ADDR
7613: LD_INT 5
7615: PUSH
7616: FOR_TO
7617: IFFALSE 7660
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7619: LD_INT 0
7621: PPUSH
7622: LD_INT 2
7624: PPUSH
7625: LD_EXP 32
7629: PPUSH
7630: CALL_OW 380
// un := CreateHuman ;
7634: LD_ADDR_VAR 0 2
7638: PUSH
7639: CALL_OW 44
7643: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7644: LD_VAR 0 2
7648: PPUSH
7649: LD_VAR 0 7
7653: PPUSH
7654: CALL_OW 52
// end ;
7658: GO 7616
7660: POP
7661: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7662: LD_ADDR_VAR 0 4
7666: PUSH
7667: LD_INT 199
7669: PPUSH
7670: LD_INT 134
7672: PPUSH
7673: LD_INT 216
7675: PPUSH
7676: LD_INT 141
7678: PPUSH
7679: LD_INT 6
7681: PPUSH
7682: CALL 1562 0 5
7686: ST_TO_ADDR
// p := 1 ;
7687: LD_ADDR_VAR 0 6
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i = 1 to 3 do
7695: LD_ADDR_VAR 0 3
7699: PUSH
7700: DOUBLE
7701: LD_INT 1
7703: DEC
7704: ST_TO_ADDR
7705: LD_INT 3
7707: PUSH
7708: FOR_TO
7709: IFFALSE 7962
// begin vc_chassis := ar_half_tracked ;
7711: LD_ADDR_OWVAR 37
7715: PUSH
7716: LD_INT 14
7718: ST_TO_ADDR
// vc_engine := engine_siberite ;
7719: LD_ADDR_OWVAR 39
7723: PUSH
7724: LD_INT 3
7726: ST_TO_ADDR
// vc_control := control_manual ;
7727: LD_ADDR_OWVAR 38
7731: PUSH
7732: LD_INT 1
7734: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7735: LD_ADDR_OWVAR 40
7739: PUSH
7740: LD_INT 31
7742: ST_TO_ADDR
// veh := CreateVehicle ;
7743: LD_ADDR_VAR 0 5
7747: PUSH
7748: CALL_OW 45
7752: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7753: LD_VAR 0 4
7757: PUSH
7758: LD_VAR 0 6
7762: ARRAY
7763: PPUSH
7764: LD_VAR 0 4
7768: PUSH
7769: LD_VAR 0 6
7773: PUSH
7774: LD_INT 1
7776: PLUS
7777: ARRAY
7778: PPUSH
7779: CALL_OW 428
7783: PUSH
7784: LD_INT 0
7786: EQUAL
7787: IFFALSE 7829
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7789: LD_VAR 0 5
7793: PPUSH
7794: LD_VAR 0 4
7798: PUSH
7799: LD_VAR 0 6
7803: ARRAY
7804: PPUSH
7805: LD_VAR 0 4
7809: PUSH
7810: LD_VAR 0 6
7814: PUSH
7815: LD_INT 1
7817: PLUS
7818: ARRAY
7819: PPUSH
7820: LD_INT 0
7822: PPUSH
7823: CALL_OW 48
7827: GO 7917
// begin repeat p := p + 2 ;
7829: LD_ADDR_VAR 0 6
7833: PUSH
7834: LD_VAR 0 6
7838: PUSH
7839: LD_INT 2
7841: PLUS
7842: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7843: LD_VAR 0 4
7847: PUSH
7848: LD_VAR 0 6
7852: ARRAY
7853: PPUSH
7854: LD_VAR 0 4
7858: PUSH
7859: LD_VAR 0 6
7863: PUSH
7864: LD_INT 1
7866: PLUS
7867: ARRAY
7868: PPUSH
7869: CALL_OW 428
7873: PUSH
7874: LD_INT 0
7876: EQUAL
7877: IFFALSE 7829
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7879: LD_VAR 0 5
7883: PPUSH
7884: LD_VAR 0 4
7888: PUSH
7889: LD_VAR 0 6
7893: ARRAY
7894: PPUSH
7895: LD_VAR 0 4
7899: PUSH
7900: LD_VAR 0 6
7904: PUSH
7905: LD_INT 1
7907: PLUS
7908: ARRAY
7909: PPUSH
7910: LD_INT 0
7912: PPUSH
7913: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7917: LD_INT 0
7919: PPUSH
7920: LD_INT 3
7922: PPUSH
7923: LD_EXP 32
7927: PUSH
7928: LD_INT 1
7930: PLUS
7931: PPUSH
7932: CALL_OW 380
// un := CreateHuman ;
7936: LD_ADDR_VAR 0 2
7940: PUSH
7941: CALL_OW 44
7945: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7946: LD_VAR 0 2
7950: PPUSH
7951: LD_VAR 0 5
7955: PPUSH
7956: CALL_OW 52
// end ;
7960: GO 7708
7962: POP
7963: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7964: LD_INT 198
7966: PPUSH
7967: LD_INT 94
7969: PPUSH
7970: LD_INT 8
7972: PPUSH
7973: LD_INT 10
7975: PPUSH
7976: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7980: LD_INT 167
7982: PPUSH
7983: LD_INT 130
7985: PPUSH
7986: LD_INT 8
7988: PPUSH
7989: LD_INT 10
7991: PPUSH
7992: CALL_OW 330
// legion_mines := [ ] ;
7996: LD_ADDR_EXP 33
8000: PUSH
8001: EMPTY
8002: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8003: LD_ADDR_EXP 33
8007: PUSH
8008: LD_INT 176
8010: PPUSH
8011: LD_INT 122
8013: PPUSH
8014: LD_INT 188
8016: PPUSH
8017: LD_INT 126
8019: PPUSH
8020: LD_INT 6
8022: PPUSH
8023: CALL 1562 0 5
8027: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8028: LD_ADDR_EXP 33
8032: PUSH
8033: LD_EXP 33
8037: PUSH
8038: LD_INT 197
8040: PPUSH
8041: LD_INT 91
8043: PPUSH
8044: LD_INT 205
8046: PPUSH
8047: LD_INT 96
8049: PPUSH
8050: LD_INT 4
8052: PPUSH
8053: CALL 1562 0 5
8057: ADD
8058: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8059: LD_ADDR_EXP 33
8063: PUSH
8064: LD_EXP 33
8068: PUSH
8069: LD_INT 184
8071: PPUSH
8072: LD_INT 151
8074: PPUSH
8075: LD_INT 178
8077: PPUSH
8078: LD_INT 130
8080: PPUSH
8081: LD_INT 9
8083: PPUSH
8084: CALL 1562 0 5
8088: ADD
8089: ST_TO_ADDR
// if Difficulty > 1 then
8090: LD_OWVAR 67
8094: PUSH
8095: LD_INT 1
8097: GREATER
8098: IFFALSE 8131
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8100: LD_ADDR_EXP 33
8104: PUSH
8105: LD_EXP 33
8109: PUSH
8110: LD_INT 166
8112: PPUSH
8113: LD_INT 126
8115: PPUSH
8116: LD_INT 181
8118: PPUSH
8119: LD_INT 136
8121: PPUSH
8122: LD_INT 5
8124: PPUSH
8125: CALL 1562 0 5
8129: ADD
8130: ST_TO_ADDR
// p := 1 ;
8131: LD_ADDR_VAR 0 6
8135: PUSH
8136: LD_INT 1
8138: ST_TO_ADDR
// for i = 1 to 24 do
8139: LD_ADDR_VAR 0 3
8143: PUSH
8144: DOUBLE
8145: LD_INT 1
8147: DEC
8148: ST_TO_ADDR
8149: LD_INT 24
8151: PUSH
8152: FOR_TO
8153: IFFALSE 8207
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8155: LD_EXP 33
8159: PUSH
8160: LD_VAR 0 6
8164: ARRAY
8165: PPUSH
8166: LD_EXP 33
8170: PUSH
8171: LD_VAR 0 6
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: ARRAY
8180: PPUSH
8181: LD_INT 8
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 454
// p := p + 2 ;
8191: LD_ADDR_VAR 0 6
8195: PUSH
8196: LD_VAR 0 6
8200: PUSH
8201: LD_INT 2
8203: PLUS
8204: ST_TO_ADDR
// end ;
8205: GO 8152
8207: POP
8208: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8209: LD_ADDR_EXP 35
8213: PUSH
8214: LD_INT 13
8216: PUSH
8217: LD_INT 3
8219: PUSH
8220: LD_INT 2
8222: PUSH
8223: LD_INT 32
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: ST_TO_ADDR
// end ;
8232: LD_VAR 0 1
8236: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8237: LD_INT 22
8239: PUSH
8240: LD_INT 8
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: PPUSH
8247: CALL_OW 69
8251: PUSH
8252: LD_INT 0
8254: GREATER
8255: IFFALSE 10441
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
8272: PPUSH
8273: PPUSH
8274: PPUSH
8275: PPUSH
8276: PPUSH
8277: PPUSH
8278: PPUSH
// begin enable ;
8279: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8280: LD_ADDR_VAR 0 8
8284: PUSH
8285: LD_INT 22
8287: PUSH
8288: LD_INT 8
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 30
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: EMPTY
8302: LIST
8303: LIST
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PPUSH
8309: CALL_OW 69
8313: PUSH
8314: LD_INT 1
8316: ARRAY
8317: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8318: LD_ADDR_VAR 0 9
8322: PUSH
8323: LD_INT 22
8325: PUSH
8326: LD_INT 8
8328: PUSH
8329: EMPTY
8330: LIST
8331: LIST
8332: PUSH
8333: LD_INT 30
8335: PUSH
8336: LD_INT 3
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: PPUSH
8347: CALL_OW 69
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8356: LD_ADDR_VAR 0 10
8360: PUSH
8361: LD_INT 22
8363: PUSH
8364: LD_INT 8
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 2
8373: PUSH
8374: LD_INT 30
8376: PUSH
8377: LD_INT 6
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PUSH
8384: LD_INT 30
8386: PUSH
8387: LD_INT 8
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 69
8407: PUSH
8408: LD_INT 1
8410: ARRAY
8411: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8412: LD_ADDR_VAR 0 11
8416: PUSH
8417: LD_INT 22
8419: PUSH
8420: LD_INT 8
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: LD_INT 30
8429: PUSH
8430: LD_INT 32
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: PPUSH
8441: CALL_OW 69
8445: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8446: LD_ADDR_VAR 0 16
8450: PUSH
8451: LD_INT 22
8453: PUSH
8454: LD_INT 8
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 25
8463: PUSH
8464: LD_INT 2
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PPUSH
8475: CALL_OW 69
8479: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8480: LD_ADDR_VAR 0 15
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_INT 8
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8514: LD_ADDR_VAR 0 14
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 25
8531: PUSH
8532: LD_INT 3
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8548: LD_ADDR_VAR 0 13
8552: PUSH
8553: LD_INT 22
8555: PUSH
8556: LD_INT 8
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 25
8565: PUSH
8566: LD_INT 4
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// if l_eng then
8582: LD_VAR 0 16
8586: IFFALSE 9001
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8588: LD_ADDR_VAR 0 5
8592: PUSH
8593: LD_INT 22
8595: PUSH
8596: LD_INT 8
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: LD_INT 21
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 69
8621: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8622: LD_VAR 0 5
8626: PPUSH
8627: LD_INT 3
8629: PUSH
8630: LD_INT 24
8632: PUSH
8633: LD_INT 1000
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 72
8648: PUSH
8649: LD_INT 0
8651: GREATER
8652: IFFALSE 8786
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8654: LD_ADDR_VAR 0 3
8658: PUSH
8659: LD_VAR 0 5
8663: PPUSH
8664: LD_INT 3
8666: PUSH
8667: LD_INT 24
8669: PUSH
8670: LD_INT 1000
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PPUSH
8681: CALL_OW 72
8685: ST_TO_ADDR
// for i = 1 to l_eng do
8686: LD_ADDR_VAR 0 2
8690: PUSH
8691: DOUBLE
8692: LD_INT 1
8694: DEC
8695: ST_TO_ADDR
8696: LD_VAR 0 16
8700: PUSH
8701: FOR_TO
8702: IFFALSE 8782
// if IsInUnit ( l_eng [ i ] ) then
8704: LD_VAR 0 16
8708: PUSH
8709: LD_VAR 0 2
8713: ARRAY
8714: PPUSH
8715: CALL_OW 310
8719: IFFALSE 8738
// ComExitBuilding ( l_eng [ i ] ) else
8721: LD_VAR 0 16
8725: PUSH
8726: LD_VAR 0 2
8730: ARRAY
8731: PPUSH
8732: CALL_OW 122
8736: GO 8780
// if not HasTask ( l_eng [ i ] ) then
8738: LD_VAR 0 16
8742: PUSH
8743: LD_VAR 0 2
8747: ARRAY
8748: PPUSH
8749: CALL_OW 314
8753: NOT
8754: IFFALSE 8780
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8756: LD_VAR 0 16
8760: PUSH
8761: LD_VAR 0 2
8765: ARRAY
8766: PPUSH
8767: LD_VAR 0 3
8771: PUSH
8772: LD_INT 1
8774: ARRAY
8775: PPUSH
8776: CALL_OW 130
8780: GO 8701
8782: POP
8783: POP
// end else
8784: GO 9001
// begin if legion_blist > 0 then
8786: LD_EXP 34
8790: PUSH
8791: LD_INT 0
8793: GREATER
8794: IFFALSE 8923
// begin for i = 1 to l_eng do
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: DOUBLE
8802: LD_INT 1
8804: DEC
8805: ST_TO_ADDR
8806: LD_VAR 0 16
8810: PUSH
8811: FOR_TO
8812: IFFALSE 8919
// if IsInUnit ( l_eng [ i ] ) then
8814: LD_VAR 0 16
8818: PUSH
8819: LD_VAR 0 2
8823: ARRAY
8824: PPUSH
8825: CALL_OW 310
8829: IFFALSE 8848
// ComExitBuilding ( l_eng [ i ] ) else
8831: LD_VAR 0 16
8835: PUSH
8836: LD_VAR 0 2
8840: ARRAY
8841: PPUSH
8842: CALL_OW 122
8846: GO 8917
// if not HasTask ( l_eng [ i ] ) then
8848: LD_VAR 0 16
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PPUSH
8859: CALL_OW 314
8863: NOT
8864: IFFALSE 8917
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8866: LD_VAR 0 16
8870: PUSH
8871: LD_VAR 0 2
8875: ARRAY
8876: PPUSH
8877: LD_EXP 34
8881: PUSH
8882: LD_INT 1
8884: ARRAY
8885: PPUSH
8886: LD_EXP 34
8890: PUSH
8891: LD_INT 2
8893: ARRAY
8894: PPUSH
8895: LD_EXP 34
8899: PUSH
8900: LD_INT 3
8902: ARRAY
8903: PPUSH
8904: LD_EXP 34
8908: PUSH
8909: LD_INT 4
8911: ARRAY
8912: PPUSH
8913: CALL_OW 145
8917: GO 8811
8919: POP
8920: POP
// end else
8921: GO 9001
// for i = 1 to l_eng do
8923: LD_ADDR_VAR 0 2
8927: PUSH
8928: DOUBLE
8929: LD_INT 1
8931: DEC
8932: ST_TO_ADDR
8933: LD_VAR 0 16
8937: PUSH
8938: FOR_TO
8939: IFFALSE 8999
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8941: LD_VAR 0 16
8945: PUSH
8946: LD_VAR 0 2
8950: ARRAY
8951: PPUSH
8952: CALL_OW 310
8956: NOT
8957: PUSH
8958: LD_VAR 0 16
8962: PUSH
8963: LD_VAR 0 2
8967: ARRAY
8968: PPUSH
8969: CALL_OW 314
8973: NOT
8974: AND
8975: IFFALSE 8997
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8977: LD_VAR 0 16
8981: PUSH
8982: LD_VAR 0 2
8986: ARRAY
8987: PPUSH
8988: LD_VAR 0 8
8992: PPUSH
8993: CALL_OW 120
8997: GO 8938
8999: POP
9000: POP
// end ; end ; if l_factory then
9001: LD_VAR 0 9
9005: IFFALSE 9405
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9007: LD_INT 22
9009: PUSH
9010: LD_INT 8
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: LD_INT 33
9019: PUSH
9020: LD_INT 2
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: LD_INT 61
9032: PUSH
9033: EMPTY
9034: LIST
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: LIST
9044: PPUSH
9045: CALL_OW 69
9049: PUSH
9050: LD_INT 0
9052: GREATER
9053: PUSH
9054: LD_INT 22
9056: PUSH
9057: LD_INT 8
9059: PUSH
9060: EMPTY
9061: LIST
9062: LIST
9063: PUSH
9064: LD_INT 34
9066: PUSH
9067: LD_INT 31
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PPUSH
9078: CALL_OW 69
9082: PUSH
9083: LD_INT 0
9085: GREATER
9086: AND
9087: IFFALSE 9207
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9089: LD_INT 22
9091: PUSH
9092: LD_INT 8
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: PUSH
9099: LD_INT 33
9101: PUSH
9102: LD_INT 2
9104: PUSH
9105: EMPTY
9106: LIST
9107: LIST
9108: PUSH
9109: LD_INT 3
9111: PUSH
9112: LD_INT 61
9114: PUSH
9115: EMPTY
9116: LIST
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: LIST
9126: PPUSH
9127: CALL_OW 69
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_INT 22
9138: PUSH
9139: LD_INT 8
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: PUSH
9146: LD_INT 34
9148: PUSH
9149: LD_INT 31
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PPUSH
9160: CALL_OW 69
9164: PUSH
9165: LD_INT 1
9167: PPUSH
9168: LD_INT 22
9170: PUSH
9171: LD_INT 8
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PUSH
9178: LD_INT 34
9180: PUSH
9181: LD_INT 31
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PUSH
9188: EMPTY
9189: LIST
9190: LIST
9191: PPUSH
9192: CALL_OW 69
9196: PPUSH
9197: CALL_OW 12
9201: ARRAY
9202: PPUSH
9203: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9207: LD_EXP 35
9211: PUSH
9212: LD_INT 0
9214: GREATER
9215: PUSH
9216: LD_VAR 0 9
9220: PPUSH
9221: CALL_OW 461
9225: PUSH
9226: LD_INT 2
9228: EQUAL
9229: AND
9230: IFFALSE 9315
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9232: LD_VAR 0 9
9236: PPUSH
9237: LD_EXP 35
9241: PUSH
9242: LD_INT 1
9244: ARRAY
9245: PPUSH
9246: LD_EXP 35
9250: PUSH
9251: LD_INT 2
9253: ARRAY
9254: PPUSH
9255: LD_EXP 35
9259: PUSH
9260: LD_INT 3
9262: ARRAY
9263: PPUSH
9264: LD_EXP 35
9268: PUSH
9269: LD_INT 4
9271: ARRAY
9272: PPUSH
9273: CALL_OW 125
// for i = 1 to 4 do
9277: LD_ADDR_VAR 0 2
9281: PUSH
9282: DOUBLE
9283: LD_INT 1
9285: DEC
9286: ST_TO_ADDR
9287: LD_INT 4
9289: PUSH
9290: FOR_TO
9291: IFFALSE 9313
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9293: LD_ADDR_EXP 35
9297: PUSH
9298: LD_EXP 35
9302: PPUSH
9303: LD_INT 1
9305: PPUSH
9306: CALL_OW 3
9310: ST_TO_ADDR
9311: GO 9290
9313: POP
9314: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9315: LD_VAR 0 11
9319: PPUSH
9320: LD_INT 35
9322: PUSH
9323: LD_INT 0
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PPUSH
9330: CALL_OW 72
9334: PUSH
9335: LD_INT 0
9337: GREATER
9338: PUSH
9339: LD_VAR 0 9
9343: PPUSH
9344: CALL_OW 461
9348: PUSH
9349: LD_INT 2
9351: EQUAL
9352: AND
9353: IFFALSE 9405
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9355: LD_VAR 0 11
9359: PPUSH
9360: LD_INT 35
9362: PUSH
9363: LD_INT 0
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 72
9374: PUSH
9375: LD_INT 1
9377: ARRAY
9378: PPUSH
9379: LD_INT 28
9381: PUSH
9382: LD_INT 27
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PUSH
9389: LD_INT 1
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 12
9399: ARRAY
9400: PPUSH
9401: CALL_OW 148
// end ; if legion_enemy > 0 then
9405: LD_EXP 36
9409: PUSH
9410: LD_INT 0
9412: GREATER
9413: IFFALSE 9993
// begin if tick mod 11 11$00 = 0 then
9415: LD_OWVAR 1
9419: PUSH
9420: LD_INT 23100
9422: MOD
9423: PUSH
9424: LD_INT 0
9426: EQUAL
9427: IFFALSE 9677
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9429: LD_ADDR_EXP 35
9433: PUSH
9434: LD_EXP 35
9438: PUSH
9439: LD_INT 13
9441: PUSH
9442: LD_INT 1
9444: PUSH
9445: LD_INT 2
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: LIST
9452: ADD
9453: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9454: LD_ADDR_EXP 35
9458: PUSH
9459: LD_EXP 35
9463: PUSH
9464: LD_INT 28
9466: PUSH
9467: LD_INT 27
9469: PUSH
9470: LD_INT 29
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: LIST
9477: PUSH
9478: LD_INT 1
9480: PPUSH
9481: LD_INT 3
9483: PPUSH
9484: CALL_OW 12
9488: ARRAY
9489: ADD
9490: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9491: LD_ADDR_EXP 35
9495: PUSH
9496: LD_EXP 35
9500: PUSH
9501: LD_INT 13
9503: PUSH
9504: LD_INT 1
9506: PUSH
9507: LD_INT 2
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: ADD
9515: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9516: LD_ADDR_EXP 35
9520: PUSH
9521: LD_EXP 35
9525: PUSH
9526: LD_INT 28
9528: PUSH
9529: LD_INT 27
9531: PUSH
9532: LD_INT 29
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 1
9542: PPUSH
9543: LD_INT 3
9545: PPUSH
9546: CALL_OW 12
9550: ARRAY
9551: ADD
9552: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9553: LD_ADDR_EXP 35
9557: PUSH
9558: LD_EXP 35
9562: PUSH
9563: LD_INT 13
9565: PUSH
9566: LD_INT 1
9568: PUSH
9569: LD_INT 2
9571: PUSH
9572: EMPTY
9573: LIST
9574: LIST
9575: LIST
9576: ADD
9577: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9578: LD_ADDR_EXP 35
9582: PUSH
9583: LD_EXP 35
9587: PUSH
9588: LD_INT 28
9590: PUSH
9591: LD_INT 27
9593: PUSH
9594: LD_INT 29
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 3
9607: PPUSH
9608: CALL_OW 12
9612: ARRAY
9613: ADD
9614: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9615: LD_ADDR_EXP 35
9619: PUSH
9620: LD_EXP 35
9624: PUSH
9625: LD_INT 13
9627: PUSH
9628: LD_INT 1
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: ADD
9639: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9640: LD_ADDR_EXP 35
9644: PUSH
9645: LD_EXP 35
9649: PUSH
9650: LD_INT 28
9652: PUSH
9653: LD_INT 27
9655: PUSH
9656: LD_INT 29
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 1
9666: PPUSH
9667: LD_INT 3
9669: PPUSH
9670: CALL_OW 12
9674: ARRAY
9675: ADD
9676: ST_TO_ADDR
// end ; if legion_force >= 7 then
9677: LD_EXP 31
9681: PUSH
9682: LD_INT 7
9684: GREATEREQUAL
9685: IFFALSE 9868
// begin for i = 1 to legion_force do
9687: LD_ADDR_VAR 0 2
9691: PUSH
9692: DOUBLE
9693: LD_INT 1
9695: DEC
9696: ST_TO_ADDR
9697: LD_EXP 31
9701: PUSH
9702: FOR_TO
9703: IFFALSE 9866
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9705: LD_EXP 31
9709: PUSH
9710: LD_VAR 0 2
9714: ARRAY
9715: PPUSH
9716: CALL_OW 314
9720: NOT
9721: PUSH
9722: LD_EXP 31
9726: PUSH
9727: LD_VAR 0 2
9731: ARRAY
9732: PPUSH
9733: CALL_OW 110
9737: PUSH
9738: LD_INT 11
9740: NONEQUAL
9741: AND
9742: IFFALSE 9864
// begin case legion_enemy of 1 :
9744: LD_EXP 36
9748: PUSH
9749: LD_INT 1
9751: DOUBLE
9752: EQUAL
9753: IFTRUE 9757
9755: GO 9781
9757: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9758: LD_EXP 31
9762: PUSH
9763: LD_VAR 0 2
9767: ARRAY
9768: PPUSH
9769: LD_INT 142
9771: PPUSH
9772: LD_INT 144
9774: PPUSH
9775: CALL_OW 111
9779: GO 9846
9781: LD_INT 2
9783: DOUBLE
9784: EQUAL
9785: IFTRUE 9789
9787: GO 9813
9789: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9790: LD_EXP 31
9794: PUSH
9795: LD_VAR 0 2
9799: ARRAY
9800: PPUSH
9801: LD_INT 101
9803: PPUSH
9804: LD_INT 34
9806: PPUSH
9807: CALL_OW 111
9811: GO 9846
9813: LD_INT 7
9815: DOUBLE
9816: EQUAL
9817: IFTRUE 9821
9819: GO 9845
9821: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9822: LD_EXP 31
9826: PUSH
9827: LD_VAR 0 2
9831: ARRAY
9832: PPUSH
9833: LD_INT 173
9835: PPUSH
9836: LD_INT 127
9838: PPUSH
9839: CALL_OW 111
9843: GO 9846
9845: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9846: LD_EXP 31
9850: PUSH
9851: LD_VAR 0 2
9855: ARRAY
9856: PPUSH
9857: LD_INT 11
9859: PPUSH
9860: CALL_OW 109
// end ; end ;
9864: GO 9702
9866: POP
9867: POP
// end ; if legion_force then
9868: LD_EXP 31
9872: IFFALSE 9993
// begin tmp := legion_force ;
9874: LD_ADDR_VAR 0 3
9878: PUSH
9879: LD_EXP 31
9883: ST_TO_ADDR
// for i = 1 to tmp do
9884: LD_ADDR_VAR 0 2
9888: PUSH
9889: DOUBLE
9890: LD_INT 1
9892: DEC
9893: ST_TO_ADDR
9894: LD_VAR 0 3
9898: PUSH
9899: FOR_TO
9900: IFFALSE 9991
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9902: LD_VAR 0 3
9906: PUSH
9907: LD_VAR 0 2
9911: ARRAY
9912: PPUSH
9913: CALL_OW 314
9917: NOT
9918: PUSH
9919: LD_EXP 31
9923: PUSH
9924: LD_VAR 0 2
9928: ARRAY
9929: PPUSH
9930: CALL_OW 110
9934: PUSH
9935: LD_INT 11
9937: EQUAL
9938: AND
9939: IFFALSE 9989
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9941: LD_VAR 0 3
9945: PUSH
9946: LD_VAR 0 2
9950: ARRAY
9951: PPUSH
9952: LD_INT 22
9954: PUSH
9955: LD_EXP 36
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PPUSH
9964: CALL_OW 69
9968: PPUSH
9969: LD_VAR 0 3
9973: PUSH
9974: LD_VAR 0 2
9978: ARRAY
9979: PPUSH
9980: CALL_OW 74
9984: PPUSH
9985: CALL_OW 115
9989: GO 9899
9991: POP
9992: POP
// end ; end ; p := 1 ;
9993: LD_ADDR_VAR 0 6
9997: PUSH
9998: LD_INT 1
10000: ST_TO_ADDR
// for i = 1 to 24 do
10001: LD_ADDR_VAR 0 2
10005: PUSH
10006: DOUBLE
10007: LD_INT 1
10009: DEC
10010: ST_TO_ADDR
10011: LD_INT 24
10013: PUSH
10014: FOR_TO
10015: IFFALSE 10145
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10017: LD_EXP 33
10021: PUSH
10022: LD_VAR 0 6
10026: ARRAY
10027: PPUSH
10028: LD_EXP 33
10032: PUSH
10033: LD_VAR 0 6
10037: PUSH
10038: LD_INT 1
10040: PLUS
10041: ARRAY
10042: PPUSH
10043: CALL_OW 428
10047: PUSH
10048: LD_INT 0
10050: GREATER
10051: IFFALSE 10129
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10053: LD_EXP 33
10057: PUSH
10058: LD_VAR 0 6
10062: ARRAY
10063: PPUSH
10064: LD_EXP 33
10068: PUSH
10069: LD_VAR 0 6
10073: PUSH
10074: LD_INT 1
10076: PLUS
10077: ARRAY
10078: PPUSH
10079: CALL_OW 428
10083: PPUSH
10084: CALL_OW 255
10088: PUSH
10089: LD_EXP 36
10093: EQUAL
10094: IFFALSE 10129
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10096: LD_EXP 33
10100: PUSH
10101: LD_VAR 0 6
10105: ARRAY
10106: PPUSH
10107: LD_EXP 33
10111: PUSH
10112: LD_VAR 0 6
10116: PUSH
10117: LD_INT 1
10119: PLUS
10120: ARRAY
10121: PPUSH
10122: LD_INT 8
10124: PPUSH
10125: CALL_OW 456
// p := p + 2 ;
10129: LD_ADDR_VAR 0 6
10133: PUSH
10134: LD_VAR 0 6
10138: PUSH
10139: LD_INT 2
10141: PLUS
10142: ST_TO_ADDR
// end ;
10143: GO 10014
10145: POP
10146: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10147: LD_INT 22
10149: PUSH
10150: LD_INT 8
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: LD_INT 34
10159: PUSH
10160: LD_INT 32
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PPUSH
10171: CALL_OW 69
10175: IFFALSE 10289
// begin if l_cargo = false then
10177: LD_VAR 0 17
10181: PUSH
10182: LD_INT 0
10184: EQUAL
10185: IFFALSE 10221
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10187: LD_ADDR_VAR 0 17
10191: PUSH
10192: LD_INT 22
10194: PUSH
10195: LD_INT 8
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 34
10204: PUSH
10205: LD_INT 32
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PUSH
10212: EMPTY
10213: LIST
10214: LIST
10215: PPUSH
10216: CALL_OW 69
10220: ST_TO_ADDR
// if l_cargo then
10221: LD_VAR 0 17
10225: IFFALSE 10289
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10227: LD_ADDR_VAR 0 7
10231: PUSH
10232: LD_INT 14
10234: PPUSH
10235: CALL_OW 435
10239: ST_TO_ADDR
// if cr > 0 then
10240: LD_VAR 0 7
10244: PUSH
10245: LD_INT 0
10247: GREATER
10248: IFFALSE 10289
// if not HasTask ( l_cargo ) then
10250: LD_VAR 0 17
10254: PPUSH
10255: CALL_OW 314
10259: NOT
10260: IFFALSE 10289
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10262: LD_VAR 0 17
10266: PPUSH
10267: LD_VAR 0 7
10271: PUSH
10272: LD_INT 1
10274: ARRAY
10275: PPUSH
10276: LD_VAR 0 7
10280: PUSH
10281: LD_INT 2
10283: ARRAY
10284: PPUSH
10285: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10289: LD_OWVAR 1
10293: PUSH
10294: LD_INT 52500
10296: PUSH
10297: LD_INT 46200
10299: PUSH
10300: LD_INT 42000
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: LD_OWVAR 67
10312: ARRAY
10313: EQUAL
10314: PUSH
10315: LD_INT 1
10317: PPUSH
10318: CALL_OW 469
10322: PUSH
10323: LD_INT 1
10325: ARRAY
10326: PUSH
10327: LD_INT 112
10329: EQUAL
10330: AND
10331: PUSH
10332: LD_INT 1
10334: PPUSH
10335: CALL_OW 469
10339: PUSH
10340: LD_INT 2
10342: ARRAY
10343: PUSH
10344: LD_INT 67
10346: EQUAL
10347: AND
10348: IFFALSE 10441
// begin un := l_eng [ 1 ] ;
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_VAR 0 16
10359: PUSH
10360: LD_INT 1
10362: ARRAY
10363: ST_TO_ADDR
// if IsInUnit ( un ) then
10364: LD_VAR 0 1
10368: PPUSH
10369: CALL_OW 310
10373: IFFALSE 10384
// ComExitBuilding ( un ) ;
10375: LD_VAR 0 1
10379: PPUSH
10380: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 1
10391: PPUSH
10392: CALL_OW 469
10396: PUSH
10397: LD_INT 1
10399: ARRAY
10400: PPUSH
10401: LD_INT 1
10403: PPUSH
10404: CALL_OW 469
10408: PUSH
10409: LD_INT 2
10411: ARRAY
10412: PPUSH
10413: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10417: LD_VAR 0 1
10421: PPUSH
10422: LD_INT 207
10424: PPUSH
10425: LD_INT 123
10427: PPUSH
10428: CALL_OW 171
// AddComUnload ( un ) ;
10432: LD_VAR 0 1
10436: PPUSH
10437: CALL_OW 219
// end ; end ;
10441: PPOPN 17
10443: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10444: LD_OWVAR 67
10448: PUSH
10449: LD_INT 1
10451: GREATER
10452: IFFALSE 10657
10454: GO 10456
10456: DISABLE
10457: LD_INT 0
10459: PPUSH
10460: PPUSH
10461: PPUSH
10462: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10463: LD_INT 35
10465: PPUSH
10466: LD_INT 12635
10468: PPUSH
10469: CALL_OW 12
10473: PPUSH
10474: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10478: LD_ADDR_VAR 0 2
10482: PUSH
10483: LD_INT 22
10485: PUSH
10486: LD_INT 8
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PUSH
10493: LD_INT 25
10495: PUSH
10496: LD_INT 4
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL_OW 69
10511: ST_TO_ADDR
// p := 1 ;
10512: LD_ADDR_VAR 0 4
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10520: LD_ADDR_VAR 0 3
10524: PUSH
10525: LD_INT 116
10527: PUSH
10528: LD_INT 139
10530: PUSH
10531: LD_INT 69
10533: PUSH
10534: LD_INT 13
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: ST_TO_ADDR
// for i = 1 to 2 do
10543: LD_ADDR_VAR 0 1
10547: PUSH
10548: DOUBLE
10549: LD_INT 1
10551: DEC
10552: ST_TO_ADDR
10553: LD_INT 2
10555: PUSH
10556: FOR_TO
10557: IFFALSE 10655
// begin if IsInUnit ( sci [ i ] ) then
10559: LD_VAR 0 2
10563: PUSH
10564: LD_VAR 0 1
10568: ARRAY
10569: PPUSH
10570: CALL_OW 310
10574: IFFALSE 10591
// ComExitBuilding ( sci [ i ] ) ;
10576: LD_VAR 0 2
10580: PUSH
10581: LD_VAR 0 1
10585: ARRAY
10586: PPUSH
10587: CALL_OW 122
// Wait ( 0 0$03 ) ;
10591: LD_INT 105
10593: PPUSH
10594: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10598: LD_VAR 0 2
10602: PUSH
10603: LD_VAR 0 1
10607: ARRAY
10608: PPUSH
10609: LD_VAR 0 3
10613: PUSH
10614: LD_VAR 0 4
10618: ARRAY
10619: PPUSH
10620: LD_VAR 0 3
10624: PUSH
10625: LD_VAR 0 4
10629: PUSH
10630: LD_INT 1
10632: PLUS
10633: ARRAY
10634: PPUSH
10635: CALL_OW 158
// p := p + 2 ;
10639: LD_ADDR_VAR 0 4
10643: PUSH
10644: LD_VAR 0 4
10648: PUSH
10649: LD_INT 2
10651: PLUS
10652: ST_TO_ADDR
// end ;
10653: GO 10556
10655: POP
10656: POP
// end ;
10657: PPOPN 4
10659: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10660: LD_INT 14
10662: PPUSH
10663: CALL_OW 435
10667: PUSH
10668: LD_INT 20
10670: LESS
10671: IFFALSE 10698
10673: GO 10675
10675: DISABLE
// begin enable ;
10676: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10677: LD_INT 1
10679: PPUSH
10680: LD_INT 5
10682: PPUSH
10683: CALL_OW 12
10687: PPUSH
10688: LD_INT 14
10690: PPUSH
10691: LD_INT 1
10693: PPUSH
10694: CALL_OW 55
// end ; end_of_file
10698: END
// export function Action ; var un ; begin
10699: LD_INT 0
10701: PPUSH
10702: PPUSH
// case Query ( QVul1 ) of 1 :
10703: LD_STRING QVul1
10705: PPUSH
10706: CALL_OW 97
10710: PUSH
10711: LD_INT 1
10713: DOUBLE
10714: EQUAL
10715: IFTRUE 10719
10717: GO 10730
10719: POP
// Difficulty := 1 ; 2 :
10720: LD_ADDR_OWVAR 67
10724: PUSH
10725: LD_INT 1
10727: ST_TO_ADDR
10728: GO 10769
10730: LD_INT 2
10732: DOUBLE
10733: EQUAL
10734: IFTRUE 10738
10736: GO 10749
10738: POP
// Difficulty := 2 ; 3 :
10739: LD_ADDR_OWVAR 67
10743: PUSH
10744: LD_INT 2
10746: ST_TO_ADDR
10747: GO 10769
10749: LD_INT 3
10751: DOUBLE
10752: EQUAL
10753: IFTRUE 10757
10755: GO 10768
10757: POP
// Difficulty := 3 ; end ;
10758: LD_ADDR_OWVAR 67
10762: PUSH
10763: LD_INT 3
10765: ST_TO_ADDR
10766: GO 10769
10768: POP
// case Query ( QVul3 ) of 1 :
10769: LD_STRING QVul3
10771: PPUSH
10772: CALL_OW 97
10776: PUSH
10777: LD_INT 1
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10808
10785: POP
// begin your_side := 1 ;
10786: LD_ADDR_OWVAR 2
10790: PUSH
10791: LD_INT 1
10793: ST_TO_ADDR
// legion_enemy := 1 ;
10794: LD_ADDR_EXP 36
10798: PUSH
10799: LD_INT 1
10801: ST_TO_ADDR
// PrepareAmerican ;
10802: CALL 221 0 0
// end ; 2 :
10806: GO 10871
10808: LD_INT 2
10810: DOUBLE
10811: EQUAL
10812: IFTRUE 10816
10814: GO 10839
10816: POP
// begin your_side := 2 ;
10817: LD_ADDR_OWVAR 2
10821: PUSH
10822: LD_INT 2
10824: ST_TO_ADDR
// legion_enemy := 2 ;
10825: LD_ADDR_EXP 36
10829: PUSH
10830: LD_INT 2
10832: ST_TO_ADDR
// PrepareArabian ;
10833: CALL 17468 0 0
// end ; 3 :
10837: GO 10871
10839: LD_INT 3
10841: DOUBLE
10842: EQUAL
10843: IFTRUE 10847
10845: GO 10870
10847: POP
// begin your_side := 7 ;
10848: LD_ADDR_OWVAR 2
10852: PUSH
10853: LD_INT 7
10855: ST_TO_ADDR
// legion_enemy := 7 ;
10856: LD_ADDR_EXP 36
10860: PUSH
10861: LD_INT 7
10863: ST_TO_ADDR
// PrepareAlliance ;
10864: CALL 14879 0 0
// end ; end ;
10868: GO 10871
10870: POP
// if your_side = 1 then
10871: LD_OWVAR 2
10875: PUSH
10876: LD_INT 1
10878: EQUAL
10879: IFFALSE 11233
// begin case Query ( QVul4 ) of 1 :
10881: LD_STRING QVul4
10883: PPUSH
10884: CALL_OW 97
10888: PUSH
10889: LD_INT 1
10891: DOUBLE
10892: EQUAL
10893: IFTRUE 10897
10895: GO 10900
10897: POP
// ; end ;
10898: GO 10901
10900: POP
// InGameOn ;
10901: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10905: LD_INT 8
10907: PPUSH
10908: LD_INT 5
10910: PPUSH
10911: CALL_OW 86
// uc_side := 4 ;
10915: LD_ADDR_OWVAR 20
10919: PUSH
10920: LD_INT 4
10922: ST_TO_ADDR
// uc_nation := 1 ;
10923: LD_ADDR_OWVAR 21
10927: PUSH
10928: LD_INT 1
10930: ST_TO_ADDR
// hc_importance := 0 ;
10931: LD_ADDR_OWVAR 32
10935: PUSH
10936: LD_INT 0
10938: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10939: LD_INT 1
10941: PPUSH
10942: LD_INT 3
10944: PPUSH
10945: LD_EXP 21
10949: PPUSH
10950: CALL_OW 380
// un := CreateHuman ;
10954: LD_ADDR_VAR 0 2
10958: PUSH
10959: CALL_OW 44
10963: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10964: LD_VAR 0 2
10968: PPUSH
10969: LD_INT 12
10971: PPUSH
10972: LD_INT 9
10974: PPUSH
10975: LD_INT 0
10977: PPUSH
10978: CALL_OW 48
// hc_name := Stuart Carey ;
10982: LD_ADDR_OWVAR 26
10986: PUSH
10987: LD_STRING Stuart Carey
10989: ST_TO_ADDR
// hc_class := 1 ;
10990: LD_ADDR_OWVAR 28
10994: PUSH
10995: LD_INT 1
10997: ST_TO_ADDR
// hc_gallery := vulcano ;
10998: LD_ADDR_OWVAR 33
11002: PUSH
11003: LD_STRING vulcano
11005: ST_TO_ADDR
// hc_face_number := 1 ;
11006: LD_ADDR_OWVAR 34
11010: PUSH
11011: LD_INT 1
11013: ST_TO_ADDR
// us_guy := CreateHuman ;
11014: LD_ADDR_EXP 22
11018: PUSH
11019: CALL_OW 44
11023: ST_TO_ADDR
// hc_gallery :=  ;
11024: LD_ADDR_OWVAR 33
11028: PUSH
11029: LD_STRING 
11031: ST_TO_ADDR
// hc_name :=  ;
11032: LD_ADDR_OWVAR 26
11036: PUSH
11037: LD_STRING 
11039: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11040: LD_VAR 0 2
11044: PPUSH
11045: LD_EXP 19
11049: PPUSH
11050: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11054: LD_EXP 19
11058: PPUSH
11059: LD_VAR 0 2
11063: PPUSH
11064: CALL_OW 119
// Say ( un , VD-un1 ) ;
11068: LD_VAR 0 2
11072: PPUSH
11073: LD_STRING VD-un1
11075: PPUSH
11076: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11080: LD_EXP 19
11084: PPUSH
11085: LD_STRING VDc-1
11087: PPUSH
11088: CALL_OW 88
// Say ( un , VD-un2 ) ;
11092: LD_VAR 0 2
11096: PPUSH
11097: LD_STRING VD-un2
11099: PPUSH
11100: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11104: LD_EXP 19
11108: PPUSH
11109: LD_STRING VDc-2
11111: PPUSH
11112: CALL_OW 88
// Say ( un , VD-un3 ) ;
11116: LD_VAR 0 2
11120: PPUSH
11121: LD_STRING VD-un3
11123: PPUSH
11124: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11128: LD_INT 7
11130: PPUSH
11131: CALL_OW 67
// Say ( un , VD-un4 ) ;
11135: LD_VAR 0 2
11139: PPUSH
11140: LD_STRING VD-un4
11142: PPUSH
11143: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11147: LD_VAR 0 2
11151: PPUSH
11152: LD_INT 2
11154: PPUSH
11155: LD_INT 2
11157: PPUSH
11158: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11162: LD_EXP 19
11166: PPUSH
11167: LD_STRING VDc-3
11169: PPUSH
11170: CALL_OW 88
// InGameOff ;
11174: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11178: LD_STRING CVulc1
11180: PPUSH
11181: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11185: LD_INT 35
11187: PPUSH
11188: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11192: LD_VAR 0 2
11196: PPUSH
11197: CALL_OW 250
11201: PUSH
11202: LD_INT 2
11204: EQUAL
11205: PUSH
11206: LD_VAR 0 2
11210: PPUSH
11211: CALL_OW 251
11215: PUSH
11216: LD_INT 2
11218: EQUAL
11219: AND
11220: IFFALSE 11185
// RemoveUnit ( un ) ;
11222: LD_VAR 0 2
11226: PPUSH
11227: CALL_OW 64
// end else
11231: GO 11525
// if your_side = 2 then
11233: LD_OWVAR 2
11237: PUSH
11238: LD_INT 2
11240: EQUAL
11241: IFFALSE 11413
// begin CenterNowOnUnits ( player_commander ) ;
11243: LD_EXP 10
11247: PPUSH
11248: CALL_OW 87
// InGameOn ;
11252: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11256: LD_EXP 51
11260: PPUSH
11261: LD_STRING VSd-1
11263: PPUSH
11264: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11268: LD_INT 22
11270: PUSH
11271: LD_INT 2
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 26
11290: PUSH
11291: LD_INT 1
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: LIST
11302: PUSH
11303: EMPTY
11304: LIST
11305: PPUSH
11306: CALL_OW 69
11310: PUSH
11311: LD_INT 2
11313: ARRAY
11314: PPUSH
11315: LD_STRING VAd-1
11317: PPUSH
11318: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11322: LD_EXP 51
11326: PPUSH
11327: LD_STRING VSd-2
11329: PPUSH
11330: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11334: LD_INT 22
11336: PUSH
11337: LD_INT 2
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: LD_INT 21
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: PUSH
11354: LD_INT 26
11356: PUSH
11357: LD_INT 1
11359: PUSH
11360: EMPTY
11361: LIST
11362: LIST
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: LIST
11368: PUSH
11369: EMPTY
11370: LIST
11371: PPUSH
11372: CALL_OW 69
11376: PUSH
11377: LD_INT 2
11379: ARRAY
11380: PPUSH
11381: LD_STRING VAd-2
11383: PPUSH
11384: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11388: LD_EXP 51
11392: PPUSH
11393: LD_STRING VSd-3
11395: PPUSH
11396: CALL_OW 88
// InGameOff ;
11400: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11404: LD_STRING CVulc5
11406: PPUSH
11407: CALL_OW 337
// end else
11411: GO 11525
// if your_side = 7 then
11413: LD_OWVAR 2
11417: PUSH
11418: LD_INT 7
11420: EQUAL
11421: IFFALSE 11525
// begin CenterNowOnUnits ( al_commander ) ;
11423: LD_EXP 37
11427: PPUSH
11428: CALL_OW 87
// InGameOn ;
11432: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11436: LD_EXP 37
11440: PPUSH
11441: LD_STRING VPd-1
11443: PPUSH
11444: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11448: LD_INT 22
11450: PUSH
11451: LD_INT 7
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: PUSH
11458: LD_INT 21
11460: PUSH
11461: LD_INT 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 26
11470: PUSH
11471: LD_INT 1
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: PPUSH
11486: CALL_OW 69
11490: PUSH
11491: LD_INT 2
11493: ARRAY
11494: PPUSH
11495: LD_STRING VPpd-1
11497: PPUSH
11498: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11502: LD_EXP 37
11506: PPUSH
11507: LD_STRING VPd-2
11509: PPUSH
11510: CALL_OW 88
// InGameOff ;
11514: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11518: LD_STRING CVulc7
11520: PPUSH
11521: CALL_OW 337
// end ; end ;
11525: LD_VAR 0 1
11529: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11530: LD_INT 22
11532: PUSH
11533: LD_INT 2
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PUSH
11540: LD_INT 30
11542: PUSH
11543: LD_INT 3
11545: PUSH
11546: EMPTY
11547: LIST
11548: LIST
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PPUSH
11554: CALL_OW 69
11558: IFFALSE 11602
11560: GO 11562
11562: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11563: LD_STRING CVulc6
11565: PPUSH
11566: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11570: LD_INT 52500
11572: PUSH
11573: LD_INT 47250
11575: PUSH
11576: LD_INT 42000
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: LIST
11583: PUSH
11584: LD_OWVAR 67
11588: ARRAY
11589: PPUSH
11590: CALL_OW 67
// ru_can_attack := true ;
11594: LD_ADDR_EXP 3
11598: PUSH
11599: LD_INT 1
11601: ST_TO_ADDR
// end ;
11602: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11603: LD_INT 50
11605: PPUSH
11606: CALL_OW 255
11610: PUSH
11611: LD_INT 1
11613: EQUAL
11614: PUSH
11615: LD_INT 22
11617: PUSH
11618: LD_INT 1
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: LD_INT 2
11627: PUSH
11628: LD_INT 30
11630: PUSH
11631: LD_INT 3
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_INT 30
11640: PUSH
11641: LD_INT 1
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: PUSH
11648: EMPTY
11649: LIST
11650: LIST
11651: LIST
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: PPUSH
11657: CALL_OW 69
11661: OR
11662: IFFALSE 11839
11664: GO 11666
11666: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11667: LD_STRING CVulc2
11669: PPUSH
11670: CALL_OW 337
// DialogueOn ;
11674: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11678: LD_INT 10
11680: PPUSH
11681: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11685: LD_INT 22
11687: PUSH
11688: LD_INT 1
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 2
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: EMPTY
11706: LIST
11707: LIST
11708: PPUSH
11709: CALL_OW 69
11713: PUSH
11714: LD_EXP 19
11718: DIFF
11719: PUSH
11720: LD_INT 1
11722: ARRAY
11723: PPUSH
11724: LD_STRING VDb-1
11726: PPUSH
11727: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11731: LD_INT 10
11733: PPUSH
11734: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11738: LD_INT 22
11740: PUSH
11741: LD_INT 1
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: PUSH
11748: LD_INT 25
11750: PUSH
11751: LD_INT 4
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PPUSH
11762: CALL_OW 69
11766: PUSH
11767: LD_EXP 19
11771: DIFF
11772: PUSH
11773: LD_INT 1
11775: ARRAY
11776: PPUSH
11777: LD_STRING VDb-2
11779: PPUSH
11780: CALL_OW 88
// DWait ( 0 0$01 ) ;
11784: LD_INT 35
11786: PPUSH
11787: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11791: LD_EXP 19
11795: PPUSH
11796: LD_STRING VDb-com1
11798: PPUSH
11799: CALL_OW 88
// DialogueOff ;
11803: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11807: LD_INT 44100
11809: PUSH
11810: LD_INT 36750
11812: PUSH
11813: LD_INT 31500
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: LIST
11820: PUSH
11821: LD_OWVAR 67
11825: ARRAY
11826: PPUSH
11827: CALL_OW 67
// ru_can_attack := true ;
11831: LD_ADDR_EXP 3
11835: PUSH
11836: LD_INT 1
11838: ST_TO_ADDR
// end ;
11839: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11840: LD_INT 22
11842: PUSH
11843: LD_INT 7
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 30
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 69
11868: IFFALSE 11905
11870: GO 11872
11872: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11873: LD_INT 42000
11875: PUSH
11876: LD_INT 34650
11878: PUSH
11879: LD_INT 29400
11881: PUSH
11882: EMPTY
11883: LIST
11884: LIST
11885: LIST
11886: PUSH
11887: LD_OWVAR 67
11891: ARRAY
11892: PPUSH
11893: CALL_OW 67
// ru_can_attack := true ;
11897: LD_ADDR_EXP 3
11901: PUSH
11902: LD_INT 1
11904: ST_TO_ADDR
// end ;
11905: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11906: LD_INT 58
11908: PPUSH
11909: CALL_OW 255
11913: PUSH
11914: LD_INT 1
11916: EQUAL
11917: IFFALSE 12049
11919: GO 11921
11921: DISABLE
// begin DialogueOn ;
11922: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11926: LD_INT 22
11928: PUSH
11929: LD_INT 1
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 25
11938: PUSH
11939: LD_INT 2
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: EMPTY
11947: LIST
11948: LIST
11949: PPUSH
11950: CALL_OW 69
11954: PUSH
11955: LD_INT 1
11957: ARRAY
11958: PPUSH
11959: LD_STRING VDe-1
11961: PPUSH
11962: CALL_OW 88
// case Query ( SibNote ) of 1 :
11966: LD_STRING SibNote
11968: PPUSH
11969: CALL_OW 97
11973: PUSH
11974: LD_INT 1
11976: DOUBLE
11977: EQUAL
11978: IFTRUE 11982
11980: GO 11985
11982: POP
// ; end ;
11983: GO 11986
11985: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11986: LD_INT 22
11988: PUSH
11989: LD_INT 1
11991: PUSH
11992: EMPTY
11993: LIST
11994: LIST
11995: PUSH
11996: LD_INT 25
11998: PUSH
11999: LD_INT 2
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PPUSH
12010: CALL_OW 69
12014: PUSH
12015: LD_INT 1
12017: ARRAY
12018: PPUSH
12019: LD_STRING VDe-2
12021: PPUSH
12022: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12026: LD_EXP 19
12030: PPUSH
12031: LD_STRING VDc-4
12033: PPUSH
12034: CALL_OW 88
// DialogueOff ;
12038: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12042: LD_STRING CVulc3
12044: PPUSH
12045: CALL_OW 337
// end ;
12049: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12050: LD_OWVAR 2
12054: PUSH
12055: LD_INT 1
12057: EQUAL
12058: PUSH
12059: LD_INT 22
12061: PUSH
12062: LD_INT 1
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: PUSH
12069: LD_INT 30
12071: PUSH
12072: LD_INT 3
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PPUSH
12083: CALL_OW 69
12087: PUSH
12088: LD_INT 0
12090: GREATER
12091: AND
12092: IFFALSE 12526
12094: GO 12096
12096: DISABLE
12097: LD_INT 0
12099: PPUSH
12100: PPUSH
12101: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12102: LD_INT 245
12104: PPUSH
12105: LD_INT 1295
12107: PPUSH
12108: CALL_OW 12
12112: PPUSH
12113: CALL_OW 67
// DialogueOn ;
12117: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12121: LD_EXP 22
12125: PPUSH
12126: LD_STRING VDG-1
12128: PPUSH
12129: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12133: LD_EXP 19
12137: PPUSH
12138: LD_STRING VDc-5
12140: PPUSH
12141: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12145: LD_EXP 22
12149: PPUSH
12150: LD_STRING VDG-2
12152: PPUSH
12153: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12157: LD_EXP 19
12161: PPUSH
12162: LD_STRING VDc-6
12164: PPUSH
12165: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12169: LD_EXP 22
12173: PPUSH
12174: LD_STRING VDG-3
12176: PPUSH
12177: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12181: LD_EXP 19
12185: PPUSH
12186: LD_STRING VDc-7
12188: PPUSH
12189: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12193: LD_EXP 22
12197: PPUSH
12198: LD_STRING VDG-4
12200: PPUSH
12201: CALL_OW 94
// DialogueOff ;
12205: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12209: LD_STRING CVulc4
12211: PPUSH
12212: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12216: LD_INT 18900
12218: PUSH
12219: LD_INT 21000
12221: PUSH
12222: LD_INT 23100
12224: PUSH
12225: EMPTY
12226: LIST
12227: LIST
12228: LIST
12229: PUSH
12230: LD_OWVAR 67
12234: ARRAY
12235: PPUSH
12236: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12240: LD_ADDR_VAR 0 1
12244: PUSH
12245: DOUBLE
12246: LD_INT 1
12248: DEC
12249: ST_TO_ADDR
12250: LD_INT 4
12252: PUSH
12253: LD_INT 5
12255: PUSH
12256: LD_INT 6
12258: PUSH
12259: EMPTY
12260: LIST
12261: LIST
12262: LIST
12263: PUSH
12264: LD_OWVAR 67
12268: ARRAY
12269: PUSH
12270: FOR_TO
12271: IFFALSE 12515
// begin uc_side := 1 ;
12273: LD_ADDR_OWVAR 20
12277: PUSH
12278: LD_INT 1
12280: ST_TO_ADDR
// uc_nation := 1 ;
12281: LD_ADDR_OWVAR 21
12285: PUSH
12286: LD_INT 1
12288: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12289: LD_INT 0
12291: PPUSH
12292: LD_INT 1
12294: PPUSH
12295: LD_INT 4
12297: PPUSH
12298: CALL_OW 12
12302: PPUSH
12303: LD_EXP 21
12307: PPUSH
12308: CALL_OW 380
// un := CreateHuman ;
12312: LD_ADDR_VAR 0 2
12316: PUSH
12317: CALL_OW 44
12321: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12322: LD_VAR 0 2
12326: PPUSH
12327: LD_INT 2
12329: PPUSH
12330: CALL_OW 233
// if GetClass ( un ) = 3 then
12334: LD_VAR 0 2
12338: PPUSH
12339: CALL_OW 257
12343: PUSH
12344: LD_INT 3
12346: EQUAL
12347: IFFALSE 12498
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12349: LD_ADDR_OWVAR 37
12353: PUSH
12354: LD_INT 2
12356: PUSH
12357: LD_INT 3
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_VAR 0 1
12368: PUSH
12369: LD_INT 2
12371: MOD
12372: ARRAY
12373: ST_TO_ADDR
// vc_engine := engine_combustion ;
12374: LD_ADDR_OWVAR 39
12378: PUSH
12379: LD_INT 1
12381: ST_TO_ADDR
// vc_control := control_manual ;
12382: LD_ADDR_OWVAR 38
12386: PUSH
12387: LD_INT 1
12389: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12390: LD_ADDR_OWVAR 40
12394: PUSH
12395: LD_INT 9
12397: PUSH
12398: LD_INT 9
12400: PUSH
12401: LD_INT 5
12403: PUSH
12404: LD_INT 11
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 1
12415: PPUSH
12416: LD_INT 4
12418: PPUSH
12419: CALL_OW 12
12423: ARRAY
12424: ST_TO_ADDR
// veh := CreateVehicle ;
12425: LD_ADDR_VAR 0 3
12429: PUSH
12430: CALL_OW 45
12434: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12435: LD_VAR 0 3
12439: PPUSH
12440: LD_INT 2
12442: PPUSH
12443: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12447: LD_VAR 0 3
12451: PPUSH
12452: LD_INT 77
12454: PPUSH
12455: LD_INT 88
12457: PPUSH
12458: CALL_OW 12
12462: PPUSH
12463: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12467: LD_VAR 0 3
12471: PPUSH
12472: LD_INT 1
12474: PPUSH
12475: LD_INT 0
12477: PPUSH
12478: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12482: LD_VAR 0 2
12486: PPUSH
12487: LD_VAR 0 3
12491: PPUSH
12492: CALL_OW 52
// end else
12496: GO 12513
// PlaceUnitArea ( un , start_north , false ) ;
12498: LD_VAR 0 2
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 49
// end ;
12513: GO 12270
12515: POP
12516: POP
// CenterNowOnUnits ( un ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: CALL_OW 87
// end ;
12526: PPOPN 3
12528: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12529: LD_INT 21
12531: PPUSH
12532: LD_INT 22
12534: PUSH
12535: LD_OWVAR 2
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PPUSH
12544: CALL_OW 70
12548: IFFALSE 12770
12550: GO 12552
12552: DISABLE
12553: LD_INT 0
12555: PPUSH
12556: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12557: LD_ADDR_VAR 0 2
12561: PUSH
12562: LD_INT 22
12564: PUSH
12565: LD_OWVAR 2
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PUSH
12574: LD_INT 2
12576: PUSH
12577: LD_INT 25
12579: PUSH
12580: LD_INT 1
12582: PUSH
12583: EMPTY
12584: LIST
12585: LIST
12586: PUSH
12587: LD_INT 25
12589: PUSH
12590: LD_INT 2
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PUSH
12597: LD_INT 25
12599: PUSH
12600: LD_INT 3
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: PUSH
12607: LD_INT 25
12609: PUSH
12610: LD_INT 4
12612: PUSH
12613: EMPTY
12614: LIST
12615: LIST
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: PPUSH
12628: CALL_OW 69
12632: PUSH
12633: LD_EXP 10
12637: DIFF
12638: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12639: LD_ADDR_VAR 0 1
12643: PUSH
12644: LD_VAR 0 2
12648: PPUSH
12649: LD_INT 112
12651: PPUSH
12652: LD_INT 67
12654: PPUSH
12655: CALL_OW 73
12659: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12660: LD_VAR 0 1
12664: PPUSH
12665: CALL_OW 255
12669: PUSH
12670: LD_INT 7
12672: EQUAL
12673: IFFALSE 12687
// Say ( un , VD-find-al ) ;
12675: LD_VAR 0 1
12679: PPUSH
12680: LD_STRING VD-find-al
12682: PPUSH
12683: CALL_OW 88
// if GetSide ( un ) = 2 then
12687: LD_VAR 0 1
12691: PPUSH
12692: CALL_OW 255
12696: PUSH
12697: LD_INT 2
12699: EQUAL
12700: IFFALSE 12714
// Say ( un , VD-find-ar ) ;
12702: LD_VAR 0 1
12706: PPUSH
12707: LD_STRING VD-find-ar
12709: PPUSH
12710: CALL_OW 88
// if GetSide ( un ) = 1 then
12714: LD_VAR 0 1
12718: PPUSH
12719: CALL_OW 255
12723: PUSH
12724: LD_INT 1
12726: EQUAL
12727: IFFALSE 12753
// begin Say ( un , VD-find-us ) ;
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_STRING VD-find-us
12736: PPUSH
12737: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12741: LD_VAR 0 1
12745: PPUSH
12746: LD_STRING VD-find-us2
12748: PPUSH
12749: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12753: LD_INT 10
12755: PPUSH
12756: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12760: LD_INT 112
12762: PPUSH
12763: LD_INT 67
12765: PPUSH
12766: CALL_OW 86
// end ;
12770: PPOPN 2
12772: END
// every 0 0$01 trigger player_artifact_ready do
12773: LD_EXP 7
12777: IFFALSE 13091
12779: GO 12781
12781: DISABLE
// begin if your_side = 1 then
12782: LD_OWVAR 2
12786: PUSH
12787: LD_INT 1
12789: EQUAL
12790: IFFALSE 12908
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12792: LD_INT 22
12794: PUSH
12795: LD_INT 1
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PUSH
12802: LD_INT 25
12804: PUSH
12805: LD_INT 4
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PPUSH
12816: CALL_OW 69
12820: PUSH
12821: LD_EXP 19
12825: DIFF
12826: PUSH
12827: LD_INT 1
12829: ARRAY
12830: PPUSH
12831: LD_STRING VD-us-sci-art-1
12833: PPUSH
12834: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12838: LD_EXP 19
12842: PPUSH
12843: LD_STRING VDc-art1
12845: PPUSH
12846: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12850: LD_INT 22
12852: PUSH
12853: LD_INT 1
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PUSH
12860: LD_INT 25
12862: PUSH
12863: LD_INT 4
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PPUSH
12874: CALL_OW 69
12878: PUSH
12879: LD_EXP 19
12883: DIFF
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: PPUSH
12889: LD_STRING VD-us-sci-art-2
12891: PPUSH
12892: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12896: LD_EXP 19
12900: PPUSH
12901: LD_STRING VDc-art2
12903: PPUSH
12904: CALL_OW 88
// end ; if your_side = 2 then
12908: LD_OWVAR 2
12912: PUSH
12913: LD_INT 2
12915: EQUAL
12916: IFFALSE 12958
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12918: LD_INT 22
12920: PUSH
12921: LD_INT 2
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 25
12930: PUSH
12931: LD_INT 4
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PPUSH
12942: CALL_OW 69
12946: PUSH
12947: LD_INT 1
12949: ARRAY
12950: PPUSH
12951: LD_STRING VD-ar-sci-art-1
12953: PPUSH
12954: CALL_OW 88
// end ; if your_side = 7 then
12958: LD_OWVAR 2
12962: PUSH
12963: LD_INT 7
12965: EQUAL
12966: IFFALSE 13091
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12968: LD_INT 22
12970: PUSH
12971: LD_INT 7
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: LD_INT 25
12980: PUSH
12981: LD_INT 4
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PPUSH
12992: CALL_OW 69
12996: PUSH
12997: LD_EXP 37
13001: DIFF
13002: PUSH
13003: LD_INT 1
13005: ARRAY
13006: PPUSH
13007: LD_STRING VD-al-sci-art-1
13009: PPUSH
13010: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13014: LD_EXP 37
13018: PPUSH
13019: LD_STRING VPd-art-1
13021: PPUSH
13022: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13026: LD_INT 22
13028: PUSH
13029: LD_INT 7
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 25
13038: PUSH
13039: LD_INT 4
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PPUSH
13050: CALL_OW 69
13054: PUSH
13055: LD_EXP 37
13059: DIFF
13060: PUSH
13061: LD_INT 1
13063: ARRAY
13064: PPUSH
13065: LD_STRING VD-al-sci-art-2
13067: PPUSH
13068: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13072: LD_EXP 37
13076: PPUSH
13077: LD_STRING VPd-art-2
13079: PPUSH
13080: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13084: LD_STRING CVulc7out
13086: PPUSH
13087: CALL_OW 337
// end ; end ;
13091: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13092: LD_INT 8
13094: PPUSH
13095: LD_INT 22
13097: PUSH
13098: LD_OWVAR 2
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: PPUSH
13107: CALL_OW 69
13111: PPUSH
13112: LD_INT 8
13114: PPUSH
13115: CALL 2145 0 2
13119: PPUSH
13120: CALL_OW 292
13124: IFFALSE 13215
13126: GO 13128
13128: DISABLE
// begin if your_side = 1 then
13129: LD_OWVAR 2
13133: PUSH
13134: LD_INT 1
13136: EQUAL
13137: IFFALSE 13171
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13139: LD_INT 22
13141: PUSH
13142: LD_INT 1
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: PPUSH
13149: CALL_OW 69
13153: PUSH
13154: LD_EXP 19
13158: DIFF
13159: PUSH
13160: LD_INT 1
13162: ARRAY
13163: PPUSH
13164: LD_STRING VD-legion-us
13166: PPUSH
13167: CALL_OW 88
// if your_side = 2 then
13171: LD_OWVAR 2
13175: PUSH
13176: LD_INT 2
13178: EQUAL
13179: IFFALSE 13193
// Say ( ar_commander , VD-legion-ar ) ;
13181: LD_EXP 51
13185: PPUSH
13186: LD_STRING VD-legion-ar
13188: PPUSH
13189: CALL_OW 88
// if your_side = 7 then
13193: LD_OWVAR 2
13197: PUSH
13198: LD_INT 7
13200: EQUAL
13201: IFFALSE 13215
// Say ( al_commander , VD-legion-al ) ;
13203: LD_EXP 37
13207: PPUSH
13208: LD_STRING VD-legion-al
13210: PPUSH
13211: CALL_OW 88
// end ;
13215: END
// every 0 0$01 trigger mine_vulc do
13216: LD_EXP 12
13220: IFFALSE 13237
13222: GO 13224
13224: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13225: LD_EXP 10
13229: PPUSH
13230: LD_STRING VD-vulc-mines
13232: PPUSH
13233: CALL_OW 88
// end ;
13237: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13238: LD_OWVAR 67
13242: PUSH
13243: LD_INT 1
13245: GREATER
13246: IFFALSE 13365
13248: GO 13250
13250: DISABLE
13251: LD_INT 0
13253: PPUSH
13254: PPUSH
13255: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13256: LD_ADDR_VAR 0 1
13260: PUSH
13261: LD_INT 123
13263: PUSH
13264: LD_INT 95
13266: PUSH
13267: LD_INT 119
13269: PUSH
13270: LD_INT 89
13272: PUSH
13273: LD_INT 115
13275: PUSH
13276: LD_INT 81
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: LIST
13283: LIST
13284: LIST
13285: LIST
13286: ST_TO_ADDR
// p := 1 ;
13287: LD_ADDR_VAR 0 2
13291: PUSH
13292: LD_INT 1
13294: ST_TO_ADDR
// for i = 1 to 3 do
13295: LD_ADDR_VAR 0 3
13299: PUSH
13300: DOUBLE
13301: LD_INT 1
13303: DEC
13304: ST_TO_ADDR
13305: LD_INT 3
13307: PUSH
13308: FOR_TO
13309: IFFALSE 13363
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13311: LD_VAR 0 1
13315: PUSH
13316: LD_VAR 0 2
13320: ARRAY
13321: PPUSH
13322: LD_VAR 0 1
13326: PUSH
13327: LD_VAR 0 2
13331: PUSH
13332: LD_INT 1
13334: PLUS
13335: ARRAY
13336: PPUSH
13337: LD_INT 8
13339: PPUSH
13340: LD_INT 0
13342: PPUSH
13343: CALL_OW 454
// p := p + 2 ;
13347: LD_ADDR_VAR 0 2
13351: PUSH
13352: LD_VAR 0 2
13356: PUSH
13357: LD_INT 2
13359: PLUS
13360: ST_TO_ADDR
// end ;
13361: GO 13308
13363: POP
13364: POP
// end ;
13365: PPOPN 3
13367: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13368: LD_OWVAR 67
13372: PUSH
13373: LD_INT 1
13375: GREATER
13376: PUSH
13377: LD_INT 22
13379: PPUSH
13380: LD_INT 22
13382: PUSH
13383: LD_OWVAR 2
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PPUSH
13392: CALL_OW 70
13396: AND
13397: IFFALSE 13601
13399: GO 13401
13401: DISABLE
13402: LD_INT 0
13404: PPUSH
13405: PPUSH
13406: PPUSH
// begin enable ;
13407: ENABLE
// p := 1 ;
13408: LD_ADDR_VAR 0 1
13412: PUSH
13413: LD_INT 1
13415: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_INT 123
13423: PUSH
13424: LD_INT 95
13426: PUSH
13427: LD_INT 119
13429: PUSH
13430: LD_INT 89
13432: PUSH
13433: LD_INT 115
13435: PUSH
13436: LD_INT 81
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: ST_TO_ADDR
// for i = 1 to 3 do
13447: LD_ADDR_VAR 0 2
13451: PUSH
13452: DOUBLE
13453: LD_INT 1
13455: DEC
13456: ST_TO_ADDR
13457: LD_INT 3
13459: PUSH
13460: FOR_TO
13461: IFFALSE 13599
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13463: LD_VAR 0 3
13467: PUSH
13468: LD_VAR 0 1
13472: ARRAY
13473: PPUSH
13474: LD_VAR 0 3
13478: PUSH
13479: LD_VAR 0 1
13483: PUSH
13484: LD_INT 1
13486: PLUS
13487: ARRAY
13488: PPUSH
13489: CALL_OW 428
13493: PUSH
13494: LD_INT 0
13496: GREATER
13497: IFFALSE 13583
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13499: LD_VAR 0 3
13503: PUSH
13504: LD_VAR 0 1
13508: ARRAY
13509: PPUSH
13510: LD_VAR 0 3
13514: PUSH
13515: LD_VAR 0 1
13519: PUSH
13520: LD_INT 1
13522: PLUS
13523: ARRAY
13524: PPUSH
13525: CALL_OW 428
13529: PPUSH
13530: CALL_OW 255
13534: PUSH
13535: LD_OWVAR 2
13539: EQUAL
13540: IFFALSE 13583
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13542: LD_VAR 0 3
13546: PUSH
13547: LD_VAR 0 1
13551: ARRAY
13552: PPUSH
13553: LD_VAR 0 3
13557: PUSH
13558: LD_VAR 0 1
13562: PUSH
13563: LD_INT 1
13565: PLUS
13566: ARRAY
13567: PPUSH
13568: LD_INT 8
13570: PPUSH
13571: CALL_OW 456
// mine_vulc := true ;
13575: LD_ADDR_EXP 12
13579: PUSH
13580: LD_INT 1
13582: ST_TO_ADDR
// end ; p := p + 2 ;
13583: LD_ADDR_VAR 0 1
13587: PUSH
13588: LD_VAR 0 1
13592: PUSH
13593: LD_INT 2
13595: PLUS
13596: ST_TO_ADDR
// end ;
13597: GO 13460
13599: POP
13600: POP
// end ;
13601: PPOPN 3
13603: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13604: LD_INT 22
13606: PUSH
13607: LD_INT 3
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PUSH
13619: LD_INT 0
13621: EQUAL
13622: PUSH
13623: LD_OWVAR 2
13627: PUSH
13628: LD_INT 2
13630: NONEQUAL
13631: AND
13632: IFFALSE 13641
13634: GO 13636
13636: DISABLE
// Win ;
13637: CALL 13698 0 0
13641: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13642: LD_INT 2
13644: PUSH
13645: LD_INT 22
13647: PUSH
13648: LD_INT 8
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PUSH
13655: LD_INT 22
13657: PUSH
13658: LD_INT 3
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: PPUSH
13670: CALL_OW 69
13674: PUSH
13675: LD_INT 0
13677: EQUAL
13678: PUSH
13679: LD_OWVAR 2
13683: PUSH
13684: LD_INT 2
13686: EQUAL
13687: AND
13688: IFFALSE 13697
13690: GO 13692
13692: DISABLE
// Win ;
13693: CALL 13698 0 0
13697: END
// function Win ; var points ; begin
13698: LD_INT 0
13700: PPUSH
13701: PPUSH
// case Query ( VulcWin ) of 1 :
13702: LD_STRING VulcWin
13704: PPUSH
13705: CALL_OW 97
13709: PUSH
13710: LD_INT 1
13712: DOUBLE
13713: EQUAL
13714: IFTRUE 13718
13716: GO 13721
13718: POP
// ; end ;
13719: GO 13722
13721: POP
// if medal_enabled then
13722: LD_EXP 13
13726: IFFALSE 13740
// AddMedal ( vulc_1 , 1 ) else
13728: LD_STRING vulc_1
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 101
13738: GO 13751
// AddMedal ( vulc_1 , - 1 ) ;
13740: LD_STRING vulc_1
13742: PPUSH
13743: LD_INT 1
13745: NEG
13746: PPUSH
13747: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13751: LD_INT 22
13753: PUSH
13754: LD_INT 8
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PPUSH
13761: CALL_OW 69
13765: PUSH
13766: LD_INT 0
13768: EQUAL
13769: IFFALSE 13783
// AddMedal ( vulc_2 , 1 ) else
13771: LD_STRING vulc_2
13773: PPUSH
13774: LD_INT 1
13776: PPUSH
13777: CALL_OW 101
13781: GO 13794
// AddMedal ( vulc_2 , - 1 ) ;
13783: LD_STRING vulc_2
13785: PPUSH
13786: LD_INT 1
13788: NEG
13789: PPUSH
13790: CALL_OW 101
// points := CalculateCommanderPoints ;
13794: LD_ADDR_VAR 0 2
13798: PUSH
13799: CALL 2266 0 0
13803: ST_TO_ADDR
// if points >= 2000 then
13804: LD_VAR 0 2
13808: PUSH
13809: LD_INT 2000
13811: GREATEREQUAL
13812: IFFALSE 13826
// AddMedal ( vulc_3 , 2 ) else
13814: LD_STRING vulc_3
13816: PPUSH
13817: LD_INT 2
13819: PPUSH
13820: CALL_OW 101
13824: GO 13859
// if points >= 0 then
13826: LD_VAR 0 2
13830: PUSH
13831: LD_INT 0
13833: GREATEREQUAL
13834: IFFALSE 13848
// AddMedal ( vulc_3 , 1 ) else
13836: LD_STRING vulc_3
13838: PPUSH
13839: LD_INT 1
13841: PPUSH
13842: CALL_OW 101
13846: GO 13859
// AddMedal ( vulc_3 , - 1 ) ;
13848: LD_STRING vulc_3
13850: PPUSH
13851: LD_INT 1
13853: NEG
13854: PPUSH
13855: CALL_OW 101
// GiveMedals ( MAIN ) ;
13859: LD_STRING MAIN
13861: PPUSH
13862: CALL_OW 102
// YouWin ;
13866: CALL_OW 103
// end ; end_of_file
13870: LD_VAR 0 1
13874: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13875: LD_INT 13
13877: PPUSH
13878: LD_INT 21
13880: PUSH
13881: LD_INT 1
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 70
13892: PUSH
13893: LD_INT 0
13895: GREATER
13896: IFFALSE 13963
13898: GO 13900
13900: DISABLE
13901: LD_INT 0
13903: PPUSH
13904: PPUSH
// begin enable ;
13905: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13906: LD_ADDR_VAR 0 1
13910: PUSH
13911: LD_INT 13
13913: PPUSH
13914: LD_INT 21
13916: PUSH
13917: LD_INT 1
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PPUSH
13924: CALL_OW 70
13928: PUSH
13929: FOR_IN
13930: IFFALSE 13961
// if GetLives ( i ) > 4 then
13932: LD_VAR 0 1
13936: PPUSH
13937: CALL_OW 256
13941: PUSH
13942: LD_INT 4
13944: GREATER
13945: IFFALSE 13959
// SetLives ( i , 4 ) ;
13947: LD_VAR 0 1
13951: PPUSH
13952: LD_INT 4
13954: PPUSH
13955: CALL_OW 234
13959: GO 13929
13961: POP
13962: POP
// end ;
13963: PPOPN 2
13965: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13966: LD_VAR 0 1
13970: PPUSH
13971: CALL_OW 255
13975: PUSH
13976: LD_OWVAR 2
13980: EQUAL
13981: IFFALSE 13991
// player_res_art := true ;
13983: LD_ADDR_EXP 6
13987: PUSH
13988: LD_INT 1
13990: ST_TO_ADDR
// end ;
13991: PPOPN 1
13993: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13994: LD_INT 22
13996: PUSH
13997: LD_OWVAR 2
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: LD_INT 2
14008: PUSH
14009: LD_INT 30
14011: PUSH
14012: LD_INT 8
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 30
14021: PUSH
14022: LD_INT 11
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: LIST
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PPUSH
14038: CALL_OW 69
14042: PUSH
14043: LD_EXP 6
14047: AND
14048: IFFALSE 14392
14050: GO 14052
14052: DISABLE
14053: LD_INT 0
14055: PPUSH
14056: PPUSH
14057: PPUSH
// begin enable ;
14058: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14059: LD_ADDR_VAR 0 1
14063: PUSH
14064: LD_INT 1
14066: PPUSH
14067: CALL_OW 469
14071: PUSH
14072: LD_INT 1
14074: ARRAY
14075: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14076: LD_ADDR_VAR 0 2
14080: PUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 469
14088: PUSH
14089: LD_INT 2
14091: ARRAY
14092: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14093: LD_ADDR_VAR 0 3
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_OWVAR 2
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: PUSH
14110: LD_INT 2
14112: PUSH
14113: LD_INT 30
14115: PUSH
14116: LD_INT 8
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: PUSH
14123: LD_INT 30
14125: PUSH
14126: LD_INT 11
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: LIST
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: PPUSH
14142: CALL_OW 69
14146: PPUSH
14147: LD_VAR 0 1
14151: PPUSH
14152: LD_VAR 0 2
14156: PPUSH
14157: CALL_OW 73
14161: ST_TO_ADDR
// if player_artifact_ready = false then
14162: LD_EXP 7
14166: PUSH
14167: LD_INT 0
14169: EQUAL
14170: IFFALSE 14276
// if GetDistUnitXY ( lab , x , y ) < 6 then
14172: LD_VAR 0 3
14176: PPUSH
14177: LD_VAR 0 1
14181: PPUSH
14182: LD_VAR 0 2
14186: PPUSH
14187: CALL_OW 297
14191: PUSH
14192: LD_INT 6
14194: LESS
14195: IFFALSE 14256
// begin if BuildingStatus ( lab ) = bs_idle then
14197: LD_VAR 0 3
14201: PPUSH
14202: CALL_OW 461
14206: PUSH
14207: LD_INT 2
14209: EQUAL
14210: IFFALSE 14234
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14212: LD_OWVAR 2
14216: PPUSH
14217: LD_INT 1
14219: PPUSH
14220: LD_INT 2
14222: PPUSH
14223: LD_VAR 0 3
14227: PPUSH
14228: CALL_OW 468
14232: GO 14254
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14234: LD_OWVAR 2
14238: PPUSH
14239: LD_INT 1
14241: PPUSH
14242: LD_INT 1
14244: PPUSH
14245: LD_VAR 0 3
14249: PPUSH
14250: CALL_OW 468
// end else
14254: GO 14276
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14256: LD_OWVAR 2
14260: PPUSH
14261: LD_INT 1
14263: PPUSH
14264: LD_INT 1
14266: PPUSH
14267: LD_VAR 0 3
14271: PPUSH
14272: CALL_OW 468
// if player_artifact_ready then
14276: LD_EXP 7
14280: IFFALSE 14392
// if GetDistUnitXY ( lab , x , y ) < 6 then
14282: LD_VAR 0 3
14286: PPUSH
14287: LD_VAR 0 1
14291: PPUSH
14292: LD_VAR 0 2
14296: PPUSH
14297: CALL_OW 297
14301: PUSH
14302: LD_INT 6
14304: LESS
14305: IFFALSE 14370
// begin if BuildingStatus ( lab ) = bs_idle then
14307: LD_VAR 0 3
14311: PPUSH
14312: CALL_OW 461
14316: PUSH
14317: LD_INT 2
14319: EQUAL
14320: IFFALSE 14346
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14322: LD_OWVAR 2
14326: PPUSH
14327: LD_EXP 8
14331: PPUSH
14332: LD_INT 4
14334: PPUSH
14335: LD_VAR 0 3
14339: PPUSH
14340: CALL_OW 468
14344: GO 14368
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14346: LD_OWVAR 2
14350: PPUSH
14351: LD_EXP 8
14355: PPUSH
14356: LD_INT 1
14358: PPUSH
14359: LD_VAR 0 3
14363: PPUSH
14364: CALL_OW 468
// end else
14368: GO 14392
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14370: LD_OWVAR 2
14374: PPUSH
14375: LD_EXP 8
14379: PPUSH
14380: LD_INT 1
14382: PPUSH
14383: LD_VAR 0 3
14387: PPUSH
14388: CALL_OW 468
// end ;
14392: PPOPN 3
14394: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14395: LD_INT 0
14397: PPUSH
14398: PPUSH
14399: PPUSH
14400: PPUSH
14401: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14402: LD_ADDR_VAR 0 5
14406: PUSH
14407: LD_INT 1
14409: PPUSH
14410: CALL_OW 469
14414: PUSH
14415: LD_INT 1
14417: ARRAY
14418: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14419: LD_ADDR_VAR 0 6
14423: PUSH
14424: LD_INT 1
14426: PPUSH
14427: CALL_OW 469
14431: PUSH
14432: LD_INT 2
14434: ARRAY
14435: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14436: LD_ADDR_VAR 0 8
14440: PUSH
14441: LD_INT 22
14443: PUSH
14444: LD_OWVAR 2
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 2
14455: PUSH
14456: LD_INT 30
14458: PUSH
14459: LD_INT 8
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 30
14468: PUSH
14469: LD_INT 11
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: PPUSH
14485: CALL_OW 69
14489: PPUSH
14490: LD_VAR 0 5
14494: PPUSH
14495: LD_VAR 0 6
14499: PPUSH
14500: CALL_OW 73
14504: ST_TO_ADDR
// if icon = art_exp_left then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 1
14512: EQUAL
14513: IFFALSE 14552
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14515: LD_VAR 0 8
14519: PPUSH
14520: LD_EXP 9
14524: PPUSH
14525: LD_INT 1
14527: PPUSH
14528: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14532: LD_OWVAR 2
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 0
14542: PPUSH
14543: LD_VAR 0 8
14547: PPUSH
14548: CALL_OW 468
// end ; if icon = art_icon then
14552: LD_VAR 0 2
14556: PUSH
14557: LD_EXP 8
14561: EQUAL
14562: IFFALSE 14776
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14564: LD_VAR 0 3
14568: PUSH
14569: LD_INT 21
14571: PUSH
14572: LD_INT 3
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: PPUSH
14579: CALL_OW 69
14583: IN
14584: IFFALSE 14776
// begin side := GetSide ( cr1 ) ;
14586: LD_ADDR_VAR 0 9
14590: PUSH
14591: LD_VAR 0 3
14595: PPUSH
14596: CALL_OW 255
14600: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14601: LD_INT 22
14603: PUSH
14604: LD_VAR 0 9
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 30
14615: PUSH
14616: LD_INT 28
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PPUSH
14627: CALL_OW 69
14631: PUSH
14632: LD_INT 0
14634: GREATER
14635: IFFALSE 14776
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14637: LD_ADDR_VAR 0 7
14641: PUSH
14642: LD_INT 22
14644: PUSH
14645: LD_VAR 0 9
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PUSH
14654: LD_INT 2
14656: PUSH
14657: LD_INT 30
14659: PUSH
14660: LD_INT 26
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 30
14669: PUSH
14670: LD_INT 27
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 30
14679: PUSH
14680: LD_INT 28
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PPUSH
14697: CALL_OW 69
14701: PUSH
14702: FOR_IN
14703: IFFALSE 14719
// SetLives ( i , 1 ) ;
14705: LD_VAR 0 7
14709: PPUSH
14710: LD_INT 1
14712: PPUSH
14713: CALL_OW 234
14717: GO 14702
14719: POP
14720: POP
// player_res_art := false ;
14721: LD_ADDR_EXP 6
14725: PUSH
14726: LD_INT 0
14728: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14729: LD_OWVAR 2
14733: PPUSH
14734: LD_EXP 8
14738: PPUSH
14739: LD_INT 1
14741: PPUSH
14742: LD_VAR 0 8
14746: PPUSH
14747: CALL_OW 468
// Wait ( time_to_reuse ) ;
14751: LD_EXP 11
14755: PPUSH
14756: CALL_OW 67
// player_res_art := true ;
14760: LD_ADDR_EXP 6
14764: PUSH
14765: LD_INT 1
14767: ST_TO_ADDR
// medal_enabled := true ;
14768: LD_ADDR_EXP 13
14772: PUSH
14773: LD_INT 1
14775: ST_TO_ADDR
// end ; end ; end ; end ;
14776: PPOPN 9
14778: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14779: LD_VAR 0 1
14783: PPUSH
14784: CALL_OW 255
14788: PUSH
14789: LD_OWVAR 2
14793: EQUAL
14794: IFFALSE 14831
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14796: LD_OWVAR 2
14800: PPUSH
14801: LD_INT 1
14803: PPUSH
14804: LD_INT 0
14806: PPUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: CALL_OW 468
// player_artifact_ready := true ;
14816: LD_ADDR_EXP 7
14820: PUSH
14821: LD_INT 1
14823: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14824: LD_STRING ArtVulcano
14826: PPUSH
14827: CALL_OW 339
// end ; end ;
14831: PPOPN 1
14833: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14834: LD_OWVAR 2
14838: PPUSH
14839: LD_INT 1
14841: PPUSH
14842: LD_INT 2
14844: PPUSH
14845: LD_VAR 0 1
14849: PPUSH
14850: CALL_OW 468
// end ; end_of_file
14854: PPOPN 2
14856: END
// every 0 0$01 do
14857: GO 14859
14859: DISABLE
// begin enable ;
14860: ENABLE
// Display_Strings := [ #tick , tick ] ;
14861: LD_ADDR_OWVAR 47
14865: PUSH
14866: LD_STRING #tick
14868: PUSH
14869: LD_OWVAR 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: ST_TO_ADDR
// end ; end_of_file
14878: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14879: LD_INT 0
14881: PPUSH
14882: PPUSH
14883: PPUSH
14884: PPUSH
14885: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14886: LD_ADDR_EXP 39
14890: PUSH
14891: LD_INT 7
14893: PUSH
14894: LD_INT 6
14896: PUSH
14897: LD_INT 5
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: LIST
14904: PUSH
14905: LD_OWVAR 67
14909: ARRAY
14910: ST_TO_ADDR
// al_force := [ ] ;
14911: LD_ADDR_EXP 38
14915: PUSH
14916: EMPTY
14917: ST_TO_ADDR
// RemoveAlliance ;
14918: CALL 15296 0 0
// ResetFog ;
14922: CALL_OW 335
// your_side := 7 ;
14926: LD_ADDR_OWVAR 2
14930: PUSH
14931: LD_INT 7
14933: ST_TO_ADDR
// uc_side := 7 ;
14934: LD_ADDR_OWVAR 20
14938: PUSH
14939: LD_INT 7
14941: ST_TO_ADDR
// hc_gallery :=  ;
14942: LD_ADDR_OWVAR 33
14946: PUSH
14947: LD_STRING 
14949: ST_TO_ADDR
// hc_name :=  ;
14950: LD_ADDR_OWVAR 26
14954: PUSH
14955: LD_STRING 
14957: ST_TO_ADDR
// hc_importance := 0 ;
14958: LD_ADDR_OWVAR 32
14962: PUSH
14963: LD_INT 0
14965: ST_TO_ADDR
// for i = 1 to 17 do
14966: LD_ADDR_VAR 0 2
14970: PUSH
14971: DOUBLE
14972: LD_INT 1
14974: DEC
14975: ST_TO_ADDR
14976: LD_INT 17
14978: PUSH
14979: FOR_TO
14980: IFFALSE 15060
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14982: LD_ADDR_OWVAR 21
14986: PUSH
14987: LD_INT 1
14989: PUSH
14990: LD_INT 3
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: PUSH
14997: LD_INT 1
14999: PPUSH
15000: LD_INT 2
15002: PPUSH
15003: CALL_OW 12
15007: ARRAY
15008: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15009: LD_INT 0
15011: PPUSH
15012: LD_INT 1
15014: PPUSH
15015: LD_INT 4
15017: PPUSH
15018: CALL_OW 12
15022: PPUSH
15023: LD_EXP 39
15027: PPUSH
15028: CALL_OW 380
// un := CreateHuman ;
15032: LD_ADDR_VAR 0 4
15036: PUSH
15037: CALL_OW 44
15041: ST_TO_ADDR
// al_force := al_force ^ un ;
15042: LD_ADDR_EXP 38
15046: PUSH
15047: LD_EXP 38
15051: PUSH
15052: LD_VAR 0 4
15056: ADD
15057: ST_TO_ADDR
// end ;
15058: GO 14979
15060: POP
15061: POP
// hc_importance := 100 ;
15062: LD_ADDR_OWVAR 32
15066: PUSH
15067: LD_INT 100
15069: ST_TO_ADDR
// uc_nation := 1 ;
15070: LD_ADDR_OWVAR 21
15074: PUSH
15075: LD_INT 1
15077: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15078: LD_INT 1
15080: PPUSH
15081: LD_INT 1
15083: PPUSH
15084: LD_EXP 39
15088: PPUSH
15089: CALL_OW 380
// al_commander := CreateHuman ;
15093: LD_ADDR_EXP 37
15097: PUSH
15098: CALL_OW 44
15102: ST_TO_ADDR
// player_commander := al_commander ;
15103: LD_ADDR_EXP 10
15107: PUSH
15108: LD_EXP 37
15112: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15113: LD_ADDR_VAR 0 5
15117: PUSH
15118: LD_STRING text
15120: PPUSH
15121: LD_INT 9
15123: PUSH
15124: LD_INT 9
15126: PUSH
15127: LD_INT 8
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: PUSH
15135: LD_OWVAR 67
15139: ARRAY
15140: PPUSH
15141: LD_INT 9
15143: PUSH
15144: LD_INT 9
15146: PUSH
15147: LD_INT 8
15149: PUSH
15150: EMPTY
15151: LIST
15152: LIST
15153: LIST
15154: PUSH
15155: LD_OWVAR 67
15159: ARRAY
15160: PPUSH
15161: LD_INT -5
15163: PUSH
15164: LD_EXP 37
15168: PUSH
15169: LD_INT -3
15171: PUSH
15172: LD_INT -2
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: LIST
15179: LIST
15180: PUSH
15181: LD_EXP 38
15185: ADD
15186: PPUSH
15187: LD_INT 1
15189: PUSH
15190: LD_INT 3
15192: PUSH
15193: LD_INT 2
15195: PUSH
15196: LD_INT 1
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: PUSH
15203: LD_INT 4
15205: PUSH
15206: LD_INT 1
15208: PUSH
15209: EMPTY
15210: LIST
15211: LIST
15212: PUSH
15213: LD_INT 9
15215: PUSH
15216: LD_INT 5
15218: PUSH
15219: EMPTY
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: PPUSH
15227: CALL_OW 42
15231: ST_TO_ADDR
// team := team ^ al_commander ;
15232: LD_ADDR_VAR 0 5
15236: PUSH
15237: LD_VAR 0 5
15241: PUSH
15242: LD_EXP 37
15246: ADD
15247: ST_TO_ADDR
// for i = 1 to team do
15248: LD_ADDR_VAR 0 2
15252: PUSH
15253: DOUBLE
15254: LD_INT 1
15256: DEC
15257: ST_TO_ADDR
15258: LD_VAR 0 5
15262: PUSH
15263: FOR_TO
15264: IFFALSE 15289
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15266: LD_VAR 0 5
15270: PUSH
15271: LD_VAR 0 2
15275: ARRAY
15276: PPUSH
15277: LD_INT 15
15279: PPUSH
15280: LD_INT 0
15282: PPUSH
15283: CALL_OW 49
15287: GO 15263
15289: POP
15290: POP
// end ;
15291: LD_VAR 0 1
15295: RET
// export function RemoveAlliance ; var i ; begin
15296: LD_INT 0
15298: PPUSH
15299: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15300: LD_INT 22
15302: PUSH
15303: LD_INT 7
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PUSH
15310: LD_INT 30
15312: PUSH
15313: LD_INT 1
15315: PUSH
15316: EMPTY
15317: LIST
15318: LIST
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PPUSH
15324: CALL_OW 69
15328: PUSH
15329: LD_INT 1
15331: ARRAY
15332: PPUSH
15333: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15337: LD_ADDR_VAR 0 2
15341: PUSH
15342: LD_INT 22
15344: PUSH
15345: LD_INT 7
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PPUSH
15352: CALL_OW 69
15356: PUSH
15357: FOR_IN
15358: IFFALSE 15371
// RemoveUnit ( i ) ;
15360: LD_VAR 0 2
15364: PPUSH
15365: CALL_OW 64
15369: GO 15357
15371: POP
15372: POP
// end ;
15373: LD_VAR 0 1
15377: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15378: LD_INT 0
15380: PPUSH
15381: PPUSH
15382: PPUSH
15383: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15384: LD_INT 31
15386: PPUSH
15387: LD_INT 7
15389: PPUSH
15390: LD_INT 2
15392: PPUSH
15393: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15397: LD_INT 32
15399: PPUSH
15400: LD_INT 7
15402: PPUSH
15403: LD_INT 2
15405: PPUSH
15406: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15410: LD_INT 59
15412: PPUSH
15413: LD_INT 7
15415: PPUSH
15416: LD_INT 2
15418: PPUSH
15419: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15423: LD_ADDR_EXP 39
15427: PUSH
15428: LD_INT 5
15430: PUSH
15431: LD_INT 6
15433: PUSH
15434: LD_INT 7
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: LIST
15441: PUSH
15442: LD_OWVAR 67
15446: ARRAY
15447: ST_TO_ADDR
// al_force := [ ] ;
15448: LD_ADDR_EXP 38
15452: PUSH
15453: EMPTY
15454: ST_TO_ADDR
// al_vehs := [ ] ;
15455: LD_ADDR_EXP 44
15459: PUSH
15460: EMPTY
15461: ST_TO_ADDR
// uc_side := 7 ;
15462: LD_ADDR_OWVAR 20
15466: PUSH
15467: LD_INT 7
15469: ST_TO_ADDR
// uc_nation := 1 ;
15470: LD_ADDR_OWVAR 21
15474: PUSH
15475: LD_INT 1
15477: ST_TO_ADDR
// bc_type := b_oil_mine ;
15478: LD_ADDR_OWVAR 42
15482: PUSH
15483: LD_INT 29
15485: ST_TO_ADDR
// b := CreateBuilding ;
15486: LD_ADDR_VAR 0 4
15490: PUSH
15491: CALL_OW 46
15495: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15496: LD_VAR 0 4
15500: PPUSH
15501: LD_INT 61
15503: PPUSH
15504: LD_INT 7
15506: PPUSH
15507: LD_INT 0
15509: PPUSH
15510: LD_INT 0
15512: PPUSH
15513: CALL_OW 50
// bc_type := b_siberite_mine ;
15517: LD_ADDR_OWVAR 42
15521: PUSH
15522: LD_INT 30
15524: ST_TO_ADDR
// b := CreateBuilding ;
15525: LD_ADDR_VAR 0 4
15529: PUSH
15530: CALL_OW 46
15534: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15535: LD_VAR 0 4
15539: PPUSH
15540: LD_INT 69
15542: PPUSH
15543: LD_INT 13
15545: PPUSH
15546: LD_INT 0
15548: PPUSH
15549: LD_INT 0
15551: PPUSH
15552: CALL_OW 50
// hc_gallery :=  ;
15556: LD_ADDR_OWVAR 33
15560: PUSH
15561: LD_STRING 
15563: ST_TO_ADDR
// hc_name :=  ;
15564: LD_ADDR_OWVAR 26
15568: PUSH
15569: LD_STRING 
15571: ST_TO_ADDR
// hc_importance := 0 ;
15572: LD_ADDR_OWVAR 32
15576: PUSH
15577: LD_INT 0
15579: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15580: LD_ADDR_VAR 0 2
15584: PUSH
15585: LD_INT 22
15587: PUSH
15588: LD_INT 7
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PUSH
15595: LD_INT 30
15597: PUSH
15598: LD_INT 32
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PPUSH
15609: CALL_OW 69
15613: PUSH
15614: FOR_IN
15615: IFFALSE 15685
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15617: LD_ADDR_OWVAR 21
15621: PUSH
15622: LD_INT 1
15624: PUSH
15625: LD_INT 3
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: PUSH
15632: LD_INT 1
15634: PPUSH
15635: LD_INT 2
15637: PPUSH
15638: CALL_OW 12
15642: ARRAY
15643: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15644: LD_INT 0
15646: PPUSH
15647: LD_INT 1
15649: PPUSH
15650: LD_EXP 39
15654: PPUSH
15655: CALL_OW 380
// un := CreateHuman ;
15659: LD_ADDR_VAR 0 3
15663: PUSH
15664: CALL_OW 44
15668: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15669: LD_VAR 0 3
15673: PPUSH
15674: LD_VAR 0 2
15678: PPUSH
15679: CALL_OW 52
// end ;
15683: GO 15614
15685: POP
15686: POP
// for i = 1 to 3 do
15687: LD_ADDR_VAR 0 2
15691: PUSH
15692: DOUBLE
15693: LD_INT 1
15695: DEC
15696: ST_TO_ADDR
15697: LD_INT 3
15699: PUSH
15700: FOR_TO
15701: IFFALSE 15769
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15703: LD_ADDR_OWVAR 21
15707: PUSH
15708: LD_INT 1
15710: PUSH
15711: LD_INT 3
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: LD_INT 1
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL_OW 12
15728: ARRAY
15729: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15730: LD_INT 0
15732: PPUSH
15733: LD_INT 4
15735: PPUSH
15736: LD_EXP 39
15740: PPUSH
15741: CALL_OW 380
// un := CreateHuman ;
15745: LD_ADDR_VAR 0 3
15749: PUSH
15750: CALL_OW 44
15754: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15755: LD_VAR 0 3
15759: PPUSH
15760: LD_INT 164
15762: PPUSH
15763: CALL_OW 52
// end ;
15767: GO 15700
15769: POP
15770: POP
// for i = 1 to 6 do
15771: LD_ADDR_VAR 0 2
15775: PUSH
15776: DOUBLE
15777: LD_INT 1
15779: DEC
15780: ST_TO_ADDR
15781: LD_INT 6
15783: PUSH
15784: FOR_TO
15785: IFFALSE 15876
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15787: LD_ADDR_OWVAR 21
15791: PUSH
15792: LD_INT 1
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 1
15804: PPUSH
15805: LD_INT 2
15807: PPUSH
15808: CALL_OW 12
15812: ARRAY
15813: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15814: LD_INT 0
15816: PPUSH
15817: LD_INT 5
15819: PUSH
15820: LD_INT 9
15822: PUSH
15823: LD_INT 9
15825: PUSH
15826: EMPTY
15827: LIST
15828: LIST
15829: LIST
15830: PUSH
15831: LD_INT 1
15833: PPUSH
15834: LD_INT 3
15836: PPUSH
15837: CALL_OW 12
15841: ARRAY
15842: PPUSH
15843: LD_EXP 39
15847: PPUSH
15848: CALL_OW 380
// un := CreateHuman ;
15852: LD_ADDR_VAR 0 3
15856: PUSH
15857: CALL_OW 44
15861: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15862: LD_VAR 0 3
15866: PPUSH
15867: LD_INT 173
15869: PPUSH
15870: CALL_OW 52
// end ;
15874: GO 15784
15876: POP
15877: POP
// for i = 1 to 6 do
15878: LD_ADDR_VAR 0 2
15882: PUSH
15883: DOUBLE
15884: LD_INT 1
15886: DEC
15887: ST_TO_ADDR
15888: LD_INT 6
15890: PUSH
15891: FOR_TO
15892: IFFALSE 15990
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15894: LD_ADDR_OWVAR 21
15898: PUSH
15899: LD_INT 1
15901: PUSH
15902: LD_INT 3
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 1
15911: PPUSH
15912: LD_INT 2
15914: PPUSH
15915: CALL_OW 12
15919: ARRAY
15920: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15921: LD_INT 0
15923: PPUSH
15924: LD_INT 3
15926: PPUSH
15927: LD_EXP 39
15931: PPUSH
15932: CALL_OW 380
// un := CreateHuman ;
15936: LD_ADDR_VAR 0 3
15940: PUSH
15941: CALL_OW 44
15945: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15946: LD_VAR 0 3
15950: PPUSH
15951: LD_INT 22
15953: PUSH
15954: LD_INT 7
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 30
15963: PUSH
15964: LD_INT 3
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: PPUSH
15975: CALL_OW 69
15979: PUSH
15980: LD_INT 1
15982: ARRAY
15983: PPUSH
15984: CALL_OW 52
// end ;
15988: GO 15891
15990: POP
15991: POP
// for i = 1 to 4 do
15992: LD_ADDR_VAR 0 2
15996: PUSH
15997: DOUBLE
15998: LD_INT 1
16000: DEC
16001: ST_TO_ADDR
16002: LD_INT 4
16004: PUSH
16005: FOR_TO
16006: IFFALSE 16074
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16008: LD_ADDR_OWVAR 21
16012: PUSH
16013: LD_INT 1
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 1
16025: PPUSH
16026: LD_INT 2
16028: PPUSH
16029: CALL_OW 12
16033: ARRAY
16034: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16035: LD_INT 0
16037: PPUSH
16038: LD_INT 2
16040: PPUSH
16041: LD_EXP 39
16045: PPUSH
16046: CALL_OW 380
// un := CreateHuman ;
16050: LD_ADDR_VAR 0 3
16054: PUSH
16055: CALL_OW 44
16059: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16060: LD_VAR 0 3
16064: PPUSH
16065: LD_INT 162
16067: PPUSH
16068: CALL_OW 52
// end ;
16072: GO 16005
16074: POP
16075: POP
// uc_nation := 3 ;
16076: LD_ADDR_OWVAR 21
16080: PUSH
16081: LD_INT 3
16083: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16084: LD_ADDR_OWVAR 37
16088: PUSH
16089: LD_INT 21
16091: ST_TO_ADDR
// vc_engine := engine_siberite ;
16092: LD_ADDR_OWVAR 39
16096: PUSH
16097: LD_INT 3
16099: ST_TO_ADDR
// vc_control := control_computer ;
16100: LD_ADDR_OWVAR 38
16104: PUSH
16105: LD_INT 3
16107: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16108: LD_ADDR_OWVAR 40
16112: PUSH
16113: LD_INT 51
16115: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16116: CALL_OW 45
16120: PPUSH
16121: LD_INT 49
16123: PPUSH
16124: LD_INT 13
16126: PPUSH
16127: LD_INT 0
16129: PPUSH
16130: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16134: LD_ADDR_EXP 46
16138: PUSH
16139: LD_INT 22
16141: PUSH
16142: LD_INT 7
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: LD_INT 30
16151: PUSH
16152: LD_INT 33
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: PPUSH
16163: CALL_OW 69
16167: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16168: LD_ADDR_VAR 0 2
16172: PUSH
16173: DOUBLE
16174: LD_INT 1
16176: DEC
16177: ST_TO_ADDR
16178: LD_INT 22
16180: PUSH
16181: LD_INT 7
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: LD_INT 30
16190: PUSH
16191: LD_INT 33
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: PUSH
16198: LD_INT 35
16200: PUSH
16201: LD_INT 0
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PUSH
16208: EMPTY
16209: LIST
16210: LIST
16211: LIST
16212: PUSH
16213: EMPTY
16214: LIST
16215: PPUSH
16216: CALL_OW 69
16220: PUSH
16221: FOR_TO
16222: IFFALSE 16282
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16224: LD_INT 22
16226: PUSH
16227: LD_INT 7
16229: PUSH
16230: EMPTY
16231: LIST
16232: LIST
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 33
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: PUSH
16244: LD_INT 35
16246: PUSH
16247: LD_INT 0
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: LIST
16258: PUSH
16259: EMPTY
16260: LIST
16261: PPUSH
16262: CALL_OW 69
16266: PUSH
16267: LD_VAR 0 2
16271: ARRAY
16272: PPUSH
16273: LD_INT 49
16275: PPUSH
16276: CALL_OW 208
16280: GO 16221
16282: POP
16283: POP
// end ;
16284: LD_VAR 0 1
16288: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16289: LD_OWVAR 2
16293: PUSH
16294: LD_INT 1
16296: EQUAL
16297: IFFALSE 17465
16299: GO 16301
16301: DISABLE
16302: LD_INT 0
16304: PPUSH
16305: PPUSH
16306: PPUSH
16307: PPUSH
// begin enable ;
16308: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16309: LD_ADDR_EXP 50
16313: PUSH
16314: LD_INT 22
16316: PUSH
16317: LD_INT 7
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PUSH
16324: LD_INT 21
16326: PUSH
16327: LD_INT 3
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PPUSH
16338: CALL_OW 69
16342: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16343: LD_ADDR_EXP 48
16347: PUSH
16348: LD_INT 164
16350: PUSH
16351: LD_INT 197
16353: PUSH
16354: EMPTY
16355: LIST
16356: LIST
16357: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16358: LD_ADDR_EXP 47
16362: PUSH
16363: LD_INT 22
16365: PUSH
16366: LD_INT 7
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 30
16375: PUSH
16376: LD_INT 1
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: PPUSH
16387: CALL_OW 69
16391: PUSH
16392: LD_INT 1
16394: ARRAY
16395: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16396: LD_ADDR_EXP 49
16400: PUSH
16401: LD_INT 22
16403: PUSH
16404: LD_INT 7
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 30
16413: PUSH
16414: LD_INT 3
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PPUSH
16425: CALL_OW 69
16429: PUSH
16430: LD_INT 1
16432: ARRAY
16433: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16434: LD_INT 22
16436: PUSH
16437: LD_INT 7
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PUSH
16444: LD_INT 34
16446: PUSH
16447: LD_INT 51
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: PPUSH
16458: CALL_OW 69
16462: IFFALSE 16502
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16464: LD_ADDR_EXP 45
16468: PUSH
16469: LD_INT 22
16471: PUSH
16472: LD_INT 7
16474: PUSH
16475: EMPTY
16476: LIST
16477: LIST
16478: PUSH
16479: LD_INT 34
16481: PUSH
16482: LD_INT 51
16484: PUSH
16485: EMPTY
16486: LIST
16487: LIST
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: PUSH
16498: LD_INT 1
16500: ARRAY
16501: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16502: LD_ADDR_EXP 41
16506: PUSH
16507: LD_INT 22
16509: PUSH
16510: LD_INT 7
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 25
16519: PUSH
16520: LD_INT 9
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: PPUSH
16531: CALL_OW 69
16535: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16536: LD_ADDR_EXP 40
16540: PUSH
16541: LD_INT 22
16543: PUSH
16544: LD_INT 7
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PUSH
16551: LD_INT 25
16553: PUSH
16554: LD_INT 2
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL_OW 69
16569: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16570: LD_ADDR_EXP 42
16574: PUSH
16575: LD_INT 22
16577: PUSH
16578: LD_INT 7
16580: PUSH
16581: EMPTY
16582: LIST
16583: LIST
16584: PUSH
16585: LD_INT 25
16587: PUSH
16588: LD_INT 3
16590: PUSH
16591: EMPTY
16592: LIST
16593: LIST
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: PPUSH
16599: CALL_OW 69
16603: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16604: LD_ADDR_EXP 43
16608: PUSH
16609: LD_INT 22
16611: PUSH
16612: LD_INT 7
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 25
16621: PUSH
16622: LD_INT 4
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: PPUSH
16633: CALL_OW 69
16637: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16638: LD_EXP 41
16642: PPUSH
16643: LD_INT 81
16645: PUSH
16646: LD_INT 7
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PPUSH
16653: CALL_OW 69
16657: PPUSH
16658: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16662: LD_EXP 45
16666: PPUSH
16667: CALL_OW 314
16671: NOT
16672: PUSH
16673: LD_EXP 45
16677: PPUSH
16678: LD_INT 1
16680: PPUSH
16681: CALL_OW 289
16685: PUSH
16686: LD_INT 100
16688: LESS
16689: AND
16690: IFFALSE 16738
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16692: LD_ADDR_VAR 0 4
16696: PUSH
16697: LD_INT 12
16699: PPUSH
16700: CALL_OW 435
16704: ST_TO_ADDR
// if cr then
16705: LD_VAR 0 4
16709: IFFALSE 16738
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16711: LD_EXP 45
16715: PPUSH
16716: LD_VAR 0 4
16720: PUSH
16721: LD_INT 1
16723: ARRAY
16724: PPUSH
16725: LD_VAR 0 4
16729: PUSH
16730: LD_INT 2
16732: ARRAY
16733: PPUSH
16734: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16738: LD_EXP 50
16742: PPUSH
16743: LD_INT 3
16745: PUSH
16746: LD_INT 24
16748: PUSH
16749: LD_INT 1000
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: EMPTY
16757: LIST
16758: LIST
16759: PPUSH
16760: CALL_OW 72
16764: IFFALSE 16894
// begin if al_eng then
16766: LD_EXP 40
16770: IFFALSE 16892
// for i = 1 to al_eng do
16772: LD_ADDR_VAR 0 1
16776: PUSH
16777: DOUBLE
16778: LD_INT 1
16780: DEC
16781: ST_TO_ADDR
16782: LD_EXP 40
16786: PUSH
16787: FOR_TO
16788: IFFALSE 16890
// if IsInUnit ( al_eng [ i ] ) then
16790: LD_EXP 40
16794: PUSH
16795: LD_VAR 0 1
16799: ARRAY
16800: PPUSH
16801: CALL_OW 310
16805: IFFALSE 16824
// ComExitBuilding ( al_eng [ i ] ) else
16807: LD_EXP 40
16811: PUSH
16812: LD_VAR 0 1
16816: ARRAY
16817: PPUSH
16818: CALL_OW 122
16822: GO 16888
// if not HasTask ( al_eng [ i ] ) then
16824: LD_EXP 40
16828: PUSH
16829: LD_VAR 0 1
16833: ARRAY
16834: PPUSH
16835: CALL_OW 314
16839: NOT
16840: IFFALSE 16888
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16842: LD_EXP 40
16846: PUSH
16847: LD_VAR 0 1
16851: ARRAY
16852: PPUSH
16853: LD_EXP 50
16857: PPUSH
16858: LD_INT 3
16860: PUSH
16861: LD_INT 24
16863: PUSH
16864: LD_INT 1000
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PPUSH
16875: CALL_OW 72
16879: PUSH
16880: LD_INT 1
16882: ARRAY
16883: PPUSH
16884: CALL_OW 130
16888: GO 16787
16890: POP
16891: POP
// end else
16892: GO 16976
// if al_eng then
16894: LD_EXP 40
16898: IFFALSE 16976
// if not IsInUnit ( al_eng [ 1 ] ) then
16900: LD_EXP 40
16904: PUSH
16905: LD_INT 1
16907: ARRAY
16908: PPUSH
16909: CALL_OW 310
16913: NOT
16914: IFFALSE 16976
// for i = 1 to al_eng do
16916: LD_ADDR_VAR 0 1
16920: PUSH
16921: DOUBLE
16922: LD_INT 1
16924: DEC
16925: ST_TO_ADDR
16926: LD_EXP 40
16930: PUSH
16931: FOR_TO
16932: IFFALSE 16974
// if not IsInUnit ( al_eng [ i ] ) then
16934: LD_EXP 40
16938: PUSH
16939: LD_VAR 0 1
16943: ARRAY
16944: PPUSH
16945: CALL_OW 310
16949: NOT
16950: IFFALSE 16972
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16952: LD_EXP 40
16956: PUSH
16957: LD_VAR 0 1
16961: ARRAY
16962: PPUSH
16963: LD_EXP 47
16967: PPUSH
16968: CALL_OW 120
16972: GO 16931
16974: POP
16975: POP
// if al_vehs then
16976: LD_EXP 44
16980: IFFALSE 17080
// if BuildingStatus ( al_fac ) = bs_idle then
16982: LD_EXP 49
16986: PPUSH
16987: CALL_OW 461
16991: PUSH
16992: LD_INT 2
16994: EQUAL
16995: IFFALSE 17080
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16997: LD_EXP 49
17001: PPUSH
17002: LD_EXP 44
17006: PUSH
17007: LD_INT 1
17009: ARRAY
17010: PPUSH
17011: LD_EXP 44
17015: PUSH
17016: LD_INT 2
17018: ARRAY
17019: PPUSH
17020: LD_EXP 44
17024: PUSH
17025: LD_INT 3
17027: ARRAY
17028: PPUSH
17029: LD_EXP 44
17033: PUSH
17034: LD_INT 4
17036: ARRAY
17037: PPUSH
17038: CALL_OW 125
// for i = 1 to 4 do
17042: LD_ADDR_VAR 0 1
17046: PUSH
17047: DOUBLE
17048: LD_INT 1
17050: DEC
17051: ST_TO_ADDR
17052: LD_INT 4
17054: PUSH
17055: FOR_TO
17056: IFFALSE 17078
// al_vehs := Delete ( al_vehs , 1 ) ;
17058: LD_ADDR_EXP 44
17062: PUSH
17063: LD_EXP 44
17067: PPUSH
17068: LD_INT 1
17070: PPUSH
17071: CALL_OW 3
17075: ST_TO_ADDR
17076: GO 17055
17078: POP
17079: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17080: LD_EXP 38
17084: PUSH
17085: LD_INT 0
17087: EQUAL
17088: PUSH
17089: LD_OWVAR 1
17093: PUSH
17094: LD_INT 23100
17096: MOD
17097: PUSH
17098: LD_INT 0
17100: EQUAL
17101: AND
17102: IFFALSE 17216
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17104: LD_ADDR_VAR 0 1
17108: PUSH
17109: DOUBLE
17110: LD_INT 1
17112: DEC
17113: ST_TO_ADDR
17114: LD_INT 4
17116: PUSH
17117: LD_INT 5
17119: PUSH
17120: LD_INT 6
17122: PUSH
17123: EMPTY
17124: LIST
17125: LIST
17126: LIST
17127: PUSH
17128: LD_OWVAR 67
17132: ARRAY
17133: PUSH
17134: FOR_TO
17135: IFFALSE 17214
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17137: LD_ADDR_EXP 44
17141: PUSH
17142: LD_EXP 44
17146: PUSH
17147: LD_INT 23
17149: ADD
17150: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17151: LD_ADDR_EXP 44
17155: PUSH
17156: LD_EXP 44
17160: PUSH
17161: LD_INT 1
17163: ADD
17164: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17165: LD_ADDR_EXP 44
17169: PUSH
17170: LD_EXP 44
17174: PUSH
17175: LD_INT 3
17177: ADD
17178: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17179: LD_ADDR_EXP 44
17183: PUSH
17184: LD_EXP 44
17188: PUSH
17189: LD_INT 46
17191: PUSH
17192: LD_INT 47
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: PUSH
17199: LD_INT 1
17201: PPUSH
17202: LD_INT 2
17204: PPUSH
17205: CALL_OW 12
17209: ARRAY
17210: ADD
17211: ST_TO_ADDR
// end ;
17212: GO 17134
17214: POP
17215: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17216: LD_INT 22
17218: PUSH
17219: LD_INT 7
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 34
17228: PUSH
17229: LD_INT 51
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PPUSH
17240: CALL_OW 69
17244: PUSH
17245: LD_INT 0
17247: EQUAL
17248: IFFALSE 17271
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17250: LD_EXP 49
17254: PPUSH
17255: LD_INT 21
17257: PPUSH
17258: LD_INT 1
17260: PPUSH
17261: LD_INT 3
17263: PPUSH
17264: LD_INT 51
17266: PPUSH
17267: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17271: LD_EXP 38
17275: PUSH
17276: LD_OWVAR 1
17280: PUSH
17281: LD_INT 25200
17283: MOD
17284: PUSH
17285: LD_INT 0
17287: EQUAL
17288: AND
17289: IFFALSE 17352
// begin for i = 1 to al_force do
17291: LD_ADDR_VAR 0 1
17295: PUSH
17296: DOUBLE
17297: LD_INT 1
17299: DEC
17300: ST_TO_ADDR
17301: LD_EXP 38
17305: PUSH
17306: FOR_TO
17307: IFFALSE 17350
// if GetTag ( al_force [ i ] ) <> 11 then
17309: LD_EXP 38
17313: PUSH
17314: LD_VAR 0 1
17318: ARRAY
17319: PPUSH
17320: CALL_OW 110
17324: PUSH
17325: LD_INT 11
17327: NONEQUAL
17328: IFFALSE 17348
// SetTag ( al_force [ i ] , 11 ) ;
17330: LD_EXP 38
17334: PUSH
17335: LD_VAR 0 1
17339: ARRAY
17340: PPUSH
17341: LD_INT 11
17343: PPUSH
17344: CALL_OW 109
17348: GO 17306
17350: POP
17351: POP
// end ; if al_force then
17352: LD_EXP 38
17356: IFFALSE 17465
// for i = 1 to al_force do
17358: LD_ADDR_VAR 0 1
17362: PUSH
17363: DOUBLE
17364: LD_INT 1
17366: DEC
17367: ST_TO_ADDR
17368: LD_EXP 38
17372: PUSH
17373: FOR_TO
17374: IFFALSE 17463
// begin if GetTag ( al_force [ i ] ) = 11 then
17376: LD_EXP 38
17380: PUSH
17381: LD_VAR 0 1
17385: ARRAY
17386: PPUSH
17387: CALL_OW 110
17391: PUSH
17392: LD_INT 11
17394: EQUAL
17395: IFFALSE 17461
// begin if not HasTask ( al_force [ i ] ) then
17397: LD_EXP 38
17401: PUSH
17402: LD_VAR 0 1
17406: ARRAY
17407: PPUSH
17408: CALL_OW 314
17412: NOT
17413: IFFALSE 17461
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17415: LD_EXP 38
17419: PUSH
17420: LD_VAR 0 1
17424: ARRAY
17425: PPUSH
17426: LD_INT 81
17428: PUSH
17429: LD_INT 7
17431: PUSH
17432: EMPTY
17433: LIST
17434: LIST
17435: PPUSH
17436: CALL_OW 69
17440: PPUSH
17441: LD_EXP 38
17445: PUSH
17446: LD_VAR 0 1
17450: ARRAY
17451: PPUSH
17452: CALL_OW 74
17456: PPUSH
17457: CALL_OW 115
// end ; end ;
17461: GO 17373
17463: POP
17464: POP
// end ; end_of_file
17465: PPOPN 4
17467: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17468: LD_INT 0
17470: PPUSH
17471: PPUSH
17472: PPUSH
17473: PPUSH
17474: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17475: LD_ADDR_EXP 53
17479: PUSH
17480: LD_INT 7
17482: PUSH
17483: LD_INT 6
17485: PUSH
17486: LD_INT 5
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: LIST
17493: PUSH
17494: LD_OWVAR 67
17498: ARRAY
17499: ST_TO_ADDR
// ar_force := [ ] ;
17500: LD_ADDR_EXP 52
17504: PUSH
17505: EMPTY
17506: ST_TO_ADDR
// RemoveAlliance ;
17507: CALL 15296 0 0
// RemoveEnvironmentArea ( evn ) ;
17511: LD_INT 17
17513: PPUSH
17514: CALL_OW 355
// your_side := 2 ;
17518: LD_ADDR_OWVAR 2
17522: PUSH
17523: LD_INT 2
17525: ST_TO_ADDR
// uc_side := 2 ;
17526: LD_ADDR_OWVAR 20
17530: PUSH
17531: LD_INT 2
17533: ST_TO_ADDR
// uc_nation := nation_arabian ;
17534: LD_ADDR_OWVAR 21
17538: PUSH
17539: LD_INT 2
17541: ST_TO_ADDR
// hc_gallery :=  ;
17542: LD_ADDR_OWVAR 33
17546: PUSH
17547: LD_STRING 
17549: ST_TO_ADDR
// hc_name :=  ;
17550: LD_ADDR_OWVAR 26
17554: PUSH
17555: LD_STRING 
17557: ST_TO_ADDR
// hc_importance := 0 ;
17558: LD_ADDR_OWVAR 32
17562: PUSH
17563: LD_INT 0
17565: ST_TO_ADDR
// for i = 1 to 15 do
17566: LD_ADDR_VAR 0 2
17570: PUSH
17571: DOUBLE
17572: LD_INT 1
17574: DEC
17575: ST_TO_ADDR
17576: LD_INT 15
17578: PUSH
17579: FOR_TO
17580: IFFALSE 17633
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17582: LD_INT 0
17584: PPUSH
17585: LD_INT 1
17587: PPUSH
17588: LD_INT 4
17590: PPUSH
17591: CALL_OW 12
17595: PPUSH
17596: LD_EXP 53
17600: PPUSH
17601: CALL_OW 380
// un := CreateHuman ;
17605: LD_ADDR_VAR 0 4
17609: PUSH
17610: CALL_OW 44
17614: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17615: LD_ADDR_EXP 52
17619: PUSH
17620: LD_EXP 52
17624: PUSH
17625: LD_VAR 0 4
17629: ADD
17630: ST_TO_ADDR
// end ;
17631: GO 17579
17633: POP
17634: POP
// hc_importance := 100 ;
17635: LD_ADDR_OWVAR 32
17639: PUSH
17640: LD_INT 100
17642: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17643: LD_INT 1
17645: PPUSH
17646: LD_INT 11
17648: PPUSH
17649: LD_EXP 53
17653: PPUSH
17654: CALL_OW 380
// ar_commander := CreateHuman ;
17658: LD_ADDR_EXP 51
17662: PUSH
17663: CALL_OW 44
17667: ST_TO_ADDR
// player_commander := ar_commander ;
17668: LD_ADDR_EXP 10
17672: PUSH
17673: LD_EXP 51
17677: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17678: LD_ADDR_VAR 0 5
17682: PUSH
17683: LD_STRING text
17685: PPUSH
17686: LD_INT 11
17688: PUSH
17689: LD_INT 10
17691: PUSH
17692: LD_INT 9
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: LIST
17699: PUSH
17700: LD_OWVAR 67
17704: ARRAY
17705: PPUSH
17706: LD_INT 11
17708: PUSH
17709: LD_INT 10
17711: PUSH
17712: LD_INT 9
17714: PUSH
17715: EMPTY
17716: LIST
17717: LIST
17718: LIST
17719: PUSH
17720: LD_OWVAR 67
17724: ARRAY
17725: PPUSH
17726: LD_INT -5
17728: PUSH
17729: LD_EXP 51
17733: PUSH
17734: LD_INT -3
17736: PUSH
17737: LD_INT -2
17739: PUSH
17740: EMPTY
17741: LIST
17742: LIST
17743: LIST
17744: LIST
17745: PUSH
17746: LD_EXP 52
17750: ADD
17751: PPUSH
17752: LD_INT 1
17754: PUSH
17755: LD_INT 3
17757: PUSH
17758: LD_INT 2
17760: PUSH
17761: LD_INT 1
17763: PUSH
17764: EMPTY
17765: LIST
17766: LIST
17767: PUSH
17768: LD_INT 4
17770: PUSH
17771: LD_INT 1
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PUSH
17778: LD_INT 8
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: PPUSH
17788: CALL_OW 42
17792: ST_TO_ADDR
// team := team ^ ar_commander ;
17793: LD_ADDR_VAR 0 5
17797: PUSH
17798: LD_VAR 0 5
17802: PUSH
17803: LD_EXP 51
17807: ADD
17808: ST_TO_ADDR
// for i = 1 to team do
17809: LD_ADDR_VAR 0 2
17813: PUSH
17814: DOUBLE
17815: LD_INT 1
17817: DEC
17818: ST_TO_ADDR
17819: LD_VAR 0 5
17823: PUSH
17824: FOR_TO
17825: IFFALSE 17850
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17827: LD_VAR 0 5
17831: PUSH
17832: LD_VAR 0 2
17836: ARRAY
17837: PPUSH
17838: LD_INT 16
17840: PPUSH
17841: LD_INT 0
17843: PPUSH
17844: CALL_OW 49
17848: GO 17824
17850: POP
17851: POP
// uc_side := 0 ;
17852: LD_ADDR_OWVAR 20
17856: PUSH
17857: LD_INT 0
17859: ST_TO_ADDR
// uc_nation := 0 ;
17860: LD_ADDR_OWVAR 21
17864: PUSH
17865: LD_INT 0
17867: ST_TO_ADDR
// vc_chassis := 31 ;
17868: LD_ADDR_OWVAR 37
17872: PUSH
17873: LD_INT 31
17875: ST_TO_ADDR
// vc_control := control_rider ;
17876: LD_ADDR_OWVAR 38
17880: PUSH
17881: LD_INT 4
17883: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17884: CALL_OW 45
17888: PPUSH
17889: LD_INT 96
17891: PPUSH
17892: LD_INT 20
17894: PPUSH
17895: LD_INT 0
17897: PPUSH
17898: CALL_OW 48
// end ;
17902: LD_VAR 0 1
17906: RET
