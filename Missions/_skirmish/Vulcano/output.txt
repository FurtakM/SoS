// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3532 0 0
// PrepareLegion ;
  27: CALL 7063 0 0
// Action ;
  31: CALL 10742 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16057 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL 29469 0 1
// if GetSide ( un ) = your_side then
2516: LD_VAR 0 1
2520: PPUSH
2521: CALL_OW 255
2525: PUSH
2526: LD_OWVAR 2
2530: EQUAL
2531: IFFALSE 2547
// dead_counter := dead_counter + 1 ;
2533: LD_ADDR_EXP 14
2537: PUSH
2538: LD_EXP 14
2542: PUSH
2543: LD_INT 1
2545: PLUS
2546: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2547: LD_VAR 0 1
2551: PPUSH
2552: CALL_OW 255
2556: PUSH
2557: LD_INT 81
2559: PUSH
2560: LD_OWVAR 2
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PPUSH
2569: CALL_OW 69
2573: IN
2574: IFFALSE 2590
// kill_counter := kill_counter + 1 ;
2576: LD_ADDR_EXP 15
2580: PUSH
2581: LD_EXP 15
2585: PUSH
2586: LD_INT 1
2588: PLUS
2589: ST_TO_ADDR
// if un = player_commander then
2590: LD_VAR 0 1
2594: PUSH
2595: LD_EXP 10
2599: EQUAL
2600: IFFALSE 2609
// YouLost ( vulcano-lost ) ;
2602: LD_STRING vulcano-lost
2604: PPUSH
2605: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2609: LD_VAR 0 1
2613: PUSH
2614: LD_INT 22
2616: PUSH
2617: LD_INT 3
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 3
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: IN
2643: IFFALSE 2759
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2645: LD_VAR 0 1
2649: PPUSH
2650: CALL_OW 266
2654: PUSH
2655: LD_INT 33
2657: EQUAL
2658: PUSH
2659: LD_VAR 0 1
2663: PPUSH
2664: CALL_OW 266
2668: PUSH
2669: LD_INT 28
2671: EQUAL
2672: OR
2673: IFFALSE 2759
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2675: LD_ADDR_EXP 26
2679: PUSH
2680: LD_EXP 26
2684: PUSH
2685: LD_VAR 0 1
2689: PPUSH
2690: CALL_OW 266
2694: ADD
2695: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2696: LD_ADDR_EXP 26
2700: PUSH
2701: LD_EXP 26
2705: PUSH
2706: LD_VAR 0 1
2710: PPUSH
2711: CALL_OW 250
2715: ADD
2716: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2717: LD_ADDR_EXP 26
2721: PUSH
2722: LD_EXP 26
2726: PUSH
2727: LD_VAR 0 1
2731: PPUSH
2732: CALL_OW 251
2736: ADD
2737: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2738: LD_ADDR_EXP 26
2742: PUSH
2743: LD_EXP 26
2747: PUSH
2748: LD_VAR 0 1
2752: PPUSH
2753: CALL_OW 254
2757: ADD
2758: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2759: LD_VAR 0 1
2763: PUSH
2764: LD_INT 22
2766: PUSH
2767: LD_INT 8
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: LD_INT 21
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PPUSH
2788: CALL_OW 69
2792: IN
2793: IFFALSE 2937
// begin if GetBType ( un ) = b_barracks then
2795: LD_VAR 0 1
2799: PPUSH
2800: CALL_OW 266
2804: PUSH
2805: LD_INT 5
2807: EQUAL
2808: IFFALSE 2826
// legion_blist := legion_blist ^ b_armoury else
2810: LD_ADDR_EXP 34
2814: PUSH
2815: LD_EXP 34
2819: PUSH
2820: LD_INT 4
2822: ADD
2823: ST_TO_ADDR
2824: GO 2874
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2826: LD_VAR 0 1
2830: PPUSH
2831: CALL_OW 266
2835: PUSH
2836: LD_INT 1
2838: PUSH
2839: LD_INT 6
2841: PUSH
2842: LD_INT 8
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: LIST
2849: IN
2850: NOT
2851: IFFALSE 2874
// legion_blist := legion_blist ^ GetBType ( un ) ;
2853: LD_ADDR_EXP 34
2857: PUSH
2858: LD_EXP 34
2862: PUSH
2863: LD_VAR 0 1
2867: PPUSH
2868: CALL_OW 266
2872: ADD
2873: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2874: LD_ADDR_EXP 34
2878: PUSH
2879: LD_EXP 34
2883: PUSH
2884: LD_VAR 0 1
2888: PPUSH
2889: CALL_OW 250
2893: ADD
2894: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2895: LD_ADDR_EXP 34
2899: PUSH
2900: LD_EXP 34
2904: PUSH
2905: LD_VAR 0 1
2909: PPUSH
2910: CALL_OW 251
2914: ADD
2915: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2916: LD_ADDR_EXP 34
2920: PUSH
2921: LD_EXP 34
2925: PUSH
2926: LD_VAR 0 1
2930: PPUSH
2931: CALL_OW 254
2935: ADD
2936: ST_TO_ADDR
// end ; if un in legion_force then
2937: LD_VAR 0 1
2941: PUSH
2942: LD_EXP 31
2946: IN
2947: IFFALSE 2965
// legion_force := legion_force diff un ;
2949: LD_ADDR_EXP 31
2953: PUSH
2954: LD_EXP 31
2958: PUSH
2959: LD_VAR 0 1
2963: DIFF
2964: ST_TO_ADDR
// if un in ru_force then
2965: LD_VAR 0 1
2969: PUSH
2970: LD_EXP 23
2974: IN
2975: IFFALSE 2993
// ru_force := ru_force diff un ;
2977: LD_ADDR_EXP 23
2981: PUSH
2982: LD_EXP 23
2986: PUSH
2987: LD_VAR 0 1
2991: DIFF
2992: ST_TO_ADDR
// if un in al_force then
2993: LD_VAR 0 1
2997: PUSH
2998: LD_EXP 38
3002: IN
3003: IFFALSE 3021
// al_force := al_force diff un ;
3005: LD_ADDR_EXP 38
3009: PUSH
3010: LD_EXP 38
3014: PUSH
3015: LD_VAR 0 1
3019: DIFF
3020: ST_TO_ADDR
// end ;
3021: PPOPN 1
3023: END
// on BuildingComplete ( b ) do var i ;
3024: LD_INT 0
3026: PPUSH
// begin if GetSide ( b ) = 8 then
3027: LD_VAR 0 1
3031: PPUSH
3032: CALL_OW 255
3036: PUSH
3037: LD_INT 8
3039: EQUAL
3040: IFFALSE 3080
// for i = 1 to 4 do
3042: LD_ADDR_VAR 0 2
3046: PUSH
3047: DOUBLE
3048: LD_INT 1
3050: DEC
3051: ST_TO_ADDR
3052: LD_INT 4
3054: PUSH
3055: FOR_TO
3056: IFFALSE 3078
// legion_blist := Delete ( legion_blist , 1 ) ;
3058: LD_ADDR_EXP 34
3062: PUSH
3063: LD_EXP 34
3067: PPUSH
3068: LD_INT 1
3070: PPUSH
3071: CALL_OW 3
3075: ST_TO_ADDR
3076: GO 3055
3078: POP
3079: POP
// if GetSide ( b ) = 3 then
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 255
3089: PUSH
3090: LD_INT 3
3092: EQUAL
3093: IFFALSE 3133
// for i = 1 to 4 do
3095: LD_ADDR_VAR 0 2
3099: PUSH
3100: DOUBLE
3101: LD_INT 1
3103: DEC
3104: ST_TO_ADDR
3105: LD_INT 4
3107: PUSH
3108: FOR_TO
3109: IFFALSE 3131
// ru_blist := Delete ( ru_blist , 1 ) ;
3111: LD_ADDR_EXP 26
3115: PUSH
3116: LD_EXP 26
3120: PPUSH
3121: LD_INT 1
3123: PPUSH
3124: CALL_OW 3
3128: ST_TO_ADDR
3129: GO 3108
3131: POP
3132: POP
// end ;
3133: PPOPN 2
3135: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3136: LD_VAR 0 1
3140: PPUSH
3141: CALL_OW 264
3145: PUSH
3146: LD_INT 51
3148: PUSH
3149: LD_INT 48
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: IN
3156: NOT
3157: IFFALSE 3205
// begin if GetSide ( veh ) = 3 then
3159: LD_VAR 0 1
3163: PPUSH
3164: CALL_OW 255
3168: PUSH
3169: LD_INT 3
3171: EQUAL
3172: IFFALSE 3205
// begin ComMoveXY ( veh , 149 , 8 ) ;
3174: LD_VAR 0 1
3178: PPUSH
3179: LD_INT 149
3181: PPUSH
3182: LD_INT 8
3184: PPUSH
3185: CALL_OW 111
// ru_force := ru_force ^ veh ;
3189: LD_ADDR_EXP 23
3193: PUSH
3194: LD_EXP 23
3198: PUSH
3199: LD_VAR 0 1
3203: ADD
3204: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3205: LD_VAR 0 1
3209: PPUSH
3210: CALL_OW 264
3214: PUSH
3215: LD_INT 32
3217: PUSH
3218: LD_INT 31
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: IN
3225: NOT
3226: IFFALSE 3259
// begin if GetSide ( veh ) = 8 then
3228: LD_VAR 0 1
3232: PPUSH
3233: CALL_OW 255
3237: PUSH
3238: LD_INT 8
3240: EQUAL
3241: IFFALSE 3259
// legion_force := legion_force ^ veh ;
3243: LD_ADDR_EXP 31
3247: PUSH
3248: LD_EXP 31
3252: PUSH
3253: LD_VAR 0 1
3257: ADD
3258: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3259: LD_VAR 0 1
3263: PPUSH
3264: CALL_OW 255
3268: PUSH
3269: LD_INT 7
3271: EQUAL
3272: PUSH
3273: LD_OWVAR 2
3277: PUSH
3278: LD_INT 7
3280: NONEQUAL
3281: AND
3282: IFFALSE 3300
// al_force := al_force ^ veh ;
3284: LD_ADDR_EXP 38
3288: PUSH
3289: LD_EXP 38
3293: PUSH
3294: LD_VAR 0 1
3298: ADD
3299: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3300: LD_VAR 0 1
3304: PPUSH
3305: CALL_OW 255
3309: PUSH
3310: LD_OWVAR 2
3314: EQUAL
3315: IFFALSE 3331
// veh_counter := veh_counter + 1 ;
3317: LD_ADDR_EXP 16
3321: PUSH
3322: LD_EXP 16
3326: PUSH
3327: LD_INT 1
3329: PLUS
3330: ST_TO_ADDR
// end ;
3331: PPOPN 2
3333: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3334: LD_VAR 0 1
3338: PPUSH
3339: CALL_OW 255
3343: PUSH
3344: LD_OWVAR 2
3348: NONEQUAL
3349: IFFALSE 3365
// sib_contamin_counter := sib_contamin_counter + 1 ;
3351: LD_ADDR_EXP 18
3355: PUSH
3356: LD_EXP 18
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: ST_TO_ADDR
// end ;
3365: PPOPN 3
3367: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 255
3377: PUSH
3378: LD_OWVAR 2
3382: EQUAL
3383: IFFALSE 3399
// tech_counter := tech_counter + 1 ;
3385: LD_ADDR_EXP 17
3389: PUSH
3390: LD_EXP 17
3394: PUSH
3395: LD_INT 1
3397: PLUS
3398: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3399: LD_VAR 0 1
3403: PUSH
3404: LD_INT 53
3406: EQUAL
3407: PUSH
3408: LD_OWVAR 2
3412: PUSH
3413: LD_INT 1
3415: EQUAL
3416: AND
3417: IFFALSE 3432
// SetTech ( 80 , 1 , state_researched ) ;
3419: LD_INT 80
3421: PPUSH
3422: LD_INT 1
3424: PPUSH
3425: LD_INT 2
3427: PPUSH
3428: CALL_OW 322
// end ;
3432: PPOPN 2
3434: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3435: LD_INT 25
3437: PUSH
3438: LD_INT 12
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: PUSH
3450: LD_INT 9
3452: LESS
3453: IFFALSE 3495
3455: GO 3457
3457: DISABLE
3458: LD_INT 0
3460: PPUSH
// begin enable ;
3461: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3462: LD_ADDR_VAR 0 1
3466: PUSH
3467: LD_INT 25
3469: PUSH
3470: LD_INT 12
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PPUSH
3477: CALL_OW 69
3481: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3482: LD_INT 8
3484: PUSH
3485: LD_VAR 0 1
3489: MINUS
3490: PPUSH
3491: CALL 1890 0 1
// end ;
3495: PPOPN 1
3497: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3498: LD_VAR 0 1
3502: PPUSH
3503: LD_VAR 0 2
3507: PPUSH
3508: LD_VAR 0 3
3512: PPUSH
3513: CALL 29567 0 3
// end ;
3517: PPOPN 3
3519: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3520: LD_VAR 0 1
3524: PPUSH
3525: CALL 29575 0 1
// end ; end_of_file
3529: PPOPN 1
3531: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3532: LD_INT 0
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
3538: PPUSH
3539: PPUSH
3540: PPUSH
3541: PPUSH
3542: PPUSH
3543: PPUSH
3544: PPUSH
// uc_side := 3 ;
3545: LD_ADDR_OWVAR 20
3549: PUSH
3550: LD_INT 3
3552: ST_TO_ADDR
// uc_nation := nation_russian ;
3553: LD_ADDR_OWVAR 21
3557: PUSH
3558: LD_INT 3
3560: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3561: LD_ADDR_VAR 0 4
3565: PUSH
3566: LD_INT 22
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 30
3578: PUSH
3579: LD_INT 1
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PPUSH
3590: CALL_OW 69
3594: PUSH
3595: LD_INT 1
3597: ARRAY
3598: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_INT 22
3606: PUSH
3607: LD_INT 3
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 30
3616: PUSH
3617: LD_INT 3
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 69
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3637: LD_ADDR_VAR 0 6
3641: PUSH
3642: LD_INT 22
3644: PUSH
3645: LD_INT 3
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: LD_INT 30
3654: PUSH
3655: LD_INT 34
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PPUSH
3666: CALL_OW 69
3670: PUSH
3671: LD_INT 1
3673: ARRAY
3674: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3675: LD_ADDR_VAR 0 8
3679: PUSH
3680: LD_INT 22
3682: PUSH
3683: LD_INT 3
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PUSH
3690: LD_INT 30
3692: PUSH
3693: LD_INT 33
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PPUSH
3704: CALL_OW 69
3708: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3709: LD_ADDR_VAR 0 7
3713: PUSH
3714: LD_INT 22
3716: PUSH
3717: LD_INT 3
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_INT 30
3726: PUSH
3727: LD_INT 5
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PPUSH
3738: CALL_OW 69
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: ST_TO_ADDR
// ru_blist := [ ] ;
3747: LD_ADDR_EXP 26
3751: PUSH
3752: EMPTY
3753: ST_TO_ADDR
// ru_vlist := [ ] ;
3754: LD_ADDR_EXP 27
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3761: LD_ADDR_EXP 30
3765: PUSH
3766: LD_INT 183
3768: PUSH
3769: LD_INT 62
3771: PUSH
3772: LD_INT 147
3774: PUSH
3775: LD_INT 44
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3784: LD_INT 30
3786: PUSH
3787: LD_INT 34
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 1
3810: ARRAY
3811: PPUSH
3812: LD_EXP 30
3816: PUSH
3817: LD_INT 2
3819: ARRAY
3820: PPUSH
3821: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3825: LD_ADDR_EXP 28
3829: PUSH
3830: LD_INT 4
3832: PUSH
3833: LD_INT 5
3835: PUSH
3836: LD_INT 6
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_OWVAR 67
3848: ARRAY
3849: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3850: LD_VAR 0 4
3854: PPUSH
3855: CALL_OW 274
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 3000
3865: PPUSH
3866: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3870: LD_VAR 0 4
3874: PPUSH
3875: CALL_OW 274
3879: PPUSH
3880: LD_INT 2
3882: PPUSH
3883: LD_INT 300
3885: PPUSH
3886: CALL_OW 277
// hc_gallery :=  ;
3890: LD_ADDR_OWVAR 33
3894: PUSH
3895: LD_STRING 
3897: ST_TO_ADDR
// hc_name :=  ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING 
3905: ST_TO_ADDR
// hc_importance := 0 ;
3906: LD_ADDR_OWVAR 32
3910: PUSH
3911: LD_INT 0
3913: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3914: LD_ADDR_EXP 24
3918: PUSH
3919: LD_INT 5
3921: PUSH
3922: LD_INT 6
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: LIST
3932: PUSH
3933: LD_OWVAR 67
3937: ARRAY
3938: ST_TO_ADDR
// for i = 1 to 6 do
3939: LD_ADDR_VAR 0 2
3943: PUSH
3944: DOUBLE
3945: LD_INT 1
3947: DEC
3948: ST_TO_ADDR
3949: LD_INT 6
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4111
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 9
3960: PPUSH
3961: LD_EXP 24
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 3
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3980: LD_VAR 0 3
3984: PPUSH
3985: LD_VAR 0 7
3989: PPUSH
3990: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3994: LD_INT 0
3996: PPUSH
3997: LD_INT 4
3999: PPUSH
4000: LD_EXP 24
4004: PPUSH
4005: CALL_OW 380
// un := CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4019: LD_VAR 0 3
4023: PPUSH
4024: LD_INT 24
4026: PPUSH
4027: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4031: LD_INT 0
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: LD_EXP 24
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4056: LD_VAR 0 3
4060: PPUSH
4061: LD_VAR 0 5
4065: PPUSH
4066: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4070: LD_INT 0
4072: PPUSH
4073: LD_INT 2
4075: PPUSH
4076: LD_EXP 24
4080: PPUSH
4081: CALL_OW 380
// un := CreateHuman ;
4085: LD_ADDR_VAR 0 3
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4095: LD_VAR 0 3
4099: PPUSH
4100: LD_VAR 0 4
4104: PPUSH
4105: CALL_OW 52
// end ;
4109: GO 3952
4111: POP
4112: POP
// russian_prepared := true ;
4113: LD_ADDR_EXP 2
4117: PUSH
4118: LD_INT 1
4120: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4121: LD_VAR 0 5
4125: PPUSH
4126: LD_INT 21
4128: PPUSH
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 3
4134: PPUSH
4135: LD_INT 51
4137: PPUSH
4138: CALL_OW 125
// end ;
4142: LD_VAR 0 1
4146: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4147: LD_INT 22
4149: PUSH
4150: LD_INT 3
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PPUSH
4157: CALL_OW 69
4161: PUSH
4162: LD_INT 0
4164: GREATER
4165: PUSH
4166: LD_EXP 2
4170: AND
4171: IFFALSE 6634
4173: GO 4175
4175: DISABLE
4176: LD_INT 0
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
4189: PPUSH
4190: PPUSH
4191: PPUSH
4192: PPUSH
4193: PPUSH
4194: PPUSH
// begin enable ;
4195: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4196: LD_ADDR_VAR 0 1
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: LD_INT 3
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: PUSH
4211: LD_INT 30
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PPUSH
4225: CALL_OW 69
4229: PUSH
4230: LD_INT 1
4232: ARRAY
4233: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4234: LD_ADDR_VAR 0 2
4238: PUSH
4239: LD_INT 22
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 3
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 69
4267: PUSH
4268: LD_INT 1
4270: ARRAY
4271: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4272: LD_ADDR_VAR 0 3
4276: PUSH
4277: LD_INT 22
4279: PUSH
4280: LD_INT 3
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 30
4289: PUSH
4290: LD_INT 34
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: PPUSH
4301: CALL_OW 69
4305: PUSH
4306: LD_INT 1
4308: ARRAY
4309: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4310: LD_ADDR_VAR 0 4
4314: PUSH
4315: LD_INT 22
4317: PUSH
4318: LD_INT 3
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 30
4327: PUSH
4328: LD_INT 33
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4344: LD_ADDR_VAR 0 8
4348: PUSH
4349: LD_INT 22
4351: PUSH
4352: LD_INT 3
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 30
4361: PUSH
4362: LD_INT 5
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PPUSH
4373: CALL_OW 69
4377: PUSH
4378: LD_INT 1
4380: ARRAY
4381: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4382: LD_ADDR_VAR 0 5
4386: PUSH
4387: LD_INT 22
4389: PUSH
4390: LD_INT 3
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 21
4399: PUSH
4400: LD_INT 3
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PPUSH
4411: CALL_OW 69
4415: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 6
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4450: LD_ADDR_VAR 0 7
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 21
4467: PUSH
4468: LD_INT 1
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 69
4483: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4484: LD_ADDR_VAR 0 9
4488: PUSH
4489: LD_VAR 0 7
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 2
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4509: LD_ADDR_VAR 0 10
4513: PUSH
4514: LD_VAR 0 7
4518: PPUSH
4519: LD_INT 25
4521: PUSH
4522: LD_INT 3
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PPUSH
4529: CALL_OW 72
4533: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4534: LD_ADDR_VAR 0 11
4538: PUSH
4539: LD_VAR 0 7
4543: PPUSH
4544: LD_INT 25
4546: PUSH
4547: LD_INT 4
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 72
4558: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4559: LD_INT 22
4561: PUSH
4562: LD_INT 3
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 34
4571: PUSH
4572: LD_INT 51
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PPUSH
4583: CALL_OW 69
4587: PUSH
4588: LD_INT 0
4590: GREATER
4591: PUSH
4592: LD_EXP 25
4596: PUSH
4597: LD_INT 0
4599: EQUAL
4600: AND
4601: IFFALSE 4641
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4603: LD_ADDR_EXP 25
4607: PUSH
4608: LD_INT 22
4610: PUSH
4611: LD_INT 3
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: PUSH
4618: LD_INT 34
4620: PUSH
4621: LD_INT 51
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PPUSH
4632: CALL_OW 69
4636: PUSH
4637: LD_INT 1
4639: ARRAY
4640: ST_TO_ADDR
// if ru_cargo then
4641: LD_EXP 25
4645: IFFALSE 4943
// begin if IsInArea ( ru_cargo , ru_base ) then
4647: LD_EXP 25
4651: PPUSH
4652: LD_INT 9
4654: PPUSH
4655: CALL_OW 308
4659: IFFALSE 4738
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4661: LD_EXP 25
4665: PPUSH
4666: LD_INT 1
4668: PPUSH
4669: CALL_OW 289
4673: PUSH
4674: LD_INT 0
4676: EQUAL
4677: IFFALSE 4695
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4679: LD_EXP 25
4683: PPUSH
4684: LD_VAR 0 3
4688: PPUSH
4689: CALL_OW 120
4693: GO 4736
// if not HasTask ( ru_cargo ) then
4695: LD_EXP 25
4699: PPUSH
4700: CALL_OW 314
4704: NOT
4705: IFFALSE 4736
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4707: LD_EXP 25
4711: PPUSH
4712: LD_VAR 0 1
4716: PPUSH
4717: CALL_OW 250
4721: PPUSH
4722: LD_VAR 0 1
4726: PPUSH
4727: CALL_OW 251
4731: PPUSH
4732: CALL_OW 111
// end else
4736: GO 4943
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4738: LD_EXP 25
4742: PPUSH
4743: CALL_OW 314
4747: NOT
4748: PUSH
4749: LD_EXP 25
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: CALL_OW 289
4761: PUSH
4762: LD_INT 100
4764: LESS
4765: AND
4766: IFFALSE 4832
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4768: LD_ADDR_VAR 0 16
4772: PUSH
4773: LD_INT 11
4775: PPUSH
4776: CALL_OW 435
4780: ST_TO_ADDR
// if cr > 0 then
4781: LD_VAR 0 16
4785: PUSH
4786: LD_INT 0
4788: GREATER
4789: IFFALSE 4820
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4791: LD_EXP 25
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_VAR 0 16
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: CALL_OW 117
4818: GO 4832
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4820: LD_EXP 25
4824: PPUSH
4825: LD_INT 11
4827: PPUSH
4828: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4832: LD_EXP 25
4836: PPUSH
4837: CALL_OW 314
4841: NOT
4842: PUSH
4843: LD_EXP 25
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL_OW 308
4855: NOT
4856: AND
4857: PUSH
4858: LD_EXP 25
4862: PPUSH
4863: LD_INT 1
4865: PPUSH
4866: CALL_OW 289
4870: PUSH
4871: LD_INT 100
4873: EQUAL
4874: AND
4875: IFFALSE 4889
// ComMoveToArea ( ru_cargo , cargoa ) ;
4877: LD_EXP 25
4881: PPUSH
4882: LD_INT 10
4884: PPUSH
4885: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4889: LD_EXP 25
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 308
4901: PUSH
4902: LD_VAR 0 8
4906: AND
4907: IFFALSE 4943
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4909: LD_VAR 0 7
4913: PPUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 9
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 72
4928: PUSH
4929: LD_INT 1
4931: ARRAY
4932: PPUSH
4933: LD_INT 139
4935: PPUSH
4936: LD_INT 24
4938: PPUSH
4939: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4943: LD_EXP 25
4947: PUSH
4948: LD_INT 0
4950: EQUAL
4951: PUSH
4952: LD_VAR 0 2
4956: AND
4957: PUSH
4958: LD_VAR 0 2
4962: PPUSH
4963: CALL_OW 461
4967: PUSH
4968: LD_INT 2
4970: EQUAL
4971: AND
4972: IFFALSE 4995
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4974: LD_VAR 0 2
4978: PPUSH
4979: LD_INT 21
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: LD_INT 3
4987: PPUSH
4988: LD_INT 51
4990: PPUSH
4991: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4995: LD_VAR 0 7
4999: PPUSH
5000: LD_INT 25
5002: PUSH
5003: LD_INT 9
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PPUSH
5010: CALL_OW 72
5014: IFFALSE 5078
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5016: LD_VAR 0 7
5020: PPUSH
5021: LD_INT 25
5023: PUSH
5024: LD_INT 9
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PPUSH
5031: CALL_OW 72
5035: PPUSH
5036: LD_INT 22
5038: PUSH
5039: LD_OWVAR 2
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 3
5050: PUSH
5051: LD_INT 21
5053: PUSH
5054: LD_INT 3
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PPUSH
5069: CALL_OW 69
5073: PPUSH
5074: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5078: LD_VAR 0 2
5082: PUSH
5083: LD_EXP 27
5087: PUSH
5088: LD_INT 0
5090: GREATER
5091: AND
5092: IFFALSE 5192
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5094: LD_VAR 0 2
5098: PPUSH
5099: CALL_OW 461
5103: PUSH
5104: LD_INT 2
5106: EQUAL
5107: IFFALSE 5192
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5109: LD_VAR 0 2
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 1
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 2
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 3
5139: ARRAY
5140: PPUSH
5141: LD_EXP 27
5145: PUSH
5146: LD_INT 4
5148: ARRAY
5149: PPUSH
5150: CALL_OW 125
// for i = 1 to 4 do
5154: LD_ADDR_VAR 0 12
5158: PUSH
5159: DOUBLE
5160: LD_INT 1
5162: DEC
5163: ST_TO_ADDR
5164: LD_INT 4
5166: PUSH
5167: FOR_TO
5168: IFFALSE 5190
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5170: LD_ADDR_EXP 27
5174: PUSH
5175: LD_EXP 27
5179: PPUSH
5180: LD_INT 1
5182: PPUSH
5183: CALL_OW 3
5187: ST_TO_ADDR
5188: GO 5167
5190: POP
5191: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5192: LD_INT 24
5194: PPUSH
5195: CALL_OW 461
5199: PUSH
5200: LD_INT 2
5202: EQUAL
5203: PUSH
5204: LD_EXP 4
5208: AND
5209: IFFALSE 5237
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5211: LD_INT 25
5213: PPUSH
5214: LD_INT 3
5216: PPUSH
5217: CALL_OW 321
5221: PUSH
5222: LD_INT 1
5224: EQUAL
5225: IFFALSE 5237
// ComResearch ( ru_lab , tech_sibfiss ) ;
5227: LD_INT 24
5229: PPUSH
5230: LD_INT 25
5232: PPUSH
5233: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5237: LD_INT 25
5239: PPUSH
5240: LD_INT 3
5242: PPUSH
5243: CALL_OW 321
5247: PUSH
5248: LD_INT 2
5250: EQUAL
5251: PUSH
5252: LD_OWVAR 1
5256: PUSH
5257: LD_INT 10500
5259: MOD
5260: PUSH
5261: LD_INT 0
5263: EQUAL
5264: AND
5265: IFFALSE 5303
// if BuildingStatus ( ru_factory ) = bs_idle then
5267: LD_VAR 0 2
5271: PPUSH
5272: CALL_OW 461
5276: PUSH
5277: LD_INT 2
5279: EQUAL
5280: IFFALSE 5303
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5282: LD_VAR 0 2
5286: PPUSH
5287: LD_INT 23
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: LD_INT 3
5295: PPUSH
5296: LD_INT 48
5298: PPUSH
5299: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5303: LD_INT 22
5305: PUSH
5306: LD_INT 3
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: PUSH
5313: LD_INT 34
5315: PUSH
5316: LD_INT 48
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: PUSH
5332: LD_INT 0
5334: GREATER
5335: IFFALSE 5709
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5337: LD_ADDR_VAR 0 17
5341: PUSH
5342: LD_INT 22
5344: PUSH
5345: LD_INT 3
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: PUSH
5352: LD_INT 34
5354: PUSH
5355: LD_INT 48
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PPUSH
5366: CALL_OW 69
5370: PUSH
5371: LD_INT 1
5373: ARRAY
5374: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5375: LD_VAR 0 17
5379: PPUSH
5380: LD_INT 9
5382: PPUSH
5383: CALL_OW 308
5387: IFFALSE 5405
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5389: LD_VAR 0 17
5393: PPUSH
5394: LD_VAR 0 3
5398: PPUSH
5399: CALL_OW 120
5403: GO 5709
// if not HasTask ( sib_bomb ) then
5405: LD_VAR 0 17
5409: PPUSH
5410: CALL_OW 314
5414: NOT
5415: IFFALSE 5709
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5417: LD_INT 22
5419: PUSH
5420: LD_OWVAR 2
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 1
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 256
5456: PUSH
5457: LD_INT 250
5459: GREATER
5460: IFFALSE 5553
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5462: LD_VAR 0 17
5466: PPUSH
5467: LD_INT 22
5469: PUSH
5470: LD_OWVAR 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PPUSH
5493: CALL_OW 69
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: CALL_OW 250
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_OWVAR 2
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 30
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PPUSH
5533: CALL_OW 69
5537: PUSH
5538: LD_INT 1
5540: ARRAY
5541: PPUSH
5542: CALL_OW 251
5546: PPUSH
5547: CALL_OW 116
5551: GO 5709
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5553: LD_INT 22
5555: PUSH
5556: LD_OWVAR 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 21
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL_OW 69
5583: PUSH
5584: LD_INT 0
5586: GREATER
5587: IFFALSE 5680
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5589: LD_VAR 0 17
5593: PPUSH
5594: LD_INT 22
5596: PUSH
5597: LD_OWVAR 2
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 21
5608: PUSH
5609: LD_INT 3
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: PUSH
5625: LD_INT 1
5627: ARRAY
5628: PPUSH
5629: CALL_OW 250
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_OWVAR 2
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 21
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PPUSH
5660: CALL_OW 69
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 251
5673: PPUSH
5674: CALL_OW 116
5678: GO 5709
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5680: LD_VAR 0 17
5684: PPUSH
5685: LD_EXP 10
5689: PPUSH
5690: CALL_OW 250
5694: PPUSH
5695: LD_EXP 10
5699: PPUSH
5700: CALL_OW 251
5704: PPUSH
5705: CALL_OW 116
// end ; if ru_can_attack then
5709: LD_EXP 3
5713: IFFALSE 5861
// if ru_time > 0 0$00 then
5715: LD_EXP 29
5719: PUSH
5720: LD_INT 0
5722: GREATER
5723: IFFALSE 5741
// ru_time := ru_time - 0 0$01 else
5725: LD_ADDR_EXP 29
5729: PUSH
5730: LD_EXP 29
5734: PUSH
5735: LD_INT 35
5737: MINUS
5738: ST_TO_ADDR
5739: GO 5861
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5741: LD_ADDR_EXP 29
5745: PUSH
5746: LD_INT 20265
5748: PPUSH
5749: LD_INT 30765
5751: PPUSH
5752: CALL_OW 12
5756: ST_TO_ADDR
// for i = 1 to ru_amount do
5757: LD_ADDR_VAR 0 12
5761: PUSH
5762: DOUBLE
5763: LD_INT 1
5765: DEC
5766: ST_TO_ADDR
5767: LD_EXP 28
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5859
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5775: LD_ADDR_EXP 27
5779: PUSH
5780: LD_EXP 27
5784: PUSH
5785: LD_INT 23
5787: ADD
5788: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5789: LD_ADDR_EXP 27
5793: PUSH
5794: LD_EXP 27
5798: PUSH
5799: LD_INT 3
5801: ADD
5802: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5803: LD_ADDR_EXP 27
5807: PUSH
5808: LD_EXP 27
5812: PUSH
5813: LD_INT 3
5815: ADD
5816: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5817: LD_ADDR_EXP 27
5821: PUSH
5822: LD_EXP 27
5826: PUSH
5827: LD_INT 46
5829: PUSH
5830: LD_INT 45
5832: PUSH
5833: LD_INT 47
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_INT 1
5843: PPUSH
5844: LD_INT 2
5846: PPUSH
5847: LD_INT 3
5849: PPUSH
5850: CALL_OW 14
5854: ARRAY
5855: ADD
5856: ST_TO_ADDR
// end ;
5857: GO 5772
5859: POP
5860: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5861: LD_VAR 0 4
5865: PPUSH
5866: LD_INT 35
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 72
5880: PUSH
5881: LD_INT 0
5883: GREATER
5884: IFFALSE 5932
// if BuildingStatus ( ru_factory ) = bs_idle then
5886: LD_VAR 0 2
5890: PPUSH
5891: CALL_OW 461
5895: PUSH
5896: LD_INT 2
5898: EQUAL
5899: IFFALSE 5932
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5901: LD_VAR 0 4
5905: PPUSH
5906: LD_INT 35
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PPUSH
5916: CALL_OW 72
5920: PUSH
5921: LD_INT 1
5923: ARRAY
5924: PPUSH
5925: LD_INT 47
5927: PPUSH
5928: CALL_OW 148
// if ru_force = ru_amount then
5932: LD_EXP 23
5936: PUSH
5937: LD_EXP 28
5941: EQUAL
5942: IFFALSE 6074
// begin for i = 1 to ru_force do
5944: LD_ADDR_VAR 0 12
5948: PUSH
5949: DOUBLE
5950: LD_INT 1
5952: DEC
5953: ST_TO_ADDR
5954: LD_EXP 23
5958: PUSH
5959: FOR_TO
5960: IFFALSE 6070
// if IsInArea ( ru_force [ i ] , ru_base ) then
5962: LD_EXP 23
5966: PUSH
5967: LD_VAR 0 12
5971: ARRAY
5972: PPUSH
5973: LD_INT 9
5975: PPUSH
5976: CALL_OW 308
5980: IFFALSE 6004
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5982: LD_EXP 23
5986: PUSH
5987: LD_VAR 0 12
5991: ARRAY
5992: PPUSH
5993: LD_VAR 0 3
5997: PPUSH
5998: CALL_OW 120
6002: GO 6068
// if not HasTask ( ru_force [ i ] ) then
6004: LD_EXP 23
6008: PUSH
6009: LD_VAR 0 12
6013: ARRAY
6014: PPUSH
6015: CALL_OW 314
6019: NOT
6020: IFFALSE 6068
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6022: LD_EXP 23
6026: PUSH
6027: LD_VAR 0 12
6031: ARRAY
6032: PPUSH
6033: LD_INT 81
6035: PUSH
6036: LD_INT 3
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 69
6047: PPUSH
6048: LD_EXP 23
6052: PUSH
6053: LD_VAR 0 12
6057: ARRAY
6058: PPUSH
6059: CALL_OW 74
6063: PPUSH
6064: CALL_OW 115
6068: GO 5959
6070: POP
6071: POP
// end else
6072: GO 6224
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6074: LD_EXP 23
6078: PPUSH
6079: LD_INT 3
6081: PUSH
6082: LD_INT 95
6084: PUSH
6085: LD_INT 18
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PPUSH
6096: CALL_OW 72
6100: PUSH
6101: LD_INT 0
6103: GREATER
6104: IFFALSE 6224
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6106: LD_ADDR_VAR 0 13
6110: PUSH
6111: LD_EXP 23
6115: PPUSH
6116: LD_INT 3
6118: PUSH
6119: LD_INT 95
6121: PUSH
6122: LD_INT 18
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: PPUSH
6133: CALL_OW 72
6137: ST_TO_ADDR
// for i = 1 to tmp do
6138: LD_ADDR_VAR 0 12
6142: PUSH
6143: DOUBLE
6144: LD_INT 1
6146: DEC
6147: ST_TO_ADDR
6148: LD_VAR 0 13
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6222
// if not HasTask ( tmp [ i ] ) then
6156: LD_VAR 0 13
6160: PUSH
6161: LD_VAR 0 12
6165: ARRAY
6166: PPUSH
6167: CALL_OW 314
6171: NOT
6172: IFFALSE 6220
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6174: LD_EXP 23
6178: PUSH
6179: LD_VAR 0 12
6183: ARRAY
6184: PPUSH
6185: LD_INT 81
6187: PUSH
6188: LD_INT 3
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 69
6199: PPUSH
6200: LD_EXP 23
6204: PUSH
6205: LD_VAR 0 12
6209: ARRAY
6210: PPUSH
6211: CALL_OW 74
6215: PPUSH
6216: CALL_OW 115
6220: GO 6153
6222: POP
6223: POP
// end ; if ru_engs > 0 then
6224: LD_VAR 0 9
6228: PUSH
6229: LD_INT 0
6231: GREATER
6232: IFFALSE 6634
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6234: LD_VAR 0 5
6238: PPUSH
6239: LD_INT 3
6241: PUSH
6242: LD_INT 24
6244: PUSH
6245: LD_INT 1000
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: LD_INT 0
6263: GREATER
6264: IFFALSE 6419
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6266: LD_ADDR_VAR 0 14
6270: PUSH
6271: LD_VAR 0 5
6275: PPUSH
6276: LD_INT 3
6278: PUSH
6279: LD_INT 24
6281: PUSH
6282: LD_INT 1000
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: CALL_OW 72
6297: ST_TO_ADDR
// for i = 1 to ru_engs do
6298: LD_ADDR_VAR 0 12
6302: PUSH
6303: DOUBLE
6304: LD_INT 1
6306: DEC
6307: ST_TO_ADDR
6308: LD_VAR 0 9
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6415
// begin if IsInUnit ( ru_engs [ i ] ) then
6316: LD_VAR 0 9
6320: PUSH
6321: LD_VAR 0 12
6325: ARRAY
6326: PPUSH
6327: CALL_OW 310
6331: IFFALSE 6350
// ComExitBuilding ( ru_engs [ i ] ) else
6333: LD_VAR 0 9
6337: PUSH
6338: LD_VAR 0 12
6342: ARRAY
6343: PPUSH
6344: CALL_OW 122
6348: GO 6413
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 256
6382: PUSH
6383: LD_INT 600
6385: GREATER
6386: AND
6387: IFFALSE 6413
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6389: LD_VAR 0 9
6393: PUSH
6394: LD_VAR 0 12
6398: ARRAY
6399: PPUSH
6400: LD_VAR 0 14
6404: PUSH
6405: LD_INT 1
6407: ARRAY
6408: PPUSH
6409: CALL_OW 130
// end ;
6413: GO 6313
6415: POP
6416: POP
// end else
6417: GO 6634
// begin if ru_blist = 0 then
6419: LD_EXP 26
6423: PUSH
6424: LD_INT 0
6426: EQUAL
6427: IFFALSE 6509
// begin for i = 1 to ru_engs do
6429: LD_ADDR_VAR 0 12
6433: PUSH
6434: DOUBLE
6435: LD_INT 1
6437: DEC
6438: ST_TO_ADDR
6439: LD_VAR 0 9
6443: PUSH
6444: FOR_TO
6445: IFFALSE 6505
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 314
6462: NOT
6463: PUSH
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 310
6479: NOT
6480: AND
6481: IFFALSE 6503
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6483: LD_VAR 0 9
6487: PUSH
6488: LD_VAR 0 12
6492: ARRAY
6493: PPUSH
6494: LD_VAR 0 1
6498: PPUSH
6499: CALL_OW 120
6503: GO 6444
6505: POP
6506: POP
// end else
6507: GO 6634
// begin for i = 1 to ru_engs do
6509: LD_ADDR_VAR 0 12
6513: PUSH
6514: DOUBLE
6515: LD_INT 1
6517: DEC
6518: ST_TO_ADDR
6519: LD_VAR 0 9
6523: PUSH
6524: FOR_TO
6525: IFFALSE 6632
// begin if IsInUnit ( ru_engs [ i ] ) then
6527: LD_VAR 0 9
6531: PUSH
6532: LD_VAR 0 12
6536: ARRAY
6537: PPUSH
6538: CALL_OW 310
6542: IFFALSE 6561
// ComExitBuilding ( ru_engs [ i ] ) else
6544: LD_VAR 0 9
6548: PUSH
6549: LD_VAR 0 12
6553: ARRAY
6554: PPUSH
6555: CALL_OW 122
6559: GO 6630
// if not HasTask ( ru_engs [ i ] ) then
6561: LD_VAR 0 9
6565: PUSH
6566: LD_VAR 0 12
6570: ARRAY
6571: PPUSH
6572: CALL_OW 314
6576: NOT
6577: IFFALSE 6630
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6579: LD_VAR 0 9
6583: PUSH
6584: LD_VAR 0 12
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 1
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 2
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PPUSH
6617: LD_EXP 26
6621: PUSH
6622: LD_INT 4
6624: ARRAY
6625: PPUSH
6626: CALL_OW 145
// end ;
6630: GO 6524
6632: POP
6633: POP
// end ; end ; end ; end ;
6634: PPOPN 17
6636: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6637: LD_EXP 2
6641: PUSH
6642: LD_INT 11
6644: PPUSH
6645: CALL_OW 435
6649: PUSH
6650: LD_INT 20
6652: LESS
6653: AND
6654: IFFALSE 6717
6656: GO 6658
6658: DISABLE
// begin enable ;
6659: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6660: LD_INT 1
6662: PPUSH
6663: LD_INT 5
6665: PPUSH
6666: CALL_OW 12
6670: PPUSH
6671: LD_INT 11
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6681: LD_INT 1505
6683: PPUSH
6684: LD_INT 2100
6686: PPUSH
6687: CALL_OW 12
6691: PPUSH
6692: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6696: LD_INT 1
6698: PPUSH
6699: LD_INT 5
6701: PPUSH
6702: CALL_OW 12
6706: PPUSH
6707: LD_INT 11
6709: PPUSH
6710: LD_INT 1
6712: PPUSH
6713: CALL_OW 55
// end ;
6717: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6718: LD_EXP 4
6722: PUSH
6723: LD_INT 0
6725: EQUAL
6726: IFFALSE 6841
6728: GO 6730
6730: DISABLE
6731: LD_INT 0
6733: PPUSH
6734: PPUSH
// begin enable ;
6735: ENABLE
// i := Rand ( 0 , 100 ) ;
6736: LD_ADDR_VAR 0 1
6740: PUSH
6741: LD_INT 0
6743: PPUSH
6744: LD_INT 100
6746: PPUSH
6747: CALL_OW 12
6751: ST_TO_ADDR
// case your_side of 1 :
6752: LD_OWVAR 2
6756: PUSH
6757: LD_INT 1
6759: DOUBLE
6760: EQUAL
6761: IFTRUE 6765
6763: GO 6776
6765: POP
// tmp := 10 ; 2 :
6766: LD_ADDR_VAR 0 2
6770: PUSH
6771: LD_INT 10
6773: ST_TO_ADDR
6774: GO 6815
6776: LD_INT 2
6778: DOUBLE
6779: EQUAL
6780: IFTRUE 6784
6782: GO 6795
6784: POP
// tmp := 0 ; 7 :
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_INT 0
6792: ST_TO_ADDR
6793: GO 6815
6795: LD_INT 7
6797: DOUBLE
6798: EQUAL
6799: IFTRUE 6803
6801: GO 6814
6803: POP
// tmp := 15 ; end ;
6804: LD_ADDR_VAR 0 2
6808: PUSH
6809: LD_INT 15
6811: ST_TO_ADDR
6812: GO 6815
6814: POP
// if i < chance_to_bomb + tmp then
6815: LD_VAR 0 1
6819: PUSH
6820: LD_EXP 5
6824: PUSH
6825: LD_VAR 0 2
6829: PLUS
6830: LESS
6831: IFFALSE 6841
// ru_sib_bomb := true ;
6833: LD_ADDR_EXP 4
6837: PUSH
6838: LD_INT 1
6840: ST_TO_ADDR
// end ;
6841: PPOPN 2
6843: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6844: LD_INT 22
6846: PUSH
6847: LD_OWVAR 2
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 34
6858: PUSH
6859: LD_INT 8
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: PPUSH
6870: CALL_OW 69
6874: IFFALSE 6887
6876: GO 6878
6878: DISABLE
// begin ru_sib_bomb := true ;
6879: LD_ADDR_EXP 4
6883: PUSH
6884: LD_INT 1
6886: ST_TO_ADDR
// end ;
6887: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6888: LD_INT 22
6890: PUSH
6891: LD_INT 3
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 34
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PPUSH
6912: CALL_OW 69
6916: IFFALSE 7015
6918: GO 6920
6920: DISABLE
6921: LD_INT 0
6923: PPUSH
// begin enable ;
6924: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6925: LD_ADDR_VAR 0 1
6929: PUSH
6930: LD_INT 1
6932: PUSH
6933: LD_INT 3
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_INT 2
6945: PPUSH
6946: CALL_OW 12
6950: ARRAY
6951: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6952: LD_INT 22
6954: PUSH
6955: LD_INT 3
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: PUSH
6962: LD_INT 30
6964: PUSH
6965: LD_INT 34
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: PUSH
6981: LD_INT 1
6983: ARRAY
6984: PPUSH
6985: LD_EXP 30
6989: PUSH
6990: LD_VAR 0 1
6994: ARRAY
6995: PPUSH
6996: LD_EXP 30
7000: PUSH
7001: LD_VAR 0 1
7005: PUSH
7006: LD_INT 1
7008: PLUS
7009: ARRAY
7010: PPUSH
7011: CALL_OW 243
// end ; end_of_file
7015: PPOPN 1
7017: END
// export function RemoveLegion ; var i ; begin
7018: LD_INT 0
7020: PPUSH
7021: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_INT 22
7029: PUSH
7030: LD_INT 8
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: PUSH
7042: FOR_IN
7043: IFFALSE 7056
// RemoveUnit ( i ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: CALL_OW 64
7054: GO 7042
7056: POP
7057: POP
// end ;
7058: LD_VAR 0 1
7062: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7063: LD_INT 0
7065: PPUSH
7066: PPUSH
7067: PPUSH
7068: PPUSH
7069: PPUSH
7070: PPUSH
7071: PPUSH
7072: PPUSH
7073: PPUSH
7074: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7075: LD_ADDR_VAR 0 7
7079: PUSH
7080: LD_INT 22
7082: PUSH
7083: LD_INT 8
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: PUSH
7109: LD_INT 1
7111: ARRAY
7112: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7113: LD_ADDR_VAR 0 8
7117: PUSH
7118: LD_INT 22
7120: PUSH
7121: LD_INT 8
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 30
7130: PUSH
7131: LD_INT 3
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PPUSH
7142: CALL_OW 69
7146: PUSH
7147: LD_INT 1
7149: ARRAY
7150: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7151: LD_ADDR_VAR 0 9
7155: PUSH
7156: LD_INT 22
7158: PUSH
7159: LD_INT 8
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 2
7168: PUSH
7169: LD_INT 30
7171: PUSH
7172: LD_INT 6
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 30
7181: PUSH
7182: LD_INT 8
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 1
7205: ARRAY
7206: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7207: LD_ADDR_VAR 0 10
7211: PUSH
7212: LD_INT 22
7214: PUSH
7215: LD_INT 8
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 30
7224: PUSH
7225: LD_INT 32
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: PPUSH
7236: CALL_OW 69
7240: ST_TO_ADDR
// uc_side := 8 ;
7241: LD_ADDR_OWVAR 20
7245: PUSH
7246: LD_INT 8
7248: ST_TO_ADDR
// uc_nation := nation_arabian ;
7249: LD_ADDR_OWVAR 21
7253: PUSH
7254: LD_INT 2
7256: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7257: LD_ADDR_EXP 32
7261: PUSH
7262: LD_INT 5
7264: PUSH
7265: LD_INT 6
7267: PUSH
7268: LD_INT 7
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: PUSH
7276: LD_OWVAR 67
7280: ARRAY
7281: ST_TO_ADDR
// legion_blist := [ ] ;
7282: LD_ADDR_EXP 34
7286: PUSH
7287: EMPTY
7288: ST_TO_ADDR
// legion_vlist := [ ] ;
7289: LD_ADDR_EXP 35
7293: PUSH
7294: EMPTY
7295: ST_TO_ADDR
// legion_force := [ ] ;
7296: LD_ADDR_EXP 31
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// legion_enemy := - 1 ;
7303: LD_ADDR_EXP 36
7307: PUSH
7308: LD_INT 1
7310: NEG
7311: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7312: LD_VAR 0 7
7316: PPUSH
7317: CALL_OW 274
7321: PPUSH
7322: LD_INT 1
7324: PPUSH
7325: LD_INT 10000
7327: PPUSH
7328: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7332: LD_VAR 0 7
7336: PPUSH
7337: CALL_OW 274
7341: PPUSH
7342: LD_INT 3
7344: PPUSH
7345: LD_INT 1000
7347: PPUSH
7348: CALL_OW 277
// for i = 1 to l_towers do
7352: LD_ADDR_VAR 0 3
7356: PUSH
7357: DOUBLE
7358: LD_INT 1
7360: DEC
7361: ST_TO_ADDR
7362: LD_VAR 0 10
7366: PUSH
7367: FOR_TO
7368: IFFALSE 7417
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7370: LD_INT 0
7372: PPUSH
7373: LD_INT 1
7375: PPUSH
7376: LD_EXP 32
7380: PPUSH
7381: CALL_OW 380
// un := CreateHuman ;
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: CALL_OW 44
7394: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_VAR 0 10
7404: PUSH
7405: LD_VAR 0 3
7409: ARRAY
7410: PPUSH
7411: CALL_OW 52
// end ;
7415: GO 7367
7417: POP
7418: POP
// for i = 1 to 4 do
7419: LD_ADDR_VAR 0 3
7423: PUSH
7424: DOUBLE
7425: LD_INT 1
7427: DEC
7428: ST_TO_ADDR
7429: LD_INT 4
7431: PUSH
7432: FOR_TO
7433: IFFALSE 7526
// for p = 1 to 2 do
7435: LD_ADDR_VAR 0 6
7439: PUSH
7440: DOUBLE
7441: LD_INT 1
7443: DEC
7444: ST_TO_ADDR
7445: LD_INT 2
7447: PUSH
7448: FOR_TO
7449: IFFALSE 7522
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7451: LD_INT 0
7453: PPUSH
7454: LD_INT 8
7456: PPUSH
7457: LD_EXP 32
7461: PPUSH
7462: CALL_OW 380
// un := CreateHuman ;
7466: LD_ADDR_VAR 0 2
7470: PUSH
7471: CALL_OW 44
7475: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_INT 22
7483: PUSH
7484: LD_INT 8
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 5
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: PUSH
7510: LD_VAR 0 6
7514: ARRAY
7515: PPUSH
7516: CALL_OW 52
// end ;
7520: GO 7448
7522: POP
7523: POP
7524: GO 7432
7526: POP
7527: POP
// for i = 1 to 4 do
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: DOUBLE
7534: LD_INT 1
7536: DEC
7537: ST_TO_ADDR
7538: LD_INT 4
7540: PUSH
7541: FOR_TO
7542: IFFALSE 7585
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7544: LD_INT 0
7546: PPUSH
7547: LD_INT 4
7549: PPUSH
7550: LD_EXP 32
7554: PPUSH
7555: CALL_OW 380
// un := CreateHuman ;
7559: LD_ADDR_VAR 0 2
7563: PUSH
7564: CALL_OW 44
7568: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7569: LD_VAR 0 2
7573: PPUSH
7574: LD_VAR 0 9
7578: PPUSH
7579: CALL_OW 52
// end ;
7583: GO 7541
7585: POP
7586: POP
// for i = 1 to 6 do
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: DOUBLE
7593: LD_INT 1
7595: DEC
7596: ST_TO_ADDR
7597: LD_INT 6
7599: PUSH
7600: FOR_TO
7601: IFFALSE 7644
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7603: LD_INT 0
7605: PPUSH
7606: LD_INT 3
7608: PPUSH
7609: LD_EXP 32
7613: PPUSH
7614: CALL_OW 380
// un := CreateHuman ;
7618: LD_ADDR_VAR 0 2
7622: PUSH
7623: CALL_OW 44
7627: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7628: LD_VAR 0 2
7632: PPUSH
7633: LD_VAR 0 8
7637: PPUSH
7638: CALL_OW 52
// end ;
7642: GO 7600
7644: POP
7645: POP
// for i = 1 to 5 do
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_INT 5
7658: PUSH
7659: FOR_TO
7660: IFFALSE 7703
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7662: LD_INT 0
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: LD_EXP 32
7672: PPUSH
7673: CALL_OW 380
// un := CreateHuman ;
7677: LD_ADDR_VAR 0 2
7681: PUSH
7682: CALL_OW 44
7686: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_VAR 0 7
7696: PPUSH
7697: CALL_OW 52
// end ;
7701: GO 7659
7703: POP
7704: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7705: LD_ADDR_VAR 0 4
7709: PUSH
7710: LD_INT 199
7712: PPUSH
7713: LD_INT 134
7715: PPUSH
7716: LD_INT 216
7718: PPUSH
7719: LD_INT 141
7721: PPUSH
7722: LD_INT 6
7724: PPUSH
7725: CALL 1562 0 5
7729: ST_TO_ADDR
// p := 1 ;
7730: LD_ADDR_VAR 0 6
7734: PUSH
7735: LD_INT 1
7737: ST_TO_ADDR
// for i = 1 to 3 do
7738: LD_ADDR_VAR 0 3
7742: PUSH
7743: DOUBLE
7744: LD_INT 1
7746: DEC
7747: ST_TO_ADDR
7748: LD_INT 3
7750: PUSH
7751: FOR_TO
7752: IFFALSE 8005
// begin vc_chassis := ar_half_tracked ;
7754: LD_ADDR_OWVAR 37
7758: PUSH
7759: LD_INT 14
7761: ST_TO_ADDR
// vc_engine := engine_siberite ;
7762: LD_ADDR_OWVAR 39
7766: PUSH
7767: LD_INT 3
7769: ST_TO_ADDR
// vc_control := control_manual ;
7770: LD_ADDR_OWVAR 38
7774: PUSH
7775: LD_INT 1
7777: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7778: LD_ADDR_OWVAR 40
7782: PUSH
7783: LD_INT 31
7785: ST_TO_ADDR
// veh := CreateVehicle ;
7786: LD_ADDR_VAR 0 5
7790: PUSH
7791: CALL_OW 45
7795: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7796: LD_VAR 0 4
7800: PUSH
7801: LD_VAR 0 6
7805: ARRAY
7806: PPUSH
7807: LD_VAR 0 4
7811: PUSH
7812: LD_VAR 0 6
7816: PUSH
7817: LD_INT 1
7819: PLUS
7820: ARRAY
7821: PPUSH
7822: CALL_OW 428
7826: PUSH
7827: LD_INT 0
7829: EQUAL
7830: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7832: LD_VAR 0 5
7836: PPUSH
7837: LD_VAR 0 4
7841: PUSH
7842: LD_VAR 0 6
7846: ARRAY
7847: PPUSH
7848: LD_VAR 0 4
7852: PUSH
7853: LD_VAR 0 6
7857: PUSH
7858: LD_INT 1
7860: PLUS
7861: ARRAY
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 48
7870: GO 7960
// begin repeat p := p + 2 ;
7872: LD_ADDR_VAR 0 6
7876: PUSH
7877: LD_VAR 0 6
7881: PUSH
7882: LD_INT 2
7884: PLUS
7885: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7886: LD_VAR 0 4
7890: PUSH
7891: LD_VAR 0 6
7895: ARRAY
7896: PPUSH
7897: LD_VAR 0 4
7901: PUSH
7902: LD_VAR 0 6
7906: PUSH
7907: LD_INT 1
7909: PLUS
7910: ARRAY
7911: PPUSH
7912: CALL_OW 428
7916: PUSH
7917: LD_INT 0
7919: EQUAL
7920: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7922: LD_VAR 0 5
7926: PPUSH
7927: LD_VAR 0 4
7931: PUSH
7932: LD_VAR 0 6
7936: ARRAY
7937: PPUSH
7938: LD_VAR 0 4
7942: PUSH
7943: LD_VAR 0 6
7947: PUSH
7948: LD_INT 1
7950: PLUS
7951: ARRAY
7952: PPUSH
7953: LD_INT 0
7955: PPUSH
7956: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7960: LD_INT 0
7962: PPUSH
7963: LD_INT 3
7965: PPUSH
7966: LD_EXP 32
7970: PUSH
7971: LD_INT 1
7973: PLUS
7974: PPUSH
7975: CALL_OW 380
// un := CreateHuman ;
7979: LD_ADDR_VAR 0 2
7983: PUSH
7984: CALL_OW 44
7988: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7989: LD_VAR 0 2
7993: PPUSH
7994: LD_VAR 0 5
7998: PPUSH
7999: CALL_OW 52
// end ;
8003: GO 7751
8005: POP
8006: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
8007: LD_INT 198
8009: PPUSH
8010: LD_INT 94
8012: PPUSH
8013: LD_INT 8
8015: PPUSH
8016: LD_INT 10
8018: PPUSH
8019: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8023: LD_INT 167
8025: PPUSH
8026: LD_INT 130
8028: PPUSH
8029: LD_INT 8
8031: PPUSH
8032: LD_INT 10
8034: PPUSH
8035: CALL_OW 330
// legion_mines := [ ] ;
8039: LD_ADDR_EXP 33
8043: PUSH
8044: EMPTY
8045: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_INT 176
8053: PPUSH
8054: LD_INT 122
8056: PPUSH
8057: LD_INT 188
8059: PPUSH
8060: LD_INT 126
8062: PPUSH
8063: LD_INT 6
8065: PPUSH
8066: CALL 1562 0 5
8070: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8071: LD_ADDR_EXP 33
8075: PUSH
8076: LD_EXP 33
8080: PUSH
8081: LD_INT 197
8083: PPUSH
8084: LD_INT 91
8086: PPUSH
8087: LD_INT 205
8089: PPUSH
8090: LD_INT 96
8092: PPUSH
8093: LD_INT 4
8095: PPUSH
8096: CALL 1562 0 5
8100: ADD
8101: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8102: LD_ADDR_EXP 33
8106: PUSH
8107: LD_EXP 33
8111: PUSH
8112: LD_INT 184
8114: PPUSH
8115: LD_INT 151
8117: PPUSH
8118: LD_INT 178
8120: PPUSH
8121: LD_INT 130
8123: PPUSH
8124: LD_INT 9
8126: PPUSH
8127: CALL 1562 0 5
8131: ADD
8132: ST_TO_ADDR
// if Difficulty > 1 then
8133: LD_OWVAR 67
8137: PUSH
8138: LD_INT 1
8140: GREATER
8141: IFFALSE 8174
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8143: LD_ADDR_EXP 33
8147: PUSH
8148: LD_EXP 33
8152: PUSH
8153: LD_INT 166
8155: PPUSH
8156: LD_INT 126
8158: PPUSH
8159: LD_INT 181
8161: PPUSH
8162: LD_INT 136
8164: PPUSH
8165: LD_INT 5
8167: PPUSH
8168: CALL 1562 0 5
8172: ADD
8173: ST_TO_ADDR
// p := 1 ;
8174: LD_ADDR_VAR 0 6
8178: PUSH
8179: LD_INT 1
8181: ST_TO_ADDR
// for i = 1 to 24 do
8182: LD_ADDR_VAR 0 3
8186: PUSH
8187: DOUBLE
8188: LD_INT 1
8190: DEC
8191: ST_TO_ADDR
8192: LD_INT 24
8194: PUSH
8195: FOR_TO
8196: IFFALSE 8250
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8198: LD_EXP 33
8202: PUSH
8203: LD_VAR 0 6
8207: ARRAY
8208: PPUSH
8209: LD_EXP 33
8213: PUSH
8214: LD_VAR 0 6
8218: PUSH
8219: LD_INT 1
8221: PLUS
8222: ARRAY
8223: PPUSH
8224: LD_INT 8
8226: PPUSH
8227: LD_INT 0
8229: PPUSH
8230: CALL_OW 454
// p := p + 2 ;
8234: LD_ADDR_VAR 0 6
8238: PUSH
8239: LD_VAR 0 6
8243: PUSH
8244: LD_INT 2
8246: PLUS
8247: ST_TO_ADDR
// end ;
8248: GO 8195
8250: POP
8251: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8252: LD_ADDR_EXP 35
8256: PUSH
8257: LD_INT 13
8259: PUSH
8260: LD_INT 3
8262: PUSH
8263: LD_INT 2
8265: PUSH
8266: LD_INT 32
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: ST_TO_ADDR
// end ;
8275: LD_VAR 0 1
8279: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8280: LD_INT 22
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: PUSH
8295: LD_INT 0
8297: GREATER
8298: IFFALSE 10484
8300: GO 8302
8302: DISABLE
8303: LD_INT 0
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
8316: PPUSH
8317: PPUSH
8318: PPUSH
8319: PPUSH
8320: PPUSH
8321: PPUSH
// begin enable ;
8322: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8323: LD_ADDR_VAR 0 8
8327: PUSH
8328: LD_INT 22
8330: PUSH
8331: LD_INT 8
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 30
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: PUSH
8348: EMPTY
8349: LIST
8350: LIST
8351: PPUSH
8352: CALL_OW 69
8356: PUSH
8357: LD_INT 1
8359: ARRAY
8360: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8361: LD_ADDR_VAR 0 9
8365: PUSH
8366: LD_INT 22
8368: PUSH
8369: LD_INT 8
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: LD_INT 30
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PPUSH
8390: CALL_OW 69
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8399: LD_ADDR_VAR 0 10
8403: PUSH
8404: LD_INT 22
8406: PUSH
8407: LD_INT 8
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 2
8416: PUSH
8417: LD_INT 30
8419: PUSH
8420: LD_INT 6
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: LD_INT 30
8429: PUSH
8430: LD_INT 8
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PPUSH
8446: CALL_OW 69
8450: PUSH
8451: LD_INT 1
8453: ARRAY
8454: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8455: LD_ADDR_VAR 0 11
8459: PUSH
8460: LD_INT 22
8462: PUSH
8463: LD_INT 8
8465: PUSH
8466: EMPTY
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 30
8472: PUSH
8473: LD_INT 32
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PPUSH
8484: CALL_OW 69
8488: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8489: LD_ADDR_VAR 0 16
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 8
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 25
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8523: LD_ADDR_VAR 0 15
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 8
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PUSH
8538: LD_INT 25
8540: PUSH
8541: LD_INT 1
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PPUSH
8552: CALL_OW 69
8556: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8557: LD_ADDR_VAR 0 14
8561: PUSH
8562: LD_INT 22
8564: PUSH
8565: LD_INT 8
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: PUSH
8572: LD_INT 25
8574: PUSH
8575: LD_INT 3
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PPUSH
8586: CALL_OW 69
8590: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8591: LD_ADDR_VAR 0 13
8595: PUSH
8596: LD_INT 22
8598: PUSH
8599: LD_INT 8
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 25
8608: PUSH
8609: LD_INT 4
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PPUSH
8620: CALL_OW 69
8624: ST_TO_ADDR
// if l_eng then
8625: LD_VAR 0 16
8629: IFFALSE 9044
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8631: LD_ADDR_VAR 0 5
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 21
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8665: LD_VAR 0 5
8669: PPUSH
8670: LD_INT 3
8672: PUSH
8673: LD_INT 24
8675: PUSH
8676: LD_INT 1000
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PPUSH
8687: CALL_OW 72
8691: PUSH
8692: LD_INT 0
8694: GREATER
8695: IFFALSE 8829
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8697: LD_ADDR_VAR 0 3
8701: PUSH
8702: LD_VAR 0 5
8706: PPUSH
8707: LD_INT 3
8709: PUSH
8710: LD_INT 24
8712: PUSH
8713: LD_INT 1000
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PPUSH
8724: CALL_OW 72
8728: ST_TO_ADDR
// for i = 1 to l_eng do
8729: LD_ADDR_VAR 0 2
8733: PUSH
8734: DOUBLE
8735: LD_INT 1
8737: DEC
8738: ST_TO_ADDR
8739: LD_VAR 0 16
8743: PUSH
8744: FOR_TO
8745: IFFALSE 8825
// if IsInUnit ( l_eng [ i ] ) then
8747: LD_VAR 0 16
8751: PUSH
8752: LD_VAR 0 2
8756: ARRAY
8757: PPUSH
8758: CALL_OW 310
8762: IFFALSE 8781
// ComExitBuilding ( l_eng [ i ] ) else
8764: LD_VAR 0 16
8768: PUSH
8769: LD_VAR 0 2
8773: ARRAY
8774: PPUSH
8775: CALL_OW 122
8779: GO 8823
// if not HasTask ( l_eng [ i ] ) then
8781: LD_VAR 0 16
8785: PUSH
8786: LD_VAR 0 2
8790: ARRAY
8791: PPUSH
8792: CALL_OW 314
8796: NOT
8797: IFFALSE 8823
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8799: LD_VAR 0 16
8803: PUSH
8804: LD_VAR 0 2
8808: ARRAY
8809: PPUSH
8810: LD_VAR 0 3
8814: PUSH
8815: LD_INT 1
8817: ARRAY
8818: PPUSH
8819: CALL_OW 130
8823: GO 8744
8825: POP
8826: POP
// end else
8827: GO 9044
// begin if legion_blist > 0 then
8829: LD_EXP 34
8833: PUSH
8834: LD_INT 0
8836: GREATER
8837: IFFALSE 8966
// begin for i = 1 to l_eng do
8839: LD_ADDR_VAR 0 2
8843: PUSH
8844: DOUBLE
8845: LD_INT 1
8847: DEC
8848: ST_TO_ADDR
8849: LD_VAR 0 16
8853: PUSH
8854: FOR_TO
8855: IFFALSE 8962
// if IsInUnit ( l_eng [ i ] ) then
8857: LD_VAR 0 16
8861: PUSH
8862: LD_VAR 0 2
8866: ARRAY
8867: PPUSH
8868: CALL_OW 310
8872: IFFALSE 8891
// ComExitBuilding ( l_eng [ i ] ) else
8874: LD_VAR 0 16
8878: PUSH
8879: LD_VAR 0 2
8883: ARRAY
8884: PPUSH
8885: CALL_OW 122
8889: GO 8960
// if not HasTask ( l_eng [ i ] ) then
8891: LD_VAR 0 16
8895: PUSH
8896: LD_VAR 0 2
8900: ARRAY
8901: PPUSH
8902: CALL_OW 314
8906: NOT
8907: IFFALSE 8960
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8909: LD_VAR 0 16
8913: PUSH
8914: LD_VAR 0 2
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 1
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 2
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 3
8945: ARRAY
8946: PPUSH
8947: LD_EXP 34
8951: PUSH
8952: LD_INT 4
8954: ARRAY
8955: PPUSH
8956: CALL_OW 145
8960: GO 8854
8962: POP
8963: POP
// end else
8964: GO 9044
// for i = 1 to l_eng do
8966: LD_ADDR_VAR 0 2
8970: PUSH
8971: DOUBLE
8972: LD_INT 1
8974: DEC
8975: ST_TO_ADDR
8976: LD_VAR 0 16
8980: PUSH
8981: FOR_TO
8982: IFFALSE 9042
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8984: LD_VAR 0 16
8988: PUSH
8989: LD_VAR 0 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 310
8999: NOT
9000: PUSH
9001: LD_VAR 0 16
9005: PUSH
9006: LD_VAR 0 2
9010: ARRAY
9011: PPUSH
9012: CALL_OW 314
9016: NOT
9017: AND
9018: IFFALSE 9040
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9020: LD_VAR 0 16
9024: PUSH
9025: LD_VAR 0 2
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 8
9035: PPUSH
9036: CALL_OW 120
9040: GO 8981
9042: POP
9043: POP
// end ; end ; if l_factory then
9044: LD_VAR 0 9
9048: IFFALSE 9448
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9050: LD_INT 22
9052: PUSH
9053: LD_INT 8
9055: PUSH
9056: EMPTY
9057: LIST
9058: LIST
9059: PUSH
9060: LD_INT 33
9062: PUSH
9063: LD_INT 2
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PUSH
9070: LD_INT 3
9072: PUSH
9073: LD_INT 61
9075: PUSH
9076: EMPTY
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: PUSH
9093: LD_INT 0
9095: GREATER
9096: PUSH
9097: LD_INT 22
9099: PUSH
9100: LD_INT 8
9102: PUSH
9103: EMPTY
9104: LIST
9105: LIST
9106: PUSH
9107: LD_INT 34
9109: PUSH
9110: LD_INT 31
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PPUSH
9121: CALL_OW 69
9125: PUSH
9126: LD_INT 0
9128: GREATER
9129: AND
9130: IFFALSE 9250
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9132: LD_INT 22
9134: PUSH
9135: LD_INT 8
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: PUSH
9142: LD_INT 33
9144: PUSH
9145: LD_INT 2
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: LD_INT 61
9157: PUSH
9158: EMPTY
9159: LIST
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PUSH
9165: EMPTY
9166: LIST
9167: LIST
9168: LIST
9169: PPUSH
9170: CALL_OW 69
9174: PUSH
9175: LD_INT 1
9177: ARRAY
9178: PPUSH
9179: LD_INT 22
9181: PUSH
9182: LD_INT 8
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PUSH
9189: LD_INT 34
9191: PUSH
9192: LD_INT 31
9194: PUSH
9195: EMPTY
9196: LIST
9197: LIST
9198: PUSH
9199: EMPTY
9200: LIST
9201: LIST
9202: PPUSH
9203: CALL_OW 69
9207: PUSH
9208: LD_INT 1
9210: PPUSH
9211: LD_INT 22
9213: PUSH
9214: LD_INT 8
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: LD_INT 34
9223: PUSH
9224: LD_INT 31
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL_OW 69
9239: PPUSH
9240: CALL_OW 12
9244: ARRAY
9245: PPUSH
9246: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9250: LD_EXP 35
9254: PUSH
9255: LD_INT 0
9257: GREATER
9258: PUSH
9259: LD_VAR 0 9
9263: PPUSH
9264: CALL_OW 461
9268: PUSH
9269: LD_INT 2
9271: EQUAL
9272: AND
9273: IFFALSE 9358
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9275: LD_VAR 0 9
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 1
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 2
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 3
9305: ARRAY
9306: PPUSH
9307: LD_EXP 35
9311: PUSH
9312: LD_INT 4
9314: ARRAY
9315: PPUSH
9316: CALL_OW 125
// for i = 1 to 4 do
9320: LD_ADDR_VAR 0 2
9324: PUSH
9325: DOUBLE
9326: LD_INT 1
9328: DEC
9329: ST_TO_ADDR
9330: LD_INT 4
9332: PUSH
9333: FOR_TO
9334: IFFALSE 9356
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9336: LD_ADDR_EXP 35
9340: PUSH
9341: LD_EXP 35
9345: PPUSH
9346: LD_INT 1
9348: PPUSH
9349: CALL_OW 3
9353: ST_TO_ADDR
9354: GO 9333
9356: POP
9357: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9358: LD_VAR 0 11
9362: PPUSH
9363: LD_INT 35
9365: PUSH
9366: LD_INT 0
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: PPUSH
9373: CALL_OW 72
9377: PUSH
9378: LD_INT 0
9380: GREATER
9381: PUSH
9382: LD_VAR 0 9
9386: PPUSH
9387: CALL_OW 461
9391: PUSH
9392: LD_INT 2
9394: EQUAL
9395: AND
9396: IFFALSE 9448
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9398: LD_VAR 0 11
9402: PPUSH
9403: LD_INT 35
9405: PUSH
9406: LD_INT 0
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 72
9417: PUSH
9418: LD_INT 1
9420: ARRAY
9421: PPUSH
9422: LD_INT 28
9424: PUSH
9425: LD_INT 27
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: LD_INT 1
9434: PPUSH
9435: LD_INT 2
9437: PPUSH
9438: CALL_OW 12
9442: ARRAY
9443: PPUSH
9444: CALL_OW 148
// end ; if legion_enemy > 0 then
9448: LD_EXP 36
9452: PUSH
9453: LD_INT 0
9455: GREATER
9456: IFFALSE 10036
// begin if tick mod 11 11$00 = 0 then
9458: LD_OWVAR 1
9462: PUSH
9463: LD_INT 23100
9465: MOD
9466: PUSH
9467: LD_INT 0
9469: EQUAL
9470: IFFALSE 9720
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9472: LD_ADDR_EXP 35
9476: PUSH
9477: LD_EXP 35
9481: PUSH
9482: LD_INT 13
9484: PUSH
9485: LD_INT 1
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: LIST
9495: ADD
9496: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9497: LD_ADDR_EXP 35
9501: PUSH
9502: LD_EXP 35
9506: PUSH
9507: LD_INT 28
9509: PUSH
9510: LD_INT 27
9512: PUSH
9513: LD_INT 29
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: PUSH
9521: LD_INT 1
9523: PPUSH
9524: LD_INT 3
9526: PPUSH
9527: CALL_OW 12
9531: ARRAY
9532: ADD
9533: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9534: LD_ADDR_EXP 35
9538: PUSH
9539: LD_EXP 35
9543: PUSH
9544: LD_INT 13
9546: PUSH
9547: LD_INT 1
9549: PUSH
9550: LD_INT 2
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: ADD
9558: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9559: LD_ADDR_EXP 35
9563: PUSH
9564: LD_EXP 35
9568: PUSH
9569: LD_INT 28
9571: PUSH
9572: LD_INT 27
9574: PUSH
9575: LD_INT 29
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 1
9585: PPUSH
9586: LD_INT 3
9588: PPUSH
9589: CALL_OW 12
9593: ARRAY
9594: ADD
9595: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9596: LD_ADDR_EXP 35
9600: PUSH
9601: LD_EXP 35
9605: PUSH
9606: LD_INT 13
9608: PUSH
9609: LD_INT 1
9611: PUSH
9612: LD_INT 2
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: ADD
9620: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9621: LD_ADDR_EXP 35
9625: PUSH
9626: LD_EXP 35
9630: PUSH
9631: LD_INT 28
9633: PUSH
9634: LD_INT 27
9636: PUSH
9637: LD_INT 29
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_INT 1
9647: PPUSH
9648: LD_INT 3
9650: PPUSH
9651: CALL_OW 12
9655: ARRAY
9656: ADD
9657: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9658: LD_ADDR_EXP 35
9662: PUSH
9663: LD_EXP 35
9667: PUSH
9668: LD_INT 13
9670: PUSH
9671: LD_INT 1
9673: PUSH
9674: LD_INT 2
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: ADD
9682: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9683: LD_ADDR_EXP 35
9687: PUSH
9688: LD_EXP 35
9692: PUSH
9693: LD_INT 28
9695: PUSH
9696: LD_INT 27
9698: PUSH
9699: LD_INT 29
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 3
9712: PPUSH
9713: CALL_OW 12
9717: ARRAY
9718: ADD
9719: ST_TO_ADDR
// end ; if legion_force >= 7 then
9720: LD_EXP 31
9724: PUSH
9725: LD_INT 7
9727: GREATEREQUAL
9728: IFFALSE 9911
// begin for i = 1 to legion_force do
9730: LD_ADDR_VAR 0 2
9734: PUSH
9735: DOUBLE
9736: LD_INT 1
9738: DEC
9739: ST_TO_ADDR
9740: LD_EXP 31
9744: PUSH
9745: FOR_TO
9746: IFFALSE 9909
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9748: LD_EXP 31
9752: PUSH
9753: LD_VAR 0 2
9757: ARRAY
9758: PPUSH
9759: CALL_OW 314
9763: NOT
9764: PUSH
9765: LD_EXP 31
9769: PUSH
9770: LD_VAR 0 2
9774: ARRAY
9775: PPUSH
9776: CALL_OW 110
9780: PUSH
9781: LD_INT 11
9783: NONEQUAL
9784: AND
9785: IFFALSE 9907
// begin case legion_enemy of 1 :
9787: LD_EXP 36
9791: PUSH
9792: LD_INT 1
9794: DOUBLE
9795: EQUAL
9796: IFTRUE 9800
9798: GO 9824
9800: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9801: LD_EXP 31
9805: PUSH
9806: LD_VAR 0 2
9810: ARRAY
9811: PPUSH
9812: LD_INT 142
9814: PPUSH
9815: LD_INT 144
9817: PPUSH
9818: CALL_OW 111
9822: GO 9889
9824: LD_INT 2
9826: DOUBLE
9827: EQUAL
9828: IFTRUE 9832
9830: GO 9856
9832: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9833: LD_EXP 31
9837: PUSH
9838: LD_VAR 0 2
9842: ARRAY
9843: PPUSH
9844: LD_INT 101
9846: PPUSH
9847: LD_INT 34
9849: PPUSH
9850: CALL_OW 111
9854: GO 9889
9856: LD_INT 7
9858: DOUBLE
9859: EQUAL
9860: IFTRUE 9864
9862: GO 9888
9864: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9865: LD_EXP 31
9869: PUSH
9870: LD_VAR 0 2
9874: ARRAY
9875: PPUSH
9876: LD_INT 173
9878: PPUSH
9879: LD_INT 127
9881: PPUSH
9882: CALL_OW 111
9886: GO 9889
9888: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9889: LD_EXP 31
9893: PUSH
9894: LD_VAR 0 2
9898: ARRAY
9899: PPUSH
9900: LD_INT 11
9902: PPUSH
9903: CALL_OW 109
// end ; end ;
9907: GO 9745
9909: POP
9910: POP
// end ; if legion_force then
9911: LD_EXP 31
9915: IFFALSE 10036
// begin tmp := legion_force ;
9917: LD_ADDR_VAR 0 3
9921: PUSH
9922: LD_EXP 31
9926: ST_TO_ADDR
// for i = 1 to tmp do
9927: LD_ADDR_VAR 0 2
9931: PUSH
9932: DOUBLE
9933: LD_INT 1
9935: DEC
9936: ST_TO_ADDR
9937: LD_VAR 0 3
9941: PUSH
9942: FOR_TO
9943: IFFALSE 10034
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9945: LD_VAR 0 3
9949: PUSH
9950: LD_VAR 0 2
9954: ARRAY
9955: PPUSH
9956: CALL_OW 314
9960: NOT
9961: PUSH
9962: LD_EXP 31
9966: PUSH
9967: LD_VAR 0 2
9971: ARRAY
9972: PPUSH
9973: CALL_OW 110
9977: PUSH
9978: LD_INT 11
9980: EQUAL
9981: AND
9982: IFFALSE 10032
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9984: LD_VAR 0 3
9988: PUSH
9989: LD_VAR 0 2
9993: ARRAY
9994: PPUSH
9995: LD_INT 22
9997: PUSH
9998: LD_EXP 36
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PPUSH
10007: CALL_OW 69
10011: PPUSH
10012: LD_VAR 0 3
10016: PUSH
10017: LD_VAR 0 2
10021: ARRAY
10022: PPUSH
10023: CALL_OW 74
10027: PPUSH
10028: CALL_OW 115
10032: GO 9942
10034: POP
10035: POP
// end ; end ; p := 1 ;
10036: LD_ADDR_VAR 0 6
10040: PUSH
10041: LD_INT 1
10043: ST_TO_ADDR
// for i = 1 to 24 do
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: DOUBLE
10050: LD_INT 1
10052: DEC
10053: ST_TO_ADDR
10054: LD_INT 24
10056: PUSH
10057: FOR_TO
10058: IFFALSE 10188
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10060: LD_EXP 33
10064: PUSH
10065: LD_VAR 0 6
10069: ARRAY
10070: PPUSH
10071: LD_EXP 33
10075: PUSH
10076: LD_VAR 0 6
10080: PUSH
10081: LD_INT 1
10083: PLUS
10084: ARRAY
10085: PPUSH
10086: CALL_OW 428
10090: PUSH
10091: LD_INT 0
10093: GREATER
10094: IFFALSE 10172
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10096: LD_EXP 33
10100: PUSH
10101: LD_VAR 0 6
10105: ARRAY
10106: PPUSH
10107: LD_EXP 33
10111: PUSH
10112: LD_VAR 0 6
10116: PUSH
10117: LD_INT 1
10119: PLUS
10120: ARRAY
10121: PPUSH
10122: CALL_OW 428
10126: PPUSH
10127: CALL_OW 255
10131: PUSH
10132: LD_EXP 36
10136: EQUAL
10137: IFFALSE 10172
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10139: LD_EXP 33
10143: PUSH
10144: LD_VAR 0 6
10148: ARRAY
10149: PPUSH
10150: LD_EXP 33
10154: PUSH
10155: LD_VAR 0 6
10159: PUSH
10160: LD_INT 1
10162: PLUS
10163: ARRAY
10164: PPUSH
10165: LD_INT 8
10167: PPUSH
10168: CALL_OW 456
// p := p + 2 ;
10172: LD_ADDR_VAR 0 6
10176: PUSH
10177: LD_VAR 0 6
10181: PUSH
10182: LD_INT 2
10184: PLUS
10185: ST_TO_ADDR
// end ;
10186: GO 10057
10188: POP
10189: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10190: LD_INT 22
10192: PUSH
10193: LD_INT 8
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: LD_INT 32
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PPUSH
10214: CALL_OW 69
10218: IFFALSE 10332
// begin if l_cargo = false then
10220: LD_VAR 0 17
10224: PUSH
10225: LD_INT 0
10227: EQUAL
10228: IFFALSE 10264
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10230: LD_ADDR_VAR 0 17
10234: PUSH
10235: LD_INT 22
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 34
10247: PUSH
10248: LD_INT 32
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 69
10263: ST_TO_ADDR
// if l_cargo then
10264: LD_VAR 0 17
10268: IFFALSE 10332
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10270: LD_ADDR_VAR 0 7
10274: PUSH
10275: LD_INT 14
10277: PPUSH
10278: CALL_OW 435
10282: ST_TO_ADDR
// if cr > 0 then
10283: LD_VAR 0 7
10287: PUSH
10288: LD_INT 0
10290: GREATER
10291: IFFALSE 10332
// if not HasTask ( l_cargo ) then
10293: LD_VAR 0 17
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10332
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10305: LD_VAR 0 17
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 1
10317: ARRAY
10318: PPUSH
10319: LD_VAR 0 7
10323: PUSH
10324: LD_INT 2
10326: ARRAY
10327: PPUSH
10328: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10332: LD_OWVAR 1
10336: PUSH
10337: LD_INT 52500
10339: PUSH
10340: LD_INT 46200
10342: PUSH
10343: LD_INT 42000
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_OWVAR 67
10355: ARRAY
10356: EQUAL
10357: PUSH
10358: LD_INT 1
10360: PPUSH
10361: CALL_OW 469
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PUSH
10370: LD_INT 112
10372: EQUAL
10373: AND
10374: PUSH
10375: LD_INT 1
10377: PPUSH
10378: CALL_OW 469
10382: PUSH
10383: LD_INT 2
10385: ARRAY
10386: PUSH
10387: LD_INT 67
10389: EQUAL
10390: AND
10391: IFFALSE 10484
// begin un := l_eng [ 1 ] ;
10393: LD_ADDR_VAR 0 1
10397: PUSH
10398: LD_VAR 0 16
10402: PUSH
10403: LD_INT 1
10405: ARRAY
10406: ST_TO_ADDR
// if IsInUnit ( un ) then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 310
10416: IFFALSE 10427
// ComExitBuilding ( un ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10427: LD_VAR 0 1
10431: PPUSH
10432: LD_INT 1
10434: PPUSH
10435: CALL_OW 469
10439: PUSH
10440: LD_INT 1
10442: ARRAY
10443: PPUSH
10444: LD_INT 1
10446: PPUSH
10447: CALL_OW 469
10451: PUSH
10452: LD_INT 2
10454: ARRAY
10455: PPUSH
10456: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_INT 207
10467: PPUSH
10468: LD_INT 123
10470: PPUSH
10471: CALL_OW 171
// AddComUnload ( un ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 219
// end ; end ;
10484: PPOPN 17
10486: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10487: LD_OWVAR 67
10491: PUSH
10492: LD_INT 1
10494: GREATER
10495: IFFALSE 10700
10497: GO 10499
10499: DISABLE
10500: LD_INT 0
10502: PPUSH
10503: PPUSH
10504: PPUSH
10505: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10506: LD_INT 35
10508: PPUSH
10509: LD_INT 12635
10511: PPUSH
10512: CALL_OW 12
10516: PPUSH
10517: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10521: LD_ADDR_VAR 0 2
10525: PUSH
10526: LD_INT 22
10528: PUSH
10529: LD_INT 8
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: PUSH
10536: LD_INT 25
10538: PUSH
10539: LD_INT 4
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: ST_TO_ADDR
// p := 1 ;
10555: LD_ADDR_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10563: LD_ADDR_VAR 0 3
10567: PUSH
10568: LD_INT 116
10570: PUSH
10571: LD_INT 139
10573: PUSH
10574: LD_INT 69
10576: PUSH
10577: LD_INT 13
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: ST_TO_ADDR
// for i = 1 to 2 do
10586: LD_ADDR_VAR 0 1
10590: PUSH
10591: DOUBLE
10592: LD_INT 1
10594: DEC
10595: ST_TO_ADDR
10596: LD_INT 2
10598: PUSH
10599: FOR_TO
10600: IFFALSE 10698
// begin if IsInUnit ( sci [ i ] ) then
10602: LD_VAR 0 2
10606: PUSH
10607: LD_VAR 0 1
10611: ARRAY
10612: PPUSH
10613: CALL_OW 310
10617: IFFALSE 10634
// ComExitBuilding ( sci [ i ] ) ;
10619: LD_VAR 0 2
10623: PUSH
10624: LD_VAR 0 1
10628: ARRAY
10629: PPUSH
10630: CALL_OW 122
// Wait ( 0 0$03 ) ;
10634: LD_INT 105
10636: PPUSH
10637: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10641: LD_VAR 0 2
10645: PUSH
10646: LD_VAR 0 1
10650: ARRAY
10651: PPUSH
10652: LD_VAR 0 3
10656: PUSH
10657: LD_VAR 0 4
10661: ARRAY
10662: PPUSH
10663: LD_VAR 0 3
10667: PUSH
10668: LD_VAR 0 4
10672: PUSH
10673: LD_INT 1
10675: PLUS
10676: ARRAY
10677: PPUSH
10678: CALL_OW 158
// p := p + 2 ;
10682: LD_ADDR_VAR 0 4
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: LD_INT 2
10694: PLUS
10695: ST_TO_ADDR
// end ;
10696: GO 10599
10698: POP
10699: POP
// end ;
10700: PPOPN 4
10702: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10703: LD_INT 14
10705: PPUSH
10706: CALL_OW 435
10710: PUSH
10711: LD_INT 20
10713: LESS
10714: IFFALSE 10741
10716: GO 10718
10718: DISABLE
// begin enable ;
10719: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10720: LD_INT 1
10722: PPUSH
10723: LD_INT 5
10725: PPUSH
10726: CALL_OW 12
10730: PPUSH
10731: LD_INT 14
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 55
// end ; end_of_file
10741: END
// export function Action ; var un , gamemode , speaker ; begin
10742: LD_INT 0
10744: PPUSH
10745: PPUSH
10746: PPUSH
10747: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10748: LD_ADDR_OWVAR 67
10752: PUSH
10753: LD_INT 0
10755: PPUSH
10756: CALL_OW 426
10760: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10761: LD_ADDR_VAR 0 3
10765: PUSH
10766: LD_INT 1
10768: PPUSH
10769: CALL_OW 426
10773: ST_TO_ADDR
// if gamemode = 1 then
10774: LD_VAR 0 3
10778: PUSH
10779: LD_INT 1
10781: EQUAL
10782: IFFALSE 10806
// begin your_side := 1 ;
10784: LD_ADDR_OWVAR 2
10788: PUSH
10789: LD_INT 1
10791: ST_TO_ADDR
// legion_enemy := 1 ;
10792: LD_ADDR_EXP 36
10796: PUSH
10797: LD_INT 1
10799: ST_TO_ADDR
// PrepareAmerican ;
10800: CALL 221 0 0
// end else
10804: GO 10858
// if gamemode = 2 then
10806: LD_VAR 0 3
10810: PUSH
10811: LD_INT 2
10813: EQUAL
10814: IFFALSE 10838
// begin your_side := 2 ;
10816: LD_ADDR_OWVAR 2
10820: PUSH
10821: LD_INT 2
10823: ST_TO_ADDR
// legion_enemy := 2 ;
10824: LD_ADDR_EXP 36
10828: PUSH
10829: LD_INT 2
10831: ST_TO_ADDR
// PrepareArabian ;
10832: CALL 18147 0 0
// end else
10836: GO 10858
// begin your_side := 7 ;
10838: LD_ADDR_OWVAR 2
10842: PUSH
10843: LD_INT 7
10845: ST_TO_ADDR
// legion_enemy := 7 ;
10846: LD_ADDR_EXP 36
10850: PUSH
10851: LD_INT 7
10853: ST_TO_ADDR
// PrepareAlliance ;
10854: CALL 15558 0 0
// end ; if your_side = 1 then
10858: LD_OWVAR 2
10862: PUSH
10863: LD_INT 1
10865: EQUAL
10866: IFFALSE 11344
// begin case Query ( QVul4 ) of 1 :
10868: LD_STRING QVul4
10870: PPUSH
10871: CALL_OW 97
10875: PUSH
10876: LD_INT 1
10878: DOUBLE
10879: EQUAL
10880: IFTRUE 10884
10882: GO 10887
10884: POP
// ; end ;
10885: GO 10888
10887: POP
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10892: LD_INT 8
10894: PPUSH
10895: LD_INT 5
10897: PPUSH
10898: CALL_OW 86
// uc_side := 4 ;
10902: LD_ADDR_OWVAR 20
10906: PUSH
10907: LD_INT 4
10909: ST_TO_ADDR
// uc_nation := 1 ;
10910: LD_ADDR_OWVAR 21
10914: PUSH
10915: LD_INT 1
10917: ST_TO_ADDR
// hc_importance := 0 ;
10918: LD_ADDR_OWVAR 32
10922: PUSH
10923: LD_INT 0
10925: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10926: LD_INT 1
10928: PPUSH
10929: LD_INT 3
10931: PPUSH
10932: LD_EXP 21
10936: PPUSH
10937: CALL_OW 380
// un := CreateHuman ;
10941: LD_ADDR_VAR 0 2
10945: PUSH
10946: CALL_OW 44
10950: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10951: LD_VAR 0 2
10955: PPUSH
10956: LD_INT 12
10958: PPUSH
10959: LD_INT 9
10961: PPUSH
10962: LD_INT 0
10964: PPUSH
10965: CALL_OW 48
// hc_name := Stuart Carey ;
10969: LD_ADDR_OWVAR 26
10973: PUSH
10974: LD_STRING Stuart Carey
10976: ST_TO_ADDR
// hc_class := 1 ;
10977: LD_ADDR_OWVAR 28
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// hc_gallery := vulcano ;
10985: LD_ADDR_OWVAR 33
10989: PUSH
10990: LD_STRING vulcano
10992: ST_TO_ADDR
// hc_face_number := 1 ;
10993: LD_ADDR_OWVAR 34
10997: PUSH
10998: LD_INT 1
11000: ST_TO_ADDR
// us_guy := CreateHuman ;
11001: LD_ADDR_EXP 22
11005: PUSH
11006: CALL_OW 44
11010: ST_TO_ADDR
// InitHc ;
11011: CALL_OW 19
// if rand ( 0 , 1 ) then
11015: LD_INT 0
11017: PPUSH
11018: LD_INT 1
11020: PPUSH
11021: CALL_OW 12
11025: IFFALSE 11042
// PrepareHuman ( sex_male , 3 , 6 ) else
11027: LD_INT 1
11029: PPUSH
11030: LD_INT 3
11032: PPUSH
11033: LD_INT 6
11035: PPUSH
11036: CALL_OW 380
11040: GO 11055
// PrepareHuman ( sex_female , 4 , 8 ) ;
11042: LD_INT 2
11044: PPUSH
11045: LD_INT 4
11047: PPUSH
11048: LD_INT 8
11050: PPUSH
11051: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11055: LD_VAR 0 2
11059: PPUSH
11060: LD_EXP 19
11064: PPUSH
11065: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11069: LD_EXP 19
11073: PPUSH
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 119
// if GetSex ( un ) = sex_male then
11083: LD_VAR 0 2
11087: PPUSH
11088: CALL_OW 258
11092: PUSH
11093: LD_INT 1
11095: EQUAL
11096: IFFALSE 11179
// begin Say ( un , VD-un1 ) ;
11098: LD_VAR 0 2
11102: PPUSH
11103: LD_STRING VD-un1
11105: PPUSH
11106: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11110: LD_EXP 19
11114: PPUSH
11115: LD_STRING VDc-1
11117: PPUSH
11118: CALL_OW 88
// Say ( un , VD-un2 ) ;
11122: LD_VAR 0 2
11126: PPUSH
11127: LD_STRING VD-un2
11129: PPUSH
11130: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11134: LD_EXP 19
11138: PPUSH
11139: LD_STRING VDc-2
11141: PPUSH
11142: CALL_OW 88
// Say ( un , VD-un3 ) ;
11146: LD_VAR 0 2
11150: PPUSH
11151: LD_STRING VD-un3
11153: PPUSH
11154: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11158: LD_INT 7
11160: PPUSH
11161: CALL_OW 67
// Say ( un , VD-un4 ) ;
11165: LD_VAR 0 2
11169: PPUSH
11170: LD_STRING VD-un4
11172: PPUSH
11173: CALL_OW 88
// end else
11177: GO 11258
// begin Say ( un , VD-unf1 ) ;
11179: LD_VAR 0 2
11183: PPUSH
11184: LD_STRING VD-unf1
11186: PPUSH
11187: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11191: LD_EXP 19
11195: PPUSH
11196: LD_STRING VDc-1
11198: PPUSH
11199: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11203: LD_VAR 0 2
11207: PPUSH
11208: LD_STRING VD-unf2
11210: PPUSH
11211: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11215: LD_EXP 19
11219: PPUSH
11220: LD_STRING VDc-2
11222: PPUSH
11223: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11227: LD_VAR 0 2
11231: PPUSH
11232: LD_STRING VD-unf3
11234: PPUSH
11235: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11239: LD_INT 7
11241: PPUSH
11242: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11246: LD_VAR 0 2
11250: PPUSH
11251: LD_STRING VD-unf4
11253: PPUSH
11254: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11258: LD_VAR 0 2
11262: PPUSH
11263: LD_INT 2
11265: PPUSH
11266: LD_INT 2
11268: PPUSH
11269: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11273: LD_EXP 19
11277: PPUSH
11278: LD_STRING VDc-3
11280: PPUSH
11281: CALL_OW 88
// InGameOff ;
11285: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11289: LD_STRING CVulc1
11291: PPUSH
11292: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11303: LD_VAR 0 2
11307: PPUSH
11308: CALL_OW 250
11312: PUSH
11313: LD_INT 2
11315: EQUAL
11316: PUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PUSH
11327: LD_INT 2
11329: EQUAL
11330: AND
11331: IFFALSE 11296
// RemoveUnit ( un ) ;
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 64
// end else
11342: GO 11721
// if your_side = 2 then
11344: LD_OWVAR 2
11348: PUSH
11349: LD_INT 2
11351: EQUAL
11352: IFFALSE 11568
// begin CenterNowOnUnits ( player_commander ) ;
11354: LD_EXP 10
11358: PPUSH
11359: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11363: LD_ADDR_VAR 0 4
11367: PUSH
11368: LD_INT 22
11370: PUSH
11371: LD_INT 2
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: LD_INT 21
11380: PUSH
11381: LD_INT 1
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: PPUSH
11392: CALL_OW 69
11396: PUSH
11397: LD_EXP 51
11401: DIFF
11402: ST_TO_ADDR
// if speaker then
11403: LD_VAR 0 4
11407: IFFALSE 11559
// begin InGameOn ;
11409: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11413: LD_EXP 51
11417: PPUSH
11418: LD_STRING VSd-1
11420: PPUSH
11421: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11425: LD_VAR 0 4
11429: PUSH
11430: LD_INT 1
11432: ARRAY
11433: PPUSH
11434: CALL_OW 258
11438: PUSH
11439: LD_INT 1
11441: EQUAL
11442: IFFALSE 11462
// Say ( speaker [ 1 ] , VAd-1 ) else
11444: LD_VAR 0 4
11448: PUSH
11449: LD_INT 1
11451: ARRAY
11452: PPUSH
11453: LD_STRING VAd-1
11455: PPUSH
11456: CALL_OW 88
11460: GO 11478
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11462: LD_VAR 0 4
11466: PUSH
11467: LD_INT 1
11469: ARRAY
11470: PPUSH
11471: LD_STRING VAfd-1
11473: PPUSH
11474: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11478: LD_EXP 51
11482: PPUSH
11483: LD_STRING VSd-2
11485: PPUSH
11486: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11490: LD_VAR 0 4
11494: PUSH
11495: LD_INT 1
11497: ARRAY
11498: PPUSH
11499: CALL_OW 258
11503: PUSH
11504: LD_INT 1
11506: EQUAL
11507: IFFALSE 11527
// Say ( speaker [ 1 ] , VAd-2 ) else
11509: LD_VAR 0 4
11513: PUSH
11514: LD_INT 1
11516: ARRAY
11517: PPUSH
11518: LD_STRING VAd-2
11520: PPUSH
11521: CALL_OW 88
11525: GO 11543
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11527: LD_VAR 0 4
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PPUSH
11536: LD_STRING VAfd-2
11538: PPUSH
11539: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11543: LD_EXP 51
11547: PPUSH
11548: LD_STRING VSd-3
11550: PPUSH
11551: CALL_OW 88
// InGameOff ;
11555: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11559: LD_STRING CVulc5
11561: PPUSH
11562: CALL_OW 337
// end else
11566: GO 11721
// if your_side = 7 then
11568: LD_OWVAR 2
11572: PUSH
11573: LD_INT 7
11575: EQUAL
11576: IFFALSE 11721
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11578: LD_ADDR_VAR 0 4
11582: PUSH
11583: LD_INT 22
11585: PUSH
11586: LD_INT 7
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: LD_INT 21
11595: PUSH
11596: LD_INT 1
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PPUSH
11607: CALL_OW 69
11611: PUSH
11612: LD_EXP 37
11616: DIFF
11617: ST_TO_ADDR
// if speaker then
11618: LD_VAR 0 4
11622: IFFALSE 11714
// begin CenterNowOnUnits ( al_commander ) ;
11624: LD_EXP 37
11628: PPUSH
11629: CALL_OW 87
// InGameOn ;
11633: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11637: LD_EXP 37
11641: PPUSH
11642: LD_STRING VPd-1
11644: PPUSH
11645: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11649: LD_VAR 0 4
11653: PUSH
11654: LD_INT 1
11656: ARRAY
11657: PPUSH
11658: CALL_OW 258
11662: IFFALSE 11682
// Say ( speaker [ 1 ] , VPpd-1 ) else
11664: LD_VAR 0 4
11668: PUSH
11669: LD_INT 1
11671: ARRAY
11672: PPUSH
11673: LD_STRING VPpd-1
11675: PPUSH
11676: CALL_OW 88
11680: GO 11698
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11682: LD_VAR 0 4
11686: PUSH
11687: LD_INT 1
11689: ARRAY
11690: PPUSH
11691: LD_STRING VPpdf-1
11693: PPUSH
11694: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11698: LD_EXP 37
11702: PPUSH
11703: LD_STRING VPd-2
11705: PPUSH
11706: CALL_OW 88
// InGameOff ;
11710: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11714: LD_STRING CVulc7
11716: PPUSH
11717: CALL_OW 337
// end ; SaveForQuickRestart ;
11721: CALL_OW 22
// end ;
11725: LD_VAR 0 1
11729: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11730: LD_INT 22
11732: PUSH
11733: LD_INT 2
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PUSH
11740: LD_INT 30
11742: PUSH
11743: LD_INT 3
11745: PUSH
11746: EMPTY
11747: LIST
11748: LIST
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PPUSH
11754: CALL_OW 69
11758: IFFALSE 11802
11760: GO 11762
11762: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11763: LD_STRING CVulc6
11765: PPUSH
11766: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11770: LD_INT 52500
11772: PUSH
11773: LD_INT 47250
11775: PUSH
11776: LD_INT 42000
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: LIST
11783: PUSH
11784: LD_OWVAR 67
11788: ARRAY
11789: PPUSH
11790: CALL_OW 67
// ru_can_attack := true ;
11794: LD_ADDR_EXP 3
11798: PUSH
11799: LD_INT 1
11801: ST_TO_ADDR
// end ;
11802: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11803: LD_INT 50
11805: PPUSH
11806: CALL_OW 255
11810: PUSH
11811: LD_INT 1
11813: EQUAL
11814: PUSH
11815: LD_INT 22
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 2
11827: PUSH
11828: LD_INT 30
11830: PUSH
11831: LD_INT 3
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: LD_INT 30
11840: PUSH
11841: LD_INT 1
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: OR
11862: IFFALSE 12096
11864: GO 11866
11866: DISABLE
11867: LD_INT 0
11869: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11870: LD_STRING CVulc2
11872: PPUSH
11873: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11877: LD_ADDR_VAR 0 1
11881: PUSH
11882: LD_INT 22
11884: PUSH
11885: LD_INT 1
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 25
11894: PUSH
11895: LD_INT 2
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 69
11910: PUSH
11911: LD_EXP 19
11915: DIFF
11916: ST_TO_ADDR
// DialogueOn ;
11917: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_INT 1
11935: ARRAY
11936: PPUSH
11937: CALL_OW 258
11941: PUSH
11942: LD_INT 1
11944: EQUAL
11945: IFFALSE 11965
// Say ( speaker [ 1 ] , VDb-1 ) else
11947: LD_VAR 0 1
11951: PUSH
11952: LD_INT 1
11954: ARRAY
11955: PPUSH
11956: LD_STRING VDb-1
11958: PPUSH
11959: CALL_OW 88
11963: GO 11981
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11965: LD_VAR 0 1
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PPUSH
11974: LD_STRING VDbf-1
11976: PPUSH
11977: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11981: LD_INT 10
11983: PPUSH
11984: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11988: LD_VAR 0 1
11992: PUSH
11993: LD_INT 1
11995: ARRAY
11996: PPUSH
11997: CALL_OW 258
12001: PUSH
12002: LD_INT 1
12004: EQUAL
12005: IFFALSE 12025
// Say ( speaker [ 1 ] , VDb-2 ) else
12007: LD_VAR 0 1
12011: PUSH
12012: LD_INT 1
12014: ARRAY
12015: PPUSH
12016: LD_STRING VDb-2
12018: PPUSH
12019: CALL_OW 88
12023: GO 12041
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12025: LD_VAR 0 1
12029: PUSH
12030: LD_INT 1
12032: ARRAY
12033: PPUSH
12034: LD_STRING VDbf-2
12036: PPUSH
12037: CALL_OW 88
// DWait ( 0 0$01 ) ;
12041: LD_INT 35
12043: PPUSH
12044: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12048: LD_EXP 19
12052: PPUSH
12053: LD_STRING VDb-com1
12055: PPUSH
12056: CALL_OW 88
// DialogueOff ;
12060: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12064: LD_INT 44100
12066: PUSH
12067: LD_INT 36750
12069: PUSH
12070: LD_INT 31500
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: PUSH
12078: LD_OWVAR 67
12082: ARRAY
12083: PPUSH
12084: CALL_OW 67
// ru_can_attack := true ;
12088: LD_ADDR_EXP 3
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// end ;
12096: PPOPN 1
12098: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12099: LD_INT 22
12101: PUSH
12102: LD_INT 7
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PUSH
12109: LD_INT 30
12111: PUSH
12112: LD_INT 3
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PPUSH
12123: CALL_OW 69
12127: IFFALSE 12164
12129: GO 12131
12131: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12132: LD_INT 42000
12134: PUSH
12135: LD_INT 34650
12137: PUSH
12138: LD_INT 29400
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: LIST
12145: PUSH
12146: LD_OWVAR 67
12150: ARRAY
12151: PPUSH
12152: CALL_OW 67
// ru_can_attack := true ;
12156: LD_ADDR_EXP 3
12160: PUSH
12161: LD_INT 1
12163: ST_TO_ADDR
// end ;
12164: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12165: LD_INT 58
12167: PPUSH
12168: CALL_OW 255
12172: PUSH
12173: LD_INT 1
12175: EQUAL
12176: IFFALSE 12383
12178: GO 12180
12180: DISABLE
12181: LD_INT 0
12183: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12184: LD_ADDR_VAR 0 1
12188: PUSH
12189: LD_INT 22
12191: PUSH
12192: LD_INT 1
12194: PUSH
12195: EMPTY
12196: LIST
12197: LIST
12198: PUSH
12199: LD_INT 25
12201: PUSH
12202: LD_INT 2
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: PUSH
12209: EMPTY
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: ST_TO_ADDR
// DialogueOn ;
12218: CALL_OW 6
// if speaker then
12222: LD_VAR 0 1
12226: IFFALSE 12281
// if GetSex ( speaker [ 1 ] ) = sex_male then
12228: LD_VAR 0 1
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: CALL_OW 258
12241: PUSH
12242: LD_INT 1
12244: EQUAL
12245: IFFALSE 12265
// Say ( speaker [ 1 ] , VDe-1 ) else
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: ARRAY
12255: PPUSH
12256: LD_STRING VDe-1
12258: PPUSH
12259: CALL_OW 88
12263: GO 12281
// Say ( speaker [ 1 ] , VDef-1 ) ;
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING VDef-1
12276: PPUSH
12277: CALL_OW 88
// case Query ( SibNote ) of 1 :
12281: LD_STRING SibNote
12283: PPUSH
12284: CALL_OW 97
12288: PUSH
12289: LD_INT 1
12291: DOUBLE
12292: EQUAL
12293: IFTRUE 12297
12295: GO 12300
12297: POP
// ; end ;
12298: GO 12301
12300: POP
// if speaker then
12301: LD_VAR 0 1
12305: IFFALSE 12360
// if GetSex ( speaker [ 1 ] ) = sex_male then
12307: LD_VAR 0 1
12311: PUSH
12312: LD_INT 1
12314: ARRAY
12315: PPUSH
12316: CALL_OW 258
12320: PUSH
12321: LD_INT 1
12323: EQUAL
12324: IFFALSE 12344
// Say ( speaker [ 1 ] , VDe-2 ) else
12326: LD_VAR 0 1
12330: PUSH
12331: LD_INT 1
12333: ARRAY
12334: PPUSH
12335: LD_STRING VDe-2
12337: PPUSH
12338: CALL_OW 88
12342: GO 12360
// Say ( speaker [ 1 ] , VDef-2 ) ;
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 1
12351: ARRAY
12352: PPUSH
12353: LD_STRING VDef-2
12355: PPUSH
12356: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12360: LD_EXP 19
12364: PPUSH
12365: LD_STRING VDc-4
12367: PPUSH
12368: CALL_OW 88
// DialogueOff ;
12372: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12376: LD_STRING CVulc3
12378: PPUSH
12379: CALL_OW 337
// end ;
12383: PPOPN 1
12385: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12386: LD_OWVAR 2
12390: PUSH
12391: LD_INT 1
12393: EQUAL
12394: PUSH
12395: LD_INT 22
12397: PUSH
12398: LD_INT 1
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: LD_INT 30
12407: PUSH
12408: LD_INT 3
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PPUSH
12419: CALL_OW 69
12423: PUSH
12424: LD_INT 0
12426: GREATER
12427: AND
12428: IFFALSE 12862
12430: GO 12432
12432: DISABLE
12433: LD_INT 0
12435: PPUSH
12436: PPUSH
12437: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12438: LD_INT 245
12440: PPUSH
12441: LD_INT 1295
12443: PPUSH
12444: CALL_OW 12
12448: PPUSH
12449: CALL_OW 67
// DialogueOn ;
12453: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12457: LD_EXP 22
12461: PPUSH
12462: LD_STRING VDG-1
12464: PPUSH
12465: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12469: LD_EXP 19
12473: PPUSH
12474: LD_STRING VDc-5
12476: PPUSH
12477: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12481: LD_EXP 22
12485: PPUSH
12486: LD_STRING VDG-2
12488: PPUSH
12489: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12493: LD_EXP 19
12497: PPUSH
12498: LD_STRING VDc-6
12500: PPUSH
12501: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12505: LD_EXP 22
12509: PPUSH
12510: LD_STRING VDG-3
12512: PPUSH
12513: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12517: LD_EXP 19
12521: PPUSH
12522: LD_STRING VDc-7
12524: PPUSH
12525: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12529: LD_EXP 22
12533: PPUSH
12534: LD_STRING VDG-4
12536: PPUSH
12537: CALL_OW 94
// DialogueOff ;
12541: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12545: LD_STRING CVulc4
12547: PPUSH
12548: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12552: LD_INT 18900
12554: PUSH
12555: LD_INT 21000
12557: PUSH
12558: LD_INT 23100
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: PUSH
12566: LD_OWVAR 67
12570: ARRAY
12571: PPUSH
12572: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12576: LD_ADDR_VAR 0 1
12580: PUSH
12581: DOUBLE
12582: LD_INT 1
12584: DEC
12585: ST_TO_ADDR
12586: LD_INT 4
12588: PUSH
12589: LD_INT 5
12591: PUSH
12592: LD_INT 6
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: LIST
12599: PUSH
12600: LD_OWVAR 67
12604: ARRAY
12605: PUSH
12606: FOR_TO
12607: IFFALSE 12851
// begin uc_side := 1 ;
12609: LD_ADDR_OWVAR 20
12613: PUSH
12614: LD_INT 1
12616: ST_TO_ADDR
// uc_nation := 1 ;
12617: LD_ADDR_OWVAR 21
12621: PUSH
12622: LD_INT 1
12624: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12625: LD_INT 0
12627: PPUSH
12628: LD_INT 1
12630: PPUSH
12631: LD_INT 4
12633: PPUSH
12634: CALL_OW 12
12638: PPUSH
12639: LD_EXP 21
12643: PPUSH
12644: CALL_OW 380
// un := CreateHuman ;
12648: LD_ADDR_VAR 0 2
12652: PUSH
12653: CALL_OW 44
12657: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12658: LD_VAR 0 2
12662: PPUSH
12663: LD_INT 2
12665: PPUSH
12666: CALL_OW 233
// if GetClass ( un ) = 3 then
12670: LD_VAR 0 2
12674: PPUSH
12675: CALL_OW 257
12679: PUSH
12680: LD_INT 3
12682: EQUAL
12683: IFFALSE 12834
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12685: LD_ADDR_OWVAR 37
12689: PUSH
12690: LD_INT 2
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: LD_VAR 0 1
12704: PUSH
12705: LD_INT 2
12707: MOD
12708: ARRAY
12709: ST_TO_ADDR
// vc_engine := engine_combustion ;
12710: LD_ADDR_OWVAR 39
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// vc_control := control_manual ;
12718: LD_ADDR_OWVAR 38
12722: PUSH
12723: LD_INT 1
12725: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12726: LD_ADDR_OWVAR 40
12730: PUSH
12731: LD_INT 9
12733: PUSH
12734: LD_INT 9
12736: PUSH
12737: LD_INT 5
12739: PUSH
12740: LD_INT 11
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: PUSH
12749: LD_INT 1
12751: PPUSH
12752: LD_INT 4
12754: PPUSH
12755: CALL_OW 12
12759: ARRAY
12760: ST_TO_ADDR
// veh := CreateVehicle ;
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: CALL_OW 45
12770: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12771: LD_VAR 0 3
12775: PPUSH
12776: LD_INT 2
12778: PPUSH
12779: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12783: LD_VAR 0 3
12787: PPUSH
12788: LD_INT 77
12790: PPUSH
12791: LD_INT 88
12793: PPUSH
12794: CALL_OW 12
12798: PPUSH
12799: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12803: LD_VAR 0 3
12807: PPUSH
12808: LD_INT 1
12810: PPUSH
12811: LD_INT 0
12813: PPUSH
12814: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12818: LD_VAR 0 2
12822: PPUSH
12823: LD_VAR 0 3
12827: PPUSH
12828: CALL_OW 52
// end else
12832: GO 12849
// PlaceUnitArea ( un , start_north , false ) ;
12834: LD_VAR 0 2
12838: PPUSH
12839: LD_INT 1
12841: PPUSH
12842: LD_INT 0
12844: PPUSH
12845: CALL_OW 49
// end ;
12849: GO 12606
12851: POP
12852: POP
// CenterNowOnUnits ( un ) ;
12853: LD_VAR 0 2
12857: PPUSH
12858: CALL_OW 87
// end ;
12862: PPOPN 3
12864: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12865: LD_INT 21
12867: PPUSH
12868: LD_INT 22
12870: PUSH
12871: LD_OWVAR 2
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 70
12884: IFFALSE 13205
12886: GO 12888
12888: DISABLE
12889: LD_INT 0
12891: PPUSH
12892: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12893: LD_ADDR_VAR 0 2
12897: PUSH
12898: LD_INT 22
12900: PUSH
12901: LD_OWVAR 2
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 2
12912: PUSH
12913: LD_INT 25
12915: PUSH
12916: LD_INT 1
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: LD_INT 25
12925: PUSH
12926: LD_INT 2
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 25
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 4
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: PUSH
12969: LD_EXP 10
12973: DIFF
12974: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12975: LD_ADDR_VAR 0 1
12979: PUSH
12980: LD_VAR 0 2
12984: PPUSH
12985: LD_INT 112
12987: PPUSH
12988: LD_INT 67
12990: PPUSH
12991: CALL_OW 73
12995: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12996: LD_VAR 0 1
13000: PPUSH
13001: CALL_OW 255
13005: PUSH
13006: LD_INT 7
13008: EQUAL
13009: IFFALSE 13052
// if GetSex ( un ) = sex_male then
13011: LD_VAR 0 1
13015: PPUSH
13016: CALL_OW 258
13020: PUSH
13021: LD_INT 1
13023: EQUAL
13024: IFFALSE 13040
// Say ( un , VD-find-al ) else
13026: LD_VAR 0 1
13030: PPUSH
13031: LD_STRING VD-find-al
13033: PPUSH
13034: CALL_OW 88
13038: GO 13052
// Say ( un , VD-find-al-f ) ;
13040: LD_VAR 0 1
13044: PPUSH
13045: LD_STRING VD-find-al-f
13047: PPUSH
13048: CALL_OW 88
// if GetSide ( un ) = 2 then
13052: LD_VAR 0 1
13056: PPUSH
13057: CALL_OW 255
13061: PUSH
13062: LD_INT 2
13064: EQUAL
13065: IFFALSE 13108
// if GetSex ( un ) = sex_male then
13067: LD_VAR 0 1
13071: PPUSH
13072: CALL_OW 258
13076: PUSH
13077: LD_INT 1
13079: EQUAL
13080: IFFALSE 13096
// Say ( un , VD-find-ar ) else
13082: LD_VAR 0 1
13086: PPUSH
13087: LD_STRING VD-find-ar
13089: PPUSH
13090: CALL_OW 88
13094: GO 13108
// Say ( un , VD-find-ar-f ) ;
13096: LD_VAR 0 1
13100: PPUSH
13101: LD_STRING VD-find-ar-f
13103: PPUSH
13104: CALL_OW 88
// if GetSide ( un ) = 1 then
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 255
13117: PUSH
13118: LD_INT 1
13120: EQUAL
13121: IFFALSE 13188
// begin if GetSex ( un ) = sex_male then
13123: LD_VAR 0 1
13127: PPUSH
13128: CALL_OW 258
13132: PUSH
13133: LD_INT 1
13135: EQUAL
13136: IFFALSE 13164
// begin Say ( un , VD-find-us ) ;
13138: LD_VAR 0 1
13142: PPUSH
13143: LD_STRING VD-find-us
13145: PPUSH
13146: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13150: LD_VAR 0 1
13154: PPUSH
13155: LD_STRING VD-find-us2
13157: PPUSH
13158: CALL_OW 88
// end else
13162: GO 13188
// begin Say ( un , VD-find-us-f ) ;
13164: LD_VAR 0 1
13168: PPUSH
13169: LD_STRING VD-find-us-f
13171: PPUSH
13172: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13176: LD_VAR 0 1
13180: PPUSH
13181: LD_STRING VD-find-us2-f
13183: PPUSH
13184: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13188: LD_INT 10
13190: PPUSH
13191: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13195: LD_INT 112
13197: PPUSH
13198: LD_INT 67
13200: PPUSH
13201: CALL_OW 86
// end ;
13205: PPOPN 2
13207: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13208: LD_EXP 7
13212: IFFALSE 13714
13214: GO 13216
13216: DISABLE
13217: LD_INT 0
13219: PPUSH
// begin if your_side = 1 then
13220: LD_OWVAR 2
13224: PUSH
13225: LD_INT 1
13227: EQUAL
13228: IFFALSE 13409
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13230: LD_ADDR_VAR 0 1
13234: PUSH
13235: LD_INT 22
13237: PUSH
13238: LD_INT 1
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: LD_INT 25
13247: PUSH
13248: LD_INT 4
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 19
13268: DIFF
13269: ST_TO_ADDR
// if not speaker then
13270: LD_VAR 0 1
13274: NOT
13275: IFFALSE 13279
// exit ;
13277: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13279: LD_VAR 0 1
13283: PUSH
13284: LD_INT 1
13286: ARRAY
13287: PPUSH
13288: CALL_OW 258
13292: PUSH
13293: LD_INT 1
13295: EQUAL
13296: IFFALSE 13316
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13298: LD_VAR 0 1
13302: PUSH
13303: LD_INT 1
13305: ARRAY
13306: PPUSH
13307: LD_STRING VD-us-sci-art-1
13309: PPUSH
13310: CALL_OW 88
13314: GO 13332
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING VD-us-fsci-art-1
13327: PPUSH
13328: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13332: LD_EXP 19
13336: PPUSH
13337: LD_STRING VDc-art1
13339: PPUSH
13340: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13344: LD_VAR 0 1
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: PPUSH
13353: CALL_OW 258
13357: PUSH
13358: LD_INT 1
13360: EQUAL
13361: IFFALSE 13381
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13363: LD_VAR 0 1
13367: PUSH
13368: LD_INT 1
13370: ARRAY
13371: PPUSH
13372: LD_STRING VD-us-sci-art-2
13374: PPUSH
13375: CALL_OW 88
13379: GO 13397
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13381: LD_VAR 0 1
13385: PUSH
13386: LD_INT 1
13388: ARRAY
13389: PPUSH
13390: LD_STRING VD-us-fsci-art-2
13392: PPUSH
13393: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13397: LD_EXP 19
13401: PPUSH
13402: LD_STRING VDc-art2
13404: PPUSH
13405: CALL_OW 88
// end ; if your_side = 2 then
13409: LD_OWVAR 2
13413: PUSH
13414: LD_INT 2
13416: EQUAL
13417: IFFALSE 13521
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13419: LD_ADDR_VAR 0 1
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_INT 2
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: PUSH
13434: LD_INT 25
13436: PUSH
13437: LD_INT 4
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PPUSH
13448: CALL_OW 69
13452: PUSH
13453: LD_EXP 51
13457: DIFF
13458: ST_TO_ADDR
// if not speaker then
13459: LD_VAR 0 1
13463: NOT
13464: IFFALSE 13468
// exit ;
13466: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13468: LD_VAR 0 1
13472: PUSH
13473: LD_INT 1
13475: ARRAY
13476: PPUSH
13477: CALL_OW 258
13481: PUSH
13482: LD_INT 1
13484: EQUAL
13485: IFFALSE 13505
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13487: LD_VAR 0 1
13491: PUSH
13492: LD_INT 1
13494: ARRAY
13495: PPUSH
13496: LD_STRING VD-ar-sci-art-1
13498: PPUSH
13499: CALL_OW 88
13503: GO 13521
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13505: LD_VAR 0 1
13509: PUSH
13510: LD_INT 1
13512: ARRAY
13513: PPUSH
13514: LD_STRING VD-ar-fsci-art-1
13516: PPUSH
13517: CALL_OW 88
// end ; if your_side = 7 then
13521: LD_OWVAR 2
13525: PUSH
13526: LD_INT 7
13528: EQUAL
13529: IFFALSE 13714
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13531: LD_ADDR_VAR 0 1
13535: PUSH
13536: LD_INT 22
13538: PUSH
13539: LD_INT 7
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 25
13548: PUSH
13549: LD_INT 4
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PUSH
13565: LD_EXP 37
13569: DIFF
13570: ST_TO_ADDR
// if speaker then
13571: LD_VAR 0 1
13575: IFFALSE 13707
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13577: LD_VAR 0 1
13581: PUSH
13582: LD_INT 1
13584: ARRAY
13585: PPUSH
13586: CALL_OW 258
13590: PUSH
13591: LD_INT 1
13593: EQUAL
13594: IFFALSE 13614
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13596: LD_VAR 0 1
13600: PUSH
13601: LD_INT 1
13603: ARRAY
13604: PPUSH
13605: LD_STRING VD-al-sci-art-1
13607: PPUSH
13608: CALL_OW 88
13612: GO 13630
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13614: LD_VAR 0 1
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: PPUSH
13623: LD_STRING VD-al-fsci-art-1
13625: PPUSH
13626: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13630: LD_EXP 37
13634: PPUSH
13635: LD_STRING VPd-art-1
13637: PPUSH
13638: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13642: LD_VAR 0 1
13646: PUSH
13647: LD_INT 1
13649: ARRAY
13650: PPUSH
13651: CALL_OW 258
13655: PUSH
13656: LD_INT 1
13658: EQUAL
13659: IFFALSE 13679
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13661: LD_VAR 0 1
13665: PUSH
13666: LD_INT 1
13668: ARRAY
13669: PPUSH
13670: LD_STRING VD-al-sci-art-2
13672: PPUSH
13673: CALL_OW 88
13677: GO 13695
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13679: LD_VAR 0 1
13683: PUSH
13684: LD_INT 1
13686: ARRAY
13687: PPUSH
13688: LD_STRING VD-al-fsci-art-2
13690: PPUSH
13691: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13695: LD_EXP 37
13699: PPUSH
13700: LD_STRING VPd-art-2
13702: PPUSH
13703: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13707: LD_STRING CVulc7out
13709: PPUSH
13710: CALL_OW 337
// end ; end ;
13714: PPOPN 1
13716: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13717: LD_INT 8
13719: PPUSH
13720: LD_INT 22
13722: PUSH
13723: LD_OWVAR 2
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: PPUSH
13732: CALL_OW 69
13736: PPUSH
13737: LD_INT 8
13739: PPUSH
13740: CALL 2145 0 2
13744: PPUSH
13745: CALL_OW 292
13749: IFFALSE 13892
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin if your_side = 1 then
13757: LD_OWVAR 2
13761: PUSH
13762: LD_INT 1
13764: EQUAL
13765: IFFALSE 13848
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13767: LD_ADDR_VAR 0 1
13771: PUSH
13772: LD_INT 22
13774: PUSH
13775: LD_INT 1
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_EXP 19
13791: DIFF
13792: ST_TO_ADDR
// if speaker then
13793: LD_VAR 0 1
13797: IFFALSE 13848
// if GetSex ( speaker [ 1 ] ) then
13799: LD_VAR 0 1
13803: PUSH
13804: LD_INT 1
13806: ARRAY
13807: PPUSH
13808: CALL_OW 258
13812: IFFALSE 13832
// Say ( speaker [ 1 ] , VD-legion-us ) else
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 1
13821: ARRAY
13822: PPUSH
13823: LD_STRING VD-legion-us
13825: PPUSH
13826: CALL_OW 88
13830: GO 13848
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13832: LD_VAR 0 1
13836: PUSH
13837: LD_INT 1
13839: ARRAY
13840: PPUSH
13841: LD_STRING VD-legion-us-f
13843: PPUSH
13844: CALL_OW 88
// end ; if your_side = 2 then
13848: LD_OWVAR 2
13852: PUSH
13853: LD_INT 2
13855: EQUAL
13856: IFFALSE 13870
// Say ( ar_commander , VD-legion-ar ) ;
13858: LD_EXP 51
13862: PPUSH
13863: LD_STRING VD-legion-ar
13865: PPUSH
13866: CALL_OW 88
// if your_side = 7 then
13870: LD_OWVAR 2
13874: PUSH
13875: LD_INT 7
13877: EQUAL
13878: IFFALSE 13892
// Say ( al_commander , VD-legion-al ) ;
13880: LD_EXP 37
13884: PPUSH
13885: LD_STRING VD-legion-al
13887: PPUSH
13888: CALL_OW 88
// end ;
13892: PPOPN 1
13894: END
// every 0 0$01 trigger mine_vulc do
13895: LD_EXP 12
13899: IFFALSE 13916
13901: GO 13903
13903: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13904: LD_EXP 10
13908: PPUSH
13909: LD_STRING VD-vulc-mines
13911: PPUSH
13912: CALL_OW 88
// end ;
13916: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13917: LD_OWVAR 67
13921: PUSH
13922: LD_INT 1
13924: GREATER
13925: IFFALSE 14044
13927: GO 13929
13929: DISABLE
13930: LD_INT 0
13932: PPUSH
13933: PPUSH
13934: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13935: LD_ADDR_VAR 0 1
13939: PUSH
13940: LD_INT 123
13942: PUSH
13943: LD_INT 95
13945: PUSH
13946: LD_INT 119
13948: PUSH
13949: LD_INT 89
13951: PUSH
13952: LD_INT 115
13954: PUSH
13955: LD_INT 81
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: ST_TO_ADDR
// p := 1 ;
13966: LD_ADDR_VAR 0 2
13970: PUSH
13971: LD_INT 1
13973: ST_TO_ADDR
// for i = 1 to 3 do
13974: LD_ADDR_VAR 0 3
13978: PUSH
13979: DOUBLE
13980: LD_INT 1
13982: DEC
13983: ST_TO_ADDR
13984: LD_INT 3
13986: PUSH
13987: FOR_TO
13988: IFFALSE 14042
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13990: LD_VAR 0 1
13994: PUSH
13995: LD_VAR 0 2
13999: ARRAY
14000: PPUSH
14001: LD_VAR 0 1
14005: PUSH
14006: LD_VAR 0 2
14010: PUSH
14011: LD_INT 1
14013: PLUS
14014: ARRAY
14015: PPUSH
14016: LD_INT 8
14018: PPUSH
14019: LD_INT 0
14021: PPUSH
14022: CALL_OW 454
// p := p + 2 ;
14026: LD_ADDR_VAR 0 2
14030: PUSH
14031: LD_VAR 0 2
14035: PUSH
14036: LD_INT 2
14038: PLUS
14039: ST_TO_ADDR
// end ;
14040: GO 13987
14042: POP
14043: POP
// end ;
14044: PPOPN 3
14046: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14047: LD_OWVAR 67
14051: PUSH
14052: LD_INT 1
14054: GREATER
14055: PUSH
14056: LD_INT 22
14058: PPUSH
14059: LD_INT 22
14061: PUSH
14062: LD_OWVAR 2
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PPUSH
14071: CALL_OW 70
14075: AND
14076: IFFALSE 14280
14078: GO 14080
14080: DISABLE
14081: LD_INT 0
14083: PPUSH
14084: PPUSH
14085: PPUSH
// begin enable ;
14086: ENABLE
// p := 1 ;
14087: LD_ADDR_VAR 0 1
14091: PUSH
14092: LD_INT 1
14094: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14095: LD_ADDR_VAR 0 3
14099: PUSH
14100: LD_INT 123
14102: PUSH
14103: LD_INT 95
14105: PUSH
14106: LD_INT 119
14108: PUSH
14109: LD_INT 89
14111: PUSH
14112: LD_INT 115
14114: PUSH
14115: LD_INT 81
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: ST_TO_ADDR
// for i = 1 to 3 do
14126: LD_ADDR_VAR 0 2
14130: PUSH
14131: DOUBLE
14132: LD_INT 1
14134: DEC
14135: ST_TO_ADDR
14136: LD_INT 3
14138: PUSH
14139: FOR_TO
14140: IFFALSE 14278
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14142: LD_VAR 0 3
14146: PUSH
14147: LD_VAR 0 1
14151: ARRAY
14152: PPUSH
14153: LD_VAR 0 3
14157: PUSH
14158: LD_VAR 0 1
14162: PUSH
14163: LD_INT 1
14165: PLUS
14166: ARRAY
14167: PPUSH
14168: CALL_OW 428
14172: PUSH
14173: LD_INT 0
14175: GREATER
14176: IFFALSE 14262
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14178: LD_VAR 0 3
14182: PUSH
14183: LD_VAR 0 1
14187: ARRAY
14188: PPUSH
14189: LD_VAR 0 3
14193: PUSH
14194: LD_VAR 0 1
14198: PUSH
14199: LD_INT 1
14201: PLUS
14202: ARRAY
14203: PPUSH
14204: CALL_OW 428
14208: PPUSH
14209: CALL_OW 255
14213: PUSH
14214: LD_OWVAR 2
14218: EQUAL
14219: IFFALSE 14262
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14221: LD_VAR 0 3
14225: PUSH
14226: LD_VAR 0 1
14230: ARRAY
14231: PPUSH
14232: LD_VAR 0 3
14236: PUSH
14237: LD_VAR 0 1
14241: PUSH
14242: LD_INT 1
14244: PLUS
14245: ARRAY
14246: PPUSH
14247: LD_INT 8
14249: PPUSH
14250: CALL_OW 456
// mine_vulc := true ;
14254: LD_ADDR_EXP 12
14258: PUSH
14259: LD_INT 1
14261: ST_TO_ADDR
// end ; p := p + 2 ;
14262: LD_ADDR_VAR 0 1
14266: PUSH
14267: LD_VAR 0 1
14271: PUSH
14272: LD_INT 2
14274: PLUS
14275: ST_TO_ADDR
// end ;
14276: GO 14139
14278: POP
14279: POP
// end ;
14280: PPOPN 3
14282: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14283: LD_INT 22
14285: PUSH
14286: LD_INT 3
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: PPUSH
14293: CALL_OW 69
14297: PUSH
14298: LD_INT 0
14300: EQUAL
14301: PUSH
14302: LD_OWVAR 2
14306: PUSH
14307: LD_INT 2
14309: NONEQUAL
14310: AND
14311: IFFALSE 14320
14313: GO 14315
14315: DISABLE
// Win ;
14316: CALL 14377 0 0
14320: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14321: LD_INT 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 8
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 22
14336: PUSH
14337: LD_INT 3
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: PPUSH
14349: CALL_OW 69
14353: PUSH
14354: LD_INT 0
14356: EQUAL
14357: PUSH
14358: LD_OWVAR 2
14362: PUSH
14363: LD_INT 2
14365: EQUAL
14366: AND
14367: IFFALSE 14376
14369: GO 14371
14371: DISABLE
// Win ;
14372: CALL 14377 0 0
14376: END
// function Win ; var points ; begin
14377: LD_INT 0
14379: PPUSH
14380: PPUSH
// case Query ( VulcWin ) of 1 :
14381: LD_STRING VulcWin
14383: PPUSH
14384: CALL_OW 97
14388: PUSH
14389: LD_INT 1
14391: DOUBLE
14392: EQUAL
14393: IFTRUE 14397
14395: GO 14400
14397: POP
// ; end ;
14398: GO 14401
14400: POP
// if medal_enabled then
14401: LD_EXP 13
14405: IFFALSE 14419
// AddMedal ( vulc_1 , 1 ) else
14407: LD_STRING vulc_1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: CALL_OW 101
14417: GO 14430
// AddMedal ( vulc_1 , - 1 ) ;
14419: LD_STRING vulc_1
14421: PPUSH
14422: LD_INT 1
14424: NEG
14425: PPUSH
14426: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14430: LD_INT 22
14432: PUSH
14433: LD_INT 8
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 69
14444: PUSH
14445: LD_INT 0
14447: EQUAL
14448: IFFALSE 14462
// AddMedal ( vulc_2 , 1 ) else
14450: LD_STRING vulc_2
14452: PPUSH
14453: LD_INT 1
14455: PPUSH
14456: CALL_OW 101
14460: GO 14473
// AddMedal ( vulc_2 , - 1 ) ;
14462: LD_STRING vulc_2
14464: PPUSH
14465: LD_INT 1
14467: NEG
14468: PPUSH
14469: CALL_OW 101
// points := CalculateCommanderPoints ;
14473: LD_ADDR_VAR 0 2
14477: PUSH
14478: CALL 2266 0 0
14482: ST_TO_ADDR
// if points >= 2000 then
14483: LD_VAR 0 2
14487: PUSH
14488: LD_INT 2000
14490: GREATEREQUAL
14491: IFFALSE 14505
// AddMedal ( vulc_3 , 2 ) else
14493: LD_STRING vulc_3
14495: PPUSH
14496: LD_INT 2
14498: PPUSH
14499: CALL_OW 101
14503: GO 14538
// if points >= 0 then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 0
14512: GREATEREQUAL
14513: IFFALSE 14527
// AddMedal ( vulc_3 , 1 ) else
14515: LD_STRING vulc_3
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 101
14525: GO 14538
// AddMedal ( vulc_3 , - 1 ) ;
14527: LD_STRING vulc_3
14529: PPUSH
14530: LD_INT 1
14532: NEG
14533: PPUSH
14534: CALL_OW 101
// GiveMedals ( MAIN ) ;
14538: LD_STRING MAIN
14540: PPUSH
14541: CALL_OW 102
// YouWin ;
14545: CALL_OW 103
// end ; end_of_file
14549: LD_VAR 0 1
14553: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14554: LD_INT 13
14556: PPUSH
14557: LD_INT 21
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PPUSH
14567: CALL_OW 70
14571: PUSH
14572: LD_INT 0
14574: GREATER
14575: IFFALSE 14642
14577: GO 14579
14579: DISABLE
14580: LD_INT 0
14582: PPUSH
14583: PPUSH
// begin enable ;
14584: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_INT 13
14592: PPUSH
14593: LD_INT 21
14595: PUSH
14596: LD_INT 1
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 70
14607: PUSH
14608: FOR_IN
14609: IFFALSE 14640
// if GetLives ( i ) > 4 then
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 256
14620: PUSH
14621: LD_INT 4
14623: GREATER
14624: IFFALSE 14638
// SetLives ( i , 4 ) ;
14626: LD_VAR 0 1
14630: PPUSH
14631: LD_INT 4
14633: PPUSH
14634: CALL_OW 234
14638: GO 14608
14640: POP
14641: POP
// end ;
14642: PPOPN 2
14644: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14645: LD_VAR 0 1
14649: PPUSH
14650: CALL_OW 255
14654: PUSH
14655: LD_OWVAR 2
14659: EQUAL
14660: IFFALSE 14670
// player_res_art := true ;
14662: LD_ADDR_EXP 6
14666: PUSH
14667: LD_INT 1
14669: ST_TO_ADDR
// end ;
14670: PPOPN 1
14672: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14673: LD_INT 22
14675: PUSH
14676: LD_OWVAR 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: LD_INT 2
14687: PUSH
14688: LD_INT 30
14690: PUSH
14691: LD_INT 8
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: LD_INT 30
14700: PUSH
14701: LD_INT 11
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: PPUSH
14717: CALL_OW 69
14721: PUSH
14722: LD_EXP 6
14726: AND
14727: IFFALSE 15071
14729: GO 14731
14731: DISABLE
14732: LD_INT 0
14734: PPUSH
14735: PPUSH
14736: PPUSH
// begin enable ;
14737: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14738: LD_ADDR_VAR 0 1
14742: PUSH
14743: LD_INT 1
14745: PPUSH
14746: CALL_OW 469
14750: PUSH
14751: LD_INT 1
14753: ARRAY
14754: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14755: LD_ADDR_VAR 0 2
14759: PUSH
14760: LD_INT 1
14762: PPUSH
14763: CALL_OW 469
14767: PUSH
14768: LD_INT 2
14770: ARRAY
14771: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14772: LD_ADDR_VAR 0 3
14776: PUSH
14777: LD_INT 22
14779: PUSH
14780: LD_OWVAR 2
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PUSH
14789: LD_INT 2
14791: PUSH
14792: LD_INT 30
14794: PUSH
14795: LD_INT 8
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 30
14804: PUSH
14805: LD_INT 11
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: EMPTY
14813: LIST
14814: LIST
14815: LIST
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: PPUSH
14821: CALL_OW 69
14825: PPUSH
14826: LD_VAR 0 1
14830: PPUSH
14831: LD_VAR 0 2
14835: PPUSH
14836: CALL_OW 73
14840: ST_TO_ADDR
// if player_artifact_ready = false then
14841: LD_EXP 7
14845: PUSH
14846: LD_INT 0
14848: EQUAL
14849: IFFALSE 14955
// if GetDistUnitXY ( lab , x , y ) < 6 then
14851: LD_VAR 0 3
14855: PPUSH
14856: LD_VAR 0 1
14860: PPUSH
14861: LD_VAR 0 2
14865: PPUSH
14866: CALL_OW 297
14870: PUSH
14871: LD_INT 6
14873: LESS
14874: IFFALSE 14935
// begin if BuildingStatus ( lab ) = bs_idle then
14876: LD_VAR 0 3
14880: PPUSH
14881: CALL_OW 461
14885: PUSH
14886: LD_INT 2
14888: EQUAL
14889: IFFALSE 14913
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14891: LD_OWVAR 2
14895: PPUSH
14896: LD_INT 1
14898: PPUSH
14899: LD_INT 2
14901: PPUSH
14902: LD_VAR 0 3
14906: PPUSH
14907: CALL_OW 468
14911: GO 14933
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14913: LD_OWVAR 2
14917: PPUSH
14918: LD_INT 1
14920: PPUSH
14921: LD_INT 1
14923: PPUSH
14924: LD_VAR 0 3
14928: PPUSH
14929: CALL_OW 468
// end else
14933: GO 14955
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14935: LD_OWVAR 2
14939: PPUSH
14940: LD_INT 1
14942: PPUSH
14943: LD_INT 1
14945: PPUSH
14946: LD_VAR 0 3
14950: PPUSH
14951: CALL_OW 468
// if player_artifact_ready then
14955: LD_EXP 7
14959: IFFALSE 15071
// if GetDistUnitXY ( lab , x , y ) < 6 then
14961: LD_VAR 0 3
14965: PPUSH
14966: LD_VAR 0 1
14970: PPUSH
14971: LD_VAR 0 2
14975: PPUSH
14976: CALL_OW 297
14980: PUSH
14981: LD_INT 6
14983: LESS
14984: IFFALSE 15049
// begin if BuildingStatus ( lab ) = bs_idle then
14986: LD_VAR 0 3
14990: PPUSH
14991: CALL_OW 461
14995: PUSH
14996: LD_INT 2
14998: EQUAL
14999: IFFALSE 15025
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
15001: LD_OWVAR 2
15005: PPUSH
15006: LD_EXP 8
15010: PPUSH
15011: LD_INT 4
15013: PPUSH
15014: LD_VAR 0 3
15018: PPUSH
15019: CALL_OW 468
15023: GO 15047
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15025: LD_OWVAR 2
15029: PPUSH
15030: LD_EXP 8
15034: PPUSH
15035: LD_INT 1
15037: PPUSH
15038: LD_VAR 0 3
15042: PPUSH
15043: CALL_OW 468
// end else
15047: GO 15071
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15049: LD_OWVAR 2
15053: PPUSH
15054: LD_EXP 8
15058: PPUSH
15059: LD_INT 1
15061: PPUSH
15062: LD_VAR 0 3
15066: PPUSH
15067: CALL_OW 468
// end ;
15071: PPOPN 3
15073: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15074: LD_INT 0
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
15080: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15081: LD_ADDR_VAR 0 5
15085: PUSH
15086: LD_INT 1
15088: PPUSH
15089: CALL_OW 469
15093: PUSH
15094: LD_INT 1
15096: ARRAY
15097: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15098: LD_ADDR_VAR 0 6
15102: PUSH
15103: LD_INT 1
15105: PPUSH
15106: CALL_OW 469
15110: PUSH
15111: LD_INT 2
15113: ARRAY
15114: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15115: LD_ADDR_VAR 0 8
15119: PUSH
15120: LD_INT 22
15122: PUSH
15123: LD_OWVAR 2
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PUSH
15132: LD_INT 2
15134: PUSH
15135: LD_INT 30
15137: PUSH
15138: LD_INT 8
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 30
15147: PUSH
15148: LD_INT 11
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: LIST
15159: PUSH
15160: EMPTY
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PPUSH
15169: LD_VAR 0 5
15173: PPUSH
15174: LD_VAR 0 6
15178: PPUSH
15179: CALL_OW 73
15183: ST_TO_ADDR
// if icon = art_exp_left then
15184: LD_VAR 0 2
15188: PUSH
15189: LD_INT 1
15191: EQUAL
15192: IFFALSE 15231
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15194: LD_VAR 0 8
15198: PPUSH
15199: LD_EXP 9
15203: PPUSH
15204: LD_INT 1
15206: PPUSH
15207: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15211: LD_OWVAR 2
15215: PPUSH
15216: LD_INT 1
15218: PPUSH
15219: LD_INT 0
15221: PPUSH
15222: LD_VAR 0 8
15226: PPUSH
15227: CALL_OW 468
// end ; if icon = art_icon then
15231: LD_VAR 0 2
15235: PUSH
15236: LD_EXP 8
15240: EQUAL
15241: IFFALSE 15455
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15243: LD_VAR 0 3
15247: PUSH
15248: LD_INT 21
15250: PUSH
15251: LD_INT 3
15253: PUSH
15254: EMPTY
15255: LIST
15256: LIST
15257: PPUSH
15258: CALL_OW 69
15262: IN
15263: IFFALSE 15455
// begin side := GetSide ( cr1 ) ;
15265: LD_ADDR_VAR 0 9
15269: PUSH
15270: LD_VAR 0 3
15274: PPUSH
15275: CALL_OW 255
15279: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15280: LD_INT 22
15282: PUSH
15283: LD_VAR 0 9
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 30
15294: PUSH
15295: LD_INT 28
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PPUSH
15306: CALL_OW 69
15310: PUSH
15311: LD_INT 0
15313: GREATER
15314: IFFALSE 15455
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15316: LD_ADDR_VAR 0 7
15320: PUSH
15321: LD_INT 22
15323: PUSH
15324: LD_VAR 0 9
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 2
15335: PUSH
15336: LD_INT 30
15338: PUSH
15339: LD_INT 26
15341: PUSH
15342: EMPTY
15343: LIST
15344: LIST
15345: PUSH
15346: LD_INT 30
15348: PUSH
15349: LD_INT 27
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: PUSH
15356: LD_INT 30
15358: PUSH
15359: LD_INT 28
15361: PUSH
15362: EMPTY
15363: LIST
15364: LIST
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: PUSH
15372: EMPTY
15373: LIST
15374: LIST
15375: PPUSH
15376: CALL_OW 69
15380: PUSH
15381: FOR_IN
15382: IFFALSE 15398
// SetLives ( i , 1 ) ;
15384: LD_VAR 0 7
15388: PPUSH
15389: LD_INT 1
15391: PPUSH
15392: CALL_OW 234
15396: GO 15381
15398: POP
15399: POP
// player_res_art := false ;
15400: LD_ADDR_EXP 6
15404: PUSH
15405: LD_INT 0
15407: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15408: LD_OWVAR 2
15412: PPUSH
15413: LD_EXP 8
15417: PPUSH
15418: LD_INT 1
15420: PPUSH
15421: LD_VAR 0 8
15425: PPUSH
15426: CALL_OW 468
// Wait ( time_to_reuse ) ;
15430: LD_EXP 11
15434: PPUSH
15435: CALL_OW 67
// player_res_art := true ;
15439: LD_ADDR_EXP 6
15443: PUSH
15444: LD_INT 1
15446: ST_TO_ADDR
// medal_enabled := true ;
15447: LD_ADDR_EXP 13
15451: PUSH
15452: LD_INT 1
15454: ST_TO_ADDR
// end ; end ; end ; end ;
15455: PPOPN 9
15457: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15458: LD_VAR 0 1
15462: PPUSH
15463: CALL_OW 255
15467: PUSH
15468: LD_OWVAR 2
15472: EQUAL
15473: IFFALSE 15510
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15475: LD_OWVAR 2
15479: PPUSH
15480: LD_INT 1
15482: PPUSH
15483: LD_INT 0
15485: PPUSH
15486: LD_VAR 0 1
15490: PPUSH
15491: CALL_OW 468
// player_artifact_ready := true ;
15495: LD_ADDR_EXP 7
15499: PUSH
15500: LD_INT 1
15502: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15503: LD_STRING ArtVulcano
15505: PPUSH
15506: CALL_OW 339
// end ; end ;
15510: PPOPN 1
15512: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15513: LD_OWVAR 2
15517: PPUSH
15518: LD_INT 1
15520: PPUSH
15521: LD_INT 2
15523: PPUSH
15524: LD_VAR 0 1
15528: PPUSH
15529: CALL_OW 468
// end ; end_of_file
15533: PPOPN 2
15535: END
// every 0 0$01 do
15536: GO 15538
15538: DISABLE
// begin enable ;
15539: ENABLE
// Display_Strings := [ #tick , tick ] ;
15540: LD_ADDR_OWVAR 47
15544: PUSH
15545: LD_STRING #tick
15547: PUSH
15548: LD_OWVAR 1
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: ST_TO_ADDR
// end ; end_of_file
15557: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15558: LD_INT 0
15560: PPUSH
15561: PPUSH
15562: PPUSH
15563: PPUSH
15564: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15565: LD_ADDR_EXP 39
15569: PUSH
15570: LD_INT 7
15572: PUSH
15573: LD_INT 6
15575: PUSH
15576: LD_INT 5
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: PUSH
15584: LD_OWVAR 67
15588: ARRAY
15589: ST_TO_ADDR
// al_force := [ ] ;
15590: LD_ADDR_EXP 38
15594: PUSH
15595: EMPTY
15596: ST_TO_ADDR
// RemoveAlliance ;
15597: CALL 15975 0 0
// ResetFog ;
15601: CALL_OW 335
// your_side := 7 ;
15605: LD_ADDR_OWVAR 2
15609: PUSH
15610: LD_INT 7
15612: ST_TO_ADDR
// uc_side := 7 ;
15613: LD_ADDR_OWVAR 20
15617: PUSH
15618: LD_INT 7
15620: ST_TO_ADDR
// hc_gallery :=  ;
15621: LD_ADDR_OWVAR 33
15625: PUSH
15626: LD_STRING 
15628: ST_TO_ADDR
// hc_name :=  ;
15629: LD_ADDR_OWVAR 26
15633: PUSH
15634: LD_STRING 
15636: ST_TO_ADDR
// hc_importance := 0 ;
15637: LD_ADDR_OWVAR 32
15641: PUSH
15642: LD_INT 0
15644: ST_TO_ADDR
// for i = 1 to 17 do
15645: LD_ADDR_VAR 0 2
15649: PUSH
15650: DOUBLE
15651: LD_INT 1
15653: DEC
15654: ST_TO_ADDR
15655: LD_INT 17
15657: PUSH
15658: FOR_TO
15659: IFFALSE 15739
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15661: LD_ADDR_OWVAR 21
15665: PUSH
15666: LD_INT 1
15668: PUSH
15669: LD_INT 3
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: PUSH
15676: LD_INT 1
15678: PPUSH
15679: LD_INT 2
15681: PPUSH
15682: CALL_OW 12
15686: ARRAY
15687: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15688: LD_INT 0
15690: PPUSH
15691: LD_INT 1
15693: PPUSH
15694: LD_INT 4
15696: PPUSH
15697: CALL_OW 12
15701: PPUSH
15702: LD_EXP 39
15706: PPUSH
15707: CALL_OW 380
// un := CreateHuman ;
15711: LD_ADDR_VAR 0 4
15715: PUSH
15716: CALL_OW 44
15720: ST_TO_ADDR
// al_force := al_force ^ un ;
15721: LD_ADDR_EXP 38
15725: PUSH
15726: LD_EXP 38
15730: PUSH
15731: LD_VAR 0 4
15735: ADD
15736: ST_TO_ADDR
// end ;
15737: GO 15658
15739: POP
15740: POP
// hc_importance := 100 ;
15741: LD_ADDR_OWVAR 32
15745: PUSH
15746: LD_INT 100
15748: ST_TO_ADDR
// uc_nation := 1 ;
15749: LD_ADDR_OWVAR 21
15753: PUSH
15754: LD_INT 1
15756: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 1
15762: PPUSH
15763: LD_EXP 39
15767: PPUSH
15768: CALL_OW 380
// al_commander := CreateHuman ;
15772: LD_ADDR_EXP 37
15776: PUSH
15777: CALL_OW 44
15781: ST_TO_ADDR
// player_commander := al_commander ;
15782: LD_ADDR_EXP 10
15786: PUSH
15787: LD_EXP 37
15791: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15792: LD_ADDR_VAR 0 5
15796: PUSH
15797: LD_STRING text
15799: PPUSH
15800: LD_INT 9
15802: PUSH
15803: LD_INT 9
15805: PUSH
15806: LD_INT 8
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: LIST
15813: PUSH
15814: LD_OWVAR 67
15818: ARRAY
15819: PPUSH
15820: LD_INT 9
15822: PUSH
15823: LD_INT 9
15825: PUSH
15826: LD_INT 8
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: PUSH
15834: LD_OWVAR 67
15838: ARRAY
15839: PPUSH
15840: LD_INT -5
15842: PUSH
15843: LD_EXP 37
15847: PUSH
15848: LD_INT -3
15850: PUSH
15851: LD_INT -2
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: LIST
15858: LIST
15859: PUSH
15860: LD_EXP 38
15864: ADD
15865: PPUSH
15866: LD_INT 1
15868: PUSH
15869: LD_INT 3
15871: PUSH
15872: LD_INT 2
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: LD_INT 4
15884: PUSH
15885: LD_INT 1
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: PUSH
15892: LD_INT 9
15894: PUSH
15895: LD_INT 5
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: LIST
15903: LIST
15904: LIST
15905: PPUSH
15906: CALL_OW 42
15910: ST_TO_ADDR
// team := team ^ al_commander ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_VAR 0 5
15920: PUSH
15921: LD_EXP 37
15925: ADD
15926: ST_TO_ADDR
// for i = 1 to team do
15927: LD_ADDR_VAR 0 2
15931: PUSH
15932: DOUBLE
15933: LD_INT 1
15935: DEC
15936: ST_TO_ADDR
15937: LD_VAR 0 5
15941: PUSH
15942: FOR_TO
15943: IFFALSE 15968
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15945: LD_VAR 0 5
15949: PUSH
15950: LD_VAR 0 2
15954: ARRAY
15955: PPUSH
15956: LD_INT 15
15958: PPUSH
15959: LD_INT 0
15961: PPUSH
15962: CALL_OW 49
15966: GO 15942
15968: POP
15969: POP
// end ;
15970: LD_VAR 0 1
15974: RET
// export function RemoveAlliance ; var i ; begin
15975: LD_INT 0
15977: PPUSH
15978: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15979: LD_INT 22
15981: PUSH
15982: LD_INT 7
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: PUSH
15989: LD_INT 30
15991: PUSH
15992: LD_INT 1
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: PUSH
16008: LD_INT 1
16010: ARRAY
16011: PPUSH
16012: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16016: LD_ADDR_VAR 0 2
16020: PUSH
16021: LD_INT 22
16023: PUSH
16024: LD_INT 7
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PPUSH
16031: CALL_OW 69
16035: PUSH
16036: FOR_IN
16037: IFFALSE 16050
// RemoveUnit ( i ) ;
16039: LD_VAR 0 2
16043: PPUSH
16044: CALL_OW 64
16048: GO 16036
16050: POP
16051: POP
// end ;
16052: LD_VAR 0 1
16056: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16057: LD_INT 0
16059: PPUSH
16060: PPUSH
16061: PPUSH
16062: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16063: LD_INT 31
16065: PPUSH
16066: LD_INT 7
16068: PPUSH
16069: LD_INT 2
16071: PPUSH
16072: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16076: LD_INT 32
16078: PPUSH
16079: LD_INT 7
16081: PPUSH
16082: LD_INT 2
16084: PPUSH
16085: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16089: LD_INT 59
16091: PPUSH
16092: LD_INT 7
16094: PPUSH
16095: LD_INT 2
16097: PPUSH
16098: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16102: LD_ADDR_EXP 39
16106: PUSH
16107: LD_INT 5
16109: PUSH
16110: LD_INT 6
16112: PUSH
16113: LD_INT 7
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: LIST
16120: PUSH
16121: LD_OWVAR 67
16125: ARRAY
16126: ST_TO_ADDR
// al_force := [ ] ;
16127: LD_ADDR_EXP 38
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// al_vehs := [ ] ;
16134: LD_ADDR_EXP 44
16138: PUSH
16139: EMPTY
16140: ST_TO_ADDR
// uc_side := 7 ;
16141: LD_ADDR_OWVAR 20
16145: PUSH
16146: LD_INT 7
16148: ST_TO_ADDR
// uc_nation := 1 ;
16149: LD_ADDR_OWVAR 21
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// bc_type := b_oil_mine ;
16157: LD_ADDR_OWVAR 42
16161: PUSH
16162: LD_INT 29
16164: ST_TO_ADDR
// b := CreateBuilding ;
16165: LD_ADDR_VAR 0 4
16169: PUSH
16170: CALL_OW 46
16174: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16175: LD_VAR 0 4
16179: PPUSH
16180: LD_INT 61
16182: PPUSH
16183: LD_INT 7
16185: PPUSH
16186: LD_INT 0
16188: PPUSH
16189: LD_INT 0
16191: PPUSH
16192: CALL_OW 50
// bc_type := b_siberite_mine ;
16196: LD_ADDR_OWVAR 42
16200: PUSH
16201: LD_INT 30
16203: ST_TO_ADDR
// b := CreateBuilding ;
16204: LD_ADDR_VAR 0 4
16208: PUSH
16209: CALL_OW 46
16213: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16214: LD_VAR 0 4
16218: PPUSH
16219: LD_INT 69
16221: PPUSH
16222: LD_INT 13
16224: PPUSH
16225: LD_INT 0
16227: PPUSH
16228: LD_INT 0
16230: PPUSH
16231: CALL_OW 50
// hc_gallery :=  ;
16235: LD_ADDR_OWVAR 33
16239: PUSH
16240: LD_STRING 
16242: ST_TO_ADDR
// hc_name :=  ;
16243: LD_ADDR_OWVAR 26
16247: PUSH
16248: LD_STRING 
16250: ST_TO_ADDR
// hc_importance := 0 ;
16251: LD_ADDR_OWVAR 32
16255: PUSH
16256: LD_INT 0
16258: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16259: LD_ADDR_VAR 0 2
16263: PUSH
16264: LD_INT 22
16266: PUSH
16267: LD_INT 7
16269: PUSH
16270: EMPTY
16271: LIST
16272: LIST
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 32
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PPUSH
16288: CALL_OW 69
16292: PUSH
16293: FOR_IN
16294: IFFALSE 16364
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16296: LD_ADDR_OWVAR 21
16300: PUSH
16301: LD_INT 1
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: LD_INT 1
16313: PPUSH
16314: LD_INT 2
16316: PPUSH
16317: CALL_OW 12
16321: ARRAY
16322: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16323: LD_INT 0
16325: PPUSH
16326: LD_INT 1
16328: PPUSH
16329: LD_EXP 39
16333: PPUSH
16334: CALL_OW 380
// un := CreateHuman ;
16338: LD_ADDR_VAR 0 3
16342: PUSH
16343: CALL_OW 44
16347: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16348: LD_VAR 0 3
16352: PPUSH
16353: LD_VAR 0 2
16357: PPUSH
16358: CALL_OW 52
// end ;
16362: GO 16293
16364: POP
16365: POP
// for i = 1 to 3 do
16366: LD_ADDR_VAR 0 2
16370: PUSH
16371: DOUBLE
16372: LD_INT 1
16374: DEC
16375: ST_TO_ADDR
16376: LD_INT 3
16378: PUSH
16379: FOR_TO
16380: IFFALSE 16448
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16382: LD_ADDR_OWVAR 21
16386: PUSH
16387: LD_INT 1
16389: PUSH
16390: LD_INT 3
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 1
16399: PPUSH
16400: LD_INT 2
16402: PPUSH
16403: CALL_OW 12
16407: ARRAY
16408: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16409: LD_INT 0
16411: PPUSH
16412: LD_INT 4
16414: PPUSH
16415: LD_EXP 39
16419: PPUSH
16420: CALL_OW 380
// un := CreateHuman ;
16424: LD_ADDR_VAR 0 3
16428: PUSH
16429: CALL_OW 44
16433: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16434: LD_VAR 0 3
16438: PPUSH
16439: LD_INT 164
16441: PPUSH
16442: CALL_OW 52
// end ;
16446: GO 16379
16448: POP
16449: POP
// for i = 1 to 6 do
16450: LD_ADDR_VAR 0 2
16454: PUSH
16455: DOUBLE
16456: LD_INT 1
16458: DEC
16459: ST_TO_ADDR
16460: LD_INT 6
16462: PUSH
16463: FOR_TO
16464: IFFALSE 16555
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16466: LD_ADDR_OWVAR 21
16470: PUSH
16471: LD_INT 1
16473: PUSH
16474: LD_INT 3
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: PUSH
16481: LD_INT 1
16483: PPUSH
16484: LD_INT 2
16486: PPUSH
16487: CALL_OW 12
16491: ARRAY
16492: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16493: LD_INT 0
16495: PPUSH
16496: LD_INT 5
16498: PUSH
16499: LD_INT 9
16501: PUSH
16502: LD_INT 9
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: LIST
16509: PUSH
16510: LD_INT 1
16512: PPUSH
16513: LD_INT 3
16515: PPUSH
16516: CALL_OW 12
16520: ARRAY
16521: PPUSH
16522: LD_EXP 39
16526: PPUSH
16527: CALL_OW 380
// un := CreateHuman ;
16531: LD_ADDR_VAR 0 3
16535: PUSH
16536: CALL_OW 44
16540: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16541: LD_VAR 0 3
16545: PPUSH
16546: LD_INT 173
16548: PPUSH
16549: CALL_OW 52
// end ;
16553: GO 16463
16555: POP
16556: POP
// for i = 1 to 6 do
16557: LD_ADDR_VAR 0 2
16561: PUSH
16562: DOUBLE
16563: LD_INT 1
16565: DEC
16566: ST_TO_ADDR
16567: LD_INT 6
16569: PUSH
16570: FOR_TO
16571: IFFALSE 16669
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16573: LD_ADDR_OWVAR 21
16577: PUSH
16578: LD_INT 1
16580: PUSH
16581: LD_INT 3
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PUSH
16588: LD_INT 1
16590: PPUSH
16591: LD_INT 2
16593: PPUSH
16594: CALL_OW 12
16598: ARRAY
16599: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16600: LD_INT 0
16602: PPUSH
16603: LD_INT 3
16605: PPUSH
16606: LD_EXP 39
16610: PPUSH
16611: CALL_OW 380
// un := CreateHuman ;
16615: LD_ADDR_VAR 0 3
16619: PUSH
16620: CALL_OW 44
16624: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16625: LD_VAR 0 3
16629: PPUSH
16630: LD_INT 22
16632: PUSH
16633: LD_INT 7
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: LD_INT 30
16642: PUSH
16643: LD_INT 3
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PPUSH
16654: CALL_OW 69
16658: PUSH
16659: LD_INT 1
16661: ARRAY
16662: PPUSH
16663: CALL_OW 52
// end ;
16667: GO 16570
16669: POP
16670: POP
// for i = 1 to 4 do
16671: LD_ADDR_VAR 0 2
16675: PUSH
16676: DOUBLE
16677: LD_INT 1
16679: DEC
16680: ST_TO_ADDR
16681: LD_INT 4
16683: PUSH
16684: FOR_TO
16685: IFFALSE 16753
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16687: LD_ADDR_OWVAR 21
16691: PUSH
16692: LD_INT 1
16694: PUSH
16695: LD_INT 3
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: PUSH
16702: LD_INT 1
16704: PPUSH
16705: LD_INT 2
16707: PPUSH
16708: CALL_OW 12
16712: ARRAY
16713: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16714: LD_INT 0
16716: PPUSH
16717: LD_INT 2
16719: PPUSH
16720: LD_EXP 39
16724: PPUSH
16725: CALL_OW 380
// un := CreateHuman ;
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: CALL_OW 44
16738: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16739: LD_VAR 0 3
16743: PPUSH
16744: LD_INT 162
16746: PPUSH
16747: CALL_OW 52
// end ;
16751: GO 16684
16753: POP
16754: POP
// uc_nation := 3 ;
16755: LD_ADDR_OWVAR 21
16759: PUSH
16760: LD_INT 3
16762: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16763: LD_ADDR_OWVAR 37
16767: PUSH
16768: LD_INT 21
16770: ST_TO_ADDR
// vc_engine := engine_siberite ;
16771: LD_ADDR_OWVAR 39
16775: PUSH
16776: LD_INT 3
16778: ST_TO_ADDR
// vc_control := control_computer ;
16779: LD_ADDR_OWVAR 38
16783: PUSH
16784: LD_INT 3
16786: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16787: LD_ADDR_OWVAR 40
16791: PUSH
16792: LD_INT 51
16794: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16795: CALL_OW 45
16799: PPUSH
16800: LD_INT 49
16802: PPUSH
16803: LD_INT 13
16805: PPUSH
16806: LD_INT 0
16808: PPUSH
16809: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16813: LD_ADDR_EXP 46
16817: PUSH
16818: LD_INT 22
16820: PUSH
16821: LD_INT 7
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 30
16830: PUSH
16831: LD_INT 33
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PPUSH
16842: CALL_OW 69
16846: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16847: LD_ADDR_VAR 0 2
16851: PUSH
16852: DOUBLE
16853: LD_INT 1
16855: DEC
16856: ST_TO_ADDR
16857: LD_INT 22
16859: PUSH
16860: LD_INT 7
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 30
16869: PUSH
16870: LD_INT 33
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: PUSH
16877: LD_INT 35
16879: PUSH
16880: LD_INT 0
16882: PUSH
16883: EMPTY
16884: LIST
16885: LIST
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: PUSH
16892: EMPTY
16893: LIST
16894: PPUSH
16895: CALL_OW 69
16899: PUSH
16900: FOR_TO
16901: IFFALSE 16961
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16903: LD_INT 22
16905: PUSH
16906: LD_INT 7
16908: PUSH
16909: EMPTY
16910: LIST
16911: LIST
16912: PUSH
16913: LD_INT 30
16915: PUSH
16916: LD_INT 33
16918: PUSH
16919: EMPTY
16920: LIST
16921: LIST
16922: PUSH
16923: LD_INT 35
16925: PUSH
16926: LD_INT 0
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: PPUSH
16941: CALL_OW 69
16945: PUSH
16946: LD_VAR 0 2
16950: ARRAY
16951: PPUSH
16952: LD_INT 49
16954: PPUSH
16955: CALL_OW 208
16959: GO 16900
16961: POP
16962: POP
// end ;
16963: LD_VAR 0 1
16967: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16968: LD_OWVAR 2
16972: PUSH
16973: LD_INT 1
16975: EQUAL
16976: IFFALSE 18144
16978: GO 16980
16980: DISABLE
16981: LD_INT 0
16983: PPUSH
16984: PPUSH
16985: PPUSH
16986: PPUSH
// begin enable ;
16987: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16988: LD_ADDR_EXP 50
16992: PUSH
16993: LD_INT 22
16995: PUSH
16996: LD_INT 7
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PUSH
17003: LD_INT 21
17005: PUSH
17006: LD_INT 3
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: PPUSH
17017: CALL_OW 69
17021: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17022: LD_ADDR_EXP 48
17026: PUSH
17027: LD_INT 164
17029: PUSH
17030: LD_INT 197
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17037: LD_ADDR_EXP 47
17041: PUSH
17042: LD_INT 22
17044: PUSH
17045: LD_INT 7
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: PUSH
17052: LD_INT 30
17054: PUSH
17055: LD_INT 1
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: PPUSH
17066: CALL_OW 69
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17075: LD_ADDR_EXP 49
17079: PUSH
17080: LD_INT 22
17082: PUSH
17083: LD_INT 7
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 30
17092: PUSH
17093: LD_INT 3
17095: PUSH
17096: EMPTY
17097: LIST
17098: LIST
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17113: LD_INT 22
17115: PUSH
17116: LD_INT 7
17118: PUSH
17119: EMPTY
17120: LIST
17121: LIST
17122: PUSH
17123: LD_INT 34
17125: PUSH
17126: LD_INT 51
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PPUSH
17137: CALL_OW 69
17141: IFFALSE 17181
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17143: LD_ADDR_EXP 45
17147: PUSH
17148: LD_INT 22
17150: PUSH
17151: LD_INT 7
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 34
17160: PUSH
17161: LD_INT 51
17163: PUSH
17164: EMPTY
17165: LIST
17166: LIST
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PPUSH
17172: CALL_OW 69
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17181: LD_ADDR_EXP 41
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_INT 7
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 25
17198: PUSH
17199: LD_INT 9
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: PPUSH
17210: CALL_OW 69
17214: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17215: LD_ADDR_EXP 40
17219: PUSH
17220: LD_INT 22
17222: PUSH
17223: LD_INT 7
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 25
17232: PUSH
17233: LD_INT 2
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PPUSH
17244: CALL_OW 69
17248: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17249: LD_ADDR_EXP 42
17253: PUSH
17254: LD_INT 22
17256: PUSH
17257: LD_INT 7
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: LD_INT 25
17266: PUSH
17267: LD_INT 3
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PPUSH
17278: CALL_OW 69
17282: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17283: LD_ADDR_EXP 43
17287: PUSH
17288: LD_INT 22
17290: PUSH
17291: LD_INT 7
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: PUSH
17298: LD_INT 25
17300: PUSH
17301: LD_INT 4
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: PPUSH
17312: CALL_OW 69
17316: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17317: LD_EXP 41
17321: PPUSH
17322: LD_INT 81
17324: PUSH
17325: LD_INT 7
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PPUSH
17332: CALL_OW 69
17336: PPUSH
17337: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17341: LD_EXP 45
17345: PPUSH
17346: CALL_OW 314
17350: NOT
17351: PUSH
17352: LD_EXP 45
17356: PPUSH
17357: LD_INT 1
17359: PPUSH
17360: CALL_OW 289
17364: PUSH
17365: LD_INT 100
17367: LESS
17368: AND
17369: IFFALSE 17417
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17371: LD_ADDR_VAR 0 4
17375: PUSH
17376: LD_INT 12
17378: PPUSH
17379: CALL_OW 435
17383: ST_TO_ADDR
// if cr then
17384: LD_VAR 0 4
17388: IFFALSE 17417
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17390: LD_EXP 45
17394: PPUSH
17395: LD_VAR 0 4
17399: PUSH
17400: LD_INT 1
17402: ARRAY
17403: PPUSH
17404: LD_VAR 0 4
17408: PUSH
17409: LD_INT 2
17411: ARRAY
17412: PPUSH
17413: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17417: LD_EXP 50
17421: PPUSH
17422: LD_INT 3
17424: PUSH
17425: LD_INT 24
17427: PUSH
17428: LD_INT 1000
17430: PUSH
17431: EMPTY
17432: LIST
17433: LIST
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: PPUSH
17439: CALL_OW 72
17443: IFFALSE 17573
// begin if al_eng then
17445: LD_EXP 40
17449: IFFALSE 17571
// for i = 1 to al_eng do
17451: LD_ADDR_VAR 0 1
17455: PUSH
17456: DOUBLE
17457: LD_INT 1
17459: DEC
17460: ST_TO_ADDR
17461: LD_EXP 40
17465: PUSH
17466: FOR_TO
17467: IFFALSE 17569
// if IsInUnit ( al_eng [ i ] ) then
17469: LD_EXP 40
17473: PUSH
17474: LD_VAR 0 1
17478: ARRAY
17479: PPUSH
17480: CALL_OW 310
17484: IFFALSE 17503
// ComExitBuilding ( al_eng [ i ] ) else
17486: LD_EXP 40
17490: PUSH
17491: LD_VAR 0 1
17495: ARRAY
17496: PPUSH
17497: CALL_OW 122
17501: GO 17567
// if not HasTask ( al_eng [ i ] ) then
17503: LD_EXP 40
17507: PUSH
17508: LD_VAR 0 1
17512: ARRAY
17513: PPUSH
17514: CALL_OW 314
17518: NOT
17519: IFFALSE 17567
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17521: LD_EXP 40
17525: PUSH
17526: LD_VAR 0 1
17530: ARRAY
17531: PPUSH
17532: LD_EXP 50
17536: PPUSH
17537: LD_INT 3
17539: PUSH
17540: LD_INT 24
17542: PUSH
17543: LD_INT 1000
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: EMPTY
17551: LIST
17552: LIST
17553: PPUSH
17554: CALL_OW 72
17558: PUSH
17559: LD_INT 1
17561: ARRAY
17562: PPUSH
17563: CALL_OW 130
17567: GO 17466
17569: POP
17570: POP
// end else
17571: GO 17655
// if al_eng then
17573: LD_EXP 40
17577: IFFALSE 17655
// if not IsInUnit ( al_eng [ 1 ] ) then
17579: LD_EXP 40
17583: PUSH
17584: LD_INT 1
17586: ARRAY
17587: PPUSH
17588: CALL_OW 310
17592: NOT
17593: IFFALSE 17655
// for i = 1 to al_eng do
17595: LD_ADDR_VAR 0 1
17599: PUSH
17600: DOUBLE
17601: LD_INT 1
17603: DEC
17604: ST_TO_ADDR
17605: LD_EXP 40
17609: PUSH
17610: FOR_TO
17611: IFFALSE 17653
// if not IsInUnit ( al_eng [ i ] ) then
17613: LD_EXP 40
17617: PUSH
17618: LD_VAR 0 1
17622: ARRAY
17623: PPUSH
17624: CALL_OW 310
17628: NOT
17629: IFFALSE 17651
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17631: LD_EXP 40
17635: PUSH
17636: LD_VAR 0 1
17640: ARRAY
17641: PPUSH
17642: LD_EXP 47
17646: PPUSH
17647: CALL_OW 120
17651: GO 17610
17653: POP
17654: POP
// if al_vehs then
17655: LD_EXP 44
17659: IFFALSE 17759
// if BuildingStatus ( al_fac ) = bs_idle then
17661: LD_EXP 49
17665: PPUSH
17666: CALL_OW 461
17670: PUSH
17671: LD_INT 2
17673: EQUAL
17674: IFFALSE 17759
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17676: LD_EXP 49
17680: PPUSH
17681: LD_EXP 44
17685: PUSH
17686: LD_INT 1
17688: ARRAY
17689: PPUSH
17690: LD_EXP 44
17694: PUSH
17695: LD_INT 2
17697: ARRAY
17698: PPUSH
17699: LD_EXP 44
17703: PUSH
17704: LD_INT 3
17706: ARRAY
17707: PPUSH
17708: LD_EXP 44
17712: PUSH
17713: LD_INT 4
17715: ARRAY
17716: PPUSH
17717: CALL_OW 125
// for i = 1 to 4 do
17721: LD_ADDR_VAR 0 1
17725: PUSH
17726: DOUBLE
17727: LD_INT 1
17729: DEC
17730: ST_TO_ADDR
17731: LD_INT 4
17733: PUSH
17734: FOR_TO
17735: IFFALSE 17757
// al_vehs := Delete ( al_vehs , 1 ) ;
17737: LD_ADDR_EXP 44
17741: PUSH
17742: LD_EXP 44
17746: PPUSH
17747: LD_INT 1
17749: PPUSH
17750: CALL_OW 3
17754: ST_TO_ADDR
17755: GO 17734
17757: POP
17758: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17759: LD_EXP 38
17763: PUSH
17764: LD_INT 0
17766: EQUAL
17767: PUSH
17768: LD_OWVAR 1
17772: PUSH
17773: LD_INT 23100
17775: MOD
17776: PUSH
17777: LD_INT 0
17779: EQUAL
17780: AND
17781: IFFALSE 17895
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17783: LD_ADDR_VAR 0 1
17787: PUSH
17788: DOUBLE
17789: LD_INT 1
17791: DEC
17792: ST_TO_ADDR
17793: LD_INT 4
17795: PUSH
17796: LD_INT 5
17798: PUSH
17799: LD_INT 6
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: LIST
17806: PUSH
17807: LD_OWVAR 67
17811: ARRAY
17812: PUSH
17813: FOR_TO
17814: IFFALSE 17893
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17816: LD_ADDR_EXP 44
17820: PUSH
17821: LD_EXP 44
17825: PUSH
17826: LD_INT 23
17828: ADD
17829: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17830: LD_ADDR_EXP 44
17834: PUSH
17835: LD_EXP 44
17839: PUSH
17840: LD_INT 1
17842: ADD
17843: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17844: LD_ADDR_EXP 44
17848: PUSH
17849: LD_EXP 44
17853: PUSH
17854: LD_INT 3
17856: ADD
17857: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17858: LD_ADDR_EXP 44
17862: PUSH
17863: LD_EXP 44
17867: PUSH
17868: LD_INT 46
17870: PUSH
17871: LD_INT 47
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: LD_INT 1
17880: PPUSH
17881: LD_INT 2
17883: PPUSH
17884: CALL_OW 12
17888: ARRAY
17889: ADD
17890: ST_TO_ADDR
// end ;
17891: GO 17813
17893: POP
17894: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17895: LD_INT 22
17897: PUSH
17898: LD_INT 7
17900: PUSH
17901: EMPTY
17902: LIST
17903: LIST
17904: PUSH
17905: LD_INT 34
17907: PUSH
17908: LD_INT 51
17910: PUSH
17911: EMPTY
17912: LIST
17913: LIST
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PPUSH
17919: CALL_OW 69
17923: PUSH
17924: LD_INT 0
17926: EQUAL
17927: IFFALSE 17950
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17929: LD_EXP 49
17933: PPUSH
17934: LD_INT 21
17936: PPUSH
17937: LD_INT 1
17939: PPUSH
17940: LD_INT 3
17942: PPUSH
17943: LD_INT 51
17945: PPUSH
17946: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17950: LD_EXP 38
17954: PUSH
17955: LD_OWVAR 1
17959: PUSH
17960: LD_INT 25200
17962: MOD
17963: PUSH
17964: LD_INT 0
17966: EQUAL
17967: AND
17968: IFFALSE 18031
// begin for i = 1 to al_force do
17970: LD_ADDR_VAR 0 1
17974: PUSH
17975: DOUBLE
17976: LD_INT 1
17978: DEC
17979: ST_TO_ADDR
17980: LD_EXP 38
17984: PUSH
17985: FOR_TO
17986: IFFALSE 18029
// if GetTag ( al_force [ i ] ) <> 11 then
17988: LD_EXP 38
17992: PUSH
17993: LD_VAR 0 1
17997: ARRAY
17998: PPUSH
17999: CALL_OW 110
18003: PUSH
18004: LD_INT 11
18006: NONEQUAL
18007: IFFALSE 18027
// SetTag ( al_force [ i ] , 11 ) ;
18009: LD_EXP 38
18013: PUSH
18014: LD_VAR 0 1
18018: ARRAY
18019: PPUSH
18020: LD_INT 11
18022: PPUSH
18023: CALL_OW 109
18027: GO 17985
18029: POP
18030: POP
// end ; if al_force then
18031: LD_EXP 38
18035: IFFALSE 18144
// for i = 1 to al_force do
18037: LD_ADDR_VAR 0 1
18041: PUSH
18042: DOUBLE
18043: LD_INT 1
18045: DEC
18046: ST_TO_ADDR
18047: LD_EXP 38
18051: PUSH
18052: FOR_TO
18053: IFFALSE 18142
// begin if GetTag ( al_force [ i ] ) = 11 then
18055: LD_EXP 38
18059: PUSH
18060: LD_VAR 0 1
18064: ARRAY
18065: PPUSH
18066: CALL_OW 110
18070: PUSH
18071: LD_INT 11
18073: EQUAL
18074: IFFALSE 18140
// begin if not HasTask ( al_force [ i ] ) then
18076: LD_EXP 38
18080: PUSH
18081: LD_VAR 0 1
18085: ARRAY
18086: PPUSH
18087: CALL_OW 314
18091: NOT
18092: IFFALSE 18140
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18094: LD_EXP 38
18098: PUSH
18099: LD_VAR 0 1
18103: ARRAY
18104: PPUSH
18105: LD_INT 81
18107: PUSH
18108: LD_INT 7
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: PPUSH
18115: CALL_OW 69
18119: PPUSH
18120: LD_EXP 38
18124: PUSH
18125: LD_VAR 0 1
18129: ARRAY
18130: PPUSH
18131: CALL_OW 74
18135: PPUSH
18136: CALL_OW 115
// end ; end ;
18140: GO 18052
18142: POP
18143: POP
// end ; end_of_file
18144: PPOPN 4
18146: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18147: LD_INT 0
18149: PPUSH
18150: PPUSH
18151: PPUSH
18152: PPUSH
18153: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18154: LD_ADDR_EXP 53
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: LD_INT 6
18164: PUSH
18165: LD_INT 5
18167: PUSH
18168: EMPTY
18169: LIST
18170: LIST
18171: LIST
18172: PUSH
18173: LD_OWVAR 67
18177: ARRAY
18178: ST_TO_ADDR
// ar_force := [ ] ;
18179: LD_ADDR_EXP 52
18183: PUSH
18184: EMPTY
18185: ST_TO_ADDR
// RemoveAlliance ;
18186: CALL 15975 0 0
// RemoveEnvironmentArea ( evn ) ;
18190: LD_INT 17
18192: PPUSH
18193: CALL_OW 355
// your_side := 2 ;
18197: LD_ADDR_OWVAR 2
18201: PUSH
18202: LD_INT 2
18204: ST_TO_ADDR
// uc_side := 2 ;
18205: LD_ADDR_OWVAR 20
18209: PUSH
18210: LD_INT 2
18212: ST_TO_ADDR
// uc_nation := nation_arabian ;
18213: LD_ADDR_OWVAR 21
18217: PUSH
18218: LD_INT 2
18220: ST_TO_ADDR
// hc_gallery :=  ;
18221: LD_ADDR_OWVAR 33
18225: PUSH
18226: LD_STRING 
18228: ST_TO_ADDR
// hc_name :=  ;
18229: LD_ADDR_OWVAR 26
18233: PUSH
18234: LD_STRING 
18236: ST_TO_ADDR
// hc_importance := 0 ;
18237: LD_ADDR_OWVAR 32
18241: PUSH
18242: LD_INT 0
18244: ST_TO_ADDR
// for i = 1 to 15 do
18245: LD_ADDR_VAR 0 2
18249: PUSH
18250: DOUBLE
18251: LD_INT 1
18253: DEC
18254: ST_TO_ADDR
18255: LD_INT 15
18257: PUSH
18258: FOR_TO
18259: IFFALSE 18312
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18261: LD_INT 0
18263: PPUSH
18264: LD_INT 1
18266: PPUSH
18267: LD_INT 4
18269: PPUSH
18270: CALL_OW 12
18274: PPUSH
18275: LD_EXP 53
18279: PPUSH
18280: CALL_OW 380
// un := CreateHuman ;
18284: LD_ADDR_VAR 0 4
18288: PUSH
18289: CALL_OW 44
18293: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18294: LD_ADDR_EXP 52
18298: PUSH
18299: LD_EXP 52
18303: PUSH
18304: LD_VAR 0 4
18308: ADD
18309: ST_TO_ADDR
// end ;
18310: GO 18258
18312: POP
18313: POP
// hc_importance := 100 ;
18314: LD_ADDR_OWVAR 32
18318: PUSH
18319: LD_INT 100
18321: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18322: LD_INT 1
18324: PPUSH
18325: LD_INT 11
18327: PPUSH
18328: LD_EXP 53
18332: PPUSH
18333: CALL_OW 380
// ar_commander := CreateHuman ;
18337: LD_ADDR_EXP 51
18341: PUSH
18342: CALL_OW 44
18346: ST_TO_ADDR
// player_commander := ar_commander ;
18347: LD_ADDR_EXP 10
18351: PUSH
18352: LD_EXP 51
18356: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18357: LD_ADDR_VAR 0 5
18361: PUSH
18362: LD_STRING text
18364: PPUSH
18365: LD_INT 11
18367: PUSH
18368: LD_INT 10
18370: PUSH
18371: LD_INT 9
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: LIST
18378: PUSH
18379: LD_OWVAR 67
18383: ARRAY
18384: PPUSH
18385: LD_INT 11
18387: PUSH
18388: LD_INT 10
18390: PUSH
18391: LD_INT 9
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: LD_OWVAR 67
18403: ARRAY
18404: PPUSH
18405: LD_INT -5
18407: PUSH
18408: LD_EXP 51
18412: PUSH
18413: LD_INT -3
18415: PUSH
18416: LD_INT -2
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: LIST
18423: LIST
18424: PUSH
18425: LD_EXP 52
18429: ADD
18430: PPUSH
18431: LD_INT 1
18433: PUSH
18434: LD_INT 3
18436: PUSH
18437: LD_INT 2
18439: PUSH
18440: LD_INT 1
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 8
18459: PUSH
18460: EMPTY
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: LIST
18466: PPUSH
18467: CALL_OW 42
18471: ST_TO_ADDR
// team := team ^ ar_commander ;
18472: LD_ADDR_VAR 0 5
18476: PUSH
18477: LD_VAR 0 5
18481: PUSH
18482: LD_EXP 51
18486: ADD
18487: ST_TO_ADDR
// for i = 1 to team do
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_VAR 0 5
18502: PUSH
18503: FOR_TO
18504: IFFALSE 18529
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18506: LD_VAR 0 5
18510: PUSH
18511: LD_VAR 0 2
18515: ARRAY
18516: PPUSH
18517: LD_INT 16
18519: PPUSH
18520: LD_INT 0
18522: PPUSH
18523: CALL_OW 49
18527: GO 18503
18529: POP
18530: POP
// uc_side := 0 ;
18531: LD_ADDR_OWVAR 20
18535: PUSH
18536: LD_INT 0
18538: ST_TO_ADDR
// uc_nation := 0 ;
18539: LD_ADDR_OWVAR 21
18543: PUSH
18544: LD_INT 0
18546: ST_TO_ADDR
// vc_chassis := 31 ;
18547: LD_ADDR_OWVAR 37
18551: PUSH
18552: LD_INT 31
18554: ST_TO_ADDR
// vc_control := control_rider ;
18555: LD_ADDR_OWVAR 38
18559: PUSH
18560: LD_INT 4
18562: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18563: CALL_OW 45
18567: PPUSH
18568: LD_INT 96
18570: PPUSH
18571: LD_INT 20
18573: PPUSH
18574: LD_INT 0
18576: PPUSH
18577: CALL_OW 48
// end ; end_of_file
18581: LD_VAR 0 1
18585: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18586: GO 18588
18588: DISABLE
// begin ru_radar := 98 ;
18589: LD_ADDR_EXP 54
18593: PUSH
18594: LD_INT 98
18596: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18597: LD_ADDR_EXP 55
18601: PUSH
18602: LD_INT 89
18604: ST_TO_ADDR
// us_hack := 99 ;
18605: LD_ADDR_EXP 56
18609: PUSH
18610: LD_INT 99
18612: ST_TO_ADDR
// us_artillery := 97 ;
18613: LD_ADDR_EXP 57
18617: PUSH
18618: LD_INT 97
18620: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18621: LD_ADDR_EXP 58
18625: PUSH
18626: LD_INT 91
18628: ST_TO_ADDR
// end ; end_of_file end_of_file
18629: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18630: GO 18632
18632: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18633: LD_STRING initStreamRollete();
18635: PPUSH
18636: CALL_OW 559
// InitStreamMode ;
18640: CALL 18649 0 0
// DefineStreamItems ( ) ;
18644: CALL 19089 0 0
// end ;
18648: END
// function InitStreamMode ; begin
18649: LD_INT 0
18651: PPUSH
// streamModeActive := false ;
18652: LD_ADDR_EXP 59
18656: PUSH
18657: LD_INT 0
18659: ST_TO_ADDR
// normalCounter := 36 ;
18660: LD_ADDR_EXP 60
18664: PUSH
18665: LD_INT 36
18667: ST_TO_ADDR
// hardcoreCounter := 16 ;
18668: LD_ADDR_EXP 61
18672: PUSH
18673: LD_INT 16
18675: ST_TO_ADDR
// sRocket := false ;
18676: LD_ADDR_EXP 64
18680: PUSH
18681: LD_INT 0
18683: ST_TO_ADDR
// sSpeed := false ;
18684: LD_ADDR_EXP 63
18688: PUSH
18689: LD_INT 0
18691: ST_TO_ADDR
// sEngine := false ;
18692: LD_ADDR_EXP 65
18696: PUSH
18697: LD_INT 0
18699: ST_TO_ADDR
// sSpec := false ;
18700: LD_ADDR_EXP 62
18704: PUSH
18705: LD_INT 0
18707: ST_TO_ADDR
// sLevel := false ;
18708: LD_ADDR_EXP 66
18712: PUSH
18713: LD_INT 0
18715: ST_TO_ADDR
// sArmoury := false ;
18716: LD_ADDR_EXP 67
18720: PUSH
18721: LD_INT 0
18723: ST_TO_ADDR
// sRadar := false ;
18724: LD_ADDR_EXP 68
18728: PUSH
18729: LD_INT 0
18731: ST_TO_ADDR
// sBunker := false ;
18732: LD_ADDR_EXP 69
18736: PUSH
18737: LD_INT 0
18739: ST_TO_ADDR
// sHack := false ;
18740: LD_ADDR_EXP 70
18744: PUSH
18745: LD_INT 0
18747: ST_TO_ADDR
// sFire := false ;
18748: LD_ADDR_EXP 71
18752: PUSH
18753: LD_INT 0
18755: ST_TO_ADDR
// sRefresh := false ;
18756: LD_ADDR_EXP 72
18760: PUSH
18761: LD_INT 0
18763: ST_TO_ADDR
// sExp := false ;
18764: LD_ADDR_EXP 73
18768: PUSH
18769: LD_INT 0
18771: ST_TO_ADDR
// sDepot := false ;
18772: LD_ADDR_EXP 74
18776: PUSH
18777: LD_INT 0
18779: ST_TO_ADDR
// sFlag := false ;
18780: LD_ADDR_EXP 75
18784: PUSH
18785: LD_INT 0
18787: ST_TO_ADDR
// sKamikadze := false ;
18788: LD_ADDR_EXP 83
18792: PUSH
18793: LD_INT 0
18795: ST_TO_ADDR
// sTroll := false ;
18796: LD_ADDR_EXP 84
18800: PUSH
18801: LD_INT 0
18803: ST_TO_ADDR
// sSlow := false ;
18804: LD_ADDR_EXP 85
18808: PUSH
18809: LD_INT 0
18811: ST_TO_ADDR
// sLack := false ;
18812: LD_ADDR_EXP 86
18816: PUSH
18817: LD_INT 0
18819: ST_TO_ADDR
// sTank := false ;
18820: LD_ADDR_EXP 88
18824: PUSH
18825: LD_INT 0
18827: ST_TO_ADDR
// sRemote := false ;
18828: LD_ADDR_EXP 89
18832: PUSH
18833: LD_INT 0
18835: ST_TO_ADDR
// sPowell := false ;
18836: LD_ADDR_EXP 90
18840: PUSH
18841: LD_INT 0
18843: ST_TO_ADDR
// sTeleport := false ;
18844: LD_ADDR_EXP 93
18848: PUSH
18849: LD_INT 0
18851: ST_TO_ADDR
// sOilTower := false ;
18852: LD_ADDR_EXP 95
18856: PUSH
18857: LD_INT 0
18859: ST_TO_ADDR
// sShovel := false ;
18860: LD_ADDR_EXP 96
18864: PUSH
18865: LD_INT 0
18867: ST_TO_ADDR
// sSheik := false ;
18868: LD_ADDR_EXP 97
18872: PUSH
18873: LD_INT 0
18875: ST_TO_ADDR
// sEarthquake := false ;
18876: LD_ADDR_EXP 99
18880: PUSH
18881: LD_INT 0
18883: ST_TO_ADDR
// sAI := false ;
18884: LD_ADDR_EXP 100
18888: PUSH
18889: LD_INT 0
18891: ST_TO_ADDR
// sCargo := false ;
18892: LD_ADDR_EXP 103
18896: PUSH
18897: LD_INT 0
18899: ST_TO_ADDR
// sDLaser := false ;
18900: LD_ADDR_EXP 104
18904: PUSH
18905: LD_INT 0
18907: ST_TO_ADDR
// sExchange := false ;
18908: LD_ADDR_EXP 105
18912: PUSH
18913: LD_INT 0
18915: ST_TO_ADDR
// sFac := false ;
18916: LD_ADDR_EXP 106
18920: PUSH
18921: LD_INT 0
18923: ST_TO_ADDR
// sPower := false ;
18924: LD_ADDR_EXP 107
18928: PUSH
18929: LD_INT 0
18931: ST_TO_ADDR
// sRandom := false ;
18932: LD_ADDR_EXP 108
18936: PUSH
18937: LD_INT 0
18939: ST_TO_ADDR
// sShield := false ;
18940: LD_ADDR_EXP 109
18944: PUSH
18945: LD_INT 0
18947: ST_TO_ADDR
// sTime := false ;
18948: LD_ADDR_EXP 110
18952: PUSH
18953: LD_INT 0
18955: ST_TO_ADDR
// sTools := false ;
18956: LD_ADDR_EXP 111
18960: PUSH
18961: LD_INT 0
18963: ST_TO_ADDR
// sSold := false ;
18964: LD_ADDR_EXP 76
18968: PUSH
18969: LD_INT 0
18971: ST_TO_ADDR
// sDiff := false ;
18972: LD_ADDR_EXP 77
18976: PUSH
18977: LD_INT 0
18979: ST_TO_ADDR
// sFog := false ;
18980: LD_ADDR_EXP 80
18984: PUSH
18985: LD_INT 0
18987: ST_TO_ADDR
// sReset := false ;
18988: LD_ADDR_EXP 81
18992: PUSH
18993: LD_INT 0
18995: ST_TO_ADDR
// sSun := false ;
18996: LD_ADDR_EXP 82
19000: PUSH
19001: LD_INT 0
19003: ST_TO_ADDR
// sTiger := false ;
19004: LD_ADDR_EXP 78
19008: PUSH
19009: LD_INT 0
19011: ST_TO_ADDR
// sBomb := false ;
19012: LD_ADDR_EXP 79
19016: PUSH
19017: LD_INT 0
19019: ST_TO_ADDR
// sWound := false ;
19020: LD_ADDR_EXP 87
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// sBetray := false ;
19028: LD_ADDR_EXP 91
19032: PUSH
19033: LD_INT 0
19035: ST_TO_ADDR
// sContamin := false ;
19036: LD_ADDR_EXP 92
19040: PUSH
19041: LD_INT 0
19043: ST_TO_ADDR
// sOil := false ;
19044: LD_ADDR_EXP 94
19048: PUSH
19049: LD_INT 0
19051: ST_TO_ADDR
// sStu := false ;
19052: LD_ADDR_EXP 98
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// sBazooka := false ;
19060: LD_ADDR_EXP 101
19064: PUSH
19065: LD_INT 0
19067: ST_TO_ADDR
// sMortar := false ;
19068: LD_ADDR_EXP 102
19072: PUSH
19073: LD_INT 0
19075: ST_TO_ADDR
// sRanger := false ;
19076: LD_ADDR_EXP 112
19080: PUSH
19081: LD_INT 0
19083: ST_TO_ADDR
// end ;
19084: LD_VAR 0 1
19088: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19089: LD_INT 0
19091: PPUSH
19092: PPUSH
19093: PPUSH
19094: PPUSH
19095: PPUSH
// result := [ ] ;
19096: LD_ADDR_VAR 0 1
19100: PUSH
19101: EMPTY
19102: ST_TO_ADDR
// if campaign_id = 1 then
19103: LD_OWVAR 69
19107: PUSH
19108: LD_INT 1
19110: EQUAL
19111: IFFALSE 22049
// begin case mission_number of 1 :
19113: LD_OWVAR 70
19117: PUSH
19118: LD_INT 1
19120: DOUBLE
19121: EQUAL
19122: IFTRUE 19126
19124: GO 19190
19126: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19127: LD_ADDR_VAR 0 1
19131: PUSH
19132: LD_INT 2
19134: PUSH
19135: LD_INT 4
19137: PUSH
19138: LD_INT 11
19140: PUSH
19141: LD_INT 12
19143: PUSH
19144: LD_INT 15
19146: PUSH
19147: LD_INT 16
19149: PUSH
19150: LD_INT 22
19152: PUSH
19153: LD_INT 23
19155: PUSH
19156: LD_INT 26
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: LIST
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: PUSH
19170: LD_INT 101
19172: PUSH
19173: LD_INT 102
19175: PUSH
19176: LD_INT 106
19178: PUSH
19179: EMPTY
19180: LIST
19181: LIST
19182: LIST
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: ST_TO_ADDR
19188: GO 22047
19190: LD_INT 2
19192: DOUBLE
19193: EQUAL
19194: IFTRUE 19198
19196: GO 19270
19198: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19199: LD_ADDR_VAR 0 1
19203: PUSH
19204: LD_INT 2
19206: PUSH
19207: LD_INT 4
19209: PUSH
19210: LD_INT 11
19212: PUSH
19213: LD_INT 12
19215: PUSH
19216: LD_INT 15
19218: PUSH
19219: LD_INT 16
19221: PUSH
19222: LD_INT 22
19224: PUSH
19225: LD_INT 23
19227: PUSH
19228: LD_INT 26
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: PUSH
19242: LD_INT 101
19244: PUSH
19245: LD_INT 102
19247: PUSH
19248: LD_INT 105
19250: PUSH
19251: LD_INT 106
19253: PUSH
19254: LD_INT 108
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: LIST
19261: LIST
19262: LIST
19263: PUSH
19264: EMPTY
19265: LIST
19266: LIST
19267: ST_TO_ADDR
19268: GO 22047
19270: LD_INT 3
19272: DOUBLE
19273: EQUAL
19274: IFTRUE 19278
19276: GO 19354
19278: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19279: LD_ADDR_VAR 0 1
19283: PUSH
19284: LD_INT 2
19286: PUSH
19287: LD_INT 4
19289: PUSH
19290: LD_INT 5
19292: PUSH
19293: LD_INT 11
19295: PUSH
19296: LD_INT 12
19298: PUSH
19299: LD_INT 15
19301: PUSH
19302: LD_INT 16
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_INT 26
19310: PUSH
19311: LD_INT 36
19313: PUSH
19314: EMPTY
19315: LIST
19316: LIST
19317: LIST
19318: LIST
19319: LIST
19320: LIST
19321: LIST
19322: LIST
19323: LIST
19324: LIST
19325: PUSH
19326: LD_INT 101
19328: PUSH
19329: LD_INT 102
19331: PUSH
19332: LD_INT 105
19334: PUSH
19335: LD_INT 106
19337: PUSH
19338: LD_INT 108
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: LIST
19345: LIST
19346: LIST
19347: PUSH
19348: EMPTY
19349: LIST
19350: LIST
19351: ST_TO_ADDR
19352: GO 22047
19354: LD_INT 4
19356: DOUBLE
19357: EQUAL
19358: IFTRUE 19362
19360: GO 19446
19362: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19363: LD_ADDR_VAR 0 1
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: LD_INT 4
19373: PUSH
19374: LD_INT 5
19376: PUSH
19377: LD_INT 8
19379: PUSH
19380: LD_INT 11
19382: PUSH
19383: LD_INT 12
19385: PUSH
19386: LD_INT 15
19388: PUSH
19389: LD_INT 16
19391: PUSH
19392: LD_INT 22
19394: PUSH
19395: LD_INT 23
19397: PUSH
19398: LD_INT 26
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: EMPTY
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: PUSH
19418: LD_INT 101
19420: PUSH
19421: LD_INT 102
19423: PUSH
19424: LD_INT 105
19426: PUSH
19427: LD_INT 106
19429: PUSH
19430: LD_INT 108
19432: PUSH
19433: EMPTY
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: LIST
19439: PUSH
19440: EMPTY
19441: LIST
19442: LIST
19443: ST_TO_ADDR
19444: GO 22047
19446: LD_INT 5
19448: DOUBLE
19449: EQUAL
19450: IFTRUE 19454
19452: GO 19554
19454: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19455: LD_ADDR_VAR 0 1
19459: PUSH
19460: LD_INT 2
19462: PUSH
19463: LD_INT 4
19465: PUSH
19466: LD_INT 5
19468: PUSH
19469: LD_INT 6
19471: PUSH
19472: LD_INT 8
19474: PUSH
19475: LD_INT 11
19477: PUSH
19478: LD_INT 12
19480: PUSH
19481: LD_INT 15
19483: PUSH
19484: LD_INT 16
19486: PUSH
19487: LD_INT 22
19489: PUSH
19490: LD_INT 23
19492: PUSH
19493: LD_INT 25
19495: PUSH
19496: LD_INT 26
19498: PUSH
19499: LD_INT 36
19501: PUSH
19502: EMPTY
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: PUSH
19518: LD_INT 101
19520: PUSH
19521: LD_INT 102
19523: PUSH
19524: LD_INT 105
19526: PUSH
19527: LD_INT 106
19529: PUSH
19530: LD_INT 108
19532: PUSH
19533: LD_INT 109
19535: PUSH
19536: LD_INT 112
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: LIST
19546: LIST
19547: PUSH
19548: EMPTY
19549: LIST
19550: LIST
19551: ST_TO_ADDR
19552: GO 22047
19554: LD_INT 6
19556: DOUBLE
19557: EQUAL
19558: IFTRUE 19562
19560: GO 19682
19562: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19563: LD_ADDR_VAR 0 1
19567: PUSH
19568: LD_INT 2
19570: PUSH
19571: LD_INT 4
19573: PUSH
19574: LD_INT 5
19576: PUSH
19577: LD_INT 6
19579: PUSH
19580: LD_INT 8
19582: PUSH
19583: LD_INT 11
19585: PUSH
19586: LD_INT 12
19588: PUSH
19589: LD_INT 15
19591: PUSH
19592: LD_INT 16
19594: PUSH
19595: LD_INT 20
19597: PUSH
19598: LD_INT 21
19600: PUSH
19601: LD_INT 22
19603: PUSH
19604: LD_INT 23
19606: PUSH
19607: LD_INT 25
19609: PUSH
19610: LD_INT 26
19612: PUSH
19613: LD_INT 30
19615: PUSH
19616: LD_INT 31
19618: PUSH
19619: LD_INT 32
19621: PUSH
19622: LD_INT 36
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: PUSH
19646: LD_INT 101
19648: PUSH
19649: LD_INT 102
19651: PUSH
19652: LD_INT 105
19654: PUSH
19655: LD_INT 106
19657: PUSH
19658: LD_INT 108
19660: PUSH
19661: LD_INT 109
19663: PUSH
19664: LD_INT 112
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: ST_TO_ADDR
19680: GO 22047
19682: LD_INT 7
19684: DOUBLE
19685: EQUAL
19686: IFTRUE 19690
19688: GO 19790
19690: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19691: LD_ADDR_VAR 0 1
19695: PUSH
19696: LD_INT 2
19698: PUSH
19699: LD_INT 4
19701: PUSH
19702: LD_INT 5
19704: PUSH
19705: LD_INT 7
19707: PUSH
19708: LD_INT 11
19710: PUSH
19711: LD_INT 12
19713: PUSH
19714: LD_INT 15
19716: PUSH
19717: LD_INT 16
19719: PUSH
19720: LD_INT 20
19722: PUSH
19723: LD_INT 21
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_INT 23
19731: PUSH
19732: LD_INT 25
19734: PUSH
19735: LD_INT 26
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: PUSH
19754: LD_INT 101
19756: PUSH
19757: LD_INT 102
19759: PUSH
19760: LD_INT 103
19762: PUSH
19763: LD_INT 105
19765: PUSH
19766: LD_INT 106
19768: PUSH
19769: LD_INT 108
19771: PUSH
19772: LD_INT 112
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: ST_TO_ADDR
19788: GO 22047
19790: LD_INT 8
19792: DOUBLE
19793: EQUAL
19794: IFTRUE 19798
19796: GO 19926
19798: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19799: LD_ADDR_VAR 0 1
19803: PUSH
19804: LD_INT 2
19806: PUSH
19807: LD_INT 4
19809: PUSH
19810: LD_INT 5
19812: PUSH
19813: LD_INT 6
19815: PUSH
19816: LD_INT 7
19818: PUSH
19819: LD_INT 8
19821: PUSH
19822: LD_INT 11
19824: PUSH
19825: LD_INT 12
19827: PUSH
19828: LD_INT 15
19830: PUSH
19831: LD_INT 16
19833: PUSH
19834: LD_INT 20
19836: PUSH
19837: LD_INT 21
19839: PUSH
19840: LD_INT 22
19842: PUSH
19843: LD_INT 23
19845: PUSH
19846: LD_INT 25
19848: PUSH
19849: LD_INT 26
19851: PUSH
19852: LD_INT 30
19854: PUSH
19855: LD_INT 31
19857: PUSH
19858: LD_INT 32
19860: PUSH
19861: LD_INT 36
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: PUSH
19886: LD_INT 101
19888: PUSH
19889: LD_INT 102
19891: PUSH
19892: LD_INT 103
19894: PUSH
19895: LD_INT 105
19897: PUSH
19898: LD_INT 106
19900: PUSH
19901: LD_INT 108
19903: PUSH
19904: LD_INT 109
19906: PUSH
19907: LD_INT 112
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: LIST
19919: PUSH
19920: EMPTY
19921: LIST
19922: LIST
19923: ST_TO_ADDR
19924: GO 22047
19926: LD_INT 9
19928: DOUBLE
19929: EQUAL
19930: IFTRUE 19934
19932: GO 20070
19934: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19935: LD_ADDR_VAR 0 1
19939: PUSH
19940: LD_INT 2
19942: PUSH
19943: LD_INT 4
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: LD_INT 6
19951: PUSH
19952: LD_INT 7
19954: PUSH
19955: LD_INT 8
19957: PUSH
19958: LD_INT 11
19960: PUSH
19961: LD_INT 12
19963: PUSH
19964: LD_INT 15
19966: PUSH
19967: LD_INT 16
19969: PUSH
19970: LD_INT 20
19972: PUSH
19973: LD_INT 21
19975: PUSH
19976: LD_INT 22
19978: PUSH
19979: LD_INT 23
19981: PUSH
19982: LD_INT 25
19984: PUSH
19985: LD_INT 26
19987: PUSH
19988: LD_INT 28
19990: PUSH
19991: LD_INT 30
19993: PUSH
19994: LD_INT 31
19996: PUSH
19997: LD_INT 32
19999: PUSH
20000: LD_INT 36
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: LIST
20017: LIST
20018: LIST
20019: LIST
20020: LIST
20021: LIST
20022: LIST
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 101
20028: PUSH
20029: LD_INT 102
20031: PUSH
20032: LD_INT 103
20034: PUSH
20035: LD_INT 105
20037: PUSH
20038: LD_INT 106
20040: PUSH
20041: LD_INT 108
20043: PUSH
20044: LD_INT 109
20046: PUSH
20047: LD_INT 112
20049: PUSH
20050: LD_INT 114
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: LIST
20060: LIST
20061: LIST
20062: LIST
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: ST_TO_ADDR
20068: GO 22047
20070: LD_INT 10
20072: DOUBLE
20073: EQUAL
20074: IFTRUE 20078
20076: GO 20262
20078: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20079: LD_ADDR_VAR 0 1
20083: PUSH
20084: LD_INT 2
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: LD_INT 6
20095: PUSH
20096: LD_INT 7
20098: PUSH
20099: LD_INT 8
20101: PUSH
20102: LD_INT 9
20104: PUSH
20105: LD_INT 10
20107: PUSH
20108: LD_INT 11
20110: PUSH
20111: LD_INT 12
20113: PUSH
20114: LD_INT 13
20116: PUSH
20117: LD_INT 14
20119: PUSH
20120: LD_INT 15
20122: PUSH
20123: LD_INT 16
20125: PUSH
20126: LD_INT 17
20128: PUSH
20129: LD_INT 18
20131: PUSH
20132: LD_INT 19
20134: PUSH
20135: LD_INT 20
20137: PUSH
20138: LD_INT 21
20140: PUSH
20141: LD_INT 22
20143: PUSH
20144: LD_INT 23
20146: PUSH
20147: LD_INT 24
20149: PUSH
20150: LD_INT 25
20152: PUSH
20153: LD_INT 26
20155: PUSH
20156: LD_INT 28
20158: PUSH
20159: LD_INT 30
20161: PUSH
20162: LD_INT 31
20164: PUSH
20165: LD_INT 32
20167: PUSH
20168: LD_INT 36
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: PUSH
20202: LD_INT 101
20204: PUSH
20205: LD_INT 102
20207: PUSH
20208: LD_INT 103
20210: PUSH
20211: LD_INT 104
20213: PUSH
20214: LD_INT 105
20216: PUSH
20217: LD_INT 106
20219: PUSH
20220: LD_INT 107
20222: PUSH
20223: LD_INT 108
20225: PUSH
20226: LD_INT 109
20228: PUSH
20229: LD_INT 110
20231: PUSH
20232: LD_INT 111
20234: PUSH
20235: LD_INT 112
20237: PUSH
20238: LD_INT 114
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: LIST
20251: LIST
20252: LIST
20253: LIST
20254: LIST
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: ST_TO_ADDR
20260: GO 22047
20262: LD_INT 11
20264: DOUBLE
20265: EQUAL
20266: IFTRUE 20270
20268: GO 20462
20270: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20271: LD_ADDR_VAR 0 1
20275: PUSH
20276: LD_INT 2
20278: PUSH
20279: LD_INT 3
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 5
20287: PUSH
20288: LD_INT 6
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: LD_INT 8
20296: PUSH
20297: LD_INT 9
20299: PUSH
20300: LD_INT 10
20302: PUSH
20303: LD_INT 11
20305: PUSH
20306: LD_INT 12
20308: PUSH
20309: LD_INT 13
20311: PUSH
20312: LD_INT 14
20314: PUSH
20315: LD_INT 15
20317: PUSH
20318: LD_INT 16
20320: PUSH
20321: LD_INT 17
20323: PUSH
20324: LD_INT 18
20326: PUSH
20327: LD_INT 19
20329: PUSH
20330: LD_INT 20
20332: PUSH
20333: LD_INT 21
20335: PUSH
20336: LD_INT 22
20338: PUSH
20339: LD_INT 23
20341: PUSH
20342: LD_INT 24
20344: PUSH
20345: LD_INT 25
20347: PUSH
20348: LD_INT 26
20350: PUSH
20351: LD_INT 28
20353: PUSH
20354: LD_INT 30
20356: PUSH
20357: LD_INT 31
20359: PUSH
20360: LD_INT 32
20362: PUSH
20363: LD_INT 34
20365: PUSH
20366: LD_INT 36
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 101
20404: PUSH
20405: LD_INT 102
20407: PUSH
20408: LD_INT 103
20410: PUSH
20411: LD_INT 104
20413: PUSH
20414: LD_INT 105
20416: PUSH
20417: LD_INT 106
20419: PUSH
20420: LD_INT 107
20422: PUSH
20423: LD_INT 108
20425: PUSH
20426: LD_INT 109
20428: PUSH
20429: LD_INT 110
20431: PUSH
20432: LD_INT 111
20434: PUSH
20435: LD_INT 112
20437: PUSH
20438: LD_INT 114
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: ST_TO_ADDR
20460: GO 22047
20462: LD_INT 12
20464: DOUBLE
20465: EQUAL
20466: IFTRUE 20470
20468: GO 20678
20470: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20471: LD_ADDR_VAR 0 1
20475: PUSH
20476: LD_INT 1
20478: PUSH
20479: LD_INT 2
20481: PUSH
20482: LD_INT 3
20484: PUSH
20485: LD_INT 4
20487: PUSH
20488: LD_INT 5
20490: PUSH
20491: LD_INT 6
20493: PUSH
20494: LD_INT 7
20496: PUSH
20497: LD_INT 8
20499: PUSH
20500: LD_INT 9
20502: PUSH
20503: LD_INT 10
20505: PUSH
20506: LD_INT 11
20508: PUSH
20509: LD_INT 12
20511: PUSH
20512: LD_INT 13
20514: PUSH
20515: LD_INT 14
20517: PUSH
20518: LD_INT 15
20520: PUSH
20521: LD_INT 16
20523: PUSH
20524: LD_INT 17
20526: PUSH
20527: LD_INT 18
20529: PUSH
20530: LD_INT 19
20532: PUSH
20533: LD_INT 20
20535: PUSH
20536: LD_INT 21
20538: PUSH
20539: LD_INT 22
20541: PUSH
20542: LD_INT 23
20544: PUSH
20545: LD_INT 24
20547: PUSH
20548: LD_INT 25
20550: PUSH
20551: LD_INT 26
20553: PUSH
20554: LD_INT 27
20556: PUSH
20557: LD_INT 28
20559: PUSH
20560: LD_INT 30
20562: PUSH
20563: LD_INT 31
20565: PUSH
20566: LD_INT 32
20568: PUSH
20569: LD_INT 33
20571: PUSH
20572: LD_INT 34
20574: PUSH
20575: LD_INT 36
20577: PUSH
20578: EMPTY
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: PUSH
20614: LD_INT 101
20616: PUSH
20617: LD_INT 102
20619: PUSH
20620: LD_INT 103
20622: PUSH
20623: LD_INT 104
20625: PUSH
20626: LD_INT 105
20628: PUSH
20629: LD_INT 106
20631: PUSH
20632: LD_INT 107
20634: PUSH
20635: LD_INT 108
20637: PUSH
20638: LD_INT 109
20640: PUSH
20641: LD_INT 110
20643: PUSH
20644: LD_INT 111
20646: PUSH
20647: LD_INT 112
20649: PUSH
20650: LD_INT 113
20652: PUSH
20653: LD_INT 114
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: ST_TO_ADDR
20676: GO 22047
20678: LD_INT 13
20680: DOUBLE
20681: EQUAL
20682: IFTRUE 20686
20684: GO 20882
20686: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20687: LD_ADDR_VAR 0 1
20691: PUSH
20692: LD_INT 1
20694: PUSH
20695: LD_INT 2
20697: PUSH
20698: LD_INT 3
20700: PUSH
20701: LD_INT 4
20703: PUSH
20704: LD_INT 5
20706: PUSH
20707: LD_INT 8
20709: PUSH
20710: LD_INT 9
20712: PUSH
20713: LD_INT 10
20715: PUSH
20716: LD_INT 11
20718: PUSH
20719: LD_INT 12
20721: PUSH
20722: LD_INT 14
20724: PUSH
20725: LD_INT 15
20727: PUSH
20728: LD_INT 16
20730: PUSH
20731: LD_INT 17
20733: PUSH
20734: LD_INT 18
20736: PUSH
20737: LD_INT 19
20739: PUSH
20740: LD_INT 20
20742: PUSH
20743: LD_INT 21
20745: PUSH
20746: LD_INT 22
20748: PUSH
20749: LD_INT 23
20751: PUSH
20752: LD_INT 24
20754: PUSH
20755: LD_INT 25
20757: PUSH
20758: LD_INT 26
20760: PUSH
20761: LD_INT 27
20763: PUSH
20764: LD_INT 28
20766: PUSH
20767: LD_INT 30
20769: PUSH
20770: LD_INT 31
20772: PUSH
20773: LD_INT 32
20775: PUSH
20776: LD_INT 33
20778: PUSH
20779: LD_INT 34
20781: PUSH
20782: LD_INT 36
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: PUSH
20818: LD_INT 101
20820: PUSH
20821: LD_INT 102
20823: PUSH
20824: LD_INT 103
20826: PUSH
20827: LD_INT 104
20829: PUSH
20830: LD_INT 105
20832: PUSH
20833: LD_INT 106
20835: PUSH
20836: LD_INT 107
20838: PUSH
20839: LD_INT 108
20841: PUSH
20842: LD_INT 109
20844: PUSH
20845: LD_INT 110
20847: PUSH
20848: LD_INT 111
20850: PUSH
20851: LD_INT 112
20853: PUSH
20854: LD_INT 113
20856: PUSH
20857: LD_INT 114
20859: PUSH
20860: EMPTY
20861: LIST
20862: LIST
20863: LIST
20864: LIST
20865: LIST
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: LIST
20875: PUSH
20876: EMPTY
20877: LIST
20878: LIST
20879: ST_TO_ADDR
20880: GO 22047
20882: LD_INT 14
20884: DOUBLE
20885: EQUAL
20886: IFTRUE 20890
20888: GO 21102
20890: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20891: LD_ADDR_VAR 0 1
20895: PUSH
20896: LD_INT 1
20898: PUSH
20899: LD_INT 2
20901: PUSH
20902: LD_INT 3
20904: PUSH
20905: LD_INT 4
20907: PUSH
20908: LD_INT 5
20910: PUSH
20911: LD_INT 6
20913: PUSH
20914: LD_INT 7
20916: PUSH
20917: LD_INT 8
20919: PUSH
20920: LD_INT 9
20922: PUSH
20923: LD_INT 10
20925: PUSH
20926: LD_INT 11
20928: PUSH
20929: LD_INT 12
20931: PUSH
20932: LD_INT 13
20934: PUSH
20935: LD_INT 14
20937: PUSH
20938: LD_INT 15
20940: PUSH
20941: LD_INT 16
20943: PUSH
20944: LD_INT 17
20946: PUSH
20947: LD_INT 18
20949: PUSH
20950: LD_INT 19
20952: PUSH
20953: LD_INT 20
20955: PUSH
20956: LD_INT 21
20958: PUSH
20959: LD_INT 22
20961: PUSH
20962: LD_INT 23
20964: PUSH
20965: LD_INT 24
20967: PUSH
20968: LD_INT 25
20970: PUSH
20971: LD_INT 26
20973: PUSH
20974: LD_INT 27
20976: PUSH
20977: LD_INT 28
20979: PUSH
20980: LD_INT 29
20982: PUSH
20983: LD_INT 30
20985: PUSH
20986: LD_INT 31
20988: PUSH
20989: LD_INT 32
20991: PUSH
20992: LD_INT 33
20994: PUSH
20995: LD_INT 34
20997: PUSH
20998: LD_INT 36
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: LIST
21015: LIST
21016: LIST
21017: LIST
21018: LIST
21019: LIST
21020: LIST
21021: LIST
21022: LIST
21023: LIST
21024: LIST
21025: LIST
21026: LIST
21027: LIST
21028: LIST
21029: LIST
21030: LIST
21031: LIST
21032: LIST
21033: LIST
21034: LIST
21035: LIST
21036: LIST
21037: PUSH
21038: LD_INT 101
21040: PUSH
21041: LD_INT 102
21043: PUSH
21044: LD_INT 103
21046: PUSH
21047: LD_INT 104
21049: PUSH
21050: LD_INT 105
21052: PUSH
21053: LD_INT 106
21055: PUSH
21056: LD_INT 107
21058: PUSH
21059: LD_INT 108
21061: PUSH
21062: LD_INT 109
21064: PUSH
21065: LD_INT 110
21067: PUSH
21068: LD_INT 111
21070: PUSH
21071: LD_INT 112
21073: PUSH
21074: LD_INT 113
21076: PUSH
21077: LD_INT 114
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: ST_TO_ADDR
21100: GO 22047
21102: LD_INT 15
21104: DOUBLE
21105: EQUAL
21106: IFTRUE 21110
21108: GO 21322
21110: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21111: LD_ADDR_VAR 0 1
21115: PUSH
21116: LD_INT 1
21118: PUSH
21119: LD_INT 2
21121: PUSH
21122: LD_INT 3
21124: PUSH
21125: LD_INT 4
21127: PUSH
21128: LD_INT 5
21130: PUSH
21131: LD_INT 6
21133: PUSH
21134: LD_INT 7
21136: PUSH
21137: LD_INT 8
21139: PUSH
21140: LD_INT 9
21142: PUSH
21143: LD_INT 10
21145: PUSH
21146: LD_INT 11
21148: PUSH
21149: LD_INT 12
21151: PUSH
21152: LD_INT 13
21154: PUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 15
21160: PUSH
21161: LD_INT 16
21163: PUSH
21164: LD_INT 17
21166: PUSH
21167: LD_INT 18
21169: PUSH
21170: LD_INT 19
21172: PUSH
21173: LD_INT 20
21175: PUSH
21176: LD_INT 21
21178: PUSH
21179: LD_INT 22
21181: PUSH
21182: LD_INT 23
21184: PUSH
21185: LD_INT 24
21187: PUSH
21188: LD_INT 25
21190: PUSH
21191: LD_INT 26
21193: PUSH
21194: LD_INT 27
21196: PUSH
21197: LD_INT 28
21199: PUSH
21200: LD_INT 29
21202: PUSH
21203: LD_INT 30
21205: PUSH
21206: LD_INT 31
21208: PUSH
21209: LD_INT 32
21211: PUSH
21212: LD_INT 33
21214: PUSH
21215: LD_INT 34
21217: PUSH
21218: LD_INT 36
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: LIST
21245: LIST
21246: LIST
21247: LIST
21248: LIST
21249: LIST
21250: LIST
21251: LIST
21252: LIST
21253: LIST
21254: LIST
21255: LIST
21256: LIST
21257: PUSH
21258: LD_INT 101
21260: PUSH
21261: LD_INT 102
21263: PUSH
21264: LD_INT 103
21266: PUSH
21267: LD_INT 104
21269: PUSH
21270: LD_INT 105
21272: PUSH
21273: LD_INT 106
21275: PUSH
21276: LD_INT 107
21278: PUSH
21279: LD_INT 108
21281: PUSH
21282: LD_INT 109
21284: PUSH
21285: LD_INT 110
21287: PUSH
21288: LD_INT 111
21290: PUSH
21291: LD_INT 112
21293: PUSH
21294: LD_INT 113
21296: PUSH
21297: LD_INT 114
21299: PUSH
21300: EMPTY
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: PUSH
21316: EMPTY
21317: LIST
21318: LIST
21319: ST_TO_ADDR
21320: GO 22047
21322: LD_INT 16
21324: DOUBLE
21325: EQUAL
21326: IFTRUE 21330
21328: GO 21454
21330: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21331: LD_ADDR_VAR 0 1
21335: PUSH
21336: LD_INT 2
21338: PUSH
21339: LD_INT 4
21341: PUSH
21342: LD_INT 5
21344: PUSH
21345: LD_INT 7
21347: PUSH
21348: LD_INT 11
21350: PUSH
21351: LD_INT 12
21353: PUSH
21354: LD_INT 15
21356: PUSH
21357: LD_INT 16
21359: PUSH
21360: LD_INT 20
21362: PUSH
21363: LD_INT 21
21365: PUSH
21366: LD_INT 22
21368: PUSH
21369: LD_INT 23
21371: PUSH
21372: LD_INT 25
21374: PUSH
21375: LD_INT 26
21377: PUSH
21378: LD_INT 30
21380: PUSH
21381: LD_INT 31
21383: PUSH
21384: LD_INT 32
21386: PUSH
21387: LD_INT 33
21389: PUSH
21390: LD_INT 34
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: LIST
21402: LIST
21403: LIST
21404: LIST
21405: LIST
21406: LIST
21407: LIST
21408: LIST
21409: LIST
21410: LIST
21411: LIST
21412: LIST
21413: PUSH
21414: LD_INT 101
21416: PUSH
21417: LD_INT 102
21419: PUSH
21420: LD_INT 103
21422: PUSH
21423: LD_INT 106
21425: PUSH
21426: LD_INT 108
21428: PUSH
21429: LD_INT 112
21431: PUSH
21432: LD_INT 113
21434: PUSH
21435: LD_INT 114
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: ST_TO_ADDR
21452: GO 22047
21454: LD_INT 17
21456: DOUBLE
21457: EQUAL
21458: IFTRUE 21462
21460: GO 21674
21462: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21463: LD_ADDR_VAR 0 1
21467: PUSH
21468: LD_INT 1
21470: PUSH
21471: LD_INT 2
21473: PUSH
21474: LD_INT 3
21476: PUSH
21477: LD_INT 4
21479: PUSH
21480: LD_INT 5
21482: PUSH
21483: LD_INT 6
21485: PUSH
21486: LD_INT 7
21488: PUSH
21489: LD_INT 8
21491: PUSH
21492: LD_INT 9
21494: PUSH
21495: LD_INT 10
21497: PUSH
21498: LD_INT 11
21500: PUSH
21501: LD_INT 12
21503: PUSH
21504: LD_INT 13
21506: PUSH
21507: LD_INT 14
21509: PUSH
21510: LD_INT 15
21512: PUSH
21513: LD_INT 16
21515: PUSH
21516: LD_INT 17
21518: PUSH
21519: LD_INT 18
21521: PUSH
21522: LD_INT 19
21524: PUSH
21525: LD_INT 20
21527: PUSH
21528: LD_INT 21
21530: PUSH
21531: LD_INT 22
21533: PUSH
21534: LD_INT 23
21536: PUSH
21537: LD_INT 24
21539: PUSH
21540: LD_INT 25
21542: PUSH
21543: LD_INT 26
21545: PUSH
21546: LD_INT 27
21548: PUSH
21549: LD_INT 28
21551: PUSH
21552: LD_INT 29
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_INT 31
21560: PUSH
21561: LD_INT 32
21563: PUSH
21564: LD_INT 33
21566: PUSH
21567: LD_INT 34
21569: PUSH
21570: LD_INT 36
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: LIST
21599: LIST
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: LIST
21607: LIST
21608: LIST
21609: PUSH
21610: LD_INT 101
21612: PUSH
21613: LD_INT 102
21615: PUSH
21616: LD_INT 103
21618: PUSH
21619: LD_INT 104
21621: PUSH
21622: LD_INT 105
21624: PUSH
21625: LD_INT 106
21627: PUSH
21628: LD_INT 107
21630: PUSH
21631: LD_INT 108
21633: PUSH
21634: LD_INT 109
21636: PUSH
21637: LD_INT 110
21639: PUSH
21640: LD_INT 111
21642: PUSH
21643: LD_INT 112
21645: PUSH
21646: LD_INT 113
21648: PUSH
21649: LD_INT 114
21651: PUSH
21652: EMPTY
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: ST_TO_ADDR
21672: GO 22047
21674: LD_INT 18
21676: DOUBLE
21677: EQUAL
21678: IFTRUE 21682
21680: GO 21818
21682: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21683: LD_ADDR_VAR 0 1
21687: PUSH
21688: LD_INT 2
21690: PUSH
21691: LD_INT 4
21693: PUSH
21694: LD_INT 5
21696: PUSH
21697: LD_INT 7
21699: PUSH
21700: LD_INT 11
21702: PUSH
21703: LD_INT 12
21705: PUSH
21706: LD_INT 15
21708: PUSH
21709: LD_INT 16
21711: PUSH
21712: LD_INT 20
21714: PUSH
21715: LD_INT 21
21717: PUSH
21718: LD_INT 22
21720: PUSH
21721: LD_INT 23
21723: PUSH
21724: LD_INT 25
21726: PUSH
21727: LD_INT 26
21729: PUSH
21730: LD_INT 30
21732: PUSH
21733: LD_INT 31
21735: PUSH
21736: LD_INT 32
21738: PUSH
21739: LD_INT 33
21741: PUSH
21742: LD_INT 34
21744: PUSH
21745: LD_INT 35
21747: PUSH
21748: LD_INT 36
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: LIST
21757: LIST
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: LIST
21763: LIST
21764: LIST
21765: LIST
21766: LIST
21767: LIST
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: LIST
21773: PUSH
21774: LD_INT 101
21776: PUSH
21777: LD_INT 102
21779: PUSH
21780: LD_INT 103
21782: PUSH
21783: LD_INT 106
21785: PUSH
21786: LD_INT 108
21788: PUSH
21789: LD_INT 112
21791: PUSH
21792: LD_INT 113
21794: PUSH
21795: LD_INT 114
21797: PUSH
21798: LD_INT 115
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: LIST
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: EMPTY
21813: LIST
21814: LIST
21815: ST_TO_ADDR
21816: GO 22047
21818: LD_INT 19
21820: DOUBLE
21821: EQUAL
21822: IFTRUE 21826
21824: GO 22046
21826: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21827: LD_ADDR_VAR 0 1
21831: PUSH
21832: LD_INT 1
21834: PUSH
21835: LD_INT 2
21837: PUSH
21838: LD_INT 3
21840: PUSH
21841: LD_INT 4
21843: PUSH
21844: LD_INT 5
21846: PUSH
21847: LD_INT 6
21849: PUSH
21850: LD_INT 7
21852: PUSH
21853: LD_INT 8
21855: PUSH
21856: LD_INT 9
21858: PUSH
21859: LD_INT 10
21861: PUSH
21862: LD_INT 11
21864: PUSH
21865: LD_INT 12
21867: PUSH
21868: LD_INT 13
21870: PUSH
21871: LD_INT 14
21873: PUSH
21874: LD_INT 15
21876: PUSH
21877: LD_INT 16
21879: PUSH
21880: LD_INT 17
21882: PUSH
21883: LD_INT 18
21885: PUSH
21886: LD_INT 19
21888: PUSH
21889: LD_INT 20
21891: PUSH
21892: LD_INT 21
21894: PUSH
21895: LD_INT 22
21897: PUSH
21898: LD_INT 23
21900: PUSH
21901: LD_INT 24
21903: PUSH
21904: LD_INT 25
21906: PUSH
21907: LD_INT 26
21909: PUSH
21910: LD_INT 27
21912: PUSH
21913: LD_INT 28
21915: PUSH
21916: LD_INT 29
21918: PUSH
21919: LD_INT 30
21921: PUSH
21922: LD_INT 31
21924: PUSH
21925: LD_INT 32
21927: PUSH
21928: LD_INT 33
21930: PUSH
21931: LD_INT 34
21933: PUSH
21934: LD_INT 35
21936: PUSH
21937: LD_INT 36
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: LIST
21953: LIST
21954: LIST
21955: LIST
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: LIST
21961: LIST
21962: LIST
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: PUSH
21978: LD_INT 101
21980: PUSH
21981: LD_INT 102
21983: PUSH
21984: LD_INT 103
21986: PUSH
21987: LD_INT 104
21989: PUSH
21990: LD_INT 105
21992: PUSH
21993: LD_INT 106
21995: PUSH
21996: LD_INT 107
21998: PUSH
21999: LD_INT 108
22001: PUSH
22002: LD_INT 109
22004: PUSH
22005: LD_INT 110
22007: PUSH
22008: LD_INT 111
22010: PUSH
22011: LD_INT 112
22013: PUSH
22014: LD_INT 113
22016: PUSH
22017: LD_INT 114
22019: PUSH
22020: LD_INT 115
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: LIST
22027: LIST
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: ST_TO_ADDR
22044: GO 22047
22046: POP
// end else
22047: GO 22084
// if campaign_id = 5 then
22049: LD_OWVAR 69
22053: PUSH
22054: LD_INT 5
22056: EQUAL
22057: IFFALSE 22084
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
22059: LD_ADDR_VAR 0 1
22063: PUSH
22064: LD_INT 1
22066: PUSH
22067: LD_INT 2
22069: PUSH
22070: EMPTY
22071: LIST
22072: LIST
22073: PUSH
22074: LD_INT 100
22076: PUSH
22077: EMPTY
22078: LIST
22079: PUSH
22080: EMPTY
22081: LIST
22082: LIST
22083: ST_TO_ADDR
// end ; if result then
22084: LD_VAR 0 1
22088: IFFALSE 22377
// begin normal :=  ;
22090: LD_ADDR_VAR 0 3
22094: PUSH
22095: LD_STRING 
22097: ST_TO_ADDR
// hardcore :=  ;
22098: LD_ADDR_VAR 0 4
22102: PUSH
22103: LD_STRING 
22105: ST_TO_ADDR
// for i = 1 to normalCounter do
22106: LD_ADDR_VAR 0 5
22110: PUSH
22111: DOUBLE
22112: LD_INT 1
22114: DEC
22115: ST_TO_ADDR
22116: LD_EXP 60
22120: PUSH
22121: FOR_TO
22122: IFFALSE 22223
// begin tmp := 0 ;
22124: LD_ADDR_VAR 0 2
22128: PUSH
22129: LD_STRING 0
22131: ST_TO_ADDR
// if result [ 1 ] then
22132: LD_VAR 0 1
22136: PUSH
22137: LD_INT 1
22139: ARRAY
22140: IFFALSE 22205
// if result [ 1 ] [ 1 ] = i then
22142: LD_VAR 0 1
22146: PUSH
22147: LD_INT 1
22149: ARRAY
22150: PUSH
22151: LD_INT 1
22153: ARRAY
22154: PUSH
22155: LD_VAR 0 5
22159: EQUAL
22160: IFFALSE 22205
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22162: LD_ADDR_VAR 0 1
22166: PUSH
22167: LD_VAR 0 1
22171: PPUSH
22172: LD_INT 1
22174: PPUSH
22175: LD_VAR 0 1
22179: PUSH
22180: LD_INT 1
22182: ARRAY
22183: PPUSH
22184: LD_INT 1
22186: PPUSH
22187: CALL_OW 3
22191: PPUSH
22192: CALL_OW 1
22196: ST_TO_ADDR
// tmp := 1 ;
22197: LD_ADDR_VAR 0 2
22201: PUSH
22202: LD_STRING 1
22204: ST_TO_ADDR
// end ; normal := normal & tmp ;
22205: LD_ADDR_VAR 0 3
22209: PUSH
22210: LD_VAR 0 3
22214: PUSH
22215: LD_VAR 0 2
22219: STR
22220: ST_TO_ADDR
// end ;
22221: GO 22121
22223: POP
22224: POP
// for i = 1 to hardcoreCounter do
22225: LD_ADDR_VAR 0 5
22229: PUSH
22230: DOUBLE
22231: LD_INT 1
22233: DEC
22234: ST_TO_ADDR
22235: LD_EXP 61
22239: PUSH
22240: FOR_TO
22241: IFFALSE 22346
// begin tmp := 0 ;
22243: LD_ADDR_VAR 0 2
22247: PUSH
22248: LD_STRING 0
22250: ST_TO_ADDR
// if result [ 2 ] then
22251: LD_VAR 0 1
22255: PUSH
22256: LD_INT 2
22258: ARRAY
22259: IFFALSE 22328
// if result [ 2 ] [ 1 ] = 100 + i then
22261: LD_VAR 0 1
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PUSH
22270: LD_INT 1
22272: ARRAY
22273: PUSH
22274: LD_INT 100
22276: PUSH
22277: LD_VAR 0 5
22281: PLUS
22282: EQUAL
22283: IFFALSE 22328
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22285: LD_ADDR_VAR 0 1
22289: PUSH
22290: LD_VAR 0 1
22294: PPUSH
22295: LD_INT 2
22297: PPUSH
22298: LD_VAR 0 1
22302: PUSH
22303: LD_INT 2
22305: ARRAY
22306: PPUSH
22307: LD_INT 1
22309: PPUSH
22310: CALL_OW 3
22314: PPUSH
22315: CALL_OW 1
22319: ST_TO_ADDR
// tmp := 1 ;
22320: LD_ADDR_VAR 0 2
22324: PUSH
22325: LD_STRING 1
22327: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22328: LD_ADDR_VAR 0 4
22332: PUSH
22333: LD_VAR 0 4
22337: PUSH
22338: LD_VAR 0 2
22342: STR
22343: ST_TO_ADDR
// end ;
22344: GO 22240
22346: POP
22347: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22348: LD_STRING getStreamItemsFromMission("
22350: PUSH
22351: LD_VAR 0 3
22355: STR
22356: PUSH
22357: LD_STRING ","
22359: STR
22360: PUSH
22361: LD_VAR 0 4
22365: STR
22366: PUSH
22367: LD_STRING ")
22369: STR
22370: PPUSH
22371: CALL_OW 559
// end else
22375: GO 22384
// ToLua ( getStreamItemsFromMission("","") ) ;
22377: LD_STRING getStreamItemsFromMission("","")
22379: PPUSH
22380: CALL_OW 559
// end ;
22384: LD_VAR 0 1
22388: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22389: LD_VAR 0 2
22393: PUSH
22394: LD_INT 100
22396: EQUAL
22397: IFFALSE 23346
// begin if not StreamModeActive then
22399: LD_EXP 59
22403: NOT
22404: IFFALSE 22414
// StreamModeActive := true ;
22406: LD_ADDR_EXP 59
22410: PUSH
22411: LD_INT 1
22413: ST_TO_ADDR
// if p3 = 0 then
22414: LD_VAR 0 3
22418: PUSH
22419: LD_INT 0
22421: EQUAL
22422: IFFALSE 22428
// InitStreamMode ;
22424: CALL 18649 0 0
// if p3 = 1 then
22428: LD_VAR 0 3
22432: PUSH
22433: LD_INT 1
22435: EQUAL
22436: IFFALSE 22446
// sRocket := true ;
22438: LD_ADDR_EXP 64
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// if p3 = 2 then
22446: LD_VAR 0 3
22450: PUSH
22451: LD_INT 2
22453: EQUAL
22454: IFFALSE 22464
// sSpeed := true ;
22456: LD_ADDR_EXP 63
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
// if p3 = 3 then
22464: LD_VAR 0 3
22468: PUSH
22469: LD_INT 3
22471: EQUAL
22472: IFFALSE 22482
// sEngine := true ;
22474: LD_ADDR_EXP 65
22478: PUSH
22479: LD_INT 1
22481: ST_TO_ADDR
// if p3 = 4 then
22482: LD_VAR 0 3
22486: PUSH
22487: LD_INT 4
22489: EQUAL
22490: IFFALSE 22500
// sSpec := true ;
22492: LD_ADDR_EXP 62
22496: PUSH
22497: LD_INT 1
22499: ST_TO_ADDR
// if p3 = 5 then
22500: LD_VAR 0 3
22504: PUSH
22505: LD_INT 5
22507: EQUAL
22508: IFFALSE 22518
// sLevel := true ;
22510: LD_ADDR_EXP 66
22514: PUSH
22515: LD_INT 1
22517: ST_TO_ADDR
// if p3 = 6 then
22518: LD_VAR 0 3
22522: PUSH
22523: LD_INT 6
22525: EQUAL
22526: IFFALSE 22536
// sArmoury := true ;
22528: LD_ADDR_EXP 67
22532: PUSH
22533: LD_INT 1
22535: ST_TO_ADDR
// if p3 = 7 then
22536: LD_VAR 0 3
22540: PUSH
22541: LD_INT 7
22543: EQUAL
22544: IFFALSE 22554
// sRadar := true ;
22546: LD_ADDR_EXP 68
22550: PUSH
22551: LD_INT 1
22553: ST_TO_ADDR
// if p3 = 8 then
22554: LD_VAR 0 3
22558: PUSH
22559: LD_INT 8
22561: EQUAL
22562: IFFALSE 22572
// sBunker := true ;
22564: LD_ADDR_EXP 69
22568: PUSH
22569: LD_INT 1
22571: ST_TO_ADDR
// if p3 = 9 then
22572: LD_VAR 0 3
22576: PUSH
22577: LD_INT 9
22579: EQUAL
22580: IFFALSE 22590
// sHack := true ;
22582: LD_ADDR_EXP 70
22586: PUSH
22587: LD_INT 1
22589: ST_TO_ADDR
// if p3 = 10 then
22590: LD_VAR 0 3
22594: PUSH
22595: LD_INT 10
22597: EQUAL
22598: IFFALSE 22608
// sFire := true ;
22600: LD_ADDR_EXP 71
22604: PUSH
22605: LD_INT 1
22607: ST_TO_ADDR
// if p3 = 11 then
22608: LD_VAR 0 3
22612: PUSH
22613: LD_INT 11
22615: EQUAL
22616: IFFALSE 22626
// sRefresh := true ;
22618: LD_ADDR_EXP 72
22622: PUSH
22623: LD_INT 1
22625: ST_TO_ADDR
// if p3 = 12 then
22626: LD_VAR 0 3
22630: PUSH
22631: LD_INT 12
22633: EQUAL
22634: IFFALSE 22644
// sExp := true ;
22636: LD_ADDR_EXP 73
22640: PUSH
22641: LD_INT 1
22643: ST_TO_ADDR
// if p3 = 13 then
22644: LD_VAR 0 3
22648: PUSH
22649: LD_INT 13
22651: EQUAL
22652: IFFALSE 22662
// sDepot := true ;
22654: LD_ADDR_EXP 74
22658: PUSH
22659: LD_INT 1
22661: ST_TO_ADDR
// if p3 = 14 then
22662: LD_VAR 0 3
22666: PUSH
22667: LD_INT 14
22669: EQUAL
22670: IFFALSE 22680
// sFlag := true ;
22672: LD_ADDR_EXP 75
22676: PUSH
22677: LD_INT 1
22679: ST_TO_ADDR
// if p3 = 15 then
22680: LD_VAR 0 3
22684: PUSH
22685: LD_INT 15
22687: EQUAL
22688: IFFALSE 22698
// sKamikadze := true ;
22690: LD_ADDR_EXP 83
22694: PUSH
22695: LD_INT 1
22697: ST_TO_ADDR
// if p3 = 16 then
22698: LD_VAR 0 3
22702: PUSH
22703: LD_INT 16
22705: EQUAL
22706: IFFALSE 22716
// sTroll := true ;
22708: LD_ADDR_EXP 84
22712: PUSH
22713: LD_INT 1
22715: ST_TO_ADDR
// if p3 = 17 then
22716: LD_VAR 0 3
22720: PUSH
22721: LD_INT 17
22723: EQUAL
22724: IFFALSE 22734
// sSlow := true ;
22726: LD_ADDR_EXP 85
22730: PUSH
22731: LD_INT 1
22733: ST_TO_ADDR
// if p3 = 18 then
22734: LD_VAR 0 3
22738: PUSH
22739: LD_INT 18
22741: EQUAL
22742: IFFALSE 22752
// sLack := true ;
22744: LD_ADDR_EXP 86
22748: PUSH
22749: LD_INT 1
22751: ST_TO_ADDR
// if p3 = 19 then
22752: LD_VAR 0 3
22756: PUSH
22757: LD_INT 19
22759: EQUAL
22760: IFFALSE 22770
// sTank := true ;
22762: LD_ADDR_EXP 88
22766: PUSH
22767: LD_INT 1
22769: ST_TO_ADDR
// if p3 = 20 then
22770: LD_VAR 0 3
22774: PUSH
22775: LD_INT 20
22777: EQUAL
22778: IFFALSE 22788
// sRemote := true ;
22780: LD_ADDR_EXP 89
22784: PUSH
22785: LD_INT 1
22787: ST_TO_ADDR
// if p3 = 21 then
22788: LD_VAR 0 3
22792: PUSH
22793: LD_INT 21
22795: EQUAL
22796: IFFALSE 22806
// sPowell := true ;
22798: LD_ADDR_EXP 90
22802: PUSH
22803: LD_INT 1
22805: ST_TO_ADDR
// if p3 = 22 then
22806: LD_VAR 0 3
22810: PUSH
22811: LD_INT 22
22813: EQUAL
22814: IFFALSE 22824
// sTeleport := true ;
22816: LD_ADDR_EXP 93
22820: PUSH
22821: LD_INT 1
22823: ST_TO_ADDR
// if p3 = 23 then
22824: LD_VAR 0 3
22828: PUSH
22829: LD_INT 23
22831: EQUAL
22832: IFFALSE 22842
// sOilTower := true ;
22834: LD_ADDR_EXP 95
22838: PUSH
22839: LD_INT 1
22841: ST_TO_ADDR
// if p3 = 24 then
22842: LD_VAR 0 3
22846: PUSH
22847: LD_INT 24
22849: EQUAL
22850: IFFALSE 22860
// sShovel := true ;
22852: LD_ADDR_EXP 96
22856: PUSH
22857: LD_INT 1
22859: ST_TO_ADDR
// if p3 = 25 then
22860: LD_VAR 0 3
22864: PUSH
22865: LD_INT 25
22867: EQUAL
22868: IFFALSE 22878
// sSheik := true ;
22870: LD_ADDR_EXP 97
22874: PUSH
22875: LD_INT 1
22877: ST_TO_ADDR
// if p3 = 26 then
22878: LD_VAR 0 3
22882: PUSH
22883: LD_INT 26
22885: EQUAL
22886: IFFALSE 22896
// sEarthquake := true ;
22888: LD_ADDR_EXP 99
22892: PUSH
22893: LD_INT 1
22895: ST_TO_ADDR
// if p3 = 27 then
22896: LD_VAR 0 3
22900: PUSH
22901: LD_INT 27
22903: EQUAL
22904: IFFALSE 22914
// sAI := true ;
22906: LD_ADDR_EXP 100
22910: PUSH
22911: LD_INT 1
22913: ST_TO_ADDR
// if p3 = 28 then
22914: LD_VAR 0 3
22918: PUSH
22919: LD_INT 28
22921: EQUAL
22922: IFFALSE 22932
// sCargo := true ;
22924: LD_ADDR_EXP 103
22928: PUSH
22929: LD_INT 1
22931: ST_TO_ADDR
// if p3 = 29 then
22932: LD_VAR 0 3
22936: PUSH
22937: LD_INT 29
22939: EQUAL
22940: IFFALSE 22950
// sDLaser := true ;
22942: LD_ADDR_EXP 104
22946: PUSH
22947: LD_INT 1
22949: ST_TO_ADDR
// if p3 = 30 then
22950: LD_VAR 0 3
22954: PUSH
22955: LD_INT 30
22957: EQUAL
22958: IFFALSE 22968
// sExchange := true ;
22960: LD_ADDR_EXP 105
22964: PUSH
22965: LD_INT 1
22967: ST_TO_ADDR
// if p3 = 31 then
22968: LD_VAR 0 3
22972: PUSH
22973: LD_INT 31
22975: EQUAL
22976: IFFALSE 22986
// sFac := true ;
22978: LD_ADDR_EXP 106
22982: PUSH
22983: LD_INT 1
22985: ST_TO_ADDR
// if p3 = 32 then
22986: LD_VAR 0 3
22990: PUSH
22991: LD_INT 32
22993: EQUAL
22994: IFFALSE 23004
// sPower := true ;
22996: LD_ADDR_EXP 107
23000: PUSH
23001: LD_INT 1
23003: ST_TO_ADDR
// if p3 = 33 then
23004: LD_VAR 0 3
23008: PUSH
23009: LD_INT 33
23011: EQUAL
23012: IFFALSE 23022
// sRandom := true ;
23014: LD_ADDR_EXP 108
23018: PUSH
23019: LD_INT 1
23021: ST_TO_ADDR
// if p3 = 34 then
23022: LD_VAR 0 3
23026: PUSH
23027: LD_INT 34
23029: EQUAL
23030: IFFALSE 23040
// sShield := true ;
23032: LD_ADDR_EXP 109
23036: PUSH
23037: LD_INT 1
23039: ST_TO_ADDR
// if p3 = 35 then
23040: LD_VAR 0 3
23044: PUSH
23045: LD_INT 35
23047: EQUAL
23048: IFFALSE 23058
// sTime := true ;
23050: LD_ADDR_EXP 110
23054: PUSH
23055: LD_INT 1
23057: ST_TO_ADDR
// if p3 = 36 then
23058: LD_VAR 0 3
23062: PUSH
23063: LD_INT 36
23065: EQUAL
23066: IFFALSE 23076
// sTools := true ;
23068: LD_ADDR_EXP 111
23072: PUSH
23073: LD_INT 1
23075: ST_TO_ADDR
// if p3 = 101 then
23076: LD_VAR 0 3
23080: PUSH
23081: LD_INT 101
23083: EQUAL
23084: IFFALSE 23094
// sSold := true ;
23086: LD_ADDR_EXP 76
23090: PUSH
23091: LD_INT 1
23093: ST_TO_ADDR
// if p3 = 102 then
23094: LD_VAR 0 3
23098: PUSH
23099: LD_INT 102
23101: EQUAL
23102: IFFALSE 23112
// sDiff := true ;
23104: LD_ADDR_EXP 77
23108: PUSH
23109: LD_INT 1
23111: ST_TO_ADDR
// if p3 = 103 then
23112: LD_VAR 0 3
23116: PUSH
23117: LD_INT 103
23119: EQUAL
23120: IFFALSE 23130
// sFog := true ;
23122: LD_ADDR_EXP 80
23126: PUSH
23127: LD_INT 1
23129: ST_TO_ADDR
// if p3 = 104 then
23130: LD_VAR 0 3
23134: PUSH
23135: LD_INT 104
23137: EQUAL
23138: IFFALSE 23148
// sReset := true ;
23140: LD_ADDR_EXP 81
23144: PUSH
23145: LD_INT 1
23147: ST_TO_ADDR
// if p3 = 105 then
23148: LD_VAR 0 3
23152: PUSH
23153: LD_INT 105
23155: EQUAL
23156: IFFALSE 23166
// sSun := true ;
23158: LD_ADDR_EXP 82
23162: PUSH
23163: LD_INT 1
23165: ST_TO_ADDR
// if p3 = 106 then
23166: LD_VAR 0 3
23170: PUSH
23171: LD_INT 106
23173: EQUAL
23174: IFFALSE 23184
// sTiger := true ;
23176: LD_ADDR_EXP 78
23180: PUSH
23181: LD_INT 1
23183: ST_TO_ADDR
// if p3 = 107 then
23184: LD_VAR 0 3
23188: PUSH
23189: LD_INT 107
23191: EQUAL
23192: IFFALSE 23202
// sBomb := true ;
23194: LD_ADDR_EXP 79
23198: PUSH
23199: LD_INT 1
23201: ST_TO_ADDR
// if p3 = 108 then
23202: LD_VAR 0 3
23206: PUSH
23207: LD_INT 108
23209: EQUAL
23210: IFFALSE 23220
// sWound := true ;
23212: LD_ADDR_EXP 87
23216: PUSH
23217: LD_INT 1
23219: ST_TO_ADDR
// if p3 = 109 then
23220: LD_VAR 0 3
23224: PUSH
23225: LD_INT 109
23227: EQUAL
23228: IFFALSE 23238
// sBetray := true ;
23230: LD_ADDR_EXP 91
23234: PUSH
23235: LD_INT 1
23237: ST_TO_ADDR
// if p3 = 110 then
23238: LD_VAR 0 3
23242: PUSH
23243: LD_INT 110
23245: EQUAL
23246: IFFALSE 23256
// sContamin := true ;
23248: LD_ADDR_EXP 92
23252: PUSH
23253: LD_INT 1
23255: ST_TO_ADDR
// if p3 = 111 then
23256: LD_VAR 0 3
23260: PUSH
23261: LD_INT 111
23263: EQUAL
23264: IFFALSE 23274
// sOil := true ;
23266: LD_ADDR_EXP 94
23270: PUSH
23271: LD_INT 1
23273: ST_TO_ADDR
// if p3 = 112 then
23274: LD_VAR 0 3
23278: PUSH
23279: LD_INT 112
23281: EQUAL
23282: IFFALSE 23292
// sStu := true ;
23284: LD_ADDR_EXP 98
23288: PUSH
23289: LD_INT 1
23291: ST_TO_ADDR
// if p3 = 113 then
23292: LD_VAR 0 3
23296: PUSH
23297: LD_INT 113
23299: EQUAL
23300: IFFALSE 23310
// sBazooka := true ;
23302: LD_ADDR_EXP 101
23306: PUSH
23307: LD_INT 1
23309: ST_TO_ADDR
// if p3 = 114 then
23310: LD_VAR 0 3
23314: PUSH
23315: LD_INT 114
23317: EQUAL
23318: IFFALSE 23328
// sMortar := true ;
23320: LD_ADDR_EXP 102
23324: PUSH
23325: LD_INT 1
23327: ST_TO_ADDR
// if p3 = 115 then
23328: LD_VAR 0 3
23332: PUSH
23333: LD_INT 115
23335: EQUAL
23336: IFFALSE 23346
// sRanger := true ;
23338: LD_ADDR_EXP 112
23342: PUSH
23343: LD_INT 1
23345: ST_TO_ADDR
// end ; end ;
23346: PPOPN 6
23348: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23349: LD_EXP 59
23353: PUSH
23354: LD_EXP 64
23358: AND
23359: IFFALSE 23483
23361: GO 23363
23363: DISABLE
23364: LD_INT 0
23366: PPUSH
23367: PPUSH
// begin enable ;
23368: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23369: LD_ADDR_VAR 0 2
23373: PUSH
23374: LD_INT 22
23376: PUSH
23377: LD_OWVAR 2
23381: PUSH
23382: EMPTY
23383: LIST
23384: LIST
23385: PUSH
23386: LD_INT 2
23388: PUSH
23389: LD_INT 34
23391: PUSH
23392: LD_INT 7
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: PUSH
23399: LD_INT 34
23401: PUSH
23402: LD_INT 45
23404: PUSH
23405: EMPTY
23406: LIST
23407: LIST
23408: PUSH
23409: LD_INT 34
23411: PUSH
23412: LD_INT 28
23414: PUSH
23415: EMPTY
23416: LIST
23417: LIST
23418: PUSH
23419: LD_INT 34
23421: PUSH
23422: LD_INT 47
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: PUSH
23429: EMPTY
23430: LIST
23431: LIST
23432: LIST
23433: LIST
23434: LIST
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: PPUSH
23440: CALL_OW 69
23444: ST_TO_ADDR
// if not tmp then
23445: LD_VAR 0 2
23449: NOT
23450: IFFALSE 23454
// exit ;
23452: GO 23483
// for i in tmp do
23454: LD_ADDR_VAR 0 1
23458: PUSH
23459: LD_VAR 0 2
23463: PUSH
23464: FOR_IN
23465: IFFALSE 23481
// begin SetLives ( i , 0 ) ;
23467: LD_VAR 0 1
23471: PPUSH
23472: LD_INT 0
23474: PPUSH
23475: CALL_OW 234
// end ;
23479: GO 23464
23481: POP
23482: POP
// end ;
23483: PPOPN 2
23485: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23486: LD_EXP 59
23490: PUSH
23491: LD_EXP 65
23495: AND
23496: IFFALSE 23580
23498: GO 23500
23500: DISABLE
23501: LD_INT 0
23503: PPUSH
23504: PPUSH
// begin enable ;
23505: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23506: LD_ADDR_VAR 0 2
23510: PUSH
23511: LD_INT 22
23513: PUSH
23514: LD_OWVAR 2
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: PUSH
23523: LD_INT 32
23525: PUSH
23526: LD_INT 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PPUSH
23537: CALL_OW 69
23541: ST_TO_ADDR
// if not tmp then
23542: LD_VAR 0 2
23546: NOT
23547: IFFALSE 23551
// exit ;
23549: GO 23580
// for i in tmp do
23551: LD_ADDR_VAR 0 1
23555: PUSH
23556: LD_VAR 0 2
23560: PUSH
23561: FOR_IN
23562: IFFALSE 23578
// begin SetLives ( i , 0 ) ;
23564: LD_VAR 0 1
23568: PPUSH
23569: LD_INT 0
23571: PPUSH
23572: CALL_OW 234
// end ;
23576: GO 23561
23578: POP
23579: POP
// end ;
23580: PPOPN 2
23582: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23583: LD_EXP 59
23587: PUSH
23588: LD_EXP 62
23592: AND
23593: IFFALSE 23686
23595: GO 23597
23597: DISABLE
23598: LD_INT 0
23600: PPUSH
// begin enable ;
23601: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23602: LD_ADDR_VAR 0 1
23606: PUSH
23607: LD_INT 22
23609: PUSH
23610: LD_OWVAR 2
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: PUSH
23619: LD_INT 2
23621: PUSH
23622: LD_INT 25
23624: PUSH
23625: LD_INT 5
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 25
23634: PUSH
23635: LD_INT 9
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: LD_INT 25
23644: PUSH
23645: LD_INT 8
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 69
23666: PUSH
23667: FOR_IN
23668: IFFALSE 23684
// begin SetClass ( i , 1 ) ;
23670: LD_VAR 0 1
23674: PPUSH
23675: LD_INT 1
23677: PPUSH
23678: CALL_OW 336
// end ;
23682: GO 23667
23684: POP
23685: POP
// end ;
23686: PPOPN 1
23688: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23689: LD_EXP 59
23693: PUSH
23694: LD_EXP 63
23698: AND
23699: PUSH
23700: LD_OWVAR 65
23704: PUSH
23705: LD_INT 7
23707: LESS
23708: AND
23709: IFFALSE 23723
23711: GO 23713
23713: DISABLE
// begin enable ;
23714: ENABLE
// game_speed := 7 ;
23715: LD_ADDR_OWVAR 65
23719: PUSH
23720: LD_INT 7
23722: ST_TO_ADDR
// end ;
23723: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23724: LD_EXP 59
23728: PUSH
23729: LD_EXP 66
23733: AND
23734: IFFALSE 23936
23736: GO 23738
23738: DISABLE
23739: LD_INT 0
23741: PPUSH
23742: PPUSH
23743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 81
23751: PUSH
23752: LD_OWVAR 2
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: LD_INT 21
23763: PUSH
23764: LD_INT 1
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PUSH
23771: EMPTY
23772: LIST
23773: LIST
23774: PPUSH
23775: CALL_OW 69
23779: ST_TO_ADDR
// if not tmp then
23780: LD_VAR 0 3
23784: NOT
23785: IFFALSE 23789
// exit ;
23787: GO 23936
// if tmp > 5 then
23789: LD_VAR 0 3
23793: PUSH
23794: LD_INT 5
23796: GREATER
23797: IFFALSE 23809
// k := 5 else
23799: LD_ADDR_VAR 0 2
23803: PUSH
23804: LD_INT 5
23806: ST_TO_ADDR
23807: GO 23819
// k := tmp ;
23809: LD_ADDR_VAR 0 2
23813: PUSH
23814: LD_VAR 0 3
23818: ST_TO_ADDR
// for i := 1 to k do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: DOUBLE
23825: LD_INT 1
23827: DEC
23828: ST_TO_ADDR
23829: LD_VAR 0 2
23833: PUSH
23834: FOR_TO
23835: IFFALSE 23934
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23837: LD_VAR 0 3
23841: PUSH
23842: LD_VAR 0 1
23846: ARRAY
23847: PPUSH
23848: LD_VAR 0 1
23852: PUSH
23853: LD_INT 4
23855: MOD
23856: PUSH
23857: LD_INT 1
23859: PLUS
23860: PPUSH
23861: CALL_OW 259
23865: PUSH
23866: LD_INT 10
23868: LESS
23869: IFFALSE 23932
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23871: LD_VAR 0 3
23875: PUSH
23876: LD_VAR 0 1
23880: ARRAY
23881: PPUSH
23882: LD_VAR 0 1
23886: PUSH
23887: LD_INT 4
23889: MOD
23890: PUSH
23891: LD_INT 1
23893: PLUS
23894: PPUSH
23895: LD_VAR 0 3
23899: PUSH
23900: LD_VAR 0 1
23904: ARRAY
23905: PPUSH
23906: LD_VAR 0 1
23910: PUSH
23911: LD_INT 4
23913: MOD
23914: PUSH
23915: LD_INT 1
23917: PLUS
23918: PPUSH
23919: CALL_OW 259
23923: PUSH
23924: LD_INT 1
23926: PLUS
23927: PPUSH
23928: CALL_OW 237
23932: GO 23834
23934: POP
23935: POP
// end ;
23936: PPOPN 3
23938: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23939: LD_EXP 59
23943: PUSH
23944: LD_EXP 67
23948: AND
23949: IFFALSE 23969
23951: GO 23953
23953: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23954: LD_INT 4
23956: PPUSH
23957: LD_OWVAR 2
23961: PPUSH
23962: LD_INT 0
23964: PPUSH
23965: CALL_OW 324
23969: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23970: LD_EXP 59
23974: PUSH
23975: LD_EXP 96
23979: AND
23980: IFFALSE 24000
23982: GO 23984
23984: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23985: LD_INT 19
23987: PPUSH
23988: LD_OWVAR 2
23992: PPUSH
23993: LD_INT 0
23995: PPUSH
23996: CALL_OW 324
24000: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24001: LD_EXP 59
24005: PUSH
24006: LD_EXP 68
24010: AND
24011: IFFALSE 24113
24013: GO 24015
24015: DISABLE
24016: LD_INT 0
24018: PPUSH
24019: PPUSH
// begin enable ;
24020: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24021: LD_ADDR_VAR 0 2
24025: PUSH
24026: LD_INT 22
24028: PUSH
24029: LD_OWVAR 2
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: PUSH
24038: LD_INT 2
24040: PUSH
24041: LD_INT 34
24043: PUSH
24044: LD_INT 11
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: PUSH
24051: LD_INT 34
24053: PUSH
24054: LD_INT 30
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: LIST
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: PPUSH
24070: CALL_OW 69
24074: ST_TO_ADDR
// if not tmp then
24075: LD_VAR 0 2
24079: NOT
24080: IFFALSE 24084
// exit ;
24082: GO 24113
// for i in tmp do
24084: LD_ADDR_VAR 0 1
24088: PUSH
24089: LD_VAR 0 2
24093: PUSH
24094: FOR_IN
24095: IFFALSE 24111
// begin SetLives ( i , 0 ) ;
24097: LD_VAR 0 1
24101: PPUSH
24102: LD_INT 0
24104: PPUSH
24105: CALL_OW 234
// end ;
24109: GO 24094
24111: POP
24112: POP
// end ;
24113: PPOPN 2
24115: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24116: LD_EXP 59
24120: PUSH
24121: LD_EXP 69
24125: AND
24126: IFFALSE 24146
24128: GO 24130
24130: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24131: LD_INT 32
24133: PPUSH
24134: LD_OWVAR 2
24138: PPUSH
24139: LD_INT 0
24141: PPUSH
24142: CALL_OW 324
24146: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24147: LD_EXP 59
24151: PUSH
24152: LD_EXP 70
24156: AND
24157: IFFALSE 24338
24159: GO 24161
24161: DISABLE
24162: LD_INT 0
24164: PPUSH
24165: PPUSH
24166: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24167: LD_ADDR_VAR 0 2
24171: PUSH
24172: LD_INT 22
24174: PUSH
24175: LD_OWVAR 2
24179: PUSH
24180: EMPTY
24181: LIST
24182: LIST
24183: PUSH
24184: LD_INT 33
24186: PUSH
24187: LD_INT 3
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PPUSH
24198: CALL_OW 69
24202: ST_TO_ADDR
// if not tmp then
24203: LD_VAR 0 2
24207: NOT
24208: IFFALSE 24212
// exit ;
24210: GO 24338
// side := 0 ;
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 0
24219: ST_TO_ADDR
// for i := 1 to 8 do
24220: LD_ADDR_VAR 0 1
24224: PUSH
24225: DOUBLE
24226: LD_INT 1
24228: DEC
24229: ST_TO_ADDR
24230: LD_INT 8
24232: PUSH
24233: FOR_TO
24234: IFFALSE 24282
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24236: LD_OWVAR 2
24240: PUSH
24241: LD_VAR 0 1
24245: NONEQUAL
24246: PUSH
24247: LD_OWVAR 2
24251: PPUSH
24252: LD_VAR 0 1
24256: PPUSH
24257: CALL_OW 81
24261: PUSH
24262: LD_INT 2
24264: EQUAL
24265: AND
24266: IFFALSE 24280
// begin side := i ;
24268: LD_ADDR_VAR 0 3
24272: PUSH
24273: LD_VAR 0 1
24277: ST_TO_ADDR
// break ;
24278: GO 24282
// end ;
24280: GO 24233
24282: POP
24283: POP
// if not side then
24284: LD_VAR 0 3
24288: NOT
24289: IFFALSE 24293
// exit ;
24291: GO 24338
// for i := 1 to tmp do
24293: LD_ADDR_VAR 0 1
24297: PUSH
24298: DOUBLE
24299: LD_INT 1
24301: DEC
24302: ST_TO_ADDR
24303: LD_VAR 0 2
24307: PUSH
24308: FOR_TO
24309: IFFALSE 24336
// if Prob ( 60 ) then
24311: LD_INT 60
24313: PPUSH
24314: CALL_OW 13
24318: IFFALSE 24334
// SetSide ( i , side ) ;
24320: LD_VAR 0 1
24324: PPUSH
24325: LD_VAR 0 3
24329: PPUSH
24330: CALL_OW 235
24334: GO 24308
24336: POP
24337: POP
// end ;
24338: PPOPN 3
24340: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24341: LD_EXP 59
24345: PUSH
24346: LD_EXP 72
24350: AND
24351: IFFALSE 24470
24353: GO 24355
24355: DISABLE
24356: LD_INT 0
24358: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24359: LD_ADDR_VAR 0 1
24363: PUSH
24364: LD_INT 22
24366: PUSH
24367: LD_OWVAR 2
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: LD_INT 21
24378: PUSH
24379: LD_INT 1
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PUSH
24386: LD_INT 3
24388: PUSH
24389: LD_INT 23
24391: PUSH
24392: LD_INT 0
24394: PUSH
24395: EMPTY
24396: LIST
24397: LIST
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: PUSH
24403: EMPTY
24404: LIST
24405: LIST
24406: LIST
24407: PPUSH
24408: CALL_OW 69
24412: PUSH
24413: FOR_IN
24414: IFFALSE 24468
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24416: LD_VAR 0 1
24420: PPUSH
24421: CALL_OW 257
24425: PUSH
24426: LD_INT 1
24428: PUSH
24429: LD_INT 2
24431: PUSH
24432: LD_INT 3
24434: PUSH
24435: LD_INT 4
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: LIST
24442: LIST
24443: IN
24444: IFFALSE 24466
// SetClass ( un , rand ( 1 , 4 ) ) ;
24446: LD_VAR 0 1
24450: PPUSH
24451: LD_INT 1
24453: PPUSH
24454: LD_INT 4
24456: PPUSH
24457: CALL_OW 12
24461: PPUSH
24462: CALL_OW 336
24466: GO 24413
24468: POP
24469: POP
// end ;
24470: PPOPN 1
24472: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24473: LD_EXP 59
24477: PUSH
24478: LD_EXP 71
24482: AND
24483: IFFALSE 24562
24485: GO 24487
24487: DISABLE
24488: LD_INT 0
24490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24491: LD_ADDR_VAR 0 1
24495: PUSH
24496: LD_INT 22
24498: PUSH
24499: LD_OWVAR 2
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: PUSH
24508: LD_INT 21
24510: PUSH
24511: LD_INT 3
24513: PUSH
24514: EMPTY
24515: LIST
24516: LIST
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PPUSH
24522: CALL_OW 69
24526: ST_TO_ADDR
// if not tmp then
24527: LD_VAR 0 1
24531: NOT
24532: IFFALSE 24536
// exit ;
24534: GO 24562
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24536: LD_VAR 0 1
24540: PUSH
24541: LD_INT 1
24543: PPUSH
24544: LD_VAR 0 1
24548: PPUSH
24549: CALL_OW 12
24553: ARRAY
24554: PPUSH
24555: LD_INT 100
24557: PPUSH
24558: CALL_OW 234
// end ;
24562: PPOPN 1
24564: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24565: LD_EXP 59
24569: PUSH
24570: LD_EXP 73
24574: AND
24575: IFFALSE 24673
24577: GO 24579
24579: DISABLE
24580: LD_INT 0
24582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24583: LD_ADDR_VAR 0 1
24587: PUSH
24588: LD_INT 22
24590: PUSH
24591: LD_OWVAR 2
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 21
24602: PUSH
24603: LD_INT 1
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PPUSH
24614: CALL_OW 69
24618: ST_TO_ADDR
// if not tmp then
24619: LD_VAR 0 1
24623: NOT
24624: IFFALSE 24628
// exit ;
24626: GO 24673
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24628: LD_VAR 0 1
24632: PUSH
24633: LD_INT 1
24635: PPUSH
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL_OW 12
24645: ARRAY
24646: PPUSH
24647: LD_INT 1
24649: PPUSH
24650: LD_INT 4
24652: PPUSH
24653: CALL_OW 12
24657: PPUSH
24658: LD_INT 3000
24660: PPUSH
24661: LD_INT 9000
24663: PPUSH
24664: CALL_OW 12
24668: PPUSH
24669: CALL_OW 492
// end ;
24673: PPOPN 1
24675: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24676: LD_EXP 59
24680: PUSH
24681: LD_EXP 74
24685: AND
24686: IFFALSE 24706
24688: GO 24690
24690: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24691: LD_INT 1
24693: PPUSH
24694: LD_OWVAR 2
24698: PPUSH
24699: LD_INT 0
24701: PPUSH
24702: CALL_OW 324
24706: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24707: LD_EXP 59
24711: PUSH
24712: LD_EXP 75
24716: AND
24717: IFFALSE 24800
24719: GO 24721
24721: DISABLE
24722: LD_INT 0
24724: PPUSH
24725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24726: LD_ADDR_VAR 0 2
24730: PUSH
24731: LD_INT 22
24733: PUSH
24734: LD_OWVAR 2
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PUSH
24743: LD_INT 21
24745: PUSH
24746: LD_INT 3
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PPUSH
24757: CALL_OW 69
24761: ST_TO_ADDR
// if not tmp then
24762: LD_VAR 0 2
24766: NOT
24767: IFFALSE 24771
// exit ;
24769: GO 24800
// for i in tmp do
24771: LD_ADDR_VAR 0 1
24775: PUSH
24776: LD_VAR 0 2
24780: PUSH
24781: FOR_IN
24782: IFFALSE 24798
// SetBLevel ( i , 10 ) ;
24784: LD_VAR 0 1
24788: PPUSH
24789: LD_INT 10
24791: PPUSH
24792: CALL_OW 241
24796: GO 24781
24798: POP
24799: POP
// end ;
24800: PPOPN 2
24802: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24803: LD_EXP 59
24807: PUSH
24808: LD_EXP 76
24812: AND
24813: IFFALSE 24924
24815: GO 24817
24817: DISABLE
24818: LD_INT 0
24820: PPUSH
24821: PPUSH
24822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24823: LD_ADDR_VAR 0 3
24827: PUSH
24828: LD_INT 22
24830: PUSH
24831: LD_OWVAR 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 25
24842: PUSH
24843: LD_INT 1
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: PPUSH
24854: CALL_OW 69
24858: ST_TO_ADDR
// if not tmp then
24859: LD_VAR 0 3
24863: NOT
24864: IFFALSE 24868
// exit ;
24866: GO 24924
// un := tmp [ rand ( 1 , tmp ) ] ;
24868: LD_ADDR_VAR 0 2
24872: PUSH
24873: LD_VAR 0 3
24877: PUSH
24878: LD_INT 1
24880: PPUSH
24881: LD_VAR 0 3
24885: PPUSH
24886: CALL_OW 12
24890: ARRAY
24891: ST_TO_ADDR
// if Crawls ( un ) then
24892: LD_VAR 0 2
24896: PPUSH
24897: CALL_OW 318
24901: IFFALSE 24912
// ComWalk ( un ) ;
24903: LD_VAR 0 2
24907: PPUSH
24908: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24912: LD_VAR 0 2
24916: PPUSH
24917: LD_INT 5
24919: PPUSH
24920: CALL_OW 336
// end ;
24924: PPOPN 3
24926: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24927: LD_EXP 59
24931: PUSH
24932: LD_EXP 77
24936: AND
24937: PUSH
24938: LD_OWVAR 67
24942: PUSH
24943: LD_INT 3
24945: LESS
24946: AND
24947: IFFALSE 24966
24949: GO 24951
24951: DISABLE
// Difficulty := Difficulty + 1 ;
24952: LD_ADDR_OWVAR 67
24956: PUSH
24957: LD_OWVAR 67
24961: PUSH
24962: LD_INT 1
24964: PLUS
24965: ST_TO_ADDR
24966: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24967: LD_EXP 59
24971: PUSH
24972: LD_EXP 78
24976: AND
24977: IFFALSE 25080
24979: GO 24981
24981: DISABLE
24982: LD_INT 0
24984: PPUSH
// begin for i := 1 to 5 do
24985: LD_ADDR_VAR 0 1
24989: PUSH
24990: DOUBLE
24991: LD_INT 1
24993: DEC
24994: ST_TO_ADDR
24995: LD_INT 5
24997: PUSH
24998: FOR_TO
24999: IFFALSE 25078
// begin uc_nation := nation_nature ;
25001: LD_ADDR_OWVAR 21
25005: PUSH
25006: LD_INT 0
25008: ST_TO_ADDR
// uc_side := 0 ;
25009: LD_ADDR_OWVAR 20
25013: PUSH
25014: LD_INT 0
25016: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25017: LD_ADDR_OWVAR 29
25021: PUSH
25022: LD_INT 12
25024: PUSH
25025: LD_INT 12
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: ST_TO_ADDR
// hc_agressivity := 20 ;
25032: LD_ADDR_OWVAR 35
25036: PUSH
25037: LD_INT 20
25039: ST_TO_ADDR
// hc_class := class_tiger ;
25040: LD_ADDR_OWVAR 28
25044: PUSH
25045: LD_INT 14
25047: ST_TO_ADDR
// hc_gallery :=  ;
25048: LD_ADDR_OWVAR 33
25052: PUSH
25053: LD_STRING 
25055: ST_TO_ADDR
// hc_name :=  ;
25056: LD_ADDR_OWVAR 26
25060: PUSH
25061: LD_STRING 
25063: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25064: CALL_OW 44
25068: PPUSH
25069: LD_INT 0
25071: PPUSH
25072: CALL_OW 51
// end ;
25076: GO 24998
25078: POP
25079: POP
// end ;
25080: PPOPN 1
25082: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25083: LD_EXP 59
25087: PUSH
25088: LD_EXP 79
25092: AND
25093: IFFALSE 25102
25095: GO 25097
25097: DISABLE
// StreamSibBomb ;
25098: CALL 25103 0 0
25102: END
// export function StreamSibBomb ; var i , x , y ; begin
25103: LD_INT 0
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
// result := false ;
25109: LD_ADDR_VAR 0 1
25113: PUSH
25114: LD_INT 0
25116: ST_TO_ADDR
// for i := 1 to 16 do
25117: LD_ADDR_VAR 0 2
25121: PUSH
25122: DOUBLE
25123: LD_INT 1
25125: DEC
25126: ST_TO_ADDR
25127: LD_INT 16
25129: PUSH
25130: FOR_TO
25131: IFFALSE 25330
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25133: LD_ADDR_VAR 0 3
25137: PUSH
25138: LD_INT 10
25140: PUSH
25141: LD_INT 20
25143: PUSH
25144: LD_INT 30
25146: PUSH
25147: LD_INT 40
25149: PUSH
25150: LD_INT 50
25152: PUSH
25153: LD_INT 60
25155: PUSH
25156: LD_INT 70
25158: PUSH
25159: LD_INT 80
25161: PUSH
25162: LD_INT 90
25164: PUSH
25165: LD_INT 100
25167: PUSH
25168: LD_INT 110
25170: PUSH
25171: LD_INT 120
25173: PUSH
25174: LD_INT 130
25176: PUSH
25177: LD_INT 140
25179: PUSH
25180: LD_INT 150
25182: PUSH
25183: EMPTY
25184: LIST
25185: LIST
25186: LIST
25187: LIST
25188: LIST
25189: LIST
25190: LIST
25191: LIST
25192: LIST
25193: LIST
25194: LIST
25195: LIST
25196: LIST
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 1
25202: PPUSH
25203: LD_INT 15
25205: PPUSH
25206: CALL_OW 12
25210: ARRAY
25211: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25212: LD_ADDR_VAR 0 4
25216: PUSH
25217: LD_INT 10
25219: PUSH
25220: LD_INT 20
25222: PUSH
25223: LD_INT 30
25225: PUSH
25226: LD_INT 40
25228: PUSH
25229: LD_INT 50
25231: PUSH
25232: LD_INT 60
25234: PUSH
25235: LD_INT 70
25237: PUSH
25238: LD_INT 80
25240: PUSH
25241: LD_INT 90
25243: PUSH
25244: LD_INT 100
25246: PUSH
25247: LD_INT 110
25249: PUSH
25250: LD_INT 120
25252: PUSH
25253: LD_INT 130
25255: PUSH
25256: LD_INT 140
25258: PUSH
25259: LD_INT 150
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: LIST
25275: LIST
25276: LIST
25277: LIST
25278: PUSH
25279: LD_INT 1
25281: PPUSH
25282: LD_INT 15
25284: PPUSH
25285: CALL_OW 12
25289: ARRAY
25290: ST_TO_ADDR
// if ValidHex ( x , y ) then
25291: LD_VAR 0 3
25295: PPUSH
25296: LD_VAR 0 4
25300: PPUSH
25301: CALL_OW 488
25305: IFFALSE 25328
// begin result := [ x , y ] ;
25307: LD_ADDR_VAR 0 1
25311: PUSH
25312: LD_VAR 0 3
25316: PUSH
25317: LD_VAR 0 4
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: ST_TO_ADDR
// break ;
25326: GO 25330
// end ; end ;
25328: GO 25130
25330: POP
25331: POP
// if result then
25332: LD_VAR 0 1
25336: IFFALSE 25396
// begin ToLua ( playSibBomb() ) ;
25338: LD_STRING playSibBomb()
25340: PPUSH
25341: CALL_OW 559
// wait ( 0 0$14 ) ;
25345: LD_INT 490
25347: PPUSH
25348: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25352: LD_VAR 0 1
25356: PUSH
25357: LD_INT 1
25359: ARRAY
25360: PPUSH
25361: LD_VAR 0 1
25365: PUSH
25366: LD_INT 2
25368: ARRAY
25369: PPUSH
25370: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25374: LD_VAR 0 1
25378: PUSH
25379: LD_INT 1
25381: ARRAY
25382: PPUSH
25383: LD_VAR 0 1
25387: PUSH
25388: LD_INT 2
25390: ARRAY
25391: PPUSH
25392: CALL_OW 429
// end ; end ;
25396: LD_VAR 0 1
25400: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25401: LD_EXP 59
25405: PUSH
25406: LD_EXP 81
25410: AND
25411: IFFALSE 25423
25413: GO 25415
25415: DISABLE
// YouLost (  ) ;
25416: LD_STRING 
25418: PPUSH
25419: CALL_OW 104
25423: END
// every 0 0$1 trigger StreamModeActive and sFog do
25424: LD_EXP 59
25428: PUSH
25429: LD_EXP 80
25433: AND
25434: IFFALSE 25448
25436: GO 25438
25438: DISABLE
// FogOff ( your_side ) ;
25439: LD_OWVAR 2
25443: PPUSH
25444: CALL_OW 344
25448: END
// every 0 0$1 trigger StreamModeActive and sSun do
25449: LD_EXP 59
25453: PUSH
25454: LD_EXP 82
25458: AND
25459: IFFALSE 25487
25461: GO 25463
25463: DISABLE
// begin solar_recharge_percent := 0 ;
25464: LD_ADDR_OWVAR 79
25468: PUSH
25469: LD_INT 0
25471: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25472: LD_INT 10500
25474: PPUSH
25475: CALL_OW 67
// solar_recharge_percent := 100 ;
25479: LD_ADDR_OWVAR 79
25483: PUSH
25484: LD_INT 100
25486: ST_TO_ADDR
// end ;
25487: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25488: LD_EXP 59
25492: PUSH
25493: LD_EXP 83
25497: AND
25498: IFFALSE 25737
25500: GO 25502
25502: DISABLE
25503: LD_INT 0
25505: PPUSH
25506: PPUSH
25507: PPUSH
// begin tmp := [ ] ;
25508: LD_ADDR_VAR 0 3
25512: PUSH
25513: EMPTY
25514: ST_TO_ADDR
// for i := 1 to 6 do
25515: LD_ADDR_VAR 0 1
25519: PUSH
25520: DOUBLE
25521: LD_INT 1
25523: DEC
25524: ST_TO_ADDR
25525: LD_INT 6
25527: PUSH
25528: FOR_TO
25529: IFFALSE 25634
// begin uc_nation := nation_nature ;
25531: LD_ADDR_OWVAR 21
25535: PUSH
25536: LD_INT 0
25538: ST_TO_ADDR
// uc_side := 0 ;
25539: LD_ADDR_OWVAR 20
25543: PUSH
25544: LD_INT 0
25546: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25547: LD_ADDR_OWVAR 29
25551: PUSH
25552: LD_INT 12
25554: PUSH
25555: LD_INT 12
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: ST_TO_ADDR
// hc_agressivity := 20 ;
25562: LD_ADDR_OWVAR 35
25566: PUSH
25567: LD_INT 20
25569: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25570: LD_ADDR_OWVAR 28
25574: PUSH
25575: LD_INT 17
25577: ST_TO_ADDR
// hc_gallery :=  ;
25578: LD_ADDR_OWVAR 33
25582: PUSH
25583: LD_STRING 
25585: ST_TO_ADDR
// hc_name :=  ;
25586: LD_ADDR_OWVAR 26
25590: PUSH
25591: LD_STRING 
25593: ST_TO_ADDR
// un := CreateHuman ;
25594: LD_ADDR_VAR 0 2
25598: PUSH
25599: CALL_OW 44
25603: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25604: LD_VAR 0 2
25608: PPUSH
25609: LD_INT 1
25611: PPUSH
25612: CALL_OW 51
// tmp := tmp ^ un ;
25616: LD_ADDR_VAR 0 3
25620: PUSH
25621: LD_VAR 0 3
25625: PUSH
25626: LD_VAR 0 2
25630: ADD
25631: ST_TO_ADDR
// end ;
25632: GO 25528
25634: POP
25635: POP
// repeat wait ( 0 0$1 ) ;
25636: LD_INT 35
25638: PPUSH
25639: CALL_OW 67
// for un in tmp do
25643: LD_ADDR_VAR 0 2
25647: PUSH
25648: LD_VAR 0 3
25652: PUSH
25653: FOR_IN
25654: IFFALSE 25728
// begin if IsDead ( un ) then
25656: LD_VAR 0 2
25660: PPUSH
25661: CALL_OW 301
25665: IFFALSE 25685
// begin tmp := tmp diff un ;
25667: LD_ADDR_VAR 0 3
25671: PUSH
25672: LD_VAR 0 3
25676: PUSH
25677: LD_VAR 0 2
25681: DIFF
25682: ST_TO_ADDR
// continue ;
25683: GO 25653
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25685: LD_VAR 0 2
25689: PPUSH
25690: LD_INT 3
25692: PUSH
25693: LD_INT 22
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PPUSH
25707: CALL_OW 69
25711: PPUSH
25712: LD_VAR 0 2
25716: PPUSH
25717: CALL_OW 74
25721: PPUSH
25722: CALL_OW 115
// end ;
25726: GO 25653
25728: POP
25729: POP
// until not tmp ;
25730: LD_VAR 0 3
25734: NOT
25735: IFFALSE 25636
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25740: LD_EXP 59
25744: PUSH
25745: LD_EXP 84
25749: AND
25750: IFFALSE 25804
25752: GO 25754
25754: DISABLE
// begin ToLua ( displayTroll(); ) ;
25755: LD_STRING displayTroll();
25757: PPUSH
25758: CALL_OW 559
// wait ( 3 3$00 ) ;
25762: LD_INT 6300
25764: PPUSH
25765: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25769: LD_STRING hideTroll();
25771: PPUSH
25772: CALL_OW 559
// wait ( 1 1$00 ) ;
25776: LD_INT 2100
25778: PPUSH
25779: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25783: LD_STRING displayTroll();
25785: PPUSH
25786: CALL_OW 559
// wait ( 1 1$00 ) ;
25790: LD_INT 2100
25792: PPUSH
25793: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25797: LD_STRING hideTroll();
25799: PPUSH
25800: CALL_OW 559
// end ;
25804: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25805: LD_EXP 59
25809: PUSH
25810: LD_EXP 85
25814: AND
25815: IFFALSE 25878
25817: GO 25819
25819: DISABLE
25820: LD_INT 0
25822: PPUSH
// begin p := 0 ;
25823: LD_ADDR_VAR 0 1
25827: PUSH
25828: LD_INT 0
25830: ST_TO_ADDR
// repeat game_speed := 1 ;
25831: LD_ADDR_OWVAR 65
25835: PUSH
25836: LD_INT 1
25838: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// p := p + 1 ;
25846: LD_ADDR_VAR 0 1
25850: PUSH
25851: LD_VAR 0 1
25855: PUSH
25856: LD_INT 1
25858: PLUS
25859: ST_TO_ADDR
// until p >= 60 ;
25860: LD_VAR 0 1
25864: PUSH
25865: LD_INT 60
25867: GREATEREQUAL
25868: IFFALSE 25831
// game_speed := 4 ;
25870: LD_ADDR_OWVAR 65
25874: PUSH
25875: LD_INT 4
25877: ST_TO_ADDR
// end ;
25878: PPOPN 1
25880: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25881: LD_EXP 59
25885: PUSH
25886: LD_EXP 86
25890: AND
25891: IFFALSE 26037
25893: GO 25895
25895: DISABLE
25896: LD_INT 0
25898: PPUSH
25899: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25900: LD_ADDR_VAR 0 1
25904: PUSH
25905: LD_INT 22
25907: PUSH
25908: LD_OWVAR 2
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 2
25919: PUSH
25920: LD_INT 30
25922: PUSH
25923: LD_INT 0
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PUSH
25930: LD_INT 30
25932: PUSH
25933: LD_INT 1
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: LIST
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PPUSH
25949: CALL_OW 69
25953: ST_TO_ADDR
// if not depot then
25954: LD_VAR 0 1
25958: NOT
25959: IFFALSE 25963
// exit ;
25961: GO 26037
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25963: LD_ADDR_VAR 0 2
25967: PUSH
25968: LD_VAR 0 1
25972: PUSH
25973: LD_INT 1
25975: PPUSH
25976: LD_VAR 0 1
25980: PPUSH
25981: CALL_OW 12
25985: ARRAY
25986: PPUSH
25987: CALL_OW 274
25991: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25992: LD_VAR 0 2
25996: PPUSH
25997: LD_INT 1
25999: PPUSH
26000: LD_INT 0
26002: PPUSH
26003: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26007: LD_VAR 0 2
26011: PPUSH
26012: LD_INT 2
26014: PPUSH
26015: LD_INT 0
26017: PPUSH
26018: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26022: LD_VAR 0 2
26026: PPUSH
26027: LD_INT 3
26029: PPUSH
26030: LD_INT 0
26032: PPUSH
26033: CALL_OW 277
// end ;
26037: PPOPN 2
26039: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26040: LD_EXP 59
26044: PUSH
26045: LD_EXP 87
26049: AND
26050: IFFALSE 26147
26052: GO 26054
26054: DISABLE
26055: LD_INT 0
26057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26058: LD_ADDR_VAR 0 1
26062: PUSH
26063: LD_INT 22
26065: PUSH
26066: LD_OWVAR 2
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 21
26077: PUSH
26078: LD_INT 1
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 3
26087: PUSH
26088: LD_INT 23
26090: PUSH
26091: LD_INT 0
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: LIST
26106: PPUSH
26107: CALL_OW 69
26111: ST_TO_ADDR
// if not tmp then
26112: LD_VAR 0 1
26116: NOT
26117: IFFALSE 26121
// exit ;
26119: GO 26147
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26121: LD_VAR 0 1
26125: PUSH
26126: LD_INT 1
26128: PPUSH
26129: LD_VAR 0 1
26133: PPUSH
26134: CALL_OW 12
26138: ARRAY
26139: PPUSH
26140: LD_INT 200
26142: PPUSH
26143: CALL_OW 234
// end ;
26147: PPOPN 1
26149: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26150: LD_EXP 59
26154: PUSH
26155: LD_EXP 88
26159: AND
26160: IFFALSE 26239
26162: GO 26164
26164: DISABLE
26165: LD_INT 0
26167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26168: LD_ADDR_VAR 0 1
26172: PUSH
26173: LD_INT 22
26175: PUSH
26176: LD_OWVAR 2
26180: PUSH
26181: EMPTY
26182: LIST
26183: LIST
26184: PUSH
26185: LD_INT 21
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PPUSH
26199: CALL_OW 69
26203: ST_TO_ADDR
// if not tmp then
26204: LD_VAR 0 1
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26239
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26213: LD_VAR 0 1
26217: PUSH
26218: LD_INT 1
26220: PPUSH
26221: LD_VAR 0 1
26225: PPUSH
26226: CALL_OW 12
26230: ARRAY
26231: PPUSH
26232: LD_INT 60
26234: PPUSH
26235: CALL_OW 234
// end ;
26239: PPOPN 1
26241: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26242: LD_EXP 59
26246: PUSH
26247: LD_EXP 89
26251: AND
26252: IFFALSE 26351
26254: GO 26256
26256: DISABLE
26257: LD_INT 0
26259: PPUSH
26260: PPUSH
// begin enable ;
26261: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26262: LD_ADDR_VAR 0 1
26266: PUSH
26267: LD_INT 22
26269: PUSH
26270: LD_OWVAR 2
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 61
26281: PUSH
26282: EMPTY
26283: LIST
26284: PUSH
26285: LD_INT 33
26287: PUSH
26288: LD_INT 2
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: PPUSH
26300: CALL_OW 69
26304: ST_TO_ADDR
// if not tmp then
26305: LD_VAR 0 1
26309: NOT
26310: IFFALSE 26314
// exit ;
26312: GO 26351
// for i in tmp do
26314: LD_ADDR_VAR 0 2
26318: PUSH
26319: LD_VAR 0 1
26323: PUSH
26324: FOR_IN
26325: IFFALSE 26349
// if IsControledBy ( i ) then
26327: LD_VAR 0 2
26331: PPUSH
26332: CALL_OW 312
26336: IFFALSE 26347
// ComUnlink ( i ) ;
26338: LD_VAR 0 2
26342: PPUSH
26343: CALL_OW 136
26347: GO 26324
26349: POP
26350: POP
// end ;
26351: PPOPN 2
26353: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26354: LD_EXP 59
26358: PUSH
26359: LD_EXP 90
26363: AND
26364: IFFALSE 26504
26366: GO 26368
26368: DISABLE
26369: LD_INT 0
26371: PPUSH
26372: PPUSH
// begin ToLua ( displayPowell(); ) ;
26373: LD_STRING displayPowell();
26375: PPUSH
26376: CALL_OW 559
// uc_side := 0 ;
26380: LD_ADDR_OWVAR 20
26384: PUSH
26385: LD_INT 0
26387: ST_TO_ADDR
// uc_nation := 2 ;
26388: LD_ADDR_OWVAR 21
26392: PUSH
26393: LD_INT 2
26395: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26396: LD_ADDR_OWVAR 37
26400: PUSH
26401: LD_INT 14
26403: ST_TO_ADDR
// vc_engine := engine_siberite ;
26404: LD_ADDR_OWVAR 39
26408: PUSH
26409: LD_INT 3
26411: ST_TO_ADDR
// vc_control := control_apeman ;
26412: LD_ADDR_OWVAR 38
26416: PUSH
26417: LD_INT 5
26419: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26420: LD_ADDR_OWVAR 40
26424: PUSH
26425: LD_INT 29
26427: ST_TO_ADDR
// un := CreateVehicle ;
26428: LD_ADDR_VAR 0 2
26432: PUSH
26433: CALL_OW 45
26437: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26438: LD_VAR 0 2
26442: PPUSH
26443: LD_INT 1
26445: PPUSH
26446: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26450: LD_INT 35
26452: PPUSH
26453: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26457: LD_VAR 0 2
26461: PPUSH
26462: LD_INT 22
26464: PUSH
26465: LD_OWVAR 2
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PPUSH
26474: CALL_OW 69
26478: PPUSH
26479: LD_VAR 0 2
26483: PPUSH
26484: CALL_OW 74
26488: PPUSH
26489: CALL_OW 115
// until IsDead ( un ) ;
26493: LD_VAR 0 2
26497: PPUSH
26498: CALL_OW 301
26502: IFFALSE 26450
// end ;
26504: PPOPN 2
26506: END
// every 0 0$1 trigger StreamModeActive and sStu do
26507: LD_EXP 59
26511: PUSH
26512: LD_EXP 98
26516: AND
26517: IFFALSE 26533
26519: GO 26521
26521: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26522: LD_STRING displayStucuk();
26524: PPUSH
26525: CALL_OW 559
// ResetFog ;
26529: CALL_OW 335
// end ;
26533: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26534: LD_EXP 59
26538: PUSH
26539: LD_EXP 91
26543: AND
26544: IFFALSE 26685
26546: GO 26548
26548: DISABLE
26549: LD_INT 0
26551: PPUSH
26552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26553: LD_ADDR_VAR 0 2
26557: PUSH
26558: LD_INT 22
26560: PUSH
26561: LD_OWVAR 2
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 21
26572: PUSH
26573: LD_INT 1
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PPUSH
26584: CALL_OW 69
26588: ST_TO_ADDR
// if not tmp then
26589: LD_VAR 0 2
26593: NOT
26594: IFFALSE 26598
// exit ;
26596: GO 26685
// un := tmp [ rand ( 1 , tmp ) ] ;
26598: LD_ADDR_VAR 0 1
26602: PUSH
26603: LD_VAR 0 2
26607: PUSH
26608: LD_INT 1
26610: PPUSH
26611: LD_VAR 0 2
26615: PPUSH
26616: CALL_OW 12
26620: ARRAY
26621: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26622: LD_VAR 0 1
26626: PPUSH
26627: LD_INT 0
26629: PPUSH
26630: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26634: LD_VAR 0 1
26638: PPUSH
26639: LD_OWVAR 3
26643: PUSH
26644: LD_VAR 0 1
26648: DIFF
26649: PPUSH
26650: LD_VAR 0 1
26654: PPUSH
26655: CALL_OW 74
26659: PPUSH
26660: CALL_OW 115
// wait ( 0 0$20 ) ;
26664: LD_INT 700
26666: PPUSH
26667: CALL_OW 67
// SetSide ( un , your_side ) ;
26671: LD_VAR 0 1
26675: PPUSH
26676: LD_OWVAR 2
26680: PPUSH
26681: CALL_OW 235
// end ;
26685: PPOPN 2
26687: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26688: LD_EXP 59
26692: PUSH
26693: LD_EXP 92
26697: AND
26698: IFFALSE 26804
26700: GO 26702
26702: DISABLE
26703: LD_INT 0
26705: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26706: LD_ADDR_VAR 0 1
26710: PUSH
26711: LD_INT 22
26713: PUSH
26714: LD_OWVAR 2
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: PUSH
26723: LD_INT 2
26725: PUSH
26726: LD_INT 30
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 30
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: LIST
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL_OW 69
26759: ST_TO_ADDR
// if not depot then
26760: LD_VAR 0 1
26764: NOT
26765: IFFALSE 26769
// exit ;
26767: GO 26804
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26769: LD_VAR 0 1
26773: PUSH
26774: LD_INT 1
26776: ARRAY
26777: PPUSH
26778: CALL_OW 250
26782: PPUSH
26783: LD_VAR 0 1
26787: PUSH
26788: LD_INT 1
26790: ARRAY
26791: PPUSH
26792: CALL_OW 251
26796: PPUSH
26797: LD_INT 70
26799: PPUSH
26800: CALL_OW 495
// end ;
26804: PPOPN 1
26806: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26807: LD_EXP 59
26811: PUSH
26812: LD_EXP 93
26816: AND
26817: IFFALSE 27028
26819: GO 26821
26821: DISABLE
26822: LD_INT 0
26824: PPUSH
26825: PPUSH
26826: PPUSH
26827: PPUSH
26828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26829: LD_ADDR_VAR 0 5
26833: PUSH
26834: LD_INT 22
26836: PUSH
26837: LD_OWVAR 2
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 21
26848: PUSH
26849: LD_INT 1
26851: PUSH
26852: EMPTY
26853: LIST
26854: LIST
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PPUSH
26860: CALL_OW 69
26864: ST_TO_ADDR
// if not tmp then
26865: LD_VAR 0 5
26869: NOT
26870: IFFALSE 26874
// exit ;
26872: GO 27028
// for i in tmp do
26874: LD_ADDR_VAR 0 1
26878: PUSH
26879: LD_VAR 0 5
26883: PUSH
26884: FOR_IN
26885: IFFALSE 27026
// begin d := rand ( 0 , 5 ) ;
26887: LD_ADDR_VAR 0 4
26891: PUSH
26892: LD_INT 0
26894: PPUSH
26895: LD_INT 5
26897: PPUSH
26898: CALL_OW 12
26902: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26903: LD_ADDR_VAR 0 2
26907: PUSH
26908: LD_VAR 0 1
26912: PPUSH
26913: CALL_OW 250
26917: PPUSH
26918: LD_VAR 0 4
26922: PPUSH
26923: LD_INT 3
26925: PPUSH
26926: LD_INT 12
26928: PPUSH
26929: CALL_OW 12
26933: PPUSH
26934: CALL_OW 272
26938: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26939: LD_ADDR_VAR 0 3
26943: PUSH
26944: LD_VAR 0 1
26948: PPUSH
26949: CALL_OW 251
26953: PPUSH
26954: LD_VAR 0 4
26958: PPUSH
26959: LD_INT 3
26961: PPUSH
26962: LD_INT 12
26964: PPUSH
26965: CALL_OW 12
26969: PPUSH
26970: CALL_OW 273
26974: ST_TO_ADDR
// if ValidHex ( x , y ) then
26975: LD_VAR 0 2
26979: PPUSH
26980: LD_VAR 0 3
26984: PPUSH
26985: CALL_OW 488
26989: IFFALSE 27024
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26991: LD_VAR 0 1
26995: PPUSH
26996: LD_VAR 0 2
27000: PPUSH
27001: LD_VAR 0 3
27005: PPUSH
27006: LD_INT 3
27008: PPUSH
27009: LD_INT 6
27011: PPUSH
27012: CALL_OW 12
27016: PPUSH
27017: LD_INT 1
27019: PPUSH
27020: CALL_OW 483
// end ;
27024: GO 26884
27026: POP
27027: POP
// end ;
27028: PPOPN 5
27030: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27031: LD_EXP 59
27035: PUSH
27036: LD_EXP 94
27040: AND
27041: IFFALSE 27135
27043: GO 27045
27045: DISABLE
27046: LD_INT 0
27048: PPUSH
27049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27050: LD_ADDR_VAR 0 2
27054: PUSH
27055: LD_INT 22
27057: PUSH
27058: LD_OWVAR 2
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PUSH
27067: LD_INT 32
27069: PUSH
27070: LD_INT 1
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: LD_INT 21
27079: PUSH
27080: LD_INT 2
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: PPUSH
27092: CALL_OW 69
27096: ST_TO_ADDR
// if not tmp then
27097: LD_VAR 0 2
27101: NOT
27102: IFFALSE 27106
// exit ;
27104: GO 27135
// for i in tmp do
27106: LD_ADDR_VAR 0 1
27110: PUSH
27111: LD_VAR 0 2
27115: PUSH
27116: FOR_IN
27117: IFFALSE 27133
// SetFuel ( i , 0 ) ;
27119: LD_VAR 0 1
27123: PPUSH
27124: LD_INT 0
27126: PPUSH
27127: CALL_OW 240
27131: GO 27116
27133: POP
27134: POP
// end ;
27135: PPOPN 2
27137: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27138: LD_EXP 59
27142: PUSH
27143: LD_EXP 95
27147: AND
27148: IFFALSE 27214
27150: GO 27152
27152: DISABLE
27153: LD_INT 0
27155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27156: LD_ADDR_VAR 0 1
27160: PUSH
27161: LD_INT 22
27163: PUSH
27164: LD_OWVAR 2
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: LD_INT 30
27175: PUSH
27176: LD_INT 29
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PPUSH
27187: CALL_OW 69
27191: ST_TO_ADDR
// if not tmp then
27192: LD_VAR 0 1
27196: NOT
27197: IFFALSE 27201
// exit ;
27199: GO 27214
// DestroyUnit ( tmp [ 1 ] ) ;
27201: LD_VAR 0 1
27205: PUSH
27206: LD_INT 1
27208: ARRAY
27209: PPUSH
27210: CALL_OW 65
// end ;
27214: PPOPN 1
27216: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27217: LD_EXP 59
27221: PUSH
27222: LD_EXP 97
27226: AND
27227: IFFALSE 27356
27229: GO 27231
27231: DISABLE
27232: LD_INT 0
27234: PPUSH
// begin uc_side := 0 ;
27235: LD_ADDR_OWVAR 20
27239: PUSH
27240: LD_INT 0
27242: ST_TO_ADDR
// uc_nation := nation_arabian ;
27243: LD_ADDR_OWVAR 21
27247: PUSH
27248: LD_INT 2
27250: ST_TO_ADDR
// hc_gallery :=  ;
27251: LD_ADDR_OWVAR 33
27255: PUSH
27256: LD_STRING 
27258: ST_TO_ADDR
// hc_name :=  ;
27259: LD_ADDR_OWVAR 26
27263: PUSH
27264: LD_STRING 
27266: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27267: LD_INT 1
27269: PPUSH
27270: LD_INT 11
27272: PPUSH
27273: LD_INT 10
27275: PPUSH
27276: CALL_OW 380
// un := CreateHuman ;
27280: LD_ADDR_VAR 0 1
27284: PUSH
27285: CALL_OW 44
27289: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_INT 1
27297: PPUSH
27298: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27302: LD_INT 35
27304: PPUSH
27305: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27309: LD_VAR 0 1
27313: PPUSH
27314: LD_INT 22
27316: PUSH
27317: LD_OWVAR 2
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: PPUSH
27326: CALL_OW 69
27330: PPUSH
27331: LD_VAR 0 1
27335: PPUSH
27336: CALL_OW 74
27340: PPUSH
27341: CALL_OW 115
// until IsDead ( un ) ;
27345: LD_VAR 0 1
27349: PPUSH
27350: CALL_OW 301
27354: IFFALSE 27302
// end ;
27356: PPOPN 1
27358: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27359: LD_EXP 59
27363: PUSH
27364: LD_EXP 99
27368: AND
27369: IFFALSE 27381
27371: GO 27373
27373: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27374: LD_STRING earthquake(getX(game), 0, 32)
27376: PPUSH
27377: CALL_OW 559
27381: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27382: LD_EXP 59
27386: PUSH
27387: LD_EXP 100
27391: AND
27392: IFFALSE 27483
27394: GO 27396
27396: DISABLE
27397: LD_INT 0
27399: PPUSH
// begin enable ;
27400: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27401: LD_ADDR_VAR 0 1
27405: PUSH
27406: LD_INT 22
27408: PUSH
27409: LD_OWVAR 2
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: LD_INT 21
27420: PUSH
27421: LD_INT 2
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 33
27430: PUSH
27431: LD_INT 3
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: LIST
27442: PPUSH
27443: CALL_OW 69
27447: ST_TO_ADDR
// if not tmp then
27448: LD_VAR 0 1
27452: NOT
27453: IFFALSE 27457
// exit ;
27455: GO 27483
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27457: LD_VAR 0 1
27461: PUSH
27462: LD_INT 1
27464: PPUSH
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 12
27474: ARRAY
27475: PPUSH
27476: LD_INT 1
27478: PPUSH
27479: CALL_OW 234
// end ;
27483: PPOPN 1
27485: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27486: LD_EXP 59
27490: PUSH
27491: LD_EXP 101
27495: AND
27496: IFFALSE 27637
27498: GO 27500
27500: DISABLE
27501: LD_INT 0
27503: PPUSH
27504: PPUSH
27505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27506: LD_ADDR_VAR 0 3
27510: PUSH
27511: LD_INT 22
27513: PUSH
27514: LD_OWVAR 2
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 25
27525: PUSH
27526: LD_INT 1
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PPUSH
27537: CALL_OW 69
27541: ST_TO_ADDR
// if not tmp then
27542: LD_VAR 0 3
27546: NOT
27547: IFFALSE 27551
// exit ;
27549: GO 27637
// un := tmp [ rand ( 1 , tmp ) ] ;
27551: LD_ADDR_VAR 0 2
27555: PUSH
27556: LD_VAR 0 3
27560: PUSH
27561: LD_INT 1
27563: PPUSH
27564: LD_VAR 0 3
27568: PPUSH
27569: CALL_OW 12
27573: ARRAY
27574: ST_TO_ADDR
// if Crawls ( un ) then
27575: LD_VAR 0 2
27579: PPUSH
27580: CALL_OW 318
27584: IFFALSE 27595
// ComWalk ( un ) ;
27586: LD_VAR 0 2
27590: PPUSH
27591: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27595: LD_VAR 0 2
27599: PPUSH
27600: LD_INT 9
27602: PPUSH
27603: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27607: LD_INT 28
27609: PPUSH
27610: LD_OWVAR 2
27614: PPUSH
27615: LD_INT 2
27617: PPUSH
27618: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27622: LD_INT 29
27624: PPUSH
27625: LD_OWVAR 2
27629: PPUSH
27630: LD_INT 2
27632: PPUSH
27633: CALL_OW 322
// end ;
27637: PPOPN 3
27639: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27640: LD_EXP 59
27644: PUSH
27645: LD_EXP 102
27649: AND
27650: IFFALSE 27761
27652: GO 27654
27654: DISABLE
27655: LD_INT 0
27657: PPUSH
27658: PPUSH
27659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27660: LD_ADDR_VAR 0 3
27664: PUSH
27665: LD_INT 22
27667: PUSH
27668: LD_OWVAR 2
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 25
27679: PUSH
27680: LD_INT 1
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PPUSH
27691: CALL_OW 69
27695: ST_TO_ADDR
// if not tmp then
27696: LD_VAR 0 3
27700: NOT
27701: IFFALSE 27705
// exit ;
27703: GO 27761
// un := tmp [ rand ( 1 , tmp ) ] ;
27705: LD_ADDR_VAR 0 2
27709: PUSH
27710: LD_VAR 0 3
27714: PUSH
27715: LD_INT 1
27717: PPUSH
27718: LD_VAR 0 3
27722: PPUSH
27723: CALL_OW 12
27727: ARRAY
27728: ST_TO_ADDR
// if Crawls ( un ) then
27729: LD_VAR 0 2
27733: PPUSH
27734: CALL_OW 318
27738: IFFALSE 27749
// ComWalk ( un ) ;
27740: LD_VAR 0 2
27744: PPUSH
27745: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27749: LD_VAR 0 2
27753: PPUSH
27754: LD_INT 8
27756: PPUSH
27757: CALL_OW 336
// end ;
27761: PPOPN 3
27763: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27764: LD_EXP 59
27768: PUSH
27769: LD_EXP 103
27773: AND
27774: IFFALSE 27918
27776: GO 27778
27778: DISABLE
27779: LD_INT 0
27781: PPUSH
27782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27783: LD_ADDR_VAR 0 2
27787: PUSH
27788: LD_INT 22
27790: PUSH
27791: LD_OWVAR 2
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 21
27802: PUSH
27803: LD_INT 2
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 2
27812: PUSH
27813: LD_INT 34
27815: PUSH
27816: LD_INT 12
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 34
27825: PUSH
27826: LD_INT 51
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PUSH
27833: LD_INT 34
27835: PUSH
27836: LD_INT 32
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: LIST
27853: PPUSH
27854: CALL_OW 69
27858: ST_TO_ADDR
// if not tmp then
27859: LD_VAR 0 2
27863: NOT
27864: IFFALSE 27868
// exit ;
27866: GO 27918
// for i in tmp do
27868: LD_ADDR_VAR 0 1
27872: PUSH
27873: LD_VAR 0 2
27877: PUSH
27878: FOR_IN
27879: IFFALSE 27916
// if GetCargo ( i , mat_artifact ) = 0 then
27881: LD_VAR 0 1
27885: PPUSH
27886: LD_INT 4
27888: PPUSH
27889: CALL_OW 289
27893: PUSH
27894: LD_INT 0
27896: EQUAL
27897: IFFALSE 27914
// SetCargo ( i , mat_siberit , 100 ) ;
27899: LD_VAR 0 1
27903: PPUSH
27904: LD_INT 3
27906: PPUSH
27907: LD_INT 100
27909: PPUSH
27910: CALL_OW 290
27914: GO 27878
27916: POP
27917: POP
// end ;
27918: PPOPN 2
27920: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27921: LD_EXP 59
27925: PUSH
27926: LD_EXP 104
27930: AND
27931: IFFALSE 28084
27933: GO 27935
27935: DISABLE
27936: LD_INT 0
27938: PPUSH
27939: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27940: LD_ADDR_VAR 0 2
27944: PUSH
27945: LD_INT 22
27947: PUSH
27948: LD_OWVAR 2
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PPUSH
27957: CALL_OW 69
27961: ST_TO_ADDR
// if not tmp then
27962: LD_VAR 0 2
27966: NOT
27967: IFFALSE 27971
// exit ;
27969: GO 28084
// for i := 1 to 2 do
27971: LD_ADDR_VAR 0 1
27975: PUSH
27976: DOUBLE
27977: LD_INT 1
27979: DEC
27980: ST_TO_ADDR
27981: LD_INT 2
27983: PUSH
27984: FOR_TO
27985: IFFALSE 28082
// begin uc_side := your_side ;
27987: LD_ADDR_OWVAR 20
27991: PUSH
27992: LD_OWVAR 2
27996: ST_TO_ADDR
// uc_nation := nation_american ;
27997: LD_ADDR_OWVAR 21
28001: PUSH
28002: LD_INT 1
28004: ST_TO_ADDR
// vc_chassis := us_morphling ;
28005: LD_ADDR_OWVAR 37
28009: PUSH
28010: LD_INT 5
28012: ST_TO_ADDR
// vc_engine := engine_siberite ;
28013: LD_ADDR_OWVAR 39
28017: PUSH
28018: LD_INT 3
28020: ST_TO_ADDR
// vc_control := control_computer ;
28021: LD_ADDR_OWVAR 38
28025: PUSH
28026: LD_INT 3
28028: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28029: LD_ADDR_OWVAR 40
28033: PUSH
28034: LD_INT 10
28036: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
28037: CALL_OW 45
28041: PPUSH
28042: LD_VAR 0 2
28046: PUSH
28047: LD_INT 1
28049: ARRAY
28050: PPUSH
28051: CALL_OW 250
28055: PPUSH
28056: LD_VAR 0 2
28060: PUSH
28061: LD_INT 1
28063: ARRAY
28064: PPUSH
28065: CALL_OW 251
28069: PPUSH
28070: LD_INT 12
28072: PPUSH
28073: LD_INT 1
28075: PPUSH
28076: CALL_OW 50
// end ;
28080: GO 27984
28082: POP
28083: POP
// end ;
28084: PPOPN 2
28086: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28087: LD_EXP 59
28091: PUSH
28092: LD_EXP 105
28096: AND
28097: IFFALSE 28319
28099: GO 28101
28101: DISABLE
28102: LD_INT 0
28104: PPUSH
28105: PPUSH
28106: PPUSH
28107: PPUSH
28108: PPUSH
28109: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28110: LD_ADDR_VAR 0 6
28114: PUSH
28115: LD_INT 22
28117: PUSH
28118: LD_OWVAR 2
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 21
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 3
28139: PUSH
28140: LD_INT 23
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: PUSH
28150: EMPTY
28151: LIST
28152: LIST
28153: PUSH
28154: EMPTY
28155: LIST
28156: LIST
28157: LIST
28158: PPUSH
28159: CALL_OW 69
28163: ST_TO_ADDR
// if not tmp then
28164: LD_VAR 0 6
28168: NOT
28169: IFFALSE 28173
// exit ;
28171: GO 28319
// s1 := rand ( 1 , 4 ) ;
28173: LD_ADDR_VAR 0 2
28177: PUSH
28178: LD_INT 1
28180: PPUSH
28181: LD_INT 4
28183: PPUSH
28184: CALL_OW 12
28188: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28189: LD_ADDR_VAR 0 4
28193: PUSH
28194: LD_VAR 0 6
28198: PUSH
28199: LD_INT 1
28201: ARRAY
28202: PPUSH
28203: LD_VAR 0 2
28207: PPUSH
28208: CALL_OW 259
28212: ST_TO_ADDR
// if s1 = 1 then
28213: LD_VAR 0 2
28217: PUSH
28218: LD_INT 1
28220: EQUAL
28221: IFFALSE 28241
// s2 := rand ( 2 , 4 ) else
28223: LD_ADDR_VAR 0 3
28227: PUSH
28228: LD_INT 2
28230: PPUSH
28231: LD_INT 4
28233: PPUSH
28234: CALL_OW 12
28238: ST_TO_ADDR
28239: GO 28249
// s2 := 1 ;
28241: LD_ADDR_VAR 0 3
28245: PUSH
28246: LD_INT 1
28248: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28249: LD_ADDR_VAR 0 5
28253: PUSH
28254: LD_VAR 0 6
28258: PUSH
28259: LD_INT 1
28261: ARRAY
28262: PPUSH
28263: LD_VAR 0 3
28267: PPUSH
28268: CALL_OW 259
28272: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28273: LD_VAR 0 6
28277: PUSH
28278: LD_INT 1
28280: ARRAY
28281: PPUSH
28282: LD_VAR 0 2
28286: PPUSH
28287: LD_VAR 0 5
28291: PPUSH
28292: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28296: LD_VAR 0 6
28300: PUSH
28301: LD_INT 1
28303: ARRAY
28304: PPUSH
28305: LD_VAR 0 3
28309: PPUSH
28310: LD_VAR 0 4
28314: PPUSH
28315: CALL_OW 237
// end ;
28319: PPOPN 6
28321: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28322: LD_EXP 59
28326: PUSH
28327: LD_EXP 106
28331: AND
28332: IFFALSE 28411
28334: GO 28336
28336: DISABLE
28337: LD_INT 0
28339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28340: LD_ADDR_VAR 0 1
28344: PUSH
28345: LD_INT 22
28347: PUSH
28348: LD_OWVAR 2
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 30
28359: PUSH
28360: LD_INT 3
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PPUSH
28371: CALL_OW 69
28375: ST_TO_ADDR
// if not tmp then
28376: LD_VAR 0 1
28380: NOT
28381: IFFALSE 28385
// exit ;
28383: GO 28411
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28385: LD_VAR 0 1
28389: PUSH
28390: LD_INT 1
28392: PPUSH
28393: LD_VAR 0 1
28397: PPUSH
28398: CALL_OW 12
28402: ARRAY
28403: PPUSH
28404: LD_INT 1
28406: PPUSH
28407: CALL_OW 234
// end ;
28411: PPOPN 1
28413: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28414: LD_EXP 59
28418: PUSH
28419: LD_EXP 107
28423: AND
28424: IFFALSE 28536
28426: GO 28428
28428: DISABLE
28429: LD_INT 0
28431: PPUSH
28432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28433: LD_ADDR_VAR 0 2
28437: PUSH
28438: LD_INT 22
28440: PUSH
28441: LD_OWVAR 2
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 2
28452: PUSH
28453: LD_INT 30
28455: PUSH
28456: LD_INT 27
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: PUSH
28463: LD_INT 30
28465: PUSH
28466: LD_INT 26
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 30
28475: PUSH
28476: LD_INT 28
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: EMPTY
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PPUSH
28493: CALL_OW 69
28497: ST_TO_ADDR
// if not tmp then
28498: LD_VAR 0 2
28502: NOT
28503: IFFALSE 28507
// exit ;
28505: GO 28536
// for i in tmp do
28507: LD_ADDR_VAR 0 1
28511: PUSH
28512: LD_VAR 0 2
28516: PUSH
28517: FOR_IN
28518: IFFALSE 28534
// SetLives ( i , 1 ) ;
28520: LD_VAR 0 1
28524: PPUSH
28525: LD_INT 1
28527: PPUSH
28528: CALL_OW 234
28532: GO 28517
28534: POP
28535: POP
// end ;
28536: PPOPN 2
28538: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28539: LD_EXP 59
28543: PUSH
28544: LD_EXP 108
28548: AND
28549: IFFALSE 28823
28551: GO 28553
28553: DISABLE
28554: LD_INT 0
28556: PPUSH
28557: PPUSH
28558: PPUSH
// begin i := rand ( 1 , 7 ) ;
28559: LD_ADDR_VAR 0 1
28563: PUSH
28564: LD_INT 1
28566: PPUSH
28567: LD_INT 7
28569: PPUSH
28570: CALL_OW 12
28574: ST_TO_ADDR
// case i of 1 :
28575: LD_VAR 0 1
28579: PUSH
28580: LD_INT 1
28582: DOUBLE
28583: EQUAL
28584: IFTRUE 28588
28586: GO 28598
28588: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28589: LD_STRING earthquake(getX(game), 0, 32)
28591: PPUSH
28592: CALL_OW 559
28596: GO 28823
28598: LD_INT 2
28600: DOUBLE
28601: EQUAL
28602: IFTRUE 28606
28604: GO 28620
28606: POP
// begin ToLua ( displayStucuk(); ) ;
28607: LD_STRING displayStucuk();
28609: PPUSH
28610: CALL_OW 559
// ResetFog ;
28614: CALL_OW 335
// end ; 3 :
28618: GO 28823
28620: LD_INT 3
28622: DOUBLE
28623: EQUAL
28624: IFTRUE 28628
28626: GO 28732
28628: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28629: LD_ADDR_VAR 0 2
28633: PUSH
28634: LD_INT 22
28636: PUSH
28637: LD_OWVAR 2
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 25
28648: PUSH
28649: LD_INT 1
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PPUSH
28660: CALL_OW 69
28664: ST_TO_ADDR
// if not tmp then
28665: LD_VAR 0 2
28669: NOT
28670: IFFALSE 28674
// exit ;
28672: GO 28823
// un := tmp [ rand ( 1 , tmp ) ] ;
28674: LD_ADDR_VAR 0 3
28678: PUSH
28679: LD_VAR 0 2
28683: PUSH
28684: LD_INT 1
28686: PPUSH
28687: LD_VAR 0 2
28691: PPUSH
28692: CALL_OW 12
28696: ARRAY
28697: ST_TO_ADDR
// if Crawls ( un ) then
28698: LD_VAR 0 3
28702: PPUSH
28703: CALL_OW 318
28707: IFFALSE 28718
// ComWalk ( un ) ;
28709: LD_VAR 0 3
28713: PPUSH
28714: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28718: LD_VAR 0 3
28722: PPUSH
28723: LD_INT 8
28725: PPUSH
28726: CALL_OW 336
// end ; 4 :
28730: GO 28823
28732: LD_INT 4
28734: DOUBLE
28735: EQUAL
28736: IFTRUE 28740
28738: GO 28801
28740: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28741: LD_ADDR_VAR 0 2
28745: PUSH
28746: LD_INT 22
28748: PUSH
28749: LD_OWVAR 2
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 30
28760: PUSH
28761: LD_INT 29
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PPUSH
28772: CALL_OW 69
28776: ST_TO_ADDR
// if not tmp then
28777: LD_VAR 0 2
28781: NOT
28782: IFFALSE 28786
// exit ;
28784: GO 28823
// DestroyUnit ( tmp [ 1 ] ) ;
28786: LD_VAR 0 2
28790: PUSH
28791: LD_INT 1
28793: ARRAY
28794: PPUSH
28795: CALL_OW 65
// end ; 5 .. 7 :
28799: GO 28823
28801: LD_INT 5
28803: DOUBLE
28804: GREATEREQUAL
28805: IFFALSE 28813
28807: LD_INT 7
28809: DOUBLE
28810: LESSEQUAL
28811: IFTRUE 28815
28813: GO 28822
28815: POP
// StreamSibBomb ; end ;
28816: CALL 25103 0 0
28820: GO 28823
28822: POP
// end ;
28823: PPOPN 3
28825: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28826: LD_EXP 59
28830: PUSH
28831: LD_EXP 109
28835: AND
28836: IFFALSE 28992
28838: GO 28840
28840: DISABLE
28841: LD_INT 0
28843: PPUSH
28844: PPUSH
28845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28846: LD_ADDR_VAR 0 2
28850: PUSH
28851: LD_INT 81
28853: PUSH
28854: LD_OWVAR 2
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 2
28865: PUSH
28866: LD_INT 21
28868: PUSH
28869: LD_INT 1
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 21
28878: PUSH
28879: LD_INT 2
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: LIST
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PPUSH
28895: CALL_OW 69
28899: ST_TO_ADDR
// if not tmp then
28900: LD_VAR 0 2
28904: NOT
28905: IFFALSE 28909
// exit ;
28907: GO 28992
// p := 0 ;
28909: LD_ADDR_VAR 0 3
28913: PUSH
28914: LD_INT 0
28916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28917: LD_INT 35
28919: PPUSH
28920: CALL_OW 67
// p := p + 1 ;
28924: LD_ADDR_VAR 0 3
28928: PUSH
28929: LD_VAR 0 3
28933: PUSH
28934: LD_INT 1
28936: PLUS
28937: ST_TO_ADDR
// for i in tmp do
28938: LD_ADDR_VAR 0 1
28942: PUSH
28943: LD_VAR 0 2
28947: PUSH
28948: FOR_IN
28949: IFFALSE 28980
// if GetLives ( i ) < 1000 then
28951: LD_VAR 0 1
28955: PPUSH
28956: CALL_OW 256
28960: PUSH
28961: LD_INT 1000
28963: LESS
28964: IFFALSE 28978
// SetLives ( i , 1000 ) ;
28966: LD_VAR 0 1
28970: PPUSH
28971: LD_INT 1000
28973: PPUSH
28974: CALL_OW 234
28978: GO 28948
28980: POP
28981: POP
// until p > 20 ;
28982: LD_VAR 0 3
28986: PUSH
28987: LD_INT 20
28989: GREATER
28990: IFFALSE 28917
// end ;
28992: PPOPN 3
28994: END
// every 0 0$1 trigger StreamModeActive and sTime do
28995: LD_EXP 59
28999: PUSH
29000: LD_EXP 110
29004: AND
29005: IFFALSE 29040
29007: GO 29009
29009: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29010: LD_INT 28
29012: PPUSH
29013: LD_OWVAR 2
29017: PPUSH
29018: LD_INT 2
29020: PPUSH
29021: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29025: LD_INT 30
29027: PPUSH
29028: LD_OWVAR 2
29032: PPUSH
29033: LD_INT 2
29035: PPUSH
29036: CALL_OW 322
// end ;
29040: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29041: LD_EXP 59
29045: PUSH
29046: LD_EXP 111
29050: AND
29051: IFFALSE 29172
29053: GO 29055
29055: DISABLE
29056: LD_INT 0
29058: PPUSH
29059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29060: LD_ADDR_VAR 0 2
29064: PUSH
29065: LD_INT 22
29067: PUSH
29068: LD_OWVAR 2
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 21
29079: PUSH
29080: LD_INT 1
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 3
29089: PUSH
29090: LD_INT 23
29092: PUSH
29093: LD_INT 0
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: LIST
29108: PPUSH
29109: CALL_OW 69
29113: ST_TO_ADDR
// if not tmp then
29114: LD_VAR 0 2
29118: NOT
29119: IFFALSE 29123
// exit ;
29121: GO 29172
// for i in tmp do
29123: LD_ADDR_VAR 0 1
29127: PUSH
29128: LD_VAR 0 2
29132: PUSH
29133: FOR_IN
29134: IFFALSE 29170
// begin if Crawls ( i ) then
29136: LD_VAR 0 1
29140: PPUSH
29141: CALL_OW 318
29145: IFFALSE 29156
// ComWalk ( i ) ;
29147: LD_VAR 0 1
29151: PPUSH
29152: CALL_OW 138
// SetClass ( i , 2 ) ;
29156: LD_VAR 0 1
29160: PPUSH
29161: LD_INT 2
29163: PPUSH
29164: CALL_OW 336
// end ;
29168: GO 29133
29170: POP
29171: POP
// end ;
29172: PPOPN 2
29174: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29175: LD_EXP 59
29179: PUSH
29180: LD_EXP 112
29184: AND
29185: IFFALSE 29466
29187: GO 29189
29189: DISABLE
29190: LD_INT 0
29192: PPUSH
29193: PPUSH
29194: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29195: LD_OWVAR 2
29199: PPUSH
29200: LD_INT 9
29202: PPUSH
29203: LD_INT 1
29205: PPUSH
29206: LD_INT 1
29208: PPUSH
29209: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29213: LD_INT 9
29215: PPUSH
29216: LD_OWVAR 2
29220: PPUSH
29221: CALL_OW 343
// uc_side := 9 ;
29225: LD_ADDR_OWVAR 20
29229: PUSH
29230: LD_INT 9
29232: ST_TO_ADDR
// uc_nation := 2 ;
29233: LD_ADDR_OWVAR 21
29237: PUSH
29238: LD_INT 2
29240: ST_TO_ADDR
// hc_name := Dark Warrior ;
29241: LD_ADDR_OWVAR 26
29245: PUSH
29246: LD_STRING Dark Warrior
29248: ST_TO_ADDR
// hc_gallery :=  ;
29249: LD_ADDR_OWVAR 33
29253: PUSH
29254: LD_STRING 
29256: ST_TO_ADDR
// hc_noskilllimit := true ;
29257: LD_ADDR_OWVAR 76
29261: PUSH
29262: LD_INT 1
29264: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29265: LD_ADDR_OWVAR 31
29269: PUSH
29270: LD_INT 30
29272: PUSH
29273: LD_INT 30
29275: PUSH
29276: LD_INT 30
29278: PUSH
29279: LD_INT 30
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: ST_TO_ADDR
// un := CreateHuman ;
29288: LD_ADDR_VAR 0 3
29292: PUSH
29293: CALL_OW 44
29297: ST_TO_ADDR
// hc_noskilllimit := false ;
29298: LD_ADDR_OWVAR 76
29302: PUSH
29303: LD_INT 0
29305: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29306: LD_VAR 0 3
29310: PPUSH
29311: LD_INT 1
29313: PPUSH
29314: CALL_OW 51
// p := 0 ;
29318: LD_ADDR_VAR 0 2
29322: PUSH
29323: LD_INT 0
29325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29326: LD_INT 35
29328: PPUSH
29329: CALL_OW 67
// p := p + 1 ;
29333: LD_ADDR_VAR 0 2
29337: PUSH
29338: LD_VAR 0 2
29342: PUSH
29343: LD_INT 1
29345: PLUS
29346: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29347: LD_VAR 0 3
29351: PPUSH
29352: CALL_OW 256
29356: PUSH
29357: LD_INT 1000
29359: LESS
29360: IFFALSE 29374
// SetLives ( un , 1000 ) ;
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 1000
29369: PPUSH
29370: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29374: LD_VAR 0 3
29378: PPUSH
29379: LD_INT 81
29381: PUSH
29382: LD_OWVAR 2
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 91
29393: PUSH
29394: LD_VAR 0 3
29398: PUSH
29399: LD_INT 30
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PPUSH
29411: CALL_OW 69
29415: PPUSH
29416: LD_VAR 0 3
29420: PPUSH
29421: CALL_OW 74
29425: PPUSH
29426: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29430: LD_VAR 0 2
29434: PUSH
29435: LD_INT 60
29437: GREATER
29438: PUSH
29439: LD_VAR 0 3
29443: PPUSH
29444: CALL_OW 301
29448: OR
29449: IFFALSE 29326
// if un then
29451: LD_VAR 0 3
29455: IFFALSE 29466
// RemoveUnit ( un ) ;
29457: LD_VAR 0 3
29461: PPUSH
29462: CALL_OW 64
// end ; end_of_file
29466: PPOPN 3
29468: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29469: LD_INT 0
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29475: LD_VAR 0 1
29479: PPUSH
29480: CALL_OW 264
29484: PUSH
29485: LD_EXP 58
29489: EQUAL
29490: IFFALSE 29562
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29492: LD_INT 68
29494: PPUSH
29495: LD_VAR 0 1
29499: PPUSH
29500: CALL_OW 255
29504: PPUSH
29505: CALL_OW 321
29509: PUSH
29510: LD_INT 2
29512: EQUAL
29513: IFFALSE 29525
// eff := 70 else
29515: LD_ADDR_VAR 0 4
29519: PUSH
29520: LD_INT 70
29522: ST_TO_ADDR
29523: GO 29533
// eff := 30 ;
29525: LD_ADDR_VAR 0 4
29529: PUSH
29530: LD_INT 30
29532: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29533: LD_VAR 0 1
29537: PPUSH
29538: CALL_OW 250
29542: PPUSH
29543: LD_VAR 0 1
29547: PPUSH
29548: CALL_OW 251
29552: PPUSH
29553: LD_VAR 0 4
29557: PPUSH
29558: CALL_OW 495
// end ; end ;
29562: LD_VAR 0 2
29566: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29567: LD_INT 0
29569: PPUSH
// end ;
29570: LD_VAR 0 4
29574: RET
// export function SOS_Command ( cmd ) ; begin
29575: LD_INT 0
29577: PPUSH
// end ;
29578: LD_VAR 0 2
29582: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29583: LD_VAR 0 1
29587: PUSH
29588: LD_INT 255
29590: EQUAL
29591: PUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 264
29601: PUSH
29602: LD_INT 14
29604: PUSH
29605: LD_INT 53
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: IN
29612: AND
29613: PUSH
29614: LD_VAR 0 4
29618: PPUSH
29619: LD_VAR 0 5
29623: PPUSH
29624: CALL_OW 488
29628: AND
29629: IFFALSE 29653
// CutTreeXYR ( unit , x , y , 12 ) ;
29631: LD_VAR 0 2
29635: PPUSH
29636: LD_VAR 0 4
29640: PPUSH
29641: LD_VAR 0 5
29645: PPUSH
29646: LD_INT 12
29648: PPUSH
29649: CALL 29656 0 4
// end ;
29653: PPOPN 5
29655: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29656: LD_INT 0
29658: PPUSH
29659: PPUSH
29660: PPUSH
29661: PPUSH
29662: PPUSH
29663: PPUSH
29664: PPUSH
29665: PPUSH
29666: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29667: LD_VAR 0 1
29671: NOT
29672: PUSH
29673: LD_VAR 0 2
29677: PPUSH
29678: LD_VAR 0 3
29682: PPUSH
29683: CALL_OW 488
29687: NOT
29688: OR
29689: PUSH
29690: LD_VAR 0 4
29694: NOT
29695: OR
29696: IFFALSE 29700
// exit ;
29698: GO 30040
// list := [ ] ;
29700: LD_ADDR_VAR 0 13
29704: PUSH
29705: EMPTY
29706: ST_TO_ADDR
// if x - r < 0 then
29707: LD_VAR 0 2
29711: PUSH
29712: LD_VAR 0 4
29716: MINUS
29717: PUSH
29718: LD_INT 0
29720: LESS
29721: IFFALSE 29733
// min_x := 0 else
29723: LD_ADDR_VAR 0 7
29727: PUSH
29728: LD_INT 0
29730: ST_TO_ADDR
29731: GO 29749
// min_x := x - r ;
29733: LD_ADDR_VAR 0 7
29737: PUSH
29738: LD_VAR 0 2
29742: PUSH
29743: LD_VAR 0 4
29747: MINUS
29748: ST_TO_ADDR
// if y - r < 0 then
29749: LD_VAR 0 3
29753: PUSH
29754: LD_VAR 0 4
29758: MINUS
29759: PUSH
29760: LD_INT 0
29762: LESS
29763: IFFALSE 29775
// min_y := 0 else
29765: LD_ADDR_VAR 0 8
29769: PUSH
29770: LD_INT 0
29772: ST_TO_ADDR
29773: GO 29791
// min_y := y - r ;
29775: LD_ADDR_VAR 0 8
29779: PUSH
29780: LD_VAR 0 3
29784: PUSH
29785: LD_VAR 0 4
29789: MINUS
29790: ST_TO_ADDR
// max_x := x + r ;
29791: LD_ADDR_VAR 0 9
29795: PUSH
29796: LD_VAR 0 2
29800: PUSH
29801: LD_VAR 0 4
29805: PLUS
29806: ST_TO_ADDR
// max_y := y + r ;
29807: LD_ADDR_VAR 0 10
29811: PUSH
29812: LD_VAR 0 3
29816: PUSH
29817: LD_VAR 0 4
29821: PLUS
29822: ST_TO_ADDR
// for _x = min_x to max_x do
29823: LD_ADDR_VAR 0 11
29827: PUSH
29828: DOUBLE
29829: LD_VAR 0 7
29833: DEC
29834: ST_TO_ADDR
29835: LD_VAR 0 9
29839: PUSH
29840: FOR_TO
29841: IFFALSE 29958
// for _y = min_y to max_y do
29843: LD_ADDR_VAR 0 12
29847: PUSH
29848: DOUBLE
29849: LD_VAR 0 8
29853: DEC
29854: ST_TO_ADDR
29855: LD_VAR 0 10
29859: PUSH
29860: FOR_TO
29861: IFFALSE 29954
// begin if not ValidHex ( _x , _y ) then
29863: LD_VAR 0 11
29867: PPUSH
29868: LD_VAR 0 12
29872: PPUSH
29873: CALL_OW 488
29877: NOT
29878: IFFALSE 29882
// continue ;
29880: GO 29860
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29882: LD_VAR 0 11
29886: PPUSH
29887: LD_VAR 0 12
29891: PPUSH
29892: CALL_OW 351
29896: PUSH
29897: LD_VAR 0 11
29901: PPUSH
29902: LD_VAR 0 12
29906: PPUSH
29907: CALL_OW 554
29911: AND
29912: IFFALSE 29952
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29914: LD_ADDR_VAR 0 13
29918: PUSH
29919: LD_VAR 0 13
29923: PPUSH
29924: LD_VAR 0 13
29928: PUSH
29929: LD_INT 1
29931: PLUS
29932: PPUSH
29933: LD_VAR 0 11
29937: PUSH
29938: LD_VAR 0 12
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PPUSH
29947: CALL_OW 2
29951: ST_TO_ADDR
// end ;
29952: GO 29860
29954: POP
29955: POP
29956: GO 29840
29958: POP
29959: POP
// if not list then
29960: LD_VAR 0 13
29964: NOT
29965: IFFALSE 29969
// exit ;
29967: GO 30040
// for i in list do
29969: LD_ADDR_VAR 0 6
29973: PUSH
29974: LD_VAR 0 13
29978: PUSH
29979: FOR_IN
29980: IFFALSE 30038
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29982: LD_VAR 0 1
29986: PPUSH
29987: LD_STRING M
29989: PUSH
29990: LD_VAR 0 6
29994: PUSH
29995: LD_INT 1
29997: ARRAY
29998: PUSH
29999: LD_VAR 0 6
30003: PUSH
30004: LD_INT 2
30006: ARRAY
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: LD_INT 0
30013: PUSH
30014: LD_INT 0
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: LIST
30028: PUSH
30029: EMPTY
30030: LIST
30031: PPUSH
30032: CALL_OW 447
30036: GO 29979
30038: POP
30039: POP
// end ;
30040: LD_VAR 0 5
30044: RET
