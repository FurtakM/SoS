// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// PrepareTrigger ;
  15: CALL 40 0 0
// PrepareVulcanoBase ;
  19: CALL 880 0 0
// PrepareRussian ;
  23: CALL 3532 0 0
// PrepareLegion ;
  27: CALL 7063 0 0
// Action ;
  31: CALL 10742 0 0
// InitArt ;
  35: CALL 201 0 0
// end ;
  39: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  40: LD_INT 0
  42: PPUSH
// base_captured := false ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// russian_prepared := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// ru_can_attack := false ;
  59: LD_ADDR_EXP 3
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// ru_sib_bomb := false ;
  67: LD_ADDR_EXP 4
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// chance_to_bomb := [ 5 , 10 , 25 ] [ Difficulty ] ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 5
  82: PUSH
  83: LD_INT 10
  85: PUSH
  86: LD_INT 25
  88: PUSH
  89: EMPTY
  90: LIST
  91: LIST
  92: LIST
  93: PUSH
  94: LD_OWVAR 67
  98: ARRAY
  99: ST_TO_ADDR
// player_res_art := false ;
 100: LD_ADDR_EXP 6
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// player_artifact_ready := false ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// art_icon := art_use_atom ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 7
 123: ST_TO_ADDR
// time_res_art := 600 ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 600
 131: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 132: LD_ADDR_EXP 11
 136: PUSH
 137: LD_INT 21000
 139: ST_TO_ADDR
// mine_vulc := false ;
 140: LD_ADDR_EXP 12
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// medal_enabled := false ;
 148: LD_ADDR_EXP 13
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// dead_counter := 0 ;
 156: LD_ADDR_EXP 14
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// kill_counter := 0 ;
 164: LD_ADDR_EXP 15
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// veh_counter := 0 ;
 172: LD_ADDR_EXP 16
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// tech_counter := 0 ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 188: LD_ADDR_EXP 18
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// end ;
 196: LD_VAR 0 1
 200: RET
// function InitArt ; begin
 201: LD_INT 0
 203: PPUSH
// SetArtifactRes ( your_side , true ) ;
 204: LD_OWVAR 2
 208: PPUSH
 209: LD_INT 1
 211: PPUSH
 212: CALL_OW 467
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 228: LD_ADDR_EXP 21
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 6
 238: PUSH
 239: LD_INT 5
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: PUSH
 247: LD_OWVAR 67
 251: ARRAY
 252: ST_TO_ADDR
// us_force := [ ] ;
 253: LD_ADDR_EXP 20
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 260: LD_INT 17
 262: PPUSH
 263: CALL_OW 355
// PrepareAllianceAI ( ) ;
 267: CALL 16079 0 0
// uc_side := 1 ;
 271: LD_ADDR_OWVAR 20
 275: PUSH
 276: LD_INT 1
 278: ST_TO_ADDR
// uc_nation := nation_american ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 1
 286: ST_TO_ADDR
// hc_gallery :=  ;
 287: LD_ADDR_OWVAR 33
 291: PUSH
 292: LD_STRING 
 294: ST_TO_ADDR
// hc_name :=  ;
 295: LD_ADDR_OWVAR 26
 299: PUSH
 300: LD_STRING 
 302: ST_TO_ADDR
// hc_importance := 0 ;
 303: LD_ADDR_OWVAR 32
 307: PUSH
 308: LD_INT 0
 310: ST_TO_ADDR
// for i = 1 to 11 do
 311: LD_ADDR_VAR 0 2
 315: PUSH
 316: DOUBLE
 317: LD_INT 1
 319: DEC
 320: ST_TO_ADDR
 321: LD_INT 11
 323: PUSH
 324: FOR_TO
 325: IFFALSE 378
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 327: LD_INT 0
 329: PPUSH
 330: LD_INT 1
 332: PPUSH
 333: LD_INT 4
 335: PPUSH
 336: CALL_OW 12
 340: PPUSH
 341: LD_EXP 21
 345: PPUSH
 346: CALL_OW 380
// un := CreateHuman ;
 350: LD_ADDR_VAR 0 4
 354: PUSH
 355: CALL_OW 44
 359: ST_TO_ADDR
// us_force := us_force ^ un ;
 360: LD_ADDR_EXP 20
 364: PUSH
 365: LD_EXP 20
 369: PUSH
 370: LD_VAR 0 4
 374: ADD
 375: ST_TO_ADDR
// end ;
 376: GO 324
 378: POP
 379: POP
// hc_importance := 100 ;
 380: LD_ADDR_OWVAR 32
 384: PUSH
 385: LD_INT 100
 387: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_EXP 21
 398: PPUSH
 399: CALL_OW 380
// us_commander := CreateHuman ;
 403: LD_ADDR_EXP 19
 407: PUSH
 408: CALL_OW 44
 412: ST_TO_ADDR
// player_commander := us_commander ;
 413: LD_ADDR_EXP 10
 417: PUSH
 418: LD_EXP 19
 422: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 423: LD_ADDR_VAR 0 5
 427: PUSH
 428: LD_STRING text
 430: PPUSH
 431: LD_INT 6
 433: PUSH
 434: LD_INT 5
 436: PUSH
 437: LD_INT 4
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: PUSH
 445: LD_OWVAR 67
 449: ARRAY
 450: PPUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 5
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_OWVAR 67
 469: ARRAY
 470: PPUSH
 471: LD_INT -5
 473: PUSH
 474: LD_EXP 19
 478: PUSH
 479: LD_INT -3
 481: PUSH
 482: LD_INT -2
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PUSH
 491: LD_EXP 20
 495: ADD
 496: PPUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 3
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 5
 525: PUSH
 526: LD_INT 5
 528: PUSH
 529: LD_INT 1
 531: NEG
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 42
 555: ST_TO_ADDR
// team := team ^ us_commander ;
 556: LD_ADDR_VAR 0 5
 560: PUSH
 561: LD_VAR 0 5
 565: PUSH
 566: LD_EXP 19
 570: ADD
 571: ST_TO_ADDR
// for i = 1 to team do
 572: LD_ADDR_VAR 0 2
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 5
 586: PUSH
 587: FOR_TO
 588: IFFALSE 613
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 590: LD_VAR 0 5
 594: PUSH
 595: LD_VAR 0 2
 599: ARRAY
 600: PPUSH
 601: LD_INT 1
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 49
 611: GO 587
 613: POP
 614: POP
// end ;
 615: LD_VAR 0 1
 619: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 620: LD_OWVAR 1
 624: PUSH
 625: LD_INT 73500
 627: LESS
 628: IFFALSE 655
 630: GO 632
 632: DISABLE
// begin enable ;
 633: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 634: LD_INT 1
 636: PPUSH
 637: LD_INT 5
 639: PPUSH
 640: CALL_OW 12
 644: PPUSH
 645: LD_INT 24
 647: PPUSH
 648: LD_INT 1
 650: PPUSH
 651: CALL_OW 55
// end ;
 655: END
// every 1 1$10 do var time , p , l ;
 656: GO 658
 658: DISABLE
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
// begin time := 0 0$44 ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_INT 1540
 671: ST_TO_ADDR
// l := 0 ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 67
// l := l + 1 ;
 689: LD_ADDR_VAR 0 3
 693: PUSH
 694: LD_VAR 0 3
 698: PUSH
 699: LD_INT 1
 701: PLUS
 702: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 703: LD_INT 12
 705: PPUSH
 706: CALL_OW 435
 710: PUSH
 711: LD_INT 30
 713: LESS
 714: IFFALSE 773
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 716: LD_INT 1
 718: PPUSH
 719: LD_INT 5
 721: PPUSH
 722: CALL_OW 12
 726: PPUSH
 727: LD_INT 12
 729: PPUSH
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 737: LD_INT 1155
 739: PPUSH
 740: LD_INT 1540
 742: PPUSH
 743: CALL_OW 12
 747: PPUSH
 748: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 752: LD_INT 1
 754: PPUSH
 755: LD_INT 5
 757: PPUSH
 758: CALL_OW 12
 762: PPUSH
 763: LD_INT 12
 765: PPUSH
 766: LD_INT 1
 768: PPUSH
 769: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_INT 0
 780: PPUSH
 781: LD_INT 1
 783: PPUSH
 784: CALL_OW 12
 788: ST_TO_ADDR
// if p then
 789: LD_VAR 0 2
 793: IFFALSE 828
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 795: LD_INT 105
 797: PPUSH
 798: LD_INT 350
 800: PPUSH
 801: CALL_OW 12
 805: PPUSH
 806: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 4
 815: PPUSH
 816: CALL_OW 12
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 828: LD_VAR 0 3
 832: PUSH
 833: LD_INT 15
 835: PUSH
 836: LD_INT 13
 838: PUSH
 839: LD_INT 11
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_OWVAR 67
 851: ARRAY
 852: MOD
 853: PUSH
 854: LD_INT 0
 856: EQUAL
 857: IFFALSE 873
// time := time + 2 2$00 ;
 859: LD_ADDR_VAR 0 1
 863: PUSH
 864: LD_VAR 0 1
 868: PUSH
 869: LD_INT 4200
 871: PLUS
 872: ST_TO_ADDR
// end until false ;
 873: LD_INT 0
 875: IFFALSE 680
// end ; end_of_file
 877: PPOPN 3
 879: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 880: LD_INT 0
 882: PPUSH
 883: PPUSH
 884: PPUSH
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 924: LD_ADDR_VAR 0 4
 928: PUSH
 929: LD_INT 470
 931: PUSH
 932: LD_INT 370
 934: PUSH
 935: LD_INT 290
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_OWVAR 67
 947: ARRAY
 948: ST_TO_ADDR
// case Difficulty of 2 :
 949: LD_OWVAR 67
 953: PUSH
 954: LD_INT 2
 956: DOUBLE
 957: EQUAL
 958: IFTRUE 962
 960: GO 993
 962: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_INT 30
 970: PUSH
 971: LD_INT 32
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PPUSH
 978: CALL_OW 72
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: CALL_OW 65
// end ; 3 :
 991: GO 1069
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1068
1001: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
1002: LD_VAR 0 3
1006: PPUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 32
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL_OW 72
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1030: LD_VAR 0 3
1034: PPUSH
1035: LD_INT 30
1037: PUSH
1038: LD_INT 27
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: PPUSH
1045: CALL_OW 72
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 3
1055: PPUSH
1056: CALL_OW 12
1060: ARRAY
1061: PPUSH
1062: CALL_OW 65
// end ; end ;
1066: GO 1069
1068: POP
// for i = 1 to filter do
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: DOUBLE
1075: LD_INT 1
1077: DEC
1078: ST_TO_ADDR
1079: LD_VAR 0 3
1083: PUSH
1084: FOR_TO
1085: IFFALSE 1122
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1087: LD_VAR 0 3
1091: PUSH
1092: LD_VAR 0 2
1096: ARRAY
1097: PPUSH
1098: LD_VAR 0 4
1102: PUSH
1103: LD_INT 29
1105: NEG
1106: PPUSH
1107: LD_INT 29
1109: PPUSH
1110: CALL_OW 12
1114: PLUS
1115: PPUSH
1116: CALL_OW 234
1120: GO 1084
1122: POP
1123: POP
// SetBName ( us_depot , Vulcano1 ) ;
1124: LD_INT 50
1126: PPUSH
1127: LD_STRING Vulcano1
1129: PPUSH
1130: CALL_OW 500
// hc_importance := 0 ;
1134: LD_ADDR_OWVAR 32
1138: PUSH
1139: LD_INT 0
1141: ST_TO_ADDR
// uc_side := 3 ;
1142: LD_ADDR_OWVAR 20
1146: PUSH
1147: LD_INT 3
1149: ST_TO_ADDR
// uc_nation := nation_russian ;
1150: LD_ADDR_OWVAR 21
1154: PUSH
1155: LD_INT 3
1157: ST_TO_ADDR
// russian_in_base := [ ] ;
1158: LD_ADDR_VAR 0 8
1162: PUSH
1163: EMPTY
1164: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1165: LD_ADDR_VAR 0 6
1169: PUSH
1170: LD_INT 82
1172: PPUSH
1173: LD_INT 137
1175: PPUSH
1176: LD_INT 106
1178: PPUSH
1179: LD_INT 152
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: CALL 1562 0 5
1189: ST_TO_ADDR
// p := 1 ;
1190: LD_ADDR_VAR 0 7
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1198: LD_ADDR_VAR 0 2
1202: PUSH
1203: DOUBLE
1204: LD_INT 1
1206: DEC
1207: ST_TO_ADDR
1208: LD_INT 6
1210: PUSH
1211: LD_INT 6
1213: PUSH
1214: LD_INT 7
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_OWVAR 67
1226: ARRAY
1227: PUSH
1228: FOR_TO
1229: IFFALSE 1341
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 1
1236: PPUSH
1237: LD_INT 4
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: PUSH
1251: LD_OWVAR 67
1255: ARRAY
1256: PPUSH
1257: CALL_OW 380
// un := CreateHuman ;
1261: LD_ADDR_VAR 0 5
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1271: LD_ADDR_VAR 0 8
1275: PUSH
1276: LD_VAR 0 8
1280: PUSH
1281: LD_VAR 0 5
1285: ADD
1286: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1287: LD_VAR 0 5
1291: PPUSH
1292: LD_VAR 0 6
1296: PUSH
1297: LD_VAR 0 7
1301: ARRAY
1302: PPUSH
1303: LD_VAR 0 6
1307: PUSH
1308: LD_VAR 0 7
1312: PUSH
1313: LD_INT 1
1315: PLUS
1316: ARRAY
1317: PPUSH
1318: LD_INT 0
1320: PPUSH
1321: CALL_OW 48
// p := p + 2 ;
1325: LD_ADDR_VAR 0 7
1329: PUSH
1330: LD_VAR 0 7
1334: PUSH
1335: LD_INT 2
1337: PLUS
1338: ST_TO_ADDR
// end ;
1339: GO 1228
1341: POP
1342: POP
// end ;
1343: LD_VAR 0 1
1347: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1348: LD_INT 50
1350: PPUSH
1351: LD_INT 1
1353: PPUSH
1354: CALL 2052 0 2
1358: PUSH
1359: LD_INT 40
1361: LESS
1362: IFFALSE 1559
1364: GO 1366
1366: DISABLE
1367: LD_INT 0
1369: PPUSH
1370: PPUSH
// begin uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// uc_nation := nation_american ;
1379: LD_ADDR_OWVAR 21
1383: PUSH
1384: LD_INT 1
1386: ST_TO_ADDR
// hc_importance := 0 ;
1387: LD_ADDR_OWVAR 32
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// for i = 1 to 7 do
1395: LD_ADDR_VAR 0 1
1399: PUSH
1400: DOUBLE
1401: LD_INT 1
1403: DEC
1404: ST_TO_ADDR
1405: LD_INT 7
1407: PUSH
1408: FOR_TO
1409: IFFALSE 1473
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1411: LD_INT 0
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 12
1424: PPUSH
1425: LD_EXP 21
1429: PPUSH
1430: CALL_OW 380
// un := CreateHuman ;
1434: LD_ADDR_VAR 0 2
1438: PUSH
1439: CALL_OW 44
1443: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1444: LD_VAR 0 2
1448: PPUSH
1449: LD_INT 7
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL_OW 49
// SetLives ( un , 10 ) ;
1459: LD_VAR 0 2
1463: PPUSH
1464: LD_INT 10
1466: PPUSH
1467: CALL_OW 234
// end ;
1471: GO 1408
1473: POP
1474: POP
// for i = 1 to 5 do
1475: LD_ADDR_VAR 0 1
1479: PUSH
1480: DOUBLE
1481: LD_INT 1
1483: DEC
1484: ST_TO_ADDR
1485: LD_INT 5
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1557
// begin PrepareHuman ( false , 4 , us_skill ) ;
1491: LD_INT 0
1493: PPUSH
1494: LD_INT 4
1496: PPUSH
1497: LD_EXP 21
1501: PPUSH
1502: CALL_OW 380
// SetDir ( un , 1 ) ;
1506: LD_VAR 0 2
1510: PPUSH
1511: LD_INT 1
1513: PPUSH
1514: CALL_OW 233
// un := CreateHuman ;
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: CALL_OW 44
1527: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_INT 23
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// SetLives ( un , 10 ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: LD_INT 10
1550: PPUSH
1551: CALL_OW 234
// end ;
1555: GO 1488
1557: POP
1558: POP
// end ; end_of_file
1559: PPOPN 2
1561: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1562: LD_INT 0
1564: PPUSH
1565: PPUSH
1566: PPUSH
// list := [ ] ;
1567: LD_ADDR_VAR 0 7
1571: PUSH
1572: EMPTY
1573: ST_TO_ADDR
// for i = 1 to num do
1574: LD_ADDR_VAR 0 8
1578: PUSH
1579: DOUBLE
1580: LD_INT 1
1582: DEC
1583: ST_TO_ADDR
1584: LD_VAR 0 5
1588: PUSH
1589: FOR_TO
1590: IFFALSE 1646
// begin list := list ^ Rand ( x1 , x2 ) ;
1592: LD_ADDR_VAR 0 7
1596: PUSH
1597: LD_VAR 0 7
1601: PUSH
1602: LD_VAR 0 1
1606: PPUSH
1607: LD_VAR 0 3
1611: PPUSH
1612: CALL_OW 12
1616: ADD
1617: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1618: LD_ADDR_VAR 0 7
1622: PUSH
1623: LD_VAR 0 7
1627: PUSH
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_VAR 0 4
1637: PPUSH
1638: CALL_OW 12
1642: ADD
1643: ST_TO_ADDR
// end ;
1644: GO 1589
1646: POP
1647: POP
// result := list ;
1648: LD_ADDR_VAR 0 6
1652: PUSH
1653: LD_VAR 0 7
1657: ST_TO_ADDR
// end ;
1658: LD_VAR 0 6
1662: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1663: LD_INT 0
1665: PPUSH
1666: PPUSH
1667: PPUSH
1668: PPUSH
// c := Rand ( 1 , 3 ) ;
1669: LD_ADDR_VAR 0 5
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// for i = 1 to list do
1685: LD_ADDR_VAR 0 6
1689: PUSH
1690: DOUBLE
1691: LD_INT 1
1693: DEC
1694: ST_TO_ADDR
1695: LD_VAR 0 1
1699: PUSH
1700: FOR_TO
1701: IFFALSE 1883
// for ta in filter do
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_VAR 0 2
1712: PUSH
1713: FOR_IN
1714: IFFALSE 1879
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1716: LD_VAR 0 1
1720: PUSH
1721: LD_VAR 0 6
1725: ARRAY
1726: PPUSH
1727: LD_VAR 0 4
1731: PPUSH
1732: CALL_OW 296
1736: PUSH
1737: LD_INT 15
1739: LESSEQUAL
1740: IFFALSE 1877
// begin case c of 1 :
1742: LD_VAR 0 5
1746: PUSH
1747: LD_INT 1
1749: DOUBLE
1750: EQUAL
1751: IFTRUE 1755
1753: GO 1793
1755: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1756: LD_VAR 0 1
1760: PUSH
1761: LD_VAR 0 6
1765: ARRAY
1766: PPUSH
1767: LD_VAR 0 4
1771: PPUSH
1772: CALL_OW 250
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 251
1786: PPUSH
1787: CALL_OW 154
1791: GO 1877
1793: LD_INT 2
1795: DOUBLE
1796: EQUAL
1797: IFTRUE 1801
1799: GO 1865
1801: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1802: LD_VAR 0 1
1806: PUSH
1807: LD_VAR 0 6
1811: ARRAY
1812: PPUSH
1813: LD_VAR 0 4
1817: PPUSH
1818: CALL_OW 250
1822: PUSH
1823: LD_INT 1
1825: NEG
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: CALL_OW 12
1834: PLUS
1835: PPUSH
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 251
1845: PUSH
1846: LD_INT 1
1848: NEG
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: CALL_OW 12
1857: PLUS
1858: PPUSH
1859: CALL_OW 153
1863: GO 1877
1865: LD_INT 3
1867: DOUBLE
1868: EQUAL
1869: IFTRUE 1873
1871: GO 1876
1873: POP
// ; end ;
1874: GO 1877
1876: POP
// end ; end ;
1877: GO 1713
1879: POP
1880: POP
1881: GO 1700
1883: POP
1884: POP
// end ;
1885: LD_VAR 0 3
1889: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1890: LD_INT 0
1892: PPUSH
1893: PPUSH
1894: PPUSH
// for i = 1 to n do
1895: LD_ADDR_VAR 0 4
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_VAR 0 1
1909: PUSH
1910: FOR_TO
1911: IFFALSE 2045
// begin uc_side := 0 ;
1913: LD_ADDR_OWVAR 20
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// uc_nation := 0 ;
1921: LD_ADDR_OWVAR 21
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// hc_class := class_apeman ;
1929: LD_ADDR_OWVAR 28
1933: PUSH
1934: LD_INT 12
1936: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1937: LD_ADDR_OWVAR 31
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: LD_INT 0
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: ST_TO_ADDR
// hc_name :=  ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING 
1967: ST_TO_ADDR
// hc_gallery :=  ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING 
1975: ST_TO_ADDR
// hc_importance := 0 ;
1976: LD_ADDR_OWVAR 32
1980: PUSH
1981: LD_INT 0
1983: ST_TO_ADDR
// un := CreateHuman ;
1984: LD_ADDR_VAR 0 3
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1994: LD_VAR 0 3
1998: PPUSH
1999: LD_INT 19
2001: PUSH
2002: LD_INT 20
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 1
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: CALL_OW 12
2019: ARRAY
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2028: LD_INT 1155
2030: PPUSH
2031: LD_INT 5355
2033: PPUSH
2034: CALL_OW 12
2038: PPUSH
2039: CALL_OW 67
// end ;
2043: GO 1910
2045: POP
2046: POP
// end ;
2047: LD_VAR 0 2
2051: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2052: LD_INT 0
2054: PPUSH
2055: PPUSH
2056: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_INT 22
2064: PUSH
2065: LD_VAR 0 2
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PPUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 74
2088: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2089: LD_ADDR_VAR 0 5
2093: PUSH
2094: LD_VAR 0 1
2098: PPUSH
2099: LD_VAR 0 4
2103: PPUSH
2104: CALL_OW 296
2108: ST_TO_ADDR
// if dist >= 9999 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 9999
2116: GREATEREQUAL
2117: IFFALSE 2130
// result := - 1 else
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_INT 1
2126: NEG
2127: ST_TO_ADDR
2128: GO 2140
// result := dist ;
2130: LD_ADDR_VAR 0 3
2134: PUSH
2135: LD_VAR 0 5
2139: ST_TO_ADDR
// end ;
2140: LD_VAR 0 3
2144: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// tmp := 9999 ;
2151: LD_ADDR_VAR 0 5
2155: PUSH
2156: LD_INT 9999
2158: ST_TO_ADDR
// for i = 1 to plist do
2159: LD_ADDR_VAR 0 4
2163: PUSH
2164: DOUBLE
2165: LD_INT 1
2167: DEC
2168: ST_TO_ADDR
2169: LD_VAR 0 1
2173: PUSH
2174: FOR_TO
2175: IFFALSE 2249
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2177: LD_VAR 0 1
2181: PUSH
2182: LD_VAR 0 4
2186: ARRAY
2187: PPUSH
2188: LD_VAR 0 2
2192: PPUSH
2193: CALL 2052 0 2
2197: PUSH
2198: LD_VAR 0 5
2202: LESS
2203: IFFALSE 2247
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_VAR 0 4
2219: ARRAY
2220: PPUSH
2221: LD_VAR 0 2
2225: PPUSH
2226: CALL 2052 0 2
2230: ST_TO_ADDR
// unit := plist [ i ] ;
2231: LD_ADDR_VAR 0 6
2235: PUSH
2236: LD_VAR 0 1
2240: PUSH
2241: LD_VAR 0 4
2245: ARRAY
2246: ST_TO_ADDR
// end ;
2247: GO 2174
2249: POP
2250: POP
// result := unit ;
2251: LD_ADDR_VAR 0 3
2255: PUSH
2256: LD_VAR 0 6
2260: ST_TO_ADDR
// end ;
2261: LD_VAR 0 3
2265: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2266: LD_INT 0
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_INT 1000
2280: PUSH
2281: LD_INT 2500
2283: PUSH
2284: LD_INT 5000
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_VAR 0 2
2307: PUSH
2308: LD_INT 1
2310: NEG
2311: PUSH
2312: LD_INT 22
2314: PUSH
2315: LD_OWVAR 2
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PPUSH
2338: CALL_OW 69
2342: MUL
2343: PUSH
2344: LD_INT 30
2346: MUL
2347: PLUS
2348: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_EXP 15
2363: PUSH
2364: LD_INT 10
2366: MUL
2367: PLUS
2368: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2369: LD_ADDR_VAR 0 2
2373: PUSH
2374: LD_VAR 0 2
2378: PUSH
2379: LD_INT 1
2381: NEG
2382: PUSH
2383: LD_EXP 15
2387: MUL
2388: PUSH
2389: LD_INT 20
2391: MUL
2392: PLUS
2393: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_OWVAR 1
2412: PUSH
2413: LD_INT 35
2415: DIVREAL
2416: PUSH
2417: LD_INT 60
2419: DIVREAL
2420: MUL
2421: PUSH
2422: LD_INT 25
2424: MUL
2425: PLUS
2426: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_VAR 0 2
2436: PUSH
2437: LD_EXP 17
2441: PUSH
2442: LD_INT 15
2444: MUL
2445: PLUS
2446: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_VAR 0 2
2456: PUSH
2457: LD_INT 1
2459: NEG
2460: PUSH
2461: LD_EXP 18
2465: MUL
2466: PUSH
2467: LD_INT 1000
2469: MUL
2470: PLUS
2471: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2472: LD_ADDR_VAR 0 2
2476: PUSH
2477: LD_VAR 0 2
2481: PUSH
2482: LD_EXP 16
2486: PUSH
2487: LD_INT 5
2489: MUL
2490: PLUS
2491: ST_TO_ADDR
// result := points ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_VAR 0 2
2501: ST_TO_ADDR
// end ; end_of_file
2502: LD_VAR 0 1
2506: RET
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL 29801 0 1
// if GetSide ( un ) = your_side then
2516: LD_VAR 0 1
2520: PPUSH
2521: CALL_OW 255
2525: PUSH
2526: LD_OWVAR 2
2530: EQUAL
2531: IFFALSE 2547
// dead_counter := dead_counter + 1 ;
2533: LD_ADDR_EXP 14
2537: PUSH
2538: LD_EXP 14
2542: PUSH
2543: LD_INT 1
2545: PLUS
2546: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2547: LD_VAR 0 1
2551: PPUSH
2552: CALL_OW 255
2556: PUSH
2557: LD_INT 81
2559: PUSH
2560: LD_OWVAR 2
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PPUSH
2569: CALL_OW 69
2573: IN
2574: IFFALSE 2590
// kill_counter := kill_counter + 1 ;
2576: LD_ADDR_EXP 15
2580: PUSH
2581: LD_EXP 15
2585: PUSH
2586: LD_INT 1
2588: PLUS
2589: ST_TO_ADDR
// if un = player_commander then
2590: LD_VAR 0 1
2594: PUSH
2595: LD_EXP 10
2599: EQUAL
2600: IFFALSE 2609
// YouLost ( vulcano-lost ) ;
2602: LD_STRING vulcano-lost
2604: PPUSH
2605: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2609: LD_VAR 0 1
2613: PUSH
2614: LD_INT 22
2616: PUSH
2617: LD_INT 3
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 3
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: IN
2643: IFFALSE 2759
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2645: LD_VAR 0 1
2649: PPUSH
2650: CALL_OW 266
2654: PUSH
2655: LD_INT 33
2657: EQUAL
2658: PUSH
2659: LD_VAR 0 1
2663: PPUSH
2664: CALL_OW 266
2668: PUSH
2669: LD_INT 28
2671: EQUAL
2672: OR
2673: IFFALSE 2759
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2675: LD_ADDR_EXP 26
2679: PUSH
2680: LD_EXP 26
2684: PUSH
2685: LD_VAR 0 1
2689: PPUSH
2690: CALL_OW 266
2694: ADD
2695: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2696: LD_ADDR_EXP 26
2700: PUSH
2701: LD_EXP 26
2705: PUSH
2706: LD_VAR 0 1
2710: PPUSH
2711: CALL_OW 250
2715: ADD
2716: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2717: LD_ADDR_EXP 26
2721: PUSH
2722: LD_EXP 26
2726: PUSH
2727: LD_VAR 0 1
2731: PPUSH
2732: CALL_OW 251
2736: ADD
2737: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2738: LD_ADDR_EXP 26
2742: PUSH
2743: LD_EXP 26
2747: PUSH
2748: LD_VAR 0 1
2752: PPUSH
2753: CALL_OW 254
2757: ADD
2758: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2759: LD_VAR 0 1
2763: PUSH
2764: LD_INT 22
2766: PUSH
2767: LD_INT 8
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: LD_INT 21
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PPUSH
2788: CALL_OW 69
2792: IN
2793: IFFALSE 2937
// begin if GetBType ( un ) = b_barracks then
2795: LD_VAR 0 1
2799: PPUSH
2800: CALL_OW 266
2804: PUSH
2805: LD_INT 5
2807: EQUAL
2808: IFFALSE 2826
// legion_blist := legion_blist ^ b_armoury else
2810: LD_ADDR_EXP 34
2814: PUSH
2815: LD_EXP 34
2819: PUSH
2820: LD_INT 4
2822: ADD
2823: ST_TO_ADDR
2824: GO 2874
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2826: LD_VAR 0 1
2830: PPUSH
2831: CALL_OW 266
2835: PUSH
2836: LD_INT 1
2838: PUSH
2839: LD_INT 6
2841: PUSH
2842: LD_INT 8
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: LIST
2849: IN
2850: NOT
2851: IFFALSE 2874
// legion_blist := legion_blist ^ GetBType ( un ) ;
2853: LD_ADDR_EXP 34
2857: PUSH
2858: LD_EXP 34
2862: PUSH
2863: LD_VAR 0 1
2867: PPUSH
2868: CALL_OW 266
2872: ADD
2873: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2874: LD_ADDR_EXP 34
2878: PUSH
2879: LD_EXP 34
2883: PUSH
2884: LD_VAR 0 1
2888: PPUSH
2889: CALL_OW 250
2893: ADD
2894: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2895: LD_ADDR_EXP 34
2899: PUSH
2900: LD_EXP 34
2904: PUSH
2905: LD_VAR 0 1
2909: PPUSH
2910: CALL_OW 251
2914: ADD
2915: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2916: LD_ADDR_EXP 34
2920: PUSH
2921: LD_EXP 34
2925: PUSH
2926: LD_VAR 0 1
2930: PPUSH
2931: CALL_OW 254
2935: ADD
2936: ST_TO_ADDR
// end ; if un in legion_force then
2937: LD_VAR 0 1
2941: PUSH
2942: LD_EXP 31
2946: IN
2947: IFFALSE 2965
// legion_force := legion_force diff un ;
2949: LD_ADDR_EXP 31
2953: PUSH
2954: LD_EXP 31
2958: PUSH
2959: LD_VAR 0 1
2963: DIFF
2964: ST_TO_ADDR
// if un in ru_force then
2965: LD_VAR 0 1
2969: PUSH
2970: LD_EXP 23
2974: IN
2975: IFFALSE 2993
// ru_force := ru_force diff un ;
2977: LD_ADDR_EXP 23
2981: PUSH
2982: LD_EXP 23
2986: PUSH
2987: LD_VAR 0 1
2991: DIFF
2992: ST_TO_ADDR
// if un in al_force then
2993: LD_VAR 0 1
2997: PUSH
2998: LD_EXP 38
3002: IN
3003: IFFALSE 3021
// al_force := al_force diff un ;
3005: LD_ADDR_EXP 38
3009: PUSH
3010: LD_EXP 38
3014: PUSH
3015: LD_VAR 0 1
3019: DIFF
3020: ST_TO_ADDR
// end ;
3021: PPOPN 1
3023: END
// on BuildingComplete ( b ) do var i ;
3024: LD_INT 0
3026: PPUSH
// begin if GetSide ( b ) = 8 then
3027: LD_VAR 0 1
3031: PPUSH
3032: CALL_OW 255
3036: PUSH
3037: LD_INT 8
3039: EQUAL
3040: IFFALSE 3080
// for i = 1 to 4 do
3042: LD_ADDR_VAR 0 2
3046: PUSH
3047: DOUBLE
3048: LD_INT 1
3050: DEC
3051: ST_TO_ADDR
3052: LD_INT 4
3054: PUSH
3055: FOR_TO
3056: IFFALSE 3078
// legion_blist := Delete ( legion_blist , 1 ) ;
3058: LD_ADDR_EXP 34
3062: PUSH
3063: LD_EXP 34
3067: PPUSH
3068: LD_INT 1
3070: PPUSH
3071: CALL_OW 3
3075: ST_TO_ADDR
3076: GO 3055
3078: POP
3079: POP
// if GetSide ( b ) = 3 then
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 255
3089: PUSH
3090: LD_INT 3
3092: EQUAL
3093: IFFALSE 3133
// for i = 1 to 4 do
3095: LD_ADDR_VAR 0 2
3099: PUSH
3100: DOUBLE
3101: LD_INT 1
3103: DEC
3104: ST_TO_ADDR
3105: LD_INT 4
3107: PUSH
3108: FOR_TO
3109: IFFALSE 3131
// ru_blist := Delete ( ru_blist , 1 ) ;
3111: LD_ADDR_EXP 26
3115: PUSH
3116: LD_EXP 26
3120: PPUSH
3121: LD_INT 1
3123: PPUSH
3124: CALL_OW 3
3128: ST_TO_ADDR
3129: GO 3108
3131: POP
3132: POP
// end ;
3133: PPOPN 2
3135: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3136: LD_VAR 0 1
3140: PPUSH
3141: CALL_OW 264
3145: PUSH
3146: LD_INT 51
3148: PUSH
3149: LD_INT 48
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: IN
3156: NOT
3157: IFFALSE 3205
// begin if GetSide ( veh ) = 3 then
3159: LD_VAR 0 1
3163: PPUSH
3164: CALL_OW 255
3168: PUSH
3169: LD_INT 3
3171: EQUAL
3172: IFFALSE 3205
// begin ComMoveXY ( veh , 149 , 8 ) ;
3174: LD_VAR 0 1
3178: PPUSH
3179: LD_INT 149
3181: PPUSH
3182: LD_INT 8
3184: PPUSH
3185: CALL_OW 111
// ru_force := ru_force ^ veh ;
3189: LD_ADDR_EXP 23
3193: PUSH
3194: LD_EXP 23
3198: PUSH
3199: LD_VAR 0 1
3203: ADD
3204: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3205: LD_VAR 0 1
3209: PPUSH
3210: CALL_OW 264
3214: PUSH
3215: LD_INT 32
3217: PUSH
3218: LD_INT 31
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: IN
3225: NOT
3226: IFFALSE 3259
// begin if GetSide ( veh ) = 8 then
3228: LD_VAR 0 1
3232: PPUSH
3233: CALL_OW 255
3237: PUSH
3238: LD_INT 8
3240: EQUAL
3241: IFFALSE 3259
// legion_force := legion_force ^ veh ;
3243: LD_ADDR_EXP 31
3247: PUSH
3248: LD_EXP 31
3252: PUSH
3253: LD_VAR 0 1
3257: ADD
3258: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3259: LD_VAR 0 1
3263: PPUSH
3264: CALL_OW 255
3268: PUSH
3269: LD_INT 7
3271: EQUAL
3272: PUSH
3273: LD_OWVAR 2
3277: PUSH
3278: LD_INT 7
3280: NONEQUAL
3281: AND
3282: IFFALSE 3300
// al_force := al_force ^ veh ;
3284: LD_ADDR_EXP 38
3288: PUSH
3289: LD_EXP 38
3293: PUSH
3294: LD_VAR 0 1
3298: ADD
3299: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3300: LD_VAR 0 1
3304: PPUSH
3305: CALL_OW 255
3309: PUSH
3310: LD_OWVAR 2
3314: EQUAL
3315: IFFALSE 3331
// veh_counter := veh_counter + 1 ;
3317: LD_ADDR_EXP 16
3321: PUSH
3322: LD_EXP 16
3326: PUSH
3327: LD_INT 1
3329: PLUS
3330: ST_TO_ADDR
// end ;
3331: PPOPN 2
3333: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3334: LD_VAR 0 1
3338: PPUSH
3339: CALL_OW 255
3343: PUSH
3344: LD_OWVAR 2
3348: NONEQUAL
3349: IFFALSE 3365
// sib_contamin_counter := sib_contamin_counter + 1 ;
3351: LD_ADDR_EXP 18
3355: PUSH
3356: LD_EXP 18
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: ST_TO_ADDR
// end ;
3365: PPOPN 3
3367: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 255
3377: PUSH
3378: LD_OWVAR 2
3382: EQUAL
3383: IFFALSE 3399
// tech_counter := tech_counter + 1 ;
3385: LD_ADDR_EXP 17
3389: PUSH
3390: LD_EXP 17
3394: PUSH
3395: LD_INT 1
3397: PLUS
3398: ST_TO_ADDR
// if tech = 53 and your_side = 1 then
3399: LD_VAR 0 1
3403: PUSH
3404: LD_INT 53
3406: EQUAL
3407: PUSH
3408: LD_OWVAR 2
3412: PUSH
3413: LD_INT 1
3415: EQUAL
3416: AND
3417: IFFALSE 3432
// SetTech ( 80 , 1 , state_researched ) ;
3419: LD_INT 80
3421: PPUSH
3422: LD_INT 1
3424: PPUSH
3425: LD_INT 2
3427: PPUSH
3428: CALL_OW 322
// end ;
3432: PPOPN 2
3434: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3435: LD_INT 25
3437: PUSH
3438: LD_INT 12
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: PUSH
3450: LD_INT 9
3452: LESS
3453: IFFALSE 3495
3455: GO 3457
3457: DISABLE
3458: LD_INT 0
3460: PPUSH
// begin enable ;
3461: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3462: LD_ADDR_VAR 0 1
3466: PUSH
3467: LD_INT 25
3469: PUSH
3470: LD_INT 12
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PPUSH
3477: CALL_OW 69
3481: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3482: LD_INT 8
3484: PUSH
3485: LD_VAR 0 1
3489: MINUS
3490: PPUSH
3491: CALL 1890 0 1
// end ;
3495: PPOPN 1
3497: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
3498: LD_VAR 0 1
3502: PPUSH
3503: LD_VAR 0 2
3507: PPUSH
3508: LD_VAR 0 3
3512: PPUSH
3513: CALL 29899 0 3
// end ;
3517: PPOPN 3
3519: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
3520: LD_VAR 0 1
3524: PPUSH
3525: CALL 29907 0 1
// end ; end_of_file
3529: PPOPN 1
3531: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3532: LD_INT 0
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
3538: PPUSH
3539: PPUSH
3540: PPUSH
3541: PPUSH
3542: PPUSH
3543: PPUSH
3544: PPUSH
// uc_side := 3 ;
3545: LD_ADDR_OWVAR 20
3549: PUSH
3550: LD_INT 3
3552: ST_TO_ADDR
// uc_nation := nation_russian ;
3553: LD_ADDR_OWVAR 21
3557: PUSH
3558: LD_INT 3
3560: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3561: LD_ADDR_VAR 0 4
3565: PUSH
3566: LD_INT 22
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 30
3578: PUSH
3579: LD_INT 1
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PPUSH
3590: CALL_OW 69
3594: PUSH
3595: LD_INT 1
3597: ARRAY
3598: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_INT 22
3606: PUSH
3607: LD_INT 3
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 30
3616: PUSH
3617: LD_INT 3
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 69
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3637: LD_ADDR_VAR 0 6
3641: PUSH
3642: LD_INT 22
3644: PUSH
3645: LD_INT 3
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: LD_INT 30
3654: PUSH
3655: LD_INT 34
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PPUSH
3666: CALL_OW 69
3670: PUSH
3671: LD_INT 1
3673: ARRAY
3674: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3675: LD_ADDR_VAR 0 8
3679: PUSH
3680: LD_INT 22
3682: PUSH
3683: LD_INT 3
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PUSH
3690: LD_INT 30
3692: PUSH
3693: LD_INT 33
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PPUSH
3704: CALL_OW 69
3708: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3709: LD_ADDR_VAR 0 7
3713: PUSH
3714: LD_INT 22
3716: PUSH
3717: LD_INT 3
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_INT 30
3726: PUSH
3727: LD_INT 5
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PPUSH
3738: CALL_OW 69
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: ST_TO_ADDR
// ru_blist := [ ] ;
3747: LD_ADDR_EXP 26
3751: PUSH
3752: EMPTY
3753: ST_TO_ADDR
// ru_vlist := [ ] ;
3754: LD_ADDR_EXP 27
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3761: LD_ADDR_EXP 30
3765: PUSH
3766: LD_INT 183
3768: PUSH
3769: LD_INT 62
3771: PUSH
3772: LD_INT 147
3774: PUSH
3775: LD_INT 44
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3784: LD_INT 30
3786: PUSH
3787: LD_INT 34
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: PPUSH
3803: LD_EXP 30
3807: PUSH
3808: LD_INT 1
3810: ARRAY
3811: PPUSH
3812: LD_EXP 30
3816: PUSH
3817: LD_INT 2
3819: ARRAY
3820: PPUSH
3821: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3825: LD_ADDR_EXP 28
3829: PUSH
3830: LD_INT 4
3832: PUSH
3833: LD_INT 5
3835: PUSH
3836: LD_INT 6
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_OWVAR 67
3848: ARRAY
3849: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3850: LD_VAR 0 4
3854: PPUSH
3855: CALL_OW 274
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 3000
3865: PPUSH
3866: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3870: LD_VAR 0 4
3874: PPUSH
3875: CALL_OW 274
3879: PPUSH
3880: LD_INT 2
3882: PPUSH
3883: LD_INT 300
3885: PPUSH
3886: CALL_OW 277
// hc_gallery :=  ;
3890: LD_ADDR_OWVAR 33
3894: PUSH
3895: LD_STRING 
3897: ST_TO_ADDR
// hc_name :=  ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING 
3905: ST_TO_ADDR
// hc_importance := 0 ;
3906: LD_ADDR_OWVAR 32
3910: PUSH
3911: LD_INT 0
3913: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3914: LD_ADDR_EXP 24
3918: PUSH
3919: LD_INT 5
3921: PUSH
3922: LD_INT 6
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: LIST
3932: PUSH
3933: LD_OWVAR 67
3937: ARRAY
3938: ST_TO_ADDR
// for i = 1 to 6 do
3939: LD_ADDR_VAR 0 2
3943: PUSH
3944: DOUBLE
3945: LD_INT 1
3947: DEC
3948: ST_TO_ADDR
3949: LD_INT 6
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4111
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 9
3960: PPUSH
3961: LD_EXP 24
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 3
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3980: LD_VAR 0 3
3984: PPUSH
3985: LD_VAR 0 7
3989: PPUSH
3990: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3994: LD_INT 0
3996: PPUSH
3997: LD_INT 4
3999: PPUSH
4000: LD_EXP 24
4004: PPUSH
4005: CALL_OW 380
// un := CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
4019: LD_VAR 0 3
4023: PPUSH
4024: LD_INT 24
4026: PPUSH
4027: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
4031: LD_INT 0
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: LD_EXP 24
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
4056: LD_VAR 0 3
4060: PPUSH
4061: LD_VAR 0 5
4065: PPUSH
4066: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
4070: LD_INT 0
4072: PPUSH
4073: LD_INT 2
4075: PPUSH
4076: LD_EXP 24
4080: PPUSH
4081: CALL_OW 380
// un := CreateHuman ;
4085: LD_ADDR_VAR 0 3
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4095: LD_VAR 0 3
4099: PPUSH
4100: LD_VAR 0 4
4104: PPUSH
4105: CALL_OW 52
// end ;
4109: GO 3952
4111: POP
4112: POP
// russian_prepared := true ;
4113: LD_ADDR_EXP 2
4117: PUSH
4118: LD_INT 1
4120: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4121: LD_VAR 0 5
4125: PPUSH
4126: LD_INT 21
4128: PPUSH
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 3
4134: PPUSH
4135: LD_INT 51
4137: PPUSH
4138: CALL_OW 125
// end ;
4142: LD_VAR 0 1
4146: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4147: LD_INT 22
4149: PUSH
4150: LD_INT 3
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PPUSH
4157: CALL_OW 69
4161: PUSH
4162: LD_INT 0
4164: GREATER
4165: PUSH
4166: LD_EXP 2
4170: AND
4171: IFFALSE 6634
4173: GO 4175
4175: DISABLE
4176: LD_INT 0
4178: PPUSH
4179: PPUSH
4180: PPUSH
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
4189: PPUSH
4190: PPUSH
4191: PPUSH
4192: PPUSH
4193: PPUSH
4194: PPUSH
// begin enable ;
4195: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4196: LD_ADDR_VAR 0 1
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: LD_INT 3
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: PUSH
4211: LD_INT 30
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PPUSH
4225: CALL_OW 69
4229: PUSH
4230: LD_INT 1
4232: ARRAY
4233: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4234: LD_ADDR_VAR 0 2
4238: PUSH
4239: LD_INT 22
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 3
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 69
4267: PUSH
4268: LD_INT 1
4270: ARRAY
4271: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4272: LD_ADDR_VAR 0 3
4276: PUSH
4277: LD_INT 22
4279: PUSH
4280: LD_INT 3
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 30
4289: PUSH
4290: LD_INT 34
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: PPUSH
4301: CALL_OW 69
4305: PUSH
4306: LD_INT 1
4308: ARRAY
4309: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4310: LD_ADDR_VAR 0 4
4314: PUSH
4315: LD_INT 22
4317: PUSH
4318: LD_INT 3
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 30
4327: PUSH
4328: LD_INT 33
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4344: LD_ADDR_VAR 0 8
4348: PUSH
4349: LD_INT 22
4351: PUSH
4352: LD_INT 3
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 30
4361: PUSH
4362: LD_INT 5
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PPUSH
4373: CALL_OW 69
4377: PUSH
4378: LD_INT 1
4380: ARRAY
4381: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4382: LD_ADDR_VAR 0 5
4386: PUSH
4387: LD_INT 22
4389: PUSH
4390: LD_INT 3
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 21
4399: PUSH
4400: LD_INT 3
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: PPUSH
4411: CALL_OW 69
4415: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 6
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4450: LD_ADDR_VAR 0 7
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 21
4467: PUSH
4468: LD_INT 1
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 69
4483: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4484: LD_ADDR_VAR 0 9
4488: PUSH
4489: LD_VAR 0 7
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 2
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4509: LD_ADDR_VAR 0 10
4513: PUSH
4514: LD_VAR 0 7
4518: PPUSH
4519: LD_INT 25
4521: PUSH
4522: LD_INT 3
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PPUSH
4529: CALL_OW 72
4533: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4534: LD_ADDR_VAR 0 11
4538: PUSH
4539: LD_VAR 0 7
4543: PPUSH
4544: LD_INT 25
4546: PUSH
4547: LD_INT 4
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 72
4558: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4559: LD_INT 22
4561: PUSH
4562: LD_INT 3
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 34
4571: PUSH
4572: LD_INT 51
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PPUSH
4583: CALL_OW 69
4587: PUSH
4588: LD_INT 0
4590: GREATER
4591: PUSH
4592: LD_EXP 25
4596: PUSH
4597: LD_INT 0
4599: EQUAL
4600: AND
4601: IFFALSE 4641
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4603: LD_ADDR_EXP 25
4607: PUSH
4608: LD_INT 22
4610: PUSH
4611: LD_INT 3
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: PUSH
4618: LD_INT 34
4620: PUSH
4621: LD_INT 51
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PPUSH
4632: CALL_OW 69
4636: PUSH
4637: LD_INT 1
4639: ARRAY
4640: ST_TO_ADDR
// if ru_cargo then
4641: LD_EXP 25
4645: IFFALSE 4943
// begin if IsInArea ( ru_cargo , ru_base ) then
4647: LD_EXP 25
4651: PPUSH
4652: LD_INT 9
4654: PPUSH
4655: CALL_OW 308
4659: IFFALSE 4738
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4661: LD_EXP 25
4665: PPUSH
4666: LD_INT 1
4668: PPUSH
4669: CALL_OW 289
4673: PUSH
4674: LD_INT 0
4676: EQUAL
4677: IFFALSE 4695
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4679: LD_EXP 25
4683: PPUSH
4684: LD_VAR 0 3
4688: PPUSH
4689: CALL_OW 120
4693: GO 4736
// if not HasTask ( ru_cargo ) then
4695: LD_EXP 25
4699: PPUSH
4700: CALL_OW 314
4704: NOT
4705: IFFALSE 4736
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4707: LD_EXP 25
4711: PPUSH
4712: LD_VAR 0 1
4716: PPUSH
4717: CALL_OW 250
4721: PPUSH
4722: LD_VAR 0 1
4726: PPUSH
4727: CALL_OW 251
4731: PPUSH
4732: CALL_OW 111
// end else
4736: GO 4943
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4738: LD_EXP 25
4742: PPUSH
4743: CALL_OW 314
4747: NOT
4748: PUSH
4749: LD_EXP 25
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: CALL_OW 289
4761: PUSH
4762: LD_INT 100
4764: LESS
4765: AND
4766: IFFALSE 4832
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4768: LD_ADDR_VAR 0 16
4772: PUSH
4773: LD_INT 11
4775: PPUSH
4776: CALL_OW 435
4780: ST_TO_ADDR
// if cr > 0 then
4781: LD_VAR 0 16
4785: PUSH
4786: LD_INT 0
4788: GREATER
4789: IFFALSE 4820
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4791: LD_EXP 25
4795: PPUSH
4796: LD_VAR 0 16
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_VAR 0 16
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: CALL_OW 117
4818: GO 4832
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4820: LD_EXP 25
4824: PPUSH
4825: LD_INT 11
4827: PPUSH
4828: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4832: LD_EXP 25
4836: PPUSH
4837: CALL_OW 314
4841: NOT
4842: PUSH
4843: LD_EXP 25
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL_OW 308
4855: NOT
4856: AND
4857: PUSH
4858: LD_EXP 25
4862: PPUSH
4863: LD_INT 1
4865: PPUSH
4866: CALL_OW 289
4870: PUSH
4871: LD_INT 100
4873: EQUAL
4874: AND
4875: IFFALSE 4889
// ComMoveToArea ( ru_cargo , cargoa ) ;
4877: LD_EXP 25
4881: PPUSH
4882: LD_INT 10
4884: PPUSH
4885: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4889: LD_EXP 25
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 308
4901: PUSH
4902: LD_VAR 0 8
4906: AND
4907: IFFALSE 4943
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4909: LD_VAR 0 7
4913: PPUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 9
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 72
4928: PUSH
4929: LD_INT 1
4931: ARRAY
4932: PPUSH
4933: LD_INT 139
4935: PPUSH
4936: LD_INT 24
4938: PPUSH
4939: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4943: LD_EXP 25
4947: PUSH
4948: LD_INT 0
4950: EQUAL
4951: PUSH
4952: LD_VAR 0 2
4956: AND
4957: PUSH
4958: LD_VAR 0 2
4962: PPUSH
4963: CALL_OW 461
4967: PUSH
4968: LD_INT 2
4970: EQUAL
4971: AND
4972: IFFALSE 4995
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4974: LD_VAR 0 2
4978: PPUSH
4979: LD_INT 21
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: LD_INT 3
4987: PPUSH
4988: LD_INT 51
4990: PPUSH
4991: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4995: LD_VAR 0 7
4999: PPUSH
5000: LD_INT 25
5002: PUSH
5003: LD_INT 9
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PPUSH
5010: CALL_OW 72
5014: IFFALSE 5078
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
5016: LD_VAR 0 7
5020: PPUSH
5021: LD_INT 25
5023: PUSH
5024: LD_INT 9
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PPUSH
5031: CALL_OW 72
5035: PPUSH
5036: LD_INT 22
5038: PUSH
5039: LD_OWVAR 2
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 3
5050: PUSH
5051: LD_INT 21
5053: PUSH
5054: LD_INT 3
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PPUSH
5069: CALL_OW 69
5073: PPUSH
5074: CALL 1663 0 2
// if ru_factory and ru_vlist > 0 then
5078: LD_VAR 0 2
5082: PUSH
5083: LD_EXP 27
5087: PUSH
5088: LD_INT 0
5090: GREATER
5091: AND
5092: IFFALSE 5192
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5094: LD_VAR 0 2
5098: PPUSH
5099: CALL_OW 461
5103: PUSH
5104: LD_INT 2
5106: EQUAL
5107: IFFALSE 5192
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5109: LD_VAR 0 2
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_INT 1
5121: ARRAY
5122: PPUSH
5123: LD_EXP 27
5127: PUSH
5128: LD_INT 2
5130: ARRAY
5131: PPUSH
5132: LD_EXP 27
5136: PUSH
5137: LD_INT 3
5139: ARRAY
5140: PPUSH
5141: LD_EXP 27
5145: PUSH
5146: LD_INT 4
5148: ARRAY
5149: PPUSH
5150: CALL_OW 125
// for i = 1 to 4 do
5154: LD_ADDR_VAR 0 12
5158: PUSH
5159: DOUBLE
5160: LD_INT 1
5162: DEC
5163: ST_TO_ADDR
5164: LD_INT 4
5166: PUSH
5167: FOR_TO
5168: IFFALSE 5190
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5170: LD_ADDR_EXP 27
5174: PUSH
5175: LD_EXP 27
5179: PPUSH
5180: LD_INT 1
5182: PPUSH
5183: CALL_OW 3
5187: ST_TO_ADDR
5188: GO 5167
5190: POP
5191: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5192: LD_INT 24
5194: PPUSH
5195: CALL_OW 461
5199: PUSH
5200: LD_INT 2
5202: EQUAL
5203: PUSH
5204: LD_EXP 4
5208: AND
5209: IFFALSE 5237
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5211: LD_INT 25
5213: PPUSH
5214: LD_INT 3
5216: PPUSH
5217: CALL_OW 321
5221: PUSH
5222: LD_INT 1
5224: EQUAL
5225: IFFALSE 5237
// ComResearch ( ru_lab , tech_sibfiss ) ;
5227: LD_INT 24
5229: PPUSH
5230: LD_INT 25
5232: PPUSH
5233: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched and tick mod 5 5$00 = 0 then
5237: LD_INT 25
5239: PPUSH
5240: LD_INT 3
5242: PPUSH
5243: CALL_OW 321
5247: PUSH
5248: LD_INT 2
5250: EQUAL
5251: PUSH
5252: LD_OWVAR 1
5256: PUSH
5257: LD_INT 10500
5259: MOD
5260: PUSH
5261: LD_INT 0
5263: EQUAL
5264: AND
5265: IFFALSE 5303
// if BuildingStatus ( ru_factory ) = bs_idle then
5267: LD_VAR 0 2
5271: PPUSH
5272: CALL_OW 461
5276: PUSH
5277: LD_INT 2
5279: EQUAL
5280: IFFALSE 5303
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5282: LD_VAR 0 2
5286: PPUSH
5287: LD_INT 23
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: LD_INT 3
5295: PPUSH
5296: LD_INT 48
5298: PPUSH
5299: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5303: LD_INT 22
5305: PUSH
5306: LD_INT 3
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: PUSH
5313: LD_INT 34
5315: PUSH
5316: LD_INT 48
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: PUSH
5332: LD_INT 0
5334: GREATER
5335: IFFALSE 5709
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5337: LD_ADDR_VAR 0 17
5341: PUSH
5342: LD_INT 22
5344: PUSH
5345: LD_INT 3
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: PUSH
5352: LD_INT 34
5354: PUSH
5355: LD_INT 48
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PPUSH
5366: CALL_OW 69
5370: PUSH
5371: LD_INT 1
5373: ARRAY
5374: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5375: LD_VAR 0 17
5379: PPUSH
5380: LD_INT 9
5382: PPUSH
5383: CALL_OW 308
5387: IFFALSE 5405
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5389: LD_VAR 0 17
5393: PPUSH
5394: LD_VAR 0 3
5398: PPUSH
5399: CALL_OW 120
5403: GO 5709
// if not HasTask ( sib_bomb ) then
5405: LD_VAR 0 17
5409: PPUSH
5410: CALL_OW 314
5414: NOT
5415: IFFALSE 5709
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5417: LD_INT 22
5419: PUSH
5420: LD_OWVAR 2
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 1
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 256
5456: PUSH
5457: LD_INT 250
5459: GREATER
5460: IFFALSE 5553
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5462: LD_VAR 0 17
5466: PPUSH
5467: LD_INT 22
5469: PUSH
5470: LD_OWVAR 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PPUSH
5493: CALL_OW 69
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: CALL_OW 250
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_OWVAR 2
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 30
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PPUSH
5533: CALL_OW 69
5537: PUSH
5538: LD_INT 1
5540: ARRAY
5541: PPUSH
5542: CALL_OW 251
5546: PPUSH
5547: CALL_OW 116
5551: GO 5709
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5553: LD_INT 22
5555: PUSH
5556: LD_OWVAR 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 21
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL_OW 69
5583: PUSH
5584: LD_INT 0
5586: GREATER
5587: IFFALSE 5680
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5589: LD_VAR 0 17
5593: PPUSH
5594: LD_INT 22
5596: PUSH
5597: LD_OWVAR 2
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 21
5608: PUSH
5609: LD_INT 3
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: PUSH
5625: LD_INT 1
5627: ARRAY
5628: PPUSH
5629: CALL_OW 250
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_OWVAR 2
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 21
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PPUSH
5660: CALL_OW 69
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 251
5673: PPUSH
5674: CALL_OW 116
5678: GO 5709
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5680: LD_VAR 0 17
5684: PPUSH
5685: LD_EXP 10
5689: PPUSH
5690: CALL_OW 250
5694: PPUSH
5695: LD_EXP 10
5699: PPUSH
5700: CALL_OW 251
5704: PPUSH
5705: CALL_OW 116
// end ; if ru_can_attack then
5709: LD_EXP 3
5713: IFFALSE 5861
// if ru_time > 0 0$00 then
5715: LD_EXP 29
5719: PUSH
5720: LD_INT 0
5722: GREATER
5723: IFFALSE 5741
// ru_time := ru_time - 0 0$01 else
5725: LD_ADDR_EXP 29
5729: PUSH
5730: LD_EXP 29
5734: PUSH
5735: LD_INT 35
5737: MINUS
5738: ST_TO_ADDR
5739: GO 5861
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5741: LD_ADDR_EXP 29
5745: PUSH
5746: LD_INT 20265
5748: PPUSH
5749: LD_INT 30765
5751: PPUSH
5752: CALL_OW 12
5756: ST_TO_ADDR
// for i = 1 to ru_amount do
5757: LD_ADDR_VAR 0 12
5761: PUSH
5762: DOUBLE
5763: LD_INT 1
5765: DEC
5766: ST_TO_ADDR
5767: LD_EXP 28
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5859
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5775: LD_ADDR_EXP 27
5779: PUSH
5780: LD_EXP 27
5784: PUSH
5785: LD_INT 23
5787: ADD
5788: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5789: LD_ADDR_EXP 27
5793: PUSH
5794: LD_EXP 27
5798: PUSH
5799: LD_INT 3
5801: ADD
5802: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5803: LD_ADDR_EXP 27
5807: PUSH
5808: LD_EXP 27
5812: PUSH
5813: LD_INT 3
5815: ADD
5816: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5817: LD_ADDR_EXP 27
5821: PUSH
5822: LD_EXP 27
5826: PUSH
5827: LD_INT 46
5829: PUSH
5830: LD_INT 45
5832: PUSH
5833: LD_INT 47
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_INT 1
5843: PPUSH
5844: LD_INT 2
5846: PPUSH
5847: LD_INT 3
5849: PPUSH
5850: CALL_OW 14
5854: ARRAY
5855: ADD
5856: ST_TO_ADDR
// end ;
5857: GO 5772
5859: POP
5860: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5861: LD_VAR 0 4
5865: PPUSH
5866: LD_INT 35
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 72
5880: PUSH
5881: LD_INT 0
5883: GREATER
5884: IFFALSE 5932
// if BuildingStatus ( ru_factory ) = bs_idle then
5886: LD_VAR 0 2
5890: PPUSH
5891: CALL_OW 461
5895: PUSH
5896: LD_INT 2
5898: EQUAL
5899: IFFALSE 5932
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5901: LD_VAR 0 4
5905: PPUSH
5906: LD_INT 35
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PPUSH
5916: CALL_OW 72
5920: PUSH
5921: LD_INT 1
5923: ARRAY
5924: PPUSH
5925: LD_INT 47
5927: PPUSH
5928: CALL_OW 148
// if ru_force = ru_amount then
5932: LD_EXP 23
5936: PUSH
5937: LD_EXP 28
5941: EQUAL
5942: IFFALSE 6074
// begin for i = 1 to ru_force do
5944: LD_ADDR_VAR 0 12
5948: PUSH
5949: DOUBLE
5950: LD_INT 1
5952: DEC
5953: ST_TO_ADDR
5954: LD_EXP 23
5958: PUSH
5959: FOR_TO
5960: IFFALSE 6070
// if IsInArea ( ru_force [ i ] , ru_base ) then
5962: LD_EXP 23
5966: PUSH
5967: LD_VAR 0 12
5971: ARRAY
5972: PPUSH
5973: LD_INT 9
5975: PPUSH
5976: CALL_OW 308
5980: IFFALSE 6004
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5982: LD_EXP 23
5986: PUSH
5987: LD_VAR 0 12
5991: ARRAY
5992: PPUSH
5993: LD_VAR 0 3
5997: PPUSH
5998: CALL_OW 120
6002: GO 6068
// if not HasTask ( ru_force [ i ] ) then
6004: LD_EXP 23
6008: PUSH
6009: LD_VAR 0 12
6013: ARRAY
6014: PPUSH
6015: CALL_OW 314
6019: NOT
6020: IFFALSE 6068
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6022: LD_EXP 23
6026: PUSH
6027: LD_VAR 0 12
6031: ARRAY
6032: PPUSH
6033: LD_INT 81
6035: PUSH
6036: LD_INT 3
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 69
6047: PPUSH
6048: LD_EXP 23
6052: PUSH
6053: LD_VAR 0 12
6057: ARRAY
6058: PPUSH
6059: CALL_OW 74
6063: PPUSH
6064: CALL_OW 115
6068: GO 5959
6070: POP
6071: POP
// end else
6072: GO 6224
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
6074: LD_EXP 23
6078: PPUSH
6079: LD_INT 3
6081: PUSH
6082: LD_INT 95
6084: PUSH
6085: LD_INT 18
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PPUSH
6096: CALL_OW 72
6100: PUSH
6101: LD_INT 0
6103: GREATER
6104: IFFALSE 6224
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6106: LD_ADDR_VAR 0 13
6110: PUSH
6111: LD_EXP 23
6115: PPUSH
6116: LD_INT 3
6118: PUSH
6119: LD_INT 95
6121: PUSH
6122: LD_INT 18
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: PPUSH
6133: CALL_OW 72
6137: ST_TO_ADDR
// for i = 1 to tmp do
6138: LD_ADDR_VAR 0 12
6142: PUSH
6143: DOUBLE
6144: LD_INT 1
6146: DEC
6147: ST_TO_ADDR
6148: LD_VAR 0 13
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6222
// if not HasTask ( tmp [ i ] ) then
6156: LD_VAR 0 13
6160: PUSH
6161: LD_VAR 0 12
6165: ARRAY
6166: PPUSH
6167: CALL_OW 314
6171: NOT
6172: IFFALSE 6220
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6174: LD_EXP 23
6178: PUSH
6179: LD_VAR 0 12
6183: ARRAY
6184: PPUSH
6185: LD_INT 81
6187: PUSH
6188: LD_INT 3
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 69
6199: PPUSH
6200: LD_EXP 23
6204: PUSH
6205: LD_VAR 0 12
6209: ARRAY
6210: PPUSH
6211: CALL_OW 74
6215: PPUSH
6216: CALL_OW 115
6220: GO 6153
6222: POP
6223: POP
// end ; if ru_engs > 0 then
6224: LD_VAR 0 9
6228: PUSH
6229: LD_INT 0
6231: GREATER
6232: IFFALSE 6634
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6234: LD_VAR 0 5
6238: PPUSH
6239: LD_INT 3
6241: PUSH
6242: LD_INT 24
6244: PUSH
6245: LD_INT 1000
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: LD_INT 0
6263: GREATER
6264: IFFALSE 6419
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6266: LD_ADDR_VAR 0 14
6270: PUSH
6271: LD_VAR 0 5
6275: PPUSH
6276: LD_INT 3
6278: PUSH
6279: LD_INT 24
6281: PUSH
6282: LD_INT 1000
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: CALL_OW 72
6297: ST_TO_ADDR
// for i = 1 to ru_engs do
6298: LD_ADDR_VAR 0 12
6302: PUSH
6303: DOUBLE
6304: LD_INT 1
6306: DEC
6307: ST_TO_ADDR
6308: LD_VAR 0 9
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6415
// begin if IsInUnit ( ru_engs [ i ] ) then
6316: LD_VAR 0 9
6320: PUSH
6321: LD_VAR 0 12
6325: ARRAY
6326: PPUSH
6327: CALL_OW 310
6331: IFFALSE 6350
// ComExitBuilding ( ru_engs [ i ] ) else
6333: LD_VAR 0 9
6337: PUSH
6338: LD_VAR 0 12
6342: ARRAY
6343: PPUSH
6344: CALL_OW 122
6348: GO 6413
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 256
6382: PUSH
6383: LD_INT 600
6385: GREATER
6386: AND
6387: IFFALSE 6413
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6389: LD_VAR 0 9
6393: PUSH
6394: LD_VAR 0 12
6398: ARRAY
6399: PPUSH
6400: LD_VAR 0 14
6404: PUSH
6405: LD_INT 1
6407: ARRAY
6408: PPUSH
6409: CALL_OW 130
// end ;
6413: GO 6313
6415: POP
6416: POP
// end else
6417: GO 6634
// begin if ru_blist = 0 then
6419: LD_EXP 26
6423: PUSH
6424: LD_INT 0
6426: EQUAL
6427: IFFALSE 6509
// begin for i = 1 to ru_engs do
6429: LD_ADDR_VAR 0 12
6433: PUSH
6434: DOUBLE
6435: LD_INT 1
6437: DEC
6438: ST_TO_ADDR
6439: LD_VAR 0 9
6443: PUSH
6444: FOR_TO
6445: IFFALSE 6505
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 314
6462: NOT
6463: PUSH
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 310
6479: NOT
6480: AND
6481: IFFALSE 6503
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6483: LD_VAR 0 9
6487: PUSH
6488: LD_VAR 0 12
6492: ARRAY
6493: PPUSH
6494: LD_VAR 0 1
6498: PPUSH
6499: CALL_OW 120
6503: GO 6444
6505: POP
6506: POP
// end else
6507: GO 6634
// begin for i = 1 to ru_engs do
6509: LD_ADDR_VAR 0 12
6513: PUSH
6514: DOUBLE
6515: LD_INT 1
6517: DEC
6518: ST_TO_ADDR
6519: LD_VAR 0 9
6523: PUSH
6524: FOR_TO
6525: IFFALSE 6632
// begin if IsInUnit ( ru_engs [ i ] ) then
6527: LD_VAR 0 9
6531: PUSH
6532: LD_VAR 0 12
6536: ARRAY
6537: PPUSH
6538: CALL_OW 310
6542: IFFALSE 6561
// ComExitBuilding ( ru_engs [ i ] ) else
6544: LD_VAR 0 9
6548: PUSH
6549: LD_VAR 0 12
6553: ARRAY
6554: PPUSH
6555: CALL_OW 122
6559: GO 6630
// if not HasTask ( ru_engs [ i ] ) then
6561: LD_VAR 0 9
6565: PUSH
6566: LD_VAR 0 12
6570: ARRAY
6571: PPUSH
6572: CALL_OW 314
6576: NOT
6577: IFFALSE 6630
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6579: LD_VAR 0 9
6583: PUSH
6584: LD_VAR 0 12
6588: ARRAY
6589: PPUSH
6590: LD_EXP 26
6594: PUSH
6595: LD_INT 1
6597: ARRAY
6598: PPUSH
6599: LD_EXP 26
6603: PUSH
6604: LD_INT 2
6606: ARRAY
6607: PPUSH
6608: LD_EXP 26
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PPUSH
6617: LD_EXP 26
6621: PUSH
6622: LD_INT 4
6624: ARRAY
6625: PPUSH
6626: CALL_OW 145
// end ;
6630: GO 6524
6632: POP
6633: POP
// end ; end ; end ; end ;
6634: PPOPN 17
6636: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6637: LD_EXP 2
6641: PUSH
6642: LD_INT 11
6644: PPUSH
6645: CALL_OW 435
6649: PUSH
6650: LD_INT 20
6652: LESS
6653: AND
6654: IFFALSE 6717
6656: GO 6658
6658: DISABLE
// begin enable ;
6659: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6660: LD_INT 1
6662: PPUSH
6663: LD_INT 5
6665: PPUSH
6666: CALL_OW 12
6670: PPUSH
6671: LD_INT 11
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6681: LD_INT 1505
6683: PPUSH
6684: LD_INT 2100
6686: PPUSH
6687: CALL_OW 12
6691: PPUSH
6692: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6696: LD_INT 1
6698: PPUSH
6699: LD_INT 5
6701: PPUSH
6702: CALL_OW 12
6706: PPUSH
6707: LD_INT 11
6709: PPUSH
6710: LD_INT 1
6712: PPUSH
6713: CALL_OW 55
// end ;
6717: END
// every 15 15$00 + 25 25$00 trigger ru_sib_bomb = false do var i , tmp ;
6718: LD_EXP 4
6722: PUSH
6723: LD_INT 0
6725: EQUAL
6726: IFFALSE 6841
6728: GO 6730
6730: DISABLE
6731: LD_INT 0
6733: PPUSH
6734: PPUSH
// begin enable ;
6735: ENABLE
// i := Rand ( 0 , 100 ) ;
6736: LD_ADDR_VAR 0 1
6740: PUSH
6741: LD_INT 0
6743: PPUSH
6744: LD_INT 100
6746: PPUSH
6747: CALL_OW 12
6751: ST_TO_ADDR
// case your_side of 1 :
6752: LD_OWVAR 2
6756: PUSH
6757: LD_INT 1
6759: DOUBLE
6760: EQUAL
6761: IFTRUE 6765
6763: GO 6776
6765: POP
// tmp := 10 ; 2 :
6766: LD_ADDR_VAR 0 2
6770: PUSH
6771: LD_INT 10
6773: ST_TO_ADDR
6774: GO 6815
6776: LD_INT 2
6778: DOUBLE
6779: EQUAL
6780: IFTRUE 6784
6782: GO 6795
6784: POP
// tmp := 0 ; 7 :
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_INT 0
6792: ST_TO_ADDR
6793: GO 6815
6795: LD_INT 7
6797: DOUBLE
6798: EQUAL
6799: IFTRUE 6803
6801: GO 6814
6803: POP
// tmp := 15 ; end ;
6804: LD_ADDR_VAR 0 2
6808: PUSH
6809: LD_INT 15
6811: ST_TO_ADDR
6812: GO 6815
6814: POP
// if i < chance_to_bomb + tmp then
6815: LD_VAR 0 1
6819: PUSH
6820: LD_EXP 5
6824: PUSH
6825: LD_VAR 0 2
6829: PLUS
6830: LESS
6831: IFFALSE 6841
// ru_sib_bomb := true ;
6833: LD_ADDR_EXP 4
6837: PUSH
6838: LD_INT 1
6840: ST_TO_ADDR
// end ;
6841: PPOPN 2
6843: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6844: LD_INT 22
6846: PUSH
6847: LD_OWVAR 2
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 34
6858: PUSH
6859: LD_INT 8
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: PPUSH
6870: CALL_OW 69
6874: IFFALSE 6887
6876: GO 6878
6878: DISABLE
// begin ru_sib_bomb := true ;
6879: LD_ADDR_EXP 4
6883: PUSH
6884: LD_INT 1
6886: ST_TO_ADDR
// end ;
6887: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6888: LD_INT 22
6890: PUSH
6891: LD_INT 3
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 34
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PPUSH
6912: CALL_OW 69
6916: IFFALSE 7015
6918: GO 6920
6920: DISABLE
6921: LD_INT 0
6923: PPUSH
// begin enable ;
6924: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6925: LD_ADDR_VAR 0 1
6929: PUSH
6930: LD_INT 1
6932: PUSH
6933: LD_INT 3
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_INT 2
6945: PPUSH
6946: CALL_OW 12
6950: ARRAY
6951: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6952: LD_INT 22
6954: PUSH
6955: LD_INT 3
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: PUSH
6962: LD_INT 30
6964: PUSH
6965: LD_INT 34
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: PUSH
6981: LD_INT 1
6983: ARRAY
6984: PPUSH
6985: LD_EXP 30
6989: PUSH
6990: LD_VAR 0 1
6994: ARRAY
6995: PPUSH
6996: LD_EXP 30
7000: PUSH
7001: LD_VAR 0 1
7005: PUSH
7006: LD_INT 1
7008: PLUS
7009: ARRAY
7010: PPUSH
7011: CALL_OW 243
// end ; end_of_file
7015: PPOPN 1
7017: END
// export function RemoveLegion ; var i ; begin
7018: LD_INT 0
7020: PPUSH
7021: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_INT 22
7029: PUSH
7030: LD_INT 8
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: PUSH
7042: FOR_IN
7043: IFFALSE 7056
// RemoveUnit ( i ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: CALL_OW 64
7054: GO 7042
7056: POP
7057: POP
// end ;
7058: LD_VAR 0 1
7062: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
7063: LD_INT 0
7065: PPUSH
7066: PPUSH
7067: PPUSH
7068: PPUSH
7069: PPUSH
7070: PPUSH
7071: PPUSH
7072: PPUSH
7073: PPUSH
7074: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
7075: LD_ADDR_VAR 0 7
7079: PUSH
7080: LD_INT 22
7082: PUSH
7083: LD_INT 8
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: PUSH
7109: LD_INT 1
7111: ARRAY
7112: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7113: LD_ADDR_VAR 0 8
7117: PUSH
7118: LD_INT 22
7120: PUSH
7121: LD_INT 8
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 30
7130: PUSH
7131: LD_INT 3
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PPUSH
7142: CALL_OW 69
7146: PUSH
7147: LD_INT 1
7149: ARRAY
7150: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7151: LD_ADDR_VAR 0 9
7155: PUSH
7156: LD_INT 22
7158: PUSH
7159: LD_INT 8
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 2
7168: PUSH
7169: LD_INT 30
7171: PUSH
7172: LD_INT 6
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: LD_INT 30
7181: PUSH
7182: LD_INT 8
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 1
7205: ARRAY
7206: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7207: LD_ADDR_VAR 0 10
7211: PUSH
7212: LD_INT 22
7214: PUSH
7215: LD_INT 8
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 30
7224: PUSH
7225: LD_INT 32
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: PPUSH
7236: CALL_OW 69
7240: ST_TO_ADDR
// uc_side := 8 ;
7241: LD_ADDR_OWVAR 20
7245: PUSH
7246: LD_INT 8
7248: ST_TO_ADDR
// uc_nation := nation_arabian ;
7249: LD_ADDR_OWVAR 21
7253: PUSH
7254: LD_INT 2
7256: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7257: LD_ADDR_EXP 32
7261: PUSH
7262: LD_INT 5
7264: PUSH
7265: LD_INT 6
7267: PUSH
7268: LD_INT 7
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: PUSH
7276: LD_OWVAR 67
7280: ARRAY
7281: ST_TO_ADDR
// legion_blist := [ ] ;
7282: LD_ADDR_EXP 34
7286: PUSH
7287: EMPTY
7288: ST_TO_ADDR
// legion_vlist := [ ] ;
7289: LD_ADDR_EXP 35
7293: PUSH
7294: EMPTY
7295: ST_TO_ADDR
// legion_force := [ ] ;
7296: LD_ADDR_EXP 31
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// legion_enemy := - 1 ;
7303: LD_ADDR_EXP 36
7307: PUSH
7308: LD_INT 1
7310: NEG
7311: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7312: LD_VAR 0 7
7316: PPUSH
7317: CALL_OW 274
7321: PPUSH
7322: LD_INT 1
7324: PPUSH
7325: LD_INT 10000
7327: PPUSH
7328: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7332: LD_VAR 0 7
7336: PPUSH
7337: CALL_OW 274
7341: PPUSH
7342: LD_INT 3
7344: PPUSH
7345: LD_INT 1000
7347: PPUSH
7348: CALL_OW 277
// for i = 1 to l_towers do
7352: LD_ADDR_VAR 0 3
7356: PUSH
7357: DOUBLE
7358: LD_INT 1
7360: DEC
7361: ST_TO_ADDR
7362: LD_VAR 0 10
7366: PUSH
7367: FOR_TO
7368: IFFALSE 7417
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7370: LD_INT 0
7372: PPUSH
7373: LD_INT 1
7375: PPUSH
7376: LD_EXP 32
7380: PPUSH
7381: CALL_OW 380
// un := CreateHuman ;
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: CALL_OW 44
7394: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_VAR 0 10
7404: PUSH
7405: LD_VAR 0 3
7409: ARRAY
7410: PPUSH
7411: CALL_OW 52
// end ;
7415: GO 7367
7417: POP
7418: POP
// for i = 1 to 4 do
7419: LD_ADDR_VAR 0 3
7423: PUSH
7424: DOUBLE
7425: LD_INT 1
7427: DEC
7428: ST_TO_ADDR
7429: LD_INT 4
7431: PUSH
7432: FOR_TO
7433: IFFALSE 7526
// for p = 1 to 2 do
7435: LD_ADDR_VAR 0 6
7439: PUSH
7440: DOUBLE
7441: LD_INT 1
7443: DEC
7444: ST_TO_ADDR
7445: LD_INT 2
7447: PUSH
7448: FOR_TO
7449: IFFALSE 7522
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7451: LD_INT 0
7453: PPUSH
7454: LD_INT 8
7456: PPUSH
7457: LD_EXP 32
7461: PPUSH
7462: CALL_OW 380
// un := CreateHuman ;
7466: LD_ADDR_VAR 0 2
7470: PUSH
7471: CALL_OW 44
7475: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_INT 22
7483: PUSH
7484: LD_INT 8
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 5
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: PUSH
7510: LD_VAR 0 6
7514: ARRAY
7515: PPUSH
7516: CALL_OW 52
// end ;
7520: GO 7448
7522: POP
7523: POP
7524: GO 7432
7526: POP
7527: POP
// for i = 1 to 4 do
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: DOUBLE
7534: LD_INT 1
7536: DEC
7537: ST_TO_ADDR
7538: LD_INT 4
7540: PUSH
7541: FOR_TO
7542: IFFALSE 7585
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7544: LD_INT 0
7546: PPUSH
7547: LD_INT 4
7549: PPUSH
7550: LD_EXP 32
7554: PPUSH
7555: CALL_OW 380
// un := CreateHuman ;
7559: LD_ADDR_VAR 0 2
7563: PUSH
7564: CALL_OW 44
7568: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7569: LD_VAR 0 2
7573: PPUSH
7574: LD_VAR 0 9
7578: PPUSH
7579: CALL_OW 52
// end ;
7583: GO 7541
7585: POP
7586: POP
// for i = 1 to 6 do
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: DOUBLE
7593: LD_INT 1
7595: DEC
7596: ST_TO_ADDR
7597: LD_INT 6
7599: PUSH
7600: FOR_TO
7601: IFFALSE 7644
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7603: LD_INT 0
7605: PPUSH
7606: LD_INT 3
7608: PPUSH
7609: LD_EXP 32
7613: PPUSH
7614: CALL_OW 380
// un := CreateHuman ;
7618: LD_ADDR_VAR 0 2
7622: PUSH
7623: CALL_OW 44
7627: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7628: LD_VAR 0 2
7632: PPUSH
7633: LD_VAR 0 8
7637: PPUSH
7638: CALL_OW 52
// end ;
7642: GO 7600
7644: POP
7645: POP
// for i = 1 to 5 do
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_INT 5
7658: PUSH
7659: FOR_TO
7660: IFFALSE 7703
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7662: LD_INT 0
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: LD_EXP 32
7672: PPUSH
7673: CALL_OW 380
// un := CreateHuman ;
7677: LD_ADDR_VAR 0 2
7681: PUSH
7682: CALL_OW 44
7686: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_VAR 0 7
7696: PPUSH
7697: CALL_OW 52
// end ;
7701: GO 7659
7703: POP
7704: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7705: LD_ADDR_VAR 0 4
7709: PUSH
7710: LD_INT 199
7712: PPUSH
7713: LD_INT 134
7715: PPUSH
7716: LD_INT 216
7718: PPUSH
7719: LD_INT 141
7721: PPUSH
7722: LD_INT 6
7724: PPUSH
7725: CALL 1562 0 5
7729: ST_TO_ADDR
// p := 1 ;
7730: LD_ADDR_VAR 0 6
7734: PUSH
7735: LD_INT 1
7737: ST_TO_ADDR
// for i = 1 to 3 do
7738: LD_ADDR_VAR 0 3
7742: PUSH
7743: DOUBLE
7744: LD_INT 1
7746: DEC
7747: ST_TO_ADDR
7748: LD_INT 3
7750: PUSH
7751: FOR_TO
7752: IFFALSE 8005
// begin vc_chassis := ar_half_tracked ;
7754: LD_ADDR_OWVAR 37
7758: PUSH
7759: LD_INT 14
7761: ST_TO_ADDR
// vc_engine := engine_siberite ;
7762: LD_ADDR_OWVAR 39
7766: PUSH
7767: LD_INT 3
7769: ST_TO_ADDR
// vc_control := control_manual ;
7770: LD_ADDR_OWVAR 38
7774: PUSH
7775: LD_INT 1
7777: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7778: LD_ADDR_OWVAR 40
7782: PUSH
7783: LD_INT 31
7785: ST_TO_ADDR
// veh := CreateVehicle ;
7786: LD_ADDR_VAR 0 5
7790: PUSH
7791: CALL_OW 45
7795: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7796: LD_VAR 0 4
7800: PUSH
7801: LD_VAR 0 6
7805: ARRAY
7806: PPUSH
7807: LD_VAR 0 4
7811: PUSH
7812: LD_VAR 0 6
7816: PUSH
7817: LD_INT 1
7819: PLUS
7820: ARRAY
7821: PPUSH
7822: CALL_OW 428
7826: PUSH
7827: LD_INT 0
7829: EQUAL
7830: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7832: LD_VAR 0 5
7836: PPUSH
7837: LD_VAR 0 4
7841: PUSH
7842: LD_VAR 0 6
7846: ARRAY
7847: PPUSH
7848: LD_VAR 0 4
7852: PUSH
7853: LD_VAR 0 6
7857: PUSH
7858: LD_INT 1
7860: PLUS
7861: ARRAY
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 48
7870: GO 7960
// begin repeat p := p + 2 ;
7872: LD_ADDR_VAR 0 6
7876: PUSH
7877: LD_VAR 0 6
7881: PUSH
7882: LD_INT 2
7884: PLUS
7885: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7886: LD_VAR 0 4
7890: PUSH
7891: LD_VAR 0 6
7895: ARRAY
7896: PPUSH
7897: LD_VAR 0 4
7901: PUSH
7902: LD_VAR 0 6
7906: PUSH
7907: LD_INT 1
7909: PLUS
7910: ARRAY
7911: PPUSH
7912: CALL_OW 428
7916: PUSH
7917: LD_INT 0
7919: EQUAL
7920: IFFALSE 7872
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7922: LD_VAR 0 5
7926: PPUSH
7927: LD_VAR 0 4
7931: PUSH
7932: LD_VAR 0 6
7936: ARRAY
7937: PPUSH
7938: LD_VAR 0 4
7942: PUSH
7943: LD_VAR 0 6
7947: PUSH
7948: LD_INT 1
7950: PLUS
7951: ARRAY
7952: PPUSH
7953: LD_INT 0
7955: PPUSH
7956: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7960: LD_INT 0
7962: PPUSH
7963: LD_INT 3
7965: PPUSH
7966: LD_EXP 32
7970: PUSH
7971: LD_INT 1
7973: PLUS
7974: PPUSH
7975: CALL_OW 380
// un := CreateHuman ;
7979: LD_ADDR_VAR 0 2
7983: PUSH
7984: CALL_OW 44
7988: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7989: LD_VAR 0 2
7993: PPUSH
7994: LD_VAR 0 5
7998: PPUSH
7999: CALL_OW 52
// end ;
8003: GO 7751
8005: POP
8006: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
8007: LD_INT 198
8009: PPUSH
8010: LD_INT 94
8012: PPUSH
8013: LD_INT 8
8015: PPUSH
8016: LD_INT 10
8018: PPUSH
8019: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
8023: LD_INT 167
8025: PPUSH
8026: LD_INT 130
8028: PPUSH
8029: LD_INT 8
8031: PPUSH
8032: LD_INT 10
8034: PPUSH
8035: CALL_OW 330
// legion_mines := [ ] ;
8039: LD_ADDR_EXP 33
8043: PUSH
8044: EMPTY
8045: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_INT 176
8053: PPUSH
8054: LD_INT 122
8056: PPUSH
8057: LD_INT 188
8059: PPUSH
8060: LD_INT 126
8062: PPUSH
8063: LD_INT 6
8065: PPUSH
8066: CALL 1562 0 5
8070: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
8071: LD_ADDR_EXP 33
8075: PUSH
8076: LD_EXP 33
8080: PUSH
8081: LD_INT 197
8083: PPUSH
8084: LD_INT 91
8086: PPUSH
8087: LD_INT 205
8089: PPUSH
8090: LD_INT 96
8092: PPUSH
8093: LD_INT 4
8095: PPUSH
8096: CALL 1562 0 5
8100: ADD
8101: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8102: LD_ADDR_EXP 33
8106: PUSH
8107: LD_EXP 33
8111: PUSH
8112: LD_INT 184
8114: PPUSH
8115: LD_INT 151
8117: PPUSH
8118: LD_INT 178
8120: PPUSH
8121: LD_INT 130
8123: PPUSH
8124: LD_INT 9
8126: PPUSH
8127: CALL 1562 0 5
8131: ADD
8132: ST_TO_ADDR
// if Difficulty > 1 then
8133: LD_OWVAR 67
8137: PUSH
8138: LD_INT 1
8140: GREATER
8141: IFFALSE 8174
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8143: LD_ADDR_EXP 33
8147: PUSH
8148: LD_EXP 33
8152: PUSH
8153: LD_INT 166
8155: PPUSH
8156: LD_INT 126
8158: PPUSH
8159: LD_INT 181
8161: PPUSH
8162: LD_INT 136
8164: PPUSH
8165: LD_INT 5
8167: PPUSH
8168: CALL 1562 0 5
8172: ADD
8173: ST_TO_ADDR
// p := 1 ;
8174: LD_ADDR_VAR 0 6
8178: PUSH
8179: LD_INT 1
8181: ST_TO_ADDR
// for i = 1 to 24 do
8182: LD_ADDR_VAR 0 3
8186: PUSH
8187: DOUBLE
8188: LD_INT 1
8190: DEC
8191: ST_TO_ADDR
8192: LD_INT 24
8194: PUSH
8195: FOR_TO
8196: IFFALSE 8250
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8198: LD_EXP 33
8202: PUSH
8203: LD_VAR 0 6
8207: ARRAY
8208: PPUSH
8209: LD_EXP 33
8213: PUSH
8214: LD_VAR 0 6
8218: PUSH
8219: LD_INT 1
8221: PLUS
8222: ARRAY
8223: PPUSH
8224: LD_INT 8
8226: PPUSH
8227: LD_INT 0
8229: PPUSH
8230: CALL_OW 454
// p := p + 2 ;
8234: LD_ADDR_VAR 0 6
8238: PUSH
8239: LD_VAR 0 6
8243: PUSH
8244: LD_INT 2
8246: PLUS
8247: ST_TO_ADDR
// end ;
8248: GO 8195
8250: POP
8251: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8252: LD_ADDR_EXP 35
8256: PUSH
8257: LD_INT 13
8259: PUSH
8260: LD_INT 3
8262: PUSH
8263: LD_INT 2
8265: PUSH
8266: LD_INT 32
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: ST_TO_ADDR
// end ;
8275: LD_VAR 0 1
8279: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8280: LD_INT 22
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: PUSH
8295: LD_INT 0
8297: GREATER
8298: IFFALSE 10484
8300: GO 8302
8302: DISABLE
8303: LD_INT 0
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
8316: PPUSH
8317: PPUSH
8318: PPUSH
8319: PPUSH
8320: PPUSH
8321: PPUSH
// begin enable ;
8322: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8323: LD_ADDR_VAR 0 8
8327: PUSH
8328: LD_INT 22
8330: PUSH
8331: LD_INT 8
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 30
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: PUSH
8348: EMPTY
8349: LIST
8350: LIST
8351: PPUSH
8352: CALL_OW 69
8356: PUSH
8357: LD_INT 1
8359: ARRAY
8360: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8361: LD_ADDR_VAR 0 9
8365: PUSH
8366: LD_INT 22
8368: PUSH
8369: LD_INT 8
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: LD_INT 30
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PPUSH
8390: CALL_OW 69
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8399: LD_ADDR_VAR 0 10
8403: PUSH
8404: LD_INT 22
8406: PUSH
8407: LD_INT 8
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 2
8416: PUSH
8417: LD_INT 30
8419: PUSH
8420: LD_INT 6
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: LD_INT 30
8429: PUSH
8430: LD_INT 8
8432: PUSH
8433: EMPTY
8434: LIST
8435: LIST
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PPUSH
8446: CALL_OW 69
8450: PUSH
8451: LD_INT 1
8453: ARRAY
8454: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8455: LD_ADDR_VAR 0 11
8459: PUSH
8460: LD_INT 22
8462: PUSH
8463: LD_INT 8
8465: PUSH
8466: EMPTY
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 30
8472: PUSH
8473: LD_INT 32
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PPUSH
8484: CALL_OW 69
8488: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8489: LD_ADDR_VAR 0 16
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 8
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 25
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8523: LD_ADDR_VAR 0 15
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 8
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PUSH
8538: LD_INT 25
8540: PUSH
8541: LD_INT 1
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PPUSH
8552: CALL_OW 69
8556: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8557: LD_ADDR_VAR 0 14
8561: PUSH
8562: LD_INT 22
8564: PUSH
8565: LD_INT 8
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: PUSH
8572: LD_INT 25
8574: PUSH
8575: LD_INT 3
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PPUSH
8586: CALL_OW 69
8590: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8591: LD_ADDR_VAR 0 13
8595: PUSH
8596: LD_INT 22
8598: PUSH
8599: LD_INT 8
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 25
8608: PUSH
8609: LD_INT 4
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PPUSH
8620: CALL_OW 69
8624: ST_TO_ADDR
// if l_eng then
8625: LD_VAR 0 16
8629: IFFALSE 9044
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8631: LD_ADDR_VAR 0 5
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 21
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8665: LD_VAR 0 5
8669: PPUSH
8670: LD_INT 3
8672: PUSH
8673: LD_INT 24
8675: PUSH
8676: LD_INT 1000
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PPUSH
8687: CALL_OW 72
8691: PUSH
8692: LD_INT 0
8694: GREATER
8695: IFFALSE 8829
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8697: LD_ADDR_VAR 0 3
8701: PUSH
8702: LD_VAR 0 5
8706: PPUSH
8707: LD_INT 3
8709: PUSH
8710: LD_INT 24
8712: PUSH
8713: LD_INT 1000
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PPUSH
8724: CALL_OW 72
8728: ST_TO_ADDR
// for i = 1 to l_eng do
8729: LD_ADDR_VAR 0 2
8733: PUSH
8734: DOUBLE
8735: LD_INT 1
8737: DEC
8738: ST_TO_ADDR
8739: LD_VAR 0 16
8743: PUSH
8744: FOR_TO
8745: IFFALSE 8825
// if IsInUnit ( l_eng [ i ] ) then
8747: LD_VAR 0 16
8751: PUSH
8752: LD_VAR 0 2
8756: ARRAY
8757: PPUSH
8758: CALL_OW 310
8762: IFFALSE 8781
// ComExitBuilding ( l_eng [ i ] ) else
8764: LD_VAR 0 16
8768: PUSH
8769: LD_VAR 0 2
8773: ARRAY
8774: PPUSH
8775: CALL_OW 122
8779: GO 8823
// if not HasTask ( l_eng [ i ] ) then
8781: LD_VAR 0 16
8785: PUSH
8786: LD_VAR 0 2
8790: ARRAY
8791: PPUSH
8792: CALL_OW 314
8796: NOT
8797: IFFALSE 8823
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8799: LD_VAR 0 16
8803: PUSH
8804: LD_VAR 0 2
8808: ARRAY
8809: PPUSH
8810: LD_VAR 0 3
8814: PUSH
8815: LD_INT 1
8817: ARRAY
8818: PPUSH
8819: CALL_OW 130
8823: GO 8744
8825: POP
8826: POP
// end else
8827: GO 9044
// begin if legion_blist > 0 then
8829: LD_EXP 34
8833: PUSH
8834: LD_INT 0
8836: GREATER
8837: IFFALSE 8966
// begin for i = 1 to l_eng do
8839: LD_ADDR_VAR 0 2
8843: PUSH
8844: DOUBLE
8845: LD_INT 1
8847: DEC
8848: ST_TO_ADDR
8849: LD_VAR 0 16
8853: PUSH
8854: FOR_TO
8855: IFFALSE 8962
// if IsInUnit ( l_eng [ i ] ) then
8857: LD_VAR 0 16
8861: PUSH
8862: LD_VAR 0 2
8866: ARRAY
8867: PPUSH
8868: CALL_OW 310
8872: IFFALSE 8891
// ComExitBuilding ( l_eng [ i ] ) else
8874: LD_VAR 0 16
8878: PUSH
8879: LD_VAR 0 2
8883: ARRAY
8884: PPUSH
8885: CALL_OW 122
8889: GO 8960
// if not HasTask ( l_eng [ i ] ) then
8891: LD_VAR 0 16
8895: PUSH
8896: LD_VAR 0 2
8900: ARRAY
8901: PPUSH
8902: CALL_OW 314
8906: NOT
8907: IFFALSE 8960
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8909: LD_VAR 0 16
8913: PUSH
8914: LD_VAR 0 2
8918: ARRAY
8919: PPUSH
8920: LD_EXP 34
8924: PUSH
8925: LD_INT 1
8927: ARRAY
8928: PPUSH
8929: LD_EXP 34
8933: PUSH
8934: LD_INT 2
8936: ARRAY
8937: PPUSH
8938: LD_EXP 34
8942: PUSH
8943: LD_INT 3
8945: ARRAY
8946: PPUSH
8947: LD_EXP 34
8951: PUSH
8952: LD_INT 4
8954: ARRAY
8955: PPUSH
8956: CALL_OW 145
8960: GO 8854
8962: POP
8963: POP
// end else
8964: GO 9044
// for i = 1 to l_eng do
8966: LD_ADDR_VAR 0 2
8970: PUSH
8971: DOUBLE
8972: LD_INT 1
8974: DEC
8975: ST_TO_ADDR
8976: LD_VAR 0 16
8980: PUSH
8981: FOR_TO
8982: IFFALSE 9042
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8984: LD_VAR 0 16
8988: PUSH
8989: LD_VAR 0 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 310
8999: NOT
9000: PUSH
9001: LD_VAR 0 16
9005: PUSH
9006: LD_VAR 0 2
9010: ARRAY
9011: PPUSH
9012: CALL_OW 314
9016: NOT
9017: AND
9018: IFFALSE 9040
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
9020: LD_VAR 0 16
9024: PUSH
9025: LD_VAR 0 2
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 8
9035: PPUSH
9036: CALL_OW 120
9040: GO 8981
9042: POP
9043: POP
// end ; end ; if l_factory then
9044: LD_VAR 0 9
9048: IFFALSE 9448
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
9050: LD_INT 22
9052: PUSH
9053: LD_INT 8
9055: PUSH
9056: EMPTY
9057: LIST
9058: LIST
9059: PUSH
9060: LD_INT 33
9062: PUSH
9063: LD_INT 2
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PUSH
9070: LD_INT 3
9072: PUSH
9073: LD_INT 61
9075: PUSH
9076: EMPTY
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: PUSH
9093: LD_INT 0
9095: GREATER
9096: PUSH
9097: LD_INT 22
9099: PUSH
9100: LD_INT 8
9102: PUSH
9103: EMPTY
9104: LIST
9105: LIST
9106: PUSH
9107: LD_INT 34
9109: PUSH
9110: LD_INT 31
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PPUSH
9121: CALL_OW 69
9125: PUSH
9126: LD_INT 0
9128: GREATER
9129: AND
9130: IFFALSE 9250
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9132: LD_INT 22
9134: PUSH
9135: LD_INT 8
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: PUSH
9142: LD_INT 33
9144: PUSH
9145: LD_INT 2
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: LD_INT 61
9157: PUSH
9158: EMPTY
9159: LIST
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PUSH
9165: EMPTY
9166: LIST
9167: LIST
9168: LIST
9169: PPUSH
9170: CALL_OW 69
9174: PUSH
9175: LD_INT 1
9177: ARRAY
9178: PPUSH
9179: LD_INT 22
9181: PUSH
9182: LD_INT 8
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PUSH
9189: LD_INT 34
9191: PUSH
9192: LD_INT 31
9194: PUSH
9195: EMPTY
9196: LIST
9197: LIST
9198: PUSH
9199: EMPTY
9200: LIST
9201: LIST
9202: PPUSH
9203: CALL_OW 69
9207: PUSH
9208: LD_INT 1
9210: PPUSH
9211: LD_INT 22
9213: PUSH
9214: LD_INT 8
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: LD_INT 34
9223: PUSH
9224: LD_INT 31
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL_OW 69
9239: PPUSH
9240: CALL_OW 12
9244: ARRAY
9245: PPUSH
9246: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9250: LD_EXP 35
9254: PUSH
9255: LD_INT 0
9257: GREATER
9258: PUSH
9259: LD_VAR 0 9
9263: PPUSH
9264: CALL_OW 461
9268: PUSH
9269: LD_INT 2
9271: EQUAL
9272: AND
9273: IFFALSE 9358
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9275: LD_VAR 0 9
9279: PPUSH
9280: LD_EXP 35
9284: PUSH
9285: LD_INT 1
9287: ARRAY
9288: PPUSH
9289: LD_EXP 35
9293: PUSH
9294: LD_INT 2
9296: ARRAY
9297: PPUSH
9298: LD_EXP 35
9302: PUSH
9303: LD_INT 3
9305: ARRAY
9306: PPUSH
9307: LD_EXP 35
9311: PUSH
9312: LD_INT 4
9314: ARRAY
9315: PPUSH
9316: CALL_OW 125
// for i = 1 to 4 do
9320: LD_ADDR_VAR 0 2
9324: PUSH
9325: DOUBLE
9326: LD_INT 1
9328: DEC
9329: ST_TO_ADDR
9330: LD_INT 4
9332: PUSH
9333: FOR_TO
9334: IFFALSE 9356
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9336: LD_ADDR_EXP 35
9340: PUSH
9341: LD_EXP 35
9345: PPUSH
9346: LD_INT 1
9348: PPUSH
9349: CALL_OW 3
9353: ST_TO_ADDR
9354: GO 9333
9356: POP
9357: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9358: LD_VAR 0 11
9362: PPUSH
9363: LD_INT 35
9365: PUSH
9366: LD_INT 0
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: PPUSH
9373: CALL_OW 72
9377: PUSH
9378: LD_INT 0
9380: GREATER
9381: PUSH
9382: LD_VAR 0 9
9386: PPUSH
9387: CALL_OW 461
9391: PUSH
9392: LD_INT 2
9394: EQUAL
9395: AND
9396: IFFALSE 9448
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9398: LD_VAR 0 11
9402: PPUSH
9403: LD_INT 35
9405: PUSH
9406: LD_INT 0
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 72
9417: PUSH
9418: LD_INT 1
9420: ARRAY
9421: PPUSH
9422: LD_INT 28
9424: PUSH
9425: LD_INT 27
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: LD_INT 1
9434: PPUSH
9435: LD_INT 2
9437: PPUSH
9438: CALL_OW 12
9442: ARRAY
9443: PPUSH
9444: CALL_OW 148
// end ; if legion_enemy > 0 then
9448: LD_EXP 36
9452: PUSH
9453: LD_INT 0
9455: GREATER
9456: IFFALSE 10036
// begin if tick mod 11 11$00 = 0 then
9458: LD_OWVAR 1
9462: PUSH
9463: LD_INT 23100
9465: MOD
9466: PUSH
9467: LD_INT 0
9469: EQUAL
9470: IFFALSE 9720
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9472: LD_ADDR_EXP 35
9476: PUSH
9477: LD_EXP 35
9481: PUSH
9482: LD_INT 13
9484: PUSH
9485: LD_INT 1
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: LIST
9495: ADD
9496: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9497: LD_ADDR_EXP 35
9501: PUSH
9502: LD_EXP 35
9506: PUSH
9507: LD_INT 28
9509: PUSH
9510: LD_INT 27
9512: PUSH
9513: LD_INT 29
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: PUSH
9521: LD_INT 1
9523: PPUSH
9524: LD_INT 3
9526: PPUSH
9527: CALL_OW 12
9531: ARRAY
9532: ADD
9533: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9534: LD_ADDR_EXP 35
9538: PUSH
9539: LD_EXP 35
9543: PUSH
9544: LD_INT 13
9546: PUSH
9547: LD_INT 1
9549: PUSH
9550: LD_INT 2
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: ADD
9558: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9559: LD_ADDR_EXP 35
9563: PUSH
9564: LD_EXP 35
9568: PUSH
9569: LD_INT 28
9571: PUSH
9572: LD_INT 27
9574: PUSH
9575: LD_INT 29
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 1
9585: PPUSH
9586: LD_INT 3
9588: PPUSH
9589: CALL_OW 12
9593: ARRAY
9594: ADD
9595: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9596: LD_ADDR_EXP 35
9600: PUSH
9601: LD_EXP 35
9605: PUSH
9606: LD_INT 13
9608: PUSH
9609: LD_INT 1
9611: PUSH
9612: LD_INT 2
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: ADD
9620: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9621: LD_ADDR_EXP 35
9625: PUSH
9626: LD_EXP 35
9630: PUSH
9631: LD_INT 28
9633: PUSH
9634: LD_INT 27
9636: PUSH
9637: LD_INT 29
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_INT 1
9647: PPUSH
9648: LD_INT 3
9650: PPUSH
9651: CALL_OW 12
9655: ARRAY
9656: ADD
9657: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9658: LD_ADDR_EXP 35
9662: PUSH
9663: LD_EXP 35
9667: PUSH
9668: LD_INT 13
9670: PUSH
9671: LD_INT 1
9673: PUSH
9674: LD_INT 2
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: ADD
9682: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9683: LD_ADDR_EXP 35
9687: PUSH
9688: LD_EXP 35
9692: PUSH
9693: LD_INT 28
9695: PUSH
9696: LD_INT 27
9698: PUSH
9699: LD_INT 29
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 3
9712: PPUSH
9713: CALL_OW 12
9717: ARRAY
9718: ADD
9719: ST_TO_ADDR
// end ; if legion_force >= 7 then
9720: LD_EXP 31
9724: PUSH
9725: LD_INT 7
9727: GREATEREQUAL
9728: IFFALSE 9911
// begin for i = 1 to legion_force do
9730: LD_ADDR_VAR 0 2
9734: PUSH
9735: DOUBLE
9736: LD_INT 1
9738: DEC
9739: ST_TO_ADDR
9740: LD_EXP 31
9744: PUSH
9745: FOR_TO
9746: IFFALSE 9909
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9748: LD_EXP 31
9752: PUSH
9753: LD_VAR 0 2
9757: ARRAY
9758: PPUSH
9759: CALL_OW 314
9763: NOT
9764: PUSH
9765: LD_EXP 31
9769: PUSH
9770: LD_VAR 0 2
9774: ARRAY
9775: PPUSH
9776: CALL_OW 110
9780: PUSH
9781: LD_INT 11
9783: NONEQUAL
9784: AND
9785: IFFALSE 9907
// begin case legion_enemy of 1 :
9787: LD_EXP 36
9791: PUSH
9792: LD_INT 1
9794: DOUBLE
9795: EQUAL
9796: IFTRUE 9800
9798: GO 9824
9800: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9801: LD_EXP 31
9805: PUSH
9806: LD_VAR 0 2
9810: ARRAY
9811: PPUSH
9812: LD_INT 142
9814: PPUSH
9815: LD_INT 144
9817: PPUSH
9818: CALL_OW 111
9822: GO 9889
9824: LD_INT 2
9826: DOUBLE
9827: EQUAL
9828: IFTRUE 9832
9830: GO 9856
9832: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9833: LD_EXP 31
9837: PUSH
9838: LD_VAR 0 2
9842: ARRAY
9843: PPUSH
9844: LD_INT 101
9846: PPUSH
9847: LD_INT 34
9849: PPUSH
9850: CALL_OW 111
9854: GO 9889
9856: LD_INT 7
9858: DOUBLE
9859: EQUAL
9860: IFTRUE 9864
9862: GO 9888
9864: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9865: LD_EXP 31
9869: PUSH
9870: LD_VAR 0 2
9874: ARRAY
9875: PPUSH
9876: LD_INT 173
9878: PPUSH
9879: LD_INT 127
9881: PPUSH
9882: CALL_OW 111
9886: GO 9889
9888: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9889: LD_EXP 31
9893: PUSH
9894: LD_VAR 0 2
9898: ARRAY
9899: PPUSH
9900: LD_INT 11
9902: PPUSH
9903: CALL_OW 109
// end ; end ;
9907: GO 9745
9909: POP
9910: POP
// end ; if legion_force then
9911: LD_EXP 31
9915: IFFALSE 10036
// begin tmp := legion_force ;
9917: LD_ADDR_VAR 0 3
9921: PUSH
9922: LD_EXP 31
9926: ST_TO_ADDR
// for i = 1 to tmp do
9927: LD_ADDR_VAR 0 2
9931: PUSH
9932: DOUBLE
9933: LD_INT 1
9935: DEC
9936: ST_TO_ADDR
9937: LD_VAR 0 3
9941: PUSH
9942: FOR_TO
9943: IFFALSE 10034
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9945: LD_VAR 0 3
9949: PUSH
9950: LD_VAR 0 2
9954: ARRAY
9955: PPUSH
9956: CALL_OW 314
9960: NOT
9961: PUSH
9962: LD_EXP 31
9966: PUSH
9967: LD_VAR 0 2
9971: ARRAY
9972: PPUSH
9973: CALL_OW 110
9977: PUSH
9978: LD_INT 11
9980: EQUAL
9981: AND
9982: IFFALSE 10032
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9984: LD_VAR 0 3
9988: PUSH
9989: LD_VAR 0 2
9993: ARRAY
9994: PPUSH
9995: LD_INT 22
9997: PUSH
9998: LD_EXP 36
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PPUSH
10007: CALL_OW 69
10011: PPUSH
10012: LD_VAR 0 3
10016: PUSH
10017: LD_VAR 0 2
10021: ARRAY
10022: PPUSH
10023: CALL_OW 74
10027: PPUSH
10028: CALL_OW 115
10032: GO 9942
10034: POP
10035: POP
// end ; end ; p := 1 ;
10036: LD_ADDR_VAR 0 6
10040: PUSH
10041: LD_INT 1
10043: ST_TO_ADDR
// for i = 1 to 24 do
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: DOUBLE
10050: LD_INT 1
10052: DEC
10053: ST_TO_ADDR
10054: LD_INT 24
10056: PUSH
10057: FOR_TO
10058: IFFALSE 10188
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10060: LD_EXP 33
10064: PUSH
10065: LD_VAR 0 6
10069: ARRAY
10070: PPUSH
10071: LD_EXP 33
10075: PUSH
10076: LD_VAR 0 6
10080: PUSH
10081: LD_INT 1
10083: PLUS
10084: ARRAY
10085: PPUSH
10086: CALL_OW 428
10090: PUSH
10091: LD_INT 0
10093: GREATER
10094: IFFALSE 10172
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10096: LD_EXP 33
10100: PUSH
10101: LD_VAR 0 6
10105: ARRAY
10106: PPUSH
10107: LD_EXP 33
10111: PUSH
10112: LD_VAR 0 6
10116: PUSH
10117: LD_INT 1
10119: PLUS
10120: ARRAY
10121: PPUSH
10122: CALL_OW 428
10126: PPUSH
10127: CALL_OW 255
10131: PUSH
10132: LD_EXP 36
10136: EQUAL
10137: IFFALSE 10172
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10139: LD_EXP 33
10143: PUSH
10144: LD_VAR 0 6
10148: ARRAY
10149: PPUSH
10150: LD_EXP 33
10154: PUSH
10155: LD_VAR 0 6
10159: PUSH
10160: LD_INT 1
10162: PLUS
10163: ARRAY
10164: PPUSH
10165: LD_INT 8
10167: PPUSH
10168: CALL_OW 456
// p := p + 2 ;
10172: LD_ADDR_VAR 0 6
10176: PUSH
10177: LD_VAR 0 6
10181: PUSH
10182: LD_INT 2
10184: PLUS
10185: ST_TO_ADDR
// end ;
10186: GO 10057
10188: POP
10189: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10190: LD_INT 22
10192: PUSH
10193: LD_INT 8
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: LD_INT 32
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PPUSH
10214: CALL_OW 69
10218: IFFALSE 10332
// begin if l_cargo = false then
10220: LD_VAR 0 17
10224: PUSH
10225: LD_INT 0
10227: EQUAL
10228: IFFALSE 10264
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10230: LD_ADDR_VAR 0 17
10234: PUSH
10235: LD_INT 22
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 34
10247: PUSH
10248: LD_INT 32
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 69
10263: ST_TO_ADDR
// if l_cargo then
10264: LD_VAR 0 17
10268: IFFALSE 10332
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10270: LD_ADDR_VAR 0 7
10274: PUSH
10275: LD_INT 14
10277: PPUSH
10278: CALL_OW 435
10282: ST_TO_ADDR
// if cr > 0 then
10283: LD_VAR 0 7
10287: PUSH
10288: LD_INT 0
10290: GREATER
10291: IFFALSE 10332
// if not HasTask ( l_cargo ) then
10293: LD_VAR 0 17
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10332
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10305: LD_VAR 0 17
10309: PPUSH
10310: LD_VAR 0 7
10314: PUSH
10315: LD_INT 1
10317: ARRAY
10318: PPUSH
10319: LD_VAR 0 7
10323: PUSH
10324: LD_INT 2
10326: ARRAY
10327: PPUSH
10328: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10332: LD_OWVAR 1
10336: PUSH
10337: LD_INT 52500
10339: PUSH
10340: LD_INT 46200
10342: PUSH
10343: LD_INT 42000
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_OWVAR 67
10355: ARRAY
10356: EQUAL
10357: PUSH
10358: LD_INT 1
10360: PPUSH
10361: CALL_OW 469
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PUSH
10370: LD_INT 112
10372: EQUAL
10373: AND
10374: PUSH
10375: LD_INT 1
10377: PPUSH
10378: CALL_OW 469
10382: PUSH
10383: LD_INT 2
10385: ARRAY
10386: PUSH
10387: LD_INT 67
10389: EQUAL
10390: AND
10391: IFFALSE 10484
// begin un := l_eng [ 1 ] ;
10393: LD_ADDR_VAR 0 1
10397: PUSH
10398: LD_VAR 0 16
10402: PUSH
10403: LD_INT 1
10405: ARRAY
10406: ST_TO_ADDR
// if IsInUnit ( un ) then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 310
10416: IFFALSE 10427
// ComExitBuilding ( un ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10427: LD_VAR 0 1
10431: PPUSH
10432: LD_INT 1
10434: PPUSH
10435: CALL_OW 469
10439: PUSH
10440: LD_INT 1
10442: ARRAY
10443: PPUSH
10444: LD_INT 1
10446: PPUSH
10447: CALL_OW 469
10451: PUSH
10452: LD_INT 2
10454: ARRAY
10455: PPUSH
10456: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_INT 207
10467: PPUSH
10468: LD_INT 123
10470: PPUSH
10471: CALL_OW 171
// AddComUnload ( un ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 219
// end ; end ;
10484: PPOPN 17
10486: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10487: LD_OWVAR 67
10491: PUSH
10492: LD_INT 1
10494: GREATER
10495: IFFALSE 10700
10497: GO 10499
10499: DISABLE
10500: LD_INT 0
10502: PPUSH
10503: PPUSH
10504: PPUSH
10505: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10506: LD_INT 35
10508: PPUSH
10509: LD_INT 12635
10511: PPUSH
10512: CALL_OW 12
10516: PPUSH
10517: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10521: LD_ADDR_VAR 0 2
10525: PUSH
10526: LD_INT 22
10528: PUSH
10529: LD_INT 8
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: PUSH
10536: LD_INT 25
10538: PUSH
10539: LD_INT 4
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: ST_TO_ADDR
// p := 1 ;
10555: LD_ADDR_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10563: LD_ADDR_VAR 0 3
10567: PUSH
10568: LD_INT 116
10570: PUSH
10571: LD_INT 139
10573: PUSH
10574: LD_INT 69
10576: PUSH
10577: LD_INT 13
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: ST_TO_ADDR
// for i = 1 to 2 do
10586: LD_ADDR_VAR 0 1
10590: PUSH
10591: DOUBLE
10592: LD_INT 1
10594: DEC
10595: ST_TO_ADDR
10596: LD_INT 2
10598: PUSH
10599: FOR_TO
10600: IFFALSE 10698
// begin if IsInUnit ( sci [ i ] ) then
10602: LD_VAR 0 2
10606: PUSH
10607: LD_VAR 0 1
10611: ARRAY
10612: PPUSH
10613: CALL_OW 310
10617: IFFALSE 10634
// ComExitBuilding ( sci [ i ] ) ;
10619: LD_VAR 0 2
10623: PUSH
10624: LD_VAR 0 1
10628: ARRAY
10629: PPUSH
10630: CALL_OW 122
// Wait ( 0 0$03 ) ;
10634: LD_INT 105
10636: PPUSH
10637: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10641: LD_VAR 0 2
10645: PUSH
10646: LD_VAR 0 1
10650: ARRAY
10651: PPUSH
10652: LD_VAR 0 3
10656: PUSH
10657: LD_VAR 0 4
10661: ARRAY
10662: PPUSH
10663: LD_VAR 0 3
10667: PUSH
10668: LD_VAR 0 4
10672: PUSH
10673: LD_INT 1
10675: PLUS
10676: ARRAY
10677: PPUSH
10678: CALL_OW 158
// p := p + 2 ;
10682: LD_ADDR_VAR 0 4
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: LD_INT 2
10694: PLUS
10695: ST_TO_ADDR
// end ;
10696: GO 10599
10698: POP
10699: POP
// end ;
10700: PPOPN 4
10702: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10703: LD_INT 14
10705: PPUSH
10706: CALL_OW 435
10710: PUSH
10711: LD_INT 20
10713: LESS
10714: IFFALSE 10741
10716: GO 10718
10718: DISABLE
// begin enable ;
10719: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10720: LD_INT 1
10722: PPUSH
10723: LD_INT 5
10725: PPUSH
10726: CALL_OW 12
10730: PPUSH
10731: LD_INT 14
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 55
// end ; end_of_file
10741: END
// export function Action ; var un , gamemode , speaker ; begin
10742: LD_INT 0
10744: PPUSH
10745: PPUSH
10746: PPUSH
10747: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
10748: LD_ADDR_OWVAR 67
10752: PUSH
10753: LD_INT 0
10755: PPUSH
10756: CALL_OW 426
10760: ST_TO_ADDR
// gamemode := GetMultiplayerSetting ( 1 ) ;
10761: LD_ADDR_VAR 0 3
10765: PUSH
10766: LD_INT 1
10768: PPUSH
10769: CALL_OW 426
10773: ST_TO_ADDR
// if gamemode = 1 then
10774: LD_VAR 0 3
10778: PUSH
10779: LD_INT 1
10781: EQUAL
10782: IFFALSE 10806
// begin your_side := 1 ;
10784: LD_ADDR_OWVAR 2
10788: PUSH
10789: LD_INT 1
10791: ST_TO_ADDR
// legion_enemy := 1 ;
10792: LD_ADDR_EXP 36
10796: PUSH
10797: LD_INT 1
10799: ST_TO_ADDR
// PrepareAmerican ;
10800: CALL 221 0 0
// end else
10804: GO 10858
// if gamemode = 2 then
10806: LD_VAR 0 3
10810: PUSH
10811: LD_INT 2
10813: EQUAL
10814: IFFALSE 10838
// begin your_side := 2 ;
10816: LD_ADDR_OWVAR 2
10820: PUSH
10821: LD_INT 2
10823: ST_TO_ADDR
// legion_enemy := 2 ;
10824: LD_ADDR_EXP 36
10828: PUSH
10829: LD_INT 2
10831: ST_TO_ADDR
// PrepareArabian ;
10832: CALL 18169 0 0
// end else
10836: GO 10858
// begin your_side := 7 ;
10838: LD_ADDR_OWVAR 2
10842: PUSH
10843: LD_INT 7
10845: ST_TO_ADDR
// legion_enemy := 7 ;
10846: LD_ADDR_EXP 36
10850: PUSH
10851: LD_INT 7
10853: ST_TO_ADDR
// PrepareAlliance ;
10854: CALL 15580 0 0
// end ; if your_side = 1 then
10858: LD_OWVAR 2
10862: PUSH
10863: LD_INT 1
10865: EQUAL
10866: IFFALSE 11344
// begin case Query ( QVul4 ) of 1 :
10868: LD_STRING QVul4
10870: PPUSH
10871: CALL_OW 97
10875: PUSH
10876: LD_INT 1
10878: DOUBLE
10879: EQUAL
10880: IFTRUE 10884
10882: GO 10887
10884: POP
// ; end ;
10885: GO 10888
10887: POP
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10892: LD_INT 8
10894: PPUSH
10895: LD_INT 5
10897: PPUSH
10898: CALL_OW 86
// uc_side := 4 ;
10902: LD_ADDR_OWVAR 20
10906: PUSH
10907: LD_INT 4
10909: ST_TO_ADDR
// uc_nation := 1 ;
10910: LD_ADDR_OWVAR 21
10914: PUSH
10915: LD_INT 1
10917: ST_TO_ADDR
// hc_importance := 0 ;
10918: LD_ADDR_OWVAR 32
10922: PUSH
10923: LD_INT 0
10925: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10926: LD_INT 1
10928: PPUSH
10929: LD_INT 3
10931: PPUSH
10932: LD_EXP 21
10936: PPUSH
10937: CALL_OW 380
// un := CreateHuman ;
10941: LD_ADDR_VAR 0 2
10945: PUSH
10946: CALL_OW 44
10950: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10951: LD_VAR 0 2
10955: PPUSH
10956: LD_INT 12
10958: PPUSH
10959: LD_INT 9
10961: PPUSH
10962: LD_INT 0
10964: PPUSH
10965: CALL_OW 48
// hc_name := Stuart Carey ;
10969: LD_ADDR_OWVAR 26
10973: PUSH
10974: LD_STRING Stuart Carey
10976: ST_TO_ADDR
// hc_class := 1 ;
10977: LD_ADDR_OWVAR 28
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// hc_gallery := vulcano ;
10985: LD_ADDR_OWVAR 33
10989: PUSH
10990: LD_STRING vulcano
10992: ST_TO_ADDR
// hc_face_number := 1 ;
10993: LD_ADDR_OWVAR 34
10997: PUSH
10998: LD_INT 1
11000: ST_TO_ADDR
// us_guy := CreateHuman ;
11001: LD_ADDR_EXP 22
11005: PUSH
11006: CALL_OW 44
11010: ST_TO_ADDR
// InitHc ;
11011: CALL_OW 19
// if rand ( 0 , 1 ) then
11015: LD_INT 0
11017: PPUSH
11018: LD_INT 1
11020: PPUSH
11021: CALL_OW 12
11025: IFFALSE 11042
// PrepareHuman ( sex_male , 3 , 6 ) else
11027: LD_INT 1
11029: PPUSH
11030: LD_INT 3
11032: PPUSH
11033: LD_INT 6
11035: PPUSH
11036: CALL_OW 380
11040: GO 11055
// PrepareHuman ( sex_female , 4 , 8 ) ;
11042: LD_INT 2
11044: PPUSH
11045: LD_INT 4
11047: PPUSH
11048: LD_INT 8
11050: PPUSH
11051: CALL_OW 380
// ComTurnUnit ( un , us_commander ) ;
11055: LD_VAR 0 2
11059: PPUSH
11060: LD_EXP 19
11064: PPUSH
11065: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11069: LD_EXP 19
11073: PPUSH
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 119
// if GetSex ( un ) = sex_male then
11083: LD_VAR 0 2
11087: PPUSH
11088: CALL_OW 258
11092: PUSH
11093: LD_INT 1
11095: EQUAL
11096: IFFALSE 11179
// begin Say ( un , VD-un1 ) ;
11098: LD_VAR 0 2
11102: PPUSH
11103: LD_STRING VD-un1
11105: PPUSH
11106: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11110: LD_EXP 19
11114: PPUSH
11115: LD_STRING VDc-1
11117: PPUSH
11118: CALL_OW 88
// Say ( un , VD-un2 ) ;
11122: LD_VAR 0 2
11126: PPUSH
11127: LD_STRING VD-un2
11129: PPUSH
11130: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11134: LD_EXP 19
11138: PPUSH
11139: LD_STRING VDc-2
11141: PPUSH
11142: CALL_OW 88
// Say ( un , VD-un3 ) ;
11146: LD_VAR 0 2
11150: PPUSH
11151: LD_STRING VD-un3
11153: PPUSH
11154: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11158: LD_INT 7
11160: PPUSH
11161: CALL_OW 67
// Say ( un , VD-un4 ) ;
11165: LD_VAR 0 2
11169: PPUSH
11170: LD_STRING VD-un4
11172: PPUSH
11173: CALL_OW 88
// end else
11177: GO 11258
// begin Say ( un , VD-unf1 ) ;
11179: LD_VAR 0 2
11183: PPUSH
11184: LD_STRING VD-unf1
11186: PPUSH
11187: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11191: LD_EXP 19
11195: PPUSH
11196: LD_STRING VDc-1
11198: PPUSH
11199: CALL_OW 88
// Say ( un , VD-unf2 ) ;
11203: LD_VAR 0 2
11207: PPUSH
11208: LD_STRING VD-unf2
11210: PPUSH
11211: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11215: LD_EXP 19
11219: PPUSH
11220: LD_STRING VDc-2
11222: PPUSH
11223: CALL_OW 88
// Say ( un , VD-unf3 ) ;
11227: LD_VAR 0 2
11231: PPUSH
11232: LD_STRING VD-unf3
11234: PPUSH
11235: CALL_OW 88
// wait ( 0 0$0.2 ) ;
11239: LD_INT 7
11241: PPUSH
11242: CALL_OW 67
// Say ( un , VD-unf4 ) ;
11246: LD_VAR 0 2
11250: PPUSH
11251: LD_STRING VD-unf4
11253: PPUSH
11254: CALL_OW 88
// end ; ComMoveXY ( un , 2 , 2 ) ;
11258: LD_VAR 0 2
11262: PPUSH
11263: LD_INT 2
11265: PPUSH
11266: LD_INT 2
11268: PPUSH
11269: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11273: LD_EXP 19
11277: PPUSH
11278: LD_STRING VDc-3
11280: PPUSH
11281: CALL_OW 88
// InGameOff ;
11285: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11289: LD_STRING CVulc1
11291: PPUSH
11292: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11303: LD_VAR 0 2
11307: PPUSH
11308: CALL_OW 250
11312: PUSH
11313: LD_INT 2
11315: EQUAL
11316: PUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PUSH
11327: LD_INT 2
11329: EQUAL
11330: AND
11331: IFFALSE 11296
// RemoveUnit ( un ) ;
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 64
// end else
11342: GO 11721
// if your_side = 2 then
11344: LD_OWVAR 2
11348: PUSH
11349: LD_INT 2
11351: EQUAL
11352: IFFALSE 11568
// begin CenterNowOnUnits ( player_commander ) ;
11354: LD_EXP 10
11358: PPUSH
11359: CALL_OW 87
// speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_commander ;
11363: LD_ADDR_VAR 0 4
11367: PUSH
11368: LD_INT 22
11370: PUSH
11371: LD_INT 2
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: LD_INT 21
11380: PUSH
11381: LD_INT 1
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: PPUSH
11392: CALL_OW 69
11396: PUSH
11397: LD_EXP 51
11401: DIFF
11402: ST_TO_ADDR
// if speaker then
11403: LD_VAR 0 4
11407: IFFALSE 11559
// begin InGameOn ;
11409: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11413: LD_EXP 51
11417: PPUSH
11418: LD_STRING VSd-1
11420: PPUSH
11421: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11425: LD_VAR 0 4
11429: PUSH
11430: LD_INT 1
11432: ARRAY
11433: PPUSH
11434: CALL_OW 258
11438: PUSH
11439: LD_INT 1
11441: EQUAL
11442: IFFALSE 11462
// Say ( speaker [ 1 ] , VAd-1 ) else
11444: LD_VAR 0 4
11448: PUSH
11449: LD_INT 1
11451: ARRAY
11452: PPUSH
11453: LD_STRING VAd-1
11455: PPUSH
11456: CALL_OW 88
11460: GO 11478
// Say ( speaker [ 1 ] , VAfd-1 ) ;
11462: LD_VAR 0 4
11466: PUSH
11467: LD_INT 1
11469: ARRAY
11470: PPUSH
11471: LD_STRING VAfd-1
11473: PPUSH
11474: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11478: LD_EXP 51
11482: PPUSH
11483: LD_STRING VSd-2
11485: PPUSH
11486: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
11490: LD_VAR 0 4
11494: PUSH
11495: LD_INT 1
11497: ARRAY
11498: PPUSH
11499: CALL_OW 258
11503: PUSH
11504: LD_INT 1
11506: EQUAL
11507: IFFALSE 11527
// Say ( speaker [ 1 ] , VAd-2 ) else
11509: LD_VAR 0 4
11513: PUSH
11514: LD_INT 1
11516: ARRAY
11517: PPUSH
11518: LD_STRING VAd-2
11520: PPUSH
11521: CALL_OW 88
11525: GO 11543
// Say ( speaker [ 1 ] , VAfd-2 ) ;
11527: LD_VAR 0 4
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PPUSH
11536: LD_STRING VAfd-2
11538: PPUSH
11539: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11543: LD_EXP 51
11547: PPUSH
11548: LD_STRING VSd-3
11550: PPUSH
11551: CALL_OW 88
// InGameOff ;
11555: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc5 ) ;
11559: LD_STRING CVulc5
11561: PPUSH
11562: CALL_OW 337
// end else
11566: GO 11721
// if your_side = 7 then
11568: LD_OWVAR 2
11572: PUSH
11573: LD_INT 7
11575: EQUAL
11576: IFFALSE 11721
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff al_commander ;
11578: LD_ADDR_VAR 0 4
11582: PUSH
11583: LD_INT 22
11585: PUSH
11586: LD_INT 7
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: LD_INT 21
11595: PUSH
11596: LD_INT 1
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PPUSH
11607: CALL_OW 69
11611: PUSH
11612: LD_EXP 37
11616: DIFF
11617: ST_TO_ADDR
// if speaker then
11618: LD_VAR 0 4
11622: IFFALSE 11714
// begin CenterNowOnUnits ( al_commander ) ;
11624: LD_EXP 37
11628: PPUSH
11629: CALL_OW 87
// InGameOn ;
11633: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11637: LD_EXP 37
11641: PPUSH
11642: LD_STRING VPd-1
11644: PPUSH
11645: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) then
11649: LD_VAR 0 4
11653: PUSH
11654: LD_INT 1
11656: ARRAY
11657: PPUSH
11658: CALL_OW 258
11662: IFFALSE 11682
// Say ( speaker [ 1 ] , VPpd-1 ) else
11664: LD_VAR 0 4
11668: PUSH
11669: LD_INT 1
11671: ARRAY
11672: PPUSH
11673: LD_STRING VPpd-1
11675: PPUSH
11676: CALL_OW 88
11680: GO 11698
// Say ( speaker [ 1 ] , VPpdf-1 ) ;
11682: LD_VAR 0 4
11686: PUSH
11687: LD_INT 1
11689: ARRAY
11690: PPUSH
11691: LD_STRING VPpdf-1
11693: PPUSH
11694: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11698: LD_EXP 37
11702: PPUSH
11703: LD_STRING VPd-2
11705: PPUSH
11706: CALL_OW 88
// InGameOff ;
11710: CALL_OW 9
// end ; ChangeMissionObjectives ( CVulc7 ) ;
11714: LD_STRING CVulc7
11716: PPUSH
11717: CALL_OW 337
// end ; SaveForQuickRestart ;
11721: CALL_OW 22
// end ;
11725: LD_VAR 0 1
11729: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11730: LD_INT 22
11732: PUSH
11733: LD_INT 2
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PUSH
11740: LD_INT 30
11742: PUSH
11743: LD_INT 3
11745: PUSH
11746: EMPTY
11747: LIST
11748: LIST
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PPUSH
11754: CALL_OW 69
11758: IFFALSE 11802
11760: GO 11762
11762: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11763: LD_STRING CVulc6
11765: PPUSH
11766: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11770: LD_INT 52500
11772: PUSH
11773: LD_INT 47250
11775: PUSH
11776: LD_INT 42000
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: LIST
11783: PUSH
11784: LD_OWVAR 67
11788: ARRAY
11789: PPUSH
11790: CALL_OW 67
// ru_can_attack := true ;
11794: LD_ADDR_EXP 3
11798: PUSH
11799: LD_INT 1
11801: ST_TO_ADDR
// end ;
11802: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do var speaker ;
11803: LD_INT 50
11805: PPUSH
11806: CALL_OW 255
11810: PUSH
11811: LD_INT 1
11813: EQUAL
11814: PUSH
11815: LD_INT 22
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 2
11827: PUSH
11828: LD_INT 30
11830: PUSH
11831: LD_INT 3
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: LD_INT 30
11840: PUSH
11841: LD_INT 1
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: OR
11862: IFFALSE 12096
11864: GO 11866
11866: DISABLE
11867: LD_INT 0
11869: PPUSH
// begin ChangeMissionObjectives ( CVulc2 ) ;
11870: LD_STRING CVulc2
11872: PPUSH
11873: CALL_OW 337
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ;
11877: LD_ADDR_VAR 0 1
11881: PUSH
11882: LD_INT 22
11884: PUSH
11885: LD_INT 1
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 25
11894: PUSH
11895: LD_INT 2
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 69
11910: PUSH
11911: LD_EXP 19
11915: DIFF
11916: ST_TO_ADDR
// DialogueOn ;
11917: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_INT 1
11935: ARRAY
11936: PPUSH
11937: CALL_OW 258
11941: PUSH
11942: LD_INT 1
11944: EQUAL
11945: IFFALSE 11965
// Say ( speaker [ 1 ] , VDb-1 ) else
11947: LD_VAR 0 1
11951: PUSH
11952: LD_INT 1
11954: ARRAY
11955: PPUSH
11956: LD_STRING VDb-1
11958: PPUSH
11959: CALL_OW 88
11963: GO 11981
// Say ( speaker [ 1 ] , VDbf-1 ) ;
11965: LD_VAR 0 1
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PPUSH
11974: LD_STRING VDbf-1
11976: PPUSH
11977: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11981: LD_INT 10
11983: PPUSH
11984: CALL_OW 68
// if GetSex ( speaker [ 1 ] ) = sex_male then
11988: LD_VAR 0 1
11992: PUSH
11993: LD_INT 1
11995: ARRAY
11996: PPUSH
11997: CALL_OW 258
12001: PUSH
12002: LD_INT 1
12004: EQUAL
12005: IFFALSE 12025
// Say ( speaker [ 1 ] , VDb-2 ) else
12007: LD_VAR 0 1
12011: PUSH
12012: LD_INT 1
12014: ARRAY
12015: PPUSH
12016: LD_STRING VDb-2
12018: PPUSH
12019: CALL_OW 88
12023: GO 12041
// Say ( speaker [ 1 ] , VDbf-2 ) ;
12025: LD_VAR 0 1
12029: PUSH
12030: LD_INT 1
12032: ARRAY
12033: PPUSH
12034: LD_STRING VDbf-2
12036: PPUSH
12037: CALL_OW 88
// DWait ( 0 0$01 ) ;
12041: LD_INT 35
12043: PPUSH
12044: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
12048: LD_EXP 19
12052: PPUSH
12053: LD_STRING VDb-com1
12055: PPUSH
12056: CALL_OW 88
// DialogueOff ;
12060: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
12064: LD_INT 44100
12066: PUSH
12067: LD_INT 36750
12069: PUSH
12070: LD_INT 31500
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: PUSH
12078: LD_OWVAR 67
12082: ARRAY
12083: PPUSH
12084: CALL_OW 67
// ru_can_attack := true ;
12088: LD_ADDR_EXP 3
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// end ;
12096: PPOPN 1
12098: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
12099: LD_INT 22
12101: PUSH
12102: LD_INT 7
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PUSH
12109: LD_INT 30
12111: PUSH
12112: LD_INT 3
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PPUSH
12123: CALL_OW 69
12127: IFFALSE 12164
12129: GO 12131
12131: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
12132: LD_INT 42000
12134: PUSH
12135: LD_INT 34650
12137: PUSH
12138: LD_INT 29400
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: LIST
12145: PUSH
12146: LD_OWVAR 67
12150: ARRAY
12151: PPUSH
12152: CALL_OW 67
// ru_can_attack := true ;
12156: LD_ADDR_EXP 3
12160: PUSH
12161: LD_INT 1
12163: ST_TO_ADDR
// end ;
12164: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do var speaker ;
12165: LD_INT 58
12167: PPUSH
12168: CALL_OW 255
12172: PUSH
12173: LD_INT 1
12175: EQUAL
12176: IFFALSE 12383
12178: GO 12180
12180: DISABLE
12181: LD_INT 0
12183: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
12184: LD_ADDR_VAR 0 1
12188: PUSH
12189: LD_INT 22
12191: PUSH
12192: LD_INT 1
12194: PUSH
12195: EMPTY
12196: LIST
12197: LIST
12198: PUSH
12199: LD_INT 25
12201: PUSH
12202: LD_INT 2
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: PUSH
12209: EMPTY
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: ST_TO_ADDR
// DialogueOn ;
12218: CALL_OW 6
// if speaker then
12222: LD_VAR 0 1
12226: IFFALSE 12281
// if GetSex ( speaker [ 1 ] ) = sex_male then
12228: LD_VAR 0 1
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: CALL_OW 258
12241: PUSH
12242: LD_INT 1
12244: EQUAL
12245: IFFALSE 12265
// Say ( speaker [ 1 ] , VDe-1 ) else
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: ARRAY
12255: PPUSH
12256: LD_STRING VDe-1
12258: PPUSH
12259: CALL_OW 88
12263: GO 12281
// Say ( speaker [ 1 ] , VDef-1 ) ;
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING VDef-1
12276: PPUSH
12277: CALL_OW 88
// case Query ( SibNote ) of 1 :
12281: LD_STRING SibNote
12283: PPUSH
12284: CALL_OW 97
12288: PUSH
12289: LD_INT 1
12291: DOUBLE
12292: EQUAL
12293: IFTRUE 12297
12295: GO 12300
12297: POP
// ; end ;
12298: GO 12301
12300: POP
// if speaker then
12301: LD_VAR 0 1
12305: IFFALSE 12360
// if GetSex ( speaker [ 1 ] ) = sex_male then
12307: LD_VAR 0 1
12311: PUSH
12312: LD_INT 1
12314: ARRAY
12315: PPUSH
12316: CALL_OW 258
12320: PUSH
12321: LD_INT 1
12323: EQUAL
12324: IFFALSE 12344
// Say ( speaker [ 1 ] , VDe-2 ) else
12326: LD_VAR 0 1
12330: PUSH
12331: LD_INT 1
12333: ARRAY
12334: PPUSH
12335: LD_STRING VDe-2
12337: PPUSH
12338: CALL_OW 88
12342: GO 12360
// Say ( speaker [ 1 ] , VDef-2 ) ;
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 1
12351: ARRAY
12352: PPUSH
12353: LD_STRING VDef-2
12355: PPUSH
12356: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12360: LD_EXP 19
12364: PPUSH
12365: LD_STRING VDc-4
12367: PPUSH
12368: CALL_OW 88
// DialogueOff ;
12372: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12376: LD_STRING CVulc3
12378: PPUSH
12379: CALL_OW 337
// end ;
12383: PPOPN 1
12385: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12386: LD_OWVAR 2
12390: PUSH
12391: LD_INT 1
12393: EQUAL
12394: PUSH
12395: LD_INT 22
12397: PUSH
12398: LD_INT 1
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: LD_INT 30
12407: PUSH
12408: LD_INT 3
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PPUSH
12419: CALL_OW 69
12423: PUSH
12424: LD_INT 0
12426: GREATER
12427: AND
12428: IFFALSE 12862
12430: GO 12432
12432: DISABLE
12433: LD_INT 0
12435: PPUSH
12436: PPUSH
12437: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12438: LD_INT 245
12440: PPUSH
12441: LD_INT 1295
12443: PPUSH
12444: CALL_OW 12
12448: PPUSH
12449: CALL_OW 67
// DialogueOn ;
12453: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12457: LD_EXP 22
12461: PPUSH
12462: LD_STRING VDG-1
12464: PPUSH
12465: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12469: LD_EXP 19
12473: PPUSH
12474: LD_STRING VDc-5
12476: PPUSH
12477: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12481: LD_EXP 22
12485: PPUSH
12486: LD_STRING VDG-2
12488: PPUSH
12489: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12493: LD_EXP 19
12497: PPUSH
12498: LD_STRING VDc-6
12500: PPUSH
12501: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12505: LD_EXP 22
12509: PPUSH
12510: LD_STRING VDG-3
12512: PPUSH
12513: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12517: LD_EXP 19
12521: PPUSH
12522: LD_STRING VDc-7
12524: PPUSH
12525: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12529: LD_EXP 22
12533: PPUSH
12534: LD_STRING VDG-4
12536: PPUSH
12537: CALL_OW 94
// DialogueOff ;
12541: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12545: LD_STRING CVulc4
12547: PPUSH
12548: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12552: LD_INT 18900
12554: PUSH
12555: LD_INT 21000
12557: PUSH
12558: LD_INT 23100
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: PUSH
12566: LD_OWVAR 67
12570: ARRAY
12571: PPUSH
12572: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12576: LD_ADDR_VAR 0 1
12580: PUSH
12581: DOUBLE
12582: LD_INT 1
12584: DEC
12585: ST_TO_ADDR
12586: LD_INT 4
12588: PUSH
12589: LD_INT 5
12591: PUSH
12592: LD_INT 6
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: LIST
12599: PUSH
12600: LD_OWVAR 67
12604: ARRAY
12605: PUSH
12606: FOR_TO
12607: IFFALSE 12851
// begin uc_side := 1 ;
12609: LD_ADDR_OWVAR 20
12613: PUSH
12614: LD_INT 1
12616: ST_TO_ADDR
// uc_nation := 1 ;
12617: LD_ADDR_OWVAR 21
12621: PUSH
12622: LD_INT 1
12624: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12625: LD_INT 0
12627: PPUSH
12628: LD_INT 1
12630: PPUSH
12631: LD_INT 4
12633: PPUSH
12634: CALL_OW 12
12638: PPUSH
12639: LD_EXP 21
12643: PPUSH
12644: CALL_OW 380
// un := CreateHuman ;
12648: LD_ADDR_VAR 0 2
12652: PUSH
12653: CALL_OW 44
12657: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12658: LD_VAR 0 2
12662: PPUSH
12663: LD_INT 2
12665: PPUSH
12666: CALL_OW 233
// if GetClass ( un ) = 3 then
12670: LD_VAR 0 2
12674: PPUSH
12675: CALL_OW 257
12679: PUSH
12680: LD_INT 3
12682: EQUAL
12683: IFFALSE 12834
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12685: LD_ADDR_OWVAR 37
12689: PUSH
12690: LD_INT 2
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: LD_VAR 0 1
12704: PUSH
12705: LD_INT 2
12707: MOD
12708: ARRAY
12709: ST_TO_ADDR
// vc_engine := engine_combustion ;
12710: LD_ADDR_OWVAR 39
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// vc_control := control_manual ;
12718: LD_ADDR_OWVAR 38
12722: PUSH
12723: LD_INT 1
12725: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12726: LD_ADDR_OWVAR 40
12730: PUSH
12731: LD_INT 9
12733: PUSH
12734: LD_INT 9
12736: PUSH
12737: LD_INT 5
12739: PUSH
12740: LD_INT 11
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: PUSH
12749: LD_INT 1
12751: PPUSH
12752: LD_INT 4
12754: PPUSH
12755: CALL_OW 12
12759: ARRAY
12760: ST_TO_ADDR
// veh := CreateVehicle ;
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: CALL_OW 45
12770: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12771: LD_VAR 0 3
12775: PPUSH
12776: LD_INT 2
12778: PPUSH
12779: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12783: LD_VAR 0 3
12787: PPUSH
12788: LD_INT 77
12790: PPUSH
12791: LD_INT 88
12793: PPUSH
12794: CALL_OW 12
12798: PPUSH
12799: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12803: LD_VAR 0 3
12807: PPUSH
12808: LD_INT 1
12810: PPUSH
12811: LD_INT 0
12813: PPUSH
12814: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12818: LD_VAR 0 2
12822: PPUSH
12823: LD_VAR 0 3
12827: PPUSH
12828: CALL_OW 52
// end else
12832: GO 12849
// PlaceUnitArea ( un , start_north , false ) ;
12834: LD_VAR 0 2
12838: PPUSH
12839: LD_INT 1
12841: PPUSH
12842: LD_INT 0
12844: PPUSH
12845: CALL_OW 49
// end ;
12849: GO 12606
12851: POP
12852: POP
// CenterNowOnUnits ( un ) ;
12853: LD_VAR 0 2
12857: PPUSH
12858: CALL_OW 87
// end ;
12862: PPOPN 3
12864: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12865: LD_INT 21
12867: PPUSH
12868: LD_INT 22
12870: PUSH
12871: LD_OWVAR 2
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 70
12884: IFFALSE 13205
12886: GO 12888
12888: DISABLE
12889: LD_INT 0
12891: PPUSH
12892: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12893: LD_ADDR_VAR 0 2
12897: PUSH
12898: LD_INT 22
12900: PUSH
12901: LD_OWVAR 2
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 2
12912: PUSH
12913: LD_INT 25
12915: PUSH
12916: LD_INT 1
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: LD_INT 25
12925: PUSH
12926: LD_INT 2
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 25
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 4
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: PUSH
12969: LD_EXP 10
12973: DIFF
12974: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12975: LD_ADDR_VAR 0 1
12979: PUSH
12980: LD_VAR 0 2
12984: PPUSH
12985: LD_INT 112
12987: PPUSH
12988: LD_INT 67
12990: PPUSH
12991: CALL_OW 73
12995: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12996: LD_VAR 0 1
13000: PPUSH
13001: CALL_OW 255
13005: PUSH
13006: LD_INT 7
13008: EQUAL
13009: IFFALSE 13052
// if GetSex ( un ) = sex_male then
13011: LD_VAR 0 1
13015: PPUSH
13016: CALL_OW 258
13020: PUSH
13021: LD_INT 1
13023: EQUAL
13024: IFFALSE 13040
// Say ( un , VD-find-al ) else
13026: LD_VAR 0 1
13030: PPUSH
13031: LD_STRING VD-find-al
13033: PPUSH
13034: CALL_OW 88
13038: GO 13052
// Say ( un , VD-find-al-f ) ;
13040: LD_VAR 0 1
13044: PPUSH
13045: LD_STRING VD-find-al-f
13047: PPUSH
13048: CALL_OW 88
// if GetSide ( un ) = 2 then
13052: LD_VAR 0 1
13056: PPUSH
13057: CALL_OW 255
13061: PUSH
13062: LD_INT 2
13064: EQUAL
13065: IFFALSE 13108
// if GetSex ( un ) = sex_male then
13067: LD_VAR 0 1
13071: PPUSH
13072: CALL_OW 258
13076: PUSH
13077: LD_INT 1
13079: EQUAL
13080: IFFALSE 13096
// Say ( un , VD-find-ar ) else
13082: LD_VAR 0 1
13086: PPUSH
13087: LD_STRING VD-find-ar
13089: PPUSH
13090: CALL_OW 88
13094: GO 13108
// Say ( un , VD-find-ar-f ) ;
13096: LD_VAR 0 1
13100: PPUSH
13101: LD_STRING VD-find-ar-f
13103: PPUSH
13104: CALL_OW 88
// if GetSide ( un ) = 1 then
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 255
13117: PUSH
13118: LD_INT 1
13120: EQUAL
13121: IFFALSE 13188
// begin if GetSex ( un ) = sex_male then
13123: LD_VAR 0 1
13127: PPUSH
13128: CALL_OW 258
13132: PUSH
13133: LD_INT 1
13135: EQUAL
13136: IFFALSE 13164
// begin Say ( un , VD-find-us ) ;
13138: LD_VAR 0 1
13142: PPUSH
13143: LD_STRING VD-find-us
13145: PPUSH
13146: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
13150: LD_VAR 0 1
13154: PPUSH
13155: LD_STRING VD-find-us2
13157: PPUSH
13158: CALL_OW 88
// end else
13162: GO 13188
// begin Say ( un , VD-find-us-f ) ;
13164: LD_VAR 0 1
13168: PPUSH
13169: LD_STRING VD-find-us-f
13171: PPUSH
13172: CALL_OW 88
// Say ( un , VD-find-us2-f ) ;
13176: LD_VAR 0 1
13180: PPUSH
13181: LD_STRING VD-find-us2-f
13183: PPUSH
13184: CALL_OW 88
// end ; end ; Wait ( 0 0$0.3 ) ;
13188: LD_INT 10
13190: PPUSH
13191: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
13195: LD_INT 112
13197: PPUSH
13198: LD_INT 67
13200: PPUSH
13201: CALL_OW 86
// end ;
13205: PPOPN 2
13207: END
// every 0 0$01 trigger player_artifact_ready do var speaker ;
13208: LD_EXP 7
13212: IFFALSE 13714
13214: GO 13216
13216: DISABLE
13217: LD_INT 0
13219: PPUSH
// begin if your_side = 1 then
13220: LD_OWVAR 2
13224: PUSH
13225: LD_INT 1
13227: EQUAL
13228: IFFALSE 13409
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ;
13230: LD_ADDR_VAR 0 1
13234: PUSH
13235: LD_INT 22
13237: PUSH
13238: LD_INT 1
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: LD_INT 25
13247: PUSH
13248: LD_INT 4
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 19
13268: DIFF
13269: ST_TO_ADDR
// if not speaker then
13270: LD_VAR 0 1
13274: NOT
13275: IFFALSE 13279
// exit ;
13277: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13279: LD_VAR 0 1
13283: PUSH
13284: LD_INT 1
13286: ARRAY
13287: PPUSH
13288: CALL_OW 258
13292: PUSH
13293: LD_INT 1
13295: EQUAL
13296: IFFALSE 13316
// Say ( speaker [ 1 ] , VD-us-sci-art-1 ) else
13298: LD_VAR 0 1
13302: PUSH
13303: LD_INT 1
13305: ARRAY
13306: PPUSH
13307: LD_STRING VD-us-sci-art-1
13309: PPUSH
13310: CALL_OW 88
13314: GO 13332
// Say ( speaker [ 1 ] , VD-us-fsci-art-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING VD-us-fsci-art-1
13327: PPUSH
13328: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
13332: LD_EXP 19
13336: PPUSH
13337: LD_STRING VDc-art1
13339: PPUSH
13340: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13344: LD_VAR 0 1
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: PPUSH
13353: CALL_OW 258
13357: PUSH
13358: LD_INT 1
13360: EQUAL
13361: IFFALSE 13381
// Say ( speaker [ 1 ] , VD-us-sci-art-2 ) else
13363: LD_VAR 0 1
13367: PUSH
13368: LD_INT 1
13370: ARRAY
13371: PPUSH
13372: LD_STRING VD-us-sci-art-2
13374: PPUSH
13375: CALL_OW 88
13379: GO 13397
// Say ( speaker [ 1 ] , VD-us-fsci-art-2 ) ;
13381: LD_VAR 0 1
13385: PUSH
13386: LD_INT 1
13388: ARRAY
13389: PPUSH
13390: LD_STRING VD-us-fsci-art-2
13392: PPUSH
13393: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
13397: LD_EXP 19
13401: PPUSH
13402: LD_STRING VDc-art2
13404: PPUSH
13405: CALL_OW 88
// end ; if your_side = 2 then
13409: LD_OWVAR 2
13413: PUSH
13414: LD_INT 2
13416: EQUAL
13417: IFFALSE 13521
// begin speaker := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff ar_commander ;
13419: LD_ADDR_VAR 0 1
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_INT 2
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: PUSH
13434: LD_INT 25
13436: PUSH
13437: LD_INT 4
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PPUSH
13448: CALL_OW 69
13452: PUSH
13453: LD_EXP 51
13457: DIFF
13458: ST_TO_ADDR
// if not speaker then
13459: LD_VAR 0 1
13463: NOT
13464: IFFALSE 13468
// exit ;
13466: GO 13714
// if GetSex ( speaker [ 1 ] ) = sex_male then
13468: LD_VAR 0 1
13472: PUSH
13473: LD_INT 1
13475: ARRAY
13476: PPUSH
13477: CALL_OW 258
13481: PUSH
13482: LD_INT 1
13484: EQUAL
13485: IFFALSE 13505
// Say ( speaker [ 1 ] , VD-ar-sci-art-1 ) else
13487: LD_VAR 0 1
13491: PUSH
13492: LD_INT 1
13494: ARRAY
13495: PPUSH
13496: LD_STRING VD-ar-sci-art-1
13498: PPUSH
13499: CALL_OW 88
13503: GO 13521
// Say ( speaker [ 1 ] , VD-ar-fsci-art-1 ) ;
13505: LD_VAR 0 1
13509: PUSH
13510: LD_INT 1
13512: ARRAY
13513: PPUSH
13514: LD_STRING VD-ar-fsci-art-1
13516: PPUSH
13517: CALL_OW 88
// end ; if your_side = 7 then
13521: LD_OWVAR 2
13525: PUSH
13526: LD_INT 7
13528: EQUAL
13529: IFFALSE 13714
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ;
13531: LD_ADDR_VAR 0 1
13535: PUSH
13536: LD_INT 22
13538: PUSH
13539: LD_INT 7
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 25
13548: PUSH
13549: LD_INT 4
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PUSH
13565: LD_EXP 37
13569: DIFF
13570: ST_TO_ADDR
// if speaker then
13571: LD_VAR 0 1
13575: IFFALSE 13707
// begin if GetSex ( speaker [ 1 ] ) = sex_male then
13577: LD_VAR 0 1
13581: PUSH
13582: LD_INT 1
13584: ARRAY
13585: PPUSH
13586: CALL_OW 258
13590: PUSH
13591: LD_INT 1
13593: EQUAL
13594: IFFALSE 13614
// Say ( speaker [ 1 ] , VD-al-sci-art-1 ) else
13596: LD_VAR 0 1
13600: PUSH
13601: LD_INT 1
13603: ARRAY
13604: PPUSH
13605: LD_STRING VD-al-sci-art-1
13607: PPUSH
13608: CALL_OW 88
13612: GO 13630
// Say ( speaker [ 1 ] , VD-al-fsci-art-1 ) ;
13614: LD_VAR 0 1
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: PPUSH
13623: LD_STRING VD-al-fsci-art-1
13625: PPUSH
13626: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13630: LD_EXP 37
13634: PPUSH
13635: LD_STRING VPd-art-1
13637: PPUSH
13638: CALL_OW 88
// if GetSex ( speaker [ 1 ] ) = sex_male then
13642: LD_VAR 0 1
13646: PUSH
13647: LD_INT 1
13649: ARRAY
13650: PPUSH
13651: CALL_OW 258
13655: PUSH
13656: LD_INT 1
13658: EQUAL
13659: IFFALSE 13679
// Say ( speaker [ 1 ] , VD-al-sci-art-2 ) else
13661: LD_VAR 0 1
13665: PUSH
13666: LD_INT 1
13668: ARRAY
13669: PPUSH
13670: LD_STRING VD-al-sci-art-2
13672: PPUSH
13673: CALL_OW 88
13677: GO 13695
// Say ( speaker [ 1 ] , VD-al-fsci-art-2 ) ;
13679: LD_VAR 0 1
13683: PUSH
13684: LD_INT 1
13686: ARRAY
13687: PPUSH
13688: LD_STRING VD-al-fsci-art-2
13690: PPUSH
13691: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13695: LD_EXP 37
13699: PPUSH
13700: LD_STRING VPd-art-2
13702: PPUSH
13703: CALL_OW 88
// end ; ChangeMissionObjectives ( CVulc7out ) ;
13707: LD_STRING CVulc7out
13709: PPUSH
13710: CALL_OW 337
// end ; end ;
13714: PPOPN 1
13716: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do var speaker ;
13717: LD_INT 8
13719: PPUSH
13720: LD_INT 22
13722: PUSH
13723: LD_OWVAR 2
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: PPUSH
13732: CALL_OW 69
13736: PPUSH
13737: LD_INT 8
13739: PPUSH
13740: CALL 2145 0 2
13744: PPUSH
13745: CALL_OW 292
13749: IFFALSE 13892
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin if your_side = 1 then
13757: LD_OWVAR 2
13761: PUSH
13762: LD_INT 1
13764: EQUAL
13765: IFFALSE 13848
// begin speaker := FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ;
13767: LD_ADDR_VAR 0 1
13771: PUSH
13772: LD_INT 22
13774: PUSH
13775: LD_INT 1
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_EXP 19
13791: DIFF
13792: ST_TO_ADDR
// if speaker then
13793: LD_VAR 0 1
13797: IFFALSE 13848
// if GetSex ( speaker [ 1 ] ) then
13799: LD_VAR 0 1
13803: PUSH
13804: LD_INT 1
13806: ARRAY
13807: PPUSH
13808: CALL_OW 258
13812: IFFALSE 13832
// Say ( speaker [ 1 ] , VD-legion-us ) else
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 1
13821: ARRAY
13822: PPUSH
13823: LD_STRING VD-legion-us
13825: PPUSH
13826: CALL_OW 88
13830: GO 13848
// Say ( speaker [ 1 ] , VD-legion-us-f ) ;
13832: LD_VAR 0 1
13836: PUSH
13837: LD_INT 1
13839: ARRAY
13840: PPUSH
13841: LD_STRING VD-legion-us-f
13843: PPUSH
13844: CALL_OW 88
// end ; if your_side = 2 then
13848: LD_OWVAR 2
13852: PUSH
13853: LD_INT 2
13855: EQUAL
13856: IFFALSE 13870
// Say ( ar_commander , VD-legion-ar ) ;
13858: LD_EXP 51
13862: PPUSH
13863: LD_STRING VD-legion-ar
13865: PPUSH
13866: CALL_OW 88
// if your_side = 7 then
13870: LD_OWVAR 2
13874: PUSH
13875: LD_INT 7
13877: EQUAL
13878: IFFALSE 13892
// Say ( al_commander , VD-legion-al ) ;
13880: LD_EXP 37
13884: PPUSH
13885: LD_STRING VD-legion-al
13887: PPUSH
13888: CALL_OW 88
// end ;
13892: PPOPN 1
13894: END
// every 0 0$01 trigger mine_vulc do
13895: LD_EXP 12
13899: IFFALSE 13916
13901: GO 13903
13903: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13904: LD_EXP 10
13908: PPUSH
13909: LD_STRING VD-vulc-mines
13911: PPUSH
13912: CALL_OW 88
// end ;
13916: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13917: LD_OWVAR 67
13921: PUSH
13922: LD_INT 1
13924: GREATER
13925: IFFALSE 14044
13927: GO 13929
13929: DISABLE
13930: LD_INT 0
13932: PPUSH
13933: PPUSH
13934: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13935: LD_ADDR_VAR 0 1
13939: PUSH
13940: LD_INT 123
13942: PUSH
13943: LD_INT 95
13945: PUSH
13946: LD_INT 119
13948: PUSH
13949: LD_INT 89
13951: PUSH
13952: LD_INT 115
13954: PUSH
13955: LD_INT 81
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: ST_TO_ADDR
// p := 1 ;
13966: LD_ADDR_VAR 0 2
13970: PUSH
13971: LD_INT 1
13973: ST_TO_ADDR
// for i = 1 to 3 do
13974: LD_ADDR_VAR 0 3
13978: PUSH
13979: DOUBLE
13980: LD_INT 1
13982: DEC
13983: ST_TO_ADDR
13984: LD_INT 3
13986: PUSH
13987: FOR_TO
13988: IFFALSE 14042
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13990: LD_VAR 0 1
13994: PUSH
13995: LD_VAR 0 2
13999: ARRAY
14000: PPUSH
14001: LD_VAR 0 1
14005: PUSH
14006: LD_VAR 0 2
14010: PUSH
14011: LD_INT 1
14013: PLUS
14014: ARRAY
14015: PPUSH
14016: LD_INT 8
14018: PPUSH
14019: LD_INT 0
14021: PPUSH
14022: CALL_OW 454
// p := p + 2 ;
14026: LD_ADDR_VAR 0 2
14030: PUSH
14031: LD_VAR 0 2
14035: PUSH
14036: LD_INT 2
14038: PLUS
14039: ST_TO_ADDR
// end ;
14040: GO 13987
14042: POP
14043: POP
// end ;
14044: PPOPN 3
14046: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
14047: LD_OWVAR 67
14051: PUSH
14052: LD_INT 1
14054: GREATER
14055: PUSH
14056: LD_INT 22
14058: PPUSH
14059: LD_INT 22
14061: PUSH
14062: LD_OWVAR 2
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PPUSH
14071: CALL_OW 70
14075: AND
14076: IFFALSE 14280
14078: GO 14080
14080: DISABLE
14081: LD_INT 0
14083: PPUSH
14084: PPUSH
14085: PPUSH
// begin enable ;
14086: ENABLE
// p := 1 ;
14087: LD_ADDR_VAR 0 1
14091: PUSH
14092: LD_INT 1
14094: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
14095: LD_ADDR_VAR 0 3
14099: PUSH
14100: LD_INT 123
14102: PUSH
14103: LD_INT 95
14105: PUSH
14106: LD_INT 119
14108: PUSH
14109: LD_INT 89
14111: PUSH
14112: LD_INT 115
14114: PUSH
14115: LD_INT 81
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: ST_TO_ADDR
// for i = 1 to 3 do
14126: LD_ADDR_VAR 0 2
14130: PUSH
14131: DOUBLE
14132: LD_INT 1
14134: DEC
14135: ST_TO_ADDR
14136: LD_INT 3
14138: PUSH
14139: FOR_TO
14140: IFFALSE 14278
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
14142: LD_VAR 0 3
14146: PUSH
14147: LD_VAR 0 1
14151: ARRAY
14152: PPUSH
14153: LD_VAR 0 3
14157: PUSH
14158: LD_VAR 0 1
14162: PUSH
14163: LD_INT 1
14165: PLUS
14166: ARRAY
14167: PPUSH
14168: CALL_OW 428
14172: PUSH
14173: LD_INT 0
14175: GREATER
14176: IFFALSE 14262
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
14178: LD_VAR 0 3
14182: PUSH
14183: LD_VAR 0 1
14187: ARRAY
14188: PPUSH
14189: LD_VAR 0 3
14193: PUSH
14194: LD_VAR 0 1
14198: PUSH
14199: LD_INT 1
14201: PLUS
14202: ARRAY
14203: PPUSH
14204: CALL_OW 428
14208: PPUSH
14209: CALL_OW 255
14213: PUSH
14214: LD_OWVAR 2
14218: EQUAL
14219: IFFALSE 14262
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
14221: LD_VAR 0 3
14225: PUSH
14226: LD_VAR 0 1
14230: ARRAY
14231: PPUSH
14232: LD_VAR 0 3
14236: PUSH
14237: LD_VAR 0 1
14241: PUSH
14242: LD_INT 1
14244: PLUS
14245: ARRAY
14246: PPUSH
14247: LD_INT 8
14249: PPUSH
14250: CALL_OW 456
// mine_vulc := true ;
14254: LD_ADDR_EXP 12
14258: PUSH
14259: LD_INT 1
14261: ST_TO_ADDR
// end ; p := p + 2 ;
14262: LD_ADDR_VAR 0 1
14266: PUSH
14267: LD_VAR 0 1
14271: PUSH
14272: LD_INT 2
14274: PLUS
14275: ST_TO_ADDR
// end ;
14276: GO 14139
14278: POP
14279: POP
// end ;
14280: PPOPN 3
14282: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
14283: LD_INT 22
14285: PUSH
14286: LD_INT 3
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: PPUSH
14293: CALL_OW 69
14297: PUSH
14298: LD_INT 0
14300: EQUAL
14301: PUSH
14302: LD_OWVAR 2
14306: PUSH
14307: LD_INT 2
14309: NONEQUAL
14310: AND
14311: IFFALSE 14320
14313: GO 14315
14315: DISABLE
// Win ;
14316: CALL 14377 0 0
14320: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
14321: LD_INT 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 8
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 22
14336: PUSH
14337: LD_INT 3
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: PPUSH
14349: CALL_OW 69
14353: PUSH
14354: LD_INT 0
14356: EQUAL
14357: PUSH
14358: LD_OWVAR 2
14362: PUSH
14363: LD_INT 2
14365: EQUAL
14366: AND
14367: IFFALSE 14376
14369: GO 14371
14371: DISABLE
// Win ;
14372: CALL 14377 0 0
14376: END
// function Win ; var points ; begin
14377: LD_INT 0
14379: PPUSH
14380: PPUSH
// case Query ( VulcWin ) of 1 :
14381: LD_STRING VulcWin
14383: PPUSH
14384: CALL_OW 97
14388: PUSH
14389: LD_INT 1
14391: DOUBLE
14392: EQUAL
14393: IFTRUE 14397
14395: GO 14400
14397: POP
// ; end ;
14398: GO 14401
14400: POP
// if medal_enabled then
14401: LD_EXP 13
14405: IFFALSE 14419
// AddMedal ( vulc_1 , 1 ) else
14407: LD_STRING vulc_1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: CALL_OW 101
14417: GO 14430
// AddMedal ( vulc_1 , - 1 ) ;
14419: LD_STRING vulc_1
14421: PPUSH
14422: LD_INT 1
14424: NEG
14425: PPUSH
14426: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
14430: LD_INT 22
14432: PUSH
14433: LD_INT 8
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 69
14444: PUSH
14445: LD_INT 0
14447: EQUAL
14448: IFFALSE 14462
// AddMedal ( vulc_2 , 1 ) else
14450: LD_STRING vulc_2
14452: PPUSH
14453: LD_INT 1
14455: PPUSH
14456: CALL_OW 101
14460: GO 14473
// AddMedal ( vulc_2 , - 1 ) ;
14462: LD_STRING vulc_2
14464: PPUSH
14465: LD_INT 1
14467: NEG
14468: PPUSH
14469: CALL_OW 101
// points := CalculateCommanderPoints ;
14473: LD_ADDR_VAR 0 2
14477: PUSH
14478: CALL 2266 0 0
14482: ST_TO_ADDR
// if points >= 2000 then
14483: LD_VAR 0 2
14487: PUSH
14488: LD_INT 2000
14490: GREATEREQUAL
14491: IFFALSE 14505
// AddMedal ( vulc_3 , 2 ) else
14493: LD_STRING vulc_3
14495: PPUSH
14496: LD_INT 2
14498: PPUSH
14499: CALL_OW 101
14503: GO 14538
// if points >= 0 then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 0
14512: GREATEREQUAL
14513: IFFALSE 14527
// AddMedal ( vulc_3 , 1 ) else
14515: LD_STRING vulc_3
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 101
14525: GO 14538
// AddMedal ( vulc_3 , - 1 ) ;
14527: LD_STRING vulc_3
14529: PPUSH
14530: LD_INT 1
14532: NEG
14533: PPUSH
14534: CALL_OW 101
// GiveMedals ( MAIN ) ;
14538: LD_STRING MAIN
14540: PPUSH
14541: CALL_OW 102
// YouWin ;
14545: CALL_OW 103
// end ; end_of_file
14549: LD_VAR 0 1
14553: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
14554: LD_INT 13
14556: PPUSH
14557: LD_INT 21
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PPUSH
14567: CALL_OW 70
14571: PUSH
14572: LD_INT 0
14574: GREATER
14575: IFFALSE 14642
14577: GO 14579
14579: DISABLE
14580: LD_INT 0
14582: PPUSH
14583: PPUSH
// begin enable ;
14584: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_INT 13
14592: PPUSH
14593: LD_INT 21
14595: PUSH
14596: LD_INT 1
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 70
14607: PUSH
14608: FOR_IN
14609: IFFALSE 14640
// if GetLives ( i ) > 4 then
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 256
14620: PUSH
14621: LD_INT 4
14623: GREATER
14624: IFFALSE 14638
// SetLives ( i , 4 ) ;
14626: LD_VAR 0 1
14630: PPUSH
14631: LD_INT 4
14633: PPUSH
14634: CALL_OW 234
14638: GO 14608
14640: POP
14641: POP
// end ;
14642: PPOPN 2
14644: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14645: LD_VAR 0 1
14649: PPUSH
14650: CALL_OW 255
14654: PUSH
14655: LD_OWVAR 2
14659: EQUAL
14660: IFFALSE 14670
// player_res_art := true ;
14662: LD_ADDR_EXP 6
14666: PUSH
14667: LD_INT 1
14669: ST_TO_ADDR
// end ;
14670: PPOPN 1
14672: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
14673: LD_INT 22
14675: PUSH
14676: LD_OWVAR 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: LD_INT 2
14687: PUSH
14688: LD_INT 30
14690: PUSH
14691: LD_INT 7
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: LD_INT 30
14700: PUSH
14701: LD_INT 8
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: LD_INT 30
14710: PUSH
14711: LD_INT 11
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 6
14737: AND
14738: IFFALSE 15093
14740: GO 14742
14742: DISABLE
14743: LD_INT 0
14745: PPUSH
14746: PPUSH
14747: PPUSH
// begin enable ;
14748: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14749: LD_ADDR_VAR 0 1
14753: PUSH
14754: LD_INT 1
14756: PPUSH
14757: CALL_OW 469
14761: PUSH
14762: LD_INT 1
14764: ARRAY
14765: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14766: LD_ADDR_VAR 0 2
14770: PUSH
14771: LD_INT 1
14773: PPUSH
14774: CALL_OW 469
14778: PUSH
14779: LD_INT 2
14781: ARRAY
14782: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14783: LD_ADDR_VAR 0 3
14787: PUSH
14788: LD_INT 22
14790: PUSH
14791: LD_OWVAR 2
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 8
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 11
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PPUSH
14848: LD_VAR 0 1
14852: PPUSH
14853: LD_VAR 0 2
14857: PPUSH
14858: CALL_OW 73
14862: ST_TO_ADDR
// if player_artifact_ready = false then
14863: LD_EXP 7
14867: PUSH
14868: LD_INT 0
14870: EQUAL
14871: IFFALSE 14977
// if GetDistUnitXY ( lab , x , y ) < 6 then
14873: LD_VAR 0 3
14877: PPUSH
14878: LD_VAR 0 1
14882: PPUSH
14883: LD_VAR 0 2
14887: PPUSH
14888: CALL_OW 297
14892: PUSH
14893: LD_INT 6
14895: LESS
14896: IFFALSE 14957
// begin if BuildingStatus ( lab ) = bs_idle then
14898: LD_VAR 0 3
14902: PPUSH
14903: CALL_OW 461
14907: PUSH
14908: LD_INT 2
14910: EQUAL
14911: IFFALSE 14935
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14913: LD_OWVAR 2
14917: PPUSH
14918: LD_INT 1
14920: PPUSH
14921: LD_INT 2
14923: PPUSH
14924: LD_VAR 0 3
14928: PPUSH
14929: CALL_OW 468
14933: GO 14955
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14935: LD_OWVAR 2
14939: PPUSH
14940: LD_INT 1
14942: PPUSH
14943: LD_INT 1
14945: PPUSH
14946: LD_VAR 0 3
14950: PPUSH
14951: CALL_OW 468
// end else
14955: GO 14977
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14957: LD_OWVAR 2
14961: PPUSH
14962: LD_INT 1
14964: PPUSH
14965: LD_INT 1
14967: PPUSH
14968: LD_VAR 0 3
14972: PPUSH
14973: CALL_OW 468
// if player_artifact_ready then
14977: LD_EXP 7
14981: IFFALSE 15093
// if GetDistUnitXY ( lab , x , y ) < 6 then
14983: LD_VAR 0 3
14987: PPUSH
14988: LD_VAR 0 1
14992: PPUSH
14993: LD_VAR 0 2
14997: PPUSH
14998: CALL_OW 297
15002: PUSH
15003: LD_INT 6
15005: LESS
15006: IFFALSE 15071
// begin if BuildingStatus ( lab ) = bs_idle then
15008: LD_VAR 0 3
15012: PPUSH
15013: CALL_OW 461
15017: PUSH
15018: LD_INT 2
15020: EQUAL
15021: IFFALSE 15047
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
15023: LD_OWVAR 2
15027: PPUSH
15028: LD_EXP 8
15032: PPUSH
15033: LD_INT 4
15035: PPUSH
15036: LD_VAR 0 3
15040: PPUSH
15041: CALL_OW 468
15045: GO 15069
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15047: LD_OWVAR 2
15051: PPUSH
15052: LD_EXP 8
15056: PPUSH
15057: LD_INT 1
15059: PPUSH
15060: LD_VAR 0 3
15064: PPUSH
15065: CALL_OW 468
// end else
15069: GO 15093
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15071: LD_OWVAR 2
15075: PPUSH
15076: LD_EXP 8
15080: PPUSH
15081: LD_INT 1
15083: PPUSH
15084: LD_VAR 0 3
15088: PPUSH
15089: CALL_OW 468
// end ;
15093: PPOPN 3
15095: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
15096: LD_INT 0
15098: PPUSH
15099: PPUSH
15100: PPUSH
15101: PPUSH
15102: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
15103: LD_ADDR_VAR 0 5
15107: PUSH
15108: LD_INT 1
15110: PPUSH
15111: CALL_OW 469
15115: PUSH
15116: LD_INT 1
15118: ARRAY
15119: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
15120: LD_ADDR_VAR 0 6
15124: PUSH
15125: LD_INT 1
15127: PPUSH
15128: CALL_OW 469
15132: PUSH
15133: LD_INT 2
15135: ARRAY
15136: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
15137: LD_ADDR_VAR 0 8
15141: PUSH
15142: LD_INT 22
15144: PUSH
15145: LD_OWVAR 2
15149: PUSH
15150: EMPTY
15151: LIST
15152: LIST
15153: PUSH
15154: LD_INT 2
15156: PUSH
15157: LD_INT 30
15159: PUSH
15160: LD_INT 8
15162: PUSH
15163: EMPTY
15164: LIST
15165: LIST
15166: PUSH
15167: LD_INT 30
15169: PUSH
15170: LD_INT 11
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: LIST
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PPUSH
15186: CALL_OW 69
15190: PPUSH
15191: LD_VAR 0 5
15195: PPUSH
15196: LD_VAR 0 6
15200: PPUSH
15201: CALL_OW 73
15205: ST_TO_ADDR
// if icon = art_exp_left then
15206: LD_VAR 0 2
15210: PUSH
15211: LD_INT 1
15213: EQUAL
15214: IFFALSE 15253
// begin SetSpecResearch ( lab , time_res_art , true ) ;
15216: LD_VAR 0 8
15220: PPUSH
15221: LD_EXP 9
15225: PPUSH
15226: LD_INT 1
15228: PPUSH
15229: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15233: LD_OWVAR 2
15237: PPUSH
15238: LD_INT 1
15240: PPUSH
15241: LD_INT 0
15243: PPUSH
15244: LD_VAR 0 8
15248: PPUSH
15249: CALL_OW 468
// end ; if icon = art_icon then
15253: LD_VAR 0 2
15257: PUSH
15258: LD_EXP 8
15262: EQUAL
15263: IFFALSE 15477
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
15265: LD_VAR 0 3
15269: PUSH
15270: LD_INT 21
15272: PUSH
15273: LD_INT 3
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: PPUSH
15280: CALL_OW 69
15284: IN
15285: IFFALSE 15477
// begin side := GetSide ( cr1 ) ;
15287: LD_ADDR_VAR 0 9
15291: PUSH
15292: LD_VAR 0 3
15296: PPUSH
15297: CALL_OW 255
15301: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
15302: LD_INT 22
15304: PUSH
15305: LD_VAR 0 9
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 30
15316: PUSH
15317: LD_INT 28
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PPUSH
15328: CALL_OW 69
15332: PUSH
15333: LD_INT 0
15335: GREATER
15336: IFFALSE 15477
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
15338: LD_ADDR_VAR 0 7
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_VAR 0 9
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: PUSH
15355: LD_INT 2
15357: PUSH
15358: LD_INT 30
15360: PUSH
15361: LD_INT 26
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: PUSH
15368: LD_INT 30
15370: PUSH
15371: LD_INT 27
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PUSH
15378: LD_INT 30
15380: PUSH
15381: LD_INT 28
15383: PUSH
15384: EMPTY
15385: LIST
15386: LIST
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: PPUSH
15398: CALL_OW 69
15402: PUSH
15403: FOR_IN
15404: IFFALSE 15420
// SetLives ( i , 1 ) ;
15406: LD_VAR 0 7
15410: PPUSH
15411: LD_INT 1
15413: PPUSH
15414: CALL_OW 234
15418: GO 15403
15420: POP
15421: POP
// player_res_art := false ;
15422: LD_ADDR_EXP 6
15426: PUSH
15427: LD_INT 0
15429: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
15430: LD_OWVAR 2
15434: PPUSH
15435: LD_EXP 8
15439: PPUSH
15440: LD_INT 1
15442: PPUSH
15443: LD_VAR 0 8
15447: PPUSH
15448: CALL_OW 468
// Wait ( time_to_reuse ) ;
15452: LD_EXP 11
15456: PPUSH
15457: CALL_OW 67
// player_res_art := true ;
15461: LD_ADDR_EXP 6
15465: PUSH
15466: LD_INT 1
15468: ST_TO_ADDR
// medal_enabled := true ;
15469: LD_ADDR_EXP 13
15473: PUSH
15474: LD_INT 1
15476: ST_TO_ADDR
// end ; end ; end ; end ;
15477: PPOPN 9
15479: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
15480: LD_VAR 0 1
15484: PPUSH
15485: CALL_OW 255
15489: PUSH
15490: LD_OWVAR 2
15494: EQUAL
15495: IFFALSE 15532
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
15497: LD_OWVAR 2
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: LD_INT 0
15507: PPUSH
15508: LD_VAR 0 1
15512: PPUSH
15513: CALL_OW 468
// player_artifact_ready := true ;
15517: LD_ADDR_EXP 7
15521: PUSH
15522: LD_INT 1
15524: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
15525: LD_STRING ArtVulcano
15527: PPUSH
15528: CALL_OW 339
// end ; end ;
15532: PPOPN 1
15534: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
15535: LD_OWVAR 2
15539: PPUSH
15540: LD_INT 1
15542: PPUSH
15543: LD_INT 2
15545: PPUSH
15546: LD_VAR 0 1
15550: PPUSH
15551: CALL_OW 468
// end ; end_of_file
15555: PPOPN 2
15557: END
// every 0 0$01 do
15558: GO 15560
15560: DISABLE
// begin enable ;
15561: ENABLE
// Display_Strings := [ #tick , tick ] ;
15562: LD_ADDR_OWVAR 47
15566: PUSH
15567: LD_STRING #tick
15569: PUSH
15570: LD_OWVAR 1
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: ST_TO_ADDR
// end ; end_of_file
15579: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
15580: LD_INT 0
15582: PPUSH
15583: PPUSH
15584: PPUSH
15585: PPUSH
15586: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
15587: LD_ADDR_EXP 39
15591: PUSH
15592: LD_INT 7
15594: PUSH
15595: LD_INT 6
15597: PUSH
15598: LD_INT 5
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: LIST
15605: PUSH
15606: LD_OWVAR 67
15610: ARRAY
15611: ST_TO_ADDR
// al_force := [ ] ;
15612: LD_ADDR_EXP 38
15616: PUSH
15617: EMPTY
15618: ST_TO_ADDR
// RemoveAlliance ;
15619: CALL 15997 0 0
// ResetFog ;
15623: CALL_OW 335
// your_side := 7 ;
15627: LD_ADDR_OWVAR 2
15631: PUSH
15632: LD_INT 7
15634: ST_TO_ADDR
// uc_side := 7 ;
15635: LD_ADDR_OWVAR 20
15639: PUSH
15640: LD_INT 7
15642: ST_TO_ADDR
// hc_gallery :=  ;
15643: LD_ADDR_OWVAR 33
15647: PUSH
15648: LD_STRING 
15650: ST_TO_ADDR
// hc_name :=  ;
15651: LD_ADDR_OWVAR 26
15655: PUSH
15656: LD_STRING 
15658: ST_TO_ADDR
// hc_importance := 0 ;
15659: LD_ADDR_OWVAR 32
15663: PUSH
15664: LD_INT 0
15666: ST_TO_ADDR
// for i = 1 to 17 do
15667: LD_ADDR_VAR 0 2
15671: PUSH
15672: DOUBLE
15673: LD_INT 1
15675: DEC
15676: ST_TO_ADDR
15677: LD_INT 17
15679: PUSH
15680: FOR_TO
15681: IFFALSE 15761
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15683: LD_ADDR_OWVAR 21
15687: PUSH
15688: LD_INT 1
15690: PUSH
15691: LD_INT 3
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 1
15700: PPUSH
15701: LD_INT 2
15703: PPUSH
15704: CALL_OW 12
15708: ARRAY
15709: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
15710: LD_INT 0
15712: PPUSH
15713: LD_INT 1
15715: PPUSH
15716: LD_INT 4
15718: PPUSH
15719: CALL_OW 12
15723: PPUSH
15724: LD_EXP 39
15728: PPUSH
15729: CALL_OW 380
// un := CreateHuman ;
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: CALL_OW 44
15742: ST_TO_ADDR
// al_force := al_force ^ un ;
15743: LD_ADDR_EXP 38
15747: PUSH
15748: LD_EXP 38
15752: PUSH
15753: LD_VAR 0 4
15757: ADD
15758: ST_TO_ADDR
// end ;
15759: GO 15680
15761: POP
15762: POP
// hc_importance := 100 ;
15763: LD_ADDR_OWVAR 32
15767: PUSH
15768: LD_INT 100
15770: ST_TO_ADDR
// uc_nation := 1 ;
15771: LD_ADDR_OWVAR 21
15775: PUSH
15776: LD_INT 1
15778: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15779: LD_INT 1
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_EXP 39
15789: PPUSH
15790: CALL_OW 380
// al_commander := CreateHuman ;
15794: LD_ADDR_EXP 37
15798: PUSH
15799: CALL_OW 44
15803: ST_TO_ADDR
// player_commander := al_commander ;
15804: LD_ADDR_EXP 10
15808: PUSH
15809: LD_EXP 37
15813: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15814: LD_ADDR_VAR 0 5
15818: PUSH
15819: LD_STRING text
15821: PPUSH
15822: LD_INT 9
15824: PUSH
15825: LD_INT 9
15827: PUSH
15828: LD_INT 8
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: LIST
15835: PUSH
15836: LD_OWVAR 67
15840: ARRAY
15841: PPUSH
15842: LD_INT 9
15844: PUSH
15845: LD_INT 9
15847: PUSH
15848: LD_INT 8
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: LIST
15855: PUSH
15856: LD_OWVAR 67
15860: ARRAY
15861: PPUSH
15862: LD_INT -5
15864: PUSH
15865: LD_EXP 37
15869: PUSH
15870: LD_INT -3
15872: PUSH
15873: LD_INT -2
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: LIST
15881: PUSH
15882: LD_EXP 38
15886: ADD
15887: PPUSH
15888: LD_INT 1
15890: PUSH
15891: LD_INT 3
15893: PUSH
15894: LD_INT 2
15896: PUSH
15897: LD_INT 1
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PUSH
15904: LD_INT 4
15906: PUSH
15907: LD_INT 1
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: LD_INT 9
15916: PUSH
15917: LD_INT 5
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: LIST
15924: LIST
15925: LIST
15926: LIST
15927: PPUSH
15928: CALL_OW 42
15932: ST_TO_ADDR
// team := team ^ al_commander ;
15933: LD_ADDR_VAR 0 5
15937: PUSH
15938: LD_VAR 0 5
15942: PUSH
15943: LD_EXP 37
15947: ADD
15948: ST_TO_ADDR
// for i = 1 to team do
15949: LD_ADDR_VAR 0 2
15953: PUSH
15954: DOUBLE
15955: LD_INT 1
15957: DEC
15958: ST_TO_ADDR
15959: LD_VAR 0 5
15963: PUSH
15964: FOR_TO
15965: IFFALSE 15990
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15967: LD_VAR 0 5
15971: PUSH
15972: LD_VAR 0 2
15976: ARRAY
15977: PPUSH
15978: LD_INT 15
15980: PPUSH
15981: LD_INT 0
15983: PPUSH
15984: CALL_OW 49
15988: GO 15964
15990: POP
15991: POP
// end ;
15992: LD_VAR 0 1
15996: RET
// export function RemoveAlliance ; var i ; begin
15997: LD_INT 0
15999: PPUSH
16000: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
16001: LD_INT 22
16003: PUSH
16004: LD_INT 7
16006: PUSH
16007: EMPTY
16008: LIST
16009: LIST
16010: PUSH
16011: LD_INT 30
16013: PUSH
16014: LD_INT 1
16016: PUSH
16017: EMPTY
16018: LIST
16019: LIST
16020: PUSH
16021: EMPTY
16022: LIST
16023: LIST
16024: PPUSH
16025: CALL_OW 69
16029: PUSH
16030: LD_INT 1
16032: ARRAY
16033: PPUSH
16034: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
16038: LD_ADDR_VAR 0 2
16042: PUSH
16043: LD_INT 22
16045: PUSH
16046: LD_INT 7
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: PUSH
16058: FOR_IN
16059: IFFALSE 16072
// RemoveUnit ( i ) ;
16061: LD_VAR 0 2
16065: PPUSH
16066: CALL_OW 64
16070: GO 16058
16072: POP
16073: POP
// end ;
16074: LD_VAR 0 1
16078: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
16079: LD_INT 0
16081: PPUSH
16082: PPUSH
16083: PPUSH
16084: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
16085: LD_INT 31
16087: PPUSH
16088: LD_INT 7
16090: PPUSH
16091: LD_INT 2
16093: PPUSH
16094: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
16098: LD_INT 32
16100: PPUSH
16101: LD_INT 7
16103: PPUSH
16104: LD_INT 2
16106: PPUSH
16107: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
16111: LD_INT 59
16113: PPUSH
16114: LD_INT 7
16116: PPUSH
16117: LD_INT 2
16119: PPUSH
16120: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16124: LD_ADDR_EXP 39
16128: PUSH
16129: LD_INT 5
16131: PUSH
16132: LD_INT 6
16134: PUSH
16135: LD_INT 7
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: LIST
16142: PUSH
16143: LD_OWVAR 67
16147: ARRAY
16148: ST_TO_ADDR
// al_force := [ ] ;
16149: LD_ADDR_EXP 38
16153: PUSH
16154: EMPTY
16155: ST_TO_ADDR
// al_vehs := [ ] ;
16156: LD_ADDR_EXP 44
16160: PUSH
16161: EMPTY
16162: ST_TO_ADDR
// uc_side := 7 ;
16163: LD_ADDR_OWVAR 20
16167: PUSH
16168: LD_INT 7
16170: ST_TO_ADDR
// uc_nation := 1 ;
16171: LD_ADDR_OWVAR 21
16175: PUSH
16176: LD_INT 1
16178: ST_TO_ADDR
// bc_type := b_oil_mine ;
16179: LD_ADDR_OWVAR 42
16183: PUSH
16184: LD_INT 29
16186: ST_TO_ADDR
// b := CreateBuilding ;
16187: LD_ADDR_VAR 0 4
16191: PUSH
16192: CALL_OW 46
16196: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
16197: LD_VAR 0 4
16201: PPUSH
16202: LD_INT 61
16204: PPUSH
16205: LD_INT 7
16207: PPUSH
16208: LD_INT 0
16210: PPUSH
16211: LD_INT 0
16213: PPUSH
16214: CALL_OW 50
// bc_type := b_siberite_mine ;
16218: LD_ADDR_OWVAR 42
16222: PUSH
16223: LD_INT 30
16225: ST_TO_ADDR
// b := CreateBuilding ;
16226: LD_ADDR_VAR 0 4
16230: PUSH
16231: CALL_OW 46
16235: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
16236: LD_VAR 0 4
16240: PPUSH
16241: LD_INT 69
16243: PPUSH
16244: LD_INT 13
16246: PPUSH
16247: LD_INT 0
16249: PPUSH
16250: LD_INT 0
16252: PPUSH
16253: CALL_OW 50
// hc_gallery :=  ;
16257: LD_ADDR_OWVAR 33
16261: PUSH
16262: LD_STRING 
16264: ST_TO_ADDR
// hc_name :=  ;
16265: LD_ADDR_OWVAR 26
16269: PUSH
16270: LD_STRING 
16272: ST_TO_ADDR
// hc_importance := 0 ;
16273: LD_ADDR_OWVAR 32
16277: PUSH
16278: LD_INT 0
16280: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
16281: LD_ADDR_VAR 0 2
16285: PUSH
16286: LD_INT 22
16288: PUSH
16289: LD_INT 7
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: PUSH
16296: LD_INT 30
16298: PUSH
16299: LD_INT 32
16301: PUSH
16302: EMPTY
16303: LIST
16304: LIST
16305: PUSH
16306: EMPTY
16307: LIST
16308: LIST
16309: PPUSH
16310: CALL_OW 69
16314: PUSH
16315: FOR_IN
16316: IFFALSE 16386
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16318: LD_ADDR_OWVAR 21
16322: PUSH
16323: LD_INT 1
16325: PUSH
16326: LD_INT 3
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: PUSH
16333: LD_INT 1
16335: PPUSH
16336: LD_INT 2
16338: PPUSH
16339: CALL_OW 12
16343: ARRAY
16344: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
16345: LD_INT 0
16347: PPUSH
16348: LD_INT 1
16350: PPUSH
16351: LD_EXP 39
16355: PPUSH
16356: CALL_OW 380
// un := CreateHuman ;
16360: LD_ADDR_VAR 0 3
16364: PUSH
16365: CALL_OW 44
16369: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
16370: LD_VAR 0 3
16374: PPUSH
16375: LD_VAR 0 2
16379: PPUSH
16380: CALL_OW 52
// end ;
16384: GO 16315
16386: POP
16387: POP
// for i = 1 to 3 do
16388: LD_ADDR_VAR 0 2
16392: PUSH
16393: DOUBLE
16394: LD_INT 1
16396: DEC
16397: ST_TO_ADDR
16398: LD_INT 3
16400: PUSH
16401: FOR_TO
16402: IFFALSE 16470
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16404: LD_ADDR_OWVAR 21
16408: PUSH
16409: LD_INT 1
16411: PUSH
16412: LD_INT 3
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PUSH
16419: LD_INT 1
16421: PPUSH
16422: LD_INT 2
16424: PPUSH
16425: CALL_OW 12
16429: ARRAY
16430: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
16431: LD_INT 0
16433: PPUSH
16434: LD_INT 4
16436: PPUSH
16437: LD_EXP 39
16441: PPUSH
16442: CALL_OW 380
// un := CreateHuman ;
16446: LD_ADDR_VAR 0 3
16450: PUSH
16451: CALL_OW 44
16455: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
16456: LD_VAR 0 3
16460: PPUSH
16461: LD_INT 164
16463: PPUSH
16464: CALL_OW 52
// end ;
16468: GO 16401
16470: POP
16471: POP
// for i = 1 to 6 do
16472: LD_ADDR_VAR 0 2
16476: PUSH
16477: DOUBLE
16478: LD_INT 1
16480: DEC
16481: ST_TO_ADDR
16482: LD_INT 6
16484: PUSH
16485: FOR_TO
16486: IFFALSE 16577
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16488: LD_ADDR_OWVAR 21
16492: PUSH
16493: LD_INT 1
16495: PUSH
16496: LD_INT 3
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 1
16505: PPUSH
16506: LD_INT 2
16508: PPUSH
16509: CALL_OW 12
16513: ARRAY
16514: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
16515: LD_INT 0
16517: PPUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 9
16523: PUSH
16524: LD_INT 9
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: LIST
16531: PUSH
16532: LD_INT 1
16534: PPUSH
16535: LD_INT 3
16537: PPUSH
16538: CALL_OW 12
16542: ARRAY
16543: PPUSH
16544: LD_EXP 39
16548: PPUSH
16549: CALL_OW 380
// un := CreateHuman ;
16553: LD_ADDR_VAR 0 3
16557: PUSH
16558: CALL_OW 44
16562: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
16563: LD_VAR 0 3
16567: PPUSH
16568: LD_INT 173
16570: PPUSH
16571: CALL_OW 52
// end ;
16575: GO 16485
16577: POP
16578: POP
// for i = 1 to 6 do
16579: LD_ADDR_VAR 0 2
16583: PUSH
16584: DOUBLE
16585: LD_INT 1
16587: DEC
16588: ST_TO_ADDR
16589: LD_INT 6
16591: PUSH
16592: FOR_TO
16593: IFFALSE 16691
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16595: LD_ADDR_OWVAR 21
16599: PUSH
16600: LD_INT 1
16602: PUSH
16603: LD_INT 3
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 1
16612: PPUSH
16613: LD_INT 2
16615: PPUSH
16616: CALL_OW 12
16620: ARRAY
16621: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
16622: LD_INT 0
16624: PPUSH
16625: LD_INT 3
16627: PPUSH
16628: LD_EXP 39
16632: PPUSH
16633: CALL_OW 380
// un := CreateHuman ;
16637: LD_ADDR_VAR 0 3
16641: PUSH
16642: CALL_OW 44
16646: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
16647: LD_VAR 0 3
16651: PPUSH
16652: LD_INT 22
16654: PUSH
16655: LD_INT 7
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: PUSH
16662: LD_INT 30
16664: PUSH
16665: LD_INT 3
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PPUSH
16676: CALL_OW 69
16680: PUSH
16681: LD_INT 1
16683: ARRAY
16684: PPUSH
16685: CALL_OW 52
// end ;
16689: GO 16592
16691: POP
16692: POP
// for i = 1 to 4 do
16693: LD_ADDR_VAR 0 2
16697: PUSH
16698: DOUBLE
16699: LD_INT 1
16701: DEC
16702: ST_TO_ADDR
16703: LD_INT 4
16705: PUSH
16706: FOR_TO
16707: IFFALSE 16775
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
16709: LD_ADDR_OWVAR 21
16713: PUSH
16714: LD_INT 1
16716: PUSH
16717: LD_INT 3
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: LD_INT 1
16726: PPUSH
16727: LD_INT 2
16729: PPUSH
16730: CALL_OW 12
16734: ARRAY
16735: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16736: LD_INT 0
16738: PPUSH
16739: LD_INT 2
16741: PPUSH
16742: LD_EXP 39
16746: PPUSH
16747: CALL_OW 380
// un := CreateHuman ;
16751: LD_ADDR_VAR 0 3
16755: PUSH
16756: CALL_OW 44
16760: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16761: LD_VAR 0 3
16765: PPUSH
16766: LD_INT 162
16768: PPUSH
16769: CALL_OW 52
// end ;
16773: GO 16706
16775: POP
16776: POP
// uc_nation := 3 ;
16777: LD_ADDR_OWVAR 21
16781: PUSH
16782: LD_INT 3
16784: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16785: LD_ADDR_OWVAR 37
16789: PUSH
16790: LD_INT 21
16792: ST_TO_ADDR
// vc_engine := engine_siberite ;
16793: LD_ADDR_OWVAR 39
16797: PUSH
16798: LD_INT 3
16800: ST_TO_ADDR
// vc_control := control_computer ;
16801: LD_ADDR_OWVAR 38
16805: PUSH
16806: LD_INT 3
16808: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16809: LD_ADDR_OWVAR 40
16813: PUSH
16814: LD_INT 51
16816: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16817: CALL_OW 45
16821: PPUSH
16822: LD_INT 49
16824: PPUSH
16825: LD_INT 13
16827: PPUSH
16828: LD_INT 0
16830: PPUSH
16831: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16835: LD_ADDR_EXP 46
16839: PUSH
16840: LD_INT 22
16842: PUSH
16843: LD_INT 7
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: LD_INT 30
16852: PUSH
16853: LD_INT 33
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PPUSH
16864: CALL_OW 69
16868: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16869: LD_ADDR_VAR 0 2
16873: PUSH
16874: DOUBLE
16875: LD_INT 1
16877: DEC
16878: ST_TO_ADDR
16879: LD_INT 22
16881: PUSH
16882: LD_INT 7
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: PUSH
16889: LD_INT 30
16891: PUSH
16892: LD_INT 33
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PUSH
16899: LD_INT 35
16901: PUSH
16902: LD_INT 0
16904: PUSH
16905: EMPTY
16906: LIST
16907: LIST
16908: PUSH
16909: EMPTY
16910: LIST
16911: LIST
16912: LIST
16913: PUSH
16914: EMPTY
16915: LIST
16916: PPUSH
16917: CALL_OW 69
16921: PUSH
16922: FOR_TO
16923: IFFALSE 16983
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16925: LD_INT 22
16927: PUSH
16928: LD_INT 7
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: LD_INT 30
16937: PUSH
16938: LD_INT 33
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PUSH
16945: LD_INT 35
16947: PUSH
16948: LD_INT 0
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: PPUSH
16963: CALL_OW 69
16967: PUSH
16968: LD_VAR 0 2
16972: ARRAY
16973: PPUSH
16974: LD_INT 49
16976: PPUSH
16977: CALL_OW 208
16981: GO 16922
16983: POP
16984: POP
// end ;
16985: LD_VAR 0 1
16989: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16990: LD_OWVAR 2
16994: PUSH
16995: LD_INT 1
16997: EQUAL
16998: IFFALSE 18166
17000: GO 17002
17002: DISABLE
17003: LD_INT 0
17005: PPUSH
17006: PPUSH
17007: PPUSH
17008: PPUSH
// begin enable ;
17009: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
17010: LD_ADDR_EXP 50
17014: PUSH
17015: LD_INT 22
17017: PUSH
17018: LD_INT 7
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: LD_INT 21
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
17044: LD_ADDR_EXP 48
17048: PUSH
17049: LD_INT 164
17051: PUSH
17052: LD_INT 197
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
17059: LD_ADDR_EXP 47
17063: PUSH
17064: LD_INT 22
17066: PUSH
17067: LD_INT 7
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: PUSH
17074: LD_INT 30
17076: PUSH
17077: LD_INT 1
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: PPUSH
17088: CALL_OW 69
17092: PUSH
17093: LD_INT 1
17095: ARRAY
17096: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
17097: LD_ADDR_EXP 49
17101: PUSH
17102: LD_INT 22
17104: PUSH
17105: LD_INT 7
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: PUSH
17112: LD_INT 30
17114: PUSH
17115: LD_INT 3
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PPUSH
17126: CALL_OW 69
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
17135: LD_INT 22
17137: PUSH
17138: LD_INT 7
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 34
17147: PUSH
17148: LD_INT 51
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: PPUSH
17159: CALL_OW 69
17163: IFFALSE 17203
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
17165: LD_ADDR_EXP 45
17169: PUSH
17170: LD_INT 22
17172: PUSH
17173: LD_INT 7
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: LD_INT 34
17182: PUSH
17183: LD_INT 51
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PPUSH
17194: CALL_OW 69
17198: PUSH
17199: LD_INT 1
17201: ARRAY
17202: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
17203: LD_ADDR_EXP 41
17207: PUSH
17208: LD_INT 22
17210: PUSH
17211: LD_INT 7
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: LD_INT 25
17220: PUSH
17221: LD_INT 9
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PPUSH
17232: CALL_OW 69
17236: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
17237: LD_ADDR_EXP 40
17241: PUSH
17242: LD_INT 22
17244: PUSH
17245: LD_INT 7
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: PUSH
17252: LD_INT 25
17254: PUSH
17255: LD_INT 2
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: PUSH
17262: EMPTY
17263: LIST
17264: LIST
17265: PPUSH
17266: CALL_OW 69
17270: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
17271: LD_ADDR_EXP 42
17275: PUSH
17276: LD_INT 22
17278: PUSH
17279: LD_INT 7
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: PUSH
17286: LD_INT 25
17288: PUSH
17289: LD_INT 3
17291: PUSH
17292: EMPTY
17293: LIST
17294: LIST
17295: PUSH
17296: EMPTY
17297: LIST
17298: LIST
17299: PPUSH
17300: CALL_OW 69
17304: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
17305: LD_ADDR_EXP 43
17309: PUSH
17310: LD_INT 22
17312: PUSH
17313: LD_INT 7
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: PUSH
17320: LD_INT 25
17322: PUSH
17323: LD_INT 4
17325: PUSH
17326: EMPTY
17327: LIST
17328: LIST
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 69
17338: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
17339: LD_EXP 41
17343: PPUSH
17344: LD_INT 81
17346: PUSH
17347: LD_INT 7
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PPUSH
17354: CALL_OW 69
17358: PPUSH
17359: CALL 1663 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
17363: LD_EXP 45
17367: PPUSH
17368: CALL_OW 314
17372: NOT
17373: PUSH
17374: LD_EXP 45
17378: PPUSH
17379: LD_INT 1
17381: PPUSH
17382: CALL_OW 289
17386: PUSH
17387: LD_INT 100
17389: LESS
17390: AND
17391: IFFALSE 17439
// begin cr := GetListOfCratesInArea ( us_crates ) ;
17393: LD_ADDR_VAR 0 4
17397: PUSH
17398: LD_INT 12
17400: PPUSH
17401: CALL_OW 435
17405: ST_TO_ADDR
// if cr then
17406: LD_VAR 0 4
17410: IFFALSE 17439
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
17412: LD_EXP 45
17416: PPUSH
17417: LD_VAR 0 4
17421: PUSH
17422: LD_INT 1
17424: ARRAY
17425: PPUSH
17426: LD_VAR 0 4
17430: PUSH
17431: LD_INT 2
17433: ARRAY
17434: PPUSH
17435: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
17439: LD_EXP 50
17443: PPUSH
17444: LD_INT 3
17446: PUSH
17447: LD_INT 24
17449: PUSH
17450: LD_INT 1000
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PPUSH
17461: CALL_OW 72
17465: IFFALSE 17595
// begin if al_eng then
17467: LD_EXP 40
17471: IFFALSE 17593
// for i = 1 to al_eng do
17473: LD_ADDR_VAR 0 1
17477: PUSH
17478: DOUBLE
17479: LD_INT 1
17481: DEC
17482: ST_TO_ADDR
17483: LD_EXP 40
17487: PUSH
17488: FOR_TO
17489: IFFALSE 17591
// if IsInUnit ( al_eng [ i ] ) then
17491: LD_EXP 40
17495: PUSH
17496: LD_VAR 0 1
17500: ARRAY
17501: PPUSH
17502: CALL_OW 310
17506: IFFALSE 17525
// ComExitBuilding ( al_eng [ i ] ) else
17508: LD_EXP 40
17512: PUSH
17513: LD_VAR 0 1
17517: ARRAY
17518: PPUSH
17519: CALL_OW 122
17523: GO 17589
// if not HasTask ( al_eng [ i ] ) then
17525: LD_EXP 40
17529: PUSH
17530: LD_VAR 0 1
17534: ARRAY
17535: PPUSH
17536: CALL_OW 314
17540: NOT
17541: IFFALSE 17589
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
17543: LD_EXP 40
17547: PUSH
17548: LD_VAR 0 1
17552: ARRAY
17553: PPUSH
17554: LD_EXP 50
17558: PPUSH
17559: LD_INT 3
17561: PUSH
17562: LD_INT 24
17564: PUSH
17565: LD_INT 1000
17567: PUSH
17568: EMPTY
17569: LIST
17570: LIST
17571: PUSH
17572: EMPTY
17573: LIST
17574: LIST
17575: PPUSH
17576: CALL_OW 72
17580: PUSH
17581: LD_INT 1
17583: ARRAY
17584: PPUSH
17585: CALL_OW 130
17589: GO 17488
17591: POP
17592: POP
// end else
17593: GO 17677
// if al_eng then
17595: LD_EXP 40
17599: IFFALSE 17677
// if not IsInUnit ( al_eng [ 1 ] ) then
17601: LD_EXP 40
17605: PUSH
17606: LD_INT 1
17608: ARRAY
17609: PPUSH
17610: CALL_OW 310
17614: NOT
17615: IFFALSE 17677
// for i = 1 to al_eng do
17617: LD_ADDR_VAR 0 1
17621: PUSH
17622: DOUBLE
17623: LD_INT 1
17625: DEC
17626: ST_TO_ADDR
17627: LD_EXP 40
17631: PUSH
17632: FOR_TO
17633: IFFALSE 17675
// if not IsInUnit ( al_eng [ i ] ) then
17635: LD_EXP 40
17639: PUSH
17640: LD_VAR 0 1
17644: ARRAY
17645: PPUSH
17646: CALL_OW 310
17650: NOT
17651: IFFALSE 17673
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
17653: LD_EXP 40
17657: PUSH
17658: LD_VAR 0 1
17662: ARRAY
17663: PPUSH
17664: LD_EXP 47
17668: PPUSH
17669: CALL_OW 120
17673: GO 17632
17675: POP
17676: POP
// if al_vehs then
17677: LD_EXP 44
17681: IFFALSE 17781
// if BuildingStatus ( al_fac ) = bs_idle then
17683: LD_EXP 49
17687: PPUSH
17688: CALL_OW 461
17692: PUSH
17693: LD_INT 2
17695: EQUAL
17696: IFFALSE 17781
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
17698: LD_EXP 49
17702: PPUSH
17703: LD_EXP 44
17707: PUSH
17708: LD_INT 1
17710: ARRAY
17711: PPUSH
17712: LD_EXP 44
17716: PUSH
17717: LD_INT 2
17719: ARRAY
17720: PPUSH
17721: LD_EXP 44
17725: PUSH
17726: LD_INT 3
17728: ARRAY
17729: PPUSH
17730: LD_EXP 44
17734: PUSH
17735: LD_INT 4
17737: ARRAY
17738: PPUSH
17739: CALL_OW 125
// for i = 1 to 4 do
17743: LD_ADDR_VAR 0 1
17747: PUSH
17748: DOUBLE
17749: LD_INT 1
17751: DEC
17752: ST_TO_ADDR
17753: LD_INT 4
17755: PUSH
17756: FOR_TO
17757: IFFALSE 17779
// al_vehs := Delete ( al_vehs , 1 ) ;
17759: LD_ADDR_EXP 44
17763: PUSH
17764: LD_EXP 44
17768: PPUSH
17769: LD_INT 1
17771: PPUSH
17772: CALL_OW 3
17776: ST_TO_ADDR
17777: GO 17756
17779: POP
17780: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17781: LD_EXP 38
17785: PUSH
17786: LD_INT 0
17788: EQUAL
17789: PUSH
17790: LD_OWVAR 1
17794: PUSH
17795: LD_INT 23100
17797: MOD
17798: PUSH
17799: LD_INT 0
17801: EQUAL
17802: AND
17803: IFFALSE 17917
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17805: LD_ADDR_VAR 0 1
17809: PUSH
17810: DOUBLE
17811: LD_INT 1
17813: DEC
17814: ST_TO_ADDR
17815: LD_INT 4
17817: PUSH
17818: LD_INT 5
17820: PUSH
17821: LD_INT 6
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: PUSH
17829: LD_OWVAR 67
17833: ARRAY
17834: PUSH
17835: FOR_TO
17836: IFFALSE 17915
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17838: LD_ADDR_EXP 44
17842: PUSH
17843: LD_EXP 44
17847: PUSH
17848: LD_INT 23
17850: ADD
17851: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17852: LD_ADDR_EXP 44
17856: PUSH
17857: LD_EXP 44
17861: PUSH
17862: LD_INT 1
17864: ADD
17865: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17866: LD_ADDR_EXP 44
17870: PUSH
17871: LD_EXP 44
17875: PUSH
17876: LD_INT 3
17878: ADD
17879: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17880: LD_ADDR_EXP 44
17884: PUSH
17885: LD_EXP 44
17889: PUSH
17890: LD_INT 46
17892: PUSH
17893: LD_INT 47
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 1
17902: PPUSH
17903: LD_INT 2
17905: PPUSH
17906: CALL_OW 12
17910: ARRAY
17911: ADD
17912: ST_TO_ADDR
// end ;
17913: GO 17835
17915: POP
17916: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17917: LD_INT 22
17919: PUSH
17920: LD_INT 7
17922: PUSH
17923: EMPTY
17924: LIST
17925: LIST
17926: PUSH
17927: LD_INT 34
17929: PUSH
17930: LD_INT 51
17932: PUSH
17933: EMPTY
17934: LIST
17935: LIST
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PPUSH
17941: CALL_OW 69
17945: PUSH
17946: LD_INT 0
17948: EQUAL
17949: IFFALSE 17972
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17951: LD_EXP 49
17955: PPUSH
17956: LD_INT 21
17958: PPUSH
17959: LD_INT 1
17961: PPUSH
17962: LD_INT 3
17964: PPUSH
17965: LD_INT 51
17967: PPUSH
17968: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17972: LD_EXP 38
17976: PUSH
17977: LD_OWVAR 1
17981: PUSH
17982: LD_INT 25200
17984: MOD
17985: PUSH
17986: LD_INT 0
17988: EQUAL
17989: AND
17990: IFFALSE 18053
// begin for i = 1 to al_force do
17992: LD_ADDR_VAR 0 1
17996: PUSH
17997: DOUBLE
17998: LD_INT 1
18000: DEC
18001: ST_TO_ADDR
18002: LD_EXP 38
18006: PUSH
18007: FOR_TO
18008: IFFALSE 18051
// if GetTag ( al_force [ i ] ) <> 11 then
18010: LD_EXP 38
18014: PUSH
18015: LD_VAR 0 1
18019: ARRAY
18020: PPUSH
18021: CALL_OW 110
18025: PUSH
18026: LD_INT 11
18028: NONEQUAL
18029: IFFALSE 18049
// SetTag ( al_force [ i ] , 11 ) ;
18031: LD_EXP 38
18035: PUSH
18036: LD_VAR 0 1
18040: ARRAY
18041: PPUSH
18042: LD_INT 11
18044: PPUSH
18045: CALL_OW 109
18049: GO 18007
18051: POP
18052: POP
// end ; if al_force then
18053: LD_EXP 38
18057: IFFALSE 18166
// for i = 1 to al_force do
18059: LD_ADDR_VAR 0 1
18063: PUSH
18064: DOUBLE
18065: LD_INT 1
18067: DEC
18068: ST_TO_ADDR
18069: LD_EXP 38
18073: PUSH
18074: FOR_TO
18075: IFFALSE 18164
// begin if GetTag ( al_force [ i ] ) = 11 then
18077: LD_EXP 38
18081: PUSH
18082: LD_VAR 0 1
18086: ARRAY
18087: PPUSH
18088: CALL_OW 110
18092: PUSH
18093: LD_INT 11
18095: EQUAL
18096: IFFALSE 18162
// begin if not HasTask ( al_force [ i ] ) then
18098: LD_EXP 38
18102: PUSH
18103: LD_VAR 0 1
18107: ARRAY
18108: PPUSH
18109: CALL_OW 314
18113: NOT
18114: IFFALSE 18162
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
18116: LD_EXP 38
18120: PUSH
18121: LD_VAR 0 1
18125: ARRAY
18126: PPUSH
18127: LD_INT 81
18129: PUSH
18130: LD_INT 7
18132: PUSH
18133: EMPTY
18134: LIST
18135: LIST
18136: PPUSH
18137: CALL_OW 69
18141: PPUSH
18142: LD_EXP 38
18146: PUSH
18147: LD_VAR 0 1
18151: ARRAY
18152: PPUSH
18153: CALL_OW 74
18157: PPUSH
18158: CALL_OW 115
// end ; end ;
18162: GO 18074
18164: POP
18165: POP
// end ; end_of_file
18166: PPOPN 4
18168: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
18169: LD_INT 0
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
18176: LD_ADDR_EXP 53
18180: PUSH
18181: LD_INT 7
18183: PUSH
18184: LD_INT 6
18186: PUSH
18187: LD_INT 5
18189: PUSH
18190: EMPTY
18191: LIST
18192: LIST
18193: LIST
18194: PUSH
18195: LD_OWVAR 67
18199: ARRAY
18200: ST_TO_ADDR
// ar_force := [ ] ;
18201: LD_ADDR_EXP 52
18205: PUSH
18206: EMPTY
18207: ST_TO_ADDR
// RemoveAlliance ;
18208: CALL 15997 0 0
// RemoveEnvironmentArea ( evn ) ;
18212: LD_INT 17
18214: PPUSH
18215: CALL_OW 355
// your_side := 2 ;
18219: LD_ADDR_OWVAR 2
18223: PUSH
18224: LD_INT 2
18226: ST_TO_ADDR
// uc_side := 2 ;
18227: LD_ADDR_OWVAR 20
18231: PUSH
18232: LD_INT 2
18234: ST_TO_ADDR
// uc_nation := nation_arabian ;
18235: LD_ADDR_OWVAR 21
18239: PUSH
18240: LD_INT 2
18242: ST_TO_ADDR
// hc_gallery :=  ;
18243: LD_ADDR_OWVAR 33
18247: PUSH
18248: LD_STRING 
18250: ST_TO_ADDR
// hc_name :=  ;
18251: LD_ADDR_OWVAR 26
18255: PUSH
18256: LD_STRING 
18258: ST_TO_ADDR
// hc_importance := 0 ;
18259: LD_ADDR_OWVAR 32
18263: PUSH
18264: LD_INT 0
18266: ST_TO_ADDR
// for i = 1 to 15 do
18267: LD_ADDR_VAR 0 2
18271: PUSH
18272: DOUBLE
18273: LD_INT 1
18275: DEC
18276: ST_TO_ADDR
18277: LD_INT 15
18279: PUSH
18280: FOR_TO
18281: IFFALSE 18334
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
18283: LD_INT 0
18285: PPUSH
18286: LD_INT 1
18288: PPUSH
18289: LD_INT 4
18291: PPUSH
18292: CALL_OW 12
18296: PPUSH
18297: LD_EXP 53
18301: PPUSH
18302: CALL_OW 380
// un := CreateHuman ;
18306: LD_ADDR_VAR 0 4
18310: PUSH
18311: CALL_OW 44
18315: ST_TO_ADDR
// ar_force := ar_force ^ un ;
18316: LD_ADDR_EXP 52
18320: PUSH
18321: LD_EXP 52
18325: PUSH
18326: LD_VAR 0 4
18330: ADD
18331: ST_TO_ADDR
// end ;
18332: GO 18280
18334: POP
18335: POP
// hc_importance := 100 ;
18336: LD_ADDR_OWVAR 32
18340: PUSH
18341: LD_INT 100
18343: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
18344: LD_INT 1
18346: PPUSH
18347: LD_INT 11
18349: PPUSH
18350: LD_EXP 53
18354: PPUSH
18355: CALL_OW 380
// ar_commander := CreateHuman ;
18359: LD_ADDR_EXP 51
18363: PUSH
18364: CALL_OW 44
18368: ST_TO_ADDR
// player_commander := ar_commander ;
18369: LD_ADDR_EXP 10
18373: PUSH
18374: LD_EXP 51
18378: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
18379: LD_ADDR_VAR 0 5
18383: PUSH
18384: LD_STRING text
18386: PPUSH
18387: LD_INT 11
18389: PUSH
18390: LD_INT 10
18392: PUSH
18393: LD_INT 9
18395: PUSH
18396: EMPTY
18397: LIST
18398: LIST
18399: LIST
18400: PUSH
18401: LD_OWVAR 67
18405: ARRAY
18406: PPUSH
18407: LD_INT 11
18409: PUSH
18410: LD_INT 10
18412: PUSH
18413: LD_INT 9
18415: PUSH
18416: EMPTY
18417: LIST
18418: LIST
18419: LIST
18420: PUSH
18421: LD_OWVAR 67
18425: ARRAY
18426: PPUSH
18427: LD_INT -5
18429: PUSH
18430: LD_EXP 51
18434: PUSH
18435: LD_INT -3
18437: PUSH
18438: LD_INT -2
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: PUSH
18447: LD_EXP 52
18451: ADD
18452: PPUSH
18453: LD_INT 1
18455: PUSH
18456: LD_INT 3
18458: PUSH
18459: LD_INT 2
18461: PUSH
18462: LD_INT 1
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PUSH
18469: LD_INT 4
18471: PUSH
18472: LD_INT 1
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PUSH
18479: LD_INT 8
18481: PUSH
18482: EMPTY
18483: LIST
18484: LIST
18485: LIST
18486: LIST
18487: LIST
18488: PPUSH
18489: CALL_OW 42
18493: ST_TO_ADDR
// team := team ^ ar_commander ;
18494: LD_ADDR_VAR 0 5
18498: PUSH
18499: LD_VAR 0 5
18503: PUSH
18504: LD_EXP 51
18508: ADD
18509: ST_TO_ADDR
// for i = 1 to team do
18510: LD_ADDR_VAR 0 2
18514: PUSH
18515: DOUBLE
18516: LD_INT 1
18518: DEC
18519: ST_TO_ADDR
18520: LD_VAR 0 5
18524: PUSH
18525: FOR_TO
18526: IFFALSE 18551
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
18528: LD_VAR 0 5
18532: PUSH
18533: LD_VAR 0 2
18537: ARRAY
18538: PPUSH
18539: LD_INT 16
18541: PPUSH
18542: LD_INT 0
18544: PPUSH
18545: CALL_OW 49
18549: GO 18525
18551: POP
18552: POP
// uc_side := 0 ;
18553: LD_ADDR_OWVAR 20
18557: PUSH
18558: LD_INT 0
18560: ST_TO_ADDR
// uc_nation := 0 ;
18561: LD_ADDR_OWVAR 21
18565: PUSH
18566: LD_INT 0
18568: ST_TO_ADDR
// vc_chassis := 31 ;
18569: LD_ADDR_OWVAR 37
18573: PUSH
18574: LD_INT 31
18576: ST_TO_ADDR
// vc_control := control_rider ;
18577: LD_ADDR_OWVAR 38
18581: PUSH
18582: LD_INT 4
18584: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
18585: CALL_OW 45
18589: PPUSH
18590: LD_INT 96
18592: PPUSH
18593: LD_INT 20
18595: PPUSH
18596: LD_INT 0
18598: PPUSH
18599: CALL_OW 48
// end ; end_of_file
18603: LD_VAR 0 1
18607: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18608: GO 18610
18610: DISABLE
// begin ru_radar := 98 ;
18611: LD_ADDR_EXP 54
18615: PUSH
18616: LD_INT 98
18618: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18619: LD_ADDR_EXP 55
18623: PUSH
18624: LD_INT 89
18626: ST_TO_ADDR
// us_hack := 99 ;
18627: LD_ADDR_EXP 56
18631: PUSH
18632: LD_INT 99
18634: ST_TO_ADDR
// us_artillery := 97 ;
18635: LD_ADDR_EXP 57
18639: PUSH
18640: LD_INT 97
18642: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18643: LD_ADDR_EXP 58
18647: PUSH
18648: LD_INT 91
18650: ST_TO_ADDR
// tech_Artillery := 80 ;
18651: LD_ADDR_EXP 59
18655: PUSH
18656: LD_INT 80
18658: ST_TO_ADDR
// tech_RadMat := 81 ;
18659: LD_ADDR_EXP 60
18663: PUSH
18664: LD_INT 81
18666: ST_TO_ADDR
// tech_BasicTools := 82 ;
18667: LD_ADDR_EXP 61
18671: PUSH
18672: LD_INT 82
18674: ST_TO_ADDR
// tech_Cargo := 83 ;
18675: LD_ADDR_EXP 62
18679: PUSH
18680: LD_INT 83
18682: ST_TO_ADDR
// tech_Track := 84 ;
18683: LD_ADDR_EXP 63
18687: PUSH
18688: LD_INT 84
18690: ST_TO_ADDR
// tech_Crane := 85 ;
18691: LD_ADDR_EXP 64
18695: PUSH
18696: LD_INT 85
18698: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18699: LD_ADDR_EXP 65
18703: PUSH
18704: LD_INT 86
18706: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18707: LD_ADDR_EXP 66
18711: PUSH
18712: LD_INT 87
18714: ST_TO_ADDR
// end ; end_of_file end_of_file
18715: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18716: GO 18718
18718: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18719: LD_STRING initStreamRollete();
18721: PPUSH
18722: CALL_OW 559
// InitStreamMode ;
18726: CALL 18735 0 0
// DefineStreamItems ( ) ;
18730: CALL 19175 0 0
// end ;
18734: END
// function InitStreamMode ; begin
18735: LD_INT 0
18737: PPUSH
// streamModeActive := false ;
18738: LD_ADDR_EXP 67
18742: PUSH
18743: LD_INT 0
18745: ST_TO_ADDR
// normalCounter := 36 ;
18746: LD_ADDR_EXP 68
18750: PUSH
18751: LD_INT 36
18753: ST_TO_ADDR
// hardcoreCounter := 16 ;
18754: LD_ADDR_EXP 69
18758: PUSH
18759: LD_INT 16
18761: ST_TO_ADDR
// sRocket := false ;
18762: LD_ADDR_EXP 72
18766: PUSH
18767: LD_INT 0
18769: ST_TO_ADDR
// sSpeed := false ;
18770: LD_ADDR_EXP 71
18774: PUSH
18775: LD_INT 0
18777: ST_TO_ADDR
// sEngine := false ;
18778: LD_ADDR_EXP 73
18782: PUSH
18783: LD_INT 0
18785: ST_TO_ADDR
// sSpec := false ;
18786: LD_ADDR_EXP 70
18790: PUSH
18791: LD_INT 0
18793: ST_TO_ADDR
// sLevel := false ;
18794: LD_ADDR_EXP 74
18798: PUSH
18799: LD_INT 0
18801: ST_TO_ADDR
// sArmoury := false ;
18802: LD_ADDR_EXP 75
18806: PUSH
18807: LD_INT 0
18809: ST_TO_ADDR
// sRadar := false ;
18810: LD_ADDR_EXP 76
18814: PUSH
18815: LD_INT 0
18817: ST_TO_ADDR
// sBunker := false ;
18818: LD_ADDR_EXP 77
18822: PUSH
18823: LD_INT 0
18825: ST_TO_ADDR
// sHack := false ;
18826: LD_ADDR_EXP 78
18830: PUSH
18831: LD_INT 0
18833: ST_TO_ADDR
// sFire := false ;
18834: LD_ADDR_EXP 79
18838: PUSH
18839: LD_INT 0
18841: ST_TO_ADDR
// sRefresh := false ;
18842: LD_ADDR_EXP 80
18846: PUSH
18847: LD_INT 0
18849: ST_TO_ADDR
// sExp := false ;
18850: LD_ADDR_EXP 81
18854: PUSH
18855: LD_INT 0
18857: ST_TO_ADDR
// sDepot := false ;
18858: LD_ADDR_EXP 82
18862: PUSH
18863: LD_INT 0
18865: ST_TO_ADDR
// sFlag := false ;
18866: LD_ADDR_EXP 83
18870: PUSH
18871: LD_INT 0
18873: ST_TO_ADDR
// sKamikadze := false ;
18874: LD_ADDR_EXP 91
18878: PUSH
18879: LD_INT 0
18881: ST_TO_ADDR
// sTroll := false ;
18882: LD_ADDR_EXP 92
18886: PUSH
18887: LD_INT 0
18889: ST_TO_ADDR
// sSlow := false ;
18890: LD_ADDR_EXP 93
18894: PUSH
18895: LD_INT 0
18897: ST_TO_ADDR
// sLack := false ;
18898: LD_ADDR_EXP 94
18902: PUSH
18903: LD_INT 0
18905: ST_TO_ADDR
// sTank := false ;
18906: LD_ADDR_EXP 96
18910: PUSH
18911: LD_INT 0
18913: ST_TO_ADDR
// sRemote := false ;
18914: LD_ADDR_EXP 97
18918: PUSH
18919: LD_INT 0
18921: ST_TO_ADDR
// sPowell := false ;
18922: LD_ADDR_EXP 98
18926: PUSH
18927: LD_INT 0
18929: ST_TO_ADDR
// sTeleport := false ;
18930: LD_ADDR_EXP 101
18934: PUSH
18935: LD_INT 0
18937: ST_TO_ADDR
// sOilTower := false ;
18938: LD_ADDR_EXP 103
18942: PUSH
18943: LD_INT 0
18945: ST_TO_ADDR
// sShovel := false ;
18946: LD_ADDR_EXP 104
18950: PUSH
18951: LD_INT 0
18953: ST_TO_ADDR
// sSheik := false ;
18954: LD_ADDR_EXP 105
18958: PUSH
18959: LD_INT 0
18961: ST_TO_ADDR
// sEarthquake := false ;
18962: LD_ADDR_EXP 107
18966: PUSH
18967: LD_INT 0
18969: ST_TO_ADDR
// sAI := false ;
18970: LD_ADDR_EXP 108
18974: PUSH
18975: LD_INT 0
18977: ST_TO_ADDR
// sCargo := false ;
18978: LD_ADDR_EXP 111
18982: PUSH
18983: LD_INT 0
18985: ST_TO_ADDR
// sDLaser := false ;
18986: LD_ADDR_EXP 112
18990: PUSH
18991: LD_INT 0
18993: ST_TO_ADDR
// sExchange := false ;
18994: LD_ADDR_EXP 113
18998: PUSH
18999: LD_INT 0
19001: ST_TO_ADDR
// sFac := false ;
19002: LD_ADDR_EXP 114
19006: PUSH
19007: LD_INT 0
19009: ST_TO_ADDR
// sPower := false ;
19010: LD_ADDR_EXP 115
19014: PUSH
19015: LD_INT 0
19017: ST_TO_ADDR
// sRandom := false ;
19018: LD_ADDR_EXP 116
19022: PUSH
19023: LD_INT 0
19025: ST_TO_ADDR
// sShield := false ;
19026: LD_ADDR_EXP 117
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// sTime := false ;
19034: LD_ADDR_EXP 118
19038: PUSH
19039: LD_INT 0
19041: ST_TO_ADDR
// sTools := false ;
19042: LD_ADDR_EXP 119
19046: PUSH
19047: LD_INT 0
19049: ST_TO_ADDR
// sSold := false ;
19050: LD_ADDR_EXP 84
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// sDiff := false ;
19058: LD_ADDR_EXP 85
19062: PUSH
19063: LD_INT 0
19065: ST_TO_ADDR
// sFog := false ;
19066: LD_ADDR_EXP 88
19070: PUSH
19071: LD_INT 0
19073: ST_TO_ADDR
// sReset := false ;
19074: LD_ADDR_EXP 89
19078: PUSH
19079: LD_INT 0
19081: ST_TO_ADDR
// sSun := false ;
19082: LD_ADDR_EXP 90
19086: PUSH
19087: LD_INT 0
19089: ST_TO_ADDR
// sTiger := false ;
19090: LD_ADDR_EXP 86
19094: PUSH
19095: LD_INT 0
19097: ST_TO_ADDR
// sBomb := false ;
19098: LD_ADDR_EXP 87
19102: PUSH
19103: LD_INT 0
19105: ST_TO_ADDR
// sWound := false ;
19106: LD_ADDR_EXP 95
19110: PUSH
19111: LD_INT 0
19113: ST_TO_ADDR
// sBetray := false ;
19114: LD_ADDR_EXP 99
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// sContamin := false ;
19122: LD_ADDR_EXP 100
19126: PUSH
19127: LD_INT 0
19129: ST_TO_ADDR
// sOil := false ;
19130: LD_ADDR_EXP 102
19134: PUSH
19135: LD_INT 0
19137: ST_TO_ADDR
// sStu := false ;
19138: LD_ADDR_EXP 106
19142: PUSH
19143: LD_INT 0
19145: ST_TO_ADDR
// sBazooka := false ;
19146: LD_ADDR_EXP 109
19150: PUSH
19151: LD_INT 0
19153: ST_TO_ADDR
// sMortar := false ;
19154: LD_ADDR_EXP 110
19158: PUSH
19159: LD_INT 0
19161: ST_TO_ADDR
// sRanger := false ;
19162: LD_ADDR_EXP 120
19166: PUSH
19167: LD_INT 0
19169: ST_TO_ADDR
// end ;
19170: LD_VAR 0 1
19174: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19175: LD_INT 0
19177: PPUSH
19178: PPUSH
19179: PPUSH
19180: PPUSH
19181: PPUSH
// result := [ ] ;
19182: LD_ADDR_VAR 0 1
19186: PUSH
19187: EMPTY
19188: ST_TO_ADDR
// if campaign_id = 1 then
19189: LD_OWVAR 69
19193: PUSH
19194: LD_INT 1
19196: EQUAL
19197: IFFALSE 22135
// begin case mission_number of 1 :
19199: LD_OWVAR 70
19203: PUSH
19204: LD_INT 1
19206: DOUBLE
19207: EQUAL
19208: IFTRUE 19212
19210: GO 19276
19212: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19213: LD_ADDR_VAR 0 1
19217: PUSH
19218: LD_INT 2
19220: PUSH
19221: LD_INT 4
19223: PUSH
19224: LD_INT 11
19226: PUSH
19227: LD_INT 12
19229: PUSH
19230: LD_INT 15
19232: PUSH
19233: LD_INT 16
19235: PUSH
19236: LD_INT 22
19238: PUSH
19239: LD_INT 23
19241: PUSH
19242: LD_INT 26
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: LIST
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: LIST
19255: PUSH
19256: LD_INT 101
19258: PUSH
19259: LD_INT 102
19261: PUSH
19262: LD_INT 106
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: ST_TO_ADDR
19274: GO 22133
19276: LD_INT 2
19278: DOUBLE
19279: EQUAL
19280: IFTRUE 19284
19282: GO 19356
19284: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19285: LD_ADDR_VAR 0 1
19289: PUSH
19290: LD_INT 2
19292: PUSH
19293: LD_INT 4
19295: PUSH
19296: LD_INT 11
19298: PUSH
19299: LD_INT 12
19301: PUSH
19302: LD_INT 15
19304: PUSH
19305: LD_INT 16
19307: PUSH
19308: LD_INT 22
19310: PUSH
19311: LD_INT 23
19313: PUSH
19314: LD_INT 26
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: LIST
19321: LIST
19322: LIST
19323: LIST
19324: LIST
19325: LIST
19326: LIST
19327: PUSH
19328: LD_INT 101
19330: PUSH
19331: LD_INT 102
19333: PUSH
19334: LD_INT 105
19336: PUSH
19337: LD_INT 106
19339: PUSH
19340: LD_INT 108
19342: PUSH
19343: EMPTY
19344: LIST
19345: LIST
19346: LIST
19347: LIST
19348: LIST
19349: PUSH
19350: EMPTY
19351: LIST
19352: LIST
19353: ST_TO_ADDR
19354: GO 22133
19356: LD_INT 3
19358: DOUBLE
19359: EQUAL
19360: IFTRUE 19364
19362: GO 19440
19364: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19365: LD_ADDR_VAR 0 1
19369: PUSH
19370: LD_INT 2
19372: PUSH
19373: LD_INT 4
19375: PUSH
19376: LD_INT 5
19378: PUSH
19379: LD_INT 11
19381: PUSH
19382: LD_INT 12
19384: PUSH
19385: LD_INT 15
19387: PUSH
19388: LD_INT 16
19390: PUSH
19391: LD_INT 22
19393: PUSH
19394: LD_INT 26
19396: PUSH
19397: LD_INT 36
19399: PUSH
19400: EMPTY
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: PUSH
19412: LD_INT 101
19414: PUSH
19415: LD_INT 102
19417: PUSH
19418: LD_INT 105
19420: PUSH
19421: LD_INT 106
19423: PUSH
19424: LD_INT 108
19426: PUSH
19427: EMPTY
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: ST_TO_ADDR
19438: GO 22133
19440: LD_INT 4
19442: DOUBLE
19443: EQUAL
19444: IFTRUE 19448
19446: GO 19532
19448: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19449: LD_ADDR_VAR 0 1
19453: PUSH
19454: LD_INT 2
19456: PUSH
19457: LD_INT 4
19459: PUSH
19460: LD_INT 5
19462: PUSH
19463: LD_INT 8
19465: PUSH
19466: LD_INT 11
19468: PUSH
19469: LD_INT 12
19471: PUSH
19472: LD_INT 15
19474: PUSH
19475: LD_INT 16
19477: PUSH
19478: LD_INT 22
19480: PUSH
19481: LD_INT 23
19483: PUSH
19484: LD_INT 26
19486: PUSH
19487: LD_INT 36
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: PUSH
19504: LD_INT 101
19506: PUSH
19507: LD_INT 102
19509: PUSH
19510: LD_INT 105
19512: PUSH
19513: LD_INT 106
19515: PUSH
19516: LD_INT 108
19518: PUSH
19519: EMPTY
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: ST_TO_ADDR
19530: GO 22133
19532: LD_INT 5
19534: DOUBLE
19535: EQUAL
19536: IFTRUE 19540
19538: GO 19640
19540: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19541: LD_ADDR_VAR 0 1
19545: PUSH
19546: LD_INT 2
19548: PUSH
19549: LD_INT 4
19551: PUSH
19552: LD_INT 5
19554: PUSH
19555: LD_INT 6
19557: PUSH
19558: LD_INT 8
19560: PUSH
19561: LD_INT 11
19563: PUSH
19564: LD_INT 12
19566: PUSH
19567: LD_INT 15
19569: PUSH
19570: LD_INT 16
19572: PUSH
19573: LD_INT 22
19575: PUSH
19576: LD_INT 23
19578: PUSH
19579: LD_INT 25
19581: PUSH
19582: LD_INT 26
19584: PUSH
19585: LD_INT 36
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: LIST
19593: LIST
19594: LIST
19595: LIST
19596: LIST
19597: LIST
19598: LIST
19599: LIST
19600: LIST
19601: LIST
19602: LIST
19603: PUSH
19604: LD_INT 101
19606: PUSH
19607: LD_INT 102
19609: PUSH
19610: LD_INT 105
19612: PUSH
19613: LD_INT 106
19615: PUSH
19616: LD_INT 108
19618: PUSH
19619: LD_INT 109
19621: PUSH
19622: LD_INT 112
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: ST_TO_ADDR
19638: GO 22133
19640: LD_INT 6
19642: DOUBLE
19643: EQUAL
19644: IFTRUE 19648
19646: GO 19768
19648: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19649: LD_ADDR_VAR 0 1
19653: PUSH
19654: LD_INT 2
19656: PUSH
19657: LD_INT 4
19659: PUSH
19660: LD_INT 5
19662: PUSH
19663: LD_INT 6
19665: PUSH
19666: LD_INT 8
19668: PUSH
19669: LD_INT 11
19671: PUSH
19672: LD_INT 12
19674: PUSH
19675: LD_INT 15
19677: PUSH
19678: LD_INT 16
19680: PUSH
19681: LD_INT 20
19683: PUSH
19684: LD_INT 21
19686: PUSH
19687: LD_INT 22
19689: PUSH
19690: LD_INT 23
19692: PUSH
19693: LD_INT 25
19695: PUSH
19696: LD_INT 26
19698: PUSH
19699: LD_INT 30
19701: PUSH
19702: LD_INT 31
19704: PUSH
19705: LD_INT 32
19707: PUSH
19708: LD_INT 36
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: PUSH
19732: LD_INT 101
19734: PUSH
19735: LD_INT 102
19737: PUSH
19738: LD_INT 105
19740: PUSH
19741: LD_INT 106
19743: PUSH
19744: LD_INT 108
19746: PUSH
19747: LD_INT 109
19749: PUSH
19750: LD_INT 112
19752: PUSH
19753: EMPTY
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 22133
19768: LD_INT 7
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19876
19776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19777: LD_ADDR_VAR 0 1
19781: PUSH
19782: LD_INT 2
19784: PUSH
19785: LD_INT 4
19787: PUSH
19788: LD_INT 5
19790: PUSH
19791: LD_INT 7
19793: PUSH
19794: LD_INT 11
19796: PUSH
19797: LD_INT 12
19799: PUSH
19800: LD_INT 15
19802: PUSH
19803: LD_INT 16
19805: PUSH
19806: LD_INT 20
19808: PUSH
19809: LD_INT 21
19811: PUSH
19812: LD_INT 22
19814: PUSH
19815: LD_INT 23
19817: PUSH
19818: LD_INT 25
19820: PUSH
19821: LD_INT 26
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: LIST
19828: LIST
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: LIST
19838: LIST
19839: PUSH
19840: LD_INT 101
19842: PUSH
19843: LD_INT 102
19845: PUSH
19846: LD_INT 103
19848: PUSH
19849: LD_INT 105
19851: PUSH
19852: LD_INT 106
19854: PUSH
19855: LD_INT 108
19857: PUSH
19858: LD_INT 112
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: ST_TO_ADDR
19874: GO 22133
19876: LD_INT 8
19878: DOUBLE
19879: EQUAL
19880: IFTRUE 19884
19882: GO 20012
19884: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19885: LD_ADDR_VAR 0 1
19889: PUSH
19890: LD_INT 2
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: LD_INT 5
19898: PUSH
19899: LD_INT 6
19901: PUSH
19902: LD_INT 7
19904: PUSH
19905: LD_INT 8
19907: PUSH
19908: LD_INT 11
19910: PUSH
19911: LD_INT 12
19913: PUSH
19914: LD_INT 15
19916: PUSH
19917: LD_INT 16
19919: PUSH
19920: LD_INT 20
19922: PUSH
19923: LD_INT 21
19925: PUSH
19926: LD_INT 22
19928: PUSH
19929: LD_INT 23
19931: PUSH
19932: LD_INT 25
19934: PUSH
19935: LD_INT 26
19937: PUSH
19938: LD_INT 30
19940: PUSH
19941: LD_INT 31
19943: PUSH
19944: LD_INT 32
19946: PUSH
19947: LD_INT 36
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: PUSH
19972: LD_INT 101
19974: PUSH
19975: LD_INT 102
19977: PUSH
19978: LD_INT 103
19980: PUSH
19981: LD_INT 105
19983: PUSH
19984: LD_INT 106
19986: PUSH
19987: LD_INT 108
19989: PUSH
19990: LD_INT 109
19992: PUSH
19993: LD_INT 112
19995: PUSH
19996: EMPTY
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: ST_TO_ADDR
20010: GO 22133
20012: LD_INT 9
20014: DOUBLE
20015: EQUAL
20016: IFTRUE 20020
20018: GO 20156
20020: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
20021: LD_ADDR_VAR 0 1
20025: PUSH
20026: LD_INT 2
20028: PUSH
20029: LD_INT 4
20031: PUSH
20032: LD_INT 5
20034: PUSH
20035: LD_INT 6
20037: PUSH
20038: LD_INT 7
20040: PUSH
20041: LD_INT 8
20043: PUSH
20044: LD_INT 11
20046: PUSH
20047: LD_INT 12
20049: PUSH
20050: LD_INT 15
20052: PUSH
20053: LD_INT 16
20055: PUSH
20056: LD_INT 20
20058: PUSH
20059: LD_INT 21
20061: PUSH
20062: LD_INT 22
20064: PUSH
20065: LD_INT 23
20067: PUSH
20068: LD_INT 25
20070: PUSH
20071: LD_INT 26
20073: PUSH
20074: LD_INT 28
20076: PUSH
20077: LD_INT 30
20079: PUSH
20080: LD_INT 31
20082: PUSH
20083: LD_INT 32
20085: PUSH
20086: LD_INT 36
20088: PUSH
20089: EMPTY
20090: LIST
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: LIST
20103: LIST
20104: LIST
20105: LIST
20106: LIST
20107: LIST
20108: LIST
20109: LIST
20110: LIST
20111: PUSH
20112: LD_INT 101
20114: PUSH
20115: LD_INT 102
20117: PUSH
20118: LD_INT 103
20120: PUSH
20121: LD_INT 105
20123: PUSH
20124: LD_INT 106
20126: PUSH
20127: LD_INT 108
20129: PUSH
20130: LD_INT 109
20132: PUSH
20133: LD_INT 112
20135: PUSH
20136: LD_INT 114
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: ST_TO_ADDR
20154: GO 22133
20156: LD_INT 10
20158: DOUBLE
20159: EQUAL
20160: IFTRUE 20164
20162: GO 20348
20164: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20165: LD_ADDR_VAR 0 1
20169: PUSH
20170: LD_INT 2
20172: PUSH
20173: LD_INT 4
20175: PUSH
20176: LD_INT 5
20178: PUSH
20179: LD_INT 6
20181: PUSH
20182: LD_INT 7
20184: PUSH
20185: LD_INT 8
20187: PUSH
20188: LD_INT 9
20190: PUSH
20191: LD_INT 10
20193: PUSH
20194: LD_INT 11
20196: PUSH
20197: LD_INT 12
20199: PUSH
20200: LD_INT 13
20202: PUSH
20203: LD_INT 14
20205: PUSH
20206: LD_INT 15
20208: PUSH
20209: LD_INT 16
20211: PUSH
20212: LD_INT 17
20214: PUSH
20215: LD_INT 18
20217: PUSH
20218: LD_INT 19
20220: PUSH
20221: LD_INT 20
20223: PUSH
20224: LD_INT 21
20226: PUSH
20227: LD_INT 22
20229: PUSH
20230: LD_INT 23
20232: PUSH
20233: LD_INT 24
20235: PUSH
20236: LD_INT 25
20238: PUSH
20239: LD_INT 26
20241: PUSH
20242: LD_INT 28
20244: PUSH
20245: LD_INT 30
20247: PUSH
20248: LD_INT 31
20250: PUSH
20251: LD_INT 32
20253: PUSH
20254: LD_INT 36
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: LIST
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: LIST
20285: LIST
20286: LIST
20287: PUSH
20288: LD_INT 101
20290: PUSH
20291: LD_INT 102
20293: PUSH
20294: LD_INT 103
20296: PUSH
20297: LD_INT 104
20299: PUSH
20300: LD_INT 105
20302: PUSH
20303: LD_INT 106
20305: PUSH
20306: LD_INT 107
20308: PUSH
20309: LD_INT 108
20311: PUSH
20312: LD_INT 109
20314: PUSH
20315: LD_INT 110
20317: PUSH
20318: LD_INT 111
20320: PUSH
20321: LD_INT 112
20323: PUSH
20324: LD_INT 114
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: PUSH
20342: EMPTY
20343: LIST
20344: LIST
20345: ST_TO_ADDR
20346: GO 22133
20348: LD_INT 11
20350: DOUBLE
20351: EQUAL
20352: IFTRUE 20356
20354: GO 20548
20356: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20357: LD_ADDR_VAR 0 1
20361: PUSH
20362: LD_INT 2
20364: PUSH
20365: LD_INT 3
20367: PUSH
20368: LD_INT 4
20370: PUSH
20371: LD_INT 5
20373: PUSH
20374: LD_INT 6
20376: PUSH
20377: LD_INT 7
20379: PUSH
20380: LD_INT 8
20382: PUSH
20383: LD_INT 9
20385: PUSH
20386: LD_INT 10
20388: PUSH
20389: LD_INT 11
20391: PUSH
20392: LD_INT 12
20394: PUSH
20395: LD_INT 13
20397: PUSH
20398: LD_INT 14
20400: PUSH
20401: LD_INT 15
20403: PUSH
20404: LD_INT 16
20406: PUSH
20407: LD_INT 17
20409: PUSH
20410: LD_INT 18
20412: PUSH
20413: LD_INT 19
20415: PUSH
20416: LD_INT 20
20418: PUSH
20419: LD_INT 21
20421: PUSH
20422: LD_INT 22
20424: PUSH
20425: LD_INT 23
20427: PUSH
20428: LD_INT 24
20430: PUSH
20431: LD_INT 25
20433: PUSH
20434: LD_INT 26
20436: PUSH
20437: LD_INT 28
20439: PUSH
20440: LD_INT 30
20442: PUSH
20443: LD_INT 31
20445: PUSH
20446: LD_INT 32
20448: PUSH
20449: LD_INT 34
20451: PUSH
20452: LD_INT 36
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: LIST
20469: LIST
20470: LIST
20471: LIST
20472: LIST
20473: LIST
20474: LIST
20475: LIST
20476: LIST
20477: LIST
20478: LIST
20479: LIST
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: PUSH
20488: LD_INT 101
20490: PUSH
20491: LD_INT 102
20493: PUSH
20494: LD_INT 103
20496: PUSH
20497: LD_INT 104
20499: PUSH
20500: LD_INT 105
20502: PUSH
20503: LD_INT 106
20505: PUSH
20506: LD_INT 107
20508: PUSH
20509: LD_INT 108
20511: PUSH
20512: LD_INT 109
20514: PUSH
20515: LD_INT 110
20517: PUSH
20518: LD_INT 111
20520: PUSH
20521: LD_INT 112
20523: PUSH
20524: LD_INT 114
20526: PUSH
20527: EMPTY
20528: LIST
20529: LIST
20530: LIST
20531: LIST
20532: LIST
20533: LIST
20534: LIST
20535: LIST
20536: LIST
20537: LIST
20538: LIST
20539: LIST
20540: LIST
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: ST_TO_ADDR
20546: GO 22133
20548: LD_INT 12
20550: DOUBLE
20551: EQUAL
20552: IFTRUE 20556
20554: GO 20764
20556: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20557: LD_ADDR_VAR 0 1
20561: PUSH
20562: LD_INT 1
20564: PUSH
20565: LD_INT 2
20567: PUSH
20568: LD_INT 3
20570: PUSH
20571: LD_INT 4
20573: PUSH
20574: LD_INT 5
20576: PUSH
20577: LD_INT 6
20579: PUSH
20580: LD_INT 7
20582: PUSH
20583: LD_INT 8
20585: PUSH
20586: LD_INT 9
20588: PUSH
20589: LD_INT 10
20591: PUSH
20592: LD_INT 11
20594: PUSH
20595: LD_INT 12
20597: PUSH
20598: LD_INT 13
20600: PUSH
20601: LD_INT 14
20603: PUSH
20604: LD_INT 15
20606: PUSH
20607: LD_INT 16
20609: PUSH
20610: LD_INT 17
20612: PUSH
20613: LD_INT 18
20615: PUSH
20616: LD_INT 19
20618: PUSH
20619: LD_INT 20
20621: PUSH
20622: LD_INT 21
20624: PUSH
20625: LD_INT 22
20627: PUSH
20628: LD_INT 23
20630: PUSH
20631: LD_INT 24
20633: PUSH
20634: LD_INT 25
20636: PUSH
20637: LD_INT 26
20639: PUSH
20640: LD_INT 27
20642: PUSH
20643: LD_INT 28
20645: PUSH
20646: LD_INT 30
20648: PUSH
20649: LD_INT 31
20651: PUSH
20652: LD_INT 32
20654: PUSH
20655: LD_INT 33
20657: PUSH
20658: LD_INT 34
20660: PUSH
20661: LD_INT 36
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: LIST
20679: LIST
20680: LIST
20681: LIST
20682: LIST
20683: LIST
20684: LIST
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: LIST
20690: LIST
20691: LIST
20692: LIST
20693: LIST
20694: LIST
20695: LIST
20696: LIST
20697: LIST
20698: LIST
20699: PUSH
20700: LD_INT 101
20702: PUSH
20703: LD_INT 102
20705: PUSH
20706: LD_INT 103
20708: PUSH
20709: LD_INT 104
20711: PUSH
20712: LD_INT 105
20714: PUSH
20715: LD_INT 106
20717: PUSH
20718: LD_INT 107
20720: PUSH
20721: LD_INT 108
20723: PUSH
20724: LD_INT 109
20726: PUSH
20727: LD_INT 110
20729: PUSH
20730: LD_INT 111
20732: PUSH
20733: LD_INT 112
20735: PUSH
20736: LD_INT 113
20738: PUSH
20739: LD_INT 114
20741: PUSH
20742: EMPTY
20743: LIST
20744: LIST
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: LIST
20750: LIST
20751: LIST
20752: LIST
20753: LIST
20754: LIST
20755: LIST
20756: LIST
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: ST_TO_ADDR
20762: GO 22133
20764: LD_INT 13
20766: DOUBLE
20767: EQUAL
20768: IFTRUE 20772
20770: GO 20968
20772: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20773: LD_ADDR_VAR 0 1
20777: PUSH
20778: LD_INT 1
20780: PUSH
20781: LD_INT 2
20783: PUSH
20784: LD_INT 3
20786: PUSH
20787: LD_INT 4
20789: PUSH
20790: LD_INT 5
20792: PUSH
20793: LD_INT 8
20795: PUSH
20796: LD_INT 9
20798: PUSH
20799: LD_INT 10
20801: PUSH
20802: LD_INT 11
20804: PUSH
20805: LD_INT 12
20807: PUSH
20808: LD_INT 14
20810: PUSH
20811: LD_INT 15
20813: PUSH
20814: LD_INT 16
20816: PUSH
20817: LD_INT 17
20819: PUSH
20820: LD_INT 18
20822: PUSH
20823: LD_INT 19
20825: PUSH
20826: LD_INT 20
20828: PUSH
20829: LD_INT 21
20831: PUSH
20832: LD_INT 22
20834: PUSH
20835: LD_INT 23
20837: PUSH
20838: LD_INT 24
20840: PUSH
20841: LD_INT 25
20843: PUSH
20844: LD_INT 26
20846: PUSH
20847: LD_INT 27
20849: PUSH
20850: LD_INT 28
20852: PUSH
20853: LD_INT 30
20855: PUSH
20856: LD_INT 31
20858: PUSH
20859: LD_INT 32
20861: PUSH
20862: LD_INT 33
20864: PUSH
20865: LD_INT 34
20867: PUSH
20868: LD_INT 36
20870: PUSH
20871: EMPTY
20872: LIST
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: LIST
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: LIST
20903: PUSH
20904: LD_INT 101
20906: PUSH
20907: LD_INT 102
20909: PUSH
20910: LD_INT 103
20912: PUSH
20913: LD_INT 104
20915: PUSH
20916: LD_INT 105
20918: PUSH
20919: LD_INT 106
20921: PUSH
20922: LD_INT 107
20924: PUSH
20925: LD_INT 108
20927: PUSH
20928: LD_INT 109
20930: PUSH
20931: LD_INT 110
20933: PUSH
20934: LD_INT 111
20936: PUSH
20937: LD_INT 112
20939: PUSH
20940: LD_INT 113
20942: PUSH
20943: LD_INT 114
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: LIST
20955: LIST
20956: LIST
20957: LIST
20958: LIST
20959: LIST
20960: LIST
20961: PUSH
20962: EMPTY
20963: LIST
20964: LIST
20965: ST_TO_ADDR
20966: GO 22133
20968: LD_INT 14
20970: DOUBLE
20971: EQUAL
20972: IFTRUE 20976
20974: GO 21188
20976: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20977: LD_ADDR_VAR 0 1
20981: PUSH
20982: LD_INT 1
20984: PUSH
20985: LD_INT 2
20987: PUSH
20988: LD_INT 3
20990: PUSH
20991: LD_INT 4
20993: PUSH
20994: LD_INT 5
20996: PUSH
20997: LD_INT 6
20999: PUSH
21000: LD_INT 7
21002: PUSH
21003: LD_INT 8
21005: PUSH
21006: LD_INT 9
21008: PUSH
21009: LD_INT 10
21011: PUSH
21012: LD_INT 11
21014: PUSH
21015: LD_INT 12
21017: PUSH
21018: LD_INT 13
21020: PUSH
21021: LD_INT 14
21023: PUSH
21024: LD_INT 15
21026: PUSH
21027: LD_INT 16
21029: PUSH
21030: LD_INT 17
21032: PUSH
21033: LD_INT 18
21035: PUSH
21036: LD_INT 19
21038: PUSH
21039: LD_INT 20
21041: PUSH
21042: LD_INT 21
21044: PUSH
21045: LD_INT 22
21047: PUSH
21048: LD_INT 23
21050: PUSH
21051: LD_INT 24
21053: PUSH
21054: LD_INT 25
21056: PUSH
21057: LD_INT 26
21059: PUSH
21060: LD_INT 27
21062: PUSH
21063: LD_INT 28
21065: PUSH
21066: LD_INT 29
21068: PUSH
21069: LD_INT 30
21071: PUSH
21072: LD_INT 31
21074: PUSH
21075: LD_INT 32
21077: PUSH
21078: LD_INT 33
21080: PUSH
21081: LD_INT 34
21083: PUSH
21084: LD_INT 36
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: LIST
21102: LIST
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: LIST
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: LIST
21117: LIST
21118: LIST
21119: LIST
21120: LIST
21121: LIST
21122: LIST
21123: PUSH
21124: LD_INT 101
21126: PUSH
21127: LD_INT 102
21129: PUSH
21130: LD_INT 103
21132: PUSH
21133: LD_INT 104
21135: PUSH
21136: LD_INT 105
21138: PUSH
21139: LD_INT 106
21141: PUSH
21142: LD_INT 107
21144: PUSH
21145: LD_INT 108
21147: PUSH
21148: LD_INT 109
21150: PUSH
21151: LD_INT 110
21153: PUSH
21154: LD_INT 111
21156: PUSH
21157: LD_INT 112
21159: PUSH
21160: LD_INT 113
21162: PUSH
21163: LD_INT 114
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: LIST
21173: LIST
21174: LIST
21175: LIST
21176: LIST
21177: LIST
21178: LIST
21179: LIST
21180: LIST
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: ST_TO_ADDR
21186: GO 22133
21188: LD_INT 15
21190: DOUBLE
21191: EQUAL
21192: IFTRUE 21196
21194: GO 21408
21196: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21197: LD_ADDR_VAR 0 1
21201: PUSH
21202: LD_INT 1
21204: PUSH
21205: LD_INT 2
21207: PUSH
21208: LD_INT 3
21210: PUSH
21211: LD_INT 4
21213: PUSH
21214: LD_INT 5
21216: PUSH
21217: LD_INT 6
21219: PUSH
21220: LD_INT 7
21222: PUSH
21223: LD_INT 8
21225: PUSH
21226: LD_INT 9
21228: PUSH
21229: LD_INT 10
21231: PUSH
21232: LD_INT 11
21234: PUSH
21235: LD_INT 12
21237: PUSH
21238: LD_INT 13
21240: PUSH
21241: LD_INT 14
21243: PUSH
21244: LD_INT 15
21246: PUSH
21247: LD_INT 16
21249: PUSH
21250: LD_INT 17
21252: PUSH
21253: LD_INT 18
21255: PUSH
21256: LD_INT 19
21258: PUSH
21259: LD_INT 20
21261: PUSH
21262: LD_INT 21
21264: PUSH
21265: LD_INT 22
21267: PUSH
21268: LD_INT 23
21270: PUSH
21271: LD_INT 24
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 26
21279: PUSH
21280: LD_INT 27
21282: PUSH
21283: LD_INT 28
21285: PUSH
21286: LD_INT 29
21288: PUSH
21289: LD_INT 30
21291: PUSH
21292: LD_INT 31
21294: PUSH
21295: LD_INT 32
21297: PUSH
21298: LD_INT 33
21300: PUSH
21301: LD_INT 34
21303: PUSH
21304: LD_INT 36
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: LIST
21328: LIST
21329: LIST
21330: LIST
21331: LIST
21332: LIST
21333: LIST
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: LIST
21339: LIST
21340: LIST
21341: LIST
21342: LIST
21343: PUSH
21344: LD_INT 101
21346: PUSH
21347: LD_INT 102
21349: PUSH
21350: LD_INT 103
21352: PUSH
21353: LD_INT 104
21355: PUSH
21356: LD_INT 105
21358: PUSH
21359: LD_INT 106
21361: PUSH
21362: LD_INT 107
21364: PUSH
21365: LD_INT 108
21367: PUSH
21368: LD_INT 109
21370: PUSH
21371: LD_INT 110
21373: PUSH
21374: LD_INT 111
21376: PUSH
21377: LD_INT 112
21379: PUSH
21380: LD_INT 113
21382: PUSH
21383: LD_INT 114
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: PUSH
21402: EMPTY
21403: LIST
21404: LIST
21405: ST_TO_ADDR
21406: GO 22133
21408: LD_INT 16
21410: DOUBLE
21411: EQUAL
21412: IFTRUE 21416
21414: GO 21540
21416: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21417: LD_ADDR_VAR 0 1
21421: PUSH
21422: LD_INT 2
21424: PUSH
21425: LD_INT 4
21427: PUSH
21428: LD_INT 5
21430: PUSH
21431: LD_INT 7
21433: PUSH
21434: LD_INT 11
21436: PUSH
21437: LD_INT 12
21439: PUSH
21440: LD_INT 15
21442: PUSH
21443: LD_INT 16
21445: PUSH
21446: LD_INT 20
21448: PUSH
21449: LD_INT 21
21451: PUSH
21452: LD_INT 22
21454: PUSH
21455: LD_INT 23
21457: PUSH
21458: LD_INT 25
21460: PUSH
21461: LD_INT 26
21463: PUSH
21464: LD_INT 30
21466: PUSH
21467: LD_INT 31
21469: PUSH
21470: LD_INT 32
21472: PUSH
21473: LD_INT 33
21475: PUSH
21476: LD_INT 34
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: LIST
21487: LIST
21488: LIST
21489: LIST
21490: LIST
21491: LIST
21492: LIST
21493: LIST
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: LIST
21499: PUSH
21500: LD_INT 101
21502: PUSH
21503: LD_INT 102
21505: PUSH
21506: LD_INT 103
21508: PUSH
21509: LD_INT 106
21511: PUSH
21512: LD_INT 108
21514: PUSH
21515: LD_INT 112
21517: PUSH
21518: LD_INT 113
21520: PUSH
21521: LD_INT 114
21523: PUSH
21524: EMPTY
21525: LIST
21526: LIST
21527: LIST
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: LIST
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: ST_TO_ADDR
21538: GO 22133
21540: LD_INT 17
21542: DOUBLE
21543: EQUAL
21544: IFTRUE 21548
21546: GO 21760
21548: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21549: LD_ADDR_VAR 0 1
21553: PUSH
21554: LD_INT 1
21556: PUSH
21557: LD_INT 2
21559: PUSH
21560: LD_INT 3
21562: PUSH
21563: LD_INT 4
21565: PUSH
21566: LD_INT 5
21568: PUSH
21569: LD_INT 6
21571: PUSH
21572: LD_INT 7
21574: PUSH
21575: LD_INT 8
21577: PUSH
21578: LD_INT 9
21580: PUSH
21581: LD_INT 10
21583: PUSH
21584: LD_INT 11
21586: PUSH
21587: LD_INT 12
21589: PUSH
21590: LD_INT 13
21592: PUSH
21593: LD_INT 14
21595: PUSH
21596: LD_INT 15
21598: PUSH
21599: LD_INT 16
21601: PUSH
21602: LD_INT 17
21604: PUSH
21605: LD_INT 18
21607: PUSH
21608: LD_INT 19
21610: PUSH
21611: LD_INT 20
21613: PUSH
21614: LD_INT 21
21616: PUSH
21617: LD_INT 22
21619: PUSH
21620: LD_INT 23
21622: PUSH
21623: LD_INT 24
21625: PUSH
21626: LD_INT 25
21628: PUSH
21629: LD_INT 26
21631: PUSH
21632: LD_INT 27
21634: PUSH
21635: LD_INT 28
21637: PUSH
21638: LD_INT 29
21640: PUSH
21641: LD_INT 30
21643: PUSH
21644: LD_INT 31
21646: PUSH
21647: LD_INT 32
21649: PUSH
21650: LD_INT 33
21652: PUSH
21653: LD_INT 34
21655: PUSH
21656: LD_INT 36
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: LIST
21671: LIST
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: LIST
21677: LIST
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: LIST
21693: LIST
21694: LIST
21695: PUSH
21696: LD_INT 101
21698: PUSH
21699: LD_INT 102
21701: PUSH
21702: LD_INT 103
21704: PUSH
21705: LD_INT 104
21707: PUSH
21708: LD_INT 105
21710: PUSH
21711: LD_INT 106
21713: PUSH
21714: LD_INT 107
21716: PUSH
21717: LD_INT 108
21719: PUSH
21720: LD_INT 109
21722: PUSH
21723: LD_INT 110
21725: PUSH
21726: LD_INT 111
21728: PUSH
21729: LD_INT 112
21731: PUSH
21732: LD_INT 113
21734: PUSH
21735: LD_INT 114
21737: PUSH
21738: EMPTY
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: LIST
21744: LIST
21745: LIST
21746: LIST
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: LIST
21753: PUSH
21754: EMPTY
21755: LIST
21756: LIST
21757: ST_TO_ADDR
21758: GO 22133
21760: LD_INT 18
21762: DOUBLE
21763: EQUAL
21764: IFTRUE 21768
21766: GO 21904
21768: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21769: LD_ADDR_VAR 0 1
21773: PUSH
21774: LD_INT 2
21776: PUSH
21777: LD_INT 4
21779: PUSH
21780: LD_INT 5
21782: PUSH
21783: LD_INT 7
21785: PUSH
21786: LD_INT 11
21788: PUSH
21789: LD_INT 12
21791: PUSH
21792: LD_INT 15
21794: PUSH
21795: LD_INT 16
21797: PUSH
21798: LD_INT 20
21800: PUSH
21801: LD_INT 21
21803: PUSH
21804: LD_INT 22
21806: PUSH
21807: LD_INT 23
21809: PUSH
21810: LD_INT 25
21812: PUSH
21813: LD_INT 26
21815: PUSH
21816: LD_INT 30
21818: PUSH
21819: LD_INT 31
21821: PUSH
21822: LD_INT 32
21824: PUSH
21825: LD_INT 33
21827: PUSH
21828: LD_INT 34
21830: PUSH
21831: LD_INT 35
21833: PUSH
21834: LD_INT 36
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: LIST
21841: LIST
21842: LIST
21843: LIST
21844: LIST
21845: LIST
21846: LIST
21847: LIST
21848: LIST
21849: LIST
21850: LIST
21851: LIST
21852: LIST
21853: LIST
21854: LIST
21855: LIST
21856: LIST
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 101
21862: PUSH
21863: LD_INT 102
21865: PUSH
21866: LD_INT 103
21868: PUSH
21869: LD_INT 106
21871: PUSH
21872: LD_INT 108
21874: PUSH
21875: LD_INT 112
21877: PUSH
21878: LD_INT 113
21880: PUSH
21881: LD_INT 114
21883: PUSH
21884: LD_INT 115
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: LIST
21891: LIST
21892: LIST
21893: LIST
21894: LIST
21895: LIST
21896: LIST
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: ST_TO_ADDR
21902: GO 22133
21904: LD_INT 19
21906: DOUBLE
21907: EQUAL
21908: IFTRUE 21912
21910: GO 22132
21912: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_INT 1
21920: PUSH
21921: LD_INT 2
21923: PUSH
21924: LD_INT 3
21926: PUSH
21927: LD_INT 4
21929: PUSH
21930: LD_INT 5
21932: PUSH
21933: LD_INT 6
21935: PUSH
21936: LD_INT 7
21938: PUSH
21939: LD_INT 8
21941: PUSH
21942: LD_INT 9
21944: PUSH
21945: LD_INT 10
21947: PUSH
21948: LD_INT 11
21950: PUSH
21951: LD_INT 12
21953: PUSH
21954: LD_INT 13
21956: PUSH
21957: LD_INT 14
21959: PUSH
21960: LD_INT 15
21962: PUSH
21963: LD_INT 16
21965: PUSH
21966: LD_INT 17
21968: PUSH
21969: LD_INT 18
21971: PUSH
21972: LD_INT 19
21974: PUSH
21975: LD_INT 20
21977: PUSH
21978: LD_INT 21
21980: PUSH
21981: LD_INT 22
21983: PUSH
21984: LD_INT 23
21986: PUSH
21987: LD_INT 24
21989: PUSH
21990: LD_INT 25
21992: PUSH
21993: LD_INT 26
21995: PUSH
21996: LD_INT 27
21998: PUSH
21999: LD_INT 28
22001: PUSH
22002: LD_INT 29
22004: PUSH
22005: LD_INT 30
22007: PUSH
22008: LD_INT 31
22010: PUSH
22011: LD_INT 32
22013: PUSH
22014: LD_INT 33
22016: PUSH
22017: LD_INT 34
22019: PUSH
22020: LD_INT 35
22022: PUSH
22023: LD_INT 36
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: LIST
22042: LIST
22043: LIST
22044: LIST
22045: LIST
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: LIST
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: LIST
22060: LIST
22061: LIST
22062: LIST
22063: PUSH
22064: LD_INT 101
22066: PUSH
22067: LD_INT 102
22069: PUSH
22070: LD_INT 103
22072: PUSH
22073: LD_INT 104
22075: PUSH
22076: LD_INT 105
22078: PUSH
22079: LD_INT 106
22081: PUSH
22082: LD_INT 107
22084: PUSH
22085: LD_INT 108
22087: PUSH
22088: LD_INT 109
22090: PUSH
22091: LD_INT 110
22093: PUSH
22094: LD_INT 111
22096: PUSH
22097: LD_INT 112
22099: PUSH
22100: LD_INT 113
22102: PUSH
22103: LD_INT 114
22105: PUSH
22106: LD_INT 115
22108: PUSH
22109: EMPTY
22110: LIST
22111: LIST
22112: LIST
22113: LIST
22114: LIST
22115: LIST
22116: LIST
22117: LIST
22118: LIST
22119: LIST
22120: LIST
22121: LIST
22122: LIST
22123: LIST
22124: LIST
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: ST_TO_ADDR
22130: GO 22133
22132: POP
// end else
22133: GO 22352
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22135: LD_ADDR_VAR 0 1
22139: PUSH
22140: LD_INT 1
22142: PUSH
22143: LD_INT 2
22145: PUSH
22146: LD_INT 3
22148: PUSH
22149: LD_INT 4
22151: PUSH
22152: LD_INT 5
22154: PUSH
22155: LD_INT 6
22157: PUSH
22158: LD_INT 7
22160: PUSH
22161: LD_INT 8
22163: PUSH
22164: LD_INT 9
22166: PUSH
22167: LD_INT 10
22169: PUSH
22170: LD_INT 11
22172: PUSH
22173: LD_INT 12
22175: PUSH
22176: LD_INT 13
22178: PUSH
22179: LD_INT 14
22181: PUSH
22182: LD_INT 15
22184: PUSH
22185: LD_INT 16
22187: PUSH
22188: LD_INT 17
22190: PUSH
22191: LD_INT 18
22193: PUSH
22194: LD_INT 19
22196: PUSH
22197: LD_INT 20
22199: PUSH
22200: LD_INT 21
22202: PUSH
22203: LD_INT 22
22205: PUSH
22206: LD_INT 23
22208: PUSH
22209: LD_INT 24
22211: PUSH
22212: LD_INT 25
22214: PUSH
22215: LD_INT 26
22217: PUSH
22218: LD_INT 27
22220: PUSH
22221: LD_INT 28
22223: PUSH
22224: LD_INT 29
22226: PUSH
22227: LD_INT 30
22229: PUSH
22230: LD_INT 31
22232: PUSH
22233: LD_INT 32
22235: PUSH
22236: LD_INT 33
22238: PUSH
22239: LD_INT 34
22241: PUSH
22242: LD_INT 35
22244: PUSH
22245: LD_INT 36
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: LIST
22264: LIST
22265: LIST
22266: LIST
22267: LIST
22268: LIST
22269: LIST
22270: LIST
22271: LIST
22272: LIST
22273: LIST
22274: LIST
22275: LIST
22276: LIST
22277: LIST
22278: LIST
22279: LIST
22280: LIST
22281: LIST
22282: LIST
22283: LIST
22284: LIST
22285: PUSH
22286: LD_INT 101
22288: PUSH
22289: LD_INT 102
22291: PUSH
22292: LD_INT 103
22294: PUSH
22295: LD_INT 104
22297: PUSH
22298: LD_INT 105
22300: PUSH
22301: LD_INT 106
22303: PUSH
22304: LD_INT 107
22306: PUSH
22307: LD_INT 108
22309: PUSH
22310: LD_INT 109
22312: PUSH
22313: LD_INT 110
22315: PUSH
22316: LD_INT 111
22318: PUSH
22319: LD_INT 112
22321: PUSH
22322: LD_INT 113
22324: PUSH
22325: LD_INT 114
22327: PUSH
22328: LD_INT 115
22330: PUSH
22331: EMPTY
22332: LIST
22333: LIST
22334: LIST
22335: LIST
22336: LIST
22337: LIST
22338: LIST
22339: LIST
22340: LIST
22341: LIST
22342: LIST
22343: LIST
22344: LIST
22345: LIST
22346: LIST
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: ST_TO_ADDR
// if result then
22352: LD_VAR 0 1
22356: IFFALSE 22645
// begin normal :=  ;
22358: LD_ADDR_VAR 0 3
22362: PUSH
22363: LD_STRING 
22365: ST_TO_ADDR
// hardcore :=  ;
22366: LD_ADDR_VAR 0 4
22370: PUSH
22371: LD_STRING 
22373: ST_TO_ADDR
// for i = 1 to normalCounter do
22374: LD_ADDR_VAR 0 5
22378: PUSH
22379: DOUBLE
22380: LD_INT 1
22382: DEC
22383: ST_TO_ADDR
22384: LD_EXP 68
22388: PUSH
22389: FOR_TO
22390: IFFALSE 22491
// begin tmp := 0 ;
22392: LD_ADDR_VAR 0 2
22396: PUSH
22397: LD_STRING 0
22399: ST_TO_ADDR
// if result [ 1 ] then
22400: LD_VAR 0 1
22404: PUSH
22405: LD_INT 1
22407: ARRAY
22408: IFFALSE 22473
// if result [ 1 ] [ 1 ] = i then
22410: LD_VAR 0 1
22414: PUSH
22415: LD_INT 1
22417: ARRAY
22418: PUSH
22419: LD_INT 1
22421: ARRAY
22422: PUSH
22423: LD_VAR 0 5
22427: EQUAL
22428: IFFALSE 22473
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22430: LD_ADDR_VAR 0 1
22434: PUSH
22435: LD_VAR 0 1
22439: PPUSH
22440: LD_INT 1
22442: PPUSH
22443: LD_VAR 0 1
22447: PUSH
22448: LD_INT 1
22450: ARRAY
22451: PPUSH
22452: LD_INT 1
22454: PPUSH
22455: CALL_OW 3
22459: PPUSH
22460: CALL_OW 1
22464: ST_TO_ADDR
// tmp := 1 ;
22465: LD_ADDR_VAR 0 2
22469: PUSH
22470: LD_STRING 1
22472: ST_TO_ADDR
// end ; normal := normal & tmp ;
22473: LD_ADDR_VAR 0 3
22477: PUSH
22478: LD_VAR 0 3
22482: PUSH
22483: LD_VAR 0 2
22487: STR
22488: ST_TO_ADDR
// end ;
22489: GO 22389
22491: POP
22492: POP
// for i = 1 to hardcoreCounter do
22493: LD_ADDR_VAR 0 5
22497: PUSH
22498: DOUBLE
22499: LD_INT 1
22501: DEC
22502: ST_TO_ADDR
22503: LD_EXP 69
22507: PUSH
22508: FOR_TO
22509: IFFALSE 22614
// begin tmp := 0 ;
22511: LD_ADDR_VAR 0 2
22515: PUSH
22516: LD_STRING 0
22518: ST_TO_ADDR
// if result [ 2 ] then
22519: LD_VAR 0 1
22523: PUSH
22524: LD_INT 2
22526: ARRAY
22527: IFFALSE 22596
// if result [ 2 ] [ 1 ] = 100 + i then
22529: LD_VAR 0 1
22533: PUSH
22534: LD_INT 2
22536: ARRAY
22537: PUSH
22538: LD_INT 1
22540: ARRAY
22541: PUSH
22542: LD_INT 100
22544: PUSH
22545: LD_VAR 0 5
22549: PLUS
22550: EQUAL
22551: IFFALSE 22596
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22553: LD_ADDR_VAR 0 1
22557: PUSH
22558: LD_VAR 0 1
22562: PPUSH
22563: LD_INT 2
22565: PPUSH
22566: LD_VAR 0 1
22570: PUSH
22571: LD_INT 2
22573: ARRAY
22574: PPUSH
22575: LD_INT 1
22577: PPUSH
22578: CALL_OW 3
22582: PPUSH
22583: CALL_OW 1
22587: ST_TO_ADDR
// tmp := 1 ;
22588: LD_ADDR_VAR 0 2
22592: PUSH
22593: LD_STRING 1
22595: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22596: LD_ADDR_VAR 0 4
22600: PUSH
22601: LD_VAR 0 4
22605: PUSH
22606: LD_VAR 0 2
22610: STR
22611: ST_TO_ADDR
// end ;
22612: GO 22508
22614: POP
22615: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22616: LD_STRING getStreamItemsFromMission("
22618: PUSH
22619: LD_VAR 0 3
22623: STR
22624: PUSH
22625: LD_STRING ","
22627: STR
22628: PUSH
22629: LD_VAR 0 4
22633: STR
22634: PUSH
22635: LD_STRING ")
22637: STR
22638: PPUSH
22639: CALL_OW 559
// end else
22643: GO 22652
// ToLua ( getStreamItemsFromMission("","") ) ;
22645: LD_STRING getStreamItemsFromMission("","")
22647: PPUSH
22648: CALL_OW 559
// end ;
22652: LD_VAR 0 1
22656: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22657: LD_VAR 0 2
22661: PUSH
22662: LD_INT 100
22664: EQUAL
22665: IFFALSE 23614
// begin if not StreamModeActive then
22667: LD_EXP 67
22671: NOT
22672: IFFALSE 22682
// StreamModeActive := true ;
22674: LD_ADDR_EXP 67
22678: PUSH
22679: LD_INT 1
22681: ST_TO_ADDR
// if p3 = 0 then
22682: LD_VAR 0 3
22686: PUSH
22687: LD_INT 0
22689: EQUAL
22690: IFFALSE 22696
// InitStreamMode ;
22692: CALL 18735 0 0
// if p3 = 1 then
22696: LD_VAR 0 3
22700: PUSH
22701: LD_INT 1
22703: EQUAL
22704: IFFALSE 22714
// sRocket := true ;
22706: LD_ADDR_EXP 72
22710: PUSH
22711: LD_INT 1
22713: ST_TO_ADDR
// if p3 = 2 then
22714: LD_VAR 0 3
22718: PUSH
22719: LD_INT 2
22721: EQUAL
22722: IFFALSE 22732
// sSpeed := true ;
22724: LD_ADDR_EXP 71
22728: PUSH
22729: LD_INT 1
22731: ST_TO_ADDR
// if p3 = 3 then
22732: LD_VAR 0 3
22736: PUSH
22737: LD_INT 3
22739: EQUAL
22740: IFFALSE 22750
// sEngine := true ;
22742: LD_ADDR_EXP 73
22746: PUSH
22747: LD_INT 1
22749: ST_TO_ADDR
// if p3 = 4 then
22750: LD_VAR 0 3
22754: PUSH
22755: LD_INT 4
22757: EQUAL
22758: IFFALSE 22768
// sSpec := true ;
22760: LD_ADDR_EXP 70
22764: PUSH
22765: LD_INT 1
22767: ST_TO_ADDR
// if p3 = 5 then
22768: LD_VAR 0 3
22772: PUSH
22773: LD_INT 5
22775: EQUAL
22776: IFFALSE 22786
// sLevel := true ;
22778: LD_ADDR_EXP 74
22782: PUSH
22783: LD_INT 1
22785: ST_TO_ADDR
// if p3 = 6 then
22786: LD_VAR 0 3
22790: PUSH
22791: LD_INT 6
22793: EQUAL
22794: IFFALSE 22804
// sArmoury := true ;
22796: LD_ADDR_EXP 75
22800: PUSH
22801: LD_INT 1
22803: ST_TO_ADDR
// if p3 = 7 then
22804: LD_VAR 0 3
22808: PUSH
22809: LD_INT 7
22811: EQUAL
22812: IFFALSE 22822
// sRadar := true ;
22814: LD_ADDR_EXP 76
22818: PUSH
22819: LD_INT 1
22821: ST_TO_ADDR
// if p3 = 8 then
22822: LD_VAR 0 3
22826: PUSH
22827: LD_INT 8
22829: EQUAL
22830: IFFALSE 22840
// sBunker := true ;
22832: LD_ADDR_EXP 77
22836: PUSH
22837: LD_INT 1
22839: ST_TO_ADDR
// if p3 = 9 then
22840: LD_VAR 0 3
22844: PUSH
22845: LD_INT 9
22847: EQUAL
22848: IFFALSE 22858
// sHack := true ;
22850: LD_ADDR_EXP 78
22854: PUSH
22855: LD_INT 1
22857: ST_TO_ADDR
// if p3 = 10 then
22858: LD_VAR 0 3
22862: PUSH
22863: LD_INT 10
22865: EQUAL
22866: IFFALSE 22876
// sFire := true ;
22868: LD_ADDR_EXP 79
22872: PUSH
22873: LD_INT 1
22875: ST_TO_ADDR
// if p3 = 11 then
22876: LD_VAR 0 3
22880: PUSH
22881: LD_INT 11
22883: EQUAL
22884: IFFALSE 22894
// sRefresh := true ;
22886: LD_ADDR_EXP 80
22890: PUSH
22891: LD_INT 1
22893: ST_TO_ADDR
// if p3 = 12 then
22894: LD_VAR 0 3
22898: PUSH
22899: LD_INT 12
22901: EQUAL
22902: IFFALSE 22912
// sExp := true ;
22904: LD_ADDR_EXP 81
22908: PUSH
22909: LD_INT 1
22911: ST_TO_ADDR
// if p3 = 13 then
22912: LD_VAR 0 3
22916: PUSH
22917: LD_INT 13
22919: EQUAL
22920: IFFALSE 22930
// sDepot := true ;
22922: LD_ADDR_EXP 82
22926: PUSH
22927: LD_INT 1
22929: ST_TO_ADDR
// if p3 = 14 then
22930: LD_VAR 0 3
22934: PUSH
22935: LD_INT 14
22937: EQUAL
22938: IFFALSE 22948
// sFlag := true ;
22940: LD_ADDR_EXP 83
22944: PUSH
22945: LD_INT 1
22947: ST_TO_ADDR
// if p3 = 15 then
22948: LD_VAR 0 3
22952: PUSH
22953: LD_INT 15
22955: EQUAL
22956: IFFALSE 22966
// sKamikadze := true ;
22958: LD_ADDR_EXP 91
22962: PUSH
22963: LD_INT 1
22965: ST_TO_ADDR
// if p3 = 16 then
22966: LD_VAR 0 3
22970: PUSH
22971: LD_INT 16
22973: EQUAL
22974: IFFALSE 22984
// sTroll := true ;
22976: LD_ADDR_EXP 92
22980: PUSH
22981: LD_INT 1
22983: ST_TO_ADDR
// if p3 = 17 then
22984: LD_VAR 0 3
22988: PUSH
22989: LD_INT 17
22991: EQUAL
22992: IFFALSE 23002
// sSlow := true ;
22994: LD_ADDR_EXP 93
22998: PUSH
22999: LD_INT 1
23001: ST_TO_ADDR
// if p3 = 18 then
23002: LD_VAR 0 3
23006: PUSH
23007: LD_INT 18
23009: EQUAL
23010: IFFALSE 23020
// sLack := true ;
23012: LD_ADDR_EXP 94
23016: PUSH
23017: LD_INT 1
23019: ST_TO_ADDR
// if p3 = 19 then
23020: LD_VAR 0 3
23024: PUSH
23025: LD_INT 19
23027: EQUAL
23028: IFFALSE 23038
// sTank := true ;
23030: LD_ADDR_EXP 96
23034: PUSH
23035: LD_INT 1
23037: ST_TO_ADDR
// if p3 = 20 then
23038: LD_VAR 0 3
23042: PUSH
23043: LD_INT 20
23045: EQUAL
23046: IFFALSE 23056
// sRemote := true ;
23048: LD_ADDR_EXP 97
23052: PUSH
23053: LD_INT 1
23055: ST_TO_ADDR
// if p3 = 21 then
23056: LD_VAR 0 3
23060: PUSH
23061: LD_INT 21
23063: EQUAL
23064: IFFALSE 23074
// sPowell := true ;
23066: LD_ADDR_EXP 98
23070: PUSH
23071: LD_INT 1
23073: ST_TO_ADDR
// if p3 = 22 then
23074: LD_VAR 0 3
23078: PUSH
23079: LD_INT 22
23081: EQUAL
23082: IFFALSE 23092
// sTeleport := true ;
23084: LD_ADDR_EXP 101
23088: PUSH
23089: LD_INT 1
23091: ST_TO_ADDR
// if p3 = 23 then
23092: LD_VAR 0 3
23096: PUSH
23097: LD_INT 23
23099: EQUAL
23100: IFFALSE 23110
// sOilTower := true ;
23102: LD_ADDR_EXP 103
23106: PUSH
23107: LD_INT 1
23109: ST_TO_ADDR
// if p3 = 24 then
23110: LD_VAR 0 3
23114: PUSH
23115: LD_INT 24
23117: EQUAL
23118: IFFALSE 23128
// sShovel := true ;
23120: LD_ADDR_EXP 104
23124: PUSH
23125: LD_INT 1
23127: ST_TO_ADDR
// if p3 = 25 then
23128: LD_VAR 0 3
23132: PUSH
23133: LD_INT 25
23135: EQUAL
23136: IFFALSE 23146
// sSheik := true ;
23138: LD_ADDR_EXP 105
23142: PUSH
23143: LD_INT 1
23145: ST_TO_ADDR
// if p3 = 26 then
23146: LD_VAR 0 3
23150: PUSH
23151: LD_INT 26
23153: EQUAL
23154: IFFALSE 23164
// sEarthquake := true ;
23156: LD_ADDR_EXP 107
23160: PUSH
23161: LD_INT 1
23163: ST_TO_ADDR
// if p3 = 27 then
23164: LD_VAR 0 3
23168: PUSH
23169: LD_INT 27
23171: EQUAL
23172: IFFALSE 23182
// sAI := true ;
23174: LD_ADDR_EXP 108
23178: PUSH
23179: LD_INT 1
23181: ST_TO_ADDR
// if p3 = 28 then
23182: LD_VAR 0 3
23186: PUSH
23187: LD_INT 28
23189: EQUAL
23190: IFFALSE 23200
// sCargo := true ;
23192: LD_ADDR_EXP 111
23196: PUSH
23197: LD_INT 1
23199: ST_TO_ADDR
// if p3 = 29 then
23200: LD_VAR 0 3
23204: PUSH
23205: LD_INT 29
23207: EQUAL
23208: IFFALSE 23218
// sDLaser := true ;
23210: LD_ADDR_EXP 112
23214: PUSH
23215: LD_INT 1
23217: ST_TO_ADDR
// if p3 = 30 then
23218: LD_VAR 0 3
23222: PUSH
23223: LD_INT 30
23225: EQUAL
23226: IFFALSE 23236
// sExchange := true ;
23228: LD_ADDR_EXP 113
23232: PUSH
23233: LD_INT 1
23235: ST_TO_ADDR
// if p3 = 31 then
23236: LD_VAR 0 3
23240: PUSH
23241: LD_INT 31
23243: EQUAL
23244: IFFALSE 23254
// sFac := true ;
23246: LD_ADDR_EXP 114
23250: PUSH
23251: LD_INT 1
23253: ST_TO_ADDR
// if p3 = 32 then
23254: LD_VAR 0 3
23258: PUSH
23259: LD_INT 32
23261: EQUAL
23262: IFFALSE 23272
// sPower := true ;
23264: LD_ADDR_EXP 115
23268: PUSH
23269: LD_INT 1
23271: ST_TO_ADDR
// if p3 = 33 then
23272: LD_VAR 0 3
23276: PUSH
23277: LD_INT 33
23279: EQUAL
23280: IFFALSE 23290
// sRandom := true ;
23282: LD_ADDR_EXP 116
23286: PUSH
23287: LD_INT 1
23289: ST_TO_ADDR
// if p3 = 34 then
23290: LD_VAR 0 3
23294: PUSH
23295: LD_INT 34
23297: EQUAL
23298: IFFALSE 23308
// sShield := true ;
23300: LD_ADDR_EXP 117
23304: PUSH
23305: LD_INT 1
23307: ST_TO_ADDR
// if p3 = 35 then
23308: LD_VAR 0 3
23312: PUSH
23313: LD_INT 35
23315: EQUAL
23316: IFFALSE 23326
// sTime := true ;
23318: LD_ADDR_EXP 118
23322: PUSH
23323: LD_INT 1
23325: ST_TO_ADDR
// if p3 = 36 then
23326: LD_VAR 0 3
23330: PUSH
23331: LD_INT 36
23333: EQUAL
23334: IFFALSE 23344
// sTools := true ;
23336: LD_ADDR_EXP 119
23340: PUSH
23341: LD_INT 1
23343: ST_TO_ADDR
// if p3 = 101 then
23344: LD_VAR 0 3
23348: PUSH
23349: LD_INT 101
23351: EQUAL
23352: IFFALSE 23362
// sSold := true ;
23354: LD_ADDR_EXP 84
23358: PUSH
23359: LD_INT 1
23361: ST_TO_ADDR
// if p3 = 102 then
23362: LD_VAR 0 3
23366: PUSH
23367: LD_INT 102
23369: EQUAL
23370: IFFALSE 23380
// sDiff := true ;
23372: LD_ADDR_EXP 85
23376: PUSH
23377: LD_INT 1
23379: ST_TO_ADDR
// if p3 = 103 then
23380: LD_VAR 0 3
23384: PUSH
23385: LD_INT 103
23387: EQUAL
23388: IFFALSE 23398
// sFog := true ;
23390: LD_ADDR_EXP 88
23394: PUSH
23395: LD_INT 1
23397: ST_TO_ADDR
// if p3 = 104 then
23398: LD_VAR 0 3
23402: PUSH
23403: LD_INT 104
23405: EQUAL
23406: IFFALSE 23416
// sReset := true ;
23408: LD_ADDR_EXP 89
23412: PUSH
23413: LD_INT 1
23415: ST_TO_ADDR
// if p3 = 105 then
23416: LD_VAR 0 3
23420: PUSH
23421: LD_INT 105
23423: EQUAL
23424: IFFALSE 23434
// sSun := true ;
23426: LD_ADDR_EXP 90
23430: PUSH
23431: LD_INT 1
23433: ST_TO_ADDR
// if p3 = 106 then
23434: LD_VAR 0 3
23438: PUSH
23439: LD_INT 106
23441: EQUAL
23442: IFFALSE 23452
// sTiger := true ;
23444: LD_ADDR_EXP 86
23448: PUSH
23449: LD_INT 1
23451: ST_TO_ADDR
// if p3 = 107 then
23452: LD_VAR 0 3
23456: PUSH
23457: LD_INT 107
23459: EQUAL
23460: IFFALSE 23470
// sBomb := true ;
23462: LD_ADDR_EXP 87
23466: PUSH
23467: LD_INT 1
23469: ST_TO_ADDR
// if p3 = 108 then
23470: LD_VAR 0 3
23474: PUSH
23475: LD_INT 108
23477: EQUAL
23478: IFFALSE 23488
// sWound := true ;
23480: LD_ADDR_EXP 95
23484: PUSH
23485: LD_INT 1
23487: ST_TO_ADDR
// if p3 = 109 then
23488: LD_VAR 0 3
23492: PUSH
23493: LD_INT 109
23495: EQUAL
23496: IFFALSE 23506
// sBetray := true ;
23498: LD_ADDR_EXP 99
23502: PUSH
23503: LD_INT 1
23505: ST_TO_ADDR
// if p3 = 110 then
23506: LD_VAR 0 3
23510: PUSH
23511: LD_INT 110
23513: EQUAL
23514: IFFALSE 23524
// sContamin := true ;
23516: LD_ADDR_EXP 100
23520: PUSH
23521: LD_INT 1
23523: ST_TO_ADDR
// if p3 = 111 then
23524: LD_VAR 0 3
23528: PUSH
23529: LD_INT 111
23531: EQUAL
23532: IFFALSE 23542
// sOil := true ;
23534: LD_ADDR_EXP 102
23538: PUSH
23539: LD_INT 1
23541: ST_TO_ADDR
// if p3 = 112 then
23542: LD_VAR 0 3
23546: PUSH
23547: LD_INT 112
23549: EQUAL
23550: IFFALSE 23560
// sStu := true ;
23552: LD_ADDR_EXP 106
23556: PUSH
23557: LD_INT 1
23559: ST_TO_ADDR
// if p3 = 113 then
23560: LD_VAR 0 3
23564: PUSH
23565: LD_INT 113
23567: EQUAL
23568: IFFALSE 23578
// sBazooka := true ;
23570: LD_ADDR_EXP 109
23574: PUSH
23575: LD_INT 1
23577: ST_TO_ADDR
// if p3 = 114 then
23578: LD_VAR 0 3
23582: PUSH
23583: LD_INT 114
23585: EQUAL
23586: IFFALSE 23596
// sMortar := true ;
23588: LD_ADDR_EXP 110
23592: PUSH
23593: LD_INT 1
23595: ST_TO_ADDR
// if p3 = 115 then
23596: LD_VAR 0 3
23600: PUSH
23601: LD_INT 115
23603: EQUAL
23604: IFFALSE 23614
// sRanger := true ;
23606: LD_ADDR_EXP 120
23610: PUSH
23611: LD_INT 1
23613: ST_TO_ADDR
// end ; end ;
23614: PPOPN 6
23616: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23617: LD_EXP 67
23621: PUSH
23622: LD_EXP 72
23626: AND
23627: IFFALSE 23751
23629: GO 23631
23631: DISABLE
23632: LD_INT 0
23634: PPUSH
23635: PPUSH
// begin enable ;
23636: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23637: LD_ADDR_VAR 0 2
23641: PUSH
23642: LD_INT 22
23644: PUSH
23645: LD_OWVAR 2
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 2
23656: PUSH
23657: LD_INT 34
23659: PUSH
23660: LD_INT 7
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: LD_INT 34
23669: PUSH
23670: LD_INT 45
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: PUSH
23677: LD_INT 34
23679: PUSH
23680: LD_INT 28
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: PUSH
23687: LD_INT 34
23689: PUSH
23690: LD_INT 47
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: LIST
23701: LIST
23702: LIST
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: PPUSH
23708: CALL_OW 69
23712: ST_TO_ADDR
// if not tmp then
23713: LD_VAR 0 2
23717: NOT
23718: IFFALSE 23722
// exit ;
23720: GO 23751
// for i in tmp do
23722: LD_ADDR_VAR 0 1
23726: PUSH
23727: LD_VAR 0 2
23731: PUSH
23732: FOR_IN
23733: IFFALSE 23749
// begin SetLives ( i , 0 ) ;
23735: LD_VAR 0 1
23739: PPUSH
23740: LD_INT 0
23742: PPUSH
23743: CALL_OW 234
// end ;
23747: GO 23732
23749: POP
23750: POP
// end ;
23751: PPOPN 2
23753: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23754: LD_EXP 67
23758: PUSH
23759: LD_EXP 73
23763: AND
23764: IFFALSE 23848
23766: GO 23768
23768: DISABLE
23769: LD_INT 0
23771: PPUSH
23772: PPUSH
// begin enable ;
23773: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23774: LD_ADDR_VAR 0 2
23778: PUSH
23779: LD_INT 22
23781: PUSH
23782: LD_OWVAR 2
23786: PUSH
23787: EMPTY
23788: LIST
23789: LIST
23790: PUSH
23791: LD_INT 32
23793: PUSH
23794: LD_INT 3
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: PPUSH
23805: CALL_OW 69
23809: ST_TO_ADDR
// if not tmp then
23810: LD_VAR 0 2
23814: NOT
23815: IFFALSE 23819
// exit ;
23817: GO 23848
// for i in tmp do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 2
23828: PUSH
23829: FOR_IN
23830: IFFALSE 23846
// begin SetLives ( i , 0 ) ;
23832: LD_VAR 0 1
23836: PPUSH
23837: LD_INT 0
23839: PPUSH
23840: CALL_OW 234
// end ;
23844: GO 23829
23846: POP
23847: POP
// end ;
23848: PPOPN 2
23850: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23851: LD_EXP 67
23855: PUSH
23856: LD_EXP 70
23860: AND
23861: IFFALSE 23954
23863: GO 23865
23865: DISABLE
23866: LD_INT 0
23868: PPUSH
// begin enable ;
23869: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23870: LD_ADDR_VAR 0 1
23874: PUSH
23875: LD_INT 22
23877: PUSH
23878: LD_OWVAR 2
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 25
23892: PUSH
23893: LD_INT 5
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 25
23902: PUSH
23903: LD_INT 9
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: LD_INT 25
23912: PUSH
23913: LD_INT 8
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PPUSH
23930: CALL_OW 69
23934: PUSH
23935: FOR_IN
23936: IFFALSE 23952
// begin SetClass ( i , 1 ) ;
23938: LD_VAR 0 1
23942: PPUSH
23943: LD_INT 1
23945: PPUSH
23946: CALL_OW 336
// end ;
23950: GO 23935
23952: POP
23953: POP
// end ;
23954: PPOPN 1
23956: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23957: LD_EXP 67
23961: PUSH
23962: LD_EXP 71
23966: AND
23967: PUSH
23968: LD_OWVAR 65
23972: PUSH
23973: LD_INT 7
23975: LESS
23976: AND
23977: IFFALSE 23991
23979: GO 23981
23981: DISABLE
// begin enable ;
23982: ENABLE
// game_speed := 7 ;
23983: LD_ADDR_OWVAR 65
23987: PUSH
23988: LD_INT 7
23990: ST_TO_ADDR
// end ;
23991: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23992: LD_EXP 67
23996: PUSH
23997: LD_EXP 74
24001: AND
24002: IFFALSE 24204
24004: GO 24006
24006: DISABLE
24007: LD_INT 0
24009: PPUSH
24010: PPUSH
24011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
24012: LD_ADDR_VAR 0 3
24016: PUSH
24017: LD_INT 81
24019: PUSH
24020: LD_OWVAR 2
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 21
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: PPUSH
24043: CALL_OW 69
24047: ST_TO_ADDR
// if not tmp then
24048: LD_VAR 0 3
24052: NOT
24053: IFFALSE 24057
// exit ;
24055: GO 24204
// if tmp > 5 then
24057: LD_VAR 0 3
24061: PUSH
24062: LD_INT 5
24064: GREATER
24065: IFFALSE 24077
// k := 5 else
24067: LD_ADDR_VAR 0 2
24071: PUSH
24072: LD_INT 5
24074: ST_TO_ADDR
24075: GO 24087
// k := tmp ;
24077: LD_ADDR_VAR 0 2
24081: PUSH
24082: LD_VAR 0 3
24086: ST_TO_ADDR
// for i := 1 to k do
24087: LD_ADDR_VAR 0 1
24091: PUSH
24092: DOUBLE
24093: LD_INT 1
24095: DEC
24096: ST_TO_ADDR
24097: LD_VAR 0 2
24101: PUSH
24102: FOR_TO
24103: IFFALSE 24202
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24105: LD_VAR 0 3
24109: PUSH
24110: LD_VAR 0 1
24114: ARRAY
24115: PPUSH
24116: LD_VAR 0 1
24120: PUSH
24121: LD_INT 4
24123: MOD
24124: PUSH
24125: LD_INT 1
24127: PLUS
24128: PPUSH
24129: CALL_OW 259
24133: PUSH
24134: LD_INT 10
24136: LESS
24137: IFFALSE 24200
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24139: LD_VAR 0 3
24143: PUSH
24144: LD_VAR 0 1
24148: ARRAY
24149: PPUSH
24150: LD_VAR 0 1
24154: PUSH
24155: LD_INT 4
24157: MOD
24158: PUSH
24159: LD_INT 1
24161: PLUS
24162: PPUSH
24163: LD_VAR 0 3
24167: PUSH
24168: LD_VAR 0 1
24172: ARRAY
24173: PPUSH
24174: LD_VAR 0 1
24178: PUSH
24179: LD_INT 4
24181: MOD
24182: PUSH
24183: LD_INT 1
24185: PLUS
24186: PPUSH
24187: CALL_OW 259
24191: PUSH
24192: LD_INT 1
24194: PLUS
24195: PPUSH
24196: CALL_OW 237
24200: GO 24102
24202: POP
24203: POP
// end ;
24204: PPOPN 3
24206: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24207: LD_EXP 67
24211: PUSH
24212: LD_EXP 75
24216: AND
24217: IFFALSE 24237
24219: GO 24221
24221: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24222: LD_INT 4
24224: PPUSH
24225: LD_OWVAR 2
24229: PPUSH
24230: LD_INT 0
24232: PPUSH
24233: CALL_OW 324
24237: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24238: LD_EXP 67
24242: PUSH
24243: LD_EXP 104
24247: AND
24248: IFFALSE 24268
24250: GO 24252
24252: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24253: LD_INT 19
24255: PPUSH
24256: LD_OWVAR 2
24260: PPUSH
24261: LD_INT 0
24263: PPUSH
24264: CALL_OW 324
24268: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24269: LD_EXP 67
24273: PUSH
24274: LD_EXP 76
24278: AND
24279: IFFALSE 24381
24281: GO 24283
24283: DISABLE
24284: LD_INT 0
24286: PPUSH
24287: PPUSH
// begin enable ;
24288: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24289: LD_ADDR_VAR 0 2
24293: PUSH
24294: LD_INT 22
24296: PUSH
24297: LD_OWVAR 2
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: PUSH
24306: LD_INT 2
24308: PUSH
24309: LD_INT 34
24311: PUSH
24312: LD_INT 11
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 34
24321: PUSH
24322: LD_INT 30
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: LIST
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PPUSH
24338: CALL_OW 69
24342: ST_TO_ADDR
// if not tmp then
24343: LD_VAR 0 2
24347: NOT
24348: IFFALSE 24352
// exit ;
24350: GO 24381
// for i in tmp do
24352: LD_ADDR_VAR 0 1
24356: PUSH
24357: LD_VAR 0 2
24361: PUSH
24362: FOR_IN
24363: IFFALSE 24379
// begin SetLives ( i , 0 ) ;
24365: LD_VAR 0 1
24369: PPUSH
24370: LD_INT 0
24372: PPUSH
24373: CALL_OW 234
// end ;
24377: GO 24362
24379: POP
24380: POP
// end ;
24381: PPOPN 2
24383: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24384: LD_EXP 67
24388: PUSH
24389: LD_EXP 77
24393: AND
24394: IFFALSE 24414
24396: GO 24398
24398: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24399: LD_INT 32
24401: PPUSH
24402: LD_OWVAR 2
24406: PPUSH
24407: LD_INT 0
24409: PPUSH
24410: CALL_OW 324
24414: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24415: LD_EXP 67
24419: PUSH
24420: LD_EXP 78
24424: AND
24425: IFFALSE 24606
24427: GO 24429
24429: DISABLE
24430: LD_INT 0
24432: PPUSH
24433: PPUSH
24434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24435: LD_ADDR_VAR 0 2
24439: PUSH
24440: LD_INT 22
24442: PUSH
24443: LD_OWVAR 2
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: PUSH
24452: LD_INT 33
24454: PUSH
24455: LD_INT 3
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: PPUSH
24466: CALL_OW 69
24470: ST_TO_ADDR
// if not tmp then
24471: LD_VAR 0 2
24475: NOT
24476: IFFALSE 24480
// exit ;
24478: GO 24606
// side := 0 ;
24480: LD_ADDR_VAR 0 3
24484: PUSH
24485: LD_INT 0
24487: ST_TO_ADDR
// for i := 1 to 8 do
24488: LD_ADDR_VAR 0 1
24492: PUSH
24493: DOUBLE
24494: LD_INT 1
24496: DEC
24497: ST_TO_ADDR
24498: LD_INT 8
24500: PUSH
24501: FOR_TO
24502: IFFALSE 24550
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24504: LD_OWVAR 2
24508: PUSH
24509: LD_VAR 0 1
24513: NONEQUAL
24514: PUSH
24515: LD_OWVAR 2
24519: PPUSH
24520: LD_VAR 0 1
24524: PPUSH
24525: CALL_OW 81
24529: PUSH
24530: LD_INT 2
24532: EQUAL
24533: AND
24534: IFFALSE 24548
// begin side := i ;
24536: LD_ADDR_VAR 0 3
24540: PUSH
24541: LD_VAR 0 1
24545: ST_TO_ADDR
// break ;
24546: GO 24550
// end ;
24548: GO 24501
24550: POP
24551: POP
// if not side then
24552: LD_VAR 0 3
24556: NOT
24557: IFFALSE 24561
// exit ;
24559: GO 24606
// for i := 1 to tmp do
24561: LD_ADDR_VAR 0 1
24565: PUSH
24566: DOUBLE
24567: LD_INT 1
24569: DEC
24570: ST_TO_ADDR
24571: LD_VAR 0 2
24575: PUSH
24576: FOR_TO
24577: IFFALSE 24604
// if Prob ( 60 ) then
24579: LD_INT 60
24581: PPUSH
24582: CALL_OW 13
24586: IFFALSE 24602
// SetSide ( i , side ) ;
24588: LD_VAR 0 1
24592: PPUSH
24593: LD_VAR 0 3
24597: PPUSH
24598: CALL_OW 235
24602: GO 24576
24604: POP
24605: POP
// end ;
24606: PPOPN 3
24608: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24609: LD_EXP 67
24613: PUSH
24614: LD_EXP 80
24618: AND
24619: IFFALSE 24738
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24627: LD_ADDR_VAR 0 1
24631: PUSH
24632: LD_INT 22
24634: PUSH
24635: LD_OWVAR 2
24639: PUSH
24640: EMPTY
24641: LIST
24642: LIST
24643: PUSH
24644: LD_INT 21
24646: PUSH
24647: LD_INT 1
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 3
24656: PUSH
24657: LD_INT 23
24659: PUSH
24660: LD_INT 0
24662: PUSH
24663: EMPTY
24664: LIST
24665: LIST
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: LIST
24675: PPUSH
24676: CALL_OW 69
24680: PUSH
24681: FOR_IN
24682: IFFALSE 24736
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24684: LD_VAR 0 1
24688: PPUSH
24689: CALL_OW 257
24693: PUSH
24694: LD_INT 1
24696: PUSH
24697: LD_INT 2
24699: PUSH
24700: LD_INT 3
24702: PUSH
24703: LD_INT 4
24705: PUSH
24706: EMPTY
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: IN
24712: IFFALSE 24734
// SetClass ( un , rand ( 1 , 4 ) ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_INT 1
24721: PPUSH
24722: LD_INT 4
24724: PPUSH
24725: CALL_OW 12
24729: PPUSH
24730: CALL_OW 336
24734: GO 24681
24736: POP
24737: POP
// end ;
24738: PPOPN 1
24740: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24741: LD_EXP 67
24745: PUSH
24746: LD_EXP 79
24750: AND
24751: IFFALSE 24830
24753: GO 24755
24755: DISABLE
24756: LD_INT 0
24758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24759: LD_ADDR_VAR 0 1
24763: PUSH
24764: LD_INT 22
24766: PUSH
24767: LD_OWVAR 2
24771: PUSH
24772: EMPTY
24773: LIST
24774: LIST
24775: PUSH
24776: LD_INT 21
24778: PUSH
24779: LD_INT 3
24781: PUSH
24782: EMPTY
24783: LIST
24784: LIST
24785: PUSH
24786: EMPTY
24787: LIST
24788: LIST
24789: PPUSH
24790: CALL_OW 69
24794: ST_TO_ADDR
// if not tmp then
24795: LD_VAR 0 1
24799: NOT
24800: IFFALSE 24804
// exit ;
24802: GO 24830
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24804: LD_VAR 0 1
24808: PUSH
24809: LD_INT 1
24811: PPUSH
24812: LD_VAR 0 1
24816: PPUSH
24817: CALL_OW 12
24821: ARRAY
24822: PPUSH
24823: LD_INT 100
24825: PPUSH
24826: CALL_OW 234
// end ;
24830: PPOPN 1
24832: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24833: LD_EXP 67
24837: PUSH
24838: LD_EXP 81
24842: AND
24843: IFFALSE 24941
24845: GO 24847
24847: DISABLE
24848: LD_INT 0
24850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24851: LD_ADDR_VAR 0 1
24855: PUSH
24856: LD_INT 22
24858: PUSH
24859: LD_OWVAR 2
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 21
24870: PUSH
24871: LD_INT 1
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PPUSH
24882: CALL_OW 69
24886: ST_TO_ADDR
// if not tmp then
24887: LD_VAR 0 1
24891: NOT
24892: IFFALSE 24896
// exit ;
24894: GO 24941
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24896: LD_VAR 0 1
24900: PUSH
24901: LD_INT 1
24903: PPUSH
24904: LD_VAR 0 1
24908: PPUSH
24909: CALL_OW 12
24913: ARRAY
24914: PPUSH
24915: LD_INT 1
24917: PPUSH
24918: LD_INT 4
24920: PPUSH
24921: CALL_OW 12
24925: PPUSH
24926: LD_INT 3000
24928: PPUSH
24929: LD_INT 9000
24931: PPUSH
24932: CALL_OW 12
24936: PPUSH
24937: CALL_OW 492
// end ;
24941: PPOPN 1
24943: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24944: LD_EXP 67
24948: PUSH
24949: LD_EXP 82
24953: AND
24954: IFFALSE 24974
24956: GO 24958
24958: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24959: LD_INT 1
24961: PPUSH
24962: LD_OWVAR 2
24966: PPUSH
24967: LD_INT 0
24969: PPUSH
24970: CALL_OW 324
24974: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24975: LD_EXP 67
24979: PUSH
24980: LD_EXP 83
24984: AND
24985: IFFALSE 25068
24987: GO 24989
24989: DISABLE
24990: LD_INT 0
24992: PPUSH
24993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24994: LD_ADDR_VAR 0 2
24998: PUSH
24999: LD_INT 22
25001: PUSH
25002: LD_OWVAR 2
25006: PUSH
25007: EMPTY
25008: LIST
25009: LIST
25010: PUSH
25011: LD_INT 21
25013: PUSH
25014: LD_INT 3
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PPUSH
25025: CALL_OW 69
25029: ST_TO_ADDR
// if not tmp then
25030: LD_VAR 0 2
25034: NOT
25035: IFFALSE 25039
// exit ;
25037: GO 25068
// for i in tmp do
25039: LD_ADDR_VAR 0 1
25043: PUSH
25044: LD_VAR 0 2
25048: PUSH
25049: FOR_IN
25050: IFFALSE 25066
// SetBLevel ( i , 10 ) ;
25052: LD_VAR 0 1
25056: PPUSH
25057: LD_INT 10
25059: PPUSH
25060: CALL_OW 241
25064: GO 25049
25066: POP
25067: POP
// end ;
25068: PPOPN 2
25070: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25071: LD_EXP 67
25075: PUSH
25076: LD_EXP 84
25080: AND
25081: IFFALSE 25192
25083: GO 25085
25085: DISABLE
25086: LD_INT 0
25088: PPUSH
25089: PPUSH
25090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25091: LD_ADDR_VAR 0 3
25095: PUSH
25096: LD_INT 22
25098: PUSH
25099: LD_OWVAR 2
25103: PUSH
25104: EMPTY
25105: LIST
25106: LIST
25107: PUSH
25108: LD_INT 25
25110: PUSH
25111: LD_INT 1
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PPUSH
25122: CALL_OW 69
25126: ST_TO_ADDR
// if not tmp then
25127: LD_VAR 0 3
25131: NOT
25132: IFFALSE 25136
// exit ;
25134: GO 25192
// un := tmp [ rand ( 1 , tmp ) ] ;
25136: LD_ADDR_VAR 0 2
25140: PUSH
25141: LD_VAR 0 3
25145: PUSH
25146: LD_INT 1
25148: PPUSH
25149: LD_VAR 0 3
25153: PPUSH
25154: CALL_OW 12
25158: ARRAY
25159: ST_TO_ADDR
// if Crawls ( un ) then
25160: LD_VAR 0 2
25164: PPUSH
25165: CALL_OW 318
25169: IFFALSE 25180
// ComWalk ( un ) ;
25171: LD_VAR 0 2
25175: PPUSH
25176: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25180: LD_VAR 0 2
25184: PPUSH
25185: LD_INT 5
25187: PPUSH
25188: CALL_OW 336
// end ;
25192: PPOPN 3
25194: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25195: LD_EXP 67
25199: PUSH
25200: LD_EXP 85
25204: AND
25205: PUSH
25206: LD_OWVAR 67
25210: PUSH
25211: LD_INT 3
25213: LESS
25214: AND
25215: IFFALSE 25234
25217: GO 25219
25219: DISABLE
// Difficulty := Difficulty + 1 ;
25220: LD_ADDR_OWVAR 67
25224: PUSH
25225: LD_OWVAR 67
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: ST_TO_ADDR
25234: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25235: LD_EXP 67
25239: PUSH
25240: LD_EXP 86
25244: AND
25245: IFFALSE 25348
25247: GO 25249
25249: DISABLE
25250: LD_INT 0
25252: PPUSH
// begin for i := 1 to 5 do
25253: LD_ADDR_VAR 0 1
25257: PUSH
25258: DOUBLE
25259: LD_INT 1
25261: DEC
25262: ST_TO_ADDR
25263: LD_INT 5
25265: PUSH
25266: FOR_TO
25267: IFFALSE 25346
// begin uc_nation := nation_nature ;
25269: LD_ADDR_OWVAR 21
25273: PUSH
25274: LD_INT 0
25276: ST_TO_ADDR
// uc_side := 0 ;
25277: LD_ADDR_OWVAR 20
25281: PUSH
25282: LD_INT 0
25284: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25285: LD_ADDR_OWVAR 29
25289: PUSH
25290: LD_INT 12
25292: PUSH
25293: LD_INT 12
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: ST_TO_ADDR
// hc_agressivity := 20 ;
25300: LD_ADDR_OWVAR 35
25304: PUSH
25305: LD_INT 20
25307: ST_TO_ADDR
// hc_class := class_tiger ;
25308: LD_ADDR_OWVAR 28
25312: PUSH
25313: LD_INT 14
25315: ST_TO_ADDR
// hc_gallery :=  ;
25316: LD_ADDR_OWVAR 33
25320: PUSH
25321: LD_STRING 
25323: ST_TO_ADDR
// hc_name :=  ;
25324: LD_ADDR_OWVAR 26
25328: PUSH
25329: LD_STRING 
25331: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25332: CALL_OW 44
25336: PPUSH
25337: LD_INT 0
25339: PPUSH
25340: CALL_OW 51
// end ;
25344: GO 25266
25346: POP
25347: POP
// end ;
25348: PPOPN 1
25350: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25351: LD_EXP 67
25355: PUSH
25356: LD_EXP 87
25360: AND
25361: IFFALSE 25370
25363: GO 25365
25365: DISABLE
// StreamSibBomb ;
25366: CALL 25371 0 0
25370: END
// export function StreamSibBomb ; var i , x , y ; begin
25371: LD_INT 0
25373: PPUSH
25374: PPUSH
25375: PPUSH
25376: PPUSH
// result := false ;
25377: LD_ADDR_VAR 0 1
25381: PUSH
25382: LD_INT 0
25384: ST_TO_ADDR
// for i := 1 to 16 do
25385: LD_ADDR_VAR 0 2
25389: PUSH
25390: DOUBLE
25391: LD_INT 1
25393: DEC
25394: ST_TO_ADDR
25395: LD_INT 16
25397: PUSH
25398: FOR_TO
25399: IFFALSE 25598
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25401: LD_ADDR_VAR 0 3
25405: PUSH
25406: LD_INT 10
25408: PUSH
25409: LD_INT 20
25411: PUSH
25412: LD_INT 30
25414: PUSH
25415: LD_INT 40
25417: PUSH
25418: LD_INT 50
25420: PUSH
25421: LD_INT 60
25423: PUSH
25424: LD_INT 70
25426: PUSH
25427: LD_INT 80
25429: PUSH
25430: LD_INT 90
25432: PUSH
25433: LD_INT 100
25435: PUSH
25436: LD_INT 110
25438: PUSH
25439: LD_INT 120
25441: PUSH
25442: LD_INT 130
25444: PUSH
25445: LD_INT 140
25447: PUSH
25448: LD_INT 150
25450: PUSH
25451: EMPTY
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 1
25470: PPUSH
25471: LD_INT 15
25473: PPUSH
25474: CALL_OW 12
25478: ARRAY
25479: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25480: LD_ADDR_VAR 0 4
25484: PUSH
25485: LD_INT 10
25487: PUSH
25488: LD_INT 20
25490: PUSH
25491: LD_INT 30
25493: PUSH
25494: LD_INT 40
25496: PUSH
25497: LD_INT 50
25499: PUSH
25500: LD_INT 60
25502: PUSH
25503: LD_INT 70
25505: PUSH
25506: LD_INT 80
25508: PUSH
25509: LD_INT 90
25511: PUSH
25512: LD_INT 100
25514: PUSH
25515: LD_INT 110
25517: PUSH
25518: LD_INT 120
25520: PUSH
25521: LD_INT 130
25523: PUSH
25524: LD_INT 140
25526: PUSH
25527: LD_INT 150
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: LIST
25538: LIST
25539: LIST
25540: LIST
25541: LIST
25542: LIST
25543: LIST
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 1
25549: PPUSH
25550: LD_INT 15
25552: PPUSH
25553: CALL_OW 12
25557: ARRAY
25558: ST_TO_ADDR
// if ValidHex ( x , y ) then
25559: LD_VAR 0 3
25563: PPUSH
25564: LD_VAR 0 4
25568: PPUSH
25569: CALL_OW 488
25573: IFFALSE 25596
// begin result := [ x , y ] ;
25575: LD_ADDR_VAR 0 1
25579: PUSH
25580: LD_VAR 0 3
25584: PUSH
25585: LD_VAR 0 4
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: ST_TO_ADDR
// break ;
25594: GO 25598
// end ; end ;
25596: GO 25398
25598: POP
25599: POP
// if result then
25600: LD_VAR 0 1
25604: IFFALSE 25664
// begin ToLua ( playSibBomb() ) ;
25606: LD_STRING playSibBomb()
25608: PPUSH
25609: CALL_OW 559
// wait ( 0 0$14 ) ;
25613: LD_INT 490
25615: PPUSH
25616: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25620: LD_VAR 0 1
25624: PUSH
25625: LD_INT 1
25627: ARRAY
25628: PPUSH
25629: LD_VAR 0 1
25633: PUSH
25634: LD_INT 2
25636: ARRAY
25637: PPUSH
25638: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25642: LD_VAR 0 1
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PPUSH
25651: LD_VAR 0 1
25655: PUSH
25656: LD_INT 2
25658: ARRAY
25659: PPUSH
25660: CALL_OW 429
// end ; end ;
25664: LD_VAR 0 1
25668: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25669: LD_EXP 67
25673: PUSH
25674: LD_EXP 89
25678: AND
25679: IFFALSE 25691
25681: GO 25683
25683: DISABLE
// YouLost (  ) ;
25684: LD_STRING 
25686: PPUSH
25687: CALL_OW 104
25691: END
// every 0 0$1 trigger StreamModeActive and sFog do
25692: LD_EXP 67
25696: PUSH
25697: LD_EXP 88
25701: AND
25702: IFFALSE 25716
25704: GO 25706
25706: DISABLE
// FogOff ( your_side ) ;
25707: LD_OWVAR 2
25711: PPUSH
25712: CALL_OW 344
25716: END
// every 0 0$1 trigger StreamModeActive and sSun do
25717: LD_EXP 67
25721: PUSH
25722: LD_EXP 90
25726: AND
25727: IFFALSE 25755
25729: GO 25731
25731: DISABLE
// begin solar_recharge_percent := 0 ;
25732: LD_ADDR_OWVAR 79
25736: PUSH
25737: LD_INT 0
25739: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25740: LD_INT 10500
25742: PPUSH
25743: CALL_OW 67
// solar_recharge_percent := 100 ;
25747: LD_ADDR_OWVAR 79
25751: PUSH
25752: LD_INT 100
25754: ST_TO_ADDR
// end ;
25755: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25756: LD_EXP 67
25760: PUSH
25761: LD_EXP 91
25765: AND
25766: IFFALSE 26005
25768: GO 25770
25770: DISABLE
25771: LD_INT 0
25773: PPUSH
25774: PPUSH
25775: PPUSH
// begin tmp := [ ] ;
25776: LD_ADDR_VAR 0 3
25780: PUSH
25781: EMPTY
25782: ST_TO_ADDR
// for i := 1 to 6 do
25783: LD_ADDR_VAR 0 1
25787: PUSH
25788: DOUBLE
25789: LD_INT 1
25791: DEC
25792: ST_TO_ADDR
25793: LD_INT 6
25795: PUSH
25796: FOR_TO
25797: IFFALSE 25902
// begin uc_nation := nation_nature ;
25799: LD_ADDR_OWVAR 21
25803: PUSH
25804: LD_INT 0
25806: ST_TO_ADDR
// uc_side := 0 ;
25807: LD_ADDR_OWVAR 20
25811: PUSH
25812: LD_INT 0
25814: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25815: LD_ADDR_OWVAR 29
25819: PUSH
25820: LD_INT 12
25822: PUSH
25823: LD_INT 12
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: ST_TO_ADDR
// hc_agressivity := 20 ;
25830: LD_ADDR_OWVAR 35
25834: PUSH
25835: LD_INT 20
25837: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25838: LD_ADDR_OWVAR 28
25842: PUSH
25843: LD_INT 17
25845: ST_TO_ADDR
// hc_gallery :=  ;
25846: LD_ADDR_OWVAR 33
25850: PUSH
25851: LD_STRING 
25853: ST_TO_ADDR
// hc_name :=  ;
25854: LD_ADDR_OWVAR 26
25858: PUSH
25859: LD_STRING 
25861: ST_TO_ADDR
// un := CreateHuman ;
25862: LD_ADDR_VAR 0 2
25866: PUSH
25867: CALL_OW 44
25871: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25872: LD_VAR 0 2
25876: PPUSH
25877: LD_INT 1
25879: PPUSH
25880: CALL_OW 51
// tmp := tmp ^ un ;
25884: LD_ADDR_VAR 0 3
25888: PUSH
25889: LD_VAR 0 3
25893: PUSH
25894: LD_VAR 0 2
25898: ADD
25899: ST_TO_ADDR
// end ;
25900: GO 25796
25902: POP
25903: POP
// repeat wait ( 0 0$1 ) ;
25904: LD_INT 35
25906: PPUSH
25907: CALL_OW 67
// for un in tmp do
25911: LD_ADDR_VAR 0 2
25915: PUSH
25916: LD_VAR 0 3
25920: PUSH
25921: FOR_IN
25922: IFFALSE 25996
// begin if IsDead ( un ) then
25924: LD_VAR 0 2
25928: PPUSH
25929: CALL_OW 301
25933: IFFALSE 25953
// begin tmp := tmp diff un ;
25935: LD_ADDR_VAR 0 3
25939: PUSH
25940: LD_VAR 0 3
25944: PUSH
25945: LD_VAR 0 2
25949: DIFF
25950: ST_TO_ADDR
// continue ;
25951: GO 25921
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25953: LD_VAR 0 2
25957: PPUSH
25958: LD_INT 3
25960: PUSH
25961: LD_INT 22
25963: PUSH
25964: LD_INT 0
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: PPUSH
25975: CALL_OW 69
25979: PPUSH
25980: LD_VAR 0 2
25984: PPUSH
25985: CALL_OW 74
25989: PPUSH
25990: CALL_OW 115
// end ;
25994: GO 25921
25996: POP
25997: POP
// until not tmp ;
25998: LD_VAR 0 3
26002: NOT
26003: IFFALSE 25904
// end ;
26005: PPOPN 3
26007: END
// every 0 0$1 trigger StreamModeActive and sTroll do
26008: LD_EXP 67
26012: PUSH
26013: LD_EXP 92
26017: AND
26018: IFFALSE 26072
26020: GO 26022
26022: DISABLE
// begin ToLua ( displayTroll(); ) ;
26023: LD_STRING displayTroll();
26025: PPUSH
26026: CALL_OW 559
// wait ( 3 3$00 ) ;
26030: LD_INT 6300
26032: PPUSH
26033: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26037: LD_STRING hideTroll();
26039: PPUSH
26040: CALL_OW 559
// wait ( 1 1$00 ) ;
26044: LD_INT 2100
26046: PPUSH
26047: CALL_OW 67
// ToLua ( displayTroll(); ) ;
26051: LD_STRING displayTroll();
26053: PPUSH
26054: CALL_OW 559
// wait ( 1 1$00 ) ;
26058: LD_INT 2100
26060: PPUSH
26061: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26065: LD_STRING hideTroll();
26067: PPUSH
26068: CALL_OW 559
// end ;
26072: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26073: LD_EXP 67
26077: PUSH
26078: LD_EXP 93
26082: AND
26083: IFFALSE 26146
26085: GO 26087
26087: DISABLE
26088: LD_INT 0
26090: PPUSH
// begin p := 0 ;
26091: LD_ADDR_VAR 0 1
26095: PUSH
26096: LD_INT 0
26098: ST_TO_ADDR
// repeat game_speed := 1 ;
26099: LD_ADDR_OWVAR 65
26103: PUSH
26104: LD_INT 1
26106: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26107: LD_INT 35
26109: PPUSH
26110: CALL_OW 67
// p := p + 1 ;
26114: LD_ADDR_VAR 0 1
26118: PUSH
26119: LD_VAR 0 1
26123: PUSH
26124: LD_INT 1
26126: PLUS
26127: ST_TO_ADDR
// until p >= 60 ;
26128: LD_VAR 0 1
26132: PUSH
26133: LD_INT 60
26135: GREATEREQUAL
26136: IFFALSE 26099
// game_speed := 4 ;
26138: LD_ADDR_OWVAR 65
26142: PUSH
26143: LD_INT 4
26145: ST_TO_ADDR
// end ;
26146: PPOPN 1
26148: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26149: LD_EXP 67
26153: PUSH
26154: LD_EXP 94
26158: AND
26159: IFFALSE 26305
26161: GO 26163
26163: DISABLE
26164: LD_INT 0
26166: PPUSH
26167: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26168: LD_ADDR_VAR 0 1
26172: PUSH
26173: LD_INT 22
26175: PUSH
26176: LD_OWVAR 2
26180: PUSH
26181: EMPTY
26182: LIST
26183: LIST
26184: PUSH
26185: LD_INT 2
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 0
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 30
26200: PUSH
26201: LD_INT 1
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: EMPTY
26209: LIST
26210: LIST
26211: LIST
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PPUSH
26217: CALL_OW 69
26221: ST_TO_ADDR
// if not depot then
26222: LD_VAR 0 1
26226: NOT
26227: IFFALSE 26231
// exit ;
26229: GO 26305
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26231: LD_ADDR_VAR 0 2
26235: PUSH
26236: LD_VAR 0 1
26240: PUSH
26241: LD_INT 1
26243: PPUSH
26244: LD_VAR 0 1
26248: PPUSH
26249: CALL_OW 12
26253: ARRAY
26254: PPUSH
26255: CALL_OW 274
26259: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26260: LD_VAR 0 2
26264: PPUSH
26265: LD_INT 1
26267: PPUSH
26268: LD_INT 0
26270: PPUSH
26271: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26275: LD_VAR 0 2
26279: PPUSH
26280: LD_INT 2
26282: PPUSH
26283: LD_INT 0
26285: PPUSH
26286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26290: LD_VAR 0 2
26294: PPUSH
26295: LD_INT 3
26297: PPUSH
26298: LD_INT 0
26300: PPUSH
26301: CALL_OW 277
// end ;
26305: PPOPN 2
26307: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26308: LD_EXP 67
26312: PUSH
26313: LD_EXP 95
26317: AND
26318: IFFALSE 26415
26320: GO 26322
26322: DISABLE
26323: LD_INT 0
26325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26326: LD_ADDR_VAR 0 1
26330: PUSH
26331: LD_INT 22
26333: PUSH
26334: LD_OWVAR 2
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 21
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 3
26355: PUSH
26356: LD_INT 23
26358: PUSH
26359: LD_INT 0
26361: PUSH
26362: EMPTY
26363: LIST
26364: LIST
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: LIST
26374: PPUSH
26375: CALL_OW 69
26379: ST_TO_ADDR
// if not tmp then
26380: LD_VAR 0 1
26384: NOT
26385: IFFALSE 26389
// exit ;
26387: GO 26415
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26389: LD_VAR 0 1
26393: PUSH
26394: LD_INT 1
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 12
26406: ARRAY
26407: PPUSH
26408: LD_INT 200
26410: PPUSH
26411: CALL_OW 234
// end ;
26415: PPOPN 1
26417: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26418: LD_EXP 67
26422: PUSH
26423: LD_EXP 96
26427: AND
26428: IFFALSE 26507
26430: GO 26432
26432: DISABLE
26433: LD_INT 0
26435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26436: LD_ADDR_VAR 0 1
26440: PUSH
26441: LD_INT 22
26443: PUSH
26444: LD_OWVAR 2
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 21
26455: PUSH
26456: LD_INT 2
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PPUSH
26467: CALL_OW 69
26471: ST_TO_ADDR
// if not tmp then
26472: LD_VAR 0 1
26476: NOT
26477: IFFALSE 26481
// exit ;
26479: GO 26507
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26481: LD_VAR 0 1
26485: PUSH
26486: LD_INT 1
26488: PPUSH
26489: LD_VAR 0 1
26493: PPUSH
26494: CALL_OW 12
26498: ARRAY
26499: PPUSH
26500: LD_INT 60
26502: PPUSH
26503: CALL_OW 234
// end ;
26507: PPOPN 1
26509: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26510: LD_EXP 67
26514: PUSH
26515: LD_EXP 97
26519: AND
26520: IFFALSE 26619
26522: GO 26524
26524: DISABLE
26525: LD_INT 0
26527: PPUSH
26528: PPUSH
// begin enable ;
26529: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26530: LD_ADDR_VAR 0 1
26534: PUSH
26535: LD_INT 22
26537: PUSH
26538: LD_OWVAR 2
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PUSH
26547: LD_INT 61
26549: PUSH
26550: EMPTY
26551: LIST
26552: PUSH
26553: LD_INT 33
26555: PUSH
26556: LD_INT 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: LIST
26567: PPUSH
26568: CALL_OW 69
26572: ST_TO_ADDR
// if not tmp then
26573: LD_VAR 0 1
26577: NOT
26578: IFFALSE 26582
// exit ;
26580: GO 26619
// for i in tmp do
26582: LD_ADDR_VAR 0 2
26586: PUSH
26587: LD_VAR 0 1
26591: PUSH
26592: FOR_IN
26593: IFFALSE 26617
// if IsControledBy ( i ) then
26595: LD_VAR 0 2
26599: PPUSH
26600: CALL_OW 312
26604: IFFALSE 26615
// ComUnlink ( i ) ;
26606: LD_VAR 0 2
26610: PPUSH
26611: CALL_OW 136
26615: GO 26592
26617: POP
26618: POP
// end ;
26619: PPOPN 2
26621: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26622: LD_EXP 67
26626: PUSH
26627: LD_EXP 98
26631: AND
26632: IFFALSE 26772
26634: GO 26636
26636: DISABLE
26637: LD_INT 0
26639: PPUSH
26640: PPUSH
// begin ToLua ( displayPowell(); ) ;
26641: LD_STRING displayPowell();
26643: PPUSH
26644: CALL_OW 559
// uc_side := 0 ;
26648: LD_ADDR_OWVAR 20
26652: PUSH
26653: LD_INT 0
26655: ST_TO_ADDR
// uc_nation := 2 ;
26656: LD_ADDR_OWVAR 21
26660: PUSH
26661: LD_INT 2
26663: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26664: LD_ADDR_OWVAR 37
26668: PUSH
26669: LD_INT 14
26671: ST_TO_ADDR
// vc_engine := engine_siberite ;
26672: LD_ADDR_OWVAR 39
26676: PUSH
26677: LD_INT 3
26679: ST_TO_ADDR
// vc_control := control_apeman ;
26680: LD_ADDR_OWVAR 38
26684: PUSH
26685: LD_INT 5
26687: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26688: LD_ADDR_OWVAR 40
26692: PUSH
26693: LD_INT 29
26695: ST_TO_ADDR
// un := CreateVehicle ;
26696: LD_ADDR_VAR 0 2
26700: PUSH
26701: CALL_OW 45
26705: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26706: LD_VAR 0 2
26710: PPUSH
26711: LD_INT 1
26713: PPUSH
26714: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26718: LD_INT 35
26720: PPUSH
26721: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26725: LD_VAR 0 2
26729: PPUSH
26730: LD_INT 22
26732: PUSH
26733: LD_OWVAR 2
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PPUSH
26742: CALL_OW 69
26746: PPUSH
26747: LD_VAR 0 2
26751: PPUSH
26752: CALL_OW 74
26756: PPUSH
26757: CALL_OW 115
// until IsDead ( un ) ;
26761: LD_VAR 0 2
26765: PPUSH
26766: CALL_OW 301
26770: IFFALSE 26718
// end ;
26772: PPOPN 2
26774: END
// every 0 0$1 trigger StreamModeActive and sStu do
26775: LD_EXP 67
26779: PUSH
26780: LD_EXP 106
26784: AND
26785: IFFALSE 26801
26787: GO 26789
26789: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26790: LD_STRING displayStucuk();
26792: PPUSH
26793: CALL_OW 559
// ResetFog ;
26797: CALL_OW 335
// end ;
26801: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26802: LD_EXP 67
26806: PUSH
26807: LD_EXP 99
26811: AND
26812: IFFALSE 26953
26814: GO 26816
26816: DISABLE
26817: LD_INT 0
26819: PPUSH
26820: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26821: LD_ADDR_VAR 0 2
26825: PUSH
26826: LD_INT 22
26828: PUSH
26829: LD_OWVAR 2
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: LD_INT 21
26840: PUSH
26841: LD_INT 1
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: EMPTY
26849: LIST
26850: LIST
26851: PPUSH
26852: CALL_OW 69
26856: ST_TO_ADDR
// if not tmp then
26857: LD_VAR 0 2
26861: NOT
26862: IFFALSE 26866
// exit ;
26864: GO 26953
// un := tmp [ rand ( 1 , tmp ) ] ;
26866: LD_ADDR_VAR 0 1
26870: PUSH
26871: LD_VAR 0 2
26875: PUSH
26876: LD_INT 1
26878: PPUSH
26879: LD_VAR 0 2
26883: PPUSH
26884: CALL_OW 12
26888: ARRAY
26889: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26890: LD_VAR 0 1
26894: PPUSH
26895: LD_INT 0
26897: PPUSH
26898: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26902: LD_VAR 0 1
26906: PPUSH
26907: LD_OWVAR 3
26911: PUSH
26912: LD_VAR 0 1
26916: DIFF
26917: PPUSH
26918: LD_VAR 0 1
26922: PPUSH
26923: CALL_OW 74
26927: PPUSH
26928: CALL_OW 115
// wait ( 0 0$20 ) ;
26932: LD_INT 700
26934: PPUSH
26935: CALL_OW 67
// SetSide ( un , your_side ) ;
26939: LD_VAR 0 1
26943: PPUSH
26944: LD_OWVAR 2
26948: PPUSH
26949: CALL_OW 235
// end ;
26953: PPOPN 2
26955: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26956: LD_EXP 67
26960: PUSH
26961: LD_EXP 100
26965: AND
26966: IFFALSE 27072
26968: GO 26970
26970: DISABLE
26971: LD_INT 0
26973: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26974: LD_ADDR_VAR 0 1
26978: PUSH
26979: LD_INT 22
26981: PUSH
26982: LD_OWVAR 2
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: PUSH
26991: LD_INT 2
26993: PUSH
26994: LD_INT 30
26996: PUSH
26997: LD_INT 0
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 30
27006: PUSH
27007: LD_INT 1
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: LIST
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: PPUSH
27023: CALL_OW 69
27027: ST_TO_ADDR
// if not depot then
27028: LD_VAR 0 1
27032: NOT
27033: IFFALSE 27037
// exit ;
27035: GO 27072
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
27037: LD_VAR 0 1
27041: PUSH
27042: LD_INT 1
27044: ARRAY
27045: PPUSH
27046: CALL_OW 250
27050: PPUSH
27051: LD_VAR 0 1
27055: PUSH
27056: LD_INT 1
27058: ARRAY
27059: PPUSH
27060: CALL_OW 251
27064: PPUSH
27065: LD_INT 70
27067: PPUSH
27068: CALL_OW 495
// end ;
27072: PPOPN 1
27074: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27075: LD_EXP 67
27079: PUSH
27080: LD_EXP 101
27084: AND
27085: IFFALSE 27296
27087: GO 27089
27089: DISABLE
27090: LD_INT 0
27092: PPUSH
27093: PPUSH
27094: PPUSH
27095: PPUSH
27096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27097: LD_ADDR_VAR 0 5
27101: PUSH
27102: LD_INT 22
27104: PUSH
27105: LD_OWVAR 2
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: LD_INT 21
27116: PUSH
27117: LD_INT 1
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PPUSH
27128: CALL_OW 69
27132: ST_TO_ADDR
// if not tmp then
27133: LD_VAR 0 5
27137: NOT
27138: IFFALSE 27142
// exit ;
27140: GO 27296
// for i in tmp do
27142: LD_ADDR_VAR 0 1
27146: PUSH
27147: LD_VAR 0 5
27151: PUSH
27152: FOR_IN
27153: IFFALSE 27294
// begin d := rand ( 0 , 5 ) ;
27155: LD_ADDR_VAR 0 4
27159: PUSH
27160: LD_INT 0
27162: PPUSH
27163: LD_INT 5
27165: PPUSH
27166: CALL_OW 12
27170: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27171: LD_ADDR_VAR 0 2
27175: PUSH
27176: LD_VAR 0 1
27180: PPUSH
27181: CALL_OW 250
27185: PPUSH
27186: LD_VAR 0 4
27190: PPUSH
27191: LD_INT 3
27193: PPUSH
27194: LD_INT 12
27196: PPUSH
27197: CALL_OW 12
27201: PPUSH
27202: CALL_OW 272
27206: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27207: LD_ADDR_VAR 0 3
27211: PUSH
27212: LD_VAR 0 1
27216: PPUSH
27217: CALL_OW 251
27221: PPUSH
27222: LD_VAR 0 4
27226: PPUSH
27227: LD_INT 3
27229: PPUSH
27230: LD_INT 12
27232: PPUSH
27233: CALL_OW 12
27237: PPUSH
27238: CALL_OW 273
27242: ST_TO_ADDR
// if ValidHex ( x , y ) then
27243: LD_VAR 0 2
27247: PPUSH
27248: LD_VAR 0 3
27252: PPUSH
27253: CALL_OW 488
27257: IFFALSE 27292
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27259: LD_VAR 0 1
27263: PPUSH
27264: LD_VAR 0 2
27268: PPUSH
27269: LD_VAR 0 3
27273: PPUSH
27274: LD_INT 3
27276: PPUSH
27277: LD_INT 6
27279: PPUSH
27280: CALL_OW 12
27284: PPUSH
27285: LD_INT 1
27287: PPUSH
27288: CALL_OW 483
// end ;
27292: GO 27152
27294: POP
27295: POP
// end ;
27296: PPOPN 5
27298: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27299: LD_EXP 67
27303: PUSH
27304: LD_EXP 102
27308: AND
27309: IFFALSE 27403
27311: GO 27313
27313: DISABLE
27314: LD_INT 0
27316: PPUSH
27317: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27318: LD_ADDR_VAR 0 2
27322: PUSH
27323: LD_INT 22
27325: PUSH
27326: LD_OWVAR 2
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 32
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 21
27347: PUSH
27348: LD_INT 2
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: LIST
27359: PPUSH
27360: CALL_OW 69
27364: ST_TO_ADDR
// if not tmp then
27365: LD_VAR 0 2
27369: NOT
27370: IFFALSE 27374
// exit ;
27372: GO 27403
// for i in tmp do
27374: LD_ADDR_VAR 0 1
27378: PUSH
27379: LD_VAR 0 2
27383: PUSH
27384: FOR_IN
27385: IFFALSE 27401
// SetFuel ( i , 0 ) ;
27387: LD_VAR 0 1
27391: PPUSH
27392: LD_INT 0
27394: PPUSH
27395: CALL_OW 240
27399: GO 27384
27401: POP
27402: POP
// end ;
27403: PPOPN 2
27405: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27406: LD_EXP 67
27410: PUSH
27411: LD_EXP 103
27415: AND
27416: IFFALSE 27482
27418: GO 27420
27420: DISABLE
27421: LD_INT 0
27423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27424: LD_ADDR_VAR 0 1
27428: PUSH
27429: LD_INT 22
27431: PUSH
27432: LD_OWVAR 2
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: LD_INT 30
27443: PUSH
27444: LD_INT 29
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PPUSH
27455: CALL_OW 69
27459: ST_TO_ADDR
// if not tmp then
27460: LD_VAR 0 1
27464: NOT
27465: IFFALSE 27469
// exit ;
27467: GO 27482
// DestroyUnit ( tmp [ 1 ] ) ;
27469: LD_VAR 0 1
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: PPUSH
27478: CALL_OW 65
// end ;
27482: PPOPN 1
27484: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27485: LD_EXP 67
27489: PUSH
27490: LD_EXP 105
27494: AND
27495: IFFALSE 27624
27497: GO 27499
27499: DISABLE
27500: LD_INT 0
27502: PPUSH
// begin uc_side := 0 ;
27503: LD_ADDR_OWVAR 20
27507: PUSH
27508: LD_INT 0
27510: ST_TO_ADDR
// uc_nation := nation_arabian ;
27511: LD_ADDR_OWVAR 21
27515: PUSH
27516: LD_INT 2
27518: ST_TO_ADDR
// hc_gallery :=  ;
27519: LD_ADDR_OWVAR 33
27523: PUSH
27524: LD_STRING 
27526: ST_TO_ADDR
// hc_name :=  ;
27527: LD_ADDR_OWVAR 26
27531: PUSH
27532: LD_STRING 
27534: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27535: LD_INT 1
27537: PPUSH
27538: LD_INT 11
27540: PPUSH
27541: LD_INT 10
27543: PPUSH
27544: CALL_OW 380
// un := CreateHuman ;
27548: LD_ADDR_VAR 0 1
27552: PUSH
27553: CALL_OW 44
27557: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27558: LD_VAR 0 1
27562: PPUSH
27563: LD_INT 1
27565: PPUSH
27566: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27570: LD_INT 35
27572: PPUSH
27573: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27577: LD_VAR 0 1
27581: PPUSH
27582: LD_INT 22
27584: PUSH
27585: LD_OWVAR 2
27589: PUSH
27590: EMPTY
27591: LIST
27592: LIST
27593: PPUSH
27594: CALL_OW 69
27598: PPUSH
27599: LD_VAR 0 1
27603: PPUSH
27604: CALL_OW 74
27608: PPUSH
27609: CALL_OW 115
// until IsDead ( un ) ;
27613: LD_VAR 0 1
27617: PPUSH
27618: CALL_OW 301
27622: IFFALSE 27570
// end ;
27624: PPOPN 1
27626: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27627: LD_EXP 67
27631: PUSH
27632: LD_EXP 107
27636: AND
27637: IFFALSE 27649
27639: GO 27641
27641: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27642: LD_STRING earthquake(getX(game), 0, 32)
27644: PPUSH
27645: CALL_OW 559
27649: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27650: LD_EXP 67
27654: PUSH
27655: LD_EXP 108
27659: AND
27660: IFFALSE 27751
27662: GO 27664
27664: DISABLE
27665: LD_INT 0
27667: PPUSH
// begin enable ;
27668: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27669: LD_ADDR_VAR 0 1
27673: PUSH
27674: LD_INT 22
27676: PUSH
27677: LD_OWVAR 2
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 21
27688: PUSH
27689: LD_INT 2
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: LD_INT 33
27698: PUSH
27699: LD_INT 3
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: LIST
27710: PPUSH
27711: CALL_OW 69
27715: ST_TO_ADDR
// if not tmp then
27716: LD_VAR 0 1
27720: NOT
27721: IFFALSE 27725
// exit ;
27723: GO 27751
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27725: LD_VAR 0 1
27729: PUSH
27730: LD_INT 1
27732: PPUSH
27733: LD_VAR 0 1
27737: PPUSH
27738: CALL_OW 12
27742: ARRAY
27743: PPUSH
27744: LD_INT 1
27746: PPUSH
27747: CALL_OW 234
// end ;
27751: PPOPN 1
27753: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27754: LD_EXP 67
27758: PUSH
27759: LD_EXP 109
27763: AND
27764: IFFALSE 27905
27766: GO 27768
27768: DISABLE
27769: LD_INT 0
27771: PPUSH
27772: PPUSH
27773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27774: LD_ADDR_VAR 0 3
27778: PUSH
27779: LD_INT 22
27781: PUSH
27782: LD_OWVAR 2
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 1
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PPUSH
27805: CALL_OW 69
27809: ST_TO_ADDR
// if not tmp then
27810: LD_VAR 0 3
27814: NOT
27815: IFFALSE 27819
// exit ;
27817: GO 27905
// un := tmp [ rand ( 1 , tmp ) ] ;
27819: LD_ADDR_VAR 0 2
27823: PUSH
27824: LD_VAR 0 3
27828: PUSH
27829: LD_INT 1
27831: PPUSH
27832: LD_VAR 0 3
27836: PPUSH
27837: CALL_OW 12
27841: ARRAY
27842: ST_TO_ADDR
// if Crawls ( un ) then
27843: LD_VAR 0 2
27847: PPUSH
27848: CALL_OW 318
27852: IFFALSE 27863
// ComWalk ( un ) ;
27854: LD_VAR 0 2
27858: PPUSH
27859: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27863: LD_VAR 0 2
27867: PPUSH
27868: LD_INT 9
27870: PPUSH
27871: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27875: LD_INT 28
27877: PPUSH
27878: LD_OWVAR 2
27882: PPUSH
27883: LD_INT 2
27885: PPUSH
27886: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27890: LD_INT 29
27892: PPUSH
27893: LD_OWVAR 2
27897: PPUSH
27898: LD_INT 2
27900: PPUSH
27901: CALL_OW 322
// end ;
27905: PPOPN 3
27907: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27908: LD_EXP 67
27912: PUSH
27913: LD_EXP 110
27917: AND
27918: IFFALSE 28029
27920: GO 27922
27922: DISABLE
27923: LD_INT 0
27925: PPUSH
27926: PPUSH
27927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27928: LD_ADDR_VAR 0 3
27932: PUSH
27933: LD_INT 22
27935: PUSH
27936: LD_OWVAR 2
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: PUSH
27945: LD_INT 25
27947: PUSH
27948: LD_INT 1
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: PUSH
27955: EMPTY
27956: LIST
27957: LIST
27958: PPUSH
27959: CALL_OW 69
27963: ST_TO_ADDR
// if not tmp then
27964: LD_VAR 0 3
27968: NOT
27969: IFFALSE 27973
// exit ;
27971: GO 28029
// un := tmp [ rand ( 1 , tmp ) ] ;
27973: LD_ADDR_VAR 0 2
27977: PUSH
27978: LD_VAR 0 3
27982: PUSH
27983: LD_INT 1
27985: PPUSH
27986: LD_VAR 0 3
27990: PPUSH
27991: CALL_OW 12
27995: ARRAY
27996: ST_TO_ADDR
// if Crawls ( un ) then
27997: LD_VAR 0 2
28001: PPUSH
28002: CALL_OW 318
28006: IFFALSE 28017
// ComWalk ( un ) ;
28008: LD_VAR 0 2
28012: PPUSH
28013: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28017: LD_VAR 0 2
28021: PPUSH
28022: LD_INT 8
28024: PPUSH
28025: CALL_OW 336
// end ;
28029: PPOPN 3
28031: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
28032: LD_EXP 67
28036: PUSH
28037: LD_EXP 111
28041: AND
28042: IFFALSE 28186
28044: GO 28046
28046: DISABLE
28047: LD_INT 0
28049: PPUSH
28050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
28051: LD_ADDR_VAR 0 2
28055: PUSH
28056: LD_INT 22
28058: PUSH
28059: LD_OWVAR 2
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 21
28070: PUSH
28071: LD_INT 2
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 2
28080: PUSH
28081: LD_INT 34
28083: PUSH
28084: LD_INT 12
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 51
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 32
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: LIST
28115: LIST
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: LIST
28121: PPUSH
28122: CALL_OW 69
28126: ST_TO_ADDR
// if not tmp then
28127: LD_VAR 0 2
28131: NOT
28132: IFFALSE 28136
// exit ;
28134: GO 28186
// for i in tmp do
28136: LD_ADDR_VAR 0 1
28140: PUSH
28141: LD_VAR 0 2
28145: PUSH
28146: FOR_IN
28147: IFFALSE 28184
// if GetCargo ( i , mat_artifact ) = 0 then
28149: LD_VAR 0 1
28153: PPUSH
28154: LD_INT 4
28156: PPUSH
28157: CALL_OW 289
28161: PUSH
28162: LD_INT 0
28164: EQUAL
28165: IFFALSE 28182
// SetCargo ( i , mat_siberit , 100 ) ;
28167: LD_VAR 0 1
28171: PPUSH
28172: LD_INT 3
28174: PPUSH
28175: LD_INT 100
28177: PPUSH
28178: CALL_OW 290
28182: GO 28146
28184: POP
28185: POP
// end ;
28186: PPOPN 2
28188: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28189: LD_EXP 67
28193: PUSH
28194: LD_EXP 112
28198: AND
28199: IFFALSE 28416
28201: GO 28203
28203: DISABLE
28204: LD_INT 0
28206: PPUSH
28207: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28208: LD_ADDR_VAR 0 2
28212: PUSH
28213: LD_INT 22
28215: PUSH
28216: LD_OWVAR 2
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: PPUSH
28225: CALL_OW 69
28229: ST_TO_ADDR
// if not tmp then
28230: LD_VAR 0 2
28234: NOT
28235: IFFALSE 28239
// exit ;
28237: GO 28416
// for i := 1 to 2 do
28239: LD_ADDR_VAR 0 1
28243: PUSH
28244: DOUBLE
28245: LD_INT 1
28247: DEC
28248: ST_TO_ADDR
28249: LD_INT 2
28251: PUSH
28252: FOR_TO
28253: IFFALSE 28414
// begin uc_side := your_side ;
28255: LD_ADDR_OWVAR 20
28259: PUSH
28260: LD_OWVAR 2
28264: ST_TO_ADDR
// uc_nation := nation_american ;
28265: LD_ADDR_OWVAR 21
28269: PUSH
28270: LD_INT 1
28272: ST_TO_ADDR
// vc_chassis := us_morphling ;
28273: LD_ADDR_OWVAR 37
28277: PUSH
28278: LD_INT 5
28280: ST_TO_ADDR
// vc_engine := engine_siberite ;
28281: LD_ADDR_OWVAR 39
28285: PUSH
28286: LD_INT 3
28288: ST_TO_ADDR
// vc_control := control_computer ;
28289: LD_ADDR_OWVAR 38
28293: PUSH
28294: LD_INT 3
28296: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28297: LD_ADDR_OWVAR 40
28301: PUSH
28302: LD_INT 10
28304: ST_TO_ADDR
// if HexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) and not IsInUnit ( tmp [ 1 ] ) then
28305: LD_VAR 0 2
28309: PUSH
28310: LD_INT 1
28312: ARRAY
28313: PPUSH
28314: CALL_OW 250
28318: PPUSH
28319: LD_VAR 0 2
28323: PUSH
28324: LD_INT 1
28326: ARRAY
28327: PPUSH
28328: CALL_OW 251
28332: PPUSH
28333: CALL_OW 428
28337: PUSH
28338: LD_VAR 0 2
28342: PUSH
28343: LD_INT 1
28345: ARRAY
28346: PPUSH
28347: CALL_OW 310
28351: NOT
28352: AND
28353: IFFALSE 28400
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
28355: CALL_OW 45
28359: PPUSH
28360: LD_VAR 0 2
28364: PUSH
28365: LD_INT 1
28367: ARRAY
28368: PPUSH
28369: CALL_OW 250
28373: PPUSH
28374: LD_VAR 0 2
28378: PUSH
28379: LD_INT 1
28381: ARRAY
28382: PPUSH
28383: CALL_OW 251
28387: PPUSH
28388: LD_INT 12
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: CALL_OW 50
28398: GO 28412
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
28400: CALL_OW 45
28404: PPUSH
28405: LD_INT 1
28407: PPUSH
28408: CALL_OW 51
// end ;
28412: GO 28252
28414: POP
28415: POP
// end ;
28416: PPOPN 2
28418: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28419: LD_EXP 67
28423: PUSH
28424: LD_EXP 113
28428: AND
28429: IFFALSE 28651
28431: GO 28433
28433: DISABLE
28434: LD_INT 0
28436: PPUSH
28437: PPUSH
28438: PPUSH
28439: PPUSH
28440: PPUSH
28441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28442: LD_ADDR_VAR 0 6
28446: PUSH
28447: LD_INT 22
28449: PUSH
28450: LD_OWVAR 2
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: LD_INT 21
28461: PUSH
28462: LD_INT 1
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 3
28471: PUSH
28472: LD_INT 23
28474: PUSH
28475: LD_INT 0
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: LIST
28490: PPUSH
28491: CALL_OW 69
28495: ST_TO_ADDR
// if not tmp then
28496: LD_VAR 0 6
28500: NOT
28501: IFFALSE 28505
// exit ;
28503: GO 28651
// s1 := rand ( 1 , 4 ) ;
28505: LD_ADDR_VAR 0 2
28509: PUSH
28510: LD_INT 1
28512: PPUSH
28513: LD_INT 4
28515: PPUSH
28516: CALL_OW 12
28520: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28521: LD_ADDR_VAR 0 4
28525: PUSH
28526: LD_VAR 0 6
28530: PUSH
28531: LD_INT 1
28533: ARRAY
28534: PPUSH
28535: LD_VAR 0 2
28539: PPUSH
28540: CALL_OW 259
28544: ST_TO_ADDR
// if s1 = 1 then
28545: LD_VAR 0 2
28549: PUSH
28550: LD_INT 1
28552: EQUAL
28553: IFFALSE 28573
// s2 := rand ( 2 , 4 ) else
28555: LD_ADDR_VAR 0 3
28559: PUSH
28560: LD_INT 2
28562: PPUSH
28563: LD_INT 4
28565: PPUSH
28566: CALL_OW 12
28570: ST_TO_ADDR
28571: GO 28581
// s2 := 1 ;
28573: LD_ADDR_VAR 0 3
28577: PUSH
28578: LD_INT 1
28580: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28581: LD_ADDR_VAR 0 5
28585: PUSH
28586: LD_VAR 0 6
28590: PUSH
28591: LD_INT 1
28593: ARRAY
28594: PPUSH
28595: LD_VAR 0 3
28599: PPUSH
28600: CALL_OW 259
28604: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28605: LD_VAR 0 6
28609: PUSH
28610: LD_INT 1
28612: ARRAY
28613: PPUSH
28614: LD_VAR 0 2
28618: PPUSH
28619: LD_VAR 0 5
28623: PPUSH
28624: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28628: LD_VAR 0 6
28632: PUSH
28633: LD_INT 1
28635: ARRAY
28636: PPUSH
28637: LD_VAR 0 3
28641: PPUSH
28642: LD_VAR 0 4
28646: PPUSH
28647: CALL_OW 237
// end ;
28651: PPOPN 6
28653: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28654: LD_EXP 67
28658: PUSH
28659: LD_EXP 114
28663: AND
28664: IFFALSE 28743
28666: GO 28668
28668: DISABLE
28669: LD_INT 0
28671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28672: LD_ADDR_VAR 0 1
28676: PUSH
28677: LD_INT 22
28679: PUSH
28680: LD_OWVAR 2
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 30
28691: PUSH
28692: LD_INT 3
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: PPUSH
28703: CALL_OW 69
28707: ST_TO_ADDR
// if not tmp then
28708: LD_VAR 0 1
28712: NOT
28713: IFFALSE 28717
// exit ;
28715: GO 28743
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28717: LD_VAR 0 1
28721: PUSH
28722: LD_INT 1
28724: PPUSH
28725: LD_VAR 0 1
28729: PPUSH
28730: CALL_OW 12
28734: ARRAY
28735: PPUSH
28736: LD_INT 1
28738: PPUSH
28739: CALL_OW 234
// end ;
28743: PPOPN 1
28745: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28746: LD_EXP 67
28750: PUSH
28751: LD_EXP 115
28755: AND
28756: IFFALSE 28868
28758: GO 28760
28760: DISABLE
28761: LD_INT 0
28763: PPUSH
28764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28765: LD_ADDR_VAR 0 2
28769: PUSH
28770: LD_INT 22
28772: PUSH
28773: LD_OWVAR 2
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: LD_INT 2
28784: PUSH
28785: LD_INT 30
28787: PUSH
28788: LD_INT 27
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 30
28797: PUSH
28798: LD_INT 26
28800: PUSH
28801: EMPTY
28802: LIST
28803: LIST
28804: PUSH
28805: LD_INT 30
28807: PUSH
28808: LD_INT 28
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: PUSH
28821: EMPTY
28822: LIST
28823: LIST
28824: PPUSH
28825: CALL_OW 69
28829: ST_TO_ADDR
// if not tmp then
28830: LD_VAR 0 2
28834: NOT
28835: IFFALSE 28839
// exit ;
28837: GO 28868
// for i in tmp do
28839: LD_ADDR_VAR 0 1
28843: PUSH
28844: LD_VAR 0 2
28848: PUSH
28849: FOR_IN
28850: IFFALSE 28866
// SetLives ( i , 1 ) ;
28852: LD_VAR 0 1
28856: PPUSH
28857: LD_INT 1
28859: PPUSH
28860: CALL_OW 234
28864: GO 28849
28866: POP
28867: POP
// end ;
28868: PPOPN 2
28870: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28871: LD_EXP 67
28875: PUSH
28876: LD_EXP 116
28880: AND
28881: IFFALSE 29155
28883: GO 28885
28885: DISABLE
28886: LD_INT 0
28888: PPUSH
28889: PPUSH
28890: PPUSH
// begin i := rand ( 1 , 7 ) ;
28891: LD_ADDR_VAR 0 1
28895: PUSH
28896: LD_INT 1
28898: PPUSH
28899: LD_INT 7
28901: PPUSH
28902: CALL_OW 12
28906: ST_TO_ADDR
// case i of 1 :
28907: LD_VAR 0 1
28911: PUSH
28912: LD_INT 1
28914: DOUBLE
28915: EQUAL
28916: IFTRUE 28920
28918: GO 28930
28920: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28921: LD_STRING earthquake(getX(game), 0, 32)
28923: PPUSH
28924: CALL_OW 559
28928: GO 29155
28930: LD_INT 2
28932: DOUBLE
28933: EQUAL
28934: IFTRUE 28938
28936: GO 28952
28938: POP
// begin ToLua ( displayStucuk(); ) ;
28939: LD_STRING displayStucuk();
28941: PPUSH
28942: CALL_OW 559
// ResetFog ;
28946: CALL_OW 335
// end ; 3 :
28950: GO 29155
28952: LD_INT 3
28954: DOUBLE
28955: EQUAL
28956: IFTRUE 28960
28958: GO 29064
28960: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28961: LD_ADDR_VAR 0 2
28965: PUSH
28966: LD_INT 22
28968: PUSH
28969: LD_OWVAR 2
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 25
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PPUSH
28992: CALL_OW 69
28996: ST_TO_ADDR
// if not tmp then
28997: LD_VAR 0 2
29001: NOT
29002: IFFALSE 29006
// exit ;
29004: GO 29155
// un := tmp [ rand ( 1 , tmp ) ] ;
29006: LD_ADDR_VAR 0 3
29010: PUSH
29011: LD_VAR 0 2
29015: PUSH
29016: LD_INT 1
29018: PPUSH
29019: LD_VAR 0 2
29023: PPUSH
29024: CALL_OW 12
29028: ARRAY
29029: ST_TO_ADDR
// if Crawls ( un ) then
29030: LD_VAR 0 3
29034: PPUSH
29035: CALL_OW 318
29039: IFFALSE 29050
// ComWalk ( un ) ;
29041: LD_VAR 0 3
29045: PPUSH
29046: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29050: LD_VAR 0 3
29054: PPUSH
29055: LD_INT 8
29057: PPUSH
29058: CALL_OW 336
// end ; 4 :
29062: GO 29155
29064: LD_INT 4
29066: DOUBLE
29067: EQUAL
29068: IFTRUE 29072
29070: GO 29133
29072: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29073: LD_ADDR_VAR 0 2
29077: PUSH
29078: LD_INT 22
29080: PUSH
29081: LD_OWVAR 2
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 29
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PPUSH
29104: CALL_OW 69
29108: ST_TO_ADDR
// if not tmp then
29109: LD_VAR 0 2
29113: NOT
29114: IFFALSE 29118
// exit ;
29116: GO 29155
// DestroyUnit ( tmp [ 1 ] ) ;
29118: LD_VAR 0 2
29122: PUSH
29123: LD_INT 1
29125: ARRAY
29126: PPUSH
29127: CALL_OW 65
// end ; 5 .. 7 :
29131: GO 29155
29133: LD_INT 5
29135: DOUBLE
29136: GREATEREQUAL
29137: IFFALSE 29145
29139: LD_INT 7
29141: DOUBLE
29142: LESSEQUAL
29143: IFTRUE 29147
29145: GO 29154
29147: POP
// StreamSibBomb ; end ;
29148: CALL 25371 0 0
29152: GO 29155
29154: POP
// end ;
29155: PPOPN 3
29157: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29158: LD_EXP 67
29162: PUSH
29163: LD_EXP 117
29167: AND
29168: IFFALSE 29324
29170: GO 29172
29172: DISABLE
29173: LD_INT 0
29175: PPUSH
29176: PPUSH
29177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29178: LD_ADDR_VAR 0 2
29182: PUSH
29183: LD_INT 81
29185: PUSH
29186: LD_OWVAR 2
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: LD_INT 21
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 21
29210: PUSH
29211: LD_INT 2
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: LIST
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PPUSH
29227: CALL_OW 69
29231: ST_TO_ADDR
// if not tmp then
29232: LD_VAR 0 2
29236: NOT
29237: IFFALSE 29241
// exit ;
29239: GO 29324
// p := 0 ;
29241: LD_ADDR_VAR 0 3
29245: PUSH
29246: LD_INT 0
29248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29249: LD_INT 35
29251: PPUSH
29252: CALL_OW 67
// p := p + 1 ;
29256: LD_ADDR_VAR 0 3
29260: PUSH
29261: LD_VAR 0 3
29265: PUSH
29266: LD_INT 1
29268: PLUS
29269: ST_TO_ADDR
// for i in tmp do
29270: LD_ADDR_VAR 0 1
29274: PUSH
29275: LD_VAR 0 2
29279: PUSH
29280: FOR_IN
29281: IFFALSE 29312
// if GetLives ( i ) < 1000 then
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 256
29292: PUSH
29293: LD_INT 1000
29295: LESS
29296: IFFALSE 29310
// SetLives ( i , 1000 ) ;
29298: LD_VAR 0 1
29302: PPUSH
29303: LD_INT 1000
29305: PPUSH
29306: CALL_OW 234
29310: GO 29280
29312: POP
29313: POP
// until p > 20 ;
29314: LD_VAR 0 3
29318: PUSH
29319: LD_INT 20
29321: GREATER
29322: IFFALSE 29249
// end ;
29324: PPOPN 3
29326: END
// every 0 0$1 trigger StreamModeActive and sTime do
29327: LD_EXP 67
29331: PUSH
29332: LD_EXP 118
29336: AND
29337: IFFALSE 29372
29339: GO 29341
29341: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29342: LD_INT 28
29344: PPUSH
29345: LD_OWVAR 2
29349: PPUSH
29350: LD_INT 2
29352: PPUSH
29353: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29357: LD_INT 30
29359: PPUSH
29360: LD_OWVAR 2
29364: PPUSH
29365: LD_INT 2
29367: PPUSH
29368: CALL_OW 322
// end ;
29372: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29373: LD_EXP 67
29377: PUSH
29378: LD_EXP 119
29382: AND
29383: IFFALSE 29504
29385: GO 29387
29387: DISABLE
29388: LD_INT 0
29390: PPUSH
29391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29392: LD_ADDR_VAR 0 2
29396: PUSH
29397: LD_INT 22
29399: PUSH
29400: LD_OWVAR 2
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 21
29411: PUSH
29412: LD_INT 1
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 3
29421: PUSH
29422: LD_INT 23
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: LIST
29440: PPUSH
29441: CALL_OW 69
29445: ST_TO_ADDR
// if not tmp then
29446: LD_VAR 0 2
29450: NOT
29451: IFFALSE 29455
// exit ;
29453: GO 29504
// for i in tmp do
29455: LD_ADDR_VAR 0 1
29459: PUSH
29460: LD_VAR 0 2
29464: PUSH
29465: FOR_IN
29466: IFFALSE 29502
// begin if Crawls ( i ) then
29468: LD_VAR 0 1
29472: PPUSH
29473: CALL_OW 318
29477: IFFALSE 29488
// ComWalk ( i ) ;
29479: LD_VAR 0 1
29483: PPUSH
29484: CALL_OW 138
// SetClass ( i , 2 ) ;
29488: LD_VAR 0 1
29492: PPUSH
29493: LD_INT 2
29495: PPUSH
29496: CALL_OW 336
// end ;
29500: GO 29465
29502: POP
29503: POP
// end ;
29504: PPOPN 2
29506: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29507: LD_EXP 67
29511: PUSH
29512: LD_EXP 120
29516: AND
29517: IFFALSE 29798
29519: GO 29521
29521: DISABLE
29522: LD_INT 0
29524: PPUSH
29525: PPUSH
29526: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29527: LD_OWVAR 2
29531: PPUSH
29532: LD_INT 9
29534: PPUSH
29535: LD_INT 1
29537: PPUSH
29538: LD_INT 1
29540: PPUSH
29541: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29545: LD_INT 9
29547: PPUSH
29548: LD_OWVAR 2
29552: PPUSH
29553: CALL_OW 343
// uc_side := 9 ;
29557: LD_ADDR_OWVAR 20
29561: PUSH
29562: LD_INT 9
29564: ST_TO_ADDR
// uc_nation := 2 ;
29565: LD_ADDR_OWVAR 21
29569: PUSH
29570: LD_INT 2
29572: ST_TO_ADDR
// hc_name := Dark Warrior ;
29573: LD_ADDR_OWVAR 26
29577: PUSH
29578: LD_STRING Dark Warrior
29580: ST_TO_ADDR
// hc_gallery :=  ;
29581: LD_ADDR_OWVAR 33
29585: PUSH
29586: LD_STRING 
29588: ST_TO_ADDR
// hc_noskilllimit := true ;
29589: LD_ADDR_OWVAR 76
29593: PUSH
29594: LD_INT 1
29596: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29597: LD_ADDR_OWVAR 31
29601: PUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 30
29607: PUSH
29608: LD_INT 30
29610: PUSH
29611: LD_INT 30
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: ST_TO_ADDR
// un := CreateHuman ;
29620: LD_ADDR_VAR 0 3
29624: PUSH
29625: CALL_OW 44
29629: ST_TO_ADDR
// hc_noskilllimit := false ;
29630: LD_ADDR_OWVAR 76
29634: PUSH
29635: LD_INT 0
29637: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29638: LD_VAR 0 3
29642: PPUSH
29643: LD_INT 1
29645: PPUSH
29646: CALL_OW 51
// p := 0 ;
29650: LD_ADDR_VAR 0 2
29654: PUSH
29655: LD_INT 0
29657: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29658: LD_INT 35
29660: PPUSH
29661: CALL_OW 67
// p := p + 1 ;
29665: LD_ADDR_VAR 0 2
29669: PUSH
29670: LD_VAR 0 2
29674: PUSH
29675: LD_INT 1
29677: PLUS
29678: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29679: LD_VAR 0 3
29683: PPUSH
29684: CALL_OW 256
29688: PUSH
29689: LD_INT 1000
29691: LESS
29692: IFFALSE 29706
// SetLives ( un , 1000 ) ;
29694: LD_VAR 0 3
29698: PPUSH
29699: LD_INT 1000
29701: PPUSH
29702: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29706: LD_VAR 0 3
29710: PPUSH
29711: LD_INT 81
29713: PUSH
29714: LD_OWVAR 2
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 91
29725: PUSH
29726: LD_VAR 0 3
29730: PUSH
29731: LD_INT 30
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: LIST
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: CALL_OW 69
29747: PPUSH
29748: LD_VAR 0 3
29752: PPUSH
29753: CALL_OW 74
29757: PPUSH
29758: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29762: LD_VAR 0 2
29766: PUSH
29767: LD_INT 60
29769: GREATER
29770: PUSH
29771: LD_VAR 0 3
29775: PPUSH
29776: CALL_OW 301
29780: OR
29781: IFFALSE 29658
// if un then
29783: LD_VAR 0 3
29787: IFFALSE 29798
// RemoveUnit ( un ) ;
29789: LD_VAR 0 3
29793: PPUSH
29794: CALL_OW 64
// end ; end_of_file
29798: PPOPN 3
29800: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29801: LD_INT 0
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29807: LD_VAR 0 1
29811: PPUSH
29812: CALL_OW 264
29816: PUSH
29817: LD_EXP 58
29821: EQUAL
29822: IFFALSE 29894
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29824: LD_INT 68
29826: PPUSH
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL_OW 255
29836: PPUSH
29837: CALL_OW 321
29841: PUSH
29842: LD_INT 2
29844: EQUAL
29845: IFFALSE 29857
// eff := 70 else
29847: LD_ADDR_VAR 0 4
29851: PUSH
29852: LD_INT 70
29854: ST_TO_ADDR
29855: GO 29865
// eff := 30 ;
29857: LD_ADDR_VAR 0 4
29861: PUSH
29862: LD_INT 30
29864: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29865: LD_VAR 0 1
29869: PPUSH
29870: CALL_OW 250
29874: PPUSH
29875: LD_VAR 0 1
29879: PPUSH
29880: CALL_OW 251
29884: PPUSH
29885: LD_VAR 0 4
29889: PPUSH
29890: CALL_OW 495
// end ; end ;
29894: LD_VAR 0 2
29898: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29899: LD_INT 0
29901: PPUSH
// end ;
29902: LD_VAR 0 4
29906: RET
// export function SOS_Command ( cmd ) ; begin
29907: LD_INT 0
29909: PPUSH
// end ;
29910: LD_VAR 0 2
29914: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29915: LD_VAR 0 1
29919: PUSH
29920: LD_INT 255
29922: EQUAL
29923: PUSH
29924: LD_VAR 0 2
29928: PPUSH
29929: CALL_OW 264
29933: PUSH
29934: LD_INT 14
29936: PUSH
29937: LD_INT 53
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: IN
29944: AND
29945: PUSH
29946: LD_VAR 0 4
29950: PPUSH
29951: LD_VAR 0 5
29955: PPUSH
29956: CALL_OW 488
29960: AND
29961: IFFALSE 29985
// CutTreeXYR ( unit , x , y , 12 ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_VAR 0 4
29972: PPUSH
29973: LD_VAR 0 5
29977: PPUSH
29978: LD_INT 12
29980: PPUSH
29981: CALL 29988 0 4
// end ;
29985: PPOPN 5
29987: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29988: LD_INT 0
29990: PPUSH
29991: PPUSH
29992: PPUSH
29993: PPUSH
29994: PPUSH
29995: PPUSH
29996: PPUSH
29997: PPUSH
29998: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29999: LD_VAR 0 1
30003: NOT
30004: PUSH
30005: LD_VAR 0 2
30009: PPUSH
30010: LD_VAR 0 3
30014: PPUSH
30015: CALL_OW 488
30019: NOT
30020: OR
30021: PUSH
30022: LD_VAR 0 4
30026: NOT
30027: OR
30028: IFFALSE 30032
// exit ;
30030: GO 30372
// list := [ ] ;
30032: LD_ADDR_VAR 0 13
30036: PUSH
30037: EMPTY
30038: ST_TO_ADDR
// if x - r < 0 then
30039: LD_VAR 0 2
30043: PUSH
30044: LD_VAR 0 4
30048: MINUS
30049: PUSH
30050: LD_INT 0
30052: LESS
30053: IFFALSE 30065
// min_x := 0 else
30055: LD_ADDR_VAR 0 7
30059: PUSH
30060: LD_INT 0
30062: ST_TO_ADDR
30063: GO 30081
// min_x := x - r ;
30065: LD_ADDR_VAR 0 7
30069: PUSH
30070: LD_VAR 0 2
30074: PUSH
30075: LD_VAR 0 4
30079: MINUS
30080: ST_TO_ADDR
// if y - r < 0 then
30081: LD_VAR 0 3
30085: PUSH
30086: LD_VAR 0 4
30090: MINUS
30091: PUSH
30092: LD_INT 0
30094: LESS
30095: IFFALSE 30107
// min_y := 0 else
30097: LD_ADDR_VAR 0 8
30101: PUSH
30102: LD_INT 0
30104: ST_TO_ADDR
30105: GO 30123
// min_y := y - r ;
30107: LD_ADDR_VAR 0 8
30111: PUSH
30112: LD_VAR 0 3
30116: PUSH
30117: LD_VAR 0 4
30121: MINUS
30122: ST_TO_ADDR
// max_x := x + r ;
30123: LD_ADDR_VAR 0 9
30127: PUSH
30128: LD_VAR 0 2
30132: PUSH
30133: LD_VAR 0 4
30137: PLUS
30138: ST_TO_ADDR
// max_y := y + r ;
30139: LD_ADDR_VAR 0 10
30143: PUSH
30144: LD_VAR 0 3
30148: PUSH
30149: LD_VAR 0 4
30153: PLUS
30154: ST_TO_ADDR
// for _x = min_x to max_x do
30155: LD_ADDR_VAR 0 11
30159: PUSH
30160: DOUBLE
30161: LD_VAR 0 7
30165: DEC
30166: ST_TO_ADDR
30167: LD_VAR 0 9
30171: PUSH
30172: FOR_TO
30173: IFFALSE 30290
// for _y = min_y to max_y do
30175: LD_ADDR_VAR 0 12
30179: PUSH
30180: DOUBLE
30181: LD_VAR 0 8
30185: DEC
30186: ST_TO_ADDR
30187: LD_VAR 0 10
30191: PUSH
30192: FOR_TO
30193: IFFALSE 30286
// begin if not ValidHex ( _x , _y ) then
30195: LD_VAR 0 11
30199: PPUSH
30200: LD_VAR 0 12
30204: PPUSH
30205: CALL_OW 488
30209: NOT
30210: IFFALSE 30214
// continue ;
30212: GO 30192
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30214: LD_VAR 0 11
30218: PPUSH
30219: LD_VAR 0 12
30223: PPUSH
30224: CALL_OW 351
30228: PUSH
30229: LD_VAR 0 11
30233: PPUSH
30234: LD_VAR 0 12
30238: PPUSH
30239: CALL_OW 554
30243: AND
30244: IFFALSE 30284
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30246: LD_ADDR_VAR 0 13
30250: PUSH
30251: LD_VAR 0 13
30255: PPUSH
30256: LD_VAR 0 13
30260: PUSH
30261: LD_INT 1
30263: PLUS
30264: PPUSH
30265: LD_VAR 0 11
30269: PUSH
30270: LD_VAR 0 12
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PPUSH
30279: CALL_OW 2
30283: ST_TO_ADDR
// end ;
30284: GO 30192
30286: POP
30287: POP
30288: GO 30172
30290: POP
30291: POP
// if not list then
30292: LD_VAR 0 13
30296: NOT
30297: IFFALSE 30301
// exit ;
30299: GO 30372
// for i in list do
30301: LD_ADDR_VAR 0 6
30305: PUSH
30306: LD_VAR 0 13
30310: PUSH
30311: FOR_IN
30312: IFFALSE 30370
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30314: LD_VAR 0 1
30318: PPUSH
30319: LD_STRING M
30321: PUSH
30322: LD_VAR 0 6
30326: PUSH
30327: LD_INT 1
30329: ARRAY
30330: PUSH
30331: LD_VAR 0 6
30335: PUSH
30336: LD_INT 2
30338: ARRAY
30339: PUSH
30340: LD_INT 0
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: LD_INT 0
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: PUSH
30361: EMPTY
30362: LIST
30363: PPUSH
30364: CALL_OW 447
30368: GO 30311
30370: POP
30371: POP
// end ;
30372: LD_VAR 0 5
30376: RET
