// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareTrigger ;
   8: CALL 33 0 0
// PrepareVulcanoBase ;
  12: CALL 873 0 0
// PrepareRussian ;
  16: CALL 3449 0 0
// PrepareLegion ;
  20: CALL 6966 0 0
// Action ;
  24: CALL 10693 0 0
// InitArt ;
  28: CALL 194 0 0
// end ;
  32: END
// export base_captured , russian_prepared , ru_can_attack , ru_sib_bomb , chance_to_bomb , player_res_art , player_artifact_ready , art_icon , time_res_art , player_commander , time_to_reuse , mine_vulc , medal_enabled , dead_counter , kill_counter , veh_counter , tech_counter , sib_contamin_counter ; function PrepareTrigger ; begin
  33: LD_INT 0
  35: PPUSH
// base_captured := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// russian_prepared := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// ru_can_attack := false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// ru_sib_bomb := false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// chance_to_bomb := [ 5 , 15 , 30 ] [ Difficulty ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 5
  75: PUSH
  76: LD_INT 15
  78: PUSH
  79: LD_INT 30
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: ST_TO_ADDR
// player_res_art := false ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// player_artifact_ready := false ;
 101: LD_ADDR_EXP 7
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// art_icon := art_use_atom ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 7
 116: ST_TO_ADDR
// time_res_art := 600 ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 600
 124: ST_TO_ADDR
// time_to_reuse := 10 10$00 ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 21000
 132: ST_TO_ADDR
// mine_vulc := false ;
 133: LD_ADDR_EXP 12
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// medal_enabled := false ;
 141: LD_ADDR_EXP 13
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// dead_counter := 0 ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// kill_counter := 0 ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// veh_counter := 0 ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// tech_counter := 0 ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// sib_contamin_counter := 0 ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// end ;
 189: LD_VAR 0 1
 193: RET
// function InitArt ; begin
 194: LD_INT 0
 196: PPUSH
// SetArtifactRes ( your_side , true ) ;
 197: LD_OWVAR 2
 201: PPUSH
 202: LD_INT 1
 204: PPUSH
 205: CALL_OW 467
// end ; end_of_file
 209: LD_VAR 0 1
 213: RET
// export us_commander , us_force , us_skill , us_guy ; export function PrepareAmerican ; var i , filter , un , team ; begin
 214: LD_INT 0
 216: PPUSH
 217: PPUSH
 218: PPUSH
 219: PPUSH
 220: PPUSH
// us_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 7
 228: PUSH
 229: LD_INT 6
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: PUSH
 240: LD_OWVAR 67
 244: ARRAY
 245: ST_TO_ADDR
// us_force := [ ] ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// RemoveEnvironmentArea ( evn ) ;
 253: LD_INT 17
 255: PPUSH
 256: CALL_OW 355
// PrepareAllianceAI ( ) ;
 260: CALL 15356 0 0
// uc_side := 1 ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// uc_nation := nation_american ;
 272: LD_ADDR_OWVAR 21
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// hc_gallery :=  ;
 280: LD_ADDR_OWVAR 33
 284: PUSH
 285: LD_STRING 
 287: ST_TO_ADDR
// hc_name :=  ;
 288: LD_ADDR_OWVAR 26
 292: PUSH
 293: LD_STRING 
 295: ST_TO_ADDR
// hc_importance := 0 ;
 296: LD_ADDR_OWVAR 32
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// for i = 1 to 11 do
 304: LD_ADDR_VAR 0 2
 308: PUSH
 309: DOUBLE
 310: LD_INT 1
 312: DEC
 313: ST_TO_ADDR
 314: LD_INT 11
 316: PUSH
 317: FOR_TO
 318: IFFALSE 371
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
 320: LD_INT 0
 322: PPUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 4
 328: PPUSH
 329: CALL_OW 12
 333: PPUSH
 334: LD_EXP 21
 338: PPUSH
 339: CALL_OW 380
// un := CreateHuman ;
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: CALL_OW 44
 352: ST_TO_ADDR
// us_force := us_force ^ un ;
 353: LD_ADDR_EXP 20
 357: PUSH
 358: LD_EXP 20
 362: PUSH
 363: LD_VAR 0 4
 367: ADD
 368: ST_TO_ADDR
// end ;
 369: GO 317
 371: POP
 372: POP
// hc_importance := 100 ;
 373: LD_ADDR_OWVAR 32
 377: PUSH
 378: LD_INT 100
 380: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: LD_EXP 21
 391: PPUSH
 392: CALL_OW 380
// us_commander := CreateHuman ;
 396: LD_ADDR_EXP 19
 400: PUSH
 401: CALL_OW 44
 405: ST_TO_ADDR
// player_commander := us_commander ;
 406: LD_ADDR_EXP 10
 410: PUSH
 411: LD_EXP 19
 415: ST_TO_ADDR
// team := CharacterSelection ( text , [ 6 , 5 , 4 ] [ Difficulty ] , [ 6 , 5 , 4 ] [ Difficulty ] , [ sel_change_class , us_commander , sel_changeable , sel_not_hired ] ^ us_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ 5 , 5 , - 1 ] [ Difficulty ] ] ) ;
 416: LD_ADDR_VAR 0 5
 420: PUSH
 421: LD_STRING text
 423: PPUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 5
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_OWVAR 67
 442: ARRAY
 443: PPUSH
 444: LD_INT 6
 446: PUSH
 447: LD_INT 5
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_OWVAR 67
 462: ARRAY
 463: PPUSH
 464: LD_INT -5
 466: PUSH
 467: LD_EXP 19
 471: PUSH
 472: LD_INT -3
 474: PUSH
 475: LD_INT -2
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: LIST
 483: PUSH
 484: LD_EXP 20
 488: ADD
 489: PPUSH
 490: LD_INT 1
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 2
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 4
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PUSH
 516: LD_INT 5
 518: PUSH
 519: LD_INT 5
 521: PUSH
 522: LD_INT 1
 524: NEG
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_OWVAR 67
 535: ARRAY
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL_OW 42
 548: ST_TO_ADDR
// team := team ^ us_commander ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: LD_EXP 19
 563: ADD
 564: ST_TO_ADDR
// for i = 1 to team do
 565: LD_ADDR_VAR 0 2
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 5
 579: PUSH
 580: FOR_TO
 581: IFFALSE 606
// PlaceUnitArea ( team [ i ] , start_north , false ) ;
 583: LD_VAR 0 5
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PPUSH
 594: LD_INT 1
 596: PPUSH
 597: LD_INT 0
 599: PPUSH
 600: CALL_OW 49
 604: GO 580
 606: POP
 607: POP
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$38 + 2 2$00 trigger tick < 73500 do
 613: LD_OWVAR 1
 617: PUSH
 618: LD_INT 73500
 620: LESS
 621: IFFALSE 648
 623: GO 625
 625: DISABLE
// begin enable ;
 626: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , extra_crates , true ) ;
 627: LD_INT 1
 629: PPUSH
 630: LD_INT 5
 632: PPUSH
 633: CALL_OW 12
 637: PPUSH
 638: LD_INT 24
 640: PPUSH
 641: LD_INT 1
 643: PPUSH
 644: CALL_OW 55
// end ;
 648: END
// every 1 1$10 do var time , p , l ;
 649: GO 651
 651: DISABLE
 652: LD_INT 0
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin time := 0 0$44 ;
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 1540
 664: ST_TO_ADDR
// l := 0 ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: LD_INT 0
 672: ST_TO_ADDR
// repeat begin Wait ( time ) ;
 673: LD_VAR 0 1
 677: PPUSH
 678: CALL_OW 67
// l := l + 1 ;
 682: LD_ADDR_VAR 0 3
 686: PUSH
 687: LD_VAR 0 3
 691: PUSH
 692: LD_INT 1
 694: PLUS
 695: ST_TO_ADDR
// if GetListOfCratesInArea ( us_crates ) < 30 then
 696: LD_INT 12
 698: PPUSH
 699: CALL_OW 435
 703: PUSH
 704: LD_INT 30
 706: LESS
 707: IFFALSE 766
// begin CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 709: LD_INT 1
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL_OW 12
 719: PPUSH
 720: LD_INT 12
 722: PPUSH
 723: LD_INT 1
 725: PPUSH
 726: CALL_OW 55
// Wait ( Rand ( 0 0$33 , 0 0$44 ) ) ;
 730: LD_INT 1155
 732: PPUSH
 733: LD_INT 1540
 735: PPUSH
 736: CALL_OW 12
 740: PPUSH
 741: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , us_crates , true ) ;
 745: LD_INT 1
 747: PPUSH
 748: LD_INT 5
 750: PPUSH
 751: CALL_OW 12
 755: PPUSH
 756: LD_INT 12
 758: PPUSH
 759: LD_INT 1
 761: PPUSH
 762: CALL_OW 55
// end ; p := Rand ( 0 , 1 ) ;
 766: LD_ADDR_VAR 0 2
 770: PUSH
 771: LD_INT 0
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 12
 781: ST_TO_ADDR
// if p then
 782: LD_VAR 0 2
 786: IFFALSE 821
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
 788: LD_INT 105
 790: PPUSH
 791: LD_INT 350
 793: PPUSH
 794: CALL_OW 12
 798: PPUSH
 799: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 4 ) , true ) ;
 803: LD_INT 1
 805: PPUSH
 806: LD_INT 4
 808: PPUSH
 809: CALL_OW 12
 813: PPUSH
 814: LD_INT 1
 816: PPUSH
 817: CALL_OW 57
// end ; if l mod [ 15 , 13 , 11 ] [ Difficulty ] = 0 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 15
 828: PUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 11
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: PUSH
 840: LD_OWVAR 67
 844: ARRAY
 845: MOD
 846: PUSH
 847: LD_INT 0
 849: EQUAL
 850: IFFALSE 866
// time := time + 2 2$00 ;
 852: LD_ADDR_VAR 0 1
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 4200
 864: PLUS
 865: ST_TO_ADDR
// end until false ;
 866: LD_INT 0
 868: IFFALSE 673
// end ; end_of_file
 870: PPOPN 3
 872: END
// export function PrepareVulcanoBase ; var i , filter , hp , un , area , p , russian_in_base ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
 882: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_INT 22
 890: PUSH
 891: LD_INT 4
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 69
 916: ST_TO_ADDR
// hp := [ 470 , 370 , 290 ] [ Difficulty ] ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_INT 470
 924: PUSH
 925: LD_INT 370
 927: PUSH
 928: LD_INT 290
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_OWVAR 67
 940: ARRAY
 941: ST_TO_ADDR
// case Difficulty of 2 :
 942: LD_OWVAR 67
 946: PUSH
 947: LD_INT 2
 949: DOUBLE
 950: EQUAL
 951: IFTRUE 955
 953: GO 986
 955: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 956: LD_VAR 0 3
 960: PPUSH
 961: LD_INT 30
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PPUSH
 971: CALL_OW 72
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 65
// end ; 3 :
 984: GO 1062
 986: LD_INT 3
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1061
 994: POP
// begin DestroyUnit ( UnitFilter ( filter , [ f_btype , b_bunker ] ) [ 1 ] ) ;
 995: LD_VAR 0 3
 999: PPUSH
1000: LD_INT 30
1002: PUSH
1003: LD_INT 32
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 72
1014: PUSH
1015: LD_INT 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 65
// DestroyUnit ( UnitFilter ( filter , [ f_btype , b_solar_power ] ) [ Rand ( 1 , 3 ) ] ) ;
1023: LD_VAR 0 3
1027: PPUSH
1028: LD_INT 30
1030: PUSH
1031: LD_INT 27
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: PPUSH
1038: CALL_OW 72
1042: PUSH
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: CALL_OW 12
1053: ARRAY
1054: PPUSH
1055: CALL_OW 65
// end ; end ;
1059: GO 1062
1061: POP
// for i = 1 to filter do
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: DOUBLE
1068: LD_INT 1
1070: DEC
1071: ST_TO_ADDR
1072: LD_VAR 0 3
1076: PUSH
1077: FOR_TO
1078: IFFALSE 1115
// SetLives ( filter [ i ] , hp + Rand ( - 29 , 29 ) ) ;
1080: LD_VAR 0 3
1084: PUSH
1085: LD_VAR 0 2
1089: ARRAY
1090: PPUSH
1091: LD_VAR 0 4
1095: PUSH
1096: LD_INT 29
1098: NEG
1099: PPUSH
1100: LD_INT 29
1102: PPUSH
1103: CALL_OW 12
1107: PLUS
1108: PPUSH
1109: CALL_OW 234
1113: GO 1077
1115: POP
1116: POP
// SetBName ( us_depot , Vulcano1 ) ;
1117: LD_INT 50
1119: PPUSH
1120: LD_STRING Vulcano1
1122: PPUSH
1123: CALL_OW 500
// hc_importance := 0 ;
1127: LD_ADDR_OWVAR 32
1131: PUSH
1132: LD_INT 0
1134: ST_TO_ADDR
// uc_side := 3 ;
1135: LD_ADDR_OWVAR 20
1139: PUSH
1140: LD_INT 3
1142: ST_TO_ADDR
// uc_nation := nation_russian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 3
1150: ST_TO_ADDR
// russian_in_base := [ ] ;
1151: LD_ADDR_VAR 0 8
1155: PUSH
1156: EMPTY
1157: ST_TO_ADDR
// area := RandPointsFromArea ( 82 , 137 , 106 , 152 , 10 ) ;
1158: LD_ADDR_VAR 0 6
1162: PUSH
1163: LD_INT 82
1165: PPUSH
1166: LD_INT 137
1168: PPUSH
1169: LD_INT 106
1171: PPUSH
1172: LD_INT 152
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL 1555 0 5
1182: ST_TO_ADDR
// p := 1 ;
1183: LD_ADDR_VAR 0 7
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: DOUBLE
1197: LD_INT 1
1199: DEC
1200: ST_TO_ADDR
1201: LD_INT 6
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_OWVAR 67
1219: ARRAY
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1334
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
1224: LD_INT 0
1226: PPUSH
1227: LD_INT 1
1229: PPUSH
1230: LD_INT 4
1232: PUSH
1233: LD_INT 5
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_OWVAR 67
1248: ARRAY
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// russian_in_base := russian_in_base ^ un ;
1264: LD_ADDR_VAR 0 8
1268: PUSH
1269: LD_VAR 0 8
1273: PUSH
1274: LD_VAR 0 5
1278: ADD
1279: ST_TO_ADDR
// PlaceUnitXY ( un , area [ p ] , area [ p + 1 ] , false ) ;
1280: LD_VAR 0 5
1284: PPUSH
1285: LD_VAR 0 6
1289: PUSH
1290: LD_VAR 0 7
1294: ARRAY
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_VAR 0 7
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: ARRAY
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL_OW 48
// p := p + 2 ;
1318: LD_ADDR_VAR 0 7
1322: PUSH
1323: LD_VAR 0 7
1327: PUSH
1328: LD_INT 2
1330: PLUS
1331: ST_TO_ADDR
// end ;
1332: GO 1221
1334: POP
1335: POP
// end ;
1336: LD_VAR 0 1
1340: RET
// every 0 0$01 trigger GetDistUnitToSide ( us_depot , 1 ) < 40 do var i , un ;
1341: LD_INT 50
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: CALL 2045 0 2
1351: PUSH
1352: LD_INT 40
1354: LESS
1355: IFFALSE 1552
1357: GO 1359
1359: DISABLE
1360: LD_INT 0
1362: PPUSH
1363: PPUSH
// begin uc_side := 4 ;
1364: LD_ADDR_OWVAR 20
1368: PUSH
1369: LD_INT 4
1371: ST_TO_ADDR
// uc_nation := nation_american ;
1372: LD_ADDR_OWVAR 21
1376: PUSH
1377: LD_INT 1
1379: ST_TO_ADDR
// hc_importance := 0 ;
1380: LD_ADDR_OWVAR 32
1384: PUSH
1385: LD_INT 0
1387: ST_TO_ADDR
// for i = 1 to 7 do
1388: LD_ADDR_VAR 0 1
1392: PUSH
1393: DOUBLE
1394: LD_INT 1
1396: DEC
1397: ST_TO_ADDR
1398: LD_INT 7
1400: PUSH
1401: FOR_TO
1402: IFFALSE 1466
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , us_skill ) ;
1404: LD_INT 0
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: CALL_OW 12
1417: PPUSH
1418: LD_EXP 21
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// PlaceUnitArea ( un , base_resp , false ) ;
1437: LD_VAR 0 2
1441: PPUSH
1442: LD_INT 7
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// SetLives ( un , 10 ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_INT 10
1459: PPUSH
1460: CALL_OW 234
// end ;
1464: GO 1401
1466: POP
1467: POP
// for i = 1 to 5 do
1468: LD_ADDR_VAR 0 1
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 5
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1550
// begin PrepareHuman ( false , 4 , us_skill ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_INT 4
1489: PPUSH
1490: LD_EXP 21
1494: PPUSH
1495: CALL_OW 380
// SetDir ( un , 1 ) ;
1499: LD_VAR 0 2
1503: PPUSH
1504: LD_INT 1
1506: PPUSH
1507: CALL_OW 233
// un := CreateHuman ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: CALL_OW 44
1520: ST_TO_ADDR
// PlaceUnitArea ( un , rekt , false ) ;
1521: LD_VAR 0 2
1525: PPUSH
1526: LD_INT 23
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// SetLives ( un , 10 ) ;
1536: LD_VAR 0 2
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: CALL_OW 234
// end ;
1548: GO 1481
1550: POP
1551: POP
// end ; end_of_file
1552: PPOPN 2
1554: END
// export function RandPointsFromArea ( x1 , y1 , x2 , y2 , num ) ; var list , i ; begin
1555: LD_INT 0
1557: PPUSH
1558: PPUSH
1559: PPUSH
// list := [ ] ;
1560: LD_ADDR_VAR 0 7
1564: PUSH
1565: EMPTY
1566: ST_TO_ADDR
// for i = 1 to num do
1567: LD_ADDR_VAR 0 8
1571: PUSH
1572: DOUBLE
1573: LD_INT 1
1575: DEC
1576: ST_TO_ADDR
1577: LD_VAR 0 5
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1639
// begin list := list ^ Rand ( x1 , x2 ) ;
1585: LD_ADDR_VAR 0 7
1589: PUSH
1590: LD_VAR 0 7
1594: PUSH
1595: LD_VAR 0 1
1599: PPUSH
1600: LD_VAR 0 3
1604: PPUSH
1605: CALL_OW 12
1609: ADD
1610: ST_TO_ADDR
// list := list ^ Rand ( y1 , y2 ) ;
1611: LD_ADDR_VAR 0 7
1615: PUSH
1616: LD_VAR 0 7
1620: PUSH
1621: LD_VAR 0 2
1625: PPUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: CALL_OW 12
1635: ADD
1636: ST_TO_ADDR
// end ;
1637: GO 1582
1639: POP
1640: POP
// result := list ;
1641: LD_ADDR_VAR 0 6
1645: PUSH
1646: LD_VAR 0 7
1650: ST_TO_ADDR
// end ;
1651: LD_VAR 0 6
1655: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
1656: LD_INT 0
1658: PPUSH
1659: PPUSH
1660: PPUSH
1661: PPUSH
// c := Rand ( 1 , 3 ) ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_INT 1
1669: PPUSH
1670: LD_INT 3
1672: PPUSH
1673: CALL_OW 12
1677: ST_TO_ADDR
// for i = 1 to list do
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: DOUBLE
1684: LD_INT 1
1686: DEC
1687: ST_TO_ADDR
1688: LD_VAR 0 1
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1876
// for ta in filter do
1696: LD_ADDR_VAR 0 4
1700: PUSH
1701: LD_VAR 0 2
1705: PUSH
1706: FOR_IN
1707: IFFALSE 1872
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
1709: LD_VAR 0 1
1713: PUSH
1714: LD_VAR 0 6
1718: ARRAY
1719: PPUSH
1720: LD_VAR 0 4
1724: PPUSH
1725: CALL_OW 296
1729: PUSH
1730: LD_INT 15
1732: LESSEQUAL
1733: IFFALSE 1870
// begin case c of 1 :
1735: LD_VAR 0 5
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1786
1748: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
1749: LD_VAR 0 1
1753: PUSH
1754: LD_VAR 0 6
1758: ARRAY
1759: PPUSH
1760: LD_VAR 0 4
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 154
1784: GO 1870
1786: LD_INT 2
1788: DOUBLE
1789: EQUAL
1790: IFTRUE 1794
1792: GO 1858
1794: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
1795: LD_VAR 0 1
1799: PUSH
1800: LD_VAR 0 6
1804: ARRAY
1805: PPUSH
1806: LD_VAR 0 4
1810: PPUSH
1811: CALL_OW 250
1815: PUSH
1816: LD_INT 1
1818: NEG
1819: PPUSH
1820: LD_INT 1
1822: PPUSH
1823: CALL_OW 12
1827: PLUS
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: CALL_OW 251
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: CALL_OW 12
1850: PLUS
1851: PPUSH
1852: CALL_OW 153
1856: GO 1870
1858: LD_INT 3
1860: DOUBLE
1861: EQUAL
1862: IFTRUE 1866
1864: GO 1869
1866: POP
// ; end ;
1867: GO 1870
1869: POP
// end ; end ;
1870: GO 1706
1872: POP
1873: POP
1874: GO 1693
1876: POP
1877: POP
// end ;
1878: LD_VAR 0 3
1882: RET
// export function PrepareApeman ( n ) ; var un , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
// for i = 1 to n do
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: DOUBLE
1894: LD_INT 1
1896: DEC
1897: ST_TO_ADDR
1898: LD_VAR 0 1
1902: PUSH
1903: FOR_TO
1904: IFFALSE 2038
// begin uc_side := 0 ;
1906: LD_ADDR_OWVAR 20
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// uc_nation := 0 ;
1914: LD_ADDR_OWVAR 21
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// hc_class := class_apeman ;
1922: LD_ADDR_OWVAR 28
1926: PUSH
1927: LD_INT 12
1929: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1930: LD_ADDR_OWVAR 31
1934: PUSH
1935: LD_INT 0
1937: PUSH
1938: LD_INT 0
1940: PUSH
1941: LD_INT 0
1943: PUSH
1944: LD_INT 0
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: ST_TO_ADDR
// hc_name :=  ;
1953: LD_ADDR_OWVAR 26
1957: PUSH
1958: LD_STRING 
1960: ST_TO_ADDR
// hc_gallery :=  ;
1961: LD_ADDR_OWVAR 33
1965: PUSH
1966: LD_STRING 
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// un := CreateHuman ;
1977: LD_ADDR_VAR 0 3
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , [ ape1 , ape2 ] [ Rand ( 1 , 2 ) ] , false ) ;
1987: LD_VAR 0 3
1991: PPUSH
1992: LD_INT 19
1994: PUSH
1995: LD_INT 20
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PPUSH
2014: LD_INT 0
2016: PPUSH
2017: CALL_OW 49
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2021: LD_INT 1155
2023: PPUSH
2024: LD_INT 5355
2026: PPUSH
2027: CALL_OW 12
2031: PPUSH
2032: CALL_OW 67
// end ;
2036: GO 1903
2038: POP
2039: POP
// end ;
2040: LD_VAR 0 2
2044: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
2050: LD_ADDR_VAR 0 4
2054: PUSH
2055: LD_INT 22
2057: PUSH
2058: LD_VAR 0 2
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 74
2081: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
2082: LD_ADDR_VAR 0 5
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_VAR 0 4
2096: PPUSH
2097: CALL_OW 296
2101: ST_TO_ADDR
// if dist >= 9999 then
2102: LD_VAR 0 5
2106: PUSH
2107: LD_INT 9999
2109: GREATEREQUAL
2110: IFFALSE 2123
// result := - 1 else
2112: LD_ADDR_VAR 0 3
2116: PUSH
2117: LD_INT 1
2119: NEG
2120: ST_TO_ADDR
2121: GO 2133
// result := dist ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 5
2132: ST_TO_ADDR
// end ;
2133: LD_VAR 0 3
2137: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
2138: LD_INT 0
2140: PPUSH
2141: PPUSH
2142: PPUSH
2143: PPUSH
// tmp := 9999 ;
2144: LD_ADDR_VAR 0 5
2148: PUSH
2149: LD_INT 9999
2151: ST_TO_ADDR
// for i = 1 to plist do
2152: LD_ADDR_VAR 0 4
2156: PUSH
2157: DOUBLE
2158: LD_INT 1
2160: DEC
2161: ST_TO_ADDR
2162: LD_VAR 0 1
2166: PUSH
2167: FOR_TO
2168: IFFALSE 2242
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
2170: LD_VAR 0 1
2174: PUSH
2175: LD_VAR 0 4
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 2
2185: PPUSH
2186: CALL 2045 0 2
2190: PUSH
2191: LD_VAR 0 5
2195: LESS
2196: IFFALSE 2240
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 1
2207: PUSH
2208: LD_VAR 0 4
2212: ARRAY
2213: PPUSH
2214: LD_VAR 0 2
2218: PPUSH
2219: CALL 2045 0 2
2223: ST_TO_ADDR
// unit := plist [ i ] ;
2224: LD_ADDR_VAR 0 6
2228: PUSH
2229: LD_VAR 0 1
2233: PUSH
2234: LD_VAR 0 4
2238: ARRAY
2239: ST_TO_ADDR
// end ;
2240: GO 2167
2242: POP
2243: POP
// result := unit ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: LD_VAR 0 6
2253: ST_TO_ADDR
// end ;
2254: LD_VAR 0 3
2258: RET
// export function CalculateCommanderPoints ; var points , crates_collected , sib_collected , i ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
// points := [ 1000 , 2500 , 5000 ] [ Difficulty ] ;
2266: LD_ADDR_VAR 0 2
2270: PUSH
2271: LD_INT 1000
2273: PUSH
2274: LD_INT 2500
2276: PUSH
2277: LD_INT 5000
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: LD_OWVAR 67
2289: ARRAY
2290: ST_TO_ADDR
// points := points + ( - 1 * FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) * 30 ) ;
2291: LD_ADDR_VAR 0 2
2295: PUSH
2296: LD_VAR 0 2
2300: PUSH
2301: LD_INT 1
2303: NEG
2304: PUSH
2305: LD_INT 22
2307: PUSH
2308: LD_OWVAR 2
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: MUL
2336: PUSH
2337: LD_INT 30
2339: MUL
2340: PLUS
2341: ST_TO_ADDR
// points := points + ( kill_counter * 10 ) ;
2342: LD_ADDR_VAR 0 2
2346: PUSH
2347: LD_VAR 0 2
2351: PUSH
2352: LD_EXP 15
2356: PUSH
2357: LD_INT 10
2359: MUL
2360: PLUS
2361: ST_TO_ADDR
// points := points + ( - 1 * kill_counter * 20 ) ;
2362: LD_ADDR_VAR 0 2
2366: PUSH
2367: LD_VAR 0 2
2371: PUSH
2372: LD_INT 1
2374: NEG
2375: PUSH
2376: LD_EXP 15
2380: MUL
2381: PUSH
2382: LD_INT 20
2384: MUL
2385: PLUS
2386: ST_TO_ADDR
// points := points + ( - 1 * ( ( tick / 35 ) / 60 ) * 25 ) ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_INT 1
2399: NEG
2400: PUSH
2401: LD_OWVAR 1
2405: PUSH
2406: LD_INT 35
2408: DIVREAL
2409: PUSH
2410: LD_INT 60
2412: DIVREAL
2413: MUL
2414: PUSH
2415: LD_INT 25
2417: MUL
2418: PLUS
2419: ST_TO_ADDR
// points := points + ( tech_counter * 15 ) ;
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: LD_VAR 0 2
2429: PUSH
2430: LD_EXP 17
2434: PUSH
2435: LD_INT 15
2437: MUL
2438: PLUS
2439: ST_TO_ADDR
// points := points + ( - 1 * sib_contamin_counter ) * 1000 ;
2440: LD_ADDR_VAR 0 2
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: NEG
2453: PUSH
2454: LD_EXP 18
2458: MUL
2459: PUSH
2460: LD_INT 1000
2462: MUL
2463: PLUS
2464: ST_TO_ADDR
// points := points + ( veh_counter * 5 ) ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 16
2479: PUSH
2480: LD_INT 5
2482: MUL
2483: PLUS
2484: ST_TO_ADDR
// result := points ;
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_VAR 0 2
2494: ST_TO_ADDR
// end ; end_of_file
2495: LD_VAR 0 1
2499: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = your_side then
2500: LD_VAR 0 1
2504: PPUSH
2505: CALL_OW 255
2509: PUSH
2510: LD_OWVAR 2
2514: EQUAL
2515: IFFALSE 2531
// dead_counter := dead_counter + 1 ;
2517: LD_ADDR_EXP 14
2521: PUSH
2522: LD_EXP 14
2526: PUSH
2527: LD_INT 1
2529: PLUS
2530: ST_TO_ADDR
// if GetSide ( un ) in FilterAllUnits ( [ f_enemy , your_side ] ) then
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 255
2540: PUSH
2541: LD_INT 81
2543: PUSH
2544: LD_OWVAR 2
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: IN
2558: IFFALSE 2574
// kill_counter := kill_counter + 1 ;
2560: LD_ADDR_EXP 15
2564: PUSH
2565: LD_EXP 15
2569: PUSH
2570: LD_INT 1
2572: PLUS
2573: ST_TO_ADDR
// if un = player_commander then
2574: LD_VAR 0 1
2578: PUSH
2579: LD_EXP 10
2583: EQUAL
2584: IFFALSE 2593
// YouLost ( vulcano-lost ) ;
2586: LD_STRING vulcano-lost
2588: PPUSH
2589: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
2593: LD_VAR 0 1
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_INT 3
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: PUSH
2608: LD_INT 21
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PPUSH
2622: CALL_OW 69
2626: IN
2627: IFFALSE 2743
// begin if GetBType ( un ) = b_turret or GetBType ( un ) = b_siberite_power then
2629: LD_VAR 0 1
2633: PPUSH
2634: CALL_OW 266
2638: PUSH
2639: LD_INT 33
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 266
2652: PUSH
2653: LD_INT 28
2655: EQUAL
2656: OR
2657: IFFALSE 2743
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
2659: LD_ADDR_EXP 26
2663: PUSH
2664: LD_EXP 26
2668: PUSH
2669: LD_VAR 0 1
2673: PPUSH
2674: CALL_OW 266
2678: ADD
2679: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
2680: LD_ADDR_EXP 26
2684: PUSH
2685: LD_EXP 26
2689: PUSH
2690: LD_VAR 0 1
2694: PPUSH
2695: CALL_OW 250
2699: ADD
2700: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
2701: LD_ADDR_EXP 26
2705: PUSH
2706: LD_EXP 26
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 251
2720: ADD
2721: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
2722: LD_ADDR_EXP 26
2726: PUSH
2727: LD_EXP 26
2731: PUSH
2732: LD_VAR 0 1
2736: PPUSH
2737: CALL_OW 254
2741: ADD
2742: ST_TO_ADDR
// end ; end ; if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) then
2743: LD_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 8
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: IN
2777: IFFALSE 2921
// begin if GetBType ( un ) = b_barracks then
2779: LD_VAR 0 1
2783: PPUSH
2784: CALL_OW 266
2788: PUSH
2789: LD_INT 5
2791: EQUAL
2792: IFFALSE 2810
// legion_blist := legion_blist ^ b_armoury else
2794: LD_ADDR_EXP 34
2798: PUSH
2799: LD_EXP 34
2803: PUSH
2804: LD_INT 4
2806: ADD
2807: ST_TO_ADDR
2808: GO 2858
// if not GetBType ( un ) in [ b_warehouse , b_lab , b_lab_full ] then
2810: LD_VAR 0 1
2814: PPUSH
2815: CALL_OW 266
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 6
2825: PUSH
2826: LD_INT 8
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: IN
2834: NOT
2835: IFFALSE 2858
// legion_blist := legion_blist ^ GetBType ( un ) ;
2837: LD_ADDR_EXP 34
2841: PUSH
2842: LD_EXP 34
2846: PUSH
2847: LD_VAR 0 1
2851: PPUSH
2852: CALL_OW 266
2856: ADD
2857: ST_TO_ADDR
// legion_blist := legion_blist ^ GetX ( un ) ;
2858: LD_ADDR_EXP 34
2862: PUSH
2863: LD_EXP 34
2867: PUSH
2868: LD_VAR 0 1
2872: PPUSH
2873: CALL_OW 250
2877: ADD
2878: ST_TO_ADDR
// legion_blist := legion_blist ^ GetY ( un ) ;
2879: LD_ADDR_EXP 34
2883: PUSH
2884: LD_EXP 34
2888: PUSH
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 251
2898: ADD
2899: ST_TO_ADDR
// legion_blist := legion_blist ^ GetDir ( un ) ;
2900: LD_ADDR_EXP 34
2904: PUSH
2905: LD_EXP 34
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: CALL_OW 254
2919: ADD
2920: ST_TO_ADDR
// end ; if un in legion_force then
2921: LD_VAR 0 1
2925: PUSH
2926: LD_EXP 31
2930: IN
2931: IFFALSE 2949
// legion_force := legion_force diff un ;
2933: LD_ADDR_EXP 31
2937: PUSH
2938: LD_EXP 31
2942: PUSH
2943: LD_VAR 0 1
2947: DIFF
2948: ST_TO_ADDR
// if un in ru_force then
2949: LD_VAR 0 1
2953: PUSH
2954: LD_EXP 23
2958: IN
2959: IFFALSE 2977
// ru_force := ru_force diff un ;
2961: LD_ADDR_EXP 23
2965: PUSH
2966: LD_EXP 23
2970: PUSH
2971: LD_VAR 0 1
2975: DIFF
2976: ST_TO_ADDR
// if un in al_force then
2977: LD_VAR 0 1
2981: PUSH
2982: LD_EXP 38
2986: IN
2987: IFFALSE 3005
// al_force := al_force diff un ;
2989: LD_ADDR_EXP 38
2993: PUSH
2994: LD_EXP 38
2998: PUSH
2999: LD_VAR 0 1
3003: DIFF
3004: ST_TO_ADDR
// end ;
3005: PPOPN 1
3007: END
// on BuildingComplete ( b ) do var i ;
3008: LD_INT 0
3010: PPUSH
// begin if GetSide ( b ) = 8 then
3011: LD_VAR 0 1
3015: PPUSH
3016: CALL_OW 255
3020: PUSH
3021: LD_INT 8
3023: EQUAL
3024: IFFALSE 3064
// for i = 1 to 4 do
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: DOUBLE
3032: LD_INT 1
3034: DEC
3035: ST_TO_ADDR
3036: LD_INT 4
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3062
// legion_blist := Delete ( legion_blist , 1 ) ;
3042: LD_ADDR_EXP 34
3046: PUSH
3047: LD_EXP 34
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: CALL_OW 3
3059: ST_TO_ADDR
3060: GO 3039
3062: POP
3063: POP
// if GetSide ( b ) = 3 then
3064: LD_VAR 0 1
3068: PPUSH
3069: CALL_OW 255
3073: PUSH
3074: LD_INT 3
3076: EQUAL
3077: IFFALSE 3117
// for i = 1 to 4 do
3079: LD_ADDR_VAR 0 2
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_INT 4
3091: PUSH
3092: FOR_TO
3093: IFFALSE 3115
// ru_blist := Delete ( ru_blist , 1 ) ;
3095: LD_ADDR_EXP 26
3099: PUSH
3100: LD_EXP 26
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: CALL_OW 3
3112: ST_TO_ADDR
3113: GO 3092
3115: POP
3116: POP
// end ;
3117: PPOPN 2
3119: END
// on VehicleConstructed ( veh , fac ) do begin if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_siberium_rocket ] then
3120: LD_VAR 0 1
3124: PPUSH
3125: CALL_OW 264
3129: PUSH
3130: LD_INT 51
3132: PUSH
3133: LD_INT 48
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: IN
3140: NOT
3141: IFFALSE 3189
// begin if GetSide ( veh ) = 3 then
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 255
3152: PUSH
3153: LD_INT 3
3155: EQUAL
3156: IFFALSE 3189
// begin ComMoveXY ( veh , 149 , 8 ) ;
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 149
3165: PPUSH
3166: LD_INT 8
3168: PPUSH
3169: CALL_OW 111
// ru_force := ru_force ^ veh ;
3173: LD_ADDR_EXP 23
3177: PUSH
3178: LD_EXP 23
3182: PUSH
3183: LD_VAR 0 1
3187: ADD
3188: ST_TO_ADDR
// end ; end ; if not GetWeapon ( veh ) in [ ar_cargo_bay , ar_control_tower ] then
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 264
3198: PUSH
3199: LD_INT 32
3201: PUSH
3202: LD_INT 31
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: IN
3209: NOT
3210: IFFALSE 3243
// begin if GetSide ( veh ) = 8 then
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 255
3221: PUSH
3222: LD_INT 8
3224: EQUAL
3225: IFFALSE 3243
// legion_force := legion_force ^ veh ;
3227: LD_ADDR_EXP 31
3231: PUSH
3232: LD_EXP 31
3236: PUSH
3237: LD_VAR 0 1
3241: ADD
3242: ST_TO_ADDR
// end ; if GetSide ( veh ) = 7 and your_side <> 7 then
3243: LD_VAR 0 1
3247: PPUSH
3248: CALL_OW 255
3252: PUSH
3253: LD_INT 7
3255: EQUAL
3256: PUSH
3257: LD_OWVAR 2
3261: PUSH
3262: LD_INT 7
3264: NONEQUAL
3265: AND
3266: IFFALSE 3284
// al_force := al_force ^ veh ;
3268: LD_ADDR_EXP 38
3272: PUSH
3273: LD_EXP 38
3277: PUSH
3278: LD_VAR 0 1
3282: ADD
3283: ST_TO_ADDR
// if GetSide ( veh ) = your_side then
3284: LD_VAR 0 1
3288: PPUSH
3289: CALL_OW 255
3293: PUSH
3294: LD_OWVAR 2
3298: EQUAL
3299: IFFALSE 3315
// veh_counter := veh_counter + 1 ;
3301: LD_ADDR_EXP 16
3305: PUSH
3306: LD_EXP 16
3310: PUSH
3311: LD_INT 1
3313: PLUS
3314: ST_TO_ADDR
// end ;
3315: PPOPN 2
3317: END
// on SibDepositContaminated ( contaminating_scientist , x_of_deposit , y_of_deposit ) do begin if GetSide ( contaminating_scientist ) <> your_side then
3318: LD_VAR 0 1
3322: PPUSH
3323: CALL_OW 255
3327: PUSH
3328: LD_OWVAR 2
3332: NONEQUAL
3333: IFFALSE 3349
// sib_contamin_counter := sib_contamin_counter + 1 ;
3335: LD_ADDR_EXP 18
3339: PUSH
3340: LD_EXP 18
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: ST_TO_ADDR
// end ;
3349: PPOPN 3
3351: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = your_side then
3352: LD_VAR 0 2
3356: PPUSH
3357: CALL_OW 255
3361: PUSH
3362: LD_OWVAR 2
3366: EQUAL
3367: IFFALSE 3383
// tech_counter := tech_counter + 1 ;
3369: LD_ADDR_EXP 17
3373: PUSH
3374: LD_EXP 17
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: ST_TO_ADDR
// end ;
3383: PPOPN 2
3385: END
// every 9 9$30 trigger FilterAllUnits ( [ f_class , class_apeman ] ) < 9 do var i ;
3386: LD_INT 25
3388: PUSH
3389: LD_INT 12
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 69
3400: PUSH
3401: LD_INT 9
3403: LESS
3404: IFFALSE 3446
3406: GO 3408
3408: DISABLE
3409: LD_INT 0
3411: PPUSH
// begin enable ;
3412: ENABLE
// i := FilterAllUnits ( [ f_class , class_apeman ] ) ;
3413: LD_ADDR_VAR 0 1
3417: PUSH
3418: LD_INT 25
3420: PUSH
3421: LD_INT 12
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PPUSH
3428: CALL_OW 69
3432: ST_TO_ADDR
// PrepareApeman ( 8 - i ) ;
3433: LD_INT 8
3435: PUSH
3436: LD_VAR 0 1
3440: MINUS
3441: PPUSH
3442: CALL 1883 0 1
// end ; end_of_file
3446: PPOPN 1
3448: END
// export ru_force , ru_skill , ru_cargo , ru_blist , ru_vlist , ru_amount , ru_time , ru_teleport_exit ; export function PrepareRussian ; var i , un , ru_depot , ru_factory , ru_teleport , ru_barracks , ru_bunkers , ru_buildings , ru_vehicles , ru_humans ; begin
3449: LD_INT 0
3451: PPUSH
3452: PPUSH
3453: PPUSH
3454: PPUSH
3455: PPUSH
3456: PPUSH
3457: PPUSH
3458: PPUSH
3459: PPUSH
3460: PPUSH
3461: PPUSH
// uc_side := 3 ;
3462: LD_ADDR_OWVAR 20
3466: PUSH
3467: LD_INT 3
3469: ST_TO_ADDR
// uc_nation := nation_russian ;
3470: LD_ADDR_OWVAR 21
3474: PUSH
3475: LD_INT 3
3477: ST_TO_ADDR
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3478: LD_ADDR_VAR 0 4
3482: PUSH
3483: LD_INT 22
3485: PUSH
3486: LD_INT 3
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: PUSH
3493: LD_INT 30
3495: PUSH
3496: LD_INT 1
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 69
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3516: LD_ADDR_VAR 0 5
3520: PUSH
3521: LD_INT 22
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: LD_INT 30
3533: PUSH
3534: LD_INT 3
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 69
3549: PUSH
3550: LD_INT 1
3552: ARRAY
3553: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
3554: LD_ADDR_VAR 0 6
3558: PUSH
3559: LD_INT 22
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 30
3571: PUSH
3572: LD_INT 34
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PPUSH
3583: CALL_OW 69
3587: PUSH
3588: LD_INT 1
3590: ARRAY
3591: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3592: LD_ADDR_VAR 0 8
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 33
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
3626: LD_ADDR_VAR 0 7
3630: PUSH
3631: LD_INT 22
3633: PUSH
3634: LD_INT 3
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: PUSH
3641: LD_INT 30
3643: PUSH
3644: LD_INT 5
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PPUSH
3655: CALL_OW 69
3659: PUSH
3660: LD_INT 1
3662: ARRAY
3663: ST_TO_ADDR
// ru_blist := [ ] ;
3664: LD_ADDR_EXP 26
3668: PUSH
3669: EMPTY
3670: ST_TO_ADDR
// ru_vlist := [ ] ;
3671: LD_ADDR_EXP 27
3675: PUSH
3676: EMPTY
3677: ST_TO_ADDR
// ru_teleport_exit := [ 183 , 62 , 147 , 44 ] ;
3678: LD_ADDR_EXP 30
3682: PUSH
3683: LD_INT 183
3685: PUSH
3686: LD_INT 62
3688: PUSH
3689: LD_INT 147
3691: PUSH
3692: LD_INT 44
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ f_btype , b_teleport ] ) [ 1 ] , ru_teleport_exit [ 1 ] , ru_teleport_exit [ 2 ] ) ;
3701: LD_INT 30
3703: PUSH
3704: LD_INT 34
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PPUSH
3711: CALL_OW 69
3715: PUSH
3716: LD_INT 1
3718: ARRAY
3719: PPUSH
3720: LD_EXP 30
3724: PUSH
3725: LD_INT 1
3727: ARRAY
3728: PPUSH
3729: LD_EXP 30
3733: PUSH
3734: LD_INT 2
3736: ARRAY
3737: PPUSH
3738: CALL_OW 243
// ru_amount := [ 4 , 5 , 6 ] [ Difficulty ] ;
3742: LD_ADDR_EXP 28
3746: PUSH
3747: LD_INT 4
3749: PUSH
3750: LD_INT 5
3752: PUSH
3753: LD_INT 6
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: LIST
3760: PUSH
3761: LD_OWVAR 67
3765: ARRAY
3766: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 3000 ) ;
3767: LD_VAR 0 4
3771: PPUSH
3772: CALL_OW 274
3776: PPUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 3000
3782: PPUSH
3783: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 300 ) ;
3787: LD_VAR 0 4
3791: PPUSH
3792: CALL_OW 274
3796: PPUSH
3797: LD_INT 2
3799: PPUSH
3800: LD_INT 300
3802: PPUSH
3803: CALL_OW 277
// hc_gallery :=  ;
3807: LD_ADDR_OWVAR 33
3811: PUSH
3812: LD_STRING 
3814: ST_TO_ADDR
// hc_name :=  ;
3815: LD_ADDR_OWVAR 26
3819: PUSH
3820: LD_STRING 
3822: ST_TO_ADDR
// hc_importance := 0 ;
3823: LD_ADDR_OWVAR 32
3827: PUSH
3828: LD_INT 0
3830: ST_TO_ADDR
// ru_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3831: LD_ADDR_EXP 24
3835: PUSH
3836: LD_INT 5
3838: PUSH
3839: LD_INT 6
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: PUSH
3850: LD_OWVAR 67
3854: ARRAY
3855: ST_TO_ADDR
// for i = 1 to 6 do
3856: LD_ADDR_VAR 0 2
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_INT 6
3868: PUSH
3869: FOR_TO
3870: IFFALSE 4028
// begin PrepareHuman ( false , class_bazooker , ru_skill ) ;
3872: LD_INT 0
3874: PPUSH
3875: LD_INT 9
3877: PPUSH
3878: LD_EXP 24
3882: PPUSH
3883: CALL_OW 380
// un := CreateHuman ;
3887: LD_ADDR_VAR 0 3
3891: PUSH
3892: CALL_OW 44
3896: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_barracks ) ;
3897: LD_VAR 0 3
3901: PPUSH
3902: LD_VAR 0 7
3906: PPUSH
3907: CALL_OW 52
// PrepareHuman ( false , 4 , ru_skill ) ;
3911: LD_INT 0
3913: PPUSH
3914: LD_INT 4
3916: PPUSH
3917: LD_EXP 24
3921: PPUSH
3922: CALL_OW 380
// un := CreateHuman ;
3926: LD_ADDR_VAR 0 3
3930: PUSH
3931: CALL_OW 44
3935: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
3936: LD_VAR 0 3
3940: PPUSH
3941: LD_INT 24
3943: PPUSH
3944: CALL_OW 52
// PrepareHuman ( false , 3 , ru_skill ) ;
3948: LD_INT 0
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_EXP 24
3958: PPUSH
3959: CALL_OW 380
// un := CreateHuman ;
3963: LD_ADDR_VAR 0 3
3967: PUSH
3968: CALL_OW 44
3972: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_factory ) ;
3973: LD_VAR 0 3
3977: PPUSH
3978: LD_VAR 0 5
3982: PPUSH
3983: CALL_OW 52
// PrepareHuman ( false , 2 , ru_skill ) ;
3987: LD_INT 0
3989: PPUSH
3990: LD_INT 2
3992: PPUSH
3993: LD_EXP 24
3997: PPUSH
3998: CALL_OW 380
// un := CreateHuman ;
4002: LD_ADDR_VAR 0 3
4006: PUSH
4007: CALL_OW 44
4011: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_depot ) ;
4012: LD_VAR 0 3
4016: PPUSH
4017: LD_VAR 0 4
4021: PPUSH
4022: CALL_OW 52
// end ;
4026: GO 3869
4028: POP
4029: POP
// russian_prepared := true ;
4030: LD_ADDR_EXP 2
4034: PUSH
4035: LD_INT 1
4037: ST_TO_ADDR
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4038: LD_VAR 0 5
4042: PPUSH
4043: LD_INT 21
4045: PPUSH
4046: LD_INT 3
4048: PPUSH
4049: LD_INT 3
4051: PPUSH
4052: LD_INT 51
4054: PPUSH
4055: CALL_OW 125
// end ;
4059: LD_VAR 0 1
4063: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 and russian_prepared do var ru_depot , ru_factory , ru_teleport , ru_bunkers , ru_buildings , ru_vehicles , ru_humans , ru_barracks , ru_engs , ru_mech , ru_sci , i , tmp , filter , p , cr , sib_bomb ;
4064: LD_INT 22
4066: PUSH
4067: LD_INT 3
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PPUSH
4074: CALL_OW 69
4078: PUSH
4079: LD_INT 0
4081: GREATER
4082: PUSH
4083: LD_EXP 2
4087: AND
4088: IFFALSE 6537
4090: GO 4092
4092: DISABLE
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
4099: PPUSH
4100: PPUSH
4101: PPUSH
4102: PPUSH
4103: PPUSH
4104: PPUSH
4105: PPUSH
4106: PPUSH
4107: PPUSH
4108: PPUSH
4109: PPUSH
4110: PPUSH
4111: PPUSH
// begin enable ;
4112: ENABLE
// ru_depot := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
4113: LD_ADDR_VAR 0 1
4117: PUSH
4118: LD_INT 22
4120: PUSH
4121: LD_INT 3
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 30
4130: PUSH
4131: LD_INT 1
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: ST_TO_ADDR
// ru_factory := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
4151: LD_ADDR_VAR 0 2
4155: PUSH
4156: LD_INT 22
4158: PUSH
4159: LD_INT 3
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 30
4168: PUSH
4169: LD_INT 3
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PPUSH
4180: CALL_OW 69
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: ST_TO_ADDR
// ru_teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] ;
4189: LD_ADDR_VAR 0 3
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 3
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 30
4206: PUSH
4207: LD_INT 34
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PPUSH
4218: CALL_OW 69
4222: PUSH
4223: LD_INT 1
4225: ARRAY
4226: ST_TO_ADDR
// ru_bunkers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4227: LD_ADDR_VAR 0 4
4231: PUSH
4232: LD_INT 22
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 33
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: ST_TO_ADDR
// ru_barracks := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
4261: LD_ADDR_VAR 0 8
4265: PUSH
4266: LD_INT 22
4268: PUSH
4269: LD_INT 3
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PUSH
4276: LD_INT 30
4278: PUSH
4279: LD_INT 5
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PPUSH
4290: CALL_OW 69
4294: PUSH
4295: LD_INT 1
4297: ARRAY
4298: ST_TO_ADDR
// ru_buildings := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4299: LD_ADDR_VAR 0 5
4303: PUSH
4304: LD_INT 22
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 21
4316: PUSH
4317: LD_INT 3
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PPUSH
4328: CALL_OW 69
4332: ST_TO_ADDR
// ru_vehicles := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: LD_INT 22
4340: PUSH
4341: LD_INT 3
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: LD_INT 21
4350: PUSH
4351: LD_INT 2
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: PPUSH
4362: CALL_OW 69
4366: ST_TO_ADDR
// ru_humans := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 3
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 21
4384: PUSH
4385: LD_INT 1
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: ST_TO_ADDR
// ru_engs := UnitFilter ( ru_humans , [ f_class , 2 ] ) ;
4401: LD_ADDR_VAR 0 9
4405: PUSH
4406: LD_VAR 0 7
4410: PPUSH
4411: LD_INT 25
4413: PUSH
4414: LD_INT 2
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 72
4425: ST_TO_ADDR
// ru_mech := UnitFilter ( ru_humans , [ f_class , 3 ] ) ;
4426: LD_ADDR_VAR 0 10
4430: PUSH
4431: LD_VAR 0 7
4435: PPUSH
4436: LD_INT 25
4438: PUSH
4439: LD_INT 3
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 72
4450: ST_TO_ADDR
// ru_sci := UnitFilter ( ru_humans , [ f_class , 4 ] ) ;
4451: LD_ADDR_VAR 0 11
4455: PUSH
4456: LD_VAR 0 7
4460: PPUSH
4461: LD_INT 25
4463: PUSH
4464: LD_INT 4
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PPUSH
4471: CALL_OW 72
4475: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) > 0 and ru_cargo = false then
4476: LD_INT 22
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 34
4488: PUSH
4489: LD_INT 51
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PPUSH
4500: CALL_OW 69
4504: PUSH
4505: LD_INT 0
4507: GREATER
4508: PUSH
4509: LD_EXP 25
4513: PUSH
4514: LD_INT 0
4516: EQUAL
4517: AND
4518: IFFALSE 4558
// ru_cargo := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
4520: LD_ADDR_EXP 25
4524: PUSH
4525: LD_INT 22
4527: PUSH
4528: LD_INT 3
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: LD_INT 34
4537: PUSH
4538: LD_INT 51
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PPUSH
4549: CALL_OW 69
4553: PUSH
4554: LD_INT 1
4556: ARRAY
4557: ST_TO_ADDR
// if ru_cargo then
4558: LD_EXP 25
4562: IFFALSE 4860
// begin if IsInArea ( ru_cargo , ru_base ) then
4564: LD_EXP 25
4568: PPUSH
4569: LD_INT 9
4571: PPUSH
4572: CALL_OW 308
4576: IFFALSE 4655
// begin if GetCargo ( ru_cargo , mat_cans ) = 0 then
4578: LD_EXP 25
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 289
4590: PUSH
4591: LD_INT 0
4593: EQUAL
4594: IFFALSE 4612
// ComEnterUnit ( ru_cargo , ru_teleport ) else
4596: LD_EXP 25
4600: PPUSH
4601: LD_VAR 0 3
4605: PPUSH
4606: CALL_OW 120
4610: GO 4653
// if not HasTask ( ru_cargo ) then
4612: LD_EXP 25
4616: PPUSH
4617: CALL_OW 314
4621: NOT
4622: IFFALSE 4653
// ComMoveXY ( ru_cargo , GetX ( ru_depot ) , GetY ( ru_depot ) ) ;
4624: LD_EXP 25
4628: PPUSH
4629: LD_VAR 0 1
4633: PPUSH
4634: CALL_OW 250
4638: PPUSH
4639: LD_VAR 0 1
4643: PPUSH
4644: CALL_OW 251
4648: PPUSH
4649: CALL_OW 111
// end else
4653: GO 4860
// begin if not HasTask ( ru_cargo ) and GetCargo ( ru_cargo , mat_cans ) < 100 then
4655: LD_EXP 25
4659: PPUSH
4660: CALL_OW 314
4664: NOT
4665: PUSH
4666: LD_EXP 25
4670: PPUSH
4671: LD_INT 1
4673: PPUSH
4674: CALL_OW 289
4678: PUSH
4679: LD_INT 100
4681: LESS
4682: AND
4683: IFFALSE 4749
// begin cr := GetListOfCratesInArea ( ru_crates ) ;
4685: LD_ADDR_VAR 0 16
4689: PUSH
4690: LD_INT 11
4692: PPUSH
4693: CALL_OW 435
4697: ST_TO_ADDR
// if cr > 0 then
4698: LD_VAR 0 16
4702: PUSH
4703: LD_INT 0
4705: GREATER
4706: IFFALSE 4737
// ComCollect ( ru_cargo , cr [ 1 ] , cr [ 2 ] ) else
4708: LD_EXP 25
4712: PPUSH
4713: LD_VAR 0 16
4717: PUSH
4718: LD_INT 1
4720: ARRAY
4721: PPUSH
4722: LD_VAR 0 16
4726: PUSH
4727: LD_INT 2
4729: ARRAY
4730: PPUSH
4731: CALL_OW 117
4735: GO 4749
// ComMoveToArea ( ru_cargo , ru_crates ) ;
4737: LD_EXP 25
4741: PPUSH
4742: LD_INT 11
4744: PPUSH
4745: CALL_OW 113
// end ; if not HasTask ( ru_cargo ) and not IsInArea ( ru_cargo , cargoa ) and GetCargo ( ru_cargo , mat_cans ) = 100 then
4749: LD_EXP 25
4753: PPUSH
4754: CALL_OW 314
4758: NOT
4759: PUSH
4760: LD_EXP 25
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 308
4772: NOT
4773: AND
4774: PUSH
4775: LD_EXP 25
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: CALL_OW 289
4787: PUSH
4788: LD_INT 100
4790: EQUAL
4791: AND
4792: IFFALSE 4806
// ComMoveToArea ( ru_cargo , cargoa ) ;
4794: LD_EXP 25
4798: PPUSH
4799: LD_INT 10
4801: PPUSH
4802: CALL_OW 113
// if IsInArea ( ru_cargo , cargoa ) and ru_barracks then
4806: LD_EXP 25
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 308
4818: PUSH
4819: LD_VAR 0 8
4823: AND
4824: IFFALSE 4860
// ComSpaceShift ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) [ 1 ] , 139 , 24 ) ;
4826: LD_VAR 0 7
4830: PPUSH
4831: LD_INT 25
4833: PUSH
4834: LD_INT 9
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: PUSH
4846: LD_INT 1
4848: ARRAY
4849: PPUSH
4850: LD_INT 139
4852: PPUSH
4853: LD_INT 24
4855: PPUSH
4856: CALL_OW 153
// end ; end ; if ru_cargo = 0 and ru_factory and BuildingStatus ( ru_factory ) = bs_idle then
4860: LD_EXP 25
4864: PUSH
4865: LD_INT 0
4867: EQUAL
4868: PUSH
4869: LD_VAR 0 2
4873: AND
4874: PUSH
4875: LD_VAR 0 2
4879: PPUSH
4880: CALL_OW 461
4884: PUSH
4885: LD_INT 2
4887: EQUAL
4888: AND
4889: IFFALSE 4912
// ComConstruct ( ru_factory , ru_medium_wheeled , 3 , control_computer , ru_cargo_bay ) ;
4891: LD_VAR 0 2
4895: PPUSH
4896: LD_INT 21
4898: PPUSH
4899: LD_INT 3
4901: PPUSH
4902: LD_INT 3
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: CALL_OW 125
// if UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) then
4912: LD_VAR 0 7
4916: PPUSH
4917: LD_INT 25
4919: PUSH
4920: LD_INT 9
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 72
4931: IFFALSE 4995
// IntBazooka ( UnitFilter ( ru_humans , [ f_class , class_bazooker ] ) , FilterAllUnits ( [ [ f_side , Your_Side ] , [ f_not , [ f_type , unit_building ] ] ] ) ) ;
4933: LD_VAR 0 7
4937: PPUSH
4938: LD_INT 25
4940: PUSH
4941: LD_INT 9
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 72
4952: PPUSH
4953: LD_INT 22
4955: PUSH
4956: LD_OWVAR 2
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: LD_INT 21
4970: PUSH
4971: LD_INT 3
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PPUSH
4986: CALL_OW 69
4990: PPUSH
4991: CALL 1656 0 2
// if ru_factory and ru_vlist > 0 then
4995: LD_VAR 0 2
4999: PUSH
5000: LD_EXP 27
5004: PUSH
5005: LD_INT 0
5007: GREATER
5008: AND
5009: IFFALSE 5109
// begin if BuildingStatus ( ru_factory ) = bs_idle then
5011: LD_VAR 0 2
5015: PPUSH
5016: CALL_OW 461
5020: PUSH
5021: LD_INT 2
5023: EQUAL
5024: IFFALSE 5109
// begin ComConstruct ( ru_factory , ru_vlist [ 1 ] , ru_vlist [ 2 ] , ru_vlist [ 3 ] , ru_vlist [ 4 ] ) ;
5026: LD_VAR 0 2
5030: PPUSH
5031: LD_EXP 27
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PPUSH
5040: LD_EXP 27
5044: PUSH
5045: LD_INT 2
5047: ARRAY
5048: PPUSH
5049: LD_EXP 27
5053: PUSH
5054: LD_INT 3
5056: ARRAY
5057: PPUSH
5058: LD_EXP 27
5062: PUSH
5063: LD_INT 4
5065: ARRAY
5066: PPUSH
5067: CALL_OW 125
// for i = 1 to 4 do
5071: LD_ADDR_VAR 0 12
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 4
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5107
// ru_vlist := Delete ( ru_vlist , 1 ) ;
5087: LD_ADDR_EXP 27
5091: PUSH
5092: LD_EXP 27
5096: PPUSH
5097: LD_INT 1
5099: PPUSH
5100: CALL_OW 3
5104: ST_TO_ADDR
5105: GO 5084
5107: POP
5108: POP
// end ; end ; if BuildingStatus ( ru_lab ) = bs_idle and ru_sib_bomb then
5109: LD_INT 24
5111: PPUSH
5112: CALL_OW 461
5116: PUSH
5117: LD_INT 2
5119: EQUAL
5120: PUSH
5121: LD_EXP 4
5125: AND
5126: IFFALSE 5154
// if GetTech ( tech_sibfiss , 3 ) = state_enabled then
5128: LD_INT 25
5130: PPUSH
5131: LD_INT 3
5133: PPUSH
5134: CALL_OW 321
5138: PUSH
5139: LD_INT 1
5141: EQUAL
5142: IFFALSE 5154
// ComResearch ( ru_lab , tech_sibfiss ) ;
5144: LD_INT 24
5146: PPUSH
5147: LD_INT 25
5149: PPUSH
5150: CALL_OW 124
// if GetTech ( tech_sibfiss , 3 ) = state_researched then
5154: LD_INT 25
5156: PPUSH
5157: LD_INT 3
5159: PPUSH
5160: CALL_OW 321
5164: PUSH
5165: LD_INT 2
5167: EQUAL
5168: IFFALSE 5206
// if BuildingStatus ( ru_factory ) = bs_idle then
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 461
5179: PUSH
5180: LD_INT 2
5182: EQUAL
5183: IFFALSE 5206
// ComConstruct ( ru_factory , ru_heavy_wheeled , 3 , control_computer , ru_siberium_rocket ) ;
5185: LD_VAR 0 2
5189: PPUSH
5190: LD_INT 23
5192: PPUSH
5193: LD_INT 3
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 48
5201: PPUSH
5202: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) > 0 then
5206: LD_INT 22
5208: PUSH
5209: LD_INT 3
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PUSH
5216: LD_INT 34
5218: PUSH
5219: LD_INT 48
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 69
5234: PUSH
5235: LD_INT 0
5237: GREATER
5238: IFFALSE 5612
// begin sib_bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
5240: LD_ADDR_VAR 0 17
5244: PUSH
5245: LD_INT 22
5247: PUSH
5248: LD_INT 3
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: LD_INT 34
5257: PUSH
5258: LD_INT 48
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PPUSH
5269: CALL_OW 69
5273: PUSH
5274: LD_INT 1
5276: ARRAY
5277: ST_TO_ADDR
// if IsInArea ( sib_bomb , ru_base ) then
5278: LD_VAR 0 17
5282: PPUSH
5283: LD_INT 9
5285: PPUSH
5286: CALL_OW 308
5290: IFFALSE 5308
// ComEnterUnit ( sib_bomb , ru_teleport ) else
5292: LD_VAR 0 17
5296: PPUSH
5297: LD_VAR 0 3
5301: PPUSH
5302: CALL_OW 120
5306: GO 5612
// if not HasTask ( sib_bomb ) then
5308: LD_VAR 0 17
5312: PPUSH
5313: CALL_OW 314
5317: NOT
5318: IFFALSE 5612
// if GetLives ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) > 250 then
5320: LD_INT 22
5322: PUSH
5323: LD_OWVAR 2
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: PUSH
5332: LD_INT 30
5334: PUSH
5335: LD_INT 1
5337: PUSH
5338: EMPTY
5339: LIST
5340: LIST
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PPUSH
5346: CALL_OW 69
5350: PUSH
5351: LD_INT 1
5353: ARRAY
5354: PPUSH
5355: CALL_OW 256
5359: PUSH
5360: LD_INT 250
5362: GREATER
5363: IFFALSE 5456
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ) else
5365: LD_VAR 0 17
5369: PPUSH
5370: LD_INT 22
5372: PUSH
5373: LD_OWVAR 2
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PUSH
5382: LD_INT 30
5384: PUSH
5385: LD_INT 1
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PPUSH
5396: CALL_OW 69
5400: PUSH
5401: LD_INT 1
5403: ARRAY
5404: PPUSH
5405: CALL_OW 250
5409: PPUSH
5410: LD_INT 22
5412: PUSH
5413: LD_OWVAR 2
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: PUSH
5422: LD_INT 30
5424: PUSH
5425: LD_INT 1
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: PUSH
5441: LD_INT 1
5443: ARRAY
5444: PPUSH
5445: CALL_OW 251
5449: PPUSH
5450: CALL_OW 116
5454: GO 5612
// if FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) > 0 then
5456: LD_INT 22
5458: PUSH
5459: LD_OWVAR 2
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PUSH
5468: LD_INT 21
5470: PUSH
5471: LD_INT 3
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PPUSH
5482: CALL_OW 69
5486: PUSH
5487: LD_INT 0
5489: GREATER
5490: IFFALSE 5583
// ComAttackPlace ( sib_bomb , GetX ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) , GetY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) [ 1 ] ) ) else
5492: LD_VAR 0 17
5496: PPUSH
5497: LD_INT 22
5499: PUSH
5500: LD_OWVAR 2
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PUSH
5509: LD_INT 21
5511: PUSH
5512: LD_INT 3
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: PUSH
5528: LD_INT 1
5530: ARRAY
5531: PPUSH
5532: CALL_OW 250
5536: PPUSH
5537: LD_INT 22
5539: PUSH
5540: LD_OWVAR 2
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 21
5551: PUSH
5552: LD_INT 3
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL_OW 69
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: CALL_OW 251
5576: PPUSH
5577: CALL_OW 116
5581: GO 5612
// ComAttackPlace ( sib_bomb , GetX ( player_commander ) , GetY ( player_commander ) ) ;
5583: LD_VAR 0 17
5587: PPUSH
5588: LD_EXP 10
5592: PPUSH
5593: CALL_OW 250
5597: PPUSH
5598: LD_EXP 10
5602: PPUSH
5603: CALL_OW 251
5607: PPUSH
5608: CALL_OW 116
// end ; if ru_can_attack then
5612: LD_EXP 3
5616: IFFALSE 5764
// if ru_time > 0 0$00 then
5618: LD_EXP 29
5622: PUSH
5623: LD_INT 0
5625: GREATER
5626: IFFALSE 5644
// ru_time := ru_time - 0 0$01 else
5628: LD_ADDR_EXP 29
5632: PUSH
5633: LD_EXP 29
5637: PUSH
5638: LD_INT 35
5640: MINUS
5641: ST_TO_ADDR
5642: GO 5764
// begin ru_time := Rand ( 9 9$39 , 14 14$39 ) ;
5644: LD_ADDR_EXP 29
5648: PUSH
5649: LD_INT 20265
5651: PPUSH
5652: LD_INT 30765
5654: PPUSH
5655: CALL_OW 12
5659: ST_TO_ADDR
// for i = 1 to ru_amount do
5660: LD_ADDR_VAR 0 12
5664: PUSH
5665: DOUBLE
5666: LD_INT 1
5668: DEC
5669: ST_TO_ADDR
5670: LD_EXP 28
5674: PUSH
5675: FOR_TO
5676: IFFALSE 5762
// begin ru_vlist := ru_vlist ^ ru_heavy_wheeled ;
5678: LD_ADDR_EXP 27
5682: PUSH
5683: LD_EXP 27
5687: PUSH
5688: LD_INT 23
5690: ADD
5691: ST_TO_ADDR
// ru_vlist := ru_vlist ^ engine_siberite ;
5692: LD_ADDR_EXP 27
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ADD
5705: ST_TO_ADDR
// ru_vlist := ru_vlist ^ control_computer ;
5706: LD_ADDR_EXP 27
5710: PUSH
5711: LD_EXP 27
5715: PUSH
5716: LD_INT 3
5718: ADD
5719: ST_TO_ADDR
// ru_vlist := ru_vlist ^ [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] [ MultiRand ( 1 , 2 , 3 ) ] ;
5720: LD_ADDR_EXP 27
5724: PUSH
5725: LD_EXP 27
5729: PUSH
5730: LD_INT 46
5732: PUSH
5733: LD_INT 45
5735: PUSH
5736: LD_INT 47
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 1
5746: PPUSH
5747: LD_INT 2
5749: PPUSH
5750: LD_INT 3
5752: PPUSH
5753: CALL_OW 14
5757: ARRAY
5758: ADD
5759: ST_TO_ADDR
// end ;
5760: GO 5675
5762: POP
5763: POP
// end ; if UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) > 0 then
5764: LD_VAR 0 4
5768: PPUSH
5769: LD_INT 35
5771: PUSH
5772: LD_INT 0
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PPUSH
5779: CALL_OW 72
5783: PUSH
5784: LD_INT 0
5786: GREATER
5787: IFFALSE 5835
// if BuildingStatus ( ru_factory ) = bs_idle then
5789: LD_VAR 0 2
5793: PPUSH
5794: CALL_OW 461
5798: PUSH
5799: LD_INT 2
5801: EQUAL
5802: IFFALSE 5835
// ComPlaceWeapon ( UnitFilter ( ru_bunkers , [ f_bweapon , 0 ] ) [ 1 ] , ru_rocket ) ;
5804: LD_VAR 0 4
5808: PPUSH
5809: LD_INT 35
5811: PUSH
5812: LD_INT 0
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PPUSH
5819: CALL_OW 72
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_INT 47
5830: PPUSH
5831: CALL_OW 148
// if ru_force = ru_amount then
5835: LD_EXP 23
5839: PUSH
5840: LD_EXP 28
5844: EQUAL
5845: IFFALSE 5977
// begin for i = 1 to ru_force do
5847: LD_ADDR_VAR 0 12
5851: PUSH
5852: DOUBLE
5853: LD_INT 1
5855: DEC
5856: ST_TO_ADDR
5857: LD_EXP 23
5861: PUSH
5862: FOR_TO
5863: IFFALSE 5973
// if IsInArea ( ru_force [ i ] , ru_base ) then
5865: LD_EXP 23
5869: PUSH
5870: LD_VAR 0 12
5874: ARRAY
5875: PPUSH
5876: LD_INT 9
5878: PPUSH
5879: CALL_OW 308
5883: IFFALSE 5907
// ComEnterUnit ( ru_force [ i ] , ru_teleport ) else
5885: LD_EXP 23
5889: PUSH
5890: LD_VAR 0 12
5894: ARRAY
5895: PPUSH
5896: LD_VAR 0 3
5900: PPUSH
5901: CALL_OW 120
5905: GO 5971
// if not HasTask ( ru_force [ i ] ) then
5907: LD_EXP 23
5911: PUSH
5912: LD_VAR 0 12
5916: ARRAY
5917: PPUSH
5918: CALL_OW 314
5922: NOT
5923: IFFALSE 5971
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
5925: LD_EXP 23
5929: PUSH
5930: LD_VAR 0 12
5934: ARRAY
5935: PPUSH
5936: LD_INT 81
5938: PUSH
5939: LD_INT 3
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PPUSH
5946: CALL_OW 69
5950: PPUSH
5951: LD_EXP 23
5955: PUSH
5956: LD_VAR 0 12
5960: ARRAY
5961: PPUSH
5962: CALL_OW 74
5966: PPUSH
5967: CALL_OW 115
5971: GO 5862
5973: POP
5974: POP
// end else
5975: GO 6127
// if UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
5977: LD_EXP 23
5981: PPUSH
5982: LD_INT 3
5984: PUSH
5985: LD_INT 95
5987: PUSH
5988: LD_INT 18
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: PUSH
6004: LD_INT 0
6006: GREATER
6007: IFFALSE 6127
// begin tmp := UnitFilter ( ru_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
6009: LD_ADDR_VAR 0 13
6013: PUSH
6014: LD_EXP 23
6018: PPUSH
6019: LD_INT 3
6021: PUSH
6022: LD_INT 95
6024: PUSH
6025: LD_INT 18
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PPUSH
6036: CALL_OW 72
6040: ST_TO_ADDR
// for i = 1 to tmp do
6041: LD_ADDR_VAR 0 12
6045: PUSH
6046: DOUBLE
6047: LD_INT 1
6049: DEC
6050: ST_TO_ADDR
6051: LD_VAR 0 13
6055: PUSH
6056: FOR_TO
6057: IFFALSE 6125
// if not HasTask ( tmp [ i ] ) then
6059: LD_VAR 0 13
6063: PUSH
6064: LD_VAR 0 12
6068: ARRAY
6069: PPUSH
6070: CALL_OW 314
6074: NOT
6075: IFFALSE 6123
// ComAttackUnit ( ru_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , ru_force [ i ] ) ) ;
6077: LD_EXP 23
6081: PUSH
6082: LD_VAR 0 12
6086: ARRAY
6087: PPUSH
6088: LD_INT 81
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PPUSH
6098: CALL_OW 69
6102: PPUSH
6103: LD_EXP 23
6107: PUSH
6108: LD_VAR 0 12
6112: ARRAY
6113: PPUSH
6114: CALL_OW 74
6118: PPUSH
6119: CALL_OW 115
6123: GO 6056
6125: POP
6126: POP
// end ; if ru_engs > 0 then
6127: LD_VAR 0 9
6131: PUSH
6132: LD_INT 0
6134: GREATER
6135: IFFALSE 6537
// begin if UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
6137: LD_VAR 0 5
6141: PPUSH
6142: LD_INT 3
6144: PUSH
6145: LD_INT 24
6147: PUSH
6148: LD_INT 1000
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 72
6163: PUSH
6164: LD_INT 0
6166: GREATER
6167: IFFALSE 6322
// begin filter := UnitFilter ( ru_buildings , [ f_not , [ f_lives , 1000 ] ] ) ;
6169: LD_ADDR_VAR 0 14
6173: PUSH
6174: LD_VAR 0 5
6178: PPUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 24
6184: PUSH
6185: LD_INT 1000
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PPUSH
6196: CALL_OW 72
6200: ST_TO_ADDR
// for i = 1 to ru_engs do
6201: LD_ADDR_VAR 0 12
6205: PUSH
6206: DOUBLE
6207: LD_INT 1
6209: DEC
6210: ST_TO_ADDR
6211: LD_VAR 0 9
6215: PUSH
6216: FOR_TO
6217: IFFALSE 6318
// begin if IsInUnit ( ru_engs [ i ] ) then
6219: LD_VAR 0 9
6223: PUSH
6224: LD_VAR 0 12
6228: ARRAY
6229: PPUSH
6230: CALL_OW 310
6234: IFFALSE 6253
// ComExitBuilding ( ru_engs [ i ] ) else
6236: LD_VAR 0 9
6240: PUSH
6241: LD_VAR 0 12
6245: ARRAY
6246: PPUSH
6247: CALL_OW 122
6251: GO 6316
// if not HasTask ( ru_engs [ i ] ) and GetLives ( ru_engs [ i ] ) > 600 then
6253: LD_VAR 0 9
6257: PUSH
6258: LD_VAR 0 12
6262: ARRAY
6263: PPUSH
6264: CALL_OW 314
6268: NOT
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_VAR 0 12
6279: ARRAY
6280: PPUSH
6281: CALL_OW 256
6285: PUSH
6286: LD_INT 600
6288: GREATER
6289: AND
6290: IFFALSE 6316
// ComRepairBuilding ( ru_engs [ i ] , filter [ 1 ] ) ;
6292: LD_VAR 0 9
6296: PUSH
6297: LD_VAR 0 12
6301: ARRAY
6302: PPUSH
6303: LD_VAR 0 14
6307: PUSH
6308: LD_INT 1
6310: ARRAY
6311: PPUSH
6312: CALL_OW 130
// end ;
6316: GO 6216
6318: POP
6319: POP
// end else
6320: GO 6537
// begin if ru_blist = 0 then
6322: LD_EXP 26
6326: PUSH
6327: LD_INT 0
6329: EQUAL
6330: IFFALSE 6412
// begin for i = 1 to ru_engs do
6332: LD_ADDR_VAR 0 12
6336: PUSH
6337: DOUBLE
6338: LD_INT 1
6340: DEC
6341: ST_TO_ADDR
6342: LD_VAR 0 9
6346: PUSH
6347: FOR_TO
6348: IFFALSE 6408
// if not HasTask ( ru_engs [ i ] ) and not IsInUnit ( ru_engs [ i ] ) then
6350: LD_VAR 0 9
6354: PUSH
6355: LD_VAR 0 12
6359: ARRAY
6360: PPUSH
6361: CALL_OW 314
6365: NOT
6366: PUSH
6367: LD_VAR 0 9
6371: PUSH
6372: LD_VAR 0 12
6376: ARRAY
6377: PPUSH
6378: CALL_OW 310
6382: NOT
6383: AND
6384: IFFALSE 6406
// ComEnterUnit ( ru_engs [ i ] , ru_depot ) ;
6386: LD_VAR 0 9
6390: PUSH
6391: LD_VAR 0 12
6395: ARRAY
6396: PPUSH
6397: LD_VAR 0 1
6401: PPUSH
6402: CALL_OW 120
6406: GO 6347
6408: POP
6409: POP
// end else
6410: GO 6537
// begin for i = 1 to ru_engs do
6412: LD_ADDR_VAR 0 12
6416: PUSH
6417: DOUBLE
6418: LD_INT 1
6420: DEC
6421: ST_TO_ADDR
6422: LD_VAR 0 9
6426: PUSH
6427: FOR_TO
6428: IFFALSE 6535
// begin if IsInUnit ( ru_engs [ i ] ) then
6430: LD_VAR 0 9
6434: PUSH
6435: LD_VAR 0 12
6439: ARRAY
6440: PPUSH
6441: CALL_OW 310
6445: IFFALSE 6464
// ComExitBuilding ( ru_engs [ i ] ) else
6447: LD_VAR 0 9
6451: PUSH
6452: LD_VAR 0 12
6456: ARRAY
6457: PPUSH
6458: CALL_OW 122
6462: GO 6533
// if not HasTask ( ru_engs [ i ] ) then
6464: LD_VAR 0 9
6468: PUSH
6469: LD_VAR 0 12
6473: ARRAY
6474: PPUSH
6475: CALL_OW 314
6479: NOT
6480: IFFALSE 6533
// ComBuild ( ru_engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
6482: LD_VAR 0 9
6486: PUSH
6487: LD_VAR 0 12
6491: ARRAY
6492: PPUSH
6493: LD_EXP 26
6497: PUSH
6498: LD_INT 1
6500: ARRAY
6501: PPUSH
6502: LD_EXP 26
6506: PUSH
6507: LD_INT 2
6509: ARRAY
6510: PPUSH
6511: LD_EXP 26
6515: PUSH
6516: LD_INT 3
6518: ARRAY
6519: PPUSH
6520: LD_EXP 26
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PPUSH
6529: CALL_OW 145
// end ;
6533: GO 6427
6535: POP
6536: POP
// end ; end ; end ; end ;
6537: PPOPN 17
6539: END
// every 2 2$40 + 0 0$45 trigger russian_prepared and GetListOfCratesInArea ( ru_crates ) < 20 do
6540: LD_EXP 2
6544: PUSH
6545: LD_INT 11
6547: PPUSH
6548: CALL_OW 435
6552: PUSH
6553: LD_INT 20
6555: LESS
6556: AND
6557: IFFALSE 6620
6559: GO 6561
6561: DISABLE
// begin enable ;
6562: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6563: LD_INT 1
6565: PPUSH
6566: LD_INT 5
6568: PPUSH
6569: CALL_OW 12
6573: PPUSH
6574: LD_INT 11
6576: PPUSH
6577: LD_INT 1
6579: PPUSH
6580: CALL_OW 55
// Wait ( Rand ( 0 0$43 , 1 1$00 ) ) ;
6584: LD_INT 1505
6586: PPUSH
6587: LD_INT 2100
6589: PPUSH
6590: CALL_OW 12
6594: PPUSH
6595: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crates , true ) ;
6599: LD_INT 1
6601: PPUSH
6602: LD_INT 5
6604: PPUSH
6605: CALL_OW 12
6609: PPUSH
6610: LD_INT 11
6612: PPUSH
6613: LD_INT 1
6615: PPUSH
6616: CALL_OW 55
// end ;
6620: END
// every 20 20$00 trigger ru_sib_bomb = false do var i , tmp ;
6621: LD_EXP 4
6625: PUSH
6626: LD_INT 0
6628: EQUAL
6629: IFFALSE 6744
6631: GO 6633
6633: DISABLE
6634: LD_INT 0
6636: PPUSH
6637: PPUSH
// begin enable ;
6638: ENABLE
// i := Rand ( 0 , 100 ) ;
6639: LD_ADDR_VAR 0 1
6643: PUSH
6644: LD_INT 0
6646: PPUSH
6647: LD_INT 100
6649: PPUSH
6650: CALL_OW 12
6654: ST_TO_ADDR
// case your_side of 1 :
6655: LD_OWVAR 2
6659: PUSH
6660: LD_INT 1
6662: DOUBLE
6663: EQUAL
6664: IFTRUE 6668
6666: GO 6679
6668: POP
// tmp := 10 ; 2 :
6669: LD_ADDR_VAR 0 2
6673: PUSH
6674: LD_INT 10
6676: ST_TO_ADDR
6677: GO 6718
6679: LD_INT 2
6681: DOUBLE
6682: EQUAL
6683: IFTRUE 6687
6685: GO 6698
6687: POP
// tmp := 0 ; 7 :
6688: LD_ADDR_VAR 0 2
6692: PUSH
6693: LD_INT 0
6695: ST_TO_ADDR
6696: GO 6718
6698: LD_INT 7
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6717
6706: POP
// tmp := 15 ; end ;
6707: LD_ADDR_VAR 0 2
6711: PUSH
6712: LD_INT 15
6714: ST_TO_ADDR
6715: GO 6718
6717: POP
// if i < chance_to_bomb + tmp then
6718: LD_VAR 0 1
6722: PUSH
6723: LD_EXP 5
6727: PUSH
6728: LD_VAR 0 2
6732: PLUS
6733: LESS
6734: IFFALSE 6744
// ru_sib_bomb := true ;
6736: LD_ADDR_EXP 4
6740: PUSH
6741: LD_INT 1
6743: ST_TO_ADDR
// end ;
6744: PPOPN 2
6746: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_weapon , us_siberium_rocket ] ] ) do
6747: LD_INT 22
6749: PUSH
6750: LD_OWVAR 2
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 34
6761: PUSH
6762: LD_INT 8
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: IFFALSE 6790
6779: GO 6781
6781: DISABLE
// begin ru_sib_bomb := true ;
6782: LD_ADDR_EXP 4
6786: PUSH
6787: LD_INT 1
6789: ST_TO_ADDR
// end ;
6790: END
// every 15 15$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) do var i ;
6791: LD_INT 22
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: EMPTY
6798: LIST
6799: LIST
6800: PUSH
6801: LD_INT 30
6803: PUSH
6804: LD_INT 34
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 69
6819: IFFALSE 6918
6821: GO 6823
6823: DISABLE
6824: LD_INT 0
6826: PPUSH
// begin enable ;
6827: ENABLE
// i := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 1
6835: PUSH
6836: LD_INT 3
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 1
6845: PPUSH
6846: LD_INT 2
6848: PPUSH
6849: CALL_OW 12
6853: ARRAY
6854: ST_TO_ADDR
// TeleportExit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) [ 1 ] , ru_teleport_exit [ i ] , ru_teleport_exit [ i + 1 ] ) ;
6855: LD_INT 22
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 30
6867: PUSH
6868: LD_INT 34
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PUSH
6884: LD_INT 1
6886: ARRAY
6887: PPUSH
6888: LD_EXP 30
6892: PUSH
6893: LD_VAR 0 1
6897: ARRAY
6898: PPUSH
6899: LD_EXP 30
6903: PUSH
6904: LD_VAR 0 1
6908: PUSH
6909: LD_INT 1
6911: PLUS
6912: ARRAY
6913: PPUSH
6914: CALL_OW 243
// end ; end_of_file
6918: PPOPN 1
6920: END
// export function RemoveLegion ; var i ; begin
6921: LD_INT 0
6923: PPUSH
6924: PPUSH
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: LD_INT 22
6932: PUSH
6933: LD_INT 8
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PPUSH
6940: CALL_OW 69
6944: PUSH
6945: FOR_IN
6946: IFFALSE 6959
// RemoveUnit ( i ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: CALL_OW 64
6957: GO 6945
6959: POP
6960: POP
// end ;
6961: LD_VAR 0 1
6965: RET
// export legion_force , legion_skill , legion_mines , legion_blist , legion_vlist , legion_enemy ; export function PrepareLegion ; var un , i , tmp , veh , p , l_depot , l_factory , l_lab , l_towers ; begin
6966: LD_INT 0
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
6976: PPUSH
6977: PPUSH
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
6978: LD_ADDR_VAR 0 7
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 8
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 30
6995: PUSH
6996: LD_INT 1
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: LD_INT 1
7014: ARRAY
7015: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
7016: LD_ADDR_VAR 0 8
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_INT 8
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 30
7033: PUSH
7034: LD_INT 3
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: LD_INT 1
7052: ARRAY
7053: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
7054: LD_ADDR_VAR 0 9
7058: PUSH
7059: LD_INT 22
7061: PUSH
7062: LD_INT 8
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PUSH
7069: LD_INT 2
7071: PUSH
7072: LD_INT 30
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 30
7084: PUSH
7085: LD_INT 8
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PPUSH
7101: CALL_OW 69
7105: PUSH
7106: LD_INT 1
7108: ARRAY
7109: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
7110: LD_ADDR_VAR 0 10
7114: PUSH
7115: LD_INT 22
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 30
7127: PUSH
7128: LD_INT 32
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: ST_TO_ADDR
// uc_side := 8 ;
7144: LD_ADDR_OWVAR 20
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// uc_nation := nation_arabian ;
7152: LD_ADDR_OWVAR 21
7156: PUSH
7157: LD_INT 2
7159: ST_TO_ADDR
// legion_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7160: LD_ADDR_EXP 32
7164: PUSH
7165: LD_INT 5
7167: PUSH
7168: LD_INT 6
7170: PUSH
7171: LD_INT 7
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: LIST
7178: PUSH
7179: LD_OWVAR 67
7183: ARRAY
7184: ST_TO_ADDR
// legion_blist := [ ] ;
7185: LD_ADDR_EXP 34
7189: PUSH
7190: EMPTY
7191: ST_TO_ADDR
// legion_vlist := [ ] ;
7192: LD_ADDR_EXP 35
7196: PUSH
7197: EMPTY
7198: ST_TO_ADDR
// legion_force := [ ] ;
7199: LD_ADDR_EXP 31
7203: PUSH
7204: EMPTY
7205: ST_TO_ADDR
// legion_enemy := - 1 ;
7206: LD_ADDR_EXP 36
7210: PUSH
7211: LD_INT 1
7213: NEG
7214: ST_TO_ADDR
// SetResourceType ( GetBase ( l_depot ) , mat_cans , 10000 ) ;
7215: LD_VAR 0 7
7219: PPUSH
7220: CALL_OW 274
7224: PPUSH
7225: LD_INT 1
7227: PPUSH
7228: LD_INT 10000
7230: PPUSH
7231: CALL_OW 277
// SetResourceType ( GetBase ( l_depot ) , 3 , 1000 ) ;
7235: LD_VAR 0 7
7239: PPUSH
7240: CALL_OW 274
7244: PPUSH
7245: LD_INT 3
7247: PPUSH
7248: LD_INT 1000
7250: PPUSH
7251: CALL_OW 277
// for i = 1 to l_towers do
7255: LD_ADDR_VAR 0 3
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_VAR 0 10
7269: PUSH
7270: FOR_TO
7271: IFFALSE 7320
// begin PrepareHuman ( false , 1 , legion_skill ) ;
7273: LD_INT 0
7275: PPUSH
7276: LD_INT 1
7278: PPUSH
7279: LD_EXP 32
7283: PPUSH
7284: CALL_OW 380
// un := CreateHuman ;
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: CALL_OW 44
7297: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_towers [ i ] ) ;
7298: LD_VAR 0 2
7302: PPUSH
7303: LD_VAR 0 10
7307: PUSH
7308: LD_VAR 0 3
7312: ARRAY
7313: PPUSH
7314: CALL_OW 52
// end ;
7318: GO 7270
7320: POP
7321: POP
// for i = 1 to 4 do
7322: LD_ADDR_VAR 0 3
7326: PUSH
7327: DOUBLE
7328: LD_INT 1
7330: DEC
7331: ST_TO_ADDR
7332: LD_INT 4
7334: PUSH
7335: FOR_TO
7336: IFFALSE 7429
// for p = 1 to 2 do
7338: LD_ADDR_VAR 0 6
7342: PUSH
7343: DOUBLE
7344: LD_INT 1
7346: DEC
7347: ST_TO_ADDR
7348: LD_INT 2
7350: PUSH
7351: FOR_TO
7352: IFFALSE 7425
// begin PrepareHuman ( false , class_mortar , legion_skill ) ;
7354: LD_INT 0
7356: PPUSH
7357: LD_INT 8
7359: PPUSH
7360: LD_EXP 32
7364: PPUSH
7365: CALL_OW 380
// un := CreateHuman ;
7369: LD_ADDR_VAR 0 2
7373: PUSH
7374: CALL_OW 44
7378: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
7379: LD_VAR 0 2
7383: PPUSH
7384: LD_INT 22
7386: PUSH
7387: LD_INT 8
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 30
7396: PUSH
7397: LD_INT 5
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: PUSH
7413: LD_VAR 0 6
7417: ARRAY
7418: PPUSH
7419: CALL_OW 52
// end ;
7423: GO 7351
7425: POP
7426: POP
7427: GO 7335
7429: POP
7430: POP
// for i = 1 to 4 do
7431: LD_ADDR_VAR 0 3
7435: PUSH
7436: DOUBLE
7437: LD_INT 1
7439: DEC
7440: ST_TO_ADDR
7441: LD_INT 4
7443: PUSH
7444: FOR_TO
7445: IFFALSE 7488
// begin PrepareHuman ( false , 4 , legion_skill ) ;
7447: LD_INT 0
7449: PPUSH
7450: LD_INT 4
7452: PPUSH
7453: LD_EXP 32
7457: PPUSH
7458: CALL_OW 380
// un := CreateHuman ;
7462: LD_ADDR_VAR 0 2
7466: PUSH
7467: CALL_OW 44
7471: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_lab ) ;
7472: LD_VAR 0 2
7476: PPUSH
7477: LD_VAR 0 9
7481: PPUSH
7482: CALL_OW 52
// end ;
7486: GO 7444
7488: POP
7489: POP
// for i = 1 to 6 do
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: DOUBLE
7496: LD_INT 1
7498: DEC
7499: ST_TO_ADDR
7500: LD_INT 6
7502: PUSH
7503: FOR_TO
7504: IFFALSE 7547
// begin PrepareHuman ( false , 3 , legion_skill ) ;
7506: LD_INT 0
7508: PPUSH
7509: LD_INT 3
7511: PPUSH
7512: LD_EXP 32
7516: PPUSH
7517: CALL_OW 380
// un := CreateHuman ;
7521: LD_ADDR_VAR 0 2
7525: PUSH
7526: CALL_OW 44
7530: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_factory ) ;
7531: LD_VAR 0 2
7535: PPUSH
7536: LD_VAR 0 8
7540: PPUSH
7541: CALL_OW 52
// end ;
7545: GO 7503
7547: POP
7548: POP
// for i = 1 to 5 do
7549: LD_ADDR_VAR 0 3
7553: PUSH
7554: DOUBLE
7555: LD_INT 1
7557: DEC
7558: ST_TO_ADDR
7559: LD_INT 5
7561: PUSH
7562: FOR_TO
7563: IFFALSE 7606
// begin PrepareHuman ( false , 2 , legion_skill ) ;
7565: LD_INT 0
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: LD_EXP 32
7575: PPUSH
7576: CALL_OW 380
// un := CreateHuman ;
7580: LD_ADDR_VAR 0 2
7584: PUSH
7585: CALL_OW 44
7589: ST_TO_ADDR
// PlaceHumanInUnit ( un , l_depot ) ;
7590: LD_VAR 0 2
7594: PPUSH
7595: LD_VAR 0 7
7599: PPUSH
7600: CALL_OW 52
// end ;
7604: GO 7562
7606: POP
7607: POP
// tmp := RandPointsFromArea ( 199 , 134 , 216 , 141 , 6 ) ;
7608: LD_ADDR_VAR 0 4
7612: PUSH
7613: LD_INT 199
7615: PPUSH
7616: LD_INT 134
7618: PPUSH
7619: LD_INT 216
7621: PPUSH
7622: LD_INT 141
7624: PPUSH
7625: LD_INT 6
7627: PPUSH
7628: CALL 1555 0 5
7632: ST_TO_ADDR
// p := 1 ;
7633: LD_ADDR_VAR 0 6
7637: PUSH
7638: LD_INT 1
7640: ST_TO_ADDR
// for i = 1 to 3 do
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: DOUBLE
7647: LD_INT 1
7649: DEC
7650: ST_TO_ADDR
7651: LD_INT 3
7653: PUSH
7654: FOR_TO
7655: IFFALSE 7908
// begin vc_chassis := ar_half_tracked ;
7657: LD_ADDR_OWVAR 37
7661: PUSH
7662: LD_INT 14
7664: ST_TO_ADDR
// vc_engine := engine_siberite ;
7665: LD_ADDR_OWVAR 39
7669: PUSH
7670: LD_INT 3
7672: ST_TO_ADDR
// vc_control := control_manual ;
7673: LD_ADDR_OWVAR 38
7677: PUSH
7678: LD_INT 1
7680: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
7681: LD_ADDR_OWVAR 40
7685: PUSH
7686: LD_INT 31
7688: ST_TO_ADDR
// veh := CreateVehicle ;
7689: LD_ADDR_VAR 0 5
7693: PUSH
7694: CALL_OW 45
7698: ST_TO_ADDR
// if HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 then
7699: LD_VAR 0 4
7703: PUSH
7704: LD_VAR 0 6
7708: ARRAY
7709: PPUSH
7710: LD_VAR 0 4
7714: PUSH
7715: LD_VAR 0 6
7719: PUSH
7720: LD_INT 1
7722: PLUS
7723: ARRAY
7724: PPUSH
7725: CALL_OW 428
7729: PUSH
7730: LD_INT 0
7732: EQUAL
7733: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) else
7735: LD_VAR 0 5
7739: PPUSH
7740: LD_VAR 0 4
7744: PUSH
7745: LD_VAR 0 6
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 6
7760: PUSH
7761: LD_INT 1
7763: PLUS
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 48
7773: GO 7863
// begin repeat p := p + 2 ;
7775: LD_ADDR_VAR 0 6
7779: PUSH
7780: LD_VAR 0 6
7784: PUSH
7785: LD_INT 2
7787: PLUS
7788: ST_TO_ADDR
// until HexInfo ( tmp [ p ] , tmp [ p + 1 ] ) = 0 ;
7789: LD_VAR 0 4
7793: PUSH
7794: LD_VAR 0 6
7798: ARRAY
7799: PPUSH
7800: LD_VAR 0 4
7804: PUSH
7805: LD_VAR 0 6
7809: PUSH
7810: LD_INT 1
7812: PLUS
7813: ARRAY
7814: PPUSH
7815: CALL_OW 428
7819: PUSH
7820: LD_INT 0
7822: EQUAL
7823: IFFALSE 7775
// PlaceUnitXY ( veh , tmp [ p ] , tmp [ p + 1 ] , false ) ;
7825: LD_VAR 0 5
7829: PPUSH
7830: LD_VAR 0 4
7834: PUSH
7835: LD_VAR 0 6
7839: ARRAY
7840: PPUSH
7841: LD_VAR 0 4
7845: PUSH
7846: LD_VAR 0 6
7850: PUSH
7851: LD_INT 1
7853: PLUS
7854: ARRAY
7855: PPUSH
7856: LD_INT 0
7858: PPUSH
7859: CALL_OW 48
// end ; PrepareHuman ( false , 3 , legion_skill + 1 ) ;
7863: LD_INT 0
7865: PPUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_EXP 32
7873: PUSH
7874: LD_INT 1
7876: PLUS
7877: PPUSH
7878: CALL_OW 380
// un := CreateHuman ;
7882: LD_ADDR_VAR 0 2
7886: PUSH
7887: CALL_OW 44
7891: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7892: LD_VAR 0 2
7896: PPUSH
7897: LD_VAR 0 5
7901: PPUSH
7902: CALL_OW 52
// end ;
7906: GO 7654
7908: POP
7909: POP
// PlaceSeeing ( 198 , 94 , 8 , 10 ) ;
7910: LD_INT 198
7912: PPUSH
7913: LD_INT 94
7915: PPUSH
7916: LD_INT 8
7918: PPUSH
7919: LD_INT 10
7921: PPUSH
7922: CALL_OW 330
// PlaceSeeing ( 167 , 130 , 8 , 10 ) ;
7926: LD_INT 167
7928: PPUSH
7929: LD_INT 130
7931: PPUSH
7932: LD_INT 8
7934: PPUSH
7935: LD_INT 10
7937: PPUSH
7938: CALL_OW 330
// legion_mines := [ ] ;
7942: LD_ADDR_EXP 33
7946: PUSH
7947: EMPTY
7948: ST_TO_ADDR
// legion_mines := RandPointsFromArea ( 176 , 122 , 188 , 126 , 6 ) ;
7949: LD_ADDR_EXP 33
7953: PUSH
7954: LD_INT 176
7956: PPUSH
7957: LD_INT 122
7959: PPUSH
7960: LD_INT 188
7962: PPUSH
7963: LD_INT 126
7965: PPUSH
7966: LD_INT 6
7968: PPUSH
7969: CALL 1555 0 5
7973: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 197 , 91 , 205 , 96 , 4 ) ;
7974: LD_ADDR_EXP 33
7978: PUSH
7979: LD_EXP 33
7983: PUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 91
7989: PPUSH
7990: LD_INT 205
7992: PPUSH
7993: LD_INT 96
7995: PPUSH
7996: LD_INT 4
7998: PPUSH
7999: CALL 1555 0 5
8003: ADD
8004: ST_TO_ADDR
// legion_mines := legion_mines ^ RandPointsFromArea ( 184 , 151 , 178 , 130 , 9 ) ;
8005: LD_ADDR_EXP 33
8009: PUSH
8010: LD_EXP 33
8014: PUSH
8015: LD_INT 184
8017: PPUSH
8018: LD_INT 151
8020: PPUSH
8021: LD_INT 178
8023: PPUSH
8024: LD_INT 130
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL 1555 0 5
8034: ADD
8035: ST_TO_ADDR
// if Difficulty > 1 then
8036: LD_OWVAR 67
8040: PUSH
8041: LD_INT 1
8043: GREATER
8044: IFFALSE 8077
// legion_mines := legion_mines ^ RandPointsFromArea ( 166 , 126 , 181 , 136 , 5 ) ;
8046: LD_ADDR_EXP 33
8050: PUSH
8051: LD_EXP 33
8055: PUSH
8056: LD_INT 166
8058: PPUSH
8059: LD_INT 126
8061: PPUSH
8062: LD_INT 181
8064: PPUSH
8065: LD_INT 136
8067: PPUSH
8068: LD_INT 5
8070: PPUSH
8071: CALL 1555 0 5
8075: ADD
8076: ST_TO_ADDR
// p := 1 ;
8077: LD_ADDR_VAR 0 6
8081: PUSH
8082: LD_INT 1
8084: ST_TO_ADDR
// for i = 1 to 24 do
8085: LD_ADDR_VAR 0 3
8089: PUSH
8090: DOUBLE
8091: LD_INT 1
8093: DEC
8094: ST_TO_ADDR
8095: LD_INT 24
8097: PUSH
8098: FOR_TO
8099: IFFALSE 8153
// begin PlaceMine ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 , 0 ) ;
8101: LD_EXP 33
8105: PUSH
8106: LD_VAR 0 6
8110: ARRAY
8111: PPUSH
8112: LD_EXP 33
8116: PUSH
8117: LD_VAR 0 6
8121: PUSH
8122: LD_INT 1
8124: PLUS
8125: ARRAY
8126: PPUSH
8127: LD_INT 8
8129: PPUSH
8130: LD_INT 0
8132: PPUSH
8133: CALL_OW 454
// p := p + 2 ;
8137: LD_ADDR_VAR 0 6
8141: PUSH
8142: LD_VAR 0 6
8146: PUSH
8147: LD_INT 2
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: GO 8098
8153: POP
8154: POP
// legion_vlist := [ ar_medium_trike , 3 , control_remote , ar_cargo_bay ] ;
8155: LD_ADDR_EXP 35
8159: PUSH
8160: LD_INT 13
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: LD_INT 2
8168: PUSH
8169: LD_INT 32
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: ST_TO_ADDR
// end ;
8178: LD_VAR 0 1
8182: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 8 ] ) > 0 do var un , i , tmp , veh , b , p , cr , l_depot , l_factory , l_lab , l_towers , l_sib , l_sci , l_mech , l_sold , l_eng , l_cargo ;
8183: LD_INT 22
8185: PUSH
8186: LD_INT 8
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PPUSH
8193: CALL_OW 69
8197: PUSH
8198: LD_INT 0
8200: GREATER
8201: IFFALSE 10435
8203: GO 8205
8205: DISABLE
8206: LD_INT 0
8208: PPUSH
8209: PPUSH
8210: PPUSH
8211: PPUSH
8212: PPUSH
8213: PPUSH
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
8218: PPUSH
8219: PPUSH
8220: PPUSH
8221: PPUSH
8222: PPUSH
8223: PPUSH
8224: PPUSH
// begin enable ;
8225: ENABLE
// l_depot := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
8226: LD_ADDR_VAR 0 8
8230: PUSH
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 30
8243: PUSH
8244: LD_INT 1
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PPUSH
8255: CALL_OW 69
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: ST_TO_ADDR
// l_factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
8264: LD_ADDR_VAR 0 9
8268: PUSH
8269: LD_INT 22
8271: PUSH
8272: LD_INT 8
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 30
8281: PUSH
8282: LD_INT 3
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: PPUSH
8293: CALL_OW 69
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: ST_TO_ADDR
// l_lab := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
8302: LD_ADDR_VAR 0 10
8306: PUSH
8307: LD_INT 22
8309: PUSH
8310: LD_INT 8
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 2
8319: PUSH
8320: LD_INT 30
8322: PUSH
8323: LD_INT 6
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: LD_INT 30
8332: PUSH
8333: LD_INT 8
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PPUSH
8349: CALL_OW 69
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: ST_TO_ADDR
// l_towers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) ;
8358: LD_ADDR_VAR 0 11
8362: PUSH
8363: LD_INT 22
8365: PUSH
8366: LD_INT 8
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: PUSH
8373: LD_INT 30
8375: PUSH
8376: LD_INT 32
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: PUSH
8383: EMPTY
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: ST_TO_ADDR
// l_eng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
8392: LD_ADDR_VAR 0 16
8396: PUSH
8397: LD_INT 22
8399: PUSH
8400: LD_INT 8
8402: PUSH
8403: EMPTY
8404: LIST
8405: LIST
8406: PUSH
8407: LD_INT 25
8409: PUSH
8410: LD_INT 2
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PPUSH
8421: CALL_OW 69
8425: ST_TO_ADDR
// l_sold := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 1 ] ] ) ;
8426: LD_ADDR_VAR 0 15
8430: PUSH
8431: LD_INT 22
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: PUSH
8441: LD_INT 25
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PPUSH
8455: CALL_OW 69
8459: ST_TO_ADDR
// l_mech := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 3 ] ] ) ;
8460: LD_ADDR_VAR 0 14
8464: PUSH
8465: LD_INT 22
8467: PUSH
8468: LD_INT 8
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: LD_INT 25
8477: PUSH
8478: LD_INT 3
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: ST_TO_ADDR
// l_sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
8494: LD_ADDR_VAR 0 13
8498: PUSH
8499: LD_INT 22
8501: PUSH
8502: LD_INT 8
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 25
8511: PUSH
8512: LD_INT 4
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: ST_TO_ADDR
// if l_eng then
8528: LD_VAR 0 16
8532: IFFALSE 8947
// begin b := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) ;
8534: LD_ADDR_VAR 0 5
8538: PUSH
8539: LD_INT 22
8541: PUSH
8542: LD_INT 8
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 21
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PPUSH
8563: CALL_OW 69
8567: ST_TO_ADDR
// if UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) > 0 then
8568: LD_VAR 0 5
8572: PPUSH
8573: LD_INT 3
8575: PUSH
8576: LD_INT 24
8578: PUSH
8579: LD_INT 1000
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PPUSH
8590: CALL_OW 72
8594: PUSH
8595: LD_INT 0
8597: GREATER
8598: IFFALSE 8732
// begin tmp := UnitFilter ( b , [ f_not , [ f_lives , 1000 ] ] ) ;
8600: LD_ADDR_VAR 0 3
8604: PUSH
8605: LD_VAR 0 5
8609: PPUSH
8610: LD_INT 3
8612: PUSH
8613: LD_INT 24
8615: PUSH
8616: LD_INT 1000
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PPUSH
8627: CALL_OW 72
8631: ST_TO_ADDR
// for i = 1 to l_eng do
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: DOUBLE
8638: LD_INT 1
8640: DEC
8641: ST_TO_ADDR
8642: LD_VAR 0 16
8646: PUSH
8647: FOR_TO
8648: IFFALSE 8728
// if IsInUnit ( l_eng [ i ] ) then
8650: LD_VAR 0 16
8654: PUSH
8655: LD_VAR 0 2
8659: ARRAY
8660: PPUSH
8661: CALL_OW 310
8665: IFFALSE 8684
// ComExitBuilding ( l_eng [ i ] ) else
8667: LD_VAR 0 16
8671: PUSH
8672: LD_VAR 0 2
8676: ARRAY
8677: PPUSH
8678: CALL_OW 122
8682: GO 8726
// if not HasTask ( l_eng [ i ] ) then
8684: LD_VAR 0 16
8688: PUSH
8689: LD_VAR 0 2
8693: ARRAY
8694: PPUSH
8695: CALL_OW 314
8699: NOT
8700: IFFALSE 8726
// ComRepairBuilding ( l_eng [ i ] , tmp [ 1 ] ) ;
8702: LD_VAR 0 16
8706: PUSH
8707: LD_VAR 0 2
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 3
8717: PUSH
8718: LD_INT 1
8720: ARRAY
8721: PPUSH
8722: CALL_OW 130
8726: GO 8647
8728: POP
8729: POP
// end else
8730: GO 8947
// begin if legion_blist > 0 then
8732: LD_EXP 34
8736: PUSH
8737: LD_INT 0
8739: GREATER
8740: IFFALSE 8869
// begin for i = 1 to l_eng do
8742: LD_ADDR_VAR 0 2
8746: PUSH
8747: DOUBLE
8748: LD_INT 1
8750: DEC
8751: ST_TO_ADDR
8752: LD_VAR 0 16
8756: PUSH
8757: FOR_TO
8758: IFFALSE 8865
// if IsInUnit ( l_eng [ i ] ) then
8760: LD_VAR 0 16
8764: PUSH
8765: LD_VAR 0 2
8769: ARRAY
8770: PPUSH
8771: CALL_OW 310
8775: IFFALSE 8794
// ComExitBuilding ( l_eng [ i ] ) else
8777: LD_VAR 0 16
8781: PUSH
8782: LD_VAR 0 2
8786: ARRAY
8787: PPUSH
8788: CALL_OW 122
8792: GO 8863
// if not HasTask ( l_eng [ i ] ) then
8794: LD_VAR 0 16
8798: PUSH
8799: LD_VAR 0 2
8803: ARRAY
8804: PPUSH
8805: CALL_OW 314
8809: NOT
8810: IFFALSE 8863
// ComBuild ( l_eng [ i ] , legion_blist [ 1 ] , legion_blist [ 2 ] , legion_blist [ 3 ] , legion_blist [ 4 ] ) ;
8812: LD_VAR 0 16
8816: PUSH
8817: LD_VAR 0 2
8821: ARRAY
8822: PPUSH
8823: LD_EXP 34
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PPUSH
8832: LD_EXP 34
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PPUSH
8841: LD_EXP 34
8845: PUSH
8846: LD_INT 3
8848: ARRAY
8849: PPUSH
8850: LD_EXP 34
8854: PUSH
8855: LD_INT 4
8857: ARRAY
8858: PPUSH
8859: CALL_OW 145
8863: GO 8757
8865: POP
8866: POP
// end else
8867: GO 8947
// for i = 1 to l_eng do
8869: LD_ADDR_VAR 0 2
8873: PUSH
8874: DOUBLE
8875: LD_INT 1
8877: DEC
8878: ST_TO_ADDR
8879: LD_VAR 0 16
8883: PUSH
8884: FOR_TO
8885: IFFALSE 8945
// if not IsInUnit ( l_eng [ i ] ) and not HasTask ( l_eng [ i ] ) then
8887: LD_VAR 0 16
8891: PUSH
8892: LD_VAR 0 2
8896: ARRAY
8897: PPUSH
8898: CALL_OW 310
8902: NOT
8903: PUSH
8904: LD_VAR 0 16
8908: PUSH
8909: LD_VAR 0 2
8913: ARRAY
8914: PPUSH
8915: CALL_OW 314
8919: NOT
8920: AND
8921: IFFALSE 8943
// ComEnterUnit ( l_eng [ i ] , l_depot ) ;
8923: LD_VAR 0 16
8927: PUSH
8928: LD_VAR 0 2
8932: ARRAY
8933: PPUSH
8934: LD_VAR 0 8
8938: PPUSH
8939: CALL_OW 120
8943: GO 8884
8945: POP
8946: POP
// end ; end ; if l_factory then
8947: LD_VAR 0 9
8951: IFFALSE 9351
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) > 0 then
8953: LD_INT 22
8955: PUSH
8956: LD_INT 8
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: LD_INT 33
8965: PUSH
8966: LD_INT 2
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 3
8975: PUSH
8976: LD_INT 61
8978: PUSH
8979: EMPTY
8980: LIST
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: LIST
8990: PPUSH
8991: CALL_OW 69
8995: PUSH
8996: LD_INT 0
8998: GREATER
8999: PUSH
9000: LD_INT 22
9002: PUSH
9003: LD_INT 8
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: LD_INT 34
9012: PUSH
9013: LD_INT 31
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 69
9028: PUSH
9029: LD_INT 0
9031: GREATER
9032: AND
9033: IFFALSE 9153
// ComLinkTo ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) [ 1 ] , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) [ Rand ( 1 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ) ] ) ;
9035: LD_INT 22
9037: PUSH
9038: LD_INT 8
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: LD_INT 33
9047: PUSH
9048: LD_INT 2
9050: PUSH
9051: EMPTY
9052: LIST
9053: LIST
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: LD_INT 61
9060: PUSH
9061: EMPTY
9062: LIST
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: PPUSH
9073: CALL_OW 69
9077: PUSH
9078: LD_INT 1
9080: ARRAY
9081: PPUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 8
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 34
9094: PUSH
9095: LD_INT 31
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL_OW 69
9110: PUSH
9111: LD_INT 1
9113: PPUSH
9114: LD_INT 22
9116: PUSH
9117: LD_INT 8
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 34
9126: PUSH
9127: LD_INT 31
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PPUSH
9143: CALL_OW 12
9147: ARRAY
9148: PPUSH
9149: CALL_OW 135
// if legion_vlist > 0 and BuildingStatus ( l_factory ) = bs_idle then
9153: LD_EXP 35
9157: PUSH
9158: LD_INT 0
9160: GREATER
9161: PUSH
9162: LD_VAR 0 9
9166: PPUSH
9167: CALL_OW 461
9171: PUSH
9172: LD_INT 2
9174: EQUAL
9175: AND
9176: IFFALSE 9261
// begin ComConstruct ( l_factory , legion_vlist [ 1 ] , legion_vlist [ 2 ] , legion_vlist [ 3 ] , legion_vlist [ 4 ] ) ;
9178: LD_VAR 0 9
9182: PPUSH
9183: LD_EXP 35
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_EXP 35
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: LD_EXP 35
9205: PUSH
9206: LD_INT 3
9208: ARRAY
9209: PPUSH
9210: LD_EXP 35
9214: PUSH
9215: LD_INT 4
9217: ARRAY
9218: PPUSH
9219: CALL_OW 125
// for i = 1 to 4 do
9223: LD_ADDR_VAR 0 2
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 4
9235: PUSH
9236: FOR_TO
9237: IFFALSE 9259
// legion_vlist := Delete ( legion_vlist , 1 ) ;
9239: LD_ADDR_EXP 35
9243: PUSH
9244: LD_EXP 35
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: CALL_OW 3
9256: ST_TO_ADDR
9257: GO 9236
9259: POP
9260: POP
// end ; if UnitFilter ( l_towers , [ f_bweapon , 0 ] ) > 0 and BuildingStatus ( l_factory ) = bs_idle then
9261: LD_VAR 0 11
9265: PPUSH
9266: LD_INT 35
9268: PUSH
9269: LD_INT 0
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PPUSH
9276: CALL_OW 72
9280: PUSH
9281: LD_INT 0
9283: GREATER
9284: PUSH
9285: LD_VAR 0 9
9289: PPUSH
9290: CALL_OW 461
9294: PUSH
9295: LD_INT 2
9297: EQUAL
9298: AND
9299: IFFALSE 9351
// ComPlaceWeapon ( UnitFilter ( l_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ ar_rocket_launcher , ar_gun ] [ Rand ( 1 , 2 ) ] ) ;
9301: LD_VAR 0 11
9305: PPUSH
9306: LD_INT 35
9308: PUSH
9309: LD_INT 0
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PPUSH
9316: CALL_OW 72
9320: PUSH
9321: LD_INT 1
9323: ARRAY
9324: PPUSH
9325: LD_INT 28
9327: PUSH
9328: LD_INT 27
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: CALL_OW 148
// end ; if legion_enemy > 0 then
9351: LD_EXP 36
9355: PUSH
9356: LD_INT 0
9358: GREATER
9359: IFFALSE 9987
// begin if tick mod 14 14$00 = 0 then
9361: LD_OWVAR 1
9365: PUSH
9366: LD_INT 29400
9368: MOD
9369: PUSH
9370: LD_INT 0
9372: EQUAL
9373: IFFALSE 9623
// begin legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9375: LD_ADDR_EXP 35
9379: PUSH
9380: LD_EXP 35
9384: PUSH
9385: LD_INT 13
9387: PUSH
9388: LD_INT 1
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: ADD
9399: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9400: LD_ADDR_EXP 35
9404: PUSH
9405: LD_EXP 35
9409: PUSH
9410: LD_INT 28
9412: PUSH
9413: LD_INT 27
9415: PUSH
9416: LD_INT 29
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: LIST
9423: PUSH
9424: LD_INT 1
9426: PPUSH
9427: LD_INT 3
9429: PPUSH
9430: CALL_OW 12
9434: ARRAY
9435: ADD
9436: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9437: LD_ADDR_EXP 35
9441: PUSH
9442: LD_EXP 35
9446: PUSH
9447: LD_INT 13
9449: PUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 2
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: LIST
9460: ADD
9461: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9462: LD_ADDR_EXP 35
9466: PUSH
9467: LD_EXP 35
9471: PUSH
9472: LD_INT 28
9474: PUSH
9475: LD_INT 27
9477: PUSH
9478: LD_INT 29
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 3
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: ADD
9498: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9499: LD_ADDR_EXP 35
9503: PUSH
9504: LD_EXP 35
9508: PUSH
9509: LD_INT 13
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: LD_INT 2
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: ADD
9523: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9524: LD_ADDR_EXP 35
9528: PUSH
9529: LD_EXP 35
9533: PUSH
9534: LD_INT 28
9536: PUSH
9537: LD_INT 27
9539: PUSH
9540: LD_INT 29
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 1
9550: PPUSH
9551: LD_INT 3
9553: PPUSH
9554: CALL_OW 12
9558: ARRAY
9559: ADD
9560: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_medium_trike , engine_combustion , control_remote ] ;
9561: LD_ADDR_EXP 35
9565: PUSH
9566: LD_EXP 35
9570: PUSH
9571: LD_INT 13
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: ADD
9585: ST_TO_ADDR
// legion_vlist := legion_vlist ^ [ ar_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] [ Rand ( 1 , 3 ) ] ;
9586: LD_ADDR_EXP 35
9590: PUSH
9591: LD_EXP 35
9595: PUSH
9596: LD_INT 28
9598: PUSH
9599: LD_INT 27
9601: PUSH
9602: LD_INT 29
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 3
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: ADD
9622: ST_TO_ADDR
// end ; if legion_force = 7 then
9623: LD_EXP 31
9627: PUSH
9628: LD_INT 7
9630: EQUAL
9631: IFFALSE 9814
// begin for i = 1 to legion_force do
9633: LD_ADDR_VAR 0 2
9637: PUSH
9638: DOUBLE
9639: LD_INT 1
9641: DEC
9642: ST_TO_ADDR
9643: LD_EXP 31
9647: PUSH
9648: FOR_TO
9649: IFFALSE 9812
// begin if not HasTask ( legion_force [ i ] ) and GetTag ( legion_force [ i ] ) <> 11 then
9651: LD_EXP 31
9655: PUSH
9656: LD_VAR 0 2
9660: ARRAY
9661: PPUSH
9662: CALL_OW 314
9666: NOT
9667: PUSH
9668: LD_EXP 31
9672: PUSH
9673: LD_VAR 0 2
9677: ARRAY
9678: PPUSH
9679: CALL_OW 110
9683: PUSH
9684: LD_INT 11
9686: NONEQUAL
9687: AND
9688: IFFALSE 9810
// begin case legion_enemy of 1 :
9690: LD_EXP 36
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9727
9703: POP
// ComMoveXY ( legion_force [ i ] , 142 , 144 ) ; 2 :
9704: LD_EXP 31
9708: PUSH
9709: LD_VAR 0 2
9713: ARRAY
9714: PPUSH
9715: LD_INT 142
9717: PPUSH
9718: LD_INT 144
9720: PPUSH
9721: CALL_OW 111
9725: GO 9792
9727: LD_INT 2
9729: DOUBLE
9730: EQUAL
9731: IFTRUE 9735
9733: GO 9759
9735: POP
// ComMoveXY ( legion_force [ i ] , 101 , 34 ) ; 7 :
9736: LD_EXP 31
9740: PUSH
9741: LD_VAR 0 2
9745: ARRAY
9746: PPUSH
9747: LD_INT 101
9749: PPUSH
9750: LD_INT 34
9752: PPUSH
9753: CALL_OW 111
9757: GO 9792
9759: LD_INT 7
9761: DOUBLE
9762: EQUAL
9763: IFTRUE 9767
9765: GO 9791
9767: POP
// ComMoveXY ( legion_force [ i ] , 173 , 127 ) ; end ;
9768: LD_EXP 31
9772: PUSH
9773: LD_VAR 0 2
9777: ARRAY
9778: PPUSH
9779: LD_INT 173
9781: PPUSH
9782: LD_INT 127
9784: PPUSH
9785: CALL_OW 111
9789: GO 9792
9791: POP
// SetTag ( legion_force [ i ] , 11 ) ;
9792: LD_EXP 31
9796: PUSH
9797: LD_VAR 0 2
9801: ARRAY
9802: PPUSH
9803: LD_INT 11
9805: PPUSH
9806: CALL_OW 109
// end ; end ;
9810: GO 9648
9812: POP
9813: POP
// end ; if UnitFilter ( legion_force , [ f_not , [ f_inarea , legion_base ] ] ) > 0 then
9814: LD_EXP 31
9818: PPUSH
9819: LD_INT 3
9821: PUSH
9822: LD_INT 95
9824: PUSH
9825: LD_INT 18
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: CALL_OW 72
9840: PUSH
9841: LD_INT 0
9843: GREATER
9844: IFFALSE 9987
// begin tmp := UnitFilter ( legion_force , [ f_not , [ f_inarea , legion_base ] ] ) ;
9846: LD_ADDR_VAR 0 3
9850: PUSH
9851: LD_EXP 31
9855: PPUSH
9856: LD_INT 3
9858: PUSH
9859: LD_INT 95
9861: PUSH
9862: LD_INT 18
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PPUSH
9873: CALL_OW 72
9877: ST_TO_ADDR
// for i = 1 to tmp do
9878: LD_ADDR_VAR 0 2
9882: PUSH
9883: DOUBLE
9884: LD_INT 1
9886: DEC
9887: ST_TO_ADDR
9888: LD_VAR 0 3
9892: PUSH
9893: FOR_TO
9894: IFFALSE 9985
// if not HasTask ( tmp [ i ] ) and GetTag ( legion_force [ i ] ) = 11 then
9896: LD_VAR 0 3
9900: PUSH
9901: LD_VAR 0 2
9905: ARRAY
9906: PPUSH
9907: CALL_OW 314
9911: NOT
9912: PUSH
9913: LD_EXP 31
9917: PUSH
9918: LD_VAR 0 2
9922: ARRAY
9923: PPUSH
9924: CALL_OW 110
9928: PUSH
9929: LD_INT 11
9931: EQUAL
9932: AND
9933: IFFALSE 9983
// ComAttackUnit ( tmp [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , legion_enemy ] ) , tmp [ i ] ) ) ;
9935: LD_VAR 0 3
9939: PUSH
9940: LD_VAR 0 2
9944: ARRAY
9945: PPUSH
9946: LD_INT 22
9948: PUSH
9949: LD_EXP 36
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: PPUSH
9963: LD_VAR 0 3
9967: PUSH
9968: LD_VAR 0 2
9972: ARRAY
9973: PPUSH
9974: CALL_OW 74
9978: PPUSH
9979: CALL_OW 115
9983: GO 9893
9985: POP
9986: POP
// end ; end ; p := 1 ;
9987: LD_ADDR_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ST_TO_ADDR
// for i = 1 to 24 do
9995: LD_ADDR_VAR 0 2
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_INT 24
10007: PUSH
10008: FOR_TO
10009: IFFALSE 10139
// begin if HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) > 0 then
10011: LD_EXP 33
10015: PUSH
10016: LD_VAR 0 6
10020: ARRAY
10021: PPUSH
10022: LD_EXP 33
10026: PUSH
10027: LD_VAR 0 6
10031: PUSH
10032: LD_INT 1
10034: PLUS
10035: ARRAY
10036: PPUSH
10037: CALL_OW 428
10041: PUSH
10042: LD_INT 0
10044: GREATER
10045: IFFALSE 10123
// if GetSide ( HexInfo ( legion_mines [ p ] , legion_mines [ p + 1 ] ) ) = legion_enemy then
10047: LD_EXP 33
10051: PUSH
10052: LD_VAR 0 6
10056: ARRAY
10057: PPUSH
10058: LD_EXP 33
10062: PUSH
10063: LD_VAR 0 6
10067: PUSH
10068: LD_INT 1
10070: PLUS
10071: ARRAY
10072: PPUSH
10073: CALL_OW 428
10077: PPUSH
10078: CALL_OW 255
10082: PUSH
10083: LD_EXP 36
10087: EQUAL
10088: IFFALSE 10123
// LaunchMineAtPos ( legion_mines [ p ] , legion_mines [ p + 1 ] , 8 ) ;
10090: LD_EXP 33
10094: PUSH
10095: LD_VAR 0 6
10099: ARRAY
10100: PPUSH
10101: LD_EXP 33
10105: PUSH
10106: LD_VAR 0 6
10110: PUSH
10111: LD_INT 1
10113: PLUS
10114: ARRAY
10115: PPUSH
10116: LD_INT 8
10118: PPUSH
10119: CALL_OW 456
// p := p + 2 ;
10123: LD_ADDR_VAR 0 6
10127: PUSH
10128: LD_VAR 0 6
10132: PUSH
10133: LD_INT 2
10135: PLUS
10136: ST_TO_ADDR
// end ;
10137: GO 10008
10139: POP
10140: POP
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) then
10141: LD_INT 22
10143: PUSH
10144: LD_INT 8
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 34
10153: PUSH
10154: LD_INT 32
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PPUSH
10165: CALL_OW 69
10169: IFFALSE 10283
// begin if l_cargo = false then
10171: LD_VAR 0 17
10175: PUSH
10176: LD_INT 0
10178: EQUAL
10179: IFFALSE 10215
// l_cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
10181: LD_ADDR_VAR 0 17
10185: PUSH
10186: LD_INT 22
10188: PUSH
10189: LD_INT 8
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PUSH
10196: LD_INT 34
10198: PUSH
10199: LD_INT 32
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PPUSH
10210: CALL_OW 69
10214: ST_TO_ADDR
// if l_cargo then
10215: LD_VAR 0 17
10219: IFFALSE 10283
// begin cr := GetListOfCratesInArea ( legion_crates ) ;
10221: LD_ADDR_VAR 0 7
10225: PUSH
10226: LD_INT 14
10228: PPUSH
10229: CALL_OW 435
10233: ST_TO_ADDR
// if cr > 0 then
10234: LD_VAR 0 7
10238: PUSH
10239: LD_INT 0
10241: GREATER
10242: IFFALSE 10283
// if not HasTask ( l_cargo ) then
10244: LD_VAR 0 17
10248: PPUSH
10249: CALL_OW 314
10253: NOT
10254: IFFALSE 10283
// ComCollect ( l_cargo , cr [ 1 ] , cr [ 2 ] ) ;
10256: LD_VAR 0 17
10260: PPUSH
10261: LD_VAR 0 7
10265: PUSH
10266: LD_INT 1
10268: ARRAY
10269: PPUSH
10270: LD_VAR 0 7
10274: PUSH
10275: LD_INT 2
10277: ARRAY
10278: PPUSH
10279: CALL_OW 117
// end ; end ; if tick = [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] and FindArtifact ( 1 ) [ 1 ] = 112 and FindArtifact ( 1 ) [ 2 ] = 67 then
10283: LD_OWVAR 1
10287: PUSH
10288: LD_INT 52500
10290: PUSH
10291: LD_INT 46200
10293: PUSH
10294: LD_INT 42000
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: PUSH
10302: LD_OWVAR 67
10306: ARRAY
10307: EQUAL
10308: PUSH
10309: LD_INT 1
10311: PPUSH
10312: CALL_OW 469
10316: PUSH
10317: LD_INT 1
10319: ARRAY
10320: PUSH
10321: LD_INT 112
10323: EQUAL
10324: AND
10325: PUSH
10326: LD_INT 1
10328: PPUSH
10329: CALL_OW 469
10333: PUSH
10334: LD_INT 2
10336: ARRAY
10337: PUSH
10338: LD_INT 67
10340: EQUAL
10341: AND
10342: IFFALSE 10435
// begin un := l_eng [ 1 ] ;
10344: LD_ADDR_VAR 0 1
10348: PUSH
10349: LD_VAR 0 16
10353: PUSH
10354: LD_INT 1
10356: ARRAY
10357: ST_TO_ADDR
// if IsInUnit ( un ) then
10358: LD_VAR 0 1
10362: PPUSH
10363: CALL_OW 310
10367: IFFALSE 10378
// ComExitBuilding ( un ) ;
10369: LD_VAR 0 1
10373: PPUSH
10374: CALL_OW 122
// AddComCollect ( un , FindArtifact ( 1 ) [ 1 ] , FindArtifact ( 1 ) [ 2 ] ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 469
10390: PUSH
10391: LD_INT 1
10393: ARRAY
10394: PPUSH
10395: LD_INT 1
10397: PPUSH
10398: CALL_OW 469
10402: PUSH
10403: LD_INT 2
10405: ARRAY
10406: PPUSH
10407: CALL_OW 177
// AddComMoveXY ( un , 207 , 123 ) ;
10411: LD_VAR 0 1
10415: PPUSH
10416: LD_INT 207
10418: PPUSH
10419: LD_INT 123
10421: PPUSH
10422: CALL_OW 171
// AddComUnload ( un ) ;
10426: LD_VAR 0 1
10430: PPUSH
10431: CALL_OW 219
// end ; end ;
10435: PPOPN 17
10437: END
// every 9 9$00 trigger difficulty > 1 do var i , sci , sib , p ;
10438: LD_OWVAR 67
10442: PUSH
10443: LD_INT 1
10445: GREATER
10446: IFFALSE 10651
10448: GO 10450
10450: DISABLE
10451: LD_INT 0
10453: PPUSH
10454: PPUSH
10455: PPUSH
10456: PPUSH
// begin Wait ( Rand ( 0 0$01 , 6 6$01 ) ) ;
10457: LD_INT 35
10459: PPUSH
10460: LD_INT 12635
10462: PPUSH
10463: CALL_OW 12
10467: PPUSH
10468: CALL_OW 67
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
10472: LD_ADDR_VAR 0 2
10476: PUSH
10477: LD_INT 22
10479: PUSH
10480: LD_INT 8
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PUSH
10487: LD_INT 25
10489: PUSH
10490: LD_INT 4
10492: PUSH
10493: EMPTY
10494: LIST
10495: LIST
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 69
10505: ST_TO_ADDR
// p := 1 ;
10506: LD_ADDR_VAR 0 4
10510: PUSH
10511: LD_INT 1
10513: ST_TO_ADDR
// sib := [ 116 , 139 , 69 , 13 ] ;
10514: LD_ADDR_VAR 0 3
10518: PUSH
10519: LD_INT 116
10521: PUSH
10522: LD_INT 139
10524: PUSH
10525: LD_INT 69
10527: PUSH
10528: LD_INT 13
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: ST_TO_ADDR
// for i = 1 to 2 do
10537: LD_ADDR_VAR 0 1
10541: PUSH
10542: DOUBLE
10543: LD_INT 1
10545: DEC
10546: ST_TO_ADDR
10547: LD_INT 2
10549: PUSH
10550: FOR_TO
10551: IFFALSE 10649
// begin if IsInUnit ( sci [ i ] ) then
10553: LD_VAR 0 2
10557: PUSH
10558: LD_VAR 0 1
10562: ARRAY
10563: PPUSH
10564: CALL_OW 310
10568: IFFALSE 10585
// ComExitBuilding ( sci [ i ] ) ;
10570: LD_VAR 0 2
10574: PUSH
10575: LD_VAR 0 1
10579: ARRAY
10580: PPUSH
10581: CALL_OW 122
// Wait ( 0 0$03 ) ;
10585: LD_INT 105
10587: PPUSH
10588: CALL_OW 67
// ComContaminate ( sci [ i ] , sib [ p ] , sib [ p + 1 ] ) ;
10592: LD_VAR 0 2
10596: PUSH
10597: LD_VAR 0 1
10601: ARRAY
10602: PPUSH
10603: LD_VAR 0 3
10607: PUSH
10608: LD_VAR 0 4
10612: ARRAY
10613: PPUSH
10614: LD_VAR 0 3
10618: PUSH
10619: LD_VAR 0 4
10623: PUSH
10624: LD_INT 1
10626: PLUS
10627: ARRAY
10628: PPUSH
10629: CALL_OW 158
// p := p + 2 ;
10633: LD_ADDR_VAR 0 4
10637: PUSH
10638: LD_VAR 0 4
10642: PUSH
10643: LD_INT 2
10645: PLUS
10646: ST_TO_ADDR
// end ;
10647: GO 10550
10649: POP
10650: POP
// end ;
10651: PPOPN 4
10653: END
// every 3 3$30 trigger GetListOfCratesInArea ( legion_crates ) < 20 do
10654: LD_INT 14
10656: PPUSH
10657: CALL_OW 435
10661: PUSH
10662: LD_INT 20
10664: LESS
10665: IFFALSE 10692
10667: GO 10669
10669: DISABLE
// begin enable ;
10670: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , legion_crates , true ) ;
10671: LD_INT 1
10673: PPUSH
10674: LD_INT 5
10676: PPUSH
10677: CALL_OW 12
10681: PPUSH
10682: LD_INT 14
10684: PPUSH
10685: LD_INT 1
10687: PPUSH
10688: CALL_OW 55
// end ; end_of_file
10692: END
// export function Action ; var un ; begin
10693: LD_INT 0
10695: PPUSH
10696: PPUSH
// case Query ( QVul1 ) of 1 :
10697: LD_STRING QVul1
10699: PPUSH
10700: CALL_OW 97
10704: PUSH
10705: LD_INT 1
10707: DOUBLE
10708: EQUAL
10709: IFTRUE 10713
10711: GO 10724
10713: POP
// Difficulty := 1 ; 2 :
10714: LD_ADDR_OWVAR 67
10718: PUSH
10719: LD_INT 1
10721: ST_TO_ADDR
10722: GO 10763
10724: LD_INT 2
10726: DOUBLE
10727: EQUAL
10728: IFTRUE 10732
10730: GO 10743
10732: POP
// Difficulty := 2 ; 3 :
10733: LD_ADDR_OWVAR 67
10737: PUSH
10738: LD_INT 2
10740: ST_TO_ADDR
10741: GO 10763
10743: LD_INT 3
10745: DOUBLE
10746: EQUAL
10747: IFTRUE 10751
10749: GO 10762
10751: POP
// Difficulty := 3 ; end ;
10752: LD_ADDR_OWVAR 67
10756: PUSH
10757: LD_INT 3
10759: ST_TO_ADDR
10760: GO 10763
10762: POP
// case Query ( QVul3 ) of 1 :
10763: LD_STRING QVul3
10765: PPUSH
10766: CALL_OW 97
10770: PUSH
10771: LD_INT 1
10773: DOUBLE
10774: EQUAL
10775: IFTRUE 10779
10777: GO 10802
10779: POP
// begin your_side := 1 ;
10780: LD_ADDR_OWVAR 2
10784: PUSH
10785: LD_INT 1
10787: ST_TO_ADDR
// legion_enemy := 1 ;
10788: LD_ADDR_EXP 36
10792: PUSH
10793: LD_INT 1
10795: ST_TO_ADDR
// PrepareAmerican ;
10796: CALL 214 0 0
// end ; 2 :
10800: GO 10865
10802: LD_INT 2
10804: DOUBLE
10805: EQUAL
10806: IFTRUE 10810
10808: GO 10833
10810: POP
// begin your_side := 2 ;
10811: LD_ADDR_OWVAR 2
10815: PUSH
10816: LD_INT 2
10818: ST_TO_ADDR
// legion_enemy := 2 ;
10819: LD_ADDR_EXP 36
10823: PUSH
10824: LD_INT 2
10826: ST_TO_ADDR
// PrepareArabian ;
10827: CALL 17446 0 0
// end ; 3 :
10831: GO 10865
10833: LD_INT 3
10835: DOUBLE
10836: EQUAL
10837: IFTRUE 10841
10839: GO 10864
10841: POP
// begin your_side := 7 ;
10842: LD_ADDR_OWVAR 2
10846: PUSH
10847: LD_INT 7
10849: ST_TO_ADDR
// legion_enemy := 7 ;
10850: LD_ADDR_EXP 36
10854: PUSH
10855: LD_INT 7
10857: ST_TO_ADDR
// PrepareAlliance ;
10858: CALL 14857 0 0
// end ; end ;
10862: GO 10865
10864: POP
// if your_side = 1 then
10865: LD_OWVAR 2
10869: PUSH
10870: LD_INT 1
10872: EQUAL
10873: IFFALSE 11219
// begin case Query ( QVul4 ) of 1 :
10875: LD_STRING QVul4
10877: PPUSH
10878: CALL_OW 97
10882: PUSH
10883: LD_INT 1
10885: DOUBLE
10886: EQUAL
10887: IFTRUE 10891
10889: GO 10894
10891: POP
// ; end ;
10892: GO 10895
10894: POP
// InGameOn ;
10895: CALL_OW 8
// CenterNowOnXY ( 8 , 5 ) ;
10899: LD_INT 8
10901: PPUSH
10902: LD_INT 5
10904: PPUSH
10905: CALL_OW 86
// uc_side := 4 ;
10909: LD_ADDR_OWVAR 20
10913: PUSH
10914: LD_INT 4
10916: ST_TO_ADDR
// uc_nation := 1 ;
10917: LD_ADDR_OWVAR 21
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// hc_importance := 0 ;
10925: LD_ADDR_OWVAR 32
10929: PUSH
10930: LD_INT 0
10932: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , us_skill ) ;
10933: LD_INT 1
10935: PPUSH
10936: LD_INT 3
10938: PPUSH
10939: LD_EXP 21
10943: PPUSH
10944: CALL_OW 380
// un := CreateHuman ;
10948: LD_ADDR_VAR 0 2
10952: PUSH
10953: CALL_OW 44
10957: ST_TO_ADDR
// PlaceUnitXY ( un , 12 , 9 , false ) ;
10958: LD_VAR 0 2
10962: PPUSH
10963: LD_INT 12
10965: PPUSH
10966: LD_INT 9
10968: PPUSH
10969: LD_INT 0
10971: PPUSH
10972: CALL_OW 48
// hc_name := Stuart Carey ;
10976: LD_ADDR_OWVAR 26
10980: PUSH
10981: LD_STRING Stuart Carey
10983: ST_TO_ADDR
// hc_gallery := vulcano ;
10984: LD_ADDR_OWVAR 33
10988: PUSH
10989: LD_STRING vulcano
10991: ST_TO_ADDR
// hc_face_number := 1 ;
10992: LD_ADDR_OWVAR 34
10996: PUSH
10997: LD_INT 1
10999: ST_TO_ADDR
// us_guy := CreateHuman ;
11000: LD_ADDR_EXP 22
11004: PUSH
11005: CALL_OW 44
11009: ST_TO_ADDR
// hc_gallery :=  ;
11010: LD_ADDR_OWVAR 33
11014: PUSH
11015: LD_STRING 
11017: ST_TO_ADDR
// hc_name :=  ;
11018: LD_ADDR_OWVAR 26
11022: PUSH
11023: LD_STRING 
11025: ST_TO_ADDR
// ComTurnUnit ( un , us_commander ) ;
11026: LD_VAR 0 2
11030: PPUSH
11031: LD_EXP 19
11035: PPUSH
11036: CALL_OW 119
// ComTurnUnit ( us_commander , un ) ;
11040: LD_EXP 19
11044: PPUSH
11045: LD_VAR 0 2
11049: PPUSH
11050: CALL_OW 119
// Say ( un , VD-un1 ) ;
11054: LD_VAR 0 2
11058: PPUSH
11059: LD_STRING VD-un1
11061: PPUSH
11062: CALL_OW 88
// Say ( us_commander , VDc-1 ) ;
11066: LD_EXP 19
11070: PPUSH
11071: LD_STRING VDc-1
11073: PPUSH
11074: CALL_OW 88
// Say ( un , VD-un2 ) ;
11078: LD_VAR 0 2
11082: PPUSH
11083: LD_STRING VD-un2
11085: PPUSH
11086: CALL_OW 88
// Say ( us_commander , VDc-2 ) ;
11090: LD_EXP 19
11094: PPUSH
11095: LD_STRING VDc-2
11097: PPUSH
11098: CALL_OW 88
// Say ( un , VD-un3 ) ;
11102: LD_VAR 0 2
11106: PPUSH
11107: LD_STRING VD-un3
11109: PPUSH
11110: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
11114: LD_INT 7
11116: PPUSH
11117: CALL_OW 67
// Say ( un , VD-un4 ) ;
11121: LD_VAR 0 2
11125: PPUSH
11126: LD_STRING VD-un4
11128: PPUSH
11129: CALL_OW 88
// ComMoveXY ( un , 2 , 2 ) ;
11133: LD_VAR 0 2
11137: PPUSH
11138: LD_INT 2
11140: PPUSH
11141: LD_INT 2
11143: PPUSH
11144: CALL_OW 111
// Say ( us_commander , VDc-3 ) ;
11148: LD_EXP 19
11152: PPUSH
11153: LD_STRING VDc-3
11155: PPUSH
11156: CALL_OW 88
// InGameOff ;
11160: CALL_OW 9
// ChangeMissionObjectives ( CVulc1 ) ;
11164: LD_STRING CVulc1
11166: PPUSH
11167: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
11171: LD_INT 35
11173: PPUSH
11174: CALL_OW 67
// until GetX ( un ) = 2 and GetY ( un ) = 2 ;
11178: LD_VAR 0 2
11182: PPUSH
11183: CALL_OW 250
11187: PUSH
11188: LD_INT 2
11190: EQUAL
11191: PUSH
11192: LD_VAR 0 2
11196: PPUSH
11197: CALL_OW 251
11201: PUSH
11202: LD_INT 2
11204: EQUAL
11205: AND
11206: IFFALSE 11171
// RemoveUnit ( un ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: CALL_OW 64
// end else
11217: GO 11511
// if your_side = 2 then
11219: LD_OWVAR 2
11223: PUSH
11224: LD_INT 2
11226: EQUAL
11227: IFFALSE 11399
// begin CenterNowOnUnits ( player_commander ) ;
11229: LD_EXP 10
11233: PPUSH
11234: CALL_OW 87
// InGameOn ;
11238: CALL_OW 8
// Say ( ar_commander , VSd-1 ) ;
11242: LD_EXP 51
11246: PPUSH
11247: LD_STRING VSd-1
11249: PPUSH
11250: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-1 ) ;
11254: LD_INT 22
11256: PUSH
11257: LD_INT 2
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 21
11266: PUSH
11267: LD_INT 1
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 26
11276: PUSH
11277: LD_INT 1
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: LIST
11288: PUSH
11289: EMPTY
11290: LIST
11291: PPUSH
11292: CALL_OW 69
11296: PUSH
11297: LD_INT 2
11299: ARRAY
11300: PPUSH
11301: LD_STRING VAd-1
11303: PPUSH
11304: CALL_OW 88
// Say ( ar_commander , VSd-2 ) ;
11308: LD_EXP 51
11312: PPUSH
11313: LD_STRING VSd-2
11315: PPUSH
11316: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VAd-2 ) ;
11320: LD_INT 22
11322: PUSH
11323: LD_INT 2
11325: PUSH
11326: EMPTY
11327: LIST
11328: LIST
11329: PUSH
11330: LD_INT 21
11332: PUSH
11333: LD_INT 1
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: PUSH
11340: LD_INT 26
11342: PUSH
11343: LD_INT 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: LIST
11354: PUSH
11355: EMPTY
11356: LIST
11357: PPUSH
11358: CALL_OW 69
11362: PUSH
11363: LD_INT 2
11365: ARRAY
11366: PPUSH
11367: LD_STRING VAd-2
11369: PPUSH
11370: CALL_OW 88
// Say ( ar_commander , VSd-3 ) ;
11374: LD_EXP 51
11378: PPUSH
11379: LD_STRING VSd-3
11381: PPUSH
11382: CALL_OW 88
// InGameOff ;
11386: CALL_OW 9
// ChangeMissionObjectives ( CVulc5 ) ;
11390: LD_STRING CVulc5
11392: PPUSH
11393: CALL_OW 337
// end else
11397: GO 11511
// if your_side = 7 then
11399: LD_OWVAR 2
11403: PUSH
11404: LD_INT 7
11406: EQUAL
11407: IFFALSE 11511
// begin CenterNowOnUnits ( al_commander ) ;
11409: LD_EXP 37
11413: PPUSH
11414: CALL_OW 87
// InGameOn ;
11418: CALL_OW 8
// Say ( al_commander , VPd-1 ) ;
11422: LD_EXP 37
11426: PPUSH
11427: LD_STRING VPd-1
11429: PPUSH
11430: CALL_OW 88
// Say ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ] ) [ 2 ] , VPpd-1 ) ;
11434: LD_INT 22
11436: PUSH
11437: LD_INT 7
11439: PUSH
11440: EMPTY
11441: LIST
11442: LIST
11443: PUSH
11444: LD_INT 21
11446: PUSH
11447: LD_INT 1
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: PUSH
11454: LD_INT 26
11456: PUSH
11457: LD_INT 1
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: LIST
11468: PUSH
11469: EMPTY
11470: LIST
11471: PPUSH
11472: CALL_OW 69
11476: PUSH
11477: LD_INT 2
11479: ARRAY
11480: PPUSH
11481: LD_STRING VPpd-1
11483: PPUSH
11484: CALL_OW 88
// Say ( al_commander , VPd-2 ) ;
11488: LD_EXP 37
11492: PPUSH
11493: LD_STRING VPd-2
11495: PPUSH
11496: CALL_OW 88
// InGameOff ;
11500: CALL_OW 9
// ChangeMissionObjectives ( CVulc7 ) ;
11504: LD_STRING CVulc7
11506: PPUSH
11507: CALL_OW 337
// end ; end ;
11511: LD_VAR 0 1
11515: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) do
11516: LD_INT 22
11518: PUSH
11519: LD_INT 2
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: LD_INT 30
11528: PUSH
11529: LD_INT 3
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PPUSH
11540: CALL_OW 69
11544: IFFALSE 11588
11546: GO 11548
11548: DISABLE
// begin ChangeMissionObjectives ( CVulc6 ) ;
11549: LD_STRING CVulc6
11551: PPUSH
11552: CALL_OW 337
// Wait ( [ 25 25$00 , 22 22$30 , 20 20$00 ] [ Difficulty ] ) ;
11556: LD_INT 52500
11558: PUSH
11559: LD_INT 47250
11561: PUSH
11562: LD_INT 42000
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: LIST
11569: PUSH
11570: LD_OWVAR 67
11574: ARRAY
11575: PPUSH
11576: CALL_OW 67
// ru_can_attack := true ;
11580: LD_ADDR_EXP 3
11584: PUSH
11585: LD_INT 1
11587: ST_TO_ADDR
// end ;
11588: END
// every 0 0$01 trigger GetSide ( us_depot ) = 1 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_factory ] , [ f_btype , b_warehouse ] ] ] ) do
11589: LD_INT 50
11591: PPUSH
11592: CALL_OW 255
11596: PUSH
11597: LD_INT 1
11599: EQUAL
11600: PUSH
11601: LD_INT 22
11603: PUSH
11604: LD_INT 1
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: PUSH
11611: LD_INT 2
11613: PUSH
11614: LD_INT 30
11616: PUSH
11617: LD_INT 3
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PUSH
11624: LD_INT 30
11626: PUSH
11627: LD_INT 1
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: LIST
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: PPUSH
11643: CALL_OW 69
11647: OR
11648: IFFALSE 11825
11650: GO 11652
11652: DISABLE
// begin ChangeMissionObjectives ( CVulc2 ) ;
11653: LD_STRING CVulc2
11655: PPUSH
11656: CALL_OW 337
// DialogueOn ;
11660: CALL_OW 6
// DWait ( 0 0$0.3 ) ;
11664: LD_INT 10
11666: PPUSH
11667: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) diff us_commander ) [ 1 ] , VDb-1 ) ;
11671: LD_INT 22
11673: PUSH
11674: LD_INT 1
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 25
11683: PUSH
11684: LD_INT 2
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 19
11704: DIFF
11705: PUSH
11706: LD_INT 1
11708: ARRAY
11709: PPUSH
11710: LD_STRING VDb-1
11712: PPUSH
11713: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
11717: LD_INT 10
11719: PPUSH
11720: CALL_OW 68
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VDb-2 ) ;
11724: LD_INT 22
11726: PUSH
11727: LD_INT 1
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 25
11736: PUSH
11737: LD_INT 4
11739: PUSH
11740: EMPTY
11741: LIST
11742: LIST
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: PPUSH
11748: CALL_OW 69
11752: PUSH
11753: LD_EXP 19
11757: DIFF
11758: PUSH
11759: LD_INT 1
11761: ARRAY
11762: PPUSH
11763: LD_STRING VDb-2
11765: PPUSH
11766: CALL_OW 88
// DWait ( 0 0$01 ) ;
11770: LD_INT 35
11772: PPUSH
11773: CALL_OW 68
// Say ( us_commander , VDb-com1 ) ;
11777: LD_EXP 19
11781: PPUSH
11782: LD_STRING VDb-com1
11784: PPUSH
11785: CALL_OW 88
// DialogueOff ;
11789: CALL_OW 7
// Wait ( [ 21 21$00 , 17 17$30 , 15 15$00 ] [ Difficulty ] ) ;
11793: LD_INT 44100
11795: PUSH
11796: LD_INT 36750
11798: PUSH
11799: LD_INT 31500
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: PUSH
11807: LD_OWVAR 67
11811: ARRAY
11812: PPUSH
11813: CALL_OW 67
// ru_can_attack := true ;
11817: LD_ADDR_EXP 3
11821: PUSH
11822: LD_INT 1
11824: ST_TO_ADDR
// end ;
11825: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) do
11826: LD_INT 22
11828: PUSH
11829: LD_INT 7
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: PUSH
11836: LD_INT 30
11838: PUSH
11839: LD_INT 3
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PPUSH
11850: CALL_OW 69
11854: IFFALSE 11891
11856: GO 11858
11858: DISABLE
// begin Wait ( [ 20 20$00 , 16 16$30 , 14 14$00 ] [ Difficulty ] ) ;
11859: LD_INT 42000
11861: PUSH
11862: LD_INT 34650
11864: PUSH
11865: LD_INT 29400
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: LIST
11872: PUSH
11873: LD_OWVAR 67
11877: ARRAY
11878: PPUSH
11879: CALL_OW 67
// ru_can_attack := true ;
11883: LD_ADDR_EXP 3
11887: PUSH
11888: LD_INT 1
11890: ST_TO_ADDR
// end ;
11891: END
// every 0 0$01 trigger GetSide ( us_lab ) = 1 do
11892: LD_INT 58
11894: PPUSH
11895: CALL_OW 255
11899: PUSH
11900: LD_INT 1
11902: EQUAL
11903: IFFALSE 12035
11905: GO 11907
11907: DISABLE
// begin DialogueOn ;
11908: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-1 ) ;
11912: LD_INT 22
11914: PUSH
11915: LD_INT 1
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PUSH
11922: LD_INT 25
11924: PUSH
11925: LD_INT 2
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PPUSH
11936: CALL_OW 69
11940: PUSH
11941: LD_INT 1
11943: ARRAY
11944: PPUSH
11945: LD_STRING VDe-1
11947: PPUSH
11948: CALL_OW 88
// case Query ( SibNote ) of 1 :
11952: LD_STRING SibNote
11954: PPUSH
11955: CALL_OW 97
11959: PUSH
11960: LD_INT 1
11962: DOUBLE
11963: EQUAL
11964: IFTRUE 11968
11966: GO 11971
11968: POP
// ; end ;
11969: GO 11972
11971: POP
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , VDe-2 ) ;
11972: LD_INT 22
11974: PUSH
11975: LD_INT 1
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_INT 25
11984: PUSH
11985: LD_INT 2
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: EMPTY
11993: LIST
11994: LIST
11995: PPUSH
11996: CALL_OW 69
12000: PUSH
12001: LD_INT 1
12003: ARRAY
12004: PPUSH
12005: LD_STRING VDe-2
12007: PPUSH
12008: CALL_OW 88
// Say ( us_commander , VDc-4 ) ;
12012: LD_EXP 19
12016: PPUSH
12017: LD_STRING VDc-4
12019: PPUSH
12020: CALL_OW 88
// DialogueOff ;
12024: CALL_OW 7
// ChangeMissionObjectives ( CVulc3 ) ;
12028: LD_STRING CVulc3
12030: PPUSH
12031: CALL_OW 337
// end ;
12035: END
// every 0 0$01 trigger your_side = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] ] ) > 0 do var i , un , veh ;
12036: LD_OWVAR 2
12040: PUSH
12041: LD_INT 1
12043: EQUAL
12044: PUSH
12045: LD_INT 22
12047: PUSH
12048: LD_INT 1
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 30
12057: PUSH
12058: LD_INT 3
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: PPUSH
12069: CALL_OW 69
12073: PUSH
12074: LD_INT 0
12076: GREATER
12077: AND
12078: IFFALSE 12512
12080: GO 12082
12082: DISABLE
12083: LD_INT 0
12085: PPUSH
12086: PPUSH
12087: PPUSH
// begin Wait ( Rand ( 0 0$07 , 0 0$37 ) ) ;
12088: LD_INT 245
12090: PPUSH
12091: LD_INT 1295
12093: PPUSH
12094: CALL_OW 12
12098: PPUSH
12099: CALL_OW 67
// DialogueOn ;
12103: CALL_OW 6
// SayRadio ( us_guy , VDG-1 ) ;
12107: LD_EXP 22
12111: PPUSH
12112: LD_STRING VDG-1
12114: PPUSH
12115: CALL_OW 94
// Say ( us_commander , VDc-5 ) ;
12119: LD_EXP 19
12123: PPUSH
12124: LD_STRING VDc-5
12126: PPUSH
12127: CALL_OW 88
// SayRadio ( us_guy , VDG-2 ) ;
12131: LD_EXP 22
12135: PPUSH
12136: LD_STRING VDG-2
12138: PPUSH
12139: CALL_OW 94
// Say ( us_commander , VDc-6 ) ;
12143: LD_EXP 19
12147: PPUSH
12148: LD_STRING VDc-6
12150: PPUSH
12151: CALL_OW 88
// SayRadio ( us_guy , VDG-3 ) ;
12155: LD_EXP 22
12159: PPUSH
12160: LD_STRING VDG-3
12162: PPUSH
12163: CALL_OW 94
// Say ( us_commander , VDc-7 ) ;
12167: LD_EXP 19
12171: PPUSH
12172: LD_STRING VDc-7
12174: PPUSH
12175: CALL_OW 88
// SayRadio ( us_guy , VDG-4 ) ;
12179: LD_EXP 22
12183: PPUSH
12184: LD_STRING VDG-4
12186: PPUSH
12187: CALL_OW 94
// DialogueOff ;
12191: CALL_OW 7
// ChangeMissionObjectives ( CVulc4 ) ;
12195: LD_STRING CVulc4
12197: PPUSH
12198: CALL_OW 337
// Wait ( [ 9 9$00 , 10 10$00 , 11 11$00 ] [ Difficulty ] ) ;
12202: LD_INT 18900
12204: PUSH
12205: LD_INT 21000
12207: PUSH
12208: LD_INT 23100
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: LIST
12215: PUSH
12216: LD_OWVAR 67
12220: ARRAY
12221: PPUSH
12222: CALL_OW 67
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
12226: LD_ADDR_VAR 0 1
12230: PUSH
12231: DOUBLE
12232: LD_INT 1
12234: DEC
12235: ST_TO_ADDR
12236: LD_INT 4
12238: PUSH
12239: LD_INT 5
12241: PUSH
12242: LD_INT 6
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: LIST
12249: PUSH
12250: LD_OWVAR 67
12254: ARRAY
12255: PUSH
12256: FOR_TO
12257: IFFALSE 12501
// begin uc_side := 1 ;
12259: LD_ADDR_OWVAR 20
12263: PUSH
12264: LD_INT 1
12266: ST_TO_ADDR
// uc_nation := 1 ;
12267: LD_ADDR_OWVAR 21
12271: PUSH
12272: LD_INT 1
12274: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , us_skill ) ;
12275: LD_INT 0
12277: PPUSH
12278: LD_INT 1
12280: PPUSH
12281: LD_INT 4
12283: PPUSH
12284: CALL_OW 12
12288: PPUSH
12289: LD_EXP 21
12293: PPUSH
12294: CALL_OW 380
// un := CreateHuman ;
12298: LD_ADDR_VAR 0 2
12302: PUSH
12303: CALL_OW 44
12307: ST_TO_ADDR
// SetDir ( un , 2 ) ;
12308: LD_VAR 0 2
12312: PPUSH
12313: LD_INT 2
12315: PPUSH
12316: CALL_OW 233
// if GetClass ( un ) = 3 then
12320: LD_VAR 0 2
12324: PPUSH
12325: CALL_OW 257
12329: PUSH
12330: LD_INT 3
12332: EQUAL
12333: IFFALSE 12484
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked ] [ i mod 2 ] ;
12335: LD_ADDR_OWVAR 37
12339: PUSH
12340: LD_INT 2
12342: PUSH
12343: LD_INT 3
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_VAR 0 1
12354: PUSH
12355: LD_INT 2
12357: MOD
12358: ARRAY
12359: ST_TO_ADDR
// vc_engine := engine_combustion ;
12360: LD_ADDR_OWVAR 39
12364: PUSH
12365: LD_INT 1
12367: ST_TO_ADDR
// vc_control := control_manual ;
12368: LD_ADDR_OWVAR 38
12372: PUSH
12373: LD_INT 1
12375: ST_TO_ADDR
// vc_weapon := [ us_laser , us_laser , us_double_gun , us_radar ] [ rand ( 1 , 4 ) ] ;
12376: LD_ADDR_OWVAR 40
12380: PUSH
12381: LD_INT 9
12383: PUSH
12384: LD_INT 9
12386: PUSH
12387: LD_INT 5
12389: PUSH
12390: LD_INT 11
12392: PUSH
12393: EMPTY
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: PUSH
12399: LD_INT 1
12401: PPUSH
12402: LD_INT 4
12404: PPUSH
12405: CALL_OW 12
12409: ARRAY
12410: ST_TO_ADDR
// veh := CreateVehicle ;
12411: LD_ADDR_VAR 0 3
12415: PUSH
12416: CALL_OW 45
12420: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
12421: LD_VAR 0 3
12425: PPUSH
12426: LD_INT 2
12428: PPUSH
12429: CALL_OW 233
// SetFuel ( veh , Rand ( 77 , 88 ) ) ;
12433: LD_VAR 0 3
12437: PPUSH
12438: LD_INT 77
12440: PPUSH
12441: LD_INT 88
12443: PPUSH
12444: CALL_OW 12
12448: PPUSH
12449: CALL_OW 240
// PlaceUnitArea ( veh , start_north , false ) ;
12453: LD_VAR 0 3
12457: PPUSH
12458: LD_INT 1
12460: PPUSH
12461: LD_INT 0
12463: PPUSH
12464: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
12468: LD_VAR 0 2
12472: PPUSH
12473: LD_VAR 0 3
12477: PPUSH
12478: CALL_OW 52
// end else
12482: GO 12499
// PlaceUnitArea ( un , start_north , false ) ;
12484: LD_VAR 0 2
12488: PPUSH
12489: LD_INT 1
12491: PPUSH
12492: LD_INT 0
12494: PPUSH
12495: CALL_OW 49
// end ;
12499: GO 12256
12501: POP
12502: POP
// CenterNowOnUnits ( un ) ;
12503: LD_VAR 0 2
12507: PPUSH
12508: CALL_OW 87
// end ;
12512: PPOPN 3
12514: END
// every 0 0$01 trigger FilterUnitsInArea ( vulc_artifact , [ f_side , your_side ] ) do var un , filter ;
12515: LD_INT 21
12517: PPUSH
12518: LD_INT 22
12520: PUSH
12521: LD_OWVAR 2
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PPUSH
12530: CALL_OW 70
12534: IFFALSE 12756
12536: GO 12538
12538: DISABLE
12539: LD_INT 0
12541: PPUSH
12542: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff player_commander ;
12543: LD_ADDR_VAR 0 2
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_OWVAR 2
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 2
12562: PUSH
12563: LD_INT 25
12565: PUSH
12566: LD_INT 1
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PUSH
12573: LD_INT 25
12575: PUSH
12576: LD_INT 2
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PUSH
12583: LD_INT 25
12585: PUSH
12586: LD_INT 3
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: PUSH
12593: LD_INT 25
12595: PUSH
12596: LD_INT 4
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: PPUSH
12614: CALL_OW 69
12618: PUSH
12619: LD_EXP 10
12623: DIFF
12624: ST_TO_ADDR
// un := NearestUnitToXY ( filter , 112 , 67 ) ;
12625: LD_ADDR_VAR 0 1
12629: PUSH
12630: LD_VAR 0 2
12634: PPUSH
12635: LD_INT 112
12637: PPUSH
12638: LD_INT 67
12640: PPUSH
12641: CALL_OW 73
12645: ST_TO_ADDR
// if GetSide ( un ) = 7 then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 255
12655: PUSH
12656: LD_INT 7
12658: EQUAL
12659: IFFALSE 12673
// Say ( un , VD-find-al ) ;
12661: LD_VAR 0 1
12665: PPUSH
12666: LD_STRING VD-find-al
12668: PPUSH
12669: CALL_OW 88
// if GetSide ( un ) = 2 then
12673: LD_VAR 0 1
12677: PPUSH
12678: CALL_OW 255
12682: PUSH
12683: LD_INT 2
12685: EQUAL
12686: IFFALSE 12700
// Say ( un , VD-find-ar ) ;
12688: LD_VAR 0 1
12692: PPUSH
12693: LD_STRING VD-find-ar
12695: PPUSH
12696: CALL_OW 88
// if GetSide ( un ) = 1 then
12700: LD_VAR 0 1
12704: PPUSH
12705: CALL_OW 255
12709: PUSH
12710: LD_INT 1
12712: EQUAL
12713: IFFALSE 12739
// begin Say ( un , VD-find-us ) ;
12715: LD_VAR 0 1
12719: PPUSH
12720: LD_STRING VD-find-us
12722: PPUSH
12723: CALL_OW 88
// Say ( un , VD-find-us2 ) ;
12727: LD_VAR 0 1
12731: PPUSH
12732: LD_STRING VD-find-us2
12734: PPUSH
12735: CALL_OW 88
// end ; Wait ( 0 0$0.3 ) ;
12739: LD_INT 10
12741: PPUSH
12742: CALL_OW 67
// CenterNowOnXY ( 112 , 67 ) ;
12746: LD_INT 112
12748: PPUSH
12749: LD_INT 67
12751: PPUSH
12752: CALL_OW 86
// end ;
12756: PPOPN 2
12758: END
// every 0 0$01 trigger player_artifact_ready do
12759: LD_EXP 7
12763: IFFALSE 13077
12765: GO 12767
12767: DISABLE
// begin if your_side = 1 then
12768: LD_OWVAR 2
12772: PUSH
12773: LD_INT 1
12775: EQUAL
12776: IFFALSE 12894
// begin Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-1 ) ;
12778: LD_INT 22
12780: PUSH
12781: LD_INT 1
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: PUSH
12788: LD_INT 25
12790: PUSH
12791: LD_INT 4
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PPUSH
12802: CALL_OW 69
12806: PUSH
12807: LD_EXP 19
12811: DIFF
12812: PUSH
12813: LD_INT 1
12815: ARRAY
12816: PPUSH
12817: LD_STRING VD-us-sci-art-1
12819: PPUSH
12820: CALL_OW 88
// Say ( us_commander , VDc-art1 ) ;
12824: LD_EXP 19
12828: PPUSH
12829: LD_STRING VDc-art1
12831: PPUSH
12832: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) diff us_commander ) [ 1 ] , VD-us-sci-art-2 ) ;
12836: LD_INT 22
12838: PUSH
12839: LD_INT 1
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 25
12848: PUSH
12849: LD_INT 4
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PPUSH
12860: CALL_OW 69
12864: PUSH
12865: LD_EXP 19
12869: DIFF
12870: PUSH
12871: LD_INT 1
12873: ARRAY
12874: PPUSH
12875: LD_STRING VD-us-sci-art-2
12877: PPUSH
12878: CALL_OW 88
// Say ( us_commander , VDc-art2 ) ;
12882: LD_EXP 19
12886: PPUSH
12887: LD_STRING VDc-art2
12889: PPUSH
12890: CALL_OW 88
// end ; if your_side = 2 then
12894: LD_OWVAR 2
12898: PUSH
12899: LD_INT 2
12901: EQUAL
12902: IFFALSE 12944
// begin Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) [ 1 ] , VD-ar-sci-art-1 ) ;
12904: LD_INT 22
12906: PUSH
12907: LD_INT 2
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 25
12916: PUSH
12917: LD_INT 4
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PPUSH
12928: CALL_OW 69
12932: PUSH
12933: LD_INT 1
12935: ARRAY
12936: PPUSH
12937: LD_STRING VD-ar-sci-art-1
12939: PPUSH
12940: CALL_OW 88
// end ; if your_side = 7 then
12944: LD_OWVAR 2
12948: PUSH
12949: LD_INT 7
12951: EQUAL
12952: IFFALSE 13077
// begin Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-1 ) ;
12954: LD_INT 22
12956: PUSH
12957: LD_INT 7
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 4
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PPUSH
12978: CALL_OW 69
12982: PUSH
12983: LD_EXP 37
12987: DIFF
12988: PUSH
12989: LD_INT 1
12991: ARRAY
12992: PPUSH
12993: LD_STRING VD-al-sci-art-1
12995: PPUSH
12996: CALL_OW 88
// Say ( al_commander , VPd-art-1 ) ;
13000: LD_EXP 37
13004: PPUSH
13005: LD_STRING VPd-art-1
13007: PPUSH
13008: CALL_OW 88
// Say ( ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) diff al_commander ) [ 1 ] , VD-al-sci-art-2 ) ;
13012: LD_INT 22
13014: PUSH
13015: LD_INT 7
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PUSH
13022: LD_INT 25
13024: PUSH
13025: LD_INT 4
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PPUSH
13036: CALL_OW 69
13040: PUSH
13041: LD_EXP 37
13045: DIFF
13046: PUSH
13047: LD_INT 1
13049: ARRAY
13050: PPUSH
13051: LD_STRING VD-al-sci-art-2
13053: PPUSH
13054: CALL_OW 88
// Say ( al_commander , VPd-art-2 ) ;
13058: LD_EXP 37
13062: PPUSH
13063: LD_STRING VPd-art-2
13065: PPUSH
13066: CALL_OW 88
// ChangeMissionObjectives ( CVulc7out ) ;
13070: LD_STRING CVulc7out
13072: PPUSH
13073: CALL_OW 337
// end ; end ;
13077: END
// every 0 0$01 trigger See ( 8 , NearestUnitToSide ( FilterAllUnits ( [ f_side , your_side ] ) , 8 ) ) do
13078: LD_INT 8
13080: PPUSH
13081: LD_INT 22
13083: PUSH
13084: LD_OWVAR 2
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PPUSH
13093: CALL_OW 69
13097: PPUSH
13098: LD_INT 8
13100: PPUSH
13101: CALL 2138 0 2
13105: PPUSH
13106: CALL_OW 292
13110: IFFALSE 13201
13112: GO 13114
13114: DISABLE
// begin if your_side = 1 then
13115: LD_OWVAR 2
13119: PUSH
13120: LD_INT 1
13122: EQUAL
13123: IFFALSE 13157
// Say ( ( FilterAllUnits ( [ f_side , 1 ] ) diff us_commander ) [ 1 ] , VD-legion-us ) ;
13125: LD_INT 22
13127: PUSH
13128: LD_INT 1
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PPUSH
13135: CALL_OW 69
13139: PUSH
13140: LD_EXP 19
13144: DIFF
13145: PUSH
13146: LD_INT 1
13148: ARRAY
13149: PPUSH
13150: LD_STRING VD-legion-us
13152: PPUSH
13153: CALL_OW 88
// if your_side = 2 then
13157: LD_OWVAR 2
13161: PUSH
13162: LD_INT 2
13164: EQUAL
13165: IFFALSE 13179
// Say ( ar_commander , VD-legion-ar ) ;
13167: LD_EXP 51
13171: PPUSH
13172: LD_STRING VD-legion-ar
13174: PPUSH
13175: CALL_OW 88
// if your_side = 7 then
13179: LD_OWVAR 2
13183: PUSH
13184: LD_INT 7
13186: EQUAL
13187: IFFALSE 13201
// Say ( al_commander , VD-legion-al ) ;
13189: LD_EXP 37
13193: PPUSH
13194: LD_STRING VD-legion-al
13196: PPUSH
13197: CALL_OW 88
// end ;
13201: END
// every 0 0$01 trigger mine_vulc do
13202: LD_EXP 12
13206: IFFALSE 13223
13208: GO 13210
13210: DISABLE
// begin Say ( player_commander , VD-vulc-mines ) ;
13211: LD_EXP 10
13215: PPUSH
13216: LD_STRING VD-vulc-mines
13218: PPUSH
13219: CALL_OW 88
// end ;
13223: END
// every 0 0$03 trigger difficulty > 1 do var mines , p , i ;
13224: LD_OWVAR 67
13228: PUSH
13229: LD_INT 1
13231: GREATER
13232: IFFALSE 13351
13234: GO 13236
13236: DISABLE
13237: LD_INT 0
13239: PPUSH
13240: PPUSH
13241: PPUSH
// begin mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13242: LD_ADDR_VAR 0 1
13246: PUSH
13247: LD_INT 123
13249: PUSH
13250: LD_INT 95
13252: PUSH
13253: LD_INT 119
13255: PUSH
13256: LD_INT 89
13258: PUSH
13259: LD_INT 115
13261: PUSH
13262: LD_INT 81
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: LIST
13272: ST_TO_ADDR
// p := 1 ;
13273: LD_ADDR_VAR 0 2
13277: PUSH
13278: LD_INT 1
13280: ST_TO_ADDR
// for i = 1 to 3 do
13281: LD_ADDR_VAR 0 3
13285: PUSH
13286: DOUBLE
13287: LD_INT 1
13289: DEC
13290: ST_TO_ADDR
13291: LD_INT 3
13293: PUSH
13294: FOR_TO
13295: IFFALSE 13349
// begin PlaceMine ( mines [ p ] , mines [ p + 1 ] , 8 , 0 ) ;
13297: LD_VAR 0 1
13301: PUSH
13302: LD_VAR 0 2
13306: ARRAY
13307: PPUSH
13308: LD_VAR 0 1
13312: PUSH
13313: LD_VAR 0 2
13317: PUSH
13318: LD_INT 1
13320: PLUS
13321: ARRAY
13322: PPUSH
13323: LD_INT 8
13325: PPUSH
13326: LD_INT 0
13328: PPUSH
13329: CALL_OW 454
// p := p + 2 ;
13333: LD_ADDR_VAR 0 2
13337: PUSH
13338: LD_VAR 0 2
13342: PUSH
13343: LD_INT 2
13345: PLUS
13346: ST_TO_ADDR
// end ;
13347: GO 13294
13349: POP
13350: POP
// end ;
13351: PPOPN 3
13353: END
// every 0 0$01 trigger difficulty > 1 and FilterUnitsInArea ( vulc_mines , [ f_side , your_side ] ) do var p , i , mines ;
13354: LD_OWVAR 67
13358: PUSH
13359: LD_INT 1
13361: GREATER
13362: PUSH
13363: LD_INT 22
13365: PPUSH
13366: LD_INT 22
13368: PUSH
13369: LD_OWVAR 2
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PPUSH
13378: CALL_OW 70
13382: AND
13383: IFFALSE 13587
13385: GO 13387
13387: DISABLE
13388: LD_INT 0
13390: PPUSH
13391: PPUSH
13392: PPUSH
// begin enable ;
13393: ENABLE
// p := 1 ;
13394: LD_ADDR_VAR 0 1
13398: PUSH
13399: LD_INT 1
13401: ST_TO_ADDR
// mines := [ 123 , 95 , 119 , 89 , 115 , 81 ] ;
13402: LD_ADDR_VAR 0 3
13406: PUSH
13407: LD_INT 123
13409: PUSH
13410: LD_INT 95
13412: PUSH
13413: LD_INT 119
13415: PUSH
13416: LD_INT 89
13418: PUSH
13419: LD_INT 115
13421: PUSH
13422: LD_INT 81
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: LIST
13431: LIST
13432: ST_TO_ADDR
// for i = 1 to 3 do
13433: LD_ADDR_VAR 0 2
13437: PUSH
13438: DOUBLE
13439: LD_INT 1
13441: DEC
13442: ST_TO_ADDR
13443: LD_INT 3
13445: PUSH
13446: FOR_TO
13447: IFFALSE 13585
// begin if HexInfo ( mines [ p ] , mines [ p + 1 ] ) > 0 then
13449: LD_VAR 0 3
13453: PUSH
13454: LD_VAR 0 1
13458: ARRAY
13459: PPUSH
13460: LD_VAR 0 3
13464: PUSH
13465: LD_VAR 0 1
13469: PUSH
13470: LD_INT 1
13472: PLUS
13473: ARRAY
13474: PPUSH
13475: CALL_OW 428
13479: PUSH
13480: LD_INT 0
13482: GREATER
13483: IFFALSE 13569
// if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) = your_side then
13485: LD_VAR 0 3
13489: PUSH
13490: LD_VAR 0 1
13494: ARRAY
13495: PPUSH
13496: LD_VAR 0 3
13500: PUSH
13501: LD_VAR 0 1
13505: PUSH
13506: LD_INT 1
13508: PLUS
13509: ARRAY
13510: PPUSH
13511: CALL_OW 428
13515: PPUSH
13516: CALL_OW 255
13520: PUSH
13521: LD_OWVAR 2
13525: EQUAL
13526: IFFALSE 13569
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 8 ) ;
13528: LD_VAR 0 3
13532: PUSH
13533: LD_VAR 0 1
13537: ARRAY
13538: PPUSH
13539: LD_VAR 0 3
13543: PUSH
13544: LD_VAR 0 1
13548: PUSH
13549: LD_INT 1
13551: PLUS
13552: ARRAY
13553: PPUSH
13554: LD_INT 8
13556: PPUSH
13557: CALL_OW 456
// mine_vulc := true ;
13561: LD_ADDR_EXP 12
13565: PUSH
13566: LD_INT 1
13568: ST_TO_ADDR
// end ; p := p + 2 ;
13569: LD_ADDR_VAR 0 1
13573: PUSH
13574: LD_VAR 0 1
13578: PUSH
13579: LD_INT 2
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13446
13585: POP
13586: POP
// end ;
13587: PPOPN 3
13589: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) = 0 and your_side <> 2 do
13590: LD_INT 22
13592: PUSH
13593: LD_INT 3
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PPUSH
13600: CALL_OW 69
13604: PUSH
13605: LD_INT 0
13607: EQUAL
13608: PUSH
13609: LD_OWVAR 2
13613: PUSH
13614: LD_INT 2
13616: NONEQUAL
13617: AND
13618: IFFALSE 13627
13620: GO 13622
13622: DISABLE
// Win ;
13623: CALL 13684 0 0
13627: END
// every 0 0$01 trigger FilterAllUnits ( [ f_or , [ f_side , 8 ] , [ f_side , 3 ] ] ) = 0 and your_side = 2 do
13628: LD_INT 2
13630: PUSH
13631: LD_INT 22
13633: PUSH
13634: LD_INT 8
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 22
13643: PUSH
13644: LD_INT 3
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: LIST
13655: PPUSH
13656: CALL_OW 69
13660: PUSH
13661: LD_INT 0
13663: EQUAL
13664: PUSH
13665: LD_OWVAR 2
13669: PUSH
13670: LD_INT 2
13672: EQUAL
13673: AND
13674: IFFALSE 13683
13676: GO 13678
13678: DISABLE
// Win ;
13679: CALL 13684 0 0
13683: END
// function Win ; var points ; begin
13684: LD_INT 0
13686: PPUSH
13687: PPUSH
// case Query ( VulcWin ) of 1 :
13688: LD_STRING VulcWin
13690: PPUSH
13691: CALL_OW 97
13695: PUSH
13696: LD_INT 1
13698: DOUBLE
13699: EQUAL
13700: IFTRUE 13704
13702: GO 13707
13704: POP
// ; end ;
13705: GO 13708
13707: POP
// if medal_enabled then
13708: LD_EXP 13
13712: IFFALSE 13726
// AddMedal ( vulc_1 , 1 ) else
13714: LD_STRING vulc_1
13716: PPUSH
13717: LD_INT 1
13719: PPUSH
13720: CALL_OW 101
13724: GO 13737
// AddMedal ( vulc_1 , - 1 ) ;
13726: LD_STRING vulc_1
13728: PPUSH
13729: LD_INT 1
13731: NEG
13732: PPUSH
13733: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) = 0 then
13737: LD_INT 22
13739: PUSH
13740: LD_INT 8
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PPUSH
13747: CALL_OW 69
13751: PUSH
13752: LD_INT 0
13754: EQUAL
13755: IFFALSE 13769
// AddMedal ( vulc_2 , 1 ) else
13757: LD_STRING vulc_2
13759: PPUSH
13760: LD_INT 1
13762: PPUSH
13763: CALL_OW 101
13767: GO 13780
// AddMedal ( vulc_2 , - 1 ) ;
13769: LD_STRING vulc_2
13771: PPUSH
13772: LD_INT 1
13774: NEG
13775: PPUSH
13776: CALL_OW 101
// points := CalculateCommanderPoints ;
13780: LD_ADDR_VAR 0 2
13784: PUSH
13785: CALL 2259 0 0
13789: ST_TO_ADDR
// if points >= 2000 then
13790: LD_VAR 0 2
13794: PUSH
13795: LD_INT 2000
13797: GREATEREQUAL
13798: IFFALSE 13812
// AddMedal ( vulc_3 , 2 ) else
13800: LD_STRING vulc_3
13802: PPUSH
13803: LD_INT 2
13805: PPUSH
13806: CALL_OW 101
13810: GO 13845
// if points >= 0 then
13812: LD_VAR 0 2
13816: PUSH
13817: LD_INT 0
13819: GREATEREQUAL
13820: IFFALSE 13834
// AddMedal ( vulc_3 , 1 ) else
13822: LD_STRING vulc_3
13824: PPUSH
13825: LD_INT 1
13827: PPUSH
13828: CALL_OW 101
13832: GO 13845
// AddMedal ( vulc_3 , - 1 ) ;
13834: LD_STRING vulc_3
13836: PPUSH
13837: LD_INT 1
13839: NEG
13840: PPUSH
13841: CALL_OW 101
// GiveMedals ( MAIN ) ;
13845: LD_STRING MAIN
13847: PPUSH
13848: CALL_OW 102
// YouWin ;
13852: CALL_OW 103
// end ; end_of_file
13856: LD_VAR 0 1
13860: RET
// every 0 0$01 trigger FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) > 0 do var i , un ;
13861: LD_INT 13
13863: PPUSH
13864: LD_INT 21
13866: PUSH
13867: LD_INT 1
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PPUSH
13874: CALL_OW 70
13878: PUSH
13879: LD_INT 0
13881: GREATER
13882: IFFALSE 13949
13884: GO 13886
13886: DISABLE
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
// begin enable ;
13891: ENABLE
// for i in FilterUnitsInArea ( vulcano_area , [ f_type , unit_human ] ) do
13892: LD_ADDR_VAR 0 1
13896: PUSH
13897: LD_INT 13
13899: PPUSH
13900: LD_INT 21
13902: PUSH
13903: LD_INT 1
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PPUSH
13910: CALL_OW 70
13914: PUSH
13915: FOR_IN
13916: IFFALSE 13947
// if GetLives ( i ) > 4 then
13918: LD_VAR 0 1
13922: PPUSH
13923: CALL_OW 256
13927: PUSH
13928: LD_INT 4
13930: GREATER
13931: IFFALSE 13945
// SetLives ( i , 4 ) ;
13933: LD_VAR 0 1
13937: PPUSH
13938: LD_INT 4
13940: PPUSH
13941: CALL_OW 234
13945: GO 13915
13947: POP
13948: POP
// end ;
13949: PPOPN 2
13951: END
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
13952: LD_VAR 0 1
13956: PPUSH
13957: CALL_OW 255
13961: PUSH
13962: LD_OWVAR 2
13966: EQUAL
13967: IFFALSE 13977
// player_res_art := true ;
13969: LD_ADDR_EXP 6
13973: PUSH
13974: LD_INT 1
13976: ST_TO_ADDR
// end ;
13977: PPOPN 1
13979: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_res_art do var x , y , lab ;
13980: LD_INT 22
13982: PUSH
13983: LD_OWVAR 2
13987: PUSH
13988: EMPTY
13989: LIST
13990: LIST
13991: PUSH
13992: LD_INT 2
13994: PUSH
13995: LD_INT 30
13997: PUSH
13998: LD_INT 8
14000: PUSH
14001: EMPTY
14002: LIST
14003: LIST
14004: PUSH
14005: LD_INT 30
14007: PUSH
14008: LD_INT 11
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: LIST
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PPUSH
14024: CALL_OW 69
14028: PUSH
14029: LD_EXP 6
14033: AND
14034: IFFALSE 14378
14036: GO 14038
14038: DISABLE
14039: LD_INT 0
14041: PPUSH
14042: PPUSH
14043: PPUSH
// begin enable ;
14044: ENABLE
// x := FindArtifact ( 1 ) [ 1 ] ;
14045: LD_ADDR_VAR 0 1
14049: PUSH
14050: LD_INT 1
14052: PPUSH
14053: CALL_OW 469
14057: PUSH
14058: LD_INT 1
14060: ARRAY
14061: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14062: LD_ADDR_VAR 0 2
14066: PUSH
14067: LD_INT 1
14069: PPUSH
14070: CALL_OW 469
14074: PUSH
14075: LD_INT 2
14077: ARRAY
14078: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14079: LD_ADDR_VAR 0 3
14083: PUSH
14084: LD_INT 22
14086: PUSH
14087: LD_OWVAR 2
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: PUSH
14096: LD_INT 2
14098: PUSH
14099: LD_INT 30
14101: PUSH
14102: LD_INT 8
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: PUSH
14109: LD_INT 30
14111: PUSH
14112: LD_INT 11
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: LIST
14123: PUSH
14124: EMPTY
14125: LIST
14126: LIST
14127: PPUSH
14128: CALL_OW 69
14132: PPUSH
14133: LD_VAR 0 1
14137: PPUSH
14138: LD_VAR 0 2
14142: PPUSH
14143: CALL_OW 73
14147: ST_TO_ADDR
// if player_artifact_ready = false then
14148: LD_EXP 7
14152: PUSH
14153: LD_INT 0
14155: EQUAL
14156: IFFALSE 14262
// if GetDistUnitXY ( lab , x , y ) < 6 then
14158: LD_VAR 0 3
14162: PPUSH
14163: LD_VAR 0 1
14167: PPUSH
14168: LD_VAR 0 2
14172: PPUSH
14173: CALL_OW 297
14177: PUSH
14178: LD_INT 6
14180: LESS
14181: IFFALSE 14242
// begin if BuildingStatus ( lab ) = bs_idle then
14183: LD_VAR 0 3
14187: PPUSH
14188: CALL_OW 461
14192: PUSH
14193: LD_INT 2
14195: EQUAL
14196: IFFALSE 14220
// SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) else
14198: LD_OWVAR 2
14202: PPUSH
14203: LD_INT 1
14205: PPUSH
14206: LD_INT 2
14208: PPUSH
14209: LD_VAR 0 3
14213: PPUSH
14214: CALL_OW 468
14218: GO 14240
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14220: LD_OWVAR 2
14224: PPUSH
14225: LD_INT 1
14227: PPUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_VAR 0 3
14235: PPUSH
14236: CALL_OW 468
// end else
14240: GO 14262
// SetArtifactUse ( your_side , art_exp_left , art_gray , lab ) ;
14242: LD_OWVAR 2
14246: PPUSH
14247: LD_INT 1
14249: PPUSH
14250: LD_INT 1
14252: PPUSH
14253: LD_VAR 0 3
14257: PPUSH
14258: CALL_OW 468
// if player_artifact_ready then
14262: LD_EXP 7
14266: IFFALSE 14378
// if GetDistUnitXY ( lab , x , y ) < 6 then
14268: LD_VAR 0 3
14272: PPUSH
14273: LD_VAR 0 1
14277: PPUSH
14278: LD_VAR 0 2
14282: PPUSH
14283: CALL_OW 297
14287: PUSH
14288: LD_INT 6
14290: LESS
14291: IFFALSE 14356
// begin if BuildingStatus ( lab ) = bs_idle then
14293: LD_VAR 0 3
14297: PPUSH
14298: CALL_OW 461
14302: PUSH
14303: LD_INT 2
14305: EQUAL
14306: IFFALSE 14332
// SetArtifactUse ( your_side , art_icon , art_unit , lab ) else
14308: LD_OWVAR 2
14312: PPUSH
14313: LD_EXP 8
14317: PPUSH
14318: LD_INT 4
14320: PPUSH
14321: LD_VAR 0 3
14325: PPUSH
14326: CALL_OW 468
14330: GO 14354
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14332: LD_OWVAR 2
14336: PPUSH
14337: LD_EXP 8
14341: PPUSH
14342: LD_INT 1
14344: PPUSH
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 468
// end else
14354: GO 14378
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14356: LD_OWVAR 2
14360: PPUSH
14361: LD_EXP 8
14365: PPUSH
14366: LD_INT 1
14368: PPUSH
14369: LD_VAR 0 3
14373: PPUSH
14374: CALL_OW 468
// end ;
14378: PPOPN 3
14380: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var x , y , i , lab , side ;
14381: LD_INT 0
14383: PPUSH
14384: PPUSH
14385: PPUSH
14386: PPUSH
14387: PPUSH
// begin x := FindArtifact ( 1 ) [ 1 ] ;
14388: LD_ADDR_VAR 0 5
14392: PUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 469
14400: PUSH
14401: LD_INT 1
14403: ARRAY
14404: ST_TO_ADDR
// y := FindArtifact ( 1 ) [ 2 ] ;
14405: LD_ADDR_VAR 0 6
14409: PUSH
14410: LD_INT 1
14412: PPUSH
14413: CALL_OW 469
14417: PUSH
14418: LD_INT 2
14420: ARRAY
14421: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , x , y ) ;
14422: LD_ADDR_VAR 0 8
14426: PUSH
14427: LD_INT 22
14429: PUSH
14430: LD_OWVAR 2
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 2
14441: PUSH
14442: LD_INT 30
14444: PUSH
14445: LD_INT 8
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: PUSH
14452: LD_INT 30
14454: PUSH
14455: LD_INT 11
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: LIST
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PPUSH
14471: CALL_OW 69
14475: PPUSH
14476: LD_VAR 0 5
14480: PPUSH
14481: LD_VAR 0 6
14485: PPUSH
14486: CALL_OW 73
14490: ST_TO_ADDR
// if icon = art_exp_left then
14491: LD_VAR 0 2
14495: PUSH
14496: LD_INT 1
14498: EQUAL
14499: IFFALSE 14538
// begin SetSpecResearch ( lab , time_res_art , true ) ;
14501: LD_VAR 0 8
14505: PPUSH
14506: LD_EXP 9
14510: PPUSH
14511: LD_INT 1
14513: PPUSH
14514: CALL_OW 486
// SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14518: LD_OWVAR 2
14522: PPUSH
14523: LD_INT 1
14525: PPUSH
14526: LD_INT 0
14528: PPUSH
14529: LD_VAR 0 8
14533: PPUSH
14534: CALL_OW 468
// end ; if icon = art_icon then
14538: LD_VAR 0 2
14542: PUSH
14543: LD_EXP 8
14547: EQUAL
14548: IFFALSE 14754
// begin if cr1 in FilterAllUnits ( [ f_type , unit_building ] ) then
14550: LD_VAR 0 3
14554: PUSH
14555: LD_INT 21
14557: PUSH
14558: LD_INT 3
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: PPUSH
14565: CALL_OW 69
14569: IN
14570: IFFALSE 14754
// begin side := GetSide ( cr1 ) ;
14572: LD_ADDR_VAR 0 9
14576: PUSH
14577: LD_VAR 0 3
14581: PPUSH
14582: CALL_OW 255
14586: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_power ] ] ) > 0 then
14587: LD_INT 22
14589: PUSH
14590: LD_VAR 0 9
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PUSH
14599: LD_INT 30
14601: PUSH
14602: LD_INT 28
14604: PUSH
14605: EMPTY
14606: LIST
14607: LIST
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PPUSH
14613: CALL_OW 69
14617: PUSH
14618: LD_INT 0
14620: GREATER
14621: IFFALSE 14754
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_siberite_power ] ] ] ) do
14623: LD_ADDR_VAR 0 7
14627: PUSH
14628: LD_INT 22
14630: PUSH
14631: LD_VAR 0 9
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: LD_INT 2
14642: PUSH
14643: LD_INT 30
14645: PUSH
14646: LD_INT 26
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: PUSH
14653: LD_INT 30
14655: PUSH
14656: LD_INT 27
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 30
14665: PUSH
14666: LD_INT 28
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PPUSH
14683: CALL_OW 69
14687: PUSH
14688: FOR_IN
14689: IFFALSE 14705
// SetLives ( i , 1 ) ;
14691: LD_VAR 0 7
14695: PPUSH
14696: LD_INT 1
14698: PPUSH
14699: CALL_OW 234
14703: GO 14688
14705: POP
14706: POP
// player_res_art := false ;
14707: LD_ADDR_EXP 6
14711: PUSH
14712: LD_INT 0
14714: ST_TO_ADDR
// SetArtifactUse ( your_side , art_icon , art_gray , lab ) ;
14715: LD_OWVAR 2
14719: PPUSH
14720: LD_EXP 8
14724: PPUSH
14725: LD_INT 1
14727: PPUSH
14728: LD_VAR 0 8
14732: PPUSH
14733: CALL_OW 468
// Wait ( time_to_reuse ) ;
14737: LD_EXP 11
14741: PPUSH
14742: CALL_OW 67
// player_res_art := true ;
14746: LD_ADDR_EXP 6
14750: PUSH
14751: LD_INT 1
14753: ST_TO_ADDR
// end ; end ; end ; end ;
14754: PPOPN 9
14756: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
14757: LD_VAR 0 1
14761: PPUSH
14762: CALL_OW 255
14766: PUSH
14767: LD_OWVAR 2
14771: EQUAL
14772: IFFALSE 14809
// begin SetArtifactUse ( your_side , art_exp_left , art_no , lab ) ;
14774: LD_OWVAR 2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: LD_INT 0
14784: PPUSH
14785: LD_VAR 0 1
14789: PPUSH
14790: CALL_OW 468
// player_artifact_ready := true ;
14794: LD_ADDR_EXP 7
14798: PUSH
14799: LD_INT 1
14801: ST_TO_ADDR
// Hint ( ArtVulcano ) ;
14802: LD_STRING ArtVulcano
14804: PPUSH
14805: CALL_OW 339
// end ; end ;
14809: PPOPN 1
14811: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , art_exp_left , art_instant , lab ) ;
14812: LD_OWVAR 2
14816: PPUSH
14817: LD_INT 1
14819: PPUSH
14820: LD_INT 2
14822: PPUSH
14823: LD_VAR 0 1
14827: PPUSH
14828: CALL_OW 468
// end ; end_of_file
14832: PPOPN 2
14834: END
// every 0 0$01 do
14835: GO 14837
14837: DISABLE
// begin enable ;
14838: ENABLE
// Display_Strings := [ #tick , tick ] ;
14839: LD_ADDR_OWVAR 47
14843: PUSH
14844: LD_STRING #tick
14846: PUSH
14847: LD_OWVAR 1
14851: PUSH
14852: EMPTY
14853: LIST
14854: LIST
14855: ST_TO_ADDR
// end ; end_of_file
14856: END
// export al_commander , al_force , al_skill ; export function PrepareAlliance ; var i , filter , un , team ; begin
14857: LD_INT 0
14859: PPUSH
14860: PPUSH
14861: PPUSH
14862: PPUSH
14863: PPUSH
// al_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
14864: LD_ADDR_EXP 39
14868: PUSH
14869: LD_INT 7
14871: PUSH
14872: LD_INT 6
14874: PUSH
14875: LD_INT 5
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PUSH
14883: LD_OWVAR 67
14887: ARRAY
14888: ST_TO_ADDR
// al_force := [ ] ;
14889: LD_ADDR_EXP 38
14893: PUSH
14894: EMPTY
14895: ST_TO_ADDR
// RemoveAlliance ;
14896: CALL 15274 0 0
// ResetFog ;
14900: CALL_OW 335
// your_side := 7 ;
14904: LD_ADDR_OWVAR 2
14908: PUSH
14909: LD_INT 7
14911: ST_TO_ADDR
// uc_side := 7 ;
14912: LD_ADDR_OWVAR 20
14916: PUSH
14917: LD_INT 7
14919: ST_TO_ADDR
// hc_gallery :=  ;
14920: LD_ADDR_OWVAR 33
14924: PUSH
14925: LD_STRING 
14927: ST_TO_ADDR
// hc_name :=  ;
14928: LD_ADDR_OWVAR 26
14932: PUSH
14933: LD_STRING 
14935: ST_TO_ADDR
// hc_importance := 0 ;
14936: LD_ADDR_OWVAR 32
14940: PUSH
14941: LD_INT 0
14943: ST_TO_ADDR
// for i = 1 to 17 do
14944: LD_ADDR_VAR 0 2
14948: PUSH
14949: DOUBLE
14950: LD_INT 1
14952: DEC
14953: ST_TO_ADDR
14954: LD_INT 17
14956: PUSH
14957: FOR_TO
14958: IFFALSE 15038
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
14960: LD_ADDR_OWVAR 21
14964: PUSH
14965: LD_INT 1
14967: PUSH
14968: LD_INT 3
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PUSH
14975: LD_INT 1
14977: PPUSH
14978: LD_INT 2
14980: PPUSH
14981: CALL_OW 12
14985: ARRAY
14986: ST_TO_ADDR
// PrepareHuman ( false , Rand ( 1 , 4 ) , al_skill ) ;
14987: LD_INT 0
14989: PPUSH
14990: LD_INT 1
14992: PPUSH
14993: LD_INT 4
14995: PPUSH
14996: CALL_OW 12
15000: PPUSH
15001: LD_EXP 39
15005: PPUSH
15006: CALL_OW 380
// un := CreateHuman ;
15010: LD_ADDR_VAR 0 4
15014: PUSH
15015: CALL_OW 44
15019: ST_TO_ADDR
// al_force := al_force ^ un ;
15020: LD_ADDR_EXP 38
15024: PUSH
15025: LD_EXP 38
15029: PUSH
15030: LD_VAR 0 4
15034: ADD
15035: ST_TO_ADDR
// end ;
15036: GO 14957
15038: POP
15039: POP
// hc_importance := 100 ;
15040: LD_ADDR_OWVAR 32
15044: PUSH
15045: LD_INT 100
15047: ST_TO_ADDR
// uc_nation := 1 ;
15048: LD_ADDR_OWVAR 21
15052: PUSH
15053: LD_INT 1
15055: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , al_skill ) ;
15056: LD_INT 1
15058: PPUSH
15059: LD_INT 1
15061: PPUSH
15062: LD_EXP 39
15066: PPUSH
15067: CALL_OW 380
// al_commander := CreateHuman ;
15071: LD_ADDR_EXP 37
15075: PUSH
15076: CALL_OW 44
15080: ST_TO_ADDR
// player_commander := al_commander ;
15081: LD_ADDR_EXP 10
15085: PUSH
15086: LD_EXP 37
15090: ST_TO_ADDR
// team := CharacterSelection ( text , [ 9 , 9 , 8 ] [ Difficulty ] , [ 9 , 9 , 8 ] [ Difficulty ] , [ sel_change_class , al_commander , sel_changeable , sel_not_hired ] ^ al_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_bazooker , class_sniper ] ) ;
15091: LD_ADDR_VAR 0 5
15095: PUSH
15096: LD_STRING text
15098: PPUSH
15099: LD_INT 9
15101: PUSH
15102: LD_INT 9
15104: PUSH
15105: LD_INT 8
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: LIST
15112: PUSH
15113: LD_OWVAR 67
15117: ARRAY
15118: PPUSH
15119: LD_INT 9
15121: PUSH
15122: LD_INT 9
15124: PUSH
15125: LD_INT 8
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: LIST
15132: PUSH
15133: LD_OWVAR 67
15137: ARRAY
15138: PPUSH
15139: LD_INT -5
15141: PUSH
15142: LD_EXP 37
15146: PUSH
15147: LD_INT -3
15149: PUSH
15150: LD_INT -2
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: PUSH
15159: LD_EXP 38
15163: ADD
15164: PPUSH
15165: LD_INT 1
15167: PUSH
15168: LD_INT 3
15170: PUSH
15171: LD_INT 2
15173: PUSH
15174: LD_INT 1
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: LD_INT 4
15183: PUSH
15184: LD_INT 1
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: PUSH
15191: LD_INT 9
15193: PUSH
15194: LD_INT 5
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: PPUSH
15205: CALL_OW 42
15209: ST_TO_ADDR
// team := team ^ al_commander ;
15210: LD_ADDR_VAR 0 5
15214: PUSH
15215: LD_VAR 0 5
15219: PUSH
15220: LD_EXP 37
15224: ADD
15225: ST_TO_ADDR
// for i = 1 to team do
15226: LD_ADDR_VAR 0 2
15230: PUSH
15231: DOUBLE
15232: LD_INT 1
15234: DEC
15235: ST_TO_ADDR
15236: LD_VAR 0 5
15240: PUSH
15241: FOR_TO
15242: IFFALSE 15267
// PlaceUnitArea ( team [ i ] , south_resp , false ) ;
15244: LD_VAR 0 5
15248: PUSH
15249: LD_VAR 0 2
15253: ARRAY
15254: PPUSH
15255: LD_INT 15
15257: PPUSH
15258: LD_INT 0
15260: PPUSH
15261: CALL_OW 49
15265: GO 15241
15267: POP
15268: POP
// end ;
15269: LD_VAR 0 1
15273: RET
// export function RemoveAlliance ; var i ; begin
15274: LD_INT 0
15276: PPUSH
15277: PPUSH
// DestroyUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
15278: LD_INT 22
15280: PUSH
15281: LD_INT 7
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PUSH
15288: LD_INT 30
15290: PUSH
15291: LD_INT 1
15293: PUSH
15294: EMPTY
15295: LIST
15296: LIST
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PPUSH
15302: CALL_OW 69
15306: PUSH
15307: LD_INT 1
15309: ARRAY
15310: PPUSH
15311: CALL_OW 65
// for i in FilterAllUnits ( [ f_side , 7 ] ) do
15315: LD_ADDR_VAR 0 2
15319: PUSH
15320: LD_INT 22
15322: PUSH
15323: LD_INT 7
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: PPUSH
15330: CALL_OW 69
15334: PUSH
15335: FOR_IN
15336: IFFALSE 15349
// RemoveUnit ( i ) ;
15338: LD_VAR 0 2
15342: PPUSH
15343: CALL_OW 64
15347: GO 15335
15349: POP
15350: POP
// end ;
15351: LD_VAR 0 1
15355: RET
// export function PrepareAllianceAI ; var i , un , b ; begin
15356: LD_INT 0
15358: PPUSH
15359: PPUSH
15360: PPUSH
15361: PPUSH
// SetTech ( tech_lapser , 7 , state_researched ) ;
15362: LD_INT 31
15364: PPUSH
15365: LD_INT 7
15367: PPUSH
15368: LD_INT 2
15370: PPUSH
15371: CALL_OW 322
// SetTech ( tech_ai , 7 , state_researched ) ;
15375: LD_INT 32
15377: PPUSH
15378: LD_INT 7
15380: PPUSH
15381: LD_INT 2
15383: PPUSH
15384: CALL_OW 322
// SetTech ( tech_comp3 , 7 , state_researched ) ;
15388: LD_INT 59
15390: PPUSH
15391: LD_INT 7
15393: PPUSH
15394: LD_INT 2
15396: PPUSH
15397: CALL_OW 322
// al_skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15401: LD_ADDR_EXP 39
15405: PUSH
15406: LD_INT 5
15408: PUSH
15409: LD_INT 6
15411: PUSH
15412: LD_INT 7
15414: PUSH
15415: EMPTY
15416: LIST
15417: LIST
15418: LIST
15419: PUSH
15420: LD_OWVAR 67
15424: ARRAY
15425: ST_TO_ADDR
// al_force := [ ] ;
15426: LD_ADDR_EXP 38
15430: PUSH
15431: EMPTY
15432: ST_TO_ADDR
// al_vehs := [ ] ;
15433: LD_ADDR_EXP 44
15437: PUSH
15438: EMPTY
15439: ST_TO_ADDR
// uc_side := 7 ;
15440: LD_ADDR_OWVAR 20
15444: PUSH
15445: LD_INT 7
15447: ST_TO_ADDR
// uc_nation := 1 ;
15448: LD_ADDR_OWVAR 21
15452: PUSH
15453: LD_INT 1
15455: ST_TO_ADDR
// bc_type := b_oil_mine ;
15456: LD_ADDR_OWVAR 42
15460: PUSH
15461: LD_INT 29
15463: ST_TO_ADDR
// b := CreateBuilding ;
15464: LD_ADDR_VAR 0 4
15468: PUSH
15469: CALL_OW 46
15473: ST_TO_ADDR
// PlaceUnitXYR ( b , 61 , 7 , 0 , false ) ;
15474: LD_VAR 0 4
15478: PPUSH
15479: LD_INT 61
15481: PPUSH
15482: LD_INT 7
15484: PPUSH
15485: LD_INT 0
15487: PPUSH
15488: LD_INT 0
15490: PPUSH
15491: CALL_OW 50
// bc_type := b_siberite_mine ;
15495: LD_ADDR_OWVAR 42
15499: PUSH
15500: LD_INT 30
15502: ST_TO_ADDR
// b := CreateBuilding ;
15503: LD_ADDR_VAR 0 4
15507: PUSH
15508: CALL_OW 46
15512: ST_TO_ADDR
// PlaceUnitXYR ( b , 69 , 13 , 0 , false ) ;
15513: LD_VAR 0 4
15517: PPUSH
15518: LD_INT 69
15520: PPUSH
15521: LD_INT 13
15523: PPUSH
15524: LD_INT 0
15526: PPUSH
15527: LD_INT 0
15529: PPUSH
15530: CALL_OW 50
// hc_gallery :=  ;
15534: LD_ADDR_OWVAR 33
15538: PUSH
15539: LD_STRING 
15541: ST_TO_ADDR
// hc_name :=  ;
15542: LD_ADDR_OWVAR 26
15546: PUSH
15547: LD_STRING 
15549: ST_TO_ADDR
// hc_importance := 0 ;
15550: LD_ADDR_OWVAR 32
15554: PUSH
15555: LD_INT 0
15557: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_bunker ] ] ) do
15558: LD_ADDR_VAR 0 2
15562: PUSH
15563: LD_INT 22
15565: PUSH
15566: LD_INT 7
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PUSH
15573: LD_INT 30
15575: PUSH
15576: LD_INT 32
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PPUSH
15587: CALL_OW 69
15591: PUSH
15592: FOR_IN
15593: IFFALSE 15663
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15595: LD_ADDR_OWVAR 21
15599: PUSH
15600: LD_INT 1
15602: PUSH
15603: LD_INT 3
15605: PUSH
15606: EMPTY
15607: LIST
15608: LIST
15609: PUSH
15610: LD_INT 1
15612: PPUSH
15613: LD_INT 2
15615: PPUSH
15616: CALL_OW 12
15620: ARRAY
15621: ST_TO_ADDR
// PrepareHuman ( false , 1 , al_skill ) ;
15622: LD_INT 0
15624: PPUSH
15625: LD_INT 1
15627: PPUSH
15628: LD_EXP 39
15632: PPUSH
15633: CALL_OW 380
// un := CreateHuman ;
15637: LD_ADDR_VAR 0 3
15641: PUSH
15642: CALL_OW 44
15646: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
15647: LD_VAR 0 3
15651: PPUSH
15652: LD_VAR 0 2
15656: PPUSH
15657: CALL_OW 52
// end ;
15661: GO 15592
15663: POP
15664: POP
// for i = 1 to 3 do
15665: LD_ADDR_VAR 0 2
15669: PUSH
15670: DOUBLE
15671: LD_INT 1
15673: DEC
15674: ST_TO_ADDR
15675: LD_INT 3
15677: PUSH
15678: FOR_TO
15679: IFFALSE 15747
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15681: LD_ADDR_OWVAR 21
15685: PUSH
15686: LD_INT 1
15688: PUSH
15689: LD_INT 3
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PUSH
15696: LD_INT 1
15698: PPUSH
15699: LD_INT 2
15701: PPUSH
15702: CALL_OW 12
15706: ARRAY
15707: ST_TO_ADDR
// PrepareHuman ( false , 4 , al_skill ) ;
15708: LD_INT 0
15710: PPUSH
15711: LD_INT 4
15713: PPUSH
15714: LD_EXP 39
15718: PPUSH
15719: CALL_OW 380
// un := CreateHuman ;
15723: LD_ADDR_VAR 0 3
15727: PUSH
15728: CALL_OW 44
15732: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_lab1 ) ;
15733: LD_VAR 0 3
15737: PPUSH
15738: LD_INT 164
15740: PPUSH
15741: CALL_OW 52
// end ;
15745: GO 15678
15747: POP
15748: POP
// for i = 1 to 6 do
15749: LD_ADDR_VAR 0 2
15753: PUSH
15754: DOUBLE
15755: LD_INT 1
15757: DEC
15758: ST_TO_ADDR
15759: LD_INT 6
15761: PUSH
15762: FOR_TO
15763: IFFALSE 15854
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15765: LD_ADDR_OWVAR 21
15769: PUSH
15770: LD_INT 1
15772: PUSH
15773: LD_INT 3
15775: PUSH
15776: EMPTY
15777: LIST
15778: LIST
15779: PUSH
15780: LD_INT 1
15782: PPUSH
15783: LD_INT 2
15785: PPUSH
15786: CALL_OW 12
15790: ARRAY
15791: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker , class_bazooker ] [ Rand ( 1 , 3 ) ] , al_skill ) ;
15792: LD_INT 0
15794: PPUSH
15795: LD_INT 5
15797: PUSH
15798: LD_INT 9
15800: PUSH
15801: LD_INT 9
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: LIST
15808: PUSH
15809: LD_INT 1
15811: PPUSH
15812: LD_INT 3
15814: PPUSH
15815: CALL_OW 12
15819: ARRAY
15820: PPUSH
15821: LD_EXP 39
15825: PPUSH
15826: CALL_OW 380
// un := CreateHuman ;
15830: LD_ADDR_VAR 0 3
15834: PUSH
15835: CALL_OW 44
15839: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_bar ) ;
15840: LD_VAR 0 3
15844: PPUSH
15845: LD_INT 173
15847: PPUSH
15848: CALL_OW 52
// end ;
15852: GO 15762
15854: POP
15855: POP
// for i = 1 to 6 do
15856: LD_ADDR_VAR 0 2
15860: PUSH
15861: DOUBLE
15862: LD_INT 1
15864: DEC
15865: ST_TO_ADDR
15866: LD_INT 6
15868: PUSH
15869: FOR_TO
15870: IFFALSE 15968
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15872: LD_ADDR_OWVAR 21
15876: PUSH
15877: LD_INT 1
15879: PUSH
15880: LD_INT 3
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: LD_INT 1
15889: PPUSH
15890: LD_INT 2
15892: PPUSH
15893: CALL_OW 12
15897: ARRAY
15898: ST_TO_ADDR
// PrepareHuman ( false , 3 , al_skill ) ;
15899: LD_INT 0
15901: PPUSH
15902: LD_INT 3
15904: PPUSH
15905: LD_EXP 39
15909: PPUSH
15910: CALL_OW 380
// un := CreateHuman ;
15914: LD_ADDR_VAR 0 3
15918: PUSH
15919: CALL_OW 44
15923: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
15924: LD_VAR 0 3
15928: PPUSH
15929: LD_INT 22
15931: PUSH
15932: LD_INT 7
15934: PUSH
15935: EMPTY
15936: LIST
15937: LIST
15938: PUSH
15939: LD_INT 30
15941: PUSH
15942: LD_INT 3
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: PPUSH
15953: CALL_OW 69
15957: PUSH
15958: LD_INT 1
15960: ARRAY
15961: PPUSH
15962: CALL_OW 52
// end ;
15966: GO 15869
15968: POP
15969: POP
// for i = 1 to 4 do
15970: LD_ADDR_VAR 0 2
15974: PUSH
15975: DOUBLE
15976: LD_INT 1
15978: DEC
15979: ST_TO_ADDR
15980: LD_INT 4
15982: PUSH
15983: FOR_TO
15984: IFFALSE 16052
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
15986: LD_ADDR_OWVAR 21
15990: PUSH
15991: LD_INT 1
15993: PUSH
15994: LD_INT 3
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: LD_INT 1
16003: PPUSH
16004: LD_INT 2
16006: PPUSH
16007: CALL_OW 12
16011: ARRAY
16012: ST_TO_ADDR
// PrepareHuman ( false , 2 , al_skill ) ;
16013: LD_INT 0
16015: PPUSH
16016: LD_INT 2
16018: PPUSH
16019: LD_EXP 39
16023: PPUSH
16024: CALL_OW 380
// un := CreateHuman ;
16028: LD_ADDR_VAR 0 3
16032: PUSH
16033: CALL_OW 44
16037: ST_TO_ADDR
// PlaceHumanInUnit ( un , al_depot ) ;
16038: LD_VAR 0 3
16042: PPUSH
16043: LD_INT 162
16045: PPUSH
16046: CALL_OW 52
// end ;
16050: GO 15983
16052: POP
16053: POP
// uc_nation := 3 ;
16054: LD_ADDR_OWVAR 21
16058: PUSH
16059: LD_INT 3
16061: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
16062: LD_ADDR_OWVAR 37
16066: PUSH
16067: LD_INT 21
16069: ST_TO_ADDR
// vc_engine := engine_siberite ;
16070: LD_ADDR_OWVAR 39
16074: PUSH
16075: LD_INT 3
16077: ST_TO_ADDR
// vc_control := control_computer ;
16078: LD_ADDR_OWVAR 38
16082: PUSH
16083: LD_INT 3
16085: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
16086: LD_ADDR_OWVAR 40
16090: PUSH
16091: LD_INT 51
16093: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 49 , 13 , false ) ;
16094: CALL_OW 45
16098: PPUSH
16099: LD_INT 49
16101: PPUSH
16102: LD_INT 13
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL_OW 48
// al_turrets := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) ;
16112: LD_ADDR_EXP 46
16116: PUSH
16117: LD_INT 22
16119: PUSH
16120: LD_INT 7
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: PUSH
16127: LD_INT 30
16129: PUSH
16130: LD_INT 33
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: PPUSH
16141: CALL_OW 69
16145: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) do
16146: LD_ADDR_VAR 0 2
16150: PUSH
16151: DOUBLE
16152: LD_INT 1
16154: DEC
16155: ST_TO_ADDR
16156: LD_INT 22
16158: PUSH
16159: LD_INT 7
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 30
16168: PUSH
16169: LD_INT 33
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 35
16178: PUSH
16179: LD_INT 0
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: PUSH
16191: EMPTY
16192: LIST
16193: PPUSH
16194: CALL_OW 69
16198: PUSH
16199: FOR_TO
16200: IFFALSE 16260
// AddComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 7 ] , [ f_btype , b_turret ] , [ f_bweapon , 0 ] ] ] ) [ i ] , ru_time_lapser ) ;
16202: LD_INT 22
16204: PUSH
16205: LD_INT 7
16207: PUSH
16208: EMPTY
16209: LIST
16210: LIST
16211: PUSH
16212: LD_INT 30
16214: PUSH
16215: LD_INT 33
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: PUSH
16222: LD_INT 35
16224: PUSH
16225: LD_INT 0
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: PUSH
16232: EMPTY
16233: LIST
16234: LIST
16235: LIST
16236: PUSH
16237: EMPTY
16238: LIST
16239: PPUSH
16240: CALL_OW 69
16244: PUSH
16245: LD_VAR 0 2
16249: ARRAY
16250: PPUSH
16251: LD_INT 49
16253: PPUSH
16254: CALL_OW 208
16258: GO 16199
16260: POP
16261: POP
// end ;
16262: LD_VAR 0 1
16266: RET
// export al_eng , al_sold , al_mech , al_sci ; export al_vehs , al_cargo , al_turrets ; export al_dep , al_lab , al_fac ; export al_bul ; every 0 0$01 trigger your_side = 1 do var i , un , veh , cr ;
16267: LD_OWVAR 2
16271: PUSH
16272: LD_INT 1
16274: EQUAL
16275: IFFALSE 17443
16277: GO 16279
16279: DISABLE
16280: LD_INT 0
16282: PPUSH
16283: PPUSH
16284: PPUSH
16285: PPUSH
// begin enable ;
16286: ENABLE
// al_bul := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) ;
16287: LD_ADDR_EXP 50
16291: PUSH
16292: LD_INT 22
16294: PUSH
16295: LD_INT 7
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 21
16304: PUSH
16305: LD_INT 3
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: PPUSH
16316: CALL_OW 69
16320: ST_TO_ADDR
// al_lab := [ al_lab1 , al_lab2 ] ;
16321: LD_ADDR_EXP 48
16325: PUSH
16326: LD_INT 164
16328: PUSH
16329: LD_INT 197
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: ST_TO_ADDR
// al_dep := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16336: LD_ADDR_EXP 47
16340: PUSH
16341: LD_INT 22
16343: PUSH
16344: LD_INT 7
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 30
16353: PUSH
16354: LD_INT 1
16356: PUSH
16357: EMPTY
16358: LIST
16359: LIST
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: PPUSH
16365: CALL_OW 69
16369: PUSH
16370: LD_INT 1
16372: ARRAY
16373: ST_TO_ADDR
// al_fac := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16374: LD_ADDR_EXP 49
16378: PUSH
16379: LD_INT 22
16381: PUSH
16382: LD_INT 7
16384: PUSH
16385: EMPTY
16386: LIST
16387: LIST
16388: PUSH
16389: LD_INT 30
16391: PUSH
16392: LD_INT 3
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: EMPTY
16400: LIST
16401: LIST
16402: PPUSH
16403: CALL_OW 69
16407: PUSH
16408: LD_INT 1
16410: ARRAY
16411: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) then
16412: LD_INT 22
16414: PUSH
16415: LD_INT 7
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 34
16424: PUSH
16425: LD_INT 51
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PPUSH
16436: CALL_OW 69
16440: IFFALSE 16480
// al_cargo := FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
16442: LD_ADDR_EXP 45
16446: PUSH
16447: LD_INT 22
16449: PUSH
16450: LD_INT 7
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: PUSH
16457: LD_INT 34
16459: PUSH
16460: LD_INT 51
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PPUSH
16471: CALL_OW 69
16475: PUSH
16476: LD_INT 1
16478: ARRAY
16479: ST_TO_ADDR
// al_sold := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , class_bazooker ] ] ) ;
16480: LD_ADDR_EXP 41
16484: PUSH
16485: LD_INT 22
16487: PUSH
16488: LD_INT 7
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: PUSH
16495: LD_INT 25
16497: PUSH
16498: LD_INT 9
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: PPUSH
16509: CALL_OW 69
16513: ST_TO_ADDR
// al_eng := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 2 ] ] ) ;
16514: LD_ADDR_EXP 40
16518: PUSH
16519: LD_INT 22
16521: PUSH
16522: LD_INT 7
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PUSH
16529: LD_INT 25
16531: PUSH
16532: LD_INT 2
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: PPUSH
16543: CALL_OW 69
16547: ST_TO_ADDR
// al_mech := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 3 ] ] ) ;
16548: LD_ADDR_EXP 42
16552: PUSH
16553: LD_INT 22
16555: PUSH
16556: LD_INT 7
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PUSH
16563: LD_INT 25
16565: PUSH
16566: LD_INT 3
16568: PUSH
16569: EMPTY
16570: LIST
16571: LIST
16572: PUSH
16573: EMPTY
16574: LIST
16575: LIST
16576: PPUSH
16577: CALL_OW 69
16581: ST_TO_ADDR
// al_sci := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] ] ) ;
16582: LD_ADDR_EXP 43
16586: PUSH
16587: LD_INT 22
16589: PUSH
16590: LD_INT 7
16592: PUSH
16593: EMPTY
16594: LIST
16595: LIST
16596: PUSH
16597: LD_INT 25
16599: PUSH
16600: LD_INT 4
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: PUSH
16607: EMPTY
16608: LIST
16609: LIST
16610: PPUSH
16611: CALL_OW 69
16615: ST_TO_ADDR
// IntBazooka ( al_sold , FilterAllUnits ( [ f_enemy , 7 ] ) ) ;
16616: LD_EXP 41
16620: PPUSH
16621: LD_INT 81
16623: PUSH
16624: LD_INT 7
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PPUSH
16631: CALL_OW 69
16635: PPUSH
16636: CALL 1656 0 2
// if not HasTask ( al_cargo ) and GetCargo ( al_cargo , mat_cans ) < 100 then
16640: LD_EXP 45
16644: PPUSH
16645: CALL_OW 314
16649: NOT
16650: PUSH
16651: LD_EXP 45
16655: PPUSH
16656: LD_INT 1
16658: PPUSH
16659: CALL_OW 289
16663: PUSH
16664: LD_INT 100
16666: LESS
16667: AND
16668: IFFALSE 16716
// begin cr := GetListOfCratesInArea ( us_crates ) ;
16670: LD_ADDR_VAR 0 4
16674: PUSH
16675: LD_INT 12
16677: PPUSH
16678: CALL_OW 435
16682: ST_TO_ADDR
// if cr then
16683: LD_VAR 0 4
16687: IFFALSE 16716
// ComCollect ( al_cargo , cr [ 1 ] , cr [ 2 ] ) ;
16689: LD_EXP 45
16693: PPUSH
16694: LD_VAR 0 4
16698: PUSH
16699: LD_INT 1
16701: ARRAY
16702: PPUSH
16703: LD_VAR 0 4
16707: PUSH
16708: LD_INT 2
16710: ARRAY
16711: PPUSH
16712: CALL_OW 117
// end ; if UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) then
16716: LD_EXP 50
16720: PPUSH
16721: LD_INT 3
16723: PUSH
16724: LD_INT 24
16726: PUSH
16727: LD_INT 1000
16729: PUSH
16730: EMPTY
16731: LIST
16732: LIST
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: PPUSH
16738: CALL_OW 72
16742: IFFALSE 16872
// begin if al_eng then
16744: LD_EXP 40
16748: IFFALSE 16870
// for i = 1 to al_eng do
16750: LD_ADDR_VAR 0 1
16754: PUSH
16755: DOUBLE
16756: LD_INT 1
16758: DEC
16759: ST_TO_ADDR
16760: LD_EXP 40
16764: PUSH
16765: FOR_TO
16766: IFFALSE 16868
// if IsInUnit ( al_eng [ i ] ) then
16768: LD_EXP 40
16772: PUSH
16773: LD_VAR 0 1
16777: ARRAY
16778: PPUSH
16779: CALL_OW 310
16783: IFFALSE 16802
// ComExitBuilding ( al_eng [ i ] ) else
16785: LD_EXP 40
16789: PUSH
16790: LD_VAR 0 1
16794: ARRAY
16795: PPUSH
16796: CALL_OW 122
16800: GO 16866
// if not HasTask ( al_eng [ i ] ) then
16802: LD_EXP 40
16806: PUSH
16807: LD_VAR 0 1
16811: ARRAY
16812: PPUSH
16813: CALL_OW 314
16817: NOT
16818: IFFALSE 16866
// ComRepairBuilding ( al_eng [ i ] , UnitFilter ( al_bul , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
16820: LD_EXP 40
16824: PUSH
16825: LD_VAR 0 1
16829: ARRAY
16830: PPUSH
16831: LD_EXP 50
16835: PPUSH
16836: LD_INT 3
16838: PUSH
16839: LD_INT 24
16841: PUSH
16842: LD_INT 1000
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 130
16866: GO 16765
16868: POP
16869: POP
// end else
16870: GO 16954
// if al_eng then
16872: LD_EXP 40
16876: IFFALSE 16954
// if not IsInUnit ( al_eng [ 1 ] ) then
16878: LD_EXP 40
16882: PUSH
16883: LD_INT 1
16885: ARRAY
16886: PPUSH
16887: CALL_OW 310
16891: NOT
16892: IFFALSE 16954
// for i = 1 to al_eng do
16894: LD_ADDR_VAR 0 1
16898: PUSH
16899: DOUBLE
16900: LD_INT 1
16902: DEC
16903: ST_TO_ADDR
16904: LD_EXP 40
16908: PUSH
16909: FOR_TO
16910: IFFALSE 16952
// if not IsInUnit ( al_eng [ i ] ) then
16912: LD_EXP 40
16916: PUSH
16917: LD_VAR 0 1
16921: ARRAY
16922: PPUSH
16923: CALL_OW 310
16927: NOT
16928: IFFALSE 16950
// ComEnterUnit ( al_eng [ i ] , al_dep ) ;
16930: LD_EXP 40
16934: PUSH
16935: LD_VAR 0 1
16939: ARRAY
16940: PPUSH
16941: LD_EXP 47
16945: PPUSH
16946: CALL_OW 120
16950: GO 16909
16952: POP
16953: POP
// if al_vehs then
16954: LD_EXP 44
16958: IFFALSE 17058
// if BuildingStatus ( al_fac ) = bs_idle then
16960: LD_EXP 49
16964: PPUSH
16965: CALL_OW 461
16969: PUSH
16970: LD_INT 2
16972: EQUAL
16973: IFFALSE 17058
// begin ComConstruct ( al_fac , al_vehs [ 1 ] , al_vehs [ 2 ] , al_vehs [ 3 ] , al_vehs [ 4 ] ) ;
16975: LD_EXP 49
16979: PPUSH
16980: LD_EXP 44
16984: PUSH
16985: LD_INT 1
16987: ARRAY
16988: PPUSH
16989: LD_EXP 44
16993: PUSH
16994: LD_INT 2
16996: ARRAY
16997: PPUSH
16998: LD_EXP 44
17002: PUSH
17003: LD_INT 3
17005: ARRAY
17006: PPUSH
17007: LD_EXP 44
17011: PUSH
17012: LD_INT 4
17014: ARRAY
17015: PPUSH
17016: CALL_OW 125
// for i = 1 to 4 do
17020: LD_ADDR_VAR 0 1
17024: PUSH
17025: DOUBLE
17026: LD_INT 1
17028: DEC
17029: ST_TO_ADDR
17030: LD_INT 4
17032: PUSH
17033: FOR_TO
17034: IFFALSE 17056
// al_vehs := Delete ( al_vehs , 1 ) ;
17036: LD_ADDR_EXP 44
17040: PUSH
17041: LD_EXP 44
17045: PPUSH
17046: LD_INT 1
17048: PPUSH
17049: CALL_OW 3
17053: ST_TO_ADDR
17054: GO 17033
17056: POP
17057: POP
// end ; if al_force = 0 and tick mod 23100 = 0 then
17058: LD_EXP 38
17062: PUSH
17063: LD_INT 0
17065: EQUAL
17066: PUSH
17067: LD_OWVAR 1
17071: PUSH
17072: LD_INT 23100
17074: MOD
17075: PUSH
17076: LD_INT 0
17078: EQUAL
17079: AND
17080: IFFALSE 17194
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
17082: LD_ADDR_VAR 0 1
17086: PUSH
17087: DOUBLE
17088: LD_INT 1
17090: DEC
17091: ST_TO_ADDR
17092: LD_INT 4
17094: PUSH
17095: LD_INT 5
17097: PUSH
17098: LD_INT 6
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: LIST
17105: PUSH
17106: LD_OWVAR 67
17110: ARRAY
17111: PUSH
17112: FOR_TO
17113: IFFALSE 17192
// begin al_vehs := al_vehs ^ ru_heavy_wheeled ;
17115: LD_ADDR_EXP 44
17119: PUSH
17120: LD_EXP 44
17124: PUSH
17125: LD_INT 23
17127: ADD
17128: ST_TO_ADDR
// al_vehs := al_vehs ^ engine_combustion ;
17129: LD_ADDR_EXP 44
17133: PUSH
17134: LD_EXP 44
17138: PUSH
17139: LD_INT 1
17141: ADD
17142: ST_TO_ADDR
// al_vehs := al_vehs ^ control_computer ;
17143: LD_ADDR_EXP 44
17147: PUSH
17148: LD_EXP 44
17152: PUSH
17153: LD_INT 3
17155: ADD
17156: ST_TO_ADDR
// al_vehs := al_vehs ^ [ ru_heavy_gun , ru_rocket ] [ Rand ( 1 , 2 ) ] ;
17157: LD_ADDR_EXP 44
17161: PUSH
17162: LD_EXP 44
17166: PUSH
17167: LD_INT 46
17169: PUSH
17170: LD_INT 47
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: PUSH
17177: LD_INT 1
17179: PPUSH
17180: LD_INT 2
17182: PPUSH
17183: CALL_OW 12
17187: ARRAY
17188: ADD
17189: ST_TO_ADDR
// end ;
17190: GO 17112
17192: POP
17193: POP
// end ; if FilterAllUnits ( [ [ f_side , 7 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
17194: LD_INT 22
17196: PUSH
17197: LD_INT 7
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 34
17206: PUSH
17207: LD_INT 51
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PPUSH
17218: CALL_OW 69
17222: PUSH
17223: LD_INT 0
17225: EQUAL
17226: IFFALSE 17249
// ComConstruct ( al_fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) ;
17228: LD_EXP 49
17232: PPUSH
17233: LD_INT 21
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: LD_INT 3
17241: PPUSH
17242: LD_INT 51
17244: PPUSH
17245: CALL_OW 125
// if al_force and tick mod 25200 = 0 then
17249: LD_EXP 38
17253: PUSH
17254: LD_OWVAR 1
17258: PUSH
17259: LD_INT 25200
17261: MOD
17262: PUSH
17263: LD_INT 0
17265: EQUAL
17266: AND
17267: IFFALSE 17330
// begin for i = 1 to al_force do
17269: LD_ADDR_VAR 0 1
17273: PUSH
17274: DOUBLE
17275: LD_INT 1
17277: DEC
17278: ST_TO_ADDR
17279: LD_EXP 38
17283: PUSH
17284: FOR_TO
17285: IFFALSE 17328
// if GetTag ( al_force [ i ] ) <> 11 then
17287: LD_EXP 38
17291: PUSH
17292: LD_VAR 0 1
17296: ARRAY
17297: PPUSH
17298: CALL_OW 110
17302: PUSH
17303: LD_INT 11
17305: NONEQUAL
17306: IFFALSE 17326
// SetTag ( al_force [ i ] , 11 ) ;
17308: LD_EXP 38
17312: PUSH
17313: LD_VAR 0 1
17317: ARRAY
17318: PPUSH
17319: LD_INT 11
17321: PPUSH
17322: CALL_OW 109
17326: GO 17284
17328: POP
17329: POP
// end ; if al_force then
17330: LD_EXP 38
17334: IFFALSE 17443
// for i = 1 to al_force do
17336: LD_ADDR_VAR 0 1
17340: PUSH
17341: DOUBLE
17342: LD_INT 1
17344: DEC
17345: ST_TO_ADDR
17346: LD_EXP 38
17350: PUSH
17351: FOR_TO
17352: IFFALSE 17441
// begin if GetTag ( al_force [ i ] ) = 11 then
17354: LD_EXP 38
17358: PUSH
17359: LD_VAR 0 1
17363: ARRAY
17364: PPUSH
17365: CALL_OW 110
17369: PUSH
17370: LD_INT 11
17372: EQUAL
17373: IFFALSE 17439
// begin if not HasTask ( al_force [ i ] ) then
17375: LD_EXP 38
17379: PUSH
17380: LD_VAR 0 1
17384: ARRAY
17385: PPUSH
17386: CALL_OW 314
17390: NOT
17391: IFFALSE 17439
// ComAttackUnit ( al_force [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , al_force [ i ] ) ) ;
17393: LD_EXP 38
17397: PUSH
17398: LD_VAR 0 1
17402: ARRAY
17403: PPUSH
17404: LD_INT 81
17406: PUSH
17407: LD_INT 7
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: PPUSH
17414: CALL_OW 69
17418: PPUSH
17419: LD_EXP 38
17423: PUSH
17424: LD_VAR 0 1
17428: ARRAY
17429: PPUSH
17430: CALL_OW 74
17434: PPUSH
17435: CALL_OW 115
// end ; end ;
17439: GO 17351
17441: POP
17442: POP
// end ; end_of_file
17443: PPOPN 4
17445: END
// export ar_commander , ar_force , ar_skill ; export function PrepareArabian ; var i , filter , un , team ; begin
17446: LD_INT 0
17448: PPUSH
17449: PPUSH
17450: PPUSH
17451: PPUSH
17452: PPUSH
// ar_skill := [ 7 , 6 , 5 ] [ Difficulty ] ;
17453: LD_ADDR_EXP 53
17457: PUSH
17458: LD_INT 7
17460: PUSH
17461: LD_INT 6
17463: PUSH
17464: LD_INT 5
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: PUSH
17472: LD_OWVAR 67
17476: ARRAY
17477: ST_TO_ADDR
// ar_force := [ ] ;
17478: LD_ADDR_EXP 52
17482: PUSH
17483: EMPTY
17484: ST_TO_ADDR
// RemoveAlliance ;
17485: CALL 15274 0 0
// RemoveEnvironmentArea ( evn ) ;
17489: LD_INT 17
17491: PPUSH
17492: CALL_OW 355
// your_side := 2 ;
17496: LD_ADDR_OWVAR 2
17500: PUSH
17501: LD_INT 2
17503: ST_TO_ADDR
// uc_side := 2 ;
17504: LD_ADDR_OWVAR 20
17508: PUSH
17509: LD_INT 2
17511: ST_TO_ADDR
// uc_nation := nation_arabian ;
17512: LD_ADDR_OWVAR 21
17516: PUSH
17517: LD_INT 2
17519: ST_TO_ADDR
// hc_gallery :=  ;
17520: LD_ADDR_OWVAR 33
17524: PUSH
17525: LD_STRING 
17527: ST_TO_ADDR
// hc_name :=  ;
17528: LD_ADDR_OWVAR 26
17532: PUSH
17533: LD_STRING 
17535: ST_TO_ADDR
// hc_importance := 0 ;
17536: LD_ADDR_OWVAR 32
17540: PUSH
17541: LD_INT 0
17543: ST_TO_ADDR
// for i = 1 to 15 do
17544: LD_ADDR_VAR 0 2
17548: PUSH
17549: DOUBLE
17550: LD_INT 1
17552: DEC
17553: ST_TO_ADDR
17554: LD_INT 15
17556: PUSH
17557: FOR_TO
17558: IFFALSE 17611
// begin PrepareHuman ( false , Rand ( 1 , 4 ) , ar_skill ) ;
17560: LD_INT 0
17562: PPUSH
17563: LD_INT 1
17565: PPUSH
17566: LD_INT 4
17568: PPUSH
17569: CALL_OW 12
17573: PPUSH
17574: LD_EXP 53
17578: PPUSH
17579: CALL_OW 380
// un := CreateHuman ;
17583: LD_ADDR_VAR 0 4
17587: PUSH
17588: CALL_OW 44
17592: ST_TO_ADDR
// ar_force := ar_force ^ un ;
17593: LD_ADDR_EXP 52
17597: PUSH
17598: LD_EXP 52
17602: PUSH
17603: LD_VAR 0 4
17607: ADD
17608: ST_TO_ADDR
// end ;
17609: GO 17557
17611: POP
17612: POP
// hc_importance := 100 ;
17613: LD_ADDR_OWVAR 32
17617: PUSH
17618: LD_INT 100
17620: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , ar_skill ) ;
17621: LD_INT 1
17623: PPUSH
17624: LD_INT 11
17626: PPUSH
17627: LD_EXP 53
17631: PPUSH
17632: CALL_OW 380
// ar_commander := CreateHuman ;
17636: LD_ADDR_EXP 51
17640: PUSH
17641: CALL_OW 44
17645: ST_TO_ADDR
// player_commander := ar_commander ;
17646: LD_ADDR_EXP 10
17650: PUSH
17651: LD_EXP 51
17655: ST_TO_ADDR
// team := CharacterSelection ( text , [ 11 , 10 , 9 ] [ Difficulty ] , [ 11 , 10 , 9 ] [ Difficulty ] , [ sel_change_class , ar_commander , sel_changeable , sel_not_hired ] ^ ar_force , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , class_mortar ] ) ;
17656: LD_ADDR_VAR 0 5
17660: PUSH
17661: LD_STRING text
17663: PPUSH
17664: LD_INT 11
17666: PUSH
17667: LD_INT 10
17669: PUSH
17670: LD_INT 9
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: LIST
17677: PUSH
17678: LD_OWVAR 67
17682: ARRAY
17683: PPUSH
17684: LD_INT 11
17686: PUSH
17687: LD_INT 10
17689: PUSH
17690: LD_INT 9
17692: PUSH
17693: EMPTY
17694: LIST
17695: LIST
17696: LIST
17697: PUSH
17698: LD_OWVAR 67
17702: ARRAY
17703: PPUSH
17704: LD_INT -5
17706: PUSH
17707: LD_EXP 51
17711: PUSH
17712: LD_INT -3
17714: PUSH
17715: LD_INT -2
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: PUSH
17724: LD_EXP 52
17728: ADD
17729: PPUSH
17730: LD_INT 1
17732: PUSH
17733: LD_INT 3
17735: PUSH
17736: LD_INT 2
17738: PUSH
17739: LD_INT 1
17741: PUSH
17742: EMPTY
17743: LIST
17744: LIST
17745: PUSH
17746: LD_INT 4
17748: PUSH
17749: LD_INT 1
17751: PUSH
17752: EMPTY
17753: LIST
17754: LIST
17755: PUSH
17756: LD_INT 8
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: PPUSH
17766: CALL_OW 42
17770: ST_TO_ADDR
// team := team ^ ar_commander ;
17771: LD_ADDR_VAR 0 5
17775: PUSH
17776: LD_VAR 0 5
17780: PUSH
17781: LD_EXP 51
17785: ADD
17786: ST_TO_ADDR
// for i = 1 to team do
17787: LD_ADDR_VAR 0 2
17791: PUSH
17792: DOUBLE
17793: LD_INT 1
17795: DEC
17796: ST_TO_ADDR
17797: LD_VAR 0 5
17801: PUSH
17802: FOR_TO
17803: IFFALSE 17828
// PlaceUnitArea ( team [ i ] , center_resp , false ) ;
17805: LD_VAR 0 5
17809: PUSH
17810: LD_VAR 0 2
17814: ARRAY
17815: PPUSH
17816: LD_INT 16
17818: PPUSH
17819: LD_INT 0
17821: PPUSH
17822: CALL_OW 49
17826: GO 17802
17828: POP
17829: POP
// uc_side := 0 ;
17830: LD_ADDR_OWVAR 20
17834: PUSH
17835: LD_INT 0
17837: ST_TO_ADDR
// uc_nation := 0 ;
17838: LD_ADDR_OWVAR 21
17842: PUSH
17843: LD_INT 0
17845: ST_TO_ADDR
// vc_chassis := 31 ;
17846: LD_ADDR_OWVAR 37
17850: PUSH
17851: LD_INT 31
17853: ST_TO_ADDR
// vc_control := control_rider ;
17854: LD_ADDR_OWVAR 38
17858: PUSH
17859: LD_INT 4
17861: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 96 , 20 , false ) ;
17862: CALL_OW 45
17866: PPUSH
17867: LD_INT 96
17869: PPUSH
17870: LD_INT 20
17872: PPUSH
17873: LD_INT 0
17875: PPUSH
17876: CALL_OW 48
// end ;
17880: LD_VAR 0 1
17884: RET
