// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8608 0 0
// PrepareAmerican ;
 100: CALL 5228 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3263: LD_VAR 0 1
3267: PUSH
3268: LD_EXP 17
3272: IN
3273: IFFALSE 3291
// Patrol := Patrol diff un ;
3275: LD_ADDR_EXP 17
3279: PUSH
3280: LD_EXP 17
3284: PUSH
3285: LD_VAR 0 1
3289: DIFF
3290: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3291: LD_VAR 0 1
3295: PUSH
3296: LD_INT 22
3298: PUSH
3299: LD_INT 1
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PUSH
3306: LD_INT 30
3308: PUSH
3309: LD_INT 32
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PPUSH
3320: CALL_OW 69
3324: IN
3325: IFFALSE 3411
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3327: LD_ADDR_EXP 18
3331: PUSH
3332: LD_EXP 18
3336: PUSH
3337: LD_VAR 0 1
3341: PPUSH
3342: CALL_OW 250
3346: ADD
3347: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3348: LD_ADDR_EXP 18
3352: PUSH
3353: LD_EXP 18
3357: PUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: CALL_OW 251
3367: ADD
3368: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3369: LD_ADDR_EXP 18
3373: PUSH
3374: LD_EXP 18
3378: PUSH
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 254
3388: ADD
3389: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3390: LD_ADDR_EXP 18
3394: PUSH
3395: LD_EXP 18
3399: PUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 269
3409: ADD
3410: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3411: LD_VAR 0 1
3415: PUSH
3416: LD_INT 33
3418: PUSH
3419: LD_INT 2
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 34
3431: PUSH
3432: LD_INT 13
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PPUSH
3447: CALL_OW 69
3451: IN
3452: IFFALSE 3468
// new_veh := new_veh + 1 ;
3454: LD_ADDR_EXP 19
3458: PUSH
3459: LD_EXP 19
3463: PUSH
3464: LD_INT 1
3466: PLUS
3467: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3468: LD_VAR 0 1
3472: PUSH
3473: LD_INT 34
3475: PUSH
3476: LD_INT 13
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: PPUSH
3483: CALL_OW 69
3487: IN
3488: IFFALSE 3509
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3490: LD_INT 26
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 2
3498: PPUSH
3499: LD_INT 2
3501: PPUSH
3502: LD_INT 13
3504: PPUSH
3505: CALL_OW 185
// if un = am_dep then
3509: LD_VAR 0 1
3513: PUSH
3514: LD_INT 25
3516: EQUAL
3517: IFFALSE 3685
// begin SayRadio ( Platonov , DPlat ) ;
3519: LD_EXP 4
3523: PPUSH
3524: LD_STRING DPlat
3526: PPUSH
3527: CALL_OW 94
// if timer <= 30 30$00 then
3531: LD_EXP 24
3535: PUSH
3536: LD_INT 63000
3538: LESSEQUAL
3539: IFFALSE 3553
// AddMedal ( gamma_med3 , 1 ) else
3541: LD_STRING gamma_med3
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 101
3551: GO 3603
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3553: LD_EXP 24
3557: PUSH
3558: LD_INT 105000
3560: PUSH
3561: LD_INT 88200
3563: PUSH
3564: LD_INT 73500
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: LIST
3571: PUSH
3572: LD_EXP 1
3576: ARRAY
3577: LESSEQUAL
3578: IFFALSE 3592
// AddMedal ( gamma_med3 , 2 ) else
3580: LD_STRING gamma_med3
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 101
3590: GO 3603
// AddMedal ( gamma_med3 , - 1 ) ;
3592: LD_STRING gamma_med3
3594: PPUSH
3595: LD_INT 1
3597: NEG
3598: PPUSH
3599: CALL_OW 101
// if not comp_tested then
3603: LD_EXP 22
3607: NOT
3608: IFFALSE 3623
// AddMedal ( gamma_med2 , - 1 ) else
3610: LD_STRING gamma_med2
3612: PPUSH
3613: LD_INT 1
3615: NEG
3616: PPUSH
3617: CALL_OW 101
3621: GO 3633
// AddMedal ( gamma_med2 , 1 ) ;
3623: LD_STRING gamma_med2
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3633: LD_EXP 9
3637: PPUSH
3638: CALL_OW 301
3642: PUSH
3643: LD_EXP 23
3647: NOT
3648: AND
3649: IFFALSE 3663
// AddMedal ( gamma_med1 , 1 ) else
3651: LD_STRING gamma_med1
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: CALL_OW 101
3661: GO 3674
// AddMedal ( gamma_med1 , - 1 ) ;
3663: LD_STRING gamma_med1
3665: PPUSH
3666: LD_INT 1
3668: NEG
3669: PPUSH
3670: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3674: LD_STRING GAMMA_MEDALS
3676: PPUSH
3677: CALL_OW 102
// YouWin ;
3681: CALL_OW 103
// end ; if un = commander then
3685: LD_VAR 0 1
3689: PUSH
3690: LD_EXP 3
3694: EQUAL
3695: IFFALSE 3704
// YouLost ( comml ) ;
3697: LD_STRING comml
3699: PPUSH
3700: CALL_OW 104
// if un = sikorski then
3704: LD_VAR 0 1
3708: PUSH
3709: LD_EXP 9
3713: EQUAL
3714: IFFALSE 3726
// AddMedal ( gamma_med1 , 1 ) ;
3716: LD_STRING gamma_med1
3718: PPUSH
3719: LD_INT 1
3721: PPUSH
3722: CALL_OW 101
// end ;
3726: PPOPN 1
3728: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3729: LD_INT 0
3731: PPUSH
3732: PPUSH
3733: PPUSH
3734: PPUSH
3735: PPUSH
3736: PPUSH
3737: PPUSH
3738: PPUSH
3739: PPUSH
// begin if event = 1 then
3740: LD_VAR 0 1
3744: PUSH
3745: LD_INT 1
3747: EQUAL
3748: IFFALSE 4045
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3750: LD_ADDR_VAR 0 4
3754: PUSH
3755: LD_INT 22
3757: PUSH
3758: LD_INT 1
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 21
3767: PUSH
3768: LD_INT 3
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 3
3777: PUSH
3778: LD_INT 24
3780: PUSH
3781: LD_INT 1000
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: LIST
3796: PPUSH
3797: CALL_OW 69
3801: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_INT 22
3809: PUSH
3810: LD_INT 1
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_INT 25
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 24
3829: PUSH
3830: LD_INT 1000
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: PPUSH
3845: CALL_OW 69
3849: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3850: LD_ADDR_VAR 0 9
3854: PUSH
3855: LD_INT 22
3857: PUSH
3858: LD_INT 1
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 34
3867: PUSH
3868: LD_INT 13
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL_OW 69
3883: ST_TO_ADDR
// if engs > 0 then
3884: LD_VAR 0 8
3888: PUSH
3889: LD_INT 0
3891: GREATER
3892: IFFALSE 3997
// for i = 1 to engs do
3894: LD_ADDR_VAR 0 2
3898: PUSH
3899: DOUBLE
3900: LD_INT 1
3902: DEC
3903: ST_TO_ADDR
3904: LD_VAR 0 8
3908: PUSH
3909: FOR_TO
3910: IFFALSE 3995
// begin if IsInUnit ( engs [ i ] ) then
3912: LD_VAR 0 8
3916: PUSH
3917: LD_VAR 0 2
3921: ARRAY
3922: PPUSH
3923: CALL_OW 310
3927: IFFALSE 3944
// ComExitBuilding ( engs [ i ] ) ;
3929: LD_VAR 0 8
3933: PUSH
3934: LD_VAR 0 2
3938: ARRAY
3939: PPUSH
3940: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3944: LD_INT 7
3946: PPUSH
3947: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3951: LD_VAR 0 8
3955: PUSH
3956: LD_VAR 0 2
3960: ARRAY
3961: PPUSH
3962: CALL_OW 314
3966: NOT
3967: IFFALSE 3993
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3969: LD_VAR 0 8
3973: PUSH
3974: LD_VAR 0 2
3978: ARRAY
3979: PPUSH
3980: LD_VAR 0 4
3984: PUSH
3985: LD_INT 1
3987: ARRAY
3988: PPUSH
3989: CALL_OW 130
// end ;
3993: GO 3909
3995: POP
3996: POP
// if crane > 0 then
3997: LD_VAR 0 9
4001: PUSH
4002: LD_INT 0
4004: GREATER
4005: IFFALSE 4045
// if not HasTask ( crane [ 1 ] ) then
4007: LD_VAR 0 9
4011: PUSH
4012: LD_INT 1
4014: ARRAY
4015: PPUSH
4016: CALL_OW 314
4020: NOT
4021: IFFALSE 4045
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4023: LD_VAR 0 9
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_VAR 0 4
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: CALL_OW 130
// end ; if event = 2 then
4045: LD_VAR 0 1
4049: PUSH
4050: LD_INT 2
4052: EQUAL
4053: IFFALSE 4175
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4055: LD_ADDR_VAR 0 8
4059: PUSH
4060: LD_INT 22
4062: PUSH
4063: LD_INT 1
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: LD_INT 25
4072: PUSH
4073: LD_INT 2
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 69
4088: ST_TO_ADDR
// if engs > 0 then
4089: LD_VAR 0 8
4093: PUSH
4094: LD_INT 0
4096: GREATER
4097: IFFALSE 4175
// for i = 1 to engs do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_VAR 0 8
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4173
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4117: LD_VAR 0 8
4121: PUSH
4122: LD_VAR 0 2
4126: ARRAY
4127: PPUSH
4128: CALL_OW 314
4132: NOT
4133: PUSH
4134: LD_VAR 0 8
4138: PUSH
4139: LD_VAR 0 2
4143: ARRAY
4144: PPUSH
4145: CALL_OW 310
4149: NOT
4150: AND
4151: IFFALSE 4171
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4153: LD_VAR 0 8
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PPUSH
4164: LD_INT 25
4166: PPUSH
4167: CALL_OW 120
4171: GO 4114
4173: POP
4174: POP
// end ; if event = 3 then
4175: LD_VAR 0 1
4179: PUSH
4180: LD_INT 3
4182: EQUAL
4183: IFFALSE 4547
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 1
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 25
4215: PUSH
4216: LD_INT 4
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: LD_INT 24
4232: PUSH
4233: LD_INT 800
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: PPUSH
4253: CALL_OW 69
4257: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4258: LD_ADDR_VAR 0 5
4262: PUSH
4263: LD_INT 22
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PUSH
4273: LD_INT 25
4275: PUSH
4276: LD_INT 4
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: ST_TO_ADDR
// if filter > 0 then
4292: LD_VAR 0 4
4296: PUSH
4297: LD_INT 0
4299: GREATER
4300: IFFALSE 4489
// begin for i = 1 to doc do
4302: LD_ADDR_VAR 0 2
4306: PUSH
4307: DOUBLE
4308: LD_INT 1
4310: DEC
4311: ST_TO_ADDR
4312: LD_VAR 0 5
4316: PUSH
4317: FOR_TO
4318: IFFALSE 4418
// begin if IsInUnit ( doc [ i ] ) then
4320: LD_VAR 0 5
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PPUSH
4331: CALL_OW 310
4335: IFFALSE 4352
// ComExitBuilding ( doc [ i ] ) ;
4337: LD_VAR 0 5
4341: PUSH
4342: LD_VAR 0 2
4346: ARRAY
4347: PPUSH
4348: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 1
4359: ARRAY
4360: PPUSH
4361: LD_INT 46
4363: PPUSH
4364: CALL_OW 296
4368: PUSH
4369: LD_INT 10
4371: LESS
4372: PUSH
4373: LD_VAR 0 5
4377: PUSH
4378: LD_VAR 0 2
4382: ARRAY
4383: PPUSH
4384: CALL_OW 314
4388: NOT
4389: AND
4390: IFFALSE 4416
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4392: LD_VAR 0 5
4396: PUSH
4397: LD_VAR 0 2
4401: ARRAY
4402: PPUSH
4403: LD_VAR 0 4
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 128
// end ;
4416: GO 4317
4418: POP
4419: POP
// for i = 1 to filter do
4420: LD_ADDR_VAR 0 2
4424: PUSH
4425: DOUBLE
4426: LD_INT 1
4428: DEC
4429: ST_TO_ADDR
4430: LD_VAR 0 4
4434: PUSH
4435: FOR_TO
4436: IFFALSE 4485
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4438: LD_VAR 0 4
4442: PUSH
4443: LD_VAR 0 2
4447: ARRAY
4448: PPUSH
4449: LD_INT 46
4451: PPUSH
4452: CALL_OW 296
4456: PUSH
4457: LD_INT 10
4459: GREATER
4460: IFFALSE 4483
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 2
4471: ARRAY
4472: PPUSH
4473: LD_INT 47
4475: PPUSH
4476: LD_INT 12
4478: PPUSH
4479: CALL_OW 111
4483: GO 4435
4485: POP
4486: POP
// end else
4487: GO 4547
// for i = 1 to doc do
4489: LD_ADDR_VAR 0 2
4493: PUSH
4494: DOUBLE
4495: LD_INT 1
4497: DEC
4498: ST_TO_ADDR
4499: LD_VAR 0 5
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4545
// if not IsInUnit ( doc [ i ] ) then
4507: LD_VAR 0 5
4511: PUSH
4512: LD_VAR 0 2
4516: ARRAY
4517: PPUSH
4518: CALL_OW 310
4522: NOT
4523: IFFALSE 4543
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 2
4534: ARRAY
4535: PPUSH
4536: LD_INT 46
4538: PPUSH
4539: CALL_OW 120
4543: GO 4504
4545: POP
4546: POP
// end ; if event = 4 then
4547: LD_VAR 0 1
4551: PUSH
4552: LD_INT 4
4554: EQUAL
4555: IFFALSE 4806
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4557: LD_ADDR_VAR 0 6
4561: PUSH
4562: LD_INT 22
4564: PUSH
4565: LD_INT 1
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 30
4574: PUSH
4575: LD_INT 5
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL_OW 69
4590: ST_TO_ADDR
// for i = 1 to bac do
4591: LD_ADDR_VAR 0 2
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_VAR 0 6
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4648
// if UnitsInside ( bac [ i ] ) < 6 then
4609: LD_VAR 0 6
4613: PUSH
4614: LD_VAR 0 2
4618: ARRAY
4619: PPUSH
4620: CALL_OW 313
4624: PUSH
4625: LD_INT 6
4627: LESS
4628: IFFALSE 4646
// place := bac [ i ] ;
4630: LD_ADDR_VAR 0 7
4634: PUSH
4635: LD_VAR 0 6
4639: PUSH
4640: LD_VAR 0 2
4644: ARRAY
4645: ST_TO_ADDR
4646: GO 4606
4648: POP
4649: POP
// if place then
4650: LD_VAR 0 7
4654: IFFALSE 4806
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4656: LD_ADDR_VAR 0 4
4660: PUSH
4661: LD_INT 22
4663: PUSH
4664: LD_INT 1
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 2
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 25
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 24
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_EXP 17
4726: DIFF
4727: ST_TO_ADDR
// for i = 1 to filter do
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: DOUBLE
4734: LD_INT 1
4736: DEC
4737: ST_TO_ADDR
4738: LD_VAR 0 4
4742: PUSH
4743: FOR_TO
4744: IFFALSE 4804
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4746: LD_VAR 0 4
4750: PUSH
4751: LD_VAR 0 2
4755: ARRAY
4756: PPUSH
4757: CALL_OW 310
4761: NOT
4762: PUSH
4763: LD_VAR 0 4
4767: PUSH
4768: LD_VAR 0 2
4772: ARRAY
4773: PPUSH
4774: CALL_OW 314
4778: NOT
4779: AND
4780: IFFALSE 4802
// ComEnterUnit ( filter [ i ] , place ) ;
4782: LD_VAR 0 4
4786: PUSH
4787: LD_VAR 0 2
4791: ARRAY
4792: PPUSH
4793: LD_VAR 0 7
4797: PPUSH
4798: CALL_OW 120
4802: GO 4743
4804: POP
4805: POP
// end ; end ; if event = 5 then
4806: LD_VAR 0 1
4810: PUSH
4811: LD_INT 5
4813: EQUAL
4814: IFFALSE 4968
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4816: LD_INT 12
4818: PPUSH
4819: LD_INT 81
4821: PUSH
4822: LD_INT 1
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PPUSH
4829: CALL_OW 70
4833: PUSH
4834: LD_INT 0
4836: EQUAL
4837: IFFALSE 4968
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4839: LD_ADDR_VAR 0 8
4843: PUSH
4844: LD_INT 22
4846: PUSH
4847: LD_INT 1
4849: PUSH
4850: EMPTY
4851: LIST
4852: LIST
4853: PUSH
4854: LD_INT 25
4856: PUSH
4857: LD_INT 2
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PPUSH
4868: CALL_OW 69
4872: ST_TO_ADDR
// if engs > 0 then
4873: LD_VAR 0 8
4877: PUSH
4878: LD_INT 0
4880: GREATER
4881: IFFALSE 4968
// for i = 1 to engs do
4883: LD_ADDR_VAR 0 2
4887: PUSH
4888: DOUBLE
4889: LD_INT 1
4891: DEC
4892: ST_TO_ADDR
4893: LD_VAR 0 8
4897: PUSH
4898: FOR_TO
4899: IFFALSE 4966
// if not HasTask ( engs [ i ] ) then
4901: LD_VAR 0 8
4905: PUSH
4906: LD_VAR 0 2
4910: ARRAY
4911: PPUSH
4912: CALL_OW 314
4916: NOT
4917: IFFALSE 4964
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4919: LD_VAR 0 8
4923: PUSH
4924: LD_VAR 0 2
4928: ARRAY
4929: PPUSH
4930: LD_INT 32
4932: PPUSH
4933: LD_EXP 18
4937: PUSH
4938: LD_INT 1
4940: ARRAY
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 2
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 3
4958: ARRAY
4959: PPUSH
4960: CALL_OW 145
4964: GO 4898
4966: POP
4967: POP
// end ; end ; if event = 6 then
4968: LD_VAR 0 1
4972: PUSH
4973: LD_INT 6
4975: EQUAL
4976: IFFALSE 5160
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4978: LD_ADDR_VAR 0 6
4982: PUSH
4983: LD_INT 22
4985: PUSH
4986: LD_INT 1
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 69
5011: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5012: LD_VAR 0 6
5016: PUSH
5017: LD_INT 22
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 32
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 58
5039: PUSH
5040: EMPTY
5041: LIST
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 0
5058: GREATER
5059: AND
5060: IFFALSE 5160
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5062: LD_ADDR_VAR 0 10
5066: PUSH
5067: LD_INT 22
5069: PUSH
5070: LD_INT 1
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: LD_INT 30
5079: PUSH
5080: LD_INT 32
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 58
5089: PUSH
5090: EMPTY
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: EMPTY
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: PUSH
5106: LD_INT 1
5108: ARRAY
5109: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5110: LD_ADDR_VAR 0 3
5114: PUSH
5115: LD_VAR 0 6
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: CALL_OW 313
5128: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5129: LD_VAR 0 3
5133: PUSH
5134: LD_INT 1
5136: ARRAY
5137: PPUSH
5138: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: ARRAY
5150: PPUSH
5151: LD_VAR 0 10
5155: PPUSH
5156: CALL_OW 180
// end ; end ; end ;
5160: PPOPN 10
5162: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5163: LD_VAR 0 1
5167: PUSH
5168: LD_INT 1
5170: EQUAL
5171: PUSH
5172: LD_VAR 0 2
5176: PUSH
5177: LD_INT 3
5179: EQUAL
5180: AND
5181: IFFALSE 5191
// contact_am := true ;
5183: LD_ADDR_EXP 16
5187: PUSH
5188: LD_INT 1
5190: ST_TO_ADDR
// end ;
5191: PPOPN 2
5193: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5194: LD_VAR 0 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PPUSH
5204: LD_VAR 0 3
5208: PPUSH
5209: CALL 9473 0 3
// end ;
5213: PPOPN 3
5215: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5216: LD_VAR 0 1
5220: PPUSH
5221: CALL 9571 0 1
// end ; end_of_file
5225: PPOPN 1
5227: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5228: LD_INT 0
5230: PPUSH
5231: PPUSH
5232: PPUSH
5233: PPUSH
5234: PPUSH
5235: PPUSH
5236: PPUSH
5237: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5238: LD_ADDR_VAR 0 5
5242: PUSH
5243: LD_INT 5
5245: PUSH
5246: LD_INT 6
5248: PUSH
5249: LD_INT 7
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_EXP 1
5261: ARRAY
5262: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5263: LD_ADDR_VAR 0 6
5267: PUSH
5268: LD_INT 4
5270: PUSH
5271: LD_INT 4
5273: PUSH
5274: LD_INT 4
5276: PUSH
5277: LD_INT 5
5279: PUSH
5280: LD_INT 5
5282: PUSH
5283: LD_INT 5
5285: PUSH
5286: LD_INT 6
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: LIST
5297: ST_TO_ADDR
// SForce := [ ] ;
5298: LD_ADDR_EXP 11
5302: PUSH
5303: EMPTY
5304: ST_TO_ADDR
// Sikorski_Ar := false ;
5305: LD_ADDR_EXP 12
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// attacked := false ;
5313: LD_ADDR_EXP 15
5317: PUSH
5318: LD_INT 0
5320: ST_TO_ADDR
// contact_am := false ;
5321: LD_ADDR_EXP 16
5325: PUSH
5326: LD_INT 0
5328: ST_TO_ADDR
// patrol := [ ] ;
5329: LD_ADDR_EXP 17
5333: PUSH
5334: EMPTY
5335: ST_TO_ADDR
// gamma_towers := [ ] ;
5336: LD_ADDR_EXP 18
5340: PUSH
5341: EMPTY
5342: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5343: LD_INT 25
5345: PPUSH
5346: LD_STRING gamma
5348: PPUSH
5349: CALL_OW 500
// uc_side := 1 ;
5353: LD_ADDR_OWVAR 20
5357: PUSH
5358: LD_INT 1
5360: ST_TO_ADDR
// uc_nation := 1 ;
5361: LD_ADDR_OWVAR 21
5365: PUSH
5366: LD_INT 1
5368: ST_TO_ADDR
// hc_importance := 0 ;
5369: LD_ADDR_OWVAR 32
5373: PUSH
5374: LD_INT 0
5376: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5377: LD_ADDR_OWVAR 26
5381: PUSH
5382: LD_STRING Jeremy Sikorski
5384: ST_TO_ADDR
// hc_gallery := us ;
5385: LD_ADDR_OWVAR 33
5389: PUSH
5390: LD_STRING us
5392: ST_TO_ADDR
// hc_face_number := 19 ;
5393: LD_ADDR_OWVAR 34
5397: PUSH
5398: LD_INT 19
5400: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5401: LD_ADDR_OWVAR 31
5405: PUSH
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_VAR 0 5
5415: PUSH
5416: LD_INT 2
5418: PLUS
5419: PPUSH
5420: CALL_OW 12
5424: PUSH
5425: LD_INT 4
5427: PUSH
5428: LD_INT 6
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: ST_TO_ADDR
// hc_sex := sex_male ;
5440: LD_ADDR_OWVAR 27
5444: PUSH
5445: LD_INT 1
5447: ST_TO_ADDR
// hc_class := 1 ;
5448: LD_ADDR_OWVAR 28
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5456: LD_ADDR_OWVAR 29
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: ST_TO_ADDR
// sikorski := CreateHuman ;
5471: LD_ADDR_EXP 9
5475: PUSH
5476: CALL_OW 44
5480: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5481: LD_ADDR_OWVAR 26
5485: PUSH
5486: LD_STRING Lucy Donaldson
5488: ST_TO_ADDR
// hc_gallery := us ;
5489: LD_ADDR_OWVAR 33
5493: PUSH
5494: LD_STRING us
5496: ST_TO_ADDR
// hc_face_number := 2 ;
5497: LD_ADDR_OWVAR 34
5501: PUSH
5502: LD_INT 2
5504: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5505: LD_ADDR_OWVAR 31
5509: PUSH
5510: LD_VAR 0 5
5514: PPUSH
5515: LD_VAR 0 5
5519: PUSH
5520: LD_INT 2
5522: PLUS
5523: PPUSH
5524: CALL_OW 12
5528: PUSH
5529: LD_INT 6
5531: PUSH
5532: LD_INT 4
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: ST_TO_ADDR
// hc_sex := sex_female ;
5544: LD_ADDR_OWVAR 27
5548: PUSH
5549: LD_INT 2
5551: ST_TO_ADDR
// hc_class := 1 ;
5552: LD_ADDR_OWVAR 28
5556: PUSH
5557: LD_INT 1
5559: ST_TO_ADDR
// donald := CreateHuman ;
5560: LD_ADDR_EXP 13
5564: PUSH
5565: CALL_OW 44
5569: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5570: LD_ADDR_OWVAR 26
5574: PUSH
5575: LD_STRING Peter Van Houten
5577: ST_TO_ADDR
// hc_gallery := us ;
5578: LD_ADDR_OWVAR 33
5582: PUSH
5583: LD_STRING us
5585: ST_TO_ADDR
// hc_face_number := 16 ;
5586: LD_ADDR_OWVAR 34
5590: PUSH
5591: LD_INT 16
5593: ST_TO_ADDR
// hc_sex := sex_male ;
5594: LD_ADDR_OWVAR 27
5598: PUSH
5599: LD_INT 1
5601: ST_TO_ADDR
// van := CreateHuman ;
5602: LD_ADDR_EXP 14
5606: PUSH
5607: CALL_OW 44
5611: ST_TO_ADDR
// hc_importance := 0 ;
5612: LD_ADDR_OWVAR 32
5616: PUSH
5617: LD_INT 0
5619: ST_TO_ADDR
// case dif of 1 :
5620: LD_EXP 1
5624: PUSH
5625: LD_INT 1
5627: DOUBLE
5628: EQUAL
5629: IFTRUE 5633
5631: GO 5644
5633: POP
// lw = 1 ; 2 :
5634: LD_ADDR_VAR 0 8
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
5642: GO 5691
5644: LD_INT 2
5646: DOUBLE
5647: EQUAL
5648: IFTRUE 5652
5650: GO 5671
5652: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5653: LD_ADDR_VAR 0 8
5657: PUSH
5658: LD_INT 1
5660: PPUSH
5661: LD_INT 2
5663: PPUSH
5664: CALL_OW 12
5668: ST_TO_ADDR
5669: GO 5691
5671: LD_INT 3
5673: DOUBLE
5674: EQUAL
5675: IFTRUE 5679
5677: GO 5690
5679: POP
// lw = 2 ; end ;
5680: LD_ADDR_VAR 0 8
5684: PUSH
5685: LD_INT 2
5687: ST_TO_ADDR
5688: GO 5691
5690: POP
// case lw of 1 :
5691: LD_VAR 0 8
5695: PUSH
5696: LD_INT 1
5698: DOUBLE
5699: EQUAL
5700: IFTRUE 5704
5702: GO 5719
5704: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5705: LD_EXP 13
5709: PPUSH
5710: LD_INT 25
5712: PPUSH
5713: CALL_OW 52
5717: GO 5743
5719: LD_INT 2
5721: DOUBLE
5722: EQUAL
5723: IFTRUE 5727
5725: GO 5742
5727: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5728: LD_EXP 14
5732: PPUSH
5733: LD_INT 25
5735: PPUSH
5736: CALL_OW 52
5740: GO 5743
5742: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5743: LD_ADDR_VAR 0 2
5747: PUSH
5748: LD_INT 22
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 30
5760: PUSH
5761: LD_INT 32
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PPUSH
5772: CALL_OW 69
5776: PUSH
5777: FOR_IN
5778: IFFALSE 5832
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5780: LD_INT 1
5782: PPUSH
5783: LD_VAR 0 5
5787: PPUSH
5788: CALL 734 0 2
5792: PPUSH
5793: LD_VAR 0 2
5797: PPUSH
5798: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PUSH
5812: LD_INT 1
5814: PPUSH
5815: LD_VAR 0 6
5819: PPUSH
5820: CALL_OW 12
5824: ARRAY
5825: PPUSH
5826: CALL_OW 431
// end ;
5830: GO 5777
5832: POP
5833: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5834: LD_ADDR_VAR 0 7
5838: PUSH
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 2
5851: PUSH
5852: LD_INT 25
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 5
5864: PUSH
5865: EMPTY
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: PPUSH
5877: CALL_OW 69
5881: ST_TO_ADDR
// for i = 1 to sol do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_VAR 0 7
5896: PUSH
5897: FOR_TO
5898: IFFALSE 5920
// SetTag ( sol [ i ] , 1 ) ;
5900: LD_VAR 0 7
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PPUSH
5911: LD_INT 1
5913: PPUSH
5914: CALL_OW 109
5918: GO 5897
5920: POP
5921: POP
// for i = 1 to 3 do
5922: LD_ADDR_VAR 0 2
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_INT 3
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5960
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: CALL 734 0 2
5950: PPUSH
5951: LD_INT 56
5953: PPUSH
5954: CALL_OW 52
5958: GO 5935
5960: POP
5961: POP
// for i = 1 to 6 do
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: DOUBLE
5968: LD_INT 1
5970: DEC
5971: ST_TO_ADDR
5972: LD_INT 6
5974: PUSH
5975: FOR_TO
5976: IFFALSE 6000
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5978: LD_INT 3
5980: PPUSH
5981: LD_VAR 0 5
5985: PPUSH
5986: CALL 734 0 2
5990: PPUSH
5991: LD_INT 26
5993: PPUSH
5994: CALL_OW 52
5998: GO 5975
6000: POP
6001: POP
// for i = 1 to 5 do
6002: LD_ADDR_VAR 0 2
6006: PUSH
6007: DOUBLE
6008: LD_INT 1
6010: DEC
6011: ST_TO_ADDR
6012: LD_INT 5
6014: PUSH
6015: FOR_TO
6016: IFFALSE 6043
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6018: LD_INT 2
6020: PPUSH
6021: LD_VAR 0 5
6025: PPUSH
6026: CALL 734 0 2
6030: PPUSH
6031: LD_INT 7
6033: PPUSH
6034: LD_INT 0
6036: PPUSH
6037: CALL_OW 49
6041: GO 6015
6043: POP
6044: POP
// for i = 1 to 3 do
6045: LD_ADDR_VAR 0 2
6049: PUSH
6050: DOUBLE
6051: LD_INT 1
6053: DEC
6054: ST_TO_ADDR
6055: LD_INT 3
6057: PUSH
6058: FOR_TO
6059: IFFALSE 6083
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6061: LD_INT 4
6063: PPUSH
6064: LD_VAR 0 5
6068: PPUSH
6069: CALL 734 0 2
6073: PPUSH
6074: LD_INT 46
6076: PPUSH
6077: CALL_OW 52
6081: GO 6058
6083: POP
6084: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 1
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 30
6102: PUSH
6103: LD_INT 5
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: PUSH
6119: FOR_IN
6120: IFFALSE 6234
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6122: LD_INT 5
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL 734 0 2
6134: PPUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6144: LD_INT 5
6146: PPUSH
6147: LD_VAR 0 5
6151: PPUSH
6152: CALL 734 0 2
6156: PPUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 5
6173: PPUSH
6174: CALL 734 0 2
6178: PPUSH
6179: LD_VAR 0 2
6183: PPUSH
6184: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6188: LD_INT 1
6190: PPUSH
6191: LD_VAR 0 5
6195: PPUSH
6196: CALL 734 0 2
6200: PPUSH
6201: LD_VAR 0 2
6205: PPUSH
6206: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6210: LD_INT 1
6212: PPUSH
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL 734 0 2
6222: PPUSH
6223: LD_VAR 0 2
6227: PPUSH
6228: CALL_OW 52
// end ;
6232: GO 6119
6234: POP
6235: POP
// if dif > 1 then
6236: LD_EXP 1
6240: PUSH
6241: LD_INT 1
6243: GREATER
6244: IFFALSE 6317
// for i = 1 to ( dif - 1 ) do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_EXP 1
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: PUSH
6265: FOR_TO
6266: IFFALSE 6315
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6268: LD_ADDR_EXP 17
6272: PUSH
6273: LD_EXP 17
6277: PUSH
6278: LD_INT 1
6280: PPUSH
6281: LD_VAR 0 5
6285: PPUSH
6286: CALL 734 0 2
6290: ADD
6291: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6292: LD_EXP 17
6296: PUSH
6297: LD_VAR 0 2
6301: ARRAY
6302: PPUSH
6303: LD_INT 3
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// end ;
6313: GO 6265
6315: POP
6316: POP
// game_started := true ;
6317: LD_ADDR_EXP 10
6321: PUSH
6322: LD_INT 1
6324: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6325: LD_INT 26
6327: PPUSH
6328: LD_INT 3
6330: PPUSH
6331: LD_INT 2
6333: PPUSH
6334: LD_INT 2
6336: PPUSH
6337: LD_INT 13
6339: PPUSH
6340: CALL_OW 125
// while ( contact_am = false ) do
6344: LD_EXP 16
6348: PUSH
6349: LD_INT 0
6351: EQUAL
6352: IFFALSE 6363
// begin Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// end ;
6361: GO 6344
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6363: LD_INT 8400
6365: PUSH
6366: LD_INT 6300
6368: PUSH
6369: LD_INT 5250
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: LD_EXP 1
6381: ARRAY
6382: PPUSH
6383: CALL_OW 67
// case dif of 1 :
6387: LD_EXP 1
6391: PUSH
6392: LD_INT 1
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6575
6400: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6401: LD_INT 26
6403: PPUSH
6404: LD_INT 3
6406: PPUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: LD_INT 5
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 4
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6447: LD_INT 26
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: LD_INT 1
6455: PPUSH
6456: LD_INT 2
6458: PPUSH
6459: LD_INT 4
6461: PUSH
6462: LD_INT 5
6464: PUSH
6465: LD_INT 5
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 1
6475: PPUSH
6476: LD_INT 3
6478: PPUSH
6479: CALL_OW 12
6483: ARRAY
6484: PPUSH
6485: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6489: LD_INT 26
6491: PPUSH
6492: LD_INT 3
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: LD_INT 4
6503: PUSH
6504: LD_INT 5
6506: PUSH
6507: LD_INT 5
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 3
6520: PPUSH
6521: CALL_OW 12
6525: ARRAY
6526: PPUSH
6527: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6531: LD_INT 26
6533: PPUSH
6534: LD_INT 3
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_INT 2
6542: PPUSH
6543: LD_INT 4
6545: PUSH
6546: LD_INT 3
6548: PUSH
6549: LD_INT 5
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 1
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 12
6567: ARRAY
6568: PPUSH
6569: CALL_OW 185
// end ; 2 :
6573: GO 7102
6575: LD_INT 2
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6796
6583: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6584: LD_INT 26
6586: PPUSH
6587: LD_INT 3
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 2
6595: PPUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: LD_INT 5
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 3
6615: PPUSH
6616: CALL_OW 12
6620: ARRAY
6621: PPUSH
6622: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6626: LD_INT 26
6628: PPUSH
6629: LD_INT 3
6631: PPUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 4
6640: PUSH
6641: LD_INT 5
6643: PUSH
6644: LD_INT 5
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 3
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6668: LD_INT 26
6670: PPUSH
6671: LD_INT 3
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: LD_INT 2
6679: PPUSH
6680: LD_INT 4
6682: PUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 5
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 3
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: PPUSH
6706: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6710: LD_INT 26
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 2
6721: PPUSH
6722: LD_INT 4
6724: PUSH
6725: LD_INT 5
6727: PUSH
6728: LD_INT 6
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 1
6738: PPUSH
6739: LD_INT 3
6741: PPUSH
6742: CALL_OW 12
6746: ARRAY
6747: PPUSH
6748: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6752: LD_INT 26
6754: PPUSH
6755: LD_INT 4
6757: PPUSH
6758: LD_INT 1
6760: PPUSH
6761: LD_INT 2
6763: PPUSH
6764: LD_INT 4
6766: PUSH
6767: LD_INT 5
6769: PUSH
6770: LD_INT 6
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: CALL_OW 185
// end ; 3 :
6794: GO 7102
6796: LD_INT 3
6798: DOUBLE
6799: EQUAL
6800: IFTRUE 6804
6802: GO 7101
6804: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6805: LD_INT 26
6807: PPUSH
6808: LD_INT 3
6810: PPUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_INT 2
6816: PPUSH
6817: LD_INT 4
6819: PUSH
6820: LD_INT 5
6822: PUSH
6823: LD_INT 5
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: LD_INT 1
6833: PPUSH
6834: LD_INT 3
6836: PPUSH
6837: CALL_OW 12
6841: ARRAY
6842: PPUSH
6843: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6847: LD_INT 26
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 1
6855: PPUSH
6856: LD_INT 2
6858: PPUSH
6859: LD_INT 4
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 5
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 3
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6889: LD_INT 26
6891: PPUSH
6892: LD_INT 3
6894: PPUSH
6895: LD_INT 1
6897: PPUSH
6898: LD_INT 2
6900: PPUSH
6901: LD_INT 4
6903: PUSH
6904: LD_INT 5
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 1
6917: PPUSH
6918: LD_INT 3
6920: PPUSH
6921: CALL_OW 12
6925: ARRAY
6926: PPUSH
6927: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6931: LD_INT 26
6933: PPUSH
6934: LD_INT 3
6936: PPUSH
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 2
6942: PPUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 5
6948: PUSH
6949: LD_INT 5
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 1
6959: PPUSH
6960: LD_INT 3
6962: PPUSH
6963: CALL_OW 12
6967: ARRAY
6968: PPUSH
6969: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6973: LD_INT 26
6975: PPUSH
6976: LD_INT 4
6978: PPUSH
6979: LD_INT 1
6981: PPUSH
6982: LD_INT 2
6984: PPUSH
6985: LD_INT 4
6987: PUSH
6988: LD_INT 5
6990: PUSH
6991: LD_INT 6
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 1
7001: PPUSH
7002: LD_INT 3
7004: PPUSH
7005: CALL_OW 12
7009: ARRAY
7010: PPUSH
7011: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7015: LD_INT 26
7017: PPUSH
7018: LD_INT 4
7020: PPUSH
7021: LD_INT 1
7023: PPUSH
7024: LD_INT 2
7026: PPUSH
7027: LD_INT 4
7029: PUSH
7030: LD_INT 5
7032: PUSH
7033: LD_INT 6
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: LIST
7040: PUSH
7041: LD_INT 1
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 12
7051: ARRAY
7052: PPUSH
7053: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7057: LD_INT 26
7059: PPUSH
7060: LD_INT 4
7062: PPUSH
7063: LD_INT 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: LD_INT 4
7071: PUSH
7072: LD_INT 5
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 1
7085: PPUSH
7086: LD_INT 3
7088: PPUSH
7089: CALL_OW 12
7093: ARRAY
7094: PPUSH
7095: CALL_OW 185
// end ; end ;
7099: GO 7102
7101: POP
// end ;
7102: LD_VAR 0 1
7106: RET
// every 0 0$01 do var i , filter ;
7107: GO 7109
7109: DISABLE
7110: LD_INT 0
7112: PPUSH
7113: PPUSH
// begin enable ;
7114: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7115: LD_INT 22
7117: PUSH
7118: LD_INT 1
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 25
7127: PUSH
7128: LD_INT 4
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: LD_INT 0
7146: GREATER
7147: IFFALSE 7156
// RaiseSailEvent ( 3 ) ;
7149: LD_INT 3
7151: PPUSH
7152: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7156: LD_INT 22
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 21
7168: PUSH
7169: LD_INT 3
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 0
7205: GREATER
7206: IFFALSE 7217
// RaiseSailEvent ( 1 ) else
7208: LD_INT 1
7210: PPUSH
7211: CALL_OW 427
7215: GO 7224
// RaiseSailEvent ( 2 ) ;
7217: LD_INT 2
7219: PPUSH
7220: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7224: LD_INT 22
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 30
7236: PUSH
7237: LD_INT 5
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PPUSH
7248: CALL_OW 69
7252: PUSH
7253: LD_INT 0
7255: GREATER
7256: IFFALSE 7265
// RaiseSailEvent ( 4 ) ;
7258: LD_INT 4
7260: PPUSH
7261: CALL_OW 427
// if gamma_towers > 0 then
7265: LD_EXP 18
7269: PUSH
7270: LD_INT 0
7272: GREATER
7273: IFFALSE 7282
// RaiseSailEvent ( 5 ) ;
7275: LD_INT 5
7277: PPUSH
7278: CALL_OW 427
// end ;
7282: PPOPN 2
7284: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7285: GO 7287
7287: DISABLE
7288: LD_INT 0
7290: PPUSH
7291: PPUSH
// begin enable ;
7292: ENABLE
// if new_veh > 0 then
7293: LD_EXP 19
7297: PUSH
7298: LD_INT 0
7300: GREATER
7301: IFFALSE 7488
// while ( new_veh > 0 ) do
7303: LD_EXP 19
7307: PUSH
7308: LD_INT 0
7310: GREATER
7311: IFFALSE 7488
// begin Wait ( 0 0$01 ) ;
7313: LD_INT 35
7315: PPUSH
7316: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7320: LD_INT 26
7322: PPUSH
7323: CALL_OW 461
7327: PUSH
7328: LD_INT 2
7330: EQUAL
7331: IFFALSE 7486
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7333: LD_ADDR_VAR 0 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 3
7343: PUSH
7344: LD_INT 3
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 1
7358: PPUSH
7359: LD_INT 4
7361: PPUSH
7362: CALL_OW 12
7366: ARRAY
7367: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7368: LD_VAR 0 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: IN
7383: IFFALSE 7418
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: LD_INT 4
7392: PUSH
7393: LD_INT 5
7395: PUSH
7396: LD_INT 7
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 1
7406: PPUSH
7407: LD_INT 3
7409: PPUSH
7410: CALL_OW 12
7414: ARRAY
7415: ST_TO_ADDR
7416: GO 7449
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_INT 5
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: LD_INT 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 3
7442: PPUSH
7443: CALL_OW 12
7447: ARRAY
7448: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7449: LD_INT 26
7451: PPUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: LD_INT 2
7462: PPUSH
7463: LD_VAR 0 2
7467: PPUSH
7468: CALL_OW 125
// new_veh := new_veh - 1 ;
7472: LD_ADDR_EXP 19
7476: PUSH
7477: LD_EXP 19
7481: PUSH
7482: LD_INT 1
7484: MINUS
7485: ST_TO_ADDR
// end ; end ;
7486: GO 7303
// end ;
7488: PPOPN 2
7490: END
// every 0 0$01 do var v , filter , am_cmeh ;
7491: GO 7493
7493: DISABLE
7494: LD_INT 0
7496: PPUSH
7497: PPUSH
7498: PPUSH
// begin enable ;
7499: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7500: LD_ADDR_VAR 0 3
7504: PUSH
7505: LD_INT 56
7507: PPUSH
7508: CALL_OW 313
7512: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 33
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 50
7540: PUSH
7541: EMPTY
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: EMPTY
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: ST_TO_ADDR
// if filter > 0 then
7557: LD_VAR 0 2
7561: PUSH
7562: LD_INT 0
7564: GREATER
7565: IFFALSE 7633
// begin for v in filter do
7567: LD_ADDR_VAR 0 1
7571: PUSH
7572: LD_VAR 0 2
7576: PUSH
7577: FOR_IN
7578: IFFALSE 7631
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7580: LD_VAR 0 1
7584: PPUSH
7585: CALL_OW 312
7589: NOT
7590: PUSH
7591: LD_VAR 0 1
7595: PPUSH
7596: CALL_OW 302
7600: AND
7601: IFFALSE 7629
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_VAR 0 3
7612: PUSH
7613: LD_INT 1
7615: PPUSH
7616: LD_INT 3
7618: PPUSH
7619: CALL_OW 12
7623: ARRAY
7624: PPUSH
7625: CALL_OW 135
// end ;
7629: GO 7577
7631: POP
7632: POP
// end ; end ;
7633: PPOPN 3
7635: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7636: LD_INT 33
7638: PUSH
7639: LD_INT 2
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 3
7648: PUSH
7649: LD_INT 34
7651: PUSH
7652: LD_INT 13
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: PUSH
7672: LD_INT 4
7674: PUSH
7675: LD_INT 5
7677: PUSH
7678: LD_INT 7
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_EXP 1
7690: ARRAY
7691: EQUAL
7692: PUSH
7693: LD_INT 26
7695: PPUSH
7696: CALL_OW 461
7700: PUSH
7701: LD_INT 2
7703: EQUAL
7704: AND
7705: IFFALSE 7916
7707: GO 7709
7709: DISABLE
7710: LD_INT 0
7712: PPUSH
7713: PPUSH
7714: PPUSH
// begin enable ;
7715: ENABLE
// if Sikorski_Ar then
7716: LD_EXP 12
7720: IFFALSE 7797
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7722: LD_ADDR_EXP 11
7726: PUSH
7727: LD_INT 2
7729: PUSH
7730: LD_INT 22
7732: PUSH
7733: LD_INT 4
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 22
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 33
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 34
7765: PUSH
7766: LD_INT 13
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: ST_TO_ADDR
7795: GO 7838
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7797: LD_ADDR_EXP 11
7801: PUSH
7802: LD_INT 33
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 3
7814: PUSH
7815: LD_INT 34
7817: PUSH
7818: LD_INT 13
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 69
7837: ST_TO_ADDR
// repeat begin for un in SForce do
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_EXP 11
7847: PUSH
7848: FOR_IN
7849: IFFALSE 7904
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7851: LD_ADDR_VAR 0 3
7855: PUSH
7856: LD_INT 22
7858: PUSH
7859: LD_INT 3
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7871: LD_VAR 0 2
7875: PPUSH
7876: LD_VAR 0 3
7880: PPUSH
7881: LD_VAR 0 2
7885: PPUSH
7886: CALL_OW 74
7890: PPUSH
7891: CALL_OW 115
// Wait ( 0 0$01 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// end ;
7902: GO 7848
7904: POP
7905: POP
// end until SForce = 0 ;
7906: LD_EXP 11
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7838
// end ;
7916: PPOPN 3
7918: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7919: LD_INT 0
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
7925: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7926: LD_ADDR_VAR 0 6
7930: PUSH
7931: LD_INT 14
7933: PPUSH
7934: EMPTY
7935: PPUSH
7936: CALL_OW 70
7940: ST_TO_ADDR
// if tmp then
7941: LD_VAR 0 6
7945: IFFALSE 7979
// for i in tmp do
7947: LD_ADDR_VAR 0 3
7951: PUSH
7952: LD_VAR 0 6
7956: PUSH
7957: FOR_IN
7958: IFFALSE 7977
// ComMoveXY ( i , 42 , 23 ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: LD_INT 42
7967: PPUSH
7968: LD_INT 23
7970: PPUSH
7971: CALL_OW 111
7975: GO 7957
7977: POP
7978: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7979: LD_INT 14
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: CALL_OW 286
// uc_side := 4 ;
7989: LD_ADDR_OWVAR 20
7993: PUSH
7994: LD_INT 4
7996: ST_TO_ADDR
// uc_nation := 1 ;
7997: LD_ADDR_OWVAR 21
8001: PUSH
8002: LD_INT 1
8004: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8005: LD_ADDR_OWVAR 37
8009: PUSH
8010: LD_INT 4
8012: ST_TO_ADDR
// vc_control := control_manual ;
8013: LD_ADDR_OWVAR 38
8017: PUSH
8018: LD_INT 1
8020: ST_TO_ADDR
// vc_engine := engine_combustion ;
8021: LD_ADDR_OWVAR 39
8025: PUSH
8026: LD_INT 1
8028: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8029: LD_ADDR_OWVAR 40
8033: PUSH
8034: LD_INT 4
8036: PUSH
8037: LD_INT 5
8039: PUSH
8040: LD_INT 7
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_EXP 1
8052: ARRAY
8053: ST_TO_ADDR
// veh := CreateVehicle ;
8054: LD_ADDR_VAR 0 5
8058: PUSH
8059: CALL_OW 45
8063: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8064: LD_VAR 0 5
8068: PPUSH
8069: LD_INT 2
8071: PPUSH
8072: LD_INT 0
8074: PPUSH
8075: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8079: LD_EXP 9
8083: PPUSH
8084: LD_VAR 0 5
8088: PPUSH
8089: CALL_OW 52
// SetMark ( veh , 1 ) ;
8093: LD_VAR 0 5
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 242
// while ( num > 0 ) do
8105: LD_VAR 0 1
8109: PUSH
8110: LD_INT 0
8112: GREATER
8113: IFFALSE 8280
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8115: LD_INT 3
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: LD_INT 3
8123: PUSH
8124: LD_INT 4
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_EXP 1
8137: PPUSH
8138: LD_INT 4
8140: PPUSH
8141: CALL_OW 12
8145: ARRAY
8146: PPUSH
8147: LD_INT 1
8149: PPUSH
8150: LD_INT 4
8152: PUSH
8153: LD_INT 5
8155: PUSH
8156: LD_INT 5
8158: PUSH
8159: LD_INT 7
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_EXP 1
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 11
8188: PPUSH
8189: LD_INT 2
8191: PPUSH
8192: LD_INT 5
8194: PUSH
8195: LD_INT 6
8197: PUSH
8198: LD_INT 7
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_EXP 1
8210: ARRAY
8211: PPUSH
8212: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8216: LD_ADDR_VAR 0 4
8220: PUSH
8221: LD_INT 22
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 69
8235: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8236: LD_VAR 0 4
8240: PUSH
8241: LD_VAR 0 4
8245: ARRAY
8246: PPUSH
8247: LD_INT 36
8249: PPUSH
8250: LD_INT 18
8252: PPUSH
8253: CALL_OW 111
// Wait ( 0 0$02 ) ;
8257: LD_INT 70
8259: PPUSH
8260: CALL_OW 67
// num := num - 1 ;
8264: LD_ADDR_VAR 0 1
8268: PUSH
8269: LD_VAR 0 1
8273: PUSH
8274: LD_INT 1
8276: MINUS
8277: ST_TO_ADDR
// end ;
8278: GO 8105
// end ;
8280: LD_VAR 0 2
8284: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8285: LD_EXP 17
8289: PUSH
8290: LD_INT 0
8292: GREATER
8293: IFFALSE 8562
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
// begin enable ;
8301: ENABLE
// for i = 1 to patrol do
8302: LD_ADDR_VAR 0 1
8306: PUSH
8307: DOUBLE
8308: LD_INT 1
8310: DEC
8311: ST_TO_ADDR
8312: LD_EXP 17
8316: PUSH
8317: FOR_TO
8318: IFFALSE 8560
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8320: LD_EXP 17
8324: PUSH
8325: LD_VAR 0 1
8329: ARRAY
8330: PUSH
8331: LD_EXP 17
8335: PUSH
8336: LD_VAR 0 1
8340: ARRAY
8341: PPUSH
8342: CALL_OW 300
8346: AND
8347: PUSH
8348: LD_EXP 17
8352: PUSH
8353: LD_VAR 0 1
8357: ARRAY
8358: PPUSH
8359: CALL_OW 314
8363: NOT
8364: AND
8365: IFFALSE 8515
// case i of 1 :
8367: LD_VAR 0 1
8371: PUSH
8372: LD_INT 1
8374: DOUBLE
8375: EQUAL
8376: IFTRUE 8380
8378: GO 8443
8380: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8381: LD_EXP 17
8385: PUSH
8386: LD_VAR 0 1
8390: ARRAY
8391: PPUSH
8392: LD_INT 53
8394: PPUSH
8395: LD_INT 91
8397: PPUSH
8398: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8402: LD_EXP 17
8406: PUSH
8407: LD_VAR 0 1
8411: ARRAY
8412: PPUSH
8413: LD_INT 245
8415: PPUSH
8416: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8420: LD_EXP 17
8424: PUSH
8425: LD_VAR 0 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 24
8433: PPUSH
8434: LD_INT 26
8436: PPUSH
8437: CALL_OW 171
// end ; 2 :
8441: GO 8515
8443: LD_INT 2
8445: DOUBLE
8446: EQUAL
8447: IFTRUE 8451
8449: GO 8514
8451: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8452: LD_EXP 17
8456: PUSH
8457: LD_VAR 0 1
8461: ARRAY
8462: PPUSH
8463: LD_INT 83
8465: PPUSH
8466: LD_INT 57
8468: PPUSH
8469: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8473: LD_EXP 17
8477: PUSH
8478: LD_VAR 0 1
8482: ARRAY
8483: PPUSH
8484: LD_INT 245
8486: PPUSH
8487: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8491: LD_EXP 17
8495: PUSH
8496: LD_VAR 0 1
8500: ARRAY
8501: PPUSH
8502: LD_INT 47
8504: PPUSH
8505: LD_INT 53
8507: PPUSH
8508: CALL_OW 171
// end ; end ;
8512: GO 8515
8514: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8515: LD_EXP 17
8519: PUSH
8520: LD_VAR 0 1
8524: ARRAY
8525: PPUSH
8526: CALL_OW 256
8530: PUSH
8531: LD_INT 1000
8533: LESS
8534: IFFALSE 8558
// patrol := patrol diff patrol [ i ] ;
8536: LD_ADDR_EXP 17
8540: PUSH
8541: LD_EXP 17
8545: PUSH
8546: LD_EXP 17
8550: PUSH
8551: LD_VAR 0 1
8555: ARRAY
8556: DIFF
8557: ST_TO_ADDR
// end ;
8558: GO 8317
8560: POP
8561: POP
// end ;
8562: PPOPN 1
8564: END
// every 0 0$10 do
8565: GO 8567
8567: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8568: LD_INT 42000
8570: PUSH
8571: LD_INT 37800
8573: PUSH
8574: LD_INT 33600
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_EXP 1
8586: ARRAY
8587: PPUSH
8588: CALL_OW 67
// if not contact_am then
8592: LD_EXP 16
8596: NOT
8597: IFFALSE 8607
// contact_am := true ;
8599: LD_ADDR_EXP 16
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// end ; end_of_file
8607: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8608: LD_INT 0
8610: PPUSH
// comp_tested := false ;
8611: LD_ADDR_EXP 22
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sikorski_run := false ;
8619: LD_ADDR_EXP 23
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// InGameOn ;
8627: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8631: LD_EXP 3
8635: PPUSH
8636: CALL_OW 87
// Wait ( 0 0$01 ) ;
8640: LD_INT 35
8642: PPUSH
8643: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8647: LD_EXP 2
8651: PPUSH
8652: LD_STRING Dpop1
8654: PPUSH
8655: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8659: LD_EXP 3
8663: PPUSH
8664: LD_STRING Dcomm1
8666: PPUSH
8667: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8671: LD_EXP 2
8675: PPUSH
8676: LD_STRING Dpop2
8678: PPUSH
8679: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8683: LD_EXP 3
8687: PPUSH
8688: LD_STRING Dcomm2
8690: PPUSH
8691: CALL_OW 88
// InGameOff ;
8695: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8699: LD_STRING T1
8701: PPUSH
8702: CALL_OW 337
// end ;
8706: LD_VAR 0 1
8710: RET
// every 0 0$01 trigger timer > 2 2$01 do
8711: LD_EXP 24
8715: PUSH
8716: LD_INT 4235
8718: GREATER
8719: IFFALSE 8736
8721: GO 8723
8723: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8724: LD_EXP 5
8728: PPUSH
8729: LD_STRING DKap1
8731: PPUSH
8732: CALL_OW 94
// end ;
8736: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8737: LD_EXP 24
8741: PUSH
8742: LD_INT 46200
8744: PUSH
8745: LD_INT 52500
8747: PUSH
8748: LD_INT 63000
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: LD_EXP 1
8760: ARRAY
8761: GREATER
8762: IFFALSE 9129
8764: GO 8766
8766: DISABLE
8767: LD_INT 0
8769: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8770: LD_EXP 5
8774: PPUSH
8775: LD_STRING DKap2
8777: PPUSH
8778: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8782: LD_INT 10
8784: PPUSH
8785: CALL_OW 67
// Say ( commander , Dcommk ) ;
8789: LD_EXP 3
8793: PPUSH
8794: LD_STRING Dcommk
8796: PPUSH
8797: CALL_OW 88
// Wait ( 0 0$44 ) ;
8801: LD_INT 1540
8803: PPUSH
8804: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8808: LD_EXP 5
8812: PPUSH
8813: LD_INT 3
8815: PPUSH
8816: LD_INT 0
8818: PPUSH
8819: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8823: LD_EXP 5
8827: PPUSH
8828: CALL_OW 87
// Wait ( 0 0$10 ) ;
8832: LD_INT 350
8834: PPUSH
8835: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8839: LD_INT 6
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 8
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_EXP 1
8857: ARRAY
8858: PPUSH
8859: CALL 7919 0 1
// Wait ( 2 2$00 ) ;
8863: LD_INT 4200
8865: PPUSH
8866: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8870: LD_INT 33
8872: PUSH
8873: LD_INT 2
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 3
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 13
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 69
8905: PUSH
8906: LD_INT 3
8908: LESS
8909: IFFALSE 8920
// Wait ( 0 0$01 ) ;
8911: LD_INT 35
8913: PPUSH
8914: CALL_OW 67
8918: GO 8870
// uc_side := 4 ;
8920: LD_ADDR_OWVAR 20
8924: PUSH
8925: LD_INT 4
8927: ST_TO_ADDR
// uc_nation := 1 ;
8928: LD_ADDR_OWVAR 21
8932: PUSH
8933: LD_INT 1
8935: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8936: LD_ADDR_VAR 0 1
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_INT 4
8948: PUSH
8949: LD_INT 5
8951: PUSH
8952: LD_INT 6
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: PUSH
8960: LD_EXP 1
8964: ARRAY
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9009
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8969: LD_INT 1
8971: PPUSH
8972: LD_INT 5
8974: PUSH
8975: LD_INT 6
8977: PUSH
8978: LD_INT 7
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: LIST
8985: PUSH
8986: LD_EXP 1
8990: ARRAY
8991: PPUSH
8992: CALL 734 0 2
8996: PPUSH
8997: LD_INT 4
8999: PPUSH
9000: LD_INT 0
9002: PPUSH
9003: CALL_OW 49
9007: GO 8966
9009: POP
9010: POP
// sikorski_ar := true ;
9011: LD_ADDR_EXP 12
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9019: LD_EXP 9
9023: PPUSH
9024: LD_STRING DSik1
9026: PPUSH
9027: CALL_OW 94
// Wait ( 0 0$30 ) ;
9031: LD_INT 1050
9033: PPUSH
9034: CALL_OW 67
// uc_side := 4 ;
9038: LD_ADDR_OWVAR 20
9042: PUSH
9043: LD_INT 4
9045: ST_TO_ADDR
// uc_nation := 1 ;
9046: LD_ADDR_OWVAR 21
9050: PUSH
9051: LD_INT 1
9053: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: DOUBLE
9060: LD_INT 1
9062: DEC
9063: ST_TO_ADDR
9064: LD_INT 3
9066: PUSH
9067: LD_INT 4
9069: PUSH
9070: LD_INT 4
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_EXP 1
9082: ARRAY
9083: PUSH
9084: FOR_TO
9085: IFFALSE 9127
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9087: LD_INT 1
9089: PPUSH
9090: LD_INT 5
9092: PUSH
9093: LD_INT 6
9095: PUSH
9096: LD_INT 7
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: LD_EXP 1
9108: ARRAY
9109: PPUSH
9110: CALL 734 0 2
9114: PPUSH
9115: LD_INT 13
9117: PPUSH
9118: LD_INT 0
9120: PPUSH
9121: CALL_OW 49
9125: GO 9084
9127: POP
9128: POP
// end ;
9129: PPOPN 1
9131: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9132: LD_EXP 9
9136: PPUSH
9137: CALL_OW 256
9141: PUSH
9142: LD_INT 650
9144: LESS
9145: IFFALSE 9227
9147: GO 9149
9149: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9150: LD_EXP 9
9154: PPUSH
9155: LD_STRING DSik2
9157: PPUSH
9158: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9162: LD_EXP 9
9166: PPUSH
9167: CALL_OW 300
9171: IFFALSE 9227
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9173: LD_EXP 9
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 113
// Wait ( 0 0$01 ) ;
9185: LD_INT 35
9187: PPUSH
9188: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9192: LD_EXP 9
9196: PPUSH
9197: LD_INT 2
9199: PPUSH
9200: CALL_OW 308
9204: IFFALSE 9225
// begin RemoveUnit ( sikorski ) ;
9206: LD_EXP 9
9210: PPUSH
9211: CALL_OW 64
// break ;
9215: GO 9227
// sikorski_run := true ;
9217: LD_ADDR_EXP 23
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// end ; end ;
9225: GO 9162
// end ;
9227: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9228: LD_EXP 9
9232: PPUSH
9233: CALL_OW 256
9237: PUSH
9238: LD_INT 1000
9240: LESS
9241: IFFALSE 9258
9243: GO 9245
9245: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9246: LD_EXP 9
9250: PPUSH
9251: LD_STRING DSkik3
9253: PPUSH
9254: CALL_OW 88
9258: END
// every 1 1$45 + 0 0$15 do
9259: GO 9261
9261: DISABLE
// begin enable ;
9262: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9263: LD_INT 1
9265: PPUSH
9266: LD_INT 5
9268: PPUSH
9269: CALL_OW 12
9273: PPUSH
9274: LD_INT 8
9276: PPUSH
9277: LD_INT 1
9279: PPUSH
9280: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9284: LD_INT 350
9286: PPUSH
9287: LD_INT 1295
9289: PPUSH
9290: CALL_OW 12
9294: PPUSH
9295: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9299: LD_INT 1
9301: PPUSH
9302: LD_INT 5
9304: PPUSH
9305: CALL_OW 12
9309: PPUSH
9310: LD_INT 1
9312: PPUSH
9313: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9317: LD_INT 350
9319: PPUSH
9320: LD_INT 1050
9322: PPUSH
9323: CALL_OW 12
9327: PPUSH
9328: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9332: LD_EXP 24
9336: PUSH
9337: LD_INT 25200
9339: PUSH
9340: LD_INT 23100
9342: PUSH
9343: LD_INT 21000
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_EXP 1
9355: ARRAY
9356: LESSEQUAL
9357: IFFALSE 9380
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9359: LD_INT 1
9361: PPUSH
9362: LD_INT 5
9364: PPUSH
9365: CALL_OW 12
9369: PPUSH
9370: LD_INT 8
9372: PPUSH
9373: LD_INT 1
9375: PPUSH
9376: CALL_OW 55
// end ;
9380: END
// export timer ; every 1 do
9381: GO 9383
9383: DISABLE
// timer := 0 0$00 ;
9384: LD_ADDR_EXP 24
9388: PUSH
9389: LD_INT 0
9391: ST_TO_ADDR
9392: END
// every 0 0$01 do
9393: GO 9395
9395: DISABLE
// begin enable ;
9396: ENABLE
// Display_Strings := [ #tick , timer ] ;
9397: LD_ADDR_OWVAR 47
9401: PUSH
9402: LD_STRING #tick
9404: PUSH
9405: LD_EXP 24
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9414: LD_ADDR_EXP 24
9418: PUSH
9419: LD_EXP 24
9423: PUSH
9424: LD_INT 35
9426: PLUS
9427: ST_TO_ADDR
// end ; end_of_file
9428: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9429: GO 9431
9431: DISABLE
// begin ru_radar := 98 ;
9432: LD_ADDR_EXP 25
9436: PUSH
9437: LD_INT 98
9439: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9440: LD_ADDR_EXP 26
9444: PUSH
9445: LD_INT 89
9447: ST_TO_ADDR
// us_hack := 99 ;
9448: LD_ADDR_EXP 27
9452: PUSH
9453: LD_INT 99
9455: ST_TO_ADDR
// us_artillery := 97 ;
9456: LD_ADDR_EXP 28
9460: PUSH
9461: LD_INT 97
9463: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9464: LD_ADDR_EXP 29
9468: PUSH
9469: LD_INT 91
9471: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
9472: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
9473: LD_INT 0
9475: PPUSH
9476: PPUSH
9477: PPUSH
9478: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
9479: LD_VAR 0 1
9483: PPUSH
9484: CALL_OW 264
9488: PUSH
9489: LD_EXP 29
9493: EQUAL
9494: IFFALSE 9566
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
9496: LD_INT 68
9498: PPUSH
9499: LD_VAR 0 1
9503: PPUSH
9504: CALL_OW 255
9508: PPUSH
9509: CALL_OW 321
9513: PUSH
9514: LD_INT 2
9516: EQUAL
9517: IFFALSE 9529
// eff := 70 else
9519: LD_ADDR_VAR 0 6
9523: PUSH
9524: LD_INT 70
9526: ST_TO_ADDR
9527: GO 9537
// eff := 30 ;
9529: LD_ADDR_VAR 0 6
9533: PUSH
9534: LD_INT 30
9536: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
9537: LD_VAR 0 1
9541: PPUSH
9542: CALL_OW 250
9546: PPUSH
9547: LD_VAR 0 1
9551: PPUSH
9552: CALL_OW 251
9556: PPUSH
9557: LD_VAR 0 6
9561: PPUSH
9562: CALL_OW 495
// end ; end ;
9566: LD_VAR 0 4
9570: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
9571: LD_INT 0
9573: PPUSH
9574: PPUSH
9575: PPUSH
9576: PPUSH
9577: PPUSH
9578: PPUSH
// if cmd = 124 then
9579: LD_VAR 0 1
9583: PUSH
9584: LD_INT 124
9586: EQUAL
9587: IFFALSE 9793
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
9589: LD_ADDR_VAR 0 5
9593: PUSH
9594: LD_INT 2
9596: PUSH
9597: LD_INT 34
9599: PUSH
9600: LD_INT 53
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 34
9609: PUSH
9610: LD_INT 14
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: LIST
9621: PPUSH
9622: CALL_OW 69
9626: ST_TO_ADDR
// if not tmp then
9627: LD_VAR 0 5
9631: NOT
9632: IFFALSE 9636
// exit ;
9634: GO 9793
// for i in tmp do
9636: LD_ADDR_VAR 0 3
9640: PUSH
9641: LD_VAR 0 5
9645: PUSH
9646: FOR_IN
9647: IFFALSE 9791
// begin taskList := GetTaskList ( i ) ;
9649: LD_ADDR_VAR 0 6
9653: PUSH
9654: LD_VAR 0 3
9658: PPUSH
9659: CALL_OW 437
9663: ST_TO_ADDR
// if not taskList then
9664: LD_VAR 0 6
9668: NOT
9669: IFFALSE 9673
// continue ;
9671: GO 9646
// for j = 1 to taskList do
9673: LD_ADDR_VAR 0 4
9677: PUSH
9678: DOUBLE
9679: LD_INT 1
9681: DEC
9682: ST_TO_ADDR
9683: LD_VAR 0 6
9687: PUSH
9688: FOR_TO
9689: IFFALSE 9787
// if taskList [ j ] [ 1 ] = | then
9691: LD_VAR 0 6
9695: PUSH
9696: LD_VAR 0 4
9700: ARRAY
9701: PUSH
9702: LD_INT 1
9704: ARRAY
9705: PUSH
9706: LD_STRING |
9708: EQUAL
9709: IFFALSE 9785
// begin _taskList := Delete ( taskList , 1 ) ;
9711: LD_ADDR_VAR 0 7
9715: PUSH
9716: LD_VAR 0 6
9720: PPUSH
9721: LD_INT 1
9723: PPUSH
9724: CALL_OW 3
9728: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
9729: LD_VAR 0 3
9733: PPUSH
9734: LD_VAR 0 7
9738: PPUSH
9739: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
9743: LD_VAR 0 3
9747: PPUSH
9748: LD_VAR 0 6
9752: PUSH
9753: LD_VAR 0 4
9757: ARRAY
9758: PUSH
9759: LD_INT 2
9761: ARRAY
9762: PPUSH
9763: LD_VAR 0 6
9767: PUSH
9768: LD_VAR 0 4
9772: ARRAY
9773: PUSH
9774: LD_INT 3
9776: ARRAY
9777: PPUSH
9778: LD_INT 8
9780: PPUSH
9781: CALL 9798 0 4
// end ;
9785: GO 9688
9787: POP
9788: POP
// end ;
9789: GO 9646
9791: POP
9792: POP
// end ; end ;
9793: LD_VAR 0 2
9797: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
9798: LD_INT 0
9800: PPUSH
9801: PPUSH
9802: PPUSH
9803: PPUSH
9804: PPUSH
9805: PPUSH
9806: PPUSH
9807: PPUSH
9808: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
9809: LD_VAR 0 1
9813: NOT
9814: PUSH
9815: LD_VAR 0 2
9819: PPUSH
9820: LD_VAR 0 3
9824: PPUSH
9825: CALL_OW 488
9829: NOT
9830: OR
9831: PUSH
9832: LD_VAR 0 4
9836: NOT
9837: OR
9838: IFFALSE 9842
// exit ;
9840: GO 10182
// list := [ ] ;
9842: LD_ADDR_VAR 0 13
9846: PUSH
9847: EMPTY
9848: ST_TO_ADDR
// if x - r < 0 then
9849: LD_VAR 0 2
9853: PUSH
9854: LD_VAR 0 4
9858: MINUS
9859: PUSH
9860: LD_INT 0
9862: LESS
9863: IFFALSE 9875
// min_x := 0 else
9865: LD_ADDR_VAR 0 7
9869: PUSH
9870: LD_INT 0
9872: ST_TO_ADDR
9873: GO 9891
// min_x := x - r ;
9875: LD_ADDR_VAR 0 7
9879: PUSH
9880: LD_VAR 0 2
9884: PUSH
9885: LD_VAR 0 4
9889: MINUS
9890: ST_TO_ADDR
// if y - r < 0 then
9891: LD_VAR 0 3
9895: PUSH
9896: LD_VAR 0 4
9900: MINUS
9901: PUSH
9902: LD_INT 0
9904: LESS
9905: IFFALSE 9917
// min_y := 0 else
9907: LD_ADDR_VAR 0 8
9911: PUSH
9912: LD_INT 0
9914: ST_TO_ADDR
9915: GO 9933
// min_y := y - r ;
9917: LD_ADDR_VAR 0 8
9921: PUSH
9922: LD_VAR 0 3
9926: PUSH
9927: LD_VAR 0 4
9931: MINUS
9932: ST_TO_ADDR
// max_x := x + r ;
9933: LD_ADDR_VAR 0 9
9937: PUSH
9938: LD_VAR 0 2
9942: PUSH
9943: LD_VAR 0 4
9947: PLUS
9948: ST_TO_ADDR
// max_y := y + r ;
9949: LD_ADDR_VAR 0 10
9953: PUSH
9954: LD_VAR 0 3
9958: PUSH
9959: LD_VAR 0 4
9963: PLUS
9964: ST_TO_ADDR
// for _x = min_x to max_x do
9965: LD_ADDR_VAR 0 11
9969: PUSH
9970: DOUBLE
9971: LD_VAR 0 7
9975: DEC
9976: ST_TO_ADDR
9977: LD_VAR 0 9
9981: PUSH
9982: FOR_TO
9983: IFFALSE 10100
// for _y = min_y to max_y do
9985: LD_ADDR_VAR 0 12
9989: PUSH
9990: DOUBLE
9991: LD_VAR 0 8
9995: DEC
9996: ST_TO_ADDR
9997: LD_VAR 0 10
10001: PUSH
10002: FOR_TO
10003: IFFALSE 10096
// begin if not ValidHex ( _x , _y ) then
10005: LD_VAR 0 11
10009: PPUSH
10010: LD_VAR 0 12
10014: PPUSH
10015: CALL_OW 488
10019: NOT
10020: IFFALSE 10024
// continue ;
10022: GO 10002
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
10024: LD_VAR 0 11
10028: PPUSH
10029: LD_VAR 0 12
10033: PPUSH
10034: CALL_OW 351
10038: PUSH
10039: LD_VAR 0 11
10043: PPUSH
10044: LD_VAR 0 12
10048: PPUSH
10049: CALL_OW 554
10053: AND
10054: IFFALSE 10094
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
10056: LD_ADDR_VAR 0 13
10060: PUSH
10061: LD_VAR 0 13
10065: PPUSH
10066: LD_VAR 0 13
10070: PUSH
10071: LD_INT 1
10073: PLUS
10074: PPUSH
10075: LD_VAR 0 11
10079: PUSH
10080: LD_VAR 0 12
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PPUSH
10089: CALL_OW 2
10093: ST_TO_ADDR
// end ;
10094: GO 10002
10096: POP
10097: POP
10098: GO 9982
10100: POP
10101: POP
// if not list then
10102: LD_VAR 0 13
10106: NOT
10107: IFFALSE 10111
// exit ;
10109: GO 10182
// for i in list do
10111: LD_ADDR_VAR 0 6
10115: PUSH
10116: LD_VAR 0 13
10120: PUSH
10121: FOR_IN
10122: IFFALSE 10180
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
10124: LD_VAR 0 1
10128: PPUSH
10129: LD_STRING M
10131: PUSH
10132: LD_VAR 0 6
10136: PUSH
10137: LD_INT 1
10139: ARRAY
10140: PUSH
10141: LD_VAR 0 6
10145: PUSH
10146: LD_INT 2
10148: ARRAY
10149: PUSH
10150: LD_INT 0
10152: PUSH
10153: LD_INT 0
10155: PUSH
10156: LD_INT 0
10158: PUSH
10159: LD_INT 0
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 447
10178: GO 10121
10180: POP
10181: POP
// end ;
10182: LD_VAR 0 5
10186: RET
