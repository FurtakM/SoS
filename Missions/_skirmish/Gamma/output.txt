// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 314 0 4
// PrepareRussian ;
  92: CALL 1392 0 0
// Action ;
  96: CALL 8495 0 0
// PrepareAmerican ;
 100: CALL 5179 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// dif := val ;
 282: LD_ADDR_EXP 1
 286: PUSH
 287: LD_VAR 0 1
 291: ST_TO_ADDR
// if dif < 3 then
 292: LD_EXP 1
 296: PUSH
 297: LD_INT 3
 299: LESS
 300: IFFALSE 309
// RemoveEnvironmentArea ( evnt ) ;
 302: LD_INT 9
 304: PPUSH
 305: CALL_OW 355
// end ;
 309: LD_VAR 0 2
 313: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 314: LD_INT 0
 316: PPUSH
 317: PPUSH
 318: PPUSH
 319: PPUSH
 320: PPUSH
// uc_nation = nation_nature ;
 321: LD_ADDR_OWVAR 21
 325: PUSH
 326: LD_INT 0
 328: ST_TO_ADDR
// uc_side = 0 ;
 329: LD_ADDR_OWVAR 20
 333: PUSH
 334: LD_INT 0
 336: ST_TO_ADDR
// hc_importance := 0 ;
 337: LD_ADDR_OWVAR 32
 341: PUSH
 342: LD_INT 0
 344: ST_TO_ADDR
// l = 0 ;
 345: LD_ADDR_VAR 0 6
 349: PUSH
 350: LD_INT 0
 352: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 353: LD_ADDR_OWVAR 24
 357: PUSH
 358: LD_INT 0
 360: PPUSH
 361: LD_INT 5
 363: PPUSH
 364: CALL_OW 12
 368: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 369: LD_ADDR_OWVAR 35
 373: PUSH
 374: LD_INT 5
 376: NEG
 377: PPUSH
 378: LD_INT 5
 380: PPUSH
 381: CALL_OW 12
 385: ST_TO_ADDR
// hc_gallery =  ;
 386: LD_ADDR_OWVAR 33
 390: PUSH
 391: LD_STRING 
 393: ST_TO_ADDR
// hc_class = class_apeman ;
 394: LD_ADDR_OWVAR 28
 398: PUSH
 399: LD_INT 12
 401: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 402: LD_ADDR_OWVAR 29
 406: PUSH
 407: LD_INT 11
 409: PPUSH
 410: LD_INT 13
 412: PPUSH
 413: CALL_OW 12
 417: PUSH
 418: LD_INT 10
 420: PPUSH
 421: LD_INT 11
 423: PPUSH
 424: CALL_OW 12
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: ST_TO_ADDR
// hc_sex = sex_male ;
 433: LD_ADDR_OWVAR 27
 437: PUSH
 438: LD_INT 1
 440: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 441: LD_ADDR_OWVAR 31
 445: PUSH
 446: LD_INT 0
 448: PPUSH
 449: LD_INT 2
 451: PPUSH
 452: CALL_OW 12
 456: PUSH
 457: LD_INT 0
 459: PUSH
 460: LD_INT 0
 462: PUSH
 463: LD_INT 0
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: ST_TO_ADDR
// apeman = CreateHuman ;
 472: LD_ADDR_VAR 0 7
 476: PUSH
 477: CALL_OW 44
 481: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 482: LD_VAR 0 7
 486: PPUSH
 487: LD_VAR 0 4
 491: PPUSH
 492: LD_INT 0
 494: PPUSH
 495: CALL_OW 49
// l = l + 1 ;
 499: LD_ADDR_VAR 0 6
 503: PUSH
 504: LD_VAR 0 6
 508: PUSH
 509: LD_INT 1
 511: PLUS
 512: ST_TO_ADDR
// end until l = num1 ;
 513: LD_VAR 0 6
 517: PUSH
 518: LD_VAR 0 1
 522: EQUAL
 523: IFFALSE 353
// l = 0 ;
 525: LD_ADDR_VAR 0 6
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 533: LD_ADDR_OWVAR 35
 537: PUSH
 538: LD_INT 0
 540: PPUSH
 541: LD_INT 25
 543: PPUSH
 544: CALL_OW 12
 548: ST_TO_ADDR
// hc_class = class_tiger ;
 549: LD_ADDR_OWVAR 28
 553: PUSH
 554: LD_INT 14
 556: ST_TO_ADDR
// hc_sex = sex_male ;
 557: LD_ADDR_OWVAR 27
 561: PUSH
 562: LD_INT 1
 564: ST_TO_ADDR
// hc_gallery = sandnature ;
 565: LD_ADDR_OWVAR 33
 569: PUSH
 570: LD_STRING sandnature
 572: ST_TO_ADDR
// hc_face_number = 3 ;
 573: LD_ADDR_OWVAR 34
 577: PUSH
 578: LD_INT 3
 580: ST_TO_ADDR
// tiger = CreateHuman ;
 581: LD_ADDR_VAR 0 8
 585: PUSH
 586: CALL_OW 44
 590: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 591: LD_VAR 0 8
 595: PPUSH
 596: LD_VAR 0 4
 600: PPUSH
 601: LD_INT 0
 603: PPUSH
 604: CALL_OW 49
// l = l + 1 ;
 608: LD_ADDR_VAR 0 6
 612: PUSH
 613: LD_VAR 0 6
 617: PUSH
 618: LD_INT 1
 620: PLUS
 621: ST_TO_ADDR
// end until l = num2 ;
 622: LD_VAR 0 6
 626: PUSH
 627: LD_VAR 0 2
 631: EQUAL
 632: IFFALSE 533
// l = 0 ;
 634: LD_ADDR_VAR 0 6
 638: PUSH
 639: LD_INT 0
 641: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 642: LD_ADDR_OWVAR 28
 646: PUSH
 647: LD_INT 18
 649: ST_TO_ADDR
// hc_gallery = sandnature ;
 650: LD_ADDR_OWVAR 33
 654: PUSH
 655: LD_STRING sandnature
 657: ST_TO_ADDR
// hc_face_number = 1 ;
 658: LD_ADDR_OWVAR 34
 662: PUSH
 663: LD_INT 1
 665: ST_TO_ADDR
// bird = CreateHuman ;
 666: LD_ADDR_VAR 0 9
 670: PUSH
 671: CALL_OW 44
 675: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 676: LD_VAR 0 9
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: CALL_OW 51
// l = l + 1 ;
 688: LD_ADDR_VAR 0 6
 692: PUSH
 693: LD_VAR 0 6
 697: PUSH
 698: LD_INT 1
 700: PLUS
 701: ST_TO_ADDR
// end until l = num3 ;
 702: LD_VAR 0 6
 706: PUSH
 707: LD_VAR 0 3
 711: EQUAL
 712: IFFALSE 642
// end ;
 714: LD_VAR 0 5
 718: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 719: LD_INT 0
 721: PPUSH
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
 726: PPUSH
// InitHc ;
 727: CALL_OW 19
// hc_class := clas ;
 731: LD_ADDR_OWVAR 28
 735: PUSH
 736: LD_VAR 0 1
 740: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 741: LD_ADDR_VAR 0 4
 745: PUSH
 746: LD_VAR 0 2
 750: PUSH
 751: LD_INT 1
 753: NEG
 754: PPUSH
 755: LD_INT 1
 757: PPUSH
 758: CALL_OW 12
 762: PLUS
 763: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 764: LD_ADDR_VAR 0 5
 768: PUSH
 769: LD_VAR 0 2
 773: PUSH
 774: LD_INT 1
 776: NEG
 777: PPUSH
 778: LD_INT 1
 780: PPUSH
 781: CALL_OW 12
 785: PLUS
 786: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 787: LD_ADDR_VAR 0 6
 791: PUSH
 792: LD_VAR 0 2
 796: PUSH
 797: LD_INT 1
 799: NEG
 800: PPUSH
 801: LD_INT 1
 803: PPUSH
 804: CALL_OW 12
 808: PLUS
 809: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 2
 819: PUSH
 820: LD_INT 1
 822: NEG
 823: PPUSH
 824: LD_INT 1
 826: PPUSH
 827: CALL_OW 12
 831: PLUS
 832: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 833: LD_VAR 0 1
 837: PUSH
 838: LD_INT 1
 840: EQUAL
 841: PUSH
 842: LD_VAR 0 1
 846: PUSH
 847: LD_INT 9
 849: EQUAL
 850: OR
 851: PUSH
 852: LD_VAR 0 1
 856: PUSH
 857: LD_INT 5
 859: EQUAL
 860: OR
 861: PUSH
 862: LD_VAR 0 1
 866: PUSH
 867: LD_INT 8
 869: EQUAL
 870: OR
 871: IFFALSE 896
// bonus := [ 2 , 0 , 0 , 0 ] ;
 873: LD_ADDR_VAR 0 8
 877: PUSH
 878: LD_INT 2
 880: PUSH
 881: LD_INT 0
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: EMPTY
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: ST_TO_ADDR
// if clas = 2 then
 896: LD_VAR 0 1
 900: PUSH
 901: LD_INT 2
 903: EQUAL
 904: IFFALSE 929
// bonus := [ 0 , 2 , 0 , 0 ] ;
 906: LD_ADDR_VAR 0 8
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 0
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: ST_TO_ADDR
// if clas = 3 then
 929: LD_VAR 0 1
 933: PUSH
 934: LD_INT 3
 936: EQUAL
 937: IFFALSE 962
// bonus := [ 0 , 0 , 2 , 0 ] ;
 939: LD_ADDR_VAR 0 8
 943: PUSH
 944: LD_INT 0
 946: PUSH
 947: LD_INT 0
 949: PUSH
 950: LD_INT 2
 952: PUSH
 953: LD_INT 0
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: ST_TO_ADDR
// if clas = 4 then
 962: LD_VAR 0 1
 966: PUSH
 967: LD_INT 4
 969: EQUAL
 970: IFFALSE 995
// bonus := [ 0 , 0 , 0 , 2 ] ;
 972: LD_ADDR_VAR 0 8
 976: PUSH
 977: LD_INT 0
 979: PUSH
 980: LD_INT 0
 982: PUSH
 983: LD_INT 0
 985: PUSH
 986: LD_INT 2
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
 995: LD_VAR 0 1
 999: PUSH
1000: LD_INT 4
1002: GREATER
1003: PUSH
1004: LD_VAR 0 1
1008: PUSH
1009: LD_INT 9
1011: NONEQUAL
1012: AND
1013: PUSH
1014: LD_VAR 0 1
1018: PUSH
1019: LD_INT 5
1021: NONEQUAL
1022: AND
1023: PUSH
1024: LD_VAR 0 1
1028: PUSH
1029: LD_INT 8
1031: NONEQUAL
1032: AND
1033: IFFALSE 1058
// bonus := [ 0 , 0 , 0 , 0 ] ;
1035: LD_ADDR_VAR 0 8
1039: PUSH
1040: LD_INT 0
1042: PUSH
1043: LD_INT 0
1045: PUSH
1046: LD_INT 0
1048: PUSH
1049: LD_INT 0
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1058: LD_ADDR_OWVAR 30
1062: PUSH
1063: LD_INT 0
1065: PPUSH
1066: LD_INT 2
1068: PPUSH
1069: CALL_OW 12
1073: PUSH
1074: LD_INT 0
1076: PPUSH
1077: LD_INT 2
1079: PPUSH
1080: CALL_OW 12
1084: PUSH
1085: LD_INT 0
1087: PPUSH
1088: LD_INT 2
1090: PPUSH
1091: CALL_OW 12
1095: PUSH
1096: LD_INT 0
1098: PPUSH
1099: LD_INT 2
1101: PPUSH
1102: CALL_OW 12
1106: PUSH
1107: EMPTY
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1113: LD_ADDR_OWVAR 31
1117: PUSH
1118: LD_VAR 0 4
1122: PUSH
1123: LD_VAR 0 8
1127: PUSH
1128: LD_INT 1
1130: ARRAY
1131: PLUS
1132: PUSH
1133: LD_VAR 0 5
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 2
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 6
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 3
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 7
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 4
1175: ARRAY
1176: PLUS
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// if clas = 3 then
1184: LD_VAR 0 1
1188: PUSH
1189: LD_INT 3
1191: EQUAL
1192: IFFALSE 1204
// hc_sex := sex_male else
1194: LD_ADDR_OWVAR 27
1198: PUSH
1199: LD_INT 1
1201: ST_TO_ADDR
1202: GO 1220
// hc_sex := Rand ( sex_male , sex_female ) ;
1204: LD_ADDR_OWVAR 27
1208: PUSH
1209: LD_INT 1
1211: PPUSH
1212: LD_INT 2
1214: PPUSH
1215: CALL_OW 12
1219: ST_TO_ADDR
// hc_gallery :=  ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING 
1227: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1228: LD_ADDR_OWVAR 29
1232: PUSH
1233: LD_INT 8
1235: PPUSH
1236: LD_INT 12
1238: PPUSH
1239: CALL_OW 12
1243: PUSH
1244: LD_INT 8
1246: PPUSH
1247: LD_INT 12
1249: PPUSH
1250: CALL_OW 12
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// hc_name :=  ;
1259: LD_ADDR_OWVAR 26
1263: PUSH
1264: LD_STRING 
1266: ST_TO_ADDR
// result := CreateHuman ;
1267: LD_ADDR_VAR 0 3
1271: PUSH
1272: CALL_OW 44
1276: ST_TO_ADDR
// end ;
1277: LD_VAR 0 3
1281: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1282: LD_INT 0
1284: PPUSH
1285: PPUSH
// vc_chassis := chassis ;
1286: LD_ADDR_OWVAR 37
1290: PUSH
1291: LD_VAR 0 1
1295: ST_TO_ADDR
// vc_engine := engine ;
1296: LD_ADDR_OWVAR 39
1300: PUSH
1301: LD_VAR 0 2
1305: ST_TO_ADDR
// vc_weapon := weapon ;
1306: LD_ADDR_OWVAR 40
1310: PUSH
1311: LD_VAR 0 3
1315: ST_TO_ADDR
// vc_control := control_manual ;
1316: LD_ADDR_OWVAR 38
1320: PUSH
1321: LD_INT 1
1323: ST_TO_ADDR
// veh := CreateVehicle ;
1324: LD_ADDR_VAR 0 8
1328: PUSH
1329: CALL_OW 45
1333: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1334: LD_VAR 0 8
1338: PPUSH
1339: LD_VAR 0 5
1343: PPUSH
1344: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1348: LD_VAR 0 8
1352: PPUSH
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1365: LD_INT 3
1367: PPUSH
1368: LD_VAR 0 6
1372: PPUSH
1373: CALL 719 0 2
1377: PPUSH
1378: LD_VAR 0 8
1382: PPUSH
1383: CALL_OW 52
// end ; end_of_file
1387: LD_VAR 0 7
1391: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1392: LD_INT 0
1394: PPUSH
1395: PPUSH
1396: PPUSH
1397: PPUSH
1398: PPUSH
1399: PPUSH
// depot_rdy := false ;
1400: LD_ADDR_EXP 6
1404: PUSH
1405: LD_INT 0
1407: ST_TO_ADDR
// uc_side := 6 ;
1408: LD_ADDR_OWVAR 20
1412: PUSH
1413: LD_INT 6
1415: ST_TO_ADDR
// uc_nation := 3 ;
1416: LD_ADDR_OWVAR 21
1420: PUSH
1421: LD_INT 3
1423: ST_TO_ADDR
// hc_gallery := ru ;
1424: LD_ADDR_OWVAR 33
1428: PUSH
1429: LD_STRING ru
1431: ST_TO_ADDR
// hc_face_number := 10 ;
1432: LD_ADDR_OWVAR 34
1436: PUSH
1437: LD_INT 10
1439: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1440: LD_ADDR_OWVAR 26
1444: PUSH
1445: LD_STRING Siergiej I. Popov
1447: ST_TO_ADDR
// hc_class := 1 ;
1448: LD_ADDR_OWVAR 28
1452: PUSH
1453: LD_INT 1
1455: ST_TO_ADDR
// hc_sex := sex_male ;
1456: LD_ADDR_OWVAR 27
1460: PUSH
1461: LD_INT 1
1463: ST_TO_ADDR
// popov := CreateHuman ;
1464: LD_ADDR_EXP 2
1468: PUSH
1469: CALL_OW 44
1473: ST_TO_ADDR
// hc_gallery := general ;
1474: LD_ADDR_OWVAR 33
1478: PUSH
1479: LD_STRING general
1481: ST_TO_ADDR
// hc_face_number := 1 ;
1482: LD_ADDR_OWVAR 34
1486: PUSH
1487: LD_INT 1
1489: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1490: LD_ADDR_OWVAR 26
1494: PUSH
1495: LD_STRING Mjr. D. N. Platonow
1497: ST_TO_ADDR
// platonov := CreateHuman ;
1498: LD_ADDR_EXP 4
1502: PUSH
1503: CALL_OW 44
1507: ST_TO_ADDR
// uc_side := 3 ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_INT 3
1515: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1516: LD_INT 3
1518: PPUSH
1519: LD_INT 6
1521: PPUSH
1522: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1526: LD_ADDR_VAR 0 4
1530: PUSH
1531: LD_INT 6
1533: PUSH
1534: LD_INT 5
1536: PUSH
1537: LD_INT 4
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: LIST
1544: PUSH
1545: LD_EXP 1
1549: ARRAY
1550: ST_TO_ADDR
// team := [ ] ;
1551: LD_ADDR_VAR 0 5
1555: PUSH
1556: EMPTY
1557: ST_TO_ADDR
// hc_importance := 100 ;
1558: LD_ADDR_OWVAR 32
1562: PUSH
1563: LD_INT 100
1565: ST_TO_ADDR
// hc_gallery := gamma ;
1566: LD_ADDR_OWVAR 33
1570: PUSH
1571: LD_STRING gamma
1573: ST_TO_ADDR
// hc_face_number := 1 ;
1574: LD_ADDR_OWVAR 34
1578: PUSH
1579: LD_INT 1
1581: ST_TO_ADDR
// hc_class := 1 ;
1582: LD_ADDR_OWVAR 28
1586: PUSH
1587: LD_INT 1
1589: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1590: LD_ADDR_OWVAR 31
1594: PUSH
1595: LD_INT 8
1597: PUSH
1598: LD_INT 7
1600: PUSH
1601: LD_INT 6
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: LIST
1608: PUSH
1609: LD_EXP 1
1613: ARRAY
1614: PUSH
1615: LD_INT 5
1617: PUSH
1618: LD_INT 3
1620: PUSH
1621: LD_INT 0
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: ST_TO_ADDR
// hc_sex := sex_male ;
1630: LD_ADDR_OWVAR 27
1634: PUSH
1635: LD_INT 1
1637: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1638: LD_ADDR_OWVAR 26
1642: PUSH
1643: LD_STRING Mjr. Jurij Karakanov
1645: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1646: LD_ADDR_OWVAR 29
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: LD_INT 11
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: ST_TO_ADDR
// commander := CreateHuman ;
1661: LD_ADDR_EXP 3
1665: PUSH
1666: CALL_OW 44
1670: ST_TO_ADDR
// team := team ^ commander ;
1671: LD_ADDR_VAR 0 5
1675: PUSH
1676: LD_VAR 0 5
1680: PUSH
1681: LD_EXP 3
1685: ADD
1686: ST_TO_ADDR
// hc_importance := 0 ;
1687: LD_ADDR_OWVAR 32
1691: PUSH
1692: LD_INT 0
1694: ST_TO_ADDR
// hc_name :=  ;
1695: LD_ADDR_OWVAR 26
1699: PUSH
1700: LD_STRING 
1702: ST_TO_ADDR
// hc_gallery :=  ;
1703: LD_ADDR_OWVAR 33
1707: PUSH
1708: LD_STRING 
1710: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1711: LD_ADDR_OWVAR 29
1715: PUSH
1716: LD_INT 12
1718: PUSH
1719: LD_INT 10
1721: PUSH
1722: EMPTY
1723: LIST
1724: LIST
1725: ST_TO_ADDR
// hc_sex := sex_male ;
1726: LD_ADDR_OWVAR 27
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// Kapral := CreateHuman ;
1734: LD_ADDR_EXP 5
1738: PUSH
1739: CALL_OW 44
1743: ST_TO_ADDR
// for i = 3 downto dif do
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: DOUBLE
1750: LD_INT 3
1752: INC
1753: ST_TO_ADDR
1754: LD_EXP 1
1758: PUSH
1759: FOR_DOWNTO
1760: IFFALSE 1866
// begin vc_chassis := ru_medium_tracked ;
1762: LD_ADDR_OWVAR 37
1766: PUSH
1767: LD_INT 22
1769: ST_TO_ADDR
// vc_engine := engine_combustion ;
1770: LD_ADDR_OWVAR 39
1774: PUSH
1775: LD_INT 1
1777: ST_TO_ADDR
// vc_control := control_manual ;
1778: LD_ADDR_OWVAR 38
1782: PUSH
1783: LD_INT 1
1785: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1786: LD_ADDR_OWVAR 40
1790: PUSH
1791: LD_INT 43
1793: PUSH
1794: LD_INT 44
1796: PUSH
1797: LD_INT 44
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_VAR 0 2
1809: ARRAY
1810: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1811: LD_ADDR_OWVAR 41
1815: PUSH
1816: LD_INT 55
1818: PPUSH
1819: LD_INT 77
1821: PPUSH
1822: CALL_OW 12
1826: ST_TO_ADDR
// un := CreateVehicle ;
1827: LD_ADDR_VAR 0 3
1831: PUSH
1832: CALL_OW 45
1836: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1837: LD_VAR 0 3
1841: PPUSH
1842: LD_INT 5
1844: PPUSH
1845: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1849: LD_VAR 0 3
1853: PPUSH
1854: LD_INT 1
1856: PPUSH
1857: LD_INT 0
1859: PPUSH
1860: CALL_OW 49
// end ;
1864: GO 1759
1866: POP
1867: POP
// vc_weapon := ru_heavy_machine_gun ;
1868: LD_ADDR_OWVAR 40
1872: PUSH
1873: LD_INT 42
1875: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1876: LD_ADDR_OWVAR 41
1880: PUSH
1881: LD_INT 55
1883: PPUSH
1884: LD_INT 77
1886: PPUSH
1887: CALL_OW 12
1891: ST_TO_ADDR
// un := CreateVehicle ;
1892: LD_ADDR_VAR 0 3
1896: PUSH
1897: CALL_OW 45
1901: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1902: LD_VAR 0 3
1906: PPUSH
1907: LD_INT 5
1909: PPUSH
1910: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1914: LD_VAR 0 3
1918: PPUSH
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 49
// for p = 1 to 4 do
1929: LD_ADDR_VAR 0 6
1933: PUSH
1934: DOUBLE
1935: LD_INT 1
1937: DEC
1938: ST_TO_ADDR
1939: LD_INT 4
1941: PUSH
1942: FOR_TO
1943: IFFALSE 2010
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1945: LD_ADDR_VAR 0 2
1949: PUSH
1950: DOUBLE
1951: LD_INT 1
1953: DEC
1954: ST_TO_ADDR
1955: LD_INT 5
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: LD_INT 3
1963: PUSH
1964: EMPTY
1965: LIST
1966: LIST
1967: LIST
1968: PUSH
1969: LD_EXP 1
1973: ARRAY
1974: PUSH
1975: FOR_TO
1976: IFFALSE 2006
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_VAR 0 6
1992: PPUSH
1993: LD_VAR 0 4
1997: PPUSH
1998: CALL 719 0 2
2002: ADD
2003: ST_TO_ADDR
2004: GO 1975
2006: POP
2007: POP
2008: GO 1942
2010: POP
2011: POP
// for i = 1 to team do
2012: LD_ADDR_VAR 0 2
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 5
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2146
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2030: LD_VAR 0 5
2034: PUSH
2035: LD_VAR 0 2
2039: ARRAY
2040: PPUSH
2041: CALL_OW 257
2045: PUSH
2046: LD_INT 3
2048: EQUAL
2049: PUSH
2050: LD_INT 22
2052: PUSH
2053: LD_INT 3
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: PUSH
2060: LD_INT 58
2062: PUSH
2063: EMPTY
2064: LIST
2065: PUSH
2066: EMPTY
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: AND
2075: IFFALSE 2123
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2077: LD_VAR 0 5
2081: PUSH
2082: LD_VAR 0 2
2086: ARRAY
2087: PPUSH
2088: LD_INT 22
2090: PUSH
2091: LD_INT 3
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 58
2100: PUSH
2101: EMPTY
2102: LIST
2103: PUSH
2104: EMPTY
2105: LIST
2106: LIST
2107: PPUSH
2108: CALL_OW 69
2112: PUSH
2113: LD_INT 1
2115: ARRAY
2116: PPUSH
2117: CALL_OW 52
2121: GO 2144
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2123: LD_VAR 0 5
2127: PUSH
2128: LD_VAR 0 2
2132: ARRAY
2133: PPUSH
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 0
2139: PPUSH
2140: CALL_OW 49
2144: GO 2027
2146: POP
2147: POP
// end ;
2148: LD_VAR 0 1
2152: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2153: LD_EXP 6
2157: IFFALSE 2527
2159: GO 2161
2161: DISABLE
2162: LD_INT 0
2164: PPUSH
2165: PPUSH
2166: PPUSH
2167: PPUSH
// begin Wait ( 0 0$07 ) ;
2168: LD_INT 245
2170: PPUSH
2171: CALL_OW 67
// l := 0 ;
2175: LD_ADDR_VAR 0 3
2179: PUSH
2180: LD_INT 0
2182: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2183: LD_ADDR_OWVAR 20
2187: PUSH
2188: LD_INT 6
2190: ST_TO_ADDR
// uc_nation := 3 ;
2191: LD_ADDR_OWVAR 21
2195: PUSH
2196: LD_INT 3
2198: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2199: LD_INT 22
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 51
2207: PPUSH
2208: LD_INT 5
2210: PPUSH
2211: LD_INT 5
2213: PPUSH
2214: LD_INT 3
2216: PPUSH
2217: LD_INT 6
2219: PPUSH
2220: CALL_OW 12
2224: PPUSH
2225: CALL 1282 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2229: LD_ADDR_VAR 0 2
2233: PUSH
2234: LD_INT 22
2236: PUSH
2237: LD_INT 6
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: LD_INT 34
2246: PUSH
2247: LD_INT 51
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PPUSH
2258: CALL_OW 69
2262: PUSH
2263: LD_INT 1
2265: ARRAY
2266: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2267: LD_VAR 0 2
2271: PPUSH
2272: LD_INT 1
2274: PPUSH
2275: LD_INT 100
2277: PPUSH
2278: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: PLUS
2295: PPUSH
2296: LD_EXP 8
2300: PPUSH
2301: CALL_OW 111
// AddComUnload ( un ) ;
2305: LD_VAR 0 2
2309: PPUSH
2310: CALL_OW 219
// if ( l = 0 ) then
2314: LD_VAR 0 3
2318: PUSH
2319: LD_INT 0
2321: EQUAL
2322: IFFALSE 2358
// begin Wait ( 0 0$03 ) ;
2324: LD_INT 105
2326: PPUSH
2327: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2331: LD_ADDR_VAR 0 4
2335: PUSH
2336: LD_VAR 0 2
2340: PPUSH
2341: CALL_OW 311
2345: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2346: LD_VAR 0 4
2350: PPUSH
2351: LD_STRING Dtran
2353: PPUSH
2354: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2358: LD_VAR 0 3
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: LD_INT 6
2368: PUSH
2369: LD_INT 5
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: LD_EXP 1
2381: ARRAY
2382: PUSH
2383: LD_INT 1
2385: MINUS
2386: EQUAL
2387: IFFALSE 2423
// begin Wait ( 0 0$03 ) ;
2389: LD_INT 105
2391: PPUSH
2392: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2396: LD_ADDR_VAR 0 4
2400: PUSH
2401: LD_VAR 0 2
2405: PPUSH
2406: CALL_OW 311
2410: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2411: LD_VAR 0 4
2415: PPUSH
2416: LD_STRING Dtrans
2418: PPUSH
2419: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2423: LD_VAR 0 2
2427: PPUSH
2428: LD_INT 6
2430: PPUSH
2431: CALL_OW 308
2435: NOT
2436: IFFALSE 2462
// begin Wait ( 0 0$01 ) ;
2438: LD_INT 35
2440: PPUSH
2441: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2445: LD_VAR 0 2
2449: PPUSH
2450: LD_INT 69
2452: PPUSH
2453: LD_INT 97
2455: PPUSH
2456: CALL_OW 171
// end ;
2460: GO 2423
// RemoveUnit ( un ) ;
2462: LD_VAR 0 2
2466: PPUSH
2467: CALL_OW 64
// l = l + 1 ;
2471: LD_ADDR_VAR 0 3
2475: PUSH
2476: LD_VAR 0 3
2480: PUSH
2481: LD_INT 1
2483: PLUS
2484: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2485: LD_INT 1155
2487: PPUSH
2488: LD_INT 5355
2490: PPUSH
2491: CALL_OW 12
2495: PPUSH
2496: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2500: LD_VAR 0 3
2504: PUSH
2505: LD_INT 7
2507: PUSH
2508: LD_INT 6
2510: PUSH
2511: LD_INT 5
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: PUSH
2519: LD_EXP 1
2523: ARRAY
2524: EQUAL
2525: IFFALSE 2183
// end ; end_of_file
2527: PPOPN 4
2529: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2530: LD_VAR 0 1
2534: PUSH
2535: LD_INT 44
2537: EQUAL
2538: PUSH
2539: LD_EXP 20
2543: PUSH
2544: LD_INT 0
2546: EQUAL
2547: AND
2548: IFFALSE 2694
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2550: LD_INT 22
2552: PUSH
2553: LD_INT 3
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PUSH
2560: LD_INT 25
2562: PUSH
2563: LD_INT 4
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL_OW 69
2578: PUSH
2579: LD_INT 0
2581: GREATER
2582: IFFALSE 2694
// begin event_rocket := true ;
2584: LD_ADDR_EXP 20
2588: PUSH
2589: LD_INT 1
2591: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2592: LD_INT 22
2594: PUSH
2595: LD_INT 3
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PUSH
2602: LD_INT 25
2604: PUSH
2605: LD_INT 4
2607: PUSH
2608: EMPTY
2609: LIST
2610: LIST
2611: PUSH
2612: LD_INT 26
2614: PUSH
2615: LD_INT 1
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PUSH
2622: EMPTY
2623: LIST
2624: LIST
2625: LIST
2626: PUSH
2627: EMPTY
2628: LIST
2629: PPUSH
2630: CALL_OW 69
2634: PUSH
2635: LD_INT 0
2637: GREATER
2638: IFFALSE 2694
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2640: LD_INT 22
2642: PUSH
2643: LD_INT 3
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: PUSH
2650: LD_INT 25
2652: PUSH
2653: LD_INT 4
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: PUSH
2660: LD_INT 26
2662: PUSH
2663: LD_INT 1
2665: PUSH
2666: EMPTY
2667: LIST
2668: LIST
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: PUSH
2675: EMPTY
2676: LIST
2677: PPUSH
2678: CALL_OW 69
2682: PUSH
2683: LD_INT 1
2685: ARRAY
2686: PPUSH
2687: LD_STRING Dsci2
2689: PPUSH
2690: CALL_OW 88
// end ; end ;
2694: PPOPN 2
2696: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 255
2706: PUSH
2707: LD_INT 3
2709: EQUAL
2710: PUSH
2711: LD_VAR 0 1
2715: PPUSH
2716: CALL_OW 263
2720: PUSH
2721: LD_INT 3
2723: EQUAL
2724: AND
2725: IFFALSE 2735
// comp_tested := true ;
2727: LD_ADDR_EXP 22
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// end ;
2735: PPOPN 2
2737: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2738: LD_VAR 0 1
2742: PUSH
2743: LD_INT 22
2745: PUSH
2746: LD_INT 1
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: LD_INT 21
2755: PUSH
2756: LD_INT 3
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PPUSH
2767: CALL_OW 69
2771: IN
2772: IFFALSE 2850
// if attacked = false and sikorski_ar = false then
2774: LD_EXP 15
2778: PUSH
2779: LD_INT 0
2781: EQUAL
2782: PUSH
2783: LD_EXP 12
2787: PUSH
2788: LD_INT 0
2790: EQUAL
2791: AND
2792: IFFALSE 2850
// begin attacked := true ;
2794: LD_ADDR_EXP 15
2798: PUSH
2799: LD_INT 1
2801: ST_TO_ADDR
// if IsInUnit ( donald ) then
2802: LD_EXP 13
2806: PPUSH
2807: CALL_OW 310
2811: IFFALSE 2827
// SayRadio ( donald , DGammaF ) else
2813: LD_EXP 13
2817: PPUSH
2818: LD_STRING DGammaF
2820: PPUSH
2821: CALL_OW 94
2825: GO 2850
// if IsInUnit ( van ) then
2827: LD_EXP 14
2831: PPUSH
2832: CALL_OW 310
2836: IFFALSE 2850
// SayRadio ( van , DGammaM ) ;
2838: LD_EXP 14
2842: PPUSH
2843: LD_STRING DGammaM
2845: PPUSH
2846: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2850: LD_VAR 0 1
2854: PUSH
2855: LD_INT 33
2857: PUSH
2858: LD_INT 2
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: IN
2870: IFFALSE 2881
// ComUnlink ( un ) ;
2872: LD_VAR 0 1
2876: PPUSH
2877: CALL_OW 136
// end ;
2881: PPOPN 1
2883: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2884: LD_VAR 0 2
2888: PPUSH
2889: CALL_OW 258
2893: PUSH
2894: LD_INT 1
2896: EQUAL
2897: IFFALSE 2911
// Say ( sci , Dsci3 ) ;
2899: LD_VAR 0 2
2903: PPUSH
2904: LD_STRING Dsci3
2906: PPUSH
2907: CALL_OW 88
// end ;
2911: PPOPN 2
2913: END
// on BuildingComplete ( b ) do var i ;
2914: LD_INT 0
2916: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2917: LD_VAR 0 1
2921: PPUSH
2922: CALL_OW 266
2926: PUSH
2927: LD_INT 0
2929: EQUAL
2930: PUSH
2931: LD_VAR 0 1
2935: PPUSH
2936: CALL_OW 255
2940: PUSH
2941: LD_INT 3
2943: EQUAL
2944: AND
2945: PUSH
2946: LD_EXP 6
2950: PUSH
2951: LD_INT 0
2953: EQUAL
2954: AND
2955: IFFALSE 3019
// begin SetBName ( b , kalinin ) ;
2957: LD_VAR 0 1
2961: PPUSH
2962: LD_STRING kalinin
2964: PPUSH
2965: CALL_OW 500
// dep_x := GetX ( b ) ;
2969: LD_ADDR_EXP 7
2973: PUSH
2974: LD_VAR 0 1
2978: PPUSH
2979: CALL_OW 250
2983: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2984: LD_ADDR_EXP 8
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 251
2998: ST_TO_ADDR
// depot_rdy := true ;
2999: LD_ADDR_EXP 6
3003: PUSH
3004: LD_INT 1
3006: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3007: LD_EXP 2
3011: PPUSH
3012: LD_STRING Dpop3
3014: PPUSH
3015: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3019: LD_VAR 0 1
3023: PPUSH
3024: CALL_OW 266
3028: PUSH
3029: LD_INT 6
3031: EQUAL
3032: PUSH
3033: LD_VAR 0 1
3037: PPUSH
3038: CALL_OW 255
3042: PUSH
3043: LD_INT 3
3045: EQUAL
3046: AND
3047: PUSH
3048: LD_EXP 21
3052: PUSH
3053: LD_INT 0
3055: EQUAL
3056: AND
3057: IFFALSE 3152
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3059: LD_INT 22
3061: PUSH
3062: LD_INT 3
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 25
3071: PUSH
3072: LD_INT 4
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PPUSH
3083: CALL_OW 69
3087: PUSH
3088: LD_INT 0
3090: GREATER
3091: IFFALSE 3152
// begin event_comp := true ;
3093: LD_ADDR_EXP 21
3097: PUSH
3098: LD_INT 1
3100: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3101: LD_INT 22
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: PUSH
3111: LD_INT 25
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 26
3123: PUSH
3124: LD_INT 1
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: LIST
3135: PPUSH
3136: CALL_OW 69
3140: PUSH
3141: LD_INT 1
3143: ARRAY
3144: PPUSH
3145: LD_STRING Dsci1
3147: PPUSH
3148: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3152: LD_VAR 0 1
3156: PPUSH
3157: CALL_OW 266
3161: PUSH
3162: LD_INT 32
3164: EQUAL
3165: PUSH
3166: LD_VAR 0 1
3170: PPUSH
3171: CALL_OW 255
3175: PUSH
3176: LD_INT 1
3178: EQUAL
3179: AND
3180: IFFALSE 3245
// begin RaiseSailEvent ( 6 ) ;
3182: LD_INT 6
3184: PPUSH
3185: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3189: LD_VAR 0 1
3193: PPUSH
3194: LD_EXP 18
3198: PUSH
3199: LD_INT 4
3201: ARRAY
3202: PPUSH
3203: CALL_OW 208
// for i = 1 to 4 do
3207: LD_ADDR_VAR 0 2
3211: PUSH
3212: DOUBLE
3213: LD_INT 1
3215: DEC
3216: ST_TO_ADDR
3217: LD_INT 4
3219: PUSH
3220: FOR_TO
3221: IFFALSE 3243
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3223: LD_ADDR_EXP 18
3227: PUSH
3228: LD_EXP 18
3232: PPUSH
3233: LD_INT 1
3235: PPUSH
3236: CALL_OW 3
3240: ST_TO_ADDR
3241: GO 3220
3243: POP
3244: POP
// end ; end ;
3245: PPOPN 2
3247: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3248: LD_VAR 0 1
3252: PUSH
3253: LD_EXP 17
3257: IN
3258: IFFALSE 3276
// Patrol := Patrol diff un ;
3260: LD_ADDR_EXP 17
3264: PUSH
3265: LD_EXP 17
3269: PUSH
3270: LD_VAR 0 1
3274: DIFF
3275: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3276: LD_VAR 0 1
3280: PUSH
3281: LD_INT 22
3283: PUSH
3284: LD_INT 1
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PUSH
3291: LD_INT 30
3293: PUSH
3294: LD_INT 32
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: PPUSH
3305: CALL_OW 69
3309: IN
3310: IFFALSE 3396
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3312: LD_ADDR_EXP 18
3316: PUSH
3317: LD_EXP 18
3321: PUSH
3322: LD_VAR 0 1
3326: PPUSH
3327: CALL_OW 250
3331: ADD
3332: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3333: LD_ADDR_EXP 18
3337: PUSH
3338: LD_EXP 18
3342: PUSH
3343: LD_VAR 0 1
3347: PPUSH
3348: CALL_OW 251
3352: ADD
3353: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3354: LD_ADDR_EXP 18
3358: PUSH
3359: LD_EXP 18
3363: PUSH
3364: LD_VAR 0 1
3368: PPUSH
3369: CALL_OW 254
3373: ADD
3374: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3375: LD_ADDR_EXP 18
3379: PUSH
3380: LD_EXP 18
3384: PUSH
3385: LD_VAR 0 1
3389: PPUSH
3390: CALL_OW 269
3394: ADD
3395: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3396: LD_VAR 0 1
3400: PUSH
3401: LD_INT 33
3403: PUSH
3404: LD_INT 2
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PUSH
3411: LD_INT 3
3413: PUSH
3414: LD_INT 34
3416: PUSH
3417: LD_INT 13
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PPUSH
3432: CALL_OW 69
3436: IN
3437: IFFALSE 3453
// new_veh := new_veh + 1 ;
3439: LD_ADDR_EXP 19
3443: PUSH
3444: LD_EXP 19
3448: PUSH
3449: LD_INT 1
3451: PLUS
3452: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3453: LD_VAR 0 1
3457: PUSH
3458: LD_INT 34
3460: PUSH
3461: LD_INT 13
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PPUSH
3468: CALL_OW 69
3472: IN
3473: IFFALSE 3494
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3475: LD_INT 26
3477: PPUSH
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 2
3483: PPUSH
3484: LD_INT 2
3486: PPUSH
3487: LD_INT 13
3489: PPUSH
3490: CALL_OW 185
// if un = am_dep then
3494: LD_VAR 0 1
3498: PUSH
3499: LD_INT 25
3501: EQUAL
3502: IFFALSE 3670
// begin SayRadio ( Platonov , DPlat ) ;
3504: LD_EXP 4
3508: PPUSH
3509: LD_STRING DPlat
3511: PPUSH
3512: CALL_OW 94
// if timer <= 30 30$00 then
3516: LD_EXP 24
3520: PUSH
3521: LD_INT 63000
3523: LESSEQUAL
3524: IFFALSE 3538
// AddMedal ( gamma_med3 , 1 ) else
3526: LD_STRING gamma_med3
3528: PPUSH
3529: LD_INT 1
3531: PPUSH
3532: CALL_OW 101
3536: GO 3588
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3538: LD_EXP 24
3542: PUSH
3543: LD_INT 105000
3545: PUSH
3546: LD_INT 88200
3548: PUSH
3549: LD_INT 73500
3551: PUSH
3552: EMPTY
3553: LIST
3554: LIST
3555: LIST
3556: PUSH
3557: LD_EXP 1
3561: ARRAY
3562: LESSEQUAL
3563: IFFALSE 3577
// AddMedal ( gamma_med3 , 2 ) else
3565: LD_STRING gamma_med3
3567: PPUSH
3568: LD_INT 2
3570: PPUSH
3571: CALL_OW 101
3575: GO 3588
// AddMedal ( gamma_med3 , - 1 ) ;
3577: LD_STRING gamma_med3
3579: PPUSH
3580: LD_INT 1
3582: NEG
3583: PPUSH
3584: CALL_OW 101
// if not comp_tested then
3588: LD_EXP 22
3592: NOT
3593: IFFALSE 3608
// AddMedal ( gamma_med2 , - 1 ) else
3595: LD_STRING gamma_med2
3597: PPUSH
3598: LD_INT 1
3600: NEG
3601: PPUSH
3602: CALL_OW 101
3606: GO 3618
// AddMedal ( gamma_med2 , 1 ) ;
3608: LD_STRING gamma_med2
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3618: LD_EXP 9
3622: PPUSH
3623: CALL_OW 301
3627: PUSH
3628: LD_EXP 23
3632: NOT
3633: AND
3634: IFFALSE 3648
// AddMedal ( gamma_med1 , 1 ) else
3636: LD_STRING gamma_med1
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: CALL_OW 101
3646: GO 3659
// AddMedal ( gamma_med1 , - 1 ) ;
3648: LD_STRING gamma_med1
3650: PPUSH
3651: LD_INT 1
3653: NEG
3654: PPUSH
3655: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3659: LD_STRING GAMMA_MEDALS
3661: PPUSH
3662: CALL_OW 102
// YouWin ;
3666: CALL_OW 103
// end ; if un = commander then
3670: LD_VAR 0 1
3674: PUSH
3675: LD_EXP 3
3679: EQUAL
3680: IFFALSE 3689
// YouLost ( comml ) ;
3682: LD_STRING comml
3684: PPUSH
3685: CALL_OW 104
// if un = sikorski then
3689: LD_VAR 0 1
3693: PUSH
3694: LD_EXP 9
3698: EQUAL
3699: IFFALSE 3711
// AddMedal ( gamma_med1 , 1 ) ;
3701: LD_STRING gamma_med1
3703: PPUSH
3704: LD_INT 1
3706: PPUSH
3707: CALL_OW 101
// end ;
3711: PPOPN 1
3713: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3714: LD_INT 0
3716: PPUSH
3717: PPUSH
3718: PPUSH
3719: PPUSH
3720: PPUSH
3721: PPUSH
3722: PPUSH
3723: PPUSH
3724: PPUSH
// begin if event = 1 then
3725: LD_VAR 0 1
3729: PUSH
3730: LD_INT 1
3732: EQUAL
3733: IFFALSE 4030
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: LD_INT 22
3742: PUSH
3743: LD_INT 1
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 21
3752: PUSH
3753: LD_INT 3
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_INT 3
3762: PUSH
3763: LD_INT 24
3765: PUSH
3766: LD_INT 1000
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: LIST
3781: PPUSH
3782: CALL_OW 69
3786: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3787: LD_ADDR_VAR 0 8
3791: PUSH
3792: LD_INT 22
3794: PUSH
3795: LD_INT 1
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PUSH
3802: LD_INT 25
3804: PUSH
3805: LD_INT 2
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: PUSH
3812: LD_INT 24
3814: PUSH
3815: LD_INT 1000
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: LIST
3826: PUSH
3827: EMPTY
3828: LIST
3829: PPUSH
3830: CALL_OW 69
3834: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3835: LD_ADDR_VAR 0 9
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 1
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 34
3852: PUSH
3853: LD_INT 13
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: ST_TO_ADDR
// if engs > 0 then
3869: LD_VAR 0 8
3873: PUSH
3874: LD_INT 0
3876: GREATER
3877: IFFALSE 3982
// for i = 1 to engs do
3879: LD_ADDR_VAR 0 2
3883: PUSH
3884: DOUBLE
3885: LD_INT 1
3887: DEC
3888: ST_TO_ADDR
3889: LD_VAR 0 8
3893: PUSH
3894: FOR_TO
3895: IFFALSE 3980
// begin if IsInUnit ( engs [ i ] ) then
3897: LD_VAR 0 8
3901: PUSH
3902: LD_VAR 0 2
3906: ARRAY
3907: PPUSH
3908: CALL_OW 310
3912: IFFALSE 3929
// ComExitBuilding ( engs [ i ] ) ;
3914: LD_VAR 0 8
3918: PUSH
3919: LD_VAR 0 2
3923: ARRAY
3924: PPUSH
3925: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3929: LD_INT 7
3931: PPUSH
3932: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3936: LD_VAR 0 8
3940: PUSH
3941: LD_VAR 0 2
3945: ARRAY
3946: PPUSH
3947: CALL_OW 314
3951: NOT
3952: IFFALSE 3978
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3954: LD_VAR 0 8
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PPUSH
3965: LD_VAR 0 4
3969: PUSH
3970: LD_INT 1
3972: ARRAY
3973: PPUSH
3974: CALL_OW 130
// end ;
3978: GO 3894
3980: POP
3981: POP
// if crane > 0 then
3982: LD_VAR 0 9
3986: PUSH
3987: LD_INT 0
3989: GREATER
3990: IFFALSE 4030
// if not HasTask ( crane [ 1 ] ) then
3992: LD_VAR 0 9
3996: PUSH
3997: LD_INT 1
3999: ARRAY
4000: PPUSH
4001: CALL_OW 314
4005: NOT
4006: IFFALSE 4030
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4008: LD_VAR 0 9
4012: PUSH
4013: LD_INT 1
4015: ARRAY
4016: PPUSH
4017: LD_VAR 0 4
4021: PUSH
4022: LD_INT 1
4024: ARRAY
4025: PPUSH
4026: CALL_OW 130
// end ; if event = 2 then
4030: LD_VAR 0 1
4034: PUSH
4035: LD_INT 2
4037: EQUAL
4038: IFFALSE 4160
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4040: LD_ADDR_VAR 0 8
4044: PUSH
4045: LD_INT 22
4047: PUSH
4048: LD_INT 1
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: PUSH
4055: LD_INT 25
4057: PUSH
4058: LD_INT 2
4060: PUSH
4061: EMPTY
4062: LIST
4063: LIST
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: PPUSH
4069: CALL_OW 69
4073: ST_TO_ADDR
// if engs > 0 then
4074: LD_VAR 0 8
4078: PUSH
4079: LD_INT 0
4081: GREATER
4082: IFFALSE 4160
// for i = 1 to engs do
4084: LD_ADDR_VAR 0 2
4088: PUSH
4089: DOUBLE
4090: LD_INT 1
4092: DEC
4093: ST_TO_ADDR
4094: LD_VAR 0 8
4098: PUSH
4099: FOR_TO
4100: IFFALSE 4158
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4102: LD_VAR 0 8
4106: PUSH
4107: LD_VAR 0 2
4111: ARRAY
4112: PPUSH
4113: CALL_OW 314
4117: NOT
4118: PUSH
4119: LD_VAR 0 8
4123: PUSH
4124: LD_VAR 0 2
4128: ARRAY
4129: PPUSH
4130: CALL_OW 310
4134: NOT
4135: AND
4136: IFFALSE 4156
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4138: LD_VAR 0 8
4142: PUSH
4143: LD_VAR 0 2
4147: ARRAY
4148: PPUSH
4149: LD_INT 25
4151: PPUSH
4152: CALL_OW 120
4156: GO 4099
4158: POP
4159: POP
// end ; if event = 3 then
4160: LD_VAR 0 1
4164: PUSH
4165: LD_INT 3
4167: EQUAL
4168: IFFALSE 4532
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4170: LD_ADDR_VAR 0 4
4174: PUSH
4175: LD_INT 22
4177: PUSH
4178: LD_INT 1
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: LD_INT 21
4187: PUSH
4188: LD_INT 1
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: LD_INT 25
4200: PUSH
4201: LD_INT 4
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: LD_INT 3
4214: PUSH
4215: LD_INT 24
4217: PUSH
4218: LD_INT 800
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: PPUSH
4238: CALL_OW 69
4242: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4243: LD_ADDR_VAR 0 5
4247: PUSH
4248: LD_INT 22
4250: PUSH
4251: LD_INT 1
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: PUSH
4258: LD_INT 25
4260: PUSH
4261: LD_INT 4
4263: PUSH
4264: EMPTY
4265: LIST
4266: LIST
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PPUSH
4272: CALL_OW 69
4276: ST_TO_ADDR
// if filter > 0 then
4277: LD_VAR 0 4
4281: PUSH
4282: LD_INT 0
4284: GREATER
4285: IFFALSE 4474
// begin for i = 1 to doc do
4287: LD_ADDR_VAR 0 2
4291: PUSH
4292: DOUBLE
4293: LD_INT 1
4295: DEC
4296: ST_TO_ADDR
4297: LD_VAR 0 5
4301: PUSH
4302: FOR_TO
4303: IFFALSE 4403
// begin if IsInUnit ( doc [ i ] ) then
4305: LD_VAR 0 5
4309: PUSH
4310: LD_VAR 0 2
4314: ARRAY
4315: PPUSH
4316: CALL_OW 310
4320: IFFALSE 4337
// ComExitBuilding ( doc [ i ] ) ;
4322: LD_VAR 0 5
4326: PUSH
4327: LD_VAR 0 2
4331: ARRAY
4332: PPUSH
4333: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4337: LD_VAR 0 4
4341: PUSH
4342: LD_INT 1
4344: ARRAY
4345: PPUSH
4346: LD_INT 46
4348: PPUSH
4349: CALL_OW 296
4353: PUSH
4354: LD_INT 10
4356: LESS
4357: PUSH
4358: LD_VAR 0 5
4362: PUSH
4363: LD_VAR 0 2
4367: ARRAY
4368: PPUSH
4369: CALL_OW 314
4373: NOT
4374: AND
4375: IFFALSE 4401
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4377: LD_VAR 0 5
4381: PUSH
4382: LD_VAR 0 2
4386: ARRAY
4387: PPUSH
4388: LD_VAR 0 4
4392: PUSH
4393: LD_INT 1
4395: ARRAY
4396: PPUSH
4397: CALL_OW 128
// end ;
4401: GO 4302
4403: POP
4404: POP
// for i = 1 to filter do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: DOUBLE
4411: LD_INT 1
4413: DEC
4414: ST_TO_ADDR
4415: LD_VAR 0 4
4419: PUSH
4420: FOR_TO
4421: IFFALSE 4470
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4423: LD_VAR 0 4
4427: PUSH
4428: LD_VAR 0 2
4432: ARRAY
4433: PPUSH
4434: LD_INT 46
4436: PPUSH
4437: CALL_OW 296
4441: PUSH
4442: LD_INT 10
4444: GREATER
4445: IFFALSE 4468
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4447: LD_VAR 0 4
4451: PUSH
4452: LD_VAR 0 2
4456: ARRAY
4457: PPUSH
4458: LD_INT 47
4460: PPUSH
4461: LD_INT 12
4463: PPUSH
4464: CALL_OW 111
4468: GO 4420
4470: POP
4471: POP
// end else
4472: GO 4532
// for i = 1 to doc do
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_VAR 0 5
4488: PUSH
4489: FOR_TO
4490: IFFALSE 4530
// if not IsInUnit ( doc [ i ] ) then
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: ARRAY
4502: PPUSH
4503: CALL_OW 310
4507: NOT
4508: IFFALSE 4528
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4510: LD_VAR 0 5
4514: PUSH
4515: LD_VAR 0 2
4519: ARRAY
4520: PPUSH
4521: LD_INT 46
4523: PPUSH
4524: CALL_OW 120
4528: GO 4489
4530: POP
4531: POP
// end ; if event = 4 then
4532: LD_VAR 0 1
4536: PUSH
4537: LD_INT 4
4539: EQUAL
4540: IFFALSE 4791
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4542: LD_ADDR_VAR 0 6
4546: PUSH
4547: LD_INT 22
4549: PUSH
4550: LD_INT 1
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 30
4559: PUSH
4560: LD_INT 5
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PPUSH
4571: CALL_OW 69
4575: ST_TO_ADDR
// for i = 1 to bac do
4576: LD_ADDR_VAR 0 2
4580: PUSH
4581: DOUBLE
4582: LD_INT 1
4584: DEC
4585: ST_TO_ADDR
4586: LD_VAR 0 6
4590: PUSH
4591: FOR_TO
4592: IFFALSE 4633
// if UnitsInside ( bac [ i ] ) < 6 then
4594: LD_VAR 0 6
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: CALL_OW 313
4609: PUSH
4610: LD_INT 6
4612: LESS
4613: IFFALSE 4631
// place := bac [ i ] ;
4615: LD_ADDR_VAR 0 7
4619: PUSH
4620: LD_VAR 0 6
4624: PUSH
4625: LD_VAR 0 2
4629: ARRAY
4630: ST_TO_ADDR
4631: GO 4591
4633: POP
4634: POP
// if place then
4635: LD_VAR 0 7
4639: IFFALSE 4791
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4641: LD_ADDR_VAR 0 4
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_INT 1
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: LD_INT 25
4661: PUSH
4662: LD_INT 1
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 25
4671: PUSH
4672: LD_INT 5
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 24
4686: PUSH
4687: LD_INT 1000
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: EMPTY
4700: LIST
4701: PPUSH
4702: CALL_OW 69
4706: PUSH
4707: LD_EXP 17
4711: DIFF
4712: ST_TO_ADDR
// for i = 1 to filter do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_VAR 0 4
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4789
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4731: LD_VAR 0 4
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PPUSH
4742: CALL_OW 310
4746: NOT
4747: PUSH
4748: LD_VAR 0 4
4752: PUSH
4753: LD_VAR 0 2
4757: ARRAY
4758: PPUSH
4759: CALL_OW 314
4763: NOT
4764: AND
4765: IFFALSE 4787
// ComEnterUnit ( filter [ i ] , place ) ;
4767: LD_VAR 0 4
4771: PUSH
4772: LD_VAR 0 2
4776: ARRAY
4777: PPUSH
4778: LD_VAR 0 7
4782: PPUSH
4783: CALL_OW 120
4787: GO 4728
4789: POP
4790: POP
// end ; end ; if event = 5 then
4791: LD_VAR 0 1
4795: PUSH
4796: LD_INT 5
4798: EQUAL
4799: IFFALSE 4953
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4801: LD_INT 12
4803: PPUSH
4804: LD_INT 81
4806: PUSH
4807: LD_INT 1
4809: PUSH
4810: EMPTY
4811: LIST
4812: LIST
4813: PPUSH
4814: CALL_OW 70
4818: PUSH
4819: LD_INT 0
4821: EQUAL
4822: IFFALSE 4953
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4824: LD_ADDR_VAR 0 8
4828: PUSH
4829: LD_INT 22
4831: PUSH
4832: LD_INT 1
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: LD_INT 25
4841: PUSH
4842: LD_INT 2
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PPUSH
4853: CALL_OW 69
4857: ST_TO_ADDR
// if engs > 0 then
4858: LD_VAR 0 8
4862: PUSH
4863: LD_INT 0
4865: GREATER
4866: IFFALSE 4953
// for i = 1 to engs do
4868: LD_ADDR_VAR 0 2
4872: PUSH
4873: DOUBLE
4874: LD_INT 1
4876: DEC
4877: ST_TO_ADDR
4878: LD_VAR 0 8
4882: PUSH
4883: FOR_TO
4884: IFFALSE 4951
// if not HasTask ( engs [ i ] ) then
4886: LD_VAR 0 8
4890: PUSH
4891: LD_VAR 0 2
4895: ARRAY
4896: PPUSH
4897: CALL_OW 314
4901: NOT
4902: IFFALSE 4949
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4904: LD_VAR 0 8
4908: PUSH
4909: LD_VAR 0 2
4913: ARRAY
4914: PPUSH
4915: LD_INT 32
4917: PPUSH
4918: LD_EXP 18
4922: PUSH
4923: LD_INT 1
4925: ARRAY
4926: PPUSH
4927: LD_EXP 18
4931: PUSH
4932: LD_INT 2
4934: ARRAY
4935: PPUSH
4936: LD_EXP 18
4940: PUSH
4941: LD_INT 3
4943: ARRAY
4944: PPUSH
4945: CALL_OW 145
4949: GO 4883
4951: POP
4952: POP
// end ; end ; if event = 6 then
4953: LD_VAR 0 1
4957: PUSH
4958: LD_INT 6
4960: EQUAL
4961: IFFALSE 5145
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4963: LD_ADDR_VAR 0 6
4967: PUSH
4968: LD_INT 22
4970: PUSH
4971: LD_INT 1
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 30
4980: PUSH
4981: LD_INT 5
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: PPUSH
4992: CALL_OW 69
4996: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
4997: LD_VAR 0 6
5001: PUSH
5002: LD_INT 22
5004: PUSH
5005: LD_INT 1
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: PUSH
5012: LD_INT 30
5014: PUSH
5015: LD_INT 32
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PUSH
5022: LD_INT 58
5024: PUSH
5025: EMPTY
5026: LIST
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: PUSH
5033: EMPTY
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 0
5043: GREATER
5044: AND
5045: IFFALSE 5145
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5047: LD_ADDR_VAR 0 10
5051: PUSH
5052: LD_INT 22
5054: PUSH
5055: LD_INT 1
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PUSH
5062: LD_INT 30
5064: PUSH
5065: LD_INT 32
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: PUSH
5072: LD_INT 58
5074: PUSH
5075: EMPTY
5076: LIST
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: PUSH
5083: EMPTY
5084: LIST
5085: PPUSH
5086: CALL_OW 69
5090: PUSH
5091: LD_INT 1
5093: ARRAY
5094: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5095: LD_ADDR_VAR 0 3
5099: PUSH
5100: LD_VAR 0 6
5104: PUSH
5105: LD_INT 1
5107: ARRAY
5108: PPUSH
5109: CALL_OW 313
5113: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5114: LD_VAR 0 3
5118: PUSH
5119: LD_INT 1
5121: ARRAY
5122: PPUSH
5123: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5127: LD_VAR 0 3
5131: PUSH
5132: LD_INT 1
5134: ARRAY
5135: PPUSH
5136: LD_VAR 0 10
5140: PPUSH
5141: CALL_OW 180
// end ; end ; end ;
5145: PPOPN 10
5147: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5148: LD_VAR 0 1
5152: PUSH
5153: LD_INT 1
5155: EQUAL
5156: PUSH
5157: LD_VAR 0 2
5161: PUSH
5162: LD_INT 3
5164: EQUAL
5165: AND
5166: IFFALSE 5176
// contact_am := true ;
5168: LD_ADDR_EXP 16
5172: PUSH
5173: LD_INT 1
5175: ST_TO_ADDR
// end ; end_of_file
5176: PPOPN 2
5178: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5179: LD_INT 0
5181: PPUSH
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
5186: PPUSH
5187: PPUSH
5188: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5189: LD_ADDR_VAR 0 5
5193: PUSH
5194: LD_INT 5
5196: PUSH
5197: LD_INT 6
5199: PUSH
5200: LD_INT 7
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_EXP 1
5212: ARRAY
5213: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5214: LD_ADDR_VAR 0 6
5218: PUSH
5219: LD_INT 4
5221: PUSH
5222: LD_INT 4
5224: PUSH
5225: LD_INT 4
5227: PUSH
5228: LD_INT 5
5230: PUSH
5231: LD_INT 5
5233: PUSH
5234: LD_INT 5
5236: PUSH
5237: LD_INT 6
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
// SForce := [ ] ;
5249: LD_ADDR_EXP 11
5253: PUSH
5254: EMPTY
5255: ST_TO_ADDR
// Sikorski_Ar := false ;
5256: LD_ADDR_EXP 12
5260: PUSH
5261: LD_INT 0
5263: ST_TO_ADDR
// attacked := false ;
5264: LD_ADDR_EXP 15
5268: PUSH
5269: LD_INT 0
5271: ST_TO_ADDR
// contact_am := false ;
5272: LD_ADDR_EXP 16
5276: PUSH
5277: LD_INT 0
5279: ST_TO_ADDR
// patrol := [ ] ;
5280: LD_ADDR_EXP 17
5284: PUSH
5285: EMPTY
5286: ST_TO_ADDR
// gamma_towers := [ ] ;
5287: LD_ADDR_EXP 18
5291: PUSH
5292: EMPTY
5293: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5294: LD_INT 25
5296: PPUSH
5297: LD_STRING gamma
5299: PPUSH
5300: CALL_OW 500
// uc_side := 1 ;
5304: LD_ADDR_OWVAR 20
5308: PUSH
5309: LD_INT 1
5311: ST_TO_ADDR
// uc_nation := 1 ;
5312: LD_ADDR_OWVAR 21
5316: PUSH
5317: LD_INT 1
5319: ST_TO_ADDR
// hc_importance := 0 ;
5320: LD_ADDR_OWVAR 32
5324: PUSH
5325: LD_INT 0
5327: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5328: LD_ADDR_OWVAR 26
5332: PUSH
5333: LD_STRING Jeremy Sikorski
5335: ST_TO_ADDR
// hc_gallery := us ;
5336: LD_ADDR_OWVAR 33
5340: PUSH
5341: LD_STRING us
5343: ST_TO_ADDR
// hc_face_number := 19 ;
5344: LD_ADDR_OWVAR 34
5348: PUSH
5349: LD_INT 19
5351: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5352: LD_ADDR_OWVAR 31
5356: PUSH
5357: LD_VAR 0 5
5361: PPUSH
5362: LD_VAR 0 5
5366: PUSH
5367: LD_INT 2
5369: PLUS
5370: PPUSH
5371: CALL_OW 12
5375: PUSH
5376: LD_INT 4
5378: PUSH
5379: LD_INT 6
5381: PUSH
5382: LD_INT 3
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: LIST
5389: LIST
5390: ST_TO_ADDR
// hc_sex := sex_male ;
5391: LD_ADDR_OWVAR 27
5395: PUSH
5396: LD_INT 1
5398: ST_TO_ADDR
// hc_class := 1 ;
5399: LD_ADDR_OWVAR 28
5403: PUSH
5404: LD_INT 1
5406: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5407: LD_ADDR_OWVAR 29
5411: PUSH
5412: LD_INT 10
5414: PUSH
5415: LD_INT 11
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: ST_TO_ADDR
// sikorski := CreateHuman ;
5422: LD_ADDR_EXP 9
5426: PUSH
5427: CALL_OW 44
5431: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5432: LD_ADDR_OWVAR 26
5436: PUSH
5437: LD_STRING Lucy Donaldson
5439: ST_TO_ADDR
// hc_gallery := us ;
5440: LD_ADDR_OWVAR 33
5444: PUSH
5445: LD_STRING us
5447: ST_TO_ADDR
// hc_face_number := 2 ;
5448: LD_ADDR_OWVAR 34
5452: PUSH
5453: LD_INT 2
5455: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5456: LD_ADDR_OWVAR 31
5460: PUSH
5461: LD_VAR 0 5
5465: PPUSH
5466: LD_VAR 0 5
5470: PUSH
5471: LD_INT 2
5473: PLUS
5474: PPUSH
5475: CALL_OW 12
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 4
5485: PUSH
5486: LD_INT 2
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: LIST
5494: ST_TO_ADDR
// hc_sex := sex_female ;
5495: LD_ADDR_OWVAR 27
5499: PUSH
5500: LD_INT 2
5502: ST_TO_ADDR
// hc_class := 1 ;
5503: LD_ADDR_OWVAR 28
5507: PUSH
5508: LD_INT 1
5510: ST_TO_ADDR
// donald := CreateHuman ;
5511: LD_ADDR_EXP 13
5515: PUSH
5516: CALL_OW 44
5520: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5521: LD_ADDR_OWVAR 26
5525: PUSH
5526: LD_STRING Peter Van Houten
5528: ST_TO_ADDR
// hc_gallery := us ;
5529: LD_ADDR_OWVAR 33
5533: PUSH
5534: LD_STRING us
5536: ST_TO_ADDR
// hc_face_number := 16 ;
5537: LD_ADDR_OWVAR 34
5541: PUSH
5542: LD_INT 16
5544: ST_TO_ADDR
// hc_sex := sex_male ;
5545: LD_ADDR_OWVAR 27
5549: PUSH
5550: LD_INT 1
5552: ST_TO_ADDR
// van := CreateHuman ;
5553: LD_ADDR_EXP 14
5557: PUSH
5558: CALL_OW 44
5562: ST_TO_ADDR
// hc_importance := 0 ;
5563: LD_ADDR_OWVAR 32
5567: PUSH
5568: LD_INT 0
5570: ST_TO_ADDR
// case dif of 1 :
5571: LD_EXP 1
5575: PUSH
5576: LD_INT 1
5578: DOUBLE
5579: EQUAL
5580: IFTRUE 5584
5582: GO 5595
5584: POP
// lw = 1 ; 2 :
5585: LD_ADDR_VAR 0 8
5589: PUSH
5590: LD_INT 1
5592: ST_TO_ADDR
5593: GO 5642
5595: LD_INT 2
5597: DOUBLE
5598: EQUAL
5599: IFTRUE 5603
5601: GO 5622
5603: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5604: LD_ADDR_VAR 0 8
5608: PUSH
5609: LD_INT 1
5611: PPUSH
5612: LD_INT 2
5614: PPUSH
5615: CALL_OW 12
5619: ST_TO_ADDR
5620: GO 5642
5622: LD_INT 3
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5630
5628: GO 5641
5630: POP
// lw = 2 ; end ;
5631: LD_ADDR_VAR 0 8
5635: PUSH
5636: LD_INT 2
5638: ST_TO_ADDR
5639: GO 5642
5641: POP
// case lw of 1 :
5642: LD_VAR 0 8
5646: PUSH
5647: LD_INT 1
5649: DOUBLE
5650: EQUAL
5651: IFTRUE 5655
5653: GO 5670
5655: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5656: LD_EXP 13
5660: PPUSH
5661: LD_INT 25
5663: PPUSH
5664: CALL_OW 52
5668: GO 5694
5670: LD_INT 2
5672: DOUBLE
5673: EQUAL
5674: IFTRUE 5678
5676: GO 5693
5678: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5679: LD_EXP 14
5683: PPUSH
5684: LD_INT 25
5686: PPUSH
5687: CALL_OW 52
5691: GO 5694
5693: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5694: LD_ADDR_VAR 0 2
5698: PUSH
5699: LD_INT 22
5701: PUSH
5702: LD_INT 1
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: LD_INT 30
5711: PUSH
5712: LD_INT 32
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PPUSH
5723: CALL_OW 69
5727: PUSH
5728: FOR_IN
5729: IFFALSE 5783
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5731: LD_INT 1
5733: PPUSH
5734: LD_VAR 0 5
5738: PPUSH
5739: CALL 719 0 2
5743: PPUSH
5744: LD_VAR 0 2
5748: PPUSH
5749: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5753: LD_VAR 0 2
5757: PPUSH
5758: LD_VAR 0 6
5762: PUSH
5763: LD_INT 1
5765: PPUSH
5766: LD_VAR 0 6
5770: PPUSH
5771: CALL_OW 12
5775: ARRAY
5776: PPUSH
5777: CALL_OW 431
// end ;
5781: GO 5728
5783: POP
5784: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5785: LD_ADDR_VAR 0 7
5789: PUSH
5790: LD_INT 22
5792: PUSH
5793: LD_INT 1
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: LD_INT 2
5802: PUSH
5803: LD_INT 25
5805: PUSH
5806: LD_INT 1
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: PUSH
5813: LD_INT 5
5815: PUSH
5816: EMPTY
5817: LIST
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PPUSH
5828: CALL_OW 69
5832: ST_TO_ADDR
// for i = 1 to sol do
5833: LD_ADDR_VAR 0 2
5837: PUSH
5838: DOUBLE
5839: LD_INT 1
5841: DEC
5842: ST_TO_ADDR
5843: LD_VAR 0 7
5847: PUSH
5848: FOR_TO
5849: IFFALSE 5871
// SetTag ( sol [ i ] , 1 ) ;
5851: LD_VAR 0 7
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PPUSH
5862: LD_INT 1
5864: PPUSH
5865: CALL_OW 109
5869: GO 5848
5871: POP
5872: POP
// for i = 1 to 3 do
5873: LD_ADDR_VAR 0 2
5877: PUSH
5878: DOUBLE
5879: LD_INT 1
5881: DEC
5882: ST_TO_ADDR
5883: LD_INT 3
5885: PUSH
5886: FOR_TO
5887: IFFALSE 5911
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5889: LD_INT 3
5891: PPUSH
5892: LD_VAR 0 5
5896: PPUSH
5897: CALL 719 0 2
5901: PPUSH
5902: LD_INT 56
5904: PPUSH
5905: CALL_OW 52
5909: GO 5886
5911: POP
5912: POP
// for i = 1 to 6 do
5913: LD_ADDR_VAR 0 2
5917: PUSH
5918: DOUBLE
5919: LD_INT 1
5921: DEC
5922: ST_TO_ADDR
5923: LD_INT 6
5925: PUSH
5926: FOR_TO
5927: IFFALSE 5951
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5929: LD_INT 3
5931: PPUSH
5932: LD_VAR 0 5
5936: PPUSH
5937: CALL 719 0 2
5941: PPUSH
5942: LD_INT 26
5944: PPUSH
5945: CALL_OW 52
5949: GO 5926
5951: POP
5952: POP
// for i = 1 to 5 do
5953: LD_ADDR_VAR 0 2
5957: PUSH
5958: DOUBLE
5959: LD_INT 1
5961: DEC
5962: ST_TO_ADDR
5963: LD_INT 5
5965: PUSH
5966: FOR_TO
5967: IFFALSE 5994
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
5969: LD_INT 2
5971: PPUSH
5972: LD_VAR 0 5
5976: PPUSH
5977: CALL 719 0 2
5981: PPUSH
5982: LD_INT 7
5984: PPUSH
5985: LD_INT 0
5987: PPUSH
5988: CALL_OW 49
5992: GO 5966
5994: POP
5995: POP
// for i = 1 to 3 do
5996: LD_ADDR_VAR 0 2
6000: PUSH
6001: DOUBLE
6002: LD_INT 1
6004: DEC
6005: ST_TO_ADDR
6006: LD_INT 3
6008: PUSH
6009: FOR_TO
6010: IFFALSE 6034
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6012: LD_INT 4
6014: PPUSH
6015: LD_VAR 0 5
6019: PPUSH
6020: CALL 719 0 2
6024: PPUSH
6025: LD_INT 46
6027: PPUSH
6028: CALL_OW 52
6032: GO 6009
6034: POP
6035: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6036: LD_ADDR_VAR 0 2
6040: PUSH
6041: LD_INT 22
6043: PUSH
6044: LD_INT 1
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: PUSH
6051: LD_INT 30
6053: PUSH
6054: LD_INT 5
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PPUSH
6065: CALL_OW 69
6069: PUSH
6070: FOR_IN
6071: IFFALSE 6185
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6073: LD_INT 5
6075: PPUSH
6076: LD_VAR 0 5
6080: PPUSH
6081: CALL 719 0 2
6085: PPUSH
6086: LD_VAR 0 2
6090: PPUSH
6091: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6095: LD_INT 5
6097: PPUSH
6098: LD_VAR 0 5
6102: PPUSH
6103: CALL 719 0 2
6107: PPUSH
6108: LD_VAR 0 2
6112: PPUSH
6113: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6117: LD_INT 1
6119: PPUSH
6120: LD_VAR 0 5
6124: PPUSH
6125: CALL 719 0 2
6129: PPUSH
6130: LD_VAR 0 2
6134: PPUSH
6135: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6139: LD_INT 1
6141: PPUSH
6142: LD_VAR 0 5
6146: PPUSH
6147: CALL 719 0 2
6151: PPUSH
6152: LD_VAR 0 2
6156: PPUSH
6157: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6161: LD_INT 1
6163: PPUSH
6164: LD_VAR 0 5
6168: PPUSH
6169: CALL 719 0 2
6173: PPUSH
6174: LD_VAR 0 2
6178: PPUSH
6179: CALL_OW 52
// end ;
6183: GO 6070
6185: POP
6186: POP
// if dif > 1 then
6187: LD_EXP 1
6191: PUSH
6192: LD_INT 1
6194: GREATER
6195: IFFALSE 6268
// for i = 1 to ( dif - 1 ) do
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_EXP 1
6211: PUSH
6212: LD_INT 1
6214: MINUS
6215: PUSH
6216: FOR_TO
6217: IFFALSE 6266
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6219: LD_ADDR_EXP 17
6223: PUSH
6224: LD_EXP 17
6228: PUSH
6229: LD_INT 1
6231: PPUSH
6232: LD_VAR 0 5
6236: PPUSH
6237: CALL 719 0 2
6241: ADD
6242: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6243: LD_EXP 17
6247: PUSH
6248: LD_VAR 0 2
6252: ARRAY
6253: PPUSH
6254: LD_INT 3
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// end ;
6264: GO 6216
6266: POP
6267: POP
// game_started := true ;
6268: LD_ADDR_EXP 10
6272: PUSH
6273: LD_INT 1
6275: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6276: LD_INT 26
6278: PPUSH
6279: LD_INT 3
6281: PPUSH
6282: LD_INT 2
6284: PPUSH
6285: LD_INT 2
6287: PPUSH
6288: LD_INT 13
6290: PPUSH
6291: CALL_OW 125
// while ( contact_am = false ) do
6295: LD_EXP 16
6299: PUSH
6300: LD_INT 0
6302: EQUAL
6303: IFFALSE 6314
// begin Wait ( 0 0$01 ) ;
6305: LD_INT 35
6307: PPUSH
6308: CALL_OW 67
// end ;
6312: GO 6295
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6314: LD_INT 8400
6316: PUSH
6317: LD_INT 6300
6319: PUSH
6320: LD_INT 5250
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: PUSH
6328: LD_EXP 1
6332: ARRAY
6333: PPUSH
6334: CALL_OW 67
// case dif of 1 :
6338: LD_EXP 1
6342: PUSH
6343: LD_INT 1
6345: DOUBLE
6346: EQUAL
6347: IFTRUE 6351
6349: GO 6526
6351: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6352: LD_INT 26
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_INT 1
6360: PPUSH
6361: LD_INT 2
6363: PPUSH
6364: LD_INT 2
6366: PUSH
6367: LD_INT 4
6369: PUSH
6370: LD_INT 5
6372: PUSH
6373: LD_INT 5
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: PUSH
6382: LD_INT 1
6384: PPUSH
6385: LD_INT 4
6387: PPUSH
6388: CALL_OW 12
6392: ARRAY
6393: PPUSH
6394: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6398: LD_INT 26
6400: PPUSH
6401: LD_INT 3
6403: PPUSH
6404: LD_INT 1
6406: PPUSH
6407: LD_INT 2
6409: PPUSH
6410: LD_INT 4
6412: PUSH
6413: LD_INT 5
6415: PUSH
6416: LD_INT 5
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_INT 1
6426: PPUSH
6427: LD_INT 3
6429: PPUSH
6430: CALL_OW 12
6434: ARRAY
6435: PPUSH
6436: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6440: LD_INT 26
6442: PPUSH
6443: LD_INT 3
6445: PPUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 2
6451: PPUSH
6452: LD_INT 4
6454: PUSH
6455: LD_INT 5
6457: PUSH
6458: LD_INT 5
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: PUSH
6466: LD_INT 1
6468: PPUSH
6469: LD_INT 3
6471: PPUSH
6472: CALL_OW 12
6476: ARRAY
6477: PPUSH
6478: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6482: LD_INT 26
6484: PPUSH
6485: LD_INT 3
6487: PPUSH
6488: LD_INT 1
6490: PPUSH
6491: LD_INT 2
6493: PPUSH
6494: LD_INT 4
6496: PUSH
6497: LD_INT 3
6499: PUSH
6500: LD_INT 5
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 1
6510: PPUSH
6511: LD_INT 3
6513: PPUSH
6514: CALL_OW 12
6518: ARRAY
6519: PPUSH
6520: CALL_OW 185
// end ; 2 :
6524: GO 7053
6526: LD_INT 2
6528: DOUBLE
6529: EQUAL
6530: IFTRUE 6534
6532: GO 6747
6534: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6535: LD_INT 26
6537: PPUSH
6538: LD_INT 3
6540: PPUSH
6541: LD_INT 1
6543: PPUSH
6544: LD_INT 2
6546: PPUSH
6547: LD_INT 4
6549: PUSH
6550: LD_INT 5
6552: PUSH
6553: LD_INT 5
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: PUSH
6561: LD_INT 1
6563: PPUSH
6564: LD_INT 3
6566: PPUSH
6567: CALL_OW 12
6571: ARRAY
6572: PPUSH
6573: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6577: LD_INT 26
6579: PPUSH
6580: LD_INT 3
6582: PPUSH
6583: LD_INT 1
6585: PPUSH
6586: LD_INT 2
6588: PPUSH
6589: LD_INT 4
6591: PUSH
6592: LD_INT 5
6594: PUSH
6595: LD_INT 5
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: PUSH
6603: LD_INT 1
6605: PPUSH
6606: LD_INT 3
6608: PPUSH
6609: CALL_OW 12
6613: ARRAY
6614: PPUSH
6615: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6619: LD_INT 26
6621: PPUSH
6622: LD_INT 3
6624: PPUSH
6625: LD_INT 1
6627: PPUSH
6628: LD_INT 2
6630: PPUSH
6631: LD_INT 4
6633: PUSH
6634: LD_INT 3
6636: PUSH
6637: LD_INT 5
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: PUSH
6645: LD_INT 1
6647: PPUSH
6648: LD_INT 3
6650: PPUSH
6651: CALL_OW 12
6655: ARRAY
6656: PPUSH
6657: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6661: LD_INT 26
6663: PPUSH
6664: LD_INT 4
6666: PPUSH
6667: LD_INT 1
6669: PPUSH
6670: LD_INT 2
6672: PPUSH
6673: LD_INT 4
6675: PUSH
6676: LD_INT 5
6678: PUSH
6679: LD_INT 6
6681: PUSH
6682: EMPTY
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 3
6692: PPUSH
6693: CALL_OW 12
6697: ARRAY
6698: PPUSH
6699: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6703: LD_INT 26
6705: PPUSH
6706: LD_INT 4
6708: PPUSH
6709: LD_INT 1
6711: PPUSH
6712: LD_INT 2
6714: PPUSH
6715: LD_INT 4
6717: PUSH
6718: LD_INT 5
6720: PUSH
6721: LD_INT 6
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: LIST
6728: PUSH
6729: LD_INT 1
6731: PPUSH
6732: LD_INT 3
6734: PPUSH
6735: CALL_OW 12
6739: ARRAY
6740: PPUSH
6741: CALL_OW 185
// end ; 3 :
6745: GO 7053
6747: LD_INT 3
6749: DOUBLE
6750: EQUAL
6751: IFTRUE 6755
6753: GO 7052
6755: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6756: LD_INT 26
6758: PPUSH
6759: LD_INT 3
6761: PPUSH
6762: LD_INT 1
6764: PPUSH
6765: LD_INT 2
6767: PPUSH
6768: LD_INT 4
6770: PUSH
6771: LD_INT 5
6773: PUSH
6774: LD_INT 5
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: LIST
6781: PUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 3
6787: PPUSH
6788: CALL_OW 12
6792: ARRAY
6793: PPUSH
6794: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6798: LD_INT 26
6800: PPUSH
6801: LD_INT 3
6803: PPUSH
6804: LD_INT 1
6806: PPUSH
6807: LD_INT 2
6809: PPUSH
6810: LD_INT 4
6812: PUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 5
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: LIST
6823: PUSH
6824: LD_INT 1
6826: PPUSH
6827: LD_INT 3
6829: PPUSH
6830: CALL_OW 12
6834: ARRAY
6835: PPUSH
6836: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6840: LD_INT 26
6842: PPUSH
6843: LD_INT 3
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 2
6851: PPUSH
6852: LD_INT 4
6854: PUSH
6855: LD_INT 5
6857: PUSH
6858: LD_INT 5
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: PUSH
6866: LD_INT 1
6868: PPUSH
6869: LD_INT 3
6871: PPUSH
6872: CALL_OW 12
6876: ARRAY
6877: PPUSH
6878: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6882: LD_INT 26
6884: PPUSH
6885: LD_INT 3
6887: PPUSH
6888: LD_INT 1
6890: PPUSH
6891: LD_INT 2
6893: PPUSH
6894: LD_INT 4
6896: PUSH
6897: LD_INT 5
6899: PUSH
6900: LD_INT 5
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: LIST
6907: PUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_INT 3
6913: PPUSH
6914: CALL_OW 12
6918: ARRAY
6919: PPUSH
6920: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6924: LD_INT 26
6926: PPUSH
6927: LD_INT 4
6929: PPUSH
6930: LD_INT 1
6932: PPUSH
6933: LD_INT 2
6935: PPUSH
6936: LD_INT 4
6938: PUSH
6939: LD_INT 5
6941: PUSH
6942: LD_INT 6
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 1
6952: PPUSH
6953: LD_INT 3
6955: PPUSH
6956: CALL_OW 12
6960: ARRAY
6961: PPUSH
6962: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6966: LD_INT 26
6968: PPUSH
6969: LD_INT 4
6971: PPUSH
6972: LD_INT 1
6974: PPUSH
6975: LD_INT 2
6977: PPUSH
6978: LD_INT 4
6980: PUSH
6981: LD_INT 5
6983: PUSH
6984: LD_INT 6
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: PUSH
6992: LD_INT 1
6994: PPUSH
6995: LD_INT 3
6997: PPUSH
6998: CALL_OW 12
7002: ARRAY
7003: PPUSH
7004: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7008: LD_INT 26
7010: PPUSH
7011: LD_INT 4
7013: PPUSH
7014: LD_INT 1
7016: PPUSH
7017: LD_INT 2
7019: PPUSH
7020: LD_INT 4
7022: PUSH
7023: LD_INT 5
7025: PUSH
7026: LD_INT 6
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 1
7036: PPUSH
7037: LD_INT 3
7039: PPUSH
7040: CALL_OW 12
7044: ARRAY
7045: PPUSH
7046: CALL_OW 185
// end ; end ;
7050: GO 7053
7052: POP
// end ;
7053: LD_VAR 0 1
7057: RET
// every 0 0$01 do var i , filter ;
7058: GO 7060
7060: DISABLE
7061: LD_INT 0
7063: PPUSH
7064: PPUSH
// begin enable ;
7065: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7066: LD_INT 22
7068: PUSH
7069: LD_INT 1
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 25
7078: PUSH
7079: LD_INT 4
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PPUSH
7090: CALL_OW 69
7094: PUSH
7095: LD_INT 0
7097: GREATER
7098: IFFALSE 7107
// RaiseSailEvent ( 3 ) ;
7100: LD_INT 3
7102: PPUSH
7103: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7107: LD_INT 22
7109: PUSH
7110: LD_INT 1
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 21
7119: PUSH
7120: LD_INT 3
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 1000
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: LIST
7148: PPUSH
7149: CALL_OW 69
7153: PUSH
7154: LD_INT 0
7156: GREATER
7157: IFFALSE 7168
// RaiseSailEvent ( 1 ) else
7159: LD_INT 1
7161: PPUSH
7162: CALL_OW 427
7166: GO 7175
// RaiseSailEvent ( 2 ) ;
7168: LD_INT 2
7170: PPUSH
7171: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7175: LD_INT 22
7177: PUSH
7178: LD_INT 1
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PUSH
7185: LD_INT 30
7187: PUSH
7188: LD_INT 5
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PPUSH
7199: CALL_OW 69
7203: PUSH
7204: LD_INT 0
7206: GREATER
7207: IFFALSE 7216
// RaiseSailEvent ( 4 ) ;
7209: LD_INT 4
7211: PPUSH
7212: CALL_OW 427
// if gamma_towers > 0 then
7216: LD_EXP 18
7220: PUSH
7221: LD_INT 0
7223: GREATER
7224: IFFALSE 7233
// RaiseSailEvent ( 5 ) ;
7226: LD_INT 5
7228: PPUSH
7229: CALL_OW 427
// end ;
7233: PPOPN 2
7235: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7236: GO 7238
7238: DISABLE
7239: LD_INT 0
7241: PPUSH
7242: PPUSH
// begin enable ;
7243: ENABLE
// if new_veh > 0 then
7244: LD_EXP 19
7248: PUSH
7249: LD_INT 0
7251: GREATER
7252: IFFALSE 7439
// while ( new_veh > 0 ) do
7254: LD_EXP 19
7258: PUSH
7259: LD_INT 0
7261: GREATER
7262: IFFALSE 7439
// begin Wait ( 0 0$01 ) ;
7264: LD_INT 35
7266: PPUSH
7267: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7271: LD_INT 26
7273: PPUSH
7274: CALL_OW 461
7278: PUSH
7279: LD_INT 2
7281: EQUAL
7282: IFFALSE 7437
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7284: LD_ADDR_VAR 0 1
7288: PUSH
7289: LD_INT 2
7291: PUSH
7292: LD_INT 3
7294: PUSH
7295: LD_INT 3
7297: PUSH
7298: LD_INT 4
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_INT 4
7312: PPUSH
7313: CALL_OW 12
7317: ARRAY
7318: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7319: LD_VAR 0 1
7323: PUSH
7324: LD_INT 2
7326: PUSH
7327: LD_INT 3
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: IN
7334: IFFALSE 7369
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7336: LD_ADDR_VAR 0 2
7340: PUSH
7341: LD_INT 4
7343: PUSH
7344: LD_INT 5
7346: PUSH
7347: LD_INT 7
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: PUSH
7355: LD_INT 1
7357: PPUSH
7358: LD_INT 3
7360: PPUSH
7361: CALL_OW 12
7365: ARRAY
7366: ST_TO_ADDR
7367: GO 7400
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7369: LD_ADDR_VAR 0 2
7373: PUSH
7374: LD_INT 5
7376: PUSH
7377: LD_INT 7
7379: PUSH
7380: LD_INT 6
7382: PUSH
7383: EMPTY
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 1
7390: PPUSH
7391: LD_INT 3
7393: PPUSH
7394: CALL_OW 12
7398: ARRAY
7399: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7400: LD_INT 26
7402: PPUSH
7403: LD_VAR 0 1
7407: PPUSH
7408: LD_INT 1
7410: PPUSH
7411: LD_INT 2
7413: PPUSH
7414: LD_VAR 0 2
7418: PPUSH
7419: CALL_OW 125
// new_veh := new_veh - 1 ;
7423: LD_ADDR_EXP 19
7427: PUSH
7428: LD_EXP 19
7432: PUSH
7433: LD_INT 1
7435: MINUS
7436: ST_TO_ADDR
// end ; end ;
7437: GO 7254
// end ;
7439: PPOPN 2
7441: END
// every 0 0$01 do var v , filter , am_cmeh ;
7442: GO 7444
7444: DISABLE
7445: LD_INT 0
7447: PPUSH
7448: PPUSH
7449: PPUSH
// begin enable ;
7450: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7451: LD_ADDR_VAR 0 3
7455: PUSH
7456: LD_INT 56
7458: PPUSH
7459: CALL_OW 313
7463: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7464: LD_ADDR_VAR 0 2
7468: PUSH
7469: LD_INT 22
7471: PUSH
7472: LD_INT 1
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 33
7481: PUSH
7482: LD_INT 2
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 50
7491: PUSH
7492: EMPTY
7493: LIST
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: LIST
7499: PUSH
7500: EMPTY
7501: LIST
7502: PPUSH
7503: CALL_OW 69
7507: ST_TO_ADDR
// if filter > 0 then
7508: LD_VAR 0 2
7512: PUSH
7513: LD_INT 0
7515: GREATER
7516: IFFALSE 7584
// begin for v in filter do
7518: LD_ADDR_VAR 0 1
7522: PUSH
7523: LD_VAR 0 2
7527: PUSH
7528: FOR_IN
7529: IFFALSE 7582
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7531: LD_VAR 0 1
7535: PPUSH
7536: CALL_OW 312
7540: NOT
7541: PUSH
7542: LD_VAR 0 1
7546: PPUSH
7547: CALL_OW 302
7551: AND
7552: IFFALSE 7580
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7554: LD_VAR 0 1
7558: PPUSH
7559: LD_VAR 0 3
7563: PUSH
7564: LD_INT 1
7566: PPUSH
7567: LD_INT 3
7569: PPUSH
7570: CALL_OW 12
7574: ARRAY
7575: PPUSH
7576: CALL_OW 135
// end ;
7580: GO 7528
7582: POP
7583: POP
// end ; end ;
7584: PPOPN 3
7586: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7587: LD_INT 33
7589: PUSH
7590: LD_INT 2
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 3
7599: PUSH
7600: LD_INT 34
7602: PUSH
7603: LD_INT 13
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: PPUSH
7618: CALL_OW 69
7622: PUSH
7623: LD_INT 4
7625: PUSH
7626: LD_INT 5
7628: PUSH
7629: LD_INT 7
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: PUSH
7637: LD_EXP 1
7641: ARRAY
7642: EQUAL
7643: PUSH
7644: LD_INT 26
7646: PPUSH
7647: CALL_OW 461
7651: PUSH
7652: LD_INT 2
7654: EQUAL
7655: AND
7656: IFFALSE 7867
7658: GO 7660
7660: DISABLE
7661: LD_INT 0
7663: PPUSH
7664: PPUSH
7665: PPUSH
// begin enable ;
7666: ENABLE
// if Sikorski_Ar then
7667: LD_EXP 12
7671: IFFALSE 7748
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7673: LD_ADDR_EXP 11
7677: PUSH
7678: LD_INT 2
7680: PUSH
7681: LD_INT 22
7683: PUSH
7684: LD_INT 4
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 22
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: PUSH
7701: LD_INT 33
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: LD_INT 3
7713: PUSH
7714: LD_INT 34
7716: PUSH
7717: LD_INT 13
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: ST_TO_ADDR
7746: GO 7789
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7748: LD_ADDR_EXP 11
7752: PUSH
7753: LD_INT 33
7755: PUSH
7756: LD_INT 2
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 3
7765: PUSH
7766: LD_INT 34
7768: PUSH
7769: LD_INT 13
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PPUSH
7784: CALL_OW 69
7788: ST_TO_ADDR
// repeat begin for un in SForce do
7789: LD_ADDR_VAR 0 2
7793: PUSH
7794: LD_EXP 11
7798: PUSH
7799: FOR_IN
7800: IFFALSE 7855
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7802: LD_ADDR_VAR 0 3
7806: PUSH
7807: LD_INT 22
7809: PUSH
7810: LD_INT 3
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: PPUSH
7817: CALL_OW 69
7821: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_VAR 0 3
7831: PPUSH
7832: LD_VAR 0 2
7836: PPUSH
7837: CALL_OW 74
7841: PPUSH
7842: CALL_OW 115
// Wait ( 0 0$01 ) ;
7846: LD_INT 35
7848: PPUSH
7849: CALL_OW 67
// end ;
7853: GO 7799
7855: POP
7856: POP
// end until SForce = 0 ;
7857: LD_EXP 11
7861: PUSH
7862: LD_INT 0
7864: EQUAL
7865: IFFALSE 7789
// end ;
7867: PPOPN 3
7869: END
// export function NewForce ( num ) ; var i , filter , veh ; begin
7870: LD_INT 0
7872: PPUSH
7873: PPUSH
7874: PPUSH
7875: PPUSH
// uc_side := 4 ;
7876: LD_ADDR_OWVAR 20
7880: PUSH
7881: LD_INT 4
7883: ST_TO_ADDR
// uc_nation := 1 ;
7884: LD_ADDR_OWVAR 21
7888: PUSH
7889: LD_INT 1
7891: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7892: LD_ADDR_OWVAR 37
7896: PUSH
7897: LD_INT 4
7899: ST_TO_ADDR
// vc_control := control_manual ;
7900: LD_ADDR_OWVAR 38
7904: PUSH
7905: LD_INT 1
7907: ST_TO_ADDR
// vc_engine := engine_combustion ;
7908: LD_ADDR_OWVAR 39
7912: PUSH
7913: LD_INT 1
7915: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
7916: LD_ADDR_OWVAR 40
7920: PUSH
7921: LD_INT 4
7923: PUSH
7924: LD_INT 5
7926: PUSH
7927: LD_INT 7
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: LIST
7934: PUSH
7935: LD_EXP 1
7939: ARRAY
7940: ST_TO_ADDR
// veh := CreateVehicle ;
7941: LD_ADDR_VAR 0 5
7945: PUSH
7946: CALL_OW 45
7950: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
7951: LD_VAR 0 5
7955: PPUSH
7956: LD_INT 2
7958: PPUSH
7959: LD_INT 0
7961: PPUSH
7962: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
7966: LD_EXP 9
7970: PPUSH
7971: LD_VAR 0 5
7975: PPUSH
7976: CALL_OW 52
// SetMark ( veh , 1 ) ;
7980: LD_VAR 0 5
7984: PPUSH
7985: LD_INT 1
7987: PPUSH
7988: CALL_OW 242
// while ( num > 0 ) do
7992: LD_VAR 0 1
7996: PUSH
7997: LD_INT 0
7999: GREATER
8000: IFFALSE 8167
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8002: LD_INT 3
8004: PUSH
8005: LD_INT 3
8007: PUSH
8008: LD_INT 3
8010: PUSH
8011: LD_INT 4
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: PUSH
8020: LD_EXP 1
8024: PPUSH
8025: LD_INT 4
8027: PPUSH
8028: CALL_OW 12
8032: ARRAY
8033: PPUSH
8034: LD_INT 1
8036: PPUSH
8037: LD_INT 4
8039: PUSH
8040: LD_INT 5
8042: PUSH
8043: LD_INT 5
8045: PUSH
8046: LD_INT 7
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 1
8057: PPUSH
8058: LD_EXP 1
8062: PUSH
8063: LD_INT 1
8065: PLUS
8066: PPUSH
8067: CALL_OW 12
8071: ARRAY
8072: PPUSH
8073: LD_INT 11
8075: PPUSH
8076: LD_INT 2
8078: PPUSH
8079: LD_INT 5
8081: PUSH
8082: LD_INT 6
8084: PUSH
8085: LD_INT 7
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: LIST
8092: PUSH
8093: LD_EXP 1
8097: ARRAY
8098: PPUSH
8099: CALL 1282 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8103: LD_ADDR_VAR 0 4
8107: PUSH
8108: LD_INT 22
8110: PUSH
8111: LD_INT 4
8113: PUSH
8114: EMPTY
8115: LIST
8116: LIST
8117: PPUSH
8118: CALL_OW 69
8122: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8123: LD_VAR 0 4
8127: PUSH
8128: LD_VAR 0 4
8132: ARRAY
8133: PPUSH
8134: LD_INT 36
8136: PPUSH
8137: LD_INT 18
8139: PPUSH
8140: CALL_OW 111
// Wait ( 0 0$02 ) ;
8144: LD_INT 70
8146: PPUSH
8147: CALL_OW 67
// num := num - 1 ;
8151: LD_ADDR_VAR 0 1
8155: PUSH
8156: LD_VAR 0 1
8160: PUSH
8161: LD_INT 1
8163: MINUS
8164: ST_TO_ADDR
// end ;
8165: GO 7992
// end ;
8167: LD_VAR 0 2
8171: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8172: LD_EXP 17
8176: PUSH
8177: LD_INT 0
8179: GREATER
8180: IFFALSE 8449
8182: GO 8184
8184: DISABLE
8185: LD_INT 0
8187: PPUSH
// begin enable ;
8188: ENABLE
// for i = 1 to patrol do
8189: LD_ADDR_VAR 0 1
8193: PUSH
8194: DOUBLE
8195: LD_INT 1
8197: DEC
8198: ST_TO_ADDR
8199: LD_EXP 17
8203: PUSH
8204: FOR_TO
8205: IFFALSE 8447
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8207: LD_EXP 17
8211: PUSH
8212: LD_VAR 0 1
8216: ARRAY
8217: PUSH
8218: LD_EXP 17
8222: PUSH
8223: LD_VAR 0 1
8227: ARRAY
8228: PPUSH
8229: CALL_OW 300
8233: AND
8234: PUSH
8235: LD_EXP 17
8239: PUSH
8240: LD_VAR 0 1
8244: ARRAY
8245: PPUSH
8246: CALL_OW 314
8250: NOT
8251: AND
8252: IFFALSE 8402
// case i of 1 :
8254: LD_VAR 0 1
8258: PUSH
8259: LD_INT 1
8261: DOUBLE
8262: EQUAL
8263: IFTRUE 8267
8265: GO 8330
8267: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8268: LD_EXP 17
8272: PUSH
8273: LD_VAR 0 1
8277: ARRAY
8278: PPUSH
8279: LD_INT 53
8281: PPUSH
8282: LD_INT 91
8284: PPUSH
8285: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8289: LD_EXP 17
8293: PUSH
8294: LD_VAR 0 1
8298: ARRAY
8299: PPUSH
8300: LD_INT 245
8302: PPUSH
8303: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8307: LD_EXP 17
8311: PUSH
8312: LD_VAR 0 1
8316: ARRAY
8317: PPUSH
8318: LD_INT 24
8320: PPUSH
8321: LD_INT 26
8323: PPUSH
8324: CALL_OW 171
// end ; 2 :
8328: GO 8402
8330: LD_INT 2
8332: DOUBLE
8333: EQUAL
8334: IFTRUE 8338
8336: GO 8401
8338: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8339: LD_EXP 17
8343: PUSH
8344: LD_VAR 0 1
8348: ARRAY
8349: PPUSH
8350: LD_INT 83
8352: PPUSH
8353: LD_INT 57
8355: PPUSH
8356: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8360: LD_EXP 17
8364: PUSH
8365: LD_VAR 0 1
8369: ARRAY
8370: PPUSH
8371: LD_INT 245
8373: PPUSH
8374: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8378: LD_EXP 17
8382: PUSH
8383: LD_VAR 0 1
8387: ARRAY
8388: PPUSH
8389: LD_INT 47
8391: PPUSH
8392: LD_INT 53
8394: PPUSH
8395: CALL_OW 171
// end ; end ;
8399: GO 8402
8401: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8402: LD_EXP 17
8406: PUSH
8407: LD_VAR 0 1
8411: ARRAY
8412: PPUSH
8413: CALL_OW 256
8417: PUSH
8418: LD_INT 1000
8420: LESS
8421: IFFALSE 8445
// patrol := patrol diff patrol [ i ] ;
8423: LD_ADDR_EXP 17
8427: PUSH
8428: LD_EXP 17
8432: PUSH
8433: LD_EXP 17
8437: PUSH
8438: LD_VAR 0 1
8442: ARRAY
8443: DIFF
8444: ST_TO_ADDR
// end ;
8445: GO 8204
8447: POP
8448: POP
// end ;
8449: PPOPN 1
8451: END
// every 0 0$10 do
8452: GO 8454
8454: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8455: LD_INT 42000
8457: PUSH
8458: LD_INT 37800
8460: PUSH
8461: LD_INT 33600
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: PUSH
8469: LD_EXP 1
8473: ARRAY
8474: PPUSH
8475: CALL_OW 67
// if not contact_am then
8479: LD_EXP 16
8483: NOT
8484: IFFALSE 8494
// contact_am := true ;
8486: LD_ADDR_EXP 16
8490: PUSH
8491: LD_INT 1
8493: ST_TO_ADDR
// end ; end_of_file
8494: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8495: LD_INT 0
8497: PPUSH
// comp_tested := false ;
8498: LD_ADDR_EXP 22
8502: PUSH
8503: LD_INT 0
8505: ST_TO_ADDR
// sikorski_run := false ;
8506: LD_ADDR_EXP 23
8510: PUSH
8511: LD_INT 0
8513: ST_TO_ADDR
// InGameOn ;
8514: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8518: LD_EXP 3
8522: PPUSH
8523: CALL_OW 87
// Wait ( 0 0$01 ) ;
8527: LD_INT 35
8529: PPUSH
8530: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8534: LD_EXP 2
8538: PPUSH
8539: LD_STRING Dpop1
8541: PPUSH
8542: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8546: LD_EXP 3
8550: PPUSH
8551: LD_STRING Dcomm1
8553: PPUSH
8554: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8558: LD_EXP 2
8562: PPUSH
8563: LD_STRING Dpop2
8565: PPUSH
8566: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8570: LD_EXP 3
8574: PPUSH
8575: LD_STRING Dcomm2
8577: PPUSH
8578: CALL_OW 88
// InGameOff ;
8582: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8586: LD_STRING T1
8588: PPUSH
8589: CALL_OW 337
// end ;
8593: LD_VAR 0 1
8597: RET
// every 0 0$01 trigger timer > 2 2$01 do
8598: LD_EXP 24
8602: PUSH
8603: LD_INT 4235
8605: GREATER
8606: IFFALSE 8623
8608: GO 8610
8610: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8611: LD_EXP 5
8615: PPUSH
8616: LD_STRING DKap1
8618: PPUSH
8619: CALL_OW 94
// end ;
8623: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8624: LD_EXP 24
8628: PUSH
8629: LD_INT 46200
8631: PUSH
8632: LD_INT 52500
8634: PUSH
8635: LD_INT 63000
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: PUSH
8643: LD_EXP 1
8647: ARRAY
8648: GREATER
8649: IFFALSE 9016
8651: GO 8653
8653: DISABLE
8654: LD_INT 0
8656: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8657: LD_EXP 5
8661: PPUSH
8662: LD_STRING DKap2
8664: PPUSH
8665: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8669: LD_INT 10
8671: PPUSH
8672: CALL_OW 67
// Say ( commander , Dcommk ) ;
8676: LD_EXP 3
8680: PPUSH
8681: LD_STRING Dcommk
8683: PPUSH
8684: CALL_OW 88
// Wait ( 0 0$44 ) ;
8688: LD_INT 1540
8690: PPUSH
8691: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8695: LD_EXP 5
8699: PPUSH
8700: LD_INT 3
8702: PPUSH
8703: LD_INT 0
8705: PPUSH
8706: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8710: LD_EXP 5
8714: PPUSH
8715: CALL_OW 87
// Wait ( 0 0$10 ) ;
8719: LD_INT 350
8721: PPUSH
8722: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8726: LD_INT 6
8728: PUSH
8729: LD_INT 7
8731: PUSH
8732: LD_INT 8
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: LIST
8739: PUSH
8740: LD_EXP 1
8744: ARRAY
8745: PPUSH
8746: CALL 7870 0 1
// Wait ( 2 2$00 ) ;
8750: LD_INT 4200
8752: PPUSH
8753: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8757: LD_INT 33
8759: PUSH
8760: LD_INT 2
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: LD_INT 3
8769: PUSH
8770: LD_INT 34
8772: PUSH
8773: LD_INT 13
8775: PUSH
8776: EMPTY
8777: LIST
8778: LIST
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PPUSH
8788: CALL_OW 69
8792: PUSH
8793: LD_INT 3
8795: LESS
8796: IFFALSE 8807
// Wait ( 0 0$01 ) ;
8798: LD_INT 35
8800: PPUSH
8801: CALL_OW 67
8805: GO 8757
// uc_side := 4 ;
8807: LD_ADDR_OWVAR 20
8811: PUSH
8812: LD_INT 4
8814: ST_TO_ADDR
// uc_nation := 1 ;
8815: LD_ADDR_OWVAR 21
8819: PUSH
8820: LD_INT 1
8822: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8823: LD_ADDR_VAR 0 1
8827: PUSH
8828: DOUBLE
8829: LD_INT 1
8831: DEC
8832: ST_TO_ADDR
8833: LD_INT 4
8835: PUSH
8836: LD_INT 5
8838: PUSH
8839: LD_INT 6
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: LIST
8846: PUSH
8847: LD_EXP 1
8851: ARRAY
8852: PUSH
8853: FOR_TO
8854: IFFALSE 8896
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8856: LD_INT 1
8858: PPUSH
8859: LD_INT 5
8861: PUSH
8862: LD_INT 6
8864: PUSH
8865: LD_INT 7
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PUSH
8873: LD_EXP 1
8877: ARRAY
8878: PPUSH
8879: CALL 719 0 2
8883: PPUSH
8884: LD_INT 4
8886: PPUSH
8887: LD_INT 0
8889: PPUSH
8890: CALL_OW 49
8894: GO 8853
8896: POP
8897: POP
// sikorski_ar := true ;
8898: LD_ADDR_EXP 12
8902: PUSH
8903: LD_INT 1
8905: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
8906: LD_EXP 9
8910: PPUSH
8911: LD_STRING DSik1
8913: PPUSH
8914: CALL_OW 94
// Wait ( 0 0$30 ) ;
8918: LD_INT 1050
8920: PPUSH
8921: CALL_OW 67
// uc_side := 4 ;
8925: LD_ADDR_OWVAR 20
8929: PUSH
8930: LD_INT 4
8932: ST_TO_ADDR
// uc_nation := 1 ;
8933: LD_ADDR_OWVAR 21
8937: PUSH
8938: LD_INT 1
8940: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
8941: LD_ADDR_VAR 0 1
8945: PUSH
8946: DOUBLE
8947: LD_INT 1
8949: DEC
8950: ST_TO_ADDR
8951: LD_INT 3
8953: PUSH
8954: LD_INT 4
8956: PUSH
8957: LD_INT 4
8959: PUSH
8960: EMPTY
8961: LIST
8962: LIST
8963: LIST
8964: PUSH
8965: LD_EXP 1
8969: ARRAY
8970: PUSH
8971: FOR_TO
8972: IFFALSE 9014
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
8974: LD_INT 1
8976: PPUSH
8977: LD_INT 5
8979: PUSH
8980: LD_INT 6
8982: PUSH
8983: LD_INT 7
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: LIST
8990: PUSH
8991: LD_EXP 1
8995: ARRAY
8996: PPUSH
8997: CALL 719 0 2
9001: PPUSH
9002: LD_INT 13
9004: PPUSH
9005: LD_INT 0
9007: PPUSH
9008: CALL_OW 49
9012: GO 8971
9014: POP
9015: POP
// end ;
9016: PPOPN 1
9018: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9019: LD_EXP 9
9023: PPUSH
9024: CALL_OW 256
9028: PUSH
9029: LD_INT 650
9031: LESS
9032: IFFALSE 9114
9034: GO 9036
9036: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9037: LD_EXP 9
9041: PPUSH
9042: LD_STRING DSik2
9044: PPUSH
9045: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9049: LD_EXP 9
9053: PPUSH
9054: CALL_OW 300
9058: IFFALSE 9114
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9060: LD_EXP 9
9064: PPUSH
9065: LD_INT 2
9067: PPUSH
9068: CALL_OW 113
// Wait ( 0 0$01 ) ;
9072: LD_INT 35
9074: PPUSH
9075: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9079: LD_EXP 9
9083: PPUSH
9084: LD_INT 2
9086: PPUSH
9087: CALL_OW 308
9091: IFFALSE 9112
// begin RemoveUnit ( sikorski ) ;
9093: LD_EXP 9
9097: PPUSH
9098: CALL_OW 64
// break ;
9102: GO 9114
// sikorski_run := true ;
9104: LD_ADDR_EXP 23
9108: PUSH
9109: LD_INT 1
9111: ST_TO_ADDR
// end ; end ;
9112: GO 9049
// end ;
9114: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9115: LD_EXP 9
9119: PPUSH
9120: CALL_OW 256
9124: PUSH
9125: LD_INT 1000
9127: LESS
9128: IFFALSE 9145
9130: GO 9132
9132: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9133: LD_EXP 9
9137: PPUSH
9138: LD_STRING DSkik3
9140: PPUSH
9141: CALL_OW 88
9145: END
// every 1 1$45 + 0 0$15 do
9146: GO 9148
9148: DISABLE
// begin enable ;
9149: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9150: LD_INT 1
9152: PPUSH
9153: LD_INT 5
9155: PPUSH
9156: CALL_OW 12
9160: PPUSH
9161: LD_INT 8
9163: PPUSH
9164: LD_INT 1
9166: PPUSH
9167: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9171: LD_INT 350
9173: PPUSH
9174: LD_INT 1295
9176: PPUSH
9177: CALL_OW 12
9181: PPUSH
9182: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9186: LD_INT 1
9188: PPUSH
9189: LD_INT 5
9191: PPUSH
9192: CALL_OW 12
9196: PPUSH
9197: LD_INT 1
9199: PPUSH
9200: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9204: LD_INT 350
9206: PPUSH
9207: LD_INT 1050
9209: PPUSH
9210: CALL_OW 12
9214: PPUSH
9215: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9219: LD_EXP 24
9223: PUSH
9224: LD_INT 25200
9226: PUSH
9227: LD_INT 23100
9229: PUSH
9230: LD_INT 21000
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: LIST
9237: PUSH
9238: LD_EXP 1
9242: ARRAY
9243: LESSEQUAL
9244: IFFALSE 9267
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9246: LD_INT 1
9248: PPUSH
9249: LD_INT 5
9251: PPUSH
9252: CALL_OW 12
9256: PPUSH
9257: LD_INT 8
9259: PPUSH
9260: LD_INT 1
9262: PPUSH
9263: CALL_OW 55
// end ;
9267: END
// export timer ; every 1 do
9268: GO 9270
9270: DISABLE
// timer := 0 0$00 ;
9271: LD_ADDR_EXP 24
9275: PUSH
9276: LD_INT 0
9278: ST_TO_ADDR
9279: END
// every 0 0$01 do
9280: GO 9282
9282: DISABLE
// begin enable ;
9283: ENABLE
// Display_Strings := [ #tick , timer ] ;
9284: LD_ADDR_OWVAR 47
9288: PUSH
9289: LD_STRING #tick
9291: PUSH
9292: LD_EXP 24
9296: PUSH
9297: EMPTY
9298: LIST
9299: LIST
9300: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9301: LD_ADDR_EXP 24
9305: PUSH
9306: LD_EXP 24
9310: PUSH
9311: LD_INT 35
9313: PLUS
9314: ST_TO_ADDR
// end ;
9315: END
