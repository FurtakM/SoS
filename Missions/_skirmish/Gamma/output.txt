// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8617 0 0
// PrepareAmerican ;
 100: CALL 5237 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
3263: LD_VAR 0 1
3267: PPUSH
3268: CALL 20321 0 1
// if un in Patrol then
3272: LD_VAR 0 1
3276: PUSH
3277: LD_EXP 17
3281: IN
3282: IFFALSE 3300
// Patrol := Patrol diff un ;
3284: LD_ADDR_EXP 17
3288: PUSH
3289: LD_EXP 17
3293: PUSH
3294: LD_VAR 0 1
3298: DIFF
3299: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3300: LD_VAR 0 1
3304: PUSH
3305: LD_INT 22
3307: PUSH
3308: LD_INT 1
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 30
3317: PUSH
3318: LD_INT 32
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: PPUSH
3329: CALL_OW 69
3333: IN
3334: IFFALSE 3420
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3336: LD_ADDR_EXP 18
3340: PUSH
3341: LD_EXP 18
3345: PUSH
3346: LD_VAR 0 1
3350: PPUSH
3351: CALL_OW 250
3355: ADD
3356: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3357: LD_ADDR_EXP 18
3361: PUSH
3362: LD_EXP 18
3366: PUSH
3367: LD_VAR 0 1
3371: PPUSH
3372: CALL_OW 251
3376: ADD
3377: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3378: LD_ADDR_EXP 18
3382: PUSH
3383: LD_EXP 18
3387: PUSH
3388: LD_VAR 0 1
3392: PPUSH
3393: CALL_OW 254
3397: ADD
3398: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3399: LD_ADDR_EXP 18
3403: PUSH
3404: LD_EXP 18
3408: PUSH
3409: LD_VAR 0 1
3413: PPUSH
3414: CALL_OW 269
3418: ADD
3419: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3420: LD_VAR 0 1
3424: PUSH
3425: LD_INT 33
3427: PUSH
3428: LD_INT 2
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 3
3437: PUSH
3438: LD_INT 34
3440: PUSH
3441: LD_INT 13
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: PUSH
3452: EMPTY
3453: LIST
3454: LIST
3455: PPUSH
3456: CALL_OW 69
3460: IN
3461: IFFALSE 3477
// new_veh := new_veh + 1 ;
3463: LD_ADDR_EXP 19
3467: PUSH
3468: LD_EXP 19
3472: PUSH
3473: LD_INT 1
3475: PLUS
3476: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3477: LD_VAR 0 1
3481: PUSH
3482: LD_INT 34
3484: PUSH
3485: LD_INT 13
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PPUSH
3492: CALL_OW 69
3496: IN
3497: IFFALSE 3518
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3499: LD_INT 26
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: LD_INT 2
3507: PPUSH
3508: LD_INT 2
3510: PPUSH
3511: LD_INT 13
3513: PPUSH
3514: CALL_OW 185
// if un = am_dep then
3518: LD_VAR 0 1
3522: PUSH
3523: LD_INT 25
3525: EQUAL
3526: IFFALSE 3694
// begin SayRadio ( Platonov , DPlat ) ;
3528: LD_EXP 4
3532: PPUSH
3533: LD_STRING DPlat
3535: PPUSH
3536: CALL_OW 94
// if timer <= 30 30$00 then
3540: LD_EXP 24
3544: PUSH
3545: LD_INT 63000
3547: LESSEQUAL
3548: IFFALSE 3562
// AddMedal ( gamma_med3 , 1 ) else
3550: LD_STRING gamma_med3
3552: PPUSH
3553: LD_INT 1
3555: PPUSH
3556: CALL_OW 101
3560: GO 3612
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3562: LD_EXP 24
3566: PUSH
3567: LD_INT 105000
3569: PUSH
3570: LD_INT 88200
3572: PUSH
3573: LD_INT 73500
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: LIST
3580: PUSH
3581: LD_EXP 1
3585: ARRAY
3586: LESSEQUAL
3587: IFFALSE 3601
// AddMedal ( gamma_med3 , 2 ) else
3589: LD_STRING gamma_med3
3591: PPUSH
3592: LD_INT 2
3594: PPUSH
3595: CALL_OW 101
3599: GO 3612
// AddMedal ( gamma_med3 , - 1 ) ;
3601: LD_STRING gamma_med3
3603: PPUSH
3604: LD_INT 1
3606: NEG
3607: PPUSH
3608: CALL_OW 101
// if not comp_tested then
3612: LD_EXP 22
3616: NOT
3617: IFFALSE 3632
// AddMedal ( gamma_med2 , - 1 ) else
3619: LD_STRING gamma_med2
3621: PPUSH
3622: LD_INT 1
3624: NEG
3625: PPUSH
3626: CALL_OW 101
3630: GO 3642
// AddMedal ( gamma_med2 , 1 ) ;
3632: LD_STRING gamma_med2
3634: PPUSH
3635: LD_INT 1
3637: PPUSH
3638: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3642: LD_EXP 9
3646: PPUSH
3647: CALL_OW 301
3651: PUSH
3652: LD_EXP 23
3656: NOT
3657: AND
3658: IFFALSE 3672
// AddMedal ( gamma_med1 , 1 ) else
3660: LD_STRING gamma_med1
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 101
3670: GO 3683
// AddMedal ( gamma_med1 , - 1 ) ;
3672: LD_STRING gamma_med1
3674: PPUSH
3675: LD_INT 1
3677: NEG
3678: PPUSH
3679: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3683: LD_STRING GAMMA_MEDALS
3685: PPUSH
3686: CALL_OW 102
// YouWin ;
3690: CALL_OW 103
// end ; if un = commander then
3694: LD_VAR 0 1
3698: PUSH
3699: LD_EXP 3
3703: EQUAL
3704: IFFALSE 3713
// YouLost ( comml ) ;
3706: LD_STRING comml
3708: PPUSH
3709: CALL_OW 104
// if un = sikorski then
3713: LD_VAR 0 1
3717: PUSH
3718: LD_EXP 9
3722: EQUAL
3723: IFFALSE 3735
// AddMedal ( gamma_med1 , 1 ) ;
3725: LD_STRING gamma_med1
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 101
// end ;
3735: PPOPN 1
3737: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3738: LD_INT 0
3740: PPUSH
3741: PPUSH
3742: PPUSH
3743: PPUSH
3744: PPUSH
3745: PPUSH
3746: PPUSH
3747: PPUSH
3748: PPUSH
// begin if event = 1 then
3749: LD_VAR 0 1
3753: PUSH
3754: LD_INT 1
3756: EQUAL
3757: IFFALSE 4054
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3759: LD_ADDR_VAR 0 4
3763: PUSH
3764: LD_INT 22
3766: PUSH
3767: LD_INT 1
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 21
3776: PUSH
3777: LD_INT 3
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 3
3786: PUSH
3787: LD_INT 24
3789: PUSH
3790: LD_INT 1000
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: LIST
3805: PPUSH
3806: CALL_OW 69
3810: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 1
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 25
3828: PUSH
3829: LD_INT 2
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: LD_INT 24
3838: PUSH
3839: LD_INT 1000
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: EMPTY
3852: LIST
3853: PPUSH
3854: CALL_OW 69
3858: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3859: LD_ADDR_VAR 0 9
3863: PUSH
3864: LD_INT 22
3866: PUSH
3867: LD_INT 1
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 34
3876: PUSH
3877: LD_INT 13
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 69
3892: ST_TO_ADDR
// if engs > 0 then
3893: LD_VAR 0 8
3897: PUSH
3898: LD_INT 0
3900: GREATER
3901: IFFALSE 4006
// for i = 1 to engs do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_VAR 0 8
3917: PUSH
3918: FOR_TO
3919: IFFALSE 4004
// begin if IsInUnit ( engs [ i ] ) then
3921: LD_VAR 0 8
3925: PUSH
3926: LD_VAR 0 2
3930: ARRAY
3931: PPUSH
3932: CALL_OW 310
3936: IFFALSE 3953
// ComExitBuilding ( engs [ i ] ) ;
3938: LD_VAR 0 8
3942: PUSH
3943: LD_VAR 0 2
3947: ARRAY
3948: PPUSH
3949: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3953: LD_INT 7
3955: PPUSH
3956: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3960: LD_VAR 0 8
3964: PUSH
3965: LD_VAR 0 2
3969: ARRAY
3970: PPUSH
3971: CALL_OW 314
3975: NOT
3976: IFFALSE 4002
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3978: LD_VAR 0 8
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: PPUSH
3989: LD_VAR 0 4
3993: PUSH
3994: LD_INT 1
3996: ARRAY
3997: PPUSH
3998: CALL_OW 130
// end ;
4002: GO 3918
4004: POP
4005: POP
// if crane > 0 then
4006: LD_VAR 0 9
4010: PUSH
4011: LD_INT 0
4013: GREATER
4014: IFFALSE 4054
// if not HasTask ( crane [ 1 ] ) then
4016: LD_VAR 0 9
4020: PUSH
4021: LD_INT 1
4023: ARRAY
4024: PPUSH
4025: CALL_OW 314
4029: NOT
4030: IFFALSE 4054
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4032: LD_VAR 0 9
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_VAR 0 4
4045: PUSH
4046: LD_INT 1
4048: ARRAY
4049: PPUSH
4050: CALL_OW 130
// end ; if event = 2 then
4054: LD_VAR 0 1
4058: PUSH
4059: LD_INT 2
4061: EQUAL
4062: IFFALSE 4184
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4064: LD_ADDR_VAR 0 8
4068: PUSH
4069: LD_INT 22
4071: PUSH
4072: LD_INT 1
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PUSH
4079: LD_INT 25
4081: PUSH
4082: LD_INT 2
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: PUSH
4089: EMPTY
4090: LIST
4091: LIST
4092: PPUSH
4093: CALL_OW 69
4097: ST_TO_ADDR
// if engs > 0 then
4098: LD_VAR 0 8
4102: PUSH
4103: LD_INT 0
4105: GREATER
4106: IFFALSE 4184
// for i = 1 to engs do
4108: LD_ADDR_VAR 0 2
4112: PUSH
4113: DOUBLE
4114: LD_INT 1
4116: DEC
4117: ST_TO_ADDR
4118: LD_VAR 0 8
4122: PUSH
4123: FOR_TO
4124: IFFALSE 4182
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4126: LD_VAR 0 8
4130: PUSH
4131: LD_VAR 0 2
4135: ARRAY
4136: PPUSH
4137: CALL_OW 314
4141: NOT
4142: PUSH
4143: LD_VAR 0 8
4147: PUSH
4148: LD_VAR 0 2
4152: ARRAY
4153: PPUSH
4154: CALL_OW 310
4158: NOT
4159: AND
4160: IFFALSE 4180
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4162: LD_VAR 0 8
4166: PUSH
4167: LD_VAR 0 2
4171: ARRAY
4172: PPUSH
4173: LD_INT 25
4175: PPUSH
4176: CALL_OW 120
4180: GO 4123
4182: POP
4183: POP
// end ; if event = 3 then
4184: LD_VAR 0 1
4188: PUSH
4189: LD_INT 3
4191: EQUAL
4192: IFFALSE 4556
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4194: LD_ADDR_VAR 0 4
4198: PUSH
4199: LD_INT 22
4201: PUSH
4202: LD_INT 1
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PUSH
4209: LD_INT 21
4211: PUSH
4212: LD_INT 1
4214: PUSH
4215: EMPTY
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 3
4221: PUSH
4222: LD_INT 25
4224: PUSH
4225: LD_INT 4
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 3
4238: PUSH
4239: LD_INT 24
4241: PUSH
4242: LD_INT 800
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: PPUSH
4262: CALL_OW 69
4266: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4267: LD_ADDR_VAR 0 5
4271: PUSH
4272: LD_INT 22
4274: PUSH
4275: LD_INT 1
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 25
4284: PUSH
4285: LD_INT 4
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PPUSH
4296: CALL_OW 69
4300: ST_TO_ADDR
// if filter > 0 then
4301: LD_VAR 0 4
4305: PUSH
4306: LD_INT 0
4308: GREATER
4309: IFFALSE 4498
// begin for i = 1 to doc do
4311: LD_ADDR_VAR 0 2
4315: PUSH
4316: DOUBLE
4317: LD_INT 1
4319: DEC
4320: ST_TO_ADDR
4321: LD_VAR 0 5
4325: PUSH
4326: FOR_TO
4327: IFFALSE 4427
// begin if IsInUnit ( doc [ i ] ) then
4329: LD_VAR 0 5
4333: PUSH
4334: LD_VAR 0 2
4338: ARRAY
4339: PPUSH
4340: CALL_OW 310
4344: IFFALSE 4361
// ComExitBuilding ( doc [ i ] ) ;
4346: LD_VAR 0 5
4350: PUSH
4351: LD_VAR 0 2
4355: ARRAY
4356: PPUSH
4357: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4361: LD_VAR 0 4
4365: PUSH
4366: LD_INT 1
4368: ARRAY
4369: PPUSH
4370: LD_INT 46
4372: PPUSH
4373: CALL_OW 296
4377: PUSH
4378: LD_INT 10
4380: LESS
4381: PUSH
4382: LD_VAR 0 5
4386: PUSH
4387: LD_VAR 0 2
4391: ARRAY
4392: PPUSH
4393: CALL_OW 314
4397: NOT
4398: AND
4399: IFFALSE 4425
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4401: LD_VAR 0 5
4405: PUSH
4406: LD_VAR 0 2
4410: ARRAY
4411: PPUSH
4412: LD_VAR 0 4
4416: PUSH
4417: LD_INT 1
4419: ARRAY
4420: PPUSH
4421: CALL_OW 128
// end ;
4425: GO 4326
4427: POP
4428: POP
// for i = 1 to filter do
4429: LD_ADDR_VAR 0 2
4433: PUSH
4434: DOUBLE
4435: LD_INT 1
4437: DEC
4438: ST_TO_ADDR
4439: LD_VAR 0 4
4443: PUSH
4444: FOR_TO
4445: IFFALSE 4494
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4447: LD_VAR 0 4
4451: PUSH
4452: LD_VAR 0 2
4456: ARRAY
4457: PPUSH
4458: LD_INT 46
4460: PPUSH
4461: CALL_OW 296
4465: PUSH
4466: LD_INT 10
4468: GREATER
4469: IFFALSE 4492
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4471: LD_VAR 0 4
4475: PUSH
4476: LD_VAR 0 2
4480: ARRAY
4481: PPUSH
4482: LD_INT 47
4484: PPUSH
4485: LD_INT 12
4487: PPUSH
4488: CALL_OW 111
4492: GO 4444
4494: POP
4495: POP
// end else
4496: GO 4556
// for i = 1 to doc do
4498: LD_ADDR_VAR 0 2
4502: PUSH
4503: DOUBLE
4504: LD_INT 1
4506: DEC
4507: ST_TO_ADDR
4508: LD_VAR 0 5
4512: PUSH
4513: FOR_TO
4514: IFFALSE 4554
// if not IsInUnit ( doc [ i ] ) then
4516: LD_VAR 0 5
4520: PUSH
4521: LD_VAR 0 2
4525: ARRAY
4526: PPUSH
4527: CALL_OW 310
4531: NOT
4532: IFFALSE 4552
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4534: LD_VAR 0 5
4538: PUSH
4539: LD_VAR 0 2
4543: ARRAY
4544: PPUSH
4545: LD_INT 46
4547: PPUSH
4548: CALL_OW 120
4552: GO 4513
4554: POP
4555: POP
// end ; if event = 4 then
4556: LD_VAR 0 1
4560: PUSH
4561: LD_INT 4
4563: EQUAL
4564: IFFALSE 4815
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4566: LD_ADDR_VAR 0 6
4570: PUSH
4571: LD_INT 22
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 30
4583: PUSH
4584: LD_INT 5
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PPUSH
4595: CALL_OW 69
4599: ST_TO_ADDR
// for i = 1 to bac do
4600: LD_ADDR_VAR 0 2
4604: PUSH
4605: DOUBLE
4606: LD_INT 1
4608: DEC
4609: ST_TO_ADDR
4610: LD_VAR 0 6
4614: PUSH
4615: FOR_TO
4616: IFFALSE 4657
// if UnitsInside ( bac [ i ] ) < 6 then
4618: LD_VAR 0 6
4622: PUSH
4623: LD_VAR 0 2
4627: ARRAY
4628: PPUSH
4629: CALL_OW 313
4633: PUSH
4634: LD_INT 6
4636: LESS
4637: IFFALSE 4655
// place := bac [ i ] ;
4639: LD_ADDR_VAR 0 7
4643: PUSH
4644: LD_VAR 0 6
4648: PUSH
4649: LD_VAR 0 2
4653: ARRAY
4654: ST_TO_ADDR
4655: GO 4615
4657: POP
4658: POP
// if place then
4659: LD_VAR 0 7
4663: IFFALSE 4815
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4665: LD_ADDR_VAR 0 4
4669: PUSH
4670: LD_INT 22
4672: PUSH
4673: LD_INT 1
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: LD_INT 2
4682: PUSH
4683: LD_INT 25
4685: PUSH
4686: LD_INT 1
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PUSH
4693: LD_INT 25
4695: PUSH
4696: LD_INT 5
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: LIST
4707: PUSH
4708: LD_INT 24
4710: PUSH
4711: LD_INT 1000
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: PPUSH
4726: CALL_OW 69
4730: PUSH
4731: LD_EXP 17
4735: DIFF
4736: ST_TO_ADDR
// for i = 1 to filter do
4737: LD_ADDR_VAR 0 2
4741: PUSH
4742: DOUBLE
4743: LD_INT 1
4745: DEC
4746: ST_TO_ADDR
4747: LD_VAR 0 4
4751: PUSH
4752: FOR_TO
4753: IFFALSE 4813
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4755: LD_VAR 0 4
4759: PUSH
4760: LD_VAR 0 2
4764: ARRAY
4765: PPUSH
4766: CALL_OW 310
4770: NOT
4771: PUSH
4772: LD_VAR 0 4
4776: PUSH
4777: LD_VAR 0 2
4781: ARRAY
4782: PPUSH
4783: CALL_OW 314
4787: NOT
4788: AND
4789: IFFALSE 4811
// ComEnterUnit ( filter [ i ] , place ) ;
4791: LD_VAR 0 4
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PPUSH
4802: LD_VAR 0 7
4806: PPUSH
4807: CALL_OW 120
4811: GO 4752
4813: POP
4814: POP
// end ; end ; if event = 5 then
4815: LD_VAR 0 1
4819: PUSH
4820: LD_INT 5
4822: EQUAL
4823: IFFALSE 4977
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4825: LD_INT 12
4827: PPUSH
4828: LD_INT 81
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PPUSH
4838: CALL_OW 70
4842: PUSH
4843: LD_INT 0
4845: EQUAL
4846: IFFALSE 4977
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4848: LD_ADDR_VAR 0 8
4852: PUSH
4853: LD_INT 22
4855: PUSH
4856: LD_INT 1
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: PUSH
4863: LD_INT 25
4865: PUSH
4866: LD_INT 2
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: EMPTY
4874: LIST
4875: LIST
4876: PPUSH
4877: CALL_OW 69
4881: ST_TO_ADDR
// if engs > 0 then
4882: LD_VAR 0 8
4886: PUSH
4887: LD_INT 0
4889: GREATER
4890: IFFALSE 4977
// for i = 1 to engs do
4892: LD_ADDR_VAR 0 2
4896: PUSH
4897: DOUBLE
4898: LD_INT 1
4900: DEC
4901: ST_TO_ADDR
4902: LD_VAR 0 8
4906: PUSH
4907: FOR_TO
4908: IFFALSE 4975
// if not HasTask ( engs [ i ] ) then
4910: LD_VAR 0 8
4914: PUSH
4915: LD_VAR 0 2
4919: ARRAY
4920: PPUSH
4921: CALL_OW 314
4925: NOT
4926: IFFALSE 4973
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4928: LD_VAR 0 8
4932: PUSH
4933: LD_VAR 0 2
4937: ARRAY
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 1
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 2
4958: ARRAY
4959: PPUSH
4960: LD_EXP 18
4964: PUSH
4965: LD_INT 3
4967: ARRAY
4968: PPUSH
4969: CALL_OW 145
4973: GO 4907
4975: POP
4976: POP
// end ; end ; if event = 6 then
4977: LD_VAR 0 1
4981: PUSH
4982: LD_INT 6
4984: EQUAL
4985: IFFALSE 5169
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4987: LD_ADDR_VAR 0 6
4991: PUSH
4992: LD_INT 22
4994: PUSH
4995: LD_INT 1
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: PUSH
5002: LD_INT 30
5004: PUSH
5005: LD_INT 5
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: PUSH
5012: EMPTY
5013: LIST
5014: LIST
5015: PPUSH
5016: CALL_OW 69
5020: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5021: LD_VAR 0 6
5025: PUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 1
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 30
5038: PUSH
5039: LD_INT 32
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 58
5048: PUSH
5049: EMPTY
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PUSH
5065: LD_INT 0
5067: GREATER
5068: AND
5069: IFFALSE 5169
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5071: LD_ADDR_VAR 0 10
5075: PUSH
5076: LD_INT 22
5078: PUSH
5079: LD_INT 1
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: PUSH
5086: LD_INT 30
5088: PUSH
5089: LD_INT 32
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: PUSH
5096: LD_INT 58
5098: PUSH
5099: EMPTY
5100: LIST
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: LIST
5106: PUSH
5107: EMPTY
5108: LIST
5109: PPUSH
5110: CALL_OW 69
5114: PUSH
5115: LD_INT 1
5117: ARRAY
5118: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5119: LD_ADDR_VAR 0 3
5123: PUSH
5124: LD_VAR 0 6
5128: PUSH
5129: LD_INT 1
5131: ARRAY
5132: PPUSH
5133: CALL_OW 313
5137: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5138: LD_VAR 0 3
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5151: LD_VAR 0 3
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PPUSH
5160: LD_VAR 0 10
5164: PPUSH
5165: CALL_OW 180
// end ; end ; end ;
5169: PPOPN 10
5171: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5172: LD_VAR 0 1
5176: PUSH
5177: LD_INT 1
5179: EQUAL
5180: PUSH
5181: LD_VAR 0 2
5185: PUSH
5186: LD_INT 3
5188: EQUAL
5189: AND
5190: IFFALSE 5200
// contact_am := true ;
5192: LD_ADDR_EXP 16
5196: PUSH
5197: LD_INT 1
5199: ST_TO_ADDR
// end ;
5200: PPOPN 2
5202: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5203: LD_VAR 0 1
5207: PPUSH
5208: LD_VAR 0 2
5212: PPUSH
5213: LD_VAR 0 3
5217: PPUSH
5218: CALL 20419 0 3
// end ;
5222: PPOPN 3
5224: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5225: LD_VAR 0 1
5229: PPUSH
5230: CALL 20427 0 1
// end ; end_of_file
5234: PPOPN 1
5236: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5237: LD_INT 0
5239: PPUSH
5240: PPUSH
5241: PPUSH
5242: PPUSH
5243: PPUSH
5244: PPUSH
5245: PPUSH
5246: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5247: LD_ADDR_VAR 0 5
5251: PUSH
5252: LD_INT 5
5254: PUSH
5255: LD_INT 6
5257: PUSH
5258: LD_INT 7
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: PUSH
5266: LD_EXP 1
5270: ARRAY
5271: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5272: LD_ADDR_VAR 0 6
5276: PUSH
5277: LD_INT 4
5279: PUSH
5280: LD_INT 4
5282: PUSH
5283: LD_INT 4
5285: PUSH
5286: LD_INT 5
5288: PUSH
5289: LD_INT 5
5291: PUSH
5292: LD_INT 5
5294: PUSH
5295: LD_INT 6
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: ST_TO_ADDR
// SForce := [ ] ;
5307: LD_ADDR_EXP 11
5311: PUSH
5312: EMPTY
5313: ST_TO_ADDR
// Sikorski_Ar := false ;
5314: LD_ADDR_EXP 12
5318: PUSH
5319: LD_INT 0
5321: ST_TO_ADDR
// attacked := false ;
5322: LD_ADDR_EXP 15
5326: PUSH
5327: LD_INT 0
5329: ST_TO_ADDR
// contact_am := false ;
5330: LD_ADDR_EXP 16
5334: PUSH
5335: LD_INT 0
5337: ST_TO_ADDR
// patrol := [ ] ;
5338: LD_ADDR_EXP 17
5342: PUSH
5343: EMPTY
5344: ST_TO_ADDR
// gamma_towers := [ ] ;
5345: LD_ADDR_EXP 18
5349: PUSH
5350: EMPTY
5351: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5352: LD_INT 25
5354: PPUSH
5355: LD_STRING gamma
5357: PPUSH
5358: CALL_OW 500
// uc_side := 1 ;
5362: LD_ADDR_OWVAR 20
5366: PUSH
5367: LD_INT 1
5369: ST_TO_ADDR
// uc_nation := 1 ;
5370: LD_ADDR_OWVAR 21
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// hc_importance := 0 ;
5378: LD_ADDR_OWVAR 32
5382: PUSH
5383: LD_INT 0
5385: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5386: LD_ADDR_OWVAR 26
5390: PUSH
5391: LD_STRING Jeremy Sikorski
5393: ST_TO_ADDR
// hc_gallery := us ;
5394: LD_ADDR_OWVAR 33
5398: PUSH
5399: LD_STRING us
5401: ST_TO_ADDR
// hc_face_number := 19 ;
5402: LD_ADDR_OWVAR 34
5406: PUSH
5407: LD_INT 19
5409: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5410: LD_ADDR_OWVAR 31
5414: PUSH
5415: LD_VAR 0 5
5419: PPUSH
5420: LD_VAR 0 5
5424: PUSH
5425: LD_INT 2
5427: PLUS
5428: PPUSH
5429: CALL_OW 12
5433: PUSH
5434: LD_INT 4
5436: PUSH
5437: LD_INT 6
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: ST_TO_ADDR
// hc_sex := sex_male ;
5449: LD_ADDR_OWVAR 27
5453: PUSH
5454: LD_INT 1
5456: ST_TO_ADDR
// hc_class := 1 ;
5457: LD_ADDR_OWVAR 28
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5465: LD_ADDR_OWVAR 29
5469: PUSH
5470: LD_INT 10
5472: PUSH
5473: LD_INT 11
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: ST_TO_ADDR
// sikorski := CreateHuman ;
5480: LD_ADDR_EXP 9
5484: PUSH
5485: CALL_OW 44
5489: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5490: LD_ADDR_OWVAR 26
5494: PUSH
5495: LD_STRING Lucy Donaldson
5497: ST_TO_ADDR
// hc_gallery := us ;
5498: LD_ADDR_OWVAR 33
5502: PUSH
5503: LD_STRING us
5505: ST_TO_ADDR
// hc_face_number := 2 ;
5506: LD_ADDR_OWVAR 34
5510: PUSH
5511: LD_INT 2
5513: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5514: LD_ADDR_OWVAR 31
5518: PUSH
5519: LD_VAR 0 5
5523: PPUSH
5524: LD_VAR 0 5
5528: PUSH
5529: LD_INT 2
5531: PLUS
5532: PPUSH
5533: CALL_OW 12
5537: PUSH
5538: LD_INT 6
5540: PUSH
5541: LD_INT 4
5543: PUSH
5544: LD_INT 2
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: LIST
5552: ST_TO_ADDR
// hc_sex := sex_female ;
5553: LD_ADDR_OWVAR 27
5557: PUSH
5558: LD_INT 2
5560: ST_TO_ADDR
// hc_class := 1 ;
5561: LD_ADDR_OWVAR 28
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// donald := CreateHuman ;
5569: LD_ADDR_EXP 13
5573: PUSH
5574: CALL_OW 44
5578: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5579: LD_ADDR_OWVAR 26
5583: PUSH
5584: LD_STRING Peter Van Houten
5586: ST_TO_ADDR
// hc_gallery := us ;
5587: LD_ADDR_OWVAR 33
5591: PUSH
5592: LD_STRING us
5594: ST_TO_ADDR
// hc_face_number := 16 ;
5595: LD_ADDR_OWVAR 34
5599: PUSH
5600: LD_INT 16
5602: ST_TO_ADDR
// hc_sex := sex_male ;
5603: LD_ADDR_OWVAR 27
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// van := CreateHuman ;
5611: LD_ADDR_EXP 14
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// hc_importance := 0 ;
5621: LD_ADDR_OWVAR 32
5625: PUSH
5626: LD_INT 0
5628: ST_TO_ADDR
// case dif of 1 :
5629: LD_EXP 1
5633: PUSH
5634: LD_INT 1
5636: DOUBLE
5637: EQUAL
5638: IFTRUE 5642
5640: GO 5653
5642: POP
// lw = 1 ; 2 :
5643: LD_ADDR_VAR 0 8
5647: PUSH
5648: LD_INT 1
5650: ST_TO_ADDR
5651: GO 5700
5653: LD_INT 2
5655: DOUBLE
5656: EQUAL
5657: IFTRUE 5661
5659: GO 5680
5661: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5662: LD_ADDR_VAR 0 8
5666: PUSH
5667: LD_INT 1
5669: PPUSH
5670: LD_INT 2
5672: PPUSH
5673: CALL_OW 12
5677: ST_TO_ADDR
5678: GO 5700
5680: LD_INT 3
5682: DOUBLE
5683: EQUAL
5684: IFTRUE 5688
5686: GO 5699
5688: POP
// lw = 2 ; end ;
5689: LD_ADDR_VAR 0 8
5693: PUSH
5694: LD_INT 2
5696: ST_TO_ADDR
5697: GO 5700
5699: POP
// case lw of 1 :
5700: LD_VAR 0 8
5704: PUSH
5705: LD_INT 1
5707: DOUBLE
5708: EQUAL
5709: IFTRUE 5713
5711: GO 5728
5713: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5714: LD_EXP 13
5718: PPUSH
5719: LD_INT 25
5721: PPUSH
5722: CALL_OW 52
5726: GO 5752
5728: LD_INT 2
5730: DOUBLE
5731: EQUAL
5732: IFTRUE 5736
5734: GO 5751
5736: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5737: LD_EXP 14
5741: PPUSH
5742: LD_INT 25
5744: PPUSH
5745: CALL_OW 52
5749: GO 5752
5751: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5752: LD_ADDR_VAR 0 2
5756: PUSH
5757: LD_INT 22
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 30
5769: PUSH
5770: LD_INT 32
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PPUSH
5781: CALL_OW 69
5785: PUSH
5786: FOR_IN
5787: IFFALSE 5841
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5789: LD_INT 1
5791: PPUSH
5792: LD_VAR 0 5
5796: PPUSH
5797: CALL 734 0 2
5801: PPUSH
5802: LD_VAR 0 2
5806: PPUSH
5807: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5811: LD_VAR 0 2
5815: PPUSH
5816: LD_VAR 0 6
5820: PUSH
5821: LD_INT 1
5823: PPUSH
5824: LD_VAR 0 6
5828: PPUSH
5829: CALL_OW 12
5833: ARRAY
5834: PPUSH
5835: CALL_OW 431
// end ;
5839: GO 5786
5841: POP
5842: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5843: LD_ADDR_VAR 0 7
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 25
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: PUSH
5871: LD_INT 5
5873: PUSH
5874: EMPTY
5875: LIST
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PPUSH
5886: CALL_OW 69
5890: ST_TO_ADDR
// for i = 1 to sol do
5891: LD_ADDR_VAR 0 2
5895: PUSH
5896: DOUBLE
5897: LD_INT 1
5899: DEC
5900: ST_TO_ADDR
5901: LD_VAR 0 7
5905: PUSH
5906: FOR_TO
5907: IFFALSE 5929
// SetTag ( sol [ i ] , 1 ) ;
5909: LD_VAR 0 7
5913: PUSH
5914: LD_VAR 0 2
5918: ARRAY
5919: PPUSH
5920: LD_INT 1
5922: PPUSH
5923: CALL_OW 109
5927: GO 5906
5929: POP
5930: POP
// for i = 1 to 3 do
5931: LD_ADDR_VAR 0 2
5935: PUSH
5936: DOUBLE
5937: LD_INT 1
5939: DEC
5940: ST_TO_ADDR
5941: LD_INT 3
5943: PUSH
5944: FOR_TO
5945: IFFALSE 5969
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5947: LD_INT 3
5949: PPUSH
5950: LD_VAR 0 5
5954: PPUSH
5955: CALL 734 0 2
5959: PPUSH
5960: LD_INT 56
5962: PPUSH
5963: CALL_OW 52
5967: GO 5944
5969: POP
5970: POP
// for i = 1 to 6 do
5971: LD_ADDR_VAR 0 2
5975: PUSH
5976: DOUBLE
5977: LD_INT 1
5979: DEC
5980: ST_TO_ADDR
5981: LD_INT 6
5983: PUSH
5984: FOR_TO
5985: IFFALSE 6009
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5987: LD_INT 3
5989: PPUSH
5990: LD_VAR 0 5
5994: PPUSH
5995: CALL 734 0 2
5999: PPUSH
6000: LD_INT 26
6002: PPUSH
6003: CALL_OW 52
6007: GO 5984
6009: POP
6010: POP
// for i = 1 to 5 do
6011: LD_ADDR_VAR 0 2
6015: PUSH
6016: DOUBLE
6017: LD_INT 1
6019: DEC
6020: ST_TO_ADDR
6021: LD_INT 5
6023: PUSH
6024: FOR_TO
6025: IFFALSE 6052
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6027: LD_INT 2
6029: PPUSH
6030: LD_VAR 0 5
6034: PPUSH
6035: CALL 734 0 2
6039: PPUSH
6040: LD_INT 7
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 49
6050: GO 6024
6052: POP
6053: POP
// for i = 1 to 3 do
6054: LD_ADDR_VAR 0 2
6058: PUSH
6059: DOUBLE
6060: LD_INT 1
6062: DEC
6063: ST_TO_ADDR
6064: LD_INT 3
6066: PUSH
6067: FOR_TO
6068: IFFALSE 6092
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6070: LD_INT 4
6072: PPUSH
6073: LD_VAR 0 5
6077: PPUSH
6078: CALL 734 0 2
6082: PPUSH
6083: LD_INT 46
6085: PPUSH
6086: CALL_OW 52
6090: GO 6067
6092: POP
6093: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6094: LD_ADDR_VAR 0 2
6098: PUSH
6099: LD_INT 22
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 30
6111: PUSH
6112: LD_INT 5
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 69
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6243
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6131: LD_INT 5
6133: PPUSH
6134: LD_VAR 0 5
6138: PPUSH
6139: CALL 734 0 2
6143: PPUSH
6144: LD_VAR 0 2
6148: PPUSH
6149: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6153: LD_INT 5
6155: PPUSH
6156: LD_VAR 0 5
6160: PPUSH
6161: CALL 734 0 2
6165: PPUSH
6166: LD_VAR 0 2
6170: PPUSH
6171: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 5
6182: PPUSH
6183: CALL 734 0 2
6187: PPUSH
6188: LD_VAR 0 2
6192: PPUSH
6193: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6197: LD_INT 1
6199: PPUSH
6200: LD_VAR 0 5
6204: PPUSH
6205: CALL 734 0 2
6209: PPUSH
6210: LD_VAR 0 2
6214: PPUSH
6215: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6219: LD_INT 1
6221: PPUSH
6222: LD_VAR 0 5
6226: PPUSH
6227: CALL 734 0 2
6231: PPUSH
6232: LD_VAR 0 2
6236: PPUSH
6237: CALL_OW 52
// end ;
6241: GO 6128
6243: POP
6244: POP
// if dif > 1 then
6245: LD_EXP 1
6249: PUSH
6250: LD_INT 1
6252: GREATER
6253: IFFALSE 6326
// for i = 1 to ( dif - 1 ) do
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: DOUBLE
6261: LD_INT 1
6263: DEC
6264: ST_TO_ADDR
6265: LD_EXP 1
6269: PUSH
6270: LD_INT 1
6272: MINUS
6273: PUSH
6274: FOR_TO
6275: IFFALSE 6324
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6277: LD_ADDR_EXP 17
6281: PUSH
6282: LD_EXP 17
6286: PUSH
6287: LD_INT 1
6289: PPUSH
6290: LD_VAR 0 5
6294: PPUSH
6295: CALL 734 0 2
6299: ADD
6300: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6301: LD_EXP 17
6305: PUSH
6306: LD_VAR 0 2
6310: ARRAY
6311: PPUSH
6312: LD_INT 3
6314: PPUSH
6315: LD_INT 0
6317: PPUSH
6318: CALL_OW 49
// end ;
6322: GO 6274
6324: POP
6325: POP
// game_started := true ;
6326: LD_ADDR_EXP 10
6330: PUSH
6331: LD_INT 1
6333: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6334: LD_INT 26
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_INT 2
6342: PPUSH
6343: LD_INT 2
6345: PPUSH
6346: LD_INT 13
6348: PPUSH
6349: CALL_OW 125
// while ( contact_am = false ) do
6353: LD_EXP 16
6357: PUSH
6358: LD_INT 0
6360: EQUAL
6361: IFFALSE 6372
// begin Wait ( 0 0$01 ) ;
6363: LD_INT 35
6365: PPUSH
6366: CALL_OW 67
// end ;
6370: GO 6353
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6372: LD_INT 8400
6374: PUSH
6375: LD_INT 6300
6377: PUSH
6378: LD_INT 5250
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: LIST
6385: PUSH
6386: LD_EXP 1
6390: ARRAY
6391: PPUSH
6392: CALL_OW 67
// case dif of 1 :
6396: LD_EXP 1
6400: PUSH
6401: LD_INT 1
6403: DOUBLE
6404: EQUAL
6405: IFTRUE 6409
6407: GO 6584
6409: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6410: LD_INT 26
6412: PPUSH
6413: LD_INT 3
6415: PPUSH
6416: LD_INT 1
6418: PPUSH
6419: LD_INT 2
6421: PPUSH
6422: LD_INT 2
6424: PUSH
6425: LD_INT 4
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 5
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 1
6442: PPUSH
6443: LD_INT 4
6445: PPUSH
6446: CALL_OW 12
6450: ARRAY
6451: PPUSH
6452: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6456: LD_INT 26
6458: PPUSH
6459: LD_INT 3
6461: PPUSH
6462: LD_INT 1
6464: PPUSH
6465: LD_INT 2
6467: PPUSH
6468: LD_INT 4
6470: PUSH
6471: LD_INT 5
6473: PUSH
6474: LD_INT 5
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 1
6484: PPUSH
6485: LD_INT 3
6487: PPUSH
6488: CALL_OW 12
6492: ARRAY
6493: PPUSH
6494: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6498: LD_INT 26
6500: PPUSH
6501: LD_INT 3
6503: PPUSH
6504: LD_INT 1
6506: PPUSH
6507: LD_INT 2
6509: PPUSH
6510: LD_INT 4
6512: PUSH
6513: LD_INT 5
6515: PUSH
6516: LD_INT 5
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 1
6526: PPUSH
6527: LD_INT 3
6529: PPUSH
6530: CALL_OW 12
6534: ARRAY
6535: PPUSH
6536: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6540: LD_INT 26
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 1
6548: PPUSH
6549: LD_INT 2
6551: PPUSH
6552: LD_INT 4
6554: PUSH
6555: LD_INT 3
6557: PUSH
6558: LD_INT 5
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 1
6568: PPUSH
6569: LD_INT 3
6571: PPUSH
6572: CALL_OW 12
6576: ARRAY
6577: PPUSH
6578: CALL_OW 185
// end ; 2 :
6582: GO 7111
6584: LD_INT 2
6586: DOUBLE
6587: EQUAL
6588: IFTRUE 6592
6590: GO 6805
6592: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6593: LD_INT 26
6595: PPUSH
6596: LD_INT 3
6598: PPUSH
6599: LD_INT 1
6601: PPUSH
6602: LD_INT 2
6604: PPUSH
6605: LD_INT 4
6607: PUSH
6608: LD_INT 5
6610: PUSH
6611: LD_INT 5
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_INT 1
6621: PPUSH
6622: LD_INT 3
6624: PPUSH
6625: CALL_OW 12
6629: ARRAY
6630: PPUSH
6631: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6635: LD_INT 26
6637: PPUSH
6638: LD_INT 3
6640: PPUSH
6641: LD_INT 1
6643: PPUSH
6644: LD_INT 2
6646: PPUSH
6647: LD_INT 4
6649: PUSH
6650: LD_INT 5
6652: PUSH
6653: LD_INT 5
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_INT 1
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: CALL_OW 12
6671: ARRAY
6672: PPUSH
6673: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6677: LD_INT 26
6679: PPUSH
6680: LD_INT 3
6682: PPUSH
6683: LD_INT 1
6685: PPUSH
6686: LD_INT 2
6688: PPUSH
6689: LD_INT 4
6691: PUSH
6692: LD_INT 3
6694: PUSH
6695: LD_INT 5
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 1
6705: PPUSH
6706: LD_INT 3
6708: PPUSH
6709: CALL_OW 12
6713: ARRAY
6714: PPUSH
6715: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6719: LD_INT 26
6721: PPUSH
6722: LD_INT 4
6724: PPUSH
6725: LD_INT 1
6727: PPUSH
6728: LD_INT 2
6730: PPUSH
6731: LD_INT 4
6733: PUSH
6734: LD_INT 5
6736: PUSH
6737: LD_INT 6
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: PUSH
6745: LD_INT 1
6747: PPUSH
6748: LD_INT 3
6750: PPUSH
6751: CALL_OW 12
6755: ARRAY
6756: PPUSH
6757: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6761: LD_INT 26
6763: PPUSH
6764: LD_INT 4
6766: PPUSH
6767: LD_INT 1
6769: PPUSH
6770: LD_INT 2
6772: PPUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: LD_INT 6
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_INT 3
6792: PPUSH
6793: CALL_OW 12
6797: ARRAY
6798: PPUSH
6799: CALL_OW 185
// end ; 3 :
6803: GO 7111
6805: LD_INT 3
6807: DOUBLE
6808: EQUAL
6809: IFTRUE 6813
6811: GO 7110
6813: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6814: LD_INT 26
6816: PPUSH
6817: LD_INT 3
6819: PPUSH
6820: LD_INT 1
6822: PPUSH
6823: LD_INT 2
6825: PPUSH
6826: LD_INT 4
6828: PUSH
6829: LD_INT 5
6831: PUSH
6832: LD_INT 5
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 1
6842: PPUSH
6843: LD_INT 3
6845: PPUSH
6846: CALL_OW 12
6850: ARRAY
6851: PPUSH
6852: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6856: LD_INT 26
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: LD_INT 2
6867: PPUSH
6868: LD_INT 4
6870: PUSH
6871: LD_INT 5
6873: PUSH
6874: LD_INT 5
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 1
6884: PPUSH
6885: LD_INT 3
6887: PPUSH
6888: CALL_OW 12
6892: ARRAY
6893: PPUSH
6894: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6898: LD_INT 26
6900: PPUSH
6901: LD_INT 3
6903: PPUSH
6904: LD_INT 1
6906: PPUSH
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PUSH
6913: LD_INT 5
6915: PUSH
6916: LD_INT 5
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 1
6926: PPUSH
6927: LD_INT 3
6929: PPUSH
6930: CALL_OW 12
6934: ARRAY
6935: PPUSH
6936: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6940: LD_INT 26
6942: PPUSH
6943: LD_INT 3
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: LD_INT 2
6951: PPUSH
6952: LD_INT 4
6954: PUSH
6955: LD_INT 5
6957: PUSH
6958: LD_INT 5
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: LD_INT 3
6971: PPUSH
6972: CALL_OW 12
6976: ARRAY
6977: PPUSH
6978: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6982: LD_INT 26
6984: PPUSH
6985: LD_INT 4
6987: PPUSH
6988: LD_INT 1
6990: PPUSH
6991: LD_INT 2
6993: PPUSH
6994: LD_INT 4
6996: PUSH
6997: LD_INT 5
6999: PUSH
7000: LD_INT 6
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: LD_INT 1
7010: PPUSH
7011: LD_INT 3
7013: PPUSH
7014: CALL_OW 12
7018: ARRAY
7019: PPUSH
7020: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7024: LD_INT 26
7026: PPUSH
7027: LD_INT 4
7029: PPUSH
7030: LD_INT 1
7032: PPUSH
7033: LD_INT 2
7035: PPUSH
7036: LD_INT 4
7038: PUSH
7039: LD_INT 5
7041: PUSH
7042: LD_INT 6
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_INT 3
7055: PPUSH
7056: CALL_OW 12
7060: ARRAY
7061: PPUSH
7062: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7066: LD_INT 26
7068: PPUSH
7069: LD_INT 4
7071: PPUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 2
7077: PPUSH
7078: LD_INT 4
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 6
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 1
7094: PPUSH
7095: LD_INT 3
7097: PPUSH
7098: CALL_OW 12
7102: ARRAY
7103: PPUSH
7104: CALL_OW 185
// end ; end ;
7108: GO 7111
7110: POP
// end ;
7111: LD_VAR 0 1
7115: RET
// every 0 0$01 do var i , filter ;
7116: GO 7118
7118: DISABLE
7119: LD_INT 0
7121: PPUSH
7122: PPUSH
// begin enable ;
7123: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7124: LD_INT 22
7126: PUSH
7127: LD_INT 1
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 25
7136: PUSH
7137: LD_INT 4
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: PUSH
7153: LD_INT 0
7155: GREATER
7156: IFFALSE 7165
// RaiseSailEvent ( 3 ) ;
7158: LD_INT 3
7160: PPUSH
7161: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7165: LD_INT 22
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 21
7177: PUSH
7178: LD_INT 3
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PUSH
7185: LD_INT 3
7187: PUSH
7188: LD_INT 24
7190: PUSH
7191: LD_INT 1000
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: PPUSH
7207: CALL_OW 69
7211: PUSH
7212: LD_INT 0
7214: GREATER
7215: IFFALSE 7226
// RaiseSailEvent ( 1 ) else
7217: LD_INT 1
7219: PPUSH
7220: CALL_OW 427
7224: GO 7233
// RaiseSailEvent ( 2 ) ;
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7233: LD_INT 22
7235: PUSH
7236: LD_INT 1
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 30
7245: PUSH
7246: LD_INT 5
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 69
7261: PUSH
7262: LD_INT 0
7264: GREATER
7265: IFFALSE 7274
// RaiseSailEvent ( 4 ) ;
7267: LD_INT 4
7269: PPUSH
7270: CALL_OW 427
// if gamma_towers > 0 then
7274: LD_EXP 18
7278: PUSH
7279: LD_INT 0
7281: GREATER
7282: IFFALSE 7291
// RaiseSailEvent ( 5 ) ;
7284: LD_INT 5
7286: PPUSH
7287: CALL_OW 427
// end ;
7291: PPOPN 2
7293: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7294: GO 7296
7296: DISABLE
7297: LD_INT 0
7299: PPUSH
7300: PPUSH
// begin enable ;
7301: ENABLE
// if new_veh > 0 then
7302: LD_EXP 19
7306: PUSH
7307: LD_INT 0
7309: GREATER
7310: IFFALSE 7497
// while ( new_veh > 0 ) do
7312: LD_EXP 19
7316: PUSH
7317: LD_INT 0
7319: GREATER
7320: IFFALSE 7497
// begin Wait ( 0 0$01 ) ;
7322: LD_INT 35
7324: PPUSH
7325: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7329: LD_INT 26
7331: PPUSH
7332: CALL_OW 461
7336: PUSH
7337: LD_INT 2
7339: EQUAL
7340: IFFALSE 7495
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7342: LD_ADDR_VAR 0 1
7346: PUSH
7347: LD_INT 2
7349: PUSH
7350: LD_INT 3
7352: PUSH
7353: LD_INT 3
7355: PUSH
7356: LD_INT 4
7358: PUSH
7359: EMPTY
7360: LIST
7361: LIST
7362: LIST
7363: LIST
7364: PUSH
7365: LD_INT 1
7367: PPUSH
7368: LD_INT 4
7370: PPUSH
7371: CALL_OW 12
7375: ARRAY
7376: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7377: LD_VAR 0 1
7381: PUSH
7382: LD_INT 2
7384: PUSH
7385: LD_INT 3
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: IN
7392: IFFALSE 7427
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7394: LD_ADDR_VAR 0 2
7398: PUSH
7399: LD_INT 4
7401: PUSH
7402: LD_INT 5
7404: PUSH
7405: LD_INT 7
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_INT 3
7418: PPUSH
7419: CALL_OW 12
7423: ARRAY
7424: ST_TO_ADDR
7425: GO 7458
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7427: LD_ADDR_VAR 0 2
7431: PUSH
7432: LD_INT 5
7434: PUSH
7435: LD_INT 7
7437: PUSH
7438: LD_INT 6
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PUSH
7446: LD_INT 1
7448: PPUSH
7449: LD_INT 3
7451: PPUSH
7452: CALL_OW 12
7456: ARRAY
7457: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7458: LD_INT 26
7460: PPUSH
7461: LD_VAR 0 1
7465: PPUSH
7466: LD_INT 1
7468: PPUSH
7469: LD_INT 2
7471: PPUSH
7472: LD_VAR 0 2
7476: PPUSH
7477: CALL_OW 125
// new_veh := new_veh - 1 ;
7481: LD_ADDR_EXP 19
7485: PUSH
7486: LD_EXP 19
7490: PUSH
7491: LD_INT 1
7493: MINUS
7494: ST_TO_ADDR
// end ; end ;
7495: GO 7312
// end ;
7497: PPOPN 2
7499: END
// every 0 0$01 do var v , filter , am_cmeh ;
7500: GO 7502
7502: DISABLE
7503: LD_INT 0
7505: PPUSH
7506: PPUSH
7507: PPUSH
// begin enable ;
7508: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7509: LD_ADDR_VAR 0 3
7513: PUSH
7514: LD_INT 56
7516: PPUSH
7517: CALL_OW 313
7521: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 33
7539: PUSH
7540: LD_INT 2
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: LD_INT 50
7549: PUSH
7550: EMPTY
7551: LIST
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: ST_TO_ADDR
// if filter > 0 then
7566: LD_VAR 0 2
7570: PUSH
7571: LD_INT 0
7573: GREATER
7574: IFFALSE 7642
// begin for v in filter do
7576: LD_ADDR_VAR 0 1
7580: PUSH
7581: LD_VAR 0 2
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7640
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7589: LD_VAR 0 1
7593: PPUSH
7594: CALL_OW 312
7598: NOT
7599: PUSH
7600: LD_VAR 0 1
7604: PPUSH
7605: CALL_OW 302
7609: AND
7610: IFFALSE 7638
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7612: LD_VAR 0 1
7616: PPUSH
7617: LD_VAR 0 3
7621: PUSH
7622: LD_INT 1
7624: PPUSH
7625: LD_INT 3
7627: PPUSH
7628: CALL_OW 12
7632: ARRAY
7633: PPUSH
7634: CALL_OW 135
// end ;
7638: GO 7586
7640: POP
7641: POP
// end ; end ;
7642: PPOPN 3
7644: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7645: LD_INT 33
7647: PUSH
7648: LD_INT 2
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 13
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 69
7680: PUSH
7681: LD_INT 4
7683: PUSH
7684: LD_INT 5
7686: PUSH
7687: LD_INT 7
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: PUSH
7695: LD_EXP 1
7699: ARRAY
7700: EQUAL
7701: PUSH
7702: LD_INT 26
7704: PPUSH
7705: CALL_OW 461
7709: PUSH
7710: LD_INT 2
7712: EQUAL
7713: AND
7714: IFFALSE 7925
7716: GO 7718
7718: DISABLE
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
// begin enable ;
7724: ENABLE
// if Sikorski_Ar then
7725: LD_EXP 12
7729: IFFALSE 7806
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7731: LD_ADDR_EXP 11
7735: PUSH
7736: LD_INT 2
7738: PUSH
7739: LD_INT 22
7741: PUSH
7742: LD_INT 4
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 22
7751: PUSH
7752: LD_INT 1
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 33
7761: PUSH
7762: LD_INT 2
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 3
7771: PUSH
7772: LD_INT 34
7774: PUSH
7775: LD_INT 13
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: LIST
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: PPUSH
7799: CALL_OW 69
7803: ST_TO_ADDR
7804: GO 7847
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7806: LD_ADDR_EXP 11
7810: PUSH
7811: LD_INT 33
7813: PUSH
7814: LD_INT 2
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 3
7823: PUSH
7824: LD_INT 34
7826: PUSH
7827: LD_INT 13
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 69
7846: ST_TO_ADDR
// repeat begin for un in SForce do
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_EXP 11
7856: PUSH
7857: FOR_IN
7858: IFFALSE 7913
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7860: LD_ADDR_VAR 0 3
7864: PUSH
7865: LD_INT 22
7867: PUSH
7868: LD_INT 3
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: PPUSH
7875: CALL_OW 69
7879: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_VAR 0 3
7889: PPUSH
7890: LD_VAR 0 2
7894: PPUSH
7895: CALL_OW 74
7899: PPUSH
7900: CALL_OW 115
// Wait ( 0 0$01 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// end ;
7911: GO 7857
7913: POP
7914: POP
// end until SForce = 0 ;
7915: LD_EXP 11
7919: PUSH
7920: LD_INT 0
7922: EQUAL
7923: IFFALSE 7847
// end ;
7925: PPOPN 3
7927: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7928: LD_INT 0
7930: PPUSH
7931: PPUSH
7932: PPUSH
7933: PPUSH
7934: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7935: LD_ADDR_VAR 0 6
7939: PUSH
7940: LD_INT 14
7942: PPUSH
7943: EMPTY
7944: PPUSH
7945: CALL_OW 70
7949: ST_TO_ADDR
// if tmp then
7950: LD_VAR 0 6
7954: IFFALSE 7988
// for i in tmp do
7956: LD_ADDR_VAR 0 3
7960: PUSH
7961: LD_VAR 0 6
7965: PUSH
7966: FOR_IN
7967: IFFALSE 7986
// ComMoveXY ( i , 42 , 23 ) ;
7969: LD_VAR 0 3
7973: PPUSH
7974: LD_INT 42
7976: PPUSH
7977: LD_INT 23
7979: PPUSH
7980: CALL_OW 111
7984: GO 7966
7986: POP
7987: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7988: LD_INT 14
7990: PPUSH
7991: LD_INT 1
7993: PPUSH
7994: CALL_OW 286
// uc_side := 4 ;
7998: LD_ADDR_OWVAR 20
8002: PUSH
8003: LD_INT 4
8005: ST_TO_ADDR
// uc_nation := 1 ;
8006: LD_ADDR_OWVAR 21
8010: PUSH
8011: LD_INT 1
8013: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8014: LD_ADDR_OWVAR 37
8018: PUSH
8019: LD_INT 4
8021: ST_TO_ADDR
// vc_control := control_manual ;
8022: LD_ADDR_OWVAR 38
8026: PUSH
8027: LD_INT 1
8029: ST_TO_ADDR
// vc_engine := engine_combustion ;
8030: LD_ADDR_OWVAR 39
8034: PUSH
8035: LD_INT 1
8037: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8038: LD_ADDR_OWVAR 40
8042: PUSH
8043: LD_INT 4
8045: PUSH
8046: LD_INT 5
8048: PUSH
8049: LD_INT 7
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: LIST
8056: PUSH
8057: LD_EXP 1
8061: ARRAY
8062: ST_TO_ADDR
// veh := CreateVehicle ;
8063: LD_ADDR_VAR 0 5
8067: PUSH
8068: CALL_OW 45
8072: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8073: LD_VAR 0 5
8077: PPUSH
8078: LD_INT 2
8080: PPUSH
8081: LD_INT 0
8083: PPUSH
8084: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8088: LD_EXP 9
8092: PPUSH
8093: LD_VAR 0 5
8097: PPUSH
8098: CALL_OW 52
// SetMark ( veh , 1 ) ;
8102: LD_VAR 0 5
8106: PPUSH
8107: LD_INT 1
8109: PPUSH
8110: CALL_OW 242
// while ( num > 0 ) do
8114: LD_VAR 0 1
8118: PUSH
8119: LD_INT 0
8121: GREATER
8122: IFFALSE 8289
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8124: LD_INT 3
8126: PUSH
8127: LD_INT 3
8129: PUSH
8130: LD_INT 3
8132: PUSH
8133: LD_INT 4
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: LIST
8141: PUSH
8142: LD_EXP 1
8146: PPUSH
8147: LD_INT 4
8149: PPUSH
8150: CALL_OW 12
8154: ARRAY
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 4
8161: PUSH
8162: LD_INT 5
8164: PUSH
8165: LD_INT 5
8167: PUSH
8168: LD_INT 7
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 1
8179: PPUSH
8180: LD_EXP 1
8184: PUSH
8185: LD_INT 1
8187: PLUS
8188: PPUSH
8189: CALL_OW 12
8193: ARRAY
8194: PPUSH
8195: LD_INT 11
8197: PPUSH
8198: LD_INT 2
8200: PPUSH
8201: LD_INT 5
8203: PUSH
8204: LD_INT 6
8206: PUSH
8207: LD_INT 7
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: LIST
8214: PUSH
8215: LD_EXP 1
8219: ARRAY
8220: PPUSH
8221: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8225: LD_ADDR_VAR 0 4
8229: PUSH
8230: LD_INT 22
8232: PUSH
8233: LD_INT 4
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PPUSH
8240: CALL_OW 69
8244: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8245: LD_VAR 0 4
8249: PUSH
8250: LD_VAR 0 4
8254: ARRAY
8255: PPUSH
8256: LD_INT 36
8258: PPUSH
8259: LD_INT 18
8261: PPUSH
8262: CALL_OW 111
// Wait ( 0 0$02 ) ;
8266: LD_INT 70
8268: PPUSH
8269: CALL_OW 67
// num := num - 1 ;
8273: LD_ADDR_VAR 0 1
8277: PUSH
8278: LD_VAR 0 1
8282: PUSH
8283: LD_INT 1
8285: MINUS
8286: ST_TO_ADDR
// end ;
8287: GO 8114
// end ;
8289: LD_VAR 0 2
8293: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8294: LD_EXP 17
8298: PUSH
8299: LD_INT 0
8301: GREATER
8302: IFFALSE 8571
8304: GO 8306
8306: DISABLE
8307: LD_INT 0
8309: PPUSH
// begin enable ;
8310: ENABLE
// for i = 1 to patrol do
8311: LD_ADDR_VAR 0 1
8315: PUSH
8316: DOUBLE
8317: LD_INT 1
8319: DEC
8320: ST_TO_ADDR
8321: LD_EXP 17
8325: PUSH
8326: FOR_TO
8327: IFFALSE 8569
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8329: LD_EXP 17
8333: PUSH
8334: LD_VAR 0 1
8338: ARRAY
8339: PUSH
8340: LD_EXP 17
8344: PUSH
8345: LD_VAR 0 1
8349: ARRAY
8350: PPUSH
8351: CALL_OW 300
8355: AND
8356: PUSH
8357: LD_EXP 17
8361: PUSH
8362: LD_VAR 0 1
8366: ARRAY
8367: PPUSH
8368: CALL_OW 314
8372: NOT
8373: AND
8374: IFFALSE 8524
// case i of 1 :
8376: LD_VAR 0 1
8380: PUSH
8381: LD_INT 1
8383: DOUBLE
8384: EQUAL
8385: IFTRUE 8389
8387: GO 8452
8389: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8390: LD_EXP 17
8394: PUSH
8395: LD_VAR 0 1
8399: ARRAY
8400: PPUSH
8401: LD_INT 53
8403: PPUSH
8404: LD_INT 91
8406: PPUSH
8407: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8411: LD_EXP 17
8415: PUSH
8416: LD_VAR 0 1
8420: ARRAY
8421: PPUSH
8422: LD_INT 245
8424: PPUSH
8425: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8429: LD_EXP 17
8433: PUSH
8434: LD_VAR 0 1
8438: ARRAY
8439: PPUSH
8440: LD_INT 24
8442: PPUSH
8443: LD_INT 26
8445: PPUSH
8446: CALL_OW 171
// end ; 2 :
8450: GO 8524
8452: LD_INT 2
8454: DOUBLE
8455: EQUAL
8456: IFTRUE 8460
8458: GO 8523
8460: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8461: LD_EXP 17
8465: PUSH
8466: LD_VAR 0 1
8470: ARRAY
8471: PPUSH
8472: LD_INT 83
8474: PPUSH
8475: LD_INT 57
8477: PPUSH
8478: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8482: LD_EXP 17
8486: PUSH
8487: LD_VAR 0 1
8491: ARRAY
8492: PPUSH
8493: LD_INT 245
8495: PPUSH
8496: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8500: LD_EXP 17
8504: PUSH
8505: LD_VAR 0 1
8509: ARRAY
8510: PPUSH
8511: LD_INT 47
8513: PPUSH
8514: LD_INT 53
8516: PPUSH
8517: CALL_OW 171
// end ; end ;
8521: GO 8524
8523: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8524: LD_EXP 17
8528: PUSH
8529: LD_VAR 0 1
8533: ARRAY
8534: PPUSH
8535: CALL_OW 256
8539: PUSH
8540: LD_INT 1000
8542: LESS
8543: IFFALSE 8567
// patrol := patrol diff patrol [ i ] ;
8545: LD_ADDR_EXP 17
8549: PUSH
8550: LD_EXP 17
8554: PUSH
8555: LD_EXP 17
8559: PUSH
8560: LD_VAR 0 1
8564: ARRAY
8565: DIFF
8566: ST_TO_ADDR
// end ;
8567: GO 8326
8569: POP
8570: POP
// end ;
8571: PPOPN 1
8573: END
// every 0 0$10 do
8574: GO 8576
8576: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8577: LD_INT 42000
8579: PUSH
8580: LD_INT 37800
8582: PUSH
8583: LD_INT 33600
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_EXP 1
8595: ARRAY
8596: PPUSH
8597: CALL_OW 67
// if not contact_am then
8601: LD_EXP 16
8605: NOT
8606: IFFALSE 8616
// contact_am := true ;
8608: LD_ADDR_EXP 16
8612: PUSH
8613: LD_INT 1
8615: ST_TO_ADDR
// end ; end_of_file
8616: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8617: LD_INT 0
8619: PPUSH
// comp_tested := false ;
8620: LD_ADDR_EXP 22
8624: PUSH
8625: LD_INT 0
8627: ST_TO_ADDR
// sikorski_run := false ;
8628: LD_ADDR_EXP 23
8632: PUSH
8633: LD_INT 0
8635: ST_TO_ADDR
// InGameOn ;
8636: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8640: LD_EXP 3
8644: PPUSH
8645: CALL_OW 87
// Wait ( 0 0$01 ) ;
8649: LD_INT 35
8651: PPUSH
8652: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8656: LD_EXP 2
8660: PPUSH
8661: LD_STRING Dpop1
8663: PPUSH
8664: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8668: LD_EXP 3
8672: PPUSH
8673: LD_STRING Dcomm1
8675: PPUSH
8676: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8680: LD_EXP 2
8684: PPUSH
8685: LD_STRING Dpop2
8687: PPUSH
8688: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8692: LD_EXP 3
8696: PPUSH
8697: LD_STRING Dcomm2
8699: PPUSH
8700: CALL_OW 88
// InGameOff ;
8704: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8708: LD_STRING T1
8710: PPUSH
8711: CALL_OW 337
// end ;
8715: LD_VAR 0 1
8719: RET
// every 0 0$01 trigger timer > 2 2$01 do
8720: LD_EXP 24
8724: PUSH
8725: LD_INT 4235
8727: GREATER
8728: IFFALSE 8745
8730: GO 8732
8732: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8733: LD_EXP 5
8737: PPUSH
8738: LD_STRING DKap1
8740: PPUSH
8741: CALL_OW 94
// end ;
8745: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8746: LD_EXP 24
8750: PUSH
8751: LD_INT 46200
8753: PUSH
8754: LD_INT 52500
8756: PUSH
8757: LD_INT 63000
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: LIST
8764: PUSH
8765: LD_EXP 1
8769: ARRAY
8770: GREATER
8771: IFFALSE 9138
8773: GO 8775
8775: DISABLE
8776: LD_INT 0
8778: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8779: LD_EXP 5
8783: PPUSH
8784: LD_STRING DKap2
8786: PPUSH
8787: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8791: LD_INT 10
8793: PPUSH
8794: CALL_OW 67
// Say ( commander , Dcommk ) ;
8798: LD_EXP 3
8802: PPUSH
8803: LD_STRING Dcommk
8805: PPUSH
8806: CALL_OW 88
// Wait ( 0 0$44 ) ;
8810: LD_INT 1540
8812: PPUSH
8813: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8817: LD_EXP 5
8821: PPUSH
8822: LD_INT 3
8824: PPUSH
8825: LD_INT 0
8827: PPUSH
8828: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8832: LD_EXP 5
8836: PPUSH
8837: CALL_OW 87
// Wait ( 0 0$10 ) ;
8841: LD_INT 350
8843: PPUSH
8844: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8848: LD_INT 6
8850: PUSH
8851: LD_INT 7
8853: PUSH
8854: LD_INT 8
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: LIST
8861: PUSH
8862: LD_EXP 1
8866: ARRAY
8867: PPUSH
8868: CALL 7928 0 1
// Wait ( 2 2$00 ) ;
8872: LD_INT 4200
8874: PPUSH
8875: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8879: LD_INT 33
8881: PUSH
8882: LD_INT 2
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: LD_INT 3
8891: PUSH
8892: LD_INT 34
8894: PUSH
8895: LD_INT 13
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PPUSH
8910: CALL_OW 69
8914: PUSH
8915: LD_INT 3
8917: LESS
8918: IFFALSE 8929
// Wait ( 0 0$01 ) ;
8920: LD_INT 35
8922: PPUSH
8923: CALL_OW 67
8927: GO 8879
// uc_side := 4 ;
8929: LD_ADDR_OWVAR 20
8933: PUSH
8934: LD_INT 4
8936: ST_TO_ADDR
// uc_nation := 1 ;
8937: LD_ADDR_OWVAR 21
8941: PUSH
8942: LD_INT 1
8944: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: DOUBLE
8951: LD_INT 1
8953: DEC
8954: ST_TO_ADDR
8955: LD_INT 4
8957: PUSH
8958: LD_INT 5
8960: PUSH
8961: LD_INT 6
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: LIST
8968: PUSH
8969: LD_EXP 1
8973: ARRAY
8974: PUSH
8975: FOR_TO
8976: IFFALSE 9018
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8978: LD_INT 1
8980: PPUSH
8981: LD_INT 5
8983: PUSH
8984: LD_INT 6
8986: PUSH
8987: LD_INT 7
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PUSH
8995: LD_EXP 1
8999: ARRAY
9000: PPUSH
9001: CALL 734 0 2
9005: PPUSH
9006: LD_INT 4
9008: PPUSH
9009: LD_INT 0
9011: PPUSH
9012: CALL_OW 49
9016: GO 8975
9018: POP
9019: POP
// sikorski_ar := true ;
9020: LD_ADDR_EXP 12
9024: PUSH
9025: LD_INT 1
9027: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9028: LD_EXP 9
9032: PPUSH
9033: LD_STRING DSik1
9035: PPUSH
9036: CALL_OW 94
// Wait ( 0 0$30 ) ;
9040: LD_INT 1050
9042: PPUSH
9043: CALL_OW 67
// uc_side := 4 ;
9047: LD_ADDR_OWVAR 20
9051: PUSH
9052: LD_INT 4
9054: ST_TO_ADDR
// uc_nation := 1 ;
9055: LD_ADDR_OWVAR 21
9059: PUSH
9060: LD_INT 1
9062: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9063: LD_ADDR_VAR 0 1
9067: PUSH
9068: DOUBLE
9069: LD_INT 1
9071: DEC
9072: ST_TO_ADDR
9073: LD_INT 3
9075: PUSH
9076: LD_INT 4
9078: PUSH
9079: LD_INT 4
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: LIST
9086: PUSH
9087: LD_EXP 1
9091: ARRAY
9092: PUSH
9093: FOR_TO
9094: IFFALSE 9136
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 5
9101: PUSH
9102: LD_INT 6
9104: PUSH
9105: LD_INT 7
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: PUSH
9113: LD_EXP 1
9117: ARRAY
9118: PPUSH
9119: CALL 734 0 2
9123: PPUSH
9124: LD_INT 13
9126: PPUSH
9127: LD_INT 0
9129: PPUSH
9130: CALL_OW 49
9134: GO 9093
9136: POP
9137: POP
// end ;
9138: PPOPN 1
9140: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9141: LD_EXP 9
9145: PPUSH
9146: CALL_OW 256
9150: PUSH
9151: LD_INT 650
9153: LESS
9154: IFFALSE 9236
9156: GO 9158
9158: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9159: LD_EXP 9
9163: PPUSH
9164: LD_STRING DSik2
9166: PPUSH
9167: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9171: LD_EXP 9
9175: PPUSH
9176: CALL_OW 300
9180: IFFALSE 9236
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9182: LD_EXP 9
9186: PPUSH
9187: LD_INT 2
9189: PPUSH
9190: CALL_OW 113
// Wait ( 0 0$01 ) ;
9194: LD_INT 35
9196: PPUSH
9197: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9201: LD_EXP 9
9205: PPUSH
9206: LD_INT 2
9208: PPUSH
9209: CALL_OW 308
9213: IFFALSE 9234
// begin RemoveUnit ( sikorski ) ;
9215: LD_EXP 9
9219: PPUSH
9220: CALL_OW 64
// break ;
9224: GO 9236
// sikorski_run := true ;
9226: LD_ADDR_EXP 23
9230: PUSH
9231: LD_INT 1
9233: ST_TO_ADDR
// end ; end ;
9234: GO 9171
// end ;
9236: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9237: LD_EXP 9
9241: PPUSH
9242: CALL_OW 256
9246: PUSH
9247: LD_INT 1000
9249: LESS
9250: IFFALSE 9267
9252: GO 9254
9254: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9255: LD_EXP 9
9259: PPUSH
9260: LD_STRING DSkik3
9262: PPUSH
9263: CALL_OW 88
9267: END
// every 1 1$45 + 0 0$15 do
9268: GO 9270
9270: DISABLE
// begin enable ;
9271: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 5
9277: PPUSH
9278: CALL_OW 12
9282: PPUSH
9283: LD_INT 8
9285: PPUSH
9286: LD_INT 1
9288: PPUSH
9289: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9293: LD_INT 350
9295: PPUSH
9296: LD_INT 1295
9298: PPUSH
9299: CALL_OW 12
9303: PPUSH
9304: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9308: LD_INT 1
9310: PPUSH
9311: LD_INT 5
9313: PPUSH
9314: CALL_OW 12
9318: PPUSH
9319: LD_INT 1
9321: PPUSH
9322: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9326: LD_INT 350
9328: PPUSH
9329: LD_INT 1050
9331: PPUSH
9332: CALL_OW 12
9336: PPUSH
9337: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9341: LD_EXP 24
9345: PUSH
9346: LD_INT 25200
9348: PUSH
9349: LD_INT 23100
9351: PUSH
9352: LD_INT 21000
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: LIST
9359: PUSH
9360: LD_EXP 1
9364: ARRAY
9365: LESSEQUAL
9366: IFFALSE 9389
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9368: LD_INT 1
9370: PPUSH
9371: LD_INT 5
9373: PPUSH
9374: CALL_OW 12
9378: PPUSH
9379: LD_INT 8
9381: PPUSH
9382: LD_INT 1
9384: PPUSH
9385: CALL_OW 55
// end ;
9389: END
// export timer ; every 1 do
9390: GO 9392
9392: DISABLE
// timer := 0 0$00 ;
9393: LD_ADDR_EXP 24
9397: PUSH
9398: LD_INT 0
9400: ST_TO_ADDR
9401: END
// every 0 0$01 do
9402: GO 9404
9404: DISABLE
// begin enable ;
9405: ENABLE
// Display_Strings := [ #tick , timer ] ;
9406: LD_ADDR_OWVAR 47
9410: PUSH
9411: LD_STRING #tick
9413: PUSH
9414: LD_EXP 24
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9423: LD_ADDR_EXP 24
9427: PUSH
9428: LD_EXP 24
9432: PUSH
9433: LD_INT 35
9435: PLUS
9436: ST_TO_ADDR
// end ; end_of_file
9437: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9438: GO 9440
9440: DISABLE
// begin ru_radar := 98 ;
9441: LD_ADDR_EXP 25
9445: PUSH
9446: LD_INT 98
9448: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9449: LD_ADDR_EXP 26
9453: PUSH
9454: LD_INT 89
9456: ST_TO_ADDR
// us_hack := 99 ;
9457: LD_ADDR_EXP 27
9461: PUSH
9462: LD_INT 99
9464: ST_TO_ADDR
// us_artillery := 97 ;
9465: LD_ADDR_EXP 28
9469: PUSH
9470: LD_INT 97
9472: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9473: LD_ADDR_EXP 29
9477: PUSH
9478: LD_INT 91
9480: ST_TO_ADDR
// end ; end_of_file end_of_file
9481: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
9482: GO 9484
9484: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
9485: LD_STRING initStreamRollete();
9487: PPUSH
9488: CALL_OW 559
// InitStreamMode ;
9492: CALL 9501 0 0
// DefineStreamItems ( ) ;
9496: CALL 9941 0 0
// end ;
9500: END
// function InitStreamMode ; begin
9501: LD_INT 0
9503: PPUSH
// streamModeActive := false ;
9504: LD_ADDR_EXP 30
9508: PUSH
9509: LD_INT 0
9511: ST_TO_ADDR
// normalCounter := 36 ;
9512: LD_ADDR_EXP 31
9516: PUSH
9517: LD_INT 36
9519: ST_TO_ADDR
// hardcoreCounter := 16 ;
9520: LD_ADDR_EXP 32
9524: PUSH
9525: LD_INT 16
9527: ST_TO_ADDR
// sRocket := false ;
9528: LD_ADDR_EXP 35
9532: PUSH
9533: LD_INT 0
9535: ST_TO_ADDR
// sSpeed := false ;
9536: LD_ADDR_EXP 34
9540: PUSH
9541: LD_INT 0
9543: ST_TO_ADDR
// sEngine := false ;
9544: LD_ADDR_EXP 36
9548: PUSH
9549: LD_INT 0
9551: ST_TO_ADDR
// sSpec := false ;
9552: LD_ADDR_EXP 33
9556: PUSH
9557: LD_INT 0
9559: ST_TO_ADDR
// sLevel := false ;
9560: LD_ADDR_EXP 37
9564: PUSH
9565: LD_INT 0
9567: ST_TO_ADDR
// sArmoury := false ;
9568: LD_ADDR_EXP 38
9572: PUSH
9573: LD_INT 0
9575: ST_TO_ADDR
// sRadar := false ;
9576: LD_ADDR_EXP 39
9580: PUSH
9581: LD_INT 0
9583: ST_TO_ADDR
// sBunker := false ;
9584: LD_ADDR_EXP 40
9588: PUSH
9589: LD_INT 0
9591: ST_TO_ADDR
// sHack := false ;
9592: LD_ADDR_EXP 41
9596: PUSH
9597: LD_INT 0
9599: ST_TO_ADDR
// sFire := false ;
9600: LD_ADDR_EXP 42
9604: PUSH
9605: LD_INT 0
9607: ST_TO_ADDR
// sRefresh := false ;
9608: LD_ADDR_EXP 43
9612: PUSH
9613: LD_INT 0
9615: ST_TO_ADDR
// sExp := false ;
9616: LD_ADDR_EXP 44
9620: PUSH
9621: LD_INT 0
9623: ST_TO_ADDR
// sDepot := false ;
9624: LD_ADDR_EXP 45
9628: PUSH
9629: LD_INT 0
9631: ST_TO_ADDR
// sFlag := false ;
9632: LD_ADDR_EXP 46
9636: PUSH
9637: LD_INT 0
9639: ST_TO_ADDR
// sKamikadze := false ;
9640: LD_ADDR_EXP 54
9644: PUSH
9645: LD_INT 0
9647: ST_TO_ADDR
// sTroll := false ;
9648: LD_ADDR_EXP 55
9652: PUSH
9653: LD_INT 0
9655: ST_TO_ADDR
// sSlow := false ;
9656: LD_ADDR_EXP 56
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// sLack := false ;
9664: LD_ADDR_EXP 57
9668: PUSH
9669: LD_INT 0
9671: ST_TO_ADDR
// sTank := false ;
9672: LD_ADDR_EXP 59
9676: PUSH
9677: LD_INT 0
9679: ST_TO_ADDR
// sRemote := false ;
9680: LD_ADDR_EXP 60
9684: PUSH
9685: LD_INT 0
9687: ST_TO_ADDR
// sPowell := false ;
9688: LD_ADDR_EXP 61
9692: PUSH
9693: LD_INT 0
9695: ST_TO_ADDR
// sTeleport := false ;
9696: LD_ADDR_EXP 64
9700: PUSH
9701: LD_INT 0
9703: ST_TO_ADDR
// sOilTower := false ;
9704: LD_ADDR_EXP 66
9708: PUSH
9709: LD_INT 0
9711: ST_TO_ADDR
// sShovel := false ;
9712: LD_ADDR_EXP 67
9716: PUSH
9717: LD_INT 0
9719: ST_TO_ADDR
// sSheik := false ;
9720: LD_ADDR_EXP 68
9724: PUSH
9725: LD_INT 0
9727: ST_TO_ADDR
// sEarthquake := false ;
9728: LD_ADDR_EXP 70
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// sAI := false ;
9736: LD_ADDR_EXP 71
9740: PUSH
9741: LD_INT 0
9743: ST_TO_ADDR
// sCargo := false ;
9744: LD_ADDR_EXP 74
9748: PUSH
9749: LD_INT 0
9751: ST_TO_ADDR
// sDLaser := false ;
9752: LD_ADDR_EXP 75
9756: PUSH
9757: LD_INT 0
9759: ST_TO_ADDR
// sExchange := false ;
9760: LD_ADDR_EXP 76
9764: PUSH
9765: LD_INT 0
9767: ST_TO_ADDR
// sFac := false ;
9768: LD_ADDR_EXP 77
9772: PUSH
9773: LD_INT 0
9775: ST_TO_ADDR
// sPower := false ;
9776: LD_ADDR_EXP 78
9780: PUSH
9781: LD_INT 0
9783: ST_TO_ADDR
// sRandom := false ;
9784: LD_ADDR_EXP 79
9788: PUSH
9789: LD_INT 0
9791: ST_TO_ADDR
// sShield := false ;
9792: LD_ADDR_EXP 80
9796: PUSH
9797: LD_INT 0
9799: ST_TO_ADDR
// sTime := false ;
9800: LD_ADDR_EXP 81
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// sTools := false ;
9808: LD_ADDR_EXP 82
9812: PUSH
9813: LD_INT 0
9815: ST_TO_ADDR
// sSold := false ;
9816: LD_ADDR_EXP 47
9820: PUSH
9821: LD_INT 0
9823: ST_TO_ADDR
// sDiff := false ;
9824: LD_ADDR_EXP 48
9828: PUSH
9829: LD_INT 0
9831: ST_TO_ADDR
// sFog := false ;
9832: LD_ADDR_EXP 51
9836: PUSH
9837: LD_INT 0
9839: ST_TO_ADDR
// sReset := false ;
9840: LD_ADDR_EXP 52
9844: PUSH
9845: LD_INT 0
9847: ST_TO_ADDR
// sSun := false ;
9848: LD_ADDR_EXP 53
9852: PUSH
9853: LD_INT 0
9855: ST_TO_ADDR
// sTiger := false ;
9856: LD_ADDR_EXP 49
9860: PUSH
9861: LD_INT 0
9863: ST_TO_ADDR
// sBomb := false ;
9864: LD_ADDR_EXP 50
9868: PUSH
9869: LD_INT 0
9871: ST_TO_ADDR
// sWound := false ;
9872: LD_ADDR_EXP 58
9876: PUSH
9877: LD_INT 0
9879: ST_TO_ADDR
// sBetray := false ;
9880: LD_ADDR_EXP 62
9884: PUSH
9885: LD_INT 0
9887: ST_TO_ADDR
// sContamin := false ;
9888: LD_ADDR_EXP 63
9892: PUSH
9893: LD_INT 0
9895: ST_TO_ADDR
// sOil := false ;
9896: LD_ADDR_EXP 65
9900: PUSH
9901: LD_INT 0
9903: ST_TO_ADDR
// sStu := false ;
9904: LD_ADDR_EXP 69
9908: PUSH
9909: LD_INT 0
9911: ST_TO_ADDR
// sBazooka := false ;
9912: LD_ADDR_EXP 72
9916: PUSH
9917: LD_INT 0
9919: ST_TO_ADDR
// sMortar := false ;
9920: LD_ADDR_EXP 73
9924: PUSH
9925: LD_INT 0
9927: ST_TO_ADDR
// sRanger := false ;
9928: LD_ADDR_EXP 83
9932: PUSH
9933: LD_INT 0
9935: ST_TO_ADDR
// end ;
9936: LD_VAR 0 1
9940: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9941: LD_INT 0
9943: PPUSH
9944: PPUSH
9945: PPUSH
9946: PPUSH
9947: PPUSH
// result := [ ] ;
9948: LD_ADDR_VAR 0 1
9952: PUSH
9953: EMPTY
9954: ST_TO_ADDR
// if campaign_id = 1 then
9955: LD_OWVAR 69
9959: PUSH
9960: LD_INT 1
9962: EQUAL
9963: IFFALSE 12901
// begin case mission_number of 1 :
9965: LD_OWVAR 70
9969: PUSH
9970: LD_INT 1
9972: DOUBLE
9973: EQUAL
9974: IFTRUE 9978
9976: GO 10042
9978: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9979: LD_ADDR_VAR 0 1
9983: PUSH
9984: LD_INT 2
9986: PUSH
9987: LD_INT 4
9989: PUSH
9990: LD_INT 11
9992: PUSH
9993: LD_INT 12
9995: PUSH
9996: LD_INT 15
9998: PUSH
9999: LD_INT 16
10001: PUSH
10002: LD_INT 22
10004: PUSH
10005: LD_INT 23
10007: PUSH
10008: LD_INT 26
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: LIST
10021: PUSH
10022: LD_INT 101
10024: PUSH
10025: LD_INT 102
10027: PUSH
10028: LD_INT 106
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: LIST
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: ST_TO_ADDR
10040: GO 12899
10042: LD_INT 2
10044: DOUBLE
10045: EQUAL
10046: IFTRUE 10050
10048: GO 10122
10050: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
10051: LD_ADDR_VAR 0 1
10055: PUSH
10056: LD_INT 2
10058: PUSH
10059: LD_INT 4
10061: PUSH
10062: LD_INT 11
10064: PUSH
10065: LD_INT 12
10067: PUSH
10068: LD_INT 15
10070: PUSH
10071: LD_INT 16
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 23
10079: PUSH
10080: LD_INT 26
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 101
10096: PUSH
10097: LD_INT 102
10099: PUSH
10100: LD_INT 105
10102: PUSH
10103: LD_INT 106
10105: PUSH
10106: LD_INT 108
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: ST_TO_ADDR
10120: GO 12899
10122: LD_INT 3
10124: DOUBLE
10125: EQUAL
10126: IFTRUE 10130
10128: GO 10206
10130: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
10131: LD_ADDR_VAR 0 1
10135: PUSH
10136: LD_INT 2
10138: PUSH
10139: LD_INT 4
10141: PUSH
10142: LD_INT 5
10144: PUSH
10145: LD_INT 11
10147: PUSH
10148: LD_INT 12
10150: PUSH
10151: LD_INT 15
10153: PUSH
10154: LD_INT 16
10156: PUSH
10157: LD_INT 22
10159: PUSH
10160: LD_INT 26
10162: PUSH
10163: LD_INT 36
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: PUSH
10178: LD_INT 101
10180: PUSH
10181: LD_INT 102
10183: PUSH
10184: LD_INT 105
10186: PUSH
10187: LD_INT 106
10189: PUSH
10190: LD_INT 108
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: ST_TO_ADDR
10204: GO 12899
10206: LD_INT 4
10208: DOUBLE
10209: EQUAL
10210: IFTRUE 10214
10212: GO 10298
10214: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
10215: LD_ADDR_VAR 0 1
10219: PUSH
10220: LD_INT 2
10222: PUSH
10223: LD_INT 4
10225: PUSH
10226: LD_INT 5
10228: PUSH
10229: LD_INT 8
10231: PUSH
10232: LD_INT 11
10234: PUSH
10235: LD_INT 12
10237: PUSH
10238: LD_INT 15
10240: PUSH
10241: LD_INT 16
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 23
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 36
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: PUSH
10270: LD_INT 101
10272: PUSH
10273: LD_INT 102
10275: PUSH
10276: LD_INT 105
10278: PUSH
10279: LD_INT 106
10281: PUSH
10282: LD_INT 108
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: ST_TO_ADDR
10296: GO 12899
10298: LD_INT 5
10300: DOUBLE
10301: EQUAL
10302: IFTRUE 10306
10304: GO 10406
10306: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
10307: LD_ADDR_VAR 0 1
10311: PUSH
10312: LD_INT 2
10314: PUSH
10315: LD_INT 4
10317: PUSH
10318: LD_INT 5
10320: PUSH
10321: LD_INT 6
10323: PUSH
10324: LD_INT 8
10326: PUSH
10327: LD_INT 11
10329: PUSH
10330: LD_INT 12
10332: PUSH
10333: LD_INT 15
10335: PUSH
10336: LD_INT 16
10338: PUSH
10339: LD_INT 22
10341: PUSH
10342: LD_INT 23
10344: PUSH
10345: LD_INT 25
10347: PUSH
10348: LD_INT 26
10350: PUSH
10351: LD_INT 36
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 101
10372: PUSH
10373: LD_INT 102
10375: PUSH
10376: LD_INT 105
10378: PUSH
10379: LD_INT 106
10381: PUSH
10382: LD_INT 108
10384: PUSH
10385: LD_INT 109
10387: PUSH
10388: LD_INT 112
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: ST_TO_ADDR
10404: GO 12899
10406: LD_INT 6
10408: DOUBLE
10409: EQUAL
10410: IFTRUE 10414
10412: GO 10534
10414: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
10415: LD_ADDR_VAR 0 1
10419: PUSH
10420: LD_INT 2
10422: PUSH
10423: LD_INT 4
10425: PUSH
10426: LD_INT 5
10428: PUSH
10429: LD_INT 6
10431: PUSH
10432: LD_INT 8
10434: PUSH
10435: LD_INT 11
10437: PUSH
10438: LD_INT 12
10440: PUSH
10441: LD_INT 15
10443: PUSH
10444: LD_INT 16
10446: PUSH
10447: LD_INT 20
10449: PUSH
10450: LD_INT 21
10452: PUSH
10453: LD_INT 22
10455: PUSH
10456: LD_INT 23
10458: PUSH
10459: LD_INT 25
10461: PUSH
10462: LD_INT 26
10464: PUSH
10465: LD_INT 30
10467: PUSH
10468: LD_INT 31
10470: PUSH
10471: LD_INT 32
10473: PUSH
10474: LD_INT 36
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: LIST
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PUSH
10498: LD_INT 101
10500: PUSH
10501: LD_INT 102
10503: PUSH
10504: LD_INT 105
10506: PUSH
10507: LD_INT 106
10509: PUSH
10510: LD_INT 108
10512: PUSH
10513: LD_INT 109
10515: PUSH
10516: LD_INT 112
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: ST_TO_ADDR
10532: GO 12899
10534: LD_INT 7
10536: DOUBLE
10537: EQUAL
10538: IFTRUE 10542
10540: GO 10642
10542: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
10543: LD_ADDR_VAR 0 1
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: LD_INT 4
10553: PUSH
10554: LD_INT 5
10556: PUSH
10557: LD_INT 7
10559: PUSH
10560: LD_INT 11
10562: PUSH
10563: LD_INT 12
10565: PUSH
10566: LD_INT 15
10568: PUSH
10569: LD_INT 16
10571: PUSH
10572: LD_INT 20
10574: PUSH
10575: LD_INT 21
10577: PUSH
10578: LD_INT 22
10580: PUSH
10581: LD_INT 23
10583: PUSH
10584: LD_INT 25
10586: PUSH
10587: LD_INT 26
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: PUSH
10606: LD_INT 101
10608: PUSH
10609: LD_INT 102
10611: PUSH
10612: LD_INT 103
10614: PUSH
10615: LD_INT 105
10617: PUSH
10618: LD_INT 106
10620: PUSH
10621: LD_INT 108
10623: PUSH
10624: LD_INT 112
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: ST_TO_ADDR
10640: GO 12899
10642: LD_INT 8
10644: DOUBLE
10645: EQUAL
10646: IFTRUE 10650
10648: GO 10778
10650: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
10651: LD_ADDR_VAR 0 1
10655: PUSH
10656: LD_INT 2
10658: PUSH
10659: LD_INT 4
10661: PUSH
10662: LD_INT 5
10664: PUSH
10665: LD_INT 6
10667: PUSH
10668: LD_INT 7
10670: PUSH
10671: LD_INT 8
10673: PUSH
10674: LD_INT 11
10676: PUSH
10677: LD_INT 12
10679: PUSH
10680: LD_INT 15
10682: PUSH
10683: LD_INT 16
10685: PUSH
10686: LD_INT 20
10688: PUSH
10689: LD_INT 21
10691: PUSH
10692: LD_INT 22
10694: PUSH
10695: LD_INT 23
10697: PUSH
10698: LD_INT 25
10700: PUSH
10701: LD_INT 26
10703: PUSH
10704: LD_INT 30
10706: PUSH
10707: LD_INT 31
10709: PUSH
10710: LD_INT 32
10712: PUSH
10713: LD_INT 36
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PUSH
10738: LD_INT 101
10740: PUSH
10741: LD_INT 102
10743: PUSH
10744: LD_INT 103
10746: PUSH
10747: LD_INT 105
10749: PUSH
10750: LD_INT 106
10752: PUSH
10753: LD_INT 108
10755: PUSH
10756: LD_INT 109
10758: PUSH
10759: LD_INT 112
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: LIST
10766: LIST
10767: LIST
10768: LIST
10769: LIST
10770: LIST
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: ST_TO_ADDR
10776: GO 12899
10778: LD_INT 9
10780: DOUBLE
10781: EQUAL
10782: IFTRUE 10786
10784: GO 10922
10786: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
10787: LD_ADDR_VAR 0 1
10791: PUSH
10792: LD_INT 2
10794: PUSH
10795: LD_INT 4
10797: PUSH
10798: LD_INT 5
10800: PUSH
10801: LD_INT 6
10803: PUSH
10804: LD_INT 7
10806: PUSH
10807: LD_INT 8
10809: PUSH
10810: LD_INT 11
10812: PUSH
10813: LD_INT 12
10815: PUSH
10816: LD_INT 15
10818: PUSH
10819: LD_INT 16
10821: PUSH
10822: LD_INT 20
10824: PUSH
10825: LD_INT 21
10827: PUSH
10828: LD_INT 22
10830: PUSH
10831: LD_INT 23
10833: PUSH
10834: LD_INT 25
10836: PUSH
10837: LD_INT 26
10839: PUSH
10840: LD_INT 28
10842: PUSH
10843: LD_INT 30
10845: PUSH
10846: LD_INT 31
10848: PUSH
10849: LD_INT 32
10851: PUSH
10852: LD_INT 36
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: LIST
10874: LIST
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 101
10880: PUSH
10881: LD_INT 102
10883: PUSH
10884: LD_INT 103
10886: PUSH
10887: LD_INT 105
10889: PUSH
10890: LD_INT 106
10892: PUSH
10893: LD_INT 108
10895: PUSH
10896: LD_INT 109
10898: PUSH
10899: LD_INT 112
10901: PUSH
10902: LD_INT 114
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: ST_TO_ADDR
10920: GO 12899
10922: LD_INT 10
10924: DOUBLE
10925: EQUAL
10926: IFTRUE 10930
10928: GO 11114
10930: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10931: LD_ADDR_VAR 0 1
10935: PUSH
10936: LD_INT 2
10938: PUSH
10939: LD_INT 4
10941: PUSH
10942: LD_INT 5
10944: PUSH
10945: LD_INT 6
10947: PUSH
10948: LD_INT 7
10950: PUSH
10951: LD_INT 8
10953: PUSH
10954: LD_INT 9
10956: PUSH
10957: LD_INT 10
10959: PUSH
10960: LD_INT 11
10962: PUSH
10963: LD_INT 12
10965: PUSH
10966: LD_INT 13
10968: PUSH
10969: LD_INT 14
10971: PUSH
10972: LD_INT 15
10974: PUSH
10975: LD_INT 16
10977: PUSH
10978: LD_INT 17
10980: PUSH
10981: LD_INT 18
10983: PUSH
10984: LD_INT 19
10986: PUSH
10987: LD_INT 20
10989: PUSH
10990: LD_INT 21
10992: PUSH
10993: LD_INT 22
10995: PUSH
10996: LD_INT 23
10998: PUSH
10999: LD_INT 24
11001: PUSH
11002: LD_INT 25
11004: PUSH
11005: LD_INT 26
11007: PUSH
11008: LD_INT 28
11010: PUSH
11011: LD_INT 30
11013: PUSH
11014: LD_INT 31
11016: PUSH
11017: LD_INT 32
11019: PUSH
11020: LD_INT 36
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: LIST
11052: LIST
11053: PUSH
11054: LD_INT 101
11056: PUSH
11057: LD_INT 102
11059: PUSH
11060: LD_INT 103
11062: PUSH
11063: LD_INT 104
11065: PUSH
11066: LD_INT 105
11068: PUSH
11069: LD_INT 106
11071: PUSH
11072: LD_INT 107
11074: PUSH
11075: LD_INT 108
11077: PUSH
11078: LD_INT 109
11080: PUSH
11081: LD_INT 110
11083: PUSH
11084: LD_INT 111
11086: PUSH
11087: LD_INT 112
11089: PUSH
11090: LD_INT 114
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: ST_TO_ADDR
11112: GO 12899
11114: LD_INT 11
11116: DOUBLE
11117: EQUAL
11118: IFTRUE 11122
11120: GO 11314
11122: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
11123: LD_ADDR_VAR 0 1
11127: PUSH
11128: LD_INT 2
11130: PUSH
11131: LD_INT 3
11133: PUSH
11134: LD_INT 4
11136: PUSH
11137: LD_INT 5
11139: PUSH
11140: LD_INT 6
11142: PUSH
11143: LD_INT 7
11145: PUSH
11146: LD_INT 8
11148: PUSH
11149: LD_INT 9
11151: PUSH
11152: LD_INT 10
11154: PUSH
11155: LD_INT 11
11157: PUSH
11158: LD_INT 12
11160: PUSH
11161: LD_INT 13
11163: PUSH
11164: LD_INT 14
11166: PUSH
11167: LD_INT 15
11169: PUSH
11170: LD_INT 16
11172: PUSH
11173: LD_INT 17
11175: PUSH
11176: LD_INT 18
11178: PUSH
11179: LD_INT 19
11181: PUSH
11182: LD_INT 20
11184: PUSH
11185: LD_INT 21
11187: PUSH
11188: LD_INT 22
11190: PUSH
11191: LD_INT 23
11193: PUSH
11194: LD_INT 24
11196: PUSH
11197: LD_INT 25
11199: PUSH
11200: LD_INT 26
11202: PUSH
11203: LD_INT 28
11205: PUSH
11206: LD_INT 30
11208: PUSH
11209: LD_INT 31
11211: PUSH
11212: LD_INT 32
11214: PUSH
11215: LD_INT 34
11217: PUSH
11218: LD_INT 36
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: PUSH
11254: LD_INT 101
11256: PUSH
11257: LD_INT 102
11259: PUSH
11260: LD_INT 103
11262: PUSH
11263: LD_INT 104
11265: PUSH
11266: LD_INT 105
11268: PUSH
11269: LD_INT 106
11271: PUSH
11272: LD_INT 107
11274: PUSH
11275: LD_INT 108
11277: PUSH
11278: LD_INT 109
11280: PUSH
11281: LD_INT 110
11283: PUSH
11284: LD_INT 111
11286: PUSH
11287: LD_INT 112
11289: PUSH
11290: LD_INT 114
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: ST_TO_ADDR
11312: GO 12899
11314: LD_INT 12
11316: DOUBLE
11317: EQUAL
11318: IFTRUE 11322
11320: GO 11530
11322: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
11323: LD_ADDR_VAR 0 1
11327: PUSH
11328: LD_INT 1
11330: PUSH
11331: LD_INT 2
11333: PUSH
11334: LD_INT 3
11336: PUSH
11337: LD_INT 4
11339: PUSH
11340: LD_INT 5
11342: PUSH
11343: LD_INT 6
11345: PUSH
11346: LD_INT 7
11348: PUSH
11349: LD_INT 8
11351: PUSH
11352: LD_INT 9
11354: PUSH
11355: LD_INT 10
11357: PUSH
11358: LD_INT 11
11360: PUSH
11361: LD_INT 12
11363: PUSH
11364: LD_INT 13
11366: PUSH
11367: LD_INT 14
11369: PUSH
11370: LD_INT 15
11372: PUSH
11373: LD_INT 16
11375: PUSH
11376: LD_INT 17
11378: PUSH
11379: LD_INT 18
11381: PUSH
11382: LD_INT 19
11384: PUSH
11385: LD_INT 20
11387: PUSH
11388: LD_INT 21
11390: PUSH
11391: LD_INT 22
11393: PUSH
11394: LD_INT 23
11396: PUSH
11397: LD_INT 24
11399: PUSH
11400: LD_INT 25
11402: PUSH
11403: LD_INT 26
11405: PUSH
11406: LD_INT 27
11408: PUSH
11409: LD_INT 28
11411: PUSH
11412: LD_INT 30
11414: PUSH
11415: LD_INT 31
11417: PUSH
11418: LD_INT 32
11420: PUSH
11421: LD_INT 33
11423: PUSH
11424: LD_INT 34
11426: PUSH
11427: LD_INT 36
11429: PUSH
11430: EMPTY
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: PUSH
11466: LD_INT 101
11468: PUSH
11469: LD_INT 102
11471: PUSH
11472: LD_INT 103
11474: PUSH
11475: LD_INT 104
11477: PUSH
11478: LD_INT 105
11480: PUSH
11481: LD_INT 106
11483: PUSH
11484: LD_INT 107
11486: PUSH
11487: LD_INT 108
11489: PUSH
11490: LD_INT 109
11492: PUSH
11493: LD_INT 110
11495: PUSH
11496: LD_INT 111
11498: PUSH
11499: LD_INT 112
11501: PUSH
11502: LD_INT 113
11504: PUSH
11505: LD_INT 114
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: ST_TO_ADDR
11528: GO 12899
11530: LD_INT 13
11532: DOUBLE
11533: EQUAL
11534: IFTRUE 11538
11536: GO 11734
11538: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
11539: LD_ADDR_VAR 0 1
11543: PUSH
11544: LD_INT 1
11546: PUSH
11547: LD_INT 2
11549: PUSH
11550: LD_INT 3
11552: PUSH
11553: LD_INT 4
11555: PUSH
11556: LD_INT 5
11558: PUSH
11559: LD_INT 8
11561: PUSH
11562: LD_INT 9
11564: PUSH
11565: LD_INT 10
11567: PUSH
11568: LD_INT 11
11570: PUSH
11571: LD_INT 12
11573: PUSH
11574: LD_INT 14
11576: PUSH
11577: LD_INT 15
11579: PUSH
11580: LD_INT 16
11582: PUSH
11583: LD_INT 17
11585: PUSH
11586: LD_INT 18
11588: PUSH
11589: LD_INT 19
11591: PUSH
11592: LD_INT 20
11594: PUSH
11595: LD_INT 21
11597: PUSH
11598: LD_INT 22
11600: PUSH
11601: LD_INT 23
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 25
11609: PUSH
11610: LD_INT 26
11612: PUSH
11613: LD_INT 27
11615: PUSH
11616: LD_INT 28
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 32
11627: PUSH
11628: LD_INT 33
11630: PUSH
11631: LD_INT 34
11633: PUSH
11634: LD_INT 36
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: PUSH
11670: LD_INT 101
11672: PUSH
11673: LD_INT 102
11675: PUSH
11676: LD_INT 103
11678: PUSH
11679: LD_INT 104
11681: PUSH
11682: LD_INT 105
11684: PUSH
11685: LD_INT 106
11687: PUSH
11688: LD_INT 107
11690: PUSH
11691: LD_INT 108
11693: PUSH
11694: LD_INT 109
11696: PUSH
11697: LD_INT 110
11699: PUSH
11700: LD_INT 111
11702: PUSH
11703: LD_INT 112
11705: PUSH
11706: LD_INT 113
11708: PUSH
11709: LD_INT 114
11711: PUSH
11712: EMPTY
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: ST_TO_ADDR
11732: GO 12899
11734: LD_INT 14
11736: DOUBLE
11737: EQUAL
11738: IFTRUE 11742
11740: GO 11954
11742: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
11743: LD_ADDR_VAR 0 1
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: LD_INT 2
11753: PUSH
11754: LD_INT 3
11756: PUSH
11757: LD_INT 4
11759: PUSH
11760: LD_INT 5
11762: PUSH
11763: LD_INT 6
11765: PUSH
11766: LD_INT 7
11768: PUSH
11769: LD_INT 8
11771: PUSH
11772: LD_INT 9
11774: PUSH
11775: LD_INT 10
11777: PUSH
11778: LD_INT 11
11780: PUSH
11781: LD_INT 12
11783: PUSH
11784: LD_INT 13
11786: PUSH
11787: LD_INT 14
11789: PUSH
11790: LD_INT 15
11792: PUSH
11793: LD_INT 16
11795: PUSH
11796: LD_INT 17
11798: PUSH
11799: LD_INT 18
11801: PUSH
11802: LD_INT 19
11804: PUSH
11805: LD_INT 20
11807: PUSH
11808: LD_INT 21
11810: PUSH
11811: LD_INT 22
11813: PUSH
11814: LD_INT 23
11816: PUSH
11817: LD_INT 24
11819: PUSH
11820: LD_INT 25
11822: PUSH
11823: LD_INT 26
11825: PUSH
11826: LD_INT 27
11828: PUSH
11829: LD_INT 28
11831: PUSH
11832: LD_INT 29
11834: PUSH
11835: LD_INT 30
11837: PUSH
11838: LD_INT 31
11840: PUSH
11841: LD_INT 32
11843: PUSH
11844: LD_INT 33
11846: PUSH
11847: LD_INT 34
11849: PUSH
11850: LD_INT 36
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 101
11892: PUSH
11893: LD_INT 102
11895: PUSH
11896: LD_INT 103
11898: PUSH
11899: LD_INT 104
11901: PUSH
11902: LD_INT 105
11904: PUSH
11905: LD_INT 106
11907: PUSH
11908: LD_INT 107
11910: PUSH
11911: LD_INT 108
11913: PUSH
11914: LD_INT 109
11916: PUSH
11917: LD_INT 110
11919: PUSH
11920: LD_INT 111
11922: PUSH
11923: LD_INT 112
11925: PUSH
11926: LD_INT 113
11928: PUSH
11929: LD_INT 114
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: LIST
11939: LIST
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: ST_TO_ADDR
11952: GO 12899
11954: LD_INT 15
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 12174
11962: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11963: LD_ADDR_VAR 0 1
11967: PUSH
11968: LD_INT 1
11970: PUSH
11971: LD_INT 2
11973: PUSH
11974: LD_INT 3
11976: PUSH
11977: LD_INT 4
11979: PUSH
11980: LD_INT 5
11982: PUSH
11983: LD_INT 6
11985: PUSH
11986: LD_INT 7
11988: PUSH
11989: LD_INT 8
11991: PUSH
11992: LD_INT 9
11994: PUSH
11995: LD_INT 10
11997: PUSH
11998: LD_INT 11
12000: PUSH
12001: LD_INT 12
12003: PUSH
12004: LD_INT 13
12006: PUSH
12007: LD_INT 14
12009: PUSH
12010: LD_INT 15
12012: PUSH
12013: LD_INT 16
12015: PUSH
12016: LD_INT 17
12018: PUSH
12019: LD_INT 18
12021: PUSH
12022: LD_INT 19
12024: PUSH
12025: LD_INT 20
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 22
12033: PUSH
12034: LD_INT 23
12036: PUSH
12037: LD_INT 24
12039: PUSH
12040: LD_INT 25
12042: PUSH
12043: LD_INT 26
12045: PUSH
12046: LD_INT 27
12048: PUSH
12049: LD_INT 28
12051: PUSH
12052: LD_INT 29
12054: PUSH
12055: LD_INT 30
12057: PUSH
12058: LD_INT 31
12060: PUSH
12061: LD_INT 32
12063: PUSH
12064: LD_INT 33
12066: PUSH
12067: LD_INT 34
12069: PUSH
12070: LD_INT 36
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: LIST
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: LIST
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: PUSH
12110: LD_INT 101
12112: PUSH
12113: LD_INT 102
12115: PUSH
12116: LD_INT 103
12118: PUSH
12119: LD_INT 104
12121: PUSH
12122: LD_INT 105
12124: PUSH
12125: LD_INT 106
12127: PUSH
12128: LD_INT 107
12130: PUSH
12131: LD_INT 108
12133: PUSH
12134: LD_INT 109
12136: PUSH
12137: LD_INT 110
12139: PUSH
12140: LD_INT 111
12142: PUSH
12143: LD_INT 112
12145: PUSH
12146: LD_INT 113
12148: PUSH
12149: LD_INT 114
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: ST_TO_ADDR
12172: GO 12899
12174: LD_INT 16
12176: DOUBLE
12177: EQUAL
12178: IFTRUE 12182
12180: GO 12306
12182: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
12183: LD_ADDR_VAR 0 1
12187: PUSH
12188: LD_INT 2
12190: PUSH
12191: LD_INT 4
12193: PUSH
12194: LD_INT 5
12196: PUSH
12197: LD_INT 7
12199: PUSH
12200: LD_INT 11
12202: PUSH
12203: LD_INT 12
12205: PUSH
12206: LD_INT 15
12208: PUSH
12209: LD_INT 16
12211: PUSH
12212: LD_INT 20
12214: PUSH
12215: LD_INT 21
12217: PUSH
12218: LD_INT 22
12220: PUSH
12221: LD_INT 23
12223: PUSH
12224: LD_INT 25
12226: PUSH
12227: LD_INT 26
12229: PUSH
12230: LD_INT 30
12232: PUSH
12233: LD_INT 31
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 33
12241: PUSH
12242: LD_INT 34
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 101
12268: PUSH
12269: LD_INT 102
12271: PUSH
12272: LD_INT 103
12274: PUSH
12275: LD_INT 106
12277: PUSH
12278: LD_INT 108
12280: PUSH
12281: LD_INT 112
12283: PUSH
12284: LD_INT 113
12286: PUSH
12287: LD_INT 114
12289: PUSH
12290: EMPTY
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: ST_TO_ADDR
12304: GO 12899
12306: LD_INT 17
12308: DOUBLE
12309: EQUAL
12310: IFTRUE 12314
12312: GO 12526
12314: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
12315: LD_ADDR_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: PUSH
12323: LD_INT 2
12325: PUSH
12326: LD_INT 3
12328: PUSH
12329: LD_INT 4
12331: PUSH
12332: LD_INT 5
12334: PUSH
12335: LD_INT 6
12337: PUSH
12338: LD_INT 7
12340: PUSH
12341: LD_INT 8
12343: PUSH
12344: LD_INT 9
12346: PUSH
12347: LD_INT 10
12349: PUSH
12350: LD_INT 11
12352: PUSH
12353: LD_INT 12
12355: PUSH
12356: LD_INT 13
12358: PUSH
12359: LD_INT 14
12361: PUSH
12362: LD_INT 15
12364: PUSH
12365: LD_INT 16
12367: PUSH
12368: LD_INT 17
12370: PUSH
12371: LD_INT 18
12373: PUSH
12374: LD_INT 19
12376: PUSH
12377: LD_INT 20
12379: PUSH
12380: LD_INT 21
12382: PUSH
12383: LD_INT 22
12385: PUSH
12386: LD_INT 23
12388: PUSH
12389: LD_INT 24
12391: PUSH
12392: LD_INT 25
12394: PUSH
12395: LD_INT 26
12397: PUSH
12398: LD_INT 27
12400: PUSH
12401: LD_INT 28
12403: PUSH
12404: LD_INT 29
12406: PUSH
12407: LD_INT 30
12409: PUSH
12410: LD_INT 31
12412: PUSH
12413: LD_INT 32
12415: PUSH
12416: LD_INT 33
12418: PUSH
12419: LD_INT 34
12421: PUSH
12422: LD_INT 36
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: LIST
12460: LIST
12461: PUSH
12462: LD_INT 101
12464: PUSH
12465: LD_INT 102
12467: PUSH
12468: LD_INT 103
12470: PUSH
12471: LD_INT 104
12473: PUSH
12474: LD_INT 105
12476: PUSH
12477: LD_INT 106
12479: PUSH
12480: LD_INT 107
12482: PUSH
12483: LD_INT 108
12485: PUSH
12486: LD_INT 109
12488: PUSH
12489: LD_INT 110
12491: PUSH
12492: LD_INT 111
12494: PUSH
12495: LD_INT 112
12497: PUSH
12498: LD_INT 113
12500: PUSH
12501: LD_INT 114
12503: PUSH
12504: EMPTY
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: ST_TO_ADDR
12524: GO 12899
12526: LD_INT 18
12528: DOUBLE
12529: EQUAL
12530: IFTRUE 12534
12532: GO 12670
12534: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
12535: LD_ADDR_VAR 0 1
12539: PUSH
12540: LD_INT 2
12542: PUSH
12543: LD_INT 4
12545: PUSH
12546: LD_INT 5
12548: PUSH
12549: LD_INT 7
12551: PUSH
12552: LD_INT 11
12554: PUSH
12555: LD_INT 12
12557: PUSH
12558: LD_INT 15
12560: PUSH
12561: LD_INT 16
12563: PUSH
12564: LD_INT 20
12566: PUSH
12567: LD_INT 21
12569: PUSH
12570: LD_INT 22
12572: PUSH
12573: LD_INT 23
12575: PUSH
12576: LD_INT 25
12578: PUSH
12579: LD_INT 26
12581: PUSH
12582: LD_INT 30
12584: PUSH
12585: LD_INT 31
12587: PUSH
12588: LD_INT 32
12590: PUSH
12591: LD_INT 33
12593: PUSH
12594: LD_INT 34
12596: PUSH
12597: LD_INT 35
12599: PUSH
12600: LD_INT 36
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 101
12628: PUSH
12629: LD_INT 102
12631: PUSH
12632: LD_INT 103
12634: PUSH
12635: LD_INT 106
12637: PUSH
12638: LD_INT 108
12640: PUSH
12641: LD_INT 112
12643: PUSH
12644: LD_INT 113
12646: PUSH
12647: LD_INT 114
12649: PUSH
12650: LD_INT 115
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: ST_TO_ADDR
12668: GO 12899
12670: LD_INT 19
12672: DOUBLE
12673: EQUAL
12674: IFTRUE 12678
12676: GO 12898
12678: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
12679: LD_ADDR_VAR 0 1
12683: PUSH
12684: LD_INT 1
12686: PUSH
12687: LD_INT 2
12689: PUSH
12690: LD_INT 3
12692: PUSH
12693: LD_INT 4
12695: PUSH
12696: LD_INT 5
12698: PUSH
12699: LD_INT 6
12701: PUSH
12702: LD_INT 7
12704: PUSH
12705: LD_INT 8
12707: PUSH
12708: LD_INT 9
12710: PUSH
12711: LD_INT 10
12713: PUSH
12714: LD_INT 11
12716: PUSH
12717: LD_INT 12
12719: PUSH
12720: LD_INT 13
12722: PUSH
12723: LD_INT 14
12725: PUSH
12726: LD_INT 15
12728: PUSH
12729: LD_INT 16
12731: PUSH
12732: LD_INT 17
12734: PUSH
12735: LD_INT 18
12737: PUSH
12738: LD_INT 19
12740: PUSH
12741: LD_INT 20
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 22
12749: PUSH
12750: LD_INT 23
12752: PUSH
12753: LD_INT 24
12755: PUSH
12756: LD_INT 25
12758: PUSH
12759: LD_INT 26
12761: PUSH
12762: LD_INT 27
12764: PUSH
12765: LD_INT 28
12767: PUSH
12768: LD_INT 29
12770: PUSH
12771: LD_INT 30
12773: PUSH
12774: LD_INT 31
12776: PUSH
12777: LD_INT 32
12779: PUSH
12780: LD_INT 33
12782: PUSH
12783: LD_INT 34
12785: PUSH
12786: LD_INT 35
12788: PUSH
12789: LD_INT 36
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PUSH
12830: LD_INT 101
12832: PUSH
12833: LD_INT 102
12835: PUSH
12836: LD_INT 103
12838: PUSH
12839: LD_INT 104
12841: PUSH
12842: LD_INT 105
12844: PUSH
12845: LD_INT 106
12847: PUSH
12848: LD_INT 107
12850: PUSH
12851: LD_INT 108
12853: PUSH
12854: LD_INT 109
12856: PUSH
12857: LD_INT 110
12859: PUSH
12860: LD_INT 111
12862: PUSH
12863: LD_INT 112
12865: PUSH
12866: LD_INT 113
12868: PUSH
12869: LD_INT 114
12871: PUSH
12872: LD_INT 115
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: PUSH
12892: EMPTY
12893: LIST
12894: LIST
12895: ST_TO_ADDR
12896: GO 12899
12898: POP
// end else
12899: GO 12936
// if campaign_id = 5 then
12901: LD_OWVAR 69
12905: PUSH
12906: LD_INT 5
12908: EQUAL
12909: IFFALSE 12936
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 1
12918: PUSH
12919: LD_INT 2
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 100
12928: PUSH
12929: EMPTY
12930: LIST
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: ST_TO_ADDR
// end ; if result then
12936: LD_VAR 0 1
12940: IFFALSE 13229
// begin normal :=  ;
12942: LD_ADDR_VAR 0 3
12946: PUSH
12947: LD_STRING 
12949: ST_TO_ADDR
// hardcore :=  ;
12950: LD_ADDR_VAR 0 4
12954: PUSH
12955: LD_STRING 
12957: ST_TO_ADDR
// for i = 1 to normalCounter do
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: DOUBLE
12964: LD_INT 1
12966: DEC
12967: ST_TO_ADDR
12968: LD_EXP 31
12972: PUSH
12973: FOR_TO
12974: IFFALSE 13075
// begin tmp := 0 ;
12976: LD_ADDR_VAR 0 2
12980: PUSH
12981: LD_STRING 0
12983: ST_TO_ADDR
// if result [ 1 ] then
12984: LD_VAR 0 1
12988: PUSH
12989: LD_INT 1
12991: ARRAY
12992: IFFALSE 13057
// if result [ 1 ] [ 1 ] = i then
12994: LD_VAR 0 1
12998: PUSH
12999: LD_INT 1
13001: ARRAY
13002: PUSH
13003: LD_INT 1
13005: ARRAY
13006: PUSH
13007: LD_VAR 0 5
13011: EQUAL
13012: IFFALSE 13057
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
13014: LD_ADDR_VAR 0 1
13018: PUSH
13019: LD_VAR 0 1
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_VAR 0 1
13031: PUSH
13032: LD_INT 1
13034: ARRAY
13035: PPUSH
13036: LD_INT 1
13038: PPUSH
13039: CALL_OW 3
13043: PPUSH
13044: CALL_OW 1
13048: ST_TO_ADDR
// tmp := 1 ;
13049: LD_ADDR_VAR 0 2
13053: PUSH
13054: LD_STRING 1
13056: ST_TO_ADDR
// end ; normal := normal & tmp ;
13057: LD_ADDR_VAR 0 3
13061: PUSH
13062: LD_VAR 0 3
13066: PUSH
13067: LD_VAR 0 2
13071: STR
13072: ST_TO_ADDR
// end ;
13073: GO 12973
13075: POP
13076: POP
// for i = 1 to hardcoreCounter do
13077: LD_ADDR_VAR 0 5
13081: PUSH
13082: DOUBLE
13083: LD_INT 1
13085: DEC
13086: ST_TO_ADDR
13087: LD_EXP 32
13091: PUSH
13092: FOR_TO
13093: IFFALSE 13198
// begin tmp := 0 ;
13095: LD_ADDR_VAR 0 2
13099: PUSH
13100: LD_STRING 0
13102: ST_TO_ADDR
// if result [ 2 ] then
13103: LD_VAR 0 1
13107: PUSH
13108: LD_INT 2
13110: ARRAY
13111: IFFALSE 13180
// if result [ 2 ] [ 1 ] = 100 + i then
13113: LD_VAR 0 1
13117: PUSH
13118: LD_INT 2
13120: ARRAY
13121: PUSH
13122: LD_INT 1
13124: ARRAY
13125: PUSH
13126: LD_INT 100
13128: PUSH
13129: LD_VAR 0 5
13133: PLUS
13134: EQUAL
13135: IFFALSE 13180
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
13137: LD_ADDR_VAR 0 1
13141: PUSH
13142: LD_VAR 0 1
13146: PPUSH
13147: LD_INT 2
13149: PPUSH
13150: LD_VAR 0 1
13154: PUSH
13155: LD_INT 2
13157: ARRAY
13158: PPUSH
13159: LD_INT 1
13161: PPUSH
13162: CALL_OW 3
13166: PPUSH
13167: CALL_OW 1
13171: ST_TO_ADDR
// tmp := 1 ;
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: LD_STRING 1
13179: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
13180: LD_ADDR_VAR 0 4
13184: PUSH
13185: LD_VAR 0 4
13189: PUSH
13190: LD_VAR 0 2
13194: STR
13195: ST_TO_ADDR
// end ;
13196: GO 13092
13198: POP
13199: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
13200: LD_STRING getStreamItemsFromMission("
13202: PUSH
13203: LD_VAR 0 3
13207: STR
13208: PUSH
13209: LD_STRING ","
13211: STR
13212: PUSH
13213: LD_VAR 0 4
13217: STR
13218: PUSH
13219: LD_STRING ")
13221: STR
13222: PPUSH
13223: CALL_OW 559
// end else
13227: GO 13236
// ToLua ( getStreamItemsFromMission("","") ) ;
13229: LD_STRING getStreamItemsFromMission("","")
13231: PPUSH
13232: CALL_OW 559
// end ;
13236: LD_VAR 0 1
13240: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
13241: LD_VAR 0 2
13245: PUSH
13246: LD_INT 100
13248: EQUAL
13249: IFFALSE 14198
// begin if not StreamModeActive then
13251: LD_EXP 30
13255: NOT
13256: IFFALSE 13266
// StreamModeActive := true ;
13258: LD_ADDR_EXP 30
13262: PUSH
13263: LD_INT 1
13265: ST_TO_ADDR
// if p3 = 0 then
13266: LD_VAR 0 3
13270: PUSH
13271: LD_INT 0
13273: EQUAL
13274: IFFALSE 13280
// InitStreamMode ;
13276: CALL 9501 0 0
// if p3 = 1 then
13280: LD_VAR 0 3
13284: PUSH
13285: LD_INT 1
13287: EQUAL
13288: IFFALSE 13298
// sRocket := true ;
13290: LD_ADDR_EXP 35
13294: PUSH
13295: LD_INT 1
13297: ST_TO_ADDR
// if p3 = 2 then
13298: LD_VAR 0 3
13302: PUSH
13303: LD_INT 2
13305: EQUAL
13306: IFFALSE 13316
// sSpeed := true ;
13308: LD_ADDR_EXP 34
13312: PUSH
13313: LD_INT 1
13315: ST_TO_ADDR
// if p3 = 3 then
13316: LD_VAR 0 3
13320: PUSH
13321: LD_INT 3
13323: EQUAL
13324: IFFALSE 13334
// sEngine := true ;
13326: LD_ADDR_EXP 36
13330: PUSH
13331: LD_INT 1
13333: ST_TO_ADDR
// if p3 = 4 then
13334: LD_VAR 0 3
13338: PUSH
13339: LD_INT 4
13341: EQUAL
13342: IFFALSE 13352
// sSpec := true ;
13344: LD_ADDR_EXP 33
13348: PUSH
13349: LD_INT 1
13351: ST_TO_ADDR
// if p3 = 5 then
13352: LD_VAR 0 3
13356: PUSH
13357: LD_INT 5
13359: EQUAL
13360: IFFALSE 13370
// sLevel := true ;
13362: LD_ADDR_EXP 37
13366: PUSH
13367: LD_INT 1
13369: ST_TO_ADDR
// if p3 = 6 then
13370: LD_VAR 0 3
13374: PUSH
13375: LD_INT 6
13377: EQUAL
13378: IFFALSE 13388
// sArmoury := true ;
13380: LD_ADDR_EXP 38
13384: PUSH
13385: LD_INT 1
13387: ST_TO_ADDR
// if p3 = 7 then
13388: LD_VAR 0 3
13392: PUSH
13393: LD_INT 7
13395: EQUAL
13396: IFFALSE 13406
// sRadar := true ;
13398: LD_ADDR_EXP 39
13402: PUSH
13403: LD_INT 1
13405: ST_TO_ADDR
// if p3 = 8 then
13406: LD_VAR 0 3
13410: PUSH
13411: LD_INT 8
13413: EQUAL
13414: IFFALSE 13424
// sBunker := true ;
13416: LD_ADDR_EXP 40
13420: PUSH
13421: LD_INT 1
13423: ST_TO_ADDR
// if p3 = 9 then
13424: LD_VAR 0 3
13428: PUSH
13429: LD_INT 9
13431: EQUAL
13432: IFFALSE 13442
// sHack := true ;
13434: LD_ADDR_EXP 41
13438: PUSH
13439: LD_INT 1
13441: ST_TO_ADDR
// if p3 = 10 then
13442: LD_VAR 0 3
13446: PUSH
13447: LD_INT 10
13449: EQUAL
13450: IFFALSE 13460
// sFire := true ;
13452: LD_ADDR_EXP 42
13456: PUSH
13457: LD_INT 1
13459: ST_TO_ADDR
// if p3 = 11 then
13460: LD_VAR 0 3
13464: PUSH
13465: LD_INT 11
13467: EQUAL
13468: IFFALSE 13478
// sRefresh := true ;
13470: LD_ADDR_EXP 43
13474: PUSH
13475: LD_INT 1
13477: ST_TO_ADDR
// if p3 = 12 then
13478: LD_VAR 0 3
13482: PUSH
13483: LD_INT 12
13485: EQUAL
13486: IFFALSE 13496
// sExp := true ;
13488: LD_ADDR_EXP 44
13492: PUSH
13493: LD_INT 1
13495: ST_TO_ADDR
// if p3 = 13 then
13496: LD_VAR 0 3
13500: PUSH
13501: LD_INT 13
13503: EQUAL
13504: IFFALSE 13514
// sDepot := true ;
13506: LD_ADDR_EXP 45
13510: PUSH
13511: LD_INT 1
13513: ST_TO_ADDR
// if p3 = 14 then
13514: LD_VAR 0 3
13518: PUSH
13519: LD_INT 14
13521: EQUAL
13522: IFFALSE 13532
// sFlag := true ;
13524: LD_ADDR_EXP 46
13528: PUSH
13529: LD_INT 1
13531: ST_TO_ADDR
// if p3 = 15 then
13532: LD_VAR 0 3
13536: PUSH
13537: LD_INT 15
13539: EQUAL
13540: IFFALSE 13550
// sKamikadze := true ;
13542: LD_ADDR_EXP 54
13546: PUSH
13547: LD_INT 1
13549: ST_TO_ADDR
// if p3 = 16 then
13550: LD_VAR 0 3
13554: PUSH
13555: LD_INT 16
13557: EQUAL
13558: IFFALSE 13568
// sTroll := true ;
13560: LD_ADDR_EXP 55
13564: PUSH
13565: LD_INT 1
13567: ST_TO_ADDR
// if p3 = 17 then
13568: LD_VAR 0 3
13572: PUSH
13573: LD_INT 17
13575: EQUAL
13576: IFFALSE 13586
// sSlow := true ;
13578: LD_ADDR_EXP 56
13582: PUSH
13583: LD_INT 1
13585: ST_TO_ADDR
// if p3 = 18 then
13586: LD_VAR 0 3
13590: PUSH
13591: LD_INT 18
13593: EQUAL
13594: IFFALSE 13604
// sLack := true ;
13596: LD_ADDR_EXP 57
13600: PUSH
13601: LD_INT 1
13603: ST_TO_ADDR
// if p3 = 19 then
13604: LD_VAR 0 3
13608: PUSH
13609: LD_INT 19
13611: EQUAL
13612: IFFALSE 13622
// sTank := true ;
13614: LD_ADDR_EXP 59
13618: PUSH
13619: LD_INT 1
13621: ST_TO_ADDR
// if p3 = 20 then
13622: LD_VAR 0 3
13626: PUSH
13627: LD_INT 20
13629: EQUAL
13630: IFFALSE 13640
// sRemote := true ;
13632: LD_ADDR_EXP 60
13636: PUSH
13637: LD_INT 1
13639: ST_TO_ADDR
// if p3 = 21 then
13640: LD_VAR 0 3
13644: PUSH
13645: LD_INT 21
13647: EQUAL
13648: IFFALSE 13658
// sPowell := true ;
13650: LD_ADDR_EXP 61
13654: PUSH
13655: LD_INT 1
13657: ST_TO_ADDR
// if p3 = 22 then
13658: LD_VAR 0 3
13662: PUSH
13663: LD_INT 22
13665: EQUAL
13666: IFFALSE 13676
// sTeleport := true ;
13668: LD_ADDR_EXP 64
13672: PUSH
13673: LD_INT 1
13675: ST_TO_ADDR
// if p3 = 23 then
13676: LD_VAR 0 3
13680: PUSH
13681: LD_INT 23
13683: EQUAL
13684: IFFALSE 13694
// sOilTower := true ;
13686: LD_ADDR_EXP 66
13690: PUSH
13691: LD_INT 1
13693: ST_TO_ADDR
// if p3 = 24 then
13694: LD_VAR 0 3
13698: PUSH
13699: LD_INT 24
13701: EQUAL
13702: IFFALSE 13712
// sShovel := true ;
13704: LD_ADDR_EXP 67
13708: PUSH
13709: LD_INT 1
13711: ST_TO_ADDR
// if p3 = 25 then
13712: LD_VAR 0 3
13716: PUSH
13717: LD_INT 25
13719: EQUAL
13720: IFFALSE 13730
// sSheik := true ;
13722: LD_ADDR_EXP 68
13726: PUSH
13727: LD_INT 1
13729: ST_TO_ADDR
// if p3 = 26 then
13730: LD_VAR 0 3
13734: PUSH
13735: LD_INT 26
13737: EQUAL
13738: IFFALSE 13748
// sEarthquake := true ;
13740: LD_ADDR_EXP 70
13744: PUSH
13745: LD_INT 1
13747: ST_TO_ADDR
// if p3 = 27 then
13748: LD_VAR 0 3
13752: PUSH
13753: LD_INT 27
13755: EQUAL
13756: IFFALSE 13766
// sAI := true ;
13758: LD_ADDR_EXP 71
13762: PUSH
13763: LD_INT 1
13765: ST_TO_ADDR
// if p3 = 28 then
13766: LD_VAR 0 3
13770: PUSH
13771: LD_INT 28
13773: EQUAL
13774: IFFALSE 13784
// sCargo := true ;
13776: LD_ADDR_EXP 74
13780: PUSH
13781: LD_INT 1
13783: ST_TO_ADDR
// if p3 = 29 then
13784: LD_VAR 0 3
13788: PUSH
13789: LD_INT 29
13791: EQUAL
13792: IFFALSE 13802
// sDLaser := true ;
13794: LD_ADDR_EXP 75
13798: PUSH
13799: LD_INT 1
13801: ST_TO_ADDR
// if p3 = 30 then
13802: LD_VAR 0 3
13806: PUSH
13807: LD_INT 30
13809: EQUAL
13810: IFFALSE 13820
// sExchange := true ;
13812: LD_ADDR_EXP 76
13816: PUSH
13817: LD_INT 1
13819: ST_TO_ADDR
// if p3 = 31 then
13820: LD_VAR 0 3
13824: PUSH
13825: LD_INT 31
13827: EQUAL
13828: IFFALSE 13838
// sFac := true ;
13830: LD_ADDR_EXP 77
13834: PUSH
13835: LD_INT 1
13837: ST_TO_ADDR
// if p3 = 32 then
13838: LD_VAR 0 3
13842: PUSH
13843: LD_INT 32
13845: EQUAL
13846: IFFALSE 13856
// sPower := true ;
13848: LD_ADDR_EXP 78
13852: PUSH
13853: LD_INT 1
13855: ST_TO_ADDR
// if p3 = 33 then
13856: LD_VAR 0 3
13860: PUSH
13861: LD_INT 33
13863: EQUAL
13864: IFFALSE 13874
// sRandom := true ;
13866: LD_ADDR_EXP 79
13870: PUSH
13871: LD_INT 1
13873: ST_TO_ADDR
// if p3 = 34 then
13874: LD_VAR 0 3
13878: PUSH
13879: LD_INT 34
13881: EQUAL
13882: IFFALSE 13892
// sShield := true ;
13884: LD_ADDR_EXP 80
13888: PUSH
13889: LD_INT 1
13891: ST_TO_ADDR
// if p3 = 35 then
13892: LD_VAR 0 3
13896: PUSH
13897: LD_INT 35
13899: EQUAL
13900: IFFALSE 13910
// sTime := true ;
13902: LD_ADDR_EXP 81
13906: PUSH
13907: LD_INT 1
13909: ST_TO_ADDR
// if p3 = 36 then
13910: LD_VAR 0 3
13914: PUSH
13915: LD_INT 36
13917: EQUAL
13918: IFFALSE 13928
// sTools := true ;
13920: LD_ADDR_EXP 82
13924: PUSH
13925: LD_INT 1
13927: ST_TO_ADDR
// if p3 = 101 then
13928: LD_VAR 0 3
13932: PUSH
13933: LD_INT 101
13935: EQUAL
13936: IFFALSE 13946
// sSold := true ;
13938: LD_ADDR_EXP 47
13942: PUSH
13943: LD_INT 1
13945: ST_TO_ADDR
// if p3 = 102 then
13946: LD_VAR 0 3
13950: PUSH
13951: LD_INT 102
13953: EQUAL
13954: IFFALSE 13964
// sDiff := true ;
13956: LD_ADDR_EXP 48
13960: PUSH
13961: LD_INT 1
13963: ST_TO_ADDR
// if p3 = 103 then
13964: LD_VAR 0 3
13968: PUSH
13969: LD_INT 103
13971: EQUAL
13972: IFFALSE 13982
// sFog := true ;
13974: LD_ADDR_EXP 51
13978: PUSH
13979: LD_INT 1
13981: ST_TO_ADDR
// if p3 = 104 then
13982: LD_VAR 0 3
13986: PUSH
13987: LD_INT 104
13989: EQUAL
13990: IFFALSE 14000
// sReset := true ;
13992: LD_ADDR_EXP 52
13996: PUSH
13997: LD_INT 1
13999: ST_TO_ADDR
// if p3 = 105 then
14000: LD_VAR 0 3
14004: PUSH
14005: LD_INT 105
14007: EQUAL
14008: IFFALSE 14018
// sSun := true ;
14010: LD_ADDR_EXP 53
14014: PUSH
14015: LD_INT 1
14017: ST_TO_ADDR
// if p3 = 106 then
14018: LD_VAR 0 3
14022: PUSH
14023: LD_INT 106
14025: EQUAL
14026: IFFALSE 14036
// sTiger := true ;
14028: LD_ADDR_EXP 49
14032: PUSH
14033: LD_INT 1
14035: ST_TO_ADDR
// if p3 = 107 then
14036: LD_VAR 0 3
14040: PUSH
14041: LD_INT 107
14043: EQUAL
14044: IFFALSE 14054
// sBomb := true ;
14046: LD_ADDR_EXP 50
14050: PUSH
14051: LD_INT 1
14053: ST_TO_ADDR
// if p3 = 108 then
14054: LD_VAR 0 3
14058: PUSH
14059: LD_INT 108
14061: EQUAL
14062: IFFALSE 14072
// sWound := true ;
14064: LD_ADDR_EXP 58
14068: PUSH
14069: LD_INT 1
14071: ST_TO_ADDR
// if p3 = 109 then
14072: LD_VAR 0 3
14076: PUSH
14077: LD_INT 109
14079: EQUAL
14080: IFFALSE 14090
// sBetray := true ;
14082: LD_ADDR_EXP 62
14086: PUSH
14087: LD_INT 1
14089: ST_TO_ADDR
// if p3 = 110 then
14090: LD_VAR 0 3
14094: PUSH
14095: LD_INT 110
14097: EQUAL
14098: IFFALSE 14108
// sContamin := true ;
14100: LD_ADDR_EXP 63
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// if p3 = 111 then
14108: LD_VAR 0 3
14112: PUSH
14113: LD_INT 111
14115: EQUAL
14116: IFFALSE 14126
// sOil := true ;
14118: LD_ADDR_EXP 65
14122: PUSH
14123: LD_INT 1
14125: ST_TO_ADDR
// if p3 = 112 then
14126: LD_VAR 0 3
14130: PUSH
14131: LD_INT 112
14133: EQUAL
14134: IFFALSE 14144
// sStu := true ;
14136: LD_ADDR_EXP 69
14140: PUSH
14141: LD_INT 1
14143: ST_TO_ADDR
// if p3 = 113 then
14144: LD_VAR 0 3
14148: PUSH
14149: LD_INT 113
14151: EQUAL
14152: IFFALSE 14162
// sBazooka := true ;
14154: LD_ADDR_EXP 72
14158: PUSH
14159: LD_INT 1
14161: ST_TO_ADDR
// if p3 = 114 then
14162: LD_VAR 0 3
14166: PUSH
14167: LD_INT 114
14169: EQUAL
14170: IFFALSE 14180
// sMortar := true ;
14172: LD_ADDR_EXP 73
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// if p3 = 115 then
14180: LD_VAR 0 3
14184: PUSH
14185: LD_INT 115
14187: EQUAL
14188: IFFALSE 14198
// sRanger := true ;
14190: LD_ADDR_EXP 83
14194: PUSH
14195: LD_INT 1
14197: ST_TO_ADDR
// end ; end ;
14198: PPOPN 6
14200: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
14201: LD_EXP 30
14205: PUSH
14206: LD_EXP 35
14210: AND
14211: IFFALSE 14335
14213: GO 14215
14215: DISABLE
14216: LD_INT 0
14218: PPUSH
14219: PPUSH
// begin enable ;
14220: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
14221: LD_ADDR_VAR 0 2
14225: PUSH
14226: LD_INT 22
14228: PUSH
14229: LD_OWVAR 2
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 2
14240: PUSH
14241: LD_INT 34
14243: PUSH
14244: LD_INT 7
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: LD_INT 34
14253: PUSH
14254: LD_INT 45
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: LD_INT 34
14263: PUSH
14264: LD_INT 28
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 34
14273: PUSH
14274: LD_INT 47
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// if not tmp then
14297: LD_VAR 0 2
14301: NOT
14302: IFFALSE 14306
// exit ;
14304: GO 14335
// for i in tmp do
14306: LD_ADDR_VAR 0 1
14310: PUSH
14311: LD_VAR 0 2
14315: PUSH
14316: FOR_IN
14317: IFFALSE 14333
// begin SetLives ( i , 0 ) ;
14319: LD_VAR 0 1
14323: PPUSH
14324: LD_INT 0
14326: PPUSH
14327: CALL_OW 234
// end ;
14331: GO 14316
14333: POP
14334: POP
// end ;
14335: PPOPN 2
14337: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
14338: LD_EXP 30
14342: PUSH
14343: LD_EXP 36
14347: AND
14348: IFFALSE 14432
14350: GO 14352
14352: DISABLE
14353: LD_INT 0
14355: PPUSH
14356: PPUSH
// begin enable ;
14357: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
14358: LD_ADDR_VAR 0 2
14362: PUSH
14363: LD_INT 22
14365: PUSH
14366: LD_OWVAR 2
14370: PUSH
14371: EMPTY
14372: LIST
14373: LIST
14374: PUSH
14375: LD_INT 32
14377: PUSH
14378: LD_INT 3
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PUSH
14385: EMPTY
14386: LIST
14387: LIST
14388: PPUSH
14389: CALL_OW 69
14393: ST_TO_ADDR
// if not tmp then
14394: LD_VAR 0 2
14398: NOT
14399: IFFALSE 14403
// exit ;
14401: GO 14432
// for i in tmp do
14403: LD_ADDR_VAR 0 1
14407: PUSH
14408: LD_VAR 0 2
14412: PUSH
14413: FOR_IN
14414: IFFALSE 14430
// begin SetLives ( i , 0 ) ;
14416: LD_VAR 0 1
14420: PPUSH
14421: LD_INT 0
14423: PPUSH
14424: CALL_OW 234
// end ;
14428: GO 14413
14430: POP
14431: POP
// end ;
14432: PPOPN 2
14434: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
14435: LD_EXP 30
14439: PUSH
14440: LD_EXP 33
14444: AND
14445: IFFALSE 14538
14447: GO 14449
14449: DISABLE
14450: LD_INT 0
14452: PPUSH
// begin enable ;
14453: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
14454: LD_ADDR_VAR 0 1
14458: PUSH
14459: LD_INT 22
14461: PUSH
14462: LD_OWVAR 2
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PUSH
14471: LD_INT 2
14473: PUSH
14474: LD_INT 25
14476: PUSH
14477: LD_INT 5
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PUSH
14484: LD_INT 25
14486: PUSH
14487: LD_INT 9
14489: PUSH
14490: EMPTY
14491: LIST
14492: LIST
14493: PUSH
14494: LD_INT 25
14496: PUSH
14497: LD_INT 8
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: PPUSH
14514: CALL_OW 69
14518: PUSH
14519: FOR_IN
14520: IFFALSE 14536
// begin SetClass ( i , 1 ) ;
14522: LD_VAR 0 1
14526: PPUSH
14527: LD_INT 1
14529: PPUSH
14530: CALL_OW 336
// end ;
14534: GO 14519
14536: POP
14537: POP
// end ;
14538: PPOPN 1
14540: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
14541: LD_EXP 30
14545: PUSH
14546: LD_EXP 34
14550: AND
14551: PUSH
14552: LD_OWVAR 65
14556: PUSH
14557: LD_INT 7
14559: LESS
14560: AND
14561: IFFALSE 14575
14563: GO 14565
14565: DISABLE
// begin enable ;
14566: ENABLE
// game_speed := 7 ;
14567: LD_ADDR_OWVAR 65
14571: PUSH
14572: LD_INT 7
14574: ST_TO_ADDR
// end ;
14575: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
14576: LD_EXP 30
14580: PUSH
14581: LD_EXP 37
14585: AND
14586: IFFALSE 14788
14588: GO 14590
14590: DISABLE
14591: LD_INT 0
14593: PPUSH
14594: PPUSH
14595: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
14596: LD_ADDR_VAR 0 3
14600: PUSH
14601: LD_INT 81
14603: PUSH
14604: LD_OWVAR 2
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 21
14615: PUSH
14616: LD_INT 1
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PPUSH
14627: CALL_OW 69
14631: ST_TO_ADDR
// if not tmp then
14632: LD_VAR 0 3
14636: NOT
14637: IFFALSE 14641
// exit ;
14639: GO 14788
// if tmp > 5 then
14641: LD_VAR 0 3
14645: PUSH
14646: LD_INT 5
14648: GREATER
14649: IFFALSE 14661
// k := 5 else
14651: LD_ADDR_VAR 0 2
14655: PUSH
14656: LD_INT 5
14658: ST_TO_ADDR
14659: GO 14671
// k := tmp ;
14661: LD_ADDR_VAR 0 2
14665: PUSH
14666: LD_VAR 0 3
14670: ST_TO_ADDR
// for i := 1 to k do
14671: LD_ADDR_VAR 0 1
14675: PUSH
14676: DOUBLE
14677: LD_INT 1
14679: DEC
14680: ST_TO_ADDR
14681: LD_VAR 0 2
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14786
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
14689: LD_VAR 0 3
14693: PUSH
14694: LD_VAR 0 1
14698: ARRAY
14699: PPUSH
14700: LD_VAR 0 1
14704: PUSH
14705: LD_INT 4
14707: MOD
14708: PUSH
14709: LD_INT 1
14711: PLUS
14712: PPUSH
14713: CALL_OW 259
14717: PUSH
14718: LD_INT 10
14720: LESS
14721: IFFALSE 14784
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
14723: LD_VAR 0 3
14727: PUSH
14728: LD_VAR 0 1
14732: ARRAY
14733: PPUSH
14734: LD_VAR 0 1
14738: PUSH
14739: LD_INT 4
14741: MOD
14742: PUSH
14743: LD_INT 1
14745: PLUS
14746: PPUSH
14747: LD_VAR 0 3
14751: PUSH
14752: LD_VAR 0 1
14756: ARRAY
14757: PPUSH
14758: LD_VAR 0 1
14762: PUSH
14763: LD_INT 4
14765: MOD
14766: PUSH
14767: LD_INT 1
14769: PLUS
14770: PPUSH
14771: CALL_OW 259
14775: PUSH
14776: LD_INT 1
14778: PLUS
14779: PPUSH
14780: CALL_OW 237
14784: GO 14686
14786: POP
14787: POP
// end ;
14788: PPOPN 3
14790: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
14791: LD_EXP 30
14795: PUSH
14796: LD_EXP 38
14800: AND
14801: IFFALSE 14821
14803: GO 14805
14805: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
14806: LD_INT 4
14808: PPUSH
14809: LD_OWVAR 2
14813: PPUSH
14814: LD_INT 0
14816: PPUSH
14817: CALL_OW 324
14821: END
// every 0 0$1 trigger StreamModeActive and sShovel do
14822: LD_EXP 30
14826: PUSH
14827: LD_EXP 67
14831: AND
14832: IFFALSE 14852
14834: GO 14836
14836: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
14837: LD_INT 19
14839: PPUSH
14840: LD_OWVAR 2
14844: PPUSH
14845: LD_INT 0
14847: PPUSH
14848: CALL_OW 324
14852: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
14853: LD_EXP 30
14857: PUSH
14858: LD_EXP 39
14862: AND
14863: IFFALSE 14965
14865: GO 14867
14867: DISABLE
14868: LD_INT 0
14870: PPUSH
14871: PPUSH
// begin enable ;
14872: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
14873: LD_ADDR_VAR 0 2
14877: PUSH
14878: LD_INT 22
14880: PUSH
14881: LD_OWVAR 2
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: PUSH
14890: LD_INT 2
14892: PUSH
14893: LD_INT 34
14895: PUSH
14896: LD_INT 11
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 34
14905: PUSH
14906: LD_INT 30
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp then
14927: LD_VAR 0 2
14931: NOT
14932: IFFALSE 14936
// exit ;
14934: GO 14965
// for i in tmp do
14936: LD_ADDR_VAR 0 1
14940: PUSH
14941: LD_VAR 0 2
14945: PUSH
14946: FOR_IN
14947: IFFALSE 14963
// begin SetLives ( i , 0 ) ;
14949: LD_VAR 0 1
14953: PPUSH
14954: LD_INT 0
14956: PPUSH
14957: CALL_OW 234
// end ;
14961: GO 14946
14963: POP
14964: POP
// end ;
14965: PPOPN 2
14967: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14968: LD_EXP 30
14972: PUSH
14973: LD_EXP 40
14977: AND
14978: IFFALSE 14998
14980: GO 14982
14982: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14983: LD_INT 32
14985: PPUSH
14986: LD_OWVAR 2
14990: PPUSH
14991: LD_INT 0
14993: PPUSH
14994: CALL_OW 324
14998: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14999: LD_EXP 30
15003: PUSH
15004: LD_EXP 41
15008: AND
15009: IFFALSE 15190
15011: GO 15013
15013: DISABLE
15014: LD_INT 0
15016: PPUSH
15017: PPUSH
15018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
15019: LD_ADDR_VAR 0 2
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_OWVAR 2
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PUSH
15036: LD_INT 33
15038: PUSH
15039: LD_INT 3
15041: PUSH
15042: EMPTY
15043: LIST
15044: LIST
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PPUSH
15050: CALL_OW 69
15054: ST_TO_ADDR
// if not tmp then
15055: LD_VAR 0 2
15059: NOT
15060: IFFALSE 15064
// exit ;
15062: GO 15190
// side := 0 ;
15064: LD_ADDR_VAR 0 3
15068: PUSH
15069: LD_INT 0
15071: ST_TO_ADDR
// for i := 1 to 8 do
15072: LD_ADDR_VAR 0 1
15076: PUSH
15077: DOUBLE
15078: LD_INT 1
15080: DEC
15081: ST_TO_ADDR
15082: LD_INT 8
15084: PUSH
15085: FOR_TO
15086: IFFALSE 15134
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
15088: LD_OWVAR 2
15092: PUSH
15093: LD_VAR 0 1
15097: NONEQUAL
15098: PUSH
15099: LD_OWVAR 2
15103: PPUSH
15104: LD_VAR 0 1
15108: PPUSH
15109: CALL_OW 81
15113: PUSH
15114: LD_INT 2
15116: EQUAL
15117: AND
15118: IFFALSE 15132
// begin side := i ;
15120: LD_ADDR_VAR 0 3
15124: PUSH
15125: LD_VAR 0 1
15129: ST_TO_ADDR
// break ;
15130: GO 15134
// end ;
15132: GO 15085
15134: POP
15135: POP
// if not side then
15136: LD_VAR 0 3
15140: NOT
15141: IFFALSE 15145
// exit ;
15143: GO 15190
// for i := 1 to tmp do
15145: LD_ADDR_VAR 0 1
15149: PUSH
15150: DOUBLE
15151: LD_INT 1
15153: DEC
15154: ST_TO_ADDR
15155: LD_VAR 0 2
15159: PUSH
15160: FOR_TO
15161: IFFALSE 15188
// if Prob ( 60 ) then
15163: LD_INT 60
15165: PPUSH
15166: CALL_OW 13
15170: IFFALSE 15186
// SetSide ( i , side ) ;
15172: LD_VAR 0 1
15176: PPUSH
15177: LD_VAR 0 3
15181: PPUSH
15182: CALL_OW 235
15186: GO 15160
15188: POP
15189: POP
// end ;
15190: PPOPN 3
15192: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
15193: LD_EXP 30
15197: PUSH
15198: LD_EXP 43
15202: AND
15203: IFFALSE 15322
15205: GO 15207
15207: DISABLE
15208: LD_INT 0
15210: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
15211: LD_ADDR_VAR 0 1
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_OWVAR 2
15223: PUSH
15224: EMPTY
15225: LIST
15226: LIST
15227: PUSH
15228: LD_INT 21
15230: PUSH
15231: LD_INT 1
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: LD_INT 23
15243: PUSH
15244: LD_INT 0
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: PUSH
15255: EMPTY
15256: LIST
15257: LIST
15258: LIST
15259: PPUSH
15260: CALL_OW 69
15264: PUSH
15265: FOR_IN
15266: IFFALSE 15320
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
15268: LD_VAR 0 1
15272: PPUSH
15273: CALL_OW 257
15277: PUSH
15278: LD_INT 1
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 3
15286: PUSH
15287: LD_INT 4
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: LIST
15294: LIST
15295: IN
15296: IFFALSE 15318
// SetClass ( un , rand ( 1 , 4 ) ) ;
15298: LD_VAR 0 1
15302: PPUSH
15303: LD_INT 1
15305: PPUSH
15306: LD_INT 4
15308: PPUSH
15309: CALL_OW 12
15313: PPUSH
15314: CALL_OW 336
15318: GO 15265
15320: POP
15321: POP
// end ;
15322: PPOPN 1
15324: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
15325: LD_EXP 30
15329: PUSH
15330: LD_EXP 42
15334: AND
15335: IFFALSE 15414
15337: GO 15339
15339: DISABLE
15340: LD_INT 0
15342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15343: LD_ADDR_VAR 0 1
15347: PUSH
15348: LD_INT 22
15350: PUSH
15351: LD_OWVAR 2
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: LD_INT 21
15362: PUSH
15363: LD_INT 3
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PPUSH
15374: CALL_OW 69
15378: ST_TO_ADDR
// if not tmp then
15379: LD_VAR 0 1
15383: NOT
15384: IFFALSE 15388
// exit ;
15386: GO 15414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
15388: LD_VAR 0 1
15392: PUSH
15393: LD_INT 1
15395: PPUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 12
15405: ARRAY
15406: PPUSH
15407: LD_INT 100
15409: PPUSH
15410: CALL_OW 234
// end ;
15414: PPOPN 1
15416: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
15417: LD_EXP 30
15421: PUSH
15422: LD_EXP 44
15426: AND
15427: IFFALSE 15525
15429: GO 15431
15431: DISABLE
15432: LD_INT 0
15434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15435: LD_ADDR_VAR 0 1
15439: PUSH
15440: LD_INT 22
15442: PUSH
15443: LD_OWVAR 2
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PUSH
15452: LD_INT 21
15454: PUSH
15455: LD_INT 1
15457: PUSH
15458: EMPTY
15459: LIST
15460: LIST
15461: PUSH
15462: EMPTY
15463: LIST
15464: LIST
15465: PPUSH
15466: CALL_OW 69
15470: ST_TO_ADDR
// if not tmp then
15471: LD_VAR 0 1
15475: NOT
15476: IFFALSE 15480
// exit ;
15478: GO 15525
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
15480: LD_VAR 0 1
15484: PUSH
15485: LD_INT 1
15487: PPUSH
15488: LD_VAR 0 1
15492: PPUSH
15493: CALL_OW 12
15497: ARRAY
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 4
15504: PPUSH
15505: CALL_OW 12
15509: PPUSH
15510: LD_INT 3000
15512: PPUSH
15513: LD_INT 9000
15515: PPUSH
15516: CALL_OW 12
15520: PPUSH
15521: CALL_OW 492
// end ;
15525: PPOPN 1
15527: END
// every 0 0$1 trigger StreamModeActive and sDepot do
15528: LD_EXP 30
15532: PUSH
15533: LD_EXP 45
15537: AND
15538: IFFALSE 15558
15540: GO 15542
15542: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
15543: LD_INT 1
15545: PPUSH
15546: LD_OWVAR 2
15550: PPUSH
15551: LD_INT 0
15553: PPUSH
15554: CALL_OW 324
15558: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
15559: LD_EXP 30
15563: PUSH
15564: LD_EXP 46
15568: AND
15569: IFFALSE 15652
15571: GO 15573
15573: DISABLE
15574: LD_INT 0
15576: PPUSH
15577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15578: LD_ADDR_VAR 0 2
15582: PUSH
15583: LD_INT 22
15585: PUSH
15586: LD_OWVAR 2
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PUSH
15595: LD_INT 21
15597: PUSH
15598: LD_INT 3
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PPUSH
15609: CALL_OW 69
15613: ST_TO_ADDR
// if not tmp then
15614: LD_VAR 0 2
15618: NOT
15619: IFFALSE 15623
// exit ;
15621: GO 15652
// for i in tmp do
15623: LD_ADDR_VAR 0 1
15627: PUSH
15628: LD_VAR 0 2
15632: PUSH
15633: FOR_IN
15634: IFFALSE 15650
// SetBLevel ( i , 10 ) ;
15636: LD_VAR 0 1
15640: PPUSH
15641: LD_INT 10
15643: PPUSH
15644: CALL_OW 241
15648: GO 15633
15650: POP
15651: POP
// end ;
15652: PPOPN 2
15654: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
15655: LD_EXP 30
15659: PUSH
15660: LD_EXP 47
15664: AND
15665: IFFALSE 15776
15667: GO 15669
15669: DISABLE
15670: LD_INT 0
15672: PPUSH
15673: PPUSH
15674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15675: LD_ADDR_VAR 0 3
15679: PUSH
15680: LD_INT 22
15682: PUSH
15683: LD_OWVAR 2
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: LD_INT 25
15694: PUSH
15695: LD_INT 1
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PPUSH
15706: CALL_OW 69
15710: ST_TO_ADDR
// if not tmp then
15711: LD_VAR 0 3
15715: NOT
15716: IFFALSE 15720
// exit ;
15718: GO 15776
// un := tmp [ rand ( 1 , tmp ) ] ;
15720: LD_ADDR_VAR 0 2
15724: PUSH
15725: LD_VAR 0 3
15729: PUSH
15730: LD_INT 1
15732: PPUSH
15733: LD_VAR 0 3
15737: PPUSH
15738: CALL_OW 12
15742: ARRAY
15743: ST_TO_ADDR
// if Crawls ( un ) then
15744: LD_VAR 0 2
15748: PPUSH
15749: CALL_OW 318
15753: IFFALSE 15764
// ComWalk ( un ) ;
15755: LD_VAR 0 2
15759: PPUSH
15760: CALL_OW 138
// SetClass ( un , class_sniper ) ;
15764: LD_VAR 0 2
15768: PPUSH
15769: LD_INT 5
15771: PPUSH
15772: CALL_OW 336
// end ;
15776: PPOPN 3
15778: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
15779: LD_EXP 30
15783: PUSH
15784: LD_EXP 48
15788: AND
15789: PUSH
15790: LD_OWVAR 67
15794: PUSH
15795: LD_INT 3
15797: LESS
15798: AND
15799: IFFALSE 15818
15801: GO 15803
15803: DISABLE
// Difficulty := Difficulty + 1 ;
15804: LD_ADDR_OWVAR 67
15808: PUSH
15809: LD_OWVAR 67
15813: PUSH
15814: LD_INT 1
15816: PLUS
15817: ST_TO_ADDR
15818: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
15819: LD_EXP 30
15823: PUSH
15824: LD_EXP 49
15828: AND
15829: IFFALSE 15932
15831: GO 15833
15833: DISABLE
15834: LD_INT 0
15836: PPUSH
// begin for i := 1 to 5 do
15837: LD_ADDR_VAR 0 1
15841: PUSH
15842: DOUBLE
15843: LD_INT 1
15845: DEC
15846: ST_TO_ADDR
15847: LD_INT 5
15849: PUSH
15850: FOR_TO
15851: IFFALSE 15930
// begin uc_nation := nation_nature ;
15853: LD_ADDR_OWVAR 21
15857: PUSH
15858: LD_INT 0
15860: ST_TO_ADDR
// uc_side := 0 ;
15861: LD_ADDR_OWVAR 20
15865: PUSH
15866: LD_INT 0
15868: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15869: LD_ADDR_OWVAR 29
15873: PUSH
15874: LD_INT 12
15876: PUSH
15877: LD_INT 12
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: ST_TO_ADDR
// hc_agressivity := 20 ;
15884: LD_ADDR_OWVAR 35
15888: PUSH
15889: LD_INT 20
15891: ST_TO_ADDR
// hc_class := class_tiger ;
15892: LD_ADDR_OWVAR 28
15896: PUSH
15897: LD_INT 14
15899: ST_TO_ADDR
// hc_gallery :=  ;
15900: LD_ADDR_OWVAR 33
15904: PUSH
15905: LD_STRING 
15907: ST_TO_ADDR
// hc_name :=  ;
15908: LD_ADDR_OWVAR 26
15912: PUSH
15913: LD_STRING 
15915: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15916: CALL_OW 44
15920: PPUSH
15921: LD_INT 0
15923: PPUSH
15924: CALL_OW 51
// end ;
15928: GO 15850
15930: POP
15931: POP
// end ;
15932: PPOPN 1
15934: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15935: LD_EXP 30
15939: PUSH
15940: LD_EXP 50
15944: AND
15945: IFFALSE 15954
15947: GO 15949
15949: DISABLE
// StreamSibBomb ;
15950: CALL 15955 0 0
15954: END
// export function StreamSibBomb ; var i , x , y ; begin
15955: LD_INT 0
15957: PPUSH
15958: PPUSH
15959: PPUSH
15960: PPUSH
// result := false ;
15961: LD_ADDR_VAR 0 1
15965: PUSH
15966: LD_INT 0
15968: ST_TO_ADDR
// for i := 1 to 16 do
15969: LD_ADDR_VAR 0 2
15973: PUSH
15974: DOUBLE
15975: LD_INT 1
15977: DEC
15978: ST_TO_ADDR
15979: LD_INT 16
15981: PUSH
15982: FOR_TO
15983: IFFALSE 16182
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15985: LD_ADDR_VAR 0 3
15989: PUSH
15990: LD_INT 10
15992: PUSH
15993: LD_INT 20
15995: PUSH
15996: LD_INT 30
15998: PUSH
15999: LD_INT 40
16001: PUSH
16002: LD_INT 50
16004: PUSH
16005: LD_INT 60
16007: PUSH
16008: LD_INT 70
16010: PUSH
16011: LD_INT 80
16013: PUSH
16014: LD_INT 90
16016: PUSH
16017: LD_INT 100
16019: PUSH
16020: LD_INT 110
16022: PUSH
16023: LD_INT 120
16025: PUSH
16026: LD_INT 130
16028: PUSH
16029: LD_INT 140
16031: PUSH
16032: LD_INT 150
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: PUSH
16052: LD_INT 1
16054: PPUSH
16055: LD_INT 15
16057: PPUSH
16058: CALL_OW 12
16062: ARRAY
16063: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16064: LD_ADDR_VAR 0 4
16068: PUSH
16069: LD_INT 10
16071: PUSH
16072: LD_INT 20
16074: PUSH
16075: LD_INT 30
16077: PUSH
16078: LD_INT 40
16080: PUSH
16081: LD_INT 50
16083: PUSH
16084: LD_INT 60
16086: PUSH
16087: LD_INT 70
16089: PUSH
16090: LD_INT 80
16092: PUSH
16093: LD_INT 90
16095: PUSH
16096: LD_INT 100
16098: PUSH
16099: LD_INT 110
16101: PUSH
16102: LD_INT 120
16104: PUSH
16105: LD_INT 130
16107: PUSH
16108: LD_INT 140
16110: PUSH
16111: LD_INT 150
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: LIST
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: LIST
16125: LIST
16126: LIST
16127: LIST
16128: LIST
16129: LIST
16130: PUSH
16131: LD_INT 1
16133: PPUSH
16134: LD_INT 15
16136: PPUSH
16137: CALL_OW 12
16141: ARRAY
16142: ST_TO_ADDR
// if ValidHex ( x , y ) then
16143: LD_VAR 0 3
16147: PPUSH
16148: LD_VAR 0 4
16152: PPUSH
16153: CALL_OW 488
16157: IFFALSE 16180
// begin result := [ x , y ] ;
16159: LD_ADDR_VAR 0 1
16163: PUSH
16164: LD_VAR 0 3
16168: PUSH
16169: LD_VAR 0 4
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: ST_TO_ADDR
// break ;
16178: GO 16182
// end ; end ;
16180: GO 15982
16182: POP
16183: POP
// if result then
16184: LD_VAR 0 1
16188: IFFALSE 16248
// begin ToLua ( playSibBomb() ) ;
16190: LD_STRING playSibBomb()
16192: PPUSH
16193: CALL_OW 559
// wait ( 0 0$14 ) ;
16197: LD_INT 490
16199: PPUSH
16200: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
16204: LD_VAR 0 1
16208: PUSH
16209: LD_INT 1
16211: ARRAY
16212: PPUSH
16213: LD_VAR 0 1
16217: PUSH
16218: LD_INT 2
16220: ARRAY
16221: PPUSH
16222: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
16226: LD_VAR 0 1
16230: PUSH
16231: LD_INT 1
16233: ARRAY
16234: PPUSH
16235: LD_VAR 0 1
16239: PUSH
16240: LD_INT 2
16242: ARRAY
16243: PPUSH
16244: CALL_OW 429
// end ; end ;
16248: LD_VAR 0 1
16252: RET
// every 0 0$1 trigger StreamModeActive and sReset do
16253: LD_EXP 30
16257: PUSH
16258: LD_EXP 52
16262: AND
16263: IFFALSE 16275
16265: GO 16267
16267: DISABLE
// YouLost (  ) ;
16268: LD_STRING 
16270: PPUSH
16271: CALL_OW 104
16275: END
// every 0 0$1 trigger StreamModeActive and sFog do
16276: LD_EXP 30
16280: PUSH
16281: LD_EXP 51
16285: AND
16286: IFFALSE 16300
16288: GO 16290
16290: DISABLE
// FogOff ( your_side ) ;
16291: LD_OWVAR 2
16295: PPUSH
16296: CALL_OW 344
16300: END
// every 0 0$1 trigger StreamModeActive and sSun do
16301: LD_EXP 30
16305: PUSH
16306: LD_EXP 53
16310: AND
16311: IFFALSE 16339
16313: GO 16315
16315: DISABLE
// begin solar_recharge_percent := 0 ;
16316: LD_ADDR_OWVAR 79
16320: PUSH
16321: LD_INT 0
16323: ST_TO_ADDR
// wait ( 5 5$00 ) ;
16324: LD_INT 10500
16326: PPUSH
16327: CALL_OW 67
// solar_recharge_percent := 100 ;
16331: LD_ADDR_OWVAR 79
16335: PUSH
16336: LD_INT 100
16338: ST_TO_ADDR
// end ;
16339: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
16340: LD_EXP 30
16344: PUSH
16345: LD_EXP 54
16349: AND
16350: IFFALSE 16589
16352: GO 16354
16354: DISABLE
16355: LD_INT 0
16357: PPUSH
16358: PPUSH
16359: PPUSH
// begin tmp := [ ] ;
16360: LD_ADDR_VAR 0 3
16364: PUSH
16365: EMPTY
16366: ST_TO_ADDR
// for i := 1 to 6 do
16367: LD_ADDR_VAR 0 1
16371: PUSH
16372: DOUBLE
16373: LD_INT 1
16375: DEC
16376: ST_TO_ADDR
16377: LD_INT 6
16379: PUSH
16380: FOR_TO
16381: IFFALSE 16486
// begin uc_nation := nation_nature ;
16383: LD_ADDR_OWVAR 21
16387: PUSH
16388: LD_INT 0
16390: ST_TO_ADDR
// uc_side := 0 ;
16391: LD_ADDR_OWVAR 20
16395: PUSH
16396: LD_INT 0
16398: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16399: LD_ADDR_OWVAR 29
16403: PUSH
16404: LD_INT 12
16406: PUSH
16407: LD_INT 12
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: ST_TO_ADDR
// hc_agressivity := 20 ;
16414: LD_ADDR_OWVAR 35
16418: PUSH
16419: LD_INT 20
16421: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
16422: LD_ADDR_OWVAR 28
16426: PUSH
16427: LD_INT 17
16429: ST_TO_ADDR
// hc_gallery :=  ;
16430: LD_ADDR_OWVAR 33
16434: PUSH
16435: LD_STRING 
16437: ST_TO_ADDR
// hc_name :=  ;
16438: LD_ADDR_OWVAR 26
16442: PUSH
16443: LD_STRING 
16445: ST_TO_ADDR
// un := CreateHuman ;
16446: LD_ADDR_VAR 0 2
16450: PUSH
16451: CALL_OW 44
16455: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
16456: LD_VAR 0 2
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL_OW 51
// tmp := tmp ^ un ;
16468: LD_ADDR_VAR 0 3
16472: PUSH
16473: LD_VAR 0 3
16477: PUSH
16478: LD_VAR 0 2
16482: ADD
16483: ST_TO_ADDR
// end ;
16484: GO 16380
16486: POP
16487: POP
// repeat wait ( 0 0$1 ) ;
16488: LD_INT 35
16490: PPUSH
16491: CALL_OW 67
// for un in tmp do
16495: LD_ADDR_VAR 0 2
16499: PUSH
16500: LD_VAR 0 3
16504: PUSH
16505: FOR_IN
16506: IFFALSE 16580
// begin if IsDead ( un ) then
16508: LD_VAR 0 2
16512: PPUSH
16513: CALL_OW 301
16517: IFFALSE 16537
// begin tmp := tmp diff un ;
16519: LD_ADDR_VAR 0 3
16523: PUSH
16524: LD_VAR 0 3
16528: PUSH
16529: LD_VAR 0 2
16533: DIFF
16534: ST_TO_ADDR
// continue ;
16535: GO 16505
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
16537: LD_VAR 0 2
16541: PPUSH
16542: LD_INT 3
16544: PUSH
16545: LD_INT 22
16547: PUSH
16548: LD_INT 0
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PPUSH
16559: CALL_OW 69
16563: PPUSH
16564: LD_VAR 0 2
16568: PPUSH
16569: CALL_OW 74
16573: PPUSH
16574: CALL_OW 115
// end ;
16578: GO 16505
16580: POP
16581: POP
// until not tmp ;
16582: LD_VAR 0 3
16586: NOT
16587: IFFALSE 16488
// end ;
16589: PPOPN 3
16591: END
// every 0 0$1 trigger StreamModeActive and sTroll do
16592: LD_EXP 30
16596: PUSH
16597: LD_EXP 55
16601: AND
16602: IFFALSE 16656
16604: GO 16606
16606: DISABLE
// begin ToLua ( displayTroll(); ) ;
16607: LD_STRING displayTroll();
16609: PPUSH
16610: CALL_OW 559
// wait ( 3 3$00 ) ;
16614: LD_INT 6300
16616: PPUSH
16617: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16621: LD_STRING hideTroll();
16623: PPUSH
16624: CALL_OW 559
// wait ( 1 1$00 ) ;
16628: LD_INT 2100
16630: PPUSH
16631: CALL_OW 67
// ToLua ( displayTroll(); ) ;
16635: LD_STRING displayTroll();
16637: PPUSH
16638: CALL_OW 559
// wait ( 1 1$00 ) ;
16642: LD_INT 2100
16644: PPUSH
16645: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16649: LD_STRING hideTroll();
16651: PPUSH
16652: CALL_OW 559
// end ;
16656: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
16657: LD_EXP 30
16661: PUSH
16662: LD_EXP 56
16666: AND
16667: IFFALSE 16730
16669: GO 16671
16671: DISABLE
16672: LD_INT 0
16674: PPUSH
// begin p := 0 ;
16675: LD_ADDR_VAR 0 1
16679: PUSH
16680: LD_INT 0
16682: ST_TO_ADDR
// repeat game_speed := 1 ;
16683: LD_ADDR_OWVAR 65
16687: PUSH
16688: LD_INT 1
16690: ST_TO_ADDR
// wait ( 0 0$1 ) ;
16691: LD_INT 35
16693: PPUSH
16694: CALL_OW 67
// p := p + 1 ;
16698: LD_ADDR_VAR 0 1
16702: PUSH
16703: LD_VAR 0 1
16707: PUSH
16708: LD_INT 1
16710: PLUS
16711: ST_TO_ADDR
// until p >= 60 ;
16712: LD_VAR 0 1
16716: PUSH
16717: LD_INT 60
16719: GREATEREQUAL
16720: IFFALSE 16683
// game_speed := 4 ;
16722: LD_ADDR_OWVAR 65
16726: PUSH
16727: LD_INT 4
16729: ST_TO_ADDR
// end ;
16730: PPOPN 1
16732: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
16733: LD_EXP 30
16737: PUSH
16738: LD_EXP 57
16742: AND
16743: IFFALSE 16889
16745: GO 16747
16747: DISABLE
16748: LD_INT 0
16750: PPUSH
16751: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16752: LD_ADDR_VAR 0 1
16756: PUSH
16757: LD_INT 22
16759: PUSH
16760: LD_OWVAR 2
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: LD_INT 2
16771: PUSH
16772: LD_INT 30
16774: PUSH
16775: LD_INT 0
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 30
16784: PUSH
16785: LD_INT 1
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: ST_TO_ADDR
// if not depot then
16806: LD_VAR 0 1
16810: NOT
16811: IFFALSE 16815
// exit ;
16813: GO 16889
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
16815: LD_ADDR_VAR 0 2
16819: PUSH
16820: LD_VAR 0 1
16824: PUSH
16825: LD_INT 1
16827: PPUSH
16828: LD_VAR 0 1
16832: PPUSH
16833: CALL_OW 12
16837: ARRAY
16838: PPUSH
16839: CALL_OW 274
16843: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
16844: LD_VAR 0 2
16848: PPUSH
16849: LD_INT 1
16851: PPUSH
16852: LD_INT 0
16854: PPUSH
16855: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
16859: LD_VAR 0 2
16863: PPUSH
16864: LD_INT 2
16866: PPUSH
16867: LD_INT 0
16869: PPUSH
16870: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
16874: LD_VAR 0 2
16878: PPUSH
16879: LD_INT 3
16881: PPUSH
16882: LD_INT 0
16884: PPUSH
16885: CALL_OW 277
// end ;
16889: PPOPN 2
16891: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16892: LD_EXP 30
16896: PUSH
16897: LD_EXP 58
16901: AND
16902: IFFALSE 16999
16904: GO 16906
16906: DISABLE
16907: LD_INT 0
16909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16910: LD_ADDR_VAR 0 1
16914: PUSH
16915: LD_INT 22
16917: PUSH
16918: LD_OWVAR 2
16922: PUSH
16923: EMPTY
16924: LIST
16925: LIST
16926: PUSH
16927: LD_INT 21
16929: PUSH
16930: LD_INT 1
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: LD_INT 3
16939: PUSH
16940: LD_INT 23
16942: PUSH
16943: LD_INT 0
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: EMPTY
16951: LIST
16952: LIST
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: LIST
16958: PPUSH
16959: CALL_OW 69
16963: ST_TO_ADDR
// if not tmp then
16964: LD_VAR 0 1
16968: NOT
16969: IFFALSE 16973
// exit ;
16971: GO 16999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16973: LD_VAR 0 1
16977: PUSH
16978: LD_INT 1
16980: PPUSH
16981: LD_VAR 0 1
16985: PPUSH
16986: CALL_OW 12
16990: ARRAY
16991: PPUSH
16992: LD_INT 200
16994: PPUSH
16995: CALL_OW 234
// end ;
16999: PPOPN 1
17001: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
17002: LD_EXP 30
17006: PUSH
17007: LD_EXP 59
17011: AND
17012: IFFALSE 17091
17014: GO 17016
17016: DISABLE
17017: LD_INT 0
17019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
17020: LD_ADDR_VAR 0 1
17024: PUSH
17025: LD_INT 22
17027: PUSH
17028: LD_OWVAR 2
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PUSH
17037: LD_INT 21
17039: PUSH
17040: LD_INT 2
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PPUSH
17051: CALL_OW 69
17055: ST_TO_ADDR
// if not tmp then
17056: LD_VAR 0 1
17060: NOT
17061: IFFALSE 17065
// exit ;
17063: GO 17091
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
17065: LD_VAR 0 1
17069: PUSH
17070: LD_INT 1
17072: PPUSH
17073: LD_VAR 0 1
17077: PPUSH
17078: CALL_OW 12
17082: ARRAY
17083: PPUSH
17084: LD_INT 60
17086: PPUSH
17087: CALL_OW 234
// end ;
17091: PPOPN 1
17093: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
17094: LD_EXP 30
17098: PUSH
17099: LD_EXP 60
17103: AND
17104: IFFALSE 17203
17106: GO 17108
17108: DISABLE
17109: LD_INT 0
17111: PPUSH
17112: PPUSH
// begin enable ;
17113: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
17114: LD_ADDR_VAR 0 1
17118: PUSH
17119: LD_INT 22
17121: PUSH
17122: LD_OWVAR 2
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 61
17133: PUSH
17134: EMPTY
17135: LIST
17136: PUSH
17137: LD_INT 33
17139: PUSH
17140: LD_INT 2
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: LIST
17151: PPUSH
17152: CALL_OW 69
17156: ST_TO_ADDR
// if not tmp then
17157: LD_VAR 0 1
17161: NOT
17162: IFFALSE 17166
// exit ;
17164: GO 17203
// for i in tmp do
17166: LD_ADDR_VAR 0 2
17170: PUSH
17171: LD_VAR 0 1
17175: PUSH
17176: FOR_IN
17177: IFFALSE 17201
// if IsControledBy ( i ) then
17179: LD_VAR 0 2
17183: PPUSH
17184: CALL_OW 312
17188: IFFALSE 17199
// ComUnlink ( i ) ;
17190: LD_VAR 0 2
17194: PPUSH
17195: CALL_OW 136
17199: GO 17176
17201: POP
17202: POP
// end ;
17203: PPOPN 2
17205: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
17206: LD_EXP 30
17210: PUSH
17211: LD_EXP 61
17215: AND
17216: IFFALSE 17356
17218: GO 17220
17220: DISABLE
17221: LD_INT 0
17223: PPUSH
17224: PPUSH
// begin ToLua ( displayPowell(); ) ;
17225: LD_STRING displayPowell();
17227: PPUSH
17228: CALL_OW 559
// uc_side := 0 ;
17232: LD_ADDR_OWVAR 20
17236: PUSH
17237: LD_INT 0
17239: ST_TO_ADDR
// uc_nation := 2 ;
17240: LD_ADDR_OWVAR 21
17244: PUSH
17245: LD_INT 2
17247: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
17248: LD_ADDR_OWVAR 37
17252: PUSH
17253: LD_INT 14
17255: ST_TO_ADDR
// vc_engine := engine_siberite ;
17256: LD_ADDR_OWVAR 39
17260: PUSH
17261: LD_INT 3
17263: ST_TO_ADDR
// vc_control := control_apeman ;
17264: LD_ADDR_OWVAR 38
17268: PUSH
17269: LD_INT 5
17271: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
17272: LD_ADDR_OWVAR 40
17276: PUSH
17277: LD_INT 29
17279: ST_TO_ADDR
// un := CreateVehicle ;
17280: LD_ADDR_VAR 0 2
17284: PUSH
17285: CALL_OW 45
17289: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17290: LD_VAR 0 2
17294: PPUSH
17295: LD_INT 1
17297: PPUSH
17298: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17302: LD_INT 35
17304: PPUSH
17305: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17309: LD_VAR 0 2
17313: PPUSH
17314: LD_INT 22
17316: PUSH
17317: LD_OWVAR 2
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PPUSH
17326: CALL_OW 69
17330: PPUSH
17331: LD_VAR 0 2
17335: PPUSH
17336: CALL_OW 74
17340: PPUSH
17341: CALL_OW 115
// until IsDead ( un ) ;
17345: LD_VAR 0 2
17349: PPUSH
17350: CALL_OW 301
17354: IFFALSE 17302
// end ;
17356: PPOPN 2
17358: END
// every 0 0$1 trigger StreamModeActive and sStu do
17359: LD_EXP 30
17363: PUSH
17364: LD_EXP 69
17368: AND
17369: IFFALSE 17385
17371: GO 17373
17373: DISABLE
// begin ToLua ( displayStucuk(); ) ;
17374: LD_STRING displayStucuk();
17376: PPUSH
17377: CALL_OW 559
// ResetFog ;
17381: CALL_OW 335
// end ;
17385: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
17386: LD_EXP 30
17390: PUSH
17391: LD_EXP 62
17395: AND
17396: IFFALSE 17537
17398: GO 17400
17400: DISABLE
17401: LD_INT 0
17403: PPUSH
17404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17405: LD_ADDR_VAR 0 2
17409: PUSH
17410: LD_INT 22
17412: PUSH
17413: LD_OWVAR 2
17417: PUSH
17418: EMPTY
17419: LIST
17420: LIST
17421: PUSH
17422: LD_INT 21
17424: PUSH
17425: LD_INT 1
17427: PUSH
17428: EMPTY
17429: LIST
17430: LIST
17431: PUSH
17432: EMPTY
17433: LIST
17434: LIST
17435: PPUSH
17436: CALL_OW 69
17440: ST_TO_ADDR
// if not tmp then
17441: LD_VAR 0 2
17445: NOT
17446: IFFALSE 17450
// exit ;
17448: GO 17537
// un := tmp [ rand ( 1 , tmp ) ] ;
17450: LD_ADDR_VAR 0 1
17454: PUSH
17455: LD_VAR 0 2
17459: PUSH
17460: LD_INT 1
17462: PPUSH
17463: LD_VAR 0 2
17467: PPUSH
17468: CALL_OW 12
17472: ARRAY
17473: ST_TO_ADDR
// SetSide ( un , 0 ) ;
17474: LD_VAR 0 1
17478: PPUSH
17479: LD_INT 0
17481: PPUSH
17482: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
17486: LD_VAR 0 1
17490: PPUSH
17491: LD_OWVAR 3
17495: PUSH
17496: LD_VAR 0 1
17500: DIFF
17501: PPUSH
17502: LD_VAR 0 1
17506: PPUSH
17507: CALL_OW 74
17511: PPUSH
17512: CALL_OW 115
// wait ( 0 0$20 ) ;
17516: LD_INT 700
17518: PPUSH
17519: CALL_OW 67
// SetSide ( un , your_side ) ;
17523: LD_VAR 0 1
17527: PPUSH
17528: LD_OWVAR 2
17532: PPUSH
17533: CALL_OW 235
// end ;
17537: PPOPN 2
17539: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
17540: LD_EXP 30
17544: PUSH
17545: LD_EXP 63
17549: AND
17550: IFFALSE 17656
17552: GO 17554
17554: DISABLE
17555: LD_INT 0
17557: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
17558: LD_ADDR_VAR 0 1
17562: PUSH
17563: LD_INT 22
17565: PUSH
17566: LD_OWVAR 2
17570: PUSH
17571: EMPTY
17572: LIST
17573: LIST
17574: PUSH
17575: LD_INT 2
17577: PUSH
17578: LD_INT 30
17580: PUSH
17581: LD_INT 0
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: PUSH
17588: LD_INT 30
17590: PUSH
17591: LD_INT 1
17593: PUSH
17594: EMPTY
17595: LIST
17596: LIST
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: LIST
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PPUSH
17607: CALL_OW 69
17611: ST_TO_ADDR
// if not depot then
17612: LD_VAR 0 1
17616: NOT
17617: IFFALSE 17621
// exit ;
17619: GO 17656
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
17621: LD_VAR 0 1
17625: PUSH
17626: LD_INT 1
17628: ARRAY
17629: PPUSH
17630: CALL_OW 250
17634: PPUSH
17635: LD_VAR 0 1
17639: PUSH
17640: LD_INT 1
17642: ARRAY
17643: PPUSH
17644: CALL_OW 251
17648: PPUSH
17649: LD_INT 70
17651: PPUSH
17652: CALL_OW 495
// end ;
17656: PPOPN 1
17658: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
17659: LD_EXP 30
17663: PUSH
17664: LD_EXP 64
17668: AND
17669: IFFALSE 17880
17671: GO 17673
17673: DISABLE
17674: LD_INT 0
17676: PPUSH
17677: PPUSH
17678: PPUSH
17679: PPUSH
17680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17681: LD_ADDR_VAR 0 5
17685: PUSH
17686: LD_INT 22
17688: PUSH
17689: LD_OWVAR 2
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 21
17700: PUSH
17701: LD_INT 1
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: PPUSH
17712: CALL_OW 69
17716: ST_TO_ADDR
// if not tmp then
17717: LD_VAR 0 5
17721: NOT
17722: IFFALSE 17726
// exit ;
17724: GO 17880
// for i in tmp do
17726: LD_ADDR_VAR 0 1
17730: PUSH
17731: LD_VAR 0 5
17735: PUSH
17736: FOR_IN
17737: IFFALSE 17878
// begin d := rand ( 0 , 5 ) ;
17739: LD_ADDR_VAR 0 4
17743: PUSH
17744: LD_INT 0
17746: PPUSH
17747: LD_INT 5
17749: PPUSH
17750: CALL_OW 12
17754: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
17755: LD_ADDR_VAR 0 2
17759: PUSH
17760: LD_VAR 0 1
17764: PPUSH
17765: CALL_OW 250
17769: PPUSH
17770: LD_VAR 0 4
17774: PPUSH
17775: LD_INT 3
17777: PPUSH
17778: LD_INT 12
17780: PPUSH
17781: CALL_OW 12
17785: PPUSH
17786: CALL_OW 272
17790: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
17791: LD_ADDR_VAR 0 3
17795: PUSH
17796: LD_VAR 0 1
17800: PPUSH
17801: CALL_OW 251
17805: PPUSH
17806: LD_VAR 0 4
17810: PPUSH
17811: LD_INT 3
17813: PPUSH
17814: LD_INT 12
17816: PPUSH
17817: CALL_OW 12
17821: PPUSH
17822: CALL_OW 273
17826: ST_TO_ADDR
// if ValidHex ( x , y ) then
17827: LD_VAR 0 2
17831: PPUSH
17832: LD_VAR 0 3
17836: PPUSH
17837: CALL_OW 488
17841: IFFALSE 17876
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
17843: LD_VAR 0 1
17847: PPUSH
17848: LD_VAR 0 2
17852: PPUSH
17853: LD_VAR 0 3
17857: PPUSH
17858: LD_INT 3
17860: PPUSH
17861: LD_INT 6
17863: PPUSH
17864: CALL_OW 12
17868: PPUSH
17869: LD_INT 1
17871: PPUSH
17872: CALL_OW 483
// end ;
17876: GO 17736
17878: POP
17879: POP
// end ;
17880: PPOPN 5
17882: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17883: LD_EXP 30
17887: PUSH
17888: LD_EXP 65
17892: AND
17893: IFFALSE 17987
17895: GO 17897
17897: DISABLE
17898: LD_INT 0
17900: PPUSH
17901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17902: LD_ADDR_VAR 0 2
17906: PUSH
17907: LD_INT 22
17909: PUSH
17910: LD_OWVAR 2
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PUSH
17919: LD_INT 32
17921: PUSH
17922: LD_INT 1
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: LD_INT 21
17931: PUSH
17932: LD_INT 2
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: LIST
17943: PPUSH
17944: CALL_OW 69
17948: ST_TO_ADDR
// if not tmp then
17949: LD_VAR 0 2
17953: NOT
17954: IFFALSE 17958
// exit ;
17956: GO 17987
// for i in tmp do
17958: LD_ADDR_VAR 0 1
17962: PUSH
17963: LD_VAR 0 2
17967: PUSH
17968: FOR_IN
17969: IFFALSE 17985
// SetFuel ( i , 0 ) ;
17971: LD_VAR 0 1
17975: PPUSH
17976: LD_INT 0
17978: PPUSH
17979: CALL_OW 240
17983: GO 17968
17985: POP
17986: POP
// end ;
17987: PPOPN 2
17989: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17990: LD_EXP 30
17994: PUSH
17995: LD_EXP 66
17999: AND
18000: IFFALSE 18066
18002: GO 18004
18004: DISABLE
18005: LD_INT 0
18007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18008: LD_ADDR_VAR 0 1
18012: PUSH
18013: LD_INT 22
18015: PUSH
18016: LD_OWVAR 2
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: PUSH
18025: LD_INT 30
18027: PUSH
18028: LD_INT 29
18030: PUSH
18031: EMPTY
18032: LIST
18033: LIST
18034: PUSH
18035: EMPTY
18036: LIST
18037: LIST
18038: PPUSH
18039: CALL_OW 69
18043: ST_TO_ADDR
// if not tmp then
18044: LD_VAR 0 1
18048: NOT
18049: IFFALSE 18053
// exit ;
18051: GO 18066
// DestroyUnit ( tmp [ 1 ] ) ;
18053: LD_VAR 0 1
18057: PUSH
18058: LD_INT 1
18060: ARRAY
18061: PPUSH
18062: CALL_OW 65
// end ;
18066: PPOPN 1
18068: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
18069: LD_EXP 30
18073: PUSH
18074: LD_EXP 68
18078: AND
18079: IFFALSE 18208
18081: GO 18083
18083: DISABLE
18084: LD_INT 0
18086: PPUSH
// begin uc_side := 0 ;
18087: LD_ADDR_OWVAR 20
18091: PUSH
18092: LD_INT 0
18094: ST_TO_ADDR
// uc_nation := nation_arabian ;
18095: LD_ADDR_OWVAR 21
18099: PUSH
18100: LD_INT 2
18102: ST_TO_ADDR
// hc_gallery :=  ;
18103: LD_ADDR_OWVAR 33
18107: PUSH
18108: LD_STRING 
18110: ST_TO_ADDR
// hc_name :=  ;
18111: LD_ADDR_OWVAR 26
18115: PUSH
18116: LD_STRING 
18118: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
18119: LD_INT 1
18121: PPUSH
18122: LD_INT 11
18124: PPUSH
18125: LD_INT 10
18127: PPUSH
18128: CALL_OW 380
// un := CreateHuman ;
18132: LD_ADDR_VAR 0 1
18136: PUSH
18137: CALL_OW 44
18141: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18142: LD_VAR 0 1
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18154: LD_INT 35
18156: PPUSH
18157: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18161: LD_VAR 0 1
18165: PPUSH
18166: LD_INT 22
18168: PUSH
18169: LD_OWVAR 2
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PPUSH
18178: CALL_OW 69
18182: PPUSH
18183: LD_VAR 0 1
18187: PPUSH
18188: CALL_OW 74
18192: PPUSH
18193: CALL_OW 115
// until IsDead ( un ) ;
18197: LD_VAR 0 1
18201: PPUSH
18202: CALL_OW 301
18206: IFFALSE 18154
// end ;
18208: PPOPN 1
18210: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
18211: LD_EXP 30
18215: PUSH
18216: LD_EXP 70
18220: AND
18221: IFFALSE 18233
18223: GO 18225
18225: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
18226: LD_STRING earthquake(getX(game), 0, 32)
18228: PPUSH
18229: CALL_OW 559
18233: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
18234: LD_EXP 30
18238: PUSH
18239: LD_EXP 71
18243: AND
18244: IFFALSE 18335
18246: GO 18248
18248: DISABLE
18249: LD_INT 0
18251: PPUSH
// begin enable ;
18252: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: LD_INT 22
18260: PUSH
18261: LD_OWVAR 2
18265: PUSH
18266: EMPTY
18267: LIST
18268: LIST
18269: PUSH
18270: LD_INT 21
18272: PUSH
18273: LD_INT 2
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: PUSH
18280: LD_INT 33
18282: PUSH
18283: LD_INT 3
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: EMPTY
18291: LIST
18292: LIST
18293: LIST
18294: PPUSH
18295: CALL_OW 69
18299: ST_TO_ADDR
// if not tmp then
18300: LD_VAR 0 1
18304: NOT
18305: IFFALSE 18309
// exit ;
18307: GO 18335
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18309: LD_VAR 0 1
18313: PUSH
18314: LD_INT 1
18316: PPUSH
18317: LD_VAR 0 1
18321: PPUSH
18322: CALL_OW 12
18326: ARRAY
18327: PPUSH
18328: LD_INT 1
18330: PPUSH
18331: CALL_OW 234
// end ;
18335: PPOPN 1
18337: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
18338: LD_EXP 30
18342: PUSH
18343: LD_EXP 72
18347: AND
18348: IFFALSE 18489
18350: GO 18352
18352: DISABLE
18353: LD_INT 0
18355: PPUSH
18356: PPUSH
18357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18358: LD_ADDR_VAR 0 3
18362: PUSH
18363: LD_INT 22
18365: PUSH
18366: LD_OWVAR 2
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 25
18377: PUSH
18378: LD_INT 1
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: PPUSH
18389: CALL_OW 69
18393: ST_TO_ADDR
// if not tmp then
18394: LD_VAR 0 3
18398: NOT
18399: IFFALSE 18403
// exit ;
18401: GO 18489
// un := tmp [ rand ( 1 , tmp ) ] ;
18403: LD_ADDR_VAR 0 2
18407: PUSH
18408: LD_VAR 0 3
18412: PUSH
18413: LD_INT 1
18415: PPUSH
18416: LD_VAR 0 3
18420: PPUSH
18421: CALL_OW 12
18425: ARRAY
18426: ST_TO_ADDR
// if Crawls ( un ) then
18427: LD_VAR 0 2
18431: PPUSH
18432: CALL_OW 318
18436: IFFALSE 18447
// ComWalk ( un ) ;
18438: LD_VAR 0 2
18442: PPUSH
18443: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
18447: LD_VAR 0 2
18451: PPUSH
18452: LD_INT 9
18454: PPUSH
18455: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
18459: LD_INT 28
18461: PPUSH
18462: LD_OWVAR 2
18466: PPUSH
18467: LD_INT 2
18469: PPUSH
18470: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
18474: LD_INT 29
18476: PPUSH
18477: LD_OWVAR 2
18481: PPUSH
18482: LD_INT 2
18484: PPUSH
18485: CALL_OW 322
// end ;
18489: PPOPN 3
18491: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
18492: LD_EXP 30
18496: PUSH
18497: LD_EXP 73
18501: AND
18502: IFFALSE 18613
18504: GO 18506
18506: DISABLE
18507: LD_INT 0
18509: PPUSH
18510: PPUSH
18511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18512: LD_ADDR_VAR 0 3
18516: PUSH
18517: LD_INT 22
18519: PUSH
18520: LD_OWVAR 2
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: PUSH
18529: LD_INT 25
18531: PUSH
18532: LD_INT 1
18534: PUSH
18535: EMPTY
18536: LIST
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 69
18547: ST_TO_ADDR
// if not tmp then
18548: LD_VAR 0 3
18552: NOT
18553: IFFALSE 18557
// exit ;
18555: GO 18613
// un := tmp [ rand ( 1 , tmp ) ] ;
18557: LD_ADDR_VAR 0 2
18561: PUSH
18562: LD_VAR 0 3
18566: PUSH
18567: LD_INT 1
18569: PPUSH
18570: LD_VAR 0 3
18574: PPUSH
18575: CALL_OW 12
18579: ARRAY
18580: ST_TO_ADDR
// if Crawls ( un ) then
18581: LD_VAR 0 2
18585: PPUSH
18586: CALL_OW 318
18590: IFFALSE 18601
// ComWalk ( un ) ;
18592: LD_VAR 0 2
18596: PPUSH
18597: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18601: LD_VAR 0 2
18605: PPUSH
18606: LD_INT 8
18608: PPUSH
18609: CALL_OW 336
// end ;
18613: PPOPN 3
18615: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
18616: LD_EXP 30
18620: PUSH
18621: LD_EXP 74
18625: AND
18626: IFFALSE 18770
18628: GO 18630
18630: DISABLE
18631: LD_INT 0
18633: PPUSH
18634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
18635: LD_ADDR_VAR 0 2
18639: PUSH
18640: LD_INT 22
18642: PUSH
18643: LD_OWVAR 2
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: PUSH
18652: LD_INT 21
18654: PUSH
18655: LD_INT 2
18657: PUSH
18658: EMPTY
18659: LIST
18660: LIST
18661: PUSH
18662: LD_INT 2
18664: PUSH
18665: LD_INT 34
18667: PUSH
18668: LD_INT 12
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: LD_INT 34
18677: PUSH
18678: LD_INT 51
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: LD_INT 34
18687: PUSH
18688: LD_INT 32
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL_OW 69
18710: ST_TO_ADDR
// if not tmp then
18711: LD_VAR 0 2
18715: NOT
18716: IFFALSE 18720
// exit ;
18718: GO 18770
// for i in tmp do
18720: LD_ADDR_VAR 0 1
18724: PUSH
18725: LD_VAR 0 2
18729: PUSH
18730: FOR_IN
18731: IFFALSE 18768
// if GetCargo ( i , mat_artifact ) = 0 then
18733: LD_VAR 0 1
18737: PPUSH
18738: LD_INT 4
18740: PPUSH
18741: CALL_OW 289
18745: PUSH
18746: LD_INT 0
18748: EQUAL
18749: IFFALSE 18766
// SetCargo ( i , mat_siberit , 100 ) ;
18751: LD_VAR 0 1
18755: PPUSH
18756: LD_INT 3
18758: PPUSH
18759: LD_INT 100
18761: PPUSH
18762: CALL_OW 290
18766: GO 18730
18768: POP
18769: POP
// end ;
18770: PPOPN 2
18772: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
18773: LD_EXP 30
18777: PUSH
18778: LD_EXP 75
18782: AND
18783: IFFALSE 18936
18785: GO 18787
18787: DISABLE
18788: LD_INT 0
18790: PPUSH
18791: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
18792: LD_ADDR_VAR 0 2
18796: PUSH
18797: LD_INT 22
18799: PUSH
18800: LD_OWVAR 2
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: ST_TO_ADDR
// if not tmp then
18814: LD_VAR 0 2
18818: NOT
18819: IFFALSE 18823
// exit ;
18821: GO 18936
// for i := 1 to 2 do
18823: LD_ADDR_VAR 0 1
18827: PUSH
18828: DOUBLE
18829: LD_INT 1
18831: DEC
18832: ST_TO_ADDR
18833: LD_INT 2
18835: PUSH
18836: FOR_TO
18837: IFFALSE 18934
// begin uc_side := your_side ;
18839: LD_ADDR_OWVAR 20
18843: PUSH
18844: LD_OWVAR 2
18848: ST_TO_ADDR
// uc_nation := nation_american ;
18849: LD_ADDR_OWVAR 21
18853: PUSH
18854: LD_INT 1
18856: ST_TO_ADDR
// vc_chassis := us_morphling ;
18857: LD_ADDR_OWVAR 37
18861: PUSH
18862: LD_INT 5
18864: ST_TO_ADDR
// vc_engine := engine_siberite ;
18865: LD_ADDR_OWVAR 39
18869: PUSH
18870: LD_INT 3
18872: ST_TO_ADDR
// vc_control := control_computer ;
18873: LD_ADDR_OWVAR 38
18877: PUSH
18878: LD_INT 3
18880: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18881: LD_ADDR_OWVAR 40
18885: PUSH
18886: LD_INT 10
18888: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18889: CALL_OW 45
18893: PPUSH
18894: LD_VAR 0 2
18898: PUSH
18899: LD_INT 1
18901: ARRAY
18902: PPUSH
18903: CALL_OW 250
18907: PPUSH
18908: LD_VAR 0 2
18912: PUSH
18913: LD_INT 1
18915: ARRAY
18916: PPUSH
18917: CALL_OW 251
18921: PPUSH
18922: LD_INT 12
18924: PPUSH
18925: LD_INT 1
18927: PPUSH
18928: CALL_OW 50
// end ;
18932: GO 18836
18934: POP
18935: POP
// end ;
18936: PPOPN 2
18938: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18939: LD_EXP 30
18943: PUSH
18944: LD_EXP 76
18948: AND
18949: IFFALSE 19171
18951: GO 18953
18953: DISABLE
18954: LD_INT 0
18956: PPUSH
18957: PPUSH
18958: PPUSH
18959: PPUSH
18960: PPUSH
18961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18962: LD_ADDR_VAR 0 6
18966: PUSH
18967: LD_INT 22
18969: PUSH
18970: LD_OWVAR 2
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 21
18981: PUSH
18982: LD_INT 1
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: PUSH
18989: LD_INT 3
18991: PUSH
18992: LD_INT 23
18994: PUSH
18995: LD_INT 0
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: LIST
19010: PPUSH
19011: CALL_OW 69
19015: ST_TO_ADDR
// if not tmp then
19016: LD_VAR 0 6
19020: NOT
19021: IFFALSE 19025
// exit ;
19023: GO 19171
// s1 := rand ( 1 , 4 ) ;
19025: LD_ADDR_VAR 0 2
19029: PUSH
19030: LD_INT 1
19032: PPUSH
19033: LD_INT 4
19035: PPUSH
19036: CALL_OW 12
19040: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
19041: LD_ADDR_VAR 0 4
19045: PUSH
19046: LD_VAR 0 6
19050: PUSH
19051: LD_INT 1
19053: ARRAY
19054: PPUSH
19055: LD_VAR 0 2
19059: PPUSH
19060: CALL_OW 259
19064: ST_TO_ADDR
// if s1 = 1 then
19065: LD_VAR 0 2
19069: PUSH
19070: LD_INT 1
19072: EQUAL
19073: IFFALSE 19093
// s2 := rand ( 2 , 4 ) else
19075: LD_ADDR_VAR 0 3
19079: PUSH
19080: LD_INT 2
19082: PPUSH
19083: LD_INT 4
19085: PPUSH
19086: CALL_OW 12
19090: ST_TO_ADDR
19091: GO 19101
// s2 := 1 ;
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_INT 1
19100: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
19101: LD_ADDR_VAR 0 5
19105: PUSH
19106: LD_VAR 0 6
19110: PUSH
19111: LD_INT 1
19113: ARRAY
19114: PPUSH
19115: LD_VAR 0 3
19119: PPUSH
19120: CALL_OW 259
19124: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
19125: LD_VAR 0 6
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: LD_VAR 0 2
19138: PPUSH
19139: LD_VAR 0 5
19143: PPUSH
19144: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
19148: LD_VAR 0 6
19152: PUSH
19153: LD_INT 1
19155: ARRAY
19156: PPUSH
19157: LD_VAR 0 3
19161: PPUSH
19162: LD_VAR 0 4
19166: PPUSH
19167: CALL_OW 237
// end ;
19171: PPOPN 6
19173: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
19174: LD_EXP 30
19178: PUSH
19179: LD_EXP 77
19183: AND
19184: IFFALSE 19263
19186: GO 19188
19188: DISABLE
19189: LD_INT 0
19191: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
19192: LD_ADDR_VAR 0 1
19196: PUSH
19197: LD_INT 22
19199: PUSH
19200: LD_OWVAR 2
19204: PUSH
19205: EMPTY
19206: LIST
19207: LIST
19208: PUSH
19209: LD_INT 30
19211: PUSH
19212: LD_INT 3
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: PPUSH
19223: CALL_OW 69
19227: ST_TO_ADDR
// if not tmp then
19228: LD_VAR 0 1
19232: NOT
19233: IFFALSE 19237
// exit ;
19235: GO 19263
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19237: LD_VAR 0 1
19241: PUSH
19242: LD_INT 1
19244: PPUSH
19245: LD_VAR 0 1
19249: PPUSH
19250: CALL_OW 12
19254: ARRAY
19255: PPUSH
19256: LD_INT 1
19258: PPUSH
19259: CALL_OW 234
// end ;
19263: PPOPN 1
19265: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
19266: LD_EXP 30
19270: PUSH
19271: LD_EXP 78
19275: AND
19276: IFFALSE 19388
19278: GO 19280
19280: DISABLE
19281: LD_INT 0
19283: PPUSH
19284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
19285: LD_ADDR_VAR 0 2
19289: PUSH
19290: LD_INT 22
19292: PUSH
19293: LD_OWVAR 2
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: LD_INT 2
19304: PUSH
19305: LD_INT 30
19307: PUSH
19308: LD_INT 27
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: PUSH
19315: LD_INT 30
19317: PUSH
19318: LD_INT 26
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PUSH
19325: LD_INT 30
19327: PUSH
19328: LD_INT 28
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: PUSH
19335: EMPTY
19336: LIST
19337: LIST
19338: LIST
19339: LIST
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: PPUSH
19345: CALL_OW 69
19349: ST_TO_ADDR
// if not tmp then
19350: LD_VAR 0 2
19354: NOT
19355: IFFALSE 19359
// exit ;
19357: GO 19388
// for i in tmp do
19359: LD_ADDR_VAR 0 1
19363: PUSH
19364: LD_VAR 0 2
19368: PUSH
19369: FOR_IN
19370: IFFALSE 19386
// SetLives ( i , 1 ) ;
19372: LD_VAR 0 1
19376: PPUSH
19377: LD_INT 1
19379: PPUSH
19380: CALL_OW 234
19384: GO 19369
19386: POP
19387: POP
// end ;
19388: PPOPN 2
19390: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
19391: LD_EXP 30
19395: PUSH
19396: LD_EXP 79
19400: AND
19401: IFFALSE 19675
19403: GO 19405
19405: DISABLE
19406: LD_INT 0
19408: PPUSH
19409: PPUSH
19410: PPUSH
// begin i := rand ( 1 , 7 ) ;
19411: LD_ADDR_VAR 0 1
19415: PUSH
19416: LD_INT 1
19418: PPUSH
19419: LD_INT 7
19421: PPUSH
19422: CALL_OW 12
19426: ST_TO_ADDR
// case i of 1 :
19427: LD_VAR 0 1
19431: PUSH
19432: LD_INT 1
19434: DOUBLE
19435: EQUAL
19436: IFTRUE 19440
19438: GO 19450
19440: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
19441: LD_STRING earthquake(getX(game), 0, 32)
19443: PPUSH
19444: CALL_OW 559
19448: GO 19675
19450: LD_INT 2
19452: DOUBLE
19453: EQUAL
19454: IFTRUE 19458
19456: GO 19472
19458: POP
// begin ToLua ( displayStucuk(); ) ;
19459: LD_STRING displayStucuk();
19461: PPUSH
19462: CALL_OW 559
// ResetFog ;
19466: CALL_OW 335
// end ; 3 :
19470: GO 19675
19472: LD_INT 3
19474: DOUBLE
19475: EQUAL
19476: IFTRUE 19480
19478: GO 19584
19480: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19481: LD_ADDR_VAR 0 2
19485: PUSH
19486: LD_INT 22
19488: PUSH
19489: LD_OWVAR 2
19493: PUSH
19494: EMPTY
19495: LIST
19496: LIST
19497: PUSH
19498: LD_INT 25
19500: PUSH
19501: LD_INT 1
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: PPUSH
19512: CALL_OW 69
19516: ST_TO_ADDR
// if not tmp then
19517: LD_VAR 0 2
19521: NOT
19522: IFFALSE 19526
// exit ;
19524: GO 19675
// un := tmp [ rand ( 1 , tmp ) ] ;
19526: LD_ADDR_VAR 0 3
19530: PUSH
19531: LD_VAR 0 2
19535: PUSH
19536: LD_INT 1
19538: PPUSH
19539: LD_VAR 0 2
19543: PPUSH
19544: CALL_OW 12
19548: ARRAY
19549: ST_TO_ADDR
// if Crawls ( un ) then
19550: LD_VAR 0 3
19554: PPUSH
19555: CALL_OW 318
19559: IFFALSE 19570
// ComWalk ( un ) ;
19561: LD_VAR 0 3
19565: PPUSH
19566: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19570: LD_VAR 0 3
19574: PPUSH
19575: LD_INT 8
19577: PPUSH
19578: CALL_OW 336
// end ; 4 :
19582: GO 19675
19584: LD_INT 4
19586: DOUBLE
19587: EQUAL
19588: IFTRUE 19592
19590: GO 19653
19592: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19593: LD_ADDR_VAR 0 2
19597: PUSH
19598: LD_INT 22
19600: PUSH
19601: LD_OWVAR 2
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PUSH
19610: LD_INT 30
19612: PUSH
19613: LD_INT 29
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: PPUSH
19624: CALL_OW 69
19628: ST_TO_ADDR
// if not tmp then
19629: LD_VAR 0 2
19633: NOT
19634: IFFALSE 19638
// exit ;
19636: GO 19675
// DestroyUnit ( tmp [ 1 ] ) ;
19638: LD_VAR 0 2
19642: PUSH
19643: LD_INT 1
19645: ARRAY
19646: PPUSH
19647: CALL_OW 65
// end ; 5 .. 7 :
19651: GO 19675
19653: LD_INT 5
19655: DOUBLE
19656: GREATEREQUAL
19657: IFFALSE 19665
19659: LD_INT 7
19661: DOUBLE
19662: LESSEQUAL
19663: IFTRUE 19667
19665: GO 19674
19667: POP
// StreamSibBomb ; end ;
19668: CALL 15955 0 0
19672: GO 19675
19674: POP
// end ;
19675: PPOPN 3
19677: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
19678: LD_EXP 30
19682: PUSH
19683: LD_EXP 80
19687: AND
19688: IFFALSE 19844
19690: GO 19692
19692: DISABLE
19693: LD_INT 0
19695: PPUSH
19696: PPUSH
19697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
19698: LD_ADDR_VAR 0 2
19702: PUSH
19703: LD_INT 81
19705: PUSH
19706: LD_OWVAR 2
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: PUSH
19715: LD_INT 2
19717: PUSH
19718: LD_INT 21
19720: PUSH
19721: LD_INT 1
19723: PUSH
19724: EMPTY
19725: LIST
19726: LIST
19727: PUSH
19728: LD_INT 21
19730: PUSH
19731: LD_INT 2
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: LIST
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: PPUSH
19747: CALL_OW 69
19751: ST_TO_ADDR
// if not tmp then
19752: LD_VAR 0 2
19756: NOT
19757: IFFALSE 19761
// exit ;
19759: GO 19844
// p := 0 ;
19761: LD_ADDR_VAR 0 3
19765: PUSH
19766: LD_INT 0
19768: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19769: LD_INT 35
19771: PPUSH
19772: CALL_OW 67
// p := p + 1 ;
19776: LD_ADDR_VAR 0 3
19780: PUSH
19781: LD_VAR 0 3
19785: PUSH
19786: LD_INT 1
19788: PLUS
19789: ST_TO_ADDR
// for i in tmp do
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_VAR 0 2
19799: PUSH
19800: FOR_IN
19801: IFFALSE 19832
// if GetLives ( i ) < 1000 then
19803: LD_VAR 0 1
19807: PPUSH
19808: CALL_OW 256
19812: PUSH
19813: LD_INT 1000
19815: LESS
19816: IFFALSE 19830
// SetLives ( i , 1000 ) ;
19818: LD_VAR 0 1
19822: PPUSH
19823: LD_INT 1000
19825: PPUSH
19826: CALL_OW 234
19830: GO 19800
19832: POP
19833: POP
// until p > 20 ;
19834: LD_VAR 0 3
19838: PUSH
19839: LD_INT 20
19841: GREATER
19842: IFFALSE 19769
// end ;
19844: PPOPN 3
19846: END
// every 0 0$1 trigger StreamModeActive and sTime do
19847: LD_EXP 30
19851: PUSH
19852: LD_EXP 81
19856: AND
19857: IFFALSE 19892
19859: GO 19861
19861: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
19862: LD_INT 28
19864: PPUSH
19865: LD_OWVAR 2
19869: PPUSH
19870: LD_INT 2
19872: PPUSH
19873: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
19877: LD_INT 30
19879: PPUSH
19880: LD_OWVAR 2
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 322
// end ;
19892: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19893: LD_EXP 30
19897: PUSH
19898: LD_EXP 82
19902: AND
19903: IFFALSE 20024
19905: GO 19907
19907: DISABLE
19908: LD_INT 0
19910: PPUSH
19911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19912: LD_ADDR_VAR 0 2
19916: PUSH
19917: LD_INT 22
19919: PUSH
19920: LD_OWVAR 2
19924: PUSH
19925: EMPTY
19926: LIST
19927: LIST
19928: PUSH
19929: LD_INT 21
19931: PUSH
19932: LD_INT 1
19934: PUSH
19935: EMPTY
19936: LIST
19937: LIST
19938: PUSH
19939: LD_INT 3
19941: PUSH
19942: LD_INT 23
19944: PUSH
19945: LD_INT 0
19947: PUSH
19948: EMPTY
19949: LIST
19950: LIST
19951: PUSH
19952: EMPTY
19953: LIST
19954: LIST
19955: PUSH
19956: EMPTY
19957: LIST
19958: LIST
19959: LIST
19960: PPUSH
19961: CALL_OW 69
19965: ST_TO_ADDR
// if not tmp then
19966: LD_VAR 0 2
19970: NOT
19971: IFFALSE 19975
// exit ;
19973: GO 20024
// for i in tmp do
19975: LD_ADDR_VAR 0 1
19979: PUSH
19980: LD_VAR 0 2
19984: PUSH
19985: FOR_IN
19986: IFFALSE 20022
// begin if Crawls ( i ) then
19988: LD_VAR 0 1
19992: PPUSH
19993: CALL_OW 318
19997: IFFALSE 20008
// ComWalk ( i ) ;
19999: LD_VAR 0 1
20003: PPUSH
20004: CALL_OW 138
// SetClass ( i , 2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_INT 2
20015: PPUSH
20016: CALL_OW 336
// end ;
20020: GO 19985
20022: POP
20023: POP
// end ;
20024: PPOPN 2
20026: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
20027: LD_EXP 30
20031: PUSH
20032: LD_EXP 83
20036: AND
20037: IFFALSE 20318
20039: GO 20041
20041: DISABLE
20042: LD_INT 0
20044: PPUSH
20045: PPUSH
20046: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
20047: LD_OWVAR 2
20051: PPUSH
20052: LD_INT 9
20054: PPUSH
20055: LD_INT 1
20057: PPUSH
20058: LD_INT 1
20060: PPUSH
20061: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
20065: LD_INT 9
20067: PPUSH
20068: LD_OWVAR 2
20072: PPUSH
20073: CALL_OW 343
// uc_side := 9 ;
20077: LD_ADDR_OWVAR 20
20081: PUSH
20082: LD_INT 9
20084: ST_TO_ADDR
// uc_nation := 2 ;
20085: LD_ADDR_OWVAR 21
20089: PUSH
20090: LD_INT 2
20092: ST_TO_ADDR
// hc_name := Dark Warrior ;
20093: LD_ADDR_OWVAR 26
20097: PUSH
20098: LD_STRING Dark Warrior
20100: ST_TO_ADDR
// hc_gallery :=  ;
20101: LD_ADDR_OWVAR 33
20105: PUSH
20106: LD_STRING 
20108: ST_TO_ADDR
// hc_noskilllimit := true ;
20109: LD_ADDR_OWVAR 76
20113: PUSH
20114: LD_INT 1
20116: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
20117: LD_ADDR_OWVAR 31
20121: PUSH
20122: LD_INT 30
20124: PUSH
20125: LD_INT 30
20127: PUSH
20128: LD_INT 30
20130: PUSH
20131: LD_INT 30
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: LIST
20138: LIST
20139: ST_TO_ADDR
// un := CreateHuman ;
20140: LD_ADDR_VAR 0 3
20144: PUSH
20145: CALL_OW 44
20149: ST_TO_ADDR
// hc_noskilllimit := false ;
20150: LD_ADDR_OWVAR 76
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20158: LD_VAR 0 3
20162: PPUSH
20163: LD_INT 1
20165: PPUSH
20166: CALL_OW 51
// p := 0 ;
20170: LD_ADDR_VAR 0 2
20174: PUSH
20175: LD_INT 0
20177: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20178: LD_INT 35
20180: PPUSH
20181: CALL_OW 67
// p := p + 1 ;
20185: LD_ADDR_VAR 0 2
20189: PUSH
20190: LD_VAR 0 2
20194: PUSH
20195: LD_INT 1
20197: PLUS
20198: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
20199: LD_VAR 0 3
20203: PPUSH
20204: CALL_OW 256
20208: PUSH
20209: LD_INT 1000
20211: LESS
20212: IFFALSE 20226
// SetLives ( un , 1000 ) ;
20214: LD_VAR 0 3
20218: PPUSH
20219: LD_INT 1000
20221: PPUSH
20222: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
20226: LD_VAR 0 3
20230: PPUSH
20231: LD_INT 81
20233: PUSH
20234: LD_OWVAR 2
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: LD_INT 91
20245: PUSH
20246: LD_VAR 0 3
20250: PUSH
20251: LD_INT 30
20253: PUSH
20254: EMPTY
20255: LIST
20256: LIST
20257: LIST
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: PPUSH
20263: CALL_OW 69
20267: PPUSH
20268: LD_VAR 0 3
20272: PPUSH
20273: CALL_OW 74
20277: PPUSH
20278: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
20282: LD_VAR 0 2
20286: PUSH
20287: LD_INT 60
20289: GREATER
20290: PUSH
20291: LD_VAR 0 3
20295: PPUSH
20296: CALL_OW 301
20300: OR
20301: IFFALSE 20178
// if un then
20303: LD_VAR 0 3
20307: IFFALSE 20318
// RemoveUnit ( un ) ;
20309: LD_VAR 0 3
20313: PPUSH
20314: CALL_OW 64
// end ; end_of_file
20318: PPOPN 3
20320: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
20321: LD_INT 0
20323: PPUSH
20324: PPUSH
20325: PPUSH
20326: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
20327: LD_VAR 0 1
20331: PPUSH
20332: CALL_OW 264
20336: PUSH
20337: LD_EXP 29
20341: EQUAL
20342: IFFALSE 20414
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
20344: LD_INT 68
20346: PPUSH
20347: LD_VAR 0 1
20351: PPUSH
20352: CALL_OW 255
20356: PPUSH
20357: CALL_OW 321
20361: PUSH
20362: LD_INT 2
20364: EQUAL
20365: IFFALSE 20377
// eff := 70 else
20367: LD_ADDR_VAR 0 4
20371: PUSH
20372: LD_INT 70
20374: ST_TO_ADDR
20375: GO 20385
// eff := 30 ;
20377: LD_ADDR_VAR 0 4
20381: PUSH
20382: LD_INT 30
20384: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
20385: LD_VAR 0 1
20389: PPUSH
20390: CALL_OW 250
20394: PPUSH
20395: LD_VAR 0 1
20399: PPUSH
20400: CALL_OW 251
20404: PPUSH
20405: LD_VAR 0 4
20409: PPUSH
20410: CALL_OW 495
// end ; end ;
20414: LD_VAR 0 2
20418: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
20419: LD_INT 0
20421: PPUSH
// end ;
20422: LD_VAR 0 4
20426: RET
// export function SOS_Command ( cmd ) ; begin
20427: LD_INT 0
20429: PPUSH
// end ;
20430: LD_VAR 0 2
20434: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
20435: LD_VAR 0 1
20439: PUSH
20440: LD_INT 255
20442: EQUAL
20443: PUSH
20444: LD_VAR 0 2
20448: PPUSH
20449: CALL_OW 264
20453: PUSH
20454: LD_INT 14
20456: PUSH
20457: LD_INT 53
20459: PUSH
20460: EMPTY
20461: LIST
20462: LIST
20463: IN
20464: AND
20465: PUSH
20466: LD_VAR 0 4
20470: PPUSH
20471: LD_VAR 0 5
20475: PPUSH
20476: CALL_OW 488
20480: AND
20481: IFFALSE 20505
// CutTreeXYR ( unit , x , y , 12 ) ;
20483: LD_VAR 0 2
20487: PPUSH
20488: LD_VAR 0 4
20492: PPUSH
20493: LD_VAR 0 5
20497: PPUSH
20498: LD_INT 12
20500: PPUSH
20501: CALL 20508 0 4
// end ;
20505: PPOPN 5
20507: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
20508: LD_INT 0
20510: PPUSH
20511: PPUSH
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
20517: PPUSH
20518: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
20519: LD_VAR 0 1
20523: NOT
20524: PUSH
20525: LD_VAR 0 2
20529: PPUSH
20530: LD_VAR 0 3
20534: PPUSH
20535: CALL_OW 488
20539: NOT
20540: OR
20541: PUSH
20542: LD_VAR 0 4
20546: NOT
20547: OR
20548: IFFALSE 20552
// exit ;
20550: GO 20892
// list := [ ] ;
20552: LD_ADDR_VAR 0 13
20556: PUSH
20557: EMPTY
20558: ST_TO_ADDR
// if x - r < 0 then
20559: LD_VAR 0 2
20563: PUSH
20564: LD_VAR 0 4
20568: MINUS
20569: PUSH
20570: LD_INT 0
20572: LESS
20573: IFFALSE 20585
// min_x := 0 else
20575: LD_ADDR_VAR 0 7
20579: PUSH
20580: LD_INT 0
20582: ST_TO_ADDR
20583: GO 20601
// min_x := x - r ;
20585: LD_ADDR_VAR 0 7
20589: PUSH
20590: LD_VAR 0 2
20594: PUSH
20595: LD_VAR 0 4
20599: MINUS
20600: ST_TO_ADDR
// if y - r < 0 then
20601: LD_VAR 0 3
20605: PUSH
20606: LD_VAR 0 4
20610: MINUS
20611: PUSH
20612: LD_INT 0
20614: LESS
20615: IFFALSE 20627
// min_y := 0 else
20617: LD_ADDR_VAR 0 8
20621: PUSH
20622: LD_INT 0
20624: ST_TO_ADDR
20625: GO 20643
// min_y := y - r ;
20627: LD_ADDR_VAR 0 8
20631: PUSH
20632: LD_VAR 0 3
20636: PUSH
20637: LD_VAR 0 4
20641: MINUS
20642: ST_TO_ADDR
// max_x := x + r ;
20643: LD_ADDR_VAR 0 9
20647: PUSH
20648: LD_VAR 0 2
20652: PUSH
20653: LD_VAR 0 4
20657: PLUS
20658: ST_TO_ADDR
// max_y := y + r ;
20659: LD_ADDR_VAR 0 10
20663: PUSH
20664: LD_VAR 0 3
20668: PUSH
20669: LD_VAR 0 4
20673: PLUS
20674: ST_TO_ADDR
// for _x = min_x to max_x do
20675: LD_ADDR_VAR 0 11
20679: PUSH
20680: DOUBLE
20681: LD_VAR 0 7
20685: DEC
20686: ST_TO_ADDR
20687: LD_VAR 0 9
20691: PUSH
20692: FOR_TO
20693: IFFALSE 20810
// for _y = min_y to max_y do
20695: LD_ADDR_VAR 0 12
20699: PUSH
20700: DOUBLE
20701: LD_VAR 0 8
20705: DEC
20706: ST_TO_ADDR
20707: LD_VAR 0 10
20711: PUSH
20712: FOR_TO
20713: IFFALSE 20806
// begin if not ValidHex ( _x , _y ) then
20715: LD_VAR 0 11
20719: PPUSH
20720: LD_VAR 0 12
20724: PPUSH
20725: CALL_OW 488
20729: NOT
20730: IFFALSE 20734
// continue ;
20732: GO 20712
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
20734: LD_VAR 0 11
20738: PPUSH
20739: LD_VAR 0 12
20743: PPUSH
20744: CALL_OW 351
20748: PUSH
20749: LD_VAR 0 11
20753: PPUSH
20754: LD_VAR 0 12
20758: PPUSH
20759: CALL_OW 554
20763: AND
20764: IFFALSE 20804
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
20766: LD_ADDR_VAR 0 13
20770: PUSH
20771: LD_VAR 0 13
20775: PPUSH
20776: LD_VAR 0 13
20780: PUSH
20781: LD_INT 1
20783: PLUS
20784: PPUSH
20785: LD_VAR 0 11
20789: PUSH
20790: LD_VAR 0 12
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PPUSH
20799: CALL_OW 2
20803: ST_TO_ADDR
// end ;
20804: GO 20712
20806: POP
20807: POP
20808: GO 20692
20810: POP
20811: POP
// if not list then
20812: LD_VAR 0 13
20816: NOT
20817: IFFALSE 20821
// exit ;
20819: GO 20892
// for i in list do
20821: LD_ADDR_VAR 0 6
20825: PUSH
20826: LD_VAR 0 13
20830: PUSH
20831: FOR_IN
20832: IFFALSE 20890
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20834: LD_VAR 0 1
20838: PPUSH
20839: LD_STRING M
20841: PUSH
20842: LD_VAR 0 6
20846: PUSH
20847: LD_INT 1
20849: ARRAY
20850: PUSH
20851: LD_VAR 0 6
20855: PUSH
20856: LD_INT 2
20858: ARRAY
20859: PUSH
20860: LD_INT 0
20862: PUSH
20863: LD_INT 0
20865: PUSH
20866: LD_INT 0
20868: PUSH
20869: LD_INT 0
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: PUSH
20881: EMPTY
20882: LIST
20883: PPUSH
20884: CALL_OW 447
20888: GO 20831
20890: POP
20891: POP
// end ;
20892: LD_VAR 0 5
20896: RET
