// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8608 0 0
// PrepareAmerican ;
 100: CALL 5228 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3263: LD_VAR 0 1
3267: PUSH
3268: LD_EXP 17
3272: IN
3273: IFFALSE 3291
// Patrol := Patrol diff un ;
3275: LD_ADDR_EXP 17
3279: PUSH
3280: LD_EXP 17
3284: PUSH
3285: LD_VAR 0 1
3289: DIFF
3290: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3291: LD_VAR 0 1
3295: PUSH
3296: LD_INT 22
3298: PUSH
3299: LD_INT 1
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PUSH
3306: LD_INT 30
3308: PUSH
3309: LD_INT 32
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PPUSH
3320: CALL_OW 69
3324: IN
3325: IFFALSE 3411
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3327: LD_ADDR_EXP 18
3331: PUSH
3332: LD_EXP 18
3336: PUSH
3337: LD_VAR 0 1
3341: PPUSH
3342: CALL_OW 250
3346: ADD
3347: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3348: LD_ADDR_EXP 18
3352: PUSH
3353: LD_EXP 18
3357: PUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: CALL_OW 251
3367: ADD
3368: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3369: LD_ADDR_EXP 18
3373: PUSH
3374: LD_EXP 18
3378: PUSH
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 254
3388: ADD
3389: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3390: LD_ADDR_EXP 18
3394: PUSH
3395: LD_EXP 18
3399: PUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 269
3409: ADD
3410: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3411: LD_VAR 0 1
3415: PUSH
3416: LD_INT 33
3418: PUSH
3419: LD_INT 2
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 34
3431: PUSH
3432: LD_INT 13
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PPUSH
3447: CALL_OW 69
3451: IN
3452: IFFALSE 3468
// new_veh := new_veh + 1 ;
3454: LD_ADDR_EXP 19
3458: PUSH
3459: LD_EXP 19
3463: PUSH
3464: LD_INT 1
3466: PLUS
3467: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3468: LD_VAR 0 1
3472: PUSH
3473: LD_INT 34
3475: PUSH
3476: LD_INT 13
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: PPUSH
3483: CALL_OW 69
3487: IN
3488: IFFALSE 3509
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3490: LD_INT 26
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 2
3498: PPUSH
3499: LD_INT 2
3501: PPUSH
3502: LD_INT 13
3504: PPUSH
3505: CALL_OW 185
// if un = am_dep then
3509: LD_VAR 0 1
3513: PUSH
3514: LD_INT 25
3516: EQUAL
3517: IFFALSE 3685
// begin SayRadio ( Platonov , DPlat ) ;
3519: LD_EXP 4
3523: PPUSH
3524: LD_STRING DPlat
3526: PPUSH
3527: CALL_OW 94
// if timer <= 30 30$00 then
3531: LD_EXP 24
3535: PUSH
3536: LD_INT 63000
3538: LESSEQUAL
3539: IFFALSE 3553
// AddMedal ( gamma_med3 , 1 ) else
3541: LD_STRING gamma_med3
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 101
3551: GO 3603
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3553: LD_EXP 24
3557: PUSH
3558: LD_INT 105000
3560: PUSH
3561: LD_INT 88200
3563: PUSH
3564: LD_INT 73500
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: LIST
3571: PUSH
3572: LD_EXP 1
3576: ARRAY
3577: LESSEQUAL
3578: IFFALSE 3592
// AddMedal ( gamma_med3 , 2 ) else
3580: LD_STRING gamma_med3
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 101
3590: GO 3603
// AddMedal ( gamma_med3 , - 1 ) ;
3592: LD_STRING gamma_med3
3594: PPUSH
3595: LD_INT 1
3597: NEG
3598: PPUSH
3599: CALL_OW 101
// if not comp_tested then
3603: LD_EXP 22
3607: NOT
3608: IFFALSE 3623
// AddMedal ( gamma_med2 , - 1 ) else
3610: LD_STRING gamma_med2
3612: PPUSH
3613: LD_INT 1
3615: NEG
3616: PPUSH
3617: CALL_OW 101
3621: GO 3633
// AddMedal ( gamma_med2 , 1 ) ;
3623: LD_STRING gamma_med2
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3633: LD_EXP 9
3637: PPUSH
3638: CALL_OW 301
3642: PUSH
3643: LD_EXP 23
3647: NOT
3648: AND
3649: IFFALSE 3663
// AddMedal ( gamma_med1 , 1 ) else
3651: LD_STRING gamma_med1
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: CALL_OW 101
3661: GO 3674
// AddMedal ( gamma_med1 , - 1 ) ;
3663: LD_STRING gamma_med1
3665: PPUSH
3666: LD_INT 1
3668: NEG
3669: PPUSH
3670: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3674: LD_STRING GAMMA_MEDALS
3676: PPUSH
3677: CALL_OW 102
// YouWin ;
3681: CALL_OW 103
// end ; if un = commander then
3685: LD_VAR 0 1
3689: PUSH
3690: LD_EXP 3
3694: EQUAL
3695: IFFALSE 3704
// YouLost ( comml ) ;
3697: LD_STRING comml
3699: PPUSH
3700: CALL_OW 104
// if un = sikorski then
3704: LD_VAR 0 1
3708: PUSH
3709: LD_EXP 9
3713: EQUAL
3714: IFFALSE 3726
// AddMedal ( gamma_med1 , 1 ) ;
3716: LD_STRING gamma_med1
3718: PPUSH
3719: LD_INT 1
3721: PPUSH
3722: CALL_OW 101
// end ;
3726: PPOPN 1
3728: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3729: LD_INT 0
3731: PPUSH
3732: PPUSH
3733: PPUSH
3734: PPUSH
3735: PPUSH
3736: PPUSH
3737: PPUSH
3738: PPUSH
3739: PPUSH
// begin if event = 1 then
3740: LD_VAR 0 1
3744: PUSH
3745: LD_INT 1
3747: EQUAL
3748: IFFALSE 4045
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3750: LD_ADDR_VAR 0 4
3754: PUSH
3755: LD_INT 22
3757: PUSH
3758: LD_INT 1
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 21
3767: PUSH
3768: LD_INT 3
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 3
3777: PUSH
3778: LD_INT 24
3780: PUSH
3781: LD_INT 1000
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: LIST
3796: PPUSH
3797: CALL_OW 69
3801: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_INT 22
3809: PUSH
3810: LD_INT 1
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_INT 25
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 24
3829: PUSH
3830: LD_INT 1000
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: PPUSH
3845: CALL_OW 69
3849: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3850: LD_ADDR_VAR 0 9
3854: PUSH
3855: LD_INT 22
3857: PUSH
3858: LD_INT 1
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 34
3867: PUSH
3868: LD_INT 13
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL_OW 69
3883: ST_TO_ADDR
// if engs > 0 then
3884: LD_VAR 0 8
3888: PUSH
3889: LD_INT 0
3891: GREATER
3892: IFFALSE 3997
// for i = 1 to engs do
3894: LD_ADDR_VAR 0 2
3898: PUSH
3899: DOUBLE
3900: LD_INT 1
3902: DEC
3903: ST_TO_ADDR
3904: LD_VAR 0 8
3908: PUSH
3909: FOR_TO
3910: IFFALSE 3995
// begin if IsInUnit ( engs [ i ] ) then
3912: LD_VAR 0 8
3916: PUSH
3917: LD_VAR 0 2
3921: ARRAY
3922: PPUSH
3923: CALL_OW 310
3927: IFFALSE 3944
// ComExitBuilding ( engs [ i ] ) ;
3929: LD_VAR 0 8
3933: PUSH
3934: LD_VAR 0 2
3938: ARRAY
3939: PPUSH
3940: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3944: LD_INT 7
3946: PPUSH
3947: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3951: LD_VAR 0 8
3955: PUSH
3956: LD_VAR 0 2
3960: ARRAY
3961: PPUSH
3962: CALL_OW 314
3966: NOT
3967: IFFALSE 3993
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3969: LD_VAR 0 8
3973: PUSH
3974: LD_VAR 0 2
3978: ARRAY
3979: PPUSH
3980: LD_VAR 0 4
3984: PUSH
3985: LD_INT 1
3987: ARRAY
3988: PPUSH
3989: CALL_OW 130
// end ;
3993: GO 3909
3995: POP
3996: POP
// if crane > 0 then
3997: LD_VAR 0 9
4001: PUSH
4002: LD_INT 0
4004: GREATER
4005: IFFALSE 4045
// if not HasTask ( crane [ 1 ] ) then
4007: LD_VAR 0 9
4011: PUSH
4012: LD_INT 1
4014: ARRAY
4015: PPUSH
4016: CALL_OW 314
4020: NOT
4021: IFFALSE 4045
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4023: LD_VAR 0 9
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_VAR 0 4
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: CALL_OW 130
// end ; if event = 2 then
4045: LD_VAR 0 1
4049: PUSH
4050: LD_INT 2
4052: EQUAL
4053: IFFALSE 4175
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4055: LD_ADDR_VAR 0 8
4059: PUSH
4060: LD_INT 22
4062: PUSH
4063: LD_INT 1
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: LD_INT 25
4072: PUSH
4073: LD_INT 2
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 69
4088: ST_TO_ADDR
// if engs > 0 then
4089: LD_VAR 0 8
4093: PUSH
4094: LD_INT 0
4096: GREATER
4097: IFFALSE 4175
// for i = 1 to engs do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_VAR 0 8
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4173
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4117: LD_VAR 0 8
4121: PUSH
4122: LD_VAR 0 2
4126: ARRAY
4127: PPUSH
4128: CALL_OW 314
4132: NOT
4133: PUSH
4134: LD_VAR 0 8
4138: PUSH
4139: LD_VAR 0 2
4143: ARRAY
4144: PPUSH
4145: CALL_OW 310
4149: NOT
4150: AND
4151: IFFALSE 4171
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4153: LD_VAR 0 8
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PPUSH
4164: LD_INT 25
4166: PPUSH
4167: CALL_OW 120
4171: GO 4114
4173: POP
4174: POP
// end ; if event = 3 then
4175: LD_VAR 0 1
4179: PUSH
4180: LD_INT 3
4182: EQUAL
4183: IFFALSE 4547
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 1
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 25
4215: PUSH
4216: LD_INT 4
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: LD_INT 24
4232: PUSH
4233: LD_INT 800
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: PPUSH
4253: CALL_OW 69
4257: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4258: LD_ADDR_VAR 0 5
4262: PUSH
4263: LD_INT 22
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PUSH
4273: LD_INT 25
4275: PUSH
4276: LD_INT 4
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: ST_TO_ADDR
// if filter > 0 then
4292: LD_VAR 0 4
4296: PUSH
4297: LD_INT 0
4299: GREATER
4300: IFFALSE 4489
// begin for i = 1 to doc do
4302: LD_ADDR_VAR 0 2
4306: PUSH
4307: DOUBLE
4308: LD_INT 1
4310: DEC
4311: ST_TO_ADDR
4312: LD_VAR 0 5
4316: PUSH
4317: FOR_TO
4318: IFFALSE 4418
// begin if IsInUnit ( doc [ i ] ) then
4320: LD_VAR 0 5
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PPUSH
4331: CALL_OW 310
4335: IFFALSE 4352
// ComExitBuilding ( doc [ i ] ) ;
4337: LD_VAR 0 5
4341: PUSH
4342: LD_VAR 0 2
4346: ARRAY
4347: PPUSH
4348: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 1
4359: ARRAY
4360: PPUSH
4361: LD_INT 46
4363: PPUSH
4364: CALL_OW 296
4368: PUSH
4369: LD_INT 10
4371: LESS
4372: PUSH
4373: LD_VAR 0 5
4377: PUSH
4378: LD_VAR 0 2
4382: ARRAY
4383: PPUSH
4384: CALL_OW 314
4388: NOT
4389: AND
4390: IFFALSE 4416
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4392: LD_VAR 0 5
4396: PUSH
4397: LD_VAR 0 2
4401: ARRAY
4402: PPUSH
4403: LD_VAR 0 4
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 128
// end ;
4416: GO 4317
4418: POP
4419: POP
// for i = 1 to filter do
4420: LD_ADDR_VAR 0 2
4424: PUSH
4425: DOUBLE
4426: LD_INT 1
4428: DEC
4429: ST_TO_ADDR
4430: LD_VAR 0 4
4434: PUSH
4435: FOR_TO
4436: IFFALSE 4485
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4438: LD_VAR 0 4
4442: PUSH
4443: LD_VAR 0 2
4447: ARRAY
4448: PPUSH
4449: LD_INT 46
4451: PPUSH
4452: CALL_OW 296
4456: PUSH
4457: LD_INT 10
4459: GREATER
4460: IFFALSE 4483
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 2
4471: ARRAY
4472: PPUSH
4473: LD_INT 47
4475: PPUSH
4476: LD_INT 12
4478: PPUSH
4479: CALL_OW 111
4483: GO 4435
4485: POP
4486: POP
// end else
4487: GO 4547
// for i = 1 to doc do
4489: LD_ADDR_VAR 0 2
4493: PUSH
4494: DOUBLE
4495: LD_INT 1
4497: DEC
4498: ST_TO_ADDR
4499: LD_VAR 0 5
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4545
// if not IsInUnit ( doc [ i ] ) then
4507: LD_VAR 0 5
4511: PUSH
4512: LD_VAR 0 2
4516: ARRAY
4517: PPUSH
4518: CALL_OW 310
4522: NOT
4523: IFFALSE 4543
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 2
4534: ARRAY
4535: PPUSH
4536: LD_INT 46
4538: PPUSH
4539: CALL_OW 120
4543: GO 4504
4545: POP
4546: POP
// end ; if event = 4 then
4547: LD_VAR 0 1
4551: PUSH
4552: LD_INT 4
4554: EQUAL
4555: IFFALSE 4806
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4557: LD_ADDR_VAR 0 6
4561: PUSH
4562: LD_INT 22
4564: PUSH
4565: LD_INT 1
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 30
4574: PUSH
4575: LD_INT 5
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL_OW 69
4590: ST_TO_ADDR
// for i = 1 to bac do
4591: LD_ADDR_VAR 0 2
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_VAR 0 6
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4648
// if UnitsInside ( bac [ i ] ) < 6 then
4609: LD_VAR 0 6
4613: PUSH
4614: LD_VAR 0 2
4618: ARRAY
4619: PPUSH
4620: CALL_OW 313
4624: PUSH
4625: LD_INT 6
4627: LESS
4628: IFFALSE 4646
// place := bac [ i ] ;
4630: LD_ADDR_VAR 0 7
4634: PUSH
4635: LD_VAR 0 6
4639: PUSH
4640: LD_VAR 0 2
4644: ARRAY
4645: ST_TO_ADDR
4646: GO 4606
4648: POP
4649: POP
// if place then
4650: LD_VAR 0 7
4654: IFFALSE 4806
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4656: LD_ADDR_VAR 0 4
4660: PUSH
4661: LD_INT 22
4663: PUSH
4664: LD_INT 1
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 2
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 25
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 24
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_EXP 17
4726: DIFF
4727: ST_TO_ADDR
// for i = 1 to filter do
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: DOUBLE
4734: LD_INT 1
4736: DEC
4737: ST_TO_ADDR
4738: LD_VAR 0 4
4742: PUSH
4743: FOR_TO
4744: IFFALSE 4804
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4746: LD_VAR 0 4
4750: PUSH
4751: LD_VAR 0 2
4755: ARRAY
4756: PPUSH
4757: CALL_OW 310
4761: NOT
4762: PUSH
4763: LD_VAR 0 4
4767: PUSH
4768: LD_VAR 0 2
4772: ARRAY
4773: PPUSH
4774: CALL_OW 314
4778: NOT
4779: AND
4780: IFFALSE 4802
// ComEnterUnit ( filter [ i ] , place ) ;
4782: LD_VAR 0 4
4786: PUSH
4787: LD_VAR 0 2
4791: ARRAY
4792: PPUSH
4793: LD_VAR 0 7
4797: PPUSH
4798: CALL_OW 120
4802: GO 4743
4804: POP
4805: POP
// end ; end ; if event = 5 then
4806: LD_VAR 0 1
4810: PUSH
4811: LD_INT 5
4813: EQUAL
4814: IFFALSE 4968
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4816: LD_INT 12
4818: PPUSH
4819: LD_INT 81
4821: PUSH
4822: LD_INT 1
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PPUSH
4829: CALL_OW 70
4833: PUSH
4834: LD_INT 0
4836: EQUAL
4837: IFFALSE 4968
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4839: LD_ADDR_VAR 0 8
4843: PUSH
4844: LD_INT 22
4846: PUSH
4847: LD_INT 1
4849: PUSH
4850: EMPTY
4851: LIST
4852: LIST
4853: PUSH
4854: LD_INT 25
4856: PUSH
4857: LD_INT 2
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PPUSH
4868: CALL_OW 69
4872: ST_TO_ADDR
// if engs > 0 then
4873: LD_VAR 0 8
4877: PUSH
4878: LD_INT 0
4880: GREATER
4881: IFFALSE 4968
// for i = 1 to engs do
4883: LD_ADDR_VAR 0 2
4887: PUSH
4888: DOUBLE
4889: LD_INT 1
4891: DEC
4892: ST_TO_ADDR
4893: LD_VAR 0 8
4897: PUSH
4898: FOR_TO
4899: IFFALSE 4966
// if not HasTask ( engs [ i ] ) then
4901: LD_VAR 0 8
4905: PUSH
4906: LD_VAR 0 2
4910: ARRAY
4911: PPUSH
4912: CALL_OW 314
4916: NOT
4917: IFFALSE 4964
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4919: LD_VAR 0 8
4923: PUSH
4924: LD_VAR 0 2
4928: ARRAY
4929: PPUSH
4930: LD_INT 32
4932: PPUSH
4933: LD_EXP 18
4937: PUSH
4938: LD_INT 1
4940: ARRAY
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 2
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 3
4958: ARRAY
4959: PPUSH
4960: CALL_OW 145
4964: GO 4898
4966: POP
4967: POP
// end ; end ; if event = 6 then
4968: LD_VAR 0 1
4972: PUSH
4973: LD_INT 6
4975: EQUAL
4976: IFFALSE 5160
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4978: LD_ADDR_VAR 0 6
4982: PUSH
4983: LD_INT 22
4985: PUSH
4986: LD_INT 1
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 69
5011: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5012: LD_VAR 0 6
5016: PUSH
5017: LD_INT 22
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 32
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 58
5039: PUSH
5040: EMPTY
5041: LIST
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 0
5058: GREATER
5059: AND
5060: IFFALSE 5160
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5062: LD_ADDR_VAR 0 10
5066: PUSH
5067: LD_INT 22
5069: PUSH
5070: LD_INT 1
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: LD_INT 30
5079: PUSH
5080: LD_INT 32
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 58
5089: PUSH
5090: EMPTY
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: EMPTY
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: PUSH
5106: LD_INT 1
5108: ARRAY
5109: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5110: LD_ADDR_VAR 0 3
5114: PUSH
5115: LD_VAR 0 6
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: CALL_OW 313
5128: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5129: LD_VAR 0 3
5133: PUSH
5134: LD_INT 1
5136: ARRAY
5137: PPUSH
5138: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: ARRAY
5150: PPUSH
5151: LD_VAR 0 10
5155: PPUSH
5156: CALL_OW 180
// end ; end ; end ;
5160: PPOPN 10
5162: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5163: LD_VAR 0 1
5167: PUSH
5168: LD_INT 1
5170: EQUAL
5171: PUSH
5172: LD_VAR 0 2
5176: PUSH
5177: LD_INT 3
5179: EQUAL
5180: AND
5181: IFFALSE 5191
// contact_am := true ;
5183: LD_ADDR_EXP 16
5187: PUSH
5188: LD_INT 1
5190: ST_TO_ADDR
// end ;
5191: PPOPN 2
5193: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5194: LD_VAR 0 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PPUSH
5204: LD_VAR 0 3
5208: PPUSH
5209: CALL 12988 0 3
// end ;
5213: PPOPN 3
5215: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5216: LD_VAR 0 1
5220: PPUSH
5221: CALL 13086 0 1
// end ; end_of_file
5225: PPOPN 1
5227: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5228: LD_INT 0
5230: PPUSH
5231: PPUSH
5232: PPUSH
5233: PPUSH
5234: PPUSH
5235: PPUSH
5236: PPUSH
5237: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5238: LD_ADDR_VAR 0 5
5242: PUSH
5243: LD_INT 5
5245: PUSH
5246: LD_INT 6
5248: PUSH
5249: LD_INT 7
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_EXP 1
5261: ARRAY
5262: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5263: LD_ADDR_VAR 0 6
5267: PUSH
5268: LD_INT 4
5270: PUSH
5271: LD_INT 4
5273: PUSH
5274: LD_INT 4
5276: PUSH
5277: LD_INT 5
5279: PUSH
5280: LD_INT 5
5282: PUSH
5283: LD_INT 5
5285: PUSH
5286: LD_INT 6
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: LIST
5297: ST_TO_ADDR
// SForce := [ ] ;
5298: LD_ADDR_EXP 11
5302: PUSH
5303: EMPTY
5304: ST_TO_ADDR
// Sikorski_Ar := false ;
5305: LD_ADDR_EXP 12
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// attacked := false ;
5313: LD_ADDR_EXP 15
5317: PUSH
5318: LD_INT 0
5320: ST_TO_ADDR
// contact_am := false ;
5321: LD_ADDR_EXP 16
5325: PUSH
5326: LD_INT 0
5328: ST_TO_ADDR
// patrol := [ ] ;
5329: LD_ADDR_EXP 17
5333: PUSH
5334: EMPTY
5335: ST_TO_ADDR
// gamma_towers := [ ] ;
5336: LD_ADDR_EXP 18
5340: PUSH
5341: EMPTY
5342: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5343: LD_INT 25
5345: PPUSH
5346: LD_STRING gamma
5348: PPUSH
5349: CALL_OW 500
// uc_side := 1 ;
5353: LD_ADDR_OWVAR 20
5357: PUSH
5358: LD_INT 1
5360: ST_TO_ADDR
// uc_nation := 1 ;
5361: LD_ADDR_OWVAR 21
5365: PUSH
5366: LD_INT 1
5368: ST_TO_ADDR
// hc_importance := 0 ;
5369: LD_ADDR_OWVAR 32
5373: PUSH
5374: LD_INT 0
5376: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5377: LD_ADDR_OWVAR 26
5381: PUSH
5382: LD_STRING Jeremy Sikorski
5384: ST_TO_ADDR
// hc_gallery := us ;
5385: LD_ADDR_OWVAR 33
5389: PUSH
5390: LD_STRING us
5392: ST_TO_ADDR
// hc_face_number := 19 ;
5393: LD_ADDR_OWVAR 34
5397: PUSH
5398: LD_INT 19
5400: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5401: LD_ADDR_OWVAR 31
5405: PUSH
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_VAR 0 5
5415: PUSH
5416: LD_INT 2
5418: PLUS
5419: PPUSH
5420: CALL_OW 12
5424: PUSH
5425: LD_INT 4
5427: PUSH
5428: LD_INT 6
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: ST_TO_ADDR
// hc_sex := sex_male ;
5440: LD_ADDR_OWVAR 27
5444: PUSH
5445: LD_INT 1
5447: ST_TO_ADDR
// hc_class := 1 ;
5448: LD_ADDR_OWVAR 28
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5456: LD_ADDR_OWVAR 29
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: ST_TO_ADDR
// sikorski := CreateHuman ;
5471: LD_ADDR_EXP 9
5475: PUSH
5476: CALL_OW 44
5480: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5481: LD_ADDR_OWVAR 26
5485: PUSH
5486: LD_STRING Lucy Donaldson
5488: ST_TO_ADDR
// hc_gallery := us ;
5489: LD_ADDR_OWVAR 33
5493: PUSH
5494: LD_STRING us
5496: ST_TO_ADDR
// hc_face_number := 2 ;
5497: LD_ADDR_OWVAR 34
5501: PUSH
5502: LD_INT 2
5504: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5505: LD_ADDR_OWVAR 31
5509: PUSH
5510: LD_VAR 0 5
5514: PPUSH
5515: LD_VAR 0 5
5519: PUSH
5520: LD_INT 2
5522: PLUS
5523: PPUSH
5524: CALL_OW 12
5528: PUSH
5529: LD_INT 6
5531: PUSH
5532: LD_INT 4
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: ST_TO_ADDR
// hc_sex := sex_female ;
5544: LD_ADDR_OWVAR 27
5548: PUSH
5549: LD_INT 2
5551: ST_TO_ADDR
// hc_class := 1 ;
5552: LD_ADDR_OWVAR 28
5556: PUSH
5557: LD_INT 1
5559: ST_TO_ADDR
// donald := CreateHuman ;
5560: LD_ADDR_EXP 13
5564: PUSH
5565: CALL_OW 44
5569: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5570: LD_ADDR_OWVAR 26
5574: PUSH
5575: LD_STRING Peter Van Houten
5577: ST_TO_ADDR
// hc_gallery := us ;
5578: LD_ADDR_OWVAR 33
5582: PUSH
5583: LD_STRING us
5585: ST_TO_ADDR
// hc_face_number := 16 ;
5586: LD_ADDR_OWVAR 34
5590: PUSH
5591: LD_INT 16
5593: ST_TO_ADDR
// hc_sex := sex_male ;
5594: LD_ADDR_OWVAR 27
5598: PUSH
5599: LD_INT 1
5601: ST_TO_ADDR
// van := CreateHuman ;
5602: LD_ADDR_EXP 14
5606: PUSH
5607: CALL_OW 44
5611: ST_TO_ADDR
// hc_importance := 0 ;
5612: LD_ADDR_OWVAR 32
5616: PUSH
5617: LD_INT 0
5619: ST_TO_ADDR
// case dif of 1 :
5620: LD_EXP 1
5624: PUSH
5625: LD_INT 1
5627: DOUBLE
5628: EQUAL
5629: IFTRUE 5633
5631: GO 5644
5633: POP
// lw = 1 ; 2 :
5634: LD_ADDR_VAR 0 8
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
5642: GO 5691
5644: LD_INT 2
5646: DOUBLE
5647: EQUAL
5648: IFTRUE 5652
5650: GO 5671
5652: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5653: LD_ADDR_VAR 0 8
5657: PUSH
5658: LD_INT 1
5660: PPUSH
5661: LD_INT 2
5663: PPUSH
5664: CALL_OW 12
5668: ST_TO_ADDR
5669: GO 5691
5671: LD_INT 3
5673: DOUBLE
5674: EQUAL
5675: IFTRUE 5679
5677: GO 5690
5679: POP
// lw = 2 ; end ;
5680: LD_ADDR_VAR 0 8
5684: PUSH
5685: LD_INT 2
5687: ST_TO_ADDR
5688: GO 5691
5690: POP
// case lw of 1 :
5691: LD_VAR 0 8
5695: PUSH
5696: LD_INT 1
5698: DOUBLE
5699: EQUAL
5700: IFTRUE 5704
5702: GO 5719
5704: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5705: LD_EXP 13
5709: PPUSH
5710: LD_INT 25
5712: PPUSH
5713: CALL_OW 52
5717: GO 5743
5719: LD_INT 2
5721: DOUBLE
5722: EQUAL
5723: IFTRUE 5727
5725: GO 5742
5727: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5728: LD_EXP 14
5732: PPUSH
5733: LD_INT 25
5735: PPUSH
5736: CALL_OW 52
5740: GO 5743
5742: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5743: LD_ADDR_VAR 0 2
5747: PUSH
5748: LD_INT 22
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 30
5760: PUSH
5761: LD_INT 32
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PPUSH
5772: CALL_OW 69
5776: PUSH
5777: FOR_IN
5778: IFFALSE 5832
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5780: LD_INT 1
5782: PPUSH
5783: LD_VAR 0 5
5787: PPUSH
5788: CALL 734 0 2
5792: PPUSH
5793: LD_VAR 0 2
5797: PPUSH
5798: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PUSH
5812: LD_INT 1
5814: PPUSH
5815: LD_VAR 0 6
5819: PPUSH
5820: CALL_OW 12
5824: ARRAY
5825: PPUSH
5826: CALL_OW 431
// end ;
5830: GO 5777
5832: POP
5833: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5834: LD_ADDR_VAR 0 7
5838: PUSH
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 2
5851: PUSH
5852: LD_INT 25
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 5
5864: PUSH
5865: EMPTY
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: PPUSH
5877: CALL_OW 69
5881: ST_TO_ADDR
// for i = 1 to sol do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_VAR 0 7
5896: PUSH
5897: FOR_TO
5898: IFFALSE 5920
// SetTag ( sol [ i ] , 1 ) ;
5900: LD_VAR 0 7
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PPUSH
5911: LD_INT 1
5913: PPUSH
5914: CALL_OW 109
5918: GO 5897
5920: POP
5921: POP
// for i = 1 to 3 do
5922: LD_ADDR_VAR 0 2
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_INT 3
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5960
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: CALL 734 0 2
5950: PPUSH
5951: LD_INT 56
5953: PPUSH
5954: CALL_OW 52
5958: GO 5935
5960: POP
5961: POP
// for i = 1 to 6 do
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: DOUBLE
5968: LD_INT 1
5970: DEC
5971: ST_TO_ADDR
5972: LD_INT 6
5974: PUSH
5975: FOR_TO
5976: IFFALSE 6000
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5978: LD_INT 3
5980: PPUSH
5981: LD_VAR 0 5
5985: PPUSH
5986: CALL 734 0 2
5990: PPUSH
5991: LD_INT 26
5993: PPUSH
5994: CALL_OW 52
5998: GO 5975
6000: POP
6001: POP
// for i = 1 to 5 do
6002: LD_ADDR_VAR 0 2
6006: PUSH
6007: DOUBLE
6008: LD_INT 1
6010: DEC
6011: ST_TO_ADDR
6012: LD_INT 5
6014: PUSH
6015: FOR_TO
6016: IFFALSE 6043
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6018: LD_INT 2
6020: PPUSH
6021: LD_VAR 0 5
6025: PPUSH
6026: CALL 734 0 2
6030: PPUSH
6031: LD_INT 7
6033: PPUSH
6034: LD_INT 0
6036: PPUSH
6037: CALL_OW 49
6041: GO 6015
6043: POP
6044: POP
// for i = 1 to 3 do
6045: LD_ADDR_VAR 0 2
6049: PUSH
6050: DOUBLE
6051: LD_INT 1
6053: DEC
6054: ST_TO_ADDR
6055: LD_INT 3
6057: PUSH
6058: FOR_TO
6059: IFFALSE 6083
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6061: LD_INT 4
6063: PPUSH
6064: LD_VAR 0 5
6068: PPUSH
6069: CALL 734 0 2
6073: PPUSH
6074: LD_INT 46
6076: PPUSH
6077: CALL_OW 52
6081: GO 6058
6083: POP
6084: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 1
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 30
6102: PUSH
6103: LD_INT 5
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: PUSH
6119: FOR_IN
6120: IFFALSE 6234
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6122: LD_INT 5
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL 734 0 2
6134: PPUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6144: LD_INT 5
6146: PPUSH
6147: LD_VAR 0 5
6151: PPUSH
6152: CALL 734 0 2
6156: PPUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 5
6173: PPUSH
6174: CALL 734 0 2
6178: PPUSH
6179: LD_VAR 0 2
6183: PPUSH
6184: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6188: LD_INT 1
6190: PPUSH
6191: LD_VAR 0 5
6195: PPUSH
6196: CALL 734 0 2
6200: PPUSH
6201: LD_VAR 0 2
6205: PPUSH
6206: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6210: LD_INT 1
6212: PPUSH
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL 734 0 2
6222: PPUSH
6223: LD_VAR 0 2
6227: PPUSH
6228: CALL_OW 52
// end ;
6232: GO 6119
6234: POP
6235: POP
// if dif > 1 then
6236: LD_EXP 1
6240: PUSH
6241: LD_INT 1
6243: GREATER
6244: IFFALSE 6317
// for i = 1 to ( dif - 1 ) do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_EXP 1
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: PUSH
6265: FOR_TO
6266: IFFALSE 6315
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6268: LD_ADDR_EXP 17
6272: PUSH
6273: LD_EXP 17
6277: PUSH
6278: LD_INT 1
6280: PPUSH
6281: LD_VAR 0 5
6285: PPUSH
6286: CALL 734 0 2
6290: ADD
6291: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6292: LD_EXP 17
6296: PUSH
6297: LD_VAR 0 2
6301: ARRAY
6302: PPUSH
6303: LD_INT 3
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// end ;
6313: GO 6265
6315: POP
6316: POP
// game_started := true ;
6317: LD_ADDR_EXP 10
6321: PUSH
6322: LD_INT 1
6324: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6325: LD_INT 26
6327: PPUSH
6328: LD_INT 3
6330: PPUSH
6331: LD_INT 2
6333: PPUSH
6334: LD_INT 2
6336: PPUSH
6337: LD_INT 13
6339: PPUSH
6340: CALL_OW 125
// while ( contact_am = false ) do
6344: LD_EXP 16
6348: PUSH
6349: LD_INT 0
6351: EQUAL
6352: IFFALSE 6363
// begin Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// end ;
6361: GO 6344
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6363: LD_INT 8400
6365: PUSH
6366: LD_INT 6300
6368: PUSH
6369: LD_INT 5250
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: LD_EXP 1
6381: ARRAY
6382: PPUSH
6383: CALL_OW 67
// case dif of 1 :
6387: LD_EXP 1
6391: PUSH
6392: LD_INT 1
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6575
6400: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6401: LD_INT 26
6403: PPUSH
6404: LD_INT 3
6406: PPUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: LD_INT 5
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 4
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6447: LD_INT 26
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: LD_INT 1
6455: PPUSH
6456: LD_INT 2
6458: PPUSH
6459: LD_INT 4
6461: PUSH
6462: LD_INT 5
6464: PUSH
6465: LD_INT 5
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 1
6475: PPUSH
6476: LD_INT 3
6478: PPUSH
6479: CALL_OW 12
6483: ARRAY
6484: PPUSH
6485: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6489: LD_INT 26
6491: PPUSH
6492: LD_INT 3
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: LD_INT 4
6503: PUSH
6504: LD_INT 5
6506: PUSH
6507: LD_INT 5
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 3
6520: PPUSH
6521: CALL_OW 12
6525: ARRAY
6526: PPUSH
6527: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6531: LD_INT 26
6533: PPUSH
6534: LD_INT 3
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_INT 2
6542: PPUSH
6543: LD_INT 4
6545: PUSH
6546: LD_INT 3
6548: PUSH
6549: LD_INT 5
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 1
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 12
6567: ARRAY
6568: PPUSH
6569: CALL_OW 185
// end ; 2 :
6573: GO 7102
6575: LD_INT 2
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6796
6583: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6584: LD_INT 26
6586: PPUSH
6587: LD_INT 3
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 2
6595: PPUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: LD_INT 5
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 3
6615: PPUSH
6616: CALL_OW 12
6620: ARRAY
6621: PPUSH
6622: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6626: LD_INT 26
6628: PPUSH
6629: LD_INT 3
6631: PPUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 4
6640: PUSH
6641: LD_INT 5
6643: PUSH
6644: LD_INT 5
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 3
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6668: LD_INT 26
6670: PPUSH
6671: LD_INT 3
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: LD_INT 2
6679: PPUSH
6680: LD_INT 4
6682: PUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 5
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 3
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: PPUSH
6706: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6710: LD_INT 26
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 2
6721: PPUSH
6722: LD_INT 4
6724: PUSH
6725: LD_INT 5
6727: PUSH
6728: LD_INT 6
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 1
6738: PPUSH
6739: LD_INT 3
6741: PPUSH
6742: CALL_OW 12
6746: ARRAY
6747: PPUSH
6748: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6752: LD_INT 26
6754: PPUSH
6755: LD_INT 4
6757: PPUSH
6758: LD_INT 1
6760: PPUSH
6761: LD_INT 2
6763: PPUSH
6764: LD_INT 4
6766: PUSH
6767: LD_INT 5
6769: PUSH
6770: LD_INT 6
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: CALL_OW 185
// end ; 3 :
6794: GO 7102
6796: LD_INT 3
6798: DOUBLE
6799: EQUAL
6800: IFTRUE 6804
6802: GO 7101
6804: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6805: LD_INT 26
6807: PPUSH
6808: LD_INT 3
6810: PPUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_INT 2
6816: PPUSH
6817: LD_INT 4
6819: PUSH
6820: LD_INT 5
6822: PUSH
6823: LD_INT 5
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: LD_INT 1
6833: PPUSH
6834: LD_INT 3
6836: PPUSH
6837: CALL_OW 12
6841: ARRAY
6842: PPUSH
6843: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6847: LD_INT 26
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 1
6855: PPUSH
6856: LD_INT 2
6858: PPUSH
6859: LD_INT 4
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 5
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 3
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6889: LD_INT 26
6891: PPUSH
6892: LD_INT 3
6894: PPUSH
6895: LD_INT 1
6897: PPUSH
6898: LD_INT 2
6900: PPUSH
6901: LD_INT 4
6903: PUSH
6904: LD_INT 5
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 1
6917: PPUSH
6918: LD_INT 3
6920: PPUSH
6921: CALL_OW 12
6925: ARRAY
6926: PPUSH
6927: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6931: LD_INT 26
6933: PPUSH
6934: LD_INT 3
6936: PPUSH
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 2
6942: PPUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 5
6948: PUSH
6949: LD_INT 5
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 1
6959: PPUSH
6960: LD_INT 3
6962: PPUSH
6963: CALL_OW 12
6967: ARRAY
6968: PPUSH
6969: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6973: LD_INT 26
6975: PPUSH
6976: LD_INT 4
6978: PPUSH
6979: LD_INT 1
6981: PPUSH
6982: LD_INT 2
6984: PPUSH
6985: LD_INT 4
6987: PUSH
6988: LD_INT 5
6990: PUSH
6991: LD_INT 6
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 1
7001: PPUSH
7002: LD_INT 3
7004: PPUSH
7005: CALL_OW 12
7009: ARRAY
7010: PPUSH
7011: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7015: LD_INT 26
7017: PPUSH
7018: LD_INT 4
7020: PPUSH
7021: LD_INT 1
7023: PPUSH
7024: LD_INT 2
7026: PPUSH
7027: LD_INT 4
7029: PUSH
7030: LD_INT 5
7032: PUSH
7033: LD_INT 6
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: LIST
7040: PUSH
7041: LD_INT 1
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 12
7051: ARRAY
7052: PPUSH
7053: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7057: LD_INT 26
7059: PPUSH
7060: LD_INT 4
7062: PPUSH
7063: LD_INT 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: LD_INT 4
7071: PUSH
7072: LD_INT 5
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 1
7085: PPUSH
7086: LD_INT 3
7088: PPUSH
7089: CALL_OW 12
7093: ARRAY
7094: PPUSH
7095: CALL_OW 185
// end ; end ;
7099: GO 7102
7101: POP
// end ;
7102: LD_VAR 0 1
7106: RET
// every 0 0$01 do var i , filter ;
7107: GO 7109
7109: DISABLE
7110: LD_INT 0
7112: PPUSH
7113: PPUSH
// begin enable ;
7114: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7115: LD_INT 22
7117: PUSH
7118: LD_INT 1
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 25
7127: PUSH
7128: LD_INT 4
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: LD_INT 0
7146: GREATER
7147: IFFALSE 7156
// RaiseSailEvent ( 3 ) ;
7149: LD_INT 3
7151: PPUSH
7152: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7156: LD_INT 22
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 21
7168: PUSH
7169: LD_INT 3
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 0
7205: GREATER
7206: IFFALSE 7217
// RaiseSailEvent ( 1 ) else
7208: LD_INT 1
7210: PPUSH
7211: CALL_OW 427
7215: GO 7224
// RaiseSailEvent ( 2 ) ;
7217: LD_INT 2
7219: PPUSH
7220: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7224: LD_INT 22
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 30
7236: PUSH
7237: LD_INT 5
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PPUSH
7248: CALL_OW 69
7252: PUSH
7253: LD_INT 0
7255: GREATER
7256: IFFALSE 7265
// RaiseSailEvent ( 4 ) ;
7258: LD_INT 4
7260: PPUSH
7261: CALL_OW 427
// if gamma_towers > 0 then
7265: LD_EXP 18
7269: PUSH
7270: LD_INT 0
7272: GREATER
7273: IFFALSE 7282
// RaiseSailEvent ( 5 ) ;
7275: LD_INT 5
7277: PPUSH
7278: CALL_OW 427
// end ;
7282: PPOPN 2
7284: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7285: GO 7287
7287: DISABLE
7288: LD_INT 0
7290: PPUSH
7291: PPUSH
// begin enable ;
7292: ENABLE
// if new_veh > 0 then
7293: LD_EXP 19
7297: PUSH
7298: LD_INT 0
7300: GREATER
7301: IFFALSE 7488
// while ( new_veh > 0 ) do
7303: LD_EXP 19
7307: PUSH
7308: LD_INT 0
7310: GREATER
7311: IFFALSE 7488
// begin Wait ( 0 0$01 ) ;
7313: LD_INT 35
7315: PPUSH
7316: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7320: LD_INT 26
7322: PPUSH
7323: CALL_OW 461
7327: PUSH
7328: LD_INT 2
7330: EQUAL
7331: IFFALSE 7486
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7333: LD_ADDR_VAR 0 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 3
7343: PUSH
7344: LD_INT 3
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 1
7358: PPUSH
7359: LD_INT 4
7361: PPUSH
7362: CALL_OW 12
7366: ARRAY
7367: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7368: LD_VAR 0 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: IN
7383: IFFALSE 7418
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: LD_INT 4
7392: PUSH
7393: LD_INT 5
7395: PUSH
7396: LD_INT 7
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 1
7406: PPUSH
7407: LD_INT 3
7409: PPUSH
7410: CALL_OW 12
7414: ARRAY
7415: ST_TO_ADDR
7416: GO 7449
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_INT 5
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: LD_INT 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 3
7442: PPUSH
7443: CALL_OW 12
7447: ARRAY
7448: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7449: LD_INT 26
7451: PPUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: LD_INT 2
7462: PPUSH
7463: LD_VAR 0 2
7467: PPUSH
7468: CALL_OW 125
// new_veh := new_veh - 1 ;
7472: LD_ADDR_EXP 19
7476: PUSH
7477: LD_EXP 19
7481: PUSH
7482: LD_INT 1
7484: MINUS
7485: ST_TO_ADDR
// end ; end ;
7486: GO 7303
// end ;
7488: PPOPN 2
7490: END
// every 0 0$01 do var v , filter , am_cmeh ;
7491: GO 7493
7493: DISABLE
7494: LD_INT 0
7496: PPUSH
7497: PPUSH
7498: PPUSH
// begin enable ;
7499: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7500: LD_ADDR_VAR 0 3
7504: PUSH
7505: LD_INT 56
7507: PPUSH
7508: CALL_OW 313
7512: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 33
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 50
7540: PUSH
7541: EMPTY
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: EMPTY
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: ST_TO_ADDR
// if filter > 0 then
7557: LD_VAR 0 2
7561: PUSH
7562: LD_INT 0
7564: GREATER
7565: IFFALSE 7633
// begin for v in filter do
7567: LD_ADDR_VAR 0 1
7571: PUSH
7572: LD_VAR 0 2
7576: PUSH
7577: FOR_IN
7578: IFFALSE 7631
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7580: LD_VAR 0 1
7584: PPUSH
7585: CALL_OW 312
7589: NOT
7590: PUSH
7591: LD_VAR 0 1
7595: PPUSH
7596: CALL_OW 302
7600: AND
7601: IFFALSE 7629
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_VAR 0 3
7612: PUSH
7613: LD_INT 1
7615: PPUSH
7616: LD_INT 3
7618: PPUSH
7619: CALL_OW 12
7623: ARRAY
7624: PPUSH
7625: CALL_OW 135
// end ;
7629: GO 7577
7631: POP
7632: POP
// end ; end ;
7633: PPOPN 3
7635: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7636: LD_INT 33
7638: PUSH
7639: LD_INT 2
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 3
7648: PUSH
7649: LD_INT 34
7651: PUSH
7652: LD_INT 13
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: PUSH
7672: LD_INT 4
7674: PUSH
7675: LD_INT 5
7677: PUSH
7678: LD_INT 7
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_EXP 1
7690: ARRAY
7691: EQUAL
7692: PUSH
7693: LD_INT 26
7695: PPUSH
7696: CALL_OW 461
7700: PUSH
7701: LD_INT 2
7703: EQUAL
7704: AND
7705: IFFALSE 7916
7707: GO 7709
7709: DISABLE
7710: LD_INT 0
7712: PPUSH
7713: PPUSH
7714: PPUSH
// begin enable ;
7715: ENABLE
// if Sikorski_Ar then
7716: LD_EXP 12
7720: IFFALSE 7797
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7722: LD_ADDR_EXP 11
7726: PUSH
7727: LD_INT 2
7729: PUSH
7730: LD_INT 22
7732: PUSH
7733: LD_INT 4
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 22
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 33
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 34
7765: PUSH
7766: LD_INT 13
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: ST_TO_ADDR
7795: GO 7838
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7797: LD_ADDR_EXP 11
7801: PUSH
7802: LD_INT 33
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 3
7814: PUSH
7815: LD_INT 34
7817: PUSH
7818: LD_INT 13
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 69
7837: ST_TO_ADDR
// repeat begin for un in SForce do
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_EXP 11
7847: PUSH
7848: FOR_IN
7849: IFFALSE 7904
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7851: LD_ADDR_VAR 0 3
7855: PUSH
7856: LD_INT 22
7858: PUSH
7859: LD_INT 3
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7871: LD_VAR 0 2
7875: PPUSH
7876: LD_VAR 0 3
7880: PPUSH
7881: LD_VAR 0 2
7885: PPUSH
7886: CALL_OW 74
7890: PPUSH
7891: CALL_OW 115
// Wait ( 0 0$01 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// end ;
7902: GO 7848
7904: POP
7905: POP
// end until SForce = 0 ;
7906: LD_EXP 11
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7838
// end ;
7916: PPOPN 3
7918: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7919: LD_INT 0
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
7925: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7926: LD_ADDR_VAR 0 6
7930: PUSH
7931: LD_INT 14
7933: PPUSH
7934: EMPTY
7935: PPUSH
7936: CALL_OW 70
7940: ST_TO_ADDR
// if tmp then
7941: LD_VAR 0 6
7945: IFFALSE 7979
// for i in tmp do
7947: LD_ADDR_VAR 0 3
7951: PUSH
7952: LD_VAR 0 6
7956: PUSH
7957: FOR_IN
7958: IFFALSE 7977
// ComMoveXY ( i , 42 , 23 ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: LD_INT 42
7967: PPUSH
7968: LD_INT 23
7970: PPUSH
7971: CALL_OW 111
7975: GO 7957
7977: POP
7978: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7979: LD_INT 14
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: CALL_OW 286
// uc_side := 4 ;
7989: LD_ADDR_OWVAR 20
7993: PUSH
7994: LD_INT 4
7996: ST_TO_ADDR
// uc_nation := 1 ;
7997: LD_ADDR_OWVAR 21
8001: PUSH
8002: LD_INT 1
8004: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8005: LD_ADDR_OWVAR 37
8009: PUSH
8010: LD_INT 4
8012: ST_TO_ADDR
// vc_control := control_manual ;
8013: LD_ADDR_OWVAR 38
8017: PUSH
8018: LD_INT 1
8020: ST_TO_ADDR
// vc_engine := engine_combustion ;
8021: LD_ADDR_OWVAR 39
8025: PUSH
8026: LD_INT 1
8028: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8029: LD_ADDR_OWVAR 40
8033: PUSH
8034: LD_INT 4
8036: PUSH
8037: LD_INT 5
8039: PUSH
8040: LD_INT 7
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_EXP 1
8052: ARRAY
8053: ST_TO_ADDR
// veh := CreateVehicle ;
8054: LD_ADDR_VAR 0 5
8058: PUSH
8059: CALL_OW 45
8063: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8064: LD_VAR 0 5
8068: PPUSH
8069: LD_INT 2
8071: PPUSH
8072: LD_INT 0
8074: PPUSH
8075: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8079: LD_EXP 9
8083: PPUSH
8084: LD_VAR 0 5
8088: PPUSH
8089: CALL_OW 52
// SetMark ( veh , 1 ) ;
8093: LD_VAR 0 5
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 242
// while ( num > 0 ) do
8105: LD_VAR 0 1
8109: PUSH
8110: LD_INT 0
8112: GREATER
8113: IFFALSE 8280
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8115: LD_INT 3
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: LD_INT 3
8123: PUSH
8124: LD_INT 4
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_EXP 1
8137: PPUSH
8138: LD_INT 4
8140: PPUSH
8141: CALL_OW 12
8145: ARRAY
8146: PPUSH
8147: LD_INT 1
8149: PPUSH
8150: LD_INT 4
8152: PUSH
8153: LD_INT 5
8155: PUSH
8156: LD_INT 5
8158: PUSH
8159: LD_INT 7
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_EXP 1
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 11
8188: PPUSH
8189: LD_INT 2
8191: PPUSH
8192: LD_INT 5
8194: PUSH
8195: LD_INT 6
8197: PUSH
8198: LD_INT 7
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_EXP 1
8210: ARRAY
8211: PPUSH
8212: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8216: LD_ADDR_VAR 0 4
8220: PUSH
8221: LD_INT 22
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 69
8235: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8236: LD_VAR 0 4
8240: PUSH
8241: LD_VAR 0 4
8245: ARRAY
8246: PPUSH
8247: LD_INT 36
8249: PPUSH
8250: LD_INT 18
8252: PPUSH
8253: CALL_OW 111
// Wait ( 0 0$02 ) ;
8257: LD_INT 70
8259: PPUSH
8260: CALL_OW 67
// num := num - 1 ;
8264: LD_ADDR_VAR 0 1
8268: PUSH
8269: LD_VAR 0 1
8273: PUSH
8274: LD_INT 1
8276: MINUS
8277: ST_TO_ADDR
// end ;
8278: GO 8105
// end ;
8280: LD_VAR 0 2
8284: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8285: LD_EXP 17
8289: PUSH
8290: LD_INT 0
8292: GREATER
8293: IFFALSE 8562
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
// begin enable ;
8301: ENABLE
// for i = 1 to patrol do
8302: LD_ADDR_VAR 0 1
8306: PUSH
8307: DOUBLE
8308: LD_INT 1
8310: DEC
8311: ST_TO_ADDR
8312: LD_EXP 17
8316: PUSH
8317: FOR_TO
8318: IFFALSE 8560
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8320: LD_EXP 17
8324: PUSH
8325: LD_VAR 0 1
8329: ARRAY
8330: PUSH
8331: LD_EXP 17
8335: PUSH
8336: LD_VAR 0 1
8340: ARRAY
8341: PPUSH
8342: CALL_OW 300
8346: AND
8347: PUSH
8348: LD_EXP 17
8352: PUSH
8353: LD_VAR 0 1
8357: ARRAY
8358: PPUSH
8359: CALL_OW 314
8363: NOT
8364: AND
8365: IFFALSE 8515
// case i of 1 :
8367: LD_VAR 0 1
8371: PUSH
8372: LD_INT 1
8374: DOUBLE
8375: EQUAL
8376: IFTRUE 8380
8378: GO 8443
8380: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8381: LD_EXP 17
8385: PUSH
8386: LD_VAR 0 1
8390: ARRAY
8391: PPUSH
8392: LD_INT 53
8394: PPUSH
8395: LD_INT 91
8397: PPUSH
8398: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8402: LD_EXP 17
8406: PUSH
8407: LD_VAR 0 1
8411: ARRAY
8412: PPUSH
8413: LD_INT 245
8415: PPUSH
8416: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8420: LD_EXP 17
8424: PUSH
8425: LD_VAR 0 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 24
8433: PPUSH
8434: LD_INT 26
8436: PPUSH
8437: CALL_OW 171
// end ; 2 :
8441: GO 8515
8443: LD_INT 2
8445: DOUBLE
8446: EQUAL
8447: IFTRUE 8451
8449: GO 8514
8451: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8452: LD_EXP 17
8456: PUSH
8457: LD_VAR 0 1
8461: ARRAY
8462: PPUSH
8463: LD_INT 83
8465: PPUSH
8466: LD_INT 57
8468: PPUSH
8469: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8473: LD_EXP 17
8477: PUSH
8478: LD_VAR 0 1
8482: ARRAY
8483: PPUSH
8484: LD_INT 245
8486: PPUSH
8487: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8491: LD_EXP 17
8495: PUSH
8496: LD_VAR 0 1
8500: ARRAY
8501: PPUSH
8502: LD_INT 47
8504: PPUSH
8505: LD_INT 53
8507: PPUSH
8508: CALL_OW 171
// end ; end ;
8512: GO 8515
8514: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8515: LD_EXP 17
8519: PUSH
8520: LD_VAR 0 1
8524: ARRAY
8525: PPUSH
8526: CALL_OW 256
8530: PUSH
8531: LD_INT 1000
8533: LESS
8534: IFFALSE 8558
// patrol := patrol diff patrol [ i ] ;
8536: LD_ADDR_EXP 17
8540: PUSH
8541: LD_EXP 17
8545: PUSH
8546: LD_EXP 17
8550: PUSH
8551: LD_VAR 0 1
8555: ARRAY
8556: DIFF
8557: ST_TO_ADDR
// end ;
8558: GO 8317
8560: POP
8561: POP
// end ;
8562: PPOPN 1
8564: END
// every 0 0$10 do
8565: GO 8567
8567: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8568: LD_INT 42000
8570: PUSH
8571: LD_INT 37800
8573: PUSH
8574: LD_INT 33600
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_EXP 1
8586: ARRAY
8587: PPUSH
8588: CALL_OW 67
// if not contact_am then
8592: LD_EXP 16
8596: NOT
8597: IFFALSE 8607
// contact_am := true ;
8599: LD_ADDR_EXP 16
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// end ; end_of_file
8607: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8608: LD_INT 0
8610: PPUSH
// comp_tested := false ;
8611: LD_ADDR_EXP 22
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sikorski_run := false ;
8619: LD_ADDR_EXP 23
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// InGameOn ;
8627: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8631: LD_EXP 3
8635: PPUSH
8636: CALL_OW 87
// Wait ( 0 0$01 ) ;
8640: LD_INT 35
8642: PPUSH
8643: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8647: LD_EXP 2
8651: PPUSH
8652: LD_STRING Dpop1
8654: PPUSH
8655: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8659: LD_EXP 3
8663: PPUSH
8664: LD_STRING Dcomm1
8666: PPUSH
8667: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8671: LD_EXP 2
8675: PPUSH
8676: LD_STRING Dpop2
8678: PPUSH
8679: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8683: LD_EXP 3
8687: PPUSH
8688: LD_STRING Dcomm2
8690: PPUSH
8691: CALL_OW 88
// InGameOff ;
8695: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8699: LD_STRING T1
8701: PPUSH
8702: CALL_OW 337
// end ;
8706: LD_VAR 0 1
8710: RET
// every 0 0$01 trigger timer > 2 2$01 do
8711: LD_EXP 24
8715: PUSH
8716: LD_INT 4235
8718: GREATER
8719: IFFALSE 8736
8721: GO 8723
8723: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8724: LD_EXP 5
8728: PPUSH
8729: LD_STRING DKap1
8731: PPUSH
8732: CALL_OW 94
// end ;
8736: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8737: LD_EXP 24
8741: PUSH
8742: LD_INT 46200
8744: PUSH
8745: LD_INT 52500
8747: PUSH
8748: LD_INT 63000
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: LD_EXP 1
8760: ARRAY
8761: GREATER
8762: IFFALSE 9129
8764: GO 8766
8766: DISABLE
8767: LD_INT 0
8769: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8770: LD_EXP 5
8774: PPUSH
8775: LD_STRING DKap2
8777: PPUSH
8778: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8782: LD_INT 10
8784: PPUSH
8785: CALL_OW 67
// Say ( commander , Dcommk ) ;
8789: LD_EXP 3
8793: PPUSH
8794: LD_STRING Dcommk
8796: PPUSH
8797: CALL_OW 88
// Wait ( 0 0$44 ) ;
8801: LD_INT 1540
8803: PPUSH
8804: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8808: LD_EXP 5
8812: PPUSH
8813: LD_INT 3
8815: PPUSH
8816: LD_INT 0
8818: PPUSH
8819: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8823: LD_EXP 5
8827: PPUSH
8828: CALL_OW 87
// Wait ( 0 0$10 ) ;
8832: LD_INT 350
8834: PPUSH
8835: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8839: LD_INT 6
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 8
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_EXP 1
8857: ARRAY
8858: PPUSH
8859: CALL 7919 0 1
// Wait ( 2 2$00 ) ;
8863: LD_INT 4200
8865: PPUSH
8866: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8870: LD_INT 33
8872: PUSH
8873: LD_INT 2
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 3
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 13
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 69
8905: PUSH
8906: LD_INT 3
8908: LESS
8909: IFFALSE 8920
// Wait ( 0 0$01 ) ;
8911: LD_INT 35
8913: PPUSH
8914: CALL_OW 67
8918: GO 8870
// uc_side := 4 ;
8920: LD_ADDR_OWVAR 20
8924: PUSH
8925: LD_INT 4
8927: ST_TO_ADDR
// uc_nation := 1 ;
8928: LD_ADDR_OWVAR 21
8932: PUSH
8933: LD_INT 1
8935: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8936: LD_ADDR_VAR 0 1
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_INT 4
8948: PUSH
8949: LD_INT 5
8951: PUSH
8952: LD_INT 6
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: PUSH
8960: LD_EXP 1
8964: ARRAY
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9009
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8969: LD_INT 1
8971: PPUSH
8972: LD_INT 5
8974: PUSH
8975: LD_INT 6
8977: PUSH
8978: LD_INT 7
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: LIST
8985: PUSH
8986: LD_EXP 1
8990: ARRAY
8991: PPUSH
8992: CALL 734 0 2
8996: PPUSH
8997: LD_INT 4
8999: PPUSH
9000: LD_INT 0
9002: PPUSH
9003: CALL_OW 49
9007: GO 8966
9009: POP
9010: POP
// sikorski_ar := true ;
9011: LD_ADDR_EXP 12
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9019: LD_EXP 9
9023: PPUSH
9024: LD_STRING DSik1
9026: PPUSH
9027: CALL_OW 94
// Wait ( 0 0$30 ) ;
9031: LD_INT 1050
9033: PPUSH
9034: CALL_OW 67
// uc_side := 4 ;
9038: LD_ADDR_OWVAR 20
9042: PUSH
9043: LD_INT 4
9045: ST_TO_ADDR
// uc_nation := 1 ;
9046: LD_ADDR_OWVAR 21
9050: PUSH
9051: LD_INT 1
9053: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: DOUBLE
9060: LD_INT 1
9062: DEC
9063: ST_TO_ADDR
9064: LD_INT 3
9066: PUSH
9067: LD_INT 4
9069: PUSH
9070: LD_INT 4
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_EXP 1
9082: ARRAY
9083: PUSH
9084: FOR_TO
9085: IFFALSE 9127
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9087: LD_INT 1
9089: PPUSH
9090: LD_INT 5
9092: PUSH
9093: LD_INT 6
9095: PUSH
9096: LD_INT 7
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: LD_EXP 1
9108: ARRAY
9109: PPUSH
9110: CALL 734 0 2
9114: PPUSH
9115: LD_INT 13
9117: PPUSH
9118: LD_INT 0
9120: PPUSH
9121: CALL_OW 49
9125: GO 9084
9127: POP
9128: POP
// end ;
9129: PPOPN 1
9131: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9132: LD_EXP 9
9136: PPUSH
9137: CALL_OW 256
9141: PUSH
9142: LD_INT 650
9144: LESS
9145: IFFALSE 9227
9147: GO 9149
9149: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9150: LD_EXP 9
9154: PPUSH
9155: LD_STRING DSik2
9157: PPUSH
9158: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9162: LD_EXP 9
9166: PPUSH
9167: CALL_OW 300
9171: IFFALSE 9227
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9173: LD_EXP 9
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 113
// Wait ( 0 0$01 ) ;
9185: LD_INT 35
9187: PPUSH
9188: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9192: LD_EXP 9
9196: PPUSH
9197: LD_INT 2
9199: PPUSH
9200: CALL_OW 308
9204: IFFALSE 9225
// begin RemoveUnit ( sikorski ) ;
9206: LD_EXP 9
9210: PPUSH
9211: CALL_OW 64
// break ;
9215: GO 9227
// sikorski_run := true ;
9217: LD_ADDR_EXP 23
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// end ; end ;
9225: GO 9162
// end ;
9227: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9228: LD_EXP 9
9232: PPUSH
9233: CALL_OW 256
9237: PUSH
9238: LD_INT 1000
9240: LESS
9241: IFFALSE 9258
9243: GO 9245
9245: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9246: LD_EXP 9
9250: PPUSH
9251: LD_STRING DSkik3
9253: PPUSH
9254: CALL_OW 88
9258: END
// every 1 1$45 + 0 0$15 do
9259: GO 9261
9261: DISABLE
// begin enable ;
9262: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9263: LD_INT 1
9265: PPUSH
9266: LD_INT 5
9268: PPUSH
9269: CALL_OW 12
9273: PPUSH
9274: LD_INT 8
9276: PPUSH
9277: LD_INT 1
9279: PPUSH
9280: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9284: LD_INT 350
9286: PPUSH
9287: LD_INT 1295
9289: PPUSH
9290: CALL_OW 12
9294: PPUSH
9295: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9299: LD_INT 1
9301: PPUSH
9302: LD_INT 5
9304: PPUSH
9305: CALL_OW 12
9309: PPUSH
9310: LD_INT 1
9312: PPUSH
9313: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9317: LD_INT 350
9319: PPUSH
9320: LD_INT 1050
9322: PPUSH
9323: CALL_OW 12
9327: PPUSH
9328: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9332: LD_EXP 24
9336: PUSH
9337: LD_INT 25200
9339: PUSH
9340: LD_INT 23100
9342: PUSH
9343: LD_INT 21000
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_EXP 1
9355: ARRAY
9356: LESSEQUAL
9357: IFFALSE 9380
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9359: LD_INT 1
9361: PPUSH
9362: LD_INT 5
9364: PPUSH
9365: CALL_OW 12
9369: PPUSH
9370: LD_INT 8
9372: PPUSH
9373: LD_INT 1
9375: PPUSH
9376: CALL_OW 55
// end ;
9380: END
// export timer ; every 1 do
9381: GO 9383
9383: DISABLE
// timer := 0 0$00 ;
9384: LD_ADDR_EXP 24
9388: PUSH
9389: LD_INT 0
9391: ST_TO_ADDR
9392: END
// every 0 0$01 do
9393: GO 9395
9395: DISABLE
// begin enable ;
9396: ENABLE
// Display_Strings := [ #tick , timer ] ;
9397: LD_ADDR_OWVAR 47
9401: PUSH
9402: LD_STRING #tick
9404: PUSH
9405: LD_EXP 24
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9414: LD_ADDR_EXP 24
9418: PUSH
9419: LD_EXP 24
9423: PUSH
9424: LD_INT 35
9426: PLUS
9427: ST_TO_ADDR
// end ; end_of_file
9428: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9429: GO 9431
9431: DISABLE
// begin ru_radar := 98 ;
9432: LD_ADDR_EXP 25
9436: PUSH
9437: LD_INT 98
9439: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9440: LD_ADDR_EXP 26
9444: PUSH
9445: LD_INT 89
9447: ST_TO_ADDR
// us_hack := 99 ;
9448: LD_ADDR_EXP 27
9452: PUSH
9453: LD_INT 99
9455: ST_TO_ADDR
// us_artillery := 97 ;
9456: LD_ADDR_EXP 28
9460: PUSH
9461: LD_INT 97
9463: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9464: LD_ADDR_EXP 29
9468: PUSH
9469: LD_INT 91
9471: ST_TO_ADDR
// end ; end_of_file end_of_file
9472: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
9473: GO 9475
9475: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
9476: LD_STRING initStreamRollete();
9478: PPUSH
9479: CALL_OW 559
// InitStreamMode ;
9483: CALL 9488 0 0
// end ;
9487: END
// function InitStreamMode ; begin
9488: LD_INT 0
9490: PPUSH
// streamModeActive := false ;
9491: LD_ADDR_EXP 30
9495: PUSH
9496: LD_INT 0
9498: ST_TO_ADDR
// sRocket := false ;
9499: LD_ADDR_EXP 33
9503: PUSH
9504: LD_INT 0
9506: ST_TO_ADDR
// sSpeed := false ;
9507: LD_ADDR_EXP 32
9511: PUSH
9512: LD_INT 0
9514: ST_TO_ADDR
// sEngine := false ;
9515: LD_ADDR_EXP 34
9519: PUSH
9520: LD_INT 0
9522: ST_TO_ADDR
// sSpec := false ;
9523: LD_ADDR_EXP 31
9527: PUSH
9528: LD_INT 0
9530: ST_TO_ADDR
// sLevel := false ;
9531: LD_ADDR_EXP 35
9535: PUSH
9536: LD_INT 0
9538: ST_TO_ADDR
// sArmoury := false ;
9539: LD_ADDR_EXP 36
9543: PUSH
9544: LD_INT 0
9546: ST_TO_ADDR
// sRadar := false ;
9547: LD_ADDR_EXP 37
9551: PUSH
9552: LD_INT 0
9554: ST_TO_ADDR
// sBunker := false ;
9555: LD_ADDR_EXP 38
9559: PUSH
9560: LD_INT 0
9562: ST_TO_ADDR
// sHack := false ;
9563: LD_ADDR_EXP 39
9567: PUSH
9568: LD_INT 0
9570: ST_TO_ADDR
// sFire := false ;
9571: LD_ADDR_EXP 40
9575: PUSH
9576: LD_INT 0
9578: ST_TO_ADDR
// sRefresh := false ;
9579: LD_ADDR_EXP 41
9583: PUSH
9584: LD_INT 0
9586: ST_TO_ADDR
// sExp := false ;
9587: LD_ADDR_EXP 42
9591: PUSH
9592: LD_INT 0
9594: ST_TO_ADDR
// sDepot := false ;
9595: LD_ADDR_EXP 43
9599: PUSH
9600: LD_INT 0
9602: ST_TO_ADDR
// sFlag := false ;
9603: LD_ADDR_EXP 44
9607: PUSH
9608: LD_INT 0
9610: ST_TO_ADDR
// sKamikadze := false ;
9611: LD_ADDR_EXP 52
9615: PUSH
9616: LD_INT 0
9618: ST_TO_ADDR
// sTroll := false ;
9619: LD_ADDR_EXP 53
9623: PUSH
9624: LD_INT 0
9626: ST_TO_ADDR
// sSlow := false ;
9627: LD_ADDR_EXP 54
9631: PUSH
9632: LD_INT 0
9634: ST_TO_ADDR
// sLack := false ;
9635: LD_ADDR_EXP 55
9639: PUSH
9640: LD_INT 0
9642: ST_TO_ADDR
// sTank := false ;
9643: LD_ADDR_EXP 57
9647: PUSH
9648: LD_INT 0
9650: ST_TO_ADDR
// sRemote := false ;
9651: LD_ADDR_EXP 58
9655: PUSH
9656: LD_INT 0
9658: ST_TO_ADDR
// sSold := false ;
9659: LD_ADDR_EXP 45
9663: PUSH
9664: LD_INT 0
9666: ST_TO_ADDR
// sDiff := false ;
9667: LD_ADDR_EXP 46
9671: PUSH
9672: LD_INT 0
9674: ST_TO_ADDR
// sFog := false ;
9675: LD_ADDR_EXP 49
9679: PUSH
9680: LD_INT 0
9682: ST_TO_ADDR
// sReset := false ;
9683: LD_ADDR_EXP 50
9687: PUSH
9688: LD_INT 0
9690: ST_TO_ADDR
// sSun := false ;
9691: LD_ADDR_EXP 51
9695: PUSH
9696: LD_INT 0
9698: ST_TO_ADDR
// sTiger := false ;
9699: LD_ADDR_EXP 47
9703: PUSH
9704: LD_INT 0
9706: ST_TO_ADDR
// sBomb := false ;
9707: LD_ADDR_EXP 48
9711: PUSH
9712: LD_INT 0
9714: ST_TO_ADDR
// sWound := false ;
9715: LD_ADDR_EXP 56
9719: PUSH
9720: LD_INT 0
9722: ST_TO_ADDR
// end ;
9723: LD_VAR 0 1
9727: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
9728: LD_VAR 0 2
9732: PUSH
9733: LD_INT 100
9735: EQUAL
9736: IFFALSE 10271
// begin if not StreamModeActive then
9738: LD_EXP 30
9742: NOT
9743: IFFALSE 9753
// StreamModeActive := true ;
9745: LD_ADDR_EXP 30
9749: PUSH
9750: LD_INT 1
9752: ST_TO_ADDR
// if p3 = 0 then
9753: LD_VAR 0 3
9757: PUSH
9758: LD_INT 0
9760: EQUAL
9761: IFFALSE 9767
// InitStreamMode ;
9763: CALL 9488 0 0
// if p3 = 1 then
9767: LD_VAR 0 3
9771: PUSH
9772: LD_INT 1
9774: EQUAL
9775: IFFALSE 9785
// sRocket := true ;
9777: LD_ADDR_EXP 33
9781: PUSH
9782: LD_INT 1
9784: ST_TO_ADDR
// if p3 = 2 then
9785: LD_VAR 0 3
9789: PUSH
9790: LD_INT 2
9792: EQUAL
9793: IFFALSE 9803
// sSpeed := true ;
9795: LD_ADDR_EXP 32
9799: PUSH
9800: LD_INT 1
9802: ST_TO_ADDR
// if p3 = 3 then
9803: LD_VAR 0 3
9807: PUSH
9808: LD_INT 3
9810: EQUAL
9811: IFFALSE 9821
// sEngine := true ;
9813: LD_ADDR_EXP 34
9817: PUSH
9818: LD_INT 1
9820: ST_TO_ADDR
// if p3 = 4 then
9821: LD_VAR 0 3
9825: PUSH
9826: LD_INT 4
9828: EQUAL
9829: IFFALSE 9839
// sSpec := true ;
9831: LD_ADDR_EXP 31
9835: PUSH
9836: LD_INT 1
9838: ST_TO_ADDR
// if p3 = 5 then
9839: LD_VAR 0 3
9843: PUSH
9844: LD_INT 5
9846: EQUAL
9847: IFFALSE 9857
// sLevel := true ;
9849: LD_ADDR_EXP 35
9853: PUSH
9854: LD_INT 1
9856: ST_TO_ADDR
// if p3 = 6 then
9857: LD_VAR 0 3
9861: PUSH
9862: LD_INT 6
9864: EQUAL
9865: IFFALSE 9875
// sArmoury := true ;
9867: LD_ADDR_EXP 36
9871: PUSH
9872: LD_INT 1
9874: ST_TO_ADDR
// if p3 = 7 then
9875: LD_VAR 0 3
9879: PUSH
9880: LD_INT 7
9882: EQUAL
9883: IFFALSE 9893
// sRadar := true ;
9885: LD_ADDR_EXP 37
9889: PUSH
9890: LD_INT 1
9892: ST_TO_ADDR
// if p3 = 8 then
9893: LD_VAR 0 3
9897: PUSH
9898: LD_INT 8
9900: EQUAL
9901: IFFALSE 9911
// sBunker := true ;
9903: LD_ADDR_EXP 38
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// if p3 = 9 then
9911: LD_VAR 0 3
9915: PUSH
9916: LD_INT 9
9918: EQUAL
9919: IFFALSE 9929
// sHack := true ;
9921: LD_ADDR_EXP 39
9925: PUSH
9926: LD_INT 1
9928: ST_TO_ADDR
// if p3 = 10 then
9929: LD_VAR 0 3
9933: PUSH
9934: LD_INT 10
9936: EQUAL
9937: IFFALSE 9947
// sFire := true ;
9939: LD_ADDR_EXP 40
9943: PUSH
9944: LD_INT 1
9946: ST_TO_ADDR
// if p3 = 11 then
9947: LD_VAR 0 3
9951: PUSH
9952: LD_INT 11
9954: EQUAL
9955: IFFALSE 9965
// sRefresh := true ;
9957: LD_ADDR_EXP 41
9961: PUSH
9962: LD_INT 1
9964: ST_TO_ADDR
// if p3 = 12 then
9965: LD_VAR 0 3
9969: PUSH
9970: LD_INT 12
9972: EQUAL
9973: IFFALSE 9983
// sExp := true ;
9975: LD_ADDR_EXP 42
9979: PUSH
9980: LD_INT 1
9982: ST_TO_ADDR
// if p3 = 13 then
9983: LD_VAR 0 3
9987: PUSH
9988: LD_INT 13
9990: EQUAL
9991: IFFALSE 10001
// sDepot := true ;
9993: LD_ADDR_EXP 43
9997: PUSH
9998: LD_INT 1
10000: ST_TO_ADDR
// if p3 = 14 then
10001: LD_VAR 0 3
10005: PUSH
10006: LD_INT 14
10008: EQUAL
10009: IFFALSE 10019
// sFlag := true ;
10011: LD_ADDR_EXP 44
10015: PUSH
10016: LD_INT 1
10018: ST_TO_ADDR
// if p3 = 15 then
10019: LD_VAR 0 3
10023: PUSH
10024: LD_INT 15
10026: EQUAL
10027: IFFALSE 10037
// sKamikadze := true ;
10029: LD_ADDR_EXP 52
10033: PUSH
10034: LD_INT 1
10036: ST_TO_ADDR
// if p3 = 16 then
10037: LD_VAR 0 3
10041: PUSH
10042: LD_INT 16
10044: EQUAL
10045: IFFALSE 10055
// sTroll := true ;
10047: LD_ADDR_EXP 53
10051: PUSH
10052: LD_INT 1
10054: ST_TO_ADDR
// if p3 = 17 then
10055: LD_VAR 0 3
10059: PUSH
10060: LD_INT 17
10062: EQUAL
10063: IFFALSE 10073
// sSlow := true ;
10065: LD_ADDR_EXP 54
10069: PUSH
10070: LD_INT 1
10072: ST_TO_ADDR
// if p3 = 18 then
10073: LD_VAR 0 3
10077: PUSH
10078: LD_INT 18
10080: EQUAL
10081: IFFALSE 10091
// sLack := true ;
10083: LD_ADDR_EXP 55
10087: PUSH
10088: LD_INT 1
10090: ST_TO_ADDR
// if p3 = 19 then
10091: LD_VAR 0 3
10095: PUSH
10096: LD_INT 19
10098: EQUAL
10099: IFFALSE 10109
// sTank := true ;
10101: LD_ADDR_EXP 57
10105: PUSH
10106: LD_INT 1
10108: ST_TO_ADDR
// if p3 = 20 then
10109: LD_VAR 0 3
10113: PUSH
10114: LD_INT 20
10116: EQUAL
10117: IFFALSE 10127
// sRemote := true ;
10119: LD_ADDR_EXP 58
10123: PUSH
10124: LD_INT 1
10126: ST_TO_ADDR
// if p3 = 101 then
10127: LD_VAR 0 3
10131: PUSH
10132: LD_INT 101
10134: EQUAL
10135: IFFALSE 10145
// sSold := true ;
10137: LD_ADDR_EXP 45
10141: PUSH
10142: LD_INT 1
10144: ST_TO_ADDR
// if p3 = 102 then
10145: LD_VAR 0 3
10149: PUSH
10150: LD_INT 102
10152: EQUAL
10153: IFFALSE 10163
// sDiff := true ;
10155: LD_ADDR_EXP 46
10159: PUSH
10160: LD_INT 1
10162: ST_TO_ADDR
// if p3 = 103 then
10163: LD_VAR 0 3
10167: PUSH
10168: LD_INT 103
10170: EQUAL
10171: IFFALSE 10181
// sFog := true ;
10173: LD_ADDR_EXP 49
10177: PUSH
10178: LD_INT 1
10180: ST_TO_ADDR
// if p3 = 104 then
10181: LD_VAR 0 3
10185: PUSH
10186: LD_INT 104
10188: EQUAL
10189: IFFALSE 10199
// sReset := true ;
10191: LD_ADDR_EXP 50
10195: PUSH
10196: LD_INT 1
10198: ST_TO_ADDR
// if p3 = 105 then
10199: LD_VAR 0 3
10203: PUSH
10204: LD_INT 105
10206: EQUAL
10207: IFFALSE 10217
// sSun := true ;
10209: LD_ADDR_EXP 51
10213: PUSH
10214: LD_INT 1
10216: ST_TO_ADDR
// if p3 = 106 then
10217: LD_VAR 0 3
10221: PUSH
10222: LD_INT 106
10224: EQUAL
10225: IFFALSE 10235
// sTiger := true ;
10227: LD_ADDR_EXP 47
10231: PUSH
10232: LD_INT 1
10234: ST_TO_ADDR
// if p3 = 107 then
10235: LD_VAR 0 3
10239: PUSH
10240: LD_INT 107
10242: EQUAL
10243: IFFALSE 10253
// sBomb := true ;
10245: LD_ADDR_EXP 48
10249: PUSH
10250: LD_INT 1
10252: ST_TO_ADDR
// if p3 = 108 then
10253: LD_VAR 0 3
10257: PUSH
10258: LD_INT 108
10260: EQUAL
10261: IFFALSE 10271
// sWound := true ;
10263: LD_ADDR_EXP 56
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
// end ; end ;
10271: PPOPN 6
10273: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
10274: LD_EXP 30
10278: PUSH
10279: LD_EXP 33
10283: AND
10284: IFFALSE 10405
10286: GO 10288
10288: DISABLE
10289: LD_INT 0
10291: PPUSH
10292: PPUSH
// begin enable ;
10293: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
10294: LD_ADDR_VAR 0 2
10298: PUSH
10299: LD_INT 22
10301: PUSH
10302: LD_OWVAR 2
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PUSH
10311: LD_INT 2
10313: PUSH
10314: LD_INT 34
10316: PUSH
10317: LD_INT 7
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 34
10326: PUSH
10327: LD_INT 45
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 34
10336: PUSH
10337: LD_INT 28
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PUSH
10344: LD_INT 34
10346: PUSH
10347: LD_INT 47
10349: PUSH
10350: EMPTY
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PUSH
10361: EMPTY
10362: LIST
10363: LIST
10364: PPUSH
10365: CALL_OW 69
10369: ST_TO_ADDR
// if not tmp then
10370: LD_VAR 0 2
10374: NOT
10375: IFFALSE 10379
// exit ;
10377: GO 10405
// for i in tmp do
10379: LD_ADDR_VAR 0 1
10383: PUSH
10384: LD_VAR 0 2
10388: PUSH
10389: FOR_IN
10390: IFFALSE 10403
// begin DestroyUnit ( i ) ;
10392: LD_VAR 0 1
10396: PPUSH
10397: CALL_OW 65
// end ;
10401: GO 10389
10403: POP
10404: POP
// end ;
10405: PPOPN 2
10407: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
10408: LD_EXP 30
10412: PUSH
10413: LD_EXP 34
10417: AND
10418: IFFALSE 10499
10420: GO 10422
10422: DISABLE
10423: LD_INT 0
10425: PPUSH
10426: PPUSH
// begin enable ;
10427: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
10428: LD_ADDR_VAR 0 2
10432: PUSH
10433: LD_INT 22
10435: PUSH
10436: LD_OWVAR 2
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 32
10447: PUSH
10448: LD_INT 3
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PPUSH
10459: CALL_OW 69
10463: ST_TO_ADDR
// if not tmp then
10464: LD_VAR 0 2
10468: NOT
10469: IFFALSE 10473
// exit ;
10471: GO 10499
// for i in tmp do
10473: LD_ADDR_VAR 0 1
10477: PUSH
10478: LD_VAR 0 2
10482: PUSH
10483: FOR_IN
10484: IFFALSE 10497
// begin DestroyUnit ( i ) ;
10486: LD_VAR 0 1
10490: PPUSH
10491: CALL_OW 65
// end ;
10495: GO 10483
10497: POP
10498: POP
// end ;
10499: PPOPN 2
10501: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
10502: LD_EXP 30
10506: PUSH
10507: LD_EXP 31
10511: AND
10512: IFFALSE 10605
10514: GO 10516
10516: DISABLE
10517: LD_INT 0
10519: PPUSH
// begin enable ;
10520: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
10521: LD_ADDR_VAR 0 1
10525: PUSH
10526: LD_INT 22
10528: PUSH
10529: LD_OWVAR 2
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 2
10540: PUSH
10541: LD_INT 25
10543: PUSH
10544: LD_INT 5
10546: PUSH
10547: EMPTY
10548: LIST
10549: LIST
10550: PUSH
10551: LD_INT 25
10553: PUSH
10554: LD_INT 9
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: PUSH
10561: LD_INT 25
10563: PUSH
10564: LD_INT 8
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: PUSH
10577: EMPTY
10578: LIST
10579: LIST
10580: PPUSH
10581: CALL_OW 69
10585: PUSH
10586: FOR_IN
10587: IFFALSE 10603
// begin SetClass ( i , 1 ) ;
10589: LD_VAR 0 1
10593: PPUSH
10594: LD_INT 1
10596: PPUSH
10597: CALL_OW 336
// end ;
10601: GO 10586
10603: POP
10604: POP
// end ;
10605: PPOPN 1
10607: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
10608: LD_EXP 30
10612: PUSH
10613: LD_EXP 32
10617: AND
10618: PUSH
10619: LD_OWVAR 65
10623: PUSH
10624: LD_INT 7
10626: LESS
10627: AND
10628: IFFALSE 10642
10630: GO 10632
10632: DISABLE
// begin enable ;
10633: ENABLE
// game_speed := 7 ;
10634: LD_ADDR_OWVAR 65
10638: PUSH
10639: LD_INT 7
10641: ST_TO_ADDR
// end ;
10642: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
10643: LD_EXP 30
10647: PUSH
10648: LD_EXP 35
10652: AND
10653: IFFALSE 10855
10655: GO 10657
10657: DISABLE
10658: LD_INT 0
10660: PPUSH
10661: PPUSH
10662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
10663: LD_ADDR_VAR 0 3
10667: PUSH
10668: LD_INT 81
10670: PUSH
10671: LD_OWVAR 2
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PUSH
10680: LD_INT 21
10682: PUSH
10683: LD_INT 1
10685: PUSH
10686: EMPTY
10687: LIST
10688: LIST
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PPUSH
10694: CALL_OW 69
10698: ST_TO_ADDR
// if not tmp then
10699: LD_VAR 0 3
10703: NOT
10704: IFFALSE 10708
// exit ;
10706: GO 10855
// if tmp > 5 then
10708: LD_VAR 0 3
10712: PUSH
10713: LD_INT 5
10715: GREATER
10716: IFFALSE 10728
// k := 5 else
10718: LD_ADDR_VAR 0 2
10722: PUSH
10723: LD_INT 5
10725: ST_TO_ADDR
10726: GO 10738
// k := tmp ;
10728: LD_ADDR_VAR 0 2
10732: PUSH
10733: LD_VAR 0 3
10737: ST_TO_ADDR
// for i := 1 to k do
10738: LD_ADDR_VAR 0 1
10742: PUSH
10743: DOUBLE
10744: LD_INT 1
10746: DEC
10747: ST_TO_ADDR
10748: LD_VAR 0 2
10752: PUSH
10753: FOR_TO
10754: IFFALSE 10853
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
10756: LD_VAR 0 3
10760: PUSH
10761: LD_VAR 0 1
10765: ARRAY
10766: PPUSH
10767: LD_VAR 0 1
10771: PUSH
10772: LD_INT 4
10774: MOD
10775: PUSH
10776: LD_INT 1
10778: PLUS
10779: PPUSH
10780: CALL_OW 259
10784: PUSH
10785: LD_INT 10
10787: LESS
10788: IFFALSE 10851
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
10790: LD_VAR 0 3
10794: PUSH
10795: LD_VAR 0 1
10799: ARRAY
10800: PPUSH
10801: LD_VAR 0 1
10805: PUSH
10806: LD_INT 4
10808: MOD
10809: PUSH
10810: LD_INT 1
10812: PLUS
10813: PPUSH
10814: LD_VAR 0 3
10818: PUSH
10819: LD_VAR 0 1
10823: ARRAY
10824: PPUSH
10825: LD_VAR 0 1
10829: PUSH
10830: LD_INT 4
10832: MOD
10833: PUSH
10834: LD_INT 1
10836: PLUS
10837: PPUSH
10838: CALL_OW 259
10842: PUSH
10843: LD_INT 1
10845: PLUS
10846: PPUSH
10847: CALL_OW 237
10851: GO 10753
10853: POP
10854: POP
// end ;
10855: PPOPN 3
10857: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
10858: LD_EXP 30
10862: PUSH
10863: LD_EXP 36
10867: AND
10868: IFFALSE 10888
10870: GO 10872
10872: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
10873: LD_INT 4
10875: PPUSH
10876: LD_OWVAR 2
10880: PPUSH
10881: LD_INT 0
10883: PPUSH
10884: CALL_OW 324
10888: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
10889: LD_EXP 30
10893: PUSH
10894: LD_EXP 37
10898: AND
10899: IFFALSE 10998
10901: GO 10903
10903: DISABLE
10904: LD_INT 0
10906: PPUSH
10907: PPUSH
// begin enable ;
10908: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
10909: LD_ADDR_VAR 0 2
10913: PUSH
10914: LD_INT 22
10916: PUSH
10917: LD_OWVAR 2
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 2
10928: PUSH
10929: LD_INT 34
10931: PUSH
10932: LD_INT 11
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: LD_INT 34
10941: PUSH
10942: LD_INT 30
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PPUSH
10958: CALL_OW 69
10962: ST_TO_ADDR
// if not tmp then
10963: LD_VAR 0 2
10967: NOT
10968: IFFALSE 10972
// exit ;
10970: GO 10998
// for i in tmp do
10972: LD_ADDR_VAR 0 1
10976: PUSH
10977: LD_VAR 0 2
10981: PUSH
10982: FOR_IN
10983: IFFALSE 10996
// begin DestroyUnit ( i ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: CALL_OW 65
// end ;
10994: GO 10982
10996: POP
10997: POP
// end ;
10998: PPOPN 2
11000: END
// every 0 0$1 trigger StreamModeActive and sBunker do
11001: LD_EXP 30
11005: PUSH
11006: LD_EXP 38
11010: AND
11011: IFFALSE 11031
11013: GO 11015
11015: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
11016: LD_INT 32
11018: PPUSH
11019: LD_OWVAR 2
11023: PPUSH
11024: LD_INT 0
11026: PPUSH
11027: CALL_OW 324
11031: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
11032: LD_EXP 30
11036: PUSH
11037: LD_EXP 39
11041: AND
11042: IFFALSE 11223
11044: GO 11046
11046: DISABLE
11047: LD_INT 0
11049: PPUSH
11050: PPUSH
11051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
11052: LD_ADDR_VAR 0 2
11056: PUSH
11057: LD_INT 22
11059: PUSH
11060: LD_OWVAR 2
11064: PUSH
11065: EMPTY
11066: LIST
11067: LIST
11068: PUSH
11069: LD_INT 33
11071: PUSH
11072: LD_INT 3
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PPUSH
11083: CALL_OW 69
11087: ST_TO_ADDR
// if not tmp then
11088: LD_VAR 0 2
11092: NOT
11093: IFFALSE 11097
// exit ;
11095: GO 11223
// side := 0 ;
11097: LD_ADDR_VAR 0 3
11101: PUSH
11102: LD_INT 0
11104: ST_TO_ADDR
// for i := 1 to 8 do
11105: LD_ADDR_VAR 0 1
11109: PUSH
11110: DOUBLE
11111: LD_INT 1
11113: DEC
11114: ST_TO_ADDR
11115: LD_INT 8
11117: PUSH
11118: FOR_TO
11119: IFFALSE 11167
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
11121: LD_OWVAR 2
11125: PUSH
11126: LD_VAR 0 1
11130: NONEQUAL
11131: PUSH
11132: LD_OWVAR 2
11136: PPUSH
11137: LD_VAR 0 1
11141: PPUSH
11142: CALL_OW 81
11146: PUSH
11147: LD_INT 2
11149: EQUAL
11150: AND
11151: IFFALSE 11165
// begin side := i ;
11153: LD_ADDR_VAR 0 3
11157: PUSH
11158: LD_VAR 0 1
11162: ST_TO_ADDR
// break ;
11163: GO 11167
// end ;
11165: GO 11118
11167: POP
11168: POP
// if not side then
11169: LD_VAR 0 3
11173: NOT
11174: IFFALSE 11178
// exit ;
11176: GO 11223
// for i := 1 to tmp do
11178: LD_ADDR_VAR 0 1
11182: PUSH
11183: DOUBLE
11184: LD_INT 1
11186: DEC
11187: ST_TO_ADDR
11188: LD_VAR 0 2
11192: PUSH
11193: FOR_TO
11194: IFFALSE 11221
// if Prob ( 30 ) then
11196: LD_INT 30
11198: PPUSH
11199: CALL_OW 13
11203: IFFALSE 11219
// SetSide ( i , side ) ;
11205: LD_VAR 0 1
11209: PPUSH
11210: LD_VAR 0 3
11214: PPUSH
11215: CALL_OW 235
11219: GO 11193
11221: POP
11222: POP
// end ;
11223: PPOPN 3
11225: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
11226: LD_EXP 30
11230: PUSH
11231: LD_EXP 41
11235: AND
11236: IFFALSE 11355
11238: GO 11240
11240: DISABLE
11241: LD_INT 0
11243: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
11244: LD_ADDR_VAR 0 1
11248: PUSH
11249: LD_INT 22
11251: PUSH
11252: LD_OWVAR 2
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 21
11263: PUSH
11264: LD_INT 1
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: LD_INT 3
11273: PUSH
11274: LD_INT 23
11276: PUSH
11277: LD_INT 0
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: LIST
11292: PPUSH
11293: CALL_OW 69
11297: PUSH
11298: FOR_IN
11299: IFFALSE 11353
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
11301: LD_VAR 0 1
11305: PPUSH
11306: CALL_OW 257
11310: PUSH
11311: LD_INT 1
11313: PUSH
11314: LD_INT 2
11316: PUSH
11317: LD_INT 3
11319: PUSH
11320: LD_INT 4
11322: PUSH
11323: EMPTY
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: IN
11329: IFFALSE 11351
// SetClass ( un , rand ( 1 , 4 ) ) ;
11331: LD_VAR 0 1
11335: PPUSH
11336: LD_INT 1
11338: PPUSH
11339: LD_INT 4
11341: PPUSH
11342: CALL_OW 12
11346: PPUSH
11347: CALL_OW 336
11351: GO 11298
11353: POP
11354: POP
// end ;
11355: PPOPN 1
11357: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
11358: LD_EXP 30
11362: PUSH
11363: LD_EXP 40
11367: AND
11368: IFFALSE 11447
11370: GO 11372
11372: DISABLE
11373: LD_INT 0
11375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
11376: LD_ADDR_VAR 0 1
11380: PUSH
11381: LD_INT 22
11383: PUSH
11384: LD_OWVAR 2
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: LD_INT 21
11395: PUSH
11396: LD_INT 3
11398: PUSH
11399: EMPTY
11400: LIST
11401: LIST
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: PPUSH
11407: CALL_OW 69
11411: ST_TO_ADDR
// if not tmp then
11412: LD_VAR 0 1
11416: NOT
11417: IFFALSE 11421
// exit ;
11419: GO 11447
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 1
11428: PPUSH
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 12
11438: ARRAY
11439: PPUSH
11440: LD_INT 100
11442: PPUSH
11443: CALL_OW 234
// end ;
11447: PPOPN 1
11449: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
11450: LD_EXP 30
11454: PUSH
11455: LD_EXP 42
11459: AND
11460: IFFALSE 11558
11462: GO 11464
11464: DISABLE
11465: LD_INT 0
11467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11468: LD_ADDR_VAR 0 1
11472: PUSH
11473: LD_INT 22
11475: PUSH
11476: LD_OWVAR 2
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: PUSH
11485: LD_INT 21
11487: PUSH
11488: LD_INT 1
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: PPUSH
11499: CALL_OW 69
11503: ST_TO_ADDR
// if not tmp then
11504: LD_VAR 0 1
11508: NOT
11509: IFFALSE 11513
// exit ;
11511: GO 11558
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 1
11520: PPUSH
11521: LD_VAR 0 1
11525: PPUSH
11526: CALL_OW 12
11530: ARRAY
11531: PPUSH
11532: LD_INT 1
11534: PPUSH
11535: LD_INT 4
11537: PPUSH
11538: CALL_OW 12
11542: PPUSH
11543: LD_INT 3000
11545: PPUSH
11546: LD_INT 9000
11548: PPUSH
11549: CALL_OW 12
11553: PPUSH
11554: CALL_OW 492
// end ;
11558: PPOPN 1
11560: END
// every 0 0$1 trigger StreamModeActive and sDepot do
11561: LD_EXP 30
11565: PUSH
11566: LD_EXP 43
11570: AND
11571: IFFALSE 11591
11573: GO 11575
11575: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
11576: LD_INT 1
11578: PPUSH
11579: LD_OWVAR 2
11583: PPUSH
11584: LD_INT 0
11586: PPUSH
11587: CALL_OW 324
11591: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
11592: LD_EXP 30
11596: PUSH
11597: LD_EXP 44
11601: AND
11602: IFFALSE 11685
11604: GO 11606
11606: DISABLE
11607: LD_INT 0
11609: PPUSH
11610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
11611: LD_ADDR_VAR 0 2
11615: PUSH
11616: LD_INT 22
11618: PUSH
11619: LD_OWVAR 2
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: LD_INT 21
11630: PUSH
11631: LD_INT 3
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: EMPTY
11639: LIST
11640: LIST
11641: PPUSH
11642: CALL_OW 69
11646: ST_TO_ADDR
// if not tmp then
11647: LD_VAR 0 2
11651: NOT
11652: IFFALSE 11656
// exit ;
11654: GO 11685
// for i in tmp do
11656: LD_ADDR_VAR 0 1
11660: PUSH
11661: LD_VAR 0 2
11665: PUSH
11666: FOR_IN
11667: IFFALSE 11683
// SetBLevel ( i , 10 ) ;
11669: LD_VAR 0 1
11673: PPUSH
11674: LD_INT 10
11676: PPUSH
11677: CALL_OW 241
11681: GO 11666
11683: POP
11684: POP
// end ;
11685: PPOPN 2
11687: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
11688: LD_EXP 30
11692: PUSH
11693: LD_EXP 45
11697: AND
11698: IFFALSE 11801
11700: GO 11702
11702: DISABLE
11703: LD_INT 0
11705: PPUSH
11706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11707: LD_ADDR_VAR 0 2
11711: PUSH
11712: LD_INT 22
11714: PUSH
11715: LD_OWVAR 2
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: LD_INT 25
11726: PUSH
11727: LD_INT 1
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: EMPTY
11735: LIST
11736: LIST
11737: PPUSH
11738: CALL_OW 69
11742: ST_TO_ADDR
// if not tmp then
11743: LD_VAR 0 2
11747: NOT
11748: IFFALSE 11752
// exit ;
11750: GO 11801
// for i in tmp do
11752: LD_ADDR_VAR 0 1
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: FOR_IN
11763: IFFALSE 11799
// begin if Crawls ( i ) then
11765: LD_VAR 0 1
11769: PPUSH
11770: CALL_OW 318
11774: IFFALSE 11785
// ComWalk ( i ) ;
11776: LD_VAR 0 1
11780: PPUSH
11781: CALL_OW 138
// SetClass ( i , 4 ) ;
11785: LD_VAR 0 1
11789: PPUSH
11790: LD_INT 4
11792: PPUSH
11793: CALL_OW 336
// end ;
11797: GO 11762
11799: POP
11800: POP
// end ;
11801: PPOPN 2
11803: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
11804: LD_EXP 30
11808: PUSH
11809: LD_EXP 46
11813: AND
11814: PUSH
11815: LD_OWVAR 67
11819: PUSH
11820: LD_INT 3
11822: LESS
11823: AND
11824: IFFALSE 11843
11826: GO 11828
11828: DISABLE
// Difficulty := Difficulty + 1 ;
11829: LD_ADDR_OWVAR 67
11833: PUSH
11834: LD_OWVAR 67
11838: PUSH
11839: LD_INT 1
11841: PLUS
11842: ST_TO_ADDR
11843: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
11844: LD_EXP 30
11848: PUSH
11849: LD_EXP 47
11853: AND
11854: IFFALSE 11957
11856: GO 11858
11858: DISABLE
11859: LD_INT 0
11861: PPUSH
// begin for i := 1 to 5 do
11862: LD_ADDR_VAR 0 1
11866: PUSH
11867: DOUBLE
11868: LD_INT 1
11870: DEC
11871: ST_TO_ADDR
11872: LD_INT 5
11874: PUSH
11875: FOR_TO
11876: IFFALSE 11955
// begin uc_nation := nation_nature ;
11878: LD_ADDR_OWVAR 21
11882: PUSH
11883: LD_INT 0
11885: ST_TO_ADDR
// uc_side := 0 ;
11886: LD_ADDR_OWVAR 20
11890: PUSH
11891: LD_INT 0
11893: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11894: LD_ADDR_OWVAR 29
11898: PUSH
11899: LD_INT 12
11901: PUSH
11902: LD_INT 12
11904: PUSH
11905: EMPTY
11906: LIST
11907: LIST
11908: ST_TO_ADDR
// hc_agressivity := 20 ;
11909: LD_ADDR_OWVAR 35
11913: PUSH
11914: LD_INT 20
11916: ST_TO_ADDR
// hc_class := class_tiger ;
11917: LD_ADDR_OWVAR 28
11921: PUSH
11922: LD_INT 14
11924: ST_TO_ADDR
// hc_gallery :=  ;
11925: LD_ADDR_OWVAR 33
11929: PUSH
11930: LD_STRING 
11932: ST_TO_ADDR
// hc_name :=  ;
11933: LD_ADDR_OWVAR 26
11937: PUSH
11938: LD_STRING 
11940: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
11941: CALL_OW 44
11945: PPUSH
11946: LD_INT 0
11948: PPUSH
11949: CALL_OW 51
// end ;
11953: GO 11875
11955: POP
11956: POP
// end ;
11957: PPOPN 1
11959: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
11960: LD_EXP 30
11964: PUSH
11965: LD_EXP 48
11969: AND
11970: IFFALSE 12144
11972: GO 11974
11974: DISABLE
11975: LD_INT 0
11977: PPUSH
11978: PPUSH
11979: PPUSH
11980: PPUSH
// begin result := false ;
11981: LD_ADDR_VAR 0 4
11985: PUSH
11986: LD_INT 0
11988: ST_TO_ADDR
// for i := 1 to 8 do
11989: LD_ADDR_VAR 0 1
11993: PUSH
11994: DOUBLE
11995: LD_INT 1
11997: DEC
11998: ST_TO_ADDR
11999: LD_INT 8
12001: PUSH
12002: FOR_TO
12003: IFFALSE 12114
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_INT 10
12012: PUSH
12013: LD_INT 50
12015: PUSH
12016: LD_INT 90
12018: PUSH
12019: LD_INT 140
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 1
12030: PPUSH
12031: LD_INT 4
12033: PPUSH
12034: CALL_OW 12
12038: ARRAY
12039: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
12040: LD_ADDR_VAR 0 3
12044: PUSH
12045: LD_INT 10
12047: PUSH
12048: LD_INT 50
12050: PUSH
12051: LD_INT 90
12053: PUSH
12054: LD_INT 140
12056: PUSH
12057: EMPTY
12058: LIST
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_INT 1
12065: PPUSH
12066: LD_INT 4
12068: PPUSH
12069: CALL_OW 12
12073: ARRAY
12074: ST_TO_ADDR
// if ValidHex ( x , y ) then
12075: LD_VAR 0 2
12079: PPUSH
12080: LD_VAR 0 3
12084: PPUSH
12085: CALL_OW 488
12089: IFFALSE 12112
// begin result := [ x , y ] ;
12091: LD_ADDR_VAR 0 4
12095: PUSH
12096: LD_VAR 0 2
12100: PUSH
12101: LD_VAR 0 3
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: ST_TO_ADDR
// break ;
12110: GO 12114
// end ; end ;
12112: GO 12002
12114: POP
12115: POP
// if result then
12116: LD_VAR 0 4
12120: IFFALSE 12144
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
12122: LD_VAR 0 4
12126: PUSH
12127: LD_INT 1
12129: ARRAY
12130: PPUSH
12131: LD_VAR 0 4
12135: PUSH
12136: LD_INT 2
12138: ARRAY
12139: PPUSH
12140: CALL_OW 429
// end ;
12144: PPOPN 4
12146: END
// every 0 0$1 trigger StreamModeActive and sReset do
12147: LD_EXP 30
12151: PUSH
12152: LD_EXP 50
12156: AND
12157: IFFALSE 12169
12159: GO 12161
12161: DISABLE
// YouLost (  ) ;
12162: LD_STRING 
12164: PPUSH
12165: CALL_OW 104
12169: END
// every 0 0$1 trigger StreamModeActive and sFog do
12170: LD_EXP 30
12174: PUSH
12175: LD_EXP 49
12179: AND
12180: IFFALSE 12194
12182: GO 12184
12184: DISABLE
// FogOff ( your_side ) ;
12185: LD_OWVAR 2
12189: PPUSH
12190: CALL_OW 344
12194: END
// every 0 0$1 trigger StreamModeActive and sSun do
12195: LD_EXP 30
12199: PUSH
12200: LD_EXP 51
12204: AND
12205: IFFALSE 12233
12207: GO 12209
12209: DISABLE
// begin solar_recharge_percent := 0 ;
12210: LD_ADDR_OWVAR 79
12214: PUSH
12215: LD_INT 0
12217: ST_TO_ADDR
// wait ( 5 5$00 ) ;
12218: LD_INT 10500
12220: PPUSH
12221: CALL_OW 67
// solar_recharge_percent := 100 ;
12225: LD_ADDR_OWVAR 79
12229: PUSH
12230: LD_INT 100
12232: ST_TO_ADDR
// end ;
12233: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
12234: LD_EXP 30
12238: PUSH
12239: LD_EXP 52
12243: AND
12244: IFFALSE 12399
12246: GO 12248
12248: DISABLE
12249: LD_INT 0
12251: PPUSH
12252: PPUSH
// begin for i := 1 to 6 do
12253: LD_ADDR_VAR 0 1
12257: PUSH
12258: DOUBLE
12259: LD_INT 1
12261: DEC
12262: ST_TO_ADDR
12263: LD_INT 6
12265: PUSH
12266: FOR_TO
12267: IFFALSE 12397
// begin uc_nation := nation_nature ;
12269: LD_ADDR_OWVAR 21
12273: PUSH
12274: LD_INT 0
12276: ST_TO_ADDR
// uc_side := 0 ;
12277: LD_ADDR_OWVAR 20
12281: PUSH
12282: LD_INT 0
12284: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
12285: LD_ADDR_OWVAR 29
12289: PUSH
12290: LD_INT 12
12292: PUSH
12293: LD_INT 12
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: ST_TO_ADDR
// hc_agressivity := 20 ;
12300: LD_ADDR_OWVAR 35
12304: PUSH
12305: LD_INT 20
12307: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
12308: LD_ADDR_OWVAR 28
12312: PUSH
12313: LD_INT 17
12315: ST_TO_ADDR
// hc_gallery :=  ;
12316: LD_ADDR_OWVAR 33
12320: PUSH
12321: LD_STRING 
12323: ST_TO_ADDR
// hc_name :=  ;
12324: LD_ADDR_OWVAR 26
12328: PUSH
12329: LD_STRING 
12331: ST_TO_ADDR
// un := CreateHuman ;
12332: LD_ADDR_VAR 0 2
12336: PUSH
12337: CALL_OW 44
12341: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
12342: LD_VAR 0 2
12346: PPUSH
12347: LD_INT 1
12349: PPUSH
12350: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 3
12361: PUSH
12362: LD_INT 22
12364: PUSH
12365: LD_INT 0
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PPUSH
12376: CALL_OW 69
12380: PPUSH
12381: LD_VAR 0 2
12385: PPUSH
12386: CALL_OW 74
12390: PPUSH
12391: CALL_OW 115
// end ;
12395: GO 12266
12397: POP
12398: POP
// end ;
12399: PPOPN 2
12401: END
// every 0 0$1 trigger StreamModeActive and sTroll do
12402: LD_EXP 30
12406: PUSH
12407: LD_EXP 53
12411: AND
12412: IFFALSE 12438
12414: GO 12416
12416: DISABLE
// begin ToLua ( displayTroll(); ) ;
12417: LD_STRING displayTroll();
12419: PPUSH
12420: CALL_OW 559
// wait ( 3 3$00 ) ;
12424: LD_INT 6300
12426: PPUSH
12427: CALL_OW 67
// ToLua ( hideTroll(); ) ;
12431: LD_STRING hideTroll();
12433: PPUSH
12434: CALL_OW 559
// end ;
12438: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
12439: LD_EXP 30
12443: PUSH
12444: LD_EXP 54
12448: AND
12449: IFFALSE 12512
12451: GO 12453
12453: DISABLE
12454: LD_INT 0
12456: PPUSH
// begin p := 0 ;
12457: LD_ADDR_VAR 0 1
12461: PUSH
12462: LD_INT 0
12464: ST_TO_ADDR
// repeat game_speed := 1 ;
12465: LD_ADDR_OWVAR 65
12469: PUSH
12470: LD_INT 1
12472: ST_TO_ADDR
// wait ( 0 0$1 ) ;
12473: LD_INT 35
12475: PPUSH
12476: CALL_OW 67
// p := p + 1 ;
12480: LD_ADDR_VAR 0 1
12484: PUSH
12485: LD_VAR 0 1
12489: PUSH
12490: LD_INT 1
12492: PLUS
12493: ST_TO_ADDR
// until p >= 60 ;
12494: LD_VAR 0 1
12498: PUSH
12499: LD_INT 60
12501: GREATEREQUAL
12502: IFFALSE 12465
// game_speed := 4 ;
12504: LD_ADDR_OWVAR 65
12508: PUSH
12509: LD_INT 4
12511: ST_TO_ADDR
// end ;
12512: PPOPN 1
12514: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
12515: LD_EXP 30
12519: PUSH
12520: LD_EXP 55
12524: AND
12525: IFFALSE 12671
12527: GO 12529
12529: DISABLE
12530: LD_INT 0
12532: PPUSH
12533: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12534: LD_ADDR_VAR 0 1
12538: PUSH
12539: LD_INT 22
12541: PUSH
12542: LD_OWVAR 2
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 2
12553: PUSH
12554: LD_INT 30
12556: PUSH
12557: LD_INT 0
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: LD_INT 30
12566: PUSH
12567: LD_INT 1
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PPUSH
12583: CALL_OW 69
12587: ST_TO_ADDR
// if not depot then
12588: LD_VAR 0 1
12592: NOT
12593: IFFALSE 12597
// exit ;
12595: GO 12671
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
12597: LD_ADDR_VAR 0 2
12601: PUSH
12602: LD_VAR 0 1
12606: PUSH
12607: LD_INT 1
12609: PPUSH
12610: LD_VAR 0 1
12614: PPUSH
12615: CALL_OW 12
12619: ARRAY
12620: PPUSH
12621: CALL_OW 274
12625: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_INT 1
12633: PPUSH
12634: LD_INT 0
12636: PPUSH
12637: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
12641: LD_VAR 0 2
12645: PPUSH
12646: LD_INT 2
12648: PPUSH
12649: LD_INT 0
12651: PPUSH
12652: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
12656: LD_VAR 0 2
12660: PPUSH
12661: LD_INT 3
12663: PPUSH
12664: LD_INT 0
12666: PPUSH
12667: CALL_OW 277
// end ;
12671: PPOPN 2
12673: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
12674: LD_EXP 30
12678: PUSH
12679: LD_EXP 56
12683: AND
12684: IFFALSE 12781
12686: GO 12688
12688: DISABLE
12689: LD_INT 0
12691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12692: LD_ADDR_VAR 0 1
12696: PUSH
12697: LD_INT 22
12699: PUSH
12700: LD_OWVAR 2
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: PUSH
12709: LD_INT 21
12711: PUSH
12712: LD_INT 1
12714: PUSH
12715: EMPTY
12716: LIST
12717: LIST
12718: PUSH
12719: LD_INT 3
12721: PUSH
12722: LD_INT 23
12724: PUSH
12725: LD_INT 0
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: LIST
12740: PPUSH
12741: CALL_OW 69
12745: ST_TO_ADDR
// if not tmp then
12746: LD_VAR 0 1
12750: NOT
12751: IFFALSE 12755
// exit ;
12753: GO 12781
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
12755: LD_VAR 0 1
12759: PUSH
12760: LD_INT 1
12762: PPUSH
12763: LD_VAR 0 1
12767: PPUSH
12768: CALL_OW 12
12772: ARRAY
12773: PPUSH
12774: LD_INT 200
12776: PPUSH
12777: CALL_OW 234
// end ;
12781: PPOPN 1
12783: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
12784: LD_EXP 30
12788: PUSH
12789: LD_EXP 57
12793: AND
12794: IFFALSE 12873
12796: GO 12798
12798: DISABLE
12799: LD_INT 0
12801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
12802: LD_ADDR_VAR 0 1
12806: PUSH
12807: LD_INT 22
12809: PUSH
12810: LD_OWVAR 2
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 21
12821: PUSH
12822: LD_INT 2
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PPUSH
12833: CALL_OW 69
12837: ST_TO_ADDR
// if not tmp then
12838: LD_VAR 0 1
12842: NOT
12843: IFFALSE 12847
// exit ;
12845: GO 12873
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
12847: LD_VAR 0 1
12851: PUSH
12852: LD_INT 1
12854: PPUSH
12855: LD_VAR 0 1
12859: PPUSH
12860: CALL_OW 12
12864: ARRAY
12865: PPUSH
12866: LD_INT 10
12868: PPUSH
12869: CALL_OW 234
// end ;
12873: PPOPN 1
12875: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
12876: LD_EXP 30
12880: PUSH
12881: LD_EXP 58
12885: AND
12886: IFFALSE 12985
12888: GO 12890
12890: DISABLE
12891: LD_INT 0
12893: PPUSH
12894: PPUSH
// begin enable ;
12895: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
12896: LD_ADDR_VAR 0 1
12900: PUSH
12901: LD_INT 22
12903: PUSH
12904: LD_OWVAR 2
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: LD_INT 61
12915: PUSH
12916: EMPTY
12917: LIST
12918: PUSH
12919: LD_INT 33
12921: PUSH
12922: LD_INT 2
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: PPUSH
12934: CALL_OW 69
12938: ST_TO_ADDR
// if not tmp then
12939: LD_VAR 0 1
12943: NOT
12944: IFFALSE 12948
// exit ;
12946: GO 12985
// for i in tmp do
12948: LD_ADDR_VAR 0 2
12952: PUSH
12953: LD_VAR 0 1
12957: PUSH
12958: FOR_IN
12959: IFFALSE 12983
// if IsControledBy ( i ) then
12961: LD_VAR 0 2
12965: PPUSH
12966: CALL_OW 312
12970: IFFALSE 12981
// ComUnlink ( i ) ;
12972: LD_VAR 0 2
12976: PPUSH
12977: CALL_OW 136
12981: GO 12958
12983: POP
12984: POP
// end ; end_of_file
12985: PPOPN 2
12987: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
12988: LD_INT 0
12990: PPUSH
12991: PPUSH
12992: PPUSH
12993: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
12994: LD_VAR 0 1
12998: PPUSH
12999: CALL_OW 264
13003: PUSH
13004: LD_EXP 29
13008: EQUAL
13009: IFFALSE 13081
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13011: LD_INT 68
13013: PPUSH
13014: LD_VAR 0 1
13018: PPUSH
13019: CALL_OW 255
13023: PPUSH
13024: CALL_OW 321
13028: PUSH
13029: LD_INT 2
13031: EQUAL
13032: IFFALSE 13044
// eff := 70 else
13034: LD_ADDR_VAR 0 6
13038: PUSH
13039: LD_INT 70
13041: ST_TO_ADDR
13042: GO 13052
// eff := 30 ;
13044: LD_ADDR_VAR 0 6
13048: PUSH
13049: LD_INT 30
13051: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13052: LD_VAR 0 1
13056: PPUSH
13057: CALL_OW 250
13061: PPUSH
13062: LD_VAR 0 1
13066: PPUSH
13067: CALL_OW 251
13071: PPUSH
13072: LD_VAR 0 6
13076: PPUSH
13077: CALL_OW 495
// end ; end ;
13081: LD_VAR 0 4
13085: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
13086: LD_INT 0
13088: PPUSH
13089: PPUSH
13090: PPUSH
13091: PPUSH
13092: PPUSH
13093: PPUSH
// if cmd = 124 then
13094: LD_VAR 0 1
13098: PUSH
13099: LD_INT 124
13101: EQUAL
13102: IFFALSE 13308
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
13104: LD_ADDR_VAR 0 5
13108: PUSH
13109: LD_INT 2
13111: PUSH
13112: LD_INT 34
13114: PUSH
13115: LD_INT 53
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: PUSH
13122: LD_INT 34
13124: PUSH
13125: LD_INT 14
13127: PUSH
13128: EMPTY
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: PPUSH
13137: CALL_OW 69
13141: ST_TO_ADDR
// if not tmp then
13142: LD_VAR 0 5
13146: NOT
13147: IFFALSE 13151
// exit ;
13149: GO 13308
// for i in tmp do
13151: LD_ADDR_VAR 0 3
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: FOR_IN
13162: IFFALSE 13306
// begin taskList := GetTaskList ( i ) ;
13164: LD_ADDR_VAR 0 6
13168: PUSH
13169: LD_VAR 0 3
13173: PPUSH
13174: CALL_OW 437
13178: ST_TO_ADDR
// if not taskList then
13179: LD_VAR 0 6
13183: NOT
13184: IFFALSE 13188
// continue ;
13186: GO 13161
// for j = 1 to taskList do
13188: LD_ADDR_VAR 0 4
13192: PUSH
13193: DOUBLE
13194: LD_INT 1
13196: DEC
13197: ST_TO_ADDR
13198: LD_VAR 0 6
13202: PUSH
13203: FOR_TO
13204: IFFALSE 13302
// if taskList [ j ] [ 1 ] = | then
13206: LD_VAR 0 6
13210: PUSH
13211: LD_VAR 0 4
13215: ARRAY
13216: PUSH
13217: LD_INT 1
13219: ARRAY
13220: PUSH
13221: LD_STRING |
13223: EQUAL
13224: IFFALSE 13300
// begin _taskList := Delete ( taskList , 1 ) ;
13226: LD_ADDR_VAR 0 7
13230: PUSH
13231: LD_VAR 0 6
13235: PPUSH
13236: LD_INT 1
13238: PPUSH
13239: CALL_OW 3
13243: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
13244: LD_VAR 0 3
13248: PPUSH
13249: LD_VAR 0 7
13253: PPUSH
13254: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
13258: LD_VAR 0 3
13262: PPUSH
13263: LD_VAR 0 6
13267: PUSH
13268: LD_VAR 0 4
13272: ARRAY
13273: PUSH
13274: LD_INT 2
13276: ARRAY
13277: PPUSH
13278: LD_VAR 0 6
13282: PUSH
13283: LD_VAR 0 4
13287: ARRAY
13288: PUSH
13289: LD_INT 3
13291: ARRAY
13292: PPUSH
13293: LD_INT 8
13295: PPUSH
13296: CALL 13313 0 4
// end ;
13300: GO 13203
13302: POP
13303: POP
// end ;
13304: GO 13161
13306: POP
13307: POP
// end ; end ;
13308: LD_VAR 0 2
13312: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13313: LD_INT 0
13315: PPUSH
13316: PPUSH
13317: PPUSH
13318: PPUSH
13319: PPUSH
13320: PPUSH
13321: PPUSH
13322: PPUSH
13323: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13324: LD_VAR 0 1
13328: NOT
13329: PUSH
13330: LD_VAR 0 2
13334: PPUSH
13335: LD_VAR 0 3
13339: PPUSH
13340: CALL_OW 488
13344: NOT
13345: OR
13346: PUSH
13347: LD_VAR 0 4
13351: NOT
13352: OR
13353: IFFALSE 13357
// exit ;
13355: GO 13697
// list := [ ] ;
13357: LD_ADDR_VAR 0 13
13361: PUSH
13362: EMPTY
13363: ST_TO_ADDR
// if x - r < 0 then
13364: LD_VAR 0 2
13368: PUSH
13369: LD_VAR 0 4
13373: MINUS
13374: PUSH
13375: LD_INT 0
13377: LESS
13378: IFFALSE 13390
// min_x := 0 else
13380: LD_ADDR_VAR 0 7
13384: PUSH
13385: LD_INT 0
13387: ST_TO_ADDR
13388: GO 13406
// min_x := x - r ;
13390: LD_ADDR_VAR 0 7
13394: PUSH
13395: LD_VAR 0 2
13399: PUSH
13400: LD_VAR 0 4
13404: MINUS
13405: ST_TO_ADDR
// if y - r < 0 then
13406: LD_VAR 0 3
13410: PUSH
13411: LD_VAR 0 4
13415: MINUS
13416: PUSH
13417: LD_INT 0
13419: LESS
13420: IFFALSE 13432
// min_y := 0 else
13422: LD_ADDR_VAR 0 8
13426: PUSH
13427: LD_INT 0
13429: ST_TO_ADDR
13430: GO 13448
// min_y := y - r ;
13432: LD_ADDR_VAR 0 8
13436: PUSH
13437: LD_VAR 0 3
13441: PUSH
13442: LD_VAR 0 4
13446: MINUS
13447: ST_TO_ADDR
// max_x := x + r ;
13448: LD_ADDR_VAR 0 9
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: LD_VAR 0 4
13462: PLUS
13463: ST_TO_ADDR
// max_y := y + r ;
13464: LD_ADDR_VAR 0 10
13468: PUSH
13469: LD_VAR 0 3
13473: PUSH
13474: LD_VAR 0 4
13478: PLUS
13479: ST_TO_ADDR
// for _x = min_x to max_x do
13480: LD_ADDR_VAR 0 11
13484: PUSH
13485: DOUBLE
13486: LD_VAR 0 7
13490: DEC
13491: ST_TO_ADDR
13492: LD_VAR 0 9
13496: PUSH
13497: FOR_TO
13498: IFFALSE 13615
// for _y = min_y to max_y do
13500: LD_ADDR_VAR 0 12
13504: PUSH
13505: DOUBLE
13506: LD_VAR 0 8
13510: DEC
13511: ST_TO_ADDR
13512: LD_VAR 0 10
13516: PUSH
13517: FOR_TO
13518: IFFALSE 13611
// begin if not ValidHex ( _x , _y ) then
13520: LD_VAR 0 11
13524: PPUSH
13525: LD_VAR 0 12
13529: PPUSH
13530: CALL_OW 488
13534: NOT
13535: IFFALSE 13539
// continue ;
13537: GO 13517
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
13539: LD_VAR 0 11
13543: PPUSH
13544: LD_VAR 0 12
13548: PPUSH
13549: CALL_OW 351
13553: PUSH
13554: LD_VAR 0 11
13558: PPUSH
13559: LD_VAR 0 12
13563: PPUSH
13564: CALL_OW 554
13568: AND
13569: IFFALSE 13609
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
13571: LD_ADDR_VAR 0 13
13575: PUSH
13576: LD_VAR 0 13
13580: PPUSH
13581: LD_VAR 0 13
13585: PUSH
13586: LD_INT 1
13588: PLUS
13589: PPUSH
13590: LD_VAR 0 11
13594: PUSH
13595: LD_VAR 0 12
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PPUSH
13604: CALL_OW 2
13608: ST_TO_ADDR
// end ;
13609: GO 13517
13611: POP
13612: POP
13613: GO 13497
13615: POP
13616: POP
// if not list then
13617: LD_VAR 0 13
13621: NOT
13622: IFFALSE 13626
// exit ;
13624: GO 13697
// for i in list do
13626: LD_ADDR_VAR 0 6
13630: PUSH
13631: LD_VAR 0 13
13635: PUSH
13636: FOR_IN
13637: IFFALSE 13695
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
13639: LD_VAR 0 1
13643: PPUSH
13644: LD_STRING M
13646: PUSH
13647: LD_VAR 0 6
13651: PUSH
13652: LD_INT 1
13654: ARRAY
13655: PUSH
13656: LD_VAR 0 6
13660: PUSH
13661: LD_INT 2
13663: ARRAY
13664: PUSH
13665: LD_INT 0
13667: PUSH
13668: LD_INT 0
13670: PUSH
13671: LD_INT 0
13673: PUSH
13674: LD_INT 0
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: PUSH
13686: EMPTY
13687: LIST
13688: PPUSH
13689: CALL_OW 447
13693: GO 13636
13695: POP
13696: POP
// end ;
13697: LD_VAR 0 5
13701: RET
