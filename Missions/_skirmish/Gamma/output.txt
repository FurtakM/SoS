// starting begin InGameOn ;
   0: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// RandomizeAll ;
  14: CALL_OW 11
// DestroyTrash ;
  18: CALL 195 0 0
// ShowPath ;
  22: CALL 261 0 0
// RandMusic ( 1 , 3 ) ;
  26: LD_INT 1
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: CALL 269 0 2
// Wait ( 0 0$01 ) ;
  36: LD_INT 35
  38: PPUSH
  39: CALL_OW 67
// case Query ( textdiff ) of 1 :
  43: LD_STRING textdiff
  45: PPUSH
  46: CALL_OW 97
  50: PUSH
  51: LD_INT 1
  53: DOUBLE
  54: EQUAL
  55: IFTRUE 59
  57: GO 69
  59: POP
// SetDifficulty ( 1 ) ; 2 :
  60: LD_INT 1
  62: PPUSH
  63: CALL 326 0 1
  67: GO 106
  69: LD_INT 2
  71: DOUBLE
  72: EQUAL
  73: IFTRUE 77
  75: GO 87
  77: POP
// SetDifficulty ( 2 ) ; 3 :
  78: LD_INT 2
  80: PPUSH
  81: CALL 326 0 1
  85: GO 106
  87: LD_INT 3
  89: DOUBLE
  90: EQUAL
  91: IFTRUE 95
  93: GO 105
  95: POP
// SetDifficulty ( 3 ) ; end ;
  96: LD_INT 3
  98: PPUSH
  99: CALL 326 0 1
 103: GO 106
 105: POP
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
 106: LD_INT 8
 108: PUSH
 109: LD_INT 7
 111: PUSH
 112: LD_INT 6
 114: PUSH
 115: EMPTY
 116: LIST
 117: LIST
 118: LIST
 119: PUSH
 120: LD_EXP 1
 124: ARRAY
 125: PPUSH
 126: LD_INT 2
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 10
 134: PPUSH
 135: CALL 414 0 4
// PrepareRussian ;
 139: CALL 1492 0 0
// Action ;
 143: CALL 8595 0 0
// PrepareAmerican ;
 147: CALL 5279 0 0
// end ;
 151: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 152: GO 154
 154: DISABLE
 155: LD_INT 0
 157: PPUSH
 158: PPUSH
// begin bool := Rand ( false , true ) ;
 159: LD_ADDR_VAR 0 2
 163: PUSH
 164: LD_INT 0
 166: PPUSH
 167: LD_INT 1
 169: PPUSH
 170: CALL_OW 12
 174: ST_TO_ADDR
// if bool then
 175: LD_VAR 0 2
 179: IFFALSE 191
// RandMusic ( 1 , 3 ) ;
 181: LD_INT 1
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: CALL 269 0 2
// enable ;
 191: ENABLE
// end ; end_of_file
 192: PPOPN 2
 194: END
// export function DestroyTrash ; var i ; begin
 195: LD_INT 0
 197: PPUSH
 198: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 199: LD_ADDR_VAR 0 2
 203: PUSH
 204: LD_INT 22
 206: PUSH
 207: LD_INT 0
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: PUSH
 214: LD_INT 3
 216: PUSH
 217: LD_INT 24
 219: PUSH
 220: LD_INT 5
 222: PUSH
 223: EMPTY
 224: LIST
 225: LIST
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: PPUSH
 235: CALL_OW 69
 239: PUSH
 240: FOR_IN
 241: IFFALSE 254
// KillUnit ( i ) ;
 243: LD_VAR 0 2
 247: PPUSH
 248: CALL_OW 66
 252: GO 240
 254: POP
 255: POP
// end ;
 256: LD_VAR 0 1
 260: RET
// export function ShowPath ; begin
 261: LD_INT 0
 263: PPUSH
// end ;
 264: LD_VAR 0 1
 268: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 269: LD_INT 0
 271: PPUSH
 272: PPUSH
// proc := Rand ( 0 , 100 ) ;
 273: LD_ADDR_VAR 0 4
 277: PUSH
 278: LD_INT 0
 280: PPUSH
 281: LD_INT 100
 283: PPUSH
 284: CALL_OW 12
 288: ST_TO_ADDR
// if proc > 50 then
 289: LD_VAR 0 4
 293: PUSH
 294: LD_INT 50
 296: GREATER
 297: IFFALSE 311
// music_nat := n1 else
 299: LD_ADDR_OWVAR 71
 303: PUSH
 304: LD_VAR 0 1
 308: ST_TO_ADDR
 309: GO 321
// music_nat := n2 ;
 311: LD_ADDR_OWVAR 71
 315: PUSH
 316: LD_VAR 0 2
 320: ST_TO_ADDR
// end ;
 321: LD_VAR 0 3
 325: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 326: LD_INT 0
 328: PPUSH
// case val of 1 :
 329: LD_VAR 0 1
 333: PUSH
 334: LD_INT 1
 336: DOUBLE
 337: EQUAL
 338: IFTRUE 342
 340: GO 353
 342: POP
// dif := 1 ; 2 :
 343: LD_ADDR_EXP 1
 347: PUSH
 348: LD_INT 1
 350: ST_TO_ADDR
 351: GO 392
 353: LD_INT 2
 355: DOUBLE
 356: EQUAL
 357: IFTRUE 361
 359: GO 372
 361: POP
// dif := 2 ; 3 :
 362: LD_ADDR_EXP 1
 366: PUSH
 367: LD_INT 2
 369: ST_TO_ADDR
 370: GO 392
 372: LD_INT 3
 374: DOUBLE
 375: EQUAL
 376: IFTRUE 380
 378: GO 391
 380: POP
// dif := 3 ; end ;
 381: LD_ADDR_EXP 1
 385: PUSH
 386: LD_INT 3
 388: ST_TO_ADDR
 389: GO 392
 391: POP
// if dif < 3 then
 392: LD_EXP 1
 396: PUSH
 397: LD_INT 3
 399: LESS
 400: IFFALSE 409
// RemoveEnvironmentArea ( evnt ) ;
 402: LD_INT 9
 404: PPUSH
 405: CALL_OW 355
// end ;
 409: LD_VAR 0 2
 413: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 414: LD_INT 0
 416: PPUSH
 417: PPUSH
 418: PPUSH
 419: PPUSH
 420: PPUSH
// uc_nation = nation_nature ;
 421: LD_ADDR_OWVAR 21
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// uc_side = 0 ;
 429: LD_ADDR_OWVAR 20
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// hc_importance := 0 ;
 437: LD_ADDR_OWVAR 32
 441: PUSH
 442: LD_INT 0
 444: ST_TO_ADDR
// l = 0 ;
 445: LD_ADDR_VAR 0 6
 449: PUSH
 450: LD_INT 0
 452: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 453: LD_ADDR_OWVAR 24
 457: PUSH
 458: LD_INT 0
 460: PPUSH
 461: LD_INT 5
 463: PPUSH
 464: CALL_OW 12
 468: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 469: LD_ADDR_OWVAR 35
 473: PUSH
 474: LD_INT 5
 476: NEG
 477: PPUSH
 478: LD_INT 5
 480: PPUSH
 481: CALL_OW 12
 485: ST_TO_ADDR
// hc_gallery =  ;
 486: LD_ADDR_OWVAR 33
 490: PUSH
 491: LD_STRING 
 493: ST_TO_ADDR
// hc_class = class_apeman ;
 494: LD_ADDR_OWVAR 28
 498: PUSH
 499: LD_INT 12
 501: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 502: LD_ADDR_OWVAR 29
 506: PUSH
 507: LD_INT 11
 509: PPUSH
 510: LD_INT 13
 512: PPUSH
 513: CALL_OW 12
 517: PUSH
 518: LD_INT 10
 520: PPUSH
 521: LD_INT 11
 523: PPUSH
 524: CALL_OW 12
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: ST_TO_ADDR
// hc_sex = sex_male ;
 533: LD_ADDR_OWVAR 27
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 541: LD_ADDR_OWVAR 31
 545: PUSH
 546: LD_INT 0
 548: PPUSH
 549: LD_INT 2
 551: PPUSH
 552: CALL_OW 12
 556: PUSH
 557: LD_INT 0
 559: PUSH
 560: LD_INT 0
 562: PUSH
 563: LD_INT 0
 565: PUSH
 566: EMPTY
 567: LIST
 568: LIST
 569: LIST
 570: LIST
 571: ST_TO_ADDR
// apeman = CreateHuman ;
 572: LD_ADDR_VAR 0 7
 576: PUSH
 577: CALL_OW 44
 581: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 582: LD_VAR 0 7
 586: PPUSH
 587: LD_VAR 0 4
 591: PPUSH
 592: LD_INT 0
 594: PPUSH
 595: CALL_OW 49
// l = l + 1 ;
 599: LD_ADDR_VAR 0 6
 603: PUSH
 604: LD_VAR 0 6
 608: PUSH
 609: LD_INT 1
 611: PLUS
 612: ST_TO_ADDR
// end until l = num1 ;
 613: LD_VAR 0 6
 617: PUSH
 618: LD_VAR 0 1
 622: EQUAL
 623: IFFALSE 453
// l = 0 ;
 625: LD_ADDR_VAR 0 6
 629: PUSH
 630: LD_INT 0
 632: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 633: LD_ADDR_OWVAR 35
 637: PUSH
 638: LD_INT 0
 640: PPUSH
 641: LD_INT 25
 643: PPUSH
 644: CALL_OW 12
 648: ST_TO_ADDR
// hc_class = class_tiger ;
 649: LD_ADDR_OWVAR 28
 653: PUSH
 654: LD_INT 14
 656: ST_TO_ADDR
// hc_sex = sex_male ;
 657: LD_ADDR_OWVAR 27
 661: PUSH
 662: LD_INT 1
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 3 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 3
 680: ST_TO_ADDR
// tiger = CreateHuman ;
 681: LD_ADDR_VAR 0 8
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 691: LD_VAR 0 8
 695: PPUSH
 696: LD_VAR 0 4
 700: PPUSH
 701: LD_INT 0
 703: PPUSH
 704: CALL_OW 49
// l = l + 1 ;
 708: LD_ADDR_VAR 0 6
 712: PUSH
 713: LD_VAR 0 6
 717: PUSH
 718: LD_INT 1
 720: PLUS
 721: ST_TO_ADDR
// end until l = num2 ;
 722: LD_VAR 0 6
 726: PUSH
 727: LD_VAR 0 2
 731: EQUAL
 732: IFFALSE 633
// l = 0 ;
 734: LD_ADDR_VAR 0 6
 738: PUSH
 739: LD_INT 0
 741: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 742: LD_ADDR_OWVAR 28
 746: PUSH
 747: LD_INT 18
 749: ST_TO_ADDR
// hc_gallery = sandnature ;
 750: LD_ADDR_OWVAR 33
 754: PUSH
 755: LD_STRING sandnature
 757: ST_TO_ADDR
// hc_face_number = 1 ;
 758: LD_ADDR_OWVAR 34
 762: PUSH
 763: LD_INT 1
 765: ST_TO_ADDR
// bird = CreateHuman ;
 766: LD_ADDR_VAR 0 9
 770: PUSH
 771: CALL_OW 44
 775: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 776: LD_VAR 0 9
 780: PPUSH
 781: LD_INT 0
 783: PPUSH
 784: CALL_OW 51
// l = l + 1 ;
 788: LD_ADDR_VAR 0 6
 792: PUSH
 793: LD_VAR 0 6
 797: PUSH
 798: LD_INT 1
 800: PLUS
 801: ST_TO_ADDR
// end until l = num3 ;
 802: LD_VAR 0 6
 806: PUSH
 807: LD_VAR 0 3
 811: EQUAL
 812: IFFALSE 742
// end ;
 814: LD_VAR 0 5
 818: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 819: LD_INT 0
 821: PPUSH
 822: PPUSH
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// InitHc ;
 827: CALL_OW 19
// hc_class := clas ;
 831: LD_ADDR_OWVAR 28
 835: PUSH
 836: LD_VAR 0 1
 840: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: LD_VAR 0 2
 850: PUSH
 851: LD_INT 1
 853: NEG
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: CALL_OW 12
 862: PLUS
 863: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 864: LD_ADDR_VAR 0 5
 868: PUSH
 869: LD_VAR 0 2
 873: PUSH
 874: LD_INT 1
 876: NEG
 877: PPUSH
 878: LD_INT 1
 880: PPUSH
 881: CALL_OW 12
 885: PLUS
 886: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 887: LD_ADDR_VAR 0 6
 891: PUSH
 892: LD_VAR 0 2
 896: PUSH
 897: LD_INT 1
 899: NEG
 900: PPUSH
 901: LD_INT 1
 903: PPUSH
 904: CALL_OW 12
 908: PLUS
 909: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 910: LD_ADDR_VAR 0 7
 914: PUSH
 915: LD_VAR 0 2
 919: PUSH
 920: LD_INT 1
 922: NEG
 923: PPUSH
 924: LD_INT 1
 926: PPUSH
 927: CALL_OW 12
 931: PLUS
 932: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 933: LD_VAR 0 1
 937: PUSH
 938: LD_INT 1
 940: EQUAL
 941: PUSH
 942: LD_VAR 0 1
 946: PUSH
 947: LD_INT 9
 949: EQUAL
 950: OR
 951: PUSH
 952: LD_VAR 0 1
 956: PUSH
 957: LD_INT 5
 959: EQUAL
 960: OR
 961: PUSH
 962: LD_VAR 0 1
 966: PUSH
 967: LD_INT 8
 969: EQUAL
 970: OR
 971: IFFALSE 996
// bonus := [ 2 , 0 , 0 , 0 ] ;
 973: LD_ADDR_VAR 0 8
 977: PUSH
 978: LD_INT 2
 980: PUSH
 981: LD_INT 0
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: ST_TO_ADDR
// if clas = 2 then
 996: LD_VAR 0 1
1000: PUSH
1001: LD_INT 2
1003: EQUAL
1004: IFFALSE 1029
// bonus := [ 0 , 2 , 0 , 0 ] ;
1006: LD_ADDR_VAR 0 8
1010: PUSH
1011: LD_INT 0
1013: PUSH
1014: LD_INT 2
1016: PUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 0
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: ST_TO_ADDR
// if clas = 3 then
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 3
1036: EQUAL
1037: IFFALSE 1062
// bonus := [ 0 , 0 , 2 , 0 ] ;
1039: LD_ADDR_VAR 0 8
1043: PUSH
1044: LD_INT 0
1046: PUSH
1047: LD_INT 0
1049: PUSH
1050: LD_INT 2
1052: PUSH
1053: LD_INT 0
1055: PUSH
1056: EMPTY
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: ST_TO_ADDR
// if clas = 4 then
1062: LD_VAR 0 1
1066: PUSH
1067: LD_INT 4
1069: EQUAL
1070: IFFALSE 1095
// bonus := [ 0 , 0 , 0 , 2 ] ;
1072: LD_ADDR_VAR 0 8
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: LD_INT 0
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: LD_INT 2
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1095: LD_VAR 0 1
1099: PUSH
1100: LD_INT 4
1102: GREATER
1103: PUSH
1104: LD_VAR 0 1
1108: PUSH
1109: LD_INT 9
1111: NONEQUAL
1112: AND
1113: PUSH
1114: LD_VAR 0 1
1118: PUSH
1119: LD_INT 5
1121: NONEQUAL
1122: AND
1123: PUSH
1124: LD_VAR 0 1
1128: PUSH
1129: LD_INT 8
1131: NONEQUAL
1132: AND
1133: IFFALSE 1158
// bonus := [ 0 , 0 , 0 , 0 ] ;
1135: LD_ADDR_VAR 0 8
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: LD_INT 0
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1158: LD_ADDR_OWVAR 30
1162: PUSH
1163: LD_INT 0
1165: PPUSH
1166: LD_INT 2
1168: PPUSH
1169: CALL_OW 12
1173: PUSH
1174: LD_INT 0
1176: PPUSH
1177: LD_INT 2
1179: PPUSH
1180: CALL_OW 12
1184: PUSH
1185: LD_INT 0
1187: PPUSH
1188: LD_INT 2
1190: PPUSH
1191: CALL_OW 12
1195: PUSH
1196: LD_INT 0
1198: PPUSH
1199: LD_INT 2
1201: PPUSH
1202: CALL_OW 12
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1213: LD_ADDR_OWVAR 31
1217: PUSH
1218: LD_VAR 0 4
1222: PUSH
1223: LD_VAR 0 8
1227: PUSH
1228: LD_INT 1
1230: ARRAY
1231: PLUS
1232: PUSH
1233: LD_VAR 0 5
1237: PUSH
1238: LD_VAR 0 8
1242: PUSH
1243: LD_INT 2
1245: ARRAY
1246: PLUS
1247: PUSH
1248: LD_VAR 0 6
1252: PUSH
1253: LD_VAR 0 8
1257: PUSH
1258: LD_INT 3
1260: ARRAY
1261: PLUS
1262: PUSH
1263: LD_VAR 0 7
1267: PUSH
1268: LD_VAR 0 8
1272: PUSH
1273: LD_INT 4
1275: ARRAY
1276: PLUS
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: ST_TO_ADDR
// if clas = 3 then
1284: LD_VAR 0 1
1288: PUSH
1289: LD_INT 3
1291: EQUAL
1292: IFFALSE 1304
// hc_sex := sex_male else
1294: LD_ADDR_OWVAR 27
1298: PUSH
1299: LD_INT 1
1301: ST_TO_ADDR
1302: GO 1320
// hc_sex := Rand ( sex_male , sex_female ) ;
1304: LD_ADDR_OWVAR 27
1308: PUSH
1309: LD_INT 1
1311: PPUSH
1312: LD_INT 2
1314: PPUSH
1315: CALL_OW 12
1319: ST_TO_ADDR
// hc_gallery :=  ;
1320: LD_ADDR_OWVAR 33
1324: PUSH
1325: LD_STRING 
1327: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1328: LD_ADDR_OWVAR 29
1332: PUSH
1333: LD_INT 8
1335: PPUSH
1336: LD_INT 12
1338: PPUSH
1339: CALL_OW 12
1343: PUSH
1344: LD_INT 8
1346: PPUSH
1347: LD_INT 12
1349: PPUSH
1350: CALL_OW 12
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: ST_TO_ADDR
// hc_name :=  ;
1359: LD_ADDR_OWVAR 26
1363: PUSH
1364: LD_STRING 
1366: ST_TO_ADDR
// result := CreateHuman ;
1367: LD_ADDR_VAR 0 3
1371: PUSH
1372: CALL_OW 44
1376: ST_TO_ADDR
// end ;
1377: LD_VAR 0 3
1381: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
// vc_chassis := chassis ;
1386: LD_ADDR_OWVAR 37
1390: PUSH
1391: LD_VAR 0 1
1395: ST_TO_ADDR
// vc_engine := engine ;
1396: LD_ADDR_OWVAR 39
1400: PUSH
1401: LD_VAR 0 2
1405: ST_TO_ADDR
// vc_weapon := weapon ;
1406: LD_ADDR_OWVAR 40
1410: PUSH
1411: LD_VAR 0 3
1415: ST_TO_ADDR
// vc_control := control_manual ;
1416: LD_ADDR_OWVAR 38
1420: PUSH
1421: LD_INT 1
1423: ST_TO_ADDR
// veh := CreateVehicle ;
1424: LD_ADDR_VAR 0 8
1428: PUSH
1429: CALL_OW 45
1433: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1434: LD_VAR 0 8
1438: PPUSH
1439: LD_VAR 0 5
1443: PPUSH
1444: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1448: LD_VAR 0 8
1452: PPUSH
1453: LD_VAR 0 4
1457: PPUSH
1458: LD_INT 0
1460: PPUSH
1461: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1465: LD_INT 3
1467: PPUSH
1468: LD_VAR 0 6
1472: PPUSH
1473: CALL 819 0 2
1477: PPUSH
1478: LD_VAR 0 8
1482: PPUSH
1483: CALL_OW 52
// end ; end_of_file
1487: LD_VAR 0 7
1491: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1492: LD_INT 0
1494: PPUSH
1495: PPUSH
1496: PPUSH
1497: PPUSH
1498: PPUSH
1499: PPUSH
// depot_rdy := false ;
1500: LD_ADDR_EXP 6
1504: PUSH
1505: LD_INT 0
1507: ST_TO_ADDR
// uc_side := 6 ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_INT 6
1515: ST_TO_ADDR
// uc_nation := 3 ;
1516: LD_ADDR_OWVAR 21
1520: PUSH
1521: LD_INT 3
1523: ST_TO_ADDR
// hc_gallery := ru ;
1524: LD_ADDR_OWVAR 33
1528: PUSH
1529: LD_STRING ru
1531: ST_TO_ADDR
// hc_face_number := 10 ;
1532: LD_ADDR_OWVAR 34
1536: PUSH
1537: LD_INT 10
1539: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1540: LD_ADDR_OWVAR 26
1544: PUSH
1545: LD_STRING Siergiej I. Popov
1547: ST_TO_ADDR
// hc_class := 1 ;
1548: LD_ADDR_OWVAR 28
1552: PUSH
1553: LD_INT 1
1555: ST_TO_ADDR
// hc_sex := sex_male ;
1556: LD_ADDR_OWVAR 27
1560: PUSH
1561: LD_INT 1
1563: ST_TO_ADDR
// popov := CreateHuman ;
1564: LD_ADDR_EXP 2
1568: PUSH
1569: CALL_OW 44
1573: ST_TO_ADDR
// hc_gallery := general ;
1574: LD_ADDR_OWVAR 33
1578: PUSH
1579: LD_STRING general
1581: ST_TO_ADDR
// hc_face_number := 1 ;
1582: LD_ADDR_OWVAR 34
1586: PUSH
1587: LD_INT 1
1589: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1590: LD_ADDR_OWVAR 26
1594: PUSH
1595: LD_STRING Mjr. D. N. Platonow
1597: ST_TO_ADDR
// platonov := CreateHuman ;
1598: LD_ADDR_EXP 4
1602: PUSH
1603: CALL_OW 44
1607: ST_TO_ADDR
// uc_side := 3 ;
1608: LD_ADDR_OWVAR 20
1612: PUSH
1613: LD_INT 3
1615: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1616: LD_INT 3
1618: PPUSH
1619: LD_INT 6
1621: PPUSH
1622: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1626: LD_ADDR_VAR 0 4
1630: PUSH
1631: LD_INT 6
1633: PUSH
1634: LD_INT 5
1636: PUSH
1637: LD_INT 4
1639: PUSH
1640: EMPTY
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: LD_EXP 1
1649: ARRAY
1650: ST_TO_ADDR
// team := [ ] ;
1651: LD_ADDR_VAR 0 5
1655: PUSH
1656: EMPTY
1657: ST_TO_ADDR
// hc_importance := 100 ;
1658: LD_ADDR_OWVAR 32
1662: PUSH
1663: LD_INT 100
1665: ST_TO_ADDR
// hc_gallery := gamma ;
1666: LD_ADDR_OWVAR 33
1670: PUSH
1671: LD_STRING gamma
1673: ST_TO_ADDR
// hc_face_number := 1 ;
1674: LD_ADDR_OWVAR 34
1678: PUSH
1679: LD_INT 1
1681: ST_TO_ADDR
// hc_class := 1 ;
1682: LD_ADDR_OWVAR 28
1686: PUSH
1687: LD_INT 1
1689: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1690: LD_ADDR_OWVAR 31
1694: PUSH
1695: LD_INT 8
1697: PUSH
1698: LD_INT 7
1700: PUSH
1701: LD_INT 6
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: LIST
1708: PUSH
1709: LD_EXP 1
1713: ARRAY
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 3
1720: PUSH
1721: LD_INT 0
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: ST_TO_ADDR
// hc_sex := sex_male ;
1730: LD_ADDR_OWVAR 27
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1738: LD_ADDR_OWVAR 26
1742: PUSH
1743: LD_STRING Mjr. Jurij Karakanov
1745: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1746: LD_ADDR_OWVAR 29
1750: PUSH
1751: LD_INT 10
1753: PUSH
1754: LD_INT 11
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: ST_TO_ADDR
// commander := CreateHuman ;
1761: LD_ADDR_EXP 3
1765: PUSH
1766: CALL_OW 44
1770: ST_TO_ADDR
// team := team ^ commander ;
1771: LD_ADDR_VAR 0 5
1775: PUSH
1776: LD_VAR 0 5
1780: PUSH
1781: LD_EXP 3
1785: ADD
1786: ST_TO_ADDR
// hc_importance := 0 ;
1787: LD_ADDR_OWVAR 32
1791: PUSH
1792: LD_INT 0
1794: ST_TO_ADDR
// hc_name :=  ;
1795: LD_ADDR_OWVAR 26
1799: PUSH
1800: LD_STRING 
1802: ST_TO_ADDR
// hc_gallery :=  ;
1803: LD_ADDR_OWVAR 33
1807: PUSH
1808: LD_STRING 
1810: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1811: LD_ADDR_OWVAR 29
1815: PUSH
1816: LD_INT 12
1818: PUSH
1819: LD_INT 10
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: ST_TO_ADDR
// hc_sex := sex_male ;
1826: LD_ADDR_OWVAR 27
1830: PUSH
1831: LD_INT 1
1833: ST_TO_ADDR
// Kapral := CreateHuman ;
1834: LD_ADDR_EXP 5
1838: PUSH
1839: CALL_OW 44
1843: ST_TO_ADDR
// for i = 3 downto dif do
1844: LD_ADDR_VAR 0 2
1848: PUSH
1849: DOUBLE
1850: LD_INT 3
1852: INC
1853: ST_TO_ADDR
1854: LD_EXP 1
1858: PUSH
1859: FOR_DOWNTO
1860: IFFALSE 1966
// begin vc_chassis := ru_medium_tracked ;
1862: LD_ADDR_OWVAR 37
1866: PUSH
1867: LD_INT 22
1869: ST_TO_ADDR
// vc_engine := engine_combustion ;
1870: LD_ADDR_OWVAR 39
1874: PUSH
1875: LD_INT 1
1877: ST_TO_ADDR
// vc_control := control_manual ;
1878: LD_ADDR_OWVAR 38
1882: PUSH
1883: LD_INT 1
1885: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1886: LD_ADDR_OWVAR 40
1890: PUSH
1891: LD_INT 43
1893: PUSH
1894: LD_INT 44
1896: PUSH
1897: LD_INT 44
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: PUSH
1905: LD_VAR 0 2
1909: ARRAY
1910: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1911: LD_ADDR_OWVAR 41
1915: PUSH
1916: LD_INT 55
1918: PPUSH
1919: LD_INT 77
1921: PPUSH
1922: CALL_OW 12
1926: ST_TO_ADDR
// un := CreateVehicle ;
1927: LD_ADDR_VAR 0 3
1931: PUSH
1932: CALL_OW 45
1936: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: LD_INT 5
1944: PPUSH
1945: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1949: LD_VAR 0 3
1953: PPUSH
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 0
1959: PPUSH
1960: CALL_OW 49
// end ;
1964: GO 1859
1966: POP
1967: POP
// vc_weapon := ru_heavy_machine_gun ;
1968: LD_ADDR_OWVAR 40
1972: PUSH
1973: LD_INT 42
1975: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1976: LD_ADDR_OWVAR 41
1980: PUSH
1981: LD_INT 55
1983: PPUSH
1984: LD_INT 77
1986: PPUSH
1987: CALL_OW 12
1991: ST_TO_ADDR
// un := CreateVehicle ;
1992: LD_ADDR_VAR 0 3
1996: PUSH
1997: CALL_OW 45
2001: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2002: LD_VAR 0 3
2006: PPUSH
2007: LD_INT 5
2009: PPUSH
2010: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
2014: LD_VAR 0 3
2018: PPUSH
2019: LD_INT 1
2021: PPUSH
2022: LD_INT 0
2024: PPUSH
2025: CALL_OW 49
// for p = 1 to 4 do
2029: LD_ADDR_VAR 0 6
2033: PUSH
2034: DOUBLE
2035: LD_INT 1
2037: DEC
2038: ST_TO_ADDR
2039: LD_INT 4
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2110
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
2045: LD_ADDR_VAR 0 2
2049: PUSH
2050: DOUBLE
2051: LD_INT 1
2053: DEC
2054: ST_TO_ADDR
2055: LD_INT 5
2057: PUSH
2058: LD_INT 4
2060: PUSH
2061: LD_INT 3
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: PUSH
2069: LD_EXP 1
2073: ARRAY
2074: PUSH
2075: FOR_TO
2076: IFFALSE 2106
// team := team ^ CreateHumanWithClass ( p , skill ) ;
2078: LD_ADDR_VAR 0 5
2082: PUSH
2083: LD_VAR 0 5
2087: PUSH
2088: LD_VAR 0 6
2092: PPUSH
2093: LD_VAR 0 4
2097: PPUSH
2098: CALL 819 0 2
2102: ADD
2103: ST_TO_ADDR
2104: GO 2075
2106: POP
2107: POP
2108: GO 2042
2110: POP
2111: POP
// for i = 1 to team do
2112: LD_ADDR_VAR 0 2
2116: PUSH
2117: DOUBLE
2118: LD_INT 1
2120: DEC
2121: ST_TO_ADDR
2122: LD_VAR 0 5
2126: PUSH
2127: FOR_TO
2128: IFFALSE 2246
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2130: LD_VAR 0 5
2134: PUSH
2135: LD_VAR 0 2
2139: ARRAY
2140: PPUSH
2141: CALL_OW 257
2145: PUSH
2146: LD_INT 3
2148: EQUAL
2149: PUSH
2150: LD_INT 22
2152: PUSH
2153: LD_INT 3
2155: PUSH
2156: EMPTY
2157: LIST
2158: LIST
2159: PUSH
2160: LD_INT 58
2162: PUSH
2163: EMPTY
2164: LIST
2165: PUSH
2166: EMPTY
2167: LIST
2168: LIST
2169: PPUSH
2170: CALL_OW 69
2174: AND
2175: IFFALSE 2223
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2177: LD_VAR 0 5
2181: PUSH
2182: LD_VAR 0 2
2186: ARRAY
2187: PPUSH
2188: LD_INT 22
2190: PUSH
2191: LD_INT 3
2193: PUSH
2194: EMPTY
2195: LIST
2196: LIST
2197: PUSH
2198: LD_INT 58
2200: PUSH
2201: EMPTY
2202: LIST
2203: PUSH
2204: EMPTY
2205: LIST
2206: LIST
2207: PPUSH
2208: CALL_OW 69
2212: PUSH
2213: LD_INT 1
2215: ARRAY
2216: PPUSH
2217: CALL_OW 52
2221: GO 2244
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2223: LD_VAR 0 5
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 49
2244: GO 2127
2246: POP
2247: POP
// end ;
2248: LD_VAR 0 1
2252: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2253: LD_EXP 6
2257: IFFALSE 2627
2259: GO 2261
2261: DISABLE
2262: LD_INT 0
2264: PPUSH
2265: PPUSH
2266: PPUSH
2267: PPUSH
// begin Wait ( 0 0$07 ) ;
2268: LD_INT 245
2270: PPUSH
2271: CALL_OW 67
// l := 0 ;
2275: LD_ADDR_VAR 0 3
2279: PUSH
2280: LD_INT 0
2282: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2283: LD_ADDR_OWVAR 20
2287: PUSH
2288: LD_INT 6
2290: ST_TO_ADDR
// uc_nation := 3 ;
2291: LD_ADDR_OWVAR 21
2295: PUSH
2296: LD_INT 3
2298: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2299: LD_INT 22
2301: PPUSH
2302: LD_INT 1
2304: PPUSH
2305: LD_INT 51
2307: PPUSH
2308: LD_INT 5
2310: PPUSH
2311: LD_INT 5
2313: PPUSH
2314: LD_INT 3
2316: PPUSH
2317: LD_INT 6
2319: PPUSH
2320: CALL_OW 12
2324: PPUSH
2325: CALL 1382 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2329: LD_ADDR_VAR 0 2
2333: PUSH
2334: LD_INT 22
2336: PUSH
2337: LD_INT 6
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PUSH
2344: LD_INT 34
2346: PUSH
2347: LD_INT 51
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: PUSH
2354: EMPTY
2355: LIST
2356: LIST
2357: PPUSH
2358: CALL_OW 69
2362: PUSH
2363: LD_INT 1
2365: ARRAY
2366: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2367: LD_VAR 0 2
2371: PPUSH
2372: LD_INT 1
2374: PPUSH
2375: LD_INT 100
2377: PPUSH
2378: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2382: LD_VAR 0 2
2386: PPUSH
2387: LD_EXP 7
2391: PUSH
2392: LD_INT 2
2394: PLUS
2395: PPUSH
2396: LD_EXP 8
2400: PPUSH
2401: CALL_OW 111
// AddComUnload ( un ) ;
2405: LD_VAR 0 2
2409: PPUSH
2410: CALL_OW 219
// if ( l = 0 ) then
2414: LD_VAR 0 3
2418: PUSH
2419: LD_INT 0
2421: EQUAL
2422: IFFALSE 2458
// begin Wait ( 0 0$03 ) ;
2424: LD_INT 105
2426: PPUSH
2427: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2431: LD_ADDR_VAR 0 4
2435: PUSH
2436: LD_VAR 0 2
2440: PPUSH
2441: CALL_OW 311
2445: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2446: LD_VAR 0 4
2450: PPUSH
2451: LD_STRING Dtran
2453: PPUSH
2454: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2458: LD_VAR 0 3
2462: PUSH
2463: LD_INT 7
2465: PUSH
2466: LD_INT 6
2468: PUSH
2469: LD_INT 5
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: LIST
2476: PUSH
2477: LD_EXP 1
2481: ARRAY
2482: PUSH
2483: LD_INT 1
2485: MINUS
2486: EQUAL
2487: IFFALSE 2523
// begin Wait ( 0 0$03 ) ;
2489: LD_INT 105
2491: PPUSH
2492: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2496: LD_ADDR_VAR 0 4
2500: PUSH
2501: LD_VAR 0 2
2505: PPUSH
2506: CALL_OW 311
2510: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2511: LD_VAR 0 4
2515: PPUSH
2516: LD_STRING Dtrans
2518: PPUSH
2519: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2523: LD_VAR 0 2
2527: PPUSH
2528: LD_INT 6
2530: PPUSH
2531: CALL_OW 308
2535: NOT
2536: IFFALSE 2562
// begin Wait ( 0 0$01 ) ;
2538: LD_INT 35
2540: PPUSH
2541: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2545: LD_VAR 0 2
2549: PPUSH
2550: LD_INT 69
2552: PPUSH
2553: LD_INT 97
2555: PPUSH
2556: CALL_OW 171
// end ;
2560: GO 2523
// RemoveUnit ( un ) ;
2562: LD_VAR 0 2
2566: PPUSH
2567: CALL_OW 64
// l = l + 1 ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 3
2580: PUSH
2581: LD_INT 1
2583: PLUS
2584: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2585: LD_INT 1155
2587: PPUSH
2588: LD_INT 5355
2590: PPUSH
2591: CALL_OW 12
2595: PPUSH
2596: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2600: LD_VAR 0 3
2604: PUSH
2605: LD_INT 7
2607: PUSH
2608: LD_INT 6
2610: PUSH
2611: LD_INT 5
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: LIST
2618: PUSH
2619: LD_EXP 1
2623: ARRAY
2624: EQUAL
2625: IFFALSE 2283
// end ; end_of_file
2627: PPOPN 4
2629: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2630: LD_VAR 0 1
2634: PUSH
2635: LD_INT 44
2637: EQUAL
2638: PUSH
2639: LD_EXP 20
2643: PUSH
2644: LD_INT 0
2646: EQUAL
2647: AND
2648: IFFALSE 2794
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2650: LD_INT 22
2652: PUSH
2653: LD_INT 3
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: PUSH
2660: LD_INT 25
2662: PUSH
2663: LD_INT 4
2665: PUSH
2666: EMPTY
2667: LIST
2668: LIST
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PPUSH
2674: CALL_OW 69
2678: PUSH
2679: LD_INT 0
2681: GREATER
2682: IFFALSE 2794
// begin event_rocket := true ;
2684: LD_ADDR_EXP 20
2688: PUSH
2689: LD_INT 1
2691: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2692: LD_INT 22
2694: PUSH
2695: LD_INT 3
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: PUSH
2702: LD_INT 25
2704: PUSH
2705: LD_INT 4
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: LD_INT 26
2714: PUSH
2715: LD_INT 1
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: EMPTY
2728: LIST
2729: PPUSH
2730: CALL_OW 69
2734: PUSH
2735: LD_INT 0
2737: GREATER
2738: IFFALSE 2794
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2740: LD_INT 22
2742: PUSH
2743: LD_INT 3
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: PUSH
2750: LD_INT 25
2752: PUSH
2753: LD_INT 4
2755: PUSH
2756: EMPTY
2757: LIST
2758: LIST
2759: PUSH
2760: LD_INT 26
2762: PUSH
2763: LD_INT 1
2765: PUSH
2766: EMPTY
2767: LIST
2768: LIST
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: PPUSH
2778: CALL_OW 69
2782: PUSH
2783: LD_INT 1
2785: ARRAY
2786: PPUSH
2787: LD_STRING Dsci2
2789: PPUSH
2790: CALL_OW 88
// end ; end ;
2794: PPOPN 2
2796: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2797: LD_VAR 0 1
2801: PPUSH
2802: CALL_OW 255
2806: PUSH
2807: LD_INT 3
2809: EQUAL
2810: PUSH
2811: LD_VAR 0 1
2815: PPUSH
2816: CALL_OW 263
2820: PUSH
2821: LD_INT 3
2823: EQUAL
2824: AND
2825: IFFALSE 2835
// comp_tested := true ;
2827: LD_ADDR_EXP 22
2831: PUSH
2832: LD_INT 1
2834: ST_TO_ADDR
// end ;
2835: PPOPN 2
2837: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2838: LD_VAR 0 1
2842: PUSH
2843: LD_INT 22
2845: PUSH
2846: LD_INT 1
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PUSH
2853: LD_INT 21
2855: PUSH
2856: LD_INT 3
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: PPUSH
2867: CALL_OW 69
2871: IN
2872: IFFALSE 2950
// if attacked = false and sikorski_ar = false then
2874: LD_EXP 15
2878: PUSH
2879: LD_INT 0
2881: EQUAL
2882: PUSH
2883: LD_EXP 12
2887: PUSH
2888: LD_INT 0
2890: EQUAL
2891: AND
2892: IFFALSE 2950
// begin attacked := true ;
2894: LD_ADDR_EXP 15
2898: PUSH
2899: LD_INT 1
2901: ST_TO_ADDR
// if IsInUnit ( donald ) then
2902: LD_EXP 13
2906: PPUSH
2907: CALL_OW 310
2911: IFFALSE 2927
// SayRadio ( donald , DGammaF ) else
2913: LD_EXP 13
2917: PPUSH
2918: LD_STRING DGammaF
2920: PPUSH
2921: CALL_OW 94
2925: GO 2950
// if IsInUnit ( van ) then
2927: LD_EXP 14
2931: PPUSH
2932: CALL_OW 310
2936: IFFALSE 2950
// SayRadio ( van , DGammaM ) ;
2938: LD_EXP 14
2942: PPUSH
2943: LD_STRING DGammaM
2945: PPUSH
2946: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2950: LD_VAR 0 1
2954: PUSH
2955: LD_INT 33
2957: PUSH
2958: LD_INT 2
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PPUSH
2965: CALL_OW 69
2969: IN
2970: IFFALSE 2981
// ComUnlink ( un ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: CALL_OW 136
// end ;
2981: PPOPN 1
2983: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2984: LD_VAR 0 2
2988: PPUSH
2989: CALL_OW 258
2993: PUSH
2994: LD_INT 1
2996: EQUAL
2997: IFFALSE 3011
// Say ( sci , Dsci3 ) ;
2999: LD_VAR 0 2
3003: PPUSH
3004: LD_STRING Dsci3
3006: PPUSH
3007: CALL_OW 88
// end ;
3011: PPOPN 2
3013: END
// on BuildingComplete ( b ) do var i ;
3014: LD_INT 0
3016: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
3017: LD_VAR 0 1
3021: PPUSH
3022: CALL_OW 266
3026: PUSH
3027: LD_INT 0
3029: EQUAL
3030: PUSH
3031: LD_VAR 0 1
3035: PPUSH
3036: CALL_OW 255
3040: PUSH
3041: LD_INT 3
3043: EQUAL
3044: AND
3045: PUSH
3046: LD_EXP 6
3050: PUSH
3051: LD_INT 0
3053: EQUAL
3054: AND
3055: IFFALSE 3119
// begin SetBName ( b , kalinin ) ;
3057: LD_VAR 0 1
3061: PPUSH
3062: LD_STRING kalinin
3064: PPUSH
3065: CALL_OW 500
// dep_x := GetX ( b ) ;
3069: LD_ADDR_EXP 7
3073: PUSH
3074: LD_VAR 0 1
3078: PPUSH
3079: CALL_OW 250
3083: ST_TO_ADDR
// dep_y := GetY ( b ) ;
3084: LD_ADDR_EXP 8
3088: PUSH
3089: LD_VAR 0 1
3093: PPUSH
3094: CALL_OW 251
3098: ST_TO_ADDR
// depot_rdy := true ;
3099: LD_ADDR_EXP 6
3103: PUSH
3104: LD_INT 1
3106: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3107: LD_EXP 2
3111: PPUSH
3112: LD_STRING Dpop3
3114: PPUSH
3115: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3119: LD_VAR 0 1
3123: PPUSH
3124: CALL_OW 266
3128: PUSH
3129: LD_INT 6
3131: EQUAL
3132: PUSH
3133: LD_VAR 0 1
3137: PPUSH
3138: CALL_OW 255
3142: PUSH
3143: LD_INT 3
3145: EQUAL
3146: AND
3147: PUSH
3148: LD_EXP 21
3152: PUSH
3153: LD_INT 0
3155: EQUAL
3156: AND
3157: IFFALSE 3252
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3159: LD_INT 22
3161: PUSH
3162: LD_INT 3
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: PUSH
3188: LD_INT 0
3190: GREATER
3191: IFFALSE 3252
// begin event_comp := true ;
3193: LD_ADDR_EXP 21
3197: PUSH
3198: LD_INT 1
3200: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3201: LD_INT 22
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: PUSH
3211: LD_INT 25
3213: PUSH
3214: LD_INT 4
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PUSH
3221: LD_INT 26
3223: PUSH
3224: LD_INT 1
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: PPUSH
3236: CALL_OW 69
3240: PUSH
3241: LD_INT 1
3243: ARRAY
3244: PPUSH
3245: LD_STRING Dsci1
3247: PPUSH
3248: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3252: LD_VAR 0 1
3256: PPUSH
3257: CALL_OW 266
3261: PUSH
3262: LD_INT 32
3264: EQUAL
3265: PUSH
3266: LD_VAR 0 1
3270: PPUSH
3271: CALL_OW 255
3275: PUSH
3276: LD_INT 1
3278: EQUAL
3279: AND
3280: IFFALSE 3345
// begin RaiseSailEvent ( 6 ) ;
3282: LD_INT 6
3284: PPUSH
3285: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3289: LD_VAR 0 1
3293: PPUSH
3294: LD_EXP 18
3298: PUSH
3299: LD_INT 4
3301: ARRAY
3302: PPUSH
3303: CALL_OW 208
// for i = 1 to 4 do
3307: LD_ADDR_VAR 0 2
3311: PUSH
3312: DOUBLE
3313: LD_INT 1
3315: DEC
3316: ST_TO_ADDR
3317: LD_INT 4
3319: PUSH
3320: FOR_TO
3321: IFFALSE 3343
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3323: LD_ADDR_EXP 18
3327: PUSH
3328: LD_EXP 18
3332: PPUSH
3333: LD_INT 1
3335: PPUSH
3336: CALL_OW 3
3340: ST_TO_ADDR
3341: GO 3320
3343: POP
3344: POP
// end ; end ;
3345: PPOPN 2
3347: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3348: LD_VAR 0 1
3352: PUSH
3353: LD_EXP 17
3357: IN
3358: IFFALSE 3376
// Patrol := Patrol diff un ;
3360: LD_ADDR_EXP 17
3364: PUSH
3365: LD_EXP 17
3369: PUSH
3370: LD_VAR 0 1
3374: DIFF
3375: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3376: LD_VAR 0 1
3380: PUSH
3381: LD_INT 22
3383: PUSH
3384: LD_INT 1
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PUSH
3391: LD_INT 30
3393: PUSH
3394: LD_INT 32
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PPUSH
3405: CALL_OW 69
3409: IN
3410: IFFALSE 3496
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3412: LD_ADDR_EXP 18
3416: PUSH
3417: LD_EXP 18
3421: PUSH
3422: LD_VAR 0 1
3426: PPUSH
3427: CALL_OW 250
3431: ADD
3432: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3433: LD_ADDR_EXP 18
3437: PUSH
3438: LD_EXP 18
3442: PUSH
3443: LD_VAR 0 1
3447: PPUSH
3448: CALL_OW 251
3452: ADD
3453: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3454: LD_ADDR_EXP 18
3458: PUSH
3459: LD_EXP 18
3463: PUSH
3464: LD_VAR 0 1
3468: PPUSH
3469: CALL_OW 254
3473: ADD
3474: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3475: LD_ADDR_EXP 18
3479: PUSH
3480: LD_EXP 18
3484: PUSH
3485: LD_VAR 0 1
3489: PPUSH
3490: CALL_OW 269
3494: ADD
3495: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3496: LD_VAR 0 1
3500: PUSH
3501: LD_INT 33
3503: PUSH
3504: LD_INT 2
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 3
3513: PUSH
3514: LD_INT 34
3516: PUSH
3517: LD_INT 13
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: PUSH
3524: EMPTY
3525: LIST
3526: LIST
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: PPUSH
3532: CALL_OW 69
3536: IN
3537: IFFALSE 3553
// new_veh := new_veh + 1 ;
3539: LD_ADDR_EXP 19
3543: PUSH
3544: LD_EXP 19
3548: PUSH
3549: LD_INT 1
3551: PLUS
3552: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3553: LD_VAR 0 1
3557: PUSH
3558: LD_INT 34
3560: PUSH
3561: LD_INT 13
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: PPUSH
3568: CALL_OW 69
3572: IN
3573: IFFALSE 3594
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3575: LD_INT 26
3577: PPUSH
3578: LD_INT 3
3580: PPUSH
3581: LD_INT 2
3583: PPUSH
3584: LD_INT 2
3586: PPUSH
3587: LD_INT 13
3589: PPUSH
3590: CALL_OW 185
// if un = am_dep then
3594: LD_VAR 0 1
3598: PUSH
3599: LD_INT 25
3601: EQUAL
3602: IFFALSE 3770
// begin SayRadio ( Platonov , DPlat ) ;
3604: LD_EXP 4
3608: PPUSH
3609: LD_STRING DPlat
3611: PPUSH
3612: CALL_OW 94
// if timer <= 30 30$00 then
3616: LD_EXP 24
3620: PUSH
3621: LD_INT 63000
3623: LESSEQUAL
3624: IFFALSE 3638
// AddMedal ( gamma_med3 , 1 ) else
3626: LD_STRING gamma_med3
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: CALL_OW 101
3636: GO 3688
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3638: LD_EXP 24
3642: PUSH
3643: LD_INT 105000
3645: PUSH
3646: LD_INT 88200
3648: PUSH
3649: LD_INT 73500
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: LIST
3656: PUSH
3657: LD_EXP 1
3661: ARRAY
3662: LESSEQUAL
3663: IFFALSE 3677
// AddMedal ( gamma_med3 , 2 ) else
3665: LD_STRING gamma_med3
3667: PPUSH
3668: LD_INT 2
3670: PPUSH
3671: CALL_OW 101
3675: GO 3688
// AddMedal ( gamma_med3 , - 1 ) ;
3677: LD_STRING gamma_med3
3679: PPUSH
3680: LD_INT 1
3682: NEG
3683: PPUSH
3684: CALL_OW 101
// if not comp_tested then
3688: LD_EXP 22
3692: NOT
3693: IFFALSE 3708
// AddMedal ( gamma_med2 , - 1 ) else
3695: LD_STRING gamma_med2
3697: PPUSH
3698: LD_INT 1
3700: NEG
3701: PPUSH
3702: CALL_OW 101
3706: GO 3718
// AddMedal ( gamma_med2 , 1 ) ;
3708: LD_STRING gamma_med2
3710: PPUSH
3711: LD_INT 1
3713: PPUSH
3714: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3718: LD_EXP 9
3722: PPUSH
3723: CALL_OW 301
3727: PUSH
3728: LD_EXP 23
3732: NOT
3733: AND
3734: IFFALSE 3748
// AddMedal ( gamma_med1 , 1 ) else
3736: LD_STRING gamma_med1
3738: PPUSH
3739: LD_INT 1
3741: PPUSH
3742: CALL_OW 101
3746: GO 3759
// AddMedal ( gamma_med1 , - 1 ) ;
3748: LD_STRING gamma_med1
3750: PPUSH
3751: LD_INT 1
3753: NEG
3754: PPUSH
3755: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3759: LD_STRING GAMMA_MEDALS
3761: PPUSH
3762: CALL_OW 102
// YouWin ;
3766: CALL_OW 103
// end ; if un = commander then
3770: LD_VAR 0 1
3774: PUSH
3775: LD_EXP 3
3779: EQUAL
3780: IFFALSE 3789
// YouLost ( comml ) ;
3782: LD_STRING comml
3784: PPUSH
3785: CALL_OW 104
// if un = sikorski then
3789: LD_VAR 0 1
3793: PUSH
3794: LD_EXP 9
3798: EQUAL
3799: IFFALSE 3811
// AddMedal ( gamma_med1 , 1 ) ;
3801: LD_STRING gamma_med1
3803: PPUSH
3804: LD_INT 1
3806: PPUSH
3807: CALL_OW 101
// end ;
3811: PPOPN 1
3813: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3814: LD_INT 0
3816: PPUSH
3817: PPUSH
3818: PPUSH
3819: PPUSH
3820: PPUSH
3821: PPUSH
3822: PPUSH
3823: PPUSH
3824: PPUSH
// begin if event = 1 then
3825: LD_VAR 0 1
3829: PUSH
3830: LD_INT 1
3832: EQUAL
3833: IFFALSE 4130
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3835: LD_ADDR_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 1
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 3
3862: PUSH
3863: LD_INT 24
3865: PUSH
3866: LD_INT 1000
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: LIST
3881: PPUSH
3882: CALL_OW 69
3886: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3887: LD_ADDR_VAR 0 8
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 1
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 25
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: LD_INT 24
3914: PUSH
3915: LD_INT 1000
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: LIST
3926: PUSH
3927: EMPTY
3928: LIST
3929: PPUSH
3930: CALL_OW 69
3934: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3935: LD_ADDR_VAR 0 9
3939: PUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 1
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 34
3952: PUSH
3953: LD_INT 13
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// if engs > 0 then
3969: LD_VAR 0 8
3973: PUSH
3974: LD_INT 0
3976: GREATER
3977: IFFALSE 4082
// for i = 1 to engs do
3979: LD_ADDR_VAR 0 2
3983: PUSH
3984: DOUBLE
3985: LD_INT 1
3987: DEC
3988: ST_TO_ADDR
3989: LD_VAR 0 8
3993: PUSH
3994: FOR_TO
3995: IFFALSE 4080
// begin if IsInUnit ( engs [ i ] ) then
3997: LD_VAR 0 8
4001: PUSH
4002: LD_VAR 0 2
4006: ARRAY
4007: PPUSH
4008: CALL_OW 310
4012: IFFALSE 4029
// ComExitBuilding ( engs [ i ] ) ;
4014: LD_VAR 0 8
4018: PUSH
4019: LD_VAR 0 2
4023: ARRAY
4024: PPUSH
4025: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
4029: LD_INT 7
4031: PPUSH
4032: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
4036: LD_VAR 0 8
4040: PUSH
4041: LD_VAR 0 2
4045: ARRAY
4046: PPUSH
4047: CALL_OW 314
4051: NOT
4052: IFFALSE 4078
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
4054: LD_VAR 0 8
4058: PUSH
4059: LD_VAR 0 2
4063: ARRAY
4064: PPUSH
4065: LD_VAR 0 4
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: PPUSH
4074: CALL_OW 130
// end ;
4078: GO 3994
4080: POP
4081: POP
// if crane > 0 then
4082: LD_VAR 0 9
4086: PUSH
4087: LD_INT 0
4089: GREATER
4090: IFFALSE 4130
// if not HasTask ( crane [ 1 ] ) then
4092: LD_VAR 0 9
4096: PUSH
4097: LD_INT 1
4099: ARRAY
4100: PPUSH
4101: CALL_OW 314
4105: NOT
4106: IFFALSE 4130
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4108: LD_VAR 0 9
4112: PUSH
4113: LD_INT 1
4115: ARRAY
4116: PPUSH
4117: LD_VAR 0 4
4121: PUSH
4122: LD_INT 1
4124: ARRAY
4125: PPUSH
4126: CALL_OW 130
// end ; if event = 2 then
4130: LD_VAR 0 1
4134: PUSH
4135: LD_INT 2
4137: EQUAL
4138: IFFALSE 4260
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4140: LD_ADDR_VAR 0 8
4144: PUSH
4145: LD_INT 22
4147: PUSH
4148: LD_INT 1
4150: PUSH
4151: EMPTY
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 25
4157: PUSH
4158: LD_INT 2
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PUSH
4165: EMPTY
4166: LIST
4167: LIST
4168: PPUSH
4169: CALL_OW 69
4173: ST_TO_ADDR
// if engs > 0 then
4174: LD_VAR 0 8
4178: PUSH
4179: LD_INT 0
4181: GREATER
4182: IFFALSE 4260
// for i = 1 to engs do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_VAR 0 8
4198: PUSH
4199: FOR_TO
4200: IFFALSE 4258
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4202: LD_VAR 0 8
4206: PUSH
4207: LD_VAR 0 2
4211: ARRAY
4212: PPUSH
4213: CALL_OW 314
4217: NOT
4218: PUSH
4219: LD_VAR 0 8
4223: PUSH
4224: LD_VAR 0 2
4228: ARRAY
4229: PPUSH
4230: CALL_OW 310
4234: NOT
4235: AND
4236: IFFALSE 4256
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4238: LD_VAR 0 8
4242: PUSH
4243: LD_VAR 0 2
4247: ARRAY
4248: PPUSH
4249: LD_INT 25
4251: PPUSH
4252: CALL_OW 120
4256: GO 4199
4258: POP
4259: POP
// end ; if event = 3 then
4260: LD_VAR 0 1
4264: PUSH
4265: LD_INT 3
4267: EQUAL
4268: IFFALSE 4632
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4270: LD_ADDR_VAR 0 4
4274: PUSH
4275: LD_INT 22
4277: PUSH
4278: LD_INT 1
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: PUSH
4285: LD_INT 21
4287: PUSH
4288: LD_INT 1
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 3
4297: PUSH
4298: LD_INT 25
4300: PUSH
4301: LD_INT 4
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 3
4314: PUSH
4315: LD_INT 24
4317: PUSH
4318: LD_INT 800
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: PPUSH
4338: CALL_OW 69
4342: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4343: LD_ADDR_VAR 0 5
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_INT 1
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PUSH
4358: LD_INT 25
4360: PUSH
4361: LD_INT 4
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: PUSH
4368: EMPTY
4369: LIST
4370: LIST
4371: PPUSH
4372: CALL_OW 69
4376: ST_TO_ADDR
// if filter > 0 then
4377: LD_VAR 0 4
4381: PUSH
4382: LD_INT 0
4384: GREATER
4385: IFFALSE 4574
// begin for i = 1 to doc do
4387: LD_ADDR_VAR 0 2
4391: PUSH
4392: DOUBLE
4393: LD_INT 1
4395: DEC
4396: ST_TO_ADDR
4397: LD_VAR 0 5
4401: PUSH
4402: FOR_TO
4403: IFFALSE 4503
// begin if IsInUnit ( doc [ i ] ) then
4405: LD_VAR 0 5
4409: PUSH
4410: LD_VAR 0 2
4414: ARRAY
4415: PPUSH
4416: CALL_OW 310
4420: IFFALSE 4437
// ComExitBuilding ( doc [ i ] ) ;
4422: LD_VAR 0 5
4426: PUSH
4427: LD_VAR 0 2
4431: ARRAY
4432: PPUSH
4433: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4437: LD_VAR 0 4
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: PPUSH
4446: LD_INT 46
4448: PPUSH
4449: CALL_OW 296
4453: PUSH
4454: LD_INT 10
4456: LESS
4457: PUSH
4458: LD_VAR 0 5
4462: PUSH
4463: LD_VAR 0 2
4467: ARRAY
4468: PPUSH
4469: CALL_OW 314
4473: NOT
4474: AND
4475: IFFALSE 4501
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4477: LD_VAR 0 5
4481: PUSH
4482: LD_VAR 0 2
4486: ARRAY
4487: PPUSH
4488: LD_VAR 0 4
4492: PUSH
4493: LD_INT 1
4495: ARRAY
4496: PPUSH
4497: CALL_OW 128
// end ;
4501: GO 4402
4503: POP
4504: POP
// for i = 1 to filter do
4505: LD_ADDR_VAR 0 2
4509: PUSH
4510: DOUBLE
4511: LD_INT 1
4513: DEC
4514: ST_TO_ADDR
4515: LD_VAR 0 4
4519: PUSH
4520: FOR_TO
4521: IFFALSE 4570
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4523: LD_VAR 0 4
4527: PUSH
4528: LD_VAR 0 2
4532: ARRAY
4533: PPUSH
4534: LD_INT 46
4536: PPUSH
4537: CALL_OW 296
4541: PUSH
4542: LD_INT 10
4544: GREATER
4545: IFFALSE 4568
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4547: LD_VAR 0 4
4551: PUSH
4552: LD_VAR 0 2
4556: ARRAY
4557: PPUSH
4558: LD_INT 47
4560: PPUSH
4561: LD_INT 12
4563: PPUSH
4564: CALL_OW 111
4568: GO 4520
4570: POP
4571: POP
// end else
4572: GO 4632
// for i = 1 to doc do
4574: LD_ADDR_VAR 0 2
4578: PUSH
4579: DOUBLE
4580: LD_INT 1
4582: DEC
4583: ST_TO_ADDR
4584: LD_VAR 0 5
4588: PUSH
4589: FOR_TO
4590: IFFALSE 4630
// if not IsInUnit ( doc [ i ] ) then
4592: LD_VAR 0 5
4596: PUSH
4597: LD_VAR 0 2
4601: ARRAY
4602: PPUSH
4603: CALL_OW 310
4607: NOT
4608: IFFALSE 4628
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4610: LD_VAR 0 5
4614: PUSH
4615: LD_VAR 0 2
4619: ARRAY
4620: PPUSH
4621: LD_INT 46
4623: PPUSH
4624: CALL_OW 120
4628: GO 4589
4630: POP
4631: POP
// end ; if event = 4 then
4632: LD_VAR 0 1
4636: PUSH
4637: LD_INT 4
4639: EQUAL
4640: IFFALSE 4891
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4642: LD_ADDR_VAR 0 6
4646: PUSH
4647: LD_INT 22
4649: PUSH
4650: LD_INT 1
4652: PUSH
4653: EMPTY
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 30
4659: PUSH
4660: LD_INT 5
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PPUSH
4671: CALL_OW 69
4675: ST_TO_ADDR
// for i = 1 to bac do
4676: LD_ADDR_VAR 0 2
4680: PUSH
4681: DOUBLE
4682: LD_INT 1
4684: DEC
4685: ST_TO_ADDR
4686: LD_VAR 0 6
4690: PUSH
4691: FOR_TO
4692: IFFALSE 4733
// if UnitsInside ( bac [ i ] ) < 6 then
4694: LD_VAR 0 6
4698: PUSH
4699: LD_VAR 0 2
4703: ARRAY
4704: PPUSH
4705: CALL_OW 313
4709: PUSH
4710: LD_INT 6
4712: LESS
4713: IFFALSE 4731
// place := bac [ i ] ;
4715: LD_ADDR_VAR 0 7
4719: PUSH
4720: LD_VAR 0 6
4724: PUSH
4725: LD_VAR 0 2
4729: ARRAY
4730: ST_TO_ADDR
4731: GO 4691
4733: POP
4734: POP
// if place then
4735: LD_VAR 0 7
4739: IFFALSE 4891
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4741: LD_ADDR_VAR 0 4
4745: PUSH
4746: LD_INT 22
4748: PUSH
4749: LD_INT 1
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: PUSH
4756: LD_INT 2
4758: PUSH
4759: LD_INT 25
4761: PUSH
4762: LD_INT 1
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: PUSH
4769: LD_INT 25
4771: PUSH
4772: LD_INT 5
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 24
4786: PUSH
4787: LD_INT 1000
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: PPUSH
4802: CALL_OW 69
4806: PUSH
4807: LD_EXP 17
4811: DIFF
4812: ST_TO_ADDR
// for i = 1 to filter do
4813: LD_ADDR_VAR 0 2
4817: PUSH
4818: DOUBLE
4819: LD_INT 1
4821: DEC
4822: ST_TO_ADDR
4823: LD_VAR 0 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4889
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4831: LD_VAR 0 4
4835: PUSH
4836: LD_VAR 0 2
4840: ARRAY
4841: PPUSH
4842: CALL_OW 310
4846: NOT
4847: PUSH
4848: LD_VAR 0 4
4852: PUSH
4853: LD_VAR 0 2
4857: ARRAY
4858: PPUSH
4859: CALL_OW 314
4863: NOT
4864: AND
4865: IFFALSE 4887
// ComEnterUnit ( filter [ i ] , place ) ;
4867: LD_VAR 0 4
4871: PUSH
4872: LD_VAR 0 2
4876: ARRAY
4877: PPUSH
4878: LD_VAR 0 7
4882: PPUSH
4883: CALL_OW 120
4887: GO 4828
4889: POP
4890: POP
// end ; end ; if event = 5 then
4891: LD_VAR 0 1
4895: PUSH
4896: LD_INT 5
4898: EQUAL
4899: IFFALSE 5053
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4901: LD_INT 12
4903: PPUSH
4904: LD_INT 81
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: PPUSH
4914: CALL_OW 70
4918: PUSH
4919: LD_INT 0
4921: EQUAL
4922: IFFALSE 5053
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4924: LD_ADDR_VAR 0 8
4928: PUSH
4929: LD_INT 22
4931: PUSH
4932: LD_INT 1
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PUSH
4939: LD_INT 25
4941: PUSH
4942: LD_INT 2
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 69
4957: ST_TO_ADDR
// if engs > 0 then
4958: LD_VAR 0 8
4962: PUSH
4963: LD_INT 0
4965: GREATER
4966: IFFALSE 5053
// for i = 1 to engs do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_VAR 0 8
4982: PUSH
4983: FOR_TO
4984: IFFALSE 5051
// if not HasTask ( engs [ i ] ) then
4986: LD_VAR 0 8
4990: PUSH
4991: LD_VAR 0 2
4995: ARRAY
4996: PPUSH
4997: CALL_OW 314
5001: NOT
5002: IFFALSE 5049
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
5004: LD_VAR 0 8
5008: PUSH
5009: LD_VAR 0 2
5013: ARRAY
5014: PPUSH
5015: LD_INT 32
5017: PPUSH
5018: LD_EXP 18
5022: PUSH
5023: LD_INT 1
5025: ARRAY
5026: PPUSH
5027: LD_EXP 18
5031: PUSH
5032: LD_INT 2
5034: ARRAY
5035: PPUSH
5036: LD_EXP 18
5040: PUSH
5041: LD_INT 3
5043: ARRAY
5044: PPUSH
5045: CALL_OW 145
5049: GO 4983
5051: POP
5052: POP
// end ; end ; if event = 6 then
5053: LD_VAR 0 1
5057: PUSH
5058: LD_INT 6
5060: EQUAL
5061: IFFALSE 5245
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 22
5070: PUSH
5071: LD_INT 1
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 30
5080: PUSH
5081: LD_INT 5
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: PPUSH
5092: CALL_OW 69
5096: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5097: LD_VAR 0 6
5101: PUSH
5102: LD_INT 22
5104: PUSH
5105: LD_INT 1
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: LD_INT 30
5114: PUSH
5115: LD_INT 32
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: PUSH
5122: LD_INT 58
5124: PUSH
5125: EMPTY
5126: LIST
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: LIST
5132: PUSH
5133: EMPTY
5134: LIST
5135: PPUSH
5136: CALL_OW 69
5140: PUSH
5141: LD_INT 0
5143: GREATER
5144: AND
5145: IFFALSE 5245
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5147: LD_ADDR_VAR 0 10
5151: PUSH
5152: LD_INT 22
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: PUSH
5162: LD_INT 30
5164: PUSH
5165: LD_INT 32
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: PUSH
5172: LD_INT 58
5174: PUSH
5175: EMPTY
5176: LIST
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: PPUSH
5186: CALL_OW 69
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5195: LD_ADDR_VAR 0 3
5199: PUSH
5200: LD_VAR 0 6
5204: PUSH
5205: LD_INT 1
5207: ARRAY
5208: PPUSH
5209: CALL_OW 313
5213: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5214: LD_VAR 0 3
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PPUSH
5223: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5227: LD_VAR 0 3
5231: PUSH
5232: LD_INT 1
5234: ARRAY
5235: PPUSH
5236: LD_VAR 0 10
5240: PPUSH
5241: CALL_OW 180
// end ; end ; end ;
5245: PPOPN 10
5247: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5248: LD_VAR 0 1
5252: PUSH
5253: LD_INT 1
5255: EQUAL
5256: PUSH
5257: LD_VAR 0 2
5261: PUSH
5262: LD_INT 3
5264: EQUAL
5265: AND
5266: IFFALSE 5276
// contact_am := true ;
5268: LD_ADDR_EXP 16
5272: PUSH
5273: LD_INT 1
5275: ST_TO_ADDR
// end ; end_of_file
5276: PPOPN 2
5278: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5279: LD_INT 0
5281: PPUSH
5282: PPUSH
5283: PPUSH
5284: PPUSH
5285: PPUSH
5286: PPUSH
5287: PPUSH
5288: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5289: LD_ADDR_VAR 0 5
5293: PUSH
5294: LD_INT 5
5296: PUSH
5297: LD_INT 6
5299: PUSH
5300: LD_INT 7
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: LIST
5307: PUSH
5308: LD_EXP 1
5312: ARRAY
5313: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5314: LD_ADDR_VAR 0 6
5318: PUSH
5319: LD_INT 4
5321: PUSH
5322: LD_INT 4
5324: PUSH
5325: LD_INT 4
5327: PUSH
5328: LD_INT 5
5330: PUSH
5331: LD_INT 5
5333: PUSH
5334: LD_INT 5
5336: PUSH
5337: LD_INT 6
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: LIST
5347: LIST
5348: ST_TO_ADDR
// SForce := [ ] ;
5349: LD_ADDR_EXP 11
5353: PUSH
5354: EMPTY
5355: ST_TO_ADDR
// Sikorski_Ar := false ;
5356: LD_ADDR_EXP 12
5360: PUSH
5361: LD_INT 0
5363: ST_TO_ADDR
// attacked := false ;
5364: LD_ADDR_EXP 15
5368: PUSH
5369: LD_INT 0
5371: ST_TO_ADDR
// contact_am := false ;
5372: LD_ADDR_EXP 16
5376: PUSH
5377: LD_INT 0
5379: ST_TO_ADDR
// patrol := [ ] ;
5380: LD_ADDR_EXP 17
5384: PUSH
5385: EMPTY
5386: ST_TO_ADDR
// gamma_towers := [ ] ;
5387: LD_ADDR_EXP 18
5391: PUSH
5392: EMPTY
5393: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5394: LD_INT 25
5396: PPUSH
5397: LD_STRING gamma
5399: PPUSH
5400: CALL_OW 500
// uc_side := 1 ;
5404: LD_ADDR_OWVAR 20
5408: PUSH
5409: LD_INT 1
5411: ST_TO_ADDR
// uc_nation := 1 ;
5412: LD_ADDR_OWVAR 21
5416: PUSH
5417: LD_INT 1
5419: ST_TO_ADDR
// hc_importance := 0 ;
5420: LD_ADDR_OWVAR 32
5424: PUSH
5425: LD_INT 0
5427: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5428: LD_ADDR_OWVAR 26
5432: PUSH
5433: LD_STRING Jeremy Sikorski
5435: ST_TO_ADDR
// hc_gallery := us ;
5436: LD_ADDR_OWVAR 33
5440: PUSH
5441: LD_STRING us
5443: ST_TO_ADDR
// hc_face_number := 19 ;
5444: LD_ADDR_OWVAR 34
5448: PUSH
5449: LD_INT 19
5451: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5452: LD_ADDR_OWVAR 31
5456: PUSH
5457: LD_VAR 0 5
5461: PPUSH
5462: LD_VAR 0 5
5466: PUSH
5467: LD_INT 2
5469: PLUS
5470: PPUSH
5471: CALL_OW 12
5475: PUSH
5476: LD_INT 4
5478: PUSH
5479: LD_INT 6
5481: PUSH
5482: LD_INT 3
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: ST_TO_ADDR
// hc_sex := sex_male ;
5491: LD_ADDR_OWVAR 27
5495: PUSH
5496: LD_INT 1
5498: ST_TO_ADDR
// hc_class := 1 ;
5499: LD_ADDR_OWVAR 28
5503: PUSH
5504: LD_INT 1
5506: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5507: LD_ADDR_OWVAR 29
5511: PUSH
5512: LD_INT 10
5514: PUSH
5515: LD_INT 11
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: ST_TO_ADDR
// sikorski := CreateHuman ;
5522: LD_ADDR_EXP 9
5526: PUSH
5527: CALL_OW 44
5531: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5532: LD_ADDR_OWVAR 26
5536: PUSH
5537: LD_STRING Lucy Donaldson
5539: ST_TO_ADDR
// hc_gallery := us ;
5540: LD_ADDR_OWVAR 33
5544: PUSH
5545: LD_STRING us
5547: ST_TO_ADDR
// hc_face_number := 2 ;
5548: LD_ADDR_OWVAR 34
5552: PUSH
5553: LD_INT 2
5555: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5556: LD_ADDR_OWVAR 31
5560: PUSH
5561: LD_VAR 0 5
5565: PPUSH
5566: LD_VAR 0 5
5570: PUSH
5571: LD_INT 2
5573: PLUS
5574: PPUSH
5575: CALL_OW 12
5579: PUSH
5580: LD_INT 6
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: LD_INT 2
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: ST_TO_ADDR
// hc_sex := sex_female ;
5595: LD_ADDR_OWVAR 27
5599: PUSH
5600: LD_INT 2
5602: ST_TO_ADDR
// hc_class := 1 ;
5603: LD_ADDR_OWVAR 28
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// donald := CreateHuman ;
5611: LD_ADDR_EXP 13
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5621: LD_ADDR_OWVAR 26
5625: PUSH
5626: LD_STRING Peter Van Houten
5628: ST_TO_ADDR
// hc_gallery := us ;
5629: LD_ADDR_OWVAR 33
5633: PUSH
5634: LD_STRING us
5636: ST_TO_ADDR
// hc_face_number := 16 ;
5637: LD_ADDR_OWVAR 34
5641: PUSH
5642: LD_INT 16
5644: ST_TO_ADDR
// hc_sex := sex_male ;
5645: LD_ADDR_OWVAR 27
5649: PUSH
5650: LD_INT 1
5652: ST_TO_ADDR
// van := CreateHuman ;
5653: LD_ADDR_EXP 14
5657: PUSH
5658: CALL_OW 44
5662: ST_TO_ADDR
// hc_importance := 0 ;
5663: LD_ADDR_OWVAR 32
5667: PUSH
5668: LD_INT 0
5670: ST_TO_ADDR
// case dif of 1 :
5671: LD_EXP 1
5675: PUSH
5676: LD_INT 1
5678: DOUBLE
5679: EQUAL
5680: IFTRUE 5684
5682: GO 5695
5684: POP
// lw = 1 ; 2 :
5685: LD_ADDR_VAR 0 8
5689: PUSH
5690: LD_INT 1
5692: ST_TO_ADDR
5693: GO 5742
5695: LD_INT 2
5697: DOUBLE
5698: EQUAL
5699: IFTRUE 5703
5701: GO 5722
5703: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5704: LD_ADDR_VAR 0 8
5708: PUSH
5709: LD_INT 1
5711: PPUSH
5712: LD_INT 2
5714: PPUSH
5715: CALL_OW 12
5719: ST_TO_ADDR
5720: GO 5742
5722: LD_INT 3
5724: DOUBLE
5725: EQUAL
5726: IFTRUE 5730
5728: GO 5741
5730: POP
// lw = 2 ; end ;
5731: LD_ADDR_VAR 0 8
5735: PUSH
5736: LD_INT 2
5738: ST_TO_ADDR
5739: GO 5742
5741: POP
// case lw of 1 :
5742: LD_VAR 0 8
5746: PUSH
5747: LD_INT 1
5749: DOUBLE
5750: EQUAL
5751: IFTRUE 5755
5753: GO 5770
5755: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5756: LD_EXP 13
5760: PPUSH
5761: LD_INT 25
5763: PPUSH
5764: CALL_OW 52
5768: GO 5794
5770: LD_INT 2
5772: DOUBLE
5773: EQUAL
5774: IFTRUE 5778
5776: GO 5793
5778: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5779: LD_EXP 14
5783: PPUSH
5784: LD_INT 25
5786: PPUSH
5787: CALL_OW 52
5791: GO 5794
5793: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5794: LD_ADDR_VAR 0 2
5798: PUSH
5799: LD_INT 22
5801: PUSH
5802: LD_INT 1
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 30
5811: PUSH
5812: LD_INT 32
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: PPUSH
5823: CALL_OW 69
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5883
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5831: LD_INT 1
5833: PPUSH
5834: LD_VAR 0 5
5838: PPUSH
5839: CALL 819 0 2
5843: PPUSH
5844: LD_VAR 0 2
5848: PPUSH
5849: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5853: LD_VAR 0 2
5857: PPUSH
5858: LD_VAR 0 6
5862: PUSH
5863: LD_INT 1
5865: PPUSH
5866: LD_VAR 0 6
5870: PPUSH
5871: CALL_OW 12
5875: ARRAY
5876: PPUSH
5877: CALL_OW 431
// end ;
5881: GO 5828
5883: POP
5884: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5885: LD_ADDR_VAR 0 7
5889: PUSH
5890: LD_INT 22
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 2
5902: PUSH
5903: LD_INT 25
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PUSH
5913: LD_INT 5
5915: PUSH
5916: EMPTY
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PPUSH
5928: CALL_OW 69
5932: ST_TO_ADDR
// for i = 1 to sol do
5933: LD_ADDR_VAR 0 2
5937: PUSH
5938: DOUBLE
5939: LD_INT 1
5941: DEC
5942: ST_TO_ADDR
5943: LD_VAR 0 7
5947: PUSH
5948: FOR_TO
5949: IFFALSE 5971
// SetTag ( sol [ i ] , 1 ) ;
5951: LD_VAR 0 7
5955: PUSH
5956: LD_VAR 0 2
5960: ARRAY
5961: PPUSH
5962: LD_INT 1
5964: PPUSH
5965: CALL_OW 109
5969: GO 5948
5971: POP
5972: POP
// for i = 1 to 3 do
5973: LD_ADDR_VAR 0 2
5977: PUSH
5978: DOUBLE
5979: LD_INT 1
5981: DEC
5982: ST_TO_ADDR
5983: LD_INT 3
5985: PUSH
5986: FOR_TO
5987: IFFALSE 6011
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5989: LD_INT 3
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: CALL 819 0 2
6001: PPUSH
6002: LD_INT 56
6004: PPUSH
6005: CALL_OW 52
6009: GO 5986
6011: POP
6012: POP
// for i = 1 to 6 do
6013: LD_ADDR_VAR 0 2
6017: PUSH
6018: DOUBLE
6019: LD_INT 1
6021: DEC
6022: ST_TO_ADDR
6023: LD_INT 6
6025: PUSH
6026: FOR_TO
6027: IFFALSE 6051
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
6029: LD_INT 3
6031: PPUSH
6032: LD_VAR 0 5
6036: PPUSH
6037: CALL 819 0 2
6041: PPUSH
6042: LD_INT 26
6044: PPUSH
6045: CALL_OW 52
6049: GO 6026
6051: POP
6052: POP
// for i = 1 to 5 do
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: DOUBLE
6059: LD_INT 1
6061: DEC
6062: ST_TO_ADDR
6063: LD_INT 5
6065: PUSH
6066: FOR_TO
6067: IFFALSE 6094
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6069: LD_INT 2
6071: PPUSH
6072: LD_VAR 0 5
6076: PPUSH
6077: CALL 819 0 2
6081: PPUSH
6082: LD_INT 7
6084: PPUSH
6085: LD_INT 0
6087: PPUSH
6088: CALL_OW 49
6092: GO 6066
6094: POP
6095: POP
// for i = 1 to 3 do
6096: LD_ADDR_VAR 0 2
6100: PUSH
6101: DOUBLE
6102: LD_INT 1
6104: DEC
6105: ST_TO_ADDR
6106: LD_INT 3
6108: PUSH
6109: FOR_TO
6110: IFFALSE 6134
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6112: LD_INT 4
6114: PPUSH
6115: LD_VAR 0 5
6119: PPUSH
6120: CALL 819 0 2
6124: PPUSH
6125: LD_INT 46
6127: PPUSH
6128: CALL_OW 52
6132: GO 6109
6134: POP
6135: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6136: LD_ADDR_VAR 0 2
6140: PUSH
6141: LD_INT 22
6143: PUSH
6144: LD_INT 1
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: LD_INT 30
6153: PUSH
6154: LD_INT 5
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 69
6169: PUSH
6170: FOR_IN
6171: IFFALSE 6285
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6173: LD_INT 5
6175: PPUSH
6176: LD_VAR 0 5
6180: PPUSH
6181: CALL 819 0 2
6185: PPUSH
6186: LD_VAR 0 2
6190: PPUSH
6191: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6195: LD_INT 5
6197: PPUSH
6198: LD_VAR 0 5
6202: PPUSH
6203: CALL 819 0 2
6207: PPUSH
6208: LD_VAR 0 2
6212: PPUSH
6213: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6217: LD_INT 1
6219: PPUSH
6220: LD_VAR 0 5
6224: PPUSH
6225: CALL 819 0 2
6229: PPUSH
6230: LD_VAR 0 2
6234: PPUSH
6235: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6239: LD_INT 1
6241: PPUSH
6242: LD_VAR 0 5
6246: PPUSH
6247: CALL 819 0 2
6251: PPUSH
6252: LD_VAR 0 2
6256: PPUSH
6257: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6261: LD_INT 1
6263: PPUSH
6264: LD_VAR 0 5
6268: PPUSH
6269: CALL 819 0 2
6273: PPUSH
6274: LD_VAR 0 2
6278: PPUSH
6279: CALL_OW 52
// end ;
6283: GO 6170
6285: POP
6286: POP
// if dif > 1 then
6287: LD_EXP 1
6291: PUSH
6292: LD_INT 1
6294: GREATER
6295: IFFALSE 6368
// for i = 1 to ( dif - 1 ) do
6297: LD_ADDR_VAR 0 2
6301: PUSH
6302: DOUBLE
6303: LD_INT 1
6305: DEC
6306: ST_TO_ADDR
6307: LD_EXP 1
6311: PUSH
6312: LD_INT 1
6314: MINUS
6315: PUSH
6316: FOR_TO
6317: IFFALSE 6366
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6319: LD_ADDR_EXP 17
6323: PUSH
6324: LD_EXP 17
6328: PUSH
6329: LD_INT 1
6331: PPUSH
6332: LD_VAR 0 5
6336: PPUSH
6337: CALL 819 0 2
6341: ADD
6342: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6343: LD_EXP 17
6347: PUSH
6348: LD_VAR 0 2
6352: ARRAY
6353: PPUSH
6354: LD_INT 3
6356: PPUSH
6357: LD_INT 0
6359: PPUSH
6360: CALL_OW 49
// end ;
6364: GO 6316
6366: POP
6367: POP
// game_started := true ;
6368: LD_ADDR_EXP 10
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6376: LD_INT 26
6378: PPUSH
6379: LD_INT 3
6381: PPUSH
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 2
6387: PPUSH
6388: LD_INT 13
6390: PPUSH
6391: CALL_OW 125
// while ( contact_am = false ) do
6395: LD_EXP 16
6399: PUSH
6400: LD_INT 0
6402: EQUAL
6403: IFFALSE 6414
// begin Wait ( 0 0$01 ) ;
6405: LD_INT 35
6407: PPUSH
6408: CALL_OW 67
// end ;
6412: GO 6395
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6414: LD_INT 8400
6416: PUSH
6417: LD_INT 6300
6419: PUSH
6420: LD_INT 5250
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_EXP 1
6432: ARRAY
6433: PPUSH
6434: CALL_OW 67
// case dif of 1 :
6438: LD_EXP 1
6442: PUSH
6443: LD_INT 1
6445: DOUBLE
6446: EQUAL
6447: IFTRUE 6451
6449: GO 6626
6451: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6452: LD_INT 26
6454: PPUSH
6455: LD_INT 3
6457: PPUSH
6458: LD_INT 1
6460: PPUSH
6461: LD_INT 2
6463: PPUSH
6464: LD_INT 2
6466: PUSH
6467: LD_INT 4
6469: PUSH
6470: LD_INT 5
6472: PUSH
6473: LD_INT 5
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 1
6484: PPUSH
6485: LD_INT 4
6487: PPUSH
6488: CALL_OW 12
6492: ARRAY
6493: PPUSH
6494: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6498: LD_INT 26
6500: PPUSH
6501: LD_INT 3
6503: PPUSH
6504: LD_INT 1
6506: PPUSH
6507: LD_INT 2
6509: PPUSH
6510: LD_INT 4
6512: PUSH
6513: LD_INT 5
6515: PUSH
6516: LD_INT 5
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 1
6526: PPUSH
6527: LD_INT 3
6529: PPUSH
6530: CALL_OW 12
6534: ARRAY
6535: PPUSH
6536: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6540: LD_INT 26
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 1
6548: PPUSH
6549: LD_INT 2
6551: PPUSH
6552: LD_INT 4
6554: PUSH
6555: LD_INT 5
6557: PUSH
6558: LD_INT 5
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 1
6568: PPUSH
6569: LD_INT 3
6571: PPUSH
6572: CALL_OW 12
6576: ARRAY
6577: PPUSH
6578: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6582: LD_INT 26
6584: PPUSH
6585: LD_INT 3
6587: PPUSH
6588: LD_INT 1
6590: PPUSH
6591: LD_INT 2
6593: PPUSH
6594: LD_INT 4
6596: PUSH
6597: LD_INT 3
6599: PUSH
6600: LD_INT 5
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: PUSH
6608: LD_INT 1
6610: PPUSH
6611: LD_INT 3
6613: PPUSH
6614: CALL_OW 12
6618: ARRAY
6619: PPUSH
6620: CALL_OW 185
// end ; 2 :
6624: GO 7153
6626: LD_INT 2
6628: DOUBLE
6629: EQUAL
6630: IFTRUE 6634
6632: GO 6847
6634: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6635: LD_INT 26
6637: PPUSH
6638: LD_INT 3
6640: PPUSH
6641: LD_INT 1
6643: PPUSH
6644: LD_INT 2
6646: PPUSH
6647: LD_INT 4
6649: PUSH
6650: LD_INT 5
6652: PUSH
6653: LD_INT 5
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_INT 1
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: CALL_OW 12
6671: ARRAY
6672: PPUSH
6673: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6677: LD_INT 26
6679: PPUSH
6680: LD_INT 3
6682: PPUSH
6683: LD_INT 1
6685: PPUSH
6686: LD_INT 2
6688: PPUSH
6689: LD_INT 4
6691: PUSH
6692: LD_INT 5
6694: PUSH
6695: LD_INT 5
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 1
6705: PPUSH
6706: LD_INT 3
6708: PPUSH
6709: CALL_OW 12
6713: ARRAY
6714: PPUSH
6715: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6719: LD_INT 26
6721: PPUSH
6722: LD_INT 3
6724: PPUSH
6725: LD_INT 1
6727: PPUSH
6728: LD_INT 2
6730: PPUSH
6731: LD_INT 4
6733: PUSH
6734: LD_INT 3
6736: PUSH
6737: LD_INT 5
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: PUSH
6745: LD_INT 1
6747: PPUSH
6748: LD_INT 3
6750: PPUSH
6751: CALL_OW 12
6755: ARRAY
6756: PPUSH
6757: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6761: LD_INT 26
6763: PPUSH
6764: LD_INT 4
6766: PPUSH
6767: LD_INT 1
6769: PPUSH
6770: LD_INT 2
6772: PPUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: LD_INT 6
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_INT 3
6792: PPUSH
6793: CALL_OW 12
6797: ARRAY
6798: PPUSH
6799: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6803: LD_INT 26
6805: PPUSH
6806: LD_INT 4
6808: PPUSH
6809: LD_INT 1
6811: PPUSH
6812: LD_INT 2
6814: PPUSH
6815: LD_INT 4
6817: PUSH
6818: LD_INT 5
6820: PUSH
6821: LD_INT 6
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 1
6831: PPUSH
6832: LD_INT 3
6834: PPUSH
6835: CALL_OW 12
6839: ARRAY
6840: PPUSH
6841: CALL_OW 185
// end ; 3 :
6845: GO 7153
6847: LD_INT 3
6849: DOUBLE
6850: EQUAL
6851: IFTRUE 6855
6853: GO 7152
6855: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6856: LD_INT 26
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: LD_INT 2
6867: PPUSH
6868: LD_INT 4
6870: PUSH
6871: LD_INT 5
6873: PUSH
6874: LD_INT 5
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 1
6884: PPUSH
6885: LD_INT 3
6887: PPUSH
6888: CALL_OW 12
6892: ARRAY
6893: PPUSH
6894: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6898: LD_INT 26
6900: PPUSH
6901: LD_INT 3
6903: PPUSH
6904: LD_INT 1
6906: PPUSH
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PUSH
6913: LD_INT 5
6915: PUSH
6916: LD_INT 5
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 1
6926: PPUSH
6927: LD_INT 3
6929: PPUSH
6930: CALL_OW 12
6934: ARRAY
6935: PPUSH
6936: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6940: LD_INT 26
6942: PPUSH
6943: LD_INT 3
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: LD_INT 2
6951: PPUSH
6952: LD_INT 4
6954: PUSH
6955: LD_INT 5
6957: PUSH
6958: LD_INT 5
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: LD_INT 3
6971: PPUSH
6972: CALL_OW 12
6976: ARRAY
6977: PPUSH
6978: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6982: LD_INT 26
6984: PPUSH
6985: LD_INT 3
6987: PPUSH
6988: LD_INT 1
6990: PPUSH
6991: LD_INT 2
6993: PPUSH
6994: LD_INT 4
6996: PUSH
6997: LD_INT 5
6999: PUSH
7000: LD_INT 5
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: LD_INT 1
7010: PPUSH
7011: LD_INT 3
7013: PPUSH
7014: CALL_OW 12
7018: ARRAY
7019: PPUSH
7020: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7024: LD_INT 26
7026: PPUSH
7027: LD_INT 4
7029: PPUSH
7030: LD_INT 1
7032: PPUSH
7033: LD_INT 2
7035: PPUSH
7036: LD_INT 4
7038: PUSH
7039: LD_INT 5
7041: PUSH
7042: LD_INT 6
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_INT 3
7055: PPUSH
7056: CALL_OW 12
7060: ARRAY
7061: PPUSH
7062: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7066: LD_INT 26
7068: PPUSH
7069: LD_INT 4
7071: PPUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 2
7077: PPUSH
7078: LD_INT 4
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 6
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 1
7094: PPUSH
7095: LD_INT 3
7097: PPUSH
7098: CALL_OW 12
7102: ARRAY
7103: PPUSH
7104: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7108: LD_INT 26
7110: PPUSH
7111: LD_INT 4
7113: PPUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: LD_INT 4
7122: PUSH
7123: LD_INT 5
7125: PUSH
7126: LD_INT 6
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 1
7136: PPUSH
7137: LD_INT 3
7139: PPUSH
7140: CALL_OW 12
7144: ARRAY
7145: PPUSH
7146: CALL_OW 185
// end ; end ;
7150: GO 7153
7152: POP
// end ;
7153: LD_VAR 0 1
7157: RET
// every 0 0$01 do var i , filter ;
7158: GO 7160
7160: DISABLE
7161: LD_INT 0
7163: PPUSH
7164: PPUSH
// begin enable ;
7165: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7166: LD_INT 22
7168: PUSH
7169: LD_INT 1
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 25
7178: PUSH
7179: LD_INT 4
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PPUSH
7190: CALL_OW 69
7194: PUSH
7195: LD_INT 0
7197: GREATER
7198: IFFALSE 7207
// RaiseSailEvent ( 3 ) ;
7200: LD_INT 3
7202: PPUSH
7203: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7207: LD_INT 22
7209: PUSH
7210: LD_INT 1
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: LD_INT 21
7219: PUSH
7220: LD_INT 3
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 24
7232: PUSH
7233: LD_INT 1000
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: PPUSH
7249: CALL_OW 69
7253: PUSH
7254: LD_INT 0
7256: GREATER
7257: IFFALSE 7268
// RaiseSailEvent ( 1 ) else
7259: LD_INT 1
7261: PPUSH
7262: CALL_OW 427
7266: GO 7275
// RaiseSailEvent ( 2 ) ;
7268: LD_INT 2
7270: PPUSH
7271: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7275: LD_INT 22
7277: PUSH
7278: LD_INT 1
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: LD_INT 30
7287: PUSH
7288: LD_INT 5
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PPUSH
7299: CALL_OW 69
7303: PUSH
7304: LD_INT 0
7306: GREATER
7307: IFFALSE 7316
// RaiseSailEvent ( 4 ) ;
7309: LD_INT 4
7311: PPUSH
7312: CALL_OW 427
// if gamma_towers > 0 then
7316: LD_EXP 18
7320: PUSH
7321: LD_INT 0
7323: GREATER
7324: IFFALSE 7333
// RaiseSailEvent ( 5 ) ;
7326: LD_INT 5
7328: PPUSH
7329: CALL_OW 427
// end ;
7333: PPOPN 2
7335: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7336: GO 7338
7338: DISABLE
7339: LD_INT 0
7341: PPUSH
7342: PPUSH
// begin enable ;
7343: ENABLE
// if new_veh > 0 then
7344: LD_EXP 19
7348: PUSH
7349: LD_INT 0
7351: GREATER
7352: IFFALSE 7539
// while ( new_veh > 0 ) do
7354: LD_EXP 19
7358: PUSH
7359: LD_INT 0
7361: GREATER
7362: IFFALSE 7539
// begin Wait ( 0 0$01 ) ;
7364: LD_INT 35
7366: PPUSH
7367: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7371: LD_INT 26
7373: PPUSH
7374: CALL_OW 461
7378: PUSH
7379: LD_INT 2
7381: EQUAL
7382: IFFALSE 7537
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7384: LD_ADDR_VAR 0 1
7388: PUSH
7389: LD_INT 2
7391: PUSH
7392: LD_INT 3
7394: PUSH
7395: LD_INT 3
7397: PUSH
7398: LD_INT 4
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 1
7409: PPUSH
7410: LD_INT 4
7412: PPUSH
7413: CALL_OW 12
7417: ARRAY
7418: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7419: LD_VAR 0 1
7423: PUSH
7424: LD_INT 2
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: IN
7434: IFFALSE 7469
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7436: LD_ADDR_VAR 0 2
7440: PUSH
7441: LD_INT 4
7443: PUSH
7444: LD_INT 5
7446: PUSH
7447: LD_INT 7
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: LIST
7454: PUSH
7455: LD_INT 1
7457: PPUSH
7458: LD_INT 3
7460: PPUSH
7461: CALL_OW 12
7465: ARRAY
7466: ST_TO_ADDR
7467: GO 7500
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7469: LD_ADDR_VAR 0 2
7473: PUSH
7474: LD_INT 5
7476: PUSH
7477: LD_INT 7
7479: PUSH
7480: LD_INT 6
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: PUSH
7488: LD_INT 1
7490: PPUSH
7491: LD_INT 3
7493: PPUSH
7494: CALL_OW 12
7498: ARRAY
7499: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7500: LD_INT 26
7502: PPUSH
7503: LD_VAR 0 1
7507: PPUSH
7508: LD_INT 1
7510: PPUSH
7511: LD_INT 2
7513: PPUSH
7514: LD_VAR 0 2
7518: PPUSH
7519: CALL_OW 125
// new_veh := new_veh - 1 ;
7523: LD_ADDR_EXP 19
7527: PUSH
7528: LD_EXP 19
7532: PUSH
7533: LD_INT 1
7535: MINUS
7536: ST_TO_ADDR
// end ; end ;
7537: GO 7354
// end ;
7539: PPOPN 2
7541: END
// every 0 0$01 do var v , filter , am_cmeh ;
7542: GO 7544
7544: DISABLE
7545: LD_INT 0
7547: PPUSH
7548: PPUSH
7549: PPUSH
// begin enable ;
7550: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7551: LD_ADDR_VAR 0 3
7555: PUSH
7556: LD_INT 56
7558: PPUSH
7559: CALL_OW 313
7563: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7564: LD_ADDR_VAR 0 2
7568: PUSH
7569: LD_INT 22
7571: PUSH
7572: LD_INT 1
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 33
7581: PUSH
7582: LD_INT 2
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 50
7591: PUSH
7592: EMPTY
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: PPUSH
7603: CALL_OW 69
7607: ST_TO_ADDR
// if filter > 0 then
7608: LD_VAR 0 2
7612: PUSH
7613: LD_INT 0
7615: GREATER
7616: IFFALSE 7684
// begin for v in filter do
7618: LD_ADDR_VAR 0 1
7622: PUSH
7623: LD_VAR 0 2
7627: PUSH
7628: FOR_IN
7629: IFFALSE 7682
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7631: LD_VAR 0 1
7635: PPUSH
7636: CALL_OW 312
7640: NOT
7641: PUSH
7642: LD_VAR 0 1
7646: PPUSH
7647: CALL_OW 302
7651: AND
7652: IFFALSE 7680
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7654: LD_VAR 0 1
7658: PPUSH
7659: LD_VAR 0 3
7663: PUSH
7664: LD_INT 1
7666: PPUSH
7667: LD_INT 3
7669: PPUSH
7670: CALL_OW 12
7674: ARRAY
7675: PPUSH
7676: CALL_OW 135
// end ;
7680: GO 7628
7682: POP
7683: POP
// end ; end ;
7684: PPOPN 3
7686: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7687: LD_INT 33
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 3
7699: PUSH
7700: LD_INT 34
7702: PUSH
7703: LD_INT 13
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: PUSH
7723: LD_INT 4
7725: PUSH
7726: LD_INT 5
7728: PUSH
7729: LD_INT 7
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: LIST
7736: PUSH
7737: LD_EXP 1
7741: ARRAY
7742: EQUAL
7743: PUSH
7744: LD_INT 26
7746: PPUSH
7747: CALL_OW 461
7751: PUSH
7752: LD_INT 2
7754: EQUAL
7755: AND
7756: IFFALSE 7967
7758: GO 7760
7760: DISABLE
7761: LD_INT 0
7763: PPUSH
7764: PPUSH
7765: PPUSH
// begin enable ;
7766: ENABLE
// if Sikorski_Ar then
7767: LD_EXP 12
7771: IFFALSE 7848
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7773: LD_ADDR_EXP 11
7777: PUSH
7778: LD_INT 2
7780: PUSH
7781: LD_INT 22
7783: PUSH
7784: LD_INT 4
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: LD_INT 22
7793: PUSH
7794: LD_INT 1
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PUSH
7801: LD_INT 33
7803: PUSH
7804: LD_INT 2
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 34
7816: PUSH
7817: LD_INT 13
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: LIST
7837: PUSH
7838: EMPTY
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: ST_TO_ADDR
7846: GO 7889
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7848: LD_ADDR_EXP 11
7852: PUSH
7853: LD_INT 33
7855: PUSH
7856: LD_INT 2
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 3
7865: PUSH
7866: LD_INT 34
7868: PUSH
7869: LD_INT 13
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: EMPTY
7881: LIST
7882: LIST
7883: PPUSH
7884: CALL_OW 69
7888: ST_TO_ADDR
// repeat begin for un in SForce do
7889: LD_ADDR_VAR 0 2
7893: PUSH
7894: LD_EXP 11
7898: PUSH
7899: FOR_IN
7900: IFFALSE 7955
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7902: LD_ADDR_VAR 0 3
7906: PUSH
7907: LD_INT 22
7909: PUSH
7910: LD_INT 3
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PPUSH
7917: CALL_OW 69
7921: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_VAR 0 3
7931: PPUSH
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 74
7941: PPUSH
7942: CALL_OW 115
// Wait ( 0 0$01 ) ;
7946: LD_INT 35
7948: PPUSH
7949: CALL_OW 67
// end ;
7953: GO 7899
7955: POP
7956: POP
// end until SForce = 0 ;
7957: LD_EXP 11
7961: PUSH
7962: LD_INT 0
7964: EQUAL
7965: IFFALSE 7889
// end ;
7967: PPOPN 3
7969: END
// export function NewForce ( num ) ; var i , filter , veh ; begin
7970: LD_INT 0
7972: PPUSH
7973: PPUSH
7974: PPUSH
7975: PPUSH
// uc_side := 4 ;
7976: LD_ADDR_OWVAR 20
7980: PUSH
7981: LD_INT 4
7983: ST_TO_ADDR
// uc_nation := 1 ;
7984: LD_ADDR_OWVAR 21
7988: PUSH
7989: LD_INT 1
7991: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7992: LD_ADDR_OWVAR 37
7996: PUSH
7997: LD_INT 4
7999: ST_TO_ADDR
// vc_control := control_manual ;
8000: LD_ADDR_OWVAR 38
8004: PUSH
8005: LD_INT 1
8007: ST_TO_ADDR
// vc_engine := engine_combustion ;
8008: LD_ADDR_OWVAR 39
8012: PUSH
8013: LD_INT 1
8015: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8016: LD_ADDR_OWVAR 40
8020: PUSH
8021: LD_INT 4
8023: PUSH
8024: LD_INT 5
8026: PUSH
8027: LD_INT 7
8029: PUSH
8030: EMPTY
8031: LIST
8032: LIST
8033: LIST
8034: PUSH
8035: LD_EXP 1
8039: ARRAY
8040: ST_TO_ADDR
// veh := CreateVehicle ;
8041: LD_ADDR_VAR 0 5
8045: PUSH
8046: CALL_OW 45
8050: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8051: LD_VAR 0 5
8055: PPUSH
8056: LD_INT 2
8058: PPUSH
8059: LD_INT 0
8061: PPUSH
8062: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8066: LD_EXP 9
8070: PPUSH
8071: LD_VAR 0 5
8075: PPUSH
8076: CALL_OW 52
// SetMark ( veh , 1 ) ;
8080: LD_VAR 0 5
8084: PPUSH
8085: LD_INT 1
8087: PPUSH
8088: CALL_OW 242
// while ( num > 0 ) do
8092: LD_VAR 0 1
8096: PUSH
8097: LD_INT 0
8099: GREATER
8100: IFFALSE 8267
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8102: LD_INT 3
8104: PUSH
8105: LD_INT 3
8107: PUSH
8108: LD_INT 3
8110: PUSH
8111: LD_INT 4
8113: PUSH
8114: EMPTY
8115: LIST
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_EXP 1
8124: PPUSH
8125: LD_INT 4
8127: PPUSH
8128: CALL_OW 12
8132: ARRAY
8133: PPUSH
8134: LD_INT 1
8136: PPUSH
8137: LD_INT 4
8139: PUSH
8140: LD_INT 5
8142: PUSH
8143: LD_INT 5
8145: PUSH
8146: LD_INT 7
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 1
8157: PPUSH
8158: LD_EXP 1
8162: PUSH
8163: LD_INT 1
8165: PLUS
8166: PPUSH
8167: CALL_OW 12
8171: ARRAY
8172: PPUSH
8173: LD_INT 11
8175: PPUSH
8176: LD_INT 2
8178: PPUSH
8179: LD_INT 5
8181: PUSH
8182: LD_INT 6
8184: PUSH
8185: LD_INT 7
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_EXP 1
8197: ARRAY
8198: PPUSH
8199: CALL 1382 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8203: LD_ADDR_VAR 0 4
8207: PUSH
8208: LD_INT 22
8210: PUSH
8211: LD_INT 4
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PPUSH
8218: CALL_OW 69
8222: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8223: LD_VAR 0 4
8227: PUSH
8228: LD_VAR 0 4
8232: ARRAY
8233: PPUSH
8234: LD_INT 36
8236: PPUSH
8237: LD_INT 18
8239: PPUSH
8240: CALL_OW 111
// Wait ( 0 0$02 ) ;
8244: LD_INT 70
8246: PPUSH
8247: CALL_OW 67
// num := num - 1 ;
8251: LD_ADDR_VAR 0 1
8255: PUSH
8256: LD_VAR 0 1
8260: PUSH
8261: LD_INT 1
8263: MINUS
8264: ST_TO_ADDR
// end ;
8265: GO 8092
// end ;
8267: LD_VAR 0 2
8271: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8272: LD_EXP 17
8276: PUSH
8277: LD_INT 0
8279: GREATER
8280: IFFALSE 8549
8282: GO 8284
8284: DISABLE
8285: LD_INT 0
8287: PPUSH
// begin enable ;
8288: ENABLE
// for i = 1 to patrol do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_EXP 17
8303: PUSH
8304: FOR_TO
8305: IFFALSE 8547
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8307: LD_EXP 17
8311: PUSH
8312: LD_VAR 0 1
8316: ARRAY
8317: PUSH
8318: LD_EXP 17
8322: PUSH
8323: LD_VAR 0 1
8327: ARRAY
8328: PPUSH
8329: CALL_OW 300
8333: AND
8334: PUSH
8335: LD_EXP 17
8339: PUSH
8340: LD_VAR 0 1
8344: ARRAY
8345: PPUSH
8346: CALL_OW 314
8350: NOT
8351: AND
8352: IFFALSE 8502
// case i of 1 :
8354: LD_VAR 0 1
8358: PUSH
8359: LD_INT 1
8361: DOUBLE
8362: EQUAL
8363: IFTRUE 8367
8365: GO 8430
8367: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8368: LD_EXP 17
8372: PUSH
8373: LD_VAR 0 1
8377: ARRAY
8378: PPUSH
8379: LD_INT 53
8381: PPUSH
8382: LD_INT 91
8384: PPUSH
8385: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8389: LD_EXP 17
8393: PUSH
8394: LD_VAR 0 1
8398: ARRAY
8399: PPUSH
8400: LD_INT 245
8402: PPUSH
8403: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8407: LD_EXP 17
8411: PUSH
8412: LD_VAR 0 1
8416: ARRAY
8417: PPUSH
8418: LD_INT 24
8420: PPUSH
8421: LD_INT 26
8423: PPUSH
8424: CALL_OW 171
// end ; 2 :
8428: GO 8502
8430: LD_INT 2
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8501
8438: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8439: LD_EXP 17
8443: PUSH
8444: LD_VAR 0 1
8448: ARRAY
8449: PPUSH
8450: LD_INT 83
8452: PPUSH
8453: LD_INT 57
8455: PPUSH
8456: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8460: LD_EXP 17
8464: PUSH
8465: LD_VAR 0 1
8469: ARRAY
8470: PPUSH
8471: LD_INT 245
8473: PPUSH
8474: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8478: LD_EXP 17
8482: PUSH
8483: LD_VAR 0 1
8487: ARRAY
8488: PPUSH
8489: LD_INT 47
8491: PPUSH
8492: LD_INT 53
8494: PPUSH
8495: CALL_OW 171
// end ; end ;
8499: GO 8502
8501: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8502: LD_EXP 17
8506: PUSH
8507: LD_VAR 0 1
8511: ARRAY
8512: PPUSH
8513: CALL_OW 256
8517: PUSH
8518: LD_INT 1000
8520: LESS
8521: IFFALSE 8545
// patrol := patrol diff patrol [ i ] ;
8523: LD_ADDR_EXP 17
8527: PUSH
8528: LD_EXP 17
8532: PUSH
8533: LD_EXP 17
8537: PUSH
8538: LD_VAR 0 1
8542: ARRAY
8543: DIFF
8544: ST_TO_ADDR
// end ;
8545: GO 8304
8547: POP
8548: POP
// end ;
8549: PPOPN 1
8551: END
// every 0 0$10 do
8552: GO 8554
8554: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8555: LD_INT 42000
8557: PUSH
8558: LD_INT 37800
8560: PUSH
8561: LD_INT 33600
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: PUSH
8569: LD_EXP 1
8573: ARRAY
8574: PPUSH
8575: CALL_OW 67
// if not contact_am then
8579: LD_EXP 16
8583: NOT
8584: IFFALSE 8594
// contact_am := true ;
8586: LD_ADDR_EXP 16
8590: PUSH
8591: LD_INT 1
8593: ST_TO_ADDR
// end ; end_of_file
8594: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8595: LD_INT 0
8597: PPUSH
// comp_tested := false ;
8598: LD_ADDR_EXP 22
8602: PUSH
8603: LD_INT 0
8605: ST_TO_ADDR
// sikorski_run := false ;
8606: LD_ADDR_EXP 23
8610: PUSH
8611: LD_INT 0
8613: ST_TO_ADDR
// InGameOn ;
8614: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8618: LD_EXP 3
8622: PPUSH
8623: CALL_OW 87
// Wait ( 0 0$01 ) ;
8627: LD_INT 35
8629: PPUSH
8630: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8634: LD_EXP 2
8638: PPUSH
8639: LD_STRING Dpop1
8641: PPUSH
8642: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8646: LD_EXP 3
8650: PPUSH
8651: LD_STRING Dcomm1
8653: PPUSH
8654: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8658: LD_EXP 2
8662: PPUSH
8663: LD_STRING Dpop2
8665: PPUSH
8666: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8670: LD_EXP 3
8674: PPUSH
8675: LD_STRING Dcomm2
8677: PPUSH
8678: CALL_OW 88
// InGameOff ;
8682: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8686: LD_STRING T1
8688: PPUSH
8689: CALL_OW 337
// end ;
8693: LD_VAR 0 1
8697: RET
// every 0 0$01 trigger timer > 2 2$01 do
8698: LD_EXP 24
8702: PUSH
8703: LD_INT 4235
8705: GREATER
8706: IFFALSE 8723
8708: GO 8710
8710: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8711: LD_EXP 5
8715: PPUSH
8716: LD_STRING DKap1
8718: PPUSH
8719: CALL_OW 94
// end ;
8723: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8724: LD_EXP 24
8728: PUSH
8729: LD_INT 46200
8731: PUSH
8732: LD_INT 52500
8734: PUSH
8735: LD_INT 63000
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: LIST
8742: PUSH
8743: LD_EXP 1
8747: ARRAY
8748: GREATER
8749: IFFALSE 9116
8751: GO 8753
8753: DISABLE
8754: LD_INT 0
8756: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8757: LD_EXP 5
8761: PPUSH
8762: LD_STRING DKap2
8764: PPUSH
8765: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8769: LD_INT 10
8771: PPUSH
8772: CALL_OW 67
// Say ( commander , Dcommk ) ;
8776: LD_EXP 3
8780: PPUSH
8781: LD_STRING Dcommk
8783: PPUSH
8784: CALL_OW 88
// Wait ( 0 0$44 ) ;
8788: LD_INT 1540
8790: PPUSH
8791: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8795: LD_EXP 5
8799: PPUSH
8800: LD_INT 3
8802: PPUSH
8803: LD_INT 0
8805: PPUSH
8806: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8810: LD_EXP 5
8814: PPUSH
8815: CALL_OW 87
// Wait ( 0 0$10 ) ;
8819: LD_INT 350
8821: PPUSH
8822: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8826: LD_INT 6
8828: PUSH
8829: LD_INT 7
8831: PUSH
8832: LD_INT 8
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: LIST
8839: PUSH
8840: LD_EXP 1
8844: ARRAY
8845: PPUSH
8846: CALL 7970 0 1
// Wait ( 2 2$00 ) ;
8850: LD_INT 4200
8852: PPUSH
8853: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8857: LD_INT 33
8859: PUSH
8860: LD_INT 2
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: LD_INT 3
8869: PUSH
8870: LD_INT 34
8872: PUSH
8873: LD_INT 13
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PPUSH
8888: CALL_OW 69
8892: PUSH
8893: LD_INT 3
8895: LESS
8896: IFFALSE 8907
// Wait ( 0 0$01 ) ;
8898: LD_INT 35
8900: PPUSH
8901: CALL_OW 67
8905: GO 8857
// uc_side := 4 ;
8907: LD_ADDR_OWVAR 20
8911: PUSH
8912: LD_INT 4
8914: ST_TO_ADDR
// uc_nation := 1 ;
8915: LD_ADDR_OWVAR 21
8919: PUSH
8920: LD_INT 1
8922: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8923: LD_ADDR_VAR 0 1
8927: PUSH
8928: DOUBLE
8929: LD_INT 1
8931: DEC
8932: ST_TO_ADDR
8933: LD_INT 4
8935: PUSH
8936: LD_INT 5
8938: PUSH
8939: LD_INT 6
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: PUSH
8947: LD_EXP 1
8951: ARRAY
8952: PUSH
8953: FOR_TO
8954: IFFALSE 8996
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8956: LD_INT 1
8958: PPUSH
8959: LD_INT 5
8961: PUSH
8962: LD_INT 6
8964: PUSH
8965: LD_INT 7
8967: PUSH
8968: EMPTY
8969: LIST
8970: LIST
8971: LIST
8972: PUSH
8973: LD_EXP 1
8977: ARRAY
8978: PPUSH
8979: CALL 819 0 2
8983: PPUSH
8984: LD_INT 4
8986: PPUSH
8987: LD_INT 0
8989: PPUSH
8990: CALL_OW 49
8994: GO 8953
8996: POP
8997: POP
// sikorski_ar := true ;
8998: LD_ADDR_EXP 12
9002: PUSH
9003: LD_INT 1
9005: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9006: LD_EXP 9
9010: PPUSH
9011: LD_STRING DSik1
9013: PPUSH
9014: CALL_OW 94
// Wait ( 0 0$30 ) ;
9018: LD_INT 1050
9020: PPUSH
9021: CALL_OW 67
// uc_side := 4 ;
9025: LD_ADDR_OWVAR 20
9029: PUSH
9030: LD_INT 4
9032: ST_TO_ADDR
// uc_nation := 1 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 1
9040: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9041: LD_ADDR_VAR 0 1
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 3
9053: PUSH
9054: LD_INT 4
9056: PUSH
9057: LD_INT 4
9059: PUSH
9060: EMPTY
9061: LIST
9062: LIST
9063: LIST
9064: PUSH
9065: LD_EXP 1
9069: ARRAY
9070: PUSH
9071: FOR_TO
9072: IFFALSE 9114
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9074: LD_INT 1
9076: PPUSH
9077: LD_INT 5
9079: PUSH
9080: LD_INT 6
9082: PUSH
9083: LD_INT 7
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: LIST
9090: PUSH
9091: LD_EXP 1
9095: ARRAY
9096: PPUSH
9097: CALL 819 0 2
9101: PPUSH
9102: LD_INT 13
9104: PPUSH
9105: LD_INT 0
9107: PPUSH
9108: CALL_OW 49
9112: GO 9071
9114: POP
9115: POP
// end ;
9116: PPOPN 1
9118: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9119: LD_EXP 9
9123: PPUSH
9124: CALL_OW 256
9128: PUSH
9129: LD_INT 650
9131: LESS
9132: IFFALSE 9214
9134: GO 9136
9136: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9137: LD_EXP 9
9141: PPUSH
9142: LD_STRING DSik2
9144: PPUSH
9145: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9149: LD_EXP 9
9153: PPUSH
9154: CALL_OW 300
9158: IFFALSE 9214
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9160: LD_EXP 9
9164: PPUSH
9165: LD_INT 2
9167: PPUSH
9168: CALL_OW 113
// Wait ( 0 0$01 ) ;
9172: LD_INT 35
9174: PPUSH
9175: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9179: LD_EXP 9
9183: PPUSH
9184: LD_INT 2
9186: PPUSH
9187: CALL_OW 308
9191: IFFALSE 9212
// begin RemoveUnit ( sikorski ) ;
9193: LD_EXP 9
9197: PPUSH
9198: CALL_OW 64
// break ;
9202: GO 9214
// sikorski_run := true ;
9204: LD_ADDR_EXP 23
9208: PUSH
9209: LD_INT 1
9211: ST_TO_ADDR
// end ; end ;
9212: GO 9149
// end ;
9214: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9215: LD_EXP 9
9219: PPUSH
9220: CALL_OW 256
9224: PUSH
9225: LD_INT 1000
9227: LESS
9228: IFFALSE 9245
9230: GO 9232
9232: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9233: LD_EXP 9
9237: PPUSH
9238: LD_STRING DSkik3
9240: PPUSH
9241: CALL_OW 88
9245: END
// every 1 1$45 + 0 0$15 do
9246: GO 9248
9248: DISABLE
// begin enable ;
9249: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9250: LD_INT 1
9252: PPUSH
9253: LD_INT 5
9255: PPUSH
9256: CALL_OW 12
9260: PPUSH
9261: LD_INT 8
9263: PPUSH
9264: LD_INT 1
9266: PPUSH
9267: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9271: LD_INT 350
9273: PPUSH
9274: LD_INT 1295
9276: PPUSH
9277: CALL_OW 12
9281: PPUSH
9282: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9286: LD_INT 1
9288: PPUSH
9289: LD_INT 5
9291: PPUSH
9292: CALL_OW 12
9296: PPUSH
9297: LD_INT 1
9299: PPUSH
9300: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9304: LD_INT 350
9306: PPUSH
9307: LD_INT 1050
9309: PPUSH
9310: CALL_OW 12
9314: PPUSH
9315: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9319: LD_EXP 24
9323: PUSH
9324: LD_INT 25200
9326: PUSH
9327: LD_INT 23100
9329: PUSH
9330: LD_INT 21000
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: LIST
9337: PUSH
9338: LD_EXP 1
9342: ARRAY
9343: LESSEQUAL
9344: IFFALSE 9367
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9346: LD_INT 1
9348: PPUSH
9349: LD_INT 5
9351: PPUSH
9352: CALL_OW 12
9356: PPUSH
9357: LD_INT 8
9359: PPUSH
9360: LD_INT 1
9362: PPUSH
9363: CALL_OW 55
// end ;
9367: END
// export timer ; every 1 do
9368: GO 9370
9370: DISABLE
// timer := 0 0$00 ;
9371: LD_ADDR_EXP 24
9375: PUSH
9376: LD_INT 0
9378: ST_TO_ADDR
9379: END
// every 0 0$01 do
9380: GO 9382
9382: DISABLE
// begin enable ;
9383: ENABLE
// Display_Strings := [ #tick , timer ] ;
9384: LD_ADDR_OWVAR 47
9388: PUSH
9389: LD_STRING #tick
9391: PUSH
9392: LD_EXP 24
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9401: LD_ADDR_EXP 24
9405: PUSH
9406: LD_EXP 24
9410: PUSH
9411: LD_INT 35
9413: PLUS
9414: ST_TO_ADDR
// end ;
9415: END
