// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8608 0 0
// PrepareAmerican ;
 100: CALL 5228 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3263: LD_VAR 0 1
3267: PUSH
3268: LD_EXP 17
3272: IN
3273: IFFALSE 3291
// Patrol := Patrol diff un ;
3275: LD_ADDR_EXP 17
3279: PUSH
3280: LD_EXP 17
3284: PUSH
3285: LD_VAR 0 1
3289: DIFF
3290: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3291: LD_VAR 0 1
3295: PUSH
3296: LD_INT 22
3298: PUSH
3299: LD_INT 1
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PUSH
3306: LD_INT 30
3308: PUSH
3309: LD_INT 32
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PPUSH
3320: CALL_OW 69
3324: IN
3325: IFFALSE 3411
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3327: LD_ADDR_EXP 18
3331: PUSH
3332: LD_EXP 18
3336: PUSH
3337: LD_VAR 0 1
3341: PPUSH
3342: CALL_OW 250
3346: ADD
3347: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3348: LD_ADDR_EXP 18
3352: PUSH
3353: LD_EXP 18
3357: PUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: CALL_OW 251
3367: ADD
3368: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3369: LD_ADDR_EXP 18
3373: PUSH
3374: LD_EXP 18
3378: PUSH
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 254
3388: ADD
3389: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3390: LD_ADDR_EXP 18
3394: PUSH
3395: LD_EXP 18
3399: PUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 269
3409: ADD
3410: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3411: LD_VAR 0 1
3415: PUSH
3416: LD_INT 33
3418: PUSH
3419: LD_INT 2
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 34
3431: PUSH
3432: LD_INT 13
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PPUSH
3447: CALL_OW 69
3451: IN
3452: IFFALSE 3468
// new_veh := new_veh + 1 ;
3454: LD_ADDR_EXP 19
3458: PUSH
3459: LD_EXP 19
3463: PUSH
3464: LD_INT 1
3466: PLUS
3467: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3468: LD_VAR 0 1
3472: PUSH
3473: LD_INT 34
3475: PUSH
3476: LD_INT 13
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: PPUSH
3483: CALL_OW 69
3487: IN
3488: IFFALSE 3509
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3490: LD_INT 26
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 2
3498: PPUSH
3499: LD_INT 2
3501: PPUSH
3502: LD_INT 13
3504: PPUSH
3505: CALL_OW 185
// if un = am_dep then
3509: LD_VAR 0 1
3513: PUSH
3514: LD_INT 25
3516: EQUAL
3517: IFFALSE 3685
// begin SayRadio ( Platonov , DPlat ) ;
3519: LD_EXP 4
3523: PPUSH
3524: LD_STRING DPlat
3526: PPUSH
3527: CALL_OW 94
// if timer <= 30 30$00 then
3531: LD_EXP 24
3535: PUSH
3536: LD_INT 63000
3538: LESSEQUAL
3539: IFFALSE 3553
// AddMedal ( gamma_med3 , 1 ) else
3541: LD_STRING gamma_med3
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 101
3551: GO 3603
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3553: LD_EXP 24
3557: PUSH
3558: LD_INT 105000
3560: PUSH
3561: LD_INT 88200
3563: PUSH
3564: LD_INT 73500
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: LIST
3571: PUSH
3572: LD_EXP 1
3576: ARRAY
3577: LESSEQUAL
3578: IFFALSE 3592
// AddMedal ( gamma_med3 , 2 ) else
3580: LD_STRING gamma_med3
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 101
3590: GO 3603
// AddMedal ( gamma_med3 , - 1 ) ;
3592: LD_STRING gamma_med3
3594: PPUSH
3595: LD_INT 1
3597: NEG
3598: PPUSH
3599: CALL_OW 101
// if not comp_tested then
3603: LD_EXP 22
3607: NOT
3608: IFFALSE 3623
// AddMedal ( gamma_med2 , - 1 ) else
3610: LD_STRING gamma_med2
3612: PPUSH
3613: LD_INT 1
3615: NEG
3616: PPUSH
3617: CALL_OW 101
3621: GO 3633
// AddMedal ( gamma_med2 , 1 ) ;
3623: LD_STRING gamma_med2
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3633: LD_EXP 9
3637: PPUSH
3638: CALL_OW 301
3642: PUSH
3643: LD_EXP 23
3647: NOT
3648: AND
3649: IFFALSE 3663
// AddMedal ( gamma_med1 , 1 ) else
3651: LD_STRING gamma_med1
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: CALL_OW 101
3661: GO 3674
// AddMedal ( gamma_med1 , - 1 ) ;
3663: LD_STRING gamma_med1
3665: PPUSH
3666: LD_INT 1
3668: NEG
3669: PPUSH
3670: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3674: LD_STRING GAMMA_MEDALS
3676: PPUSH
3677: CALL_OW 102
// YouWin ;
3681: CALL_OW 103
// end ; if un = commander then
3685: LD_VAR 0 1
3689: PUSH
3690: LD_EXP 3
3694: EQUAL
3695: IFFALSE 3704
// YouLost ( comml ) ;
3697: LD_STRING comml
3699: PPUSH
3700: CALL_OW 104
// if un = sikorski then
3704: LD_VAR 0 1
3708: PUSH
3709: LD_EXP 9
3713: EQUAL
3714: IFFALSE 3726
// AddMedal ( gamma_med1 , 1 ) ;
3716: LD_STRING gamma_med1
3718: PPUSH
3719: LD_INT 1
3721: PPUSH
3722: CALL_OW 101
// end ;
3726: PPOPN 1
3728: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3729: LD_INT 0
3731: PPUSH
3732: PPUSH
3733: PPUSH
3734: PPUSH
3735: PPUSH
3736: PPUSH
3737: PPUSH
3738: PPUSH
3739: PPUSH
// begin if event = 1 then
3740: LD_VAR 0 1
3744: PUSH
3745: LD_INT 1
3747: EQUAL
3748: IFFALSE 4045
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3750: LD_ADDR_VAR 0 4
3754: PUSH
3755: LD_INT 22
3757: PUSH
3758: LD_INT 1
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 21
3767: PUSH
3768: LD_INT 3
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 3
3777: PUSH
3778: LD_INT 24
3780: PUSH
3781: LD_INT 1000
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: LIST
3796: PPUSH
3797: CALL_OW 69
3801: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_INT 22
3809: PUSH
3810: LD_INT 1
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_INT 25
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 24
3829: PUSH
3830: LD_INT 1000
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: PPUSH
3845: CALL_OW 69
3849: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3850: LD_ADDR_VAR 0 9
3854: PUSH
3855: LD_INT 22
3857: PUSH
3858: LD_INT 1
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 34
3867: PUSH
3868: LD_INT 13
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL_OW 69
3883: ST_TO_ADDR
// if engs > 0 then
3884: LD_VAR 0 8
3888: PUSH
3889: LD_INT 0
3891: GREATER
3892: IFFALSE 3997
// for i = 1 to engs do
3894: LD_ADDR_VAR 0 2
3898: PUSH
3899: DOUBLE
3900: LD_INT 1
3902: DEC
3903: ST_TO_ADDR
3904: LD_VAR 0 8
3908: PUSH
3909: FOR_TO
3910: IFFALSE 3995
// begin if IsInUnit ( engs [ i ] ) then
3912: LD_VAR 0 8
3916: PUSH
3917: LD_VAR 0 2
3921: ARRAY
3922: PPUSH
3923: CALL_OW 310
3927: IFFALSE 3944
// ComExitBuilding ( engs [ i ] ) ;
3929: LD_VAR 0 8
3933: PUSH
3934: LD_VAR 0 2
3938: ARRAY
3939: PPUSH
3940: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3944: LD_INT 7
3946: PPUSH
3947: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3951: LD_VAR 0 8
3955: PUSH
3956: LD_VAR 0 2
3960: ARRAY
3961: PPUSH
3962: CALL_OW 314
3966: NOT
3967: IFFALSE 3993
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3969: LD_VAR 0 8
3973: PUSH
3974: LD_VAR 0 2
3978: ARRAY
3979: PPUSH
3980: LD_VAR 0 4
3984: PUSH
3985: LD_INT 1
3987: ARRAY
3988: PPUSH
3989: CALL_OW 130
// end ;
3993: GO 3909
3995: POP
3996: POP
// if crane > 0 then
3997: LD_VAR 0 9
4001: PUSH
4002: LD_INT 0
4004: GREATER
4005: IFFALSE 4045
// if not HasTask ( crane [ 1 ] ) then
4007: LD_VAR 0 9
4011: PUSH
4012: LD_INT 1
4014: ARRAY
4015: PPUSH
4016: CALL_OW 314
4020: NOT
4021: IFFALSE 4045
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4023: LD_VAR 0 9
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_VAR 0 4
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: CALL_OW 130
// end ; if event = 2 then
4045: LD_VAR 0 1
4049: PUSH
4050: LD_INT 2
4052: EQUAL
4053: IFFALSE 4175
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4055: LD_ADDR_VAR 0 8
4059: PUSH
4060: LD_INT 22
4062: PUSH
4063: LD_INT 1
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: LD_INT 25
4072: PUSH
4073: LD_INT 2
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 69
4088: ST_TO_ADDR
// if engs > 0 then
4089: LD_VAR 0 8
4093: PUSH
4094: LD_INT 0
4096: GREATER
4097: IFFALSE 4175
// for i = 1 to engs do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_VAR 0 8
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4173
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4117: LD_VAR 0 8
4121: PUSH
4122: LD_VAR 0 2
4126: ARRAY
4127: PPUSH
4128: CALL_OW 314
4132: NOT
4133: PUSH
4134: LD_VAR 0 8
4138: PUSH
4139: LD_VAR 0 2
4143: ARRAY
4144: PPUSH
4145: CALL_OW 310
4149: NOT
4150: AND
4151: IFFALSE 4171
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4153: LD_VAR 0 8
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PPUSH
4164: LD_INT 25
4166: PPUSH
4167: CALL_OW 120
4171: GO 4114
4173: POP
4174: POP
// end ; if event = 3 then
4175: LD_VAR 0 1
4179: PUSH
4180: LD_INT 3
4182: EQUAL
4183: IFFALSE 4547
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 1
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 25
4215: PUSH
4216: LD_INT 4
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: LD_INT 24
4232: PUSH
4233: LD_INT 800
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: PPUSH
4253: CALL_OW 69
4257: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4258: LD_ADDR_VAR 0 5
4262: PUSH
4263: LD_INT 22
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PUSH
4273: LD_INT 25
4275: PUSH
4276: LD_INT 4
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: ST_TO_ADDR
// if filter > 0 then
4292: LD_VAR 0 4
4296: PUSH
4297: LD_INT 0
4299: GREATER
4300: IFFALSE 4489
// begin for i = 1 to doc do
4302: LD_ADDR_VAR 0 2
4306: PUSH
4307: DOUBLE
4308: LD_INT 1
4310: DEC
4311: ST_TO_ADDR
4312: LD_VAR 0 5
4316: PUSH
4317: FOR_TO
4318: IFFALSE 4418
// begin if IsInUnit ( doc [ i ] ) then
4320: LD_VAR 0 5
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PPUSH
4331: CALL_OW 310
4335: IFFALSE 4352
// ComExitBuilding ( doc [ i ] ) ;
4337: LD_VAR 0 5
4341: PUSH
4342: LD_VAR 0 2
4346: ARRAY
4347: PPUSH
4348: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 1
4359: ARRAY
4360: PPUSH
4361: LD_INT 46
4363: PPUSH
4364: CALL_OW 296
4368: PUSH
4369: LD_INT 10
4371: LESS
4372: PUSH
4373: LD_VAR 0 5
4377: PUSH
4378: LD_VAR 0 2
4382: ARRAY
4383: PPUSH
4384: CALL_OW 314
4388: NOT
4389: AND
4390: IFFALSE 4416
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4392: LD_VAR 0 5
4396: PUSH
4397: LD_VAR 0 2
4401: ARRAY
4402: PPUSH
4403: LD_VAR 0 4
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 128
// end ;
4416: GO 4317
4418: POP
4419: POP
// for i = 1 to filter do
4420: LD_ADDR_VAR 0 2
4424: PUSH
4425: DOUBLE
4426: LD_INT 1
4428: DEC
4429: ST_TO_ADDR
4430: LD_VAR 0 4
4434: PUSH
4435: FOR_TO
4436: IFFALSE 4485
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4438: LD_VAR 0 4
4442: PUSH
4443: LD_VAR 0 2
4447: ARRAY
4448: PPUSH
4449: LD_INT 46
4451: PPUSH
4452: CALL_OW 296
4456: PUSH
4457: LD_INT 10
4459: GREATER
4460: IFFALSE 4483
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 2
4471: ARRAY
4472: PPUSH
4473: LD_INT 47
4475: PPUSH
4476: LD_INT 12
4478: PPUSH
4479: CALL_OW 111
4483: GO 4435
4485: POP
4486: POP
// end else
4487: GO 4547
// for i = 1 to doc do
4489: LD_ADDR_VAR 0 2
4493: PUSH
4494: DOUBLE
4495: LD_INT 1
4497: DEC
4498: ST_TO_ADDR
4499: LD_VAR 0 5
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4545
// if not IsInUnit ( doc [ i ] ) then
4507: LD_VAR 0 5
4511: PUSH
4512: LD_VAR 0 2
4516: ARRAY
4517: PPUSH
4518: CALL_OW 310
4522: NOT
4523: IFFALSE 4543
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 2
4534: ARRAY
4535: PPUSH
4536: LD_INT 46
4538: PPUSH
4539: CALL_OW 120
4543: GO 4504
4545: POP
4546: POP
// end ; if event = 4 then
4547: LD_VAR 0 1
4551: PUSH
4552: LD_INT 4
4554: EQUAL
4555: IFFALSE 4806
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4557: LD_ADDR_VAR 0 6
4561: PUSH
4562: LD_INT 22
4564: PUSH
4565: LD_INT 1
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 30
4574: PUSH
4575: LD_INT 5
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL_OW 69
4590: ST_TO_ADDR
// for i = 1 to bac do
4591: LD_ADDR_VAR 0 2
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_VAR 0 6
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4648
// if UnitsInside ( bac [ i ] ) < 6 then
4609: LD_VAR 0 6
4613: PUSH
4614: LD_VAR 0 2
4618: ARRAY
4619: PPUSH
4620: CALL_OW 313
4624: PUSH
4625: LD_INT 6
4627: LESS
4628: IFFALSE 4646
// place := bac [ i ] ;
4630: LD_ADDR_VAR 0 7
4634: PUSH
4635: LD_VAR 0 6
4639: PUSH
4640: LD_VAR 0 2
4644: ARRAY
4645: ST_TO_ADDR
4646: GO 4606
4648: POP
4649: POP
// if place then
4650: LD_VAR 0 7
4654: IFFALSE 4806
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4656: LD_ADDR_VAR 0 4
4660: PUSH
4661: LD_INT 22
4663: PUSH
4664: LD_INT 1
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 2
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 25
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 24
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_EXP 17
4726: DIFF
4727: ST_TO_ADDR
// for i = 1 to filter do
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: DOUBLE
4734: LD_INT 1
4736: DEC
4737: ST_TO_ADDR
4738: LD_VAR 0 4
4742: PUSH
4743: FOR_TO
4744: IFFALSE 4804
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4746: LD_VAR 0 4
4750: PUSH
4751: LD_VAR 0 2
4755: ARRAY
4756: PPUSH
4757: CALL_OW 310
4761: NOT
4762: PUSH
4763: LD_VAR 0 4
4767: PUSH
4768: LD_VAR 0 2
4772: ARRAY
4773: PPUSH
4774: CALL_OW 314
4778: NOT
4779: AND
4780: IFFALSE 4802
// ComEnterUnit ( filter [ i ] , place ) ;
4782: LD_VAR 0 4
4786: PUSH
4787: LD_VAR 0 2
4791: ARRAY
4792: PPUSH
4793: LD_VAR 0 7
4797: PPUSH
4798: CALL_OW 120
4802: GO 4743
4804: POP
4805: POP
// end ; end ; if event = 5 then
4806: LD_VAR 0 1
4810: PUSH
4811: LD_INT 5
4813: EQUAL
4814: IFFALSE 4968
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4816: LD_INT 12
4818: PPUSH
4819: LD_INT 81
4821: PUSH
4822: LD_INT 1
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PPUSH
4829: CALL_OW 70
4833: PUSH
4834: LD_INT 0
4836: EQUAL
4837: IFFALSE 4968
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4839: LD_ADDR_VAR 0 8
4843: PUSH
4844: LD_INT 22
4846: PUSH
4847: LD_INT 1
4849: PUSH
4850: EMPTY
4851: LIST
4852: LIST
4853: PUSH
4854: LD_INT 25
4856: PUSH
4857: LD_INT 2
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PPUSH
4868: CALL_OW 69
4872: ST_TO_ADDR
// if engs > 0 then
4873: LD_VAR 0 8
4877: PUSH
4878: LD_INT 0
4880: GREATER
4881: IFFALSE 4968
// for i = 1 to engs do
4883: LD_ADDR_VAR 0 2
4887: PUSH
4888: DOUBLE
4889: LD_INT 1
4891: DEC
4892: ST_TO_ADDR
4893: LD_VAR 0 8
4897: PUSH
4898: FOR_TO
4899: IFFALSE 4966
// if not HasTask ( engs [ i ] ) then
4901: LD_VAR 0 8
4905: PUSH
4906: LD_VAR 0 2
4910: ARRAY
4911: PPUSH
4912: CALL_OW 314
4916: NOT
4917: IFFALSE 4964
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4919: LD_VAR 0 8
4923: PUSH
4924: LD_VAR 0 2
4928: ARRAY
4929: PPUSH
4930: LD_INT 32
4932: PPUSH
4933: LD_EXP 18
4937: PUSH
4938: LD_INT 1
4940: ARRAY
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 2
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 3
4958: ARRAY
4959: PPUSH
4960: CALL_OW 145
4964: GO 4898
4966: POP
4967: POP
// end ; end ; if event = 6 then
4968: LD_VAR 0 1
4972: PUSH
4973: LD_INT 6
4975: EQUAL
4976: IFFALSE 5160
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4978: LD_ADDR_VAR 0 6
4982: PUSH
4983: LD_INT 22
4985: PUSH
4986: LD_INT 1
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 69
5011: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5012: LD_VAR 0 6
5016: PUSH
5017: LD_INT 22
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 32
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 58
5039: PUSH
5040: EMPTY
5041: LIST
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 0
5058: GREATER
5059: AND
5060: IFFALSE 5160
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5062: LD_ADDR_VAR 0 10
5066: PUSH
5067: LD_INT 22
5069: PUSH
5070: LD_INT 1
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: LD_INT 30
5079: PUSH
5080: LD_INT 32
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 58
5089: PUSH
5090: EMPTY
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: EMPTY
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: PUSH
5106: LD_INT 1
5108: ARRAY
5109: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5110: LD_ADDR_VAR 0 3
5114: PUSH
5115: LD_VAR 0 6
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: CALL_OW 313
5128: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5129: LD_VAR 0 3
5133: PUSH
5134: LD_INT 1
5136: ARRAY
5137: PPUSH
5138: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: ARRAY
5150: PPUSH
5151: LD_VAR 0 10
5155: PPUSH
5156: CALL_OW 180
// end ; end ; end ;
5160: PPOPN 10
5162: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5163: LD_VAR 0 1
5167: PUSH
5168: LD_INT 1
5170: EQUAL
5171: PUSH
5172: LD_VAR 0 2
5176: PUSH
5177: LD_INT 3
5179: EQUAL
5180: AND
5181: IFFALSE 5191
// contact_am := true ;
5183: LD_ADDR_EXP 16
5187: PUSH
5188: LD_INT 1
5190: ST_TO_ADDR
// end ;
5191: PPOPN 2
5193: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5194: LD_VAR 0 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PPUSH
5204: LD_VAR 0 3
5208: PPUSH
5209: CALL 20197 0 3
// end ;
5213: PPOPN 3
5215: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5216: LD_VAR 0 1
5220: PPUSH
5221: CALL 20295 0 1
// end ; end_of_file
5225: PPOPN 1
5227: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5228: LD_INT 0
5230: PPUSH
5231: PPUSH
5232: PPUSH
5233: PPUSH
5234: PPUSH
5235: PPUSH
5236: PPUSH
5237: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5238: LD_ADDR_VAR 0 5
5242: PUSH
5243: LD_INT 5
5245: PUSH
5246: LD_INT 6
5248: PUSH
5249: LD_INT 7
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_EXP 1
5261: ARRAY
5262: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5263: LD_ADDR_VAR 0 6
5267: PUSH
5268: LD_INT 4
5270: PUSH
5271: LD_INT 4
5273: PUSH
5274: LD_INT 4
5276: PUSH
5277: LD_INT 5
5279: PUSH
5280: LD_INT 5
5282: PUSH
5283: LD_INT 5
5285: PUSH
5286: LD_INT 6
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: LIST
5297: ST_TO_ADDR
// SForce := [ ] ;
5298: LD_ADDR_EXP 11
5302: PUSH
5303: EMPTY
5304: ST_TO_ADDR
// Sikorski_Ar := false ;
5305: LD_ADDR_EXP 12
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// attacked := false ;
5313: LD_ADDR_EXP 15
5317: PUSH
5318: LD_INT 0
5320: ST_TO_ADDR
// contact_am := false ;
5321: LD_ADDR_EXP 16
5325: PUSH
5326: LD_INT 0
5328: ST_TO_ADDR
// patrol := [ ] ;
5329: LD_ADDR_EXP 17
5333: PUSH
5334: EMPTY
5335: ST_TO_ADDR
// gamma_towers := [ ] ;
5336: LD_ADDR_EXP 18
5340: PUSH
5341: EMPTY
5342: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5343: LD_INT 25
5345: PPUSH
5346: LD_STRING gamma
5348: PPUSH
5349: CALL_OW 500
// uc_side := 1 ;
5353: LD_ADDR_OWVAR 20
5357: PUSH
5358: LD_INT 1
5360: ST_TO_ADDR
// uc_nation := 1 ;
5361: LD_ADDR_OWVAR 21
5365: PUSH
5366: LD_INT 1
5368: ST_TO_ADDR
// hc_importance := 0 ;
5369: LD_ADDR_OWVAR 32
5373: PUSH
5374: LD_INT 0
5376: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5377: LD_ADDR_OWVAR 26
5381: PUSH
5382: LD_STRING Jeremy Sikorski
5384: ST_TO_ADDR
// hc_gallery := us ;
5385: LD_ADDR_OWVAR 33
5389: PUSH
5390: LD_STRING us
5392: ST_TO_ADDR
// hc_face_number := 19 ;
5393: LD_ADDR_OWVAR 34
5397: PUSH
5398: LD_INT 19
5400: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5401: LD_ADDR_OWVAR 31
5405: PUSH
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_VAR 0 5
5415: PUSH
5416: LD_INT 2
5418: PLUS
5419: PPUSH
5420: CALL_OW 12
5424: PUSH
5425: LD_INT 4
5427: PUSH
5428: LD_INT 6
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: ST_TO_ADDR
// hc_sex := sex_male ;
5440: LD_ADDR_OWVAR 27
5444: PUSH
5445: LD_INT 1
5447: ST_TO_ADDR
// hc_class := 1 ;
5448: LD_ADDR_OWVAR 28
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5456: LD_ADDR_OWVAR 29
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: ST_TO_ADDR
// sikorski := CreateHuman ;
5471: LD_ADDR_EXP 9
5475: PUSH
5476: CALL_OW 44
5480: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5481: LD_ADDR_OWVAR 26
5485: PUSH
5486: LD_STRING Lucy Donaldson
5488: ST_TO_ADDR
// hc_gallery := us ;
5489: LD_ADDR_OWVAR 33
5493: PUSH
5494: LD_STRING us
5496: ST_TO_ADDR
// hc_face_number := 2 ;
5497: LD_ADDR_OWVAR 34
5501: PUSH
5502: LD_INT 2
5504: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5505: LD_ADDR_OWVAR 31
5509: PUSH
5510: LD_VAR 0 5
5514: PPUSH
5515: LD_VAR 0 5
5519: PUSH
5520: LD_INT 2
5522: PLUS
5523: PPUSH
5524: CALL_OW 12
5528: PUSH
5529: LD_INT 6
5531: PUSH
5532: LD_INT 4
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: ST_TO_ADDR
// hc_sex := sex_female ;
5544: LD_ADDR_OWVAR 27
5548: PUSH
5549: LD_INT 2
5551: ST_TO_ADDR
// hc_class := 1 ;
5552: LD_ADDR_OWVAR 28
5556: PUSH
5557: LD_INT 1
5559: ST_TO_ADDR
// donald := CreateHuman ;
5560: LD_ADDR_EXP 13
5564: PUSH
5565: CALL_OW 44
5569: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5570: LD_ADDR_OWVAR 26
5574: PUSH
5575: LD_STRING Peter Van Houten
5577: ST_TO_ADDR
// hc_gallery := us ;
5578: LD_ADDR_OWVAR 33
5582: PUSH
5583: LD_STRING us
5585: ST_TO_ADDR
// hc_face_number := 16 ;
5586: LD_ADDR_OWVAR 34
5590: PUSH
5591: LD_INT 16
5593: ST_TO_ADDR
// hc_sex := sex_male ;
5594: LD_ADDR_OWVAR 27
5598: PUSH
5599: LD_INT 1
5601: ST_TO_ADDR
// van := CreateHuman ;
5602: LD_ADDR_EXP 14
5606: PUSH
5607: CALL_OW 44
5611: ST_TO_ADDR
// hc_importance := 0 ;
5612: LD_ADDR_OWVAR 32
5616: PUSH
5617: LD_INT 0
5619: ST_TO_ADDR
// case dif of 1 :
5620: LD_EXP 1
5624: PUSH
5625: LD_INT 1
5627: DOUBLE
5628: EQUAL
5629: IFTRUE 5633
5631: GO 5644
5633: POP
// lw = 1 ; 2 :
5634: LD_ADDR_VAR 0 8
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
5642: GO 5691
5644: LD_INT 2
5646: DOUBLE
5647: EQUAL
5648: IFTRUE 5652
5650: GO 5671
5652: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5653: LD_ADDR_VAR 0 8
5657: PUSH
5658: LD_INT 1
5660: PPUSH
5661: LD_INT 2
5663: PPUSH
5664: CALL_OW 12
5668: ST_TO_ADDR
5669: GO 5691
5671: LD_INT 3
5673: DOUBLE
5674: EQUAL
5675: IFTRUE 5679
5677: GO 5690
5679: POP
// lw = 2 ; end ;
5680: LD_ADDR_VAR 0 8
5684: PUSH
5685: LD_INT 2
5687: ST_TO_ADDR
5688: GO 5691
5690: POP
// case lw of 1 :
5691: LD_VAR 0 8
5695: PUSH
5696: LD_INT 1
5698: DOUBLE
5699: EQUAL
5700: IFTRUE 5704
5702: GO 5719
5704: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5705: LD_EXP 13
5709: PPUSH
5710: LD_INT 25
5712: PPUSH
5713: CALL_OW 52
5717: GO 5743
5719: LD_INT 2
5721: DOUBLE
5722: EQUAL
5723: IFTRUE 5727
5725: GO 5742
5727: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5728: LD_EXP 14
5732: PPUSH
5733: LD_INT 25
5735: PPUSH
5736: CALL_OW 52
5740: GO 5743
5742: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5743: LD_ADDR_VAR 0 2
5747: PUSH
5748: LD_INT 22
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 30
5760: PUSH
5761: LD_INT 32
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PPUSH
5772: CALL_OW 69
5776: PUSH
5777: FOR_IN
5778: IFFALSE 5832
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5780: LD_INT 1
5782: PPUSH
5783: LD_VAR 0 5
5787: PPUSH
5788: CALL 734 0 2
5792: PPUSH
5793: LD_VAR 0 2
5797: PPUSH
5798: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PUSH
5812: LD_INT 1
5814: PPUSH
5815: LD_VAR 0 6
5819: PPUSH
5820: CALL_OW 12
5824: ARRAY
5825: PPUSH
5826: CALL_OW 431
// end ;
5830: GO 5777
5832: POP
5833: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5834: LD_ADDR_VAR 0 7
5838: PUSH
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 2
5851: PUSH
5852: LD_INT 25
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 5
5864: PUSH
5865: EMPTY
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: PPUSH
5877: CALL_OW 69
5881: ST_TO_ADDR
// for i = 1 to sol do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_VAR 0 7
5896: PUSH
5897: FOR_TO
5898: IFFALSE 5920
// SetTag ( sol [ i ] , 1 ) ;
5900: LD_VAR 0 7
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PPUSH
5911: LD_INT 1
5913: PPUSH
5914: CALL_OW 109
5918: GO 5897
5920: POP
5921: POP
// for i = 1 to 3 do
5922: LD_ADDR_VAR 0 2
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_INT 3
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5960
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: CALL 734 0 2
5950: PPUSH
5951: LD_INT 56
5953: PPUSH
5954: CALL_OW 52
5958: GO 5935
5960: POP
5961: POP
// for i = 1 to 6 do
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: DOUBLE
5968: LD_INT 1
5970: DEC
5971: ST_TO_ADDR
5972: LD_INT 6
5974: PUSH
5975: FOR_TO
5976: IFFALSE 6000
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5978: LD_INT 3
5980: PPUSH
5981: LD_VAR 0 5
5985: PPUSH
5986: CALL 734 0 2
5990: PPUSH
5991: LD_INT 26
5993: PPUSH
5994: CALL_OW 52
5998: GO 5975
6000: POP
6001: POP
// for i = 1 to 5 do
6002: LD_ADDR_VAR 0 2
6006: PUSH
6007: DOUBLE
6008: LD_INT 1
6010: DEC
6011: ST_TO_ADDR
6012: LD_INT 5
6014: PUSH
6015: FOR_TO
6016: IFFALSE 6043
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6018: LD_INT 2
6020: PPUSH
6021: LD_VAR 0 5
6025: PPUSH
6026: CALL 734 0 2
6030: PPUSH
6031: LD_INT 7
6033: PPUSH
6034: LD_INT 0
6036: PPUSH
6037: CALL_OW 49
6041: GO 6015
6043: POP
6044: POP
// for i = 1 to 3 do
6045: LD_ADDR_VAR 0 2
6049: PUSH
6050: DOUBLE
6051: LD_INT 1
6053: DEC
6054: ST_TO_ADDR
6055: LD_INT 3
6057: PUSH
6058: FOR_TO
6059: IFFALSE 6083
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6061: LD_INT 4
6063: PPUSH
6064: LD_VAR 0 5
6068: PPUSH
6069: CALL 734 0 2
6073: PPUSH
6074: LD_INT 46
6076: PPUSH
6077: CALL_OW 52
6081: GO 6058
6083: POP
6084: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 1
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 30
6102: PUSH
6103: LD_INT 5
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: PUSH
6119: FOR_IN
6120: IFFALSE 6234
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6122: LD_INT 5
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL 734 0 2
6134: PPUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6144: LD_INT 5
6146: PPUSH
6147: LD_VAR 0 5
6151: PPUSH
6152: CALL 734 0 2
6156: PPUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 5
6173: PPUSH
6174: CALL 734 0 2
6178: PPUSH
6179: LD_VAR 0 2
6183: PPUSH
6184: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6188: LD_INT 1
6190: PPUSH
6191: LD_VAR 0 5
6195: PPUSH
6196: CALL 734 0 2
6200: PPUSH
6201: LD_VAR 0 2
6205: PPUSH
6206: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6210: LD_INT 1
6212: PPUSH
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL 734 0 2
6222: PPUSH
6223: LD_VAR 0 2
6227: PPUSH
6228: CALL_OW 52
// end ;
6232: GO 6119
6234: POP
6235: POP
// if dif > 1 then
6236: LD_EXP 1
6240: PUSH
6241: LD_INT 1
6243: GREATER
6244: IFFALSE 6317
// for i = 1 to ( dif - 1 ) do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_EXP 1
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: PUSH
6265: FOR_TO
6266: IFFALSE 6315
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6268: LD_ADDR_EXP 17
6272: PUSH
6273: LD_EXP 17
6277: PUSH
6278: LD_INT 1
6280: PPUSH
6281: LD_VAR 0 5
6285: PPUSH
6286: CALL 734 0 2
6290: ADD
6291: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6292: LD_EXP 17
6296: PUSH
6297: LD_VAR 0 2
6301: ARRAY
6302: PPUSH
6303: LD_INT 3
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// end ;
6313: GO 6265
6315: POP
6316: POP
// game_started := true ;
6317: LD_ADDR_EXP 10
6321: PUSH
6322: LD_INT 1
6324: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6325: LD_INT 26
6327: PPUSH
6328: LD_INT 3
6330: PPUSH
6331: LD_INT 2
6333: PPUSH
6334: LD_INT 2
6336: PPUSH
6337: LD_INT 13
6339: PPUSH
6340: CALL_OW 125
// while ( contact_am = false ) do
6344: LD_EXP 16
6348: PUSH
6349: LD_INT 0
6351: EQUAL
6352: IFFALSE 6363
// begin Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// end ;
6361: GO 6344
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6363: LD_INT 8400
6365: PUSH
6366: LD_INT 6300
6368: PUSH
6369: LD_INT 5250
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: LD_EXP 1
6381: ARRAY
6382: PPUSH
6383: CALL_OW 67
// case dif of 1 :
6387: LD_EXP 1
6391: PUSH
6392: LD_INT 1
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6575
6400: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6401: LD_INT 26
6403: PPUSH
6404: LD_INT 3
6406: PPUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: LD_INT 5
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 4
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6447: LD_INT 26
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: LD_INT 1
6455: PPUSH
6456: LD_INT 2
6458: PPUSH
6459: LD_INT 4
6461: PUSH
6462: LD_INT 5
6464: PUSH
6465: LD_INT 5
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 1
6475: PPUSH
6476: LD_INT 3
6478: PPUSH
6479: CALL_OW 12
6483: ARRAY
6484: PPUSH
6485: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6489: LD_INT 26
6491: PPUSH
6492: LD_INT 3
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: LD_INT 4
6503: PUSH
6504: LD_INT 5
6506: PUSH
6507: LD_INT 5
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 3
6520: PPUSH
6521: CALL_OW 12
6525: ARRAY
6526: PPUSH
6527: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6531: LD_INT 26
6533: PPUSH
6534: LD_INT 3
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_INT 2
6542: PPUSH
6543: LD_INT 4
6545: PUSH
6546: LD_INT 3
6548: PUSH
6549: LD_INT 5
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 1
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 12
6567: ARRAY
6568: PPUSH
6569: CALL_OW 185
// end ; 2 :
6573: GO 7102
6575: LD_INT 2
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6796
6583: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6584: LD_INT 26
6586: PPUSH
6587: LD_INT 3
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 2
6595: PPUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: LD_INT 5
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 3
6615: PPUSH
6616: CALL_OW 12
6620: ARRAY
6621: PPUSH
6622: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6626: LD_INT 26
6628: PPUSH
6629: LD_INT 3
6631: PPUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 4
6640: PUSH
6641: LD_INT 5
6643: PUSH
6644: LD_INT 5
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 3
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6668: LD_INT 26
6670: PPUSH
6671: LD_INT 3
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: LD_INT 2
6679: PPUSH
6680: LD_INT 4
6682: PUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 5
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 3
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: PPUSH
6706: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6710: LD_INT 26
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 2
6721: PPUSH
6722: LD_INT 4
6724: PUSH
6725: LD_INT 5
6727: PUSH
6728: LD_INT 6
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 1
6738: PPUSH
6739: LD_INT 3
6741: PPUSH
6742: CALL_OW 12
6746: ARRAY
6747: PPUSH
6748: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6752: LD_INT 26
6754: PPUSH
6755: LD_INT 4
6757: PPUSH
6758: LD_INT 1
6760: PPUSH
6761: LD_INT 2
6763: PPUSH
6764: LD_INT 4
6766: PUSH
6767: LD_INT 5
6769: PUSH
6770: LD_INT 6
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: CALL_OW 185
// end ; 3 :
6794: GO 7102
6796: LD_INT 3
6798: DOUBLE
6799: EQUAL
6800: IFTRUE 6804
6802: GO 7101
6804: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6805: LD_INT 26
6807: PPUSH
6808: LD_INT 3
6810: PPUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_INT 2
6816: PPUSH
6817: LD_INT 4
6819: PUSH
6820: LD_INT 5
6822: PUSH
6823: LD_INT 5
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: LD_INT 1
6833: PPUSH
6834: LD_INT 3
6836: PPUSH
6837: CALL_OW 12
6841: ARRAY
6842: PPUSH
6843: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6847: LD_INT 26
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 1
6855: PPUSH
6856: LD_INT 2
6858: PPUSH
6859: LD_INT 4
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 5
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 3
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6889: LD_INT 26
6891: PPUSH
6892: LD_INT 3
6894: PPUSH
6895: LD_INT 1
6897: PPUSH
6898: LD_INT 2
6900: PPUSH
6901: LD_INT 4
6903: PUSH
6904: LD_INT 5
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 1
6917: PPUSH
6918: LD_INT 3
6920: PPUSH
6921: CALL_OW 12
6925: ARRAY
6926: PPUSH
6927: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6931: LD_INT 26
6933: PPUSH
6934: LD_INT 3
6936: PPUSH
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 2
6942: PPUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 5
6948: PUSH
6949: LD_INT 5
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 1
6959: PPUSH
6960: LD_INT 3
6962: PPUSH
6963: CALL_OW 12
6967: ARRAY
6968: PPUSH
6969: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6973: LD_INT 26
6975: PPUSH
6976: LD_INT 4
6978: PPUSH
6979: LD_INT 1
6981: PPUSH
6982: LD_INT 2
6984: PPUSH
6985: LD_INT 4
6987: PUSH
6988: LD_INT 5
6990: PUSH
6991: LD_INT 6
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 1
7001: PPUSH
7002: LD_INT 3
7004: PPUSH
7005: CALL_OW 12
7009: ARRAY
7010: PPUSH
7011: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7015: LD_INT 26
7017: PPUSH
7018: LD_INT 4
7020: PPUSH
7021: LD_INT 1
7023: PPUSH
7024: LD_INT 2
7026: PPUSH
7027: LD_INT 4
7029: PUSH
7030: LD_INT 5
7032: PUSH
7033: LD_INT 6
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: LIST
7040: PUSH
7041: LD_INT 1
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 12
7051: ARRAY
7052: PPUSH
7053: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7057: LD_INT 26
7059: PPUSH
7060: LD_INT 4
7062: PPUSH
7063: LD_INT 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: LD_INT 4
7071: PUSH
7072: LD_INT 5
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 1
7085: PPUSH
7086: LD_INT 3
7088: PPUSH
7089: CALL_OW 12
7093: ARRAY
7094: PPUSH
7095: CALL_OW 185
// end ; end ;
7099: GO 7102
7101: POP
// end ;
7102: LD_VAR 0 1
7106: RET
// every 0 0$01 do var i , filter ;
7107: GO 7109
7109: DISABLE
7110: LD_INT 0
7112: PPUSH
7113: PPUSH
// begin enable ;
7114: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7115: LD_INT 22
7117: PUSH
7118: LD_INT 1
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 25
7127: PUSH
7128: LD_INT 4
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: LD_INT 0
7146: GREATER
7147: IFFALSE 7156
// RaiseSailEvent ( 3 ) ;
7149: LD_INT 3
7151: PPUSH
7152: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7156: LD_INT 22
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 21
7168: PUSH
7169: LD_INT 3
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 0
7205: GREATER
7206: IFFALSE 7217
// RaiseSailEvent ( 1 ) else
7208: LD_INT 1
7210: PPUSH
7211: CALL_OW 427
7215: GO 7224
// RaiseSailEvent ( 2 ) ;
7217: LD_INT 2
7219: PPUSH
7220: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7224: LD_INT 22
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 30
7236: PUSH
7237: LD_INT 5
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PPUSH
7248: CALL_OW 69
7252: PUSH
7253: LD_INT 0
7255: GREATER
7256: IFFALSE 7265
// RaiseSailEvent ( 4 ) ;
7258: LD_INT 4
7260: PPUSH
7261: CALL_OW 427
// if gamma_towers > 0 then
7265: LD_EXP 18
7269: PUSH
7270: LD_INT 0
7272: GREATER
7273: IFFALSE 7282
// RaiseSailEvent ( 5 ) ;
7275: LD_INT 5
7277: PPUSH
7278: CALL_OW 427
// end ;
7282: PPOPN 2
7284: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7285: GO 7287
7287: DISABLE
7288: LD_INT 0
7290: PPUSH
7291: PPUSH
// begin enable ;
7292: ENABLE
// if new_veh > 0 then
7293: LD_EXP 19
7297: PUSH
7298: LD_INT 0
7300: GREATER
7301: IFFALSE 7488
// while ( new_veh > 0 ) do
7303: LD_EXP 19
7307: PUSH
7308: LD_INT 0
7310: GREATER
7311: IFFALSE 7488
// begin Wait ( 0 0$01 ) ;
7313: LD_INT 35
7315: PPUSH
7316: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7320: LD_INT 26
7322: PPUSH
7323: CALL_OW 461
7327: PUSH
7328: LD_INT 2
7330: EQUAL
7331: IFFALSE 7486
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7333: LD_ADDR_VAR 0 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 3
7343: PUSH
7344: LD_INT 3
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 1
7358: PPUSH
7359: LD_INT 4
7361: PPUSH
7362: CALL_OW 12
7366: ARRAY
7367: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7368: LD_VAR 0 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: IN
7383: IFFALSE 7418
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: LD_INT 4
7392: PUSH
7393: LD_INT 5
7395: PUSH
7396: LD_INT 7
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 1
7406: PPUSH
7407: LD_INT 3
7409: PPUSH
7410: CALL_OW 12
7414: ARRAY
7415: ST_TO_ADDR
7416: GO 7449
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_INT 5
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: LD_INT 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 3
7442: PPUSH
7443: CALL_OW 12
7447: ARRAY
7448: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7449: LD_INT 26
7451: PPUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: LD_INT 2
7462: PPUSH
7463: LD_VAR 0 2
7467: PPUSH
7468: CALL_OW 125
// new_veh := new_veh - 1 ;
7472: LD_ADDR_EXP 19
7476: PUSH
7477: LD_EXP 19
7481: PUSH
7482: LD_INT 1
7484: MINUS
7485: ST_TO_ADDR
// end ; end ;
7486: GO 7303
// end ;
7488: PPOPN 2
7490: END
// every 0 0$01 do var v , filter , am_cmeh ;
7491: GO 7493
7493: DISABLE
7494: LD_INT 0
7496: PPUSH
7497: PPUSH
7498: PPUSH
// begin enable ;
7499: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7500: LD_ADDR_VAR 0 3
7504: PUSH
7505: LD_INT 56
7507: PPUSH
7508: CALL_OW 313
7512: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 33
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 50
7540: PUSH
7541: EMPTY
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: EMPTY
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: ST_TO_ADDR
// if filter > 0 then
7557: LD_VAR 0 2
7561: PUSH
7562: LD_INT 0
7564: GREATER
7565: IFFALSE 7633
// begin for v in filter do
7567: LD_ADDR_VAR 0 1
7571: PUSH
7572: LD_VAR 0 2
7576: PUSH
7577: FOR_IN
7578: IFFALSE 7631
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7580: LD_VAR 0 1
7584: PPUSH
7585: CALL_OW 312
7589: NOT
7590: PUSH
7591: LD_VAR 0 1
7595: PPUSH
7596: CALL_OW 302
7600: AND
7601: IFFALSE 7629
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_VAR 0 3
7612: PUSH
7613: LD_INT 1
7615: PPUSH
7616: LD_INT 3
7618: PPUSH
7619: CALL_OW 12
7623: ARRAY
7624: PPUSH
7625: CALL_OW 135
// end ;
7629: GO 7577
7631: POP
7632: POP
// end ; end ;
7633: PPOPN 3
7635: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7636: LD_INT 33
7638: PUSH
7639: LD_INT 2
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 3
7648: PUSH
7649: LD_INT 34
7651: PUSH
7652: LD_INT 13
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: PUSH
7672: LD_INT 4
7674: PUSH
7675: LD_INT 5
7677: PUSH
7678: LD_INT 7
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_EXP 1
7690: ARRAY
7691: EQUAL
7692: PUSH
7693: LD_INT 26
7695: PPUSH
7696: CALL_OW 461
7700: PUSH
7701: LD_INT 2
7703: EQUAL
7704: AND
7705: IFFALSE 7916
7707: GO 7709
7709: DISABLE
7710: LD_INT 0
7712: PPUSH
7713: PPUSH
7714: PPUSH
// begin enable ;
7715: ENABLE
// if Sikorski_Ar then
7716: LD_EXP 12
7720: IFFALSE 7797
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7722: LD_ADDR_EXP 11
7726: PUSH
7727: LD_INT 2
7729: PUSH
7730: LD_INT 22
7732: PUSH
7733: LD_INT 4
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 22
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 33
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 34
7765: PUSH
7766: LD_INT 13
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: ST_TO_ADDR
7795: GO 7838
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7797: LD_ADDR_EXP 11
7801: PUSH
7802: LD_INT 33
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 3
7814: PUSH
7815: LD_INT 34
7817: PUSH
7818: LD_INT 13
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 69
7837: ST_TO_ADDR
// repeat begin for un in SForce do
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_EXP 11
7847: PUSH
7848: FOR_IN
7849: IFFALSE 7904
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7851: LD_ADDR_VAR 0 3
7855: PUSH
7856: LD_INT 22
7858: PUSH
7859: LD_INT 3
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7871: LD_VAR 0 2
7875: PPUSH
7876: LD_VAR 0 3
7880: PPUSH
7881: LD_VAR 0 2
7885: PPUSH
7886: CALL_OW 74
7890: PPUSH
7891: CALL_OW 115
// Wait ( 0 0$01 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// end ;
7902: GO 7848
7904: POP
7905: POP
// end until SForce = 0 ;
7906: LD_EXP 11
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7838
// end ;
7916: PPOPN 3
7918: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7919: LD_INT 0
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
7925: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7926: LD_ADDR_VAR 0 6
7930: PUSH
7931: LD_INT 14
7933: PPUSH
7934: EMPTY
7935: PPUSH
7936: CALL_OW 70
7940: ST_TO_ADDR
// if tmp then
7941: LD_VAR 0 6
7945: IFFALSE 7979
// for i in tmp do
7947: LD_ADDR_VAR 0 3
7951: PUSH
7952: LD_VAR 0 6
7956: PUSH
7957: FOR_IN
7958: IFFALSE 7977
// ComMoveXY ( i , 42 , 23 ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: LD_INT 42
7967: PPUSH
7968: LD_INT 23
7970: PPUSH
7971: CALL_OW 111
7975: GO 7957
7977: POP
7978: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7979: LD_INT 14
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: CALL_OW 286
// uc_side := 4 ;
7989: LD_ADDR_OWVAR 20
7993: PUSH
7994: LD_INT 4
7996: ST_TO_ADDR
// uc_nation := 1 ;
7997: LD_ADDR_OWVAR 21
8001: PUSH
8002: LD_INT 1
8004: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8005: LD_ADDR_OWVAR 37
8009: PUSH
8010: LD_INT 4
8012: ST_TO_ADDR
// vc_control := control_manual ;
8013: LD_ADDR_OWVAR 38
8017: PUSH
8018: LD_INT 1
8020: ST_TO_ADDR
// vc_engine := engine_combustion ;
8021: LD_ADDR_OWVAR 39
8025: PUSH
8026: LD_INT 1
8028: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8029: LD_ADDR_OWVAR 40
8033: PUSH
8034: LD_INT 4
8036: PUSH
8037: LD_INT 5
8039: PUSH
8040: LD_INT 7
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_EXP 1
8052: ARRAY
8053: ST_TO_ADDR
// veh := CreateVehicle ;
8054: LD_ADDR_VAR 0 5
8058: PUSH
8059: CALL_OW 45
8063: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8064: LD_VAR 0 5
8068: PPUSH
8069: LD_INT 2
8071: PPUSH
8072: LD_INT 0
8074: PPUSH
8075: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8079: LD_EXP 9
8083: PPUSH
8084: LD_VAR 0 5
8088: PPUSH
8089: CALL_OW 52
// SetMark ( veh , 1 ) ;
8093: LD_VAR 0 5
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 242
// while ( num > 0 ) do
8105: LD_VAR 0 1
8109: PUSH
8110: LD_INT 0
8112: GREATER
8113: IFFALSE 8280
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8115: LD_INT 3
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: LD_INT 3
8123: PUSH
8124: LD_INT 4
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_EXP 1
8137: PPUSH
8138: LD_INT 4
8140: PPUSH
8141: CALL_OW 12
8145: ARRAY
8146: PPUSH
8147: LD_INT 1
8149: PPUSH
8150: LD_INT 4
8152: PUSH
8153: LD_INT 5
8155: PUSH
8156: LD_INT 5
8158: PUSH
8159: LD_INT 7
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_EXP 1
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 11
8188: PPUSH
8189: LD_INT 2
8191: PPUSH
8192: LD_INT 5
8194: PUSH
8195: LD_INT 6
8197: PUSH
8198: LD_INT 7
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_EXP 1
8210: ARRAY
8211: PPUSH
8212: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8216: LD_ADDR_VAR 0 4
8220: PUSH
8221: LD_INT 22
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 69
8235: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8236: LD_VAR 0 4
8240: PUSH
8241: LD_VAR 0 4
8245: ARRAY
8246: PPUSH
8247: LD_INT 36
8249: PPUSH
8250: LD_INT 18
8252: PPUSH
8253: CALL_OW 111
// Wait ( 0 0$02 ) ;
8257: LD_INT 70
8259: PPUSH
8260: CALL_OW 67
// num := num - 1 ;
8264: LD_ADDR_VAR 0 1
8268: PUSH
8269: LD_VAR 0 1
8273: PUSH
8274: LD_INT 1
8276: MINUS
8277: ST_TO_ADDR
// end ;
8278: GO 8105
// end ;
8280: LD_VAR 0 2
8284: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8285: LD_EXP 17
8289: PUSH
8290: LD_INT 0
8292: GREATER
8293: IFFALSE 8562
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
// begin enable ;
8301: ENABLE
// for i = 1 to patrol do
8302: LD_ADDR_VAR 0 1
8306: PUSH
8307: DOUBLE
8308: LD_INT 1
8310: DEC
8311: ST_TO_ADDR
8312: LD_EXP 17
8316: PUSH
8317: FOR_TO
8318: IFFALSE 8560
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8320: LD_EXP 17
8324: PUSH
8325: LD_VAR 0 1
8329: ARRAY
8330: PUSH
8331: LD_EXP 17
8335: PUSH
8336: LD_VAR 0 1
8340: ARRAY
8341: PPUSH
8342: CALL_OW 300
8346: AND
8347: PUSH
8348: LD_EXP 17
8352: PUSH
8353: LD_VAR 0 1
8357: ARRAY
8358: PPUSH
8359: CALL_OW 314
8363: NOT
8364: AND
8365: IFFALSE 8515
// case i of 1 :
8367: LD_VAR 0 1
8371: PUSH
8372: LD_INT 1
8374: DOUBLE
8375: EQUAL
8376: IFTRUE 8380
8378: GO 8443
8380: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8381: LD_EXP 17
8385: PUSH
8386: LD_VAR 0 1
8390: ARRAY
8391: PPUSH
8392: LD_INT 53
8394: PPUSH
8395: LD_INT 91
8397: PPUSH
8398: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8402: LD_EXP 17
8406: PUSH
8407: LD_VAR 0 1
8411: ARRAY
8412: PPUSH
8413: LD_INT 245
8415: PPUSH
8416: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8420: LD_EXP 17
8424: PUSH
8425: LD_VAR 0 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 24
8433: PPUSH
8434: LD_INT 26
8436: PPUSH
8437: CALL_OW 171
// end ; 2 :
8441: GO 8515
8443: LD_INT 2
8445: DOUBLE
8446: EQUAL
8447: IFTRUE 8451
8449: GO 8514
8451: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8452: LD_EXP 17
8456: PUSH
8457: LD_VAR 0 1
8461: ARRAY
8462: PPUSH
8463: LD_INT 83
8465: PPUSH
8466: LD_INT 57
8468: PPUSH
8469: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8473: LD_EXP 17
8477: PUSH
8478: LD_VAR 0 1
8482: ARRAY
8483: PPUSH
8484: LD_INT 245
8486: PPUSH
8487: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8491: LD_EXP 17
8495: PUSH
8496: LD_VAR 0 1
8500: ARRAY
8501: PPUSH
8502: LD_INT 47
8504: PPUSH
8505: LD_INT 53
8507: PPUSH
8508: CALL_OW 171
// end ; end ;
8512: GO 8515
8514: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8515: LD_EXP 17
8519: PUSH
8520: LD_VAR 0 1
8524: ARRAY
8525: PPUSH
8526: CALL_OW 256
8530: PUSH
8531: LD_INT 1000
8533: LESS
8534: IFFALSE 8558
// patrol := patrol diff patrol [ i ] ;
8536: LD_ADDR_EXP 17
8540: PUSH
8541: LD_EXP 17
8545: PUSH
8546: LD_EXP 17
8550: PUSH
8551: LD_VAR 0 1
8555: ARRAY
8556: DIFF
8557: ST_TO_ADDR
// end ;
8558: GO 8317
8560: POP
8561: POP
// end ;
8562: PPOPN 1
8564: END
// every 0 0$10 do
8565: GO 8567
8567: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8568: LD_INT 42000
8570: PUSH
8571: LD_INT 37800
8573: PUSH
8574: LD_INT 33600
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_EXP 1
8586: ARRAY
8587: PPUSH
8588: CALL_OW 67
// if not contact_am then
8592: LD_EXP 16
8596: NOT
8597: IFFALSE 8607
// contact_am := true ;
8599: LD_ADDR_EXP 16
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// end ; end_of_file
8607: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8608: LD_INT 0
8610: PPUSH
// comp_tested := false ;
8611: LD_ADDR_EXP 22
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sikorski_run := false ;
8619: LD_ADDR_EXP 23
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// InGameOn ;
8627: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8631: LD_EXP 3
8635: PPUSH
8636: CALL_OW 87
// Wait ( 0 0$01 ) ;
8640: LD_INT 35
8642: PPUSH
8643: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8647: LD_EXP 2
8651: PPUSH
8652: LD_STRING Dpop1
8654: PPUSH
8655: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8659: LD_EXP 3
8663: PPUSH
8664: LD_STRING Dcomm1
8666: PPUSH
8667: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8671: LD_EXP 2
8675: PPUSH
8676: LD_STRING Dpop2
8678: PPUSH
8679: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8683: LD_EXP 3
8687: PPUSH
8688: LD_STRING Dcomm2
8690: PPUSH
8691: CALL_OW 88
// InGameOff ;
8695: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8699: LD_STRING T1
8701: PPUSH
8702: CALL_OW 337
// end ;
8706: LD_VAR 0 1
8710: RET
// every 0 0$01 trigger timer > 2 2$01 do
8711: LD_EXP 24
8715: PUSH
8716: LD_INT 4235
8718: GREATER
8719: IFFALSE 8736
8721: GO 8723
8723: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8724: LD_EXP 5
8728: PPUSH
8729: LD_STRING DKap1
8731: PPUSH
8732: CALL_OW 94
// end ;
8736: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8737: LD_EXP 24
8741: PUSH
8742: LD_INT 46200
8744: PUSH
8745: LD_INT 52500
8747: PUSH
8748: LD_INT 63000
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: LD_EXP 1
8760: ARRAY
8761: GREATER
8762: IFFALSE 9129
8764: GO 8766
8766: DISABLE
8767: LD_INT 0
8769: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8770: LD_EXP 5
8774: PPUSH
8775: LD_STRING DKap2
8777: PPUSH
8778: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8782: LD_INT 10
8784: PPUSH
8785: CALL_OW 67
// Say ( commander , Dcommk ) ;
8789: LD_EXP 3
8793: PPUSH
8794: LD_STRING Dcommk
8796: PPUSH
8797: CALL_OW 88
// Wait ( 0 0$44 ) ;
8801: LD_INT 1540
8803: PPUSH
8804: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8808: LD_EXP 5
8812: PPUSH
8813: LD_INT 3
8815: PPUSH
8816: LD_INT 0
8818: PPUSH
8819: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8823: LD_EXP 5
8827: PPUSH
8828: CALL_OW 87
// Wait ( 0 0$10 ) ;
8832: LD_INT 350
8834: PPUSH
8835: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8839: LD_INT 6
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 8
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_EXP 1
8857: ARRAY
8858: PPUSH
8859: CALL 7919 0 1
// Wait ( 2 2$00 ) ;
8863: LD_INT 4200
8865: PPUSH
8866: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8870: LD_INT 33
8872: PUSH
8873: LD_INT 2
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 3
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 13
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 69
8905: PUSH
8906: LD_INT 3
8908: LESS
8909: IFFALSE 8920
// Wait ( 0 0$01 ) ;
8911: LD_INT 35
8913: PPUSH
8914: CALL_OW 67
8918: GO 8870
// uc_side := 4 ;
8920: LD_ADDR_OWVAR 20
8924: PUSH
8925: LD_INT 4
8927: ST_TO_ADDR
// uc_nation := 1 ;
8928: LD_ADDR_OWVAR 21
8932: PUSH
8933: LD_INT 1
8935: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8936: LD_ADDR_VAR 0 1
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_INT 4
8948: PUSH
8949: LD_INT 5
8951: PUSH
8952: LD_INT 6
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: PUSH
8960: LD_EXP 1
8964: ARRAY
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9009
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8969: LD_INT 1
8971: PPUSH
8972: LD_INT 5
8974: PUSH
8975: LD_INT 6
8977: PUSH
8978: LD_INT 7
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: LIST
8985: PUSH
8986: LD_EXP 1
8990: ARRAY
8991: PPUSH
8992: CALL 734 0 2
8996: PPUSH
8997: LD_INT 4
8999: PPUSH
9000: LD_INT 0
9002: PPUSH
9003: CALL_OW 49
9007: GO 8966
9009: POP
9010: POP
// sikorski_ar := true ;
9011: LD_ADDR_EXP 12
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9019: LD_EXP 9
9023: PPUSH
9024: LD_STRING DSik1
9026: PPUSH
9027: CALL_OW 94
// Wait ( 0 0$30 ) ;
9031: LD_INT 1050
9033: PPUSH
9034: CALL_OW 67
// uc_side := 4 ;
9038: LD_ADDR_OWVAR 20
9042: PUSH
9043: LD_INT 4
9045: ST_TO_ADDR
// uc_nation := 1 ;
9046: LD_ADDR_OWVAR 21
9050: PUSH
9051: LD_INT 1
9053: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: DOUBLE
9060: LD_INT 1
9062: DEC
9063: ST_TO_ADDR
9064: LD_INT 3
9066: PUSH
9067: LD_INT 4
9069: PUSH
9070: LD_INT 4
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_EXP 1
9082: ARRAY
9083: PUSH
9084: FOR_TO
9085: IFFALSE 9127
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9087: LD_INT 1
9089: PPUSH
9090: LD_INT 5
9092: PUSH
9093: LD_INT 6
9095: PUSH
9096: LD_INT 7
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: LD_EXP 1
9108: ARRAY
9109: PPUSH
9110: CALL 734 0 2
9114: PPUSH
9115: LD_INT 13
9117: PPUSH
9118: LD_INT 0
9120: PPUSH
9121: CALL_OW 49
9125: GO 9084
9127: POP
9128: POP
// end ;
9129: PPOPN 1
9131: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9132: LD_EXP 9
9136: PPUSH
9137: CALL_OW 256
9141: PUSH
9142: LD_INT 650
9144: LESS
9145: IFFALSE 9227
9147: GO 9149
9149: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9150: LD_EXP 9
9154: PPUSH
9155: LD_STRING DSik2
9157: PPUSH
9158: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9162: LD_EXP 9
9166: PPUSH
9167: CALL_OW 300
9171: IFFALSE 9227
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9173: LD_EXP 9
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 113
// Wait ( 0 0$01 ) ;
9185: LD_INT 35
9187: PPUSH
9188: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9192: LD_EXP 9
9196: PPUSH
9197: LD_INT 2
9199: PPUSH
9200: CALL_OW 308
9204: IFFALSE 9225
// begin RemoveUnit ( sikorski ) ;
9206: LD_EXP 9
9210: PPUSH
9211: CALL_OW 64
// break ;
9215: GO 9227
// sikorski_run := true ;
9217: LD_ADDR_EXP 23
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// end ; end ;
9225: GO 9162
// end ;
9227: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9228: LD_EXP 9
9232: PPUSH
9233: CALL_OW 256
9237: PUSH
9238: LD_INT 1000
9240: LESS
9241: IFFALSE 9258
9243: GO 9245
9245: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9246: LD_EXP 9
9250: PPUSH
9251: LD_STRING DSkik3
9253: PPUSH
9254: CALL_OW 88
9258: END
// every 1 1$45 + 0 0$15 do
9259: GO 9261
9261: DISABLE
// begin enable ;
9262: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9263: LD_INT 1
9265: PPUSH
9266: LD_INT 5
9268: PPUSH
9269: CALL_OW 12
9273: PPUSH
9274: LD_INT 8
9276: PPUSH
9277: LD_INT 1
9279: PPUSH
9280: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9284: LD_INT 350
9286: PPUSH
9287: LD_INT 1295
9289: PPUSH
9290: CALL_OW 12
9294: PPUSH
9295: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9299: LD_INT 1
9301: PPUSH
9302: LD_INT 5
9304: PPUSH
9305: CALL_OW 12
9309: PPUSH
9310: LD_INT 1
9312: PPUSH
9313: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9317: LD_INT 350
9319: PPUSH
9320: LD_INT 1050
9322: PPUSH
9323: CALL_OW 12
9327: PPUSH
9328: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9332: LD_EXP 24
9336: PUSH
9337: LD_INT 25200
9339: PUSH
9340: LD_INT 23100
9342: PUSH
9343: LD_INT 21000
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_EXP 1
9355: ARRAY
9356: LESSEQUAL
9357: IFFALSE 9380
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9359: LD_INT 1
9361: PPUSH
9362: LD_INT 5
9364: PPUSH
9365: CALL_OW 12
9369: PPUSH
9370: LD_INT 8
9372: PPUSH
9373: LD_INT 1
9375: PPUSH
9376: CALL_OW 55
// end ;
9380: END
// export timer ; every 1 do
9381: GO 9383
9383: DISABLE
// timer := 0 0$00 ;
9384: LD_ADDR_EXP 24
9388: PUSH
9389: LD_INT 0
9391: ST_TO_ADDR
9392: END
// every 0 0$01 do
9393: GO 9395
9395: DISABLE
// begin enable ;
9396: ENABLE
// Display_Strings := [ #tick , timer ] ;
9397: LD_ADDR_OWVAR 47
9401: PUSH
9402: LD_STRING #tick
9404: PUSH
9405: LD_EXP 24
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9414: LD_ADDR_EXP 24
9418: PUSH
9419: LD_EXP 24
9423: PUSH
9424: LD_INT 35
9426: PLUS
9427: ST_TO_ADDR
// end ; end_of_file
9428: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9429: GO 9431
9431: DISABLE
// begin ru_radar := 98 ;
9432: LD_ADDR_EXP 25
9436: PUSH
9437: LD_INT 98
9439: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9440: LD_ADDR_EXP 26
9444: PUSH
9445: LD_INT 89
9447: ST_TO_ADDR
// us_hack := 99 ;
9448: LD_ADDR_EXP 27
9452: PUSH
9453: LD_INT 99
9455: ST_TO_ADDR
// us_artillery := 97 ;
9456: LD_ADDR_EXP 28
9460: PUSH
9461: LD_INT 97
9463: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9464: LD_ADDR_EXP 29
9468: PUSH
9469: LD_INT 91
9471: ST_TO_ADDR
// end ; end_of_file end_of_file
9472: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
9473: GO 9475
9475: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
9476: LD_STRING initStreamRollete();
9478: PPUSH
9479: CALL_OW 559
// InitStreamMode ;
9483: CALL 9492 0 0
// DefineStreamItems ( ) ;
9487: CALL 9932 0 0
// end ;
9491: END
// function InitStreamMode ; begin
9492: LD_INT 0
9494: PPUSH
// streamModeActive := false ;
9495: LD_ADDR_EXP 30
9499: PUSH
9500: LD_INT 0
9502: ST_TO_ADDR
// normalCounter := 26 ;
9503: LD_ADDR_EXP 31
9507: PUSH
9508: LD_INT 26
9510: ST_TO_ADDR
// hardcoreCounter := 12 ;
9511: LD_ADDR_EXP 32
9515: PUSH
9516: LD_INT 12
9518: ST_TO_ADDR
// sRocket := false ;
9519: LD_ADDR_EXP 35
9523: PUSH
9524: LD_INT 0
9526: ST_TO_ADDR
// sSpeed := false ;
9527: LD_ADDR_EXP 34
9531: PUSH
9532: LD_INT 0
9534: ST_TO_ADDR
// sEngine := false ;
9535: LD_ADDR_EXP 36
9539: PUSH
9540: LD_INT 0
9542: ST_TO_ADDR
// sSpec := false ;
9543: LD_ADDR_EXP 33
9547: PUSH
9548: LD_INT 0
9550: ST_TO_ADDR
// sLevel := false ;
9551: LD_ADDR_EXP 37
9555: PUSH
9556: LD_INT 0
9558: ST_TO_ADDR
// sArmoury := false ;
9559: LD_ADDR_EXP 38
9563: PUSH
9564: LD_INT 0
9566: ST_TO_ADDR
// sRadar := false ;
9567: LD_ADDR_EXP 39
9571: PUSH
9572: LD_INT 0
9574: ST_TO_ADDR
// sBunker := false ;
9575: LD_ADDR_EXP 40
9579: PUSH
9580: LD_INT 0
9582: ST_TO_ADDR
// sHack := false ;
9583: LD_ADDR_EXP 41
9587: PUSH
9588: LD_INT 0
9590: ST_TO_ADDR
// sFire := false ;
9591: LD_ADDR_EXP 42
9595: PUSH
9596: LD_INT 0
9598: ST_TO_ADDR
// sRefresh := false ;
9599: LD_ADDR_EXP 43
9603: PUSH
9604: LD_INT 0
9606: ST_TO_ADDR
// sExp := false ;
9607: LD_ADDR_EXP 44
9611: PUSH
9612: LD_INT 0
9614: ST_TO_ADDR
// sDepot := false ;
9615: LD_ADDR_EXP 45
9619: PUSH
9620: LD_INT 0
9622: ST_TO_ADDR
// sFlag := false ;
9623: LD_ADDR_EXP 46
9627: PUSH
9628: LD_INT 0
9630: ST_TO_ADDR
// sKamikadze := false ;
9631: LD_ADDR_EXP 54
9635: PUSH
9636: LD_INT 0
9638: ST_TO_ADDR
// sTroll := false ;
9639: LD_ADDR_EXP 55
9643: PUSH
9644: LD_INT 0
9646: ST_TO_ADDR
// sSlow := false ;
9647: LD_ADDR_EXP 56
9651: PUSH
9652: LD_INT 0
9654: ST_TO_ADDR
// sLack := false ;
9655: LD_ADDR_EXP 57
9659: PUSH
9660: LD_INT 0
9662: ST_TO_ADDR
// sTank := false ;
9663: LD_ADDR_EXP 59
9667: PUSH
9668: LD_INT 0
9670: ST_TO_ADDR
// sRemote := false ;
9671: LD_ADDR_EXP 60
9675: PUSH
9676: LD_INT 0
9678: ST_TO_ADDR
// sPowell := false ;
9679: LD_ADDR_EXP 61
9683: PUSH
9684: LD_INT 0
9686: ST_TO_ADDR
// sTeleport := false ;
9687: LD_ADDR_EXP 64
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// sOilTower := false ;
9695: LD_ADDR_EXP 66
9699: PUSH
9700: LD_INT 0
9702: ST_TO_ADDR
// sShovel := false ;
9703: LD_ADDR_EXP 67
9707: PUSH
9708: LD_INT 0
9710: ST_TO_ADDR
// sSheik := false ;
9711: LD_ADDR_EXP 68
9715: PUSH
9716: LD_INT 0
9718: ST_TO_ADDR
// sEarthquake := false ;
9719: LD_ADDR_EXP 70
9723: PUSH
9724: LD_INT 0
9726: ST_TO_ADDR
// sAI := false ;
9727: LD_ADDR_EXP 71
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// sCargo := false ;
9735: LD_ADDR_EXP 74
9739: PUSH
9740: LD_INT 0
9742: ST_TO_ADDR
// sDLaser := false ;
9743: LD_ADDR_EXP 75
9747: PUSH
9748: LD_INT 0
9750: ST_TO_ADDR
// sExchange := false ;
9751: LD_ADDR_EXP 76
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// sFac := false ;
9759: LD_ADDR_EXP 77
9763: PUSH
9764: LD_INT 0
9766: ST_TO_ADDR
// sPower := false ;
9767: LD_ADDR_EXP 78
9771: PUSH
9772: LD_INT 0
9774: ST_TO_ADDR
// sRandom := false ;
9775: LD_ADDR_EXP 79
9779: PUSH
9780: LD_INT 0
9782: ST_TO_ADDR
// sShield := false ;
9783: LD_ADDR_EXP 80
9787: PUSH
9788: LD_INT 0
9790: ST_TO_ADDR
// sTime := false ;
9791: LD_ADDR_EXP 81
9795: PUSH
9796: LD_INT 0
9798: ST_TO_ADDR
// sTools := false ;
9799: LD_ADDR_EXP 82
9803: PUSH
9804: LD_INT 0
9806: ST_TO_ADDR
// sSold := false ;
9807: LD_ADDR_EXP 47
9811: PUSH
9812: LD_INT 0
9814: ST_TO_ADDR
// sDiff := false ;
9815: LD_ADDR_EXP 48
9819: PUSH
9820: LD_INT 0
9822: ST_TO_ADDR
// sFog := false ;
9823: LD_ADDR_EXP 51
9827: PUSH
9828: LD_INT 0
9830: ST_TO_ADDR
// sReset := false ;
9831: LD_ADDR_EXP 52
9835: PUSH
9836: LD_INT 0
9838: ST_TO_ADDR
// sSun := false ;
9839: LD_ADDR_EXP 53
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// sTiger := false ;
9847: LD_ADDR_EXP 49
9851: PUSH
9852: LD_INT 0
9854: ST_TO_ADDR
// sBomb := false ;
9855: LD_ADDR_EXP 50
9859: PUSH
9860: LD_INT 0
9862: ST_TO_ADDR
// sWound := false ;
9863: LD_ADDR_EXP 58
9867: PUSH
9868: LD_INT 0
9870: ST_TO_ADDR
// sBetray := false ;
9871: LD_ADDR_EXP 62
9875: PUSH
9876: LD_INT 0
9878: ST_TO_ADDR
// sContamin := false ;
9879: LD_ADDR_EXP 63
9883: PUSH
9884: LD_INT 0
9886: ST_TO_ADDR
// sOil := false ;
9887: LD_ADDR_EXP 65
9891: PUSH
9892: LD_INT 0
9894: ST_TO_ADDR
// sStu := false ;
9895: LD_ADDR_EXP 69
9899: PUSH
9900: LD_INT 0
9902: ST_TO_ADDR
// sBazooka := false ;
9903: LD_ADDR_EXP 72
9907: PUSH
9908: LD_INT 0
9910: ST_TO_ADDR
// sMortar := false ;
9911: LD_ADDR_EXP 73
9915: PUSH
9916: LD_INT 0
9918: ST_TO_ADDR
// sRanger := false ;
9919: LD_ADDR_EXP 83
9923: PUSH
9924: LD_INT 0
9926: ST_TO_ADDR
// end ;
9927: LD_VAR 0 1
9931: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9932: LD_INT 0
9934: PPUSH
9935: PPUSH
9936: PPUSH
9937: PPUSH
9938: PPUSH
// result := [ ] ;
9939: LD_ADDR_VAR 0 1
9943: PUSH
9944: EMPTY
9945: ST_TO_ADDR
// if campaign_id = 1 then
9946: LD_OWVAR 69
9950: PUSH
9951: LD_INT 1
9953: EQUAL
9954: IFFALSE 12902
// begin case mission_number of 1 :
9956: LD_OWVAR 70
9960: PUSH
9961: LD_INT 1
9963: DOUBLE
9964: EQUAL
9965: IFTRUE 9969
9967: GO 10033
9969: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9970: LD_ADDR_VAR 0 1
9974: PUSH
9975: LD_INT 2
9977: PUSH
9978: LD_INT 4
9980: PUSH
9981: LD_INT 11
9983: PUSH
9984: LD_INT 12
9986: PUSH
9987: LD_INT 15
9989: PUSH
9990: LD_INT 16
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_INT 23
9998: PUSH
9999: LD_INT 26
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: PUSH
10013: LD_INT 101
10015: PUSH
10016: LD_INT 102
10018: PUSH
10019: LD_INT 106
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: LIST
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: ST_TO_ADDR
10031: GO 12902
10033: LD_INT 2
10035: DOUBLE
10036: EQUAL
10037: IFTRUE 10041
10039: GO 10113
10041: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
10042: LD_ADDR_VAR 0 1
10046: PUSH
10047: LD_INT 2
10049: PUSH
10050: LD_INT 4
10052: PUSH
10053: LD_INT 11
10055: PUSH
10056: LD_INT 12
10058: PUSH
10059: LD_INT 15
10061: PUSH
10062: LD_INT 16
10064: PUSH
10065: LD_INT 22
10067: PUSH
10068: LD_INT 23
10070: PUSH
10071: LD_INT 26
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 101
10087: PUSH
10088: LD_INT 102
10090: PUSH
10091: LD_INT 105
10093: PUSH
10094: LD_INT 106
10096: PUSH
10097: LD_INT 108
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: ST_TO_ADDR
10111: GO 12902
10113: LD_INT 3
10115: DOUBLE
10116: EQUAL
10117: IFTRUE 10121
10119: GO 10197
10121: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
10122: LD_ADDR_VAR 0 1
10126: PUSH
10127: LD_INT 2
10129: PUSH
10130: LD_INT 4
10132: PUSH
10133: LD_INT 5
10135: PUSH
10136: LD_INT 11
10138: PUSH
10139: LD_INT 12
10141: PUSH
10142: LD_INT 15
10144: PUSH
10145: LD_INT 16
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 26
10153: PUSH
10154: LD_INT 36
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: PUSH
10169: LD_INT 101
10171: PUSH
10172: LD_INT 102
10174: PUSH
10175: LD_INT 105
10177: PUSH
10178: LD_INT 106
10180: PUSH
10181: LD_INT 108
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: ST_TO_ADDR
10195: GO 12902
10197: LD_INT 4
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10289
10205: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
10206: LD_ADDR_VAR 0 1
10210: PUSH
10211: LD_INT 2
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 8
10222: PUSH
10223: LD_INT 11
10225: PUSH
10226: LD_INT 12
10228: PUSH
10229: LD_INT 15
10231: PUSH
10232: LD_INT 16
10234: PUSH
10235: LD_INT 22
10237: PUSH
10238: LD_INT 23
10240: PUSH
10241: LD_INT 26
10243: PUSH
10244: LD_INT 36
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 101
10263: PUSH
10264: LD_INT 102
10266: PUSH
10267: LD_INT 105
10269: PUSH
10270: LD_INT 106
10272: PUSH
10273: LD_INT 108
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: ST_TO_ADDR
10287: GO 12902
10289: LD_INT 5
10291: DOUBLE
10292: EQUAL
10293: IFTRUE 10297
10295: GO 10397
10297: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
10298: LD_ADDR_VAR 0 1
10302: PUSH
10303: LD_INT 2
10305: PUSH
10306: LD_INT 4
10308: PUSH
10309: LD_INT 5
10311: PUSH
10312: LD_INT 6
10314: PUSH
10315: LD_INT 8
10317: PUSH
10318: LD_INT 11
10320: PUSH
10321: LD_INT 12
10323: PUSH
10324: LD_INT 15
10326: PUSH
10327: LD_INT 16
10329: PUSH
10330: LD_INT 22
10332: PUSH
10333: LD_INT 23
10335: PUSH
10336: LD_INT 25
10338: PUSH
10339: LD_INT 26
10341: PUSH
10342: LD_INT 36
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PUSH
10361: LD_INT 101
10363: PUSH
10364: LD_INT 102
10366: PUSH
10367: LD_INT 105
10369: PUSH
10370: LD_INT 106
10372: PUSH
10373: LD_INT 108
10375: PUSH
10376: LD_INT 109
10378: PUSH
10379: LD_INT 112
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: ST_TO_ADDR
10395: GO 12902
10397: LD_INT 6
10399: DOUBLE
10400: EQUAL
10401: IFTRUE 10405
10403: GO 10525
10405: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
10406: LD_ADDR_VAR 0 1
10410: PUSH
10411: LD_INT 2
10413: PUSH
10414: LD_INT 4
10416: PUSH
10417: LD_INT 5
10419: PUSH
10420: LD_INT 6
10422: PUSH
10423: LD_INT 8
10425: PUSH
10426: LD_INT 11
10428: PUSH
10429: LD_INT 12
10431: PUSH
10432: LD_INT 15
10434: PUSH
10435: LD_INT 16
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 21
10443: PUSH
10444: LD_INT 22
10446: PUSH
10447: LD_INT 23
10449: PUSH
10450: LD_INT 25
10452: PUSH
10453: LD_INT 26
10455: PUSH
10456: LD_INT 30
10458: PUSH
10459: LD_INT 31
10461: PUSH
10462: LD_INT 32
10464: PUSH
10465: LD_INT 36
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 101
10491: PUSH
10492: LD_INT 102
10494: PUSH
10495: LD_INT 105
10497: PUSH
10498: LD_INT 106
10500: PUSH
10501: LD_INT 108
10503: PUSH
10504: LD_INT 109
10506: PUSH
10507: LD_INT 112
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: ST_TO_ADDR
10523: GO 12902
10525: LD_INT 7
10527: DOUBLE
10528: EQUAL
10529: IFTRUE 10533
10531: GO 10633
10533: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
10534: LD_ADDR_VAR 0 1
10538: PUSH
10539: LD_INT 2
10541: PUSH
10542: LD_INT 4
10544: PUSH
10545: LD_INT 5
10547: PUSH
10548: LD_INT 7
10550: PUSH
10551: LD_INT 11
10553: PUSH
10554: LD_INT 12
10556: PUSH
10557: LD_INT 15
10559: PUSH
10560: LD_INT 16
10562: PUSH
10563: LD_INT 20
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 22
10571: PUSH
10572: LD_INT 23
10574: PUSH
10575: LD_INT 25
10577: PUSH
10578: LD_INT 26
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: PUSH
10597: LD_INT 101
10599: PUSH
10600: LD_INT 102
10602: PUSH
10603: LD_INT 103
10605: PUSH
10606: LD_INT 105
10608: PUSH
10609: LD_INT 106
10611: PUSH
10612: LD_INT 108
10614: PUSH
10615: LD_INT 112
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: ST_TO_ADDR
10631: GO 12902
10633: LD_INT 8
10635: DOUBLE
10636: EQUAL
10637: IFTRUE 10641
10639: GO 10769
10641: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
10642: LD_ADDR_VAR 0 1
10646: PUSH
10647: LD_INT 2
10649: PUSH
10650: LD_INT 4
10652: PUSH
10653: LD_INT 5
10655: PUSH
10656: LD_INT 6
10658: PUSH
10659: LD_INT 7
10661: PUSH
10662: LD_INT 8
10664: PUSH
10665: LD_INT 11
10667: PUSH
10668: LD_INT 12
10670: PUSH
10671: LD_INT 15
10673: PUSH
10674: LD_INT 16
10676: PUSH
10677: LD_INT 20
10679: PUSH
10680: LD_INT 21
10682: PUSH
10683: LD_INT 22
10685: PUSH
10686: LD_INT 23
10688: PUSH
10689: LD_INT 25
10691: PUSH
10692: LD_INT 26
10694: PUSH
10695: LD_INT 30
10697: PUSH
10698: LD_INT 31
10700: PUSH
10701: LD_INT 32
10703: PUSH
10704: LD_INT 36
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: PUSH
10729: LD_INT 101
10731: PUSH
10732: LD_INT 102
10734: PUSH
10735: LD_INT 103
10737: PUSH
10738: LD_INT 105
10740: PUSH
10741: LD_INT 106
10743: PUSH
10744: LD_INT 108
10746: PUSH
10747: LD_INT 109
10749: PUSH
10750: LD_INT 112
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: LIST
10759: LIST
10760: LIST
10761: LIST
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: ST_TO_ADDR
10767: GO 12902
10769: LD_INT 9
10771: DOUBLE
10772: EQUAL
10773: IFTRUE 10777
10775: GO 10913
10777: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
10778: LD_ADDR_VAR 0 1
10782: PUSH
10783: LD_INT 2
10785: PUSH
10786: LD_INT 4
10788: PUSH
10789: LD_INT 5
10791: PUSH
10792: LD_INT 6
10794: PUSH
10795: LD_INT 7
10797: PUSH
10798: LD_INT 8
10800: PUSH
10801: LD_INT 11
10803: PUSH
10804: LD_INT 12
10806: PUSH
10807: LD_INT 15
10809: PUSH
10810: LD_INT 16
10812: PUSH
10813: LD_INT 20
10815: PUSH
10816: LD_INT 21
10818: PUSH
10819: LD_INT 22
10821: PUSH
10822: LD_INT 23
10824: PUSH
10825: LD_INT 25
10827: PUSH
10828: LD_INT 26
10830: PUSH
10831: LD_INT 28
10833: PUSH
10834: LD_INT 30
10836: PUSH
10837: LD_INT 31
10839: PUSH
10840: LD_INT 32
10842: PUSH
10843: LD_INT 36
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 101
10871: PUSH
10872: LD_INT 102
10874: PUSH
10875: LD_INT 103
10877: PUSH
10878: LD_INT 105
10880: PUSH
10881: LD_INT 106
10883: PUSH
10884: LD_INT 108
10886: PUSH
10887: LD_INT 109
10889: PUSH
10890: LD_INT 112
10892: PUSH
10893: LD_INT 114
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: ST_TO_ADDR
10911: GO 12902
10913: LD_INT 10
10915: DOUBLE
10916: EQUAL
10917: IFTRUE 10921
10919: GO 11105
10921: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10922: LD_ADDR_VAR 0 1
10926: PUSH
10927: LD_INT 2
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: LD_INT 5
10935: PUSH
10936: LD_INT 6
10938: PUSH
10939: LD_INT 7
10941: PUSH
10942: LD_INT 8
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: LD_INT 10
10950: PUSH
10951: LD_INT 11
10953: PUSH
10954: LD_INT 12
10956: PUSH
10957: LD_INT 13
10959: PUSH
10960: LD_INT 14
10962: PUSH
10963: LD_INT 15
10965: PUSH
10966: LD_INT 16
10968: PUSH
10969: LD_INT 17
10971: PUSH
10972: LD_INT 18
10974: PUSH
10975: LD_INT 19
10977: PUSH
10978: LD_INT 20
10980: PUSH
10981: LD_INT 21
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 23
10989: PUSH
10990: LD_INT 24
10992: PUSH
10993: LD_INT 25
10995: PUSH
10996: LD_INT 26
10998: PUSH
10999: LD_INT 28
11001: PUSH
11002: LD_INT 30
11004: PUSH
11005: LD_INT 31
11007: PUSH
11008: LD_INT 32
11010: PUSH
11011: LD_INT 36
11013: PUSH
11014: EMPTY
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 101
11047: PUSH
11048: LD_INT 102
11050: PUSH
11051: LD_INT 103
11053: PUSH
11054: LD_INT 104
11056: PUSH
11057: LD_INT 105
11059: PUSH
11060: LD_INT 106
11062: PUSH
11063: LD_INT 107
11065: PUSH
11066: LD_INT 108
11068: PUSH
11069: LD_INT 109
11071: PUSH
11072: LD_INT 110
11074: PUSH
11075: LD_INT 111
11077: PUSH
11078: LD_INT 112
11080: PUSH
11081: LD_INT 114
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: ST_TO_ADDR
11103: GO 12902
11105: LD_INT 11
11107: DOUBLE
11108: EQUAL
11109: IFTRUE 11113
11111: GO 11305
11113: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: LD_INT 3
11124: PUSH
11125: LD_INT 4
11127: PUSH
11128: LD_INT 5
11130: PUSH
11131: LD_INT 6
11133: PUSH
11134: LD_INT 7
11136: PUSH
11137: LD_INT 8
11139: PUSH
11140: LD_INT 9
11142: PUSH
11143: LD_INT 10
11145: PUSH
11146: LD_INT 11
11148: PUSH
11149: LD_INT 12
11151: PUSH
11152: LD_INT 13
11154: PUSH
11155: LD_INT 14
11157: PUSH
11158: LD_INT 15
11160: PUSH
11161: LD_INT 16
11163: PUSH
11164: LD_INT 17
11166: PUSH
11167: LD_INT 18
11169: PUSH
11170: LD_INT 19
11172: PUSH
11173: LD_INT 20
11175: PUSH
11176: LD_INT 21
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_INT 23
11184: PUSH
11185: LD_INT 24
11187: PUSH
11188: LD_INT 25
11190: PUSH
11191: LD_INT 26
11193: PUSH
11194: LD_INT 28
11196: PUSH
11197: LD_INT 30
11199: PUSH
11200: LD_INT 31
11202: PUSH
11203: LD_INT 32
11205: PUSH
11206: LD_INT 34
11208: PUSH
11209: LD_INT 36
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: PUSH
11245: LD_INT 101
11247: PUSH
11248: LD_INT 102
11250: PUSH
11251: LD_INT 103
11253: PUSH
11254: LD_INT 104
11256: PUSH
11257: LD_INT 105
11259: PUSH
11260: LD_INT 106
11262: PUSH
11263: LD_INT 107
11265: PUSH
11266: LD_INT 108
11268: PUSH
11269: LD_INT 109
11271: PUSH
11272: LD_INT 110
11274: PUSH
11275: LD_INT 111
11277: PUSH
11278: LD_INT 112
11280: PUSH
11281: LD_INT 114
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: PUSH
11299: EMPTY
11300: LIST
11301: LIST
11302: ST_TO_ADDR
11303: GO 12902
11305: LD_INT 12
11307: DOUBLE
11308: EQUAL
11309: IFTRUE 11313
11311: GO 11521
11313: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
11314: LD_ADDR_VAR 0 1
11318: PUSH
11319: LD_INT 1
11321: PUSH
11322: LD_INT 2
11324: PUSH
11325: LD_INT 3
11327: PUSH
11328: LD_INT 4
11330: PUSH
11331: LD_INT 5
11333: PUSH
11334: LD_INT 6
11336: PUSH
11337: LD_INT 7
11339: PUSH
11340: LD_INT 8
11342: PUSH
11343: LD_INT 9
11345: PUSH
11346: LD_INT 10
11348: PUSH
11349: LD_INT 11
11351: PUSH
11352: LD_INT 12
11354: PUSH
11355: LD_INT 13
11357: PUSH
11358: LD_INT 14
11360: PUSH
11361: LD_INT 15
11363: PUSH
11364: LD_INT 16
11366: PUSH
11367: LD_INT 17
11369: PUSH
11370: LD_INT 18
11372: PUSH
11373: LD_INT 19
11375: PUSH
11376: LD_INT 20
11378: PUSH
11379: LD_INT 21
11381: PUSH
11382: LD_INT 22
11384: PUSH
11385: LD_INT 23
11387: PUSH
11388: LD_INT 24
11390: PUSH
11391: LD_INT 25
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 27
11399: PUSH
11400: LD_INT 28
11402: PUSH
11403: LD_INT 30
11405: PUSH
11406: LD_INT 31
11408: PUSH
11409: LD_INT 32
11411: PUSH
11412: LD_INT 33
11414: PUSH
11415: LD_INT 34
11417: PUSH
11418: LD_INT 36
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: PUSH
11457: LD_INT 101
11459: PUSH
11460: LD_INT 102
11462: PUSH
11463: LD_INT 103
11465: PUSH
11466: LD_INT 104
11468: PUSH
11469: LD_INT 105
11471: PUSH
11472: LD_INT 106
11474: PUSH
11475: LD_INT 107
11477: PUSH
11478: LD_INT 108
11480: PUSH
11481: LD_INT 109
11483: PUSH
11484: LD_INT 110
11486: PUSH
11487: LD_INT 111
11489: PUSH
11490: LD_INT 112
11492: PUSH
11493: LD_INT 113
11495: PUSH
11496: LD_INT 114
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: PUSH
11515: EMPTY
11516: LIST
11517: LIST
11518: ST_TO_ADDR
11519: GO 12902
11521: LD_INT 13
11523: DOUBLE
11524: EQUAL
11525: IFTRUE 11529
11527: GO 11737
11529: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
11530: LD_ADDR_VAR 0 1
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: LD_INT 2
11540: PUSH
11541: LD_INT 3
11543: PUSH
11544: LD_INT 4
11546: PUSH
11547: LD_INT 5
11549: PUSH
11550: LD_INT 6
11552: PUSH
11553: LD_INT 7
11555: PUSH
11556: LD_INT 8
11558: PUSH
11559: LD_INT 9
11561: PUSH
11562: LD_INT 10
11564: PUSH
11565: LD_INT 11
11567: PUSH
11568: LD_INT 12
11570: PUSH
11571: LD_INT 13
11573: PUSH
11574: LD_INT 14
11576: PUSH
11577: LD_INT 15
11579: PUSH
11580: LD_INT 16
11582: PUSH
11583: LD_INT 17
11585: PUSH
11586: LD_INT 18
11588: PUSH
11589: LD_INT 19
11591: PUSH
11592: LD_INT 20
11594: PUSH
11595: LD_INT 21
11597: PUSH
11598: LD_INT 22
11600: PUSH
11601: LD_INT 23
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 25
11609: PUSH
11610: LD_INT 26
11612: PUSH
11613: LD_INT 27
11615: PUSH
11616: LD_INT 28
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 32
11627: PUSH
11628: LD_INT 33
11630: PUSH
11631: LD_INT 34
11633: PUSH
11634: LD_INT 36
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: LIST
11672: PUSH
11673: LD_INT 101
11675: PUSH
11676: LD_INT 102
11678: PUSH
11679: LD_INT 103
11681: PUSH
11682: LD_INT 104
11684: PUSH
11685: LD_INT 105
11687: PUSH
11688: LD_INT 106
11690: PUSH
11691: LD_INT 107
11693: PUSH
11694: LD_INT 108
11696: PUSH
11697: LD_INT 109
11699: PUSH
11700: LD_INT 110
11702: PUSH
11703: LD_INT 111
11705: PUSH
11706: LD_INT 112
11708: PUSH
11709: LD_INT 113
11711: PUSH
11712: LD_INT 114
11714: PUSH
11715: EMPTY
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: ST_TO_ADDR
11735: GO 12902
11737: LD_INT 14
11739: DOUBLE
11740: EQUAL
11741: IFTRUE 11745
11743: GO 11957
11745: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
11746: LD_ADDR_VAR 0 1
11750: PUSH
11751: LD_INT 1
11753: PUSH
11754: LD_INT 2
11756: PUSH
11757: LD_INT 3
11759: PUSH
11760: LD_INT 4
11762: PUSH
11763: LD_INT 5
11765: PUSH
11766: LD_INT 6
11768: PUSH
11769: LD_INT 7
11771: PUSH
11772: LD_INT 8
11774: PUSH
11775: LD_INT 9
11777: PUSH
11778: LD_INT 10
11780: PUSH
11781: LD_INT 11
11783: PUSH
11784: LD_INT 12
11786: PUSH
11787: LD_INT 13
11789: PUSH
11790: LD_INT 14
11792: PUSH
11793: LD_INT 15
11795: PUSH
11796: LD_INT 16
11798: PUSH
11799: LD_INT 17
11801: PUSH
11802: LD_INT 18
11804: PUSH
11805: LD_INT 19
11807: PUSH
11808: LD_INT 20
11810: PUSH
11811: LD_INT 21
11813: PUSH
11814: LD_INT 22
11816: PUSH
11817: LD_INT 23
11819: PUSH
11820: LD_INT 24
11822: PUSH
11823: LD_INT 25
11825: PUSH
11826: LD_INT 26
11828: PUSH
11829: LD_INT 27
11831: PUSH
11832: LD_INT 28
11834: PUSH
11835: LD_INT 29
11837: PUSH
11838: LD_INT 30
11840: PUSH
11841: LD_INT 31
11843: PUSH
11844: LD_INT 32
11846: PUSH
11847: LD_INT 33
11849: PUSH
11850: LD_INT 34
11852: PUSH
11853: LD_INT 36
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: PUSH
11893: LD_INT 101
11895: PUSH
11896: LD_INT 102
11898: PUSH
11899: LD_INT 103
11901: PUSH
11902: LD_INT 104
11904: PUSH
11905: LD_INT 105
11907: PUSH
11908: LD_INT 106
11910: PUSH
11911: LD_INT 107
11913: PUSH
11914: LD_INT 108
11916: PUSH
11917: LD_INT 109
11919: PUSH
11920: LD_INT 110
11922: PUSH
11923: LD_INT 111
11925: PUSH
11926: LD_INT 112
11928: PUSH
11929: LD_INT 113
11931: PUSH
11932: LD_INT 114
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: LIST
11939: LIST
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: LIST
11949: LIST
11950: PUSH
11951: EMPTY
11952: LIST
11953: LIST
11954: ST_TO_ADDR
11955: GO 12902
11957: LD_INT 15
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 12177
11965: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11966: LD_ADDR_VAR 0 1
11970: PUSH
11971: LD_INT 1
11973: PUSH
11974: LD_INT 2
11976: PUSH
11977: LD_INT 3
11979: PUSH
11980: LD_INT 4
11982: PUSH
11983: LD_INT 5
11985: PUSH
11986: LD_INT 6
11988: PUSH
11989: LD_INT 7
11991: PUSH
11992: LD_INT 8
11994: PUSH
11995: LD_INT 9
11997: PUSH
11998: LD_INT 10
12000: PUSH
12001: LD_INT 11
12003: PUSH
12004: LD_INT 12
12006: PUSH
12007: LD_INT 13
12009: PUSH
12010: LD_INT 14
12012: PUSH
12013: LD_INT 15
12015: PUSH
12016: LD_INT 16
12018: PUSH
12019: LD_INT 17
12021: PUSH
12022: LD_INT 18
12024: PUSH
12025: LD_INT 19
12027: PUSH
12028: LD_INT 20
12030: PUSH
12031: LD_INT 21
12033: PUSH
12034: LD_INT 22
12036: PUSH
12037: LD_INT 23
12039: PUSH
12040: LD_INT 24
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 26
12048: PUSH
12049: LD_INT 27
12051: PUSH
12052: LD_INT 28
12054: PUSH
12055: LD_INT 29
12057: PUSH
12058: LD_INT 30
12060: PUSH
12061: LD_INT 31
12063: PUSH
12064: LD_INT 32
12066: PUSH
12067: LD_INT 33
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 36
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: LIST
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: LIST
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 101
12115: PUSH
12116: LD_INT 102
12118: PUSH
12119: LD_INT 103
12121: PUSH
12122: LD_INT 104
12124: PUSH
12125: LD_INT 105
12127: PUSH
12128: LD_INT 106
12130: PUSH
12131: LD_INT 107
12133: PUSH
12134: LD_INT 108
12136: PUSH
12137: LD_INT 109
12139: PUSH
12140: LD_INT 110
12142: PUSH
12143: LD_INT 111
12145: PUSH
12146: LD_INT 112
12148: PUSH
12149: LD_INT 113
12151: PUSH
12152: LD_INT 114
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: ST_TO_ADDR
12175: GO 12902
12177: LD_INT 16
12179: DOUBLE
12180: EQUAL
12181: IFTRUE 12185
12183: GO 12309
12185: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
12186: LD_ADDR_VAR 0 1
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: LD_INT 4
12196: PUSH
12197: LD_INT 5
12199: PUSH
12200: LD_INT 7
12202: PUSH
12203: LD_INT 11
12205: PUSH
12206: LD_INT 12
12208: PUSH
12209: LD_INT 15
12211: PUSH
12212: LD_INT 16
12214: PUSH
12215: LD_INT 20
12217: PUSH
12218: LD_INT 21
12220: PUSH
12221: LD_INT 22
12223: PUSH
12224: LD_INT 23
12226: PUSH
12227: LD_INT 25
12229: PUSH
12230: LD_INT 26
12232: PUSH
12233: LD_INT 30
12235: PUSH
12236: LD_INT 31
12238: PUSH
12239: LD_INT 32
12241: PUSH
12242: LD_INT 33
12244: PUSH
12245: LD_INT 34
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: PUSH
12269: LD_INT 101
12271: PUSH
12272: LD_INT 102
12274: PUSH
12275: LD_INT 103
12277: PUSH
12278: LD_INT 106
12280: PUSH
12281: LD_INT 108
12283: PUSH
12284: LD_INT 112
12286: PUSH
12287: LD_INT 113
12289: PUSH
12290: LD_INT 114
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: ST_TO_ADDR
12307: GO 12902
12309: LD_INT 17
12311: DOUBLE
12312: EQUAL
12313: IFTRUE 12317
12315: GO 12529
12317: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
12318: LD_ADDR_VAR 0 1
12322: PUSH
12323: LD_INT 1
12325: PUSH
12326: LD_INT 2
12328: PUSH
12329: LD_INT 3
12331: PUSH
12332: LD_INT 4
12334: PUSH
12335: LD_INT 5
12337: PUSH
12338: LD_INT 6
12340: PUSH
12341: LD_INT 7
12343: PUSH
12344: LD_INT 8
12346: PUSH
12347: LD_INT 9
12349: PUSH
12350: LD_INT 10
12352: PUSH
12353: LD_INT 11
12355: PUSH
12356: LD_INT 12
12358: PUSH
12359: LD_INT 13
12361: PUSH
12362: LD_INT 14
12364: PUSH
12365: LD_INT 15
12367: PUSH
12368: LD_INT 16
12370: PUSH
12371: LD_INT 17
12373: PUSH
12374: LD_INT 18
12376: PUSH
12377: LD_INT 19
12379: PUSH
12380: LD_INT 20
12382: PUSH
12383: LD_INT 21
12385: PUSH
12386: LD_INT 22
12388: PUSH
12389: LD_INT 23
12391: PUSH
12392: LD_INT 24
12394: PUSH
12395: LD_INT 25
12397: PUSH
12398: LD_INT 26
12400: PUSH
12401: LD_INT 27
12403: PUSH
12404: LD_INT 28
12406: PUSH
12407: LD_INT 29
12409: PUSH
12410: LD_INT 30
12412: PUSH
12413: LD_INT 31
12415: PUSH
12416: LD_INT 32
12418: PUSH
12419: LD_INT 33
12421: PUSH
12422: LD_INT 34
12424: PUSH
12425: LD_INT 36
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: LIST
12463: LIST
12464: PUSH
12465: LD_INT 101
12467: PUSH
12468: LD_INT 102
12470: PUSH
12471: LD_INT 103
12473: PUSH
12474: LD_INT 104
12476: PUSH
12477: LD_INT 105
12479: PUSH
12480: LD_INT 106
12482: PUSH
12483: LD_INT 107
12485: PUSH
12486: LD_INT 108
12488: PUSH
12489: LD_INT 109
12491: PUSH
12492: LD_INT 110
12494: PUSH
12495: LD_INT 111
12497: PUSH
12498: LD_INT 112
12500: PUSH
12501: LD_INT 113
12503: PUSH
12504: LD_INT 114
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: ST_TO_ADDR
12527: GO 12902
12529: LD_INT 18
12531: DOUBLE
12532: EQUAL
12533: IFTRUE 12537
12535: GO 12673
12537: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
12538: LD_ADDR_VAR 0 1
12542: PUSH
12543: LD_INT 2
12545: PUSH
12546: LD_INT 4
12548: PUSH
12549: LD_INT 5
12551: PUSH
12552: LD_INT 7
12554: PUSH
12555: LD_INT 11
12557: PUSH
12558: LD_INT 12
12560: PUSH
12561: LD_INT 15
12563: PUSH
12564: LD_INT 16
12566: PUSH
12567: LD_INT 20
12569: PUSH
12570: LD_INT 21
12572: PUSH
12573: LD_INT 22
12575: PUSH
12576: LD_INT 23
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 26
12584: PUSH
12585: LD_INT 30
12587: PUSH
12588: LD_INT 31
12590: PUSH
12591: LD_INT 32
12593: PUSH
12594: LD_INT 33
12596: PUSH
12597: LD_INT 34
12599: PUSH
12600: LD_INT 35
12602: PUSH
12603: LD_INT 36
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 101
12631: PUSH
12632: LD_INT 102
12634: PUSH
12635: LD_INT 103
12637: PUSH
12638: LD_INT 106
12640: PUSH
12641: LD_INT 108
12643: PUSH
12644: LD_INT 112
12646: PUSH
12647: LD_INT 113
12649: PUSH
12650: LD_INT 114
12652: PUSH
12653: LD_INT 115
12655: PUSH
12656: EMPTY
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: LIST
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: ST_TO_ADDR
12671: GO 12902
12673: LD_INT 19
12675: DOUBLE
12676: EQUAL
12677: IFTRUE 12681
12679: GO 12901
12681: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
12682: LD_ADDR_VAR 0 1
12686: PUSH
12687: LD_INT 1
12689: PUSH
12690: LD_INT 2
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: LD_INT 4
12698: PUSH
12699: LD_INT 5
12701: PUSH
12702: LD_INT 6
12704: PUSH
12705: LD_INT 7
12707: PUSH
12708: LD_INT 8
12710: PUSH
12711: LD_INT 9
12713: PUSH
12714: LD_INT 10
12716: PUSH
12717: LD_INT 11
12719: PUSH
12720: LD_INT 12
12722: PUSH
12723: LD_INT 13
12725: PUSH
12726: LD_INT 14
12728: PUSH
12729: LD_INT 15
12731: PUSH
12732: LD_INT 16
12734: PUSH
12735: LD_INT 17
12737: PUSH
12738: LD_INT 18
12740: PUSH
12741: LD_INT 19
12743: PUSH
12744: LD_INT 20
12746: PUSH
12747: LD_INT 21
12749: PUSH
12750: LD_INT 22
12752: PUSH
12753: LD_INT 23
12755: PUSH
12756: LD_INT 24
12758: PUSH
12759: LD_INT 25
12761: PUSH
12762: LD_INT 26
12764: PUSH
12765: LD_INT 27
12767: PUSH
12768: LD_INT 28
12770: PUSH
12771: LD_INT 29
12773: PUSH
12774: LD_INT 30
12776: PUSH
12777: LD_INT 31
12779: PUSH
12780: LD_INT 32
12782: PUSH
12783: LD_INT 33
12785: PUSH
12786: LD_INT 34
12788: PUSH
12789: LD_INT 35
12791: PUSH
12792: LD_INT 36
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: LIST
12830: LIST
12831: LIST
12832: PUSH
12833: LD_INT 101
12835: PUSH
12836: LD_INT 102
12838: PUSH
12839: LD_INT 103
12841: PUSH
12842: LD_INT 104
12844: PUSH
12845: LD_INT 105
12847: PUSH
12848: LD_INT 106
12850: PUSH
12851: LD_INT 107
12853: PUSH
12854: LD_INT 108
12856: PUSH
12857: LD_INT 109
12859: PUSH
12860: LD_INT 110
12862: PUSH
12863: LD_INT 111
12865: PUSH
12866: LD_INT 112
12868: PUSH
12869: LD_INT 113
12871: PUSH
12872: LD_INT 114
12874: PUSH
12875: LD_INT 115
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: LIST
12893: LIST
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: ST_TO_ADDR
12899: GO 12902
12901: POP
// end ; if result then
12902: LD_VAR 0 1
12906: IFFALSE 13195
// begin normal :=  ;
12908: LD_ADDR_VAR 0 3
12912: PUSH
12913: LD_STRING 
12915: ST_TO_ADDR
// hardcore :=  ;
12916: LD_ADDR_VAR 0 4
12920: PUSH
12921: LD_STRING 
12923: ST_TO_ADDR
// for i = 1 to normalCounter do
12924: LD_ADDR_VAR 0 5
12928: PUSH
12929: DOUBLE
12930: LD_INT 1
12932: DEC
12933: ST_TO_ADDR
12934: LD_EXP 31
12938: PUSH
12939: FOR_TO
12940: IFFALSE 13041
// begin tmp := 0 ;
12942: LD_ADDR_VAR 0 2
12946: PUSH
12947: LD_STRING 0
12949: ST_TO_ADDR
// if result [ 1 ] then
12950: LD_VAR 0 1
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: IFFALSE 13023
// if result [ 1 ] [ 1 ] = i then
12960: LD_VAR 0 1
12964: PUSH
12965: LD_INT 1
12967: ARRAY
12968: PUSH
12969: LD_INT 1
12971: ARRAY
12972: PUSH
12973: LD_VAR 0 5
12977: EQUAL
12978: IFFALSE 13023
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
12980: LD_ADDR_VAR 0 1
12984: PUSH
12985: LD_VAR 0 1
12989: PPUSH
12990: LD_INT 1
12992: PPUSH
12993: LD_VAR 0 1
12997: PUSH
12998: LD_INT 1
13000: ARRAY
13001: PPUSH
13002: LD_INT 1
13004: PPUSH
13005: CALL_OW 3
13009: PPUSH
13010: CALL_OW 1
13014: ST_TO_ADDR
// tmp := 1 ;
13015: LD_ADDR_VAR 0 2
13019: PUSH
13020: LD_STRING 1
13022: ST_TO_ADDR
// end ; normal := normal & tmp ;
13023: LD_ADDR_VAR 0 3
13027: PUSH
13028: LD_VAR 0 3
13032: PUSH
13033: LD_VAR 0 2
13037: STR
13038: ST_TO_ADDR
// end ;
13039: GO 12939
13041: POP
13042: POP
// for i = 1 to hardcoreCounter do
13043: LD_ADDR_VAR 0 5
13047: PUSH
13048: DOUBLE
13049: LD_INT 1
13051: DEC
13052: ST_TO_ADDR
13053: LD_EXP 32
13057: PUSH
13058: FOR_TO
13059: IFFALSE 13164
// begin tmp := 0 ;
13061: LD_ADDR_VAR 0 2
13065: PUSH
13066: LD_STRING 0
13068: ST_TO_ADDR
// if result [ 2 ] then
13069: LD_VAR 0 1
13073: PUSH
13074: LD_INT 2
13076: ARRAY
13077: IFFALSE 13146
// if result [ 2 ] [ 1 ] = 100 + i then
13079: LD_VAR 0 1
13083: PUSH
13084: LD_INT 2
13086: ARRAY
13087: PUSH
13088: LD_INT 1
13090: ARRAY
13091: PUSH
13092: LD_INT 100
13094: PUSH
13095: LD_VAR 0 5
13099: PLUS
13100: EQUAL
13101: IFFALSE 13146
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
13103: LD_ADDR_VAR 0 1
13107: PUSH
13108: LD_VAR 0 1
13112: PPUSH
13113: LD_INT 2
13115: PPUSH
13116: LD_VAR 0 1
13120: PUSH
13121: LD_INT 2
13123: ARRAY
13124: PPUSH
13125: LD_INT 1
13127: PPUSH
13128: CALL_OW 3
13132: PPUSH
13133: CALL_OW 1
13137: ST_TO_ADDR
// tmp := 1 ;
13138: LD_ADDR_VAR 0 2
13142: PUSH
13143: LD_STRING 1
13145: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
13146: LD_ADDR_VAR 0 4
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 2
13160: STR
13161: ST_TO_ADDR
// end ;
13162: GO 13058
13164: POP
13165: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
13166: LD_STRING getStreamItemsFromMission("
13168: PUSH
13169: LD_VAR 0 3
13173: STR
13174: PUSH
13175: LD_STRING ","
13177: STR
13178: PUSH
13179: LD_VAR 0 4
13183: STR
13184: PUSH
13185: LD_STRING ")
13187: STR
13188: PPUSH
13189: CALL_OW 559
// end else
13193: GO 13202
// ToLua ( getStreamItemsFromMission("","") ) ;
13195: LD_STRING getStreamItemsFromMission("","")
13197: PPUSH
13198: CALL_OW 559
// end ;
13202: LD_VAR 0 1
13206: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
13207: LD_VAR 0 2
13211: PUSH
13212: LD_INT 100
13214: EQUAL
13215: IFFALSE 14164
// begin if not StreamModeActive then
13217: LD_EXP 30
13221: NOT
13222: IFFALSE 13232
// StreamModeActive := true ;
13224: LD_ADDR_EXP 30
13228: PUSH
13229: LD_INT 1
13231: ST_TO_ADDR
// if p3 = 0 then
13232: LD_VAR 0 3
13236: PUSH
13237: LD_INT 0
13239: EQUAL
13240: IFFALSE 13246
// InitStreamMode ;
13242: CALL 9492 0 0
// if p3 = 1 then
13246: LD_VAR 0 3
13250: PUSH
13251: LD_INT 1
13253: EQUAL
13254: IFFALSE 13264
// sRocket := true ;
13256: LD_ADDR_EXP 35
13260: PUSH
13261: LD_INT 1
13263: ST_TO_ADDR
// if p3 = 2 then
13264: LD_VAR 0 3
13268: PUSH
13269: LD_INT 2
13271: EQUAL
13272: IFFALSE 13282
// sSpeed := true ;
13274: LD_ADDR_EXP 34
13278: PUSH
13279: LD_INT 1
13281: ST_TO_ADDR
// if p3 = 3 then
13282: LD_VAR 0 3
13286: PUSH
13287: LD_INT 3
13289: EQUAL
13290: IFFALSE 13300
// sEngine := true ;
13292: LD_ADDR_EXP 36
13296: PUSH
13297: LD_INT 1
13299: ST_TO_ADDR
// if p3 = 4 then
13300: LD_VAR 0 3
13304: PUSH
13305: LD_INT 4
13307: EQUAL
13308: IFFALSE 13318
// sSpec := true ;
13310: LD_ADDR_EXP 33
13314: PUSH
13315: LD_INT 1
13317: ST_TO_ADDR
// if p3 = 5 then
13318: LD_VAR 0 3
13322: PUSH
13323: LD_INT 5
13325: EQUAL
13326: IFFALSE 13336
// sLevel := true ;
13328: LD_ADDR_EXP 37
13332: PUSH
13333: LD_INT 1
13335: ST_TO_ADDR
// if p3 = 6 then
13336: LD_VAR 0 3
13340: PUSH
13341: LD_INT 6
13343: EQUAL
13344: IFFALSE 13354
// sArmoury := true ;
13346: LD_ADDR_EXP 38
13350: PUSH
13351: LD_INT 1
13353: ST_TO_ADDR
// if p3 = 7 then
13354: LD_VAR 0 3
13358: PUSH
13359: LD_INT 7
13361: EQUAL
13362: IFFALSE 13372
// sRadar := true ;
13364: LD_ADDR_EXP 39
13368: PUSH
13369: LD_INT 1
13371: ST_TO_ADDR
// if p3 = 8 then
13372: LD_VAR 0 3
13376: PUSH
13377: LD_INT 8
13379: EQUAL
13380: IFFALSE 13390
// sBunker := true ;
13382: LD_ADDR_EXP 40
13386: PUSH
13387: LD_INT 1
13389: ST_TO_ADDR
// if p3 = 9 then
13390: LD_VAR 0 3
13394: PUSH
13395: LD_INT 9
13397: EQUAL
13398: IFFALSE 13408
// sHack := true ;
13400: LD_ADDR_EXP 41
13404: PUSH
13405: LD_INT 1
13407: ST_TO_ADDR
// if p3 = 10 then
13408: LD_VAR 0 3
13412: PUSH
13413: LD_INT 10
13415: EQUAL
13416: IFFALSE 13426
// sFire := true ;
13418: LD_ADDR_EXP 42
13422: PUSH
13423: LD_INT 1
13425: ST_TO_ADDR
// if p3 = 11 then
13426: LD_VAR 0 3
13430: PUSH
13431: LD_INT 11
13433: EQUAL
13434: IFFALSE 13444
// sRefresh := true ;
13436: LD_ADDR_EXP 43
13440: PUSH
13441: LD_INT 1
13443: ST_TO_ADDR
// if p3 = 12 then
13444: LD_VAR 0 3
13448: PUSH
13449: LD_INT 12
13451: EQUAL
13452: IFFALSE 13462
// sExp := true ;
13454: LD_ADDR_EXP 44
13458: PUSH
13459: LD_INT 1
13461: ST_TO_ADDR
// if p3 = 13 then
13462: LD_VAR 0 3
13466: PUSH
13467: LD_INT 13
13469: EQUAL
13470: IFFALSE 13480
// sDepot := true ;
13472: LD_ADDR_EXP 45
13476: PUSH
13477: LD_INT 1
13479: ST_TO_ADDR
// if p3 = 14 then
13480: LD_VAR 0 3
13484: PUSH
13485: LD_INT 14
13487: EQUAL
13488: IFFALSE 13498
// sFlag := true ;
13490: LD_ADDR_EXP 46
13494: PUSH
13495: LD_INT 1
13497: ST_TO_ADDR
// if p3 = 15 then
13498: LD_VAR 0 3
13502: PUSH
13503: LD_INT 15
13505: EQUAL
13506: IFFALSE 13516
// sKamikadze := true ;
13508: LD_ADDR_EXP 54
13512: PUSH
13513: LD_INT 1
13515: ST_TO_ADDR
// if p3 = 16 then
13516: LD_VAR 0 3
13520: PUSH
13521: LD_INT 16
13523: EQUAL
13524: IFFALSE 13534
// sTroll := true ;
13526: LD_ADDR_EXP 55
13530: PUSH
13531: LD_INT 1
13533: ST_TO_ADDR
// if p3 = 17 then
13534: LD_VAR 0 3
13538: PUSH
13539: LD_INT 17
13541: EQUAL
13542: IFFALSE 13552
// sSlow := true ;
13544: LD_ADDR_EXP 56
13548: PUSH
13549: LD_INT 1
13551: ST_TO_ADDR
// if p3 = 18 then
13552: LD_VAR 0 3
13556: PUSH
13557: LD_INT 18
13559: EQUAL
13560: IFFALSE 13570
// sLack := true ;
13562: LD_ADDR_EXP 57
13566: PUSH
13567: LD_INT 1
13569: ST_TO_ADDR
// if p3 = 19 then
13570: LD_VAR 0 3
13574: PUSH
13575: LD_INT 19
13577: EQUAL
13578: IFFALSE 13588
// sTank := true ;
13580: LD_ADDR_EXP 59
13584: PUSH
13585: LD_INT 1
13587: ST_TO_ADDR
// if p3 = 20 then
13588: LD_VAR 0 3
13592: PUSH
13593: LD_INT 20
13595: EQUAL
13596: IFFALSE 13606
// sRemote := true ;
13598: LD_ADDR_EXP 60
13602: PUSH
13603: LD_INT 1
13605: ST_TO_ADDR
// if p3 = 21 then
13606: LD_VAR 0 3
13610: PUSH
13611: LD_INT 21
13613: EQUAL
13614: IFFALSE 13624
// sPowell := true ;
13616: LD_ADDR_EXP 61
13620: PUSH
13621: LD_INT 1
13623: ST_TO_ADDR
// if p3 = 22 then
13624: LD_VAR 0 3
13628: PUSH
13629: LD_INT 22
13631: EQUAL
13632: IFFALSE 13642
// sTeleport := true ;
13634: LD_ADDR_EXP 64
13638: PUSH
13639: LD_INT 1
13641: ST_TO_ADDR
// if p3 = 23 then
13642: LD_VAR 0 3
13646: PUSH
13647: LD_INT 23
13649: EQUAL
13650: IFFALSE 13660
// sOilTower := true ;
13652: LD_ADDR_EXP 66
13656: PUSH
13657: LD_INT 1
13659: ST_TO_ADDR
// if p3 = 24 then
13660: LD_VAR 0 3
13664: PUSH
13665: LD_INT 24
13667: EQUAL
13668: IFFALSE 13678
// sShovel := true ;
13670: LD_ADDR_EXP 67
13674: PUSH
13675: LD_INT 1
13677: ST_TO_ADDR
// if p3 = 25 then
13678: LD_VAR 0 3
13682: PUSH
13683: LD_INT 25
13685: EQUAL
13686: IFFALSE 13696
// sSheik := true ;
13688: LD_ADDR_EXP 68
13692: PUSH
13693: LD_INT 1
13695: ST_TO_ADDR
// if p3 = 26 then
13696: LD_VAR 0 3
13700: PUSH
13701: LD_INT 26
13703: EQUAL
13704: IFFALSE 13714
// sEarthquake := true ;
13706: LD_ADDR_EXP 70
13710: PUSH
13711: LD_INT 1
13713: ST_TO_ADDR
// if p3 = 27 then
13714: LD_VAR 0 3
13718: PUSH
13719: LD_INT 27
13721: EQUAL
13722: IFFALSE 13732
// sAI := true ;
13724: LD_ADDR_EXP 71
13728: PUSH
13729: LD_INT 1
13731: ST_TO_ADDR
// if p3 = 28 then
13732: LD_VAR 0 3
13736: PUSH
13737: LD_INT 28
13739: EQUAL
13740: IFFALSE 13750
// sCargo := true ;
13742: LD_ADDR_EXP 74
13746: PUSH
13747: LD_INT 1
13749: ST_TO_ADDR
// if p3 = 29 then
13750: LD_VAR 0 3
13754: PUSH
13755: LD_INT 29
13757: EQUAL
13758: IFFALSE 13768
// sDLaser := true ;
13760: LD_ADDR_EXP 75
13764: PUSH
13765: LD_INT 1
13767: ST_TO_ADDR
// if p3 = 30 then
13768: LD_VAR 0 3
13772: PUSH
13773: LD_INT 30
13775: EQUAL
13776: IFFALSE 13786
// sExchange := true ;
13778: LD_ADDR_EXP 76
13782: PUSH
13783: LD_INT 1
13785: ST_TO_ADDR
// if p3 = 31 then
13786: LD_VAR 0 3
13790: PUSH
13791: LD_INT 31
13793: EQUAL
13794: IFFALSE 13804
// sFac := true ;
13796: LD_ADDR_EXP 77
13800: PUSH
13801: LD_INT 1
13803: ST_TO_ADDR
// if p3 = 32 then
13804: LD_VAR 0 3
13808: PUSH
13809: LD_INT 32
13811: EQUAL
13812: IFFALSE 13822
// sPower := true ;
13814: LD_ADDR_EXP 78
13818: PUSH
13819: LD_INT 1
13821: ST_TO_ADDR
// if p3 = 33 then
13822: LD_VAR 0 3
13826: PUSH
13827: LD_INT 33
13829: EQUAL
13830: IFFALSE 13840
// sRandom := true ;
13832: LD_ADDR_EXP 79
13836: PUSH
13837: LD_INT 1
13839: ST_TO_ADDR
// if p3 = 34 then
13840: LD_VAR 0 3
13844: PUSH
13845: LD_INT 34
13847: EQUAL
13848: IFFALSE 13858
// sShield := true ;
13850: LD_ADDR_EXP 80
13854: PUSH
13855: LD_INT 1
13857: ST_TO_ADDR
// if p3 = 35 then
13858: LD_VAR 0 3
13862: PUSH
13863: LD_INT 35
13865: EQUAL
13866: IFFALSE 13876
// sTime := true ;
13868: LD_ADDR_EXP 81
13872: PUSH
13873: LD_INT 1
13875: ST_TO_ADDR
// if p3 = 36 then
13876: LD_VAR 0 3
13880: PUSH
13881: LD_INT 36
13883: EQUAL
13884: IFFALSE 13894
// sTools := true ;
13886: LD_ADDR_EXP 82
13890: PUSH
13891: LD_INT 1
13893: ST_TO_ADDR
// if p3 = 101 then
13894: LD_VAR 0 3
13898: PUSH
13899: LD_INT 101
13901: EQUAL
13902: IFFALSE 13912
// sSold := true ;
13904: LD_ADDR_EXP 47
13908: PUSH
13909: LD_INT 1
13911: ST_TO_ADDR
// if p3 = 102 then
13912: LD_VAR 0 3
13916: PUSH
13917: LD_INT 102
13919: EQUAL
13920: IFFALSE 13930
// sDiff := true ;
13922: LD_ADDR_EXP 48
13926: PUSH
13927: LD_INT 1
13929: ST_TO_ADDR
// if p3 = 103 then
13930: LD_VAR 0 3
13934: PUSH
13935: LD_INT 103
13937: EQUAL
13938: IFFALSE 13948
// sFog := true ;
13940: LD_ADDR_EXP 51
13944: PUSH
13945: LD_INT 1
13947: ST_TO_ADDR
// if p3 = 104 then
13948: LD_VAR 0 3
13952: PUSH
13953: LD_INT 104
13955: EQUAL
13956: IFFALSE 13966
// sReset := true ;
13958: LD_ADDR_EXP 52
13962: PUSH
13963: LD_INT 1
13965: ST_TO_ADDR
// if p3 = 105 then
13966: LD_VAR 0 3
13970: PUSH
13971: LD_INT 105
13973: EQUAL
13974: IFFALSE 13984
// sSun := true ;
13976: LD_ADDR_EXP 53
13980: PUSH
13981: LD_INT 1
13983: ST_TO_ADDR
// if p3 = 106 then
13984: LD_VAR 0 3
13988: PUSH
13989: LD_INT 106
13991: EQUAL
13992: IFFALSE 14002
// sTiger := true ;
13994: LD_ADDR_EXP 49
13998: PUSH
13999: LD_INT 1
14001: ST_TO_ADDR
// if p3 = 107 then
14002: LD_VAR 0 3
14006: PUSH
14007: LD_INT 107
14009: EQUAL
14010: IFFALSE 14020
// sBomb := true ;
14012: LD_ADDR_EXP 50
14016: PUSH
14017: LD_INT 1
14019: ST_TO_ADDR
// if p3 = 108 then
14020: LD_VAR 0 3
14024: PUSH
14025: LD_INT 108
14027: EQUAL
14028: IFFALSE 14038
// sWound := true ;
14030: LD_ADDR_EXP 58
14034: PUSH
14035: LD_INT 1
14037: ST_TO_ADDR
// if p3 = 109 then
14038: LD_VAR 0 3
14042: PUSH
14043: LD_INT 109
14045: EQUAL
14046: IFFALSE 14056
// sBetray := true ;
14048: LD_ADDR_EXP 62
14052: PUSH
14053: LD_INT 1
14055: ST_TO_ADDR
// if p3 = 110 then
14056: LD_VAR 0 3
14060: PUSH
14061: LD_INT 110
14063: EQUAL
14064: IFFALSE 14074
// sContamin := true ;
14066: LD_ADDR_EXP 63
14070: PUSH
14071: LD_INT 1
14073: ST_TO_ADDR
// if p3 = 111 then
14074: LD_VAR 0 3
14078: PUSH
14079: LD_INT 111
14081: EQUAL
14082: IFFALSE 14092
// sOil := true ;
14084: LD_ADDR_EXP 65
14088: PUSH
14089: LD_INT 1
14091: ST_TO_ADDR
// if p3 = 112 then
14092: LD_VAR 0 3
14096: PUSH
14097: LD_INT 112
14099: EQUAL
14100: IFFALSE 14110
// sStu := true ;
14102: LD_ADDR_EXP 69
14106: PUSH
14107: LD_INT 1
14109: ST_TO_ADDR
// if p3 = 113 then
14110: LD_VAR 0 3
14114: PUSH
14115: LD_INT 113
14117: EQUAL
14118: IFFALSE 14128
// sBazooka := true ;
14120: LD_ADDR_EXP 72
14124: PUSH
14125: LD_INT 1
14127: ST_TO_ADDR
// if p3 = 114 then
14128: LD_VAR 0 3
14132: PUSH
14133: LD_INT 114
14135: EQUAL
14136: IFFALSE 14146
// sMortar := true ;
14138: LD_ADDR_EXP 73
14142: PUSH
14143: LD_INT 1
14145: ST_TO_ADDR
// if p3 = 115 then
14146: LD_VAR 0 3
14150: PUSH
14151: LD_INT 115
14153: EQUAL
14154: IFFALSE 14164
// sRanger := true ;
14156: LD_ADDR_EXP 83
14160: PUSH
14161: LD_INT 1
14163: ST_TO_ADDR
// end ; end ;
14164: PPOPN 6
14166: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
14167: LD_EXP 30
14171: PUSH
14172: LD_EXP 35
14176: AND
14177: IFFALSE 14301
14179: GO 14181
14181: DISABLE
14182: LD_INT 0
14184: PPUSH
14185: PPUSH
// begin enable ;
14186: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
14187: LD_ADDR_VAR 0 2
14191: PUSH
14192: LD_INT 22
14194: PUSH
14195: LD_OWVAR 2
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: LD_INT 2
14206: PUSH
14207: LD_INT 34
14209: PUSH
14210: LD_INT 7
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PUSH
14217: LD_INT 34
14219: PUSH
14220: LD_INT 45
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PUSH
14227: LD_INT 34
14229: PUSH
14230: LD_INT 28
14232: PUSH
14233: EMPTY
14234: LIST
14235: LIST
14236: PUSH
14237: LD_INT 34
14239: PUSH
14240: LD_INT 47
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PPUSH
14258: CALL_OW 69
14262: ST_TO_ADDR
// if not tmp then
14263: LD_VAR 0 2
14267: NOT
14268: IFFALSE 14272
// exit ;
14270: GO 14301
// for i in tmp do
14272: LD_ADDR_VAR 0 1
14276: PUSH
14277: LD_VAR 0 2
14281: PUSH
14282: FOR_IN
14283: IFFALSE 14299
// begin SetLives ( i , 0 ) ;
14285: LD_VAR 0 1
14289: PPUSH
14290: LD_INT 0
14292: PPUSH
14293: CALL_OW 234
// end ;
14297: GO 14282
14299: POP
14300: POP
// end ;
14301: PPOPN 2
14303: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
14304: LD_EXP 30
14308: PUSH
14309: LD_EXP 36
14313: AND
14314: IFFALSE 14398
14316: GO 14318
14318: DISABLE
14319: LD_INT 0
14321: PPUSH
14322: PPUSH
// begin enable ;
14323: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
14324: LD_ADDR_VAR 0 2
14328: PUSH
14329: LD_INT 22
14331: PUSH
14332: LD_OWVAR 2
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: PUSH
14341: LD_INT 32
14343: PUSH
14344: LD_INT 3
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: PUSH
14351: EMPTY
14352: LIST
14353: LIST
14354: PPUSH
14355: CALL_OW 69
14359: ST_TO_ADDR
// if not tmp then
14360: LD_VAR 0 2
14364: NOT
14365: IFFALSE 14369
// exit ;
14367: GO 14398
// for i in tmp do
14369: LD_ADDR_VAR 0 1
14373: PUSH
14374: LD_VAR 0 2
14378: PUSH
14379: FOR_IN
14380: IFFALSE 14396
// begin SetLives ( i , 0 ) ;
14382: LD_VAR 0 1
14386: PPUSH
14387: LD_INT 0
14389: PPUSH
14390: CALL_OW 234
// end ;
14394: GO 14379
14396: POP
14397: POP
// end ;
14398: PPOPN 2
14400: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
14401: LD_EXP 30
14405: PUSH
14406: LD_EXP 33
14410: AND
14411: IFFALSE 14504
14413: GO 14415
14415: DISABLE
14416: LD_INT 0
14418: PPUSH
// begin enable ;
14419: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
14420: LD_ADDR_VAR 0 1
14424: PUSH
14425: LD_INT 22
14427: PUSH
14428: LD_OWVAR 2
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: PUSH
14437: LD_INT 2
14439: PUSH
14440: LD_INT 25
14442: PUSH
14443: LD_INT 5
14445: PUSH
14446: EMPTY
14447: LIST
14448: LIST
14449: PUSH
14450: LD_INT 25
14452: PUSH
14453: LD_INT 9
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 8
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PPUSH
14480: CALL_OW 69
14484: PUSH
14485: FOR_IN
14486: IFFALSE 14502
// begin SetClass ( i , 1 ) ;
14488: LD_VAR 0 1
14492: PPUSH
14493: LD_INT 1
14495: PPUSH
14496: CALL_OW 336
// end ;
14500: GO 14485
14502: POP
14503: POP
// end ;
14504: PPOPN 1
14506: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
14507: LD_EXP 30
14511: PUSH
14512: LD_EXP 34
14516: AND
14517: PUSH
14518: LD_OWVAR 65
14522: PUSH
14523: LD_INT 7
14525: LESS
14526: AND
14527: IFFALSE 14541
14529: GO 14531
14531: DISABLE
// begin enable ;
14532: ENABLE
// game_speed := 7 ;
14533: LD_ADDR_OWVAR 65
14537: PUSH
14538: LD_INT 7
14540: ST_TO_ADDR
// end ;
14541: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
14542: LD_EXP 30
14546: PUSH
14547: LD_EXP 37
14551: AND
14552: IFFALSE 14754
14554: GO 14556
14556: DISABLE
14557: LD_INT 0
14559: PPUSH
14560: PPUSH
14561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
14562: LD_ADDR_VAR 0 3
14566: PUSH
14567: LD_INT 81
14569: PUSH
14570: LD_OWVAR 2
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: PUSH
14579: LD_INT 21
14581: PUSH
14582: LD_INT 1
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: PPUSH
14593: CALL_OW 69
14597: ST_TO_ADDR
// if not tmp then
14598: LD_VAR 0 3
14602: NOT
14603: IFFALSE 14607
// exit ;
14605: GO 14754
// if tmp > 5 then
14607: LD_VAR 0 3
14611: PUSH
14612: LD_INT 5
14614: GREATER
14615: IFFALSE 14627
// k := 5 else
14617: LD_ADDR_VAR 0 2
14621: PUSH
14622: LD_INT 5
14624: ST_TO_ADDR
14625: GO 14637
// k := tmp ;
14627: LD_ADDR_VAR 0 2
14631: PUSH
14632: LD_VAR 0 3
14636: ST_TO_ADDR
// for i := 1 to k do
14637: LD_ADDR_VAR 0 1
14641: PUSH
14642: DOUBLE
14643: LD_INT 1
14645: DEC
14646: ST_TO_ADDR
14647: LD_VAR 0 2
14651: PUSH
14652: FOR_TO
14653: IFFALSE 14752
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
14655: LD_VAR 0 3
14659: PUSH
14660: LD_VAR 0 1
14664: ARRAY
14665: PPUSH
14666: LD_VAR 0 1
14670: PUSH
14671: LD_INT 4
14673: MOD
14674: PUSH
14675: LD_INT 1
14677: PLUS
14678: PPUSH
14679: CALL_OW 259
14683: PUSH
14684: LD_INT 10
14686: LESS
14687: IFFALSE 14750
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
14689: LD_VAR 0 3
14693: PUSH
14694: LD_VAR 0 1
14698: ARRAY
14699: PPUSH
14700: LD_VAR 0 1
14704: PUSH
14705: LD_INT 4
14707: MOD
14708: PUSH
14709: LD_INT 1
14711: PLUS
14712: PPUSH
14713: LD_VAR 0 3
14717: PUSH
14718: LD_VAR 0 1
14722: ARRAY
14723: PPUSH
14724: LD_VAR 0 1
14728: PUSH
14729: LD_INT 4
14731: MOD
14732: PUSH
14733: LD_INT 1
14735: PLUS
14736: PPUSH
14737: CALL_OW 259
14741: PUSH
14742: LD_INT 1
14744: PLUS
14745: PPUSH
14746: CALL_OW 237
14750: GO 14652
14752: POP
14753: POP
// end ;
14754: PPOPN 3
14756: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
14757: LD_EXP 30
14761: PUSH
14762: LD_EXP 38
14766: AND
14767: IFFALSE 14787
14769: GO 14771
14771: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
14772: LD_INT 4
14774: PPUSH
14775: LD_OWVAR 2
14779: PPUSH
14780: LD_INT 0
14782: PPUSH
14783: CALL_OW 324
14787: END
// every 0 0$1 trigger StreamModeActive and sShovel do
14788: LD_EXP 30
14792: PUSH
14793: LD_EXP 67
14797: AND
14798: IFFALSE 14818
14800: GO 14802
14802: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
14803: LD_INT 19
14805: PPUSH
14806: LD_OWVAR 2
14810: PPUSH
14811: LD_INT 0
14813: PPUSH
14814: CALL_OW 324
14818: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
14819: LD_EXP 30
14823: PUSH
14824: LD_EXP 39
14828: AND
14829: IFFALSE 14931
14831: GO 14833
14833: DISABLE
14834: LD_INT 0
14836: PPUSH
14837: PPUSH
// begin enable ;
14838: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
14839: LD_ADDR_VAR 0 2
14843: PUSH
14844: LD_INT 22
14846: PUSH
14847: LD_OWVAR 2
14851: PUSH
14852: EMPTY
14853: LIST
14854: LIST
14855: PUSH
14856: LD_INT 2
14858: PUSH
14859: LD_INT 34
14861: PUSH
14862: LD_INT 11
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PUSH
14869: LD_INT 34
14871: PUSH
14872: LD_INT 30
14874: PUSH
14875: EMPTY
14876: LIST
14877: LIST
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 69
14892: ST_TO_ADDR
// if not tmp then
14893: LD_VAR 0 2
14897: NOT
14898: IFFALSE 14902
// exit ;
14900: GO 14931
// for i in tmp do
14902: LD_ADDR_VAR 0 1
14906: PUSH
14907: LD_VAR 0 2
14911: PUSH
14912: FOR_IN
14913: IFFALSE 14929
// begin SetLives ( i , 0 ) ;
14915: LD_VAR 0 1
14919: PPUSH
14920: LD_INT 0
14922: PPUSH
14923: CALL_OW 234
// end ;
14927: GO 14912
14929: POP
14930: POP
// end ;
14931: PPOPN 2
14933: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14934: LD_EXP 30
14938: PUSH
14939: LD_EXP 40
14943: AND
14944: IFFALSE 14964
14946: GO 14948
14948: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14949: LD_INT 32
14951: PPUSH
14952: LD_OWVAR 2
14956: PPUSH
14957: LD_INT 0
14959: PPUSH
14960: CALL_OW 324
14964: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14965: LD_EXP 30
14969: PUSH
14970: LD_EXP 41
14974: AND
14975: IFFALSE 15156
14977: GO 14979
14979: DISABLE
14980: LD_INT 0
14982: PPUSH
14983: PPUSH
14984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: LD_INT 22
14992: PUSH
14993: LD_OWVAR 2
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PUSH
15002: LD_INT 33
15004: PUSH
15005: LD_INT 3
15007: PUSH
15008: EMPTY
15009: LIST
15010: LIST
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: PPUSH
15016: CALL_OW 69
15020: ST_TO_ADDR
// if not tmp then
15021: LD_VAR 0 2
15025: NOT
15026: IFFALSE 15030
// exit ;
15028: GO 15156
// side := 0 ;
15030: LD_ADDR_VAR 0 3
15034: PUSH
15035: LD_INT 0
15037: ST_TO_ADDR
// for i := 1 to 8 do
15038: LD_ADDR_VAR 0 1
15042: PUSH
15043: DOUBLE
15044: LD_INT 1
15046: DEC
15047: ST_TO_ADDR
15048: LD_INT 8
15050: PUSH
15051: FOR_TO
15052: IFFALSE 15100
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
15054: LD_OWVAR 2
15058: PUSH
15059: LD_VAR 0 1
15063: NONEQUAL
15064: PUSH
15065: LD_OWVAR 2
15069: PPUSH
15070: LD_VAR 0 1
15074: PPUSH
15075: CALL_OW 81
15079: PUSH
15080: LD_INT 2
15082: EQUAL
15083: AND
15084: IFFALSE 15098
// begin side := i ;
15086: LD_ADDR_VAR 0 3
15090: PUSH
15091: LD_VAR 0 1
15095: ST_TO_ADDR
// break ;
15096: GO 15100
// end ;
15098: GO 15051
15100: POP
15101: POP
// if not side then
15102: LD_VAR 0 3
15106: NOT
15107: IFFALSE 15111
// exit ;
15109: GO 15156
// for i := 1 to tmp do
15111: LD_ADDR_VAR 0 1
15115: PUSH
15116: DOUBLE
15117: LD_INT 1
15119: DEC
15120: ST_TO_ADDR
15121: LD_VAR 0 2
15125: PUSH
15126: FOR_TO
15127: IFFALSE 15154
// if Prob ( 30 ) then
15129: LD_INT 30
15131: PPUSH
15132: CALL_OW 13
15136: IFFALSE 15152
// SetSide ( i , side ) ;
15138: LD_VAR 0 1
15142: PPUSH
15143: LD_VAR 0 3
15147: PPUSH
15148: CALL_OW 235
15152: GO 15126
15154: POP
15155: POP
// end ;
15156: PPOPN 3
15158: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
15159: LD_EXP 30
15163: PUSH
15164: LD_EXP 43
15168: AND
15169: IFFALSE 15288
15171: GO 15173
15173: DISABLE
15174: LD_INT 0
15176: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
15177: LD_ADDR_VAR 0 1
15181: PUSH
15182: LD_INT 22
15184: PUSH
15185: LD_OWVAR 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: LD_INT 21
15196: PUSH
15197: LD_INT 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PUSH
15204: LD_INT 3
15206: PUSH
15207: LD_INT 23
15209: PUSH
15210: LD_INT 0
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: LIST
15225: PPUSH
15226: CALL_OW 69
15230: PUSH
15231: FOR_IN
15232: IFFALSE 15286
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
15234: LD_VAR 0 1
15238: PPUSH
15239: CALL_OW 257
15243: PUSH
15244: LD_INT 1
15246: PUSH
15247: LD_INT 2
15249: PUSH
15250: LD_INT 3
15252: PUSH
15253: LD_INT 4
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: IN
15262: IFFALSE 15284
// SetClass ( un , rand ( 1 , 4 ) ) ;
15264: LD_VAR 0 1
15268: PPUSH
15269: LD_INT 1
15271: PPUSH
15272: LD_INT 4
15274: PPUSH
15275: CALL_OW 12
15279: PPUSH
15280: CALL_OW 336
15284: GO 15231
15286: POP
15287: POP
// end ;
15288: PPOPN 1
15290: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
15291: LD_EXP 30
15295: PUSH
15296: LD_EXP 42
15300: AND
15301: IFFALSE 15380
15303: GO 15305
15305: DISABLE
15306: LD_INT 0
15308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15309: LD_ADDR_VAR 0 1
15313: PUSH
15314: LD_INT 22
15316: PUSH
15317: LD_OWVAR 2
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 21
15328: PUSH
15329: LD_INT 3
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 69
15344: ST_TO_ADDR
// if not tmp then
15345: LD_VAR 0 1
15349: NOT
15350: IFFALSE 15354
// exit ;
15352: GO 15380
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
15354: LD_VAR 0 1
15358: PUSH
15359: LD_INT 1
15361: PPUSH
15362: LD_VAR 0 1
15366: PPUSH
15367: CALL_OW 12
15371: ARRAY
15372: PPUSH
15373: LD_INT 100
15375: PPUSH
15376: CALL_OW 234
// end ;
15380: PPOPN 1
15382: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
15383: LD_EXP 30
15387: PUSH
15388: LD_EXP 44
15392: AND
15393: IFFALSE 15491
15395: GO 15397
15397: DISABLE
15398: LD_INT 0
15400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15401: LD_ADDR_VAR 0 1
15405: PUSH
15406: LD_INT 22
15408: PUSH
15409: LD_OWVAR 2
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 21
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: PPUSH
15432: CALL_OW 69
15436: ST_TO_ADDR
// if not tmp then
15437: LD_VAR 0 1
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15491
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
15446: LD_VAR 0 1
15450: PUSH
15451: LD_INT 1
15453: PPUSH
15454: LD_VAR 0 1
15458: PPUSH
15459: CALL_OW 12
15463: ARRAY
15464: PPUSH
15465: LD_INT 1
15467: PPUSH
15468: LD_INT 4
15470: PPUSH
15471: CALL_OW 12
15475: PPUSH
15476: LD_INT 3000
15478: PPUSH
15479: LD_INT 9000
15481: PPUSH
15482: CALL_OW 12
15486: PPUSH
15487: CALL_OW 492
// end ;
15491: PPOPN 1
15493: END
// every 0 0$1 trigger StreamModeActive and sDepot do
15494: LD_EXP 30
15498: PUSH
15499: LD_EXP 45
15503: AND
15504: IFFALSE 15524
15506: GO 15508
15508: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
15509: LD_INT 1
15511: PPUSH
15512: LD_OWVAR 2
15516: PPUSH
15517: LD_INT 0
15519: PPUSH
15520: CALL_OW 324
15524: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
15525: LD_EXP 30
15529: PUSH
15530: LD_EXP 46
15534: AND
15535: IFFALSE 15618
15537: GO 15539
15539: DISABLE
15540: LD_INT 0
15542: PPUSH
15543: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15544: LD_ADDR_VAR 0 2
15548: PUSH
15549: LD_INT 22
15551: PUSH
15552: LD_OWVAR 2
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 21
15563: PUSH
15564: LD_INT 3
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PPUSH
15575: CALL_OW 69
15579: ST_TO_ADDR
// if not tmp then
15580: LD_VAR 0 2
15584: NOT
15585: IFFALSE 15589
// exit ;
15587: GO 15618
// for i in tmp do
15589: LD_ADDR_VAR 0 1
15593: PUSH
15594: LD_VAR 0 2
15598: PUSH
15599: FOR_IN
15600: IFFALSE 15616
// SetBLevel ( i , 10 ) ;
15602: LD_VAR 0 1
15606: PPUSH
15607: LD_INT 10
15609: PPUSH
15610: CALL_OW 241
15614: GO 15599
15616: POP
15617: POP
// end ;
15618: PPOPN 2
15620: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
15621: LD_EXP 30
15625: PUSH
15626: LD_EXP 47
15630: AND
15631: IFFALSE 15742
15633: GO 15635
15635: DISABLE
15636: LD_INT 0
15638: PPUSH
15639: PPUSH
15640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15641: LD_ADDR_VAR 0 3
15645: PUSH
15646: LD_INT 22
15648: PUSH
15649: LD_OWVAR 2
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: PUSH
15658: LD_INT 25
15660: PUSH
15661: LD_INT 1
15663: PUSH
15664: EMPTY
15665: LIST
15666: LIST
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PPUSH
15672: CALL_OW 69
15676: ST_TO_ADDR
// if not tmp then
15677: LD_VAR 0 3
15681: NOT
15682: IFFALSE 15686
// exit ;
15684: GO 15742
// un := tmp [ rand ( 1 , tmp ) ] ;
15686: LD_ADDR_VAR 0 2
15690: PUSH
15691: LD_VAR 0 3
15695: PUSH
15696: LD_INT 1
15698: PPUSH
15699: LD_VAR 0 3
15703: PPUSH
15704: CALL_OW 12
15708: ARRAY
15709: ST_TO_ADDR
// if Crawls ( un ) then
15710: LD_VAR 0 2
15714: PPUSH
15715: CALL_OW 318
15719: IFFALSE 15730
// ComWalk ( un ) ;
15721: LD_VAR 0 2
15725: PPUSH
15726: CALL_OW 138
// SetClass ( un , class_sniper ) ;
15730: LD_VAR 0 2
15734: PPUSH
15735: LD_INT 5
15737: PPUSH
15738: CALL_OW 336
// end ;
15742: PPOPN 3
15744: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
15745: LD_EXP 30
15749: PUSH
15750: LD_EXP 48
15754: AND
15755: PUSH
15756: LD_OWVAR 67
15760: PUSH
15761: LD_INT 3
15763: LESS
15764: AND
15765: IFFALSE 15784
15767: GO 15769
15769: DISABLE
// Difficulty := Difficulty + 1 ;
15770: LD_ADDR_OWVAR 67
15774: PUSH
15775: LD_OWVAR 67
15779: PUSH
15780: LD_INT 1
15782: PLUS
15783: ST_TO_ADDR
15784: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
15785: LD_EXP 30
15789: PUSH
15790: LD_EXP 49
15794: AND
15795: IFFALSE 15898
15797: GO 15799
15799: DISABLE
15800: LD_INT 0
15802: PPUSH
// begin for i := 1 to 5 do
15803: LD_ADDR_VAR 0 1
15807: PUSH
15808: DOUBLE
15809: LD_INT 1
15811: DEC
15812: ST_TO_ADDR
15813: LD_INT 5
15815: PUSH
15816: FOR_TO
15817: IFFALSE 15896
// begin uc_nation := nation_nature ;
15819: LD_ADDR_OWVAR 21
15823: PUSH
15824: LD_INT 0
15826: ST_TO_ADDR
// uc_side := 0 ;
15827: LD_ADDR_OWVAR 20
15831: PUSH
15832: LD_INT 0
15834: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15835: LD_ADDR_OWVAR 29
15839: PUSH
15840: LD_INT 12
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: ST_TO_ADDR
// hc_agressivity := 20 ;
15850: LD_ADDR_OWVAR 35
15854: PUSH
15855: LD_INT 20
15857: ST_TO_ADDR
// hc_class := class_tiger ;
15858: LD_ADDR_OWVAR 28
15862: PUSH
15863: LD_INT 14
15865: ST_TO_ADDR
// hc_gallery :=  ;
15866: LD_ADDR_OWVAR 33
15870: PUSH
15871: LD_STRING 
15873: ST_TO_ADDR
// hc_name :=  ;
15874: LD_ADDR_OWVAR 26
15878: PUSH
15879: LD_STRING 
15881: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15882: CALL_OW 44
15886: PPUSH
15887: LD_INT 0
15889: PPUSH
15890: CALL_OW 51
// end ;
15894: GO 15816
15896: POP
15897: POP
// end ;
15898: PPOPN 1
15900: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15901: LD_EXP 30
15905: PUSH
15906: LD_EXP 50
15910: AND
15911: IFFALSE 15920
15913: GO 15915
15915: DISABLE
// StreamSibBomb ;
15916: CALL 15921 0 0
15920: END
// export function StreamSibBomb ; var i , x , y ; begin
15921: LD_INT 0
15923: PPUSH
15924: PPUSH
15925: PPUSH
15926: PPUSH
// result := false ;
15927: LD_ADDR_VAR 0 1
15931: PUSH
15932: LD_INT 0
15934: ST_TO_ADDR
// for i := 1 to 16 do
15935: LD_ADDR_VAR 0 2
15939: PUSH
15940: DOUBLE
15941: LD_INT 1
15943: DEC
15944: ST_TO_ADDR
15945: LD_INT 16
15947: PUSH
15948: FOR_TO
15949: IFFALSE 16148
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15951: LD_ADDR_VAR 0 3
15955: PUSH
15956: LD_INT 10
15958: PUSH
15959: LD_INT 20
15961: PUSH
15962: LD_INT 30
15964: PUSH
15965: LD_INT 40
15967: PUSH
15968: LD_INT 50
15970: PUSH
15971: LD_INT 60
15973: PUSH
15974: LD_INT 70
15976: PUSH
15977: LD_INT 80
15979: PUSH
15980: LD_INT 90
15982: PUSH
15983: LD_INT 100
15985: PUSH
15986: LD_INT 110
15988: PUSH
15989: LD_INT 120
15991: PUSH
15992: LD_INT 130
15994: PUSH
15995: LD_INT 140
15997: PUSH
15998: LD_INT 150
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: PUSH
16018: LD_INT 1
16020: PPUSH
16021: LD_INT 15
16023: PPUSH
16024: CALL_OW 12
16028: ARRAY
16029: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16030: LD_ADDR_VAR 0 4
16034: PUSH
16035: LD_INT 10
16037: PUSH
16038: LD_INT 20
16040: PUSH
16041: LD_INT 30
16043: PUSH
16044: LD_INT 40
16046: PUSH
16047: LD_INT 50
16049: PUSH
16050: LD_INT 60
16052: PUSH
16053: LD_INT 70
16055: PUSH
16056: LD_INT 80
16058: PUSH
16059: LD_INT 90
16061: PUSH
16062: LD_INT 100
16064: PUSH
16065: LD_INT 110
16067: PUSH
16068: LD_INT 120
16070: PUSH
16071: LD_INT 130
16073: PUSH
16074: LD_INT 140
16076: PUSH
16077: LD_INT 150
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: LIST
16088: LIST
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: LIST
16095: LIST
16096: PUSH
16097: LD_INT 1
16099: PPUSH
16100: LD_INT 15
16102: PPUSH
16103: CALL_OW 12
16107: ARRAY
16108: ST_TO_ADDR
// if ValidHex ( x , y ) then
16109: LD_VAR 0 3
16113: PPUSH
16114: LD_VAR 0 4
16118: PPUSH
16119: CALL_OW 488
16123: IFFALSE 16146
// begin result := [ x , y ] ;
16125: LD_ADDR_VAR 0 1
16129: PUSH
16130: LD_VAR 0 3
16134: PUSH
16135: LD_VAR 0 4
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: ST_TO_ADDR
// break ;
16144: GO 16148
// end ; end ;
16146: GO 15948
16148: POP
16149: POP
// if result then
16150: LD_VAR 0 1
16154: IFFALSE 16214
// begin ToLua ( playSibBomb() ) ;
16156: LD_STRING playSibBomb()
16158: PPUSH
16159: CALL_OW 559
// wait ( 0 0$14 ) ;
16163: LD_INT 490
16165: PPUSH
16166: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
16170: LD_VAR 0 1
16174: PUSH
16175: LD_INT 1
16177: ARRAY
16178: PPUSH
16179: LD_VAR 0 1
16183: PUSH
16184: LD_INT 2
16186: ARRAY
16187: PPUSH
16188: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
16192: LD_VAR 0 1
16196: PUSH
16197: LD_INT 1
16199: ARRAY
16200: PPUSH
16201: LD_VAR 0 1
16205: PUSH
16206: LD_INT 2
16208: ARRAY
16209: PPUSH
16210: CALL_OW 429
// end ; end ;
16214: LD_VAR 0 1
16218: RET
// every 0 0$1 trigger StreamModeActive and sReset do
16219: LD_EXP 30
16223: PUSH
16224: LD_EXP 52
16228: AND
16229: IFFALSE 16241
16231: GO 16233
16233: DISABLE
// YouLost (  ) ;
16234: LD_STRING 
16236: PPUSH
16237: CALL_OW 104
16241: END
// every 0 0$1 trigger StreamModeActive and sFog do
16242: LD_EXP 30
16246: PUSH
16247: LD_EXP 51
16251: AND
16252: IFFALSE 16266
16254: GO 16256
16256: DISABLE
// FogOff ( your_side ) ;
16257: LD_OWVAR 2
16261: PPUSH
16262: CALL_OW 344
16266: END
// every 0 0$1 trigger StreamModeActive and sSun do
16267: LD_EXP 30
16271: PUSH
16272: LD_EXP 53
16276: AND
16277: IFFALSE 16305
16279: GO 16281
16281: DISABLE
// begin solar_recharge_percent := 0 ;
16282: LD_ADDR_OWVAR 79
16286: PUSH
16287: LD_INT 0
16289: ST_TO_ADDR
// wait ( 5 5$00 ) ;
16290: LD_INT 10500
16292: PPUSH
16293: CALL_OW 67
// solar_recharge_percent := 100 ;
16297: LD_ADDR_OWVAR 79
16301: PUSH
16302: LD_INT 100
16304: ST_TO_ADDR
// end ;
16305: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
16306: LD_EXP 30
16310: PUSH
16311: LD_EXP 54
16315: AND
16316: IFFALSE 16555
16318: GO 16320
16320: DISABLE
16321: LD_INT 0
16323: PPUSH
16324: PPUSH
16325: PPUSH
// begin tmp := [ ] ;
16326: LD_ADDR_VAR 0 3
16330: PUSH
16331: EMPTY
16332: ST_TO_ADDR
// for i := 1 to 6 do
16333: LD_ADDR_VAR 0 1
16337: PUSH
16338: DOUBLE
16339: LD_INT 1
16341: DEC
16342: ST_TO_ADDR
16343: LD_INT 6
16345: PUSH
16346: FOR_TO
16347: IFFALSE 16452
// begin uc_nation := nation_nature ;
16349: LD_ADDR_OWVAR 21
16353: PUSH
16354: LD_INT 0
16356: ST_TO_ADDR
// uc_side := 0 ;
16357: LD_ADDR_OWVAR 20
16361: PUSH
16362: LD_INT 0
16364: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16365: LD_ADDR_OWVAR 29
16369: PUSH
16370: LD_INT 12
16372: PUSH
16373: LD_INT 12
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: ST_TO_ADDR
// hc_agressivity := 20 ;
16380: LD_ADDR_OWVAR 35
16384: PUSH
16385: LD_INT 20
16387: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
16388: LD_ADDR_OWVAR 28
16392: PUSH
16393: LD_INT 17
16395: ST_TO_ADDR
// hc_gallery :=  ;
16396: LD_ADDR_OWVAR 33
16400: PUSH
16401: LD_STRING 
16403: ST_TO_ADDR
// hc_name :=  ;
16404: LD_ADDR_OWVAR 26
16408: PUSH
16409: LD_STRING 
16411: ST_TO_ADDR
// un := CreateHuman ;
16412: LD_ADDR_VAR 0 2
16416: PUSH
16417: CALL_OW 44
16421: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
16422: LD_VAR 0 2
16426: PPUSH
16427: LD_INT 1
16429: PPUSH
16430: CALL_OW 51
// tmp := tmp ^ un ;
16434: LD_ADDR_VAR 0 3
16438: PUSH
16439: LD_VAR 0 3
16443: PUSH
16444: LD_VAR 0 2
16448: ADD
16449: ST_TO_ADDR
// end ;
16450: GO 16346
16452: POP
16453: POP
// repeat wait ( 0 0$1 ) ;
16454: LD_INT 35
16456: PPUSH
16457: CALL_OW 67
// for un in tmp do
16461: LD_ADDR_VAR 0 2
16465: PUSH
16466: LD_VAR 0 3
16470: PUSH
16471: FOR_IN
16472: IFFALSE 16546
// begin if IsDead ( un ) then
16474: LD_VAR 0 2
16478: PPUSH
16479: CALL_OW 301
16483: IFFALSE 16503
// begin tmp := tmp diff un ;
16485: LD_ADDR_VAR 0 3
16489: PUSH
16490: LD_VAR 0 3
16494: PUSH
16495: LD_VAR 0 2
16499: DIFF
16500: ST_TO_ADDR
// continue ;
16501: GO 16471
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
16503: LD_VAR 0 2
16507: PPUSH
16508: LD_INT 3
16510: PUSH
16511: LD_INT 22
16513: PUSH
16514: LD_INT 0
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: PPUSH
16525: CALL_OW 69
16529: PPUSH
16530: LD_VAR 0 2
16534: PPUSH
16535: CALL_OW 74
16539: PPUSH
16540: CALL_OW 115
// end ;
16544: GO 16471
16546: POP
16547: POP
// until not tmp ;
16548: LD_VAR 0 3
16552: NOT
16553: IFFALSE 16454
// end ;
16555: PPOPN 3
16557: END
// every 0 0$1 trigger StreamModeActive and sTroll do
16558: LD_EXP 30
16562: PUSH
16563: LD_EXP 55
16567: AND
16568: IFFALSE 16622
16570: GO 16572
16572: DISABLE
// begin ToLua ( displayTroll(); ) ;
16573: LD_STRING displayTroll();
16575: PPUSH
16576: CALL_OW 559
// wait ( 3 3$00 ) ;
16580: LD_INT 6300
16582: PPUSH
16583: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16587: LD_STRING hideTroll();
16589: PPUSH
16590: CALL_OW 559
// wait ( 1 1$00 ) ;
16594: LD_INT 2100
16596: PPUSH
16597: CALL_OW 67
// ToLua ( displayTroll(); ) ;
16601: LD_STRING displayTroll();
16603: PPUSH
16604: CALL_OW 559
// wait ( 1 1$00 ) ;
16608: LD_INT 2100
16610: PPUSH
16611: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16615: LD_STRING hideTroll();
16617: PPUSH
16618: CALL_OW 559
// end ;
16622: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
16623: LD_EXP 30
16627: PUSH
16628: LD_EXP 56
16632: AND
16633: IFFALSE 16696
16635: GO 16637
16637: DISABLE
16638: LD_INT 0
16640: PPUSH
// begin p := 0 ;
16641: LD_ADDR_VAR 0 1
16645: PUSH
16646: LD_INT 0
16648: ST_TO_ADDR
// repeat game_speed := 1 ;
16649: LD_ADDR_OWVAR 65
16653: PUSH
16654: LD_INT 1
16656: ST_TO_ADDR
// wait ( 0 0$1 ) ;
16657: LD_INT 35
16659: PPUSH
16660: CALL_OW 67
// p := p + 1 ;
16664: LD_ADDR_VAR 0 1
16668: PUSH
16669: LD_VAR 0 1
16673: PUSH
16674: LD_INT 1
16676: PLUS
16677: ST_TO_ADDR
// until p >= 60 ;
16678: LD_VAR 0 1
16682: PUSH
16683: LD_INT 60
16685: GREATEREQUAL
16686: IFFALSE 16649
// game_speed := 4 ;
16688: LD_ADDR_OWVAR 65
16692: PUSH
16693: LD_INT 4
16695: ST_TO_ADDR
// end ;
16696: PPOPN 1
16698: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
16699: LD_EXP 30
16703: PUSH
16704: LD_EXP 57
16708: AND
16709: IFFALSE 16855
16711: GO 16713
16713: DISABLE
16714: LD_INT 0
16716: PPUSH
16717: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16718: LD_ADDR_VAR 0 1
16722: PUSH
16723: LD_INT 22
16725: PUSH
16726: LD_OWVAR 2
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: PUSH
16735: LD_INT 2
16737: PUSH
16738: LD_INT 30
16740: PUSH
16741: LD_INT 0
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 30
16750: PUSH
16751: LD_INT 1
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: LIST
16762: PUSH
16763: EMPTY
16764: LIST
16765: LIST
16766: PPUSH
16767: CALL_OW 69
16771: ST_TO_ADDR
// if not depot then
16772: LD_VAR 0 1
16776: NOT
16777: IFFALSE 16781
// exit ;
16779: GO 16855
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
16781: LD_ADDR_VAR 0 2
16785: PUSH
16786: LD_VAR 0 1
16790: PUSH
16791: LD_INT 1
16793: PPUSH
16794: LD_VAR 0 1
16798: PPUSH
16799: CALL_OW 12
16803: ARRAY
16804: PPUSH
16805: CALL_OW 274
16809: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
16810: LD_VAR 0 2
16814: PPUSH
16815: LD_INT 1
16817: PPUSH
16818: LD_INT 0
16820: PPUSH
16821: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
16825: LD_VAR 0 2
16829: PPUSH
16830: LD_INT 2
16832: PPUSH
16833: LD_INT 0
16835: PPUSH
16836: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
16840: LD_VAR 0 2
16844: PPUSH
16845: LD_INT 3
16847: PPUSH
16848: LD_INT 0
16850: PPUSH
16851: CALL_OW 277
// end ;
16855: PPOPN 2
16857: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16858: LD_EXP 30
16862: PUSH
16863: LD_EXP 58
16867: AND
16868: IFFALSE 16965
16870: GO 16872
16872: DISABLE
16873: LD_INT 0
16875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16876: LD_ADDR_VAR 0 1
16880: PUSH
16881: LD_INT 22
16883: PUSH
16884: LD_OWVAR 2
16888: PUSH
16889: EMPTY
16890: LIST
16891: LIST
16892: PUSH
16893: LD_INT 21
16895: PUSH
16896: LD_INT 1
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 3
16905: PUSH
16906: LD_INT 23
16908: PUSH
16909: LD_INT 0
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: PPUSH
16925: CALL_OW 69
16929: ST_TO_ADDR
// if not tmp then
16930: LD_VAR 0 1
16934: NOT
16935: IFFALSE 16939
// exit ;
16937: GO 16965
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16939: LD_VAR 0 1
16943: PUSH
16944: LD_INT 1
16946: PPUSH
16947: LD_VAR 0 1
16951: PPUSH
16952: CALL_OW 12
16956: ARRAY
16957: PPUSH
16958: LD_INT 200
16960: PPUSH
16961: CALL_OW 234
// end ;
16965: PPOPN 1
16967: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
16968: LD_EXP 30
16972: PUSH
16973: LD_EXP 59
16977: AND
16978: IFFALSE 17057
16980: GO 16982
16982: DISABLE
16983: LD_INT 0
16985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
16986: LD_ADDR_VAR 0 1
16990: PUSH
16991: LD_INT 22
16993: PUSH
16994: LD_OWVAR 2
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PUSH
17003: LD_INT 21
17005: PUSH
17006: LD_INT 2
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: PPUSH
17017: CALL_OW 69
17021: ST_TO_ADDR
// if not tmp then
17022: LD_VAR 0 1
17026: NOT
17027: IFFALSE 17031
// exit ;
17029: GO 17057
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
17031: LD_VAR 0 1
17035: PUSH
17036: LD_INT 1
17038: PPUSH
17039: LD_VAR 0 1
17043: PPUSH
17044: CALL_OW 12
17048: ARRAY
17049: PPUSH
17050: LD_INT 60
17052: PPUSH
17053: CALL_OW 234
// end ;
17057: PPOPN 1
17059: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
17060: LD_EXP 30
17064: PUSH
17065: LD_EXP 60
17069: AND
17070: IFFALSE 17169
17072: GO 17074
17074: DISABLE
17075: LD_INT 0
17077: PPUSH
17078: PPUSH
// begin enable ;
17079: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
17080: LD_ADDR_VAR 0 1
17084: PUSH
17085: LD_INT 22
17087: PUSH
17088: LD_OWVAR 2
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: PUSH
17097: LD_INT 61
17099: PUSH
17100: EMPTY
17101: LIST
17102: PUSH
17103: LD_INT 33
17105: PUSH
17106: LD_INT 2
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: PPUSH
17118: CALL_OW 69
17122: ST_TO_ADDR
// if not tmp then
17123: LD_VAR 0 1
17127: NOT
17128: IFFALSE 17132
// exit ;
17130: GO 17169
// for i in tmp do
17132: LD_ADDR_VAR 0 2
17136: PUSH
17137: LD_VAR 0 1
17141: PUSH
17142: FOR_IN
17143: IFFALSE 17167
// if IsControledBy ( i ) then
17145: LD_VAR 0 2
17149: PPUSH
17150: CALL_OW 312
17154: IFFALSE 17165
// ComUnlink ( i ) ;
17156: LD_VAR 0 2
17160: PPUSH
17161: CALL_OW 136
17165: GO 17142
17167: POP
17168: POP
// end ;
17169: PPOPN 2
17171: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
17172: LD_EXP 30
17176: PUSH
17177: LD_EXP 61
17181: AND
17182: IFFALSE 17316
17184: GO 17186
17186: DISABLE
17187: LD_INT 0
17189: PPUSH
17190: PPUSH
// begin ToLua ( displayPowell(); ) ;
17191: LD_STRING displayPowell();
17193: PPUSH
17194: CALL_OW 559
// uc_side := 0 ;
17198: LD_ADDR_OWVAR 20
17202: PUSH
17203: LD_INT 0
17205: ST_TO_ADDR
// uc_nation := 2 ;
17206: LD_ADDR_OWVAR 21
17210: PUSH
17211: LD_INT 2
17213: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
17214: LD_ADDR_OWVAR 37
17218: PUSH
17219: LD_INT 14
17221: ST_TO_ADDR
// vc_engine := engine_siberite ;
17222: LD_ADDR_OWVAR 39
17226: PUSH
17227: LD_INT 3
17229: ST_TO_ADDR
// vc_control := control_apeman ;
17230: LD_ADDR_OWVAR 38
17234: PUSH
17235: LD_INT 5
17237: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
17238: LD_ADDR_OWVAR 40
17242: PUSH
17243: LD_INT 29
17245: ST_TO_ADDR
// un := CreateVehicle ;
17246: LD_ADDR_VAR 0 2
17250: PUSH
17251: CALL_OW 45
17255: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17256: LD_VAR 0 2
17260: PPUSH
17261: LD_INT 1
17263: PPUSH
17264: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17268: LD_INT 35
17270: PPUSH
17271: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_OWVAR 3
17284: PUSH
17285: LD_VAR 0 2
17289: DIFF
17290: PPUSH
17291: LD_VAR 0 2
17295: PPUSH
17296: CALL_OW 74
17300: PPUSH
17301: CALL_OW 115
// until IsOk ( un ) ;
17305: LD_VAR 0 2
17309: PPUSH
17310: CALL_OW 302
17314: IFFALSE 17268
// end ;
17316: PPOPN 2
17318: END
// every 0 0$1 trigger StreamModeActive and sStu do
17319: LD_EXP 30
17323: PUSH
17324: LD_EXP 69
17328: AND
17329: IFFALSE 17341
17331: GO 17333
17333: DISABLE
// begin ToLua ( displayStucuk(); ) ;
17334: LD_STRING displayStucuk();
17336: PPUSH
17337: CALL_OW 559
// end ;
17341: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
17342: LD_EXP 30
17346: PUSH
17347: LD_EXP 62
17351: AND
17352: IFFALSE 17493
17354: GO 17356
17356: DISABLE
17357: LD_INT 0
17359: PPUSH
17360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17361: LD_ADDR_VAR 0 2
17365: PUSH
17366: LD_INT 22
17368: PUSH
17369: LD_OWVAR 2
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PUSH
17378: LD_INT 21
17380: PUSH
17381: LD_INT 1
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: PUSH
17388: EMPTY
17389: LIST
17390: LIST
17391: PPUSH
17392: CALL_OW 69
17396: ST_TO_ADDR
// if not tmp then
17397: LD_VAR 0 2
17401: NOT
17402: IFFALSE 17406
// exit ;
17404: GO 17493
// un := tmp [ rand ( 1 , tmp ) ] ;
17406: LD_ADDR_VAR 0 1
17410: PUSH
17411: LD_VAR 0 2
17415: PUSH
17416: LD_INT 1
17418: PPUSH
17419: LD_VAR 0 2
17423: PPUSH
17424: CALL_OW 12
17428: ARRAY
17429: ST_TO_ADDR
// SetSide ( un , 0 ) ;
17430: LD_VAR 0 1
17434: PPUSH
17435: LD_INT 0
17437: PPUSH
17438: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
17442: LD_VAR 0 1
17446: PPUSH
17447: LD_OWVAR 3
17451: PUSH
17452: LD_VAR 0 1
17456: DIFF
17457: PPUSH
17458: LD_VAR 0 1
17462: PPUSH
17463: CALL_OW 74
17467: PPUSH
17468: CALL_OW 115
// wait ( 0 0$20 ) ;
17472: LD_INT 700
17474: PPUSH
17475: CALL_OW 67
// SetSide ( un , your_side ) ;
17479: LD_VAR 0 1
17483: PPUSH
17484: LD_OWVAR 2
17488: PPUSH
17489: CALL_OW 235
// end ;
17493: PPOPN 2
17495: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
17496: LD_EXP 30
17500: PUSH
17501: LD_EXP 63
17505: AND
17506: IFFALSE 17612
17508: GO 17510
17510: DISABLE
17511: LD_INT 0
17513: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
17514: LD_ADDR_VAR 0 1
17518: PUSH
17519: LD_INT 22
17521: PUSH
17522: LD_OWVAR 2
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: PUSH
17531: LD_INT 2
17533: PUSH
17534: LD_INT 30
17536: PUSH
17537: LD_INT 0
17539: PUSH
17540: EMPTY
17541: LIST
17542: LIST
17543: PUSH
17544: LD_INT 30
17546: PUSH
17547: LD_INT 1
17549: PUSH
17550: EMPTY
17551: LIST
17552: LIST
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: LIST
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: PPUSH
17563: CALL_OW 69
17567: ST_TO_ADDR
// if not depot then
17568: LD_VAR 0 1
17572: NOT
17573: IFFALSE 17577
// exit ;
17575: GO 17612
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
17577: LD_VAR 0 1
17581: PUSH
17582: LD_INT 1
17584: ARRAY
17585: PPUSH
17586: CALL_OW 250
17590: PPUSH
17591: LD_VAR 0 1
17595: PUSH
17596: LD_INT 1
17598: ARRAY
17599: PPUSH
17600: CALL_OW 251
17604: PPUSH
17605: LD_INT 70
17607: PPUSH
17608: CALL_OW 495
// end ;
17612: PPOPN 1
17614: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
17615: LD_EXP 30
17619: PUSH
17620: LD_EXP 64
17624: AND
17625: IFFALSE 17836
17627: GO 17629
17629: DISABLE
17630: LD_INT 0
17632: PPUSH
17633: PPUSH
17634: PPUSH
17635: PPUSH
17636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17637: LD_ADDR_VAR 0 5
17641: PUSH
17642: LD_INT 22
17644: PUSH
17645: LD_OWVAR 2
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: PUSH
17654: LD_INT 21
17656: PUSH
17657: LD_INT 1
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: EMPTY
17665: LIST
17666: LIST
17667: PPUSH
17668: CALL_OW 69
17672: ST_TO_ADDR
// if not tmp then
17673: LD_VAR 0 5
17677: NOT
17678: IFFALSE 17682
// exit ;
17680: GO 17836
// for i in tmp do
17682: LD_ADDR_VAR 0 1
17686: PUSH
17687: LD_VAR 0 5
17691: PUSH
17692: FOR_IN
17693: IFFALSE 17834
// begin d := rand ( 0 , 5 ) ;
17695: LD_ADDR_VAR 0 4
17699: PUSH
17700: LD_INT 0
17702: PPUSH
17703: LD_INT 5
17705: PPUSH
17706: CALL_OW 12
17710: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
17711: LD_ADDR_VAR 0 2
17715: PUSH
17716: LD_VAR 0 1
17720: PPUSH
17721: CALL_OW 250
17725: PPUSH
17726: LD_VAR 0 4
17730: PPUSH
17731: LD_INT 3
17733: PPUSH
17734: LD_INT 12
17736: PPUSH
17737: CALL_OW 12
17741: PPUSH
17742: CALL_OW 272
17746: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 1
17756: PPUSH
17757: CALL_OW 251
17761: PPUSH
17762: LD_VAR 0 4
17766: PPUSH
17767: LD_INT 3
17769: PPUSH
17770: LD_INT 12
17772: PPUSH
17773: CALL_OW 12
17777: PPUSH
17778: CALL_OW 273
17782: ST_TO_ADDR
// if ValidHex ( x , y ) then
17783: LD_VAR 0 2
17787: PPUSH
17788: LD_VAR 0 3
17792: PPUSH
17793: CALL_OW 488
17797: IFFALSE 17832
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
17799: LD_VAR 0 1
17803: PPUSH
17804: LD_VAR 0 2
17808: PPUSH
17809: LD_VAR 0 3
17813: PPUSH
17814: LD_INT 3
17816: PPUSH
17817: LD_INT 6
17819: PPUSH
17820: CALL_OW 12
17824: PPUSH
17825: LD_INT 1
17827: PPUSH
17828: CALL_OW 483
// end ;
17832: GO 17692
17834: POP
17835: POP
// end ;
17836: PPOPN 5
17838: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17839: LD_EXP 30
17843: PUSH
17844: LD_EXP 65
17848: AND
17849: IFFALSE 17943
17851: GO 17853
17853: DISABLE
17854: LD_INT 0
17856: PPUSH
17857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17858: LD_ADDR_VAR 0 2
17862: PUSH
17863: LD_INT 22
17865: PUSH
17866: LD_OWVAR 2
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 32
17877: PUSH
17878: LD_INT 1
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: LD_INT 21
17887: PUSH
17888: LD_INT 2
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: PPUSH
17900: CALL_OW 69
17904: ST_TO_ADDR
// if not tmp then
17905: LD_VAR 0 2
17909: NOT
17910: IFFALSE 17914
// exit ;
17912: GO 17943
// for i in tmp do
17914: LD_ADDR_VAR 0 1
17918: PUSH
17919: LD_VAR 0 2
17923: PUSH
17924: FOR_IN
17925: IFFALSE 17941
// SetFuel ( i , 0 ) ;
17927: LD_VAR 0 1
17931: PPUSH
17932: LD_INT 0
17934: PPUSH
17935: CALL_OW 240
17939: GO 17924
17941: POP
17942: POP
// end ;
17943: PPOPN 2
17945: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17946: LD_EXP 30
17950: PUSH
17951: LD_EXP 66
17955: AND
17956: IFFALSE 18022
17958: GO 17960
17960: DISABLE
17961: LD_INT 0
17963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17964: LD_ADDR_VAR 0 1
17968: PUSH
17969: LD_INT 22
17971: PUSH
17972: LD_OWVAR 2
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 30
17983: PUSH
17984: LD_INT 29
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PPUSH
17995: CALL_OW 69
17999: ST_TO_ADDR
// if not tmp then
18000: LD_VAR 0 1
18004: NOT
18005: IFFALSE 18009
// exit ;
18007: GO 18022
// DestroyUnit ( tmp [ 1 ] ) ;
18009: LD_VAR 0 1
18013: PUSH
18014: LD_INT 1
18016: ARRAY
18017: PPUSH
18018: CALL_OW 65
// end ;
18022: PPOPN 1
18024: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
18025: LD_EXP 30
18029: PUSH
18030: LD_EXP 68
18034: AND
18035: IFFALSE 18164
18037: GO 18039
18039: DISABLE
18040: LD_INT 0
18042: PPUSH
// begin uc_side := 0 ;
18043: LD_ADDR_OWVAR 20
18047: PUSH
18048: LD_INT 0
18050: ST_TO_ADDR
// uc_nation := nation_arabian ;
18051: LD_ADDR_OWVAR 21
18055: PUSH
18056: LD_INT 2
18058: ST_TO_ADDR
// hc_gallery :=  ;
18059: LD_ADDR_OWVAR 33
18063: PUSH
18064: LD_STRING 
18066: ST_TO_ADDR
// hc_name :=  ;
18067: LD_ADDR_OWVAR 26
18071: PUSH
18072: LD_STRING 
18074: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
18075: LD_INT 1
18077: PPUSH
18078: LD_INT 11
18080: PPUSH
18081: LD_INT 10
18083: PPUSH
18084: CALL_OW 380
// un := CreateHuman ;
18088: LD_ADDR_VAR 0 1
18092: PUSH
18093: CALL_OW 44
18097: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18098: LD_VAR 0 1
18102: PPUSH
18103: LD_INT 1
18105: PPUSH
18106: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18110: LD_INT 35
18112: PPUSH
18113: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18117: LD_VAR 0 1
18121: PPUSH
18122: LD_INT 22
18124: PUSH
18125: LD_OWVAR 2
18129: PUSH
18130: EMPTY
18131: LIST
18132: LIST
18133: PPUSH
18134: CALL_OW 69
18138: PPUSH
18139: LD_VAR 0 1
18143: PPUSH
18144: CALL_OW 74
18148: PPUSH
18149: CALL_OW 115
// until IsDead ( un ) ;
18153: LD_VAR 0 1
18157: PPUSH
18158: CALL_OW 301
18162: IFFALSE 18110
// end ;
18164: PPOPN 1
18166: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
18167: LD_EXP 30
18171: PUSH
18172: LD_EXP 70
18176: AND
18177: IFFALSE 18189
18179: GO 18181
18181: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
18182: LD_STRING earthquake(getX(game), 0, 32)
18184: PPUSH
18185: CALL_OW 559
18189: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
18190: LD_EXP 30
18194: PUSH
18195: LD_EXP 71
18199: AND
18200: IFFALSE 18291
18202: GO 18204
18204: DISABLE
18205: LD_INT 0
18207: PPUSH
// begin enable ;
18208: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
18209: LD_ADDR_VAR 0 1
18213: PUSH
18214: LD_INT 22
18216: PUSH
18217: LD_OWVAR 2
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PUSH
18226: LD_INT 21
18228: PUSH
18229: LD_INT 2
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: PUSH
18236: LD_INT 33
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: PUSH
18246: EMPTY
18247: LIST
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 69
18255: ST_TO_ADDR
// if not tmp then
18256: LD_VAR 0 1
18260: NOT
18261: IFFALSE 18265
// exit ;
18263: GO 18291
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18265: LD_VAR 0 1
18269: PUSH
18270: LD_INT 1
18272: PPUSH
18273: LD_VAR 0 1
18277: PPUSH
18278: CALL_OW 12
18282: ARRAY
18283: PPUSH
18284: LD_INT 1
18286: PPUSH
18287: CALL_OW 234
// end ;
18291: PPOPN 1
18293: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
18294: LD_EXP 30
18298: PUSH
18299: LD_EXP 72
18303: AND
18304: IFFALSE 18445
18306: GO 18308
18308: DISABLE
18309: LD_INT 0
18311: PPUSH
18312: PPUSH
18313: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18314: LD_ADDR_VAR 0 3
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_OWVAR 2
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PUSH
18331: LD_INT 25
18333: PUSH
18334: LD_INT 1
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PPUSH
18345: CALL_OW 69
18349: ST_TO_ADDR
// if not tmp then
18350: LD_VAR 0 3
18354: NOT
18355: IFFALSE 18359
// exit ;
18357: GO 18445
// un := tmp [ rand ( 1 , tmp ) ] ;
18359: LD_ADDR_VAR 0 2
18363: PUSH
18364: LD_VAR 0 3
18368: PUSH
18369: LD_INT 1
18371: PPUSH
18372: LD_VAR 0 3
18376: PPUSH
18377: CALL_OW 12
18381: ARRAY
18382: ST_TO_ADDR
// if Crawls ( un ) then
18383: LD_VAR 0 2
18387: PPUSH
18388: CALL_OW 318
18392: IFFALSE 18403
// ComWalk ( un ) ;
18394: LD_VAR 0 2
18398: PPUSH
18399: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
18403: LD_VAR 0 2
18407: PPUSH
18408: LD_INT 9
18410: PPUSH
18411: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
18415: LD_INT 28
18417: PPUSH
18418: LD_OWVAR 2
18422: PPUSH
18423: LD_INT 2
18425: PPUSH
18426: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
18430: LD_INT 29
18432: PPUSH
18433: LD_OWVAR 2
18437: PPUSH
18438: LD_INT 2
18440: PPUSH
18441: CALL_OW 322
// end ;
18445: PPOPN 3
18447: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
18448: LD_EXP 30
18452: PUSH
18453: LD_EXP 73
18457: AND
18458: IFFALSE 18569
18460: GO 18462
18462: DISABLE
18463: LD_INT 0
18465: PPUSH
18466: PPUSH
18467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18468: LD_ADDR_VAR 0 3
18472: PUSH
18473: LD_INT 22
18475: PUSH
18476: LD_OWVAR 2
18480: PUSH
18481: EMPTY
18482: LIST
18483: LIST
18484: PUSH
18485: LD_INT 25
18487: PUSH
18488: LD_INT 1
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PPUSH
18499: CALL_OW 69
18503: ST_TO_ADDR
// if not tmp then
18504: LD_VAR 0 3
18508: NOT
18509: IFFALSE 18513
// exit ;
18511: GO 18569
// un := tmp [ rand ( 1 , tmp ) ] ;
18513: LD_ADDR_VAR 0 2
18517: PUSH
18518: LD_VAR 0 3
18522: PUSH
18523: LD_INT 1
18525: PPUSH
18526: LD_VAR 0 3
18530: PPUSH
18531: CALL_OW 12
18535: ARRAY
18536: ST_TO_ADDR
// if Crawls ( un ) then
18537: LD_VAR 0 2
18541: PPUSH
18542: CALL_OW 318
18546: IFFALSE 18557
// ComWalk ( un ) ;
18548: LD_VAR 0 2
18552: PPUSH
18553: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18557: LD_VAR 0 2
18561: PPUSH
18562: LD_INT 8
18564: PPUSH
18565: CALL_OW 336
// end ;
18569: PPOPN 3
18571: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
18572: LD_EXP 30
18576: PUSH
18577: LD_EXP 74
18581: AND
18582: IFFALSE 18726
18584: GO 18586
18586: DISABLE
18587: LD_INT 0
18589: PPUSH
18590: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
18591: LD_ADDR_VAR 0 2
18595: PUSH
18596: LD_INT 22
18598: PUSH
18599: LD_OWVAR 2
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PUSH
18608: LD_INT 21
18610: PUSH
18611: LD_INT 2
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PUSH
18618: LD_INT 2
18620: PUSH
18621: LD_INT 34
18623: PUSH
18624: LD_INT 12
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: PUSH
18631: LD_INT 34
18633: PUSH
18634: LD_INT 51
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 34
18643: PUSH
18644: LD_INT 32
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: LIST
18661: PPUSH
18662: CALL_OW 69
18666: ST_TO_ADDR
// if not tmp then
18667: LD_VAR 0 2
18671: NOT
18672: IFFALSE 18676
// exit ;
18674: GO 18726
// for i in tmp do
18676: LD_ADDR_VAR 0 1
18680: PUSH
18681: LD_VAR 0 2
18685: PUSH
18686: FOR_IN
18687: IFFALSE 18724
// if GetCargo ( i , mat_artifact ) = 0 then
18689: LD_VAR 0 1
18693: PPUSH
18694: LD_INT 4
18696: PPUSH
18697: CALL_OW 289
18701: PUSH
18702: LD_INT 0
18704: EQUAL
18705: IFFALSE 18722
// SetCargo ( i , mat_siberit , 100 ) ;
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 3
18714: PPUSH
18715: LD_INT 100
18717: PPUSH
18718: CALL_OW 290
18722: GO 18686
18724: POP
18725: POP
// end ;
18726: PPOPN 2
18728: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
18729: LD_EXP 30
18733: PUSH
18734: LD_EXP 75
18738: AND
18739: IFFALSE 18892
18741: GO 18743
18743: DISABLE
18744: LD_INT 0
18746: PPUSH
18747: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
18748: LD_ADDR_VAR 0 2
18752: PUSH
18753: LD_INT 22
18755: PUSH
18756: LD_OWVAR 2
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PPUSH
18765: CALL_OW 69
18769: ST_TO_ADDR
// if not tmp then
18770: LD_VAR 0 2
18774: NOT
18775: IFFALSE 18779
// exit ;
18777: GO 18892
// for i := 1 to 2 do
18779: LD_ADDR_VAR 0 1
18783: PUSH
18784: DOUBLE
18785: LD_INT 1
18787: DEC
18788: ST_TO_ADDR
18789: LD_INT 2
18791: PUSH
18792: FOR_TO
18793: IFFALSE 18890
// begin uc_side := your_side ;
18795: LD_ADDR_OWVAR 20
18799: PUSH
18800: LD_OWVAR 2
18804: ST_TO_ADDR
// uc_nation := nation_american ;
18805: LD_ADDR_OWVAR 21
18809: PUSH
18810: LD_INT 1
18812: ST_TO_ADDR
// vc_chassis := us_morphling ;
18813: LD_ADDR_OWVAR 37
18817: PUSH
18818: LD_INT 5
18820: ST_TO_ADDR
// vc_engine := engine_siberite ;
18821: LD_ADDR_OWVAR 39
18825: PUSH
18826: LD_INT 3
18828: ST_TO_ADDR
// vc_control := control_computer ;
18829: LD_ADDR_OWVAR 38
18833: PUSH
18834: LD_INT 3
18836: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18837: LD_ADDR_OWVAR 40
18841: PUSH
18842: LD_INT 10
18844: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18845: CALL_OW 45
18849: PPUSH
18850: LD_VAR 0 2
18854: PUSH
18855: LD_INT 1
18857: ARRAY
18858: PPUSH
18859: CALL_OW 250
18863: PPUSH
18864: LD_VAR 0 2
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: PPUSH
18873: CALL_OW 251
18877: PPUSH
18878: LD_INT 12
18880: PPUSH
18881: LD_INT 1
18883: PPUSH
18884: CALL_OW 50
// end ;
18888: GO 18792
18890: POP
18891: POP
// end ;
18892: PPOPN 2
18894: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18895: LD_EXP 30
18899: PUSH
18900: LD_EXP 76
18904: AND
18905: IFFALSE 19127
18907: GO 18909
18909: DISABLE
18910: LD_INT 0
18912: PPUSH
18913: PPUSH
18914: PPUSH
18915: PPUSH
18916: PPUSH
18917: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18918: LD_ADDR_VAR 0 6
18922: PUSH
18923: LD_INT 22
18925: PUSH
18926: LD_OWVAR 2
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PUSH
18935: LD_INT 21
18937: PUSH
18938: LD_INT 1
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: PUSH
18945: LD_INT 3
18947: PUSH
18948: LD_INT 23
18950: PUSH
18951: LD_INT 0
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: LIST
18966: PPUSH
18967: CALL_OW 69
18971: ST_TO_ADDR
// if not tmp then
18972: LD_VAR 0 6
18976: NOT
18977: IFFALSE 18981
// exit ;
18979: GO 19127
// s1 := rand ( 1 , 4 ) ;
18981: LD_ADDR_VAR 0 2
18985: PUSH
18986: LD_INT 1
18988: PPUSH
18989: LD_INT 4
18991: PPUSH
18992: CALL_OW 12
18996: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18997: LD_ADDR_VAR 0 4
19001: PUSH
19002: LD_VAR 0 6
19006: PUSH
19007: LD_INT 1
19009: ARRAY
19010: PPUSH
19011: LD_VAR 0 2
19015: PPUSH
19016: CALL_OW 259
19020: ST_TO_ADDR
// if s1 = 1 then
19021: LD_VAR 0 2
19025: PUSH
19026: LD_INT 1
19028: EQUAL
19029: IFFALSE 19049
// s2 := rand ( 2 , 4 ) else
19031: LD_ADDR_VAR 0 3
19035: PUSH
19036: LD_INT 2
19038: PPUSH
19039: LD_INT 4
19041: PPUSH
19042: CALL_OW 12
19046: ST_TO_ADDR
19047: GO 19057
// s2 := 1 ;
19049: LD_ADDR_VAR 0 3
19053: PUSH
19054: LD_INT 1
19056: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
19057: LD_ADDR_VAR 0 5
19061: PUSH
19062: LD_VAR 0 6
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: LD_VAR 0 3
19075: PPUSH
19076: CALL_OW 259
19080: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
19081: LD_VAR 0 6
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: LD_VAR 0 2
19094: PPUSH
19095: LD_VAR 0 5
19099: PPUSH
19100: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
19104: LD_VAR 0 6
19108: PUSH
19109: LD_INT 1
19111: ARRAY
19112: PPUSH
19113: LD_VAR 0 3
19117: PPUSH
19118: LD_VAR 0 4
19122: PPUSH
19123: CALL_OW 237
// end ;
19127: PPOPN 6
19129: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
19130: LD_EXP 30
19134: PUSH
19135: LD_EXP 77
19139: AND
19140: IFFALSE 19219
19142: GO 19144
19144: DISABLE
19145: LD_INT 0
19147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
19148: LD_ADDR_VAR 0 1
19152: PUSH
19153: LD_INT 22
19155: PUSH
19156: LD_OWVAR 2
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 3
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: PPUSH
19179: CALL_OW 69
19183: ST_TO_ADDR
// if not tmp then
19184: LD_VAR 0 1
19188: NOT
19189: IFFALSE 19193
// exit ;
19191: GO 19219
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19193: LD_VAR 0 1
19197: PUSH
19198: LD_INT 1
19200: PPUSH
19201: LD_VAR 0 1
19205: PPUSH
19206: CALL_OW 12
19210: ARRAY
19211: PPUSH
19212: LD_INT 1
19214: PPUSH
19215: CALL_OW 234
// end ;
19219: PPOPN 1
19221: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
19222: LD_EXP 30
19226: PUSH
19227: LD_EXP 78
19231: AND
19232: IFFALSE 19344
19234: GO 19236
19236: DISABLE
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
19241: LD_ADDR_VAR 0 2
19245: PUSH
19246: LD_INT 22
19248: PUSH
19249: LD_OWVAR 2
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PUSH
19258: LD_INT 2
19260: PUSH
19261: LD_INT 30
19263: PUSH
19264: LD_INT 27
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: PUSH
19271: LD_INT 30
19273: PUSH
19274: LD_INT 26
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: PUSH
19281: LD_INT 30
19283: PUSH
19284: LD_INT 28
19286: PUSH
19287: EMPTY
19288: LIST
19289: LIST
19290: PUSH
19291: EMPTY
19292: LIST
19293: LIST
19294: LIST
19295: LIST
19296: PUSH
19297: EMPTY
19298: LIST
19299: LIST
19300: PPUSH
19301: CALL_OW 69
19305: ST_TO_ADDR
// if not tmp then
19306: LD_VAR 0 2
19310: NOT
19311: IFFALSE 19315
// exit ;
19313: GO 19344
// for i in tmp do
19315: LD_ADDR_VAR 0 1
19319: PUSH
19320: LD_VAR 0 2
19324: PUSH
19325: FOR_IN
19326: IFFALSE 19342
// SetLives ( i , 1 ) ;
19328: LD_VAR 0 1
19332: PPUSH
19333: LD_INT 1
19335: PPUSH
19336: CALL_OW 234
19340: GO 19325
19342: POP
19343: POP
// end ;
19344: PPOPN 2
19346: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
19347: LD_EXP 30
19351: PUSH
19352: LD_EXP 79
19356: AND
19357: IFFALSE 19627
19359: GO 19361
19361: DISABLE
19362: LD_INT 0
19364: PPUSH
19365: PPUSH
19366: PPUSH
// begin i := rand ( 1 , 7 ) ;
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: LD_INT 1
19374: PPUSH
19375: LD_INT 7
19377: PPUSH
19378: CALL_OW 12
19382: ST_TO_ADDR
// case i of 1 :
19383: LD_VAR 0 1
19387: PUSH
19388: LD_INT 1
19390: DOUBLE
19391: EQUAL
19392: IFTRUE 19396
19394: GO 19406
19396: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
19397: LD_STRING earthquake(getX(game), 0, 32)
19399: PPUSH
19400: CALL_OW 559
19404: GO 19627
19406: LD_INT 2
19408: DOUBLE
19409: EQUAL
19410: IFTRUE 19414
19412: GO 19424
19414: POP
// ToLua ( displayStucuk(); ) ; 3 :
19415: LD_STRING displayStucuk();
19417: PPUSH
19418: CALL_OW 559
19422: GO 19627
19424: LD_INT 3
19426: DOUBLE
19427: EQUAL
19428: IFTRUE 19432
19430: GO 19536
19432: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19433: LD_ADDR_VAR 0 2
19437: PUSH
19438: LD_INT 22
19440: PUSH
19441: LD_OWVAR 2
19445: PUSH
19446: EMPTY
19447: LIST
19448: LIST
19449: PUSH
19450: LD_INT 25
19452: PUSH
19453: LD_INT 1
19455: PUSH
19456: EMPTY
19457: LIST
19458: LIST
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: PPUSH
19464: CALL_OW 69
19468: ST_TO_ADDR
// if not tmp then
19469: LD_VAR 0 2
19473: NOT
19474: IFFALSE 19478
// exit ;
19476: GO 19627
// un := tmp [ rand ( 1 , tmp ) ] ;
19478: LD_ADDR_VAR 0 3
19482: PUSH
19483: LD_VAR 0 2
19487: PUSH
19488: LD_INT 1
19490: PPUSH
19491: LD_VAR 0 2
19495: PPUSH
19496: CALL_OW 12
19500: ARRAY
19501: ST_TO_ADDR
// if Crawls ( un ) then
19502: LD_VAR 0 3
19506: PPUSH
19507: CALL_OW 318
19511: IFFALSE 19522
// ComWalk ( un ) ;
19513: LD_VAR 0 3
19517: PPUSH
19518: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19522: LD_VAR 0 3
19526: PPUSH
19527: LD_INT 8
19529: PPUSH
19530: CALL_OW 336
// end ; 4 :
19534: GO 19627
19536: LD_INT 4
19538: DOUBLE
19539: EQUAL
19540: IFTRUE 19544
19542: GO 19605
19544: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19545: LD_ADDR_VAR 0 2
19549: PUSH
19550: LD_INT 22
19552: PUSH
19553: LD_OWVAR 2
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PUSH
19562: LD_INT 30
19564: PUSH
19565: LD_INT 29
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: PPUSH
19576: CALL_OW 69
19580: ST_TO_ADDR
// if not tmp then
19581: LD_VAR 0 2
19585: NOT
19586: IFFALSE 19590
// exit ;
19588: GO 19627
// DestroyUnit ( tmp [ 1 ] ) ;
19590: LD_VAR 0 2
19594: PUSH
19595: LD_INT 1
19597: ARRAY
19598: PPUSH
19599: CALL_OW 65
// end ; 5 .. 7 :
19603: GO 19627
19605: LD_INT 5
19607: DOUBLE
19608: GREATEREQUAL
19609: IFFALSE 19617
19611: LD_INT 7
19613: DOUBLE
19614: LESSEQUAL
19615: IFTRUE 19619
19617: GO 19626
19619: POP
// StreamSibBomb ; end ;
19620: CALL 15921 0 0
19624: GO 19627
19626: POP
// end ;
19627: PPOPN 3
19629: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
19630: LD_EXP 30
19634: PUSH
19635: LD_EXP 80
19639: AND
19640: IFFALSE 19796
19642: GO 19644
19644: DISABLE
19645: LD_INT 0
19647: PPUSH
19648: PPUSH
19649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
19650: LD_ADDR_VAR 0 2
19654: PUSH
19655: LD_INT 81
19657: PUSH
19658: LD_OWVAR 2
19662: PUSH
19663: EMPTY
19664: LIST
19665: LIST
19666: PUSH
19667: LD_INT 2
19669: PUSH
19670: LD_INT 21
19672: PUSH
19673: LD_INT 1
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: PUSH
19680: LD_INT 21
19682: PUSH
19683: LD_INT 2
19685: PUSH
19686: EMPTY
19687: LIST
19688: LIST
19689: PUSH
19690: EMPTY
19691: LIST
19692: LIST
19693: LIST
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: PPUSH
19699: CALL_OW 69
19703: ST_TO_ADDR
// if not tmp then
19704: LD_VAR 0 2
19708: NOT
19709: IFFALSE 19713
// exit ;
19711: GO 19796
// p := 0 ;
19713: LD_ADDR_VAR 0 3
19717: PUSH
19718: LD_INT 0
19720: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19721: LD_INT 35
19723: PPUSH
19724: CALL_OW 67
// p := p + 1 ;
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_VAR 0 3
19737: PUSH
19738: LD_INT 1
19740: PLUS
19741: ST_TO_ADDR
// for i in tmp do
19742: LD_ADDR_VAR 0 1
19746: PUSH
19747: LD_VAR 0 2
19751: PUSH
19752: FOR_IN
19753: IFFALSE 19784
// if GetLives ( i ) < 1000 then
19755: LD_VAR 0 1
19759: PPUSH
19760: CALL_OW 256
19764: PUSH
19765: LD_INT 1000
19767: LESS
19768: IFFALSE 19782
// SetLives ( i , 1000 ) ;
19770: LD_VAR 0 1
19774: PPUSH
19775: LD_INT 1000
19777: PPUSH
19778: CALL_OW 234
19782: GO 19752
19784: POP
19785: POP
// until p > 20 ;
19786: LD_VAR 0 3
19790: PUSH
19791: LD_INT 20
19793: GREATER
19794: IFFALSE 19721
// end ;
19796: PPOPN 3
19798: END
// every 0 0$1 trigger StreamModeActive and sTime do
19799: LD_EXP 30
19803: PUSH
19804: LD_EXP 81
19808: AND
19809: IFFALSE 19844
19811: GO 19813
19813: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
19814: LD_INT 28
19816: PPUSH
19817: LD_OWVAR 2
19821: PPUSH
19822: LD_INT 2
19824: PPUSH
19825: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
19829: LD_INT 30
19831: PPUSH
19832: LD_OWVAR 2
19836: PPUSH
19837: LD_INT 2
19839: PPUSH
19840: CALL_OW 322
// end ;
19844: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19845: LD_EXP 30
19849: PUSH
19850: LD_EXP 82
19854: AND
19855: IFFALSE 19976
19857: GO 19859
19859: DISABLE
19860: LD_INT 0
19862: PPUSH
19863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19864: LD_ADDR_VAR 0 2
19868: PUSH
19869: LD_INT 22
19871: PUSH
19872: LD_OWVAR 2
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: PUSH
19881: LD_INT 21
19883: PUSH
19884: LD_INT 1
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: PUSH
19891: LD_INT 3
19893: PUSH
19894: LD_INT 23
19896: PUSH
19897: LD_INT 0
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL_OW 69
19917: ST_TO_ADDR
// if not tmp then
19918: LD_VAR 0 2
19922: NOT
19923: IFFALSE 19927
// exit ;
19925: GO 19976
// for i in tmp do
19927: LD_ADDR_VAR 0 1
19931: PUSH
19932: LD_VAR 0 2
19936: PUSH
19937: FOR_IN
19938: IFFALSE 19974
// begin if Crawls ( i ) then
19940: LD_VAR 0 1
19944: PPUSH
19945: CALL_OW 318
19949: IFFALSE 19960
// ComWalk ( i ) ;
19951: LD_VAR 0 1
19955: PPUSH
19956: CALL_OW 138
// SetClass ( i , 2 ) ;
19960: LD_VAR 0 1
19964: PPUSH
19965: LD_INT 2
19967: PPUSH
19968: CALL_OW 336
// end ;
19972: GO 19937
19974: POP
19975: POP
// end ;
19976: PPOPN 2
19978: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19979: LD_EXP 30
19983: PUSH
19984: LD_EXP 83
19988: AND
19989: IFFALSE 20194
19991: GO 19993
19993: DISABLE
19994: LD_INT 0
19996: PPUSH
19997: PPUSH
19998: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
19999: LD_OWVAR 2
20003: PPUSH
20004: LD_INT 9
20006: PPUSH
20007: LD_INT 1
20009: PPUSH
20010: LD_INT 1
20012: PPUSH
20013: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
20017: LD_INT 9
20019: PPUSH
20020: LD_OWVAR 2
20024: PPUSH
20025: CALL_OW 343
// hc_name := Dark Warrior ;
20029: LD_ADDR_OWVAR 26
20033: PUSH
20034: LD_STRING Dark Warrior
20036: ST_TO_ADDR
// hc_gallery :=  ;
20037: LD_ADDR_OWVAR 33
20041: PUSH
20042: LD_STRING 
20044: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
20045: LD_INT 1
20047: PPUSH
20048: LD_INT 1
20050: PPUSH
20051: LD_INT 10
20053: PPUSH
20054: CALL_OW 380
// un := CreateHuman ;
20058: LD_ADDR_VAR 0 3
20062: PUSH
20063: CALL_OW 44
20067: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20068: LD_VAR 0 3
20072: PPUSH
20073: LD_INT 1
20075: PPUSH
20076: CALL_OW 51
// p := 0 ;
20080: LD_ADDR_VAR 0 2
20084: PUSH
20085: LD_INT 0
20087: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20088: LD_INT 35
20090: PPUSH
20091: CALL_OW 67
// if GetLives ( un ) < 1000 then
20095: LD_VAR 0 3
20099: PPUSH
20100: CALL_OW 256
20104: PUSH
20105: LD_INT 1000
20107: LESS
20108: IFFALSE 20122
// SetLives ( un , 1000 ) ;
20110: LD_VAR 0 3
20114: PPUSH
20115: LD_INT 1000
20117: PPUSH
20118: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
20122: LD_VAR 0 3
20126: PPUSH
20127: LD_INT 81
20129: PUSH
20130: LD_OWVAR 2
20134: PUSH
20135: EMPTY
20136: LIST
20137: LIST
20138: PPUSH
20139: CALL_OW 69
20143: PPUSH
20144: LD_VAR 0 3
20148: PPUSH
20149: CALL_OW 74
20153: PPUSH
20154: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
20158: LD_VAR 0 2
20162: PUSH
20163: LD_INT 60
20165: GREATER
20166: PUSH
20167: LD_VAR 0 3
20171: PPUSH
20172: CALL_OW 301
20176: OR
20177: IFFALSE 20088
// if un then
20179: LD_VAR 0 3
20183: IFFALSE 20194
// RemoveUnit ( un ) ;
20185: LD_VAR 0 3
20189: PPUSH
20190: CALL_OW 64
// end ; end_of_file
20194: PPOPN 3
20196: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
20197: LD_INT 0
20199: PPUSH
20200: PPUSH
20201: PPUSH
20202: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
20203: LD_VAR 0 1
20207: PPUSH
20208: CALL_OW 264
20212: PUSH
20213: LD_EXP 29
20217: EQUAL
20218: IFFALSE 20290
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
20220: LD_INT 68
20222: PPUSH
20223: LD_VAR 0 1
20227: PPUSH
20228: CALL_OW 255
20232: PPUSH
20233: CALL_OW 321
20237: PUSH
20238: LD_INT 2
20240: EQUAL
20241: IFFALSE 20253
// eff := 70 else
20243: LD_ADDR_VAR 0 6
20247: PUSH
20248: LD_INT 70
20250: ST_TO_ADDR
20251: GO 20261
// eff := 30 ;
20253: LD_ADDR_VAR 0 6
20257: PUSH
20258: LD_INT 30
20260: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
20261: LD_VAR 0 1
20265: PPUSH
20266: CALL_OW 250
20270: PPUSH
20271: LD_VAR 0 1
20275: PPUSH
20276: CALL_OW 251
20280: PPUSH
20281: LD_VAR 0 6
20285: PPUSH
20286: CALL_OW 495
// end ; end ;
20290: LD_VAR 0 4
20294: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
20295: LD_INT 0
20297: PPUSH
20298: PPUSH
20299: PPUSH
20300: PPUSH
20301: PPUSH
20302: PPUSH
// if cmd = 124 then
20303: LD_VAR 0 1
20307: PUSH
20308: LD_INT 124
20310: EQUAL
20311: IFFALSE 20517
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
20313: LD_ADDR_VAR 0 5
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 34
20323: PUSH
20324: LD_INT 53
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: PUSH
20331: LD_INT 34
20333: PUSH
20334: LD_INT 14
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PPUSH
20346: CALL_OW 69
20350: ST_TO_ADDR
// if not tmp then
20351: LD_VAR 0 5
20355: NOT
20356: IFFALSE 20360
// exit ;
20358: GO 20517
// for i in tmp do
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_VAR 0 5
20369: PUSH
20370: FOR_IN
20371: IFFALSE 20515
// begin taskList := GetTaskList ( i ) ;
20373: LD_ADDR_VAR 0 6
20377: PUSH
20378: LD_VAR 0 3
20382: PPUSH
20383: CALL_OW 437
20387: ST_TO_ADDR
// if not taskList then
20388: LD_VAR 0 6
20392: NOT
20393: IFFALSE 20397
// continue ;
20395: GO 20370
// for j = 1 to taskList do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_VAR 0 6
20411: PUSH
20412: FOR_TO
20413: IFFALSE 20511
// if taskList [ j ] [ 1 ] = | then
20415: LD_VAR 0 6
20419: PUSH
20420: LD_VAR 0 4
20424: ARRAY
20425: PUSH
20426: LD_INT 1
20428: ARRAY
20429: PUSH
20430: LD_STRING |
20432: EQUAL
20433: IFFALSE 20509
// begin _taskList := Delete ( taskList , 1 ) ;
20435: LD_ADDR_VAR 0 7
20439: PUSH
20440: LD_VAR 0 6
20444: PPUSH
20445: LD_INT 1
20447: PPUSH
20448: CALL_OW 3
20452: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
20453: LD_VAR 0 3
20457: PPUSH
20458: LD_VAR 0 7
20462: PPUSH
20463: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
20467: LD_VAR 0 3
20471: PPUSH
20472: LD_VAR 0 6
20476: PUSH
20477: LD_VAR 0 4
20481: ARRAY
20482: PUSH
20483: LD_INT 2
20485: ARRAY
20486: PPUSH
20487: LD_VAR 0 6
20491: PUSH
20492: LD_VAR 0 4
20496: ARRAY
20497: PUSH
20498: LD_INT 3
20500: ARRAY
20501: PPUSH
20502: LD_INT 8
20504: PPUSH
20505: CALL 20522 0 4
// end ;
20509: GO 20412
20511: POP
20512: POP
// end ;
20513: GO 20370
20515: POP
20516: POP
// end ; end ;
20517: LD_VAR 0 2
20521: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
20522: LD_INT 0
20524: PPUSH
20525: PPUSH
20526: PPUSH
20527: PPUSH
20528: PPUSH
20529: PPUSH
20530: PPUSH
20531: PPUSH
20532: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
20533: LD_VAR 0 1
20537: NOT
20538: PUSH
20539: LD_VAR 0 2
20543: PPUSH
20544: LD_VAR 0 3
20548: PPUSH
20549: CALL_OW 488
20553: NOT
20554: OR
20555: PUSH
20556: LD_VAR 0 4
20560: NOT
20561: OR
20562: IFFALSE 20566
// exit ;
20564: GO 20906
// list := [ ] ;
20566: LD_ADDR_VAR 0 13
20570: PUSH
20571: EMPTY
20572: ST_TO_ADDR
// if x - r < 0 then
20573: LD_VAR 0 2
20577: PUSH
20578: LD_VAR 0 4
20582: MINUS
20583: PUSH
20584: LD_INT 0
20586: LESS
20587: IFFALSE 20599
// min_x := 0 else
20589: LD_ADDR_VAR 0 7
20593: PUSH
20594: LD_INT 0
20596: ST_TO_ADDR
20597: GO 20615
// min_x := x - r ;
20599: LD_ADDR_VAR 0 7
20603: PUSH
20604: LD_VAR 0 2
20608: PUSH
20609: LD_VAR 0 4
20613: MINUS
20614: ST_TO_ADDR
// if y - r < 0 then
20615: LD_VAR 0 3
20619: PUSH
20620: LD_VAR 0 4
20624: MINUS
20625: PUSH
20626: LD_INT 0
20628: LESS
20629: IFFALSE 20641
// min_y := 0 else
20631: LD_ADDR_VAR 0 8
20635: PUSH
20636: LD_INT 0
20638: ST_TO_ADDR
20639: GO 20657
// min_y := y - r ;
20641: LD_ADDR_VAR 0 8
20645: PUSH
20646: LD_VAR 0 3
20650: PUSH
20651: LD_VAR 0 4
20655: MINUS
20656: ST_TO_ADDR
// max_x := x + r ;
20657: LD_ADDR_VAR 0 9
20661: PUSH
20662: LD_VAR 0 2
20666: PUSH
20667: LD_VAR 0 4
20671: PLUS
20672: ST_TO_ADDR
// max_y := y + r ;
20673: LD_ADDR_VAR 0 10
20677: PUSH
20678: LD_VAR 0 3
20682: PUSH
20683: LD_VAR 0 4
20687: PLUS
20688: ST_TO_ADDR
// for _x = min_x to max_x do
20689: LD_ADDR_VAR 0 11
20693: PUSH
20694: DOUBLE
20695: LD_VAR 0 7
20699: DEC
20700: ST_TO_ADDR
20701: LD_VAR 0 9
20705: PUSH
20706: FOR_TO
20707: IFFALSE 20824
// for _y = min_y to max_y do
20709: LD_ADDR_VAR 0 12
20713: PUSH
20714: DOUBLE
20715: LD_VAR 0 8
20719: DEC
20720: ST_TO_ADDR
20721: LD_VAR 0 10
20725: PUSH
20726: FOR_TO
20727: IFFALSE 20820
// begin if not ValidHex ( _x , _y ) then
20729: LD_VAR 0 11
20733: PPUSH
20734: LD_VAR 0 12
20738: PPUSH
20739: CALL_OW 488
20743: NOT
20744: IFFALSE 20748
// continue ;
20746: GO 20726
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
20748: LD_VAR 0 11
20752: PPUSH
20753: LD_VAR 0 12
20757: PPUSH
20758: CALL_OW 351
20762: PUSH
20763: LD_VAR 0 11
20767: PPUSH
20768: LD_VAR 0 12
20772: PPUSH
20773: CALL_OW 554
20777: AND
20778: IFFALSE 20818
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
20780: LD_ADDR_VAR 0 13
20784: PUSH
20785: LD_VAR 0 13
20789: PPUSH
20790: LD_VAR 0 13
20794: PUSH
20795: LD_INT 1
20797: PLUS
20798: PPUSH
20799: LD_VAR 0 11
20803: PUSH
20804: LD_VAR 0 12
20808: PUSH
20809: EMPTY
20810: LIST
20811: LIST
20812: PPUSH
20813: CALL_OW 2
20817: ST_TO_ADDR
// end ;
20818: GO 20726
20820: POP
20821: POP
20822: GO 20706
20824: POP
20825: POP
// if not list then
20826: LD_VAR 0 13
20830: NOT
20831: IFFALSE 20835
// exit ;
20833: GO 20906
// for i in list do
20835: LD_ADDR_VAR 0 6
20839: PUSH
20840: LD_VAR 0 13
20844: PUSH
20845: FOR_IN
20846: IFFALSE 20904
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20848: LD_VAR 0 1
20852: PPUSH
20853: LD_STRING M
20855: PUSH
20856: LD_VAR 0 6
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: PUSH
20865: LD_VAR 0 6
20869: PUSH
20870: LD_INT 2
20872: ARRAY
20873: PUSH
20874: LD_INT 0
20876: PUSH
20877: LD_INT 0
20879: PUSH
20880: LD_INT 0
20882: PUSH
20883: LD_INT 0
20885: PUSH
20886: EMPTY
20887: LIST
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: PUSH
20895: EMPTY
20896: LIST
20897: PPUSH
20898: CALL_OW 447
20902: GO 20845
20904: POP
20905: POP
// end ;
20906: LD_VAR 0 5
20910: RET
