// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8608 0 0
// PrepareAmerican ;
 100: CALL 5228 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin if un in Patrol then
3263: LD_VAR 0 1
3267: PUSH
3268: LD_EXP 17
3272: IN
3273: IFFALSE 3291
// Patrol := Patrol diff un ;
3275: LD_ADDR_EXP 17
3279: PUSH
3280: LD_EXP 17
3284: PUSH
3285: LD_VAR 0 1
3289: DIFF
3290: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3291: LD_VAR 0 1
3295: PUSH
3296: LD_INT 22
3298: PUSH
3299: LD_INT 1
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PUSH
3306: LD_INT 30
3308: PUSH
3309: LD_INT 32
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PPUSH
3320: CALL_OW 69
3324: IN
3325: IFFALSE 3411
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3327: LD_ADDR_EXP 18
3331: PUSH
3332: LD_EXP 18
3336: PUSH
3337: LD_VAR 0 1
3341: PPUSH
3342: CALL_OW 250
3346: ADD
3347: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3348: LD_ADDR_EXP 18
3352: PUSH
3353: LD_EXP 18
3357: PUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: CALL_OW 251
3367: ADD
3368: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3369: LD_ADDR_EXP 18
3373: PUSH
3374: LD_EXP 18
3378: PUSH
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 254
3388: ADD
3389: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3390: LD_ADDR_EXP 18
3394: PUSH
3395: LD_EXP 18
3399: PUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 269
3409: ADD
3410: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3411: LD_VAR 0 1
3415: PUSH
3416: LD_INT 33
3418: PUSH
3419: LD_INT 2
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 34
3431: PUSH
3432: LD_INT 13
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PPUSH
3447: CALL_OW 69
3451: IN
3452: IFFALSE 3468
// new_veh := new_veh + 1 ;
3454: LD_ADDR_EXP 19
3458: PUSH
3459: LD_EXP 19
3463: PUSH
3464: LD_INT 1
3466: PLUS
3467: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3468: LD_VAR 0 1
3472: PUSH
3473: LD_INT 34
3475: PUSH
3476: LD_INT 13
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: PPUSH
3483: CALL_OW 69
3487: IN
3488: IFFALSE 3509
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3490: LD_INT 26
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 2
3498: PPUSH
3499: LD_INT 2
3501: PPUSH
3502: LD_INT 13
3504: PPUSH
3505: CALL_OW 185
// if un = am_dep then
3509: LD_VAR 0 1
3513: PUSH
3514: LD_INT 25
3516: EQUAL
3517: IFFALSE 3685
// begin SayRadio ( Platonov , DPlat ) ;
3519: LD_EXP 4
3523: PPUSH
3524: LD_STRING DPlat
3526: PPUSH
3527: CALL_OW 94
// if timer <= 30 30$00 then
3531: LD_EXP 24
3535: PUSH
3536: LD_INT 63000
3538: LESSEQUAL
3539: IFFALSE 3553
// AddMedal ( gamma_med3 , 1 ) else
3541: LD_STRING gamma_med3
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 101
3551: GO 3603
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3553: LD_EXP 24
3557: PUSH
3558: LD_INT 105000
3560: PUSH
3561: LD_INT 88200
3563: PUSH
3564: LD_INT 73500
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: LIST
3571: PUSH
3572: LD_EXP 1
3576: ARRAY
3577: LESSEQUAL
3578: IFFALSE 3592
// AddMedal ( gamma_med3 , 2 ) else
3580: LD_STRING gamma_med3
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 101
3590: GO 3603
// AddMedal ( gamma_med3 , - 1 ) ;
3592: LD_STRING gamma_med3
3594: PPUSH
3595: LD_INT 1
3597: NEG
3598: PPUSH
3599: CALL_OW 101
// if not comp_tested then
3603: LD_EXP 22
3607: NOT
3608: IFFALSE 3623
// AddMedal ( gamma_med2 , - 1 ) else
3610: LD_STRING gamma_med2
3612: PPUSH
3613: LD_INT 1
3615: NEG
3616: PPUSH
3617: CALL_OW 101
3621: GO 3633
// AddMedal ( gamma_med2 , 1 ) ;
3623: LD_STRING gamma_med2
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3633: LD_EXP 9
3637: PPUSH
3638: CALL_OW 301
3642: PUSH
3643: LD_EXP 23
3647: NOT
3648: AND
3649: IFFALSE 3663
// AddMedal ( gamma_med1 , 1 ) else
3651: LD_STRING gamma_med1
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: CALL_OW 101
3661: GO 3674
// AddMedal ( gamma_med1 , - 1 ) ;
3663: LD_STRING gamma_med1
3665: PPUSH
3666: LD_INT 1
3668: NEG
3669: PPUSH
3670: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3674: LD_STRING GAMMA_MEDALS
3676: PPUSH
3677: CALL_OW 102
// YouWin ;
3681: CALL_OW 103
// end ; if un = commander then
3685: LD_VAR 0 1
3689: PUSH
3690: LD_EXP 3
3694: EQUAL
3695: IFFALSE 3704
// YouLost ( comml ) ;
3697: LD_STRING comml
3699: PPUSH
3700: CALL_OW 104
// if un = sikorski then
3704: LD_VAR 0 1
3708: PUSH
3709: LD_EXP 9
3713: EQUAL
3714: IFFALSE 3726
// AddMedal ( gamma_med1 , 1 ) ;
3716: LD_STRING gamma_med1
3718: PPUSH
3719: LD_INT 1
3721: PPUSH
3722: CALL_OW 101
// end ;
3726: PPOPN 1
3728: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3729: LD_INT 0
3731: PPUSH
3732: PPUSH
3733: PPUSH
3734: PPUSH
3735: PPUSH
3736: PPUSH
3737: PPUSH
3738: PPUSH
3739: PPUSH
// begin if event = 1 then
3740: LD_VAR 0 1
3744: PUSH
3745: LD_INT 1
3747: EQUAL
3748: IFFALSE 4045
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3750: LD_ADDR_VAR 0 4
3754: PUSH
3755: LD_INT 22
3757: PUSH
3758: LD_INT 1
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 21
3767: PUSH
3768: LD_INT 3
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 3
3777: PUSH
3778: LD_INT 24
3780: PUSH
3781: LD_INT 1000
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: LIST
3796: PPUSH
3797: CALL_OW 69
3801: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_INT 22
3809: PUSH
3810: LD_INT 1
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_INT 25
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 24
3829: PUSH
3830: LD_INT 1000
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: PPUSH
3845: CALL_OW 69
3849: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3850: LD_ADDR_VAR 0 9
3854: PUSH
3855: LD_INT 22
3857: PUSH
3858: LD_INT 1
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 34
3867: PUSH
3868: LD_INT 13
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL_OW 69
3883: ST_TO_ADDR
// if engs > 0 then
3884: LD_VAR 0 8
3888: PUSH
3889: LD_INT 0
3891: GREATER
3892: IFFALSE 3997
// for i = 1 to engs do
3894: LD_ADDR_VAR 0 2
3898: PUSH
3899: DOUBLE
3900: LD_INT 1
3902: DEC
3903: ST_TO_ADDR
3904: LD_VAR 0 8
3908: PUSH
3909: FOR_TO
3910: IFFALSE 3995
// begin if IsInUnit ( engs [ i ] ) then
3912: LD_VAR 0 8
3916: PUSH
3917: LD_VAR 0 2
3921: ARRAY
3922: PPUSH
3923: CALL_OW 310
3927: IFFALSE 3944
// ComExitBuilding ( engs [ i ] ) ;
3929: LD_VAR 0 8
3933: PUSH
3934: LD_VAR 0 2
3938: ARRAY
3939: PPUSH
3940: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3944: LD_INT 7
3946: PPUSH
3947: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3951: LD_VAR 0 8
3955: PUSH
3956: LD_VAR 0 2
3960: ARRAY
3961: PPUSH
3962: CALL_OW 314
3966: NOT
3967: IFFALSE 3993
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3969: LD_VAR 0 8
3973: PUSH
3974: LD_VAR 0 2
3978: ARRAY
3979: PPUSH
3980: LD_VAR 0 4
3984: PUSH
3985: LD_INT 1
3987: ARRAY
3988: PPUSH
3989: CALL_OW 130
// end ;
3993: GO 3909
3995: POP
3996: POP
// if crane > 0 then
3997: LD_VAR 0 9
4001: PUSH
4002: LD_INT 0
4004: GREATER
4005: IFFALSE 4045
// if not HasTask ( crane [ 1 ] ) then
4007: LD_VAR 0 9
4011: PUSH
4012: LD_INT 1
4014: ARRAY
4015: PPUSH
4016: CALL_OW 314
4020: NOT
4021: IFFALSE 4045
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4023: LD_VAR 0 9
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_VAR 0 4
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: CALL_OW 130
// end ; if event = 2 then
4045: LD_VAR 0 1
4049: PUSH
4050: LD_INT 2
4052: EQUAL
4053: IFFALSE 4175
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4055: LD_ADDR_VAR 0 8
4059: PUSH
4060: LD_INT 22
4062: PUSH
4063: LD_INT 1
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: LD_INT 25
4072: PUSH
4073: LD_INT 2
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 69
4088: ST_TO_ADDR
// if engs > 0 then
4089: LD_VAR 0 8
4093: PUSH
4094: LD_INT 0
4096: GREATER
4097: IFFALSE 4175
// for i = 1 to engs do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_VAR 0 8
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4173
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4117: LD_VAR 0 8
4121: PUSH
4122: LD_VAR 0 2
4126: ARRAY
4127: PPUSH
4128: CALL_OW 314
4132: NOT
4133: PUSH
4134: LD_VAR 0 8
4138: PUSH
4139: LD_VAR 0 2
4143: ARRAY
4144: PPUSH
4145: CALL_OW 310
4149: NOT
4150: AND
4151: IFFALSE 4171
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4153: LD_VAR 0 8
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PPUSH
4164: LD_INT 25
4166: PPUSH
4167: CALL_OW 120
4171: GO 4114
4173: POP
4174: POP
// end ; if event = 3 then
4175: LD_VAR 0 1
4179: PUSH
4180: LD_INT 3
4182: EQUAL
4183: IFFALSE 4547
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_INT 22
4192: PUSH
4193: LD_INT 1
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 25
4215: PUSH
4216: LD_INT 4
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: LD_INT 24
4232: PUSH
4233: LD_INT 800
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: PPUSH
4253: CALL_OW 69
4257: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4258: LD_ADDR_VAR 0 5
4262: PUSH
4263: LD_INT 22
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PUSH
4273: LD_INT 25
4275: PUSH
4276: LD_INT 4
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: ST_TO_ADDR
// if filter > 0 then
4292: LD_VAR 0 4
4296: PUSH
4297: LD_INT 0
4299: GREATER
4300: IFFALSE 4489
// begin for i = 1 to doc do
4302: LD_ADDR_VAR 0 2
4306: PUSH
4307: DOUBLE
4308: LD_INT 1
4310: DEC
4311: ST_TO_ADDR
4312: LD_VAR 0 5
4316: PUSH
4317: FOR_TO
4318: IFFALSE 4418
// begin if IsInUnit ( doc [ i ] ) then
4320: LD_VAR 0 5
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PPUSH
4331: CALL_OW 310
4335: IFFALSE 4352
// ComExitBuilding ( doc [ i ] ) ;
4337: LD_VAR 0 5
4341: PUSH
4342: LD_VAR 0 2
4346: ARRAY
4347: PPUSH
4348: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 1
4359: ARRAY
4360: PPUSH
4361: LD_INT 46
4363: PPUSH
4364: CALL_OW 296
4368: PUSH
4369: LD_INT 10
4371: LESS
4372: PUSH
4373: LD_VAR 0 5
4377: PUSH
4378: LD_VAR 0 2
4382: ARRAY
4383: PPUSH
4384: CALL_OW 314
4388: NOT
4389: AND
4390: IFFALSE 4416
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4392: LD_VAR 0 5
4396: PUSH
4397: LD_VAR 0 2
4401: ARRAY
4402: PPUSH
4403: LD_VAR 0 4
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 128
// end ;
4416: GO 4317
4418: POP
4419: POP
// for i = 1 to filter do
4420: LD_ADDR_VAR 0 2
4424: PUSH
4425: DOUBLE
4426: LD_INT 1
4428: DEC
4429: ST_TO_ADDR
4430: LD_VAR 0 4
4434: PUSH
4435: FOR_TO
4436: IFFALSE 4485
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4438: LD_VAR 0 4
4442: PUSH
4443: LD_VAR 0 2
4447: ARRAY
4448: PPUSH
4449: LD_INT 46
4451: PPUSH
4452: CALL_OW 296
4456: PUSH
4457: LD_INT 10
4459: GREATER
4460: IFFALSE 4483
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 2
4471: ARRAY
4472: PPUSH
4473: LD_INT 47
4475: PPUSH
4476: LD_INT 12
4478: PPUSH
4479: CALL_OW 111
4483: GO 4435
4485: POP
4486: POP
// end else
4487: GO 4547
// for i = 1 to doc do
4489: LD_ADDR_VAR 0 2
4493: PUSH
4494: DOUBLE
4495: LD_INT 1
4497: DEC
4498: ST_TO_ADDR
4499: LD_VAR 0 5
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4545
// if not IsInUnit ( doc [ i ] ) then
4507: LD_VAR 0 5
4511: PUSH
4512: LD_VAR 0 2
4516: ARRAY
4517: PPUSH
4518: CALL_OW 310
4522: NOT
4523: IFFALSE 4543
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 2
4534: ARRAY
4535: PPUSH
4536: LD_INT 46
4538: PPUSH
4539: CALL_OW 120
4543: GO 4504
4545: POP
4546: POP
// end ; if event = 4 then
4547: LD_VAR 0 1
4551: PUSH
4552: LD_INT 4
4554: EQUAL
4555: IFFALSE 4806
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4557: LD_ADDR_VAR 0 6
4561: PUSH
4562: LD_INT 22
4564: PUSH
4565: LD_INT 1
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 30
4574: PUSH
4575: LD_INT 5
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL_OW 69
4590: ST_TO_ADDR
// for i = 1 to bac do
4591: LD_ADDR_VAR 0 2
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_VAR 0 6
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4648
// if UnitsInside ( bac [ i ] ) < 6 then
4609: LD_VAR 0 6
4613: PUSH
4614: LD_VAR 0 2
4618: ARRAY
4619: PPUSH
4620: CALL_OW 313
4624: PUSH
4625: LD_INT 6
4627: LESS
4628: IFFALSE 4646
// place := bac [ i ] ;
4630: LD_ADDR_VAR 0 7
4634: PUSH
4635: LD_VAR 0 6
4639: PUSH
4640: LD_VAR 0 2
4644: ARRAY
4645: ST_TO_ADDR
4646: GO 4606
4648: POP
4649: POP
// if place then
4650: LD_VAR 0 7
4654: IFFALSE 4806
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4656: LD_ADDR_VAR 0 4
4660: PUSH
4661: LD_INT 22
4663: PUSH
4664: LD_INT 1
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 2
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 25
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 24
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_EXP 17
4726: DIFF
4727: ST_TO_ADDR
// for i = 1 to filter do
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: DOUBLE
4734: LD_INT 1
4736: DEC
4737: ST_TO_ADDR
4738: LD_VAR 0 4
4742: PUSH
4743: FOR_TO
4744: IFFALSE 4804
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4746: LD_VAR 0 4
4750: PUSH
4751: LD_VAR 0 2
4755: ARRAY
4756: PPUSH
4757: CALL_OW 310
4761: NOT
4762: PUSH
4763: LD_VAR 0 4
4767: PUSH
4768: LD_VAR 0 2
4772: ARRAY
4773: PPUSH
4774: CALL_OW 314
4778: NOT
4779: AND
4780: IFFALSE 4802
// ComEnterUnit ( filter [ i ] , place ) ;
4782: LD_VAR 0 4
4786: PUSH
4787: LD_VAR 0 2
4791: ARRAY
4792: PPUSH
4793: LD_VAR 0 7
4797: PPUSH
4798: CALL_OW 120
4802: GO 4743
4804: POP
4805: POP
// end ; end ; if event = 5 then
4806: LD_VAR 0 1
4810: PUSH
4811: LD_INT 5
4813: EQUAL
4814: IFFALSE 4968
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4816: LD_INT 12
4818: PPUSH
4819: LD_INT 81
4821: PUSH
4822: LD_INT 1
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PPUSH
4829: CALL_OW 70
4833: PUSH
4834: LD_INT 0
4836: EQUAL
4837: IFFALSE 4968
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4839: LD_ADDR_VAR 0 8
4843: PUSH
4844: LD_INT 22
4846: PUSH
4847: LD_INT 1
4849: PUSH
4850: EMPTY
4851: LIST
4852: LIST
4853: PUSH
4854: LD_INT 25
4856: PUSH
4857: LD_INT 2
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PPUSH
4868: CALL_OW 69
4872: ST_TO_ADDR
// if engs > 0 then
4873: LD_VAR 0 8
4877: PUSH
4878: LD_INT 0
4880: GREATER
4881: IFFALSE 4968
// for i = 1 to engs do
4883: LD_ADDR_VAR 0 2
4887: PUSH
4888: DOUBLE
4889: LD_INT 1
4891: DEC
4892: ST_TO_ADDR
4893: LD_VAR 0 8
4897: PUSH
4898: FOR_TO
4899: IFFALSE 4966
// if not HasTask ( engs [ i ] ) then
4901: LD_VAR 0 8
4905: PUSH
4906: LD_VAR 0 2
4910: ARRAY
4911: PPUSH
4912: CALL_OW 314
4916: NOT
4917: IFFALSE 4964
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4919: LD_VAR 0 8
4923: PUSH
4924: LD_VAR 0 2
4928: ARRAY
4929: PPUSH
4930: LD_INT 32
4932: PPUSH
4933: LD_EXP 18
4937: PUSH
4938: LD_INT 1
4940: ARRAY
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 2
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 3
4958: ARRAY
4959: PPUSH
4960: CALL_OW 145
4964: GO 4898
4966: POP
4967: POP
// end ; end ; if event = 6 then
4968: LD_VAR 0 1
4972: PUSH
4973: LD_INT 6
4975: EQUAL
4976: IFFALSE 5160
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4978: LD_ADDR_VAR 0 6
4982: PUSH
4983: LD_INT 22
4985: PUSH
4986: LD_INT 1
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 69
5011: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5012: LD_VAR 0 6
5016: PUSH
5017: LD_INT 22
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 32
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 58
5039: PUSH
5040: EMPTY
5041: LIST
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 0
5058: GREATER
5059: AND
5060: IFFALSE 5160
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5062: LD_ADDR_VAR 0 10
5066: PUSH
5067: LD_INT 22
5069: PUSH
5070: LD_INT 1
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: LD_INT 30
5079: PUSH
5080: LD_INT 32
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 58
5089: PUSH
5090: EMPTY
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: EMPTY
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: PUSH
5106: LD_INT 1
5108: ARRAY
5109: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5110: LD_ADDR_VAR 0 3
5114: PUSH
5115: LD_VAR 0 6
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: CALL_OW 313
5128: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5129: LD_VAR 0 3
5133: PUSH
5134: LD_INT 1
5136: ARRAY
5137: PPUSH
5138: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: ARRAY
5150: PPUSH
5151: LD_VAR 0 10
5155: PPUSH
5156: CALL_OW 180
// end ; end ; end ;
5160: PPOPN 10
5162: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5163: LD_VAR 0 1
5167: PUSH
5168: LD_INT 1
5170: EQUAL
5171: PUSH
5172: LD_VAR 0 2
5176: PUSH
5177: LD_INT 3
5179: EQUAL
5180: AND
5181: IFFALSE 5191
// contact_am := true ;
5183: LD_ADDR_EXP 16
5187: PUSH
5188: LD_INT 1
5190: ST_TO_ADDR
// end ;
5191: PPOPN 2
5193: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5194: LD_VAR 0 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PPUSH
5204: LD_VAR 0 3
5208: PPUSH
5209: CALL 20215 0 3
// end ;
5213: PPOPN 3
5215: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5216: LD_VAR 0 1
5220: PPUSH
5221: CALL 20313 0 1
// end ; end_of_file
5225: PPOPN 1
5227: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5228: LD_INT 0
5230: PPUSH
5231: PPUSH
5232: PPUSH
5233: PPUSH
5234: PPUSH
5235: PPUSH
5236: PPUSH
5237: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5238: LD_ADDR_VAR 0 5
5242: PUSH
5243: LD_INT 5
5245: PUSH
5246: LD_INT 6
5248: PUSH
5249: LD_INT 7
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_EXP 1
5261: ARRAY
5262: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5263: LD_ADDR_VAR 0 6
5267: PUSH
5268: LD_INT 4
5270: PUSH
5271: LD_INT 4
5273: PUSH
5274: LD_INT 4
5276: PUSH
5277: LD_INT 5
5279: PUSH
5280: LD_INT 5
5282: PUSH
5283: LD_INT 5
5285: PUSH
5286: LD_INT 6
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: LIST
5297: ST_TO_ADDR
// SForce := [ ] ;
5298: LD_ADDR_EXP 11
5302: PUSH
5303: EMPTY
5304: ST_TO_ADDR
// Sikorski_Ar := false ;
5305: LD_ADDR_EXP 12
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// attacked := false ;
5313: LD_ADDR_EXP 15
5317: PUSH
5318: LD_INT 0
5320: ST_TO_ADDR
// contact_am := false ;
5321: LD_ADDR_EXP 16
5325: PUSH
5326: LD_INT 0
5328: ST_TO_ADDR
// patrol := [ ] ;
5329: LD_ADDR_EXP 17
5333: PUSH
5334: EMPTY
5335: ST_TO_ADDR
// gamma_towers := [ ] ;
5336: LD_ADDR_EXP 18
5340: PUSH
5341: EMPTY
5342: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5343: LD_INT 25
5345: PPUSH
5346: LD_STRING gamma
5348: PPUSH
5349: CALL_OW 500
// uc_side := 1 ;
5353: LD_ADDR_OWVAR 20
5357: PUSH
5358: LD_INT 1
5360: ST_TO_ADDR
// uc_nation := 1 ;
5361: LD_ADDR_OWVAR 21
5365: PUSH
5366: LD_INT 1
5368: ST_TO_ADDR
// hc_importance := 0 ;
5369: LD_ADDR_OWVAR 32
5373: PUSH
5374: LD_INT 0
5376: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5377: LD_ADDR_OWVAR 26
5381: PUSH
5382: LD_STRING Jeremy Sikorski
5384: ST_TO_ADDR
// hc_gallery := us ;
5385: LD_ADDR_OWVAR 33
5389: PUSH
5390: LD_STRING us
5392: ST_TO_ADDR
// hc_face_number := 19 ;
5393: LD_ADDR_OWVAR 34
5397: PUSH
5398: LD_INT 19
5400: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5401: LD_ADDR_OWVAR 31
5405: PUSH
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_VAR 0 5
5415: PUSH
5416: LD_INT 2
5418: PLUS
5419: PPUSH
5420: CALL_OW 12
5424: PUSH
5425: LD_INT 4
5427: PUSH
5428: LD_INT 6
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: ST_TO_ADDR
// hc_sex := sex_male ;
5440: LD_ADDR_OWVAR 27
5444: PUSH
5445: LD_INT 1
5447: ST_TO_ADDR
// hc_class := 1 ;
5448: LD_ADDR_OWVAR 28
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5456: LD_ADDR_OWVAR 29
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: ST_TO_ADDR
// sikorski := CreateHuman ;
5471: LD_ADDR_EXP 9
5475: PUSH
5476: CALL_OW 44
5480: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5481: LD_ADDR_OWVAR 26
5485: PUSH
5486: LD_STRING Lucy Donaldson
5488: ST_TO_ADDR
// hc_gallery := us ;
5489: LD_ADDR_OWVAR 33
5493: PUSH
5494: LD_STRING us
5496: ST_TO_ADDR
// hc_face_number := 2 ;
5497: LD_ADDR_OWVAR 34
5501: PUSH
5502: LD_INT 2
5504: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5505: LD_ADDR_OWVAR 31
5509: PUSH
5510: LD_VAR 0 5
5514: PPUSH
5515: LD_VAR 0 5
5519: PUSH
5520: LD_INT 2
5522: PLUS
5523: PPUSH
5524: CALL_OW 12
5528: PUSH
5529: LD_INT 6
5531: PUSH
5532: LD_INT 4
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: ST_TO_ADDR
// hc_sex := sex_female ;
5544: LD_ADDR_OWVAR 27
5548: PUSH
5549: LD_INT 2
5551: ST_TO_ADDR
// hc_class := 1 ;
5552: LD_ADDR_OWVAR 28
5556: PUSH
5557: LD_INT 1
5559: ST_TO_ADDR
// donald := CreateHuman ;
5560: LD_ADDR_EXP 13
5564: PUSH
5565: CALL_OW 44
5569: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5570: LD_ADDR_OWVAR 26
5574: PUSH
5575: LD_STRING Peter Van Houten
5577: ST_TO_ADDR
// hc_gallery := us ;
5578: LD_ADDR_OWVAR 33
5582: PUSH
5583: LD_STRING us
5585: ST_TO_ADDR
// hc_face_number := 16 ;
5586: LD_ADDR_OWVAR 34
5590: PUSH
5591: LD_INT 16
5593: ST_TO_ADDR
// hc_sex := sex_male ;
5594: LD_ADDR_OWVAR 27
5598: PUSH
5599: LD_INT 1
5601: ST_TO_ADDR
// van := CreateHuman ;
5602: LD_ADDR_EXP 14
5606: PUSH
5607: CALL_OW 44
5611: ST_TO_ADDR
// hc_importance := 0 ;
5612: LD_ADDR_OWVAR 32
5616: PUSH
5617: LD_INT 0
5619: ST_TO_ADDR
// case dif of 1 :
5620: LD_EXP 1
5624: PUSH
5625: LD_INT 1
5627: DOUBLE
5628: EQUAL
5629: IFTRUE 5633
5631: GO 5644
5633: POP
// lw = 1 ; 2 :
5634: LD_ADDR_VAR 0 8
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
5642: GO 5691
5644: LD_INT 2
5646: DOUBLE
5647: EQUAL
5648: IFTRUE 5652
5650: GO 5671
5652: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5653: LD_ADDR_VAR 0 8
5657: PUSH
5658: LD_INT 1
5660: PPUSH
5661: LD_INT 2
5663: PPUSH
5664: CALL_OW 12
5668: ST_TO_ADDR
5669: GO 5691
5671: LD_INT 3
5673: DOUBLE
5674: EQUAL
5675: IFTRUE 5679
5677: GO 5690
5679: POP
// lw = 2 ; end ;
5680: LD_ADDR_VAR 0 8
5684: PUSH
5685: LD_INT 2
5687: ST_TO_ADDR
5688: GO 5691
5690: POP
// case lw of 1 :
5691: LD_VAR 0 8
5695: PUSH
5696: LD_INT 1
5698: DOUBLE
5699: EQUAL
5700: IFTRUE 5704
5702: GO 5719
5704: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5705: LD_EXP 13
5709: PPUSH
5710: LD_INT 25
5712: PPUSH
5713: CALL_OW 52
5717: GO 5743
5719: LD_INT 2
5721: DOUBLE
5722: EQUAL
5723: IFTRUE 5727
5725: GO 5742
5727: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5728: LD_EXP 14
5732: PPUSH
5733: LD_INT 25
5735: PPUSH
5736: CALL_OW 52
5740: GO 5743
5742: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5743: LD_ADDR_VAR 0 2
5747: PUSH
5748: LD_INT 22
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 30
5760: PUSH
5761: LD_INT 32
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PPUSH
5772: CALL_OW 69
5776: PUSH
5777: FOR_IN
5778: IFFALSE 5832
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5780: LD_INT 1
5782: PPUSH
5783: LD_VAR 0 5
5787: PPUSH
5788: CALL 734 0 2
5792: PPUSH
5793: LD_VAR 0 2
5797: PPUSH
5798: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PUSH
5812: LD_INT 1
5814: PPUSH
5815: LD_VAR 0 6
5819: PPUSH
5820: CALL_OW 12
5824: ARRAY
5825: PPUSH
5826: CALL_OW 431
// end ;
5830: GO 5777
5832: POP
5833: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5834: LD_ADDR_VAR 0 7
5838: PUSH
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 2
5851: PUSH
5852: LD_INT 25
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 5
5864: PUSH
5865: EMPTY
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: PPUSH
5877: CALL_OW 69
5881: ST_TO_ADDR
// for i = 1 to sol do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_VAR 0 7
5896: PUSH
5897: FOR_TO
5898: IFFALSE 5920
// SetTag ( sol [ i ] , 1 ) ;
5900: LD_VAR 0 7
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PPUSH
5911: LD_INT 1
5913: PPUSH
5914: CALL_OW 109
5918: GO 5897
5920: POP
5921: POP
// for i = 1 to 3 do
5922: LD_ADDR_VAR 0 2
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_INT 3
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5960
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: CALL 734 0 2
5950: PPUSH
5951: LD_INT 56
5953: PPUSH
5954: CALL_OW 52
5958: GO 5935
5960: POP
5961: POP
// for i = 1 to 6 do
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: DOUBLE
5968: LD_INT 1
5970: DEC
5971: ST_TO_ADDR
5972: LD_INT 6
5974: PUSH
5975: FOR_TO
5976: IFFALSE 6000
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5978: LD_INT 3
5980: PPUSH
5981: LD_VAR 0 5
5985: PPUSH
5986: CALL 734 0 2
5990: PPUSH
5991: LD_INT 26
5993: PPUSH
5994: CALL_OW 52
5998: GO 5975
6000: POP
6001: POP
// for i = 1 to 5 do
6002: LD_ADDR_VAR 0 2
6006: PUSH
6007: DOUBLE
6008: LD_INT 1
6010: DEC
6011: ST_TO_ADDR
6012: LD_INT 5
6014: PUSH
6015: FOR_TO
6016: IFFALSE 6043
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6018: LD_INT 2
6020: PPUSH
6021: LD_VAR 0 5
6025: PPUSH
6026: CALL 734 0 2
6030: PPUSH
6031: LD_INT 7
6033: PPUSH
6034: LD_INT 0
6036: PPUSH
6037: CALL_OW 49
6041: GO 6015
6043: POP
6044: POP
// for i = 1 to 3 do
6045: LD_ADDR_VAR 0 2
6049: PUSH
6050: DOUBLE
6051: LD_INT 1
6053: DEC
6054: ST_TO_ADDR
6055: LD_INT 3
6057: PUSH
6058: FOR_TO
6059: IFFALSE 6083
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6061: LD_INT 4
6063: PPUSH
6064: LD_VAR 0 5
6068: PPUSH
6069: CALL 734 0 2
6073: PPUSH
6074: LD_INT 46
6076: PPUSH
6077: CALL_OW 52
6081: GO 6058
6083: POP
6084: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 1
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 30
6102: PUSH
6103: LD_INT 5
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: PUSH
6119: FOR_IN
6120: IFFALSE 6234
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6122: LD_INT 5
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL 734 0 2
6134: PPUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6144: LD_INT 5
6146: PPUSH
6147: LD_VAR 0 5
6151: PPUSH
6152: CALL 734 0 2
6156: PPUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 5
6173: PPUSH
6174: CALL 734 0 2
6178: PPUSH
6179: LD_VAR 0 2
6183: PPUSH
6184: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6188: LD_INT 1
6190: PPUSH
6191: LD_VAR 0 5
6195: PPUSH
6196: CALL 734 0 2
6200: PPUSH
6201: LD_VAR 0 2
6205: PPUSH
6206: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6210: LD_INT 1
6212: PPUSH
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL 734 0 2
6222: PPUSH
6223: LD_VAR 0 2
6227: PPUSH
6228: CALL_OW 52
// end ;
6232: GO 6119
6234: POP
6235: POP
// if dif > 1 then
6236: LD_EXP 1
6240: PUSH
6241: LD_INT 1
6243: GREATER
6244: IFFALSE 6317
// for i = 1 to ( dif - 1 ) do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_EXP 1
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: PUSH
6265: FOR_TO
6266: IFFALSE 6315
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6268: LD_ADDR_EXP 17
6272: PUSH
6273: LD_EXP 17
6277: PUSH
6278: LD_INT 1
6280: PPUSH
6281: LD_VAR 0 5
6285: PPUSH
6286: CALL 734 0 2
6290: ADD
6291: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6292: LD_EXP 17
6296: PUSH
6297: LD_VAR 0 2
6301: ARRAY
6302: PPUSH
6303: LD_INT 3
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// end ;
6313: GO 6265
6315: POP
6316: POP
// game_started := true ;
6317: LD_ADDR_EXP 10
6321: PUSH
6322: LD_INT 1
6324: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6325: LD_INT 26
6327: PPUSH
6328: LD_INT 3
6330: PPUSH
6331: LD_INT 2
6333: PPUSH
6334: LD_INT 2
6336: PPUSH
6337: LD_INT 13
6339: PPUSH
6340: CALL_OW 125
// while ( contact_am = false ) do
6344: LD_EXP 16
6348: PUSH
6349: LD_INT 0
6351: EQUAL
6352: IFFALSE 6363
// begin Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// end ;
6361: GO 6344
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6363: LD_INT 8400
6365: PUSH
6366: LD_INT 6300
6368: PUSH
6369: LD_INT 5250
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: LD_EXP 1
6381: ARRAY
6382: PPUSH
6383: CALL_OW 67
// case dif of 1 :
6387: LD_EXP 1
6391: PUSH
6392: LD_INT 1
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6575
6400: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6401: LD_INT 26
6403: PPUSH
6404: LD_INT 3
6406: PPUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: LD_INT 5
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 4
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6447: LD_INT 26
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: LD_INT 1
6455: PPUSH
6456: LD_INT 2
6458: PPUSH
6459: LD_INT 4
6461: PUSH
6462: LD_INT 5
6464: PUSH
6465: LD_INT 5
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 1
6475: PPUSH
6476: LD_INT 3
6478: PPUSH
6479: CALL_OW 12
6483: ARRAY
6484: PPUSH
6485: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6489: LD_INT 26
6491: PPUSH
6492: LD_INT 3
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: LD_INT 4
6503: PUSH
6504: LD_INT 5
6506: PUSH
6507: LD_INT 5
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 3
6520: PPUSH
6521: CALL_OW 12
6525: ARRAY
6526: PPUSH
6527: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6531: LD_INT 26
6533: PPUSH
6534: LD_INT 3
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_INT 2
6542: PPUSH
6543: LD_INT 4
6545: PUSH
6546: LD_INT 3
6548: PUSH
6549: LD_INT 5
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 1
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 12
6567: ARRAY
6568: PPUSH
6569: CALL_OW 185
// end ; 2 :
6573: GO 7102
6575: LD_INT 2
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6796
6583: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6584: LD_INT 26
6586: PPUSH
6587: LD_INT 3
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 2
6595: PPUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: LD_INT 5
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 3
6615: PPUSH
6616: CALL_OW 12
6620: ARRAY
6621: PPUSH
6622: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6626: LD_INT 26
6628: PPUSH
6629: LD_INT 3
6631: PPUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 4
6640: PUSH
6641: LD_INT 5
6643: PUSH
6644: LD_INT 5
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 3
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6668: LD_INT 26
6670: PPUSH
6671: LD_INT 3
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: LD_INT 2
6679: PPUSH
6680: LD_INT 4
6682: PUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 5
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 3
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: PPUSH
6706: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6710: LD_INT 26
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 2
6721: PPUSH
6722: LD_INT 4
6724: PUSH
6725: LD_INT 5
6727: PUSH
6728: LD_INT 6
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 1
6738: PPUSH
6739: LD_INT 3
6741: PPUSH
6742: CALL_OW 12
6746: ARRAY
6747: PPUSH
6748: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6752: LD_INT 26
6754: PPUSH
6755: LD_INT 4
6757: PPUSH
6758: LD_INT 1
6760: PPUSH
6761: LD_INT 2
6763: PPUSH
6764: LD_INT 4
6766: PUSH
6767: LD_INT 5
6769: PUSH
6770: LD_INT 6
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: CALL_OW 185
// end ; 3 :
6794: GO 7102
6796: LD_INT 3
6798: DOUBLE
6799: EQUAL
6800: IFTRUE 6804
6802: GO 7101
6804: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6805: LD_INT 26
6807: PPUSH
6808: LD_INT 3
6810: PPUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_INT 2
6816: PPUSH
6817: LD_INT 4
6819: PUSH
6820: LD_INT 5
6822: PUSH
6823: LD_INT 5
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: LD_INT 1
6833: PPUSH
6834: LD_INT 3
6836: PPUSH
6837: CALL_OW 12
6841: ARRAY
6842: PPUSH
6843: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6847: LD_INT 26
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 1
6855: PPUSH
6856: LD_INT 2
6858: PPUSH
6859: LD_INT 4
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 5
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 3
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6889: LD_INT 26
6891: PPUSH
6892: LD_INT 3
6894: PPUSH
6895: LD_INT 1
6897: PPUSH
6898: LD_INT 2
6900: PPUSH
6901: LD_INT 4
6903: PUSH
6904: LD_INT 5
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 1
6917: PPUSH
6918: LD_INT 3
6920: PPUSH
6921: CALL_OW 12
6925: ARRAY
6926: PPUSH
6927: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6931: LD_INT 26
6933: PPUSH
6934: LD_INT 3
6936: PPUSH
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 2
6942: PPUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 5
6948: PUSH
6949: LD_INT 5
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 1
6959: PPUSH
6960: LD_INT 3
6962: PPUSH
6963: CALL_OW 12
6967: ARRAY
6968: PPUSH
6969: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6973: LD_INT 26
6975: PPUSH
6976: LD_INT 4
6978: PPUSH
6979: LD_INT 1
6981: PPUSH
6982: LD_INT 2
6984: PPUSH
6985: LD_INT 4
6987: PUSH
6988: LD_INT 5
6990: PUSH
6991: LD_INT 6
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 1
7001: PPUSH
7002: LD_INT 3
7004: PPUSH
7005: CALL_OW 12
7009: ARRAY
7010: PPUSH
7011: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7015: LD_INT 26
7017: PPUSH
7018: LD_INT 4
7020: PPUSH
7021: LD_INT 1
7023: PPUSH
7024: LD_INT 2
7026: PPUSH
7027: LD_INT 4
7029: PUSH
7030: LD_INT 5
7032: PUSH
7033: LD_INT 6
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: LIST
7040: PUSH
7041: LD_INT 1
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 12
7051: ARRAY
7052: PPUSH
7053: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7057: LD_INT 26
7059: PPUSH
7060: LD_INT 4
7062: PPUSH
7063: LD_INT 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: LD_INT 4
7071: PUSH
7072: LD_INT 5
7074: PUSH
7075: LD_INT 6
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 1
7085: PPUSH
7086: LD_INT 3
7088: PPUSH
7089: CALL_OW 12
7093: ARRAY
7094: PPUSH
7095: CALL_OW 185
// end ; end ;
7099: GO 7102
7101: POP
// end ;
7102: LD_VAR 0 1
7106: RET
// every 0 0$01 do var i , filter ;
7107: GO 7109
7109: DISABLE
7110: LD_INT 0
7112: PPUSH
7113: PPUSH
// begin enable ;
7114: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7115: LD_INT 22
7117: PUSH
7118: LD_INT 1
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 25
7127: PUSH
7128: LD_INT 4
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: LD_INT 0
7146: GREATER
7147: IFFALSE 7156
// RaiseSailEvent ( 3 ) ;
7149: LD_INT 3
7151: PPUSH
7152: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7156: LD_INT 22
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 21
7168: PUSH
7169: LD_INT 3
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: PUSH
7203: LD_INT 0
7205: GREATER
7206: IFFALSE 7217
// RaiseSailEvent ( 1 ) else
7208: LD_INT 1
7210: PPUSH
7211: CALL_OW 427
7215: GO 7224
// RaiseSailEvent ( 2 ) ;
7217: LD_INT 2
7219: PPUSH
7220: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7224: LD_INT 22
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 30
7236: PUSH
7237: LD_INT 5
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PPUSH
7248: CALL_OW 69
7252: PUSH
7253: LD_INT 0
7255: GREATER
7256: IFFALSE 7265
// RaiseSailEvent ( 4 ) ;
7258: LD_INT 4
7260: PPUSH
7261: CALL_OW 427
// if gamma_towers > 0 then
7265: LD_EXP 18
7269: PUSH
7270: LD_INT 0
7272: GREATER
7273: IFFALSE 7282
// RaiseSailEvent ( 5 ) ;
7275: LD_INT 5
7277: PPUSH
7278: CALL_OW 427
// end ;
7282: PPOPN 2
7284: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7285: GO 7287
7287: DISABLE
7288: LD_INT 0
7290: PPUSH
7291: PPUSH
// begin enable ;
7292: ENABLE
// if new_veh > 0 then
7293: LD_EXP 19
7297: PUSH
7298: LD_INT 0
7300: GREATER
7301: IFFALSE 7488
// while ( new_veh > 0 ) do
7303: LD_EXP 19
7307: PUSH
7308: LD_INT 0
7310: GREATER
7311: IFFALSE 7488
// begin Wait ( 0 0$01 ) ;
7313: LD_INT 35
7315: PPUSH
7316: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7320: LD_INT 26
7322: PPUSH
7323: CALL_OW 461
7327: PUSH
7328: LD_INT 2
7330: EQUAL
7331: IFFALSE 7486
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7333: LD_ADDR_VAR 0 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 3
7343: PUSH
7344: LD_INT 3
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 1
7358: PPUSH
7359: LD_INT 4
7361: PPUSH
7362: CALL_OW 12
7366: ARRAY
7367: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7368: LD_VAR 0 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: IN
7383: IFFALSE 7418
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7385: LD_ADDR_VAR 0 2
7389: PUSH
7390: LD_INT 4
7392: PUSH
7393: LD_INT 5
7395: PUSH
7396: LD_INT 7
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 1
7406: PPUSH
7407: LD_INT 3
7409: PPUSH
7410: CALL_OW 12
7414: ARRAY
7415: ST_TO_ADDR
7416: GO 7449
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_INT 5
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: LD_INT 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 3
7442: PPUSH
7443: CALL_OW 12
7447: ARRAY
7448: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7449: LD_INT 26
7451: PPUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: LD_INT 2
7462: PPUSH
7463: LD_VAR 0 2
7467: PPUSH
7468: CALL_OW 125
// new_veh := new_veh - 1 ;
7472: LD_ADDR_EXP 19
7476: PUSH
7477: LD_EXP 19
7481: PUSH
7482: LD_INT 1
7484: MINUS
7485: ST_TO_ADDR
// end ; end ;
7486: GO 7303
// end ;
7488: PPOPN 2
7490: END
// every 0 0$01 do var v , filter , am_cmeh ;
7491: GO 7493
7493: DISABLE
7494: LD_INT 0
7496: PPUSH
7497: PPUSH
7498: PPUSH
// begin enable ;
7499: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7500: LD_ADDR_VAR 0 3
7504: PUSH
7505: LD_INT 56
7507: PPUSH
7508: CALL_OW 313
7512: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 33
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 50
7540: PUSH
7541: EMPTY
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: EMPTY
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: ST_TO_ADDR
// if filter > 0 then
7557: LD_VAR 0 2
7561: PUSH
7562: LD_INT 0
7564: GREATER
7565: IFFALSE 7633
// begin for v in filter do
7567: LD_ADDR_VAR 0 1
7571: PUSH
7572: LD_VAR 0 2
7576: PUSH
7577: FOR_IN
7578: IFFALSE 7631
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7580: LD_VAR 0 1
7584: PPUSH
7585: CALL_OW 312
7589: NOT
7590: PUSH
7591: LD_VAR 0 1
7595: PPUSH
7596: CALL_OW 302
7600: AND
7601: IFFALSE 7629
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_VAR 0 3
7612: PUSH
7613: LD_INT 1
7615: PPUSH
7616: LD_INT 3
7618: PPUSH
7619: CALL_OW 12
7623: ARRAY
7624: PPUSH
7625: CALL_OW 135
// end ;
7629: GO 7577
7631: POP
7632: POP
// end ; end ;
7633: PPOPN 3
7635: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7636: LD_INT 33
7638: PUSH
7639: LD_INT 2
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 3
7648: PUSH
7649: LD_INT 34
7651: PUSH
7652: LD_INT 13
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: PUSH
7672: LD_INT 4
7674: PUSH
7675: LD_INT 5
7677: PUSH
7678: LD_INT 7
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_EXP 1
7690: ARRAY
7691: EQUAL
7692: PUSH
7693: LD_INT 26
7695: PPUSH
7696: CALL_OW 461
7700: PUSH
7701: LD_INT 2
7703: EQUAL
7704: AND
7705: IFFALSE 7916
7707: GO 7709
7709: DISABLE
7710: LD_INT 0
7712: PPUSH
7713: PPUSH
7714: PPUSH
// begin enable ;
7715: ENABLE
// if Sikorski_Ar then
7716: LD_EXP 12
7720: IFFALSE 7797
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7722: LD_ADDR_EXP 11
7726: PUSH
7727: LD_INT 2
7729: PUSH
7730: LD_INT 22
7732: PUSH
7733: LD_INT 4
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 22
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 33
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 34
7765: PUSH
7766: LD_INT 13
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: ST_TO_ADDR
7795: GO 7838
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7797: LD_ADDR_EXP 11
7801: PUSH
7802: LD_INT 33
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 3
7814: PUSH
7815: LD_INT 34
7817: PUSH
7818: LD_INT 13
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 69
7837: ST_TO_ADDR
// repeat begin for un in SForce do
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_EXP 11
7847: PUSH
7848: FOR_IN
7849: IFFALSE 7904
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7851: LD_ADDR_VAR 0 3
7855: PUSH
7856: LD_INT 22
7858: PUSH
7859: LD_INT 3
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7871: LD_VAR 0 2
7875: PPUSH
7876: LD_VAR 0 3
7880: PPUSH
7881: LD_VAR 0 2
7885: PPUSH
7886: CALL_OW 74
7890: PPUSH
7891: CALL_OW 115
// Wait ( 0 0$01 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// end ;
7902: GO 7848
7904: POP
7905: POP
// end until SForce = 0 ;
7906: LD_EXP 11
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7838
// end ;
7916: PPOPN 3
7918: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7919: LD_INT 0
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
7925: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7926: LD_ADDR_VAR 0 6
7930: PUSH
7931: LD_INT 14
7933: PPUSH
7934: EMPTY
7935: PPUSH
7936: CALL_OW 70
7940: ST_TO_ADDR
// if tmp then
7941: LD_VAR 0 6
7945: IFFALSE 7979
// for i in tmp do
7947: LD_ADDR_VAR 0 3
7951: PUSH
7952: LD_VAR 0 6
7956: PUSH
7957: FOR_IN
7958: IFFALSE 7977
// ComMoveXY ( i , 42 , 23 ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: LD_INT 42
7967: PPUSH
7968: LD_INT 23
7970: PPUSH
7971: CALL_OW 111
7975: GO 7957
7977: POP
7978: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7979: LD_INT 14
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: CALL_OW 286
// uc_side := 4 ;
7989: LD_ADDR_OWVAR 20
7993: PUSH
7994: LD_INT 4
7996: ST_TO_ADDR
// uc_nation := 1 ;
7997: LD_ADDR_OWVAR 21
8001: PUSH
8002: LD_INT 1
8004: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8005: LD_ADDR_OWVAR 37
8009: PUSH
8010: LD_INT 4
8012: ST_TO_ADDR
// vc_control := control_manual ;
8013: LD_ADDR_OWVAR 38
8017: PUSH
8018: LD_INT 1
8020: ST_TO_ADDR
// vc_engine := engine_combustion ;
8021: LD_ADDR_OWVAR 39
8025: PUSH
8026: LD_INT 1
8028: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8029: LD_ADDR_OWVAR 40
8033: PUSH
8034: LD_INT 4
8036: PUSH
8037: LD_INT 5
8039: PUSH
8040: LD_INT 7
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_EXP 1
8052: ARRAY
8053: ST_TO_ADDR
// veh := CreateVehicle ;
8054: LD_ADDR_VAR 0 5
8058: PUSH
8059: CALL_OW 45
8063: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8064: LD_VAR 0 5
8068: PPUSH
8069: LD_INT 2
8071: PPUSH
8072: LD_INT 0
8074: PPUSH
8075: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8079: LD_EXP 9
8083: PPUSH
8084: LD_VAR 0 5
8088: PPUSH
8089: CALL_OW 52
// SetMark ( veh , 1 ) ;
8093: LD_VAR 0 5
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 242
// while ( num > 0 ) do
8105: LD_VAR 0 1
8109: PUSH
8110: LD_INT 0
8112: GREATER
8113: IFFALSE 8280
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8115: LD_INT 3
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: LD_INT 3
8123: PUSH
8124: LD_INT 4
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_EXP 1
8137: PPUSH
8138: LD_INT 4
8140: PPUSH
8141: CALL_OW 12
8145: ARRAY
8146: PPUSH
8147: LD_INT 1
8149: PPUSH
8150: LD_INT 4
8152: PUSH
8153: LD_INT 5
8155: PUSH
8156: LD_INT 5
8158: PUSH
8159: LD_INT 7
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_EXP 1
8175: PUSH
8176: LD_INT 1
8178: PLUS
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 11
8188: PPUSH
8189: LD_INT 2
8191: PPUSH
8192: LD_INT 5
8194: PUSH
8195: LD_INT 6
8197: PUSH
8198: LD_INT 7
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_EXP 1
8210: ARRAY
8211: PPUSH
8212: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8216: LD_ADDR_VAR 0 4
8220: PUSH
8221: LD_INT 22
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 69
8235: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8236: LD_VAR 0 4
8240: PUSH
8241: LD_VAR 0 4
8245: ARRAY
8246: PPUSH
8247: LD_INT 36
8249: PPUSH
8250: LD_INT 18
8252: PPUSH
8253: CALL_OW 111
// Wait ( 0 0$02 ) ;
8257: LD_INT 70
8259: PPUSH
8260: CALL_OW 67
// num := num - 1 ;
8264: LD_ADDR_VAR 0 1
8268: PUSH
8269: LD_VAR 0 1
8273: PUSH
8274: LD_INT 1
8276: MINUS
8277: ST_TO_ADDR
// end ;
8278: GO 8105
// end ;
8280: LD_VAR 0 2
8284: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8285: LD_EXP 17
8289: PUSH
8290: LD_INT 0
8292: GREATER
8293: IFFALSE 8562
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
// begin enable ;
8301: ENABLE
// for i = 1 to patrol do
8302: LD_ADDR_VAR 0 1
8306: PUSH
8307: DOUBLE
8308: LD_INT 1
8310: DEC
8311: ST_TO_ADDR
8312: LD_EXP 17
8316: PUSH
8317: FOR_TO
8318: IFFALSE 8560
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8320: LD_EXP 17
8324: PUSH
8325: LD_VAR 0 1
8329: ARRAY
8330: PUSH
8331: LD_EXP 17
8335: PUSH
8336: LD_VAR 0 1
8340: ARRAY
8341: PPUSH
8342: CALL_OW 300
8346: AND
8347: PUSH
8348: LD_EXP 17
8352: PUSH
8353: LD_VAR 0 1
8357: ARRAY
8358: PPUSH
8359: CALL_OW 314
8363: NOT
8364: AND
8365: IFFALSE 8515
// case i of 1 :
8367: LD_VAR 0 1
8371: PUSH
8372: LD_INT 1
8374: DOUBLE
8375: EQUAL
8376: IFTRUE 8380
8378: GO 8443
8380: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8381: LD_EXP 17
8385: PUSH
8386: LD_VAR 0 1
8390: ARRAY
8391: PPUSH
8392: LD_INT 53
8394: PPUSH
8395: LD_INT 91
8397: PPUSH
8398: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8402: LD_EXP 17
8406: PUSH
8407: LD_VAR 0 1
8411: ARRAY
8412: PPUSH
8413: LD_INT 245
8415: PPUSH
8416: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8420: LD_EXP 17
8424: PUSH
8425: LD_VAR 0 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 24
8433: PPUSH
8434: LD_INT 26
8436: PPUSH
8437: CALL_OW 171
// end ; 2 :
8441: GO 8515
8443: LD_INT 2
8445: DOUBLE
8446: EQUAL
8447: IFTRUE 8451
8449: GO 8514
8451: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8452: LD_EXP 17
8456: PUSH
8457: LD_VAR 0 1
8461: ARRAY
8462: PPUSH
8463: LD_INT 83
8465: PPUSH
8466: LD_INT 57
8468: PPUSH
8469: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8473: LD_EXP 17
8477: PUSH
8478: LD_VAR 0 1
8482: ARRAY
8483: PPUSH
8484: LD_INT 245
8486: PPUSH
8487: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8491: LD_EXP 17
8495: PUSH
8496: LD_VAR 0 1
8500: ARRAY
8501: PPUSH
8502: LD_INT 47
8504: PPUSH
8505: LD_INT 53
8507: PPUSH
8508: CALL_OW 171
// end ; end ;
8512: GO 8515
8514: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8515: LD_EXP 17
8519: PUSH
8520: LD_VAR 0 1
8524: ARRAY
8525: PPUSH
8526: CALL_OW 256
8530: PUSH
8531: LD_INT 1000
8533: LESS
8534: IFFALSE 8558
// patrol := patrol diff patrol [ i ] ;
8536: LD_ADDR_EXP 17
8540: PUSH
8541: LD_EXP 17
8545: PUSH
8546: LD_EXP 17
8550: PUSH
8551: LD_VAR 0 1
8555: ARRAY
8556: DIFF
8557: ST_TO_ADDR
// end ;
8558: GO 8317
8560: POP
8561: POP
// end ;
8562: PPOPN 1
8564: END
// every 0 0$10 do
8565: GO 8567
8567: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8568: LD_INT 42000
8570: PUSH
8571: LD_INT 37800
8573: PUSH
8574: LD_INT 33600
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_EXP 1
8586: ARRAY
8587: PPUSH
8588: CALL_OW 67
// if not contact_am then
8592: LD_EXP 16
8596: NOT
8597: IFFALSE 8607
// contact_am := true ;
8599: LD_ADDR_EXP 16
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// end ; end_of_file
8607: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8608: LD_INT 0
8610: PPUSH
// comp_tested := false ;
8611: LD_ADDR_EXP 22
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sikorski_run := false ;
8619: LD_ADDR_EXP 23
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// InGameOn ;
8627: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8631: LD_EXP 3
8635: PPUSH
8636: CALL_OW 87
// Wait ( 0 0$01 ) ;
8640: LD_INT 35
8642: PPUSH
8643: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8647: LD_EXP 2
8651: PPUSH
8652: LD_STRING Dpop1
8654: PPUSH
8655: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8659: LD_EXP 3
8663: PPUSH
8664: LD_STRING Dcomm1
8666: PPUSH
8667: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8671: LD_EXP 2
8675: PPUSH
8676: LD_STRING Dpop2
8678: PPUSH
8679: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8683: LD_EXP 3
8687: PPUSH
8688: LD_STRING Dcomm2
8690: PPUSH
8691: CALL_OW 88
// InGameOff ;
8695: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8699: LD_STRING T1
8701: PPUSH
8702: CALL_OW 337
// end ;
8706: LD_VAR 0 1
8710: RET
// every 0 0$01 trigger timer > 2 2$01 do
8711: LD_EXP 24
8715: PUSH
8716: LD_INT 4235
8718: GREATER
8719: IFFALSE 8736
8721: GO 8723
8723: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8724: LD_EXP 5
8728: PPUSH
8729: LD_STRING DKap1
8731: PPUSH
8732: CALL_OW 94
// end ;
8736: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8737: LD_EXP 24
8741: PUSH
8742: LD_INT 46200
8744: PUSH
8745: LD_INT 52500
8747: PUSH
8748: LD_INT 63000
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: LD_EXP 1
8760: ARRAY
8761: GREATER
8762: IFFALSE 9129
8764: GO 8766
8766: DISABLE
8767: LD_INT 0
8769: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8770: LD_EXP 5
8774: PPUSH
8775: LD_STRING DKap2
8777: PPUSH
8778: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8782: LD_INT 10
8784: PPUSH
8785: CALL_OW 67
// Say ( commander , Dcommk ) ;
8789: LD_EXP 3
8793: PPUSH
8794: LD_STRING Dcommk
8796: PPUSH
8797: CALL_OW 88
// Wait ( 0 0$44 ) ;
8801: LD_INT 1540
8803: PPUSH
8804: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8808: LD_EXP 5
8812: PPUSH
8813: LD_INT 3
8815: PPUSH
8816: LD_INT 0
8818: PPUSH
8819: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8823: LD_EXP 5
8827: PPUSH
8828: CALL_OW 87
// Wait ( 0 0$10 ) ;
8832: LD_INT 350
8834: PPUSH
8835: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8839: LD_INT 6
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 8
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_EXP 1
8857: ARRAY
8858: PPUSH
8859: CALL 7919 0 1
// Wait ( 2 2$00 ) ;
8863: LD_INT 4200
8865: PPUSH
8866: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8870: LD_INT 33
8872: PUSH
8873: LD_INT 2
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 3
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 13
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 69
8905: PUSH
8906: LD_INT 3
8908: LESS
8909: IFFALSE 8920
// Wait ( 0 0$01 ) ;
8911: LD_INT 35
8913: PPUSH
8914: CALL_OW 67
8918: GO 8870
// uc_side := 4 ;
8920: LD_ADDR_OWVAR 20
8924: PUSH
8925: LD_INT 4
8927: ST_TO_ADDR
// uc_nation := 1 ;
8928: LD_ADDR_OWVAR 21
8932: PUSH
8933: LD_INT 1
8935: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8936: LD_ADDR_VAR 0 1
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_INT 4
8948: PUSH
8949: LD_INT 5
8951: PUSH
8952: LD_INT 6
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: PUSH
8960: LD_EXP 1
8964: ARRAY
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9009
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8969: LD_INT 1
8971: PPUSH
8972: LD_INT 5
8974: PUSH
8975: LD_INT 6
8977: PUSH
8978: LD_INT 7
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: LIST
8985: PUSH
8986: LD_EXP 1
8990: ARRAY
8991: PPUSH
8992: CALL 734 0 2
8996: PPUSH
8997: LD_INT 4
8999: PPUSH
9000: LD_INT 0
9002: PPUSH
9003: CALL_OW 49
9007: GO 8966
9009: POP
9010: POP
// sikorski_ar := true ;
9011: LD_ADDR_EXP 12
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9019: LD_EXP 9
9023: PPUSH
9024: LD_STRING DSik1
9026: PPUSH
9027: CALL_OW 94
// Wait ( 0 0$30 ) ;
9031: LD_INT 1050
9033: PPUSH
9034: CALL_OW 67
// uc_side := 4 ;
9038: LD_ADDR_OWVAR 20
9042: PUSH
9043: LD_INT 4
9045: ST_TO_ADDR
// uc_nation := 1 ;
9046: LD_ADDR_OWVAR 21
9050: PUSH
9051: LD_INT 1
9053: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: DOUBLE
9060: LD_INT 1
9062: DEC
9063: ST_TO_ADDR
9064: LD_INT 3
9066: PUSH
9067: LD_INT 4
9069: PUSH
9070: LD_INT 4
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_EXP 1
9082: ARRAY
9083: PUSH
9084: FOR_TO
9085: IFFALSE 9127
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9087: LD_INT 1
9089: PPUSH
9090: LD_INT 5
9092: PUSH
9093: LD_INT 6
9095: PUSH
9096: LD_INT 7
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: LD_EXP 1
9108: ARRAY
9109: PPUSH
9110: CALL 734 0 2
9114: PPUSH
9115: LD_INT 13
9117: PPUSH
9118: LD_INT 0
9120: PPUSH
9121: CALL_OW 49
9125: GO 9084
9127: POP
9128: POP
// end ;
9129: PPOPN 1
9131: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9132: LD_EXP 9
9136: PPUSH
9137: CALL_OW 256
9141: PUSH
9142: LD_INT 650
9144: LESS
9145: IFFALSE 9227
9147: GO 9149
9149: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9150: LD_EXP 9
9154: PPUSH
9155: LD_STRING DSik2
9157: PPUSH
9158: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9162: LD_EXP 9
9166: PPUSH
9167: CALL_OW 300
9171: IFFALSE 9227
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9173: LD_EXP 9
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 113
// Wait ( 0 0$01 ) ;
9185: LD_INT 35
9187: PPUSH
9188: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9192: LD_EXP 9
9196: PPUSH
9197: LD_INT 2
9199: PPUSH
9200: CALL_OW 308
9204: IFFALSE 9225
// begin RemoveUnit ( sikorski ) ;
9206: LD_EXP 9
9210: PPUSH
9211: CALL_OW 64
// break ;
9215: GO 9227
// sikorski_run := true ;
9217: LD_ADDR_EXP 23
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// end ; end ;
9225: GO 9162
// end ;
9227: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9228: LD_EXP 9
9232: PPUSH
9233: CALL_OW 256
9237: PUSH
9238: LD_INT 1000
9240: LESS
9241: IFFALSE 9258
9243: GO 9245
9245: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9246: LD_EXP 9
9250: PPUSH
9251: LD_STRING DSkik3
9253: PPUSH
9254: CALL_OW 88
9258: END
// every 1 1$45 + 0 0$15 do
9259: GO 9261
9261: DISABLE
// begin enable ;
9262: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9263: LD_INT 1
9265: PPUSH
9266: LD_INT 5
9268: PPUSH
9269: CALL_OW 12
9273: PPUSH
9274: LD_INT 8
9276: PPUSH
9277: LD_INT 1
9279: PPUSH
9280: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9284: LD_INT 350
9286: PPUSH
9287: LD_INT 1295
9289: PPUSH
9290: CALL_OW 12
9294: PPUSH
9295: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9299: LD_INT 1
9301: PPUSH
9302: LD_INT 5
9304: PPUSH
9305: CALL_OW 12
9309: PPUSH
9310: LD_INT 1
9312: PPUSH
9313: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9317: LD_INT 350
9319: PPUSH
9320: LD_INT 1050
9322: PPUSH
9323: CALL_OW 12
9327: PPUSH
9328: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9332: LD_EXP 24
9336: PUSH
9337: LD_INT 25200
9339: PUSH
9340: LD_INT 23100
9342: PUSH
9343: LD_INT 21000
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_EXP 1
9355: ARRAY
9356: LESSEQUAL
9357: IFFALSE 9380
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9359: LD_INT 1
9361: PPUSH
9362: LD_INT 5
9364: PPUSH
9365: CALL_OW 12
9369: PPUSH
9370: LD_INT 8
9372: PPUSH
9373: LD_INT 1
9375: PPUSH
9376: CALL_OW 55
// end ;
9380: END
// export timer ; every 1 do
9381: GO 9383
9383: DISABLE
// timer := 0 0$00 ;
9384: LD_ADDR_EXP 24
9388: PUSH
9389: LD_INT 0
9391: ST_TO_ADDR
9392: END
// every 0 0$01 do
9393: GO 9395
9395: DISABLE
// begin enable ;
9396: ENABLE
// Display_Strings := [ #tick , timer ] ;
9397: LD_ADDR_OWVAR 47
9401: PUSH
9402: LD_STRING #tick
9404: PUSH
9405: LD_EXP 24
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9414: LD_ADDR_EXP 24
9418: PUSH
9419: LD_EXP 24
9423: PUSH
9424: LD_INT 35
9426: PLUS
9427: ST_TO_ADDR
// end ; end_of_file
9428: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9429: GO 9431
9431: DISABLE
// begin ru_radar := 98 ;
9432: LD_ADDR_EXP 25
9436: PUSH
9437: LD_INT 98
9439: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9440: LD_ADDR_EXP 26
9444: PUSH
9445: LD_INT 89
9447: ST_TO_ADDR
// us_hack := 99 ;
9448: LD_ADDR_EXP 27
9452: PUSH
9453: LD_INT 99
9455: ST_TO_ADDR
// us_artillery := 97 ;
9456: LD_ADDR_EXP 28
9460: PUSH
9461: LD_INT 97
9463: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9464: LD_ADDR_EXP 29
9468: PUSH
9469: LD_INT 91
9471: ST_TO_ADDR
// end ; end_of_file end_of_file
9472: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
9473: GO 9475
9475: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
9476: LD_STRING initStreamRollete();
9478: PPUSH
9479: CALL_OW 559
// InitStreamMode ;
9483: CALL 9492 0 0
// DefineStreamItems ( ) ;
9487: CALL 9932 0 0
// end ;
9491: END
// function InitStreamMode ; begin
9492: LD_INT 0
9494: PPUSH
// streamModeActive := false ;
9495: LD_ADDR_EXP 30
9499: PUSH
9500: LD_INT 0
9502: ST_TO_ADDR
// normalCounter := 26 ;
9503: LD_ADDR_EXP 31
9507: PUSH
9508: LD_INT 26
9510: ST_TO_ADDR
// hardcoreCounter := 12 ;
9511: LD_ADDR_EXP 32
9515: PUSH
9516: LD_INT 12
9518: ST_TO_ADDR
// sRocket := false ;
9519: LD_ADDR_EXP 35
9523: PUSH
9524: LD_INT 0
9526: ST_TO_ADDR
// sSpeed := false ;
9527: LD_ADDR_EXP 34
9531: PUSH
9532: LD_INT 0
9534: ST_TO_ADDR
// sEngine := false ;
9535: LD_ADDR_EXP 36
9539: PUSH
9540: LD_INT 0
9542: ST_TO_ADDR
// sSpec := false ;
9543: LD_ADDR_EXP 33
9547: PUSH
9548: LD_INT 0
9550: ST_TO_ADDR
// sLevel := false ;
9551: LD_ADDR_EXP 37
9555: PUSH
9556: LD_INT 0
9558: ST_TO_ADDR
// sArmoury := false ;
9559: LD_ADDR_EXP 38
9563: PUSH
9564: LD_INT 0
9566: ST_TO_ADDR
// sRadar := false ;
9567: LD_ADDR_EXP 39
9571: PUSH
9572: LD_INT 0
9574: ST_TO_ADDR
// sBunker := false ;
9575: LD_ADDR_EXP 40
9579: PUSH
9580: LD_INT 0
9582: ST_TO_ADDR
// sHack := false ;
9583: LD_ADDR_EXP 41
9587: PUSH
9588: LD_INT 0
9590: ST_TO_ADDR
// sFire := false ;
9591: LD_ADDR_EXP 42
9595: PUSH
9596: LD_INT 0
9598: ST_TO_ADDR
// sRefresh := false ;
9599: LD_ADDR_EXP 43
9603: PUSH
9604: LD_INT 0
9606: ST_TO_ADDR
// sExp := false ;
9607: LD_ADDR_EXP 44
9611: PUSH
9612: LD_INT 0
9614: ST_TO_ADDR
// sDepot := false ;
9615: LD_ADDR_EXP 45
9619: PUSH
9620: LD_INT 0
9622: ST_TO_ADDR
// sFlag := false ;
9623: LD_ADDR_EXP 46
9627: PUSH
9628: LD_INT 0
9630: ST_TO_ADDR
// sKamikadze := false ;
9631: LD_ADDR_EXP 54
9635: PUSH
9636: LD_INT 0
9638: ST_TO_ADDR
// sTroll := false ;
9639: LD_ADDR_EXP 55
9643: PUSH
9644: LD_INT 0
9646: ST_TO_ADDR
// sSlow := false ;
9647: LD_ADDR_EXP 56
9651: PUSH
9652: LD_INT 0
9654: ST_TO_ADDR
// sLack := false ;
9655: LD_ADDR_EXP 57
9659: PUSH
9660: LD_INT 0
9662: ST_TO_ADDR
// sTank := false ;
9663: LD_ADDR_EXP 59
9667: PUSH
9668: LD_INT 0
9670: ST_TO_ADDR
// sRemote := false ;
9671: LD_ADDR_EXP 60
9675: PUSH
9676: LD_INT 0
9678: ST_TO_ADDR
// sPowell := false ;
9679: LD_ADDR_EXP 61
9683: PUSH
9684: LD_INT 0
9686: ST_TO_ADDR
// sTeleport := false ;
9687: LD_ADDR_EXP 64
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// sOilTower := false ;
9695: LD_ADDR_EXP 66
9699: PUSH
9700: LD_INT 0
9702: ST_TO_ADDR
// sShovel := false ;
9703: LD_ADDR_EXP 67
9707: PUSH
9708: LD_INT 0
9710: ST_TO_ADDR
// sSheik := false ;
9711: LD_ADDR_EXP 68
9715: PUSH
9716: LD_INT 0
9718: ST_TO_ADDR
// sEarthquake := false ;
9719: LD_ADDR_EXP 70
9723: PUSH
9724: LD_INT 0
9726: ST_TO_ADDR
// sAI := false ;
9727: LD_ADDR_EXP 71
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// sCargo := false ;
9735: LD_ADDR_EXP 74
9739: PUSH
9740: LD_INT 0
9742: ST_TO_ADDR
// sDLaser := false ;
9743: LD_ADDR_EXP 75
9747: PUSH
9748: LD_INT 0
9750: ST_TO_ADDR
// sExchange := false ;
9751: LD_ADDR_EXP 76
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// sFac := false ;
9759: LD_ADDR_EXP 77
9763: PUSH
9764: LD_INT 0
9766: ST_TO_ADDR
// sPower := false ;
9767: LD_ADDR_EXP 78
9771: PUSH
9772: LD_INT 0
9774: ST_TO_ADDR
// sRandom := false ;
9775: LD_ADDR_EXP 79
9779: PUSH
9780: LD_INT 0
9782: ST_TO_ADDR
// sShield := false ;
9783: LD_ADDR_EXP 80
9787: PUSH
9788: LD_INT 0
9790: ST_TO_ADDR
// sTime := false ;
9791: LD_ADDR_EXP 81
9795: PUSH
9796: LD_INT 0
9798: ST_TO_ADDR
// sTools := false ;
9799: LD_ADDR_EXP 82
9803: PUSH
9804: LD_INT 0
9806: ST_TO_ADDR
// sSold := false ;
9807: LD_ADDR_EXP 47
9811: PUSH
9812: LD_INT 0
9814: ST_TO_ADDR
// sDiff := false ;
9815: LD_ADDR_EXP 48
9819: PUSH
9820: LD_INT 0
9822: ST_TO_ADDR
// sFog := false ;
9823: LD_ADDR_EXP 51
9827: PUSH
9828: LD_INT 0
9830: ST_TO_ADDR
// sReset := false ;
9831: LD_ADDR_EXP 52
9835: PUSH
9836: LD_INT 0
9838: ST_TO_ADDR
// sSun := false ;
9839: LD_ADDR_EXP 53
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// sTiger := false ;
9847: LD_ADDR_EXP 49
9851: PUSH
9852: LD_INT 0
9854: ST_TO_ADDR
// sBomb := false ;
9855: LD_ADDR_EXP 50
9859: PUSH
9860: LD_INT 0
9862: ST_TO_ADDR
// sWound := false ;
9863: LD_ADDR_EXP 58
9867: PUSH
9868: LD_INT 0
9870: ST_TO_ADDR
// sBetray := false ;
9871: LD_ADDR_EXP 62
9875: PUSH
9876: LD_INT 0
9878: ST_TO_ADDR
// sContamin := false ;
9879: LD_ADDR_EXP 63
9883: PUSH
9884: LD_INT 0
9886: ST_TO_ADDR
// sOil := false ;
9887: LD_ADDR_EXP 65
9891: PUSH
9892: LD_INT 0
9894: ST_TO_ADDR
// sStu := false ;
9895: LD_ADDR_EXP 69
9899: PUSH
9900: LD_INT 0
9902: ST_TO_ADDR
// sBazooka := false ;
9903: LD_ADDR_EXP 72
9907: PUSH
9908: LD_INT 0
9910: ST_TO_ADDR
// sMortar := false ;
9911: LD_ADDR_EXP 73
9915: PUSH
9916: LD_INT 0
9918: ST_TO_ADDR
// sRanger := false ;
9919: LD_ADDR_EXP 83
9923: PUSH
9924: LD_INT 0
9926: ST_TO_ADDR
// end ;
9927: LD_VAR 0 1
9931: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9932: LD_INT 0
9934: PPUSH
9935: PPUSH
9936: PPUSH
9937: PPUSH
9938: PPUSH
// result := [ ] ;
9939: LD_ADDR_VAR 0 1
9943: PUSH
9944: EMPTY
9945: ST_TO_ADDR
// if campaign_id = 1 then
9946: LD_OWVAR 69
9950: PUSH
9951: LD_INT 1
9953: EQUAL
9954: IFFALSE 12890
// begin case mission_number of 1 :
9956: LD_OWVAR 70
9960: PUSH
9961: LD_INT 1
9963: DOUBLE
9964: EQUAL
9965: IFTRUE 9969
9967: GO 10033
9969: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9970: LD_ADDR_VAR 0 1
9974: PUSH
9975: LD_INT 2
9977: PUSH
9978: LD_INT 4
9980: PUSH
9981: LD_INT 11
9983: PUSH
9984: LD_INT 12
9986: PUSH
9987: LD_INT 15
9989: PUSH
9990: LD_INT 16
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_INT 23
9998: PUSH
9999: LD_INT 26
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: PUSH
10013: LD_INT 101
10015: PUSH
10016: LD_INT 102
10018: PUSH
10019: LD_INT 106
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: LIST
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: ST_TO_ADDR
10031: GO 12890
10033: LD_INT 2
10035: DOUBLE
10036: EQUAL
10037: IFTRUE 10041
10039: GO 10113
10041: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
10042: LD_ADDR_VAR 0 1
10046: PUSH
10047: LD_INT 2
10049: PUSH
10050: LD_INT 4
10052: PUSH
10053: LD_INT 11
10055: PUSH
10056: LD_INT 12
10058: PUSH
10059: LD_INT 15
10061: PUSH
10062: LD_INT 16
10064: PUSH
10065: LD_INT 22
10067: PUSH
10068: LD_INT 23
10070: PUSH
10071: LD_INT 26
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 101
10087: PUSH
10088: LD_INT 102
10090: PUSH
10091: LD_INT 105
10093: PUSH
10094: LD_INT 106
10096: PUSH
10097: LD_INT 108
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: ST_TO_ADDR
10111: GO 12890
10113: LD_INT 3
10115: DOUBLE
10116: EQUAL
10117: IFTRUE 10121
10119: GO 10197
10121: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
10122: LD_ADDR_VAR 0 1
10126: PUSH
10127: LD_INT 2
10129: PUSH
10130: LD_INT 4
10132: PUSH
10133: LD_INT 5
10135: PUSH
10136: LD_INT 11
10138: PUSH
10139: LD_INT 12
10141: PUSH
10142: LD_INT 15
10144: PUSH
10145: LD_INT 16
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 26
10153: PUSH
10154: LD_INT 36
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: PUSH
10169: LD_INT 101
10171: PUSH
10172: LD_INT 102
10174: PUSH
10175: LD_INT 105
10177: PUSH
10178: LD_INT 106
10180: PUSH
10181: LD_INT 108
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: ST_TO_ADDR
10195: GO 12890
10197: LD_INT 4
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10289
10205: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
10206: LD_ADDR_VAR 0 1
10210: PUSH
10211: LD_INT 2
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 8
10222: PUSH
10223: LD_INT 11
10225: PUSH
10226: LD_INT 12
10228: PUSH
10229: LD_INT 15
10231: PUSH
10232: LD_INT 16
10234: PUSH
10235: LD_INT 22
10237: PUSH
10238: LD_INT 23
10240: PUSH
10241: LD_INT 26
10243: PUSH
10244: LD_INT 36
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 101
10263: PUSH
10264: LD_INT 102
10266: PUSH
10267: LD_INT 105
10269: PUSH
10270: LD_INT 106
10272: PUSH
10273: LD_INT 108
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: ST_TO_ADDR
10287: GO 12890
10289: LD_INT 5
10291: DOUBLE
10292: EQUAL
10293: IFTRUE 10297
10295: GO 10397
10297: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
10298: LD_ADDR_VAR 0 1
10302: PUSH
10303: LD_INT 2
10305: PUSH
10306: LD_INT 4
10308: PUSH
10309: LD_INT 5
10311: PUSH
10312: LD_INT 6
10314: PUSH
10315: LD_INT 8
10317: PUSH
10318: LD_INT 11
10320: PUSH
10321: LD_INT 12
10323: PUSH
10324: LD_INT 15
10326: PUSH
10327: LD_INT 16
10329: PUSH
10330: LD_INT 22
10332: PUSH
10333: LD_INT 23
10335: PUSH
10336: LD_INT 25
10338: PUSH
10339: LD_INT 26
10341: PUSH
10342: LD_INT 36
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PUSH
10361: LD_INT 101
10363: PUSH
10364: LD_INT 102
10366: PUSH
10367: LD_INT 105
10369: PUSH
10370: LD_INT 106
10372: PUSH
10373: LD_INT 108
10375: PUSH
10376: LD_INT 109
10378: PUSH
10379: LD_INT 112
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: ST_TO_ADDR
10395: GO 12890
10397: LD_INT 6
10399: DOUBLE
10400: EQUAL
10401: IFTRUE 10405
10403: GO 10525
10405: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
10406: LD_ADDR_VAR 0 1
10410: PUSH
10411: LD_INT 2
10413: PUSH
10414: LD_INT 4
10416: PUSH
10417: LD_INT 5
10419: PUSH
10420: LD_INT 6
10422: PUSH
10423: LD_INT 8
10425: PUSH
10426: LD_INT 11
10428: PUSH
10429: LD_INT 12
10431: PUSH
10432: LD_INT 15
10434: PUSH
10435: LD_INT 16
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 21
10443: PUSH
10444: LD_INT 22
10446: PUSH
10447: LD_INT 23
10449: PUSH
10450: LD_INT 25
10452: PUSH
10453: LD_INT 26
10455: PUSH
10456: LD_INT 30
10458: PUSH
10459: LD_INT 31
10461: PUSH
10462: LD_INT 32
10464: PUSH
10465: LD_INT 36
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 101
10491: PUSH
10492: LD_INT 102
10494: PUSH
10495: LD_INT 105
10497: PUSH
10498: LD_INT 106
10500: PUSH
10501: LD_INT 108
10503: PUSH
10504: LD_INT 109
10506: PUSH
10507: LD_INT 112
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: ST_TO_ADDR
10523: GO 12890
10525: LD_INT 7
10527: DOUBLE
10528: EQUAL
10529: IFTRUE 10533
10531: GO 10633
10533: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
10534: LD_ADDR_VAR 0 1
10538: PUSH
10539: LD_INT 2
10541: PUSH
10542: LD_INT 4
10544: PUSH
10545: LD_INT 5
10547: PUSH
10548: LD_INT 7
10550: PUSH
10551: LD_INT 11
10553: PUSH
10554: LD_INT 12
10556: PUSH
10557: LD_INT 15
10559: PUSH
10560: LD_INT 16
10562: PUSH
10563: LD_INT 20
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 22
10571: PUSH
10572: LD_INT 23
10574: PUSH
10575: LD_INT 25
10577: PUSH
10578: LD_INT 26
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: PUSH
10597: LD_INT 101
10599: PUSH
10600: LD_INT 102
10602: PUSH
10603: LD_INT 103
10605: PUSH
10606: LD_INT 105
10608: PUSH
10609: LD_INT 106
10611: PUSH
10612: LD_INT 108
10614: PUSH
10615: LD_INT 112
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: ST_TO_ADDR
10631: GO 12890
10633: LD_INT 8
10635: DOUBLE
10636: EQUAL
10637: IFTRUE 10641
10639: GO 10769
10641: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
10642: LD_ADDR_VAR 0 1
10646: PUSH
10647: LD_INT 2
10649: PUSH
10650: LD_INT 4
10652: PUSH
10653: LD_INT 5
10655: PUSH
10656: LD_INT 6
10658: PUSH
10659: LD_INT 7
10661: PUSH
10662: LD_INT 8
10664: PUSH
10665: LD_INT 11
10667: PUSH
10668: LD_INT 12
10670: PUSH
10671: LD_INT 15
10673: PUSH
10674: LD_INT 16
10676: PUSH
10677: LD_INT 20
10679: PUSH
10680: LD_INT 21
10682: PUSH
10683: LD_INT 22
10685: PUSH
10686: LD_INT 23
10688: PUSH
10689: LD_INT 25
10691: PUSH
10692: LD_INT 26
10694: PUSH
10695: LD_INT 30
10697: PUSH
10698: LD_INT 31
10700: PUSH
10701: LD_INT 32
10703: PUSH
10704: LD_INT 36
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: PUSH
10729: LD_INT 101
10731: PUSH
10732: LD_INT 102
10734: PUSH
10735: LD_INT 103
10737: PUSH
10738: LD_INT 105
10740: PUSH
10741: LD_INT 106
10743: PUSH
10744: LD_INT 108
10746: PUSH
10747: LD_INT 109
10749: PUSH
10750: LD_INT 112
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: LIST
10759: LIST
10760: LIST
10761: LIST
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: ST_TO_ADDR
10767: GO 12890
10769: LD_INT 9
10771: DOUBLE
10772: EQUAL
10773: IFTRUE 10777
10775: GO 10913
10777: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
10778: LD_ADDR_VAR 0 1
10782: PUSH
10783: LD_INT 2
10785: PUSH
10786: LD_INT 4
10788: PUSH
10789: LD_INT 5
10791: PUSH
10792: LD_INT 6
10794: PUSH
10795: LD_INT 7
10797: PUSH
10798: LD_INT 8
10800: PUSH
10801: LD_INT 11
10803: PUSH
10804: LD_INT 12
10806: PUSH
10807: LD_INT 15
10809: PUSH
10810: LD_INT 16
10812: PUSH
10813: LD_INT 20
10815: PUSH
10816: LD_INT 21
10818: PUSH
10819: LD_INT 22
10821: PUSH
10822: LD_INT 23
10824: PUSH
10825: LD_INT 25
10827: PUSH
10828: LD_INT 26
10830: PUSH
10831: LD_INT 28
10833: PUSH
10834: LD_INT 30
10836: PUSH
10837: LD_INT 31
10839: PUSH
10840: LD_INT 32
10842: PUSH
10843: LD_INT 36
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 101
10871: PUSH
10872: LD_INT 102
10874: PUSH
10875: LD_INT 103
10877: PUSH
10878: LD_INT 105
10880: PUSH
10881: LD_INT 106
10883: PUSH
10884: LD_INT 108
10886: PUSH
10887: LD_INT 109
10889: PUSH
10890: LD_INT 112
10892: PUSH
10893: LD_INT 114
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: ST_TO_ADDR
10911: GO 12890
10913: LD_INT 10
10915: DOUBLE
10916: EQUAL
10917: IFTRUE 10921
10919: GO 11105
10921: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10922: LD_ADDR_VAR 0 1
10926: PUSH
10927: LD_INT 2
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: LD_INT 5
10935: PUSH
10936: LD_INT 6
10938: PUSH
10939: LD_INT 7
10941: PUSH
10942: LD_INT 8
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: LD_INT 10
10950: PUSH
10951: LD_INT 11
10953: PUSH
10954: LD_INT 12
10956: PUSH
10957: LD_INT 13
10959: PUSH
10960: LD_INT 14
10962: PUSH
10963: LD_INT 15
10965: PUSH
10966: LD_INT 16
10968: PUSH
10969: LD_INT 17
10971: PUSH
10972: LD_INT 18
10974: PUSH
10975: LD_INT 19
10977: PUSH
10978: LD_INT 20
10980: PUSH
10981: LD_INT 21
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 23
10989: PUSH
10990: LD_INT 24
10992: PUSH
10993: LD_INT 25
10995: PUSH
10996: LD_INT 26
10998: PUSH
10999: LD_INT 28
11001: PUSH
11002: LD_INT 30
11004: PUSH
11005: LD_INT 31
11007: PUSH
11008: LD_INT 32
11010: PUSH
11011: LD_INT 36
11013: PUSH
11014: EMPTY
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 101
11047: PUSH
11048: LD_INT 102
11050: PUSH
11051: LD_INT 103
11053: PUSH
11054: LD_INT 104
11056: PUSH
11057: LD_INT 105
11059: PUSH
11060: LD_INT 106
11062: PUSH
11063: LD_INT 107
11065: PUSH
11066: LD_INT 108
11068: PUSH
11069: LD_INT 109
11071: PUSH
11072: LD_INT 110
11074: PUSH
11075: LD_INT 111
11077: PUSH
11078: LD_INT 112
11080: PUSH
11081: LD_INT 114
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: ST_TO_ADDR
11103: GO 12890
11105: LD_INT 11
11107: DOUBLE
11108: EQUAL
11109: IFTRUE 11113
11111: GO 11305
11113: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: LD_INT 3
11124: PUSH
11125: LD_INT 4
11127: PUSH
11128: LD_INT 5
11130: PUSH
11131: LD_INT 6
11133: PUSH
11134: LD_INT 7
11136: PUSH
11137: LD_INT 8
11139: PUSH
11140: LD_INT 9
11142: PUSH
11143: LD_INT 10
11145: PUSH
11146: LD_INT 11
11148: PUSH
11149: LD_INT 12
11151: PUSH
11152: LD_INT 13
11154: PUSH
11155: LD_INT 14
11157: PUSH
11158: LD_INT 15
11160: PUSH
11161: LD_INT 16
11163: PUSH
11164: LD_INT 17
11166: PUSH
11167: LD_INT 18
11169: PUSH
11170: LD_INT 19
11172: PUSH
11173: LD_INT 20
11175: PUSH
11176: LD_INT 21
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_INT 23
11184: PUSH
11185: LD_INT 24
11187: PUSH
11188: LD_INT 25
11190: PUSH
11191: LD_INT 26
11193: PUSH
11194: LD_INT 28
11196: PUSH
11197: LD_INT 30
11199: PUSH
11200: LD_INT 31
11202: PUSH
11203: LD_INT 32
11205: PUSH
11206: LD_INT 34
11208: PUSH
11209: LD_INT 36
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: PUSH
11245: LD_INT 101
11247: PUSH
11248: LD_INT 102
11250: PUSH
11251: LD_INT 103
11253: PUSH
11254: LD_INT 104
11256: PUSH
11257: LD_INT 105
11259: PUSH
11260: LD_INT 106
11262: PUSH
11263: LD_INT 107
11265: PUSH
11266: LD_INT 108
11268: PUSH
11269: LD_INT 109
11271: PUSH
11272: LD_INT 110
11274: PUSH
11275: LD_INT 111
11277: PUSH
11278: LD_INT 112
11280: PUSH
11281: LD_INT 114
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: PUSH
11299: EMPTY
11300: LIST
11301: LIST
11302: ST_TO_ADDR
11303: GO 12890
11305: LD_INT 12
11307: DOUBLE
11308: EQUAL
11309: IFTRUE 11313
11311: GO 11521
11313: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
11314: LD_ADDR_VAR 0 1
11318: PUSH
11319: LD_INT 1
11321: PUSH
11322: LD_INT 2
11324: PUSH
11325: LD_INT 3
11327: PUSH
11328: LD_INT 4
11330: PUSH
11331: LD_INT 5
11333: PUSH
11334: LD_INT 6
11336: PUSH
11337: LD_INT 7
11339: PUSH
11340: LD_INT 8
11342: PUSH
11343: LD_INT 9
11345: PUSH
11346: LD_INT 10
11348: PUSH
11349: LD_INT 11
11351: PUSH
11352: LD_INT 12
11354: PUSH
11355: LD_INT 13
11357: PUSH
11358: LD_INT 14
11360: PUSH
11361: LD_INT 15
11363: PUSH
11364: LD_INT 16
11366: PUSH
11367: LD_INT 17
11369: PUSH
11370: LD_INT 18
11372: PUSH
11373: LD_INT 19
11375: PUSH
11376: LD_INT 20
11378: PUSH
11379: LD_INT 21
11381: PUSH
11382: LD_INT 22
11384: PUSH
11385: LD_INT 23
11387: PUSH
11388: LD_INT 24
11390: PUSH
11391: LD_INT 25
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 27
11399: PUSH
11400: LD_INT 28
11402: PUSH
11403: LD_INT 30
11405: PUSH
11406: LD_INT 31
11408: PUSH
11409: LD_INT 32
11411: PUSH
11412: LD_INT 33
11414: PUSH
11415: LD_INT 34
11417: PUSH
11418: LD_INT 36
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: PUSH
11457: LD_INT 101
11459: PUSH
11460: LD_INT 102
11462: PUSH
11463: LD_INT 103
11465: PUSH
11466: LD_INT 104
11468: PUSH
11469: LD_INT 105
11471: PUSH
11472: LD_INT 106
11474: PUSH
11475: LD_INT 107
11477: PUSH
11478: LD_INT 108
11480: PUSH
11481: LD_INT 109
11483: PUSH
11484: LD_INT 110
11486: PUSH
11487: LD_INT 111
11489: PUSH
11490: LD_INT 112
11492: PUSH
11493: LD_INT 113
11495: PUSH
11496: LD_INT 114
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: PUSH
11515: EMPTY
11516: LIST
11517: LIST
11518: ST_TO_ADDR
11519: GO 12890
11521: LD_INT 13
11523: DOUBLE
11524: EQUAL
11525: IFTRUE 11529
11527: GO 11725
11529: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
11530: LD_ADDR_VAR 0 1
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: LD_INT 2
11540: PUSH
11541: LD_INT 3
11543: PUSH
11544: LD_INT 4
11546: PUSH
11547: LD_INT 5
11549: PUSH
11550: LD_INT 8
11552: PUSH
11553: LD_INT 9
11555: PUSH
11556: LD_INT 10
11558: PUSH
11559: LD_INT 11
11561: PUSH
11562: LD_INT 12
11564: PUSH
11565: LD_INT 14
11567: PUSH
11568: LD_INT 15
11570: PUSH
11571: LD_INT 16
11573: PUSH
11574: LD_INT 17
11576: PUSH
11577: LD_INT 18
11579: PUSH
11580: LD_INT 19
11582: PUSH
11583: LD_INT 20
11585: PUSH
11586: LD_INT 21
11588: PUSH
11589: LD_INT 22
11591: PUSH
11592: LD_INT 23
11594: PUSH
11595: LD_INT 24
11597: PUSH
11598: LD_INT 25
11600: PUSH
11601: LD_INT 26
11603: PUSH
11604: LD_INT 27
11606: PUSH
11607: LD_INT 28
11609: PUSH
11610: LD_INT 30
11612: PUSH
11613: LD_INT 31
11615: PUSH
11616: LD_INT 32
11618: PUSH
11619: LD_INT 33
11621: PUSH
11622: LD_INT 34
11624: PUSH
11625: LD_INT 36
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 101
11663: PUSH
11664: LD_INT 102
11666: PUSH
11667: LD_INT 103
11669: PUSH
11670: LD_INT 104
11672: PUSH
11673: LD_INT 105
11675: PUSH
11676: LD_INT 106
11678: PUSH
11679: LD_INT 107
11681: PUSH
11682: LD_INT 108
11684: PUSH
11685: LD_INT 109
11687: PUSH
11688: LD_INT 110
11690: PUSH
11691: LD_INT 111
11693: PUSH
11694: LD_INT 112
11696: PUSH
11697: LD_INT 113
11699: PUSH
11700: LD_INT 114
11702: PUSH
11703: EMPTY
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: ST_TO_ADDR
11723: GO 12890
11725: LD_INT 14
11727: DOUBLE
11728: EQUAL
11729: IFTRUE 11733
11731: GO 11945
11733: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
11734: LD_ADDR_VAR 0 1
11738: PUSH
11739: LD_INT 1
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 3
11747: PUSH
11748: LD_INT 4
11750: PUSH
11751: LD_INT 5
11753: PUSH
11754: LD_INT 6
11756: PUSH
11757: LD_INT 7
11759: PUSH
11760: LD_INT 8
11762: PUSH
11763: LD_INT 9
11765: PUSH
11766: LD_INT 10
11768: PUSH
11769: LD_INT 11
11771: PUSH
11772: LD_INT 12
11774: PUSH
11775: LD_INT 13
11777: PUSH
11778: LD_INT 14
11780: PUSH
11781: LD_INT 15
11783: PUSH
11784: LD_INT 16
11786: PUSH
11787: LD_INT 17
11789: PUSH
11790: LD_INT 18
11792: PUSH
11793: LD_INT 19
11795: PUSH
11796: LD_INT 20
11798: PUSH
11799: LD_INT 21
11801: PUSH
11802: LD_INT 22
11804: PUSH
11805: LD_INT 23
11807: PUSH
11808: LD_INT 24
11810: PUSH
11811: LD_INT 25
11813: PUSH
11814: LD_INT 26
11816: PUSH
11817: LD_INT 27
11819: PUSH
11820: LD_INT 28
11822: PUSH
11823: LD_INT 29
11825: PUSH
11826: LD_INT 30
11828: PUSH
11829: LD_INT 31
11831: PUSH
11832: LD_INT 32
11834: PUSH
11835: LD_INT 33
11837: PUSH
11838: LD_INT 34
11840: PUSH
11841: LD_INT 36
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: PUSH
11881: LD_INT 101
11883: PUSH
11884: LD_INT 102
11886: PUSH
11887: LD_INT 103
11889: PUSH
11890: LD_INT 104
11892: PUSH
11893: LD_INT 105
11895: PUSH
11896: LD_INT 106
11898: PUSH
11899: LD_INT 107
11901: PUSH
11902: LD_INT 108
11904: PUSH
11905: LD_INT 109
11907: PUSH
11908: LD_INT 110
11910: PUSH
11911: LD_INT 111
11913: PUSH
11914: LD_INT 112
11916: PUSH
11917: LD_INT 113
11919: PUSH
11920: LD_INT 114
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: LIST
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: ST_TO_ADDR
11943: GO 12890
11945: LD_INT 15
11947: DOUBLE
11948: EQUAL
11949: IFTRUE 11953
11951: GO 12165
11953: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11954: LD_ADDR_VAR 0 1
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: LD_INT 2
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: LD_INT 4
11970: PUSH
11971: LD_INT 5
11973: PUSH
11974: LD_INT 6
11976: PUSH
11977: LD_INT 7
11979: PUSH
11980: LD_INT 8
11982: PUSH
11983: LD_INT 9
11985: PUSH
11986: LD_INT 10
11988: PUSH
11989: LD_INT 11
11991: PUSH
11992: LD_INT 12
11994: PUSH
11995: LD_INT 13
11997: PUSH
11998: LD_INT 14
12000: PUSH
12001: LD_INT 15
12003: PUSH
12004: LD_INT 16
12006: PUSH
12007: LD_INT 17
12009: PUSH
12010: LD_INT 18
12012: PUSH
12013: LD_INT 19
12015: PUSH
12016: LD_INT 20
12018: PUSH
12019: LD_INT 21
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 23
12027: PUSH
12028: LD_INT 24
12030: PUSH
12031: LD_INT 25
12033: PUSH
12034: LD_INT 26
12036: PUSH
12037: LD_INT 27
12039: PUSH
12040: LD_INT 28
12042: PUSH
12043: LD_INT 29
12045: PUSH
12046: LD_INT 30
12048: PUSH
12049: LD_INT 31
12051: PUSH
12052: LD_INT 32
12054: PUSH
12055: LD_INT 33
12057: PUSH
12058: LD_INT 34
12060: PUSH
12061: LD_INT 36
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: LIST
12070: LIST
12071: LIST
12072: LIST
12073: LIST
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: LIST
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 101
12103: PUSH
12104: LD_INT 102
12106: PUSH
12107: LD_INT 103
12109: PUSH
12110: LD_INT 104
12112: PUSH
12113: LD_INT 105
12115: PUSH
12116: LD_INT 106
12118: PUSH
12119: LD_INT 107
12121: PUSH
12122: LD_INT 108
12124: PUSH
12125: LD_INT 109
12127: PUSH
12128: LD_INT 110
12130: PUSH
12131: LD_INT 111
12133: PUSH
12134: LD_INT 112
12136: PUSH
12137: LD_INT 113
12139: PUSH
12140: LD_INT 114
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: ST_TO_ADDR
12163: GO 12890
12165: LD_INT 16
12167: DOUBLE
12168: EQUAL
12169: IFTRUE 12173
12171: GO 12297
12173: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
12174: LD_ADDR_VAR 0 1
12178: PUSH
12179: LD_INT 2
12181: PUSH
12182: LD_INT 4
12184: PUSH
12185: LD_INT 5
12187: PUSH
12188: LD_INT 7
12190: PUSH
12191: LD_INT 11
12193: PUSH
12194: LD_INT 12
12196: PUSH
12197: LD_INT 15
12199: PUSH
12200: LD_INT 16
12202: PUSH
12203: LD_INT 20
12205: PUSH
12206: LD_INT 21
12208: PUSH
12209: LD_INT 22
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 25
12217: PUSH
12218: LD_INT 26
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 31
12226: PUSH
12227: LD_INT 32
12229: PUSH
12230: LD_INT 33
12232: PUSH
12233: LD_INT 34
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: PUSH
12257: LD_INT 101
12259: PUSH
12260: LD_INT 102
12262: PUSH
12263: LD_INT 103
12265: PUSH
12266: LD_INT 106
12268: PUSH
12269: LD_INT 108
12271: PUSH
12272: LD_INT 112
12274: PUSH
12275: LD_INT 113
12277: PUSH
12278: LD_INT 114
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: LIST
12287: LIST
12288: LIST
12289: LIST
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: ST_TO_ADDR
12295: GO 12890
12297: LD_INT 17
12299: DOUBLE
12300: EQUAL
12301: IFTRUE 12305
12303: GO 12517
12305: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
12306: LD_ADDR_VAR 0 1
12310: PUSH
12311: LD_INT 1
12313: PUSH
12314: LD_INT 2
12316: PUSH
12317: LD_INT 3
12319: PUSH
12320: LD_INT 4
12322: PUSH
12323: LD_INT 5
12325: PUSH
12326: LD_INT 6
12328: PUSH
12329: LD_INT 7
12331: PUSH
12332: LD_INT 8
12334: PUSH
12335: LD_INT 9
12337: PUSH
12338: LD_INT 10
12340: PUSH
12341: LD_INT 11
12343: PUSH
12344: LD_INT 12
12346: PUSH
12347: LD_INT 13
12349: PUSH
12350: LD_INT 14
12352: PUSH
12353: LD_INT 15
12355: PUSH
12356: LD_INT 16
12358: PUSH
12359: LD_INT 17
12361: PUSH
12362: LD_INT 18
12364: PUSH
12365: LD_INT 19
12367: PUSH
12368: LD_INT 20
12370: PUSH
12371: LD_INT 21
12373: PUSH
12374: LD_INT 22
12376: PUSH
12377: LD_INT 23
12379: PUSH
12380: LD_INT 24
12382: PUSH
12383: LD_INT 25
12385: PUSH
12386: LD_INT 26
12388: PUSH
12389: LD_INT 27
12391: PUSH
12392: LD_INT 28
12394: PUSH
12395: LD_INT 29
12397: PUSH
12398: LD_INT 30
12400: PUSH
12401: LD_INT 31
12403: PUSH
12404: LD_INT 32
12406: PUSH
12407: LD_INT 33
12409: PUSH
12410: LD_INT 34
12412: PUSH
12413: LD_INT 36
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: LIST
12426: LIST
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: PUSH
12453: LD_INT 101
12455: PUSH
12456: LD_INT 102
12458: PUSH
12459: LD_INT 103
12461: PUSH
12462: LD_INT 104
12464: PUSH
12465: LD_INT 105
12467: PUSH
12468: LD_INT 106
12470: PUSH
12471: LD_INT 107
12473: PUSH
12474: LD_INT 108
12476: PUSH
12477: LD_INT 109
12479: PUSH
12480: LD_INT 110
12482: PUSH
12483: LD_INT 111
12485: PUSH
12486: LD_INT 112
12488: PUSH
12489: LD_INT 113
12491: PUSH
12492: LD_INT 114
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: ST_TO_ADDR
12515: GO 12890
12517: LD_INT 18
12519: DOUBLE
12520: EQUAL
12521: IFTRUE 12525
12523: GO 12661
12525: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
12526: LD_ADDR_VAR 0 1
12530: PUSH
12531: LD_INT 2
12533: PUSH
12534: LD_INT 4
12536: PUSH
12537: LD_INT 5
12539: PUSH
12540: LD_INT 7
12542: PUSH
12543: LD_INT 11
12545: PUSH
12546: LD_INT 12
12548: PUSH
12549: LD_INT 15
12551: PUSH
12552: LD_INT 16
12554: PUSH
12555: LD_INT 20
12557: PUSH
12558: LD_INT 21
12560: PUSH
12561: LD_INT 22
12563: PUSH
12564: LD_INT 23
12566: PUSH
12567: LD_INT 25
12569: PUSH
12570: LD_INT 26
12572: PUSH
12573: LD_INT 30
12575: PUSH
12576: LD_INT 31
12578: PUSH
12579: LD_INT 32
12581: PUSH
12582: LD_INT 33
12584: PUSH
12585: LD_INT 34
12587: PUSH
12588: LD_INT 35
12590: PUSH
12591: LD_INT 36
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: PUSH
12617: LD_INT 101
12619: PUSH
12620: LD_INT 102
12622: PUSH
12623: LD_INT 103
12625: PUSH
12626: LD_INT 106
12628: PUSH
12629: LD_INT 108
12631: PUSH
12632: LD_INT 112
12634: PUSH
12635: LD_INT 113
12637: PUSH
12638: LD_INT 114
12640: PUSH
12641: LD_INT 115
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: ST_TO_ADDR
12659: GO 12890
12661: LD_INT 19
12663: DOUBLE
12664: EQUAL
12665: IFTRUE 12669
12667: GO 12889
12669: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
12670: LD_ADDR_VAR 0 1
12674: PUSH
12675: LD_INT 1
12677: PUSH
12678: LD_INT 2
12680: PUSH
12681: LD_INT 3
12683: PUSH
12684: LD_INT 4
12686: PUSH
12687: LD_INT 5
12689: PUSH
12690: LD_INT 6
12692: PUSH
12693: LD_INT 7
12695: PUSH
12696: LD_INT 8
12698: PUSH
12699: LD_INT 9
12701: PUSH
12702: LD_INT 10
12704: PUSH
12705: LD_INT 11
12707: PUSH
12708: LD_INT 12
12710: PUSH
12711: LD_INT 13
12713: PUSH
12714: LD_INT 14
12716: PUSH
12717: LD_INT 15
12719: PUSH
12720: LD_INT 16
12722: PUSH
12723: LD_INT 17
12725: PUSH
12726: LD_INT 18
12728: PUSH
12729: LD_INT 19
12731: PUSH
12732: LD_INT 20
12734: PUSH
12735: LD_INT 21
12737: PUSH
12738: LD_INT 22
12740: PUSH
12741: LD_INT 23
12743: PUSH
12744: LD_INT 24
12746: PUSH
12747: LD_INT 25
12749: PUSH
12750: LD_INT 26
12752: PUSH
12753: LD_INT 27
12755: PUSH
12756: LD_INT 28
12758: PUSH
12759: LD_INT 29
12761: PUSH
12762: LD_INT 30
12764: PUSH
12765: LD_INT 31
12767: PUSH
12768: LD_INT 32
12770: PUSH
12771: LD_INT 33
12773: PUSH
12774: LD_INT 34
12776: PUSH
12777: LD_INT 35
12779: PUSH
12780: LD_INT 36
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PUSH
12821: LD_INT 101
12823: PUSH
12824: LD_INT 102
12826: PUSH
12827: LD_INT 103
12829: PUSH
12830: LD_INT 104
12832: PUSH
12833: LD_INT 105
12835: PUSH
12836: LD_INT 106
12838: PUSH
12839: LD_INT 107
12841: PUSH
12842: LD_INT 108
12844: PUSH
12845: LD_INT 109
12847: PUSH
12848: LD_INT 110
12850: PUSH
12851: LD_INT 111
12853: PUSH
12854: LD_INT 112
12856: PUSH
12857: LD_INT 113
12859: PUSH
12860: LD_INT 114
12862: PUSH
12863: LD_INT 115
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: ST_TO_ADDR
12887: GO 12890
12889: POP
// end ; if result then
12890: LD_VAR 0 1
12894: IFFALSE 13183
// begin normal :=  ;
12896: LD_ADDR_VAR 0 3
12900: PUSH
12901: LD_STRING 
12903: ST_TO_ADDR
// hardcore :=  ;
12904: LD_ADDR_VAR 0 4
12908: PUSH
12909: LD_STRING 
12911: ST_TO_ADDR
// for i = 1 to normalCounter do
12912: LD_ADDR_VAR 0 5
12916: PUSH
12917: DOUBLE
12918: LD_INT 1
12920: DEC
12921: ST_TO_ADDR
12922: LD_EXP 31
12926: PUSH
12927: FOR_TO
12928: IFFALSE 13029
// begin tmp := 0 ;
12930: LD_ADDR_VAR 0 2
12934: PUSH
12935: LD_STRING 0
12937: ST_TO_ADDR
// if result [ 1 ] then
12938: LD_VAR 0 1
12942: PUSH
12943: LD_INT 1
12945: ARRAY
12946: IFFALSE 13011
// if result [ 1 ] [ 1 ] = i then
12948: LD_VAR 0 1
12952: PUSH
12953: LD_INT 1
12955: ARRAY
12956: PUSH
12957: LD_INT 1
12959: ARRAY
12960: PUSH
12961: LD_VAR 0 5
12965: EQUAL
12966: IFFALSE 13011
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
12968: LD_ADDR_VAR 0 1
12972: PUSH
12973: LD_VAR 0 1
12977: PPUSH
12978: LD_INT 1
12980: PPUSH
12981: LD_VAR 0 1
12985: PUSH
12986: LD_INT 1
12988: ARRAY
12989: PPUSH
12990: LD_INT 1
12992: PPUSH
12993: CALL_OW 3
12997: PPUSH
12998: CALL_OW 1
13002: ST_TO_ADDR
// tmp := 1 ;
13003: LD_ADDR_VAR 0 2
13007: PUSH
13008: LD_STRING 1
13010: ST_TO_ADDR
// end ; normal := normal & tmp ;
13011: LD_ADDR_VAR 0 3
13015: PUSH
13016: LD_VAR 0 3
13020: PUSH
13021: LD_VAR 0 2
13025: STR
13026: ST_TO_ADDR
// end ;
13027: GO 12927
13029: POP
13030: POP
// for i = 1 to hardcoreCounter do
13031: LD_ADDR_VAR 0 5
13035: PUSH
13036: DOUBLE
13037: LD_INT 1
13039: DEC
13040: ST_TO_ADDR
13041: LD_EXP 32
13045: PUSH
13046: FOR_TO
13047: IFFALSE 13152
// begin tmp := 0 ;
13049: LD_ADDR_VAR 0 2
13053: PUSH
13054: LD_STRING 0
13056: ST_TO_ADDR
// if result [ 2 ] then
13057: LD_VAR 0 1
13061: PUSH
13062: LD_INT 2
13064: ARRAY
13065: IFFALSE 13134
// if result [ 2 ] [ 1 ] = 100 + i then
13067: LD_VAR 0 1
13071: PUSH
13072: LD_INT 2
13074: ARRAY
13075: PUSH
13076: LD_INT 1
13078: ARRAY
13079: PUSH
13080: LD_INT 100
13082: PUSH
13083: LD_VAR 0 5
13087: PLUS
13088: EQUAL
13089: IFFALSE 13134
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
13091: LD_ADDR_VAR 0 1
13095: PUSH
13096: LD_VAR 0 1
13100: PPUSH
13101: LD_INT 2
13103: PPUSH
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 2
13111: ARRAY
13112: PPUSH
13113: LD_INT 1
13115: PPUSH
13116: CALL_OW 3
13120: PPUSH
13121: CALL_OW 1
13125: ST_TO_ADDR
// tmp := 1 ;
13126: LD_ADDR_VAR 0 2
13130: PUSH
13131: LD_STRING 1
13133: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
13134: LD_ADDR_VAR 0 4
13138: PUSH
13139: LD_VAR 0 4
13143: PUSH
13144: LD_VAR 0 2
13148: STR
13149: ST_TO_ADDR
// end ;
13150: GO 13046
13152: POP
13153: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
13154: LD_STRING getStreamItemsFromMission("
13156: PUSH
13157: LD_VAR 0 3
13161: STR
13162: PUSH
13163: LD_STRING ","
13165: STR
13166: PUSH
13167: LD_VAR 0 4
13171: STR
13172: PUSH
13173: LD_STRING ")
13175: STR
13176: PPUSH
13177: CALL_OW 559
// end else
13181: GO 13190
// ToLua ( getStreamItemsFromMission("","") ) ;
13183: LD_STRING getStreamItemsFromMission("","")
13185: PPUSH
13186: CALL_OW 559
// end ;
13190: LD_VAR 0 1
13194: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
13195: LD_VAR 0 2
13199: PUSH
13200: LD_INT 100
13202: EQUAL
13203: IFFALSE 14152
// begin if not StreamModeActive then
13205: LD_EXP 30
13209: NOT
13210: IFFALSE 13220
// StreamModeActive := true ;
13212: LD_ADDR_EXP 30
13216: PUSH
13217: LD_INT 1
13219: ST_TO_ADDR
// if p3 = 0 then
13220: LD_VAR 0 3
13224: PUSH
13225: LD_INT 0
13227: EQUAL
13228: IFFALSE 13234
// InitStreamMode ;
13230: CALL 9492 0 0
// if p3 = 1 then
13234: LD_VAR 0 3
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13252
// sRocket := true ;
13244: LD_ADDR_EXP 35
13248: PUSH
13249: LD_INT 1
13251: ST_TO_ADDR
// if p3 = 2 then
13252: LD_VAR 0 3
13256: PUSH
13257: LD_INT 2
13259: EQUAL
13260: IFFALSE 13270
// sSpeed := true ;
13262: LD_ADDR_EXP 34
13266: PUSH
13267: LD_INT 1
13269: ST_TO_ADDR
// if p3 = 3 then
13270: LD_VAR 0 3
13274: PUSH
13275: LD_INT 3
13277: EQUAL
13278: IFFALSE 13288
// sEngine := true ;
13280: LD_ADDR_EXP 36
13284: PUSH
13285: LD_INT 1
13287: ST_TO_ADDR
// if p3 = 4 then
13288: LD_VAR 0 3
13292: PUSH
13293: LD_INT 4
13295: EQUAL
13296: IFFALSE 13306
// sSpec := true ;
13298: LD_ADDR_EXP 33
13302: PUSH
13303: LD_INT 1
13305: ST_TO_ADDR
// if p3 = 5 then
13306: LD_VAR 0 3
13310: PUSH
13311: LD_INT 5
13313: EQUAL
13314: IFFALSE 13324
// sLevel := true ;
13316: LD_ADDR_EXP 37
13320: PUSH
13321: LD_INT 1
13323: ST_TO_ADDR
// if p3 = 6 then
13324: LD_VAR 0 3
13328: PUSH
13329: LD_INT 6
13331: EQUAL
13332: IFFALSE 13342
// sArmoury := true ;
13334: LD_ADDR_EXP 38
13338: PUSH
13339: LD_INT 1
13341: ST_TO_ADDR
// if p3 = 7 then
13342: LD_VAR 0 3
13346: PUSH
13347: LD_INT 7
13349: EQUAL
13350: IFFALSE 13360
// sRadar := true ;
13352: LD_ADDR_EXP 39
13356: PUSH
13357: LD_INT 1
13359: ST_TO_ADDR
// if p3 = 8 then
13360: LD_VAR 0 3
13364: PUSH
13365: LD_INT 8
13367: EQUAL
13368: IFFALSE 13378
// sBunker := true ;
13370: LD_ADDR_EXP 40
13374: PUSH
13375: LD_INT 1
13377: ST_TO_ADDR
// if p3 = 9 then
13378: LD_VAR 0 3
13382: PUSH
13383: LD_INT 9
13385: EQUAL
13386: IFFALSE 13396
// sHack := true ;
13388: LD_ADDR_EXP 41
13392: PUSH
13393: LD_INT 1
13395: ST_TO_ADDR
// if p3 = 10 then
13396: LD_VAR 0 3
13400: PUSH
13401: LD_INT 10
13403: EQUAL
13404: IFFALSE 13414
// sFire := true ;
13406: LD_ADDR_EXP 42
13410: PUSH
13411: LD_INT 1
13413: ST_TO_ADDR
// if p3 = 11 then
13414: LD_VAR 0 3
13418: PUSH
13419: LD_INT 11
13421: EQUAL
13422: IFFALSE 13432
// sRefresh := true ;
13424: LD_ADDR_EXP 43
13428: PUSH
13429: LD_INT 1
13431: ST_TO_ADDR
// if p3 = 12 then
13432: LD_VAR 0 3
13436: PUSH
13437: LD_INT 12
13439: EQUAL
13440: IFFALSE 13450
// sExp := true ;
13442: LD_ADDR_EXP 44
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// if p3 = 13 then
13450: LD_VAR 0 3
13454: PUSH
13455: LD_INT 13
13457: EQUAL
13458: IFFALSE 13468
// sDepot := true ;
13460: LD_ADDR_EXP 45
13464: PUSH
13465: LD_INT 1
13467: ST_TO_ADDR
// if p3 = 14 then
13468: LD_VAR 0 3
13472: PUSH
13473: LD_INT 14
13475: EQUAL
13476: IFFALSE 13486
// sFlag := true ;
13478: LD_ADDR_EXP 46
13482: PUSH
13483: LD_INT 1
13485: ST_TO_ADDR
// if p3 = 15 then
13486: LD_VAR 0 3
13490: PUSH
13491: LD_INT 15
13493: EQUAL
13494: IFFALSE 13504
// sKamikadze := true ;
13496: LD_ADDR_EXP 54
13500: PUSH
13501: LD_INT 1
13503: ST_TO_ADDR
// if p3 = 16 then
13504: LD_VAR 0 3
13508: PUSH
13509: LD_INT 16
13511: EQUAL
13512: IFFALSE 13522
// sTroll := true ;
13514: LD_ADDR_EXP 55
13518: PUSH
13519: LD_INT 1
13521: ST_TO_ADDR
// if p3 = 17 then
13522: LD_VAR 0 3
13526: PUSH
13527: LD_INT 17
13529: EQUAL
13530: IFFALSE 13540
// sSlow := true ;
13532: LD_ADDR_EXP 56
13536: PUSH
13537: LD_INT 1
13539: ST_TO_ADDR
// if p3 = 18 then
13540: LD_VAR 0 3
13544: PUSH
13545: LD_INT 18
13547: EQUAL
13548: IFFALSE 13558
// sLack := true ;
13550: LD_ADDR_EXP 57
13554: PUSH
13555: LD_INT 1
13557: ST_TO_ADDR
// if p3 = 19 then
13558: LD_VAR 0 3
13562: PUSH
13563: LD_INT 19
13565: EQUAL
13566: IFFALSE 13576
// sTank := true ;
13568: LD_ADDR_EXP 59
13572: PUSH
13573: LD_INT 1
13575: ST_TO_ADDR
// if p3 = 20 then
13576: LD_VAR 0 3
13580: PUSH
13581: LD_INT 20
13583: EQUAL
13584: IFFALSE 13594
// sRemote := true ;
13586: LD_ADDR_EXP 60
13590: PUSH
13591: LD_INT 1
13593: ST_TO_ADDR
// if p3 = 21 then
13594: LD_VAR 0 3
13598: PUSH
13599: LD_INT 21
13601: EQUAL
13602: IFFALSE 13612
// sPowell := true ;
13604: LD_ADDR_EXP 61
13608: PUSH
13609: LD_INT 1
13611: ST_TO_ADDR
// if p3 = 22 then
13612: LD_VAR 0 3
13616: PUSH
13617: LD_INT 22
13619: EQUAL
13620: IFFALSE 13630
// sTeleport := true ;
13622: LD_ADDR_EXP 64
13626: PUSH
13627: LD_INT 1
13629: ST_TO_ADDR
// if p3 = 23 then
13630: LD_VAR 0 3
13634: PUSH
13635: LD_INT 23
13637: EQUAL
13638: IFFALSE 13648
// sOilTower := true ;
13640: LD_ADDR_EXP 66
13644: PUSH
13645: LD_INT 1
13647: ST_TO_ADDR
// if p3 = 24 then
13648: LD_VAR 0 3
13652: PUSH
13653: LD_INT 24
13655: EQUAL
13656: IFFALSE 13666
// sShovel := true ;
13658: LD_ADDR_EXP 67
13662: PUSH
13663: LD_INT 1
13665: ST_TO_ADDR
// if p3 = 25 then
13666: LD_VAR 0 3
13670: PUSH
13671: LD_INT 25
13673: EQUAL
13674: IFFALSE 13684
// sSheik := true ;
13676: LD_ADDR_EXP 68
13680: PUSH
13681: LD_INT 1
13683: ST_TO_ADDR
// if p3 = 26 then
13684: LD_VAR 0 3
13688: PUSH
13689: LD_INT 26
13691: EQUAL
13692: IFFALSE 13702
// sEarthquake := true ;
13694: LD_ADDR_EXP 70
13698: PUSH
13699: LD_INT 1
13701: ST_TO_ADDR
// if p3 = 27 then
13702: LD_VAR 0 3
13706: PUSH
13707: LD_INT 27
13709: EQUAL
13710: IFFALSE 13720
// sAI := true ;
13712: LD_ADDR_EXP 71
13716: PUSH
13717: LD_INT 1
13719: ST_TO_ADDR
// if p3 = 28 then
13720: LD_VAR 0 3
13724: PUSH
13725: LD_INT 28
13727: EQUAL
13728: IFFALSE 13738
// sCargo := true ;
13730: LD_ADDR_EXP 74
13734: PUSH
13735: LD_INT 1
13737: ST_TO_ADDR
// if p3 = 29 then
13738: LD_VAR 0 3
13742: PUSH
13743: LD_INT 29
13745: EQUAL
13746: IFFALSE 13756
// sDLaser := true ;
13748: LD_ADDR_EXP 75
13752: PUSH
13753: LD_INT 1
13755: ST_TO_ADDR
// if p3 = 30 then
13756: LD_VAR 0 3
13760: PUSH
13761: LD_INT 30
13763: EQUAL
13764: IFFALSE 13774
// sExchange := true ;
13766: LD_ADDR_EXP 76
13770: PUSH
13771: LD_INT 1
13773: ST_TO_ADDR
// if p3 = 31 then
13774: LD_VAR 0 3
13778: PUSH
13779: LD_INT 31
13781: EQUAL
13782: IFFALSE 13792
// sFac := true ;
13784: LD_ADDR_EXP 77
13788: PUSH
13789: LD_INT 1
13791: ST_TO_ADDR
// if p3 = 32 then
13792: LD_VAR 0 3
13796: PUSH
13797: LD_INT 32
13799: EQUAL
13800: IFFALSE 13810
// sPower := true ;
13802: LD_ADDR_EXP 78
13806: PUSH
13807: LD_INT 1
13809: ST_TO_ADDR
// if p3 = 33 then
13810: LD_VAR 0 3
13814: PUSH
13815: LD_INT 33
13817: EQUAL
13818: IFFALSE 13828
// sRandom := true ;
13820: LD_ADDR_EXP 79
13824: PUSH
13825: LD_INT 1
13827: ST_TO_ADDR
// if p3 = 34 then
13828: LD_VAR 0 3
13832: PUSH
13833: LD_INT 34
13835: EQUAL
13836: IFFALSE 13846
// sShield := true ;
13838: LD_ADDR_EXP 80
13842: PUSH
13843: LD_INT 1
13845: ST_TO_ADDR
// if p3 = 35 then
13846: LD_VAR 0 3
13850: PUSH
13851: LD_INT 35
13853: EQUAL
13854: IFFALSE 13864
// sTime := true ;
13856: LD_ADDR_EXP 81
13860: PUSH
13861: LD_INT 1
13863: ST_TO_ADDR
// if p3 = 36 then
13864: LD_VAR 0 3
13868: PUSH
13869: LD_INT 36
13871: EQUAL
13872: IFFALSE 13882
// sTools := true ;
13874: LD_ADDR_EXP 82
13878: PUSH
13879: LD_INT 1
13881: ST_TO_ADDR
// if p3 = 101 then
13882: LD_VAR 0 3
13886: PUSH
13887: LD_INT 101
13889: EQUAL
13890: IFFALSE 13900
// sSold := true ;
13892: LD_ADDR_EXP 47
13896: PUSH
13897: LD_INT 1
13899: ST_TO_ADDR
// if p3 = 102 then
13900: LD_VAR 0 3
13904: PUSH
13905: LD_INT 102
13907: EQUAL
13908: IFFALSE 13918
// sDiff := true ;
13910: LD_ADDR_EXP 48
13914: PUSH
13915: LD_INT 1
13917: ST_TO_ADDR
// if p3 = 103 then
13918: LD_VAR 0 3
13922: PUSH
13923: LD_INT 103
13925: EQUAL
13926: IFFALSE 13936
// sFog := true ;
13928: LD_ADDR_EXP 51
13932: PUSH
13933: LD_INT 1
13935: ST_TO_ADDR
// if p3 = 104 then
13936: LD_VAR 0 3
13940: PUSH
13941: LD_INT 104
13943: EQUAL
13944: IFFALSE 13954
// sReset := true ;
13946: LD_ADDR_EXP 52
13950: PUSH
13951: LD_INT 1
13953: ST_TO_ADDR
// if p3 = 105 then
13954: LD_VAR 0 3
13958: PUSH
13959: LD_INT 105
13961: EQUAL
13962: IFFALSE 13972
// sSun := true ;
13964: LD_ADDR_EXP 53
13968: PUSH
13969: LD_INT 1
13971: ST_TO_ADDR
// if p3 = 106 then
13972: LD_VAR 0 3
13976: PUSH
13977: LD_INT 106
13979: EQUAL
13980: IFFALSE 13990
// sTiger := true ;
13982: LD_ADDR_EXP 49
13986: PUSH
13987: LD_INT 1
13989: ST_TO_ADDR
// if p3 = 107 then
13990: LD_VAR 0 3
13994: PUSH
13995: LD_INT 107
13997: EQUAL
13998: IFFALSE 14008
// sBomb := true ;
14000: LD_ADDR_EXP 50
14004: PUSH
14005: LD_INT 1
14007: ST_TO_ADDR
// if p3 = 108 then
14008: LD_VAR 0 3
14012: PUSH
14013: LD_INT 108
14015: EQUAL
14016: IFFALSE 14026
// sWound := true ;
14018: LD_ADDR_EXP 58
14022: PUSH
14023: LD_INT 1
14025: ST_TO_ADDR
// if p3 = 109 then
14026: LD_VAR 0 3
14030: PUSH
14031: LD_INT 109
14033: EQUAL
14034: IFFALSE 14044
// sBetray := true ;
14036: LD_ADDR_EXP 62
14040: PUSH
14041: LD_INT 1
14043: ST_TO_ADDR
// if p3 = 110 then
14044: LD_VAR 0 3
14048: PUSH
14049: LD_INT 110
14051: EQUAL
14052: IFFALSE 14062
// sContamin := true ;
14054: LD_ADDR_EXP 63
14058: PUSH
14059: LD_INT 1
14061: ST_TO_ADDR
// if p3 = 111 then
14062: LD_VAR 0 3
14066: PUSH
14067: LD_INT 111
14069: EQUAL
14070: IFFALSE 14080
// sOil := true ;
14072: LD_ADDR_EXP 65
14076: PUSH
14077: LD_INT 1
14079: ST_TO_ADDR
// if p3 = 112 then
14080: LD_VAR 0 3
14084: PUSH
14085: LD_INT 112
14087: EQUAL
14088: IFFALSE 14098
// sStu := true ;
14090: LD_ADDR_EXP 69
14094: PUSH
14095: LD_INT 1
14097: ST_TO_ADDR
// if p3 = 113 then
14098: LD_VAR 0 3
14102: PUSH
14103: LD_INT 113
14105: EQUAL
14106: IFFALSE 14116
// sBazooka := true ;
14108: LD_ADDR_EXP 72
14112: PUSH
14113: LD_INT 1
14115: ST_TO_ADDR
// if p3 = 114 then
14116: LD_VAR 0 3
14120: PUSH
14121: LD_INT 114
14123: EQUAL
14124: IFFALSE 14134
// sMortar := true ;
14126: LD_ADDR_EXP 73
14130: PUSH
14131: LD_INT 1
14133: ST_TO_ADDR
// if p3 = 115 then
14134: LD_VAR 0 3
14138: PUSH
14139: LD_INT 115
14141: EQUAL
14142: IFFALSE 14152
// sRanger := true ;
14144: LD_ADDR_EXP 83
14148: PUSH
14149: LD_INT 1
14151: ST_TO_ADDR
// end ; end ;
14152: PPOPN 6
14154: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
14155: LD_EXP 30
14159: PUSH
14160: LD_EXP 35
14164: AND
14165: IFFALSE 14289
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
// begin enable ;
14174: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
14175: LD_ADDR_VAR 0 2
14179: PUSH
14180: LD_INT 22
14182: PUSH
14183: LD_OWVAR 2
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PUSH
14192: LD_INT 2
14194: PUSH
14195: LD_INT 34
14197: PUSH
14198: LD_INT 7
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PUSH
14205: LD_INT 34
14207: PUSH
14208: LD_INT 45
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: LD_INT 34
14217: PUSH
14218: LD_INT 28
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: PUSH
14225: LD_INT 34
14227: PUSH
14228: LD_INT 47
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: PPUSH
14246: CALL_OW 69
14250: ST_TO_ADDR
// if not tmp then
14251: LD_VAR 0 2
14255: NOT
14256: IFFALSE 14260
// exit ;
14258: GO 14289
// for i in tmp do
14260: LD_ADDR_VAR 0 1
14264: PUSH
14265: LD_VAR 0 2
14269: PUSH
14270: FOR_IN
14271: IFFALSE 14287
// begin SetLives ( i , 0 ) ;
14273: LD_VAR 0 1
14277: PPUSH
14278: LD_INT 0
14280: PPUSH
14281: CALL_OW 234
// end ;
14285: GO 14270
14287: POP
14288: POP
// end ;
14289: PPOPN 2
14291: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
14292: LD_EXP 30
14296: PUSH
14297: LD_EXP 36
14301: AND
14302: IFFALSE 14386
14304: GO 14306
14306: DISABLE
14307: LD_INT 0
14309: PPUSH
14310: PPUSH
// begin enable ;
14311: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
14312: LD_ADDR_VAR 0 2
14316: PUSH
14317: LD_INT 22
14319: PUSH
14320: LD_OWVAR 2
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PUSH
14329: LD_INT 32
14331: PUSH
14332: LD_INT 3
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PPUSH
14343: CALL_OW 69
14347: ST_TO_ADDR
// if not tmp then
14348: LD_VAR 0 2
14352: NOT
14353: IFFALSE 14357
// exit ;
14355: GO 14386
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14384
// begin SetLives ( i , 0 ) ;
14370: LD_VAR 0 1
14374: PPUSH
14375: LD_INT 0
14377: PPUSH
14378: CALL_OW 234
// end ;
14382: GO 14367
14384: POP
14385: POP
// end ;
14386: PPOPN 2
14388: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
14389: LD_EXP 30
14393: PUSH
14394: LD_EXP 33
14398: AND
14399: IFFALSE 14492
14401: GO 14403
14403: DISABLE
14404: LD_INT 0
14406: PPUSH
// begin enable ;
14407: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
14408: LD_ADDR_VAR 0 1
14412: PUSH
14413: LD_INT 22
14415: PUSH
14416: LD_OWVAR 2
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 25
14430: PUSH
14431: LD_INT 5
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 25
14440: PUSH
14441: LD_INT 9
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 25
14450: PUSH
14451: LD_INT 8
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: LIST
14462: LIST
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PPUSH
14468: CALL_OW 69
14472: PUSH
14473: FOR_IN
14474: IFFALSE 14490
// begin SetClass ( i , 1 ) ;
14476: LD_VAR 0 1
14480: PPUSH
14481: LD_INT 1
14483: PPUSH
14484: CALL_OW 336
// end ;
14488: GO 14473
14490: POP
14491: POP
// end ;
14492: PPOPN 1
14494: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
14495: LD_EXP 30
14499: PUSH
14500: LD_EXP 34
14504: AND
14505: PUSH
14506: LD_OWVAR 65
14510: PUSH
14511: LD_INT 7
14513: LESS
14514: AND
14515: IFFALSE 14529
14517: GO 14519
14519: DISABLE
// begin enable ;
14520: ENABLE
// game_speed := 7 ;
14521: LD_ADDR_OWVAR 65
14525: PUSH
14526: LD_INT 7
14528: ST_TO_ADDR
// end ;
14529: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
14530: LD_EXP 30
14534: PUSH
14535: LD_EXP 37
14539: AND
14540: IFFALSE 14742
14542: GO 14544
14544: DISABLE
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
14550: LD_ADDR_VAR 0 3
14554: PUSH
14555: LD_INT 81
14557: PUSH
14558: LD_OWVAR 2
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 21
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 69
14585: ST_TO_ADDR
// if not tmp then
14586: LD_VAR 0 3
14590: NOT
14591: IFFALSE 14595
// exit ;
14593: GO 14742
// if tmp > 5 then
14595: LD_VAR 0 3
14599: PUSH
14600: LD_INT 5
14602: GREATER
14603: IFFALSE 14615
// k := 5 else
14605: LD_ADDR_VAR 0 2
14609: PUSH
14610: LD_INT 5
14612: ST_TO_ADDR
14613: GO 14625
// k := tmp ;
14615: LD_ADDR_VAR 0 2
14619: PUSH
14620: LD_VAR 0 3
14624: ST_TO_ADDR
// for i := 1 to k do
14625: LD_ADDR_VAR 0 1
14629: PUSH
14630: DOUBLE
14631: LD_INT 1
14633: DEC
14634: ST_TO_ADDR
14635: LD_VAR 0 2
14639: PUSH
14640: FOR_TO
14641: IFFALSE 14740
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
14643: LD_VAR 0 3
14647: PUSH
14648: LD_VAR 0 1
14652: ARRAY
14653: PPUSH
14654: LD_VAR 0 1
14658: PUSH
14659: LD_INT 4
14661: MOD
14662: PUSH
14663: LD_INT 1
14665: PLUS
14666: PPUSH
14667: CALL_OW 259
14671: PUSH
14672: LD_INT 10
14674: LESS
14675: IFFALSE 14738
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
14677: LD_VAR 0 3
14681: PUSH
14682: LD_VAR 0 1
14686: ARRAY
14687: PPUSH
14688: LD_VAR 0 1
14692: PUSH
14693: LD_INT 4
14695: MOD
14696: PUSH
14697: LD_INT 1
14699: PLUS
14700: PPUSH
14701: LD_VAR 0 3
14705: PUSH
14706: LD_VAR 0 1
14710: ARRAY
14711: PPUSH
14712: LD_VAR 0 1
14716: PUSH
14717: LD_INT 4
14719: MOD
14720: PUSH
14721: LD_INT 1
14723: PLUS
14724: PPUSH
14725: CALL_OW 259
14729: PUSH
14730: LD_INT 1
14732: PLUS
14733: PPUSH
14734: CALL_OW 237
14738: GO 14640
14740: POP
14741: POP
// end ;
14742: PPOPN 3
14744: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
14745: LD_EXP 30
14749: PUSH
14750: LD_EXP 38
14754: AND
14755: IFFALSE 14775
14757: GO 14759
14759: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
14760: LD_INT 4
14762: PPUSH
14763: LD_OWVAR 2
14767: PPUSH
14768: LD_INT 0
14770: PPUSH
14771: CALL_OW 324
14775: END
// every 0 0$1 trigger StreamModeActive and sShovel do
14776: LD_EXP 30
14780: PUSH
14781: LD_EXP 67
14785: AND
14786: IFFALSE 14806
14788: GO 14790
14790: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
14791: LD_INT 19
14793: PPUSH
14794: LD_OWVAR 2
14798: PPUSH
14799: LD_INT 0
14801: PPUSH
14802: CALL_OW 324
14806: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
14807: LD_EXP 30
14811: PUSH
14812: LD_EXP 39
14816: AND
14817: IFFALSE 14919
14819: GO 14821
14821: DISABLE
14822: LD_INT 0
14824: PPUSH
14825: PPUSH
// begin enable ;
14826: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
14827: LD_ADDR_VAR 0 2
14831: PUSH
14832: LD_INT 22
14834: PUSH
14835: LD_OWVAR 2
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 2
14846: PUSH
14847: LD_INT 34
14849: PUSH
14850: LD_INT 11
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: LD_INT 34
14859: PUSH
14860: LD_INT 30
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: LIST
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 69
14880: ST_TO_ADDR
// if not tmp then
14881: LD_VAR 0 2
14885: NOT
14886: IFFALSE 14890
// exit ;
14888: GO 14919
// for i in tmp do
14890: LD_ADDR_VAR 0 1
14894: PUSH
14895: LD_VAR 0 2
14899: PUSH
14900: FOR_IN
14901: IFFALSE 14917
// begin SetLives ( i , 0 ) ;
14903: LD_VAR 0 1
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 234
// end ;
14915: GO 14900
14917: POP
14918: POP
// end ;
14919: PPOPN 2
14921: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14922: LD_EXP 30
14926: PUSH
14927: LD_EXP 40
14931: AND
14932: IFFALSE 14952
14934: GO 14936
14936: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14937: LD_INT 32
14939: PPUSH
14940: LD_OWVAR 2
14944: PPUSH
14945: LD_INT 0
14947: PPUSH
14948: CALL_OW 324
14952: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14953: LD_EXP 30
14957: PUSH
14958: LD_EXP 41
14962: AND
14963: IFFALSE 15144
14965: GO 14967
14967: DISABLE
14968: LD_INT 0
14970: PPUSH
14971: PPUSH
14972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
14973: LD_ADDR_VAR 0 2
14977: PUSH
14978: LD_INT 22
14980: PUSH
14981: LD_OWVAR 2
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: PUSH
14990: LD_INT 33
14992: PUSH
14993: LD_INT 3
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: PUSH
15000: EMPTY
15001: LIST
15002: LIST
15003: PPUSH
15004: CALL_OW 69
15008: ST_TO_ADDR
// if not tmp then
15009: LD_VAR 0 2
15013: NOT
15014: IFFALSE 15018
// exit ;
15016: GO 15144
// side := 0 ;
15018: LD_ADDR_VAR 0 3
15022: PUSH
15023: LD_INT 0
15025: ST_TO_ADDR
// for i := 1 to 8 do
15026: LD_ADDR_VAR 0 1
15030: PUSH
15031: DOUBLE
15032: LD_INT 1
15034: DEC
15035: ST_TO_ADDR
15036: LD_INT 8
15038: PUSH
15039: FOR_TO
15040: IFFALSE 15088
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
15042: LD_OWVAR 2
15046: PUSH
15047: LD_VAR 0 1
15051: NONEQUAL
15052: PUSH
15053: LD_OWVAR 2
15057: PPUSH
15058: LD_VAR 0 1
15062: PPUSH
15063: CALL_OW 81
15067: PUSH
15068: LD_INT 2
15070: EQUAL
15071: AND
15072: IFFALSE 15086
// begin side := i ;
15074: LD_ADDR_VAR 0 3
15078: PUSH
15079: LD_VAR 0 1
15083: ST_TO_ADDR
// break ;
15084: GO 15088
// end ;
15086: GO 15039
15088: POP
15089: POP
// if not side then
15090: LD_VAR 0 3
15094: NOT
15095: IFFALSE 15099
// exit ;
15097: GO 15144
// for i := 1 to tmp do
15099: LD_ADDR_VAR 0 1
15103: PUSH
15104: DOUBLE
15105: LD_INT 1
15107: DEC
15108: ST_TO_ADDR
15109: LD_VAR 0 2
15113: PUSH
15114: FOR_TO
15115: IFFALSE 15142
// if Prob ( 60 ) then
15117: LD_INT 60
15119: PPUSH
15120: CALL_OW 13
15124: IFFALSE 15140
// SetSide ( i , side ) ;
15126: LD_VAR 0 1
15130: PPUSH
15131: LD_VAR 0 3
15135: PPUSH
15136: CALL_OW 235
15140: GO 15114
15142: POP
15143: POP
// end ;
15144: PPOPN 3
15146: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
15147: LD_EXP 30
15151: PUSH
15152: LD_EXP 43
15156: AND
15157: IFFALSE 15276
15159: GO 15161
15161: DISABLE
15162: LD_INT 0
15164: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
15165: LD_ADDR_VAR 0 1
15169: PUSH
15170: LD_INT 22
15172: PUSH
15173: LD_OWVAR 2
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 21
15184: PUSH
15185: LD_INT 1
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 3
15194: PUSH
15195: LD_INT 23
15197: PUSH
15198: LD_INT 0
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PUSH
15209: EMPTY
15210: LIST
15211: LIST
15212: LIST
15213: PPUSH
15214: CALL_OW 69
15218: PUSH
15219: FOR_IN
15220: IFFALSE 15274
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
15222: LD_VAR 0 1
15226: PPUSH
15227: CALL_OW 257
15231: PUSH
15232: LD_INT 1
15234: PUSH
15235: LD_INT 2
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: LD_INT 4
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: IN
15250: IFFALSE 15272
// SetClass ( un , rand ( 1 , 4 ) ) ;
15252: LD_VAR 0 1
15256: PPUSH
15257: LD_INT 1
15259: PPUSH
15260: LD_INT 4
15262: PPUSH
15263: CALL_OW 12
15267: PPUSH
15268: CALL_OW 336
15272: GO 15219
15274: POP
15275: POP
// end ;
15276: PPOPN 1
15278: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
15279: LD_EXP 30
15283: PUSH
15284: LD_EXP 42
15288: AND
15289: IFFALSE 15368
15291: GO 15293
15293: DISABLE
15294: LD_INT 0
15296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15297: LD_ADDR_VAR 0 1
15301: PUSH
15302: LD_INT 22
15304: PUSH
15305: LD_OWVAR 2
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 21
15316: PUSH
15317: LD_INT 3
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PPUSH
15328: CALL_OW 69
15332: ST_TO_ADDR
// if not tmp then
15333: LD_VAR 0 1
15337: NOT
15338: IFFALSE 15342
// exit ;
15340: GO 15368
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
15342: LD_VAR 0 1
15346: PUSH
15347: LD_INT 1
15349: PPUSH
15350: LD_VAR 0 1
15354: PPUSH
15355: CALL_OW 12
15359: ARRAY
15360: PPUSH
15361: LD_INT 100
15363: PPUSH
15364: CALL_OW 234
// end ;
15368: PPOPN 1
15370: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
15371: LD_EXP 30
15375: PUSH
15376: LD_EXP 44
15380: AND
15381: IFFALSE 15479
15383: GO 15385
15385: DISABLE
15386: LD_INT 0
15388: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15389: LD_ADDR_VAR 0 1
15393: PUSH
15394: LD_INT 22
15396: PUSH
15397: LD_OWVAR 2
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PUSH
15406: LD_INT 21
15408: PUSH
15409: LD_INT 1
15411: PUSH
15412: EMPTY
15413: LIST
15414: LIST
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PPUSH
15420: CALL_OW 69
15424: ST_TO_ADDR
// if not tmp then
15425: LD_VAR 0 1
15429: NOT
15430: IFFALSE 15434
// exit ;
15432: GO 15479
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
15434: LD_VAR 0 1
15438: PUSH
15439: LD_INT 1
15441: PPUSH
15442: LD_VAR 0 1
15446: PPUSH
15447: CALL_OW 12
15451: ARRAY
15452: PPUSH
15453: LD_INT 1
15455: PPUSH
15456: LD_INT 4
15458: PPUSH
15459: CALL_OW 12
15463: PPUSH
15464: LD_INT 3000
15466: PPUSH
15467: LD_INT 9000
15469: PPUSH
15470: CALL_OW 12
15474: PPUSH
15475: CALL_OW 492
// end ;
15479: PPOPN 1
15481: END
// every 0 0$1 trigger StreamModeActive and sDepot do
15482: LD_EXP 30
15486: PUSH
15487: LD_EXP 45
15491: AND
15492: IFFALSE 15512
15494: GO 15496
15496: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
15497: LD_INT 1
15499: PPUSH
15500: LD_OWVAR 2
15504: PPUSH
15505: LD_INT 0
15507: PPUSH
15508: CALL_OW 324
15512: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
15513: LD_EXP 30
15517: PUSH
15518: LD_EXP 46
15522: AND
15523: IFFALSE 15606
15525: GO 15527
15527: DISABLE
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 22
15539: PUSH
15540: LD_OWVAR 2
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PUSH
15549: LD_INT 21
15551: PUSH
15552: LD_INT 3
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: EMPTY
15560: LIST
15561: LIST
15562: PPUSH
15563: CALL_OW 69
15567: ST_TO_ADDR
// if not tmp then
15568: LD_VAR 0 2
15572: NOT
15573: IFFALSE 15577
// exit ;
15575: GO 15606
// for i in tmp do
15577: LD_ADDR_VAR 0 1
15581: PUSH
15582: LD_VAR 0 2
15586: PUSH
15587: FOR_IN
15588: IFFALSE 15604
// SetBLevel ( i , 10 ) ;
15590: LD_VAR 0 1
15594: PPUSH
15595: LD_INT 10
15597: PPUSH
15598: CALL_OW 241
15602: GO 15587
15604: POP
15605: POP
// end ;
15606: PPOPN 2
15608: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
15609: LD_EXP 30
15613: PUSH
15614: LD_EXP 47
15618: AND
15619: IFFALSE 15730
15621: GO 15623
15623: DISABLE
15624: LD_INT 0
15626: PPUSH
15627: PPUSH
15628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15629: LD_ADDR_VAR 0 3
15633: PUSH
15634: LD_INT 22
15636: PUSH
15637: LD_OWVAR 2
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: PUSH
15646: LD_INT 25
15648: PUSH
15649: LD_INT 1
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: PPUSH
15660: CALL_OW 69
15664: ST_TO_ADDR
// if not tmp then
15665: LD_VAR 0 3
15669: NOT
15670: IFFALSE 15674
// exit ;
15672: GO 15730
// un := tmp [ rand ( 1 , tmp ) ] ;
15674: LD_ADDR_VAR 0 2
15678: PUSH
15679: LD_VAR 0 3
15683: PUSH
15684: LD_INT 1
15686: PPUSH
15687: LD_VAR 0 3
15691: PPUSH
15692: CALL_OW 12
15696: ARRAY
15697: ST_TO_ADDR
// if Crawls ( un ) then
15698: LD_VAR 0 2
15702: PPUSH
15703: CALL_OW 318
15707: IFFALSE 15718
// ComWalk ( un ) ;
15709: LD_VAR 0 2
15713: PPUSH
15714: CALL_OW 138
// SetClass ( un , class_sniper ) ;
15718: LD_VAR 0 2
15722: PPUSH
15723: LD_INT 5
15725: PPUSH
15726: CALL_OW 336
// end ;
15730: PPOPN 3
15732: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
15733: LD_EXP 30
15737: PUSH
15738: LD_EXP 48
15742: AND
15743: PUSH
15744: LD_OWVAR 67
15748: PUSH
15749: LD_INT 3
15751: LESS
15752: AND
15753: IFFALSE 15772
15755: GO 15757
15757: DISABLE
// Difficulty := Difficulty + 1 ;
15758: LD_ADDR_OWVAR 67
15762: PUSH
15763: LD_OWVAR 67
15767: PUSH
15768: LD_INT 1
15770: PLUS
15771: ST_TO_ADDR
15772: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
15773: LD_EXP 30
15777: PUSH
15778: LD_EXP 49
15782: AND
15783: IFFALSE 15886
15785: GO 15787
15787: DISABLE
15788: LD_INT 0
15790: PPUSH
// begin for i := 1 to 5 do
15791: LD_ADDR_VAR 0 1
15795: PUSH
15796: DOUBLE
15797: LD_INT 1
15799: DEC
15800: ST_TO_ADDR
15801: LD_INT 5
15803: PUSH
15804: FOR_TO
15805: IFFALSE 15884
// begin uc_nation := nation_nature ;
15807: LD_ADDR_OWVAR 21
15811: PUSH
15812: LD_INT 0
15814: ST_TO_ADDR
// uc_side := 0 ;
15815: LD_ADDR_OWVAR 20
15819: PUSH
15820: LD_INT 0
15822: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15823: LD_ADDR_OWVAR 29
15827: PUSH
15828: LD_INT 12
15830: PUSH
15831: LD_INT 12
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: ST_TO_ADDR
// hc_agressivity := 20 ;
15838: LD_ADDR_OWVAR 35
15842: PUSH
15843: LD_INT 20
15845: ST_TO_ADDR
// hc_class := class_tiger ;
15846: LD_ADDR_OWVAR 28
15850: PUSH
15851: LD_INT 14
15853: ST_TO_ADDR
// hc_gallery :=  ;
15854: LD_ADDR_OWVAR 33
15858: PUSH
15859: LD_STRING 
15861: ST_TO_ADDR
// hc_name :=  ;
15862: LD_ADDR_OWVAR 26
15866: PUSH
15867: LD_STRING 
15869: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15870: CALL_OW 44
15874: PPUSH
15875: LD_INT 0
15877: PPUSH
15878: CALL_OW 51
// end ;
15882: GO 15804
15884: POP
15885: POP
// end ;
15886: PPOPN 1
15888: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15889: LD_EXP 30
15893: PUSH
15894: LD_EXP 50
15898: AND
15899: IFFALSE 15908
15901: GO 15903
15903: DISABLE
// StreamSibBomb ;
15904: CALL 15909 0 0
15908: END
// export function StreamSibBomb ; var i , x , y ; begin
15909: LD_INT 0
15911: PPUSH
15912: PPUSH
15913: PPUSH
15914: PPUSH
// result := false ;
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_INT 0
15922: ST_TO_ADDR
// for i := 1 to 16 do
15923: LD_ADDR_VAR 0 2
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 16
15935: PUSH
15936: FOR_TO
15937: IFFALSE 16136
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15939: LD_ADDR_VAR 0 3
15943: PUSH
15944: LD_INT 10
15946: PUSH
15947: LD_INT 20
15949: PUSH
15950: LD_INT 30
15952: PUSH
15953: LD_INT 40
15955: PUSH
15956: LD_INT 50
15958: PUSH
15959: LD_INT 60
15961: PUSH
15962: LD_INT 70
15964: PUSH
15965: LD_INT 80
15967: PUSH
15968: LD_INT 90
15970: PUSH
15971: LD_INT 100
15973: PUSH
15974: LD_INT 110
15976: PUSH
15977: LD_INT 120
15979: PUSH
15980: LD_INT 130
15982: PUSH
15983: LD_INT 140
15985: PUSH
15986: LD_INT 150
15988: PUSH
15989: EMPTY
15990: LIST
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: LIST
16004: LIST
16005: PUSH
16006: LD_INT 1
16008: PPUSH
16009: LD_INT 15
16011: PPUSH
16012: CALL_OW 12
16016: ARRAY
16017: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_INT 10
16025: PUSH
16026: LD_INT 20
16028: PUSH
16029: LD_INT 30
16031: PUSH
16032: LD_INT 40
16034: PUSH
16035: LD_INT 50
16037: PUSH
16038: LD_INT 60
16040: PUSH
16041: LD_INT 70
16043: PUSH
16044: LD_INT 80
16046: PUSH
16047: LD_INT 90
16049: PUSH
16050: LD_INT 100
16052: PUSH
16053: LD_INT 110
16055: PUSH
16056: LD_INT 120
16058: PUSH
16059: LD_INT 130
16061: PUSH
16062: LD_INT 140
16064: PUSH
16065: LD_INT 150
16067: PUSH
16068: EMPTY
16069: LIST
16070: LIST
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: LIST
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: LIST
16081: LIST
16082: LIST
16083: LIST
16084: PUSH
16085: LD_INT 1
16087: PPUSH
16088: LD_INT 15
16090: PPUSH
16091: CALL_OW 12
16095: ARRAY
16096: ST_TO_ADDR
// if ValidHex ( x , y ) then
16097: LD_VAR 0 3
16101: PPUSH
16102: LD_VAR 0 4
16106: PPUSH
16107: CALL_OW 488
16111: IFFALSE 16134
// begin result := [ x , y ] ;
16113: LD_ADDR_VAR 0 1
16117: PUSH
16118: LD_VAR 0 3
16122: PUSH
16123: LD_VAR 0 4
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: ST_TO_ADDR
// break ;
16132: GO 16136
// end ; end ;
16134: GO 15936
16136: POP
16137: POP
// if result then
16138: LD_VAR 0 1
16142: IFFALSE 16202
// begin ToLua ( playSibBomb() ) ;
16144: LD_STRING playSibBomb()
16146: PPUSH
16147: CALL_OW 559
// wait ( 0 0$14 ) ;
16151: LD_INT 490
16153: PPUSH
16154: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
16158: LD_VAR 0 1
16162: PUSH
16163: LD_INT 1
16165: ARRAY
16166: PPUSH
16167: LD_VAR 0 1
16171: PUSH
16172: LD_INT 2
16174: ARRAY
16175: PPUSH
16176: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
16180: LD_VAR 0 1
16184: PUSH
16185: LD_INT 1
16187: ARRAY
16188: PPUSH
16189: LD_VAR 0 1
16193: PUSH
16194: LD_INT 2
16196: ARRAY
16197: PPUSH
16198: CALL_OW 429
// end ; end ;
16202: LD_VAR 0 1
16206: RET
// every 0 0$1 trigger StreamModeActive and sReset do
16207: LD_EXP 30
16211: PUSH
16212: LD_EXP 52
16216: AND
16217: IFFALSE 16229
16219: GO 16221
16221: DISABLE
// YouLost (  ) ;
16222: LD_STRING 
16224: PPUSH
16225: CALL_OW 104
16229: END
// every 0 0$1 trigger StreamModeActive and sFog do
16230: LD_EXP 30
16234: PUSH
16235: LD_EXP 51
16239: AND
16240: IFFALSE 16254
16242: GO 16244
16244: DISABLE
// FogOff ( your_side ) ;
16245: LD_OWVAR 2
16249: PPUSH
16250: CALL_OW 344
16254: END
// every 0 0$1 trigger StreamModeActive and sSun do
16255: LD_EXP 30
16259: PUSH
16260: LD_EXP 53
16264: AND
16265: IFFALSE 16293
16267: GO 16269
16269: DISABLE
// begin solar_recharge_percent := 0 ;
16270: LD_ADDR_OWVAR 79
16274: PUSH
16275: LD_INT 0
16277: ST_TO_ADDR
// wait ( 5 5$00 ) ;
16278: LD_INT 10500
16280: PPUSH
16281: CALL_OW 67
// solar_recharge_percent := 100 ;
16285: LD_ADDR_OWVAR 79
16289: PUSH
16290: LD_INT 100
16292: ST_TO_ADDR
// end ;
16293: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
16294: LD_EXP 30
16298: PUSH
16299: LD_EXP 54
16303: AND
16304: IFFALSE 16543
16306: GO 16308
16308: DISABLE
16309: LD_INT 0
16311: PPUSH
16312: PPUSH
16313: PPUSH
// begin tmp := [ ] ;
16314: LD_ADDR_VAR 0 3
16318: PUSH
16319: EMPTY
16320: ST_TO_ADDR
// for i := 1 to 6 do
16321: LD_ADDR_VAR 0 1
16325: PUSH
16326: DOUBLE
16327: LD_INT 1
16329: DEC
16330: ST_TO_ADDR
16331: LD_INT 6
16333: PUSH
16334: FOR_TO
16335: IFFALSE 16440
// begin uc_nation := nation_nature ;
16337: LD_ADDR_OWVAR 21
16341: PUSH
16342: LD_INT 0
16344: ST_TO_ADDR
// uc_side := 0 ;
16345: LD_ADDR_OWVAR 20
16349: PUSH
16350: LD_INT 0
16352: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16353: LD_ADDR_OWVAR 29
16357: PUSH
16358: LD_INT 12
16360: PUSH
16361: LD_INT 12
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: ST_TO_ADDR
// hc_agressivity := 20 ;
16368: LD_ADDR_OWVAR 35
16372: PUSH
16373: LD_INT 20
16375: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
16376: LD_ADDR_OWVAR 28
16380: PUSH
16381: LD_INT 17
16383: ST_TO_ADDR
// hc_gallery :=  ;
16384: LD_ADDR_OWVAR 33
16388: PUSH
16389: LD_STRING 
16391: ST_TO_ADDR
// hc_name :=  ;
16392: LD_ADDR_OWVAR 26
16396: PUSH
16397: LD_STRING 
16399: ST_TO_ADDR
// un := CreateHuman ;
16400: LD_ADDR_VAR 0 2
16404: PUSH
16405: CALL_OW 44
16409: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
16410: LD_VAR 0 2
16414: PPUSH
16415: LD_INT 1
16417: PPUSH
16418: CALL_OW 51
// tmp := tmp ^ un ;
16422: LD_ADDR_VAR 0 3
16426: PUSH
16427: LD_VAR 0 3
16431: PUSH
16432: LD_VAR 0 2
16436: ADD
16437: ST_TO_ADDR
// end ;
16438: GO 16334
16440: POP
16441: POP
// repeat wait ( 0 0$1 ) ;
16442: LD_INT 35
16444: PPUSH
16445: CALL_OW 67
// for un in tmp do
16449: LD_ADDR_VAR 0 2
16453: PUSH
16454: LD_VAR 0 3
16458: PUSH
16459: FOR_IN
16460: IFFALSE 16534
// begin if IsDead ( un ) then
16462: LD_VAR 0 2
16466: PPUSH
16467: CALL_OW 301
16471: IFFALSE 16491
// begin tmp := tmp diff un ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: LD_VAR 0 3
16482: PUSH
16483: LD_VAR 0 2
16487: DIFF
16488: ST_TO_ADDR
// continue ;
16489: GO 16459
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
16491: LD_VAR 0 2
16495: PPUSH
16496: LD_INT 3
16498: PUSH
16499: LD_INT 22
16501: PUSH
16502: LD_INT 0
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PPUSH
16513: CALL_OW 69
16517: PPUSH
16518: LD_VAR 0 2
16522: PPUSH
16523: CALL_OW 74
16527: PPUSH
16528: CALL_OW 115
// end ;
16532: GO 16459
16534: POP
16535: POP
// until not tmp ;
16536: LD_VAR 0 3
16540: NOT
16541: IFFALSE 16442
// end ;
16543: PPOPN 3
16545: END
// every 0 0$1 trigger StreamModeActive and sTroll do
16546: LD_EXP 30
16550: PUSH
16551: LD_EXP 55
16555: AND
16556: IFFALSE 16610
16558: GO 16560
16560: DISABLE
// begin ToLua ( displayTroll(); ) ;
16561: LD_STRING displayTroll();
16563: PPUSH
16564: CALL_OW 559
// wait ( 3 3$00 ) ;
16568: LD_INT 6300
16570: PPUSH
16571: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16575: LD_STRING hideTroll();
16577: PPUSH
16578: CALL_OW 559
// wait ( 1 1$00 ) ;
16582: LD_INT 2100
16584: PPUSH
16585: CALL_OW 67
// ToLua ( displayTroll(); ) ;
16589: LD_STRING displayTroll();
16591: PPUSH
16592: CALL_OW 559
// wait ( 1 1$00 ) ;
16596: LD_INT 2100
16598: PPUSH
16599: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16603: LD_STRING hideTroll();
16605: PPUSH
16606: CALL_OW 559
// end ;
16610: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
16611: LD_EXP 30
16615: PUSH
16616: LD_EXP 56
16620: AND
16621: IFFALSE 16684
16623: GO 16625
16625: DISABLE
16626: LD_INT 0
16628: PPUSH
// begin p := 0 ;
16629: LD_ADDR_VAR 0 1
16633: PUSH
16634: LD_INT 0
16636: ST_TO_ADDR
// repeat game_speed := 1 ;
16637: LD_ADDR_OWVAR 65
16641: PUSH
16642: LD_INT 1
16644: ST_TO_ADDR
// wait ( 0 0$1 ) ;
16645: LD_INT 35
16647: PPUSH
16648: CALL_OW 67
// p := p + 1 ;
16652: LD_ADDR_VAR 0 1
16656: PUSH
16657: LD_VAR 0 1
16661: PUSH
16662: LD_INT 1
16664: PLUS
16665: ST_TO_ADDR
// until p >= 60 ;
16666: LD_VAR 0 1
16670: PUSH
16671: LD_INT 60
16673: GREATEREQUAL
16674: IFFALSE 16637
// game_speed := 4 ;
16676: LD_ADDR_OWVAR 65
16680: PUSH
16681: LD_INT 4
16683: ST_TO_ADDR
// end ;
16684: PPOPN 1
16686: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
16687: LD_EXP 30
16691: PUSH
16692: LD_EXP 57
16696: AND
16697: IFFALSE 16843
16699: GO 16701
16701: DISABLE
16702: LD_INT 0
16704: PPUSH
16705: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16706: LD_ADDR_VAR 0 1
16710: PUSH
16711: LD_INT 22
16713: PUSH
16714: LD_OWVAR 2
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 0
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 30
16738: PUSH
16739: LD_INT 1
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: LIST
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: PPUSH
16755: CALL_OW 69
16759: ST_TO_ADDR
// if not depot then
16760: LD_VAR 0 1
16764: NOT
16765: IFFALSE 16769
// exit ;
16767: GO 16843
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
16769: LD_ADDR_VAR 0 2
16773: PUSH
16774: LD_VAR 0 1
16778: PUSH
16779: LD_INT 1
16781: PPUSH
16782: LD_VAR 0 1
16786: PPUSH
16787: CALL_OW 12
16791: ARRAY
16792: PPUSH
16793: CALL_OW 274
16797: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
16798: LD_VAR 0 2
16802: PPUSH
16803: LD_INT 1
16805: PPUSH
16806: LD_INT 0
16808: PPUSH
16809: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
16813: LD_VAR 0 2
16817: PPUSH
16818: LD_INT 2
16820: PPUSH
16821: LD_INT 0
16823: PPUSH
16824: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
16828: LD_VAR 0 2
16832: PPUSH
16833: LD_INT 3
16835: PPUSH
16836: LD_INT 0
16838: PPUSH
16839: CALL_OW 277
// end ;
16843: PPOPN 2
16845: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16846: LD_EXP 30
16850: PUSH
16851: LD_EXP 58
16855: AND
16856: IFFALSE 16953
16858: GO 16860
16860: DISABLE
16861: LD_INT 0
16863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16864: LD_ADDR_VAR 0 1
16868: PUSH
16869: LD_INT 22
16871: PUSH
16872: LD_OWVAR 2
16876: PUSH
16877: EMPTY
16878: LIST
16879: LIST
16880: PUSH
16881: LD_INT 21
16883: PUSH
16884: LD_INT 1
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: PUSH
16891: LD_INT 3
16893: PUSH
16894: LD_INT 23
16896: PUSH
16897: LD_INT 0
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: LIST
16912: PPUSH
16913: CALL_OW 69
16917: ST_TO_ADDR
// if not tmp then
16918: LD_VAR 0 1
16922: NOT
16923: IFFALSE 16927
// exit ;
16925: GO 16953
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16927: LD_VAR 0 1
16931: PUSH
16932: LD_INT 1
16934: PPUSH
16935: LD_VAR 0 1
16939: PPUSH
16940: CALL_OW 12
16944: ARRAY
16945: PPUSH
16946: LD_INT 200
16948: PPUSH
16949: CALL_OW 234
// end ;
16953: PPOPN 1
16955: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
16956: LD_EXP 30
16960: PUSH
16961: LD_EXP 59
16965: AND
16966: IFFALSE 17045
16968: GO 16970
16970: DISABLE
16971: LD_INT 0
16973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
16974: LD_ADDR_VAR 0 1
16978: PUSH
16979: LD_INT 22
16981: PUSH
16982: LD_OWVAR 2
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: PUSH
16991: LD_INT 21
16993: PUSH
16994: LD_INT 2
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PPUSH
17005: CALL_OW 69
17009: ST_TO_ADDR
// if not tmp then
17010: LD_VAR 0 1
17014: NOT
17015: IFFALSE 17019
// exit ;
17017: GO 17045
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
17019: LD_VAR 0 1
17023: PUSH
17024: LD_INT 1
17026: PPUSH
17027: LD_VAR 0 1
17031: PPUSH
17032: CALL_OW 12
17036: ARRAY
17037: PPUSH
17038: LD_INT 60
17040: PPUSH
17041: CALL_OW 234
// end ;
17045: PPOPN 1
17047: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
17048: LD_EXP 30
17052: PUSH
17053: LD_EXP 60
17057: AND
17058: IFFALSE 17157
17060: GO 17062
17062: DISABLE
17063: LD_INT 0
17065: PPUSH
17066: PPUSH
// begin enable ;
17067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
17068: LD_ADDR_VAR 0 1
17072: PUSH
17073: LD_INT 22
17075: PUSH
17076: LD_OWVAR 2
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: LD_INT 61
17087: PUSH
17088: EMPTY
17089: LIST
17090: PUSH
17091: LD_INT 33
17093: PUSH
17094: LD_INT 2
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: LIST
17105: PPUSH
17106: CALL_OW 69
17110: ST_TO_ADDR
// if not tmp then
17111: LD_VAR 0 1
17115: NOT
17116: IFFALSE 17120
// exit ;
17118: GO 17157
// for i in tmp do
17120: LD_ADDR_VAR 0 2
17124: PUSH
17125: LD_VAR 0 1
17129: PUSH
17130: FOR_IN
17131: IFFALSE 17155
// if IsControledBy ( i ) then
17133: LD_VAR 0 2
17137: PPUSH
17138: CALL_OW 312
17142: IFFALSE 17153
// ComUnlink ( i ) ;
17144: LD_VAR 0 2
17148: PPUSH
17149: CALL_OW 136
17153: GO 17130
17155: POP
17156: POP
// end ;
17157: PPOPN 2
17159: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
17160: LD_EXP 30
17164: PUSH
17165: LD_EXP 61
17169: AND
17170: IFFALSE 17310
17172: GO 17174
17174: DISABLE
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
// begin ToLua ( displayPowell(); ) ;
17179: LD_STRING displayPowell();
17181: PPUSH
17182: CALL_OW 559
// uc_side := 0 ;
17186: LD_ADDR_OWVAR 20
17190: PUSH
17191: LD_INT 0
17193: ST_TO_ADDR
// uc_nation := 2 ;
17194: LD_ADDR_OWVAR 21
17198: PUSH
17199: LD_INT 2
17201: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
17202: LD_ADDR_OWVAR 37
17206: PUSH
17207: LD_INT 14
17209: ST_TO_ADDR
// vc_engine := engine_siberite ;
17210: LD_ADDR_OWVAR 39
17214: PUSH
17215: LD_INT 3
17217: ST_TO_ADDR
// vc_control := control_apeman ;
17218: LD_ADDR_OWVAR 38
17222: PUSH
17223: LD_INT 5
17225: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
17226: LD_ADDR_OWVAR 40
17230: PUSH
17231: LD_INT 29
17233: ST_TO_ADDR
// un := CreateVehicle ;
17234: LD_ADDR_VAR 0 2
17238: PUSH
17239: CALL_OW 45
17243: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17244: LD_VAR 0 2
17248: PPUSH
17249: LD_INT 1
17251: PPUSH
17252: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17256: LD_INT 35
17258: PPUSH
17259: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17263: LD_VAR 0 2
17267: PPUSH
17268: LD_INT 22
17270: PUSH
17271: LD_OWVAR 2
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PPUSH
17280: CALL_OW 69
17284: PPUSH
17285: LD_VAR 0 2
17289: PPUSH
17290: CALL_OW 74
17294: PPUSH
17295: CALL_OW 115
// until IsDead ( un ) ;
17299: LD_VAR 0 2
17303: PPUSH
17304: CALL_OW 301
17308: IFFALSE 17256
// end ;
17310: PPOPN 2
17312: END
// every 0 0$1 trigger StreamModeActive and sStu do
17313: LD_EXP 30
17317: PUSH
17318: LD_EXP 69
17322: AND
17323: IFFALSE 17339
17325: GO 17327
17327: DISABLE
// begin ToLua ( displayStucuk(); ) ;
17328: LD_STRING displayStucuk();
17330: PPUSH
17331: CALL_OW 559
// ResetFog ;
17335: CALL_OW 335
// end ;
17339: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
17340: LD_EXP 30
17344: PUSH
17345: LD_EXP 62
17349: AND
17350: IFFALSE 17491
17352: GO 17354
17354: DISABLE
17355: LD_INT 0
17357: PPUSH
17358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17359: LD_ADDR_VAR 0 2
17363: PUSH
17364: LD_INT 22
17366: PUSH
17367: LD_OWVAR 2
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: PUSH
17376: LD_INT 21
17378: PUSH
17379: LD_INT 1
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: PUSH
17386: EMPTY
17387: LIST
17388: LIST
17389: PPUSH
17390: CALL_OW 69
17394: ST_TO_ADDR
// if not tmp then
17395: LD_VAR 0 2
17399: NOT
17400: IFFALSE 17404
// exit ;
17402: GO 17491
// un := tmp [ rand ( 1 , tmp ) ] ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_VAR 0 2
17413: PUSH
17414: LD_INT 1
17416: PPUSH
17417: LD_VAR 0 2
17421: PPUSH
17422: CALL_OW 12
17426: ARRAY
17427: ST_TO_ADDR
// SetSide ( un , 0 ) ;
17428: LD_VAR 0 1
17432: PPUSH
17433: LD_INT 0
17435: PPUSH
17436: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
17440: LD_VAR 0 1
17444: PPUSH
17445: LD_OWVAR 3
17449: PUSH
17450: LD_VAR 0 1
17454: DIFF
17455: PPUSH
17456: LD_VAR 0 1
17460: PPUSH
17461: CALL_OW 74
17465: PPUSH
17466: CALL_OW 115
// wait ( 0 0$20 ) ;
17470: LD_INT 700
17472: PPUSH
17473: CALL_OW 67
// SetSide ( un , your_side ) ;
17477: LD_VAR 0 1
17481: PPUSH
17482: LD_OWVAR 2
17486: PPUSH
17487: CALL_OW 235
// end ;
17491: PPOPN 2
17493: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
17494: LD_EXP 30
17498: PUSH
17499: LD_EXP 63
17503: AND
17504: IFFALSE 17610
17506: GO 17508
17508: DISABLE
17509: LD_INT 0
17511: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
17512: LD_ADDR_VAR 0 1
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_OWVAR 2
17524: PUSH
17525: EMPTY
17526: LIST
17527: LIST
17528: PUSH
17529: LD_INT 2
17531: PUSH
17532: LD_INT 30
17534: PUSH
17535: LD_INT 0
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: PUSH
17542: LD_INT 30
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: LIST
17556: PUSH
17557: EMPTY
17558: LIST
17559: LIST
17560: PPUSH
17561: CALL_OW 69
17565: ST_TO_ADDR
// if not depot then
17566: LD_VAR 0 1
17570: NOT
17571: IFFALSE 17575
// exit ;
17573: GO 17610
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
17575: LD_VAR 0 1
17579: PUSH
17580: LD_INT 1
17582: ARRAY
17583: PPUSH
17584: CALL_OW 250
17588: PPUSH
17589: LD_VAR 0 1
17593: PUSH
17594: LD_INT 1
17596: ARRAY
17597: PPUSH
17598: CALL_OW 251
17602: PPUSH
17603: LD_INT 70
17605: PPUSH
17606: CALL_OW 495
// end ;
17610: PPOPN 1
17612: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
17613: LD_EXP 30
17617: PUSH
17618: LD_EXP 64
17622: AND
17623: IFFALSE 17834
17625: GO 17627
17627: DISABLE
17628: LD_INT 0
17630: PPUSH
17631: PPUSH
17632: PPUSH
17633: PPUSH
17634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17635: LD_ADDR_VAR 0 5
17639: PUSH
17640: LD_INT 22
17642: PUSH
17643: LD_OWVAR 2
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PUSH
17652: LD_INT 21
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: PPUSH
17666: CALL_OW 69
17670: ST_TO_ADDR
// if not tmp then
17671: LD_VAR 0 5
17675: NOT
17676: IFFALSE 17680
// exit ;
17678: GO 17834
// for i in tmp do
17680: LD_ADDR_VAR 0 1
17684: PUSH
17685: LD_VAR 0 5
17689: PUSH
17690: FOR_IN
17691: IFFALSE 17832
// begin d := rand ( 0 , 5 ) ;
17693: LD_ADDR_VAR 0 4
17697: PUSH
17698: LD_INT 0
17700: PPUSH
17701: LD_INT 5
17703: PPUSH
17704: CALL_OW 12
17708: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
17709: LD_ADDR_VAR 0 2
17713: PUSH
17714: LD_VAR 0 1
17718: PPUSH
17719: CALL_OW 250
17723: PPUSH
17724: LD_VAR 0 4
17728: PPUSH
17729: LD_INT 3
17731: PPUSH
17732: LD_INT 12
17734: PPUSH
17735: CALL_OW 12
17739: PPUSH
17740: CALL_OW 272
17744: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_VAR 0 1
17754: PPUSH
17755: CALL_OW 251
17759: PPUSH
17760: LD_VAR 0 4
17764: PPUSH
17765: LD_INT 3
17767: PPUSH
17768: LD_INT 12
17770: PPUSH
17771: CALL_OW 12
17775: PPUSH
17776: CALL_OW 273
17780: ST_TO_ADDR
// if ValidHex ( x , y ) then
17781: LD_VAR 0 2
17785: PPUSH
17786: LD_VAR 0 3
17790: PPUSH
17791: CALL_OW 488
17795: IFFALSE 17830
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
17797: LD_VAR 0 1
17801: PPUSH
17802: LD_VAR 0 2
17806: PPUSH
17807: LD_VAR 0 3
17811: PPUSH
17812: LD_INT 3
17814: PPUSH
17815: LD_INT 6
17817: PPUSH
17818: CALL_OW 12
17822: PPUSH
17823: LD_INT 1
17825: PPUSH
17826: CALL_OW 483
// end ;
17830: GO 17690
17832: POP
17833: POP
// end ;
17834: PPOPN 5
17836: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17837: LD_EXP 30
17841: PUSH
17842: LD_EXP 65
17846: AND
17847: IFFALSE 17941
17849: GO 17851
17851: DISABLE
17852: LD_INT 0
17854: PPUSH
17855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17856: LD_ADDR_VAR 0 2
17860: PUSH
17861: LD_INT 22
17863: PUSH
17864: LD_OWVAR 2
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: PUSH
17873: LD_INT 32
17875: PUSH
17876: LD_INT 1
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PUSH
17883: LD_INT 21
17885: PUSH
17886: LD_INT 2
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: PPUSH
17898: CALL_OW 69
17902: ST_TO_ADDR
// if not tmp then
17903: LD_VAR 0 2
17907: NOT
17908: IFFALSE 17912
// exit ;
17910: GO 17941
// for i in tmp do
17912: LD_ADDR_VAR 0 1
17916: PUSH
17917: LD_VAR 0 2
17921: PUSH
17922: FOR_IN
17923: IFFALSE 17939
// SetFuel ( i , 0 ) ;
17925: LD_VAR 0 1
17929: PPUSH
17930: LD_INT 0
17932: PPUSH
17933: CALL_OW 240
17937: GO 17922
17939: POP
17940: POP
// end ;
17941: PPOPN 2
17943: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17944: LD_EXP 30
17948: PUSH
17949: LD_EXP 66
17953: AND
17954: IFFALSE 18020
17956: GO 17958
17958: DISABLE
17959: LD_INT 0
17961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17962: LD_ADDR_VAR 0 1
17966: PUSH
17967: LD_INT 22
17969: PUSH
17970: LD_OWVAR 2
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: PUSH
17979: LD_INT 30
17981: PUSH
17982: LD_INT 29
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PPUSH
17993: CALL_OW 69
17997: ST_TO_ADDR
// if not tmp then
17998: LD_VAR 0 1
18002: NOT
18003: IFFALSE 18007
// exit ;
18005: GO 18020
// DestroyUnit ( tmp [ 1 ] ) ;
18007: LD_VAR 0 1
18011: PUSH
18012: LD_INT 1
18014: ARRAY
18015: PPUSH
18016: CALL_OW 65
// end ;
18020: PPOPN 1
18022: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
18023: LD_EXP 30
18027: PUSH
18028: LD_EXP 68
18032: AND
18033: IFFALSE 18162
18035: GO 18037
18037: DISABLE
18038: LD_INT 0
18040: PPUSH
// begin uc_side := 0 ;
18041: LD_ADDR_OWVAR 20
18045: PUSH
18046: LD_INT 0
18048: ST_TO_ADDR
// uc_nation := nation_arabian ;
18049: LD_ADDR_OWVAR 21
18053: PUSH
18054: LD_INT 2
18056: ST_TO_ADDR
// hc_gallery :=  ;
18057: LD_ADDR_OWVAR 33
18061: PUSH
18062: LD_STRING 
18064: ST_TO_ADDR
// hc_name :=  ;
18065: LD_ADDR_OWVAR 26
18069: PUSH
18070: LD_STRING 
18072: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
18073: LD_INT 1
18075: PPUSH
18076: LD_INT 11
18078: PPUSH
18079: LD_INT 10
18081: PPUSH
18082: CALL_OW 380
// un := CreateHuman ;
18086: LD_ADDR_VAR 0 1
18090: PUSH
18091: CALL_OW 44
18095: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18096: LD_VAR 0 1
18100: PPUSH
18101: LD_INT 1
18103: PPUSH
18104: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18115: LD_VAR 0 1
18119: PPUSH
18120: LD_INT 22
18122: PUSH
18123: LD_OWVAR 2
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PPUSH
18132: CALL_OW 69
18136: PPUSH
18137: LD_VAR 0 1
18141: PPUSH
18142: CALL_OW 74
18146: PPUSH
18147: CALL_OW 115
// until IsDead ( un ) ;
18151: LD_VAR 0 1
18155: PPUSH
18156: CALL_OW 301
18160: IFFALSE 18108
// end ;
18162: PPOPN 1
18164: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
18165: LD_EXP 30
18169: PUSH
18170: LD_EXP 70
18174: AND
18175: IFFALSE 18187
18177: GO 18179
18179: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
18180: LD_STRING earthquake(getX(game), 0, 32)
18182: PPUSH
18183: CALL_OW 559
18187: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
18188: LD_EXP 30
18192: PUSH
18193: LD_EXP 71
18197: AND
18198: IFFALSE 18289
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin enable ;
18206: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
18207: LD_ADDR_VAR 0 1
18211: PUSH
18212: LD_INT 22
18214: PUSH
18215: LD_OWVAR 2
18219: PUSH
18220: EMPTY
18221: LIST
18222: LIST
18223: PUSH
18224: LD_INT 21
18226: PUSH
18227: LD_INT 2
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: PUSH
18234: LD_INT 33
18236: PUSH
18237: LD_INT 3
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: LIST
18248: PPUSH
18249: CALL_OW 69
18253: ST_TO_ADDR
// if not tmp then
18254: LD_VAR 0 1
18258: NOT
18259: IFFALSE 18263
// exit ;
18261: GO 18289
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18263: LD_VAR 0 1
18267: PUSH
18268: LD_INT 1
18270: PPUSH
18271: LD_VAR 0 1
18275: PPUSH
18276: CALL_OW 12
18280: ARRAY
18281: PPUSH
18282: LD_INT 1
18284: PPUSH
18285: CALL_OW 234
// end ;
18289: PPOPN 1
18291: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
18292: LD_EXP 30
18296: PUSH
18297: LD_EXP 72
18301: AND
18302: IFFALSE 18443
18304: GO 18306
18306: DISABLE
18307: LD_INT 0
18309: PPUSH
18310: PPUSH
18311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18312: LD_ADDR_VAR 0 3
18316: PUSH
18317: LD_INT 22
18319: PUSH
18320: LD_OWVAR 2
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 25
18331: PUSH
18332: LD_INT 1
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: PPUSH
18343: CALL_OW 69
18347: ST_TO_ADDR
// if not tmp then
18348: LD_VAR 0 3
18352: NOT
18353: IFFALSE 18357
// exit ;
18355: GO 18443
// un := tmp [ rand ( 1 , tmp ) ] ;
18357: LD_ADDR_VAR 0 2
18361: PUSH
18362: LD_VAR 0 3
18366: PUSH
18367: LD_INT 1
18369: PPUSH
18370: LD_VAR 0 3
18374: PPUSH
18375: CALL_OW 12
18379: ARRAY
18380: ST_TO_ADDR
// if Crawls ( un ) then
18381: LD_VAR 0 2
18385: PPUSH
18386: CALL_OW 318
18390: IFFALSE 18401
// ComWalk ( un ) ;
18392: LD_VAR 0 2
18396: PPUSH
18397: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
18401: LD_VAR 0 2
18405: PPUSH
18406: LD_INT 9
18408: PPUSH
18409: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
18413: LD_INT 28
18415: PPUSH
18416: LD_OWVAR 2
18420: PPUSH
18421: LD_INT 2
18423: PPUSH
18424: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
18428: LD_INT 29
18430: PPUSH
18431: LD_OWVAR 2
18435: PPUSH
18436: LD_INT 2
18438: PPUSH
18439: CALL_OW 322
// end ;
18443: PPOPN 3
18445: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
18446: LD_EXP 30
18450: PUSH
18451: LD_EXP 73
18455: AND
18456: IFFALSE 18567
18458: GO 18460
18460: DISABLE
18461: LD_INT 0
18463: PPUSH
18464: PPUSH
18465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18466: LD_ADDR_VAR 0 3
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_OWVAR 2
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: PUSH
18483: LD_INT 25
18485: PUSH
18486: LD_INT 1
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: PPUSH
18497: CALL_OW 69
18501: ST_TO_ADDR
// if not tmp then
18502: LD_VAR 0 3
18506: NOT
18507: IFFALSE 18511
// exit ;
18509: GO 18567
// un := tmp [ rand ( 1 , tmp ) ] ;
18511: LD_ADDR_VAR 0 2
18515: PUSH
18516: LD_VAR 0 3
18520: PUSH
18521: LD_INT 1
18523: PPUSH
18524: LD_VAR 0 3
18528: PPUSH
18529: CALL_OW 12
18533: ARRAY
18534: ST_TO_ADDR
// if Crawls ( un ) then
18535: LD_VAR 0 2
18539: PPUSH
18540: CALL_OW 318
18544: IFFALSE 18555
// ComWalk ( un ) ;
18546: LD_VAR 0 2
18550: PPUSH
18551: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18555: LD_VAR 0 2
18559: PPUSH
18560: LD_INT 8
18562: PPUSH
18563: CALL_OW 336
// end ;
18567: PPOPN 3
18569: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
18570: LD_EXP 30
18574: PUSH
18575: LD_EXP 74
18579: AND
18580: IFFALSE 18724
18582: GO 18584
18584: DISABLE
18585: LD_INT 0
18587: PPUSH
18588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
18589: LD_ADDR_VAR 0 2
18593: PUSH
18594: LD_INT 22
18596: PUSH
18597: LD_OWVAR 2
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: PUSH
18606: LD_INT 21
18608: PUSH
18609: LD_INT 2
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: PUSH
18616: LD_INT 2
18618: PUSH
18619: LD_INT 34
18621: PUSH
18622: LD_INT 12
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: PUSH
18629: LD_INT 34
18631: PUSH
18632: LD_INT 51
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: PUSH
18639: LD_INT 34
18641: PUSH
18642: LD_INT 32
18644: PUSH
18645: EMPTY
18646: LIST
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: LIST
18653: LIST
18654: PUSH
18655: EMPTY
18656: LIST
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: ST_TO_ADDR
// if not tmp then
18665: LD_VAR 0 2
18669: NOT
18670: IFFALSE 18674
// exit ;
18672: GO 18724
// for i in tmp do
18674: LD_ADDR_VAR 0 1
18678: PUSH
18679: LD_VAR 0 2
18683: PUSH
18684: FOR_IN
18685: IFFALSE 18722
// if GetCargo ( i , mat_artifact ) = 0 then
18687: LD_VAR 0 1
18691: PPUSH
18692: LD_INT 4
18694: PPUSH
18695: CALL_OW 289
18699: PUSH
18700: LD_INT 0
18702: EQUAL
18703: IFFALSE 18720
// SetCargo ( i , mat_siberit , 100 ) ;
18705: LD_VAR 0 1
18709: PPUSH
18710: LD_INT 3
18712: PPUSH
18713: LD_INT 100
18715: PPUSH
18716: CALL_OW 290
18720: GO 18684
18722: POP
18723: POP
// end ;
18724: PPOPN 2
18726: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
18727: LD_EXP 30
18731: PUSH
18732: LD_EXP 75
18736: AND
18737: IFFALSE 18890
18739: GO 18741
18741: DISABLE
18742: LD_INT 0
18744: PPUSH
18745: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
18746: LD_ADDR_VAR 0 2
18750: PUSH
18751: LD_INT 22
18753: PUSH
18754: LD_OWVAR 2
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: PPUSH
18763: CALL_OW 69
18767: ST_TO_ADDR
// if not tmp then
18768: LD_VAR 0 2
18772: NOT
18773: IFFALSE 18777
// exit ;
18775: GO 18890
// for i := 1 to 2 do
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: DOUBLE
18783: LD_INT 1
18785: DEC
18786: ST_TO_ADDR
18787: LD_INT 2
18789: PUSH
18790: FOR_TO
18791: IFFALSE 18888
// begin uc_side := your_side ;
18793: LD_ADDR_OWVAR 20
18797: PUSH
18798: LD_OWVAR 2
18802: ST_TO_ADDR
// uc_nation := nation_american ;
18803: LD_ADDR_OWVAR 21
18807: PUSH
18808: LD_INT 1
18810: ST_TO_ADDR
// vc_chassis := us_morphling ;
18811: LD_ADDR_OWVAR 37
18815: PUSH
18816: LD_INT 5
18818: ST_TO_ADDR
// vc_engine := engine_siberite ;
18819: LD_ADDR_OWVAR 39
18823: PUSH
18824: LD_INT 3
18826: ST_TO_ADDR
// vc_control := control_computer ;
18827: LD_ADDR_OWVAR 38
18831: PUSH
18832: LD_INT 3
18834: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18835: LD_ADDR_OWVAR 40
18839: PUSH
18840: LD_INT 10
18842: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18843: CALL_OW 45
18847: PPUSH
18848: LD_VAR 0 2
18852: PUSH
18853: LD_INT 1
18855: ARRAY
18856: PPUSH
18857: CALL_OW 250
18861: PPUSH
18862: LD_VAR 0 2
18866: PUSH
18867: LD_INT 1
18869: ARRAY
18870: PPUSH
18871: CALL_OW 251
18875: PPUSH
18876: LD_INT 12
18878: PPUSH
18879: LD_INT 1
18881: PPUSH
18882: CALL_OW 50
// end ;
18886: GO 18790
18888: POP
18889: POP
// end ;
18890: PPOPN 2
18892: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18893: LD_EXP 30
18897: PUSH
18898: LD_EXP 76
18902: AND
18903: IFFALSE 19125
18905: GO 18907
18907: DISABLE
18908: LD_INT 0
18910: PPUSH
18911: PPUSH
18912: PPUSH
18913: PPUSH
18914: PPUSH
18915: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18916: LD_ADDR_VAR 0 6
18920: PUSH
18921: LD_INT 22
18923: PUSH
18924: LD_OWVAR 2
18928: PUSH
18929: EMPTY
18930: LIST
18931: LIST
18932: PUSH
18933: LD_INT 21
18935: PUSH
18936: LD_INT 1
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: PUSH
18943: LD_INT 3
18945: PUSH
18946: LD_INT 23
18948: PUSH
18949: LD_INT 0
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PUSH
18960: EMPTY
18961: LIST
18962: LIST
18963: LIST
18964: PPUSH
18965: CALL_OW 69
18969: ST_TO_ADDR
// if not tmp then
18970: LD_VAR 0 6
18974: NOT
18975: IFFALSE 18979
// exit ;
18977: GO 19125
// s1 := rand ( 1 , 4 ) ;
18979: LD_ADDR_VAR 0 2
18983: PUSH
18984: LD_INT 1
18986: PPUSH
18987: LD_INT 4
18989: PPUSH
18990: CALL_OW 12
18994: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18995: LD_ADDR_VAR 0 4
18999: PUSH
19000: LD_VAR 0 6
19004: PUSH
19005: LD_INT 1
19007: ARRAY
19008: PPUSH
19009: LD_VAR 0 2
19013: PPUSH
19014: CALL_OW 259
19018: ST_TO_ADDR
// if s1 = 1 then
19019: LD_VAR 0 2
19023: PUSH
19024: LD_INT 1
19026: EQUAL
19027: IFFALSE 19047
// s2 := rand ( 2 , 4 ) else
19029: LD_ADDR_VAR 0 3
19033: PUSH
19034: LD_INT 2
19036: PPUSH
19037: LD_INT 4
19039: PPUSH
19040: CALL_OW 12
19044: ST_TO_ADDR
19045: GO 19055
// s2 := 1 ;
19047: LD_ADDR_VAR 0 3
19051: PUSH
19052: LD_INT 1
19054: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
19055: LD_ADDR_VAR 0 5
19059: PUSH
19060: LD_VAR 0 6
19064: PUSH
19065: LD_INT 1
19067: ARRAY
19068: PPUSH
19069: LD_VAR 0 3
19073: PPUSH
19074: CALL_OW 259
19078: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
19079: LD_VAR 0 6
19083: PUSH
19084: LD_INT 1
19086: ARRAY
19087: PPUSH
19088: LD_VAR 0 2
19092: PPUSH
19093: LD_VAR 0 5
19097: PPUSH
19098: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
19102: LD_VAR 0 6
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_VAR 0 3
19115: PPUSH
19116: LD_VAR 0 4
19120: PPUSH
19121: CALL_OW 237
// end ;
19125: PPOPN 6
19127: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
19128: LD_EXP 30
19132: PUSH
19133: LD_EXP 77
19137: AND
19138: IFFALSE 19217
19140: GO 19142
19142: DISABLE
19143: LD_INT 0
19145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
19146: LD_ADDR_VAR 0 1
19150: PUSH
19151: LD_INT 22
19153: PUSH
19154: LD_OWVAR 2
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: PUSH
19163: LD_INT 30
19165: PUSH
19166: LD_INT 3
19168: PUSH
19169: EMPTY
19170: LIST
19171: LIST
19172: PUSH
19173: EMPTY
19174: LIST
19175: LIST
19176: PPUSH
19177: CALL_OW 69
19181: ST_TO_ADDR
// if not tmp then
19182: LD_VAR 0 1
19186: NOT
19187: IFFALSE 19191
// exit ;
19189: GO 19217
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19191: LD_VAR 0 1
19195: PUSH
19196: LD_INT 1
19198: PPUSH
19199: LD_VAR 0 1
19203: PPUSH
19204: CALL_OW 12
19208: ARRAY
19209: PPUSH
19210: LD_INT 1
19212: PPUSH
19213: CALL_OW 234
// end ;
19217: PPOPN 1
19219: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
19220: LD_EXP 30
19224: PUSH
19225: LD_EXP 78
19229: AND
19230: IFFALSE 19342
19232: GO 19234
19234: DISABLE
19235: LD_INT 0
19237: PPUSH
19238: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
19239: LD_ADDR_VAR 0 2
19243: PUSH
19244: LD_INT 22
19246: PUSH
19247: LD_OWVAR 2
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: PUSH
19256: LD_INT 2
19258: PUSH
19259: LD_INT 30
19261: PUSH
19262: LD_INT 27
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: PUSH
19269: LD_INT 30
19271: PUSH
19272: LD_INT 26
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 30
19281: PUSH
19282: LD_INT 28
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: EMPTY
19290: LIST
19291: LIST
19292: LIST
19293: LIST
19294: PUSH
19295: EMPTY
19296: LIST
19297: LIST
19298: PPUSH
19299: CALL_OW 69
19303: ST_TO_ADDR
// if not tmp then
19304: LD_VAR 0 2
19308: NOT
19309: IFFALSE 19313
// exit ;
19311: GO 19342
// for i in tmp do
19313: LD_ADDR_VAR 0 1
19317: PUSH
19318: LD_VAR 0 2
19322: PUSH
19323: FOR_IN
19324: IFFALSE 19340
// SetLives ( i , 1 ) ;
19326: LD_VAR 0 1
19330: PPUSH
19331: LD_INT 1
19333: PPUSH
19334: CALL_OW 234
19338: GO 19323
19340: POP
19341: POP
// end ;
19342: PPOPN 2
19344: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
19345: LD_EXP 30
19349: PUSH
19350: LD_EXP 79
19354: AND
19355: IFFALSE 19629
19357: GO 19359
19359: DISABLE
19360: LD_INT 0
19362: PPUSH
19363: PPUSH
19364: PPUSH
// begin i := rand ( 1 , 7 ) ;
19365: LD_ADDR_VAR 0 1
19369: PUSH
19370: LD_INT 1
19372: PPUSH
19373: LD_INT 7
19375: PPUSH
19376: CALL_OW 12
19380: ST_TO_ADDR
// case i of 1 :
19381: LD_VAR 0 1
19385: PUSH
19386: LD_INT 1
19388: DOUBLE
19389: EQUAL
19390: IFTRUE 19394
19392: GO 19404
19394: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
19395: LD_STRING earthquake(getX(game), 0, 32)
19397: PPUSH
19398: CALL_OW 559
19402: GO 19629
19404: LD_INT 2
19406: DOUBLE
19407: EQUAL
19408: IFTRUE 19412
19410: GO 19426
19412: POP
// begin ToLua ( displayStucuk(); ) ;
19413: LD_STRING displayStucuk();
19415: PPUSH
19416: CALL_OW 559
// ResetFog ;
19420: CALL_OW 335
// end ; 3 :
19424: GO 19629
19426: LD_INT 3
19428: DOUBLE
19429: EQUAL
19430: IFTRUE 19434
19432: GO 19538
19434: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19435: LD_ADDR_VAR 0 2
19439: PUSH
19440: LD_INT 22
19442: PUSH
19443: LD_OWVAR 2
19447: PUSH
19448: EMPTY
19449: LIST
19450: LIST
19451: PUSH
19452: LD_INT 25
19454: PUSH
19455: LD_INT 1
19457: PUSH
19458: EMPTY
19459: LIST
19460: LIST
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 69
19470: ST_TO_ADDR
// if not tmp then
19471: LD_VAR 0 2
19475: NOT
19476: IFFALSE 19480
// exit ;
19478: GO 19629
// un := tmp [ rand ( 1 , tmp ) ] ;
19480: LD_ADDR_VAR 0 3
19484: PUSH
19485: LD_VAR 0 2
19489: PUSH
19490: LD_INT 1
19492: PPUSH
19493: LD_VAR 0 2
19497: PPUSH
19498: CALL_OW 12
19502: ARRAY
19503: ST_TO_ADDR
// if Crawls ( un ) then
19504: LD_VAR 0 3
19508: PPUSH
19509: CALL_OW 318
19513: IFFALSE 19524
// ComWalk ( un ) ;
19515: LD_VAR 0 3
19519: PPUSH
19520: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19524: LD_VAR 0 3
19528: PPUSH
19529: LD_INT 8
19531: PPUSH
19532: CALL_OW 336
// end ; 4 :
19536: GO 19629
19538: LD_INT 4
19540: DOUBLE
19541: EQUAL
19542: IFTRUE 19546
19544: GO 19607
19546: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19547: LD_ADDR_VAR 0 2
19551: PUSH
19552: LD_INT 22
19554: PUSH
19555: LD_OWVAR 2
19559: PUSH
19560: EMPTY
19561: LIST
19562: LIST
19563: PUSH
19564: LD_INT 30
19566: PUSH
19567: LD_INT 29
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: PUSH
19574: EMPTY
19575: LIST
19576: LIST
19577: PPUSH
19578: CALL_OW 69
19582: ST_TO_ADDR
// if not tmp then
19583: LD_VAR 0 2
19587: NOT
19588: IFFALSE 19592
// exit ;
19590: GO 19629
// DestroyUnit ( tmp [ 1 ] ) ;
19592: LD_VAR 0 2
19596: PUSH
19597: LD_INT 1
19599: ARRAY
19600: PPUSH
19601: CALL_OW 65
// end ; 5 .. 7 :
19605: GO 19629
19607: LD_INT 5
19609: DOUBLE
19610: GREATEREQUAL
19611: IFFALSE 19619
19613: LD_INT 7
19615: DOUBLE
19616: LESSEQUAL
19617: IFTRUE 19621
19619: GO 19628
19621: POP
// StreamSibBomb ; end ;
19622: CALL 15909 0 0
19626: GO 19629
19628: POP
// end ;
19629: PPOPN 3
19631: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
19632: LD_EXP 30
19636: PUSH
19637: LD_EXP 80
19641: AND
19642: IFFALSE 19798
19644: GO 19646
19646: DISABLE
19647: LD_INT 0
19649: PPUSH
19650: PPUSH
19651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
19652: LD_ADDR_VAR 0 2
19656: PUSH
19657: LD_INT 81
19659: PUSH
19660: LD_OWVAR 2
19664: PUSH
19665: EMPTY
19666: LIST
19667: LIST
19668: PUSH
19669: LD_INT 2
19671: PUSH
19672: LD_INT 21
19674: PUSH
19675: LD_INT 1
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: PUSH
19682: LD_INT 21
19684: PUSH
19685: LD_INT 2
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: LIST
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PPUSH
19701: CALL_OW 69
19705: ST_TO_ADDR
// if not tmp then
19706: LD_VAR 0 2
19710: NOT
19711: IFFALSE 19715
// exit ;
19713: GO 19798
// p := 0 ;
19715: LD_ADDR_VAR 0 3
19719: PUSH
19720: LD_INT 0
19722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19723: LD_INT 35
19725: PPUSH
19726: CALL_OW 67
// p := p + 1 ;
19730: LD_ADDR_VAR 0 3
19734: PUSH
19735: LD_VAR 0 3
19739: PUSH
19740: LD_INT 1
19742: PLUS
19743: ST_TO_ADDR
// for i in tmp do
19744: LD_ADDR_VAR 0 1
19748: PUSH
19749: LD_VAR 0 2
19753: PUSH
19754: FOR_IN
19755: IFFALSE 19786
// if GetLives ( i ) < 1000 then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 256
19766: PUSH
19767: LD_INT 1000
19769: LESS
19770: IFFALSE 19784
// SetLives ( i , 1000 ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_INT 1000
19779: PPUSH
19780: CALL_OW 234
19784: GO 19754
19786: POP
19787: POP
// until p > 20 ;
19788: LD_VAR 0 3
19792: PUSH
19793: LD_INT 20
19795: GREATER
19796: IFFALSE 19723
// end ;
19798: PPOPN 3
19800: END
// every 0 0$1 trigger StreamModeActive and sTime do
19801: LD_EXP 30
19805: PUSH
19806: LD_EXP 81
19810: AND
19811: IFFALSE 19846
19813: GO 19815
19815: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
19816: LD_INT 28
19818: PPUSH
19819: LD_OWVAR 2
19823: PPUSH
19824: LD_INT 2
19826: PPUSH
19827: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
19831: LD_INT 30
19833: PPUSH
19834: LD_OWVAR 2
19838: PPUSH
19839: LD_INT 2
19841: PPUSH
19842: CALL_OW 322
// end ;
19846: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19847: LD_EXP 30
19851: PUSH
19852: LD_EXP 82
19856: AND
19857: IFFALSE 19978
19859: GO 19861
19861: DISABLE
19862: LD_INT 0
19864: PPUSH
19865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19866: LD_ADDR_VAR 0 2
19870: PUSH
19871: LD_INT 22
19873: PUSH
19874: LD_OWVAR 2
19878: PUSH
19879: EMPTY
19880: LIST
19881: LIST
19882: PUSH
19883: LD_INT 21
19885: PUSH
19886: LD_INT 1
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: PUSH
19893: LD_INT 3
19895: PUSH
19896: LD_INT 23
19898: PUSH
19899: LD_INT 0
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: LIST
19914: PPUSH
19915: CALL_OW 69
19919: ST_TO_ADDR
// if not tmp then
19920: LD_VAR 0 2
19924: NOT
19925: IFFALSE 19929
// exit ;
19927: GO 19978
// for i in tmp do
19929: LD_ADDR_VAR 0 1
19933: PUSH
19934: LD_VAR 0 2
19938: PUSH
19939: FOR_IN
19940: IFFALSE 19976
// begin if Crawls ( i ) then
19942: LD_VAR 0 1
19946: PPUSH
19947: CALL_OW 318
19951: IFFALSE 19962
// ComWalk ( i ) ;
19953: LD_VAR 0 1
19957: PPUSH
19958: CALL_OW 138
// SetClass ( i , 2 ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_INT 2
19969: PPUSH
19970: CALL_OW 336
// end ;
19974: GO 19939
19976: POP
19977: POP
// end ;
19978: PPOPN 2
19980: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19981: LD_EXP 30
19985: PUSH
19986: LD_EXP 83
19990: AND
19991: IFFALSE 20212
19993: GO 19995
19995: DISABLE
19996: LD_INT 0
19998: PPUSH
19999: PPUSH
20000: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
20001: LD_OWVAR 2
20005: PPUSH
20006: LD_INT 9
20008: PPUSH
20009: LD_INT 1
20011: PPUSH
20012: LD_INT 1
20014: PPUSH
20015: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
20019: LD_INT 9
20021: PPUSH
20022: LD_OWVAR 2
20026: PPUSH
20027: CALL_OW 343
// uc_side := 9 ;
20031: LD_ADDR_OWVAR 20
20035: PUSH
20036: LD_INT 9
20038: ST_TO_ADDR
// uc_nation := 2 ;
20039: LD_ADDR_OWVAR 21
20043: PUSH
20044: LD_INT 2
20046: ST_TO_ADDR
// hc_name := Dark Warrior ;
20047: LD_ADDR_OWVAR 26
20051: PUSH
20052: LD_STRING Dark Warrior
20054: ST_TO_ADDR
// hc_gallery :=  ;
20055: LD_ADDR_OWVAR 33
20059: PUSH
20060: LD_STRING 
20062: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
20063: LD_INT 1
20065: PPUSH
20066: LD_INT 1
20068: PPUSH
20069: LD_INT 10
20071: PPUSH
20072: CALL_OW 380
// un := CreateHuman ;
20076: LD_ADDR_VAR 0 3
20080: PUSH
20081: CALL_OW 44
20085: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20086: LD_VAR 0 3
20090: PPUSH
20091: LD_INT 1
20093: PPUSH
20094: CALL_OW 51
// p := 0 ;
20098: LD_ADDR_VAR 0 2
20102: PUSH
20103: LD_INT 0
20105: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20106: LD_INT 35
20108: PPUSH
20109: CALL_OW 67
// if GetLives ( un ) < 1000 then
20113: LD_VAR 0 3
20117: PPUSH
20118: CALL_OW 256
20122: PUSH
20123: LD_INT 1000
20125: LESS
20126: IFFALSE 20140
// SetLives ( un , 1000 ) ;
20128: LD_VAR 0 3
20132: PPUSH
20133: LD_INT 1000
20135: PPUSH
20136: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
20140: LD_VAR 0 3
20144: PPUSH
20145: LD_INT 81
20147: PUSH
20148: LD_OWVAR 2
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: PPUSH
20157: CALL_OW 69
20161: PPUSH
20162: LD_VAR 0 3
20166: PPUSH
20167: CALL_OW 74
20171: PPUSH
20172: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
20176: LD_VAR 0 2
20180: PUSH
20181: LD_INT 60
20183: GREATER
20184: PUSH
20185: LD_VAR 0 3
20189: PPUSH
20190: CALL_OW 301
20194: OR
20195: IFFALSE 20106
// if un then
20197: LD_VAR 0 3
20201: IFFALSE 20212
// RemoveUnit ( un ) ;
20203: LD_VAR 0 3
20207: PPUSH
20208: CALL_OW 64
// end ; end_of_file
20212: PPOPN 3
20214: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
20215: LD_INT 0
20217: PPUSH
20218: PPUSH
20219: PPUSH
20220: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
20221: LD_VAR 0 1
20225: PPUSH
20226: CALL_OW 264
20230: PUSH
20231: LD_EXP 29
20235: EQUAL
20236: IFFALSE 20308
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
20238: LD_INT 68
20240: PPUSH
20241: LD_VAR 0 1
20245: PPUSH
20246: CALL_OW 255
20250: PPUSH
20251: CALL_OW 321
20255: PUSH
20256: LD_INT 2
20258: EQUAL
20259: IFFALSE 20271
// eff := 70 else
20261: LD_ADDR_VAR 0 6
20265: PUSH
20266: LD_INT 70
20268: ST_TO_ADDR
20269: GO 20279
// eff := 30 ;
20271: LD_ADDR_VAR 0 6
20275: PUSH
20276: LD_INT 30
20278: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
20279: LD_VAR 0 1
20283: PPUSH
20284: CALL_OW 250
20288: PPUSH
20289: LD_VAR 0 1
20293: PPUSH
20294: CALL_OW 251
20298: PPUSH
20299: LD_VAR 0 6
20303: PPUSH
20304: CALL_OW 495
// end ; end ;
20308: LD_VAR 0 4
20312: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
20313: LD_INT 0
20315: PPUSH
20316: PPUSH
20317: PPUSH
20318: PPUSH
20319: PPUSH
20320: PPUSH
// if cmd = 124 then
20321: LD_VAR 0 1
20325: PUSH
20326: LD_INT 124
20328: EQUAL
20329: IFFALSE 20535
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
20331: LD_ADDR_VAR 0 5
20335: PUSH
20336: LD_INT 2
20338: PUSH
20339: LD_INT 34
20341: PUSH
20342: LD_INT 53
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PUSH
20349: LD_INT 34
20351: PUSH
20352: LD_INT 14
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: LIST
20363: PPUSH
20364: CALL_OW 69
20368: ST_TO_ADDR
// if not tmp then
20369: LD_VAR 0 5
20373: NOT
20374: IFFALSE 20378
// exit ;
20376: GO 20535
// for i in tmp do
20378: LD_ADDR_VAR 0 3
20382: PUSH
20383: LD_VAR 0 5
20387: PUSH
20388: FOR_IN
20389: IFFALSE 20533
// begin taskList := GetTaskList ( i ) ;
20391: LD_ADDR_VAR 0 6
20395: PUSH
20396: LD_VAR 0 3
20400: PPUSH
20401: CALL_OW 437
20405: ST_TO_ADDR
// if not taskList then
20406: LD_VAR 0 6
20410: NOT
20411: IFFALSE 20415
// continue ;
20413: GO 20388
// for j = 1 to taskList do
20415: LD_ADDR_VAR 0 4
20419: PUSH
20420: DOUBLE
20421: LD_INT 1
20423: DEC
20424: ST_TO_ADDR
20425: LD_VAR 0 6
20429: PUSH
20430: FOR_TO
20431: IFFALSE 20529
// if taskList [ j ] [ 1 ] = | then
20433: LD_VAR 0 6
20437: PUSH
20438: LD_VAR 0 4
20442: ARRAY
20443: PUSH
20444: LD_INT 1
20446: ARRAY
20447: PUSH
20448: LD_STRING |
20450: EQUAL
20451: IFFALSE 20527
// begin _taskList := Delete ( taskList , 1 ) ;
20453: LD_ADDR_VAR 0 7
20457: PUSH
20458: LD_VAR 0 6
20462: PPUSH
20463: LD_INT 1
20465: PPUSH
20466: CALL_OW 3
20470: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
20471: LD_VAR 0 3
20475: PPUSH
20476: LD_VAR 0 7
20480: PPUSH
20481: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
20485: LD_VAR 0 3
20489: PPUSH
20490: LD_VAR 0 6
20494: PUSH
20495: LD_VAR 0 4
20499: ARRAY
20500: PUSH
20501: LD_INT 2
20503: ARRAY
20504: PPUSH
20505: LD_VAR 0 6
20509: PUSH
20510: LD_VAR 0 4
20514: ARRAY
20515: PUSH
20516: LD_INT 3
20518: ARRAY
20519: PPUSH
20520: LD_INT 8
20522: PPUSH
20523: CALL 20540 0 4
// end ;
20527: GO 20430
20529: POP
20530: POP
// end ;
20531: GO 20388
20533: POP
20534: POP
// end ; end ;
20535: LD_VAR 0 2
20539: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
20540: LD_INT 0
20542: PPUSH
20543: PPUSH
20544: PPUSH
20545: PPUSH
20546: PPUSH
20547: PPUSH
20548: PPUSH
20549: PPUSH
20550: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
20551: LD_VAR 0 1
20555: NOT
20556: PUSH
20557: LD_VAR 0 2
20561: PPUSH
20562: LD_VAR 0 3
20566: PPUSH
20567: CALL_OW 488
20571: NOT
20572: OR
20573: PUSH
20574: LD_VAR 0 4
20578: NOT
20579: OR
20580: IFFALSE 20584
// exit ;
20582: GO 20924
// list := [ ] ;
20584: LD_ADDR_VAR 0 13
20588: PUSH
20589: EMPTY
20590: ST_TO_ADDR
// if x - r < 0 then
20591: LD_VAR 0 2
20595: PUSH
20596: LD_VAR 0 4
20600: MINUS
20601: PUSH
20602: LD_INT 0
20604: LESS
20605: IFFALSE 20617
// min_x := 0 else
20607: LD_ADDR_VAR 0 7
20611: PUSH
20612: LD_INT 0
20614: ST_TO_ADDR
20615: GO 20633
// min_x := x - r ;
20617: LD_ADDR_VAR 0 7
20621: PUSH
20622: LD_VAR 0 2
20626: PUSH
20627: LD_VAR 0 4
20631: MINUS
20632: ST_TO_ADDR
// if y - r < 0 then
20633: LD_VAR 0 3
20637: PUSH
20638: LD_VAR 0 4
20642: MINUS
20643: PUSH
20644: LD_INT 0
20646: LESS
20647: IFFALSE 20659
// min_y := 0 else
20649: LD_ADDR_VAR 0 8
20653: PUSH
20654: LD_INT 0
20656: ST_TO_ADDR
20657: GO 20675
// min_y := y - r ;
20659: LD_ADDR_VAR 0 8
20663: PUSH
20664: LD_VAR 0 3
20668: PUSH
20669: LD_VAR 0 4
20673: MINUS
20674: ST_TO_ADDR
// max_x := x + r ;
20675: LD_ADDR_VAR 0 9
20679: PUSH
20680: LD_VAR 0 2
20684: PUSH
20685: LD_VAR 0 4
20689: PLUS
20690: ST_TO_ADDR
// max_y := y + r ;
20691: LD_ADDR_VAR 0 10
20695: PUSH
20696: LD_VAR 0 3
20700: PUSH
20701: LD_VAR 0 4
20705: PLUS
20706: ST_TO_ADDR
// for _x = min_x to max_x do
20707: LD_ADDR_VAR 0 11
20711: PUSH
20712: DOUBLE
20713: LD_VAR 0 7
20717: DEC
20718: ST_TO_ADDR
20719: LD_VAR 0 9
20723: PUSH
20724: FOR_TO
20725: IFFALSE 20842
// for _y = min_y to max_y do
20727: LD_ADDR_VAR 0 12
20731: PUSH
20732: DOUBLE
20733: LD_VAR 0 8
20737: DEC
20738: ST_TO_ADDR
20739: LD_VAR 0 10
20743: PUSH
20744: FOR_TO
20745: IFFALSE 20838
// begin if not ValidHex ( _x , _y ) then
20747: LD_VAR 0 11
20751: PPUSH
20752: LD_VAR 0 12
20756: PPUSH
20757: CALL_OW 488
20761: NOT
20762: IFFALSE 20766
// continue ;
20764: GO 20744
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
20766: LD_VAR 0 11
20770: PPUSH
20771: LD_VAR 0 12
20775: PPUSH
20776: CALL_OW 351
20780: PUSH
20781: LD_VAR 0 11
20785: PPUSH
20786: LD_VAR 0 12
20790: PPUSH
20791: CALL_OW 554
20795: AND
20796: IFFALSE 20836
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
20798: LD_ADDR_VAR 0 13
20802: PUSH
20803: LD_VAR 0 13
20807: PPUSH
20808: LD_VAR 0 13
20812: PUSH
20813: LD_INT 1
20815: PLUS
20816: PPUSH
20817: LD_VAR 0 11
20821: PUSH
20822: LD_VAR 0 12
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: PPUSH
20831: CALL_OW 2
20835: ST_TO_ADDR
// end ;
20836: GO 20744
20838: POP
20839: POP
20840: GO 20724
20842: POP
20843: POP
// if not list then
20844: LD_VAR 0 13
20848: NOT
20849: IFFALSE 20853
// exit ;
20851: GO 20924
// for i in list do
20853: LD_ADDR_VAR 0 6
20857: PUSH
20858: LD_VAR 0 13
20862: PUSH
20863: FOR_IN
20864: IFFALSE 20922
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20866: LD_VAR 0 1
20870: PPUSH
20871: LD_STRING M
20873: PUSH
20874: LD_VAR 0 6
20878: PUSH
20879: LD_INT 1
20881: ARRAY
20882: PUSH
20883: LD_VAR 0 6
20887: PUSH
20888: LD_INT 2
20890: ARRAY
20891: PUSH
20892: LD_INT 0
20894: PUSH
20895: LD_INT 0
20897: PUSH
20898: LD_INT 0
20900: PUSH
20901: LD_INT 0
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: LIST
20908: LIST
20909: LIST
20910: LIST
20911: LIST
20912: PUSH
20913: EMPTY
20914: LIST
20915: PPUSH
20916: CALL_OW 447
20920: GO 20863
20922: POP
20923: POP
// end ;
20924: LD_VAR 0 5
20928: RET
