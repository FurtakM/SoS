// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// SetDifficulty ( GetMultiplayerSetting ( 0 ) ) ;
  11: LD_INT 0
  13: PPUSH
  14: CALL_OW 426
  18: PPUSH
  19: CALL 279 0 1
// InGameOn ;
  23: CALL_OW 8
// CenterNowOnXY ( 0 , 0 ) ;
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: CALL_OW 86
// RandomizeAll ;
  37: CALL_OW 11
// DestroyTrash ;
  41: CALL 148 0 0
// ShowPath ;
  45: CALL 214 0 0
// RandMusic ( 1 , 3 ) ;
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 3
  54: PPUSH
  55: CALL 222 0 2
// PrepareAnimals ( [ 8 , 7 , 6 ] [ dif ] , 2 , 3 , nature ) ;
  59: LD_INT 8
  61: PUSH
  62: LD_INT 7
  64: PUSH
  65: LD_INT 6
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: LIST
  72: PUSH
  73: LD_EXP 1
  77: ARRAY
  78: PPUSH
  79: LD_INT 2
  81: PPUSH
  82: LD_INT 3
  84: PPUSH
  85: LD_INT 10
  87: PPUSH
  88: CALL 329 0 4
// PrepareRussian ;
  92: CALL 1407 0 0
// Action ;
  96: CALL 8617 0 0
// PrepareAmerican ;
 100: CALL 5237 0 0
// end ;
 104: END
// every 2 2$00 + 1 1$0 do var i , bool ;
 105: GO 107
 107: DISABLE
 108: LD_INT 0
 110: PPUSH
 111: PPUSH
// begin bool := Rand ( false , true ) ;
 112: LD_ADDR_VAR 0 2
 116: PUSH
 117: LD_INT 0
 119: PPUSH
 120: LD_INT 1
 122: PPUSH
 123: CALL_OW 12
 127: ST_TO_ADDR
// if bool then
 128: LD_VAR 0 2
 132: IFFALSE 144
// RandMusic ( 1 , 3 ) ;
 134: LD_INT 1
 136: PPUSH
 137: LD_INT 3
 139: PPUSH
 140: CALL 222 0 2
// enable ;
 144: ENABLE
// end ; end_of_file
 145: PPOPN 2
 147: END
// export function DestroyTrash ; var i ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_not , [ f_lives , 5 ] ] ] ) do
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 22
 159: PUSH
 160: LD_INT 0
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: PUSH
 167: LD_INT 3
 169: PUSH
 170: LD_INT 24
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: EMPTY
 177: LIST
 178: LIST
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PPUSH
 188: CALL_OW 69
 192: PUSH
 193: FOR_IN
 194: IFFALSE 207
// KillUnit ( i ) ;
 196: LD_VAR 0 2
 200: PPUSH
 201: CALL_OW 66
 205: GO 193
 207: POP
 208: POP
// end ;
 209: LD_VAR 0 1
 213: RET
// export function ShowPath ; begin
 214: LD_INT 0
 216: PPUSH
// end ;
 217: LD_VAR 0 1
 221: RET
// export function RandMusic ( n1 , n2 ) ; var proc ; begin
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// proc := Rand ( 0 , 100 ) ;
 226: LD_ADDR_VAR 0 4
 230: PUSH
 231: LD_INT 0
 233: PPUSH
 234: LD_INT 100
 236: PPUSH
 237: CALL_OW 12
 241: ST_TO_ADDR
// if proc > 50 then
 242: LD_VAR 0 4
 246: PUSH
 247: LD_INT 50
 249: GREATER
 250: IFFALSE 264
// music_nat := n1 else
 252: LD_ADDR_OWVAR 71
 256: PUSH
 257: LD_VAR 0 1
 261: ST_TO_ADDR
 262: GO 274
// music_nat := n2 ;
 264: LD_ADDR_OWVAR 71
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// end ;
 274: LD_VAR 0 3
 278: RET
// export dif ; export function SetDifficulty ( val ) ; begin
 279: LD_INT 0
 281: PPUSH
// if not val then
 282: LD_VAR 0 1
 286: NOT
 287: IFFALSE 297
// val := 2 ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: LD_INT 2
 296: ST_TO_ADDR
// dif := val ;
 297: LD_ADDR_EXP 1
 301: PUSH
 302: LD_VAR 0 1
 306: ST_TO_ADDR
// if dif < 3 then
 307: LD_EXP 1
 311: PUSH
 312: LD_INT 3
 314: LESS
 315: IFFALSE 324
// RemoveEnvironmentArea ( evnt ) ;
 317: LD_INT 9
 319: PPUSH
 320: CALL_OW 355
// end ;
 324: LD_VAR 0 2
 328: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
 329: LD_INT 0
 331: PPUSH
 332: PPUSH
 333: PPUSH
 334: PPUSH
 335: PPUSH
// uc_nation = nation_nature ;
 336: LD_ADDR_OWVAR 21
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_side = 0 ;
 344: LD_ADDR_OWVAR 20
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// hc_importance := 0 ;
 352: LD_ADDR_OWVAR 32
 356: PUSH
 357: LD_INT 0
 359: ST_TO_ADDR
// l = 0 ;
 360: LD_ADDR_VAR 0 6
 364: PUSH
 365: LD_INT 0
 367: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
 368: LD_ADDR_OWVAR 24
 372: PUSH
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: CALL_OW 12
 383: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 384: LD_ADDR_OWVAR 35
 388: PUSH
 389: LD_INT 5
 391: NEG
 392: PPUSH
 393: LD_INT 5
 395: PPUSH
 396: CALL_OW 12
 400: ST_TO_ADDR
// hc_gallery =  ;
 401: LD_ADDR_OWVAR 33
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// hc_class = class_apeman ;
 409: LD_ADDR_OWVAR 28
 413: PUSH
 414: LD_INT 12
 416: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 11
 424: PPUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 12
 432: PUSH
 433: LD_INT 10
 435: PPUSH
 436: LD_INT 11
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// hc_sex = sex_male ;
 448: LD_ADDR_OWVAR 27
 452: PUSH
 453: LD_INT 1
 455: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 456: LD_ADDR_OWVAR 31
 460: PUSH
 461: LD_INT 0
 463: PPUSH
 464: LD_INT 2
 466: PPUSH
 467: CALL_OW 12
 471: PUSH
 472: LD_INT 0
 474: PUSH
 475: LD_INT 0
 477: PUSH
 478: LD_INT 0
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: ST_TO_ADDR
// apeman = CreateHuman ;
 487: LD_ADDR_VAR 0 7
 491: PUSH
 492: CALL_OW 44
 496: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 497: LD_VAR 0 7
 501: PPUSH
 502: LD_VAR 0 4
 506: PPUSH
 507: LD_INT 0
 509: PPUSH
 510: CALL_OW 49
// l = l + 1 ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 1
 526: PLUS
 527: ST_TO_ADDR
// end until l = num1 ;
 528: LD_VAR 0 6
 532: PUSH
 533: LD_VAR 0 1
 537: EQUAL
 538: IFFALSE 368
// l = 0 ;
 540: LD_ADDR_VAR 0 6
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 548: LD_ADDR_OWVAR 35
 552: PUSH
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 25
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// hc_class = class_tiger ;
 564: LD_ADDR_OWVAR 28
 568: PUSH
 569: LD_INT 14
 571: ST_TO_ADDR
// hc_sex = sex_male ;
 572: LD_ADDR_OWVAR 27
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// hc_gallery = sandnature ;
 580: LD_ADDR_OWVAR 33
 584: PUSH
 585: LD_STRING sandnature
 587: ST_TO_ADDR
// hc_face_number = 3 ;
 588: LD_ADDR_OWVAR 34
 592: PUSH
 593: LD_INT 3
 595: ST_TO_ADDR
// tiger = CreateHuman ;
 596: LD_ADDR_VAR 0 8
 600: PUSH
 601: CALL_OW 44
 605: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 606: LD_VAR 0 8
 610: PPUSH
 611: LD_VAR 0 4
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// l = l + 1 ;
 623: LD_ADDR_VAR 0 6
 627: PUSH
 628: LD_VAR 0 6
 632: PUSH
 633: LD_INT 1
 635: PLUS
 636: ST_TO_ADDR
// end until l = num2 ;
 637: LD_VAR 0 6
 641: PUSH
 642: LD_VAR 0 2
 646: EQUAL
 647: IFFALSE 548
// l = 0 ;
 649: LD_ADDR_VAR 0 6
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 657: LD_ADDR_OWVAR 28
 661: PUSH
 662: LD_INT 18
 664: ST_TO_ADDR
// hc_gallery = sandnature ;
 665: LD_ADDR_OWVAR 33
 669: PUSH
 670: LD_STRING sandnature
 672: ST_TO_ADDR
// hc_face_number = 1 ;
 673: LD_ADDR_OWVAR 34
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// bird = CreateHuman ;
 681: LD_ADDR_VAR 0 9
 685: PUSH
 686: CALL_OW 44
 690: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 691: LD_VAR 0 9
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 51
// l = l + 1 ;
 703: LD_ADDR_VAR 0 6
 707: PUSH
 708: LD_VAR 0 6
 712: PUSH
 713: LD_INT 1
 715: PLUS
 716: ST_TO_ADDR
// end until l = num3 ;
 717: LD_VAR 0 6
 721: PUSH
 722: LD_VAR 0 3
 726: EQUAL
 727: IFFALSE 657
// end ;
 729: LD_VAR 0 5
 733: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 734: LD_INT 0
 736: PPUSH
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// InitHc ;
 742: CALL_OW 19
// hc_class := clas ;
 746: LD_ADDR_OWVAR 28
 750: PUSH
 751: LD_VAR 0 1
 755: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 756: LD_ADDR_VAR 0 4
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: NEG
 769: PPUSH
 770: LD_INT 1
 772: PPUSH
 773: CALL_OW 12
 777: PLUS
 778: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: NEG
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: CALL_OW 12
 800: PLUS
 801: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 802: LD_ADDR_VAR 0 6
 806: PUSH
 807: LD_VAR 0 2
 811: PUSH
 812: LD_INT 1
 814: NEG
 815: PPUSH
 816: LD_INT 1
 818: PPUSH
 819: CALL_OW 12
 823: PLUS
 824: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 825: LD_ADDR_VAR 0 7
 829: PUSH
 830: LD_VAR 0 2
 834: PUSH
 835: LD_INT 1
 837: NEG
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 12
 846: PLUS
 847: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
 848: LD_VAR 0 1
 852: PUSH
 853: LD_INT 1
 855: EQUAL
 856: PUSH
 857: LD_VAR 0 1
 861: PUSH
 862: LD_INT 9
 864: EQUAL
 865: OR
 866: PUSH
 867: LD_VAR 0 1
 871: PUSH
 872: LD_INT 5
 874: EQUAL
 875: OR
 876: PUSH
 877: LD_VAR 0 1
 881: PUSH
 882: LD_INT 8
 884: EQUAL
 885: OR
 886: IFFALSE 911
// bonus := [ 2 , 0 , 0 , 0 ] ;
 888: LD_ADDR_VAR 0 8
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: ST_TO_ADDR
// if clas = 2 then
 911: LD_VAR 0 1
 915: PUSH
 916: LD_INT 2
 918: EQUAL
 919: IFFALSE 944
// bonus := [ 0 , 2 , 0 , 0 ] ;
 921: LD_ADDR_VAR 0 8
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 2
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: LD_INT 0
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: ST_TO_ADDR
// if clas = 3 then
 944: LD_VAR 0 1
 948: PUSH
 949: LD_INT 3
 951: EQUAL
 952: IFFALSE 977
// bonus := [ 0 , 0 , 2 , 0 ] ;
 954: LD_ADDR_VAR 0 8
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: LD_INT 0
 964: PUSH
 965: LD_INT 2
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: ST_TO_ADDR
// if clas = 4 then
 977: LD_VAR 0 1
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: IFFALSE 1010
// bonus := [ 0 , 0 , 0 , 2 ] ;
 987: LD_ADDR_VAR 0 8
 991: PUSH
 992: LD_INT 0
 994: PUSH
 995: LD_INT 0
 997: PUSH
 998: LD_INT 0
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
1010: LD_VAR 0 1
1014: PUSH
1015: LD_INT 4
1017: GREATER
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 9
1026: NONEQUAL
1027: AND
1028: PUSH
1029: LD_VAR 0 1
1033: PUSH
1034: LD_INT 5
1036: NONEQUAL
1037: AND
1038: PUSH
1039: LD_VAR 0 1
1043: PUSH
1044: LD_INT 8
1046: NONEQUAL
1047: AND
1048: IFFALSE 1073
// bonus := [ 0 , 0 , 0 , 0 ] ;
1050: LD_ADDR_VAR 0 8
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 0
1060: PUSH
1061: LD_INT 0
1063: PUSH
1064: LD_INT 0
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1073: LD_ADDR_OWVAR 30
1077: PUSH
1078: LD_INT 0
1080: PPUSH
1081: LD_INT 2
1083: PPUSH
1084: CALL_OW 12
1088: PUSH
1089: LD_INT 0
1091: PPUSH
1092: LD_INT 2
1094: PPUSH
1095: CALL_OW 12
1099: PUSH
1100: LD_INT 0
1102: PPUSH
1103: LD_INT 2
1105: PPUSH
1106: CALL_OW 12
1110: PUSH
1111: LD_INT 0
1113: PPUSH
1114: LD_INT 2
1116: PPUSH
1117: CALL_OW 12
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1128: LD_ADDR_OWVAR 31
1132: PUSH
1133: LD_VAR 0 4
1137: PUSH
1138: LD_VAR 0 8
1142: PUSH
1143: LD_INT 1
1145: ARRAY
1146: PLUS
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 8
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PLUS
1162: PUSH
1163: LD_VAR 0 6
1167: PUSH
1168: LD_VAR 0 8
1172: PUSH
1173: LD_INT 3
1175: ARRAY
1176: PLUS
1177: PUSH
1178: LD_VAR 0 7
1182: PUSH
1183: LD_VAR 0 8
1187: PUSH
1188: LD_INT 4
1190: ARRAY
1191: PLUS
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// if clas = 3 then
1199: LD_VAR 0 1
1203: PUSH
1204: LD_INT 3
1206: EQUAL
1207: IFFALSE 1219
// hc_sex := sex_male else
1209: LD_ADDR_OWVAR 27
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
1217: GO 1235
// hc_sex := Rand ( sex_male , sex_female ) ;
1219: LD_ADDR_OWVAR 27
1223: PUSH
1224: LD_INT 1
1226: PPUSH
1227: LD_INT 2
1229: PPUSH
1230: CALL_OW 12
1234: ST_TO_ADDR
// hc_gallery :=  ;
1235: LD_ADDR_OWVAR 33
1239: PUSH
1240: LD_STRING 
1242: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 8 , 12 ) ] ;
1243: LD_ADDR_OWVAR 29
1247: PUSH
1248: LD_INT 8
1250: PPUSH
1251: LD_INT 12
1253: PPUSH
1254: CALL_OW 12
1258: PUSH
1259: LD_INT 8
1261: PPUSH
1262: LD_INT 12
1264: PPUSH
1265: CALL_OW 12
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name :=  ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING 
1281: ST_TO_ADDR
// result := CreateHuman ;
1282: LD_ADDR_VAR 0 3
1286: PUSH
1287: CALL_OW 44
1291: ST_TO_ADDR
// end ;
1292: LD_VAR 0 3
1296: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
1297: LD_INT 0
1299: PPUSH
1300: PPUSH
// vc_chassis := chassis ;
1301: LD_ADDR_OWVAR 37
1305: PUSH
1306: LD_VAR 0 1
1310: ST_TO_ADDR
// vc_engine := engine ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_VAR 0 2
1320: ST_TO_ADDR
// vc_weapon := weapon ;
1321: LD_ADDR_OWVAR 40
1325: PUSH
1326: LD_VAR 0 3
1330: ST_TO_ADDR
// vc_control := control_manual ;
1331: LD_ADDR_OWVAR 38
1335: PUSH
1336: LD_INT 1
1338: ST_TO_ADDR
// veh := CreateVehicle ;
1339: LD_ADDR_VAR 0 8
1343: PUSH
1344: CALL_OW 45
1348: ST_TO_ADDR
// SetDir ( veh , dir ) ;
1349: LD_VAR 0 8
1353: PPUSH
1354: LD_VAR 0 5
1358: PPUSH
1359: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
1363: LD_VAR 0 8
1367: PPUSH
1368: LD_VAR 0 4
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
1380: LD_INT 3
1382: PPUSH
1383: LD_VAR 0 6
1387: PPUSH
1388: CALL 734 0 2
1392: PPUSH
1393: LD_VAR 0 8
1397: PPUSH
1398: CALL_OW 52
// end ; end_of_file
1402: LD_VAR 0 7
1406: RET
// export Popov , Commander , Platonov , Kapral ; export depot_rdy , dep_x , dep_y ; export function PrepareRussian ; var i , un , skill , team , p ; begin
1407: LD_INT 0
1409: PPUSH
1410: PPUSH
1411: PPUSH
1412: PPUSH
1413: PPUSH
1414: PPUSH
// depot_rdy := false ;
1415: LD_ADDR_EXP 6
1419: PUSH
1420: LD_INT 0
1422: ST_TO_ADDR
// uc_side := 6 ;
1423: LD_ADDR_OWVAR 20
1427: PUSH
1428: LD_INT 6
1430: ST_TO_ADDR
// uc_nation := 3 ;
1431: LD_ADDR_OWVAR 21
1435: PUSH
1436: LD_INT 3
1438: ST_TO_ADDR
// hc_gallery := ru ;
1439: LD_ADDR_OWVAR 33
1443: PUSH
1444: LD_STRING ru
1446: ST_TO_ADDR
// hc_face_number := 10 ;
1447: LD_ADDR_OWVAR 34
1451: PUSH
1452: LD_INT 10
1454: ST_TO_ADDR
// hc_name := Siergiej I. Popov ;
1455: LD_ADDR_OWVAR 26
1459: PUSH
1460: LD_STRING Siergiej I. Popov
1462: ST_TO_ADDR
// hc_class := 1 ;
1463: LD_ADDR_OWVAR 28
1467: PUSH
1468: LD_INT 1
1470: ST_TO_ADDR
// hc_sex := sex_male ;
1471: LD_ADDR_OWVAR 27
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// popov := CreateHuman ;
1479: LD_ADDR_EXP 2
1483: PUSH
1484: CALL_OW 44
1488: ST_TO_ADDR
// hc_gallery := general ;
1489: LD_ADDR_OWVAR 33
1493: PUSH
1494: LD_STRING general
1496: ST_TO_ADDR
// hc_face_number := 1 ;
1497: LD_ADDR_OWVAR 34
1501: PUSH
1502: LD_INT 1
1504: ST_TO_ADDR
// hc_name := Mjr. D. N. Platonow ;
1505: LD_ADDR_OWVAR 26
1509: PUSH
1510: LD_STRING Mjr. D. N. Platonow
1512: ST_TO_ADDR
// platonov := CreateHuman ;
1513: LD_ADDR_EXP 4
1517: PUSH
1518: CALL_OW 44
1522: ST_TO_ADDR
// uc_side := 3 ;
1523: LD_ADDR_OWVAR 20
1527: PUSH
1528: LD_INT 3
1530: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
1531: LD_INT 3
1533: PPUSH
1534: LD_INT 6
1536: PPUSH
1537: CALL_OW 343
// skill := [ 6 , 5 , 4 ] [ dif ] ;
1541: LD_ADDR_VAR 0 4
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: LD_INT 5
1551: PUSH
1552: LD_INT 4
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: PUSH
1560: LD_EXP 1
1564: ARRAY
1565: ST_TO_ADDR
// team := [ ] ;
1566: LD_ADDR_VAR 0 5
1570: PUSH
1571: EMPTY
1572: ST_TO_ADDR
// hc_importance := 100 ;
1573: LD_ADDR_OWVAR 32
1577: PUSH
1578: LD_INT 100
1580: ST_TO_ADDR
// hc_gallery := gamma ;
1581: LD_ADDR_OWVAR 33
1585: PUSH
1586: LD_STRING gamma
1588: ST_TO_ADDR
// hc_face_number := 1 ;
1589: LD_ADDR_OWVAR 34
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_class := 1 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// hc_skills := [ [ 8 , 7 , 6 ] [ dif ] , 5 , 3 , 0 ] ;
1605: LD_ADDR_OWVAR 31
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: LD_INT 7
1615: PUSH
1616: LD_INT 6
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PUSH
1624: LD_EXP 1
1628: ARRAY
1629: PUSH
1630: LD_INT 5
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: ST_TO_ADDR
// hc_sex := sex_male ;
1645: LD_ADDR_OWVAR 27
1649: PUSH
1650: LD_INT 1
1652: ST_TO_ADDR
// hc_name := Mjr. Jurij Karakanov ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING Mjr. Jurij Karakanov
1660: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1661: LD_ADDR_OWVAR 29
1665: PUSH
1666: LD_INT 10
1668: PUSH
1669: LD_INT 11
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: ST_TO_ADDR
// commander := CreateHuman ;
1676: LD_ADDR_EXP 3
1680: PUSH
1681: CALL_OW 44
1685: ST_TO_ADDR
// team := team ^ commander ;
1686: LD_ADDR_VAR 0 5
1690: PUSH
1691: LD_VAR 0 5
1695: PUSH
1696: LD_EXP 3
1700: ADD
1701: ST_TO_ADDR
// hc_importance := 0 ;
1702: LD_ADDR_OWVAR 32
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// hc_name :=  ;
1710: LD_ADDR_OWVAR 26
1714: PUSH
1715: LD_STRING 
1717: ST_TO_ADDR
// hc_gallery :=  ;
1718: LD_ADDR_OWVAR 33
1722: PUSH
1723: LD_STRING 
1725: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1726: LD_ADDR_OWVAR 29
1730: PUSH
1731: LD_INT 12
1733: PUSH
1734: LD_INT 10
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// hc_sex := sex_male ;
1741: LD_ADDR_OWVAR 27
1745: PUSH
1746: LD_INT 1
1748: ST_TO_ADDR
// Kapral := CreateHuman ;
1749: LD_ADDR_EXP 5
1753: PUSH
1754: CALL_OW 44
1758: ST_TO_ADDR
// for i = 3 downto dif do
1759: LD_ADDR_VAR 0 2
1763: PUSH
1764: DOUBLE
1765: LD_INT 3
1767: INC
1768: ST_TO_ADDR
1769: LD_EXP 1
1773: PUSH
1774: FOR_DOWNTO
1775: IFFALSE 1881
// begin vc_chassis := ru_medium_tracked ;
1777: LD_ADDR_OWVAR 37
1781: PUSH
1782: LD_INT 22
1784: ST_TO_ADDR
// vc_engine := engine_combustion ;
1785: LD_ADDR_OWVAR 39
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// vc_control := control_manual ;
1793: LD_ADDR_OWVAR 38
1797: PUSH
1798: LD_INT 1
1800: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ i ] ;
1801: LD_ADDR_OWVAR 40
1805: PUSH
1806: LD_INT 43
1808: PUSH
1809: LD_INT 44
1811: PUSH
1812: LD_INT 44
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_VAR 0 2
1824: ARRAY
1825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1826: LD_ADDR_OWVAR 41
1830: PUSH
1831: LD_INT 55
1833: PPUSH
1834: LD_INT 77
1836: PPUSH
1837: CALL_OW 12
1841: ST_TO_ADDR
// un := CreateVehicle ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: CALL_OW 45
1851: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1852: LD_VAR 0 3
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1864: LD_VAR 0 3
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 49
// end ;
1879: GO 1774
1881: POP
1882: POP
// vc_weapon := ru_heavy_machine_gun ;
1883: LD_ADDR_OWVAR 40
1887: PUSH
1888: LD_INT 42
1890: ST_TO_ADDR
// vc_fuel_battery := Rand ( 55 , 77 ) ;
1891: LD_ADDR_OWVAR 41
1895: PUSH
1896: LD_INT 55
1898: PPUSH
1899: LD_INT 77
1901: PPUSH
1902: CALL_OW 12
1906: ST_TO_ADDR
// un := CreateVehicle ;
1907: LD_ADDR_VAR 0 3
1911: PUSH
1912: CALL_OW 45
1916: ST_TO_ADDR
// SetDir ( un , 5 ) ;
1917: LD_VAR 0 3
1921: PPUSH
1922: LD_INT 5
1924: PPUSH
1925: CALL_OW 233
// PlaceUnitArea ( un , rus_spawn , false ) ;
1929: LD_VAR 0 3
1933: PPUSH
1934: LD_INT 1
1936: PPUSH
1937: LD_INT 0
1939: PPUSH
1940: CALL_OW 49
// for p = 1 to 4 do
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: DOUBLE
1950: LD_INT 1
1952: DEC
1953: ST_TO_ADDR
1954: LD_INT 4
1956: PUSH
1957: FOR_TO
1958: IFFALSE 2025
// for i = 1 to [ 5 , 4 , 3 ] [ dif ] do
1960: LD_ADDR_VAR 0 2
1964: PUSH
1965: DOUBLE
1966: LD_INT 1
1968: DEC
1969: ST_TO_ADDR
1970: LD_INT 5
1972: PUSH
1973: LD_INT 4
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: LD_EXP 1
1988: ARRAY
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2021
// team := team ^ CreateHumanWithClass ( p , skill ) ;
1993: LD_ADDR_VAR 0 5
1997: PUSH
1998: LD_VAR 0 5
2002: PUSH
2003: LD_VAR 0 6
2007: PPUSH
2008: LD_VAR 0 4
2012: PPUSH
2013: CALL 734 0 2
2017: ADD
2018: ST_TO_ADDR
2019: GO 1990
2021: POP
2022: POP
2023: GO 1957
2025: POP
2026: POP
// for i = 1 to team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: DOUBLE
2033: LD_INT 1
2035: DEC
2036: ST_TO_ADDR
2037: LD_VAR 0 5
2041: PUSH
2042: FOR_TO
2043: IFFALSE 2161
// if GetClass ( team [ i ] ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) then
2045: LD_VAR 0 5
2049: PUSH
2050: LD_VAR 0 2
2054: ARRAY
2055: PPUSH
2056: CALL_OW 257
2060: PUSH
2061: LD_INT 3
2063: EQUAL
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 58
2077: PUSH
2078: EMPTY
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 69
2089: AND
2090: IFFALSE 2138
// PlaceHumanInUnit ( team [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) [ 1 ] ) else
2092: LD_VAR 0 5
2096: PUSH
2097: LD_VAR 0 2
2101: ARRAY
2102: PPUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 3
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 58
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 69
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: CALL_OW 52
2136: GO 2159
// PlaceUnitArea ( team [ i ] , rus_spawn , false ) ;
2138: LD_VAR 0 5
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 49
2159: GO 2042
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 1
2167: RET
// every 0 0$10 trigger depot_rdy do var i , un , l , driver ;
2168: LD_EXP 6
2172: IFFALSE 2542
2174: GO 2176
2176: DISABLE
2177: LD_INT 0
2179: PPUSH
2180: PPUSH
2181: PPUSH
2182: PPUSH
// begin Wait ( 0 0$07 ) ;
2183: LD_INT 245
2185: PPUSH
2186: CALL_OW 67
// l := 0 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// repeat begin uc_side := 6 ;
2198: LD_ADDR_OWVAR 20
2202: PUSH
2203: LD_INT 6
2205: ST_TO_ADDR
// uc_nation := 3 ;
2206: LD_ADDR_OWVAR 21
2210: PUSH
2211: LD_INT 3
2213: ST_TO_ADDR
// CreateVehicleWithDriver ( ru_medium_tracked , engine_combustion , ru_cargo_bay , rus_cr_spawn , 5 , Rand ( 3 , 6 ) ) ;
2214: LD_INT 22
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: LD_INT 51
2222: PPUSH
2223: LD_INT 5
2225: PPUSH
2226: LD_INT 5
2228: PPUSH
2229: LD_INT 3
2231: PPUSH
2232: LD_INT 6
2234: PPUSH
2235: CALL_OW 12
2239: PPUSH
2240: CALL 1297 0 6
// un := FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) [ 1 ] ;
2244: LD_ADDR_VAR 0 2
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 6
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 34
2261: PUSH
2262: LD_INT 51
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: PPUSH
2273: CALL_OW 69
2277: PUSH
2278: LD_INT 1
2280: ARRAY
2281: ST_TO_ADDR
// SetCargo ( un , mat_cans , 100 ) ;
2282: LD_VAR 0 2
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 100
2292: PPUSH
2293: CALL_OW 290
// ComMoveXY ( un , dep_x + 2 , dep_y ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_EXP 7
2306: PUSH
2307: LD_INT 2
2309: PLUS
2310: PPUSH
2311: LD_EXP 8
2315: PPUSH
2316: CALL_OW 111
// AddComUnload ( un ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: CALL_OW 219
// if ( l = 0 ) then
2329: LD_VAR 0 3
2333: PUSH
2334: LD_INT 0
2336: EQUAL
2337: IFFALSE 2373
// begin Wait ( 0 0$03 ) ;
2339: LD_INT 105
2341: PPUSH
2342: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: CALL_OW 311
2360: ST_TO_ADDR
// Say ( driver , Dtran ) ;
2361: LD_VAR 0 4
2365: PPUSH
2366: LD_STRING Dtran
2368: PPUSH
2369: CALL_OW 88
// end ; if ( l = [ 7 , 6 , 5 ] [ dif ] - 1 ) then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 7
2380: PUSH
2381: LD_INT 6
2383: PUSH
2384: LD_INT 5
2386: PUSH
2387: EMPTY
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_EXP 1
2396: ARRAY
2397: PUSH
2398: LD_INT 1
2400: MINUS
2401: EQUAL
2402: IFFALSE 2438
// begin Wait ( 0 0$03 ) ;
2404: LD_INT 105
2406: PPUSH
2407: CALL_OW 67
// driver := IsDrivenBy ( un ) ;
2411: LD_ADDR_VAR 0 4
2415: PUSH
2416: LD_VAR 0 2
2420: PPUSH
2421: CALL_OW 311
2425: ST_TO_ADDR
// Say ( driver , Dtrans ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_STRING Dtrans
2433: PPUSH
2434: CALL_OW 88
// end ; while ( not IsInArea ( un , rus_exit ) ) do
2438: LD_VAR 0 2
2442: PPUSH
2443: LD_INT 6
2445: PPUSH
2446: CALL_OW 308
2450: NOT
2451: IFFALSE 2477
// begin Wait ( 0 0$01 ) ;
2453: LD_INT 35
2455: PPUSH
2456: CALL_OW 67
// AddComMoveXY ( un , 69 , 97 ) ;
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 69
2467: PPUSH
2468: LD_INT 97
2470: PPUSH
2471: CALL_OW 171
// end ;
2475: GO 2438
// RemoveUnit ( un ) ;
2477: LD_VAR 0 2
2481: PPUSH
2482: CALL_OW 64
// l = l + 1 ;
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 3
2495: PUSH
2496: LD_INT 1
2498: PLUS
2499: ST_TO_ADDR
// Wait ( Rand ( 0 0$33 , 2 2$33 ) ) ;
2500: LD_INT 1155
2502: PPUSH
2503: LD_INT 5355
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: CALL_OW 67
// end until l = [ 7 , 6 , 5 ] [ dif ] ;
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: LD_INT 6
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: LD_EXP 1
2538: ARRAY
2539: EQUAL
2540: IFFALSE 2198
// end ; end_of_file
2542: PPOPN 4
2544: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_bazooka and event_rocket = false then
2545: LD_VAR 0 1
2549: PUSH
2550: LD_INT 44
2552: EQUAL
2553: PUSH
2554: LD_EXP 20
2558: PUSH
2559: LD_INT 0
2561: EQUAL
2562: AND
2563: IFFALSE 2709
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
2565: LD_INT 22
2567: PUSH
2568: LD_INT 3
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 25
2577: PUSH
2578: LD_INT 4
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: PUSH
2594: LD_INT 0
2596: GREATER
2597: IFFALSE 2709
// begin event_rocket := true ;
2599: LD_ADDR_EXP 20
2603: PUSH
2604: LD_INT 1
2606: ST_TO_ADDR
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) > 0 then
2607: LD_INT 22
2609: PUSH
2610: LD_INT 3
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 4
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: LD_INT 26
2629: PUSH
2630: LD_INT 1
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: PPUSH
2645: CALL_OW 69
2649: PUSH
2650: LD_INT 0
2652: GREATER
2653: IFFALSE 2709
// Say ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ] ) [ 1 ] , Dsci2 ) ;
2655: LD_INT 22
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 25
2667: PUSH
2668: LD_INT 4
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 1
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: PPUSH
2693: CALL_OW 69
2697: PUSH
2698: LD_INT 1
2700: ARRAY
2701: PPUSH
2702: LD_STRING Dsci2
2704: PPUSH
2705: CALL_OW 88
// end ; end ;
2709: PPOPN 2
2711: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and GetControl ( un ) = control_computer then
2712: LD_VAR 0 1
2716: PPUSH
2717: CALL_OW 255
2721: PUSH
2722: LD_INT 3
2724: EQUAL
2725: PUSH
2726: LD_VAR 0 1
2730: PPUSH
2731: CALL_OW 263
2735: PUSH
2736: LD_INT 3
2738: EQUAL
2739: AND
2740: IFFALSE 2750
// comp_tested := true ;
2742: LD_ADDR_EXP 22
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// end ;
2750: PPOPN 2
2752: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
2753: LD_VAR 0 1
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PPUSH
2782: CALL_OW 69
2786: IN
2787: IFFALSE 2865
// if attacked = false and sikorski_ar = false then
2789: LD_EXP 15
2793: PUSH
2794: LD_INT 0
2796: EQUAL
2797: PUSH
2798: LD_EXP 12
2802: PUSH
2803: LD_INT 0
2805: EQUAL
2806: AND
2807: IFFALSE 2865
// begin attacked := true ;
2809: LD_ADDR_EXP 15
2813: PUSH
2814: LD_INT 1
2816: ST_TO_ADDR
// if IsInUnit ( donald ) then
2817: LD_EXP 13
2821: PPUSH
2822: CALL_OW 310
2826: IFFALSE 2842
// SayRadio ( donald , DGammaF ) else
2828: LD_EXP 13
2832: PPUSH
2833: LD_STRING DGammaF
2835: PPUSH
2836: CALL_OW 94
2840: GO 2865
// if IsInUnit ( van ) then
2842: LD_EXP 14
2846: PPUSH
2847: CALL_OW 310
2851: IFFALSE 2865
// SayRadio ( van , DGammaM ) ;
2853: LD_EXP 14
2857: PPUSH
2858: LD_STRING DGammaM
2860: PPUSH
2861: CALL_OW 94
// end ; if un in FilterAllUnits ( [ f_control , control_remote ] ) then
2865: LD_VAR 0 1
2869: PUSH
2870: LD_INT 33
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: IN
2885: IFFALSE 2896
// ComUnlink ( un ) ;
2887: LD_VAR 0 1
2891: PPUSH
2892: CALL_OW 136
// end ;
2896: PPOPN 1
2898: END
// on ApemanTamed ( ape , sci ) do begin if GetSex ( sci ) = sex_male then
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 258
2908: PUSH
2909: LD_INT 1
2911: EQUAL
2912: IFFALSE 2926
// Say ( sci , Dsci3 ) ;
2914: LD_VAR 0 2
2918: PPUSH
2919: LD_STRING Dsci3
2921: PPUSH
2922: CALL_OW 88
// end ;
2926: PPOPN 2
2928: END
// on BuildingComplete ( b ) do var i ;
2929: LD_INT 0
2931: PPUSH
// begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 and depot_rdy = false then
2932: LD_VAR 0 1
2936: PPUSH
2937: CALL_OW 266
2941: PUSH
2942: LD_INT 0
2944: EQUAL
2945: PUSH
2946: LD_VAR 0 1
2950: PPUSH
2951: CALL_OW 255
2955: PUSH
2956: LD_INT 3
2958: EQUAL
2959: AND
2960: PUSH
2961: LD_EXP 6
2965: PUSH
2966: LD_INT 0
2968: EQUAL
2969: AND
2970: IFFALSE 3034
// begin SetBName ( b , kalinin ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_STRING kalinin
2979: PPUSH
2980: CALL_OW 500
// dep_x := GetX ( b ) ;
2984: LD_ADDR_EXP 7
2988: PUSH
2989: LD_VAR 0 1
2993: PPUSH
2994: CALL_OW 250
2998: ST_TO_ADDR
// dep_y := GetY ( b ) ;
2999: LD_ADDR_EXP 8
3003: PUSH
3004: LD_VAR 0 1
3008: PPUSH
3009: CALL_OW 251
3013: ST_TO_ADDR
// depot_rdy := true ;
3014: LD_ADDR_EXP 6
3018: PUSH
3019: LD_INT 1
3021: ST_TO_ADDR
// SayRadio ( popov , Dpop3 ) ;
3022: LD_EXP 2
3026: PPUSH
3027: LD_STRING Dpop3
3029: PPUSH
3030: CALL_OW 94
// end ; if GetBType ( b ) = b_lab and GetSide ( b ) = 3 and event_comp = false then
3034: LD_VAR 0 1
3038: PPUSH
3039: CALL_OW 266
3043: PUSH
3044: LD_INT 6
3046: EQUAL
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 255
3057: PUSH
3058: LD_INT 3
3060: EQUAL
3061: AND
3062: PUSH
3063: LD_EXP 21
3067: PUSH
3068: LD_INT 0
3070: EQUAL
3071: AND
3072: IFFALSE 3167
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) > 0 then
3074: LD_INT 22
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 25
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PUSH
3103: LD_INT 0
3105: GREATER
3106: IFFALSE 3167
// begin event_comp := true ;
3108: LD_ADDR_EXP 21
3112: PUSH
3113: LD_INT 1
3115: ST_TO_ADDR
// Say ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , Dsci1 ) ;
3116: LD_INT 22
3118: PUSH
3119: LD_INT 3
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 25
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 26
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PPUSH
3151: CALL_OW 69
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_STRING Dsci1
3162: PPUSH
3163: CALL_OW 88
// end ; if GetBType ( b ) = b_bunker and GetSide ( b ) = 1 then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 266
3176: PUSH
3177: LD_INT 32
3179: EQUAL
3180: PUSH
3181: LD_VAR 0 1
3185: PPUSH
3186: CALL_OW 255
3190: PUSH
3191: LD_INT 1
3193: EQUAL
3194: AND
3195: IFFALSE 3260
// begin RaiseSailEvent ( 6 ) ;
3197: LD_INT 6
3199: PPUSH
3200: CALL_OW 427
// AddComPlaceWeapon ( b , gamma_towers [ 4 ] ) ;
3204: LD_VAR 0 1
3208: PPUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_INT 4
3216: ARRAY
3217: PPUSH
3218: CALL_OW 208
// for i = 1 to 4 do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 4
3234: PUSH
3235: FOR_TO
3236: IFFALSE 3258
// gamma_towers := Delete ( gamma_towers , 1 ) ;
3238: LD_ADDR_EXP 18
3242: PUSH
3243: LD_EXP 18
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: CALL_OW 3
3255: ST_TO_ADDR
3256: GO 3235
3258: POP
3259: POP
// end ; end ;
3260: PPOPN 2
3262: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
3263: LD_VAR 0 1
3267: PPUSH
3268: CALL 20567 0 1
// if un in Patrol then
3272: LD_VAR 0 1
3276: PUSH
3277: LD_EXP 17
3281: IN
3282: IFFALSE 3300
// Patrol := Patrol diff un ;
3284: LD_ADDR_EXP 17
3288: PUSH
3289: LD_EXP 17
3293: PUSH
3294: LD_VAR 0 1
3298: DIFF
3299: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
3300: LD_VAR 0 1
3304: PUSH
3305: LD_INT 22
3307: PUSH
3308: LD_INT 1
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 30
3317: PUSH
3318: LD_INT 32
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: PPUSH
3329: CALL_OW 69
3333: IN
3334: IFFALSE 3420
// begin gamma_towers := gamma_towers ^ GetX ( un ) ;
3336: LD_ADDR_EXP 18
3340: PUSH
3341: LD_EXP 18
3345: PUSH
3346: LD_VAR 0 1
3350: PPUSH
3351: CALL_OW 250
3355: ADD
3356: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetY ( un ) ;
3357: LD_ADDR_EXP 18
3361: PUSH
3362: LD_EXP 18
3366: PUSH
3367: LD_VAR 0 1
3371: PPUSH
3372: CALL_OW 251
3376: ADD
3377: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetDir ( un ) ;
3378: LD_ADDR_EXP 18
3382: PUSH
3383: LD_EXP 18
3387: PUSH
3388: LD_VAR 0 1
3392: PPUSH
3393: CALL_OW 254
3397: ADD
3398: ST_TO_ADDR
// gamma_towers := gamma_towers ^ GetBWeapon ( un ) ;
3399: LD_ADDR_EXP 18
3403: PUSH
3404: LD_EXP 18
3408: PUSH
3409: LD_VAR 0 1
3413: PPUSH
3414: CALL_OW 269
3418: ADD
3419: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) then
3420: LD_VAR 0 1
3424: PUSH
3425: LD_INT 33
3427: PUSH
3428: LD_INT 2
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 3
3437: PUSH
3438: LD_INT 34
3440: PUSH
3441: LD_INT 13
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: PUSH
3452: EMPTY
3453: LIST
3454: LIST
3455: PPUSH
3456: CALL_OW 69
3460: IN
3461: IFFALSE 3477
// new_veh := new_veh + 1 ;
3463: LD_ADDR_EXP 19
3467: PUSH
3468: LD_EXP 19
3472: PUSH
3473: LD_INT 1
3475: PLUS
3476: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_weapon , us_crane ] ) then
3477: LD_VAR 0 1
3481: PUSH
3482: LD_INT 34
3484: PUSH
3485: LD_INT 13
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PPUSH
3492: CALL_OW 69
3496: IN
3497: IFFALSE 3518
// AddComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
3499: LD_INT 26
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: LD_INT 2
3507: PPUSH
3508: LD_INT 2
3510: PPUSH
3511: LD_INT 13
3513: PPUSH
3514: CALL_OW 185
// if un = am_dep then
3518: LD_VAR 0 1
3522: PUSH
3523: LD_INT 25
3525: EQUAL
3526: IFFALSE 3694
// begin SayRadio ( Platonov , DPlat ) ;
3528: LD_EXP 4
3532: PPUSH
3533: LD_STRING DPlat
3535: PPUSH
3536: CALL_OW 94
// if timer <= 30 30$00 then
3540: LD_EXP 24
3544: PUSH
3545: LD_INT 63000
3547: LESSEQUAL
3548: IFFALSE 3562
// AddMedal ( gamma_med3 , 1 ) else
3550: LD_STRING gamma_med3
3552: PPUSH
3553: LD_INT 1
3555: PPUSH
3556: CALL_OW 101
3560: GO 3612
// if timer <= [ 50 50$00 , 42 42$00 , 35 35$00 ] [ dif ] then
3562: LD_EXP 24
3566: PUSH
3567: LD_INT 105000
3569: PUSH
3570: LD_INT 88200
3572: PUSH
3573: LD_INT 73500
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: LIST
3580: PUSH
3581: LD_EXP 1
3585: ARRAY
3586: LESSEQUAL
3587: IFFALSE 3601
// AddMedal ( gamma_med3 , 2 ) else
3589: LD_STRING gamma_med3
3591: PPUSH
3592: LD_INT 2
3594: PPUSH
3595: CALL_OW 101
3599: GO 3612
// AddMedal ( gamma_med3 , - 1 ) ;
3601: LD_STRING gamma_med3
3603: PPUSH
3604: LD_INT 1
3606: NEG
3607: PPUSH
3608: CALL_OW 101
// if not comp_tested then
3612: LD_EXP 22
3616: NOT
3617: IFFALSE 3632
// AddMedal ( gamma_med2 , - 1 ) else
3619: LD_STRING gamma_med2
3621: PPUSH
3622: LD_INT 1
3624: NEG
3625: PPUSH
3626: CALL_OW 101
3630: GO 3642
// AddMedal ( gamma_med2 , 1 ) ;
3632: LD_STRING gamma_med2
3634: PPUSH
3635: LD_INT 1
3637: PPUSH
3638: CALL_OW 101
// if IsDead ( sikorski ) and not sikorski_run then
3642: LD_EXP 9
3646: PPUSH
3647: CALL_OW 301
3651: PUSH
3652: LD_EXP 23
3656: NOT
3657: AND
3658: IFFALSE 3672
// AddMedal ( gamma_med1 , 1 ) else
3660: LD_STRING gamma_med1
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 101
3670: GO 3683
// AddMedal ( gamma_med1 , - 1 ) ;
3672: LD_STRING gamma_med1
3674: PPUSH
3675: LD_INT 1
3677: NEG
3678: PPUSH
3679: CALL_OW 101
// GiveMedals ( GAMMA_MEDALS ) ;
3683: LD_STRING GAMMA_MEDALS
3685: PPUSH
3686: CALL_OW 102
// YouWin ;
3690: CALL_OW 103
// end ; if un = commander then
3694: LD_VAR 0 1
3698: PUSH
3699: LD_EXP 3
3703: EQUAL
3704: IFFALSE 3713
// YouLost ( comml ) ;
3706: LD_STRING comml
3708: PPUSH
3709: CALL_OW 104
// if un = sikorski then
3713: LD_VAR 0 1
3717: PUSH
3718: LD_EXP 9
3722: EQUAL
3723: IFFALSE 3735
// AddMedal ( gamma_med1 , 1 ) ;
3725: LD_STRING gamma_med1
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 101
// end ;
3735: PPOPN 1
3737: END
// on SailEvent ( event ) do var i , un , filter , doc , bac , place , engs , crane , b ;
3738: LD_INT 0
3740: PPUSH
3741: PPUSH
3742: PPUSH
3743: PPUSH
3744: PPUSH
3745: PPUSH
3746: PPUSH
3747: PPUSH
3748: PPUSH
// begin if event = 1 then
3749: LD_VAR 0 1
3753: PUSH
3754: LD_INT 1
3756: EQUAL
3757: IFFALSE 4054
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3759: LD_ADDR_VAR 0 4
3763: PUSH
3764: LD_INT 22
3766: PUSH
3767: LD_INT 1
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 21
3776: PUSH
3777: LD_INT 3
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 3
3786: PUSH
3787: LD_INT 24
3789: PUSH
3790: LD_INT 1000
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: LIST
3805: PPUSH
3806: CALL_OW 69
3810: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ] ) ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 1
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 25
3828: PUSH
3829: LD_INT 2
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: LD_INT 24
3838: PUSH
3839: LD_INT 1000
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: EMPTY
3852: LIST
3853: PPUSH
3854: CALL_OW 69
3858: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_crane ] ] ) ;
3859: LD_ADDR_VAR 0 9
3863: PUSH
3864: LD_INT 22
3866: PUSH
3867: LD_INT 1
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 34
3876: PUSH
3877: LD_INT 13
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 69
3892: ST_TO_ADDR
// if engs > 0 then
3893: LD_VAR 0 8
3897: PUSH
3898: LD_INT 0
3900: GREATER
3901: IFFALSE 4006
// for i = 1 to engs do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_VAR 0 8
3917: PUSH
3918: FOR_TO
3919: IFFALSE 4004
// begin if IsInUnit ( engs [ i ] ) then
3921: LD_VAR 0 8
3925: PUSH
3926: LD_VAR 0 2
3930: ARRAY
3931: PPUSH
3932: CALL_OW 310
3936: IFFALSE 3953
// ComExitBuilding ( engs [ i ] ) ;
3938: LD_VAR 0 8
3942: PUSH
3943: LD_VAR 0 2
3947: ARRAY
3948: PPUSH
3949: CALL_OW 122
// Wait ( 0 0$0.2 ) ;
3953: LD_INT 7
3955: PPUSH
3956: CALL_OW 67
// if not HasTask ( engs [ i ] ) then
3960: LD_VAR 0 8
3964: PUSH
3965: LD_VAR 0 2
3969: ARRAY
3970: PPUSH
3971: CALL_OW 314
3975: NOT
3976: IFFALSE 4002
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
3978: LD_VAR 0 8
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: PPUSH
3989: LD_VAR 0 4
3993: PUSH
3994: LD_INT 1
3996: ARRAY
3997: PPUSH
3998: CALL_OW 130
// end ;
4002: GO 3918
4004: POP
4005: POP
// if crane > 0 then
4006: LD_VAR 0 9
4010: PUSH
4011: LD_INT 0
4013: GREATER
4014: IFFALSE 4054
// if not HasTask ( crane [ 1 ] ) then
4016: LD_VAR 0 9
4020: PUSH
4021: LD_INT 1
4023: ARRAY
4024: PPUSH
4025: CALL_OW 314
4029: NOT
4030: IFFALSE 4054
// ComRepairBuilding ( crane [ 1 ] , filter [ 1 ] ) ;
4032: LD_VAR 0 9
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_VAR 0 4
4045: PUSH
4046: LD_INT 1
4048: ARRAY
4049: PPUSH
4050: CALL_OW 130
// end ; if event = 2 then
4054: LD_VAR 0 1
4058: PUSH
4059: LD_INT 2
4061: EQUAL
4062: IFFALSE 4184
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4064: LD_ADDR_VAR 0 8
4068: PUSH
4069: LD_INT 22
4071: PUSH
4072: LD_INT 1
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PUSH
4079: LD_INT 25
4081: PUSH
4082: LD_INT 2
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: PUSH
4089: EMPTY
4090: LIST
4091: LIST
4092: PPUSH
4093: CALL_OW 69
4097: ST_TO_ADDR
// if engs > 0 then
4098: LD_VAR 0 8
4102: PUSH
4103: LD_INT 0
4105: GREATER
4106: IFFALSE 4184
// for i = 1 to engs do
4108: LD_ADDR_VAR 0 2
4112: PUSH
4113: DOUBLE
4114: LD_INT 1
4116: DEC
4117: ST_TO_ADDR
4118: LD_VAR 0 8
4122: PUSH
4123: FOR_TO
4124: IFFALSE 4182
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
4126: LD_VAR 0 8
4130: PUSH
4131: LD_VAR 0 2
4135: ARRAY
4136: PPUSH
4137: CALL_OW 314
4141: NOT
4142: PUSH
4143: LD_VAR 0 8
4147: PUSH
4148: LD_VAR 0 2
4152: ARRAY
4153: PPUSH
4154: CALL_OW 310
4158: NOT
4159: AND
4160: IFFALSE 4180
// ComEnterUnit ( engs [ i ] , am_dep ) ;
4162: LD_VAR 0 8
4166: PUSH
4167: LD_VAR 0 2
4171: ARRAY
4172: PPUSH
4173: LD_INT 25
4175: PPUSH
4176: CALL_OW 120
4180: GO 4123
4182: POP
4183: POP
// end ; if event = 3 then
4184: LD_VAR 0 1
4188: PUSH
4189: LD_INT 3
4191: EQUAL
4192: IFFALSE 4556
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 4 ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
4194: LD_ADDR_VAR 0 4
4198: PUSH
4199: LD_INT 22
4201: PUSH
4202: LD_INT 1
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PUSH
4209: LD_INT 21
4211: PUSH
4212: LD_INT 1
4214: PUSH
4215: EMPTY
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 3
4221: PUSH
4222: LD_INT 25
4224: PUSH
4225: LD_INT 4
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 3
4238: PUSH
4239: LD_INT 24
4241: PUSH
4242: LD_INT 800
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: PPUSH
4262: CALL_OW 69
4266: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
4267: LD_ADDR_VAR 0 5
4271: PUSH
4272: LD_INT 22
4274: PUSH
4275: LD_INT 1
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 25
4284: PUSH
4285: LD_INT 4
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PPUSH
4296: CALL_OW 69
4300: ST_TO_ADDR
// if filter > 0 then
4301: LD_VAR 0 4
4305: PUSH
4306: LD_INT 0
4308: GREATER
4309: IFFALSE 4498
// begin for i = 1 to doc do
4311: LD_ADDR_VAR 0 2
4315: PUSH
4316: DOUBLE
4317: LD_INT 1
4319: DEC
4320: ST_TO_ADDR
4321: LD_VAR 0 5
4325: PUSH
4326: FOR_TO
4327: IFFALSE 4427
// begin if IsInUnit ( doc [ i ] ) then
4329: LD_VAR 0 5
4333: PUSH
4334: LD_VAR 0 2
4338: ARRAY
4339: PPUSH
4340: CALL_OW 310
4344: IFFALSE 4361
// ComExitBuilding ( doc [ i ] ) ;
4346: LD_VAR 0 5
4350: PUSH
4351: LD_VAR 0 2
4355: ARRAY
4356: PPUSH
4357: CALL_OW 122
// if GetDistUnits ( filter [ 1 ] , am_lab ) < 10 and not HasTask ( doc [ i ] ) then
4361: LD_VAR 0 4
4365: PUSH
4366: LD_INT 1
4368: ARRAY
4369: PPUSH
4370: LD_INT 46
4372: PPUSH
4373: CALL_OW 296
4377: PUSH
4378: LD_INT 10
4380: LESS
4381: PUSH
4382: LD_VAR 0 5
4386: PUSH
4387: LD_VAR 0 2
4391: ARRAY
4392: PPUSH
4393: CALL_OW 314
4397: NOT
4398: AND
4399: IFFALSE 4425
// ComHeal ( doc [ i ] , filter [ 1 ] ) ;
4401: LD_VAR 0 5
4405: PUSH
4406: LD_VAR 0 2
4410: ARRAY
4411: PPUSH
4412: LD_VAR 0 4
4416: PUSH
4417: LD_INT 1
4419: ARRAY
4420: PPUSH
4421: CALL_OW 128
// end ;
4425: GO 4326
4427: POP
4428: POP
// for i = 1 to filter do
4429: LD_ADDR_VAR 0 2
4433: PUSH
4434: DOUBLE
4435: LD_INT 1
4437: DEC
4438: ST_TO_ADDR
4439: LD_VAR 0 4
4443: PUSH
4444: FOR_TO
4445: IFFALSE 4494
// if GetDistUnits ( filter [ i ] , am_lab ) > 10 then
4447: LD_VAR 0 4
4451: PUSH
4452: LD_VAR 0 2
4456: ARRAY
4457: PPUSH
4458: LD_INT 46
4460: PPUSH
4461: CALL_OW 296
4465: PUSH
4466: LD_INT 10
4468: GREATER
4469: IFFALSE 4492
// ComMoveXY ( filter [ i ] , 47 , 12 ) ;
4471: LD_VAR 0 4
4475: PUSH
4476: LD_VAR 0 2
4480: ARRAY
4481: PPUSH
4482: LD_INT 47
4484: PPUSH
4485: LD_INT 12
4487: PPUSH
4488: CALL_OW 111
4492: GO 4444
4494: POP
4495: POP
// end else
4496: GO 4556
// for i = 1 to doc do
4498: LD_ADDR_VAR 0 2
4502: PUSH
4503: DOUBLE
4504: LD_INT 1
4506: DEC
4507: ST_TO_ADDR
4508: LD_VAR 0 5
4512: PUSH
4513: FOR_TO
4514: IFFALSE 4554
// if not IsInUnit ( doc [ i ] ) then
4516: LD_VAR 0 5
4520: PUSH
4521: LD_VAR 0 2
4525: ARRAY
4526: PPUSH
4527: CALL_OW 310
4531: NOT
4532: IFFALSE 4552
// ComEnterUnit ( doc [ i ] , am_lab ) ;
4534: LD_VAR 0 5
4538: PUSH
4539: LD_VAR 0 2
4543: ARRAY
4544: PPUSH
4545: LD_INT 46
4547: PPUSH
4548: CALL_OW 120
4552: GO 4513
4554: POP
4555: POP
// end ; if event = 4 then
4556: LD_VAR 0 1
4560: PUSH
4561: LD_INT 4
4563: EQUAL
4564: IFFALSE 4815
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4566: LD_ADDR_VAR 0 6
4570: PUSH
4571: LD_INT 22
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 30
4583: PUSH
4584: LD_INT 5
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PPUSH
4595: CALL_OW 69
4599: ST_TO_ADDR
// for i = 1 to bac do
4600: LD_ADDR_VAR 0 2
4604: PUSH
4605: DOUBLE
4606: LD_INT 1
4608: DEC
4609: ST_TO_ADDR
4610: LD_VAR 0 6
4614: PUSH
4615: FOR_TO
4616: IFFALSE 4657
// if UnitsInside ( bac [ i ] ) < 6 then
4618: LD_VAR 0 6
4622: PUSH
4623: LD_VAR 0 2
4627: ARRAY
4628: PPUSH
4629: CALL_OW 313
4633: PUSH
4634: LD_INT 6
4636: LESS
4637: IFFALSE 4655
// place := bac [ i ] ;
4639: LD_ADDR_VAR 0 7
4643: PUSH
4644: LD_VAR 0 6
4648: PUSH
4649: LD_VAR 0 2
4653: ARRAY
4654: ST_TO_ADDR
4655: GO 4615
4657: POP
4658: POP
// if place then
4659: LD_VAR 0 7
4663: IFFALSE 4815
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] ] , [ f_lives , 1000 ] ] ] ) diff Patrol ;
4665: LD_ADDR_VAR 0 4
4669: PUSH
4670: LD_INT 22
4672: PUSH
4673: LD_INT 1
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: LD_INT 2
4682: PUSH
4683: LD_INT 25
4685: PUSH
4686: LD_INT 1
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PUSH
4693: LD_INT 25
4695: PUSH
4696: LD_INT 5
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: LIST
4707: PUSH
4708: LD_INT 24
4710: PUSH
4711: LD_INT 1000
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: PPUSH
4726: CALL_OW 69
4730: PUSH
4731: LD_EXP 17
4735: DIFF
4736: ST_TO_ADDR
// for i = 1 to filter do
4737: LD_ADDR_VAR 0 2
4741: PUSH
4742: DOUBLE
4743: LD_INT 1
4745: DEC
4746: ST_TO_ADDR
4747: LD_VAR 0 4
4751: PUSH
4752: FOR_TO
4753: IFFALSE 4813
// if not IsInUnit ( filter [ i ] ) and not HasTask ( filter [ i ] ) then
4755: LD_VAR 0 4
4759: PUSH
4760: LD_VAR 0 2
4764: ARRAY
4765: PPUSH
4766: CALL_OW 310
4770: NOT
4771: PUSH
4772: LD_VAR 0 4
4776: PUSH
4777: LD_VAR 0 2
4781: ARRAY
4782: PPUSH
4783: CALL_OW 314
4787: NOT
4788: AND
4789: IFFALSE 4811
// ComEnterUnit ( filter [ i ] , place ) ;
4791: LD_VAR 0 4
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PPUSH
4802: LD_VAR 0 7
4806: PPUSH
4807: CALL_OW 120
4811: GO 4752
4813: POP
4814: POP
// end ; end ; if event = 5 then
4815: LD_VAR 0 1
4819: PUSH
4820: LD_INT 5
4822: EQUAL
4823: IFFALSE 4977
// begin if FilterUnitsInArea ( am_sec , [ f_enemy , 1 ] ) = 0 then
4825: LD_INT 12
4827: PPUSH
4828: LD_INT 81
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PPUSH
4838: CALL_OW 70
4842: PUSH
4843: LD_INT 0
4845: EQUAL
4846: IFFALSE 4977
// begin engs := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
4848: LD_ADDR_VAR 0 8
4852: PUSH
4853: LD_INT 22
4855: PUSH
4856: LD_INT 1
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: PUSH
4863: LD_INT 25
4865: PUSH
4866: LD_INT 2
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: EMPTY
4874: LIST
4875: LIST
4876: PPUSH
4877: CALL_OW 69
4881: ST_TO_ADDR
// if engs > 0 then
4882: LD_VAR 0 8
4886: PUSH
4887: LD_INT 0
4889: GREATER
4890: IFFALSE 4977
// for i = 1 to engs do
4892: LD_ADDR_VAR 0 2
4896: PUSH
4897: DOUBLE
4898: LD_INT 1
4900: DEC
4901: ST_TO_ADDR
4902: LD_VAR 0 8
4906: PUSH
4907: FOR_TO
4908: IFFALSE 4975
// if not HasTask ( engs [ i ] ) then
4910: LD_VAR 0 8
4914: PUSH
4915: LD_VAR 0 2
4919: ARRAY
4920: PPUSH
4921: CALL_OW 314
4925: NOT
4926: IFFALSE 4973
// ComBuild ( engs [ i ] , b_bunker , gamma_towers [ 1 ] , gamma_towers [ 2 ] , gamma_towers [ 3 ] ) ;
4928: LD_VAR 0 8
4932: PUSH
4933: LD_VAR 0 2
4937: ARRAY
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_EXP 18
4946: PUSH
4947: LD_INT 1
4949: ARRAY
4950: PPUSH
4951: LD_EXP 18
4955: PUSH
4956: LD_INT 2
4958: ARRAY
4959: PPUSH
4960: LD_EXP 18
4964: PUSH
4965: LD_INT 3
4967: ARRAY
4968: PPUSH
4969: CALL_OW 145
4973: GO 4907
4975: POP
4976: POP
// end ; end ; if event = 6 then
4977: LD_VAR 0 1
4981: PUSH
4982: LD_INT 6
4984: EQUAL
4985: IFFALSE 5169
// begin bac := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) ;
4987: LD_ADDR_VAR 0 6
4991: PUSH
4992: LD_INT 22
4994: PUSH
4995: LD_INT 1
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: PUSH
5002: LD_INT 30
5004: PUSH
5005: LD_INT 5
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: PUSH
5012: EMPTY
5013: LIST
5014: LIST
5015: PPUSH
5016: CALL_OW 69
5020: ST_TO_ADDR
// if bac and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) > 0 then
5021: LD_VAR 0 6
5025: PUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 1
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 30
5038: PUSH
5039: LD_INT 32
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 58
5048: PUSH
5049: EMPTY
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: PPUSH
5060: CALL_OW 69
5064: PUSH
5065: LD_INT 0
5067: GREATER
5068: AND
5069: IFFALSE 5169
// begin b := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) [ 1 ] ;
5071: LD_ADDR_VAR 0 10
5075: PUSH
5076: LD_INT 22
5078: PUSH
5079: LD_INT 1
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: PUSH
5086: LD_INT 30
5088: PUSH
5089: LD_INT 32
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: PUSH
5096: LD_INT 58
5098: PUSH
5099: EMPTY
5100: LIST
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: LIST
5106: PUSH
5107: EMPTY
5108: LIST
5109: PPUSH
5110: CALL_OW 69
5114: PUSH
5115: LD_INT 1
5117: ARRAY
5118: ST_TO_ADDR
// un := UnitsInside ( bac [ 1 ] ) ;
5119: LD_ADDR_VAR 0 3
5123: PUSH
5124: LD_VAR 0 6
5128: PUSH
5129: LD_INT 1
5131: ARRAY
5132: PPUSH
5133: CALL_OW 313
5137: ST_TO_ADDR
// ComExitBuilding ( un [ 1 ] ) ;
5138: LD_VAR 0 3
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 122
// AddComEnterUnit ( un [ 1 ] , b ) ;
5151: LD_VAR 0 3
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PPUSH
5160: LD_VAR 0 10
5164: PPUSH
5165: CALL_OW 180
// end ; end ; end ;
5169: PPOPN 10
5171: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 3 then
5172: LD_VAR 0 1
5176: PUSH
5177: LD_INT 1
5179: EQUAL
5180: PUSH
5181: LD_VAR 0 2
5185: PUSH
5186: LD_INT 3
5188: EQUAL
5189: AND
5190: IFFALSE 5200
// contact_am := true ;
5192: LD_ADDR_EXP 16
5196: PUSH
5197: LD_INT 1
5199: ST_TO_ADDR
// end ;
5200: PPOPN 2
5202: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5203: LD_VAR 0 1
5207: PPUSH
5208: LD_VAR 0 2
5212: PPUSH
5213: LD_VAR 0 3
5217: PPUSH
5218: CALL 20665 0 3
// end ;
5222: PPOPN 3
5224: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5225: LD_VAR 0 1
5229: PPUSH
5230: CALL 20673 0 1
// end ; end_of_file
5234: PPOPN 1
5236: END
// export Sikorski , Game_Started , SForce , Sikorski_Ar , Donald , Van , attacked , contact_am ; export patrol ; export gamma_towers ; export function PrepareAmerican ; var i , un , b , skill , weapons , sol , lw ; begin
5237: LD_INT 0
5239: PPUSH
5240: PPUSH
5241: PPUSH
5242: PPUSH
5243: PPUSH
5244: PPUSH
5245: PPUSH
5246: PPUSH
// skill := [ 5 , 6 , 7 ] [ dif ] ;
5247: LD_ADDR_VAR 0 5
5251: PUSH
5252: LD_INT 5
5254: PUSH
5255: LD_INT 6
5257: PUSH
5258: LD_INT 7
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: PUSH
5266: LD_EXP 1
5270: ARRAY
5271: ST_TO_ADDR
// weapons := [ us_gatling_gun , us_gatling_gun , us_gatling_gun , us_double_gun , us_double_gun , us_double_gun , us_heavy_gun ] ;
5272: LD_ADDR_VAR 0 6
5276: PUSH
5277: LD_INT 4
5279: PUSH
5280: LD_INT 4
5282: PUSH
5283: LD_INT 4
5285: PUSH
5286: LD_INT 5
5288: PUSH
5289: LD_INT 5
5291: PUSH
5292: LD_INT 5
5294: PUSH
5295: LD_INT 6
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: ST_TO_ADDR
// SForce := [ ] ;
5307: LD_ADDR_EXP 11
5311: PUSH
5312: EMPTY
5313: ST_TO_ADDR
// Sikorski_Ar := false ;
5314: LD_ADDR_EXP 12
5318: PUSH
5319: LD_INT 0
5321: ST_TO_ADDR
// attacked := false ;
5322: LD_ADDR_EXP 15
5326: PUSH
5327: LD_INT 0
5329: ST_TO_ADDR
// contact_am := false ;
5330: LD_ADDR_EXP 16
5334: PUSH
5335: LD_INT 0
5337: ST_TO_ADDR
// patrol := [ ] ;
5338: LD_ADDR_EXP 17
5342: PUSH
5343: EMPTY
5344: ST_TO_ADDR
// gamma_towers := [ ] ;
5345: LD_ADDR_EXP 18
5349: PUSH
5350: EMPTY
5351: ST_TO_ADDR
// SetBName ( am_dep , gamma ) ;
5352: LD_INT 25
5354: PPUSH
5355: LD_STRING gamma
5357: PPUSH
5358: CALL_OW 500
// uc_side := 1 ;
5362: LD_ADDR_OWVAR 20
5366: PUSH
5367: LD_INT 1
5369: ST_TO_ADDR
// uc_nation := 1 ;
5370: LD_ADDR_OWVAR 21
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// hc_importance := 0 ;
5378: LD_ADDR_OWVAR 32
5382: PUSH
5383: LD_INT 0
5385: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
5386: LD_ADDR_OWVAR 26
5390: PUSH
5391: LD_STRING Jeremy Sikorski
5393: ST_TO_ADDR
// hc_gallery := us ;
5394: LD_ADDR_OWVAR 33
5398: PUSH
5399: LD_STRING us
5401: ST_TO_ADDR
// hc_face_number := 19 ;
5402: LD_ADDR_OWVAR 34
5406: PUSH
5407: LD_INT 19
5409: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 4 , 6 , 3 ] ;
5410: LD_ADDR_OWVAR 31
5414: PUSH
5415: LD_VAR 0 5
5419: PPUSH
5420: LD_VAR 0 5
5424: PUSH
5425: LD_INT 2
5427: PLUS
5428: PPUSH
5429: CALL_OW 12
5433: PUSH
5434: LD_INT 4
5436: PUSH
5437: LD_INT 6
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: ST_TO_ADDR
// hc_sex := sex_male ;
5449: LD_ADDR_OWVAR 27
5453: PUSH
5454: LD_INT 1
5456: ST_TO_ADDR
// hc_class := 1 ;
5457: LD_ADDR_OWVAR 28
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
5465: LD_ADDR_OWVAR 29
5469: PUSH
5470: LD_INT 10
5472: PUSH
5473: LD_INT 11
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: ST_TO_ADDR
// sikorski := CreateHuman ;
5480: LD_ADDR_EXP 9
5484: PUSH
5485: CALL_OW 44
5489: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
5490: LD_ADDR_OWVAR 26
5494: PUSH
5495: LD_STRING Lucy Donaldson
5497: ST_TO_ADDR
// hc_gallery := us ;
5498: LD_ADDR_OWVAR 33
5502: PUSH
5503: LD_STRING us
5505: ST_TO_ADDR
// hc_face_number := 2 ;
5506: LD_ADDR_OWVAR 34
5510: PUSH
5511: LD_INT 2
5513: ST_TO_ADDR
// hc_skills := [ Rand ( skill , skill + 2 ) , 6 , 4 , 2 ] ;
5514: LD_ADDR_OWVAR 31
5518: PUSH
5519: LD_VAR 0 5
5523: PPUSH
5524: LD_VAR 0 5
5528: PUSH
5529: LD_INT 2
5531: PLUS
5532: PPUSH
5533: CALL_OW 12
5537: PUSH
5538: LD_INT 6
5540: PUSH
5541: LD_INT 4
5543: PUSH
5544: LD_INT 2
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: LIST
5552: ST_TO_ADDR
// hc_sex := sex_female ;
5553: LD_ADDR_OWVAR 27
5557: PUSH
5558: LD_INT 2
5560: ST_TO_ADDR
// hc_class := 1 ;
5561: LD_ADDR_OWVAR 28
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// donald := CreateHuman ;
5569: LD_ADDR_EXP 13
5573: PUSH
5574: CALL_OW 44
5578: ST_TO_ADDR
// hc_name := Peter Van Houten ;
5579: LD_ADDR_OWVAR 26
5583: PUSH
5584: LD_STRING Peter Van Houten
5586: ST_TO_ADDR
// hc_gallery := us ;
5587: LD_ADDR_OWVAR 33
5591: PUSH
5592: LD_STRING us
5594: ST_TO_ADDR
// hc_face_number := 16 ;
5595: LD_ADDR_OWVAR 34
5599: PUSH
5600: LD_INT 16
5602: ST_TO_ADDR
// hc_sex := sex_male ;
5603: LD_ADDR_OWVAR 27
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// van := CreateHuman ;
5611: LD_ADDR_EXP 14
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// hc_importance := 0 ;
5621: LD_ADDR_OWVAR 32
5625: PUSH
5626: LD_INT 0
5628: ST_TO_ADDR
// case dif of 1 :
5629: LD_EXP 1
5633: PUSH
5634: LD_INT 1
5636: DOUBLE
5637: EQUAL
5638: IFTRUE 5642
5640: GO 5653
5642: POP
// lw = 1 ; 2 :
5643: LD_ADDR_VAR 0 8
5647: PUSH
5648: LD_INT 1
5650: ST_TO_ADDR
5651: GO 5700
5653: LD_INT 2
5655: DOUBLE
5656: EQUAL
5657: IFTRUE 5661
5659: GO 5680
5661: POP
// lw = Rand ( 1 , 2 ) ; 3 :
5662: LD_ADDR_VAR 0 8
5666: PUSH
5667: LD_INT 1
5669: PPUSH
5670: LD_INT 2
5672: PPUSH
5673: CALL_OW 12
5677: ST_TO_ADDR
5678: GO 5700
5680: LD_INT 3
5682: DOUBLE
5683: EQUAL
5684: IFTRUE 5688
5686: GO 5699
5688: POP
// lw = 2 ; end ;
5689: LD_ADDR_VAR 0 8
5693: PUSH
5694: LD_INT 2
5696: ST_TO_ADDR
5697: GO 5700
5699: POP
// case lw of 1 :
5700: LD_VAR 0 8
5704: PUSH
5705: LD_INT 1
5707: DOUBLE
5708: EQUAL
5709: IFTRUE 5713
5711: GO 5728
5713: POP
// PlaceHumanInUnit ( donald , am_dep ) ; 2 :
5714: LD_EXP 13
5718: PPUSH
5719: LD_INT 25
5721: PPUSH
5722: CALL_OW 52
5726: GO 5752
5728: LD_INT 2
5730: DOUBLE
5731: EQUAL
5732: IFTRUE 5736
5734: GO 5751
5736: POP
// PlaceHumanInUnit ( van , am_dep ) ; end ;
5737: LD_EXP 14
5741: PPUSH
5742: LD_INT 25
5744: PPUSH
5745: CALL_OW 52
5749: GO 5752
5751: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
5752: LD_ADDR_VAR 0 2
5756: PUSH
5757: LD_INT 22
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 30
5769: PUSH
5770: LD_INT 32
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PPUSH
5781: CALL_OW 69
5785: PUSH
5786: FOR_IN
5787: IFFALSE 5841
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
5789: LD_INT 1
5791: PPUSH
5792: LD_VAR 0 5
5796: PPUSH
5797: CALL 734 0 2
5801: PPUSH
5802: LD_VAR 0 2
5806: PPUSH
5807: CALL_OW 52
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5811: LD_VAR 0 2
5815: PPUSH
5816: LD_VAR 0 6
5820: PUSH
5821: LD_INT 1
5823: PPUSH
5824: LD_VAR 0 6
5828: PPUSH
5829: CALL_OW 12
5833: ARRAY
5834: PPUSH
5835: CALL_OW 431
// end ;
5839: GO 5786
5841: POP
5842: POP
// sol := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_soldier ] , [ class_sniper ] ] ] ) ;
5843: LD_ADDR_VAR 0 7
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 25
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: PUSH
5871: LD_INT 5
5873: PUSH
5874: EMPTY
5875: LIST
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PPUSH
5886: CALL_OW 69
5890: ST_TO_ADDR
// for i = 1 to sol do
5891: LD_ADDR_VAR 0 2
5895: PUSH
5896: DOUBLE
5897: LD_INT 1
5899: DEC
5900: ST_TO_ADDR
5901: LD_VAR 0 7
5905: PUSH
5906: FOR_TO
5907: IFFALSE 5929
// SetTag ( sol [ i ] , 1 ) ;
5909: LD_VAR 0 7
5913: PUSH
5914: LD_VAR 0 2
5918: ARRAY
5919: PPUSH
5920: LD_INT 1
5922: PPUSH
5923: CALL_OW 109
5927: GO 5906
5929: POP
5930: POP
// for i = 1 to 3 do
5931: LD_ADDR_VAR 0 2
5935: PUSH
5936: DOUBLE
5937: LD_INT 1
5939: DEC
5940: ST_TO_ADDR
5941: LD_INT 3
5943: PUSH
5944: FOR_TO
5945: IFFALSE 5969
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_ct ) ;
5947: LD_INT 3
5949: PPUSH
5950: LD_VAR 0 5
5954: PPUSH
5955: CALL 734 0 2
5959: PPUSH
5960: LD_INT 56
5962: PPUSH
5963: CALL_OW 52
5967: GO 5944
5969: POP
5970: POP
// for i = 1 to 6 do
5971: LD_ADDR_VAR 0 2
5975: PUSH
5976: DOUBLE
5977: LD_INT 1
5979: DEC
5980: ST_TO_ADDR
5981: LD_INT 6
5983: PUSH
5984: FOR_TO
5985: IFFALSE 6009
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , am_fac ) ;
5987: LD_INT 3
5989: PPUSH
5990: LD_VAR 0 5
5994: PPUSH
5995: CALL 734 0 2
5999: PPUSH
6000: LD_INT 26
6002: PPUSH
6003: CALL_OW 52
6007: GO 5984
6009: POP
6010: POP
// for i = 1 to 5 do
6011: LD_ADDR_VAR 0 2
6015: PUSH
6016: DOUBLE
6017: LD_INT 1
6019: DEC
6020: ST_TO_ADDR
6021: LD_INT 5
6023: PUSH
6024: FOR_TO
6025: IFFALSE 6052
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , am_base , false ) ;
6027: LD_INT 2
6029: PPUSH
6030: LD_VAR 0 5
6034: PPUSH
6035: CALL 734 0 2
6039: PPUSH
6040: LD_INT 7
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 49
6050: GO 6024
6052: POP
6053: POP
// for i = 1 to 3 do
6054: LD_ADDR_VAR 0 2
6058: PUSH
6059: DOUBLE
6060: LD_INT 1
6062: DEC
6063: ST_TO_ADDR
6064: LD_INT 3
6066: PUSH
6067: FOR_TO
6068: IFFALSE 6092
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , am_lab ) ;
6070: LD_INT 4
6072: PPUSH
6073: LD_VAR 0 5
6077: PPUSH
6078: CALL 734 0 2
6082: PPUSH
6083: LD_INT 46
6085: PPUSH
6086: CALL_OW 52
6090: GO 6067
6092: POP
6093: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) do
6094: LD_ADDR_VAR 0 2
6098: PUSH
6099: LD_INT 22
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 30
6111: PUSH
6112: LD_INT 5
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 69
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6243
// begin PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6131: LD_INT 5
6133: PPUSH
6134: LD_VAR 0 5
6138: PPUSH
6139: CALL 734 0 2
6143: PPUSH
6144: LD_VAR 0 2
6148: PPUSH
6149: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( class_sniper , skill ) , i ) ;
6153: LD_INT 5
6155: PPUSH
6156: LD_VAR 0 5
6160: PPUSH
6161: CALL 734 0 2
6165: PPUSH
6166: LD_VAR 0 2
6170: PPUSH
6171: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 5
6182: PPUSH
6183: CALL 734 0 2
6187: PPUSH
6188: LD_VAR 0 2
6192: PPUSH
6193: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6197: LD_INT 1
6199: PPUSH
6200: LD_VAR 0 5
6204: PPUSH
6205: CALL 734 0 2
6209: PPUSH
6210: LD_VAR 0 2
6214: PPUSH
6215: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
6219: LD_INT 1
6221: PPUSH
6222: LD_VAR 0 5
6226: PPUSH
6227: CALL 734 0 2
6231: PPUSH
6232: LD_VAR 0 2
6236: PPUSH
6237: CALL_OW 52
// end ;
6241: GO 6128
6243: POP
6244: POP
// if dif > 1 then
6245: LD_EXP 1
6249: PUSH
6250: LD_INT 1
6252: GREATER
6253: IFFALSE 6326
// for i = 1 to ( dif - 1 ) do
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: DOUBLE
6261: LD_INT 1
6263: DEC
6264: ST_TO_ADDR
6265: LD_EXP 1
6269: PUSH
6270: LD_INT 1
6272: MINUS
6273: PUSH
6274: FOR_TO
6275: IFFALSE 6324
// begin patrol := patrol ^ CreateHumanWithClass ( 1 , skill ) ;
6277: LD_ADDR_EXP 17
6281: PUSH
6282: LD_EXP 17
6286: PUSH
6287: LD_INT 1
6289: PPUSH
6290: LD_VAR 0 5
6294: PPUSH
6295: CALL 734 0 2
6299: ADD
6300: ST_TO_ADDR
// PlaceUnitArea ( patrol [ i ] , am_west_spawn , false ) ;
6301: LD_EXP 17
6305: PUSH
6306: LD_VAR 0 2
6310: ARRAY
6311: PPUSH
6312: LD_INT 3
6314: PPUSH
6315: LD_INT 0
6317: PPUSH
6318: CALL_OW 49
// end ;
6322: GO 6274
6324: POP
6325: POP
// game_started := true ;
6326: LD_ADDR_EXP 10
6330: PUSH
6331: LD_INT 1
6333: ST_TO_ADDR
// ComConstruct ( am_fac , us_medium_tracked , engine_solar , control_remote , us_crane ) ;
6334: LD_INT 26
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_INT 2
6342: PPUSH
6343: LD_INT 2
6345: PPUSH
6346: LD_INT 13
6348: PPUSH
6349: CALL_OW 125
// while ( contact_am = false ) do
6353: LD_EXP 16
6357: PUSH
6358: LD_INT 0
6360: EQUAL
6361: IFFALSE 6372
// begin Wait ( 0 0$01 ) ;
6363: LD_INT 35
6365: PPUSH
6366: CALL_OW 67
// end ;
6370: GO 6353
// Wait ( [ 4 4$00 , 3 3$00 , 2 2$30 ] [ dif ] ) ;
6372: LD_INT 8400
6374: PUSH
6375: LD_INT 6300
6377: PUSH
6378: LD_INT 5250
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: LIST
6385: PUSH
6386: LD_EXP 1
6390: ARRAY
6391: PPUSH
6392: CALL_OW 67
// case dif of 1 :
6396: LD_EXP 1
6400: PUSH
6401: LD_INT 1
6403: DOUBLE
6404: EQUAL
6405: IFTRUE 6409
6407: GO 6584
6409: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_machine_gun , us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ) ;
6410: LD_INT 26
6412: PPUSH
6413: LD_INT 3
6415: PPUSH
6416: LD_INT 1
6418: PPUSH
6419: LD_INT 2
6421: PPUSH
6422: LD_INT 2
6424: PUSH
6425: LD_INT 4
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 5
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 1
6442: PPUSH
6443: LD_INT 4
6445: PPUSH
6446: CALL_OW 12
6450: ARRAY
6451: PPUSH
6452: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6456: LD_INT 26
6458: PPUSH
6459: LD_INT 3
6461: PPUSH
6462: LD_INT 1
6464: PPUSH
6465: LD_INT 2
6467: PPUSH
6468: LD_INT 4
6470: PUSH
6471: LD_INT 5
6473: PUSH
6474: LD_INT 5
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 1
6484: PPUSH
6485: LD_INT 3
6487: PPUSH
6488: CALL_OW 12
6492: ARRAY
6493: PPUSH
6494: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6498: LD_INT 26
6500: PPUSH
6501: LD_INT 3
6503: PPUSH
6504: LD_INT 1
6506: PPUSH
6507: LD_INT 2
6509: PPUSH
6510: LD_INT 4
6512: PUSH
6513: LD_INT 5
6515: PUSH
6516: LD_INT 5
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 1
6526: PPUSH
6527: LD_INT 3
6529: PPUSH
6530: CALL_OW 12
6534: ARRAY
6535: PPUSH
6536: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6540: LD_INT 26
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 1
6548: PPUSH
6549: LD_INT 2
6551: PPUSH
6552: LD_INT 4
6554: PUSH
6555: LD_INT 3
6557: PUSH
6558: LD_INT 5
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 1
6568: PPUSH
6569: LD_INT 3
6571: PPUSH
6572: CALL_OW 12
6576: ARRAY
6577: PPUSH
6578: CALL_OW 185
// end ; 2 :
6582: GO 7111
6584: LD_INT 2
6586: DOUBLE
6587: EQUAL
6588: IFTRUE 6592
6590: GO 6805
6592: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6593: LD_INT 26
6595: PPUSH
6596: LD_INT 3
6598: PPUSH
6599: LD_INT 1
6601: PPUSH
6602: LD_INT 2
6604: PPUSH
6605: LD_INT 4
6607: PUSH
6608: LD_INT 5
6610: PUSH
6611: LD_INT 5
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_INT 1
6621: PPUSH
6622: LD_INT 3
6624: PPUSH
6625: CALL_OW 12
6629: ARRAY
6630: PPUSH
6631: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6635: LD_INT 26
6637: PPUSH
6638: LD_INT 3
6640: PPUSH
6641: LD_INT 1
6643: PPUSH
6644: LD_INT 2
6646: PPUSH
6647: LD_INT 4
6649: PUSH
6650: LD_INT 5
6652: PUSH
6653: LD_INT 5
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_INT 1
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: CALL_OW 12
6671: ARRAY
6672: PPUSH
6673: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6677: LD_INT 26
6679: PPUSH
6680: LD_INT 3
6682: PPUSH
6683: LD_INT 1
6685: PPUSH
6686: LD_INT 2
6688: PPUSH
6689: LD_INT 4
6691: PUSH
6692: LD_INT 3
6694: PUSH
6695: LD_INT 5
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 1
6705: PPUSH
6706: LD_INT 3
6708: PPUSH
6709: CALL_OW 12
6713: ARRAY
6714: PPUSH
6715: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6719: LD_INT 26
6721: PPUSH
6722: LD_INT 4
6724: PPUSH
6725: LD_INT 1
6727: PPUSH
6728: LD_INT 2
6730: PPUSH
6731: LD_INT 4
6733: PUSH
6734: LD_INT 5
6736: PUSH
6737: LD_INT 6
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: PUSH
6745: LD_INT 1
6747: PPUSH
6748: LD_INT 3
6750: PPUSH
6751: CALL_OW 12
6755: ARRAY
6756: PPUSH
6757: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6761: LD_INT 26
6763: PPUSH
6764: LD_INT 4
6766: PPUSH
6767: LD_INT 1
6769: PPUSH
6770: LD_INT 2
6772: PPUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: LD_INT 6
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_INT 3
6792: PPUSH
6793: CALL_OW 12
6797: ARRAY
6798: PPUSH
6799: CALL_OW 185
// end ; 3 :
6803: GO 7111
6805: LD_INT 3
6807: DOUBLE
6808: EQUAL
6809: IFTRUE 6813
6811: GO 7110
6813: POP
// begin AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6814: LD_INT 26
6816: PPUSH
6817: LD_INT 3
6819: PPUSH
6820: LD_INT 1
6822: PPUSH
6823: LD_INT 2
6825: PPUSH
6826: LD_INT 4
6828: PUSH
6829: LD_INT 5
6831: PUSH
6832: LD_INT 5
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 1
6842: PPUSH
6843: LD_INT 3
6845: PPUSH
6846: CALL_OW 12
6850: ARRAY
6851: PPUSH
6852: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6856: LD_INT 26
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: LD_INT 2
6867: PPUSH
6868: LD_INT 4
6870: PUSH
6871: LD_INT 5
6873: PUSH
6874: LD_INT 5
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 1
6884: PPUSH
6885: LD_INT 3
6887: PPUSH
6888: CALL_OW 12
6892: ARRAY
6893: PPUSH
6894: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6898: LD_INT 26
6900: PPUSH
6901: LD_INT 3
6903: PPUSH
6904: LD_INT 1
6906: PPUSH
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PUSH
6913: LD_INT 5
6915: PUSH
6916: LD_INT 5
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 1
6926: PPUSH
6927: LD_INT 3
6929: PPUSH
6930: CALL_OW 12
6934: ARRAY
6935: PPUSH
6936: CALL_OW 185
// AddComConstruct ( am_fac , us_medium_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
6940: LD_INT 26
6942: PPUSH
6943: LD_INT 3
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: LD_INT 2
6951: PPUSH
6952: LD_INT 4
6954: PUSH
6955: LD_INT 5
6957: PUSH
6958: LD_INT 5
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: LD_INT 3
6971: PPUSH
6972: CALL_OW 12
6976: ARRAY
6977: PPUSH
6978: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
6982: LD_INT 26
6984: PPUSH
6985: LD_INT 4
6987: PPUSH
6988: LD_INT 1
6990: PPUSH
6991: LD_INT 2
6993: PPUSH
6994: LD_INT 4
6996: PUSH
6997: LD_INT 5
6999: PUSH
7000: LD_INT 6
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: LD_INT 1
7010: PPUSH
7011: LD_INT 3
7013: PPUSH
7014: CALL_OW 12
7018: ARRAY
7019: PPUSH
7020: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7024: LD_INT 26
7026: PPUSH
7027: LD_INT 4
7029: PPUSH
7030: LD_INT 1
7032: PPUSH
7033: LD_INT 2
7035: PPUSH
7036: LD_INT 4
7038: PUSH
7039: LD_INT 5
7041: PUSH
7042: LD_INT 6
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_INT 3
7055: PPUSH
7056: CALL_OW 12
7060: ARRAY
7061: PPUSH
7062: CALL_OW 185
// AddComConstruct ( am_fac , us_heavy_tracked , engine_combustion , control_remote , [ us_gatling_gun , us_double_gun , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ) ;
7066: LD_INT 26
7068: PPUSH
7069: LD_INT 4
7071: PPUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 2
7077: PPUSH
7078: LD_INT 4
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 6
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 1
7094: PPUSH
7095: LD_INT 3
7097: PPUSH
7098: CALL_OW 12
7102: ARRAY
7103: PPUSH
7104: CALL_OW 185
// end ; end ;
7108: GO 7111
7110: POP
// end ;
7111: LD_VAR 0 1
7115: RET
// every 0 0$01 do var i , filter ;
7116: GO 7118
7118: DISABLE
7119: LD_INT 0
7121: PPUSH
7122: PPUSH
// begin enable ;
7123: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) > 0 then
7124: LD_INT 22
7126: PUSH
7127: LD_INT 1
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 25
7136: PUSH
7137: LD_INT 4
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: PUSH
7153: LD_INT 0
7155: GREATER
7156: IFFALSE 7165
// RaiseSailEvent ( 3 ) ;
7158: LD_INT 3
7160: PPUSH
7161: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) > 0 then
7165: LD_INT 22
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 21
7177: PUSH
7178: LD_INT 3
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PUSH
7185: LD_INT 3
7187: PUSH
7188: LD_INT 24
7190: PUSH
7191: LD_INT 1000
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: PPUSH
7207: CALL_OW 69
7211: PUSH
7212: LD_INT 0
7214: GREATER
7215: IFFALSE 7226
// RaiseSailEvent ( 1 ) else
7217: LD_INT 1
7219: PPUSH
7220: CALL_OW 427
7224: GO 7233
// RaiseSailEvent ( 2 ) ;
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 427
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_barracks ] ] ) > 0 then
7233: LD_INT 22
7235: PUSH
7236: LD_INT 1
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 30
7245: PUSH
7246: LD_INT 5
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 69
7261: PUSH
7262: LD_INT 0
7264: GREATER
7265: IFFALSE 7274
// RaiseSailEvent ( 4 ) ;
7267: LD_INT 4
7269: PPUSH
7270: CALL_OW 427
// if gamma_towers > 0 then
7274: LD_EXP 18
7278: PUSH
7279: LD_INT 0
7281: GREATER
7282: IFFALSE 7291
// RaiseSailEvent ( 5 ) ;
7284: LD_INT 5
7286: PPUSH
7287: CALL_OW 427
// end ;
7291: PPOPN 2
7293: END
// export new_veh ; every 9 9$00 do var chassis , weapon ;
7294: GO 7296
7296: DISABLE
7297: LD_INT 0
7299: PPUSH
7300: PPUSH
// begin enable ;
7301: ENABLE
// if new_veh > 0 then
7302: LD_EXP 19
7306: PUSH
7307: LD_INT 0
7309: GREATER
7310: IFFALSE 7497
// while ( new_veh > 0 ) do
7312: LD_EXP 19
7316: PUSH
7317: LD_INT 0
7319: GREATER
7320: IFFALSE 7497
// begin Wait ( 0 0$01 ) ;
7322: LD_INT 35
7324: PPUSH
7325: CALL_OW 67
// if BuildingStatus ( am_fac ) = bs_idle then
7329: LD_INT 26
7331: PPUSH
7332: CALL_OW 461
7336: PUSH
7337: LD_INT 2
7339: EQUAL
7340: IFFALSE 7495
// begin chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 4 ) ] ;
7342: LD_ADDR_VAR 0 1
7346: PUSH
7347: LD_INT 2
7349: PUSH
7350: LD_INT 3
7352: PUSH
7353: LD_INT 3
7355: PUSH
7356: LD_INT 4
7358: PUSH
7359: EMPTY
7360: LIST
7361: LIST
7362: LIST
7363: LIST
7364: PUSH
7365: LD_INT 1
7367: PPUSH
7368: LD_INT 4
7370: PPUSH
7371: CALL_OW 12
7375: ARRAY
7376: ST_TO_ADDR
// if chassis in [ us_medium_wheeled , us_medium_tracked ] then
7377: LD_VAR 0 1
7381: PUSH
7382: LD_INT 2
7384: PUSH
7385: LD_INT 3
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: IN
7392: IFFALSE 7427
// weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
7394: LD_ADDR_VAR 0 2
7398: PUSH
7399: LD_INT 4
7401: PUSH
7402: LD_INT 5
7404: PUSH
7405: LD_INT 7
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_INT 3
7418: PPUSH
7419: CALL_OW 12
7423: ARRAY
7424: ST_TO_ADDR
7425: GO 7458
// weapon := [ us_double_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 3 ) ] ;
7427: LD_ADDR_VAR 0 2
7431: PUSH
7432: LD_INT 5
7434: PUSH
7435: LD_INT 7
7437: PUSH
7438: LD_INT 6
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PUSH
7446: LD_INT 1
7448: PPUSH
7449: LD_INT 3
7451: PPUSH
7452: CALL_OW 12
7456: ARRAY
7457: ST_TO_ADDR
// ComConstruct ( am_fac , chassis , engine_combustion , control_remote , weapon ) ;
7458: LD_INT 26
7460: PPUSH
7461: LD_VAR 0 1
7465: PPUSH
7466: LD_INT 1
7468: PPUSH
7469: LD_INT 2
7471: PPUSH
7472: LD_VAR 0 2
7476: PPUSH
7477: CALL_OW 125
// new_veh := new_veh - 1 ;
7481: LD_ADDR_EXP 19
7485: PUSH
7486: LD_EXP 19
7490: PUSH
7491: LD_INT 1
7493: MINUS
7494: ST_TO_ADDR
// end ; end ;
7495: GO 7312
// end ;
7497: PPOPN 2
7499: END
// every 0 0$01 do var v , filter , am_cmeh ;
7500: GO 7502
7502: DISABLE
7503: LD_INT 0
7505: PPUSH
7506: PPUSH
7507: PPUSH
// begin enable ;
7508: ENABLE
// am_cmeh := UnitsInside ( am_ct ) ;
7509: LD_ADDR_VAR 0 3
7513: PUSH
7514: LD_INT 56
7516: PPUSH
7517: CALL_OW 313
7521: ST_TO_ADDR
// filter = FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ] ) ;
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 33
7539: PUSH
7540: LD_INT 2
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: LD_INT 50
7549: PUSH
7550: EMPTY
7551: LIST
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: ST_TO_ADDR
// if filter > 0 then
7566: LD_VAR 0 2
7570: PUSH
7571: LD_INT 0
7573: GREATER
7574: IFFALSE 7642
// begin for v in filter do
7576: LD_ADDR_VAR 0 1
7580: PUSH
7581: LD_VAR 0 2
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7640
// begin if not IsControledBy ( v ) and IsOk ( v ) then
7589: LD_VAR 0 1
7593: PPUSH
7594: CALL_OW 312
7598: NOT
7599: PUSH
7600: LD_VAR 0 1
7604: PPUSH
7605: CALL_OW 302
7609: AND
7610: IFFALSE 7638
// ComLinkTo ( v , am_cmeh [ Rand ( 1 , 3 ) ] ) ;
7612: LD_VAR 0 1
7616: PPUSH
7617: LD_VAR 0 3
7621: PUSH
7622: LD_INT 1
7624: PPUSH
7625: LD_INT 3
7627: PPUSH
7628: CALL_OW 12
7632: ARRAY
7633: PPUSH
7634: CALL_OW 135
// end ;
7638: GO 7586
7640: POP
7641: POP
// end ; end ;
7642: PPOPN 3
7644: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) = [ 4 , 5 , 7 ] [ dif ] and BuildingStatus ( am_fac ) = bs_idle do var i , un , enemy ;
7645: LD_INT 33
7647: PUSH
7648: LD_INT 2
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 13
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 69
7680: PUSH
7681: LD_INT 4
7683: PUSH
7684: LD_INT 5
7686: PUSH
7687: LD_INT 7
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: PUSH
7695: LD_EXP 1
7699: ARRAY
7700: EQUAL
7701: PUSH
7702: LD_INT 26
7704: PPUSH
7705: CALL_OW 461
7709: PUSH
7710: LD_INT 2
7712: EQUAL
7713: AND
7714: IFFALSE 7925
7716: GO 7718
7718: DISABLE
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
// begin enable ;
7724: ENABLE
// if Sikorski_Ar then
7725: LD_EXP 12
7729: IFFALSE 7806
// SForce := FilterAllUnits ( [ [ f_or , [ f_side , 4 ] , [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ] ] ) else
7731: LD_ADDR_EXP 11
7735: PUSH
7736: LD_INT 2
7738: PUSH
7739: LD_INT 22
7741: PUSH
7742: LD_INT 4
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 22
7751: PUSH
7752: LD_INT 1
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 33
7761: PUSH
7762: LD_INT 2
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 3
7771: PUSH
7772: LD_INT 34
7774: PUSH
7775: LD_INT 13
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: LIST
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: PPUSH
7799: CALL_OW 69
7803: ST_TO_ADDR
7804: GO 7847
// SForce := FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) ;
7806: LD_ADDR_EXP 11
7810: PUSH
7811: LD_INT 33
7813: PUSH
7814: LD_INT 2
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 3
7823: PUSH
7824: LD_INT 34
7826: PUSH
7827: LD_INT 13
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 69
7846: ST_TO_ADDR
// repeat begin for un in SForce do
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_EXP 11
7856: PUSH
7857: FOR_IN
7858: IFFALSE 7913
// begin enemy := FilterAllUnits ( [ f_side , 3 ] ) ;
7860: LD_ADDR_VAR 0 3
7864: PUSH
7865: LD_INT 22
7867: PUSH
7868: LD_INT 3
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: PPUSH
7875: CALL_OW 69
7879: ST_TO_ADDR
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_VAR 0 3
7889: PPUSH
7890: LD_VAR 0 2
7894: PPUSH
7895: CALL_OW 74
7899: PPUSH
7900: CALL_OW 115
// Wait ( 0 0$01 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// end ;
7911: GO 7857
7913: POP
7914: POP
// end until SForce = 0 ;
7915: LD_EXP 11
7919: PUSH
7920: LD_INT 0
7922: EQUAL
7923: IFFALSE 7847
// end ;
7925: PPOPN 3
7927: END
// export function NewForce ( num ) ; var i , filter , veh , tmp ; begin
7928: LD_INT 0
7930: PPUSH
7931: PPUSH
7932: PPUSH
7933: PPUSH
7934: PPUSH
// tmp := FilterUnitsInArea ( spawnArea , [ ] ) ;
7935: LD_ADDR_VAR 0 6
7939: PUSH
7940: LD_INT 14
7942: PPUSH
7943: EMPTY
7944: PPUSH
7945: CALL_OW 70
7949: ST_TO_ADDR
// if tmp then
7950: LD_VAR 0 6
7954: IFFALSE 7988
// for i in tmp do
7956: LD_ADDR_VAR 0 3
7960: PUSH
7961: LD_VAR 0 6
7965: PUSH
7966: FOR_IN
7967: IFFALSE 7986
// ComMoveXY ( i , 42 , 23 ) ;
7969: LD_VAR 0 3
7973: PPUSH
7974: LD_INT 42
7976: PPUSH
7977: LD_INT 23
7979: PPUSH
7980: CALL_OW 111
7984: GO 7966
7986: POP
7987: POP
// EraseResourceArea ( spawnArea , mat_cans ) ;
7988: LD_INT 14
7990: PPUSH
7991: LD_INT 1
7993: PPUSH
7994: CALL_OW 286
// uc_side := 4 ;
7998: LD_ADDR_OWVAR 20
8002: PUSH
8003: LD_INT 4
8005: ST_TO_ADDR
// uc_nation := 1 ;
8006: LD_ADDR_OWVAR 21
8010: PUSH
8011: LD_INT 1
8013: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8014: LD_ADDR_OWVAR 37
8018: PUSH
8019: LD_INT 4
8021: ST_TO_ADDR
// vc_control := control_manual ;
8022: LD_ADDR_OWVAR 38
8026: PUSH
8027: LD_INT 1
8029: ST_TO_ADDR
// vc_engine := engine_combustion ;
8030: LD_ADDR_OWVAR 39
8034: PUSH
8035: LD_INT 1
8037: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_rocket_launcher ] [ dif ] ;
8038: LD_ADDR_OWVAR 40
8042: PUSH
8043: LD_INT 4
8045: PUSH
8046: LD_INT 5
8048: PUSH
8049: LD_INT 7
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: LIST
8056: PUSH
8057: LD_EXP 1
8061: ARRAY
8062: ST_TO_ADDR
// veh := CreateVehicle ;
8063: LD_ADDR_VAR 0 5
8067: PUSH
8068: CALL_OW 45
8072: ST_TO_ADDR
// PlaceUnitArea ( veh , am_main_spawn , false ) ;
8073: LD_VAR 0 5
8077: PPUSH
8078: LD_INT 2
8080: PPUSH
8081: LD_INT 0
8083: PPUSH
8084: CALL_OW 49
// PlaceHumanInUnit ( sikorski , veh ) ;
8088: LD_EXP 9
8092: PPUSH
8093: LD_VAR 0 5
8097: PPUSH
8098: CALL_OW 52
// SetMark ( veh , 1 ) ;
8102: LD_VAR 0 5
8106: PPUSH
8107: LD_INT 1
8109: PPUSH
8110: CALL_OW 242
// while ( num > 0 ) do
8114: LD_VAR 0 1
8118: PUSH
8119: LD_INT 0
8121: GREATER
8122: IFFALSE 8289
// begin CreateVehicleWithDriver ( [ us_medium_tracked , us_medium_tracked , us_medium_tracked , us_heavy_tracked ] [ Rand ( dif , 4 ) ] , engine_combustion , [ us_gatling_gun , us_double_gun , us_double_gun , us_rocket_launcher ] [ Rand ( 1 , dif + 1 ) ] , am_sik , 2 , [ 5 , 6 , 7 ] [ dif ] ) ;
8124: LD_INT 3
8126: PUSH
8127: LD_INT 3
8129: PUSH
8130: LD_INT 3
8132: PUSH
8133: LD_INT 4
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: LIST
8141: PUSH
8142: LD_EXP 1
8146: PPUSH
8147: LD_INT 4
8149: PPUSH
8150: CALL_OW 12
8154: ARRAY
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 4
8161: PUSH
8162: LD_INT 5
8164: PUSH
8165: LD_INT 5
8167: PUSH
8168: LD_INT 7
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 1
8179: PPUSH
8180: LD_EXP 1
8184: PUSH
8185: LD_INT 1
8187: PLUS
8188: PPUSH
8189: CALL_OW 12
8193: ARRAY
8194: PPUSH
8195: LD_INT 11
8197: PPUSH
8198: LD_INT 2
8200: PPUSH
8201: LD_INT 5
8203: PUSH
8204: LD_INT 6
8206: PUSH
8207: LD_INT 7
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: LIST
8214: PUSH
8215: LD_EXP 1
8219: ARRAY
8220: PPUSH
8221: CALL 1297 0 6
// filter := FilterAllUnits ( [ f_side , 4 ] ) ;
8225: LD_ADDR_VAR 0 4
8229: PUSH
8230: LD_INT 22
8232: PUSH
8233: LD_INT 4
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PPUSH
8240: CALL_OW 69
8244: ST_TO_ADDR
// ComMoveXY ( filter [ filter ] , 36 , 18 ) ;
8245: LD_VAR 0 4
8249: PUSH
8250: LD_VAR 0 4
8254: ARRAY
8255: PPUSH
8256: LD_INT 36
8258: PPUSH
8259: LD_INT 18
8261: PPUSH
8262: CALL_OW 111
// Wait ( 0 0$02 ) ;
8266: LD_INT 70
8268: PPUSH
8269: CALL_OW 67
// num := num - 1 ;
8273: LD_ADDR_VAR 0 1
8277: PUSH
8278: LD_VAR 0 1
8282: PUSH
8283: LD_INT 1
8285: MINUS
8286: ST_TO_ADDR
// end ;
8287: GO 8114
// end ;
8289: LD_VAR 0 2
8293: RET
// every 0 0$03 trigger patrol > 0 do var i ;
8294: LD_EXP 17
8298: PUSH
8299: LD_INT 0
8301: GREATER
8302: IFFALSE 8571
8304: GO 8306
8306: DISABLE
8307: LD_INT 0
8309: PPUSH
// begin enable ;
8310: ENABLE
// for i = 1 to patrol do
8311: LD_ADDR_VAR 0 1
8315: PUSH
8316: DOUBLE
8317: LD_INT 1
8319: DEC
8320: ST_TO_ADDR
8321: LD_EXP 17
8325: PUSH
8326: FOR_TO
8327: IFFALSE 8569
// begin if patrol [ i ] and IsLive ( patrol [ i ] ) and not HasTask ( patrol [ i ] ) then
8329: LD_EXP 17
8333: PUSH
8334: LD_VAR 0 1
8338: ARRAY
8339: PUSH
8340: LD_EXP 17
8344: PUSH
8345: LD_VAR 0 1
8349: ARRAY
8350: PPUSH
8351: CALL_OW 300
8355: AND
8356: PUSH
8357: LD_EXP 17
8361: PUSH
8362: LD_VAR 0 1
8366: ARRAY
8367: PPUSH
8368: CALL_OW 314
8372: NOT
8373: AND
8374: IFFALSE 8524
// case i of 1 :
8376: LD_VAR 0 1
8380: PUSH
8381: LD_INT 1
8383: DOUBLE
8384: EQUAL
8385: IFTRUE 8389
8387: GO 8452
8389: POP
// begin ComMoveXY ( patrol [ i ] , 53 , 91 ) ;
8390: LD_EXP 17
8394: PUSH
8395: LD_VAR 0 1
8399: ARRAY
8400: PPUSH
8401: LD_INT 53
8403: PPUSH
8404: LD_INT 91
8406: PPUSH
8407: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8411: LD_EXP 17
8415: PUSH
8416: LD_VAR 0 1
8420: ARRAY
8421: PPUSH
8422: LD_INT 245
8424: PPUSH
8425: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 24 , 26 ) ;
8429: LD_EXP 17
8433: PUSH
8434: LD_VAR 0 1
8438: ARRAY
8439: PPUSH
8440: LD_INT 24
8442: PPUSH
8443: LD_INT 26
8445: PPUSH
8446: CALL_OW 171
// end ; 2 :
8450: GO 8524
8452: LD_INT 2
8454: DOUBLE
8455: EQUAL
8456: IFTRUE 8460
8458: GO 8523
8460: POP
// begin ComMoveXY ( patrol [ i ] , 83 , 57 ) ;
8461: LD_EXP 17
8465: PUSH
8466: LD_VAR 0 1
8470: ARRAY
8471: PPUSH
8472: LD_INT 83
8474: PPUSH
8475: LD_INT 57
8477: PPUSH
8478: CALL_OW 111
// AddComWait ( patrol [ i ] , 0 0$07 ) ;
8482: LD_EXP 17
8486: PUSH
8487: LD_VAR 0 1
8491: ARRAY
8492: PPUSH
8493: LD_INT 245
8495: PPUSH
8496: CALL_OW 202
// AddComMoveXY ( patrol [ i ] , 47 , 53 ) ;
8500: LD_EXP 17
8504: PUSH
8505: LD_VAR 0 1
8509: ARRAY
8510: PPUSH
8511: LD_INT 47
8513: PPUSH
8514: LD_INT 53
8516: PPUSH
8517: CALL_OW 171
// end ; end ;
8521: GO 8524
8523: POP
// if GetLives ( patrol [ i ] ) < 1000 then
8524: LD_EXP 17
8528: PUSH
8529: LD_VAR 0 1
8533: ARRAY
8534: PPUSH
8535: CALL_OW 256
8539: PUSH
8540: LD_INT 1000
8542: LESS
8543: IFFALSE 8567
// patrol := patrol diff patrol [ i ] ;
8545: LD_ADDR_EXP 17
8549: PUSH
8550: LD_EXP 17
8554: PUSH
8555: LD_EXP 17
8559: PUSH
8560: LD_VAR 0 1
8564: ARRAY
8565: DIFF
8566: ST_TO_ADDR
// end ;
8567: GO 8326
8569: POP
8570: POP
// end ;
8571: PPOPN 1
8573: END
// every 0 0$10 do
8574: GO 8576
8576: DISABLE
// begin Wait ( [ 20 20$00 , 18 18$00 , 16 16$00 ] [ dif ] ) ;
8577: LD_INT 42000
8579: PUSH
8580: LD_INT 37800
8582: PUSH
8583: LD_INT 33600
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_EXP 1
8595: ARRAY
8596: PPUSH
8597: CALL_OW 67
// if not contact_am then
8601: LD_EXP 16
8605: NOT
8606: IFFALSE 8616
// contact_am := true ;
8608: LD_ADDR_EXP 16
8612: PUSH
8613: LD_INT 1
8615: ST_TO_ADDR
// end ; end_of_file
8616: END
// export event_rocket , event_comp , comp_tested , sikorski_run ; export function Action ; begin
8617: LD_INT 0
8619: PPUSH
// comp_tested := false ;
8620: LD_ADDR_EXP 22
8624: PUSH
8625: LD_INT 0
8627: ST_TO_ADDR
// sikorski_run := false ;
8628: LD_ADDR_EXP 23
8632: PUSH
8633: LD_INT 0
8635: ST_TO_ADDR
// InGameOn ;
8636: CALL_OW 8
// CenterNowOnUnits ( commander ) ;
8640: LD_EXP 3
8644: PPUSH
8645: CALL_OW 87
// Wait ( 0 0$01 ) ;
8649: LD_INT 35
8651: PPUSH
8652: CALL_OW 67
// SayRadio ( popov , Dpop1 ) ;
8656: LD_EXP 2
8660: PPUSH
8661: LD_STRING Dpop1
8663: PPUSH
8664: CALL_OW 94
// Say ( commander , Dcomm1 ) ;
8668: LD_EXP 3
8672: PPUSH
8673: LD_STRING Dcomm1
8675: PPUSH
8676: CALL_OW 88
// SayRadio ( popov , Dpop2 ) ;
8680: LD_EXP 2
8684: PPUSH
8685: LD_STRING Dpop2
8687: PPUSH
8688: CALL_OW 94
// Say ( commander , Dcomm2 ) ;
8692: LD_EXP 3
8696: PPUSH
8697: LD_STRING Dcomm2
8699: PPUSH
8700: CALL_OW 88
// InGameOff ;
8704: CALL_OW 9
// ChangeMissionObjectives ( T1 ) ;
8708: LD_STRING T1
8710: PPUSH
8711: CALL_OW 337
// end ;
8715: LD_VAR 0 1
8719: RET
// every 0 0$01 trigger timer > 2 2$01 do
8720: LD_EXP 24
8724: PUSH
8725: LD_INT 4235
8727: GREATER
8728: IFFALSE 8745
8730: GO 8732
8732: DISABLE
// begin SayRadio ( kapral , DKap1 ) ;
8733: LD_EXP 5
8737: PPUSH
8738: LD_STRING DKap1
8740: PPUSH
8741: CALL_OW 94
// end ;
8745: END
// every 0 0$01 trigger timer > [ 22 22$00 , 25 25$00 , 30 30$00 ] [ dif ] do var i ;
8746: LD_EXP 24
8750: PUSH
8751: LD_INT 46200
8753: PUSH
8754: LD_INT 52500
8756: PUSH
8757: LD_INT 63000
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: LIST
8764: PUSH
8765: LD_EXP 1
8769: ARRAY
8770: GREATER
8771: IFFALSE 9138
8773: GO 8775
8775: DISABLE
8776: LD_INT 0
8778: PPUSH
// begin SayRadio ( kapral , DKap2 ) ;
8779: LD_EXP 5
8783: PPUSH
8784: LD_STRING DKap2
8786: PPUSH
8787: CALL_OW 94
// Wait ( 0 0$0.3 ) ;
8791: LD_INT 10
8793: PPUSH
8794: CALL_OW 67
// Say ( commander , Dcommk ) ;
8798: LD_EXP 3
8802: PPUSH
8803: LD_STRING Dcommk
8805: PPUSH
8806: CALL_OW 88
// Wait ( 0 0$44 ) ;
8810: LD_INT 1540
8812: PPUSH
8813: CALL_OW 67
// PlaceUnitArea ( kapral , am_west_spawn , false ) ;
8817: LD_EXP 5
8821: PPUSH
8822: LD_INT 3
8824: PPUSH
8825: LD_INT 0
8827: PPUSH
8828: CALL_OW 49
// CenterNowOnUnits ( kapral ) ;
8832: LD_EXP 5
8836: PPUSH
8837: CALL_OW 87
// Wait ( 0 0$10 ) ;
8841: LD_INT 350
8843: PPUSH
8844: CALL_OW 67
// NewForce ( [ 6 , 7 , 8 ] [ dif ] ) ;
8848: LD_INT 6
8850: PUSH
8851: LD_INT 7
8853: PUSH
8854: LD_INT 8
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: LIST
8861: PUSH
8862: LD_EXP 1
8866: ARRAY
8867: PPUSH
8868: CALL 7928 0 1
// Wait ( 2 2$00 ) ;
8872: LD_INT 4200
8874: PPUSH
8875: CALL_OW 67
// while ( FilterAllUnits ( [ [ f_control , control_remote ] , [ f_not , [ f_weapon , us_crane ] ] ] ) < 3 ) do
8879: LD_INT 33
8881: PUSH
8882: LD_INT 2
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: LD_INT 3
8891: PUSH
8892: LD_INT 34
8894: PUSH
8895: LD_INT 13
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PPUSH
8910: CALL_OW 69
8914: PUSH
8915: LD_INT 3
8917: LESS
8918: IFFALSE 8929
// Wait ( 0 0$01 ) ;
8920: LD_INT 35
8922: PPUSH
8923: CALL_OW 67
8927: GO 8879
// uc_side := 4 ;
8929: LD_ADDR_OWVAR 20
8933: PUSH
8934: LD_INT 4
8936: ST_TO_ADDR
// uc_nation := 1 ;
8937: LD_ADDR_OWVAR 21
8941: PUSH
8942: LD_INT 1
8944: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ dif ] do
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: DOUBLE
8951: LD_INT 1
8953: DEC
8954: ST_TO_ADDR
8955: LD_INT 4
8957: PUSH
8958: LD_INT 5
8960: PUSH
8961: LD_INT 6
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: LIST
8968: PUSH
8969: LD_EXP 1
8973: ARRAY
8974: PUSH
8975: FOR_TO
8976: IFFALSE 9018
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_east_spawn , false ) ;
8978: LD_INT 1
8980: PPUSH
8981: LD_INT 5
8983: PUSH
8984: LD_INT 6
8986: PUSH
8987: LD_INT 7
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PUSH
8995: LD_EXP 1
8999: ARRAY
9000: PPUSH
9001: CALL 734 0 2
9005: PPUSH
9006: LD_INT 4
9008: PPUSH
9009: LD_INT 0
9011: PPUSH
9012: CALL_OW 49
9016: GO 8975
9018: POP
9019: POP
// sikorski_ar := true ;
9020: LD_ADDR_EXP 12
9024: PUSH
9025: LD_INT 1
9027: ST_TO_ADDR
// SayRadio ( sikorski , DSik1 ) ;
9028: LD_EXP 9
9032: PPUSH
9033: LD_STRING DSik1
9035: PPUSH
9036: CALL_OW 94
// Wait ( 0 0$30 ) ;
9040: LD_INT 1050
9042: PPUSH
9043: CALL_OW 67
// uc_side := 4 ;
9047: LD_ADDR_OWVAR 20
9051: PUSH
9052: LD_INT 4
9054: ST_TO_ADDR
// uc_nation := 1 ;
9055: LD_ADDR_OWVAR 21
9059: PUSH
9060: LD_INT 1
9062: ST_TO_ADDR
// for i = 1 to [ 3 , 4 , 4 ] [ dif ] do
9063: LD_ADDR_VAR 0 1
9067: PUSH
9068: DOUBLE
9069: LD_INT 1
9071: DEC
9072: ST_TO_ADDR
9073: LD_INT 3
9075: PUSH
9076: LD_INT 4
9078: PUSH
9079: LD_INT 4
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: LIST
9086: PUSH
9087: LD_EXP 1
9091: ARRAY
9092: PUSH
9093: FOR_TO
9094: IFFALSE 9136
// PlaceUnitArea ( CreateHumanWithClass ( 1 , [ 5 , 6 , 7 ] [ dif ] ) , am_south_spawn , false ) ;
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 5
9101: PUSH
9102: LD_INT 6
9104: PUSH
9105: LD_INT 7
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: PUSH
9113: LD_EXP 1
9117: ARRAY
9118: PPUSH
9119: CALL 734 0 2
9123: PPUSH
9124: LD_INT 13
9126: PPUSH
9127: LD_INT 0
9129: PPUSH
9130: CALL_OW 49
9134: GO 9093
9136: POP
9137: POP
// end ;
9138: PPOPN 1
9140: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 650 do
9141: LD_EXP 9
9145: PPUSH
9146: CALL_OW 256
9150: PUSH
9151: LD_INT 650
9153: LESS
9154: IFFALSE 9236
9156: GO 9158
9158: DISABLE
// begin Say ( sikorski , DSik2 ) ;
9159: LD_EXP 9
9163: PPUSH
9164: LD_STRING DSik2
9166: PPUSH
9167: CALL_OW 88
// while ( IsLive ( sikorski ) ) do
9171: LD_EXP 9
9175: PPUSH
9176: CALL_OW 300
9180: IFFALSE 9236
// begin ComMoveToArea ( sikorski , am_main_spawn ) ;
9182: LD_EXP 9
9186: PPUSH
9187: LD_INT 2
9189: PPUSH
9190: CALL_OW 113
// Wait ( 0 0$01 ) ;
9194: LD_INT 35
9196: PPUSH
9197: CALL_OW 67
// if IsInArea ( sikorski , am_main_spawn ) then
9201: LD_EXP 9
9205: PPUSH
9206: LD_INT 2
9208: PPUSH
9209: CALL_OW 308
9213: IFFALSE 9234
// begin RemoveUnit ( sikorski ) ;
9215: LD_EXP 9
9219: PPUSH
9220: CALL_OW 64
// break ;
9224: GO 9236
// sikorski_run := true ;
9226: LD_ADDR_EXP 23
9230: PUSH
9231: LD_INT 1
9233: ST_TO_ADDR
// end ; end ;
9234: GO 9171
// end ;
9236: END
// every 0 0$0.1 trigger GetLives ( sikorski ) < 1000 do
9237: LD_EXP 9
9241: PPUSH
9242: CALL_OW 256
9246: PUSH
9247: LD_INT 1000
9249: LESS
9250: IFFALSE 9267
9252: GO 9254
9254: DISABLE
// Say ( sikorski , DSkik3 ) ; end_of_file
9255: LD_EXP 9
9259: PPUSH
9260: LD_STRING DSkik3
9262: PPUSH
9263: CALL_OW 88
9267: END
// every 1 1$45 + 0 0$15 do
9268: GO 9270
9270: DISABLE
// begin enable ;
9271: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 5
9277: PPUSH
9278: CALL_OW 12
9282: PPUSH
9283: LD_INT 8
9285: PPUSH
9286: LD_INT 1
9288: PPUSH
9289: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
9293: LD_INT 350
9295: PPUSH
9296: LD_INT 1295
9298: PPUSH
9299: CALL_OW 12
9303: PPUSH
9304: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9308: LD_INT 1
9310: PPUSH
9311: LD_INT 5
9313: PPUSH
9314: CALL_OW 12
9318: PPUSH
9319: LD_INT 1
9321: PPUSH
9322: CALL_OW 57
// Wait ( Rand ( 0 0$10 , 0 0$30 ) ) ;
9326: LD_INT 350
9328: PPUSH
9329: LD_INT 1050
9331: PPUSH
9332: CALL_OW 12
9336: PPUSH
9337: CALL_OW 67
// if timer <= [ 12 12$00 , 11 11$00 , 10 10$00 ] [ dif ] then
9341: LD_EXP 24
9345: PUSH
9346: LD_INT 25200
9348: PUSH
9349: LD_INT 23100
9351: PUSH
9352: LD_INT 21000
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: LIST
9359: PUSH
9360: LD_EXP 1
9364: ARRAY
9365: LESSEQUAL
9366: IFFALSE 9389
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9368: LD_INT 1
9370: PPUSH
9371: LD_INT 5
9373: PPUSH
9374: CALL_OW 12
9378: PPUSH
9379: LD_INT 8
9381: PPUSH
9382: LD_INT 1
9384: PPUSH
9385: CALL_OW 55
// end ;
9389: END
// export timer ; every 1 do
9390: GO 9392
9392: DISABLE
// timer := 0 0$00 ;
9393: LD_ADDR_EXP 24
9397: PUSH
9398: LD_INT 0
9400: ST_TO_ADDR
9401: END
// every 0 0$01 do
9402: GO 9404
9404: DISABLE
// begin enable ;
9405: ENABLE
// Display_Strings := [ #tick , timer ] ;
9406: LD_ADDR_OWVAR 47
9410: PUSH
9411: LD_STRING #tick
9413: PUSH
9414: LD_EXP 24
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: ST_TO_ADDR
// timer := timer + 0 0$01 ;
9423: LD_ADDR_EXP 24
9427: PUSH
9428: LD_EXP 24
9432: PUSH
9433: LD_INT 35
9435: PLUS
9436: ST_TO_ADDR
// end ; end_of_file
9437: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
9438: GO 9440
9440: DISABLE
// begin ru_radar := 98 ;
9441: LD_ADDR_EXP 25
9445: PUSH
9446: LD_INT 98
9448: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9449: LD_ADDR_EXP 26
9453: PUSH
9454: LD_INT 89
9456: ST_TO_ADDR
// us_hack := 99 ;
9457: LD_ADDR_EXP 27
9461: PUSH
9462: LD_INT 99
9464: ST_TO_ADDR
// us_artillery := 97 ;
9465: LD_ADDR_EXP 28
9469: PUSH
9470: LD_INT 97
9472: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9473: LD_ADDR_EXP 29
9477: PUSH
9478: LD_INT 91
9480: ST_TO_ADDR
// tech_Artillery := 80 ;
9481: LD_ADDR_EXP 30
9485: PUSH
9486: LD_INT 80
9488: ST_TO_ADDR
// tech_RadMat := 81 ;
9489: LD_ADDR_EXP 31
9493: PUSH
9494: LD_INT 81
9496: ST_TO_ADDR
// tech_BasicTools := 82 ;
9497: LD_ADDR_EXP 32
9501: PUSH
9502: LD_INT 82
9504: ST_TO_ADDR
// tech_Cargo := 83 ;
9505: LD_ADDR_EXP 33
9509: PUSH
9510: LD_INT 83
9512: ST_TO_ADDR
// tech_Track := 84 ;
9513: LD_ADDR_EXP 34
9517: PUSH
9518: LD_INT 84
9520: ST_TO_ADDR
// tech_Crane := 85 ;
9521: LD_ADDR_EXP 35
9525: PUSH
9526: LD_INT 85
9528: ST_TO_ADDR
// tech_Bulldozer := 86 ;
9529: LD_ADDR_EXP 36
9533: PUSH
9534: LD_INT 86
9536: ST_TO_ADDR
// tech_Hovercraft := 87 ;
9537: LD_ADDR_EXP 37
9541: PUSH
9542: LD_INT 87
9544: ST_TO_ADDR
// end ; end_of_file end_of_file
9545: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
9546: GO 9548
9548: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
9549: LD_STRING initStreamRollete();
9551: PPUSH
9552: CALL_OW 559
// InitStreamMode ;
9556: CALL 9565 0 0
// DefineStreamItems ( ) ;
9560: CALL 10005 0 0
// end ;
9564: END
// function InitStreamMode ; begin
9565: LD_INT 0
9567: PPUSH
// streamModeActive := false ;
9568: LD_ADDR_EXP 38
9572: PUSH
9573: LD_INT 0
9575: ST_TO_ADDR
// normalCounter := 36 ;
9576: LD_ADDR_EXP 39
9580: PUSH
9581: LD_INT 36
9583: ST_TO_ADDR
// hardcoreCounter := 16 ;
9584: LD_ADDR_EXP 40
9588: PUSH
9589: LD_INT 16
9591: ST_TO_ADDR
// sRocket := false ;
9592: LD_ADDR_EXP 43
9596: PUSH
9597: LD_INT 0
9599: ST_TO_ADDR
// sSpeed := false ;
9600: LD_ADDR_EXP 42
9604: PUSH
9605: LD_INT 0
9607: ST_TO_ADDR
// sEngine := false ;
9608: LD_ADDR_EXP 44
9612: PUSH
9613: LD_INT 0
9615: ST_TO_ADDR
// sSpec := false ;
9616: LD_ADDR_EXP 41
9620: PUSH
9621: LD_INT 0
9623: ST_TO_ADDR
// sLevel := false ;
9624: LD_ADDR_EXP 45
9628: PUSH
9629: LD_INT 0
9631: ST_TO_ADDR
// sArmoury := false ;
9632: LD_ADDR_EXP 46
9636: PUSH
9637: LD_INT 0
9639: ST_TO_ADDR
// sRadar := false ;
9640: LD_ADDR_EXP 47
9644: PUSH
9645: LD_INT 0
9647: ST_TO_ADDR
// sBunker := false ;
9648: LD_ADDR_EXP 48
9652: PUSH
9653: LD_INT 0
9655: ST_TO_ADDR
// sHack := false ;
9656: LD_ADDR_EXP 49
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// sFire := false ;
9664: LD_ADDR_EXP 50
9668: PUSH
9669: LD_INT 0
9671: ST_TO_ADDR
// sRefresh := false ;
9672: LD_ADDR_EXP 51
9676: PUSH
9677: LD_INT 0
9679: ST_TO_ADDR
// sExp := false ;
9680: LD_ADDR_EXP 52
9684: PUSH
9685: LD_INT 0
9687: ST_TO_ADDR
// sDepot := false ;
9688: LD_ADDR_EXP 53
9692: PUSH
9693: LD_INT 0
9695: ST_TO_ADDR
// sFlag := false ;
9696: LD_ADDR_EXP 54
9700: PUSH
9701: LD_INT 0
9703: ST_TO_ADDR
// sKamikadze := false ;
9704: LD_ADDR_EXP 62
9708: PUSH
9709: LD_INT 0
9711: ST_TO_ADDR
// sTroll := false ;
9712: LD_ADDR_EXP 63
9716: PUSH
9717: LD_INT 0
9719: ST_TO_ADDR
// sSlow := false ;
9720: LD_ADDR_EXP 64
9724: PUSH
9725: LD_INT 0
9727: ST_TO_ADDR
// sLack := false ;
9728: LD_ADDR_EXP 65
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// sTank := false ;
9736: LD_ADDR_EXP 67
9740: PUSH
9741: LD_INT 0
9743: ST_TO_ADDR
// sRemote := false ;
9744: LD_ADDR_EXP 68
9748: PUSH
9749: LD_INT 0
9751: ST_TO_ADDR
// sPowell := false ;
9752: LD_ADDR_EXP 69
9756: PUSH
9757: LD_INT 0
9759: ST_TO_ADDR
// sTeleport := false ;
9760: LD_ADDR_EXP 72
9764: PUSH
9765: LD_INT 0
9767: ST_TO_ADDR
// sOilTower := false ;
9768: LD_ADDR_EXP 74
9772: PUSH
9773: LD_INT 0
9775: ST_TO_ADDR
// sShovel := false ;
9776: LD_ADDR_EXP 75
9780: PUSH
9781: LD_INT 0
9783: ST_TO_ADDR
// sSheik := false ;
9784: LD_ADDR_EXP 76
9788: PUSH
9789: LD_INT 0
9791: ST_TO_ADDR
// sEarthquake := false ;
9792: LD_ADDR_EXP 78
9796: PUSH
9797: LD_INT 0
9799: ST_TO_ADDR
// sAI := false ;
9800: LD_ADDR_EXP 79
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// sCargo := false ;
9808: LD_ADDR_EXP 82
9812: PUSH
9813: LD_INT 0
9815: ST_TO_ADDR
// sDLaser := false ;
9816: LD_ADDR_EXP 83
9820: PUSH
9821: LD_INT 0
9823: ST_TO_ADDR
// sExchange := false ;
9824: LD_ADDR_EXP 84
9828: PUSH
9829: LD_INT 0
9831: ST_TO_ADDR
// sFac := false ;
9832: LD_ADDR_EXP 85
9836: PUSH
9837: LD_INT 0
9839: ST_TO_ADDR
// sPower := false ;
9840: LD_ADDR_EXP 86
9844: PUSH
9845: LD_INT 0
9847: ST_TO_ADDR
// sRandom := false ;
9848: LD_ADDR_EXP 87
9852: PUSH
9853: LD_INT 0
9855: ST_TO_ADDR
// sShield := false ;
9856: LD_ADDR_EXP 88
9860: PUSH
9861: LD_INT 0
9863: ST_TO_ADDR
// sTime := false ;
9864: LD_ADDR_EXP 89
9868: PUSH
9869: LD_INT 0
9871: ST_TO_ADDR
// sTools := false ;
9872: LD_ADDR_EXP 90
9876: PUSH
9877: LD_INT 0
9879: ST_TO_ADDR
// sSold := false ;
9880: LD_ADDR_EXP 55
9884: PUSH
9885: LD_INT 0
9887: ST_TO_ADDR
// sDiff := false ;
9888: LD_ADDR_EXP 56
9892: PUSH
9893: LD_INT 0
9895: ST_TO_ADDR
// sFog := false ;
9896: LD_ADDR_EXP 59
9900: PUSH
9901: LD_INT 0
9903: ST_TO_ADDR
// sReset := false ;
9904: LD_ADDR_EXP 60
9908: PUSH
9909: LD_INT 0
9911: ST_TO_ADDR
// sSun := false ;
9912: LD_ADDR_EXP 61
9916: PUSH
9917: LD_INT 0
9919: ST_TO_ADDR
// sTiger := false ;
9920: LD_ADDR_EXP 57
9924: PUSH
9925: LD_INT 0
9927: ST_TO_ADDR
// sBomb := false ;
9928: LD_ADDR_EXP 58
9932: PUSH
9933: LD_INT 0
9935: ST_TO_ADDR
// sWound := false ;
9936: LD_ADDR_EXP 66
9940: PUSH
9941: LD_INT 0
9943: ST_TO_ADDR
// sBetray := false ;
9944: LD_ADDR_EXP 70
9948: PUSH
9949: LD_INT 0
9951: ST_TO_ADDR
// sContamin := false ;
9952: LD_ADDR_EXP 71
9956: PUSH
9957: LD_INT 0
9959: ST_TO_ADDR
// sOil := false ;
9960: LD_ADDR_EXP 73
9964: PUSH
9965: LD_INT 0
9967: ST_TO_ADDR
// sStu := false ;
9968: LD_ADDR_EXP 77
9972: PUSH
9973: LD_INT 0
9975: ST_TO_ADDR
// sBazooka := false ;
9976: LD_ADDR_EXP 80
9980: PUSH
9981: LD_INT 0
9983: ST_TO_ADDR
// sMortar := false ;
9984: LD_ADDR_EXP 81
9988: PUSH
9989: LD_INT 0
9991: ST_TO_ADDR
// sRanger := false ;
9992: LD_ADDR_EXP 91
9996: PUSH
9997: LD_INT 0
9999: ST_TO_ADDR
// end ;
10000: LD_VAR 0 1
10004: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
10005: LD_INT 0
10007: PPUSH
10008: PPUSH
10009: PPUSH
10010: PPUSH
10011: PPUSH
// result := [ ] ;
10012: LD_ADDR_VAR 0 1
10016: PUSH
10017: EMPTY
10018: ST_TO_ADDR
// if campaign_id = 1 then
10019: LD_OWVAR 69
10023: PUSH
10024: LD_INT 1
10026: EQUAL
10027: IFFALSE 12965
// begin case mission_number of 1 :
10029: LD_OWVAR 70
10033: PUSH
10034: LD_INT 1
10036: DOUBLE
10037: EQUAL
10038: IFTRUE 10042
10040: GO 10106
10042: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
10043: LD_ADDR_VAR 0 1
10047: PUSH
10048: LD_INT 2
10050: PUSH
10051: LD_INT 4
10053: PUSH
10054: LD_INT 11
10056: PUSH
10057: LD_INT 12
10059: PUSH
10060: LD_INT 15
10062: PUSH
10063: LD_INT 16
10065: PUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 23
10071: PUSH
10072: LD_INT 26
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: PUSH
10086: LD_INT 101
10088: PUSH
10089: LD_INT 102
10091: PUSH
10092: LD_INT 106
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: LIST
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: ST_TO_ADDR
10104: GO 12963
10106: LD_INT 2
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10186
10114: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_INT 2
10122: PUSH
10123: LD_INT 4
10125: PUSH
10126: LD_INT 11
10128: PUSH
10129: LD_INT 12
10131: PUSH
10132: LD_INT 15
10134: PUSH
10135: LD_INT 16
10137: PUSH
10138: LD_INT 22
10140: PUSH
10141: LD_INT 23
10143: PUSH
10144: LD_INT 26
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 101
10160: PUSH
10161: LD_INT 102
10163: PUSH
10164: LD_INT 105
10166: PUSH
10167: LD_INT 106
10169: PUSH
10170: LD_INT 108
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: ST_TO_ADDR
10184: GO 12963
10186: LD_INT 3
10188: DOUBLE
10189: EQUAL
10190: IFTRUE 10194
10192: GO 10270
10194: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
10195: LD_ADDR_VAR 0 1
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 4
10205: PUSH
10206: LD_INT 5
10208: PUSH
10209: LD_INT 11
10211: PUSH
10212: LD_INT 12
10214: PUSH
10215: LD_INT 15
10217: PUSH
10218: LD_INT 16
10220: PUSH
10221: LD_INT 22
10223: PUSH
10224: LD_INT 26
10226: PUSH
10227: LD_INT 36
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: LIST
10240: LIST
10241: PUSH
10242: LD_INT 101
10244: PUSH
10245: LD_INT 102
10247: PUSH
10248: LD_INT 105
10250: PUSH
10251: LD_INT 106
10253: PUSH
10254: LD_INT 108
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: ST_TO_ADDR
10268: GO 12963
10270: LD_INT 4
10272: DOUBLE
10273: EQUAL
10274: IFTRUE 10278
10276: GO 10362
10278: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
10279: LD_ADDR_VAR 0 1
10283: PUSH
10284: LD_INT 2
10286: PUSH
10287: LD_INT 4
10289: PUSH
10290: LD_INT 5
10292: PUSH
10293: LD_INT 8
10295: PUSH
10296: LD_INT 11
10298: PUSH
10299: LD_INT 12
10301: PUSH
10302: LD_INT 15
10304: PUSH
10305: LD_INT 16
10307: PUSH
10308: LD_INT 22
10310: PUSH
10311: LD_INT 23
10313: PUSH
10314: LD_INT 26
10316: PUSH
10317: LD_INT 36
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 101
10336: PUSH
10337: LD_INT 102
10339: PUSH
10340: LD_INT 105
10342: PUSH
10343: LD_INT 106
10345: PUSH
10346: LD_INT 108
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: ST_TO_ADDR
10360: GO 12963
10362: LD_INT 5
10364: DOUBLE
10365: EQUAL
10366: IFTRUE 10370
10368: GO 10470
10370: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
10371: LD_ADDR_VAR 0 1
10375: PUSH
10376: LD_INT 2
10378: PUSH
10379: LD_INT 4
10381: PUSH
10382: LD_INT 5
10384: PUSH
10385: LD_INT 6
10387: PUSH
10388: LD_INT 8
10390: PUSH
10391: LD_INT 11
10393: PUSH
10394: LD_INT 12
10396: PUSH
10397: LD_INT 15
10399: PUSH
10400: LD_INT 16
10402: PUSH
10403: LD_INT 22
10405: PUSH
10406: LD_INT 23
10408: PUSH
10409: LD_INT 25
10411: PUSH
10412: LD_INT 26
10414: PUSH
10415: LD_INT 36
10417: PUSH
10418: EMPTY
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 101
10436: PUSH
10437: LD_INT 102
10439: PUSH
10440: LD_INT 105
10442: PUSH
10443: LD_INT 106
10445: PUSH
10446: LD_INT 108
10448: PUSH
10449: LD_INT 109
10451: PUSH
10452: LD_INT 112
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: ST_TO_ADDR
10468: GO 12963
10470: LD_INT 6
10472: DOUBLE
10473: EQUAL
10474: IFTRUE 10478
10476: GO 10598
10478: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
10479: LD_ADDR_VAR 0 1
10483: PUSH
10484: LD_INT 2
10486: PUSH
10487: LD_INT 4
10489: PUSH
10490: LD_INT 5
10492: PUSH
10493: LD_INT 6
10495: PUSH
10496: LD_INT 8
10498: PUSH
10499: LD_INT 11
10501: PUSH
10502: LD_INT 12
10504: PUSH
10505: LD_INT 15
10507: PUSH
10508: LD_INT 16
10510: PUSH
10511: LD_INT 20
10513: PUSH
10514: LD_INT 21
10516: PUSH
10517: LD_INT 22
10519: PUSH
10520: LD_INT 23
10522: PUSH
10523: LD_INT 25
10525: PUSH
10526: LD_INT 26
10528: PUSH
10529: LD_INT 30
10531: PUSH
10532: LD_INT 31
10534: PUSH
10535: LD_INT 32
10537: PUSH
10538: LD_INT 36
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: PUSH
10562: LD_INT 101
10564: PUSH
10565: LD_INT 102
10567: PUSH
10568: LD_INT 105
10570: PUSH
10571: LD_INT 106
10573: PUSH
10574: LD_INT 108
10576: PUSH
10577: LD_INT 109
10579: PUSH
10580: LD_INT 112
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: ST_TO_ADDR
10596: GO 12963
10598: LD_INT 7
10600: DOUBLE
10601: EQUAL
10602: IFTRUE 10606
10604: GO 10706
10606: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
10607: LD_ADDR_VAR 0 1
10611: PUSH
10612: LD_INT 2
10614: PUSH
10615: LD_INT 4
10617: PUSH
10618: LD_INT 5
10620: PUSH
10621: LD_INT 7
10623: PUSH
10624: LD_INT 11
10626: PUSH
10627: LD_INT 12
10629: PUSH
10630: LD_INT 15
10632: PUSH
10633: LD_INT 16
10635: PUSH
10636: LD_INT 20
10638: PUSH
10639: LD_INT 21
10641: PUSH
10642: LD_INT 22
10644: PUSH
10645: LD_INT 23
10647: PUSH
10648: LD_INT 25
10650: PUSH
10651: LD_INT 26
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: PUSH
10670: LD_INT 101
10672: PUSH
10673: LD_INT 102
10675: PUSH
10676: LD_INT 103
10678: PUSH
10679: LD_INT 105
10681: PUSH
10682: LD_INT 106
10684: PUSH
10685: LD_INT 108
10687: PUSH
10688: LD_INT 112
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: ST_TO_ADDR
10704: GO 12963
10706: LD_INT 8
10708: DOUBLE
10709: EQUAL
10710: IFTRUE 10714
10712: GO 10842
10714: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
10715: LD_ADDR_VAR 0 1
10719: PUSH
10720: LD_INT 2
10722: PUSH
10723: LD_INT 4
10725: PUSH
10726: LD_INT 5
10728: PUSH
10729: LD_INT 6
10731: PUSH
10732: LD_INT 7
10734: PUSH
10735: LD_INT 8
10737: PUSH
10738: LD_INT 11
10740: PUSH
10741: LD_INT 12
10743: PUSH
10744: LD_INT 15
10746: PUSH
10747: LD_INT 16
10749: PUSH
10750: LD_INT 20
10752: PUSH
10753: LD_INT 21
10755: PUSH
10756: LD_INT 22
10758: PUSH
10759: LD_INT 23
10761: PUSH
10762: LD_INT 25
10764: PUSH
10765: LD_INT 26
10767: PUSH
10768: LD_INT 30
10770: PUSH
10771: LD_INT 31
10773: PUSH
10774: LD_INT 32
10776: PUSH
10777: LD_INT 36
10779: PUSH
10780: EMPTY
10781: LIST
10782: LIST
10783: LIST
10784: LIST
10785: LIST
10786: LIST
10787: LIST
10788: LIST
10789: LIST
10790: LIST
10791: LIST
10792: LIST
10793: LIST
10794: LIST
10795: LIST
10796: LIST
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 101
10804: PUSH
10805: LD_INT 102
10807: PUSH
10808: LD_INT 103
10810: PUSH
10811: LD_INT 105
10813: PUSH
10814: LD_INT 106
10816: PUSH
10817: LD_INT 108
10819: PUSH
10820: LD_INT 109
10822: PUSH
10823: LD_INT 112
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: ST_TO_ADDR
10840: GO 12963
10842: LD_INT 9
10844: DOUBLE
10845: EQUAL
10846: IFTRUE 10850
10848: GO 10986
10850: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
10851: LD_ADDR_VAR 0 1
10855: PUSH
10856: LD_INT 2
10858: PUSH
10859: LD_INT 4
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: LD_INT 6
10867: PUSH
10868: LD_INT 7
10870: PUSH
10871: LD_INT 8
10873: PUSH
10874: LD_INT 11
10876: PUSH
10877: LD_INT 12
10879: PUSH
10880: LD_INT 15
10882: PUSH
10883: LD_INT 16
10885: PUSH
10886: LD_INT 20
10888: PUSH
10889: LD_INT 21
10891: PUSH
10892: LD_INT 22
10894: PUSH
10895: LD_INT 23
10897: PUSH
10898: LD_INT 25
10900: PUSH
10901: LD_INT 26
10903: PUSH
10904: LD_INT 28
10906: PUSH
10907: LD_INT 30
10909: PUSH
10910: LD_INT 31
10912: PUSH
10913: LD_INT 32
10915: PUSH
10916: LD_INT 36
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: LIST
10939: LIST
10940: LIST
10941: PUSH
10942: LD_INT 101
10944: PUSH
10945: LD_INT 102
10947: PUSH
10948: LD_INT 103
10950: PUSH
10951: LD_INT 105
10953: PUSH
10954: LD_INT 106
10956: PUSH
10957: LD_INT 108
10959: PUSH
10960: LD_INT 109
10962: PUSH
10963: LD_INT 112
10965: PUSH
10966: LD_INT 114
10968: PUSH
10969: EMPTY
10970: LIST
10971: LIST
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: ST_TO_ADDR
10984: GO 12963
10986: LD_INT 10
10988: DOUBLE
10989: EQUAL
10990: IFTRUE 10994
10992: GO 11178
10994: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10995: LD_ADDR_VAR 0 1
10999: PUSH
11000: LD_INT 2
11002: PUSH
11003: LD_INT 4
11005: PUSH
11006: LD_INT 5
11008: PUSH
11009: LD_INT 6
11011: PUSH
11012: LD_INT 7
11014: PUSH
11015: LD_INT 8
11017: PUSH
11018: LD_INT 9
11020: PUSH
11021: LD_INT 10
11023: PUSH
11024: LD_INT 11
11026: PUSH
11027: LD_INT 12
11029: PUSH
11030: LD_INT 13
11032: PUSH
11033: LD_INT 14
11035: PUSH
11036: LD_INT 15
11038: PUSH
11039: LD_INT 16
11041: PUSH
11042: LD_INT 17
11044: PUSH
11045: LD_INT 18
11047: PUSH
11048: LD_INT 19
11050: PUSH
11051: LD_INT 20
11053: PUSH
11054: LD_INT 21
11056: PUSH
11057: LD_INT 22
11059: PUSH
11060: LD_INT 23
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 25
11068: PUSH
11069: LD_INT 26
11071: PUSH
11072: LD_INT 28
11074: PUSH
11075: LD_INT 30
11077: PUSH
11078: LD_INT 31
11080: PUSH
11081: LD_INT 32
11083: PUSH
11084: LD_INT 36
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 101
11120: PUSH
11121: LD_INT 102
11123: PUSH
11124: LD_INT 103
11126: PUSH
11127: LD_INT 104
11129: PUSH
11130: LD_INT 105
11132: PUSH
11133: LD_INT 106
11135: PUSH
11136: LD_INT 107
11138: PUSH
11139: LD_INT 108
11141: PUSH
11142: LD_INT 109
11144: PUSH
11145: LD_INT 110
11147: PUSH
11148: LD_INT 111
11150: PUSH
11151: LD_INT 112
11153: PUSH
11154: LD_INT 114
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: ST_TO_ADDR
11176: GO 12963
11178: LD_INT 11
11180: DOUBLE
11181: EQUAL
11182: IFTRUE 11186
11184: GO 11378
11186: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
11187: LD_ADDR_VAR 0 1
11191: PUSH
11192: LD_INT 2
11194: PUSH
11195: LD_INT 3
11197: PUSH
11198: LD_INT 4
11200: PUSH
11201: LD_INT 5
11203: PUSH
11204: LD_INT 6
11206: PUSH
11207: LD_INT 7
11209: PUSH
11210: LD_INT 8
11212: PUSH
11213: LD_INT 9
11215: PUSH
11216: LD_INT 10
11218: PUSH
11219: LD_INT 11
11221: PUSH
11222: LD_INT 12
11224: PUSH
11225: LD_INT 13
11227: PUSH
11228: LD_INT 14
11230: PUSH
11231: LD_INT 15
11233: PUSH
11234: LD_INT 16
11236: PUSH
11237: LD_INT 17
11239: PUSH
11240: LD_INT 18
11242: PUSH
11243: LD_INT 19
11245: PUSH
11246: LD_INT 20
11248: PUSH
11249: LD_INT 21
11251: PUSH
11252: LD_INT 22
11254: PUSH
11255: LD_INT 23
11257: PUSH
11258: LD_INT 24
11260: PUSH
11261: LD_INT 25
11263: PUSH
11264: LD_INT 26
11266: PUSH
11267: LD_INT 28
11269: PUSH
11270: LD_INT 30
11272: PUSH
11273: LD_INT 31
11275: PUSH
11276: LD_INT 32
11278: PUSH
11279: LD_INT 34
11281: PUSH
11282: LD_INT 36
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 101
11320: PUSH
11321: LD_INT 102
11323: PUSH
11324: LD_INT 103
11326: PUSH
11327: LD_INT 104
11329: PUSH
11330: LD_INT 105
11332: PUSH
11333: LD_INT 106
11335: PUSH
11336: LD_INT 107
11338: PUSH
11339: LD_INT 108
11341: PUSH
11342: LD_INT 109
11344: PUSH
11345: LD_INT 110
11347: PUSH
11348: LD_INT 111
11350: PUSH
11351: LD_INT 112
11353: PUSH
11354: LD_INT 114
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: LIST
11367: LIST
11368: LIST
11369: LIST
11370: LIST
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: ST_TO_ADDR
11376: GO 12963
11378: LD_INT 12
11380: DOUBLE
11381: EQUAL
11382: IFTRUE 11386
11384: GO 11594
11386: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
11387: LD_ADDR_VAR 0 1
11391: PUSH
11392: LD_INT 1
11394: PUSH
11395: LD_INT 2
11397: PUSH
11398: LD_INT 3
11400: PUSH
11401: LD_INT 4
11403: PUSH
11404: LD_INT 5
11406: PUSH
11407: LD_INT 6
11409: PUSH
11410: LD_INT 7
11412: PUSH
11413: LD_INT 8
11415: PUSH
11416: LD_INT 9
11418: PUSH
11419: LD_INT 10
11421: PUSH
11422: LD_INT 11
11424: PUSH
11425: LD_INT 12
11427: PUSH
11428: LD_INT 13
11430: PUSH
11431: LD_INT 14
11433: PUSH
11434: LD_INT 15
11436: PUSH
11437: LD_INT 16
11439: PUSH
11440: LD_INT 17
11442: PUSH
11443: LD_INT 18
11445: PUSH
11446: LD_INT 19
11448: PUSH
11449: LD_INT 20
11451: PUSH
11452: LD_INT 21
11454: PUSH
11455: LD_INT 22
11457: PUSH
11458: LD_INT 23
11460: PUSH
11461: LD_INT 24
11463: PUSH
11464: LD_INT 25
11466: PUSH
11467: LD_INT 26
11469: PUSH
11470: LD_INT 27
11472: PUSH
11473: LD_INT 28
11475: PUSH
11476: LD_INT 30
11478: PUSH
11479: LD_INT 31
11481: PUSH
11482: LD_INT 32
11484: PUSH
11485: LD_INT 33
11487: PUSH
11488: LD_INT 34
11490: PUSH
11491: LD_INT 36
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_INT 101
11532: PUSH
11533: LD_INT 102
11535: PUSH
11536: LD_INT 103
11538: PUSH
11539: LD_INT 104
11541: PUSH
11542: LD_INT 105
11544: PUSH
11545: LD_INT 106
11547: PUSH
11548: LD_INT 107
11550: PUSH
11551: LD_INT 108
11553: PUSH
11554: LD_INT 109
11556: PUSH
11557: LD_INT 110
11559: PUSH
11560: LD_INT 111
11562: PUSH
11563: LD_INT 112
11565: PUSH
11566: LD_INT 113
11568: PUSH
11569: LD_INT 114
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: ST_TO_ADDR
11592: GO 12963
11594: LD_INT 13
11596: DOUBLE
11597: EQUAL
11598: IFTRUE 11602
11600: GO 11798
11602: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
11603: LD_ADDR_VAR 0 1
11607: PUSH
11608: LD_INT 1
11610: PUSH
11611: LD_INT 2
11613: PUSH
11614: LD_INT 3
11616: PUSH
11617: LD_INT 4
11619: PUSH
11620: LD_INT 5
11622: PUSH
11623: LD_INT 8
11625: PUSH
11626: LD_INT 9
11628: PUSH
11629: LD_INT 10
11631: PUSH
11632: LD_INT 11
11634: PUSH
11635: LD_INT 12
11637: PUSH
11638: LD_INT 14
11640: PUSH
11641: LD_INT 15
11643: PUSH
11644: LD_INT 16
11646: PUSH
11647: LD_INT 17
11649: PUSH
11650: LD_INT 18
11652: PUSH
11653: LD_INT 19
11655: PUSH
11656: LD_INT 20
11658: PUSH
11659: LD_INT 21
11661: PUSH
11662: LD_INT 22
11664: PUSH
11665: LD_INT 23
11667: PUSH
11668: LD_INT 24
11670: PUSH
11671: LD_INT 25
11673: PUSH
11674: LD_INT 26
11676: PUSH
11677: LD_INT 27
11679: PUSH
11680: LD_INT 28
11682: PUSH
11683: LD_INT 30
11685: PUSH
11686: LD_INT 31
11688: PUSH
11689: LD_INT 32
11691: PUSH
11692: LD_INT 33
11694: PUSH
11695: LD_INT 34
11697: PUSH
11698: LD_INT 36
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 101
11736: PUSH
11737: LD_INT 102
11739: PUSH
11740: LD_INT 103
11742: PUSH
11743: LD_INT 104
11745: PUSH
11746: LD_INT 105
11748: PUSH
11749: LD_INT 106
11751: PUSH
11752: LD_INT 107
11754: PUSH
11755: LD_INT 108
11757: PUSH
11758: LD_INT 109
11760: PUSH
11761: LD_INT 110
11763: PUSH
11764: LD_INT 111
11766: PUSH
11767: LD_INT 112
11769: PUSH
11770: LD_INT 113
11772: PUSH
11773: LD_INT 114
11775: PUSH
11776: EMPTY
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: ST_TO_ADDR
11796: GO 12963
11798: LD_INT 14
11800: DOUBLE
11801: EQUAL
11802: IFTRUE 11806
11804: GO 12018
11806: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
11807: LD_ADDR_VAR 0 1
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: LD_INT 2
11817: PUSH
11818: LD_INT 3
11820: PUSH
11821: LD_INT 4
11823: PUSH
11824: LD_INT 5
11826: PUSH
11827: LD_INT 6
11829: PUSH
11830: LD_INT 7
11832: PUSH
11833: LD_INT 8
11835: PUSH
11836: LD_INT 9
11838: PUSH
11839: LD_INT 10
11841: PUSH
11842: LD_INT 11
11844: PUSH
11845: LD_INT 12
11847: PUSH
11848: LD_INT 13
11850: PUSH
11851: LD_INT 14
11853: PUSH
11854: LD_INT 15
11856: PUSH
11857: LD_INT 16
11859: PUSH
11860: LD_INT 17
11862: PUSH
11863: LD_INT 18
11865: PUSH
11866: LD_INT 19
11868: PUSH
11869: LD_INT 20
11871: PUSH
11872: LD_INT 21
11874: PUSH
11875: LD_INT 22
11877: PUSH
11878: LD_INT 23
11880: PUSH
11881: LD_INT 24
11883: PUSH
11884: LD_INT 25
11886: PUSH
11887: LD_INT 26
11889: PUSH
11890: LD_INT 27
11892: PUSH
11893: LD_INT 28
11895: PUSH
11896: LD_INT 29
11898: PUSH
11899: LD_INT 30
11901: PUSH
11902: LD_INT 31
11904: PUSH
11905: LD_INT 32
11907: PUSH
11908: LD_INT 33
11910: PUSH
11911: LD_INT 34
11913: PUSH
11914: LD_INT 36
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: LIST
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: LIST
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: LIST
11939: LIST
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: LIST
11949: LIST
11950: LIST
11951: LIST
11952: LIST
11953: PUSH
11954: LD_INT 101
11956: PUSH
11957: LD_INT 102
11959: PUSH
11960: LD_INT 103
11962: PUSH
11963: LD_INT 104
11965: PUSH
11966: LD_INT 105
11968: PUSH
11969: LD_INT 106
11971: PUSH
11972: LD_INT 107
11974: PUSH
11975: LD_INT 108
11977: PUSH
11978: LD_INT 109
11980: PUSH
11981: LD_INT 110
11983: PUSH
11984: LD_INT 111
11986: PUSH
11987: LD_INT 112
11989: PUSH
11990: LD_INT 113
11992: PUSH
11993: LD_INT 114
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: ST_TO_ADDR
12016: GO 12963
12018: LD_INT 15
12020: DOUBLE
12021: EQUAL
12022: IFTRUE 12026
12024: GO 12238
12026: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
12027: LD_ADDR_VAR 0 1
12031: PUSH
12032: LD_INT 1
12034: PUSH
12035: LD_INT 2
12037: PUSH
12038: LD_INT 3
12040: PUSH
12041: LD_INT 4
12043: PUSH
12044: LD_INT 5
12046: PUSH
12047: LD_INT 6
12049: PUSH
12050: LD_INT 7
12052: PUSH
12053: LD_INT 8
12055: PUSH
12056: LD_INT 9
12058: PUSH
12059: LD_INT 10
12061: PUSH
12062: LD_INT 11
12064: PUSH
12065: LD_INT 12
12067: PUSH
12068: LD_INT 13
12070: PUSH
12071: LD_INT 14
12073: PUSH
12074: LD_INT 15
12076: PUSH
12077: LD_INT 16
12079: PUSH
12080: LD_INT 17
12082: PUSH
12083: LD_INT 18
12085: PUSH
12086: LD_INT 19
12088: PUSH
12089: LD_INT 20
12091: PUSH
12092: LD_INT 21
12094: PUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 23
12100: PUSH
12101: LD_INT 24
12103: PUSH
12104: LD_INT 25
12106: PUSH
12107: LD_INT 26
12109: PUSH
12110: LD_INT 27
12112: PUSH
12113: LD_INT 28
12115: PUSH
12116: LD_INT 29
12118: PUSH
12119: LD_INT 30
12121: PUSH
12122: LD_INT 31
12124: PUSH
12125: LD_INT 32
12127: PUSH
12128: LD_INT 33
12130: PUSH
12131: LD_INT 34
12133: PUSH
12134: LD_INT 36
12136: PUSH
12137: EMPTY
12138: LIST
12139: LIST
12140: LIST
12141: LIST
12142: LIST
12143: LIST
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: PUSH
12174: LD_INT 101
12176: PUSH
12177: LD_INT 102
12179: PUSH
12180: LD_INT 103
12182: PUSH
12183: LD_INT 104
12185: PUSH
12186: LD_INT 105
12188: PUSH
12189: LD_INT 106
12191: PUSH
12192: LD_INT 107
12194: PUSH
12195: LD_INT 108
12197: PUSH
12198: LD_INT 109
12200: PUSH
12201: LD_INT 110
12203: PUSH
12204: LD_INT 111
12206: PUSH
12207: LD_INT 112
12209: PUSH
12210: LD_INT 113
12212: PUSH
12213: LD_INT 114
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: LIST
12223: LIST
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: LIST
12229: LIST
12230: LIST
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: ST_TO_ADDR
12236: GO 12963
12238: LD_INT 16
12240: DOUBLE
12241: EQUAL
12242: IFTRUE 12246
12244: GO 12370
12246: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
12247: LD_ADDR_VAR 0 1
12251: PUSH
12252: LD_INT 2
12254: PUSH
12255: LD_INT 4
12257: PUSH
12258: LD_INT 5
12260: PUSH
12261: LD_INT 7
12263: PUSH
12264: LD_INT 11
12266: PUSH
12267: LD_INT 12
12269: PUSH
12270: LD_INT 15
12272: PUSH
12273: LD_INT 16
12275: PUSH
12276: LD_INT 20
12278: PUSH
12279: LD_INT 21
12281: PUSH
12282: LD_INT 22
12284: PUSH
12285: LD_INT 23
12287: PUSH
12288: LD_INT 25
12290: PUSH
12291: LD_INT 26
12293: PUSH
12294: LD_INT 30
12296: PUSH
12297: LD_INT 31
12299: PUSH
12300: LD_INT 32
12302: PUSH
12303: LD_INT 33
12305: PUSH
12306: LD_INT 34
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 101
12332: PUSH
12333: LD_INT 102
12335: PUSH
12336: LD_INT 103
12338: PUSH
12339: LD_INT 106
12341: PUSH
12342: LD_INT 108
12344: PUSH
12345: LD_INT 112
12347: PUSH
12348: LD_INT 113
12350: PUSH
12351: LD_INT 114
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: ST_TO_ADDR
12368: GO 12963
12370: LD_INT 17
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12590
12378: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
12379: LD_ADDR_VAR 0 1
12383: PUSH
12384: LD_INT 1
12386: PUSH
12387: LD_INT 2
12389: PUSH
12390: LD_INT 3
12392: PUSH
12393: LD_INT 4
12395: PUSH
12396: LD_INT 5
12398: PUSH
12399: LD_INT 6
12401: PUSH
12402: LD_INT 7
12404: PUSH
12405: LD_INT 8
12407: PUSH
12408: LD_INT 9
12410: PUSH
12411: LD_INT 10
12413: PUSH
12414: LD_INT 11
12416: PUSH
12417: LD_INT 12
12419: PUSH
12420: LD_INT 13
12422: PUSH
12423: LD_INT 14
12425: PUSH
12426: LD_INT 15
12428: PUSH
12429: LD_INT 16
12431: PUSH
12432: LD_INT 17
12434: PUSH
12435: LD_INT 18
12437: PUSH
12438: LD_INT 19
12440: PUSH
12441: LD_INT 20
12443: PUSH
12444: LD_INT 21
12446: PUSH
12447: LD_INT 22
12449: PUSH
12450: LD_INT 23
12452: PUSH
12453: LD_INT 24
12455: PUSH
12456: LD_INT 25
12458: PUSH
12459: LD_INT 26
12461: PUSH
12462: LD_INT 27
12464: PUSH
12465: LD_INT 28
12467: PUSH
12468: LD_INT 29
12470: PUSH
12471: LD_INT 30
12473: PUSH
12474: LD_INT 31
12476: PUSH
12477: LD_INT 32
12479: PUSH
12480: LD_INT 33
12482: PUSH
12483: LD_INT 34
12485: PUSH
12486: LD_INT 36
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 101
12528: PUSH
12529: LD_INT 102
12531: PUSH
12532: LD_INT 103
12534: PUSH
12535: LD_INT 104
12537: PUSH
12538: LD_INT 105
12540: PUSH
12541: LD_INT 106
12543: PUSH
12544: LD_INT 107
12546: PUSH
12547: LD_INT 108
12549: PUSH
12550: LD_INT 109
12552: PUSH
12553: LD_INT 110
12555: PUSH
12556: LD_INT 111
12558: PUSH
12559: LD_INT 112
12561: PUSH
12562: LD_INT 113
12564: PUSH
12565: LD_INT 114
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: LIST
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: ST_TO_ADDR
12588: GO 12963
12590: LD_INT 18
12592: DOUBLE
12593: EQUAL
12594: IFTRUE 12598
12596: GO 12734
12598: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
12599: LD_ADDR_VAR 0 1
12603: PUSH
12604: LD_INT 2
12606: PUSH
12607: LD_INT 4
12609: PUSH
12610: LD_INT 5
12612: PUSH
12613: LD_INT 7
12615: PUSH
12616: LD_INT 11
12618: PUSH
12619: LD_INT 12
12621: PUSH
12622: LD_INT 15
12624: PUSH
12625: LD_INT 16
12627: PUSH
12628: LD_INT 20
12630: PUSH
12631: LD_INT 21
12633: PUSH
12634: LD_INT 22
12636: PUSH
12637: LD_INT 23
12639: PUSH
12640: LD_INT 25
12642: PUSH
12643: LD_INT 26
12645: PUSH
12646: LD_INT 30
12648: PUSH
12649: LD_INT 31
12651: PUSH
12652: LD_INT 32
12654: PUSH
12655: LD_INT 33
12657: PUSH
12658: LD_INT 34
12660: PUSH
12661: LD_INT 35
12663: PUSH
12664: LD_INT 36
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: LIST
12687: LIST
12688: LIST
12689: PUSH
12690: LD_INT 101
12692: PUSH
12693: LD_INT 102
12695: PUSH
12696: LD_INT 103
12698: PUSH
12699: LD_INT 106
12701: PUSH
12702: LD_INT 108
12704: PUSH
12705: LD_INT 112
12707: PUSH
12708: LD_INT 113
12710: PUSH
12711: LD_INT 114
12713: PUSH
12714: LD_INT 115
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: ST_TO_ADDR
12732: GO 12963
12734: LD_INT 19
12736: DOUBLE
12737: EQUAL
12738: IFTRUE 12742
12740: GO 12962
12742: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
12743: LD_ADDR_VAR 0 1
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: LD_INT 2
12753: PUSH
12754: LD_INT 3
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: LD_INT 5
12762: PUSH
12763: LD_INT 6
12765: PUSH
12766: LD_INT 7
12768: PUSH
12769: LD_INT 8
12771: PUSH
12772: LD_INT 9
12774: PUSH
12775: LD_INT 10
12777: PUSH
12778: LD_INT 11
12780: PUSH
12781: LD_INT 12
12783: PUSH
12784: LD_INT 13
12786: PUSH
12787: LD_INT 14
12789: PUSH
12790: LD_INT 15
12792: PUSH
12793: LD_INT 16
12795: PUSH
12796: LD_INT 17
12798: PUSH
12799: LD_INT 18
12801: PUSH
12802: LD_INT 19
12804: PUSH
12805: LD_INT 20
12807: PUSH
12808: LD_INT 21
12810: PUSH
12811: LD_INT 22
12813: PUSH
12814: LD_INT 23
12816: PUSH
12817: LD_INT 24
12819: PUSH
12820: LD_INT 25
12822: PUSH
12823: LD_INT 26
12825: PUSH
12826: LD_INT 27
12828: PUSH
12829: LD_INT 28
12831: PUSH
12832: LD_INT 29
12834: PUSH
12835: LD_INT 30
12837: PUSH
12838: LD_INT 31
12840: PUSH
12841: LD_INT 32
12843: PUSH
12844: LD_INT 33
12846: PUSH
12847: LD_INT 34
12849: PUSH
12850: LD_INT 35
12852: PUSH
12853: LD_INT 36
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 101
12896: PUSH
12897: LD_INT 102
12899: PUSH
12900: LD_INT 103
12902: PUSH
12903: LD_INT 104
12905: PUSH
12906: LD_INT 105
12908: PUSH
12909: LD_INT 106
12911: PUSH
12912: LD_INT 107
12914: PUSH
12915: LD_INT 108
12917: PUSH
12918: LD_INT 109
12920: PUSH
12921: LD_INT 110
12923: PUSH
12924: LD_INT 111
12926: PUSH
12927: LD_INT 112
12929: PUSH
12930: LD_INT 113
12932: PUSH
12933: LD_INT 114
12935: PUSH
12936: LD_INT 115
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: ST_TO_ADDR
12960: GO 12963
12962: POP
// end else
12963: GO 13182
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
12965: LD_ADDR_VAR 0 1
12969: PUSH
12970: LD_INT 1
12972: PUSH
12973: LD_INT 2
12975: PUSH
12976: LD_INT 3
12978: PUSH
12979: LD_INT 4
12981: PUSH
12982: LD_INT 5
12984: PUSH
12985: LD_INT 6
12987: PUSH
12988: LD_INT 7
12990: PUSH
12991: LD_INT 8
12993: PUSH
12994: LD_INT 9
12996: PUSH
12997: LD_INT 10
12999: PUSH
13000: LD_INT 11
13002: PUSH
13003: LD_INT 12
13005: PUSH
13006: LD_INT 13
13008: PUSH
13009: LD_INT 14
13011: PUSH
13012: LD_INT 15
13014: PUSH
13015: LD_INT 16
13017: PUSH
13018: LD_INT 17
13020: PUSH
13021: LD_INT 18
13023: PUSH
13024: LD_INT 19
13026: PUSH
13027: LD_INT 20
13029: PUSH
13030: LD_INT 21
13032: PUSH
13033: LD_INT 22
13035: PUSH
13036: LD_INT 23
13038: PUSH
13039: LD_INT 24
13041: PUSH
13042: LD_INT 25
13044: PUSH
13045: LD_INT 26
13047: PUSH
13048: LD_INT 27
13050: PUSH
13051: LD_INT 28
13053: PUSH
13054: LD_INT 29
13056: PUSH
13057: LD_INT 30
13059: PUSH
13060: LD_INT 31
13062: PUSH
13063: LD_INT 32
13065: PUSH
13066: LD_INT 33
13068: PUSH
13069: LD_INT 34
13071: PUSH
13072: LD_INT 35
13074: PUSH
13075: LD_INT 36
13077: PUSH
13078: EMPTY
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: PUSH
13116: LD_INT 101
13118: PUSH
13119: LD_INT 102
13121: PUSH
13122: LD_INT 103
13124: PUSH
13125: LD_INT 104
13127: PUSH
13128: LD_INT 105
13130: PUSH
13131: LD_INT 106
13133: PUSH
13134: LD_INT 107
13136: PUSH
13137: LD_INT 108
13139: PUSH
13140: LD_INT 109
13142: PUSH
13143: LD_INT 110
13145: PUSH
13146: LD_INT 111
13148: PUSH
13149: LD_INT 112
13151: PUSH
13152: LD_INT 113
13154: PUSH
13155: LD_INT 114
13157: PUSH
13158: LD_INT 115
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: ST_TO_ADDR
// if result then
13182: LD_VAR 0 1
13186: IFFALSE 13475
// begin normal :=  ;
13188: LD_ADDR_VAR 0 3
13192: PUSH
13193: LD_STRING 
13195: ST_TO_ADDR
// hardcore :=  ;
13196: LD_ADDR_VAR 0 4
13200: PUSH
13201: LD_STRING 
13203: ST_TO_ADDR
// for i = 1 to normalCounter do
13204: LD_ADDR_VAR 0 5
13208: PUSH
13209: DOUBLE
13210: LD_INT 1
13212: DEC
13213: ST_TO_ADDR
13214: LD_EXP 39
13218: PUSH
13219: FOR_TO
13220: IFFALSE 13321
// begin tmp := 0 ;
13222: LD_ADDR_VAR 0 2
13226: PUSH
13227: LD_STRING 0
13229: ST_TO_ADDR
// if result [ 1 ] then
13230: LD_VAR 0 1
13234: PUSH
13235: LD_INT 1
13237: ARRAY
13238: IFFALSE 13303
// if result [ 1 ] [ 1 ] = i then
13240: LD_VAR 0 1
13244: PUSH
13245: LD_INT 1
13247: ARRAY
13248: PUSH
13249: LD_INT 1
13251: ARRAY
13252: PUSH
13253: LD_VAR 0 5
13257: EQUAL
13258: IFFALSE 13303
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
13260: LD_ADDR_VAR 0 1
13264: PUSH
13265: LD_VAR 0 1
13269: PPUSH
13270: LD_INT 1
13272: PPUSH
13273: LD_VAR 0 1
13277: PUSH
13278: LD_INT 1
13280: ARRAY
13281: PPUSH
13282: LD_INT 1
13284: PPUSH
13285: CALL_OW 3
13289: PPUSH
13290: CALL_OW 1
13294: ST_TO_ADDR
// tmp := 1 ;
13295: LD_ADDR_VAR 0 2
13299: PUSH
13300: LD_STRING 1
13302: ST_TO_ADDR
// end ; normal := normal & tmp ;
13303: LD_ADDR_VAR 0 3
13307: PUSH
13308: LD_VAR 0 3
13312: PUSH
13313: LD_VAR 0 2
13317: STR
13318: ST_TO_ADDR
// end ;
13319: GO 13219
13321: POP
13322: POP
// for i = 1 to hardcoreCounter do
13323: LD_ADDR_VAR 0 5
13327: PUSH
13328: DOUBLE
13329: LD_INT 1
13331: DEC
13332: ST_TO_ADDR
13333: LD_EXP 40
13337: PUSH
13338: FOR_TO
13339: IFFALSE 13444
// begin tmp := 0 ;
13341: LD_ADDR_VAR 0 2
13345: PUSH
13346: LD_STRING 0
13348: ST_TO_ADDR
// if result [ 2 ] then
13349: LD_VAR 0 1
13353: PUSH
13354: LD_INT 2
13356: ARRAY
13357: IFFALSE 13426
// if result [ 2 ] [ 1 ] = 100 + i then
13359: LD_VAR 0 1
13363: PUSH
13364: LD_INT 2
13366: ARRAY
13367: PUSH
13368: LD_INT 1
13370: ARRAY
13371: PUSH
13372: LD_INT 100
13374: PUSH
13375: LD_VAR 0 5
13379: PLUS
13380: EQUAL
13381: IFFALSE 13426
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
13383: LD_ADDR_VAR 0 1
13387: PUSH
13388: LD_VAR 0 1
13392: PPUSH
13393: LD_INT 2
13395: PPUSH
13396: LD_VAR 0 1
13400: PUSH
13401: LD_INT 2
13403: ARRAY
13404: PPUSH
13405: LD_INT 1
13407: PPUSH
13408: CALL_OW 3
13412: PPUSH
13413: CALL_OW 1
13417: ST_TO_ADDR
// tmp := 1 ;
13418: LD_ADDR_VAR 0 2
13422: PUSH
13423: LD_STRING 1
13425: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
13426: LD_ADDR_VAR 0 4
13430: PUSH
13431: LD_VAR 0 4
13435: PUSH
13436: LD_VAR 0 2
13440: STR
13441: ST_TO_ADDR
// end ;
13442: GO 13338
13444: POP
13445: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
13446: LD_STRING getStreamItemsFromMission("
13448: PUSH
13449: LD_VAR 0 3
13453: STR
13454: PUSH
13455: LD_STRING ","
13457: STR
13458: PUSH
13459: LD_VAR 0 4
13463: STR
13464: PUSH
13465: LD_STRING ")
13467: STR
13468: PPUSH
13469: CALL_OW 559
// end else
13473: GO 13482
// ToLua ( getStreamItemsFromMission("","") ) ;
13475: LD_STRING getStreamItemsFromMission("","")
13477: PPUSH
13478: CALL_OW 559
// end ;
13482: LD_VAR 0 1
13486: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
13487: LD_VAR 0 2
13491: PUSH
13492: LD_INT 100
13494: EQUAL
13495: IFFALSE 14444
// begin if not StreamModeActive then
13497: LD_EXP 38
13501: NOT
13502: IFFALSE 13512
// StreamModeActive := true ;
13504: LD_ADDR_EXP 38
13508: PUSH
13509: LD_INT 1
13511: ST_TO_ADDR
// if p3 = 0 then
13512: LD_VAR 0 3
13516: PUSH
13517: LD_INT 0
13519: EQUAL
13520: IFFALSE 13526
// InitStreamMode ;
13522: CALL 9565 0 0
// if p3 = 1 then
13526: LD_VAR 0 3
13530: PUSH
13531: LD_INT 1
13533: EQUAL
13534: IFFALSE 13544
// sRocket := true ;
13536: LD_ADDR_EXP 43
13540: PUSH
13541: LD_INT 1
13543: ST_TO_ADDR
// if p3 = 2 then
13544: LD_VAR 0 3
13548: PUSH
13549: LD_INT 2
13551: EQUAL
13552: IFFALSE 13562
// sSpeed := true ;
13554: LD_ADDR_EXP 42
13558: PUSH
13559: LD_INT 1
13561: ST_TO_ADDR
// if p3 = 3 then
13562: LD_VAR 0 3
13566: PUSH
13567: LD_INT 3
13569: EQUAL
13570: IFFALSE 13580
// sEngine := true ;
13572: LD_ADDR_EXP 44
13576: PUSH
13577: LD_INT 1
13579: ST_TO_ADDR
// if p3 = 4 then
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 4
13587: EQUAL
13588: IFFALSE 13598
// sSpec := true ;
13590: LD_ADDR_EXP 41
13594: PUSH
13595: LD_INT 1
13597: ST_TO_ADDR
// if p3 = 5 then
13598: LD_VAR 0 3
13602: PUSH
13603: LD_INT 5
13605: EQUAL
13606: IFFALSE 13616
// sLevel := true ;
13608: LD_ADDR_EXP 45
13612: PUSH
13613: LD_INT 1
13615: ST_TO_ADDR
// if p3 = 6 then
13616: LD_VAR 0 3
13620: PUSH
13621: LD_INT 6
13623: EQUAL
13624: IFFALSE 13634
// sArmoury := true ;
13626: LD_ADDR_EXP 46
13630: PUSH
13631: LD_INT 1
13633: ST_TO_ADDR
// if p3 = 7 then
13634: LD_VAR 0 3
13638: PUSH
13639: LD_INT 7
13641: EQUAL
13642: IFFALSE 13652
// sRadar := true ;
13644: LD_ADDR_EXP 47
13648: PUSH
13649: LD_INT 1
13651: ST_TO_ADDR
// if p3 = 8 then
13652: LD_VAR 0 3
13656: PUSH
13657: LD_INT 8
13659: EQUAL
13660: IFFALSE 13670
// sBunker := true ;
13662: LD_ADDR_EXP 48
13666: PUSH
13667: LD_INT 1
13669: ST_TO_ADDR
// if p3 = 9 then
13670: LD_VAR 0 3
13674: PUSH
13675: LD_INT 9
13677: EQUAL
13678: IFFALSE 13688
// sHack := true ;
13680: LD_ADDR_EXP 49
13684: PUSH
13685: LD_INT 1
13687: ST_TO_ADDR
// if p3 = 10 then
13688: LD_VAR 0 3
13692: PUSH
13693: LD_INT 10
13695: EQUAL
13696: IFFALSE 13706
// sFire := true ;
13698: LD_ADDR_EXP 50
13702: PUSH
13703: LD_INT 1
13705: ST_TO_ADDR
// if p3 = 11 then
13706: LD_VAR 0 3
13710: PUSH
13711: LD_INT 11
13713: EQUAL
13714: IFFALSE 13724
// sRefresh := true ;
13716: LD_ADDR_EXP 51
13720: PUSH
13721: LD_INT 1
13723: ST_TO_ADDR
// if p3 = 12 then
13724: LD_VAR 0 3
13728: PUSH
13729: LD_INT 12
13731: EQUAL
13732: IFFALSE 13742
// sExp := true ;
13734: LD_ADDR_EXP 52
13738: PUSH
13739: LD_INT 1
13741: ST_TO_ADDR
// if p3 = 13 then
13742: LD_VAR 0 3
13746: PUSH
13747: LD_INT 13
13749: EQUAL
13750: IFFALSE 13760
// sDepot := true ;
13752: LD_ADDR_EXP 53
13756: PUSH
13757: LD_INT 1
13759: ST_TO_ADDR
// if p3 = 14 then
13760: LD_VAR 0 3
13764: PUSH
13765: LD_INT 14
13767: EQUAL
13768: IFFALSE 13778
// sFlag := true ;
13770: LD_ADDR_EXP 54
13774: PUSH
13775: LD_INT 1
13777: ST_TO_ADDR
// if p3 = 15 then
13778: LD_VAR 0 3
13782: PUSH
13783: LD_INT 15
13785: EQUAL
13786: IFFALSE 13796
// sKamikadze := true ;
13788: LD_ADDR_EXP 62
13792: PUSH
13793: LD_INT 1
13795: ST_TO_ADDR
// if p3 = 16 then
13796: LD_VAR 0 3
13800: PUSH
13801: LD_INT 16
13803: EQUAL
13804: IFFALSE 13814
// sTroll := true ;
13806: LD_ADDR_EXP 63
13810: PUSH
13811: LD_INT 1
13813: ST_TO_ADDR
// if p3 = 17 then
13814: LD_VAR 0 3
13818: PUSH
13819: LD_INT 17
13821: EQUAL
13822: IFFALSE 13832
// sSlow := true ;
13824: LD_ADDR_EXP 64
13828: PUSH
13829: LD_INT 1
13831: ST_TO_ADDR
// if p3 = 18 then
13832: LD_VAR 0 3
13836: PUSH
13837: LD_INT 18
13839: EQUAL
13840: IFFALSE 13850
// sLack := true ;
13842: LD_ADDR_EXP 65
13846: PUSH
13847: LD_INT 1
13849: ST_TO_ADDR
// if p3 = 19 then
13850: LD_VAR 0 3
13854: PUSH
13855: LD_INT 19
13857: EQUAL
13858: IFFALSE 13868
// sTank := true ;
13860: LD_ADDR_EXP 67
13864: PUSH
13865: LD_INT 1
13867: ST_TO_ADDR
// if p3 = 20 then
13868: LD_VAR 0 3
13872: PUSH
13873: LD_INT 20
13875: EQUAL
13876: IFFALSE 13886
// sRemote := true ;
13878: LD_ADDR_EXP 68
13882: PUSH
13883: LD_INT 1
13885: ST_TO_ADDR
// if p3 = 21 then
13886: LD_VAR 0 3
13890: PUSH
13891: LD_INT 21
13893: EQUAL
13894: IFFALSE 13904
// sPowell := true ;
13896: LD_ADDR_EXP 69
13900: PUSH
13901: LD_INT 1
13903: ST_TO_ADDR
// if p3 = 22 then
13904: LD_VAR 0 3
13908: PUSH
13909: LD_INT 22
13911: EQUAL
13912: IFFALSE 13922
// sTeleport := true ;
13914: LD_ADDR_EXP 72
13918: PUSH
13919: LD_INT 1
13921: ST_TO_ADDR
// if p3 = 23 then
13922: LD_VAR 0 3
13926: PUSH
13927: LD_INT 23
13929: EQUAL
13930: IFFALSE 13940
// sOilTower := true ;
13932: LD_ADDR_EXP 74
13936: PUSH
13937: LD_INT 1
13939: ST_TO_ADDR
// if p3 = 24 then
13940: LD_VAR 0 3
13944: PUSH
13945: LD_INT 24
13947: EQUAL
13948: IFFALSE 13958
// sShovel := true ;
13950: LD_ADDR_EXP 75
13954: PUSH
13955: LD_INT 1
13957: ST_TO_ADDR
// if p3 = 25 then
13958: LD_VAR 0 3
13962: PUSH
13963: LD_INT 25
13965: EQUAL
13966: IFFALSE 13976
// sSheik := true ;
13968: LD_ADDR_EXP 76
13972: PUSH
13973: LD_INT 1
13975: ST_TO_ADDR
// if p3 = 26 then
13976: LD_VAR 0 3
13980: PUSH
13981: LD_INT 26
13983: EQUAL
13984: IFFALSE 13994
// sEarthquake := true ;
13986: LD_ADDR_EXP 78
13990: PUSH
13991: LD_INT 1
13993: ST_TO_ADDR
// if p3 = 27 then
13994: LD_VAR 0 3
13998: PUSH
13999: LD_INT 27
14001: EQUAL
14002: IFFALSE 14012
// sAI := true ;
14004: LD_ADDR_EXP 79
14008: PUSH
14009: LD_INT 1
14011: ST_TO_ADDR
// if p3 = 28 then
14012: LD_VAR 0 3
14016: PUSH
14017: LD_INT 28
14019: EQUAL
14020: IFFALSE 14030
// sCargo := true ;
14022: LD_ADDR_EXP 82
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// if p3 = 29 then
14030: LD_VAR 0 3
14034: PUSH
14035: LD_INT 29
14037: EQUAL
14038: IFFALSE 14048
// sDLaser := true ;
14040: LD_ADDR_EXP 83
14044: PUSH
14045: LD_INT 1
14047: ST_TO_ADDR
// if p3 = 30 then
14048: LD_VAR 0 3
14052: PUSH
14053: LD_INT 30
14055: EQUAL
14056: IFFALSE 14066
// sExchange := true ;
14058: LD_ADDR_EXP 84
14062: PUSH
14063: LD_INT 1
14065: ST_TO_ADDR
// if p3 = 31 then
14066: LD_VAR 0 3
14070: PUSH
14071: LD_INT 31
14073: EQUAL
14074: IFFALSE 14084
// sFac := true ;
14076: LD_ADDR_EXP 85
14080: PUSH
14081: LD_INT 1
14083: ST_TO_ADDR
// if p3 = 32 then
14084: LD_VAR 0 3
14088: PUSH
14089: LD_INT 32
14091: EQUAL
14092: IFFALSE 14102
// sPower := true ;
14094: LD_ADDR_EXP 86
14098: PUSH
14099: LD_INT 1
14101: ST_TO_ADDR
// if p3 = 33 then
14102: LD_VAR 0 3
14106: PUSH
14107: LD_INT 33
14109: EQUAL
14110: IFFALSE 14120
// sRandom := true ;
14112: LD_ADDR_EXP 87
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// if p3 = 34 then
14120: LD_VAR 0 3
14124: PUSH
14125: LD_INT 34
14127: EQUAL
14128: IFFALSE 14138
// sShield := true ;
14130: LD_ADDR_EXP 88
14134: PUSH
14135: LD_INT 1
14137: ST_TO_ADDR
// if p3 = 35 then
14138: LD_VAR 0 3
14142: PUSH
14143: LD_INT 35
14145: EQUAL
14146: IFFALSE 14156
// sTime := true ;
14148: LD_ADDR_EXP 89
14152: PUSH
14153: LD_INT 1
14155: ST_TO_ADDR
// if p3 = 36 then
14156: LD_VAR 0 3
14160: PUSH
14161: LD_INT 36
14163: EQUAL
14164: IFFALSE 14174
// sTools := true ;
14166: LD_ADDR_EXP 90
14170: PUSH
14171: LD_INT 1
14173: ST_TO_ADDR
// if p3 = 101 then
14174: LD_VAR 0 3
14178: PUSH
14179: LD_INT 101
14181: EQUAL
14182: IFFALSE 14192
// sSold := true ;
14184: LD_ADDR_EXP 55
14188: PUSH
14189: LD_INT 1
14191: ST_TO_ADDR
// if p3 = 102 then
14192: LD_VAR 0 3
14196: PUSH
14197: LD_INT 102
14199: EQUAL
14200: IFFALSE 14210
// sDiff := true ;
14202: LD_ADDR_EXP 56
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// if p3 = 103 then
14210: LD_VAR 0 3
14214: PUSH
14215: LD_INT 103
14217: EQUAL
14218: IFFALSE 14228
// sFog := true ;
14220: LD_ADDR_EXP 59
14224: PUSH
14225: LD_INT 1
14227: ST_TO_ADDR
// if p3 = 104 then
14228: LD_VAR 0 3
14232: PUSH
14233: LD_INT 104
14235: EQUAL
14236: IFFALSE 14246
// sReset := true ;
14238: LD_ADDR_EXP 60
14242: PUSH
14243: LD_INT 1
14245: ST_TO_ADDR
// if p3 = 105 then
14246: LD_VAR 0 3
14250: PUSH
14251: LD_INT 105
14253: EQUAL
14254: IFFALSE 14264
// sSun := true ;
14256: LD_ADDR_EXP 61
14260: PUSH
14261: LD_INT 1
14263: ST_TO_ADDR
// if p3 = 106 then
14264: LD_VAR 0 3
14268: PUSH
14269: LD_INT 106
14271: EQUAL
14272: IFFALSE 14282
// sTiger := true ;
14274: LD_ADDR_EXP 57
14278: PUSH
14279: LD_INT 1
14281: ST_TO_ADDR
// if p3 = 107 then
14282: LD_VAR 0 3
14286: PUSH
14287: LD_INT 107
14289: EQUAL
14290: IFFALSE 14300
// sBomb := true ;
14292: LD_ADDR_EXP 58
14296: PUSH
14297: LD_INT 1
14299: ST_TO_ADDR
// if p3 = 108 then
14300: LD_VAR 0 3
14304: PUSH
14305: LD_INT 108
14307: EQUAL
14308: IFFALSE 14318
// sWound := true ;
14310: LD_ADDR_EXP 66
14314: PUSH
14315: LD_INT 1
14317: ST_TO_ADDR
// if p3 = 109 then
14318: LD_VAR 0 3
14322: PUSH
14323: LD_INT 109
14325: EQUAL
14326: IFFALSE 14336
// sBetray := true ;
14328: LD_ADDR_EXP 70
14332: PUSH
14333: LD_INT 1
14335: ST_TO_ADDR
// if p3 = 110 then
14336: LD_VAR 0 3
14340: PUSH
14341: LD_INT 110
14343: EQUAL
14344: IFFALSE 14354
// sContamin := true ;
14346: LD_ADDR_EXP 71
14350: PUSH
14351: LD_INT 1
14353: ST_TO_ADDR
// if p3 = 111 then
14354: LD_VAR 0 3
14358: PUSH
14359: LD_INT 111
14361: EQUAL
14362: IFFALSE 14372
// sOil := true ;
14364: LD_ADDR_EXP 73
14368: PUSH
14369: LD_INT 1
14371: ST_TO_ADDR
// if p3 = 112 then
14372: LD_VAR 0 3
14376: PUSH
14377: LD_INT 112
14379: EQUAL
14380: IFFALSE 14390
// sStu := true ;
14382: LD_ADDR_EXP 77
14386: PUSH
14387: LD_INT 1
14389: ST_TO_ADDR
// if p3 = 113 then
14390: LD_VAR 0 3
14394: PUSH
14395: LD_INT 113
14397: EQUAL
14398: IFFALSE 14408
// sBazooka := true ;
14400: LD_ADDR_EXP 80
14404: PUSH
14405: LD_INT 1
14407: ST_TO_ADDR
// if p3 = 114 then
14408: LD_VAR 0 3
14412: PUSH
14413: LD_INT 114
14415: EQUAL
14416: IFFALSE 14426
// sMortar := true ;
14418: LD_ADDR_EXP 81
14422: PUSH
14423: LD_INT 1
14425: ST_TO_ADDR
// if p3 = 115 then
14426: LD_VAR 0 3
14430: PUSH
14431: LD_INT 115
14433: EQUAL
14434: IFFALSE 14444
// sRanger := true ;
14436: LD_ADDR_EXP 91
14440: PUSH
14441: LD_INT 1
14443: ST_TO_ADDR
// end ; end ;
14444: PPOPN 6
14446: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
14447: LD_EXP 38
14451: PUSH
14452: LD_EXP 43
14456: AND
14457: IFFALSE 14581
14459: GO 14461
14461: DISABLE
14462: LD_INT 0
14464: PPUSH
14465: PPUSH
// begin enable ;
14466: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: LD_INT 22
14474: PUSH
14475: LD_OWVAR 2
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PUSH
14484: LD_INT 2
14486: PUSH
14487: LD_INT 34
14489: PUSH
14490: LD_INT 7
14492: PUSH
14493: EMPTY
14494: LIST
14495: LIST
14496: PUSH
14497: LD_INT 34
14499: PUSH
14500: LD_INT 45
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: PUSH
14507: LD_INT 34
14509: PUSH
14510: LD_INT 28
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: PUSH
14517: LD_INT 34
14519: PUSH
14520: LD_INT 47
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: PUSH
14534: EMPTY
14535: LIST
14536: LIST
14537: PPUSH
14538: CALL_OW 69
14542: ST_TO_ADDR
// if not tmp then
14543: LD_VAR 0 2
14547: NOT
14548: IFFALSE 14552
// exit ;
14550: GO 14581
// for i in tmp do
14552: LD_ADDR_VAR 0 1
14556: PUSH
14557: LD_VAR 0 2
14561: PUSH
14562: FOR_IN
14563: IFFALSE 14579
// begin SetLives ( i , 0 ) ;
14565: LD_VAR 0 1
14569: PPUSH
14570: LD_INT 0
14572: PPUSH
14573: CALL_OW 234
// end ;
14577: GO 14562
14579: POP
14580: POP
// end ;
14581: PPOPN 2
14583: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
14584: LD_EXP 38
14588: PUSH
14589: LD_EXP 44
14593: AND
14594: IFFALSE 14678
14596: GO 14598
14598: DISABLE
14599: LD_INT 0
14601: PPUSH
14602: PPUSH
// begin enable ;
14603: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
14604: LD_ADDR_VAR 0 2
14608: PUSH
14609: LD_INT 22
14611: PUSH
14612: LD_OWVAR 2
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 32
14623: PUSH
14624: LD_INT 3
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: ST_TO_ADDR
// if not tmp then
14640: LD_VAR 0 2
14644: NOT
14645: IFFALSE 14649
// exit ;
14647: GO 14678
// for i in tmp do
14649: LD_ADDR_VAR 0 1
14653: PUSH
14654: LD_VAR 0 2
14658: PUSH
14659: FOR_IN
14660: IFFALSE 14676
// begin SetLives ( i , 0 ) ;
14662: LD_VAR 0 1
14666: PPUSH
14667: LD_INT 0
14669: PPUSH
14670: CALL_OW 234
// end ;
14674: GO 14659
14676: POP
14677: POP
// end ;
14678: PPOPN 2
14680: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
14681: LD_EXP 38
14685: PUSH
14686: LD_EXP 41
14690: AND
14691: IFFALSE 14784
14693: GO 14695
14695: DISABLE
14696: LD_INT 0
14698: PPUSH
// begin enable ;
14699: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
14700: LD_ADDR_VAR 0 1
14704: PUSH
14705: LD_INT 22
14707: PUSH
14708: LD_OWVAR 2
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: PUSH
14717: LD_INT 2
14719: PUSH
14720: LD_INT 25
14722: PUSH
14723: LD_INT 5
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: LD_INT 25
14732: PUSH
14733: LD_INT 9
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: PUSH
14740: LD_INT 25
14742: PUSH
14743: LD_INT 8
14745: PUSH
14746: EMPTY
14747: LIST
14748: LIST
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL_OW 69
14764: PUSH
14765: FOR_IN
14766: IFFALSE 14782
// begin SetClass ( i , 1 ) ;
14768: LD_VAR 0 1
14772: PPUSH
14773: LD_INT 1
14775: PPUSH
14776: CALL_OW 336
// end ;
14780: GO 14765
14782: POP
14783: POP
// end ;
14784: PPOPN 1
14786: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
14787: LD_EXP 38
14791: PUSH
14792: LD_EXP 42
14796: AND
14797: PUSH
14798: LD_OWVAR 65
14802: PUSH
14803: LD_INT 7
14805: LESS
14806: AND
14807: IFFALSE 14821
14809: GO 14811
14811: DISABLE
// begin enable ;
14812: ENABLE
// game_speed := 7 ;
14813: LD_ADDR_OWVAR 65
14817: PUSH
14818: LD_INT 7
14820: ST_TO_ADDR
// end ;
14821: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
14822: LD_EXP 38
14826: PUSH
14827: LD_EXP 45
14831: AND
14832: IFFALSE 15034
14834: GO 14836
14836: DISABLE
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
14841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
14842: LD_ADDR_VAR 0 3
14846: PUSH
14847: LD_INT 81
14849: PUSH
14850: LD_OWVAR 2
14854: PUSH
14855: EMPTY
14856: LIST
14857: LIST
14858: PUSH
14859: LD_INT 21
14861: PUSH
14862: LD_INT 1
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PPUSH
14873: CALL_OW 69
14877: ST_TO_ADDR
// if not tmp then
14878: LD_VAR 0 3
14882: NOT
14883: IFFALSE 14887
// exit ;
14885: GO 15034
// if tmp > 5 then
14887: LD_VAR 0 3
14891: PUSH
14892: LD_INT 5
14894: GREATER
14895: IFFALSE 14907
// k := 5 else
14897: LD_ADDR_VAR 0 2
14901: PUSH
14902: LD_INT 5
14904: ST_TO_ADDR
14905: GO 14917
// k := tmp ;
14907: LD_ADDR_VAR 0 2
14911: PUSH
14912: LD_VAR 0 3
14916: ST_TO_ADDR
// for i := 1 to k do
14917: LD_ADDR_VAR 0 1
14921: PUSH
14922: DOUBLE
14923: LD_INT 1
14925: DEC
14926: ST_TO_ADDR
14927: LD_VAR 0 2
14931: PUSH
14932: FOR_TO
14933: IFFALSE 15032
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_VAR 0 1
14944: ARRAY
14945: PPUSH
14946: LD_VAR 0 1
14950: PUSH
14951: LD_INT 4
14953: MOD
14954: PUSH
14955: LD_INT 1
14957: PLUS
14958: PPUSH
14959: CALL_OW 259
14963: PUSH
14964: LD_INT 10
14966: LESS
14967: IFFALSE 15030
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
14969: LD_VAR 0 3
14973: PUSH
14974: LD_VAR 0 1
14978: ARRAY
14979: PPUSH
14980: LD_VAR 0 1
14984: PUSH
14985: LD_INT 4
14987: MOD
14988: PUSH
14989: LD_INT 1
14991: PLUS
14992: PPUSH
14993: LD_VAR 0 3
14997: PUSH
14998: LD_VAR 0 1
15002: ARRAY
15003: PPUSH
15004: LD_VAR 0 1
15008: PUSH
15009: LD_INT 4
15011: MOD
15012: PUSH
15013: LD_INT 1
15015: PLUS
15016: PPUSH
15017: CALL_OW 259
15021: PUSH
15022: LD_INT 1
15024: PLUS
15025: PPUSH
15026: CALL_OW 237
15030: GO 14932
15032: POP
15033: POP
// end ;
15034: PPOPN 3
15036: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
15037: LD_EXP 38
15041: PUSH
15042: LD_EXP 46
15046: AND
15047: IFFALSE 15067
15049: GO 15051
15051: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
15052: LD_INT 4
15054: PPUSH
15055: LD_OWVAR 2
15059: PPUSH
15060: LD_INT 0
15062: PPUSH
15063: CALL_OW 324
15067: END
// every 0 0$1 trigger StreamModeActive and sShovel do
15068: LD_EXP 38
15072: PUSH
15073: LD_EXP 75
15077: AND
15078: IFFALSE 15098
15080: GO 15082
15082: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
15083: LD_INT 19
15085: PPUSH
15086: LD_OWVAR 2
15090: PPUSH
15091: LD_INT 0
15093: PPUSH
15094: CALL_OW 324
15098: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
15099: LD_EXP 38
15103: PUSH
15104: LD_EXP 47
15108: AND
15109: IFFALSE 15211
15111: GO 15113
15113: DISABLE
15114: LD_INT 0
15116: PPUSH
15117: PPUSH
// begin enable ;
15118: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
15119: LD_ADDR_VAR 0 2
15123: PUSH
15124: LD_INT 22
15126: PUSH
15127: LD_OWVAR 2
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: PUSH
15136: LD_INT 2
15138: PUSH
15139: LD_INT 34
15141: PUSH
15142: LD_INT 11
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: LD_INT 34
15151: PUSH
15152: LD_INT 30
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: LIST
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: PPUSH
15168: CALL_OW 69
15172: ST_TO_ADDR
// if not tmp then
15173: LD_VAR 0 2
15177: NOT
15178: IFFALSE 15182
// exit ;
15180: GO 15211
// for i in tmp do
15182: LD_ADDR_VAR 0 1
15186: PUSH
15187: LD_VAR 0 2
15191: PUSH
15192: FOR_IN
15193: IFFALSE 15209
// begin SetLives ( i , 0 ) ;
15195: LD_VAR 0 1
15199: PPUSH
15200: LD_INT 0
15202: PPUSH
15203: CALL_OW 234
// end ;
15207: GO 15192
15209: POP
15210: POP
// end ;
15211: PPOPN 2
15213: END
// every 0 0$1 trigger StreamModeActive and sBunker do
15214: LD_EXP 38
15218: PUSH
15219: LD_EXP 48
15223: AND
15224: IFFALSE 15244
15226: GO 15228
15228: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
15229: LD_INT 32
15231: PPUSH
15232: LD_OWVAR 2
15236: PPUSH
15237: LD_INT 0
15239: PPUSH
15240: CALL_OW 324
15244: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
15245: LD_EXP 38
15249: PUSH
15250: LD_EXP 49
15254: AND
15255: IFFALSE 15436
15257: GO 15259
15259: DISABLE
15260: LD_INT 0
15262: PPUSH
15263: PPUSH
15264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
15265: LD_ADDR_VAR 0 2
15269: PUSH
15270: LD_INT 22
15272: PUSH
15273: LD_OWVAR 2
15277: PUSH
15278: EMPTY
15279: LIST
15280: LIST
15281: PUSH
15282: LD_INT 33
15284: PUSH
15285: LD_INT 3
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PPUSH
15296: CALL_OW 69
15300: ST_TO_ADDR
// if not tmp then
15301: LD_VAR 0 2
15305: NOT
15306: IFFALSE 15310
// exit ;
15308: GO 15436
// side := 0 ;
15310: LD_ADDR_VAR 0 3
15314: PUSH
15315: LD_INT 0
15317: ST_TO_ADDR
// for i := 1 to 8 do
15318: LD_ADDR_VAR 0 1
15322: PUSH
15323: DOUBLE
15324: LD_INT 1
15326: DEC
15327: ST_TO_ADDR
15328: LD_INT 8
15330: PUSH
15331: FOR_TO
15332: IFFALSE 15380
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
15334: LD_OWVAR 2
15338: PUSH
15339: LD_VAR 0 1
15343: NONEQUAL
15344: PUSH
15345: LD_OWVAR 2
15349: PPUSH
15350: LD_VAR 0 1
15354: PPUSH
15355: CALL_OW 81
15359: PUSH
15360: LD_INT 2
15362: EQUAL
15363: AND
15364: IFFALSE 15378
// begin side := i ;
15366: LD_ADDR_VAR 0 3
15370: PUSH
15371: LD_VAR 0 1
15375: ST_TO_ADDR
// break ;
15376: GO 15380
// end ;
15378: GO 15331
15380: POP
15381: POP
// if not side then
15382: LD_VAR 0 3
15386: NOT
15387: IFFALSE 15391
// exit ;
15389: GO 15436
// for i := 1 to tmp do
15391: LD_ADDR_VAR 0 1
15395: PUSH
15396: DOUBLE
15397: LD_INT 1
15399: DEC
15400: ST_TO_ADDR
15401: LD_VAR 0 2
15405: PUSH
15406: FOR_TO
15407: IFFALSE 15434
// if Prob ( 60 ) then
15409: LD_INT 60
15411: PPUSH
15412: CALL_OW 13
15416: IFFALSE 15432
// SetSide ( i , side ) ;
15418: LD_VAR 0 1
15422: PPUSH
15423: LD_VAR 0 3
15427: PPUSH
15428: CALL_OW 235
15432: GO 15406
15434: POP
15435: POP
// end ;
15436: PPOPN 3
15438: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
15439: LD_EXP 38
15443: PUSH
15444: LD_EXP 51
15448: AND
15449: IFFALSE 15568
15451: GO 15453
15453: DISABLE
15454: LD_INT 0
15456: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
15457: LD_ADDR_VAR 0 1
15461: PUSH
15462: LD_INT 22
15464: PUSH
15465: LD_OWVAR 2
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: PUSH
15474: LD_INT 21
15476: PUSH
15477: LD_INT 1
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PUSH
15484: LD_INT 3
15486: PUSH
15487: LD_INT 23
15489: PUSH
15490: LD_INT 0
15492: PUSH
15493: EMPTY
15494: LIST
15495: LIST
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: LIST
15505: PPUSH
15506: CALL_OW 69
15510: PUSH
15511: FOR_IN
15512: IFFALSE 15566
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
15514: LD_VAR 0 1
15518: PPUSH
15519: CALL_OW 257
15523: PUSH
15524: LD_INT 1
15526: PUSH
15527: LD_INT 2
15529: PUSH
15530: LD_INT 3
15532: PUSH
15533: LD_INT 4
15535: PUSH
15536: EMPTY
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: IN
15542: IFFALSE 15564
// SetClass ( un , rand ( 1 , 4 ) ) ;
15544: LD_VAR 0 1
15548: PPUSH
15549: LD_INT 1
15551: PPUSH
15552: LD_INT 4
15554: PPUSH
15555: CALL_OW 12
15559: PPUSH
15560: CALL_OW 336
15564: GO 15511
15566: POP
15567: POP
// end ;
15568: PPOPN 1
15570: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
15571: LD_EXP 38
15575: PUSH
15576: LD_EXP 50
15580: AND
15581: IFFALSE 15660
15583: GO 15585
15585: DISABLE
15586: LD_INT 0
15588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15589: LD_ADDR_VAR 0 1
15593: PUSH
15594: LD_INT 22
15596: PUSH
15597: LD_OWVAR 2
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 21
15608: PUSH
15609: LD_INT 3
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PPUSH
15620: CALL_OW 69
15624: ST_TO_ADDR
// if not tmp then
15625: LD_VAR 0 1
15629: NOT
15630: IFFALSE 15634
// exit ;
15632: GO 15660
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
15634: LD_VAR 0 1
15638: PUSH
15639: LD_INT 1
15641: PPUSH
15642: LD_VAR 0 1
15646: PPUSH
15647: CALL_OW 12
15651: ARRAY
15652: PPUSH
15653: LD_INT 100
15655: PPUSH
15656: CALL_OW 234
// end ;
15660: PPOPN 1
15662: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
15663: LD_EXP 38
15667: PUSH
15668: LD_EXP 52
15672: AND
15673: IFFALSE 15771
15675: GO 15677
15677: DISABLE
15678: LD_INT 0
15680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15681: LD_ADDR_VAR 0 1
15685: PUSH
15686: LD_INT 22
15688: PUSH
15689: LD_OWVAR 2
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 21
15700: PUSH
15701: LD_INT 1
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PPUSH
15712: CALL_OW 69
15716: ST_TO_ADDR
// if not tmp then
15717: LD_VAR 0 1
15721: NOT
15722: IFFALSE 15726
// exit ;
15724: GO 15771
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
15726: LD_VAR 0 1
15730: PUSH
15731: LD_INT 1
15733: PPUSH
15734: LD_VAR 0 1
15738: PPUSH
15739: CALL_OW 12
15743: ARRAY
15744: PPUSH
15745: LD_INT 1
15747: PPUSH
15748: LD_INT 4
15750: PPUSH
15751: CALL_OW 12
15755: PPUSH
15756: LD_INT 3000
15758: PPUSH
15759: LD_INT 9000
15761: PPUSH
15762: CALL_OW 12
15766: PPUSH
15767: CALL_OW 492
// end ;
15771: PPOPN 1
15773: END
// every 0 0$1 trigger StreamModeActive and sDepot do
15774: LD_EXP 38
15778: PUSH
15779: LD_EXP 53
15783: AND
15784: IFFALSE 15804
15786: GO 15788
15788: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
15789: LD_INT 1
15791: PPUSH
15792: LD_OWVAR 2
15796: PPUSH
15797: LD_INT 0
15799: PPUSH
15800: CALL_OW 324
15804: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
15805: LD_EXP 38
15809: PUSH
15810: LD_EXP 54
15814: AND
15815: IFFALSE 15898
15817: GO 15819
15819: DISABLE
15820: LD_INT 0
15822: PPUSH
15823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
15824: LD_ADDR_VAR 0 2
15828: PUSH
15829: LD_INT 22
15831: PUSH
15832: LD_OWVAR 2
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: PUSH
15841: LD_INT 21
15843: PUSH
15844: LD_INT 3
15846: PUSH
15847: EMPTY
15848: LIST
15849: LIST
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PPUSH
15855: CALL_OW 69
15859: ST_TO_ADDR
// if not tmp then
15860: LD_VAR 0 2
15864: NOT
15865: IFFALSE 15869
// exit ;
15867: GO 15898
// for i in tmp do
15869: LD_ADDR_VAR 0 1
15873: PUSH
15874: LD_VAR 0 2
15878: PUSH
15879: FOR_IN
15880: IFFALSE 15896
// SetBLevel ( i , 10 ) ;
15882: LD_VAR 0 1
15886: PPUSH
15887: LD_INT 10
15889: PPUSH
15890: CALL_OW 241
15894: GO 15879
15896: POP
15897: POP
// end ;
15898: PPOPN 2
15900: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
15901: LD_EXP 38
15905: PUSH
15906: LD_EXP 55
15910: AND
15911: IFFALSE 16022
15913: GO 15915
15915: DISABLE
15916: LD_INT 0
15918: PPUSH
15919: PPUSH
15920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15921: LD_ADDR_VAR 0 3
15925: PUSH
15926: LD_INT 22
15928: PUSH
15929: LD_OWVAR 2
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PUSH
15938: LD_INT 25
15940: PUSH
15941: LD_INT 1
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: EMPTY
15949: LIST
15950: LIST
15951: PPUSH
15952: CALL_OW 69
15956: ST_TO_ADDR
// if not tmp then
15957: LD_VAR 0 3
15961: NOT
15962: IFFALSE 15966
// exit ;
15964: GO 16022
// un := tmp [ rand ( 1 , tmp ) ] ;
15966: LD_ADDR_VAR 0 2
15970: PUSH
15971: LD_VAR 0 3
15975: PUSH
15976: LD_INT 1
15978: PPUSH
15979: LD_VAR 0 3
15983: PPUSH
15984: CALL_OW 12
15988: ARRAY
15989: ST_TO_ADDR
// if Crawls ( un ) then
15990: LD_VAR 0 2
15994: PPUSH
15995: CALL_OW 318
15999: IFFALSE 16010
// ComWalk ( un ) ;
16001: LD_VAR 0 2
16005: PPUSH
16006: CALL_OW 138
// SetClass ( un , class_sniper ) ;
16010: LD_VAR 0 2
16014: PPUSH
16015: LD_INT 5
16017: PPUSH
16018: CALL_OW 336
// end ;
16022: PPOPN 3
16024: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
16025: LD_EXP 38
16029: PUSH
16030: LD_EXP 56
16034: AND
16035: PUSH
16036: LD_OWVAR 67
16040: PUSH
16041: LD_INT 3
16043: LESS
16044: AND
16045: IFFALSE 16064
16047: GO 16049
16049: DISABLE
// Difficulty := Difficulty + 1 ;
16050: LD_ADDR_OWVAR 67
16054: PUSH
16055: LD_OWVAR 67
16059: PUSH
16060: LD_INT 1
16062: PLUS
16063: ST_TO_ADDR
16064: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
16065: LD_EXP 38
16069: PUSH
16070: LD_EXP 57
16074: AND
16075: IFFALSE 16178
16077: GO 16079
16079: DISABLE
16080: LD_INT 0
16082: PPUSH
// begin for i := 1 to 5 do
16083: LD_ADDR_VAR 0 1
16087: PUSH
16088: DOUBLE
16089: LD_INT 1
16091: DEC
16092: ST_TO_ADDR
16093: LD_INT 5
16095: PUSH
16096: FOR_TO
16097: IFFALSE 16176
// begin uc_nation := nation_nature ;
16099: LD_ADDR_OWVAR 21
16103: PUSH
16104: LD_INT 0
16106: ST_TO_ADDR
// uc_side := 0 ;
16107: LD_ADDR_OWVAR 20
16111: PUSH
16112: LD_INT 0
16114: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16115: LD_ADDR_OWVAR 29
16119: PUSH
16120: LD_INT 12
16122: PUSH
16123: LD_INT 12
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: ST_TO_ADDR
// hc_agressivity := 20 ;
16130: LD_ADDR_OWVAR 35
16134: PUSH
16135: LD_INT 20
16137: ST_TO_ADDR
// hc_class := class_tiger ;
16138: LD_ADDR_OWVAR 28
16142: PUSH
16143: LD_INT 14
16145: ST_TO_ADDR
// hc_gallery :=  ;
16146: LD_ADDR_OWVAR 33
16150: PUSH
16151: LD_STRING 
16153: ST_TO_ADDR
// hc_name :=  ;
16154: LD_ADDR_OWVAR 26
16158: PUSH
16159: LD_STRING 
16161: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
16162: CALL_OW 44
16166: PPUSH
16167: LD_INT 0
16169: PPUSH
16170: CALL_OW 51
// end ;
16174: GO 16096
16176: POP
16177: POP
// end ;
16178: PPOPN 1
16180: END
// every 0 0$1 trigger StreamModeActive and sBomb do
16181: LD_EXP 38
16185: PUSH
16186: LD_EXP 58
16190: AND
16191: IFFALSE 16200
16193: GO 16195
16195: DISABLE
// StreamSibBomb ;
16196: CALL 16201 0 0
16200: END
// export function StreamSibBomb ; var i , x , y ; begin
16201: LD_INT 0
16203: PPUSH
16204: PPUSH
16205: PPUSH
16206: PPUSH
// result := false ;
16207: LD_ADDR_VAR 0 1
16211: PUSH
16212: LD_INT 0
16214: ST_TO_ADDR
// for i := 1 to 16 do
16215: LD_ADDR_VAR 0 2
16219: PUSH
16220: DOUBLE
16221: LD_INT 1
16223: DEC
16224: ST_TO_ADDR
16225: LD_INT 16
16227: PUSH
16228: FOR_TO
16229: IFFALSE 16428
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16231: LD_ADDR_VAR 0 3
16235: PUSH
16236: LD_INT 10
16238: PUSH
16239: LD_INT 20
16241: PUSH
16242: LD_INT 30
16244: PUSH
16245: LD_INT 40
16247: PUSH
16248: LD_INT 50
16250: PUSH
16251: LD_INT 60
16253: PUSH
16254: LD_INT 70
16256: PUSH
16257: LD_INT 80
16259: PUSH
16260: LD_INT 90
16262: PUSH
16263: LD_INT 100
16265: PUSH
16266: LD_INT 110
16268: PUSH
16269: LD_INT 120
16271: PUSH
16272: LD_INT 130
16274: PUSH
16275: LD_INT 140
16277: PUSH
16278: LD_INT 150
16280: PUSH
16281: EMPTY
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: LIST
16294: LIST
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 1
16300: PPUSH
16301: LD_INT 15
16303: PPUSH
16304: CALL_OW 12
16308: ARRAY
16309: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16310: LD_ADDR_VAR 0 4
16314: PUSH
16315: LD_INT 10
16317: PUSH
16318: LD_INT 20
16320: PUSH
16321: LD_INT 30
16323: PUSH
16324: LD_INT 40
16326: PUSH
16327: LD_INT 50
16329: PUSH
16330: LD_INT 60
16332: PUSH
16333: LD_INT 70
16335: PUSH
16336: LD_INT 80
16338: PUSH
16339: LD_INT 90
16341: PUSH
16342: LD_INT 100
16344: PUSH
16345: LD_INT 110
16347: PUSH
16348: LD_INT 120
16350: PUSH
16351: LD_INT 130
16353: PUSH
16354: LD_INT 140
16356: PUSH
16357: LD_INT 150
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: LIST
16364: LIST
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: PUSH
16377: LD_INT 1
16379: PPUSH
16380: LD_INT 15
16382: PPUSH
16383: CALL_OW 12
16387: ARRAY
16388: ST_TO_ADDR
// if ValidHex ( x , y ) then
16389: LD_VAR 0 3
16393: PPUSH
16394: LD_VAR 0 4
16398: PPUSH
16399: CALL_OW 488
16403: IFFALSE 16426
// begin result := [ x , y ] ;
16405: LD_ADDR_VAR 0 1
16409: PUSH
16410: LD_VAR 0 3
16414: PUSH
16415: LD_VAR 0 4
16419: PUSH
16420: EMPTY
16421: LIST
16422: LIST
16423: ST_TO_ADDR
// break ;
16424: GO 16428
// end ; end ;
16426: GO 16228
16428: POP
16429: POP
// if result then
16430: LD_VAR 0 1
16434: IFFALSE 16494
// begin ToLua ( playSibBomb() ) ;
16436: LD_STRING playSibBomb()
16438: PPUSH
16439: CALL_OW 559
// wait ( 0 0$14 ) ;
16443: LD_INT 490
16445: PPUSH
16446: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
16450: LD_VAR 0 1
16454: PUSH
16455: LD_INT 1
16457: ARRAY
16458: PPUSH
16459: LD_VAR 0 1
16463: PUSH
16464: LD_INT 2
16466: ARRAY
16467: PPUSH
16468: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
16472: LD_VAR 0 1
16476: PUSH
16477: LD_INT 1
16479: ARRAY
16480: PPUSH
16481: LD_VAR 0 1
16485: PUSH
16486: LD_INT 2
16488: ARRAY
16489: PPUSH
16490: CALL_OW 429
// end ; end ;
16494: LD_VAR 0 1
16498: RET
// every 0 0$1 trigger StreamModeActive and sReset do
16499: LD_EXP 38
16503: PUSH
16504: LD_EXP 60
16508: AND
16509: IFFALSE 16521
16511: GO 16513
16513: DISABLE
// YouLost (  ) ;
16514: LD_STRING 
16516: PPUSH
16517: CALL_OW 104
16521: END
// every 0 0$1 trigger StreamModeActive and sFog do
16522: LD_EXP 38
16526: PUSH
16527: LD_EXP 59
16531: AND
16532: IFFALSE 16546
16534: GO 16536
16536: DISABLE
// FogOff ( your_side ) ;
16537: LD_OWVAR 2
16541: PPUSH
16542: CALL_OW 344
16546: END
// every 0 0$1 trigger StreamModeActive and sSun do
16547: LD_EXP 38
16551: PUSH
16552: LD_EXP 61
16556: AND
16557: IFFALSE 16585
16559: GO 16561
16561: DISABLE
// begin solar_recharge_percent := 0 ;
16562: LD_ADDR_OWVAR 79
16566: PUSH
16567: LD_INT 0
16569: ST_TO_ADDR
// wait ( 5 5$00 ) ;
16570: LD_INT 10500
16572: PPUSH
16573: CALL_OW 67
// solar_recharge_percent := 100 ;
16577: LD_ADDR_OWVAR 79
16581: PUSH
16582: LD_INT 100
16584: ST_TO_ADDR
// end ;
16585: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
16586: LD_EXP 38
16590: PUSH
16591: LD_EXP 62
16595: AND
16596: IFFALSE 16835
16598: GO 16600
16600: DISABLE
16601: LD_INT 0
16603: PPUSH
16604: PPUSH
16605: PPUSH
// begin tmp := [ ] ;
16606: LD_ADDR_VAR 0 3
16610: PUSH
16611: EMPTY
16612: ST_TO_ADDR
// for i := 1 to 6 do
16613: LD_ADDR_VAR 0 1
16617: PUSH
16618: DOUBLE
16619: LD_INT 1
16621: DEC
16622: ST_TO_ADDR
16623: LD_INT 6
16625: PUSH
16626: FOR_TO
16627: IFFALSE 16732
// begin uc_nation := nation_nature ;
16629: LD_ADDR_OWVAR 21
16633: PUSH
16634: LD_INT 0
16636: ST_TO_ADDR
// uc_side := 0 ;
16637: LD_ADDR_OWVAR 20
16641: PUSH
16642: LD_INT 0
16644: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16645: LD_ADDR_OWVAR 29
16649: PUSH
16650: LD_INT 12
16652: PUSH
16653: LD_INT 12
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: ST_TO_ADDR
// hc_agressivity := 20 ;
16660: LD_ADDR_OWVAR 35
16664: PUSH
16665: LD_INT 20
16667: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
16668: LD_ADDR_OWVAR 28
16672: PUSH
16673: LD_INT 17
16675: ST_TO_ADDR
// hc_gallery :=  ;
16676: LD_ADDR_OWVAR 33
16680: PUSH
16681: LD_STRING 
16683: ST_TO_ADDR
// hc_name :=  ;
16684: LD_ADDR_OWVAR 26
16688: PUSH
16689: LD_STRING 
16691: ST_TO_ADDR
// un := CreateHuman ;
16692: LD_ADDR_VAR 0 2
16696: PUSH
16697: CALL_OW 44
16701: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
16702: LD_VAR 0 2
16706: PPUSH
16707: LD_INT 1
16709: PPUSH
16710: CALL_OW 51
// tmp := tmp ^ un ;
16714: LD_ADDR_VAR 0 3
16718: PUSH
16719: LD_VAR 0 3
16723: PUSH
16724: LD_VAR 0 2
16728: ADD
16729: ST_TO_ADDR
// end ;
16730: GO 16626
16732: POP
16733: POP
// repeat wait ( 0 0$1 ) ;
16734: LD_INT 35
16736: PPUSH
16737: CALL_OW 67
// for un in tmp do
16741: LD_ADDR_VAR 0 2
16745: PUSH
16746: LD_VAR 0 3
16750: PUSH
16751: FOR_IN
16752: IFFALSE 16826
// begin if IsDead ( un ) then
16754: LD_VAR 0 2
16758: PPUSH
16759: CALL_OW 301
16763: IFFALSE 16783
// begin tmp := tmp diff un ;
16765: LD_ADDR_VAR 0 3
16769: PUSH
16770: LD_VAR 0 3
16774: PUSH
16775: LD_VAR 0 2
16779: DIFF
16780: ST_TO_ADDR
// continue ;
16781: GO 16751
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
16783: LD_VAR 0 2
16787: PPUSH
16788: LD_INT 3
16790: PUSH
16791: LD_INT 22
16793: PUSH
16794: LD_INT 0
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: PPUSH
16805: CALL_OW 69
16809: PPUSH
16810: LD_VAR 0 2
16814: PPUSH
16815: CALL_OW 74
16819: PPUSH
16820: CALL_OW 115
// end ;
16824: GO 16751
16826: POP
16827: POP
// until not tmp ;
16828: LD_VAR 0 3
16832: NOT
16833: IFFALSE 16734
// end ;
16835: PPOPN 3
16837: END
// every 0 0$1 trigger StreamModeActive and sTroll do
16838: LD_EXP 38
16842: PUSH
16843: LD_EXP 63
16847: AND
16848: IFFALSE 16902
16850: GO 16852
16852: DISABLE
// begin ToLua ( displayTroll(); ) ;
16853: LD_STRING displayTroll();
16855: PPUSH
16856: CALL_OW 559
// wait ( 3 3$00 ) ;
16860: LD_INT 6300
16862: PPUSH
16863: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16867: LD_STRING hideTroll();
16869: PPUSH
16870: CALL_OW 559
// wait ( 1 1$00 ) ;
16874: LD_INT 2100
16876: PPUSH
16877: CALL_OW 67
// ToLua ( displayTroll(); ) ;
16881: LD_STRING displayTroll();
16883: PPUSH
16884: CALL_OW 559
// wait ( 1 1$00 ) ;
16888: LD_INT 2100
16890: PPUSH
16891: CALL_OW 67
// ToLua ( hideTroll(); ) ;
16895: LD_STRING hideTroll();
16897: PPUSH
16898: CALL_OW 559
// end ;
16902: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
16903: LD_EXP 38
16907: PUSH
16908: LD_EXP 64
16912: AND
16913: IFFALSE 16976
16915: GO 16917
16917: DISABLE
16918: LD_INT 0
16920: PPUSH
// begin p := 0 ;
16921: LD_ADDR_VAR 0 1
16925: PUSH
16926: LD_INT 0
16928: ST_TO_ADDR
// repeat game_speed := 1 ;
16929: LD_ADDR_OWVAR 65
16933: PUSH
16934: LD_INT 1
16936: ST_TO_ADDR
// wait ( 0 0$1 ) ;
16937: LD_INT 35
16939: PPUSH
16940: CALL_OW 67
// p := p + 1 ;
16944: LD_ADDR_VAR 0 1
16948: PUSH
16949: LD_VAR 0 1
16953: PUSH
16954: LD_INT 1
16956: PLUS
16957: ST_TO_ADDR
// until p >= 60 ;
16958: LD_VAR 0 1
16962: PUSH
16963: LD_INT 60
16965: GREATEREQUAL
16966: IFFALSE 16929
// game_speed := 4 ;
16968: LD_ADDR_OWVAR 65
16972: PUSH
16973: LD_INT 4
16975: ST_TO_ADDR
// end ;
16976: PPOPN 1
16978: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
16979: LD_EXP 38
16983: PUSH
16984: LD_EXP 65
16988: AND
16989: IFFALSE 17135
16991: GO 16993
16993: DISABLE
16994: LD_INT 0
16996: PPUSH
16997: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16998: LD_ADDR_VAR 0 1
17002: PUSH
17003: LD_INT 22
17005: PUSH
17006: LD_OWVAR 2
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PUSH
17015: LD_INT 2
17017: PUSH
17018: LD_INT 30
17020: PUSH
17021: LD_INT 0
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 30
17030: PUSH
17031: LD_INT 1
17033: PUSH
17034: EMPTY
17035: LIST
17036: LIST
17037: PUSH
17038: EMPTY
17039: LIST
17040: LIST
17041: LIST
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: PPUSH
17047: CALL_OW 69
17051: ST_TO_ADDR
// if not depot then
17052: LD_VAR 0 1
17056: NOT
17057: IFFALSE 17061
// exit ;
17059: GO 17135
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
17061: LD_ADDR_VAR 0 2
17065: PUSH
17066: LD_VAR 0 1
17070: PUSH
17071: LD_INT 1
17073: PPUSH
17074: LD_VAR 0 1
17078: PPUSH
17079: CALL_OW 12
17083: ARRAY
17084: PPUSH
17085: CALL_OW 274
17089: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
17090: LD_VAR 0 2
17094: PPUSH
17095: LD_INT 1
17097: PPUSH
17098: LD_INT 0
17100: PPUSH
17101: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
17105: LD_VAR 0 2
17109: PPUSH
17110: LD_INT 2
17112: PPUSH
17113: LD_INT 0
17115: PPUSH
17116: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
17120: LD_VAR 0 2
17124: PPUSH
17125: LD_INT 3
17127: PPUSH
17128: LD_INT 0
17130: PPUSH
17131: CALL_OW 277
// end ;
17135: PPOPN 2
17137: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
17138: LD_EXP 38
17142: PUSH
17143: LD_EXP 66
17147: AND
17148: IFFALSE 17245
17150: GO 17152
17152: DISABLE
17153: LD_INT 0
17155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17156: LD_ADDR_VAR 0 1
17160: PUSH
17161: LD_INT 22
17163: PUSH
17164: LD_OWVAR 2
17168: PUSH
17169: EMPTY
17170: LIST
17171: LIST
17172: PUSH
17173: LD_INT 21
17175: PUSH
17176: LD_INT 1
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: PUSH
17183: LD_INT 3
17185: PUSH
17186: LD_INT 23
17188: PUSH
17189: LD_INT 0
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: EMPTY
17197: LIST
17198: LIST
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: LIST
17204: PPUSH
17205: CALL_OW 69
17209: ST_TO_ADDR
// if not tmp then
17210: LD_VAR 0 1
17214: NOT
17215: IFFALSE 17219
// exit ;
17217: GO 17245
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
17219: LD_VAR 0 1
17223: PUSH
17224: LD_INT 1
17226: PPUSH
17227: LD_VAR 0 1
17231: PPUSH
17232: CALL_OW 12
17236: ARRAY
17237: PPUSH
17238: LD_INT 200
17240: PPUSH
17241: CALL_OW 234
// end ;
17245: PPOPN 1
17247: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
17248: LD_EXP 38
17252: PUSH
17253: LD_EXP 67
17257: AND
17258: IFFALSE 17337
17260: GO 17262
17262: DISABLE
17263: LD_INT 0
17265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
17266: LD_ADDR_VAR 0 1
17270: PUSH
17271: LD_INT 22
17273: PUSH
17274: LD_OWVAR 2
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: LD_INT 21
17285: PUSH
17286: LD_INT 2
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: PUSH
17293: EMPTY
17294: LIST
17295: LIST
17296: PPUSH
17297: CALL_OW 69
17301: ST_TO_ADDR
// if not tmp then
17302: LD_VAR 0 1
17306: NOT
17307: IFFALSE 17311
// exit ;
17309: GO 17337
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
17311: LD_VAR 0 1
17315: PUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL_OW 12
17328: ARRAY
17329: PPUSH
17330: LD_INT 60
17332: PPUSH
17333: CALL_OW 234
// end ;
17337: PPOPN 1
17339: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
17340: LD_EXP 38
17344: PUSH
17345: LD_EXP 68
17349: AND
17350: IFFALSE 17449
17352: GO 17354
17354: DISABLE
17355: LD_INT 0
17357: PPUSH
17358: PPUSH
// begin enable ;
17359: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
17360: LD_ADDR_VAR 0 1
17364: PUSH
17365: LD_INT 22
17367: PUSH
17368: LD_OWVAR 2
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: PUSH
17377: LD_INT 61
17379: PUSH
17380: EMPTY
17381: LIST
17382: PUSH
17383: LD_INT 33
17385: PUSH
17386: LD_INT 2
17388: PUSH
17389: EMPTY
17390: LIST
17391: LIST
17392: PUSH
17393: EMPTY
17394: LIST
17395: LIST
17396: LIST
17397: PPUSH
17398: CALL_OW 69
17402: ST_TO_ADDR
// if not tmp then
17403: LD_VAR 0 1
17407: NOT
17408: IFFALSE 17412
// exit ;
17410: GO 17449
// for i in tmp do
17412: LD_ADDR_VAR 0 2
17416: PUSH
17417: LD_VAR 0 1
17421: PUSH
17422: FOR_IN
17423: IFFALSE 17447
// if IsControledBy ( i ) then
17425: LD_VAR 0 2
17429: PPUSH
17430: CALL_OW 312
17434: IFFALSE 17445
// ComUnlink ( i ) ;
17436: LD_VAR 0 2
17440: PPUSH
17441: CALL_OW 136
17445: GO 17422
17447: POP
17448: POP
// end ;
17449: PPOPN 2
17451: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
17452: LD_EXP 38
17456: PUSH
17457: LD_EXP 69
17461: AND
17462: IFFALSE 17602
17464: GO 17466
17466: DISABLE
17467: LD_INT 0
17469: PPUSH
17470: PPUSH
// begin ToLua ( displayPowell(); ) ;
17471: LD_STRING displayPowell();
17473: PPUSH
17474: CALL_OW 559
// uc_side := 0 ;
17478: LD_ADDR_OWVAR 20
17482: PUSH
17483: LD_INT 0
17485: ST_TO_ADDR
// uc_nation := 2 ;
17486: LD_ADDR_OWVAR 21
17490: PUSH
17491: LD_INT 2
17493: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
17494: LD_ADDR_OWVAR 37
17498: PUSH
17499: LD_INT 14
17501: ST_TO_ADDR
// vc_engine := engine_siberite ;
17502: LD_ADDR_OWVAR 39
17506: PUSH
17507: LD_INT 3
17509: ST_TO_ADDR
// vc_control := control_apeman ;
17510: LD_ADDR_OWVAR 38
17514: PUSH
17515: LD_INT 5
17517: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
17518: LD_ADDR_OWVAR 40
17522: PUSH
17523: LD_INT 29
17525: ST_TO_ADDR
// un := CreateVehicle ;
17526: LD_ADDR_VAR 0 2
17530: PUSH
17531: CALL_OW 45
17535: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17536: LD_VAR 0 2
17540: PPUSH
17541: LD_INT 1
17543: PPUSH
17544: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17548: LD_INT 35
17550: PPUSH
17551: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17555: LD_VAR 0 2
17559: PPUSH
17560: LD_INT 22
17562: PUSH
17563: LD_OWVAR 2
17567: PUSH
17568: EMPTY
17569: LIST
17570: LIST
17571: PPUSH
17572: CALL_OW 69
17576: PPUSH
17577: LD_VAR 0 2
17581: PPUSH
17582: CALL_OW 74
17586: PPUSH
17587: CALL_OW 115
// until IsDead ( un ) ;
17591: LD_VAR 0 2
17595: PPUSH
17596: CALL_OW 301
17600: IFFALSE 17548
// end ;
17602: PPOPN 2
17604: END
// every 0 0$1 trigger StreamModeActive and sStu do
17605: LD_EXP 38
17609: PUSH
17610: LD_EXP 77
17614: AND
17615: IFFALSE 17631
17617: GO 17619
17619: DISABLE
// begin ToLua ( displayStucuk(); ) ;
17620: LD_STRING displayStucuk();
17622: PPUSH
17623: CALL_OW 559
// ResetFog ;
17627: CALL_OW 335
// end ;
17631: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
17632: LD_EXP 38
17636: PUSH
17637: LD_EXP 70
17641: AND
17642: IFFALSE 17783
17644: GO 17646
17646: DISABLE
17647: LD_INT 0
17649: PPUSH
17650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17651: LD_ADDR_VAR 0 2
17655: PUSH
17656: LD_INT 22
17658: PUSH
17659: LD_OWVAR 2
17663: PUSH
17664: EMPTY
17665: LIST
17666: LIST
17667: PUSH
17668: LD_INT 21
17670: PUSH
17671: LD_INT 1
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: PPUSH
17682: CALL_OW 69
17686: ST_TO_ADDR
// if not tmp then
17687: LD_VAR 0 2
17691: NOT
17692: IFFALSE 17696
// exit ;
17694: GO 17783
// un := tmp [ rand ( 1 , tmp ) ] ;
17696: LD_ADDR_VAR 0 1
17700: PUSH
17701: LD_VAR 0 2
17705: PUSH
17706: LD_INT 1
17708: PPUSH
17709: LD_VAR 0 2
17713: PPUSH
17714: CALL_OW 12
17718: ARRAY
17719: ST_TO_ADDR
// SetSide ( un , 0 ) ;
17720: LD_VAR 0 1
17724: PPUSH
17725: LD_INT 0
17727: PPUSH
17728: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
17732: LD_VAR 0 1
17736: PPUSH
17737: LD_OWVAR 3
17741: PUSH
17742: LD_VAR 0 1
17746: DIFF
17747: PPUSH
17748: LD_VAR 0 1
17752: PPUSH
17753: CALL_OW 74
17757: PPUSH
17758: CALL_OW 115
// wait ( 0 0$20 ) ;
17762: LD_INT 700
17764: PPUSH
17765: CALL_OW 67
// SetSide ( un , your_side ) ;
17769: LD_VAR 0 1
17773: PPUSH
17774: LD_OWVAR 2
17778: PPUSH
17779: CALL_OW 235
// end ;
17783: PPOPN 2
17785: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
17786: LD_EXP 38
17790: PUSH
17791: LD_EXP 71
17795: AND
17796: IFFALSE 17902
17798: GO 17800
17800: DISABLE
17801: LD_INT 0
17803: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
17804: LD_ADDR_VAR 0 1
17808: PUSH
17809: LD_INT 22
17811: PUSH
17812: LD_OWVAR 2
17816: PUSH
17817: EMPTY
17818: LIST
17819: LIST
17820: PUSH
17821: LD_INT 2
17823: PUSH
17824: LD_INT 30
17826: PUSH
17827: LD_INT 0
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: PUSH
17834: LD_INT 30
17836: PUSH
17837: LD_INT 1
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: LIST
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: PPUSH
17853: CALL_OW 69
17857: ST_TO_ADDR
// if not depot then
17858: LD_VAR 0 1
17862: NOT
17863: IFFALSE 17867
// exit ;
17865: GO 17902
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
17867: LD_VAR 0 1
17871: PUSH
17872: LD_INT 1
17874: ARRAY
17875: PPUSH
17876: CALL_OW 250
17880: PPUSH
17881: LD_VAR 0 1
17885: PUSH
17886: LD_INT 1
17888: ARRAY
17889: PPUSH
17890: CALL_OW 251
17894: PPUSH
17895: LD_INT 70
17897: PPUSH
17898: CALL_OW 495
// end ;
17902: PPOPN 1
17904: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
17905: LD_EXP 38
17909: PUSH
17910: LD_EXP 72
17914: AND
17915: IFFALSE 18126
17917: GO 17919
17919: DISABLE
17920: LD_INT 0
17922: PPUSH
17923: PPUSH
17924: PPUSH
17925: PPUSH
17926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17927: LD_ADDR_VAR 0 5
17931: PUSH
17932: LD_INT 22
17934: PUSH
17935: LD_OWVAR 2
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: PUSH
17944: LD_INT 21
17946: PUSH
17947: LD_INT 1
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PPUSH
17958: CALL_OW 69
17962: ST_TO_ADDR
// if not tmp then
17963: LD_VAR 0 5
17967: NOT
17968: IFFALSE 17972
// exit ;
17970: GO 18126
// for i in tmp do
17972: LD_ADDR_VAR 0 1
17976: PUSH
17977: LD_VAR 0 5
17981: PUSH
17982: FOR_IN
17983: IFFALSE 18124
// begin d := rand ( 0 , 5 ) ;
17985: LD_ADDR_VAR 0 4
17989: PUSH
17990: LD_INT 0
17992: PPUSH
17993: LD_INT 5
17995: PPUSH
17996: CALL_OW 12
18000: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
18001: LD_ADDR_VAR 0 2
18005: PUSH
18006: LD_VAR 0 1
18010: PPUSH
18011: CALL_OW 250
18015: PPUSH
18016: LD_VAR 0 4
18020: PPUSH
18021: LD_INT 3
18023: PPUSH
18024: LD_INT 12
18026: PPUSH
18027: CALL_OW 12
18031: PPUSH
18032: CALL_OW 272
18036: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
18037: LD_ADDR_VAR 0 3
18041: PUSH
18042: LD_VAR 0 1
18046: PPUSH
18047: CALL_OW 251
18051: PPUSH
18052: LD_VAR 0 4
18056: PPUSH
18057: LD_INT 3
18059: PPUSH
18060: LD_INT 12
18062: PPUSH
18063: CALL_OW 12
18067: PPUSH
18068: CALL_OW 273
18072: ST_TO_ADDR
// if ValidHex ( x , y ) then
18073: LD_VAR 0 2
18077: PPUSH
18078: LD_VAR 0 3
18082: PPUSH
18083: CALL_OW 488
18087: IFFALSE 18122
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
18089: LD_VAR 0 1
18093: PPUSH
18094: LD_VAR 0 2
18098: PPUSH
18099: LD_VAR 0 3
18103: PPUSH
18104: LD_INT 3
18106: PPUSH
18107: LD_INT 6
18109: PPUSH
18110: CALL_OW 12
18114: PPUSH
18115: LD_INT 1
18117: PPUSH
18118: CALL_OW 483
// end ;
18122: GO 17982
18124: POP
18125: POP
// end ;
18126: PPOPN 5
18128: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
18129: LD_EXP 38
18133: PUSH
18134: LD_EXP 73
18138: AND
18139: IFFALSE 18233
18141: GO 18143
18143: DISABLE
18144: LD_INT 0
18146: PPUSH
18147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
18148: LD_ADDR_VAR 0 2
18152: PUSH
18153: LD_INT 22
18155: PUSH
18156: LD_OWVAR 2
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: PUSH
18165: LD_INT 32
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PUSH
18175: LD_INT 21
18177: PUSH
18178: LD_INT 2
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: LIST
18189: PPUSH
18190: CALL_OW 69
18194: ST_TO_ADDR
// if not tmp then
18195: LD_VAR 0 2
18199: NOT
18200: IFFALSE 18204
// exit ;
18202: GO 18233
// for i in tmp do
18204: LD_ADDR_VAR 0 1
18208: PUSH
18209: LD_VAR 0 2
18213: PUSH
18214: FOR_IN
18215: IFFALSE 18231
// SetFuel ( i , 0 ) ;
18217: LD_VAR 0 1
18221: PPUSH
18222: LD_INT 0
18224: PPUSH
18225: CALL_OW 240
18229: GO 18214
18231: POP
18232: POP
// end ;
18233: PPOPN 2
18235: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
18236: LD_EXP 38
18240: PUSH
18241: LD_EXP 74
18245: AND
18246: IFFALSE 18312
18248: GO 18250
18250: DISABLE
18251: LD_INT 0
18253: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18254: LD_ADDR_VAR 0 1
18258: PUSH
18259: LD_INT 22
18261: PUSH
18262: LD_OWVAR 2
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PUSH
18271: LD_INT 30
18273: PUSH
18274: LD_INT 29
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 69
18289: ST_TO_ADDR
// if not tmp then
18290: LD_VAR 0 1
18294: NOT
18295: IFFALSE 18299
// exit ;
18297: GO 18312
// DestroyUnit ( tmp [ 1 ] ) ;
18299: LD_VAR 0 1
18303: PUSH
18304: LD_INT 1
18306: ARRAY
18307: PPUSH
18308: CALL_OW 65
// end ;
18312: PPOPN 1
18314: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
18315: LD_EXP 38
18319: PUSH
18320: LD_EXP 76
18324: AND
18325: IFFALSE 18454
18327: GO 18329
18329: DISABLE
18330: LD_INT 0
18332: PPUSH
// begin uc_side := 0 ;
18333: LD_ADDR_OWVAR 20
18337: PUSH
18338: LD_INT 0
18340: ST_TO_ADDR
// uc_nation := nation_arabian ;
18341: LD_ADDR_OWVAR 21
18345: PUSH
18346: LD_INT 2
18348: ST_TO_ADDR
// hc_gallery :=  ;
18349: LD_ADDR_OWVAR 33
18353: PUSH
18354: LD_STRING 
18356: ST_TO_ADDR
// hc_name :=  ;
18357: LD_ADDR_OWVAR 26
18361: PUSH
18362: LD_STRING 
18364: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
18365: LD_INT 1
18367: PPUSH
18368: LD_INT 11
18370: PPUSH
18371: LD_INT 10
18373: PPUSH
18374: CALL_OW 380
// un := CreateHuman ;
18378: LD_ADDR_VAR 0 1
18382: PUSH
18383: CALL_OW 44
18387: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18388: LD_VAR 0 1
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18400: LD_INT 35
18402: PPUSH
18403: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18407: LD_VAR 0 1
18411: PPUSH
18412: LD_INT 22
18414: PUSH
18415: LD_OWVAR 2
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PPUSH
18424: CALL_OW 69
18428: PPUSH
18429: LD_VAR 0 1
18433: PPUSH
18434: CALL_OW 74
18438: PPUSH
18439: CALL_OW 115
// until IsDead ( un ) ;
18443: LD_VAR 0 1
18447: PPUSH
18448: CALL_OW 301
18452: IFFALSE 18400
// end ;
18454: PPOPN 1
18456: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
18457: LD_EXP 38
18461: PUSH
18462: LD_EXP 78
18466: AND
18467: IFFALSE 18479
18469: GO 18471
18471: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
18472: LD_STRING earthquake(getX(game), 0, 32)
18474: PPUSH
18475: CALL_OW 559
18479: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
18480: LD_EXP 38
18484: PUSH
18485: LD_EXP 79
18489: AND
18490: IFFALSE 18581
18492: GO 18494
18494: DISABLE
18495: LD_INT 0
18497: PPUSH
// begin enable ;
18498: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
18499: LD_ADDR_VAR 0 1
18503: PUSH
18504: LD_INT 22
18506: PUSH
18507: LD_OWVAR 2
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: PUSH
18516: LD_INT 21
18518: PUSH
18519: LD_INT 2
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: PUSH
18526: LD_INT 33
18528: PUSH
18529: LD_INT 3
18531: PUSH
18532: EMPTY
18533: LIST
18534: LIST
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: LIST
18540: PPUSH
18541: CALL_OW 69
18545: ST_TO_ADDR
// if not tmp then
18546: LD_VAR 0 1
18550: NOT
18551: IFFALSE 18555
// exit ;
18553: GO 18581
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18555: LD_VAR 0 1
18559: PUSH
18560: LD_INT 1
18562: PPUSH
18563: LD_VAR 0 1
18567: PPUSH
18568: CALL_OW 12
18572: ARRAY
18573: PPUSH
18574: LD_INT 1
18576: PPUSH
18577: CALL_OW 234
// end ;
18581: PPOPN 1
18583: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
18584: LD_EXP 38
18588: PUSH
18589: LD_EXP 80
18593: AND
18594: IFFALSE 18735
18596: GO 18598
18598: DISABLE
18599: LD_INT 0
18601: PPUSH
18602: PPUSH
18603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18604: LD_ADDR_VAR 0 3
18608: PUSH
18609: LD_INT 22
18611: PUSH
18612: LD_OWVAR 2
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: PUSH
18621: LD_INT 25
18623: PUSH
18624: LD_INT 1
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: PUSH
18631: EMPTY
18632: LIST
18633: LIST
18634: PPUSH
18635: CALL_OW 69
18639: ST_TO_ADDR
// if not tmp then
18640: LD_VAR 0 3
18644: NOT
18645: IFFALSE 18649
// exit ;
18647: GO 18735
// un := tmp [ rand ( 1 , tmp ) ] ;
18649: LD_ADDR_VAR 0 2
18653: PUSH
18654: LD_VAR 0 3
18658: PUSH
18659: LD_INT 1
18661: PPUSH
18662: LD_VAR 0 3
18666: PPUSH
18667: CALL_OW 12
18671: ARRAY
18672: ST_TO_ADDR
// if Crawls ( un ) then
18673: LD_VAR 0 2
18677: PPUSH
18678: CALL_OW 318
18682: IFFALSE 18693
// ComWalk ( un ) ;
18684: LD_VAR 0 2
18688: PPUSH
18689: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
18693: LD_VAR 0 2
18697: PPUSH
18698: LD_INT 9
18700: PPUSH
18701: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
18705: LD_INT 28
18707: PPUSH
18708: LD_OWVAR 2
18712: PPUSH
18713: LD_INT 2
18715: PPUSH
18716: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
18720: LD_INT 29
18722: PPUSH
18723: LD_OWVAR 2
18727: PPUSH
18728: LD_INT 2
18730: PPUSH
18731: CALL_OW 322
// end ;
18735: PPOPN 3
18737: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
18738: LD_EXP 38
18742: PUSH
18743: LD_EXP 81
18747: AND
18748: IFFALSE 18859
18750: GO 18752
18752: DISABLE
18753: LD_INT 0
18755: PPUSH
18756: PPUSH
18757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18758: LD_ADDR_VAR 0 3
18762: PUSH
18763: LD_INT 22
18765: PUSH
18766: LD_OWVAR 2
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 25
18777: PUSH
18778: LD_INT 1
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PPUSH
18789: CALL_OW 69
18793: ST_TO_ADDR
// if not tmp then
18794: LD_VAR 0 3
18798: NOT
18799: IFFALSE 18803
// exit ;
18801: GO 18859
// un := tmp [ rand ( 1 , tmp ) ] ;
18803: LD_ADDR_VAR 0 2
18807: PUSH
18808: LD_VAR 0 3
18812: PUSH
18813: LD_INT 1
18815: PPUSH
18816: LD_VAR 0 3
18820: PPUSH
18821: CALL_OW 12
18825: ARRAY
18826: ST_TO_ADDR
// if Crawls ( un ) then
18827: LD_VAR 0 2
18831: PPUSH
18832: CALL_OW 318
18836: IFFALSE 18847
// ComWalk ( un ) ;
18838: LD_VAR 0 2
18842: PPUSH
18843: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18847: LD_VAR 0 2
18851: PPUSH
18852: LD_INT 8
18854: PPUSH
18855: CALL_OW 336
// end ;
18859: PPOPN 3
18861: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
18862: LD_EXP 38
18866: PUSH
18867: LD_EXP 82
18871: AND
18872: IFFALSE 19016
18874: GO 18876
18876: DISABLE
18877: LD_INT 0
18879: PPUSH
18880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
18881: LD_ADDR_VAR 0 2
18885: PUSH
18886: LD_INT 22
18888: PUSH
18889: LD_OWVAR 2
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: PUSH
18898: LD_INT 21
18900: PUSH
18901: LD_INT 2
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 2
18910: PUSH
18911: LD_INT 34
18913: PUSH
18914: LD_INT 12
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 34
18923: PUSH
18924: LD_INT 51
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: LD_INT 34
18933: PUSH
18934: LD_INT 32
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: LIST
18951: PPUSH
18952: CALL_OW 69
18956: ST_TO_ADDR
// if not tmp then
18957: LD_VAR 0 2
18961: NOT
18962: IFFALSE 18966
// exit ;
18964: GO 19016
// for i in tmp do
18966: LD_ADDR_VAR 0 1
18970: PUSH
18971: LD_VAR 0 2
18975: PUSH
18976: FOR_IN
18977: IFFALSE 19014
// if GetCargo ( i , mat_artifact ) = 0 then
18979: LD_VAR 0 1
18983: PPUSH
18984: LD_INT 4
18986: PPUSH
18987: CALL_OW 289
18991: PUSH
18992: LD_INT 0
18994: EQUAL
18995: IFFALSE 19012
// SetCargo ( i , mat_siberit , 100 ) ;
18997: LD_VAR 0 1
19001: PPUSH
19002: LD_INT 3
19004: PPUSH
19005: LD_INT 100
19007: PPUSH
19008: CALL_OW 290
19012: GO 18976
19014: POP
19015: POP
// end ;
19016: PPOPN 2
19018: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
19019: LD_EXP 38
19023: PUSH
19024: LD_EXP 83
19028: AND
19029: IFFALSE 19182
19031: GO 19033
19033: DISABLE
19034: LD_INT 0
19036: PPUSH
19037: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
19038: LD_ADDR_VAR 0 2
19042: PUSH
19043: LD_INT 22
19045: PUSH
19046: LD_OWVAR 2
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: PPUSH
19055: CALL_OW 69
19059: ST_TO_ADDR
// if not tmp then
19060: LD_VAR 0 2
19064: NOT
19065: IFFALSE 19069
// exit ;
19067: GO 19182
// for i := 1 to 2 do
19069: LD_ADDR_VAR 0 1
19073: PUSH
19074: DOUBLE
19075: LD_INT 1
19077: DEC
19078: ST_TO_ADDR
19079: LD_INT 2
19081: PUSH
19082: FOR_TO
19083: IFFALSE 19180
// begin uc_side := your_side ;
19085: LD_ADDR_OWVAR 20
19089: PUSH
19090: LD_OWVAR 2
19094: ST_TO_ADDR
// uc_nation := nation_american ;
19095: LD_ADDR_OWVAR 21
19099: PUSH
19100: LD_INT 1
19102: ST_TO_ADDR
// vc_chassis := us_morphling ;
19103: LD_ADDR_OWVAR 37
19107: PUSH
19108: LD_INT 5
19110: ST_TO_ADDR
// vc_engine := engine_siberite ;
19111: LD_ADDR_OWVAR 39
19115: PUSH
19116: LD_INT 3
19118: ST_TO_ADDR
// vc_control := control_computer ;
19119: LD_ADDR_OWVAR 38
19123: PUSH
19124: LD_INT 3
19126: ST_TO_ADDR
// vc_weapon := us_double_laser ;
19127: LD_ADDR_OWVAR 40
19131: PUSH
19132: LD_INT 10
19134: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
19135: CALL_OW 45
19139: PPUSH
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 1
19147: ARRAY
19148: PPUSH
19149: CALL_OW 250
19153: PPUSH
19154: LD_VAR 0 2
19158: PUSH
19159: LD_INT 1
19161: ARRAY
19162: PPUSH
19163: CALL_OW 251
19167: PPUSH
19168: LD_INT 12
19170: PPUSH
19171: LD_INT 1
19173: PPUSH
19174: CALL_OW 50
// end ;
19178: GO 19082
19180: POP
19181: POP
// end ;
19182: PPOPN 2
19184: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
19185: LD_EXP 38
19189: PUSH
19190: LD_EXP 84
19194: AND
19195: IFFALSE 19417
19197: GO 19199
19199: DISABLE
19200: LD_INT 0
19202: PPUSH
19203: PPUSH
19204: PPUSH
19205: PPUSH
19206: PPUSH
19207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19208: LD_ADDR_VAR 0 6
19212: PUSH
19213: LD_INT 22
19215: PUSH
19216: LD_OWVAR 2
19220: PUSH
19221: EMPTY
19222: LIST
19223: LIST
19224: PUSH
19225: LD_INT 21
19227: PUSH
19228: LD_INT 1
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: PUSH
19235: LD_INT 3
19237: PUSH
19238: LD_INT 23
19240: PUSH
19241: LD_INT 0
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: LIST
19256: PPUSH
19257: CALL_OW 69
19261: ST_TO_ADDR
// if not tmp then
19262: LD_VAR 0 6
19266: NOT
19267: IFFALSE 19271
// exit ;
19269: GO 19417
// s1 := rand ( 1 , 4 ) ;
19271: LD_ADDR_VAR 0 2
19275: PUSH
19276: LD_INT 1
19278: PPUSH
19279: LD_INT 4
19281: PPUSH
19282: CALL_OW 12
19286: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
19287: LD_ADDR_VAR 0 4
19291: PUSH
19292: LD_VAR 0 6
19296: PUSH
19297: LD_INT 1
19299: ARRAY
19300: PPUSH
19301: LD_VAR 0 2
19305: PPUSH
19306: CALL_OW 259
19310: ST_TO_ADDR
// if s1 = 1 then
19311: LD_VAR 0 2
19315: PUSH
19316: LD_INT 1
19318: EQUAL
19319: IFFALSE 19339
// s2 := rand ( 2 , 4 ) else
19321: LD_ADDR_VAR 0 3
19325: PUSH
19326: LD_INT 2
19328: PPUSH
19329: LD_INT 4
19331: PPUSH
19332: CALL_OW 12
19336: ST_TO_ADDR
19337: GO 19347
// s2 := 1 ;
19339: LD_ADDR_VAR 0 3
19343: PUSH
19344: LD_INT 1
19346: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
19347: LD_ADDR_VAR 0 5
19351: PUSH
19352: LD_VAR 0 6
19356: PUSH
19357: LD_INT 1
19359: ARRAY
19360: PPUSH
19361: LD_VAR 0 3
19365: PPUSH
19366: CALL_OW 259
19370: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
19371: LD_VAR 0 6
19375: PUSH
19376: LD_INT 1
19378: ARRAY
19379: PPUSH
19380: LD_VAR 0 2
19384: PPUSH
19385: LD_VAR 0 5
19389: PPUSH
19390: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
19394: LD_VAR 0 6
19398: PUSH
19399: LD_INT 1
19401: ARRAY
19402: PPUSH
19403: LD_VAR 0 3
19407: PPUSH
19408: LD_VAR 0 4
19412: PPUSH
19413: CALL_OW 237
// end ;
19417: PPOPN 6
19419: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
19420: LD_EXP 38
19424: PUSH
19425: LD_EXP 85
19429: AND
19430: IFFALSE 19509
19432: GO 19434
19434: DISABLE
19435: LD_INT 0
19437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
19438: LD_ADDR_VAR 0 1
19442: PUSH
19443: LD_INT 22
19445: PUSH
19446: LD_OWVAR 2
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 30
19457: PUSH
19458: LD_INT 3
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: PPUSH
19469: CALL_OW 69
19473: ST_TO_ADDR
// if not tmp then
19474: LD_VAR 0 1
19478: NOT
19479: IFFALSE 19483
// exit ;
19481: GO 19509
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19483: LD_VAR 0 1
19487: PUSH
19488: LD_INT 1
19490: PPUSH
19491: LD_VAR 0 1
19495: PPUSH
19496: CALL_OW 12
19500: ARRAY
19501: PPUSH
19502: LD_INT 1
19504: PPUSH
19505: CALL_OW 234
// end ;
19509: PPOPN 1
19511: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
19512: LD_EXP 38
19516: PUSH
19517: LD_EXP 86
19521: AND
19522: IFFALSE 19634
19524: GO 19526
19526: DISABLE
19527: LD_INT 0
19529: PPUSH
19530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
19531: LD_ADDR_VAR 0 2
19535: PUSH
19536: LD_INT 22
19538: PUSH
19539: LD_OWVAR 2
19543: PUSH
19544: EMPTY
19545: LIST
19546: LIST
19547: PUSH
19548: LD_INT 2
19550: PUSH
19551: LD_INT 30
19553: PUSH
19554: LD_INT 27
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: PUSH
19561: LD_INT 30
19563: PUSH
19564: LD_INT 26
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 30
19573: PUSH
19574: LD_INT 28
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: PUSH
19587: EMPTY
19588: LIST
19589: LIST
19590: PPUSH
19591: CALL_OW 69
19595: ST_TO_ADDR
// if not tmp then
19596: LD_VAR 0 2
19600: NOT
19601: IFFALSE 19605
// exit ;
19603: GO 19634
// for i in tmp do
19605: LD_ADDR_VAR 0 1
19609: PUSH
19610: LD_VAR 0 2
19614: PUSH
19615: FOR_IN
19616: IFFALSE 19632
// SetLives ( i , 1 ) ;
19618: LD_VAR 0 1
19622: PPUSH
19623: LD_INT 1
19625: PPUSH
19626: CALL_OW 234
19630: GO 19615
19632: POP
19633: POP
// end ;
19634: PPOPN 2
19636: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
19637: LD_EXP 38
19641: PUSH
19642: LD_EXP 87
19646: AND
19647: IFFALSE 19921
19649: GO 19651
19651: DISABLE
19652: LD_INT 0
19654: PPUSH
19655: PPUSH
19656: PPUSH
// begin i := rand ( 1 , 7 ) ;
19657: LD_ADDR_VAR 0 1
19661: PUSH
19662: LD_INT 1
19664: PPUSH
19665: LD_INT 7
19667: PPUSH
19668: CALL_OW 12
19672: ST_TO_ADDR
// case i of 1 :
19673: LD_VAR 0 1
19677: PUSH
19678: LD_INT 1
19680: DOUBLE
19681: EQUAL
19682: IFTRUE 19686
19684: GO 19696
19686: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
19687: LD_STRING earthquake(getX(game), 0, 32)
19689: PPUSH
19690: CALL_OW 559
19694: GO 19921
19696: LD_INT 2
19698: DOUBLE
19699: EQUAL
19700: IFTRUE 19704
19702: GO 19718
19704: POP
// begin ToLua ( displayStucuk(); ) ;
19705: LD_STRING displayStucuk();
19707: PPUSH
19708: CALL_OW 559
// ResetFog ;
19712: CALL_OW 335
// end ; 3 :
19716: GO 19921
19718: LD_INT 3
19720: DOUBLE
19721: EQUAL
19722: IFTRUE 19726
19724: GO 19830
19726: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19727: LD_ADDR_VAR 0 2
19731: PUSH
19732: LD_INT 22
19734: PUSH
19735: LD_OWVAR 2
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: PUSH
19744: LD_INT 25
19746: PUSH
19747: LD_INT 1
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PUSH
19754: EMPTY
19755: LIST
19756: LIST
19757: PPUSH
19758: CALL_OW 69
19762: ST_TO_ADDR
// if not tmp then
19763: LD_VAR 0 2
19767: NOT
19768: IFFALSE 19772
// exit ;
19770: GO 19921
// un := tmp [ rand ( 1 , tmp ) ] ;
19772: LD_ADDR_VAR 0 3
19776: PUSH
19777: LD_VAR 0 2
19781: PUSH
19782: LD_INT 1
19784: PPUSH
19785: LD_VAR 0 2
19789: PPUSH
19790: CALL_OW 12
19794: ARRAY
19795: ST_TO_ADDR
// if Crawls ( un ) then
19796: LD_VAR 0 3
19800: PPUSH
19801: CALL_OW 318
19805: IFFALSE 19816
// ComWalk ( un ) ;
19807: LD_VAR 0 3
19811: PPUSH
19812: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19816: LD_VAR 0 3
19820: PPUSH
19821: LD_INT 8
19823: PPUSH
19824: CALL_OW 336
// end ; 4 :
19828: GO 19921
19830: LD_INT 4
19832: DOUBLE
19833: EQUAL
19834: IFTRUE 19838
19836: GO 19899
19838: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19839: LD_ADDR_VAR 0 2
19843: PUSH
19844: LD_INT 22
19846: PUSH
19847: LD_OWVAR 2
19851: PUSH
19852: EMPTY
19853: LIST
19854: LIST
19855: PUSH
19856: LD_INT 30
19858: PUSH
19859: LD_INT 29
19861: PUSH
19862: EMPTY
19863: LIST
19864: LIST
19865: PUSH
19866: EMPTY
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 69
19874: ST_TO_ADDR
// if not tmp then
19875: LD_VAR 0 2
19879: NOT
19880: IFFALSE 19884
// exit ;
19882: GO 19921
// DestroyUnit ( tmp [ 1 ] ) ;
19884: LD_VAR 0 2
19888: PUSH
19889: LD_INT 1
19891: ARRAY
19892: PPUSH
19893: CALL_OW 65
// end ; 5 .. 7 :
19897: GO 19921
19899: LD_INT 5
19901: DOUBLE
19902: GREATEREQUAL
19903: IFFALSE 19911
19905: LD_INT 7
19907: DOUBLE
19908: LESSEQUAL
19909: IFTRUE 19913
19911: GO 19920
19913: POP
// StreamSibBomb ; end ;
19914: CALL 16201 0 0
19918: GO 19921
19920: POP
// end ;
19921: PPOPN 3
19923: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
19924: LD_EXP 38
19928: PUSH
19929: LD_EXP 88
19933: AND
19934: IFFALSE 20090
19936: GO 19938
19938: DISABLE
19939: LD_INT 0
19941: PPUSH
19942: PPUSH
19943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
19944: LD_ADDR_VAR 0 2
19948: PUSH
19949: LD_INT 81
19951: PUSH
19952: LD_OWVAR 2
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: PUSH
19961: LD_INT 2
19963: PUSH
19964: LD_INT 21
19966: PUSH
19967: LD_INT 1
19969: PUSH
19970: EMPTY
19971: LIST
19972: LIST
19973: PUSH
19974: LD_INT 21
19976: PUSH
19977: LD_INT 2
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: LIST
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PPUSH
19993: CALL_OW 69
19997: ST_TO_ADDR
// if not tmp then
19998: LD_VAR 0 2
20002: NOT
20003: IFFALSE 20007
// exit ;
20005: GO 20090
// p := 0 ;
20007: LD_ADDR_VAR 0 3
20011: PUSH
20012: LD_INT 0
20014: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20015: LD_INT 35
20017: PPUSH
20018: CALL_OW 67
// p := p + 1 ;
20022: LD_ADDR_VAR 0 3
20026: PUSH
20027: LD_VAR 0 3
20031: PUSH
20032: LD_INT 1
20034: PLUS
20035: ST_TO_ADDR
// for i in tmp do
20036: LD_ADDR_VAR 0 1
20040: PUSH
20041: LD_VAR 0 2
20045: PUSH
20046: FOR_IN
20047: IFFALSE 20078
// if GetLives ( i ) < 1000 then
20049: LD_VAR 0 1
20053: PPUSH
20054: CALL_OW 256
20058: PUSH
20059: LD_INT 1000
20061: LESS
20062: IFFALSE 20076
// SetLives ( i , 1000 ) ;
20064: LD_VAR 0 1
20068: PPUSH
20069: LD_INT 1000
20071: PPUSH
20072: CALL_OW 234
20076: GO 20046
20078: POP
20079: POP
// until p > 20 ;
20080: LD_VAR 0 3
20084: PUSH
20085: LD_INT 20
20087: GREATER
20088: IFFALSE 20015
// end ;
20090: PPOPN 3
20092: END
// every 0 0$1 trigger StreamModeActive and sTime do
20093: LD_EXP 38
20097: PUSH
20098: LD_EXP 89
20102: AND
20103: IFFALSE 20138
20105: GO 20107
20107: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
20108: LD_INT 28
20110: PPUSH
20111: LD_OWVAR 2
20115: PPUSH
20116: LD_INT 2
20118: PPUSH
20119: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
20123: LD_INT 30
20125: PPUSH
20126: LD_OWVAR 2
20130: PPUSH
20131: LD_INT 2
20133: PPUSH
20134: CALL_OW 322
// end ;
20138: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
20139: LD_EXP 38
20143: PUSH
20144: LD_EXP 90
20148: AND
20149: IFFALSE 20270
20151: GO 20153
20153: DISABLE
20154: LD_INT 0
20156: PPUSH
20157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20158: LD_ADDR_VAR 0 2
20162: PUSH
20163: LD_INT 22
20165: PUSH
20166: LD_OWVAR 2
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: PUSH
20175: LD_INT 21
20177: PUSH
20178: LD_INT 1
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: PUSH
20185: LD_INT 3
20187: PUSH
20188: LD_INT 23
20190: PUSH
20191: LD_INT 0
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: LIST
20206: PPUSH
20207: CALL_OW 69
20211: ST_TO_ADDR
// if not tmp then
20212: LD_VAR 0 2
20216: NOT
20217: IFFALSE 20221
// exit ;
20219: GO 20270
// for i in tmp do
20221: LD_ADDR_VAR 0 1
20225: PUSH
20226: LD_VAR 0 2
20230: PUSH
20231: FOR_IN
20232: IFFALSE 20268
// begin if Crawls ( i ) then
20234: LD_VAR 0 1
20238: PPUSH
20239: CALL_OW 318
20243: IFFALSE 20254
// ComWalk ( i ) ;
20245: LD_VAR 0 1
20249: PPUSH
20250: CALL_OW 138
// SetClass ( i , 2 ) ;
20254: LD_VAR 0 1
20258: PPUSH
20259: LD_INT 2
20261: PPUSH
20262: CALL_OW 336
// end ;
20266: GO 20231
20268: POP
20269: POP
// end ;
20270: PPOPN 2
20272: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
20273: LD_EXP 38
20277: PUSH
20278: LD_EXP 91
20282: AND
20283: IFFALSE 20564
20285: GO 20287
20287: DISABLE
20288: LD_INT 0
20290: PPUSH
20291: PPUSH
20292: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
20293: LD_OWVAR 2
20297: PPUSH
20298: LD_INT 9
20300: PPUSH
20301: LD_INT 1
20303: PPUSH
20304: LD_INT 1
20306: PPUSH
20307: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
20311: LD_INT 9
20313: PPUSH
20314: LD_OWVAR 2
20318: PPUSH
20319: CALL_OW 343
// uc_side := 9 ;
20323: LD_ADDR_OWVAR 20
20327: PUSH
20328: LD_INT 9
20330: ST_TO_ADDR
// uc_nation := 2 ;
20331: LD_ADDR_OWVAR 21
20335: PUSH
20336: LD_INT 2
20338: ST_TO_ADDR
// hc_name := Dark Warrior ;
20339: LD_ADDR_OWVAR 26
20343: PUSH
20344: LD_STRING Dark Warrior
20346: ST_TO_ADDR
// hc_gallery :=  ;
20347: LD_ADDR_OWVAR 33
20351: PUSH
20352: LD_STRING 
20354: ST_TO_ADDR
// hc_noskilllimit := true ;
20355: LD_ADDR_OWVAR 76
20359: PUSH
20360: LD_INT 1
20362: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
20363: LD_ADDR_OWVAR 31
20367: PUSH
20368: LD_INT 30
20370: PUSH
20371: LD_INT 30
20373: PUSH
20374: LD_INT 30
20376: PUSH
20377: LD_INT 30
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: ST_TO_ADDR
// un := CreateHuman ;
20386: LD_ADDR_VAR 0 3
20390: PUSH
20391: CALL_OW 44
20395: ST_TO_ADDR
// hc_noskilllimit := false ;
20396: LD_ADDR_OWVAR 76
20400: PUSH
20401: LD_INT 0
20403: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20404: LD_VAR 0 3
20408: PPUSH
20409: LD_INT 1
20411: PPUSH
20412: CALL_OW 51
// p := 0 ;
20416: LD_ADDR_VAR 0 2
20420: PUSH
20421: LD_INT 0
20423: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20424: LD_INT 35
20426: PPUSH
20427: CALL_OW 67
// p := p + 1 ;
20431: LD_ADDR_VAR 0 2
20435: PUSH
20436: LD_VAR 0 2
20440: PUSH
20441: LD_INT 1
20443: PLUS
20444: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
20445: LD_VAR 0 3
20449: PPUSH
20450: CALL_OW 256
20454: PUSH
20455: LD_INT 1000
20457: LESS
20458: IFFALSE 20472
// SetLives ( un , 1000 ) ;
20460: LD_VAR 0 3
20464: PPUSH
20465: LD_INT 1000
20467: PPUSH
20468: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
20472: LD_VAR 0 3
20476: PPUSH
20477: LD_INT 81
20479: PUSH
20480: LD_OWVAR 2
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: PUSH
20489: LD_INT 91
20491: PUSH
20492: LD_VAR 0 3
20496: PUSH
20497: LD_INT 30
20499: PUSH
20500: EMPTY
20501: LIST
20502: LIST
20503: LIST
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: PPUSH
20509: CALL_OW 69
20513: PPUSH
20514: LD_VAR 0 3
20518: PPUSH
20519: CALL_OW 74
20523: PPUSH
20524: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
20528: LD_VAR 0 2
20532: PUSH
20533: LD_INT 60
20535: GREATER
20536: PUSH
20537: LD_VAR 0 3
20541: PPUSH
20542: CALL_OW 301
20546: OR
20547: IFFALSE 20424
// if un then
20549: LD_VAR 0 3
20553: IFFALSE 20564
// RemoveUnit ( un ) ;
20555: LD_VAR 0 3
20559: PPUSH
20560: CALL_OW 64
// end ; end_of_file
20564: PPOPN 3
20566: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
20567: LD_INT 0
20569: PPUSH
20570: PPUSH
20571: PPUSH
20572: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
20573: LD_VAR 0 1
20577: PPUSH
20578: CALL_OW 264
20582: PUSH
20583: LD_EXP 29
20587: EQUAL
20588: IFFALSE 20660
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
20590: LD_INT 68
20592: PPUSH
20593: LD_VAR 0 1
20597: PPUSH
20598: CALL_OW 255
20602: PPUSH
20603: CALL_OW 321
20607: PUSH
20608: LD_INT 2
20610: EQUAL
20611: IFFALSE 20623
// eff := 70 else
20613: LD_ADDR_VAR 0 4
20617: PUSH
20618: LD_INT 70
20620: ST_TO_ADDR
20621: GO 20631
// eff := 30 ;
20623: LD_ADDR_VAR 0 4
20627: PUSH
20628: LD_INT 30
20630: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
20631: LD_VAR 0 1
20635: PPUSH
20636: CALL_OW 250
20640: PPUSH
20641: LD_VAR 0 1
20645: PPUSH
20646: CALL_OW 251
20650: PPUSH
20651: LD_VAR 0 4
20655: PPUSH
20656: CALL_OW 495
// end ; end ;
20660: LD_VAR 0 2
20664: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
20665: LD_INT 0
20667: PPUSH
// end ;
20668: LD_VAR 0 4
20672: RET
// export function SOS_Command ( cmd ) ; begin
20673: LD_INT 0
20675: PPUSH
// end ;
20676: LD_VAR 0 2
20680: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
20681: LD_VAR 0 1
20685: PUSH
20686: LD_INT 255
20688: EQUAL
20689: PUSH
20690: LD_VAR 0 2
20694: PPUSH
20695: CALL_OW 264
20699: PUSH
20700: LD_INT 14
20702: PUSH
20703: LD_INT 53
20705: PUSH
20706: EMPTY
20707: LIST
20708: LIST
20709: IN
20710: AND
20711: PUSH
20712: LD_VAR 0 4
20716: PPUSH
20717: LD_VAR 0 5
20721: PPUSH
20722: CALL_OW 488
20726: AND
20727: IFFALSE 20751
// CutTreeXYR ( unit , x , y , 12 ) ;
20729: LD_VAR 0 2
20733: PPUSH
20734: LD_VAR 0 4
20738: PPUSH
20739: LD_VAR 0 5
20743: PPUSH
20744: LD_INT 12
20746: PPUSH
20747: CALL 20754 0 4
// end ;
20751: PPOPN 5
20753: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
20754: LD_INT 0
20756: PPUSH
20757: PPUSH
20758: PPUSH
20759: PPUSH
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
20764: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
20765: LD_VAR 0 1
20769: NOT
20770: PUSH
20771: LD_VAR 0 2
20775: PPUSH
20776: LD_VAR 0 3
20780: PPUSH
20781: CALL_OW 488
20785: NOT
20786: OR
20787: PUSH
20788: LD_VAR 0 4
20792: NOT
20793: OR
20794: IFFALSE 20798
// exit ;
20796: GO 21138
// list := [ ] ;
20798: LD_ADDR_VAR 0 13
20802: PUSH
20803: EMPTY
20804: ST_TO_ADDR
// if x - r < 0 then
20805: LD_VAR 0 2
20809: PUSH
20810: LD_VAR 0 4
20814: MINUS
20815: PUSH
20816: LD_INT 0
20818: LESS
20819: IFFALSE 20831
// min_x := 0 else
20821: LD_ADDR_VAR 0 7
20825: PUSH
20826: LD_INT 0
20828: ST_TO_ADDR
20829: GO 20847
// min_x := x - r ;
20831: LD_ADDR_VAR 0 7
20835: PUSH
20836: LD_VAR 0 2
20840: PUSH
20841: LD_VAR 0 4
20845: MINUS
20846: ST_TO_ADDR
// if y - r < 0 then
20847: LD_VAR 0 3
20851: PUSH
20852: LD_VAR 0 4
20856: MINUS
20857: PUSH
20858: LD_INT 0
20860: LESS
20861: IFFALSE 20873
// min_y := 0 else
20863: LD_ADDR_VAR 0 8
20867: PUSH
20868: LD_INT 0
20870: ST_TO_ADDR
20871: GO 20889
// min_y := y - r ;
20873: LD_ADDR_VAR 0 8
20877: PUSH
20878: LD_VAR 0 3
20882: PUSH
20883: LD_VAR 0 4
20887: MINUS
20888: ST_TO_ADDR
// max_x := x + r ;
20889: LD_ADDR_VAR 0 9
20893: PUSH
20894: LD_VAR 0 2
20898: PUSH
20899: LD_VAR 0 4
20903: PLUS
20904: ST_TO_ADDR
// max_y := y + r ;
20905: LD_ADDR_VAR 0 10
20909: PUSH
20910: LD_VAR 0 3
20914: PUSH
20915: LD_VAR 0 4
20919: PLUS
20920: ST_TO_ADDR
// for _x = min_x to max_x do
20921: LD_ADDR_VAR 0 11
20925: PUSH
20926: DOUBLE
20927: LD_VAR 0 7
20931: DEC
20932: ST_TO_ADDR
20933: LD_VAR 0 9
20937: PUSH
20938: FOR_TO
20939: IFFALSE 21056
// for _y = min_y to max_y do
20941: LD_ADDR_VAR 0 12
20945: PUSH
20946: DOUBLE
20947: LD_VAR 0 8
20951: DEC
20952: ST_TO_ADDR
20953: LD_VAR 0 10
20957: PUSH
20958: FOR_TO
20959: IFFALSE 21052
// begin if not ValidHex ( _x , _y ) then
20961: LD_VAR 0 11
20965: PPUSH
20966: LD_VAR 0 12
20970: PPUSH
20971: CALL_OW 488
20975: NOT
20976: IFFALSE 20980
// continue ;
20978: GO 20958
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
20980: LD_VAR 0 11
20984: PPUSH
20985: LD_VAR 0 12
20989: PPUSH
20990: CALL_OW 351
20994: PUSH
20995: LD_VAR 0 11
20999: PPUSH
21000: LD_VAR 0 12
21004: PPUSH
21005: CALL_OW 554
21009: AND
21010: IFFALSE 21050
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
21012: LD_ADDR_VAR 0 13
21016: PUSH
21017: LD_VAR 0 13
21021: PPUSH
21022: LD_VAR 0 13
21026: PUSH
21027: LD_INT 1
21029: PLUS
21030: PPUSH
21031: LD_VAR 0 11
21035: PUSH
21036: LD_VAR 0 12
21040: PUSH
21041: EMPTY
21042: LIST
21043: LIST
21044: PPUSH
21045: CALL_OW 2
21049: ST_TO_ADDR
// end ;
21050: GO 20958
21052: POP
21053: POP
21054: GO 20938
21056: POP
21057: POP
// if not list then
21058: LD_VAR 0 13
21062: NOT
21063: IFFALSE 21067
// exit ;
21065: GO 21138
// for i in list do
21067: LD_ADDR_VAR 0 6
21071: PUSH
21072: LD_VAR 0 13
21076: PUSH
21077: FOR_IN
21078: IFFALSE 21136
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
21080: LD_VAR 0 1
21084: PPUSH
21085: LD_STRING M
21087: PUSH
21088: LD_VAR 0 6
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PUSH
21097: LD_VAR 0 6
21101: PUSH
21102: LD_INT 2
21104: ARRAY
21105: PUSH
21106: LD_INT 0
21108: PUSH
21109: LD_INT 0
21111: PUSH
21112: LD_INT 0
21114: PUSH
21115: LD_INT 0
21117: PUSH
21118: EMPTY
21119: LIST
21120: LIST
21121: LIST
21122: LIST
21123: LIST
21124: LIST
21125: LIST
21126: PUSH
21127: EMPTY
21128: LIST
21129: PPUSH
21130: CALL_OW 447
21134: GO 21077
21136: POP
21137: POP
// end ;
21138: LD_VAR 0 5
21142: RET
