// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 136 , 106 ) ;
   4: LD_INT 136
   6: PPUSH
   7: LD_INT 106
   9: PPUSH
  10: CALL_OW 86
// Init ;
  14: CALL 79 0 0
// PrepareNature ( nat_area , wat_area , [ 10 , 2 * Difficulty , 6 , 6 , 3 * Difficulty , 6 , 3 , 3 ] ) ;
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 10
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: LD_OWVAR 67
  34: MUL
  35: PUSH
  36: LD_INT 6
  38: PUSH
  39: LD_INT 6
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: LD_OWVAR 67
  49: MUL
  50: PUSH
  51: LD_INT 6
  53: PUSH
  54: LD_INT 3
  56: PUSH
  57: LD_INT 3
  59: PUSH
  60: EMPTY
  61: LIST
  62: LIST
  63: LIST
  64: LIST
  65: LIST
  66: LIST
  67: LIST
  68: LIST
  69: PPUSH
  70: CALL 399 0 3
// PrepareHunters ( ) ;
  74: CALL 245 0 0
// end ;
  78: END
// export debug , hunterClass , huntersAmount , animalAmount ; export class_horse ; export points , hunters ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// class_horse := 21 ;
  90: LD_ADDR_EXP 5
  94: PUSH
  95: LD_INT 21
  97: ST_TO_ADDR
// if debug then
  98: LD_EXP 1
 102: IFFALSE 137
// begin FogOff ( 1 ) ;
 104: LD_INT 1
 106: PPUSH
 107: CALL_OW 344
// Difficulty := 2 ;
 111: LD_ADDR_OWVAR 67
 115: PUSH
 116: LD_INT 2
 118: ST_TO_ADDR
// hunterClass := 3 ;
 119: LD_ADDR_EXP 2
 123: PUSH
 124: LD_INT 3
 126: ST_TO_ADDR
// animalAmount := 2 ;
 127: LD_ADDR_EXP 4
 131: PUSH
 132: LD_INT 2
 134: ST_TO_ADDR
// end else
 135: GO 176
// begin Difficulty := GetMultiplayerSetting ( 0 ) ;
 137: LD_ADDR_OWVAR 67
 141: PUSH
 142: LD_INT 0
 144: PPUSH
 145: CALL_OW 426
 149: ST_TO_ADDR
// hunterClass := GetMultiplayerSetting ( 2 ) ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_INT 2
 157: PPUSH
 158: CALL_OW 426
 162: ST_TO_ADDR
// animalAmount := GetMultiplayerSetting ( 1 ) ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 1
 170: PPUSH
 171: CALL_OW 426
 175: ST_TO_ADDR
// end ; huntersAmount := [ 4 , 6 , 8 ] [ Difficulty ] ;
 176: LD_ADDR_EXP 3
 180: PUSH
 181: LD_INT 4
 183: PUSH
 184: LD_INT 6
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: LIST
 194: PUSH
 195: LD_OWVAR 67
 199: ARRAY
 200: ST_TO_ADDR
// points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 201: LD_ADDR_EXP 6
 205: PUSH
 206: LD_INT 0
 208: PUSH
 209: LD_INT 0
 211: PUSH
 212: LD_INT 0
 214: PUSH
 215: LD_INT 0
 217: PUSH
 218: LD_INT 0
 220: PUSH
 221: LD_INT 0
 223: PUSH
 224: LD_INT 0
 226: PUSH
 227: LD_INT 0
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// export function PrepareHunters ; var i , un ; begin
 245: LD_INT 0
 247: PPUSH
 248: PPUSH
 249: PPUSH
// for i := 1 to huntersAmount do
 250: LD_ADDR_VAR 0 2
 254: PUSH
 255: DOUBLE
 256: LD_INT 1
 258: DEC
 259: ST_TO_ADDR
 260: LD_EXP 3
 264: PUSH
 265: FOR_TO
 266: IFFALSE 392
// begin uc_side := i ;
 268: LD_ADDR_OWVAR 20
 272: PUSH
 273: LD_VAR 0 2
 277: ST_TO_ADDR
// uc_nation := i mod 3 + 1 ;
 278: LD_ADDR_OWVAR 21
 282: PUSH
 283: LD_VAR 0 2
 287: PUSH
 288: LD_INT 3
 290: MOD
 291: PUSH
 292: LD_INT 1
 294: PLUS
 295: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_sniper , class_desert_warior ] [ hunterClass ] , 10 - Difficulty * 2 ) ;
 296: LD_INT 0
 298: PPUSH
 299: LD_INT 1
 301: PUSH
 302: LD_INT 5
 304: PUSH
 305: LD_INT 11
 307: PUSH
 308: EMPTY
 309: LIST
 310: LIST
 311: LIST
 312: PUSH
 313: LD_EXP 2
 317: ARRAY
 318: PPUSH
 319: LD_INT 10
 321: PUSH
 322: LD_OWVAR 67
 326: PUSH
 327: LD_INT 2
 329: MUL
 330: MINUS
 331: PPUSH
 332: CALL_OW 380
// un := CreateHuman ;
 336: LD_ADDR_VAR 0 3
 340: PUSH
 341: CALL_OW 44
 345: ST_TO_ADDR
// hunters := Replace ( hunters , hunters + 1 , un ) ;
 346: LD_ADDR_EXP 7
 350: PUSH
 351: LD_EXP 7
 355: PPUSH
 356: LD_EXP 7
 360: PUSH
 361: LD_INT 1
 363: PLUS
 364: PPUSH
 365: LD_VAR 0 3
 369: PPUSH
 370: CALL_OW 1
 374: ST_TO_ADDR
// PlaceUnitArea ( un , startArea , false ) ;
 375: LD_VAR 0 3
 379: PPUSH
 380: LD_INT 3
 382: PPUSH
 383: LD_INT 0
 385: PPUSH
 386: CALL_OW 49
// end ;
 390: GO 265
 392: POP
 393: POP
// end ; end_of_file
 394: LD_VAR 0 1
 398: RET
// export function PrepareNature ( area , waterArea , numbers ) ; var i , j , classes , waterClass ; begin
 399: LD_INT 0
 401: PPUSH
 402: PPUSH
 403: PPUSH
 404: PPUSH
 405: PPUSH
// uc_side = 0 ;
 406: LD_ADDR_OWVAR 20
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// uc_nation = 0 ;
 414: LD_ADDR_OWVAR 21
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// classes := [ class_apeman , class_apeman_soldier , class_baggie , class_phororhacos , class_tiger , class_horse ] ;
 422: LD_ADDR_VAR 0 7
 426: PUSH
 427: LD_INT 12
 429: PUSH
 430: LD_INT 15
 432: PUSH
 433: LD_INT 13
 435: PUSH
 436: LD_INT 18
 438: PUSH
 439: LD_INT 14
 441: PUSH
 442: LD_EXP 5
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: ST_TO_ADDR
// waterClass := [ class_fish , class_frog ] ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: LD_INT 20
 462: PUSH
 463: LD_INT 19
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// InitHc_All ( ) ;
 470: CALL_OW 584
// for i := 1 to numbers - 2 do
 474: LD_ADDR_VAR 0 5
 478: PUSH
 479: DOUBLE
 480: LD_INT 1
 482: DEC
 483: ST_TO_ADDR
 484: LD_VAR 0 3
 488: PUSH
 489: LD_INT 2
 491: MINUS
 492: PUSH
 493: FOR_TO
 494: IFFALSE 635
// begin if numbers [ i ] = 0 then
 496: LD_VAR 0 3
 500: PUSH
 501: LD_VAR 0 5
 505: ARRAY
 506: PUSH
 507: LD_INT 0
 509: EQUAL
 510: IFFALSE 514
// continue ;
 512: GO 493
// hc_class := classes [ i ] ;
 514: LD_ADDR_OWVAR 28
 518: PUSH
 519: LD_VAR 0 7
 523: PUSH
 524: LD_VAR 0 5
 528: ARRAY
 529: ST_TO_ADDR
// hc_attr := [ rand ( 8 , 12 ) , rand ( 8 , 12 ) ] ;
 530: LD_ADDR_OWVAR 29
 534: PUSH
 535: LD_INT 8
 537: PPUSH
 538: LD_INT 12
 540: PPUSH
 541: CALL_OW 12
 545: PUSH
 546: LD_INT 8
 548: PPUSH
 549: LD_INT 12
 551: PPUSH
 552: CALL_OW 12
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) + Difficulty * 5 ;
 561: LD_ADDR_OWVAR 35
 565: PUSH
 566: LD_INT 5
 568: NEG
 569: PPUSH
 570: LD_INT 5
 572: PPUSH
 573: CALL_OW 12
 577: PUSH
 578: LD_OWVAR 67
 582: PUSH
 583: LD_INT 5
 585: MUL
 586: PLUS
 587: ST_TO_ADDR
// for j := 1 to numbers [ i ] do
 588: LD_ADDR_VAR 0 6
 592: PUSH
 593: DOUBLE
 594: LD_INT 1
 596: DEC
 597: ST_TO_ADDR
 598: LD_VAR 0 3
 602: PUSH
 603: LD_VAR 0 5
 607: ARRAY
 608: PUSH
 609: FOR_TO
 610: IFFALSE 631
// PlaceUnitArea ( CreateHuman , area , false ) ;
 612: CALL_OW 44
 616: PPUSH
 617: LD_VAR 0 1
 621: PPUSH
 622: LD_INT 0
 624: PPUSH
 625: CALL_OW 49
 629: GO 609
 631: POP
 632: POP
// end ;
 633: GO 493
 635: POP
 636: POP
// if not waterArea then
 637: LD_VAR 0 2
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 806
// hc_class := waterClass [ 1 ] ;
 646: LD_ADDR_OWVAR 28
 650: PUSH
 651: LD_VAR 0 8
 655: PUSH
 656: LD_INT 1
 658: ARRAY
 659: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 660: LD_ADDR_OWVAR 29
 664: PUSH
 665: LD_INT 10
 667: PUSH
 668: LD_INT 10
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: ST_TO_ADDR
// hc_agressivity := 0 ;
 675: LD_ADDR_OWVAR 35
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for j := 1 to numbers [ 7 ] do
 683: LD_ADDR_VAR 0 6
 687: PUSH
 688: DOUBLE
 689: LD_INT 1
 691: DEC
 692: ST_TO_ADDR
 693: LD_VAR 0 3
 697: PUSH
 698: LD_INT 7
 700: ARRAY
 701: PUSH
 702: FOR_TO
 703: IFFALSE 724
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 705: CALL_OW 44
 709: PPUSH
 710: LD_VAR 0 2
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL_OW 49
 722: GO 702
 724: POP
 725: POP
// hc_class := waterClass [ 2 ] ;
 726: LD_ADDR_OWVAR 28
 730: PUSH
 731: LD_VAR 0 8
 735: PUSH
 736: LD_INT 2
 738: ARRAY
 739: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 740: LD_ADDR_OWVAR 29
 744: PUSH
 745: LD_INT 10
 747: PUSH
 748: LD_INT 10
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: ST_TO_ADDR
// hc_agressivity := 0 ;
 755: LD_ADDR_OWVAR 35
 759: PUSH
 760: LD_INT 0
 762: ST_TO_ADDR
// for j := 1 to numbers [ 8 ] do
 763: LD_ADDR_VAR 0 6
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_VAR 0 3
 777: PUSH
 778: LD_INT 8
 780: ARRAY
 781: PUSH
 782: FOR_TO
 783: IFFALSE 804
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 785: CALL_OW 44
 789: PPUSH
 790: LD_VAR 0 2
 794: PPUSH
 795: LD_INT 0
 797: PPUSH
 798: CALL_OW 49
 802: GO 782
 804: POP
 805: POP
// end ; end_of_file
 806: LD_VAR 0 4
 810: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do var i ;
 811: LD_INT 22
 813: PUSH
 814: LD_INT 0
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: PUSH
 821: LD_INT 25
 823: PUSH
 824: LD_INT 15
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: PUSH
 831: EMPTY
 832: LIST
 833: LIST
 834: PPUSH
 835: CALL_OW 69
 839: IFFALSE 945
 841: GO 843
 843: DISABLE
 844: LD_INT 0
 846: PPUSH
// begin enable ;
 847: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do
 848: LD_ADDR_VAR 0 1
 852: PUSH
 853: LD_INT 22
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 25
 865: PUSH
 866: LD_INT 15
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: PUSH
 882: FOR_IN
 883: IFFALSE 943
// if GetLives ( i ) < 1000 then
 885: LD_VAR 0 1
 889: PPUSH
 890: CALL_OW 256
 894: PUSH
 895: LD_INT 1000
 897: LESS
 898: IFFALSE 941
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , i ) ) ;
 900: LD_VAR 0 1
 904: PPUSH
 905: LD_INT 3
 907: PUSH
 908: LD_INT 22
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: PPUSH
 922: CALL_OW 69
 926: PPUSH
 927: LD_VAR 0 1
 931: PPUSH
 932: CALL_OW 74
 936: PPUSH
 937: CALL_OW 115
 941: GO 882
 943: POP
 944: POP
// end ;
 945: PPOPN 1
 947: END
// every 3 do var i , enemy , x , y , d ;
 948: GO 950
 950: DISABLE
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
// begin enable ;
 958: ENABLE
// for i := 2 to huntersAmount do
 959: LD_ADDR_VAR 0 1
 963: PUSH
 964: DOUBLE
 965: LD_INT 2
 967: DEC
 968: ST_TO_ADDR
 969: LD_EXP 3
 973: PUSH
 974: FOR_TO
 975: IFFALSE 1314
// begin if not HasTask ( hunters [ i ] ) then
 977: LD_EXP 7
 981: PUSH
 982: LD_VAR 0 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 314
 992: NOT
 993: IFFALSE 1312
// begin enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 0 ] ) , hunters [ i ] ) ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_INT 22
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 69
1014: PPUSH
1015: LD_EXP 7
1019: PUSH
1020: LD_VAR 0 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 74
1030: ST_TO_ADDR
// if not enemy then
1031: LD_VAR 0 2
1035: NOT
1036: IFFALSE 1040
// continue ;
1038: GO 974
// if GetDistUnits ( hunters [ i ] , enemy ) < 17 then
1040: LD_EXP 7
1044: PUSH
1045: LD_VAR 0 1
1049: ARRAY
1050: PPUSH
1051: LD_VAR 0 2
1055: PPUSH
1056: CALL_OW 296
1060: PUSH
1061: LD_INT 17
1063: LESS
1064: IFFALSE 1167
// begin if GetClass ( hunters [ i ] ) = class_desert_warior then
1066: LD_EXP 7
1070: PUSH
1071: LD_VAR 0 1
1075: ARRAY
1076: PPUSH
1077: CALL_OW 257
1081: PUSH
1082: LD_INT 11
1084: EQUAL
1085: IFFALSE 1145
// if GetClass ( enemy ) in [ class_frog , class_fish , class_baggie ] then
1087: LD_VAR 0 2
1091: PPUSH
1092: CALL_OW 257
1096: PUSH
1097: LD_INT 19
1099: PUSH
1100: LD_INT 20
1102: PUSH
1103: LD_INT 13
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: IN
1111: IFFALSE 1130
// ComCarabine ( hunters [ i ] ) else
1113: LD_EXP 7
1117: PUSH
1118: LD_VAR 0 1
1122: ARRAY
1123: PPUSH
1124: CALL_OW 162
1128: GO 1145
// ComSabre ( hunters [ i ] ) ;
1130: LD_EXP 7
1134: PUSH
1135: LD_VAR 0 1
1139: ARRAY
1140: PPUSH
1141: CALL_OW 163
// ComAttackUnit ( hunters [ i ] , enemy ) ;
1145: LD_EXP 7
1149: PUSH
1150: LD_VAR 0 1
1154: ARRAY
1155: PPUSH
1156: LD_VAR 0 2
1160: PPUSH
1161: CALL_OW 115
// end else
1165: GO 1312
// begin d := rand ( 0 , 5 ) ;
1167: LD_ADDR_VAR 0 5
1171: PUSH
1172: LD_INT 0
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: CALL_OW 12
1182: ST_TO_ADDR
// x := ShiftX ( GetX ( hunters [ i ] ) , d , 8 ) ;
1183: LD_ADDR_VAR 0 3
1187: PUSH
1188: LD_EXP 7
1192: PUSH
1193: LD_VAR 0 1
1197: ARRAY
1198: PPUSH
1199: CALL_OW 250
1203: PPUSH
1204: LD_VAR 0 5
1208: PPUSH
1209: LD_INT 8
1211: PPUSH
1212: CALL_OW 272
1216: ST_TO_ADDR
// y := ShiftY ( GetY ( hunters [ i ] ) , d , 8 ) ;
1217: LD_ADDR_VAR 0 4
1221: PUSH
1222: LD_EXP 7
1226: PUSH
1227: LD_VAR 0 1
1231: ARRAY
1232: PPUSH
1233: CALL_OW 251
1237: PPUSH
1238: LD_VAR 0 5
1242: PPUSH
1243: LD_INT 8
1245: PPUSH
1246: CALL_OW 273
1250: ST_TO_ADDR
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
1251: LD_VAR 0 3
1255: PPUSH
1256: LD_VAR 0 4
1260: PPUSH
1261: CALL_OW 488
1265: PUSH
1266: LD_VAR 0 3
1270: PPUSH
1271: LD_VAR 0 4
1275: PPUSH
1276: CALL_OW 428
1280: PUSH
1281: LD_INT 0
1283: EQUAL
1284: AND
1285: IFFALSE 1312
// ComMoveXY ( hunters [ i ] , x , y ) ;
1287: LD_EXP 7
1291: PUSH
1292: LD_VAR 0 1
1296: ARRAY
1297: PPUSH
1298: LD_VAR 0 3
1302: PPUSH
1303: LD_VAR 0 4
1307: PPUSH
1308: CALL_OW 111
// end ; end ; end ;
1312: GO 974
1314: POP
1315: POP
// end ; end_of_file
1316: PPOPN 5
1318: END
// on UnitGoesToRed ( un ) do var i ;
1319: LD_INT 0
1321: PPUSH
// begin if GetSide ( un ) = 1 then
1322: LD_VAR 0 1
1326: PPUSH
1327: CALL_OW 255
1331: PUSH
1332: LD_INT 1
1334: EQUAL
1335: IFFALSE 1344
// YouLost ( hunt2 ) ;
1337: LD_STRING hunt2
1339: PPUSH
1340: CALL_OW 104
// if GetSide ( un ) > 1 then
1344: LD_VAR 0 1
1348: PPUSH
1349: CALL_OW 255
1353: PUSH
1354: LD_INT 1
1356: GREATER
1357: IFFALSE 1410
// begin for i := 1 to 6 do
1359: LD_ADDR_VAR 0 2
1363: PUSH
1364: DOUBLE
1365: LD_INT 1
1367: DEC
1368: ST_TO_ADDR
1369: LD_INT 6
1371: PUSH
1372: FOR_TO
1373: IFFALSE 1396
// begin wait ( 0 0$1 ) ;
1375: LD_INT 35
1377: PPUSH
1378: CALL_OW 67
// SetLives ( un , 249 ) ;
1382: LD_VAR 0 1
1386: PPUSH
1387: LD_INT 249
1389: PPUSH
1390: CALL_OW 234
// end ;
1394: GO 1372
1396: POP
1397: POP
// SetLives ( un , 1000 ) ;
1398: LD_VAR 0 1
1402: PPUSH
1403: LD_INT 1000
1405: PPUSH
1406: CALL_OW 234
// end ; end ;
1410: PPOPN 2
1412: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 > 1 then
1413: LD_VAR 0 1
1417: PUSH
1418: LD_INT 1
1420: EQUAL
1421: PUSH
1422: LD_VAR 0 2
1426: PUSH
1427: LD_INT 1
1429: GREATER
1430: AND
1431: IFFALSE 1440
// YouLost ( hunt1 ) ;
1433: LD_STRING hunt1
1435: PPUSH
1436: CALL_OW 104
// end ;
1440: PPOPN 2
1442: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do var point ;
1443: LD_INT 0
1445: PPUSH
// begin point := 0 ;
1446: LD_ADDR_VAR 0 4
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// case GetClass ( un ) of class_fish :
1454: LD_VAR 0 1
1458: PPUSH
1459: CALL_OW 257
1463: PUSH
1464: LD_INT 20
1466: DOUBLE
1467: EQUAL
1468: IFTRUE 1472
1470: GO 1483
1472: POP
// point := 10 ; class_horse :
1473: LD_ADDR_VAR 0 4
1477: PUSH
1478: LD_INT 10
1480: ST_TO_ADDR
1481: GO 1619
1483: LD_EXP 5
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1504
1493: POP
// point := 10 ; class_baggie :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 10
1501: ST_TO_ADDR
1502: GO 1619
1504: LD_INT 13
1506: DOUBLE
1507: EQUAL
1508: IFTRUE 1512
1510: GO 1523
1512: POP
// point := 5 ; class_phororhacos :
1513: LD_ADDR_VAR 0 4
1517: PUSH
1518: LD_INT 5
1520: ST_TO_ADDR
1521: GO 1619
1523: LD_INT 18
1525: DOUBLE
1526: EQUAL
1527: IFTRUE 1531
1529: GO 1542
1531: POP
// point := 10 ; class_tiger :
1532: LD_ADDR_VAR 0 4
1536: PUSH
1537: LD_INT 10
1539: ST_TO_ADDR
1540: GO 1619
1542: LD_INT 14
1544: DOUBLE
1545: EQUAL
1546: IFTRUE 1550
1548: GO 1561
1550: POP
// point := 20 ; class_apeman :
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_INT 20
1558: ST_TO_ADDR
1559: GO 1619
1561: LD_INT 12
1563: DOUBLE
1564: EQUAL
1565: IFTRUE 1569
1567: GO 1580
1569: POP
// point := 30 ; class_apeman_soldier :
1570: LD_ADDR_VAR 0 4
1574: PUSH
1575: LD_INT 30
1577: ST_TO_ADDR
1578: GO 1619
1580: LD_INT 15
1582: DOUBLE
1583: EQUAL
1584: IFTRUE 1588
1586: GO 1599
1588: POP
// point := 50 ; class_frog :
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_INT 50
1596: ST_TO_ADDR
1597: GO 1619
1599: LD_INT 19
1601: DOUBLE
1602: EQUAL
1603: IFTRUE 1607
1605: GO 1618
1607: POP
// point := 10 ; end ;
1608: LD_ADDR_VAR 0 4
1612: PUSH
1613: LD_INT 10
1615: ST_TO_ADDR
1616: GO 1619
1618: POP
// if point then
1619: LD_VAR 0 4
1623: IFFALSE 1662
// points := Replace ( points , killer_side , points [ killer_side ] + point ) ;
1625: LD_ADDR_EXP 6
1629: PUSH
1630: LD_EXP 6
1634: PPUSH
1635: LD_VAR 0 2
1639: PPUSH
1640: LD_EXP 6
1644: PUSH
1645: LD_VAR 0 2
1649: ARRAY
1650: PUSH
1651: LD_VAR 0 4
1655: PLUS
1656: PPUSH
1657: CALL_OW 1
1661: ST_TO_ADDR
// end ;
1662: PPOPN 4
1664: END
// every 0 0$20 trigger FilterAllUnits ( [ f_side , 0 ] ) < 10 do
1665: LD_INT 22
1667: PUSH
1668: LD_INT 0
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: PPUSH
1675: CALL_OW 69
1679: PUSH
1680: LD_INT 10
1682: LESS
1683: IFFALSE 1797
1685: GO 1687
1687: DISABLE
// begin enable ;
1688: ENABLE
// PrepareNature ( nat_area , wat_area , [ rand ( 0 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 2 , 4 ) , rand ( 2 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 0 , 2 ) ] ) ;
1689: LD_INT 2
1691: PPUSH
1692: LD_INT 1
1694: PPUSH
1695: LD_INT 0
1697: PPUSH
1698: LD_INT 4
1700: PPUSH
1701: CALL_OW 12
1705: PUSH
1706: LD_INT 0
1708: PPUSH
1709: LD_INT 2
1711: PPUSH
1712: CALL_OW 12
1716: PUSH
1717: LD_INT 0
1719: PPUSH
1720: LD_INT 4
1722: PPUSH
1723: CALL_OW 12
1727: PUSH
1728: LD_INT 2
1730: PPUSH
1731: LD_INT 4
1733: PPUSH
1734: CALL_OW 12
1738: PUSH
1739: LD_INT 2
1741: PPUSH
1742: LD_INT 4
1744: PPUSH
1745: CALL_OW 12
1749: PUSH
1750: LD_INT 0
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PUSH
1761: LD_INT 0
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 0
1774: PPUSH
1775: LD_INT 2
1777: PPUSH
1778: CALL_OW 12
1782: PUSH
1783: EMPTY
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: PPUSH
1793: CALL 399 0 3
// end ;
1797: END
// every 0 0$1 do var i ;
1798: GO 1800
1800: DISABLE
1801: LD_INT 0
1803: PPUSH
// begin enable ;
1804: ENABLE
// display_strings := [ ] ;
1805: LD_ADDR_OWVAR 47
1809: PUSH
1810: EMPTY
1811: ST_TO_ADDR
// for i := 1 to huntersAmount do
1812: LD_ADDR_VAR 0 1
1816: PUSH
1817: DOUBLE
1818: LD_INT 1
1820: DEC
1821: ST_TO_ADDR
1822: LD_EXP 3
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1962
// begin display_strings := display_strings ^ [ #player & i , i , points [ i ] ] ;
1830: LD_ADDR_OWVAR 47
1834: PUSH
1835: LD_OWVAR 47
1839: PUSH
1840: LD_STRING #player
1842: PUSH
1843: LD_VAR 0 1
1847: STR
1848: PUSH
1849: LD_VAR 0 1
1853: PUSH
1854: LD_EXP 6
1858: PUSH
1859: LD_VAR 0 1
1863: ARRAY
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: ADD
1870: ST_TO_ADDR
// if points [ i ] >= [ 750 , 1250 , 2000 ] [ Difficulty ] then
1871: LD_EXP 6
1875: PUSH
1876: LD_VAR 0 1
1880: ARRAY
1881: PUSH
1882: LD_INT 750
1884: PUSH
1885: LD_INT 1250
1887: PUSH
1888: LD_INT 2000
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: PUSH
1896: LD_OWVAR 67
1900: ARRAY
1901: GREATEREQUAL
1902: IFFALSE 1960
// begin if i = 1 then
1904: LD_VAR 0 1
1908: PUSH
1909: LD_INT 1
1911: EQUAL
1912: IFFALSE 1953
// begin DialogueOn ;
1914: CALL_OW 6
// SetAchievement ( ACH_HUNT ) ;
1918: LD_STRING ACH_HUNT
1920: PPUSH
1921: CALL_OW 543
// display_strings := [ #hunting-win ] ;
1925: LD_ADDR_OWVAR 47
1929: PUSH
1930: LD_STRING #hunting-win
1932: PUSH
1933: EMPTY
1934: LIST
1935: ST_TO_ADDR
// dwait ( 0 0$5 ) ;
1936: LD_INT 175
1938: PPUSH
1939: CALL_OW 68
// YouWin ;
1943: CALL_OW 103
// DialogueOff ;
1947: CALL_OW 7
// end else
1951: GO 1960
// YouLost ( hunt3 ) ;
1953: LD_STRING hunt3
1955: PPUSH
1956: CALL_OW 104
// end ; end ;
1960: GO 1827
1962: POP
1963: POP
// end ; end_of_file end_of_file
1964: PPOPN 1
1966: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
1967: LD_VAR 0 2
1971: PUSH
1972: LD_INT 100
1974: EQUAL
1975: IFFALSE 2924
// begin if not StreamModeActive then
1977: LD_EXP 8
1981: NOT
1982: IFFALSE 1992
// StreamModeActive := true ;
1984: LD_ADDR_EXP 8
1988: PUSH
1989: LD_INT 1
1991: ST_TO_ADDR
// if p3 = 0 then
1992: LD_VAR 0 3
1996: PUSH
1997: LD_INT 0
1999: EQUAL
2000: IFFALSE 2006
// InitStreamMode ;
2002: CALL 3157 0 0
// if p3 = 1 then
2006: LD_VAR 0 3
2010: PUSH
2011: LD_INT 1
2013: EQUAL
2014: IFFALSE 2024
// sRocket := true ;
2016: LD_ADDR_EXP 13
2020: PUSH
2021: LD_INT 1
2023: ST_TO_ADDR
// if p3 = 2 then
2024: LD_VAR 0 3
2028: PUSH
2029: LD_INT 2
2031: EQUAL
2032: IFFALSE 2042
// sSpeed := true ;
2034: LD_ADDR_EXP 12
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// if p3 = 3 then
2042: LD_VAR 0 3
2046: PUSH
2047: LD_INT 3
2049: EQUAL
2050: IFFALSE 2060
// sEngine := true ;
2052: LD_ADDR_EXP 14
2056: PUSH
2057: LD_INT 1
2059: ST_TO_ADDR
// if p3 = 4 then
2060: LD_VAR 0 3
2064: PUSH
2065: LD_INT 4
2067: EQUAL
2068: IFFALSE 2078
// sSpec := true ;
2070: LD_ADDR_EXP 11
2074: PUSH
2075: LD_INT 1
2077: ST_TO_ADDR
// if p3 = 5 then
2078: LD_VAR 0 3
2082: PUSH
2083: LD_INT 5
2085: EQUAL
2086: IFFALSE 2096
// sLevel := true ;
2088: LD_ADDR_EXP 15
2092: PUSH
2093: LD_INT 1
2095: ST_TO_ADDR
// if p3 = 6 then
2096: LD_VAR 0 3
2100: PUSH
2101: LD_INT 6
2103: EQUAL
2104: IFFALSE 2114
// sArmoury := true ;
2106: LD_ADDR_EXP 16
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// if p3 = 7 then
2114: LD_VAR 0 3
2118: PUSH
2119: LD_INT 7
2121: EQUAL
2122: IFFALSE 2132
// sRadar := true ;
2124: LD_ADDR_EXP 17
2128: PUSH
2129: LD_INT 1
2131: ST_TO_ADDR
// if p3 = 8 then
2132: LD_VAR 0 3
2136: PUSH
2137: LD_INT 8
2139: EQUAL
2140: IFFALSE 2150
// sBunker := true ;
2142: LD_ADDR_EXP 18
2146: PUSH
2147: LD_INT 1
2149: ST_TO_ADDR
// if p3 = 9 then
2150: LD_VAR 0 3
2154: PUSH
2155: LD_INT 9
2157: EQUAL
2158: IFFALSE 2168
// sHack := true ;
2160: LD_ADDR_EXP 19
2164: PUSH
2165: LD_INT 1
2167: ST_TO_ADDR
// if p3 = 10 then
2168: LD_VAR 0 3
2172: PUSH
2173: LD_INT 10
2175: EQUAL
2176: IFFALSE 2186
// sFire := true ;
2178: LD_ADDR_EXP 20
2182: PUSH
2183: LD_INT 1
2185: ST_TO_ADDR
// if p3 = 11 then
2186: LD_VAR 0 3
2190: PUSH
2191: LD_INT 11
2193: EQUAL
2194: IFFALSE 2204
// sRefresh := true ;
2196: LD_ADDR_EXP 21
2200: PUSH
2201: LD_INT 1
2203: ST_TO_ADDR
// if p3 = 12 then
2204: LD_VAR 0 3
2208: PUSH
2209: LD_INT 12
2211: EQUAL
2212: IFFALSE 2222
// sExp := true ;
2214: LD_ADDR_EXP 22
2218: PUSH
2219: LD_INT 1
2221: ST_TO_ADDR
// if p3 = 13 then
2222: LD_VAR 0 3
2226: PUSH
2227: LD_INT 13
2229: EQUAL
2230: IFFALSE 2240
// sDepot := true ;
2232: LD_ADDR_EXP 23
2236: PUSH
2237: LD_INT 1
2239: ST_TO_ADDR
// if p3 = 14 then
2240: LD_VAR 0 3
2244: PUSH
2245: LD_INT 14
2247: EQUAL
2248: IFFALSE 2258
// sFlag := true ;
2250: LD_ADDR_EXP 24
2254: PUSH
2255: LD_INT 1
2257: ST_TO_ADDR
// if p3 = 15 then
2258: LD_VAR 0 3
2262: PUSH
2263: LD_INT 15
2265: EQUAL
2266: IFFALSE 2276
// sKamikadze := true ;
2268: LD_ADDR_EXP 32
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// if p3 = 16 then
2276: LD_VAR 0 3
2280: PUSH
2281: LD_INT 16
2283: EQUAL
2284: IFFALSE 2294
// sTroll := true ;
2286: LD_ADDR_EXP 33
2290: PUSH
2291: LD_INT 1
2293: ST_TO_ADDR
// if p3 = 17 then
2294: LD_VAR 0 3
2298: PUSH
2299: LD_INT 17
2301: EQUAL
2302: IFFALSE 2312
// sSlow := true ;
2304: LD_ADDR_EXP 34
2308: PUSH
2309: LD_INT 1
2311: ST_TO_ADDR
// if p3 = 18 then
2312: LD_VAR 0 3
2316: PUSH
2317: LD_INT 18
2319: EQUAL
2320: IFFALSE 2330
// sLack := true ;
2322: LD_ADDR_EXP 35
2326: PUSH
2327: LD_INT 1
2329: ST_TO_ADDR
// if p3 = 19 then
2330: LD_VAR 0 3
2334: PUSH
2335: LD_INT 19
2337: EQUAL
2338: IFFALSE 2348
// sTank := true ;
2340: LD_ADDR_EXP 37
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// if p3 = 20 then
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 20
2355: EQUAL
2356: IFFALSE 2366
// sRemote := true ;
2358: LD_ADDR_EXP 38
2362: PUSH
2363: LD_INT 1
2365: ST_TO_ADDR
// if p3 = 21 then
2366: LD_VAR 0 3
2370: PUSH
2371: LD_INT 21
2373: EQUAL
2374: IFFALSE 2384
// sPowell := true ;
2376: LD_ADDR_EXP 39
2380: PUSH
2381: LD_INT 1
2383: ST_TO_ADDR
// if p3 = 22 then
2384: LD_VAR 0 3
2388: PUSH
2389: LD_INT 22
2391: EQUAL
2392: IFFALSE 2402
// sTeleport := true ;
2394: LD_ADDR_EXP 42
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// if p3 = 23 then
2402: LD_VAR 0 3
2406: PUSH
2407: LD_INT 23
2409: EQUAL
2410: IFFALSE 2420
// sOilTower := true ;
2412: LD_ADDR_EXP 44
2416: PUSH
2417: LD_INT 1
2419: ST_TO_ADDR
// if p3 = 24 then
2420: LD_VAR 0 3
2424: PUSH
2425: LD_INT 24
2427: EQUAL
2428: IFFALSE 2438
// sShovel := true ;
2430: LD_ADDR_EXP 45
2434: PUSH
2435: LD_INT 1
2437: ST_TO_ADDR
// if p3 = 25 then
2438: LD_VAR 0 3
2442: PUSH
2443: LD_INT 25
2445: EQUAL
2446: IFFALSE 2456
// sSheik := true ;
2448: LD_ADDR_EXP 46
2452: PUSH
2453: LD_INT 1
2455: ST_TO_ADDR
// if p3 = 26 then
2456: LD_VAR 0 3
2460: PUSH
2461: LD_INT 26
2463: EQUAL
2464: IFFALSE 2474
// sEarthquake := true ;
2466: LD_ADDR_EXP 48
2470: PUSH
2471: LD_INT 1
2473: ST_TO_ADDR
// if p3 = 27 then
2474: LD_VAR 0 3
2478: PUSH
2479: LD_INT 27
2481: EQUAL
2482: IFFALSE 2492
// sAI := true ;
2484: LD_ADDR_EXP 49
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// if p3 = 28 then
2492: LD_VAR 0 3
2496: PUSH
2497: LD_INT 28
2499: EQUAL
2500: IFFALSE 2510
// sCargo := true ;
2502: LD_ADDR_EXP 52
2506: PUSH
2507: LD_INT 1
2509: ST_TO_ADDR
// if p3 = 29 then
2510: LD_VAR 0 3
2514: PUSH
2515: LD_INT 29
2517: EQUAL
2518: IFFALSE 2528
// sDLaser := true ;
2520: LD_ADDR_EXP 53
2524: PUSH
2525: LD_INT 1
2527: ST_TO_ADDR
// if p3 = 30 then
2528: LD_VAR 0 3
2532: PUSH
2533: LD_INT 30
2535: EQUAL
2536: IFFALSE 2546
// sExchange := true ;
2538: LD_ADDR_EXP 54
2542: PUSH
2543: LD_INT 1
2545: ST_TO_ADDR
// if p3 = 31 then
2546: LD_VAR 0 3
2550: PUSH
2551: LD_INT 31
2553: EQUAL
2554: IFFALSE 2564
// sFac := true ;
2556: LD_ADDR_EXP 55
2560: PUSH
2561: LD_INT 1
2563: ST_TO_ADDR
// if p3 = 32 then
2564: LD_VAR 0 3
2568: PUSH
2569: LD_INT 32
2571: EQUAL
2572: IFFALSE 2582
// sPower := true ;
2574: LD_ADDR_EXP 56
2578: PUSH
2579: LD_INT 1
2581: ST_TO_ADDR
// if p3 = 33 then
2582: LD_VAR 0 3
2586: PUSH
2587: LD_INT 33
2589: EQUAL
2590: IFFALSE 2600
// sRandom := true ;
2592: LD_ADDR_EXP 57
2596: PUSH
2597: LD_INT 1
2599: ST_TO_ADDR
// if p3 = 34 then
2600: LD_VAR 0 3
2604: PUSH
2605: LD_INT 34
2607: EQUAL
2608: IFFALSE 2618
// sShield := true ;
2610: LD_ADDR_EXP 58
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// if p3 = 35 then
2618: LD_VAR 0 3
2622: PUSH
2623: LD_INT 35
2625: EQUAL
2626: IFFALSE 2636
// sTime := true ;
2628: LD_ADDR_EXP 59
2632: PUSH
2633: LD_INT 1
2635: ST_TO_ADDR
// if p3 = 36 then
2636: LD_VAR 0 3
2640: PUSH
2641: LD_INT 36
2643: EQUAL
2644: IFFALSE 2654
// sTools := true ;
2646: LD_ADDR_EXP 60
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// if p3 = 101 then
2654: LD_VAR 0 3
2658: PUSH
2659: LD_INT 101
2661: EQUAL
2662: IFFALSE 2672
// sSold := true ;
2664: LD_ADDR_EXP 25
2668: PUSH
2669: LD_INT 1
2671: ST_TO_ADDR
// if p3 = 102 then
2672: LD_VAR 0 3
2676: PUSH
2677: LD_INT 102
2679: EQUAL
2680: IFFALSE 2690
// sDiff := true ;
2682: LD_ADDR_EXP 26
2686: PUSH
2687: LD_INT 1
2689: ST_TO_ADDR
// if p3 = 103 then
2690: LD_VAR 0 3
2694: PUSH
2695: LD_INT 103
2697: EQUAL
2698: IFFALSE 2708
// sFog := true ;
2700: LD_ADDR_EXP 29
2704: PUSH
2705: LD_INT 1
2707: ST_TO_ADDR
// if p3 = 104 then
2708: LD_VAR 0 3
2712: PUSH
2713: LD_INT 104
2715: EQUAL
2716: IFFALSE 2726
// sReset := true ;
2718: LD_ADDR_EXP 30
2722: PUSH
2723: LD_INT 1
2725: ST_TO_ADDR
// if p3 = 105 then
2726: LD_VAR 0 3
2730: PUSH
2731: LD_INT 105
2733: EQUAL
2734: IFFALSE 2744
// sSun := true ;
2736: LD_ADDR_EXP 31
2740: PUSH
2741: LD_INT 1
2743: ST_TO_ADDR
// if p3 = 106 then
2744: LD_VAR 0 3
2748: PUSH
2749: LD_INT 106
2751: EQUAL
2752: IFFALSE 2762
// sTiger := true ;
2754: LD_ADDR_EXP 27
2758: PUSH
2759: LD_INT 1
2761: ST_TO_ADDR
// if p3 = 107 then
2762: LD_VAR 0 3
2766: PUSH
2767: LD_INT 107
2769: EQUAL
2770: IFFALSE 2780
// sBomb := true ;
2772: LD_ADDR_EXP 28
2776: PUSH
2777: LD_INT 1
2779: ST_TO_ADDR
// if p3 = 108 then
2780: LD_VAR 0 3
2784: PUSH
2785: LD_INT 108
2787: EQUAL
2788: IFFALSE 2798
// sWound := true ;
2790: LD_ADDR_EXP 36
2794: PUSH
2795: LD_INT 1
2797: ST_TO_ADDR
// if p3 = 109 then
2798: LD_VAR 0 3
2802: PUSH
2803: LD_INT 109
2805: EQUAL
2806: IFFALSE 2816
// sBetray := true ;
2808: LD_ADDR_EXP 40
2812: PUSH
2813: LD_INT 1
2815: ST_TO_ADDR
// if p3 = 110 then
2816: LD_VAR 0 3
2820: PUSH
2821: LD_INT 110
2823: EQUAL
2824: IFFALSE 2834
// sContamin := true ;
2826: LD_ADDR_EXP 41
2830: PUSH
2831: LD_INT 1
2833: ST_TO_ADDR
// if p3 = 111 then
2834: LD_VAR 0 3
2838: PUSH
2839: LD_INT 111
2841: EQUAL
2842: IFFALSE 2852
// sOil := true ;
2844: LD_ADDR_EXP 43
2848: PUSH
2849: LD_INT 1
2851: ST_TO_ADDR
// if p3 = 112 then
2852: LD_VAR 0 3
2856: PUSH
2857: LD_INT 112
2859: EQUAL
2860: IFFALSE 2870
// sStu := true ;
2862: LD_ADDR_EXP 47
2866: PUSH
2867: LD_INT 1
2869: ST_TO_ADDR
// if p3 = 113 then
2870: LD_VAR 0 3
2874: PUSH
2875: LD_INT 113
2877: EQUAL
2878: IFFALSE 2888
// sBazooka := true ;
2880: LD_ADDR_EXP 50
2884: PUSH
2885: LD_INT 1
2887: ST_TO_ADDR
// if p3 = 114 then
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 114
2895: EQUAL
2896: IFFALSE 2906
// sMortar := true ;
2898: LD_ADDR_EXP 51
2902: PUSH
2903: LD_INT 1
2905: ST_TO_ADDR
// if p3 = 115 then
2906: LD_VAR 0 3
2910: PUSH
2911: LD_INT 115
2913: EQUAL
2914: IFFALSE 2924
// sRanger := true ;
2916: LD_ADDR_EXP 61
2920: PUSH
2921: LD_INT 1
2923: ST_TO_ADDR
// end ; if p2 = 101 then
2924: LD_VAR 0 2
2928: PUSH
2929: LD_INT 101
2931: EQUAL
2932: IFFALSE 3135
// begin case p3 of 1 :
2934: LD_VAR 0 3
2938: PUSH
2939: LD_INT 1
2941: DOUBLE
2942: EQUAL
2943: IFTRUE 2947
2945: GO 2954
2947: POP
// hHackUnlimitedResources ; 2 :
2948: CALL 13229 0 0
2952: GO 3135
2954: LD_INT 2
2956: DOUBLE
2957: EQUAL
2958: IFTRUE 2962
2960: GO 2969
2962: POP
// hHackSetLevel10 ; 3 :
2963: CALL 13362 0 0
2967: GO 3135
2969: LD_INT 3
2971: DOUBLE
2972: EQUAL
2973: IFTRUE 2977
2975: GO 2984
2977: POP
// hHackSetLevel10YourUnits ; 4 :
2978: CALL 13447 0 0
2982: GO 3135
2984: LD_INT 4
2986: DOUBLE
2987: EQUAL
2988: IFTRUE 2992
2990: GO 3014
2992: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
2993: LD_VAR 0 4
2997: PPUSH
2998: LD_VAR 0 5
3002: PPUSH
3003: LD_VAR 0 6
3007: PPUSH
3008: CALL 13537 0 3
3012: GO 3135
3014: LD_INT 5
3016: DOUBLE
3017: EQUAL
3018: IFTRUE 3022
3020: GO 3029
3022: POP
// hHackSpawnVehicle ; 6 :
3023: CALL 13598 0 0
3027: GO 3135
3029: LD_INT 6
3031: DOUBLE
3032: EQUAL
3033: IFTRUE 3037
3035: GO 3044
3037: POP
// hHackInvincible ; 7 :
3038: CALL 14144 0 0
3042: GO 3135
3044: LD_INT 7
3046: DOUBLE
3047: EQUAL
3048: IFTRUE 3052
3050: GO 3059
3052: POP
// hHackInvisible ; 8 :
3053: CALL 14255 0 0
3057: GO 3135
3059: LD_INT 8
3061: DOUBLE
3062: EQUAL
3063: IFTRUE 3067
3065: GO 3074
3067: POP
// hHackChangeYourSide ; 9 :
3068: CALL 14312 0 0
3072: GO 3135
3074: LD_INT 9
3076: DOUBLE
3077: EQUAL
3078: IFTRUE 3082
3080: GO 3089
3082: POP
// hHackChangeUnitSide ; 10 :
3083: CALL 14354 0 0
3087: GO 3135
3089: LD_INT 10
3091: DOUBLE
3092: EQUAL
3093: IFTRUE 3097
3095: GO 3104
3097: POP
// hHackFog ; 11 :
3098: CALL 14455 0 0
3102: GO 3135
3104: LD_INT 11
3106: DOUBLE
3107: EQUAL
3108: IFTRUE 3112
3110: GO 3119
3112: POP
// hHackApeman ; 12 :
3113: CALL 14470 0 0
3117: GO 3135
3119: LD_INT 12
3121: DOUBLE
3122: EQUAL
3123: IFTRUE 3127
3125: GO 3134
3127: POP
// hHackBoom ; end ;
3128: CALL 14555 0 0
3132: GO 3135
3134: POP
// end ; end ;
3135: PPOPN 6
3137: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
3138: GO 3140
3140: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
3141: LD_STRING initStreamRollete();
3143: PPUSH
3144: CALL_OW 559
// InitStreamMode ;
3148: CALL 3157 0 0
// DefineStreamItems ( ) ;
3152: CALL 3597 0 0
// end ;
3156: END
// function InitStreamMode ; begin
3157: LD_INT 0
3159: PPUSH
// streamModeActive := false ;
3160: LD_ADDR_EXP 8
3164: PUSH
3165: LD_INT 0
3167: ST_TO_ADDR
// normalCounter := 36 ;
3168: LD_ADDR_EXP 9
3172: PUSH
3173: LD_INT 36
3175: ST_TO_ADDR
// hardcoreCounter := 16 ;
3176: LD_ADDR_EXP 10
3180: PUSH
3181: LD_INT 16
3183: ST_TO_ADDR
// sRocket := false ;
3184: LD_ADDR_EXP 13
3188: PUSH
3189: LD_INT 0
3191: ST_TO_ADDR
// sSpeed := false ;
3192: LD_ADDR_EXP 12
3196: PUSH
3197: LD_INT 0
3199: ST_TO_ADDR
// sEngine := false ;
3200: LD_ADDR_EXP 14
3204: PUSH
3205: LD_INT 0
3207: ST_TO_ADDR
// sSpec := false ;
3208: LD_ADDR_EXP 11
3212: PUSH
3213: LD_INT 0
3215: ST_TO_ADDR
// sLevel := false ;
3216: LD_ADDR_EXP 15
3220: PUSH
3221: LD_INT 0
3223: ST_TO_ADDR
// sArmoury := false ;
3224: LD_ADDR_EXP 16
3228: PUSH
3229: LD_INT 0
3231: ST_TO_ADDR
// sRadar := false ;
3232: LD_ADDR_EXP 17
3236: PUSH
3237: LD_INT 0
3239: ST_TO_ADDR
// sBunker := false ;
3240: LD_ADDR_EXP 18
3244: PUSH
3245: LD_INT 0
3247: ST_TO_ADDR
// sHack := false ;
3248: LD_ADDR_EXP 19
3252: PUSH
3253: LD_INT 0
3255: ST_TO_ADDR
// sFire := false ;
3256: LD_ADDR_EXP 20
3260: PUSH
3261: LD_INT 0
3263: ST_TO_ADDR
// sRefresh := false ;
3264: LD_ADDR_EXP 21
3268: PUSH
3269: LD_INT 0
3271: ST_TO_ADDR
// sExp := false ;
3272: LD_ADDR_EXP 22
3276: PUSH
3277: LD_INT 0
3279: ST_TO_ADDR
// sDepot := false ;
3280: LD_ADDR_EXP 23
3284: PUSH
3285: LD_INT 0
3287: ST_TO_ADDR
// sFlag := false ;
3288: LD_ADDR_EXP 24
3292: PUSH
3293: LD_INT 0
3295: ST_TO_ADDR
// sKamikadze := false ;
3296: LD_ADDR_EXP 32
3300: PUSH
3301: LD_INT 0
3303: ST_TO_ADDR
// sTroll := false ;
3304: LD_ADDR_EXP 33
3308: PUSH
3309: LD_INT 0
3311: ST_TO_ADDR
// sSlow := false ;
3312: LD_ADDR_EXP 34
3316: PUSH
3317: LD_INT 0
3319: ST_TO_ADDR
// sLack := false ;
3320: LD_ADDR_EXP 35
3324: PUSH
3325: LD_INT 0
3327: ST_TO_ADDR
// sTank := false ;
3328: LD_ADDR_EXP 37
3332: PUSH
3333: LD_INT 0
3335: ST_TO_ADDR
// sRemote := false ;
3336: LD_ADDR_EXP 38
3340: PUSH
3341: LD_INT 0
3343: ST_TO_ADDR
// sPowell := false ;
3344: LD_ADDR_EXP 39
3348: PUSH
3349: LD_INT 0
3351: ST_TO_ADDR
// sTeleport := false ;
3352: LD_ADDR_EXP 42
3356: PUSH
3357: LD_INT 0
3359: ST_TO_ADDR
// sOilTower := false ;
3360: LD_ADDR_EXP 44
3364: PUSH
3365: LD_INT 0
3367: ST_TO_ADDR
// sShovel := false ;
3368: LD_ADDR_EXP 45
3372: PUSH
3373: LD_INT 0
3375: ST_TO_ADDR
// sSheik := false ;
3376: LD_ADDR_EXP 46
3380: PUSH
3381: LD_INT 0
3383: ST_TO_ADDR
// sEarthquake := false ;
3384: LD_ADDR_EXP 48
3388: PUSH
3389: LD_INT 0
3391: ST_TO_ADDR
// sAI := false ;
3392: LD_ADDR_EXP 49
3396: PUSH
3397: LD_INT 0
3399: ST_TO_ADDR
// sCargo := false ;
3400: LD_ADDR_EXP 52
3404: PUSH
3405: LD_INT 0
3407: ST_TO_ADDR
// sDLaser := false ;
3408: LD_ADDR_EXP 53
3412: PUSH
3413: LD_INT 0
3415: ST_TO_ADDR
// sExchange := false ;
3416: LD_ADDR_EXP 54
3420: PUSH
3421: LD_INT 0
3423: ST_TO_ADDR
// sFac := false ;
3424: LD_ADDR_EXP 55
3428: PUSH
3429: LD_INT 0
3431: ST_TO_ADDR
// sPower := false ;
3432: LD_ADDR_EXP 56
3436: PUSH
3437: LD_INT 0
3439: ST_TO_ADDR
// sRandom := false ;
3440: LD_ADDR_EXP 57
3444: PUSH
3445: LD_INT 0
3447: ST_TO_ADDR
// sShield := false ;
3448: LD_ADDR_EXP 58
3452: PUSH
3453: LD_INT 0
3455: ST_TO_ADDR
// sTime := false ;
3456: LD_ADDR_EXP 59
3460: PUSH
3461: LD_INT 0
3463: ST_TO_ADDR
// sTools := false ;
3464: LD_ADDR_EXP 60
3468: PUSH
3469: LD_INT 0
3471: ST_TO_ADDR
// sSold := false ;
3472: LD_ADDR_EXP 25
3476: PUSH
3477: LD_INT 0
3479: ST_TO_ADDR
// sDiff := false ;
3480: LD_ADDR_EXP 26
3484: PUSH
3485: LD_INT 0
3487: ST_TO_ADDR
// sFog := false ;
3488: LD_ADDR_EXP 29
3492: PUSH
3493: LD_INT 0
3495: ST_TO_ADDR
// sReset := false ;
3496: LD_ADDR_EXP 30
3500: PUSH
3501: LD_INT 0
3503: ST_TO_ADDR
// sSun := false ;
3504: LD_ADDR_EXP 31
3508: PUSH
3509: LD_INT 0
3511: ST_TO_ADDR
// sTiger := false ;
3512: LD_ADDR_EXP 27
3516: PUSH
3517: LD_INT 0
3519: ST_TO_ADDR
// sBomb := false ;
3520: LD_ADDR_EXP 28
3524: PUSH
3525: LD_INT 0
3527: ST_TO_ADDR
// sWound := false ;
3528: LD_ADDR_EXP 36
3532: PUSH
3533: LD_INT 0
3535: ST_TO_ADDR
// sBetray := false ;
3536: LD_ADDR_EXP 40
3540: PUSH
3541: LD_INT 0
3543: ST_TO_ADDR
// sContamin := false ;
3544: LD_ADDR_EXP 41
3548: PUSH
3549: LD_INT 0
3551: ST_TO_ADDR
// sOil := false ;
3552: LD_ADDR_EXP 43
3556: PUSH
3557: LD_INT 0
3559: ST_TO_ADDR
// sStu := false ;
3560: LD_ADDR_EXP 47
3564: PUSH
3565: LD_INT 0
3567: ST_TO_ADDR
// sBazooka := false ;
3568: LD_ADDR_EXP 50
3572: PUSH
3573: LD_INT 0
3575: ST_TO_ADDR
// sMortar := false ;
3576: LD_ADDR_EXP 51
3580: PUSH
3581: LD_INT 0
3583: ST_TO_ADDR
// sRanger := false ;
3584: LD_ADDR_EXP 61
3588: PUSH
3589: LD_INT 0
3591: ST_TO_ADDR
// end ;
3592: LD_VAR 0 1
3596: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
3597: LD_INT 0
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
// result := [ ] ;
3604: LD_ADDR_VAR 0 1
3608: PUSH
3609: EMPTY
3610: ST_TO_ADDR
// if campaign_id = 1 then
3611: LD_OWVAR 69
3615: PUSH
3616: LD_INT 1
3618: EQUAL
3619: IFFALSE 6557
// begin case mission_number of 1 :
3621: LD_OWVAR 70
3625: PUSH
3626: LD_INT 1
3628: DOUBLE
3629: EQUAL
3630: IFTRUE 3634
3632: GO 3698
3634: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
3635: LD_ADDR_VAR 0 1
3639: PUSH
3640: LD_INT 2
3642: PUSH
3643: LD_INT 4
3645: PUSH
3646: LD_INT 11
3648: PUSH
3649: LD_INT 12
3651: PUSH
3652: LD_INT 15
3654: PUSH
3655: LD_INT 16
3657: PUSH
3658: LD_INT 22
3660: PUSH
3661: LD_INT 23
3663: PUSH
3664: LD_INT 26
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: LIST
3671: LIST
3672: LIST
3673: LIST
3674: LIST
3675: LIST
3676: LIST
3677: PUSH
3678: LD_INT 101
3680: PUSH
3681: LD_INT 102
3683: PUSH
3684: LD_INT 106
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: ST_TO_ADDR
3696: GO 6555
3698: LD_INT 2
3700: DOUBLE
3701: EQUAL
3702: IFTRUE 3706
3704: GO 3778
3706: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
3707: LD_ADDR_VAR 0 1
3711: PUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 11
3720: PUSH
3721: LD_INT 12
3723: PUSH
3724: LD_INT 15
3726: PUSH
3727: LD_INT 16
3729: PUSH
3730: LD_INT 22
3732: PUSH
3733: LD_INT 23
3735: PUSH
3736: LD_INT 26
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: LIST
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 101
3752: PUSH
3753: LD_INT 102
3755: PUSH
3756: LD_INT 105
3758: PUSH
3759: LD_INT 106
3761: PUSH
3762: LD_INT 108
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: ST_TO_ADDR
3776: GO 6555
3778: LD_INT 3
3780: DOUBLE
3781: EQUAL
3782: IFTRUE 3786
3784: GO 3862
3786: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
3787: LD_ADDR_VAR 0 1
3791: PUSH
3792: LD_INT 2
3794: PUSH
3795: LD_INT 4
3797: PUSH
3798: LD_INT 5
3800: PUSH
3801: LD_INT 11
3803: PUSH
3804: LD_INT 12
3806: PUSH
3807: LD_INT 15
3809: PUSH
3810: LD_INT 16
3812: PUSH
3813: LD_INT 22
3815: PUSH
3816: LD_INT 26
3818: PUSH
3819: LD_INT 36
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 101
3836: PUSH
3837: LD_INT 102
3839: PUSH
3840: LD_INT 105
3842: PUSH
3843: LD_INT 106
3845: PUSH
3846: LD_INT 108
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: ST_TO_ADDR
3860: GO 6555
3862: LD_INT 4
3864: DOUBLE
3865: EQUAL
3866: IFTRUE 3870
3868: GO 3954
3870: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
3871: LD_ADDR_VAR 0 1
3875: PUSH
3876: LD_INT 2
3878: PUSH
3879: LD_INT 4
3881: PUSH
3882: LD_INT 5
3884: PUSH
3885: LD_INT 8
3887: PUSH
3888: LD_INT 11
3890: PUSH
3891: LD_INT 12
3893: PUSH
3894: LD_INT 15
3896: PUSH
3897: LD_INT 16
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 23
3905: PUSH
3906: LD_INT 26
3908: PUSH
3909: LD_INT 36
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: LIST
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 101
3928: PUSH
3929: LD_INT 102
3931: PUSH
3932: LD_INT 105
3934: PUSH
3935: LD_INT 106
3937: PUSH
3938: LD_INT 108
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: LIST
3946: LIST
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: ST_TO_ADDR
3952: GO 6555
3954: LD_INT 5
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 4062
3962: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
3963: LD_ADDR_VAR 0 1
3967: PUSH
3968: LD_INT 2
3970: PUSH
3971: LD_INT 4
3973: PUSH
3974: LD_INT 5
3976: PUSH
3977: LD_INT 6
3979: PUSH
3980: LD_INT 8
3982: PUSH
3983: LD_INT 11
3985: PUSH
3986: LD_INT 12
3988: PUSH
3989: LD_INT 15
3991: PUSH
3992: LD_INT 16
3994: PUSH
3995: LD_INT 22
3997: PUSH
3998: LD_INT 23
4000: PUSH
4001: LD_INT 25
4003: PUSH
4004: LD_INT 26
4006: PUSH
4007: LD_INT 36
4009: PUSH
4010: EMPTY
4011: LIST
4012: LIST
4013: LIST
4014: LIST
4015: LIST
4016: LIST
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: PUSH
4026: LD_INT 101
4028: PUSH
4029: LD_INT 102
4031: PUSH
4032: LD_INT 105
4034: PUSH
4035: LD_INT 106
4037: PUSH
4038: LD_INT 108
4040: PUSH
4041: LD_INT 109
4043: PUSH
4044: LD_INT 112
4046: PUSH
4047: EMPTY
4048: LIST
4049: LIST
4050: LIST
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: EMPTY
4057: LIST
4058: LIST
4059: ST_TO_ADDR
4060: GO 6555
4062: LD_INT 6
4064: DOUBLE
4065: EQUAL
4066: IFTRUE 4070
4068: GO 4190
4070: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
4071: LD_ADDR_VAR 0 1
4075: PUSH
4076: LD_INT 2
4078: PUSH
4079: LD_INT 4
4081: PUSH
4082: LD_INT 5
4084: PUSH
4085: LD_INT 6
4087: PUSH
4088: LD_INT 8
4090: PUSH
4091: LD_INT 11
4093: PUSH
4094: LD_INT 12
4096: PUSH
4097: LD_INT 15
4099: PUSH
4100: LD_INT 16
4102: PUSH
4103: LD_INT 20
4105: PUSH
4106: LD_INT 21
4108: PUSH
4109: LD_INT 22
4111: PUSH
4112: LD_INT 23
4114: PUSH
4115: LD_INT 25
4117: PUSH
4118: LD_INT 26
4120: PUSH
4121: LD_INT 30
4123: PUSH
4124: LD_INT 31
4126: PUSH
4127: LD_INT 32
4129: PUSH
4130: LD_INT 36
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: LIST
4137: LIST
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: LIST
4144: LIST
4145: LIST
4146: LIST
4147: LIST
4148: LIST
4149: LIST
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_INT 101
4156: PUSH
4157: LD_INT 102
4159: PUSH
4160: LD_INT 105
4162: PUSH
4163: LD_INT 106
4165: PUSH
4166: LD_INT 108
4168: PUSH
4169: LD_INT 109
4171: PUSH
4172: LD_INT 112
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: ST_TO_ADDR
4188: GO 6555
4190: LD_INT 7
4192: DOUBLE
4193: EQUAL
4194: IFTRUE 4198
4196: GO 4298
4198: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
4199: LD_ADDR_VAR 0 1
4203: PUSH
4204: LD_INT 2
4206: PUSH
4207: LD_INT 4
4209: PUSH
4210: LD_INT 5
4212: PUSH
4213: LD_INT 7
4215: PUSH
4216: LD_INT 11
4218: PUSH
4219: LD_INT 12
4221: PUSH
4222: LD_INT 15
4224: PUSH
4225: LD_INT 16
4227: PUSH
4228: LD_INT 20
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 22
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: LD_INT 25
4242: PUSH
4243: LD_INT 26
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 101
4264: PUSH
4265: LD_INT 102
4267: PUSH
4268: LD_INT 103
4270: PUSH
4271: LD_INT 105
4273: PUSH
4274: LD_INT 106
4276: PUSH
4277: LD_INT 108
4279: PUSH
4280: LD_INT 112
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: ST_TO_ADDR
4296: GO 6555
4298: LD_INT 8
4300: DOUBLE
4301: EQUAL
4302: IFTRUE 4306
4304: GO 4434
4306: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
4307: LD_ADDR_VAR 0 1
4311: PUSH
4312: LD_INT 2
4314: PUSH
4315: LD_INT 4
4317: PUSH
4318: LD_INT 5
4320: PUSH
4321: LD_INT 6
4323: PUSH
4324: LD_INT 7
4326: PUSH
4327: LD_INT 8
4329: PUSH
4330: LD_INT 11
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: LD_INT 15
4338: PUSH
4339: LD_INT 16
4341: PUSH
4342: LD_INT 20
4344: PUSH
4345: LD_INT 21
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_INT 23
4353: PUSH
4354: LD_INT 25
4356: PUSH
4357: LD_INT 26
4359: PUSH
4360: LD_INT 30
4362: PUSH
4363: LD_INT 31
4365: PUSH
4366: LD_INT 32
4368: PUSH
4369: LD_INT 36
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: LIST
4376: LIST
4377: LIST
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 101
4396: PUSH
4397: LD_INT 102
4399: PUSH
4400: LD_INT 103
4402: PUSH
4403: LD_INT 105
4405: PUSH
4406: LD_INT 106
4408: PUSH
4409: LD_INT 108
4411: PUSH
4412: LD_INT 109
4414: PUSH
4415: LD_INT 112
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: LIST
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: ST_TO_ADDR
4432: GO 6555
4434: LD_INT 9
4436: DOUBLE
4437: EQUAL
4438: IFTRUE 4442
4440: GO 4578
4442: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
4443: LD_ADDR_VAR 0 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 4
4453: PUSH
4454: LD_INT 5
4456: PUSH
4457: LD_INT 6
4459: PUSH
4460: LD_INT 7
4462: PUSH
4463: LD_INT 8
4465: PUSH
4466: LD_INT 11
4468: PUSH
4469: LD_INT 12
4471: PUSH
4472: LD_INT 15
4474: PUSH
4475: LD_INT 16
4477: PUSH
4478: LD_INT 20
4480: PUSH
4481: LD_INT 21
4483: PUSH
4484: LD_INT 22
4486: PUSH
4487: LD_INT 23
4489: PUSH
4490: LD_INT 25
4492: PUSH
4493: LD_INT 26
4495: PUSH
4496: LD_INT 28
4498: PUSH
4499: LD_INT 30
4501: PUSH
4502: LD_INT 31
4504: PUSH
4505: LD_INT 32
4507: PUSH
4508: LD_INT 36
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: PUSH
4534: LD_INT 101
4536: PUSH
4537: LD_INT 102
4539: PUSH
4540: LD_INT 103
4542: PUSH
4543: LD_INT 105
4545: PUSH
4546: LD_INT 106
4548: PUSH
4549: LD_INT 108
4551: PUSH
4552: LD_INT 109
4554: PUSH
4555: LD_INT 112
4557: PUSH
4558: LD_INT 114
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: ST_TO_ADDR
4576: GO 6555
4578: LD_INT 10
4580: DOUBLE
4581: EQUAL
4582: IFTRUE 4586
4584: GO 4770
4586: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
4587: LD_ADDR_VAR 0 1
4591: PUSH
4592: LD_INT 2
4594: PUSH
4595: LD_INT 4
4597: PUSH
4598: LD_INT 5
4600: PUSH
4601: LD_INT 6
4603: PUSH
4604: LD_INT 7
4606: PUSH
4607: LD_INT 8
4609: PUSH
4610: LD_INT 9
4612: PUSH
4613: LD_INT 10
4615: PUSH
4616: LD_INT 11
4618: PUSH
4619: LD_INT 12
4621: PUSH
4622: LD_INT 13
4624: PUSH
4625: LD_INT 14
4627: PUSH
4628: LD_INT 15
4630: PUSH
4631: LD_INT 16
4633: PUSH
4634: LD_INT 17
4636: PUSH
4637: LD_INT 18
4639: PUSH
4640: LD_INT 19
4642: PUSH
4643: LD_INT 20
4645: PUSH
4646: LD_INT 21
4648: PUSH
4649: LD_INT 22
4651: PUSH
4652: LD_INT 23
4654: PUSH
4655: LD_INT 24
4657: PUSH
4658: LD_INT 25
4660: PUSH
4661: LD_INT 26
4663: PUSH
4664: LD_INT 28
4666: PUSH
4667: LD_INT 30
4669: PUSH
4670: LD_INT 31
4672: PUSH
4673: LD_INT 32
4675: PUSH
4676: LD_INT 36
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: PUSH
4710: LD_INT 101
4712: PUSH
4713: LD_INT 102
4715: PUSH
4716: LD_INT 103
4718: PUSH
4719: LD_INT 104
4721: PUSH
4722: LD_INT 105
4724: PUSH
4725: LD_INT 106
4727: PUSH
4728: LD_INT 107
4730: PUSH
4731: LD_INT 108
4733: PUSH
4734: LD_INT 109
4736: PUSH
4737: LD_INT 110
4739: PUSH
4740: LD_INT 111
4742: PUSH
4743: LD_INT 112
4745: PUSH
4746: LD_INT 114
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: PUSH
4764: EMPTY
4765: LIST
4766: LIST
4767: ST_TO_ADDR
4768: GO 6555
4770: LD_INT 11
4772: DOUBLE
4773: EQUAL
4774: IFTRUE 4778
4776: GO 4970
4778: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
4779: LD_ADDR_VAR 0 1
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: LD_INT 3
4789: PUSH
4790: LD_INT 4
4792: PUSH
4793: LD_INT 5
4795: PUSH
4796: LD_INT 6
4798: PUSH
4799: LD_INT 7
4801: PUSH
4802: LD_INT 8
4804: PUSH
4805: LD_INT 9
4807: PUSH
4808: LD_INT 10
4810: PUSH
4811: LD_INT 11
4813: PUSH
4814: LD_INT 12
4816: PUSH
4817: LD_INT 13
4819: PUSH
4820: LD_INT 14
4822: PUSH
4823: LD_INT 15
4825: PUSH
4826: LD_INT 16
4828: PUSH
4829: LD_INT 17
4831: PUSH
4832: LD_INT 18
4834: PUSH
4835: LD_INT 19
4837: PUSH
4838: LD_INT 20
4840: PUSH
4841: LD_INT 21
4843: PUSH
4844: LD_INT 22
4846: PUSH
4847: LD_INT 23
4849: PUSH
4850: LD_INT 24
4852: PUSH
4853: LD_INT 25
4855: PUSH
4856: LD_INT 26
4858: PUSH
4859: LD_INT 28
4861: PUSH
4862: LD_INT 30
4864: PUSH
4865: LD_INT 31
4867: PUSH
4868: LD_INT 32
4870: PUSH
4871: LD_INT 34
4873: PUSH
4874: LD_INT 36
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: LIST
4904: LIST
4905: LIST
4906: LIST
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 101
4912: PUSH
4913: LD_INT 102
4915: PUSH
4916: LD_INT 103
4918: PUSH
4919: LD_INT 104
4921: PUSH
4922: LD_INT 105
4924: PUSH
4925: LD_INT 106
4927: PUSH
4928: LD_INT 107
4930: PUSH
4931: LD_INT 108
4933: PUSH
4934: LD_INT 109
4936: PUSH
4937: LD_INT 110
4939: PUSH
4940: LD_INT 111
4942: PUSH
4943: LD_INT 112
4945: PUSH
4946: LD_INT 114
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: LIST
4953: LIST
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: ST_TO_ADDR
4968: GO 6555
4970: LD_INT 12
4972: DOUBLE
4973: EQUAL
4974: IFTRUE 4978
4976: GO 5186
4978: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
4979: LD_ADDR_VAR 0 1
4983: PUSH
4984: LD_INT 1
4986: PUSH
4987: LD_INT 2
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: LD_INT 4
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: LD_INT 6
5001: PUSH
5002: LD_INT 7
5004: PUSH
5005: LD_INT 8
5007: PUSH
5008: LD_INT 9
5010: PUSH
5011: LD_INT 10
5013: PUSH
5014: LD_INT 11
5016: PUSH
5017: LD_INT 12
5019: PUSH
5020: LD_INT 13
5022: PUSH
5023: LD_INT 14
5025: PUSH
5026: LD_INT 15
5028: PUSH
5029: LD_INT 16
5031: PUSH
5032: LD_INT 17
5034: PUSH
5035: LD_INT 18
5037: PUSH
5038: LD_INT 19
5040: PUSH
5041: LD_INT 20
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: LD_INT 22
5049: PUSH
5050: LD_INT 23
5052: PUSH
5053: LD_INT 24
5055: PUSH
5056: LD_INT 25
5058: PUSH
5059: LD_INT 26
5061: PUSH
5062: LD_INT 27
5064: PUSH
5065: LD_INT 28
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 31
5073: PUSH
5074: LD_INT 32
5076: PUSH
5077: LD_INT 33
5079: PUSH
5080: LD_INT 34
5082: PUSH
5083: LD_INT 36
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: LIST
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: LD_INT 101
5124: PUSH
5125: LD_INT 102
5127: PUSH
5128: LD_INT 103
5130: PUSH
5131: LD_INT 104
5133: PUSH
5134: LD_INT 105
5136: PUSH
5137: LD_INT 106
5139: PUSH
5140: LD_INT 107
5142: PUSH
5143: LD_INT 108
5145: PUSH
5146: LD_INT 109
5148: PUSH
5149: LD_INT 110
5151: PUSH
5152: LD_INT 111
5154: PUSH
5155: LD_INT 112
5157: PUSH
5158: LD_INT 113
5160: PUSH
5161: LD_INT 114
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: ST_TO_ADDR
5184: GO 6555
5186: LD_INT 13
5188: DOUBLE
5189: EQUAL
5190: IFTRUE 5194
5192: GO 5390
5194: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
5195: LD_ADDR_VAR 0 1
5199: PUSH
5200: LD_INT 1
5202: PUSH
5203: LD_INT 2
5205: PUSH
5206: LD_INT 3
5208: PUSH
5209: LD_INT 4
5211: PUSH
5212: LD_INT 5
5214: PUSH
5215: LD_INT 8
5217: PUSH
5218: LD_INT 9
5220: PUSH
5221: LD_INT 10
5223: PUSH
5224: LD_INT 11
5226: PUSH
5227: LD_INT 12
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 15
5235: PUSH
5236: LD_INT 16
5238: PUSH
5239: LD_INT 17
5241: PUSH
5242: LD_INT 18
5244: PUSH
5245: LD_INT 19
5247: PUSH
5248: LD_INT 20
5250: PUSH
5251: LD_INT 21
5253: PUSH
5254: LD_INT 22
5256: PUSH
5257: LD_INT 23
5259: PUSH
5260: LD_INT 24
5262: PUSH
5263: LD_INT 25
5265: PUSH
5266: LD_INT 26
5268: PUSH
5269: LD_INT 27
5271: PUSH
5272: LD_INT 28
5274: PUSH
5275: LD_INT 30
5277: PUSH
5278: LD_INT 31
5280: PUSH
5281: LD_INT 32
5283: PUSH
5284: LD_INT 33
5286: PUSH
5287: LD_INT 34
5289: PUSH
5290: LD_INT 36
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: LIST
5307: LIST
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: LIST
5325: PUSH
5326: LD_INT 101
5328: PUSH
5329: LD_INT 102
5331: PUSH
5332: LD_INT 103
5334: PUSH
5335: LD_INT 104
5337: PUSH
5338: LD_INT 105
5340: PUSH
5341: LD_INT 106
5343: PUSH
5344: LD_INT 107
5346: PUSH
5347: LD_INT 108
5349: PUSH
5350: LD_INT 109
5352: PUSH
5353: LD_INT 110
5355: PUSH
5356: LD_INT 111
5358: PUSH
5359: LD_INT 112
5361: PUSH
5362: LD_INT 113
5364: PUSH
5365: LD_INT 114
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: LIST
5379: LIST
5380: LIST
5381: LIST
5382: LIST
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: ST_TO_ADDR
5388: GO 6555
5390: LD_INT 14
5392: DOUBLE
5393: EQUAL
5394: IFTRUE 5398
5396: GO 5610
5398: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
5399: LD_ADDR_VAR 0 1
5403: PUSH
5404: LD_INT 1
5406: PUSH
5407: LD_INT 2
5409: PUSH
5410: LD_INT 3
5412: PUSH
5413: LD_INT 4
5415: PUSH
5416: LD_INT 5
5418: PUSH
5419: LD_INT 6
5421: PUSH
5422: LD_INT 7
5424: PUSH
5425: LD_INT 8
5427: PUSH
5428: LD_INT 9
5430: PUSH
5431: LD_INT 10
5433: PUSH
5434: LD_INT 11
5436: PUSH
5437: LD_INT 12
5439: PUSH
5440: LD_INT 13
5442: PUSH
5443: LD_INT 14
5445: PUSH
5446: LD_INT 15
5448: PUSH
5449: LD_INT 16
5451: PUSH
5452: LD_INT 17
5454: PUSH
5455: LD_INT 18
5457: PUSH
5458: LD_INT 19
5460: PUSH
5461: LD_INT 20
5463: PUSH
5464: LD_INT 21
5466: PUSH
5467: LD_INT 22
5469: PUSH
5470: LD_INT 23
5472: PUSH
5473: LD_INT 24
5475: PUSH
5476: LD_INT 25
5478: PUSH
5479: LD_INT 26
5481: PUSH
5482: LD_INT 27
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: LD_INT 29
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 31
5496: PUSH
5497: LD_INT 32
5499: PUSH
5500: LD_INT 33
5502: PUSH
5503: LD_INT 34
5505: PUSH
5506: LD_INT 36
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: LIST
5537: LIST
5538: LIST
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 101
5548: PUSH
5549: LD_INT 102
5551: PUSH
5552: LD_INT 103
5554: PUSH
5555: LD_INT 104
5557: PUSH
5558: LD_INT 105
5560: PUSH
5561: LD_INT 106
5563: PUSH
5564: LD_INT 107
5566: PUSH
5567: LD_INT 108
5569: PUSH
5570: LD_INT 109
5572: PUSH
5573: LD_INT 110
5575: PUSH
5576: LD_INT 111
5578: PUSH
5579: LD_INT 112
5581: PUSH
5582: LD_INT 113
5584: PUSH
5585: LD_INT 114
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: LIST
5595: LIST
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: ST_TO_ADDR
5608: GO 6555
5610: LD_INT 15
5612: DOUBLE
5613: EQUAL
5614: IFTRUE 5618
5616: GO 5830
5618: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
5619: LD_ADDR_VAR 0 1
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 3
5632: PUSH
5633: LD_INT 4
5635: PUSH
5636: LD_INT 5
5638: PUSH
5639: LD_INT 6
5641: PUSH
5642: LD_INT 7
5644: PUSH
5645: LD_INT 8
5647: PUSH
5648: LD_INT 9
5650: PUSH
5651: LD_INT 10
5653: PUSH
5654: LD_INT 11
5656: PUSH
5657: LD_INT 12
5659: PUSH
5660: LD_INT 13
5662: PUSH
5663: LD_INT 14
5665: PUSH
5666: LD_INT 15
5668: PUSH
5669: LD_INT 16
5671: PUSH
5672: LD_INT 17
5674: PUSH
5675: LD_INT 18
5677: PUSH
5678: LD_INT 19
5680: PUSH
5681: LD_INT 20
5683: PUSH
5684: LD_INT 21
5686: PUSH
5687: LD_INT 22
5689: PUSH
5690: LD_INT 23
5692: PUSH
5693: LD_INT 24
5695: PUSH
5696: LD_INT 25
5698: PUSH
5699: LD_INT 26
5701: PUSH
5702: LD_INT 27
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: LD_INT 29
5710: PUSH
5711: LD_INT 30
5713: PUSH
5714: LD_INT 31
5716: PUSH
5717: LD_INT 32
5719: PUSH
5720: LD_INT 33
5722: PUSH
5723: LD_INT 34
5725: PUSH
5726: LD_INT 36
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: LIST
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: LIST
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 101
5768: PUSH
5769: LD_INT 102
5771: PUSH
5772: LD_INT 103
5774: PUSH
5775: LD_INT 104
5777: PUSH
5778: LD_INT 105
5780: PUSH
5781: LD_INT 106
5783: PUSH
5784: LD_INT 107
5786: PUSH
5787: LD_INT 108
5789: PUSH
5790: LD_INT 109
5792: PUSH
5793: LD_INT 110
5795: PUSH
5796: LD_INT 111
5798: PUSH
5799: LD_INT 112
5801: PUSH
5802: LD_INT 113
5804: PUSH
5805: LD_INT 114
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: ST_TO_ADDR
5828: GO 6555
5830: LD_INT 16
5832: DOUBLE
5833: EQUAL
5834: IFTRUE 5838
5836: GO 5962
5838: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
5839: LD_ADDR_VAR 0 1
5843: PUSH
5844: LD_INT 2
5846: PUSH
5847: LD_INT 4
5849: PUSH
5850: LD_INT 5
5852: PUSH
5853: LD_INT 7
5855: PUSH
5856: LD_INT 11
5858: PUSH
5859: LD_INT 12
5861: PUSH
5862: LD_INT 15
5864: PUSH
5865: LD_INT 16
5867: PUSH
5868: LD_INT 20
5870: PUSH
5871: LD_INT 21
5873: PUSH
5874: LD_INT 22
5876: PUSH
5877: LD_INT 23
5879: PUSH
5880: LD_INT 25
5882: PUSH
5883: LD_INT 26
5885: PUSH
5886: LD_INT 30
5888: PUSH
5889: LD_INT 31
5891: PUSH
5892: LD_INT 32
5894: PUSH
5895: LD_INT 33
5897: PUSH
5898: LD_INT 34
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: PUSH
5922: LD_INT 101
5924: PUSH
5925: LD_INT 102
5927: PUSH
5928: LD_INT 103
5930: PUSH
5931: LD_INT 106
5933: PUSH
5934: LD_INT 108
5936: PUSH
5937: LD_INT 112
5939: PUSH
5940: LD_INT 113
5942: PUSH
5943: LD_INT 114
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: ST_TO_ADDR
5960: GO 6555
5962: LD_INT 17
5964: DOUBLE
5965: EQUAL
5966: IFTRUE 5970
5968: GO 6182
5970: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
5971: LD_ADDR_VAR 0 1
5975: PUSH
5976: LD_INT 1
5978: PUSH
5979: LD_INT 2
5981: PUSH
5982: LD_INT 3
5984: PUSH
5985: LD_INT 4
5987: PUSH
5988: LD_INT 5
5990: PUSH
5991: LD_INT 6
5993: PUSH
5994: LD_INT 7
5996: PUSH
5997: LD_INT 8
5999: PUSH
6000: LD_INT 9
6002: PUSH
6003: LD_INT 10
6005: PUSH
6006: LD_INT 11
6008: PUSH
6009: LD_INT 12
6011: PUSH
6012: LD_INT 13
6014: PUSH
6015: LD_INT 14
6017: PUSH
6018: LD_INT 15
6020: PUSH
6021: LD_INT 16
6023: PUSH
6024: LD_INT 17
6026: PUSH
6027: LD_INT 18
6029: PUSH
6030: LD_INT 19
6032: PUSH
6033: LD_INT 20
6035: PUSH
6036: LD_INT 21
6038: PUSH
6039: LD_INT 22
6041: PUSH
6042: LD_INT 23
6044: PUSH
6045: LD_INT 24
6047: PUSH
6048: LD_INT 25
6050: PUSH
6051: LD_INT 26
6053: PUSH
6054: LD_INT 27
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: LD_INT 29
6062: PUSH
6063: LD_INT 30
6065: PUSH
6066: LD_INT 31
6068: PUSH
6069: LD_INT 32
6071: PUSH
6072: LD_INT 33
6074: PUSH
6075: LD_INT 34
6077: PUSH
6078: LD_INT 36
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: LIST
6085: LIST
6086: LIST
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 101
6120: PUSH
6121: LD_INT 102
6123: PUSH
6124: LD_INT 103
6126: PUSH
6127: LD_INT 104
6129: PUSH
6130: LD_INT 105
6132: PUSH
6133: LD_INT 106
6135: PUSH
6136: LD_INT 107
6138: PUSH
6139: LD_INT 108
6141: PUSH
6142: LD_INT 109
6144: PUSH
6145: LD_INT 110
6147: PUSH
6148: LD_INT 111
6150: PUSH
6151: LD_INT 112
6153: PUSH
6154: LD_INT 113
6156: PUSH
6157: LD_INT 114
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: LIST
6174: LIST
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: ST_TO_ADDR
6180: GO 6555
6182: LD_INT 18
6184: DOUBLE
6185: EQUAL
6186: IFTRUE 6190
6188: GO 6326
6190: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
6191: LD_ADDR_VAR 0 1
6195: PUSH
6196: LD_INT 2
6198: PUSH
6199: LD_INT 4
6201: PUSH
6202: LD_INT 5
6204: PUSH
6205: LD_INT 7
6207: PUSH
6208: LD_INT 11
6210: PUSH
6211: LD_INT 12
6213: PUSH
6214: LD_INT 15
6216: PUSH
6217: LD_INT 16
6219: PUSH
6220: LD_INT 20
6222: PUSH
6223: LD_INT 21
6225: PUSH
6226: LD_INT 22
6228: PUSH
6229: LD_INT 23
6231: PUSH
6232: LD_INT 25
6234: PUSH
6235: LD_INT 26
6237: PUSH
6238: LD_INT 30
6240: PUSH
6241: LD_INT 31
6243: PUSH
6244: LD_INT 32
6246: PUSH
6247: LD_INT 33
6249: PUSH
6250: LD_INT 34
6252: PUSH
6253: LD_INT 35
6255: PUSH
6256: LD_INT 36
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 101
6284: PUSH
6285: LD_INT 102
6287: PUSH
6288: LD_INT 103
6290: PUSH
6291: LD_INT 106
6293: PUSH
6294: LD_INT 108
6296: PUSH
6297: LD_INT 112
6299: PUSH
6300: LD_INT 113
6302: PUSH
6303: LD_INT 114
6305: PUSH
6306: LD_INT 115
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: LIST
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: ST_TO_ADDR
6324: GO 6555
6326: LD_INT 19
6328: DOUBLE
6329: EQUAL
6330: IFTRUE 6334
6332: GO 6554
6334: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 3
6348: PUSH
6349: LD_INT 4
6351: PUSH
6352: LD_INT 5
6354: PUSH
6355: LD_INT 6
6357: PUSH
6358: LD_INT 7
6360: PUSH
6361: LD_INT 8
6363: PUSH
6364: LD_INT 9
6366: PUSH
6367: LD_INT 10
6369: PUSH
6370: LD_INT 11
6372: PUSH
6373: LD_INT 12
6375: PUSH
6376: LD_INT 13
6378: PUSH
6379: LD_INT 14
6381: PUSH
6382: LD_INT 15
6384: PUSH
6385: LD_INT 16
6387: PUSH
6388: LD_INT 17
6390: PUSH
6391: LD_INT 18
6393: PUSH
6394: LD_INT 19
6396: PUSH
6397: LD_INT 20
6399: PUSH
6400: LD_INT 21
6402: PUSH
6403: LD_INT 22
6405: PUSH
6406: LD_INT 23
6408: PUSH
6409: LD_INT 24
6411: PUSH
6412: LD_INT 25
6414: PUSH
6415: LD_INT 26
6417: PUSH
6418: LD_INT 27
6420: PUSH
6421: LD_INT 28
6423: PUSH
6424: LD_INT 29
6426: PUSH
6427: LD_INT 30
6429: PUSH
6430: LD_INT 31
6432: PUSH
6433: LD_INT 32
6435: PUSH
6436: LD_INT 33
6438: PUSH
6439: LD_INT 34
6441: PUSH
6442: LD_INT 35
6444: PUSH
6445: LD_INT 36
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PUSH
6486: LD_INT 101
6488: PUSH
6489: LD_INT 102
6491: PUSH
6492: LD_INT 103
6494: PUSH
6495: LD_INT 104
6497: PUSH
6498: LD_INT 105
6500: PUSH
6501: LD_INT 106
6503: PUSH
6504: LD_INT 107
6506: PUSH
6507: LD_INT 108
6509: PUSH
6510: LD_INT 109
6512: PUSH
6513: LD_INT 110
6515: PUSH
6516: LD_INT 111
6518: PUSH
6519: LD_INT 112
6521: PUSH
6522: LD_INT 113
6524: PUSH
6525: LD_INT 114
6527: PUSH
6528: LD_INT 115
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: LIST
6535: LIST
6536: LIST
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: ST_TO_ADDR
6552: GO 6555
6554: POP
// end else
6555: GO 6774
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
6557: LD_ADDR_VAR 0 1
6561: PUSH
6562: LD_INT 1
6564: PUSH
6565: LD_INT 2
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 4
6573: PUSH
6574: LD_INT 5
6576: PUSH
6577: LD_INT 6
6579: PUSH
6580: LD_INT 7
6582: PUSH
6583: LD_INT 8
6585: PUSH
6586: LD_INT 9
6588: PUSH
6589: LD_INT 10
6591: PUSH
6592: LD_INT 11
6594: PUSH
6595: LD_INT 12
6597: PUSH
6598: LD_INT 13
6600: PUSH
6601: LD_INT 14
6603: PUSH
6604: LD_INT 15
6606: PUSH
6607: LD_INT 16
6609: PUSH
6610: LD_INT 17
6612: PUSH
6613: LD_INT 18
6615: PUSH
6616: LD_INT 19
6618: PUSH
6619: LD_INT 20
6621: PUSH
6622: LD_INT 21
6624: PUSH
6625: LD_INT 22
6627: PUSH
6628: LD_INT 23
6630: PUSH
6631: LD_INT 24
6633: PUSH
6634: LD_INT 25
6636: PUSH
6637: LD_INT 26
6639: PUSH
6640: LD_INT 27
6642: PUSH
6643: LD_INT 28
6645: PUSH
6646: LD_INT 29
6648: PUSH
6649: LD_INT 30
6651: PUSH
6652: LD_INT 31
6654: PUSH
6655: LD_INT 32
6657: PUSH
6658: LD_INT 33
6660: PUSH
6661: LD_INT 34
6663: PUSH
6664: LD_INT 35
6666: PUSH
6667: LD_INT 36
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 101
6710: PUSH
6711: LD_INT 102
6713: PUSH
6714: LD_INT 103
6716: PUSH
6717: LD_INT 104
6719: PUSH
6720: LD_INT 105
6722: PUSH
6723: LD_INT 106
6725: PUSH
6726: LD_INT 107
6728: PUSH
6729: LD_INT 108
6731: PUSH
6732: LD_INT 109
6734: PUSH
6735: LD_INT 110
6737: PUSH
6738: LD_INT 111
6740: PUSH
6741: LD_INT 112
6743: PUSH
6744: LD_INT 113
6746: PUSH
6747: LD_INT 114
6749: PUSH
6750: LD_INT 115
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: LIST
6768: LIST
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: ST_TO_ADDR
// if result then
6774: LD_VAR 0 1
6778: IFFALSE 7067
// begin normal :=  ;
6780: LD_ADDR_VAR 0 3
6784: PUSH
6785: LD_STRING 
6787: ST_TO_ADDR
// hardcore :=  ;
6788: LD_ADDR_VAR 0 4
6792: PUSH
6793: LD_STRING 
6795: ST_TO_ADDR
// for i = 1 to normalCounter do
6796: LD_ADDR_VAR 0 5
6800: PUSH
6801: DOUBLE
6802: LD_INT 1
6804: DEC
6805: ST_TO_ADDR
6806: LD_EXP 9
6810: PUSH
6811: FOR_TO
6812: IFFALSE 6913
// begin tmp := 0 ;
6814: LD_ADDR_VAR 0 2
6818: PUSH
6819: LD_STRING 0
6821: ST_TO_ADDR
// if result [ 1 ] then
6822: LD_VAR 0 1
6826: PUSH
6827: LD_INT 1
6829: ARRAY
6830: IFFALSE 6895
// if result [ 1 ] [ 1 ] = i then
6832: LD_VAR 0 1
6836: PUSH
6837: LD_INT 1
6839: ARRAY
6840: PUSH
6841: LD_INT 1
6843: ARRAY
6844: PUSH
6845: LD_VAR 0 5
6849: EQUAL
6850: IFFALSE 6895
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
6852: LD_ADDR_VAR 0 1
6856: PUSH
6857: LD_VAR 0 1
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: LD_VAR 0 1
6869: PUSH
6870: LD_INT 1
6872: ARRAY
6873: PPUSH
6874: LD_INT 1
6876: PPUSH
6877: CALL_OW 3
6881: PPUSH
6882: CALL_OW 1
6886: ST_TO_ADDR
// tmp := 1 ;
6887: LD_ADDR_VAR 0 2
6891: PUSH
6892: LD_STRING 1
6894: ST_TO_ADDR
// end ; normal := normal & tmp ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 3
6904: PUSH
6905: LD_VAR 0 2
6909: STR
6910: ST_TO_ADDR
// end ;
6911: GO 6811
6913: POP
6914: POP
// for i = 1 to hardcoreCounter do
6915: LD_ADDR_VAR 0 5
6919: PUSH
6920: DOUBLE
6921: LD_INT 1
6923: DEC
6924: ST_TO_ADDR
6925: LD_EXP 10
6929: PUSH
6930: FOR_TO
6931: IFFALSE 7036
// begin tmp := 0 ;
6933: LD_ADDR_VAR 0 2
6937: PUSH
6938: LD_STRING 0
6940: ST_TO_ADDR
// if result [ 2 ] then
6941: LD_VAR 0 1
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: IFFALSE 7018
// if result [ 2 ] [ 1 ] = 100 + i then
6951: LD_VAR 0 1
6955: PUSH
6956: LD_INT 2
6958: ARRAY
6959: PUSH
6960: LD_INT 1
6962: ARRAY
6963: PUSH
6964: LD_INT 100
6966: PUSH
6967: LD_VAR 0 5
6971: PLUS
6972: EQUAL
6973: IFFALSE 7018
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
6975: LD_ADDR_VAR 0 1
6979: PUSH
6980: LD_VAR 0 1
6984: PPUSH
6985: LD_INT 2
6987: PPUSH
6988: LD_VAR 0 1
6992: PUSH
6993: LD_INT 2
6995: ARRAY
6996: PPUSH
6997: LD_INT 1
6999: PPUSH
7000: CALL_OW 3
7004: PPUSH
7005: CALL_OW 1
7009: ST_TO_ADDR
// tmp := 1 ;
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: LD_STRING 1
7017: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
7018: LD_ADDR_VAR 0 4
7022: PUSH
7023: LD_VAR 0 4
7027: PUSH
7028: LD_VAR 0 2
7032: STR
7033: ST_TO_ADDR
// end ;
7034: GO 6930
7036: POP
7037: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
7038: LD_STRING getStreamItemsFromMission("
7040: PUSH
7041: LD_VAR 0 3
7045: STR
7046: PUSH
7047: LD_STRING ","
7049: STR
7050: PUSH
7051: LD_VAR 0 4
7055: STR
7056: PUSH
7057: LD_STRING ")
7059: STR
7060: PPUSH
7061: CALL_OW 559
// end else
7065: GO 7074
// ToLua ( getStreamItemsFromMission("","") ) ;
7067: LD_STRING getStreamItemsFromMission("","")
7069: PPUSH
7070: CALL_OW 559
// end ;
7074: LD_VAR 0 1
7078: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7079: LD_EXP 8
7083: PUSH
7084: LD_EXP 13
7088: AND
7089: IFFALSE 7213
7091: GO 7093
7093: DISABLE
7094: LD_INT 0
7096: PPUSH
7097: PPUSH
// begin enable ;
7098: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7099: LD_ADDR_VAR 0 2
7103: PUSH
7104: LD_INT 22
7106: PUSH
7107: LD_OWVAR 2
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 2
7118: PUSH
7119: LD_INT 34
7121: PUSH
7122: LD_INT 7
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 34
7131: PUSH
7132: LD_INT 45
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PUSH
7139: LD_INT 34
7141: PUSH
7142: LD_INT 28
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: PUSH
7149: LD_INT 34
7151: PUSH
7152: LD_INT 47
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PPUSH
7170: CALL_OW 69
7174: ST_TO_ADDR
// if not tmp then
7175: LD_VAR 0 2
7179: NOT
7180: IFFALSE 7184
// exit ;
7182: GO 7213
// for i in tmp do
7184: LD_ADDR_VAR 0 1
7188: PUSH
7189: LD_VAR 0 2
7193: PUSH
7194: FOR_IN
7195: IFFALSE 7211
// begin SetLives ( i , 0 ) ;
7197: LD_VAR 0 1
7201: PPUSH
7202: LD_INT 0
7204: PPUSH
7205: CALL_OW 234
// end ;
7209: GO 7194
7211: POP
7212: POP
// end ;
7213: PPOPN 2
7215: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7216: LD_EXP 8
7220: PUSH
7221: LD_EXP 14
7225: AND
7226: IFFALSE 7310
7228: GO 7230
7230: DISABLE
7231: LD_INT 0
7233: PPUSH
7234: PPUSH
// begin enable ;
7235: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7236: LD_ADDR_VAR 0 2
7240: PUSH
7241: LD_INT 22
7243: PUSH
7244: LD_OWVAR 2
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: LD_INT 32
7255: PUSH
7256: LD_INT 3
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: PPUSH
7267: CALL_OW 69
7271: ST_TO_ADDR
// if not tmp then
7272: LD_VAR 0 2
7276: NOT
7277: IFFALSE 7281
// exit ;
7279: GO 7310
// for i in tmp do
7281: LD_ADDR_VAR 0 1
7285: PUSH
7286: LD_VAR 0 2
7290: PUSH
7291: FOR_IN
7292: IFFALSE 7308
// begin SetLives ( i , 0 ) ;
7294: LD_VAR 0 1
7298: PPUSH
7299: LD_INT 0
7301: PPUSH
7302: CALL_OW 234
// end ;
7306: GO 7291
7308: POP
7309: POP
// end ;
7310: PPOPN 2
7312: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7313: LD_EXP 8
7317: PUSH
7318: LD_EXP 11
7322: AND
7323: IFFALSE 7416
7325: GO 7327
7327: DISABLE
7328: LD_INT 0
7330: PPUSH
// begin enable ;
7331: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: LD_INT 22
7339: PUSH
7340: LD_OWVAR 2
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: PUSH
7349: LD_INT 2
7351: PUSH
7352: LD_INT 25
7354: PUSH
7355: LD_INT 5
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: PUSH
7362: LD_INT 25
7364: PUSH
7365: LD_INT 9
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: LD_INT 25
7374: PUSH
7375: LD_INT 8
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PPUSH
7392: CALL_OW 69
7396: PUSH
7397: FOR_IN
7398: IFFALSE 7414
// begin SetClass ( i , 1 ) ;
7400: LD_VAR 0 1
7404: PPUSH
7405: LD_INT 1
7407: PPUSH
7408: CALL_OW 336
// end ;
7412: GO 7397
7414: POP
7415: POP
// end ;
7416: PPOPN 1
7418: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7419: LD_EXP 8
7423: PUSH
7424: LD_EXP 12
7428: AND
7429: PUSH
7430: LD_OWVAR 65
7434: PUSH
7435: LD_INT 7
7437: LESS
7438: AND
7439: IFFALSE 7453
7441: GO 7443
7443: DISABLE
// begin enable ;
7444: ENABLE
// game_speed := 7 ;
7445: LD_ADDR_OWVAR 65
7449: PUSH
7450: LD_INT 7
7452: ST_TO_ADDR
// end ;
7453: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7454: LD_EXP 8
7458: PUSH
7459: LD_EXP 15
7463: AND
7464: IFFALSE 7666
7466: GO 7468
7468: DISABLE
7469: LD_INT 0
7471: PPUSH
7472: PPUSH
7473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7474: LD_ADDR_VAR 0 3
7478: PUSH
7479: LD_INT 81
7481: PUSH
7482: LD_OWVAR 2
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 21
7493: PUSH
7494: LD_INT 1
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: ST_TO_ADDR
// if not tmp then
7510: LD_VAR 0 3
7514: NOT
7515: IFFALSE 7519
// exit ;
7517: GO 7666
// if tmp > 5 then
7519: LD_VAR 0 3
7523: PUSH
7524: LD_INT 5
7526: GREATER
7527: IFFALSE 7539
// k := 5 else
7529: LD_ADDR_VAR 0 2
7533: PUSH
7534: LD_INT 5
7536: ST_TO_ADDR
7537: GO 7549
// k := tmp ;
7539: LD_ADDR_VAR 0 2
7543: PUSH
7544: LD_VAR 0 3
7548: ST_TO_ADDR
// for i := 1 to k do
7549: LD_ADDR_VAR 0 1
7553: PUSH
7554: DOUBLE
7555: LD_INT 1
7557: DEC
7558: ST_TO_ADDR
7559: LD_VAR 0 2
7563: PUSH
7564: FOR_TO
7565: IFFALSE 7664
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7567: LD_VAR 0 3
7571: PUSH
7572: LD_VAR 0 1
7576: ARRAY
7577: PPUSH
7578: LD_VAR 0 1
7582: PUSH
7583: LD_INT 4
7585: MOD
7586: PUSH
7587: LD_INT 1
7589: PLUS
7590: PPUSH
7591: CALL_OW 259
7595: PUSH
7596: LD_INT 10
7598: LESS
7599: IFFALSE 7662
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7601: LD_VAR 0 3
7605: PUSH
7606: LD_VAR 0 1
7610: ARRAY
7611: PPUSH
7612: LD_VAR 0 1
7616: PUSH
7617: LD_INT 4
7619: MOD
7620: PUSH
7621: LD_INT 1
7623: PLUS
7624: PPUSH
7625: LD_VAR 0 3
7629: PUSH
7630: LD_VAR 0 1
7634: ARRAY
7635: PPUSH
7636: LD_VAR 0 1
7640: PUSH
7641: LD_INT 4
7643: MOD
7644: PUSH
7645: LD_INT 1
7647: PLUS
7648: PPUSH
7649: CALL_OW 259
7653: PUSH
7654: LD_INT 1
7656: PLUS
7657: PPUSH
7658: CALL_OW 237
7662: GO 7564
7664: POP
7665: POP
// end ;
7666: PPOPN 3
7668: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7669: LD_EXP 8
7673: PUSH
7674: LD_EXP 16
7678: AND
7679: IFFALSE 7699
7681: GO 7683
7683: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7684: LD_INT 4
7686: PPUSH
7687: LD_OWVAR 2
7691: PPUSH
7692: LD_INT 0
7694: PPUSH
7695: CALL_OW 324
7699: END
// every 0 0$1 trigger StreamModeActive and sShovel do
7700: LD_EXP 8
7704: PUSH
7705: LD_EXP 45
7709: AND
7710: IFFALSE 7730
7712: GO 7714
7714: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
7715: LD_INT 19
7717: PPUSH
7718: LD_OWVAR 2
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 324
7730: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7731: LD_EXP 8
7735: PUSH
7736: LD_EXP 17
7740: AND
7741: IFFALSE 7843
7743: GO 7745
7745: DISABLE
7746: LD_INT 0
7748: PPUSH
7749: PPUSH
// begin enable ;
7750: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7751: LD_ADDR_VAR 0 2
7755: PUSH
7756: LD_INT 22
7758: PUSH
7759: LD_OWVAR 2
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: PUSH
7768: LD_INT 2
7770: PUSH
7771: LD_INT 34
7773: PUSH
7774: LD_INT 11
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 34
7783: PUSH
7784: LD_INT 30
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PPUSH
7800: CALL_OW 69
7804: ST_TO_ADDR
// if not tmp then
7805: LD_VAR 0 2
7809: NOT
7810: IFFALSE 7814
// exit ;
7812: GO 7843
// for i in tmp do
7814: LD_ADDR_VAR 0 1
7818: PUSH
7819: LD_VAR 0 2
7823: PUSH
7824: FOR_IN
7825: IFFALSE 7841
// begin SetLives ( i , 0 ) ;
7827: LD_VAR 0 1
7831: PPUSH
7832: LD_INT 0
7834: PPUSH
7835: CALL_OW 234
// end ;
7839: GO 7824
7841: POP
7842: POP
// end ;
7843: PPOPN 2
7845: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7846: LD_EXP 8
7850: PUSH
7851: LD_EXP 18
7855: AND
7856: IFFALSE 7876
7858: GO 7860
7860: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7861: LD_INT 32
7863: PPUSH
7864: LD_OWVAR 2
7868: PPUSH
7869: LD_INT 0
7871: PPUSH
7872: CALL_OW 324
7876: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
7877: LD_EXP 8
7881: PUSH
7882: LD_EXP 19
7886: AND
7887: IFFALSE 8068
7889: GO 7891
7891: DISABLE
7892: LD_INT 0
7894: PPUSH
7895: PPUSH
7896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
7897: LD_ADDR_VAR 0 2
7901: PUSH
7902: LD_INT 22
7904: PUSH
7905: LD_OWVAR 2
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: LD_INT 33
7916: PUSH
7917: LD_INT 3
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 69
7932: ST_TO_ADDR
// if not tmp then
7933: LD_VAR 0 2
7937: NOT
7938: IFFALSE 7942
// exit ;
7940: GO 8068
// side := 0 ;
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 0
7949: ST_TO_ADDR
// for i := 1 to 8 do
7950: LD_ADDR_VAR 0 1
7954: PUSH
7955: DOUBLE
7956: LD_INT 1
7958: DEC
7959: ST_TO_ADDR
7960: LD_INT 8
7962: PUSH
7963: FOR_TO
7964: IFFALSE 8012
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7966: LD_OWVAR 2
7970: PUSH
7971: LD_VAR 0 1
7975: NONEQUAL
7976: PUSH
7977: LD_OWVAR 2
7981: PPUSH
7982: LD_VAR 0 1
7986: PPUSH
7987: CALL_OW 81
7991: PUSH
7992: LD_INT 2
7994: EQUAL
7995: AND
7996: IFFALSE 8010
// begin side := i ;
7998: LD_ADDR_VAR 0 3
8002: PUSH
8003: LD_VAR 0 1
8007: ST_TO_ADDR
// break ;
8008: GO 8012
// end ;
8010: GO 7963
8012: POP
8013: POP
// if not side then
8014: LD_VAR 0 3
8018: NOT
8019: IFFALSE 8023
// exit ;
8021: GO 8068
// for i := 1 to tmp do
8023: LD_ADDR_VAR 0 1
8027: PUSH
8028: DOUBLE
8029: LD_INT 1
8031: DEC
8032: ST_TO_ADDR
8033: LD_VAR 0 2
8037: PUSH
8038: FOR_TO
8039: IFFALSE 8066
// if Prob ( 60 ) then
8041: LD_INT 60
8043: PPUSH
8044: CALL_OW 13
8048: IFFALSE 8064
// SetSide ( i , side ) ;
8050: LD_VAR 0 1
8054: PPUSH
8055: LD_VAR 0 3
8059: PPUSH
8060: CALL_OW 235
8064: GO 8038
8066: POP
8067: POP
// end ;
8068: PPOPN 3
8070: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
8071: LD_EXP 8
8075: PUSH
8076: LD_EXP 21
8080: AND
8081: IFFALSE 8200
8083: GO 8085
8085: DISABLE
8086: LD_INT 0
8088: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8089: LD_ADDR_VAR 0 1
8093: PUSH
8094: LD_INT 22
8096: PUSH
8097: LD_OWVAR 2
8101: PUSH
8102: EMPTY
8103: LIST
8104: LIST
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 3
8118: PUSH
8119: LD_INT 23
8121: PUSH
8122: LD_INT 0
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: PUSH
8133: EMPTY
8134: LIST
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: PUSH
8143: FOR_IN
8144: IFFALSE 8198
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL_OW 257
8155: PUSH
8156: LD_INT 1
8158: PUSH
8159: LD_INT 2
8161: PUSH
8162: LD_INT 3
8164: PUSH
8165: LD_INT 4
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: LIST
8172: LIST
8173: IN
8174: IFFALSE 8196
// SetClass ( un , rand ( 1 , 4 ) ) ;
8176: LD_VAR 0 1
8180: PPUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 4
8186: PPUSH
8187: CALL_OW 12
8191: PPUSH
8192: CALL_OW 336
8196: GO 8143
8198: POP
8199: POP
// end ;
8200: PPOPN 1
8202: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8203: LD_EXP 8
8207: PUSH
8208: LD_EXP 20
8212: AND
8213: IFFALSE 8292
8215: GO 8217
8217: DISABLE
8218: LD_INT 0
8220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8221: LD_ADDR_VAR 0 1
8225: PUSH
8226: LD_INT 22
8228: PUSH
8229: LD_OWVAR 2
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PUSH
8238: LD_INT 21
8240: PUSH
8241: LD_INT 3
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PPUSH
8252: CALL_OW 69
8256: ST_TO_ADDR
// if not tmp then
8257: LD_VAR 0 1
8261: NOT
8262: IFFALSE 8266
// exit ;
8264: GO 8292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
8266: LD_VAR 0 1
8270: PUSH
8271: LD_INT 1
8273: PPUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 12
8283: ARRAY
8284: PPUSH
8285: LD_INT 100
8287: PPUSH
8288: CALL_OW 234
// end ;
8292: PPOPN 1
8294: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
8295: LD_EXP 8
8299: PUSH
8300: LD_EXP 22
8304: AND
8305: IFFALSE 8403
8307: GO 8309
8309: DISABLE
8310: LD_INT 0
8312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8313: LD_ADDR_VAR 0 1
8317: PUSH
8318: LD_INT 22
8320: PUSH
8321: LD_OWVAR 2
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: LD_INT 21
8332: PUSH
8333: LD_INT 1
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PPUSH
8344: CALL_OW 69
8348: ST_TO_ADDR
// if not tmp then
8349: LD_VAR 0 1
8353: NOT
8354: IFFALSE 8358
// exit ;
8356: GO 8403
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8358: LD_VAR 0 1
8362: PUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_VAR 0 1
8370: PPUSH
8371: CALL_OW 12
8375: ARRAY
8376: PPUSH
8377: LD_INT 1
8379: PPUSH
8380: LD_INT 4
8382: PPUSH
8383: CALL_OW 12
8387: PPUSH
8388: LD_INT 3000
8390: PPUSH
8391: LD_INT 9000
8393: PPUSH
8394: CALL_OW 12
8398: PPUSH
8399: CALL_OW 492
// end ;
8403: PPOPN 1
8405: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8406: LD_EXP 8
8410: PUSH
8411: LD_EXP 23
8415: AND
8416: IFFALSE 8436
8418: GO 8420
8420: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8421: LD_INT 1
8423: PPUSH
8424: LD_OWVAR 2
8428: PPUSH
8429: LD_INT 0
8431: PPUSH
8432: CALL_OW 324
8436: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8437: LD_EXP 8
8441: PUSH
8442: LD_EXP 24
8446: AND
8447: IFFALSE 8530
8449: GO 8451
8451: DISABLE
8452: LD_INT 0
8454: PPUSH
8455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8456: LD_ADDR_VAR 0 2
8460: PUSH
8461: LD_INT 22
8463: PUSH
8464: LD_OWVAR 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 21
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: ST_TO_ADDR
// if not tmp then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8530
// for i in tmp do
8501: LD_ADDR_VAR 0 1
8505: PUSH
8506: LD_VAR 0 2
8510: PUSH
8511: FOR_IN
8512: IFFALSE 8528
// SetBLevel ( i , 10 ) ;
8514: LD_VAR 0 1
8518: PPUSH
8519: LD_INT 10
8521: PPUSH
8522: CALL_OW 241
8526: GO 8511
8528: POP
8529: POP
// end ;
8530: PPOPN 2
8532: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8533: LD_EXP 8
8537: PUSH
8538: LD_EXP 25
8542: AND
8543: IFFALSE 8654
8545: GO 8547
8547: DISABLE
8548: LD_INT 0
8550: PPUSH
8551: PPUSH
8552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8553: LD_ADDR_VAR 0 3
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_OWVAR 2
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: PUSH
8570: LD_INT 25
8572: PUSH
8573: LD_INT 1
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 69
8588: ST_TO_ADDR
// if not tmp then
8589: LD_VAR 0 3
8593: NOT
8594: IFFALSE 8598
// exit ;
8596: GO 8654
// un := tmp [ rand ( 1 , tmp ) ] ;
8598: LD_ADDR_VAR 0 2
8602: PUSH
8603: LD_VAR 0 3
8607: PUSH
8608: LD_INT 1
8610: PPUSH
8611: LD_VAR 0 3
8615: PPUSH
8616: CALL_OW 12
8620: ARRAY
8621: ST_TO_ADDR
// if Crawls ( un ) then
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 318
8631: IFFALSE 8642
// ComWalk ( un ) ;
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 138
// SetClass ( un , class_sniper ) ;
8642: LD_VAR 0 2
8646: PPUSH
8647: LD_INT 5
8649: PPUSH
8650: CALL_OW 336
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8657: LD_EXP 8
8661: PUSH
8662: LD_EXP 26
8666: AND
8667: PUSH
8668: LD_OWVAR 67
8672: PUSH
8673: LD_INT 3
8675: LESS
8676: AND
8677: IFFALSE 8696
8679: GO 8681
8681: DISABLE
// Difficulty := Difficulty + 1 ;
8682: LD_ADDR_OWVAR 67
8686: PUSH
8687: LD_OWVAR 67
8691: PUSH
8692: LD_INT 1
8694: PLUS
8695: ST_TO_ADDR
8696: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8697: LD_EXP 8
8701: PUSH
8702: LD_EXP 27
8706: AND
8707: IFFALSE 8810
8709: GO 8711
8711: DISABLE
8712: LD_INT 0
8714: PPUSH
// begin for i := 1 to 5 do
8715: LD_ADDR_VAR 0 1
8719: PUSH
8720: DOUBLE
8721: LD_INT 1
8723: DEC
8724: ST_TO_ADDR
8725: LD_INT 5
8727: PUSH
8728: FOR_TO
8729: IFFALSE 8808
// begin uc_nation := nation_nature ;
8731: LD_ADDR_OWVAR 21
8735: PUSH
8736: LD_INT 0
8738: ST_TO_ADDR
// uc_side := 0 ;
8739: LD_ADDR_OWVAR 20
8743: PUSH
8744: LD_INT 0
8746: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8747: LD_ADDR_OWVAR 29
8751: PUSH
8752: LD_INT 12
8754: PUSH
8755: LD_INT 12
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: ST_TO_ADDR
// hc_agressivity := 20 ;
8762: LD_ADDR_OWVAR 35
8766: PUSH
8767: LD_INT 20
8769: ST_TO_ADDR
// hc_class := class_tiger ;
8770: LD_ADDR_OWVAR 28
8774: PUSH
8775: LD_INT 14
8777: ST_TO_ADDR
// hc_gallery :=  ;
8778: LD_ADDR_OWVAR 33
8782: PUSH
8783: LD_STRING 
8785: ST_TO_ADDR
// hc_name :=  ;
8786: LD_ADDR_OWVAR 26
8790: PUSH
8791: LD_STRING 
8793: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8794: CALL_OW 44
8798: PPUSH
8799: LD_INT 0
8801: PPUSH
8802: CALL_OW 51
// end ;
8806: GO 8728
8808: POP
8809: POP
// end ;
8810: PPOPN 1
8812: END
// every 0 0$1 trigger StreamModeActive and sBomb do
8813: LD_EXP 8
8817: PUSH
8818: LD_EXP 28
8822: AND
8823: IFFALSE 8832
8825: GO 8827
8827: DISABLE
// StreamSibBomb ;
8828: CALL 8833 0 0
8832: END
// export function StreamSibBomb ; var i , x , y ; begin
8833: LD_INT 0
8835: PPUSH
8836: PPUSH
8837: PPUSH
8838: PPUSH
// result := false ;
8839: LD_ADDR_VAR 0 1
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// for i := 1 to 16 do
8847: LD_ADDR_VAR 0 2
8851: PUSH
8852: DOUBLE
8853: LD_INT 1
8855: DEC
8856: ST_TO_ADDR
8857: LD_INT 16
8859: PUSH
8860: FOR_TO
8861: IFFALSE 9060
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8863: LD_ADDR_VAR 0 3
8867: PUSH
8868: LD_INT 10
8870: PUSH
8871: LD_INT 20
8873: PUSH
8874: LD_INT 30
8876: PUSH
8877: LD_INT 40
8879: PUSH
8880: LD_INT 50
8882: PUSH
8883: LD_INT 60
8885: PUSH
8886: LD_INT 70
8888: PUSH
8889: LD_INT 80
8891: PUSH
8892: LD_INT 90
8894: PUSH
8895: LD_INT 100
8897: PUSH
8898: LD_INT 110
8900: PUSH
8901: LD_INT 120
8903: PUSH
8904: LD_INT 130
8906: PUSH
8907: LD_INT 140
8909: PUSH
8910: LD_INT 150
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: LIST
8917: LIST
8918: LIST
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: PUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 15
8935: PPUSH
8936: CALL_OW 12
8940: ARRAY
8941: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8942: LD_ADDR_VAR 0 4
8946: PUSH
8947: LD_INT 10
8949: PUSH
8950: LD_INT 20
8952: PUSH
8953: LD_INT 30
8955: PUSH
8956: LD_INT 40
8958: PUSH
8959: LD_INT 50
8961: PUSH
8962: LD_INT 60
8964: PUSH
8965: LD_INT 70
8967: PUSH
8968: LD_INT 80
8970: PUSH
8971: LD_INT 90
8973: PUSH
8974: LD_INT 100
8976: PUSH
8977: LD_INT 110
8979: PUSH
8980: LD_INT 120
8982: PUSH
8983: LD_INT 130
8985: PUSH
8986: LD_INT 140
8988: PUSH
8989: LD_INT 150
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: LIST
8996: LIST
8997: LIST
8998: LIST
8999: LIST
9000: LIST
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: PUSH
9009: LD_INT 1
9011: PPUSH
9012: LD_INT 15
9014: PPUSH
9015: CALL_OW 12
9019: ARRAY
9020: ST_TO_ADDR
// if ValidHex ( x , y ) then
9021: LD_VAR 0 3
9025: PPUSH
9026: LD_VAR 0 4
9030: PPUSH
9031: CALL_OW 488
9035: IFFALSE 9058
// begin result := [ x , y ] ;
9037: LD_ADDR_VAR 0 1
9041: PUSH
9042: LD_VAR 0 3
9046: PUSH
9047: LD_VAR 0 4
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: ST_TO_ADDR
// break ;
9056: GO 9060
// end ; end ;
9058: GO 8860
9060: POP
9061: POP
// if result then
9062: LD_VAR 0 1
9066: IFFALSE 9126
// begin ToLua ( playSibBomb() ) ;
9068: LD_STRING playSibBomb()
9070: PPUSH
9071: CALL_OW 559
// wait ( 0 0$14 ) ;
9075: LD_INT 490
9077: PPUSH
9078: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
9082: LD_VAR 0 1
9086: PUSH
9087: LD_INT 1
9089: ARRAY
9090: PPUSH
9091: LD_VAR 0 1
9095: PUSH
9096: LD_INT 2
9098: ARRAY
9099: PPUSH
9100: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
9104: LD_VAR 0 1
9108: PUSH
9109: LD_INT 1
9111: ARRAY
9112: PPUSH
9113: LD_VAR 0 1
9117: PUSH
9118: LD_INT 2
9120: ARRAY
9121: PPUSH
9122: CALL_OW 429
// end ; end ;
9126: LD_VAR 0 1
9130: RET
// every 0 0$1 trigger StreamModeActive and sReset do
9131: LD_EXP 8
9135: PUSH
9136: LD_EXP 30
9140: AND
9141: IFFALSE 9153
9143: GO 9145
9145: DISABLE
// YouLost (  ) ;
9146: LD_STRING 
9148: PPUSH
9149: CALL_OW 104
9153: END
// every 0 0$1 trigger StreamModeActive and sFog do
9154: LD_EXP 8
9158: PUSH
9159: LD_EXP 29
9163: AND
9164: IFFALSE 9178
9166: GO 9168
9168: DISABLE
// FogOff ( your_side ) ;
9169: LD_OWVAR 2
9173: PPUSH
9174: CALL_OW 344
9178: END
// every 0 0$1 trigger StreamModeActive and sSun do
9179: LD_EXP 8
9183: PUSH
9184: LD_EXP 31
9188: AND
9189: IFFALSE 9217
9191: GO 9193
9193: DISABLE
// begin solar_recharge_percent := 0 ;
9194: LD_ADDR_OWVAR 79
9198: PUSH
9199: LD_INT 0
9201: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9202: LD_INT 10500
9204: PPUSH
9205: CALL_OW 67
// solar_recharge_percent := 100 ;
9209: LD_ADDR_OWVAR 79
9213: PUSH
9214: LD_INT 100
9216: ST_TO_ADDR
// end ;
9217: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
9218: LD_EXP 8
9222: PUSH
9223: LD_EXP 32
9227: AND
9228: IFFALSE 9467
9230: GO 9232
9232: DISABLE
9233: LD_INT 0
9235: PPUSH
9236: PPUSH
9237: PPUSH
// begin tmp := [ ] ;
9238: LD_ADDR_VAR 0 3
9242: PUSH
9243: EMPTY
9244: ST_TO_ADDR
// for i := 1 to 6 do
9245: LD_ADDR_VAR 0 1
9249: PUSH
9250: DOUBLE
9251: LD_INT 1
9253: DEC
9254: ST_TO_ADDR
9255: LD_INT 6
9257: PUSH
9258: FOR_TO
9259: IFFALSE 9364
// begin uc_nation := nation_nature ;
9261: LD_ADDR_OWVAR 21
9265: PUSH
9266: LD_INT 0
9268: ST_TO_ADDR
// uc_side := 0 ;
9269: LD_ADDR_OWVAR 20
9273: PUSH
9274: LD_INT 0
9276: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9277: LD_ADDR_OWVAR 29
9281: PUSH
9282: LD_INT 12
9284: PUSH
9285: LD_INT 12
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: ST_TO_ADDR
// hc_agressivity := 20 ;
9292: LD_ADDR_OWVAR 35
9296: PUSH
9297: LD_INT 20
9299: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9300: LD_ADDR_OWVAR 28
9304: PUSH
9305: LD_INT 17
9307: ST_TO_ADDR
// hc_gallery :=  ;
9308: LD_ADDR_OWVAR 33
9312: PUSH
9313: LD_STRING 
9315: ST_TO_ADDR
// hc_name :=  ;
9316: LD_ADDR_OWVAR 26
9320: PUSH
9321: LD_STRING 
9323: ST_TO_ADDR
// un := CreateHuman ;
9324: LD_ADDR_VAR 0 2
9328: PUSH
9329: CALL_OW 44
9333: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9334: LD_VAR 0 2
9338: PPUSH
9339: LD_INT 1
9341: PPUSH
9342: CALL_OW 51
// tmp := tmp ^ un ;
9346: LD_ADDR_VAR 0 3
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_VAR 0 2
9360: ADD
9361: ST_TO_ADDR
// end ;
9362: GO 9258
9364: POP
9365: POP
// repeat wait ( 0 0$1 ) ;
9366: LD_INT 35
9368: PPUSH
9369: CALL_OW 67
// for un in tmp do
9373: LD_ADDR_VAR 0 2
9377: PUSH
9378: LD_VAR 0 3
9382: PUSH
9383: FOR_IN
9384: IFFALSE 9458
// begin if IsDead ( un ) then
9386: LD_VAR 0 2
9390: PPUSH
9391: CALL_OW 301
9395: IFFALSE 9415
// begin tmp := tmp diff un ;
9397: LD_ADDR_VAR 0 3
9401: PUSH
9402: LD_VAR 0 3
9406: PUSH
9407: LD_VAR 0 2
9411: DIFF
9412: ST_TO_ADDR
// continue ;
9413: GO 9383
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9415: LD_VAR 0 2
9419: PPUSH
9420: LD_INT 3
9422: PUSH
9423: LD_INT 22
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PPUSH
9437: CALL_OW 69
9441: PPUSH
9442: LD_VAR 0 2
9446: PPUSH
9447: CALL_OW 74
9451: PPUSH
9452: CALL_OW 115
// end ;
9456: GO 9383
9458: POP
9459: POP
// until not tmp ;
9460: LD_VAR 0 3
9464: NOT
9465: IFFALSE 9366
// end ;
9467: PPOPN 3
9469: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9470: LD_EXP 8
9474: PUSH
9475: LD_EXP 33
9479: AND
9480: IFFALSE 9534
9482: GO 9484
9484: DISABLE
// begin ToLua ( displayTroll(); ) ;
9485: LD_STRING displayTroll();
9487: PPUSH
9488: CALL_OW 559
// wait ( 3 3$00 ) ;
9492: LD_INT 6300
9494: PPUSH
9495: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9499: LD_STRING hideTroll();
9501: PPUSH
9502: CALL_OW 559
// wait ( 1 1$00 ) ;
9506: LD_INT 2100
9508: PPUSH
9509: CALL_OW 67
// ToLua ( displayTroll(); ) ;
9513: LD_STRING displayTroll();
9515: PPUSH
9516: CALL_OW 559
// wait ( 1 1$00 ) ;
9520: LD_INT 2100
9522: PPUSH
9523: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9527: LD_STRING hideTroll();
9529: PPUSH
9530: CALL_OW 559
// end ;
9534: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9535: LD_EXP 8
9539: PUSH
9540: LD_EXP 34
9544: AND
9545: IFFALSE 9608
9547: GO 9549
9549: DISABLE
9550: LD_INT 0
9552: PPUSH
// begin p := 0 ;
9553: LD_ADDR_VAR 0 1
9557: PUSH
9558: LD_INT 0
9560: ST_TO_ADDR
// repeat game_speed := 1 ;
9561: LD_ADDR_OWVAR 65
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9569: LD_INT 35
9571: PPUSH
9572: CALL_OW 67
// p := p + 1 ;
9576: LD_ADDR_VAR 0 1
9580: PUSH
9581: LD_VAR 0 1
9585: PUSH
9586: LD_INT 1
9588: PLUS
9589: ST_TO_ADDR
// until p >= 60 ;
9590: LD_VAR 0 1
9594: PUSH
9595: LD_INT 60
9597: GREATEREQUAL
9598: IFFALSE 9561
// game_speed := 4 ;
9600: LD_ADDR_OWVAR 65
9604: PUSH
9605: LD_INT 4
9607: ST_TO_ADDR
// end ;
9608: PPOPN 1
9610: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9611: LD_EXP 8
9615: PUSH
9616: LD_EXP 35
9620: AND
9621: IFFALSE 9767
9623: GO 9625
9625: DISABLE
9626: LD_INT 0
9628: PPUSH
9629: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9630: LD_ADDR_VAR 0 1
9634: PUSH
9635: LD_INT 22
9637: PUSH
9638: LD_OWVAR 2
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 2
9649: PUSH
9650: LD_INT 30
9652: PUSH
9653: LD_INT 0
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: LD_INT 30
9662: PUSH
9663: LD_INT 1
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: PPUSH
9679: CALL_OW 69
9683: ST_TO_ADDR
// if not depot then
9684: LD_VAR 0 1
9688: NOT
9689: IFFALSE 9693
// exit ;
9691: GO 9767
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9693: LD_ADDR_VAR 0 2
9697: PUSH
9698: LD_VAR 0 1
9702: PUSH
9703: LD_INT 1
9705: PPUSH
9706: LD_VAR 0 1
9710: PPUSH
9711: CALL_OW 12
9715: ARRAY
9716: PPUSH
9717: CALL_OW 274
9721: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9722: LD_VAR 0 2
9726: PPUSH
9727: LD_INT 1
9729: PPUSH
9730: LD_INT 0
9732: PPUSH
9733: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9737: LD_VAR 0 2
9741: PPUSH
9742: LD_INT 2
9744: PPUSH
9745: LD_INT 0
9747: PPUSH
9748: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9752: LD_VAR 0 2
9756: PPUSH
9757: LD_INT 3
9759: PPUSH
9760: LD_INT 0
9762: PPUSH
9763: CALL_OW 277
// end ;
9767: PPOPN 2
9769: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9770: LD_EXP 8
9774: PUSH
9775: LD_EXP 36
9779: AND
9780: IFFALSE 9877
9782: GO 9784
9784: DISABLE
9785: LD_INT 0
9787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9788: LD_ADDR_VAR 0 1
9792: PUSH
9793: LD_INT 22
9795: PUSH
9796: LD_OWVAR 2
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PUSH
9805: LD_INT 21
9807: PUSH
9808: LD_INT 1
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PUSH
9815: LD_INT 3
9817: PUSH
9818: LD_INT 23
9820: PUSH
9821: LD_INT 0
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PPUSH
9837: CALL_OW 69
9841: ST_TO_ADDR
// if not tmp then
9842: LD_VAR 0 1
9846: NOT
9847: IFFALSE 9851
// exit ;
9849: GO 9877
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9851: LD_VAR 0 1
9855: PUSH
9856: LD_INT 1
9858: PPUSH
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 12
9868: ARRAY
9869: PPUSH
9870: LD_INT 200
9872: PPUSH
9873: CALL_OW 234
// end ;
9877: PPOPN 1
9879: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9880: LD_EXP 8
9884: PUSH
9885: LD_EXP 37
9889: AND
9890: IFFALSE 9969
9892: GO 9894
9894: DISABLE
9895: LD_INT 0
9897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9898: LD_ADDR_VAR 0 1
9902: PUSH
9903: LD_INT 22
9905: PUSH
9906: LD_OWVAR 2
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PUSH
9915: LD_INT 21
9917: PUSH
9918: LD_INT 2
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PPUSH
9929: CALL_OW 69
9933: ST_TO_ADDR
// if not tmp then
9934: LD_VAR 0 1
9938: NOT
9939: IFFALSE 9943
// exit ;
9941: GO 9969
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9943: LD_VAR 0 1
9947: PUSH
9948: LD_INT 1
9950: PPUSH
9951: LD_VAR 0 1
9955: PPUSH
9956: CALL_OW 12
9960: ARRAY
9961: PPUSH
9962: LD_INT 60
9964: PPUSH
9965: CALL_OW 234
// end ;
9969: PPOPN 1
9971: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9972: LD_EXP 8
9976: PUSH
9977: LD_EXP 38
9981: AND
9982: IFFALSE 10081
9984: GO 9986
9986: DISABLE
9987: LD_INT 0
9989: PPUSH
9990: PPUSH
// begin enable ;
9991: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9992: LD_ADDR_VAR 0 1
9996: PUSH
9997: LD_INT 22
9999: PUSH
10000: LD_OWVAR 2
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 61
10011: PUSH
10012: EMPTY
10013: LIST
10014: PUSH
10015: LD_INT 33
10017: PUSH
10018: LD_INT 2
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: PPUSH
10030: CALL_OW 69
10034: ST_TO_ADDR
// if not tmp then
10035: LD_VAR 0 1
10039: NOT
10040: IFFALSE 10044
// exit ;
10042: GO 10081
// for i in tmp do
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: LD_VAR 0 1
10053: PUSH
10054: FOR_IN
10055: IFFALSE 10079
// if IsControledBy ( i ) then
10057: LD_VAR 0 2
10061: PPUSH
10062: CALL_OW 312
10066: IFFALSE 10077
// ComUnlink ( i ) ;
10068: LD_VAR 0 2
10072: PPUSH
10073: CALL_OW 136
10077: GO 10054
10079: POP
10080: POP
// end ;
10081: PPOPN 2
10083: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
10084: LD_EXP 8
10088: PUSH
10089: LD_EXP 39
10093: AND
10094: IFFALSE 10234
10096: GO 10098
10098: DISABLE
10099: LD_INT 0
10101: PPUSH
10102: PPUSH
// begin ToLua ( displayPowell(); ) ;
10103: LD_STRING displayPowell();
10105: PPUSH
10106: CALL_OW 559
// uc_side := 0 ;
10110: LD_ADDR_OWVAR 20
10114: PUSH
10115: LD_INT 0
10117: ST_TO_ADDR
// uc_nation := 2 ;
10118: LD_ADDR_OWVAR 21
10122: PUSH
10123: LD_INT 2
10125: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10126: LD_ADDR_OWVAR 37
10130: PUSH
10131: LD_INT 14
10133: ST_TO_ADDR
// vc_engine := engine_siberite ;
10134: LD_ADDR_OWVAR 39
10138: PUSH
10139: LD_INT 3
10141: ST_TO_ADDR
// vc_control := control_apeman ;
10142: LD_ADDR_OWVAR 38
10146: PUSH
10147: LD_INT 5
10149: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
10150: LD_ADDR_OWVAR 40
10154: PUSH
10155: LD_INT 29
10157: ST_TO_ADDR
// un := CreateVehicle ;
10158: LD_ADDR_VAR 0 2
10162: PUSH
10163: CALL_OW 45
10167: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10168: LD_VAR 0 2
10172: PPUSH
10173: LD_INT 1
10175: PPUSH
10176: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10180: LD_INT 35
10182: PPUSH
10183: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10187: LD_VAR 0 2
10191: PPUSH
10192: LD_INT 22
10194: PUSH
10195: LD_OWVAR 2
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: PPUSH
10204: CALL_OW 69
10208: PPUSH
10209: LD_VAR 0 2
10213: PPUSH
10214: CALL_OW 74
10218: PPUSH
10219: CALL_OW 115
// until IsDead ( un ) ;
10223: LD_VAR 0 2
10227: PPUSH
10228: CALL_OW 301
10232: IFFALSE 10180
// end ;
10234: PPOPN 2
10236: END
// every 0 0$1 trigger StreamModeActive and sStu do
10237: LD_EXP 8
10241: PUSH
10242: LD_EXP 47
10246: AND
10247: IFFALSE 10263
10249: GO 10251
10251: DISABLE
// begin ToLua ( displayStucuk(); ) ;
10252: LD_STRING displayStucuk();
10254: PPUSH
10255: CALL_OW 559
// ResetFog ;
10259: CALL_OW 335
// end ;
10263: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
10264: LD_EXP 8
10268: PUSH
10269: LD_EXP 40
10273: AND
10274: IFFALSE 10415
10276: GO 10278
10278: DISABLE
10279: LD_INT 0
10281: PPUSH
10282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10283: LD_ADDR_VAR 0 2
10287: PUSH
10288: LD_INT 22
10290: PUSH
10291: LD_OWVAR 2
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 21
10302: PUSH
10303: LD_INT 1
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PPUSH
10314: CALL_OW 69
10318: ST_TO_ADDR
// if not tmp then
10319: LD_VAR 0 2
10323: NOT
10324: IFFALSE 10328
// exit ;
10326: GO 10415
// un := tmp [ rand ( 1 , tmp ) ] ;
10328: LD_ADDR_VAR 0 1
10332: PUSH
10333: LD_VAR 0 2
10337: PUSH
10338: LD_INT 1
10340: PPUSH
10341: LD_VAR 0 2
10345: PPUSH
10346: CALL_OW 12
10350: ARRAY
10351: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_OWVAR 3
10373: PUSH
10374: LD_VAR 0 1
10378: DIFF
10379: PPUSH
10380: LD_VAR 0 1
10384: PPUSH
10385: CALL_OW 74
10389: PPUSH
10390: CALL_OW 115
// wait ( 0 0$20 ) ;
10394: LD_INT 700
10396: PPUSH
10397: CALL_OW 67
// SetSide ( un , your_side ) ;
10401: LD_VAR 0 1
10405: PPUSH
10406: LD_OWVAR 2
10410: PPUSH
10411: CALL_OW 235
// end ;
10415: PPOPN 2
10417: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10418: LD_EXP 8
10422: PUSH
10423: LD_EXP 41
10427: AND
10428: IFFALSE 10534
10430: GO 10432
10432: DISABLE
10433: LD_INT 0
10435: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10436: LD_ADDR_VAR 0 1
10440: PUSH
10441: LD_INT 22
10443: PUSH
10444: LD_OWVAR 2
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: PUSH
10453: LD_INT 2
10455: PUSH
10456: LD_INT 30
10458: PUSH
10459: LD_INT 0
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 1
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PPUSH
10485: CALL_OW 69
10489: ST_TO_ADDR
// if not depot then
10490: LD_VAR 0 1
10494: NOT
10495: IFFALSE 10499
// exit ;
10497: GO 10534
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10499: LD_VAR 0 1
10503: PUSH
10504: LD_INT 1
10506: ARRAY
10507: PPUSH
10508: CALL_OW 250
10512: PPUSH
10513: LD_VAR 0 1
10517: PUSH
10518: LD_INT 1
10520: ARRAY
10521: PPUSH
10522: CALL_OW 251
10526: PPUSH
10527: LD_INT 70
10529: PPUSH
10530: CALL_OW 495
// end ;
10534: PPOPN 1
10536: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10537: LD_EXP 8
10541: PUSH
10542: LD_EXP 42
10546: AND
10547: IFFALSE 10758
10549: GO 10551
10551: DISABLE
10552: LD_INT 0
10554: PPUSH
10555: PPUSH
10556: PPUSH
10557: PPUSH
10558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10559: LD_ADDR_VAR 0 5
10563: PUSH
10564: LD_INT 22
10566: PUSH
10567: LD_OWVAR 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: LD_INT 21
10578: PUSH
10579: LD_INT 1
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PPUSH
10590: CALL_OW 69
10594: ST_TO_ADDR
// if not tmp then
10595: LD_VAR 0 5
10599: NOT
10600: IFFALSE 10604
// exit ;
10602: GO 10758
// for i in tmp do
10604: LD_ADDR_VAR 0 1
10608: PUSH
10609: LD_VAR 0 5
10613: PUSH
10614: FOR_IN
10615: IFFALSE 10756
// begin d := rand ( 0 , 5 ) ;
10617: LD_ADDR_VAR 0 4
10621: PUSH
10622: LD_INT 0
10624: PPUSH
10625: LD_INT 5
10627: PPUSH
10628: CALL_OW 12
10632: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10633: LD_ADDR_VAR 0 2
10637: PUSH
10638: LD_VAR 0 1
10642: PPUSH
10643: CALL_OW 250
10647: PPUSH
10648: LD_VAR 0 4
10652: PPUSH
10653: LD_INT 3
10655: PPUSH
10656: LD_INT 12
10658: PPUSH
10659: CALL_OW 12
10663: PPUSH
10664: CALL_OW 272
10668: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10669: LD_ADDR_VAR 0 3
10673: PUSH
10674: LD_VAR 0 1
10678: PPUSH
10679: CALL_OW 251
10683: PPUSH
10684: LD_VAR 0 4
10688: PPUSH
10689: LD_INT 3
10691: PPUSH
10692: LD_INT 12
10694: PPUSH
10695: CALL_OW 12
10699: PPUSH
10700: CALL_OW 273
10704: ST_TO_ADDR
// if ValidHex ( x , y ) then
10705: LD_VAR 0 2
10709: PPUSH
10710: LD_VAR 0 3
10714: PPUSH
10715: CALL_OW 488
10719: IFFALSE 10754
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10721: LD_VAR 0 1
10725: PPUSH
10726: LD_VAR 0 2
10730: PPUSH
10731: LD_VAR 0 3
10735: PPUSH
10736: LD_INT 3
10738: PPUSH
10739: LD_INT 6
10741: PPUSH
10742: CALL_OW 12
10746: PPUSH
10747: LD_INT 1
10749: PPUSH
10750: CALL_OW 483
// end ;
10754: GO 10614
10756: POP
10757: POP
// end ;
10758: PPOPN 5
10760: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10761: LD_EXP 8
10765: PUSH
10766: LD_EXP 43
10770: AND
10771: IFFALSE 10865
10773: GO 10775
10775: DISABLE
10776: LD_INT 0
10778: PPUSH
10779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10780: LD_ADDR_VAR 0 2
10784: PUSH
10785: LD_INT 22
10787: PUSH
10788: LD_OWVAR 2
10792: PUSH
10793: EMPTY
10794: LIST
10795: LIST
10796: PUSH
10797: LD_INT 32
10799: PUSH
10800: LD_INT 1
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PUSH
10807: LD_INT 21
10809: PUSH
10810: LD_INT 2
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: LIST
10821: PPUSH
10822: CALL_OW 69
10826: ST_TO_ADDR
// if not tmp then
10827: LD_VAR 0 2
10831: NOT
10832: IFFALSE 10836
// exit ;
10834: GO 10865
// for i in tmp do
10836: LD_ADDR_VAR 0 1
10840: PUSH
10841: LD_VAR 0 2
10845: PUSH
10846: FOR_IN
10847: IFFALSE 10863
// SetFuel ( i , 0 ) ;
10849: LD_VAR 0 1
10853: PPUSH
10854: LD_INT 0
10856: PPUSH
10857: CALL_OW 240
10861: GO 10846
10863: POP
10864: POP
// end ;
10865: PPOPN 2
10867: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
10868: LD_EXP 8
10872: PUSH
10873: LD_EXP 44
10877: AND
10878: IFFALSE 10944
10880: GO 10882
10882: DISABLE
10883: LD_INT 0
10885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10886: LD_ADDR_VAR 0 1
10890: PUSH
10891: LD_INT 22
10893: PUSH
10894: LD_OWVAR 2
10898: PUSH
10899: EMPTY
10900: LIST
10901: LIST
10902: PUSH
10903: LD_INT 30
10905: PUSH
10906: LD_INT 29
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PPUSH
10917: CALL_OW 69
10921: ST_TO_ADDR
// if not tmp then
10922: LD_VAR 0 1
10926: NOT
10927: IFFALSE 10931
// exit ;
10929: GO 10944
// DestroyUnit ( tmp [ 1 ] ) ;
10931: LD_VAR 0 1
10935: PUSH
10936: LD_INT 1
10938: ARRAY
10939: PPUSH
10940: CALL_OW 65
// end ;
10944: PPOPN 1
10946: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10947: LD_EXP 8
10951: PUSH
10952: LD_EXP 46
10956: AND
10957: IFFALSE 11086
10959: GO 10961
10961: DISABLE
10962: LD_INT 0
10964: PPUSH
// begin uc_side := 0 ;
10965: LD_ADDR_OWVAR 20
10969: PUSH
10970: LD_INT 0
10972: ST_TO_ADDR
// uc_nation := nation_arabian ;
10973: LD_ADDR_OWVAR 21
10977: PUSH
10978: LD_INT 2
10980: ST_TO_ADDR
// hc_gallery :=  ;
10981: LD_ADDR_OWVAR 33
10985: PUSH
10986: LD_STRING 
10988: ST_TO_ADDR
// hc_name :=  ;
10989: LD_ADDR_OWVAR 26
10993: PUSH
10994: LD_STRING 
10996: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10997: LD_INT 1
10999: PPUSH
11000: LD_INT 11
11002: PPUSH
11003: LD_INT 10
11005: PPUSH
11006: CALL_OW 380
// un := CreateHuman ;
11010: LD_ADDR_VAR 0 1
11014: PUSH
11015: CALL_OW 44
11019: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11020: LD_VAR 0 1
11024: PPUSH
11025: LD_INT 1
11027: PPUSH
11028: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11032: LD_INT 35
11034: PPUSH
11035: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11039: LD_VAR 0 1
11043: PPUSH
11044: LD_INT 22
11046: PUSH
11047: LD_OWVAR 2
11051: PUSH
11052: EMPTY
11053: LIST
11054: LIST
11055: PPUSH
11056: CALL_OW 69
11060: PPUSH
11061: LD_VAR 0 1
11065: PPUSH
11066: CALL_OW 74
11070: PPUSH
11071: CALL_OW 115
// until IsDead ( un ) ;
11075: LD_VAR 0 1
11079: PPUSH
11080: CALL_OW 301
11084: IFFALSE 11032
// end ;
11086: PPOPN 1
11088: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
11089: LD_EXP 8
11093: PUSH
11094: LD_EXP 48
11098: AND
11099: IFFALSE 11111
11101: GO 11103
11103: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
11104: LD_STRING earthquake(getX(game), 0, 32)
11106: PPUSH
11107: CALL_OW 559
11111: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
11112: LD_EXP 8
11116: PUSH
11117: LD_EXP 49
11121: AND
11122: IFFALSE 11213
11124: GO 11126
11126: DISABLE
11127: LD_INT 0
11129: PPUSH
// begin enable ;
11130: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
11131: LD_ADDR_VAR 0 1
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_OWVAR 2
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 2
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: LD_INT 33
11160: PUSH
11161: LD_INT 3
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: ST_TO_ADDR
// if not tmp then
11178: LD_VAR 0 1
11182: NOT
11183: IFFALSE 11187
// exit ;
11185: GO 11213
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11187: LD_VAR 0 1
11191: PUSH
11192: LD_INT 1
11194: PPUSH
11195: LD_VAR 0 1
11199: PPUSH
11200: CALL_OW 12
11204: ARRAY
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: CALL_OW 234
// end ;
11213: PPOPN 1
11215: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
11216: LD_EXP 8
11220: PUSH
11221: LD_EXP 50
11225: AND
11226: IFFALSE 11367
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
11235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11236: LD_ADDR_VAR 0 3
11240: PUSH
11241: LD_INT 22
11243: PUSH
11244: LD_OWVAR 2
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 25
11255: PUSH
11256: LD_INT 1
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: ST_TO_ADDR
// if not tmp then
11272: LD_VAR 0 3
11276: NOT
11277: IFFALSE 11281
// exit ;
11279: GO 11367
// un := tmp [ rand ( 1 , tmp ) ] ;
11281: LD_ADDR_VAR 0 2
11285: PUSH
11286: LD_VAR 0 3
11290: PUSH
11291: LD_INT 1
11293: PPUSH
11294: LD_VAR 0 3
11298: PPUSH
11299: CALL_OW 12
11303: ARRAY
11304: ST_TO_ADDR
// if Crawls ( un ) then
11305: LD_VAR 0 2
11309: PPUSH
11310: CALL_OW 318
11314: IFFALSE 11325
// ComWalk ( un ) ;
11316: LD_VAR 0 2
11320: PPUSH
11321: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
11325: LD_VAR 0 2
11329: PPUSH
11330: LD_INT 9
11332: PPUSH
11333: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
11337: LD_INT 28
11339: PPUSH
11340: LD_OWVAR 2
11344: PPUSH
11345: LD_INT 2
11347: PPUSH
11348: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
11352: LD_INT 29
11354: PPUSH
11355: LD_OWVAR 2
11359: PPUSH
11360: LD_INT 2
11362: PPUSH
11363: CALL_OW 322
// end ;
11367: PPOPN 3
11369: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
11370: LD_EXP 8
11374: PUSH
11375: LD_EXP 51
11379: AND
11380: IFFALSE 11491
11382: GO 11384
11384: DISABLE
11385: LD_INT 0
11387: PPUSH
11388: PPUSH
11389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11390: LD_ADDR_VAR 0 3
11394: PUSH
11395: LD_INT 22
11397: PUSH
11398: LD_OWVAR 2
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: PUSH
11407: LD_INT 25
11409: PUSH
11410: LD_INT 1
11412: PUSH
11413: EMPTY
11414: LIST
11415: LIST
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PPUSH
11421: CALL_OW 69
11425: ST_TO_ADDR
// if not tmp then
11426: LD_VAR 0 3
11430: NOT
11431: IFFALSE 11435
// exit ;
11433: GO 11491
// un := tmp [ rand ( 1 , tmp ) ] ;
11435: LD_ADDR_VAR 0 2
11439: PUSH
11440: LD_VAR 0 3
11444: PUSH
11445: LD_INT 1
11447: PPUSH
11448: LD_VAR 0 3
11452: PPUSH
11453: CALL_OW 12
11457: ARRAY
11458: ST_TO_ADDR
// if Crawls ( un ) then
11459: LD_VAR 0 2
11463: PPUSH
11464: CALL_OW 318
11468: IFFALSE 11479
// ComWalk ( un ) ;
11470: LD_VAR 0 2
11474: PPUSH
11475: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 8
11486: PPUSH
11487: CALL_OW 336
// end ;
11491: PPOPN 3
11493: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
11494: LD_EXP 8
11498: PUSH
11499: LD_EXP 52
11503: AND
11504: IFFALSE 11648
11506: GO 11508
11508: DISABLE
11509: LD_INT 0
11511: PPUSH
11512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
11513: LD_ADDR_VAR 0 2
11517: PUSH
11518: LD_INT 22
11520: PUSH
11521: LD_OWVAR 2
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: PUSH
11530: LD_INT 21
11532: PUSH
11533: LD_INT 2
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PUSH
11540: LD_INT 2
11542: PUSH
11543: LD_INT 34
11545: PUSH
11546: LD_INT 12
11548: PUSH
11549: EMPTY
11550: LIST
11551: LIST
11552: PUSH
11553: LD_INT 34
11555: PUSH
11556: LD_INT 51
11558: PUSH
11559: EMPTY
11560: LIST
11561: LIST
11562: PUSH
11563: LD_INT 34
11565: PUSH
11566: LD_INT 32
11568: PUSH
11569: EMPTY
11570: LIST
11571: LIST
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: LIST
11583: PPUSH
11584: CALL_OW 69
11588: ST_TO_ADDR
// if not tmp then
11589: LD_VAR 0 2
11593: NOT
11594: IFFALSE 11598
// exit ;
11596: GO 11648
// for i in tmp do
11598: LD_ADDR_VAR 0 1
11602: PUSH
11603: LD_VAR 0 2
11607: PUSH
11608: FOR_IN
11609: IFFALSE 11646
// if GetCargo ( i , mat_artifact ) = 0 then
11611: LD_VAR 0 1
11615: PPUSH
11616: LD_INT 4
11618: PPUSH
11619: CALL_OW 289
11623: PUSH
11624: LD_INT 0
11626: EQUAL
11627: IFFALSE 11644
// SetCargo ( i , mat_siberit , 100 ) ;
11629: LD_VAR 0 1
11633: PPUSH
11634: LD_INT 3
11636: PPUSH
11637: LD_INT 100
11639: PPUSH
11640: CALL_OW 290
11644: GO 11608
11646: POP
11647: POP
// end ;
11648: PPOPN 2
11650: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
11651: LD_EXP 8
11655: PUSH
11656: LD_EXP 53
11660: AND
11661: IFFALSE 11844
11663: GO 11665
11665: DISABLE
11666: LD_INT 0
11668: PPUSH
11669: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
11670: LD_ADDR_VAR 0 2
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_OWVAR 2
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PPUSH
11687: CALL_OW 69
11691: ST_TO_ADDR
// if not tmp then
11692: LD_VAR 0 2
11696: NOT
11697: IFFALSE 11701
// exit ;
11699: GO 11844
// for i := 1 to 2 do
11701: LD_ADDR_VAR 0 1
11705: PUSH
11706: DOUBLE
11707: LD_INT 1
11709: DEC
11710: ST_TO_ADDR
11711: LD_INT 2
11713: PUSH
11714: FOR_TO
11715: IFFALSE 11842
// begin uc_side := your_side ;
11717: LD_ADDR_OWVAR 20
11721: PUSH
11722: LD_OWVAR 2
11726: ST_TO_ADDR
// uc_nation := nation_american ;
11727: LD_ADDR_OWVAR 21
11731: PUSH
11732: LD_INT 1
11734: ST_TO_ADDR
// vc_chassis := us_morphling ;
11735: LD_ADDR_OWVAR 37
11739: PUSH
11740: LD_INT 5
11742: ST_TO_ADDR
// vc_engine := engine_siberite ;
11743: LD_ADDR_OWVAR 39
11747: PUSH
11748: LD_INT 3
11750: ST_TO_ADDR
// vc_control := control_computer ;
11751: LD_ADDR_OWVAR 38
11755: PUSH
11756: LD_INT 3
11758: ST_TO_ADDR
// vc_weapon := us_double_laser ;
11759: LD_ADDR_OWVAR 40
11763: PUSH
11764: LD_INT 10
11766: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
11767: LD_VAR 0 2
11771: PUSH
11772: LD_INT 1
11774: ARRAY
11775: PPUSH
11776: CALL_OW 310
11780: NOT
11781: IFFALSE 11828
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
11783: CALL_OW 45
11787: PPUSH
11788: LD_VAR 0 2
11792: PUSH
11793: LD_INT 1
11795: ARRAY
11796: PPUSH
11797: CALL_OW 250
11801: PPUSH
11802: LD_VAR 0 2
11806: PUSH
11807: LD_INT 1
11809: ARRAY
11810: PPUSH
11811: CALL_OW 251
11815: PPUSH
11816: LD_INT 12
11818: PPUSH
11819: LD_INT 1
11821: PPUSH
11822: CALL_OW 50
11826: GO 11840
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
11828: CALL_OW 45
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: CALL_OW 51
// end ;
11840: GO 11714
11842: POP
11843: POP
// end ;
11844: PPOPN 2
11846: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
11847: LD_EXP 8
11851: PUSH
11852: LD_EXP 54
11856: AND
11857: IFFALSE 12079
11859: GO 11861
11861: DISABLE
11862: LD_INT 0
11864: PPUSH
11865: PPUSH
11866: PPUSH
11867: PPUSH
11868: PPUSH
11869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11870: LD_ADDR_VAR 0 6
11874: PUSH
11875: LD_INT 22
11877: PUSH
11878: LD_OWVAR 2
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 21
11889: PUSH
11890: LD_INT 1
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 3
11899: PUSH
11900: LD_INT 23
11902: PUSH
11903: LD_INT 0
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: LIST
11918: PPUSH
11919: CALL_OW 69
11923: ST_TO_ADDR
// if not tmp then
11924: LD_VAR 0 6
11928: NOT
11929: IFFALSE 11933
// exit ;
11931: GO 12079
// s1 := rand ( 1 , 4 ) ;
11933: LD_ADDR_VAR 0 2
11937: PUSH
11938: LD_INT 1
11940: PPUSH
11941: LD_INT 4
11943: PPUSH
11944: CALL_OW 12
11948: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
11949: LD_ADDR_VAR 0 4
11953: PUSH
11954: LD_VAR 0 6
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: LD_VAR 0 2
11967: PPUSH
11968: CALL_OW 259
11972: ST_TO_ADDR
// if s1 = 1 then
11973: LD_VAR 0 2
11977: PUSH
11978: LD_INT 1
11980: EQUAL
11981: IFFALSE 12001
// s2 := rand ( 2 , 4 ) else
11983: LD_ADDR_VAR 0 3
11987: PUSH
11988: LD_INT 2
11990: PPUSH
11991: LD_INT 4
11993: PPUSH
11994: CALL_OW 12
11998: ST_TO_ADDR
11999: GO 12009
// s2 := 1 ;
12001: LD_ADDR_VAR 0 3
12005: PUSH
12006: LD_INT 1
12008: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
12009: LD_ADDR_VAR 0 5
12013: PUSH
12014: LD_VAR 0 6
12018: PUSH
12019: LD_INT 1
12021: ARRAY
12022: PPUSH
12023: LD_VAR 0 3
12027: PPUSH
12028: CALL_OW 259
12032: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
12033: LD_VAR 0 6
12037: PUSH
12038: LD_INT 1
12040: ARRAY
12041: PPUSH
12042: LD_VAR 0 2
12046: PPUSH
12047: LD_VAR 0 5
12051: PPUSH
12052: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
12056: LD_VAR 0 6
12060: PUSH
12061: LD_INT 1
12063: ARRAY
12064: PPUSH
12065: LD_VAR 0 3
12069: PPUSH
12070: LD_VAR 0 4
12074: PPUSH
12075: CALL_OW 237
// end ;
12079: PPOPN 6
12081: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
12082: LD_EXP 8
12086: PUSH
12087: LD_EXP 55
12091: AND
12092: IFFALSE 12171
12094: GO 12096
12096: DISABLE
12097: LD_INT 0
12099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
12100: LD_ADDR_VAR 0 1
12104: PUSH
12105: LD_INT 22
12107: PUSH
12108: LD_OWVAR 2
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 30
12119: PUSH
12120: LD_INT 3
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PPUSH
12131: CALL_OW 69
12135: ST_TO_ADDR
// if not tmp then
12136: LD_VAR 0 1
12140: NOT
12141: IFFALSE 12145
// exit ;
12143: GO 12171
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12145: LD_VAR 0 1
12149: PUSH
12150: LD_INT 1
12152: PPUSH
12153: LD_VAR 0 1
12157: PPUSH
12158: CALL_OW 12
12162: ARRAY
12163: PPUSH
12164: LD_INT 1
12166: PPUSH
12167: CALL_OW 234
// end ;
12171: PPOPN 1
12173: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
12174: LD_EXP 8
12178: PUSH
12179: LD_EXP 56
12183: AND
12184: IFFALSE 12296
12186: GO 12188
12188: DISABLE
12189: LD_INT 0
12191: PPUSH
12192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 22
12200: PUSH
12201: LD_OWVAR 2
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: LD_INT 2
12212: PUSH
12213: LD_INT 30
12215: PUSH
12216: LD_INT 27
12218: PUSH
12219: EMPTY
12220: LIST
12221: LIST
12222: PUSH
12223: LD_INT 30
12225: PUSH
12226: LD_INT 26
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 30
12235: PUSH
12236: LD_INT 28
12238: PUSH
12239: EMPTY
12240: LIST
12241: LIST
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: PPUSH
12253: CALL_OW 69
12257: ST_TO_ADDR
// if not tmp then
12258: LD_VAR 0 2
12262: NOT
12263: IFFALSE 12267
// exit ;
12265: GO 12296
// for i in tmp do
12267: LD_ADDR_VAR 0 1
12271: PUSH
12272: LD_VAR 0 2
12276: PUSH
12277: FOR_IN
12278: IFFALSE 12294
// SetLives ( i , 1 ) ;
12280: LD_VAR 0 1
12284: PPUSH
12285: LD_INT 1
12287: PPUSH
12288: CALL_OW 234
12292: GO 12277
12294: POP
12295: POP
// end ;
12296: PPOPN 2
12298: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
12299: LD_EXP 8
12303: PUSH
12304: LD_EXP 57
12308: AND
12309: IFFALSE 12583
12311: GO 12313
12313: DISABLE
12314: LD_INT 0
12316: PPUSH
12317: PPUSH
12318: PPUSH
// begin i := rand ( 1 , 7 ) ;
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 1
12326: PPUSH
12327: LD_INT 7
12329: PPUSH
12330: CALL_OW 12
12334: ST_TO_ADDR
// case i of 1 :
12335: LD_VAR 0 1
12339: PUSH
12340: LD_INT 1
12342: DOUBLE
12343: EQUAL
12344: IFTRUE 12348
12346: GO 12358
12348: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
12349: LD_STRING earthquake(getX(game), 0, 32)
12351: PPUSH
12352: CALL_OW 559
12356: GO 12583
12358: LD_INT 2
12360: DOUBLE
12361: EQUAL
12362: IFTRUE 12366
12364: GO 12380
12366: POP
// begin ToLua ( displayStucuk(); ) ;
12367: LD_STRING displayStucuk();
12369: PPUSH
12370: CALL_OW 559
// ResetFog ;
12374: CALL_OW 335
// end ; 3 :
12378: GO 12583
12380: LD_INT 3
12382: DOUBLE
12383: EQUAL
12384: IFTRUE 12388
12386: GO 12492
12388: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12389: LD_ADDR_VAR 0 2
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_OWVAR 2
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PUSH
12406: LD_INT 25
12408: PUSH
12409: LD_INT 1
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: PPUSH
12420: CALL_OW 69
12424: ST_TO_ADDR
// if not tmp then
12425: LD_VAR 0 2
12429: NOT
12430: IFFALSE 12434
// exit ;
12432: GO 12583
// un := tmp [ rand ( 1 , tmp ) ] ;
12434: LD_ADDR_VAR 0 3
12438: PUSH
12439: LD_VAR 0 2
12443: PUSH
12444: LD_INT 1
12446: PPUSH
12447: LD_VAR 0 2
12451: PPUSH
12452: CALL_OW 12
12456: ARRAY
12457: ST_TO_ADDR
// if Crawls ( un ) then
12458: LD_VAR 0 3
12462: PPUSH
12463: CALL_OW 318
12467: IFFALSE 12478
// ComWalk ( un ) ;
12469: LD_VAR 0 3
12473: PPUSH
12474: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12478: LD_VAR 0 3
12482: PPUSH
12483: LD_INT 8
12485: PPUSH
12486: CALL_OW 336
// end ; 4 :
12490: GO 12583
12492: LD_INT 4
12494: DOUBLE
12495: EQUAL
12496: IFTRUE 12500
12498: GO 12561
12500: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12501: LD_ADDR_VAR 0 2
12505: PUSH
12506: LD_INT 22
12508: PUSH
12509: LD_OWVAR 2
12513: PUSH
12514: EMPTY
12515: LIST
12516: LIST
12517: PUSH
12518: LD_INT 30
12520: PUSH
12521: LD_INT 29
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PPUSH
12532: CALL_OW 69
12536: ST_TO_ADDR
// if not tmp then
12537: LD_VAR 0 2
12541: NOT
12542: IFFALSE 12546
// exit ;
12544: GO 12583
// DestroyUnit ( tmp [ 1 ] ) ;
12546: LD_VAR 0 2
12550: PUSH
12551: LD_INT 1
12553: ARRAY
12554: PPUSH
12555: CALL_OW 65
// end ; 5 .. 7 :
12559: GO 12583
12561: LD_INT 5
12563: DOUBLE
12564: GREATEREQUAL
12565: IFFALSE 12573
12567: LD_INT 7
12569: DOUBLE
12570: LESSEQUAL
12571: IFTRUE 12575
12573: GO 12582
12575: POP
// StreamSibBomb ; end ;
12576: CALL 8833 0 0
12580: GO 12583
12582: POP
// end ;
12583: PPOPN 3
12585: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
12586: LD_EXP 8
12590: PUSH
12591: LD_EXP 58
12595: AND
12596: IFFALSE 12752
12598: GO 12600
12600: DISABLE
12601: LD_INT 0
12603: PPUSH
12604: PPUSH
12605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
12606: LD_ADDR_VAR 0 2
12610: PUSH
12611: LD_INT 81
12613: PUSH
12614: LD_OWVAR 2
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: PUSH
12623: LD_INT 2
12625: PUSH
12626: LD_INT 21
12628: PUSH
12629: LD_INT 1
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 21
12638: PUSH
12639: LD_INT 2
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: PPUSH
12655: CALL_OW 69
12659: ST_TO_ADDR
// if not tmp then
12660: LD_VAR 0 2
12664: NOT
12665: IFFALSE 12669
// exit ;
12667: GO 12752
// p := 0 ;
12669: LD_ADDR_VAR 0 3
12673: PUSH
12674: LD_INT 0
12676: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12677: LD_INT 35
12679: PPUSH
12680: CALL_OW 67
// p := p + 1 ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_VAR 0 3
12693: PUSH
12694: LD_INT 1
12696: PLUS
12697: ST_TO_ADDR
// for i in tmp do
12698: LD_ADDR_VAR 0 1
12702: PUSH
12703: LD_VAR 0 2
12707: PUSH
12708: FOR_IN
12709: IFFALSE 12740
// if GetLives ( i ) < 1000 then
12711: LD_VAR 0 1
12715: PPUSH
12716: CALL_OW 256
12720: PUSH
12721: LD_INT 1000
12723: LESS
12724: IFFALSE 12738
// SetLives ( i , 1000 ) ;
12726: LD_VAR 0 1
12730: PPUSH
12731: LD_INT 1000
12733: PPUSH
12734: CALL_OW 234
12738: GO 12708
12740: POP
12741: POP
// until p > 20 ;
12742: LD_VAR 0 3
12746: PUSH
12747: LD_INT 20
12749: GREATER
12750: IFFALSE 12677
// end ;
12752: PPOPN 3
12754: END
// every 0 0$1 trigger StreamModeActive and sTime do
12755: LD_EXP 8
12759: PUSH
12760: LD_EXP 59
12764: AND
12765: IFFALSE 12800
12767: GO 12769
12769: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
12770: LD_INT 28
12772: PPUSH
12773: LD_OWVAR 2
12777: PPUSH
12778: LD_INT 2
12780: PPUSH
12781: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
12785: LD_INT 30
12787: PPUSH
12788: LD_OWVAR 2
12792: PPUSH
12793: LD_INT 2
12795: PPUSH
12796: CALL_OW 322
// end ;
12800: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
12801: LD_EXP 8
12805: PUSH
12806: LD_EXP 60
12810: AND
12811: IFFALSE 12932
12813: GO 12815
12815: DISABLE
12816: LD_INT 0
12818: PPUSH
12819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12820: LD_ADDR_VAR 0 2
12824: PUSH
12825: LD_INT 22
12827: PUSH
12828: LD_OWVAR 2
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: LD_INT 21
12839: PUSH
12840: LD_INT 1
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: PUSH
12847: LD_INT 3
12849: PUSH
12850: LD_INT 23
12852: PUSH
12853: LD_INT 0
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: LIST
12868: PPUSH
12869: CALL_OW 69
12873: ST_TO_ADDR
// if not tmp then
12874: LD_VAR 0 2
12878: NOT
12879: IFFALSE 12883
// exit ;
12881: GO 12932
// for i in tmp do
12883: LD_ADDR_VAR 0 1
12887: PUSH
12888: LD_VAR 0 2
12892: PUSH
12893: FOR_IN
12894: IFFALSE 12930
// begin if Crawls ( i ) then
12896: LD_VAR 0 1
12900: PPUSH
12901: CALL_OW 318
12905: IFFALSE 12916
// ComWalk ( i ) ;
12907: LD_VAR 0 1
12911: PPUSH
12912: CALL_OW 138
// SetClass ( i , 2 ) ;
12916: LD_VAR 0 1
12920: PPUSH
12921: LD_INT 2
12923: PPUSH
12924: CALL_OW 336
// end ;
12928: GO 12893
12930: POP
12931: POP
// end ;
12932: PPOPN 2
12934: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
12935: LD_EXP 8
12939: PUSH
12940: LD_EXP 61
12944: AND
12945: IFFALSE 13226
12947: GO 12949
12949: DISABLE
12950: LD_INT 0
12952: PPUSH
12953: PPUSH
12954: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
12955: LD_OWVAR 2
12959: PPUSH
12960: LD_INT 9
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: LD_INT 1
12968: PPUSH
12969: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12973: LD_INT 9
12975: PPUSH
12976: LD_OWVAR 2
12980: PPUSH
12981: CALL_OW 343
// uc_side := 9 ;
12985: LD_ADDR_OWVAR 20
12989: PUSH
12990: LD_INT 9
12992: ST_TO_ADDR
// uc_nation := 2 ;
12993: LD_ADDR_OWVAR 21
12997: PUSH
12998: LD_INT 2
13000: ST_TO_ADDR
// hc_name := Dark Warrior ;
13001: LD_ADDR_OWVAR 26
13005: PUSH
13006: LD_STRING Dark Warrior
13008: ST_TO_ADDR
// hc_gallery :=  ;
13009: LD_ADDR_OWVAR 33
13013: PUSH
13014: LD_STRING 
13016: ST_TO_ADDR
// hc_noskilllimit := true ;
13017: LD_ADDR_OWVAR 76
13021: PUSH
13022: LD_INT 1
13024: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
13025: LD_ADDR_OWVAR 31
13029: PUSH
13030: LD_INT 30
13032: PUSH
13033: LD_INT 30
13035: PUSH
13036: LD_INT 30
13038: PUSH
13039: LD_INT 30
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: LIST
13046: LIST
13047: ST_TO_ADDR
// un := CreateHuman ;
13048: LD_ADDR_VAR 0 3
13052: PUSH
13053: CALL_OW 44
13057: ST_TO_ADDR
// hc_noskilllimit := false ;
13058: LD_ADDR_OWVAR 76
13062: PUSH
13063: LD_INT 0
13065: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
13066: LD_VAR 0 3
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 51
// p := 0 ;
13078: LD_ADDR_VAR 0 2
13082: PUSH
13083: LD_INT 0
13085: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13086: LD_INT 35
13088: PPUSH
13089: CALL_OW 67
// p := p + 1 ;
13093: LD_ADDR_VAR 0 2
13097: PUSH
13098: LD_VAR 0 2
13102: PUSH
13103: LD_INT 1
13105: PLUS
13106: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
13107: LD_VAR 0 3
13111: PPUSH
13112: CALL_OW 256
13116: PUSH
13117: LD_INT 1000
13119: LESS
13120: IFFALSE 13134
// SetLives ( un , 1000 ) ;
13122: LD_VAR 0 3
13126: PPUSH
13127: LD_INT 1000
13129: PPUSH
13130: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
13134: LD_VAR 0 3
13138: PPUSH
13139: LD_INT 81
13141: PUSH
13142: LD_OWVAR 2
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: PUSH
13151: LD_INT 91
13153: PUSH
13154: LD_VAR 0 3
13158: PUSH
13159: LD_INT 30
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PPUSH
13171: CALL_OW 69
13175: PPUSH
13176: LD_VAR 0 3
13180: PPUSH
13181: CALL_OW 74
13185: PPUSH
13186: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
13190: LD_VAR 0 2
13194: PUSH
13195: LD_INT 60
13197: GREATER
13198: PUSH
13199: LD_VAR 0 3
13203: PPUSH
13204: CALL_OW 301
13208: OR
13209: IFFALSE 13086
// if un then
13211: LD_VAR 0 3
13215: IFFALSE 13226
// RemoveUnit ( un ) ;
13217: LD_VAR 0 3
13221: PPUSH
13222: CALL_OW 64
// end ;
13226: PPOPN 3
13228: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
13229: LD_INT 0
13231: PPUSH
13232: PPUSH
13233: PPUSH
13234: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 22
13242: PUSH
13243: LD_OWVAR 2
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 2
13254: PUSH
13255: LD_INT 30
13257: PUSH
13258: LD_INT 0
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: PUSH
13265: LD_INT 30
13267: PUSH
13268: LD_INT 1
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: LIST
13279: PUSH
13280: EMPTY
13281: LIST
13282: LIST
13283: PPUSH
13284: CALL_OW 69
13288: ST_TO_ADDR
// if not tmp then
13289: LD_VAR 0 4
13293: NOT
13294: IFFALSE 13298
// exit ;
13296: GO 13357
// for i in tmp do
13298: LD_ADDR_VAR 0 2
13302: PUSH
13303: LD_VAR 0 4
13307: PUSH
13308: FOR_IN
13309: IFFALSE 13355
// for j = 1 to 3 do
13311: LD_ADDR_VAR 0 3
13315: PUSH
13316: DOUBLE
13317: LD_INT 1
13319: DEC
13320: ST_TO_ADDR
13321: LD_INT 3
13323: PUSH
13324: FOR_TO
13325: IFFALSE 13351
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
13327: LD_VAR 0 2
13331: PPUSH
13332: CALL_OW 274
13336: PPUSH
13337: LD_VAR 0 3
13341: PPUSH
13342: LD_INT 99999
13344: PPUSH
13345: CALL_OW 277
13349: GO 13324
13351: POP
13352: POP
13353: GO 13308
13355: POP
13356: POP
// end ;
13357: LD_VAR 0 1
13361: RET
// export function hHackSetLevel10 ; var i , j ; begin
13362: LD_INT 0
13364: PPUSH
13365: PPUSH
13366: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
13367: LD_ADDR_VAR 0 2
13371: PUSH
13372: LD_INT 21
13374: PUSH
13375: LD_INT 1
13377: PUSH
13378: EMPTY
13379: LIST
13380: LIST
13381: PPUSH
13382: CALL_OW 69
13386: PUSH
13387: FOR_IN
13388: IFFALSE 13440
// if IsSelected ( i ) then
13390: LD_VAR 0 2
13394: PPUSH
13395: CALL_OW 306
13399: IFFALSE 13438
// begin for j := 1 to 4 do
13401: LD_ADDR_VAR 0 3
13405: PUSH
13406: DOUBLE
13407: LD_INT 1
13409: DEC
13410: ST_TO_ADDR
13411: LD_INT 4
13413: PUSH
13414: FOR_TO
13415: IFFALSE 13436
// SetSkill ( i , j , 10 ) ;
13417: LD_VAR 0 2
13421: PPUSH
13422: LD_VAR 0 3
13426: PPUSH
13427: LD_INT 10
13429: PPUSH
13430: CALL_OW 237
13434: GO 13414
13436: POP
13437: POP
// end ;
13438: GO 13387
13440: POP
13441: POP
// end ;
13442: LD_VAR 0 1
13446: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
13447: LD_INT 0
13449: PPUSH
13450: PPUSH
13451: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
13452: LD_ADDR_VAR 0 2
13456: PUSH
13457: LD_INT 22
13459: PUSH
13460: LD_OWVAR 2
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: LD_INT 21
13471: PUSH
13472: LD_INT 1
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 69
13487: PUSH
13488: FOR_IN
13489: IFFALSE 13530
// begin for j := 1 to 4 do
13491: LD_ADDR_VAR 0 3
13495: PUSH
13496: DOUBLE
13497: LD_INT 1
13499: DEC
13500: ST_TO_ADDR
13501: LD_INT 4
13503: PUSH
13504: FOR_TO
13505: IFFALSE 13526
// SetSkill ( i , j , 10 ) ;
13507: LD_VAR 0 2
13511: PPUSH
13512: LD_VAR 0 3
13516: PPUSH
13517: LD_INT 10
13519: PPUSH
13520: CALL_OW 237
13524: GO 13504
13526: POP
13527: POP
// end ;
13528: GO 13488
13530: POP
13531: POP
// end ;
13532: LD_VAR 0 1
13536: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
13537: LD_INT 0
13539: PPUSH
// uc_side := your_side ;
13540: LD_ADDR_OWVAR 20
13544: PUSH
13545: LD_OWVAR 2
13549: ST_TO_ADDR
// uc_nation := nation ;
13550: LD_ADDR_OWVAR 21
13554: PUSH
13555: LD_VAR 0 1
13559: ST_TO_ADDR
// InitHc ;
13560: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
13564: LD_INT 0
13566: PPUSH
13567: LD_VAR 0 2
13571: PPUSH
13572: LD_VAR 0 3
13576: PPUSH
13577: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
13581: CALL_OW 44
13585: PPUSH
13586: LD_INT 1
13588: PPUSH
13589: CALL_OW 51
// end ;
13593: LD_VAR 0 4
13597: RET
// export function hHackSpawnVehicle ; begin
13598: LD_INT 0
13600: PPUSH
// uc_side := your_side ;
13601: LD_ADDR_OWVAR 20
13605: PUSH
13606: LD_OWVAR 2
13610: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
13611: LD_ADDR_OWVAR 21
13615: PUSH
13616: LD_INT 1
13618: PPUSH
13619: LD_INT 3
13621: PPUSH
13622: CALL_OW 12
13626: ST_TO_ADDR
// InitVc ;
13627: CALL_OW 20
// case uc_nation of 1 :
13631: LD_OWVAR 21
13635: PUSH
13636: LD_INT 1
13638: DOUBLE
13639: EQUAL
13640: IFTRUE 13644
13642: GO 13788
13644: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
13645: LD_ADDR_OWVAR 37
13649: PUSH
13650: LD_INT 1
13652: PUSH
13653: LD_INT 2
13655: PUSH
13656: LD_INT 3
13658: PUSH
13659: LD_INT 4
13661: PUSH
13662: LD_INT 5
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: LIST
13671: PUSH
13672: LD_INT 1
13674: PPUSH
13675: LD_INT 5
13677: PPUSH
13678: CALL_OW 12
13682: ARRAY
13683: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
13684: LD_ADDR_OWVAR 39
13688: PUSH
13689: LD_INT 1
13691: PPUSH
13692: LD_INT 3
13694: PPUSH
13695: CALL_OW 12
13699: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
13700: LD_ADDR_OWVAR 38
13704: PUSH
13705: LD_INT 1
13707: PUSH
13708: LD_INT 2
13710: PUSH
13711: LD_INT 3
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: LIST
13718: PUSH
13719: LD_INT 1
13721: PPUSH
13722: LD_INT 3
13724: PPUSH
13725: CALL_OW 12
13729: ARRAY
13730: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
13731: LD_ADDR_OWVAR 40
13735: PUSH
13736: LD_INT 2
13738: PUSH
13739: LD_INT 4
13741: PUSH
13742: LD_INT 5
13744: PUSH
13745: LD_INT 3
13747: PUSH
13748: LD_INT 7
13750: PUSH
13751: LD_INT 8
13753: PUSH
13754: LD_INT 9
13756: PUSH
13757: LD_INT 10
13759: PUSH
13760: LD_INT 6
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: PUSH
13774: LD_INT 1
13776: PPUSH
13777: LD_INT 9
13779: PPUSH
13780: CALL_OW 12
13784: ARRAY
13785: ST_TO_ADDR
// end ; 2 :
13786: GO 14053
13788: LD_INT 2
13790: DOUBLE
13791: EQUAL
13792: IFTRUE 13796
13794: GO 13920
13796: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
13797: LD_ADDR_OWVAR 37
13801: PUSH
13802: LD_INT 11
13804: PUSH
13805: LD_INT 12
13807: PUSH
13808: LD_INT 13
13810: PUSH
13811: LD_INT 14
13813: PUSH
13814: EMPTY
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 1
13822: PPUSH
13823: LD_INT 4
13825: PPUSH
13826: CALL_OW 12
13830: ARRAY
13831: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
13832: LD_ADDR_OWVAR 39
13836: PUSH
13837: LD_INT 1
13839: PPUSH
13840: LD_INT 3
13842: PPUSH
13843: CALL_OW 12
13847: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
13848: LD_ADDR_OWVAR 38
13852: PUSH
13853: LD_INT 1
13855: PUSH
13856: LD_INT 2
13858: PUSH
13859: LD_INT 5
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: LIST
13866: PUSH
13867: LD_INT 1
13869: PPUSH
13870: LD_INT 3
13872: PPUSH
13873: CALL_OW 12
13877: ARRAY
13878: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
13879: LD_ADDR_OWVAR 40
13883: PUSH
13884: LD_INT 24
13886: PUSH
13887: LD_INT 26
13889: PUSH
13890: LD_INT 27
13892: PUSH
13893: LD_INT 28
13895: PUSH
13896: LD_INT 29
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: PUSH
13906: LD_INT 1
13908: PPUSH
13909: LD_INT 5
13911: PPUSH
13912: CALL_OW 12
13916: ARRAY
13917: ST_TO_ADDR
// end ; 3 :
13918: GO 14053
13920: LD_INT 3
13922: DOUBLE
13923: EQUAL
13924: IFTRUE 13928
13926: GO 14052
13928: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
13929: LD_ADDR_OWVAR 37
13933: PUSH
13934: LD_INT 21
13936: PUSH
13937: LD_INT 23
13939: PUSH
13940: LD_INT 22
13942: PUSH
13943: LD_INT 24
13945: PUSH
13946: EMPTY
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 1
13954: PPUSH
13955: LD_INT 4
13957: PPUSH
13958: CALL_OW 12
13962: ARRAY
13963: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
13964: LD_ADDR_OWVAR 39
13968: PUSH
13969: LD_INT 1
13971: PPUSH
13972: LD_INT 3
13974: PPUSH
13975: CALL_OW 12
13979: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
13980: LD_ADDR_OWVAR 38
13984: PUSH
13985: LD_INT 1
13987: PUSH
13988: LD_INT 3
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 2
14000: PPUSH
14001: CALL_OW 12
14005: ARRAY
14006: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
14007: LD_ADDR_OWVAR 40
14011: PUSH
14012: LD_INT 42
14014: PUSH
14015: LD_INT 43
14017: PUSH
14018: LD_INT 44
14020: PUSH
14021: LD_INT 46
14023: PUSH
14024: LD_INT 48
14026: PUSH
14027: LD_INT 47
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: PUSH
14038: LD_INT 1
14040: PPUSH
14041: LD_INT 6
14043: PPUSH
14044: CALL_OW 12
14048: ARRAY
14049: ST_TO_ADDR
// end ; end ;
14050: GO 14053
14052: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
14053: CALL_OW 45
14057: PPUSH
14058: LD_INT 1
14060: PPUSH
14061: CALL_OW 51
// end ;
14065: LD_VAR 0 1
14069: RET
// export hInvincible ; every 1 do
14070: GO 14072
14072: DISABLE
// hInvincible := [ ] ;
14073: LD_ADDR_EXP 62
14077: PUSH
14078: EMPTY
14079: ST_TO_ADDR
14080: END
// every 10 do var i ;
14081: GO 14083
14083: DISABLE
14084: LD_INT 0
14086: PPUSH
// begin enable ;
14087: ENABLE
// if not hInvincible then
14088: LD_EXP 62
14092: NOT
14093: IFFALSE 14097
// exit ;
14095: GO 14141
// for i in hInvincible do
14097: LD_ADDR_VAR 0 1
14101: PUSH
14102: LD_EXP 62
14106: PUSH
14107: FOR_IN
14108: IFFALSE 14139
// if GetLives ( i ) < 1000 then
14110: LD_VAR 0 1
14114: PPUSH
14115: CALL_OW 256
14119: PUSH
14120: LD_INT 1000
14122: LESS
14123: IFFALSE 14137
// SetLives ( i , 1000 ) ;
14125: LD_VAR 0 1
14129: PPUSH
14130: LD_INT 1000
14132: PPUSH
14133: CALL_OW 234
14137: GO 14107
14139: POP
14140: POP
// end ;
14141: PPOPN 1
14143: END
// export function hHackInvincible ; var i ; begin
14144: LD_INT 0
14146: PPUSH
14147: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: PUSH
14156: LD_INT 21
14158: PUSH
14159: LD_INT 1
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PUSH
14166: LD_INT 21
14168: PUSH
14169: LD_INT 2
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: LIST
14180: PPUSH
14181: CALL_OW 69
14185: PUSH
14186: FOR_IN
14187: IFFALSE 14248
// if IsSelected ( i ) then
14189: LD_VAR 0 2
14193: PPUSH
14194: CALL_OW 306
14198: IFFALSE 14246
// begin if i in hInvincible then
14200: LD_VAR 0 2
14204: PUSH
14205: LD_EXP 62
14209: IN
14210: IFFALSE 14230
// hInvincible := hInvincible diff i else
14212: LD_ADDR_EXP 62
14216: PUSH
14217: LD_EXP 62
14221: PUSH
14222: LD_VAR 0 2
14226: DIFF
14227: ST_TO_ADDR
14228: GO 14246
// hInvincible := hInvincible union i ;
14230: LD_ADDR_EXP 62
14234: PUSH
14235: LD_EXP 62
14239: PUSH
14240: LD_VAR 0 2
14244: UNION
14245: ST_TO_ADDR
// end ;
14246: GO 14186
14248: POP
14249: POP
// end ;
14250: LD_VAR 0 1
14254: RET
// export function hHackInvisible ; var i , j ; begin
14255: LD_INT 0
14257: PPUSH
14258: PPUSH
14259: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
14260: LD_ADDR_VAR 0 2
14264: PUSH
14265: LD_INT 21
14267: PUSH
14268: LD_INT 1
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PPUSH
14275: CALL_OW 69
14279: PUSH
14280: FOR_IN
14281: IFFALSE 14305
// if IsSelected ( i ) then
14283: LD_VAR 0 2
14287: PPUSH
14288: CALL_OW 306
14292: IFFALSE 14303
// ComForceInvisible ( i ) ;
14294: LD_VAR 0 2
14298: PPUSH
14299: CALL_OW 496
14303: GO 14280
14305: POP
14306: POP
// end ;
14307: LD_VAR 0 1
14311: RET
// export function hHackChangeYourSide ; begin
14312: LD_INT 0
14314: PPUSH
// if your_side = 8 then
14315: LD_OWVAR 2
14319: PUSH
14320: LD_INT 8
14322: EQUAL
14323: IFFALSE 14335
// your_side := 0 else
14325: LD_ADDR_OWVAR 2
14329: PUSH
14330: LD_INT 0
14332: ST_TO_ADDR
14333: GO 14349
// your_side := your_side + 1 ;
14335: LD_ADDR_OWVAR 2
14339: PUSH
14340: LD_OWVAR 2
14344: PUSH
14345: LD_INT 1
14347: PLUS
14348: ST_TO_ADDR
// end ;
14349: LD_VAR 0 1
14353: RET
// export function hHackChangeUnitSide ; var i , j ; begin
14354: LD_INT 0
14356: PPUSH
14357: PPUSH
14358: PPUSH
// for i in all_units do
14359: LD_ADDR_VAR 0 2
14363: PUSH
14364: LD_OWVAR 3
14368: PUSH
14369: FOR_IN
14370: IFFALSE 14448
// if IsSelected ( i ) then
14372: LD_VAR 0 2
14376: PPUSH
14377: CALL_OW 306
14381: IFFALSE 14446
// begin j := GetSide ( i ) ;
14383: LD_ADDR_VAR 0 3
14387: PUSH
14388: LD_VAR 0 2
14392: PPUSH
14393: CALL_OW 255
14397: ST_TO_ADDR
// if j = 8 then
14398: LD_VAR 0 3
14402: PUSH
14403: LD_INT 8
14405: EQUAL
14406: IFFALSE 14418
// j := 0 else
14408: LD_ADDR_VAR 0 3
14412: PUSH
14413: LD_INT 0
14415: ST_TO_ADDR
14416: GO 14432
// j := j + 1 ;
14418: LD_ADDR_VAR 0 3
14422: PUSH
14423: LD_VAR 0 3
14427: PUSH
14428: LD_INT 1
14430: PLUS
14431: ST_TO_ADDR
// SetSide ( i , j ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: LD_VAR 0 3
14441: PPUSH
14442: CALL_OW 235
// end ;
14446: GO 14369
14448: POP
14449: POP
// end ;
14450: LD_VAR 0 1
14454: RET
// export function hHackFog ; begin
14455: LD_INT 0
14457: PPUSH
// FogOff ( true ) ;
14458: LD_INT 1
14460: PPUSH
14461: CALL_OW 344
// end ;
14465: LD_VAR 0 1
14469: RET
// export function hHackApeman ; begin
14470: LD_INT 0
14472: PPUSH
// uc_side := your_side ;
14473: LD_ADDR_OWVAR 20
14477: PUSH
14478: LD_OWVAR 2
14482: ST_TO_ADDR
// uc_nation := 0 ;
14483: LD_ADDR_OWVAR 21
14487: PUSH
14488: LD_INT 0
14490: ST_TO_ADDR
// hc_name :=  ;
14491: LD_ADDR_OWVAR 26
14495: PUSH
14496: LD_STRING 
14498: ST_TO_ADDR
// hc_gallery :=  ;
14499: LD_ADDR_OWVAR 33
14503: PUSH
14504: LD_STRING 
14506: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
14507: LD_ADDR_OWVAR 31
14511: PUSH
14512: LD_INT 0
14514: PUSH
14515: LD_INT 0
14517: PUSH
14518: LD_INT 0
14520: PUSH
14521: LD_INT 0
14523: PUSH
14524: EMPTY
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: ST_TO_ADDR
// hc_class := class_apeman ;
14530: LD_ADDR_OWVAR 28
14534: PUSH
14535: LD_INT 12
14537: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
14538: CALL_OW 44
14542: PPUSH
14543: LD_INT 1
14545: PPUSH
14546: CALL_OW 51
// end ;
14550: LD_VAR 0 1
14554: RET
// export function hHackBoom ; begin
14555: LD_INT 0
14557: PPUSH
// uc_side := your_side ;
14558: LD_ADDR_OWVAR 20
14562: PUSH
14563: LD_OWVAR 2
14567: ST_TO_ADDR
// uc_nation := 1 ;
14568: LD_ADDR_OWVAR 21
14572: PUSH
14573: LD_INT 1
14575: ST_TO_ADDR
// vc_chassis := us_morphling ;
14576: LD_ADDR_OWVAR 37
14580: PUSH
14581: LD_INT 5
14583: ST_TO_ADDR
// vc_engine := engine_siberite ;
14584: LD_ADDR_OWVAR 39
14588: PUSH
14589: LD_INT 3
14591: ST_TO_ADDR
// vc_control := control_computer ;
14592: LD_ADDR_OWVAR 38
14596: PUSH
14597: LD_INT 3
14599: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
14600: LD_ADDR_OWVAR 40
14604: PUSH
14605: LD_INT 8
14607: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
14608: CALL_OW 45
14612: PPUSH
14613: LD_INT 1
14615: PPUSH
14616: CALL_OW 51
// end ;
14620: LD_VAR 0 1
14624: RET
