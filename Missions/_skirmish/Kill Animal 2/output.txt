// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 136 , 106 ) ;
   4: LD_INT 136
   6: PPUSH
   7: LD_INT 106
   9: PPUSH
  10: CALL_OW 86
// Init ;
  14: CALL 75 0 0
// PrepareNature ( nat_area , wat_area , [ 10 , 2 * Difficulty , 6 , 6 , 3 * Difficulty , 6 , 4 ] ) ;
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 10
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: LD_OWVAR 67
  34: MUL
  35: PUSH
  36: LD_INT 6
  38: PUSH
  39: LD_INT 6
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: LD_OWVAR 67
  49: MUL
  50: PUSH
  51: LD_INT 6
  53: PUSH
  54: LD_INT 4
  56: PUSH
  57: EMPTY
  58: LIST
  59: LIST
  60: LIST
  61: LIST
  62: LIST
  63: LIST
  64: LIST
  65: PPUSH
  66: CALL 395 0 3
// PrepareHunters ( ) ;
  70: CALL 241 0 0
// end ;
  74: END
// export debug , hunterClass , huntersAmount , animalAmount ; export class_horse ; export points , hunters ; function Init ; begin
  75: LD_INT 0
  77: PPUSH
// debug := 0 ;
  78: LD_ADDR_EXP 1
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// class_horse := 21 ;
  86: LD_ADDR_EXP 5
  90: PUSH
  91: LD_INT 21
  93: ST_TO_ADDR
// if debug then
  94: LD_EXP 1
  98: IFFALSE 133
// begin FogOff ( 1 ) ;
 100: LD_INT 1
 102: PPUSH
 103: CALL_OW 344
// Difficulty := 2 ;
 107: LD_ADDR_OWVAR 67
 111: PUSH
 112: LD_INT 2
 114: ST_TO_ADDR
// hunterClass := 3 ;
 115: LD_ADDR_EXP 2
 119: PUSH
 120: LD_INT 3
 122: ST_TO_ADDR
// animalAmount := 2 ;
 123: LD_ADDR_EXP 4
 127: PUSH
 128: LD_INT 2
 130: ST_TO_ADDR
// end else
 131: GO 172
// begin Difficulty := GetMultiplayerSetting ( 0 ) ;
 133: LD_ADDR_OWVAR 67
 137: PUSH
 138: LD_INT 0
 140: PPUSH
 141: CALL_OW 426
 145: ST_TO_ADDR
// hunterClass := GetMultiplayerSetting ( 2 ) ;
 146: LD_ADDR_EXP 2
 150: PUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL_OW 426
 158: ST_TO_ADDR
// animalAmount := GetMultiplayerSetting ( 1 ) ;
 159: LD_ADDR_EXP 4
 163: PUSH
 164: LD_INT 1
 166: PPUSH
 167: CALL_OW 426
 171: ST_TO_ADDR
// end ; huntersAmount := [ 4 , 6 , 8 ] [ Difficulty ] ;
 172: LD_ADDR_EXP 3
 176: PUSH
 177: LD_INT 4
 179: PUSH
 180: LD_INT 6
 182: PUSH
 183: LD_INT 8
 185: PUSH
 186: EMPTY
 187: LIST
 188: LIST
 189: LIST
 190: PUSH
 191: LD_OWVAR 67
 195: ARRAY
 196: ST_TO_ADDR
// points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 197: LD_ADDR_EXP 6
 201: PUSH
 202: LD_INT 0
 204: PUSH
 205: LD_INT 0
 207: PUSH
 208: LD_INT 0
 210: PUSH
 211: LD_INT 0
 213: PUSH
 214: LD_INT 0
 216: PUSH
 217: LD_INT 0
 219: PUSH
 220: LD_INT 0
 222: PUSH
 223: LD_INT 0
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// end ;
 236: LD_VAR 0 1
 240: RET
// export function PrepareHunters ; var i , un ; begin
 241: LD_INT 0
 243: PPUSH
 244: PPUSH
 245: PPUSH
// for i := 1 to huntersAmount do
 246: LD_ADDR_VAR 0 2
 250: PUSH
 251: DOUBLE
 252: LD_INT 1
 254: DEC
 255: ST_TO_ADDR
 256: LD_EXP 3
 260: PUSH
 261: FOR_TO
 262: IFFALSE 388
// begin uc_side := i ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// uc_nation := i mod 3 + 1 ;
 274: LD_ADDR_OWVAR 21
 278: PUSH
 279: LD_VAR 0 2
 283: PUSH
 284: LD_INT 3
 286: MOD
 287: PUSH
 288: LD_INT 1
 290: PLUS
 291: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_sniper , class_desert_warior ] [ hunterClass ] , 10 - Difficulty * 2 ) ;
 292: LD_INT 0
 294: PPUSH
 295: LD_INT 1
 297: PUSH
 298: LD_INT 5
 300: PUSH
 301: LD_INT 11
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: LIST
 308: PUSH
 309: LD_EXP 2
 313: ARRAY
 314: PPUSH
 315: LD_INT 10
 317: PUSH
 318: LD_OWVAR 67
 322: PUSH
 323: LD_INT 2
 325: MUL
 326: MINUS
 327: PPUSH
 328: CALL_OW 380
// un := CreateHuman ;
 332: LD_ADDR_VAR 0 3
 336: PUSH
 337: CALL_OW 44
 341: ST_TO_ADDR
// hunters := Replace ( hunters , hunters + 1 , un ) ;
 342: LD_ADDR_EXP 7
 346: PUSH
 347: LD_EXP 7
 351: PPUSH
 352: LD_EXP 7
 356: PUSH
 357: LD_INT 1
 359: PLUS
 360: PPUSH
 361: LD_VAR 0 3
 365: PPUSH
 366: CALL_OW 1
 370: ST_TO_ADDR
// PlaceUnitArea ( un , startArea , false ) ;
 371: LD_VAR 0 3
 375: PPUSH
 376: LD_INT 3
 378: PPUSH
 379: LD_INT 0
 381: PPUSH
 382: CALL_OW 49
// end ;
 386: GO 261
 388: POP
 389: POP
// end ; end_of_file
 390: LD_VAR 0 1
 394: RET
// export function PrepareNature ( area , waterArea , numbers ) ; var i , j , classes , waterClass ; begin
 395: LD_INT 0
 397: PPUSH
 398: PPUSH
 399: PPUSH
 400: PPUSH
 401: PPUSH
// uc_side = 0 ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// uc_nation = 0 ;
 410: LD_ADDR_OWVAR 21
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// classes := [ class_apeman , class_apeman_soldier , class_baggie , class_phororhacos , class_tiger , class_horse ] ;
 418: LD_ADDR_VAR 0 7
 422: PUSH
 423: LD_INT 12
 425: PUSH
 426: LD_INT 15
 428: PUSH
 429: LD_INT 13
 431: PUSH
 432: LD_INT 18
 434: PUSH
 435: LD_INT 14
 437: PUSH
 438: LD_EXP 5
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: ST_TO_ADDR
// waterClass := [ class_fish ] ;
 451: LD_ADDR_VAR 0 8
 455: PUSH
 456: LD_INT 20
 458: PUSH
 459: EMPTY
 460: LIST
 461: ST_TO_ADDR
// InitHc_All ( ) ;
 462: CALL_OW 584
// for i := 1 to numbers - 2 do
 466: LD_ADDR_VAR 0 5
 470: PUSH
 471: DOUBLE
 472: LD_INT 1
 474: DEC
 475: ST_TO_ADDR
 476: LD_VAR 0 3
 480: PUSH
 481: LD_INT 2
 483: MINUS
 484: PUSH
 485: FOR_TO
 486: IFFALSE 627
// begin if numbers [ i ] = 0 then
 488: LD_VAR 0 3
 492: PUSH
 493: LD_VAR 0 5
 497: ARRAY
 498: PUSH
 499: LD_INT 0
 501: EQUAL
 502: IFFALSE 506
// continue ;
 504: GO 485
// hc_class := classes [ i ] ;
 506: LD_ADDR_OWVAR 28
 510: PUSH
 511: LD_VAR 0 7
 515: PUSH
 516: LD_VAR 0 5
 520: ARRAY
 521: ST_TO_ADDR
// hc_attr := [ rand ( 8 , 12 ) , rand ( 8 , 12 ) ] ;
 522: LD_ADDR_OWVAR 29
 526: PUSH
 527: LD_INT 8
 529: PPUSH
 530: LD_INT 12
 532: PPUSH
 533: CALL_OW 12
 537: PUSH
 538: LD_INT 8
 540: PPUSH
 541: LD_INT 12
 543: PPUSH
 544: CALL_OW 12
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) + Difficulty * 5 ;
 553: LD_ADDR_OWVAR 35
 557: PUSH
 558: LD_INT 5
 560: NEG
 561: PPUSH
 562: LD_INT 5
 564: PPUSH
 565: CALL_OW 12
 569: PUSH
 570: LD_OWVAR 67
 574: PUSH
 575: LD_INT 5
 577: MUL
 578: PLUS
 579: ST_TO_ADDR
// for j := 1 to numbers [ i ] do
 580: LD_ADDR_VAR 0 6
 584: PUSH
 585: DOUBLE
 586: LD_INT 1
 588: DEC
 589: ST_TO_ADDR
 590: LD_VAR 0 3
 594: PUSH
 595: LD_VAR 0 5
 599: ARRAY
 600: PUSH
 601: FOR_TO
 602: IFFALSE 623
// PlaceUnitArea ( CreateHuman , area , false ) ;
 604: CALL_OW 44
 608: PPUSH
 609: LD_VAR 0 1
 613: PPUSH
 614: LD_INT 0
 616: PPUSH
 617: CALL_OW 49
 621: GO 601
 623: POP
 624: POP
// end ;
 625: GO 485
 627: POP
 628: POP
// if not waterArea then
 629: LD_VAR 0 2
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 718
// hc_class := waterClass [ 1 ] ;
 638: LD_ADDR_OWVAR 28
 642: PUSH
 643: LD_VAR 0 8
 647: PUSH
 648: LD_INT 1
 650: ARRAY
 651: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 652: LD_ADDR_OWVAR 29
 656: PUSH
 657: LD_INT 10
 659: PUSH
 660: LD_INT 10
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: ST_TO_ADDR
// hc_agressivity := 0 ;
 667: LD_ADDR_OWVAR 35
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// for j := 1 to numbers [ 7 ] do
 675: LD_ADDR_VAR 0 6
 679: PUSH
 680: DOUBLE
 681: LD_INT 1
 683: DEC
 684: ST_TO_ADDR
 685: LD_VAR 0 3
 689: PUSH
 690: LD_INT 7
 692: ARRAY
 693: PUSH
 694: FOR_TO
 695: IFFALSE 716
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 697: CALL_OW 44
 701: PPUSH
 702: LD_VAR 0 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
 714: GO 694
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 4
 722: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do var i ;
 723: LD_INT 22
 725: PUSH
 726: LD_INT 0
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: PUSH
 733: LD_INT 25
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: PPUSH
 747: CALL_OW 69
 751: IFFALSE 857
 753: GO 755
 755: DISABLE
 756: LD_INT 0
 758: PPUSH
// begin enable ;
 759: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do
 760: LD_ADDR_VAR 0 1
 764: PUSH
 765: LD_INT 22
 767: PUSH
 768: LD_INT 0
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: PUSH
 775: LD_INT 25
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PPUSH
 789: CALL_OW 69
 793: PUSH
 794: FOR_IN
 795: IFFALSE 855
// if GetLives ( i ) < 1000 then
 797: LD_VAR 0 1
 801: PPUSH
 802: CALL_OW 256
 806: PUSH
 807: LD_INT 1000
 809: LESS
 810: IFFALSE 853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , i ) ) ;
 812: LD_VAR 0 1
 816: PPUSH
 817: LD_INT 3
 819: PUSH
 820: LD_INT 22
 822: PUSH
 823: LD_INT 0
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: LD_VAR 0 1
 843: PPUSH
 844: CALL_OW 74
 848: PPUSH
 849: CALL_OW 115
 853: GO 794
 855: POP
 856: POP
// end ;
 857: PPOPN 1
 859: END
// every 3 do var i , enemy , x , y , d ;
 860: GO 862
 862: DISABLE
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
 867: PPUSH
 868: PPUSH
 869: PPUSH
// begin enable ;
 870: ENABLE
// for i := 2 to huntersAmount do
 871: LD_ADDR_VAR 0 1
 875: PUSH
 876: DOUBLE
 877: LD_INT 2
 879: DEC
 880: ST_TO_ADDR
 881: LD_EXP 3
 885: PUSH
 886: FOR_TO
 887: IFFALSE 1226
// begin if not HasTask ( hunters [ i ] ) then
 889: LD_EXP 7
 893: PUSH
 894: LD_VAR 0 1
 898: ARRAY
 899: PPUSH
 900: CALL_OW 314
 904: NOT
 905: IFFALSE 1224
// begin enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 0 ] ) , hunters [ i ] ) ;
 907: LD_ADDR_VAR 0 2
 911: PUSH
 912: LD_INT 22
 914: PUSH
 915: LD_INT 0
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: PPUSH
 922: CALL_OW 69
 926: PPUSH
 927: LD_EXP 7
 931: PUSH
 932: LD_VAR 0 1
 936: ARRAY
 937: PPUSH
 938: CALL_OW 74
 942: ST_TO_ADDR
// if not enemy then
 943: LD_VAR 0 2
 947: NOT
 948: IFFALSE 952
// continue ;
 950: GO 886
// if GetDistUnits ( hunters [ i ] , enemy ) < 17 then
 952: LD_EXP 7
 956: PUSH
 957: LD_VAR 0 1
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 2
 967: PPUSH
 968: CALL_OW 296
 972: PUSH
 973: LD_INT 17
 975: LESS
 976: IFFALSE 1079
// begin if GetClass ( hunters [ i ] ) = class_desert_warior then
 978: LD_EXP 7
 982: PUSH
 983: LD_VAR 0 1
 987: ARRAY
 988: PPUSH
 989: CALL_OW 257
 993: PUSH
 994: LD_INT 11
 996: EQUAL
 997: IFFALSE 1057
// if GetClass ( enemy ) in [ class_frog , class_fish , class_baggie ] then
 999: LD_VAR 0 2
1003: PPUSH
1004: CALL_OW 257
1008: PUSH
1009: LD_INT 19
1011: PUSH
1012: LD_INT 20
1014: PUSH
1015: LD_INT 13
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: IN
1023: IFFALSE 1042
// ComCarabine ( hunters [ i ] ) else
1025: LD_EXP 7
1029: PUSH
1030: LD_VAR 0 1
1034: ARRAY
1035: PPUSH
1036: CALL_OW 162
1040: GO 1057
// ComSabre ( hunters [ i ] ) ;
1042: LD_EXP 7
1046: PUSH
1047: LD_VAR 0 1
1051: ARRAY
1052: PPUSH
1053: CALL_OW 163
// ComAttackUnit ( hunters [ i ] , enemy ) ;
1057: LD_EXP 7
1061: PUSH
1062: LD_VAR 0 1
1066: ARRAY
1067: PPUSH
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 115
// end else
1077: GO 1224
// begin d := rand ( 0 , 5 ) ;
1079: LD_ADDR_VAR 0 5
1083: PUSH
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 5
1089: PPUSH
1090: CALL_OW 12
1094: ST_TO_ADDR
// x := ShiftX ( GetX ( hunters [ i ] ) , d , 8 ) ;
1095: LD_ADDR_VAR 0 3
1099: PUSH
1100: LD_EXP 7
1104: PUSH
1105: LD_VAR 0 1
1109: ARRAY
1110: PPUSH
1111: CALL_OW 250
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: LD_INT 8
1123: PPUSH
1124: CALL_OW 272
1128: ST_TO_ADDR
// y := ShiftY ( GetY ( hunters [ i ] ) , d , 8 ) ;
1129: LD_ADDR_VAR 0 4
1133: PUSH
1134: LD_EXP 7
1138: PUSH
1139: LD_VAR 0 1
1143: ARRAY
1144: PPUSH
1145: CALL_OW 251
1149: PPUSH
1150: LD_VAR 0 5
1154: PPUSH
1155: LD_INT 8
1157: PPUSH
1158: CALL_OW 273
1162: ST_TO_ADDR
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
1163: LD_VAR 0 3
1167: PPUSH
1168: LD_VAR 0 4
1172: PPUSH
1173: CALL_OW 488
1177: PUSH
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_VAR 0 4
1187: PPUSH
1188: CALL_OW 428
1192: PUSH
1193: LD_INT 0
1195: EQUAL
1196: AND
1197: IFFALSE 1224
// ComMoveXY ( hunters [ i ] , x , y ) ;
1199: LD_EXP 7
1203: PUSH
1204: LD_VAR 0 1
1208: ARRAY
1209: PPUSH
1210: LD_VAR 0 3
1214: PPUSH
1215: LD_VAR 0 4
1219: PPUSH
1220: CALL_OW 111
// end ; end ; end ;
1224: GO 886
1226: POP
1227: POP
// end ; end_of_file
1228: PPOPN 5
1230: END
// on UnitGoesToRed ( un ) do var i ;
1231: LD_INT 0
1233: PPUSH
// begin if GetSide ( un ) = 1 then
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 255
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1256
// YouLost ( hunt2 ) ;
1249: LD_STRING hunt2
1251: PPUSH
1252: CALL_OW 104
// if GetSide ( un ) > 1 then
1256: LD_VAR 0 1
1260: PPUSH
1261: CALL_OW 255
1265: PUSH
1266: LD_INT 1
1268: GREATER
1269: IFFALSE 1322
// begin for i := 1 to 6 do
1271: LD_ADDR_VAR 0 2
1275: PUSH
1276: DOUBLE
1277: LD_INT 1
1279: DEC
1280: ST_TO_ADDR
1281: LD_INT 6
1283: PUSH
1284: FOR_TO
1285: IFFALSE 1308
// begin wait ( 0 0$1 ) ;
1287: LD_INT 35
1289: PPUSH
1290: CALL_OW 67
// SetLives ( un , 249 ) ;
1294: LD_VAR 0 1
1298: PPUSH
1299: LD_INT 249
1301: PPUSH
1302: CALL_OW 234
// end ;
1306: GO 1284
1308: POP
1309: POP
// SetLives ( un , 1000 ) ;
1310: LD_VAR 0 1
1314: PPUSH
1315: LD_INT 1000
1317: PPUSH
1318: CALL_OW 234
// end ; end ;
1322: PPOPN 2
1324: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 > 1 then
1325: LD_VAR 0 1
1329: PUSH
1330: LD_INT 1
1332: EQUAL
1333: PUSH
1334: LD_VAR 0 2
1338: PUSH
1339: LD_INT 1
1341: GREATER
1342: AND
1343: IFFALSE 1352
// YouLost ( hunt1 ) ;
1345: LD_STRING hunt1
1347: PPUSH
1348: CALL_OW 104
// end ;
1352: PPOPN 2
1354: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do var point ;
1355: LD_INT 0
1357: PPUSH
// begin point := 0 ;
1358: LD_ADDR_VAR 0 4
1362: PUSH
1363: LD_INT 0
1365: ST_TO_ADDR
// case GetClass ( un ) of class_fish :
1366: LD_VAR 0 1
1370: PPUSH
1371: CALL_OW 257
1375: PUSH
1376: LD_INT 20
1378: DOUBLE
1379: EQUAL
1380: IFTRUE 1384
1382: GO 1395
1384: POP
// point := 10 ; class_horse :
1385: LD_ADDR_VAR 0 4
1389: PUSH
1390: LD_INT 10
1392: ST_TO_ADDR
1393: GO 1531
1395: LD_EXP 5
1399: DOUBLE
1400: EQUAL
1401: IFTRUE 1405
1403: GO 1416
1405: POP
// point := 10 ; class_baggie :
1406: LD_ADDR_VAR 0 4
1410: PUSH
1411: LD_INT 10
1413: ST_TO_ADDR
1414: GO 1531
1416: LD_INT 13
1418: DOUBLE
1419: EQUAL
1420: IFTRUE 1424
1422: GO 1435
1424: POP
// point := 5 ; class_phororhacos :
1425: LD_ADDR_VAR 0 4
1429: PUSH
1430: LD_INT 5
1432: ST_TO_ADDR
1433: GO 1531
1435: LD_INT 18
1437: DOUBLE
1438: EQUAL
1439: IFTRUE 1443
1441: GO 1454
1443: POP
// point := 10 ; class_tiger :
1444: LD_ADDR_VAR 0 4
1448: PUSH
1449: LD_INT 10
1451: ST_TO_ADDR
1452: GO 1531
1454: LD_INT 14
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1473
1462: POP
// point := 20 ; class_apeman :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 20
1470: ST_TO_ADDR
1471: GO 1531
1473: LD_INT 12
1475: DOUBLE
1476: EQUAL
1477: IFTRUE 1481
1479: GO 1492
1481: POP
// point := 30 ; class_apeman_soldier :
1482: LD_ADDR_VAR 0 4
1486: PUSH
1487: LD_INT 30
1489: ST_TO_ADDR
1490: GO 1531
1492: LD_INT 15
1494: DOUBLE
1495: EQUAL
1496: IFTRUE 1500
1498: GO 1511
1500: POP
// point := 50 ; class_frog :
1501: LD_ADDR_VAR 0 4
1505: PUSH
1506: LD_INT 50
1508: ST_TO_ADDR
1509: GO 1531
1511: LD_INT 19
1513: DOUBLE
1514: EQUAL
1515: IFTRUE 1519
1517: GO 1530
1519: POP
// point := 10 ; end ;
1520: LD_ADDR_VAR 0 4
1524: PUSH
1525: LD_INT 10
1527: ST_TO_ADDR
1528: GO 1531
1530: POP
// if point then
1531: LD_VAR 0 4
1535: IFFALSE 1574
// points := Replace ( points , killer_side , points [ killer_side ] + point ) ;
1537: LD_ADDR_EXP 6
1541: PUSH
1542: LD_EXP 6
1546: PPUSH
1547: LD_VAR 0 2
1551: PPUSH
1552: LD_EXP 6
1556: PUSH
1557: LD_VAR 0 2
1561: ARRAY
1562: PUSH
1563: LD_VAR 0 4
1567: PLUS
1568: PPUSH
1569: CALL_OW 1
1573: ST_TO_ADDR
// end ;
1574: PPOPN 4
1576: END
// every 0 0$20 trigger FilterAllUnits ( [ f_side , 0 ] ) < 10 do
1577: LD_INT 22
1579: PUSH
1580: LD_INT 0
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: PUSH
1592: LD_INT 10
1594: LESS
1595: IFFALSE 1697
1597: GO 1599
1599: DISABLE
// begin enable ;
1600: ENABLE
// PrepareNature ( nat_area , wat_area , [ rand ( 0 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 2 , 4 ) , rand ( 2 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) ] ) ;
1601: LD_INT 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: LD_INT 0
1609: PPUSH
1610: LD_INT 4
1612: PPUSH
1613: CALL_OW 12
1617: PUSH
1618: LD_INT 0
1620: PPUSH
1621: LD_INT 2
1623: PPUSH
1624: CALL_OW 12
1628: PUSH
1629: LD_INT 0
1631: PPUSH
1632: LD_INT 4
1634: PPUSH
1635: CALL_OW 12
1639: PUSH
1640: LD_INT 2
1642: PPUSH
1643: LD_INT 4
1645: PPUSH
1646: CALL_OW 12
1650: PUSH
1651: LD_INT 2
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: CALL_OW 12
1661: PUSH
1662: LD_INT 0
1664: PPUSH
1665: LD_INT 2
1667: PPUSH
1668: CALL_OW 12
1672: PUSH
1673: LD_INT 0
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: CALL_OW 12
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PPUSH
1693: CALL 395 0 3
// end ;
1697: END
// every 0 0$1 do var i ;
1698: GO 1700
1700: DISABLE
1701: LD_INT 0
1703: PPUSH
// begin enable ;
1704: ENABLE
// display_strings := [ ] ;
1705: LD_ADDR_OWVAR 47
1709: PUSH
1710: EMPTY
1711: ST_TO_ADDR
// for i := 1 to huntersAmount do
1712: LD_ADDR_VAR 0 1
1716: PUSH
1717: DOUBLE
1718: LD_INT 1
1720: DEC
1721: ST_TO_ADDR
1722: LD_EXP 3
1726: PUSH
1727: FOR_TO
1728: IFFALSE 1862
// begin display_strings := display_strings ^ [ #player & i , i , points [ i ] ] ;
1730: LD_ADDR_OWVAR 47
1734: PUSH
1735: LD_OWVAR 47
1739: PUSH
1740: LD_STRING #player
1742: PUSH
1743: LD_VAR 0 1
1747: STR
1748: PUSH
1749: LD_VAR 0 1
1753: PUSH
1754: LD_EXP 6
1758: PUSH
1759: LD_VAR 0 1
1763: ARRAY
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: ADD
1770: ST_TO_ADDR
// if points [ i ] >= [ 750 , 1250 , 2000 ] [ Difficulty ] then
1771: LD_EXP 6
1775: PUSH
1776: LD_VAR 0 1
1780: ARRAY
1781: PUSH
1782: LD_INT 750
1784: PUSH
1785: LD_INT 1250
1787: PUSH
1788: LD_INT 2000
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_OWVAR 67
1800: ARRAY
1801: GREATEREQUAL
1802: IFFALSE 1860
// begin if i = 1 then
1804: LD_VAR 0 1
1808: PUSH
1809: LD_INT 1
1811: EQUAL
1812: IFFALSE 1853
// begin DialogueOn ;
1814: CALL_OW 6
// SetAchievement ( ACH_HUNT ) ;
1818: LD_STRING ACH_HUNT
1820: PPUSH
1821: CALL_OW 543
// display_strings := [ #hunting-win ] ;
1825: LD_ADDR_OWVAR 47
1829: PUSH
1830: LD_STRING #hunting-win
1832: PUSH
1833: EMPTY
1834: LIST
1835: ST_TO_ADDR
// dwait ( 0 0$5 ) ;
1836: LD_INT 175
1838: PPUSH
1839: CALL_OW 68
// YouWin ;
1843: CALL_OW 103
// DialogueOff ;
1847: CALL_OW 7
// end else
1851: GO 1860
// YouLost ( hunt3 ) ;
1853: LD_STRING hunt3
1855: PPUSH
1856: CALL_OW 104
// end ; end ;
1860: GO 1727
1862: POP
1863: POP
// end ; end_of_file end_of_file
1864: PPOPN 1
1866: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1867: GO 1869
1869: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1870: LD_STRING initStreamRollete();
1872: PPUSH
1873: CALL_OW 559
// InitStreamMode ;
1877: CALL 1886 0 0
// DefineStreamItems ( ) ;
1881: CALL 2326 0 0
// end ;
1885: END
// function InitStreamMode ; begin
1886: LD_INT 0
1888: PPUSH
// streamModeActive := false ;
1889: LD_ADDR_EXP 8
1893: PUSH
1894: LD_INT 0
1896: ST_TO_ADDR
// normalCounter := 36 ;
1897: LD_ADDR_EXP 9
1901: PUSH
1902: LD_INT 36
1904: ST_TO_ADDR
// hardcoreCounter := 16 ;
1905: LD_ADDR_EXP 10
1909: PUSH
1910: LD_INT 16
1912: ST_TO_ADDR
// sRocket := false ;
1913: LD_ADDR_EXP 13
1917: PUSH
1918: LD_INT 0
1920: ST_TO_ADDR
// sSpeed := false ;
1921: LD_ADDR_EXP 12
1925: PUSH
1926: LD_INT 0
1928: ST_TO_ADDR
// sEngine := false ;
1929: LD_ADDR_EXP 14
1933: PUSH
1934: LD_INT 0
1936: ST_TO_ADDR
// sSpec := false ;
1937: LD_ADDR_EXP 11
1941: PUSH
1942: LD_INT 0
1944: ST_TO_ADDR
// sLevel := false ;
1945: LD_ADDR_EXP 15
1949: PUSH
1950: LD_INT 0
1952: ST_TO_ADDR
// sArmoury := false ;
1953: LD_ADDR_EXP 16
1957: PUSH
1958: LD_INT 0
1960: ST_TO_ADDR
// sRadar := false ;
1961: LD_ADDR_EXP 17
1965: PUSH
1966: LD_INT 0
1968: ST_TO_ADDR
// sBunker := false ;
1969: LD_ADDR_EXP 18
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// sHack := false ;
1977: LD_ADDR_EXP 19
1981: PUSH
1982: LD_INT 0
1984: ST_TO_ADDR
// sFire := false ;
1985: LD_ADDR_EXP 20
1989: PUSH
1990: LD_INT 0
1992: ST_TO_ADDR
// sRefresh := false ;
1993: LD_ADDR_EXP 21
1997: PUSH
1998: LD_INT 0
2000: ST_TO_ADDR
// sExp := false ;
2001: LD_ADDR_EXP 22
2005: PUSH
2006: LD_INT 0
2008: ST_TO_ADDR
// sDepot := false ;
2009: LD_ADDR_EXP 23
2013: PUSH
2014: LD_INT 0
2016: ST_TO_ADDR
// sFlag := false ;
2017: LD_ADDR_EXP 24
2021: PUSH
2022: LD_INT 0
2024: ST_TO_ADDR
// sKamikadze := false ;
2025: LD_ADDR_EXP 32
2029: PUSH
2030: LD_INT 0
2032: ST_TO_ADDR
// sTroll := false ;
2033: LD_ADDR_EXP 33
2037: PUSH
2038: LD_INT 0
2040: ST_TO_ADDR
// sSlow := false ;
2041: LD_ADDR_EXP 34
2045: PUSH
2046: LD_INT 0
2048: ST_TO_ADDR
// sLack := false ;
2049: LD_ADDR_EXP 35
2053: PUSH
2054: LD_INT 0
2056: ST_TO_ADDR
// sTank := false ;
2057: LD_ADDR_EXP 37
2061: PUSH
2062: LD_INT 0
2064: ST_TO_ADDR
// sRemote := false ;
2065: LD_ADDR_EXP 38
2069: PUSH
2070: LD_INT 0
2072: ST_TO_ADDR
// sPowell := false ;
2073: LD_ADDR_EXP 39
2077: PUSH
2078: LD_INT 0
2080: ST_TO_ADDR
// sTeleport := false ;
2081: LD_ADDR_EXP 42
2085: PUSH
2086: LD_INT 0
2088: ST_TO_ADDR
// sOilTower := false ;
2089: LD_ADDR_EXP 44
2093: PUSH
2094: LD_INT 0
2096: ST_TO_ADDR
// sShovel := false ;
2097: LD_ADDR_EXP 45
2101: PUSH
2102: LD_INT 0
2104: ST_TO_ADDR
// sSheik := false ;
2105: LD_ADDR_EXP 46
2109: PUSH
2110: LD_INT 0
2112: ST_TO_ADDR
// sEarthquake := false ;
2113: LD_ADDR_EXP 48
2117: PUSH
2118: LD_INT 0
2120: ST_TO_ADDR
// sAI := false ;
2121: LD_ADDR_EXP 49
2125: PUSH
2126: LD_INT 0
2128: ST_TO_ADDR
// sCargo := false ;
2129: LD_ADDR_EXP 52
2133: PUSH
2134: LD_INT 0
2136: ST_TO_ADDR
// sDLaser := false ;
2137: LD_ADDR_EXP 53
2141: PUSH
2142: LD_INT 0
2144: ST_TO_ADDR
// sExchange := false ;
2145: LD_ADDR_EXP 54
2149: PUSH
2150: LD_INT 0
2152: ST_TO_ADDR
// sFac := false ;
2153: LD_ADDR_EXP 55
2157: PUSH
2158: LD_INT 0
2160: ST_TO_ADDR
// sPower := false ;
2161: LD_ADDR_EXP 56
2165: PUSH
2166: LD_INT 0
2168: ST_TO_ADDR
// sRandom := false ;
2169: LD_ADDR_EXP 57
2173: PUSH
2174: LD_INT 0
2176: ST_TO_ADDR
// sShield := false ;
2177: LD_ADDR_EXP 58
2181: PUSH
2182: LD_INT 0
2184: ST_TO_ADDR
// sTime := false ;
2185: LD_ADDR_EXP 59
2189: PUSH
2190: LD_INT 0
2192: ST_TO_ADDR
// sTools := false ;
2193: LD_ADDR_EXP 60
2197: PUSH
2198: LD_INT 0
2200: ST_TO_ADDR
// sSold := false ;
2201: LD_ADDR_EXP 25
2205: PUSH
2206: LD_INT 0
2208: ST_TO_ADDR
// sDiff := false ;
2209: LD_ADDR_EXP 26
2213: PUSH
2214: LD_INT 0
2216: ST_TO_ADDR
// sFog := false ;
2217: LD_ADDR_EXP 29
2221: PUSH
2222: LD_INT 0
2224: ST_TO_ADDR
// sReset := false ;
2225: LD_ADDR_EXP 30
2229: PUSH
2230: LD_INT 0
2232: ST_TO_ADDR
// sSun := false ;
2233: LD_ADDR_EXP 31
2237: PUSH
2238: LD_INT 0
2240: ST_TO_ADDR
// sTiger := false ;
2241: LD_ADDR_EXP 27
2245: PUSH
2246: LD_INT 0
2248: ST_TO_ADDR
// sBomb := false ;
2249: LD_ADDR_EXP 28
2253: PUSH
2254: LD_INT 0
2256: ST_TO_ADDR
// sWound := false ;
2257: LD_ADDR_EXP 36
2261: PUSH
2262: LD_INT 0
2264: ST_TO_ADDR
// sBetray := false ;
2265: LD_ADDR_EXP 40
2269: PUSH
2270: LD_INT 0
2272: ST_TO_ADDR
// sContamin := false ;
2273: LD_ADDR_EXP 41
2277: PUSH
2278: LD_INT 0
2280: ST_TO_ADDR
// sOil := false ;
2281: LD_ADDR_EXP 43
2285: PUSH
2286: LD_INT 0
2288: ST_TO_ADDR
// sStu := false ;
2289: LD_ADDR_EXP 47
2293: PUSH
2294: LD_INT 0
2296: ST_TO_ADDR
// sBazooka := false ;
2297: LD_ADDR_EXP 50
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// sMortar := false ;
2305: LD_ADDR_EXP 51
2309: PUSH
2310: LD_INT 0
2312: ST_TO_ADDR
// sRanger := false ;
2313: LD_ADDR_EXP 61
2317: PUSH
2318: LD_INT 0
2320: ST_TO_ADDR
// end ;
2321: LD_VAR 0 1
2325: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
2332: PPUSH
// result := [ ] ;
2333: LD_ADDR_VAR 0 1
2337: PUSH
2338: EMPTY
2339: ST_TO_ADDR
// if campaign_id = 1 then
2340: LD_OWVAR 69
2344: PUSH
2345: LD_INT 1
2347: EQUAL
2348: IFFALSE 5286
// begin case mission_number of 1 :
2350: LD_OWVAR 70
2354: PUSH
2355: LD_INT 1
2357: DOUBLE
2358: EQUAL
2359: IFTRUE 2363
2361: GO 2427
2363: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
2364: LD_ADDR_VAR 0 1
2368: PUSH
2369: LD_INT 2
2371: PUSH
2372: LD_INT 4
2374: PUSH
2375: LD_INT 11
2377: PUSH
2378: LD_INT 12
2380: PUSH
2381: LD_INT 15
2383: PUSH
2384: LD_INT 16
2386: PUSH
2387: LD_INT 22
2389: PUSH
2390: LD_INT 23
2392: PUSH
2393: LD_INT 26
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: LIST
2400: LIST
2401: LIST
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 101
2409: PUSH
2410: LD_INT 102
2412: PUSH
2413: LD_INT 106
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: LIST
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: ST_TO_ADDR
2425: GO 5284
2427: LD_INT 2
2429: DOUBLE
2430: EQUAL
2431: IFTRUE 2435
2433: GO 2507
2435: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
2436: LD_ADDR_VAR 0 1
2440: PUSH
2441: LD_INT 2
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 11
2449: PUSH
2450: LD_INT 12
2452: PUSH
2453: LD_INT 15
2455: PUSH
2456: LD_INT 16
2458: PUSH
2459: LD_INT 22
2461: PUSH
2462: LD_INT 23
2464: PUSH
2465: LD_INT 26
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: LIST
2478: PUSH
2479: LD_INT 101
2481: PUSH
2482: LD_INT 102
2484: PUSH
2485: LD_INT 105
2487: PUSH
2488: LD_INT 106
2490: PUSH
2491: LD_INT 108
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: ST_TO_ADDR
2505: GO 5284
2507: LD_INT 3
2509: DOUBLE
2510: EQUAL
2511: IFTRUE 2515
2513: GO 2591
2515: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
2516: LD_ADDR_VAR 0 1
2520: PUSH
2521: LD_INT 2
2523: PUSH
2524: LD_INT 4
2526: PUSH
2527: LD_INT 5
2529: PUSH
2530: LD_INT 11
2532: PUSH
2533: LD_INT 12
2535: PUSH
2536: LD_INT 15
2538: PUSH
2539: LD_INT 16
2541: PUSH
2542: LD_INT 22
2544: PUSH
2545: LD_INT 26
2547: PUSH
2548: LD_INT 36
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: LIST
2555: LIST
2556: LIST
2557: LIST
2558: LIST
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_INT 101
2565: PUSH
2566: LD_INT 102
2568: PUSH
2569: LD_INT 105
2571: PUSH
2572: LD_INT 106
2574: PUSH
2575: LD_INT 108
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: LIST
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: ST_TO_ADDR
2589: GO 5284
2591: LD_INT 4
2593: DOUBLE
2594: EQUAL
2595: IFTRUE 2599
2597: GO 2683
2599: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
2600: LD_ADDR_VAR 0 1
2604: PUSH
2605: LD_INT 2
2607: PUSH
2608: LD_INT 4
2610: PUSH
2611: LD_INT 5
2613: PUSH
2614: LD_INT 8
2616: PUSH
2617: LD_INT 11
2619: PUSH
2620: LD_INT 12
2622: PUSH
2623: LD_INT 15
2625: PUSH
2626: LD_INT 16
2628: PUSH
2629: LD_INT 22
2631: PUSH
2632: LD_INT 23
2634: PUSH
2635: LD_INT 26
2637: PUSH
2638: LD_INT 36
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 101
2657: PUSH
2658: LD_INT 102
2660: PUSH
2661: LD_INT 105
2663: PUSH
2664: LD_INT 106
2666: PUSH
2667: LD_INT 108
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: ST_TO_ADDR
2681: GO 5284
2683: LD_INT 5
2685: DOUBLE
2686: EQUAL
2687: IFTRUE 2691
2689: GO 2791
2691: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2692: LD_ADDR_VAR 0 1
2696: PUSH
2697: LD_INT 2
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: LD_INT 5
2705: PUSH
2706: LD_INT 6
2708: PUSH
2709: LD_INT 8
2711: PUSH
2712: LD_INT 11
2714: PUSH
2715: LD_INT 12
2717: PUSH
2718: LD_INT 15
2720: PUSH
2721: LD_INT 16
2723: PUSH
2724: LD_INT 22
2726: PUSH
2727: LD_INT 23
2729: PUSH
2730: LD_INT 25
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 36
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: PUSH
2755: LD_INT 101
2757: PUSH
2758: LD_INT 102
2760: PUSH
2761: LD_INT 105
2763: PUSH
2764: LD_INT 106
2766: PUSH
2767: LD_INT 108
2769: PUSH
2770: LD_INT 109
2772: PUSH
2773: LD_INT 112
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: EMPTY
2786: LIST
2787: LIST
2788: ST_TO_ADDR
2789: GO 5284
2791: LD_INT 6
2793: DOUBLE
2794: EQUAL
2795: IFTRUE 2799
2797: GO 2919
2799: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2800: LD_ADDR_VAR 0 1
2804: PUSH
2805: LD_INT 2
2807: PUSH
2808: LD_INT 4
2810: PUSH
2811: LD_INT 5
2813: PUSH
2814: LD_INT 6
2816: PUSH
2817: LD_INT 8
2819: PUSH
2820: LD_INT 11
2822: PUSH
2823: LD_INT 12
2825: PUSH
2826: LD_INT 15
2828: PUSH
2829: LD_INT 16
2831: PUSH
2832: LD_INT 20
2834: PUSH
2835: LD_INT 21
2837: PUSH
2838: LD_INT 22
2840: PUSH
2841: LD_INT 23
2843: PUSH
2844: LD_INT 25
2846: PUSH
2847: LD_INT 26
2849: PUSH
2850: LD_INT 30
2852: PUSH
2853: LD_INT 31
2855: PUSH
2856: LD_INT 32
2858: PUSH
2859: LD_INT 36
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: PUSH
2883: LD_INT 101
2885: PUSH
2886: LD_INT 102
2888: PUSH
2889: LD_INT 105
2891: PUSH
2892: LD_INT 106
2894: PUSH
2895: LD_INT 108
2897: PUSH
2898: LD_INT 109
2900: PUSH
2901: LD_INT 112
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: LIST
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: ST_TO_ADDR
2917: GO 5284
2919: LD_INT 7
2921: DOUBLE
2922: EQUAL
2923: IFTRUE 2927
2925: GO 3027
2927: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 5
2941: PUSH
2942: LD_INT 7
2944: PUSH
2945: LD_INT 11
2947: PUSH
2948: LD_INT 12
2950: PUSH
2951: LD_INT 15
2953: PUSH
2954: LD_INT 16
2956: PUSH
2957: LD_INT 20
2959: PUSH
2960: LD_INT 21
2962: PUSH
2963: LD_INT 22
2965: PUSH
2966: LD_INT 23
2968: PUSH
2969: LD_INT 25
2971: PUSH
2972: LD_INT 26
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: LIST
2980: LIST
2981: LIST
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_INT 101
2993: PUSH
2994: LD_INT 102
2996: PUSH
2997: LD_INT 103
2999: PUSH
3000: LD_INT 105
3002: PUSH
3003: LD_INT 106
3005: PUSH
3006: LD_INT 108
3008: PUSH
3009: LD_INT 112
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: ST_TO_ADDR
3025: GO 5284
3027: LD_INT 8
3029: DOUBLE
3030: EQUAL
3031: IFTRUE 3035
3033: GO 3163
3035: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
3036: LD_ADDR_VAR 0 1
3040: PUSH
3041: LD_INT 2
3043: PUSH
3044: LD_INT 4
3046: PUSH
3047: LD_INT 5
3049: PUSH
3050: LD_INT 6
3052: PUSH
3053: LD_INT 7
3055: PUSH
3056: LD_INT 8
3058: PUSH
3059: LD_INT 11
3061: PUSH
3062: LD_INT 12
3064: PUSH
3065: LD_INT 15
3067: PUSH
3068: LD_INT 16
3070: PUSH
3071: LD_INT 20
3073: PUSH
3074: LD_INT 21
3076: PUSH
3077: LD_INT 22
3079: PUSH
3080: LD_INT 23
3082: PUSH
3083: LD_INT 25
3085: PUSH
3086: LD_INT 26
3088: PUSH
3089: LD_INT 30
3091: PUSH
3092: LD_INT 31
3094: PUSH
3095: LD_INT 32
3097: PUSH
3098: LD_INT 36
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: LIST
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 101
3125: PUSH
3126: LD_INT 102
3128: PUSH
3129: LD_INT 103
3131: PUSH
3132: LD_INT 105
3134: PUSH
3135: LD_INT 106
3137: PUSH
3138: LD_INT 108
3140: PUSH
3141: LD_INT 109
3143: PUSH
3144: LD_INT 112
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: ST_TO_ADDR
3161: GO 5284
3163: LD_INT 9
3165: DOUBLE
3166: EQUAL
3167: IFTRUE 3171
3169: GO 3307
3171: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
3172: LD_ADDR_VAR 0 1
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: LD_INT 4
3182: PUSH
3183: LD_INT 5
3185: PUSH
3186: LD_INT 6
3188: PUSH
3189: LD_INT 7
3191: PUSH
3192: LD_INT 8
3194: PUSH
3195: LD_INT 11
3197: PUSH
3198: LD_INT 12
3200: PUSH
3201: LD_INT 15
3203: PUSH
3204: LD_INT 16
3206: PUSH
3207: LD_INT 20
3209: PUSH
3210: LD_INT 21
3212: PUSH
3213: LD_INT 22
3215: PUSH
3216: LD_INT 23
3218: PUSH
3219: LD_INT 25
3221: PUSH
3222: LD_INT 26
3224: PUSH
3225: LD_INT 28
3227: PUSH
3228: LD_INT 30
3230: PUSH
3231: LD_INT 31
3233: PUSH
3234: LD_INT 32
3236: PUSH
3237: LD_INT 36
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 101
3265: PUSH
3266: LD_INT 102
3268: PUSH
3269: LD_INT 103
3271: PUSH
3272: LD_INT 105
3274: PUSH
3275: LD_INT 106
3277: PUSH
3278: LD_INT 108
3280: PUSH
3281: LD_INT 109
3283: PUSH
3284: LD_INT 112
3286: PUSH
3287: LD_INT 114
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: ST_TO_ADDR
3305: GO 5284
3307: LD_INT 10
3309: DOUBLE
3310: EQUAL
3311: IFTRUE 3315
3313: GO 3499
3315: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
3316: LD_ADDR_VAR 0 1
3320: PUSH
3321: LD_INT 2
3323: PUSH
3324: LD_INT 4
3326: PUSH
3327: LD_INT 5
3329: PUSH
3330: LD_INT 6
3332: PUSH
3333: LD_INT 7
3335: PUSH
3336: LD_INT 8
3338: PUSH
3339: LD_INT 9
3341: PUSH
3342: LD_INT 10
3344: PUSH
3345: LD_INT 11
3347: PUSH
3348: LD_INT 12
3350: PUSH
3351: LD_INT 13
3353: PUSH
3354: LD_INT 14
3356: PUSH
3357: LD_INT 15
3359: PUSH
3360: LD_INT 16
3362: PUSH
3363: LD_INT 17
3365: PUSH
3366: LD_INT 18
3368: PUSH
3369: LD_INT 19
3371: PUSH
3372: LD_INT 20
3374: PUSH
3375: LD_INT 21
3377: PUSH
3378: LD_INT 22
3380: PUSH
3381: LD_INT 23
3383: PUSH
3384: LD_INT 24
3386: PUSH
3387: LD_INT 25
3389: PUSH
3390: LD_INT 26
3392: PUSH
3393: LD_INT 28
3395: PUSH
3396: LD_INT 30
3398: PUSH
3399: LD_INT 31
3401: PUSH
3402: LD_INT 32
3404: PUSH
3405: LD_INT 36
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 101
3441: PUSH
3442: LD_INT 102
3444: PUSH
3445: LD_INT 103
3447: PUSH
3448: LD_INT 104
3450: PUSH
3451: LD_INT 105
3453: PUSH
3454: LD_INT 106
3456: PUSH
3457: LD_INT 107
3459: PUSH
3460: LD_INT 108
3462: PUSH
3463: LD_INT 109
3465: PUSH
3466: LD_INT 110
3468: PUSH
3469: LD_INT 111
3471: PUSH
3472: LD_INT 112
3474: PUSH
3475: LD_INT 114
3477: PUSH
3478: EMPTY
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: PUSH
3493: EMPTY
3494: LIST
3495: LIST
3496: ST_TO_ADDR
3497: GO 5284
3499: LD_INT 11
3501: DOUBLE
3502: EQUAL
3503: IFTRUE 3507
3505: GO 3699
3507: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
3508: LD_ADDR_VAR 0 1
3512: PUSH
3513: LD_INT 2
3515: PUSH
3516: LD_INT 3
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 6
3527: PUSH
3528: LD_INT 7
3530: PUSH
3531: LD_INT 8
3533: PUSH
3534: LD_INT 9
3536: PUSH
3537: LD_INT 10
3539: PUSH
3540: LD_INT 11
3542: PUSH
3543: LD_INT 12
3545: PUSH
3546: LD_INT 13
3548: PUSH
3549: LD_INT 14
3551: PUSH
3552: LD_INT 15
3554: PUSH
3555: LD_INT 16
3557: PUSH
3558: LD_INT 17
3560: PUSH
3561: LD_INT 18
3563: PUSH
3564: LD_INT 19
3566: PUSH
3567: LD_INT 20
3569: PUSH
3570: LD_INT 21
3572: PUSH
3573: LD_INT 22
3575: PUSH
3576: LD_INT 23
3578: PUSH
3579: LD_INT 24
3581: PUSH
3582: LD_INT 25
3584: PUSH
3585: LD_INT 26
3587: PUSH
3588: LD_INT 28
3590: PUSH
3591: LD_INT 30
3593: PUSH
3594: LD_INT 31
3596: PUSH
3597: LD_INT 32
3599: PUSH
3600: LD_INT 34
3602: PUSH
3603: LD_INT 36
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: LIST
3623: LIST
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: LIST
3632: LIST
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 101
3641: PUSH
3642: LD_INT 102
3644: PUSH
3645: LD_INT 103
3647: PUSH
3648: LD_INT 104
3650: PUSH
3651: LD_INT 105
3653: PUSH
3654: LD_INT 106
3656: PUSH
3657: LD_INT 107
3659: PUSH
3660: LD_INT 108
3662: PUSH
3663: LD_INT 109
3665: PUSH
3666: LD_INT 110
3668: PUSH
3669: LD_INT 111
3671: PUSH
3672: LD_INT 112
3674: PUSH
3675: LD_INT 114
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: LIST
3686: LIST
3687: LIST
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: ST_TO_ADDR
3697: GO 5284
3699: LD_INT 12
3701: DOUBLE
3702: EQUAL
3703: IFTRUE 3707
3705: GO 3915
3707: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3708: LD_ADDR_VAR 0 1
3712: PUSH
3713: LD_INT 1
3715: PUSH
3716: LD_INT 2
3718: PUSH
3719: LD_INT 3
3721: PUSH
3722: LD_INT 4
3724: PUSH
3725: LD_INT 5
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: LD_INT 7
3733: PUSH
3734: LD_INT 8
3736: PUSH
3737: LD_INT 9
3739: PUSH
3740: LD_INT 10
3742: PUSH
3743: LD_INT 11
3745: PUSH
3746: LD_INT 12
3748: PUSH
3749: LD_INT 13
3751: PUSH
3752: LD_INT 14
3754: PUSH
3755: LD_INT 15
3757: PUSH
3758: LD_INT 16
3760: PUSH
3761: LD_INT 17
3763: PUSH
3764: LD_INT 18
3766: PUSH
3767: LD_INT 19
3769: PUSH
3770: LD_INT 20
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 22
3778: PUSH
3779: LD_INT 23
3781: PUSH
3782: LD_INT 24
3784: PUSH
3785: LD_INT 25
3787: PUSH
3788: LD_INT 26
3790: PUSH
3791: LD_INT 27
3793: PUSH
3794: LD_INT 28
3796: PUSH
3797: LD_INT 30
3799: PUSH
3800: LD_INT 31
3802: PUSH
3803: LD_INT 32
3805: PUSH
3806: LD_INT 33
3808: PUSH
3809: LD_INT 34
3811: PUSH
3812: LD_INT 36
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 101
3853: PUSH
3854: LD_INT 102
3856: PUSH
3857: LD_INT 103
3859: PUSH
3860: LD_INT 104
3862: PUSH
3863: LD_INT 105
3865: PUSH
3866: LD_INT 106
3868: PUSH
3869: LD_INT 107
3871: PUSH
3872: LD_INT 108
3874: PUSH
3875: LD_INT 109
3877: PUSH
3878: LD_INT 110
3880: PUSH
3881: LD_INT 111
3883: PUSH
3884: LD_INT 112
3886: PUSH
3887: LD_INT 113
3889: PUSH
3890: LD_INT 114
3892: PUSH
3893: EMPTY
3894: LIST
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: ST_TO_ADDR
3913: GO 5284
3915: LD_INT 13
3917: DOUBLE
3918: EQUAL
3919: IFTRUE 3923
3921: GO 4119
3923: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3924: LD_ADDR_VAR 0 1
3928: PUSH
3929: LD_INT 1
3931: PUSH
3932: LD_INT 2
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 5
3943: PUSH
3944: LD_INT 8
3946: PUSH
3947: LD_INT 9
3949: PUSH
3950: LD_INT 10
3952: PUSH
3953: LD_INT 11
3955: PUSH
3956: LD_INT 12
3958: PUSH
3959: LD_INT 14
3961: PUSH
3962: LD_INT 15
3964: PUSH
3965: LD_INT 16
3967: PUSH
3968: LD_INT 17
3970: PUSH
3971: LD_INT 18
3973: PUSH
3974: LD_INT 19
3976: PUSH
3977: LD_INT 20
3979: PUSH
3980: LD_INT 21
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 23
3988: PUSH
3989: LD_INT 24
3991: PUSH
3992: LD_INT 25
3994: PUSH
3995: LD_INT 26
3997: PUSH
3998: LD_INT 27
4000: PUSH
4001: LD_INT 28
4003: PUSH
4004: LD_INT 30
4006: PUSH
4007: LD_INT 31
4009: PUSH
4010: LD_INT 32
4012: PUSH
4013: LD_INT 33
4015: PUSH
4016: LD_INT 34
4018: PUSH
4019: LD_INT 36
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: LIST
4040: LIST
4041: LIST
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: LIST
4049: LIST
4050: LIST
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_INT 101
4057: PUSH
4058: LD_INT 102
4060: PUSH
4061: LD_INT 103
4063: PUSH
4064: LD_INT 104
4066: PUSH
4067: LD_INT 105
4069: PUSH
4070: LD_INT 106
4072: PUSH
4073: LD_INT 107
4075: PUSH
4076: LD_INT 108
4078: PUSH
4079: LD_INT 109
4081: PUSH
4082: LD_INT 110
4084: PUSH
4085: LD_INT 111
4087: PUSH
4088: LD_INT 112
4090: PUSH
4091: LD_INT 113
4093: PUSH
4094: LD_INT 114
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: ST_TO_ADDR
4117: GO 5284
4119: LD_INT 14
4121: DOUBLE
4122: EQUAL
4123: IFTRUE 4127
4125: GO 4339
4127: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
4128: LD_ADDR_VAR 0 1
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: LD_INT 2
4138: PUSH
4139: LD_INT 3
4141: PUSH
4142: LD_INT 4
4144: PUSH
4145: LD_INT 5
4147: PUSH
4148: LD_INT 6
4150: PUSH
4151: LD_INT 7
4153: PUSH
4154: LD_INT 8
4156: PUSH
4157: LD_INT 9
4159: PUSH
4160: LD_INT 10
4162: PUSH
4163: LD_INT 11
4165: PUSH
4166: LD_INT 12
4168: PUSH
4169: LD_INT 13
4171: PUSH
4172: LD_INT 14
4174: PUSH
4175: LD_INT 15
4177: PUSH
4178: LD_INT 16
4180: PUSH
4181: LD_INT 17
4183: PUSH
4184: LD_INT 18
4186: PUSH
4187: LD_INT 19
4189: PUSH
4190: LD_INT 20
4192: PUSH
4193: LD_INT 21
4195: PUSH
4196: LD_INT 22
4198: PUSH
4199: LD_INT 23
4201: PUSH
4202: LD_INT 24
4204: PUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 26
4210: PUSH
4211: LD_INT 27
4213: PUSH
4214: LD_INT 28
4216: PUSH
4217: LD_INT 29
4219: PUSH
4220: LD_INT 30
4222: PUSH
4223: LD_INT 31
4225: PUSH
4226: LD_INT 32
4228: PUSH
4229: LD_INT 33
4231: PUSH
4232: LD_INT 34
4234: PUSH
4235: LD_INT 36
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: LIST
4242: LIST
4243: LIST
4244: LIST
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: LIST
4274: PUSH
4275: LD_INT 101
4277: PUSH
4278: LD_INT 102
4280: PUSH
4281: LD_INT 103
4283: PUSH
4284: LD_INT 104
4286: PUSH
4287: LD_INT 105
4289: PUSH
4290: LD_INT 106
4292: PUSH
4293: LD_INT 107
4295: PUSH
4296: LD_INT 108
4298: PUSH
4299: LD_INT 109
4301: PUSH
4302: LD_INT 110
4304: PUSH
4305: LD_INT 111
4307: PUSH
4308: LD_INT 112
4310: PUSH
4311: LD_INT 113
4313: PUSH
4314: LD_INT 114
4316: PUSH
4317: EMPTY
4318: LIST
4319: LIST
4320: LIST
4321: LIST
4322: LIST
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: LIST
4331: LIST
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: ST_TO_ADDR
4337: GO 5284
4339: LD_INT 15
4341: DOUBLE
4342: EQUAL
4343: IFTRUE 4347
4345: GO 4559
4347: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
4348: LD_ADDR_VAR 0 1
4352: PUSH
4353: LD_INT 1
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: LD_INT 5
4367: PUSH
4368: LD_INT 6
4370: PUSH
4371: LD_INT 7
4373: PUSH
4374: LD_INT 8
4376: PUSH
4377: LD_INT 9
4379: PUSH
4380: LD_INT 10
4382: PUSH
4383: LD_INT 11
4385: PUSH
4386: LD_INT 12
4388: PUSH
4389: LD_INT 13
4391: PUSH
4392: LD_INT 14
4394: PUSH
4395: LD_INT 15
4397: PUSH
4398: LD_INT 16
4400: PUSH
4401: LD_INT 17
4403: PUSH
4404: LD_INT 18
4406: PUSH
4407: LD_INT 19
4409: PUSH
4410: LD_INT 20
4412: PUSH
4413: LD_INT 21
4415: PUSH
4416: LD_INT 22
4418: PUSH
4419: LD_INT 23
4421: PUSH
4422: LD_INT 24
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 26
4430: PUSH
4431: LD_INT 27
4433: PUSH
4434: LD_INT 28
4436: PUSH
4437: LD_INT 29
4439: PUSH
4440: LD_INT 30
4442: PUSH
4443: LD_INT 31
4445: PUSH
4446: LD_INT 32
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 34
4454: PUSH
4455: LD_INT 36
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: LIST
4488: LIST
4489: LIST
4490: LIST
4491: LIST
4492: LIST
4493: LIST
4494: PUSH
4495: LD_INT 101
4497: PUSH
4498: LD_INT 102
4500: PUSH
4501: LD_INT 103
4503: PUSH
4504: LD_INT 104
4506: PUSH
4507: LD_INT 105
4509: PUSH
4510: LD_INT 106
4512: PUSH
4513: LD_INT 107
4515: PUSH
4516: LD_INT 108
4518: PUSH
4519: LD_INT 109
4521: PUSH
4522: LD_INT 110
4524: PUSH
4525: LD_INT 111
4527: PUSH
4528: LD_INT 112
4530: PUSH
4531: LD_INT 113
4533: PUSH
4534: LD_INT 114
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: ST_TO_ADDR
4557: GO 5284
4559: LD_INT 16
4561: DOUBLE
4562: EQUAL
4563: IFTRUE 4567
4565: GO 4691
4567: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
4568: LD_ADDR_VAR 0 1
4572: PUSH
4573: LD_INT 2
4575: PUSH
4576: LD_INT 4
4578: PUSH
4579: LD_INT 5
4581: PUSH
4582: LD_INT 7
4584: PUSH
4585: LD_INT 11
4587: PUSH
4588: LD_INT 12
4590: PUSH
4591: LD_INT 15
4593: PUSH
4594: LD_INT 16
4596: PUSH
4597: LD_INT 20
4599: PUSH
4600: LD_INT 21
4602: PUSH
4603: LD_INT 22
4605: PUSH
4606: LD_INT 23
4608: PUSH
4609: LD_INT 25
4611: PUSH
4612: LD_INT 26
4614: PUSH
4615: LD_INT 30
4617: PUSH
4618: LD_INT 31
4620: PUSH
4621: LD_INT 32
4623: PUSH
4624: LD_INT 33
4626: PUSH
4627: LD_INT 34
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 101
4653: PUSH
4654: LD_INT 102
4656: PUSH
4657: LD_INT 103
4659: PUSH
4660: LD_INT 106
4662: PUSH
4663: LD_INT 108
4665: PUSH
4666: LD_INT 112
4668: PUSH
4669: LD_INT 113
4671: PUSH
4672: LD_INT 114
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: ST_TO_ADDR
4689: GO 5284
4691: LD_INT 17
4693: DOUBLE
4694: EQUAL
4695: IFTRUE 4699
4697: GO 4911
4699: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: LD_INT 2
4710: PUSH
4711: LD_INT 3
4713: PUSH
4714: LD_INT 4
4716: PUSH
4717: LD_INT 5
4719: PUSH
4720: LD_INT 6
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: LD_INT 8
4728: PUSH
4729: LD_INT 9
4731: PUSH
4732: LD_INT 10
4734: PUSH
4735: LD_INT 11
4737: PUSH
4738: LD_INT 12
4740: PUSH
4741: LD_INT 13
4743: PUSH
4744: LD_INT 14
4746: PUSH
4747: LD_INT 15
4749: PUSH
4750: LD_INT 16
4752: PUSH
4753: LD_INT 17
4755: PUSH
4756: LD_INT 18
4758: PUSH
4759: LD_INT 19
4761: PUSH
4762: LD_INT 20
4764: PUSH
4765: LD_INT 21
4767: PUSH
4768: LD_INT 22
4770: PUSH
4771: LD_INT 23
4773: PUSH
4774: LD_INT 24
4776: PUSH
4777: LD_INT 25
4779: PUSH
4780: LD_INT 26
4782: PUSH
4783: LD_INT 27
4785: PUSH
4786: LD_INT 28
4788: PUSH
4789: LD_INT 29
4791: PUSH
4792: LD_INT 30
4794: PUSH
4795: LD_INT 31
4797: PUSH
4798: LD_INT 32
4800: PUSH
4801: LD_INT 33
4803: PUSH
4804: LD_INT 34
4806: PUSH
4807: LD_INT 36
4809: PUSH
4810: EMPTY
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 101
4849: PUSH
4850: LD_INT 102
4852: PUSH
4853: LD_INT 103
4855: PUSH
4856: LD_INT 104
4858: PUSH
4859: LD_INT 105
4861: PUSH
4862: LD_INT 106
4864: PUSH
4865: LD_INT 107
4867: PUSH
4868: LD_INT 108
4870: PUSH
4871: LD_INT 109
4873: PUSH
4874: LD_INT 110
4876: PUSH
4877: LD_INT 111
4879: PUSH
4880: LD_INT 112
4882: PUSH
4883: LD_INT 113
4885: PUSH
4886: LD_INT 114
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: LIST
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: ST_TO_ADDR
4909: GO 5284
4911: LD_INT 18
4913: DOUBLE
4914: EQUAL
4915: IFTRUE 4919
4917: GO 5055
4919: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4920: LD_ADDR_VAR 0 1
4924: PUSH
4925: LD_INT 2
4927: PUSH
4928: LD_INT 4
4930: PUSH
4931: LD_INT 5
4933: PUSH
4934: LD_INT 7
4936: PUSH
4937: LD_INT 11
4939: PUSH
4940: LD_INT 12
4942: PUSH
4943: LD_INT 15
4945: PUSH
4946: LD_INT 16
4948: PUSH
4949: LD_INT 20
4951: PUSH
4952: LD_INT 21
4954: PUSH
4955: LD_INT 22
4957: PUSH
4958: LD_INT 23
4960: PUSH
4961: LD_INT 25
4963: PUSH
4964: LD_INT 26
4966: PUSH
4967: LD_INT 30
4969: PUSH
4970: LD_INT 31
4972: PUSH
4973: LD_INT 32
4975: PUSH
4976: LD_INT 33
4978: PUSH
4979: LD_INT 34
4981: PUSH
4982: LD_INT 35
4984: PUSH
4985: LD_INT 36
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 101
5013: PUSH
5014: LD_INT 102
5016: PUSH
5017: LD_INT 103
5019: PUSH
5020: LD_INT 106
5022: PUSH
5023: LD_INT 108
5025: PUSH
5026: LD_INT 112
5028: PUSH
5029: LD_INT 113
5031: PUSH
5032: LD_INT 114
5034: PUSH
5035: LD_INT 115
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: LIST
5044: LIST
5045: LIST
5046: LIST
5047: LIST
5048: PUSH
5049: EMPTY
5050: LIST
5051: LIST
5052: ST_TO_ADDR
5053: GO 5284
5055: LD_INT 19
5057: DOUBLE
5058: EQUAL
5059: IFTRUE 5063
5061: GO 5283
5063: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
5064: LD_ADDR_VAR 0 1
5068: PUSH
5069: LD_INT 1
5071: PUSH
5072: LD_INT 2
5074: PUSH
5075: LD_INT 3
5077: PUSH
5078: LD_INT 4
5080: PUSH
5081: LD_INT 5
5083: PUSH
5084: LD_INT 6
5086: PUSH
5087: LD_INT 7
5089: PUSH
5090: LD_INT 8
5092: PUSH
5093: LD_INT 9
5095: PUSH
5096: LD_INT 10
5098: PUSH
5099: LD_INT 11
5101: PUSH
5102: LD_INT 12
5104: PUSH
5105: LD_INT 13
5107: PUSH
5108: LD_INT 14
5110: PUSH
5111: LD_INT 15
5113: PUSH
5114: LD_INT 16
5116: PUSH
5117: LD_INT 17
5119: PUSH
5120: LD_INT 18
5122: PUSH
5123: LD_INT 19
5125: PUSH
5126: LD_INT 20
5128: PUSH
5129: LD_INT 21
5131: PUSH
5132: LD_INT 22
5134: PUSH
5135: LD_INT 23
5137: PUSH
5138: LD_INT 24
5140: PUSH
5141: LD_INT 25
5143: PUSH
5144: LD_INT 26
5146: PUSH
5147: LD_INT 27
5149: PUSH
5150: LD_INT 28
5152: PUSH
5153: LD_INT 29
5155: PUSH
5156: LD_INT 30
5158: PUSH
5159: LD_INT 31
5161: PUSH
5162: LD_INT 32
5164: PUSH
5165: LD_INT 33
5167: PUSH
5168: LD_INT 34
5170: PUSH
5171: LD_INT 35
5173: PUSH
5174: LD_INT 36
5176: PUSH
5177: EMPTY
5178: LIST
5179: LIST
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 101
5217: PUSH
5218: LD_INT 102
5220: PUSH
5221: LD_INT 103
5223: PUSH
5224: LD_INT 104
5226: PUSH
5227: LD_INT 105
5229: PUSH
5230: LD_INT 106
5232: PUSH
5233: LD_INT 107
5235: PUSH
5236: LD_INT 108
5238: PUSH
5239: LD_INT 109
5241: PUSH
5242: LD_INT 110
5244: PUSH
5245: LD_INT 111
5247: PUSH
5248: LD_INT 112
5250: PUSH
5251: LD_INT 113
5253: PUSH
5254: LD_INT 114
5256: PUSH
5257: LD_INT 115
5259: PUSH
5260: EMPTY
5261: LIST
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: LIST
5268: LIST
5269: LIST
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: LIST
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: ST_TO_ADDR
5281: GO 5284
5283: POP
// end else
5284: GO 5503
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
5286: LD_ADDR_VAR 0 1
5290: PUSH
5291: LD_INT 1
5293: PUSH
5294: LD_INT 2
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: LD_INT 4
5302: PUSH
5303: LD_INT 5
5305: PUSH
5306: LD_INT 6
5308: PUSH
5309: LD_INT 7
5311: PUSH
5312: LD_INT 8
5314: PUSH
5315: LD_INT 9
5317: PUSH
5318: LD_INT 10
5320: PUSH
5321: LD_INT 11
5323: PUSH
5324: LD_INT 12
5326: PUSH
5327: LD_INT 13
5329: PUSH
5330: LD_INT 14
5332: PUSH
5333: LD_INT 15
5335: PUSH
5336: LD_INT 16
5338: PUSH
5339: LD_INT 17
5341: PUSH
5342: LD_INT 18
5344: PUSH
5345: LD_INT 19
5347: PUSH
5348: LD_INT 20
5350: PUSH
5351: LD_INT 21
5353: PUSH
5354: LD_INT 22
5356: PUSH
5357: LD_INT 23
5359: PUSH
5360: LD_INT 24
5362: PUSH
5363: LD_INT 25
5365: PUSH
5366: LD_INT 26
5368: PUSH
5369: LD_INT 27
5371: PUSH
5372: LD_INT 28
5374: PUSH
5375: LD_INT 29
5377: PUSH
5378: LD_INT 30
5380: PUSH
5381: LD_INT 31
5383: PUSH
5384: LD_INT 32
5386: PUSH
5387: LD_INT 33
5389: PUSH
5390: LD_INT 34
5392: PUSH
5393: LD_INT 35
5395: PUSH
5396: LD_INT 36
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: LIST
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: LIST
5436: PUSH
5437: LD_INT 101
5439: PUSH
5440: LD_INT 102
5442: PUSH
5443: LD_INT 103
5445: PUSH
5446: LD_INT 104
5448: PUSH
5449: LD_INT 105
5451: PUSH
5452: LD_INT 106
5454: PUSH
5455: LD_INT 107
5457: PUSH
5458: LD_INT 108
5460: PUSH
5461: LD_INT 109
5463: PUSH
5464: LD_INT 110
5466: PUSH
5467: LD_INT 111
5469: PUSH
5470: LD_INT 112
5472: PUSH
5473: LD_INT 113
5475: PUSH
5476: LD_INT 114
5478: PUSH
5479: LD_INT 115
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: ST_TO_ADDR
// if result then
5503: LD_VAR 0 1
5507: IFFALSE 5796
// begin normal :=  ;
5509: LD_ADDR_VAR 0 3
5513: PUSH
5514: LD_STRING 
5516: ST_TO_ADDR
// hardcore :=  ;
5517: LD_ADDR_VAR 0 4
5521: PUSH
5522: LD_STRING 
5524: ST_TO_ADDR
// for i = 1 to normalCounter do
5525: LD_ADDR_VAR 0 5
5529: PUSH
5530: DOUBLE
5531: LD_INT 1
5533: DEC
5534: ST_TO_ADDR
5535: LD_EXP 9
5539: PUSH
5540: FOR_TO
5541: IFFALSE 5642
// begin tmp := 0 ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: LD_STRING 0
5550: ST_TO_ADDR
// if result [ 1 ] then
5551: LD_VAR 0 1
5555: PUSH
5556: LD_INT 1
5558: ARRAY
5559: IFFALSE 5624
// if result [ 1 ] [ 1 ] = i then
5561: LD_VAR 0 1
5565: PUSH
5566: LD_INT 1
5568: ARRAY
5569: PUSH
5570: LD_INT 1
5572: ARRAY
5573: PUSH
5574: LD_VAR 0 5
5578: EQUAL
5579: IFFALSE 5624
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
5581: LD_ADDR_VAR 0 1
5585: PUSH
5586: LD_VAR 0 1
5590: PPUSH
5591: LD_INT 1
5593: PPUSH
5594: LD_VAR 0 1
5598: PUSH
5599: LD_INT 1
5601: ARRAY
5602: PPUSH
5603: LD_INT 1
5605: PPUSH
5606: CALL_OW 3
5610: PPUSH
5611: CALL_OW 1
5615: ST_TO_ADDR
// tmp := 1 ;
5616: LD_ADDR_VAR 0 2
5620: PUSH
5621: LD_STRING 1
5623: ST_TO_ADDR
// end ; normal := normal & tmp ;
5624: LD_ADDR_VAR 0 3
5628: PUSH
5629: LD_VAR 0 3
5633: PUSH
5634: LD_VAR 0 2
5638: STR
5639: ST_TO_ADDR
// end ;
5640: GO 5540
5642: POP
5643: POP
// for i = 1 to hardcoreCounter do
5644: LD_ADDR_VAR 0 5
5648: PUSH
5649: DOUBLE
5650: LD_INT 1
5652: DEC
5653: ST_TO_ADDR
5654: LD_EXP 10
5658: PUSH
5659: FOR_TO
5660: IFFALSE 5765
// begin tmp := 0 ;
5662: LD_ADDR_VAR 0 2
5666: PUSH
5667: LD_STRING 0
5669: ST_TO_ADDR
// if result [ 2 ] then
5670: LD_VAR 0 1
5674: PUSH
5675: LD_INT 2
5677: ARRAY
5678: IFFALSE 5747
// if result [ 2 ] [ 1 ] = 100 + i then
5680: LD_VAR 0 1
5684: PUSH
5685: LD_INT 2
5687: ARRAY
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_INT 100
5695: PUSH
5696: LD_VAR 0 5
5700: PLUS
5701: EQUAL
5702: IFFALSE 5747
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5704: LD_ADDR_VAR 0 1
5708: PUSH
5709: LD_VAR 0 1
5713: PPUSH
5714: LD_INT 2
5716: PPUSH
5717: LD_VAR 0 1
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 1
5728: PPUSH
5729: CALL_OW 3
5733: PPUSH
5734: CALL_OW 1
5738: ST_TO_ADDR
// tmp := 1 ;
5739: LD_ADDR_VAR 0 2
5743: PUSH
5744: LD_STRING 1
5746: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5747: LD_ADDR_VAR 0 4
5751: PUSH
5752: LD_VAR 0 4
5756: PUSH
5757: LD_VAR 0 2
5761: STR
5762: ST_TO_ADDR
// end ;
5763: GO 5659
5765: POP
5766: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5767: LD_STRING getStreamItemsFromMission("
5769: PUSH
5770: LD_VAR 0 3
5774: STR
5775: PUSH
5776: LD_STRING ","
5778: STR
5779: PUSH
5780: LD_VAR 0 4
5784: STR
5785: PUSH
5786: LD_STRING ")
5788: STR
5789: PPUSH
5790: CALL_OW 559
// end else
5794: GO 5803
// ToLua ( getStreamItemsFromMission("","") ) ;
5796: LD_STRING getStreamItemsFromMission("","")
5798: PPUSH
5799: CALL_OW 559
// end ;
5803: LD_VAR 0 1
5807: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
5808: LD_VAR 0 2
5812: PUSH
5813: LD_INT 100
5815: EQUAL
5816: IFFALSE 6765
// begin if not StreamModeActive then
5818: LD_EXP 8
5822: NOT
5823: IFFALSE 5833
// StreamModeActive := true ;
5825: LD_ADDR_EXP 8
5829: PUSH
5830: LD_INT 1
5832: ST_TO_ADDR
// if p3 = 0 then
5833: LD_VAR 0 3
5837: PUSH
5838: LD_INT 0
5840: EQUAL
5841: IFFALSE 5847
// InitStreamMode ;
5843: CALL 1886 0 0
// if p3 = 1 then
5847: LD_VAR 0 3
5851: PUSH
5852: LD_INT 1
5854: EQUAL
5855: IFFALSE 5865
// sRocket := true ;
5857: LD_ADDR_EXP 13
5861: PUSH
5862: LD_INT 1
5864: ST_TO_ADDR
// if p3 = 2 then
5865: LD_VAR 0 3
5869: PUSH
5870: LD_INT 2
5872: EQUAL
5873: IFFALSE 5883
// sSpeed := true ;
5875: LD_ADDR_EXP 12
5879: PUSH
5880: LD_INT 1
5882: ST_TO_ADDR
// if p3 = 3 then
5883: LD_VAR 0 3
5887: PUSH
5888: LD_INT 3
5890: EQUAL
5891: IFFALSE 5901
// sEngine := true ;
5893: LD_ADDR_EXP 14
5897: PUSH
5898: LD_INT 1
5900: ST_TO_ADDR
// if p3 = 4 then
5901: LD_VAR 0 3
5905: PUSH
5906: LD_INT 4
5908: EQUAL
5909: IFFALSE 5919
// sSpec := true ;
5911: LD_ADDR_EXP 11
5915: PUSH
5916: LD_INT 1
5918: ST_TO_ADDR
// if p3 = 5 then
5919: LD_VAR 0 3
5923: PUSH
5924: LD_INT 5
5926: EQUAL
5927: IFFALSE 5937
// sLevel := true ;
5929: LD_ADDR_EXP 15
5933: PUSH
5934: LD_INT 1
5936: ST_TO_ADDR
// if p3 = 6 then
5937: LD_VAR 0 3
5941: PUSH
5942: LD_INT 6
5944: EQUAL
5945: IFFALSE 5955
// sArmoury := true ;
5947: LD_ADDR_EXP 16
5951: PUSH
5952: LD_INT 1
5954: ST_TO_ADDR
// if p3 = 7 then
5955: LD_VAR 0 3
5959: PUSH
5960: LD_INT 7
5962: EQUAL
5963: IFFALSE 5973
// sRadar := true ;
5965: LD_ADDR_EXP 17
5969: PUSH
5970: LD_INT 1
5972: ST_TO_ADDR
// if p3 = 8 then
5973: LD_VAR 0 3
5977: PUSH
5978: LD_INT 8
5980: EQUAL
5981: IFFALSE 5991
// sBunker := true ;
5983: LD_ADDR_EXP 18
5987: PUSH
5988: LD_INT 1
5990: ST_TO_ADDR
// if p3 = 9 then
5991: LD_VAR 0 3
5995: PUSH
5996: LD_INT 9
5998: EQUAL
5999: IFFALSE 6009
// sHack := true ;
6001: LD_ADDR_EXP 19
6005: PUSH
6006: LD_INT 1
6008: ST_TO_ADDR
// if p3 = 10 then
6009: LD_VAR 0 3
6013: PUSH
6014: LD_INT 10
6016: EQUAL
6017: IFFALSE 6027
// sFire := true ;
6019: LD_ADDR_EXP 20
6023: PUSH
6024: LD_INT 1
6026: ST_TO_ADDR
// if p3 = 11 then
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 11
6034: EQUAL
6035: IFFALSE 6045
// sRefresh := true ;
6037: LD_ADDR_EXP 21
6041: PUSH
6042: LD_INT 1
6044: ST_TO_ADDR
// if p3 = 12 then
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 12
6052: EQUAL
6053: IFFALSE 6063
// sExp := true ;
6055: LD_ADDR_EXP 22
6059: PUSH
6060: LD_INT 1
6062: ST_TO_ADDR
// if p3 = 13 then
6063: LD_VAR 0 3
6067: PUSH
6068: LD_INT 13
6070: EQUAL
6071: IFFALSE 6081
// sDepot := true ;
6073: LD_ADDR_EXP 23
6077: PUSH
6078: LD_INT 1
6080: ST_TO_ADDR
// if p3 = 14 then
6081: LD_VAR 0 3
6085: PUSH
6086: LD_INT 14
6088: EQUAL
6089: IFFALSE 6099
// sFlag := true ;
6091: LD_ADDR_EXP 24
6095: PUSH
6096: LD_INT 1
6098: ST_TO_ADDR
// if p3 = 15 then
6099: LD_VAR 0 3
6103: PUSH
6104: LD_INT 15
6106: EQUAL
6107: IFFALSE 6117
// sKamikadze := true ;
6109: LD_ADDR_EXP 32
6113: PUSH
6114: LD_INT 1
6116: ST_TO_ADDR
// if p3 = 16 then
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 16
6124: EQUAL
6125: IFFALSE 6135
// sTroll := true ;
6127: LD_ADDR_EXP 33
6131: PUSH
6132: LD_INT 1
6134: ST_TO_ADDR
// if p3 = 17 then
6135: LD_VAR 0 3
6139: PUSH
6140: LD_INT 17
6142: EQUAL
6143: IFFALSE 6153
// sSlow := true ;
6145: LD_ADDR_EXP 34
6149: PUSH
6150: LD_INT 1
6152: ST_TO_ADDR
// if p3 = 18 then
6153: LD_VAR 0 3
6157: PUSH
6158: LD_INT 18
6160: EQUAL
6161: IFFALSE 6171
// sLack := true ;
6163: LD_ADDR_EXP 35
6167: PUSH
6168: LD_INT 1
6170: ST_TO_ADDR
// if p3 = 19 then
6171: LD_VAR 0 3
6175: PUSH
6176: LD_INT 19
6178: EQUAL
6179: IFFALSE 6189
// sTank := true ;
6181: LD_ADDR_EXP 37
6185: PUSH
6186: LD_INT 1
6188: ST_TO_ADDR
// if p3 = 20 then
6189: LD_VAR 0 3
6193: PUSH
6194: LD_INT 20
6196: EQUAL
6197: IFFALSE 6207
// sRemote := true ;
6199: LD_ADDR_EXP 38
6203: PUSH
6204: LD_INT 1
6206: ST_TO_ADDR
// if p3 = 21 then
6207: LD_VAR 0 3
6211: PUSH
6212: LD_INT 21
6214: EQUAL
6215: IFFALSE 6225
// sPowell := true ;
6217: LD_ADDR_EXP 39
6221: PUSH
6222: LD_INT 1
6224: ST_TO_ADDR
// if p3 = 22 then
6225: LD_VAR 0 3
6229: PUSH
6230: LD_INT 22
6232: EQUAL
6233: IFFALSE 6243
// sTeleport := true ;
6235: LD_ADDR_EXP 42
6239: PUSH
6240: LD_INT 1
6242: ST_TO_ADDR
// if p3 = 23 then
6243: LD_VAR 0 3
6247: PUSH
6248: LD_INT 23
6250: EQUAL
6251: IFFALSE 6261
// sOilTower := true ;
6253: LD_ADDR_EXP 44
6257: PUSH
6258: LD_INT 1
6260: ST_TO_ADDR
// if p3 = 24 then
6261: LD_VAR 0 3
6265: PUSH
6266: LD_INT 24
6268: EQUAL
6269: IFFALSE 6279
// sShovel := true ;
6271: LD_ADDR_EXP 45
6275: PUSH
6276: LD_INT 1
6278: ST_TO_ADDR
// if p3 = 25 then
6279: LD_VAR 0 3
6283: PUSH
6284: LD_INT 25
6286: EQUAL
6287: IFFALSE 6297
// sSheik := true ;
6289: LD_ADDR_EXP 46
6293: PUSH
6294: LD_INT 1
6296: ST_TO_ADDR
// if p3 = 26 then
6297: LD_VAR 0 3
6301: PUSH
6302: LD_INT 26
6304: EQUAL
6305: IFFALSE 6315
// sEarthquake := true ;
6307: LD_ADDR_EXP 48
6311: PUSH
6312: LD_INT 1
6314: ST_TO_ADDR
// if p3 = 27 then
6315: LD_VAR 0 3
6319: PUSH
6320: LD_INT 27
6322: EQUAL
6323: IFFALSE 6333
// sAI := true ;
6325: LD_ADDR_EXP 49
6329: PUSH
6330: LD_INT 1
6332: ST_TO_ADDR
// if p3 = 28 then
6333: LD_VAR 0 3
6337: PUSH
6338: LD_INT 28
6340: EQUAL
6341: IFFALSE 6351
// sCargo := true ;
6343: LD_ADDR_EXP 52
6347: PUSH
6348: LD_INT 1
6350: ST_TO_ADDR
// if p3 = 29 then
6351: LD_VAR 0 3
6355: PUSH
6356: LD_INT 29
6358: EQUAL
6359: IFFALSE 6369
// sDLaser := true ;
6361: LD_ADDR_EXP 53
6365: PUSH
6366: LD_INT 1
6368: ST_TO_ADDR
// if p3 = 30 then
6369: LD_VAR 0 3
6373: PUSH
6374: LD_INT 30
6376: EQUAL
6377: IFFALSE 6387
// sExchange := true ;
6379: LD_ADDR_EXP 54
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// if p3 = 31 then
6387: LD_VAR 0 3
6391: PUSH
6392: LD_INT 31
6394: EQUAL
6395: IFFALSE 6405
// sFac := true ;
6397: LD_ADDR_EXP 55
6401: PUSH
6402: LD_INT 1
6404: ST_TO_ADDR
// if p3 = 32 then
6405: LD_VAR 0 3
6409: PUSH
6410: LD_INT 32
6412: EQUAL
6413: IFFALSE 6423
// sPower := true ;
6415: LD_ADDR_EXP 56
6419: PUSH
6420: LD_INT 1
6422: ST_TO_ADDR
// if p3 = 33 then
6423: LD_VAR 0 3
6427: PUSH
6428: LD_INT 33
6430: EQUAL
6431: IFFALSE 6441
// sRandom := true ;
6433: LD_ADDR_EXP 57
6437: PUSH
6438: LD_INT 1
6440: ST_TO_ADDR
// if p3 = 34 then
6441: LD_VAR 0 3
6445: PUSH
6446: LD_INT 34
6448: EQUAL
6449: IFFALSE 6459
// sShield := true ;
6451: LD_ADDR_EXP 58
6455: PUSH
6456: LD_INT 1
6458: ST_TO_ADDR
// if p3 = 35 then
6459: LD_VAR 0 3
6463: PUSH
6464: LD_INT 35
6466: EQUAL
6467: IFFALSE 6477
// sTime := true ;
6469: LD_ADDR_EXP 59
6473: PUSH
6474: LD_INT 1
6476: ST_TO_ADDR
// if p3 = 36 then
6477: LD_VAR 0 3
6481: PUSH
6482: LD_INT 36
6484: EQUAL
6485: IFFALSE 6495
// sTools := true ;
6487: LD_ADDR_EXP 60
6491: PUSH
6492: LD_INT 1
6494: ST_TO_ADDR
// if p3 = 101 then
6495: LD_VAR 0 3
6499: PUSH
6500: LD_INT 101
6502: EQUAL
6503: IFFALSE 6513
// sSold := true ;
6505: LD_ADDR_EXP 25
6509: PUSH
6510: LD_INT 1
6512: ST_TO_ADDR
// if p3 = 102 then
6513: LD_VAR 0 3
6517: PUSH
6518: LD_INT 102
6520: EQUAL
6521: IFFALSE 6531
// sDiff := true ;
6523: LD_ADDR_EXP 26
6527: PUSH
6528: LD_INT 1
6530: ST_TO_ADDR
// if p3 = 103 then
6531: LD_VAR 0 3
6535: PUSH
6536: LD_INT 103
6538: EQUAL
6539: IFFALSE 6549
// sFog := true ;
6541: LD_ADDR_EXP 29
6545: PUSH
6546: LD_INT 1
6548: ST_TO_ADDR
// if p3 = 104 then
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 104
6556: EQUAL
6557: IFFALSE 6567
// sReset := true ;
6559: LD_ADDR_EXP 30
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
// if p3 = 105 then
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 105
6574: EQUAL
6575: IFFALSE 6585
// sSun := true ;
6577: LD_ADDR_EXP 31
6581: PUSH
6582: LD_INT 1
6584: ST_TO_ADDR
// if p3 = 106 then
6585: LD_VAR 0 3
6589: PUSH
6590: LD_INT 106
6592: EQUAL
6593: IFFALSE 6603
// sTiger := true ;
6595: LD_ADDR_EXP 27
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// if p3 = 107 then
6603: LD_VAR 0 3
6607: PUSH
6608: LD_INT 107
6610: EQUAL
6611: IFFALSE 6621
// sBomb := true ;
6613: LD_ADDR_EXP 28
6617: PUSH
6618: LD_INT 1
6620: ST_TO_ADDR
// if p3 = 108 then
6621: LD_VAR 0 3
6625: PUSH
6626: LD_INT 108
6628: EQUAL
6629: IFFALSE 6639
// sWound := true ;
6631: LD_ADDR_EXP 36
6635: PUSH
6636: LD_INT 1
6638: ST_TO_ADDR
// if p3 = 109 then
6639: LD_VAR 0 3
6643: PUSH
6644: LD_INT 109
6646: EQUAL
6647: IFFALSE 6657
// sBetray := true ;
6649: LD_ADDR_EXP 40
6653: PUSH
6654: LD_INT 1
6656: ST_TO_ADDR
// if p3 = 110 then
6657: LD_VAR 0 3
6661: PUSH
6662: LD_INT 110
6664: EQUAL
6665: IFFALSE 6675
// sContamin := true ;
6667: LD_ADDR_EXP 41
6671: PUSH
6672: LD_INT 1
6674: ST_TO_ADDR
// if p3 = 111 then
6675: LD_VAR 0 3
6679: PUSH
6680: LD_INT 111
6682: EQUAL
6683: IFFALSE 6693
// sOil := true ;
6685: LD_ADDR_EXP 43
6689: PUSH
6690: LD_INT 1
6692: ST_TO_ADDR
// if p3 = 112 then
6693: LD_VAR 0 3
6697: PUSH
6698: LD_INT 112
6700: EQUAL
6701: IFFALSE 6711
// sStu := true ;
6703: LD_ADDR_EXP 47
6707: PUSH
6708: LD_INT 1
6710: ST_TO_ADDR
// if p3 = 113 then
6711: LD_VAR 0 3
6715: PUSH
6716: LD_INT 113
6718: EQUAL
6719: IFFALSE 6729
// sBazooka := true ;
6721: LD_ADDR_EXP 50
6725: PUSH
6726: LD_INT 1
6728: ST_TO_ADDR
// if p3 = 114 then
6729: LD_VAR 0 3
6733: PUSH
6734: LD_INT 114
6736: EQUAL
6737: IFFALSE 6747
// sMortar := true ;
6739: LD_ADDR_EXP 51
6743: PUSH
6744: LD_INT 1
6746: ST_TO_ADDR
// if p3 = 115 then
6747: LD_VAR 0 3
6751: PUSH
6752: LD_INT 115
6754: EQUAL
6755: IFFALSE 6765
// sRanger := true ;
6757: LD_ADDR_EXP 61
6761: PUSH
6762: LD_INT 1
6764: ST_TO_ADDR
// end ; end ;
6765: PPOPN 6
6767: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
6768: LD_EXP 8
6772: PUSH
6773: LD_EXP 13
6777: AND
6778: IFFALSE 6902
6780: GO 6782
6782: DISABLE
6783: LD_INT 0
6785: PPUSH
6786: PPUSH
// begin enable ;
6787: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
6788: LD_ADDR_VAR 0 2
6792: PUSH
6793: LD_INT 22
6795: PUSH
6796: LD_OWVAR 2
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: PUSH
6805: LD_INT 2
6807: PUSH
6808: LD_INT 34
6810: PUSH
6811: LD_INT 7
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 34
6820: PUSH
6821: LD_INT 45
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PUSH
6828: LD_INT 34
6830: PUSH
6831: LD_INT 28
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: PUSH
6838: LD_INT 34
6840: PUSH
6841: LD_INT 47
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PUSH
6848: EMPTY
6849: LIST
6850: LIST
6851: LIST
6852: LIST
6853: LIST
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: PPUSH
6859: CALL_OW 69
6863: ST_TO_ADDR
// if not tmp then
6864: LD_VAR 0 2
6868: NOT
6869: IFFALSE 6873
// exit ;
6871: GO 6902
// for i in tmp do
6873: LD_ADDR_VAR 0 1
6877: PUSH
6878: LD_VAR 0 2
6882: PUSH
6883: FOR_IN
6884: IFFALSE 6900
// begin SetLives ( i , 0 ) ;
6886: LD_VAR 0 1
6890: PPUSH
6891: LD_INT 0
6893: PPUSH
6894: CALL_OW 234
// end ;
6898: GO 6883
6900: POP
6901: POP
// end ;
6902: PPOPN 2
6904: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
6905: LD_EXP 8
6909: PUSH
6910: LD_EXP 14
6914: AND
6915: IFFALSE 6999
6917: GO 6919
6919: DISABLE
6920: LD_INT 0
6922: PPUSH
6923: PPUSH
// begin enable ;
6924: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: LD_INT 22
6932: PUSH
6933: LD_OWVAR 2
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PUSH
6942: LD_INT 32
6944: PUSH
6945: LD_INT 3
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL_OW 69
6960: ST_TO_ADDR
// if not tmp then
6961: LD_VAR 0 2
6965: NOT
6966: IFFALSE 6970
// exit ;
6968: GO 6999
// for i in tmp do
6970: LD_ADDR_VAR 0 1
6974: PUSH
6975: LD_VAR 0 2
6979: PUSH
6980: FOR_IN
6981: IFFALSE 6997
// begin SetLives ( i , 0 ) ;
6983: LD_VAR 0 1
6987: PPUSH
6988: LD_INT 0
6990: PPUSH
6991: CALL_OW 234
// end ;
6995: GO 6980
6997: POP
6998: POP
// end ;
6999: PPOPN 2
7001: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7002: LD_EXP 8
7006: PUSH
7007: LD_EXP 11
7011: AND
7012: IFFALSE 7105
7014: GO 7016
7016: DISABLE
7017: LD_INT 0
7019: PPUSH
// begin enable ;
7020: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7021: LD_ADDR_VAR 0 1
7025: PUSH
7026: LD_INT 22
7028: PUSH
7029: LD_OWVAR 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 2
7040: PUSH
7041: LD_INT 25
7043: PUSH
7044: LD_INT 5
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: PUSH
7051: LD_INT 25
7053: PUSH
7054: LD_INT 9
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PUSH
7061: LD_INT 25
7063: PUSH
7064: LD_INT 8
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: LIST
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PPUSH
7081: CALL_OW 69
7085: PUSH
7086: FOR_IN
7087: IFFALSE 7103
// begin SetClass ( i , 1 ) ;
7089: LD_VAR 0 1
7093: PPUSH
7094: LD_INT 1
7096: PPUSH
7097: CALL_OW 336
// end ;
7101: GO 7086
7103: POP
7104: POP
// end ;
7105: PPOPN 1
7107: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7108: LD_EXP 8
7112: PUSH
7113: LD_EXP 12
7117: AND
7118: PUSH
7119: LD_OWVAR 65
7123: PUSH
7124: LD_INT 7
7126: LESS
7127: AND
7128: IFFALSE 7142
7130: GO 7132
7132: DISABLE
// begin enable ;
7133: ENABLE
// game_speed := 7 ;
7134: LD_ADDR_OWVAR 65
7138: PUSH
7139: LD_INT 7
7141: ST_TO_ADDR
// end ;
7142: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7143: LD_EXP 8
7147: PUSH
7148: LD_EXP 15
7152: AND
7153: IFFALSE 7355
7155: GO 7157
7157: DISABLE
7158: LD_INT 0
7160: PPUSH
7161: PPUSH
7162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7163: LD_ADDR_VAR 0 3
7167: PUSH
7168: LD_INT 81
7170: PUSH
7171: LD_OWVAR 2
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 21
7182: PUSH
7183: LD_INT 1
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: ST_TO_ADDR
// if not tmp then
7199: LD_VAR 0 3
7203: NOT
7204: IFFALSE 7208
// exit ;
7206: GO 7355
// if tmp > 5 then
7208: LD_VAR 0 3
7212: PUSH
7213: LD_INT 5
7215: GREATER
7216: IFFALSE 7228
// k := 5 else
7218: LD_ADDR_VAR 0 2
7222: PUSH
7223: LD_INT 5
7225: ST_TO_ADDR
7226: GO 7238
// k := tmp ;
7228: LD_ADDR_VAR 0 2
7232: PUSH
7233: LD_VAR 0 3
7237: ST_TO_ADDR
// for i := 1 to k do
7238: LD_ADDR_VAR 0 1
7242: PUSH
7243: DOUBLE
7244: LD_INT 1
7246: DEC
7247: ST_TO_ADDR
7248: LD_VAR 0 2
7252: PUSH
7253: FOR_TO
7254: IFFALSE 7353
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7256: LD_VAR 0 3
7260: PUSH
7261: LD_VAR 0 1
7265: ARRAY
7266: PPUSH
7267: LD_VAR 0 1
7271: PUSH
7272: LD_INT 4
7274: MOD
7275: PUSH
7276: LD_INT 1
7278: PLUS
7279: PPUSH
7280: CALL_OW 259
7284: PUSH
7285: LD_INT 10
7287: LESS
7288: IFFALSE 7351
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7290: LD_VAR 0 3
7294: PUSH
7295: LD_VAR 0 1
7299: ARRAY
7300: PPUSH
7301: LD_VAR 0 1
7305: PUSH
7306: LD_INT 4
7308: MOD
7309: PUSH
7310: LD_INT 1
7312: PLUS
7313: PPUSH
7314: LD_VAR 0 3
7318: PUSH
7319: LD_VAR 0 1
7323: ARRAY
7324: PPUSH
7325: LD_VAR 0 1
7329: PUSH
7330: LD_INT 4
7332: MOD
7333: PUSH
7334: LD_INT 1
7336: PLUS
7337: PPUSH
7338: CALL_OW 259
7342: PUSH
7343: LD_INT 1
7345: PLUS
7346: PPUSH
7347: CALL_OW 237
7351: GO 7253
7353: POP
7354: POP
// end ;
7355: PPOPN 3
7357: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7358: LD_EXP 8
7362: PUSH
7363: LD_EXP 16
7367: AND
7368: IFFALSE 7388
7370: GO 7372
7372: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7373: LD_INT 4
7375: PPUSH
7376: LD_OWVAR 2
7380: PPUSH
7381: LD_INT 0
7383: PPUSH
7384: CALL_OW 324
7388: END
// every 0 0$1 trigger StreamModeActive and sShovel do
7389: LD_EXP 8
7393: PUSH
7394: LD_EXP 45
7398: AND
7399: IFFALSE 7419
7401: GO 7403
7403: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
7404: LD_INT 19
7406: PPUSH
7407: LD_OWVAR 2
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 324
7419: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7420: LD_EXP 8
7424: PUSH
7425: LD_EXP 17
7429: AND
7430: IFFALSE 7532
7432: GO 7434
7434: DISABLE
7435: LD_INT 0
7437: PPUSH
7438: PPUSH
// begin enable ;
7439: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7440: LD_ADDR_VAR 0 2
7444: PUSH
7445: LD_INT 22
7447: PUSH
7448: LD_OWVAR 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 2
7459: PUSH
7460: LD_INT 34
7462: PUSH
7463: LD_INT 11
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: LD_INT 34
7472: PUSH
7473: LD_INT 30
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PPUSH
7489: CALL_OW 69
7493: ST_TO_ADDR
// if not tmp then
7494: LD_VAR 0 2
7498: NOT
7499: IFFALSE 7503
// exit ;
7501: GO 7532
// for i in tmp do
7503: LD_ADDR_VAR 0 1
7507: PUSH
7508: LD_VAR 0 2
7512: PUSH
7513: FOR_IN
7514: IFFALSE 7530
// begin SetLives ( i , 0 ) ;
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 0
7523: PPUSH
7524: CALL_OW 234
// end ;
7528: GO 7513
7530: POP
7531: POP
// end ;
7532: PPOPN 2
7534: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7535: LD_EXP 8
7539: PUSH
7540: LD_EXP 18
7544: AND
7545: IFFALSE 7565
7547: GO 7549
7549: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7550: LD_INT 32
7552: PPUSH
7553: LD_OWVAR 2
7557: PPUSH
7558: LD_INT 0
7560: PPUSH
7561: CALL_OW 324
7565: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
7566: LD_EXP 8
7570: PUSH
7571: LD_EXP 19
7575: AND
7576: IFFALSE 7757
7578: GO 7580
7580: DISABLE
7581: LD_INT 0
7583: PPUSH
7584: PPUSH
7585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
7586: LD_ADDR_VAR 0 2
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_OWVAR 2
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: LD_INT 33
7605: PUSH
7606: LD_INT 3
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: ST_TO_ADDR
// if not tmp then
7622: LD_VAR 0 2
7626: NOT
7627: IFFALSE 7631
// exit ;
7629: GO 7757
// side := 0 ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_INT 0
7638: ST_TO_ADDR
// for i := 1 to 8 do
7639: LD_ADDR_VAR 0 1
7643: PUSH
7644: DOUBLE
7645: LD_INT 1
7647: DEC
7648: ST_TO_ADDR
7649: LD_INT 8
7651: PUSH
7652: FOR_TO
7653: IFFALSE 7701
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7655: LD_OWVAR 2
7659: PUSH
7660: LD_VAR 0 1
7664: NONEQUAL
7665: PUSH
7666: LD_OWVAR 2
7670: PPUSH
7671: LD_VAR 0 1
7675: PPUSH
7676: CALL_OW 81
7680: PUSH
7681: LD_INT 2
7683: EQUAL
7684: AND
7685: IFFALSE 7699
// begin side := i ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_VAR 0 1
7696: ST_TO_ADDR
// break ;
7697: GO 7701
// end ;
7699: GO 7652
7701: POP
7702: POP
// if not side then
7703: LD_VAR 0 3
7707: NOT
7708: IFFALSE 7712
// exit ;
7710: GO 7757
// for i := 1 to tmp do
7712: LD_ADDR_VAR 0 1
7716: PUSH
7717: DOUBLE
7718: LD_INT 1
7720: DEC
7721: ST_TO_ADDR
7722: LD_VAR 0 2
7726: PUSH
7727: FOR_TO
7728: IFFALSE 7755
// if Prob ( 60 ) then
7730: LD_INT 60
7732: PPUSH
7733: CALL_OW 13
7737: IFFALSE 7753
// SetSide ( i , side ) ;
7739: LD_VAR 0 1
7743: PPUSH
7744: LD_VAR 0 3
7748: PPUSH
7749: CALL_OW 235
7753: GO 7727
7755: POP
7756: POP
// end ;
7757: PPOPN 3
7759: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
7760: LD_EXP 8
7764: PUSH
7765: LD_EXP 21
7769: AND
7770: IFFALSE 7889
7772: GO 7774
7774: DISABLE
7775: LD_INT 0
7777: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
7778: LD_ADDR_VAR 0 1
7782: PUSH
7783: LD_INT 22
7785: PUSH
7786: LD_OWVAR 2
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: PUSH
7795: LD_INT 21
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PUSH
7805: LD_INT 3
7807: PUSH
7808: LD_INT 23
7810: PUSH
7811: LD_INT 0
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: LIST
7826: PPUSH
7827: CALL_OW 69
7831: PUSH
7832: FOR_IN
7833: IFFALSE 7887
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
7835: LD_VAR 0 1
7839: PPUSH
7840: CALL_OW 257
7844: PUSH
7845: LD_INT 1
7847: PUSH
7848: LD_INT 2
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: LD_INT 4
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: IN
7863: IFFALSE 7885
// SetClass ( un , rand ( 1 , 4 ) ) ;
7865: LD_VAR 0 1
7869: PPUSH
7870: LD_INT 1
7872: PPUSH
7873: LD_INT 4
7875: PPUSH
7876: CALL_OW 12
7880: PPUSH
7881: CALL_OW 336
7885: GO 7832
7887: POP
7888: POP
// end ;
7889: PPOPN 1
7891: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
7892: LD_EXP 8
7896: PUSH
7897: LD_EXP 20
7901: AND
7902: IFFALSE 7981
7904: GO 7906
7906: DISABLE
7907: LD_INT 0
7909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7910: LD_ADDR_VAR 0 1
7914: PUSH
7915: LD_INT 22
7917: PUSH
7918: LD_OWVAR 2
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 21
7929: PUSH
7930: LD_INT 3
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: ST_TO_ADDR
// if not tmp then
7946: LD_VAR 0 1
7950: NOT
7951: IFFALSE 7955
// exit ;
7953: GO 7981
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
7955: LD_VAR 0 1
7959: PUSH
7960: LD_INT 1
7962: PPUSH
7963: LD_VAR 0 1
7967: PPUSH
7968: CALL_OW 12
7972: ARRAY
7973: PPUSH
7974: LD_INT 100
7976: PPUSH
7977: CALL_OW 234
// end ;
7981: PPOPN 1
7983: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
7984: LD_EXP 8
7988: PUSH
7989: LD_EXP 22
7993: AND
7994: IFFALSE 8092
7996: GO 7998
7998: DISABLE
7999: LD_INT 0
8001: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8002: LD_ADDR_VAR 0 1
8006: PUSH
8007: LD_INT 22
8009: PUSH
8010: LD_OWVAR 2
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 21
8021: PUSH
8022: LD_INT 1
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PPUSH
8033: CALL_OW 69
8037: ST_TO_ADDR
// if not tmp then
8038: LD_VAR 0 1
8042: NOT
8043: IFFALSE 8047
// exit ;
8045: GO 8092
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8047: LD_VAR 0 1
8051: PUSH
8052: LD_INT 1
8054: PPUSH
8055: LD_VAR 0 1
8059: PPUSH
8060: CALL_OW 12
8064: ARRAY
8065: PPUSH
8066: LD_INT 1
8068: PPUSH
8069: LD_INT 4
8071: PPUSH
8072: CALL_OW 12
8076: PPUSH
8077: LD_INT 3000
8079: PPUSH
8080: LD_INT 9000
8082: PPUSH
8083: CALL_OW 12
8087: PPUSH
8088: CALL_OW 492
// end ;
8092: PPOPN 1
8094: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8095: LD_EXP 8
8099: PUSH
8100: LD_EXP 23
8104: AND
8105: IFFALSE 8125
8107: GO 8109
8109: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8110: LD_INT 1
8112: PPUSH
8113: LD_OWVAR 2
8117: PPUSH
8118: LD_INT 0
8120: PPUSH
8121: CALL_OW 324
8125: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8126: LD_EXP 8
8130: PUSH
8131: LD_EXP 24
8135: AND
8136: IFFALSE 8219
8138: GO 8140
8140: DISABLE
8141: LD_INT 0
8143: PPUSH
8144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8145: LD_ADDR_VAR 0 2
8149: PUSH
8150: LD_INT 22
8152: PUSH
8153: LD_OWVAR 2
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: LD_INT 21
8164: PUSH
8165: LD_INT 3
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: PPUSH
8176: CALL_OW 69
8180: ST_TO_ADDR
// if not tmp then
8181: LD_VAR 0 2
8185: NOT
8186: IFFALSE 8190
// exit ;
8188: GO 8219
// for i in tmp do
8190: LD_ADDR_VAR 0 1
8194: PUSH
8195: LD_VAR 0 2
8199: PUSH
8200: FOR_IN
8201: IFFALSE 8217
// SetBLevel ( i , 10 ) ;
8203: LD_VAR 0 1
8207: PPUSH
8208: LD_INT 10
8210: PPUSH
8211: CALL_OW 241
8215: GO 8200
8217: POP
8218: POP
// end ;
8219: PPOPN 2
8221: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8222: LD_EXP 8
8226: PUSH
8227: LD_EXP 25
8231: AND
8232: IFFALSE 8343
8234: GO 8236
8236: DISABLE
8237: LD_INT 0
8239: PPUSH
8240: PPUSH
8241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: LD_INT 22
8249: PUSH
8250: LD_OWVAR 2
8254: PUSH
8255: EMPTY
8256: LIST
8257: LIST
8258: PUSH
8259: LD_INT 25
8261: PUSH
8262: LD_INT 1
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: PPUSH
8273: CALL_OW 69
8277: ST_TO_ADDR
// if not tmp then
8278: LD_VAR 0 3
8282: NOT
8283: IFFALSE 8287
// exit ;
8285: GO 8343
// un := tmp [ rand ( 1 , tmp ) ] ;
8287: LD_ADDR_VAR 0 2
8291: PUSH
8292: LD_VAR 0 3
8296: PUSH
8297: LD_INT 1
8299: PPUSH
8300: LD_VAR 0 3
8304: PPUSH
8305: CALL_OW 12
8309: ARRAY
8310: ST_TO_ADDR
// if Crawls ( un ) then
8311: LD_VAR 0 2
8315: PPUSH
8316: CALL_OW 318
8320: IFFALSE 8331
// ComWalk ( un ) ;
8322: LD_VAR 0 2
8326: PPUSH
8327: CALL_OW 138
// SetClass ( un , class_sniper ) ;
8331: LD_VAR 0 2
8335: PPUSH
8336: LD_INT 5
8338: PPUSH
8339: CALL_OW 336
// end ;
8343: PPOPN 3
8345: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8346: LD_EXP 8
8350: PUSH
8351: LD_EXP 26
8355: AND
8356: PUSH
8357: LD_OWVAR 67
8361: PUSH
8362: LD_INT 3
8364: LESS
8365: AND
8366: IFFALSE 8385
8368: GO 8370
8370: DISABLE
// Difficulty := Difficulty + 1 ;
8371: LD_ADDR_OWVAR 67
8375: PUSH
8376: LD_OWVAR 67
8380: PUSH
8381: LD_INT 1
8383: PLUS
8384: ST_TO_ADDR
8385: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8386: LD_EXP 8
8390: PUSH
8391: LD_EXP 27
8395: AND
8396: IFFALSE 8499
8398: GO 8400
8400: DISABLE
8401: LD_INT 0
8403: PPUSH
// begin for i := 1 to 5 do
8404: LD_ADDR_VAR 0 1
8408: PUSH
8409: DOUBLE
8410: LD_INT 1
8412: DEC
8413: ST_TO_ADDR
8414: LD_INT 5
8416: PUSH
8417: FOR_TO
8418: IFFALSE 8497
// begin uc_nation := nation_nature ;
8420: LD_ADDR_OWVAR 21
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// uc_side := 0 ;
8428: LD_ADDR_OWVAR 20
8432: PUSH
8433: LD_INT 0
8435: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8436: LD_ADDR_OWVAR 29
8440: PUSH
8441: LD_INT 12
8443: PUSH
8444: LD_INT 12
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: ST_TO_ADDR
// hc_agressivity := 20 ;
8451: LD_ADDR_OWVAR 35
8455: PUSH
8456: LD_INT 20
8458: ST_TO_ADDR
// hc_class := class_tiger ;
8459: LD_ADDR_OWVAR 28
8463: PUSH
8464: LD_INT 14
8466: ST_TO_ADDR
// hc_gallery :=  ;
8467: LD_ADDR_OWVAR 33
8471: PUSH
8472: LD_STRING 
8474: ST_TO_ADDR
// hc_name :=  ;
8475: LD_ADDR_OWVAR 26
8479: PUSH
8480: LD_STRING 
8482: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8483: CALL_OW 44
8487: PPUSH
8488: LD_INT 0
8490: PPUSH
8491: CALL_OW 51
// end ;
8495: GO 8417
8497: POP
8498: POP
// end ;
8499: PPOPN 1
8501: END
// every 0 0$1 trigger StreamModeActive and sBomb do
8502: LD_EXP 8
8506: PUSH
8507: LD_EXP 28
8511: AND
8512: IFFALSE 8521
8514: GO 8516
8516: DISABLE
// StreamSibBomb ;
8517: CALL 8522 0 0
8521: END
// export function StreamSibBomb ; var i , x , y ; begin
8522: LD_INT 0
8524: PPUSH
8525: PPUSH
8526: PPUSH
8527: PPUSH
// result := false ;
8528: LD_ADDR_VAR 0 1
8532: PUSH
8533: LD_INT 0
8535: ST_TO_ADDR
// for i := 1 to 16 do
8536: LD_ADDR_VAR 0 2
8540: PUSH
8541: DOUBLE
8542: LD_INT 1
8544: DEC
8545: ST_TO_ADDR
8546: LD_INT 16
8548: PUSH
8549: FOR_TO
8550: IFFALSE 8749
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8552: LD_ADDR_VAR 0 3
8556: PUSH
8557: LD_INT 10
8559: PUSH
8560: LD_INT 20
8562: PUSH
8563: LD_INT 30
8565: PUSH
8566: LD_INT 40
8568: PUSH
8569: LD_INT 50
8571: PUSH
8572: LD_INT 60
8574: PUSH
8575: LD_INT 70
8577: PUSH
8578: LD_INT 80
8580: PUSH
8581: LD_INT 90
8583: PUSH
8584: LD_INT 100
8586: PUSH
8587: LD_INT 110
8589: PUSH
8590: LD_INT 120
8592: PUSH
8593: LD_INT 130
8595: PUSH
8596: LD_INT 140
8598: PUSH
8599: LD_INT 150
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: LIST
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: LIST
8618: PUSH
8619: LD_INT 1
8621: PPUSH
8622: LD_INT 15
8624: PPUSH
8625: CALL_OW 12
8629: ARRAY
8630: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_INT 10
8638: PUSH
8639: LD_INT 20
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 40
8647: PUSH
8648: LD_INT 50
8650: PUSH
8651: LD_INT 60
8653: PUSH
8654: LD_INT 70
8656: PUSH
8657: LD_INT 80
8659: PUSH
8660: LD_INT 90
8662: PUSH
8663: LD_INT 100
8665: PUSH
8666: LD_INT 110
8668: PUSH
8669: LD_INT 120
8671: PUSH
8672: LD_INT 130
8674: PUSH
8675: LD_INT 140
8677: PUSH
8678: LD_INT 150
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_INT 1
8700: PPUSH
8701: LD_INT 15
8703: PPUSH
8704: CALL_OW 12
8708: ARRAY
8709: ST_TO_ADDR
// if ValidHex ( x , y ) then
8710: LD_VAR 0 3
8714: PPUSH
8715: LD_VAR 0 4
8719: PPUSH
8720: CALL_OW 488
8724: IFFALSE 8747
// begin result := [ x , y ] ;
8726: LD_ADDR_VAR 0 1
8730: PUSH
8731: LD_VAR 0 3
8735: PUSH
8736: LD_VAR 0 4
8740: PUSH
8741: EMPTY
8742: LIST
8743: LIST
8744: ST_TO_ADDR
// break ;
8745: GO 8749
// end ; end ;
8747: GO 8549
8749: POP
8750: POP
// if result then
8751: LD_VAR 0 1
8755: IFFALSE 8815
// begin ToLua ( playSibBomb() ) ;
8757: LD_STRING playSibBomb()
8759: PPUSH
8760: CALL_OW 559
// wait ( 0 0$14 ) ;
8764: LD_INT 490
8766: PPUSH
8767: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
8771: LD_VAR 0 1
8775: PUSH
8776: LD_INT 1
8778: ARRAY
8779: PPUSH
8780: LD_VAR 0 1
8784: PUSH
8785: LD_INT 2
8787: ARRAY
8788: PPUSH
8789: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
8793: LD_VAR 0 1
8797: PUSH
8798: LD_INT 1
8800: ARRAY
8801: PPUSH
8802: LD_VAR 0 1
8806: PUSH
8807: LD_INT 2
8809: ARRAY
8810: PPUSH
8811: CALL_OW 429
// end ; end ;
8815: LD_VAR 0 1
8819: RET
// every 0 0$1 trigger StreamModeActive and sReset do
8820: LD_EXP 8
8824: PUSH
8825: LD_EXP 30
8829: AND
8830: IFFALSE 8842
8832: GO 8834
8834: DISABLE
// YouLost (  ) ;
8835: LD_STRING 
8837: PPUSH
8838: CALL_OW 104
8842: END
// every 0 0$1 trigger StreamModeActive and sFog do
8843: LD_EXP 8
8847: PUSH
8848: LD_EXP 29
8852: AND
8853: IFFALSE 8867
8855: GO 8857
8857: DISABLE
// FogOff ( your_side ) ;
8858: LD_OWVAR 2
8862: PPUSH
8863: CALL_OW 344
8867: END
// every 0 0$1 trigger StreamModeActive and sSun do
8868: LD_EXP 8
8872: PUSH
8873: LD_EXP 31
8877: AND
8878: IFFALSE 8906
8880: GO 8882
8882: DISABLE
// begin solar_recharge_percent := 0 ;
8883: LD_ADDR_OWVAR 79
8887: PUSH
8888: LD_INT 0
8890: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8891: LD_INT 10500
8893: PPUSH
8894: CALL_OW 67
// solar_recharge_percent := 100 ;
8898: LD_ADDR_OWVAR 79
8902: PUSH
8903: LD_INT 100
8905: ST_TO_ADDR
// end ;
8906: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
8907: LD_EXP 8
8911: PUSH
8912: LD_EXP 32
8916: AND
8917: IFFALSE 9156
8919: GO 8921
8921: DISABLE
8922: LD_INT 0
8924: PPUSH
8925: PPUSH
8926: PPUSH
// begin tmp := [ ] ;
8927: LD_ADDR_VAR 0 3
8931: PUSH
8932: EMPTY
8933: ST_TO_ADDR
// for i := 1 to 6 do
8934: LD_ADDR_VAR 0 1
8938: PUSH
8939: DOUBLE
8940: LD_INT 1
8942: DEC
8943: ST_TO_ADDR
8944: LD_INT 6
8946: PUSH
8947: FOR_TO
8948: IFFALSE 9053
// begin uc_nation := nation_nature ;
8950: LD_ADDR_OWVAR 21
8954: PUSH
8955: LD_INT 0
8957: ST_TO_ADDR
// uc_side := 0 ;
8958: LD_ADDR_OWVAR 20
8962: PUSH
8963: LD_INT 0
8965: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8966: LD_ADDR_OWVAR 29
8970: PUSH
8971: LD_INT 12
8973: PUSH
8974: LD_INT 12
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: ST_TO_ADDR
// hc_agressivity := 20 ;
8981: LD_ADDR_OWVAR 35
8985: PUSH
8986: LD_INT 20
8988: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
8989: LD_ADDR_OWVAR 28
8993: PUSH
8994: LD_INT 17
8996: ST_TO_ADDR
// hc_gallery :=  ;
8997: LD_ADDR_OWVAR 33
9001: PUSH
9002: LD_STRING 
9004: ST_TO_ADDR
// hc_name :=  ;
9005: LD_ADDR_OWVAR 26
9009: PUSH
9010: LD_STRING 
9012: ST_TO_ADDR
// un := CreateHuman ;
9013: LD_ADDR_VAR 0 2
9017: PUSH
9018: CALL_OW 44
9022: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9023: LD_VAR 0 2
9027: PPUSH
9028: LD_INT 1
9030: PPUSH
9031: CALL_OW 51
// tmp := tmp ^ un ;
9035: LD_ADDR_VAR 0 3
9039: PUSH
9040: LD_VAR 0 3
9044: PUSH
9045: LD_VAR 0 2
9049: ADD
9050: ST_TO_ADDR
// end ;
9051: GO 8947
9053: POP
9054: POP
// repeat wait ( 0 0$1 ) ;
9055: LD_INT 35
9057: PPUSH
9058: CALL_OW 67
// for un in tmp do
9062: LD_ADDR_VAR 0 2
9066: PUSH
9067: LD_VAR 0 3
9071: PUSH
9072: FOR_IN
9073: IFFALSE 9147
// begin if IsDead ( un ) then
9075: LD_VAR 0 2
9079: PPUSH
9080: CALL_OW 301
9084: IFFALSE 9104
// begin tmp := tmp diff un ;
9086: LD_ADDR_VAR 0 3
9090: PUSH
9091: LD_VAR 0 3
9095: PUSH
9096: LD_VAR 0 2
9100: DIFF
9101: ST_TO_ADDR
// continue ;
9102: GO 9072
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9104: LD_VAR 0 2
9108: PPUSH
9109: LD_INT 3
9111: PUSH
9112: LD_INT 22
9114: PUSH
9115: LD_INT 0
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PPUSH
9126: CALL_OW 69
9130: PPUSH
9131: LD_VAR 0 2
9135: PPUSH
9136: CALL_OW 74
9140: PPUSH
9141: CALL_OW 115
// end ;
9145: GO 9072
9147: POP
9148: POP
// until not tmp ;
9149: LD_VAR 0 3
9153: NOT
9154: IFFALSE 9055
// end ;
9156: PPOPN 3
9158: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9159: LD_EXP 8
9163: PUSH
9164: LD_EXP 33
9168: AND
9169: IFFALSE 9223
9171: GO 9173
9173: DISABLE
// begin ToLua ( displayTroll(); ) ;
9174: LD_STRING displayTroll();
9176: PPUSH
9177: CALL_OW 559
// wait ( 3 3$00 ) ;
9181: LD_INT 6300
9183: PPUSH
9184: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9188: LD_STRING hideTroll();
9190: PPUSH
9191: CALL_OW 559
// wait ( 1 1$00 ) ;
9195: LD_INT 2100
9197: PPUSH
9198: CALL_OW 67
// ToLua ( displayTroll(); ) ;
9202: LD_STRING displayTroll();
9204: PPUSH
9205: CALL_OW 559
// wait ( 1 1$00 ) ;
9209: LD_INT 2100
9211: PPUSH
9212: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9216: LD_STRING hideTroll();
9218: PPUSH
9219: CALL_OW 559
// end ;
9223: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9224: LD_EXP 8
9228: PUSH
9229: LD_EXP 34
9233: AND
9234: IFFALSE 9297
9236: GO 9238
9238: DISABLE
9239: LD_INT 0
9241: PPUSH
// begin p := 0 ;
9242: LD_ADDR_VAR 0 1
9246: PUSH
9247: LD_INT 0
9249: ST_TO_ADDR
// repeat game_speed := 1 ;
9250: LD_ADDR_OWVAR 65
9254: PUSH
9255: LD_INT 1
9257: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9258: LD_INT 35
9260: PPUSH
9261: CALL_OW 67
// p := p + 1 ;
9265: LD_ADDR_VAR 0 1
9269: PUSH
9270: LD_VAR 0 1
9274: PUSH
9275: LD_INT 1
9277: PLUS
9278: ST_TO_ADDR
// until p >= 60 ;
9279: LD_VAR 0 1
9283: PUSH
9284: LD_INT 60
9286: GREATEREQUAL
9287: IFFALSE 9250
// game_speed := 4 ;
9289: LD_ADDR_OWVAR 65
9293: PUSH
9294: LD_INT 4
9296: ST_TO_ADDR
// end ;
9297: PPOPN 1
9299: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9300: LD_EXP 8
9304: PUSH
9305: LD_EXP 35
9309: AND
9310: IFFALSE 9456
9312: GO 9314
9314: DISABLE
9315: LD_INT 0
9317: PPUSH
9318: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9319: LD_ADDR_VAR 0 1
9323: PUSH
9324: LD_INT 22
9326: PUSH
9327: LD_OWVAR 2
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 2
9338: PUSH
9339: LD_INT 30
9341: PUSH
9342: LD_INT 0
9344: PUSH
9345: EMPTY
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 30
9351: PUSH
9352: LD_INT 1
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PPUSH
9368: CALL_OW 69
9372: ST_TO_ADDR
// if not depot then
9373: LD_VAR 0 1
9377: NOT
9378: IFFALSE 9382
// exit ;
9380: GO 9456
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9382: LD_ADDR_VAR 0 2
9386: PUSH
9387: LD_VAR 0 1
9391: PUSH
9392: LD_INT 1
9394: PPUSH
9395: LD_VAR 0 1
9399: PPUSH
9400: CALL_OW 12
9404: ARRAY
9405: PPUSH
9406: CALL_OW 274
9410: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9411: LD_VAR 0 2
9415: PPUSH
9416: LD_INT 1
9418: PPUSH
9419: LD_INT 0
9421: PPUSH
9422: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9426: LD_VAR 0 2
9430: PPUSH
9431: LD_INT 2
9433: PPUSH
9434: LD_INT 0
9436: PPUSH
9437: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9441: LD_VAR 0 2
9445: PPUSH
9446: LD_INT 3
9448: PPUSH
9449: LD_INT 0
9451: PPUSH
9452: CALL_OW 277
// end ;
9456: PPOPN 2
9458: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9459: LD_EXP 8
9463: PUSH
9464: LD_EXP 36
9468: AND
9469: IFFALSE 9566
9471: GO 9473
9473: DISABLE
9474: LD_INT 0
9476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9477: LD_ADDR_VAR 0 1
9481: PUSH
9482: LD_INT 22
9484: PUSH
9485: LD_OWVAR 2
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: PUSH
9494: LD_INT 21
9496: PUSH
9497: LD_INT 1
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 3
9506: PUSH
9507: LD_INT 23
9509: PUSH
9510: LD_INT 0
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 69
9530: ST_TO_ADDR
// if not tmp then
9531: LD_VAR 0 1
9535: NOT
9536: IFFALSE 9540
// exit ;
9538: GO 9566
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9540: LD_VAR 0 1
9544: PUSH
9545: LD_INT 1
9547: PPUSH
9548: LD_VAR 0 1
9552: PPUSH
9553: CALL_OW 12
9557: ARRAY
9558: PPUSH
9559: LD_INT 200
9561: PPUSH
9562: CALL_OW 234
// end ;
9566: PPOPN 1
9568: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9569: LD_EXP 8
9573: PUSH
9574: LD_EXP 37
9578: AND
9579: IFFALSE 9658
9581: GO 9583
9583: DISABLE
9584: LD_INT 0
9586: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_INT 22
9594: PUSH
9595: LD_OWVAR 2
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 21
9606: PUSH
9607: LD_INT 2
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PPUSH
9618: CALL_OW 69
9622: ST_TO_ADDR
// if not tmp then
9623: LD_VAR 0 1
9627: NOT
9628: IFFALSE 9632
// exit ;
9630: GO 9658
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9632: LD_VAR 0 1
9636: PUSH
9637: LD_INT 1
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 12
9649: ARRAY
9650: PPUSH
9651: LD_INT 60
9653: PPUSH
9654: CALL_OW 234
// end ;
9658: PPOPN 1
9660: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9661: LD_EXP 8
9665: PUSH
9666: LD_EXP 38
9670: AND
9671: IFFALSE 9770
9673: GO 9675
9675: DISABLE
9676: LD_INT 0
9678: PPUSH
9679: PPUSH
// begin enable ;
9680: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9681: LD_ADDR_VAR 0 1
9685: PUSH
9686: LD_INT 22
9688: PUSH
9689: LD_OWVAR 2
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 61
9700: PUSH
9701: EMPTY
9702: LIST
9703: PUSH
9704: LD_INT 33
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: PPUSH
9719: CALL_OW 69
9723: ST_TO_ADDR
// if not tmp then
9724: LD_VAR 0 1
9728: NOT
9729: IFFALSE 9733
// exit ;
9731: GO 9770
// for i in tmp do
9733: LD_ADDR_VAR 0 2
9737: PUSH
9738: LD_VAR 0 1
9742: PUSH
9743: FOR_IN
9744: IFFALSE 9768
// if IsControledBy ( i ) then
9746: LD_VAR 0 2
9750: PPUSH
9751: CALL_OW 312
9755: IFFALSE 9766
// ComUnlink ( i ) ;
9757: LD_VAR 0 2
9761: PPUSH
9762: CALL_OW 136
9766: GO 9743
9768: POP
9769: POP
// end ;
9770: PPOPN 2
9772: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
9773: LD_EXP 8
9777: PUSH
9778: LD_EXP 39
9782: AND
9783: IFFALSE 9923
9785: GO 9787
9787: DISABLE
9788: LD_INT 0
9790: PPUSH
9791: PPUSH
// begin ToLua ( displayPowell(); ) ;
9792: LD_STRING displayPowell();
9794: PPUSH
9795: CALL_OW 559
// uc_side := 0 ;
9799: LD_ADDR_OWVAR 20
9803: PUSH
9804: LD_INT 0
9806: ST_TO_ADDR
// uc_nation := 2 ;
9807: LD_ADDR_OWVAR 21
9811: PUSH
9812: LD_INT 2
9814: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
9815: LD_ADDR_OWVAR 37
9819: PUSH
9820: LD_INT 14
9822: ST_TO_ADDR
// vc_engine := engine_siberite ;
9823: LD_ADDR_OWVAR 39
9827: PUSH
9828: LD_INT 3
9830: ST_TO_ADDR
// vc_control := control_apeman ;
9831: LD_ADDR_OWVAR 38
9835: PUSH
9836: LD_INT 5
9838: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
9839: LD_ADDR_OWVAR 40
9843: PUSH
9844: LD_INT 29
9846: ST_TO_ADDR
// un := CreateVehicle ;
9847: LD_ADDR_VAR 0 2
9851: PUSH
9852: CALL_OW 45
9856: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9857: LD_VAR 0 2
9861: PPUSH
9862: LD_INT 1
9864: PPUSH
9865: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9869: LD_INT 35
9871: PPUSH
9872: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9876: LD_VAR 0 2
9880: PPUSH
9881: LD_INT 22
9883: PUSH
9884: LD_OWVAR 2
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PPUSH
9893: CALL_OW 69
9897: PPUSH
9898: LD_VAR 0 2
9902: PPUSH
9903: CALL_OW 74
9907: PPUSH
9908: CALL_OW 115
// until IsDead ( un ) ;
9912: LD_VAR 0 2
9916: PPUSH
9917: CALL_OW 301
9921: IFFALSE 9869
// end ;
9923: PPOPN 2
9925: END
// every 0 0$1 trigger StreamModeActive and sStu do
9926: LD_EXP 8
9930: PUSH
9931: LD_EXP 47
9935: AND
9936: IFFALSE 9952
9938: GO 9940
9940: DISABLE
// begin ToLua ( displayStucuk(); ) ;
9941: LD_STRING displayStucuk();
9943: PPUSH
9944: CALL_OW 559
// ResetFog ;
9948: CALL_OW 335
// end ;
9952: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
9953: LD_EXP 8
9957: PUSH
9958: LD_EXP 40
9962: AND
9963: IFFALSE 10104
9965: GO 9967
9967: DISABLE
9968: LD_INT 0
9970: PPUSH
9971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9972: LD_ADDR_VAR 0 2
9976: PUSH
9977: LD_INT 22
9979: PUSH
9980: LD_OWVAR 2
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: PUSH
9989: LD_INT 21
9991: PUSH
9992: LD_INT 1
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: PPUSH
10003: CALL_OW 69
10007: ST_TO_ADDR
// if not tmp then
10008: LD_VAR 0 2
10012: NOT
10013: IFFALSE 10017
// exit ;
10015: GO 10104
// un := tmp [ rand ( 1 , tmp ) ] ;
10017: LD_ADDR_VAR 0 1
10021: PUSH
10022: LD_VAR 0 2
10026: PUSH
10027: LD_INT 1
10029: PPUSH
10030: LD_VAR 0 2
10034: PPUSH
10035: CALL_OW 12
10039: ARRAY
10040: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10041: LD_VAR 0 1
10045: PPUSH
10046: LD_INT 0
10048: PPUSH
10049: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10053: LD_VAR 0 1
10057: PPUSH
10058: LD_OWVAR 3
10062: PUSH
10063: LD_VAR 0 1
10067: DIFF
10068: PPUSH
10069: LD_VAR 0 1
10073: PPUSH
10074: CALL_OW 74
10078: PPUSH
10079: CALL_OW 115
// wait ( 0 0$20 ) ;
10083: LD_INT 700
10085: PPUSH
10086: CALL_OW 67
// SetSide ( un , your_side ) ;
10090: LD_VAR 0 1
10094: PPUSH
10095: LD_OWVAR 2
10099: PPUSH
10100: CALL_OW 235
// end ;
10104: PPOPN 2
10106: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10107: LD_EXP 8
10111: PUSH
10112: LD_EXP 41
10116: AND
10117: IFFALSE 10223
10119: GO 10121
10121: DISABLE
10122: LD_INT 0
10124: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10125: LD_ADDR_VAR 0 1
10129: PUSH
10130: LD_INT 22
10132: PUSH
10133: LD_OWVAR 2
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: PUSH
10142: LD_INT 2
10144: PUSH
10145: LD_INT 30
10147: PUSH
10148: LD_INT 0
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 30
10157: PUSH
10158: LD_INT 1
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: ST_TO_ADDR
// if not depot then
10179: LD_VAR 0 1
10183: NOT
10184: IFFALSE 10188
// exit ;
10186: GO 10223
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10188: LD_VAR 0 1
10192: PUSH
10193: LD_INT 1
10195: ARRAY
10196: PPUSH
10197: CALL_OW 250
10201: PPUSH
10202: LD_VAR 0 1
10206: PUSH
10207: LD_INT 1
10209: ARRAY
10210: PPUSH
10211: CALL_OW 251
10215: PPUSH
10216: LD_INT 70
10218: PPUSH
10219: CALL_OW 495
// end ;
10223: PPOPN 1
10225: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10226: LD_EXP 8
10230: PUSH
10231: LD_EXP 42
10235: AND
10236: IFFALSE 10447
10238: GO 10240
10240: DISABLE
10241: LD_INT 0
10243: PPUSH
10244: PPUSH
10245: PPUSH
10246: PPUSH
10247: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10248: LD_ADDR_VAR 0 5
10252: PUSH
10253: LD_INT 22
10255: PUSH
10256: LD_OWVAR 2
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 21
10267: PUSH
10268: LD_INT 1
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PPUSH
10279: CALL_OW 69
10283: ST_TO_ADDR
// if not tmp then
10284: LD_VAR 0 5
10288: NOT
10289: IFFALSE 10293
// exit ;
10291: GO 10447
// for i in tmp do
10293: LD_ADDR_VAR 0 1
10297: PUSH
10298: LD_VAR 0 5
10302: PUSH
10303: FOR_IN
10304: IFFALSE 10445
// begin d := rand ( 0 , 5 ) ;
10306: LD_ADDR_VAR 0 4
10310: PUSH
10311: LD_INT 0
10313: PPUSH
10314: LD_INT 5
10316: PPUSH
10317: CALL_OW 12
10321: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_VAR 0 1
10331: PPUSH
10332: CALL_OW 250
10336: PPUSH
10337: LD_VAR 0 4
10341: PPUSH
10342: LD_INT 3
10344: PPUSH
10345: LD_INT 12
10347: PPUSH
10348: CALL_OW 12
10352: PPUSH
10353: CALL_OW 272
10357: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10358: LD_ADDR_VAR 0 3
10362: PUSH
10363: LD_VAR 0 1
10367: PPUSH
10368: CALL_OW 251
10372: PPUSH
10373: LD_VAR 0 4
10377: PPUSH
10378: LD_INT 3
10380: PPUSH
10381: LD_INT 12
10383: PPUSH
10384: CALL_OW 12
10388: PPUSH
10389: CALL_OW 273
10393: ST_TO_ADDR
// if ValidHex ( x , y ) then
10394: LD_VAR 0 2
10398: PPUSH
10399: LD_VAR 0 3
10403: PPUSH
10404: CALL_OW 488
10408: IFFALSE 10443
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10410: LD_VAR 0 1
10414: PPUSH
10415: LD_VAR 0 2
10419: PPUSH
10420: LD_VAR 0 3
10424: PPUSH
10425: LD_INT 3
10427: PPUSH
10428: LD_INT 6
10430: PPUSH
10431: CALL_OW 12
10435: PPUSH
10436: LD_INT 1
10438: PPUSH
10439: CALL_OW 483
// end ;
10443: GO 10303
10445: POP
10446: POP
// end ;
10447: PPOPN 5
10449: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10450: LD_EXP 8
10454: PUSH
10455: LD_EXP 43
10459: AND
10460: IFFALSE 10554
10462: GO 10464
10464: DISABLE
10465: LD_INT 0
10467: PPUSH
10468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10469: LD_ADDR_VAR 0 2
10473: PUSH
10474: LD_INT 22
10476: PUSH
10477: LD_OWVAR 2
10481: PUSH
10482: EMPTY
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 32
10488: PUSH
10489: LD_INT 1
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: PUSH
10496: LD_INT 21
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: PPUSH
10511: CALL_OW 69
10515: ST_TO_ADDR
// if not tmp then
10516: LD_VAR 0 2
10520: NOT
10521: IFFALSE 10525
// exit ;
10523: GO 10554
// for i in tmp do
10525: LD_ADDR_VAR 0 1
10529: PUSH
10530: LD_VAR 0 2
10534: PUSH
10535: FOR_IN
10536: IFFALSE 10552
// SetFuel ( i , 0 ) ;
10538: LD_VAR 0 1
10542: PPUSH
10543: LD_INT 0
10545: PPUSH
10546: CALL_OW 240
10550: GO 10535
10552: POP
10553: POP
// end ;
10554: PPOPN 2
10556: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
10557: LD_EXP 8
10561: PUSH
10562: LD_EXP 44
10566: AND
10567: IFFALSE 10633
10569: GO 10571
10571: DISABLE
10572: LD_INT 0
10574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10575: LD_ADDR_VAR 0 1
10579: PUSH
10580: LD_INT 22
10582: PUSH
10583: LD_OWVAR 2
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 30
10594: PUSH
10595: LD_INT 29
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PPUSH
10606: CALL_OW 69
10610: ST_TO_ADDR
// if not tmp then
10611: LD_VAR 0 1
10615: NOT
10616: IFFALSE 10620
// exit ;
10618: GO 10633
// DestroyUnit ( tmp [ 1 ] ) ;
10620: LD_VAR 0 1
10624: PUSH
10625: LD_INT 1
10627: ARRAY
10628: PPUSH
10629: CALL_OW 65
// end ;
10633: PPOPN 1
10635: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10636: LD_EXP 8
10640: PUSH
10641: LD_EXP 46
10645: AND
10646: IFFALSE 10775
10648: GO 10650
10650: DISABLE
10651: LD_INT 0
10653: PPUSH
// begin uc_side := 0 ;
10654: LD_ADDR_OWVAR 20
10658: PUSH
10659: LD_INT 0
10661: ST_TO_ADDR
// uc_nation := nation_arabian ;
10662: LD_ADDR_OWVAR 21
10666: PUSH
10667: LD_INT 2
10669: ST_TO_ADDR
// hc_gallery :=  ;
10670: LD_ADDR_OWVAR 33
10674: PUSH
10675: LD_STRING 
10677: ST_TO_ADDR
// hc_name :=  ;
10678: LD_ADDR_OWVAR 26
10682: PUSH
10683: LD_STRING 
10685: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10686: LD_INT 1
10688: PPUSH
10689: LD_INT 11
10691: PPUSH
10692: LD_INT 10
10694: PPUSH
10695: CALL_OW 380
// un := CreateHuman ;
10699: LD_ADDR_VAR 0 1
10703: PUSH
10704: CALL_OW 44
10708: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10709: LD_VAR 0 1
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10721: LD_INT 35
10723: PPUSH
10724: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10728: LD_VAR 0 1
10732: PPUSH
10733: LD_INT 22
10735: PUSH
10736: LD_OWVAR 2
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PPUSH
10745: CALL_OW 69
10749: PPUSH
10750: LD_VAR 0 1
10754: PPUSH
10755: CALL_OW 74
10759: PPUSH
10760: CALL_OW 115
// until IsDead ( un ) ;
10764: LD_VAR 0 1
10768: PPUSH
10769: CALL_OW 301
10773: IFFALSE 10721
// end ;
10775: PPOPN 1
10777: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
10778: LD_EXP 8
10782: PUSH
10783: LD_EXP 48
10787: AND
10788: IFFALSE 10800
10790: GO 10792
10792: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
10793: LD_STRING earthquake(getX(game), 0, 32)
10795: PPUSH
10796: CALL_OW 559
10800: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
10801: LD_EXP 8
10805: PUSH
10806: LD_EXP 49
10810: AND
10811: IFFALSE 10902
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
// begin enable ;
10819: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
10820: LD_ADDR_VAR 0 1
10824: PUSH
10825: LD_INT 22
10827: PUSH
10828: LD_OWVAR 2
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PUSH
10837: LD_INT 21
10839: PUSH
10840: LD_INT 2
10842: PUSH
10843: EMPTY
10844: LIST
10845: LIST
10846: PUSH
10847: LD_INT 33
10849: PUSH
10850: LD_INT 3
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: EMPTY
10858: LIST
10859: LIST
10860: LIST
10861: PPUSH
10862: CALL_OW 69
10866: ST_TO_ADDR
// if not tmp then
10867: LD_VAR 0 1
10871: NOT
10872: IFFALSE 10876
// exit ;
10874: GO 10902
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10876: LD_VAR 0 1
10880: PUSH
10881: LD_INT 1
10883: PPUSH
10884: LD_VAR 0 1
10888: PPUSH
10889: CALL_OW 12
10893: ARRAY
10894: PPUSH
10895: LD_INT 1
10897: PPUSH
10898: CALL_OW 234
// end ;
10902: PPOPN 1
10904: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
10905: LD_EXP 8
10909: PUSH
10910: LD_EXP 50
10914: AND
10915: IFFALSE 11056
10917: GO 10919
10919: DISABLE
10920: LD_INT 0
10922: PPUSH
10923: PPUSH
10924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10925: LD_ADDR_VAR 0 3
10929: PUSH
10930: LD_INT 22
10932: PUSH
10933: LD_OWVAR 2
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: LD_INT 25
10944: PUSH
10945: LD_INT 1
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: ST_TO_ADDR
// if not tmp then
10961: LD_VAR 0 3
10965: NOT
10966: IFFALSE 10970
// exit ;
10968: GO 11056
// un := tmp [ rand ( 1 , tmp ) ] ;
10970: LD_ADDR_VAR 0 2
10974: PUSH
10975: LD_VAR 0 3
10979: PUSH
10980: LD_INT 1
10982: PPUSH
10983: LD_VAR 0 3
10987: PPUSH
10988: CALL_OW 12
10992: ARRAY
10993: ST_TO_ADDR
// if Crawls ( un ) then
10994: LD_VAR 0 2
10998: PPUSH
10999: CALL_OW 318
11003: IFFALSE 11014
// ComWalk ( un ) ;
11005: LD_VAR 0 2
11009: PPUSH
11010: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_INT 9
11021: PPUSH
11022: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
11026: LD_INT 28
11028: PPUSH
11029: LD_OWVAR 2
11033: PPUSH
11034: LD_INT 2
11036: PPUSH
11037: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
11041: LD_INT 29
11043: PPUSH
11044: LD_OWVAR 2
11048: PPUSH
11049: LD_INT 2
11051: PPUSH
11052: CALL_OW 322
// end ;
11056: PPOPN 3
11058: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
11059: LD_EXP 8
11063: PUSH
11064: LD_EXP 51
11068: AND
11069: IFFALSE 11180
11071: GO 11073
11073: DISABLE
11074: LD_INT 0
11076: PPUSH
11077: PPUSH
11078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11079: LD_ADDR_VAR 0 3
11083: PUSH
11084: LD_INT 22
11086: PUSH
11087: LD_OWVAR 2
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: PUSH
11096: LD_INT 25
11098: PUSH
11099: LD_INT 1
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: ST_TO_ADDR
// if not tmp then
11115: LD_VAR 0 3
11119: NOT
11120: IFFALSE 11124
// exit ;
11122: GO 11180
// un := tmp [ rand ( 1 , tmp ) ] ;
11124: LD_ADDR_VAR 0 2
11128: PUSH
11129: LD_VAR 0 3
11133: PUSH
11134: LD_INT 1
11136: PPUSH
11137: LD_VAR 0 3
11141: PPUSH
11142: CALL_OW 12
11146: ARRAY
11147: ST_TO_ADDR
// if Crawls ( un ) then
11148: LD_VAR 0 2
11152: PPUSH
11153: CALL_OW 318
11157: IFFALSE 11168
// ComWalk ( un ) ;
11159: LD_VAR 0 2
11163: PPUSH
11164: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11168: LD_VAR 0 2
11172: PPUSH
11173: LD_INT 8
11175: PPUSH
11176: CALL_OW 336
// end ;
11180: PPOPN 3
11182: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
11183: LD_EXP 8
11187: PUSH
11188: LD_EXP 52
11192: AND
11193: IFFALSE 11337
11195: GO 11197
11197: DISABLE
11198: LD_INT 0
11200: PPUSH
11201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
11202: LD_ADDR_VAR 0 2
11206: PUSH
11207: LD_INT 22
11209: PUSH
11210: LD_OWVAR 2
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: PUSH
11219: LD_INT 21
11221: PUSH
11222: LD_INT 2
11224: PUSH
11225: EMPTY
11226: LIST
11227: LIST
11228: PUSH
11229: LD_INT 2
11231: PUSH
11232: LD_INT 34
11234: PUSH
11235: LD_INT 12
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 34
11244: PUSH
11245: LD_INT 51
11247: PUSH
11248: EMPTY
11249: LIST
11250: LIST
11251: PUSH
11252: LD_INT 34
11254: PUSH
11255: LD_INT 32
11257: PUSH
11258: EMPTY
11259: LIST
11260: LIST
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: LIST
11272: PPUSH
11273: CALL_OW 69
11277: ST_TO_ADDR
// if not tmp then
11278: LD_VAR 0 2
11282: NOT
11283: IFFALSE 11287
// exit ;
11285: GO 11337
// for i in tmp do
11287: LD_ADDR_VAR 0 1
11291: PUSH
11292: LD_VAR 0 2
11296: PUSH
11297: FOR_IN
11298: IFFALSE 11335
// if GetCargo ( i , mat_artifact ) = 0 then
11300: LD_VAR 0 1
11304: PPUSH
11305: LD_INT 4
11307: PPUSH
11308: CALL_OW 289
11312: PUSH
11313: LD_INT 0
11315: EQUAL
11316: IFFALSE 11333
// SetCargo ( i , mat_siberit , 100 ) ;
11318: LD_VAR 0 1
11322: PPUSH
11323: LD_INT 3
11325: PPUSH
11326: LD_INT 100
11328: PPUSH
11329: CALL_OW 290
11333: GO 11297
11335: POP
11336: POP
// end ;
11337: PPOPN 2
11339: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
11340: LD_EXP 8
11344: PUSH
11345: LD_EXP 53
11349: AND
11350: IFFALSE 11533
11352: GO 11354
11354: DISABLE
11355: LD_INT 0
11357: PPUSH
11358: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
11359: LD_ADDR_VAR 0 2
11363: PUSH
11364: LD_INT 22
11366: PUSH
11367: LD_OWVAR 2
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: PPUSH
11376: CALL_OW 69
11380: ST_TO_ADDR
// if not tmp then
11381: LD_VAR 0 2
11385: NOT
11386: IFFALSE 11390
// exit ;
11388: GO 11533
// for i := 1 to 2 do
11390: LD_ADDR_VAR 0 1
11394: PUSH
11395: DOUBLE
11396: LD_INT 1
11398: DEC
11399: ST_TO_ADDR
11400: LD_INT 2
11402: PUSH
11403: FOR_TO
11404: IFFALSE 11531
// begin uc_side := your_side ;
11406: LD_ADDR_OWVAR 20
11410: PUSH
11411: LD_OWVAR 2
11415: ST_TO_ADDR
// uc_nation := nation_american ;
11416: LD_ADDR_OWVAR 21
11420: PUSH
11421: LD_INT 1
11423: ST_TO_ADDR
// vc_chassis := us_morphling ;
11424: LD_ADDR_OWVAR 37
11428: PUSH
11429: LD_INT 5
11431: ST_TO_ADDR
// vc_engine := engine_siberite ;
11432: LD_ADDR_OWVAR 39
11436: PUSH
11437: LD_INT 3
11439: ST_TO_ADDR
// vc_control := control_computer ;
11440: LD_ADDR_OWVAR 38
11444: PUSH
11445: LD_INT 3
11447: ST_TO_ADDR
// vc_weapon := us_double_laser ;
11448: LD_ADDR_OWVAR 40
11452: PUSH
11453: LD_INT 10
11455: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
11456: LD_VAR 0 2
11460: PUSH
11461: LD_INT 1
11463: ARRAY
11464: PPUSH
11465: CALL_OW 310
11469: NOT
11470: IFFALSE 11517
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
11472: CALL_OW 45
11476: PPUSH
11477: LD_VAR 0 2
11481: PUSH
11482: LD_INT 1
11484: ARRAY
11485: PPUSH
11486: CALL_OW 250
11490: PPUSH
11491: LD_VAR 0 2
11495: PUSH
11496: LD_INT 1
11498: ARRAY
11499: PPUSH
11500: CALL_OW 251
11504: PPUSH
11505: LD_INT 12
11507: PPUSH
11508: LD_INT 1
11510: PPUSH
11511: CALL_OW 50
11515: GO 11529
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
11517: CALL_OW 45
11521: PPUSH
11522: LD_INT 1
11524: PPUSH
11525: CALL_OW 51
// end ;
11529: GO 11403
11531: POP
11532: POP
// end ;
11533: PPOPN 2
11535: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
11536: LD_EXP 8
11540: PUSH
11541: LD_EXP 54
11545: AND
11546: IFFALSE 11768
11548: GO 11550
11550: DISABLE
11551: LD_INT 0
11553: PPUSH
11554: PPUSH
11555: PPUSH
11556: PPUSH
11557: PPUSH
11558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11559: LD_ADDR_VAR 0 6
11563: PUSH
11564: LD_INT 22
11566: PUSH
11567: LD_OWVAR 2
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 21
11578: PUSH
11579: LD_INT 1
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: PUSH
11586: LD_INT 3
11588: PUSH
11589: LD_INT 23
11591: PUSH
11592: LD_INT 0
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: LIST
11607: PPUSH
11608: CALL_OW 69
11612: ST_TO_ADDR
// if not tmp then
11613: LD_VAR 0 6
11617: NOT
11618: IFFALSE 11622
// exit ;
11620: GO 11768
// s1 := rand ( 1 , 4 ) ;
11622: LD_ADDR_VAR 0 2
11626: PUSH
11627: LD_INT 1
11629: PPUSH
11630: LD_INT 4
11632: PPUSH
11633: CALL_OW 12
11637: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
11638: LD_ADDR_VAR 0 4
11642: PUSH
11643: LD_VAR 0 6
11647: PUSH
11648: LD_INT 1
11650: ARRAY
11651: PPUSH
11652: LD_VAR 0 2
11656: PPUSH
11657: CALL_OW 259
11661: ST_TO_ADDR
// if s1 = 1 then
11662: LD_VAR 0 2
11666: PUSH
11667: LD_INT 1
11669: EQUAL
11670: IFFALSE 11690
// s2 := rand ( 2 , 4 ) else
11672: LD_ADDR_VAR 0 3
11676: PUSH
11677: LD_INT 2
11679: PPUSH
11680: LD_INT 4
11682: PPUSH
11683: CALL_OW 12
11687: ST_TO_ADDR
11688: GO 11698
// s2 := 1 ;
11690: LD_ADDR_VAR 0 3
11694: PUSH
11695: LD_INT 1
11697: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
11698: LD_ADDR_VAR 0 5
11702: PUSH
11703: LD_VAR 0 6
11707: PUSH
11708: LD_INT 1
11710: ARRAY
11711: PPUSH
11712: LD_VAR 0 3
11716: PPUSH
11717: CALL_OW 259
11721: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
11722: LD_VAR 0 6
11726: PUSH
11727: LD_INT 1
11729: ARRAY
11730: PPUSH
11731: LD_VAR 0 2
11735: PPUSH
11736: LD_VAR 0 5
11740: PPUSH
11741: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
11745: LD_VAR 0 6
11749: PUSH
11750: LD_INT 1
11752: ARRAY
11753: PPUSH
11754: LD_VAR 0 3
11758: PPUSH
11759: LD_VAR 0 4
11763: PPUSH
11764: CALL_OW 237
// end ;
11768: PPOPN 6
11770: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
11771: LD_EXP 8
11775: PUSH
11776: LD_EXP 55
11780: AND
11781: IFFALSE 11860
11783: GO 11785
11785: DISABLE
11786: LD_INT 0
11788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
11789: LD_ADDR_VAR 0 1
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_OWVAR 2
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 30
11808: PUSH
11809: LD_INT 3
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: PPUSH
11820: CALL_OW 69
11824: ST_TO_ADDR
// if not tmp then
11825: LD_VAR 0 1
11829: NOT
11830: IFFALSE 11834
// exit ;
11832: GO 11860
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11834: LD_VAR 0 1
11838: PUSH
11839: LD_INT 1
11841: PPUSH
11842: LD_VAR 0 1
11846: PPUSH
11847: CALL_OW 12
11851: ARRAY
11852: PPUSH
11853: LD_INT 1
11855: PPUSH
11856: CALL_OW 234
// end ;
11860: PPOPN 1
11862: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
11863: LD_EXP 8
11867: PUSH
11868: LD_EXP 56
11872: AND
11873: IFFALSE 11985
11875: GO 11877
11877: DISABLE
11878: LD_INT 0
11880: PPUSH
11881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
11882: LD_ADDR_VAR 0 2
11886: PUSH
11887: LD_INT 22
11889: PUSH
11890: LD_OWVAR 2
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: LD_INT 2
11901: PUSH
11902: LD_INT 30
11904: PUSH
11905: LD_INT 27
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 30
11914: PUSH
11915: LD_INT 26
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PUSH
11922: LD_INT 30
11924: PUSH
11925: LD_INT 28
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// if not tmp then
11947: LD_VAR 0 2
11951: NOT
11952: IFFALSE 11956
// exit ;
11954: GO 11985
// for i in tmp do
11956: LD_ADDR_VAR 0 1
11960: PUSH
11961: LD_VAR 0 2
11965: PUSH
11966: FOR_IN
11967: IFFALSE 11983
// SetLives ( i , 1 ) ;
11969: LD_VAR 0 1
11973: PPUSH
11974: LD_INT 1
11976: PPUSH
11977: CALL_OW 234
11981: GO 11966
11983: POP
11984: POP
// end ;
11985: PPOPN 2
11987: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
11988: LD_EXP 8
11992: PUSH
11993: LD_EXP 57
11997: AND
11998: IFFALSE 12272
12000: GO 12002
12002: DISABLE
12003: LD_INT 0
12005: PPUSH
12006: PPUSH
12007: PPUSH
// begin i := rand ( 1 , 7 ) ;
12008: LD_ADDR_VAR 0 1
12012: PUSH
12013: LD_INT 1
12015: PPUSH
12016: LD_INT 7
12018: PPUSH
12019: CALL_OW 12
12023: ST_TO_ADDR
// case i of 1 :
12024: LD_VAR 0 1
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12047
12037: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
12038: LD_STRING earthquake(getX(game), 0, 32)
12040: PPUSH
12041: CALL_OW 559
12045: GO 12272
12047: LD_INT 2
12049: DOUBLE
12050: EQUAL
12051: IFTRUE 12055
12053: GO 12069
12055: POP
// begin ToLua ( displayStucuk(); ) ;
12056: LD_STRING displayStucuk();
12058: PPUSH
12059: CALL_OW 559
// ResetFog ;
12063: CALL_OW 335
// end ; 3 :
12067: GO 12272
12069: LD_INT 3
12071: DOUBLE
12072: EQUAL
12073: IFTRUE 12077
12075: GO 12181
12077: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12078: LD_ADDR_VAR 0 2
12082: PUSH
12083: LD_INT 22
12085: PUSH
12086: LD_OWVAR 2
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 25
12097: PUSH
12098: LD_INT 1
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PPUSH
12109: CALL_OW 69
12113: ST_TO_ADDR
// if not tmp then
12114: LD_VAR 0 2
12118: NOT
12119: IFFALSE 12123
// exit ;
12121: GO 12272
// un := tmp [ rand ( 1 , tmp ) ] ;
12123: LD_ADDR_VAR 0 3
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 1
12135: PPUSH
12136: LD_VAR 0 2
12140: PPUSH
12141: CALL_OW 12
12145: ARRAY
12146: ST_TO_ADDR
// if Crawls ( un ) then
12147: LD_VAR 0 3
12151: PPUSH
12152: CALL_OW 318
12156: IFFALSE 12167
// ComWalk ( un ) ;
12158: LD_VAR 0 3
12162: PPUSH
12163: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12167: LD_VAR 0 3
12171: PPUSH
12172: LD_INT 8
12174: PPUSH
12175: CALL_OW 336
// end ; 4 :
12179: GO 12272
12181: LD_INT 4
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12189
12187: GO 12250
12189: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12190: LD_ADDR_VAR 0 2
12194: PUSH
12195: LD_INT 22
12197: PUSH
12198: LD_OWVAR 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 30
12209: PUSH
12210: LD_INT 29
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PPUSH
12221: CALL_OW 69
12225: ST_TO_ADDR
// if not tmp then
12226: LD_VAR 0 2
12230: NOT
12231: IFFALSE 12235
// exit ;
12233: GO 12272
// DestroyUnit ( tmp [ 1 ] ) ;
12235: LD_VAR 0 2
12239: PUSH
12240: LD_INT 1
12242: ARRAY
12243: PPUSH
12244: CALL_OW 65
// end ; 5 .. 7 :
12248: GO 12272
12250: LD_INT 5
12252: DOUBLE
12253: GREATEREQUAL
12254: IFFALSE 12262
12256: LD_INT 7
12258: DOUBLE
12259: LESSEQUAL
12260: IFTRUE 12264
12262: GO 12271
12264: POP
// StreamSibBomb ; end ;
12265: CALL 8522 0 0
12269: GO 12272
12271: POP
// end ;
12272: PPOPN 3
12274: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
12275: LD_EXP 8
12279: PUSH
12280: LD_EXP 58
12284: AND
12285: IFFALSE 12441
12287: GO 12289
12289: DISABLE
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
12295: LD_ADDR_VAR 0 2
12299: PUSH
12300: LD_INT 81
12302: PUSH
12303: LD_OWVAR 2
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 2
12314: PUSH
12315: LD_INT 21
12317: PUSH
12318: LD_INT 1
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: PUSH
12325: LD_INT 21
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: LIST
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: PPUSH
12344: CALL_OW 69
12348: ST_TO_ADDR
// if not tmp then
12349: LD_VAR 0 2
12353: NOT
12354: IFFALSE 12358
// exit ;
12356: GO 12441
// p := 0 ;
12358: LD_ADDR_VAR 0 3
12362: PUSH
12363: LD_INT 0
12365: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12366: LD_INT 35
12368: PPUSH
12369: CALL_OW 67
// p := p + 1 ;
12373: LD_ADDR_VAR 0 3
12377: PUSH
12378: LD_VAR 0 3
12382: PUSH
12383: LD_INT 1
12385: PLUS
12386: ST_TO_ADDR
// for i in tmp do
12387: LD_ADDR_VAR 0 1
12391: PUSH
12392: LD_VAR 0 2
12396: PUSH
12397: FOR_IN
12398: IFFALSE 12429
// if GetLives ( i ) < 1000 then
12400: LD_VAR 0 1
12404: PPUSH
12405: CALL_OW 256
12409: PUSH
12410: LD_INT 1000
12412: LESS
12413: IFFALSE 12427
// SetLives ( i , 1000 ) ;
12415: LD_VAR 0 1
12419: PPUSH
12420: LD_INT 1000
12422: PPUSH
12423: CALL_OW 234
12427: GO 12397
12429: POP
12430: POP
// until p > 20 ;
12431: LD_VAR 0 3
12435: PUSH
12436: LD_INT 20
12438: GREATER
12439: IFFALSE 12366
// end ;
12441: PPOPN 3
12443: END
// every 0 0$1 trigger StreamModeActive and sTime do
12444: LD_EXP 8
12448: PUSH
12449: LD_EXP 59
12453: AND
12454: IFFALSE 12489
12456: GO 12458
12458: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
12459: LD_INT 28
12461: PPUSH
12462: LD_OWVAR 2
12466: PPUSH
12467: LD_INT 2
12469: PPUSH
12470: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
12474: LD_INT 30
12476: PPUSH
12477: LD_OWVAR 2
12481: PPUSH
12482: LD_INT 2
12484: PPUSH
12485: CALL_OW 322
// end ;
12489: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
12490: LD_EXP 8
12494: PUSH
12495: LD_EXP 60
12499: AND
12500: IFFALSE 12621
12502: GO 12504
12504: DISABLE
12505: LD_INT 0
12507: PPUSH
12508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12509: LD_ADDR_VAR 0 2
12513: PUSH
12514: LD_INT 22
12516: PUSH
12517: LD_OWVAR 2
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 21
12528: PUSH
12529: LD_INT 1
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 3
12538: PUSH
12539: LD_INT 23
12541: PUSH
12542: LD_INT 0
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: LIST
12557: PPUSH
12558: CALL_OW 69
12562: ST_TO_ADDR
// if not tmp then
12563: LD_VAR 0 2
12567: NOT
12568: IFFALSE 12572
// exit ;
12570: GO 12621
// for i in tmp do
12572: LD_ADDR_VAR 0 1
12576: PUSH
12577: LD_VAR 0 2
12581: PUSH
12582: FOR_IN
12583: IFFALSE 12619
// begin if Crawls ( i ) then
12585: LD_VAR 0 1
12589: PPUSH
12590: CALL_OW 318
12594: IFFALSE 12605
// ComWalk ( i ) ;
12596: LD_VAR 0 1
12600: PPUSH
12601: CALL_OW 138
// SetClass ( i , 2 ) ;
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_INT 2
12612: PPUSH
12613: CALL_OW 336
// end ;
12617: GO 12582
12619: POP
12620: POP
// end ;
12621: PPOPN 2
12623: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
12624: LD_EXP 8
12628: PUSH
12629: LD_EXP 61
12633: AND
12634: IFFALSE 12915
12636: GO 12638
12638: DISABLE
12639: LD_INT 0
12641: PPUSH
12642: PPUSH
12643: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
12644: LD_OWVAR 2
12648: PPUSH
12649: LD_INT 9
12651: PPUSH
12652: LD_INT 1
12654: PPUSH
12655: LD_INT 1
12657: PPUSH
12658: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12662: LD_INT 9
12664: PPUSH
12665: LD_OWVAR 2
12669: PPUSH
12670: CALL_OW 343
// uc_side := 9 ;
12674: LD_ADDR_OWVAR 20
12678: PUSH
12679: LD_INT 9
12681: ST_TO_ADDR
// uc_nation := 2 ;
12682: LD_ADDR_OWVAR 21
12686: PUSH
12687: LD_INT 2
12689: ST_TO_ADDR
// hc_name := Dark Warrior ;
12690: LD_ADDR_OWVAR 26
12694: PUSH
12695: LD_STRING Dark Warrior
12697: ST_TO_ADDR
// hc_gallery :=  ;
12698: LD_ADDR_OWVAR 33
12702: PUSH
12703: LD_STRING 
12705: ST_TO_ADDR
// hc_noskilllimit := true ;
12706: LD_ADDR_OWVAR 76
12710: PUSH
12711: LD_INT 1
12713: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
12714: LD_ADDR_OWVAR 31
12718: PUSH
12719: LD_INT 30
12721: PUSH
12722: LD_INT 30
12724: PUSH
12725: LD_INT 30
12727: PUSH
12728: LD_INT 30
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: LIST
12735: LIST
12736: ST_TO_ADDR
// un := CreateHuman ;
12737: LD_ADDR_VAR 0 3
12741: PUSH
12742: CALL_OW 44
12746: ST_TO_ADDR
// hc_noskilllimit := false ;
12747: LD_ADDR_OWVAR 76
12751: PUSH
12752: LD_INT 0
12754: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12755: LD_VAR 0 3
12759: PPUSH
12760: LD_INT 1
12762: PPUSH
12763: CALL_OW 51
// p := 0 ;
12767: LD_ADDR_VAR 0 2
12771: PUSH
12772: LD_INT 0
12774: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12775: LD_INT 35
12777: PPUSH
12778: CALL_OW 67
// p := p + 1 ;
12782: LD_ADDR_VAR 0 2
12786: PUSH
12787: LD_VAR 0 2
12791: PUSH
12792: LD_INT 1
12794: PLUS
12795: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
12796: LD_VAR 0 3
12800: PPUSH
12801: CALL_OW 256
12805: PUSH
12806: LD_INT 1000
12808: LESS
12809: IFFALSE 12823
// SetLives ( un , 1000 ) ;
12811: LD_VAR 0 3
12815: PPUSH
12816: LD_INT 1000
12818: PPUSH
12819: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
12823: LD_VAR 0 3
12827: PPUSH
12828: LD_INT 81
12830: PUSH
12831: LD_OWVAR 2
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: PUSH
12840: LD_INT 91
12842: PUSH
12843: LD_VAR 0 3
12847: PUSH
12848: LD_INT 30
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: LIST
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PPUSH
12860: CALL_OW 69
12864: PPUSH
12865: LD_VAR 0 3
12869: PPUSH
12870: CALL_OW 74
12874: PPUSH
12875: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
12879: LD_VAR 0 2
12883: PUSH
12884: LD_INT 60
12886: GREATER
12887: PUSH
12888: LD_VAR 0 3
12892: PPUSH
12893: CALL_OW 301
12897: OR
12898: IFFALSE 12775
// if un then
12900: LD_VAR 0 3
12904: IFFALSE 12915
// RemoveUnit ( un ) ;
12906: LD_VAR 0 3
12910: PPUSH
12911: CALL_OW 64
// end ;
12915: PPOPN 3
12917: END
