// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 136 , 106 ) ;
   4: LD_INT 136
   6: PPUSH
   7: LD_INT 106
   9: PPUSH
  10: CALL_OW 86
// Init ;
  14: CALL 79 0 0
// PrepareNature ( nat_area , wat_area , [ 10 , 2 * Difficulty , 6 , 6 , 3 * Difficulty , 6 , 3 , 3 ] ) ;
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 10
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: LD_OWVAR 67
  34: MUL
  35: PUSH
  36: LD_INT 6
  38: PUSH
  39: LD_INT 6
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: LD_OWVAR 67
  49: MUL
  50: PUSH
  51: LD_INT 6
  53: PUSH
  54: LD_INT 3
  56: PUSH
  57: LD_INT 3
  59: PUSH
  60: EMPTY
  61: LIST
  62: LIST
  63: LIST
  64: LIST
  65: LIST
  66: LIST
  67: LIST
  68: LIST
  69: PPUSH
  70: CALL 399 0 3
// PrepareHunters ( ) ;
  74: CALL 245 0 0
// end ;
  78: END
// export debug , hunterClass , huntersAmount , animalAmount ; export class_horse ; export points , hunters ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// class_horse := 21 ;
  90: LD_ADDR_EXP 5
  94: PUSH
  95: LD_INT 21
  97: ST_TO_ADDR
// if debug then
  98: LD_EXP 1
 102: IFFALSE 137
// begin FogOff ( 1 ) ;
 104: LD_INT 1
 106: PPUSH
 107: CALL_OW 344
// Difficulty := 2 ;
 111: LD_ADDR_OWVAR 67
 115: PUSH
 116: LD_INT 2
 118: ST_TO_ADDR
// hunterClass := 3 ;
 119: LD_ADDR_EXP 2
 123: PUSH
 124: LD_INT 3
 126: ST_TO_ADDR
// animalAmount := 2 ;
 127: LD_ADDR_EXP 4
 131: PUSH
 132: LD_INT 2
 134: ST_TO_ADDR
// end else
 135: GO 176
// begin Difficulty := GetMultiplayerSetting ( 0 ) ;
 137: LD_ADDR_OWVAR 67
 141: PUSH
 142: LD_INT 0
 144: PPUSH
 145: CALL_OW 426
 149: ST_TO_ADDR
// hunterClass := GetMultiplayerSetting ( 2 ) ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_INT 2
 157: PPUSH
 158: CALL_OW 426
 162: ST_TO_ADDR
// animalAmount := GetMultiplayerSetting ( 1 ) ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 1
 170: PPUSH
 171: CALL_OW 426
 175: ST_TO_ADDR
// end ; huntersAmount := [ 4 , 6 , 8 ] [ Difficulty ] ;
 176: LD_ADDR_EXP 3
 180: PUSH
 181: LD_INT 4
 183: PUSH
 184: LD_INT 6
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: LIST
 194: PUSH
 195: LD_OWVAR 67
 199: ARRAY
 200: ST_TO_ADDR
// points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 201: LD_ADDR_EXP 6
 205: PUSH
 206: LD_INT 0
 208: PUSH
 209: LD_INT 0
 211: PUSH
 212: LD_INT 0
 214: PUSH
 215: LD_INT 0
 217: PUSH
 218: LD_INT 0
 220: PUSH
 221: LD_INT 0
 223: PUSH
 224: LD_INT 0
 226: PUSH
 227: LD_INT 0
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// export function PrepareHunters ; var i , un ; begin
 245: LD_INT 0
 247: PPUSH
 248: PPUSH
 249: PPUSH
// for i := 1 to huntersAmount do
 250: LD_ADDR_VAR 0 2
 254: PUSH
 255: DOUBLE
 256: LD_INT 1
 258: DEC
 259: ST_TO_ADDR
 260: LD_EXP 3
 264: PUSH
 265: FOR_TO
 266: IFFALSE 392
// begin uc_side := i ;
 268: LD_ADDR_OWVAR 20
 272: PUSH
 273: LD_VAR 0 2
 277: ST_TO_ADDR
// uc_nation := i mod 3 + 1 ;
 278: LD_ADDR_OWVAR 21
 282: PUSH
 283: LD_VAR 0 2
 287: PUSH
 288: LD_INT 3
 290: MOD
 291: PUSH
 292: LD_INT 1
 294: PLUS
 295: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_sniper , class_desert_warior ] [ hunterClass ] , 10 - Difficulty * 2 ) ;
 296: LD_INT 0
 298: PPUSH
 299: LD_INT 1
 301: PUSH
 302: LD_INT 5
 304: PUSH
 305: LD_INT 11
 307: PUSH
 308: EMPTY
 309: LIST
 310: LIST
 311: LIST
 312: PUSH
 313: LD_EXP 2
 317: ARRAY
 318: PPUSH
 319: LD_INT 10
 321: PUSH
 322: LD_OWVAR 67
 326: PUSH
 327: LD_INT 2
 329: MUL
 330: MINUS
 331: PPUSH
 332: CALL_OW 380
// un := CreateHuman ;
 336: LD_ADDR_VAR 0 3
 340: PUSH
 341: CALL_OW 44
 345: ST_TO_ADDR
// hunters := Replace ( hunters , hunters + 1 , un ) ;
 346: LD_ADDR_EXP 7
 350: PUSH
 351: LD_EXP 7
 355: PPUSH
 356: LD_EXP 7
 360: PUSH
 361: LD_INT 1
 363: PLUS
 364: PPUSH
 365: LD_VAR 0 3
 369: PPUSH
 370: CALL_OW 1
 374: ST_TO_ADDR
// PlaceUnitArea ( un , startArea , false ) ;
 375: LD_VAR 0 3
 379: PPUSH
 380: LD_INT 3
 382: PPUSH
 383: LD_INT 0
 385: PPUSH
 386: CALL_OW 49
// end ;
 390: GO 265
 392: POP
 393: POP
// end ; end_of_file
 394: LD_VAR 0 1
 398: RET
// export function PrepareNature ( area , waterArea , numbers ) ; var i , j , classes , waterClass ; begin
 399: LD_INT 0
 401: PPUSH
 402: PPUSH
 403: PPUSH
 404: PPUSH
 405: PPUSH
// uc_side = 0 ;
 406: LD_ADDR_OWVAR 20
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// uc_nation = 0 ;
 414: LD_ADDR_OWVAR 21
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// classes := [ class_apeman , class_apeman_soldier , class_baggie , class_phororhacos , class_tiger , class_horse ] ;
 422: LD_ADDR_VAR 0 7
 426: PUSH
 427: LD_INT 12
 429: PUSH
 430: LD_INT 15
 432: PUSH
 433: LD_INT 13
 435: PUSH
 436: LD_INT 18
 438: PUSH
 439: LD_INT 14
 441: PUSH
 442: LD_EXP 5
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: ST_TO_ADDR
// waterClass := [ class_fish , class_frog ] ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: LD_INT 20
 462: PUSH
 463: LD_INT 19
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// InitHc_All ( ) ;
 470: CALL_OW 584
// for i := 1 to numbers - 2 do
 474: LD_ADDR_VAR 0 5
 478: PUSH
 479: DOUBLE
 480: LD_INT 1
 482: DEC
 483: ST_TO_ADDR
 484: LD_VAR 0 3
 488: PUSH
 489: LD_INT 2
 491: MINUS
 492: PUSH
 493: FOR_TO
 494: IFFALSE 635
// begin if numbers [ i ] = 0 then
 496: LD_VAR 0 3
 500: PUSH
 501: LD_VAR 0 5
 505: ARRAY
 506: PUSH
 507: LD_INT 0
 509: EQUAL
 510: IFFALSE 514
// continue ;
 512: GO 493
// hc_class := classes [ i ] ;
 514: LD_ADDR_OWVAR 28
 518: PUSH
 519: LD_VAR 0 7
 523: PUSH
 524: LD_VAR 0 5
 528: ARRAY
 529: ST_TO_ADDR
// hc_attr := [ rand ( 8 , 12 ) , rand ( 8 , 12 ) ] ;
 530: LD_ADDR_OWVAR 29
 534: PUSH
 535: LD_INT 8
 537: PPUSH
 538: LD_INT 12
 540: PPUSH
 541: CALL_OW 12
 545: PUSH
 546: LD_INT 8
 548: PPUSH
 549: LD_INT 12
 551: PPUSH
 552: CALL_OW 12
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) + Difficulty * 5 ;
 561: LD_ADDR_OWVAR 35
 565: PUSH
 566: LD_INT 5
 568: NEG
 569: PPUSH
 570: LD_INT 5
 572: PPUSH
 573: CALL_OW 12
 577: PUSH
 578: LD_OWVAR 67
 582: PUSH
 583: LD_INT 5
 585: MUL
 586: PLUS
 587: ST_TO_ADDR
// for j := 1 to numbers [ i ] do
 588: LD_ADDR_VAR 0 6
 592: PUSH
 593: DOUBLE
 594: LD_INT 1
 596: DEC
 597: ST_TO_ADDR
 598: LD_VAR 0 3
 602: PUSH
 603: LD_VAR 0 5
 607: ARRAY
 608: PUSH
 609: FOR_TO
 610: IFFALSE 631
// PlaceUnitArea ( CreateHuman , area , false ) ;
 612: CALL_OW 44
 616: PPUSH
 617: LD_VAR 0 1
 621: PPUSH
 622: LD_INT 0
 624: PPUSH
 625: CALL_OW 49
 629: GO 609
 631: POP
 632: POP
// end ;
 633: GO 493
 635: POP
 636: POP
// if not waterArea then
 637: LD_VAR 0 2
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 806
// hc_class := waterClass [ 1 ] ;
 646: LD_ADDR_OWVAR 28
 650: PUSH
 651: LD_VAR 0 8
 655: PUSH
 656: LD_INT 1
 658: ARRAY
 659: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 660: LD_ADDR_OWVAR 29
 664: PUSH
 665: LD_INT 10
 667: PUSH
 668: LD_INT 10
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: ST_TO_ADDR
// hc_agressivity := 0 ;
 675: LD_ADDR_OWVAR 35
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for j := 1 to numbers [ 7 ] do
 683: LD_ADDR_VAR 0 6
 687: PUSH
 688: DOUBLE
 689: LD_INT 1
 691: DEC
 692: ST_TO_ADDR
 693: LD_VAR 0 3
 697: PUSH
 698: LD_INT 7
 700: ARRAY
 701: PUSH
 702: FOR_TO
 703: IFFALSE 724
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 705: CALL_OW 44
 709: PPUSH
 710: LD_VAR 0 2
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL_OW 49
 722: GO 702
 724: POP
 725: POP
// hc_class := waterClass [ 2 ] ;
 726: LD_ADDR_OWVAR 28
 730: PUSH
 731: LD_VAR 0 8
 735: PUSH
 736: LD_INT 2
 738: ARRAY
 739: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 740: LD_ADDR_OWVAR 29
 744: PUSH
 745: LD_INT 10
 747: PUSH
 748: LD_INT 10
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: ST_TO_ADDR
// hc_agressivity := 0 ;
 755: LD_ADDR_OWVAR 35
 759: PUSH
 760: LD_INT 0
 762: ST_TO_ADDR
// for j := 1 to numbers [ 8 ] do
 763: LD_ADDR_VAR 0 6
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_VAR 0 3
 777: PUSH
 778: LD_INT 8
 780: ARRAY
 781: PUSH
 782: FOR_TO
 783: IFFALSE 804
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 785: CALL_OW 44
 789: PPUSH
 790: LD_VAR 0 2
 794: PPUSH
 795: LD_INT 0
 797: PPUSH
 798: CALL_OW 49
 802: GO 782
 804: POP
 805: POP
// end ; end_of_file
 806: LD_VAR 0 4
 810: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do var i ;
 811: LD_INT 22
 813: PUSH
 814: LD_INT 0
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: PUSH
 821: LD_INT 25
 823: PUSH
 824: LD_INT 15
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: PUSH
 831: EMPTY
 832: LIST
 833: LIST
 834: PPUSH
 835: CALL_OW 69
 839: IFFALSE 945
 841: GO 843
 843: DISABLE
 844: LD_INT 0
 846: PPUSH
// begin enable ;
 847: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do
 848: LD_ADDR_VAR 0 1
 852: PUSH
 853: LD_INT 22
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 25
 865: PUSH
 866: LD_INT 15
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: PUSH
 882: FOR_IN
 883: IFFALSE 943
// if GetLives ( i ) < 1000 then
 885: LD_VAR 0 1
 889: PPUSH
 890: CALL_OW 256
 894: PUSH
 895: LD_INT 1000
 897: LESS
 898: IFFALSE 941
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , i ) ) ;
 900: LD_VAR 0 1
 904: PPUSH
 905: LD_INT 3
 907: PUSH
 908: LD_INT 22
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: PPUSH
 922: CALL_OW 69
 926: PPUSH
 927: LD_VAR 0 1
 931: PPUSH
 932: CALL_OW 74
 936: PPUSH
 937: CALL_OW 115
 941: GO 882
 943: POP
 944: POP
// end ;
 945: PPOPN 1
 947: END
// every 3 do var i , enemy , x , y , d ;
 948: GO 950
 950: DISABLE
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
// begin enable ;
 958: ENABLE
// for i := 2 to huntersAmount do
 959: LD_ADDR_VAR 0 1
 963: PUSH
 964: DOUBLE
 965: LD_INT 2
 967: DEC
 968: ST_TO_ADDR
 969: LD_EXP 3
 973: PUSH
 974: FOR_TO
 975: IFFALSE 1314
// begin if not HasTask ( hunters [ i ] ) then
 977: LD_EXP 7
 981: PUSH
 982: LD_VAR 0 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 314
 992: NOT
 993: IFFALSE 1312
// begin enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 0 ] ) , hunters [ i ] ) ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_INT 22
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: CALL_OW 69
1014: PPUSH
1015: LD_EXP 7
1019: PUSH
1020: LD_VAR 0 1
1024: ARRAY
1025: PPUSH
1026: CALL_OW 74
1030: ST_TO_ADDR
// if not enemy then
1031: LD_VAR 0 2
1035: NOT
1036: IFFALSE 1040
// continue ;
1038: GO 974
// if GetDistUnits ( hunters [ i ] , enemy ) < 17 then
1040: LD_EXP 7
1044: PUSH
1045: LD_VAR 0 1
1049: ARRAY
1050: PPUSH
1051: LD_VAR 0 2
1055: PPUSH
1056: CALL_OW 296
1060: PUSH
1061: LD_INT 17
1063: LESS
1064: IFFALSE 1167
// begin if GetClass ( hunters [ i ] ) = class_desert_warior then
1066: LD_EXP 7
1070: PUSH
1071: LD_VAR 0 1
1075: ARRAY
1076: PPUSH
1077: CALL_OW 257
1081: PUSH
1082: LD_INT 11
1084: EQUAL
1085: IFFALSE 1145
// if GetClass ( enemy ) in [ class_frog , class_fish , class_baggie ] then
1087: LD_VAR 0 2
1091: PPUSH
1092: CALL_OW 257
1096: PUSH
1097: LD_INT 19
1099: PUSH
1100: LD_INT 20
1102: PUSH
1103: LD_INT 13
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: IN
1111: IFFALSE 1130
// ComCarabine ( hunters [ i ] ) else
1113: LD_EXP 7
1117: PUSH
1118: LD_VAR 0 1
1122: ARRAY
1123: PPUSH
1124: CALL_OW 162
1128: GO 1145
// ComSabre ( hunters [ i ] ) ;
1130: LD_EXP 7
1134: PUSH
1135: LD_VAR 0 1
1139: ARRAY
1140: PPUSH
1141: CALL_OW 163
// ComAttackUnit ( hunters [ i ] , enemy ) ;
1145: LD_EXP 7
1149: PUSH
1150: LD_VAR 0 1
1154: ARRAY
1155: PPUSH
1156: LD_VAR 0 2
1160: PPUSH
1161: CALL_OW 115
// end else
1165: GO 1312
// begin d := rand ( 0 , 5 ) ;
1167: LD_ADDR_VAR 0 5
1171: PUSH
1172: LD_INT 0
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: CALL_OW 12
1182: ST_TO_ADDR
// x := ShiftX ( GetX ( hunters [ i ] ) , d , 8 ) ;
1183: LD_ADDR_VAR 0 3
1187: PUSH
1188: LD_EXP 7
1192: PUSH
1193: LD_VAR 0 1
1197: ARRAY
1198: PPUSH
1199: CALL_OW 250
1203: PPUSH
1204: LD_VAR 0 5
1208: PPUSH
1209: LD_INT 8
1211: PPUSH
1212: CALL_OW 272
1216: ST_TO_ADDR
// y := ShiftY ( GetY ( hunters [ i ] ) , d , 8 ) ;
1217: LD_ADDR_VAR 0 4
1221: PUSH
1222: LD_EXP 7
1226: PUSH
1227: LD_VAR 0 1
1231: ARRAY
1232: PPUSH
1233: CALL_OW 251
1237: PPUSH
1238: LD_VAR 0 5
1242: PPUSH
1243: LD_INT 8
1245: PPUSH
1246: CALL_OW 273
1250: ST_TO_ADDR
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
1251: LD_VAR 0 3
1255: PPUSH
1256: LD_VAR 0 4
1260: PPUSH
1261: CALL_OW 488
1265: PUSH
1266: LD_VAR 0 3
1270: PPUSH
1271: LD_VAR 0 4
1275: PPUSH
1276: CALL_OW 428
1280: PUSH
1281: LD_INT 0
1283: EQUAL
1284: AND
1285: IFFALSE 1312
// ComMoveXY ( hunters [ i ] , x , y ) ;
1287: LD_EXP 7
1291: PUSH
1292: LD_VAR 0 1
1296: ARRAY
1297: PPUSH
1298: LD_VAR 0 3
1302: PPUSH
1303: LD_VAR 0 4
1307: PPUSH
1308: CALL_OW 111
// end ; end ; end ;
1312: GO 974
1314: POP
1315: POP
// end ; end_of_file
1316: PPOPN 5
1318: END
// on UnitGoesToRed ( un ) do var i ;
1319: LD_INT 0
1321: PPUSH
// begin if GetSide ( un ) = 1 then
1322: LD_VAR 0 1
1326: PPUSH
1327: CALL_OW 255
1331: PUSH
1332: LD_INT 1
1334: EQUAL
1335: IFFALSE 1344
// YouLost ( hunt2 ) ;
1337: LD_STRING hunt2
1339: PPUSH
1340: CALL_OW 104
// if GetSide ( un ) > 1 then
1344: LD_VAR 0 1
1348: PPUSH
1349: CALL_OW 255
1353: PUSH
1354: LD_INT 1
1356: GREATER
1357: IFFALSE 1410
// begin for i := 1 to 6 do
1359: LD_ADDR_VAR 0 2
1363: PUSH
1364: DOUBLE
1365: LD_INT 1
1367: DEC
1368: ST_TO_ADDR
1369: LD_INT 6
1371: PUSH
1372: FOR_TO
1373: IFFALSE 1396
// begin wait ( 0 0$1 ) ;
1375: LD_INT 35
1377: PPUSH
1378: CALL_OW 67
// SetLives ( un , 249 ) ;
1382: LD_VAR 0 1
1386: PPUSH
1387: LD_INT 249
1389: PPUSH
1390: CALL_OW 234
// end ;
1394: GO 1372
1396: POP
1397: POP
// SetLives ( un , 1000 ) ;
1398: LD_VAR 0 1
1402: PPUSH
1403: LD_INT 1000
1405: PPUSH
1406: CALL_OW 234
// end ; end ;
1410: PPOPN 2
1412: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 > 1 then
1413: LD_VAR 0 1
1417: PUSH
1418: LD_INT 1
1420: EQUAL
1421: PUSH
1422: LD_VAR 0 2
1426: PUSH
1427: LD_INT 1
1429: GREATER
1430: AND
1431: IFFALSE 1440
// YouLost ( hunt1 ) ;
1433: LD_STRING hunt1
1435: PPUSH
1436: CALL_OW 104
// end ;
1440: PPOPN 2
1442: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do var point ;
1443: LD_INT 0
1445: PPUSH
// begin point := 0 ;
1446: LD_ADDR_VAR 0 4
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// case GetClass ( un ) of class_fish :
1454: LD_VAR 0 1
1458: PPUSH
1459: CALL_OW 257
1463: PUSH
1464: LD_INT 20
1466: DOUBLE
1467: EQUAL
1468: IFTRUE 1472
1470: GO 1483
1472: POP
// point := 10 ; class_horse :
1473: LD_ADDR_VAR 0 4
1477: PUSH
1478: LD_INT 10
1480: ST_TO_ADDR
1481: GO 1619
1483: LD_EXP 5
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1504
1493: POP
// point := 10 ; class_baggie :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 10
1501: ST_TO_ADDR
1502: GO 1619
1504: LD_INT 13
1506: DOUBLE
1507: EQUAL
1508: IFTRUE 1512
1510: GO 1523
1512: POP
// point := 5 ; class_phororhacos :
1513: LD_ADDR_VAR 0 4
1517: PUSH
1518: LD_INT 5
1520: ST_TO_ADDR
1521: GO 1619
1523: LD_INT 18
1525: DOUBLE
1526: EQUAL
1527: IFTRUE 1531
1529: GO 1542
1531: POP
// point := 10 ; class_tiger :
1532: LD_ADDR_VAR 0 4
1536: PUSH
1537: LD_INT 10
1539: ST_TO_ADDR
1540: GO 1619
1542: LD_INT 14
1544: DOUBLE
1545: EQUAL
1546: IFTRUE 1550
1548: GO 1561
1550: POP
// point := 20 ; class_apeman :
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_INT 20
1558: ST_TO_ADDR
1559: GO 1619
1561: LD_INT 12
1563: DOUBLE
1564: EQUAL
1565: IFTRUE 1569
1567: GO 1580
1569: POP
// point := 30 ; class_apeman_soldier :
1570: LD_ADDR_VAR 0 4
1574: PUSH
1575: LD_INT 30
1577: ST_TO_ADDR
1578: GO 1619
1580: LD_INT 15
1582: DOUBLE
1583: EQUAL
1584: IFTRUE 1588
1586: GO 1599
1588: POP
// point := 50 ; class_frog :
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_INT 50
1596: ST_TO_ADDR
1597: GO 1619
1599: LD_INT 19
1601: DOUBLE
1602: EQUAL
1603: IFTRUE 1607
1605: GO 1618
1607: POP
// point := 10 ; end ;
1608: LD_ADDR_VAR 0 4
1612: PUSH
1613: LD_INT 10
1615: ST_TO_ADDR
1616: GO 1619
1618: POP
// if point then
1619: LD_VAR 0 4
1623: IFFALSE 1662
// points := Replace ( points , killer_side , points [ killer_side ] + point ) ;
1625: LD_ADDR_EXP 6
1629: PUSH
1630: LD_EXP 6
1634: PPUSH
1635: LD_VAR 0 2
1639: PPUSH
1640: LD_EXP 6
1644: PUSH
1645: LD_VAR 0 2
1649: ARRAY
1650: PUSH
1651: LD_VAR 0 4
1655: PLUS
1656: PPUSH
1657: CALL_OW 1
1661: ST_TO_ADDR
// end ;
1662: PPOPN 4
1664: END
// every 0 0$20 trigger FilterAllUnits ( [ f_side , 0 ] ) < 10 do
1665: LD_INT 22
1667: PUSH
1668: LD_INT 0
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: PPUSH
1675: CALL_OW 69
1679: PUSH
1680: LD_INT 10
1682: LESS
1683: IFFALSE 1797
1685: GO 1687
1687: DISABLE
// begin enable ;
1688: ENABLE
// PrepareNature ( nat_area , wat_area , [ rand ( 0 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 2 , 4 ) , rand ( 2 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 0 , 2 ) ] ) ;
1689: LD_INT 2
1691: PPUSH
1692: LD_INT 1
1694: PPUSH
1695: LD_INT 0
1697: PPUSH
1698: LD_INT 4
1700: PPUSH
1701: CALL_OW 12
1705: PUSH
1706: LD_INT 0
1708: PPUSH
1709: LD_INT 2
1711: PPUSH
1712: CALL_OW 12
1716: PUSH
1717: LD_INT 0
1719: PPUSH
1720: LD_INT 4
1722: PPUSH
1723: CALL_OW 12
1727: PUSH
1728: LD_INT 2
1730: PPUSH
1731: LD_INT 4
1733: PPUSH
1734: CALL_OW 12
1738: PUSH
1739: LD_INT 2
1741: PPUSH
1742: LD_INT 4
1744: PPUSH
1745: CALL_OW 12
1749: PUSH
1750: LD_INT 0
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PUSH
1761: LD_INT 0
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 0
1774: PPUSH
1775: LD_INT 2
1777: PPUSH
1778: CALL_OW 12
1782: PUSH
1783: EMPTY
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: PPUSH
1793: CALL 399 0 3
// end ;
1797: END
// every 0 0$1 do var i ;
1798: GO 1800
1800: DISABLE
1801: LD_INT 0
1803: PPUSH
// begin enable ;
1804: ENABLE
// display_strings := [ ] ;
1805: LD_ADDR_OWVAR 47
1809: PUSH
1810: EMPTY
1811: ST_TO_ADDR
// for i := 1 to huntersAmount do
1812: LD_ADDR_VAR 0 1
1816: PUSH
1817: DOUBLE
1818: LD_INT 1
1820: DEC
1821: ST_TO_ADDR
1822: LD_EXP 3
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1962
// begin display_strings := display_strings ^ [ #player & i , i , points [ i ] ] ;
1830: LD_ADDR_OWVAR 47
1834: PUSH
1835: LD_OWVAR 47
1839: PUSH
1840: LD_STRING #player
1842: PUSH
1843: LD_VAR 0 1
1847: STR
1848: PUSH
1849: LD_VAR 0 1
1853: PUSH
1854: LD_EXP 6
1858: PUSH
1859: LD_VAR 0 1
1863: ARRAY
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: ADD
1870: ST_TO_ADDR
// if points [ i ] >= [ 750 , 1250 , 2000 ] [ Difficulty ] then
1871: LD_EXP 6
1875: PUSH
1876: LD_VAR 0 1
1880: ARRAY
1881: PUSH
1882: LD_INT 750
1884: PUSH
1885: LD_INT 1250
1887: PUSH
1888: LD_INT 2000
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: PUSH
1896: LD_OWVAR 67
1900: ARRAY
1901: GREATEREQUAL
1902: IFFALSE 1960
// begin if i = 1 then
1904: LD_VAR 0 1
1908: PUSH
1909: LD_INT 1
1911: EQUAL
1912: IFFALSE 1953
// begin DialogueOn ;
1914: CALL_OW 6
// SetAchievement ( ACH_HUNT ) ;
1918: LD_STRING ACH_HUNT
1920: PPUSH
1921: CALL_OW 543
// display_strings := [ #hunting-win ] ;
1925: LD_ADDR_OWVAR 47
1929: PUSH
1930: LD_STRING #hunting-win
1932: PUSH
1933: EMPTY
1934: LIST
1935: ST_TO_ADDR
// dwait ( 0 0$5 ) ;
1936: LD_INT 175
1938: PPUSH
1939: CALL_OW 68
// YouWin ;
1943: CALL_OW 103
// DialogueOff ;
1947: CALL_OW 7
// end else
1951: GO 1960
// YouLost ( hunt3 ) ;
1953: LD_STRING hunt3
1955: PPUSH
1956: CALL_OW 104
// end ; end ;
1960: GO 1827
1962: POP
1963: POP
// end ; end_of_file end_of_file
1964: PPOPN 1
1966: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
1967: LD_VAR 0 2
1971: PUSH
1972: LD_INT 100
1974: EQUAL
1975: IFFALSE 2924
// begin if not StreamModeActive then
1977: LD_EXP 8
1981: NOT
1982: IFFALSE 1992
// StreamModeActive := true ;
1984: LD_ADDR_EXP 8
1988: PUSH
1989: LD_INT 1
1991: ST_TO_ADDR
// if p3 = 0 then
1992: LD_VAR 0 3
1996: PUSH
1997: LD_INT 0
1999: EQUAL
2000: IFFALSE 2006
// InitStreamMode ;
2002: CALL 3082 0 0
// if p3 = 1 then
2006: LD_VAR 0 3
2010: PUSH
2011: LD_INT 1
2013: EQUAL
2014: IFFALSE 2024
// sRocket := true ;
2016: LD_ADDR_EXP 13
2020: PUSH
2021: LD_INT 1
2023: ST_TO_ADDR
// if p3 = 2 then
2024: LD_VAR 0 3
2028: PUSH
2029: LD_INT 2
2031: EQUAL
2032: IFFALSE 2042
// sSpeed := true ;
2034: LD_ADDR_EXP 12
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// if p3 = 3 then
2042: LD_VAR 0 3
2046: PUSH
2047: LD_INT 3
2049: EQUAL
2050: IFFALSE 2060
// sEngine := true ;
2052: LD_ADDR_EXP 14
2056: PUSH
2057: LD_INT 1
2059: ST_TO_ADDR
// if p3 = 4 then
2060: LD_VAR 0 3
2064: PUSH
2065: LD_INT 4
2067: EQUAL
2068: IFFALSE 2078
// sSpec := true ;
2070: LD_ADDR_EXP 11
2074: PUSH
2075: LD_INT 1
2077: ST_TO_ADDR
// if p3 = 5 then
2078: LD_VAR 0 3
2082: PUSH
2083: LD_INT 5
2085: EQUAL
2086: IFFALSE 2096
// sLevel := true ;
2088: LD_ADDR_EXP 15
2092: PUSH
2093: LD_INT 1
2095: ST_TO_ADDR
// if p3 = 6 then
2096: LD_VAR 0 3
2100: PUSH
2101: LD_INT 6
2103: EQUAL
2104: IFFALSE 2114
// sArmoury := true ;
2106: LD_ADDR_EXP 16
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// if p3 = 7 then
2114: LD_VAR 0 3
2118: PUSH
2119: LD_INT 7
2121: EQUAL
2122: IFFALSE 2132
// sRadar := true ;
2124: LD_ADDR_EXP 17
2128: PUSH
2129: LD_INT 1
2131: ST_TO_ADDR
// if p3 = 8 then
2132: LD_VAR 0 3
2136: PUSH
2137: LD_INT 8
2139: EQUAL
2140: IFFALSE 2150
// sBunker := true ;
2142: LD_ADDR_EXP 18
2146: PUSH
2147: LD_INT 1
2149: ST_TO_ADDR
// if p3 = 9 then
2150: LD_VAR 0 3
2154: PUSH
2155: LD_INT 9
2157: EQUAL
2158: IFFALSE 2168
// sHack := true ;
2160: LD_ADDR_EXP 19
2164: PUSH
2165: LD_INT 1
2167: ST_TO_ADDR
// if p3 = 10 then
2168: LD_VAR 0 3
2172: PUSH
2173: LD_INT 10
2175: EQUAL
2176: IFFALSE 2186
// sFire := true ;
2178: LD_ADDR_EXP 20
2182: PUSH
2183: LD_INT 1
2185: ST_TO_ADDR
// if p3 = 11 then
2186: LD_VAR 0 3
2190: PUSH
2191: LD_INT 11
2193: EQUAL
2194: IFFALSE 2204
// sRefresh := true ;
2196: LD_ADDR_EXP 21
2200: PUSH
2201: LD_INT 1
2203: ST_TO_ADDR
// if p3 = 12 then
2204: LD_VAR 0 3
2208: PUSH
2209: LD_INT 12
2211: EQUAL
2212: IFFALSE 2222
// sExp := true ;
2214: LD_ADDR_EXP 22
2218: PUSH
2219: LD_INT 1
2221: ST_TO_ADDR
// if p3 = 13 then
2222: LD_VAR 0 3
2226: PUSH
2227: LD_INT 13
2229: EQUAL
2230: IFFALSE 2240
// sDepot := true ;
2232: LD_ADDR_EXP 23
2236: PUSH
2237: LD_INT 1
2239: ST_TO_ADDR
// if p3 = 14 then
2240: LD_VAR 0 3
2244: PUSH
2245: LD_INT 14
2247: EQUAL
2248: IFFALSE 2258
// sFlag := true ;
2250: LD_ADDR_EXP 24
2254: PUSH
2255: LD_INT 1
2257: ST_TO_ADDR
// if p3 = 15 then
2258: LD_VAR 0 3
2262: PUSH
2263: LD_INT 15
2265: EQUAL
2266: IFFALSE 2276
// sKamikadze := true ;
2268: LD_ADDR_EXP 32
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// if p3 = 16 then
2276: LD_VAR 0 3
2280: PUSH
2281: LD_INT 16
2283: EQUAL
2284: IFFALSE 2294
// sTroll := true ;
2286: LD_ADDR_EXP 33
2290: PUSH
2291: LD_INT 1
2293: ST_TO_ADDR
// if p3 = 17 then
2294: LD_VAR 0 3
2298: PUSH
2299: LD_INT 17
2301: EQUAL
2302: IFFALSE 2312
// sSlow := true ;
2304: LD_ADDR_EXP 34
2308: PUSH
2309: LD_INT 1
2311: ST_TO_ADDR
// if p3 = 18 then
2312: LD_VAR 0 3
2316: PUSH
2317: LD_INT 18
2319: EQUAL
2320: IFFALSE 2330
// sLack := true ;
2322: LD_ADDR_EXP 35
2326: PUSH
2327: LD_INT 1
2329: ST_TO_ADDR
// if p3 = 19 then
2330: LD_VAR 0 3
2334: PUSH
2335: LD_INT 19
2337: EQUAL
2338: IFFALSE 2348
// sTank := true ;
2340: LD_ADDR_EXP 37
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// if p3 = 20 then
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 20
2355: EQUAL
2356: IFFALSE 2366
// sRemote := true ;
2358: LD_ADDR_EXP 38
2362: PUSH
2363: LD_INT 1
2365: ST_TO_ADDR
// if p3 = 21 then
2366: LD_VAR 0 3
2370: PUSH
2371: LD_INT 21
2373: EQUAL
2374: IFFALSE 2384
// sPowell := true ;
2376: LD_ADDR_EXP 39
2380: PUSH
2381: LD_INT 1
2383: ST_TO_ADDR
// if p3 = 22 then
2384: LD_VAR 0 3
2388: PUSH
2389: LD_INT 22
2391: EQUAL
2392: IFFALSE 2402
// sTeleport := true ;
2394: LD_ADDR_EXP 42
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// if p3 = 23 then
2402: LD_VAR 0 3
2406: PUSH
2407: LD_INT 23
2409: EQUAL
2410: IFFALSE 2420
// sOilTower := true ;
2412: LD_ADDR_EXP 44
2416: PUSH
2417: LD_INT 1
2419: ST_TO_ADDR
// if p3 = 24 then
2420: LD_VAR 0 3
2424: PUSH
2425: LD_INT 24
2427: EQUAL
2428: IFFALSE 2438
// sShovel := true ;
2430: LD_ADDR_EXP 45
2434: PUSH
2435: LD_INT 1
2437: ST_TO_ADDR
// if p3 = 25 then
2438: LD_VAR 0 3
2442: PUSH
2443: LD_INT 25
2445: EQUAL
2446: IFFALSE 2456
// sSheik := true ;
2448: LD_ADDR_EXP 46
2452: PUSH
2453: LD_INT 1
2455: ST_TO_ADDR
// if p3 = 26 then
2456: LD_VAR 0 3
2460: PUSH
2461: LD_INT 26
2463: EQUAL
2464: IFFALSE 2474
// sEarthquake := true ;
2466: LD_ADDR_EXP 48
2470: PUSH
2471: LD_INT 1
2473: ST_TO_ADDR
// if p3 = 27 then
2474: LD_VAR 0 3
2478: PUSH
2479: LD_INT 27
2481: EQUAL
2482: IFFALSE 2492
// sAI := true ;
2484: LD_ADDR_EXP 49
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// if p3 = 28 then
2492: LD_VAR 0 3
2496: PUSH
2497: LD_INT 28
2499: EQUAL
2500: IFFALSE 2510
// sCargo := true ;
2502: LD_ADDR_EXP 52
2506: PUSH
2507: LD_INT 1
2509: ST_TO_ADDR
// if p3 = 29 then
2510: LD_VAR 0 3
2514: PUSH
2515: LD_INT 29
2517: EQUAL
2518: IFFALSE 2528
// sDLaser := true ;
2520: LD_ADDR_EXP 53
2524: PUSH
2525: LD_INT 1
2527: ST_TO_ADDR
// if p3 = 30 then
2528: LD_VAR 0 3
2532: PUSH
2533: LD_INT 30
2535: EQUAL
2536: IFFALSE 2546
// sExchange := true ;
2538: LD_ADDR_EXP 54
2542: PUSH
2543: LD_INT 1
2545: ST_TO_ADDR
// if p3 = 31 then
2546: LD_VAR 0 3
2550: PUSH
2551: LD_INT 31
2553: EQUAL
2554: IFFALSE 2564
// sFac := true ;
2556: LD_ADDR_EXP 55
2560: PUSH
2561: LD_INT 1
2563: ST_TO_ADDR
// if p3 = 32 then
2564: LD_VAR 0 3
2568: PUSH
2569: LD_INT 32
2571: EQUAL
2572: IFFALSE 2582
// sPower := true ;
2574: LD_ADDR_EXP 56
2578: PUSH
2579: LD_INT 1
2581: ST_TO_ADDR
// if p3 = 33 then
2582: LD_VAR 0 3
2586: PUSH
2587: LD_INT 33
2589: EQUAL
2590: IFFALSE 2600
// sRandom := true ;
2592: LD_ADDR_EXP 57
2596: PUSH
2597: LD_INT 1
2599: ST_TO_ADDR
// if p3 = 34 then
2600: LD_VAR 0 3
2604: PUSH
2605: LD_INT 34
2607: EQUAL
2608: IFFALSE 2618
// sShield := true ;
2610: LD_ADDR_EXP 58
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// if p3 = 35 then
2618: LD_VAR 0 3
2622: PUSH
2623: LD_INT 35
2625: EQUAL
2626: IFFALSE 2636
// sTime := true ;
2628: LD_ADDR_EXP 59
2632: PUSH
2633: LD_INT 1
2635: ST_TO_ADDR
// if p3 = 36 then
2636: LD_VAR 0 3
2640: PUSH
2641: LD_INT 36
2643: EQUAL
2644: IFFALSE 2654
// sTools := true ;
2646: LD_ADDR_EXP 60
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// if p3 = 101 then
2654: LD_VAR 0 3
2658: PUSH
2659: LD_INT 101
2661: EQUAL
2662: IFFALSE 2672
// sSold := true ;
2664: LD_ADDR_EXP 25
2668: PUSH
2669: LD_INT 1
2671: ST_TO_ADDR
// if p3 = 102 then
2672: LD_VAR 0 3
2676: PUSH
2677: LD_INT 102
2679: EQUAL
2680: IFFALSE 2690
// sDiff := true ;
2682: LD_ADDR_EXP 26
2686: PUSH
2687: LD_INT 1
2689: ST_TO_ADDR
// if p3 = 103 then
2690: LD_VAR 0 3
2694: PUSH
2695: LD_INT 103
2697: EQUAL
2698: IFFALSE 2708
// sFog := true ;
2700: LD_ADDR_EXP 29
2704: PUSH
2705: LD_INT 1
2707: ST_TO_ADDR
// if p3 = 104 then
2708: LD_VAR 0 3
2712: PUSH
2713: LD_INT 104
2715: EQUAL
2716: IFFALSE 2726
// sReset := true ;
2718: LD_ADDR_EXP 30
2722: PUSH
2723: LD_INT 1
2725: ST_TO_ADDR
// if p3 = 105 then
2726: LD_VAR 0 3
2730: PUSH
2731: LD_INT 105
2733: EQUAL
2734: IFFALSE 2744
// sSun := true ;
2736: LD_ADDR_EXP 31
2740: PUSH
2741: LD_INT 1
2743: ST_TO_ADDR
// if p3 = 106 then
2744: LD_VAR 0 3
2748: PUSH
2749: LD_INT 106
2751: EQUAL
2752: IFFALSE 2762
// sTiger := true ;
2754: LD_ADDR_EXP 27
2758: PUSH
2759: LD_INT 1
2761: ST_TO_ADDR
// if p3 = 107 then
2762: LD_VAR 0 3
2766: PUSH
2767: LD_INT 107
2769: EQUAL
2770: IFFALSE 2780
// sBomb := true ;
2772: LD_ADDR_EXP 28
2776: PUSH
2777: LD_INT 1
2779: ST_TO_ADDR
// if p3 = 108 then
2780: LD_VAR 0 3
2784: PUSH
2785: LD_INT 108
2787: EQUAL
2788: IFFALSE 2798
// sWound := true ;
2790: LD_ADDR_EXP 36
2794: PUSH
2795: LD_INT 1
2797: ST_TO_ADDR
// if p3 = 109 then
2798: LD_VAR 0 3
2802: PUSH
2803: LD_INT 109
2805: EQUAL
2806: IFFALSE 2816
// sBetray := true ;
2808: LD_ADDR_EXP 40
2812: PUSH
2813: LD_INT 1
2815: ST_TO_ADDR
// if p3 = 110 then
2816: LD_VAR 0 3
2820: PUSH
2821: LD_INT 110
2823: EQUAL
2824: IFFALSE 2834
// sContamin := true ;
2826: LD_ADDR_EXP 41
2830: PUSH
2831: LD_INT 1
2833: ST_TO_ADDR
// if p3 = 111 then
2834: LD_VAR 0 3
2838: PUSH
2839: LD_INT 111
2841: EQUAL
2842: IFFALSE 2852
// sOil := true ;
2844: LD_ADDR_EXP 43
2848: PUSH
2849: LD_INT 1
2851: ST_TO_ADDR
// if p3 = 112 then
2852: LD_VAR 0 3
2856: PUSH
2857: LD_INT 112
2859: EQUAL
2860: IFFALSE 2870
// sStu := true ;
2862: LD_ADDR_EXP 47
2866: PUSH
2867: LD_INT 1
2869: ST_TO_ADDR
// if p3 = 113 then
2870: LD_VAR 0 3
2874: PUSH
2875: LD_INT 113
2877: EQUAL
2878: IFFALSE 2888
// sBazooka := true ;
2880: LD_ADDR_EXP 50
2884: PUSH
2885: LD_INT 1
2887: ST_TO_ADDR
// if p3 = 114 then
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 114
2895: EQUAL
2896: IFFALSE 2906
// sMortar := true ;
2898: LD_ADDR_EXP 51
2902: PUSH
2903: LD_INT 1
2905: ST_TO_ADDR
// if p3 = 115 then
2906: LD_VAR 0 3
2910: PUSH
2911: LD_INT 115
2913: EQUAL
2914: IFFALSE 2924
// sRanger := true ;
2916: LD_ADDR_EXP 61
2920: PUSH
2921: LD_INT 1
2923: ST_TO_ADDR
// end ; if p2 = 101 then
2924: LD_VAR 0 2
2928: PUSH
2929: LD_INT 101
2931: EQUAL
2932: IFFALSE 3060
// begin case p3 of 1 :
2934: LD_VAR 0 3
2938: PUSH
2939: LD_INT 1
2941: DOUBLE
2942: EQUAL
2943: IFTRUE 2947
2945: GO 2954
2947: POP
// hHackUnlimitedResources ; 2 :
2948: CALL 14095 0 0
2952: GO 3060
2954: LD_INT 2
2956: DOUBLE
2957: EQUAL
2958: IFTRUE 2962
2960: GO 2969
2962: POP
// hHackSetLevel10 ; 3 :
2963: CALL 14228 0 0
2967: GO 3060
2969: LD_INT 3
2971: DOUBLE
2972: EQUAL
2973: IFTRUE 2977
2975: GO 2984
2977: POP
// hHackSetLevel10YourUnits ; 4 :
2978: CALL 14313 0 0
2982: GO 3060
2984: LD_INT 4
2986: DOUBLE
2987: EQUAL
2988: IFTRUE 2992
2990: GO 2999
2992: POP
// hHackInvincible ; 5 :
2993: CALL 14761 0 0
2997: GO 3060
2999: LD_INT 5
3001: DOUBLE
3002: EQUAL
3003: IFTRUE 3007
3005: GO 3014
3007: POP
// hHackInvisible ; 6 :
3008: CALL 14872 0 0
3012: GO 3060
3014: LD_INT 6
3016: DOUBLE
3017: EQUAL
3018: IFTRUE 3022
3020: GO 3029
3022: POP
// hHackChangeYourSide ; 7 :
3023: CALL 14929 0 0
3027: GO 3060
3029: LD_INT 7
3031: DOUBLE
3032: EQUAL
3033: IFTRUE 3037
3035: GO 3044
3037: POP
// hHackChangeUnitSide ; 8 :
3038: CALL 14971 0 0
3042: GO 3060
3044: LD_INT 8
3046: DOUBLE
3047: EQUAL
3048: IFTRUE 3052
3050: GO 3059
3052: POP
// hHackFog ; end ;
3053: CALL 15072 0 0
3057: GO 3060
3059: POP
// end ; end ;
3060: PPOPN 6
3062: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
3063: GO 3065
3065: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
3066: LD_STRING initStreamRollete();
3068: PPUSH
3069: CALL_OW 559
// InitStreamMode ;
3073: CALL 3082 0 0
// DefineStreamItems ( ) ;
3077: CALL 3522 0 0
// end ;
3081: END
// function InitStreamMode ; begin
3082: LD_INT 0
3084: PPUSH
// streamModeActive := false ;
3085: LD_ADDR_EXP 8
3089: PUSH
3090: LD_INT 0
3092: ST_TO_ADDR
// normalCounter := 36 ;
3093: LD_ADDR_EXP 9
3097: PUSH
3098: LD_INT 36
3100: ST_TO_ADDR
// hardcoreCounter := 16 ;
3101: LD_ADDR_EXP 10
3105: PUSH
3106: LD_INT 16
3108: ST_TO_ADDR
// sRocket := false ;
3109: LD_ADDR_EXP 13
3113: PUSH
3114: LD_INT 0
3116: ST_TO_ADDR
// sSpeed := false ;
3117: LD_ADDR_EXP 12
3121: PUSH
3122: LD_INT 0
3124: ST_TO_ADDR
// sEngine := false ;
3125: LD_ADDR_EXP 14
3129: PUSH
3130: LD_INT 0
3132: ST_TO_ADDR
// sSpec := false ;
3133: LD_ADDR_EXP 11
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// sLevel := false ;
3141: LD_ADDR_EXP 15
3145: PUSH
3146: LD_INT 0
3148: ST_TO_ADDR
// sArmoury := false ;
3149: LD_ADDR_EXP 16
3153: PUSH
3154: LD_INT 0
3156: ST_TO_ADDR
// sRadar := false ;
3157: LD_ADDR_EXP 17
3161: PUSH
3162: LD_INT 0
3164: ST_TO_ADDR
// sBunker := false ;
3165: LD_ADDR_EXP 18
3169: PUSH
3170: LD_INT 0
3172: ST_TO_ADDR
// sHack := false ;
3173: LD_ADDR_EXP 19
3177: PUSH
3178: LD_INT 0
3180: ST_TO_ADDR
// sFire := false ;
3181: LD_ADDR_EXP 20
3185: PUSH
3186: LD_INT 0
3188: ST_TO_ADDR
// sRefresh := false ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_INT 0
3196: ST_TO_ADDR
// sExp := false ;
3197: LD_ADDR_EXP 22
3201: PUSH
3202: LD_INT 0
3204: ST_TO_ADDR
// sDepot := false ;
3205: LD_ADDR_EXP 23
3209: PUSH
3210: LD_INT 0
3212: ST_TO_ADDR
// sFlag := false ;
3213: LD_ADDR_EXP 24
3217: PUSH
3218: LD_INT 0
3220: ST_TO_ADDR
// sKamikadze := false ;
3221: LD_ADDR_EXP 32
3225: PUSH
3226: LD_INT 0
3228: ST_TO_ADDR
// sTroll := false ;
3229: LD_ADDR_EXP 33
3233: PUSH
3234: LD_INT 0
3236: ST_TO_ADDR
// sSlow := false ;
3237: LD_ADDR_EXP 34
3241: PUSH
3242: LD_INT 0
3244: ST_TO_ADDR
// sLack := false ;
3245: LD_ADDR_EXP 35
3249: PUSH
3250: LD_INT 0
3252: ST_TO_ADDR
// sTank := false ;
3253: LD_ADDR_EXP 37
3257: PUSH
3258: LD_INT 0
3260: ST_TO_ADDR
// sRemote := false ;
3261: LD_ADDR_EXP 38
3265: PUSH
3266: LD_INT 0
3268: ST_TO_ADDR
// sPowell := false ;
3269: LD_ADDR_EXP 39
3273: PUSH
3274: LD_INT 0
3276: ST_TO_ADDR
// sTeleport := false ;
3277: LD_ADDR_EXP 42
3281: PUSH
3282: LD_INT 0
3284: ST_TO_ADDR
// sOilTower := false ;
3285: LD_ADDR_EXP 44
3289: PUSH
3290: LD_INT 0
3292: ST_TO_ADDR
// sShovel := false ;
3293: LD_ADDR_EXP 45
3297: PUSH
3298: LD_INT 0
3300: ST_TO_ADDR
// sSheik := false ;
3301: LD_ADDR_EXP 46
3305: PUSH
3306: LD_INT 0
3308: ST_TO_ADDR
// sEarthquake := false ;
3309: LD_ADDR_EXP 48
3313: PUSH
3314: LD_INT 0
3316: ST_TO_ADDR
// sAI := false ;
3317: LD_ADDR_EXP 49
3321: PUSH
3322: LD_INT 0
3324: ST_TO_ADDR
// sCargo := false ;
3325: LD_ADDR_EXP 52
3329: PUSH
3330: LD_INT 0
3332: ST_TO_ADDR
// sDLaser := false ;
3333: LD_ADDR_EXP 53
3337: PUSH
3338: LD_INT 0
3340: ST_TO_ADDR
// sExchange := false ;
3341: LD_ADDR_EXP 54
3345: PUSH
3346: LD_INT 0
3348: ST_TO_ADDR
// sFac := false ;
3349: LD_ADDR_EXP 55
3353: PUSH
3354: LD_INT 0
3356: ST_TO_ADDR
// sPower := false ;
3357: LD_ADDR_EXP 56
3361: PUSH
3362: LD_INT 0
3364: ST_TO_ADDR
// sRandom := false ;
3365: LD_ADDR_EXP 57
3369: PUSH
3370: LD_INT 0
3372: ST_TO_ADDR
// sShield := false ;
3373: LD_ADDR_EXP 58
3377: PUSH
3378: LD_INT 0
3380: ST_TO_ADDR
// sTime := false ;
3381: LD_ADDR_EXP 59
3385: PUSH
3386: LD_INT 0
3388: ST_TO_ADDR
// sTools := false ;
3389: LD_ADDR_EXP 60
3393: PUSH
3394: LD_INT 0
3396: ST_TO_ADDR
// sSold := false ;
3397: LD_ADDR_EXP 25
3401: PUSH
3402: LD_INT 0
3404: ST_TO_ADDR
// sDiff := false ;
3405: LD_ADDR_EXP 26
3409: PUSH
3410: LD_INT 0
3412: ST_TO_ADDR
// sFog := false ;
3413: LD_ADDR_EXP 29
3417: PUSH
3418: LD_INT 0
3420: ST_TO_ADDR
// sReset := false ;
3421: LD_ADDR_EXP 30
3425: PUSH
3426: LD_INT 0
3428: ST_TO_ADDR
// sSun := false ;
3429: LD_ADDR_EXP 31
3433: PUSH
3434: LD_INT 0
3436: ST_TO_ADDR
// sTiger := false ;
3437: LD_ADDR_EXP 27
3441: PUSH
3442: LD_INT 0
3444: ST_TO_ADDR
// sBomb := false ;
3445: LD_ADDR_EXP 28
3449: PUSH
3450: LD_INT 0
3452: ST_TO_ADDR
// sWound := false ;
3453: LD_ADDR_EXP 36
3457: PUSH
3458: LD_INT 0
3460: ST_TO_ADDR
// sBetray := false ;
3461: LD_ADDR_EXP 40
3465: PUSH
3466: LD_INT 0
3468: ST_TO_ADDR
// sContamin := false ;
3469: LD_ADDR_EXP 41
3473: PUSH
3474: LD_INT 0
3476: ST_TO_ADDR
// sOil := false ;
3477: LD_ADDR_EXP 43
3481: PUSH
3482: LD_INT 0
3484: ST_TO_ADDR
// sStu := false ;
3485: LD_ADDR_EXP 47
3489: PUSH
3490: LD_INT 0
3492: ST_TO_ADDR
// sBazooka := false ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_INT 0
3500: ST_TO_ADDR
// sMortar := false ;
3501: LD_ADDR_EXP 51
3505: PUSH
3506: LD_INT 0
3508: ST_TO_ADDR
// sRanger := false ;
3509: LD_ADDR_EXP 61
3513: PUSH
3514: LD_INT 0
3516: ST_TO_ADDR
// end ;
3517: LD_VAR 0 1
3521: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
3522: LD_INT 0
3524: PPUSH
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
// result := [ ] ;
3529: LD_ADDR_VAR 0 1
3533: PUSH
3534: EMPTY
3535: ST_TO_ADDR
// if campaign_id = 1 then
3536: LD_OWVAR 69
3540: PUSH
3541: LD_INT 1
3543: EQUAL
3544: IFFALSE 6482
// begin case mission_number of 1 :
3546: LD_OWVAR 70
3550: PUSH
3551: LD_INT 1
3553: DOUBLE
3554: EQUAL
3555: IFTRUE 3559
3557: GO 3623
3559: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
3560: LD_ADDR_VAR 0 1
3564: PUSH
3565: LD_INT 2
3567: PUSH
3568: LD_INT 4
3570: PUSH
3571: LD_INT 11
3573: PUSH
3574: LD_INT 12
3576: PUSH
3577: LD_INT 15
3579: PUSH
3580: LD_INT 16
3582: PUSH
3583: LD_INT 22
3585: PUSH
3586: LD_INT 23
3588: PUSH
3589: LD_INT 26
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 101
3605: PUSH
3606: LD_INT 102
3608: PUSH
3609: LD_INT 106
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: ST_TO_ADDR
3621: GO 6480
3623: LD_INT 2
3625: DOUBLE
3626: EQUAL
3627: IFTRUE 3631
3629: GO 3703
3631: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
3632: LD_ADDR_VAR 0 1
3636: PUSH
3637: LD_INT 2
3639: PUSH
3640: LD_INT 4
3642: PUSH
3643: LD_INT 11
3645: PUSH
3646: LD_INT 12
3648: PUSH
3649: LD_INT 15
3651: PUSH
3652: LD_INT 16
3654: PUSH
3655: LD_INT 22
3657: PUSH
3658: LD_INT 23
3660: PUSH
3661: LD_INT 26
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: LIST
3668: LIST
3669: LIST
3670: LIST
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_INT 101
3677: PUSH
3678: LD_INT 102
3680: PUSH
3681: LD_INT 105
3683: PUSH
3684: LD_INT 106
3686: PUSH
3687: LD_INT 108
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: LIST
3694: LIST
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: ST_TO_ADDR
3701: GO 6480
3703: LD_INT 3
3705: DOUBLE
3706: EQUAL
3707: IFTRUE 3711
3709: GO 3787
3711: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
3712: LD_ADDR_VAR 0 1
3716: PUSH
3717: LD_INT 2
3719: PUSH
3720: LD_INT 4
3722: PUSH
3723: LD_INT 5
3725: PUSH
3726: LD_INT 11
3728: PUSH
3729: LD_INT 12
3731: PUSH
3732: LD_INT 15
3734: PUSH
3735: LD_INT 16
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 26
3743: PUSH
3744: LD_INT 36
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: LIST
3752: LIST
3753: LIST
3754: LIST
3755: LIST
3756: LIST
3757: LIST
3758: PUSH
3759: LD_INT 101
3761: PUSH
3762: LD_INT 102
3764: PUSH
3765: LD_INT 105
3767: PUSH
3768: LD_INT 106
3770: PUSH
3771: LD_INT 108
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: ST_TO_ADDR
3785: GO 6480
3787: LD_INT 4
3789: DOUBLE
3790: EQUAL
3791: IFTRUE 3795
3793: GO 3879
3795: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
3796: LD_ADDR_VAR 0 1
3800: PUSH
3801: LD_INT 2
3803: PUSH
3804: LD_INT 4
3806: PUSH
3807: LD_INT 5
3809: PUSH
3810: LD_INT 8
3812: PUSH
3813: LD_INT 11
3815: PUSH
3816: LD_INT 12
3818: PUSH
3819: LD_INT 15
3821: PUSH
3822: LD_INT 16
3824: PUSH
3825: LD_INT 22
3827: PUSH
3828: LD_INT 23
3830: PUSH
3831: LD_INT 26
3833: PUSH
3834: LD_INT 36
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 101
3853: PUSH
3854: LD_INT 102
3856: PUSH
3857: LD_INT 105
3859: PUSH
3860: LD_INT 106
3862: PUSH
3863: LD_INT 108
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: ST_TO_ADDR
3877: GO 6480
3879: LD_INT 5
3881: DOUBLE
3882: EQUAL
3883: IFTRUE 3887
3885: GO 3987
3887: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
3888: LD_ADDR_VAR 0 1
3892: PUSH
3893: LD_INT 2
3895: PUSH
3896: LD_INT 4
3898: PUSH
3899: LD_INT 5
3901: PUSH
3902: LD_INT 6
3904: PUSH
3905: LD_INT 8
3907: PUSH
3908: LD_INT 11
3910: PUSH
3911: LD_INT 12
3913: PUSH
3914: LD_INT 15
3916: PUSH
3917: LD_INT 16
3919: PUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 23
3925: PUSH
3926: LD_INT 25
3928: PUSH
3929: LD_INT 26
3931: PUSH
3932: LD_INT 36
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: LIST
3942: LIST
3943: LIST
3944: LIST
3945: LIST
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: PUSH
3951: LD_INT 101
3953: PUSH
3954: LD_INT 102
3956: PUSH
3957: LD_INT 105
3959: PUSH
3960: LD_INT 106
3962: PUSH
3963: LD_INT 108
3965: PUSH
3966: LD_INT 109
3968: PUSH
3969: LD_INT 112
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: EMPTY
3982: LIST
3983: LIST
3984: ST_TO_ADDR
3985: GO 6480
3987: LD_INT 6
3989: DOUBLE
3990: EQUAL
3991: IFTRUE 3995
3993: GO 4115
3995: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
3996: LD_ADDR_VAR 0 1
4000: PUSH
4001: LD_INT 2
4003: PUSH
4004: LD_INT 4
4006: PUSH
4007: LD_INT 5
4009: PUSH
4010: LD_INT 6
4012: PUSH
4013: LD_INT 8
4015: PUSH
4016: LD_INT 11
4018: PUSH
4019: LD_INT 12
4021: PUSH
4022: LD_INT 15
4024: PUSH
4025: LD_INT 16
4027: PUSH
4028: LD_INT 20
4030: PUSH
4031: LD_INT 21
4033: PUSH
4034: LD_INT 22
4036: PUSH
4037: LD_INT 23
4039: PUSH
4040: LD_INT 25
4042: PUSH
4043: LD_INT 26
4045: PUSH
4046: LD_INT 30
4048: PUSH
4049: LD_INT 31
4051: PUSH
4052: LD_INT 32
4054: PUSH
4055: LD_INT 36
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: LIST
4062: LIST
4063: LIST
4064: LIST
4065: LIST
4066: LIST
4067: LIST
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: LIST
4078: PUSH
4079: LD_INT 101
4081: PUSH
4082: LD_INT 102
4084: PUSH
4085: LD_INT 105
4087: PUSH
4088: LD_INT 106
4090: PUSH
4091: LD_INT 108
4093: PUSH
4094: LD_INT 109
4096: PUSH
4097: LD_INT 112
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: ST_TO_ADDR
4113: GO 6480
4115: LD_INT 7
4117: DOUBLE
4118: EQUAL
4119: IFTRUE 4123
4121: GO 4223
4123: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
4124: LD_ADDR_VAR 0 1
4128: PUSH
4129: LD_INT 2
4131: PUSH
4132: LD_INT 4
4134: PUSH
4135: LD_INT 5
4137: PUSH
4138: LD_INT 7
4140: PUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 12
4146: PUSH
4147: LD_INT 15
4149: PUSH
4150: LD_INT 16
4152: PUSH
4153: LD_INT 20
4155: PUSH
4156: LD_INT 21
4158: PUSH
4159: LD_INT 22
4161: PUSH
4162: LD_INT 23
4164: PUSH
4165: LD_INT 25
4167: PUSH
4168: LD_INT 26
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: LIST
4177: LIST
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_INT 101
4189: PUSH
4190: LD_INT 102
4192: PUSH
4193: LD_INT 103
4195: PUSH
4196: LD_INT 105
4198: PUSH
4199: LD_INT 106
4201: PUSH
4202: LD_INT 108
4204: PUSH
4205: LD_INT 112
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: ST_TO_ADDR
4221: GO 6480
4223: LD_INT 8
4225: DOUBLE
4226: EQUAL
4227: IFTRUE 4231
4229: GO 4359
4231: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
4232: LD_ADDR_VAR 0 1
4236: PUSH
4237: LD_INT 2
4239: PUSH
4240: LD_INT 4
4242: PUSH
4243: LD_INT 5
4245: PUSH
4246: LD_INT 6
4248: PUSH
4249: LD_INT 7
4251: PUSH
4252: LD_INT 8
4254: PUSH
4255: LD_INT 11
4257: PUSH
4258: LD_INT 12
4260: PUSH
4261: LD_INT 15
4263: PUSH
4264: LD_INT 16
4266: PUSH
4267: LD_INT 20
4269: PUSH
4270: LD_INT 21
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 23
4278: PUSH
4279: LD_INT 25
4281: PUSH
4282: LD_INT 26
4284: PUSH
4285: LD_INT 30
4287: PUSH
4288: LD_INT 31
4290: PUSH
4291: LD_INT 32
4293: PUSH
4294: LD_INT 36
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: LIST
4301: LIST
4302: LIST
4303: LIST
4304: LIST
4305: LIST
4306: LIST
4307: LIST
4308: LIST
4309: LIST
4310: LIST
4311: LIST
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 101
4321: PUSH
4322: LD_INT 102
4324: PUSH
4325: LD_INT 103
4327: PUSH
4328: LD_INT 105
4330: PUSH
4331: LD_INT 106
4333: PUSH
4334: LD_INT 108
4336: PUSH
4337: LD_INT 109
4339: PUSH
4340: LD_INT 112
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: LIST
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: ST_TO_ADDR
4357: GO 6480
4359: LD_INT 9
4361: DOUBLE
4362: EQUAL
4363: IFTRUE 4367
4365: GO 4503
4367: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
4368: LD_ADDR_VAR 0 1
4372: PUSH
4373: LD_INT 2
4375: PUSH
4376: LD_INT 4
4378: PUSH
4379: LD_INT 5
4381: PUSH
4382: LD_INT 6
4384: PUSH
4385: LD_INT 7
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: LD_INT 11
4393: PUSH
4394: LD_INT 12
4396: PUSH
4397: LD_INT 15
4399: PUSH
4400: LD_INT 16
4402: PUSH
4403: LD_INT 20
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 23
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 26
4420: PUSH
4421: LD_INT 28
4423: PUSH
4424: LD_INT 30
4426: PUSH
4427: LD_INT 31
4429: PUSH
4430: LD_INT 32
4432: PUSH
4433: LD_INT 36
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: LIST
4458: PUSH
4459: LD_INT 101
4461: PUSH
4462: LD_INT 102
4464: PUSH
4465: LD_INT 103
4467: PUSH
4468: LD_INT 105
4470: PUSH
4471: LD_INT 106
4473: PUSH
4474: LD_INT 108
4476: PUSH
4477: LD_INT 109
4479: PUSH
4480: LD_INT 112
4482: PUSH
4483: LD_INT 114
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: LIST
4490: LIST
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: EMPTY
4498: LIST
4499: LIST
4500: ST_TO_ADDR
4501: GO 6480
4503: LD_INT 10
4505: DOUBLE
4506: EQUAL
4507: IFTRUE 4511
4509: GO 4695
4511: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
4512: LD_ADDR_VAR 0 1
4516: PUSH
4517: LD_INT 2
4519: PUSH
4520: LD_INT 4
4522: PUSH
4523: LD_INT 5
4525: PUSH
4526: LD_INT 6
4528: PUSH
4529: LD_INT 7
4531: PUSH
4532: LD_INT 8
4534: PUSH
4535: LD_INT 9
4537: PUSH
4538: LD_INT 10
4540: PUSH
4541: LD_INT 11
4543: PUSH
4544: LD_INT 12
4546: PUSH
4547: LD_INT 13
4549: PUSH
4550: LD_INT 14
4552: PUSH
4553: LD_INT 15
4555: PUSH
4556: LD_INT 16
4558: PUSH
4559: LD_INT 17
4561: PUSH
4562: LD_INT 18
4564: PUSH
4565: LD_INT 19
4567: PUSH
4568: LD_INT 20
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 22
4576: PUSH
4577: LD_INT 23
4579: PUSH
4580: LD_INT 24
4582: PUSH
4583: LD_INT 25
4585: PUSH
4586: LD_INT 26
4588: PUSH
4589: LD_INT 28
4591: PUSH
4592: LD_INT 30
4594: PUSH
4595: LD_INT 31
4597: PUSH
4598: LD_INT 32
4600: PUSH
4601: LD_INT 36
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: LIST
4613: LIST
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: LIST
4633: LIST
4634: PUSH
4635: LD_INT 101
4637: PUSH
4638: LD_INT 102
4640: PUSH
4641: LD_INT 103
4643: PUSH
4644: LD_INT 104
4646: PUSH
4647: LD_INT 105
4649: PUSH
4650: LD_INT 106
4652: PUSH
4653: LD_INT 107
4655: PUSH
4656: LD_INT 108
4658: PUSH
4659: LD_INT 109
4661: PUSH
4662: LD_INT 110
4664: PUSH
4665: LD_INT 111
4667: PUSH
4668: LD_INT 112
4670: PUSH
4671: LD_INT 114
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: ST_TO_ADDR
4693: GO 6480
4695: LD_INT 11
4697: DOUBLE
4698: EQUAL
4699: IFTRUE 4703
4701: GO 4895
4703: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
4704: LD_ADDR_VAR 0 1
4708: PUSH
4709: LD_INT 2
4711: PUSH
4712: LD_INT 3
4714: PUSH
4715: LD_INT 4
4717: PUSH
4718: LD_INT 5
4720: PUSH
4721: LD_INT 6
4723: PUSH
4724: LD_INT 7
4726: PUSH
4727: LD_INT 8
4729: PUSH
4730: LD_INT 9
4732: PUSH
4733: LD_INT 10
4735: PUSH
4736: LD_INT 11
4738: PUSH
4739: LD_INT 12
4741: PUSH
4742: LD_INT 13
4744: PUSH
4745: LD_INT 14
4747: PUSH
4748: LD_INT 15
4750: PUSH
4751: LD_INT 16
4753: PUSH
4754: LD_INT 17
4756: PUSH
4757: LD_INT 18
4759: PUSH
4760: LD_INT 19
4762: PUSH
4763: LD_INT 20
4765: PUSH
4766: LD_INT 21
4768: PUSH
4769: LD_INT 22
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 24
4777: PUSH
4778: LD_INT 25
4780: PUSH
4781: LD_INT 26
4783: PUSH
4784: LD_INT 28
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 31
4792: PUSH
4793: LD_INT 32
4795: PUSH
4796: LD_INT 34
4798: PUSH
4799: LD_INT 36
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 101
4837: PUSH
4838: LD_INT 102
4840: PUSH
4841: LD_INT 103
4843: PUSH
4844: LD_INT 104
4846: PUSH
4847: LD_INT 105
4849: PUSH
4850: LD_INT 106
4852: PUSH
4853: LD_INT 107
4855: PUSH
4856: LD_INT 108
4858: PUSH
4859: LD_INT 109
4861: PUSH
4862: LD_INT 110
4864: PUSH
4865: LD_INT 111
4867: PUSH
4868: LD_INT 112
4870: PUSH
4871: LD_INT 114
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: ST_TO_ADDR
4893: GO 6480
4895: LD_INT 12
4897: DOUBLE
4898: EQUAL
4899: IFTRUE 4903
4901: GO 5111
4903: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
4904: LD_ADDR_VAR 0 1
4908: PUSH
4909: LD_INT 1
4911: PUSH
4912: LD_INT 2
4914: PUSH
4915: LD_INT 3
4917: PUSH
4918: LD_INT 4
4920: PUSH
4921: LD_INT 5
4923: PUSH
4924: LD_INT 6
4926: PUSH
4927: LD_INT 7
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: LD_INT 9
4935: PUSH
4936: LD_INT 10
4938: PUSH
4939: LD_INT 11
4941: PUSH
4942: LD_INT 12
4944: PUSH
4945: LD_INT 13
4947: PUSH
4948: LD_INT 14
4950: PUSH
4951: LD_INT 15
4953: PUSH
4954: LD_INT 16
4956: PUSH
4957: LD_INT 17
4959: PUSH
4960: LD_INT 18
4962: PUSH
4963: LD_INT 19
4965: PUSH
4966: LD_INT 20
4968: PUSH
4969: LD_INT 21
4971: PUSH
4972: LD_INT 22
4974: PUSH
4975: LD_INT 23
4977: PUSH
4978: LD_INT 24
4980: PUSH
4981: LD_INT 25
4983: PUSH
4984: LD_INT 26
4986: PUSH
4987: LD_INT 27
4989: PUSH
4990: LD_INT 28
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 31
4998: PUSH
4999: LD_INT 32
5001: PUSH
5002: LD_INT 33
5004: PUSH
5005: LD_INT 34
5007: PUSH
5008: LD_INT 36
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: LIST
5026: LIST
5027: LIST
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: LIST
5044: LIST
5045: LIST
5046: PUSH
5047: LD_INT 101
5049: PUSH
5050: LD_INT 102
5052: PUSH
5053: LD_INT 103
5055: PUSH
5056: LD_INT 104
5058: PUSH
5059: LD_INT 105
5061: PUSH
5062: LD_INT 106
5064: PUSH
5065: LD_INT 107
5067: PUSH
5068: LD_INT 108
5070: PUSH
5071: LD_INT 109
5073: PUSH
5074: LD_INT 110
5076: PUSH
5077: LD_INT 111
5079: PUSH
5080: LD_INT 112
5082: PUSH
5083: LD_INT 113
5085: PUSH
5086: LD_INT 114
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: ST_TO_ADDR
5109: GO 6480
5111: LD_INT 13
5113: DOUBLE
5114: EQUAL
5115: IFTRUE 5119
5117: GO 5315
5119: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
5120: LD_ADDR_VAR 0 1
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: LD_INT 2
5130: PUSH
5131: LD_INT 3
5133: PUSH
5134: LD_INT 4
5136: PUSH
5137: LD_INT 5
5139: PUSH
5140: LD_INT 8
5142: PUSH
5143: LD_INT 9
5145: PUSH
5146: LD_INT 10
5148: PUSH
5149: LD_INT 11
5151: PUSH
5152: LD_INT 12
5154: PUSH
5155: LD_INT 14
5157: PUSH
5158: LD_INT 15
5160: PUSH
5161: LD_INT 16
5163: PUSH
5164: LD_INT 17
5166: PUSH
5167: LD_INT 18
5169: PUSH
5170: LD_INT 19
5172: PUSH
5173: LD_INT 20
5175: PUSH
5176: LD_INT 21
5178: PUSH
5179: LD_INT 22
5181: PUSH
5182: LD_INT 23
5184: PUSH
5185: LD_INT 24
5187: PUSH
5188: LD_INT 25
5190: PUSH
5191: LD_INT 26
5193: PUSH
5194: LD_INT 27
5196: PUSH
5197: LD_INT 28
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 31
5205: PUSH
5206: LD_INT 32
5208: PUSH
5209: LD_INT 33
5211: PUSH
5212: LD_INT 34
5214: PUSH
5215: LD_INT 36
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 101
5253: PUSH
5254: LD_INT 102
5256: PUSH
5257: LD_INT 103
5259: PUSH
5260: LD_INT 104
5262: PUSH
5263: LD_INT 105
5265: PUSH
5266: LD_INT 106
5268: PUSH
5269: LD_INT 107
5271: PUSH
5272: LD_INT 108
5274: PUSH
5275: LD_INT 109
5277: PUSH
5278: LD_INT 110
5280: PUSH
5281: LD_INT 111
5283: PUSH
5284: LD_INT 112
5286: PUSH
5287: LD_INT 113
5289: PUSH
5290: LD_INT 114
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: ST_TO_ADDR
5313: GO 6480
5315: LD_INT 14
5317: DOUBLE
5318: EQUAL
5319: IFTRUE 5323
5321: GO 5535
5323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
5324: LD_ADDR_VAR 0 1
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: LD_INT 2
5334: PUSH
5335: LD_INT 3
5337: PUSH
5338: LD_INT 4
5340: PUSH
5341: LD_INT 5
5343: PUSH
5344: LD_INT 6
5346: PUSH
5347: LD_INT 7
5349: PUSH
5350: LD_INT 8
5352: PUSH
5353: LD_INT 9
5355: PUSH
5356: LD_INT 10
5358: PUSH
5359: LD_INT 11
5361: PUSH
5362: LD_INT 12
5364: PUSH
5365: LD_INT 13
5367: PUSH
5368: LD_INT 14
5370: PUSH
5371: LD_INT 15
5373: PUSH
5374: LD_INT 16
5376: PUSH
5377: LD_INT 17
5379: PUSH
5380: LD_INT 18
5382: PUSH
5383: LD_INT 19
5385: PUSH
5386: LD_INT 20
5388: PUSH
5389: LD_INT 21
5391: PUSH
5392: LD_INT 22
5394: PUSH
5395: LD_INT 23
5397: PUSH
5398: LD_INT 24
5400: PUSH
5401: LD_INT 25
5403: PUSH
5404: LD_INT 26
5406: PUSH
5407: LD_INT 27
5409: PUSH
5410: LD_INT 28
5412: PUSH
5413: LD_INT 29
5415: PUSH
5416: LD_INT 30
5418: PUSH
5419: LD_INT 31
5421: PUSH
5422: LD_INT 32
5424: PUSH
5425: LD_INT 33
5427: PUSH
5428: LD_INT 34
5430: PUSH
5431: LD_INT 36
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: LIST
5455: LIST
5456: LIST
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: LIST
5462: LIST
5463: LIST
5464: LIST
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PUSH
5471: LD_INT 101
5473: PUSH
5474: LD_INT 102
5476: PUSH
5477: LD_INT 103
5479: PUSH
5480: LD_INT 104
5482: PUSH
5483: LD_INT 105
5485: PUSH
5486: LD_INT 106
5488: PUSH
5489: LD_INT 107
5491: PUSH
5492: LD_INT 108
5494: PUSH
5495: LD_INT 109
5497: PUSH
5498: LD_INT 110
5500: PUSH
5501: LD_INT 111
5503: PUSH
5504: LD_INT 112
5506: PUSH
5507: LD_INT 113
5509: PUSH
5510: LD_INT 114
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: ST_TO_ADDR
5533: GO 6480
5535: LD_INT 15
5537: DOUBLE
5538: EQUAL
5539: IFTRUE 5543
5541: GO 5755
5543: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
5544: LD_ADDR_VAR 0 1
5548: PUSH
5549: LD_INT 1
5551: PUSH
5552: LD_INT 2
5554: PUSH
5555: LD_INT 3
5557: PUSH
5558: LD_INT 4
5560: PUSH
5561: LD_INT 5
5563: PUSH
5564: LD_INT 6
5566: PUSH
5567: LD_INT 7
5569: PUSH
5570: LD_INT 8
5572: PUSH
5573: LD_INT 9
5575: PUSH
5576: LD_INT 10
5578: PUSH
5579: LD_INT 11
5581: PUSH
5582: LD_INT 12
5584: PUSH
5585: LD_INT 13
5587: PUSH
5588: LD_INT 14
5590: PUSH
5591: LD_INT 15
5593: PUSH
5594: LD_INT 16
5596: PUSH
5597: LD_INT 17
5599: PUSH
5600: LD_INT 18
5602: PUSH
5603: LD_INT 19
5605: PUSH
5606: LD_INT 20
5608: PUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 22
5614: PUSH
5615: LD_INT 23
5617: PUSH
5618: LD_INT 24
5620: PUSH
5621: LD_INT 25
5623: PUSH
5624: LD_INT 26
5626: PUSH
5627: LD_INT 27
5629: PUSH
5630: LD_INT 28
5632: PUSH
5633: LD_INT 29
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 31
5641: PUSH
5642: LD_INT 32
5644: PUSH
5645: LD_INT 33
5647: PUSH
5648: LD_INT 34
5650: PUSH
5651: LD_INT 36
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 101
5693: PUSH
5694: LD_INT 102
5696: PUSH
5697: LD_INT 103
5699: PUSH
5700: LD_INT 104
5702: PUSH
5703: LD_INT 105
5705: PUSH
5706: LD_INT 106
5708: PUSH
5709: LD_INT 107
5711: PUSH
5712: LD_INT 108
5714: PUSH
5715: LD_INT 109
5717: PUSH
5718: LD_INT 110
5720: PUSH
5721: LD_INT 111
5723: PUSH
5724: LD_INT 112
5726: PUSH
5727: LD_INT 113
5729: PUSH
5730: LD_INT 114
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: ST_TO_ADDR
5753: GO 6480
5755: LD_INT 16
5757: DOUBLE
5758: EQUAL
5759: IFTRUE 5763
5761: GO 5887
5763: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
5764: LD_ADDR_VAR 0 1
5768: PUSH
5769: LD_INT 2
5771: PUSH
5772: LD_INT 4
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 7
5780: PUSH
5781: LD_INT 11
5783: PUSH
5784: LD_INT 12
5786: PUSH
5787: LD_INT 15
5789: PUSH
5790: LD_INT 16
5792: PUSH
5793: LD_INT 20
5795: PUSH
5796: LD_INT 21
5798: PUSH
5799: LD_INT 22
5801: PUSH
5802: LD_INT 23
5804: PUSH
5805: LD_INT 25
5807: PUSH
5808: LD_INT 26
5810: PUSH
5811: LD_INT 30
5813: PUSH
5814: LD_INT 31
5816: PUSH
5817: LD_INT 32
5819: PUSH
5820: LD_INT 33
5822: PUSH
5823: LD_INT 34
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: LIST
5836: LIST
5837: LIST
5838: LIST
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: LD_INT 101
5849: PUSH
5850: LD_INT 102
5852: PUSH
5853: LD_INT 103
5855: PUSH
5856: LD_INT 106
5858: PUSH
5859: LD_INT 108
5861: PUSH
5862: LD_INT 112
5864: PUSH
5865: LD_INT 113
5867: PUSH
5868: LD_INT 114
5870: PUSH
5871: EMPTY
5872: LIST
5873: LIST
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: ST_TO_ADDR
5885: GO 6480
5887: LD_INT 17
5889: DOUBLE
5890: EQUAL
5891: IFTRUE 5895
5893: GO 6107
5895: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
5896: LD_ADDR_VAR 0 1
5900: PUSH
5901: LD_INT 1
5903: PUSH
5904: LD_INT 2
5906: PUSH
5907: LD_INT 3
5909: PUSH
5910: LD_INT 4
5912: PUSH
5913: LD_INT 5
5915: PUSH
5916: LD_INT 6
5918: PUSH
5919: LD_INT 7
5921: PUSH
5922: LD_INT 8
5924: PUSH
5925: LD_INT 9
5927: PUSH
5928: LD_INT 10
5930: PUSH
5931: LD_INT 11
5933: PUSH
5934: LD_INT 12
5936: PUSH
5937: LD_INT 13
5939: PUSH
5940: LD_INT 14
5942: PUSH
5943: LD_INT 15
5945: PUSH
5946: LD_INT 16
5948: PUSH
5949: LD_INT 17
5951: PUSH
5952: LD_INT 18
5954: PUSH
5955: LD_INT 19
5957: PUSH
5958: LD_INT 20
5960: PUSH
5961: LD_INT 21
5963: PUSH
5964: LD_INT 22
5966: PUSH
5967: LD_INT 23
5969: PUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 25
5975: PUSH
5976: LD_INT 26
5978: PUSH
5979: LD_INT 27
5981: PUSH
5982: LD_INT 28
5984: PUSH
5985: LD_INT 29
5987: PUSH
5988: LD_INT 30
5990: PUSH
5991: LD_INT 31
5993: PUSH
5994: LD_INT 32
5996: PUSH
5997: LD_INT 33
5999: PUSH
6000: LD_INT 34
6002: PUSH
6003: LD_INT 36
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: LIST
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 101
6045: PUSH
6046: LD_INT 102
6048: PUSH
6049: LD_INT 103
6051: PUSH
6052: LD_INT 104
6054: PUSH
6055: LD_INT 105
6057: PUSH
6058: LD_INT 106
6060: PUSH
6061: LD_INT 107
6063: PUSH
6064: LD_INT 108
6066: PUSH
6067: LD_INT 109
6069: PUSH
6070: LD_INT 110
6072: PUSH
6073: LD_INT 111
6075: PUSH
6076: LD_INT 112
6078: PUSH
6079: LD_INT 113
6081: PUSH
6082: LD_INT 114
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: ST_TO_ADDR
6105: GO 6480
6107: LD_INT 18
6109: DOUBLE
6110: EQUAL
6111: IFTRUE 6115
6113: GO 6251
6115: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
6116: LD_ADDR_VAR 0 1
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: LD_INT 4
6126: PUSH
6127: LD_INT 5
6129: PUSH
6130: LD_INT 7
6132: PUSH
6133: LD_INT 11
6135: PUSH
6136: LD_INT 12
6138: PUSH
6139: LD_INT 15
6141: PUSH
6142: LD_INT 16
6144: PUSH
6145: LD_INT 20
6147: PUSH
6148: LD_INT 21
6150: PUSH
6151: LD_INT 22
6153: PUSH
6154: LD_INT 23
6156: PUSH
6157: LD_INT 25
6159: PUSH
6160: LD_INT 26
6162: PUSH
6163: LD_INT 30
6165: PUSH
6166: LD_INT 31
6168: PUSH
6169: LD_INT 32
6171: PUSH
6172: LD_INT 33
6174: PUSH
6175: LD_INT 34
6177: PUSH
6178: LD_INT 35
6180: PUSH
6181: LD_INT 36
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: PUSH
6207: LD_INT 101
6209: PUSH
6210: LD_INT 102
6212: PUSH
6213: LD_INT 103
6215: PUSH
6216: LD_INT 106
6218: PUSH
6219: LD_INT 108
6221: PUSH
6222: LD_INT 112
6224: PUSH
6225: LD_INT 113
6227: PUSH
6228: LD_INT 114
6230: PUSH
6231: LD_INT 115
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: ST_TO_ADDR
6249: GO 6480
6251: LD_INT 19
6253: DOUBLE
6254: EQUAL
6255: IFTRUE 6259
6257: GO 6479
6259: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
6260: LD_ADDR_VAR 0 1
6264: PUSH
6265: LD_INT 1
6267: PUSH
6268: LD_INT 2
6270: PUSH
6271: LD_INT 3
6273: PUSH
6274: LD_INT 4
6276: PUSH
6277: LD_INT 5
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: LD_INT 7
6285: PUSH
6286: LD_INT 8
6288: PUSH
6289: LD_INT 9
6291: PUSH
6292: LD_INT 10
6294: PUSH
6295: LD_INT 11
6297: PUSH
6298: LD_INT 12
6300: PUSH
6301: LD_INT 13
6303: PUSH
6304: LD_INT 14
6306: PUSH
6307: LD_INT 15
6309: PUSH
6310: LD_INT 16
6312: PUSH
6313: LD_INT 17
6315: PUSH
6316: LD_INT 18
6318: PUSH
6319: LD_INT 19
6321: PUSH
6322: LD_INT 20
6324: PUSH
6325: LD_INT 21
6327: PUSH
6328: LD_INT 22
6330: PUSH
6331: LD_INT 23
6333: PUSH
6334: LD_INT 24
6336: PUSH
6337: LD_INT 25
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 27
6345: PUSH
6346: LD_INT 28
6348: PUSH
6349: LD_INT 29
6351: PUSH
6352: LD_INT 30
6354: PUSH
6355: LD_INT 31
6357: PUSH
6358: LD_INT 32
6360: PUSH
6361: LD_INT 33
6363: PUSH
6364: LD_INT 34
6366: PUSH
6367: LD_INT 35
6369: PUSH
6370: LD_INT 36
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: LD_INT 101
6413: PUSH
6414: LD_INT 102
6416: PUSH
6417: LD_INT 103
6419: PUSH
6420: LD_INT 104
6422: PUSH
6423: LD_INT 105
6425: PUSH
6426: LD_INT 106
6428: PUSH
6429: LD_INT 107
6431: PUSH
6432: LD_INT 108
6434: PUSH
6435: LD_INT 109
6437: PUSH
6438: LD_INT 110
6440: PUSH
6441: LD_INT 111
6443: PUSH
6444: LD_INT 112
6446: PUSH
6447: LD_INT 113
6449: PUSH
6450: LD_INT 114
6452: PUSH
6453: LD_INT 115
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: ST_TO_ADDR
6477: GO 6480
6479: POP
// end else
6480: GO 6699
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
6482: LD_ADDR_VAR 0 1
6486: PUSH
6487: LD_INT 1
6489: PUSH
6490: LD_INT 2
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 4
6498: PUSH
6499: LD_INT 5
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: LD_INT 7
6507: PUSH
6508: LD_INT 8
6510: PUSH
6511: LD_INT 9
6513: PUSH
6514: LD_INT 10
6516: PUSH
6517: LD_INT 11
6519: PUSH
6520: LD_INT 12
6522: PUSH
6523: LD_INT 13
6525: PUSH
6526: LD_INT 14
6528: PUSH
6529: LD_INT 15
6531: PUSH
6532: LD_INT 16
6534: PUSH
6535: LD_INT 17
6537: PUSH
6538: LD_INT 18
6540: PUSH
6541: LD_INT 19
6543: PUSH
6544: LD_INT 20
6546: PUSH
6547: LD_INT 21
6549: PUSH
6550: LD_INT 22
6552: PUSH
6553: LD_INT 23
6555: PUSH
6556: LD_INT 24
6558: PUSH
6559: LD_INT 25
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 27
6567: PUSH
6568: LD_INT 28
6570: PUSH
6571: LD_INT 29
6573: PUSH
6574: LD_INT 30
6576: PUSH
6577: LD_INT 31
6579: PUSH
6580: LD_INT 32
6582: PUSH
6583: LD_INT 33
6585: PUSH
6586: LD_INT 34
6588: PUSH
6589: LD_INT 35
6591: PUSH
6592: LD_INT 36
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 101
6635: PUSH
6636: LD_INT 102
6638: PUSH
6639: LD_INT 103
6641: PUSH
6642: LD_INT 104
6644: PUSH
6645: LD_INT 105
6647: PUSH
6648: LD_INT 106
6650: PUSH
6651: LD_INT 107
6653: PUSH
6654: LD_INT 108
6656: PUSH
6657: LD_INT 109
6659: PUSH
6660: LD_INT 110
6662: PUSH
6663: LD_INT 111
6665: PUSH
6666: LD_INT 112
6668: PUSH
6669: LD_INT 113
6671: PUSH
6672: LD_INT 114
6674: PUSH
6675: LD_INT 115
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: ST_TO_ADDR
// if result then
6699: LD_VAR 0 1
6703: IFFALSE 6992
// begin normal :=  ;
6705: LD_ADDR_VAR 0 3
6709: PUSH
6710: LD_STRING 
6712: ST_TO_ADDR
// hardcore :=  ;
6713: LD_ADDR_VAR 0 4
6717: PUSH
6718: LD_STRING 
6720: ST_TO_ADDR
// for i = 1 to normalCounter do
6721: LD_ADDR_VAR 0 5
6725: PUSH
6726: DOUBLE
6727: LD_INT 1
6729: DEC
6730: ST_TO_ADDR
6731: LD_EXP 9
6735: PUSH
6736: FOR_TO
6737: IFFALSE 6838
// begin tmp := 0 ;
6739: LD_ADDR_VAR 0 2
6743: PUSH
6744: LD_STRING 0
6746: ST_TO_ADDR
// if result [ 1 ] then
6747: LD_VAR 0 1
6751: PUSH
6752: LD_INT 1
6754: ARRAY
6755: IFFALSE 6820
// if result [ 1 ] [ 1 ] = i then
6757: LD_VAR 0 1
6761: PUSH
6762: LD_INT 1
6764: ARRAY
6765: PUSH
6766: LD_INT 1
6768: ARRAY
6769: PUSH
6770: LD_VAR 0 5
6774: EQUAL
6775: IFFALSE 6820
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
6777: LD_ADDR_VAR 0 1
6781: PUSH
6782: LD_VAR 0 1
6786: PPUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_VAR 0 1
6794: PUSH
6795: LD_INT 1
6797: ARRAY
6798: PPUSH
6799: LD_INT 1
6801: PPUSH
6802: CALL_OW 3
6806: PPUSH
6807: CALL_OW 1
6811: ST_TO_ADDR
// tmp := 1 ;
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_STRING 1
6819: ST_TO_ADDR
// end ; normal := normal & tmp ;
6820: LD_ADDR_VAR 0 3
6824: PUSH
6825: LD_VAR 0 3
6829: PUSH
6830: LD_VAR 0 2
6834: STR
6835: ST_TO_ADDR
// end ;
6836: GO 6736
6838: POP
6839: POP
// for i = 1 to hardcoreCounter do
6840: LD_ADDR_VAR 0 5
6844: PUSH
6845: DOUBLE
6846: LD_INT 1
6848: DEC
6849: ST_TO_ADDR
6850: LD_EXP 10
6854: PUSH
6855: FOR_TO
6856: IFFALSE 6961
// begin tmp := 0 ;
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_STRING 0
6865: ST_TO_ADDR
// if result [ 2 ] then
6866: LD_VAR 0 1
6870: PUSH
6871: LD_INT 2
6873: ARRAY
6874: IFFALSE 6943
// if result [ 2 ] [ 1 ] = 100 + i then
6876: LD_VAR 0 1
6880: PUSH
6881: LD_INT 2
6883: ARRAY
6884: PUSH
6885: LD_INT 1
6887: ARRAY
6888: PUSH
6889: LD_INT 100
6891: PUSH
6892: LD_VAR 0 5
6896: PLUS
6897: EQUAL
6898: IFFALSE 6943
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
6900: LD_ADDR_VAR 0 1
6904: PUSH
6905: LD_VAR 0 1
6909: PPUSH
6910: LD_INT 2
6912: PPUSH
6913: LD_VAR 0 1
6917: PUSH
6918: LD_INT 2
6920: ARRAY
6921: PPUSH
6922: LD_INT 1
6924: PPUSH
6925: CALL_OW 3
6929: PPUSH
6930: CALL_OW 1
6934: ST_TO_ADDR
// tmp := 1 ;
6935: LD_ADDR_VAR 0 2
6939: PUSH
6940: LD_STRING 1
6942: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
6943: LD_ADDR_VAR 0 4
6947: PUSH
6948: LD_VAR 0 4
6952: PUSH
6953: LD_VAR 0 2
6957: STR
6958: ST_TO_ADDR
// end ;
6959: GO 6855
6961: POP
6962: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
6963: LD_STRING getStreamItemsFromMission("
6965: PUSH
6966: LD_VAR 0 3
6970: STR
6971: PUSH
6972: LD_STRING ","
6974: STR
6975: PUSH
6976: LD_VAR 0 4
6980: STR
6981: PUSH
6982: LD_STRING ")
6984: STR
6985: PPUSH
6986: CALL_OW 559
// end else
6990: GO 6999
// ToLua ( getStreamItemsFromMission("","") ) ;
6992: LD_STRING getStreamItemsFromMission("","")
6994: PPUSH
6995: CALL_OW 559
// end ;
6999: LD_VAR 0 1
7003: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7004: LD_EXP 8
7008: PUSH
7009: LD_EXP 13
7013: AND
7014: IFFALSE 7138
7016: GO 7018
7018: DISABLE
7019: LD_INT 0
7021: PPUSH
7022: PPUSH
// begin enable ;
7023: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7024: LD_ADDR_VAR 0 2
7028: PUSH
7029: LD_INT 22
7031: PUSH
7032: LD_OWVAR 2
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: LD_INT 34
7046: PUSH
7047: LD_INT 7
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: LD_INT 34
7056: PUSH
7057: LD_INT 45
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 34
7066: PUSH
7067: LD_INT 28
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PUSH
7074: LD_INT 34
7076: PUSH
7077: LD_INT 47
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: LIST
7088: LIST
7089: LIST
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PPUSH
7095: CALL_OW 69
7099: ST_TO_ADDR
// if not tmp then
7100: LD_VAR 0 2
7104: NOT
7105: IFFALSE 7109
// exit ;
7107: GO 7138
// for i in tmp do
7109: LD_ADDR_VAR 0 1
7113: PUSH
7114: LD_VAR 0 2
7118: PUSH
7119: FOR_IN
7120: IFFALSE 7136
// begin SetLives ( i , 0 ) ;
7122: LD_VAR 0 1
7126: PPUSH
7127: LD_INT 0
7129: PPUSH
7130: CALL_OW 234
// end ;
7134: GO 7119
7136: POP
7137: POP
// end ;
7138: PPOPN 2
7140: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7141: LD_EXP 8
7145: PUSH
7146: LD_EXP 14
7150: AND
7151: IFFALSE 7235
7153: GO 7155
7155: DISABLE
7156: LD_INT 0
7158: PPUSH
7159: PPUSH
// begin enable ;
7160: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7161: LD_ADDR_VAR 0 2
7165: PUSH
7166: LD_INT 22
7168: PUSH
7169: LD_OWVAR 2
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: LD_INT 32
7180: PUSH
7181: LD_INT 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: PPUSH
7192: CALL_OW 69
7196: ST_TO_ADDR
// if not tmp then
7197: LD_VAR 0 2
7201: NOT
7202: IFFALSE 7206
// exit ;
7204: GO 7235
// for i in tmp do
7206: LD_ADDR_VAR 0 1
7210: PUSH
7211: LD_VAR 0 2
7215: PUSH
7216: FOR_IN
7217: IFFALSE 7233
// begin SetLives ( i , 0 ) ;
7219: LD_VAR 0 1
7223: PPUSH
7224: LD_INT 0
7226: PPUSH
7227: CALL_OW 234
// end ;
7231: GO 7216
7233: POP
7234: POP
// end ;
7235: PPOPN 2
7237: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7238: LD_EXP 8
7242: PUSH
7243: LD_EXP 11
7247: AND
7248: IFFALSE 7341
7250: GO 7252
7252: DISABLE
7253: LD_INT 0
7255: PPUSH
// begin enable ;
7256: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7257: LD_ADDR_VAR 0 1
7261: PUSH
7262: LD_INT 22
7264: PUSH
7265: LD_OWVAR 2
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: LD_INT 2
7276: PUSH
7277: LD_INT 25
7279: PUSH
7280: LD_INT 5
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: PUSH
7287: LD_INT 25
7289: PUSH
7290: LD_INT 9
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 25
7299: PUSH
7300: LD_INT 8
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: CALL_OW 69
7321: PUSH
7322: FOR_IN
7323: IFFALSE 7339
// begin SetClass ( i , 1 ) ;
7325: LD_VAR 0 1
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: CALL_OW 336
// end ;
7337: GO 7322
7339: POP
7340: POP
// end ;
7341: PPOPN 1
7343: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7344: LD_EXP 8
7348: PUSH
7349: LD_EXP 12
7353: AND
7354: PUSH
7355: LD_OWVAR 65
7359: PUSH
7360: LD_INT 7
7362: LESS
7363: AND
7364: IFFALSE 7378
7366: GO 7368
7368: DISABLE
// begin enable ;
7369: ENABLE
// game_speed := 7 ;
7370: LD_ADDR_OWVAR 65
7374: PUSH
7375: LD_INT 7
7377: ST_TO_ADDR
// end ;
7378: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7379: LD_EXP 8
7383: PUSH
7384: LD_EXP 15
7388: AND
7389: IFFALSE 7591
7391: GO 7393
7393: DISABLE
7394: LD_INT 0
7396: PPUSH
7397: PPUSH
7398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7399: LD_ADDR_VAR 0 3
7403: PUSH
7404: LD_INT 81
7406: PUSH
7407: LD_OWVAR 2
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 21
7418: PUSH
7419: LD_INT 1
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 69
7434: ST_TO_ADDR
// if not tmp then
7435: LD_VAR 0 3
7439: NOT
7440: IFFALSE 7444
// exit ;
7442: GO 7591
// if tmp > 5 then
7444: LD_VAR 0 3
7448: PUSH
7449: LD_INT 5
7451: GREATER
7452: IFFALSE 7464
// k := 5 else
7454: LD_ADDR_VAR 0 2
7458: PUSH
7459: LD_INT 5
7461: ST_TO_ADDR
7462: GO 7474
// k := tmp ;
7464: LD_ADDR_VAR 0 2
7468: PUSH
7469: LD_VAR 0 3
7473: ST_TO_ADDR
// for i := 1 to k do
7474: LD_ADDR_VAR 0 1
7478: PUSH
7479: DOUBLE
7480: LD_INT 1
7482: DEC
7483: ST_TO_ADDR
7484: LD_VAR 0 2
7488: PUSH
7489: FOR_TO
7490: IFFALSE 7589
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7492: LD_VAR 0 3
7496: PUSH
7497: LD_VAR 0 1
7501: ARRAY
7502: PPUSH
7503: LD_VAR 0 1
7507: PUSH
7508: LD_INT 4
7510: MOD
7511: PUSH
7512: LD_INT 1
7514: PLUS
7515: PPUSH
7516: CALL_OW 259
7520: PUSH
7521: LD_INT 10
7523: LESS
7524: IFFALSE 7587
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7526: LD_VAR 0 3
7530: PUSH
7531: LD_VAR 0 1
7535: ARRAY
7536: PPUSH
7537: LD_VAR 0 1
7541: PUSH
7542: LD_INT 4
7544: MOD
7545: PUSH
7546: LD_INT 1
7548: PLUS
7549: PPUSH
7550: LD_VAR 0 3
7554: PUSH
7555: LD_VAR 0 1
7559: ARRAY
7560: PPUSH
7561: LD_VAR 0 1
7565: PUSH
7566: LD_INT 4
7568: MOD
7569: PUSH
7570: LD_INT 1
7572: PLUS
7573: PPUSH
7574: CALL_OW 259
7578: PUSH
7579: LD_INT 1
7581: PLUS
7582: PPUSH
7583: CALL_OW 237
7587: GO 7489
7589: POP
7590: POP
// end ;
7591: PPOPN 3
7593: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7594: LD_EXP 8
7598: PUSH
7599: LD_EXP 16
7603: AND
7604: IFFALSE 7624
7606: GO 7608
7608: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7609: LD_INT 4
7611: PPUSH
7612: LD_OWVAR 2
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: CALL_OW 324
7624: END
// every 0 0$1 trigger StreamModeActive and sShovel do
7625: LD_EXP 8
7629: PUSH
7630: LD_EXP 45
7634: AND
7635: IFFALSE 7655
7637: GO 7639
7639: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
7640: LD_INT 19
7642: PPUSH
7643: LD_OWVAR 2
7647: PPUSH
7648: LD_INT 0
7650: PPUSH
7651: CALL_OW 324
7655: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7656: LD_EXP 8
7660: PUSH
7661: LD_EXP 17
7665: AND
7666: IFFALSE 7768
7668: GO 7670
7670: DISABLE
7671: LD_INT 0
7673: PPUSH
7674: PPUSH
// begin enable ;
7675: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7676: LD_ADDR_VAR 0 2
7680: PUSH
7681: LD_INT 22
7683: PUSH
7684: LD_OWVAR 2
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: LD_INT 2
7695: PUSH
7696: LD_INT 34
7698: PUSH
7699: LD_INT 11
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 34
7708: PUSH
7709: LD_INT 30
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PPUSH
7725: CALL_OW 69
7729: ST_TO_ADDR
// if not tmp then
7730: LD_VAR 0 2
7734: NOT
7735: IFFALSE 7739
// exit ;
7737: GO 7768
// for i in tmp do
7739: LD_ADDR_VAR 0 1
7743: PUSH
7744: LD_VAR 0 2
7748: PUSH
7749: FOR_IN
7750: IFFALSE 7766
// begin SetLives ( i , 0 ) ;
7752: LD_VAR 0 1
7756: PPUSH
7757: LD_INT 0
7759: PPUSH
7760: CALL_OW 234
// end ;
7764: GO 7749
7766: POP
7767: POP
// end ;
7768: PPOPN 2
7770: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7771: LD_EXP 8
7775: PUSH
7776: LD_EXP 18
7780: AND
7781: IFFALSE 7801
7783: GO 7785
7785: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7786: LD_INT 32
7788: PPUSH
7789: LD_OWVAR 2
7793: PPUSH
7794: LD_INT 0
7796: PPUSH
7797: CALL_OW 324
7801: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
7802: LD_EXP 8
7806: PUSH
7807: LD_EXP 19
7811: AND
7812: IFFALSE 7993
7814: GO 7816
7816: DISABLE
7817: LD_INT 0
7819: PPUSH
7820: PPUSH
7821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
7822: LD_ADDR_VAR 0 2
7826: PUSH
7827: LD_INT 22
7829: PUSH
7830: LD_OWVAR 2
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: LD_INT 33
7841: PUSH
7842: LD_INT 3
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: PUSH
7849: EMPTY
7850: LIST
7851: LIST
7852: PPUSH
7853: CALL_OW 69
7857: ST_TO_ADDR
// if not tmp then
7858: LD_VAR 0 2
7862: NOT
7863: IFFALSE 7867
// exit ;
7865: GO 7993
// side := 0 ;
7867: LD_ADDR_VAR 0 3
7871: PUSH
7872: LD_INT 0
7874: ST_TO_ADDR
// for i := 1 to 8 do
7875: LD_ADDR_VAR 0 1
7879: PUSH
7880: DOUBLE
7881: LD_INT 1
7883: DEC
7884: ST_TO_ADDR
7885: LD_INT 8
7887: PUSH
7888: FOR_TO
7889: IFFALSE 7937
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7891: LD_OWVAR 2
7895: PUSH
7896: LD_VAR 0 1
7900: NONEQUAL
7901: PUSH
7902: LD_OWVAR 2
7906: PPUSH
7907: LD_VAR 0 1
7911: PPUSH
7912: CALL_OW 81
7916: PUSH
7917: LD_INT 2
7919: EQUAL
7920: AND
7921: IFFALSE 7935
// begin side := i ;
7923: LD_ADDR_VAR 0 3
7927: PUSH
7928: LD_VAR 0 1
7932: ST_TO_ADDR
// break ;
7933: GO 7937
// end ;
7935: GO 7888
7937: POP
7938: POP
// if not side then
7939: LD_VAR 0 3
7943: NOT
7944: IFFALSE 7948
// exit ;
7946: GO 7993
// for i := 1 to tmp do
7948: LD_ADDR_VAR 0 1
7952: PUSH
7953: DOUBLE
7954: LD_INT 1
7956: DEC
7957: ST_TO_ADDR
7958: LD_VAR 0 2
7962: PUSH
7963: FOR_TO
7964: IFFALSE 7991
// if Prob ( 60 ) then
7966: LD_INT 60
7968: PPUSH
7969: CALL_OW 13
7973: IFFALSE 7989
// SetSide ( i , side ) ;
7975: LD_VAR 0 1
7979: PPUSH
7980: LD_VAR 0 3
7984: PPUSH
7985: CALL_OW 235
7989: GO 7963
7991: POP
7992: POP
// end ;
7993: PPOPN 3
7995: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
7996: LD_EXP 8
8000: PUSH
8001: LD_EXP 21
8005: AND
8006: IFFALSE 8125
8008: GO 8010
8010: DISABLE
8011: LD_INT 0
8013: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8014: LD_ADDR_VAR 0 1
8018: PUSH
8019: LD_INT 22
8021: PUSH
8022: LD_OWVAR 2
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 21
8033: PUSH
8034: LD_INT 1
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 3
8043: PUSH
8044: LD_INT 23
8046: PUSH
8047: LD_INT 0
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: PUSH
8058: EMPTY
8059: LIST
8060: LIST
8061: LIST
8062: PPUSH
8063: CALL_OW 69
8067: PUSH
8068: FOR_IN
8069: IFFALSE 8123
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
8071: LD_VAR 0 1
8075: PPUSH
8076: CALL_OW 257
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 3
8089: PUSH
8090: LD_INT 4
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: IN
8099: IFFALSE 8121
// SetClass ( un , rand ( 1 , 4 ) ) ;
8101: LD_VAR 0 1
8105: PPUSH
8106: LD_INT 1
8108: PPUSH
8109: LD_INT 4
8111: PPUSH
8112: CALL_OW 12
8116: PPUSH
8117: CALL_OW 336
8121: GO 8068
8123: POP
8124: POP
// end ;
8125: PPOPN 1
8127: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8128: LD_EXP 8
8132: PUSH
8133: LD_EXP 20
8137: AND
8138: IFFALSE 8217
8140: GO 8142
8142: DISABLE
8143: LD_INT 0
8145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8146: LD_ADDR_VAR 0 1
8150: PUSH
8151: LD_INT 22
8153: PUSH
8154: LD_OWVAR 2
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 21
8165: PUSH
8166: LD_INT 3
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: PPUSH
8177: CALL_OW 69
8181: ST_TO_ADDR
// if not tmp then
8182: LD_VAR 0 1
8186: NOT
8187: IFFALSE 8191
// exit ;
8189: GO 8217
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
8191: LD_VAR 0 1
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: CALL_OW 12
8208: ARRAY
8209: PPUSH
8210: LD_INT 100
8212: PPUSH
8213: CALL_OW 234
// end ;
8217: PPOPN 1
8219: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
8220: LD_EXP 8
8224: PUSH
8225: LD_EXP 22
8229: AND
8230: IFFALSE 8328
8232: GO 8234
8234: DISABLE
8235: LD_INT 0
8237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8238: LD_ADDR_VAR 0 1
8242: PUSH
8243: LD_INT 22
8245: PUSH
8246: LD_OWVAR 2
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PUSH
8255: LD_INT 21
8257: PUSH
8258: LD_INT 1
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PPUSH
8269: CALL_OW 69
8273: ST_TO_ADDR
// if not tmp then
8274: LD_VAR 0 1
8278: NOT
8279: IFFALSE 8283
// exit ;
8281: GO 8328
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8283: LD_VAR 0 1
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: LD_VAR 0 1
8295: PPUSH
8296: CALL_OW 12
8300: ARRAY
8301: PPUSH
8302: LD_INT 1
8304: PPUSH
8305: LD_INT 4
8307: PPUSH
8308: CALL_OW 12
8312: PPUSH
8313: LD_INT 3000
8315: PPUSH
8316: LD_INT 9000
8318: PPUSH
8319: CALL_OW 12
8323: PPUSH
8324: CALL_OW 492
// end ;
8328: PPOPN 1
8330: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8331: LD_EXP 8
8335: PUSH
8336: LD_EXP 23
8340: AND
8341: IFFALSE 8361
8343: GO 8345
8345: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8346: LD_INT 1
8348: PPUSH
8349: LD_OWVAR 2
8353: PPUSH
8354: LD_INT 0
8356: PPUSH
8357: CALL_OW 324
8361: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8362: LD_EXP 8
8366: PUSH
8367: LD_EXP 24
8371: AND
8372: IFFALSE 8455
8374: GO 8376
8376: DISABLE
8377: LD_INT 0
8379: PPUSH
8380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8381: LD_ADDR_VAR 0 2
8385: PUSH
8386: LD_INT 22
8388: PUSH
8389: LD_OWVAR 2
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 21
8400: PUSH
8401: LD_INT 3
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: PPUSH
8412: CALL_OW 69
8416: ST_TO_ADDR
// if not tmp then
8417: LD_VAR 0 2
8421: NOT
8422: IFFALSE 8426
// exit ;
8424: GO 8455
// for i in tmp do
8426: LD_ADDR_VAR 0 1
8430: PUSH
8431: LD_VAR 0 2
8435: PUSH
8436: FOR_IN
8437: IFFALSE 8453
// SetBLevel ( i , 10 ) ;
8439: LD_VAR 0 1
8443: PPUSH
8444: LD_INT 10
8446: PPUSH
8447: CALL_OW 241
8451: GO 8436
8453: POP
8454: POP
// end ;
8455: PPOPN 2
8457: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8458: LD_EXP 8
8462: PUSH
8463: LD_EXP 25
8467: AND
8468: IFFALSE 8579
8470: GO 8472
8472: DISABLE
8473: LD_INT 0
8475: PPUSH
8476: PPUSH
8477: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8478: LD_ADDR_VAR 0 3
8482: PUSH
8483: LD_INT 22
8485: PUSH
8486: LD_OWVAR 2
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 25
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 69
8513: ST_TO_ADDR
// if not tmp then
8514: LD_VAR 0 3
8518: NOT
8519: IFFALSE 8523
// exit ;
8521: GO 8579
// un := tmp [ rand ( 1 , tmp ) ] ;
8523: LD_ADDR_VAR 0 2
8527: PUSH
8528: LD_VAR 0 3
8532: PUSH
8533: LD_INT 1
8535: PPUSH
8536: LD_VAR 0 3
8540: PPUSH
8541: CALL_OW 12
8545: ARRAY
8546: ST_TO_ADDR
// if Crawls ( un ) then
8547: LD_VAR 0 2
8551: PPUSH
8552: CALL_OW 318
8556: IFFALSE 8567
// ComWalk ( un ) ;
8558: LD_VAR 0 2
8562: PPUSH
8563: CALL_OW 138
// SetClass ( un , class_sniper ) ;
8567: LD_VAR 0 2
8571: PPUSH
8572: LD_INT 5
8574: PPUSH
8575: CALL_OW 336
// end ;
8579: PPOPN 3
8581: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8582: LD_EXP 8
8586: PUSH
8587: LD_EXP 26
8591: AND
8592: PUSH
8593: LD_OWVAR 67
8597: PUSH
8598: LD_INT 3
8600: LESS
8601: AND
8602: IFFALSE 8621
8604: GO 8606
8606: DISABLE
// Difficulty := Difficulty + 1 ;
8607: LD_ADDR_OWVAR 67
8611: PUSH
8612: LD_OWVAR 67
8616: PUSH
8617: LD_INT 1
8619: PLUS
8620: ST_TO_ADDR
8621: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8622: LD_EXP 8
8626: PUSH
8627: LD_EXP 27
8631: AND
8632: IFFALSE 8735
8634: GO 8636
8636: DISABLE
8637: LD_INT 0
8639: PPUSH
// begin for i := 1 to 5 do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: DOUBLE
8646: LD_INT 1
8648: DEC
8649: ST_TO_ADDR
8650: LD_INT 5
8652: PUSH
8653: FOR_TO
8654: IFFALSE 8733
// begin uc_nation := nation_nature ;
8656: LD_ADDR_OWVAR 21
8660: PUSH
8661: LD_INT 0
8663: ST_TO_ADDR
// uc_side := 0 ;
8664: LD_ADDR_OWVAR 20
8668: PUSH
8669: LD_INT 0
8671: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8672: LD_ADDR_OWVAR 29
8676: PUSH
8677: LD_INT 12
8679: PUSH
8680: LD_INT 12
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: ST_TO_ADDR
// hc_agressivity := 20 ;
8687: LD_ADDR_OWVAR 35
8691: PUSH
8692: LD_INT 20
8694: ST_TO_ADDR
// hc_class := class_tiger ;
8695: LD_ADDR_OWVAR 28
8699: PUSH
8700: LD_INT 14
8702: ST_TO_ADDR
// hc_gallery :=  ;
8703: LD_ADDR_OWVAR 33
8707: PUSH
8708: LD_STRING 
8710: ST_TO_ADDR
// hc_name :=  ;
8711: LD_ADDR_OWVAR 26
8715: PUSH
8716: LD_STRING 
8718: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8719: CALL_OW 44
8723: PPUSH
8724: LD_INT 0
8726: PPUSH
8727: CALL_OW 51
// end ;
8731: GO 8653
8733: POP
8734: POP
// end ;
8735: PPOPN 1
8737: END
// every 0 0$1 trigger StreamModeActive and sBomb do
8738: LD_EXP 8
8742: PUSH
8743: LD_EXP 28
8747: AND
8748: IFFALSE 8757
8750: GO 8752
8752: DISABLE
// StreamSibBomb ;
8753: CALL 8758 0 0
8757: END
// export function StreamSibBomb ; var i , x , y ; begin
8758: LD_INT 0
8760: PPUSH
8761: PPUSH
8762: PPUSH
8763: PPUSH
// result := false ;
8764: LD_ADDR_VAR 0 1
8768: PUSH
8769: LD_INT 0
8771: ST_TO_ADDR
// for i := 1 to 16 do
8772: LD_ADDR_VAR 0 2
8776: PUSH
8777: DOUBLE
8778: LD_INT 1
8780: DEC
8781: ST_TO_ADDR
8782: LD_INT 16
8784: PUSH
8785: FOR_TO
8786: IFFALSE 8985
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8788: LD_ADDR_VAR 0 3
8792: PUSH
8793: LD_INT 10
8795: PUSH
8796: LD_INT 20
8798: PUSH
8799: LD_INT 30
8801: PUSH
8802: LD_INT 40
8804: PUSH
8805: LD_INT 50
8807: PUSH
8808: LD_INT 60
8810: PUSH
8811: LD_INT 70
8813: PUSH
8814: LD_INT 80
8816: PUSH
8817: LD_INT 90
8819: PUSH
8820: LD_INT 100
8822: PUSH
8823: LD_INT 110
8825: PUSH
8826: LD_INT 120
8828: PUSH
8829: LD_INT 130
8831: PUSH
8832: LD_INT 140
8834: PUSH
8835: LD_INT 150
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 1
8857: PPUSH
8858: LD_INT 15
8860: PPUSH
8861: CALL_OW 12
8865: ARRAY
8866: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8867: LD_ADDR_VAR 0 4
8871: PUSH
8872: LD_INT 10
8874: PUSH
8875: LD_INT 20
8877: PUSH
8878: LD_INT 30
8880: PUSH
8881: LD_INT 40
8883: PUSH
8884: LD_INT 50
8886: PUSH
8887: LD_INT 60
8889: PUSH
8890: LD_INT 70
8892: PUSH
8893: LD_INT 80
8895: PUSH
8896: LD_INT 90
8898: PUSH
8899: LD_INT 100
8901: PUSH
8902: LD_INT 110
8904: PUSH
8905: LD_INT 120
8907: PUSH
8908: LD_INT 130
8910: PUSH
8911: LD_INT 140
8913: PUSH
8914: LD_INT 150
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: PUSH
8934: LD_INT 1
8936: PPUSH
8937: LD_INT 15
8939: PPUSH
8940: CALL_OW 12
8944: ARRAY
8945: ST_TO_ADDR
// if ValidHex ( x , y ) then
8946: LD_VAR 0 3
8950: PPUSH
8951: LD_VAR 0 4
8955: PPUSH
8956: CALL_OW 488
8960: IFFALSE 8983
// begin result := [ x , y ] ;
8962: LD_ADDR_VAR 0 1
8966: PUSH
8967: LD_VAR 0 3
8971: PUSH
8972: LD_VAR 0 4
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: ST_TO_ADDR
// break ;
8981: GO 8985
// end ; end ;
8983: GO 8785
8985: POP
8986: POP
// if result then
8987: LD_VAR 0 1
8991: IFFALSE 9051
// begin ToLua ( playSibBomb() ) ;
8993: LD_STRING playSibBomb()
8995: PPUSH
8996: CALL_OW 559
// wait ( 0 0$14 ) ;
9000: LD_INT 490
9002: PPUSH
9003: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
9007: LD_VAR 0 1
9011: PUSH
9012: LD_INT 1
9014: ARRAY
9015: PPUSH
9016: LD_VAR 0 1
9020: PUSH
9021: LD_INT 2
9023: ARRAY
9024: PPUSH
9025: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
9029: LD_VAR 0 1
9033: PUSH
9034: LD_INT 1
9036: ARRAY
9037: PPUSH
9038: LD_VAR 0 1
9042: PUSH
9043: LD_INT 2
9045: ARRAY
9046: PPUSH
9047: CALL_OW 429
// end ; end ;
9051: LD_VAR 0 1
9055: RET
// every 0 0$1 trigger StreamModeActive and sReset do
9056: LD_EXP 8
9060: PUSH
9061: LD_EXP 30
9065: AND
9066: IFFALSE 9078
9068: GO 9070
9070: DISABLE
// YouLost (  ) ;
9071: LD_STRING 
9073: PPUSH
9074: CALL_OW 104
9078: END
// every 0 0$1 trigger StreamModeActive and sFog do
9079: LD_EXP 8
9083: PUSH
9084: LD_EXP 29
9088: AND
9089: IFFALSE 9103
9091: GO 9093
9093: DISABLE
// FogOff ( your_side ) ;
9094: LD_OWVAR 2
9098: PPUSH
9099: CALL_OW 344
9103: END
// every 0 0$1 trigger StreamModeActive and sSun do
9104: LD_EXP 8
9108: PUSH
9109: LD_EXP 31
9113: AND
9114: IFFALSE 9142
9116: GO 9118
9118: DISABLE
// begin solar_recharge_percent := 0 ;
9119: LD_ADDR_OWVAR 79
9123: PUSH
9124: LD_INT 0
9126: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9127: LD_INT 10500
9129: PPUSH
9130: CALL_OW 67
// solar_recharge_percent := 100 ;
9134: LD_ADDR_OWVAR 79
9138: PUSH
9139: LD_INT 100
9141: ST_TO_ADDR
// end ;
9142: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
9143: LD_EXP 8
9147: PUSH
9148: LD_EXP 32
9152: AND
9153: IFFALSE 9392
9155: GO 9157
9157: DISABLE
9158: LD_INT 0
9160: PPUSH
9161: PPUSH
9162: PPUSH
// begin tmp := [ ] ;
9163: LD_ADDR_VAR 0 3
9167: PUSH
9168: EMPTY
9169: ST_TO_ADDR
// for i := 1 to 6 do
9170: LD_ADDR_VAR 0 1
9174: PUSH
9175: DOUBLE
9176: LD_INT 1
9178: DEC
9179: ST_TO_ADDR
9180: LD_INT 6
9182: PUSH
9183: FOR_TO
9184: IFFALSE 9289
// begin uc_nation := nation_nature ;
9186: LD_ADDR_OWVAR 21
9190: PUSH
9191: LD_INT 0
9193: ST_TO_ADDR
// uc_side := 0 ;
9194: LD_ADDR_OWVAR 20
9198: PUSH
9199: LD_INT 0
9201: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9202: LD_ADDR_OWVAR 29
9206: PUSH
9207: LD_INT 12
9209: PUSH
9210: LD_INT 12
9212: PUSH
9213: EMPTY
9214: LIST
9215: LIST
9216: ST_TO_ADDR
// hc_agressivity := 20 ;
9217: LD_ADDR_OWVAR 35
9221: PUSH
9222: LD_INT 20
9224: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9225: LD_ADDR_OWVAR 28
9229: PUSH
9230: LD_INT 17
9232: ST_TO_ADDR
// hc_gallery :=  ;
9233: LD_ADDR_OWVAR 33
9237: PUSH
9238: LD_STRING 
9240: ST_TO_ADDR
// hc_name :=  ;
9241: LD_ADDR_OWVAR 26
9245: PUSH
9246: LD_STRING 
9248: ST_TO_ADDR
// un := CreateHuman ;
9249: LD_ADDR_VAR 0 2
9253: PUSH
9254: CALL_OW 44
9258: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9259: LD_VAR 0 2
9263: PPUSH
9264: LD_INT 1
9266: PPUSH
9267: CALL_OW 51
// tmp := tmp ^ un ;
9271: LD_ADDR_VAR 0 3
9275: PUSH
9276: LD_VAR 0 3
9280: PUSH
9281: LD_VAR 0 2
9285: ADD
9286: ST_TO_ADDR
// end ;
9287: GO 9183
9289: POP
9290: POP
// repeat wait ( 0 0$1 ) ;
9291: LD_INT 35
9293: PPUSH
9294: CALL_OW 67
// for un in tmp do
9298: LD_ADDR_VAR 0 2
9302: PUSH
9303: LD_VAR 0 3
9307: PUSH
9308: FOR_IN
9309: IFFALSE 9383
// begin if IsDead ( un ) then
9311: LD_VAR 0 2
9315: PPUSH
9316: CALL_OW 301
9320: IFFALSE 9340
// begin tmp := tmp diff un ;
9322: LD_ADDR_VAR 0 3
9326: PUSH
9327: LD_VAR 0 3
9331: PUSH
9332: LD_VAR 0 2
9336: DIFF
9337: ST_TO_ADDR
// continue ;
9338: GO 9308
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9340: LD_VAR 0 2
9344: PPUSH
9345: LD_INT 3
9347: PUSH
9348: LD_INT 22
9350: PUSH
9351: LD_INT 0
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PPUSH
9362: CALL_OW 69
9366: PPUSH
9367: LD_VAR 0 2
9371: PPUSH
9372: CALL_OW 74
9376: PPUSH
9377: CALL_OW 115
// end ;
9381: GO 9308
9383: POP
9384: POP
// until not tmp ;
9385: LD_VAR 0 3
9389: NOT
9390: IFFALSE 9291
// end ;
9392: PPOPN 3
9394: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9395: LD_EXP 8
9399: PUSH
9400: LD_EXP 33
9404: AND
9405: IFFALSE 9459
9407: GO 9409
9409: DISABLE
// begin ToLua ( displayTroll(); ) ;
9410: LD_STRING displayTroll();
9412: PPUSH
9413: CALL_OW 559
// wait ( 3 3$00 ) ;
9417: LD_INT 6300
9419: PPUSH
9420: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9424: LD_STRING hideTroll();
9426: PPUSH
9427: CALL_OW 559
// wait ( 1 1$00 ) ;
9431: LD_INT 2100
9433: PPUSH
9434: CALL_OW 67
// ToLua ( displayTroll(); ) ;
9438: LD_STRING displayTroll();
9440: PPUSH
9441: CALL_OW 559
// wait ( 1 1$00 ) ;
9445: LD_INT 2100
9447: PPUSH
9448: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9452: LD_STRING hideTroll();
9454: PPUSH
9455: CALL_OW 559
// end ;
9459: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9460: LD_EXP 8
9464: PUSH
9465: LD_EXP 34
9469: AND
9470: IFFALSE 9533
9472: GO 9474
9474: DISABLE
9475: LD_INT 0
9477: PPUSH
// begin p := 0 ;
9478: LD_ADDR_VAR 0 1
9482: PUSH
9483: LD_INT 0
9485: ST_TO_ADDR
// repeat game_speed := 1 ;
9486: LD_ADDR_OWVAR 65
9490: PUSH
9491: LD_INT 1
9493: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9494: LD_INT 35
9496: PPUSH
9497: CALL_OW 67
// p := p + 1 ;
9501: LD_ADDR_VAR 0 1
9505: PUSH
9506: LD_VAR 0 1
9510: PUSH
9511: LD_INT 1
9513: PLUS
9514: ST_TO_ADDR
// until p >= 60 ;
9515: LD_VAR 0 1
9519: PUSH
9520: LD_INT 60
9522: GREATEREQUAL
9523: IFFALSE 9486
// game_speed := 4 ;
9525: LD_ADDR_OWVAR 65
9529: PUSH
9530: LD_INT 4
9532: ST_TO_ADDR
// end ;
9533: PPOPN 1
9535: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9536: LD_EXP 8
9540: PUSH
9541: LD_EXP 35
9545: AND
9546: IFFALSE 9692
9548: GO 9550
9550: DISABLE
9551: LD_INT 0
9553: PPUSH
9554: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9555: LD_ADDR_VAR 0 1
9559: PUSH
9560: LD_INT 22
9562: PUSH
9563: LD_OWVAR 2
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: PUSH
9572: LD_INT 2
9574: PUSH
9575: LD_INT 30
9577: PUSH
9578: LD_INT 0
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: PUSH
9585: LD_INT 30
9587: PUSH
9588: LD_INT 1
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PPUSH
9604: CALL_OW 69
9608: ST_TO_ADDR
// if not depot then
9609: LD_VAR 0 1
9613: NOT
9614: IFFALSE 9618
// exit ;
9616: GO 9692
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9618: LD_ADDR_VAR 0 2
9622: PUSH
9623: LD_VAR 0 1
9627: PUSH
9628: LD_INT 1
9630: PPUSH
9631: LD_VAR 0 1
9635: PPUSH
9636: CALL_OW 12
9640: ARRAY
9641: PPUSH
9642: CALL_OW 274
9646: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9647: LD_VAR 0 2
9651: PPUSH
9652: LD_INT 1
9654: PPUSH
9655: LD_INT 0
9657: PPUSH
9658: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9662: LD_VAR 0 2
9666: PPUSH
9667: LD_INT 2
9669: PPUSH
9670: LD_INT 0
9672: PPUSH
9673: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9677: LD_VAR 0 2
9681: PPUSH
9682: LD_INT 3
9684: PPUSH
9685: LD_INT 0
9687: PPUSH
9688: CALL_OW 277
// end ;
9692: PPOPN 2
9694: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9695: LD_EXP 8
9699: PUSH
9700: LD_EXP 36
9704: AND
9705: IFFALSE 9802
9707: GO 9709
9709: DISABLE
9710: LD_INT 0
9712: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9713: LD_ADDR_VAR 0 1
9717: PUSH
9718: LD_INT 22
9720: PUSH
9721: LD_OWVAR 2
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: LD_INT 21
9732: PUSH
9733: LD_INT 1
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 3
9742: PUSH
9743: LD_INT 23
9745: PUSH
9746: LD_INT 0
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: PPUSH
9762: CALL_OW 69
9766: ST_TO_ADDR
// if not tmp then
9767: LD_VAR 0 1
9771: NOT
9772: IFFALSE 9776
// exit ;
9774: GO 9802
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 1
9783: PPUSH
9784: LD_VAR 0 1
9788: PPUSH
9789: CALL_OW 12
9793: ARRAY
9794: PPUSH
9795: LD_INT 200
9797: PPUSH
9798: CALL_OW 234
// end ;
9802: PPOPN 1
9804: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9805: LD_EXP 8
9809: PUSH
9810: LD_EXP 37
9814: AND
9815: IFFALSE 9894
9817: GO 9819
9819: DISABLE
9820: LD_INT 0
9822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9823: LD_ADDR_VAR 0 1
9827: PUSH
9828: LD_INT 22
9830: PUSH
9831: LD_OWVAR 2
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PUSH
9840: LD_INT 21
9842: PUSH
9843: LD_INT 2
9845: PUSH
9846: EMPTY
9847: LIST
9848: LIST
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PPUSH
9854: CALL_OW 69
9858: ST_TO_ADDR
// if not tmp then
9859: LD_VAR 0 1
9863: NOT
9864: IFFALSE 9868
// exit ;
9866: GO 9894
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9868: LD_VAR 0 1
9872: PUSH
9873: LD_INT 1
9875: PPUSH
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 12
9885: ARRAY
9886: PPUSH
9887: LD_INT 60
9889: PPUSH
9890: CALL_OW 234
// end ;
9894: PPOPN 1
9896: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9897: LD_EXP 8
9901: PUSH
9902: LD_EXP 38
9906: AND
9907: IFFALSE 10006
9909: GO 9911
9911: DISABLE
9912: LD_INT 0
9914: PPUSH
9915: PPUSH
// begin enable ;
9916: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9917: LD_ADDR_VAR 0 1
9921: PUSH
9922: LD_INT 22
9924: PUSH
9925: LD_OWVAR 2
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 61
9936: PUSH
9937: EMPTY
9938: LIST
9939: PUSH
9940: LD_INT 33
9942: PUSH
9943: LD_INT 2
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PPUSH
9955: CALL_OW 69
9959: ST_TO_ADDR
// if not tmp then
9960: LD_VAR 0 1
9964: NOT
9965: IFFALSE 9969
// exit ;
9967: GO 10006
// for i in tmp do
9969: LD_ADDR_VAR 0 2
9973: PUSH
9974: LD_VAR 0 1
9978: PUSH
9979: FOR_IN
9980: IFFALSE 10004
// if IsControledBy ( i ) then
9982: LD_VAR 0 2
9986: PPUSH
9987: CALL_OW 312
9991: IFFALSE 10002
// ComUnlink ( i ) ;
9993: LD_VAR 0 2
9997: PPUSH
9998: CALL_OW 136
10002: GO 9979
10004: POP
10005: POP
// end ;
10006: PPOPN 2
10008: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
10009: LD_EXP 8
10013: PUSH
10014: LD_EXP 39
10018: AND
10019: IFFALSE 10159
10021: GO 10023
10023: DISABLE
10024: LD_INT 0
10026: PPUSH
10027: PPUSH
// begin ToLua ( displayPowell(); ) ;
10028: LD_STRING displayPowell();
10030: PPUSH
10031: CALL_OW 559
// uc_side := 0 ;
10035: LD_ADDR_OWVAR 20
10039: PUSH
10040: LD_INT 0
10042: ST_TO_ADDR
// uc_nation := 2 ;
10043: LD_ADDR_OWVAR 21
10047: PUSH
10048: LD_INT 2
10050: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
10051: LD_ADDR_OWVAR 37
10055: PUSH
10056: LD_INT 14
10058: ST_TO_ADDR
// vc_engine := engine_siberite ;
10059: LD_ADDR_OWVAR 39
10063: PUSH
10064: LD_INT 3
10066: ST_TO_ADDR
// vc_control := control_apeman ;
10067: LD_ADDR_OWVAR 38
10071: PUSH
10072: LD_INT 5
10074: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
10075: LD_ADDR_OWVAR 40
10079: PUSH
10080: LD_INT 29
10082: ST_TO_ADDR
// un := CreateVehicle ;
10083: LD_ADDR_VAR 0 2
10087: PUSH
10088: CALL_OW 45
10092: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10093: LD_VAR 0 2
10097: PPUSH
10098: LD_INT 1
10100: PPUSH
10101: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10105: LD_INT 35
10107: PPUSH
10108: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10112: LD_VAR 0 2
10116: PPUSH
10117: LD_INT 22
10119: PUSH
10120: LD_OWVAR 2
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PPUSH
10134: LD_VAR 0 2
10138: PPUSH
10139: CALL_OW 74
10143: PPUSH
10144: CALL_OW 115
// until IsDead ( un ) ;
10148: LD_VAR 0 2
10152: PPUSH
10153: CALL_OW 301
10157: IFFALSE 10105
// end ;
10159: PPOPN 2
10161: END
// every 0 0$1 trigger StreamModeActive and sStu do
10162: LD_EXP 8
10166: PUSH
10167: LD_EXP 47
10171: AND
10172: IFFALSE 10188
10174: GO 10176
10176: DISABLE
// begin ToLua ( displayStucuk(); ) ;
10177: LD_STRING displayStucuk();
10179: PPUSH
10180: CALL_OW 559
// ResetFog ;
10184: CALL_OW 335
// end ;
10188: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
10189: LD_EXP 8
10193: PUSH
10194: LD_EXP 40
10198: AND
10199: IFFALSE 10340
10201: GO 10203
10203: DISABLE
10204: LD_INT 0
10206: PPUSH
10207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10208: LD_ADDR_VAR 0 2
10212: PUSH
10213: LD_INT 22
10215: PUSH
10216: LD_OWVAR 2
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 21
10227: PUSH
10228: LD_INT 1
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: PPUSH
10239: CALL_OW 69
10243: ST_TO_ADDR
// if not tmp then
10244: LD_VAR 0 2
10248: NOT
10249: IFFALSE 10253
// exit ;
10251: GO 10340
// un := tmp [ rand ( 1 , tmp ) ] ;
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 2
10262: PUSH
10263: LD_INT 1
10265: PPUSH
10266: LD_VAR 0 2
10270: PPUSH
10271: CALL_OW 12
10275: ARRAY
10276: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: LD_INT 0
10284: PPUSH
10285: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10289: LD_VAR 0 1
10293: PPUSH
10294: LD_OWVAR 3
10298: PUSH
10299: LD_VAR 0 1
10303: DIFF
10304: PPUSH
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 74
10314: PPUSH
10315: CALL_OW 115
// wait ( 0 0$20 ) ;
10319: LD_INT 700
10321: PPUSH
10322: CALL_OW 67
// SetSide ( un , your_side ) ;
10326: LD_VAR 0 1
10330: PPUSH
10331: LD_OWVAR 2
10335: PPUSH
10336: CALL_OW 235
// end ;
10340: PPOPN 2
10342: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10343: LD_EXP 8
10347: PUSH
10348: LD_EXP 41
10352: AND
10353: IFFALSE 10459
10355: GO 10357
10357: DISABLE
10358: LD_INT 0
10360: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10361: LD_ADDR_VAR 0 1
10365: PUSH
10366: LD_INT 22
10368: PUSH
10369: LD_OWVAR 2
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: PUSH
10378: LD_INT 2
10380: PUSH
10381: LD_INT 30
10383: PUSH
10384: LD_INT 0
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: LD_INT 30
10393: PUSH
10394: LD_INT 1
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: LIST
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PPUSH
10410: CALL_OW 69
10414: ST_TO_ADDR
// if not depot then
10415: LD_VAR 0 1
10419: NOT
10420: IFFALSE 10424
// exit ;
10422: GO 10459
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10424: LD_VAR 0 1
10428: PUSH
10429: LD_INT 1
10431: ARRAY
10432: PPUSH
10433: CALL_OW 250
10437: PPUSH
10438: LD_VAR 0 1
10442: PUSH
10443: LD_INT 1
10445: ARRAY
10446: PPUSH
10447: CALL_OW 251
10451: PPUSH
10452: LD_INT 70
10454: PPUSH
10455: CALL_OW 495
// end ;
10459: PPOPN 1
10461: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10462: LD_EXP 8
10466: PUSH
10467: LD_EXP 42
10471: AND
10472: IFFALSE 10683
10474: GO 10476
10476: DISABLE
10477: LD_INT 0
10479: PPUSH
10480: PPUSH
10481: PPUSH
10482: PPUSH
10483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10484: LD_ADDR_VAR 0 5
10488: PUSH
10489: LD_INT 22
10491: PUSH
10492: LD_OWVAR 2
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PUSH
10501: LD_INT 21
10503: PUSH
10504: LD_INT 1
10506: PUSH
10507: EMPTY
10508: LIST
10509: LIST
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PPUSH
10515: CALL_OW 69
10519: ST_TO_ADDR
// if not tmp then
10520: LD_VAR 0 5
10524: NOT
10525: IFFALSE 10529
// exit ;
10527: GO 10683
// for i in tmp do
10529: LD_ADDR_VAR 0 1
10533: PUSH
10534: LD_VAR 0 5
10538: PUSH
10539: FOR_IN
10540: IFFALSE 10681
// begin d := rand ( 0 , 5 ) ;
10542: LD_ADDR_VAR 0 4
10546: PUSH
10547: LD_INT 0
10549: PPUSH
10550: LD_INT 5
10552: PPUSH
10553: CALL_OW 12
10557: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_VAR 0 1
10567: PPUSH
10568: CALL_OW 250
10572: PPUSH
10573: LD_VAR 0 4
10577: PPUSH
10578: LD_INT 3
10580: PPUSH
10581: LD_INT 12
10583: PPUSH
10584: CALL_OW 12
10588: PPUSH
10589: CALL_OW 272
10593: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10594: LD_ADDR_VAR 0 3
10598: PUSH
10599: LD_VAR 0 1
10603: PPUSH
10604: CALL_OW 251
10608: PPUSH
10609: LD_VAR 0 4
10613: PPUSH
10614: LD_INT 3
10616: PPUSH
10617: LD_INT 12
10619: PPUSH
10620: CALL_OW 12
10624: PPUSH
10625: CALL_OW 273
10629: ST_TO_ADDR
// if ValidHex ( x , y ) then
10630: LD_VAR 0 2
10634: PPUSH
10635: LD_VAR 0 3
10639: PPUSH
10640: CALL_OW 488
10644: IFFALSE 10679
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10646: LD_VAR 0 1
10650: PPUSH
10651: LD_VAR 0 2
10655: PPUSH
10656: LD_VAR 0 3
10660: PPUSH
10661: LD_INT 3
10663: PPUSH
10664: LD_INT 6
10666: PPUSH
10667: CALL_OW 12
10671: PPUSH
10672: LD_INT 1
10674: PPUSH
10675: CALL_OW 483
// end ;
10679: GO 10539
10681: POP
10682: POP
// end ;
10683: PPOPN 5
10685: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10686: LD_EXP 8
10690: PUSH
10691: LD_EXP 43
10695: AND
10696: IFFALSE 10790
10698: GO 10700
10700: DISABLE
10701: LD_INT 0
10703: PPUSH
10704: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10705: LD_ADDR_VAR 0 2
10709: PUSH
10710: LD_INT 22
10712: PUSH
10713: LD_OWVAR 2
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 32
10724: PUSH
10725: LD_INT 1
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 2
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: PPUSH
10747: CALL_OW 69
10751: ST_TO_ADDR
// if not tmp then
10752: LD_VAR 0 2
10756: NOT
10757: IFFALSE 10761
// exit ;
10759: GO 10790
// for i in tmp do
10761: LD_ADDR_VAR 0 1
10765: PUSH
10766: LD_VAR 0 2
10770: PUSH
10771: FOR_IN
10772: IFFALSE 10788
// SetFuel ( i , 0 ) ;
10774: LD_VAR 0 1
10778: PPUSH
10779: LD_INT 0
10781: PPUSH
10782: CALL_OW 240
10786: GO 10771
10788: POP
10789: POP
// end ;
10790: PPOPN 2
10792: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
10793: LD_EXP 8
10797: PUSH
10798: LD_EXP 44
10802: AND
10803: IFFALSE 10869
10805: GO 10807
10807: DISABLE
10808: LD_INT 0
10810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10811: LD_ADDR_VAR 0 1
10815: PUSH
10816: LD_INT 22
10818: PUSH
10819: LD_OWVAR 2
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: LD_INT 30
10830: PUSH
10831: LD_INT 29
10833: PUSH
10834: EMPTY
10835: LIST
10836: LIST
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 69
10846: ST_TO_ADDR
// if not tmp then
10847: LD_VAR 0 1
10851: NOT
10852: IFFALSE 10856
// exit ;
10854: GO 10869
// DestroyUnit ( tmp [ 1 ] ) ;
10856: LD_VAR 0 1
10860: PUSH
10861: LD_INT 1
10863: ARRAY
10864: PPUSH
10865: CALL_OW 65
// end ;
10869: PPOPN 1
10871: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10872: LD_EXP 8
10876: PUSH
10877: LD_EXP 46
10881: AND
10882: IFFALSE 11011
10884: GO 10886
10886: DISABLE
10887: LD_INT 0
10889: PPUSH
// begin uc_side := 0 ;
10890: LD_ADDR_OWVAR 20
10894: PUSH
10895: LD_INT 0
10897: ST_TO_ADDR
// uc_nation := nation_arabian ;
10898: LD_ADDR_OWVAR 21
10902: PUSH
10903: LD_INT 2
10905: ST_TO_ADDR
// hc_gallery :=  ;
10906: LD_ADDR_OWVAR 33
10910: PUSH
10911: LD_STRING 
10913: ST_TO_ADDR
// hc_name :=  ;
10914: LD_ADDR_OWVAR 26
10918: PUSH
10919: LD_STRING 
10921: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10922: LD_INT 1
10924: PPUSH
10925: LD_INT 11
10927: PPUSH
10928: LD_INT 10
10930: PPUSH
10931: CALL_OW 380
// un := CreateHuman ;
10935: LD_ADDR_VAR 0 1
10939: PUSH
10940: CALL_OW 44
10944: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10945: LD_VAR 0 1
10949: PPUSH
10950: LD_INT 1
10952: PPUSH
10953: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10957: LD_INT 35
10959: PPUSH
10960: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10964: LD_VAR 0 1
10968: PPUSH
10969: LD_INT 22
10971: PUSH
10972: LD_OWVAR 2
10976: PUSH
10977: EMPTY
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 115
// until IsDead ( un ) ;
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 301
11009: IFFALSE 10957
// end ;
11011: PPOPN 1
11013: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
11014: LD_EXP 8
11018: PUSH
11019: LD_EXP 48
11023: AND
11024: IFFALSE 11036
11026: GO 11028
11028: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
11029: LD_STRING earthquake(getX(game), 0, 32)
11031: PPUSH
11032: CALL_OW 559
11036: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
11037: LD_EXP 8
11041: PUSH
11042: LD_EXP 49
11046: AND
11047: IFFALSE 11138
11049: GO 11051
11051: DISABLE
11052: LD_INT 0
11054: PPUSH
// begin enable ;
11055: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
11056: LD_ADDR_VAR 0 1
11060: PUSH
11061: LD_INT 22
11063: PUSH
11064: LD_OWVAR 2
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: LD_INT 21
11075: PUSH
11076: LD_INT 2
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PUSH
11083: LD_INT 33
11085: PUSH
11086: LD_INT 3
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: PPUSH
11098: CALL_OW 69
11102: ST_TO_ADDR
// if not tmp then
11103: LD_VAR 0 1
11107: NOT
11108: IFFALSE 11112
// exit ;
11110: GO 11138
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11112: LD_VAR 0 1
11116: PUSH
11117: LD_INT 1
11119: PPUSH
11120: LD_VAR 0 1
11124: PPUSH
11125: CALL_OW 12
11129: ARRAY
11130: PPUSH
11131: LD_INT 1
11133: PPUSH
11134: CALL_OW 234
// end ;
11138: PPOPN 1
11140: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
11141: LD_EXP 8
11145: PUSH
11146: LD_EXP 50
11150: AND
11151: IFFALSE 11292
11153: GO 11155
11155: DISABLE
11156: LD_INT 0
11158: PPUSH
11159: PPUSH
11160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11161: LD_ADDR_VAR 0 3
11165: PUSH
11166: LD_INT 22
11168: PUSH
11169: LD_OWVAR 2
11173: PUSH
11174: EMPTY
11175: LIST
11176: LIST
11177: PUSH
11178: LD_INT 25
11180: PUSH
11181: LD_INT 1
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: PPUSH
11192: CALL_OW 69
11196: ST_TO_ADDR
// if not tmp then
11197: LD_VAR 0 3
11201: NOT
11202: IFFALSE 11206
// exit ;
11204: GO 11292
// un := tmp [ rand ( 1 , tmp ) ] ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_VAR 0 3
11215: PUSH
11216: LD_INT 1
11218: PPUSH
11219: LD_VAR 0 3
11223: PPUSH
11224: CALL_OW 12
11228: ARRAY
11229: ST_TO_ADDR
// if Crawls ( un ) then
11230: LD_VAR 0 2
11234: PPUSH
11235: CALL_OW 318
11239: IFFALSE 11250
// ComWalk ( un ) ;
11241: LD_VAR 0 2
11245: PPUSH
11246: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
11250: LD_VAR 0 2
11254: PPUSH
11255: LD_INT 9
11257: PPUSH
11258: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
11262: LD_INT 28
11264: PPUSH
11265: LD_OWVAR 2
11269: PPUSH
11270: LD_INT 2
11272: PPUSH
11273: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
11277: LD_INT 29
11279: PPUSH
11280: LD_OWVAR 2
11284: PPUSH
11285: LD_INT 2
11287: PPUSH
11288: CALL_OW 322
// end ;
11292: PPOPN 3
11294: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
11295: LD_EXP 8
11299: PUSH
11300: LD_EXP 51
11304: AND
11305: IFFALSE 11416
11307: GO 11309
11309: DISABLE
11310: LD_INT 0
11312: PPUSH
11313: PPUSH
11314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 22
11322: PUSH
11323: LD_OWVAR 2
11327: PUSH
11328: EMPTY
11329: LIST
11330: LIST
11331: PUSH
11332: LD_INT 25
11334: PUSH
11335: LD_INT 1
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: PPUSH
11346: CALL_OW 69
11350: ST_TO_ADDR
// if not tmp then
11351: LD_VAR 0 3
11355: NOT
11356: IFFALSE 11360
// exit ;
11358: GO 11416
// un := tmp [ rand ( 1 , tmp ) ] ;
11360: LD_ADDR_VAR 0 2
11364: PUSH
11365: LD_VAR 0 3
11369: PUSH
11370: LD_INT 1
11372: PPUSH
11373: LD_VAR 0 3
11377: PPUSH
11378: CALL_OW 12
11382: ARRAY
11383: ST_TO_ADDR
// if Crawls ( un ) then
11384: LD_VAR 0 2
11388: PPUSH
11389: CALL_OW 318
11393: IFFALSE 11404
// ComWalk ( un ) ;
11395: LD_VAR 0 2
11399: PPUSH
11400: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11404: LD_VAR 0 2
11408: PPUSH
11409: LD_INT 8
11411: PPUSH
11412: CALL_OW 336
// end ;
11416: PPOPN 3
11418: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
11419: LD_EXP 8
11423: PUSH
11424: LD_EXP 52
11428: AND
11429: IFFALSE 11573
11431: GO 11433
11433: DISABLE
11434: LD_INT 0
11436: PPUSH
11437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
11438: LD_ADDR_VAR 0 2
11442: PUSH
11443: LD_INT 22
11445: PUSH
11446: LD_OWVAR 2
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: LD_INT 21
11457: PUSH
11458: LD_INT 2
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: PUSH
11465: LD_INT 2
11467: PUSH
11468: LD_INT 34
11470: PUSH
11471: LD_INT 12
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: LD_INT 34
11480: PUSH
11481: LD_INT 51
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: PUSH
11488: LD_INT 34
11490: PUSH
11491: LD_INT 32
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: LIST
11508: PPUSH
11509: CALL_OW 69
11513: ST_TO_ADDR
// if not tmp then
11514: LD_VAR 0 2
11518: NOT
11519: IFFALSE 11523
// exit ;
11521: GO 11573
// for i in tmp do
11523: LD_ADDR_VAR 0 1
11527: PUSH
11528: LD_VAR 0 2
11532: PUSH
11533: FOR_IN
11534: IFFALSE 11571
// if GetCargo ( i , mat_artifact ) = 0 then
11536: LD_VAR 0 1
11540: PPUSH
11541: LD_INT 4
11543: PPUSH
11544: CALL_OW 289
11548: PUSH
11549: LD_INT 0
11551: EQUAL
11552: IFFALSE 11569
// SetCargo ( i , mat_siberit , 100 ) ;
11554: LD_VAR 0 1
11558: PPUSH
11559: LD_INT 3
11561: PPUSH
11562: LD_INT 100
11564: PPUSH
11565: CALL_OW 290
11569: GO 11533
11571: POP
11572: POP
// end ;
11573: PPOPN 2
11575: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
11576: LD_EXP 8
11580: PUSH
11581: LD_EXP 53
11585: AND
11586: IFFALSE 11769
11588: GO 11590
11590: DISABLE
11591: LD_INT 0
11593: PPUSH
11594: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
11595: LD_ADDR_VAR 0 2
11599: PUSH
11600: LD_INT 22
11602: PUSH
11603: LD_OWVAR 2
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: PPUSH
11612: CALL_OW 69
11616: ST_TO_ADDR
// if not tmp then
11617: LD_VAR 0 2
11621: NOT
11622: IFFALSE 11626
// exit ;
11624: GO 11769
// for i := 1 to 2 do
11626: LD_ADDR_VAR 0 1
11630: PUSH
11631: DOUBLE
11632: LD_INT 1
11634: DEC
11635: ST_TO_ADDR
11636: LD_INT 2
11638: PUSH
11639: FOR_TO
11640: IFFALSE 11767
// begin uc_side := your_side ;
11642: LD_ADDR_OWVAR 20
11646: PUSH
11647: LD_OWVAR 2
11651: ST_TO_ADDR
// uc_nation := nation_american ;
11652: LD_ADDR_OWVAR 21
11656: PUSH
11657: LD_INT 1
11659: ST_TO_ADDR
// vc_chassis := us_morphling ;
11660: LD_ADDR_OWVAR 37
11664: PUSH
11665: LD_INT 5
11667: ST_TO_ADDR
// vc_engine := engine_siberite ;
11668: LD_ADDR_OWVAR 39
11672: PUSH
11673: LD_INT 3
11675: ST_TO_ADDR
// vc_control := control_computer ;
11676: LD_ADDR_OWVAR 38
11680: PUSH
11681: LD_INT 3
11683: ST_TO_ADDR
// vc_weapon := us_double_laser ;
11684: LD_ADDR_OWVAR 40
11688: PUSH
11689: LD_INT 10
11691: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
11692: LD_VAR 0 2
11696: PUSH
11697: LD_INT 1
11699: ARRAY
11700: PPUSH
11701: CALL_OW 310
11705: NOT
11706: IFFALSE 11753
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
11708: CALL_OW 45
11712: PPUSH
11713: LD_VAR 0 2
11717: PUSH
11718: LD_INT 1
11720: ARRAY
11721: PPUSH
11722: CALL_OW 250
11726: PPUSH
11727: LD_VAR 0 2
11731: PUSH
11732: LD_INT 1
11734: ARRAY
11735: PPUSH
11736: CALL_OW 251
11740: PPUSH
11741: LD_INT 12
11743: PPUSH
11744: LD_INT 1
11746: PPUSH
11747: CALL_OW 50
11751: GO 11765
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
11753: CALL_OW 45
11757: PPUSH
11758: LD_INT 1
11760: PPUSH
11761: CALL_OW 51
// end ;
11765: GO 11639
11767: POP
11768: POP
// end ;
11769: PPOPN 2
11771: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
11772: LD_EXP 8
11776: PUSH
11777: LD_EXP 54
11781: AND
11782: IFFALSE 12004
11784: GO 11786
11786: DISABLE
11787: LD_INT 0
11789: PPUSH
11790: PPUSH
11791: PPUSH
11792: PPUSH
11793: PPUSH
11794: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11795: LD_ADDR_VAR 0 6
11799: PUSH
11800: LD_INT 22
11802: PUSH
11803: LD_OWVAR 2
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: LD_INT 21
11814: PUSH
11815: LD_INT 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: LD_INT 23
11827: PUSH
11828: LD_INT 0
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: LIST
11843: PPUSH
11844: CALL_OW 69
11848: ST_TO_ADDR
// if not tmp then
11849: LD_VAR 0 6
11853: NOT
11854: IFFALSE 11858
// exit ;
11856: GO 12004
// s1 := rand ( 1 , 4 ) ;
11858: LD_ADDR_VAR 0 2
11862: PUSH
11863: LD_INT 1
11865: PPUSH
11866: LD_INT 4
11868: PPUSH
11869: CALL_OW 12
11873: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
11874: LD_ADDR_VAR 0 4
11878: PUSH
11879: LD_VAR 0 6
11883: PUSH
11884: LD_INT 1
11886: ARRAY
11887: PPUSH
11888: LD_VAR 0 2
11892: PPUSH
11893: CALL_OW 259
11897: ST_TO_ADDR
// if s1 = 1 then
11898: LD_VAR 0 2
11902: PUSH
11903: LD_INT 1
11905: EQUAL
11906: IFFALSE 11926
// s2 := rand ( 2 , 4 ) else
11908: LD_ADDR_VAR 0 3
11912: PUSH
11913: LD_INT 2
11915: PPUSH
11916: LD_INT 4
11918: PPUSH
11919: CALL_OW 12
11923: ST_TO_ADDR
11924: GO 11934
// s2 := 1 ;
11926: LD_ADDR_VAR 0 3
11930: PUSH
11931: LD_INT 1
11933: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
11934: LD_ADDR_VAR 0 5
11938: PUSH
11939: LD_VAR 0 6
11943: PUSH
11944: LD_INT 1
11946: ARRAY
11947: PPUSH
11948: LD_VAR 0 3
11952: PPUSH
11953: CALL_OW 259
11957: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
11958: LD_VAR 0 6
11962: PUSH
11963: LD_INT 1
11965: ARRAY
11966: PPUSH
11967: LD_VAR 0 2
11971: PPUSH
11972: LD_VAR 0 5
11976: PPUSH
11977: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
11981: LD_VAR 0 6
11985: PUSH
11986: LD_INT 1
11988: ARRAY
11989: PPUSH
11990: LD_VAR 0 3
11994: PPUSH
11995: LD_VAR 0 4
11999: PPUSH
12000: CALL_OW 237
// end ;
12004: PPOPN 6
12006: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
12007: LD_EXP 8
12011: PUSH
12012: LD_EXP 55
12016: AND
12017: IFFALSE 12096
12019: GO 12021
12021: DISABLE
12022: LD_INT 0
12024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
12025: LD_ADDR_VAR 0 1
12029: PUSH
12030: LD_INT 22
12032: PUSH
12033: LD_OWVAR 2
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 30
12044: PUSH
12045: LD_INT 3
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: CALL_OW 69
12060: ST_TO_ADDR
// if not tmp then
12061: LD_VAR 0 1
12065: NOT
12066: IFFALSE 12070
// exit ;
12068: GO 12096
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12070: LD_VAR 0 1
12074: PUSH
12075: LD_INT 1
12077: PPUSH
12078: LD_VAR 0 1
12082: PPUSH
12083: CALL_OW 12
12087: ARRAY
12088: PPUSH
12089: LD_INT 1
12091: PPUSH
12092: CALL_OW 234
// end ;
12096: PPOPN 1
12098: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
12099: LD_EXP 8
12103: PUSH
12104: LD_EXP 56
12108: AND
12109: IFFALSE 12221
12111: GO 12113
12113: DISABLE
12114: LD_INT 0
12116: PPUSH
12117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
12118: LD_ADDR_VAR 0 2
12122: PUSH
12123: LD_INT 22
12125: PUSH
12126: LD_OWVAR 2
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 2
12137: PUSH
12138: LD_INT 30
12140: PUSH
12141: LD_INT 27
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: PUSH
12148: LD_INT 30
12150: PUSH
12151: LD_INT 26
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PUSH
12158: LD_INT 30
12160: PUSH
12161: LD_INT 28
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PPUSH
12178: CALL_OW 69
12182: ST_TO_ADDR
// if not tmp then
12183: LD_VAR 0 2
12187: NOT
12188: IFFALSE 12192
// exit ;
12190: GO 12221
// for i in tmp do
12192: LD_ADDR_VAR 0 1
12196: PUSH
12197: LD_VAR 0 2
12201: PUSH
12202: FOR_IN
12203: IFFALSE 12219
// SetLives ( i , 1 ) ;
12205: LD_VAR 0 1
12209: PPUSH
12210: LD_INT 1
12212: PPUSH
12213: CALL_OW 234
12217: GO 12202
12219: POP
12220: POP
// end ;
12221: PPOPN 2
12223: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
12224: LD_EXP 8
12228: PUSH
12229: LD_EXP 57
12233: AND
12234: IFFALSE 12508
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin i := rand ( 1 , 7 ) ;
12244: LD_ADDR_VAR 0 1
12248: PUSH
12249: LD_INT 1
12251: PPUSH
12252: LD_INT 7
12254: PPUSH
12255: CALL_OW 12
12259: ST_TO_ADDR
// case i of 1 :
12260: LD_VAR 0 1
12264: PUSH
12265: LD_INT 1
12267: DOUBLE
12268: EQUAL
12269: IFTRUE 12273
12271: GO 12283
12273: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
12274: LD_STRING earthquake(getX(game), 0, 32)
12276: PPUSH
12277: CALL_OW 559
12281: GO 12508
12283: LD_INT 2
12285: DOUBLE
12286: EQUAL
12287: IFTRUE 12291
12289: GO 12305
12291: POP
// begin ToLua ( displayStucuk(); ) ;
12292: LD_STRING displayStucuk();
12294: PPUSH
12295: CALL_OW 559
// ResetFog ;
12299: CALL_OW 335
// end ; 3 :
12303: GO 12508
12305: LD_INT 3
12307: DOUBLE
12308: EQUAL
12309: IFTRUE 12313
12311: GO 12417
12313: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12314: LD_ADDR_VAR 0 2
12318: PUSH
12319: LD_INT 22
12321: PUSH
12322: LD_OWVAR 2
12326: PUSH
12327: EMPTY
12328: LIST
12329: LIST
12330: PUSH
12331: LD_INT 25
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: PPUSH
12345: CALL_OW 69
12349: ST_TO_ADDR
// if not tmp then
12350: LD_VAR 0 2
12354: NOT
12355: IFFALSE 12359
// exit ;
12357: GO 12508
// un := tmp [ rand ( 1 , tmp ) ] ;
12359: LD_ADDR_VAR 0 3
12363: PUSH
12364: LD_VAR 0 2
12368: PUSH
12369: LD_INT 1
12371: PPUSH
12372: LD_VAR 0 2
12376: PPUSH
12377: CALL_OW 12
12381: ARRAY
12382: ST_TO_ADDR
// if Crawls ( un ) then
12383: LD_VAR 0 3
12387: PPUSH
12388: CALL_OW 318
12392: IFFALSE 12403
// ComWalk ( un ) ;
12394: LD_VAR 0 3
12398: PPUSH
12399: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12403: LD_VAR 0 3
12407: PPUSH
12408: LD_INT 8
12410: PPUSH
12411: CALL_OW 336
// end ; 4 :
12415: GO 12508
12417: LD_INT 4
12419: DOUBLE
12420: EQUAL
12421: IFTRUE 12425
12423: GO 12486
12425: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12426: LD_ADDR_VAR 0 2
12430: PUSH
12431: LD_INT 22
12433: PUSH
12434: LD_OWVAR 2
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: LD_INT 30
12445: PUSH
12446: LD_INT 29
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PPUSH
12457: CALL_OW 69
12461: ST_TO_ADDR
// if not tmp then
12462: LD_VAR 0 2
12466: NOT
12467: IFFALSE 12471
// exit ;
12469: GO 12508
// DestroyUnit ( tmp [ 1 ] ) ;
12471: LD_VAR 0 2
12475: PUSH
12476: LD_INT 1
12478: ARRAY
12479: PPUSH
12480: CALL_OW 65
// end ; 5 .. 7 :
12484: GO 12508
12486: LD_INT 5
12488: DOUBLE
12489: GREATEREQUAL
12490: IFFALSE 12498
12492: LD_INT 7
12494: DOUBLE
12495: LESSEQUAL
12496: IFTRUE 12500
12498: GO 12507
12500: POP
// StreamSibBomb ; end ;
12501: CALL 8758 0 0
12505: GO 12508
12507: POP
// end ;
12508: PPOPN 3
12510: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
12511: LD_EXP 8
12515: PUSH
12516: LD_EXP 58
12520: AND
12521: IFFALSE 12677
12523: GO 12525
12525: DISABLE
12526: LD_INT 0
12528: PPUSH
12529: PPUSH
12530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
12531: LD_ADDR_VAR 0 2
12535: PUSH
12536: LD_INT 81
12538: PUSH
12539: LD_OWVAR 2
12543: PUSH
12544: EMPTY
12545: LIST
12546: LIST
12547: PUSH
12548: LD_INT 2
12550: PUSH
12551: LD_INT 21
12553: PUSH
12554: LD_INT 1
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 21
12563: PUSH
12564: LD_INT 2
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: LIST
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PPUSH
12580: CALL_OW 69
12584: ST_TO_ADDR
// if not tmp then
12585: LD_VAR 0 2
12589: NOT
12590: IFFALSE 12594
// exit ;
12592: GO 12677
// p := 0 ;
12594: LD_ADDR_VAR 0 3
12598: PUSH
12599: LD_INT 0
12601: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12602: LD_INT 35
12604: PPUSH
12605: CALL_OW 67
// p := p + 1 ;
12609: LD_ADDR_VAR 0 3
12613: PUSH
12614: LD_VAR 0 3
12618: PUSH
12619: LD_INT 1
12621: PLUS
12622: ST_TO_ADDR
// for i in tmp do
12623: LD_ADDR_VAR 0 1
12627: PUSH
12628: LD_VAR 0 2
12632: PUSH
12633: FOR_IN
12634: IFFALSE 12665
// if GetLives ( i ) < 1000 then
12636: LD_VAR 0 1
12640: PPUSH
12641: CALL_OW 256
12645: PUSH
12646: LD_INT 1000
12648: LESS
12649: IFFALSE 12663
// SetLives ( i , 1000 ) ;
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 1000
12658: PPUSH
12659: CALL_OW 234
12663: GO 12633
12665: POP
12666: POP
// until p > 20 ;
12667: LD_VAR 0 3
12671: PUSH
12672: LD_INT 20
12674: GREATER
12675: IFFALSE 12602
// end ;
12677: PPOPN 3
12679: END
// every 0 0$1 trigger StreamModeActive and sTime do
12680: LD_EXP 8
12684: PUSH
12685: LD_EXP 59
12689: AND
12690: IFFALSE 12725
12692: GO 12694
12694: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
12695: LD_INT 28
12697: PPUSH
12698: LD_OWVAR 2
12702: PPUSH
12703: LD_INT 2
12705: PPUSH
12706: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
12710: LD_INT 30
12712: PPUSH
12713: LD_OWVAR 2
12717: PPUSH
12718: LD_INT 2
12720: PPUSH
12721: CALL_OW 322
// end ;
12725: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
12726: LD_EXP 8
12730: PUSH
12731: LD_EXP 60
12735: AND
12736: IFFALSE 12857
12738: GO 12740
12740: DISABLE
12741: LD_INT 0
12743: PPUSH
12744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12745: LD_ADDR_VAR 0 2
12749: PUSH
12750: LD_INT 22
12752: PUSH
12753: LD_OWVAR 2
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 21
12764: PUSH
12765: LD_INT 1
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: LD_INT 3
12774: PUSH
12775: LD_INT 23
12777: PUSH
12778: LD_INT 0
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: PPUSH
12794: CALL_OW 69
12798: ST_TO_ADDR
// if not tmp then
12799: LD_VAR 0 2
12803: NOT
12804: IFFALSE 12808
// exit ;
12806: GO 12857
// for i in tmp do
12808: LD_ADDR_VAR 0 1
12812: PUSH
12813: LD_VAR 0 2
12817: PUSH
12818: FOR_IN
12819: IFFALSE 12855
// begin if Crawls ( i ) then
12821: LD_VAR 0 1
12825: PPUSH
12826: CALL_OW 318
12830: IFFALSE 12841
// ComWalk ( i ) ;
12832: LD_VAR 0 1
12836: PPUSH
12837: CALL_OW 138
// SetClass ( i , 2 ) ;
12841: LD_VAR 0 1
12845: PPUSH
12846: LD_INT 2
12848: PPUSH
12849: CALL_OW 336
// end ;
12853: GO 12818
12855: POP
12856: POP
// end ;
12857: PPOPN 2
12859: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
12860: LD_EXP 8
12864: PUSH
12865: LD_EXP 61
12869: AND
12870: IFFALSE 13151
12872: GO 12874
12874: DISABLE
12875: LD_INT 0
12877: PPUSH
12878: PPUSH
12879: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
12880: LD_OWVAR 2
12884: PPUSH
12885: LD_INT 9
12887: PPUSH
12888: LD_INT 1
12890: PPUSH
12891: LD_INT 1
12893: PPUSH
12894: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12898: LD_INT 9
12900: PPUSH
12901: LD_OWVAR 2
12905: PPUSH
12906: CALL_OW 343
// uc_side := 9 ;
12910: LD_ADDR_OWVAR 20
12914: PUSH
12915: LD_INT 9
12917: ST_TO_ADDR
// uc_nation := 2 ;
12918: LD_ADDR_OWVAR 21
12922: PUSH
12923: LD_INT 2
12925: ST_TO_ADDR
// hc_name := Dark Warrior ;
12926: LD_ADDR_OWVAR 26
12930: PUSH
12931: LD_STRING Dark Warrior
12933: ST_TO_ADDR
// hc_gallery :=  ;
12934: LD_ADDR_OWVAR 33
12938: PUSH
12939: LD_STRING 
12941: ST_TO_ADDR
// hc_noskilllimit := true ;
12942: LD_ADDR_OWVAR 76
12946: PUSH
12947: LD_INT 1
12949: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
12950: LD_ADDR_OWVAR 31
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 30
12960: PUSH
12961: LD_INT 30
12963: PUSH
12964: LD_INT 30
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: ST_TO_ADDR
// un := CreateHuman ;
12973: LD_ADDR_VAR 0 3
12977: PUSH
12978: CALL_OW 44
12982: ST_TO_ADDR
// hc_noskilllimit := false ;
12983: LD_ADDR_OWVAR 76
12987: PUSH
12988: LD_INT 0
12990: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12991: LD_VAR 0 3
12995: PPUSH
12996: LD_INT 1
12998: PPUSH
12999: CALL_OW 51
// p := 0 ;
13003: LD_ADDR_VAR 0 2
13007: PUSH
13008: LD_INT 0
13010: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13011: LD_INT 35
13013: PPUSH
13014: CALL_OW 67
// p := p + 1 ;
13018: LD_ADDR_VAR 0 2
13022: PUSH
13023: LD_VAR 0 2
13027: PUSH
13028: LD_INT 1
13030: PLUS
13031: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
13032: LD_VAR 0 3
13036: PPUSH
13037: CALL_OW 256
13041: PUSH
13042: LD_INT 1000
13044: LESS
13045: IFFALSE 13059
// SetLives ( un , 1000 ) ;
13047: LD_VAR 0 3
13051: PPUSH
13052: LD_INT 1000
13054: PPUSH
13055: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
13059: LD_VAR 0 3
13063: PPUSH
13064: LD_INT 81
13066: PUSH
13067: LD_OWVAR 2
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 91
13078: PUSH
13079: LD_VAR 0 3
13083: PUSH
13084: LD_INT 30
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: PPUSH
13096: CALL_OW 69
13100: PPUSH
13101: LD_VAR 0 3
13105: PPUSH
13106: CALL_OW 74
13110: PPUSH
13111: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
13115: LD_VAR 0 2
13119: PUSH
13120: LD_INT 60
13122: GREATER
13123: PUSH
13124: LD_VAR 0 3
13128: PPUSH
13129: CALL_OW 301
13133: OR
13134: IFFALSE 13011
// if un then
13136: LD_VAR 0 3
13140: IFFALSE 13151
// RemoveUnit ( un ) ;
13142: LD_VAR 0 3
13146: PPUSH
13147: CALL_OW 64
// end ;
13151: PPOPN 3
13153: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
13154: LD_INT 0
13156: PPUSH
// case cmd of 301 :
13157: LD_VAR 0 1
13161: PUSH
13162: LD_INT 301
13164: DOUBLE
13165: EQUAL
13166: IFTRUE 13170
13168: GO 13202
13170: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
13171: LD_VAR 0 6
13175: PPUSH
13176: LD_VAR 0 7
13180: PPUSH
13181: LD_VAR 0 8
13185: PPUSH
13186: LD_VAR 0 4
13190: PPUSH
13191: LD_VAR 0 5
13195: PPUSH
13196: CALL 14403 0 5
13200: GO 13323
13202: LD_INT 302
13204: DOUBLE
13205: EQUAL
13206: IFTRUE 13210
13208: GO 13247
13210: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
13211: LD_VAR 0 6
13215: PPUSH
13216: LD_VAR 0 7
13220: PPUSH
13221: LD_VAR 0 8
13225: PPUSH
13226: LD_VAR 0 9
13230: PPUSH
13231: LD_VAR 0 4
13235: PPUSH
13236: LD_VAR 0 5
13240: PPUSH
13241: CALL 14494 0 6
13245: GO 13323
13247: LD_INT 303
13249: DOUBLE
13250: EQUAL
13251: IFTRUE 13255
13253: GO 13292
13255: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
13256: LD_VAR 0 6
13260: PPUSH
13261: LD_VAR 0 7
13265: PPUSH
13266: LD_VAR 0 8
13270: PPUSH
13271: LD_VAR 0 9
13275: PPUSH
13276: LD_VAR 0 4
13280: PPUSH
13281: LD_VAR 0 5
13285: PPUSH
13286: CALL 13328 0 6
13290: GO 13323
13292: LD_INT 304
13294: DOUBLE
13295: EQUAL
13296: IFTRUE 13300
13298: GO 13322
13300: POP
// hHackTeleport ( unit , x , y ) ; end ;
13301: LD_VAR 0 2
13305: PPUSH
13306: LD_VAR 0 4
13310: PPUSH
13311: LD_VAR 0 5
13315: PPUSH
13316: CALL 15087 0 3
13320: GO 13323
13322: POP
// end ;
13323: LD_VAR 0 12
13327: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
13328: LD_INT 0
13330: PPUSH
13331: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
13332: LD_VAR 0 1
13336: PUSH
13337: LD_INT 1
13339: LESS
13340: PUSH
13341: LD_VAR 0 1
13345: PUSH
13346: LD_INT 3
13348: GREATER
13349: OR
13350: PUSH
13351: LD_VAR 0 5
13355: PPUSH
13356: LD_VAR 0 6
13360: PPUSH
13361: CALL_OW 428
13365: OR
13366: IFFALSE 13370
// exit ;
13368: GO 14090
// uc_side := your_side ;
13370: LD_ADDR_OWVAR 20
13374: PUSH
13375: LD_OWVAR 2
13379: ST_TO_ADDR
// uc_nation := nation ;
13380: LD_ADDR_OWVAR 21
13384: PUSH
13385: LD_VAR 0 1
13389: ST_TO_ADDR
// bc_level = 1 ;
13390: LD_ADDR_OWVAR 43
13394: PUSH
13395: LD_INT 1
13397: ST_TO_ADDR
// case btype of 1 :
13398: LD_VAR 0 2
13402: PUSH
13403: LD_INT 1
13405: DOUBLE
13406: EQUAL
13407: IFTRUE 13411
13409: GO 13422
13411: POP
// bc_type := b_depot ; 2 :
13412: LD_ADDR_OWVAR 42
13416: PUSH
13417: LD_INT 0
13419: ST_TO_ADDR
13420: GO 14034
13422: LD_INT 2
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13441
13430: POP
// bc_type := b_warehouse ; 3 :
13431: LD_ADDR_OWVAR 42
13435: PUSH
13436: LD_INT 1
13438: ST_TO_ADDR
13439: GO 14034
13441: LD_INT 3
13443: DOUBLE
13444: EQUAL
13445: IFTRUE 13449
13447: GO 13460
13449: POP
// bc_type := b_lab ; 4 .. 9 :
13450: LD_ADDR_OWVAR 42
13454: PUSH
13455: LD_INT 6
13457: ST_TO_ADDR
13458: GO 14034
13460: LD_INT 4
13462: DOUBLE
13463: GREATEREQUAL
13464: IFFALSE 13472
13466: LD_INT 9
13468: DOUBLE
13469: LESSEQUAL
13470: IFTRUE 13474
13472: GO 13526
13474: POP
// begin bc_type := b_lab_half ;
13475: LD_ADDR_OWVAR 42
13479: PUSH
13480: LD_INT 7
13482: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
13483: LD_ADDR_OWVAR 44
13487: PUSH
13488: LD_INT 10
13490: PUSH
13491: LD_INT 11
13493: PUSH
13494: LD_INT 12
13496: PUSH
13497: LD_INT 15
13499: PUSH
13500: LD_INT 14
13502: PUSH
13503: LD_INT 13
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: LIST
13513: PUSH
13514: LD_VAR 0 2
13518: PUSH
13519: LD_INT 3
13521: MINUS
13522: ARRAY
13523: ST_TO_ADDR
// end ; 10 .. 13 :
13524: GO 14034
13526: LD_INT 10
13528: DOUBLE
13529: GREATEREQUAL
13530: IFFALSE 13538
13532: LD_INT 13
13534: DOUBLE
13535: LESSEQUAL
13536: IFTRUE 13540
13538: GO 13617
13540: POP
// begin bc_type := b_lab_full ;
13541: LD_ADDR_OWVAR 42
13545: PUSH
13546: LD_INT 8
13548: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
13549: LD_ADDR_OWVAR 44
13553: PUSH
13554: LD_INT 10
13556: PUSH
13557: LD_INT 12
13559: PUSH
13560: LD_INT 14
13562: PUSH
13563: LD_INT 13
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: PUSH
13572: LD_VAR 0 2
13576: PUSH
13577: LD_INT 9
13579: MINUS
13580: ARRAY
13581: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
13582: LD_ADDR_OWVAR 45
13586: PUSH
13587: LD_INT 11
13589: PUSH
13590: LD_INT 15
13592: PUSH
13593: LD_INT 12
13595: PUSH
13596: LD_INT 15
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: PUSH
13605: LD_VAR 0 2
13609: PUSH
13610: LD_INT 9
13612: MINUS
13613: ARRAY
13614: ST_TO_ADDR
// end ; 14 :
13615: GO 14034
13617: LD_INT 14
13619: DOUBLE
13620: EQUAL
13621: IFTRUE 13625
13623: GO 13636
13625: POP
// bc_type := b_workshop ; 15 :
13626: LD_ADDR_OWVAR 42
13630: PUSH
13631: LD_INT 2
13633: ST_TO_ADDR
13634: GO 14034
13636: LD_INT 15
13638: DOUBLE
13639: EQUAL
13640: IFTRUE 13644
13642: GO 13655
13644: POP
// bc_type := b_factory ; 16 :
13645: LD_ADDR_OWVAR 42
13649: PUSH
13650: LD_INT 3
13652: ST_TO_ADDR
13653: GO 14034
13655: LD_INT 16
13657: DOUBLE
13658: EQUAL
13659: IFTRUE 13663
13661: GO 13674
13663: POP
// bc_type := b_ext_gun ; 17 :
13664: LD_ADDR_OWVAR 42
13668: PUSH
13669: LD_INT 17
13671: ST_TO_ADDR
13672: GO 14034
13674: LD_INT 17
13676: DOUBLE
13677: EQUAL
13678: IFTRUE 13682
13680: GO 13710
13682: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
13683: LD_ADDR_OWVAR 42
13687: PUSH
13688: LD_INT 19
13690: PUSH
13691: LD_INT 23
13693: PUSH
13694: LD_INT 19
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: LIST
13701: PUSH
13702: LD_VAR 0 1
13706: ARRAY
13707: ST_TO_ADDR
13708: GO 14034
13710: LD_INT 18
13712: DOUBLE
13713: EQUAL
13714: IFTRUE 13718
13716: GO 13729
13718: POP
// bc_type := b_ext_radar ; 19 :
13719: LD_ADDR_OWVAR 42
13723: PUSH
13724: LD_INT 20
13726: ST_TO_ADDR
13727: GO 14034
13729: LD_INT 19
13731: DOUBLE
13732: EQUAL
13733: IFTRUE 13737
13735: GO 13748
13737: POP
// bc_type := b_ext_radio ; 20 :
13738: LD_ADDR_OWVAR 42
13742: PUSH
13743: LD_INT 22
13745: ST_TO_ADDR
13746: GO 14034
13748: LD_INT 20
13750: DOUBLE
13751: EQUAL
13752: IFTRUE 13756
13754: GO 13767
13756: POP
// bc_type := b_ext_siberium ; 21 :
13757: LD_ADDR_OWVAR 42
13761: PUSH
13762: LD_INT 21
13764: ST_TO_ADDR
13765: GO 14034
13767: LD_INT 21
13769: DOUBLE
13770: EQUAL
13771: IFTRUE 13775
13773: GO 13786
13775: POP
// bc_type := b_ext_computer ; 22 :
13776: LD_ADDR_OWVAR 42
13780: PUSH
13781: LD_INT 24
13783: ST_TO_ADDR
13784: GO 14034
13786: LD_INT 22
13788: DOUBLE
13789: EQUAL
13790: IFTRUE 13794
13792: GO 13805
13794: POP
// bc_type := b_ext_track ; 23 :
13795: LD_ADDR_OWVAR 42
13799: PUSH
13800: LD_INT 16
13802: ST_TO_ADDR
13803: GO 14034
13805: LD_INT 23
13807: DOUBLE
13808: EQUAL
13809: IFTRUE 13813
13811: GO 13824
13813: POP
// bc_type := b_ext_laser ; 24 :
13814: LD_ADDR_OWVAR 42
13818: PUSH
13819: LD_INT 25
13821: ST_TO_ADDR
13822: GO 14034
13824: LD_INT 24
13826: DOUBLE
13827: EQUAL
13828: IFTRUE 13832
13830: GO 13843
13832: POP
// bc_type := b_control_tower ; 25 :
13833: LD_ADDR_OWVAR 42
13837: PUSH
13838: LD_INT 36
13840: ST_TO_ADDR
13841: GO 14034
13843: LD_INT 25
13845: DOUBLE
13846: EQUAL
13847: IFTRUE 13851
13849: GO 13862
13851: POP
// bc_type := b_breastwork ; 26 :
13852: LD_ADDR_OWVAR 42
13856: PUSH
13857: LD_INT 31
13859: ST_TO_ADDR
13860: GO 14034
13862: LD_INT 26
13864: DOUBLE
13865: EQUAL
13866: IFTRUE 13870
13868: GO 13881
13870: POP
// bc_type := b_bunker ; 27 :
13871: LD_ADDR_OWVAR 42
13875: PUSH
13876: LD_INT 32
13878: ST_TO_ADDR
13879: GO 14034
13881: LD_INT 27
13883: DOUBLE
13884: EQUAL
13885: IFTRUE 13889
13887: GO 13900
13889: POP
// bc_type := b_turret ; 28 :
13890: LD_ADDR_OWVAR 42
13894: PUSH
13895: LD_INT 33
13897: ST_TO_ADDR
13898: GO 14034
13900: LD_INT 28
13902: DOUBLE
13903: EQUAL
13904: IFTRUE 13908
13906: GO 13919
13908: POP
// bc_type := b_armoury ; 29 :
13909: LD_ADDR_OWVAR 42
13913: PUSH
13914: LD_INT 4
13916: ST_TO_ADDR
13917: GO 14034
13919: LD_INT 29
13921: DOUBLE
13922: EQUAL
13923: IFTRUE 13927
13925: GO 13938
13927: POP
// bc_type := b_barracks ; 30 :
13928: LD_ADDR_OWVAR 42
13932: PUSH
13933: LD_INT 5
13935: ST_TO_ADDR
13936: GO 14034
13938: LD_INT 30
13940: DOUBLE
13941: EQUAL
13942: IFTRUE 13946
13944: GO 13957
13946: POP
// bc_type := b_solar_power ; 31 :
13947: LD_ADDR_OWVAR 42
13951: PUSH
13952: LD_INT 27
13954: ST_TO_ADDR
13955: GO 14034
13957: LD_INT 31
13959: DOUBLE
13960: EQUAL
13961: IFTRUE 13965
13963: GO 13976
13965: POP
// bc_type := b_oil_power ; 32 :
13966: LD_ADDR_OWVAR 42
13970: PUSH
13971: LD_INT 26
13973: ST_TO_ADDR
13974: GO 14034
13976: LD_INT 32
13978: DOUBLE
13979: EQUAL
13980: IFTRUE 13984
13982: GO 13995
13984: POP
// bc_type := b_siberite_power ; 33 :
13985: LD_ADDR_OWVAR 42
13989: PUSH
13990: LD_INT 28
13992: ST_TO_ADDR
13993: GO 14034
13995: LD_INT 33
13997: DOUBLE
13998: EQUAL
13999: IFTRUE 14003
14001: GO 14014
14003: POP
// bc_type := b_oil_mine ; 34 :
14004: LD_ADDR_OWVAR 42
14008: PUSH
14009: LD_INT 29
14011: ST_TO_ADDR
14012: GO 14034
14014: LD_INT 34
14016: DOUBLE
14017: EQUAL
14018: IFTRUE 14022
14020: GO 14033
14022: POP
// bc_type := b_siberite_mine ; end ;
14023: LD_ADDR_OWVAR 42
14027: PUSH
14028: LD_INT 30
14030: ST_TO_ADDR
14031: GO 14034
14033: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
14034: LD_ADDR_VAR 0 8
14038: PUSH
14039: LD_VAR 0 5
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: LD_VAR 0 3
14053: PPUSH
14054: CALL_OW 47
14058: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
14059: LD_OWVAR 42
14063: PUSH
14064: LD_INT 32
14066: PUSH
14067: LD_INT 33
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: IN
14074: IFFALSE 14090
// PlaceWeaponTurret ( b , weapon ) ;
14076: LD_VAR 0 8
14080: PPUSH
14081: LD_VAR 0 4
14085: PPUSH
14086: CALL_OW 431
// end ;
14090: LD_VAR 0 7
14094: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
14095: LD_INT 0
14097: PPUSH
14098: PPUSH
14099: PPUSH
14100: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14101: LD_ADDR_VAR 0 4
14105: PUSH
14106: LD_INT 22
14108: PUSH
14109: LD_OWVAR 2
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: PUSH
14118: LD_INT 2
14120: PUSH
14121: LD_INT 30
14123: PUSH
14124: LD_INT 0
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: PUSH
14131: LD_INT 30
14133: PUSH
14134: LD_INT 1
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: EMPTY
14142: LIST
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: ST_TO_ADDR
// if not tmp then
14155: LD_VAR 0 4
14159: NOT
14160: IFFALSE 14164
// exit ;
14162: GO 14223
// for i in tmp do
14164: LD_ADDR_VAR 0 2
14168: PUSH
14169: LD_VAR 0 4
14173: PUSH
14174: FOR_IN
14175: IFFALSE 14221
// for j = 1 to 3 do
14177: LD_ADDR_VAR 0 3
14181: PUSH
14182: DOUBLE
14183: LD_INT 1
14185: DEC
14186: ST_TO_ADDR
14187: LD_INT 3
14189: PUSH
14190: FOR_TO
14191: IFFALSE 14217
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
14193: LD_VAR 0 2
14197: PPUSH
14198: CALL_OW 274
14202: PPUSH
14203: LD_VAR 0 3
14207: PPUSH
14208: LD_INT 99999
14210: PPUSH
14211: CALL_OW 277
14215: GO 14190
14217: POP
14218: POP
14219: GO 14174
14221: POP
14222: POP
// end ;
14223: LD_VAR 0 1
14227: RET
// export function hHackSetLevel10 ; var i , j ; begin
14228: LD_INT 0
14230: PPUSH
14231: PPUSH
14232: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
14233: LD_ADDR_VAR 0 2
14237: PUSH
14238: LD_INT 21
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PPUSH
14248: CALL_OW 69
14252: PUSH
14253: FOR_IN
14254: IFFALSE 14306
// if IsSelected ( i ) then
14256: LD_VAR 0 2
14260: PPUSH
14261: CALL_OW 306
14265: IFFALSE 14304
// begin for j := 1 to 4 do
14267: LD_ADDR_VAR 0 3
14271: PUSH
14272: DOUBLE
14273: LD_INT 1
14275: DEC
14276: ST_TO_ADDR
14277: LD_INT 4
14279: PUSH
14280: FOR_TO
14281: IFFALSE 14302
// SetSkill ( i , j , 10 ) ;
14283: LD_VAR 0 2
14287: PPUSH
14288: LD_VAR 0 3
14292: PPUSH
14293: LD_INT 10
14295: PPUSH
14296: CALL_OW 237
14300: GO 14280
14302: POP
14303: POP
// end ;
14304: GO 14253
14306: POP
14307: POP
// end ;
14308: LD_VAR 0 1
14312: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
14313: LD_INT 0
14315: PPUSH
14316: PPUSH
14317: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
14318: LD_ADDR_VAR 0 2
14322: PUSH
14323: LD_INT 22
14325: PUSH
14326: LD_OWVAR 2
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: LD_INT 21
14337: PUSH
14338: LD_INT 1
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: PPUSH
14349: CALL_OW 69
14353: PUSH
14354: FOR_IN
14355: IFFALSE 14396
// begin for j := 1 to 4 do
14357: LD_ADDR_VAR 0 3
14361: PUSH
14362: DOUBLE
14363: LD_INT 1
14365: DEC
14366: ST_TO_ADDR
14367: LD_INT 4
14369: PUSH
14370: FOR_TO
14371: IFFALSE 14392
// SetSkill ( i , j , 10 ) ;
14373: LD_VAR 0 2
14377: PPUSH
14378: LD_VAR 0 3
14382: PPUSH
14383: LD_INT 10
14385: PPUSH
14386: CALL_OW 237
14390: GO 14370
14392: POP
14393: POP
// end ;
14394: GO 14354
14396: POP
14397: POP
// end ;
14398: LD_VAR 0 1
14402: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
14403: LD_INT 0
14405: PPUSH
// uc_side := your_side ;
14406: LD_ADDR_OWVAR 20
14410: PUSH
14411: LD_OWVAR 2
14415: ST_TO_ADDR
// uc_nation := nation ;
14416: LD_ADDR_OWVAR 21
14420: PUSH
14421: LD_VAR 0 1
14425: ST_TO_ADDR
// InitHc ;
14426: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
14430: LD_INT 0
14432: PPUSH
14433: LD_VAR 0 2
14437: PPUSH
14438: LD_VAR 0 3
14442: PPUSH
14443: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
14447: LD_VAR 0 4
14451: PPUSH
14452: LD_VAR 0 5
14456: PPUSH
14457: CALL_OW 428
14461: PUSH
14462: LD_INT 0
14464: EQUAL
14465: IFFALSE 14489
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
14467: CALL_OW 44
14471: PPUSH
14472: LD_VAR 0 4
14476: PPUSH
14477: LD_VAR 0 5
14481: PPUSH
14482: LD_INT 1
14484: PPUSH
14485: CALL_OW 48
// end ;
14489: LD_VAR 0 6
14493: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
14494: LD_INT 0
14496: PPUSH
14497: PPUSH
// uc_side := your_side ;
14498: LD_ADDR_OWVAR 20
14502: PUSH
14503: LD_OWVAR 2
14507: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
14508: LD_VAR 0 1
14512: PUSH
14513: LD_INT 1
14515: PUSH
14516: LD_INT 2
14518: PUSH
14519: LD_INT 3
14521: PUSH
14522: LD_INT 4
14524: PUSH
14525: LD_INT 5
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: IN
14535: IFFALSE 14547
// uc_nation := nation_american else
14537: LD_ADDR_OWVAR 21
14541: PUSH
14542: LD_INT 1
14544: ST_TO_ADDR
14545: GO 14590
// if chassis in [ 11 , 12 , 13 , 14 ] then
14547: LD_VAR 0 1
14551: PUSH
14552: LD_INT 11
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 13
14560: PUSH
14561: LD_INT 14
14563: PUSH
14564: EMPTY
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: IN
14570: IFFALSE 14582
// uc_nation := nation_arabian else
14572: LD_ADDR_OWVAR 21
14576: PUSH
14577: LD_INT 2
14579: ST_TO_ADDR
14580: GO 14590
// uc_nation := nation_russian ;
14582: LD_ADDR_OWVAR 21
14586: PUSH
14587: LD_INT 3
14589: ST_TO_ADDR
// vc_chassis := chassis ;
14590: LD_ADDR_OWVAR 37
14594: PUSH
14595: LD_VAR 0 1
14599: ST_TO_ADDR
// vc_engine := engine ;
14600: LD_ADDR_OWVAR 39
14604: PUSH
14605: LD_VAR 0 2
14609: ST_TO_ADDR
// vc_control := control ;
14610: LD_ADDR_OWVAR 38
14614: PUSH
14615: LD_VAR 0 3
14619: ST_TO_ADDR
// vc_weapon := weapon ;
14620: LD_ADDR_OWVAR 40
14624: PUSH
14625: LD_VAR 0 4
14629: ST_TO_ADDR
// un := CreateVehicle ;
14630: LD_ADDR_VAR 0 8
14634: PUSH
14635: CALL_OW 45
14639: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
14640: LD_VAR 0 8
14644: PPUSH
14645: LD_INT 0
14647: PPUSH
14648: LD_INT 5
14650: PPUSH
14651: CALL_OW 12
14655: PPUSH
14656: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
14660: LD_VAR 0 8
14664: PPUSH
14665: LD_VAR 0 5
14669: PPUSH
14670: LD_VAR 0 6
14674: PPUSH
14675: LD_INT 1
14677: PPUSH
14678: CALL_OW 48
// end ;
14682: LD_VAR 0 7
14686: RET
// export hInvincible ; every 1 do
14687: GO 14689
14689: DISABLE
// hInvincible := [ ] ;
14690: LD_ADDR_EXP 62
14694: PUSH
14695: EMPTY
14696: ST_TO_ADDR
14697: END
// every 10 do var i ;
14698: GO 14700
14700: DISABLE
14701: LD_INT 0
14703: PPUSH
// begin enable ;
14704: ENABLE
// if not hInvincible then
14705: LD_EXP 62
14709: NOT
14710: IFFALSE 14714
// exit ;
14712: GO 14758
// for i in hInvincible do
14714: LD_ADDR_VAR 0 1
14718: PUSH
14719: LD_EXP 62
14723: PUSH
14724: FOR_IN
14725: IFFALSE 14756
// if GetLives ( i ) < 1000 then
14727: LD_VAR 0 1
14731: PPUSH
14732: CALL_OW 256
14736: PUSH
14737: LD_INT 1000
14739: LESS
14740: IFFALSE 14754
// SetLives ( i , 1000 ) ;
14742: LD_VAR 0 1
14746: PPUSH
14747: LD_INT 1000
14749: PPUSH
14750: CALL_OW 234
14754: GO 14724
14756: POP
14757: POP
// end ;
14758: PPOPN 1
14760: END
// export function hHackInvincible ; var i ; begin
14761: LD_INT 0
14763: PPUSH
14764: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
14765: LD_ADDR_VAR 0 2
14769: PUSH
14770: LD_INT 2
14772: PUSH
14773: LD_INT 21
14775: PUSH
14776: LD_INT 1
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: PUSH
14783: LD_INT 21
14785: PUSH
14786: LD_INT 2
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: LIST
14797: PPUSH
14798: CALL_OW 69
14802: PUSH
14803: FOR_IN
14804: IFFALSE 14865
// if IsSelected ( i ) then
14806: LD_VAR 0 2
14810: PPUSH
14811: CALL_OW 306
14815: IFFALSE 14863
// begin if i in hInvincible then
14817: LD_VAR 0 2
14821: PUSH
14822: LD_EXP 62
14826: IN
14827: IFFALSE 14847
// hInvincible := hInvincible diff i else
14829: LD_ADDR_EXP 62
14833: PUSH
14834: LD_EXP 62
14838: PUSH
14839: LD_VAR 0 2
14843: DIFF
14844: ST_TO_ADDR
14845: GO 14863
// hInvincible := hInvincible union i ;
14847: LD_ADDR_EXP 62
14851: PUSH
14852: LD_EXP 62
14856: PUSH
14857: LD_VAR 0 2
14861: UNION
14862: ST_TO_ADDR
// end ;
14863: GO 14803
14865: POP
14866: POP
// end ;
14867: LD_VAR 0 1
14871: RET
// export function hHackInvisible ; var i , j ; begin
14872: LD_INT 0
14874: PPUSH
14875: PPUSH
14876: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
14877: LD_ADDR_VAR 0 2
14881: PUSH
14882: LD_INT 21
14884: PUSH
14885: LD_INT 1
14887: PUSH
14888: EMPTY
14889: LIST
14890: LIST
14891: PPUSH
14892: CALL_OW 69
14896: PUSH
14897: FOR_IN
14898: IFFALSE 14922
// if IsSelected ( i ) then
14900: LD_VAR 0 2
14904: PPUSH
14905: CALL_OW 306
14909: IFFALSE 14920
// ComForceInvisible ( i ) ;
14911: LD_VAR 0 2
14915: PPUSH
14916: CALL_OW 496
14920: GO 14897
14922: POP
14923: POP
// end ;
14924: LD_VAR 0 1
14928: RET
// export function hHackChangeYourSide ; begin
14929: LD_INT 0
14931: PPUSH
// if your_side = 8 then
14932: LD_OWVAR 2
14936: PUSH
14937: LD_INT 8
14939: EQUAL
14940: IFFALSE 14952
// your_side := 0 else
14942: LD_ADDR_OWVAR 2
14946: PUSH
14947: LD_INT 0
14949: ST_TO_ADDR
14950: GO 14966
// your_side := your_side + 1 ;
14952: LD_ADDR_OWVAR 2
14956: PUSH
14957: LD_OWVAR 2
14961: PUSH
14962: LD_INT 1
14964: PLUS
14965: ST_TO_ADDR
// end ;
14966: LD_VAR 0 1
14970: RET
// export function hHackChangeUnitSide ; var i , j ; begin
14971: LD_INT 0
14973: PPUSH
14974: PPUSH
14975: PPUSH
// for i in all_units do
14976: LD_ADDR_VAR 0 2
14980: PUSH
14981: LD_OWVAR 3
14985: PUSH
14986: FOR_IN
14987: IFFALSE 15065
// if IsSelected ( i ) then
14989: LD_VAR 0 2
14993: PPUSH
14994: CALL_OW 306
14998: IFFALSE 15063
// begin j := GetSide ( i ) ;
15000: LD_ADDR_VAR 0 3
15004: PUSH
15005: LD_VAR 0 2
15009: PPUSH
15010: CALL_OW 255
15014: ST_TO_ADDR
// if j = 8 then
15015: LD_VAR 0 3
15019: PUSH
15020: LD_INT 8
15022: EQUAL
15023: IFFALSE 15035
// j := 0 else
15025: LD_ADDR_VAR 0 3
15029: PUSH
15030: LD_INT 0
15032: ST_TO_ADDR
15033: GO 15049
// j := j + 1 ;
15035: LD_ADDR_VAR 0 3
15039: PUSH
15040: LD_VAR 0 3
15044: PUSH
15045: LD_INT 1
15047: PLUS
15048: ST_TO_ADDR
// SetSide ( i , j ) ;
15049: LD_VAR 0 2
15053: PPUSH
15054: LD_VAR 0 3
15058: PPUSH
15059: CALL_OW 235
// end ;
15063: GO 14986
15065: POP
15066: POP
// end ;
15067: LD_VAR 0 1
15071: RET
// export function hHackFog ; begin
15072: LD_INT 0
15074: PPUSH
// FogOff ( true ) ;
15075: LD_INT 1
15077: PPUSH
15078: CALL_OW 344
// end ;
15082: LD_VAR 0 1
15086: RET
// export function hHackTeleport ( unit , x , y ) ; begin
15087: LD_INT 0
15089: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
15090: LD_VAR 0 1
15094: PPUSH
15095: LD_VAR 0 2
15099: PPUSH
15100: LD_VAR 0 3
15104: PPUSH
15105: LD_INT 1
15107: PPUSH
15108: LD_INT 1
15110: PPUSH
15111: CALL_OW 483
// CenterOnXY ( x , y ) ;
15115: LD_VAR 0 2
15119: PPUSH
15120: LD_VAR 0 3
15124: PPUSH
15125: CALL_OW 84
// end ;
15129: LD_VAR 0 4
15133: RET
